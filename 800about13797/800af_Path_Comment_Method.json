[{
	"Path": "org.klomp.snark.PeerState.requestNextPiece",
	"Comment": "starts requesting first chunk of next piece. returns true ifsomething has been added to the requests, false otherwise.caller should synchronize.",
	"Method": "boolean requestNextPiece(){\r\n    if (bitfield != null) {\r\n        PartialPiece pp = listener.getPartialPiece(peer, bitfield);\r\n        if (pp != null) {\r\n            if (!getRequestedPieces().contains(Integer.valueOf(pp.getPiece()))) {\r\n                Request r = pp.getRequest();\r\n                outstandingRequests.add(r);\r\n                if (!choked)\r\n                    out.sendRequest(r);\r\n                lastRequest = r;\r\n                return true;\r\n            } else {\r\n                if (_log.shouldLog(Log.WARN))\r\n                    _log.warn(\"Got dup from coord: \" + pp);\r\n                pp.release();\r\n            }\r\n        }\r\n    }\r\n    if (outstandingRequests.isEmpty())\r\n        lastRequest = null;\r\n    if (interesting && lastRequest == null) {\r\n        interesting = false;\r\n        out.sendInterest(false);\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(peer + \" nothing more to request, now uninteresting\");\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.i2p.util.I2PSSLSocketFactory.selectCipherSuites",
	"Comment": "select cipher suites to be usedbased on configured inclusion and exclusion listsas well as enabled and supported cipher suite lists.adapted from jetty sslcontextfactory.java",
	"Method": "String[] selectCipherSuites(String[] enabledCipherSuites,String[] supportedCipherSuites){\r\n    return select(enabledCipherSuites, supportedCipherSuites, INCLUDE_CIPHERS, EXCLUDE_CIPHERS);\r\n}"
}, {
	"Path": "net.i2p.router.update.UpdateRunner.update",
	"Comment": "loop through the entire list of update urls. for each one, first get the version from the first 56 bytes and see if it is newer than what we are running now. if it is, get the whole thing.",
	"Method": "void update(){\r\n    boolean shouldProxy;\r\n    String proxyHost;\r\n    int proxyPort;\r\n    boolean isSSL = false;\r\n    if (_method == HTTP) {\r\n        shouldProxy = _context.getProperty(ConfigUpdateHandler.PROP_SHOULD_PROXY, ConfigUpdateHandler.DEFAULT_SHOULD_PROXY);\r\n        if (shouldProxy) {\r\n            proxyHost = _context.getProperty(ConfigUpdateHandler.PROP_PROXY_HOST, ConfigUpdateHandler.DEFAULT_PROXY_HOST);\r\n            proxyPort = ConfigUpdateHandler.proxyPort(_context);\r\n            if (proxyPort == ConfigUpdateHandler.DEFAULT_PROXY_PORT_INT && proxyHost.equals(ConfigUpdateHandler.DEFAULT_PROXY_HOST) && _context.portMapper().getPort(PortMapper.SVC_HTTP_PROXY) < 0) {\r\n                String msg = _t(\"HTTP client proxy tunnel must be running\");\r\n                if (_log.shouldWarn())\r\n                    _log.warn(msg);\r\n                updateStatus(\"<b>\" + msg + \"<\/b>\");\r\n                _mgr.notifyTaskFailed(this, msg, null);\r\n                return;\r\n            }\r\n        } else {\r\n            proxyHost = null;\r\n            proxyPort = 0;\r\n        }\r\n    } else if (_method == HTTP_CLEARNET) {\r\n        shouldProxy = false;\r\n        proxyHost = null;\r\n        proxyPort = 0;\r\n    } else if (_method == HTTPS_CLEARNET) {\r\n        shouldProxy = false;\r\n        proxyHost = null;\r\n        proxyPort = 0;\r\n        isSSL = true;\r\n    } else {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (_urls.isEmpty()) {\r\n        String msg = \"Update source list is empty, cannot download update\";\r\n        updateStatus(\"<b>\" + msg + \"<\/b>\");\r\n        _log.error(msg);\r\n        _mgr.notifyTaskFailed(this, msg, null);\r\n        return;\r\n    }\r\n    for (URI uri : _urls) {\r\n        _currentURI = uri;\r\n        String updateURL = uri.toString();\r\n        if ((_method == HTTP && !\"http\".equals(uri.getScheme())) || (_method == HTTP_CLEARNET && !\"http\".equals(uri.getScheme())) || (_method == HTTPS_CLEARNET && !\"https\".equals(uri.getScheme())) || uri.getHost() == null || (_method != HTTP && uri.getHost().toLowerCase(Locale.US).endsWith(\".i2p\"))) {\r\n            if (_log.shouldLog(Log.WARN))\r\n                _log.warn(\"Bad update URI \" + uri + \" for method \" + _method);\r\n            continue;\r\n        }\r\n        updateStatus(\"<b>\" + _t(\"Updating from {0}\", linkify(updateURL)) + \"<\/b>\");\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"Selected update URL: \" + updateURL);\r\n        _newVersion = null;\r\n        if (!isSSL) {\r\n            _isPartial = true;\r\n            _baos.reset();\r\n            try {\r\n                _get = new PartialEepGet(_context, proxyHost, proxyPort, _baos, updateURL, TrustedUpdate.HEADER_BYTES);\r\n                _get.addStatusListener(UpdateRunner.this);\r\n                _get.fetch(CONNECT_TIMEOUT);\r\n            } catch (Throwable t) {\r\n            }\r\n            _isPartial = false;\r\n            if (_newVersion == null)\r\n                continue;\r\n        }\r\n        try {\r\n            if (shouldProxy)\r\n                _get = new EepGet(_context, proxyHost, proxyPort, 40, _updateFile, updateURL, false);\r\n            else if (isSSL)\r\n                _get = new SSLEepGet(_context, _updateFile, updateURL);\r\n            else\r\n                _get = new EepGet(_context, 1, _updateFile, updateURL, false);\r\n            _get.addStatusListener(UpdateRunner.this);\r\n            _get.fetch(CONNECT_TIMEOUT, -1, shouldProxy ? INACTIVITY_TIMEOUT : NOPROXY_INACTIVITY_TIMEOUT);\r\n        } catch (Throwable t) {\r\n            _log.error(\"Error updating\", t);\r\n        }\r\n        if (this.done)\r\n            break;\r\n    }\r\n    (new File(_updateFile)).delete();\r\n    if (!this.done)\r\n        _mgr.notifyTaskFailed(this, \"\", null);\r\n}"
}, {
	"Path": "net.i2p.data.i2np.DatabaseStoreMessage.writeMessageBody",
	"Comment": "write the message body to the output array, starting at the given index",
	"Method": "int writeMessageBody(byte out,int curIndex){\r\n    if (_dbEntry == null)\r\n        throw new I2NPMessageException(\"Missing entry\");\r\n    int type = _dbEntry.getType();\r\n    if (type != DatabaseEntry.KEY_TYPE_ROUTERINFO && !_dbEntry.isLeaseSet())\r\n        throw new I2NPMessageException(\"Invalid key type \" + type);\r\n    System.arraycopy(getKey().getData(), 0, out, curIndex, Hash.HASH_LENGTH);\r\n    curIndex += Hash.HASH_LENGTH;\r\n    out[curIndex++] = (byte) type;\r\n    DataHelper.toLong(out, curIndex, 4, _replyToken);\r\n    curIndex += 4;\r\n    if (_replyToken > 0) {\r\n        long replyTunnel = 0;\r\n        if (_replyTunnel != null)\r\n            replyTunnel = _replyTunnel.getTunnelId();\r\n        DataHelper.toLong(out, curIndex, 4, replyTunnel);\r\n        curIndex += 4;\r\n        System.arraycopy(_replyGateway.getData(), 0, out, curIndex, Hash.HASH_LENGTH);\r\n        curIndex += Hash.HASH_LENGTH;\r\n    }\r\n    if (type == DatabaseEntry.KEY_TYPE_ROUTERINFO) {\r\n        DataHelper.toLong(out, curIndex, 2, _byteCache.length);\r\n        curIndex += 2;\r\n    }\r\n    System.arraycopy(_byteCache, 0, out, curIndex, _byteCache.length);\r\n    curIndex += _byteCache.length;\r\n    return curIndex;\r\n}"
}, {
	"Path": "io.helidon.webserver.netty.OriginThreadPublisher.isCompleted",
	"Comment": "indicates that the only one possible associated subscriber has been completed.",
	"Method": "boolean isCompleted(){\r\n    return completed;\r\n}"
}, {
	"Path": "com.spotify.heroic.requestcondition.ClientId.matches",
	"Comment": "match the httpcontext and optionally provide a feature set to apply to a request.",
	"Method": "boolean matches(QueryContext context){\r\n    return context.getHttpContext().flatMap(httpContext -> httpContext.getClientId().map(this.clientId::equals)).orElse(false);\r\n}"
}, {
	"Path": "net.i2p.data.i2cp.I2CPMessageReader.startReading",
	"Comment": "instruct the reader to begin reading messages off the stream",
	"Method": "void startReading(){\r\n    _readerThread.start();\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.Connection.closeReceived",
	"Comment": "notify that a close was received. called by cph. may be called multiple times.",
	"Method": "void closeReceived(){\r\n    if (_closeReceivedOn.compareAndSet(0, _context.clock().now())) {\r\n        _inputStream.closeReceived();\r\n        if (_closeSentOn.get() > 0) {\r\n            disconnect(true);\r\n        } else {\r\n            synchronized (_connectLock) {\r\n                _connectLock.notifyAll();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.helidon.security.Security.environmentBuilder",
	"Comment": "security environment builder, to be used to createenvironment for evaluating security in integration components.",
	"Method": "SecurityEnvironment.Builder environmentBuilder(){\r\n    return SecurityEnvironment.builder(serverTime);\r\n}"
}, {
	"Path": "io.helidon.webserver.testsupport.RouteMock.before",
	"Comment": "executes this handler before first matched handler. executed only if some handler is matched.",
	"Method": "RouteMock before(Handler handler){\r\n    beforeHandlers.add(handler);\r\n    return this;\r\n}"
}, {
	"Path": "net.i2p.router.transport.ntcp.NTCPConnection.enqueueInfoMessage",
	"Comment": "inject a databasestoremessage with our routerinfo. ntcp 1 or 2. externally, this is only called by ntcptransport for outbound cons, before the con is established, but we know what version it is. internally, may be called for outbound or inbound, but only after the con is established, so we know what the version is.",
	"Method": "void enqueueInfoMessage(){\r\n    if (_version == 1) {\r\n        enqueueInfoMessageNTCP1();\r\n    } else if (_isInbound) {\r\n        sendOurRouterInfo(false);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.util.RandomSource.nextBytes",
	"Comment": "not part of java.util.securerandom, but added since fortuna supports it.this code unused, see fortunarandomsource override",
	"Method": "void nextBytes(byte buf,int offset,int length){\r\n    if (offset == 0 && buf.length == length) {\r\n        nextBytes(buf);\r\n    } else {\r\n        byte[] tmp = new byte[length];\r\n        nextBytes(tmp);\r\n        System.arraycopy(tmp, 0, buf, offset, length);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.RouterContext.jobQueue",
	"Comment": "the actual driver of the router, where all jobs are enqueued and processed.",
	"Method": "JobQueue jobQueue(){\r\n    return _jobQueue;\r\n}"
}, {
	"Path": "net.i2p.data.i2cp.MessagePayloadMessage.writeMessage",
	"Comment": "write out the full message to the stream, including the 4 byte size and 1 byte type header.",
	"Method": "void writeMessage(OutputStream out){\r\n    if (_sessionId <= 0)\r\n        throw new I2CPMessageException(\"Unable to write out the message, as the session ID has not been defined\");\r\n    if (_messageId < 0)\r\n        throw new I2CPMessageException(\"Unable to write out the message, as the message ID has not been defined\");\r\n    if (_payload == null)\r\n        throw new I2CPMessageException(\"Unable to write out the message, as the payload has not been defined\");\r\n    int size = 2 + 4 + 4 + _payload.getSize();\r\n    try {\r\n        DataHelper.writeLong(out, 4, size);\r\n        out.write((byte) MESSAGE_TYPE);\r\n        DataHelper.writeLong(out, 2, _sessionId);\r\n        DataHelper.writeLong(out, 4, _messageId);\r\n        DataHelper.writeLong(out, 4, _payload.getSize());\r\n        out.write(_payload.getEncryptedData());\r\n    } catch (DataFormatException dfe) {\r\n        throw new I2CPMessageException(\"Unable to write the message length or type\", dfe);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterInfo.isValid",
	"Comment": "determine whether this router info is authorized with a valid signature",
	"Method": "boolean isValid(){\r\n    if (!_validated)\r\n        doValidate();\r\n    return _isValid;\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.settings.IgnoreSettings.isInformTrackedIgnored",
	"Comment": "inform user about the tracked and ignored files in the project.",
	"Method": "boolean isInformTrackedIgnored(){\r\n    return informTrackedIgnored;\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.PacketQueue.enqueue",
	"Comment": "add a new packet to be sent out asap.this updates the acks.keys and tags disabled since dropped in i2psession",
	"Method": "boolean enqueue(PacketLocal packet){\r\n    if (_dead)\r\n        return false;\r\n    if (packet.getAckTime() > 0) {\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"Not resending \" + packet);\r\n        return false;\r\n    }\r\n    Connection con = packet.getConnection();\r\n    if (con != null) {\r\n        con.getInputStream().updateAcks(packet);\r\n    }\r\n    ByteArray ba = _cache.acquire();\r\n    byte[] buf = ba.getData();\r\n    long begin = 0;\r\n    long end = 0;\r\n    boolean sent = false;\r\n    try {\r\n        int size = 0;\r\n        if (packet.shouldSign())\r\n            size = packet.writeSignedPacket(buf, 0);\r\n        else\r\n            size = packet.writePacket(buf, 0);\r\n        if (packet.getAckTime() > 0)\r\n            return false;\r\n        begin = _context.clock().now();\r\n        long expires = 0;\r\n        Connection.ResendPacketEvent rpe = (Connection.ResendPacketEvent) packet.getResendEvent();\r\n        if (rpe != null)\r\n            expires = rpe.getNextSendTime() - 500;\r\n        SendMessageOptions options = new SendMessageOptions();\r\n        if (expires > 0)\r\n            options.setDate(expires);\r\n        boolean listenForStatus = false;\r\n        if (packet.isFlagSet(FLAGS_FINAL_TAGS)) {\r\n            if (packet.isFlagSet(Packet.FLAG_ECHO)) {\r\n                if (packet.getSendStreamId() <= 0)\r\n                    options.setSendLeaseSet(false);\r\n            } else {\r\n                options.setSendLeaseSet(false);\r\n            }\r\n            int sendTags = FINAL_TAGS_TO_SEND;\r\n            int tagThresh = FINAL_TAG_THRESHOLD;\r\n            if (con != null) {\r\n                ConnectionOptions copts = con.getOptions();\r\n                int cSendTags = copts.getTagsToSend();\r\n                int cTagThresh = copts.getTagThreshold();\r\n                if (cSendTags < sendTags)\r\n                    sendTags = cSendTags;\r\n                if (cTagThresh < tagThresh)\r\n                    tagThresh = cTagThresh;\r\n            }\r\n            options.setTagsToSend(sendTags);\r\n            options.setTagThreshold(tagThresh);\r\n            options.setGzip(packet.getPayloadSize() > 50);\r\n        } else if (packet.isFlagSet(FLAGS_INITIAL_TAGS)) {\r\n            if (con != null) {\r\n                if (con.isInbound())\r\n                    options.setSendLeaseSet(false);\r\n                else if (ENABLE_STATUS_LISTEN)\r\n                    listenForStatus = true;\r\n            }\r\n            int sendTags = INITIAL_TAGS_TO_SEND;\r\n            int tagThresh = MIN_TAG_THRESHOLD;\r\n            if (con != null) {\r\n                ConnectionOptions copts = con.getOptions();\r\n                int cSendTags = copts.getTagsToSend();\r\n                int cTagThresh = copts.getTagThreshold();\r\n                if (cSendTags < sendTags)\r\n                    sendTags = cSendTags;\r\n                if (cTagThresh < tagThresh)\r\n                    tagThresh = cTagThresh;\r\n            }\r\n            options.setTagsToSend(sendTags);\r\n            options.setTagThreshold(tagThresh);\r\n            options.setGzip(packet.getPayloadSize() > 50);\r\n        } else {\r\n            if (con != null) {\r\n                if (con.isInbound() && con.getLifetime() < 2 * 60 * 1000)\r\n                    options.setSendLeaseSet(false);\r\n                ConnectionOptions copts = con.getOptions();\r\n                int wdw = copts.getWindowSize();\r\n                int thresh = Math.max(MIN_TAG_THRESHOLD, wdw * TAG_WINDOW_FACTOR);\r\n                int cTagThresh = copts.getTagThreshold();\r\n                if (cTagThresh < thresh)\r\n                    thresh = cTagThresh;\r\n                options.setTagThreshold(thresh);\r\n            }\r\n        }\r\n        I2PSession session = packet.getSession();\r\n        if (listenForStatus) {\r\n            long id = session.sendMessage(packet.getTo(), buf, 0, size, I2PSession.PROTO_STREAMING, packet.getLocalPort(), packet.getRemotePort(), options, this);\r\n            _messageStatusMap.put(Long.valueOf(id), con);\r\n            sent = true;\r\n        } else {\r\n            sent = session.sendMessage(packet.getTo(), buf, 0, size, I2PSession.PROTO_STREAMING, packet.getLocalPort(), packet.getRemotePort(), options);\r\n        }\r\n        end = _context.clock().now();\r\n        if ((end - begin > 1000) && (_log.shouldLog(Log.WARN)))\r\n            _log.warn(\"Took \" + (end - begin) + \"ms to sendMessage(...) \" + packet);\r\n        _context.statManager().addRateData(\"stream.con.sendMessageSize\", size, packet.getLifetime());\r\n        if (packet.getNumSends() > 1)\r\n            _context.statManager().addRateData(\"stream.con.sendDuplicateSize\", size, packet.getLifetime());\r\n        if (con != null) {\r\n            con.incrementBytesSent(size);\r\n            if (packet.getNumSends() > 1)\r\n                con.incrementDupMessagesSent(1);\r\n        }\r\n    } catch (I2PSessionException ise) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Unable to send the packet \" + packet, ise);\r\n    }\r\n    _cache.release(ba);\r\n    if (!sent) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Send failed for \" + packet);\r\n        if (con != null)\r\n            con.disconnect(false);\r\n    } else {\r\n        packet.incrementSends();\r\n        if (con != null && _log.shouldDebug()) {\r\n            String suffix = \"wsize \" + con.getOptions().getWindowSize() + \" rto \" + con.getOptions().getRTO();\r\n            con.getConnectionManager().getPacketHandler().displayPacket(packet, \"SEND\", suffix);\r\n        }\r\n        if (I2PSocketManagerFull.pcapWriter != null && _context.getBooleanProperty(I2PSocketManagerFull.PROP_PCAP))\r\n            packet.logTCPDump();\r\n    }\r\n    if ((packet.getSequenceNum() == 0) && (!packet.isFlagSet(Packet.FLAG_SYNCHRONIZE))) {\r\n        packet.releasePayload();\r\n    } else if (packet.isFlagSet(Packet.FLAG_ECHO) && !packet.isFlagSet(Packet.FLAG_SIGNATURE_INCLUDED)) {\r\n        packet.releasePayload();\r\n    } else if (packet.isFlagSet(Packet.FLAG_RESET)) {\r\n        packet.releasePayload();\r\n    }\r\n    return sent;\r\n}"
}, {
	"Path": "i2p.susi.webmail.WebMail.processComposeButtons",
	"Comment": "process buttons of compose message dialog\tthis must be called before processstatechangebuttons so we can add the attachment before send",
	"Method": "State processComposeButtons(SessionObject sessionObject,RequestWrapper request){\r\n    State state = null;\r\n    String filename = request.getFilename(NEW_FILENAME);\r\n    if (filename != null && (buttonPressed(request, NEW_UPLOAD) || buttonPressed(request, SEND))) {\r\n        int i = filename.lastIndexOf('/');\r\n        if (i != -1)\r\n            filename = filename.substring(i + 1);\r\n        i = filename.lastIndexOf('\\\\');\r\n        if (i != -1)\r\n            filename = filename.substring(i + 1);\r\n        if (filename != null && filename.length() > 0) {\r\n            InputStream in = null;\r\n            OutputStream out = null;\r\n            I2PAppContext ctx = I2PAppContext.getGlobalContext();\r\n            String temp = \"susimail-attachment-\" + ctx.random().nextLong();\r\n            File f;\r\n            MailCache drafts = sessionObject.caches.get(DIR_DRAFTS);\r\n            if (drafts != null) {\r\n                f = new File(drafts.getAttachmentDir(), temp);\r\n            } else {\r\n                f = new File(ctx.getTempDir(), temp);\r\n            }\r\n            try {\r\n                in = request.getInputStream(NEW_FILENAME);\r\n                if (in == null)\r\n                    throw new IOException(\"no stream\");\r\n                out = new SecureFileOutputStream(f);\r\n                DataHelper.copy(in, out);\r\n                String contentType = request.getContentType(NEW_FILENAME);\r\n                String encodeTo;\r\n                String ctlc = contentType.toLowerCase(Locale.US);\r\n                if (ctlc.startsWith(\"text/\")) {\r\n                    encodeTo = \"quoted-printable\";\r\n                    if (!ctlc.contains(\"charset=\"))\r\n                        contentType += \"; charset=\\\"utf-8\\\"\";\r\n                } else {\r\n                    encodeTo = \"base64\";\r\n                }\r\n                Encoding encoding = EncodingFactory.getEncoding(encodeTo);\r\n                if (encoding != null) {\r\n                    if (sessionObject.attachments == null)\r\n                        sessionObject.attachments = new ArrayList<Attachment>();\r\n                    sessionObject.attachments.add(new Attachment(filename, contentType, encodeTo, f));\r\n                } else {\r\n                    sessionObject.error += _t(\"No Encoding found for {0}\", encodeTo) + '\\n';\r\n                }\r\n            } catch (IOException e) {\r\n                sessionObject.error += _t(\"Error reading uploaded file: {0}\", e.getMessage()) + '\\n';\r\n                f.delete();\r\n            } finally {\r\n                if (in != null)\r\n                    try {\r\n                        in.close();\r\n                    } catch (IOException ioe) {\r\n                    }\r\n                if (out != null)\r\n                    try {\r\n                        out.close();\r\n                    } catch (IOException ioe) {\r\n                    }\r\n            }\r\n        }\r\n        state = State.NEW;\r\n    } else if (sessionObject.attachments != null && buttonPressed(request, DELETE_ATTACHMENT)) {\r\n        for (String item : getCheckedItems(request)) {\r\n            try {\r\n                int n = Integer.parseInt(item);\r\n                for (int i = 0; i < sessionObject.attachments.size(); i++) {\r\n                    Attachment attachment = sessionObject.attachments.get(i);\r\n                    if (attachment.hashCode() == n) {\r\n                        sessionObject.attachments.remove(i);\r\n                        break;\r\n                    }\r\n                }\r\n            } catch (NumberFormatException nfe) {\r\n            }\r\n        }\r\n        state = State.NEW;\r\n    }\r\n    return state;\r\n}"
}, {
	"Path": "net.i2p.client.impl.I2CPMessageProducer.createLeaseSet",
	"Comment": "in response to a requestleaseset message from the router, send acreateleaseset message back to the router.this method is misnamed, it does not create the leaseset,the caller does that.",
	"Method": "void createLeaseSet(I2PSessionImpl session,LeaseSet leaseSet,SigningPrivateKey signingPriv,PrivateKey priv){\r\n    CreateLeaseSetMessage msg;\r\n    int type = leaseSet.getType();\r\n    if (type == DatabaseEntry.KEY_TYPE_LEASESET)\r\n        msg = new CreateLeaseSetMessage();\r\n    else\r\n        msg = new CreateLeaseSet2Message();\r\n    msg.setLeaseSet(leaseSet);\r\n    msg.setPrivateKey(priv);\r\n    msg.setSigningPrivateKey(signingPriv);\r\n    SessionId sid = session.getSessionId();\r\n    if (sid == null) {\r\n        _log.error(session.toString() + \" create LS w/o session\", new Exception());\r\n        return;\r\n    }\r\n    msg.setSessionId(sid);\r\n    session.sendMessage_unchecked(msg);\r\n}"
}, {
	"Path": "net.i2p.data.i2cp.I2CPMessageReader.pauseReading",
	"Comment": "have the already started reader pause its reading indefinitely",
	"Method": "void pauseReading(){\r\n    _reader.pauseRunner();\r\n}"
}, {
	"Path": "net.i2p.stat.Frequency.getEventCount",
	"Comment": "how many events have occurred within the lifetime of this stat?",
	"Method": "long getEventCount(){\r\n    return _count;\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.web.IndexBean.deleteTunnel",
	"Comment": "stop the tunnel, delete from config, rename the private key file if in the default directory",
	"Method": "String deleteTunnel(){\r\n    if (!_removeConfirmed)\r\n        return \"Please confirm removal\";\r\n    return getMessages(_helper.deleteTunnel(_tunnel, _config.getPrivKeyFile()));\r\n}"
}, {
	"Path": "com.netflix.hollow.api.client.HollowAnnouncementWatcher.triggerAsyncRefreshWithDelay",
	"Comment": "triggers async refresh after the specified number of milliseconds has passed.any subsequent calls for async refresh will not begin until after the specified delayhas completed.",
	"Method": "void triggerAsyncRefreshWithDelay(int delayMillis){\r\n    final HollowClient client = this.client;\r\n    final long targetBeginTime = System.currentTimeMillis() + delayMillis;\r\n    refreshExecutor.execute(new Runnable() {\r\n        public void run() {\r\n            try {\r\n                long delay = targetBeginTime - System.currentTimeMillis();\r\n                if (delay > 0)\r\n                    Thread.sleep(delay);\r\n                client.triggerRefresh();\r\n            } catch (Throwable th) {\r\n                log.log(Level.SEVERE, \"Async refresh failed\", th);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.netflix.hollow.api.client.HollowAnnouncementWatcher.triggerAsyncRefreshWithDelay",
	"Comment": "triggers async refresh after the specified number of milliseconds has passed.any subsequent calls for async refresh will not begin until after the specified delayhas completed.",
	"Method": "void triggerAsyncRefreshWithDelay(int delayMillis){\r\n    try {\r\n        long delay = targetBeginTime - System.currentTimeMillis();\r\n        if (delay > 0)\r\n            Thread.sleep(delay);\r\n        client.triggerRefresh();\r\n    } catch (Throwable th) {\r\n        log.log(Level.SEVERE, \"Async refresh failed\", th);\r\n    }\r\n}"
}, {
	"Path": "org.mitre.dsmiley.httpproxy.ProxyServlet.getContentLength",
	"Comment": "get the header value as a long in order to more correctly proxy very large requests",
	"Method": "long getContentLength(HttpServletRequest request){\r\n    String contentLengthHeader = request.getHeader(\"Content-Length\");\r\n    if (contentLengthHeader != null) {\r\n        return Long.parseLong(contentLengthHeader);\r\n    }\r\n    return -1L;\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.I2PTunnelHTTPServer.setEntry",
	"Comment": "remove the other matching entries and set this entry as the only one.",
	"Method": "void setEntry(Map<String, List<String>> headers,String key,String value){\r\n    List<String> entry = headers.get(key);\r\n    if (entry == null) {\r\n        headers.put(key, entry = new ArrayList<String>(1));\r\n    } else {\r\n        entry.clear();\r\n    }\r\n    entry.add(value);\r\n}"
}, {
	"Path": "io.helidon.security.jersey.SingleSubscriberHolder.get",
	"Comment": "get the stored subscriber.this method blocks indefinitely until a subscriber is registered or the holder has been closed.",
	"Method": "Flow.Subscriber<? super T> get(){\r\n    return subscriber.get();\r\n}"
}, {
	"Path": "io.helidon.webserver.SSLContextBuilder.trustConfig",
	"Comment": "set the trust key configuration to be used to validate certificates.",
	"Method": "SSLContextBuilder trustConfig(KeyConfig trustConfig){\r\n    this.trustConfig = trustConfig;\r\n    return this;\r\n}"
}, {
	"Path": "net.i2p.router.transport.ntcp.NTCPTransport.mayDisconnect",
	"Comment": "tell the transport that we may disconnect from this peer.this is advisory only.",
	"Method": "void mayDisconnect(Hash peer){\r\n    final NTCPConnection con = _conByIdent.get(peer);\r\n    if (con != null && con.isEstablished() && con.getMessagesReceived() <= 2 && con.getMessagesSent() <= 1) {\r\n        con.setMayDisconnect();\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.core.FetchRequest.getConsolFun",
	"Comment": "returns consolitation function to be used during the fetch process.",
	"Method": "String getConsolFun(){\r\n    return consolFun;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerState.getCurrentMACKey",
	"Comment": "the aes key used to verify packets, set only after the connection isestablished.",
	"Method": "SessionKey getCurrentMACKey(){\r\n    return _currentMACKey;\r\n}"
}, {
	"Path": "i2p.susi.util.Folder.getIndexOf",
	"Comment": "gets index of an element in the array regardless of sorting direction.",
	"Method": "int getIndexOf(O element){\r\n    if (elements != null) {\r\n        for (int i = 0; i < elements.length; i++) if (elements[i].equals(element))\r\n            return i;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.spotify.heroic.aggregation.AggregationArguments.throwUnlessEmpty",
	"Comment": "throw an exception unless there are no more arguments and keywords available.",
	"Method": "void throwUnlessEmpty(String name){\r\n    if (args.isEmpty() && kw.isEmpty()) {\r\n        return;\r\n    }\r\n    final List<String> parts = new ArrayList();\r\n    final Joiner on = Joiner.on(\" and \");\r\n    if (!args.isEmpty()) {\r\n        parts.add(args.size() == 1 ? \"argument \" + args.iterator().next() : \"arguments \" + args);\r\n    }\r\n    if (!kw.isEmpty()) {\r\n        parts.add((kw.size() == 1 ? \"keyword \" + kw.keySet().iterator().next() : \"keywords \" + kw.keySet()));\r\n    }\r\n    throw new IllegalStateException(name + \": has trailing \" + on.join(parts));\r\n}"
}, {
	"Path": "org.klomp.snark.web.BasicServlet.getContent",
	"Comment": "get resource to serve.map a path to a resource. the default implementation callshttpcontext.getresource but derived servlets may providetheir own mapping.",
	"Method": "HttpContent getContent(String pathInContext){\r\n    HttpContent r = null;\r\n    if (_warBase != null && pathInContext.startsWith(_warBase)) {\r\n        r = new JarContent(pathInContext);\r\n    } else {\r\n        File f = getResource(pathInContext);\r\n        if (f != null && f.isFile())\r\n            r = new FileContent(f);\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "net.i2p.util.SimpleTimer2.stop",
	"Comment": "stops the simpletimer.subsequent executions should not throw a rejectedexecutionexception.cannot be restarted.",
	"Method": "void stop(){\r\n    _executor.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());\r\n    _executor.shutdownNow();\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.settings.IgnoreSettings.setAddUnversionedFiles",
	"Comment": "sets suggesting of adding unversioned files to the .gitignore file.",
	"Method": "void setAddUnversionedFiles(boolean addUnversionedFiles){\r\n    this.notifyOnChange(KEY.ADD_UNVERSIONED_FILES, this.addUnversionedFiles, addUnversionedFiles);\r\n    this.addUnversionedFiles = addUnversionedFiles;\r\n}"
}, {
	"Path": "org.mitre.dsmiley.httpproxy.ProxyServlet.getConfigParam",
	"Comment": "reads a configuration parameter. by default it reads servlet init parameters butit can be overridden.",
	"Method": "String getConfigParam(String key){\r\n    return getServletConfig().getInitParameter(key);\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterAddress.getExpirationTime",
	"Comment": "retrieve the date after which the address should not be used.if thisis zero, then the address never expires.",
	"Method": "long getExpirationTime(){\r\n    return _expiration;\r\n}"
}, {
	"Path": "net.i2p.router.OutNetMessage.getOnFailedSendJob",
	"Comment": "if the router could not be reached or the expiration passed, this jobis enqueued.",
	"Method": "Job getOnFailedSendJob(){\r\n    return _onFailedSend;\r\n}"
}, {
	"Path": "org.jrobin.data.DataProcessor.chooseOptimalStep",
	"Comment": "tricky and ugly. should be redesigned some time in the future",
	"Method": "void chooseOptimalStep(){\r\n    long newStep = Long.MAX_VALUE;\r\n    for (Def defSource : defSources) {\r\n        long fetchStep = defSource.getFetchStep(), tryStep = fetchStep;\r\n        if (step > 0) {\r\n            tryStep = Math.min(newStep, (((step - 1) / fetchStep) + 1) * fetchStep);\r\n        }\r\n        newStep = Math.min(newStep, tryStep);\r\n    }\r\n    if (newStep != Long.MAX_VALUE) {\r\n        step = newStep;\r\n    } else {\r\n        step = Math.max((tEnd - tStart) / pixelCount, 1);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.data.i2cp.SendMessageMessage.writeMessage",
	"Comment": "write out the full message to the stream, including the 4 byte size and 1 byte type header.override the parent so we can be more mem efficient",
	"Method": "void writeMessage(OutputStream out){\r\n    if (_sessionId == null)\r\n        throw new I2CPMessageException(\"No session ID\");\r\n    if (_destination == null)\r\n        throw new I2CPMessageException(\"No dest\");\r\n    if (_payload == null)\r\n        throw new I2CPMessageException(\"No payload\");\r\n    if (_nonce < 0)\r\n        throw new I2CPMessageException(\"No nonce\");\r\n    int len = 2 + _destination.size() + _payload.getSize() + 4 + 4;\r\n    try {\r\n        DataHelper.writeLong(out, 4, len);\r\n        out.write((byte) getType());\r\n        _sessionId.writeBytes(out);\r\n        _destination.writeBytes(out);\r\n        _payload.writeBytes(out);\r\n        DataHelper.writeLong(out, 4, _nonce);\r\n    } catch (DataFormatException dfe) {\r\n        throw new I2CPMessageException(\"Error writing the msg\", dfe);\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.data.DataProcessor.processData",
	"Comment": "method that should be called once all datasources are defined. data will be fetched from\trrd files, rpn expressions will be calculated, etc.",
	"Method": "void processData(){\r\n    extractDefs();\r\n    fetchRrdData();\r\n    fixZeroEndingTimestamp();\r\n    chooseOptimalStep();\r\n    createTimestamps();\r\n    assignTimestampsToSources();\r\n    normalizeRrdValues();\r\n    calculateNonRrdSources();\r\n}"
}, {
	"Path": "net.i2p.router.OutNetMessage.getOnReplyJob",
	"Comment": "if the messageselector detects a reply, this job is enqueued",
	"Method": "ReplyJob getOnReplyJob(){\r\n    return _onReply;\r\n}"
}, {
	"Path": "net.i2p.data.MetaLeaseSet.hashCode",
	"Comment": "the destination has enough randomness in it to use it by itself for speed",
	"Method": "int hashCode(){\r\n    if (_destination == null)\r\n        return 0;\r\n    return _destination.hashCode();\r\n}"
}, {
	"Path": "io.helidon.security.providers.EvictableCache.remove",
	"Comment": "remove a key from the cache. return the value if it was cached and valid.",
	"Method": "Optional<V> remove(K key){\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "org.klomp.snark.SnarkManager.stop",
	"Comment": "called by the webapp at jetty shutdown. stops all torrents. does not close the tunnel, so the announces have a chance. fix this so an individual webaapp stop will close the tunnel. runs inline.",
	"Method": "void stop(){\r\n    if (_log.shouldDebug())\r\n        _log.debug(\"Snark stop() begin\", new Exception(\"I did it\"));\r\n    if (_umgr != null && _uhandler != null) {\r\n        _umgr.unregister(_uhandler, UpdateType.ROUTER_SIGNED, UpdateMethod.TORRENT);\r\n        _umgr.unregister(_uhandler, UpdateType.ROUTER_SIGNED_SU3, UpdateMethod.TORRENT);\r\n    }\r\n    _running = false;\r\n    _monitor.interrupt();\r\n    _connectionAcceptor.halt();\r\n    _idleChecker.cancel();\r\n    stopAllTorrents(true);\r\n    if (\"i2psnark\".equals(_contextName)) {\r\n        ClientAppManager cmgr = _context.clientAppManager();\r\n        if (cmgr != null)\r\n            cmgr.unregister(this);\r\n    }\r\n    if (_log.shouldWarn())\r\n        _log.warn(\"Snark stop() end\");\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.InboundMessageFragments.rcvData",
	"Comment": "pull the fragments and acks out of the authenticated data packet",
	"Method": "void rcvData(PeerState from,UDPPacketReader.DataReader data){\r\n    int fragmentsIncluded = receiveMessages(from, data);\r\n    int acksIncluded = receiveACKs(from, data);\r\n    from.packetReceived(data.getPacketSize());\r\n    if ((fragmentsIncluded > 0) && (acksIncluded > 0))\r\n        _context.statManager().addRateData(\"udp.receivePiggyback\", acksIncluded, fragmentsIncluded);\r\n}"
}, {
	"Path": "com.docuverse.identicon.NineBlockIdenticonRenderer2.getPatchSize",
	"Comment": "returns the size in pixels at which each patch will be rendered before\tthey are scaled down to requested identicon size.",
	"Method": "float getPatchSize(){\r\n    return patchSize;\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.pool.TunnelPool.buildRateName",
	"Comment": "keep a separate stat for each type, direction, and length of tunnel.",
	"Method": "String buildRateName(){\r\n    if (_settings.isExploratory())\r\n        return \"tunnel.buildRatio.exploratory.\" + (_settings.isInbound() ? \"in\" : \"out\");\r\n    else\r\n        return \"tunnel.buildRatio.l\" + _settings.getLength() + \"v\" + _settings.getLengthVariance() + (_settings.isInbound() ? \".in\" : \".out\");\r\n}"
}, {
	"Path": "net.i2p.router.transport.ntcp.NTCPTransport.returnUnused",
	"Comment": "return an unused dh key builderto be put back onto the queue for reuse.",
	"Method": "void returnUnused(DHSessionKeyBuilder builder){\r\n    _dhFactory.returnUnused(builder);\r\n}"
}, {
	"Path": "net.i2p.router.time.NtpMessage.referenceIdentifierToString",
	"Comment": "returns a string representation of a reference identifier accordingto the rules set out in rfc 2030.",
	"Method": "String referenceIdentifierToString(String referenceIdentifierToString,byte[] ref,short stratum,byte version){\r\n    if (stratum == 0 || stratum == 1) {\r\n        StringBuilder buf = new StringBuilder(4);\r\n        for (int i = 0; i < 4; i++) {\r\n            if (ref[i] == 0)\r\n                break;\r\n            buf.append((char) (ref[i] & 0xff));\r\n        }\r\n        return buf.toString();\r\n    } else if (version == 3) {\r\n        return unsignedByteToShort(ref[0]) + \".\" + unsignedByteToShort(ref[1]) + \".\" + unsignedByteToShort(ref[2]) + \".\" + unsignedByteToShort(ref[3]);\r\n    } else if (version == 4) {\r\n        return \"\" + ((unsignedByteToShort(ref[0]) / 256.0) + (unsignedByteToShort(ref[1]) / 65536.0) + (unsignedByteToShort(ref[2]) / 16777216.0) + (unsignedByteToShort(ref[3]) / 4294967296.0));\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "org.jrobin.core.RrdDef.getStartTime",
	"Comment": "returns starting timestamp for the rrd that should be created.",
	"Method": "long getStartTime(){\r\n    return startTime;\r\n}"
}, {
	"Path": "org.jrobin.core.RrdDb.getDsIndex",
	"Comment": "returns internal index number for the given datasource name. this index is heavily\tused by jrobin.graph package and has no value outside of it.",
	"Method": "int getDsIndex(String dsName){\r\n    for (int i = 0; i < datasources.length; i++) {\r\n        if (datasources[i].getDsName().equals(dsName)) {\r\n            return i;\r\n        }\r\n    }\r\n    throw new RrdException(\"Unknown datasource name: \" + dsName);\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.daemon.IgnoredEditingNotificationProvider.createNotificationPanel",
	"Comment": "creates notification panel for given file and checks if is allowed to show the notification.",
	"Method": "EditorNotificationPanel createNotificationPanel(VirtualFile file,FileEditor fileEditor){\r\n    if (!settings.isNotifyIgnoredEditing() || !manager.isFileIgnored(file) || Properties.isDismissedIgnoredEditingNotification(project, file)) {\r\n        return null;\r\n    }\r\n    final EditorNotificationPanel panel = new EditorNotificationPanel();\r\n    panel.setText(IgnoreBundle.message(\"daemon.ignoredEditing\"));\r\n    panel.createActionLabel(IgnoreBundle.message(\"daemon.ok\"), () -> {\r\n        Properties.setDismissedIgnoredEditingNotification(project, file);\r\n        notifications.updateAllNotifications();\r\n    });\r\n    try {\r\n        panel.icon(Icons.IGNORE);\r\n    } catch (NoSuchMethodError ignored) {\r\n    }\r\n    return panel;\r\n}"
}, {
	"Path": "net.i2p.router.transport.TransportImpl.updateAddress",
	"Comment": "ask the transport to update its address based on current information and return ittransports should override.",
	"Method": "List<RouterAddress> updateAddress(){\r\n    return _currentAddresses;\r\n}"
}, {
	"Path": "com.spotify.heroic.aggregation.simple.QuantileBucket.insertBatch",
	"Comment": "merges items from buffer into the samples array in one pass. this is more efficient thandoing an insert on every item.",
	"Method": "void insertBatch(){\r\n    if (index == 0) {\r\n        return;\r\n    }\r\n    Arrays.sort(batch, 0, index);\r\n    int start = 0;\r\n    if (samples.isEmpty()) {\r\n        samples.add(new SampleItem(batch[0], 0, 1));\r\n        start++;\r\n    }\r\n    final ListIterator<SampleItem> it = samples.listIterator();\r\n    SampleItem prev = it.next();\r\n    for (int i = start; i < index; i++) {\r\n        final double value = batch[i];\r\n        while (it.nextIndex() < samples.size() && prev.value < value) {\r\n            prev = it.next();\r\n        }\r\n        if (prev.value > value) {\r\n            it.previous();\r\n        }\r\n        final int delta = calculateDelta(it.previousIndex(), it.nextIndex());\r\n        final SampleItem next = new SampleItem(value, delta, 1);\r\n        it.add(next);\r\n        prev = next;\r\n    }\r\n    index = 0;\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.DataSource.getMinimumHeartbeat",
	"Comment": "returns the minimum required heartbeat for this data source.",
	"Method": "int getMinimumHeartbeat(){\r\n    return minimumHeartbeat;\r\n}"
}, {
	"Path": "net.nicoulaj.idea.markdown.highlighter.MarkdownSyntaxHighlighter.getTokenHighlights",
	"Comment": "get the list of text attribute keys used for highlighting the specified token type.",
	"Method": "TextAttributesKey[] getTokenHighlights(IElementType tokenType){\r\n    return pack(ATTRIBUTES.get(tokenType));\r\n}"
}, {
	"Path": "com.spotify.heroic.metric.MetricCollection.build",
	"Comment": "build a new metric collection of the given type.this api is not safe, checks must be performed to verify that the encapsulated data type iscorrect.",
	"Method": "MetricCollection build(MetricType key,List<? extends Metric> metrics){\r\n    switch(key) {\r\n        case EVENT:\r\n            return new EventCollection((List<Event>) metrics);\r\n        case CARDINALITY:\r\n            return new CardinalityCollection((List<Payload>) metrics);\r\n        case GROUP:\r\n            return new GroupCollection((List<MetricGroup>) metrics);\r\n        case SPREAD:\r\n            return new SpreadCollection((List<Spread>) metrics);\r\n        case POINT:\r\n            return new PointCollection((List<Point>) metrics);\r\n        default:\r\n            throw new RuntimeException(\"unsupported metric collection\");\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.core.RrdSafeFileBackendFactory.getLockRetryPeriod",
	"Comment": "returns time between two consecutive file locking attempts.",
	"Method": "long getLockRetryPeriod(){\r\n    return lockRetryPeriod;\r\n}"
}, {
	"Path": "net.i2p.router.TunnelPoolSettings.setLengthOverride",
	"Comment": "a temporary length to be used due to network conditions.if less than zero, the standard length will be used.unused until 0.8.11",
	"Method": "void setLengthOverride(int length){\r\n    _lengthOverride = length;\r\n}"
}, {
	"Path": "com.nettgryppa.security.HashCash.equals",
	"Comment": "two objects are considered equal if they are both of type hashcash and have an identical string representation",
	"Method": "boolean equals(Object obj){\r\n    if (obj instanceof HashCash)\r\n        return toString().equals(obj.toString());\r\n    else\r\n        return super.equals(obj);\r\n}"
}, {
	"Path": "com.spotify.heroic.aggregation.simple.FilterAggregation.distributable",
	"Comment": "filtering aggregations are by definition not distributable since they are incapableof making a complete local decision.",
	"Method": "boolean distributable(){\r\n    return false;\r\n}"
}, {
	"Path": "org.klomp.snark.comments.CommentSet.clear",
	"Comment": "actually clears everything, including hidden. resets ratings to zero.",
	"Method": "void clear(){\r\n    if (realSize > 0) {\r\n        modified = true;\r\n        realSize = 0;\r\n        map.clear();\r\n        size = 0;\r\n        myRating = 0;\r\n        totalRating = 0;\r\n        ratingSize = 0;\r\n        totalTextSize = 0;\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.data.DataProcessor.dump",
	"Comment": "dumps timestamps and values of all datasources in a tabelar form. very useful for debugging.",
	"Method": "String dump(){\r\n    String[] names = getSourceNames();\r\n    double[][] values = getValues();\r\n    StringBuilder buffer = new StringBuilder();\r\n    buffer.append(format(\"timestamp\", 12));\r\n    for (String name : names) {\r\n        buffer.append(format(name, 20));\r\n    }\r\n    buffer.append(\"\\n\");\r\n    for (int i = 0; i < timestamps.length; i++) {\r\n        buffer.append(format(\"\" + timestamps[i], 12));\r\n        for (int j = 0; j < names.length; j++) {\r\n            buffer.append(format(Util.formatDouble(values[j][i]), 20));\r\n        }\r\n        buffer.append(\"\\n\");\r\n    }\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "org.jrobin.core.FetchData.getAggregate",
	"Comment": "returns single aggregated value from the fetched data for a single datasource.",
	"Method": "double getAggregate(String dsName,String consolFun,double getAggregate,String dsName,String consolFun,String rpnExpression){\r\n    rpnExpression = rpnExpression.replaceAll(\"value\", dsName);\r\n    return getRpnAggregate(rpnExpression, consolFun);\r\n}"
}, {
	"Path": "org.klomp.snark.PeerConnectionOut.addMessage",
	"Comment": "adds a message to the sendqueue and notifies the method waitingon the sendqueue to change.",
	"Method": "void addMessage(Message m){\r\n    synchronized (sendQueue) {\r\n        sendQueue.offer(m);\r\n        sendQueue.notifyAll();\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.graph.RrdGraphDef.setHeight",
	"Comment": "sets height of the drawing area within the graph. this affects the totalsize of the image.",
	"Method": "void setHeight(int height){\r\n    this.height = height;\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.HopProcessor.process",
	"Comment": "process the data for the current hop, overwriting the original data withwhat should be sent to the next peer.this also validates the previous peer and the iv, making sure its not a repeat and not a loop.",
	"Method": "boolean process(byte orig,int offset,int length,Hash prev){\r\n    if (prev != null) {\r\n        if (_config.getReceiveFrom() == null) {\r\n            _config.setReceiveFrom(prev);\r\n        } else if (!_config.getReceiveFrom().equals(prev)) {\r\n            if (_log.shouldLog(Log.WARN))\r\n                _log.warn(\"Attempted mid-tunnel injection from \" + prev + \", expected \" + _config.getReceiveFrom());\r\n            return false;\r\n        }\r\n    }\r\n    boolean okIV = _validator.receiveIV(orig, offset, orig, offset + IV_LENGTH);\r\n    if (!okIV) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Invalid IV, dropping at hop \" + _config);\r\n        return false;\r\n    }\r\n    updateIV(orig, offset);\r\n    encrypt(orig, offset, length);\r\n    updateIV(orig, offset);\r\n    return true;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.OutboundEstablishState.generateSessionKey",
	"Comment": "generates session key and mac key. caller must synch on this.",
	"Method": "void generateSessionKey(){\r\n    if (_sessionKey != null)\r\n        return;\r\n    if (_keyBuilder == null)\r\n        throw new DHSessionKeyBuilder.InvalidPublicParameterException(\"Illegal state - never generated a key builder\");\r\n    try {\r\n        _keyBuilder.setPeerPublicValue(_receivedY);\r\n    } catch (IllegalStateException ise) {\r\n        throw new DHSessionKeyBuilder.InvalidPublicParameterException(\"reused keys?\", ise);\r\n    }\r\n    _sessionKey = _keyBuilder.getSessionKey();\r\n    ByteArray extra = _keyBuilder.getExtraBytes();\r\n    _macKey = new SessionKey(new byte[SessionKey.KEYSIZE_BYTES]);\r\n    System.arraycopy(extra.getData(), 0, _macKey.getData(), 0, SessionKey.KEYSIZE_BYTES);\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Established outbound keys.  cipher: \" + _sessionKey + \" mac: \" + _macKey);\r\n}"
}, {
	"Path": "com.netflix.hollow.core.write.HollowTypeWriteState.scratch",
	"Comment": "get or create a scratch byte array.each thread will need its own array, so theseare referenced via a threadlocal variable.",
	"Method": "ByteDataBuffer scratch(){\r\n    ByteDataBuffer scratch = serializedScratchSpace.get();\r\n    if (scratch == null) {\r\n        scratch = new ByteDataBuffer(WastefulRecycler.DEFAULT_INSTANCE);\r\n        serializedScratchSpace.set(scratch);\r\n    }\r\n    return scratch;\r\n}"
}, {
	"Path": "net.i2p.router.Router.isAlive",
	"Comment": "true during the initial start, but false during a soft restart.",
	"Method": "boolean isAlive(){\r\n    synchronized (_stateLock) {\r\n        return STATES_ALIVE.contains(_state);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.pool.TunnelPool.curPeriod",
	"Comment": "when selecting tunnels, stick with the same one for a brief period to allow batching if we can.",
	"Method": "long curPeriod(){\r\n    long period = _context.clock().now();\r\n    long ms = period % 1000;\r\n    if (ms > 500)\r\n        period = period - ms + 500;\r\n    else\r\n        period = period - ms;\r\n    return period;\r\n}"
}, {
	"Path": "net.nicoulaj.idea.markdown.file.MarkdownFileTypeFactory.createFileTypes",
	"Comment": "register extensions with the file type declared for markdown.",
	"Method": "void createFileTypes(FileTypeConsumer fileTypeConsumer){\r\n    for (int i = 0; i < MarkdownFileType.DEFAULT_ASSOCIATED_EXTENSIONS.length; i++) {\r\n        fileTypeConsumer.consume(MarkdownFileType.INSTANCE, MarkdownFileType.DEFAULT_ASSOCIATED_EXTENSIONS[i]);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.client.impl.SubSession.bwReceived",
	"Comment": "called by the message handler.this will never happen, as the bw limits message does not contain a session id.",
	"Method": "void bwReceived(int[] i){\r\n    _primary.bwReceived(i);\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.pool.TunnelPool.needFallback",
	"Comment": "do we really need more fallbacks?used to prevent a zillion of them",
	"Method": "boolean needFallback(){\r\n    int needed = getAdjustedTotalQuantity();\r\n    int fallbacks = 0;\r\n    synchronized (_tunnels) {\r\n        for (int i = 0; i < _tunnels.size(); i++) {\r\n            TunnelInfo info = _tunnels.get(i);\r\n            if (info.getLength() <= 1 && ++fallbacks >= needed)\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.klomp.snark.Piece.setRequested",
	"Comment": "since 0.8.3, keep track of who is requesting here,to avoid deadlocks from querying each peer.caller must synchronize",
	"Method": "void setRequested(Peer peer,boolean requested){\r\n    if (requested) {\r\n        if (this.requests == null)\r\n            this.requests = new HashSet<PeerID>(2);\r\n        this.requests.add(peer.getPeerID());\r\n    } else {\r\n        if (this.requests != null)\r\n            this.requests.remove(peer.getPeerID());\r\n    }\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.ConnectionPacketHandler.ack",
	"Comment": "process the acks in a received packet, and adjust our window and rtt",
	"Method": "boolean ack(Connection con,long ackThrough,long nacks,Packet packet,boolean isNew,boolean choke){\r\n    if (ackThrough < 0)\r\n        return false;\r\n    boolean firstAck = isNew && con.getHighestAckedThrough() < 0;\r\n    int numResends = 0;\r\n    List<PacketLocal> acked = null;\r\n    if ((packet != null) && (packet.getSendStreamId() > 0) && (packet.getReceiveStreamId() > 0) && (con != null) && (con.getSendStreamId() > 0) && (con.getReceiveStreamId() > 0) && (packet.getSendStreamId() != Packet.STREAM_ID_UNKNOWN) && (packet.getReceiveStreamId() != Packet.STREAM_ID_UNKNOWN) && (con.getSendStreamId() != Packet.STREAM_ID_UNKNOWN) && (con.getReceiveStreamId() != Packet.STREAM_ID_UNKNOWN))\r\n        acked = con.ackPackets(ackThrough, nacks);\r\n    else\r\n        return false;\r\n    boolean lastPacketAcked = false;\r\n    final boolean receivedAck = con.getOptions().receivedAck();\r\n    if ((acked != null) && (!acked.isEmpty())) {\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(acked.size() + \" of our packets acked with \" + packet);\r\n        int highestRTT = -1;\r\n        for (int i = 0; i < acked.size(); i++) {\r\n            PacketLocal p = acked.get(i);\r\n            final int numSends = p.getNumSends();\r\n            final int ackTime = p.getAckTime();\r\n            if (numSends > 1 && receivedAck)\r\n                numResends++;\r\n            else if (ackTime > highestRTT)\r\n                highestRTT = ackTime;\r\n            _context.statManager().addRateData(\"stream.sendsBeforeAck\", numSends, ackTime);\r\n            if (_log.shouldLog(Log.DEBUG))\r\n                _log.debug(\"Packet acked after \" + ackTime + \"ms: \" + p);\r\n        }\r\n        if (highestRTT > 0) {\r\n            if (_log.shouldLog(Log.INFO)) {\r\n                int oldrtt = con.getOptions().getRTT();\r\n                int oldrto = con.getOptions().getRTO();\r\n                int olddev = con.getOptions().getRTTDev();\r\n                con.getOptions().updateRTT(highestRTT);\r\n                _log.info(\"acked: \" + acked.size() + \" highestRTT: \" + highestRTT + \" RTT: \" + oldrtt + \" -> \" + con.getOptions().getRTT() + \" RTO: \" + oldrto + \" -> \" + con.getOptions().getRTO() + \" Dev: \" + olddev + \" -> \" + con.getOptions().getRTTDev());\r\n            } else {\r\n                con.getOptions().updateRTT(highestRTT);\r\n            }\r\n            if (firstAck) {\r\n                if (con.isInbound())\r\n                    _context.statManager().addRateData(\"stream.con.initialRTT.in\", highestRTT);\r\n                else\r\n                    _context.statManager().addRateData(\"stream.con.initialRTT.out\", highestRTT);\r\n            }\r\n        }\r\n        _context.statManager().addRateData(\"stream.con.packetsAckedPerMessageReceived\", acked.size(), highestRTT);\r\n        if (con.getCloseSentOn() > 0 && con.getUnackedPacketsSent() <= 0)\r\n            lastPacketAcked = true;\r\n    }\r\n    boolean rv = adjustWindow(con, isNew, packet.getSequenceNum(), numResends, (acked != null ? acked.size() : 0), choke);\r\n    if (lastPacketAcked)\r\n        con.notifyLastPacketAcked();\r\n    return rv;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.EstablishmentManager.handlePendingIntro",
	"Comment": "send relayrequests to multiple introducers. this may be called multiple times, it sets the nonce the first time only caller should probably synch on state.",
	"Method": "void handlePendingIntro(OutboundEstablishState state){\r\n    long nonce = state.getIntroNonce();\r\n    if (nonce < 0) {\r\n        OutboundEstablishState old;\r\n        do {\r\n            nonce = _context.random().nextLong(MAX_NONCE);\r\n            old = _liveIntroductions.putIfAbsent(Long.valueOf(nonce), state);\r\n        } while (old != null);\r\n        state.setIntroNonce(nonce);\r\n    }\r\n    _context.statManager().addRateData(\"udp.sendIntroRelayRequest\", 1);\r\n    List<UDPPacket> requests = _builder.buildRelayRequest(_transport, state, _transport.getIntroKey());\r\n    if (requests.isEmpty()) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"No valid introducers! \" + state);\r\n    }\r\n    for (UDPPacket req : requests) {\r\n        _transport.send(req);\r\n    }\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Send intro for \" + state + \" with our intro key as \" + _transport.getIntroKey());\r\n    state.introSent();\r\n}"
}, {
	"Path": "net.i2p.router.transport.ntcp.NTCPConnection.prepareNextWriteFast",
	"Comment": "prepare the next i2np message for transmission.this should be run fromthe writer thread pool. ntcp 1 only.caller must synchronize.",
	"Method": "void prepareNextWriteFast(PrepBuffer buf){\r\n    long now = _context.clock().now();\r\n    if (_nextMetaTime <= now) {\r\n        sendMeta();\r\n        _nextMetaTime = now + (META_FREQUENCY / 2) + _context.random().nextInt(META_FREQUENCY / 2);\r\n    }\r\n    OutNetMessage msg;\r\n    synchronized (_currentOutbound) {\r\n        if (!_currentOutbound.isEmpty()) {\r\n            if (_log.shouldLog(Log.INFO))\r\n                _log.info(\"attempt for multiple outbound messages with \" + _currentOutbound.size() + \" already waiting and \" + _outbound.size() + \" queued\");\r\n            return;\r\n        }\r\n        while (true) {\r\n            msg = _outbound.poll();\r\n            if (msg == null)\r\n                return;\r\n            if (msg.getExpiration() >= now)\r\n                break;\r\n            if (_log.shouldWarn())\r\n                _log.warn(\"dropping message expired on queue: \" + msg + \" on \" + this);\r\n            _transport.afterSend(msg, false, false, msg.getLifetime());\r\n        }\r\n        _currentOutbound.add(msg);\r\n    }\r\n    bufferedPrepare(msg, buf);\r\n    _context.aes().encrypt(buf.unencrypted, 0, buf.encrypted, 0, _sessionKey, _prevWriteEnd, 0, buf.unencryptedLength);\r\n    System.arraycopy(buf.encrypted, buf.encrypted.length - 16, _prevWriteEnd, 0, _prevWriteEnd.length);\r\n    _transport.getPumper().wantsWrite(this, buf.encrypted);\r\n    if (_nextInfoTime <= now) {\r\n        enqueueInfoMessage();\r\n        _nextInfoTime = now + (INFO_FREQUENCY / 2) + _context.random().nextInt(INFO_FREQUENCY);\r\n    }\r\n}"
}, {
	"Path": "io.helidon.security.webserver.WebSecurity.securityDefaults",
	"Comment": "create a new web security instance using the default handler as base defaults for all handlers used.if handlers are loaded from config, than this is the least significant value.",
	"Method": "WebSecurity securityDefaults(SecurityHandler defaultHandler){\r\n    Objects.requireNonNull(defaultHandler, \"Default security handler must not be null\");\r\n    return new WebSecurity(security, config, defaultHandler);\r\n}"
}, {
	"Path": "com.spotify.heroic.common.Throwing.call",
	"Comment": "guarantee that both clauses are called, in the given order. combine any thrown exceptions byadding any prior exceptions as suppressed.this is useful if you want to have multiple potentially throwing blocks of code, andguarantee that all have been called at least once.",
	"Method": "void call(Runnable a,Runnable b){\r\n    RuntimeException inner = null;\r\n    try {\r\n        a.run();\r\n    } catch (final RuntimeException e) {\r\n        inner = e;\r\n    }\r\n    try {\r\n        b.run();\r\n    } catch (final RuntimeException e) {\r\n        if (inner != null) {\r\n            e.addSuppressed(inner);\r\n        }\r\n        throw e;\r\n    }\r\n    if (inner != null) {\r\n        throw inner;\r\n    }\r\n}"
}, {
	"Path": "net.i2p.crypto.KeyGenerator.getPublicKey",
	"Comment": "convert a privatekey to its corresponding publickey.as of 0.9.38, supports enctypes",
	"Method": "PublicKey getPublicKey(PrivateKey priv){\r\n    EncType type = priv.getType();\r\n    byte[] data;\r\n    switch(type) {\r\n        case ELGAMAL_2048:\r\n            BigInteger a = new NativeBigInteger(1, priv.toByteArray());\r\n            BigInteger aalpha = CryptoConstants.elgg.modPow(a, CryptoConstants.elgp);\r\n            try {\r\n                data = SigUtil.rectify(aalpha, PublicKey.KEYSIZE_BYTES);\r\n            } catch (InvalidKeyException ike) {\r\n                throw new IllegalArgumentException(ike);\r\n            }\r\n            break;\r\n        case ECIES_X25519:\r\n            data = new byte[32];\r\n            Curve25519.eval(data, 0, priv.getData(), null);\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Unsupported algorithm\");\r\n    }\r\n    PublicKey pub = new PublicKey(type, data);\r\n    return pub;\r\n}"
}, {
	"Path": "net.i2p.router.TunnelPoolSettings.getLengthOverride",
	"Comment": "a temporary length to be used due to network conditions.if less than zero, the standard length should be used.unused until 0.8.11",
	"Method": "int getLengthOverride(){\r\n    return _lengthOverride;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.IntroductionManager.receiveRelayRequest",
	"Comment": "we are bob and we got this from alice. send a relayintro to charlie and a relayresponse to alice. we should already have a session with charlie, but not necessarily with alice.",
	"Method": "void receiveRelayRequest(RemoteHostId alice,UDPPacketReader reader){\r\n    if (_context.router().isHidden())\r\n        return;\r\n    UDPPacketReader.RelayRequestReader rrReader = reader.getRelayRequestReader();\r\n    long tag = rrReader.readTag();\r\n    int ipSize = rrReader.readIPSize();\r\n    int port = rrReader.readPort();\r\n    byte[] aliceIP = alice.getIP();\r\n    int alicePort = alice.getPort();\r\n    if (!isValid(alice.getIP(), alice.getPort())) {\r\n        if (_log.shouldWarn())\r\n            _log.warn(\"Bad relay req from \" + alice + \" for \" + Addresses.toString(aliceIP, alicePort));\r\n        _context.statManager().addRateData(\"udp.relayBadIP\", 1);\r\n        return;\r\n    }\r\n    if (ipSize != 0) {\r\n        byte[] ip = new byte[ipSize];\r\n        rrReader.readIP(ip, 0);\r\n        if (!Arrays.equals(aliceIP, ip)) {\r\n            if (_log.shouldWarn())\r\n                _log.warn(\"Bad relay req from \" + alice + \" for \" + Addresses.toString(ip, port));\r\n            _context.statManager().addRateData(\"udp.relayBadIP\", 1);\r\n            return;\r\n        }\r\n    }\r\n    if (port != 0 && port != alicePort) {\r\n        if (_log.shouldWarn())\r\n            _log.warn(\"Bad relay req from \" + alice + \" for \" + Addresses.toString(aliceIP, port));\r\n        _context.statManager().addRateData(\"udp.relayBadIP\", 1);\r\n        return;\r\n    }\r\n    PeerState charlie = get(tag);\r\n    if (charlie == null) {\r\n        if (_log.shouldLog(Log.INFO))\r\n            _log.info(\"Receive relay request from \" + alice + \" with unknown tag\");\r\n        _context.statManager().addRateData(\"udp.receiveRelayRequestBadTag\", 1);\r\n        return;\r\n    }\r\n    if (_log.shouldLog(Log.INFO))\r\n        _log.info(\"Receive relay request from \" + alice + \" for tag \" + tag + \" and relaying with \" + charlie);\r\n    _context.statManager().addRateData(\"udp.receiveRelayRequest\", 1);\r\n    _transport.send(_builder.buildRelayIntro(alice, charlie, reader.getRelayRequestReader()));\r\n    SessionKey cipherKey = null;\r\n    SessionKey macKey = null;\r\n    PeerState aliceState = _transport.getPeerState(alice);\r\n    if (aliceState != null) {\r\n        cipherKey = aliceState.getCurrentCipherKey();\r\n        macKey = aliceState.getCurrentMACKey();\r\n    }\r\n    if (cipherKey == null || macKey == null) {\r\n        byte[] key = new byte[SessionKey.KEYSIZE_BYTES];\r\n        reader.getRelayRequestReader().readAliceIntroKey(key, 0);\r\n        cipherKey = new SessionKey(key);\r\n        macKey = cipherKey;\r\n        if (_log.shouldLog(Log.INFO))\r\n            _log.info(\"Sending relay response (w/ intro key) to \" + alice);\r\n    } else {\r\n        if (_log.shouldLog(Log.INFO))\r\n            _log.info(\"Sending relay response (in-session) to \" + alice);\r\n    }\r\n    _transport.send(_builder.buildRelayResponse(alice, charlie, reader.getRelayRequestReader().readNonce(), cipherKey, macKey));\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.translation.collector.YamlTranslationVisitor.keyNormalizer",
	"Comment": "translation key allow quoted values and also space before and after",
	"Method": "String keyNormalizer(String keyName){\r\n    return StringUtils.trim(StringUtils.strip(StringUtils.strip(keyName, \"'\"), \"\\\"\"));\r\n}"
}, {
	"Path": "io.helidon.security.jersey.spi.AnnotationAnalyzer.analyze",
	"Comment": "analyze a resource method.by default returns an abstain response.",
	"Method": "AnalyzerResponse analyze(Class<?> maybeAnnotated,AnalyzerResponse analyze,Class<?> maybeAnnotated,AnalyzerResponse previousResponse,AnalyzerResponse analyze,Method maybeAnnotated,AnalyzerResponse previousResponse){\r\n    return AnalyzerResponse.abstain(previousResponse);\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.PeerProfile.setLastHeardAbout",
	"Comment": "set when did we last hear about this peer, only if unset or newer also sets firstheardabout if earlier",
	"Method": "void setLastHeardAbout(long when){\r\n    if (_lastHeardAbout <= 0 || when > _lastHeardAbout)\r\n        _lastHeardAbout = when;\r\n    if (when < _firstHeardAbout)\r\n        _firstHeardAbout = when;\r\n}"
}, {
	"Path": "net.i2p.crypto.SessionKeyManager.getAvailableTimeLeft",
	"Comment": "determine how long the available tags will be available for before expiring, in milliseconds",
	"Method": "long getAvailableTimeLeft(PublicKey target,SessionKey key){\r\n    return 0;\r\n}"
}, {
	"Path": "org.klomp.snark.Storage.complete",
	"Comment": "whether or not this storage contains all pieces if the metainfo.",
	"Method": "boolean complete(){\r\n    return needed == 0;\r\n}"
}, {
	"Path": "i2p.susi.webmail.pop3.POP3MailBox.sendCmd1aNoWait",
	"Comment": "send command to pop3 server. does not flush or read or wait.\tcaller must sync.",
	"Method": "void sendCmd1aNoWait(String cmd){\r\n    String msg = cmd;\r\n    if (msg.startsWith(\"PASS\"))\r\n        msg = \"PASS provided\";\r\n    if (_log.shouldDebug())\r\n        _log.debug(\"sendCmd1a(\" + msg + \")\");\r\n    cmd += \"\\r\\n\";\r\n    socket.getOutputStream().write(DataHelper.getASCII(cmd));\r\n    updateActivity();\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.web.IndexBean.isClient",
	"Comment": "is it a client or server in the ui and i2p side? note that a streamr client is a ui and i2p client but a server on the localhost side. note that a streamr server is a ui and i2p server but a client on the localhost side.",
	"Method": "boolean isClient(int tunnelNum,boolean isClient,String type){\r\n    return TunnelController.isClient(type);\r\n}"
}, {
	"Path": "net.i2p.stat.StatManager.store",
	"Comment": "serializes all frequencies and rates to the provided outputstream",
	"Method": "void store(OutputStream out,String prefix){\r\n    for (FrequencyStat fs : _frequencyStats.values()) fs.store(out, prefix);\r\n    for (RateStat rs : _rateStats.values()) rs.store(out, prefix);\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.daemon.MissingGitignoreNotificationProvider.createNotificationPanel",
	"Comment": "creates notification panel for given file and checks if is allowed to show the notification.",
	"Method": "EditorNotificationPanel createNotificationPanel(VirtualFile file,FileEditor fileEditor){\r\n    if (!settings.isMissingGitignore()) {\r\n        return null;\r\n    }\r\n    if (Properties.isIgnoreMissingGitignore(project)) {\r\n        return null;\r\n    }\r\n    String vcsDirectory = GitLanguage.INSTANCE.getVcsDirectory();\r\n    if (vcsDirectory == null) {\r\n        return null;\r\n    }\r\n    VirtualFile baseDir = project.getBaseDir();\r\n    if (baseDir == null) {\r\n        return null;\r\n    }\r\n    VirtualFile gitDirectory = baseDir.findChild(vcsDirectory);\r\n    if (gitDirectory == null || !gitDirectory.isDirectory()) {\r\n        return null;\r\n    }\r\n    VirtualFile gitignoreFile = baseDir.findChild(GitLanguage.INSTANCE.getFilename());\r\n    if (gitignoreFile != null) {\r\n        return null;\r\n    }\r\n    return createPanel(project);\r\n}"
}, {
	"Path": "org.mitre.dsmiley.httpproxy.ProxyServlet.copyProxyCookie",
	"Comment": "copy cookie from the proxy to the servlet client.replaces cookie path to local path and renames cookie to avoid collisions.",
	"Method": "void copyProxyCookie(HttpServletRequest servletRequest,HttpServletResponse servletResponse,String headerValue){\r\n    String path = servletRequest.getContextPath();\r\n    path += servletRequest.getServletPath();\r\n    if (path.isEmpty()) {\r\n        path = \"/\";\r\n    }\r\n    for (HttpCookie cookie : HttpCookie.parse(headerValue)) {\r\n        String proxyCookieName = doPreserveCookies ? cookie.getName() : getCookieNamePrefix(cookie.getName()) + cookie.getName();\r\n        Cookie servletCookie = new Cookie(proxyCookieName, cookie.getValue());\r\n        servletCookie.setComment(cookie.getComment());\r\n        servletCookie.setMaxAge((int) cookie.getMaxAge());\r\n        servletCookie.setPath(path);\r\n        servletCookie.setSecure(cookie.getSecure());\r\n        servletCookie.setVersion(cookie.getVersion());\r\n        servletCookie.setHttpOnly(cookie.isHttpOnly());\r\n        servletResponse.addCookie(servletCookie);\r\n    }\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.stubs.ServiceIndexUtil.getRestrictedFileTypesScope",
	"Comment": "so support only some file types, so we can filter them and xml and yaml for now",
	"Method": "GlobalSearchScope getRestrictedFileTypesScope(Project project){\r\n    return GlobalSearchScope.getScopeRestrictedByFileTypes(GlobalSearchScope.allScope(project), XmlFileType.INSTANCE, YAMLFileType.YML);\r\n}"
}, {
	"Path": "i2p.susi.webmail.pop3.POP3MailBox.doHandshake",
	"Comment": "check the initial response, send capa, check the capa result\tcaller must sync.",
	"Method": "boolean doHandshake(){\r\n    List<SendRecv> cmds = new ArrayList<SendRecv>(2);\r\n    cmds.add(new SendRecv(null, Mode.A1));\r\n    SendRecv capa = null;\r\n    if (gotCAPA) {\r\n        if (_log.shouldDebug())\r\n            _log.debug(\"Skipping CAPA\");\r\n    } else {\r\n        capa = new SendRecv(\"CAPA\", Mode.LS);\r\n        cmds.add(capa);\r\n    }\r\n    boolean rv = sendCmds(cmds);\r\n    if (rv && capa != null) {\r\n        if (capa.ls != null) {\r\n            for (String cap : capa.ls) {\r\n                String t = cap.trim();\r\n                if (t.equals(\"PIPELINING\"))\r\n                    supportsPipelining = true;\r\n                else if (t.equals(\"UIDL\"))\r\n                    supportsUIDL = true;\r\n                else if (t.equals(\"TOP\"))\r\n                    supportsTOP = true;\r\n            }\r\n        }\r\n        gotCAPA = true;\r\n        if (_log.shouldDebug())\r\n            _log.debug(\"POP3 server caps: pipelining? \" + supportsPipelining + \" UIDL? \" + supportsUIDL + \" TOP? \" + supportsTOP);\r\n    }\r\n    return rv;\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.FloodfillNetworkDatabaseFacade.flood",
	"Comment": "send to a subset of all floodfill peers. we do this to implement kademlia within the floodfills, i.e. we flood to those closest to the key.",
	"Method": "void flood(DatabaseEntry ds){\r\n    Hash key = ds.getHash();\r\n    RouterKeyGenerator gen = _context.routerKeyGenerator();\r\n    Hash rkey = gen.getRoutingKey(key);\r\n    FloodfillPeerSelector sel = (FloodfillPeerSelector) getPeerSelector();\r\n    List<Hash> peers = sel.selectFloodfillParticipants(rkey, MAX_TO_FLOOD, getKBuckets());\r\n    long until = gen.getTimeTillMidnight();\r\n    if (until < NEXT_RKEY_LS_ADVANCE_TIME || (ds.getType() == DatabaseEntry.KEY_TYPE_ROUTERINFO && until < NEXT_RKEY_RI_ADVANCE_TIME)) {\r\n        Hash nkey = gen.getNextRoutingKey(key);\r\n        List<Hash> nextPeers = sel.selectFloodfillParticipants(nkey, NEXT_FLOOD_QTY, getKBuckets());\r\n        int i = 0;\r\n        for (Hash h : nextPeers) {\r\n            if (h.equals(key))\r\n                continue;\r\n            if (!peers.contains(h)) {\r\n                peers.add(h);\r\n                i++;\r\n            }\r\n        }\r\n        if (i > 0 && _log.shouldLog(Log.INFO))\r\n            _log.info(\"Flooding the entry for \" + key + \" to \" + i + \" more, just before midnight\");\r\n    }\r\n    int flooded = 0;\r\n    boolean isls2 = ds.isLeaseSet() && ds.getType() != DatabaseEntry.KEY_TYPE_LEASESET;\r\n    for (int i = 0; i < peers.size(); i++) {\r\n        Hash peer = peers.get(i);\r\n        RouterInfo target = lookupRouterInfoLocally(peer);\r\n        if ((target == null) || (_context.banlist().isBanlisted(peer)))\r\n            continue;\r\n        if (ds.getType() == DatabaseEntry.KEY_TYPE_ROUTERINFO && peer.equals(key))\r\n            continue;\r\n        if (peer.equals(_context.routerHash()))\r\n            continue;\r\n        if (isls2 && !StoreJob.shouldStoreLS2To(target))\r\n            continue;\r\n        if (!StoreJob.shouldStoreTo(target))\r\n            continue;\r\n        DatabaseStoreMessage msg = new DatabaseStoreMessage(_context);\r\n        msg.setEntry(ds);\r\n        OutNetMessage m = new OutNetMessage(_context, msg, _context.clock().now() + FLOOD_TIMEOUT, FLOOD_PRIORITY, target);\r\n        Job floodFail = new FloodFailedJob(_context, peer);\r\n        m.setOnFailedSendJob(floodFail);\r\n        Job floodGood = new FloodSuccessJob(_context, peer);\r\n        m.setOnSendJob(floodGood);\r\n        _context.commSystem().processMessage(m);\r\n        flooded++;\r\n        if (_log.shouldLog(Log.INFO))\r\n            _log.info(\"Flooding the entry for \" + key.toBase64() + \" to \" + peer.toBase64());\r\n    }\r\n    if (_log.shouldLog(Log.INFO))\r\n        _log.info(\"Flooded the data to \" + flooded + \" of \" + peers.size() + \" peers\");\r\n}"
}, {
	"Path": "net.i2p.stat.Rate.getAverageValue",
	"Comment": "what was the average value across the events in the last period?",
	"Method": "double getAverageValue(){\r\n    int lec = _lastEventCount;\r\n    if ((_lastTotalValue != 0) && (lec > 0))\r\n        return _lastTotalValue / lec;\r\n    return 0.0D;\r\n}"
}, {
	"Path": "org.klomp.snark.bencode.BDecoder.bdecodeBytes",
	"Comment": "returns the next bencoded value on the stream and makes sure itis a byte array. if it is not a bencoded byte array it will throwinvalidbencodingexception.",
	"Method": "BEValue bdecodeBytes(){\r\n    int c = getNextIndicator();\r\n    int num = c - '0';\r\n    if (num < 0 || num > 9)\r\n        throw new InvalidBEncodingException(\"Number expected, not '\" + (char) c + \"'\");\r\n    indicator = 0;\r\n    c = read();\r\n    int i = c - '0';\r\n    while (i >= 0 && i <= 9) {\r\n        num = num * 10 + i;\r\n        c = read();\r\n        i = c - '0';\r\n    }\r\n    if (c != ':')\r\n        throw new InvalidBEncodingException(\"Colon expected, not '\" + (char) c + \"'\");\r\n    return new BEValue(read(num));\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerState.setCurrentReceiveSecond",
	"Comment": "what is the current receive second, for congestion control?",
	"Method": "void setCurrentReceiveSecond(long sec){\r\n    _currentReceiveSecond = sec;\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.lang.IgnoreCommenter.getLineCommentPrefix",
	"Comment": "returns the string which prefixes a line comment in the language, or null if the languagedoes not support line comments.",
	"Method": "String getLineCommentPrefix(){\r\n    return Constants.HASH;\r\n}"
}, {
	"Path": "io.helidon.security.EndpointConfig.getInstance",
	"Comment": "get an instance of a custom object configuring this endpoint.",
	"Method": "Optional<U> getInstance(Class<U> clazz){\r\n    return customObjects.getInstance(clazz);\r\n}"
}, {
	"Path": "com.google.zxing.qrcode.decoder.Version.getProvisionalVersionForDimension",
	"Comment": "deduces version information purely from qr code dimensions.",
	"Method": "Version getProvisionalVersionForDimension(int dimension){\r\n    if (dimension % 4 != 1) {\r\n        throw FormatException.getFormatInstance();\r\n    }\r\n    try {\r\n        return getVersionForNumber((dimension - 17) / 4);\r\n    } catch (IllegalArgumentException ignored) {\r\n        throw FormatException.getFormatInstance();\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.MessageHistory.getName",
	"Comment": "prettify the hash by doing a base64 and returning the first 6 characters",
	"Method": "String getName(String getName,Hash router,String getName){\r\n    if (router == null)\r\n        return \"unknown\";\r\n    String str = router.toBase64();\r\n    if ((str == null) || (str.length() < 6))\r\n        return \"invalid\";\r\n    return str.substring(0, 6);\r\n}"
}, {
	"Path": "net.i2p.data.DataHelper.writeDate",
	"Comment": "write out a date to the stream as specified by the i2p data structure spec.",
	"Method": "void writeDate(OutputStream out,Date date){\r\n    if (date == null)\r\n        writeLong(out, DATE_LENGTH, 0L);\r\n    else\r\n        writeLong(out, DATE_LENGTH, date.getTime());\r\n}"
}, {
	"Path": "org.jrobin.core.ArcState.getParent",
	"Comment": "returns the archive object to which this arcstate object belongs.",
	"Method": "Archive getParent(){\r\n    return parentArc;\r\n}"
}, {
	"Path": "net.i2p.router.Router.getSharePercentage",
	"Comment": "what fraction of the bandwidth specified in our bandwidth limits shouldwe allow to be consumed by participating tunnels?",
	"Method": "double getSharePercentage(){\r\n    String pct = _context.getProperty(PROP_BANDWIDTH_SHARE_PERCENTAGE);\r\n    if (pct != null) {\r\n        try {\r\n            double d = Double.parseDouble(pct);\r\n            if (d > 1)\r\n                return d / 100d;\r\n            else\r\n                return d;\r\n        } catch (NumberFormatException nfe) {\r\n            if (_log.shouldLog(Log.INFO))\r\n                _log.info(\"Unable to get the share percentage\");\r\n        }\r\n    }\r\n    return DEFAULT_SHARE_PERCENTAGE / 100.0d;\r\n}"
}, {
	"Path": "org.jrobin.core.RrdMemoryBackendFactory.exists",
	"Comment": "method to determine if a memory storage with the given id already exists.",
	"Method": "boolean exists(String id){\r\n    return backends.containsKey(id);\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.lang.IgnoreCommenter.getCommentedBlockCommentSuffix",
	"Comment": "returns the string which marks the commented end of a block comment in the language,or null if the language does not support block comments.",
	"Method": "String getCommentedBlockCommentSuffix(){\r\n    return null;\r\n}"
}, {
	"Path": "com.spotify.heroic.aggregation.AggregationArguments.positionalOrKeyword",
	"Comment": "take the next argument from the list of available arguments or fallback to a keyword if noarguments are present.",
	"Method": "Optional<T> positionalOrKeyword(String key,Class<T> expected){\r\n    if (!args.isEmpty()) {\r\n        return Optional.of(args.removeFirst().cast(expected));\r\n    }\r\n    return Optional.ofNullable(kw.remove(key)).map(v -> v.cast(expected));\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.I2PTunnelHTTPClientRunner.close",
	"Comment": "why is this overridden? why flush in super but not here? why do things in different order than in super?",
	"Method": "void close(OutputStream out,InputStream in,OutputStream i2pout,InputStream i2pin,Socket s,I2PSocket i2ps,Thread t1,Thread t2){\r\n    if (i2pin != null) {\r\n        try {\r\n            i2pin.close();\r\n        } catch (IOException ioe) {\r\n        }\r\n    }\r\n    if (i2pout != null) {\r\n        try {\r\n            i2pout.close();\r\n        } catch (IOException ioe) {\r\n        }\r\n    }\r\n    if (in != null) {\r\n        try {\r\n            in.close();\r\n        } catch (IOException ioe) {\r\n        }\r\n    }\r\n    if (out != null) {\r\n        try {\r\n            out.close();\r\n        } catch (IOException ioe) {\r\n        }\r\n    }\r\n    try {\r\n        i2ps.close();\r\n    } catch (IOException ioe) {\r\n    }\r\n    try {\r\n        s.close();\r\n    } catch (IOException ioe) {\r\n    }\r\n    if (t1 != null)\r\n        t1.join(30 * 1000);\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.UDPPacket.getMarkedType",
	"Comment": "flag this packet as a particular type for accounting purposes, with1 implying the packet is an ack, otherwise it is a data packet",
	"Method": "int getMarkedType(){\r\n    verifyNotReleased();\r\n    return _markedType;\r\n}"
}, {
	"Path": "org.jrobin.core.FetchData.getColumnCount",
	"Comment": "returns the number of columns fetched from the corresponding rrd.\tthis number is always equal to the number of datasources defined\tin the rrd. each column represents values of a single datasource.",
	"Method": "int getColumnCount(){\r\n    return dsNames.length;\r\n}"
}, {
	"Path": "net.i2p.router.time.NtpMessage.unsignedByteToShort",
	"Comment": "converts an unsigned byte to a short.by default, java assumes thata byte is signed.",
	"Method": "short unsignedByteToShort(byte b){\r\n    if ((b & 0x80) == 0x80)\r\n        return (short) (128 + (b & 0x7f));\r\n    else\r\n        return b;\r\n}"
}, {
	"Path": "net.i2p.sam.SAMStreamSession.connect",
	"Comment": "connect the sam stream session to the specified destination",
	"Method": "boolean connect(int id,String dest,Properties props){\r\n    if (!canCreate) {\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"Trying to create an outgoing connection using a receive-only session\");\r\n        throw new SAMInvalidDirectionException(\"Trying to create connections through a receive-only session\");\r\n    }\r\n    if (checkSocketHandlerId(id)) {\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"The specified id (\" + id + \") is already in use\");\r\n        return false;\r\n    }\r\n    Destination d = SAMUtils.getDest(dest);\r\n    I2PSocketOptions opts = socketMgr.buildOptions(props);\r\n    if (props.getProperty(I2PSocketOptions.PROP_CONNECT_TIMEOUT) == null)\r\n        opts.setConnectTimeout(60 * 1000);\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Connecting new I2PSocket...\");\r\n    I2PSocket i2ps = socketMgr.connect(d, opts);\r\n    createSocketHandler(i2ps, id);\r\n    recv.notifyStreamOutgoingConnection(id, \"OK\", null);\r\n    return true;\r\n}"
}, {
	"Path": "net.i2p.router.news.NewsXMLParser.extractNewsEntries",
	"Comment": "this does not check for any missing values. any field in any newsentry may be null.",
	"Method": "List<NewsEntry> extractNewsEntries(Node feed){\r\n    List<NewsEntry> rv = new ArrayList<NewsEntry>();\r\n    List<Node> entries = getNodes(feed, \"entry\");\r\n    for (Node entry : entries) {\r\n        NewsEntry e = new NewsEntry();\r\n        Node n = entry.getNode(\"title\");\r\n        if (n != null) {\r\n            e.title = n.getValue();\r\n            if (e.title != null)\r\n                e.title = e.title.trim();\r\n        }\r\n        n = entry.getNode(\"link\");\r\n        if (n != null) {\r\n            String a = n.getAttributeValue(\"href\");\r\n            if (a.length() > 0)\r\n                e.link = a.trim();\r\n        }\r\n        n = entry.getNode(\"id\");\r\n        if (n != null) {\r\n            e.id = n.getValue();\r\n            if (e.id != null)\r\n                e.id = e.id.trim();\r\n        }\r\n        n = entry.getNode(\"updated\");\r\n        if (n != null) {\r\n            String v = n.getValue();\r\n            if (v != null) {\r\n                long time = RFC3339Date.parse3339Date(v.trim());\r\n                if (time > 0)\r\n                    e.updated = time;\r\n            }\r\n        }\r\n        n = entry.getNode(\"summary\");\r\n        if (n != null) {\r\n            e.summary = n.getValue();\r\n            if (e.summary != null)\r\n                e.summary = e.summary.trim();\r\n        }\r\n        n = entry.getNode(\"author\");\r\n        if (n != null) {\r\n            n = n.getNode(\"name\");\r\n            if (n != null) {\r\n                e.authorName = n.getValue();\r\n                if (e.authorName != null)\r\n                    e.authorName = e.authorName.trim();\r\n            }\r\n        }\r\n        n = entry.getNode(\"content\");\r\n        if (n != null) {\r\n            String a = n.getAttributeValue(\"type\");\r\n            if (a.length() > 0)\r\n                e.contentType = a;\r\n            StringBuilder buf = new StringBuilder(256);\r\n            for (int i = 0; i < n.getNNodes(); i++) {\r\n                Node sn = n.getNode(i);\r\n                try {\r\n                    boolean removed = validate(sn);\r\n                    if (removed) {\r\n                        i--;\r\n                        continue;\r\n                    }\r\n                } catch (I2PParserException ipe) {\r\n                    switch(_mode) {\r\n                        case ABORT:\r\n                            throw ipe;\r\n                        case SKIP_ENTRY:\r\n                            if (_log.shouldLog(Log.WARN))\r\n                                _log.warn(\"Skipping entry\", ipe);\r\n                            e = null;\r\n                            break;\r\n                        case REMOVE_ATTRIBUTE:\r\n                        case REMOVE_ELEMENT:\r\n                            if (_log.shouldLog(Log.WARN))\r\n                                _log.warn(\"Removing element\", ipe);\r\n                            continue;\r\n                        case ALLOW_ALL:\r\n                        default:\r\n                            break;\r\n                    }\r\n                }\r\n                if (e == null)\r\n                    break;\r\n                XMLParser.toString(buf, sn);\r\n            }\r\n            if (e == null)\r\n                continue;\r\n            e.content = buf.toString();\r\n        }\r\n        rv.add(e);\r\n    }\r\n    Collections.sort(rv);\r\n    return rv;\r\n}"
}, {
	"Path": "com.netflix.hollow.api.client.HollowAnnouncementWatcher.triggerAsyncRefreshWithRandomDelay",
	"Comment": "triggers async refresh after some random number of milliseconds have passed,between now and the specified maximum number of milliseconds.any subsequent calls for async refresh will not begin until after the specified delayhas completed.",
	"Method": "void triggerAsyncRefreshWithRandomDelay(int maxDelayMillis){\r\n    Random rand = new Random();\r\n    int delayMillis = maxDelayMillis > 0 ? rand.nextInt(maxDelayMillis) : 0;\r\n    triggerAsyncRefreshWithDelay(delayMillis);\r\n}"
}, {
	"Path": "org.jrobin.core.RrdFileBackendFactory.exists",
	"Comment": "method to determine if a file with the given path already exists.",
	"Method": "boolean exists(String path){\r\n    return Util.fileExists(path);\r\n}"
}, {
	"Path": "net.i2p.router.transport.ntcp.Reader.processRead",
	"Comment": "process everything read.return read buffers back to the pool as we process them.",
	"Method": "void processRead(NTCPConnection con){\r\n    ByteBuffer buf = null;\r\n    while (true) {\r\n        synchronized (con) {\r\n            if (con.isClosed())\r\n                return;\r\n            if (con.isEstablished())\r\n                break;\r\n        }\r\n        if ((buf = con.getNextReadBuf()) == null)\r\n            return;\r\n        EstablishState est = con.getEstablishState();\r\n        if (est.isComplete()) {\r\n            _log.error(\"establishment state [\" + est + \"] is complete, yet the connection isn't established? \" + con.isEstablished() + \" (inbound? \" + con.isInbound() + \" \" + con + \")\");\r\n            EventPumper.releaseBuf(buf);\r\n            break;\r\n        }\r\n        est.receive(buf);\r\n        EventPumper.releaseBuf(buf);\r\n        if (est.isCorrupt()) {\r\n            con.close();\r\n            return;\r\n        }\r\n    }\r\n    while (!con.isClosed() && (buf = con.getNextReadBuf()) != null) {\r\n        con.recvEncryptedI2NP(buf);\r\n        EventPumper.releaseBuf(buf);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.Router.cancelGracefulShutdown",
	"Comment": "cancel any prior request to shut the router down gracefully.returns silently if a final shutdown is already in progress.",
	"Method": "void cancelGracefulShutdown(){\r\n    synchronized (_stateLock) {\r\n        if (isFinalShutdownInProgress())\r\n            return;\r\n        changeState(State.RUNNING);\r\n        _gracefulExitCode = -1;\r\n    }\r\n    _context.throttle().cancelShutdownStatus();\r\n    synchronized (_gracefulShutdownDetector) {\r\n        _gracefulShutdownDetector.notifyAll();\r\n    }\r\n}"
}, {
	"Path": "net.i2p.util.InternalSocket.isInputShutdown",
	"Comment": "supported as of 0.9.33, prior to that threw unsupportedoperationexception",
	"Method": "boolean isInputShutdown(){\r\n    return _is == null;\r\n}"
}, {
	"Path": "com.spotify.heroic.aggregation.ChainInstance.estimate",
	"Comment": "the last aggregation in the chain determines the estimated number of samples.",
	"Method": "long estimate(DateRange range){\r\n    return chain.get(chain.size() - 1).estimate(range);\r\n}"
}, {
	"Path": "net.i2p.util.LogManager.addRecord",
	"Comment": "used by log to add records to the queue.this is generally nonblocking and unsyncrhonized but may block when undermassive logging load as a way of throttling logging threads.",
	"Method": "void addRecord(LogRecord record){\r\n    if ((!_context.isRouterContext()) && _writer == null)\r\n        startLogWriter();\r\n    boolean success = _records.offer(record);\r\n    if (!success) {\r\n        if (_dropOnOverflow) {\r\n            _droppedRecords.incrementAndGet();\r\n            return;\r\n        }\r\n        synchronized (_writer) {\r\n            _writer.notifyAll();\r\n        }\r\n        try {\r\n            _records.put(record);\r\n        } catch (InterruptedException ie) {\r\n        }\r\n    } else if (_flushInterval <= 0) {\r\n        synchronized (_writer) {\r\n            _writer.notifyAll();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.ClientMessage.getExpiration",
	"Comment": "expiration requested by the client that sent the message.this will only be availablefor locally originated messages.",
	"Method": "long getExpiration(){\r\n    return _expiration;\r\n}"
}, {
	"Path": "net.i2p.crypto.SHA1.computeBlock",
	"Comment": "updates the digest using the specified array of bytes,starting at the specified offset, but an implied lengthof exactly 64 bytes.requires no internal buffering, but assumes a fixed input size,in which the required padding bytes may have been added.",
	"Method": "void computeBlock(byte[] input,int offset){\r\n    int a, b, c, d, e;\r\n    int i00, i01, i02, i03, i04, i05, i06, i07, i08, i09, i10, i11, i12, i13, i14, i15;\r\n    e = hE + (((a = hA) << 5) | (a >>> 27)) + 0x5a827999 + (((b = hB) & ((c = hC) ^ (d = hD))) ^ d) + (i00 = input[offset] << 24 | (input[offset + 1] & 0xff) << 16 | (input[offset + 2] & 0xff) << 8 | (input[offset + 3] & 0xff));\r\n    d += ((e << 5) | (e >>> 27)) + 0x5a827999 + ((a & ((b = (b << 30) | (b >>> 2)) ^ c)) ^ c) + (i01 = input[offset + 4] << 24 | (input[offset += 5] & 0xff) << 16 | (input[offset + 1] & 0xff) << 8 | (input[offset + 2] & 0xff));\r\n    c += ((d << 5) | (d >>> 27)) + 0x5a827999 + ((e & ((a = (a << 30) | (a >>> 2)) ^ b)) ^ b) + (i02 = input[offset + 3] << 24 | (input[offset + 4] & 0xff) << 16 | (input[offset += 5] & 0xff) << 8 | (input[offset + 1] & 0xff));\r\n    b += ((c << 5) | (c >>> 27)) + 0x5a827999 + ((d & ((e = (e << 30) | (e >>> 2)) ^ a)) ^ a) + (i03 = input[offset + 2] << 24 | (input[offset + 3] & 0xff) << 16 | (input[offset + 4] & 0xff) << 8 | (input[offset += 5] & 0xff));\r\n    a += ((b << 5) | (b >>> 27)) + 0x5a827999 + ((c & ((d = (d << 30) | (d >>> 2)) ^ e)) ^ e) + (i04 = input[offset + 1] << 24 | (input[offset + 2] & 0xff) << 16 | (input[offset + 3] & 0xff) << 8 | (input[offset + 4] & 0xff));\r\n    e += ((a << 5) | (a >>> 27)) + 0x5a827999 + ((b & ((c = (c << 30) | (c >>> 2)) ^ d)) ^ d) + (i05 = input[offset += 5] << 24 | (input[offset + 1] & 0xff) << 16 | (input[offset + 2] & 0xff) << 8 | (input[offset + 3] & 0xff));\r\n    d += ((e << 5) | (e >>> 27)) + 0x5a827999 + ((a & ((b = (b << 30) | (b >>> 2)) ^ c)) ^ c) + (i06 = input[offset + 4] << 24 | (input[offset += 5] & 0xff) << 16 | (input[offset + 1] & 0xff) << 8 | (input[offset + 2] & 0xff));\r\n    c += ((d << 5) | (d >>> 27)) + 0x5a827999 + ((e & ((a = (a << 30) | (a >>> 2)) ^ b)) ^ b) + (i07 = input[offset + 3] << 24 | (input[offset + 4] & 0xff) << 16 | (input[offset += 5] & 0xff) << 8 | (input[offset + 1] & 0xff));\r\n    b += ((c << 5) | (c >>> 27)) + 0x5a827999 + ((d & ((e = (e << 30) | (e >>> 2)) ^ a)) ^ a) + (i08 = input[offset + 2] << 24 | (input[offset + 3] & 0xff) << 16 | (input[offset + 4] & 0xff) << 8 | (input[offset += 5] & 0xff));\r\n    a += ((b << 5) | (b >>> 27)) + 0x5a827999 + ((c & ((d = (d << 30) | (d >>> 2)) ^ e)) ^ e) + (i09 = input[offset + 1] << 24 | (input[offset + 2] & 0xff) << 16 | (input[offset + 3] & 0xff) << 8 | (input[offset + 4] & 0xff));\r\n    e += ((a << 5) | (a >>> 27)) + 0x5a827999 + ((b & ((c = (c << 30) | (c >>> 2)) ^ d)) ^ d) + (i10 = input[offset += 5] << 24 | (input[offset + 1] & 0xff) << 16 | (input[offset + 2] & 0xff) << 8 | (input[offset + 3] & 0xff));\r\n    d += ((e << 5) | (e >>> 27)) + 0x5a827999 + ((a & ((b = (b << 30) | (b >>> 2)) ^ c)) ^ c) + (i11 = input[offset + 4] << 24 | (input[offset += 5] & 0xff) << 16 | (input[offset + 1] & 0xff) << 8 | (input[offset + 2] & 0xff));\r\n    c += ((d << 5) | (d >>> 27)) + 0x5a827999 + ((e & ((a = (a << 30) | (a >>> 2)) ^ b)) ^ b) + (i12 = input[offset + 3] << 24 | (input[offset + 4] & 0xff) << 16 | (input[offset += 5] & 0xff) << 8 | (input[offset + 1] & 0xff));\r\n    b += ((c << 5) | (c >>> 27)) + 0x5a827999 + ((d & ((e = (e << 30) | (e >>> 2)) ^ a)) ^ a) + (i13 = input[offset + 2] << 24 | (input[offset + 3] & 0xff) << 16 | (input[offset + 4] & 0xff) << 8 | (input[offset += 5] & 0xff));\r\n    a += ((b << 5) | (b >>> 27)) + 0x5a827999 + ((c & ((d = (d << 30) | (d >>> 2)) ^ e)) ^ e) + (i14 = input[offset + 1] << 24 | (input[offset + 2] & 0xff) << 16 | (input[offset + 3] & 0xff) << 8 | (input[offset + 4] & 0xff));\r\n    e += ((a << 5) | (a >>> 27)) + 0x5a827999 + ((b & ((c = (c << 30) | (c >>> 2)) ^ d)) ^ d) + (i15 = input[offset += 5] << 24 | (input[offset + 1] & 0xff) << 16 | (input[offset + 2] & 0xff) << 8 | (input[offset + 3] & 0xff));\r\n    d += ((e << 5) | (e >>> 27)) + 0x5a827999 + ((a & ((b = (b << 30) | (b >>> 2)) ^ c)) ^ c) + (i00 = ((i00 ^= i02 ^ i08 ^ i13) << 1) | (i00 >>> 31));\r\n    c += ((d << 5) | (d >>> 27)) + 0x5a827999 + ((e & ((a = (a << 30) | (a >>> 2)) ^ b)) ^ b) + (i01 = ((i01 ^= i03 ^ i09 ^ i14) << 1) | (i01 >>> 31));\r\n    b += ((c << 5) | (c >>> 27)) + 0x5a827999 + ((d & ((e = (e << 30) | (e >>> 2)) ^ a)) ^ a) + (i02 = ((i02 ^= i04 ^ i10 ^ i15) << 1) | (i02 >>> 31));\r\n    a += ((b << 5) | (b >>> 27)) + 0x5a827999 + ((c & ((d = (d << 30) | (d >>> 2)) ^ e)) ^ e) + (i03 = ((i03 ^= i05 ^ i11 ^ i00) << 1) | (i03 >>> 31));\r\n    e += ((a << 5) | (a >>> 27)) + 0x6ed9eba1 + (b ^ (c = (c << 30) | (c >>> 2)) ^ d) + (i04 = ((i04 ^= i06 ^ i12 ^ i01) << 1) | (i04 >>> 31));\r\n    d += ((e << 5) | (e >>> 27)) + 0x6ed9eba1 + (a ^ (b = (b << 30) | (b >>> 2)) ^ c) + (i05 = ((i05 ^= i07 ^ i13 ^ i02) << 1) | (i05 >>> 31));\r\n    c += ((d << 5) | (d >>> 27)) + 0x6ed9eba1 + (e ^ (a = (a << 30) | (a >>> 2)) ^ b) + (i06 = ((i06 ^= i08 ^ i14 ^ i03) << 1) | (i06 >>> 31));\r\n    b += ((c << 5) | (c >>> 27)) + 0x6ed9eba1 + (d ^ (e = (e << 30) | (e >>> 2)) ^ a) + (i07 = ((i07 ^= i09 ^ i15 ^ i04) << 1) | (i07 >>> 31));\r\n    a += ((b << 5) | (b >>> 27)) + 0x6ed9eba1 + (c ^ (d = (d << 30) | (d >>> 2)) ^ e) + (i08 = ((i08 ^= i10 ^ i00 ^ i05) << 1) | (i08 >>> 31));\r\n    e += ((a << 5) | (a >>> 27)) + 0x6ed9eba1 + (b ^ (c = (c << 30) | (c >>> 2)) ^ d) + (i09 = ((i09 ^= i11 ^ i01 ^ i06) << 1) | (i09 >>> 31));\r\n    d += ((e << 5) | (e >>> 27)) + 0x6ed9eba1 + (a ^ (b = (b << 30) | (b >>> 2)) ^ c) + (i10 = ((i10 ^= i12 ^ i02 ^ i07) << 1) | (i10 >>> 31));\r\n    c += ((d << 5) | (d >>> 27)) + 0x6ed9eba1 + (e ^ (a = (a << 30) | (a >>> 2)) ^ b) + (i11 = ((i11 ^= i13 ^ i03 ^ i08) << 1) | (i11 >>> 31));\r\n    b += ((c << 5) | (c >>> 27)) + 0x6ed9eba1 + (d ^ (e = (e << 30) | (e >>> 2)) ^ a) + (i12 = ((i12 ^= i14 ^ i04 ^ i09) << 1) | (i12 >>> 31));\r\n    a += ((b << 5) | (b >>> 27)) + 0x6ed9eba1 + (c ^ (d = (d << 30) | (d >>> 2)) ^ e) + (i13 = ((i13 ^= i15 ^ i05 ^ i10) << 1) | (i13 >>> 31));\r\n    e += ((a << 5) | (a >>> 27)) + 0x6ed9eba1 + (b ^ (c = (c << 30) | (c >>> 2)) ^ d) + (i14 = ((i14 ^= i00 ^ i06 ^ i11) << 1) | (i14 >>> 31));\r\n    d += ((e << 5) | (e >>> 27)) + 0x6ed9eba1 + (a ^ (b = (b << 30) | (b >>> 2)) ^ c) + (i15 = ((i15 ^= i01 ^ i07 ^ i12) << 1) | (i15 >>> 31));\r\n    c += ((d << 5) | (d >>> 27)) + 0x6ed9eba1 + (e ^ (a = (a << 30) | (a >>> 2)) ^ b) + (i00 = ((i00 ^= i02 ^ i08 ^ i13) << 1) | (i00 >>> 31));\r\n    b += ((c << 5) | (c >>> 27)) + 0x6ed9eba1 + (d ^ (e = (e << 30) | (e >>> 2)) ^ a) + (i01 = ((i01 ^= i03 ^ i09 ^ i14) << 1) | (i01 >>> 31));\r\n    a += ((b << 5) | (b >>> 27)) + 0x6ed9eba1 + (c ^ (d = (d << 30) | (d >>> 2)) ^ e) + (i02 = ((i02 ^= i04 ^ i10 ^ i15) << 1) | (i02 >>> 31));\r\n    e += ((a << 5) | (a >>> 27)) + 0x6ed9eba1 + (b ^ (c = (c << 30) | (c >>> 2)) ^ d) + (i03 = ((i03 ^= i05 ^ i11 ^ i00) << 1) | (i03 >>> 31));\r\n    d += ((e << 5) | (e >>> 27)) + 0x6ed9eba1 + (a ^ (b = (b << 30) | (b >>> 2)) ^ c) + (i04 = ((i04 ^= i06 ^ i12 ^ i01) << 1) | (i04 >>> 31));\r\n    c += ((d << 5) | (d >>> 27)) + 0x6ed9eba1 + (e ^ (a = (a << 30) | (a >>> 2)) ^ b) + (i05 = ((i05 ^= i07 ^ i13 ^ i02) << 1) | (i05 >>> 31));\r\n    b += ((c << 5) | (c >>> 27)) + 0x6ed9eba1 + (d ^ (e = (e << 30) | (e >>> 2)) ^ a) + (i06 = ((i06 ^= i08 ^ i14 ^ i03) << 1) | (i06 >>> 31));\r\n    a += ((b << 5) | (b >>> 27)) + 0x6ed9eba1 + (c ^ (d = (d << 30) | (d >>> 2)) ^ e) + (i07 = ((i07 ^= i09 ^ i15 ^ i04) << 1) | (i07 >>> 31));\r\n    e += ((a << 5) | (a >>> 27)) + 0x8f1bbcdc + ((b & (c = (c << 30) | (c >>> 2))) | ((b | c) & d)) + (i08 = ((i08 ^= i10 ^ i00 ^ i05) << 1) | (i08 >>> 31));\r\n    d += ((e << 5) | (e >>> 27)) + 0x8f1bbcdc + ((a & (b = (b << 30) | (b >>> 2))) | ((a | b) & c)) + (i09 = ((i09 ^= i11 ^ i01 ^ i06) << 1) | (i09 >>> 31));\r\n    c += ((d << 5) | (d >>> 27)) + 0x8f1bbcdc + ((e & (a = (a << 30) | (a >>> 2))) | ((e | a) & b)) + (i10 = ((i10 ^= i12 ^ i02 ^ i07) << 1) | (i10 >>> 31));\r\n    b += ((c << 5) | (c >>> 27)) + 0x8f1bbcdc + ((d & (e = (e << 30) | (e >>> 2))) | ((d | e) & a)) + (i11 = ((i11 ^= i13 ^ i03 ^ i08) << 1) | (i11 >>> 31));\r\n    a += ((b << 5) | (b >>> 27)) + 0x8f1bbcdc + ((c & (d = (d << 30) | (d >>> 2))) | ((c | d) & e)) + (i12 = ((i12 ^= i14 ^ i04 ^ i09) << 1) | (i12 >>> 31));\r\n    e += ((a << 5) | (a >>> 27)) + 0x8f1bbcdc + ((b & (c = (c << 30) | (c >>> 2))) | ((b | c) & d)) + (i13 = ((i13 ^= i15 ^ i05 ^ i10) << 1) | (i13 >>> 31));\r\n    d += ((e << 5) | (e >>> 27)) + 0x8f1bbcdc + ((a & (b = (b << 30) | (b >>> 2))) | ((a | b) & c)) + (i14 = ((i14 ^= i00 ^ i06 ^ i11) << 1) | (i14 >>> 31));\r\n    c += ((d << 5) | (d >>> 27)) + 0x8f1bbcdc + ((e & (a = (a << 30) | (a >>> 2))) | ((e | a) & b)) + (i15 = ((i15 ^= i01 ^ i07 ^ i12) << 1) | (i15 >>> 31));\r\n    b += ((c << 5) | (c >>> 27)) + 0x8f1bbcdc + ((d & (e = (e << 30) | (e >>> 2))) | ((d | e) & a)) + (i00 = ((i00 ^= i02 ^ i08 ^ i13) << 1) | (i00 >>> 31));\r\n    a += ((b << 5) | (b >>> 27)) + 0x8f1bbcdc + ((c & (d = (d << 30) | (d >>> 2))) | ((c | d) & e)) + (i01 = ((i01 ^= i03 ^ i09 ^ i14) << 1) | (i01 >>> 31));\r\n    e += ((a << 5) | (a >>> 27)) + 0x8f1bbcdc + ((b & (c = (c << 30) | (c >>> 2))) | ((b | c) & d)) + (i02 = ((i02 ^= i04 ^ i10 ^ i15) << 1) | (i02 >>> 31));\r\n    d += ((e << 5) | (e >>> 27)) + 0x8f1bbcdc + ((a & (b = (b << 30) | (b >>> 2))) | ((a | b) & c)) + (i03 = ((i03 ^= i05 ^ i11 ^ i00) << 1) | (i03 >>> 31));\r\n    c += ((d << 5) | (d >>> 27)) + 0x8f1bbcdc + ((e & (a = (a << 30) | (a >>> 2))) | ((e | a) & b)) + (i04 = ((i04 ^= i06 ^ i12 ^ i01) << 1) | (i04 >>> 31));\r\n    b += ((c << 5) | (c >>> 27)) + 0x8f1bbcdc + ((d & (e = (e << 30) | (e >>> 2))) | ((d | e) & a)) + (i05 = ((i05 ^= i07 ^ i13 ^ i02) << 1) | (i05 >>> 31));\r\n    a += ((b << 5) | (b >>> 27)) + 0x8f1bbcdc + ((c & (d = (d << 30) | (d >>> 2))) | ((c | d) & e)) + (i06 = ((i06 ^= i08 ^ i14 ^ i03) << 1) | (i06 >>> 31));\r\n    e += ((a << 5) | (a >>> 27)) + 0x8f1bbcdc + ((b & (c = (c << 30) | (c >>> 2))) | ((b | c) & d)) + (i07 = ((i07 ^= i09 ^ i15 ^ i04) << 1) | (i07 >>> 31));\r\n    d += ((e << 5) | (e >>> 27)) + 0x8f1bbcdc + ((a & (b = (b << 30) | (b >>> 2))) | ((a | b) & c)) + (i08 = ((i08 ^= i10 ^ i00 ^ i05) << 1) | (i08 >>> 31));\r\n    c += ((d << 5) | (d >>> 27)) + 0x8f1bbcdc + ((e & (a = (a << 30) | (a >>> 2))) | ((e | a) & b)) + (i09 = ((i09 ^= i11 ^ i01 ^ i06) << 1) | (i09 >>> 31));\r\n    b += ((c << 5) | (c >>> 27)) + 0x8f1bbcdc + ((d & (e = (e << 30) | (e >>> 2))) | ((d | e) & a)) + (i10 = ((i10 ^= i12 ^ i02 ^ i07) << 1) | (i10 >>> 31));\r\n    a += ((b << 5) | (b >>> 27)) + 0x8f1bbcdc + ((c & (d = (d << 30) | (d >>> 2))) | ((c | d) & e)) + (i11 = ((i11 ^= i13 ^ i03 ^ i08) << 1) | (i11 >>> 31));\r\n    e += ((a << 5) | (a >>> 27)) + 0xca62c1d6 + (b ^ (c = (c << 30) | (c >>> 2)) ^ d) + (i12 = ((i12 ^= i14 ^ i04 ^ i09) << 1) | (i12 >>> 31));\r\n    d += ((e << 5) | (e >>> 27)) + 0xca62c1d6 + (a ^ (b = (b << 30) | (b >>> 2)) ^ c) + (i13 = ((i13 ^= i15 ^ i05 ^ i10) << 1) | (i13 >>> 31));\r\n    c += ((d << 5) | (d >>> 27)) + 0xca62c1d6 + (e ^ (a = (a << 30) | (a >>> 2)) ^ b) + (i14 = ((i14 ^= i00 ^ i06 ^ i11) << 1) | (i14 >>> 31));\r\n    b += ((c << 5) | (c >>> 27)) + 0xca62c1d6 + (d ^ (e = (e << 30) | (e >>> 2)) ^ a) + (i15 = ((i15 ^= i01 ^ i07 ^ i12) << 1) | (i15 >>> 31));\r\n    a += ((b << 5) | (b >>> 27)) + 0xca62c1d6 + (c ^ (d = (d << 30) | (d >>> 2)) ^ e) + (i00 = ((i00 ^= i02 ^ i08 ^ i13) << 1) | (i00 >>> 31));\r\n    e += ((a << 5) | (a >>> 27)) + 0xca62c1d6 + (b ^ (c = (c << 30) | (c >>> 2)) ^ d) + (i01 = ((i01 ^= i03 ^ i09 ^ i14) << 1) | (i01 >>> 31));\r\n    d += ((e << 5) | (e >>> 27)) + 0xca62c1d6 + (a ^ (b = (b << 30) | (b >>> 2)) ^ c) + (i02 = ((i02 ^= i04 ^ i10 ^ i15) << 1) | (i02 >>> 31));\r\n    c += ((d << 5) | (d >>> 27)) + 0xca62c1d6 + (e ^ (a = (a << 30) | (a >>> 2)) ^ b) + (i03 = ((i03 ^= i05 ^ i11 ^ i00) << 1) | (i03 >>> 31));\r\n    b += ((c << 5) | (c >>> 27)) + 0xca62c1d6 + (d ^ (e = (e << 30) | (e >>> 2)) ^ a) + (i04 = ((i04 ^= i06 ^ i12 ^ i01) << 1) | (i04 >>> 31));\r\n    a += ((b << 5) | (b >>> 27)) + 0xca62c1d6 + (c ^ (d = (d << 30) | (d >>> 2)) ^ e) + (i05 = ((i05 ^= i07 ^ i13 ^ i02) << 1) | (i05 >>> 31));\r\n    e += ((a << 5) | (a >>> 27)) + 0xca62c1d6 + (b ^ (c = (c << 30) | (c >>> 2)) ^ d) + (i06 = ((i06 ^= i08 ^ i14 ^ i03) << 1) | (i06 >>> 31));\r\n    d += ((e << 5) | (e >>> 27)) + 0xca62c1d6 + (a ^ (b = (b << 30) | (b >>> 2)) ^ c) + (i07 = ((i07 ^= i09 ^ i15 ^ i04) << 1) | (i07 >>> 31));\r\n    c += ((d << 5) | (d >>> 27)) + 0xca62c1d6 + (e ^ (a = (a << 30) | (a >>> 2)) ^ b) + (i08 = ((i08 ^= i10 ^ i00 ^ i05) << 1) | (i08 >>> 31));\r\n    b += ((c << 5) | (c >>> 27)) + 0xca62c1d6 + (d ^ (e = (e << 30) | (e >>> 2)) ^ a) + (i09 = ((i09 ^= i11 ^ i01 ^ i06) << 1) | (i09 >>> 31));\r\n    a += ((b << 5) | (b >>> 27)) + 0xca62c1d6 + (c ^ (d = (d << 30) | (d >>> 2)) ^ e) + (i10 = ((i10 ^= i12 ^ i02 ^ i07) << 1) | (i10 >>> 31));\r\n    e += ((a << 5) | (a >>> 27)) + 0xca62c1d6 + (b ^ (c = (c << 30) | (c >>> 2)) ^ d) + (i11 = ((i11 ^= i13 ^ i03 ^ i08) << 1) | (i11 >>> 31));\r\n    d += ((e << 5) | (e >>> 27)) + 0xca62c1d6 + (a ^ (b = (b << 30) | (b >>> 2)) ^ c) + (i12 = ((i12 ^= i14 ^ i04 ^ i09) << 1) | (i12 >>> 31));\r\n    c += ((d << 5) | (d >>> 27)) + 0xca62c1d6 + (e ^ (a = (a << 30) | (a >>> 2)) ^ b) + (i13 = ((i13 ^= i15 ^ i05 ^ i10) << 1) | (i13 >>> 31));\r\n    hB += b += ((c << 5) | (c >>> 27)) + 0xca62c1d6 + (d ^ (e = (e << 30) | (e >>> 2)) ^ a) + (i14 = ((i14 ^= i00 ^ i06 ^ i11) << 1) | (i14 >>> 31));\r\n    hA += a += ((b << 5) | (b >>> 27)) + 0xca62c1d6 + (c ^ (d = (d << 30) | (d >>> 2)) ^ e) + (i15 = ((i15 ^= i01 ^ i07 ^ i12) << 1) | (i15 >>> 31));\r\n    hE += e;\r\n    hD += d;\r\n    hC += (c << 30) | (c >>> 2);\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.FloodfillNetworkDatabaseFacade.setFloodfillEnabled",
	"Comment": "public, called from console. this wakes up the floodfill monitor, which will rebuild the ri and log in the event log, and call setfloodfillenabledfrommonitor which really sets it.",
	"Method": "void setFloodfillEnabled(boolean yes){\r\n    if (yes != _floodfillEnabled) {\r\n        _context.jobQueue().removeJob(_ffMonitor);\r\n        _ffMonitor.getTiming().setStartAfter(_context.clock().now() + 1000);\r\n        _context.jobQueue().addJob(_ffMonitor);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.PeerProfile.setFirstHeardAbout",
	"Comment": "set when did we first heard about this peer, only if older. package private, only set by profile management subsystem.",
	"Method": "void setFirstHeardAbout(long when){\r\n    if (when < _firstHeardAbout)\r\n        _firstHeardAbout = when;\r\n}"
}, {
	"Path": "com.netflix.hollow.core.memory.encoding.VarInt.readVInt",
	"Comment": "read a variable length integer from the supplied inputstream",
	"Method": "int readVInt(ByteData arr,long position,int readVInt,InputStream in){\r\n    byte b = (byte) in.read();\r\n    if (b == (byte) 0x80)\r\n        throw new RuntimeException(\"Attempting to read null value as int\");\r\n    int value = b & 0x7F;\r\n    while ((b & 0x80) != 0) {\r\n        b = (byte) in.read();\r\n        value <<= 7;\r\n        value |= (b & 0x7F);\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.config.yaml.YamlElementPatternHelper.getOrmRoot",
	"Comment": "proxy for getwithfirstrootkey to filter with file name condition",
	"Method": "ElementPattern<? extends PsiElement> getOrmRoot(){\r\n    return PlatformPatterns.and(PlatformPatterns.psiElement().with(new PatternCondition<PsiElement>(\"Doctrine file\") {\r\n        @Override\r\n        public boolean accepts(@NotNull PsiElement psiElement, ProcessingContext processingContext) {\r\n            return getOrmFilePattern().accepts(psiElement.getContainingFile());\r\n        }\r\n    }), getWithFirstRootKey());\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.config.yaml.YamlElementPatternHelper.getOrmRoot",
	"Comment": "proxy for getwithfirstrootkey to filter with file name condition",
	"Method": "ElementPattern<? extends PsiElement> getOrmRoot(){\r\n    return getOrmFilePattern().accepts(psiElement.getContainingFile());\r\n}"
}, {
	"Path": "io.helidon.security.jwt.JwtUtil.transformToJson",
	"Comment": "transform a map of strings to objects to a map of string to json values.each object is checked for type and if supported, transformed to appropriatejson value.",
	"Method": "Map<String, JsonValue> transformToJson(Map<String, Object> claims){\r\n    Map<String, JsonValue> result = new HashMap();\r\n    claims.forEach((s, o) -> result.put(s, toJson(o)));\r\n    return result;\r\n}"
}, {
	"Path": "io.helidon.security.oidc.common.OidcConfig.useParam",
	"Comment": "whether to use query parameter to get the information from request.",
	"Method": "boolean useParam(Builder useParam,Boolean useParam){\r\n    return useParam;\r\n}"
}, {
	"Path": "io.helidon.security.abac.AbacProvider.builder",
	"Comment": "creates a fluent api builder to build new instances of this class.",
	"Method": "Builder builder(){\r\n    return new Builder();\r\n}"
}, {
	"Path": "net.i2p.data.KeysAndCert.hashCode",
	"Comment": "the signing key has enough randomness in it to use it by itself for speed",
	"Method": "int hashCode(){\r\n    if (_signingKey == null)\r\n        return 0;\r\n    return _signingKey.hashCode();\r\n}"
}, {
	"Path": "net.i2p.sam.SAMBridge.addKeystream",
	"Comment": "specify that the given keystream should be used for the given name",
	"Method": "void addKeystream(String name,String stream){\r\n    synchronized (nameToPrivKeys) {\r\n        nameToPrivKeys.put(name, stream);\r\n    }\r\n    storeKeys();\r\n}"
}, {
	"Path": "net.i2p.client.impl.I2PSessionImpl.sendMessage",
	"Comment": "deliver an i2cp message to the routeras of 0.9.3, may block for several seconds if the write queue to the router is full",
	"Method": "void sendMessage(I2CPMessage message){\r\n    verifyOpen();\r\n    sendMessage_unchecked(message);\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.pool.TunnelPool.isAlive",
	"Comment": "is this pool running and either exploratory, or tracked by the client manager? a pool will be alive but not tracked after the client manager removes it but before all the tunnels have expired.",
	"Method": "boolean isAlive(){\r\n    return _alive && (_settings.isExploratory() || _context.clientManager().isLocal(_settings.getDestination()));\r\n}"
}, {
	"Path": "org.jrobin.graph.RrdGraphDef.setLazy",
	"Comment": "creates graph only if the current graph is out of date or not existent.",
	"Method": "void setLazy(boolean lazy){\r\n    this.lazy = lazy;\r\n}"
}, {
	"Path": "com.spotify.heroic.aggregation.DistributedAggregationCombiner.create",
	"Comment": "create a combiner from a global aggregation.notice that the cadence is taken from the root aggregation, since the reducer mightlose it.",
	"Method": "DistributedAggregationCombiner create(AggregationInstance root,DateRange range,BucketStrategy bucketStrategy){\r\n    return new DistributedAggregationCombiner(root.reducer(), range, bucketStrategy, root.cadence());\r\n}"
}, {
	"Path": "org.jrobin.core.RrdDbPool.getInstance",
	"Comment": "creates a single instance of the class on the first call, or returns already existing one.",
	"Method": "RrdDbPool getInstance(){\r\n    if (instance == null) {\r\n        instance = new RrdDbPool();\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "org.klomp.snark.Snark.getComments",
	"Comment": "the current comment set for this torrent.not a copy.caller must synch on the returned object for all operations.",
	"Method": "CommentSet getComments(){\r\n    synchronized (_commentLock) {\r\n        return _comments;\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.crypto.TransientSessionKeyManager.aggressiveExpire",
	"Comment": "aggressively expire inbound tag sets and outbound sessions",
	"Method": "int aggressiveExpire(){\r\n    int removed = 0;\r\n    int remaining = 0;\r\n    long now = _context.clock().now();\r\n    synchronized (_inboundTagSets) {\r\n        for (Iterator<TagSet> iter = _inboundTagSets.values().iterator(); iter.hasNext(); ) {\r\n            TagSet ts = iter.next();\r\n            if (ts.getDate() <= now) {\r\n                iter.remove();\r\n                removed++;\r\n            }\r\n        }\r\n        remaining = _inboundTagSets.size();\r\n        if (remaining > 500) {\r\n            Map<SessionKey, Set<TagSet>> inboundSets = getInboundTagSetsBySessionKey();\r\n            for (Map.Entry<SessionKey, Set<TagSet>> e : inboundSets.entrySet()) {\r\n                SessionKey skey = e.getKey();\r\n                Set<TagSet> sets = e.getValue();\r\n                int count = sets.size();\r\n                if (count >= 10) {\r\n                    if (_log.shouldInfo())\r\n                        _log.info(\"Session key \" + skey.toBase64() + \" has \" + count + \" tag sets\");\r\n                    long age = Math.min(5 * 60 * 1000, Math.max(60 * 1000, 9 * 60 * 1000 - ((count - 10) * 8 * 60 * 1000 / 40)));\r\n                    for (TagSet ts : sets) {\r\n                        Set<SessionTag> tags = ts.getTags();\r\n                        int curSize = tags.size();\r\n                        int origSize = ts.getOriginalSize();\r\n                        long expires = ts.getDate();\r\n                        if (curSize == origSize && curSize > 8 && expires < now + SESSION_LIFETIME_MAX_MS - age) {\r\n                            if (_log.shouldInfo())\r\n                                _log.info(\"Removed unused tag set \" + ts);\r\n                            for (SessionTag tag : tags) {\r\n                                _inboundTagSets.remove(tag);\r\n                            }\r\n                            removed += curSize;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            remaining = _inboundTagSets.size();\r\n        }\r\n    }\r\n    _context.statManager().addRateData(\"crypto.sessionTagsRemaining\", remaining, 0);\r\n    if (removed > 0 && _log.shouldInfo())\r\n        _log.info(\"Expired inbound: \" + removed);\r\n    int oremoved = 0;\r\n    synchronized (_outboundSessions) {\r\n        for (Iterator<OutboundSession> iter = _outboundSessions.values().iterator(); iter.hasNext(); ) {\r\n            OutboundSession sess = iter.next();\r\n            oremoved += sess.expireTags();\r\n            if (sess.getLastUsedDate() < now - (SESSION_LIFETIME_MAX_MS / 2) && sess.availableTags() <= 0) {\r\n                iter.remove();\r\n                oremoved++;\r\n            }\r\n        }\r\n    }\r\n    if (oremoved > 0 && _log.shouldInfo())\r\n        _log.info(\"Expired outbound: \" + oremoved);\r\n    return removed + oremoved;\r\n}"
}, {
	"Path": "com.spotify.heroic.cluster.CoreClusterManager.refreshSweep",
	"Comment": "operation that takes the existing list of clients, compares it to a collection of resolveduris and determines which nodes should be updated, and which should be removed.",
	"Method": "LazyTransform<Collection<List<URI>>, Void> refreshSweep(String id){\r\n    return uriLists -> {\r\n        final List<URI> uris = ImmutableList.copyOf(Iterables.concat(uriLists));\r\n        final List<AsyncFuture<Update>> updated = new ArrayList();\r\n        final List<RemovedNode> removedNodes = new ArrayList();\r\n        final Map<URI, ClusterNode> oldClients = this.clients.get();\r\n        if (oldClients == null) {\r\n            log.warn(\"{}: Aborting refresh, shutting down\", id);\r\n            return async.resolved();\r\n        }\r\n        final Set<URI> removedUris = new HashSet(oldClients.keySet());\r\n        for (final URI uri : uris) {\r\n            final ClusterNode node = oldClients.get(uri);\r\n            removedUris.remove(uri);\r\n            if (node == null) {\r\n                updated.add(createClusterNode(id, uri));\r\n                continue;\r\n            }\r\n            updated.add(node.fetchMetadata().lazyTransform(m -> {\r\n                if (!node.metadata().equals(m)) {\r\n                    removedNodes.add(new RemovedNode(uri, node));\r\n                    return createClusterNode(id, uri);\r\n                }\r\n                return async.resolved(new SuccessfulUpdate(uri, false, node));\r\n            }).catchFailed(Update.error(uri)).catchCancelled(Update.cancellation(uri)));\r\n        }\r\n        for (final URI uri : removedUris) {\r\n            final ClusterNode remove = oldClients.get(uri);\r\n            if (remove != null) {\r\n                removedNodes.add(new RemovedNode(uri, remove));\r\n            }\r\n        }\r\n        return async.collect(updated).lazyTransform(refreshLogAndPrepare(id, removedNodes, oldClients));\r\n    };\r\n}"
}, {
	"Path": "net.i2p.data.SessionKey.getPreparedKey",
	"Comment": "retrieve an internal representation of the session key, as knownby the aes engine used.this can be reused safely",
	"Method": "Object getPreparedKey(){\r\n    return _preparedKey;\r\n}"
}, {
	"Path": "com.netflix.hollow.tools.history.HollowHistory.ignoreListOrderingOnDoubleSnapshot",
	"Comment": "call this method to indicate that list ordering changes should be identified as modified records whena double snapshot occurs.by default, these will not be identified as updates.",
	"Method": "void ignoreListOrderingOnDoubleSnapshot(){\r\n    this.ignoreListOrderingOnDoubleSnapshot = true;\r\n}"
}, {
	"Path": "com.southernstorm.noise.protocol.SymmetricState.decryptAndHash",
	"Comment": "decrypts a block of ciphertext and mixes it into the handshake hash.",
	"Method": "int decryptAndHash(byte[] ciphertext,int ciphertextOffset,byte[] plaintext,int plaintextOffset,int length){\r\n    System.arraycopy(h, 0, prev_h, 0, h.length);\r\n    mixHash(ciphertext, ciphertextOffset, length);\r\n    return cipher.decryptWithAd(prev_h, ciphertext, ciphertextOffset, plaintext, plaintextOffset, length);\r\n}"
}, {
	"Path": "net.i2p.router.naming.BlockfileNamingService.initNew",
	"Comment": "create a new database and initialize it from the local files privatehosts.txt, userhosts.txt, and hosts.txt, creating a skiplist in the database for each.",
	"Method": "BlockFile initNew(RAIFile f){\r\n    long start = _context.clock().now();\r\n    _version = VERSION;\r\n    _destSerializer = _destSerializerV4;\r\n    _isVersion4 = true;\r\n    try {\r\n        BlockFile rv = new BlockFile(f, true);\r\n        SkipList<String, Properties> hdr = rv.makeIndex(INFO_SKIPLIST, _stringSerializer, _infoSerializer);\r\n        Properties info = new Properties();\r\n        info.setProperty(PROP_VERSION, VERSION);\r\n        info.setProperty(PROP_CREATED, Long.toString(_context.clock().now()));\r\n        String list = _context.getProperty(HostsTxtNamingService.PROP_HOSTS_FILE, HostsTxtNamingService.DEFAULT_HOSTS_FILE);\r\n        info.setProperty(PROP_LISTS, list);\r\n        hdr.put(PROP_INFO, info);\r\n        rv.makeIndex(REVERSE_SKIPLIST, _hashIndexSerializer, _infoSerializer);\r\n        int total = 0;\r\n        for (String hostsfile : getFilenames(list)) {\r\n            _lists.add(hostsfile);\r\n            File file = new File(_context.getRouterDir(), hostsfile);\r\n            if ((!file.exists()) || !(file.canRead()))\r\n                continue;\r\n            int count = 0;\r\n            BufferedReader in = null;\r\n            String sourceMsg = \"Imported from \" + hostsfile + \" file\";\r\n            try {\r\n                in = new BufferedReader(new InputStreamReader(new FileInputStream(file), \"UTF-8\"), 16 * 1024);\r\n                String line = null;\r\n                while ((line = in.readLine()) != null) {\r\n                    if (line.startsWith(\"#\"))\r\n                        continue;\r\n                    int split = line.indexOf('=');\r\n                    if (split <= 0)\r\n                        continue;\r\n                    String key = line.substring(0, split).toLowerCase(Locale.US);\r\n                    if (line.indexOf('#') > 0) {\r\n                        line = line.substring(0, line.indexOf('#')).trim();\r\n                        if (line.length() < split + 1)\r\n                            continue;\r\n                    }\r\n                    String b64 = line.substring(split + 1).trim();\r\n                    Destination d = lookupBase64(b64);\r\n                    if (d != null) {\r\n                        addEntry(rv, hostsfile, key, d, sourceMsg);\r\n                        addReverseEntry(rv, key, d, _log);\r\n                        count++;\r\n                    } else {\r\n                        _log.logAlways(Log.WARN, \"Unable to import entry for \" + key + \" from file \" + file + \" - bad Base 64: \" + b64);\r\n                    }\r\n                }\r\n            } catch (IOException ioe) {\r\n                _log.error(\"Failed to read hosts from \" + file, ioe);\r\n            } finally {\r\n                if (in != null)\r\n                    try {\r\n                        in.close();\r\n                    } catch (IOException ioe) {\r\n                    }\r\n            }\r\n            total += count;\r\n            _log.logAlways(Log.INFO, \"Migrating \" + count + \" hosts from \" + file + \" to new hosts database\");\r\n        }\r\n        if (_log.shouldLog(Log.INFO))\r\n            _log.info(\"DB init took \" + DataHelper.formatDuration(_context.clock().now() - start));\r\n        if (total <= 0)\r\n            _log.logAlways(Log.WARN, \"No hosts.txt files found, Initialized hosts database with zero entries\");\r\n        return rv;\r\n    } catch (RuntimeException e) {\r\n        _log.error(\"Failed to initialize database\", e);\r\n        throw new IOException(e.toString());\r\n    }\r\n}"
}, {
	"Path": "net.i2p.stat.RateStat.addRate",
	"Comment": "adds a new rate with the requested period, provided thata rate with that period does not already exist.",
	"Method": "void addRate(long period){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.MessageHandler.reportAbuse",
	"Comment": "instruct the client that the session specified seems to be under attackand that the client may wish to move its destination to another router.",
	"Method": "void reportAbuse(I2PSession session,int severity){\r\n    if (_log.shouldLog(Log.ERROR))\r\n        _log.error(\"Abuse reported with severity \" + severity);\r\n    _manager.disconnectAllHard();\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.I2PSocketManagerFull.destroySocketManager",
	"Comment": "destroy the socket manager, freeing all the associated resources.thismethod will block until all the managed sockets are closed.cannot be restarted.",
	"Method": "void destroySocketManager(){\r\n    if (!_isDestroyed.compareAndSet(false, true)) {\r\n        _log.logCloseLoop(\"I2PSocketManager\", getName());\r\n        return;\r\n    }\r\n    _connectionManager.setAllowIncomingConnections(false);\r\n    _connectionManager.shutdown();\r\n    if (!_subsessions.isEmpty()) {\r\n        for (I2PSession sess : _subsessions) {\r\n            removeSubsession(sess);\r\n        }\r\n    }\r\n    if ((_session != null) && (!_session.isClosed())) {\r\n        try {\r\n            _session.destroySession();\r\n        } catch (I2PSessionException ise) {\r\n            _log.warn(\"Unable to destroy the session\", ise);\r\n        }\r\n        PcapWriter pcap = null;\r\n        synchronized (_pcapInitLock) {\r\n            pcap = pcapWriter;\r\n        }\r\n        if (pcap != null)\r\n            pcap.flush();\r\n    }\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterAddress.getCost",
	"Comment": "retrieve the weighted cost of this address, relative to other methods ofcontacting this router.the value 0 means free and 255 means really expensive.no value above 255 is allowed.unused before 0.7.12",
	"Method": "int getCost(){\r\n    return _cost;\r\n}"
}, {
	"Path": "com.southernstorm.noise.protocol.SymmetricState.split",
	"Comment": "splits the symmetric state into two ciphers for session encryption,\tand optionally mixes in a secondary symmetric key.",
	"Method": "CipherStatePair split(CipherStatePair split,byte[] secondaryKey,int offset,int length){\r\n    if (length != 0 && length != 32)\r\n        throw new IllegalArgumentException(\"Secondary keys must be 0 or 32 bytes in length\");\r\n    int keyLength = cipher.getKeyLength();\r\n    byte[] k1 = new byte[keyLength];\r\n    byte[] k2 = new byte[keyLength];\r\n    try {\r\n        hkdf(ck, 0, ck.length, secondaryKey, offset, length, k1, 0, k1.length, k2, 0, k2.length);\r\n        CipherState c1 = null;\r\n        CipherState c2 = null;\r\n        CipherStatePair pair = null;\r\n        try {\r\n            c1 = cipher.fork(k1, 0);\r\n            c2 = cipher.fork(k2, 0);\r\n            pair = new CipherStatePair(c1, c2);\r\n        } finally {\r\n            if (c1 == null || c2 == null || pair == null) {\r\n                if (c1 != null)\r\n                    c1.destroy();\r\n                if (c2 != null)\r\n                    c2.destroy();\r\n                pair = null;\r\n            }\r\n        }\r\n        return pair;\r\n    } finally {\r\n        Noise.destroy(k1);\r\n        Noise.destroy(k2);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.data.i2np.TunnelDataMessage.writeMessageBody",
	"Comment": "write the message body to the output array, starting at the given index",
	"Method": "int writeMessageBody(byte out,int curIndex){\r\n    if ((_tunnelId <= 0) || (_data == null))\r\n        throw new I2NPMessageException(\"Not enough data to write out (id=\" + _tunnelId + \")\");\r\n    if (_data.length <= 0)\r\n        throw new I2NPMessageException(\"Not enough data to write out (data.length=\" + _data.length + \")\");\r\n    if (_hadCache && _dataBuf == null) {\r\n        I2NPMessageException e = new I2NPMessageException(\"TDM data buf use after free\");\r\n        _log.error(\"TDM boom\", e);\r\n        throw e;\r\n    }\r\n    DataHelper.toLong(out, curIndex, 4, _tunnelId);\r\n    curIndex += 4;\r\n    System.arraycopy(_data, 0, out, curIndex, DATA_SIZE);\r\n    curIndex += _data.length;\r\n    return curIndex;\r\n}"
}, {
	"Path": "net.i2p.router.client.MessageReceivedJob.messageAvailable",
	"Comment": "deliver notification to the client that the given message is available.",
	"Method": "void messageAvailable(MessageId id,long size){\r\n    MessageStatusMessage msg = new MessageStatusMessage();\r\n    msg.setMessageId(id.getMessageId());\r\n    SessionId sid = _runner.getSessionId(_toDest.calculateHash());\r\n    if (sid == null) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"No session for \" + _toDest.calculateHash());\r\n        return;\r\n    }\r\n    msg.setSessionId(sid.getSessionId());\r\n    msg.setSize(size);\r\n    msg.setNonce(1);\r\n    msg.setStatus(MessageStatusMessage.STATUS_AVAILABLE);\r\n    _runner.doSend(msg);\r\n}"
}, {
	"Path": "io.helidon.security.util.TokenHandler.setHeader",
	"Comment": "set the token as a new header.creates the header if not present, replaces header value if present.",
	"Method": "void setHeader(Map<String, List<String>> headers,String token){\r\n    headers.put(tokenHeader, singletonList(headerCreator.apply(token)));\r\n}"
}, {
	"Path": "org.klomp.snark.PeerCoordinator.gotBitField",
	"Comment": "returns true if the given bitfield contains at least one piece weare interested in.",
	"Method": "boolean gotBitField(Peer peer,BitField bitfield){\r\n    boolean rv = false;\r\n    synchronized (wantedPieces) {\r\n        for (Piece p : wantedPieces) {\r\n            int i = p.getId();\r\n            if (bitfield.get(i)) {\r\n                p.addPeer(peer);\r\n                rv = true;\r\n            }\r\n        }\r\n    }\r\n    return rv;\r\n}"
}, {
	"Path": "io.helidon.webserver.testsupport.SocketHttpClient.assertConnectionIsOpen",
	"Comment": "assert that the socket associated with the provided client is working and open.",
	"Method": "void assertConnectionIsOpen(SocketHttpClient s){\r\n    s.request(Http.Method.GET);\r\n    assertThat(s.receive(), StringEndsWith.endsWith(\"\\n9\\nIt works!\\n0\\n\\n\"));\r\n}"
}, {
	"Path": "io.helidon.security.oidc.common.OidcConfig.useHeader",
	"Comment": "whether to use http header to get the information from request.",
	"Method": "boolean useHeader(Builder useHeader,Boolean useHeader){\r\n    return useHeader;\r\n}"
}, {
	"Path": "com.spotify.heroic.cluster.CoreClusterManager.refreshLogAndPrepare",
	"Comment": "operation the logs all intended operations and prepares for the final step.",
	"Method": "LazyTransform<Collection<Update>, Void> refreshLogAndPrepare(String id,List<RemovedNode> removedNodes,Map<URI, ClusterNode> oldClients){\r\n    return updates -> {\r\n        final Set<ClusterNode> okNodes = new HashSet();\r\n        final List<SuccessfulUpdate> okUpdates = new ArrayList();\r\n        final List<ClusterNode> failedNodes = new ArrayList();\r\n        final Map<URI, ClusterNode> newClients = new HashMap();\r\n        updates.forEach(update -> {\r\n            update.handle(s -> {\r\n                if (s.isAdded()) {\r\n                    log.info(\"{} [new] {}\", id, s.getUri());\r\n                }\r\n                newClients.put(s.getUri(), s.getNode());\r\n                okNodes.add(s.getNode());\r\n                okUpdates.add(s);\r\n            }, error -> {\r\n                log.error(\"{} [failed] {}\", id, error.getUri(), error.getError());\r\n                error.getExistingNode().ifPresent(existingNode -> {\r\n                    failedNodes.add(existingNode);\r\n                });\r\n            });\r\n        });\r\n        if (okNodes.isEmpty() && useLocal) {\r\n            log.info(\"{} [refresh] no nodes discovered, including local node\", id);\r\n            okNodes.add(new TracingClusterNode(local, LOCAL_IDENTIFIER));\r\n        }\r\n        final Set<Map<String, String>> knownShards = extractKnownShards(okNodes);\r\n        log.info(\"{} [update] {} {} result(s)\", id, knownShards, okNodes.size());\r\n        return refreshFinalize(id, oldClients, newClients, okNodes, okUpdates, removedNodes, failedNodes);\r\n    };\r\n}"
}, {
	"Path": "io.helidon.webserver.netty.BareResponseImpl.completeInternal",
	"Comment": "completes this response. no other data are send to the client when response is completed. all caches are flushed.",
	"Method": "void completeInternal(Throwable throwable){\r\n    if (!internallyClosed.compareAndSet(false, true)) {\r\n        completeResponseFuture(throwable);\r\n        return;\r\n    }\r\n    if (keepAlive) {\r\n        runOnOutboundEventLoopThread(() -> {\r\n            LOGGER.finest(() -> log(\"Writing an empty last http content; keep-alive: true\"));\r\n            if (!requestContentConsumed.getAsBoolean()) {\r\n                LOGGER.finer(() -> log(\"Request content not fully read; trying to keep the connection; keep-alive: true\"));\r\n                ctx.channel().read();\r\n            }\r\n            ctx.writeAndFlush(new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER)).addListener(completeOnFailureListener(\"An exception occurred when writing last http content.\")).addListener(preventMaskingExceptionOnFailureListener(throwable)).addListener(completeOnSuccessListener(throwable)).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);\r\n        });\r\n    } else {\r\n        runOnOutboundEventLoopThread(() -> {\r\n            LOGGER.finest(() -> log(\"Closing with an empty buffer; keep-alive: \" + keepAlive));\r\n            ctx.writeAndFlush(new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER)).addListener(completeOnFailureListener(\"An exception occurred when writing last http content.\")).addListener(preventMaskingExceptionOnFailureListener(throwable)).addListener(completeOnSuccessListener(throwable)).addListener(ChannelFutureListener.CLOSE);\r\n        });\r\n    }\r\n}"
}, {
	"Path": "org.klomp.snark.Peer.setInteresting",
	"Comment": "sets whether or not we are interested in pieces from this peer.defaults to false. when interest is true and this peer unchokesus then we start downloading from it. has no effect when not connected.",
	"Method": "void setInteresting(boolean interest){\r\n    PeerState s = state;\r\n    if (s != null)\r\n        s.setInteresting(interest);\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.settings.IgnoreSettings.setHideIgnoredFiles",
	"Comment": "changes the configuration to determine if ignored files should be hidden in the project tree view or not.",
	"Method": "void setHideIgnoredFiles(boolean hideIgnoredFiles){\r\n    this.notifyOnChange(KEY.HIDE_IGNORED_FILES, this.hideIgnoredFiles, hideIgnoredFiles);\r\n    this.hideIgnoredFiles = hideIgnoredFiles;\r\n}"
}, {
	"Path": "net.i2p.util.SecureDirectory.mkdirs",
	"Comment": "sets directory to mode 700 if the directory is created does not change the mode of other created directories",
	"Method": "boolean mkdirs(){\r\n    boolean rv = super.mkdirs();\r\n    if (rv)\r\n        setPerms();\r\n    return rv;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerState.setTheyRelayToUsAs",
	"Comment": "if they have offered to serve as an introducer to us, this is the tagwe can use to publish that fact.",
	"Method": "void setTheyRelayToUsAs(long tag){\r\n    _theyRelayToUsAs = tag;\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.pool.TunnelPool.listPending",
	"Comment": "list of tunnelinfo instances of tunnels currently being built",
	"Method": "List<PooledTunnelCreatorConfig> listPending(){\r\n    synchronized (_inProgress) {\r\n        return new ArrayList<PooledTunnelCreatorConfig>(_inProgress);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.Banlist.banlistRouter",
	"Comment": "ick have to put the reasoncode in the front to avoid ambiguity",
	"Method": "boolean banlistRouter(Hash peer,boolean banlistRouter,Hash peer,String reason,boolean banlistRouter,String reasonCode,Hash peer,String reason,boolean banlistRouter,Hash peer,String reason,String transport,boolean banlistRouter,Hash peer,String reason,String transport,boolean forever,boolean banlistRouter,Hash peer,String reason,String reasonCode,String transport,boolean forever,boolean banlistRouter,Hash peer,String reason,String reasonCode,String transport,long expireOn){\r\n    if (peer == null) {\r\n        _log.error(\"ban null?\", new Exception());\r\n        return false;\r\n    }\r\n    if (peer.equals(_context.routerHash())) {\r\n        if (_log.shouldWarn())\r\n            _log.warn(\"not banning us\", new Exception());\r\n        return false;\r\n    }\r\n    boolean wasAlready = false;\r\n    if (_log.shouldLog(Log.INFO))\r\n        _log.info(\"Banlist \" + peer.toBase64() + ((transport != null) ? \" on transport \" + transport : \"\"), new Exception(\"Banlist cause: \" + reason));\r\n    Entry e = new Entry();\r\n    e.expireOn = expireOn;\r\n    e.cause = reason;\r\n    e.causeCode = reasonCode;\r\n    e.transports = null;\r\n    if (transport != null) {\r\n        e.transports = new ConcurrentHashSet<String>(2);\r\n        e.transports.add(transport);\r\n    }\r\n    Entry old = _entries.get(peer);\r\n    if (old != null) {\r\n        wasAlready = true;\r\n        if (old.expireOn > e.expireOn) {\r\n            e.expireOn = old.expireOn;\r\n            e.cause = old.cause;\r\n            e.causeCode = old.causeCode;\r\n        }\r\n        if (e.transports != null) {\r\n            if (old.transports != null)\r\n                e.transports.addAll(old.transports);\r\n            else {\r\n                e.transports = null;\r\n                e.cause = reason;\r\n                e.causeCode = reasonCode;\r\n            }\r\n        }\r\n    }\r\n    _entries.put(peer, e);\r\n    if (transport == null) {\r\n        _context.netDb().fail(peer);\r\n        _context.tunnelManager().fail(peer);\r\n    }\r\n    if (!wasAlready)\r\n        _context.messageHistory().banlist(peer, reason);\r\n    return wasAlready;\r\n}"
}, {
	"Path": "net.i2p.addressbook.AddressBook.toString",
	"Comment": "return a string representation of the origin of the addressbook.",
	"Method": "String toString(){\r\n    if (this.location != null)\r\n        return \"Book from \" + this.location;\r\n    return \"Map containing \" + this.addresses.size() + \" entries\";\r\n}"
}, {
	"Path": "org.klomp.snark.bencode.BDecoder.get_special_map_digest",
	"Comment": "ugly hack. return the sha has over bytes that make up the special map.",
	"Method": "byte[] get_special_map_digest(){\r\n    if (sha_digest == null)\r\n        return null;\r\n    byte[] result = sha_digest.digest();\r\n    return result;\r\n}"
}, {
	"Path": "org.jrobin.core.Robin.getRrdAllocator",
	"Comment": "required to implement rrdupdater interface. you should never call this method directly.",
	"Method": "RrdAllocator getRrdAllocator(){\r\n    return parentArc.getRrdAllocator();\r\n}"
}, {
	"Path": "net.i2p.stat.Rate.getLifetimeTotalValue",
	"Comment": "since rate creation, what was the total value acrued through all events?",
	"Method": "double getLifetimeTotalValue(){\r\n    return _lifetimeTotalValue;\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.I2PTunnelClientBase.createI2PSocket",
	"Comment": "create a new i2psocket towards to the specified destination,adding it to the list of connections actually managed by thistunnel.",
	"Method": "I2PSocket createI2PSocket(Destination dest,I2PSocket createI2PSocket,Destination dest,int port,I2PSocket createI2PSocket,Destination dest,I2PSocketOptions opt){\r\n    if (dest == null)\r\n        throw new NullPointerException();\r\n    I2PSocket i2ps;\r\n    verifySocketManager();\r\n    i2ps = sockMgr.connect(dest, opt);\r\n    synchronized (sockLock) {\r\n        mySockets.add(i2ps);\r\n    }\r\n    return i2ps;\r\n}"
}, {
	"Path": "net.i2p.router.web.helpers.ConfigClientsHandler.startWebApp",
	"Comment": "big hack for the moment, not using properties for directory and portgo through all the jetty servers, find the one serving port 7657,requested and add the .war to that one",
	"Method": "void startWebApp(String app){\r\n    ContextHandlerCollection s = WebAppStarter.getConsoleServer(_context);\r\n    if (s != null) {\r\n        try {\r\n            File path = new File(_context.getBaseDir(), \"webapps\");\r\n            path = new File(path, app + \".war\");\r\n            WebAppStarter.startWebApp(_context, s, app, path.getAbsolutePath());\r\n            addFormNoticeNoEscape(_t(\"WebApp\") + \" <a href=\\\"/\" + app + \"/\\\">\" + _t(app) + \"<\/a> \" + _t(\"started\") + '.');\r\n        } catch (Throwable e) {\r\n            addFormError(_t(\"Failed to start\") + ' ' + _t(app) + \": \" + e);\r\n            _log.error(\"Failed to start webapp \" + app, e);\r\n        }\r\n        return;\r\n    }\r\n    addFormError(_t(\"Failed to find server.\"));\r\n}"
}, {
	"Path": "net.i2p.sam.client.SAMEventHandler.waitForHelloReply",
	"Comment": "wait for the connection to be established, returning the server version if everything went ok",
	"Method": "String waitForHelloReply(){\r\n    while (true) {\r\n        try {\r\n            synchronized (_helloLock) {\r\n                if (_helloOk == null)\r\n                    _helloLock.wait();\r\n                else\r\n                    return _helloOk.booleanValue() ? _version : null;\r\n            }\r\n        } catch (InterruptedException ie) {\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.I2PTunnelHTTPClient.startRunning",
	"Comment": "actually start working on incoming connections.overridden to start an internal socket too.",
	"Method": "void startRunning(){\r\n    super.startRunning();\r\n    if (open) {\r\n        this.isr = new InternalSocketRunner(this);\r\n        this.isr.start();\r\n        int port = getLocalPort();\r\n        _context.portMapper().register(PortMapper.SVC_HTTP_PROXY, getTunnel().listenHost, port);\r\n        _context.portMapper().register(PortMapper.SVC_HTTPS_PROXY, getTunnel().listenHost, port);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.addressbook.AddressBook.getLocation",
	"Comment": "return the location of the file this addressbook was constructed from.",
	"Method": "String getLocation(){\r\n    return this.location;\r\n}"
}, {
	"Path": "net.i2p.data.LeaseSet.hashCode",
	"Comment": "the destination has enough randomness in it to use it by itself for speed",
	"Method": "int hashCode(){\r\n    if (_destination == null)\r\n        return 0;\r\n    return _destination.hashCode();\r\n}"
}, {
	"Path": "net.i2p.sam.SAMHandler.stopHandling",
	"Comment": "stop the sam handler, close the client socket,unregister with the bridge.",
	"Method": "void stopHandling(){\r\n    if (_log.shouldInfo())\r\n        _log.info(\"Stopping: \" + this, new Exception(\"I did it\"));\r\n    synchronized (stopLock) {\r\n        stopHandler = true;\r\n    }\r\n    try {\r\n        closeClientSocket();\r\n    } catch (IOException e) {\r\n    }\r\n    bridge.unregister(this);\r\n}"
}, {
	"Path": "org.jrobin.core.FetchData.getDsIndex",
	"Comment": "retrieve the table index number of a datasource by name.names are case sensitive.",
	"Method": "int getDsIndex(String dsName){\r\n    for (int i = 0; i < dsNames.length; i++) {\r\n        if (dsNames[i].equals(dsName)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.klomp.snark.web.I2PSnarkServlet.escapeHTML2",
	"Comment": "modded from datahelper.does not escape ampersand. string must already have escaped ampersand.",
	"Method": "String escapeHTML2(String unescaped){\r\n    String escaped = unescaped;\r\n    for (int i = 0; i < escapeChars.length; i++) {\r\n        escaped = escaped.replace(escapeChars[i], escapeCodes[i]);\r\n    }\r\n    return escaped;\r\n}"
}, {
	"Path": "net.i2p.data.i2cp.SessionConfig.getDestination",
	"Comment": "retrieve the destination for which this session is supposed to connect",
	"Method": "Destination getDestination(){\r\n    return _destination;\r\n}"
}, {
	"Path": "io.helidon.security.jwt.jwk.Jwk.getOperations",
	"Comment": "permitted operations of this jwk.see rfc 7517, section 4.3.",
	"Method": "Optional<List<String>> getOperations(){\r\n    return operations;\r\n}"
}, {
	"Path": "net.i2p.router.startup.LoadRouterInfoJob.loadRouterInfo",
	"Comment": "loads router.info and either router.keys.dat or router.keys. see createrouterinfojob for file formats",
	"Method": "void loadRouterInfo(){\r\n    RouterInfo info = null;\r\n    File rif = new File(getContext().getRouterDir(), CreateRouterInfoJob.INFO_FILENAME);\r\n    boolean infoExists = rif.exists();\r\n    File rkf = new File(getContext().getRouterDir(), CreateRouterInfoJob.KEYS_FILENAME);\r\n    boolean keysExist = rkf.exists();\r\n    File rkf2 = new File(getContext().getRouterDir(), CreateRouterInfoJob.KEYS2_FILENAME);\r\n    boolean keys2Exist = rkf2.exists();\r\n    InputStream fis1 = null;\r\n    try {\r\n        if (infoExists && (keys2Exist || keysExist)) {\r\n            fis1 = new BufferedInputStream(new FileInputStream(rif));\r\n            info = new RouterInfo();\r\n            info.readBytes(fis1);\r\n            if (!info.isValid())\r\n                throw new DataFormatException(\"Our RouterInfo has a bad signature\");\r\n            if (_log.shouldLog(Log.DEBUG))\r\n                _log.debug(\"Reading in routerInfo from \" + rif.getAbsolutePath() + \" and it has \" + info.getAddresses().size() + \" addresses\");\r\n            if (DataHelper.eq(info.getOption(FamilyKeyCrypto.OPT_NAME), getContext().getProperty(FamilyKeyCrypto.PROP_FAMILY_NAME))) {\r\n                _us = info;\r\n            } else {\r\n                _log.logAlways(Log.WARN, \"NetDb family name changed\");\r\n            }\r\n        }\r\n        if (keys2Exist || keysExist) {\r\n            KeyData kd = readKeyData(rkf, rkf2);\r\n            PublicKey pubkey = kd.routerIdentity.getPublicKey();\r\n            SigningPublicKey signingPubKey = kd.routerIdentity.getSigningPublicKey();\r\n            PrivateKey privkey = kd.privateKey;\r\n            SigningPrivateKey signingPrivKey = kd.signingPrivateKey;\r\n            SigType stype = signingPubKey.getType();\r\n            SigType cstype = CreateRouterInfoJob.getSigTypeConfig(getContext());\r\n            boolean sigTypeChanged = stype != cstype;\r\n            if (sigTypeChanged && getContext().getProperty(CreateRouterInfoJob.PROP_ROUTER_SIGTYPE) == null) {\r\n                if (getContext().random().nextInt(4) > 0) {\r\n                    sigTypeChanged = false;\r\n                    if (_log.shouldWarn())\r\n                        _log.warn(\"Deferring RI rekey from \" + stype + \" to \" + cstype);\r\n                }\r\n            }\r\n            if (sigTypeChanged || shouldRebuild(privkey)) {\r\n                if (_us != null) {\r\n                    Hash h = _us.getIdentity().getHash();\r\n                    _log.logAlways(Log.WARN, \"Deleting old router identity \" + h.toBase64());\r\n                    File f = PersistentDataStore.getRouterInfoFile(getContext(), h);\r\n                    f.delete();\r\n                    getContext().banlist().banlistRouterForever(h, \"Our previous identity\");\r\n                    _us = null;\r\n                }\r\n                if (sigTypeChanged)\r\n                    _log.logAlways(Log.WARN, \"Rebuilding RouterInfo with new signature type \" + cstype);\r\n                if (fis1 != null) {\r\n                    try {\r\n                        fis1.close();\r\n                    } catch (IOException ioe) {\r\n                    }\r\n                    fis1 = null;\r\n                }\r\n                rif.delete();\r\n                rkf.delete();\r\n                rkf2.delete();\r\n                return;\r\n            }\r\n            getContext().keyManager().setKeys(pubkey, privkey, signingPubKey, signingPrivKey);\r\n        }\r\n    } catch (IOException ioe) {\r\n        _log.log(Log.CRIT, \"Error reading the router info from \" + rif.getAbsolutePath() + \" and the keys from \" + rkf.getAbsolutePath(), ioe);\r\n        _us = null;\r\n        if (fis1 != null) {\r\n            try {\r\n                fis1.close();\r\n            } catch (IOException ioe2) {\r\n            }\r\n            fis1 = null;\r\n        }\r\n        rif.delete();\r\n        rkf.delete();\r\n        rkf2.delete();\r\n    } catch (DataFormatException dfe) {\r\n        _log.log(Log.CRIT, \"Corrupt router info or keys at \" + rif.getAbsolutePath() + \" / \" + rkf.getAbsolutePath(), dfe);\r\n        _us = null;\r\n        if (fis1 != null) {\r\n            try {\r\n                fis1.close();\r\n            } catch (IOException ioe) {\r\n            }\r\n            fis1 = null;\r\n        }\r\n        rif.delete();\r\n        rkf.delete();\r\n        rkf2.delete();\r\n    } finally {\r\n        if (fis1 != null)\r\n            try {\r\n                fis1.close();\r\n            } catch (IOException ioe) {\r\n            }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.pool.TunnelPool.tellProfileFailed",
	"Comment": "blame all the other peers in the tunnel, with a probability inversely related to the tunnel length",
	"Method": "void tellProfileFailed(TunnelInfo cfg){\r\n    int len = cfg.getLength();\r\n    if (len < 2)\r\n        return;\r\n    int start = 0;\r\n    int end = len;\r\n    if (cfg.isInbound())\r\n        end--;\r\n    else\r\n        start++;\r\n    for (int i = start; i < end; i++) {\r\n        int pct = 100 / (len - 1);\r\n        if (cfg.isInbound() && len > 2) {\r\n            if (i == start)\r\n                pct *= 2;\r\n            else\r\n                pct /= 2;\r\n        }\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(toString() + \": Blaming \" + cfg.getPeer(i) + ' ' + pct + '%');\r\n        _context.profileManager().tunnelFailed(cfg.getPeer(i), pct);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.Router.get5mRate",
	"Comment": "when outboundonly is false, outbound rate in bytes per second. when true, max of inbound and outbound rate in bytes per second.",
	"Method": "int get5mRate(int get5mRate,boolean outboundOnly){\r\n    int send = 0;\r\n    RateStat rs = _context.statManager().getRate(\"bw.sendRate\");\r\n    if (rs != null)\r\n        send = (int) rs.getRate(5 * 60 * 1000).getAverageValue();\r\n    if (outboundOnly)\r\n        return send;\r\n    int recv = 0;\r\n    rs = _context.statManager().getRate(\"bw.recvRate\");\r\n    if (rs != null)\r\n        recv = (int) rs.getRate(5 * 60 * 1000).getAverageValue();\r\n    return Math.max(send, recv);\r\n}"
}, {
	"Path": "net.i2p.router.transport.CommSystemFacadeImpl.countActivePeers",
	"Comment": "how many peers are we currently connected to, that we have sent a message to or received a message from in the last five minutes.",
	"Method": "int countActivePeers(){\r\n    return _manager.countActivePeers();\r\n}"
}, {
	"Path": "com.spotify.heroic.metric.MetricCollection.getDataAs",
	"Comment": "helper method to fetch a collection of the given type, if applicable.this api is not safe, checks must be performed to verify that the encapsulated data type isthe same as expected.",
	"Method": "List<T> getDataAs(Class<T> expected){\r\n    if (expected == getType().type()) {\r\n        return (List<T>) getData();\r\n    }\r\n    throw new RuntimeException(\"collection not of type: \" + expected);\r\n}"
}, {
	"Path": "io.helidon.security.EndpointConfig.getInstanceKeys",
	"Comment": "get all classes of custom endpoint configuration object registered.",
	"Method": "Collection<Class<?>> getInstanceKeys(){\r\n    return customObjects.keys();\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterInfo.getPublished",
	"Comment": "retrieve the timestamp on which the info was published,essentially a version number for the routerinfo.this should be used to expire old routerinfo structures.",
	"Method": "long getPublished(){\r\n    return _published;\r\n}"
}, {
	"Path": "com.netflix.hollow.core.write.HollowWriteStateEngine.addAllObjectsFromPreviousCycle",
	"Comment": "add all of the objects from the previous cycle, exactly as they were in the previous cycle.",
	"Method": "void addAllObjectsFromPreviousCycle(){\r\n    for (HollowTypeWriteState typeState : orderedTypeStates) {\r\n        typeState.addAllObjectsFromPreviousCycle();\r\n    }\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.TunnelController.startStreamrServer",
	"Comment": "streamr server is a udp client, use the targetport field for listenport",
	"Method": "void startStreamrServer(){\r\n    String listenOn = getListenOnInterface();\r\n    if ((listenOn != null) && (listenOn.length() > 0)) {\r\n        _tunnel.runListenOn(new String[] { listenOn }, this);\r\n    }\r\n    String listenPort = getTargetPort();\r\n    String privKeyFile = getPrivKeyFile();\r\n    _tunnel.runStreamrServer(new String[] { listenPort, privKeyFile }, this);\r\n}"
}, {
	"Path": "org.cybergarage.upnp.Device.addService",
	"Comment": "add a service to device without checking for duplicate or syntax error",
	"Method": "void addService(Service s){\r\n    Node serviceListNode = getDeviceNode().getNode(ServiceList.ELEM_NAME);\r\n    if (serviceListNode == null) {\r\n        serviceListNode = new Node(ServiceList.ELEM_NAME);\r\n        getDeviceNode().addNode(serviceListNode);\r\n    }\r\n    serviceListNode.addNode(s.getServiceNode());\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerState.getWeRelayToThemAs",
	"Comment": "if we are serving as an introducer to them, this is the the tag thatthey can publish that, when presented to us, will cause us to senda relay introduction to the current peer",
	"Method": "long getWeRelayToThemAs(){\r\n    return _weRelayToThemAs;\r\n}"
}, {
	"Path": "org.jrobin.core.Util.toDoubleArray",
	"Comment": "converts an array of long primitives to an array of doubles.",
	"Method": "double[] toDoubleArray(long[] array){\r\n    double[] values = new double[array.length];\r\n    for (int i = 0; i < array.length; i++) {\r\n        values[i] = array[i];\r\n    }\r\n    return values;\r\n}"
}, {
	"Path": "net.i2p.addressbook.SubscriptionList.iterator",
	"Comment": "return an iterator over the addressbooks represented by the subscriptionsin this subscriptionlist.",
	"Method": "SubscriptionIterator iterator(){\r\n    return new SubscriptionIterator(this.subscriptions, this.delay, this.proxyHost, this.proxyPort);\r\n}"
}, {
	"Path": "org.klomp.snark.SnarkManager.getSavedTorrentTime",
	"Comment": "get the timestamp for a torrent from the config file.a snark.completelistener method.",
	"Method": "long getSavedTorrentTime(Snark snark){\r\n    Properties config = getConfig(snark);\r\n    String time = config.getProperty(PROP_META_STAMP);\r\n    if (time == null)\r\n        return 0;\r\n    try {\r\n        return Long.parseLong(time);\r\n    } catch (NumberFormatException nfe) {\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "net.metanotion.io.block.index.IBSkipSpan.seekAndLoadData",
	"Comment": "seek to the start of the span and load the data\tpackage private so bskipiterator can call it",
	"Method": "void seekAndLoadData(){\r\n    seekData();\r\n    loadData();\r\n}"
}, {
	"Path": "net.i2p.util.InternalSocket.isOutputShutdown",
	"Comment": "supported as of 0.9.33, prior to that threw unsupportedoperationexception",
	"Method": "boolean isOutputShutdown(){\r\n    return _os == null;\r\n}"
}, {
	"Path": "net.i2p.addressbook.Daemon.wakeup",
	"Comment": "call this to get the addressbook to reread its config and refetch its subscriptions.",
	"Method": "void wakeup(){\r\n    synchronized (this) {\r\n        notifyAll();\r\n    }\r\n}"
}, {
	"Path": "i2p.susi.webmail.pop3.POP3MailBox.doDelete",
	"Comment": "send dele for all pending deletions. must be connected.\tcaller must sync.\tleaves socket connected. caller must close on ioe.",
	"Method": "void doDelete(boolean noWait){\r\n    Collection<String> uidls = delayedDeleter.getQueued();\r\n    if (uidls.isEmpty())\r\n        return;\r\n    List<SendRecv> cmds = new ArrayList<SendRecv>(uidls.size());\r\n    for (String uid : uidls) {\r\n        int id = getIDfromUIDL(uid);\r\n        if (id < 0) {\r\n            delayedDeleter.removeQueued(uid);\r\n            continue;\r\n        }\r\n        if (noWait) {\r\n            sendCmd1aNoWait(\"DELE \" + id);\r\n            delayedDeleter.removeQueued(uid);\r\n            uidlToID.remove(uid);\r\n            sizes.remove(Integer.valueOf(id));\r\n        } else {\r\n            SendRecv sr = new SendRecv(\"DELE \" + id, Mode.A1);\r\n            sr.savedObject = uid;\r\n            cmds.add(sr);\r\n        }\r\n    }\r\n    if (!cmds.isEmpty()) {\r\n        sendCmds(cmds);\r\n        if (isConnected()) {\r\n            for (SendRecv sr : cmds) {\r\n                String uid = (String) sr.savedObject;\r\n                delayedDeleter.removeQueued(uid);\r\n                Integer id = uidlToID.remove(uid);\r\n                if (id != null)\r\n                    sizes.remove(id);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.client.impl.I2PSessionImpl.disconnected",
	"Comment": "the i2cpmessageeventlistener callback.recieve notification that the i2cp connection was disconnected.",
	"Method": "void disconnected(I2CPMessageReader reader){\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(getPrefix() + \"Disconnected\", new Exception(\"Disconnected\"));\r\n    disconnect();\r\n}"
}, {
	"Path": "org.jrobin.core.RrdToolkit.getCanonicalPaths",
	"Comment": "returns list of canonical file names with the specified extension in the given directory. this\tmethod is not rrd related, but might come handy to create a quick list of all rrd files\tin the given directory.",
	"Method": "String[] getCanonicalPaths(String directory,String extension,boolean resursive){\r\n    File baseDir = new File(directory);\r\n    if (!baseDir.isDirectory()) {\r\n        throw new IOException(\"Not a directory: \" + directory);\r\n    }\r\n    List<String> fileList = new LinkedList<String>();\r\n    traverseDirectory(new File(directory), extension, resursive, fileList);\r\n    String[] result = fileList.toArray(new String[fileList.size()]);\r\n    Arrays.sort(result);\r\n    return result;\r\n}"
}, {
	"Path": "net.i2p.stat.StatManager.createRequiredRateStat",
	"Comment": "create a new statistic to monitor the average value and confidence of some action.the stat is always created, independent of the stat.full setting or context.",
	"Method": "void createRequiredRateStat(String name,String description,String group,long periods){\r\n    if (_rateStats.containsKey(name))\r\n        return;\r\n    RateStat rs = new RateStat(name, description, group, periods);\r\n    if (_statLog != null)\r\n        rs.setStatLog(_statLog);\r\n    _rateStats.putIfAbsent(name, rs);\r\n}"
}, {
	"Path": "net.i2p.I2PAppContext.setGlobalContext",
	"Comment": "sets the default context, unless there is one already.not a public api, for use by routercontext only, not for external use.",
	"Method": "boolean setGlobalContext(I2PAppContext ctx){\r\n    synchronized (I2PAppContext.class) {\r\n        if (_globalAppContext == null) {\r\n            _globalAppContext = ctx;\r\n            return true;\r\n        }\r\n    }\r\n    System.out.println(\"Warning - New context not replacing old one, you now have a second one\");\r\n    (new Exception(\"I did it\")).printStackTrace();\r\n    return false;\r\n}"
}, {
	"Path": "net.i2p.router.message.OutboundClientMessageStatus.success",
	"Comment": "we succeeded.returns true if we had already succeeded before",
	"Method": "boolean success(){\r\n    boolean already = _success;\r\n    _success = true;\r\n    return already;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PacketBuilder.buildPeerTestToAlice",
	"Comment": "build a packet as if we are either bob or charlie and we are helping test alice.",
	"Method": "UDPPacket buildPeerTestToAlice(InetAddress aliceIP,int alicePort,SessionKey aliceIntroKey,SessionKey charlieIntroKey,long nonce){\r\n    UDPPacket packet = buildPacketHeader(PEER_TEST_FLAG_BYTE);\r\n    DatagramPacket pkt = packet.getPacket();\r\n    byte[] data = pkt.getData();\r\n    int off = HEADER_SIZE;\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Sending peer test \" + nonce + \" to Alice\");\r\n    DataHelper.toLong(data, off, 4, nonce);\r\n    off += 4;\r\n    byte[] ip = aliceIP.getAddress();\r\n    DataHelper.toLong(data, off, 1, ip.length);\r\n    off++;\r\n    System.arraycopy(ip, 0, data, off, ip.length);\r\n    off += ip.length;\r\n    DataHelper.toLong(data, off, 2, alicePort);\r\n    off += 2;\r\n    System.arraycopy(charlieIntroKey.getData(), 0, data, off, SessionKey.KEYSIZE_BYTES);\r\n    off += SessionKey.KEYSIZE_BYTES;\r\n    off = pad1(data, off);\r\n    off = pad2(data, off);\r\n    pkt.setLength(off);\r\n    authenticate(packet, aliceIntroKey, aliceIntroKey);\r\n    setTo(packet, aliceIP, alicePort);\r\n    packet.setMessageType(TYPE_TTA);\r\n    return packet;\r\n}"
}, {
	"Path": "com.netflix.hollow.tools.diff.HollowDiff.getTypeDiff",
	"Comment": "retrieve a diff report for a specific type in order to inspect the calculated differences",
	"Method": "HollowTypeDiff getTypeDiff(String type){\r\n    return typeDiffs.get(type);\r\n}"
}, {
	"Path": "net.i2p.sam.SAMStreamSession.createSocketHandler",
	"Comment": "create a new sam stream session socket handler, detaching its thread.",
	"Method": "int createSocketHandler(I2PSocket s,int id){\r\n    SAMStreamSessionSocketReader reader;\r\n    StreamSender sender;\r\n    if (id == 0) {\r\n        id = createUniqueId();\r\n    }\r\n    try {\r\n        reader = newSAMStreamSessionSocketReader(s, id);\r\n        sender = newStreamSender(s, id);\r\n    } catch (IOException e) {\r\n        _log.error(\"IOException when creating SAM STREAM session socket handler\", e);\r\n        recv.stopStreamReceiving();\r\n        return 0;\r\n    }\r\n    synchronized (handlersMap) {\r\n        handlersMap.put(Integer.valueOf(id), reader);\r\n        sendersMap.put(Integer.valueOf(id), sender);\r\n    }\r\n    I2PAppThread t = new I2PAppThread(reader, \"SAMReader\" + id);\r\n    t.start();\r\n    t = new I2PAppThread(sender, \"SAMSender\" + id);\r\n    t.start();\r\n    return id;\r\n}"
}, {
	"Path": "net.i2p.addressbook.ConfigParser.parse",
	"Comment": "return a map using the contents of the file file. if file cannot be read,use map instead, and write the result to where file should have been.",
	"Method": "Map<String, String> parse(BufferedReader input,Map<String, String> parse,File file,Map<String, String> parse,File file,Map<String, String> map){\r\n    Map<String, String> result;\r\n    try {\r\n        result = parse(file);\r\n        for (Map.Entry<String, String> entry : map.entrySet()) {\r\n            if (!result.containsKey(entry.getKey()))\r\n                result.put(entry.getKey(), entry.getValue());\r\n        }\r\n    } catch (IOException exp) {\r\n        result = map;\r\n        try {\r\n            write(result, file);\r\n        } catch (IOException exp2) {\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.PDPStatusBlock.getUnknownSeconds",
	"Comment": "returns the number of seconds of the current primary data point is\tunknown data.",
	"Method": "int getUnknownSeconds(){\r\n    return unknownSeconds;\r\n}"
}, {
	"Path": "net.i2p.crypto.eddsa.math.MathUtils.reduceModGroupOrder",
	"Comment": "reduces an integer in 2^8 bit representation modulo the group order and returns the result.",
	"Method": "byte[] reduceModGroupOrder(byte[] bytes){\r\n    final BigInteger b = toBigInteger(bytes).mod(groupOrder);\r\n    return toByteArray(b);\r\n}"
}, {
	"Path": "net.i2p.client.impl.I2CPMessageProducer.connect",
	"Comment": "send all the messages that a client needs to send to a router to establisha new session.",
	"Method": "void connect(I2PSessionImpl session){\r\n    updateBandwidth(session);\r\n    CreateSessionMessage msg = new CreateSessionMessage();\r\n    SessionConfig cfg = new SessionConfig(session.getMyDestination());\r\n    cfg.setOptions(session.getOptions());\r\n    if (session.isOffline()) {\r\n        cfg.setOfflineSignature(session.getOfflineExpiration(), session.getTransientSigningPublicKey(), session.getOfflineSignature());\r\n    }\r\n    try {\r\n        cfg.signSessionConfig(session.getPrivateKey());\r\n    } catch (DataFormatException dfe) {\r\n        throw new I2PSessionException(\"Unable to sign the session config\", dfe);\r\n    }\r\n    msg.setSessionConfig(cfg);\r\n    session.sendMessage_unchecked(msg);\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.DataSource.getPDPStatusBlock",
	"Comment": "returns the primary data point status block for this data source.",
	"Method": "PDPStatusBlock getPDPStatusBlock(){\r\n    return pdpStatusBlock;\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.PeerProfile.getCapacityValue",
	"Comment": "how many tunnels do we think this peer can handle over the next hour?",
	"Method": "float getCapacityValue(){\r\n    return _capacityValue;\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.TunnelControllerGroup.clearAllMessages",
	"Comment": "fetch and clear all outstanding messages from any of the known tunnels.",
	"Method": "List<String> clearAllMessages(){\r\n    List<String> msgs = new ArrayList<String>();\r\n    _controllersLock.readLock().lock();\r\n    try {\r\n        for (int i = 0; i < _controllers.size(); i++) {\r\n            TunnelController controller = _controllers.get(i);\r\n            msgs.addAll(controller.clearMessages());\r\n        }\r\n    } finally {\r\n        _controllersLock.readLock().unlock();\r\n    }\r\n    return msgs;\r\n}"
}, {
	"Path": "io.helidon.security.AuthenticationResponse.success",
	"Comment": "provider has authenticated the request and created a principal for a user.",
	"Method": "AuthenticationResponse success(Subject subject,AuthenticationResponse success,Subject user,Subject service,AuthenticationResponse success,Principal principal){\r\n    return success(Subject.builder().principal(principal).build());\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.I2PSocketOptionsImpl.init",
	"Comment": "sets max buffer size, connect timeout, read timeout, and write timeout from properties. does not set local port or remote port.",
	"Method": "void init(Properties opts){\r\n    _maxBufferSize = getInt(opts, PROP_BUFFER_SIZE, DEFAULT_BUFFER_SIZE);\r\n    _connectTimeout = getInt(opts, PROP_CONNECT_TIMEOUT, DEFAULT_CONNECT_TIMEOUT);\r\n    _readTimeout = getInt(opts, PROP_READ_TIMEOUT, -1);\r\n    _writeTimeout = getInt(opts, PROP_WRITE_TIMEOUT, DEFAULT_WRITE_TIMEOUT);\r\n}"
}, {
	"Path": "com.spotify.heroic.HeroicConfigurationTest.testConditionalFeatures",
	"Comment": "test that conditional features from configuration can be parsed and used.",
	"Method": "void testConditionalFeatures(){\r\n    final HeroicCoreInstance instance = testConfiguration(\"heroic-conditional-features.yml\");\r\n    final HttpContext httpContext1 = mock(HttpContext.class);\r\n    doReturn(Optional.of(\"bar\")).when(httpContext1).getClientId();\r\n    final HttpContext httpContext2 = mock(HttpContext.class);\r\n    doReturn(Optional.empty()).when(httpContext2).getClientId();\r\n    final QueryContext context1 = mock(QueryContext.class);\r\n    doReturn(Optional.of(httpContext1)).when(context1).getHttpContext();\r\n    final QueryContext context2 = mock(QueryContext.class);\r\n    doReturn(Optional.of(httpContext2)).when(context2).getHttpContext();\r\n    instance.inject(coreComponent -> {\r\n        final ConditionalFeatures conditional = coreComponent.conditionalFeatures().get();\r\n        assertEquals(FeatureSet.of(Feature.CACHE_QUERY), conditional.match(context1));\r\n        assertEquals(FeatureSet.empty(), conditional.match(context2));\r\n        return null;\r\n    });\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.util.ExpiringMap.set",
	"Comment": "stores value under given key and resets expiration counter.",
	"Method": "V set(K key,V value){\r\n    long current = System.currentTimeMillis();\r\n    map.put(key, Pair.create(value, current));\r\n    return value;\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.ProfileManagerImpl.dbLookupSuccessful",
	"Comment": "note that the peer was able to return the valid data for a db lookupthis will force creation of db stats",
	"Method": "void dbLookupSuccessful(Hash peer,long responseTimeMs){\r\n    PeerProfile data = getProfile(peer);\r\n    data.setLastHeardFrom(_context.clock().now());\r\n    if (!data.getIsExpandedDB())\r\n        data.expandDBProfile();\r\n    data.getDbResponseTime().addData(responseTimeMs, responseTimeMs);\r\n    DBHistory hist = data.getDBHistory();\r\n    hist.lookupSuccessful();\r\n}"
}, {
	"Path": "com.southernstorm.noise.protocol.SymmetricState.encryptAndHash",
	"Comment": "encrypts a block of plaintext and mixes the ciphertext into the handshake hash.",
	"Method": "int encryptAndHash(byte[] plaintext,int plaintextOffset,byte[] ciphertext,int ciphertextOffset,int length){\r\n    int ciphertextLength = cipher.encryptWithAd(h, plaintext, plaintextOffset, ciphertext, ciphertextOffset, length);\r\n    mixHash(ciphertext, ciphertextOffset, ciphertextLength);\r\n    return ciphertextLength;\r\n}"
}, {
	"Path": "io.helidon.security.EndpointConfig.combineAnnotations",
	"Comment": "get all annotations of a specific class declared on any level.",
	"Method": "List<T> combineAnnotations(Class<T> annotationClass,AnnotationScope scopes){\r\n    List<T> result = new LinkedList();\r\n    result.addAll((Collection<? extends T>) getAnnotations(scopes).getOrDefault(annotationClass, CollectionsHelper.listOf()));\r\n    return result;\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.IgnoreManager.getComponentName",
	"Comment": "unique name of this component. if there is another component with the same name or name is null internalassertion will occur.",
	"Method": "String getComponentName(){\r\n    return \"IgnoreManager\";\r\n}"
}, {
	"Path": "org.jrobin.core.FetchData.dump",
	"Comment": "dumps the content of the whole fetchdata object. useful for debugging.",
	"Method": "String dump(){\r\n    StringBuffer buffer = new StringBuffer(\"\");\r\n    for (int row = 0; row < getRowCount(); row++) {\r\n        buffer.append(timestamps[row]);\r\n        buffer.append(\":  \");\r\n        for (int dsIndex = 0; dsIndex < getColumnCount(); dsIndex++) {\r\n            buffer.append(Util.formatDouble(values[dsIndex][row], true));\r\n            buffer.append(\"  \");\r\n        }\r\n        buffer.append(\"\\n\");\r\n    }\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "com.netflix.hollow.core.read.filter.HollowFilterConfig.addType",
	"Comment": "add a type.all fields in the type will be either excluded or included, depending onwhether this is an exclude or include filter, respectively.",
	"Method": "void addType(String type){\r\n    specifiedTypes.add(type);\r\n}"
}, {
	"Path": "com.netflix.hollow.api.client.HollowUpdatePlanner.includeNextDelta",
	"Comment": "includes the next delta only if it will not take usthe desired version",
	"Method": "long includeNextDelta(HollowUpdatePlan plan,long currentVersion,long desiredVersion){\r\n    HollowConsumer.Blob transition = transitionCreator.retrieveDeltaBlob(currentVersion);\r\n    if (transition != null) {\r\n        if (transition.getToVersion() <= desiredVersion) {\r\n            plan.add(transition);\r\n        }\r\n        return transition.getToVersion();\r\n    }\r\n    return HollowConstants.VERSION_LATEST;\r\n}"
}, {
	"Path": "com.southernstorm.noise.protocol.CipherStatePair.getReceiver",
	"Comment": "gets the cipherstate to use to receive packets from the remote party.",
	"Method": "CipherState getReceiver(){\r\n    return recv;\r\n}"
}, {
	"Path": "net.i2p.router.transport.UPnP.discoverService",
	"Comment": "traverses the structure of the router device looking for the port mapping service.",
	"Method": "void discoverService(){\r\n    synchronized (lock) {\r\n        for (Device current : _router.getDeviceList()) {\r\n            String type = current.getDeviceType();\r\n            if (!(WAN_DEVICE.equals(type) || WAN_DEVICE_2.equals(type)))\r\n                continue;\r\n            DeviceList l = current.getDeviceList();\r\n            for (int i = 0; i < current.getDeviceList().size(); i++) {\r\n                Device current2 = l.getDevice(i);\r\n                type = current2.getDeviceType();\r\n                if (!(WANCON_DEVICE.equals(type) || WANCON_DEVICE_2.equals(type)))\r\n                    continue;\r\n                _service = current2.getService(WAN_IP_CONNECTION_2);\r\n                if (_service == null) {\r\n                    _service = current2.getService(WAN_IP_CONNECTION);\r\n                    if (_service == null) {\r\n                        _service = current2.getService(WAN_PPP_CONNECTION);\r\n                        if (_service == null) {\r\n                            if (_log.shouldWarn())\r\n                                _log.warn(_router.getFriendlyName() + \" doesn't have any recognized connection type; we won't be able to use it!\");\r\n                        }\r\n                    }\r\n                }\r\n                if (_log.shouldWarn()) {\r\n                    Service svc2 = current2.getService(WAN_IPV6_CONNECTION);\r\n                    if (svc2 != null)\r\n                        _log.warn(_router.getFriendlyName() + \" supports WANIPv6Connection, but we don't\");\r\n                }\r\n                _serviceLacksAPM = false;\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterInfo.setAddresses",
	"Comment": "specify a set of routeraddress structures at which this routercan be contacted.",
	"Method": "void setAddresses(Collection<RouterAddress> addresses){\r\n    if (_signature != null || !_addresses.isEmpty())\r\n        throw new IllegalStateException();\r\n    if (addresses != null) {\r\n        _addresses.addAll(addresses);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.data.DataHelper.toLongLE",
	"Comment": "little endian, i.e. backwards. not for use in i2p protocols.",
	"Method": "void toLongLE(byte target,int offset,int numBytes,long value){\r\n    if (numBytes <= 0 || numBytes > 8)\r\n        throw new IllegalArgumentException(\"Invalid number of bytes\");\r\n    if (value < 0)\r\n        throw new IllegalArgumentException(\"Negative value not allowed\");\r\n    int limit = offset + numBytes;\r\n    for (int i = offset; i < limit; i++) {\r\n        target[i] = (byte) value;\r\n        value >>= 8;\r\n    }\r\n}"
}, {
	"Path": "net.i2p.crypto.CryptixRijndael_Algorithm.toString",
	"Comment": "returns a string of hexadecimal digits from an integer array. eachint is converted to 4 hex symbols.",
	"Method": "String toString(byte[] ba,String toString,int[] ia){\r\n    int length = ia.length;\r\n    char[] buf = new char[length * 8];\r\n    for (int i = 0, j = 0, k; i < length; i++) {\r\n        k = ia[i];\r\n        buf[j++] = _HEX_DIGITS[(k >>> 28) & 0x0F];\r\n        buf[j++] = _HEX_DIGITS[(k >>> 24) & 0x0F];\r\n        buf[j++] = _HEX_DIGITS[(k >>> 20) & 0x0F];\r\n        buf[j++] = _HEX_DIGITS[(k >>> 16) & 0x0F];\r\n        buf[j++] = _HEX_DIGITS[(k >>> 12) & 0x0F];\r\n        buf[j++] = _HEX_DIGITS[(k >>> 8) & 0x0F];\r\n        buf[j++] = _HEX_DIGITS[(k >>> 4) & 0x0F];\r\n        buf[j++] = _HEX_DIGITS[k & 0x0F];\r\n    }\r\n    return new String(buf);\r\n}"
}, {
	"Path": "com.netflix.hollow.tools.diff.specific.HollowSpecificDiff.setRecordMatchPaths",
	"Comment": "set the primary key paths which will be used to find matching records across the two states",
	"Method": "void setRecordMatchPaths(String paths){\r\n    for (String path : paths) matcher.addMatchPath(path);\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.udpTunnel.I2PTunnelUDPClientBase.close",
	"Comment": "i2ptunneltask methodsclasses should override to close udp side as well",
	"Method": "boolean close(boolean forced){\r\n    if (!open)\r\n        return true;\r\n    if (_session != null) {\r\n        try {\r\n            _session.destroySession();\r\n        } catch (I2PSessionException ise) {\r\n        }\r\n    }\r\n    l.log(\"Closing client \" + toString());\r\n    open = false;\r\n    return true;\r\n}"
}, {
	"Path": "org.jrobin.core.RrdJRobin14FileBackend.setLength",
	"Comment": "sets length of the underlying rrd file. this method is called only once, immediately\tafter a new rrd file gets created.",
	"Method": "void setLength(long length){\r\n    m_file.setLength(length);\r\n}"
}, {
	"Path": "org.jrobin.data.DataProcessor.getTimestampsPerPixel",
	"Comment": "calculates timestamps which correspond to individual pixels on the graph.",
	"Method": "long[] getTimestampsPerPixel(int pixelCount,long[] getTimestampsPerPixel){\r\n    long[] times = new long[pixelCount];\r\n    long span = tEnd - tStart;\r\n    for (int i = 0; i < pixelCount; i++) {\r\n        times[i] = Math.round(tStart + (double) (span * i) / (double) (pixelCount - 1));\r\n    }\r\n    return times;\r\n}"
}, {
	"Path": "gnu.gettext.GettextResource.npgettext",
	"Comment": "returns the plural form for n of the translation ofmsgid in the context of msgctxt.",
	"Method": "String npgettext(ResourceBundle catalog,String msgctxt,String msgid,String msgid_plural,long n){\r\n    String result = ngettextnull(catalog, msgctxt + CONTEXT_GLUE + msgid, n);\r\n    if (result != null)\r\n        return result;\r\n    return (n != 1 ? msgid_plural : msgid);\r\n}"
}, {
	"Path": "edu.internet2.ndt.Tcpbw100.showBufferedBytesInfo",
	"Comment": "pop up a window to display some information about tcp packet queuing.",
	"Method": "void showBufferedBytesInfo(){\r\n    JOptionPane.showMessageDialog(null, _resBundDisplayMsgs.getString(\"packetQueuingInfo\"), _resBundDisplayMsgs.getString(\"packetQueuing\"), JOptionPane.INFORMATION_MESSAGE);\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PacketBuilder.buildPeerTestFromAlice",
	"Comment": "build a packet as if we are alice and we either want bob to begin a peer test or charlie to finish a peer test.",
	"Method": "UDPPacket buildPeerTestFromAlice(InetAddress toIP,int toPort,SessionKey toIntroKey,long nonce,SessionKey aliceIntroKey,UDPPacket buildPeerTestFromAlice,InetAddress toIP,int toPort,SessionKey toCipherKey,SessionKey toMACKey,long nonce,SessionKey aliceIntroKey){\r\n    UDPPacket packet = buildPacketHeader(PEER_TEST_FLAG_BYTE);\r\n    DatagramPacket pkt = packet.getPacket();\r\n    byte[] data = pkt.getData();\r\n    int off = HEADER_SIZE;\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Sending peer test \" + nonce + \" to Bob\");\r\n    DataHelper.toLong(data, off, 4, nonce);\r\n    off += 4;\r\n    DataHelper.toLong(data, off, 1, 0);\r\n    off++;\r\n    DataHelper.toLong(data, off, 2, 0);\r\n    off += 2;\r\n    System.arraycopy(aliceIntroKey.getData(), 0, data, off, SessionKey.KEYSIZE_BYTES);\r\n    off += SessionKey.KEYSIZE_BYTES;\r\n    off = pad1(data, off);\r\n    off = pad2(data, off);\r\n    pkt.setLength(off);\r\n    authenticate(packet, toCipherKey, toMACKey);\r\n    setTo(packet, toIP, toPort);\r\n    packet.setMessageType(TYPE_TFA);\r\n    return packet;\r\n}"
}, {
	"Path": "com.netflix.hollow.api.client.HollowClientUpdater.shouldCreateSnapshotPlan",
	"Comment": "whether or not a snapshot plan should be created. visible for testing.",
	"Method": "boolean shouldCreateSnapshotPlan(){\r\n    return getCurrentVersionId() == HollowConstants.VERSION_NONE || (forceDoubleSnapshot && doubleSnapshotConfig.allowDoubleSnapshot());\r\n}"
}, {
	"Path": "org.jrobin.core.RrdDb.getLastDatasourceValues",
	"Comment": "returns an array of last datasource values. the first value in the array corresponds\tto the first datasource defined in the rrddb and so on.",
	"Method": "double[] getLastDatasourceValues(){\r\n    double[] values = new double[datasources.length];\r\n    for (int i = 0; i < values.length; i++) {\r\n        values[i] = datasources[i].getLastValue();\r\n    }\r\n    return values;\r\n}"
}, {
	"Path": "com.netflix.hollow.core.write.HollowBlobWriter.writeDelta",
	"Comment": "serialize the changes necessary to transition a consumer from the previous stateto the current state as a delta blob.",
	"Method": "void writeDelta(OutputStream os){\r\n    stateEngine.prepareForWrite();\r\n    if (stateEngine.isRestored())\r\n        stateEngine.ensureAllNecessaryStatesRestored();\r\n    List<HollowSchema> changedTypes = changedTypes();\r\n    DataOutputStream dos = new DataOutputStream(os);\r\n    writeHeader(dos, changedTypes, false);\r\n    VarInt.writeVInt(dos, changedTypes.size());\r\n    SimultaneousExecutor executor = new SimultaneousExecutor();\r\n    for (final HollowTypeWriteState typeState : stateEngine.getOrderedTypeStates()) {\r\n        executor.execute(new Runnable() {\r\n            public void run() {\r\n                if (typeState.hasChangedSinceLastCycle())\r\n                    typeState.calculateDelta();\r\n            }\r\n        });\r\n    }\r\n    try {\r\n        executor.awaitSuccessfulCompletion();\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    for (HollowTypeWriteState typeState : stateEngine.getOrderedTypeStates()) {\r\n        if (typeState.hasChangedSinceLastCycle()) {\r\n            HollowSchema schema = typeState.getSchema();\r\n            schema.writeTo(dos);\r\n            writeNumShards(dos, typeState.getNumShards());\r\n            typeState.writeDelta(dos);\r\n        }\r\n    }\r\n    os.flush();\r\n}"
}, {
	"Path": "com.netflix.hollow.core.write.HollowBlobWriter.writeDelta",
	"Comment": "serialize the changes necessary to transition a consumer from the previous stateto the current state as a delta blob.",
	"Method": "void writeDelta(OutputStream os){\r\n    if (typeState.hasChangedSinceLastCycle())\r\n        typeState.calculateDelta();\r\n}"
}, {
	"Path": "net.i2p.crypto.CryptixAESEngine.decryptBlock",
	"Comment": "decrypt exactly 16 bytes of data with the session key provided",
	"Method": "void decryptBlock(byte payload,int inIndex,SessionKey sessionKey,byte rv,int outIndex){\r\n    Object pkey = sessionKey.getPreparedKey();\r\n    if (pkey == null) {\r\n        try {\r\n            pkey = CryptixRijndael_Algorithm.makeKey(sessionKey.getData(), 16);\r\n            sessionKey.setPreparedKey(pkey);\r\n        } catch (InvalidKeyException ike) {\r\n            _log.log(Log.CRIT, \"Invalid key\", ike);\r\n            throw new IllegalArgumentException(\"invalid key?  \" + ike.getMessage());\r\n        }\r\n    }\r\n    CryptixRijndael_Algorithm.blockDecrypt(payload, rv, inIndex, outIndex, pkey);\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.ExploreKeySelectorJob.selectKeysToExplore",
	"Comment": "run through all kbuckets with too few routers and generate a random keyfor it, with a maximum number of keys limited by the exploration pool size",
	"Method": "Collection<Hash> selectKeysToExplore(){\r\n    Set<Hash> alreadyQueued = _facade.getExploreKeys();\r\n    if (alreadyQueued.size() > KademliaNetworkDatabaseFacade.MAX_EXPLORE_QUEUE)\r\n        return null;\r\n    return _facade.getKBuckets().getExploreKeys(OLD_BUCKET_TIME);\r\n}"
}, {
	"Path": "com.google.zxing.qrcode.encoder.MaskUtil.applyMaskPenaltyRule1Internal",
	"Comment": "helper function for applymaskpenaltyrule1. we need this for doing this calculation in bothvertical and horizontal orders respectively.",
	"Method": "int applyMaskPenaltyRule1Internal(ByteMatrix matrix,boolean isHorizontal){\r\n    int penalty = 0;\r\n    int iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();\r\n    int jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();\r\n    byte[][] array = matrix.getArray();\r\n    for (int i = 0; i < iLimit; i++) {\r\n        int numSameBitCells = 0;\r\n        int prevBit = -1;\r\n        for (int j = 0; j < jLimit; j++) {\r\n            int bit = isHorizontal ? array[i][j] : array[j][i];\r\n            if (bit == prevBit) {\r\n                numSameBitCells++;\r\n            } else {\r\n                if (numSameBitCells >= 5) {\r\n                    penalty += N1 + (numSameBitCells - 5);\r\n                }\r\n                numSameBitCells = 1;\r\n                prevBit = bit;\r\n            }\r\n        }\r\n        if (numSameBitCells >= 5) {\r\n            penalty += N1 + (numSameBitCells - 5);\r\n        }\r\n    }\r\n    return penalty;\r\n}"
}, {
	"Path": "org.klomp.snark.bencode.BDecoder.bdecodeNumber",
	"Comment": "returns the next bencoded value on the stream and makes sure itis a number. if it is not a number it will throwinvalidbencodingexception.",
	"Method": "BEValue bdecodeNumber(){\r\n    int c = getNextIndicator();\r\n    if (c != 'i')\r\n        throw new InvalidBEncodingException(\"Expected 'i', not '\" + (char) c + \"'\");\r\n    indicator = 0;\r\n    c = read();\r\n    if (c == '0') {\r\n        c = read();\r\n        if (c == 'e')\r\n            return new BEValue(Integer.valueOf(0));\r\n        else\r\n            throw new InvalidBEncodingException(\"'e' expected after zero,\" + \" not '\" + (char) c + \"'\");\r\n    }\r\n    StringBuilder chars = new StringBuilder(16);\r\n    if (c == '-') {\r\n        chars.append((char) c);\r\n        c = read();\r\n    }\r\n    if (c < '1' || c > '9')\r\n        throw new InvalidBEncodingException(\"Invalid Integer start '\" + (char) c + \"'\");\r\n    chars.append((char) c);\r\n    c = read();\r\n    while (c >= '0' && c <= '9') {\r\n        chars.append((char) c);\r\n        c = read();\r\n    }\r\n    if (c != 'e')\r\n        throw new InvalidBEncodingException(\"Integer should end with 'e'\");\r\n    String s = chars.toString();\r\n    int len = s.length();\r\n    Number num;\r\n    if (len < 10)\r\n        num = Integer.valueOf(s);\r\n    else if (len < 19)\r\n        num = Long.valueOf(s);\r\n    else if (len > 256)\r\n        throw new InvalidBEncodingException(\"Too many digits: \" + len);\r\n    else\r\n        num = new BigInteger(s);\r\n    return new BEValue(num);\r\n}"
}, {
	"Path": "com.spotify.heroic.metrics.EWMA.fiveMinuteEWMA",
	"Comment": "creates a new ewma which is equivalent to the unix five minute load average and which expectsto be ticked every 5 seconds.",
	"Method": "EWMA fiveMinuteEWMA(){\r\n    return new EWMA(M5_ALPHA, INTERVAL, TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "net.i2p.util.LookaheadInputStream.getFooter",
	"Comment": "grab the lookahead footer.this will be of size lookaheadsize given in constructor.the last byte received will be in the last byte of the array.",
	"Method": "byte[] getFooter(){\r\n    if (index == 0)\r\n        return _footerLookahead;\r\n    byte[] rv = new byte[size];\r\n    System.arraycopy(_footerLookahead, index, rv, 0, size - index);\r\n    System.arraycopy(_footerLookahead, 0, rv, size - index, index);\r\n    return rv;\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.SSLClientUtil.initializeFactory",
	"Comment": "sets up the sslcontext and sets the socket factory. no option prefix allowed.",
	"Method": "SSLServerSocketFactory initializeFactory(Properties opts){\r\n    String ksPass = opts.getProperty(PROP_KEYSTORE_PASSWORD, KeyStoreUtil.DEFAULT_KEYSTORE_PASSWORD);\r\n    String keyPass = opts.getProperty(PROP_KEY_PASSWORD);\r\n    if (keyPass == null) {\r\n        throw new IOException(\"No key password, set \" + PROP_KEY_PASSWORD + \" in \" + (new File(I2PAppContext.getGlobalContext().getConfigDir(), \"i2ptunnel.config\")).getAbsolutePath());\r\n    }\r\n    String ksname = opts.getProperty(PROP_KS_NAME);\r\n    if (ksname == null) {\r\n        throw new IOException(\"No keystore, set \" + PROP_KS_NAME + \" in \" + (new File(I2PAppContext.getGlobalContext().getConfigDir(), \"i2ptunnel.config\")).getAbsolutePath());\r\n    }\r\n    File ks = new File(ksname);\r\n    if (!ks.isAbsolute()) {\r\n        ks = new File(I2PAppContext.getGlobalContext().getConfigDir(), KS_DIR);\r\n        ks = new File(ks, ksname);\r\n    }\r\n    InputStream fis = null;\r\n    try {\r\n        SSLContext sslc = SSLContext.getInstance(\"TLS\");\r\n        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\r\n        fis = new FileInputStream(ks);\r\n        keyStore.load(fis, ksPass.toCharArray());\r\n        KeyStoreUtil.logCertExpiration(keyStore, ks.getAbsolutePath(), 180 * 24 * 60 * 60 * 1000L);\r\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\r\n        kmf.init(keyStore, keyPass.toCharArray());\r\n        sslc.init(kmf.getKeyManagers(), null, I2PAppContext.getGlobalContext().random());\r\n        return sslc.getServerSocketFactory();\r\n    } catch (GeneralSecurityException gse) {\r\n        IOException ioe = new IOException(\"keystore error\");\r\n        ioe.initCause(gse);\r\n        throw ioe;\r\n    } finally {\r\n        if (fis != null)\r\n            try {\r\n                fis.close();\r\n            } catch (IOException ioe) {\r\n            }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.client.ClientConnectionRunner.receiveMessage",
	"Comment": "synchronously deliver the message to the current runnerfailure indication is available as of 0.9.29.fails on e.g. queue overflow to client, client dead, etc.",
	"Method": "boolean receiveMessage(Destination toDest,Destination fromDest,Payload payload,boolean receiveMessage,Hash toHash,Destination fromDest,Payload payload){\r\n    SessionParams sp = _sessions.get(toHash);\r\n    if (sp == null) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"No session found for receiveMessage()\");\r\n        return false;\r\n    }\r\n    return receiveMessage(sp.dest, fromDest, payload);\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.highlighter.IgnoreColorSettingsPage.getAdditionalHighlightingTagToDescriptorMap",
	"Comment": "returns the mapping from special tag names surrounding the regions to be highlightedin the preview text.",
	"Method": "Map<String, TextAttributesKey> getAdditionalHighlightingTagToDescriptorMap(){\r\n    return null;\r\n}"
}, {
	"Path": "net.i2p.util.InternalSocket.isConnected",
	"Comment": "supported as of 0.9.33, prior to that threw unsupportedoperationexception",
	"Method": "boolean isConnected(){\r\n    return _is != null || _os != null;\r\n}"
}, {
	"Path": "net.i2p.router.transport.crypto.DHSessionKeyBuilder.getMyPublicValue",
	"Comment": "retrieve the public value used by the local participant in the dh exchange,",
	"Method": "BigInteger getMyPublicValue(){\r\n    return _myPublicValue;\r\n}"
}, {
	"Path": "io.helidon.security.SecurityRequestBuilder.tracingSpan",
	"Comment": "tracing span to support open tracing. provider developer can add additional spans as children of this spanto trace their progress.",
	"Method": "T tracingSpan(Span span){\r\n    this.tracingSpan = span;\r\n    return myInstance;\r\n}"
}, {
	"Path": "org.klomp.snark.SnarkManager.listTorrentFiles",
	"Comment": "set of canonical .torrent filenames that we are dealing with. an unsynchronized copy.",
	"Method": "Set<String> listTorrentFiles(){\r\n    return new HashSet<String>(_snarks.keySet());\r\n}"
}, {
	"Path": "net.i2p.router.RouterContext.setGlobalContext",
	"Comment": "sets the default context, unless there is one already.not a public api, for use by router only, not for external use.",
	"Method": "boolean setGlobalContext(RouterContext ctx){\r\n    _contexts.add(ctx);\r\n    return I2PAppContext.setGlobalContext(ctx);\r\n}"
}, {
	"Path": "org.jrobin.core.RrdDb.getDatasource",
	"Comment": "returns datasource object corresponding to the given datasource name.",
	"Method": "Datasource getDatasource(int dsIndex,Datasource getDatasource,String dsName){\r\n    try {\r\n        return getDatasource(getDsIndex(dsName));\r\n    } catch (RrdException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "i2p.susi.webmail.pop3.POP3MailBox.deletePending",
	"Comment": "delete all pending deletions at once.\tif previously connected, leaves connected.\tif not previously connected, closes connection when done.",
	"Method": "void deletePending(boolean noWait){\r\n    Collection<String> uidls = delayedDeleter.getQueued();\r\n    if (uidls.isEmpty())\r\n        return;\r\n    synchronized (synchronizer) {\r\n        try {\r\n            if (isConnected()) {\r\n                doDelete(noWait);\r\n            } else {\r\n                checkConnection();\r\n                sendCmd1a(\"QUIT\");\r\n                if (socket != null) {\r\n                    try {\r\n                        socket.close();\r\n                    } catch (IOException e) {\r\n                    }\r\n                    socket = null;\r\n                    connected = false;\r\n                }\r\n            }\r\n        } catch (IOException ioe) {\r\n            if (_log.shouldDebug())\r\n                _log.debug(\"Error deleting\", ioe);\r\n            if (socket != null) {\r\n                try {\r\n                    socket.close();\r\n                } catch (IOException e) {\r\n                }\r\n                socket = null;\r\n                connected = false;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterAddress.setOptions",
	"Comment": "specify the transport specific options necessary for communication.makes a copy.",
	"Method": "void setOptions(Properties options){\r\n    if (!_options.isEmpty())\r\n        throw new IllegalStateException();\r\n    _options.putAll(options);\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.util.yaml.YamlHelper.getYamlKeyValueAsBoolean",
	"Comment": "get false or true value for given key or null if not found or invalid value was found",
	"Method": "Boolean getYamlKeyValueAsBoolean(YAMLKeyValue yamlKeyValue,String key){\r\n    YAMLKeyValue autowire = YamlHelper.getYamlKeyValue(yamlKeyValue, key);\r\n    if (autowire == null) {\r\n        return null;\r\n    }\r\n    YAMLValue value = autowire.getValue();\r\n    if (!(value instanceof YAMLScalar)) {\r\n        return null;\r\n    }\r\n    String textValue = ((YAMLScalar) value).getTextValue().toLowerCase();\r\n    switch(textValue) {\r\n        case \"false\":\r\n            return false;\r\n        case \"true\":\r\n            return true;\r\n        default:\r\n            return null;\r\n    }\r\n}"
}, {
	"Path": "com.spotify.heroic.AbstractLocalClusterIT.metadataFactories",
	"Comment": "overload the default metadata behavior.if empty, default factories will be used.",
	"Method": "List<NodeMetadataFactory> metadataFactories(){\r\n    return ImmutableList.of();\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.ui.GeneratorDialog.dispose",
	"Comment": "dispose the wrapped and releases all resources allocated be the wrapper to helpmore efficient garbage collection. you should never invoke this method twice orinvoke any method of the wrapper after invocation of dispose.",
	"Method": "void dispose(){\r\n    tree.removeTreeSelectionListener(treeSelectionListener);\r\n    EditorFactory.getInstance().releaseEditor(preview);\r\n    super.dispose();\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterAddress.equals",
	"Comment": "transport, host, and port only.never look at cost or other properties.",
	"Method": "boolean equals(Object object){\r\n    if (object == this)\r\n        return true;\r\n    if ((object == null) || !(object instanceof RouterAddress))\r\n        return false;\r\n    RouterAddress addr = (RouterAddress) object;\r\n    return getPort() == addr.getPort() && DataHelper.eq(getHost(), addr.getHost()) && DataHelper.eq(_transportStyle, addr._transportStyle);\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.TunnelHistory.getLastRejectedProbabalistic",
	"Comment": "when the peer last refused to participate in a tunnel probabalistically",
	"Method": "long getLastRejectedProbabalistic(){\r\n    return _lastRejectedProbabalistic;\r\n}"
}, {
	"Path": "io.helidon.security.OutboundSecurityClientBuilder.build",
	"Comment": "build an instance of a security client. the client is immutable.",
	"Method": "SecurityClient<OutboundSecurityResponse> build(){\r\n    return new OutboundSecurityClientImpl(security, context, super.buildRequest(), super.getProviderName(), outboundEnvironment, outboundEndpointConfig);\r\n}"
}, {
	"Path": "com.spotify.heroic.test.AbstractMetricBackendIT.testMaxBatchSize",
	"Comment": "some backends have limits on how many metrics should be written in a single request.this test case creates a dense pool of metrics after a given max batch size to make sure thatthey can be written and read out.",
	"Method": "void testMaxBatchSize(){\r\n    assumeTrue(\"max batch size\", maxBatchSize.isPresent());\r\n    final int maxBatchSize = this.maxBatchSize.get();\r\n    newCase().denseStart(100).dense(maxBatchSize * 4).forEach((input, expected) -> {\r\n        verifyReadWrite(input, expected, new DateRange(99L, 100L + (maxBatchSize * 4)));\r\n    });\r\n}"
}, {
	"Path": "net.i2p.data.SimpleDataStructure.hashCode",
	"Comment": "we assume the data has enough randomness in it, so use the first 4 bytes for speed.if this is not the case, override in the extending class.",
	"Method": "int hashCode(){\r\n    if (_data == null)\r\n        return 0;\r\n    int rv = _data[0];\r\n    for (int i = 1; i < 4; i++) rv ^= (_data[i] << (i * 8));\r\n    return rv;\r\n}"
}, {
	"Path": "net.i2p.addressbook.AddressBook.isValidDest",
	"Comment": "do basic validation of the b64 dest, without bothering to instantiate it",
	"Method": "boolean isValidDest(String dest){\r\n    return ((dest.length() == MIN_DEST_LENGTH && dest.endsWith(\"AA\")) || (dest.length() > MIN_DEST_LENGTH && dest.length() <= MAX_DEST_LENGTH)) && ((dest.length() % 4) != 1) && B64_PATTERN.matcher(dest).matches();\r\n}"
}, {
	"Path": "net.i2p.data.i2cp.SendMessageExpiresMessage.writeMessage",
	"Comment": "write out the full message to the stream, including the 4 byte size and 1 byte type header.override the parent so we can be more mem efficient",
	"Method": "void writeMessage(OutputStream out){\r\n    if (_sessionId == null)\r\n        throw new I2CPMessageException(\"No session ID\");\r\n    if (_destination == null)\r\n        throw new I2CPMessageException(\"No dest\");\r\n    if (_payload == null)\r\n        throw new I2CPMessageException(\"No payload\");\r\n    if (_nonce < 0)\r\n        throw new I2CPMessageException(\"No nonce\");\r\n    int len = 2 + _destination.size() + _payload.getSize() + 4 + 4 + DataHelper.DATE_LENGTH;\r\n    try {\r\n        DataHelper.writeLong(out, 4, len);\r\n        out.write((byte) MESSAGE_TYPE);\r\n        _sessionId.writeBytes(out);\r\n        _destination.writeBytes(out);\r\n        _payload.writeBytes(out);\r\n        DataHelper.writeLong(out, 4, _nonce);\r\n        _daf.writeBytes(out);\r\n    } catch (DataFormatException dfe) {\r\n        throw new I2CPMessageException(\"Error writing the msg\", dfe);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.TunnelCreatorConfig.getReceiveTunnelId",
	"Comment": "retrieve the tunnelid that the given hop receives messages on.the gateway is hop 0.",
	"Method": "TunnelId getReceiveTunnelId(int hop){\r\n    return _config[hop].getReceiveTunnel();\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.RRDatabase.toXml",
	"Comment": "outputs the content of the database to the given print stream\tas a stream of xml. the xml format is almost identical to that produced by\trrdtool dump",
	"Method": "void toXml(PrintStream s){\r\n    s.println(\"<!--\");\r\n    s.println(\"  -- Round Robin RRDatabase Dump \");\r\n    s.println(\"  -- Generated by jRRD <ciaran@codeloop.com>\");\r\n    s.println(\"  -->\");\r\n    s.println(\"<rrd>\");\r\n    s.print(\"\\t<version> \");\r\n    s.print(header.version);\r\n    s.println(\" <\/version>\");\r\n    s.print(\"\\t<step> \");\r\n    s.print(header.pdpStep);\r\n    s.println(\" <\/step> <!-- Seconds -->\");\r\n    s.print(\"\\t<lastupdate> \");\r\n    s.print(lastUpdate.getTime() / 1000);\r\n    s.print(\" <\/lastupdate> <!-- \");\r\n    s.print(lastUpdate.toString());\r\n    s.println(\" -->\");\r\n    s.println();\r\n    for (int i = 0; i < header.dsCount; i++) {\r\n        DataSource ds = dataSources.get(i);\r\n        ds.toXml(s);\r\n    }\r\n    s.println(\"<!-- Round Robin Archives -->\");\r\n    for (int i = 0; i < header.rraCount; i++) {\r\n        Archive archive = archives.get(i);\r\n        archive.toXml(s);\r\n    }\r\n    s.println(\"<\/rrd>\");\r\n}"
}, {
	"Path": "net.i2p.data.DataHelper.fromLongLE",
	"Comment": "little endian, i.e. backwards. not for use in i2p protocols.",
	"Method": "long fromLongLE(byte src,int offset,int numBytes){\r\n    if (numBytes <= 0 || numBytes > 8)\r\n        throw new IllegalArgumentException(\"Invalid number of bytes\");\r\n    long rv = 0;\r\n    for (int i = offset + numBytes - 1; i >= offset; i--) {\r\n        rv <<= 8;\r\n        rv |= src[i] & 0xFF;\r\n    }\r\n    if (rv < 0)\r\n        throw new IllegalArgumentException(\"fromLong got a negative? \" + rv + \": offset=\" + offset + \" numBytes=\" + numBytes);\r\n    return rv;\r\n}"
}, {
	"Path": "net.i2p.util.I2PSSLSocketFactory.selectProtocols",
	"Comment": "select protocols to be usedbased on configured inclusion and exclusion listsas well as enabled and supported protocols.adapted from jetty sslcontextfactory.java",
	"Method": "String[] selectProtocols(String[] enabledProtocols,String[] supportedProtocols){\r\n    return select(enabledProtocols, supportedProtocols, INCLUDE_PROTOCOLS, EXCLUDE_PROTOCOLS);\r\n}"
}, {
	"Path": "i2p.susi.util.Folder.setElements",
	"Comment": "set the array of objects the folder should manage.\tdoes not copy the array.\tsorts the array if a sorter set.",
	"Method": "void setElements(O[] elements){\r\n    if (elements.length > 0) {\r\n        this.elements = elements;\r\n        sort();\r\n    } else {\r\n        this.elements = null;\r\n    }\r\n    update();\r\n}"
}, {
	"Path": "net.nicoulaj.idea.markdown.lang.parser.MarkdownParserDefinition.spaceExistanceTypeBetweenTokens",
	"Comment": "check if the specified two token types need to be separated by a space according to the language grammar.",
	"Method": "SpaceRequirements spaceExistanceTypeBetweenTokens(ASTNode left,ASTNode right){\r\n    return SpaceRequirements.MAY;\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.I2PSocketManagerFull.listSockets",
	"Comment": "retrieve a set of currently connected i2psockets, either initiated locally or remotely.",
	"Method": "Set<I2PSocket> listSockets(){\r\n    Set<Connection> connections = _connectionManager.listConnections();\r\n    Set<I2PSocket> rv = new HashSet<I2PSocket>(connections.size());\r\n    for (Connection con : connections) {\r\n        if (con.getSocket() != null)\r\n            rv.add(con.getSocket());\r\n    }\r\n    return rv;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.InboundMessageState.toString",
	"Comment": "may not be valid if released, or may npe on race with release, use with care in exception text",
	"Method": "String toString(String toString){\r\n    StringBuilder buf = new StringBuilder(256);\r\n    buf.append(\"IB Message: \").append(_messageId);\r\n    buf.append(\" from \").append(_from.toString());\r\n    if (isComplete()) {\r\n        buf.append(\" completely received with \");\r\n        buf.append(_completeSize).append(\" bytes in \");\r\n        buf.append(_lastFragment + 1).append(\" fragments\");\r\n    } else {\r\n        for (int i = 0; i <= _lastFragment; i++) {\r\n            buf.append(\" fragment \").append(i);\r\n            if (_fragments[i] != null)\r\n                buf.append(\": known at size \").append(_fragments[i].getValid());\r\n            else\r\n                buf.append(\": unknown\");\r\n        }\r\n    }\r\n    buf.append(\" lifetime: \").append(getLifetime());\r\n    return buf.toString();\r\n}"
}, {
	"Path": "i2p.susi.webmail.pop3.POP3MailBox.checkConnection",
	"Comment": "if not connected, connect now.\tshould be called from all public methods before sending a command.\tcaller must sync.",
	"Method": "void checkConnection(){\r\n    if (_log.shouldDebug())\r\n        _log.debug(\"checkConnection()\");\r\n    if (!isConnected()) {\r\n        connect();\r\n        if (!isConnected())\r\n            throw new IOException(_t(\"Cannot connect\"));\r\n    }\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.settings.IgnoreSettings.setInformTrackedIgnored",
	"Comment": "sets notification about editing ignored file status to enabled or disabled.",
	"Method": "void setInformTrackedIgnored(boolean informTrackedIgnored){\r\n    this.notifyOnChange(KEY.INFORM_TRACKED_IGNORED, this.informTrackedIgnored, informTrackedIgnored);\r\n    this.informTrackedIgnored = informTrackedIgnored;\r\n}"
}, {
	"Path": "io.helidon.security.spi.SynchronousProvider.authorize",
	"Comment": "authorize a request based on configuration.authorization cannot be optional. if this method is called, it should always attempt to authorize the current request.this method will be invoked for inbound requests only.",
	"Method": "CompletionStage<AuthorizationResponse> authorize(ProviderRequest providerRequest){\r\n    return CompletableFuture.supplyAsync(() -> syncAuthorize(providerRequest), providerRequest.getContext().getExecutorService());\r\n}"
}, {
	"Path": "net.i2p.router.RouterContext.setProperty",
	"Comment": "modify the configuration attributes of this context, changingone of the properties provided during the context construction.",
	"Method": "void setProperty(String propName,String value){\r\n    _overrideProps.setProperty(propName, value);\r\n}"
}, {
	"Path": "net.i2p.util.InternalSocket.getLocalPort",
	"Comment": "supported as of 0.9.33, prior to that threw unsupportedoperationexception",
	"Method": "int getLocalPort(){\r\n    return isConnected() ? 1 : -1;\r\n}"
}, {
	"Path": "net.i2p.util.InternalSocket.shutdownInput",
	"Comment": "supported as of 0.9.33, prior to that threw unsupportedoperationexception",
	"Method": "void shutdownInput(){\r\n    if (_is != null) {\r\n        _is.close();\r\n        _is = null;\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.DataSource.getMaximum",
	"Comment": "returns the maximum value input to this data source can have.",
	"Method": "double getMaximum(){\r\n    return maximum;\r\n}"
}, {
	"Path": "org.xlattice.crypto.filters.BloomSHA1.member",
	"Comment": "is a key in the filter.external interface, internally synchronized.",
	"Method": "boolean member(byte[] b,boolean member,byte[] b,int offset,int len){\r\n    synchronized (this) {\r\n        return isMember(b, offset, len);\r\n    }\r\n}"
}, {
	"Path": "com.spotify.heroic.cluster.CoreClusterManager.getNodesForShard",
	"Comment": "eventually consistent view of the currently known nodes in a specific shard",
	"Method": "List<ClusterNode> getNodesForShard(Map<String, String> shard){\r\n    synchronized (this.updateRegistryLock) {\r\n        return registry.get().getNodesInShard(shard);\r\n    }\r\n}"
}, {
	"Path": "com.netflix.hollow.core.memory.ThreadSafeBitSet.orAll",
	"Comment": "return a new bit set which contains all bits which are contained inof the specified bit sets.",
	"Method": "ThreadSafeBitSet orAll(ThreadSafeBitSet bitSets){\r\n    if (bitSets.length == 0)\r\n        return new ThreadSafeBitSet();\r\n    int log2SegmentSize = bitSets[0].log2SegmentSize;\r\n    int numLongsPerSegment = bitSets[0].numLongsPerSegment;\r\n    ThreadSafeBitSetSegments[] segments = new ThreadSafeBitSetSegments[bitSets.length];\r\n    int maxNumSegments = 0;\r\n    for (int i = 0; i < bitSets.length; i++) {\r\n        if (bitSets[i].log2SegmentSize != log2SegmentSize)\r\n            throw new IllegalArgumentException(\"Segment sizes must be the same\");\r\n        segments[i] = bitSets[i].segments.get();\r\n        if (segments[i].numSegments() > maxNumSegments)\r\n            maxNumSegments = segments[i].numSegments();\r\n    }\r\n    ThreadSafeBitSetSegments newSegments = new ThreadSafeBitSetSegments(maxNumSegments, numLongsPerSegment);\r\n    AtomicLongArray[] segment = new AtomicLongArray[segments.length];\r\n    for (int i = 0; i < maxNumSegments; i++) {\r\n        for (int j = 0; j < segments.length; j++) {\r\n            segment[j] = i < segments[j].numSegments() ? segments[j].getSegment(i) : null;\r\n        }\r\n        AtomicLongArray newSegment = newSegments.getSegment(i);\r\n        for (int j = 0; j < numLongsPerSegment; j++) {\r\n            long value = 0;\r\n            for (int k = 0; k < segments.length; k++) {\r\n                if (segment[k] != null)\r\n                    value |= segment[k].get(j);\r\n            }\r\n            newSegment.set(j, value);\r\n        }\r\n    }\r\n    ThreadSafeBitSet or = new ThreadSafeBitSet(log2SegmentSize);\r\n    or.segments.set(newSegments);\r\n    return or;\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterAddress.getOptionsMap",
	"Comment": "retrieve the transport specific options necessary for communication",
	"Method": "Map<Object, Object> getOptionsMap(){\r\n    return Collections.unmodifiableMap(_options);\r\n}"
}, {
	"Path": "edu.internet2.ndt.Protocol.readn",
	"Comment": "populate message byte array with specific number of bytes of data from\tsocket input stream",
	"Method": "int readn(Message msgParam,int iParamAmount){\r\n    int read = 0;\r\n    int tmp;\r\n    msgParam.initBodySize(iParamAmount);\r\n    while (read != iParamAmount) {\r\n        tmp = _ctlInStream.read(msgParam._yaBody, read, iParamAmount - read);\r\n        if (tmp <= 0) {\r\n            return read;\r\n        }\r\n        read += tmp;\r\n    }\r\n    return read;\r\n}"
}, {
	"Path": "net.i2p.data.LeaseSet.isCurrent",
	"Comment": "determine whether any lease is currently valid, at least within a givenfudge factor",
	"Method": "boolean isCurrent(long fudge){\r\n    long now = Clock.getInstance().now();\r\n    return _lastExpiration > now - fudge;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerTestManager.testComplete",
	"Comment": "evaluate the info we have and act accordingly, since the test has either timed out orwe have successfully received the second peertest from a charlie.",
	"Method": "void testComplete(boolean forgetTest){\r\n    _currentTestComplete = true;\r\n    PeerTestState test = _currentTest;\r\n    boolean isIPv6 = test.isIPv6();\r\n    Status status;\r\n    if (test.getAlicePortFromCharlie() > 0) {\r\n        if ((test.getAlicePort() == test.getAlicePortFromCharlie()) && (test.getAliceIP() != null) && (test.getAliceIPFromCharlie() != null) && (test.getAliceIP().equals(test.getAliceIPFromCharlie()))) {\r\n            status = isIPv6 ? Status.IPV4_UNKNOWN_IPV6_OK : Status.IPV4_OK_IPV6_UNKNOWN;\r\n        } else {\r\n            status = isIPv6 ? Status.IPV4_UNKNOWN_IPV6_FIREWALLED : Status.IPV4_SNAT_IPV6_UNKNOWN;\r\n        }\r\n    } else if (test.getReceiveCharlieTime() > 0) {\r\n        status = Status.UNKNOWN;\r\n    } else if (test.getReceiveBobTime() > 0) {\r\n        status = isIPv6 ? Status.IPV4_UNKNOWN_IPV6_FIREWALLED : Status.IPV4_FIREWALLED_IPV6_UNKNOWN;\r\n    } else {\r\n        status = Status.UNKNOWN;\r\n    }\r\n    if (_log.shouldLog(Log.INFO))\r\n        _log.info(\"Test complete: \" + test);\r\n    honorStatus(status, isIPv6);\r\n    if (forgetTest)\r\n        _currentTest = null;\r\n}"
}, {
	"Path": "com.nettgryppa.security.HashCash.numberOfLeadingZeros",
	"Comment": "returns the number of leading zeros in a bytes binary represenation",
	"Method": "int numberOfLeadingZeros(byte[] values,int numberOfLeadingZeros,byte value){\r\n    if (value < 0)\r\n        return 0;\r\n    if (value < 1)\r\n        return 8;\r\n    else if (value < 2)\r\n        return 7;\r\n    else if (value < 4)\r\n        return 6;\r\n    else if (value < 8)\r\n        return 5;\r\n    else if (value < 16)\r\n        return 4;\r\n    else if (value < 32)\r\n        return 3;\r\n    else if (value < 64)\r\n        return 2;\r\n    else if (value < 128)\r\n        return 1;\r\n    else\r\n        return 0;\r\n}"
}, {
	"Path": "com.spotify.heroic.cluster.CoreClusterManager.getNodes",
	"Comment": "eventually consistent view of the currently known nodes in the cluster",
	"Method": "List<ClusterNode> getNodes(){\r\n    final NodeRegistry registry = this.registry.get();\r\n    if (registry == null) {\r\n        throw new IllegalStateException(\"Registry not ready\");\r\n    }\r\n    return registry.getEntries();\r\n}"
}, {
	"Path": "net.i2p.client.impl.SubSession.destroySession",
	"Comment": "tear down the session, and do not reconnect.blocks if session has not been fully started.",
	"Method": "void destroySession(){\r\n    _primary.destroySession();\r\n    if (_availabilityNotifier != null)\r\n        _availabilityNotifier.stopNotifying();\r\n    if (_sessionListener != null)\r\n        _sessionListener.disconnected(this);\r\n    changeState(State.CLOSED);\r\n}"
}, {
	"Path": "io.helidon.webserver.utils.TestUtils.matcher",
	"Comment": "test a result of a lambda call of a given object that is under a test.",
	"Method": "FeatureMatcher<T, R> matcher(Function<T, R> call,Matcher<? super R> subMatcher,FeatureMatcher<T, R> matcher,Supplier<R> call,Matcher<? super R> subMatcher){\r\n    return matcher(t -> call.get(), subMatcher);\r\n}"
}, {
	"Path": "com.netflix.hollow.api.consumer.HollowConsumer.triggerAsyncRefreshWithDelay",
	"Comment": "triggers async refresh after the specified number of milliseconds has passed.any subsequent calls for async refresh will not begin until after the specified delayhas completed.",
	"Method": "void triggerAsyncRefreshWithDelay(int delayMillis){\r\n    final long targetBeginTime = System.currentTimeMillis() + delayMillis;\r\n    refreshExecutor.execute(() -> {\r\n        try {\r\n            long delay = targetBeginTime - System.currentTimeMillis();\r\n            if (delay > 0)\r\n                Thread.sleep(delay);\r\n        } catch (InterruptedException e) {\r\n            LOG.log(Level.INFO, \"Async refresh interrupted before trigger, refresh cancelled\", e);\r\n            return;\r\n        }\r\n        try {\r\n            triggerRefresh();\r\n        } catch (Error | RuntimeException e) {\r\n            LOG.log(Level.SEVERE, \"Async refresh failed\", e);\r\n            throw e;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PacketBuilder.buildSessionCreatedPacket",
	"Comment": "build a new sessioncreated packet for the given peer, encrypting it as necessary.",
	"Method": "UDPPacket buildSessionCreatedPacket(InboundEstablishState state,int externalPort,SessionKey ourIntroKey){\r\n    UDPPacket packet = buildPacketHeader(SESSION_CREATED_FLAG_BYTE);\r\n    DatagramPacket pkt = packet.getPacket();\r\n    byte[] data = pkt.getData();\r\n    int off = HEADER_SIZE;\r\n    InetAddress to = null;\r\n    try {\r\n        to = InetAddress.getByAddress(state.getSentIP());\r\n    } catch (UnknownHostException uhe) {\r\n        if (_log.shouldLog(Log.ERROR))\r\n            _log.error(\"How did we think this was a valid IP?  \" + state.getRemoteHostId().toString());\r\n        packet.release();\r\n        return null;\r\n    }\r\n    state.prepareSessionCreated();\r\n    byte[] sentIP = state.getSentIP();\r\n    if ((sentIP == null) || (sentIP.length <= 0) || (!_transport.isValid(sentIP))) {\r\n        if (_log.shouldLog(Log.ERROR))\r\n            _log.error(\"How did our sent IP become invalid? \" + state);\r\n        state.fail();\r\n        packet.release();\r\n        return null;\r\n    }\r\n    System.arraycopy(state.getSentY(), 0, data, off, state.getSentY().length);\r\n    off += state.getSentY().length;\r\n    DataHelper.toLong(data, off, 1, sentIP.length);\r\n    off += 1;\r\n    System.arraycopy(sentIP, 0, data, off, sentIP.length);\r\n    off += sentIP.length;\r\n    DataHelper.toLong(data, off, 2, state.getSentPort());\r\n    off += 2;\r\n    DataHelper.toLong(data, off, 4, state.getSentRelayTag());\r\n    off += 4;\r\n    DataHelper.toLong(data, off, 4, state.getSentSignedOnTime());\r\n    off += 4;\r\n    Signature sig = state.getSentSignature();\r\n    int siglen = sig.length();\r\n    System.arraycopy(sig.getData(), 0, data, off, siglen);\r\n    off += siglen;\r\n    int rem = siglen % 16;\r\n    int padding;\r\n    if (rem > 0) {\r\n        padding = 16 - rem;\r\n        _context.random().nextBytes(data, off, padding);\r\n        off += padding;\r\n    } else {\r\n        padding = 0;\r\n    }\r\n    if (_log.shouldLog(Log.DEBUG)) {\r\n        StringBuilder buf = new StringBuilder(128);\r\n        buf.append(\"Sending sessionCreated:\");\r\n        buf.append(\" Alice: \").append(Addresses.toString(sentIP, state.getSentPort()));\r\n        buf.append(\" Bob: \").append(Addresses.toString(state.getReceivedOurIP(), externalPort));\r\n        buf.append(\" RelayTag: \").append(state.getSentRelayTag());\r\n        buf.append(\" SignedOn: \").append(state.getSentSignedOnTime());\r\n        buf.append(\" signature: \").append(Base64.encode(sig.getData()));\r\n        buf.append(\"\\nRawCreated: \").append(Base64.encode(data, 0, off));\r\n        buf.append(\"\\nsignedTime: \").append(Base64.encode(data, off - padding - siglen - 4, 4));\r\n        _log.debug(buf.toString());\r\n    }\r\n    byte[] iv = SimpleByteCache.acquire(UDPPacket.IV_SIZE);\r\n    _context.random().nextBytes(iv);\r\n    int encrWrite = siglen + padding;\r\n    int sigBegin = off - encrWrite;\r\n    _context.aes().encrypt(data, sigBegin, data, sigBegin, state.getCipherKey(), iv, encrWrite);\r\n    off = pad1(data, off);\r\n    off = pad2(data, off);\r\n    pkt.setLength(off);\r\n    authenticate(packet, ourIntroKey, ourIntroKey, iv);\r\n    setTo(packet, to, state.getSentPort());\r\n    SimpleByteCache.release(iv);\r\n    packet.setMessageType(TYPE_CREAT);\r\n    return packet;\r\n}"
}, {
	"Path": "net.i2p.router.OutNetMessage.getPriority",
	"Comment": "specify the priority of the message, where higher numbers are higherpriority.higher priority messages should be delivered before lowerpriority ones, though some algorithm may be used to avoid starvation.",
	"Method": "int getPriority(){\r\n    return _priority;\r\n}"
}, {
	"Path": "com.spotify.heroic.HeroicCore.loadingInjector",
	"Comment": "setup early injector, which is responsible for sufficiently providing dependencies to runtimecomponents.",
	"Method": "CoreLoadingComponent loadingInjector(){\r\n    log.info(\"Building Loading Injector\");\r\n    final ExecutorService executor;\r\n    final boolean managedExecutor;\r\n    if (this.executor.isPresent()) {\r\n        executor = this.executor.get();\r\n        managedExecutor = false;\r\n    } else {\r\n        executor = setupExecutor(Runtime.getRuntime().availableProcessors() * 2);\r\n        managedExecutor = true;\r\n    }\r\n    return DaggerCoreLoadingComponent.builder().loadingModule(new LoadingModule(executor, managedExecutor, this, params)).build();\r\n}"
}, {
	"Path": "org.jrobin.core.RrdFileBackend.setLength",
	"Comment": "sets length of the underlying rrd file. this method is called only once, immediately\tafter a new rrd file gets created.",
	"Method": "void setLength(long length){\r\n    file.setLength(length);\r\n}"
}, {
	"Path": "com.netflix.hollow.tools.query.HollowFieldMatchQuery.findMatchingRecords",
	"Comment": "match any records of the specified type, which have the specified field set to the specified value.",
	"Method": "Map<String, BitSet> findMatchingRecords(String fieldName,String fieldValue,Map<String, BitSet> findMatchingRecords,String typeName,String fieldName,String fieldValue){\r\n    Map<String, BitSet> matches = new HashMap<String, BitSet>();\r\n    HollowTypeReadState typeState = readEngine.getTypeState(typeName);\r\n    if (typeState != null)\r\n        augmentMatchingRecords(typeState, fieldName, fieldValue, matches);\r\n    return matches;\r\n}"
}, {
	"Path": "org.mitre.dsmiley.httpproxy.ProxyServlet.copyRequestHeader",
	"Comment": "copy a request header from the servlet client to the proxy request.this is easily overridden to filter out certain headers if desired.",
	"Method": "void copyRequestHeader(HttpServletRequest servletRequest,HttpRequest proxyRequest,String headerName){\r\n    if (headerName.equalsIgnoreCase(HttpHeaders.CONTENT_LENGTH))\r\n        return;\r\n    if (hopByHopHeaders.containsHeader(headerName))\r\n        return;\r\n    @SuppressWarnings(\"unchecked\")\r\n    Enumeration<String> headers = servletRequest.getHeaders(headerName);\r\n    while (headers.hasMoreElements()) {\r\n        String headerValue = headers.nextElement();\r\n        if (!doPreserveHost && headerName.equalsIgnoreCase(HttpHeaders.HOST)) {\r\n            HttpHost host = getTargetHost(servletRequest);\r\n            headerValue = host.getHostName();\r\n            if (host.getPort() != -1)\r\n                headerValue += \":\" + host.getPort();\r\n        } else if (!doPreserveCookies && headerName.equalsIgnoreCase(org.apache.http.cookie.SM.COOKIE)) {\r\n            headerValue = getRealCookie(headerValue);\r\n        }\r\n        proxyRequest.addHeader(headerName, headerValue);\r\n    }\r\n}"
}, {
	"Path": "org.klomp.snark.bencode.BEValue.getNumber",
	"Comment": "returns this bevalue as a number. this operation only succeedswhen the bevalue is actually a number, otherwise it will throw ainvalidbencodingexception.",
	"Method": "Number getNumber(){\r\n    try {\r\n        return (Number) value;\r\n    } catch (ClassCastException cce) {\r\n        throw new InvalidBEncodingException(cce.toString());\r\n    }\r\n}"
}, {
	"Path": "net.i2p.data.i2np.I2NPMessageImpl.toByteArray",
	"Comment": "write the message to the buffer, returning the number of bytes written.the data is formatted so as to be self contained, with the type, size,expiration, unique id, as well as a checksum bundled along.full 16 byte header for ntcp 1.",
	"Method": "byte[] toByteArray(int toByteArray,byte buffer,int toByteArray,byte buffer,int off){\r\n    int start = off;\r\n    try {\r\n        int rv = writeMessageBody(buffer, off + HEADER_LENGTH);\r\n        int payloadLen = rv - (off + HEADER_LENGTH);\r\n        byte[] h = SimpleByteCache.acquire(Hash.HASH_LENGTH);\r\n        _context.sha().calculateHash(buffer, off + HEADER_LENGTH, payloadLen, h, 0);\r\n        buffer[off++] = (byte) getType();\r\n        if (_uniqueId < 0) {\r\n            _uniqueId = _context.random().nextLong(MAX_ID_VALUE);\r\n        }\r\n        DataHelper.toLong(buffer, off, 4, _uniqueId);\r\n        off += 4;\r\n        DataHelper.toLong(buffer, off, DataHelper.DATE_LENGTH, _expiration);\r\n        off += DataHelper.DATE_LENGTH;\r\n        DataHelper.toLong(buffer, off, 2, payloadLen);\r\n        off += 2;\r\n        System.arraycopy(h, 0, buffer, off, CHECKSUM_LENGTH);\r\n        SimpleByteCache.release(h);\r\n        return rv;\r\n    } catch (I2NPMessageException ime) {\r\n        _context.logManager().getLog(getClass()).log(Log.CRIT, \"Error writing\", ime);\r\n        throw new IllegalStateException(\"Unable to serialize the message \" + getClass().getSimpleName(), ime);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerTestManager.receiveTest",
	"Comment": "entry point for all incoming packets. most of the source and dest validation is here.receive a test message of some sort from the given peer, queueing up any packetthat should be sent in response, or if its a reply to our own current testing,adjusting our test state.we could be alice, bob, or charlie.",
	"Method": "void receiveTest(RemoteHostId from,UDPPacketReader reader){\r\n    _context.statManager().addRateData(\"udp.receiveTest\", 1);\r\n    byte[] fromIP = from.getIP();\r\n    int fromPort = from.getPort();\r\n    if (!TransportUtil.isValidPort(fromPort) || (!_transport.isValid(fromIP)) || _transport.isTooClose(fromIP) || _context.blocklist().isBlocklisted(fromIP)) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Invalid PeerTest address: \" + Addresses.toString(fromIP, fromPort));\r\n        _context.statManager().addRateData(\"udp.testBadIP\", 1);\r\n        return;\r\n    }\r\n    UDPPacketReader.PeerTestReader testInfo = reader.getPeerTestReader();\r\n    byte[] testIP = null;\r\n    int testPort = testInfo.readPort();\r\n    if (testInfo.readIPSize() > 0) {\r\n        testIP = new byte[testInfo.readIPSize()];\r\n        testInfo.readIP(testIP, 0);\r\n    }\r\n    if ((testPort > 0 && (!TransportUtil.isValidPort(testPort))) || (testIP != null && ((!_transport.isValid(testIP)) || (testIP.length != 4 && testIP.length != 16) || _context.blocklist().isBlocklisted(testIP)))) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Invalid address in PeerTest: \" + Addresses.toString(testIP, testPort));\r\n        _context.statManager().addRateData(\"udp.testBadIP\", 1);\r\n        return;\r\n    }\r\n    long nonce = testInfo.readNonce();\r\n    PeerTestState test = _currentTest;\r\n    if ((test != null) && (test.getNonce() == nonce)) {\r\n        receiveTestReply(from, testInfo);\r\n        return;\r\n    }\r\n    if (_throttle.shouldThrottle(fromIP)) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"PeerTest throttle from \" + Addresses.toString(fromIP, fromPort));\r\n        return;\r\n    }\r\n    if (testIP != null && _throttle.shouldThrottle(testIP)) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"PeerTest throttle to \" + Addresses.toString(testIP, testPort));\r\n        return;\r\n    }\r\n    Long lNonce = Long.valueOf(nonce);\r\n    PeerTestState state = _activeTests.get(lNonce);\r\n    if (testIP != null && _transport.isTooClose(testIP)) {\r\n        if (_recentTests.contains(lNonce)) {\r\n            if (_log.shouldLog(Log.INFO))\r\n                _log.info(\"Got delayed reply on nonce \" + nonce + \" from: \" + Addresses.toString(fromIP, fromPort));\r\n        } else {\r\n            if (_log.shouldLog(Log.WARN))\r\n                _log.warn(\"Nearby address in PeerTest: \" + Addresses.toString(testIP, testPort) + \" from: \" + Addresses.toString(fromIP, fromPort) + \" state? \" + state);\r\n            _context.statManager().addRateData(\"udp.testBadIP\", 1);\r\n        }\r\n        return;\r\n    }\r\n    if (state == null) {\r\n        if ((testIP == null) || (testPort <= 0)) {\r\n            if (_activeTests.size() >= MAX_ACTIVE_TESTS) {\r\n                if (_log.shouldLog(Log.WARN))\r\n                    _log.warn(\"Too many active tests, droppping from Alice \" + Addresses.toString(fromIP, fromPort));\r\n                return;\r\n            }\r\n            if (_transport.getPeerState(from) == null) {\r\n                if (_log.shouldLog(Log.WARN))\r\n                    _log.warn(\"No session, dropping new test from Alice \" + Addresses.toString(fromIP, fromPort));\r\n                return;\r\n            }\r\n            if (_log.shouldLog(Log.DEBUG))\r\n                _log.debug(\"test IP/port are blank coming from \" + from + \", assuming we are Bob and they are alice\");\r\n            receiveFromAliceAsBob(from, testInfo, nonce, null);\r\n        } else {\r\n            if (_recentTests.contains(lNonce)) {\r\n            } else {\r\n                if (_activeTests.size() >= MAX_ACTIVE_TESTS) {\r\n                    if (_log.shouldLog(Log.WARN))\r\n                        _log.warn(\"Too many active tests, droppping from Bob \" + Addresses.toString(fromIP, fromPort));\r\n                    return;\r\n                }\r\n                if (_log.shouldLog(Log.DEBUG))\r\n                    _log.debug(\"We are charlie, as the testIP/port is \" + Addresses.toString(testIP, testPort) + \" and the state is unknown for \" + nonce);\r\n                receiveFromBobAsCharlie(from, testInfo, nonce, null);\r\n            }\r\n        }\r\n    } else {\r\n        if (state.getOurRole() == BOB) {\r\n            if (DataHelper.eq(fromIP, state.getAliceIP().getAddress()) && (fromPort == state.getAlicePort())) {\r\n                receiveFromAliceAsBob(from, testInfo, nonce, state);\r\n            } else if (DataHelper.eq(fromIP, state.getCharlieIP().getAddress()) && (fromPort == state.getCharliePort())) {\r\n                receiveFromCharlieAsBob(from, state);\r\n            } else {\r\n                if (_log.shouldLog(Log.WARN))\r\n                    _log.warn(\"Received from a fourth party as bob!  alice: \" + state.getAliceIP() + \", charlie: \" + state.getCharlieIP() + \", dave: \" + from);\r\n            }\r\n        } else if (state.getOurRole() == CHARLIE) {\r\n            if ((testIP == null) || (testPort <= 0)) {\r\n                receiveFromAliceAsCharlie(from, testInfo, nonce, state);\r\n            } else {\r\n                receiveFromBobAsCharlie(from, testInfo, nonce, state);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.klomp.snark.web.BasicServlet.getResource",
	"Comment": "get resource to serve.map a path to a resource. the default implementation callshttpcontext.getresource but derived servlets may providetheir own mapping.",
	"Method": "File getResource(String pathInContext){\r\n    File r = null;\r\n    if (!pathInContext.contains(\"..\") && !pathInContext.endsWith(\"/\")) {\r\n        File f;\r\n        synchronized (this) {\r\n            if (_resourceBase == null)\r\n                return null;\r\n            f = new File(_resourceBase, pathInContext);\r\n        }\r\n        if (f.exists())\r\n            r = f;\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "net.i2p.crypto.SigUtil.toJavaRSAKey",
	"Comment": "as of 0.9.31, if pk is a rsasigningprivatecrtkey, this will return a rsaprivatecrtkey.",
	"Method": "RSAPublicKey toJavaRSAKey(SigningPublicKey pk,RSAPrivateKey toJavaRSAKey,SigningPrivateKey pk){\r\n    if (pk instanceof RSASigningPrivateCrtKey)\r\n        return ((RSASigningPrivateCrtKey) pk).toJavaKey();\r\n    KeyFactory kf = KeyFactory.getInstance(\"RSA\");\r\n    BigInteger[] nd = split(pk.getData());\r\n    KeySpec ks = new RSAPrivateKeySpec(nd[0], nd[1]);\r\n    return (RSAPrivateKey) kf.generatePrivate(ks);\r\n}"
}, {
	"Path": "net.i2p.data.EncryptedLeaseSet.hashCode",
	"Comment": "the destination has enough randomness in it to use it by itself for speed",
	"Method": "int hashCode(){\r\n    if (_encryptionKey == null)\r\n        return 0;\r\n    return _encryptionKey.hashCode();\r\n}"
}, {
	"Path": "com.netflix.hollow.core.read.engine.SnapshotPopulatedOrdinalsReader.readOrdinals",
	"Comment": "read populated ordinals as a bit set from a stream, and notify a listener for each populated ordinal.",
	"Method": "void readOrdinals(DataInputStream dis,HollowTypeStateListener[] listeners){\r\n    int numLongs = dis.readInt();\r\n    int currentOrdinal = 0;\r\n    for (int i = 0; i < numLongs; i++) {\r\n        long l = dis.readLong();\r\n        notifyPopulatedOrdinals(l, currentOrdinal, listeners);\r\n        currentOrdinal += 64;\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.Blocklist.parse",
	"Comment": "parse one line, returning a temp data structure with the result",
	"Method": "Entry parse(String buf,boolean shouldLog){\r\n    byte[] ip1;\r\n    byte[] ip2;\r\n    int start1 = 0;\r\n    int end1 = buf.length();\r\n    if (end1 <= 0)\r\n        return null;\r\n    int start2 = -1;\r\n    int mask = -1;\r\n    String comment = null;\r\n    int index = buf.indexOf('#');\r\n    if (index == 0)\r\n        return null;\r\n    index = buf.lastIndexOf(':');\r\n    if (index >= 0) {\r\n        comment = buf.substring(0, index);\r\n        start1 = index + 1;\r\n    }\r\n    if (end1 - start1 == 44 && buf.substring(start1).indexOf('.') < 0) {\r\n        byte[] b = Base64.decode(buf.substring(start1));\r\n        if (b != null)\r\n            return new Entry(comment, Hash.create(b), null, null);\r\n    }\r\n    index = buf.indexOf('-', start1);\r\n    if (index >= 0) {\r\n        end1 = index;\r\n        start2 = index + 1;\r\n    } else {\r\n        index = buf.indexOf('/', start1);\r\n        if (index >= 0) {\r\n            end1 = index;\r\n            mask = index + 1;\r\n        }\r\n    }\r\n    if (end1 - start1 <= 0)\r\n        return null;\r\n    try {\r\n        String sip = buf.substring(start1, end1);\r\n        sip = sip.replace(';', ':');\r\n        InetAddress pi = InetAddress.getByName(sip);\r\n        if (pi == null)\r\n            return null;\r\n        ip1 = pi.getAddress();\r\n        if (start2 >= 0) {\r\n            pi = InetAddress.getByName(buf.substring(start2));\r\n            if (pi == null)\r\n                return null;\r\n            ip2 = pi.getAddress();\r\n            if (ip2.length != 4)\r\n                throw new UnknownHostException();\r\n            if ((ip1[0] & 0xff) < 0x80 && (ip2[0] & 0xff) >= 0x80) {\r\n                if (_wrapSave == null) {\r\n                    _wrapSave = new Entry(comment, null, new byte[] { (byte) 0x80, 0, 0, 0 }, new byte[] { ip2[0], ip2[1], ip2[2], ip2[3] });\r\n                    ip2 = new byte[] { 127, (byte) 0xff, (byte) 0xff, (byte) 0xff };\r\n                } else\r\n                    throw new NumberFormatException();\r\n            }\r\n            for (int i = 0; i < 4; i++) {\r\n                if ((ip2[i] & 0xff) > (ip1[i] & 0xff))\r\n                    break;\r\n                if ((ip2[i] & 0xff) < (ip1[i] & 0xff))\r\n                    throw new NumberFormatException();\r\n            }\r\n        } else if (mask >= 0) {\r\n            int m = Integer.parseInt(buf.substring(mask));\r\n            if (m < 3 || m > 32)\r\n                throw new NumberFormatException();\r\n            ip2 = new byte[4];\r\n            for (int i = 0; i < 4; i++) ip2[i] = ip1[i];\r\n            for (int i = 0; i < 32 - m; i++) ip2[(31 - i) / 8] |= (0x01 << (i % 8));\r\n        } else {\r\n            ip2 = ip1;\r\n        }\r\n    } catch (UnknownHostException uhe) {\r\n        if (shouldLog)\r\n            _log.logAlways(Log.WARN, \"Format error in the blocklist file: \" + buf);\r\n        return null;\r\n    } catch (NumberFormatException nfe) {\r\n        if (shouldLog)\r\n            _log.logAlways(Log.WARN, \"Format error in the blocklist file: \" + buf);\r\n        return null;\r\n    } catch (IndexOutOfBoundsException ioobe) {\r\n        if (shouldLog)\r\n            _log.logAlways(Log.WARN, \"Format error in the blocklist file: \" + buf);\r\n        return null;\r\n    }\r\n    return new Entry(comment, null, ip1, ip2);\r\n}"
}, {
	"Path": "net.i2p.router.transport.TransportManager.getPorts",
	"Comment": "include the published port, or the requested port, for each transportwhich we will pass along to upnp",
	"Method": "Set<Port> getPorts(){\r\n    Set<Port> rv = new HashSet<Port>(4);\r\n    for (Transport t : _transports.values()) {\r\n        int port = t.getRequestedPort();\r\n        if (t.getStyle().equals(NTCPTransport.STYLE) && port <= 0 && _context.getBooleanProperty(NTCPTransport.PROP_I2NP_NTCP_AUTO_PORT)) {\r\n            Transport udp = getTransport(UDPTransport.STYLE);\r\n            if (udp != null)\r\n                port = t.getRequestedPort();\r\n        }\r\n        if (port > 0)\r\n            rv.add(new Port(t.getStyle(), port));\r\n    }\r\n    return rv;\r\n}"
}, {
	"Path": "net.i2p.sam.SAMBridge.storeKeys",
	"Comment": "store the current keys to disk in the location specified on creation.",
	"Method": "void storeKeys(){\r\n    synchronized (nameToPrivKeys) {\r\n        File file = new File(persistFilename);\r\n        if (!file.exists() && !file.isAbsolute())\r\n            file = new File(I2PAppContext.getGlobalContext().getConfigDir(), persistFilename);\r\n        try {\r\n            Properties props = new OrderedProperties();\r\n            props.putAll(nameToPrivKeys);\r\n            DataHelper.storeProps(props, file);\r\n            if (_log.shouldInfo())\r\n                _log.info(\"Saved \" + nameToPrivKeys.size() + \" private keys to \" + file);\r\n        } catch (IOException ioe) {\r\n            _log.error(\"Error writing out the SAM keys to \" + file, ioe);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.PeerTestJob.selectPeersToTest",
	"Comment": "retrieve a group of 0 or more peers that we want to test. returned list will not include ourselves.",
	"Method": "Set<RouterInfo> selectPeersToTest(){\r\n    PeerSelectionCriteria criteria = new PeerSelectionCriteria();\r\n    criteria.setMinimumRequired(getTestConcurrency());\r\n    criteria.setMaximumRequired(getTestConcurrency());\r\n    criteria.setPurpose(PeerSelectionCriteria.PURPOSE_TEST);\r\n    List<Hash> peerHashes = _manager.selectPeers(criteria);\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Peer selection found \" + peerHashes.size() + \" peers\");\r\n    Set<RouterInfo> peers = new HashSet<RouterInfo>(peerHashes.size());\r\n    for (Hash peer : peerHashes) {\r\n        RouterInfo peerInfo = getContext().netDb().lookupRouterInfoLocally(peer);\r\n        if (peerInfo != null) {\r\n            peers.add(peerInfo);\r\n        } else {\r\n            if (_log.shouldLog(Log.WARN))\r\n                _log.warn(\"Test peer \" + peer.toBase64() + \" had no local routerInfo?\");\r\n        }\r\n    }\r\n    return peers;\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.RRDatabase.getDataSource",
	"Comment": "returns the datasource at the specified position in this database.",
	"Method": "DataSource getDataSource(int index){\r\n    return dataSources.get(index);\r\n}"
}, {
	"Path": "org.jrobin.data.DataProcessor.getSourceNames",
	"Comment": "returns array of datasource names defined in this dataprocessor.",
	"Method": "String[] getSourceNames(){\r\n    return sources.keySet().toArray(new String[0]);\r\n}"
}, {
	"Path": "io.helidon.webserver.prometheus.PrometheusSupport.compose",
	"Comment": "compose the text version 0.0.4 of the given metricfamilysamples.",
	"Method": "String compose(Enumeration<Collector.MetricFamilySamples> mfs){\r\n    StringBuilder result = new StringBuilder();\r\n    while (mfs.hasMoreElements()) {\r\n        Collector.MetricFamilySamples metricFamilySamples = mfs.nextElement();\r\n        result.append(\"# HELP \").append(metricFamilySamples.name).append(' ');\r\n        appendEscapedHelp(result, metricFamilySamples.help);\r\n        result.append('\\n');\r\n        result.append(\"# TYPE \").append(metricFamilySamples.name).append(' ').append(typeString(metricFamilySamples.type)).append('\\n');\r\n        for (Collector.MetricFamilySamples.Sample sample : metricFamilySamples.samples) {\r\n            result.append(sample.name);\r\n            if (sample.labelNames.size() > 0) {\r\n                result.append('{');\r\n                for (int i = 0; i < sample.labelNames.size(); ++i) {\r\n                    result.append(sample.labelNames.get(i)).append(\"=\\\"\");\r\n                    appendEscapedLabelValue(result, sample.labelValues.get(i));\r\n                    result.append(\"\\\",\");\r\n                }\r\n                result.append('}');\r\n            }\r\n            result.append(' ').append(Collector.doubleToGoString(sample.value)).append('\\n');\r\n        }\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.KademliaNetworkDatabaseFacade.store",
	"Comment": "store the routerinfo.if the store fails due to unsupported crypto, it will banlistthe router hash until restart and then throw unsupportedcrytpoexception.",
	"Method": "LeaseSet store(Hash key,LeaseSet leaseSet,RouterInfo store,Hash key,RouterInfo routerInfo,RouterInfo store,Hash key,RouterInfo routerInfo,boolean persist){\r\n    if (!_initialized)\r\n        return null;\r\n    RouterInfo rv = null;\r\n    try {\r\n        rv = (RouterInfo) _ds.get(key, persist);\r\n        if ((rv != null) && (rv.equals(routerInfo))) {\r\n            return rv;\r\n        }\r\n    } catch (ClassCastException cce) {\r\n        throw new IllegalArgumentException(\"Attempt to replace LS with \" + routerInfo);\r\n    }\r\n    if (rv != null && !routerInfo.getIdentity().equals(rv.getIdentity()))\r\n        throw new IllegalArgumentException(\"RI Hash collision\");\r\n    String err = validate(key, routerInfo);\r\n    if (err != null)\r\n        throw new IllegalArgumentException(\"Invalid store attempt - \" + err);\r\n    _context.peerManager().setCapabilities(key, routerInfo.getCapabilities());\r\n    _ds.put(key, routerInfo, persist);\r\n    if (rv == null)\r\n        _kb.add(key);\r\n    return rv;\r\n}"
}, {
	"Path": "net.i2p.router.transport.UPnPManager.start",
	"Comment": "blocking, may take a while. may be called even if already running.",
	"Method": "void start(){\r\n    _shouldBeRunning = true;\r\n    if (!_isRunning && Addresses.isConnected()) {\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"UPnP Start\");\r\n        long b = _context.clock().now();\r\n        try {\r\n            _upnp.setHTTPPort(_context.getProperty(PROP_HTTP_PORT, DEFAULT_HTTP_PORT));\r\n            _upnp.setSSDPPort(_context.getProperty(PROP_SSDP_PORT, DEFAULT_SSDP_PORT));\r\n            _isRunning = _upnp.runPlugin();\r\n            if (_log.shouldDebug())\r\n                _log.info(\"UPnP runPlugin took \" + (_context.clock().now() - b));\r\n        } catch (RuntimeException e) {\r\n            if (!_errorLogged) {\r\n                _log.error(\"UPnP error, please report\", e);\r\n                _errorLogged = true;\r\n            }\r\n        }\r\n    }\r\n    if (_isRunning) {\r\n        _rescanner.schedule(RESCAN_LONG_DELAY);\r\n    } else {\r\n        _rescanner.schedule(RESCAN_SHORT_DELAY);\r\n        if (!Addresses.isConnected()) {\r\n            if (!_disconLogged) {\r\n                _log.logAlways(Log.WARN, \"UPnP start failed - no network connection?\");\r\n                _disconLogged = true;\r\n            }\r\n        } else {\r\n            _log.error(\"UPnP start failed - port conflict?\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.util.SimpleByteCache.acquire",
	"Comment": "get the next available array, either from the cache or a brand new one",
	"Method": "byte[] acquire(int size,byte[] acquire){\r\n    return _available.acquire();\r\n}"
}, {
	"Path": "i2p.susi.webmail.pop3.POP3MailBox.connect",
	"Comment": "closes any existing connection first.\tthen, connect to pop3 server, login with user and pass and try stat then\tcaller must sync.",
	"Method": "void connect(){\r\n    if (_log.shouldDebug())\r\n        _log.debug(\"connect()\", new Exception(\"I did it\"));\r\n    clear();\r\n    if (socket != null && socket.isConnected())\r\n        close();\r\n    try {\r\n        socket = InternalSocket.getSocket(host, port);\r\n    } catch (IOException e) {\r\n        if (_log.shouldDebug())\r\n            _log.debug(\"Error connecting\", e);\r\n        lastError = _t(\"Cannot connect\") + \" (\" + host + ':' + port + \") - \" + e.getLocalizedMessage();\r\n        return;\r\n    }\r\n    if (socket != null) {\r\n        try {\r\n            lastError = \"\";\r\n            socket.setSoTimeout(120 * 1000);\r\n            boolean ok = doHandshake();\r\n            boolean loginOK = false;\r\n            if (ok) {\r\n                List<SendRecv> cmds = new ArrayList<SendRecv>(4);\r\n                cmds.add(new SendRecv(\"USER \" + user, Mode.A1));\r\n                cmds.add(new SendRecv(\"PASS \" + pass, Mode.A1));\r\n                socket.setSoTimeout(60 * 1000);\r\n                loginOK = sendCmds(cmds);\r\n            }\r\n            if (loginOK) {\r\n                connected = true;\r\n                ok = doCheckMail();\r\n                if (ok && backgroundChecker == null && Boolean.parseBoolean(Config.getProperty(WebMail.CONFIG_BACKGROUND_CHECK)))\r\n                    backgroundChecker = new BackgroundChecker(this);\r\n                if (ok && idleCloser == null)\r\n                    idleCloser = new IdleCloser(this);\r\n            } else {\r\n                if (lastError.equals(\"\"))\r\n                    lastError = _t(\"Error connecting to server\");\r\n                if (ok && !loginOK) {\r\n                    lastError += '\\n' + _t(\"Mail server login failed, wrong username or password.\") + '\\n' + _t(\"Logout and then login again with the correct username and password.\");\r\n                }\r\n                close();\r\n            }\r\n        } catch (SocketTimeoutException e1) {\r\n            lastError = _t(\"Cannot connect\") + \": \" + _t(\"No response from server\");\r\n            if (socket != null) {\r\n                try {\r\n                    socket.close();\r\n                } catch (IOException e) {\r\n                }\r\n                socket = null;\r\n                connected = false;\r\n            }\r\n            if (_log.shouldDebug())\r\n                _log.debug(\"Error connecting\", e1);\r\n        } catch (IOException e1) {\r\n            lastError = _t(\"Cannot connect\") + \": \" + e1.getLocalizedMessage();\r\n            if (socket != null) {\r\n                try {\r\n                    socket.close();\r\n                } catch (IOException e) {\r\n                }\r\n                socket = null;\r\n                connected = false;\r\n            }\r\n            if (_log.shouldDebug())\r\n                _log.debug(\"Error connecting\", e1);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.util.ResettableGZIPOutputStream.reset",
	"Comment": "reinitialze everything so we can write a brand new gzip output streamagain.",
	"Method": "void reset(){\r\n    if (DEBUG)\r\n        System.out.println(\"Resetting (writtenSize=\" + _writtenSize + \")\");\r\n    def.reset();\r\n    _crc32.reset();\r\n    _writtenSize = 0;\r\n    _headerWritten = false;\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.HandleFloodfillDatabaseLookupMessageJob.sendClosest",
	"Comment": "we extend this here to send our routerinfo back as well, if we are not floodfill.this gets the word out to routers that we are no longer floodfill, so theywill stop bugging us.",
	"Method": "void sendClosest(Hash key,Set<Hash> routerInfoSet,Hash toPeer,TunnelId replyTunnel){\r\n    super.sendClosest(key, routerInfoSet, toPeer, replyTunnel);\r\n    if (!getContext().netDb().floodfillEnabled()) {\r\n        DatabaseStoreMessage msg = new DatabaseStoreMessage(getContext());\r\n        RouterInfo me = getContext().router().getRouterInfo();\r\n        msg.setEntry(me);\r\n        sendMessage(msg, toPeer, replyTunnel);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.Router.gracefulShutdownInProgress",
	"Comment": "is a graceful shutdown in progress? this may be cancelled.note that this also returns true if an uncancellable final shutdown is in progress.",
	"Method": "boolean gracefulShutdownInProgress(){\r\n    synchronized (_stateLock) {\r\n        return STATES_GRACEFUL.contains(_state);\r\n    }\r\n}"
}, {
	"Path": "com.spotify.heroic.HeroicCore.setupExecutor",
	"Comment": "setup a fixed thread pool executor that correctly handles unhandled exceptions.",
	"Method": "ExecutorService setupExecutor(int threads){\r\n    return new ThreadPoolExecutor(threads, threads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(), new ThreadFactoryBuilder().setNameFormat(\"heroic-core-%d\").setUncaughtExceptionHandler(uncaughtExceptionHandler).build()) {\r\n        @Override\r\n        protected void afterExecute(Runnable r, Throwable t) {\r\n            super.afterExecute(r, t);\r\n            if (t == null && (r instanceof Future<?>)) {\r\n                try {\r\n                    ((Future<?>) r).get();\r\n                } catch (CancellationException e) {\r\n                    t = e;\r\n                } catch (ExecutionException e) {\r\n                    t = e.getCause();\r\n                } catch (InterruptedException e) {\r\n                    Thread.currentThread().interrupt();\r\n                }\r\n            }\r\n            if (t != null) {\r\n                if (log.isErrorEnabled()) {\r\n                    log.error(\"Unhandled exception caught in core executor\", t);\r\n                    log.error(\"Exiting (code=2)\");\r\n                } else {\r\n                    System.err.println(\"Unhandled exception caught in core executor\");\r\n                    System.err.println(\"Exiting (code=2)\");\r\n                    t.printStackTrace(System.err);\r\n                }\r\n                System.exit(2);\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.spotify.heroic.HeroicCore.setupExecutor",
	"Comment": "setup a fixed thread pool executor that correctly handles unhandled exceptions.",
	"Method": "ExecutorService setupExecutor(int threads){\r\n    super.afterExecute(r, t);\r\n    if (t == null && (r instanceof Future<?>)) {\r\n        try {\r\n            ((Future<?>) r).get();\r\n        } catch (CancellationException e) {\r\n            t = e;\r\n        } catch (ExecutionException e) {\r\n            t = e.getCause();\r\n        } catch (InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n        }\r\n    }\r\n    if (t != null) {\r\n        if (log.isErrorEnabled()) {\r\n            log.error(\"Unhandled exception caught in core executor\", t);\r\n            log.error(\"Exiting (code=2)\");\r\n        } else {\r\n            System.err.println(\"Unhandled exception caught in core executor\");\r\n            System.err.println(\"Exiting (code=2)\");\r\n            t.printStackTrace(System.err);\r\n        }\r\n        System.exit(2);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.crypto.eddsa.math.MathUtils.doubleGroupElement",
	"Comment": "doubles a group element and returns the result in p3 representation.it uses biginteger arithmetic and the affine representation.this method is a helper used to test the projective group doubling formula in groupelement.",
	"Method": "GroupElement doubleGroupElement(GroupElement g){\r\n    return addGroupElements(g, g);\r\n}"
}, {
	"Path": "net.i2p.router.client.ClientMessageEventListener.handleReceiveBegin",
	"Comment": "the client asked for a message, so we send it to them.this is only when not in fast receive mode.in the default fast receive mode, data is sent in messagereceivedjob.",
	"Method": "void handleReceiveBegin(ReceiveMessageBeginMessage message){\r\n    if (_runner.isDead())\r\n        return;\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Handling receive begin: id = \" + message.getMessageId());\r\n    MessagePayloadMessage msg = new MessagePayloadMessage();\r\n    msg.setMessageId(message.getMessageId());\r\n    msg.setSessionId(message.getSessionId());\r\n    Payload payload = _runner.getPayload(new MessageId(message.getMessageId()));\r\n    if (payload == null) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Payload for message id [\" + message.getMessageId() + \"] is null!  Dropped or Unknown message id\");\r\n        return;\r\n    }\r\n    msg.setPayload(payload);\r\n    try {\r\n        _runner.doSend(msg);\r\n    } catch (I2CPMessageException ime) {\r\n        String emsg = \"Error sending data to client \" + _runner.getDestHash();\r\n        if (_log.shouldWarn())\r\n            _log.warn(emsg, ime);\r\n        else\r\n            _log.logAlways(Log.WARN, emsg);\r\n        _runner.removePayload(new MessageId(message.getMessageId()));\r\n    }\r\n}"
}, {
	"Path": "net.i2p.crypto.CryptixAESKeyCache.acquireKey",
	"Comment": "get the next available structure, either from the cache or a brand new one",
	"Method": "KeyCacheEntry acquireKey(){\r\n    KeyCacheEntry rv = _availableKeys.poll();\r\n    if (rv != null)\r\n        return rv;\r\n    return createNew();\r\n}"
}, {
	"Path": "net.i2p.crypto.SigUtil.fromJavaKey",
	"Comment": "as of 0.9.31, if pk is a rsaprivatecrtkey, this will return a rsasigningprivatecrtkey.",
	"Method": "SigningPublicKey fromJavaKey(PublicKey pk,SigningPublicKey fromJavaKey,PublicKey pk,SigType type,SigningPrivateKey fromJavaKey,PrivateKey pk,SigningPrivateKey fromJavaKey,PrivateKey pk,SigType type,SigningPublicKey fromJavaKey,ECPublicKey pk,SigType type,SigningPrivateKey fromJavaKey,ECPrivateKey pk,SigType type,SigningPublicKey fromJavaKey,EdDSAPublicKey pk,SigType type,SigningPrivateKey fromJavaKey,EdDSAPrivateKey pk,SigType type,SigningPublicKey fromJavaKey,DSAPublicKey pk,SigningPrivateKey fromJavaKey,DSAPrivateKey pk,SigningPublicKey fromJavaKey,RSAPublicKey pk,SigType type,SigningPrivateKey fromJavaKey,RSAPrivateKey pk,SigType type){\r\n    BigInteger n = pk.getModulus();\r\n    BigInteger d = pk.getPrivateExponent();\r\n    byte[] b = combine(n, d, type.getPrivkeyLen());\r\n    if (pk instanceof RSAPrivateCrtKey)\r\n        return RSASigningPrivateCrtKey.fromJavaKey((RSAPrivateCrtKey) pk);\r\n    return new SigningPrivateKey(type, b);\r\n}"
}, {
	"Path": "org.jrobin.core.RrdNioBackendFactory.setSyncPeriod",
	"Comment": "sets time between consecutive background synchronizations.",
	"Method": "void setSyncPeriod(int syncPeriod){\r\n    s_syncManager.setSyncPeriod(syncPeriod);\r\n}"
}, {
	"Path": "net.i2p.data.i2cp.I2CPMessageHandler.readMessage",
	"Comment": "read an i2cpmessage from the stream and return the fully populated object.",
	"Method": "I2CPMessage readMessage(InputStream in){\r\n    int length;\r\n    try {\r\n        length = (int) DataHelper.readLong(in, 4);\r\n    } catch (DataFormatException dfe) {\r\n        throw new IOException(\"Connection closed\");\r\n    }\r\n    if (length > MAX_LENGTH)\r\n        throw new I2CPMessageException(\"Invalid message length specified\");\r\n    try {\r\n        int type = (int) DataHelper.readLong(in, 1);\r\n        I2CPMessage msg = createMessage(type);\r\n        msg.readMessage(in, length, type);\r\n        return msg;\r\n    } catch (DataFormatException dfe) {\r\n        throw new I2CPMessageException(\"Error reading the message\", dfe);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.udpTunnel.I2PTunnelUDPServerBase.close",
	"Comment": "i2ptunneltask methodsclasses should override to close udp side as well",
	"Method": "boolean close(boolean forced){\r\n    if (!open)\r\n        return true;\r\n    synchronized (lock) {\r\n        l.log(\"Shutting down server \" + toString());\r\n        try {\r\n            if (_session != null) {\r\n                _session.destroySession();\r\n            }\r\n        } catch (I2PException ex) {\r\n            _log.error(\"Error destroying the session\", ex);\r\n        }\r\n        l.log(\"Server shut down.\");\r\n        open = false;\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerState.getClockSkew",
	"Comment": "how far off is the remote peer from our clock, in milliseconds? a positive number means our clock is ahead of theirs.",
	"Method": "long getClockSkew(){\r\n    return _clockSkew;\r\n}"
}, {
	"Path": "net.i2p.crypto.eddsa.math.GroupElement.getT",
	"Comment": "gets the t value of the group element.this is for most representation the projective t coordinate.",
	"Method": "FieldElement getT(){\r\n    return this.T;\r\n}"
}, {
	"Path": "i2p.susi.webmail.WebMail.quoteHTML",
	"Comment": "prepare line for presentation between html tags\tescapes html tags",
	"Method": "String quoteHTML(String line){\r\n    if (line != null)\r\n        line = DataHelper.escapeHTML(line);\r\n    else\r\n        line = \"\";\r\n    return line;\r\n}"
}, {
	"Path": "net.i2p.crypto.eddsa.math.GroupElement.getX",
	"Comment": "gets the x value of the group element.this is for most representation the projective x coordinate.",
	"Method": "FieldElement getX(){\r\n    return this.X;\r\n}"
}, {
	"Path": "net.i2p.crypto.eddsa.math.GroupElement.getY",
	"Comment": "gets the y value of the group element.this is for most representation the projective y coordinate.",
	"Method": "FieldElement getY(){\r\n    return this.Y;\r\n}"
}, {
	"Path": "net.i2p.crypto.eddsa.math.GroupElement.getZ",
	"Comment": "gets the z value of the group element.this is for most representation the projective z coordinate.",
	"Method": "FieldElement getZ(){\r\n    return this.Z;\r\n}"
}, {
	"Path": "com.netflix.hollow.api.codegen.HollowAPIGenerator.reservePrimaryKeyIndexForTypeWithPrimaryKey",
	"Comment": "use this method to specify to only generate primarykeyindex for types that has primarykey defineddefaults to false to be backwards compatible",
	"Method": "void reservePrimaryKeyIndexForTypeWithPrimaryKey(boolean reservePrimaryKeyIndexForTypeWithPrimaryKey){\r\n    config.setReservePrimaryKeyIndexForTypeWithPrimaryKey(reservePrimaryKeyIndexForTypeWithPrimaryKey);\r\n}"
}, {
	"Path": "i2p.susi.util.Config.saveConfiguration",
	"Comment": "saves the properties. a property not in newprops will be removed but\twill not override the default in the resource.",
	"Method": "void saveConfiguration(Properties newProps){\r\n    Properties toSave = new OrderedProperties();\r\n    for (Map.Entry<Object, Object> e : newProps.entrySet()) {\r\n        Object k = e.getKey();\r\n        if (configPrefix != null)\r\n            k = configPrefix + k;\r\n        toSave.put(k, e.getValue());\r\n    }\r\n    config = toSave;\r\n    File cfg = new File(I2PAppContext.getGlobalContext().getConfigDir(), \"susimail.config\");\r\n    DataHelper.storeProps(toSave, cfg);\r\n}"
}, {
	"Path": "org.jrobin.core.Archive.getRrdAllocator",
	"Comment": "required to implement rrdupdater interface. you should never call this method directly.",
	"Method": "RrdAllocator getRrdAllocator(){\r\n    return parentDb.getRrdAllocator();\r\n}"
}, {
	"Path": "net.i2p.crypto.elgamal.impl.ElGamalPrivateKeyImpl.getEncoded",
	"Comment": "return a pkcs8 representation of the key. the sequence returnedrepresents a full privatekeyinfo object.",
	"Method": "byte[] getEncoded(){\r\n    byte[] pb = elSpec.getP().toByteArray();\r\n    byte[] gb = elSpec.getG().toByteArray();\r\n    byte[] xb = x.toByteArray();\r\n    int seq3len = spaceFor(pb.length) + spaceFor(gb.length);\r\n    int seq2len = 8 + spaceFor(seq3len);\r\n    int seq1len = 3 + spaceFor(seq2len) + spaceFor(xb.length);\r\n    int totlen = spaceFor(seq1len);\r\n    byte[] rv = new byte[totlen];\r\n    int idx = 0;\r\n    rv[idx++] = 0x30;\r\n    idx = intToASN1(rv, idx, seq1len);\r\n    rv[idx++] = 0x02;\r\n    rv[idx++] = 1;\r\n    rv[idx++] = 0;\r\n    rv[idx++] = 0x30;\r\n    idx = intToASN1(rv, idx, seq2len);\r\n    rv[idx++] = 0x06;\r\n    rv[idx++] = 6;\r\n    rv[idx++] = (1 * 40) + 3;\r\n    rv[idx++] = 14;\r\n    rv[idx++] = 7;\r\n    rv[idx++] = 2;\r\n    rv[idx++] = 1;\r\n    rv[idx++] = 1;\r\n    rv[idx++] = 0x30;\r\n    idx = intToASN1(rv, idx, seq3len);\r\n    rv[idx++] = 0x02;\r\n    idx = intToASN1(rv, idx, pb.length);\r\n    System.arraycopy(pb, 0, rv, idx, pb.length);\r\n    idx += pb.length;\r\n    rv[idx++] = 0x02;\r\n    idx = intToASN1(rv, idx, gb.length);\r\n    System.arraycopy(gb, 0, rv, idx, gb.length);\r\n    idx += gb.length;\r\n    rv[idx++] = 0x04;\r\n    idx = intToASN1(rv, idx, xb.length);\r\n    System.arraycopy(xb, 0, rv, idx, xb.length);\r\n    return rv;\r\n}"
}, {
	"Path": "net.i2p.router.RouterContext.statPublisher",
	"Comment": "if the router is configured to, gather up some particularly tasty morselsregarding the stats managed and offer to publish them into the routerinfo.",
	"Method": "StatisticsManager statPublisher(){\r\n    return _statPublisher;\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.doctrine.EntityHelper.getAnnotationRepositoryClass",
	"Comment": "resolve shortcut and namespaces classes for current phpclass and attached modelname",
	"Method": "PhpClass getAnnotationRepositoryClass(PhpClass phpClass,String modelName){\r\n    if (modelName.startsWith(\"\\\\\")) {\r\n        return PhpElementsUtil.getClassInterface(phpClass.getProject(), modelName);\r\n    }\r\n    PhpNamedElementImpl phpNamedElementImpl = PsiTreeUtil.getParentOfType(phpClass, PhpNamedElementImpl.class);\r\n    if (phpNamedElementImpl != null) {\r\n        String className = phpNamedElementImpl.getFQN() + \"\\\\\" + modelName;\r\n        PhpClass namespaceClass = PhpElementsUtil.getClassInterface(phpClass.getProject(), className);\r\n        if (namespaceClass != null) {\r\n            return namespaceClass;\r\n        }\r\n    }\r\n    return PhpElementsUtil.getClassInterface(phpClass.getProject(), modelName);\r\n}"
}, {
	"Path": "net.i2p.router.client.ClientManagerFacadeImpl.isLocal",
	"Comment": "determine if the destination specified is managed locally.this calldoes block.",
	"Method": "boolean isLocal(Destination dest,boolean isLocal,Hash destHash){\r\n    if (_manager != null)\r\n        return _manager.isLocal(destHash);\r\n    else {\r\n        _log.debug(\"Null manager on isLocal(hash)!\");\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.Router.get1sRate",
	"Comment": "when outboundonly is false, outbound rate in bytes per second. when true, max of inbound and outbound rate in bytes per second.",
	"Method": "int get1sRate(int get1sRate,boolean outboundOnly){\r\n    FIFOBandwidthLimiter bw = _context.bandwidthLimiter();\r\n    int out = (int) bw.getSendBps();\r\n    if (outboundOnly)\r\n        return out;\r\n    return (int) Math.max(out, bw.getReceiveBps());\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.ConnectionManager.connect",
	"Comment": "build a new connection to the given peer.this blocks if there is noconnection delay, otherwise it returns immediately.",
	"Method": "Connection connect(Destination peer,ConnectionOptions opts,I2PSession session){\r\n    if (peer == null)\r\n        throw new NullPointerException();\r\n    Connection con = null;\r\n    long expiration = _context.clock().now();\r\n    long tmout = opts.getConnectTimeout();\r\n    if (tmout <= 0)\r\n        expiration += DEFAULT_STREAM_DELAY_MAX;\r\n    else\r\n        expiration += tmout;\r\n    _numWaiting.incrementAndGet();\r\n    while (true) {\r\n        long remaining = expiration - _context.clock().now();\r\n        if (remaining <= 0) {\r\n            _log.logAlways(Log.WARN, \"Refusing to connect since we have exceeded our max of \" + _defaultOptions.getMaxConns() + \" connections\");\r\n            _numWaiting.decrementAndGet();\r\n            return null;\r\n        }\r\n        if (locked_tooManyStreams()) {\r\n            int max = _defaultOptions.getMaxConns();\r\n            if (_numWaiting.get() > max) {\r\n                _log.logAlways(Log.WARN, \"Refusing connection since we have exceeded our max of \" + max + \" and there are \" + _numWaiting + \" waiting already\");\r\n                _numWaiting.decrementAndGet();\r\n                return null;\r\n            }\r\n            try {\r\n                Thread.sleep(remaining / 4);\r\n            } catch (InterruptedException ie) {\r\n            }\r\n        } else {\r\n            con = new Connection(_context, this, session, _schedulerChooser, _timer, _outboundQueue, _conPacketHandler, opts, false);\r\n            con.setRemotePeer(peer);\r\n            assignReceiveStreamId(con);\r\n            break;\r\n        }\r\n    }\r\n    con.eventOccurred();\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Connect() conDelay = \" + opts.getConnectDelay());\r\n    if (opts.getConnectDelay() <= 0) {\r\n        con.waitForConnect();\r\n    }\r\n    for (; ; ) {\r\n        int n = _numWaiting.get();\r\n        if (n <= 0)\r\n            break;\r\n        if (_numWaiting.compareAndSet(n, n - 1))\r\n            break;\r\n    }\r\n    _context.statManager().addRateData(\"stream.connectionCreated\", 1);\r\n    return con;\r\n}"
}, {
	"Path": "com.netflix.hollow.core.memory.ByteArrayOrdinalMap.populateNewHashArray",
	"Comment": "hash all of the existing values specified by the keys in the supplied long array into the supplied atomiclongarray.",
	"Method": "void populateNewHashArray(AtomicLongArray newKeys,long[] valuesToAdd){\r\n    int modBitmask = newKeys.length() - 1;\r\n    for (int i = 0; i < valuesToAdd.length; i++) {\r\n        if (valuesToAdd[i] != EMPTY_BUCKET_VALUE) {\r\n            int hash = rehashPreviouslyAddedData(valuesToAdd[i]);\r\n            int bucket = hash & modBitmask;\r\n            while (newKeys.get(bucket) != EMPTY_BUCKET_VALUE) bucket = (bucket + 1) & modBitmask;\r\n            newKeys.set(bucket, valuesToAdd[i]);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.klomp.snark.MetaInfo.getAnnounce",
	"Comment": "returns the string representing the url of the tracker for this torrent.",
	"Method": "String getAnnounce(){\r\n    return announce;\r\n}"
}, {
	"Path": "net.i2p.sam.SAMHandlerFactory.createSAMHandler",
	"Comment": "return the right sam handler depending on the protocol versionrequired by the client.",
	"Method": "SAMHandler createSAMHandler(SocketChannel s,Properties i2cpProps,SAMBridge parent){\r\n    String line;\r\n    Log log = I2PAppContext.getGlobalContext().logManager().getLog(SAMHandlerFactory.class);\r\n    try {\r\n        Socket sock = s.socket();\r\n        sock.setKeepAlive(true);\r\n        StringBuilder buf = new StringBuilder(128);\r\n        ReadLine.readLine(sock, buf, HELLO_TIMEOUT);\r\n        sock.setSoTimeout(0);\r\n        line = buf.toString();\r\n    } catch (SocketTimeoutException e) {\r\n        throw new SAMException(\"Timeout waiting for HELLO VERSION\", e);\r\n    } catch (IOException e) {\r\n        throw new SAMException(\"Error reading from socket\", e);\r\n    } catch (RuntimeException e) {\r\n        throw new SAMException(\"Unexpected error\", e);\r\n    }\r\n    if (log.shouldDebug())\r\n        log.debug(\"New message received: [\" + line + ']');\r\n    Properties props = SAMUtils.parseParams(line);\r\n    if (!\"HELLO\".equals(props.remove(SAMUtils.COMMAND)) || !\"VERSION\".equals(props.remove(SAMUtils.OPCODE))) {\r\n        throw new SAMException(\"Must start with HELLO VERSION\");\r\n    }\r\n    String minVer = props.getProperty(\"MIN\");\r\n    if (minVer == null) {\r\n        minVer = \"1\";\r\n    }\r\n    String maxVer = props.getProperty(\"MAX\");\r\n    if (maxVer == null) {\r\n        maxVer = \"99.99\";\r\n    }\r\n    String ver = chooseBestVersion(minVer, maxVer);\r\n    if (ver == null) {\r\n        SAMHandler.writeString(\"HELLO REPLY RESULT=NOVERSION\\n\", s);\r\n        return null;\r\n    }\r\n    if (Boolean.parseBoolean(i2cpProps.getProperty(SAMBridge.PROP_AUTH))) {\r\n        String user = props.getProperty(\"USER\");\r\n        String pw = props.getProperty(\"PASSWORD\");\r\n        if (user == null || pw == null) {\r\n            if (user == null)\r\n                log.logAlways(Log.WARN, \"SAM authentication failed\");\r\n            else\r\n                log.logAlways(Log.WARN, \"SAM authentication failed, user: \" + user);\r\n            throw new SAMException(\"USER and PASSWORD required\");\r\n        }\r\n        String savedPW = i2cpProps.getProperty(SAMBridge.PROP_PW_PREFIX + user + SAMBridge.PROP_PW_SUFFIX);\r\n        if (savedPW == null) {\r\n            log.logAlways(Log.WARN, \"SAM authentication failed, user: \" + user);\r\n            throw new SAMException(\"Authorization failed\");\r\n        }\r\n        PasswordManager pm = new PasswordManager(I2PAppContext.getGlobalContext());\r\n        if (!pm.checkHash(savedPW, pw)) {\r\n            log.logAlways(Log.WARN, \"SAM authentication failed, user: \" + user);\r\n            throw new SAMException(\"Authorization failed\");\r\n        }\r\n    }\r\n    if (!SAMHandler.writeString(\"HELLO REPLY RESULT=OK VERSION=\" + ver + \"\\n\", s))\r\n        throw new SAMException(\"Error writing to socket\");\r\n    int verMajor = getMajor(ver);\r\n    int verMinor = getMinor(ver);\r\n    SAMHandler handler;\r\n    try {\r\n        switch(verMajor) {\r\n            case 1:\r\n                handler = new SAMv1Handler(s, verMajor, verMinor, i2cpProps, parent);\r\n                break;\r\n            case 2:\r\n                handler = new SAMv2Handler(s, verMajor, verMinor, i2cpProps, parent);\r\n                break;\r\n            case 3:\r\n                handler = new SAMv3Handler(s, verMajor, verMinor, i2cpProps, parent);\r\n                break;\r\n            default:\r\n                log.error(\"BUG! Trying to initialize the wrong SAM version!\");\r\n                throw new SAMException(\"BUG! (in handler instantiation)\");\r\n        }\r\n    } catch (IOException e) {\r\n        log.error(\"Error creating the handler for version \" + verMajor, e);\r\n        throw new SAMException(\"IOException caught during SAM handler instantiation\");\r\n    }\r\n    return handler;\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.DBHistory.lookupSuccessful",
	"Comment": "note that the peer was not only able to respond to the lookup, but sent usthe data we wanted!",
	"Method": "void lookupSuccessful(){\r\n    _failedLookupRate.addData(0);\r\n    _context.statManager().addRateData(\"peer.failedLookupRate\", 0);\r\n    _lastLookupSuccessful = _context.clock().now();\r\n}"
}, {
	"Path": "org.klomp.snark.MetaInfo.checkPiece",
	"Comment": "checks that the given piece has the same sha1 hash as the givenbyte array. returns random results or indexoutofboundsexceptionswhen the piece number is unknown.",
	"Method": "boolean checkPiece(int piece,byte[] bs,int off,int length,boolean checkPiece,PartialPiece pp){\r\n    int piece = pp.getPiece();\r\n    byte[] hash;\r\n    try {\r\n        hash = pp.getHash();\r\n    } catch (IOException ioe) {\r\n        _log.warn(\"Error checking\", ioe);\r\n        return false;\r\n    }\r\n    for (int i = 0; i < 20; i++) {\r\n        if (hash[i] != piece_hashes[20 * piece + i])\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.lang.IgnoreParserDefinition.getCommentTokens",
	"Comment": "returns the set of token types which are treated as comments by the psi builder.tokens of those types are automatically skipped by psibuilder. also, to do patternsare searched in the text of tokens of those types.",
	"Method": "TokenSet getCommentTokens(){\r\n    return COMMENTS;\r\n}"
}, {
	"Path": "net.i2p.data.LeaseSet.getReceivedAsReply",
	"Comment": "if true, we received this leaseset by searching for itdefault false.",
	"Method": "boolean getReceivedAsReply(){\r\n    return _receivedAsReply;\r\n}"
}, {
	"Path": "com.spotify.heroic.metrics.EWMA.oneMinuteEWMA",
	"Comment": "creates a new ewma which is equivalent to the unix one minute load average and which expectsto be ticked every 5 seconds.",
	"Method": "EWMA oneMinuteEWMA(){\r\n    return new EWMA(M1_ALPHA, INTERVAL, TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.indexing.ExternalIndexableSetContributor.getAdditionalFiles",
	"Comment": "returns additional files located outside of the current project that should be indexed.",
	"Method": "HashSet<VirtualFile> getAdditionalFiles(Project project){\r\n    final HashSet<VirtualFile> files = ContainerUtil.newHashSet();\r\n    if (CACHE.containsKey(project)) {\r\n        files.addAll(ContainerUtil.filter(CACHE.get(project), VirtualFile::isValid));\r\n    } else {\r\n        for (IgnoreLanguage language : IgnoreBundle.LANGUAGES) {\r\n            final IgnoreFileType fileType = language.getFileType();\r\n            if (language.isOuterFileSupported()) {\r\n                for (VirtualFile file : language.getOuterFiles(project, true)) {\r\n                    if (file == null || !file.isValid()) {\r\n                        continue;\r\n                    }\r\n                    if (!(file.getFileType() instanceof IgnoreFileType) && !file.getFileType().equals(fileType)) {\r\n                        IgnoreManager.associateFileType(file.getName(), fileType);\r\n                    }\r\n                    files.add(file);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    CACHE.put(project, files);\r\n    return files;\r\n}"
}, {
	"Path": "com.nettgryppa.security.HashCash.initEstimates",
	"Comment": "seeds the estimates by determining how long it takes to calculate a 16bit collision on average.",
	"Method": "void initEstimates(){\r\n    if (milliFor16 == -1) {\r\n        long duration;\r\n        duration = Calendar.getInstance().getTimeInMillis();\r\n        for (int i = 0; i < 11; i++) {\r\n            mintCash(\"estimation\", 16);\r\n        }\r\n        duration = Calendar.getInstance().getTimeInMillis() - duration;\r\n        milliFor16 = (duration / 10);\r\n    }\r\n}"
}, {
	"Path": "org.klomp.snark.PeerID.sameID",
	"Comment": "returns true if and only if this peerid and the given peerid havethe same destination hash",
	"Method": "boolean sameID(PeerID pid){\r\n    return DataHelper.eq(destHash, pid.getDestHash());\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterInfo.getAddresses",
	"Comment": "retrieve the set of routeraddress structures at which thisrouter can be contacted.",
	"Method": "Collection<RouterAddress> getAddresses(){\r\n    return Collections.unmodifiableList(_addresses);\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.util.MatcherUtil.match",
	"Comment": "extracts alphanumeric parts from the regex pattern and checks if any of them is contained in the tested path.looking for the parts speed ups the matching and prevents from running whole regex on the string.",
	"Method": "boolean match(Pattern pattern,String path){\r\n    if (pattern == null || path == null) {\r\n        return false;\r\n    }\r\n    synchronized (cache) {\r\n        int hashCode = new HashCodeBuilder().append(pattern).append(path).toHashCode();\r\n        if (!cache.containsKey(hashCode)) {\r\n            final String[] parts = getParts(pattern);\r\n            boolean result = false;\r\n            if (parts.length == 0 || matchAllParts(parts, path)) {\r\n                try {\r\n                    result = pattern.matcher(path).find();\r\n                } catch (StringIndexOutOfBoundsException ignored) {\r\n                }\r\n            }\r\n            cache.put(hashCode, result);\r\n            return result;\r\n        }\r\n        return cache.get(hashCode);\r\n    }\r\n}"
}, {
	"Path": "com.spotify.heroic.rpc.grpc.GrpcRpcProtocolServer.extractInetSocketAddress",
	"Comment": "extract the local address from the current server.because no api is available to accomplish this, it currently uses a very ugly reflexiveapproach.",
	"Method": "InetSocketAddress extractInetSocketAddress(Server server){\r\n    final ServerImpl impl = (ServerImpl) server;\r\n    final Field transportServerField = ServerImpl.class.getDeclaredField(\"transportServer\");\r\n    transportServerField.setAccessible(true);\r\n    final Object transportServer = transportServerField.get(impl);\r\n    final Field channelField = transportServer.getClass().getDeclaredField(\"channel\");\r\n    channelField.setAccessible(true);\r\n    final Channel channel = (Channel) channelField.get(transportServer);\r\n    return (InetSocketAddress) channel.localAddress();\r\n}"
}, {
	"Path": "net.i2p.router.Router.locked_rebuildRouterInfo",
	"Comment": "rebuild and republish our routerinfo since something significant has changed.",
	"Method": "void locked_rebuildRouterInfo(boolean blockingRebuild){\r\n    RouterInfo ri;\r\n    if (_routerInfo != null)\r\n        ri = new RouterInfo(_routerInfo);\r\n    else\r\n        ri = new RouterInfo();\r\n    try {\r\n        ri.setPublished(_context.clock().now());\r\n        Properties stats = _context.statPublisher().publishStatistics();\r\n        ri.setOptions(stats);\r\n        ri.setAddresses(_context.commSystem().createAddresses());\r\n        SigningPrivateKey key = _context.keyManager().getSigningPrivateKey();\r\n        if (key == null) {\r\n            _log.log(Log.CRIT, \"Internal error - signing private key not known? Impossible?\");\r\n            return;\r\n        }\r\n        ri.sign(key);\r\n        setRouterInfo(ri);\r\n        if (!ri.isValid())\r\n            throw new DataFormatException(\"Our RouterInfo has a bad signature\");\r\n        Republish r = new Republish(_context);\r\n        if (blockingRebuild)\r\n            r.timeReached();\r\n        else\r\n            _context.simpleTimer2().addEvent(r, 0);\r\n    } catch (DataFormatException dfe) {\r\n        _log.log(Log.CRIT, \"Internal error - unable to sign our own address?!\", dfe);\r\n    }\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.settings.IgnoreSettings.setNotifyIgnoredEditing",
	"Comment": "sets value for informing user about the tracked and ignored files in the project.",
	"Method": "void setNotifyIgnoredEditing(boolean notifyIgnoredEditing){\r\n    this.notifyOnChange(KEY.NOTIFY_IGNORED_EDITING, this.notifyIgnoredEditing, notifyIgnoredEditing);\r\n    this.notifyIgnoredEditing = notifyIgnoredEditing;\r\n}"
}, {
	"Path": "net.i2p.util.FortunaRandomSource.nextByte",
	"Comment": "not part of java.util.securerandom, but added for efficiency, since fortuna supports it.",
	"Method": "byte nextByte(){\r\n    synchronized (_fortuna) {\r\n        return _fortuna.nextByte();\r\n    }\r\n}"
}, {
	"Path": "net.i2p.stat.StatManager.createRequiredFrequencyStat",
	"Comment": "create a new statistic to monitor the frequency of some event.the stat is always created, independent of the stat.full setting or context.",
	"Method": "void createRequiredFrequencyStat(String name,String description,String group,long periods){\r\n    if (_frequencyStats.containsKey(name))\r\n        return;\r\n    _frequencyStats.putIfAbsent(name, new FrequencyStat(name, description, group, periods));\r\n}"
}, {
	"Path": "com.netflix.hollow.tools.traverse.TransitiveSetTraverser.removeReferencedOutsideClosure",
	"Comment": "remove any records from the given selection which are referenced by other records not in the selection.",
	"Method": "void removeReferencedOutsideClosure(HollowReadStateEngine stateEngine,Map<String, BitSet> matches){\r\n    List<HollowSchema> orderedSchemas = HollowSchemaSorter.dependencyOrderedSchemaList(stateEngine);\r\n    Collections.reverse(orderedSchemas);\r\n    for (HollowSchema referencedSchema : orderedSchemas) {\r\n        if (matches.containsKey(referencedSchema.getName())) {\r\n            for (HollowSchema referencerSchema : orderedSchemas) {\r\n                if (referencerSchema == referencedSchema)\r\n                    break;\r\n                if (matches.containsKey(referencedSchema.getName()) && matches.get(referencedSchema.getName()).cardinality() > 0)\r\n                    traverseReferencesOutsideClosure(stateEngine, referencerSchema.getName(), referencedSchema.getName(), matches, REMOVE_REFERENCED_OUTSIDE_CLOSURE);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.nicoulaj.idea.markdown.editor.MarkdownPreviewEditor.isModified",
	"Comment": "indicates whether the document content is modified compared to its file.",
	"Method": "boolean isModified(){\r\n    return false;\r\n}"
}, {
	"Path": "com.spotify.heroic.metrics.EWMA.tick",
	"Comment": "mark the passage of time and decay the current rate accordingly.",
	"Method": "void tick(){\r\n    final long count = uncounted.sumThenReset();\r\n    final double instantRate = count / interval;\r\n    if (initialized) {\r\n        rate += (alpha * (instantRate - rate));\r\n    } else {\r\n        rate = instantRate;\r\n        initialized = true;\r\n    }\r\n}"
}, {
	"Path": "io.helidon.webserver.examples.translator.backend.TranslatorResource.getText",
	"Comment": "get method to translate a given query to a given language if possible.",
	"Method": "Response getText(String query,String language){\r\n    if (Main.isSecurityDisabled()) {\r\n        LOGGER.info(\"[dev-local] Security check is disabled by local development mode.\");\r\n        LOGGER.info(\"getText(\\\"\" + query + \"\\\", \" + language + \")\");\r\n    } else {\r\n    }\r\n    if (TranslatorResource.brokenFlag) {\r\n        return Response.serverError().build();\r\n    }\r\n    String translation;\r\n    switch(language) {\r\n        case CZECH:\r\n            translation = TRANSLATED_WORDS_REPOSITORY.get(query + SEPARATOR + CZECH);\r\n            break;\r\n        case SPANISH:\r\n            translation = TRANSLATED_WORDS_REPOSITORY.get(query + SEPARATOR + SPANISH);\r\n            break;\r\n        case CHINESE:\r\n            translation = TRANSLATED_WORDS_REPOSITORY.get(query + SEPARATOR + CHINESE);\r\n            break;\r\n        case HINDI:\r\n            translation = TRANSLATED_WORDS_REPOSITORY.get(query + SEPARATOR + HINDI);\r\n            break;\r\n        case ITALIAN:\r\n            translation = TRANSLATED_WORDS_REPOSITORY.get(query + SEPARATOR + ITALIAN);\r\n            break;\r\n        case FRENCH:\r\n            translation = TRANSLATED_WORDS_REPOSITORY.get(query + SEPARATOR + FRENCH);\r\n            break;\r\n        default:\r\n            return Response.status(Response.Status.NOT_FOUND).entity(String.format(\"Language '%s' not in supported. Supported languages: %s, %s, %s, %s.\", language, CZECH, SPANISH, CHINESE, HINDI)).build();\r\n    }\r\n    if (translation != null) {\r\n        return Response.ok(translation).build();\r\n    } else {\r\n        return Response.status(Response.Status.NOT_FOUND).entity(String.format(\"Word '%s' not in the dictionary\", query)).build();\r\n    }\r\n}"
}, {
	"Path": "net.i2p.util.InternalServerSocket.isClosed",
	"Comment": "supported as of 0.9.33, prior to that threw illegalargumentexception",
	"Method": "boolean isClosed(){\r\n    return !_running;\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.ui.untrackFiles.UntrackFilesDialog.createTreeActionsToolbarPanel",
	"Comment": "creates tree toolbar panel with actions for working with templates tree.",
	"Method": "ActionToolbar createTreeActionsToolbarPanel(JComponent target){\r\n    final CommonActionsManager actionManager = CommonActionsManager.getInstance();\r\n    final DefaultActionGroup actions = new DefaultActionGroup();\r\n    actions.add(actionManager.createExpandAllAction(treeExpander, tree));\r\n    actions.add(actionManager.createCollapseAllAction(treeExpander, tree));\r\n    final ActionToolbar actionToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, actions, true);\r\n    actionToolbar.setTargetComponent(target);\r\n    return actionToolbar;\r\n}"
}, {
	"Path": "net.i2p.router.web.ConfigUpdateHelper.getNewsURL",
	"Comment": "hack to replace the old news location with the new one, even if they have savedthe update page at some point",
	"Method": "String getNewsURL(String getNewsURL,I2PAppContext ctx){\r\n    String url = ctx.getProperty(ConfigUpdateHandler.PROP_NEWS_URL);\r\n    if (url != null && !url.equals(ConfigUpdateHandler.OLD_DEFAULT_NEWS_URL) && !url.equals(ConfigUpdateHandler.DEFAULT_NEWS_URL) && !url.equals(ConfigUpdateHandler.OLD_DEFAULT_NEWS_URL_SU3))\r\n        return url;\r\n    else\r\n        return ConfigUpdateHandler.DEFAULT_NEWS_URL_SU3;\r\n}"
}, {
	"Path": "org.jrobin.core.RrdJRobin14FileBackendFactory.exists",
	"Comment": "method to determine if a file with the given path already exists.",
	"Method": "boolean exists(String path){\r\n    return Util.fileExists(path);\r\n}"
}, {
	"Path": "io.helidon.security.jwt.JwtUtil.getString",
	"Comment": "extract a key value from json object that is string if present.",
	"Method": "Optional<String> getString(JsonObject json,String key){\r\n    return Optional.ofNullable(json.getString(key, null));\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.Packet.getReceiveStreamId",
	"Comment": "stream the replies should be sent on.this should be 0 if theconnection is still being built.",
	"Method": "long getReceiveStreamId(){\r\n    return _receiveStreamId;\r\n}"
}, {
	"Path": "com.netflix.hollow.api.codegen.HollowAPIGenerator.hasCollectionsInDataSet",
	"Comment": "determines whether dataset contains any collections schema",
	"Method": "boolean hasCollectionsInDataSet(HollowDataset dataset){\r\n    for (HollowSchema schema : dataset.getSchemas()) {\r\n        if ((schema instanceof HollowListSchema) || (schema instanceof HollowSetSchema) || (schema instanceof HollowMapSchema)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.i2p.data.DatabaseEntry.setSignature",
	"Comment": "configure the proof that the entity stands behind the info here",
	"Method": "void setSignature(Signature signature){\r\n    if (_signature != null)\r\n        throw new IllegalStateException();\r\n    _signature = signature;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.UDPTransport.isValid",
	"Comment": "an ipv6 address is only valid if we are configured to support ipv6and we have a public ipv6 address.",
	"Method": "boolean isValid(byte addr){\r\n    if (addr == null)\r\n        return false;\r\n    if (isPubliclyRoutable(addr) && (addr.length != 16 || _haveIPv6Address))\r\n        return true;\r\n    return allowLocal();\r\n}"
}, {
	"Path": "net.i2p.router.web.helpers.WizardHelper.getInboundBurstRate",
	"Comment": "to populate form with.uses the test result if available, else the current settingadapted from confignethelper.",
	"Method": "String getInboundBurstRate(){\r\n    float bw;\r\n    long result = getDownBandwidth();\r\n    if (result > 0) {\r\n        bw = Math.max(MIN_DOWN_BW, BW_SCALE * result / 1000f);\r\n    } else {\r\n        bw = _context.bandwidthLimiter().getInboundBurstKBytesPerSecond() * 1.024f;\r\n    }\r\n    return Integer.toString(Math.round(bw));\r\n}"
}, {
	"Path": "net.i2p.data.i2np.I2NPMessageImpl.setUniqueId",
	"Comment": "the id is set to a random value when written but it can be overridden here.",
	"Method": "void setUniqueId(long id){\r\n    _uniqueId = id;\r\n}"
}, {
	"Path": "com.spotify.heroic.aggregation.GroupingAggregationTest.testDistributedAggregation",
	"Comment": "checks that the distribute aggregation for grouping aggregations are composed out of thedistributed aggregation for the child clause.",
	"Method": "void testDistributedAggregation(){\r\n    final AggregationInstance distributed = mock(AggregationInstance.class);\r\n    final AggregationInstance next = mock(AggregationInstance.class);\r\n    final AggregationInstance each = mock(AggregationInstance.class);\r\n    final Optional<List<String>> of = Optional.empty();\r\n    final SimpleGroup g = spy(new SimpleGroup(of, each));\r\n    doReturn(distributed).when(each).distributed();\r\n    doReturn(next).when(g).newInstance(of, distributed);\r\n    assertEquals(next, g.distributed());\r\n    verify(each).distributed();\r\n    verify(g).newInstance(of, distributed);\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.pool.TunnelPool.selectTunnel",
	"Comment": "pull a random tunnel out of the pool.if there are none available butthe pool is configured to allow 0hop tunnels, this builds a fake oneand returns it.",
	"Method": "TunnelInfo selectTunnel(TunnelInfo selectTunnel,boolean allowRecurseOnFail,TunnelInfo selectTunnel,Hash closestTo){\r\n    boolean avoidZeroHop = !_settings.getAllowZeroHop();\r\n    TunnelInfo rv = null;\r\n    synchronized (_tunnels) {\r\n        if (!_tunnels.isEmpty()) {\r\n            if (_tunnels.size() > 1)\r\n                Collections.sort(_tunnels, new TunnelInfoComparator(closestTo, avoidZeroHop));\r\n            for (TunnelInfo info : _tunnels) {\r\n                if (info.getExpiration() > _context.clock().now()) {\r\n                    rv = info;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (rv != null) {\r\n        _context.statManager().addRateData(\"tunnel.matchLease\", closestTo.equals(rv.getFarEnd()) ? 1 : 0);\r\n    } else {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(toString() + \": No tunnels to select from\");\r\n    }\r\n    return rv;\r\n}"
}, {
	"Path": "org.jrobin.graph.RrdGraphDef.setWidth",
	"Comment": "sets width of the drawing area within the graph. this affects the totalsize of the image.",
	"Method": "void setWidth(int width){\r\n    this.width = width;\r\n}"
}, {
	"Path": "net.i2p.util.FileUtil.rmdir",
	"Comment": "delete the path as well as any files or directories underneath it.",
	"Method": "boolean rmdir(String path,boolean failIfNotEmpty,boolean rmdir,File target,boolean failIfNotEmpty){\r\n    if (!target.exists()) {\r\n        return true;\r\n    }\r\n    if (!target.isDirectory()) {\r\n        return target.delete();\r\n    } else {\r\n        File[] children = target.listFiles();\r\n        if (children == null) {\r\n            return false;\r\n        }\r\n        if ((failIfNotEmpty) && (children.length > 0)) {\r\n            return false;\r\n        }\r\n        for (int i = 0; i < children.length; i++) {\r\n            if (!rmdir(children[i], failIfNotEmpty))\r\n                return false;\r\n        }\r\n        return target.delete();\r\n    }\r\n}"
}, {
	"Path": "io.helidon.security.jwt.jwk.Jwk.verifySignature",
	"Comment": "verify that the signature is indeed for the signed bytes based on this jwk typeand algorithm.",
	"Method": "boolean verifySignature(byte[] signedBytes,byte[] signature){\r\n    if (supports(USE_SIGNATURE, OPERATION_VERIFY)) {\r\n        return doVerify(signedBytes, signature);\r\n    } else {\r\n        throw new JwtException(\"This key (\" + this + \") does not support verification of requests\");\r\n    }\r\n}"
}, {
	"Path": "org.klomp.snark.dht.KRPC.receivePong",
	"Comment": "if node info was previously created with the dummy nid, replace it with the received nid.",
	"Method": "void receivePong(NodeInfo nInfo,byte[] nid){\r\n    if (nInfo.getNID().equals(FAKE_NID)) {\r\n        NodeInfo newInfo = new NodeInfo(new NID(nid), nInfo.getHash(), nInfo.getPort());\r\n        Destination dest = nInfo.getDestination();\r\n        if (dest != null)\r\n            newInfo.setDestination(dest);\r\n        heardFrom(newInfo);\r\n    }\r\n    if (_log.shouldLog(Log.INFO))\r\n        _log.info(\"Rcvd pong from: \" + nInfo);\r\n}"
}, {
	"Path": "net.i2p.crypto.eddsa.math.MathUtils.toRepresentation",
	"Comment": "converts a group element from one representation to another.this method is a helper used to test various methods in groupelement.",
	"Method": "GroupElement toRepresentation(GroupElement g,GroupElement.Representation repr){\r\n    BigInteger x;\r\n    BigInteger y;\r\n    final BigInteger gX = toBigInteger(g.getX().toByteArray());\r\n    final BigInteger gY = toBigInteger(g.getY().toByteArray());\r\n    final BigInteger gZ = toBigInteger(g.getZ().toByteArray());\r\n    final BigInteger gT = null == g.getT() ? null : toBigInteger(g.getT().toByteArray());\r\n    switch(g.getRepresentation()) {\r\n        case P2:\r\n        case P3:\r\n        case P3PrecomputedDouble:\r\n            x = gX.multiply(gZ.modInverse(getQ())).mod(getQ());\r\n            y = gY.multiply(gZ.modInverse(getQ())).mod(getQ());\r\n            break;\r\n        case P1P1:\r\n            x = gX.multiply(gZ.modInverse(getQ())).mod(getQ());\r\n            y = gY.multiply(gT.modInverse(getQ())).mod(getQ());\r\n            break;\r\n        case CACHED:\r\n            x = gX.subtract(gY).multiply(gZ.multiply(new BigInteger(\"2\")).modInverse(getQ())).mod(getQ());\r\n            y = gX.add(gY).multiply(gZ.multiply(new BigInteger(\"2\")).modInverse(getQ())).mod(getQ());\r\n            break;\r\n        case PRECOMP:\r\n            x = gX.subtract(gY).multiply(new BigInteger(\"2\").modInverse(getQ())).mod(getQ());\r\n            y = gX.add(gY).multiply(new BigInteger(\"2\").modInverse(getQ())).mod(getQ());\r\n            break;\r\n        default:\r\n            throw new UnsupportedOperationException();\r\n    }\r\n    switch(repr) {\r\n        case P2:\r\n            return GroupElement.p2(curve, toFieldElement(x), toFieldElement(y), getField().ONE);\r\n        case P3:\r\n            return GroupElement.p3(curve, toFieldElement(x), toFieldElement(y), getField().ONE, toFieldElement(x.multiply(y).mod(getQ())), false);\r\n        case P3PrecomputedDouble:\r\n            return GroupElement.p3(curve, toFieldElement(x), toFieldElement(y), getField().ONE, toFieldElement(x.multiply(y).mod(getQ())), true);\r\n        case P1P1:\r\n            return GroupElement.p1p1(curve, toFieldElement(x), toFieldElement(y), getField().ONE, getField().ONE);\r\n        case CACHED:\r\n            return GroupElement.cached(curve, toFieldElement(y.add(x).mod(getQ())), toFieldElement(y.subtract(x).mod(getQ())), getField().ONE, toFieldElement(d.multiply(new BigInteger(\"2\")).multiply(x).multiply(y).mod(getQ())));\r\n        case PRECOMP:\r\n            return GroupElement.precomp(curve, toFieldElement(y.add(x).mod(getQ())), toFieldElement(y.subtract(x).mod(getQ())), toFieldElement(d.multiply(new BigInteger(\"2\")).multiply(x).multiply(y).mod(getQ())));\r\n        default:\r\n            throw new UnsupportedOperationException();\r\n    }\r\n}"
}, {
	"Path": "com.netflix.hollow.api.producer.HollowProducer.runCompactionCycle",
	"Comment": "run a compaction cycle, will produce a data state with exactly the same data as currently, butreorganized so that ordinal holes are filled.this may need to be run multiple times to arriveat an optimal state.",
	"Method": "long runCompactionCycle(HollowCompactor.CompactionConfig config){\r\n    if (config != null && readStates.hasCurrent()) {\r\n        final HollowCompactor compactor = new HollowCompactor(getWriteEngine(), readStates.current().getStateEngine(), config);\r\n        if (compactor.needsCompaction()) {\r\n            return runCycle(newState -> compactor.compact());\r\n        }\r\n    }\r\n    return NO_ANNOUNCEMENT_AVAILABLE;\r\n}"
}, {
	"Path": "net.i2p.util.I2PThread.addOOMEventListener",
	"Comment": "register a new component that wants notification of oom events",
	"Method": "void addOOMEventListener(OOMEventListener lsnr){\r\n    _listeners.add(lsnr);\r\n}"
}, {
	"Path": "net.i2p.router.transport.FIFOBandwidthLimiter.locked_satisfyOutboundUnlimited",
	"Comment": "there are no limits, so just give every outbound request whatever they want",
	"Method": "void locked_satisfyOutboundUnlimited(List<Request> satisfied){\r\n    while (!_pendingOutboundRequests.isEmpty()) {\r\n        SimpleRequest req = _pendingOutboundRequests.remove(0);\r\n        int allocated = req.getPendingRequested();\r\n        _totalAllocatedOutboundBytes.addAndGet(allocated);\r\n        req.allocateBytes(allocated);\r\n        satisfied.add(req);\r\n        long waited = now() - req.getRequestTime();\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"Granting outbound request \" + req + \" fully (waited \" + waited + \"ms) pending \" + _pendingOutboundRequests.size() + \", longest waited \" + locked_getLongestOutboundWait() + \" out\");\r\n        if (waited > 10)\r\n            _context.statManager().addRateData(\"bwLimiter.outboundDelayedTime\", waited);\r\n    }\r\n}"
}, {
	"Path": "com.spotify.heroic.cluster.CoreClusterManager.refreshFinalize",
	"Comment": "create a lazy transform that updates the local state of the registry, or attempts anotherrefresh if the local state has already been updated.",
	"Method": "AsyncFuture<Void> refreshFinalize(String id,Map<URI, ClusterNode> oldClients,Map<URI, ClusterNode> newClients,Set<ClusterNode> okNodes,List<SuccessfulUpdate> okUpdates,List<RemovedNode> removedNodes,List<ClusterNode> failedNodes){\r\n    if (this.clients.compareAndSet(oldClients, newClients)) {\r\n        synchronized (this.updateRegistryLock) {\r\n            registry.getAndSet(new NodeRegistry(async, new ArrayList(okNodes), okNodes.size()));\r\n        }\r\n        final List<AsyncFuture<Void>> removals = new ArrayList();\r\n        removedNodes.forEach(removedNode -> {\r\n            log.error(\"{} [remove] {}\", id, removedNode.getUri());\r\n            removals.add(removedNode.getNode().close());\r\n        });\r\n        failedNodes.forEach(failedNode -> {\r\n            removals.add(failedNode.close());\r\n        });\r\n        return async.collectAndDiscard(removals);\r\n    }\r\n    log.warn(\"{} another refresh in progress, trying again\", id);\r\n    final List<AsyncFuture<Void>> removals = new ArrayList();\r\n    removals.addAll(okUpdates.stream().filter(SuccessfulUpdate::isAdded).map(s -> s.getNode().close()).collect(Collectors.toList()));\r\n    return async.collectAndDiscard(removals).lazyTransform(v0 -> refreshDiscovery(id));\r\n}"
}, {
	"Path": "i2p.susi.webmail.WebMail.isMobile",
	"Comment": "either mobile or text browsercopied from net.i2p.router.web.csshelper",
	"Method": "boolean isMobile(String ua){\r\n    if (ua == null)\r\n        return false;\r\n    return ServletUtil.isSmallBrowser(ua);\r\n}"
}, {
	"Path": "net.i2p.router.RouterThrottleImpl.acceptNetworkMessage",
	"Comment": "should we accept any more data from the network for any sort of message, taking into account our current load, or should we simply slow down?fixme only called by ssu receiver, not ntcp!fixme should put warning on the consolefixme or should we do this at all? we have codel queues all over now...",
	"Method": "boolean acceptNetworkMessage(){\r\n    long lag = _context.jobQueue().getMaxLag();\r\n    if ((lag > JOB_LAG_LIMIT_NETWORK) && (_context.router().getUptime() > 60 * 1000)) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Throttling network reader, as the job lag is \" + lag);\r\n        _context.statManager().addRateData(\"router.throttleNetworkCause\", lag);\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "net.i2p.client.impl.I2PSessionImpl.loadConfig",
	"Comment": "parse the config for anything we know about.also fill in the authorization properties if missing.",
	"Method": "Properties loadConfig(Properties opts){\r\n    Properties options = new Properties();\r\n    options.putAll(filter(opts));\r\n    if ((!_context.isRouterContext()) && _context.getBooleanProperty(\"i2cp.auth\") && ((!opts.containsKey(PROP_USER)) || (!opts.containsKey(PROP_PW)))) {\r\n        String configUser = _context.getProperty(PROP_USER);\r\n        String configPW = _context.getProperty(PROP_PW);\r\n        if (configUser != null && configPW != null) {\r\n            options.setProperty(PROP_USER, configUser);\r\n            options.setProperty(PROP_PW, configPW);\r\n        }\r\n    }\r\n    if (options.getProperty(I2PClient.PROP_FAST_RECEIVE) == null)\r\n        options.setProperty(I2PClient.PROP_FAST_RECEIVE, \"true\");\r\n    if (options.getProperty(I2PClient.PROP_RELIABILITY) == null)\r\n        options.setProperty(I2PClient.PROP_RELIABILITY, \"none\");\r\n    return options;\r\n}"
}, {
	"Path": "com.netflix.hollow.diffview.effigy.pairer.HollowEffigyCollectionPairer.pairByMinDifference",
	"Comment": "finds the element pairings which have the minimum number of differences between them.",
	"Method": "List<EffigyFieldPair> pairByMinDifference(){\r\n    List<EffigyFieldPair> fieldPairs = new ArrayList<EffigyFieldPair>();\r\n    BitSet pairedFromIndices = new BitSet(from.getFields().size());\r\n    BitSet pairedToIndices = new BitSet(to.getFields().size());\r\n    int[] maxDiffBackoff = new int[] { 1, 2, 4, 8, Integer.MAX_VALUE };\r\n    int maxPairs = Math.min(from.getFields().size(), to.getFields().size());\r\n    for (int i = 0; i < maxDiffBackoff.length && fieldPairs.size() < maxPairs; i++) {\r\n        long[] diffMatrixElements = pair(pairedFromIndices, pairedToIndices, maxDiffBackoff[i]);\r\n        Arrays.sort(diffMatrixElements);\r\n        for (long matrixElement : diffMatrixElements) {\r\n            if (fieldPairs.size() == maxPairs)\r\n                break;\r\n            int diffScore = getDiffScore(matrixElement);\r\n            if (diffScore == MAX_MATRIX_ELEMENT_FIELD_VALUE)\r\n                break;\r\n            int fromIndex = getFromIndex(matrixElement);\r\n            int toIndex = getToIndex(matrixElement);\r\n            if (pairedFromIndices.get(fromIndex))\r\n                continue;\r\n            if (pairedToIndices.get(toIndex))\r\n                continue;\r\n            fieldPairs.add(new EffigyFieldPair(from.getFields().get(fromIndex), to.getFields().get(toIndex), fromIndex, toIndex));\r\n            pairedFromIndices.set(fromIndex);\r\n            pairedToIndices.set(toIndex);\r\n        }\r\n    }\r\n    addUnmatchedElements(fieldPairs, pairedFromIndices, pairedToIndices);\r\n    return fieldPairs;\r\n}"
}, {
	"Path": "org.klomp.snark.I2PSnarkUtil.get",
	"Comment": "fetch the given url, returning the file it is stored in, or null on error.no retries.",
	"Method": "File get(String url,File get,String url,boolean rewrite,File get,String url,int retries,File get,String url,boolean rewrite,int retries,byte[] get,String url,boolean rewrite,int retries,int initialSize,int maxSize){\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Fetching [\" + url + \"] to memory\");\r\n    String fetchURL = url;\r\n    if (rewrite)\r\n        fetchURL = rewriteAnnounce(url);\r\n    int timeout;\r\n    if (retries < 0) {\r\n        if (!connected())\r\n            return null;\r\n        timeout = EEPGET_CONNECT_TIMEOUT_SHORT;\r\n        retries = 0;\r\n    } else {\r\n        timeout = EEPGET_CONNECT_TIMEOUT;\r\n        if (!connected()) {\r\n            if (!connect())\r\n                return null;\r\n        }\r\n    }\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream(initialSize);\r\n    EepGet get = new I2PSocketEepGet(_context, _manager, retries, -1, maxSize, null, out, fetchURL);\r\n    get.addHeader(\"User-Agent\", EEPGET_USER_AGENT);\r\n    if (get.fetch(timeout)) {\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"Fetch successful [\" + url + \"]: size=\" + out.size());\r\n        return out.toByteArray();\r\n    } else {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Fetch failed [\" + url + \"]\");\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.nicoulaj.idea.markdown.highlighter.MarkdownColorSettingsPage.getAdditionalHighlightingTagToDescriptorMap",
	"Comment": "get the mapping from special tag names surrounding the regions to be highlighted in the preview text to textattribute keys used to highlight the regions.",
	"Method": "Map<String, TextAttributesKey> getAdditionalHighlightingTagToDescriptorMap(){\r\n    return null;\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.translation.dict.TranslationUtil.getPlaceholderFromTranslation",
	"Comment": "extract common placeholder pattern from translation content",
	"Method": "Set<String> getPlaceholderFromTranslation(String text,Set<String> getPlaceholderFromTranslation,Project project,String key,String domain){\r\n    Set<String> placeholder = new HashSet();\r\n    Set<VirtualFile> visitedXlf = new HashSet();\r\n    for (PsiElement element : TranslationUtil.getTranslationPsiElements(project, key, domain)) {\r\n        if (element instanceof YAMLScalar) {\r\n            String textValue = ((YAMLScalar) element).getTextValue();\r\n            if (StringUtils.isBlank(textValue)) {\r\n                continue;\r\n            }\r\n            placeholder.addAll(TranslationUtil.getPlaceholderFromTranslation(textValue));\r\n        } else if (\"xlf\".equalsIgnoreCase(element.getContainingFile().getVirtualFile().getExtension()) || \"xliff\".equalsIgnoreCase(element.getContainingFile().getVirtualFile().getExtension())) {\r\n            VirtualFile virtualFile = element.getContainingFile().getVirtualFile();\r\n            if (!visitedXlf.contains(virtualFile)) {\r\n                try {\r\n                    visitXliffTranslations(element.getContainingFile().getVirtualFile().getInputStream(), new MyXlfTranslationConsumer(placeholder, key));\r\n                } catch (IOException ignored) {\r\n                }\r\n            }\r\n            visitedXlf.add(virtualFile);\r\n        }\r\n    }\r\n    return placeholder;\r\n}"
}, {
	"Path": "net.i2p.router.web.helpers.ConfigTunnelsHandler.saveChanges",
	"Comment": "the user made changes to the network config and wants to save them, solets go ahead and do so.",
	"Method": "void saveChanges(){\r\n    boolean saveRequired = false;\r\n    Map<String, String> changes = new HashMap<String, String>();\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Saving changes, with props = \" + _settings + \".\");\r\n    int updated = 0;\r\n    int index = 0;\r\n    while (true) {\r\n        Object val = _settings.get(\"pool.\" + index);\r\n        if (val == null)\r\n            break;\r\n        Hash client = new Hash();\r\n        String poolName = (val instanceof String ? (String) val : ((String[]) val)[0]);\r\n        TunnelPoolSettings in = null;\r\n        TunnelPoolSettings out = null;\r\n        if (\"exploratory\".equals(poolName)) {\r\n            in = _context.tunnelManager().getInboundSettings();\r\n            out = _context.tunnelManager().getOutboundSettings();\r\n        } else {\r\n            try {\r\n                client.fromBase64(poolName);\r\n            } catch (DataFormatException dfe) {\r\n                addFormError(\"Internal error (pool name could not resolve - \" + poolName + \").\");\r\n                index++;\r\n                continue;\r\n            }\r\n            in = _context.tunnelManager().getInboundSettings(client);\r\n            out = _context.tunnelManager().getOutboundSettings(client);\r\n        }\r\n        if ((in == null) || (out == null)) {\r\n            addFormError(\"Internal error (pool settings cound not be found for \" + poolName + \").\");\r\n            index++;\r\n            continue;\r\n        }\r\n        Object di = _settings.get(index + \".depthInbound\");\r\n        if (di == null) {\r\n            index++;\r\n            continue;\r\n        }\r\n        in.setLength(getInt(di));\r\n        out.setLength(getInt(_settings.get(index + \".depthOutbound\")));\r\n        in.setLengthVariance(getInt(_settings.get(index + \".varianceInbound\")));\r\n        out.setLengthVariance(getInt(_settings.get(index + \".varianceOutbound\")));\r\n        in.setQuantity(getInt(_settings.get(index + \".quantityInbound\")));\r\n        out.setQuantity(getInt(_settings.get(index + \".quantityOutbound\")));\r\n        in.setBackupQuantity(getInt(_settings.get(index + \".backupInbound\")));\r\n        out.setBackupQuantity(getInt(_settings.get(index + \".backupOutbound\")));\r\n        if (\"exploratory\".equals(poolName)) {\r\n            changes.put(TunnelPoolSettings.PREFIX_INBOUND_EXPLORATORY + TunnelPoolSettings.PROP_LENGTH, in.getLength() + \"\");\r\n            changes.put(TunnelPoolSettings.PREFIX_OUTBOUND_EXPLORATORY + TunnelPoolSettings.PROP_LENGTH, out.getLength() + \"\");\r\n            changes.put(TunnelPoolSettings.PREFIX_INBOUND_EXPLORATORY + TunnelPoolSettings.PROP_LENGTH_VARIANCE, in.getLengthVariance() + \"\");\r\n            changes.put(TunnelPoolSettings.PREFIX_OUTBOUND_EXPLORATORY + TunnelPoolSettings.PROP_LENGTH_VARIANCE, out.getLengthVariance() + \"\");\r\n            changes.put(TunnelPoolSettings.PREFIX_INBOUND_EXPLORATORY + TunnelPoolSettings.PROP_QUANTITY, in.getQuantity() + \"\");\r\n            changes.put(TunnelPoolSettings.PREFIX_OUTBOUND_EXPLORATORY + TunnelPoolSettings.PROP_QUANTITY, out.getQuantity() + \"\");\r\n            changes.put(TunnelPoolSettings.PREFIX_INBOUND_EXPLORATORY + TunnelPoolSettings.PROP_BACKUP_QUANTITY, in.getBackupQuantity() + \"\");\r\n            changes.put(TunnelPoolSettings.PREFIX_OUTBOUND_EXPLORATORY + TunnelPoolSettings.PROP_BACKUP_QUANTITY, out.getBackupQuantity() + \"\");\r\n        }\r\n        if (\"exploratory\".equals(poolName)) {\r\n            if (_log.shouldLog(Log.DEBUG)) {\r\n                _log.debug(\"Inbound exploratory settings: \" + in);\r\n                _log.debug(\"Outbound exploratory settings: \" + out);\r\n            }\r\n            _context.tunnelManager().setInboundSettings(in);\r\n            _context.tunnelManager().setOutboundSettings(out);\r\n        } else {\r\n            if (_log.shouldLog(Log.DEBUG)) {\r\n                _log.debug(\"Inbound settings for \" + client.toBase64() + \": \" + in);\r\n                _log.debug(\"Outbound settings for \" + client.toBase64() + \": \" + out);\r\n            }\r\n            _context.tunnelManager().setInboundSettings(client, in);\r\n            _context.tunnelManager().setOutboundSettings(client, out);\r\n        }\r\n        updated++;\r\n        saveRequired = true;\r\n        index++;\r\n    }\r\n    if (updated > 0)\r\n        addFormNotice(_t(\"Updated settings for all pools.\"));\r\n    if (saveRequired) {\r\n        boolean saved = _context.router().saveConfig(changes, null);\r\n        if (saved)\r\n            addFormNotice(_t(\"Exploratory tunnel configuration saved successfully.\"));\r\n        else\r\n            addFormError(_t(\"Error saving the configuration (applied but not saved) - please see the error logs.\"));\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.core.RrdDb.getArcIndex",
	"Comment": "returns index of archive object with the given consolidation function and the number\tof steps. exception is thrown if such archive could not be found.",
	"Method": "int getArcIndex(String consolFun,int steps){\r\n    for (int i = 0; i < archives.length; i++) {\r\n        if (archives[i].getConsolFun().equals(consolFun) && archives[i].getSteps() == steps) {\r\n            return i;\r\n        }\r\n    }\r\n    throw new RrdException(\"Could not find archive \" + consolFun + \"/\" + steps);\r\n}"
}, {
	"Path": "net.i2p.stat.Frequency.eventOccurred",
	"Comment": "take note that a new event occurred, recalculating all the averages and frequencies",
	"Method": "void eventOccurred(){\r\n    recalculate(true);\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.util.Properties.isDismissedIgnoredEditingNotification",
	"Comment": "checks if user already dismissed notification about editing ignored file.",
	"Method": "boolean isDismissedIgnoredEditingNotification(Project project,VirtualFile file){\r\n    final PropertiesComponent props = properties(project);\r\n    String[] values = props.getValues(DISMISSED_IGNORED_EDITING_NOTIFICATION);\r\n    return ContainerUtil.newHashSet(values != null ? values : new String[0]).contains(file.getCanonicalPath());\r\n}"
}, {
	"Path": "io.helidon.security.providers.OutboundTarget.getCustomObject",
	"Comment": "allows a programmatic client to send custom security provider specific parameters to the provider.definition of such properties must be documented on the provider.the security is not aware of such properties.",
	"Method": "Optional<? extends T> getCustomObject(Class<? extends T> clazz){\r\n    return customObjects.getInstance(clazz);\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterAddress.getExpiration",
	"Comment": "retrieve the date after which the address should not be used.if thisis null, then the address never expires.as of 0.9.3, expiration must be all zeros as it is ignored onreadin and the signature will fail.restored as of 0.9.12.",
	"Method": "Date getExpiration(){\r\n    if (_expiration > 0)\r\n        return new Date(_expiration);\r\n    return null;\r\n}"
}, {
	"Path": "com.spotify.heroic.HeroicCore.loadModules",
	"Comment": "load modules from the specified modules configuration file and wire up those components withearly injection.",
	"Method": "void loadModules(CoreLoadingComponent loading){\r\n    final List<HeroicModule> modules = new ArrayList();\r\n    for (final HeroicModule builtin : BUILTIN_MODULES) {\r\n        modules.add(builtin);\r\n    }\r\n    modules.addAll(this.modules);\r\n    for (final HeroicModule module : modules) {\r\n        module.setup(loading).run();\r\n    }\r\n    log.info(\"Loaded {} module(s)\", modules.size());\r\n}"
}, {
	"Path": "org.jrobin.graph.RrdGraphDef.setAltYGrid",
	"Comment": "places y grid dynamically based on graph y range. algorithm ensuresthat you always have grid, that there are enough but not too manygrid lines and the grid is metric. that is grid lines are placedevery 1, 2, 5 or 10 units.",
	"Method": "void setAltYGrid(boolean altYGrid){\r\n    this.altYGrid = altYGrid;\r\n}"
}, {
	"Path": "com.spotify.heroic.metric.bigtable.api.RowFilter.onlyLatestCell",
	"Comment": "build a filter that only matches the latest cell in each column.",
	"Method": "RowFilter onlyLatestCell(){\r\n    return new OnlyLatestCell();\r\n}"
}, {
	"Path": "net.i2p.stat.Rate.load",
	"Comment": "load this rate from the properties, taking data from the data points underneath the given prefix.",
	"Method": "void load(Properties props,String prefix,boolean treatAsCurrent){\r\n    _period = PersistenceHelper.getInt(props, prefix, \".period\");\r\n    _creationDate = PersistenceHelper.getLong(props, prefix, \".creationDate\");\r\n    _lastCoalesceDate = PersistenceHelper.getLong(props, prefix, \".lastCoalesceDate\");\r\n    _currentTotalValue = (float) PersistenceHelper.getDouble(props, prefix, \".currentTotalValue\");\r\n    _currentEventCount = PersistenceHelper.getInt(props, prefix, \".currentEventCount\");\r\n    _currentTotalEventTime = (int) PersistenceHelper.getLong(props, prefix, \".currentTotalEventTime\");\r\n    _lastTotalValue = (float) PersistenceHelper.getDouble(props, prefix, \".lastTotalValue\");\r\n    _lastEventCount = PersistenceHelper.getInt(props, prefix, \".lastEventCount\");\r\n    _lastTotalEventTime = (int) PersistenceHelper.getLong(props, prefix, \".lastTotalEventTime\");\r\n    _extremeTotalValue = (float) PersistenceHelper.getDouble(props, prefix, \".extremeTotalValue\");\r\n    _extremeEventCount = PersistenceHelper.getInt(props, prefix, \".extremeEventCount\");\r\n    _extremeTotalEventTime = (int) PersistenceHelper.getLong(props, prefix, \".extremeTotalEventTime\");\r\n    _lifetimeTotalValue = (float) PersistenceHelper.getDouble(props, prefix, \".lifetimeTotalValue\");\r\n    _lifetimeEventCount = PersistenceHelper.getLong(props, prefix, \".lifetimeEventCount\");\r\n    _lifetimeTotalEventTime = PersistenceHelper.getLong(props, prefix, \".lifetimeTotalEventTime\");\r\n    if (treatAsCurrent)\r\n        _lastCoalesceDate = now();\r\n    if (_period <= 0)\r\n        throw new IllegalArgumentException(\"Period for \" + prefix + \" is invalid\");\r\n    coalesce();\r\n}"
}, {
	"Path": "org.klomp.snark.Peer.setChoking",
	"Comment": "sets whether or not we are choking the peer. defaults totrue. when choke is false and the peer requests some pieces weupload them, otherwise requests of this peer are ignored.",
	"Method": "void setChoking(boolean choke){\r\n    PeerState s = state;\r\n    if (s != null)\r\n        s.setChoking(choke);\r\n}"
}, {
	"Path": "com.maxmind.geoip.LookupService.bytesToLong",
	"Comment": "returns the long version of an ip address given an inetaddress object.",
	"Method": "long bytesToLong(byte[] address){\r\n    long ipnum = 0;\r\n    for (int i = 0; i < 4; ++i) {\r\n        long y = address[i];\r\n        if (y < 0) {\r\n            y += 256;\r\n        }\r\n        ipnum += y << ((3 - i) * 8);\r\n    }\r\n    return ipnum;\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.DataSource.getMinimum",
	"Comment": "returns the minimum value input to this data source can have.",
	"Method": "double getMinimum(){\r\n    return minimum;\r\n}"
}, {
	"Path": "com.netflix.hollow.core.index.FieldPath.findValue",
	"Comment": "recursively find a value following the path. if the path contains a collection, then the first value is picked.",
	"Method": "Object findValue(int ordinal){\r\n    return getValue(ordinal, type, 0);\r\n}"
}, {
	"Path": "org.klomp.snark.SnarkManager.locked_writeMetaInfo",
	"Comment": "write the metainfo to the file, caller must hold the snarks lockto prevent interference from the dirmonitor.",
	"Method": "void locked_writeMetaInfo(MetaInfo metainfo,String filename,boolean areFilesPublic){\r\n    File file = new File(filename);\r\n    if (file.exists())\r\n        throw new IOException(\"Cannot overwrite an existing .torrent file: \" + file.getPath());\r\n    OutputStream out = null;\r\n    try {\r\n        if (areFilesPublic)\r\n            out = new FileOutputStream(filename);\r\n        else\r\n            out = new SecureFileOutputStream(filename);\r\n        out.write(metainfo.getTorrentData());\r\n    } catch (IOException ioe) {\r\n        file.delete();\r\n        throw ioe;\r\n    } finally {\r\n        try {\r\n            if (out != null)\r\n                out.close();\r\n        } catch (IOException ioe) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.stat.StatManager.createFrequencyStat",
	"Comment": "create a new statistic to monitor the frequency of some event.the stat is only created if the stat.full property is true or we are not in the router context.",
	"Method": "void createFrequencyStat(String name,String description,String group,long periods){\r\n    if (ignoreStat(name))\r\n        return;\r\n    createRequiredFrequencyStat(name, description, group, periods);\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.ExpireRoutersJob.expireKeys",
	"Comment": "run through all of the known peers and pick ones that have really oldrouterinfo publish dates, excluding ones that we are connected to,so that they can be failed",
	"Method": "int expireKeys(){\r\n    Set<Hash> keys = _facade.getAllRouters();\r\n    keys.remove(getContext().routerHash());\r\n    if (keys.size() < 150)\r\n        return 0;\r\n    int removed = 0;\r\n    for (Hash key : keys) {\r\n        if (!getContext().commSystem().isEstablished(key)) {\r\n            DatabaseEntry e = _facade.lookupLocallyWithoutValidation(key);\r\n            if (e != null && e.getType() == DatabaseEntry.KEY_TYPE_ROUTERINFO) {\r\n                try {\r\n                    if (_facade.validate((RouterInfo) e) != null) {\r\n                        _facade.dropAfterLookupFailed(key);\r\n                        removed++;\r\n                    }\r\n                } catch (IllegalArgumentException iae) {\r\n                    _facade.dropAfterLookupFailed(key);\r\n                    removed++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return removed;\r\n}"
}, {
	"Path": "org.klomp.snark.bencode.BEValue.getList",
	"Comment": "returns this bevalue as a list of bevalues. this operation onlysucceeds when the bevalue is actually a list, otherwise it willthrow a invalidbencodingexception.",
	"Method": "List<BEValue> getList(){\r\n    try {\r\n        return (List<BEValue>) value;\r\n    } catch (ClassCastException cce) {\r\n        throw new InvalidBEncodingException(cce.toString());\r\n    }\r\n}"
}, {
	"Path": "net.i2p.client.impl.I2PSessionImpl.getPrefix",
	"Comment": "try hard to make a decent identifier as this will appear in error logs",
	"Method": "String getPrefix(){\r\n    StringBuilder buf = new StringBuilder();\r\n    buf.append('[');\r\n    buf.append(_state.toString()).append(' ');\r\n    String s = _options.getProperty(\"inbound.nickname\");\r\n    if (s != null)\r\n        buf.append(s);\r\n    else\r\n        buf.append(getClass().getSimpleName());\r\n    SessionId id = _sessionId;\r\n    if (id != null)\r\n        buf.append(\" #\").append(id.getSessionId());\r\n    buf.append(\"]: \");\r\n    return buf.toString();\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.TunnelController.acquire",
	"Comment": "note the fact that we are using some sessions, so that they dont getclosed by some other tunnels",
	"Method": "void acquire(){\r\n    List<I2PSession> sessions = _tunnel.getSessions();\r\n    if (!sessions.isEmpty()) {\r\n        for (int i = 0; i < sessions.size(); i++) {\r\n            I2PSession session = sessions.get(i);\r\n            if (_log.shouldLog(Log.INFO))\r\n                _log.info(\"Acquiring session \" + session);\r\n            TunnelControllerGroup group = TunnelControllerGroup.getInstance();\r\n            if (group != null)\r\n                group.acquire(this, session);\r\n        }\r\n        _sessions = sessions;\r\n    } else {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"No sessions to acquire? for \" + getName());\r\n    }\r\n}"
}, {
	"Path": "net.i2p.client.impl.I2PSessionImpl.readError",
	"Comment": "the i2cpmessageeventlistener callback.recieve notifiation of an error reading the i2cp stream.",
	"Method": "void readError(I2CPMessageReader reader,Exception error){\r\n    propogateError(\"There was an error reading data\", error);\r\n    disconnect();\r\n}"
}, {
	"Path": "com.southernstorm.noise.protocol.HandshakeState.getAction",
	"Comment": "gets the next action that the application should perform for\tthe handshake part of the protocol.",
	"Method": "int getAction(){\r\n    return action;\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.ProfileManagerImpl.dbStoreFailed",
	"Comment": "note that we were unable to confirm a successful send of db data tothe peer, at least not within our timeout periodthis will force creation of db stats",
	"Method": "void dbStoreFailed(Hash peer){\r\n    PeerProfile data = getProfile(peer);\r\n    if (!data.getIsExpandedDB())\r\n        data.expandDBProfile();\r\n    DBHistory hist = data.getDBHistory();\r\n    hist.storeFailed();\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.lang.IgnoreCommenter.getBlockCommentSuffix",
	"Comment": "returns the string which marks the end of a block comment in the language,or null if the language does not support block comments.",
	"Method": "String getBlockCommentSuffix(){\r\n    return null;\r\n}"
}, {
	"Path": "org.jrobin.core.Archive.getArcStep",
	"Comment": "returns archive time step in seconds. archive step is equal to rrd step\tmultiplied with the number of archive steps.",
	"Method": "long getArcStep(){\r\n    final long step = parentDb.getHeader().getStep();\r\n    return step * steps.get();\r\n}"
}, {
	"Path": "io.helidon.security.util.TokenHandler.forHeader",
	"Comment": "a shortcut method to build a token handler that does not modify the token content.",
	"Method": "TokenHandler forHeader(String header){\r\n    return builder().tokenHeader(header).build();\r\n}"
}, {
	"Path": "net.i2p.router.web.helpers.ConfigStatsHelper.hasMoreStats",
	"Comment": "move the cursor to the next known stat, returning true if a validstat is available.",
	"Method": "boolean hasMoreStats(){\r\n    if (_stats.isEmpty())\r\n        return false;\r\n    _currentIsGraphed = false;\r\n    _currentStatName = _stats.remove(0);\r\n    RateStat rs = _context.statManager().getRate(_currentStatName);\r\n    if (rs != null) {\r\n        _currentStatDescription = rs.getDescription();\r\n        if (_currentGroup == null)\r\n            _currentIsFirstInGroup = true;\r\n        else if (!rs.getGroupName().equals(_currentGroup))\r\n            _currentIsFirstInGroup = true;\r\n        else\r\n            _currentIsFirstInGroup = false;\r\n        _currentGroup = rs.getGroupName();\r\n        long period = rs.getPeriods()[0];\r\n        if (period <= 10 * 60 * 1000) {\r\n            Rate r = rs.getRate(period);\r\n            _currentCanBeGraphed = r != null;\r\n            if (_currentCanBeGraphed) {\r\n                _currentGraphName = _currentStatName + \".\" + period;\r\n                _currentIsGraphed = _graphs.contains(_currentGraphName);\r\n            }\r\n        } else {\r\n            _currentCanBeGraphed = false;\r\n        }\r\n    } else {\r\n        FrequencyStat fs = _context.statManager().getFrequency(_currentStatName);\r\n        if (fs != null) {\r\n            _currentStatDescription = fs.getDescription();\r\n            if (_currentGroup == null)\r\n                _currentIsFirstInGroup = true;\r\n            else if (!fs.getGroupName().equals(_currentGroup))\r\n                _currentIsFirstInGroup = true;\r\n            else\r\n                _currentIsFirstInGroup = false;\r\n            _currentGroup = fs.getGroupName();\r\n            _currentCanBeGraphed = false;\r\n        } else {\r\n            if (_log.shouldLog(Log.ERROR))\r\n                _log.error(\"Stat does not exist?!  [\" + _currentStatName + \"]\");\r\n            return false;\r\n        }\r\n    }\r\n    if (_filters.contains(\"*\") || _filters.contains(_currentStatName))\r\n        _currentIsLogged = true;\r\n    else\r\n        _currentIsLogged = false;\r\n    return true;\r\n}"
}, {
	"Path": "org.klomp.snark.Peer.isChoked",
	"Comment": "whether or not the peer choked us. returns true when not connected.",
	"Method": "boolean isChoked(){\r\n    PeerState s = state;\r\n    return (s == null) || s.choked;\r\n}"
}, {
	"Path": "com.spotify.heroic.consumer.schemas.Spotify100.objectMapper",
	"Comment": "setup the objectmapper necessary to serialize types in this protocol.",
	"Method": "ObjectMapper objectMapper(){\r\n    ObjectMapper mapper = new ObjectMapper();\r\n    mapper.registerModule(new Jdk8Module().configureAbsentsAsNulls(true));\r\n    return mapper;\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.TunnelControllerGroup.release",
	"Comment": "note the fact that the controller is no longer using the session, and ifno other controllers are using it, destroy the session.",
	"Method": "void release(TunnelController controller,I2PSession session){\r\n    boolean shouldClose = false;\r\n    synchronized (_sessions) {\r\n        Set<TunnelController> owners = _sessions.get(session);\r\n        if (owners != null) {\r\n            owners.remove(controller);\r\n            if (owners.isEmpty()) {\r\n                if (_log.shouldLog(Log.INFO))\r\n                    _log.info(\"After releasing session \" + session + \" by \" + controller + \", no more owners remain\");\r\n                shouldClose = true;\r\n                _sessions.remove(session);\r\n            } else {\r\n                if (_log.shouldLog(Log.INFO))\r\n                    _log.info(\"After releasing session \" + session + \" by \" + controller + \", \" + owners.size() + \" owners remain\");\r\n                shouldClose = false;\r\n            }\r\n        } else {\r\n            if (_log.shouldLog(Log.WARN))\r\n                _log.warn(\"After releasing session \" + session + \" by \" + controller + \", no owners were even known?!\");\r\n            shouldClose = true;\r\n        }\r\n    }\r\n    if (shouldClose) {\r\n        try {\r\n            session.destroySession();\r\n            if (_log.shouldLog(Log.INFO))\r\n                _log.info(\"Session destroyed: \" + session);\r\n        } catch (I2PSessionException ise) {\r\n            _log.error(\"Error closing the client session\", ise);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.helidon.security.util.TokenHandler.addHeader",
	"Comment": "add the token as a new header value.creates the header if not present, adds header value to list of values if present.",
	"Method": "void addHeader(Map<String, List<String>> headers,String token){\r\n    String tokenValue = headerCreator.apply(token);\r\n    List<String> values = headers.get(tokenHeader);\r\n    if (null == values) {\r\n        values = singletonList(tokenValue);\r\n    } else {\r\n        values = new ArrayList(values);\r\n        values.add(tokenValue);\r\n    }\r\n    headers.put(tokenHeader, values);\r\n}"
}, {
	"Path": "net.i2p.stat.StatManager.ignoreStat",
	"Comment": "save memory by not creating stats unless they are required for router operation.for backward compatibility of any external clients, always returns false if not in router context.",
	"Method": "boolean ignoreStat(String statName){\r\n    return _context.isRouterContext() && !_context.getBooleanProperty(PROP_STAT_FULL);\r\n}"
}, {
	"Path": "net.i2p.router.startup.PortableWorkingDir.getWorkingDir",
	"Comment": "only call this once on router invocation.caller should store the return value for future reference.",
	"Method": "String getWorkingDir(Properties envProps){\r\n    String dir = null;\r\n    if (envProps != null)\r\n        dir = envProps.getProperty(PROP_WORKING_DIR);\r\n    if (dir == null)\r\n        dir = System.getProperty(PROP_WORKING_DIR);\r\n    String cwd = null;\r\n    if (envProps != null)\r\n        cwd = envProps.getProperty(PROP_BASE_DIR);\r\n    if (cwd == null) {\r\n        cwd = System.getProperty(PROP_BASE_DIR);\r\n        if (cwd == null)\r\n            cwd = System.getProperty(\"user.dir\");\r\n    }\r\n    File dirf = new SecureDirectory(dir);\r\n    File oldDirf = new File(cwd);\r\n    File test = new File(oldDirf, \"hosts.txt\");\r\n    if (!test.exists()) {\r\n        setupSystemOut(cwd);\r\n        System.err.println(\"ERROR - Cannot find I2P installation in \" + cwd + \" - Will probably be just a router with no apps or console at all!\");\r\n        return cwd;\r\n    }\r\n    if (!dirf.exists() && !dirf.mkdir()) {\r\n        setupSystemOut(null);\r\n        System.err.println(\"Wanted to use \" + dirf.toString() + \" for a working directory but could not create it\");\r\n        return cwd;\r\n    }\r\n    setupSystemOut(dirf.getAbsolutePath());\r\n    return dirf.getAbsolutePath();\r\n}"
}, {
	"Path": "net.i2p.util.Clock.getTimestamper",
	"Comment": "this is a dummy, see routerclock and routertimestamper for the real thing",
	"Method": "Timestamper getTimestamper(){\r\n    return new Timestamper();\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.ui.GeneratorDialog.createTreeActionsToolbarPanel",
	"Comment": "creates tree toolbar panel with actions for working with templates tree.",
	"Method": "ActionToolbar createTreeActionsToolbarPanel(JComponent target){\r\n    final CommonActionsManager actionManager = CommonActionsManager.getInstance();\r\n    DefaultActionGroup actions = new DefaultActionGroup();\r\n    actions.add(actionManager.createExpandAllAction(treeExpander, tree));\r\n    actions.add(actionManager.createCollapseAllAction(treeExpander, tree));\r\n    actions.add(new AnAction(IgnoreBundle.message(\"dialog.generator.unselectAll\"), null, AllIcons.Actions.Unselectall) {\r\n        @Override\r\n        public void update(@NotNull AnActionEvent e) {\r\n            e.getPresentation().setEnabled(!checked.isEmpty());\r\n        }\r\n        @Override\r\n        public void actionPerformed(@NotNull AnActionEvent e) {\r\n            checked.clear();\r\n            filterTree(profileFilter.getTextEditor().getText());\r\n        }\r\n    });\r\n    actions.add(new AnAction(IgnoreBundle.message(\"dialog.generator.star\"), null, STAR) {\r\n        @Override\r\n        public void update(@NotNull AnActionEvent e) {\r\n            final TemplateTreeNode node = getCurrentNode();\r\n            boolean disabled = node == null || USER.equals(node.getContainer()) || !node.isLeaf();\r\n            boolean unstar = node != null && STARRED.equals(node.getContainer());\r\n            final Icon icon = disabled ? IconLoader.getDisabledIcon(STAR) : (unstar ? IconLoader.getTransparentIcon(STAR) : STAR);\r\n            final String text = IgnoreBundle.message(unstar ? \"dialog.generator.unstar\" : \"dialog.generator.star\");\r\n            final Presentation presentation = e.getPresentation();\r\n            presentation.setEnabled(!disabled);\r\n            presentation.setIcon(icon);\r\n            presentation.setText(text);\r\n        }\r\n        @Override\r\n        public void actionPerformed(@NotNull AnActionEvent e) {\r\n            final TemplateTreeNode node = getCurrentNode();\r\n            if (node == null) {\r\n                return;\r\n            }\r\n            final Resources.Template template = node.getTemplate();\r\n            if (template != null) {\r\n                boolean isStarred = !template.isStarred();\r\n                template.setStarred(isStarred);\r\n                refreshTree();\r\n                if (isStarred) {\r\n                    starred.add(template.getName());\r\n                } else {\r\n                    starred.remove(template.getName());\r\n                }\r\n                settings.setStarredTemplates(ContainerUtil.newArrayList(starred));\r\n            }\r\n        }\r\n        @Nullable\r\n        private TemplateTreeNode getCurrentNode() {\r\n            final TreePath path = getCurrentPath();\r\n            return path == null ? null : (TemplateTreeNode) path.getLastPathComponent();\r\n        }\r\n    });\r\n    final ActionToolbar actionToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, actions, true);\r\n    actionToolbar.setTargetComponent(target);\r\n    return actionToolbar;\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.ui.GeneratorDialog.createTreeActionsToolbarPanel",
	"Comment": "creates tree toolbar panel with actions for working with templates tree.",
	"Method": "ActionToolbar createTreeActionsToolbarPanel(JComponent target){\r\n    e.getPresentation().setEnabled(!checked.isEmpty());\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.ui.GeneratorDialog.createTreeActionsToolbarPanel",
	"Comment": "creates tree toolbar panel with actions for working with templates tree.",
	"Method": "ActionToolbar createTreeActionsToolbarPanel(JComponent target){\r\n    checked.clear();\r\n    filterTree(profileFilter.getTextEditor().getText());\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.ui.GeneratorDialog.createTreeActionsToolbarPanel",
	"Comment": "creates tree toolbar panel with actions for working with templates tree.",
	"Method": "ActionToolbar createTreeActionsToolbarPanel(JComponent target){\r\n    final TemplateTreeNode node = getCurrentNode();\r\n    boolean disabled = node == null || USER.equals(node.getContainer()) || !node.isLeaf();\r\n    boolean unstar = node != null && STARRED.equals(node.getContainer());\r\n    final Icon icon = disabled ? IconLoader.getDisabledIcon(STAR) : (unstar ? IconLoader.getTransparentIcon(STAR) : STAR);\r\n    final String text = IgnoreBundle.message(unstar ? \"dialog.generator.unstar\" : \"dialog.generator.star\");\r\n    final Presentation presentation = e.getPresentation();\r\n    presentation.setEnabled(!disabled);\r\n    presentation.setIcon(icon);\r\n    presentation.setText(text);\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.ui.GeneratorDialog.createTreeActionsToolbarPanel",
	"Comment": "creates tree toolbar panel with actions for working with templates tree.",
	"Method": "ActionToolbar createTreeActionsToolbarPanel(JComponent target){\r\n    final TemplateTreeNode node = getCurrentNode();\r\n    if (node == null) {\r\n        return;\r\n    }\r\n    final Resources.Template template = node.getTemplate();\r\n    if (template != null) {\r\n        boolean isStarred = !template.isStarred();\r\n        template.setStarred(isStarred);\r\n        refreshTree();\r\n        if (isStarred) {\r\n            starred.add(template.getName());\r\n        } else {\r\n            starred.remove(template.getName());\r\n        }\r\n        settings.setStarredTemplates(ContainerUtil.newArrayList(starred));\r\n    }\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.ui.GeneratorDialog.createTreeActionsToolbarPanel",
	"Comment": "creates tree toolbar panel with actions for working with templates tree.",
	"Method": "ActionToolbar createTreeActionsToolbarPanel(JComponent target){\r\n    final TreePath path = getCurrentPath();\r\n    return path == null ? null : (TemplateTreeNode) path.getLastPathComponent();\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.settings.IgnoreSettingsConfigurable.isModified",
	"Comment": "checks if the settings in the user interface component were modified by the user and need to be saved.",
	"Method": "boolean isModified(){\r\n    return settingsPanel == null || !Comparing.equal(settings.isMissingGitignore(), settingsPanel.isMissingGitignore()) || !Utils.equalLists(settings.getUserTemplates(), settingsPanel.getUserTemplates()) || !Comparing.equal(settings.isIgnoredFileStatus(), settingsPanel.isIgnoredFileStatus()) || !Comparing.equal(settings.isOuterIgnoreRules(), settingsPanel.isOuterIgnoreRules()) || !Comparing.equal(settings.isInsertAtCursor(), settingsPanel.isInsertAtCursor()) || !Comparing.equal(settings.isAddUnversionedFiles(), settingsPanel.isAddUnversionedFiles()) || !Comparing.equal(settings.isUnignoreActions(), settingsPanel.isUnignoreActions()) || !Comparing.equal(settings.isInformTrackedIgnored(), settingsPanel.isInformTrackedIgnored()) || !Comparing.equal(settings.isNotifyIgnoredEditing(), settingsPanel.isNotifyIgnoredEditing()) || !settingsPanel.getLanguagesSettings().equalSettings(settings.getLanguagesSettings());\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.lang.IgnoreParserDefinition.getFileNodeType",
	"Comment": "returns the element type of the node describing a file in the specified language.",
	"Method": "IFileElementType getFileNodeType(){\r\n    return FILE;\r\n}"
}, {
	"Path": "net.i2p.router.RouterContext.messageRegistry",
	"Comment": "the registry is used by outbound messages to wait for replies.",
	"Method": "OutboundMessageRegistry messageRegistry(){\r\n    return _messageRegistry;\r\n}"
}, {
	"Path": "com.netflix.hollow.api.producer.ListenerSupport.listeners",
	"Comment": "copies the collection of listeners so they can be iterated on without changing.from the returned copy events may be fired.any addition or removal of listeners will take effect on the next cycle.",
	"Method": "Listeners listeners(){\r\n    return new Listeners(eventListeners.toArray(new HollowProducerEventListener[0]));\r\n}"
}, {
	"Path": "com.spotify.heroic.aggregation.AggregationInstance.requiredTags",
	"Comment": "get a set of required tags.this is used to elide a set of required tags that needs to be forwarded for a certainaggregation.",
	"Method": "Set<String> requiredTags(){\r\n    return ImmutableSet.of();\r\n}"
}, {
	"Path": "net.i2p.router.RouterContext.profileOrganizer",
	"Comment": "organize the peers we know about into various tiers, profiling theirperformance and sorting them accordingly.",
	"Method": "ProfileOrganizer profileOrganizer(){\r\n    return _profileOrganizer;\r\n}"
}, {
	"Path": "net.i2p.data.i2np.BuildRequestRecord.readNextTunnelId",
	"Comment": "what tunnel id the next hop receives messages on.if this is the outbound tunnel endpoint,this specifies the tunnel id to which the reply should be sent.",
	"Method": "long readNextTunnelId(){\r\n    return DataHelper.fromLong(_data, OFF_SEND_TUNNEL, 4);\r\n}"
}, {
	"Path": "org.klomp.snark.PartialPiece.compareTo",
	"Comment": "highest priority first, then rarest first, then highest downloaded first",
	"Method": "int compareTo(PartialPiece opp){\r\n    int d = this.piece.compareTo(opp.piece);\r\n    if (d != 0)\r\n        return d;\r\n    return opp.off - this.off;\r\n}"
}, {
	"Path": "net.i2p.router.client.ClientMessageEventListener.messageReceived",
	"Comment": "handle an incoming message and dispatch it to the appropriate handler",
	"Method": "void messageReceived(I2CPMessageReader reader,I2CPMessage message){\r\n    if (_runner.isDead()) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Received but runner dead: \\n\" + message);\r\n        return;\r\n    }\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Message received: \\n\" + message);\r\n    int type = message.getType();\r\n    if (!_authorized) {\r\n        boolean strict = _context.getBooleanPropertyDefaultTrue(PROP_AUTH_STRICT);\r\n        if ((strict && type != GetDateMessage.MESSAGE_TYPE) || (type != CreateSessionMessage.MESSAGE_TYPE && type != GetDateMessage.MESSAGE_TYPE && type != DestLookupMessage.MESSAGE_TYPE && type != GetBandwidthLimitsMessage.MESSAGE_TYPE)) {\r\n            _log.error(\"Received message type \" + type + \" without required authentication\");\r\n            _runner.disconnectClient(\"Authorization required\");\r\n            return;\r\n        }\r\n    }\r\n    switch(message.getType()) {\r\n        case GetDateMessage.MESSAGE_TYPE:\r\n            handleGetDate((GetDateMessage) message);\r\n            break;\r\n        case SetDateMessage.MESSAGE_TYPE:\r\n            handleSetDate((SetDateMessage) message);\r\n            break;\r\n        case CreateSessionMessage.MESSAGE_TYPE:\r\n            handleCreateSession((CreateSessionMessage) message);\r\n            break;\r\n        case SendMessageMessage.MESSAGE_TYPE:\r\n            handleSendMessage((SendMessageMessage) message);\r\n            break;\r\n        case SendMessageExpiresMessage.MESSAGE_TYPE:\r\n            handleSendMessage((SendMessageExpiresMessage) message);\r\n            break;\r\n        case ReceiveMessageBeginMessage.MESSAGE_TYPE:\r\n            handleReceiveBegin((ReceiveMessageBeginMessage) message);\r\n            break;\r\n        case ReceiveMessageEndMessage.MESSAGE_TYPE:\r\n            handleReceiveEnd((ReceiveMessageEndMessage) message);\r\n            break;\r\n        case CreateLeaseSetMessage.MESSAGE_TYPE:\r\n        case CreateLeaseSet2Message.MESSAGE_TYPE:\r\n            handleCreateLeaseSet((CreateLeaseSetMessage) message);\r\n            break;\r\n        case DestroySessionMessage.MESSAGE_TYPE:\r\n            handleDestroySession((DestroySessionMessage) message);\r\n            break;\r\n        case DestLookupMessage.MESSAGE_TYPE:\r\n            handleDestLookup((DestLookupMessage) message);\r\n            break;\r\n        case HostLookupMessage.MESSAGE_TYPE:\r\n            handleHostLookup((HostLookupMessage) message);\r\n            break;\r\n        case ReconfigureSessionMessage.MESSAGE_TYPE:\r\n            handleReconfigureSession((ReconfigureSessionMessage) message);\r\n            break;\r\n        case GetBandwidthLimitsMessage.MESSAGE_TYPE:\r\n            handleGetBWLimits((GetBandwidthLimitsMessage) message);\r\n            break;\r\n        default:\r\n            if (_log.shouldLog(Log.ERROR))\r\n                _log.error(\"Unhandled I2CP type received: \" + message.getType());\r\n    }\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.socks.I2PSOCKSIRCTunnel.clientConnectionRun",
	"Comment": "same as in i2psockstunnel, but run the filters from i2ptunnelircclient instead of i2ptunnelrunner",
	"Method": "void clientConnectionRun(Socket s){\r\n    I2PSocket destSock = null;\r\n    try {\r\n        try {\r\n            s.setSoTimeout(INITIAL_SO_TIMEOUT);\r\n        } catch (SocketException ioe) {\r\n        }\r\n        SOCKSServer serv = SOCKSServerFactory.createSOCKSServer(_context, s, getTunnel().getClientOptions());\r\n        Socket clientSock = serv.getClientSocket();\r\n        try {\r\n            s.setSoTimeout(0);\r\n        } catch (SocketException ioe) {\r\n        }\r\n        destSock = serv.getDestinationI2PSocket(this);\r\n        StringBuffer expectedPong = new StringBuffer();\r\n        int id = __clientId.incrementAndGet();\r\n        Thread in = new I2PAppThread(new IrcInboundFilter(clientSock, destSock, expectedPong, _log), \"SOCKS IRC Client \" + id + \" in\", true);\r\n        in.start();\r\n        Runnable out = new IrcOutboundFilter(clientSock, destSock, expectedPong, _log);\r\n        out.run();\r\n    } catch (SOCKSException e) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Error from SOCKS connection\", e);\r\n    } finally {\r\n        closeSocket(s);\r\n        if (destSock != null)\r\n            try {\r\n                destSock.close();\r\n            } catch (IOException ioe) {\r\n            }\r\n    }\r\n}"
}, {
	"Path": "io.helidon.webserver.netty.ReferenceHoldingQueue.shutdown",
	"Comment": "shutdown this reference queue. once shut down, all the managed references are forcibly clearedand no more items are accepted to be managed by this queue.",
	"Method": "void shutdown(){\r\n    down = true;\r\n    for (ReleasableReference<T> reference : set) {\r\n        reference.release();\r\n    }\r\n}"
}, {
	"Path": "com.netflix.hollow.tools.diff.specific.HollowSpecificDiff.setElementMatchPaths",
	"Comment": "set the paths for which we will inspect differences across the two states",
	"Method": "void setElementMatchPaths(String paths){\r\n    resetResults();\r\n    this.elementPaths = paths;\r\n    this.elementKeyPaths = null;\r\n    this.elementNonKeyPaths = null;\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.FragmentedMessage.getExpireEvent",
	"Comment": "used in the fragment handler so we can cancel the expire event on success",
	"Method": "SimpleTimer2.TimedEvent getExpireEvent(){\r\n    return _expireEvent;\r\n}"
}, {
	"Path": "net.i2p.router.message.GarlicConfig.setRecipientPublicKey",
	"Comment": "public key of the router to receive and process this clove.this is usefulfor garlic routed messages encrypted to the router at the end of a tunnel,as their routeridentity is not known, but a publickey they handle is exposedvia the leaseset",
	"Method": "void setRecipientPublicKey(PublicKey recipientPublicKey){\r\n    _recipientPublicKey = recipientPublicKey;\r\n}"
}, {
	"Path": "net.i2p.data.Certificate.create",
	"Comment": "if null, p256 key, or ed25519 key cert, return immutable static instance, else create new",
	"Method": "Certificate create(byte[] data,int off,Certificate create,InputStream in){\r\n    int type = in.read();\r\n    int length = (int) DataHelper.readLong(in, 2);\r\n    if (type == 0 && length == 0)\r\n        return NULL_CERT;\r\n    if (length == 0)\r\n        return new Certificate(type, null);\r\n    byte[] payload = new byte[length];\r\n    int read = DataHelper.read(in, payload);\r\n    if (read != length)\r\n        throw new DataFormatException(\"Not enough bytes for the payload (read: \" + read + \" length: \" + length + ')');\r\n    if (type == CERTIFICATE_TYPE_KEY) {\r\n        if (length == 4) {\r\n            if (Arrays.equals(payload, KeyCertificate.Ed25519_PAYLOAD))\r\n                return KeyCertificate.ELG_Ed25519_CERT;\r\n            if (Arrays.equals(payload, KeyCertificate.ECDSA256_PAYLOAD))\r\n                return KeyCertificate.ELG_ECDSA256_CERT;\r\n        }\r\n        return new KeyCertificate(payload);\r\n    }\r\n    return new Certificate(type, payload);\r\n}"
}, {
	"Path": "net.i2p.router.web.helpers.ConfigNetHelper.getConfiguredUdpPort",
	"Comment": "this should always be the actual internal ssu port, as udptransport udpates the config when it changes.",
	"Method": "String getConfiguredUdpPort(){\r\n    return _context.getProperty(UDPTransport.PROP_INTERNAL_PORT, \"unset\");\r\n}"
}, {
	"Path": "net.i2p.sam.client.SAMEventHandler.waitForSessionAddReply",
	"Comment": "wait for the session to be added, returning true if everything went ok",
	"Method": "boolean waitForSessionAddReply(){\r\n    while (true) {\r\n        try {\r\n            synchronized (_sessionCreateLock) {\r\n                if (_sessionAddOk == null)\r\n                    _sessionCreateLock.wait();\r\n                else\r\n                    return _sessionAddOk.booleanValue();\r\n            }\r\n        } catch (InterruptedException ie) {\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.InboundMessageFragments.receiveMessages",
	"Comment": "pull out all the data fragments and shove them into inboundmessagestates.along the way, if any state expires, or a full message arrives, move itappropriately.",
	"Method": "int receiveMessages(PeerState from,UDPPacketReader.DataReader data){\r\n    int fragments = data.readFragmentCount();\r\n    if (fragments <= 0)\r\n        return fragments;\r\n    Hash fromPeer = from.getRemotePeer();\r\n    Map<Long, InboundMessageState> messages = from.getInboundMessages();\r\n    for (int i = 0; i < fragments; i++) {\r\n        long mid = data.readMessageId(i);\r\n        Long messageId = Long.valueOf(mid);\r\n        if (_recentlyCompletedMessages.isKnown(mid)) {\r\n            if (data.readMessageFragmentNum(i) == 0) {\r\n                _context.statManager().addRateData(\"udp.ignoreRecentDuplicate\", 1);\r\n                from.messageFullyReceived(messageId, -1);\r\n                _ackSender.ackPeer(from);\r\n                if (_log.shouldLog(Log.INFO))\r\n                    _log.info(\"Message received is a dup: \" + mid + \" dups: \" + _recentlyCompletedMessages.getCurrentDuplicateCount() + \" out of \" + _recentlyCompletedMessages.getInsertedCount());\r\n                _context.messageHistory().droppedInboundMessage(mid, from.getRemotePeer(), \"dup\");\r\n            }\r\n            continue;\r\n        }\r\n        InboundMessageState state;\r\n        boolean messageComplete = false;\r\n        boolean messageExpired = false;\r\n        boolean fragmentOK;\r\n        boolean partialACK = false;\r\n        synchronized (messages) {\r\n            boolean isNew = false;\r\n            state = messages.get(messageId);\r\n            if (state == null) {\r\n                state = new InboundMessageState(_context, mid, fromPeer, data, i);\r\n                isNew = true;\r\n                fragmentOK = true;\r\n            } else {\r\n                fragmentOK = state.receiveFragment(data, i);\r\n            }\r\n            if (state.isComplete()) {\r\n                messageComplete = true;\r\n                if (!isNew)\r\n                    messages.remove(messageId);\r\n            } else if (state.isExpired()) {\r\n                messageExpired = true;\r\n                if (!isNew)\r\n                    messages.remove(messageId);\r\n            } else {\r\n                partialACK = true;\r\n                if (isNew)\r\n                    messages.put(messageId, state);\r\n            }\r\n        }\r\n        if (messageComplete) {\r\n            _recentlyCompletedMessages.add(mid);\r\n            from.messageFullyReceived(messageId, state.getCompleteSize());\r\n            _ackSender.ackPeer(from);\r\n            if (_log.shouldLog(Log.DEBUG))\r\n                _log.debug(\"Message received completely!  \" + state);\r\n            _context.statManager().addRateData(\"udp.receivedCompleteTime\", state.getLifetime(), state.getLifetime());\r\n            if (state.getFragmentCount() > 0)\r\n                _context.statManager().addRateData(\"udp.receivedCompleteFragments\", state.getFragmentCount(), state.getLifetime());\r\n            _messageReceiver.receiveMessage(state);\r\n        } else if (messageExpired) {\r\n            if (_log.shouldLog(Log.WARN))\r\n                _log.warn(\"Message expired while only being partially read: \" + state);\r\n            _context.messageHistory().droppedInboundMessage(state.getMessageId(), state.getFrom(), \"expired while partially read: \" + state.toString());\r\n            state.releaseResources();\r\n        } else if (partialACK) {\r\n            if (_log.shouldLog(Log.DEBUG))\r\n                _log.debug(\"Queueing up a partial ACK for peer: \" + from + \" for \" + state);\r\n            from.messagePartiallyReceived();\r\n            _ackSender.ackPeer(from);\r\n        }\r\n        if (!fragmentOK)\r\n            break;\r\n    }\r\n    from.expireInboundMessages();\r\n    return fragments;\r\n}"
}, {
	"Path": "net.i2p.router.ClientMessage.getPayload",
	"Comment": "retrieve the payload of the message.all clientmessage objects should havea payload",
	"Method": "Payload getPayload(){\r\n    return _payload;\r\n}"
}, {
	"Path": "org.jrobin.data.Aggregates.dump",
	"Comment": "returns string representing all aggregated values. just for debugging purposes.",
	"Method": "String dump(){\r\n    return \"MIN=\" + Util.formatDouble(min) + \", MAX=\" + Util.formatDouble(max) + \"\\n\" + \"FIRST=\" + Util.formatDouble(first) + \", LAST=\" + Util.formatDouble(last) + \"\\n\" + \"AVERAGE=\" + Util.formatDouble(average) + \", TOTAL=\" + Util.formatDouble(total);\r\n}"
}, {
	"Path": "com.southernstorm.noise.protocol.CipherStatePair.getSender",
	"Comment": "gets the cipherstate to use to send packets to the remote party.",
	"Method": "CipherState getSender(){\r\n    return send;\r\n}"
}, {
	"Path": "net.i2p.data.i2cp.I2CPMessageHandler.createMessage",
	"Comment": "yes, this is fairly ugly, but its the only place it ever happens.",
	"Method": "I2CPMessage createMessage(int type){\r\n    switch(type) {\r\n        case CreateLeaseSetMessage.MESSAGE_TYPE:\r\n            return new CreateLeaseSetMessage();\r\n        case CreateSessionMessage.MESSAGE_TYPE:\r\n            return new CreateSessionMessage();\r\n        case DestroySessionMessage.MESSAGE_TYPE:\r\n            return new DestroySessionMessage();\r\n        case DisconnectMessage.MESSAGE_TYPE:\r\n            return new DisconnectMessage();\r\n        case MessageStatusMessage.MESSAGE_TYPE:\r\n            return new MessageStatusMessage();\r\n        case MessagePayloadMessage.MESSAGE_TYPE:\r\n            return new MessagePayloadMessage();\r\n        case ReceiveMessageBeginMessage.MESSAGE_TYPE:\r\n            return new ReceiveMessageBeginMessage();\r\n        case ReceiveMessageEndMessage.MESSAGE_TYPE:\r\n            return new ReceiveMessageEndMessage();\r\n        case ReconfigureSessionMessage.MESSAGE_TYPE:\r\n            return new ReconfigureSessionMessage();\r\n        case ReportAbuseMessage.MESSAGE_TYPE:\r\n            return new ReportAbuseMessage();\r\n        case RequestLeaseSetMessage.MESSAGE_TYPE:\r\n            return new RequestLeaseSetMessage();\r\n        case RequestVariableLeaseSetMessage.MESSAGE_TYPE:\r\n            return new RequestVariableLeaseSetMessage();\r\n        case SendMessageMessage.MESSAGE_TYPE:\r\n            return new SendMessageMessage();\r\n        case SendMessageExpiresMessage.MESSAGE_TYPE:\r\n            return new SendMessageExpiresMessage();\r\n        case SessionStatusMessage.MESSAGE_TYPE:\r\n            return new SessionStatusMessage();\r\n        case GetDateMessage.MESSAGE_TYPE:\r\n            return new GetDateMessage();\r\n        case SetDateMessage.MESSAGE_TYPE:\r\n            return new SetDateMessage();\r\n        case DestLookupMessage.MESSAGE_TYPE:\r\n            return new DestLookupMessage();\r\n        case DestReplyMessage.MESSAGE_TYPE:\r\n            return new DestReplyMessage();\r\n        case GetBandwidthLimitsMessage.MESSAGE_TYPE:\r\n            return new GetBandwidthLimitsMessage();\r\n        case BandwidthLimitsMessage.MESSAGE_TYPE:\r\n            return new BandwidthLimitsMessage();\r\n        case HostLookupMessage.MESSAGE_TYPE:\r\n            return new HostLookupMessage();\r\n        case HostReplyMessage.MESSAGE_TYPE:\r\n            return new HostReplyMessage();\r\n        case CreateLeaseSet2Message.MESSAGE_TYPE:\r\n            return new CreateLeaseSet2Message();\r\n        default:\r\n            throw new I2CPMessageException(\"The type \" + type + \" is an unknown I2CP message\");\r\n    }\r\n}"
}, {
	"Path": "com.spotify.heroic.cluster.CoreClusterManager.refreshDiscovery",
	"Comment": "the first step of the refresh operation.discover a new collection of heroic peers, and feed them into the sweep step.",
	"Method": "AsyncFuture<Void> refreshDiscovery(String id){\r\n    final List<AsyncFuture<List<URI>>> dynamic = new ArrayList();\r\n    final List<URI> staticNodes = new ArrayList(this.staticNodes.get());\r\n    if (!staticNodes.isEmpty()) {\r\n        dynamic.add(async.resolved(staticNodes));\r\n    }\r\n    dynamic.add(discovery.find());\r\n    return async.collect(dynamic).lazyTransform(refreshSweep(id));\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.stubs.cache.FileIndexCaches.getIndexKeysCache",
	"Comment": "there several methods that just need to check for names, as they also needed for value extraction, so cache them also",
	"Method": "Set<String> getIndexKeysCache(Project project,Key<CachedValue<Set<String>>> dataHolderKey,ID<String, ?> ID){\r\n    CachedValue<Set<String>> cache = project.getUserData(dataHolderKey);\r\n    if (cache == null) {\r\n        cache = CachedValuesManager.getManager(project).createCachedValue(() -> CachedValueProvider.Result.create(SymfonyProcessors.createResult(project, ID), PsiModificationTracker.MODIFICATION_COUNT), false);\r\n        project.putUserData(dataHolderKey, cache);\r\n    }\r\n    return cache.getValue();\r\n}"
}, {
	"Path": "org.klomp.snark.MetaInfo.getPieceHashes",
	"Comment": "returns the piece hashes. only used by storage so package local.",
	"Method": "byte[] getPieceHashes(){\r\n    return piece_hashes;\r\n}"
}, {
	"Path": "net.i2p.util.EepGet.getContentType",
	"Comment": "after fetch, the received value from the server, or null if none.",
	"Method": "String getContentType(){\r\n    return _contentType;\r\n}"
}, {
	"Path": "com.spotify.heroic.common.DateRange.modify",
	"Comment": "modify this range with another range.a modification asserts that the new range is a subset of the current range. any span whichwould cause the new range to become out of bounds will be cropped.",
	"Method": "DateRange modify(DateRange range,DateRange modify,long start,long end){\r\n    return new DateRange(Math.max(this.start, start), Math.min(this.end, end - 1));\r\n}"
}, {
	"Path": "net.i2p.router.web.helpers.SummaryHelper.getHighCapacityPeers",
	"Comment": "how many active peers the router ranks as having a high capacity.",
	"Method": "int getHighCapacityPeers(){\r\n    if (_context == null)\r\n        return 0;\r\n    else\r\n        return _context.profileOrganizer().countHighCapacityPeers();\r\n}"
}, {
	"Path": "net.i2p.util.I2PAppThread.removeOOMEventThreadListener",
	"Comment": "unregister a component that wants notification of oom events",
	"Method": "void removeOOMEventThreadListener(OOMEventListener lsnr){\r\n    _threadListeners.remove(lsnr);\r\n}"
}, {
	"Path": "io.helidon.webserver.testsupport.SocketHttpClient.assertConnectionIsClosed",
	"Comment": "assert that the socket associated with the provided client is closed.",
	"Method": "void assertConnectionIsClosed(SocketHttpClient s){\r\n    s.request(Http.Method.POST, null);\r\n    try {\r\n        assertThat(s.receive(), Is.is(\"\"));\r\n    } catch (SocketException e) {\r\n        LOGGER.finer(\"Received: \" + e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.core.RrdDb.close",
	"Comment": "closes rrd. no further operations are allowed on this rrddb object.",
	"Method": "void close(){\r\n    if (!closed) {\r\n        closed = true;\r\n        backend.close();\r\n    }\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterPrivateKeyFile.getRouterIdentity",
	"Comment": "read it in from the file. also sets the local privkey and signingprivkey.",
	"Method": "RouterIdentity getRouterIdentity(){\r\n    InputStream in = null;\r\n    try {\r\n        in = new BufferedInputStream(new FileInputStream(this.file));\r\n        RouterIdentity ri = new RouterIdentity();\r\n        ri.readBytes(in);\r\n        privKey = new PrivateKey();\r\n        privKey.readBytes(in);\r\n        SigType type = ri.getSigningPublicKey().getType();\r\n        if (type == null)\r\n            throw new DataFormatException(\"Unknown sig type\");\r\n        signingPrivKey = new SigningPrivateKey(type);\r\n        signingPrivKey.readBytes(in);\r\n        dest = new Destination();\r\n        dest.setPublicKey(ri.getPublicKey());\r\n        dest.setSigningPublicKey(ri.getSigningPublicKey());\r\n        dest.setCertificate(ri.getCertificate());\r\n        dest.setPadding(ri.getPadding());\r\n        return ri;\r\n    } finally {\r\n        if (in != null) {\r\n            try {\r\n                in.close();\r\n            } catch (IOException ioe) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.web.HostCheckHandler.handle",
	"Comment": "block by host header, redirect http to https, pass everything else to the delegate.",
	"Method": "void handle(String pathInContext,Request baseRequest,HttpServletRequest httpRequest,HttpServletResponse httpResponse){\r\n    String host = httpRequest.getHeader(\"Host\");\r\n    if (!allowHost(host)) {\r\n        Log log = _context.logManager().getLog(HostCheckHandler.class);\r\n        host = DataHelper.stripHTML(getHost(host));\r\n        String s = \"Console request denied.\\n\" + \"    To allow access using the hostname \\\"\" + host + \"\\\",\\n\" + \"    add the line \\\"\" + RouterConsoleRunner.PROP_ALLOWED_HOSTS + '=' + host + \"\\\"\\n\" + \"    to advanced configuration and restart.\";\r\n        log.logAlways(Log.WARN, s);\r\n        httpResponse.sendError(403, s);\r\n        baseRequest.setHandled(true);\r\n        return;\r\n    }\r\n    if (!httpRequest.isSecure()) {\r\n        int httpsPort = _portMapper.getPort(PortMapper.SVC_HTTPS_CONSOLE);\r\n        if (httpsPort > 0 && httpRequest.getLocalPort() != httpsPort) {\r\n            String redir = _context.getProperty(PROP_REDIRECT);\r\n            if (Boolean.valueOf(redir) || (redir == null && \"1\".equals(httpRequest.getHeader(\"Upgrade-Insecure-Requests\")))) {\r\n                sendRedirect(httpsPort, httpRequest, httpResponse);\r\n                baseRequest.setHandled(true);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    super.handle(pathInContext, baseRequest, httpRequest, httpResponse);\r\n}"
}, {
	"Path": "net.i2p.crypto.eddsa.math.MathUtils.getRandomGroupElement",
	"Comment": "gets a random group element in p3 representation, with precmp and dblprecmp populated.",
	"Method": "GroupElement getRandomGroupElement(GroupElement getRandomGroupElement,boolean precompute){\r\n    final byte[] bytes = new byte[32];\r\n    while (true) {\r\n        try {\r\n            random.nextBytes(bytes);\r\n            return new GroupElement(curve, bytes, precompute);\r\n        } catch (IllegalArgumentException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.crypto.eddsa.math.MathUtils.addGroupElements",
	"Comment": "adds two group elements and returns the result in p3 representation.it uses biginteger arithmetic and the affine representation.this method is a helper used to test the projective group addition formulas in groupelement.",
	"Method": "GroupElement addGroupElements(GroupElement g1,GroupElement g2){\r\n    if ((g1.getRepresentation() != GroupElement.Representation.P2 && g1.getRepresentation() != GroupElement.Representation.P3) || (g2.getRepresentation() != GroupElement.Representation.P2 && g2.getRepresentation() != GroupElement.Representation.P3)) {\r\n        throw new IllegalArgumentException(\"g1 and g2 must have representation P2 or P3\");\r\n    }\r\n    final BigInteger g1X = toBigInteger(g1.getX().toByteArray());\r\n    final BigInteger g1Y = toBigInteger(g1.getY().toByteArray());\r\n    final BigInteger g1Z = toBigInteger(g1.getZ().toByteArray());\r\n    final BigInteger g2X = toBigInteger(g2.getX().toByteArray());\r\n    final BigInteger g2Y = toBigInteger(g2.getY().toByteArray());\r\n    final BigInteger g2Z = toBigInteger(g2.getZ().toByteArray());\r\n    final BigInteger g1x = g1X.multiply(g1Z.modInverse(getQ())).mod(getQ());\r\n    final BigInteger g1y = g1Y.multiply(g1Z.modInverse(getQ())).mod(getQ());\r\n    final BigInteger g2x = g2X.multiply(g2Z.modInverse(getQ())).mod(getQ());\r\n    final BigInteger g2y = g2Y.multiply(g2Z.modInverse(getQ())).mod(getQ());\r\n    BigInteger dx1x2y1y2 = d.multiply(g1x).multiply(g2x).multiply(g1y).multiply(g2y).mod(getQ());\r\n    BigInteger x3 = g1x.multiply(g2y).add(g2x.multiply(g1y)).multiply(BigInteger.ONE.add(dx1x2y1y2).modInverse(getQ())).mod(getQ());\r\n    BigInteger y3 = g1x.multiply(g2x).add(g1y.multiply(g2y)).multiply(BigInteger.ONE.subtract(dx1x2y1y2).modInverse(getQ())).mod(getQ());\r\n    BigInteger t3 = x3.multiply(y3).mod(getQ());\r\n    return GroupElement.p3(g1.getCurve(), toFieldElement(x3), toFieldElement(y3), getField().ONE, toFieldElement(t3));\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.socks.SOCKS5Server.sendRequestReply",
	"Comment": "send the specified reply to a request of the client.eitherone of inetaddr or domainname can be null, depending onaddresstype.",
	"Method": "void sendRequestReply(int replyCode,int addressType,InetAddress inetAddr,String domainName,int bindPort,DataOutputStream out){\r\n    ByteArrayOutputStream reps = new ByteArrayOutputStream();\r\n    DataOutputStream dreps = new DataOutputStream(reps);\r\n    dreps.write(SOCKS_VERSION_5);\r\n    dreps.write(replyCode);\r\n    dreps.write(0x00);\r\n    dreps.write(addressType);\r\n    switch(addressType) {\r\n        case AddressType.IPV4:\r\n            dreps.write(inetAddr.getAddress());\r\n            break;\r\n        case AddressType.DOMAINNAME:\r\n            dreps.writeByte(domainName.length());\r\n            dreps.writeBytes(domainName);\r\n            break;\r\n        default:\r\n            _log.error(\"unknown address type passed to sendReply() (\" + Integer.toHexString(addressType) + \")!\");\r\n            return;\r\n    }\r\n    dreps.writeShort(bindPort);\r\n    byte[] reply = reps.toByteArray();\r\n    if (_log.shouldLog(Log.DEBUG)) {\r\n        _log.debug(\"Sending request reply:\\n\" + HexDump.dump(reply));\r\n    }\r\n    out.write(reply);\r\n}"
}, {
	"Path": "edu.internet2.ndt.JSONUtils.getValueFromJsonObj",
	"Comment": "function that return value for given key from json object represented by jsontext",
	"Method": "String getValueFromJsonObj(String jsonTxt,String key){\r\n    JSONValue jsonParser = new JSONValue();\r\n    Map json = (Map) jsonParser.parse(new String(jsonTxt));\r\n    Iterator iter = json.entrySet().iterator();\r\n    while (iter.hasNext()) {\r\n        Map.Entry entry = (Map.Entry) iter.next();\r\n        if (entry.getKey().equals(key)) {\r\n            return entry.getValue().toString();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.i2p.router.Router.getUptime",
	"Comment": "wall clock uptime.this uses system time, not context time, so context clock shifts willnot affect it. this is important if ntp fails and theclock then shifts from a ssu peer source just after startup.",
	"Method": "long getUptime(){\r\n    if (_started <= 0)\r\n        return 1000;\r\n    return Math.max(1000, System.currentTimeMillis() - _started);\r\n}"
}, {
	"Path": "net.nicoulaj.idea.markdown.editor.MarkdownPreviewEditor.selectNotify",
	"Comment": "invoked when the editor is selected.update the html content if obsolete.",
	"Method": "void selectNotify(){\r\n    if (previewIsObsolete) {\r\n        try {\r\n            jEditorPane.setText(\"<div id=\\\"markdown-preview\\\">\" + processor.get().markdownToHtml(document.getText()) + \"<\/div>\");\r\n            previewIsObsolete = false;\r\n        } catch (Exception e) {\r\n            LOGGER.error(\"Failed processing Markdown document\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.client.impl.I2CPMessageProducer.disconnect",
	"Comment": "send messages to the router destroying the session and disconnecting",
	"Method": "void disconnect(I2PSessionImpl session){\r\n    if (session.isClosed())\r\n        return;\r\n    DestroySessionMessage dmsg = new DestroySessionMessage();\r\n    dmsg.setSessionId(session.getSessionId());\r\n    session.sendMessage_unchecked(dmsg);\r\n}"
}, {
	"Path": "com.southernstorm.noise.protocol.HandshakeState.hasLocalKeyPair",
	"Comment": "determine if this handshake has already been configured\twith a local static key.",
	"Method": "boolean hasLocalKeyPair(){\r\n    if (localKeyPair != null)\r\n        return localKeyPair.hasPrivateKey();\r\n    else\r\n        return false;\r\n}"
}, {
	"Path": "net.i2p.servlet.I2PDefaultServlet.getListHTML",
	"Comment": "copied and modified from resource.javamodified to set the locale for the dates.get the resource list as a html directory listing.",
	"Method": "String getListHTML(Resource res,String base,boolean parent){\r\n    base = URIUtil.canonicalPath(base);\r\n    if (base == null || !res.isDirectory())\r\n        return null;\r\n    String[] ls = res.list();\r\n    if (ls == null)\r\n        return null;\r\n    Arrays.sort(ls);\r\n    String decodedBase = URIUtil.decodePath(base);\r\n    String title = \"Directory: \" + deTag(decodedBase);\r\n    StringBuilder buf = new StringBuilder(4096);\r\n    buf.append(\"<HTML><HEAD>\");\r\n    buf.append(\"<LINK HREF=\\\"\").append(\"jetty-dir.css\").append(\"\\\" REL=\\\"stylesheet\\\" TYPE=\\\"text/css\\\"/><TITLE>\");\r\n    buf.append(title);\r\n    buf.append(\"<\/TITLE><\/HEAD><BODY>\\n<H1>\");\r\n    buf.append(title);\r\n    buf.append(\"<\/H1>\\n<TABLE BORDER=0>\\n\");\r\n    if (parent) {\r\n        buf.append(\"<TR><TD><A HREF=\\\"\");\r\n        buf.append(URIUtil.addPaths(base, \"../\"));\r\n        buf.append(\"\\\">Parent Directory<\/A><\/TD><TD><\/TD><TD><\/TD><\/TR>\\n\");\r\n    }\r\n    String encodedBase = hrefEncodeURI(base);\r\n    DateFormat dfmt = new SimpleDateFormat(FORMAT, Locale.UK);\r\n    TimeZone utc = TimeZone.getTimeZone(\"GMT\");\r\n    dfmt.setTimeZone(utc);\r\n    for (int i = 0; i < ls.length; i++) {\r\n        Resource item;\r\n        try {\r\n            item = res.addPath(ls[i]);\r\n        } catch (IOException ioe) {\r\n            System.out.println(\"Skipping file in directory listing: \" + ioe.getMessage());\r\n            continue;\r\n        } catch (RuntimeException re) {\r\n            System.out.println(\"Skipping file in directory listing: \" + re.getMessage());\r\n            continue;\r\n        }\r\n        buf.append(\"\\n<TR><TD><A HREF=\\\"\");\r\n        String path = URIUtil.addPaths(encodedBase, URIUtil.encodePath(ls[i]));\r\n        buf.append(path);\r\n        if (item.isDirectory() && !path.endsWith(\"/\"))\r\n            buf.append(URIUtil.SLASH);\r\n        buf.append(\"\\\">\");\r\n        buf.append(deTag(ls[i]));\r\n        buf.append(\"<\/A><\/TD><TD ALIGN=right>\");\r\n        buf.append(item.length());\r\n        buf.append(\" bytes&nbsp;<\/TD><TD>\");\r\n        buf.append(dfmt.format(new Date(item.lastModified())));\r\n        buf.append(\" UTC<\/TD><\/TR>\");\r\n    }\r\n    buf.append(\"<\/TABLE>\\n\");\r\n    buf.append(\"<\/BODY><\/HTML>\\n\");\r\n    return buf.toString();\r\n}"
}, {
	"Path": "net.metanotion.io.block.index.BSkipLevels.blvlck",
	"Comment": "recursively walk through the levels at level 0\t this needs work.",
	"Method": "boolean blvlck(boolean fix,boolean blvlck,boolean fix,int width,SkipLevels<K, V>[] prevLevels){\r\n    bf.log.warn(\"    Skip level at width \" + width);\r\n    bf.log.warn(\"        levels \" + this.levels.length);\r\n    bf.log.warn(\"        first key \" + this.key());\r\n    bf.log.warn(\"        spanPage \" + this.spanPage);\r\n    bf.log.warn(\"        levelPage \" + this.levelPage);\r\n    SkipLevels<K, V> higher = null;\r\n    for (int i = levels.length - 1; i >= 0; i--) {\r\n        if (levels[i] != null) {\r\n            bf.log.info(\"                level \" + i + \" -> \" + levels[i].key() + \" \");\r\n            if (higher != null) {\r\n                if (higher.key().compareTo(key()) < 0)\r\n                    bf.log.warn(\"                Higher level has lower key \" + higher.key());\r\n            }\r\n        } else {\r\n            bf.log.info(\"                level \" + i + \" empty\");\r\n            if (higher != null)\r\n                bf.log.warn(\"                Higher level is not empty, key is \" + higher.key());\r\n        }\r\n    }\r\n    if (prevLevels != null) {\r\n        int min = Math.min(prevLevels.length, levels.length);\r\n        for (int i = 0; i < min; i++) {\r\n            if (prevLevels[i] == this) {\r\n                prevLevels[i] = levels[i];\r\n            } else if (prevLevels[i] != null) {\r\n                bf.log.warn(\"                Previous levels is non-null \" + prevLevels[i].key() + \" but not pointing to us at level \" + i);\r\n                prevLevels[i] = levels[i];\r\n            } else {\r\n                if (levels[i] != null) {\r\n                    bf.log.warn(\"                Previous levels is null but we are non-null \" + levels[i].key() + \" at level \" + i);\r\n                    prevLevels[i] = levels[i];\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        prevLevels = (SkipLevels<K, V>[]) new SkipLevels[levels.length];\r\n        System.arraycopy(levels, 0, prevLevels, 0, levels.length);\r\n    }\r\n    if (levels[0] != null)\r\n        levels[0].blvlck(fix, width + 1, prevLevels);\r\n    return false;\r\n}"
}, {
	"Path": "org.jrobin.core.Header.getRrdAllocator",
	"Comment": "required to implement rrdupdater interface. you should never call this method directly.",
	"Method": "RrdAllocator getRrdAllocator(){\r\n    return parentDb.getRrdAllocator();\r\n}"
}, {
	"Path": "net.i2p.data.PrivateKeyFile.getDestination",
	"Comment": "if the destination is not set, read it in from the file. also sets the local privkey and signingprivkey.",
	"Method": "Destination getDestination(){\r\n    if (dest == null) {\r\n        I2PSession s = open();\r\n        if (s != null) {\r\n            this.dest = new VerifiedDestination(s.getMyDestination());\r\n            this.privKey = s.getDecryptionKey();\r\n            this.signingPrivKey = s.getPrivateKey();\r\n            if (s.isOffline()) {\r\n                _offlineExpiration = s.getOfflineExpiration();\r\n                _transientSigningPubKey = s.getTransientSigningPublicKey();\r\n                _offlineSignature = s.getOfflineSignature();\r\n                _transientSigningPrivKey = signingPrivKey;\r\n                SigType type = dest.getSigningPublicKey().getType();\r\n                byte[] dbytes = new byte[type.getPrivkeyLen()];\r\n                signingPrivKey = new SigningPrivateKey(type, dbytes);\r\n            }\r\n        }\r\n    }\r\n    return this.dest;\r\n}"
}, {
	"Path": "org.klomp.snark.standalone.HostCheckHandler.handle",
	"Comment": "block by host header, redirect http to https, pass everything else to the delegate.",
	"Method": "void handle(String pathInContext,Request baseRequest,HttpServletRequest httpRequest,HttpServletResponse httpResponse){\r\n    String host = httpRequest.getHeader(\"Host\");\r\n    if (!allowHost(host)) {\r\n        Log log = _context.logManager().getLog(HostCheckHandler.class);\r\n        host = getHost(host);\r\n        String s = \"Console request denied.\\n\" + \"    To allow access using the hostname \\\"\" + host + \"\\\", add the line \\\"\" + PROP_ALLOWED_HOSTS + '=' + host + \"\\\" in the file \" + RunStandalone.APP_CONFIG_FILE.getAbsolutePath() + \" and restart.\";\r\n        log.logAlways(Log.WARN, s);\r\n        httpResponse.sendError(403, s);\r\n        baseRequest.setHandled(true);\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.HopConfig.getReplyKey",
	"Comment": "key to encrypt the reply sent for the new tunnel creation crypto",
	"Method": "SessionKey getReplyKey(){\r\n    return _replyKey;\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.KademliaNetworkDatabaseFacade.validate",
	"Comment": "determine whether this routerinfo will be accepted as valid and currentgiven what we know now.call this before each use, to check expiration",
	"Method": "String validate(Hash key,LeaseSet leaseSet,String validate,Hash key,RouterInfo routerInfo,String validate,RouterInfo routerInfo){\r\n    long now = _context.clock().now();\r\n    boolean upLongEnough = _context.router().getUptime() > 60 * 60 * 1000;\r\n    long adjustedExpiration;\r\n    if (floodfillEnabled())\r\n        adjustedExpiration = ROUTER_INFO_EXPIRATION_FLOODFILL;\r\n    else\r\n        adjustedExpiration = Math.min(ROUTER_INFO_EXPIRATION, ROUTER_INFO_EXPIRATION_MIN + ((ROUTER_INFO_EXPIRATION - ROUTER_INFO_EXPIRATION_MIN) * MIN_ROUTERS / (_kb.size() + 1)));\r\n    if (upLongEnough && !routerInfo.isCurrent(adjustedExpiration)) {\r\n        long age = _context.clock().now() - routerInfo.getPublished();\r\n        int existing = _kb.size();\r\n        if (existing >= MIN_REMAINING_ROUTERS) {\r\n            if (_log.shouldLog(Log.INFO))\r\n                _log.info(\"Expired RI \" + routerInfo.getIdentity().getHash(), new Exception());\r\n            return \"Peer expired \" + DataHelper.formatDuration(age) + \" ago\";\r\n        } else {\r\n            if (_log.shouldLog(Log.WARN))\r\n                _log.warn(\"Even though the peer is old, we have only \" + existing + \" peers left \" + routerInfo);\r\n        }\r\n    }\r\n    if (routerInfo.getPublished() > now + 2 * Router.CLOCK_FUDGE_FACTOR) {\r\n        long age = routerInfo.getPublished() - _context.clock().now();\r\n        if (_log.shouldLog(Log.INFO))\r\n            _log.info(\"Peer \" + routerInfo.getIdentity().getHash() + \" published their routerInfo in the future?! [\" + new Date(routerInfo.getPublished()) + \"]\", new Exception());\r\n        return \"Peer published \" + DataHelper.formatDuration(age) + \" in the future?!\";\r\n    }\r\n    if (!routerInfo.isCurrent(ROUTER_INFO_EXPIRATION_INTRODUCED)) {\r\n        if (routerInfo.getAddresses().isEmpty())\r\n            return \"Old peer with no addresses\";\r\n        if (routerInfo.getCapabilities().indexOf(Router.CAPABILITY_UNREACHABLE) >= 0)\r\n            return \"Old peer and thinks it is unreachable\";\r\n        for (RouterAddress ra : routerInfo.getAddresses()) {\r\n            if (ra.getOption(\"ihost0\") != null)\r\n                return \"Old peer with SSU Introducers\";\r\n        }\r\n    }\r\n    if (upLongEnough && (routerInfo.getPublished() < now - 2 * 24 * 60 * 60 * 1000l)) {\r\n        long age = _context.clock().now() - routerInfo.getPublished();\r\n        return \"Peer published \" + DataHelper.formatDuration(age) + \" ago\";\r\n    }\r\n    if (upLongEnough && !routerInfo.isCurrent(ROUTER_INFO_EXPIRATION_SHORT)) {\r\n        if (routerInfo.getTargetAddress(\"NTCP\") == null)\r\n            return \"Peer published > 75m ago, SSU only without introducers\";\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jrobin.data.LinearInterpolator.getValue",
	"Comment": "method overriden from the base class. this method will be called by the framework. call\tthis method only if you need interpolated values in your code.",
	"Method": "double getValue(long timestamp){\r\n    if (interpolationMethod == INTERPOLATE_REGRESSION) {\r\n        return b0 + b1 * timestamp;\r\n    }\r\n    int count = timestamps.length;\r\n    if (timestamp < timestamps[0] || timestamp > timestamps[count - 1]) {\r\n        return Double.NaN;\r\n    }\r\n    int startIndex = lastIndexUsed;\r\n    if (timestamp < timestamps[lastIndexUsed]) {\r\n        startIndex = 0;\r\n    }\r\n    for (int i = startIndex; i < count; i++) {\r\n        if (timestamps[i] == timestamp) {\r\n            return values[i];\r\n        }\r\n        if (i < count - 1 && timestamps[i] < timestamp && timestamp < timestamps[i + 1]) {\r\n            lastIndexUsed = i;\r\n            switch(interpolationMethod) {\r\n                case INTERPOLATE_LEFT:\r\n                    return values[i];\r\n                case INTERPOLATE_RIGHT:\r\n                    return values[i + 1];\r\n                case INTERPOLATE_LINEAR:\r\n                    double slope = (values[i + 1] - values[i]) / (timestamps[i + 1] - timestamps[i]);\r\n                    return values[i] + slope * (timestamp - timestamps[i]);\r\n                default:\r\n                    return Double.NaN;\r\n            }\r\n        }\r\n    }\r\n    return Double.NaN;\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.Archive.getCDPStatusBlock",
	"Comment": "returns the cdpstatusblock at the specified position in this archive.",
	"Method": "CDPStatusBlock getCDPStatusBlock(int index){\r\n    return cdpStatusBlocks.get(index);\r\n}"
}, {
	"Path": "net.i2p.router.transport.TransportManager.mayDisconnect",
	"Comment": "tell the transports that we may disconnect from this peer.this is advisory only.",
	"Method": "void mayDisconnect(Hash peer){\r\n    for (Transport t : _transports.values()) {\r\n        t.mayDisconnect(peer);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PacketBuilder.buildPeerTestToCharlie",
	"Comment": "build a packet as if we are bob sending charlie a packet to help test alice.",
	"Method": "UDPPacket buildPeerTestToCharlie(InetAddress aliceIP,int alicePort,SessionKey aliceIntroKey,long nonce,InetAddress charlieIP,int charliePort,SessionKey charlieCipherKey,SessionKey charlieMACKey){\r\n    UDPPacket packet = buildPacketHeader(PEER_TEST_FLAG_BYTE);\r\n    DatagramPacket pkt = packet.getPacket();\r\n    byte[] data = pkt.getData();\r\n    int off = HEADER_SIZE;\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Sending peer test \" + nonce + \" to Charlie\");\r\n    DataHelper.toLong(data, off, 4, nonce);\r\n    off += 4;\r\n    byte[] ip = aliceIP.getAddress();\r\n    DataHelper.toLong(data, off, 1, ip.length);\r\n    off++;\r\n    System.arraycopy(ip, 0, data, off, ip.length);\r\n    off += ip.length;\r\n    DataHelper.toLong(data, off, 2, alicePort);\r\n    off += 2;\r\n    System.arraycopy(aliceIntroKey.getData(), 0, data, off, SessionKey.KEYSIZE_BYTES);\r\n    off += SessionKey.KEYSIZE_BYTES;\r\n    off = pad1(data, off);\r\n    off = pad2(data, off);\r\n    pkt.setLength(off);\r\n    authenticate(packet, charlieCipherKey, charlieMACKey);\r\n    setTo(packet, charlieIP, charliePort);\r\n    packet.setMessageType(TYPE_TBC);\r\n    return packet;\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.ProfileManagerImpl.commErrorOccurred",
	"Comment": "note that there was some sort of communication error talking with the peer",
	"Method": "void commErrorOccurred(Hash peer){\r\n    if (_log.shouldLog(Log.INFO))\r\n        _log.info(\"Comm error occurred for peer \" + peer.toBase64(), new Exception(\"Comm error\"));\r\n    PeerProfile data = getProfile(peer);\r\n    data.setLastSendFailed(_context.clock().now());\r\n}"
}, {
	"Path": "net.i2p.util.FileLogWriter.getFirstFile",
	"Comment": "retrieve the first file, updating the rotation number accordinglycaller must synch",
	"Method": "File getFirstFile(File base,String pattern,int max){\r\n    for (int i = 0; i < max; i++) {\r\n        File f;\r\n        if (base != null)\r\n            f = new File(base, replace(pattern, i));\r\n        else\r\n            f = new File(replace(pattern, i));\r\n        if (!f.exists()) {\r\n            _rotationNum = i;\r\n            return f;\r\n        }\r\n    }\r\n    File oldest = null;\r\n    for (int i = 0; i < max; i++) {\r\n        File f;\r\n        if (base != null)\r\n            f = new File(base, replace(pattern, i));\r\n        else\r\n            f = new File(replace(pattern, i));\r\n        if (oldest == null) {\r\n            oldest = f;\r\n        } else {\r\n            if (f.lastModified() < oldest.lastModified()) {\r\n                _rotationNum = i;\r\n                oldest = f;\r\n            }\r\n        }\r\n    }\r\n    return oldest;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.EstablishmentManager.handleInbound",
	"Comment": "drive through the inbound establishment states, adjusting one of themas necessary. called from establisher thread only.",
	"Method": "long handleInbound(){\r\n    long now = _context.clock().now();\r\n    long nextSendTime = -1;\r\n    InboundEstablishState inboundState = null;\r\n    boolean expired = false;\r\n    for (Iterator<InboundEstablishState> iter = _inboundStates.values().iterator(); iter.hasNext(); ) {\r\n        InboundEstablishState cur = iter.next();\r\n        if (cur.getState() == IB_STATE_CONFIRMED_COMPLETELY) {\r\n            iter.remove();\r\n            inboundState = cur;\r\n            break;\r\n        } else if (cur.getLifetime() > MAX_IB_ESTABLISH_TIME) {\r\n            iter.remove();\r\n            inboundState = cur;\r\n            expired = true;\r\n            break;\r\n        } else if (cur.getState() == IB_STATE_FAILED) {\r\n            iter.remove();\r\n        } else {\r\n            if (cur.getNextSendTime() <= now) {\r\n                inboundState = cur;\r\n                break;\r\n            } else {\r\n                long when = -1;\r\n                if (cur.getNextSendTime() <= 0) {\r\n                    when = cur.getEstablishBeginTime() + MAX_IB_ESTABLISH_TIME;\r\n                } else {\r\n                    when = cur.getNextSendTime();\r\n                }\r\n                if (when < nextSendTime)\r\n                    nextSendTime = when;\r\n            }\r\n        }\r\n    }\r\n    if (inboundState != null) {\r\n        synchronized (inboundState) {\r\n            switch(inboundState.getState()) {\r\n                case IB_STATE_REQUEST_RECEIVED:\r\n                    if (expired)\r\n                        processExpired(inboundState);\r\n                    else\r\n                        sendCreated(inboundState);\r\n                    break;\r\n                case IB_STATE_CREATED_SENT:\r\n                case IB_STATE_CONFIRMED_PARTIALLY:\r\n                    if (expired) {\r\n                        sendDestroy(inboundState);\r\n                        processExpired(inboundState);\r\n                    } else if (inboundState.getNextSendTime() <= now) {\r\n                        sendCreated(inboundState);\r\n                    }\r\n                    break;\r\n                case IB_STATE_CONFIRMED_COMPLETELY:\r\n                    RouterIdentity remote = inboundState.getConfirmedIdentity();\r\n                    if (remote != null) {\r\n                        if (_context.banlist().isBanlistedForever(remote.calculateHash())) {\r\n                            if (_log.shouldLog(Log.WARN))\r\n                                _log.warn(\"Dropping inbound connection from permanently banlisted peer: \" + remote.calculateHash());\r\n                            _context.blocklist().add(inboundState.getSentIP());\r\n                            inboundState.fail();\r\n                            processExpired(inboundState);\r\n                        } else {\r\n                            handleCompletelyEstablished(inboundState);\r\n                        }\r\n                    } else {\r\n                        if (_log.shouldLog(Log.WARN))\r\n                            _log.warn(\"confirmed with invalid? \" + inboundState);\r\n                        inboundState.fail();\r\n                        processExpired(inboundState);\r\n                    }\r\n                    break;\r\n                case IB_STATE_COMPLETE:\r\n                case IB_STATE_FAILED:\r\n                    break;\r\n                case IB_STATE_UNKNOWN:\r\n                    if (_log.shouldLog(Log.ERROR))\r\n                        _log.error(\"hrm, state is unknown for \" + inboundState);\r\n            }\r\n        }\r\n        nextSendTime = now;\r\n    }\r\n    return nextSendTime;\r\n}"
}, {
	"Path": "com.netflix.hollow.api.producer.HollowIncrementalProducer.restoreFromLastState",
	"Comment": "initializes the data model and restores from existing state.",
	"Method": "void restoreFromLastState(){\r\n    producer.initializeDataModel(dataModel);\r\n    long latestAnnouncedVersion = announcementWatcher.getLatestVersion();\r\n    if (latestAnnouncedVersion == HollowFilesystemAnnouncementWatcher.NO_ANNOUNCEMENT_AVAILABLE || latestAnnouncedVersion < 0) {\r\n        return;\r\n    }\r\n    restore(latestAnnouncedVersion, blobRetriever);\r\n}"
}, {
	"Path": "net.i2p.crypto.AESEngine.decryptBlock",
	"Comment": "this just copies payload to rv, see extension for the real thing.",
	"Method": "void decryptBlock(byte payload,int inIndex,SessionKey sessionKey,byte rv,int outIndex){\r\n    System.arraycopy(payload, inIndex, rv, outIndex, rv.length - outIndex);\r\n}"
}, {
	"Path": "org.jrobin.core.RrdDef.getEstimatedSize",
	"Comment": "returns the number of storage bytes required to create rrd from this\trrddef object.",
	"Method": "long getEstimatedSize(){\r\n    final int dsCount = dsDefs.size();\r\n    final int arcCount = arcDefs.size();\r\n    int rowsCount = 0;\r\n    for (final ArcDef arcDef : arcDefs) {\r\n        rowsCount += arcDef.getRows();\r\n    }\r\n    return calculateSize(dsCount, arcCount, rowsCount);\r\n}"
}, {
	"Path": "com.southernstorm.noise.protocol.HandshakeState.split",
	"Comment": "splits the transport encryption cipherstate objects out of\tthis handshakeobject after mixing in a secondary symmetric key.",
	"Method": "CipherStatePair split(CipherStatePair split,byte[] secondaryKey,int offset,int length){\r\n    if (action != SPLIT) {\r\n        throw new IllegalStateException(\"Handshake has not finished\");\r\n    }\r\n    CipherStatePair pair = symmetric.split(secondaryKey, offset, length);\r\n    if (!isInitiator) {\r\n        pair.swap();\r\n    }\r\n    action = COMPLETE;\r\n    return pair;\r\n}"
}, {
	"Path": "com.spotify.heroic.cluster.CoreClusterManagerIT.testSafeRefresh",
	"Comment": "this tests the assumption that it is safe to perform refreshes, even when there arerequests pending, or about to be fired.the test will continue to run, while the refresh thread is running.",
	"Method": "void testSafeRefresh(){\r\n    final int numberOfRefreshes = 100;\r\n    final int requestsPerIteration = 100;\r\n    final HeroicCoreInstance a = instances.get(0);\r\n    final ClusterManager clusterManager = a.inject(ClusterComponent::clusterManager);\r\n    final ClusterRefreshThread t = setupRefreshThread(clusterManager, numberOfRefreshes);\r\n    final DataStreamCollector collector = new DataStreamCollector();\r\n    while (!t.shutdown.get()) {\r\n        final List<Callable<AsyncFuture<Void>>> operations = new ArrayList();\r\n        for (int i = 0; i < requestsPerIteration; i++) {\r\n            operations.add(() -> {\r\n                final List<AsyncFuture<Void>> pongs = new ArrayList();\r\n                for (final ClusterShard shard : clusterManager.useDefaultGroup()) {\r\n                    for (int p = 0; p < 10; p++) {\r\n                        pongs.addAll(pingAllNodesInShard(clusterManager, shard));\r\n                    }\r\n                }\r\n                return async.collectAndDiscard(pongs);\r\n            });\r\n        }\r\n        async.eventuallyCollect(operations, collector, 20).get();\r\n    }\r\n    t.join();\r\n    assertNull(\"no errors during refreshes\", t.refreshError.get());\r\n    assertTrue(\"number of refreshes are non-zero\", t.refreshes.get() > 0);\r\n    assertTrue(\"number of resolved requests are non-zero\", collector.resolved.get() > 0);\r\n    assertEquals(\"expect no cancelled requests\", 0, collector.cancelled.get());\r\n    assertEquals(\"expect no failed requests\", 0, collector.failed.get());\r\n    assertTrue(collector.ended);\r\n}"
}, {
	"Path": "org.jrobin.graph.RrdGraphDef.setUnit",
	"Comment": "sets unit to be displayed on y axis. it is wise to use only short units on graph, however.",
	"Method": "void setUnit(String unit){\r\n    this.unit = unit;\r\n}"
}, {
	"Path": "org.jrobin.core.Robin.getSize",
	"Comment": "returns the size of the underlying array of archived values.",
	"Method": "int getSize(){\r\n    return rows;\r\n}"
}, {
	"Path": "i2p.susi.dns.AddressbookBean.generateLoadMessage",
	"Comment": "format a message about filtered addressbook size, and the number of displayed entries\t addressbook.jsp catches the case where the whole book is empty.",
	"Method": "String generateLoadMessage(){\r\n    String message;\r\n    String filterArg = \"\";\r\n    int resultCount = resultSize();\r\n    if (filter != null && filter.length() > 0) {\r\n        if (search != null && search.length() > 0)\r\n            message = ngettext(\"One result for search within filtered list.\", \"{0} results for search within filtered list.\", resultCount);\r\n        else\r\n            message = ngettext(\"Filtered list contains 1 entry.\", \"Filtered list contains {0} entries.\", resultCount);\r\n        filterArg = \"&amp;filter=\" + filter;\r\n    } else if (search != null && search.length() > 0) {\r\n        message = ngettext(\"One result for search.\", \"{0} results for search.\", resultCount);\r\n    } else {\r\n        if (resultCount <= 0)\r\n            message = \"\";\r\n        else\r\n            message = ngettext(\"Address book contains 1 entry.\", \"Address book contains {0} entries.\", resultCount);\r\n    }\r\n    if (resultCount <= 0) {\r\n    } else if (getBeginInt() == 0 && getEndInt() == resultCount - 1) {\r\n    } else {\r\n        if (getBeginInt() > 0) {\r\n            int newBegin = Math.max(0, getBeginInt() - DISPLAY_SIZE);\r\n            int newEnd = Math.max(0, getBeginInt() - 1);\r\n            message += \" <a href=\\\"addressbook?book=\" + getBook() + filterArg + \"&amp;begin=\" + newBegin + \"&amp;end=\" + newEnd + \"\\\">\" + (newBegin + 1) + '-' + (newEnd + 1) + \"<\/a> | \";\r\n        }\r\n        message += ' ' + _t(\"Showing {0} of {1}\", \"\" + (getBeginInt() + 1) + '-' + (getEndInt() + 1), Integer.valueOf(resultCount));\r\n        if (getEndInt() < resultCount - 1) {\r\n            int newBegin = Math.min(resultCount - 1, getEndInt() + 1);\r\n            int newEnd = Math.min(resultCount, getEndInt() + DISPLAY_SIZE);\r\n            message += \" | <a href=\\\"addressbook?book=\" + getBook() + filterArg + \"&amp;begin=\" + newBegin + \"&amp;end=\" + newEnd + \"\\\">\" + (newBegin + 1) + '-' + (newEnd + 1) + \"<\/a>\";\r\n        }\r\n    }\r\n    return message;\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.KademliaNetworkDatabaseFacade.getKnownRouters",
	"Comment": "this used to return the number of routers that were in both the kbuckets and the data store, which was fine when the kbuckets held everything. but now that is probably not what you want. just return the count in the data store.",
	"Method": "int getKnownRouters(){\r\n    if (_ds == null)\r\n        return 0;\r\n    int rv = 0;\r\n    for (DatabaseEntry ds : _ds.getEntries()) {\r\n        if (ds.getType() == DatabaseEntry.KEY_TYPE_ROUTERINFO)\r\n            rv++;\r\n    }\r\n    return rv;\r\n}"
}, {
	"Path": "com.spotify.heroic.cluster.ClusterNode.isAlive",
	"Comment": "perform a check to see if this node connection should be considered alive or not.",
	"Method": "boolean isAlive(){\r\n    return true;\r\n}"
}, {
	"Path": "net.i2p.util.LogSettingsTest.setUp",
	"Comment": "sets up the test fixture.called before every test case method.",
	"Method": "void setUp(){\r\n    _context = I2PAppContext.getGlobalContext();\r\n    log = _context.logManager().getLog(LogSettingsTest.class);\r\n    p = new Properties();\r\n    f = new File(\"logger.config\");\r\n    if (!f.exists()) {\r\n        FileWriter temp = new FileWriter(f);\r\n        temp.close();\r\n    }\r\n    DataHelper.loadProps(p, f);\r\n    origMinimumOnScreenLevel = p.getProperty(\"logger.record.net.i2p.util.LogSettingsTest\", Log.STR_ERROR);\r\n    origLogSettings = p.getProperty(\"logger.minimumOnScreenLevel\", Log.STR_CRIT);\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.OutboundGatewayProcessor.process",
	"Comment": "since we are the outbound gateway, pick a random iv and wrap the preprocessed data so that it will be exposed at the endpoint.",
	"Method": "void process(byte orig,int offset,int length){\r\n    byte[] iv = SimpleByteCache.acquire(HopProcessor.IV_LENGTH);\r\n    System.arraycopy(orig, offset, iv, 0, HopProcessor.IV_LENGTH);\r\n    if (_log.shouldLog(Log.DEBUG)) {\r\n        _log.debug(\"Orig random IV: \" + Base64.encode(iv));\r\n    }\r\n    decrypt(_context, _config, iv, orig, offset, length);\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"finished processing the preprocessed data\");\r\n    SimpleByteCache.release(iv);\r\n}"
}, {
	"Path": "net.i2p.data.i2np.DeliveryStatusMessage.writeMessageBody",
	"Comment": "write the message body to the output array, starting at the given index",
	"Method": "int writeMessageBody(byte out,int curIndex){\r\n    if ((_id < 0) || (_arrival <= 0))\r\n        throw new I2NPMessageException(\"Not enough data to write out\");\r\n    DataHelper.toLong(out, curIndex, 4, _id);\r\n    curIndex += 4;\r\n    DataHelper.toLong(out, curIndex, DataHelper.DATE_LENGTH, _arrival);\r\n    curIndex += DataHelper.DATE_LENGTH;\r\n    return curIndex;\r\n}"
}, {
	"Path": "net.i2p.router.crypto.TransientSessionKeyManager.getAvailableTimeLeft",
	"Comment": "determine how long the available tags will be available for before expiring, in milliseconds",
	"Method": "long getAvailableTimeLeft(PublicKey target,SessionKey key){\r\n    OutboundSession sess = getSession(target);\r\n    if (sess == null) {\r\n        return 0;\r\n    }\r\n    if (sess.getCurrentKey().equals(key)) {\r\n        long end = sess.getLastExpirationDate();\r\n        if (end <= 0)\r\n            return 0;\r\n        else\r\n            return end - _context.clock().now();\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "net.nicoulaj.idea.markdown.editor.MarkdownPreviewEditorProvider.createEditor",
	"Comment": "create a valid editor for the specified file.should be called only if the provider has accepted this file.",
	"Method": "FileEditor createEditor(Project project,VirtualFile file){\r\n    return new MarkdownPreviewEditor(project, FileDocumentManager.getInstance().getDocument(file));\r\n}"
}, {
	"Path": "net.i2p.sam.SAMv1Handler.checkDatagramSize",
	"Comment": "check whether a size is inside the limits allowed by this protocol",
	"Method": "boolean checkDatagramSize(int size){\r\n    return ((size >= 1) && (size <= 31744));\r\n}"
}, {
	"Path": "net.i2p.addressbook.Subscription.getEtag",
	"Comment": "return the etag header that we received the last time we read thissubscription.",
	"Method": "String getEtag(){\r\n    return this.etag;\r\n}"
}, {
	"Path": "net.i2p.router.time.NtpClient.currentTimeAndStratum",
	"Comment": "query the ntp servers, returning the current time from first one we findhack to return time and stratum",
	"Method": "long[] currentTimeAndStratum(String serverNames,int perServerTimeout,boolean preferIPv6,Log log,long[] currentTimeAndStratum,String serverName,int timeout,boolean preferIPv6,Log log){\r\n    DatagramSocket socket = null;\r\n    I2PAppContext ctx = I2PAppContext.getGlobalContext();\r\n    boolean useDNSOverHTTPS = ctx.getProperty(PROP_USE_DNS_OVER_HTTPS, DEFAULT_USE_DNS_OVER_HTTPS);\r\n    try {\r\n        InetAddress address;\r\n        if (preferIPv6) {\r\n            String ip = null;\r\n            if (useDNSOverHTTPS) {\r\n                DNSOverHTTPS doh = new DNSOverHTTPS(ctx);\r\n                ip = doh.lookup(serverName, DNSOverHTTPS.Type.V6_PREFERRED);\r\n            }\r\n            if (ip != null) {\r\n                address = InetAddress.getByName(ip);\r\n            } else {\r\n                InetAddress[] addrs = InetAddress.getAllByName(serverName);\r\n                if (addrs == null || addrs.length == 0)\r\n                    throw new UnknownHostException();\r\n                address = null;\r\n                for (int i = 0; i < addrs.length; i++) {\r\n                    if (addrs[i] instanceof Inet6Address) {\r\n                        address = addrs[i];\r\n                        break;\r\n                    }\r\n                    if (address == null)\r\n                        address = addrs[0];\r\n                }\r\n            }\r\n        } else {\r\n            if (useDNSOverHTTPS) {\r\n                DNSOverHTTPS doh = new DNSOverHTTPS(ctx);\r\n                String ip = doh.lookup(serverName, DNSOverHTTPS.Type.V4_ONLY);\r\n                if (ip != null)\r\n                    serverName = ip;\r\n            }\r\n            address = InetAddress.getByName(serverName);\r\n        }\r\n        String who = address.getHostAddress();\r\n        String why = kisses.get(who);\r\n        if (why != null) {\r\n            if (log != null)\r\n                log.warn(\"Not querying, previous KoD from NTP server \" + serverName + \" (\" + who + \") \" + why);\r\n            return null;\r\n        }\r\n        byte[] buf = new NtpMessage().toByteArray();\r\n        DatagramPacket packet = new DatagramPacket(buf, buf.length, address, NTP_PORT);\r\n        byte[] txtime = new byte[8];\r\n        socket = new DatagramSocket();\r\n        NtpMessage.encodeTimestamp(packet.getData(), OFF_TXTIME, (System.currentTimeMillis() / 1000.0) + SECONDS_1900_TO_EPOCH);\r\n        socket.send(packet);\r\n        System.arraycopy(packet.getData(), OFF_TXTIME, txtime, 0, 8);\r\n        if (log != null && log.shouldDebug())\r\n            log.debug(\"Sent to \" + serverName + \" (\" + who + \")\\n\" + HexDump.dump(buf));\r\n        packet = new DatagramPacket(buf, buf.length);\r\n        socket.setSoTimeout(timeout);\r\n        socket.receive(packet);\r\n        double destinationTimestamp = (System.currentTimeMillis() / 1000.0) + SECONDS_1900_TO_EPOCH;\r\n        if (packet.getLength() < MIN_PKT_LEN) {\r\n            if (log != null && log.shouldWarn())\r\n                log.warn(\"Short packet length \" + packet.getLength());\r\n            return null;\r\n        }\r\n        NtpMessage msg = new NtpMessage(packet.getData());\r\n        String from = packet.getAddress().getHostAddress();\r\n        int port = packet.getPort();\r\n        if (log != null && log.shouldDebug())\r\n            log.debug(\"Received from: \" + from + \" port \" + port + '\\n' + msg + '\\n' + HexDump.dump(packet.getData()));\r\n        if (port != NTP_PORT || !who.equals(from)) {\r\n            if (log != null && log.shouldWarn())\r\n                log.warn(\"Sent to \" + who + \" port \" + NTP_PORT + \" but received from \" + packet.getSocketAddress());\r\n            return null;\r\n        }\r\n        if (msg.stratum > 15) {\r\n            if (log != null && log.shouldWarn())\r\n                log.warn(\"NTP server \" + serverName + \" bad stratum \" + msg.stratum);\r\n            return null;\r\n        }\r\n        if (!DataHelper.eq(txtime, 0, packet.getData(), OFF_ORIGTIME, 8)) {\r\n            if (log != null && log.shouldWarn())\r\n                log.warn(\"Origin time mismatch sent:\\n\" + HexDump.dump(txtime) + \"rcvd:\\n\" + HexDump.dump(packet.getData(), OFF_ORIGTIME, 8));\r\n            return null;\r\n        }\r\n        if (msg.leapIndicator == 3 || msg.version < 3 || msg.mode != 4 || msg.transmitTimestamp <= 0 || Math.abs(msg.rootDelay) > 1.0d || Math.abs(msg.rootDispersion) > 1.0d) {\r\n            if (log != null && log.shouldWarn())\r\n                log.warn(\"Failed sanity checks:\\n\" + msg);\r\n            return null;\r\n        }\r\n        if (msg.stratum == 0) {\r\n            why = msg.referenceIdentifierToString();\r\n            kisses.put(who, why);\r\n            if (log != null)\r\n                log.logAlways(Log.WARN, \"KoD from NTP server \" + serverName + \" (\" + who + \") \" + why);\r\n            return null;\r\n        }\r\n        double localClockOffset = ((msg.receiveTimestamp - msg.originateTimestamp) + (msg.transmitTimestamp - destinationTimestamp)) / 2;\r\n        long[] rv = new long[2];\r\n        rv[0] = (long) (System.currentTimeMillis() + localClockOffset * 1000);\r\n        rv[1] = msg.stratum;\r\n        if (log != null && log.shouldInfo()) {\r\n            double roundTripDelay = (destinationTimestamp - msg.originateTimestamp) - (msg.receiveTimestamp - msg.transmitTimestamp);\r\n            log.info(\"host: \" + packet.getAddress().getHostAddress() + \" rtt: \" + roundTripDelay + \" offset: \" + localClockOffset + \" seconds\");\r\n        }\r\n        return rv;\r\n    } catch (IOException ioe) {\r\n        if (log != null && log.shouldWarn())\r\n            log.warn(\"NTP failure from \" + serverName, ioe);\r\n        return null;\r\n    } finally {\r\n        if (socket != null)\r\n            socket.close();\r\n    }\r\n}"
}, {
	"Path": "net.i2p.data.i2np.BuildRequestRecord.readNextIdentity",
	"Comment": "read the next hop from the record.if this is the outbound tunnel endpoint, this specifiesthe gateway to which the reply should be sent.",
	"Method": "Hash readNextIdentity(){\r\n    return Hash.create(_data, OFF_SEND_IDENT);\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.doctrine.metadata.util.DoctrineMetadataUtil.getClassRepository",
	"Comment": "try to find repository class on models scope on its metadata definition",
	"Method": "PhpClass getClassRepository(Project project,String className){\r\n    for (VirtualFile virtualFile : FileBasedIndex.getInstance().getContainingFiles(DoctrineMetadataFileStubIndex.KEY, className, GlobalSearchScope.allScope(project))) {\r\n        final String[] phpClass = { null };\r\n        FileBasedIndex.getInstance().processValues(DoctrineMetadataFileStubIndex.KEY, className, virtualFile, (virtualFile1, model) -> {\r\n            if (phpClass[0] != null || model == null || model.getRepositoryClass() == null) {\r\n                return true;\r\n            }\r\n            phpClass[0] = model.getRepositoryClass();\r\n            return true;\r\n        }, GlobalSearchScope.allScope(project));\r\n        if (phpClass[0] != null) {\r\n            return PhpElementsUtil.getClassInsideNamespaceScope(project, className, phpClass[0]);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.i2p.router.CommSystemFacade.getFramedAveragePeerClockSkew",
	"Comment": "return framed average clock skew of connected peers in seconds, or null if we cannot answer.commsystemfacadeimpl overrides this.",
	"Method": "long getFramedAveragePeerClockSkew(int percentToInclude){\r\n    return 0;\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.GunzipOutputStream.verifyHeader",
	"Comment": "make sure the header is valid, throwing an ioexception if it is bad.pushes through the state machine, checking as we go.call for each byte until headerstate is done.",
	"Method": "void verifyHeader(byte b){\r\n    int c = b & 0xff;\r\n    switch(_state) {\r\n        case MB1:\r\n            if (c != 0x1F)\r\n                throw new IOException(\"First magic byte was wrong [\" + c + \"]\");\r\n            _state = HeaderState.MB2;\r\n            break;\r\n        case MB2:\r\n            if (c != 0x8B)\r\n                throw new IOException(\"Second magic byte was wrong [\" + c + \"]\");\r\n            _state = HeaderState.CF;\r\n            break;\r\n        case CF:\r\n            if (c != 0x08)\r\n                throw new IOException(\"Compression format is invalid [\" + c + \"]\");\r\n            _state = HeaderState.FLAGS;\r\n            break;\r\n        case FLAGS:\r\n            _flags = c;\r\n            _state = HeaderState.MT0;\r\n            break;\r\n        case MT0:\r\n            _state = HeaderState.MT1;\r\n            break;\r\n        case MT1:\r\n            _state = HeaderState.MT2;\r\n            break;\r\n        case MT2:\r\n            _state = HeaderState.MT3;\r\n            break;\r\n        case MT3:\r\n            _state = HeaderState.EF;\r\n            break;\r\n        case EF:\r\n            if ((c != 0x00) && (c != 0x02) && (c != 0x04))\r\n                throw new IOException(\"Invalid extended flags [\" + c + \"]\");\r\n            _state = HeaderState.OS;\r\n            break;\r\n        case OS:\r\n            if (0 != (_flags & (1 << 5)))\r\n                _state = HeaderState.EH1;\r\n            else if (0 != (_flags & (1 << 4)))\r\n                _state = HeaderState.NAME;\r\n            else if (0 != (_flags & (1 << 3)))\r\n                _state = HeaderState.COMMENT;\r\n            else if (0 != (_flags & (1 << 6)))\r\n                _state = HeaderState.CRC1;\r\n            else\r\n                _state = HeaderState.DONE;\r\n            break;\r\n        case EH1:\r\n            _extHdrToRead = c;\r\n            _state = HeaderState.EH2;\r\n            break;\r\n        case EH2:\r\n            _extHdrToRead += (c << 8);\r\n            if (_extHdrToRead > 0)\r\n                _state = HeaderState.EHDATA;\r\n            else if (0 != (_flags & (1 << 4)))\r\n                _state = HeaderState.NAME;\r\n            if (0 != (_flags & (1 << 3)))\r\n                _state = HeaderState.COMMENT;\r\n            else if (0 != (_flags & (1 << 6)))\r\n                _state = HeaderState.CRC1;\r\n            else\r\n                _state = HeaderState.DONE;\r\n            break;\r\n        case EHDATA:\r\n            if (--_extHdrToRead <= 0) {\r\n                if (0 != (_flags & (1 << 4)))\r\n                    _state = HeaderState.NAME;\r\n                if (0 != (_flags & (1 << 3)))\r\n                    _state = HeaderState.COMMENT;\r\n                else if (0 != (_flags & (1 << 6)))\r\n                    _state = HeaderState.CRC1;\r\n                else\r\n                    _state = HeaderState.DONE;\r\n            }\r\n            break;\r\n        case NAME:\r\n            if (c == 0) {\r\n                if (0 != (_flags & (1 << 3)))\r\n                    _state = HeaderState.COMMENT;\r\n                else if (0 != (_flags & (1 << 6)))\r\n                    _state = HeaderState.CRC1;\r\n                else\r\n                    _state = HeaderState.DONE;\r\n            }\r\n            break;\r\n        case COMMENT:\r\n            if (c == 0) {\r\n                if (0 != (_flags & (1 << 6)))\r\n                    _state = HeaderState.CRC1;\r\n                else\r\n                    _state = HeaderState.DONE;\r\n            }\r\n            break;\r\n        case CRC1:\r\n            _state = HeaderState.CRC2;\r\n            break;\r\n        case CRC2:\r\n            _state = HeaderState.DONE;\r\n            break;\r\n        case DONE:\r\n        default:\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "net.i2p.stat.FrequencyStat.store",
	"Comment": "serializes this frequencystat to the provided outputstream",
	"Method": "void store(OutputStream out,String prefix){\r\n    StringBuilder buf = new StringBuilder(1024);\r\n    buf.append(NL);\r\n    buf.append(\"################################################################################\").append(NL);\r\n    buf.append(\"# Frequency: \").append(_groupName).append(\": \").append(_statName).append(NL);\r\n    buf.append(\"# \").append(_description).append(NL);\r\n    buf.append(\"# \").append(NL).append(NL);\r\n    out.write(buf.toString().getBytes(\"UTF-8\"));\r\n    buf.setLength(0);\r\n    for (Frequency r : _frequencies) {\r\n        buf.append(\"#######\").append(NL);\r\n        buf.append(\"# Period : \").append(DataHelper.formatDuration(r.getPeriod())).append(\" for rate \").append(_groupName).append(\" - \").append(_statName).append(NL);\r\n        buf.append(NL);\r\n        r.store(buf);\r\n        out.write(buf.toString().getBytes(\"UTF-8\"));\r\n        buf.setLength(0);\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.core.Util.getJRobinDemoDirectory",
	"Comment": "returns path to directory used for placement of jrobin demo graphs and creates it\tif necessary.",
	"Method": "String getJRobinDemoDirectory(){\r\n    final String homeDirPath = getUserHomeDirectory() + JROBIN_DIR + getFileSeparator();\r\n    final File homeDirFile = new File(homeDirPath);\r\n    return (homeDirFile.exists() || homeDirFile.mkdirs()) ? homeDirPath : null;\r\n}"
}, {
	"Path": "com.spotify.heroic.CoreQueryManager.toleranceShiftPeriod",
	"Comment": "calculate a tolerance shift period that corresponds to the given difference that needs to beapplied to the range to honor the tolerance shift period.",
	"Method": "long toleranceShiftPeriod(long diff,long cadence){\r\n    if (cadence <= 0L) {\r\n        return diff;\r\n    }\r\n    return ((diff + cadence - 1) / cadence) * cadence;\r\n}"
}, {
	"Path": "net.i2p.util.InternalServerSocket.getChannel",
	"Comment": "returns null as of 0.9.33, prior to that threw illegalargumentexception",
	"Method": "ServerSocketChannel getChannel(){\r\n    return null;\r\n}"
}, {
	"Path": "io.helidon.security.Subject.builder",
	"Comment": "creates a fluent api builder to build new instances of this class.",
	"Method": "Builder builder(){\r\n    return new Builder();\r\n}"
}, {
	"Path": "io.helidon.security.SecurityEnvironment.builder",
	"Comment": "creates a fluent api builder to build new instances of this class with current time.",
	"Method": "Builder builder(SecurityTime serverTime,Builder builder){\r\n    return new Builder(SecurityTime.create());\r\n}"
}, {
	"Path": "com.netflix.hollow.core.memory.ByteArrayOrdinalMap.findFreeOrdinal",
	"Comment": "if the preferredordinal has not already been used, mark it and use it.otherwise, delegate to the freeordinaltracker.",
	"Method": "int findFreeOrdinal(int preferredOrdinal){\r\n    if (preferredOrdinal != -1 && unusedPreviousOrdinals.get(preferredOrdinal)) {\r\n        unusedPreviousOrdinals.clear(preferredOrdinal);\r\n        return preferredOrdinal;\r\n    }\r\n    return freeOrdinalTracker.getFreeOrdinal();\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.highlighter.IgnoreColorSettingsPage.getHighlighter",
	"Comment": "returns the syntax highlighter which is used to highlight the text shown in the previewpane of the page.",
	"Method": "SyntaxHighlighter getHighlighter(){\r\n    return new IgnoreHighlighter(null, null);\r\n}"
}, {
	"Path": "com.spotify.heroic.aggregation.AggregationInstance.session",
	"Comment": "traverse the possible aggregations and build the necessary graph out of them.",
	"Method": "AggregationSession session(DateRange range,AggregationSession session,DateRange range,RetainQuotaWatcher quotaWatcher,BucketStrategy bucketStrategy){\r\n    return session(range, RetainQuotaWatcher.NO_QUOTA, BucketStrategy.START);\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.ProfileManagerImpl.dbStoreReceived",
	"Comment": "note that the local router received an unprompted db store from the given peer",
	"Method": "void dbStoreReceived(Hash peer,boolean wasNewKey){\r\n    PeerProfile data = getProfile(peer);\r\n    data.setLastHeardFrom(_context.clock().now());\r\n    if (!data.getIsExpandedDB())\r\n        return;\r\n    DBHistory hist = data.getDBHistory();\r\n    hist.unpromptedStoreReceived(wasNewKey);\r\n}"
}, {
	"Path": "net.i2p.data.i2np.I2NPMessageImpl.createMessage",
	"Comment": "yes, this is fairly ugly, but its the only place it ever happens.",
	"Method": "I2NPMessage createMessage(I2PAppContext context,int type){\r\n    switch(type) {\r\n        case DatabaseStoreMessage.MESSAGE_TYPE:\r\n            return new DatabaseStoreMessage(context);\r\n        case DatabaseLookupMessage.MESSAGE_TYPE:\r\n            return new DatabaseLookupMessage(context);\r\n        case DatabaseSearchReplyMessage.MESSAGE_TYPE:\r\n            return new DatabaseSearchReplyMessage(context);\r\n        case DeliveryStatusMessage.MESSAGE_TYPE:\r\n            return new DeliveryStatusMessage(context);\r\n        case GarlicMessage.MESSAGE_TYPE:\r\n            return new GarlicMessage(context);\r\n        case TunnelDataMessage.MESSAGE_TYPE:\r\n            return new TunnelDataMessage(context);\r\n        case TunnelGatewayMessage.MESSAGE_TYPE:\r\n            return new TunnelGatewayMessage(context);\r\n        case DataMessage.MESSAGE_TYPE:\r\n            return new DataMessage(context);\r\n        case TunnelBuildMessage.MESSAGE_TYPE:\r\n            return new TunnelBuildMessage(context);\r\n        case TunnelBuildReplyMessage.MESSAGE_TYPE:\r\n            return new TunnelBuildReplyMessage(context);\r\n        case VariableTunnelBuildMessage.MESSAGE_TYPE:\r\n            return new VariableTunnelBuildMessage(context);\r\n        case VariableTunnelBuildReplyMessage.MESSAGE_TYPE:\r\n            return new VariableTunnelBuildReplyMessage(context);\r\n        default:\r\n            Builder builder = _builders.get(Integer.valueOf(type));\r\n            if (builder != null)\r\n                return builder.build(context);\r\n            return new UnknownI2NPMessage(context, type);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.EstablishmentManager.sendConfirmation",
	"Comment": "note that while a sessionconfirmed could in theory be fragmented, in practice a routeridentity is 387 bytes and a single fragment is 512 bytes max, so it will never be fragmented. caller should probably synch on state.",
	"Method": "void sendConfirmation(OutboundEstablishState state){\r\n    boolean valid = state.validateSessionCreated();\r\n    if (!valid) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"SessionCreated validate failed: \" + state);\r\n        return;\r\n    }\r\n    if (!_transport.isValid(state.getReceivedIP()) || !_transport.isValid(state.getRemoteHostId().getIP())) {\r\n        state.fail();\r\n        return;\r\n    }\r\n    _transport.externalAddressReceived(state.getRemoteIdentity().calculateHash(), state.getReceivedIP(), state.getReceivedPort());\r\n    state.prepareSessionConfirmed();\r\n    UDPPacket[] packets = _builder.buildSessionConfirmedPackets(state, _context.router().getRouterInfo().getIdentity());\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Send confirm to: \" + state);\r\n    for (int i = 0; i < packets.length; i++) _transport.send(packets[i]);\r\n    state.confirmedPacketsSent();\r\n}"
}, {
	"Path": "net.i2p.sam.SAMStreamSession.checkSocketHandlerId",
	"Comment": "check whether a sam stream session socket handler id is still in use.",
	"Method": "boolean checkSocketHandlerId(int id){\r\n    synchronized (handlersMap) {\r\n        return (!(handlersMap.get(Integer.valueOf(id)) == null));\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.startup.MigrateJetty.migrate",
	"Comment": "for each entry in apps, if the main class is an old jetty class, migrate it to the new jetty class, and update the jetty config files.",
	"Method": "void migrate(RouterContext ctx,List<ClientAppConfig> apps){\r\n    if (ctx.getBooleanProperty(PROP_JETTY9_MIGRATED))\r\n        return;\r\n    String installed = ctx.getProperty(\"router.firstVersion\");\r\n    if (installed != null && VersionComparator.comp(installed, \"0.9.30\") >= 0) {\r\n        ctx.router().saveConfig(PROP_JETTY9_MIGRATED, \"true\");\r\n        return;\r\n    }\r\n    boolean shouldSave = false;\r\n    boolean jetty9success = false;\r\n    for (int i = 0; i < apps.size(); i++) {\r\n        ClientAppConfig app = apps.get(i);\r\n        String client;\r\n        String backupSuffix;\r\n        if (app.className.equals(NEW_CLASS)) {\r\n            client = \"client application \" + i + \" [\" + app.clientName + \"] from Jetty 7/8 to Jetty 9\";\r\n            backupSuffix = BACKUP_SUFFIX_8;\r\n        } else if (app.className.equals(OLD_CLASS) || app.className.equals(OLD_CLASS_6)) {\r\n            client = \"client application \" + i + \" [\" + app.clientName + \"] from Jetty 5/6 \" + app.className + \" to Jetty 9 \" + NEW_CLASS;\r\n            backupSuffix = BACKUP_SUFFIX;\r\n        } else {\r\n            continue;\r\n        }\r\n        if (!hasLatestJetty()) {\r\n            System.err.println(\"WARNING: Jetty 7 unavailable, cannot migrate \" + client);\r\n            continue;\r\n        }\r\n        if (app.args == null)\r\n            continue;\r\n        String[] args = LoadClientAppsJob.parseArgs(app.args);\r\n        if (args.length == 0)\r\n            continue;\r\n        String xml = args[0];\r\n        File xmlFile = new File(xml);\r\n        if (!xmlFile.isAbsolute())\r\n            xmlFile = new File(ctx.getAppDir(), xml);\r\n        if (!xmlFile.exists()) {\r\n            System.err.println(\"WARNING: XML file \" + xmlFile + \" not found, cannot migrate \" + client);\r\n            continue;\r\n        }\r\n        File eepsite = xmlFile.getParentFile();\r\n        boolean ok = backupFile(xmlFile, backupSuffix);\r\n        if (!ok) {\r\n            System.err.println(\"WARNING: Failed to backup up XML file \" + xmlFile + \", cannot migrate \" + client);\r\n            continue;\r\n        }\r\n        if (app.className.equals(NEW_CLASS)) {\r\n            for (int j = 0; j < args.length; j++) {\r\n                if (j > 0) {\r\n                    xmlFile = new File(args[j]);\r\n                    ok = backupFile(xmlFile, backupSuffix);\r\n                    if (!ok) {\r\n                        System.err.println(\"WARNING: Failed to backup up XML file \" + xmlFile + \", cannot migrate \" + client);\r\n                        continue;\r\n                    }\r\n                }\r\n                boolean ok9 = migrateToJetty9(xmlFile);\r\n                if (ok9) {\r\n                    System.err.println(\"WARNING: Migrated \" + client + \".\\n\" + \"Check the \" + xmlFile.getName() + \" file in \" + eepsite + \".\\n\" + \"Your old \" + xmlFile.getName() + \" file was backed up to \" + xmlFile.getAbsolutePath() + BACKUP_SUFFIX_8);\r\n                    jetty9success = true;\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n        File baseEep = new File(ctx.getBaseDir(), JETTY_TEMPLATE_DIR);\r\n        if (!baseEep.exists())\r\n            baseEep = new File(ctx.getBaseDir(), JETTY_TEMPLATE_PKGDIR);\r\n        if (baseEep.equals(eepsite)) {\r\n            System.err.println(\"Eepsite in non-split directory \" + eepsite + \", cannot migrate \" + client);\r\n            continue;\r\n        }\r\n        File baseContext = new File(baseEep, BASE_CONTEXT);\r\n        if (!baseContext.exists()) {\r\n            System.err.println(\"WARNING: Cannot find new XML file template \" + baseContext + \", cannot migrate \" + client);\r\n            continue;\r\n        }\r\n        String newPath = eepsite.getAbsolutePath() + File.separatorChar;\r\n        ok = WorkingDir.migrateJettyXml(baseEep, eepsite, \"jetty.xml\", \"./eepsite/\", newPath);\r\n        if (!ok) {\r\n            System.err.println(\"WARNING: Failed to modify XML file \" + xmlFile + \", cannot migrate \" + client);\r\n            continue;\r\n        }\r\n        backupAndMigrateFile(baseEep, eepsite, \"jetty-ssl.xml\", \"./eepsite/\", newPath);\r\n        (new File(eepsite, \"contexts\")).mkdir();\r\n        backupAndMigrateFile(baseEep, eepsite, BASE_CONTEXT, \"./eepsite/\", newPath);\r\n        backupAndMigrateFile(baseEep, eepsite, CGI_CONTEXT, \"./eepsite/\", newPath);\r\n        backupAndCopyFile(baseEep, eepsite, \"jetty-rewrite.xml\");\r\n        (new File(eepsite, \"etc\")).mkdir();\r\n        File to = new File(eepsite, \"etc/realm.properties\");\r\n        if (!to.exists())\r\n            WorkingDir.copyFile(new File(baseEep, \"etc/realm.properties\"), to);\r\n        backupAndCopyFile(baseEep, eepsite, \"etc/webdefault.xml\");\r\n        app.className = NEW_CLASS;\r\n        shouldSave = true;\r\n        System.err.println(\"WARNING: Migrated \" + client + '\\n' + \"Check the following files in \" + eepsite + \": jetty.xml, \" + BASE_CONTEXT + \", and \" + CGI_CONTEXT + \"\\n\" + \"Your old jetty.xml was backed up.\" + '\\n' + \"If you modified your jetty.xml to change ports, thread limits, etc, you MUST\\n\" + \"edit it to change them again. Your port was reset to 7658.\");\r\n    }\r\n    if (shouldSave) {\r\n        File cfgFile = ClientAppConfig.configFile(ctx);\r\n        boolean ok = backupFile(cfgFile);\r\n        if (ok) {\r\n            ClientAppConfig.writeClientAppConfig(ctx, apps);\r\n            System.err.println(\"WARNING: Migrated clients config file \" + cfgFile + \" from Jetty 5/6 \" + OLD_CLASS + '/' + OLD_CLASS_6 + \" to Jetty 9 \" + NEW_CLASS);\r\n        }\r\n    }\r\n    if (jetty9success)\r\n        ctx.router().saveConfig(PROP_JETTY9_MIGRATED, \"true\");\r\n}"
}, {
	"Path": "net.i2p.crypto.HMACGenerator.verify",
	"Comment": "verify the mac inline, reducing some unnecessary memory churn.",
	"Method": "boolean verify(SessionKey key,byte curData,int curOffset,int curLength,byte origMAC,int origMACOffset,int origMACLength){\r\n    if ((key == null) || (key.getData() == null) || (curData == null))\r\n        throw new NullPointerException(\"Null arguments for HMAC\");\r\n    I2PHMac mac = acquire();\r\n    mac.init(key.getData());\r\n    mac.update(curData, curOffset, curLength);\r\n    byte[] rv = acquireTmp();\r\n    mac.doFinal(rv, 0);\r\n    release(mac);\r\n    boolean eq = DataHelper.eqCT(rv, 0, origMAC, origMACOffset, origMACLength);\r\n    releaseTmp(rv);\r\n    return eq;\r\n}"
}, {
	"Path": "net.i2p.router.web.helpers.StatHelper.getProfile",
	"Comment": "look up based on a b64 prefix or full b64. prefix is inefficient.",
	"Method": "String getProfile(){\r\n    if (_peer == null || _peer.length() <= 0)\r\n        return \"No peer specified\";\r\n    if (_peer.length() >= 44)\r\n        return outputProfile();\r\n    Set<Hash> peers = _context.profileOrganizer().selectAllPeers();\r\n    for (Hash peer : peers) {\r\n        if (peer.toBase64().startsWith(_peer)) {\r\n            return dumpProfile(peer);\r\n        }\r\n    }\r\n    return \"Unknown peer \" + _peer;\r\n}"
}, {
	"Path": "net.nicoulaj.idea.markdown.highlighter.MarkdownColorSettingsPage.getHighlighter",
	"Comment": "get the syntax highlighter which is used to highlight the text shown in the previewpane of the page.",
	"Method": "SyntaxHighlighter getHighlighter(){\r\n    return new MarkdownSyntaxHighlighter();\r\n}"
}, {
	"Path": "net.i2p.crypto.eddsa.math.ed25519.Ed25519LittleEndianEncoding.decode",
	"Comment": "decodes a given field element in its 10 byte 2^25.5 representation.",
	"Method": "FieldElement decode(byte[] in){\r\n    long h0 = load_4(in, 0);\r\n    long h1 = load_3(in, 4) << 6;\r\n    long h2 = load_3(in, 7) << 5;\r\n    long h3 = load_3(in, 10) << 3;\r\n    long h4 = load_3(in, 13) << 2;\r\n    long h5 = load_4(in, 16);\r\n    long h6 = load_3(in, 20) << 7;\r\n    long h7 = load_3(in, 23) << 5;\r\n    long h8 = load_3(in, 26) << 4;\r\n    long h9 = (load_3(in, 29) & 0x7FFFFF) << 2;\r\n    long carry0;\r\n    long carry1;\r\n    long carry2;\r\n    long carry3;\r\n    long carry4;\r\n    long carry5;\r\n    long carry6;\r\n    long carry7;\r\n    long carry8;\r\n    long carry9;\r\n    carry9 = (h9 + (long) (1 << 24)) >> 25;\r\n    h0 += carry9 * 19;\r\n    h9 -= carry9 << 25;\r\n    carry1 = (h1 + (long) (1 << 24)) >> 25;\r\n    h2 += carry1;\r\n    h1 -= carry1 << 25;\r\n    carry3 = (h3 + (long) (1 << 24)) >> 25;\r\n    h4 += carry3;\r\n    h3 -= carry3 << 25;\r\n    carry5 = (h5 + (long) (1 << 24)) >> 25;\r\n    h6 += carry5;\r\n    h5 -= carry5 << 25;\r\n    carry7 = (h7 + (long) (1 << 24)) >> 25;\r\n    h8 += carry7;\r\n    h7 -= carry7 << 25;\r\n    carry0 = (h0 + (long) (1 << 25)) >> 26;\r\n    h1 += carry0;\r\n    h0 -= carry0 << 26;\r\n    carry2 = (h2 + (long) (1 << 25)) >> 26;\r\n    h3 += carry2;\r\n    h2 -= carry2 << 26;\r\n    carry4 = (h4 + (long) (1 << 25)) >> 26;\r\n    h5 += carry4;\r\n    h4 -= carry4 << 26;\r\n    carry6 = (h6 + (long) (1 << 25)) >> 26;\r\n    h7 += carry6;\r\n    h6 -= carry6 << 26;\r\n    carry8 = (h8 + (long) (1 << 25)) >> 26;\r\n    h9 += carry8;\r\n    h8 -= carry8 << 26;\r\n    int[] h = new int[10];\r\n    h[0] = (int) h0;\r\n    h[1] = (int) h1;\r\n    h[2] = (int) h2;\r\n    h[3] = (int) h3;\r\n    h[4] = (int) h4;\r\n    h[5] = (int) h5;\r\n    h[6] = (int) h6;\r\n    h[7] = (int) h7;\r\n    h[8] = (int) h8;\r\n    h[9] = (int) h9;\r\n    return new Ed25519FieldElement(f, h);\r\n}"
}, {
	"Path": "com.spotify.heroic.consumer.pubsub.Connection.setEmulatorOptions",
	"Comment": "determine if a pubsub emulator should be used instead of a live connection. sets the appropriateoptions on the builder when using the emulator.",
	"Method": "void setEmulatorOptions(){\r\n    String host = System.getenv(\"PUBSUB_EMULATOR_HOST\");\r\n    if (host == null) {\r\n        return;\r\n    }\r\n    log.info(\"PubSub emulator detected at {}\", host);\r\n    ManagedChannel channel = ManagedChannelBuilder.forTarget(host).usePlaintext().build();\r\n    channelProvider = FixedTransportChannelProvider.create(GrpcTransportChannel.create(channel));\r\n    credentialsProvider = NoCredentialsProvider.create();\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.MessageInputStream.read",
	"Comment": "on a read timeout, this throws a sockettimeoutexception as of 0.9.36. prior to that, returned 0.",
	"Method": "int read(int read,byte target,int read,byte target,int offset,int length){\r\n    int readTimeout = _readTimeout;\r\n    long expiration;\r\n    if (readTimeout > 0)\r\n        expiration = readTimeout + System.currentTimeMillis();\r\n    else\r\n        expiration = -1;\r\n    final boolean shouldDebug = _log.shouldDebug();\r\n    synchronized (_dataLock) {\r\n        if (_locallyClosed)\r\n            throw new IOException(\"Input stream closed\");\r\n        throwAnyError();\r\n        int i = 0;\r\n        while (i < length) {\r\n            if ((_readyDataBlocks.isEmpty()) && (i == 0)) {\r\n                while (_readyDataBlocks.isEmpty()) {\r\n                    if (_locallyClosed)\r\n                        throw new IOException(\"Input stream closed\");\r\n                    if ((_notYetReadyBlocks.isEmpty()) && (_closeReceived)) {\r\n                        if (_log.shouldLog(Log.INFO))\r\n                            _log.info(\"read(...,\" + offset + \", \" + length + \")[\" + i + \"] got EOF after \" + _readTotal + \": \" + hashCode());\r\n                        return -1;\r\n                    } else {\r\n                        if (readTimeout < 0) {\r\n                            if (shouldDebug)\r\n                                _log.debug(\"read(...,\" + offset + \", \" + length + \")[\" + i + \"] wait w/o timeout: \" + hashCode());\r\n                            try {\r\n                                _dataLock.wait();\r\n                            } catch (InterruptedException ie) {\r\n                                IOException ioe2 = new InterruptedIOException(\"Interrupted read\");\r\n                                ioe2.initCause(ie);\r\n                                throw ioe2;\r\n                            }\r\n                            if (shouldDebug)\r\n                                _log.debug(\"read(...,\" + offset + \", \" + length + \")[\" + i + \"] wait w/o timeout complete: \" + hashCode());\r\n                            throwAnyError();\r\n                        } else if (readTimeout > 0) {\r\n                            if (shouldDebug)\r\n                                _log.debug(\"read(...,\" + offset + \", \" + length + \")[\" + i + \"] wait: \" + readTimeout + \": \" + hashCode());\r\n                            try {\r\n                                _dataLock.wait(readTimeout);\r\n                            } catch (InterruptedException ie) {\r\n                                IOException ioe2 = new InterruptedIOException(\"Interrupted read\");\r\n                                ioe2.initCause(ie);\r\n                                throw ioe2;\r\n                            }\r\n                            if (shouldDebug)\r\n                                _log.debug(\"read(...,\" + offset + \", \" + length + \")[\" + i + \"] wait complete: \" + readTimeout + \": \" + hashCode());\r\n                            throwAnyError();\r\n                        } else {\r\n                            if (shouldDebug)\r\n                                _log.debug(\"read(...,\" + offset + \", \" + length + \")[\" + i + \"] nonblocking return: \" + hashCode());\r\n                            return 0;\r\n                        }\r\n                        if (_readyDataBlocks.isEmpty()) {\r\n                            if (readTimeout > 0) {\r\n                                long remaining = expiration - System.currentTimeMillis();\r\n                                if (remaining <= 0) {\r\n                                    if (_log.shouldLog(Log.INFO))\r\n                                        _log.info(\"read(...,\" + offset + \", \" + length + \")[\" + i + \"] timed out: \" + hashCode());\r\n                                    throw new SocketTimeoutException();\r\n                                } else {\r\n                                    readTimeout = (int) remaining;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else if (_readyDataBlocks.isEmpty()) {\r\n                if (shouldDebug)\r\n                    _log.debug(\"read(...,\" + offset + \", \" + length + \")[\" + i + \"] no more ready blocks, returning: \" + hashCode());\r\n                return i;\r\n            } else {\r\n                ByteArray cur = _readyDataBlocks.get(0);\r\n                int toRead = Math.min(cur.getValid() - _readyDataBlockIndex, length - i);\r\n                System.arraycopy(cur.getData(), cur.getOffset() + _readyDataBlockIndex, target, offset + i, toRead);\r\n                _readyDataBlockIndex += toRead;\r\n                if (cur.getValid() <= _readyDataBlockIndex) {\r\n                    _readyDataBlockIndex = 0;\r\n                    _readyDataBlocks.remove(0);\r\n                }\r\n                _readTotal += toRead;\r\n                if (shouldDebug) {\r\n                    _log.debug(\"read(...,\" + offset + \", \" + length + \")[\" + i + \"] copied \" + toRead + \" after ready data: readyDataBlockIndex=\" + _readyDataBlockIndex + \" readyBlocks=\" + _readyDataBlocks.size() + \" readTotal=\" + _readTotal + \": \" + hashCode());\r\n                }\r\n                i += toRead;\r\n            }\r\n        }\r\n    }\r\n    if (shouldDebug)\r\n        _log.debug(\"read(byte[],\" + offset + ',' + length + \") read fully; total read: \" + _readTotal);\r\n    return length;\r\n}"
}, {
	"Path": "net.i2p.router.transport.CommSystemFacadeImpl.mayDisconnect",
	"Comment": "tell the comm system that we may disconnect from this peer.this is advisory only.",
	"Method": "void mayDisconnect(Hash peer){\r\n    _manager.mayDisconnect(peer);\r\n}"
}, {
	"Path": "com.netflix.hollow.core.write.HollowBlobWriter.writeReverseDelta",
	"Comment": "serialize the changes necessary to transition a consumer from the current state to theprevious state as a delta blob.",
	"Method": "void writeReverseDelta(OutputStream os){\r\n    stateEngine.prepareForWrite();\r\n    if (stateEngine.isRestored())\r\n        stateEngine.ensureAllNecessaryStatesRestored();\r\n    List<HollowSchema> changedTypes = changedTypes();\r\n    DataOutputStream dos = new DataOutputStream(os);\r\n    writeHeader(dos, changedTypes, true);\r\n    VarInt.writeVInt(dos, changedTypes.size());\r\n    SimultaneousExecutor executor = new SimultaneousExecutor();\r\n    for (final HollowTypeWriteState typeState : stateEngine.getOrderedTypeStates()) {\r\n        executor.execute(new Runnable() {\r\n            public void run() {\r\n                if (typeState.hasChangedSinceLastCycle())\r\n                    typeState.calculateReverseDelta();\r\n            }\r\n        });\r\n    }\r\n    try {\r\n        executor.awaitSuccessfulCompletion();\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    for (HollowTypeWriteState typeState : stateEngine.getOrderedTypeStates()) {\r\n        if (typeState.hasChangedSinceLastCycle()) {\r\n            HollowSchema schema = typeState.getSchema();\r\n            schema.writeTo(dos);\r\n            writeNumShards(dos, typeState.getNumShards());\r\n            typeState.writeReverseDelta(dos);\r\n        }\r\n    }\r\n    os.flush();\r\n}"
}, {
	"Path": "com.netflix.hollow.core.write.HollowBlobWriter.writeReverseDelta",
	"Comment": "serialize the changes necessary to transition a consumer from the current state to theprevious state as a delta blob.",
	"Method": "void writeReverseDelta(OutputStream os){\r\n    if (typeState.hasChangedSinceLastCycle())\r\n        typeState.calculateReverseDelta();\r\n}"
}, {
	"Path": "net.i2p.BOB.TCPio.run",
	"Comment": "copy from source to destination...\tand yes, we are totally ok to block here on writes,\tthe os has buffers, and i intend to use them.\twe send an interrupt signal to the threadgroup to\tunwedge any pending writes.",
	"Method": "void run(){\r\n    int b;\r\n    byte[] a = new byte[8192];\r\n    try {\r\n        try {\r\n            while (lives.get()) {\r\n                b = Ain.read(a, 0, 8192);\r\n                if (b > 0) {\r\n                    Aout.write(a, 0, b);\r\n                } else if (b == 0) {\r\n                    while (Ain.available() == 0) {\r\n                        Thread.sleep(20);\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n        }\r\n    } finally {\r\n        try {\r\n            Ain.close();\r\n        } catch (IOException ex) {\r\n        }\r\n        try {\r\n            Aout.close();\r\n        } catch (IOException ex) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.sam.client.SAMEventHandler.waitForStreamStatusReply",
	"Comment": "wait for the stream to be created, returning true if everything went ok",
	"Method": "boolean waitForStreamStatusReply(){\r\n    while (true) {\r\n        try {\r\n            synchronized (_streamStatusLock) {\r\n                if (_streamStatusOk == null)\r\n                    _streamStatusLock.wait();\r\n                else\r\n                    return _streamStatusOk.booleanValue();\r\n            }\r\n        } catch (InterruptedException ie) {\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.graph.RrdGraphDef.setAntiAliasing",
	"Comment": "controls if the chart area of the image should be antialiased or not.",
	"Method": "void setAntiAliasing(boolean antiAliasing){\r\n    this.antiAliasing = antiAliasing;\r\n}"
}, {
	"Path": "com.netflix.hollow.core.util.SimultaneousExecutor.awaitSuccessfulCompletionOfCurrentTasks",
	"Comment": "await successful completion of all previously submitted tasks.throw exception of the first failed taskif 1 or more tasks failed.after this call completes, the thread pool will not be shut down and can be reused.",
	"Method": "void awaitSuccessfulCompletionOfCurrentTasks(){\r\n    for (Future<?> f : futures) {\r\n        f.get();\r\n    }\r\n    futures.clear();\r\n}"
}, {
	"Path": "net.i2p.util.InternalSocket.getPort",
	"Comment": "supported as of 0.9.33, prior to that threw unsupportedoperationexception",
	"Method": "int getPort(){\r\n    return isConnected() ? _port : 0;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.InboundEstablishState.confirmedFullyReceived",
	"Comment": "have we fully received the sessionconfirmed messages from alice? caller must synch on this.",
	"Method": "boolean confirmedFullyReceived(){\r\n    if (_receivedIdentity != null) {\r\n        for (int i = 0; i < _receivedIdentity.length; i++) {\r\n            if (_receivedIdentity[i] == null)\r\n                return false;\r\n        }\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.klomp.snark.PeerCoordinator.gotRequest",
	"Comment": "returns a byte array containing the requested piece or null ofthe piece is unknown.",
	"Method": "ByteArray gotRequest(Peer peer,int piece,int off,int len){\r\n    if (halted)\r\n        return null;\r\n    if (metainfo == null || storage == null)\r\n        return null;\r\n    try {\r\n        return storage.getPiece(piece, off, len);\r\n    } catch (IOException ioe) {\r\n        snark.stopTorrent();\r\n        String msg = \"Error reading the storage (piece \" + piece + \") for \" + metainfo.getName() + \": \" + ioe;\r\n        _log.error(msg, ioe);\r\n        if (listener != null) {\r\n            listener.addMessage(msg);\r\n            listener.addMessage(\"Fatal storage error: Stopping torrent \" + metainfo.getName());\r\n        }\r\n        throw new RuntimeException(msg, ioe);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.JobQueue.getLastJob",
	"Comment": "retrieve the most recently begin and still currently active job, or null ifno jobs are running",
	"Method": "Job getLastJob(){\r\n    Job j = null;\r\n    long when = -1;\r\n    for (JobQueueRunner cur : _queueRunners.values()) {\r\n        if (cur.getLastBegin() > when) {\r\n            j = cur.getCurrentJob();\r\n            when = cur.getLastBegin();\r\n        }\r\n    }\r\n    return j;\r\n}"
}, {
	"Path": "org.jrobin.core.Archive.getStartTime",
	"Comment": "returns current starting timestamp. this value is not constant.",
	"Method": "long getStartTime(){\r\n    final long endTime = getEndTime();\r\n    final long arcStep = getArcStep();\r\n    final long numRows = rows.get();\r\n    return endTime - (numRows - 1) * arcStep;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PacketHandler.receiveNext",
	"Comment": "blocking call to retrieve the next inbound packet, or null if we haveshut down.",
	"Method": "UDPPacket receiveNext(){\r\n    UDPPacket rv = null;\r\n    while (_keepReading && rv == null) {\r\n        try {\r\n            rv = _inboundQueue.take();\r\n        } catch (InterruptedException ie) {\r\n        }\r\n        if (rv != null && rv.getMessageType() == TYPE_POISON)\r\n            return null;\r\n    }\r\n    return rv;\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.ConnThrottler.shouldThrottle",
	"Comment": "checks both individual and total. increments before checking.",
	"Method": "boolean shouldThrottle(Hash h){\r\n    if (_max > 0 && this.counter.increment(h) > _max)\r\n        return true;\r\n    if (_totalMax > 0 && _currentTotal.incrementAndGet() > _totalMax)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "io.helidon.security.SecurityTime.create",
	"Comment": "creates a new security time based on default time zone and current time.",
	"Method": "SecurityTime create(){\r\n    return SecurityTime.builder().build();\r\n}"
}, {
	"Path": "io.helidon.security.oidc.common.OidcConfig.shouldRedirect",
	"Comment": "whether to redirect to identity server if user is not authenticated.",
	"Method": "boolean shouldRedirect(){\r\n    return redirect;\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.util.StringUtils.startWithEqualClassname",
	"Comment": "simple string compare if class name is in same namespacestarting backslash doesnt break equal check",
	"Method": "boolean startWithEqualClassname(String class1,String class2){\r\n    if (class1.startsWith(\"\\\\\")) {\r\n        class1 = class1.substring(1);\r\n    }\r\n    if (class2.startsWith(\"\\\\\")) {\r\n        class2 = class2.substring(1);\r\n    }\r\n    return class1.startsWith(class2);\r\n}"
}, {
	"Path": "net.i2p.router.transport.TransportManager.countActiveSendPeers",
	"Comment": "how many peers are we currently connected to, that we have sent a message to in the last minute. unused for anything, to be removed.",
	"Method": "int countActiveSendPeers(){\r\n    int peers = 0;\r\n    for (Transport t : _transports.values()) {\r\n        peers += t.countActiveSendPeers();\r\n    }\r\n    return peers;\r\n}"
}, {
	"Path": "net.i2p.data.Lease.setGateway",
	"Comment": "configure the router at which the destination can be contacted",
	"Method": "void setGateway(Hash ident){\r\n    _gateway = ident;\r\n}"
}, {
	"Path": "net.i2p.util.EepGet.getETag",
	"Comment": "after fetch, the received value from the server, or null if none. before fetch, and after some errors, may be the value passed in the constructor.",
	"Method": "String getETag(){\r\n    return _etag;\r\n}"
}, {
	"Path": "com.netflix.hollow.tools.compact.HollowCompactor.findCompactionTargets",
	"Comment": "find candidate types for compaction.no two types in the returned set will have a dependency relationship, eitherdirectly or transitively.",
	"Method": "Set<String> findCompactionTargets(){\r\n    List<HollowSchema> schemas = HollowSchemaSorter.dependencyOrderedSchemaList(readEngine.getSchemas());\r\n    Set<String> typesToCompact = new HashSet<String>();\r\n    for (HollowSchema schema : schemas) {\r\n        if (isCompactionCandidate(schema.getName())) {\r\n            if (!candidateIsDependentOnAnyTargetedType(schema.getName(), typesToCompact))\r\n                typesToCompact.add(schema.getName());\r\n        }\r\n    }\r\n    return typesToCompact;\r\n}"
}, {
	"Path": "org.klomp.snark.MetaInfo.getTorrentData",
	"Comment": "called by servlet to save a new torrent file generated from local data",
	"Method": "byte[] getTorrentData(){\r\n    Map<String, Object> m = new HashMap<String, Object>();\r\n    if (announce != null)\r\n        m.put(\"announce\", announce);\r\n    if (announce_list != null)\r\n        m.put(\"announce-list\", announce_list);\r\n    if (comment != null)\r\n        m.put(\"comment\", comment);\r\n    if (created_by != null)\r\n        m.put(\"created by\", created_by);\r\n    if (creation_date != 0)\r\n        m.put(\"creation date\", creation_date / 1000);\r\n    Map<String, BEValue> info = createInfoMap();\r\n    m.put(\"info\", info);\r\n    return BEncoder.bencode(m);\r\n}"
}, {
	"Path": "org.jrobin.core.FetchRequest.getFetchStart",
	"Comment": "returns starting timestamp to be used for the fetch request.",
	"Method": "long getFetchStart(){\r\n    return fetchStart;\r\n}"
}, {
	"Path": "org.klomp.snark.MetaInfo.getNameAndInfoHash",
	"Comment": "efficiently returns the name and the 20 byte sha1 hash of the info dictionary in a torrent filecaller must close stream.",
	"Method": "String getNameAndInfoHash(InputStream in,byte[] infoHashOut){\r\n    BDecoder bd = new BDecoder(in);\r\n    Map<String, BEValue> m = bd.bdecodeMap().getMap();\r\n    BEValue ibev = m.get(\"info\");\r\n    if (ibev == null)\r\n        throw new InvalidBEncodingException(\"Missing info map\");\r\n    Map<String, BEValue> i = ibev.getMap();\r\n    BEValue rvbev = i.get(\"name\");\r\n    if (rvbev == null)\r\n        throw new InvalidBEncodingException(\"Missing name\");\r\n    byte[] h = bd.get_special_map_digest();\r\n    System.arraycopy(h, 0, infoHashOut, 0, 20);\r\n    return rvbev.getString();\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.templating.RenderParameterGotoCompletionRegistrar.getTemplatesForScope",
	"Comment": "extract template names from function, method or annotations",
	"Method": "Collection<String> getTemplatesForScope(PsiElement psiElement){\r\n    PsiElement stringLiteral = psiElement.getParent();\r\n    if (!(stringLiteral instanceof StringLiteralExpression)) {\r\n        return Collections.emptyList();\r\n    }\r\n    PhpPsiElement arrayCreationElement = PhpElementsUtil.getCompletableArrayCreationElement(stringLiteral);\r\n    if (arrayCreationElement == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    Set<String> templates = new HashSet();\r\n    PsiElement parentArrayCreation = arrayCreationElement.getParent();\r\n    if (parentArrayCreation instanceof ParameterList) {\r\n        PsiElement functionReference = parentArrayCreation.getParent();\r\n        if (functionReference instanceof FunctionReference) {\r\n            String name = ((FunctionReference) functionReference).getName();\r\n            if (ARRAY_FUNCTIONS.contains(name)) {\r\n                arrayCreationElement = (PhpPsiElement) functionReference;\r\n            }\r\n        }\r\n    }\r\n    if (parentArrayCreation instanceof PhpReturn) {\r\n        Method method = PsiTreeUtil.getParentOfType(parentArrayCreation, Method.class);\r\n        if (method != null) {\r\n            TemplatesControllerRelatedGotoCollector.visitMethodTemplateNames(method, pair -> templates.add(TwigUtil.normalizeTemplateName(pair.getFirst())));\r\n        }\r\n    } else {\r\n        PsiElement prevSibling = arrayCreationElement.getPrevPsiSibling();\r\n        if (prevSibling != null) {\r\n            String stringValue = PhpElementsUtil.getStringValue(prevSibling);\r\n            if (stringValue != null && stringValue.toLowerCase().endsWith(\".twig\")) {\r\n                templates.add(TwigUtil.normalizeTemplateName(stringValue));\r\n            }\r\n        }\r\n    }\r\n    return templates;\r\n}"
}, {
	"Path": "net.i2p.crypto.TrustedUpdate.needsUpdate",
	"Comment": "checks if the given version is newer than the given current version.",
	"Method": "boolean needsUpdate(String currentVersion,String newVersion){\r\n    return VersionComparator.comp(currentVersion, newVersion) < 0;\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterInfo.getOptionsMap",
	"Comment": "retrieve a set of options or statistics that the router can expose.",
	"Method": "Map<Object, Object> getOptionsMap(){\r\n    return Collections.unmodifiableMap(_options);\r\n}"
}, {
	"Path": "net.i2p.router.message.OutboundClientMessageOneShotJob.selectInboundTunnel",
	"Comment": "pick an arbitrary inbound tunnel for any deliverystatusmessage to come back in",
	"Method": "TunnelInfo selectInboundTunnel(){\r\n    return getContext().tunnelManager().selectInboundTunnel(_from.calculateHash(), _to.calculateHash());\r\n}"
}, {
	"Path": "net.i2p.router.transport.ntcp.NTCPTransport.countActivePeers",
	"Comment": "how many peers have we talked to in the last 5 minutes?as of 0.9.20, actually returns active peer count, not total.",
	"Method": "int countActivePeers(){\r\n    int active = 0;\r\n    for (NTCPConnection con : _conByIdent.values()) {\r\n        if ((con.getMessagesSent() > 0 && con.getTimeSinceSend() <= 5 * 60 * 1000) || (con.getMessagesReceived() > 0 && con.getTimeSinceReceive() <= 5 * 60 * 1000)) {\r\n            active++;\r\n        }\r\n    }\r\n    return active;\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.PeerProfile.expandProfile",
	"Comment": "when the given peer is performing well enough that we want to keep detailedstats on them again, call this to set up the info we dropped during shrinkprofile.this will not however overwrite any existing data, so it can be safely calledrepeatedly",
	"Method": "void expandProfile(){\r\n    String group = (null == _peer ? \"profileUnknown\" : _peer.toBase64().substring(0, 6));\r\n    if (_tunnelCreateResponseTime == null)\r\n        _tunnelCreateResponseTime = new RateStat(\"tunnelCreateResponseTime\", \"how long it takes to get a tunnel create response from the peer (in milliseconds)\", group, new long[] { 10 * 60 * 1000l, 30 * 60 * 1000l, 60 * 60 * 1000l, 24 * 60 * 60 * 1000 });\r\n    if (_tunnelTestResponseTime == null)\r\n        _tunnelTestResponseTime = new RateStat(\"tunnelTestResponseTime\", \"how long it takes to successfully test a tunnel this peer participates in (in milliseconds)\", group, new long[] { 10 * 60 * 1000l, 30 * 60 * 1000l, 60 * 60 * 1000l, 3 * 60 * 60 * 1000l, 24 * 60 * 60 * 1000 });\r\n    if (_tunnelHistory == null)\r\n        _tunnelHistory = new TunnelHistory(_context, group);\r\n    _tunnelCreateResponseTime.setStatLog(_context.statManager().getStatLog());\r\n    _tunnelTestResponseTime.setStatLog(_context.statManager().getStatLog());\r\n    _expanded = true;\r\n}"
}, {
	"Path": "net.i2p.addressbook.ConfigParser.parseSubscriptions",
	"Comment": "return a list using the contents of the file file. if file cannot beread, use list instead, and write the result to where file should havebeen.",
	"Method": "List<String> parseSubscriptions(BufferedReader input,List<String> parseSubscriptions,File file,List<String> parseSubscriptions,File file,List<String> list){\r\n    List<String> result;\r\n    try {\r\n        result = parseSubscriptions(file);\r\n        if (result.remove(Daemon.OLD_DEFAULT_SUB)) {\r\n            for (String sub : list) {\r\n                if (!result.contains(sub))\r\n                    result.add(sub);\r\n            }\r\n            try {\r\n                writeSubscriptions(result, file);\r\n            } catch (IOException ioe) {\r\n            }\r\n        }\r\n    } catch (IOException exp) {\r\n        result = list;\r\n        try {\r\n            writeSubscriptions(result, file);\r\n        } catch (IOException exp2) {\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.i2p.router.client.ClientConnectionRunner.alreadyAccepted",
	"Comment": "true if the client has already been sent the accepted state for the givenmessage id, false otherwise.",
	"Method": "boolean alreadyAccepted(MessageId id){\r\n    if (_dead)\r\n        return false;\r\n    return !_acceptedPending.contains(id);\r\n}"
}, {
	"Path": "org.klomp.snark.SnarkManager.copyAndAddTorrent",
	"Comment": "add a torrent from a file not in the torrent directory. copy the file to filename.holds the snarks lock to prevent interference from the dirmonitor.caller must verify this torrent is not already added.this may take a long time to create or check the storage.",
	"Method": "void copyAndAddTorrent(File fromfile,String filename,File dataDir){\r\n    synchronized (_snarks) {\r\n        boolean success = FileUtil.copy(fromfile.getAbsolutePath(), filename, false);\r\n        if (!success) {\r\n            addMessage(_t(\"Failed to copy torrent file to {0}\", filename));\r\n            _log.error(\"Failed to write torrent file to \" + filename);\r\n            return;\r\n        }\r\n        if (!areFilesPublic())\r\n            SecureFileOutputStream.setPerms(new File(filename));\r\n        addTorrent(filename, null, false, dataDir);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.I2PTunnel.runHelp",
	"Comment": "display help information through the given logger.does not fire any events to the logger",
	"Method": "void runHelp(Logging l){\r\n    l.log(\"Command list:\\n\" + \"  auth <username> <password>\\n\" + \"  client <port> <pubkey>[,<pubkey,...]|file:<pubkeyfile> [<sharedClient>]\\n\" + \"  clientoptions [-acx] [key=value ]*\\n\" + \"  close [forced|destroy] <jobnumber>|all\\n\" + \"  config [-s] <I2CPhost> <I2CPport>\\n\" + \"  connectclient <port> [<sharedClient>] [<proxy>]\\n\" + \"  genkeys <privkeyfile> [<pubkeyfile>]\\n\" + \"  gentextkeys\\n\" + \"  httpbidirserver <host> <port> <proxyport> <spoofedhost> <privkeyfile>\\n\" + \"  httpclient <port> [<sharedClient>] [<proxy>]\\n\" + \"  httpserver <host> <port> <spoofedhost> <privkeyfile>\\n\" + \"  ircclient <port> <pubkey>[,<pubkey,...]|file:<pubkeyfile> [<sharedClient>]\\n\" + \"  list\\n\" + \"  listen_on <ip>\\n\" + \"  lookup <name>\\n\" + \"  owndest yes|no\\n\" + \"  ping <args>\\n\" + \"  quit\\n\" + \"  read_timeout <msecs>\\n\" + \"  run <commandfile>\\n\" + \"  server <host> <port> <privkeyfile>\\n\" + \"  socksirctunnel <port> [<sharedClient> [<privKeyFile>]]\\n\" + \"  sockstunnel <port>\\n\" + \"  streamrclient <host> <port> <destination>\\n\" + \"  streamrserver <port> <privkeyfile>\\n\" + \"  textserver <host> <port> <privkey>\\n\");\r\n}"
}, {
	"Path": "com.netflix.hollow.api.metrics.HollowMetrics.calculateTypeMetrics",
	"Comment": "calculates the memory heap footprint and populated ordinals per type and total",
	"Method": "void calculateTypeMetrics(HollowReadStateEngine hollowReadStateEngine){\r\n    Collection<HollowTypeReadState> typeStates = hollowReadStateEngine.getTypeStates();\r\n    if (typeStates == null)\r\n        return;\r\n    totalHeapFootprint = 0L;\r\n    totalPopulatedOrdinals = 0;\r\n    for (HollowTypeReadState typeState : typeStates) {\r\n        long heapCost = typeState.getApproximateHeapFootprintInBytes();\r\n        totalHeapFootprint += heapCost;\r\n        int populatedOrdinals = typeState.getPopulatedOrdinals().cardinality();\r\n        totalPopulatedOrdinals += populatedOrdinals;\r\n        String type = typeState.getSchema().getName();\r\n        typeHeapFootprint.put(type, heapCost);\r\n        typePopulatedOrdinals.put(type, populatedOrdinals);\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.data.DataProcessor.main",
	"Comment": "cute little demo. uses demo.rrd file previously created by basic jrobin demo.",
	"Method": "void main(String[] args){\r\n    long t1 = Util.getTimestamp(2003, 4, 1);\r\n    long t2 = Util.getTimestamp(2003, 5, 1);\r\n    System.out.println(\"t1 = \" + t1);\r\n    System.out.println(\"t2 = \" + t2);\r\n    String rrdPath = Util.getJRobinDemoPath(\"demo.rrd\");\r\n    DataProcessor dp = new DataProcessor(t1, t2);\r\n    dp.addDatasource(\"X\", rrdPath, \"sun\", \"AVERAGE\");\r\n    dp.addDatasource(\"Y\", rrdPath, \"shade\", \"AVERAGE\");\r\n    dp.addDatasource(\"Z\", \"X,Y,+,2,/\");\r\n    dp.addDatasource(\"DERIVE[Z]\", \"Z,PREV(Z),-,STEP,/\");\r\n    dp.addDatasource(\"TREND[Z]\", \"DERIVE[Z],SIGN\");\r\n    dp.addDatasource(\"AVG[Z]\", \"Z\", \"AVERAGE\");\r\n    dp.addDatasource(\"DELTA\", \"Z,AVG[Z],-\");\r\n    long laptime = System.currentTimeMillis();\r\n    dp.processData();\r\n    System.out.println(\"Data processed in \" + (System.currentTimeMillis() - laptime) + \" milliseconds\\n---\");\r\n    System.out.println(dp.dump());\r\n    System.out.println(\"\\nAggregates for X\");\r\n    Aggregates agg = dp.getAggregates(\"X\");\r\n    System.out.println(agg.dump());\r\n    System.out.println(\"\\nAggregates for Y\");\r\n    agg = dp.getAggregates(\"Y\");\r\n    System.out.println(agg.dump());\r\n    System.out.println(\"\\n95-percentile for X: \" + Util.formatDouble(dp.get95Percentile(\"X\")));\r\n    System.out.println(\"95-percentile for Y: \" + Util.formatDouble(dp.get95Percentile(\"Y\")));\r\n    System.out.println(\"\\nLast archive update time was: \" + dp.getLastRrdArchiveUpdateTime());\r\n}"
}, {
	"Path": "org.jrobin.core.ArcDef.isValidConsolFun",
	"Comment": "checks if function argument represents valid consolidation function name.",
	"Method": "boolean isValidConsolFun(String consolFun){\r\n    for (final String cFun : CONSOL_FUNS) {\r\n        if (cFun.equals(consolFun)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jrobin.core.RrdDbPool.release",
	"Comment": "releases rrddb reference previously obtained from the pool. when a reference is released, its usage\tcount is decremented by one. if usage count drops to zero, the underlying rrd file will be closed.",
	"Method": "void release(RrdDb rrdDb){\r\n    if (rrdDb == null) {\r\n        return;\r\n    }\r\n    String canonicalPath = Util.getCanonicalPath(rrdDb.getPath());\r\n    if (!rrdMap.containsKey(canonicalPath)) {\r\n        throw new RrdException(\"Could not release [\" + canonicalPath + \"], the file was never requested\");\r\n    }\r\n    RrdEntry entry = rrdMap.get(canonicalPath);\r\n    if (--entry.count <= 0) {\r\n        rrdMap.remove(canonicalPath);\r\n        notifyAll();\r\n        entry.rrdDb.close();\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.TunnelCreatorConfig.getSendTunnelId",
	"Comment": "retrieve the tunnelid that the given hop sends messages on.the gateway is hop 0.",
	"Method": "TunnelId getSendTunnelId(int hop){\r\n    return _config[hop].getSendTunnel();\r\n}"
}, {
	"Path": "net.i2p.router.transport.ntcp.NTCPConnection.enqueueInfoMessageNTCP1",
	"Comment": "inject a databasestoremessage with our routerinfo. ntcp 1 only.",
	"Method": "void enqueueInfoMessageNTCP1(){\r\n    int priority = INFO_PRIORITY;\r\n    if (_log.shouldDebug())\r\n        _log.debug(\"SENDING INFO message pri. \" + priority + \": \" + toString());\r\n    DatabaseStoreMessage dsm = new DatabaseStoreMessage(_context);\r\n    dsm.setEntry(_context.router().getRouterInfo());\r\n    OutNetMessage infoMsg = new OutNetMessage(_context, dsm, _context.clock().now() + 10 * 1000, priority, null);\r\n    infoMsg.beginSend();\r\n    send(infoMsg);\r\n}"
}, {
	"Path": "org.klomp.snark.PeerCoordinator.wantPiece",
	"Comment": "returns one of pieces in the given bitfield that is still wanted ornull if none of the given pieces are wanted.",
	"Method": "int wantPiece(Peer peer,BitField havePieces,Piece wantPiece,Peer peer,BitField havePieces,boolean record){\r\n    if (halted) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"We don't want anything from the peer, as we are halted!  peer=\" + peer);\r\n        return null;\r\n    }\r\n    Piece piece = null;\r\n    List<Piece> requested = new ArrayList<Piece>();\r\n    int wantedSize = END_GAME_THRESHOLD + 1;\r\n    synchronized (wantedPieces) {\r\n        if (record)\r\n            Collections.sort(wantedPieces);\r\n        Iterator<Piece> it = wantedPieces.iterator();\r\n        while (piece == null && it.hasNext()) {\r\n            Piece p = it.next();\r\n            if (p.isDisabled())\r\n                break;\r\n            if (havePieces.get(p.getId()) && !p.isRequested()) {\r\n                boolean hasPartial = false;\r\n                for (PartialPiece pp : partialPieces) {\r\n                    if (pp.getPiece() == p.getId()) {\r\n                        if (_log.shouldLog(Log.INFO))\r\n                            _log.info(\"wantPiece() skipping partial for \" + peer + \": piece = \" + pp);\r\n                        hasPartial = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!hasPartial)\r\n                    piece = p;\r\n            } else if (p.isRequested()) {\r\n                requested.add(p);\r\n            }\r\n        }\r\n        if (piece == null)\r\n            wantedSize = wantedPieces.size();\r\n        if (piece == null) {\r\n            if (wantedSize > END_GAME_THRESHOLD) {\r\n                if (_log.shouldLog(Log.INFO))\r\n                    _log.info(\"Nothing to request, \" + requested.size() + \" being requested and \" + wantedSize + \" still wanted\");\r\n                return null;\r\n            }\r\n            if (record)\r\n                Collections.shuffle(requested, _random);\r\n            Iterator<Piece> it2 = requested.iterator();\r\n            while (piece == null && it2.hasNext()) {\r\n                Piece p = it2.next();\r\n                if (havePieces.get(p.getId())) {\r\n                    int requestedCount = p.getRequestCount();\r\n                    if (requestedCount < MAX_PARALLEL_REQUESTS && !p.isRequestedBy(peer)) {\r\n                        piece = p;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (piece == null) {\r\n                if (_log.shouldLog(Log.WARN))\r\n                    _log.warn(\"nothing to even rerequest from \" + peer + \": requested = \" + requested);\r\n                return null;\r\n            } else {\r\n                if (_log.shouldLog(Log.INFO))\r\n                    _log.info(\"parallel request (end game?) for \" + peer + \": piece = \" + piece);\r\n            }\r\n        }\r\n        if (record) {\r\n            if (_log.shouldLog(Log.INFO))\r\n                _log.info(\"Now requesting from \" + peer + \": piece \" + piece + \" priority \" + piece.getPriority() + \" peers \" + piece.getPeerCount() + '/' + peers.size());\r\n            piece.setRequested(peer, true);\r\n        }\r\n        return piece;\r\n    }\r\n}"
}, {
	"Path": "i2p.susi.util.Folder.getPageOf",
	"Comment": "returns the page this element is on, using the current sort, or 1 if not found",
	"Method": "int getPageOf(O element){\r\n    if (pages <= 1)\r\n        return 1;\r\n    if (elements == null)\r\n        return 1;\r\n    int i = getIndexOf(element);\r\n    if (i < 0)\r\n        return 1;\r\n    return 1 + (i / getPageSize());\r\n}"
}, {
	"Path": "net.i2p.data.i2np.BuildRequestRecord.readIsOutboundEndpoint",
	"Comment": "the current hop is the outbound endpoint.if this is true, the next identity and next tunnelfields refer to where the reply should be sent.",
	"Method": "boolean readIsOutboundEndpoint(){\r\n    return (_data[OFF_FLAG] & FLAG_OUTBOUND_ENDPOINT) != 0;\r\n}"
}, {
	"Path": "i2p.susi.dns.AddressbookBean.getLoadBookMessages",
	"Comment": "load addressbook and apply filter, returning messages about this.",
	"Method": "String getLoadBookMessages(){\r\n    loadConfig();\r\n    addressbook = new Properties();\r\n    String message = \"\";\r\n    FileInputStream fis = null;\r\n    try {\r\n        fis = new FileInputStream(getFileName());\r\n        addressbook.load(fis);\r\n        LinkedList<AddressBean> list = new LinkedList<AddressBean>();\r\n        for (Map.Entry<Object, Object> entry : addressbook.entrySet()) {\r\n            String name = (String) entry.getKey();\r\n            String destination = (String) entry.getValue();\r\n            if (filter != null && filter.length() > 0) {\r\n                if (filter.compareTo(\"0-9\") == 0) {\r\n                    char first = name.charAt(0);\r\n                    if (first < '0' || first > '9')\r\n                        continue;\r\n                } else if (!name.toLowerCase(Locale.US).startsWith(filter.toLowerCase(Locale.US))) {\r\n                    continue;\r\n                }\r\n            }\r\n            if (search != null && search.length() > 0) {\r\n                if (name.indexOf(search) == -1) {\r\n                    continue;\r\n                }\r\n            }\r\n            list.addLast(new AddressBean(name, destination));\r\n        }\r\n        AddressBean[] array = list.toArray(new AddressBean[list.size()]);\r\n        Arrays.sort(array, sorter);\r\n        entries = array;\r\n        message = generateLoadMessage();\r\n    } catch (IOException e) {\r\n        warn(e);\r\n    } finally {\r\n        if (fis != null)\r\n            try {\r\n                fis.close();\r\n            } catch (IOException ioe) {\r\n            }\r\n    }\r\n    if (message.length() > 0)\r\n        message = \"<p id=\\\"filtered\\\">\" + message + \"<\/p>\";\r\n    return message;\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.I2PSocketManagerFull.getDefaultOptions",
	"Comment": "current options, not a copy, setters may be used to make changes. todo there is no facility to specify the session.",
	"Method": "I2PSocketOptions getDefaultOptions(){\r\n    return _defaultOptions;\r\n}"
}, {
	"Path": "com.spotify.heroic.HeroicMappers.config",
	"Comment": "setup the objectmapper used to deserialize configuration files.",
	"Method": "ObjectMapper config(){\r\n    final ObjectMapper m = new ObjectMapper(new YAMLFactory());\r\n    m.addMixIn(ClusterDiscoveryModule.class, TypeNameMixin.class);\r\n    m.addMixIn(RpcProtocolModule.class, TypeNameMixin.class);\r\n    m.addMixIn(ConsumerModule.Builder.class, TypeNameMixin.class);\r\n    m.addMixIn(MetadataModule.class, TypeNameMixin.class);\r\n    m.addMixIn(SuggestModule.class, TypeNameMixin.class);\r\n    m.addMixIn(MetricModule.class, TypeNameMixin.class);\r\n    m.addMixIn(MetricGeneratorModule.class, TypeNameMixin.class);\r\n    m.addMixIn(MetadataGenerator.class, TypeNameMixin.class);\r\n    m.addMixIn(AnalyticsModule.Builder.class, TypeNameMixin.class);\r\n    m.addMixIn(StatisticsModule.class, TypeNameMixin.class);\r\n    m.addMixIn(QueryLoggingModule.class, TypeNameMixin.class);\r\n    m.addMixIn(CacheModule.Builder.class, TypeNameMixin.class);\r\n    m.addMixIn(RequestCondition.class, TypeNameMixin.class);\r\n    m.addMixIn(ConditionalFeatures.class, TypeNameMixin.class);\r\n    m.registerModule(commonSerializers());\r\n    m.registerModule(new Jdk8Module());\r\n    return m;\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.Connection.waitForConnect",
	"Comment": "wait until a connection is made or the connection fails within the timeout period, setting the error accordingly.",
	"Method": "void waitForConnect(){\r\n    long expiration = _context.clock().now() + _options.getConnectTimeout();\r\n    while (true) {\r\n        if (_connected.get() && (_receiveStreamId.get() > 0) && (_sendStreamId.get() > 0)) {\r\n            if (_log.shouldLog(Log.DEBUG))\r\n                _log.debug(\"waitForConnect(): Connected and we have stream IDs\");\r\n            return;\r\n        }\r\n        if (_connectionError != null) {\r\n            if (_log.shouldLog(Log.DEBUG))\r\n                _log.debug(\"waitForConnect(): connection error found: \" + _connectionError);\r\n            return;\r\n        }\r\n        if (!_connected.get()) {\r\n            _connectionError = \"Connection failed\";\r\n            if (_log.shouldLog(Log.DEBUG))\r\n                _log.debug(\"waitForConnect(): not connected\");\r\n            return;\r\n        }\r\n        long timeLeft = expiration - _context.clock().now();\r\n        if ((timeLeft <= 0) && (_options.getConnectTimeout() > 0)) {\r\n            if (_connectionError == null) {\r\n                _connectionError = \"Connection timed out\";\r\n                disconnect(false);\r\n            }\r\n            if (_log.shouldLog(Log.DEBUG))\r\n                _log.debug(\"waitForConnect(): timed out: \" + _connectionError);\r\n            return;\r\n        }\r\n        if (timeLeft > MAX_CONNECT_TIMEOUT)\r\n            timeLeft = MAX_CONNECT_TIMEOUT;\r\n        else if (_options.getConnectTimeout() <= 0)\r\n            timeLeft = DEFAULT_CONNECT_TIMEOUT;\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"waitForConnect(): wait \" + timeLeft);\r\n        try {\r\n            synchronized (_connectLock) {\r\n                _connectLock.wait(timeLeft);\r\n            }\r\n        } catch (InterruptedException ie) {\r\n            if (_log.shouldLog(Log.DEBUG))\r\n                _log.debug(\"waitForConnect(): InterruptedException\");\r\n            _connectionError = \"InterruptedException\";\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.sam.client.SAMEventHandler.waitForNamingReply",
	"Comment": "return the destination found matching the name, or null if the key wasnot able to be retrieved.",
	"Method": "String waitForNamingReply(String name){\r\n    while (true) {\r\n        try {\r\n            synchronized (_namingReplyLock) {\r\n                String val = _namingReplies.remove(name);\r\n                if (val == null) {\r\n                    _namingReplyLock.wait();\r\n                } else {\r\n                    if (SAMReader.SAMClientEventListener.NAMING_REPLY_INVALID_KEY.equals(val))\r\n                        return null;\r\n                    else if (SAMReader.SAMClientEventListener.NAMING_REPLY_KEY_NOT_FOUND.equals(val))\r\n                        return null;\r\n                    else\r\n                        return val;\r\n                }\r\n            }\r\n        } catch (InterruptedException ie) {\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.CommSystemFacade.getStatus",
	"Comment": "determine under what conditions we are remotely reachable.",
	"Method": "Status getStatus(){\r\n    return Status.OK;\r\n}"
}, {
	"Path": "io.helidon.webserver.RoutingTest.basicRouting",
	"Comment": "use fluent routing api to cover http methods and paths with handlers.",
	"Method": "void basicRouting(){\r\n    assertThrows(RuntimeException.class, () -> {\r\n        Routing.builder().post(\"/user\", (req, resp) -> {\r\n        }).get(\"/user/{name}\", (req, resp) -> {\r\n        }).build();\r\n    });\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.I2PTunnelClient.startRunning",
	"Comment": "actually start working on incoming connections.overridden to register with port mapper.",
	"Method": "void startRunning(){\r\n    super.startRunning();\r\n    if (open) {\r\n        I2PSocketAddress addr = pickDestination();\r\n        if (addr != null) {\r\n            String svc = null;\r\n            String hostname = addr.getHostName();\r\n            if (\"smtp.postman.i2p\".equals(hostname)) {\r\n                svc = PortMapper.SVC_SMTP;\r\n            } else if (\"pop.postman.i2p\".equals(hostname)) {\r\n                svc = PortMapper.SVC_POP;\r\n            }\r\n            if (svc != null) {\r\n                _isr = new InternalSocketRunner(this);\r\n                _isr.start();\r\n                _context.portMapper().register(svc, getTunnel().listenHost, getLocalPort());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.Archive.getPdpCount",
	"Comment": "returns the number of primary data points required for a consolidated\tdata point in this archive.",
	"Method": "int getPdpCount(){\r\n    return pdpCount;\r\n}"
}, {
	"Path": "io.helidon.security.SecurityEnvironment.derive",
	"Comment": "derive a new environment builder based on this environment.",
	"Method": "Builder derive(){\r\n    return builder(timeProvider).attributes(properties).targetUri(targetUri).method(method).transport(transport).path(path.orElse(null)).headers(headers);\r\n}"
}, {
	"Path": "org.klomp.snark.Storage.close",
	"Comment": "closes the storage and makes sure that all randomaccessfiles areclosed. the storage is unusable after this.",
	"Method": "void close(){\r\n    for (TorrentFile tf : _torrentFiles) {\r\n        try {\r\n            tf.closeRAF();\r\n        } catch (IOException ioe) {\r\n            _log.error(\"Error closing \" + tf, ioe);\r\n        }\r\n    }\r\n    changed = false;\r\n}"
}, {
	"Path": "net.i2p.router.MessageHistory.tunnelValid",
	"Comment": "note that we have reason to believe that the given tunnel is valid, since we could do something through it in the given amount of time",
	"Method": "void tunnelValid(TunnelInfo tunnel,long timeToTest){\r\n    if (!_doLog)\r\n        return;\r\n    if (tunnel == null)\r\n        return;\r\n    StringBuilder buf = new StringBuilder(128);\r\n    buf.append(getPrefix());\r\n    buf.append(\"tunnel \").append(tunnel).append(\" tested ok after \").append(timeToTest).append(\"ms\");\r\n    addEntry(buf.toString());\r\n}"
}, {
	"Path": "net.i2p.crypto.eddsa.math.GroupElement.toRadix16",
	"Comment": "convert a to radix 16.method is package private only so that tests run.",
	"Method": "byte[] toRadix16(byte[] a){\r\n    final byte[] e = new byte[64];\r\n    int i;\r\n    for (i = 0; i < 32; i++) {\r\n        e[2 * i + 0] = (byte) (a[i] & 15);\r\n        e[2 * i + 1] = (byte) ((a[i] >> 4) & 15);\r\n    }\r\n    int carry = 0;\r\n    for (i = 0; i < 63; i++) {\r\n        e[i] += carry;\r\n        carry = e[i] + 8;\r\n        carry >>= 4;\r\n        e[i] -= carry << 4;\r\n    }\r\n    e[63] += carry;\r\n    return e;\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterAddress.setTransportStyle",
	"Comment": "configure the type of transport that must be used to communicate on this address",
	"Method": "void setTransportStyle(String transportStyle){\r\n    if (_transportStyle != null)\r\n        throw new IllegalStateException();\r\n    _transportStyle = transportStyle;\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.ui.TunnelConfig.updateTunnelQuantities",
	"Comment": "update tunnel quantities for the provided config from this tunnelconfig.",
	"Method": "void updateTunnelQuantities(Properties config){\r\n    if (_tunnelQuantity >= 0) {\r\n        config.setProperty(\"option.inbound.quantity\", Integer.toString(_tunnelQuantity));\r\n        if (_tunnelQuantityOut < 0)\r\n            _tunnelQuantityOut = _tunnelQuantity;\r\n        config.setProperty(\"option.outbound.quantity\", Integer.toString(_tunnelQuantityOut));\r\n    }\r\n    if (_tunnelDepth >= 0) {\r\n        config.setProperty(\"option.inbound.length\", Integer.toString(_tunnelDepth));\r\n        if (_tunnelDepthOut < 0)\r\n            _tunnelDepthOut = _tunnelDepth;\r\n        config.setProperty(\"option.outbound.length\", Integer.toString(_tunnelDepthOut));\r\n    }\r\n    if (_tunnelVariance >= -2) {\r\n        config.setProperty(\"option.inbound.lengthVariance\", Integer.toString(_tunnelVariance));\r\n        if (_tunnelVarianceOut < -2)\r\n            _tunnelVarianceOut = _tunnelVariance;\r\n        config.setProperty(\"option.outbound.lengthVariance\", Integer.toString(_tunnelVarianceOut));\r\n    }\r\n    if (_tunnelBackupQuantity >= 0) {\r\n        config.setProperty(\"option.inbound.backupQuantity\", Integer.toString(_tunnelBackupQuantity));\r\n        if (_tunnelBackupQuantityOut < 0)\r\n            _tunnelBackupQuantityOut = _tunnelBackupQuantity;\r\n        config.setProperty(\"option.outbound.backupQuantity\", Integer.toString(_tunnelBackupQuantityOut));\r\n    }\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.settings.IgnoreSettingsConfigurable.createComponent",
	"Comment": "returns the user interface component for editing the configuration.",
	"Method": "JComponent createComponent(){\r\n    if (settingsPanel == null) {\r\n        settingsPanel = new IgnoreSettingsPanel();\r\n    }\r\n    reset();\r\n    return settingsPanel.panel;\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.lang.IgnoreLanguage.isNewAllowed",
	"Comment": "checks if creating new file for given language is allowed with the settings.",
	"Method": "boolean isNewAllowed(){\r\n    final TreeMap<IgnoreSettings.IgnoreLanguagesSettings.KEY, Object> data = IgnoreSettings.getInstance().getLanguagesSettings().get(this);\r\n    boolean value = false;\r\n    if (data != null) {\r\n        value = Boolean.valueOf(data.get(IgnoreSettings.IgnoreLanguagesSettings.KEY.NEW_FILE).toString());\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerState.setCurrentMACKey",
	"Comment": "the aes key used to verify packets, set only after the connection isestablished.",
	"Method": "void setCurrentMACKey(SessionKey key){\r\n    _currentMACKey = key;\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.InboundEndpointProcessor.retrievePreprocessedData",
	"Comment": "undo all of the encryption done by the peers in the tunnel, recovering thepreprocessed data sent by the gateway.",
	"Method": "boolean retrievePreprocessedData(byte orig,int offset,int length,Hash prev){\r\n    Hash last = _config.getPeer(_config.getLength() - 2);\r\n    if (!last.equals(prev)) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Attempted IBEP injection from \" + prev + \", expected \" + last);\r\n        return false;\r\n    }\r\n    byte[] iv = SimpleByteCache.acquire(HopProcessor.IV_LENGTH);\r\n    System.arraycopy(orig, offset, iv, 0, iv.length);\r\n    boolean ok = _validator.receiveIV(iv, 0, orig, offset + HopProcessor.IV_LENGTH);\r\n    if (!ok) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Invalid IV, dropping at IBEP \" + _config);\r\n        SimpleByteCache.release(iv);\r\n        return false;\r\n    }\r\n    decrypt(_context, _config, iv, orig, offset, length);\r\n    SimpleByteCache.release(iv);\r\n    if (_config.getLength() > 0) {\r\n        int rtt = 0;\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"Received a \" + length + \"byte message through tunnel \" + _config);\r\n        for (int i = 0; i < _config.getLength(); i++) _context.profileManager().tunnelDataPushed(_config.getPeer(i), rtt, length);\r\n        _config.incrementVerifiedBytesTransferred(length);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.i2p.router.naming.BlockfileNamingService.put",
	"Comment": "multiple dests version.db must be version 4.this does not prevent adding b32. caller must check.",
	"Method": "boolean put(String hostname,Destination d,Properties options,boolean put,String hostname,Destination d,Properties options,boolean checkExisting,boolean put,String hostname,List<Destination> dests,List<Properties> propsList,boolean checkExisting){\r\n    int sz = dests.size();\r\n    if (sz <= 0)\r\n        throw new IllegalArgumentException();\r\n    if (sz == 1)\r\n        return put(hostname, dests.get(0), propsList != null ? propsList.get(0) : null, checkExisting);\r\n    if (_readOnly) {\r\n        _log.error(\"Add entry failed, read-only hosts database\");\r\n        return false;\r\n    }\r\n    String key = hostname.toLowerCase(Locale.US);\r\n    synchronized (_negativeCache) {\r\n        _negativeCache.remove(key);\r\n    }\r\n    String listname = FALLBACK_LIST;\r\n    String date = Long.toString(_context.clock().now());\r\n    List<Properties> outProps = new ArrayList<Properties>(propsList.size());\r\n    for (Properties options : propsList) {\r\n        Properties props = new Properties();\r\n        props.setProperty(PROP_ADDED, date);\r\n        if (options != null) {\r\n            props.putAll(options);\r\n            String list = options.getProperty(\"list\");\r\n            if (list != null) {\r\n                listname = list;\r\n                props.remove(\"list\");\r\n            }\r\n        }\r\n        outProps.add(props);\r\n    }\r\n    synchronized (_bf) {\r\n        if (_isClosed)\r\n            return false;\r\n        try {\r\n            SkipList<String, DestEntry> sl = _bf.getIndex(listname, _stringSerializer, _destSerializer);\r\n            if (sl == null)\r\n                sl = _bf.makeIndex(listname, _stringSerializer, _destSerializer);\r\n            boolean changed = (checkExisting || !_listeners.isEmpty()) && sl.get(key) != null;\r\n            if (changed && checkExisting)\r\n                return false;\r\n            addEntry(sl, key, dests, outProps);\r\n            if (changed) {\r\n                removeCache(hostname);\r\n            }\r\n            for (int i = 0; i < dests.size(); i++) {\r\n                Destination d = dests.get(i);\r\n                Properties options = propsList.get(i);\r\n                addReverseEntry(key, d);\r\n                for (NamingServiceListener nsl : _listeners) {\r\n                    if (changed)\r\n                        nsl.entryChanged(this, hostname, d, options);\r\n                    else\r\n                        nsl.entryAdded(this, hostname, d, options);\r\n                }\r\n            }\r\n            return true;\r\n        } catch (IOException ioe) {\r\n            _log.error(\"DB add error\", ioe);\r\n            return false;\r\n        } catch (RuntimeException re) {\r\n            _log.error(\"DB add error\", re);\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.lang.IgnoreBraceMatcher.getPairs",
	"Comment": "returns the array of definitions for brace pairs that need to be matched whenediting code in the language.",
	"Method": "BracePair[] getPairs(){\r\n    return PAIRS;\r\n}"
}, {
	"Path": "net.i2p.router.web.PluginStarter.isClientThreadRunning",
	"Comment": "returns true if one or more client threads are running in a given plugin.",
	"Method": "boolean isClientThreadRunning(String pluginName,RouterContext ctx){\r\n    ThreadGroup group = pluginThreadGroups.get(pluginName);\r\n    if (group == null)\r\n        return false;\r\n    boolean rv = group.activeCount() > 0;\r\n    if (rv) {\r\n        Log log = ctx.logManager().getLog(PluginStarter.class);\r\n        Thread[] activeThreads = new Thread[128];\r\n        int count = group.enumerate(activeThreads);\r\n        boolean notRollover = false;\r\n        for (int i = 0; i < count; i++) {\r\n            if (activeThreads[i] != null) {\r\n                String name = activeThreads[i].getName();\r\n                if (!\"org.eclipse.jetty.util.RolloverFileOutputStream\".equals(name) && !name.startsWith(\"HSQLDB Timer\"))\r\n                    notRollover = true;\r\n                if (log.shouldLog(Log.DEBUG))\r\n                    log.debug(\"Found \" + activeThreads[i].getState() + \" thread \" + name + \" for \" + pluginName + \": \" + name);\r\n            }\r\n        }\r\n        rv = notRollover;\r\n    }\r\n    return rv;\r\n}"
}, {
	"Path": "net.i2p.router.client.ClientConnectionRunner.doSend",
	"Comment": "actually send the i2cpmessage to the peer through the socket",
	"Method": "void doSend(I2CPMessage msg){\r\n    if (_out == null)\r\n        throw new I2CPMessageException(\"Output stream is not initialized\");\r\n    if (msg == null)\r\n        throw new I2CPMessageException(\"Null message?!\");\r\n    _writer.addMessage(msg);\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.util.yaml.YamlHelper.getIndentSpaceForFile",
	"Comment": "try to find a valid indent value, which are spaces which we need to fill",
	"Method": "int getIndentSpaceForFile(YAMLFile yamlFile){\r\n    List<YAMLDocument> documents = yamlFile.getDocuments();\r\n    YAMLMapping mapping = ObjectUtils.tryCast(documents.get(0).getTopLevelValue(), YAMLMapping.class);\r\n    if (mapping != null) {\r\n        PsiElementPattern.Capture<PsiElement> pattern = PlatformPatterns.psiElement(YAMLTokenTypes.INDENT).with(new PsiElementPatternCondition());\r\n        for (YAMLPsiElement yamlPsiElement : mapping.getKeyValues()) {\r\n            PsiElement firstChild = yamlPsiElement.getFirstChild();\r\n            if (firstChild == null) {\r\n                continue;\r\n            }\r\n            PsiElement nextSiblingOfType = PsiElementUtils.getNextSiblingOfType(firstChild, pattern);\r\n            if (nextSiblingOfType != null && nextSiblingOfType.getTextLength() > 0) {\r\n                return nextSiblingOfType.getTextLength();\r\n            }\r\n        }\r\n    }\r\n    return 4;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.UDPPacket.validate",
	"Comment": "validate the packet against the mac specified, returning true if themac matches, false otherwise.",
	"Method": "boolean validate(SessionKey macKey){\r\n    verifyNotReleased();\r\n    boolean eq = false;\r\n    Arrays.fill(_validateBuf, (byte) 0);\r\n    int payloadLength = _packet.getLength() - MAC_SIZE - IV_SIZE;\r\n    if (payloadLength > 0) {\r\n        int off = 0;\r\n        System.arraycopy(_data, _packet.getOffset() + MAC_SIZE + IV_SIZE, _validateBuf, off, payloadLength);\r\n        off += payloadLength;\r\n        System.arraycopy(_data, _packet.getOffset() + MAC_SIZE, _validateBuf, off, IV_SIZE);\r\n        off += IV_SIZE;\r\n        DataHelper.toLong(_validateBuf, off, 2, payloadLength);\r\n        off += 2;\r\n        eq = _context.hmac().verify(macKey, _validateBuf, 0, off, _data, _packet.getOffset(), MAC_SIZE);\r\n        if (!eq) {\r\n            Log log = _context.logManager().getLog(UDPPacket.class);\r\n            if (log.shouldLog(Log.INFO)) {\r\n                byte[] calc = new byte[32];\r\n                _context.hmac().calculate(macKey, _validateBuf, 0, off, calc, 0);\r\n                StringBuilder str = new StringBuilder(512);\r\n                str.append(\"Bad HMAC:\\n\\t\");\r\n                str.append(_packet.getLength()).append(\" byte pkt, \");\r\n                str.append(payloadLength).append(\" byte payload\");\r\n                str.append(\"\\n\\tFrom: \").append(getRemoteHost().toString());\r\n                str.append(\"\\n\\tIV:   \").append(Base64.encode(_validateBuf, payloadLength, IV_SIZE));\r\n                str.append(\"\\n\\tIV2:  \").append(Base64.encode(_data, MAC_SIZE, IV_SIZE));\r\n                str.append(\"\\n\\tGiven Len: \").append(DataHelper.fromLong(_validateBuf, payloadLength + IV_SIZE, 2));\r\n                str.append(\"\\n\\tCalc HMAC: \").append(Base64.encode(calc, 0, MAC_SIZE));\r\n                str.append(\"\\n\\tRead HMAC: \").append(Base64.encode(_data, _packet.getOffset(), MAC_SIZE));\r\n                str.append(\"\\n\\tUsing key: \").append(macKey.toBase64());\r\n                if (DataHelper.eq(macKey.getData(), 0, _context.routerHash().getData(), 0, 32))\r\n                    str.append(\" (Intro)\");\r\n                else\r\n                    str.append(\" (Session)\");\r\n                str.append(\"\\n\\tRaw:       \").append(Base64.encode(_data, _packet.getOffset(), _packet.getLength()));\r\n                log.info(str.toString(), new Exception());\r\n            }\r\n        }\r\n    } else {\r\n        Log log = _context.logManager().getLog(UDPPacket.class);\r\n        if (log.shouldLog(Log.WARN))\r\n            log.warn(\"Payload length is \" + payloadLength + \", too short! From: \" + getRemoteHost() + '\\n' + net.i2p.util.HexDump.dump(_data, _packet.getOffset(), _packet.getLength()));\r\n    }\r\n    _validateCount++;\r\n    return eq;\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.TunnelHistory.getLastRejectedTransient",
	"Comment": "when the peer last refused to participate in a tunnel complaining of transient overload",
	"Method": "long getLastRejectedTransient(){\r\n    return _lastRejectedTransient;\r\n}"
}, {
	"Path": "org.jrobin.graph.RrdGraphDef.setSmallFont",
	"Comment": "sets default font for graphing. note that jrobin will behave unpredictably if proportionalfont is selected.",
	"Method": "void setSmallFont(Font smallFont){\r\n    this.setFont(FONTTAG_DEFAULT, smallFont);\r\n}"
}, {
	"Path": "net.i2p.I2PAppContext.keyGenerator",
	"Comment": "component to generate elgamal, dsa, and session keys.for why it is inthe appcontext, see the dsa, hmac, and sha comments above.",
	"Method": "KeyGenerator keyGenerator(){\r\n    if (!_keyGeneratorInitialized)\r\n        initializeKeyGenerator();\r\n    return _keyGenerator;\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.RRDatabase.close",
	"Comment": "closes this database stream and releases any associated system resources.",
	"Method": "void close(){\r\n    rrdFile.close();\r\n}"
}, {
	"Path": "net.i2p.router.CommSystemFacade.getMedianPeerClockSkew",
	"Comment": "median clock skew of connected peers in seconds, or null if we cannot answer.commsystemfacadeimpl overrides this.",
	"Method": "Long getMedianPeerClockSkew(){\r\n    return null;\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.RRDatabase.getDataSources",
	"Comment": "returns an iterator over the data sources in this database in proper sequence.",
	"Method": "Iterator<DataSource> getDataSources(){\r\n    return dataSources.iterator();\r\n}"
}, {
	"Path": "net.i2p.router.transport.crypto.X25519KeyFactory.returnUnused",
	"Comment": "return an unused dh key builderto be put back onto the queue for reuse.",
	"Method": "void returnUnused(KeyPair kp){\r\n    _context.statManager().addRateData(\"crypto.XDHReused\", 1);\r\n    _keys.offer(kp);\r\n}"
}, {
	"Path": "org.jrobin.core.XmlTemplate.getVariables",
	"Comment": "returns the list of variables that should be set in this template.",
	"Method": "String[] getVariables(){\r\n    ArrayList<String> list = new ArrayList<String>();\r\n    Matcher m = PATTERN.matcher(root.toString());\r\n    while (m.find()) {\r\n        String var = m.group(1);\r\n        if (!list.contains(var)) {\r\n            list.add(var);\r\n        }\r\n    }\r\n    return list.toArray(new String[list.size()]);\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerState.getRemotePeer",
	"Comment": "the peer are we talking to.this should be set as soon as thisstate is created if we are initiating a connection, but if we arereceiving the connection this will be set only after the connectionis established.",
	"Method": "Hash getRemotePeer(){\r\n    return _remotePeer;\r\n}"
}, {
	"Path": "com.spotify.heroic.QueryBuilder.legacyFilter",
	"Comment": "convert a metricsrequest into a filter.this is meant to stay backwards compatible, since every filtering in metricsrequest can beexpressed as filter objects.",
	"Method": "Optional<Filter> legacyFilter(){\r\n    final List<Filter> statements = new ArrayList();\r\n    if (filter.isPresent()) {\r\n        statements.add(filter.get());\r\n    }\r\n    if (tags.isPresent()) {\r\n        for (final Map.Entry<String, String> entry : tags.get().entrySet()) {\r\n            statements.add(new MatchTagFilter(entry.getKey(), entry.getValue()));\r\n        }\r\n    }\r\n    if (key.isPresent()) {\r\n        statements.add(new MatchKeyFilter(key.get()));\r\n    }\r\n    if (statements.isEmpty()) {\r\n        return Optional.empty();\r\n    }\r\n    if (statements.size() == 1) {\r\n        return Optional.of(statements.get(0).optimize());\r\n    }\r\n    return Optional.of(new AndFilter(statements).optimize());\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerState.getConsecutiveFailedSends",
	"Comment": "how many seconds have we sent packets without any acks received?",
	"Method": "int getConsecutiveFailedSends(){\r\n    return _consecutiveFailedSends;\r\n}"
}, {
	"Path": "io.helidon.webserver.netty.ReferenceHoldingQueue.unlink",
	"Comment": "unlinks the reference in order to clear all the residue objects from the memory.",
	"Method": "void unlink(Reference<T> reference){\r\n    set.remove(reference);\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PacketBuilder.pad1",
	"Comment": "pad up to next 16 byte boundary and return new offset.these bytes will be encrypted.this must be called before encryption.",
	"Method": "int pad1(byte[] data,int off){\r\n    int mod = off & 0x0f;\r\n    if (mod == 0)\r\n        return off;\r\n    int padSize = 16 - mod;\r\n    _context.random().nextBytes(data, off, padSize);\r\n    return off + padSize;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.InboundMessageFragments.receiveData",
	"Comment": "pull the fragments and acks out of the authenticated data packet",
	"Method": "void receiveData(PeerState from,UDPPacketReader.DataReader data){\r\n    try {\r\n        rcvData(from, data);\r\n    } catch (DataFormatException dfe) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Bad pkt from: \" + from, dfe);\r\n    } catch (IndexOutOfBoundsException ioobe) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Bad pkt from: \" + from, ioobe);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.DBHistory.unpromptedStoreReceived",
	"Comment": "note that the peer sent us a data point without us asking for it",
	"Method": "void unpromptedStoreReceived(boolean wasNew){\r\n    if (wasNew)\r\n        _unpromptedDbStoreNew++;\r\n    else\r\n        _unpromptedDbStoreOld++;\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.ProfileManagerImpl.tunnelTestSucceeded",
	"Comment": "note that a tunnel that the router is participating inwas successfully tested with the given round trip latency",
	"Method": "void tunnelTestSucceeded(Hash peer,long responseTimeMs){\r\n    PeerProfile data = getProfile(peer);\r\n    data.updateTunnelTestTimeAverage(responseTimeMs);\r\n    data.getTunnelTestResponseTime().addData(responseTimeMs, responseTimeMs);\r\n}"
}, {
	"Path": "org.klomp.snark.PeerState.havePiece",
	"Comment": "we now have this piece. tell the peer and cancel any requests for the piece.",
	"Method": "void havePiece(int piece){\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Tell \" + peer + \" havePiece(\" + piece + \")\");\r\n    cancelPiece(piece);\r\n    out.sendHave(piece);\r\n    addRequest();\r\n}"
}, {
	"Path": "net.i2p.util.ShellCommand.executeSilent",
	"Comment": "passes a command to the shell for execution and returns immediatelywithout waiting for an exit status. any output produced by the executedcommand will not be displayed.warning, no good way to quote or escape spaces in arguments with this method.",
	"Method": "void executeSilent(String shellCommand){\r\n    Runtime.getRuntime().exec(shellCommand, null);\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.UDPTransport.mayDisconnect",
	"Comment": "tell the transport that we may disconnect from this peer.this is advisory only.",
	"Method": "void mayDisconnect(Hash peer){\r\n    final PeerState ps = _peersByIdent.get(peer);\r\n    if (ps != null && ps.getWeRelayToThemAs() <= 0 && (ps.getTheyRelayToUsAs() <= 0 || ps.getIntroducerTime() < _context.clock().now() - 2 * 60 * 60 * 1000) && ps.getMessagesReceived() <= 2 && ps.getMessagesSent() <= 2) {\r\n        ps.setMayDisconnect();\r\n    }\r\n}"
}, {
	"Path": "io.helidon.webserver.ContentTypeSelector.putSingle",
	"Comment": "add a single value to the static map. should be used only from static constructor.",
	"Method": "void putSingle(String extension,String contentTypeName){\r\n    CONTENT_TYPES.put(extension, MediaType.parse(contentTypeName));\r\n}"
}, {
	"Path": "com.spotify.heroic.cluster.CoreClusterManager.useOptionalGroup",
	"Comment": "eventually consistent view of the currently known shards in the cluster",
	"Method": "List<ClusterShard> useOptionalGroup(Optional<String> group){\r\n    final ImmutableList.Builder<ClusterShard> shards = ImmutableList.builder();\r\n    for (final Map<String, String> shardTags : allShards()) {\r\n        shards.add(new ClusterShard(async, shardTags, reporter, this));\r\n    }\r\n    return shards.build();\r\n}"
}, {
	"Path": "net.i2p.stat.Frequency.store",
	"Comment": "appends the data of this frequency to the specified stringbuilder",
	"Method": "void store(StringBuilder dest){\r\n    dest.append(\"avgInterval:\").append(_avgInterval).append(',');\r\n    dest.append(\"minAverageInterval\").append(_minAverageInterval).append(',');\r\n    dest.append(\"lastEvent\").append(_lastEvent).append(\",\");\r\n    dest.append(\"count\").append(_count);\r\n}"
}, {
	"Path": "net.i2p.router.MessageHistory.messageProcessingError",
	"Comment": "there was an error processing the given message that was received",
	"Method": "void messageProcessingError(long messageId,String messageType,String error){\r\n    if (!_doLog)\r\n        return;\r\n    StringBuilder buf = new StringBuilder(128);\r\n    buf.append(getPrefix());\r\n    buf.append(\"Error processing [\").append(messageType).append(\"] [\").append(messageId).append(\"] failed with [\").append(error).append(\"]\");\r\n    addEntry(buf.toString());\r\n}"
}, {
	"Path": "net.i2p.BOB.TCPtoI2P.lnRead",
	"Comment": "this is a more forgiving readline,\tit works on unbuffered streams",
	"Method": "String lnRead(InputStream in){\r\n    StringBuilder builder = new StringBuilder();\r\n    int b;\r\n    char c;\r\n    while (true) {\r\n        b = in.read();\r\n        if (b == 13) {\r\n            continue;\r\n        }\r\n        if (b < 20 || b > 126) {\r\n            break;\r\n        }\r\n        c = (char) (b & 0x7f);\r\n        builder.append(c);\r\n    }\r\n    return builder.toString();\r\n}"
}, {
	"Path": "net.i2p.data.SDSCache.hashCodeOf",
	"Comment": "we assume the data has enough randomness in it, so use the first 4 bytes for speed.",
	"Method": "Integer hashCodeOf(byte[] data){\r\n    int rv = data[0];\r\n    for (int i = 1; i < 4; i++) rv ^= (data[i] << (i * 8));\r\n    return Integer.valueOf(rv);\r\n}"
}, {
	"Path": "org.jrobin.core.FetchData.getMatchingArchive",
	"Comment": "returns archive object which is determined to be the best match for the\ttimestamps specified in the fetch request. all datasource values are obtained\tfrom round robin archives belonging to this archive.",
	"Method": "Archive getMatchingArchive(){\r\n    return matchingArchive;\r\n}"
}, {
	"Path": "net.nicoulaj.idea.markdown.editor.MarkdownPreviewEditorProvider.isDumbAware",
	"Comment": "indicates the editor can be created while background indexing is running.",
	"Method": "boolean isDumbAware(){\r\n    return true;\r\n}"
}, {
	"Path": "com.spotify.heroic.HeroicCore.primaryInjector",
	"Comment": "setup primary injector, which will provide dependencies to the entire application.",
	"Method": "CoreComponent primaryInjector(CoreEarlyComponent early,HeroicConfig config,HeroicCoreInstance instance){\r\n    log.info(\"Building Primary Injector\");\r\n    final List<LifeCycle> life = new ArrayList();\r\n    final StatisticsComponent statistics = config.getStatistics().module(early);\r\n    life.add(statistics.life());\r\n    final HeroicReporter reporter = statistics.reporter();\r\n    final CorePrimaryComponent primary = DaggerCorePrimaryComponent.builder().coreEarlyComponent(early).primaryModule(new PrimaryModule(instance, config.getFeatures(), reporter, config.getConditionalFeature())).build();\r\n    final QueryLoggingComponent queryLogging = config.getQueryLogging().component(primary);\r\n    final Optional<HttpServer> server = setupServer(config, life, primary);\r\n    final CacheComponent cache = config.getCache().module(primary);\r\n    life.add(cache.cacheLife());\r\n    final AnalyticsComponent analytics = config.getAnalytics().module(primary);\r\n    life.add(analytics.analyticsLife());\r\n    final CoreMetadataComponent metadata = DaggerCoreMetadataComponent.builder().primaryComponent(primary).metadataManagerModule(config.getMetadata()).build();\r\n    life.add(metadata.metadataLife());\r\n    final CoreSuggestComponent suggest = DaggerCoreSuggestComponent.builder().primaryComponent(primary).suggestManagerModule(config.getSuggest()).build();\r\n    life.add(suggest.suggestLife());\r\n    final CoreMetricComponent metric = DaggerCoreMetricComponent.builder().corePrimaryComponent(primary).metadataComponent(metadata).analyticsComponent(analytics).metricManagerModule(config.getMetric()).queryLoggingComponent(queryLogging).build();\r\n    life.add(metric.metricLife());\r\n    final IngestionComponent ingestion = config.getIngestion().module(primary, suggest, metadata, metric);\r\n    life.add(ingestion.ingestionLife());\r\n    buildShellServer(config).ifPresent(shellServerModule -> {\r\n        final ShellServerComponent shellServer = DaggerShellServerComponent.builder().primaryComponent(primary).shellServerModule(shellServerModule).build();\r\n        life.add(shellServer.shellServerLife());\r\n    });\r\n    final CoreClusterComponent cluster = DaggerCoreClusterComponent.builder().primaryComponent(primary).metricComponent(metric).metadataComponent(metadata).suggestComponent(suggest).clusterManagerModule(config.getCluster()).clusterDiscoveryComponent(config.getCluster().getDiscovery().module(primary)).build();\r\n    life.add(cluster.clusterLife());\r\n    if (startupPing.isPresent() && startupId.isPresent()) {\r\n        final StartupPingerComponent pinger = DaggerStartupPingerComponent.builder().corePrimaryComponent(primary).clusterComponent(cluster).startupPingerModule(new StartupPingerModule(startupPing.get(), startupId.get(), server)).build();\r\n        life.add(pinger.startupPingerLife());\r\n    }\r\n    final ConsumersComponent consumer = DaggerCoreConsumersComponent.builder().coreConsumersModule(new CoreConsumersModule(reporter, config.getConsumers(), primary, ingestion)).corePrimaryComponent(primary).build();\r\n    life.add(consumer.consumersLife());\r\n    final QueryComponent query = DaggerCoreQueryComponent.builder().queryModule(new QueryModule(config.getMetric().getGroupLimit(), config.getMetric().getSmallQueryThreshold())).corePrimaryComponent(primary).clusterComponent(cluster).cacheComponent(cache).queryLoggingComponent(queryLogging).build();\r\n    life.add(query.queryLife());\r\n    final GeneratorComponent generator = config.getGenerator().module(primary);\r\n    life.add(generator.generatorLife());\r\n    final LifeCycle combined = LifeCycle.combined(life);\r\n    combined.install();\r\n    return DaggerCoreComponent.builder().primaryComponent(primary).analyticsComponent(analytics).consumersComponent(consumer).metricComponent(metric).metadataComponent(metadata).suggestComponent(suggest).queryComponent(query).queryLoggingComponent(queryLogging).ingestionComponent(ingestion).clusterComponent(cluster).generatorComponent(generator).build();\r\n}"
}, {
	"Path": "com.netflix.hollow.api.codegen.HollowAPIGenerator.generateFilesForHollowSchemas",
	"Comment": "generate files based on dataset schemas under the specified directory",
	"Method": "void generateFilesForHollowSchemas(File directory){\r\n    for (HollowSchema schema : dataset.getSchemas()) {\r\n        String type = schema.getName();\r\n        if (config.isUseHollowPrimitiveTypes() && HollowCodeGenerationUtils.isPrimitiveType(type))\r\n            continue;\r\n        generateFile(directory, getStaticAPIGenerator(schema));\r\n        generateFile(directory, getHollowObjectGenerator(schema));\r\n        generateFile(directory, getHollowFactoryGenerator(schema));\r\n        if (schema.getSchemaType() == SchemaType.OBJECT) {\r\n            HollowObjectSchema objSchema = (HollowObjectSchema) schema;\r\n            generateFile(directory, new HollowObjectDelegateInterfaceGenerator(packageName, objSchema, ergonomicShortcuts, dataset, config));\r\n            generateFile(directory, new HollowObjectDelegateCachedImplGenerator(packageName, objSchema, ergonomicShortcuts, dataset, config));\r\n            generateFile(directory, new HollowObjectDelegateLookupImplGenerator(packageName, objSchema, ergonomicShortcuts, dataset, config));\r\n            generateFile(directory, new HollowDataAccessorGenerator(packageName, apiClassname, objSchema, dataset, config));\r\n            if (!config.isReservePrimaryKeyIndexForTypeWithPrimaryKey()) {\r\n                generateFile(directory, new LegacyHollowPrimaryKeyIndexGenerator(packageName, apiClassname, objSchema, dataset, config));\r\n            } else if ((objSchema).getPrimaryKey() != null) {\r\n                generateFile(directory, new HollowPrimaryKeyIndexGenerator(dataset, packageName, apiClassname, objSchema, config));\r\n                generateFile(directory, new HollowUniqueKeyIndexGenerator(packageName, apiClassname, objSchema, dataset, config));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.spotify.heroic.aggregation.AggregationArguments.positional",
	"Comment": "take the next positional argument from the list of available arguments.",
	"Method": "Optional<T> positional(Class<T> expected){\r\n    if (args.isEmpty()) {\r\n        return Optional.empty();\r\n    }\r\n    return Optional.of(args.removeFirst().cast(expected));\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.FloodfillVerifyStoreJob.pickTarget",
	"Comment": "pick a responsive floodfill close to the key, but not the one we sent to",
	"Method": "Hash pickTarget(){\r\n    Hash rkey = getContext().routingKeyGenerator().getRoutingKey(_key);\r\n    FloodfillPeerSelector sel = (FloodfillPeerSelector) _facade.getPeerSelector();\r\n    Certificate keyCert = null;\r\n    if (!_isRouterInfo) {\r\n        Destination dest = _facade.lookupDestinationLocally(_key);\r\n        if (dest != null) {\r\n            Certificate cert = dest.getCertificate();\r\n            if (cert.getCertificateType() == Certificate.CERTIFICATE_TYPE_KEY)\r\n                keyCert = cert;\r\n        }\r\n    }\r\n    if (keyCert != null) {\r\n        while (true) {\r\n            List<Hash> peers = sel.selectFloodfillParticipants(rkey, 1, _ignore, _facade.getKBuckets());\r\n            if (peers.isEmpty())\r\n                break;\r\n            Hash peer = peers.get(0);\r\n            RouterInfo ri = _facade.lookupRouterInfoLocally(peer);\r\n            if (ri != null && StoreJob.shouldStoreTo(ri) && (!_isLS2 || StoreJob.shouldStoreLS2To(ri))) {\r\n                Set<String> peerIPs = new MaskedIPSet(getContext(), ri, IP_CLOSE_BYTES);\r\n                if (!_ipSet.containsAny(peerIPs)) {\r\n                    _ipSet.addAll(peerIPs);\r\n                    return peer;\r\n                } else {\r\n                    if (_log.shouldLog(Log.INFO))\r\n                        _log.info(getJobId() + \": Skipping verify w/ router too close to the store \" + peer);\r\n                }\r\n            } else {\r\n                if (_log.shouldLog(Log.INFO))\r\n                    _log.info(getJobId() + \": Skipping verify w/ router that is too old \" + peer);\r\n            }\r\n            _ignore.add(peer);\r\n        }\r\n    } else {\r\n        List<Hash> peers = sel.selectFloodfillParticipants(rkey, 1, _ignore, _facade.getKBuckets());\r\n        if (!peers.isEmpty())\r\n            return peers.get(0);\r\n    }\r\n    if (_log.shouldLog(Log.WARN))\r\n        _log.warn(\"No other peers to verify floodfill with, using the one we sent to\");\r\n    return _sentTo;\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterInfo.getOptions",
	"Comment": "retrieve a set of options or statistics that the router can expose.",
	"Method": "Properties getOptions(){\r\n    return _options;\r\n}"
}, {
	"Path": "net.i2p.router.transport.TransportManager.countActivePeers",
	"Comment": "how many peers are we currently connected to, that we have sent a message to or received a message from in the last five minutes.",
	"Method": "int countActivePeers(){\r\n    int peers = 0;\r\n    for (Transport t : _transports.values()) {\r\n        peers += t.countActivePeers();\r\n    }\r\n    return peers;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.UDPPacket.markType",
	"Comment": "flag this packet as a particular type for accounting purposes",
	"Method": "void markType(int type){\r\n    verifyNotReleased();\r\n    _markedType = type;\r\n}"
}, {
	"Path": "net.i2p.router.transport.UPnPManager.update",
	"Comment": "call when the ports might have changedthe transports can call this pretty quickly at startup,which can have multiple upnp threads running at once, butthat should be ok.",
	"Method": "void update(Set<TransportManager.Port> ports){\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"UPnP Update with \" + ports.size() + \" ports\");\r\n    if (!_isRunning)\r\n        return;\r\n    Set<ForwardPort> forwards = new HashSet<ForwardPort>(ports.size());\r\n    for (TransportManager.Port entry : ports) {\r\n        String style = entry.style;\r\n        int port = entry.port;\r\n        int protocol;\r\n        String name;\r\n        if (\"SSU\".equals(style)) {\r\n            protocol = ForwardPort.PROTOCOL_UDP_IPV4;\r\n            name = UDP_PORT_NAME;\r\n        } else if (\"NTCP\".equals(style)) {\r\n            protocol = ForwardPort.PROTOCOL_TCP_IPV4;\r\n            name = TCP_PORT_NAME;\r\n        } else {\r\n            continue;\r\n        }\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"Adding: \" + style + \" \" + port);\r\n        ForwardPort fp = new ForwardPort(name, false, protocol, port);\r\n        forwards.add(fp);\r\n    }\r\n    _upnp.onChangePublicPorts(forwards, _upnpCallback);\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerState.getMessagesReceived",
	"Comment": "i2np messages received. as of 0.9.24, does not include duplicates.",
	"Method": "int getMessagesReceived(){\r\n    return _messagesReceived;\r\n}"
}, {
	"Path": "net.i2p.router.web.helpers.ConfigLoggingHandler.saveChanges",
	"Comment": "the user made changes to the config and wants to save them, solets go ahead and do so.",
	"Method": "void saveChanges(){\r\n    boolean shouldSave = false;\r\n    if ((_levels != null && _levels.length() > 0) || _newLogClass != null) {\r\n        try {\r\n            Properties props = new Properties();\r\n            if (_levels != null)\r\n                props.load(new ByteArrayInputStream(DataHelper.getUTF8(_levels)));\r\n            if (_newLogClass != null)\r\n                props.setProperty(_newLogClass, _newLogLevel);\r\n            _context.logManager().setLimits(props);\r\n            shouldSave = true;\r\n            addFormNotice(_t(\"Log overrides updated\"));\r\n        } catch (IOException ioe) {\r\n            _context.logManager().getLog(ConfigLoggingHandler.class).error(\"Error reading from the props?\", ioe);\r\n            addFormError(\"Error updating the log limits - levels not valid\");\r\n        }\r\n    } else if (!_context.logManager().getLimits().isEmpty()) {\r\n        _context.logManager().setLimits(null);\r\n        shouldSave = true;\r\n        addFormNotice(\"Log limits cleared\");\r\n    }\r\n    if (_defaultLevel != null) {\r\n        String oldDefault = _context.logManager().getDefaultLimit();\r\n        if (_defaultLevel.equals(oldDefault)) {\r\n        } else {\r\n            shouldSave = true;\r\n            _context.logManager().setDefaultLimit(_defaultLevel);\r\n            addFormNotice(\"Default log level updated from \" + oldDefault + \" to \" + _defaultLevel);\r\n        }\r\n    }\r\n    if (_dateFormat != null && !_dateFormat.equals(_context.logManager().getDateFormatPattern())) {\r\n        boolean valid = _context.logManager().setDateFormat(_dateFormat);\r\n        if (valid) {\r\n            shouldSave = true;\r\n            addFormNotice(\"Date format updated\");\r\n        } else {\r\n            addFormError(\"Specified date format is not valid (\" + _dateFormat + \") - not updated\");\r\n        }\r\n    }\r\n    if (_fileSize != null) {\r\n        int newBytes = LogManager.getFileSize(_fileSize);\r\n        int oldBytes = _context.logManager().getFileSize();\r\n        if (newBytes > 0) {\r\n            if (oldBytes != newBytes) {\r\n                _context.logManager().setFileSize(newBytes);\r\n                shouldSave = true;\r\n                addFormNotice(\"File size updated\");\r\n            }\r\n        } else {\r\n            addFormError(\"Specified file size limit is not valid (\" + _fileSize + \") - not updated\");\r\n        }\r\n    }\r\n    if ((_recordFormat != null) && (_recordFormat.trim().length() > 0)) {\r\n        _recordFormat = _recordFormat.trim();\r\n        String old = new String(_context.logManager().getFormat());\r\n        if (_recordFormat.equalsIgnoreCase(old)) {\r\n        } else {\r\n            char[] fmt = new char[_recordFormat.length()];\r\n            for (int i = 0; i < fmt.length; i++) fmt[i] = _recordFormat.charAt(i);\r\n            _context.logManager().setFormat(fmt);\r\n            shouldSave = true;\r\n            addFormNotice(\"Log record format updated\");\r\n        }\r\n    }\r\n    if (shouldSave) {\r\n        boolean saved = _context.logManager().saveConfig();\r\n        if (saved)\r\n            addFormNotice(_t(\"Log configuration saved\"));\r\n        else\r\n            addFormError(\"Error saving the configuration (applied but not saved) - please see the error logs\");\r\n    }\r\n}"
}, {
	"Path": "com.netflix.hollow.core.memory.FreeOrdinalTracker.setNextEmptyOrdinal",
	"Comment": "specify the next ordinal to return after the reusable pool is exhausted",
	"Method": "void setNextEmptyOrdinal(int nextEmptyOrdinal){\r\n    this.nextEmptyOrdinal = nextEmptyOrdinal;\r\n}"
}, {
	"Path": "com.google.zxing.common.BitMatrix.getRow",
	"Comment": "a fast method to retrieve one row of data from the matrix as a bitarray.",
	"Method": "BitArray getRow(int y,BitArray row){\r\n    if (row == null || row.getSize() < width) {\r\n        row = new BitArray(width);\r\n    } else {\r\n        row.clear();\r\n    }\r\n    int offset = y * rowSize;\r\n    for (int x = 0; x < rowSize; x++) {\r\n        row.setBulk(x * 32, bits[offset + x]);\r\n    }\r\n    return row;\r\n}"
}, {
	"Path": "net.i2p.crypto.TrustedUpdate.isUpdatedVersion",
	"Comment": "verifies that the version of the given signed update file is newer thancurrentversion.",
	"Method": "boolean isUpdatedVersion(String currentVersion,File signedFile){\r\n    _newVersion = getVersionString(signedFile);\r\n    return needsUpdate(currentVersion, _newVersion);\r\n}"
}, {
	"Path": "org.jrobin.graph.RrdGraphDef.setForceRulesLegend",
	"Comment": "force the generation of hrule and vrule legend even if those hruleor vrule will not be drawn because out of graph boundaries.",
	"Method": "void setForceRulesLegend(boolean forceRulesLegend){\r\n    this.forceRulesLegend = forceRulesLegend;\r\n}"
}, {
	"Path": "org.klomp.snark.SnarkManager.linkify",
	"Comment": "an html link to the file if complete and a single file,to the directory if not complete or not a single file,or simply the unlinkified name of the snark if a magnet",
	"Method": "String linkify(Snark snark){\r\n    MetaInfo meta = snark.getMetaInfo();\r\n    Storage storage = snark.getStorage();\r\n    if (meta == null || storage == null)\r\n        return DataHelper.escapeHTML(snark.getBaseName());\r\n    StringBuilder buf = new StringBuilder(256);\r\n    String base = DataHelper.escapeHTML(storage.getBaseName());\r\n    String enc = base.replace(\"[\", \"[\").replace(\"]\", \"]\").replace(\"|\", \"|\");\r\n    buf.append(\"<a href=\\\"\").append(_contextPath).append('/').append(enc);\r\n    if (meta.getFiles() != null || !storage.complete())\r\n        buf.append('/');\r\n    buf.append(\"\\\">\").append(base).append(\"<\/a>\");\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.jrobin.core.RrdNioBackend.setLength",
	"Comment": "sets length of the underlying rrd file. this method is called onlyonce, immediately after a new rrd file gets created.",
	"Method": "void setLength(long newLength){\r\n    unmapFile();\r\n    super.setLength(newLength);\r\n    mapFile();\r\n}"
}, {
	"Path": "net.i2p.router.transport.ntcp.NTCPConnection.failInboundEstablishment",
	"Comment": "we are bob. ntcp2 only.this is only for invalid payload received in message 3. we send a termination and close.there will be no receiving.",
	"Method": "void failInboundEstablishment(CipherState sender,byte[] sip_ba,int reason){\r\n    _sender = sender;\r\n    _sendSipk1 = fromLong8LE(sip_ba, 0);\r\n    _sendSipk2 = fromLong8LE(sip_ba, 8);\r\n    _sendSipIV = new byte[SIP_IV_LENGTH];\r\n    System.arraycopy(sip_ba, 16, _sendSipIV, 0, SIP_IV_LENGTH);\r\n    _establishState = EstablishBase.VERIFIED;\r\n    _establishedOn = _context.clock().now();\r\n    _nextMetaTime = Long.MAX_VALUE;\r\n    _nextInfoTime = Long.MAX_VALUE;\r\n    _paddingConfig = OUR_PADDING;\r\n    sendTermination(reason, 0);\r\n}"
}, {
	"Path": "org.jrobin.core.Robin.getParent",
	"Comment": "returns the archive object to which this robin object belongs.",
	"Method": "Archive getParent(){\r\n    return parentArc;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerState.getTheyRelayToUsAs",
	"Comment": "if they have offered to serve as an introducer to us, this is the tagwe can use to publish that fact.",
	"Method": "long getTheyRelayToUsAs(){\r\n    return _theyRelayToUsAs;\r\n}"
}, {
	"Path": "net.i2p.data.i2np.I2NPMessageImpl.setMessageExpiration",
	"Comment": "the expiration is set to one minute from now in the constructor but it can be overridden here.",
	"Method": "void setMessageExpiration(long exp){\r\n    _expiration = exp;\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterAddress.getTransportStyle",
	"Comment": "retrieve the type of transport that must be used to communicate on this address.",
	"Method": "String getTransportStyle(){\r\n    return _transportStyle;\r\n}"
}, {
	"Path": "net.i2p.router.RouterContext.messageHistory",
	"Comment": "tracker component for monitoring what messages are wrapped in what containersand how they proceed through the network.this is fully for debugging, as whena large portion of the network tracks their messages through this messagehistoryand submits their logs, we can correlate them and watch as messages flow from hop to hop.",
	"Method": "MessageHistory messageHistory(){\r\n    return _messageHistory;\r\n}"
}, {
	"Path": "net.i2p.router.web.RouterConsoleRunner.initialize",
	"Comment": "set up basic security constraints for the webapp. add all users and passwords.",
	"Method": "void initialize(RouterContext ctx,WebAppContext context){\r\n    ConstraintSecurityHandler sec = new ConstraintSecurityHandler();\r\n    List<ConstraintMapping> constraints = new ArrayList<ConstraintMapping>(4);\r\n    ConsolePasswordManager mgr = new ConsolePasswordManager(ctx);\r\n    boolean enable = ctx.getBooleanProperty(PROP_PW_ENABLE);\r\n    if (enable) {\r\n        Map<String, String> userpw = mgr.getMD5(PROP_CONSOLE_PW);\r\n        if (userpw.isEmpty()) {\r\n            enable = false;\r\n            ctx.router().saveConfig(PROP_PW_ENABLE, \"false\");\r\n        } else {\r\n            HashLoginService realm = new CustomHashLoginService(JETTY_REALM, context.getContextPath(), ctx.logManager().getLog(RouterConsoleRunner.class));\r\n            sec.setLoginService(realm);\r\n            sec.setAuthenticator(authenticator);\r\n            String[] role = new String[] { JETTY_ROLE };\r\n            for (Map.Entry<String, String> e : userpw.entrySet()) {\r\n                String user = e.getKey();\r\n                String pw = e.getValue();\r\n                Credential cred = Credential.getCredential(MD5_CREDENTIAL_TYPE + pw);\r\n                realm.putUser(user, cred, role);\r\n                Constraint constraint = new Constraint(user, JETTY_ROLE);\r\n                constraint.setAuthenticate(true);\r\n                ConstraintMapping cm = new ConstraintMapping();\r\n                cm.setConstraint(constraint);\r\n                cm.setPathSpec(\"/\");\r\n                constraints.add(cm);\r\n                byte[] b1 = DataHelper.getUTF8(user);\r\n                byte[] b2 = DataHelper.getASCII(user);\r\n                if (!DataHelper.eq(b1, b2)) {\r\n                    try {\r\n                        String user2 = new String(b2, \"ISO-8859-1\");\r\n                        realm.putUser(user2, cred, role);\r\n                        constraint = new Constraint(user2, JETTY_ROLE);\r\n                        constraint.setAuthenticate(true);\r\n                        cm = new ConstraintMapping();\r\n                        cm.setConstraint(constraint);\r\n                        cm.setPathSpec(\"/\");\r\n                        constraints.add(cm);\r\n                        String user3 = new String(b1, \"ISO-8859-1\");\r\n                        realm.putUser(user3, cred, role);\r\n                        constraint = new Constraint(user3, JETTY_ROLE);\r\n                        constraint.setAuthenticate(true);\r\n                        cm = new ConstraintMapping();\r\n                        cm.setConstraint(constraint);\r\n                        cm.setPathSpec(\"/\");\r\n                        constraints.add(cm);\r\n                    } catch (UnsupportedEncodingException uee) {\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Constraint sc = new Constraint();\r\n    sc.setName(\"No trace\");\r\n    ConstraintMapping cm = new ConstraintMapping();\r\n    cm.setMethod(\"TRACE\");\r\n    cm.setConstraint(sc);\r\n    cm.setPathSpec(\"/\");\r\n    constraints.add(cm);\r\n    sc = new Constraint();\r\n    sc.setName(\"No options\");\r\n    cm = new ConstraintMapping();\r\n    cm.setMethod(\"OPTIONS\");\r\n    cm.setConstraint(sc);\r\n    cm.setPathSpec(\"/\");\r\n    constraints.add(cm);\r\n    ConstraintMapping[] cmarr = constraints.toArray(new ConstraintMapping[constraints.size()]);\r\n    sec.setConstraintMappings(cmarr);\r\n    context.setSecurityHandler(sec);\r\n    synchronized (RouterConsoleRunner.class) {\r\n        if (_jettyTimer == null) {\r\n            _jettyTimer = new ScheduledExecutorScheduler(\"Console HashSessionScavenger\", true);\r\n            try {\r\n                _jettyTimer.start();\r\n            } catch (Exception e) {\r\n                System.err.println(\"Warning: ScheduledExecutorScheduler start failed: \" + e);\r\n            }\r\n        }\r\n        context.getServletContext().setAttribute(\"org.eclipse.jetty.server.session.timer\", _jettyTimer);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.client.impl.I2PSessionImpl.getOptions",
	"Comment": "retrieve the configuration options, filtered.all defaults passed in via constructor have been promoted to the primary map.",
	"Method": "Properties getOptions(){\r\n    return _options;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.UDPEndpoint.receive",
	"Comment": "blocking call to receive the next inbound udp packet from any peer.unit testing only. direct from the socket.in normal operation, udpreceiver thread injects to packethandler queue.",
	"Method": "UDPPacket receive(){\r\n    UDPPacket packet = UDPPacket.acquire(_context, true);\r\n    try {\r\n        _socket.receive(packet.getPacket());\r\n        return packet;\r\n    } catch (IOException ioe) {\r\n        packet.release();\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerState.getCurrentReceiveSecond",
	"Comment": "what is the current receive second, for congestion control?",
	"Method": "long getCurrentReceiveSecond(){\r\n    return _currentReceiveSecond;\r\n}"
}, {
	"Path": "io.helidon.webserver.StaticContentSupport.builder",
	"Comment": "creates new builder with defined static content root as a path to the file system. builder provides ability to definemore advanced configuration.",
	"Method": "Builder builder(String resourceRoot,Builder builder,String resourceRoot,ClassLoader classLoader,Builder builder,Path root){\r\n    Objects.requireNonNull(root, \"Attribute root is null!\");\r\n    return new Builder(root);\r\n}"
}, {
	"Path": "org.klomp.snark.BitField.getFieldBytes",
	"Comment": "this returns the actual byte array used.changes to this arrayaffect this bitfield.note that some bits at the end of the bytearray are supposed to be always unset if they represent bitsbigger then the size of the bitfield.caller should synch on this and copy!",
	"Method": "byte[] getFieldBytes(){\r\n    return bitfield;\r\n}"
}, {
	"Path": "net.i2p.data.i2np.DataMessage.writeMessageBody",
	"Comment": "write the message body to the output array, starting at the given index",
	"Method": "int writeMessageBody(byte out,int curIndex){\r\n    if (_data == null) {\r\n        out[curIndex++] = 0x0;\r\n        out[curIndex++] = 0x0;\r\n        out[curIndex++] = 0x0;\r\n        out[curIndex++] = 0x0;\r\n    } else {\r\n        DataHelper.toLong(out, curIndex, 4, _data.length);\r\n        curIndex += 4;\r\n        System.arraycopy(_data, 0, out, curIndex, _data.length);\r\n        curIndex += _data.length;\r\n    }\r\n    return curIndex;\r\n}"
}, {
	"Path": "net.i2p.router.startup.ClientAppConfig.getClientApps",
	"Comment": "go through the properties, and return a list of clientappconfig structures",
	"Method": "List<ClientAppConfig> getClientApps(RouterContext ctx,List<ClientAppConfig> getClientApps,File cfgFile,List<ClientAppConfig> getClientApps,Properties clientApps){\r\n    List<ClientAppConfig> rv = new ArrayList<ClientAppConfig>(8);\r\n    int i = 0;\r\n    while (true) {\r\n        String className = clientApps.getProperty(PREFIX + i + \".main\");\r\n        if (className == null)\r\n            break;\r\n        String clientName = clientApps.getProperty(PREFIX + i + \".name\");\r\n        String args = clientApps.getProperty(PREFIX + i + \".args\");\r\n        String delayStr = clientApps.getProperty(PREFIX + i + \".delay\");\r\n        String onBoot = clientApps.getProperty(PREFIX + i + \".onBoot\");\r\n        String disabled = clientApps.getProperty(PREFIX + i + \".startOnLoad\");\r\n        String classpath = clientApps.getProperty(PREFIX + i + \".classpath\");\r\n        String stopargs = clientApps.getProperty(PREFIX + i + \".stopargs\");\r\n        String uninstallargs = clientApps.getProperty(PREFIX + i + \".uninstallargs\");\r\n        i++;\r\n        boolean dis = disabled != null && \"false\".equals(disabled);\r\n        boolean onStartup = false;\r\n        if (onBoot != null)\r\n            onStartup = \"true\".equals(onBoot) || \"yes\".equals(onBoot);\r\n        long delay = onStartup ? 0 : (className.equals(\"net.i2p.i2ptunnel.TunnelControllerGroup\") ? I2PTUNNEL_STARTUP_DELAY : DEFAULT_STARTUP_DELAY);\r\n        if (delayStr != null && !onStartup)\r\n            try {\r\n                delay = 1000 * Integer.parseInt(delayStr);\r\n            } catch (NumberFormatException nfe) {\r\n            }\r\n        rv.add(new ClientAppConfig(className, clientName, args, delay, dis, classpath, stopargs, uninstallargs));\r\n    }\r\n    return rv;\r\n}"
}, {
	"Path": "io.helidon.webserver.netty.BytesReuseTest.sendLimitedDataInAnUnlimitedLoopAndReleasingTheChunksAllowToRunIndefinitely",
	"Comment": "this test shows that with an unlimited number of connections, each sending 1gb of data, nomemory leak occurs.",
	"Method": "void sendLimitedDataInAnUnlimitedLoopAndReleasingTheChunksAllowToRunIndefinitely(){\r\n    while (true) {\r\n        flood(true, false, 1_000, false);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterAddress.getOptions",
	"Comment": "retrieve the transport specific options necessary for communication",
	"Method": "Properties getOptions(){\r\n    return _options;\r\n}"
}, {
	"Path": "io.helidon.security.OutboundSecurityResponse.builder",
	"Comment": "get an instance of builder to build custom identity propagation response.",
	"Method": "Builder builder(){\r\n    return new Builder();\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.ui.GeneratorDialog.getPreferredFocusedComponent",
	"Comment": "returns component which should be focused when the dialog appears on the screen.",
	"Method": "JComponent getPreferredFocusedComponent(){\r\n    return profileFilter;\r\n}"
}, {
	"Path": "com.spotify.heroic.async.AsyncObservable.failed",
	"Comment": "create an observable that will always be immediately failed with the given throwable.",
	"Method": "AsyncObservable<T> failed(Throwable e){\r\n    return observer -> observer.fail(e);\r\n}"
}, {
	"Path": "org.klomp.snark.MetaInfo.getInfoHash",
	"Comment": "returns the original 20 byte sha1 hash over the bencoded info map.",
	"Method": "byte[] getInfoHash(){\r\n    return info_hash;\r\n}"
}, {
	"Path": "net.i2p.router.RouterThrottleImpl.getMinThrottleTunnels",
	"Comment": "dont ever probabalistically throttle tunnels if we have less than this many",
	"Method": "int getMinThrottleTunnels(){\r\n    return _context.getProperty(\"router.minThrottleTunnels\", DEFAULT_MIN_THROTTLE_TUNNELS);\r\n}"
}, {
	"Path": "net.i2p.util.InternalSocket.getSoLinger",
	"Comment": "supported as of 0.9.33, prior to that threw unsupportedoperationexception",
	"Method": "int getSoLinger(){\r\n    return -1;\r\n}"
}, {
	"Path": "net.i2p.crypto.KeyGenerator.getSigningPublicKey",
	"Comment": "convert a signingprivatekey to a signingpublickey. as of 0.9.16, supports all key types.",
	"Method": "SigningPublicKey getSigningPublicKey(SigningPrivateKey priv){\r\n    SigType type = priv.getType();\r\n    if (type == null)\r\n        throw new IllegalArgumentException(\"Unknown type\");\r\n    try {\r\n        switch(type.getBaseAlgorithm()) {\r\n            case DSA:\r\n                BigInteger x = new NativeBigInteger(1, priv.toByteArray());\r\n                BigInteger y = CryptoConstants.dsag.modPow(x, CryptoConstants.dsap);\r\n                SigningPublicKey pub = new SigningPublicKey();\r\n                pub.setData(SigUtil.rectify(y, SigningPublicKey.KEYSIZE_BYTES));\r\n                return pub;\r\n            case EC:\r\n                ECPrivateKey ecpriv = SigUtil.toJavaECKey(priv);\r\n                BigInteger s = ecpriv.getS();\r\n                ECParameterSpec spec = (ECParameterSpec) type.getParams();\r\n                EllipticCurve curve = spec.getCurve();\r\n                ECPoint g = spec.getGenerator();\r\n                ECPoint w = ECUtil.scalarMult(g, s, curve);\r\n                ECPublicKeySpec ecks = new ECPublicKeySpec(w, ecpriv.getParams());\r\n                KeyFactory eckf = KeyFactory.getInstance(\"EC\");\r\n                ECPublicKey ecpub = (ECPublicKey) eckf.generatePublic(ecks);\r\n                return SigUtil.fromJavaKey(ecpub, type);\r\n            case RSA:\r\n                RSAPrivateKey rsapriv = SigUtil.toJavaRSAKey(priv);\r\n                BigInteger exp = ((RSAKeyGenParameterSpec) type.getParams()).getPublicExponent();\r\n                RSAPublicKeySpec rsaks = new RSAPublicKeySpec(rsapriv.getModulus(), exp);\r\n                KeyFactory rsakf = KeyFactory.getInstance(\"RSA\");\r\n                RSAPublicKey rsapub = (RSAPublicKey) rsakf.generatePublic(rsaks);\r\n                return SigUtil.fromJavaKey(rsapub, type);\r\n            case EdDSA:\r\n                EdDSAPrivateKey epriv = SigUtil.toJavaEdDSAKey(priv);\r\n                EdDSAPublicKey epub = new EdDSAPublicKey(new EdDSAPublicKeySpec(epriv.getA(), epriv.getParams()));\r\n                return SigUtil.fromJavaKey(epub, type);\r\n            default:\r\n                throw new IllegalArgumentException(\"Unsupported algorithm\");\r\n        }\r\n    } catch (GeneralSecurityException gse) {\r\n        throw new IllegalArgumentException(\"Conversion failed\", gse);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.RouterThrottleImpl.allowTunnel",
	"Comment": "with bytesallocated already accounted for across the numtunnels existingtunnels we have agreed to, can we handle another tunnel with our existingbandwidth?",
	"Method": "boolean allowTunnel(double bytesAllocated,int numTunnels){\r\n    int maxKBpsIn = _context.bandwidthLimiter().getInboundKBytesPerSecond();\r\n    int maxKBpsOut = _context.bandwidthLimiter().getOutboundKBytesPerSecond();\r\n    int maxKBps = Math.min(maxKBpsIn, maxKBpsOut);\r\n    int usedIn = Math.min(_context.router().get1sRateIn(), _context.router().get15sRateIn());\r\n    int usedOut = Math.min(_context.router().get1sRate(true), _context.router().get15sRate(true));\r\n    int used = Math.max(usedIn, usedOut);\r\n    int used1mIn = _context.router().get1mRateIn();\r\n    int used1mOut = _context.router().get1mRate(true);\r\n    int availBps = Math.min((maxKBpsIn * 1024 * 9 / 10) - usedIn, (maxKBpsOut * 1024 * 9 / 10) - usedOut);\r\n    if (availBps < MIN_AVAILABLE_BPS) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Reject, avail (\" + availBps + \") less than min\");\r\n        setTunnelStatus(LIMIT_STR);\r\n        return false;\r\n    }\r\n    double share = _context.router().getSharePercentage();\r\n    used = Math.min(used, (int) (bytesAllocated / (10 * 60)));\r\n    availBps = Math.min(availBps, (int) (((maxKBps * 1024) * share) - used));\r\n    _context.statManager().addRateData(\"router.throttleTunnelBytesUsed\", used, maxKBps);\r\n    _context.statManager().addRateData(\"router.throttleTunnelBytesAllowed\", availBps, (long) bytesAllocated);\r\n    long overage = Math.max(used1mIn - (maxKBpsIn * 1024), used1mOut - (maxKBpsOut * 1024));\r\n    if ((overage > 0) && ((overage / (maxKBps * 1024f)) > _context.random().nextFloat())) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Reject tunnel, 1m rate (\" + overage + \" over) indicates overload.\");\r\n        setTunnelStatus(LIMIT_STR);\r\n        return false;\r\n    }\r\n    float maxBps = (maxKBps * 1024f * 0.9f) - MIN_AVAILABLE_BPS;\r\n    float pctFull = (maxBps - availBps) / (maxBps);\r\n    double probReject = Math.pow(pctFull, 16);\r\n    double rand = _context.random().nextFloat();\r\n    boolean reject = rand <= probReject;\r\n    if (reject && _log.shouldLog(Log.WARN))\r\n        _log.warn(\"Reject avail/maxK/used \" + availBps + \"/\" + maxKBps + \"/\" + used + \" pReject = \" + probReject + \" pFull = \" + pctFull + \" numTunnels = \" + numTunnels + \" rand = \" + rand + \" est = \" + bytesAllocated);\r\n    else if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Accept avail/maxK/used \" + availBps + \"/\" + maxKBps + \"/\" + used + \" pReject = \" + probReject + \" pFull = \" + pctFull + \" numTunnels = \" + numTunnels + \" rand = \" + rand + \" est = \" + bytesAllocated);\r\n    if (probReject >= 0.9)\r\n        setTunnelStatus(LIMIT_STR);\r\n    else if (probReject >= 0.5)\r\n        setTunnelStatus(_x(\"Rejecting most tunnels: Bandwidth limit\"));\r\n    else if (probReject >= 0.1)\r\n        setTunnelStatus(_x(\"Accepting most tunnels\"));\r\n    else\r\n        setTunnelStatus(_x(\"Accepting tunnels\"));\r\n    return !reject;\r\n}"
}, {
	"Path": "net.i2p.addressbook.AddressBook.merge",
	"Comment": "merge this addressbook with addressbook other, writing messages about newaddresses or conflicts to log. addresses in addressbook other that arenot in this addressbook are added to this addressbook. in case of aconflict, addresses in this addressbook take precedence",
	"Method": "void merge(AddressBook other,boolean overwrite,Log log){\r\n    if (this.addresses == null)\r\n        throw new IllegalStateException();\r\n    Iterator<Map.Entry<String, HostTxtEntry>> iter = other.iterator();\r\n    try {\r\n        merge2(other, iter, overwrite, log);\r\n    } finally {\r\n        if (iter instanceof HostTxtIterator)\r\n            ((HostTxtIterator) iter).close();\r\n    }\r\n}"
}, {
	"Path": "net.i2p.util.SimpleTimer2.addEvent",
	"Comment": "queue up the given event to be fired no sooner than timeoutms from now.for transition from simplescheduler. uncancellable.new code should use simpletimer2.timedevent.",
	"Method": "void addEvent(SimpleTimer.TimedEvent event,long timeoutMs){\r\n    if (event == null)\r\n        throw new IllegalArgumentException(\"addEvent null\");\r\n    new TimedEvent(this, timeoutMs) {\r\n        @Override\r\n        public void timeReached() {\r\n            event.timeReached();\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return event.toString();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "net.i2p.util.SimpleTimer2.addEvent",
	"Comment": "queue up the given event to be fired no sooner than timeoutms from now.for transition from simplescheduler. uncancellable.new code should use simpletimer2.timedevent.",
	"Method": "void addEvent(SimpleTimer.TimedEvent event,long timeoutMs){\r\n    event.timeReached();\r\n}"
}, {
	"Path": "net.i2p.util.SimpleTimer2.addEvent",
	"Comment": "queue up the given event to be fired no sooner than timeoutms from now.for transition from simplescheduler. uncancellable.new code should use simpletimer2.timedevent.",
	"Method": "void addEvent(SimpleTimer.TimedEvent event,long timeoutMs){\r\n    return event.toString();\r\n}"
}, {
	"Path": "com.google.zxing.qrcode.encoder.MaskUtil.applyMaskPenaltyRule4",
	"Comment": "apply mask penalty rule 4 and return the penalty. calculate the ratio of dark cells and givepenalty if the ratio is far from 50%. it gives 10 penalty for 5% distance.",
	"Method": "int applyMaskPenaltyRule4(ByteMatrix matrix){\r\n    int numDarkCells = 0;\r\n    byte[][] array = matrix.getArray();\r\n    int width = matrix.getWidth();\r\n    int height = matrix.getHeight();\r\n    for (int y = 0; y < height; y++) {\r\n        byte[] arrayY = array[y];\r\n        for (int x = 0; x < width; x++) {\r\n            if (arrayY[x] == 1) {\r\n                numDarkCells++;\r\n            }\r\n        }\r\n    }\r\n    int numTotalCells = matrix.getHeight() * matrix.getWidth();\r\n    int fivePercentVariances = Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells;\r\n    return fivePercentVariances * N4;\r\n}"
}, {
	"Path": "net.i2p.sam.client.SSLUtil.initializeFactory",
	"Comment": "sets up the sslcontext and sets the socket factory. no option prefix allowed.",
	"Method": "SSLServerSocketFactory initializeFactory(Properties opts){\r\n    String ksPass = opts.getProperty(PROP_KEYSTORE_PASSWORD, KeyStoreUtil.DEFAULT_KEYSTORE_PASSWORD);\r\n    String keyPass = opts.getProperty(PROP_KEY_PASSWORD);\r\n    if (keyPass == null) {\r\n        throw new IOException(\"No key password, set \" + PROP_KEY_PASSWORD + \" in \" + (new File(I2PAppContext.getGlobalContext().getConfigDir(), DEFAULT_SAMCLIENT_CONFIGFILE)).getAbsolutePath());\r\n    }\r\n    String ksname = opts.getProperty(PROP_KS_NAME);\r\n    if (ksname == null) {\r\n        throw new IOException(\"No keystore, set \" + PROP_KS_NAME + \" in \" + (new File(I2PAppContext.getGlobalContext().getConfigDir(), DEFAULT_SAMCLIENT_CONFIGFILE)).getAbsolutePath());\r\n    }\r\n    File ks = new File(ksname);\r\n    if (!ks.isAbsolute()) {\r\n        ks = new File(I2PAppContext.getGlobalContext().getConfigDir(), KS_DIR);\r\n        ks = new File(ks, ksname);\r\n    }\r\n    InputStream fis = null;\r\n    try {\r\n        SSLContext sslc = SSLContext.getInstance(\"TLS\");\r\n        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\r\n        fis = new FileInputStream(ks);\r\n        keyStore.load(fis, ksPass.toCharArray());\r\n        KeyStoreUtil.logCertExpiration(keyStore, ks.getAbsolutePath(), 180 * 24 * 60 * 60 * 1000L);\r\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\r\n        kmf.init(keyStore, keyPass.toCharArray());\r\n        sslc.init(kmf.getKeyManagers(), null, I2PAppContext.getGlobalContext().random());\r\n        return sslc.getServerSocketFactory();\r\n    } catch (GeneralSecurityException gse) {\r\n        IOException ioe = new IOException(\"keystore error\");\r\n        ioe.initCause(gse);\r\n        throw ioe;\r\n    } finally {\r\n        if (fis != null)\r\n            try {\r\n                fis.close();\r\n            } catch (IOException ioe) {\r\n            }\r\n    }\r\n}"
}, {
	"Path": "io.helidon.webserver.testsupport.SocketHttpClient.sendAndReceive",
	"Comment": "a helper method that sends the given payload at the given path with the provided method to the webserver.",
	"Method": "String sendAndReceive(Http.Method method,String payload,WebServer webServer,String sendAndReceive,String path,Http.Method method,String payload,WebServer webServer,String sendAndReceive,String path,Http.Method method,String payload,Iterable<String> headers,WebServer webServer){\r\n    try (SocketHttpClient s = new SocketHttpClient(webServer)) {\r\n        s.request(method, path, payload, headers);\r\n        return s.receive();\r\n    }\r\n}"
}, {
	"Path": "com.netflix.hollow.tools.combine.HollowCombinerExcludePrimaryKeysCopyDirector.excludeReferencedObjects",
	"Comment": "exclude any objects which are referenced by excluded objects.",
	"Method": "void excludeReferencedObjects(){\r\n    Set<HollowReadStateEngine> stateEngines = new HashSet<HollowReadStateEngine>();\r\n    for (Map.Entry<HollowTypeReadState, BitSet> entry : excludedOrdinals.entrySet()) stateEngines.add(entry.getKey().getStateEngine());\r\n    for (HollowReadStateEngine stateEngine : stateEngines) {\r\n        Map<String, BitSet> typeBitSetsForStateEngine = new HashMap<String, BitSet>();\r\n        for (Map.Entry<HollowTypeReadState, BitSet> entry : excludedOrdinals.entrySet()) {\r\n            if (entry.getKey().getStateEngine() == stateEngine) {\r\n                String type = entry.getKey().getSchema().getName();\r\n                typeBitSetsForStateEngine.put(type, BitSet.valueOf(entry.getValue().toLongArray()));\r\n            }\r\n        }\r\n        TransitiveSetTraverser.addTransitiveMatches(stateEngine, typeBitSetsForStateEngine);\r\n        for (Map.Entry<String, BitSet> entry : typeBitSetsForStateEngine.entrySet()) excludedOrdinals.put(stateEngine.getTypeState(entry.getKey()), entry.getValue());\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.core.RrdDbPool.getCapacity",
	"Comment": "returns the maximum number of simultaneously open rrd files.",
	"Method": "int getCapacity(){\r\n    return capacity;\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.pool.BuildExecutor.buildZeroHopTunnels",
	"Comment": "iterate over the 0hop tunnels, running them all inline regardless of how many are allowed",
	"Method": "int buildZeroHopTunnels(List<TunnelPool> wanted,int allowed){\r\n    for (int i = 0; i < wanted.size(); i++) {\r\n        TunnelPool pool = wanted.get(0);\r\n        if (pool.getSettings().getLength() == 0) {\r\n            PooledTunnelCreatorConfig cfg = pool.configureNewTunnel();\r\n            if (cfg != null) {\r\n                if (_log.shouldLog(Log.DEBUG))\r\n                    _log.debug(\"Configuring short tunnel \" + i + \" for \" + pool + \": \" + cfg);\r\n                buildTunnel(pool, cfg);\r\n                if (cfg.getLength() > 1) {\r\n                    allowed--;\r\n                }\r\n                wanted.remove(i);\r\n                i--;\r\n            } else {\r\n                if (_log.shouldLog(Log.DEBUG))\r\n                    _log.debug(\"Configured a null tunnel\");\r\n            }\r\n        }\r\n    }\r\n    return allowed;\r\n}"
}, {
	"Path": "org.mitre.dsmiley.httpproxy.ProxyServlet.copyRequestHeaders",
	"Comment": "copy request headers from the servlet client to the proxy request.this is easily overridden to add your own.",
	"Method": "void copyRequestHeaders(HttpServletRequest servletRequest,HttpRequest proxyRequest){\r\n    @SuppressWarnings(\"unchecked\")\r\n    Enumeration<String> enumerationOfHeaderNames = servletRequest.getHeaderNames();\r\n    while (enumerationOfHeaderNames.hasMoreElements()) {\r\n        String headerName = enumerationOfHeaderNames.nextElement();\r\n        copyRequestHeader(servletRequest, proxyRequest, headerName);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.web.helpers.ConfigNetHandler.saveChanges",
	"Comment": "the user made changes to the network config and wants to save them, solets go ahead and do so.",
	"Method": "void saveChanges(){\r\n    boolean restartRequired = false;\r\n    boolean error = false;\r\n    List<String> removes = new ArrayList<String>();\r\n    if (!_ratesOnly) {\r\n        String oldUdp = _context.getProperty(UDPTransport.PROP_SOURCES, _context.router().isHidden() ? \"hidden\" : UDPTransport.DEFAULT_SOURCES);\r\n        String oldUHost = _context.getProperty(UDPTransport.PROP_EXTERNAL_HOST, \"\");\r\n        if (_udpHost1 != null && _udpHost1.length() > 0)\r\n            _udpAutoIP = \"fixed\";\r\n        if (_udpAutoIP != null) {\r\n            String uhost = \"\";\r\n            if (_udpAutoIP.equals(\"fixed\")) {\r\n                if (_settings == null)\r\n                    _settings = Collections.EMPTY_MAP;\r\n                Set<String> addrs = new TreeSet<String>();\r\n                for (Object o : _settings.keySet()) {\r\n                    String k = (String) o;\r\n                    if (k.startsWith(\"addr_\")) {\r\n                        String v = DataHelper.stripHTML(k.substring(5));\r\n                        if (v.length() > 0)\r\n                            addrs.add(v);\r\n                    }\r\n                }\r\n                if (_udpHost1 != null && _udpHost1.length() > 0) {\r\n                    if (verifyAddress(_udpHost1)) {\r\n                        addrs.add(_udpHost1);\r\n                    } else {\r\n                        error = true;\r\n                    }\r\n                }\r\n                int tot = addrs.size();\r\n                int i = 0;\r\n                if (tot > 0) {\r\n                    StringBuilder buf = new StringBuilder(128);\r\n                    for (String addr : addrs) {\r\n                        buf.append(addr);\r\n                        if (++i < tot)\r\n                            buf.append(',');\r\n                    }\r\n                    uhost = buf.toString();\r\n                    changes.put(UDPTransport.PROP_EXTERNAL_HOST, uhost);\r\n                } else {\r\n                    _udpAutoIP = UDPTransport.DEFAULT_SOURCES;\r\n                    removes.add(UDPTransport.PROP_EXTERNAL_HOST);\r\n                }\r\n            } else {\r\n                if (oldUHost.length() > 0)\r\n                    removes.add(UDPTransport.PROP_EXTERNAL_HOST);\r\n            }\r\n            changes.put(UDPTransport.PROP_SOURCES, _udpAutoIP);\r\n            if ((!oldUdp.equals(_udpAutoIP)) || (!oldUHost.equals(uhost))) {\r\n                addFormNotice(_t(\"Updating IP address\"));\r\n                restartRequired = true;\r\n            }\r\n        }\r\n        if (_ipv6Mode != null) {\r\n            String tcp6 = _context.getProperty(TransportUtil.NTCP_IPV6_CONFIG);\r\n            if (tcp6 == null)\r\n                tcp6 = TransportUtil.DEFAULT_IPV6_CONFIG.toConfigString();\r\n            String udp6 = _context.getProperty(TransportUtil.SSU_IPV6_CONFIG);\r\n            if (udp6 == null)\r\n                udp6 = TransportUtil.DEFAULT_IPV6_CONFIG.toConfigString();\r\n            boolean ch = false;\r\n            if (!_ipv6Mode.equals(tcp6)) {\r\n                changes.put(TransportUtil.NTCP_IPV6_CONFIG, _ipv6Mode);\r\n                ch = true;\r\n            }\r\n            if (!_ipv6Mode.equals(udp6)) {\r\n                changes.put(TransportUtil.SSU_IPV6_CONFIG, _ipv6Mode);\r\n                ch = true;\r\n            }\r\n            if (ch)\r\n                addFormNotice(_t(\"Updating IPv6 setting\"));\r\n        }\r\n        String oldNHost = _context.getProperty(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME, \"\");\r\n        String oldNPort = _context.getProperty(ConfigNetHelper.PROP_I2NP_NTCP_PORT, \"\");\r\n        String oldAutoHost = _context.getProperty(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_IP, \"true\");\r\n        String sAutoPort = _context.getProperty(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_PORT, \"true\");\r\n        boolean oldAutoPort = Boolean.parseBoolean(sAutoPort);\r\n        if (_ntcpHostname == null)\r\n            _ntcpHostname = \"\";\r\n        if (_ntcpPort == null)\r\n            _ntcpPort = \"\";\r\n        if (_ntcpAutoIP == null)\r\n            _ntcpAutoIP = \"true\";\r\n        if ((!oldAutoHost.equals(_ntcpAutoIP)) || !oldNHost.equalsIgnoreCase(_ntcpHostname)) {\r\n            boolean valid = true;\r\n            if (\"disabled\".equals(_ntcpAutoIP)) {\r\n                addFormNotice(_t(\"Disabling TCP completely\"));\r\n            } else if (\"false\".equals(_ntcpAutoIP) && _ntcpHostname.length() > 0) {\r\n                valid = verifyAddress(_ntcpHostname);\r\n                if (valid) {\r\n                    changes.put(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME, _ntcpHostname);\r\n                    addFormNotice(_t(\"Updating TCP address to {0}\", _ntcpHostname));\r\n                } else {\r\n                    error = true;\r\n                }\r\n            } else {\r\n                removes.add(ConfigNetHelper.PROP_I2NP_NTCP_HOSTNAME);\r\n                if (\"false\".equals(_ntcpAutoIP))\r\n                    addFormNotice(_t(\"Disabling inbound TCP\"));\r\n                else\r\n                    addFormNotice(_t(\"Updating inbound TCP address to auto\"));\r\n            }\r\n            if (valid) {\r\n                changes.put(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_IP, _ntcpAutoIP);\r\n                changes.put(TransportManager.PROP_ENABLE_NTCP, Boolean.toString(!\"disabled\".equals(_ntcpAutoIP)));\r\n                restartRequired = true;\r\n            }\r\n        }\r\n        if (oldAutoPort != _ntcpAutoPort || !oldNPort.equals(_ntcpPort)) {\r\n            if (_ntcpPort.length() > 0 && !_ntcpAutoPort) {\r\n                int port = Addresses.getPort(_ntcpPort);\r\n                if (port != 0) {\r\n                    changes.put(ConfigNetHelper.PROP_I2NP_NTCP_PORT, _ntcpPort);\r\n                    addFormNotice(_t(\"Updating TCP port to {0}\", _ntcpPort));\r\n                    if (port < 1024) {\r\n                        addFormError(_t(\"Warning - ports less than 1024 are not recommended\"));\r\n                        error = true;\r\n                    }\r\n                } else {\r\n                    addFormError(_t(\"Invalid port\") + \": \" + _ntcpPort);\r\n                    error = true;\r\n                }\r\n            } else {\r\n                removes.add(ConfigNetHelper.PROP_I2NP_NTCP_PORT);\r\n                addFormNotice(_t(\"Updating inbound TCP port to auto\"));\r\n            }\r\n            changes.put(ConfigNetHelper.PROP_I2NP_NTCP_AUTO_PORT, Boolean.toString(_ntcpAutoPort));\r\n            restartRequired = true;\r\n        }\r\n        if ((_udpPort != null) && (_udpPort.length() > 0)) {\r\n            String oldPort = _context.getProperty(UDPTransport.PROP_INTERNAL_PORT, \"unset\");\r\n            if (!oldPort.equals(_udpPort)) {\r\n                int port = Addresses.getPort(_udpPort);\r\n                if (port != 0) {\r\n                    changes.put(UDPTransport.PROP_INTERNAL_PORT, _udpPort);\r\n                    changes.put(UDPTransport.PROP_EXTERNAL_PORT, _udpPort);\r\n                    addFormNotice(_t(\"Updating UDP port to {0}\", _udpPort));\r\n                    if (port < 1024) {\r\n                        addFormError(_t(\"Warning - ports less than 1024 are not recommended\"));\r\n                        error = true;\r\n                    } else {\r\n                        restartRequired = true;\r\n                    }\r\n                } else {\r\n                    addFormError(_t(\"Invalid port\") + \": \" + _udpPort);\r\n                    error = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    boolean ratesUpdated = updateRates();\r\n    boolean switchRequired = false;\r\n    if (!_ratesOnly) {\r\n        switchRequired = _hiddenMode != _context.router().isHidden();\r\n        if (switchRequired) {\r\n            changes.put(PROP_HIDDEN, Boolean.toString(_hiddenMode));\r\n            if (_hiddenMode)\r\n                addFormError(_t(\"Gracefully restarting into Hidden Router Mode\"));\r\n            else\r\n                addFormError(_t(\"Gracefully restarting to exit Hidden Router Mode\"));\r\n        }\r\n        changes.put(Router.PROP_REBUILD_KEYS, Boolean.toString(switchRequired));\r\n        changes.put(Router.PROP_DYNAMIC_KEYS, Boolean.toString(_dynamicKeys));\r\n        if (_context.getBooleanPropertyDefaultTrue(TransportManager.PROP_ENABLE_UPNP) != _upnp) {\r\n            if (_upnp)\r\n                addFormNotice(_t(\"Enabling UPnP\"));\r\n            else\r\n                addFormNotice(_t(\"Disabling UPnP\"));\r\n            addFormNotice(_t(\"Restart required to take effect\"));\r\n        }\r\n        changes.put(TransportManager.PROP_ENABLE_UPNP, Boolean.toString(_upnp));\r\n        if (Boolean.parseBoolean(_context.getProperty(UDPTransport.PROP_LAPTOP_MODE)) != _laptop) {\r\n            if (_laptop)\r\n                addFormNotice(_t(\"Enabling laptop mode\"));\r\n            else\r\n                addFormNotice(_t(\"Disabling laptop mode\"));\r\n        }\r\n        changes.put(UDPTransport.PROP_LAPTOP_MODE, Boolean.toString(_laptop));\r\n        if (Boolean.parseBoolean(_context.getProperty(TransportUtil.PROP_IPV4_FIREWALLED)) != _ipv4Firewalled) {\r\n            if (_ipv4Firewalled)\r\n                addFormNotice(_t(\"Disabling inbound IPv4\"));\r\n            else\r\n                addFormNotice(_t(\"Enabling inbound IPv4\"));\r\n            restartRequired = true;\r\n        }\r\n        changes.put(TransportUtil.PROP_IPV4_FIREWALLED, Boolean.toString(_ipv4Firewalled));\r\n        if (Boolean.parseBoolean(_context.getProperty(TransportUtil.PROP_IPV6_FIREWALLED)) != _ipv6Firewalled) {\r\n            if (_ipv6Firewalled)\r\n                addFormNotice(_t(\"Disabling inbound IPv6\"));\r\n            else\r\n                addFormNotice(_t(\"Enabling inbound IPv6\"));\r\n            restartRequired = true;\r\n        }\r\n        changes.put(TransportUtil.PROP_IPV6_FIREWALLED, Boolean.toString(_ipv6Firewalled));\r\n        if (_context.getBooleanPropertyDefaultTrue(TransportManager.PROP_ENABLE_UDP) != !_udpDisabled) {\r\n            if (_udpDisabled)\r\n                addFormNotice(_t(\"Disabling UDP\"));\r\n            else\r\n                addFormNotice(_t(\"Enabling UDP\"));\r\n            restartRequired = true;\r\n        }\r\n        changes.put(TransportManager.PROP_ENABLE_UDP, Boolean.toString(!_udpDisabled));\r\n        if (_requireIntroductions) {\r\n            changes.put(UDPTransport.PROP_FORCE_INTRODUCERS, \"true\");\r\n            addFormNotice(_t(\"Requiring SSU introducers\"));\r\n        } else {\r\n            removes.add(UDPTransport.PROP_FORCE_INTRODUCERS);\r\n        }\r\n    }\r\n    boolean saved = _context.router().saveConfig(changes, removes);\r\n    if (saved)\r\n        addFormNotice(_t(\"Configuration saved successfully\"));\r\n    else\r\n        addFormError(_t(\"Error saving the configuration (applied but not saved) - please see the error logs\"));\r\n    if (ratesUpdated)\r\n        _context.bandwidthLimiter().reinitialize();\r\n    if (saved && !error) {\r\n        if (switchRequired) {\r\n            hiddenSwitch();\r\n        } else if (restartRequired) {\r\n            addFormNotice(\"Performing a soft restart\");\r\n            _context.router().restart();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.client.naming.NamingService.reverseLookupAll",
	"Comment": "reverse lookup a hash.this implementation returns the result from reverselookup, or null.subclasses implementing reverse lookups should override.",
	"Method": "List<String> reverseLookupAll(Hash h,List<String> reverseLookupAll,Destination dest,List<String> reverseLookupAll,Destination d,Properties options){\r\n    String s = reverseLookup(d, options);\r\n    return (s != null) ? Collections.singletonList(s) : null;\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.security.utils.VoterUtil.visitVariable",
	"Comment": "find security roles on voter implementation and security roles in yaml",
	"Method": "void visitVariable(Variable resolve,Consumer<Pair<String, PsiElement>> consumer){\r\n    PsiElement parent = resolve.getParent();\r\n    if (parent instanceof BinaryExpression) {\r\n        PsiElement rightElement = PsiTreeUtil.prevVisibleLeaf(resolve);\r\n        if (rightElement != null) {\r\n            IElementType node = rightElement.getNode().getElementType();\r\n            if (isIfOperand(node)) {\r\n                PsiElement leftOperand = ((BinaryExpression) parent).getLeftOperand();\r\n                String stringValue = PhpElementsUtil.getStringValue(leftOperand);\r\n                if (StringUtils.isNotBlank(stringValue)) {\r\n                    consumer.accept(Pair.create(stringValue, leftOperand));\r\n                }\r\n            }\r\n        }\r\n        PsiElement leftElement = PsiTreeUtil.nextVisibleLeaf(resolve);\r\n        if (leftElement != null) {\r\n            IElementType node = leftElement.getNode().getElementType();\r\n            if (isIfOperand(node)) {\r\n                PsiElement rightOperand = ((BinaryExpression) parent).getRightOperand();\r\n                String stringValue = PhpElementsUtil.getStringValue(rightOperand);\r\n                if (StringUtils.isNotBlank(stringValue)) {\r\n                    consumer.accept(Pair.create(stringValue, rightOperand));\r\n                }\r\n            }\r\n        }\r\n    } else if (parent instanceof ParameterList && PsiElementUtils.getParameterIndexValue(resolve) == 0) {\r\n        PsiElement functionCall = parent.getParent();\r\n        if (functionCall instanceof FunctionReference && \"in_array\".equalsIgnoreCase(((FunctionReference) functionCall).getName())) {\r\n            PsiElement[] functionParameter = ((ParameterList) parent).getParameters();\r\n            if (functionParameter.length > 1) {\r\n                if (functionParameter[1] instanceof ArrayCreationExpression) {\r\n                    PsiElement[] psiElements = PsiTreeUtil.collectElements(functionParameter[1], psiElement -> psiElement.getNode().getElementType() == PhpElementTypes.ARRAY_VALUE);\r\n                    for (PsiElement psiElement : psiElements) {\r\n                        PsiElement firstChild = psiElement.getFirstChild();\r\n                        String stringValue = PhpElementsUtil.getStringValue(firstChild);\r\n                        if (StringUtils.isNotBlank(stringValue)) {\r\n                            consumer.accept(Pair.create(stringValue, firstChild));\r\n                        }\r\n                    }\r\n                } else if (functionParameter[1] instanceof MemberReference) {\r\n                    PsiElement PsiReference = ((PsiReference) functionParameter[1]).resolve();\r\n                    if (PsiReference instanceof Field) {\r\n                        PsiElement defaultValue = ((Field) PsiReference).getDefaultValue();\r\n                        if (defaultValue instanceof ArrayCreationExpression) {\r\n                            for (String s : PhpElementsUtil.getArrayValuesAsString((ArrayCreationExpression) defaultValue)) {\r\n                                consumer.accept(Pair.create(s, defaultValue));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else if (parent instanceof PhpSwitch) {\r\n        for (PhpCase phpCase : ((PhpSwitch) parent).getAllCases()) {\r\n            PhpPsiElement condition = phpCase.getCondition();\r\n            String stringValue = PhpElementsUtil.getStringValue(condition);\r\n            if (StringUtils.isNotBlank(stringValue)) {\r\n                consumer.accept(Pair.create(stringValue, condition));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.netflix.hollow.tools.filter.FilteredHollowBlobWriter.filterSnapshot",
	"Comment": "filter a snapshot, provided via the inputstream, to each of the outputstreams.the number of provided outputstreams should be equal to the number of provided hollowfilterconfigs at instantiation.",
	"Method": "void filterSnapshot(InputStream in,OutputStream out){\r\n    filter(false, in, out);\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.FloodfillNetworkDatabaseFacade.lookupBeforeDropping",
	"Comment": "search for a newer router info, drop it from the db if the search fails, unless just started up or have bigger problems.",
	"Method": "void lookupBeforeDropping(Hash peer,RouterInfo info){\r\n    if (info.getNetworkId() == _networkID && (getKBucketSetSize() < MIN_REMAINING_ROUTERS || _context.router().getUptime() < DONT_FAIL_PERIOD || _context.commSystem().countActivePeers() <= MIN_ACTIVE_PEERS)) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Not failing \" + peer.toBase64() + \" as we are just starting up or have problems\");\r\n        return;\r\n    }\r\n    if (_floodfillEnabled || _context.jobQueue().getMaxLag() > 500 || _context.banlist().isBanlistedForever(peer) || getKBucketSetSize() > MAX_DB_BEFORE_SKIPPING_SEARCH) {\r\n        super.lookupBeforeDropping(peer, info);\r\n        return;\r\n    }\r\n    search(peer, new DropLookupFoundJob(_context, peer, info), new DropLookupFailedJob(_context, peer, info), 10 * 1000, false);\r\n}"
}, {
	"Path": "org.jrobin.core.RrdSafeFileBackendFactory.open",
	"Comment": "creates rrdsafefilebackend object for the given file path.",
	"Method": "RrdBackend open(String path,boolean readOnly){\r\n    return new RrdSafeFileBackend(path, lockWaitTime, lockRetryPeriod);\r\n}"
}, {
	"Path": "net.i2p.client.streaming.I2PSocketManagerFactory.createManager",
	"Comment": "create a socket manager using the destination loaded from the given private keystream and connected to the i2cp router on the specified machine on the givenport.blocks for a long time while the router builds tunnels if connect is true.",
	"Method": "I2PSocketManager createManager(I2PSocketManager createManager,Properties opts,I2PSocketManager createManager,String host,int port,I2PSocketManager createManager,String i2cpHost,int i2cpPort,Properties opts,I2PSocketManager createManager,InputStream myPrivateKeyStream,I2PSocketManager createManager,InputStream myPrivateKeyStream,Properties opts,I2PSocketManager createManager,InputStream myPrivateKeyStream,String i2cpHost,int i2cpPort,Properties opts,I2PSocketManager createManager,InputStream myPrivateKeyStream,String i2cpHost,int i2cpPort,Properties opts,boolean connect,I2PSocketManager createManager,I2PSession session,Properties opts,String name){\r\n    I2PAppContext context = I2PAppContext.getGlobalContext();\r\n    String classname = DEFAULT_MANAGER;\r\n    try {\r\n        Class<?> cls = Class.forName(classname);\r\n        if (!I2PSocketManager.class.isAssignableFrom(cls))\r\n            throw new IllegalArgumentException(classname + \" is not an I2PSocketManager\");\r\n        Constructor<?> con = cls.getConstructor(I2PAppContext.class, I2PSession.class, Properties.class, String.class);\r\n        I2PSocketManager mgr = (I2PSocketManager) con.newInstance(new Object[] { context, session, opts, name });\r\n        return mgr;\r\n    } catch (Throwable t) {\r\n        getLog().log(Log.CRIT, \"Error loading \" + classname, t);\r\n        throw new IllegalStateException(t);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.ProfileManagerImpl.dbLookupReceived",
	"Comment": "note that the local router received a db lookup from the given peer",
	"Method": "void dbLookupReceived(Hash peer){\r\n    PeerProfile data = getProfile(peer);\r\n    data.setLastHeardFrom(_context.clock().now());\r\n    if (!data.getIsExpandedDB())\r\n        return;\r\n}"
}, {
	"Path": "org.mitre.dsmiley.httpproxy.ProxyServlet.getRealCookie",
	"Comment": "take any client cookies that were originally from the proxy and prepare them to send to theproxy.this relies on cookie headers being set correctly according to rfc 6265 sec 5.4.this also blocks any local cookies from being sent to the proxy.",
	"Method": "String getRealCookie(String cookieValue){\r\n    StringBuilder escapedCookie = new StringBuilder();\r\n    String[] cookies = cookieValue.split(\"[;,]\");\r\n    for (String cookie : cookies) {\r\n        String[] cookieSplit = cookie.split(\"=\");\r\n        if (cookieSplit.length == 2) {\r\n            String cookieName = cookieSplit[0].trim();\r\n            if (cookieName.startsWith(getCookieNamePrefix(cookieName))) {\r\n                cookieName = cookieName.substring(getCookieNamePrefix(cookieName).length());\r\n                if (escapedCookie.length() > 0) {\r\n                    escapedCookie.append(\"; \");\r\n                }\r\n                escapedCookie.append(cookieName).append(\"=\").append(cookieSplit[1].trim());\r\n            }\r\n        }\r\n    }\r\n    return escapedCookie.toString();\r\n}"
}, {
	"Path": "net.i2p.data.DataStructureImpl.read",
	"Comment": "repeated reads until the buffer is full or ioexception is thrown",
	"Method": "int read(InputStream in,byte target){\r\n    return DataHelper.read(in, target);\r\n}"
}, {
	"Path": "net.i2p.sam.SAMv2StreamSession.connect",
	"Comment": "connect the sam stream session to the specified destination",
	"Method": "boolean connect(int id,String dest,Properties props){\r\n    if (!canCreate) {\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"Trying to create an outgoing connection using a receive-only session\");\r\n        throw new SAMInvalidDirectionException(\"Trying to create connections through a receive-only session\");\r\n    }\r\n    if (checkSocketHandlerId(id)) {\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"The specified id (\" + id + \") is already in use\");\r\n        return false;\r\n    }\r\n    Destination d = SAMUtils.getDest(dest);\r\n    I2PSocketOptions opts = socketMgr.buildOptions(props);\r\n    if (props.getProperty(I2PSocketOptions.PROP_CONNECT_TIMEOUT) == null)\r\n        opts.setConnectTimeout(60 * 1000);\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Connecting new I2PSocket...\");\r\n    StreamConnector connector = new StreamConnector(id, d, opts);\r\n    I2PAppThread connectThread = new I2PAppThread(connector, \"StreamConnector\" + id);\r\n    connectThread.start();\r\n    return true;\r\n}"
}, {
	"Path": "net.i2p.crypto.CryptixRijndael_Algorithm.mul4",
	"Comment": "convenience method used in generating transposition boxes",
	"Method": "int mul4(int a,byte[] b){\r\n    if (a == 0)\r\n        return 0;\r\n    a = _log[a & 0xFF];\r\n    int a0 = (b[0] != 0) ? _alog[(a + _log[b[0] & 0xFF]) % 255] & 0xFF : 0;\r\n    int a1 = (b[1] != 0) ? _alog[(a + _log[b[1] & 0xFF]) % 255] & 0xFF : 0;\r\n    int a2 = (b[2] != 0) ? _alog[(a + _log[b[2] & 0xFF]) % 255] & 0xFF : 0;\r\n    int a3 = (b[3] != 0) ? _alog[(a + _log[b[3] & 0xFF]) % 255] & 0xFF : 0;\r\n    return a0 << 24 | a1 << 16 | a2 << 8 | a3;\r\n}"
}, {
	"Path": "com.netflix.hollow.core.memory.ByteArrayOrdinalMap.compact",
	"Comment": "reclaim space in the byte array used in the previous cycle, but not referenced in this cycle. this is achieved by shifting all used byte sequences down in the byte array, then updating the key array to reflect the new pointers and exclude the removed entries.this is also where ordinals which are unused are returned to the pool.",
	"Method": "void compact(ThreadSafeBitSet usedOrdinals){\r\n    long[] populatedReverseKeys = new long[size];\r\n    int counter = 0;\r\n    for (int i = 0; i < pointersAndOrdinals.length(); i++) {\r\n        long key = pointersAndOrdinals.get(i);\r\n        if (key != EMPTY_BUCKET_VALUE) {\r\n            populatedReverseKeys[counter++] = key << BITS_PER_ORDINAL | key >>> BITS_PER_POINTER;\r\n        }\r\n    }\r\n    Arrays.sort(populatedReverseKeys);\r\n    SegmentedByteArray arr = byteData.getUnderlyingArray();\r\n    long currentCopyPointer = 0;\r\n    for (int i = 0; i < populatedReverseKeys.length; i++) {\r\n        int ordinal = (int) (populatedReverseKeys[i] & ORDINAL_MASK);\r\n        if (usedOrdinals.get(ordinal)) {\r\n            long pointer = populatedReverseKeys[i] >>> BITS_PER_ORDINAL;\r\n            int length = VarInt.readVInt(arr, pointer);\r\n            length += VarInt.sizeOfVInt(length);\r\n            if (currentCopyPointer != pointer)\r\n                arr.copy(arr, pointer, currentCopyPointer, length);\r\n            populatedReverseKeys[i] = populatedReverseKeys[i] << BITS_PER_POINTER | currentCopyPointer;\r\n            currentCopyPointer += length;\r\n        } else {\r\n            freeOrdinalTracker.returnOrdinalToPool(ordinal);\r\n            populatedReverseKeys[i] = EMPTY_BUCKET_VALUE;\r\n        }\r\n    }\r\n    byteData.setPosition(currentCopyPointer);\r\n    freeOrdinalTracker.sort();\r\n    for (int i = 0; i < pointersAndOrdinals.length(); i++) {\r\n        pointersAndOrdinals.set(i, EMPTY_BUCKET_VALUE);\r\n    }\r\n    populateNewHashArray(pointersAndOrdinals, populatedReverseKeys);\r\n    size = usedOrdinals.cardinality();\r\n    pointersByOrdinal = null;\r\n    unusedPreviousOrdinals = null;\r\n}"
}, {
	"Path": "org.jrobin.core.RrdBackendFactory.setDefaultFactory",
	"Comment": "replaces the default backend factory with a new one. this method must be called before\tthe first rrd gets created.",
	"Method": "void setDefaultFactory(String factoryName){\r\n    if (!RrdBackend.isInstanceCreated()) {\r\n        defaultFactory = getFactory(factoryName);\r\n    } else {\r\n        throw new RrdException(\"Could not change the default backend factory. This method must be called before the first RRD gets created\");\r\n    }\r\n}"
}, {
	"Path": "net.i2p.util.InternalServerSocket.isBound",
	"Comment": "returns true as of 0.9.33, prior to that threw illegalargumentexception",
	"Method": "boolean isBound(){\r\n    return true;\r\n}"
}, {
	"Path": "net.i2p.crypto.eddsa.math.GroupElement.toP3PrecomputeDouble",
	"Comment": "converts the group element to the p3 representation, with dblprecmp populated.",
	"Method": "GroupElement toP3PrecomputeDouble(){\r\n    return toRep(Representation.P3PrecomputedDouble);\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.lang.IgnoreParserDefinition.createParser",
	"Comment": "returns the parser for parsing files in the specified project.",
	"Method": "PsiParser createParser(Project project){\r\n    return new IgnoreParser();\r\n}"
}, {
	"Path": "com.netflix.hollow.core.memory.ThreadSafeBitSet.andNot",
	"Comment": "return a new bit set which contains all bits which are contained in this bit set, and which are not contained in the other bit set.in other words, return a new bit set, which is a bitwise and with the bitwise not of the other bit set.",
	"Method": "ThreadSafeBitSet andNot(ThreadSafeBitSet other){\r\n    if (other.log2SegmentSize != log2SegmentSize)\r\n        throw new IllegalArgumentException(\"Segment sizes must be the same\");\r\n    ThreadSafeBitSetSegments thisSegments = this.segments.get();\r\n    ThreadSafeBitSetSegments otherSegments = other.segments.get();\r\n    ThreadSafeBitSetSegments newSegments = new ThreadSafeBitSetSegments(thisSegments.numSegments(), numLongsPerSegment);\r\n    for (int i = 0; i < thisSegments.numSegments(); i++) {\r\n        AtomicLongArray thisArray = thisSegments.getSegment(i);\r\n        AtomicLongArray otherArray = (i < otherSegments.numSegments()) ? otherSegments.getSegment(i) : null;\r\n        AtomicLongArray newArray = newSegments.getSegment(i);\r\n        for (int j = 0; j < thisArray.length(); j++) {\r\n            long thisLong = thisArray.get(j);\r\n            long otherLong = (otherArray == null) ? 0 : otherArray.get(j);\r\n            newArray.set(j, thisLong & ~otherLong);\r\n        }\r\n    }\r\n    ThreadSafeBitSet andNot = new ThreadSafeBitSet(log2SegmentSize);\r\n    andNot.segments.set(newSegments);\r\n    return andNot;\r\n}"
}, {
	"Path": "i2p.susi.util.Folder.getPages",
	"Comment": "returns the number of pages in the folder.minimum of 1 even if empty.",
	"Method": "int getPages(){\r\n    return pages;\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.HopConfig.getIVKey",
	"Comment": "what key should we use to encrypt the preiv before passing it on?",
	"Method": "SessionKey getIVKey(){\r\n    return _ivKey;\r\n}"
}, {
	"Path": "net.i2p.crypto.TrustedUpdate.main",
	"Comment": "parses command line arguments when this class is used from the commandline.exits 1 on failure so this can be used in scripts.",
	"Method": "void main(String[] args){\r\n    boolean ok = false;\r\n    try {\r\n        if (\"keygen\".equals(args[0])) {\r\n            ok = genKeysCLI(args[1], args[2]);\r\n        } else if (\"showversion\".equals(args[0])) {\r\n            ok = showVersionCLI(args[1]);\r\n        } else if (\"sign\".equals(args[0])) {\r\n            ok = signCLI(args[1], args[2], args[3], args[4]);\r\n        } else if (\"verifysig\".equals(args[0])) {\r\n            ok = verifySigCLI(args[1]);\r\n        } else if (\"verifyupdate\".equals(args[0])) {\r\n            ok = verifyUpdateCLI(args[1]);\r\n        } else if (\"verifyversion\".equals(args[0])) {\r\n            ok = verifyVersionCLI(args[1]);\r\n        } else {\r\n            showUsageCLI();\r\n        }\r\n    } catch (ArrayIndexOutOfBoundsException aioobe) {\r\n        showUsageCLI();\r\n    }\r\n    if (!ok)\r\n        System.exit(1);\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.MessageOutputStream.close",
	"Comment": "this does a flush, and blocks until the close packet is acked.",
	"Method": "void close(){\r\n    if (!_closed.compareAndSet(false, true)) {\r\n        synchronized (_dataLock) {\r\n            _dataLock.notifyAll();\r\n        }\r\n        _log.logCloseLoop(\"MOS\");\r\n        return;\r\n    }\r\n    _flusher.cancel();\r\n    flush(false);\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Output stream closed after writing \" + _written);\r\n    ByteArray ba = null;\r\n    synchronized (_dataLock) {\r\n        if (_buf != null) {\r\n            ba = new ByteArray(_buf);\r\n            _buf = null;\r\n            _valid = 0;\r\n        }\r\n        _dataLock.notifyAll();\r\n    }\r\n    if (ba != null) {\r\n        _dataCache.release(ba);\r\n    }\r\n}"
}, {
	"Path": "io.helidon.security.EndpointConfig.builder",
	"Comment": "creates a fluent api builder to build new instances of this class.",
	"Method": "Builder builder(){\r\n    return new Builder();\r\n}"
}, {
	"Path": "net.i2p.data.i2np.GarlicMessage.writeMessageBody",
	"Comment": "write the message body to the output array, starting at the given index",
	"Method": "int writeMessageBody(byte out,int curIndex){\r\n    DataHelper.toLong(out, curIndex, 4, _data.length);\r\n    curIndex += 4;\r\n    System.arraycopy(_data, 0, out, curIndex, _data.length);\r\n    curIndex += _data.length;\r\n    return curIndex;\r\n}"
}, {
	"Path": "com.netflix.hollow.api.producer.HollowIncrementalProducer.runCycle",
	"Comment": "runs a hollow cycle, if successful, cleans the mutations map.",
	"Method": "long runCycle(){\r\n    long recordsRemoved = countRecordsToRemove();\r\n    long recordsAddedOrModified = this.mutations.values().size() - recordsRemoved;\r\n    try {\r\n        long version = producer.runCycle(populator);\r\n        if (version == lastSucessfulCycle) {\r\n            return version;\r\n        }\r\n        listeners.fireIncrementalCycleComplete(version, recordsAddedOrModified, recordsRemoved, new HashMap<String, Object>(cycleMetadata));\r\n        clearChanges();\r\n        lastSucessfulCycle = version;\r\n        return version;\r\n    } catch (Exception e) {\r\n        listeners.fireIncrementalCycleFail(e, recordsAddedOrModified, recordsRemoved, new HashMap<String, Object>(cycleMetadata));\r\n        return FAILED_VERSION;\r\n    } finally {\r\n        clearCycleMetadata();\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.core.RrdNioByteBufferBackend.setLength",
	"Comment": "sets length of the underlying rrd file. this method is called only once, immediately\tafter a new rrd file gets created.",
	"Method": "void setLength(long newLength){\r\n    m_writeLock.lock();\r\n    try {\r\n        super.setLength(newLength);\r\n        m_ch = file.getChannel();\r\n        m_byteBuffer = ByteBuffer.allocate((int) newLength);\r\n        m_ch.read(m_byteBuffer, 0);\r\n        m_byteBuffer.position(0);\r\n    } finally {\r\n        m_writeLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.TunnelCreatorConfig.getLength",
	"Comment": "how many hops are there in the tunnel? including us. i.e. one more than the tunnelcreatorconfig length.",
	"Method": "int getLength(){\r\n    return _config.length;\r\n}"
}, {
	"Path": "edu.internet2.ndt.Tcpbw100.test_s2c",
	"Comment": "s2c throughput test to measure network bandwidth from server to client.",
	"Method": "boolean test_s2c(Protocol paramProtoObj,Socket paramSocketObj){\r\n    byte[] buff = new byte[NDTConstants.PREDEFINED_BUFFER_SIZE];\r\n    Message msg = new Message();\r\n    if ((_yTests & NDTConstants.TEST_S2C) == NDTConstants.TEST_S2C) {\r\n        showStatus(_resBundDisplayMsgs.getString(\"inboundTest\"));\r\n        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"runningInboundTest\") + \" \");\r\n        _txtStatistics.append(_resBundDisplayMsgs.getString(\"runningInboundTest\") + \" \");\r\n        _sEmailText += _resBundDisplayMsgs.getString(\"runningInboundTest\") + \" \";\r\n        pub_status = \"runningInboundTest\";\r\n        if (paramProtoObj.recv_msg(msg) != NDTConstants.PROTOCOL_MSG_READ_SUCCESS) {\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"protocolError\") + parseMsgBodyToInt(new String(msg.getBody()), 16) + \" instead\\n\";\r\n            return true;\r\n        }\r\n        if (msg.getType() != MessageType.TEST_PREPARE) {\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"inboundWrongMessage\") + \"\\n\";\r\n            if (msg.getType() == MessageType.MSG_ERROR) {\r\n                _sErrMsg += \"ERROR MSG: \" + parseMsgBodyToInt(new String(msg.getBody()), 16) + \"\\n\";\r\n            }\r\n            return true;\r\n        }\r\n        int iS2cport = parseMsgBodyToInt(new String(msg.getBody()));\r\n        Socket inSocket;\r\n        try {\r\n            inSocket = newSocket(hostAddress, iS2cport);\r\n        } catch (UnknownHostException e) {\r\n            _log.warn(\"Don't know about host: \" + sHostName, e);\r\n            _sErrMsg = \"unknown server\\n\";\r\n            return true;\r\n        } catch (IOException e) {\r\n            _log.warn(\"Couldn't get 3rd connection to: \" + sHostName, e);\r\n            _sErrMsg = \"Server Failed while receiving data\\n\";\r\n            return true;\r\n        }\r\n        InputStream srvin = inSocket.getInputStream();\r\n        long iBitCount = 0;\r\n        int inlth;\r\n        if (paramProtoObj.recv_msg(msg) != NDTConstants.PROTOCOL_MSG_READ_SUCCESS) {\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"protocolError\") + parseMsgBodyToInt(new String(msg.getBody()), 16) + \" instead\\n\";\r\n            return true;\r\n        }\r\n        if (msg.getType() != MessageType.TEST_START) {\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"inboundWrongMessage\") + \"\\n\";\r\n            if (msg.getType() == MessageType.MSG_ERROR) {\r\n                _sErrMsg += \"ERROR MSG: \" + parseMsgBodyToInt(new String(msg.getBody()), 16) + \"\\n\";\r\n            }\r\n            return true;\r\n        }\r\n        inSocket.setSoTimeout(15000);\r\n        _dTime = System.currentTimeMillis();\r\n        pub_time = _dTime;\r\n        Timer s2cspdUpdateTimer = new Timer();\r\n        s2cspdUpdateTimer.scheduleAtFixedRate(new TimerTask() {\r\n            @Override\r\n            public void run() {\r\n                pub_s2cspd = ((NDTConstants.EIGHT * pub_bytes) / NDTConstants.KILO) / (System.currentTimeMillis() - _dTime);\r\n            }\r\n        }, 100, _s2cspdUpdateTime);\r\n        try {\r\n            while ((inlth = srvin.read(buff, 0, buff.length)) > 0) {\r\n                iBitCount += inlth;\r\n                pub_bytes = iBitCount;\r\n                if ((System.currentTimeMillis() - _dTime) > 14500) {\r\n                    break;\r\n                }\r\n            }\r\n        } catch (IOException ioExcep) {\r\n            _log.warn(\"Couldn't perform s2c testing to: \" + sHostName, ioExcep);\r\n            _sErrMsg = \"Server Failed while reading socket data\\n\";\r\n            return true;\r\n        } finally {\r\n            s2cspdUpdateTimer.cancel();\r\n        }\r\n        _dTime = System.currentTimeMillis() - _dTime;\r\n        _log.warn(iBitCount + \" bytes \" + (NDTConstants.EIGHT * iBitCount) / _dTime + \" kb/s \" + _dTime / NDTConstants.KILO + \" secs\");\r\n        _dS2cspd = ((NDTConstants.EIGHT * iBitCount) / NDTConstants.KILO) / _dTime;\r\n        if (paramProtoObj.recv_msg(msg) != NDTConstants.PROTOCOL_MSG_READ_SUCCESS) {\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"protocolError\") + parseMsgBodyToInt(new String(msg.getBody()), 16) + \" instead\\n\";\r\n            return true;\r\n        }\r\n        if (msg.getType() != MessageType.TEST_MSG) {\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"inboundWrongMessage\") + \"\\n\";\r\n            if (msg.getType() == MessageType.MSG_ERROR) {\r\n                _sErrMsg += \"ERROR MSG: \" + parseMsgBodyToInt(new String(msg.getBody()), 16) + \"\\n\";\r\n            }\r\n            return true;\r\n        }\r\n        if (jsonSupport) {\r\n            try {\r\n                String tmpstr3 = new String(msg.getBody());\r\n                _dSs2cspd = Double.parseDouble(JSONUtils.getValueFromJsonObj(tmpstr3, \"ThroughputValue\")) / NDTConstants.KILO;\r\n                _iSsndqueue = Integer.parseInt(JSONUtils.getValueFromJsonObj(tmpstr3, \"UnsentDataAmount\"));\r\n                _dSbytes = Double.parseDouble(JSONUtils.getValueFromJsonObj(tmpstr3, \"TotalSentByte\"));\r\n            } catch (Exception e) {\r\n                _sErrMsg = _resBundDisplayMsgs.getString(\"inboundWrongMessage\") + \"\\n\";\r\n                _log.warn(_sErrMsg, e);\r\n                return true;\r\n            }\r\n        } else {\r\n            try {\r\n                String tmpstr3 = new String(msg.getBody());\r\n                int k1 = tmpstr3.indexOf(\" \");\r\n                int k2 = tmpstr3.substring(k1 + 1).indexOf(\" \");\r\n                _dSs2cspd = Double.parseDouble(tmpstr3.substring(0, k1)) / NDTConstants.KILO;\r\n                _iSsndqueue = Integer.parseInt(tmpstr3.substring(k1 + 1).substring(0, k2));\r\n                _dSbytes = Double.parseDouble(tmpstr3.substring(k1 + 1).substring(k2 + 1));\r\n            } catch (Exception e) {\r\n                _sErrMsg = _resBundDisplayMsgs.getString(\"inboundWrongMessage\") + \"\\n\";\r\n                _log.warn(_sErrMsg, e);\r\n                return true;\r\n            }\r\n        }\r\n        if (_dS2cspd < 1.0) {\r\n            _resultsTxtPane.append(NDTUtils.prtdbl(_dS2cspd * NDTConstants.KILO) + \"kb/s\\n\");\r\n            _txtStatistics.append(NDTUtils.prtdbl(_dS2cspd * NDTConstants.KILO) + \"kb/s\\n\");\r\n            _sEmailText += NDTUtils.prtdbl(_dS2cspd * NDTConstants.KILO) + \"kb/s\\n\
	";\r\n        } else {\r\n            _resultsTxtPane.append(NDTUtils.prtdbl(_dS2cspd) + \"Mb/s\\n\");\r\n            _txtStatistics.append(NDTUtils.prtdbl(_dS2cspd) + \"Mb/s\\n\");\r\n            _sEmailText += NDTUtils.prtdbl(_dS2cspd) + \"Mb/s\\n\
	";\r\n        }\r\n        pub_s2cspd = _dS2cspd;\r\n        pub_status = \"done\";\r\n        srvin.close();\r\n        inSocket.close();\r\n        buff = Double.toString(_dS2cspd * NDTConstants.KILO).getBytes();\r\n        String tmpstr4 = new String(buff, 0, buff.length);\r\n        _log.warn(\"Sending '\" + tmpstr4 + \"' back to server\");\r\n        paramProtoObj.send_json_msg(MessageType.TEST_MSG, buff);\r\n        _sTestResults = \"\";\r\n        int i = 0;\r\n        paramSocketObj.setSoTimeout(5000);\r\n        try {\r\n            for (; ; ) {\r\n                if (paramProtoObj.recv_msg(msg) != NDTConstants.PROTOCOL_MSG_READ_SUCCESS) {\r\n                    _sErrMsg = _resBundDisplayMsgs.getString(\"protocolError\") + parseMsgBodyToInt(new String(msg.getBody()), 16) + \" instead\\n\";\r\n                    return true;\r\n                }\r\n                if (msg.getType() == MessageType.TEST_FINALIZE) {\r\n                    break;\r\n                }\r\n                if (msg.getType() != MessageType.TEST_MSG) {\r\n                    _sErrMsg = _resBundDisplayMsgs.getString(\"inboundWrongMessage\") + \"\\n\";\r\n                    if (msg.getType() == MessageType.MSG_ERROR) {\r\n                        _sErrMsg += \"ERROR MSG: \" + parseMsgBodyToInt(new String(msg.getBody()), 16) + \"\\n\";\r\n                    }\r\n                    return true;\r\n                }\r\n                if (jsonSupport) {\r\n                    _sTestResults += JSONUtils.getSingleMessage(new String(msg.getBody()));\r\n                } else {\r\n                    _sTestResults += new String(msg.getBody());\r\n                }\r\n                i++;\r\n            }\r\n        } catch (IOException ioExcep) {\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"s2cThroughputFailed\") + \"\\n\";\r\n            _log.warn(\"Couldn't perform s2c testing to: \" + sHostName, ioExcep);\r\n            _sErrMsg += \"Server Failed while reading socket data\\n\";\r\n            return true;\r\n        }\r\n    }\r\n    pub_status = \"done\";\r\n    return false;\r\n}"
}, {
	"Path": "edu.internet2.ndt.Tcpbw100.test_s2c",
	"Comment": "s2c throughput test to measure network bandwidth from server to client.",
	"Method": "boolean test_s2c(Protocol paramProtoObj,Socket paramSocketObj){\r\n    pub_s2cspd = ((NDTConstants.EIGHT * pub_bytes) / NDTConstants.KILO) / (System.currentTimeMillis() - _dTime);\r\n}"
}, {
	"Path": "net.i2p.util.SocketTimeout.cancel",
	"Comment": "change in return value from void to boolean in 0.9.3 accidentally broke syndie, sorry. recompile syndie to fix it.",
	"Method": "boolean cancel(){\r\n    _cancelled = true;\r\n    return super.cancel();\r\n}"
}, {
	"Path": "org.jrobin.data.Aggregates.getAggregate",
	"Comment": "returns single aggregated value for the give consolidation function",
	"Method": "double getAggregate(String consolFun){\r\n    if (consolFun.equals(CF_AVERAGE)) {\r\n        return average;\r\n    } else if (consolFun.equals(CF_FIRST)) {\r\n        return first;\r\n    } else if (consolFun.equals(CF_LAST)) {\r\n        return last;\r\n    } else if (consolFun.equals(CF_MAX)) {\r\n        return max;\r\n    } else if (consolFun.equals(CF_MIN)) {\r\n        return min;\r\n    } else if (consolFun.equals(CF_TOTAL)) {\r\n        return total;\r\n    } else if (consolFun.equals(\"STDEV\")) {\r\n        return stdev;\r\n    } else if (consolFun.equals(\"LSLSLOPE\")) {\r\n        return lslslope;\r\n    } else if (consolFun.equals(\"LSLINT\")) {\r\n        return lslint;\r\n    } else if (consolFun.equals(\"LSLCORREL\")) {\r\n        return lslcorrel;\r\n    } else {\r\n        throw new RrdException(\"Unknown consolidation function: \" + consolFun);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.ui.TunnelConfig.setOutproxyAuth",
	"Comment": "sets whether authentication is required for any of the configuredoutproxies.",
	"Method": "void setOutproxyAuth(boolean val){\r\n    if (val)\r\n        _booleanOptions.add(I2PTunnelHTTPClientBase.PROP_OUTPROXY_AUTH);\r\n    else\r\n        _booleanOptions.remove(I2PTunnelHTTPClientBase.PROP_OUTPROXY_AUTH);\r\n}"
}, {
	"Path": "net.i2p.data.i2np.DatabaseSearchReplyMessage.writeMessageBody",
	"Comment": "write the message body to the output array, starting at the given index",
	"Method": "int writeMessageBody(byte out,int curIndex){\r\n    if (_key == null)\r\n        throw new I2NPMessageException(\"Key in reply to not specified\");\r\n    if (_from == null)\r\n        throw new I2NPMessageException(\"No 'from' address specified!\");\r\n    System.arraycopy(_key.getData(), 0, out, curIndex, Hash.HASH_LENGTH);\r\n    curIndex += Hash.HASH_LENGTH;\r\n    out[curIndex++] = (byte) _peerHashes.size();\r\n    for (int i = 0; i < getNumReplies(); i++) {\r\n        System.arraycopy(getReply(i).getData(), 0, out, curIndex, Hash.HASH_LENGTH);\r\n        curIndex += Hash.HASH_LENGTH;\r\n    }\r\n    System.arraycopy(_from.getData(), 0, out, curIndex, Hash.HASH_LENGTH);\r\n    curIndex += Hash.HASH_LENGTH;\r\n    return curIndex;\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.ui.template.UserTemplateDialog.dispose",
	"Comment": "dispose the wrapped and releases all resources allocated be the wrapper to helpmore efficient garbage collection. you should never invoke this method twice orinvoke any method of the wrapper after invocation of dispose.",
	"Method": "void dispose(){\r\n    EditorFactory.getInstance().releaseEditor(preview);\r\n    super.dispose();\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.SearchJob.resend",
	"Comment": "resend the leaseset to the peer who had previously failed to provide us with the data when we asked them.",
	"Method": "void resend(boolean resend,RouterInfo toPeer,LeaseSet ls){\r\n    Hash to = toPeer.getIdentity().getHash();\r\n    DatabaseStoreMessage msg = new DatabaseStoreMessage(getContext());\r\n    msg.setEntry(ls);\r\n    msg.setMessageExpiration(getContext().clock().now() + RESEND_TIMEOUT);\r\n    TunnelInfo outTunnel = getContext().tunnelManager().selectOutboundExploratoryTunnel(to);\r\n    if (outTunnel != null) {\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"resending leaseSet out to \" + to + \" through \" + outTunnel + \": \" + msg);\r\n        getContext().tunnelDispatcher().dispatchOutbound(msg, outTunnel.getSendTunnelId(0), null, to);\r\n        return true;\r\n    } else {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"unable to resend a leaseSet - no outbound exploratory tunnels!\");\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.klomp.snark.UpdateRunner.update",
	"Comment": "loop through the entire list of update urls. for each one, first get the version from the first 56 bytes and see if it is newer than what we are running now. if it is, get the whole thing.",
	"Method": "void update(){\r\n    for (URI uri : _urls) {\r\n        _currentURI = uri;\r\n        String updateURL = uri.toString();\r\n        try {\r\n            MagnetURI magnet = new MagnetURI(_smgr.util(), updateURL);\r\n            byte[] ih = magnet.getInfoHash();\r\n            _snark = _smgr.getTorrentByInfoHash(ih);\r\n            if (_snark != null) {\r\n                if (_snark.getMetaInfo() != null) {\r\n                    _hasMetaInfo = true;\r\n                    Storage storage = _snark.getStorage();\r\n                    if (storage != null && storage.complete())\r\n                        processComplete(_snark);\r\n                }\r\n                if (!_isComplete) {\r\n                    if (_snark.isStopped() && !_snark.isStarting())\r\n                        _snark.startTorrent();\r\n                    new Watcher();\r\n                }\r\n                break;\r\n            }\r\n            String name = magnet.getName();\r\n            String trackerURL = magnet.getTrackerURL();\r\n            if (trackerURL == null && !_smgr.util().shouldUseDHT() && !_smgr.util().shouldUseOpenTrackers()) {\r\n                _umgr.notifyAttemptFailed(this, \"No tracker, no DHT, no OT\", null);\r\n                continue;\r\n            }\r\n            _snark = _smgr.addMagnet(name, ih, trackerURL, true, true, null, this);\r\n            if (_snark != null) {\r\n                updateStatus(\"<b>\" + _smgr.util().getString(\"Updating from {0}\", linkify(updateURL)) + \"<\/b>\");\r\n                new Timeout();\r\n                break;\r\n            }\r\n        } catch (IllegalArgumentException iae) {\r\n            _log.error(\"Invalid update URL\", iae);\r\n        }\r\n    }\r\n    if (_snark == null)\r\n        fatal(\"No valid URLs\");\r\n}"
}, {
	"Path": "com.spotify.heroic.HeroicLogging.configureNetty",
	"Comment": "initialize all netty logging consistently.netty decided it was a good idea to build their own logging framework. from this follows thatevery time netty has been shaded, it needs to be initialized independently to properlyredirect all logging to slf4j.",
	"Method": "void configureNetty(){\r\n    com.datastax.shaded.netty.util.internal.logging.InternalLoggerFactory.setDefaultFactory(new com.datastax.shaded.netty.util.internal.logging.Slf4JLoggerFactory());\r\n    io.netty.util.internal.logging.InternalLoggerFactory.setDefaultFactory(new io.netty.util.internal.logging.Slf4JLoggerFactory());\r\n    org.jboss.netty.logging.InternalLoggerFactory.setDefaultFactory(new org.jboss.netty.logging.Slf4JLoggerFactory());\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.util.yaml.YamlHelper.isClassServiceId",
	"Comment": "services id in symfony 3.3 are allowed to be class namesdefensive extract by naming strategy",
	"Method": "boolean isClassServiceId(String serviceId){\r\n    if (serviceId.contains(\".\")) {\r\n        return false;\r\n    }\r\n    return PhpNameUtil.isValidNamespaceFullName(serviceId, true);\r\n}"
}, {
	"Path": "com.spotify.heroic.HeroicCore.runBootstrappers",
	"Comment": "this method basically goes through the list of bootstrappers registered by modules and runsthem.",
	"Method": "void runBootstrappers(CoreEarlyComponent early,List<HeroicBootstrap> bootstrappers){\r\n    for (final HeroicBootstrap bootstrap : bootstrappers) {\r\n        try {\r\n            bootstrap.run(early);\r\n        } catch (Exception e) {\r\n            throw new Exception(\"Failed to run bootstrapper \" + bootstrap, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.stubs.ContainerCollectionResolver.resolveParameter",
	"Comment": "resolve service class name which can be a class name or parameter, unknown parameter returns null",
	"Method": "String resolveParameter(Project project,String paramOrClassName,String resolveParameter,ParameterCollector parameterCollector,String paramOrClassName){\r\n    return parameterCollector.resolve(paramOrClassName);\r\n}"
}, {
	"Path": "io.helidon.security.spi.OutboundSecurityProvider.isOutboundSupported",
	"Comment": "check if the path to be executed is supported by this security provider.defaults to true.",
	"Method": "boolean isOutboundSupported(ProviderRequest providerRequest,SecurityEnvironment outboundEnv,EndpointConfig outboundConfig){\r\n    return true;\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.Connection.resetReceived",
	"Comment": "notify that a reset was received. may be called multiple times.",
	"Method": "void resetReceived(){\r\n    if (!_resetReceived.compareAndSet(false, true))\r\n        return;\r\n    IOException ioe = new I2PSocketException(I2PSocketException.STATUS_CONNECTION_RESET);\r\n    _outputStream.streamErrorOccurred(ioe);\r\n    _inputStream.streamErrorOccurred(ioe);\r\n    _connectionError = \"Connection reset\";\r\n    synchronized (_connectLock) {\r\n        _connectLock.notifyAll();\r\n    }\r\n    disconnectComplete();\r\n}"
}, {
	"Path": "i2p.susi.webmail.MailCache.loadFromDisk",
	"Comment": "threaded. returns immediately.\tthis will not access the mailbox. mailbox need not be ready.",
	"Method": "boolean loadFromDisk(NewMailListener nml){\r\n    if (_isLoaded || _loadInProgress != null)\r\n        return false;\r\n    if (_log.shouldDebug())\r\n        _log.debug(\"Loading folder \" + folderName);\r\n    Thread t = new I2PAppThread(new LoadMailRunner(nml), \"Email loader\");\r\n    _loadInProgress = nml;\r\n    try {\r\n        t.start();\r\n    } catch (Throwable e) {\r\n        _loadInProgress = null;\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.i2p.util.SimpleScheduler.addEvent",
	"Comment": "queue up the given event to be fired no sooner than timeoutms from now.",
	"Method": "void addEvent(SimpleTimer.TimedEvent event,long timeoutMs){\r\n    if (event == null)\r\n        throw new IllegalArgumentException(\"addEvent null\");\r\n    RunnableEvent re = new RunnableEvent(event, timeoutMs);\r\n    re.schedule();\r\n}"
}, {
	"Path": "net.i2p.util.TranslateReader.main",
	"Comment": "do not comment out, used to extract tags as a part of the build process.",
	"Method": "void main(String[] args){\r\n    try {\r\n        if (args.length >= 2 && args[0].equals(\"test\"))\r\n            test(args[1]);\r\n        else if (args.length >= 2 && args[0].equals(\"tag\"))\r\n            tag(args);\r\n        else\r\n            System.err.println(\"Usage:\\n\" + \"\\ttest file (output to stdout)\\n\" + \"\\ttag file (output to file.java)\\n\" + \"\\ttag dir outfile\\n\" + \"\\ttag file1 [file2...] outfile\");\r\n    } catch (IOException ioe) {\r\n        throw new RuntimeException(ioe);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.UDPTransport.getClockSkews",
	"Comment": "return our peer clock skews on this transport.vector composed of long, each element representing a peer skew in seconds.a positive number means our clock is ahead of theirs.",
	"Method": "Vector<Long> getClockSkews(){\r\n    Vector<Long> skews = new Vector<Long>();\r\n    boolean includeEverybody = _context.router().getUptime() < 10 * 60 * 1000 || _peersByIdent.size() < 10;\r\n    long now = _context.clock().now();\r\n    for (PeerState peer : _peersByIdent.values()) {\r\n        if ((!includeEverybody) && now - peer.getLastReceiveTime() > 5 * 60 * 1000)\r\n            continue;\r\n        if (peer.getRTT() > PeerState.INIT_RTT - 250)\r\n            continue;\r\n        skews.addElement(Long.valueOf(peer.getClockSkew() / 1000));\r\n    }\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"UDP transport returning \" + skews.size() + \" peer clock skews.\");\r\n    return skews;\r\n}"
}, {
	"Path": "org.jrobin.core.Util.parseBoolean",
	"Comment": "parses input string as a boolean value. the parser is case insensitive.",
	"Method": "boolean parseBoolean(String valueStr){\r\n    return valueStr.equalsIgnoreCase(\"true\") || valueStr.equalsIgnoreCase(\"on\") || valueStr.equalsIgnoreCase(\"yes\") || valueStr.equalsIgnoreCase(\"y\") || valueStr.equalsIgnoreCase(\"1\");\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.UDPPacketReader.isRekeyingIncluded",
	"Comment": "does this packet include rekeying data in the header?unused, should always be false.",
	"Method": "boolean isRekeyingIncluded(){\r\n    return (_message[_payloadBeginOffset] & UDPPacket.HEADER_FLAG_REKEY) != 0;\r\n}"
}, {
	"Path": "net.i2p.router.client.SSLClientListenerRunner.exportCert",
	"Comment": "pull the cert back out of the keystore and save it as asciiso the clients can get to it.",
	"Method": "void exportCert(File ks){\r\n    File sdir = new SecureDirectory(_context.getConfigDir(), \"certificates/i2cp\");\r\n    if (sdir.exists() || sdir.mkdirs()) {\r\n        String ksPass = _context.getProperty(PROP_KEYSTORE_PASSWORD, KeyStoreUtil.DEFAULT_KEYSTORE_PASSWORD);\r\n        File out = new File(sdir, ASCII_KEYFILE);\r\n        boolean success = KeyStoreUtil.exportCert(ks, ksPass, KEY_ALIAS, out);\r\n        if (!success)\r\n            _log.error(\"Error getting SSL cert to save as ASCII\");\r\n    } else {\r\n        _log.error(\"Error saving ASCII SSL keys\");\r\n    }\r\n}"
}, {
	"Path": "org.klomp.snark.PeerConnectionOut.run",
	"Comment": "continuesly monitors for more outgoing messages that have to be send.stops if quit is true or an ioexception occurs.",
	"Method": "void run(){\r\n    try {\r\n        while (!quit && peer.isConnected()) {\r\n            Message m = null;\r\n            PeerState state = null;\r\n            boolean shouldFlush;\r\n            synchronized (sendQueue) {\r\n                shouldFlush = !quit && peer.isConnected() && sendQueue.isEmpty();\r\n            }\r\n            if (shouldFlush)\r\n                dout.flush();\r\n            synchronized (sendQueue) {\r\n                while (!quit && peer.isConnected() && sendQueue.isEmpty()) {\r\n                    try {\r\n                        sendQueue.wait(60 * 1000);\r\n                    } catch (InterruptedException ie) {\r\n                    }\r\n                }\r\n                state = peer.state;\r\n                if (!quit && state != null && peer.isConnected()) {\r\n                    Iterator<Message> it = sendQueue.iterator();\r\n                    while (m == null && it.hasNext()) {\r\n                        Message nm = it.next();\r\n                        if (nm.type == Message.PIECE) {\r\n                            if (state.choking) {\r\n                                it.remove();\r\n                                if (peer.supportsFast()) {\r\n                                    Message r = new Message(Message.REJECT, nm.piece, nm.begin, nm.length);\r\n                                    if (_log.shouldLog(Log.DEBUG))\r\n                                        _log.debug(\"Send \" + peer + \": \" + r);\r\n                                    r.sendMessage(dout);\r\n                                }\r\n                            }\r\n                            nm = null;\r\n                        } else if (nm.type == Message.REQUEST && state.choked) {\r\n                            it.remove();\r\n                            nm = null;\r\n                        }\r\n                        if (nm != null) {\r\n                            m = nm;\r\n                            it.remove();\r\n                        }\r\n                    }\r\n                    if (m == null) {\r\n                        m = sendQueue.poll();\r\n                    }\r\n                }\r\n            }\r\n            if (m != null) {\r\n                if (_log.shouldLog(Log.DEBUG))\r\n                    _log.debug(\"Send \" + peer + \": \" + m);\r\n                lastSent = System.currentTimeMillis();\r\n                if (m.type == Message.CHOKE)\r\n                    removeMessage(Message.PIECE);\r\n                int remainder = 0;\r\n                if (m.type == Message.PIECE) {\r\n                    if (m.len <= PeerState.PARTSIZE) {\r\n                        state.uploaded(m.len);\r\n                    } else {\r\n                        state.uploaded(PeerState.PARTSIZE);\r\n                        remainder = m.len - PeerState.PARTSIZE;\r\n                    }\r\n                }\r\n                m.sendMessage(dout);\r\n                if (remainder > 0)\r\n                    state.uploaded(remainder);\r\n                m = null;\r\n            }\r\n        }\r\n    } catch (IOException ioe) {\r\n        if (_log.shouldLog(Log.INFO))\r\n            _log.info(\"IOError sending to \" + peer, ioe);\r\n    } catch (Throwable t) {\r\n        _log.error(\"Error sending to \" + peer, t);\r\n        if (t instanceof OutOfMemoryError)\r\n            throw (OutOfMemoryError) t;\r\n    } finally {\r\n        quit = true;\r\n        peer.disconnect();\r\n    }\r\n}"
}, {
	"Path": "io.helidon.webserver.PathMatcher.from",
	"Comment": "creates new instance from provided web server path pattern.see class level javadoc for the path pattern description.",
	"Method": "PathMatcher from(String pathPattern){\r\n    return PathPattern.compile(pathPattern);\r\n}"
}, {
	"Path": "com.netflix.hollow.api.producer.validation.ValidationStatus.failed",
	"Comment": "returns true if one or more validation results failed or was erroneous, otherwise false if all resultspassed.",
	"Method": "boolean failed(){\r\n    return !passed;\r\n}"
}, {
	"Path": "org.jrobin.core.DsDef.isValidDsType",
	"Comment": "checks if function argument represents valid source type.",
	"Method": "boolean isValidDsType(String dsType){\r\n    for (final String type : DS_TYPES) {\r\n        if (type.equals(dsType)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "edu.internet2.ndt.Tcpbw100.getNDTvar",
	"Comment": "function that returns a variable corresponding to the parameter passed to\tit as a request.",
	"Method": "String getNDTvar(String varName){\r\n    if (varName.equals(\"ClientToServerSpeed\"))\r\n        return get_c2sspd();\r\n    else if (varName.equals(\"ServerToClientSpeed\"))\r\n        return get_s2cspd();\r\n    else if (varName.equals(\"Jitter\"))\r\n        return get_jitter();\r\n    else if (varName.equals(\"OperatingSystem\"))\r\n        return get_osName() + \" \" + get_osVer();\r\n    else if (varName.equals(\"PluginVersion\"))\r\n        return get_pluginVer();\r\n    else if (varName.equals(\"OsArchitecture\"))\r\n        return get_osArch();\r\n    else if (varName.equals(NDTConstants.AVGRTT))\r\n        return get_avgrtt();\r\n    else if (varName.equals(NDTConstants.CURRWINRCVD))\r\n        return get_CurRwinRcvd();\r\n    else if (varName.equals(NDTConstants.MAXRWINRCVD))\r\n        return get_MaxRwinRcvd();\r\n    else if (varName.equals(NDTConstants.LOSS))\r\n        return get_loss();\r\n    else if (varName.equals(NDTConstants.MINRTT))\r\n        return get_Ping();\r\n    else if (varName.equals(NDTConstants.MAXRTT))\r\n        return get_MaxRTT();\r\n    else if (varName.equals(NDTConstants.WAITSEC))\r\n        return get_WaitSec();\r\n    else if (varName.equals(NDTConstants.CURRTO))\r\n        return get_CurRTO();\r\n    else if (varName.equals(NDTConstants.SACKSRCVD))\r\n        return get_SACKsRcvd();\r\n    else if (varName.equals(NDTConstants.MISMATCH))\r\n        return get_mismatch();\r\n    else if (varName.equals(NDTConstants.BAD_CABLE))\r\n        return get_Bad_cable();\r\n    else if (varName.equals(NDTConstants.CONGESTION))\r\n        return get_congestion();\r\n    else if (varName.equals(NDTConstants.CWNDTIME))\r\n        return get_cwndtime();\r\n    else if (varName.equals(NDTConstants.RWINTIME))\r\n        return get_rcvrLimiting();\r\n    else if (varName.equals(NDTConstants.OPTRCVRBUFF))\r\n        return get_optimalRcvrBuffer();\r\n    else if (varName.equals(NDTConstants.ACCESS_TECH))\r\n        return get_AccessTech();\r\n    else if (varName.equals(NDTConstants.DUPACKSIN))\r\n        return get_DupAcksIn();\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "com.google.zxing.qrcode.encoder.Encoder.recommendVersion",
	"Comment": "decides the smallest version of qr code that will contain all of the provided data.",
	"Method": "Version recommendVersion(ErrorCorrectionLevel ecLevel,Mode mode,BitArray headerBits,BitArray dataBits){\r\n    int provisionalBitsNeeded = calculateBitsNeeded(mode, headerBits, dataBits, Version.getVersionForNumber(1));\r\n    Version provisionalVersion = chooseVersion(provisionalBitsNeeded, ecLevel);\r\n    int bitsNeeded = calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);\r\n    return chooseVersion(bitsNeeded, ecLevel);\r\n}"
}, {
	"Path": "io.helidon.security.SecurityRequestBuilder.responseMessage",
	"Comment": "set the response message to use when security provider requires access to it.",
	"Method": "T responseMessage(Entity entity){\r\n    this.responseEntity = entity;\r\n    return myInstance;\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.settings.IgnoreSettings.isNotifyIgnoredEditing",
	"Comment": "checks if notifications about editing ignored file are enabled",
	"Method": "boolean isNotifyIgnoredEditing(){\r\n    return notifyIgnoredEditing;\r\n}"
}, {
	"Path": "org.jrobin.core.RrdBackendFactory.getFactory",
	"Comment": "returns backend factory for the given backend factory name.",
	"Method": "RrdBackendFactory getFactory(String name){\r\n    final RrdBackendFactory factory = factories.get(name);\r\n    if (factory != null) {\r\n        return factory;\r\n    }\r\n    throw new RrdException(\"No backend factory found with the name specified [\" + name + \"]\");\r\n}"
}, {
	"Path": "net.i2p.router.dummy.VMCommSystem.processMessage",
	"Comment": "the router wants us to send the given message to the peer.do so, or fire off the failing job.",
	"Method": "void processMessage(OutNetMessage msg){\r\n    Hash peer = msg.getTarget().getIdentity().getHash();\r\n    VMCommSystem peerSys = _commSystemFacades.get(peer);\r\n    long now = _context.clock().now();\r\n    long sendTime = now - msg.getSendBegin();\r\n    boolean sendSuccessful = false;\r\n    if (peerSys == null) {\r\n        _context.jobQueue().addJob(msg.getOnFailedSendJob());\r\n        _context.statManager().updateFrequency(\"transport.sendMessageFailureFrequency\");\r\n        _context.profileManager().messageFailed(msg.getTarget().getIdentity().getHash(), \"vm\");\r\n    } else {\r\n        _context.jobQueue().addJob(msg.getOnSendJob());\r\n        _context.profileManager().messageSent(msg.getTarget().getIdentity().getHash(), \"vm\", sendTime, msg.getMessageSize());\r\n        byte[] data = new byte[msg.getMessageSize()];\r\n        msg.getMessageData(data);\r\n        _context.statManager().addRateData(\"transport.sendMessageSize\", data.length, sendTime);\r\n        if (data.length < 1024)\r\n            _context.statManager().addRateData(\"transport.sendMessageSmall\", 1, sendTime);\r\n        else if (data.length <= 4096)\r\n            _context.statManager().addRateData(\"transport.sendMessageMedium\", 1, sendTime);\r\n        else\r\n            _context.statManager().addRateData(\"transport.sendMessageLarge\", 1, sendTime);\r\n        peerSys.receive(data, _context.routerHash());\r\n        sendSuccessful = true;\r\n    }\r\n    if (true) {\r\n        I2NPMessage dmsg = msg.getMessage();\r\n        String type = dmsg.getClass().getName();\r\n        _context.messageHistory().sendMessage(type, dmsg.getUniqueId(), dmsg.getMessageExpiration(), msg.getTarget().getIdentity().getHash(), sendSuccessful, null);\r\n    }\r\n    msg.discardData();\r\n    _context.statManager().addRateData(\"transport.sendProcessingTime\", msg.getLifetime(), msg.getLifetime());\r\n}"
}, {
	"Path": "com.spotify.heroic.QueryBuilder.legacyAggregation",
	"Comment": "support a legacy kind of aggregation where groupby is specified independently.",
	"Method": "Optional<Aggregation> legacyAggregation(){\r\n    if (groupBy.isPresent()) {\r\n        return Optional.of(Group.of(groupBy, aggregation));\r\n    }\r\n    return aggregation;\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.util.IdeHelper.getWindowComponentFromProject",
	"Comment": "find current window element of given project.use this to find a component for new dialogs without using jbpopupfactory",
	"Method": "Window getWindowComponentFromProject(Project project){\r\n    WindowManagerEx windowManager = getWindowManager();\r\n    if (windowManager == null) {\r\n        return null;\r\n    }\r\n    Window window = null;\r\n    Component focusedComponent = windowManager.getFocusedComponent(project);\r\n    if (focusedComponent != null) {\r\n        Component parent = UIUtil.findUltimateParent(focusedComponent);\r\n        if (parent instanceof Window) {\r\n            window = (Window) parent;\r\n        }\r\n    }\r\n    if (window == null) {\r\n        window = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusedWindow();\r\n    }\r\n    if (window != null && window.isShowing()) {\r\n        return window;\r\n    }\r\n    return window;\r\n}"
}, {
	"Path": "com.netflix.hollow.core.memory.FreeOrdinalTracker.sort",
	"Comment": "ensure that all future ordinals are returned in ascending order.",
	"Method": "void sort(){\r\n    Arrays.sort(freeOrdinals, 0, size);\r\n    int midpoint = size / 2;\r\n    for (int i = 0; i < midpoint; i++) {\r\n        int temp = freeOrdinals[i];\r\n        freeOrdinals[i] = freeOrdinals[size - i - 1];\r\n        freeOrdinals[size - i - 1] = temp;\r\n    }\r\n}"
}, {
	"Path": "org.klomp.snark.bencode.BDecoder.bdecodeList",
	"Comment": "returns the next bencoded value on the stream and makes sure itis a list. if it is not a list it will throwinvalidbencodingexception.",
	"Method": "BEValue bdecodeList(){\r\n    int c = getNextIndicator();\r\n    if (c != 'l')\r\n        throw new InvalidBEncodingException(\"Expected 'l', not '\" + (char) c + \"'\");\r\n    indicator = 0;\r\n    List<BEValue> result = new ArrayList<BEValue>();\r\n    c = getNextIndicator();\r\n    while (c != 'e') {\r\n        result.add(bdecode());\r\n        c = getNextIndicator();\r\n    }\r\n    indicator = 0;\r\n    return new BEValue(result);\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterInfo.setPublished",
	"Comment": "date on which it was published, in milliseconds since midnight gmt on jan 01, 1970",
	"Method": "void setPublished(long published){\r\n    if (_signature != null)\r\n        throw new IllegalStateException();\r\n    _published = published;\r\n}"
}, {
	"Path": "org.jrobin.core.ArcDef.getSteps",
	"Comment": "returns the number of primary rrd steps which complete a single archive step.",
	"Method": "int getSteps(){\r\n    return steps;\r\n}"
}, {
	"Path": "net.i2p.crypto.eddsa.math.MathUtils.toByteArray",
	"Comment": "converts a biginteger to a little endian 32 byte representation.",
	"Method": "byte[] toByteArray(BigInteger b){\r\n    if (b.compareTo(BigInteger.ONE.shiftLeft(256)) >= 0) {\r\n        throw new RuntimeException(\"only numbers < 2^256 are allowed\");\r\n    }\r\n    final byte[] bytes = new byte[32];\r\n    final byte[] original = b.toByteArray();\r\n    final int offset = original.length > 32 ? original.length - 32 : 0;\r\n    for (int i = 0; i < original.length - offset; i++) {\r\n        bytes[original.length - i - offset - 1] = original[i + offset];\r\n    }\r\n    return bytes;\r\n}"
}, {
	"Path": "i2p.susi.webmail.pop3.POP3MailBox.doCheckMail",
	"Comment": "send stat, uidl, list, and dele for all pending. must be connected.\tcaller must sync.\tleaves socket connected. caller must close on ioe.",
	"Method": "boolean doCheckMail(){\r\n    if (!isConnected())\r\n        throw new IOException(\"not connected\");\r\n    List<SendRecv> cmds = new ArrayList<SendRecv>(4);\r\n    SendRecv stat = new SendRecv(\"STAT\", Mode.A1);\r\n    cmds.add(stat);\r\n    SendRecv uidl = new SendRecv(\"UIDL\", Mode.LS);\r\n    cmds.add(uidl);\r\n    SendRecv list = new SendRecv(\"LIST\", Mode.LS);\r\n    cmds.add(list);\r\n    socket.setSoTimeout(120 * 1000);\r\n    boolean ok = sendCmds(cmds);\r\n    if (stat.result)\r\n        updateMailCount(stat.response);\r\n    else if (_log.shouldDebug())\r\n        _log.debug(\"STAT failed\");\r\n    if (uidl.result)\r\n        updateUIDLs(uidl.ls);\r\n    else if (_log.shouldDebug())\r\n        _log.debug(\"UIDL failed\");\r\n    if (list.result)\r\n        updateSizes(list.ls);\r\n    else if (_log.shouldDebug())\r\n        _log.debug(\"LIST failed\");\r\n    doDelete(false);\r\n    if (socket != null)\r\n        try {\r\n            socket.setSoTimeout(300 * 1000);\r\n        } catch (IOException ioe) {\r\n        }\r\n    return ok;\r\n}"
}, {
	"Path": "org.jrobin.core.DsDef.equals",
	"Comment": "checks if two datasource definitions are equal.\tsource definitions are treated as equal if they have the same source name.\tit is not possible to create rrd with two equal archive definitions.",
	"Method": "boolean equals(Object obj){\r\n    if (obj instanceof DsDef) {\r\n        final DsDef dsObj = (DsDef) obj;\r\n        return dsName.equals(dsObj.dsName);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.i2p.router.transport.CommSystemFacadeImpl.countActiveSendPeers",
	"Comment": "how many peers are we currently connected to, that we have sent a message to in the last minute. unused for anything, to be removed.",
	"Method": "int countActiveSendPeers(){\r\n    return _manager.countActiveSendPeers();\r\n}"
}, {
	"Path": "org.jrobin.graph.RrdGraphDef.setValueAxis",
	"Comment": "sets vertical axis grid and labels. makes vertical grid lines appearat gridstep interval. every labelfactorgridstep, a major grid line is printed,along with label showing the value of the grid line.",
	"Method": "void setValueAxis(double gridStep,int labelFactor){\r\n    valueAxisSetting = new ValueAxisSetting(gridStep, labelFactor);\r\n}"
}, {
	"Path": "io.helidon.webserver.ServerConfiguration.fromConfig",
	"Comment": "creates new instance with defaults from external configuration source.",
	"Method": "ServerConfiguration fromConfig(Config config){\r\n    return builder(config).build();\r\n}"
}, {
	"Path": "edu.internet2.ndt.NDTUtils.prttxt",
	"Comment": "utility method to print text values for data speed related keys.",
	"Method": "String prttxt(int paramIntVal,ResourceBundle paramResBundObj){\r\n    String strNameTxt = null;\r\n    switch(paramIntVal) {\r\n        case (NDTConstants.DATA_RATE_SYSTEM_FAULT):\r\n            strNameTxt = paramResBundObj.getString(NDTConstants.SYSTEM_FAULT_STR);\r\n            break;\r\n        case NDTConstants.DATA_RATE_RTT:\r\n            strNameTxt = paramResBundObj.getString(NDTConstants.RTT_STR);\r\n            break;\r\n        case NDTConstants.DATA_RATE_DIAL_UP:\r\n            strNameTxt = paramResBundObj.getString(NDTConstants.DIALUP_STR);\r\n            break;\r\n        case NDTConstants.DATA_RATE_T1:\r\n            strNameTxt = NDTConstants.T1_STR;\r\n            break;\r\n        case NDTConstants.DATA_RATE_ETHERNET:\r\n            strNameTxt = NDTConstants.ETHERNET_STR;\r\n            break;\r\n        case NDTConstants.DATA_RATE_T3:\r\n            strNameTxt = NDTConstants.T3_STR;\r\n            break;\r\n        case NDTConstants.DATA_RATE_FAST_ETHERNET:\r\n            strNameTxt = NDTConstants.FAST_ETHERNET;\r\n            break;\r\n        case NDTConstants.DATA_RATE_OC_12:\r\n            strNameTxt = NDTConstants.OC_12_STR;\r\n            break;\r\n        case NDTConstants.DATA_RATE_GIGABIT_ETHERNET:\r\n            strNameTxt = NDTConstants.GIGABIT_ETHERNET_STR;\r\n            break;\r\n        case NDTConstants.DATA_RATE_OC_48:\r\n            strNameTxt = NDTConstants.OC_48_STR;\r\n            break;\r\n        case NDTConstants.DATA_RATE_10G_ETHERNET:\r\n            strNameTxt = NDTConstants.TENGIGABIT_ETHERNET_STR;\r\n            break;\r\n    }\r\n    return (strNameTxt);\r\n}"
}, {
	"Path": "com.maxmind.db.BufferHolder.get",
	"Comment": "returns a duplicate of the underlying bytebuffer. the returned bytebuffershould not be shared between threads.",
	"Method": "ByteBuffer get(){\r\n    return this.buffer.duplicate();\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.EstablishmentManager.handleCompletelyEstablished",
	"Comment": "ok, fully received, add it to the established cons and send anyqueued messages",
	"Method": "void handleCompletelyEstablished(InboundEstablishState state,PeerState handleCompletelyEstablished,OutboundEstablishState state){\r\n    if (state.complete()) {\r\n        RouterIdentity rem = state.getRemoteIdentity();\r\n        if (rem != null)\r\n            return _transport.getPeerState(rem.getHash());\r\n    }\r\n    long now = _context.clock().now();\r\n    RouterIdentity remote = state.getRemoteIdentity();\r\n    RemoteHostId claimed = state.getClaimedAddress();\r\n    if (claimed != null)\r\n        _outboundByClaimedAddress.remove(claimed, state);\r\n    _outboundByHash.remove(remote.calculateHash(), state);\r\n    PeerState peer = new PeerState(_context, _transport, state.getSentIP(), state.getSentPort(), remote.calculateHash(), false);\r\n    peer.setCurrentCipherKey(state.getCipherKey());\r\n    peer.setCurrentMACKey(state.getMACKey());\r\n    peer.setTheyRelayToUsAs(state.getReceivedRelayTag());\r\n    int mtu = state.getRemoteAddress().getMTU();\r\n    if (mtu > 0)\r\n        peer.setHisMTU(mtu);\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Handle completely established (outbound): \" + state + \" - \" + peer.getRemotePeer());\r\n    _transport.addRemotePeerState(peer);\r\n    _transport.setIP(remote.calculateHash(), state.getSentIP());\r\n    _context.statManager().addRateData(\"udp.outboundEstablishTime\", state.getLifetime());\r\n    DatabaseStoreMessage dbsm = null;\r\n    if (!state.isFirstMessageOurDSM()) {\r\n        dbsm = getOurInfo();\r\n    } else if (_log.shouldLog(Log.INFO)) {\r\n        _log.info(\"Skipping publish: \" + state);\r\n    }\r\n    List<OutNetMessage> msgs = new ArrayList<OutNetMessage>(8);\r\n    OutNetMessage msg;\r\n    while ((msg = state.getNextQueuedMessage()) != null) {\r\n        if (now - Router.CLOCK_FUDGE_FACTOR > msg.getExpiration()) {\r\n            msg.timestamp(\"took too long but established...\");\r\n            _transport.failed(msg, \"Took too long to establish, but it was established\");\r\n        } else {\r\n            msg.timestamp(\"session fully established and sent\");\r\n            msgs.add(msg);\r\n        }\r\n    }\r\n    _transport.send(dbsm, msgs, peer);\r\n    return peer;\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.BatchedFragmentTest.runBatches",
	"Comment": "send a small message, wait a second, then send a large message, pushingthe first one through immediately, with the rest of the large one passedafter a brief delay.",
	"Method": "void runBatches(){\r\n    for (int i = 1; i <= 1024; i++) {\r\n        testBatched(i, false, false, 1024, false, false, 1024, false, false);\r\n        testBatched(i, true, false, 1024, false, false, 1024, false, false);\r\n        testBatched(i, true, true, 1024, false, false, 1024, false, false);\r\n        testBatched(i, false, false, 1024, true, false, 1024, false, false);\r\n        testBatched(i, true, false, 1024, true, false, 1024, false, false);\r\n        testBatched(i, true, true, 1024, true, false, 1024, false, false);\r\n        testBatched(i, false, false, 1024, true, true, 1024, false, false);\r\n        testBatched(i, true, false, 1024, true, true, 1024, false, false);\r\n        testBatched(i, true, true, 1024, true, true, 1024, false, false);\r\n        testBatched(i, false, false, 1024, false, false, 1024, true, false);\r\n        testBatched(i, true, false, 1024, false, false, 1024, true, false);\r\n        testBatched(i, true, true, 1024, false, false, 1024, true, false);\r\n        testBatched(i, false, false, 1024, true, false, 1024, true, false);\r\n        testBatched(i, true, false, 1024, true, false, 1024, true, false);\r\n        testBatched(i, true, true, 1024, true, false, 1024, true, false);\r\n        testBatched(i, false, false, 1024, true, true, 1024, true, false);\r\n        testBatched(i, true, false, 1024, true, true, 1024, true, false);\r\n        testBatched(i, true, true, 1024, true, true, 1024, true, false);\r\n        testBatched(i, false, false, 1024, false, false, 1024, true, true);\r\n        testBatched(i, true, false, 1024, false, false, 1024, true, true);\r\n        testBatched(i, true, true, 1024, false, false, 1024, true, true);\r\n        testBatched(i, false, false, 1024, true, false, 1024, true, true);\r\n        testBatched(i, true, false, 1024, true, false, 1024, true, true);\r\n        testBatched(i, true, true, 1024, true, false, 1024, true, true);\r\n        testBatched(i, false, false, 1024, true, true, 1024, true, true);\r\n        testBatched(i, true, false, 1024, true, true, 1024, true, true);\r\n        testBatched(i, true, true, 1024, true, true, 1024, true, true);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.UDPTransport.getPeerState",
	"Comment": "get the state for the peer with the given ident, or null if no state exists",
	"Method": "PeerState getPeerState(RemoteHostId hostInfo,PeerState getPeerState,Hash remotePeer){\r\n    return _peersByIdent.get(remotePeer);\r\n}"
}, {
	"Path": "net.i2p.data.LeaseSet.getReceivedAsPublished",
	"Comment": "if true, we received this leaseset by a remote peer publishing it tous, rather than by searching for it ourselves or locally creating it.default false.",
	"Method": "boolean getReceivedAsPublished(){\r\n    return _receivedAsPublished;\r\n}"
}, {
	"Path": "net.i2p.addressbook.Log.append",
	"Comment": "write entry to a new line in the log, with appropriate time stamp.",
	"Method": "void append(String entry){\r\n    BufferedWriter bw = null;\r\n    try {\r\n        bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(this.file, true), \"UTF-8\"));\r\n        String timestamp = new Date().toString();\r\n        bw.write(timestamp + \" -- \" + entry);\r\n        bw.newLine();\r\n    } catch (IOException exp) {\r\n    } finally {\r\n        if (bw != null)\r\n            try {\r\n                bw.close();\r\n            } catch (IOException ioe) {\r\n            }\r\n    }\r\n}"
}, {
	"Path": "io.helidon.security.EndpointConfig.getAnnotations",
	"Comment": "all custom annotations for scopes defined in parameters, in the same order.",
	"Method": "Map<Class<? extends Annotation>, List<Annotation>> getAnnotations(AnnotationScope scopes){\r\n    Map<Class<? extends Annotation>, List<Annotation>> result = new HashMap();\r\n    for (AnnotationScope scope : scopes) {\r\n        Map<Class<? extends Annotation>, List<Annotation>> map = annotations.get(scope);\r\n        if (null != map) {\r\n            map.forEach((annotClass, annotList) -> result.computeIfAbsent(annotClass, aClass -> new LinkedList()).addAll(annotList));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.i2p.router.Router.get15sRate",
	"Comment": "when outboundonly is false, outbound rate in bytes per second. when true, max of inbound and outbound rate in bytes per second.",
	"Method": "int get15sRate(int get15sRate,boolean outboundOnly){\r\n    FIFOBandwidthLimiter bw = _context.bandwidthLimiter();\r\n    int out = (int) bw.getSendBps15s();\r\n    if (outboundOnly)\r\n        return out;\r\n    return (int) Math.max(out, bw.getReceiveBps15s());\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.ConnectionOptions.getResendDelay",
	"Comment": "how long after sending a packet will we wait before resending?",
	"Method": "int getResendDelay(){\r\n    return _resendDelay;\r\n}"
}, {
	"Path": "edu.internet2.ndt.Tcpbw100.actionPerformed",
	"Comment": "action handler method called when an associated action is performed",
	"Method": "void actionPerformed(ActionEvent paramEventObj){\r\n    Object source = paramEventObj.getSource();\r\n    if (source == _buttonStartTest) {\r\n        if (_frameWeb100Vars != null) {\r\n            _frameWeb100Vars.toBack();\r\n            _frameWeb100Vars.dispose();\r\n            _frameWeb100Vars = null;\r\n        }\r\n        if (_frameDetailedStats != null) {\r\n            _frameDetailedStats.toBack();\r\n            _frameDetailedStats.dispose();\r\n            _frameDetailedStats = null;\r\n        }\r\n        pub_errmsg = \"Test in progress.\";\r\n        runtest();\r\n    } else if (source == _buttonDetails) {\r\n        _frameWeb100Vars.setResizable(true);\r\n        _frameWeb100Vars.setVisible(true);\r\n        if (NDTUtils.isNotEmpty(_txtDiagnosis.getText())) {\r\n            _buttonDetailsCopy.setEnabled(true);\r\n        }\r\n    } else if (source == _buttonDetailsDismiss) {\r\n        _frameWeb100Vars.toBack();\r\n        _frameWeb100Vars.dispose();\r\n    } else if (source == _buttonStatsDismiss) {\r\n        _frameDetailedStats.toBack();\r\n        _frameDetailedStats.dispose();\r\n    } else if (source == _buttonDetailsCopy) {\r\n        copy(_txtDiagnosis);\r\n    } else if (source == _buttonStatsCopy) {\r\n        copy(_txtStatistics);\r\n    } else if (source == _buttonStatistics) {\r\n        _frameDetailedStats.setResizable(true);\r\n        _frameDetailedStats.setVisible(true);\r\n        if (NDTUtils.isNotEmpty(_txtStatistics.getText())) {\r\n            _buttonStatsCopy.setEnabled(true);\r\n        }\r\n    } else if (source == _chkboxPreferIPv6) {\r\n        setsHostName(sHostName);\r\n    } else if (source == _buttonMailTo) {\r\n        String sName, sHost;\r\n        showStatus(_resBundDisplayMsgs.getString(\"invokingMailtoFunction\") + \"...\");\r\n        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"generatingReport\") + \"\\n\");\r\n        try {\r\n            if ((sName = getParameter(NDTConstants.TARGET1)) == null) {\r\n                throw new IllegalArgumentException(\"U parameter Required:\");\r\n            }\r\n            if ((sHost = getParameter(NDTConstants.TARGET2)) == null) {\r\n                throw new IllegalArgumentException(\"H parameter Required:\");\r\n            }\r\n            String sSubject = getParameter(\"subject\");\r\n            if (sSubject == null) {\r\n                sSubject = _resBundDisplayMsgs.getString(\"troubleReportFrom\") + \" \" + getCodeBase().getHost();\r\n            }\r\n            String sBody = _resBundDisplayMsgs.getString(\"comments\") + \":\\n\\n\" + _sEmailText + \"\\n\\n\" + _resBundDisplayMsgs.getString(\"endOfEmail\");\r\n            String sUrl = NDTUtils.mailTo(sName, sHost, sSubject, sBody);\r\n            _targetURL = new URL(sUrl);\r\n            getAppletContext().showDocument(_targetURL);\r\n        } catch (Exception e) {\r\n            String sMessage = NDTUtils.isEmpty(e.getMessage()) ? _resBundDisplayMsgs.getString(\"withoutMessage\") : e.getMessage();\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"unexpectedException\") + \" (\" + e.getClass().getName() + \"): \" + sMessage + \"\\n\";\r\n            _log.warn(_sErrMsg, e);\r\n            _resultsTxtPane.append(_sErrMsg);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.spotify.heroic.metric.MetricCollection.mergeSorted",
	"Comment": "merge the given collections and return a new metric collection with the sorted values.this expects the source collections being merged to be sorted.this api is not safe, checks must be performed to verify that the encapsulated data type isthe same as expected.",
	"Method": "MetricCollection mergeSorted(MetricType type,List<List<? extends Metric>> values){\r\n    final List<Metric> data = ImmutableList.copyOf(Iterators.mergeSorted(ImmutableList.copyOf(values.stream().map(Iterable::iterator).iterator()), Metric.comparator()));\r\n    return build(type, data);\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.lang.IgnoreBraceMatcher.isPairedBracesAllowedBeforeType",
	"Comment": "returns true if paired rbrace should be inserted after lbrace of given type when lbrace is encountered beforecontexttype token.it is safe to always return true, then paired brace will be inserted anyway.",
	"Method": "boolean isPairedBracesAllowedBeforeType(IElementType lbraceType,IElementType contextType){\r\n    return true;\r\n}"
}, {
	"Path": "net.i2p.servlet.I2PDefaultServlet.sendDirectory",
	"Comment": "copied and modified from defaultservlet.java.overridden to set the locale for the dates.get the resource list as a html directory listing.",
	"Method": "void sendDirectory(HttpServletRequest request,HttpServletResponse response,Resource resource,String pathInContext){\r\n    if (!_dirAllowed) {\r\n        response.sendError(HttpServletResponse.SC_FORBIDDEN);\r\n        return;\r\n    }\r\n    byte[] data = null;\r\n    String base = URIUtil.addPaths(request.getRequestURI(), URIUtil.SLASH);\r\n    if (_resourceBase != null) {\r\n        if (_resourceBase instanceof ResourceCollection)\r\n            resource = _resourceBase.addPath(pathInContext);\r\n    } else if (_contextHandler.getBaseResource() instanceof ResourceCollection)\r\n        resource = _contextHandler.getBaseResource().addPath(pathInContext);\r\n    String dir = getListHTML(resource, base, pathInContext.length() > 1);\r\n    if (dir == null) {\r\n        response.sendError(HttpServletResponse.SC_FORBIDDEN, \"No directory\");\r\n        return;\r\n    }\r\n    data = dir.getBytes(\"UTF-8\");\r\n    response.setContentType(\"text/html; charset=UTF-8\");\r\n    response.setContentLength(data.length);\r\n    response.getOutputStream().write(data);\r\n}"
}, {
	"Path": "org.jrobin.core.RrdNioByteBufferBackendFactory.open",
	"Comment": "creates rrdniobytebufferbackend object for the given file path.",
	"Method": "RrdBackend open(String path,boolean readOnly){\r\n    return new RrdNioByteBufferBackend(path, readOnly);\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.OutboundMessageState.getMessageSize",
	"Comment": "the size of the i2np message. does not include any ssu overhead.",
	"Method": "int getMessageSize(){\r\n    return _messageBuf.length;\r\n}"
}, {
	"Path": "net.i2p.crypto.SU3File.main",
	"Comment": "parses command line arguments when this class is used from the commandline.exits 1 on failure so this can be used in scripts.",
	"Method": "void main(String[] args){\r\n    boolean ok = false;\r\n    try {\r\n        String stype = null;\r\n        String ctype = null;\r\n        String ftype = null;\r\n        String kfile = null;\r\n        String crlfile = null;\r\n        String kspass = KeyStoreUtil.DEFAULT_KEYSTORE_PASSWORD;\r\n        boolean error = false;\r\n        boolean shouldVerify = true;\r\n        Getopt g = new Getopt(\"SU3File\", args, \"t:c:f:k:xp:r:\");\r\n        int c;\r\n        while ((c = g.getopt()) != -1) {\r\n            switch(c) {\r\n                case 't':\r\n                    stype = g.getOptarg();\r\n                    break;\r\n                case 'c':\r\n                    ctype = g.getOptarg();\r\n                    break;\r\n                case 'f':\r\n                    ftype = g.getOptarg();\r\n                    break;\r\n                case 'k':\r\n                    kfile = g.getOptarg();\r\n                    break;\r\n                case 'r':\r\n                    crlfile = g.getOptarg();\r\n                    break;\r\n                case 'x':\r\n                    shouldVerify = false;\r\n                    break;\r\n                case 'p':\r\n                    kspass = g.getOptarg();\r\n                    break;\r\n                case '?':\r\n                case ':':\r\n                default:\r\n                    error = true;\r\n            }\r\n        }\r\n        int idx = g.getOptind();\r\n        String cmd = args[idx];\r\n        List<String> a = new ArrayList<String>(Arrays.asList(args).subList(idx + 1, args.length));\r\n        if (error) {\r\n            showUsageCLI();\r\n        } else if (\"showversion\".equals(cmd)) {\r\n            ok = showVersionCLI(a.get(0));\r\n        } else if (\"sign\".equals(cmd)) {\r\n            Properties props = new Properties();\r\n            props.setProperty(\"prng.bufferSize\", \"16384\");\r\n            new I2PAppContext(props);\r\n            ok = signCLI(stype, ctype, ftype, a.get(0), a.get(1), a.get(2), a.get(3), a.get(4), \"\", kspass);\r\n        } else if (\"bulksign\".equals(cmd)) {\r\n            Properties props = new Properties();\r\n            props.setProperty(\"prng.bufferSize\", \"16384\");\r\n            new I2PAppContext(props);\r\n            ok = bulkSignCLI(stype, ctype, a.get(0), a.get(1), a.get(2), a.get(3), kspass);\r\n        } else if (\"verifysig\".equals(cmd)) {\r\n            ok = verifySigCLI(a.get(0), kfile);\r\n        } else if (\"keygen\".equals(cmd)) {\r\n            Properties props = new Properties();\r\n            props.setProperty(\"prng.bufferSize\", \"16384\");\r\n            new I2PAppContext(props);\r\n            ok = genKeysCLI(stype, a.get(0), a.get(1), crlfile, a.get(2), kspass);\r\n        } else if (\"extract\".equals(cmd)) {\r\n            ok = extractCLI(a.get(0), a.get(1), shouldVerify, kfile);\r\n        } else {\r\n            showUsageCLI();\r\n        }\r\n    } catch (NoSuchElementException nsee) {\r\n        showUsageCLI();\r\n    } catch (IndexOutOfBoundsException ioobe) {\r\n        showUsageCLI();\r\n    }\r\n    if (!ok)\r\n        System.exit(1);\r\n}"
}, {
	"Path": "net.i2p.router.transport.crypto.X25519KeyFactory.getKeys",
	"Comment": "pulls a prebuilt keypair from the queue,or if not available, construct a new one.",
	"Method": "KeyPair getKeys(){\r\n    _context.statManager().addRateData(\"crypto.XDHUsed\", 1);\r\n    KeyPair rv = _keys.poll();\r\n    if (rv == null) {\r\n        _context.statManager().addRateData(\"crypto.XDHEmpty\", 1);\r\n        rv = precalc();\r\n        this.interrupt();\r\n    }\r\n    return rv;\r\n}"
}, {
	"Path": "org.klomp.snark.Peer.isChoking",
	"Comment": "whether or not we are choking the peer. returns true when not connected.",
	"Method": "boolean isChoking(){\r\n    PeerState s = state;\r\n    return (s == null) || s.choking;\r\n}"
}, {
	"Path": "com.netflix.hollow.tools.stringifier.AbstractHollowRecordStringifierTest.stringifyType",
	"Comment": "sends instances of a type through the hollowrecordstringifier. this concatenates recordsfor all the instances, separated by newlines.",
	"Method": "String stringifyType(Class<T> clazz,HollowStringifier<S> stringifier,T instances){\r\n    HollowWriteStateEngine writeStateEngine = new HollowWriteStateEngine();\r\n    HollowObjectMapper objectMapper = new HollowObjectMapper(writeStateEngine);\r\n    objectMapper.initializeTypeState(clazz);\r\n    for (T instance : instances) {\r\n        objectMapper.add(instance);\r\n    }\r\n    HollowReadStateEngine readStateEngine = new HollowReadStateEngine();\r\n    StateEngineRoundTripper.roundTripSnapshot(writeStateEngine, readStateEngine, null);\r\n    StringWriter writer = new StringWriter();\r\n    stringifier.stringify(writer, readStateEngine, clazz.getSimpleName(), 0);\r\n    for (int i = 1; i < instances.length; i++) {\r\n        writer.append(NEWLINE);\r\n        stringifier.stringify(writer, readStateEngine, clazz.getSimpleName(), i);\r\n    }\r\n    return writer.toString();\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerState.getNextMACKey",
	"Comment": "the pending aes key for verifying packets if we are rekeying the connection, or null if we are not in the process of rekeying.",
	"Method": "SessionKey getNextMACKey(){\r\n    return _nextMACKey;\r\n}"
}, {
	"Path": "com.spotify.heroic.test.AbstractMetricBackendIT.testOne",
	"Comment": "some backends have optimized code for writing a single sample.",
	"Method": "void testOne(){\r\n    newCase().input(100L).expect(100L).forEach((input, expected) -> {\r\n        verifyReadWrite(input, expected, new DateRange(99L, 100L));\r\n    });\r\n}"
}, {
	"Path": "io.helidon.security.SecurityResponse.getDescription",
	"Comment": "description of current security status. should be provided by security providers mostly for failure cases.",
	"Method": "Optional<String> getDescription(){\r\n    return Optional.ofNullable(description);\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.Archive.getType",
	"Comment": "returns the type of function used to calculate the consolidated data point.",
	"Method": "ConsolidationFunctionType getType(){\r\n    return type;\r\n}"
}, {
	"Path": "i2p.susi.webmail.WebMail.composeDraft",
	"Comment": "take the data from the parameters, and put it in a stringbuilder\tsuitable for writing out as a draft.\twe do no validation of recipients, total length, sender, etc. here.\tall params except session may be null.",
	"Method": "StringBuilder composeDraft(SessionObject sessionObject,RequestWrapper request,StringBuilder composeDraft,SessionObject sessionObject,String from,String to,String cc,String bcc,String subject,String text,List<Attachment> attachments){\r\n    boolean ok = true;\r\n    if (subject == null || subject.trim().length() <= 0)\r\n        subject = _t(\"no subject\");\r\n    else\r\n        subject = subject.trim();\r\n    boolean fixed = Boolean.parseBoolean(Config.getProperty(CONFIG_SENDER_FIXED, \"true\"));\r\n    if (fixed) {\r\n        String domain = Config.getProperty(CONFIG_SENDER_DOMAIN, \"mail.i2p\");\r\n        from = \"<\" + sessionObject.user + \"@\" + domain + \">\";\r\n    }\r\n    ArrayList<String> toList = new ArrayList<String>();\r\n    ArrayList<String> ccList = new ArrayList<String>();\r\n    ArrayList<String> bccList = new ArrayList<String>();\r\n    Mail.getRecipientsFromList(toList, to, ok);\r\n    Mail.getRecipientsFromList(ccList, cc, ok);\r\n    Mail.getRecipientsFromList(bccList, bcc, ok);\r\n    Encoding qp = EncodingFactory.getEncoding(\"quoted-printable\");\r\n    Encoding hl = EncodingFactory.getEncoding(\"HEADERLINE\");\r\n    StringBuilder body = null;\r\n    if (ok) {\r\n        boolean multipart = attachments != null && !attachments.isEmpty();\r\n        if (multipart) {\r\n            Draft draft = new Draft(\"\");\r\n            for (Attachment a : attachments) {\r\n                draft.addAttachment(a);\r\n            }\r\n            body = draft.encodeAttachments();\r\n        } else {\r\n            body = new StringBuilder(1024);\r\n        }\r\n        I2PAppContext ctx = I2PAppContext.getGlobalContext();\r\n        body.append(\"Date: \" + RFC822Date.to822Date(ctx.clock().now()) + \"\\r\\n\");\r\n        if (from != null)\r\n            body.append(\"From: \" + from + \"\\r\\n\");\r\n        Mail.appendRecipients(body, toList, \"To: \");\r\n        Mail.appendRecipients(body, ccList, \"Cc: \");\r\n        Mail.appendRecipients(body, bccList, Draft.HDR_BCC);\r\n        Log log = sessionObject.log;\r\n        try {\r\n            body.append(hl.encode(\"Subject: \" + subject));\r\n        } catch (EncodingException e) {\r\n            ok = false;\r\n            sessionObject.error += e.getMessage() + '\\n';\r\n            if (log.shouldDebug())\r\n                log.debug(\"Draft subj\", e);\r\n        }\r\n        body.append(\"MIME-Version: 1.0\\r\\nContent-type: text/plain; charset=\\\"utf-8\\\"\\r\\nContent-Transfer-Encoding: quoted-printable\\r\\n\\r\\n\");\r\n        try {\r\n            body.append(qp.encode(text));\r\n            int len = body.length();\r\n            if (body.charAt(len - 2) != '\\r' && body.charAt(len - 1) != '\\n')\r\n                body.append(\"\\r\\n\");\r\n        } catch (EncodingException e) {\r\n            ok = false;\r\n            sessionObject.error += e.getMessage() + '\\n';\r\n            if (log.shouldDebug())\r\n                log.debug(\"Draft body\", e);\r\n        }\r\n    }\r\n    return ok ? body : null;\r\n}"
}, {
	"Path": "net.i2p.data.i2np.BuildRequestRecord.readIsInboundGateway",
	"Comment": "the current hop is the inbound gateway.if this is true, it means anyone can send messages tothis tunnel, but if it is false, only the current predecessor can.",
	"Method": "boolean readIsInboundGateway(){\r\n    return (_data[OFF_FLAG] & FLAG_UNRESTRICTED_PREV) != 0;\r\n}"
}, {
	"Path": "com.netflix.hollow.tools.compact.HollowCompactor.needsCompaction",
	"Comment": "determine whether a compaction is necessary, based on the criteria specified in the constructor.",
	"Method": "boolean needsCompaction(){\r\n    return !findCompactionTargets().isEmpty();\r\n}"
}, {
	"Path": "net.i2p.router.web.helpers.ConfigNetHelper.getUdpPort",
	"Comment": "to reduce confusion caused by nats, this is the current internal ssu port, not the external port.",
	"Method": "String getUdpPort(){\r\n    return getConfiguredUdpPort();\r\n}"
}, {
	"Path": "org.jrobin.core.Datasource.getRrdAllocator",
	"Comment": "required to implement rrdupdater interface. you should never call this method directly.",
	"Method": "RrdAllocator getRrdAllocator(){\r\n    return parentDb.getRrdAllocator();\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.PeerTestJob.getTestTimeout",
	"Comment": "how long to give each peer before marking them as unresponsive?",
	"Method": "int getTestTimeout(){\r\n    return 30 * 1000;\r\n}"
}, {
	"Path": "org.klomp.snark.Storage.getBitField",
	"Comment": "the bitfield that tells which pieces this storage contains.do not change this since this is the current state of the storage.",
	"Method": "BitField getBitField(){\r\n    return bitfield;\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.KademliaNetworkDatabaseFacade.fail",
	"Comment": "final remove for a leaseset.for a router info, will look up in the network before dropping.",
	"Method": "void fail(Hash dbEntry){\r\n    if (!_initialized)\r\n        return;\r\n    DatabaseEntry o = _ds.get(dbEntry);\r\n    if (o == null) {\r\n        _kb.remove(dbEntry);\r\n        _context.peerManager().removeCapabilities(dbEntry);\r\n        return;\r\n    }\r\n    if (o.getType() == DatabaseEntry.KEY_TYPE_ROUTERINFO) {\r\n        lookupBeforeDropping(dbEntry, (RouterInfo) o);\r\n        return;\r\n    }\r\n    if (_log.shouldLog(Log.INFO))\r\n        _log.info(\"Dropping a lease: \" + dbEntry);\r\n    _ds.remove(dbEntry, false);\r\n}"
}, {
	"Path": "net.i2p.router.web.helpers.SummaryHelper.getAllPeers",
	"Comment": "subtract one for ourselves, so if we know no other peers it displays zero",
	"Method": "int getAllPeers(){\r\n    return Math.max(_context.netDb().getKnownRouters() - 1, 0);\r\n}"
}, {
	"Path": "net.i2p.I2PAppContext.getCurrentContext",
	"Comment": "pull the default context, without creating a new one.use this in static methods used early in router initialization,where creating a context messes things up.",
	"Method": "I2PAppContext getCurrentContext(){\r\n    return _globalAppContext;\r\n}"
}, {
	"Path": "com.spotify.heroic.ObjectHasherTest.testSameClass",
	"Comment": "test that classes with the same name and topology matches.and classes with the same topology, but different name does not.",
	"Method": "void testSameClass(){\r\n    final Consumer<Foo> c1 = h1.with(Foo::hashTo);\r\n    final Consumer<Foo> c2 = h2.with(Foo::hashTo);\r\n    final Consumer<Bar> c3 = h3.with(Bar::hashTo);\r\n    c1.accept(new Foo(42));\r\n    c2.accept(new Foo(42));\r\n    c3.accept(new Bar(42));\r\n    assertEquals(h1.result(), h2.result());\r\n    assertNotEquals(h1.result(), h3.result());\r\n}"
}, {
	"Path": "com.spotify.heroic.requestcondition.UserAgent.matches",
	"Comment": "match the httpcontext and optionally provide a feature set to apply to a request.",
	"Method": "boolean matches(QueryContext context){\r\n    return context.getHttpContext().flatMap(httpContext -> httpContext.getUserAgent().map(this.userAgent::equals)).orElse(false);\r\n}"
}, {
	"Path": "org.klomp.snark.PeerCoordinator.allowedUploaders",
	"Comment": "return number of allowed uploaders for this torrent.check with snark to see if we are over the total upload limit.",
	"Method": "int allowedUploaders(){\r\n    int up = uploaders.get();\r\n    if (listener != null && listener.overUploadLimit(interestedUploaders.get())) {\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"Over limit, uploaders was: \" + up);\r\n        return up - 1;\r\n    } else if (up < MAX_UPLOADERS) {\r\n        return up + 1;\r\n    } else {\r\n        return MAX_UPLOADERS;\r\n    }\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.file.type.IgnoreFileType.getName",
	"Comment": "returns the name of the file type. the name must be unique among all file types registered in the system.",
	"Method": "String getName(){\r\n    return language.getID() + \" file\";\r\n}"
}, {
	"Path": "net.nicoulaj.idea.markdown.editor.MarkdownPathResolver.findVirtualFile",
	"Comment": "makes a simple attempt to convert the url into a virtualfile.",
	"Method": "VirtualFile findVirtualFile(URL target){\r\n    return VirtualFileManager.getInstance().getFileSystem(target.getProtocol()).findFileByPath(target.getFile());\r\n}"
}, {
	"Path": "com.netflix.hollow.api.codegen.HollowAPIGenerator.setUseBooleanFieldErgonomics",
	"Comment": "use this method to specify to use new boolean field ergonomics for generated apidefaults to false to be backwards compatible",
	"Method": "void setUseBooleanFieldErgonomics(boolean useBooleanFieldErgonomics){\r\n    config.setUseBooleanFieldErgonomics(useBooleanFieldErgonomics);\r\n}"
}, {
	"Path": "i2p.susi.webmail.Mail.getRecipientsFromList",
	"Comment": "a little misnamed. adds all addresses from the elements\tin text to the recipients list.",
	"Method": "boolean getRecipientsFromList(ArrayList<String> recipients,String text,boolean ok,boolean getRecipientsFromList,ArrayList<String> recipients,String[] ccs,boolean ok){\r\n    if (ccs != null && ccs.length > 0) {\r\n        for (int i = 0; i < ccs.length; i++) {\r\n            String recipient = ccs[i].trim();\r\n            if (validateAddress(recipient)) {\r\n                String str = getAddress(recipient);\r\n                if (str != null && str.length() > 0) {\r\n                    recipients.add(str);\r\n                } else {\r\n                    ok = false;\r\n                }\r\n            } else {\r\n                ok = false;\r\n            }\r\n        }\r\n    }\r\n    return ok;\r\n}"
}, {
	"Path": "com.spotify.heroic.statistics.semantic.MinMaxSlidingTimeReservoir.calculateFirstBucket",
	"Comment": "calculate the first possible bucket that is within the current time interval.",
	"Method": "long calculateFirstBucket(){\r\n    return (clock.getTick() - (step * size)) / step;\r\n}"
}, {
	"Path": "net.i2p.crypto.AESEngine.getPadding",
	"Comment": "return random bytes for padding the data to a mod 16 size so that it isat least minpaddedsizepublic for elgamalaesengine.not a public api, not for external use.",
	"Method": "byte[] getPadding(I2PAppContext context,int curSize,long minPaddedSize){\r\n    int size = getPaddingSize(curSize, minPaddedSize);\r\n    byte[] rv = new byte[size];\r\n    context.random().nextBytes(rv);\r\n    return rv;\r\n}"
}, {
	"Path": "net.i2p.sam.SAMHandler.startHandling",
	"Comment": "start handling the sam connection, detaching an handling thread.",
	"Method": "void startHandling(){\r\n    thread = new I2PAppThread(this, getClass().getSimpleName());\r\n    thread.start();\r\n}"
}, {
	"Path": "net.i2p.data.Base32.decode",
	"Comment": "decodes base32 content in byte array format and returnsthe decoded byte array.",
	"Method": "void decode(InputStream in,OutputStream out,byte[] decode,String s,byte[] decode,byte[] source){\r\n    int len58;\r\n    if (source.length <= 1)\r\n        len58 = source.length;\r\n    else\r\n        len58 = source.length * 5 / 8;\r\n    byte[] outBuff = new byte[len58];\r\n    int outBuffPosn = 0;\r\n    int usedbits = 0;\r\n    for (int i = 0; i < source.length; i++) {\r\n        int fivebits;\r\n        if ((source[i] & 0x80) != 0 || source[i] < '2' || source[i] > 'z')\r\n            fivebits = BAD_ENCODING;\r\n        else\r\n            fivebits = DECODABET[source[i] - '2'];\r\n        if (fivebits >= 0) {\r\n            if (usedbits == 0) {\r\n                outBuff[outBuffPosn] = (byte) ((fivebits << 3) & 0xf8);\r\n                usedbits = 5;\r\n            } else if (usedbits < 3) {\r\n                outBuff[outBuffPosn] |= (fivebits << (3 - usedbits)) & dmask[usedbits];\r\n                usedbits += 5;\r\n            } else if (usedbits == 3) {\r\n                outBuff[outBuffPosn++] |= fivebits;\r\n                usedbits = 0;\r\n            } else {\r\n                outBuff[outBuffPosn++] |= (fivebits >> (usedbits - 3)) & dmask[usedbits];\r\n                byte next = (byte) (fivebits << (11 - usedbits));\r\n                if (outBuffPosn < len58) {\r\n                    outBuff[outBuffPosn] = next;\r\n                    usedbits -= 3;\r\n                } else if (next != 0) {\r\n                    return null;\r\n                }\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    return outBuff;\r\n}"
}, {
	"Path": "net.i2p.data.PrivateKey.hashCode",
	"Comment": "we assume the data has enough randomness in it, so use the last 4 bytes for speed.overridden since we use short exponents, so the first 227 bytes are all zero.",
	"Method": "int hashCode(){\r\n    if (_data == null)\r\n        return 0;\r\n    if (_type != DEF_TYPE)\r\n        return DataHelper.hashCode(_data);\r\n    int rv = _data[KEYSIZE_BYTES - 4];\r\n    for (int i = 1; i < 4; i++) rv ^= (_data[i + (KEYSIZE_BYTES - 4)] << (i * 8));\r\n    return rv;\r\n}"
}, {
	"Path": "io.helidon.webserver.RequestPredicate.any",
	"Comment": "combines several provided predicates in short circuit or manner.",
	"Method": "RequestPredicate any(RequestPredicate predicates){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "net.i2p.desktopgui.InternalTrayManager.launchBrowser",
	"Comment": "build the console url with info from the port mapper,and launch the browser at it.modified from i2ptunnelhttpclientbase.todo perhaps move this to a new portmapper method.",
	"Method": "void launchBrowser(){\r\n    String url = _context.portMapper().getConsoleURL();\r\n    try {\r\n        I2PDesktop.browse(url);\r\n    } catch (BrowseException e1) {\r\n        log.log(Log.WARN, \"Failed to open browser!\", e1);\r\n    }\r\n}"
}, {
	"Path": "com.netflix.hollow.tools.patch.delta.HollowStateDeltaPatcher.getStateEngine",
	"Comment": "returns the hollowwritestateengine containing the state, use this to write the deltas and reverse deltas.",
	"Method": "HollowWriteStateEngine getStateEngine(){\r\n    return writeEngine;\r\n}"
}, {
	"Path": "net.i2p.sam.client.SAMEventHandler.waitForSessionCreateReply",
	"Comment": "wait for the session to be created, returning true if everything went ok",
	"Method": "boolean waitForSessionCreateReply(){\r\n    while (true) {\r\n        try {\r\n            synchronized (_sessionCreateLock) {\r\n                if (_sessionCreateOk == null)\r\n                    _sessionCreateLock.wait();\r\n                else\r\n                    return _sessionCreateOk.booleanValue();\r\n            }\r\n        } catch (InterruptedException ie) {\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.RRDatabase.getArchive",
	"Comment": "returns the archive at the specified position in this database.",
	"Method": "Archive getArchive(int index){\r\n    return archives.get(index);\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.Archive.getCDPStatusBlocks",
	"Comment": "returns an iterator over the cdp status blocks in this archive in proper sequence.",
	"Method": "Iterator<CDPStatusBlock> getCDPStatusBlocks(){\r\n    return cdpStatusBlocks.iterator();\r\n}"
}, {
	"Path": "com.netflix.hollow.core.memory.ThreadSafeBitSet.getSegment",
	"Comment": "get the segment at segmentindex.if this segment does not yet exist, create it.",
	"Method": "AtomicLongArray getSegment(int segmentIndex,AtomicLongArray getSegment,int index){\r\n    ThreadSafeBitSetSegments visibleSegments = segments.get();\r\n    while (visibleSegments.numSegments() <= segmentIndex) {\r\n        ThreadSafeBitSetSegments newVisibleSegments = new ThreadSafeBitSetSegments(visibleSegments, segmentIndex + 1, numLongsPerSegment);\r\n        if (segments.compareAndSet(visibleSegments, newVisibleSegments)) {\r\n            visibleSegments = newVisibleSegments;\r\n        } else {\r\n            visibleSegments = segments.get();\r\n        }\r\n    }\r\n    return visibleSegments.getSegment(segmentIndex);\r\n}"
}, {
	"Path": "net.i2p.router.JobQueue.updateJobTimings",
	"Comment": "update the clock data for all jobs in process or scheduled forcompletion.",
	"Method": "void updateJobTimings(long delta){\r\n    synchronized (_jobLock) {\r\n        for (Job j : _timedJobs) {\r\n            j.getTiming().offsetChanged(delta);\r\n        }\r\n        for (Job j : _readyJobs) {\r\n            j.getTiming().offsetChanged(delta);\r\n        }\r\n    }\r\n    synchronized (_runnerLock) {\r\n        for (JobQueueRunner runner : _queueRunners.values()) {\r\n            Job job = runner.getCurrentJob();\r\n            if (job != null)\r\n                job.getTiming().offsetChanged(delta);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.nicoulaj.idea.markdown.lang.parser.MarkdownParserDefinition.getStringLiteralElements",
	"Comment": "get the set of element types which are treated as string literals.",
	"Method": "TokenSet getStringLiteralElements(){\r\n    return TokenSet.EMPTY;\r\n}"
}, {
	"Path": "com.spotify.heroic.ObjectHasherTest.testChainedLists",
	"Comment": "this tries to verify that two chained lists do not have overlapping hashes.",
	"Method": "void testChainedLists(){\r\n    final Consumer<List<Boolean>> f1 = h1.list(h1.bool());\r\n    final Consumer<List<Boolean>> f2 = h2.list(h2.bool());\r\n    f1.accept(ImmutableList.of(true, true));\r\n    f1.accept(ImmutableList.of(true, true));\r\n    f2.accept(ImmutableList.of(true));\r\n    f2.accept(ImmutableList.of(true, true, true));\r\n    assertNotEquals(h1.result(), h2.result());\r\n}"
}, {
	"Path": "net.i2p.data.LeaseSet2.sign",
	"Comment": "sign the structure using the supplied signing key.overridden because ls2 sigs cover the type byte.",
	"Method": "void sign(SigningPrivateKey key){\r\n    if (_signature != null)\r\n        throw new IllegalStateException();\r\n    if (key == null)\r\n        throw new DataFormatException(\"No signing key\");\r\n    int len = size();\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream(1 + len);\r\n    try {\r\n        out.write(getType());\r\n        writeBytesWithoutSig(out);\r\n    } catch (IOException ioe) {\r\n        throw new DataFormatException(\"Signature failed\", ioe);\r\n    }\r\n    byte[] data = out.toByteArray();\r\n    _signature = DSAEngine.getInstance().sign(data, key);\r\n    if (_signature == null)\r\n        throw new DataFormatException(\"Signature failed with \" + key.getType() + \" key\");\r\n}"
}, {
	"Path": "org.klomp.snark.PeerID.idencode",
	"Comment": "encode an id as a hex encoded string and remove leading zeros.",
	"Method": "String idencode(byte[] bs){\r\n    boolean leading_zeros = true;\r\n    StringBuilder sb = new StringBuilder(bs.length * 2);\r\n    for (int i = 0; i < bs.length; i++) {\r\n        int c = bs[i] & 0xFF;\r\n        if (leading_zeros && c == 0)\r\n            continue;\r\n        else\r\n            leading_zeros = false;\r\n        if (c < 16)\r\n            sb.append('0');\r\n        sb.append(Integer.toHexString(c));\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.actions.NewFileAction.update",
	"Comment": "updates visibility of the action presentation in various actions list.",
	"Method": "void update(AnActionEvent e){\r\n    final Project project = e.getData(CommonDataKeys.PROJECT);\r\n    final IdeView view = e.getData(LangDataKeys.IDE_VIEW);\r\n    final PsiDirectory[] directory = view != null ? view.getDirectories() : null;\r\n    if (directory == null || directory.length == 0 || project == null || !this.fileType.getIgnoreLanguage().isNewAllowed()) {\r\n        e.getPresentation().setVisible(false);\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.core.Datasource.setMaxValue",
	"Comment": "sets maximum allowed value for this datasource. if filterarchivedvalues\targment is set to true, all archived values greater then maxvalue will\tbe fixed to nan.",
	"Method": "void setMaxValue(double maxValue,boolean filterArchivedValues){\r\n    final double minValue = this.minValue.get();\r\n    if (!Double.isNaN(minValue) && !Double.isNaN(maxValue) && minValue >= maxValue) {\r\n        throw new RrdException(\"Invalid min/max values: \" + minValue + \"/\" + maxValue);\r\n    }\r\n    this.maxValue.set(maxValue);\r\n    if (!Double.isNaN(maxValue) && filterArchivedValues) {\r\n        final int dsIndex = getDsIndex();\r\n        final Archive[] archives = parentDb.getArchives();\r\n        for (final Archive archive : archives) {\r\n            archive.getRobin(dsIndex).filterValues(Double.NaN, maxValue);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.sam.SAMv3StreamSession.acceptSocket",
	"Comment": "take a socket from the accept queue.\tonly for subsession, throws illegalstateexception otherwise.",
	"Method": "I2PSocket acceptSocket(){\r\n    if (_acceptQueue == null)\r\n        throw new IllegalStateException();\r\n    try {\r\n        return _acceptQueue.take();\r\n    } catch (InterruptedException ie) {\r\n        ConnectException ce = new ConnectException(\"interrupted\");\r\n        ce.initCause(ie);\r\n        throw ce;\r\n    }\r\n}"
}, {
	"Path": "net.i2p.util.I2PThread.removeOOMEventListener",
	"Comment": "unregister a component that wants notification of oom events",
	"Method": "void removeOOMEventListener(OOMEventListener lsnr){\r\n    _listeners.remove(lsnr);\r\n}"
}, {
	"Path": "org.klomp.snark.Peer.isInteresting",
	"Comment": "whether or not the peer has pieces we want from it. returns falseif not connected.",
	"Method": "boolean isInteresting(){\r\n    PeerState s = state;\r\n    return (s != null) && s.interesting;\r\n}"
}, {
	"Path": "net.i2p.router.web.ContentHelper.setPage",
	"Comment": "caution, use absolute paths only, do not assume files are in cwd",
	"Method": "void setPage(String page){\r\n    _page = page;\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.web.EditBean.staticIsClient",
	"Comment": "is it a client or server in the ui and i2p side? note that a streamr client is a ui and i2p client but a server on the localhost side. note that a streamr server is a ui and i2p server but a client on the localhost side.",
	"Method": "boolean staticIsClient(int tunnel){\r\n    TunnelControllerGroup group = TunnelControllerGroup.getInstance();\r\n    if (group == null)\r\n        return false;\r\n    List<TunnelController> controllers = group.getControllers();\r\n    if (controllers.size() > tunnel) {\r\n        TunnelController cur = controllers.get(tunnel);\r\n        if (cur == null)\r\n            return false;\r\n        return isClient(cur.getType());\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.web.FormHandler.getAllMessages",
	"Comment": "display everything, wrap it in a div for consistent presentation",
	"Method": "String getAllMessages(){\r\n    validate();\r\n    process();\r\n    if (_errors.isEmpty() && _notices.isEmpty())\r\n        return \"\";\r\n    StringBuilder buf = new StringBuilder(512);\r\n    buf.append(\"<div class=\\\"messages\\\" id=\\\"messages\\\">\");\r\n    if (!_errors.isEmpty()) {\r\n        buf.append(\"<div class=\\\"error\\\">\");\r\n        buf.append(render(_errors));\r\n        buf.append(\"<\/div>\");\r\n    }\r\n    if (!_notices.isEmpty()) {\r\n        buf.append(\"<div class=\\\"notice\\\">\");\r\n        buf.append(render(_notices));\r\n        buf.append(\"<\/div>\");\r\n    }\r\n    buf.append(\"<\/div>\");\r\n    return buf.toString();\r\n}"
}, {
	"Path": "net.i2p.BOB.BOB.visitAllThreads",
	"Comment": "find the root thread group,\t \tthen find all theads with certain names and wait for them all to be dead.",
	"Method": "void visitAllThreads(){\r\n    ThreadGroup root = Thread.currentThread().getThreadGroup().getParent();\r\n    while (root.getParent() != null) {\r\n        root = root.getParent();\r\n    }\r\n    waitjoin(root, 0, root.getName());\r\n}"
}, {
	"Path": "com.netflix.hollow.core.memory.FreeOrdinalTracker.returnOrdinalToPool",
	"Comment": "return an ordinal to the pool after the object to which it was assigned is discarded.",
	"Method": "void returnOrdinalToPool(int ordinal){\r\n    if (size == freeOrdinals.length) {\r\n        freeOrdinals = Arrays.copyOf(freeOrdinals, freeOrdinals.length * 3 / 2);\r\n    }\r\n    freeOrdinals[size] = ordinal;\r\n    size++;\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.RRDatabase.getArchives",
	"Comment": "returns an iterator over the archives in this database of the given type\tin proper sequence.",
	"Method": "Iterator<Archive> getArchives(Iterator<Archive> getArchives,ConsolidationFunctionType type){\r\n    return getArchiveList(type).iterator();\r\n}"
}, {
	"Path": "io.helidon.security.Grant.builder",
	"Comment": "creates a fluent api builder to build new instances of this class.",
	"Method": "Builder builder(){\r\n    return new Builder();\r\n}"
}, {
	"Path": "net.i2p.client.impl.I2PSessionImpl.getPrivateKey",
	"Comment": "retrieve the signing signingprivatekey.as of 0.9.38, this will be the transient key if offline signed.",
	"Method": "SigningPrivateKey getPrivateKey(){\r\n    return _signingPrivateKey;\r\n}"
}, {
	"Path": "io.helidon.security.jersey.HttpUtil.basicAuthCallbackHandler",
	"Comment": "extracts username and password from http headers to prepare a callback handler.if the header is not present returns null, if invalid format, throws an exception.",
	"Method": "CallbackHandler basicAuthCallbackHandler(Map<String, List<String>> headers){\r\n    List<String> authorization = headers.get(AUTHN_HEADER);\r\n    if ((null == authorization) || authorization.isEmpty()) {\r\n        return null;\r\n    }\r\n    String authorizationValue = authorization.get(0);\r\n    if (authorizationValue.toLowerCase().startsWith(BASIC_PREFIX)) {\r\n        String b64 = authorizationValue.substring(BASIC_PREFIX.length());\r\n        String usernameAndPassword = new String(Base64.getDecoder().decode(b64), StandardCharsets.UTF_8);\r\n        Matcher matcher = CREDENTIAL_PATTERN.matcher(usernameAndPassword);\r\n        if (!matcher.matches()) {\r\n            LOGGER.finest(\"Basic authentication header with invalid content: \" + usernameAndPassword);\r\n            throw new IllegalArgumentException(\"Basic authentication header with invalid content\");\r\n        }\r\n        final String username = matcher.group(1);\r\n        final char[] password = matcher.group(2).toCharArray();\r\n        return callbacks -> {\r\n            for (Callback callback : callbacks) {\r\n                if (callback instanceof NameCallback) {\r\n                    ((NameCallback) callback).setName(username);\r\n                } else if (callback instanceof PasswordCallback) {\r\n                    ((PasswordCallback) callback).setPassword(password);\r\n                } else {\r\n                    throw new UnsupportedCallbackException(callback);\r\n                }\r\n            }\r\n        };\r\n    }\r\n    return callbacks -> {\r\n        for (Callback callback : callbacks) {\r\n            throw new UnsupportedCallbackException(callback);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.settings.IgnoreSettings.isHideIgnoredFiles",
	"Comment": "check if ignored files should be hidden in the project tree view.",
	"Method": "boolean isHideIgnoredFiles(){\r\n    return hideIgnoredFiles;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerState.setWeRelayToThemAs",
	"Comment": "if we are serving as an introducer to them, this is the the tag thatthey can publish that, when presented to us, will cause us to senda relay introduction to the current peer",
	"Method": "void setWeRelayToThemAs(long tag){\r\n    _weRelayToThemAs = tag;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerState.getMessagesSent",
	"Comment": "i2np messages sent. does not include duplicates. as of 0.9.24, incremented when bandwidth is allocated just before sending, not when acked.",
	"Method": "int getMessagesSent(){\r\n    synchronized (_outboundMessages) {\r\n        return _messagesSent;\r\n    }\r\n}"
}, {
	"Path": "com.netflix.hollow.api.client.HollowClient.triggerRefreshTo",
	"Comment": "if the hollowannouncementwatcher supports setting an explicit version, this method will updateto the specified version.otherwise, an unsupportedoperationexception will be thrown.this is a blocking call.",
	"Method": "void triggerRefreshTo(long version){\r\n    announcementWatcher.setLatestVersion(version);\r\n    triggerRefresh();\r\n}"
}, {
	"Path": "net.i2p.crypto.SelfSignedGenerator.generateCRL",
	"Comment": "generate a crl for the given cert, signed with the given private key",
	"Method": "X509CRL generateCRL(X509Certificate cert,int validDays,int crlNum,byte[] sigoid,SigningPrivateKey priv){\r\n    byte[] tbs = genTBSCRL(cert, validDays, crlNum, sigoid);\r\n    int tbslen = tbs.length;\r\n    Signature sig = DSAEngine.getInstance().sign(tbs, priv);\r\n    if (sig == null)\r\n        throw new GeneralSecurityException(\"sig failed\");\r\n    byte[] sigbytes = SigUtil.toJavaSig(sig);\r\n    int seqlen = tbslen + sigoid.length + spaceFor(sigbytes.length + 1);\r\n    int totlen = spaceFor(seqlen);\r\n    byte[] cb = new byte[totlen];\r\n    int idx = 0;\r\n    cb[idx++] = 0x30;\r\n    idx = intToASN1(cb, idx, seqlen);\r\n    System.arraycopy(tbs, 0, cb, idx, tbs.length);\r\n    idx += tbs.length;\r\n    System.arraycopy(sigoid, 0, cb, idx, sigoid.length);\r\n    idx += sigoid.length;\r\n    cb[idx++] = 0x03;\r\n    idx = intToASN1(cb, idx, sigbytes.length + 1);\r\n    cb[idx++] = 0;\r\n    System.arraycopy(sigbytes, 0, cb, idx, sigbytes.length);\r\n    ByteArrayInputStream bais = new ByteArrayInputStream(cb);\r\n    X509CRL rv;\r\n    try {\r\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\r\n        rv = (X509CRL) cf.generateCRL(bais);\r\n    } catch (IllegalArgumentException iae) {\r\n        throw new GeneralSecurityException(\"cert error\", iae);\r\n    }\r\n    return rv;\r\n}"
}, {
	"Path": "com.nettgryppa.security.HashCash.toString",
	"Comment": "returns the canonical string representation of the hashcash",
	"Method": "String toString(){\r\n    return myToken;\r\n}"
}, {
	"Path": "com.netflix.hollow.api.codegen.HollowAPIGenerator.setUseHollowPrimitiveTypes",
	"Comment": "use this method to specify to use hollow primitive types instead of generating them per projectdefaults to false to be backwards compatible",
	"Method": "void setUseHollowPrimitiveTypes(boolean useHollowPrimitiveTypes){\r\n    config.setUseHollowPrimitiveTypes(useHollowPrimitiveTypes);\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.ConnectionOptions.getConnectDelay",
	"Comment": "how long will we wait after instantiating a new con before actually attempting to connect.if this isset to 0, connect asap.if it is greater than 0, waituntil the output stream is flushed, the buffer fills, or that many milliseconds pass.",
	"Method": "int getConnectDelay(){\r\n    return _connectDelay;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PacketBuilder.buildSessionConfirmedPackets",
	"Comment": "build a new series of sessionconfirmed packets for the given peer, encrypting it as necessary.note that while a sessionconfirmed could in theory be fragmented,in practice a routeridentity is 387 bytes and a single fragment is 512 bytes max,so it will never be fragmented.",
	"Method": "UDPPacket[] buildSessionConfirmedPackets(OutboundEstablishState state,RouterIdentity ourIdentity){\r\n    byte[] identity = ourIdentity.toByteArray();\r\n    int numFragments = identity.length / MAX_IDENTITY_FRAGMENT_SIZE;\r\n    if (numFragments * MAX_IDENTITY_FRAGMENT_SIZE != identity.length)\r\n        numFragments++;\r\n    UDPPacket[] packets = new UDPPacket[numFragments];\r\n    for (int i = 0; i < numFragments; i++) packets[i] = buildSessionConfirmedPacket(state, i, numFragments, identity);\r\n    return packets;\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.I2PSocketManagerFull.ping",
	"Comment": "ping the specified peer, returning true if they replied to the ping within the timeout specified, false otherwise.this call blocks.uses the ports specified.todo there is no way to ping on a subsession.",
	"Method": "boolean ping(Destination peer,long timeoutMs,boolean ping,Destination peer,int localPort,int remotePort,long timeoutMs,byte[] ping,Destination peer,int localPort,int remotePort,long timeoutMs,byte[] payload){\r\n    if (localPort < 0 || localPort > 65535 || remotePort < 0 || remotePort > 65535)\r\n        throw new IllegalArgumentException(\"bad port\");\r\n    if (timeoutMs <= 0)\r\n        throw new IllegalArgumentException(\"bad timeout\");\r\n    return _connectionManager.ping(peer, localPort, remotePort, timeoutMs, payload);\r\n}"
}, {
	"Path": "net.i2p.router.web.helpers.ConfigStatsHandler.saveChanges",
	"Comment": "the user made changes to the config and wants to save them, solets go ahead and do so.",
	"Method": "void saveChanges(){\r\n    Map<String, String> changes = new HashMap<String, String>();\r\n    if (_filename == null)\r\n        _filename = StatManager.DEFAULT_STAT_FILE;\r\n    changes.put(StatManager.PROP_STAT_FILE, _filename);\r\n    if (_explicitFilter) {\r\n        _stats.clear();\r\n        if (_explicitFilterValue == null)\r\n            _explicitFilterValue = \"\";\r\n        if (_explicitFilterValue.indexOf(',') != -1) {\r\n            StringTokenizer tok = new StringTokenizer(_explicitFilterValue, \",\");\r\n            while (tok.hasMoreTokens()) {\r\n                String cur = tok.nextToken().trim();\r\n                if ((cur.length() > 0) && (!_stats.contains(cur)))\r\n                    _stats.add(cur);\r\n            }\r\n        } else {\r\n            String stat = _explicitFilterValue.trim();\r\n            if ((stat.length() > 0) && (!_stats.contains(stat)))\r\n                _stats.add(stat);\r\n        }\r\n    }\r\n    StringBuilder stats = new StringBuilder();\r\n    for (int i = 0; i < _stats.size(); i++) {\r\n        stats.append(_stats.get(i));\r\n        if (i + 1 < _stats.size())\r\n            stats.append(',');\r\n    }\r\n    changes.put(StatManager.PROP_STAT_FILTER, stats.toString());\r\n    boolean graphsChanged = !_graphs.equals(_context.getProperty(\"stat.summaries\"));\r\n    changes.put(\"stat.summaries\", _graphs);\r\n    boolean fullChanged = _context.getBooleanProperty(StatManager.PROP_STAT_FULL) != _isFull;\r\n    changes.put(StatManager.PROP_STAT_FULL, Boolean.toString(_isFull));\r\n    _context.router().saveConfig(changes, null);\r\n    if (!_stats.isEmpty())\r\n        addFormNotice(_t(\"Stat filter and location updated successfully to\") + \": \" + stats.toString());\r\n    if (fullChanged) {\r\n        if (_isFull)\r\n            addFormNotice(_t(\"Full statistics enabled\"));\r\n        else\r\n            addFormNotice(_t(\"Full statistics disabled\"));\r\n        addFormNotice(_t(\"Restart required to take effect\"));\r\n    }\r\n    if (graphsChanged)\r\n        addFormNoticeNoEscape(_t(\"Graph list updated, may take up to 60s to be reflected on the {0}Graphs Page{1}\", \"<a href=\\\"graphs\\\">\", \"<\/a>\"));\r\n}"
}, {
	"Path": "net.i2p.data.i2np.I2NPMessageHandler.readMessage",
	"Comment": "read an i2npmessage from the byte array and return the fully populated object.",
	"Method": "I2NPMessage readMessage(byte data,int readMessage,byte data,int offset,int readMessage,byte data,int offset,int maxLen){\r\n    int cur = offset;\r\n    int type = data[cur] & 0xff;\r\n    cur++;\r\n    _lastReadBegin = System.currentTimeMillis();\r\n    I2NPMessage msg = I2NPMessageImpl.createMessage(_context, type);\r\n    try {\r\n        _lastSize = msg.readBytes(data, type, cur, maxLen - 1);\r\n        cur += _lastSize;\r\n    } catch (I2NPMessageException ime) {\r\n        throw ime;\r\n    } catch (RuntimeException e) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Error reading the stream\", e);\r\n        throw new I2NPMessageException(\"Unknown error reading the \" + msg.getClass().getSimpleName(), e);\r\n    }\r\n    _lastReadEnd = System.currentTimeMillis();\r\n    _lastRead = msg;\r\n    return cur - offset;\r\n}"
}, {
	"Path": "net.nicoulaj.idea.markdown.lang.parser.MarkdownParserDefinition.getCommentTokens",
	"Comment": "get the set of token types which are treated as comments by the psi builder.",
	"Method": "TokenSet getCommentTokens(){\r\n    return TokenSet.EMPTY;\r\n}"
}, {
	"Path": "org.klomp.snark.Peer.isInterested",
	"Comment": "whether or not the peer is interested in pieces we have. returnsfalse if not connected.",
	"Method": "boolean isInterested(){\r\n    PeerState s = state;\r\n    return (s != null) && s.interested;\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.templating.util.PhpMethodVariableResolveUtil.collectOnVariableReferences",
	"Comment": "search for references of variable declaration and collect the types",
	"Method": "Map<String, PsiVariable> collectOnVariableReferences(Function function,Variable variable){\r\n    Map<String, PsiVariable> collectedTypes = new HashMap();\r\n    for (Variable scopeVar : PhpElementsUtil.getVariablesInScope(function, variable)) {\r\n        PsiElement parent = scopeVar.getParent();\r\n        if (parent instanceof ArrayAccessExpression) {\r\n            collectedTypes.putAll(getTypesOnArrayIndex((ArrayAccessExpression) parent));\r\n        } else if (parent instanceof AssignmentExpression) {\r\n            if (((AssignmentExpression) parent).getValue() instanceof ArrayCreationExpression) {\r\n                collectedTypes.putAll(getTypesOnArrayHash((ArrayCreationExpression) ((AssignmentExpression) parent).getValue()));\r\n            }\r\n        }\r\n    }\r\n    return collectedTypes;\r\n}"
}, {
	"Path": "com.spotify.heroic.aggregation.AggregationTest.testTagElision",
	"Comment": "test that required tags works when elided for a given collection of aggregations.",
	"Method": "void testTagElision(){\r\n    final Aggregation g1 = Group.of(Optional.of(ImmutableList.of(\"foo\")), Optional.of(a));\r\n    final Aggregation g2 = Group.of(Optional.of(ImmutableList.of(\"bar\")), Optional.of(new Chain(// inner groups should _not_ force tags elision\r\n    ImmutableList.of(Group.of(Optional.of(ImmutableList.of(\"baz\")), Optional.of(a))))));\r\n    final AggregationInstance instance = Aggregations.chain(Optional.of(ImmutableList.of(g1, g2))).apply(context);\r\n    final ChainInstance chain = (ChainInstance) instance;\r\n    final GroupInstance g1i = (GroupInstance) chain.getChain().get(0);\r\n    final GroupInstance g2i = (GroupInstance) chain.getChain().get(1);\r\n    final GroupInstance g2i1i = (GroupInstance) (((GroupInstance) chain.getChain().get(1)).getEach());\r\n    assertEquals(Optional.of(ImmutableSet.of(\"foo\", \"bar\")), g1i.getOf().map(ImmutableSet::copyOf));\r\n    assertEquals(Optional.of(ImmutableSet.of(\"bar\")), g2i.getOf().map(ImmutableSet::copyOf));\r\n    assertEquals(Optional.of(ImmutableSet.of(\"baz\")), g2i1i.getOf().map(ImmutableSet::copyOf));\r\n}"
}, {
	"Path": "net.i2p.util.ResettableGZIPInputStream.verifyHeader",
	"Comment": "make sure the header is valid, throwing an ioexception if its b0rked.",
	"Method": "void verifyHeader(){\r\n    int c = in.read();\r\n    if (c != 0x1F)\r\n        throw new IOException(\"First magic byte was wrong [\" + c + \"]\");\r\n    c = in.read();\r\n    if (c != 0x8B)\r\n        throw new IOException(\"Second magic byte was wrong [\" + c + \"]\");\r\n    c = in.read();\r\n    if (c != 0x08)\r\n        throw new IOException(\"Compression format is invalid [\" + c + \"]\");\r\n    int flags = in.read();\r\n    c = in.read();\r\n    if (c == -1)\r\n        throw new IOException(\"EOF on MTIME0 [\" + c + \"]\");\r\n    c = in.read();\r\n    if (c == -1)\r\n        throw new IOException(\"EOF on MTIME1 [\" + c + \"]\");\r\n    c = in.read();\r\n    if (c == -1)\r\n        throw new IOException(\"EOF on MTIME2 [\" + c + \"]\");\r\n    c = in.read();\r\n    if (c == -1)\r\n        throw new IOException(\"EOF on MTIME3 [\" + c + \"]\");\r\n    c = in.read();\r\n    if ((c != 0x00) && (c != 0x02) && (c != 0x04))\r\n        throw new IOException(\"Invalid extended flags [\" + c + \"]\");\r\n    c = in.read();\r\n    if (0 != (flags & (1 << 5))) {\r\n        int _len = 0;\r\n        c = in.read();\r\n        if (c == -1)\r\n            throw new IOException(\"EOF reading the extra header\");\r\n        _len = c;\r\n        c = in.read();\r\n        if (c == -1)\r\n            throw new IOException(\"EOF reading the extra header\");\r\n        _len += (c << 8);\r\n        for (int i = 0; i < _len; i++) {\r\n            c = in.read();\r\n            if (c == -1)\r\n                throw new IOException(\"EOF reading the extra header's body\");\r\n        }\r\n    }\r\n    if (0 != (flags & (1 << 4))) {\r\n        c = in.read();\r\n        while (c != 0) {\r\n            if (c == -1)\r\n                throw new IOException(\"EOF reading the name\");\r\n            c = in.read();\r\n        }\r\n    }\r\n    if (0 != (flags & (1 << 3))) {\r\n        c = in.read();\r\n        while (c != 0) {\r\n            if (c == -1)\r\n                throw new IOException(\"EOF reading the comment\");\r\n            c = in.read();\r\n        }\r\n    }\r\n    if (0 != (flags & (1 << 6))) {\r\n        c = in.read();\r\n        if (c == -1)\r\n            throw new IOException(\"EOF reading the CRC16\");\r\n        c = in.read();\r\n        if (c == -1)\r\n            throw new IOException(\"EOF reading the CRC16\");\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.JobQueue.runQueue",
	"Comment": "start up the queue with the specified number of concurrent processors.if this method has already been called, it will adjust the number of runners to meet the new number.this does not kill jobs running onexcess threads, it merely instructs the threads to die after finishingthe current job.",
	"Method": "void runQueue(int numThreads){\r\n    if ((!_queueRunners.isEmpty()) && (!_allowParallelOperation))\r\n        return;\r\n    if (_queueRunners.size() < numThreads) {\r\n        if (_log.shouldLog(Log.INFO))\r\n            _log.info(\"Increasing the number of queue runners from \" + _queueRunners.size() + \" to \" + numThreads);\r\n        for (int i = _queueRunners.size(); i < numThreads; i++) {\r\n            JobQueueRunner runner = new JobQueueRunner(_context, i);\r\n            _queueRunners.put(Integer.valueOf(i), runner);\r\n            runner.setName(\"JobQueue \" + _runnerId.incrementAndGet() + '/' + numThreads);\r\n            runner.start();\r\n        }\r\n    } else if (_queueRunners.size() == numThreads) {\r\n        for (JobQueueRunner runner : _queueRunners.values()) {\r\n            runner.startRunning();\r\n        }\r\n    } else {\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.RouterClock.now",
	"Comment": "retrieve the current time synchronized with whatever reference clock is in use.do really simple clock slewing, like ntp but without jitter prevention.slew the clock toward the desired offset, but only up to a maximum slew rate,and never let the clock go backwards because of slewing.take care to only access the volatile variables once for speed and toavoid having another thread change themthis is called about a zillion times a second, so we can do the slewing righthere rather than in some separate thread to keep it simple.avoiding backwards clocks when updating in a thread would be hard too.",
	"Method": "long now(){\r\n    long systemNow = System.currentTimeMillis();\r\n    long offset = _offset;\r\n    long sinceLastSlewed = systemNow - _lastSlewed;\r\n    if (sinceLastSlewed >= MASSIVE_SHIFT_FORWARD || sinceLastSlewed <= 0 - MASSIVE_SHIFT_BACKWARD) {\r\n        _lastSlewed = systemNow;\r\n        notifyMassive(sinceLastSlewed);\r\n    } else if (sinceLastSlewed >= MAX_SLEW) {\r\n        long desiredOffset = _desiredOffset;\r\n        if (desiredOffset > offset) {\r\n            offset += Math.min(10, sinceLastSlewed / MAX_SLEW);\r\n            _offset = offset;\r\n        } else if (desiredOffset < offset) {\r\n            _offset = --offset;\r\n        }\r\n        _lastSlewed = systemNow;\r\n    }\r\n    return offset + systemNow;\r\n}"
}, {
	"Path": "com.netflix.hollow.core.read.HollowReadFieldUtils.fieldsAreEqual",
	"Comment": "determine whether two object field records are exactly equal.",
	"Method": "boolean fieldsAreEqual(HollowObjectTypeDataAccess typeAccess1,int ordinal1,int fieldPosition1,HollowObjectTypeDataAccess typeAccess2,int ordinal2,int fieldPosition2){\r\n    HollowObjectSchema schema1 = typeAccess1.getSchema();\r\n    switch(schema1.getFieldType(fieldPosition1)) {\r\n        case BOOLEAN:\r\n            Boolean bool1 = typeAccess1.readBoolean(ordinal1, fieldPosition1);\r\n            Boolean bool2 = typeAccess2.readBoolean(ordinal2, fieldPosition2);\r\n            return bool1 == bool2;\r\n        case BYTES:\r\n            byte[] data1 = typeAccess1.readBytes(ordinal1, fieldPosition1);\r\n            byte[] data2 = typeAccess2.readBytes(ordinal2, fieldPosition2);\r\n            return Arrays.equals(data1, data2);\r\n        case DOUBLE:\r\n            double d1 = typeAccess1.readDouble(ordinal1, fieldPosition1);\r\n            double d2 = typeAccess2.readDouble(ordinal2, fieldPosition2);\r\n            return Double.compare(d1, d2) == 0;\r\n        case FLOAT:\r\n            float f1 = typeAccess1.readFloat(ordinal1, fieldPosition1);\r\n            float f2 = typeAccess2.readFloat(ordinal2, fieldPosition2);\r\n            return Float.compare(f1, f2) == 0;\r\n        case INT:\r\n            int i1 = typeAccess1.readInt(ordinal1, fieldPosition1);\r\n            int i2 = typeAccess2.readInt(ordinal2, fieldPosition2);\r\n            return i1 == i2;\r\n        case LONG:\r\n            long l1 = typeAccess1.readLong(ordinal1, fieldPosition1);\r\n            long l2 = typeAccess2.readLong(ordinal2, fieldPosition2);\r\n            return l1 == l2;\r\n        case STRING:\r\n            String s1 = typeAccess1.readString(ordinal1, fieldPosition1);\r\n            return typeAccess2.isStringFieldEqual(ordinal2, fieldPosition2, s1);\r\n        case REFERENCE:\r\n            if (typeAccess1 == typeAccess2 && fieldPosition1 == fieldPosition2)\r\n                return typeAccess1.readOrdinal(ordinal1, fieldPosition1) == typeAccess2.readOrdinal(ordinal2, fieldPosition2);\r\n        default:\r\n    }\r\n    throw new IllegalStateException(\"I don't know how to test equality for a \" + schema1.getFieldType(fieldPosition1));\r\n}"
}, {
	"Path": "net.i2p.data.PrivateKey.toPublic",
	"Comment": "derives a new publickey object derived from the secret contentsof this privatekey",
	"Method": "PublicKey toPublic(){\r\n    return KeyGenerator.getPublicKey(this);\r\n}"
}, {
	"Path": "net.i2p.BOB.NamedDB.get",
	"Comment": "get the object, and return it, throws runtimeexception if not found",
	"Method": "Object get(String key){\r\n    Object rv = data.get(key);\r\n    if (rv != null)\r\n        return rv;\r\n    throw new RuntimeException(\"Key not found\");\r\n}"
}, {
	"Path": "org.jrobin.graph.RrdGraphInfo.dump",
	"Comment": "dumps complete graph information. useful for debugging purposes.",
	"Method": "String dump(){\r\n    StringBuffer b = new StringBuffer();\r\n    b.append(\"filename = \\\"\").append(getFilename()).append(\"\\\"\\n\");\r\n    b.append(\"width = \").append(getWidth()).append(\", height = \").append(getHeight()).append(\"\\n\");\r\n    b.append(\"byteCount = \").append(getByteCount()).append(\"\\n\");\r\n    b.append(\"imginfo = \\\"\").append(getImgInfo()).append(\"\\\"\\n\");\r\n    String[] plines = getPrintLines();\r\n    if (plines.length == 0) {\r\n        b.append(\"No print lines found\\n\");\r\n    } else {\r\n        for (int i = 0; i < plines.length; i++) {\r\n            b.append(\"print[\").append(i).append(\"] = \\\"\").append(plines[i]).append(\"\\\"\\n\");\r\n        }\r\n    }\r\n    return b.toString();\r\n}"
}, {
	"Path": "com.netflix.hollow.core.memory.ByteArrayOrdinalMap.rehashPreviouslyAddedData",
	"Comment": "get the hash code for the byte array pointed to by the specified key.",
	"Method": "int rehashPreviouslyAddedData(long key){\r\n    long position = key & POINTER_MASK;\r\n    int sizeOfData = VarInt.readVInt(byteData.getUnderlyingArray(), position);\r\n    position += VarInt.sizeOfVInt(sizeOfData);\r\n    return HashCodes.hashCode(byteData.getUnderlyingArray(), position, sizeOfData);\r\n}"
}, {
	"Path": "edu.internet2.ndt.Tcpbw100.test_meta",
	"Comment": "the meta test allows the client to send an additional information to the\tserver that basically gets included along with the overall set of test\tresults.",
	"Method": "boolean test_meta(Protocol paramProtoObj,String application){\r\n    Message msg = new Message();\r\n    if ((_yTests & NDTConstants.TEST_META) == NDTConstants.TEST_META) {\r\n        showStatus(_resBundDisplayMsgs.getString(\"metaTest\"));\r\n        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"sendingMetaInformation\") + \" \");\r\n        _txtStatistics.append(_resBundDisplayMsgs.getString(\"sendingMetaInformation\") + \" \");\r\n        _sEmailText += _resBundDisplayMsgs.getString(\"sendingMetaInformation\") + \" \";\r\n        pub_status = \"sendingMetaInformation\";\r\n        if (paramProtoObj.recv_msg(msg) != NDTConstants.PROTOCOL_MSG_READ_SUCCESS) {\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"protocolError\") + parseMsgBodyToInt(new String(msg.getBody()), 16) + \" instead\\n\";\r\n            return true;\r\n        }\r\n        if (msg.getType() != MessageType.TEST_PREPARE) {\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"metaWrongMessage\") + \"\\n\";\r\n            if (msg.getType() == MessageType.MSG_ERROR) {\r\n                _sErrMsg += \"ERROR MSG: \" + parseMsgBodyToInt(new String(msg.getBody()), 16) + \"\\n\";\r\n            }\r\n            return true;\r\n        }\r\n        if (paramProtoObj.recv_msg(msg) != NDTConstants.PROTOCOL_MSG_READ_SUCCESS) {\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"protocolError\") + parseMsgBodyToInt(new String(msg.getBody()), 16) + \" instead\\n\";\r\n            return true;\r\n        }\r\n        if (msg.getType() != MessageType.TEST_START) {\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"metaWrongMessage\") + \"\\n\";\r\n            if (msg.getType() == MessageType.MSG_ERROR) {\r\n                _sErrMsg += \"ERROR MSG: \" + parseMsgBodyToInt(new String(msg.getBody()), 16) + \"\\n\";\r\n            }\r\n            return true;\r\n        }\r\n        _log.warn(\"USERAGENT \" + getUserAgent());\r\n        paramProtoObj.send_json_msg(MessageType.TEST_MSG, (NDTConstants.META_CLIENT_OS + \":\" + \"Linux\").getBytes());\r\n        paramProtoObj.send_json_msg(MessageType.TEST_MSG, (NDTConstants.META_BROWSER_OS + \":\" + UserAgentTools.getBrowser(getUserAgent())[2]).getBytes());\r\n        paramProtoObj.send_json_msg(MessageType.TEST_MSG, (NDTConstants.META_CLIENT_KERNEL_VERSION + \":\" + \"4.15.0-38-generic\").getBytes());\r\n        paramProtoObj.send_json_msg(MessageType.TEST_MSG, (NDTConstants.META_CLIENT_VERSION + \":\" + NDTConstants.VERSION).getBytes());\r\n        paramProtoObj.send_json_msg(MessageType.TEST_MSG, (NDTConstants.META_CLIENT_APPLICATION + \":\" + application).getBytes());\r\n        paramProtoObj.send_json_msg(MessageType.TEST_MSG, new byte[0]);\r\n        if (paramProtoObj.recv_msg(msg) != NDTConstants.PROTOCOL_MSG_READ_SUCCESS) {\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"protocolError\") + parseMsgBodyToInt(new String(msg.getBody()), 16) + \" instead\\n\";\r\n            return true;\r\n        }\r\n        if (msg.getType() != MessageType.TEST_FINALIZE) {\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"metaWrongMessage\");\r\n            if (msg.getType() == MessageType.MSG_ERROR) {\r\n                _sErrMsg += \"ERROR MSG: \" + parseMsgBodyToInt(new String(msg.getBody()), 16) + \"\\n\";\r\n            }\r\n            return true;\r\n        }\r\n        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"done\") + \"\\n\");\r\n        _txtStatistics.append(_resBundDisplayMsgs.getString(\"done\") + \"\\n\");\r\n        _sEmailText += _resBundDisplayMsgs.getString(\"done\") + \"\\n\
	";\r\n    }\r\n    pub_status = \"done\";\r\n    return false;\r\n}"
}, {
	"Path": "edu.internet2.ndt.Tcpbw100.dottcp",
	"Comment": "method to run tests and interpret the results sent by the server",
	"Method": "void dottcp(StatusPanel sPanel){\r\n    Socket ctlSocket = null;\r\n    if (!_bIsApplication) {\r\n        String sTestingServer = getParameter(\"testingServer\");\r\n        if (sTestingServer == null) {\r\n            sTestingServer = getCodeBase().getHost();\r\n        }\r\n        setsHostName(sTestingServer);\r\n        pub_host = sHostName;\r\n    }\r\n    int ctlport = _useSSL ? NDTConstants.CONTROL_PORT_SSL : NDTConstants.CONTROL_PORT_DEFAULT;\r\n    int i, wait;\r\n    int iServerWaitFlag = 0;\r\n    _bFailed = false;\r\n    try {\r\n        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"connectingTo\") + \" '\" + sHostName + \"' [\" + hostAddress + \"] \" + _resBundDisplayMsgs.getString(\"toRunTest\") + \"\\n\");\r\n        ctlSocket = newSocket(hostAddress, ctlport);\r\n    } catch (UnknownHostException e) {\r\n        _log.warn(\"Don't know about host: \" + sHostName, e);\r\n        _sErrMsg = _resBundDisplayMsgs.getString(\"unknownServer\") + \"\\n\";\r\n        _bFailed = true;\r\n        return;\r\n    } catch (IOException e) {\r\n        _log.warn(\"Couldn't get the connection to: \" + sHostName + \" \" + ctlport, e);\r\n        _sErrMsg = _resBundDisplayMsgs.getString(\"serverNotRunning\") + \" (\" + sHostName + \":\" + ctlport + \")\\n\";\r\n        _bFailed = true;\r\n        return;\r\n    }\r\n    Protocol protocolObj = new Protocol(ctlSocket);\r\n    Message msg = new Message();\r\n    if (ctlSocket.getInetAddress() instanceof Inet6Address) {\r\n        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"connected\") + \" \" + sHostName + _resBundDisplayMsgs.getString(\"usingIpv6\") + \"\\n\");\r\n    } else {\r\n        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"connected\") + \" \" + sHostName + _resBundDisplayMsgs.getString(\"usingIpv4\") + \"\\n\");\r\n    }\r\n    byte[] send = new byte[NDTConstants.VERSION.length() + 1];\r\n    send[0] = _yTests;\r\n    System.arraycopy(NDTConstants.VERSION.getBytes(), 0, send, 1, NDTConstants.VERSION.length());\r\n    protocolObj.send_json_msg(MessageType.MSG_EXTENDED_LOGIN, send);\r\n    if (protocolObj.readn(msg, 13) != 13) {\r\n        _sErrMsg = _resBundDisplayMsgs.getString(\"unsupportedClient\") + \"\\n\";\r\n        _bFailed = true;\r\n        try {\r\n            ctlSocket.close();\r\n        } catch (IOException ioe) {\r\n        }\r\n        return;\r\n    }\r\n    for (; ; ) {\r\n        if (protocolObj.recv_msg(msg) != NDTConstants.PROTOCOL_MSG_READ_SUCCESS) {\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"protocolError\") + parseMsgBodyToInt(new String(msg.getBody()), 16) + \" instead\\n\";\r\n            _bFailed = true;\r\n            return;\r\n        }\r\n        if (msg.getType() != MessageType.SRV_QUEUE) {\r\n            if (!retry && !new String(msg.getBody()).equals(\"Invalid login message.\")) {\r\n                jsonSupport = false;\r\n                retry = true;\r\n                try {\r\n                    _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"unsupportedMsgExtendedLogin\") + \"\\n\");\r\n                    if (ctlSocket != null) {\r\n                        try {\r\n                            ctlSocket.close();\r\n                        } catch (IOException ioe) {\r\n                        }\r\n                    }\r\n                    ctlSocket = newSocket(hostAddress, ctlport);\r\n                } catch (UnknownHostException e) {\r\n                    _log.warn(\"Don't know about host: \" + sHostName, e);\r\n                    _sErrMsg = _resBundDisplayMsgs.getString(\"unknownServer\") + \"\\n\";\r\n                    _bFailed = true;\r\n                    return;\r\n                } catch (IOException e) {\r\n                    _log.warn(\"Couldn't get the connection to: \" + sHostName + \" \" + ctlport, e);\r\n                    _sErrMsg = _resBundDisplayMsgs.getString(\"serverNotRunning\") + \" (\" + sHostName + \":\" + ctlport + \")\\n\";\r\n                    _bFailed = true;\r\n                    return;\r\n                }\r\n                protocolObj = new Protocol(ctlSocket);\r\n                protocolObj.setJsonSupport(false);\r\n                if (ctlSocket.getInetAddress() instanceof Inet6Address) {\r\n                    _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"connected\") + \" \" + sHostName + _resBundDisplayMsgs.getString(\"usingIpv6\") + \"\\n\");\r\n                } else {\r\n                    _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"connected\") + \" \" + sHostName + _resBundDisplayMsgs.getString(\"usingIpv4\") + \"\\n\");\r\n                }\r\n                protocolObj.send_msg(MessageType.MSG_LOGIN, _yTests);\r\n                if (protocolObj.readn(msg, 13) != 13) {\r\n                    _sErrMsg = _resBundDisplayMsgs.getString(\"unsupportedClient\") + \"\\n\";\r\n                    _bFailed = true;\r\n                    return;\r\n                }\r\n                continue;\r\n            } else {\r\n                _sErrMsg = _resBundDisplayMsgs.getString(\"loggingWrongMessage\") + \"\\n\";\r\n                _bFailed = true;\r\n                return;\r\n            }\r\n        }\r\n        String tmpstr3 = new String(msg.getBody());\r\n        wait = parseMsgBodyToInt(tmpstr3);\r\n        _log.warn(\"wait flag received = \" + wait);\r\n        if (wait == NDTConstants.SRV_QUEUE_TEST_STARTS_NOW) {\r\n            break;\r\n        }\r\n        if (wait == NDTConstants.SRV_QUEUE_SERVER_FAULT) {\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"serverFault\") + \"\\n\";\r\n            _bFailed = true;\r\n            return;\r\n        }\r\n        if (wait == NDTConstants.SRV_QUEUE_SERVER_BUSY) {\r\n            if (iServerWaitFlag == 0) {\r\n                _sErrMsg = _resBundDisplayMsgs.getString(\"serverBusy\") + \"\\n\";\r\n                _bFailed = true;\r\n                return;\r\n            } else {\r\n                _sErrMsg = _resBundDisplayMsgs.getString(\"serverFault\") + \"\\n\";\r\n                _bFailed = true;\r\n                return;\r\n            }\r\n        }\r\n        if (wait == NDTConstants.SRV_QUEUE_SERVER_BUSY_60s) {\r\n            _sErrMsg = _resBundDisplayMsgs.getString(\"serverBusy60s\") + \"\\n\";\r\n            _bFailed = true;\r\n            return;\r\n        }\r\n        if (wait == NDTConstants.SRV_QUEUE_HEARTBEAT) {\r\n            protocolObj.send_json_msg(MessageType.MSG_WAITING, _yTests);\r\n            continue;\r\n        }\r\n        wait = (wait * 60);\r\n        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"otherClient\") + wait + _resBundDisplayMsgs.getString(\"seconds\") + \".\\n\");\r\n        iServerWaitFlag = 1;\r\n    }\r\n    if (protocolObj.recv_msg(msg) != NDTConstants.PROTOCOL_MSG_READ_SUCCESS) {\r\n        _sErrMsg = _resBundDisplayMsgs.getString(\"protocolError\") + parseMsgBodyToInt(new String(msg.getBody()), 16) + \" instead\\n\";\r\n        _bFailed = true;\r\n        return;\r\n    }\r\n    if (msg.getType() != MessageType.MSG_LOGIN) {\r\n        _sErrMsg = _resBundDisplayMsgs.getString(\"versionWrongMessage\") + \"\\n\";\r\n        _bFailed = true;\r\n        return;\r\n    }\r\n    String vVersion;\r\n    if (jsonSupport) {\r\n        vVersion = JSONUtils.getSingleMessage(new String(msg.getBody()));\r\n    } else {\r\n        vVersion = new String(msg.getBody());\r\n    }\r\n    if (!vVersion.startsWith(\"v\")) {\r\n        _sErrMsg = _resBundDisplayMsgs.getString(\"incompatibleVersion\");\r\n        _bFailed = true;\r\n        return;\r\n    }\r\n    _log.warn(\"Server version: \" + vVersion.substring(1));\r\n    if (vVersion.endsWith(\"Web10G\") || vVersion.endsWith(\"Web100\")) {\r\n        if (!vVersion.substring(1, vVersion.lastIndexOf('-')).equals(NDTConstants.VERSION)) {\r\n            _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"diffrentVersion\") + \" (\" + vVersion.substring(1, vVersion.lastIndexOf('-')) + \")\\n\");\r\n            _log.warn(\"WARNING: NDT server has different version number (\" + vVersion.substring(1) + \")\");\r\n        }\r\n    } else if (!vVersion.substring(1).equals(NDTConstants.VERSION)) {\r\n        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"diffrentVersion\") + \" (\" + vVersion.substring(1) + \")\\n\");\r\n        _log.warn(\"WARNING: NDT server has different version number (\" + vVersion.substring(1) + \")\");\r\n    }\r\n    _sServerType = vVersion.endsWith(\"Web10G\") ? \"web10g\" : \"web100\";\r\n    createDiagnoseWindow();\r\n    createStatsWindow();\r\n    _frameWeb100Vars.toBack();\r\n    _frameDetailedStats.toBack();\r\n    if (protocolObj.recv_msg(msg) != NDTConstants.PROTOCOL_MSG_READ_SUCCESS) {\r\n        _sErrMsg = _resBundDisplayMsgs.getString(\"protocolError\") + parseMsgBodyToInt(new String(msg.getBody()), 16) + \" instead\\n\";\r\n        _bFailed = true;\r\n        return;\r\n    }\r\n    if (msg.getType() != MessageType.MSG_LOGIN) {\r\n        _sErrMsg = _resBundDisplayMsgs.getString(\"testsuiteWrongMessage\") + \"\\n\";\r\n        _bFailed = true;\r\n        return;\r\n    }\r\n    String tmpstr;\r\n    if (jsonSupport) {\r\n        tmpstr = JSONUtils.getSingleMessage(new String(msg.getBody()));\r\n    } else {\r\n        tmpstr = new String(msg.getBody());\r\n    }\r\n    StringTokenizer tokenizer = new StringTokenizer(tmpstr, \" \");\r\n    while (tokenizer.hasMoreTokens()) {\r\n        try {\r\n            if (sPanel.wantToStop()) {\r\n                protocolObj.send_json_msg(MessageType.MSG_ERROR, \"Manually stopped by the user\".getBytes());\r\n                protocolObj.close();\r\n                ctlSocket.close();\r\n                _sErrMsg = \"\\n\" + _resBundDisplayMsgs.getString(\"stopped\") + \"\\n\";\r\n                _bFailed = true;\r\n                _log.warn(_sErrMsg);\r\n                return;\r\n            }\r\n            int testId = Integer.parseInt(tokenizer.nextToken());\r\n            switch(testId) {\r\n                case NDTConstants.TEST_MID:\r\n                    sPanel.setText(_resBundDisplayMsgs.getString(\"middlebox\"));\r\n                    if (test_mid(protocolObj)) {\r\n                        _resultsTxtPane.append(_sErrMsg);\r\n                        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"middleboxFail2\") + \"\\n\");\r\n                        _yTests &= (~NDTConstants.TEST_MID);\r\n                    }\r\n                    break;\r\n                case NDTConstants.TEST_SFW:\r\n                    sPanel.setText(_resBundDisplayMsgs.getString(\"simpleFirewall\"));\r\n                    if (test_sfw(protocolObj)) {\r\n                        _resultsTxtPane.append(_sErrMsg);\r\n                        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"sfwFail\") + \"\\n\");\r\n                        _yTests &= (~NDTConstants.TEST_SFW);\r\n                    }\r\n                    break;\r\n                case NDTConstants.TEST_C2S:\r\n                    sPanel.setText(_resBundDisplayMsgs.getString(\"c2sThroughput\"));\r\n                    if (test_c2s(protocolObj)) {\r\n                        _resultsTxtPane.append(_sErrMsg);\r\n                        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"c2sThroughputFailed\") + \"\\n\");\r\n                        _yTests &= (~NDTConstants.TEST_C2S);\r\n                    }\r\n                    break;\r\n                case NDTConstants.TEST_S2C:\r\n                    sPanel.setText(_resBundDisplayMsgs.getString(\"s2cThroughput\"));\r\n                    if (test_s2c(protocolObj, ctlSocket)) {\r\n                        _resultsTxtPane.append(_sErrMsg);\r\n                        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"s2cThroughputFailed\") + \"\\n\");\r\n                        _yTests &= (~NDTConstants.TEST_S2C);\r\n                    }\r\n                    break;\r\n                case NDTConstants.TEST_META:\r\n                    sPanel.setText(_resBundDisplayMsgs.getString(\"meta\"));\r\n                    if (test_meta(protocolObj, _sClient)) {\r\n                        _resultsTxtPane.append(_sErrMsg);\r\n                        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"metaFailed\") + \"\\n\");\r\n                        _yTests &= (~NDTConstants.TEST_META);\r\n                    }\r\n                    break;\r\n                default:\r\n                    _sErrMsg = _resBundDisplayMsgs.getString(\"unknownID\") + \"\\n\";\r\n                    _bFailed = true;\r\n                    return;\r\n            }\r\n        } catch (NumberFormatException nfe) {\r\n            _log.warn(\"nfe\", nfe);\r\n        }\r\n    }\r\n    if (sPanel.wantToStop()) {\r\n        protocolObj.send_json_msg(MessageType.MSG_ERROR, \"Manually stopped by the user\".getBytes());\r\n        protocolObj.close();\r\n        ctlSocket.close();\r\n        _sErrMsg = _resBundDisplayMsgs.getString(\"stopped\") + \"\\n\";\r\n        _bFailed = true;\r\n        _log.warn(_sErrMsg);\r\n        return;\r\n    }\r\n    sPanel.setText(_resBundDisplayMsgs.getString(\"receiving\"));\r\n    i = 0;\r\n    try {\r\n        for (; ; ) {\r\n            if (protocolObj.recv_msg(msg) != NDTConstants.PROTOCOL_MSG_READ_SUCCESS) {\r\n                _sErrMsg = _resBundDisplayMsgs.getString(\"protocolError\") + parseMsgBodyToInt(new String(msg.getBody()), 16) + \" instead\\n\";\r\n                _bFailed = true;\r\n                return;\r\n            }\r\n            if (msg.getType() == MessageType.MSG_LOGOUT) {\r\n                break;\r\n            }\r\n            if (msg.getType() != MessageType.MSG_RESULTS) {\r\n                _sErrMsg = _resBundDisplayMsgs.getString(\"resultsWrongMessage\") + \"\\n\";\r\n                _bFailed = true;\r\n                return;\r\n            }\r\n            if (jsonSupport) {\r\n                _sTestResults += JSONUtils.getSingleMessage(new String(msg.getBody()));\r\n            } else {\r\n                _sTestResults += new String(msg.getBody());\r\n            }\r\n            i++;\r\n        }\r\n    } catch (IOException e) {\r\n        _log.warn(\"Couldn't complete tests while waiting for MSG_LOGOUT/MSG_RESULTS for \" + sHostName, e);\r\n        _sErrMsg = \"Couldn't complete tests while waiting for MSG_LOGOUT/MSG_RESULTS for \" + sHostName + \")\\n\";\r\n        _bFailed = true;\r\n        return;\r\n    }\r\n    if (i == 0) {\r\n        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"resultsTimeout\") + \"\\n\");\r\n    }\r\n    _log.warn(\"Calling InetAddress.getLocalHost() twice\");\r\n    try {\r\n        _txtDiagnosis.append(_resBundDisplayMsgs.getString(\"client\") + \": \" + InetAddress.getLocalHost() + \"\\n\");\r\n    } catch (SecurityException e) {\r\n        _txtDiagnosis.append(_resBundDisplayMsgs.getString(\"client\") + \": 127.0.0.1\\n\");\r\n        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"unableToObtainIP\") + \"\\n\");\r\n        _log.warn(\"Unable to obtain local IP address: using 127.0.0.1\", e);\r\n    }\r\n    try {\r\n        _sEmailText += _resBundDisplayMsgs.getString(\"client\") + \": \" + InetAddress.getLocalHost() + \"\\n\
	";\r\n    } catch (SecurityException e) {\r\n        _sEmailText += _resBundDisplayMsgs.getString(\"client\") + \": \" + \"127.0.0.1\" + \"\\n\
	";\r\n    }\r\n    protocolObj.close();\r\n    ctlSocket.close();\r\n    try {\r\n        testResults(_sTestResults);\r\n    } catch (Exception ex) {\r\n        _resultsTxtPane.append(_resBundDisplayMsgs.getString(\"resultsParseError\") + \"\\n\");\r\n        _resultsTxtPane.append(ex + \"\\n\");\r\n    }\r\n    if ((_yTests & NDTConstants.TEST_MID) == NDTConstants.TEST_MID) {\r\n        middleboxResults(_sMidBoxTestResult);\r\n    }\r\n    pub_isReady = \"yes\";\r\n    pub_errmsg = \"All tests completed OK.\";\r\n    pub_status = \"done\";\r\n}"
}, {
	"Path": "com.netflix.hollow.api.producer.validation.ValidationStatus.passed",
	"Comment": "returns true if all validation results have passed, otherwise false if one or more resultsfailed or a validator was erroneous.",
	"Method": "boolean passed(){\r\n    return passed;\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.DBHistory.lookupReply",
	"Comment": "receive a lookup reply from the peer, where they gave us the specified info",
	"Method": "void lookupReply(int newPeers,int oldPeers,int invalid,int duplicate){\r\n    if (invalid > 0) {\r\n        _invalidReplyRate.addData(invalid);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.data.Lease.getGateway",
	"Comment": "retrieve the router at which the destination can be contacted",
	"Method": "Hash getGateway(){\r\n    return _gateway;\r\n}"
}, {
	"Path": "org.klomp.snark.comments.CommentSet.removeMyOldRatings",
	"Comment": "remove all ratings of mine with empty comments, except the id specified.",
	"Method": "void removeMyOldRatings(int exceptID){\r\n    for (List<Comment> l : map.values()) {\r\n        for (Comment c : l) {\r\n            if (c.isMine() && c.getText() == null && c.getID() != exceptID && !c.isHidden()) {\r\n                removeStats(c);\r\n                c.setHidden();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.ui.TunnelConfig.setDestination",
	"Comment": "this is easier than requiring tunnelconfig to talk totunnelcontrollergroup and tunnelcontroller.",
	"Method": "void setDestination(Destination dest){\r\n    _dest = dest;\r\n}"
}, {
	"Path": "com.netflix.hollow.core.util.HollowWriteStateCreator.readSchemaFileIntoWriteState",
	"Comment": "reads a schema file into the provided hollowwritestateengine. the schema file must be on the classpath.",
	"Method": "void readSchemaFileIntoWriteState(String schemaFilePath,HollowWriteStateEngine engine){\r\n    InputStream input = null;\r\n    try {\r\n        input = HollowWriteStateCreator.class.getClassLoader().getResourceAsStream(schemaFilePath);\r\n        Collection<HollowSchema> schemas = HollowSchemaParser.parseCollectionOfSchemas(new BufferedReader(new InputStreamReader(input)));\r\n        populateStateEngineWithTypeWriteStates(engine, schemas);\r\n    } finally {\r\n        if (input != null) {\r\n            input.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.zxing.common.BitArray.isRange",
	"Comment": "efficient method to check if a range of bits is set, or not set.",
	"Method": "boolean isRange(int start,int end,boolean value){\r\n    if (end < start || start < 0 || end > size) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (end == start) {\r\n        return true;\r\n    }\r\n    end--;\r\n    int firstInt = start / 32;\r\n    int lastInt = end / 32;\r\n    for (int i = firstInt; i <= lastInt; i++) {\r\n        int firstBit = i > firstInt ? 0 : start & 0x1F;\r\n        int lastBit = i < lastInt ? 31 : end & 0x1F;\r\n        int mask = (2 << lastBit) - (1 << firstBit);\r\n        if ((bits[i] & mask) != (value ? mask : 0)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.klomp.snark.web.FetchAndAdd.add",
	"Comment": "tell snarkmanager to copy the torrent file over and add it to the snarks list. this snark may then be deleted.",
	"Method": "void add(File file){\r\n    _mgr.addMessageNoEscape(_t(\"Torrent fetched from {0}\", urlify(_url)));\r\n    FileInputStream in = null;\r\n    try {\r\n        in = new FileInputStream(file);\r\n        byte[] fileInfoHash = new byte[20];\r\n        String name = MetaInfo.getNameAndInfoHash(in, fileInfoHash);\r\n        try {\r\n            in.close();\r\n        } catch (IOException ioe) {\r\n        }\r\n        Snark snark = _mgr.getTorrentByInfoHash(fileInfoHash);\r\n        if (snark != null) {\r\n            _mgr.addMessage(_t(\"Torrent with this info hash is already running: {0}\", snark.getBaseName()));\r\n            return;\r\n        }\r\n        String originalName = Storage.filterName(name);\r\n        name = originalName + \".torrent\";\r\n        File torrentFile = new File(_mgr.getDataDir(), name);\r\n        String canonical = torrentFile.getCanonicalPath();\r\n        if (torrentFile.exists()) {\r\n            if (_mgr.getTorrent(canonical) != null)\r\n                _mgr.addMessage(_t(\"Torrent already running: {0}\", name));\r\n            else\r\n                _mgr.addMessage(_t(\"Torrent already in the queue: {0}\", name));\r\n        } else {\r\n            _mgr.copyAndAddTorrent(file, canonical, _dataDir);\r\n            snark = _mgr.getTorrentByBaseName(originalName);\r\n            if (snark != null)\r\n                snark.startTorrent();\r\n            else\r\n                throw new IOException(\"Unknown error - check logs\");\r\n        }\r\n    } catch (IOException ioe) {\r\n        _mgr.addMessageNoEscape(_t(\"Torrent at {0} was not valid\", urlify(_url)) + \": \" + DataHelper.stripHTML(ioe.getMessage()));\r\n    } catch (OutOfMemoryError oom) {\r\n        _mgr.addMessageNoEscape(_t(\"ERROR - Out of memory, cannot create torrent from {0}\", urlify(_url)) + \": \" + DataHelper.stripHTML(oom.getMessage()));\r\n    } finally {\r\n        try {\r\n            if (in != null)\r\n                in.close();\r\n        } catch (IOException ioe) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.spotify.heroic.async.AsyncObserver.bind",
	"Comment": "bind a given future as an observeable. it can also be considered as converting a future intoan observable.the end states of the observable will be passed on to the future.",
	"Method": "AsyncObserver<T> bind(ResolvableFuture<Void> future,Function<T, AsyncFuture<Void>> transform){\r\n    return new AsyncObserver<T>() {\r\n        @Override\r\n        public AsyncFuture<Void> observe(T value) {\r\n            return transform.apply(value);\r\n        }\r\n        @Override\r\n        public void cancel() {\r\n            future.cancel();\r\n        }\r\n        @Override\r\n        public void fail(Throwable cause) {\r\n            future.fail(cause);\r\n        }\r\n        @Override\r\n        public void end() {\r\n            future.resolve(null);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.spotify.heroic.async.AsyncObserver.bind",
	"Comment": "bind a given future as an observeable. it can also be considered as converting a future intoan observable.the end states of the observable will be passed on to the future.",
	"Method": "AsyncObserver<T> bind(ResolvableFuture<Void> future,Function<T, AsyncFuture<Void>> transform){\r\n    return transform.apply(value);\r\n}"
}, {
	"Path": "com.spotify.heroic.async.AsyncObserver.bind",
	"Comment": "bind a given future as an observeable. it can also be considered as converting a future intoan observable.the end states of the observable will be passed on to the future.",
	"Method": "AsyncObserver<T> bind(ResolvableFuture<Void> future,Function<T, AsyncFuture<Void>> transform){\r\n    future.cancel();\r\n}"
}, {
	"Path": "com.spotify.heroic.async.AsyncObserver.bind",
	"Comment": "bind a given future as an observeable. it can also be considered as converting a future intoan observable.the end states of the observable will be passed on to the future.",
	"Method": "AsyncObserver<T> bind(ResolvableFuture<Void> future,Function<T, AsyncFuture<Void>> transform){\r\n    future.fail(cause);\r\n}"
}, {
	"Path": "com.spotify.heroic.async.AsyncObserver.bind",
	"Comment": "bind a given future as an observeable. it can also be considered as converting a future intoan observable.the end states of the observable will be passed on to the future.",
	"Method": "AsyncObserver<T> bind(ResolvableFuture<Void> future,Function<T, AsyncFuture<Void>> transform){\r\n    future.resolve(null);\r\n}"
}, {
	"Path": "i2p.susi.webmail.WebMail.button2",
	"Comment": "returns html string of a disabled form button with name and label",
	"Method": "String button2(String name,String label){\r\n    return \"<input type=\\\"submit\\\" name=\\\"\" + name + \"\\\" value=\\\"\" + label + \"\\\" disabled>\";\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.DBHistory.lookupFailed",
	"Comment": "note that the peer failed to respond to the db lookup in any way",
	"Method": "void lookupFailed(){\r\n    _failedLookupRate.addData(1);\r\n    _context.statManager().addRateData(\"peer.failedLookupRate\", 1);\r\n    _lastLookupFailed = _context.clock().now();\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.settings.IgnoreSettings.isAddUnversionedFiles",
	"Comment": "check if suggesting of adding unversioned files to the .gitignore file is enabled.",
	"Method": "boolean isAddUnversionedFiles(){\r\n    return addUnversionedFiles;\r\n}"
}, {
	"Path": "net.i2p.data.i2cp.I2CPMessageImpl.writeMessage",
	"Comment": "write out the full message to the stream, including the 4 byte size and 1 byte type header.",
	"Method": "void writeMessage(OutputStream out){\r\n    byte[] data = doWriteMessage();\r\n    try {\r\n        DataHelper.writeLong(out, 4, data.length);\r\n        out.write((byte) getType());\r\n    } catch (DataFormatException dfe) {\r\n        throw new I2CPMessageException(\"Unable to write the message length or type\", dfe);\r\n    }\r\n    out.write(data);\r\n}"
}, {
	"Path": "com.netflix.hollow.core.index.HollowSparseIntegerSet.size",
	"Comment": "estimate the total number of bits used to represent the integer set.",
	"Method": "long size(){\r\n    SparseBitSet current;\r\n    long size;\r\n    do {\r\n        current = sparseBitSetVolatile;\r\n        size = current.estimateBitsUsed();\r\n    } while (current != sparseBitSetVolatile);\r\n    return size;\r\n}"
}, {
	"Path": "org.jrobin.core.Util.getLapTime",
	"Comment": "function used for debugging purposes and performance bottlenecks detection.\tprobably of no use for end users of jrobin.",
	"Method": "String getLapTime(){\r\n    final long newLap = System.currentTimeMillis();\r\n    final double seconds = (newLap - lastLap) / 1000.0;\r\n    lastLap = newLap;\r\n    return \"[\" + seconds + \" sec]\";\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.TunnelHistory.getLastRejectedBandwidth",
	"Comment": "when the peer last refused to participate in a tunnel complaining of bandwidth overload",
	"Method": "long getLastRejectedBandwidth(){\r\n    return _lastRejectedBandwidth;\r\n}"
}, {
	"Path": "io.helidon.security.jwt.JwtUtil.getStrings",
	"Comment": "extract a key value from json object that is a list of strings if present.",
	"Method": "Optional<List<String>> getStrings(JsonObject json,String key){\r\n    return Optional.ofNullable(json.getJsonArray(key)).map(it -> {\r\n        try {\r\n            return it.stream().map(it2 -> ((JsonString) it2).getString()).collect(Collectors.toList());\r\n        } catch (Exception e) {\r\n            throw new JwtException(\"Invalid value. Expecting a string array for key \" + key);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.netflix.hollow.core.write.HollowObjectWriteRecord.getFieldBuffer",
	"Comment": "returns the buffer which should be used to serialize the data for the field at the given position in the schema.this is used by the fastblobframeworkserializer when writing the data for a specific field.",
	"Method": "ByteDataBuffer getFieldBuffer(int fieldPosition){\r\n    isNonNull[fieldPosition] = true;\r\n    fieldData[fieldPosition].reset();\r\n    return fieldData[fieldPosition];\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.ConsolidationFunctionType.get",
	"Comment": "returns a consolidationfunctiontype with the given name.",
	"Method": "ConsolidationFunctionType get(String s){\r\n    if (STR_AVERAGE.equalsIgnoreCase(s)) {\r\n        return AVERAGE;\r\n    } else if (STR_MIN.equalsIgnoreCase(s)) {\r\n        return MIN;\r\n    } else if (STR_MAX.equalsIgnoreCase(s)) {\r\n        return MAX;\r\n    } else if (STR_LAST.equalsIgnoreCase(s)) {\r\n        return LAST;\r\n    } else {\r\n        throw new IllegalArgumentException(\"Invalid ConsolidationFunctionType: \" + s);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.client.ClientListenerRunner.getServerSocket",
	"Comment": "get a serversocket.split out so it can be overridden for ssl.",
	"Method": "ServerSocket getServerSocket(){\r\n    if (_bindAllInterfaces) {\r\n        if (_log.shouldLog(Log.INFO))\r\n            _log.info(\"Listening on port \" + _port + \" on all interfaces\");\r\n        return new ServerSocket(_port);\r\n    } else {\r\n        String listenInterface = _context.getProperty(ClientManagerFacadeImpl.PROP_CLIENT_HOST, ClientManagerFacadeImpl.DEFAULT_HOST);\r\n        if (_log.shouldLog(Log.INFO))\r\n            _log.info(\"Listening on port \" + _port + \" of the specific interface: \" + listenInterface);\r\n        return new ServerSocket(_port, 0, InetAddress.getByName(listenInterface));\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.transport.TransportImpl.getNextMessage",
	"Comment": "nonblocking call to pull the next outbound messageoff the queue.only used by ntcp. ssu does not call.",
	"Method": "OutNetMessage getNextMessage(){\r\n    OutNetMessage msg = _sendPool.poll();\r\n    if (msg != null)\r\n        msg.beginSend();\r\n    return msg;\r\n}"
}, {
	"Path": "com.spotify.heroic.metrics.EWMA.fifteenMinuteEWMA",
	"Comment": "creates a new ewma which is equivalent to the unix fifteen minute load average and whichexpects to be ticked every 5 seconds.",
	"Method": "EWMA fifteenMinuteEWMA(){\r\n    return new EWMA(M15_ALPHA, INTERVAL, TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "net.i2p.stat.Rate.equals",
	"Comment": "this is used in statsummarizer and summarylistener.we base it on the stat we are tracking, not the stored data.",
	"Method": "boolean equals(Object obj){\r\n    if ((obj == null) || !(obj instanceof Rate))\r\n        return false;\r\n    if (obj == this)\r\n        return true;\r\n    Rate r = (Rate) obj;\r\n    if (_period != r.getPeriod() || _creationDate != r.getCreationDate())\r\n        return false;\r\n    if (_stat == null && r._stat == null)\r\n        return true;\r\n    if (_stat != null && r._stat != null)\r\n        return _stat.nameGroupDescEquals(r._stat);\r\n    return false;\r\n}"
}, {
	"Path": "io.helidon.webserver.WebServer.create",
	"Comment": "creates new instance form provided routing and default configuration.",
	"Method": "WebServer create(io.helidon.common.Builder<? extends ServerConfiguration> configurationBuilder,Routing routing,WebServer create,io.helidon.common.Builder<? extends ServerConfiguration> configurationBuilder,io.helidon.common.Builder<? extends Routing> routingBuilder,WebServer create,ServerConfiguration configuration,io.helidon.common.Builder<? extends Routing> routingBuilder,WebServer create,Routing routing,WebServer create,ServerConfiguration configuration,Routing routing,WebServer create,io.helidon.common.Builder<? extends Routing> routingBuilder){\r\n    Objects.requireNonNull(routingBuilder, \"Parameter 'routingBuilder' must not be null!\");\r\n    return create(routingBuilder.build());\r\n}"
}, {
	"Path": "net.i2p.stat.Rate.getLifetimeEventSaturation",
	"Comment": "during the lifetime of this stat, how much of the time was spent actually processing events in proportion to how many events could have occurred if there were no intervals?",
	"Method": "double getLifetimeEventSaturation(){\r\n    if ((_lastEventCount > 0) && (_lifetimeTotalEventTime > 0)) {\r\n        double eventTime = (double) _lifetimeTotalEventTime / (double) _lifetimeEventCount;\r\n        double maxEvents = _period / eventTime;\r\n        double numPeriods = getLifetimePeriods();\r\n        double avgEventsPerPeriod = _lifetimeEventCount / numPeriods;\r\n        return avgEventsPerPeriod / maxEvents;\r\n    }\r\n    return 0.0D;\r\n}"
}, {
	"Path": "com.spotify.heroic.common.Features.withFeature",
	"Comment": "run the given operation if feature is set, or another operation if it is not.",
	"Method": "T withFeature(Feature feature,Supplier<T> isSet,Supplier<T> isNotSet){\r\n    return hasFeature(feature) ? isSet.get() : isNotSet.get();\r\n}"
}, {
	"Path": "io.helidon.security.Security.createContext",
	"Comment": "create a new security context with the defined id and all defaults.",
	"Method": "SecurityContext createContext(String id){\r\n    return contextBuilder(id).build();\r\n}"
}, {
	"Path": "net.i2p.util.SimpleScheduler.stop",
	"Comment": "stops the simplescheduler.subsequent executions should not throw a rejectedexecutionexception.",
	"Method": "void stop(){\r\n    _executor.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());\r\n    _executor.shutdownNow();\r\n}"
}, {
	"Path": "net.i2p.data.LeaseSet2.hashCode",
	"Comment": "the destination has enough randomness in it to use it by itself for speed",
	"Method": "int hashCode(){\r\n    if (_destination == null)\r\n        return 0;\r\n    return _destination.hashCode();\r\n}"
}, {
	"Path": "net.i2p.router.message.GarlicMessageBuilder.buildMessage",
	"Comment": "used by testjob and directly above and for encrypting databaselookupmessages",
	"Method": "GarlicMessage buildMessage(RouterContext ctx,GarlicConfig config,GarlicMessage buildMessage,RouterContext ctx,GarlicConfig config,SessionKey wrappedKey,Set<SessionTag> wrappedTags,SessionKeyManager skm,GarlicMessage buildMessage,RouterContext ctx,GarlicConfig config,SessionKey wrappedKey,Set<SessionTag> wrappedTags,int numTagsToDeliver,SessionKeyManager skm,GarlicMessage buildMessage,RouterContext ctx,GarlicConfig config,SessionKey wrappedKey,Set<SessionTag> wrappedTags,int numTagsToDeliver,int lowTagsThreshold,SessionKeyManager skm,GarlicMessage buildMessage,RouterContext ctx,GarlicConfig config,SessionKey wrappedKey,Set<SessionTag> wrappedTags,PublicKey target,SessionKey encryptKey,SessionTag encryptTag){\r\n    Log log = ctx.logManager().getLog(GarlicMessageBuilder.class);\r\n    if (config == null)\r\n        throw new IllegalArgumentException(\"Null config specified\");\r\n    GarlicMessage msg = new GarlicMessage(ctx);\r\n    byte[] cloveSet = buildCloveSet(ctx, config);\r\n    byte[] encData = ctx.elGamalAESEngine().encrypt(cloveSet, target, encryptKey, wrappedTags, encryptTag, 128);\r\n    msg.setData(encData);\r\n    msg.setMessageExpiration(config.getExpiration());\r\n    long timeFromNow = config.getExpiration() - ctx.clock().now();\r\n    if (timeFromNow < 1 * 1000) {\r\n        if (log.shouldLog(Log.DEBUG))\r\n            log.debug(\"Building a message expiring in \" + timeFromNow + \"ms: \" + config, new Exception(\"created by\"));\r\n        return null;\r\n    }\r\n    if (log.shouldLog(Log.DEBUG))\r\n        log.debug(\"CloveSet (\" + config.getCloveCount() + \" cloves) for message \" + msg.getUniqueId() + \" is \" + cloveSet.length + \" bytes and encrypted message data is \" + encData.length + \" bytes\");\r\n    return msg;\r\n}"
}, {
	"Path": "net.i2p.crypto.AESEngine.getPaddingSize",
	"Comment": "return size for padding the data to a mod 16 size so that it isat least minpaddedsizepublic for elgamalaesengine.not a public api, not for external use.",
	"Method": "int getPaddingSize(int curSize,long minPaddedSize){\r\n    int diff = 0;\r\n    if (curSize < minPaddedSize) {\r\n        diff = (int) minPaddedSize - curSize;\r\n    }\r\n    int numPadding = diff;\r\n    if (((curSize + diff) % 16) != 0)\r\n        numPadding += (16 - ((curSize + diff) % 16));\r\n    return numPadding;\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.StartExplorersJob.selectKeysToExplore",
	"Comment": "run through the explore pool and pick out some valuesnope, explorekeyselectorjob is disabled, so the explore poolmay be empty. in that case, generate random keys.",
	"Method": "Set<Hash> selectKeysToExplore(int num){\r\n    Set<Hash> queued = _facade.getExploreKeys();\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(\"Keys waiting for exploration: \" + queued.size());\r\n    Set<Hash> rv = new HashSet<Hash>(num);\r\n    for (Hash key : queued) {\r\n        if (rv.size() >= num)\r\n            break;\r\n        rv.add(key);\r\n    }\r\n    for (int i = rv.size(); i < num; i++) {\r\n        byte[] hash = new byte[Hash.HASH_LENGTH];\r\n        getContext().random().nextBytes(hash);\r\n        Hash key = new Hash(hash);\r\n        rv.add(key);\r\n    }\r\n    return rv;\r\n}"
}, {
	"Path": "net.i2p.router.web.helpers.SummaryHelper.getIdent",
	"Comment": "retrieve the shortened 4 character ident for the router located withinthe current jvm at the given context.",
	"Method": "String getIdent(){\r\n    if (_context == null)\r\n        return \"[no router]\";\r\n    if (_context.routerHash() != null)\r\n        return _context.routerHash().toBase64().substring(0, 4);\r\n    else\r\n        return \"[unknown]\";\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.SearchJob.onlyQueryFloodfillPeers",
	"Comment": "this is now misnamed, as it is only used to determine whether to return floodfill peers only",
	"Method": "boolean onlyQueryFloodfillPeers(RouterContext ctx){\r\n    if (ctx.netDb().floodfillEnabled())\r\n        return false;\r\n    return ctx.getProperty(\"netDb.floodfillOnly\", DEFAULT_FLOODFILL_ONLY);\r\n}"
}, {
	"Path": "net.i2p.router.transport.TransportImpl.haveCapacity",
	"Comment": "can we initiate or accept a connection to another peer, saving some margin",
	"Method": "boolean haveCapacity(boolean haveCapacity,int pct){\r\n    return countPeers() < getMaxConnections() * pct / 100;\r\n}"
}, {
	"Path": "org.jrobin.graph.RrdGraphDef.setRigid",
	"Comment": "sets rigid boundaries mode. normally jrobin will automatically expandthe lower and upper limit if the graph contains a value outside thevalid range. with the true argument you can disable this behavior.",
	"Method": "void setRigid(boolean rigid){\r\n    this.rigid = rigid;\r\n}"
}, {
	"Path": "net.i2p.stat.Frequency.getStrictAverageEventsPerPeriod",
	"Comment": "using the strict average interval, how many events occur within an average period?",
	"Method": "double getStrictAverageEventsPerPeriod(){\r\n    double avgInterval = getStrictAverageInterval();\r\n    if (avgInterval > 0)\r\n        return _period / avgInterval;\r\n    return 0;\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.CDPStatusBlock.getUnknownDatapoints",
	"Comment": "returns the number of unknown primary data points that were integrated.",
	"Method": "int getUnknownDatapoints(){\r\n    return unknownDatapoints;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.EstablishmentManager.handleOutbound",
	"Comment": "drive through the outbound establishment states, adjusting one of themas necessary. called from establisher thread only.",
	"Method": "long handleOutbound(){\r\n    long now = _context.clock().now();\r\n    long nextSendTime = -1;\r\n    OutboundEstablishState outboundState = null;\r\n    for (Iterator<OutboundEstablishState> iter = _outboundStates.values().iterator(); iter.hasNext(); ) {\r\n        OutboundEstablishState cur = iter.next();\r\n        OutboundEstablishState.OutboundState state = cur.getState();\r\n        if (state == OB_STATE_CONFIRMED_COMPLETELY || state == OB_STATE_VALIDATION_FAILED) {\r\n            iter.remove();\r\n            outboundState = cur;\r\n            break;\r\n        } else if (cur.getLifetime() >= MAX_OB_ESTABLISH_TIME) {\r\n            iter.remove();\r\n            outboundState = cur;\r\n            break;\r\n        } else {\r\n            if (cur.getNextSendTime() <= now) {\r\n                outboundState = cur;\r\n                break;\r\n            } else {\r\n                long when = -1;\r\n                if (cur.getNextSendTime() <= 0) {\r\n                    when = cur.getEstablishBeginTime() + MAX_OB_ESTABLISH_TIME;\r\n                } else {\r\n                    when = cur.getNextSendTime();\r\n                }\r\n                if ((nextSendTime <= 0) || (when < nextSendTime))\r\n                    nextSendTime = when;\r\n            }\r\n        }\r\n    }\r\n    if (outboundState != null) {\r\n        synchronized (outboundState) {\r\n            boolean expired = outboundState.getLifetime() >= MAX_OB_ESTABLISH_TIME;\r\n            switch(outboundState.getState()) {\r\n                case OB_STATE_UNKNOWN:\r\n                case OB_STATE_INTRODUCED:\r\n                    if (expired)\r\n                        processExpired(outboundState);\r\n                    else\r\n                        sendRequest(outboundState);\r\n                    break;\r\n                case OB_STATE_REQUEST_SENT:\r\n                    long rtime = outboundState.getRequestSentTime();\r\n                    if (expired || (rtime > 0 && rtime + OB_MESSAGE_TIMEOUT <= now))\r\n                        processExpired(outboundState);\r\n                    else if (outboundState.getNextSendTime() <= now)\r\n                        sendRequest(outboundState);\r\n                    break;\r\n                case OB_STATE_CREATED_RECEIVED:\r\n                    if (expired)\r\n                        processExpired(outboundState);\r\n                    else if (outboundState.getNextSendTime() <= now)\r\n                        sendConfirmation(outboundState);\r\n                    break;\r\n                case OB_STATE_CONFIRMED_PARTIALLY:\r\n                    long ctime = outboundState.getConfirmedSentTime();\r\n                    if (expired || (ctime > 0 && ctime + OB_MESSAGE_TIMEOUT <= now)) {\r\n                        sendDestroy(outboundState);\r\n                        processExpired(outboundState);\r\n                    } else if (outboundState.getNextSendTime() <= now) {\r\n                        sendConfirmation(outboundState);\r\n                    }\r\n                    break;\r\n                case OB_STATE_CONFIRMED_COMPLETELY:\r\n                    if (expired)\r\n                        processExpired(outboundState);\r\n                    else\r\n                        handleCompletelyEstablished(outboundState);\r\n                    break;\r\n                case OB_STATE_PENDING_INTRO:\r\n                    long itime = outboundState.getIntroSentTime();\r\n                    if (expired || (itime > 0 && itime + OB_MESSAGE_TIMEOUT <= now))\r\n                        processExpired(outboundState);\r\n                    else if (outboundState.getNextSendTime() <= now)\r\n                        handlePendingIntro(outboundState);\r\n                    break;\r\n                case OB_STATE_VALIDATION_FAILED:\r\n                    processExpired(outboundState);\r\n                    break;\r\n            }\r\n        }\r\n        nextSendTime = now;\r\n    }\r\n    return nextSendTime;\r\n}"
}, {
	"Path": "org.jrobin.core.ArcState.getRrdAllocator",
	"Comment": "required to implement rrdupdater interface. you should never call this method directly.",
	"Method": "RrdAllocator getRrdAllocator(){\r\n    return parentArc.getRrdAllocator();\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.TunnelHistory.getLifetimeFailed",
	"Comment": "total tunnels the peer has agreed to participate in that were later marked as failed prematurely",
	"Method": "long getLifetimeFailed(){\r\n    return _lifetimeFailed.get();\r\n}"
}, {
	"Path": "net.i2p.router.util.CoDelPriorityBlockingQueue.isBacklogged",
	"Comment": "has the head of the queue been waiting too long, or is the queue too big?",
	"Method": "boolean isBacklogged(){\r\n    E e = peek();\r\n    if (e == null)\r\n        return false;\r\n    return _dropping || _context.clock().now() - e.getEnqueueTime() >= BACKLOG_TIME || size() >= BACKLOG_SIZE;\r\n}"
}, {
	"Path": "org.apache.http.conn.util.InetAddressUtils.isIPv6HexCompressedAddress",
	"Comment": "checks whether the parameter is a valid compressed ipv6 address",
	"Method": "boolean isIPv6HexCompressedAddress(String input){\r\n    int colonCount = 0;\r\n    for (int i = 0; i < input.length(); i++) {\r\n        if (input.charAt(i) == COLON_CHAR) {\r\n            colonCount++;\r\n        }\r\n    }\r\n    return colonCount <= MAX_COLON_COUNT && IPV6_HEX_COMPRESSED_PATTERN.matcher(input).matches();\r\n}"
}, {
	"Path": "org.jrobin.core.XmlTemplate.hasVariables",
	"Comment": "searches the xml template to see if there are variables in there that\twill need to be set.",
	"Method": "boolean hasVariables(){\r\n    return PATTERN.matcher(root.toString()).find();\r\n}"
}, {
	"Path": "org.jrobin.core.RrdNioBackend.sync",
	"Comment": "this method forces all data cached in memory but not yet stored in thefile, to be stored in it.",
	"Method": "void sync(){\r\n    if (m_byteBuffer != null) {\r\n        m_byteBuffer.force();\r\n    }\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.socks.SOCKS4aServer.sendRequestReply",
	"Comment": "send the specified reply to a request of the client.eitherone of inetaddr or domainname can be null, depending onaddresstype.",
	"Method": "void sendRequestReply(int replyCode,InetAddress inetAddr,int bindPort,DataOutputStream out){\r\n    ByteArrayOutputStream reps = new ByteArrayOutputStream();\r\n    DataOutputStream dreps = new DataOutputStream(reps);\r\n    dreps.write(0x00);\r\n    dreps.write(replyCode);\r\n    dreps.writeShort(bindPort);\r\n    dreps.write(inetAddr.getAddress());\r\n    byte[] reply = reps.toByteArray();\r\n    if (_log.shouldLog(Log.DEBUG)) {\r\n        _log.debug(\"Sending request reply:\\n\" + HexDump.dump(reply));\r\n    }\r\n    out.write(reply);\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.Packet.getOptionalMaxSize",
	"Comment": "what is the largest payload the sender of this packet wants to receive?",
	"Method": "int getOptionalMaxSize(){\r\n    return _optionMaxSize;\r\n}"
}, {
	"Path": "net.i2p.data.i2np.UnknownI2NPMessage.writeMessageBody",
	"Comment": "write the message body to the output array, starting at the given index",
	"Method": "int writeMessageBody(byte out,int curIndex){\r\n    if (_data != null) {\r\n        System.arraycopy(_data, 0, out, curIndex, _data.length);\r\n        curIndex += _data.length;\r\n    }\r\n    return curIndex;\r\n}"
}, {
	"Path": "net.i2p.util.FileUtil.extractZip",
	"Comment": "as of release 0.7.12, any files inside the zip that have a .jar.pack or .war.pack suffix are transparently unpacked to a .jar or .war file using unpack200. logs at warn level to wrapper.log",
	"Method": "boolean extractZip(File zipfile,File targetDir,boolean extractZip,File zipfile,File targetDir,int logLevel){\r\n    int files = 0;\r\n    ZipFile zip = null;\r\n    try {\r\n        final byte[] buf = new byte[8192];\r\n        zip = new ZipFile(zipfile);\r\n        Enumeration<? extends ZipEntry> entries = zip.entries();\r\n        while (entries.hasMoreElements()) {\r\n            ZipEntry entry = (ZipEntry) entries.nextElement();\r\n            if (entry.getName().contains(\"..\")) {\r\n                System.err.println(\"ERROR: Refusing to extract a zip entry with '..' in it [\" + entry.getName() + \"]\");\r\n                return false;\r\n            }\r\n            if (entry.getName().indexOf(0) >= 0) {\r\n                System.err.println(\"ERROR: Refusing to extract a zip entry with null in it [\" + entry.getName() + \"]\");\r\n                return false;\r\n            }\r\n            File target = new File(targetDir, entry.getName());\r\n            File parent = target.getParentFile();\r\n            if ((parent != null) && (!parent.exists())) {\r\n                boolean parentsOk = parent.mkdirs();\r\n                if (!parentsOk) {\r\n                    if (logLevel <= Log.ERROR)\r\n                        System.err.println(\"ERROR: Unable to create the parent dir for \" + entry.getName() + \": [\" + parent.getAbsolutePath() + \"]\");\r\n                    return false;\r\n                }\r\n            }\r\n            if (entry.isDirectory()) {\r\n                if (!target.exists()) {\r\n                    boolean created = target.mkdirs();\r\n                    if (!created) {\r\n                        if (logLevel <= Log.ERROR)\r\n                            System.err.println(\"ERROR: Unable to create the directory [\" + entry.getName() + \"]\");\r\n                        return false;\r\n                    } else if (logLevel <= Log.INFO) {\r\n                        System.err.println(\"INFO: Creating directory [\" + entry.getName() + \"]\");\r\n                    }\r\n                }\r\n            } else {\r\n                InputStream in = null;\r\n                FileOutputStream fos = null;\r\n                JarOutputStream jos = null;\r\n                try {\r\n                    in = zip.getInputStream(entry);\r\n                    if (entry.getName().endsWith(\".jar.pack\") || entry.getName().endsWith(\".war.pack\")) {\r\n                        target = new File(targetDir, entry.getName().substring(0, entry.getName().length() - \".pack\".length()));\r\n                        jos = new JarOutputStream(new FileOutputStream(target));\r\n                        unpack(in, jos);\r\n                        if (logLevel <= Log.INFO)\r\n                            System.err.println(\"INFO: File [\" + entry.getName() + \"] extracted and unpacked\");\r\n                    } else {\r\n                        fos = new FileOutputStream(target);\r\n                        int read;\r\n                        while ((read = in.read(buf)) != -1) {\r\n                            fos.write(buf, 0, read);\r\n                        }\r\n                        if (logLevel <= Log.INFO)\r\n                            System.err.println(\"INFO: File [\" + entry.getName() + \"] extracted\");\r\n                    }\r\n                    files++;\r\n                } catch (IOException ioe) {\r\n                    if (logLevel <= Log.ERROR) {\r\n                        System.err.println(\"ERROR: Error extracting the zip entry (\" + entry.getName() + ')');\r\n                        if (ioe.getMessage() != null && ioe.getMessage().indexOf(\"CAFED00D\") >= 0)\r\n                            System.err.println(\"This may be caused by a packed library that requires Java 1.6, your Java version is: \" + System.getProperty(\"java.version\"));\r\n                        ioe.printStackTrace();\r\n                    }\r\n                    return false;\r\n                } catch (Exception e) {\r\n                    if (logLevel <= Log.ERROR) {\r\n                        System.err.println(\"ERROR: Error extracting the zip entry (\" + entry.getName() + ')');\r\n                        e.printStackTrace();\r\n                    }\r\n                    return false;\r\n                } finally {\r\n                    try {\r\n                        if (in != null)\r\n                            in.close();\r\n                    } catch (IOException ioe) {\r\n                    }\r\n                    try {\r\n                        if (fos != null)\r\n                            fos.close();\r\n                    } catch (IOException ioe) {\r\n                    }\r\n                    try {\r\n                        if (jos != null)\r\n                            jos.close();\r\n                    } catch (IOException ioe) {\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    } catch (IOException ioe) {\r\n        if (logLevel <= Log.ERROR) {\r\n            System.err.println(\"ERROR: Unable to extract the zip file\");\r\n            ioe.printStackTrace();\r\n        }\r\n        return false;\r\n    } finally {\r\n        if (zip != null) {\r\n            try {\r\n                zip.close();\r\n            } catch (IOException ioe) {\r\n            }\r\n        }\r\n        if (files > 0 && logLevel <= Log.WARN)\r\n            System.err.println(\"INFO: \" + files + \" files extracted to \" + targetDir);\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.core.FetchData.getRowCount",
	"Comment": "returns the number of rows fetched from the corresponding rrd.\teach row represents datasource values for the specific timestamp.",
	"Method": "int getRowCount(){\r\n    return timestamps.length;\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.IterativeSearchJob.retry",
	"Comment": "send lookups to one or more peers, up to the configured concurrent and total limits",
	"Method": "void retry(){\r\n    long now = getContext().clock().now();\r\n    if (_expiration < now) {\r\n        failed();\r\n        return;\r\n    }\r\n    if (_expiration - 500 < now) {\r\n        return;\r\n    }\r\n    while (true) {\r\n        Hash peer = null;\r\n        final int done, pend;\r\n        synchronized (this) {\r\n            if (_dead)\r\n                return;\r\n            pend = _unheardFrom.size();\r\n            if (pend >= _maxConcurrent)\r\n                return;\r\n            done = _failedPeers.size();\r\n        }\r\n        if (done >= _totalSearchLimit) {\r\n            failed();\r\n            return;\r\n        }\r\n        if (done + pend >= _totalSearchLimit)\r\n            return;\r\n        synchronized (this) {\r\n            if (_alwaysQueryHash != null && !_unheardFrom.contains(_alwaysQueryHash) && !_failedPeers.contains(_alwaysQueryHash)) {\r\n                peer = _alwaysQueryHash;\r\n            } else {\r\n                if (_toTry.isEmpty())\r\n                    return;\r\n                for (Iterator<Hash> iter = _toTry.iterator(); iter.hasNext(); ) {\r\n                    Hash h = iter.next();\r\n                    iter.remove();\r\n                    Set<String> peerIPs = new MaskedIPSet(getContext(), h, IP_CLOSE_BYTES);\r\n                    if (!_ipSet.containsAny(peerIPs)) {\r\n                        _ipSet.addAll(peerIPs);\r\n                        peer = h;\r\n                        break;\r\n                    }\r\n                    if (_log.shouldLog(Log.INFO))\r\n                        _log.info(getJobId() + \": Skipping query w/ router too close to others \" + h);\r\n                    _skippedPeers.add(h);\r\n                }\r\n                if (peer == null)\r\n                    return;\r\n            }\r\n            _unheardFrom.add(peer);\r\n        }\r\n        sendQuery(peer);\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.core.RrdDb.getArchive",
	"Comment": "returns archive object with the given consolidation function and the number\tof steps.",
	"Method": "Archive getArchive(int arcIndex,Archive getArchive,String consolFun,int steps){\r\n    try {\r\n        return getArchive(getArcIndex(consolFun, steps));\r\n    } catch (RrdException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.i2p.crypto.SHA1.engineReset",
	"Comment": "reset athen initialize the digest context.overrides the protected abstract method ofjava.security.messagedigestspi.",
	"Method": "void engineReset(){\r\n    int i = 60;\r\n    do {\r\n        pad[i] = (byte) 0x00;\r\n        pad[i + 1] = (byte) 0x00;\r\n        pad[i + 2] = (byte) 0x00;\r\n        pad[i + 3] = (byte) 0x00;\r\n    } while ((i -= 4) >= 0);\r\n    padding = 0;\r\n    bytes = 0;\r\n    init();\r\n}"
}, {
	"Path": "com.netflix.hollow.core.write.HollowWriteStateEngine.addTypeState",
	"Comment": "add a type to the dataset.should be called during the first cycle, before writing the first state.",
	"Method": "void addTypeState(HollowTypeWriteState writeState){\r\n    HollowSchema schema = writeState.getSchema();\r\n    if (writeStates.containsKey(schema.getName()))\r\n        throw new IllegalStateException(\"The state for type \" + schema.getName() + \" has already been added!\");\r\n    hollowSchemas.put(schema.getName(), schema);\r\n    writeStates.put(schema.getName(), writeState);\r\n    orderedTypeStates.add(writeState);\r\n    writeState.setStateEngine(this);\r\n}"
}, {
	"Path": "net.i2p.router.peermanager.TunnelHistory.getLastRejectedCritical",
	"Comment": "when the peer last refused to participate in a tunnel with level of critical",
	"Method": "long getLastRejectedCritical(){\r\n    return _lastRejectedCritical;\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.codeInspection.IgnoreDuplicateEntryInspection.checkFile",
	"Comment": "reports problems at file level. checks if entries are duplicated by other entries.",
	"Method": "ProblemDescriptor[] checkFile(PsiFile file,InspectionManager manager,boolean isOnTheFly){\r\n    if (!(file instanceof IgnoreFile)) {\r\n        return null;\r\n    }\r\n    final ProblemsHolder problemsHolder = new ProblemsHolder(manager, file, isOnTheFly);\r\n    final MultiMap<String, IgnoreEntry> entries = MultiMap.create();\r\n    file.acceptChildren(new IgnoreVisitor() {\r\n        @Override\r\n        public void visitEntry(@NotNull IgnoreEntry entry) {\r\n            entries.putValue(entry.getText(), entry);\r\n            super.visitEntry(entry);\r\n        }\r\n    });\r\n    for (Map.Entry<String, Collection<IgnoreEntry>> stringCollectionEntry : entries.entrySet()) {\r\n        Iterator<IgnoreEntry> iterator = stringCollectionEntry.getValue().iterator();\r\n        iterator.next();\r\n        while (iterator.hasNext()) {\r\n            IgnoreEntry entry = iterator.next();\r\n            problemsHolder.registerProblem(entry, IgnoreBundle.message(\"codeInspection.duplicateEntry.message\"), new IgnoreRemoveEntryFix(entry));\r\n        }\r\n    }\r\n    return problemsHolder.getResultsArray();\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.codeInspection.IgnoreDuplicateEntryInspection.checkFile",
	"Comment": "reports problems at file level. checks if entries are duplicated by other entries.",
	"Method": "ProblemDescriptor[] checkFile(PsiFile file,InspectionManager manager,boolean isOnTheFly){\r\n    entries.putValue(entry.getText(), entry);\r\n    super.visitEntry(entry);\r\n}"
}, {
	"Path": "net.i2p.client.streaming.impl.ConnectionOptions.setSendAckDelay",
	"Comment": "unused except here, so expect the default initial delay of 2000 ms unless set by the user to remain constant.",
	"Method": "void setSendAckDelay(int delayMs){\r\n    _sendAckDelay = delayMs;\r\n}"
}, {
	"Path": "net.i2p.servlet.I2PDefaultServlet.init",
	"Comment": "overridden to save local copies of dirallowed, locale, resourcebase, and stylesheet.calls super.",
	"Method": "void init(){\r\n    super.init();\r\n    _dirAllowed = getInitBoolean(\"dirAllowed\", _dirAllowed);\r\n    String rb = getInitParameter(\"resourceBase\");\r\n    if (rb != null) {\r\n        try {\r\n            _resourceBase = _contextHandler.newResource(rb);\r\n        } catch (Exception e) {\r\n            throw new UnavailableException(e.toString());\r\n        }\r\n    }\r\n    String css = getInitParameter(\"stylesheet\");\r\n    try {\r\n        if (css != null) {\r\n            _stylesheet = Resource.newResource(css);\r\n            if (!_stylesheet.exists()) {\r\n                _stylesheet = null;\r\n            }\r\n        }\r\n        if (_stylesheet == null) {\r\n            _stylesheet = Resource.newResource(this.getClass().getResource(\"/jetty-dir.css\"));\r\n        }\r\n    } catch (Exception e) {\r\n    }\r\n}"
}, {
	"Path": "net.i2p.data.LeaseSet2.verifySignature",
	"Comment": "verify with the spk in the dest for online sigs.verify with the spk in the offline sig section for offline sigs.",
	"Method": "boolean verifySignature(){\r\n    if (_signature == null)\r\n        return false;\r\n    SigType type = _signature.getType();\r\n    if (type == null || type.getBaseAlgorithm() == SigAlgo.RSA)\r\n        return false;\r\n    SigningPublicKey spk;\r\n    if (isOffline()) {\r\n        type = _transientSigningPublicKey.getType();\r\n        if (type == null || type.getBaseAlgorithm() == SigAlgo.RSA)\r\n            return false;\r\n        if (!verifyOfflineSignature())\r\n            return false;\r\n        spk = _transientSigningPublicKey;\r\n    } else {\r\n        spk = getSigningPublicKey();\r\n    }\r\n    int len = size();\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream(1 + len);\r\n    try {\r\n        out.write(getType());\r\n        writeBytesWithoutSig(out);\r\n    } catch (IOException ioe) {\r\n        ioe.printStackTrace();\r\n        return false;\r\n    } catch (DataFormatException dfe) {\r\n        dfe.printStackTrace();\r\n        return false;\r\n    }\r\n    byte[] data = out.toByteArray();\r\n    return DSAEngine.getInstance().verifySignature(_signature, data, spk);\r\n}"
}, {
	"Path": "net.i2p.stat.RateStat.containsRate",
	"Comment": "tests if a rate with the provided period exists within this ratestat.",
	"Method": "boolean containsRate(long period){\r\n    return getRate(period) != null;\r\n}"
}, {
	"Path": "net.i2p.stat.RateStat.getRate",
	"Comment": "returns rate with requested period if it exists, otherwise null",
	"Method": "Rate getRate(long period){\r\n    for (Rate r : _rates) {\r\n        if (r.getPeriod() == period)\r\n            return r;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.netflix.hollow.core.index.HollowHashIndexBuilder.calculateDedupedSizesAndTotalNumberOfSelectBuckets",
	"Comment": "called after initial pass.returns the sum total number of select buckets in the low 7 bytes, and the bits required for the max set size in the high 1 byte.",
	"Method": "long calculateDedupedSizesAndTotalNumberOfSelectBuckets(MultiLinkedElementArray elementArray,GrowingSegmentedLongArray matchIndexHashAndSizeArray){\r\n    long totalBuckets = 0;\r\n    long maxSize = 0;\r\n    int[] selectArray = new int[8];\r\n    for (int i = 0; i < elementArray.numLists(); i++) {\r\n        int listSize = elementArray.listSize(i);\r\n        int setSize = 0;\r\n        int predictedBuckets = HashCodes.hashTableSize(listSize);\r\n        int hashMask = predictedBuckets - 1;\r\n        if (predictedBuckets > selectArray.length)\r\n            selectArray = new int[predictedBuckets];\r\n        for (int j = 0; j < predictedBuckets; j++) selectArray[j] = -1;\r\n        HollowOrdinalIterator iter = elementArray.iterator(i);\r\n        int selectOrdinal = iter.next();\r\n        while (selectOrdinal != HollowOrdinalIterator.NO_MORE_ORDINALS) {\r\n            int hash = HashCodes.hashInt(selectOrdinal);\r\n            int bucket = hash & hashMask;\r\n            while (true) {\r\n                if (selectArray[bucket] == selectOrdinal)\r\n                    break;\r\n                if (selectArray[bucket] == -1) {\r\n                    selectArray[bucket] = selectOrdinal;\r\n                    setSize++;\r\n                    break;\r\n                }\r\n                bucket = (bucket + 1) & hashMask;\r\n            }\r\n            selectOrdinal = iter.next();\r\n        }\r\n        long matchIndexHashAndSize = matchIndexHashAndSizeArray.get(i);\r\n        matchIndexHashAndSize |= (long) setSize << 32;\r\n        matchIndexHashAndSizeArray.set(i, matchIndexHashAndSize);\r\n        totalBuckets += HashCodes.hashTableSize(setSize);\r\n        if (setSize > maxSize)\r\n            maxSize = setSize;\r\n    }\r\n    return totalBuckets | (long) bitsRequiredToRepresentValue(maxSize) << 56;\r\n}"
}, {
	"Path": "net.i2p.stat.Rate.getLastTotalValue",
	"Comment": "in the last full period, what was the total value acrued through all events?",
	"Method": "double getLastTotalValue(){\r\n    return _lastTotalValue;\r\n}"
}, {
	"Path": "org.mitre.dsmiley.httpproxy.ProxyServlet.copyResponseHeader",
	"Comment": "copy a proxied response header back to the servlet client.this is easily overwritten to filter out certain headers if desired.",
	"Method": "void copyResponseHeader(HttpServletRequest servletRequest,HttpServletResponse servletResponse,Header header){\r\n    String headerName = header.getName();\r\n    if (hopByHopHeaders.containsHeader(headerName))\r\n        return;\r\n    String headerValue = header.getValue();\r\n    if (headerName.equalsIgnoreCase(org.apache.http.cookie.SM.SET_COOKIE) || headerName.equalsIgnoreCase(org.apache.http.cookie.SM.SET_COOKIE2)) {\r\n        copyProxyCookie(servletRequest, servletResponse, headerValue);\r\n    } else if (headerName.equalsIgnoreCase(HttpHeaders.LOCATION)) {\r\n        servletResponse.addHeader(headerName, rewriteUrlFromResponse(servletRequest, headerValue));\r\n    } else {\r\n        servletResponse.addHeader(headerName, headerValue);\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.core.Sample.getDsNames",
	"Comment": "returns an array of all data source names. if you try to set value for the data source\tname not in this array, an exception is thrown.",
	"Method": "String[] getDsNames(){\r\n    return dsNames;\r\n}"
}, {
	"Path": "net.i2p.BOB.DoCMDS.ttlpnt",
	"Comment": "print information on a specific record, indicated by nameddb",
	"Method": "void ttlpnt(PrintStream out,String Arg){\r\n    database.getReadLock();\r\n    try {\r\n        if (database.exists(Arg)) {\r\n            out.print(\"DATA\");\r\n            nickprint(out, (NamedDB) database.get(Arg));\r\n        }\r\n    } finally {\r\n        database.releaseReadLock();\r\n    }\r\n}"
}, {
	"Path": "com.spotify.heroic.aggregation.AggregationInstance.distributable",
	"Comment": "indicated if any aggregation after this in a chain can be reduced or not.",
	"Method": "boolean distributable(){\r\n    return true;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.EstablishmentManager.receiveRelayResponse",
	"Comment": "we are alice, we sent a relayrequest to bob and got a response back.",
	"Method": "void receiveRelayResponse(RemoteHostId bob,UDPPacketReader reader){\r\n    long nonce = reader.getRelayResponseReader().readNonce();\r\n    OutboundEstablishState state = _liveIntroductions.remove(Long.valueOf(nonce));\r\n    if (state == null) {\r\n        if (_log.shouldLog(Log.INFO))\r\n            _log.info(\"Dup or unknown RelayResponse: \" + nonce);\r\n        return;\r\n    }\r\n    int sz = reader.getRelayResponseReader().readCharlieIPSize();\r\n    byte[] ip = new byte[sz];\r\n    reader.getRelayResponseReader().readCharlieIP(ip, 0);\r\n    int port = reader.getRelayResponseReader().readCharliePort();\r\n    if ((!isValid(ip, port)) || (!isValid(bob.getIP(), bob.getPort()))) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Bad relay resp from \" + bob + \" for \" + Addresses.toString(ip, port));\r\n        _context.statManager().addRateData(\"udp.relayBadIP\", 1);\r\n        return;\r\n    }\r\n    InetAddress addr = null;\r\n    try {\r\n        addr = InetAddress.getByAddress(ip);\r\n    } catch (UnknownHostException uhe) {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"Introducer for \" + state + \" (\" + bob + \") sent us an invalid address for our target: \" + Addresses.toString(ip, port), uhe);\r\n        return;\r\n    }\r\n    _context.statManager().addRateData(\"udp.receiveIntroRelayResponse\", state.getLifetime());\r\n    if (_log.shouldLog(Log.INFO))\r\n        _log.info(\"Received RelayResponse for \" + state.getRemoteIdentity().calculateHash() + \" - they are on \" + addr.toString() + \":\" + port + \" (according to \" + bob + \") nonce=\" + nonce);\r\n    synchronized (state) {\r\n        RemoteHostId oldId = state.getRemoteHostId();\r\n        state.introduced(ip, port);\r\n        RemoteHostId newId = state.getRemoteHostId();\r\n        _outboundByHash.put(state.getRemoteIdentity().calculateHash(), state);\r\n        RemoteHostId claimed = state.getClaimedAddress();\r\n        if (!oldId.equals(newId)) {\r\n            _outboundStates.remove(oldId);\r\n            _outboundStates.put(newId, state);\r\n            if (_log.shouldLog(Log.INFO))\r\n                _log.info(\"RR replaced \" + oldId + \" with \" + newId + \", claimed address was \" + claimed);\r\n        }\r\n        if (claimed != null)\r\n            _outboundByClaimedAddress.remove(oldId, state);\r\n    }\r\n    notifyActivity();\r\n}"
}, {
	"Path": "net.i2p.router.client.LocalClientConnectionRunner.localLookup",
	"Comment": "so localclientmessageeventlistener can lookup other local dests",
	"Method": "Destination localLookup(Hash h){\r\n    for (Destination d : _manager.getRunnerDestinations()) {\r\n        if (d.calculateHash().equals(h))\r\n            return d;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PeerState.setNextMACKey",
	"Comment": "the pending aes key for verifying packets if we are rekeying the connection, or null if we are not in the process of rekeying.",
	"Method": "void setNextMACKey(SessionKey key){\r\n    _nextMACKey = key;\r\n}"
}, {
	"Path": "org.jrobin.core.RrdDef.getDsDefs",
	"Comment": "returns all data source definition objects specified so far.",
	"Method": "DsDef[] getDsDefs(){\r\n    return dsDefs.toArray(new DsDef[0]);\r\n}"
}, {
	"Path": "com.netflix.hollow.core.memory.ByteArrayOrdinalMap.compare",
	"Comment": "compare the byte sequence contained in the supplied bytedatabuffer with the sequence contained in the map pointed to by the specified key, byte by byte.",
	"Method": "boolean compare(ByteDataBuffer serializedRepresentation,long key){\r\n    long position = key & POINTER_MASK;\r\n    int sizeOfData = VarInt.readVInt(byteData.getUnderlyingArray(), position);\r\n    if (sizeOfData != serializedRepresentation.length())\r\n        return false;\r\n    position += VarInt.sizeOfVInt(sizeOfData);\r\n    for (int i = 0; i < sizeOfData; i++) {\r\n        if (serializedRepresentation.get(i) != byteData.get(position++))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.ui.template.UserTemplateDialog.getPreferredFocusedComponent",
	"Comment": "returns component which should be focused when the dialog appears on the screen.",
	"Method": "JComponent getPreferredFocusedComponent(){\r\n    return name;\r\n}"
}, {
	"Path": "net.i2p.crypto.SHA1.engineGetDigestLength",
	"Comment": "returns the digest length in bytes.can be used to allocate your own output buffer whencomputing multiple digests.overrides the protected abstract method ofjava.security.messagedigestspi.",
	"Method": "int engineGetDigestLength(){\r\n    return HASH_LENGTH;\r\n}"
}, {
	"Path": "net.i2p.I2PAppContext.getProperties",
	"Comment": "access the configuration attributes of this context, listing the properties provided during the context construction, as well as the ones included insystem.getproperties.",
	"Method": "Properties getProperties(){\r\n    Properties rv = (Properties) System.getProperties().clone();\r\n    rv.putAll(_overrideProps);\r\n    return rv;\r\n}"
}, {
	"Path": "net.i2p.sam.SAMStreamSession.removeAllSocketHandlers",
	"Comment": "remove and hard close all the socket handlers managed by this samstream session.",
	"Method": "void removeAllSocketHandlers(){\r\n    synchronized (handlersMap) {\r\n        for (Map.Entry<Integer, SAMStreamSessionSocketReader> e : handlersMap.entrySet()) {\r\n            Integer id = e.getKey();\r\n            e.getValue().stopRunning();\r\n            sendersMap.get(id).shutDownGracefully();\r\n        }\r\n        handlersMap.clear();\r\n        sendersMap.clear();\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.graph.RrdGraphDef.setStep",
	"Comment": "suggests which time step should be used by jrobin while processing data from rrd files.",
	"Method": "void setStep(long step){\r\n    this.step = step;\r\n}"
}, {
	"Path": "org.jrobin.core.jrrd.RRDatabase.getData",
	"Comment": "returns data from the database corresponding to the given consolidation\tfunction.",
	"Method": "DataChunk getData(ConsolidationFunctionType type,DataChunk getData,ConsolidationFunctionType type,long step){\r\n    ArrayList<Archive> possibleArchives = getArchiveList(type);\r\n    if (possibleArchives.size() == 0) {\r\n        throw new RrdException(\"Database does not contain an Archive of consolidation function type \" + type);\r\n    }\r\n    Calendar endCal = Calendar.getInstance();\r\n    endCal.set(Calendar.MILLISECOND, 0);\r\n    Calendar startCal = (Calendar) endCal.clone();\r\n    startCal.add(Calendar.DATE, -1);\r\n    long end = endCal.getTime().getTime() / 1000;\r\n    long start = startCal.getTime().getTime() / 1000;\r\n    Archive archive = findBestArchive(start, end, step, possibleArchives);\r\n    step = header.pdpStep * archive.pdpCount;\r\n    start -= start % step;\r\n    if (end % step != 0) {\r\n        end += step - end % step;\r\n    }\r\n    int rows = (int) ((end - start) / step + 1);\r\n    long lastUpdateLong = lastUpdate.getTime() / 1000;\r\n    long archiveEndTime = lastUpdateLong - (lastUpdateLong % step);\r\n    long archiveStartTime = archiveEndTime - (step * (archive.rowCount - 1));\r\n    int startOffset = (int) ((start - archiveStartTime) / step);\r\n    int endOffset = (int) ((archiveEndTime - end) / step);\r\n    DataChunk chunk = new DataChunk(start, startOffset, endOffset, step, header.dsCount, rows);\r\n    archive.loadData(chunk);\r\n    return chunk;\r\n}"
}, {
	"Path": "io.helidon.security.AuthenticationResponse.successService",
	"Comment": "provider has authenticated the request and created a service subject.",
	"Method": "AuthenticationResponse successService(Subject service,AuthenticationResponse successService,Principal principal){\r\n    return successService(Subject.builder().principal(principal).build());\r\n}"
}, {
	"Path": "net.i2p.util.I2PAppThread.addOOMEventThreadListener",
	"Comment": "register a new component that wants notification of oom events",
	"Method": "void addOOMEventThreadListener(OOMEventListener lsnr){\r\n    _threadListeners.add(lsnr);\r\n}"
}, {
	"Path": "io.helidon.webserver.examples.comments.CommentsService.listComments",
	"Comment": "list all comments in original order as a string with single comment on the line.",
	"Method": "String listComments(String roomName){\r\n    List<Comment> comments = topicsAndComments.get(roomName);\r\n    if (comments != null) {\r\n        return comments.stream().map(String::valueOf).collect(Collectors.joining(\"\\n\"));\r\n    } else {\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "com.netflix.hollow.api.codegen.HollowCodeGenerationCompileUtil.runFindbugs",
	"Comment": "run findbugs on the provided directory. if findbugs fails, the first found bug is printed out as xml.",
	"Method": "void runFindbugs(File classDir){\r\n    ClassLoader classLoader = HollowCodeGenerationCompileUtil.class.getClassLoader();\r\n    FindBugs2.main(new String[] { \"-auxclasspath\", System.getProperty(PROPERTY_CLASSPATH), \"-output\", classLoader.getResource(\"\").getFile() + FILENAME_FINDBUGS, classDir.getAbsolutePath() });\r\n    BufferedReader reader = new BufferedReader(new InputStreamReader(classLoader.getResourceAsStream(FILENAME_FINDBUGS)));\r\n    String line = \"\";\r\n    String foundBug = null;\r\n    while ((line = reader.readLine()) != null) {\r\n        if (line.contains(\"<BugInstance\")) {\r\n            foundBug = line;\r\n        } else if (foundBug != null) {\r\n            foundBug += \"\\n\" + line;\r\n        }\r\n        if (line.contains(\"<\/BugInstance>\")) {\r\n            throw new Exception(\"Findbugs found an error:\\n\" + foundBug);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.klomp.snark.Peer.equals",
	"Comment": "two peers are equal when they have the same peerid.all other properties are ignored.",
	"Method": "boolean equals(Object o){\r\n    if (o instanceof Peer) {\r\n        Peer p = (Peer) o;\r\n        return _id == p._id && peerID.equals(p.peerID);\r\n    } else\r\n        return false;\r\n}"
}, {
	"Path": "net.i2p.router.transport.ntcp.NTCPTransport.getClockSkews",
	"Comment": "return our peer clock skews on this transport.vector composed of long, each element representing a peer skew in seconds.a positive number means our clock is ahead of theirs.",
	"Method": "Vector<Long> getClockSkews(){\r\n    Vector<Long> skews = new Vector<Long>();\r\n    long tooOld = _context.clock().now() - 10 * 60 * 1000;\r\n    for (NTCPConnection con : _conByIdent.values()) {\r\n        if (con.isEstablished() && con.getCreated() > tooOld)\r\n            skews.addElement(Long.valueOf(con.getClockSkew()));\r\n    }\r\n    if (skews.size() < 5 && _lastBadSkew != 0)\r\n        skews.addElement(Long.valueOf(_lastBadSkew));\r\n    return skews;\r\n}"
}, {
	"Path": "io.helidon.security.jersey.RequestedCounter.tryDecrement",
	"Comment": "tries to safely decrement a positive requested counter value, making sure the value does not drop below zero.",
	"Method": "boolean tryDecrement(){\r\n    return requested.getAndUpdate(val -> val > 0 ? val - 1 : 0) > 0;\r\n}"
}, {
	"Path": "com.netflix.hollow.api.codegen.HollowAPIGenerator.setUseAggressiveSubstitutions",
	"Comment": "use this method to override generated classnames for type names corresponding to any class in the java.lang package.defaults to false, which overrides only type names corresponding to a few select classes in java.lang.",
	"Method": "void setUseAggressiveSubstitutions(boolean useAggressiveSubstitutions){\r\n    config.setUseAggressiveSubstitutions(useAggressiveSubstitutions);\r\n}"
}, {
	"Path": "com.netflix.hollow.core.util.SimultaneousExecutor.awaitSuccessfulCompletion",
	"Comment": "await successful completion of all submitted tasks. throw exception of the first failed taskif 1 or more tasks failed.after this call completes, the thread pool will be shut down.",
	"Method": "void awaitSuccessfulCompletion(){\r\n    awaitUninterruptibly();\r\n    for (final Future<?> f : futures) {\r\n        f.get();\r\n    }\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.ConnThrottler.shouldThrottle",
	"Comment": "checks both individual and total. increments before checking.",
	"Method": "boolean shouldThrottle(Hash h){\r\n    if (_totalMax > 0) {\r\n        if (_totalThrottleUntil > 0) {\r\n            if (_totalThrottleUntil > Clock.getInstance().now())\r\n                return true;\r\n            _totalThrottleUntil = 0;\r\n        }\r\n    }\r\n    if (_max > 0) {\r\n        Record rec = _peers.get(h);\r\n        if (rec != null) {\r\n            if (rec.getUntil() > 0)\r\n                return true;\r\n            rec.increment();\r\n            long now = Clock.getInstance().now();\r\n            if (rec.countSince(now - _checkPeriod) > _max) {\r\n                long until = now + _throttlePeriod;\r\n                String date = _fmt.format(new Date(until));\r\n                _log.logAlways(Log.WARN, \"Throttling \" + _action + \" until \" + date + \" after exceeding max of \" + _max + \" in \" + DataHelper.formatDuration(_checkPeriod) + \": \" + h.toBase64());\r\n                rec.ban(until);\r\n                return true;\r\n            }\r\n        } else {\r\n            _peers.put(h, new Record());\r\n        }\r\n    }\r\n    if (_totalMax > 0 && ++_currentTotal > _totalMax) {\r\n        if (_totalThrottleUntil == 0) {\r\n            _totalThrottleUntil = Clock.getInstance().now() + _totalThrottlePeriod;\r\n            String date = _fmt.format(new Date(_totalThrottleUntil));\r\n            _log.logAlways(Log.WARN, \"*** Throttling \" + _action + \" from ALL peers until \" + date + \" after exceeding max of \" + _max + \" in \" + DataHelper.formatDuration(_checkPeriod));\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.EstablishmentManager.shouldAllowInboundEstablishment",
	"Comment": "should we allow another inbound establishment?used to throttle outbound hole punches.",
	"Method": "boolean shouldAllowInboundEstablishment(){\r\n    return _inboundStates.size() < getMaxInboundEstablishers();\r\n}"
}, {
	"Path": "net.i2p.crypto.SessionKeyManager.getCurrentOrNewKey",
	"Comment": "retrieve the session key currently associated with encryption to the target.generates a new session and session key if not previously exising.",
	"Method": "SessionKey getCurrentOrNewKey(PublicKey target){\r\n    return null;\r\n}"
}, {
	"Path": "org.klomp.snark.bencode.BDecoder.bdecode",
	"Comment": "gets the next indicator and returns either null when the streamhas ended or bdecodes the rest of the stream and returns theappropriate bevalue encoded object.",
	"Method": "BEValue bdecode(InputStream in,BEValue bdecode){\r\n    indicator = getNextIndicator();\r\n    if (indicator == -1)\r\n        return null;\r\n    if (indicator >= '0' && indicator <= '9')\r\n        return bdecodeBytes();\r\n    else if (indicator == 'i')\r\n        return bdecodeNumber();\r\n    else if (indicator == 'l')\r\n        return bdecodeList();\r\n    else if (indicator == 'd')\r\n        return bdecodeMap();\r\n    else\r\n        throw new InvalidBEncodingException(\"Unknown indicator '\" + indicator + \"'\");\r\n}"
}, {
	"Path": "io.helidon.security.EndpointConfig.derive",
	"Comment": "derive a new endpoint configuration builder based on this instance.",
	"Method": "Builder derive(){\r\n    Builder result = builder().attributes(attributes).customObjects(customObjects).configMap(configMap);\r\n    annotations.forEach(result::annotations);\r\n    return result;\r\n}"
}, {
	"Path": "org.cybergarage.upnp.ArgumentList.setResArgs",
	"Comment": "set all the argument which are output argoument to the given value in \tthe argument list",
	"Method": "void setResArgs(ArgumentList outArgList){\r\n    int nArgs = size();\r\n    for (int n = 0; n < nArgs; n++) {\r\n        Argument arg = getArgument(n);\r\n        if (arg.isOutDirection()) {\r\n            String argName = arg.getName();\r\n            Argument outArg = outArgList.getArgument(argName);\r\n            if (outArg == null)\r\n                throw new IllegalArgumentException(\"Argument \\\"\" + argName + \"\\\" missing.\");\r\n            arg.setValue(outArg.getValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.klomp.snark.Piece.getRequestCount",
	"Comment": "how many peers are requesting this piece?caller must synchronize",
	"Method": "int getRequestCount(){\r\n    return this.requests == null ? 0 : this.requests.size();\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.lang.IgnoreCommenter.getBlockCommentPrefix",
	"Comment": "returns the string which marks the beginning of a block comment in the language,or null if the language does not support block comments.",
	"Method": "String getBlockCommentPrefix(){\r\n    return null;\r\n}"
}, {
	"Path": "net.i2p.util.TryCache.clear",
	"Comment": "clears all cached items.this is the only methodthat blocks until it acquires the lock.",
	"Method": "void clear(){\r\n    lock.lock();\r\n    try {\r\n        items.clear();\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.transport.crypto.DHSessionKeyBuilder.getMyPublicValueBytes",
	"Comment": "return a 256 byte representation of our public key, with leading 0s if necessary.",
	"Method": "byte[] getMyPublicValueBytes(){\r\n    return toByteArray(getMyPublicValue());\r\n}"
}, {
	"Path": "net.i2p.stat.Rate.getLifetimeTotalEventTime",
	"Comment": "since rate creation, how much of the time was spent doing the events?",
	"Method": "long getLifetimeTotalEventTime(){\r\n    return _lifetimeTotalEventTime;\r\n}"
}, {
	"Path": "com.netflix.hollow.core.memory.ByteArrayOrdinalMap.prepareForWrite",
	"Comment": "create an array mapping the ordinals to pointers, so that they can be easily looked up when writing to blob streams.",
	"Method": "void prepareForWrite(){\r\n    int maxOrdinal = 0;\r\n    for (int i = 0; i < pointersAndOrdinals.length(); i++) {\r\n        long key = pointersAndOrdinals.get(i);\r\n        if (key != EMPTY_BUCKET_VALUE) {\r\n            int ordinal = (int) (key >>> BITS_PER_POINTER);\r\n            if (ordinal > maxOrdinal)\r\n                maxOrdinal = ordinal;\r\n        }\r\n    }\r\n    pointersByOrdinal = new long[maxOrdinal + 1];\r\n    Arrays.fill(pointersByOrdinal, -1);\r\n    for (int i = 0; i < pointersAndOrdinals.length(); i++) {\r\n        long key = pointersAndOrdinals.get(i);\r\n        if (key != EMPTY_BUCKET_VALUE) {\r\n            int ordinal = (int) (key >>> BITS_PER_POINTER);\r\n            pointersByOrdinal[ordinal] = key & POINTER_MASK;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.StoreJob.sendNext",
	"Comment": "send the key to the next batch of peerssynchronized to enforce parallelization limits and prevent dups",
	"Method": "void sendNext(){\r\n    if (_state.completed()) {\r\n        if (_log.shouldLog(Log.INFO))\r\n            _log.info(\"Already completed\");\r\n        return;\r\n    }\r\n    if (isExpired()) {\r\n        _state.complete(true);\r\n        if (_log.shouldLog(Log.INFO))\r\n            _log.info(getJobId() + \": Expired: \" + _timeoutMs);\r\n        fail();\r\n    } else if (_state.getAttempted().size() > MAX_PEERS_SENT) {\r\n        _state.complete(true);\r\n        if (_log.shouldLog(Log.INFO))\r\n            _log.info(getJobId() + \": Max sent\");\r\n        fail();\r\n    } else {\r\n        continueSending();\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.news.NewsManager.addEntries",
	"Comment": "add or replace each entry in the list. does not store them to disk.",
	"Method": "void addEntries(List<NewsEntry> entries){\r\n    for (NewsEntry e : entries) {\r\n        String id = e.id;\r\n        if (id == null)\r\n            continue;\r\n        String title = e.title;\r\n        boolean found = false;\r\n        for (int i = 0; i < _currentNews.size(); i++) {\r\n            NewsEntry old = _currentNews.get(i);\r\n            if (id.equals(old.id) || (title != null && title.equals(old.id))) {\r\n                _currentNews.set(i, e);\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found)\r\n            _currentNews.add(e);\r\n    }\r\n    Collections.sort(_currentNews);\r\n}"
}, {
	"Path": "io.helidon.security.SecurityRequestBuilder.requestMessage",
	"Comment": "set the request message to use when security provider requires access to it.",
	"Method": "T requestMessage(Entity entity){\r\n    this.requestEntity = entity;\r\n    return myInstance;\r\n}"
}, {
	"Path": "net.i2p.util.Clock.now",
	"Comment": "retrieve the current time synchronized with whatever reference clock is inuse.",
	"Method": "long now(){\r\n    return _offset + System.currentTimeMillis();\r\n}"
}, {
	"Path": "com.southernstorm.noise.protocol.HandshakeState.hasRemotePublicKey",
	"Comment": "determine if this handshake has already been configured\twith a remote static key.",
	"Method": "boolean hasRemotePublicKey(){\r\n    if (remotePublicKey != null)\r\n        return remotePublicKey.hasPublicKey();\r\n    else\r\n        return false;\r\n}"
}, {
	"Path": "net.i2p.sam.SAMv3StreamSession.queueSocket",
	"Comment": "put a socket on the accept queue.\tonly for subsession, throws illegalstateexception otherwise.",
	"Method": "boolean queueSocket(I2PSocket sock){\r\n    if (_acceptQueue == null)\r\n        throw new IllegalStateException();\r\n    return _acceptQueue.offer(sock);\r\n}"
}, {
	"Path": "net.i2p.router.ClientMessage.getFlags",
	"Comment": "flags requested by the client that sent the message.this will only be availablefor locally originated messages.",
	"Method": "int getFlags(){\r\n    return _flags;\r\n}"
}, {
	"Path": "net.i2p.router.transport.TransportImpl.getClockSkews",
	"Comment": "return our peer clock skews on a transport.vector composed of long, each element representing a peer skew in seconds.dummy version. transports override it.",
	"Method": "Vector<Long> getClockSkews(){\r\n    return new Vector<Long>();\r\n}"
}, {
	"Path": "net.i2p.router.time.RouterTimestamper.updateConfig",
	"Comment": "reload all the config elements from the appcontext.no logging allowed here",
	"Method": "void updateConfig(){\r\n    String serverList = _context.getProperty(PROP_SERVER_LIST);\r\n    if ((serverList == null) || (serverList.trim().length() <= 0)) {\r\n        serverList = DEFAULT_SERVER_LIST;\r\n        String country = _context.getProperty(PROP_IP_COUNTRY);\r\n        if (country == null) {\r\n            country = Locale.getDefault().getCountry();\r\n            if (country != null)\r\n                country = country.toLowerCase(Locale.US);\r\n        }\r\n        if (country != null && country.length() > 0 && !country.equals(\"a1\") && !country.equals(\"a2\")) {\r\n            _priorityServers = new ArrayList<List<String>>(2);\r\n            List<String> p1 = new ArrayList<String>(3);\r\n            for (int i = 0; i < 3; i++) {\r\n                p1.add(i + \".\" + country + \".pool.ntp.org\");\r\n            }\r\n            _priorityServers.add(p1);\r\n            String zone = _zones.getZone(country);\r\n            if (zone != null) {\r\n                List<String> p2 = new ArrayList<String>(3);\r\n                for (int i = 0; i < 3; i++) {\r\n                    p2.add(i + \".\" + zone + \".pool.ntp.org\");\r\n                }\r\n                _priorityServers.add(p2);\r\n            }\r\n        } else {\r\n            _priorityServers = null;\r\n        }\r\n    } else {\r\n        _priorityServers = null;\r\n    }\r\n    _servers.clear();\r\n    StringTokenizer tok = new StringTokenizer(serverList, \", \");\r\n    while (tok.hasMoreTokens()) {\r\n        String val = tok.nextToken();\r\n        val = val.trim();\r\n        if (val.length() > 0)\r\n            _servers.add(val);\r\n    }\r\n    _queryFrequency = Math.max(MIN_QUERY_FREQUENCY, _context.getProperty(PROP_QUERY_FREQUENCY, DEFAULT_QUERY_FREQUENCY));\r\n    _disabled = _context.getProperty(PROP_DISABLED, DEFAULT_DISABLED);\r\n    _concurringServers = Math.min(4, Math.max(1, _context.getProperty(PROP_CONCURRING_SERVERS, DEFAULT_CONCURRING_SERVERS)));\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.PacketBuilder.buildHolePunch",
	"Comment": "creates an empty unauthenticated packet for hole punching. parameters must be validated previously.",
	"Method": "UDPPacket buildHolePunch(InetAddress to,int port){\r\n    UDPPacket packet = UDPPacket.acquire(_context, false);\r\n    if (_log.shouldLog(Log.INFO))\r\n        _log.info(\"Sending relay hole punch to \" + to + \":\" + port);\r\n    packet.getPacket().setLength(0);\r\n    setTo(packet, to, port);\r\n    packet.setMessageType(TYPE_PUNCH);\r\n    return packet;\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.profiler.utils.ProfilerUtil.getProfilerRequestCollectorDecorated",
	"Comment": "decorated request model with loaded collector dataloads data on multiple thread to be as fast as possible",
	"Method": "List<ProfilerRequestInterface> getProfilerRequestCollectorDecorated(Collection<Callable<ProfilerRequestInterface>> callable,int threads){\r\n    ExecutorService executor = Executors.newFixedThreadPool(threads);\r\n    List<Future<ProfilerRequestInterface>> futures;\r\n    try {\r\n        futures = executor.invokeAll(callable);\r\n    } catch (InterruptedException e) {\r\n        return Collections.emptyList();\r\n    }\r\n    List<ProfilerRequestInterface> requests = new ArrayList();\r\n    for (Future<ProfilerRequestInterface> future : futures) {\r\n        try {\r\n            requests.add(future.get());\r\n        } catch (ExecutionException | InterruptedException ignored) {\r\n        }\r\n    }\r\n    executor.shutdown();\r\n    return requests;\r\n}"
}, {
	"Path": "com.netflix.hollow.core.memory.encoding.HashCodes.hashTableSize",
	"Comment": "determine size of hash table capable of storing the specified number of elements with a loadfactor applied.",
	"Method": "int hashTableSize(int numElements){\r\n    if (numElements < 0) {\r\n        throw new IllegalArgumentException(\"cannot be negative; numElements=\" + numElements);\r\n    } else if (numElements > HASH_TABLE_MAX_SIZE) {\r\n        throw new IllegalArgumentException(\"exceeds maximum number of buckets; numElements=\" + numElements);\r\n    }\r\n    if (numElements == 0)\r\n        return 1;\r\n    if (numElements < 3)\r\n        return numElements * 2;\r\n    int sizeAfterLoadFactor = (int) ((long) numElements * 10 / 7);\r\n    int bits = 32 - Integer.numberOfLeadingZeros(sizeAfterLoadFactor - 1);\r\n    return 1 << bits;\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.util.Glob.getRegex",
	"Comment": "returns regex string basing on the rule and provided syntax.",
	"Method": "String getRegex(String rule,IgnoreBundle.Syntax syntax,boolean acceptChildren){\r\n    return syntax.equals(IgnoreBundle.Syntax.GLOB) ? createRegex(rule, acceptChildren) : rule;\r\n}"
}, {
	"Path": "com.spotify.heroic.metadata.FindTags.updateTags",
	"Comment": "handle that tags is a deeply nested structure and copy it up until the closest immutabletype.",
	"Method": "void updateTags(Map<String, Set<String>> data,Map<String, Set<String>> add){\r\n    for (final Map.Entry<String, Set<String>> entry : add.entrySet()) {\r\n        Set<String> entries = data.get(entry.getKey());\r\n        if (entries == null) {\r\n            entries = new HashSet<String>();\r\n            data.put(entry.getKey(), entries);\r\n        }\r\n        entries.addAll(entry.getValue());\r\n    }\r\n}"
}, {
	"Path": "org.jrobin.graph.ValueAxis.getPixelsPerGridline",
	"Comment": "finds the number of pixels per gridline that the given ylab definition will result in",
	"Method": "int getPixelsPerGridline(YLab thisYLab){\r\n    double scaledrange = this.getScaledRange();\r\n    return (int) (im.ysize / (scaledrange / thisYLab.grid));\r\n}"
}, {
	"Path": "io.helidon.security.abac.AbacProvider.create",
	"Comment": "creates a new provider instance with default configuration.",
	"Method": "AbacProvider create(){\r\n    return builder().build();\r\n}"
}, {
	"Path": "net.i2p.router.transport.ntcp.NTCPTransport.isValid",
	"Comment": "an ipv6 address is only valid if we are configured to support ipv6and we have a public ipv6 address.",
	"Method": "boolean isValid(byte addr){\r\n    if (addr == null)\r\n        return false;\r\n    if (isPubliclyRoutable(addr) && (addr.length != 16 || _haveIPv6Address))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.util.PhpTypeProviderUtil.getResolvedParameter",
	"Comment": "we can also pipe php references signatures and resolve them hereoverwrite parameter to get string value",
	"Method": "String getResolvedParameter(PhpIndex phpIndex,String parameter){\r\n    if (parameter.startsWith(\"#K#C\")) {\r\n        if (parameter.endsWith(\".class\")) {\r\n            return StringUtils.stripStart(parameter.substring(4, parameter.length() - 6), \"\\\\\");\r\n        }\r\n    }\r\n    if (parameter.startsWith(\"#\")) {\r\n        Collection<? extends PhpNamedElement> signTypes = phpIndex.getBySignature(parameter, null, 0);\r\n        if (signTypes.size() == 0) {\r\n            return null;\r\n        }\r\n        parameter = PhpElementsUtil.getStringValue(signTypes.iterator().next());\r\n        if (parameter == null) {\r\n            return null;\r\n        }\r\n    }\r\n    return parameter;\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.config.yaml.YamlElementPatternHelper.getConfigKeyPattern",
	"Comment": "possible config key completionin document root or key value context",
	"Method": "ElementPattern<PsiElement> getConfigKeyPattern(){\r\n    return // not should fire this in all yaml files\r\n    PlatformPatterns.psiElement().withParent(PlatformPatterns.or(PlatformPatterns.psiElement(YAMLDocument.class), PlatformPatterns.psiElement(YAMLScalar.class), PlatformPatterns.psiElement(YAMLKeyValue.class))).inFile(getConfigFileNamePattern());\r\n}"
}, {
	"Path": "net.i2p.sam.MasterSession.close",
	"Comment": "close the master session\toverridden to stop the acceptor.",
	"Method": "void close(){\r\n    streamAcceptor.stopRunning();\r\n    super.close();\r\n}"
}, {
	"Path": "io.helidon.security.SecurityEnvironment.create",
	"Comment": "create a new instance of security environment with all default values.",
	"Method": "SecurityEnvironment create(){\r\n    return builder().build();\r\n}"
}, {
	"Path": "org.jrobin.core.FetchData.getArcEndTime",
	"Comment": "returns the timestamp of the last populated slot in the corresponding rra archive",
	"Method": "long getArcEndTime(){\r\n    return arcEndTime;\r\n}"
}, {
	"Path": "i2p.susi.webmail.MailCache.blockingLoadFromDisk",
	"Comment": "blocking. only call once!\tthis will not access the mailbox. mailbox need not be ready.",
	"Method": "void blockingLoadFromDisk(){\r\n    synchronized (mails) {\r\n        if (_isLoaded)\r\n            throw new IllegalStateException();\r\n        Collection<Mail> dmails = disk.getMails();\r\n        for (Mail mail : dmails) {\r\n            mails.put(mail.uidl, mail);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterInfo.writeDataBytes",
	"Comment": "write out the raw payload of the routerinfo, excluding the signature.thiscaches the data in memory if possible.",
	"Method": "void writeDataBytes(OutputStream out){\r\n    if (_identity == null)\r\n        throw new DataFormatException(\"Missing identity\");\r\n    if (_published < 0)\r\n        throw new DataFormatException(\"Invalid published date: \" + _published);\r\n    _identity.writeBytes(out);\r\n    DataHelper.writeLong(out, 8, _published);\r\n    int sz = _addresses.size();\r\n    out.write((byte) sz);\r\n    if (sz > 0) {\r\n        for (RouterAddress addr : _addresses) {\r\n            addr.writeBytes(out);\r\n        }\r\n    }\r\n    int psz = _peers == null ? 0 : _peers.size();\r\n    out.write((byte) psz);\r\n    if (psz > 0) {\r\n        Collection<Hash> peers = _peers;\r\n        if (psz > 1)\r\n            peers = SortHelper.sortStructures(peers);\r\n        for (Hash peerHash : peers) {\r\n            peerHash.writeBytes(out);\r\n        }\r\n    }\r\n    DataHelper.writeProperties(out, _options);\r\n}"
}, {
	"Path": "net.i2p.I2PAppContext.statManager",
	"Comment": "the statistics component with which we can track various eventsover time.",
	"Method": "StatManager statManager(){\r\n    if (!_statManagerInitialized)\r\n        initializeStatManager();\r\n    return _statManager;\r\n}"
}, {
	"Path": "org.jrobin.data.PercentileDef.calculate",
	"Comment": "realize the calculation of this definition, over the given time period",
	"Method": "void calculate(long tStart,long tEnd){\r\n    if (m_source != null) {\r\n        this.setValue(m_source.getPercentile(tStart, tEnd, m_percentile));\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.web.helpers.WizardHelper.getOutboundBurstRate",
	"Comment": "to populate form with.uses the test result if available, else the current settingadapted from confignethelper.",
	"Method": "String getOutboundBurstRate(){\r\n    float bw;\r\n    long result = getUpBandwidth();\r\n    if (result > 0) {\r\n        bw = Math.max(MIN_UP_BW, BW_SCALE * result / 1000f);\r\n    } else {\r\n        bw = _context.bandwidthLimiter().getOutboundBurstKBytesPerSecond() * 1.024f;\r\n    }\r\n    return Integer.toString(Math.round(bw));\r\n}"
}, {
	"Path": "net.i2p.router.tunnel.InboundEndpointProcessor.decrypt",
	"Comment": "iteratively undo the crypto that the various layers in the tunnel added.",
	"Method": "void decrypt(RouterContext ctx,TunnelCreatorConfig cfg,byte iv,byte orig,int offset,int length){\r\n    byte[] cur = SimpleByteCache.acquire(HopProcessor.IV_LENGTH);\r\n    for (int i = cfg.getLength() - 2; i >= 0; i--) {\r\n        OutboundGatewayProcessor.decrypt(ctx, iv, orig, offset, length, cur, cfg.getConfig(i));\r\n    }\r\n    SimpleByteCache.release(cur);\r\n}"
}, {
	"Path": "net.i2p.stat.Rate.getLastEventSaturation",
	"Comment": "during the last period, how much of the time was spent actually processing events in proportion to how many events could have occurred if there were no intervals?",
	"Method": "double getLastEventSaturation(){\r\n    if ((_lastEventCount > 0) && (_lastTotalEventTime > 0)) {\r\n        return ((double) _lastTotalEventTime) / (double) _period;\r\n    }\r\n    return 0.0D;\r\n}"
}, {
	"Path": "net.i2p.router.OutNetMessage.getMessageSize",
	"Comment": "how large the message is, including the full 16 byte header.transports with different header sizes should adjust.",
	"Method": "int getMessageSize(){\r\n    return _messageSize;\r\n}"
}, {
	"Path": "org.klomp.snark.comments.CommentSet.add",
	"Comment": "max length for strings enforced in comment.java. max total length for strings enforced here. enforces max size for set",
	"Method": "boolean add(Comment c){\r\n    if (realSize >= MAX_SIZE && !c.isMine())\r\n        return false;\r\n    String s = c.getText();\r\n    if (s != null && totalTextSize + s.length() > MAX_TOTAL_TEXT_LEN)\r\n        return false;\r\n    if (c.isMine() && c.getText() == null && c.getRating() == myRating)\r\n        return false;\r\n    int hCode = c.hashCode();\r\n    Integer phc = Integer.valueOf(hCode - 1);\r\n    List<Comment> plist = map.get(phc);\r\n    if (plist != null && plist.contains(c))\r\n        return false;\r\n    Integer nhc = Integer.valueOf(hCode + 1);\r\n    List<Comment> nxlist = map.get(nhc);\r\n    if (nxlist != null && nxlist.contains(c))\r\n        return false;\r\n    Integer hc = Integer.valueOf(hCode);\r\n    List<Comment> list = map.get(hc);\r\n    if (list == null) {\r\n        list = Collections.singletonList(c);\r\n        map.put(hc, list);\r\n        addStats(c);\r\n        return true;\r\n    }\r\n    if (list.contains(c))\r\n        return false;\r\n    if (list.size() == 1) {\r\n        List<Comment> nlist = new ArrayList<Comment>(2);\r\n        nlist.add(list.get(0));\r\n        map.put(hc, nlist);\r\n        list = nlist;\r\n    }\r\n    list.add(c);\r\n    if (c.isMine() && c.getText() == null)\r\n        removeMyOldRatings(c.getID());\r\n    addStats(c);\r\n    return true;\r\n}"
}, {
	"Path": "net.i2p.router.transport.udp.InboundEstablishState.receiveSessionConfirmed",
	"Comment": "note that while a sessionconfirmed could in theory be fragmented, in practice a routeridentity is 387 bytes and a single fragment is 512 bytes max, so it will never be fragmented.",
	"Method": "void receiveSessionConfirmed(UDPPacketReader.SessionConfirmedReader conf){\r\n    if (_receivedIdentity == null)\r\n        _receivedIdentity = new byte[conf.readTotalFragmentNum()][];\r\n    int cur = conf.readCurrentFragmentNum();\r\n    if (cur >= _receivedIdentity.length) {\r\n        fail();\r\n        packetReceived();\r\n        return;\r\n    }\r\n    if (_receivedIdentity[cur] == null) {\r\n        byte[] fragment = new byte[conf.readCurrentFragmentSize()];\r\n        conf.readFragmentData(fragment, 0);\r\n        _receivedIdentity[cur] = fragment;\r\n    }\r\n    if (cur == _receivedIdentity.length - 1) {\r\n        _receivedSignedOnTime = conf.readFinalFragmentSignedOnTime();\r\n        buildIdentity();\r\n        if (_receivedUnconfirmedIdentity != null) {\r\n            SigType type = _receivedUnconfirmedIdentity.getSigningPublicKey().getType();\r\n            if (type != null) {\r\n                int sigLen = type.getSigLen();\r\n                if (_receivedSignature == null)\r\n                    _receivedSignature = new byte[sigLen];\r\n                conf.readFinalSignature(_receivedSignature, 0, sigLen);\r\n            } else {\r\n                if (_log.shouldLog(Log.WARN))\r\n                    _log.warn(\"Unsupported sig type from: \" + toString());\r\n                _context.banlist().banlistRouterForever(_receivedUnconfirmedIdentity.calculateHash(), \"Unsupported signature type\");\r\n                fail();\r\n            }\r\n        } else {\r\n            if (_log.shouldLog(Log.WARN))\r\n                _log.warn(\"Bad ident from: \" + toString());\r\n            fail();\r\n        }\r\n    }\r\n    if ((_currentState == InboundState.IB_STATE_UNKNOWN) || (_currentState == InboundState.IB_STATE_REQUEST_RECEIVED) || (_currentState == InboundState.IB_STATE_CREATED_SENT)) {\r\n        if (confirmedFullyReceived())\r\n            _currentState = InboundState.IB_STATE_CONFIRMED_COMPLETELY;\r\n        else\r\n            _currentState = InboundState.IB_STATE_CONFIRMED_PARTIALLY;\r\n    }\r\n    packetReceived();\r\n}"
}, {
	"Path": "mobi.hsz.idea.gitignore.lang.IgnoreCommenter.getCommentedBlockCommentPrefix",
	"Comment": "returns the string which marks the commented beginning of a block comment in the language,or null if the language does not support block comments.",
	"Method": "String getCommentedBlockCommentPrefix(){\r\n    return null;\r\n}"
}, {
	"Path": "net.i2p.i2ptunnel.ui.GeneralHelper.deleteTunnel",
	"Comment": "stop the tunnel, delete from config,rename the private key file if in the default directory",
	"Method": "List<String> deleteTunnel(int tunnel,String privKeyFile,List<String> deleteTunnel,I2PAppContext context,TunnelControllerGroup tcg,int tunnel,String privKeyFile){\r\n    List<String> msgs;\r\n    TunnelController cur = getController(tcg, tunnel);\r\n    if (cur == null) {\r\n        msgs = new ArrayList<String>();\r\n        msgs.add(\"Invalid tunnel number\");\r\n        return msgs;\r\n    }\r\n    msgs = tcg.removeController(cur);\r\n    msgs.addAll(saveConfig(context, tcg));\r\n    String pk = cur.getPrivKeyFile();\r\n    if (pk == null)\r\n        pk = privKeyFile;\r\n    if (pk != null && pk.startsWith(\"i2ptunnel\") && pk.endsWith(\"-privKeys.dat\") && ((!TunnelController.isClient(cur.getType())) || cur.getPersistentClientKey())) {\r\n        File pkf = new File(context.getConfigDir(), pk);\r\n        if (pkf.exists()) {\r\n            String name = cur.getName();\r\n            if (name == null) {\r\n                name = cur.getDescription();\r\n                if (name == null) {\r\n                    name = cur.getType();\r\n                    if (name == null)\r\n                        name = Long.toString(context.clock().now());\r\n                }\r\n            }\r\n            name = name.replace(' ', '_').replace(':', '_').replace(\"..\", \"_\").replace('/', '_').replace('\\\\', '_');\r\n            name = \"i2ptunnel-deleted-\" + name + '-' + context.clock().now() + \"-privkeys.dat\";\r\n            File backupDir = new SecureFile(context.getConfigDir(), TunnelController.KEY_BACKUP_DIR);\r\n            File to;\r\n            if (backupDir.isDirectory() || backupDir.mkdir())\r\n                to = new File(backupDir, name);\r\n            else\r\n                to = new File(context.getConfigDir(), name);\r\n            boolean success = FileUtil.rename(pkf, to);\r\n            if (success)\r\n                msgs.add(\"Private key file \" + pkf.getAbsolutePath() + \" renamed to \" + to.getAbsolutePath());\r\n        }\r\n    }\r\n    return msgs;\r\n}"
}, {
	"Path": "net.i2p.router.networkdb.kademlia.StoreJob.sendStoreThroughGarlic",
	"Comment": "this is misnamed, it means sending it out through an exploratory tunnel,with the reply to come back through an exploratory tunnel.there is no garlic encryption added.",
	"Method": "void sendStoreThroughGarlic(DatabaseStoreMessage msg,RouterInfo peer,long expiration){\r\n    long token = 1 + getContext().random().nextLong(I2NPMessage.MAX_ID_VALUE);\r\n    Hash to = peer.getIdentity().getHash();\r\n    TunnelInfo replyTunnel = getContext().tunnelManager().selectInboundExploratoryTunnel(to);\r\n    if (replyTunnel == null) {\r\n        _log.warn(\"No reply inbound tunnels available!\");\r\n        return;\r\n    }\r\n    TunnelId replyTunnelId = replyTunnel.getReceiveTunnelId(0);\r\n    msg.setReplyToken(token);\r\n    msg.setReplyTunnel(replyTunnelId);\r\n    msg.setReplyGateway(replyTunnel.getPeer(0));\r\n    if (_log.shouldLog(Log.DEBUG))\r\n        _log.debug(getJobId() + \": send store thru expl. tunnel to \" + peer.getIdentity().getHash() + \"  w/ token expected \" + token);\r\n    _state.addPending(to);\r\n    TunnelInfo outTunnel = getContext().tunnelManager().selectOutboundExploratoryTunnel(to);\r\n    if (outTunnel != null) {\r\n        SendSuccessJob onReply = new SendSuccessJob(getContext(), peer, outTunnel, msg.getMessageSize());\r\n        FailedJob onFail = new FailedJob(getContext(), peer, getContext().clock().now());\r\n        StoreMessageSelector selector = new StoreMessageSelector(getContext(), getJobId(), peer, token, expiration);\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"sending store to \" + peer.getIdentity().getHash() + \" through \" + outTunnel + \": \" + msg);\r\n        getContext().messageRegistry().registerPending(selector, onReply, onFail);\r\n        getContext().tunnelDispatcher().dispatchOutbound(msg, outTunnel.getSendTunnelId(0), null, to);\r\n    } else {\r\n        if (_log.shouldLog(Log.WARN))\r\n            _log.warn(\"No outbound tunnels to send a dbStore out!\");\r\n        fail();\r\n    }\r\n}"
}, {
	"Path": "io.helidon.security.Principal.builder",
	"Comment": "creates a fluent api builder to build new instances of this class.",
	"Method": "Builder builder(){\r\n    return new Builder();\r\n}"
}, {
	"Path": "net.i2p.client.impl.I2PSimpleSession.connect",
	"Comment": "connect to the router and establish a session.this call blocks until a session is granted.not threadsafe, do not call from multiple threads.",
	"Method": "void connect(){\r\n    changeState(State.OPENING);\r\n    boolean success = false;\r\n    try {\r\n        synchronized (_stateLock) {\r\n            if (_context.isRouterContext()) {\r\n                InternalClientManager mgr = _context.internalClientManager();\r\n                if (mgr == null)\r\n                    throw new I2PSessionException(\"Router is not ready for connections\");\r\n                _queue = mgr.connect();\r\n                _reader = new QueuedI2CPMessageReader(_queue, this);\r\n                _reader.startReading();\r\n            } else {\r\n                if (Boolean.parseBoolean(getOptions().getProperty(PROP_ENABLE_SSL))) {\r\n                    try {\r\n                        I2PSSLSocketFactory fact = new I2PSSLSocketFactory(_context, false, \"certificates/i2cp\");\r\n                        _socket = fact.createSocket(_hostname, _portNum);\r\n                    } catch (GeneralSecurityException gse) {\r\n                        IOException ioe = new IOException(\"SSL Fail\");\r\n                        ioe.initCause(gse);\r\n                        throw ioe;\r\n                    }\r\n                } else {\r\n                    _socket = new Socket(_hostname, _portNum);\r\n                }\r\n                _socket.setKeepAlive(true);\r\n                OutputStream out = _socket.getOutputStream();\r\n                out.write(I2PClient.PROTOCOL_BYTE);\r\n                out.flush();\r\n                _writer = new ClientWriterRunner(out, this);\r\n                _writer.startWriting();\r\n                InputStream in = new BufferedInputStream(_socket.getInputStream(), BUF_SIZE);\r\n                _reader = new I2CPMessageReader(in, this);\r\n                _reader.startReading();\r\n            }\r\n        }\r\n        if (!_context.isRouterContext()) {\r\n            Properties opts = getOptions();\r\n            if ((!opts.containsKey(PROP_USER)) && (!opts.containsKey(PROP_PW))) {\r\n                String configUser = _context.getProperty(PROP_USER);\r\n                String configPW = _context.getProperty(PROP_PW);\r\n                if (configUser != null && configPW != null) {\r\n                    opts.setProperty(PROP_USER, configUser);\r\n                    opts.setProperty(PROP_PW, configPW);\r\n                }\r\n            }\r\n            if (opts.containsKey(PROP_USER) && opts.containsKey(PROP_PW)) {\r\n                Properties auth = new OrderedProperties();\r\n                auth.setProperty(PROP_USER, opts.getProperty(PROP_USER));\r\n                auth.setProperty(PROP_PW, opts.getProperty(PROP_PW));\r\n                sendMessage_unchecked(new GetDateMessage(CoreVersion.VERSION, auth));\r\n            } else {\r\n                sendMessage_unchecked(new GetDateMessage(CoreVersion.VERSION));\r\n            }\r\n            waitForDate();\r\n        }\r\n        success = true;\r\n        if (_log.shouldLog(Log.INFO))\r\n            _log.info(getPrefix() + \" simple session connected\");\r\n    } catch (InterruptedException ie) {\r\n        throw new I2PSessionException(\"Interrupted\", ie);\r\n    } catch (UnknownHostException uhe) {\r\n        throw new I2PSessionException(getPrefix() + \"Cannot connect to the router on \" + _hostname + ':' + _portNum, uhe);\r\n    } catch (IOException ioe) {\r\n        String msg;\r\n        if (_context.isRouterContext())\r\n            msg = \"Failed internal router binding\";\r\n        else if (SystemVersion.isAndroid() && Boolean.parseBoolean(getOptions().getProperty(PROP_DOMAIN_SOCKET)))\r\n            msg = \"Failed to bind to the router\";\r\n        else\r\n            msg = \"Cannot connect to the router on \" + _hostname + ':' + _portNum;\r\n        throw new I2PSessionException(getPrefix() + msg, ioe);\r\n    } finally {\r\n        changeState(success ? State.OPEN : State.CLOSED);\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.MessageHistory.replyTimedOut",
	"Comment": "the message wanted a reply but no reply came in the time expected",
	"Method": "void replyTimedOut(OutNetMessage sentMessage){\r\n    if (!_doLog)\r\n        return;\r\n    if (sentMessage == null)\r\n        return;\r\n    StringBuilder buf = new StringBuilder(512);\r\n    buf.append(getPrefix());\r\n    buf.append(\"timed out waiting for a reply to [\").append(sentMessage.getMessageType());\r\n    buf.append(\"] [\").append(sentMessage.getMessageId()).append(\"] expiring on [\");\r\n    buf.append(getTime(sentMessage.getReplySelector().getExpiration()));\r\n    buf.append(\"] \").append(sentMessage.getReplySelector().toString());\r\n    addEntry(buf.toString());\r\n}"
}, {
	"Path": "io.helidon.security.oidc.common.OidcConfig.builder",
	"Comment": "create a builder to programmatically construct oidc configuration.",
	"Method": "Builder builder(){\r\n    return new Builder();\r\n}"
}, {
	"Path": "net.i2p.router.OutNetMessage.getOnSendJob",
	"Comment": "after the message is successfully passed to the router specified, thegiven job is enqueued.",
	"Method": "Job getOnSendJob(){\r\n    return _onSend;\r\n}"
}, {
	"Path": "net.i2p.crypto.TrustedUpdate.migrateFile",
	"Comment": "extract the file. skips and ignores the signature and version. no verification.",
	"Method": "String migrateFile(File signedFile,File outputFile){\r\n    if (!signedFile.exists())\r\n        return \"File not found: \" + signedFile.getAbsolutePath();\r\n    FileInputStream fileInputStream = null;\r\n    FileOutputStream fileOutputStream = null;\r\n    try {\r\n        fileInputStream = new FileInputStream(signedFile);\r\n        fileOutputStream = new FileOutputStream(outputFile);\r\n        DataHelper.skip(fileInputStream, HEADER_BYTES);\r\n        DataHelper.copy(fileInputStream, fileOutputStream);\r\n    } catch (IOException ioe) {\r\n        return \"Error copying update: \" + ioe;\r\n    } finally {\r\n        if (fileInputStream != null)\r\n            try {\r\n                fileInputStream.close();\r\n            } catch (IOException ioe) {\r\n            }\r\n        if (fileOutputStream != null)\r\n            try {\r\n                fileOutputStream.close();\r\n            } catch (IOException ioe) {\r\n            }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.helidon.security.spi.SecurityProvider.supportedAttributes",
	"Comment": "a collection of attribute names expected by this provider to override endpointconfiguration.",
	"Method": "Collection<String> supportedAttributes(){\r\n    return CollectionsHelper.setOf();\r\n}"
}, {
	"Path": "net.i2p.router.transport.crypto.DHSessionKeyBuilder.getPeerPublicValueBytes",
	"Comment": "return a 256 byte representation of his public key, with leading 0s if necessary.",
	"Method": "byte[] getPeerPublicValueBytes(){\r\n    return toByteArray(getPeerPublicValue());\r\n}"
}, {
	"Path": "net.nicoulaj.idea.markdown.lang.parser.MarkdownParserDefinition.getWhitespaceTokens",
	"Comment": "get the set of token types which are treated as whitespace by the psi builder.",
	"Method": "TokenSet getWhitespaceTokens(){\r\n    return TokenSet.EMPTY;\r\n}"
}, {
	"Path": "com.netflix.hollow.api.codegen.HollowCodeGenerationCompileUtil.compileSrcFiles",
	"Comment": "compiles java source files in the provided source directory, to the provided class directory.this also runs findbugs on the compiled classes, throwing an exception if findbugs fails.",
	"Method": "void compileSrcFiles(String sourceDirPath,String classDirPath){\r\n    List<String> srcFiles = new ArrayList();\r\n    addAllJavaFiles(new File(sourceDirPath), srcFiles);\r\n    File classDir = new File(classDirPath);\r\n    classDir.mkdir();\r\n    List<String> argList = new ArrayList();\r\n    argList.add(\"-d\");\r\n    argList.add(classDir.getAbsolutePath());\r\n    argList.add(\"-classpath\");\r\n    argList.add(System.getProperty(PROPERTY_CLASSPATH) + System.getProperty(\"path.separator\") + classDirPath);\r\n    argList.addAll(srcFiles);\r\n    String[] args = new String[argList.size()];\r\n    for (int i = 0; i < argList.size(); i++) {\r\n        args[i] = argList.get(i);\r\n    }\r\n    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\r\n    int err = compiler.run(null, System.out, System.out, args);\r\n    if (err != 0)\r\n        throw new RuntimeException(\"compiler errors, see system.out\");\r\n    runFindbugs(classDir);\r\n}"
}, {
	"Path": "net.i2p.data.router.RouterInfo.getBytes",
	"Comment": "write out the raw payload of the routerinfo, excluding the signature.thiscaches the data in memory if possible.",
	"Method": "byte[] getBytes(){\r\n    if (_byteified != null)\r\n        return _byteified;\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream(2 * 1024);\r\n    try {\r\n        writeDataBytes(out);\r\n    } catch (IOException ioe) {\r\n        throw new DataFormatException(\"IO Error getting bytes\", ioe);\r\n    }\r\n    byte[] data = out.toByteArray();\r\n    if (CACHE_ALL || _shouldCache)\r\n        _byteified = data;\r\n    return data;\r\n}"
}, {
	"Path": "net.i2p.router.message.GarlicMessageBuilder.buildCloveSet",
	"Comment": "build the unencrypted garlicmessage specified by the config.it contains the number of cloves, followed by each clove,followed by a certificate, id, and expiration date.",
	"Method": "byte[] buildCloveSet(RouterContext ctx,GarlicConfig config){\r\n    ByteArrayOutputStream baos = null;\r\n    Log log = ctx.logManager().getLog(GarlicMessageBuilder.class);\r\n    try {\r\n        if (config instanceof PayloadGarlicConfig) {\r\n            byte[] clove = buildClove(ctx, (PayloadGarlicConfig) config);\r\n            baos = new ByteArrayOutputStream(clove.length + 16);\r\n            baos.write((byte) 1);\r\n            baos.write(clove);\r\n        } else {\r\n            byte[][] cloves = new byte[config.getCloveCount()][];\r\n            for (int i = 0; i < config.getCloveCount(); i++) {\r\n                GarlicConfig c = config.getClove(i);\r\n                if (c instanceof PayloadGarlicConfig) {\r\n                    cloves[i] = buildClove(ctx, (PayloadGarlicConfig) c);\r\n                } else {\r\n                    log.debug(\"Subclove IS NOT a payload garlic clove\");\r\n                    cloves[i] = buildClove(ctx, c);\r\n                }\r\n            }\r\n            int len = 1;\r\n            for (int i = 0; i < cloves.length; i++) len += cloves[i].length;\r\n            baos = new ByteArrayOutputStream(len + 16);\r\n            baos.write((byte) cloves.length);\r\n            for (int i = 0; i < cloves.length; i++) baos.write(cloves[i]);\r\n        }\r\n        config.getCertificate().writeBytes(baos);\r\n        DataHelper.writeLong(baos, 4, config.getId());\r\n        DataHelper.writeLong(baos, DataHelper.DATE_LENGTH, config.getExpiration());\r\n    } catch (IOException ioe) {\r\n        log.error(\"Error building the clove set\", ioe);\r\n        throw new IllegalArgumentException(\"Error building the clove set\", ioe);\r\n    } catch (DataFormatException dfe) {\r\n        log.error(\"Error building the clove set\", dfe);\r\n        throw new IllegalArgumentException(\"Error building the clove set\", dfe);\r\n    }\r\n    return baos.toByteArray();\r\n}"
}, {
	"Path": "org.jrobin.core.Util.getJRobinDemoPath",
	"Comment": "returns full path to the file stored in the demo directory of jrobin",
	"Method": "String getJRobinDemoPath(String filename){\r\n    final String demoDir = getJRobinDemoDirectory();\r\n    if (demoDir != null) {\r\n        return demoDir + filename;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.i2p.router.transport.FIFOBandwidthLimiter.locked_satisfyInboundUnlimited",
	"Comment": "there are no limits, so just give every inbound request whatever they want",
	"Method": "void locked_satisfyInboundUnlimited(List<Request> satisfied){\r\n    while (!_pendingInboundRequests.isEmpty()) {\r\n        SimpleRequest req = _pendingInboundRequests.remove(0);\r\n        int allocated = req.getPendingRequested();\r\n        _totalAllocatedInboundBytes.addAndGet(allocated);\r\n        req.allocateBytes(allocated);\r\n        satisfied.add(req);\r\n        long waited = now() - req.getRequestTime();\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"Granting inbound request \" + req + \" fully (waited \" + waited + \"ms) pending \" + _pendingInboundRequests.size());\r\n        if (waited > 10)\r\n            _context.statManager().addRateData(\"bwLimiter.inboundDelayedTime\", waited);\r\n    }\r\n}"
}, {
	"Path": "io.helidon.security.oidc.common.OidcConfig.appClient",
	"Comment": "client with configured proxy and security of this oidc client.",
	"Method": "Client appClient(){\r\n    return appClient;\r\n}"
}, {
	"Path": "net.i2p.stat.Rate.getLastTotalEventTime",
	"Comment": "in the last full period, how much of the time was spent doing the events?",
	"Method": "long getLastTotalEventTime(){\r\n    return _lastTotalEventTime;\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.util.yaml.YamlHelper.findLastKnownKeyInFile",
	"Comment": "find last known keyvalue of key path, so that we can merge new incoming keys",
	"Method": "Pair<YAMLKeyValue, String[]> findLastKnownKeyInFile(YAMLFile file,String keys){\r\n    YAMLKeyValue last = null;\r\n    YAMLMapping mapping = ObjectUtils.tryCast(file.getDocuments().get(0).getTopLevelValue(), YAMLMapping.class);\r\n    for (int i = 0; i < keys.length; i++) {\r\n        String s = keys[i];\r\n        if (mapping == null) {\r\n            return Pair.create(last, Arrays.copyOfRange(keys, i, keys.length));\r\n        }\r\n        YAMLKeyValue keyValue = mapping.getKeyValueByKey(s);\r\n        if (keyValue == null) {\r\n            return Pair.create(last, Arrays.copyOfRange(keys, i, keys.length));\r\n        }\r\n        last = keyValue;\r\n        mapping = ObjectUtils.tryCast(keyValue.getValue(), YAMLMapping.class);\r\n    }\r\n    return Pair.create(last, new String[] {});\r\n}"
}, {
	"Path": "com.netflix.hollow.api.codegen.CodeGeneratorConfig.initWithNextMajorVersionDefaults_V3",
	"Comment": "make it easier to automatically use defaults for next major version",
	"Method": "void initWithNextMajorVersionDefaults_V3(){\r\n    usePackageGrouping = true;\r\n    useBooleanFieldErgonomics = true;\r\n    reservePrimaryKeyIndexForTypeWithPrimaryKey = true;\r\n    useHollowPrimitiveTypes = true;\r\n    restrictApiToFieldType = true;\r\n    useVerboseToString = true;\r\n}"
}, {
	"Path": "net.i2p.router.client.ClientMessageEventListener.handleReceiveEnd",
	"Comment": "the client told us that the message has been received completely.this currentlydoes not do any security checking prior to removing the message from the pending queue, though it should.",
	"Method": "void handleReceiveEnd(ReceiveMessageEndMessage message){\r\n    _runner.removePayload(new MessageId(message.getMessageId()));\r\n}"
}, {
	"Path": "org.klomp.snark.dht.KRPC.clear",
	"Comment": "clears the tracker and dht data.call after saving dht data to disk.",
	"Method": "void clear(){\r\n    _tracker.stop();\r\n    _knownNodes.clear();\r\n}"
}, {
	"Path": "net.i2p.sam.SAMv3Handler.stopHandling",
	"Comment": "stop the sam handler, close the socket,\tunregister with the bridge. overridden to not close the client socket if stolen.",
	"Method": "void stopHandling(){\r\n    if (_log.shouldInfo())\r\n        _log.info(\"Stopping (stolen? \" + stolenSocket + \"): \" + this, new Exception(\"I did it\"));\r\n    synchronized (stopLock) {\r\n        stopHandler = true;\r\n    }\r\n    if (!stolenSocket) {\r\n        try {\r\n            closeClientSocket();\r\n        } catch (IOException e) {\r\n        }\r\n    }\r\n    bridge.unregister(this);\r\n}"
}, {
	"Path": "com.netflix.hollow.api.codegen.HollowCodeGenerationCompileUtil.cleanupFolder",
	"Comment": "cleanup specified folder based on file older than specified timestamp",
	"Method": "void cleanupFolder(File folder,Long timestamp){\r\n    System.out.println(\"Cleaning up folder: \" + folder.getAbsolutePath());\r\n    if (folder.exists()) {\r\n        for (File file : folder.listFiles()) {\r\n            if (file.isDirectory()) {\r\n                cleanupFolder(file, timestamp);\r\n                file.delete();\r\n            } else if (timestamp == null || (timestamp.longValue() - file.lastModified() >= 5000)) {\r\n                System.out.println(String.format(\"\\t deleting file: %s, lastModified=%s\", file.getName(), new Date(file.lastModified())));\r\n                file.delete();\r\n            }\r\n        }\r\n        folder.delete();\r\n    }\r\n}"
}, {
	"Path": "net.i2p.data.i2np.TunnelGatewayMessage.writeMessageBody",
	"Comment": "write the message body to the output array, starting at the given index",
	"Method": "int writeMessageBody(byte out,int curIndex){\r\n    if ((_tunnelId == null) || ((_msg == null) && (_msgData == null))) {\r\n        _log.log(Log.CRIT, \"failing to write out gateway message\");\r\n        throw new I2NPMessageException(\"Not enough data to write out (id=\" + _tunnelId + \" data=\" + _msg + \")\");\r\n    }\r\n    DataHelper.toLong(out, curIndex, 4, _tunnelId.getTunnelId());\r\n    curIndex += 4;\r\n    synchronized (this) {\r\n        if (_msgData == null) {\r\n            _msgData = _msg.toByteArray();\r\n            _msg = null;\r\n        }\r\n    }\r\n    DataHelper.toLong(out, curIndex, 2, _msgData.length);\r\n    curIndex += 2;\r\n    if (curIndex + _msgData.length > out.length) {\r\n        String txt = \"output buffer too small idx: \" + curIndex + \" len: \" + _msgData.length + \" outlen: \" + out.length;\r\n        _log.error(txt);\r\n        throw new I2NPMessageException(txt);\r\n    }\r\n    System.arraycopy(_msgData, 0, out, curIndex, _msgData.length);\r\n    curIndex += _msgData.length;\r\n    return curIndex;\r\n}"
}, {
	"Path": "net.i2p.router.transport.ntcp.NTCPConnection.prepareNextWriteNTCP2",
	"Comment": "prepare the next i2np message for transmission.this should be run fromthe writer thread pool.caller must synchronize.",
	"Method": "void prepareNextWriteNTCP2(PrepBuffer buf){\r\n    int size = OutboundNTCP2State.MAC_SIZE;\r\n    List<Block> blocks = new ArrayList<Block>(4);\r\n    long now = _context.clock().now();\r\n    synchronized (_currentOutbound) {\r\n        if (!_currentOutbound.isEmpty()) {\r\n            if (_log.shouldLog(Log.INFO))\r\n                _log.info(\"attempt for multiple outbound messages with \" + _currentOutbound.size() + \" already waiting and \" + _outbound.size() + \" queued\");\r\n            return;\r\n        }\r\n        OutNetMessage msg;\r\n        while (true) {\r\n            msg = _outbound.poll();\r\n            if (msg == null)\r\n                return;\r\n            if (msg.getExpiration() >= now)\r\n                break;\r\n            if (_log.shouldWarn())\r\n                _log.warn(\"dropping message expired on queue: \" + msg + \" on \" + this);\r\n            _transport.afterSend(msg, false, false, msg.getLifetime());\r\n        }\r\n        _currentOutbound.add(msg);\r\n        I2NPMessage m = msg.getMessage();\r\n        Block block = new NTCP2Payload.I2NPBlock(m);\r\n        blocks.add(block);\r\n        size += block.getTotalLength();\r\n        if (size < NTCP2_PREFERRED_PAYLOAD_MAX) {\r\n            while (true) {\r\n                msg = _outbound.peek();\r\n                if (msg == null)\r\n                    break;\r\n                m = msg.getMessage();\r\n                int msz = m.getMessageSize() - 7;\r\n                if (size + msz > NTCP2_PREFERRED_PAYLOAD_MAX)\r\n                    break;\r\n                OutNetMessage msg2 = _outbound.poll();\r\n                if (msg2 == null)\r\n                    break;\r\n                if (msg2 != msg) {\r\n                    _outbound.offer(msg2);\r\n                    break;\r\n                }\r\n                if (msg.getExpiration() >= now) {\r\n                    block = new NTCP2Payload.I2NPBlock(m);\r\n                    blocks.add(block);\r\n                    size += NTCP2Payload.BLOCK_HEADER_SIZE + msz;\r\n                } else {\r\n                    if (_log.shouldWarn())\r\n                        _log.warn(\"dropping message expired on queue: \" + msg + \" on \" + this);\r\n                    _transport.afterSend(msg, false, false, msg.getLifetime());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (_nextMetaTime <= now && size + (NTCP2Payload.BLOCK_HEADER_SIZE + 4) <= BUFFER_SIZE) {\r\n        Block block = new NTCP2Payload.DateTimeBlock(_context);\r\n        blocks.add(block);\r\n        size += block.getTotalLength();\r\n        _nextMetaTime = now + (META_FREQUENCY / 2) + _context.random().nextInt(META_FREQUENCY / 2);\r\n        if (_log.shouldLog(Log.DEBUG))\r\n            _log.debug(\"Sending NTCP2 datetime block\");\r\n    }\r\n    if (_nextInfoTime <= now && size + 1024 <= BUFFER_SIZE) {\r\n        RouterInfo ri = _context.router().getRouterInfo();\r\n        Block block = new NTCP2Payload.RIBlock(ri, false);\r\n        int sz = block.getTotalLength();\r\n        if (size + sz <= BUFFER_SIZE) {\r\n            blocks.add(block);\r\n            size += sz;\r\n            _nextInfoTime = now + (INFO_FREQUENCY / 2) + _context.random().nextInt(INFO_FREQUENCY);\r\n            if (_log.shouldDebug())\r\n                _log.debug(\"SENDING NTCP2 RI block\");\r\n        }\r\n    }\r\n    int availForPad = BUFFER_SIZE - (size + NTCP2Payload.BLOCK_HEADER_SIZE);\r\n    if (availForPad > 0) {\r\n        int padlen = getPaddingSize(size, availForPad);\r\n        Block block = new NTCP2Payload.PaddingBlock(padlen);\r\n        blocks.add(block);\r\n        size += block.getTotalLength();\r\n    }\r\n    byte[] tmp = size <= BUFFER_SIZE ? buf.unencrypted : new byte[size];\r\n    sendNTCP2(tmp, blocks);\r\n}"
}]