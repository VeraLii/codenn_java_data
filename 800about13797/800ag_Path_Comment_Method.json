[{
	"Path": "com.itextpdf.text.pdf.ocg.OCGParser.println",
	"Comment": "writes a pdf object to the outputstream, followed by a newline character.",
	"Method": "void println(PdfObject o){\r\n    o.toPdf(null, baos);\r\n    baos.write('\\n');\r\n}"
}, {
	"Path": "com.structurizr.view.SystemContextView.addNearestNeighbours",
	"Comment": "adds all software systems and people that are directly connected to the specified element.",
	"Method": "void addNearestNeighbours(Element element){\r\n    if (element == null) {\r\n        throw new IllegalArgumentException(\"An element must be specified.\");\r\n    }\r\n    if (element instanceof Person || element instanceof SoftwareSystem) {\r\n        super.addNearestNeighbours(element, Person.class);\r\n        super.addNearestNeighbours(element, SoftwareSystem.class);\r\n    } else {\r\n        throw new IllegalArgumentException(\"A person or software system must be specified.\");\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.ByteBuffer.ensureCapacity",
	"Comment": "ensures the requested capacity by increasing the buffer size when the\tcurrent length is exceeded.",
	"Method": "void ensureCapacity(int requestedLength){\r\n    if (requestedLength > buffer.length) {\r\n        byte[] oldBuf = buffer;\r\n        buffer = new byte[oldBuf.length * 2];\r\n        System.arraycopy(oldBuf, 0, buffer, 0, oldBuf.length);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfAWriter.setOutputIntents",
	"Comment": "copies the output intent dictionary from other document to this one.",
	"Method": "void setOutputIntents(String outputConditionIdentifier,String outputCondition,String registryName,String info,ICC_Profile colorProfile,boolean setOutputIntents,PdfReader reader,boolean checkExistence){\r\n    PdfDictionary catalog = reader.catalog;\r\n    PdfArray outs = catalog.getAsArray(PdfName.OUTPUTINTENTS);\r\n    if (outs == null)\r\n        return false;\r\n    if (outs.size() == 0)\r\n        return false;\r\n    PdfDictionary outa = outs.getAsDict(0);\r\n    PdfObject obj = PdfReader.getPdfObject(outa.get(PdfName.S));\r\n    if (obj == null || !PdfName.GTS_PDFA1.equals(obj))\r\n        return false;\r\n    if (checkExistence)\r\n        return true;\r\n    PRStream stream = (PRStream) PdfReader.getPdfObject(outa.get(PdfName.DESTOUTPUTPROFILE));\r\n    byte[] destProfile = null;\r\n    if (stream != null) {\r\n        destProfile = PdfReader.getStreamBytes(stream);\r\n    }\r\n    setOutputIntents(getNameString(outa, PdfName.OUTPUTCONDITIONIDENTIFIER), getNameString(outa, PdfName.OUTPUTCONDITION), getNameString(outa, PdfName.REGISTRYNAME), getNameString(outa, PdfName.INFO), destProfile);\r\n    return true;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentByte.endLayer",
	"Comment": "ends a layer controlled graphic block. it will end the most recent open block.",
	"Method": "void endLayer(){\r\n    int n = 1;\r\n    if (layerDepth != null && !layerDepth.isEmpty()) {\r\n        n = layerDepth.get(layerDepth.size() - 1).intValue();\r\n        layerDepth.remove(layerDepth.size() - 1);\r\n    } else {\r\n        throw new IllegalPdfSyntaxException(MessageLocalization.getComposedMessage(\"unbalanced.layer.operators\"));\r\n    }\r\n    while (n-- > 0) content.append(\"EMC\").append_i(separator);\r\n}"
}, {
	"Path": "com.example.containeranalysis.Samples.getDiscoveryInfo",
	"Comment": "retrieves and prints the discovery occurrence created for a specified imagethe discovery occurrence contains information about the initial scan on the image",
	"Method": "void getDiscoveryInfo(GrafeasV1Beta1Client client,String imageUrl,String projectId){\r\n    String filterStr = \"kind=\\\"DISCOVERY\\\" AND resourceUrl=\\\"\" + imageUrl + \"\\\"\";\r\n    final String projectName = ProjectName.format(projectId);\r\n    for (Occurrence o : client.listOccurrences(projectName, filterStr).iterateAll()) {\r\n        System.out.println(o);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.XfaForm.setXfaPresent",
	"Comment": "sets the xfa form flag signaling that this is a valid xfa form.",
	"Method": "void setXfaPresent(boolean xfaPresent){\r\n    this.xfaPresent = xfaPresent;\r\n}"
}, {
	"Path": "com.example.firestore.snippets.QueryDataSnippets.prepareExamples",
	"Comment": "creates cities collection and add sample documents to test queries.",
	"Method": "void prepareExamples(){\r\n    CollectionReference cities = db.collection(\"cities\");\r\n    List<ApiFuture<WriteResult>> futures = new ArrayList();\r\n    futures.add(cities.document(\"SF\").set(new City(\"San Francisco\", \"CA\", \"USA\", false, 860000L, Arrays.asList(\"west_coast\", \"norcal\"))));\r\n    futures.add(cities.document(\"LA\").set(new City(\"Los Angeles\", \"CA\", \"USA\", false, 3900000L, Arrays.asList(\"west_coast\", \"socal\"))));\r\n    futures.add(cities.document(\"DC\").set(new City(\"Washington D.C.\", null, \"USA\", true, 680000L, Arrays.asList(\"east_coast\"))));\r\n    futures.add(cities.document(\"TOK\").set(new City(\"Tokyo\", null, \"Japan\", true, 9000000L, Arrays.asList(\"kanto\", \"honshu\"))));\r\n    futures.add(cities.document(\"BJ\").set(new City(\"Beijing\", null, \"China\", true, 21500000L, Arrays.asList(\"jingjinji\", \"hebei\"))));\r\n    ApiFutures.allAsList(futures).get();\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.pipeline.AbstractPipeline.close",
	"Comment": "just calls getnext.override this to get notified on encountered closing tags.",
	"Method": "Pipeline<?> close(WorkerContext context,Tag t,ProcessObject po){\r\n    return getNext();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPRow.getCells",
	"Comment": "returns the array of cells in the row. please be extremely careful withthis method. use the cells as read only objects.",
	"Method": "PdfPCell[] getCells(){\r\n    return cells;\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.pipeline.AbstractPipeline.getLocalContext",
	"Comment": "returns the local context for this class using getcontextkey, override\tthis together with getcontextkey to change the key usage in case you want\tto add multiple identical pipelines to the worker.",
	"Method": "T getLocalContext(WorkerContext context){\r\n    try {\r\n        CustomContext cc = context.get(getContextKey());\r\n        if (null != cc) {\r\n            return (T) cc;\r\n        }\r\n        throw new PipelineException(String.format(LocaleMessages.getInstance().getMessage(LocaleMessages.OWN_CONTEXT_404), this.getClass().getName()));\r\n    } catch (NoCustomContextException e) {\r\n        throw new PipelineException(String.format(LocaleMessages.getInstance().getMessage(LocaleMessages.OWN_CONTEXT_404), this.getClass().getName()), e);\r\n    }\r\n}"
}, {
	"Path": "com.sixt.service.framework.registry.consul.RegistrationMonitorWorker.diffServiceStatus",
	"Comment": "create diff to send to loadbalancer, and also update our baseline.",
	"Method": "LoadBalancerUpdate diffServiceStatus(List<ConsulHealthEntry> healthEntries){\r\n    LoadBalancerUpdate retval = new LoadBalancerUpdate();\r\n    for (String serviceId : discoveredServices.keySet()) {\r\n        boolean found = false;\r\n        for (ConsulHealthEntry health : healthEntries) {\r\n            if (health.getId().equals(serviceId)) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            ConsulHealthEntry service = discoveredServices.get(serviceId);\r\n            if (!service.getStatus().equals(ConsulHealthEntry.Status.Critical)) {\r\n                service.setStatus(ConsulHealthEntry.Status.Critical);\r\n                retval.addDeletedService(newServiceEndpoint(service));\r\n            }\r\n        }\r\n    }\r\n    for (ConsulHealthEntry entry : healthEntries) {\r\n        if (!discoveredServices.containsKey(entry.getId())) {\r\n            retval.addNewService(newServiceEndpoint(entry));\r\n            discoveredServices.put(entry.getId(), entry);\r\n        }\r\n    }\r\n    for (ConsulHealthEntry health : healthEntries) {\r\n        ConsulHealthEntry previous = discoveredServices.get(health.getId());\r\n        if (previous == null) {\r\n            continue;\r\n        }\r\n        if (health.getStatus().equals(ConsulHealthEntry.Status.Passing) && previous.getStatus().equals(ConsulHealthEntry.Status.Critical)) {\r\n            previous.setStatus(ConsulHealthEntry.Status.Passing);\r\n            retval.addUpdatedService(newServiceEndpoint(previous));\r\n        } else if (!health.getStatus().equals(ConsulHealthEntry.Status.Passing) && previous.getStatus().equals(ConsulHealthEntry.Status.Passing)) {\r\n            previous.setStatus(ConsulHealthEntry.Status.Critical);\r\n            retval.addUpdatedService(newServiceEndpoint(previous));\r\n        }\r\n    }\r\n    return retval;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.setUserProperties",
	"Comment": "sets the flag indicating the presence of structure elements that contain user properties attributes.",
	"Method": "void setUserProperties(boolean userProperties){\r\n    this.userProperties = userProperties;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfArray.getAsStream",
	"Comment": "returns a pdfobject as a pdfstream,resolving indirect references.the object corresponding to the specified index is retrieved andresolved to a direct object.if it is a pdfstream, it is cast down and returned as such.otherwise null is returned.",
	"Method": "PdfStream getAsStream(int idx){\r\n    PdfStream stream = null;\r\n    PdfObject orig = getDirectObject(idx);\r\n    if (orig != null && orig.isStream())\r\n        stream = (PdfStream) orig;\r\n    return stream;\r\n}"
}, {
	"Path": "com.itextpdf.testutils.ITextTest.getCmpPdf",
	"Comment": "gets the name of the compare pdf file.this name will be passed to comparepdf method.",
	"Method": "String getCmpPdf(){\r\n    return \"\";\r\n}"
}, {
	"Path": "com.itextpdf.text.html.simpleparser.TableWrapper.createTable",
	"Comment": "creates a new pdfptable based on the info assembledin the table stub.",
	"Method": "PdfPTable createTable(){\r\n    if (rows.isEmpty())\r\n        return new PdfPTable(1);\r\n    int ncol = 0;\r\n    for (PdfPCell pc : rows.get(0)) {\r\n        ncol += pc.getColspan();\r\n    }\r\n    PdfPTable table = new PdfPTable(ncol);\r\n    String width = styles.get(HtmlTags.WIDTH);\r\n    if (width == null)\r\n        table.setWidthPercentage(100);\r\n    else {\r\n        if (width.endsWith(\"%\"))\r\n            table.setWidthPercentage(Float.parseFloat(width.substring(0, width.length() - 1)));\r\n        else {\r\n            table.setTotalWidth(Float.parseFloat(width));\r\n            table.setLockedWidth(true);\r\n        }\r\n    }\r\n    String alignment = styles.get(HtmlTags.ALIGN);\r\n    int align = Element.ALIGN_LEFT;\r\n    if (alignment != null) {\r\n        align = HtmlUtilities.alignmentValue(alignment);\r\n    }\r\n    table.setHorizontalAlignment(align);\r\n    try {\r\n        if (colWidths != null)\r\n            table.setWidths(colWidths);\r\n    } catch (Exception e) {\r\n    }\r\n    for (List<PdfPCell> col : rows) {\r\n        for (PdfPCell pc : col) {\r\n            table.addCell(pc);\r\n        }\r\n    }\r\n    return table;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfGState.setOverPrintMode",
	"Comment": "sets the flag whether to toggle knockout behavior for overprinted objects.",
	"Method": "void setOverPrintMode(int opm){\r\n    put(PdfName.OPM, new PdfNumber(opm == 0 ? 0 : 1));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.collection.PdfCollection.setInitialDocument",
	"Comment": "identifies the document that will be initially presented\tin the user interface.",
	"Method": "void setInitialDocument(String description){\r\n    put(PdfName.D, new PdfString(description, null));\r\n}"
}, {
	"Path": "com.itextpdf.text.html.simpleparser.ElementFactory.getHyphenation",
	"Comment": "gets a hyphenationevent based on the hyphenation entry in\tthe hierarchy chain.",
	"Method": "HyphenationEvent getHyphenation(ChainedProperties chain){\r\n    String value = chain.getProperty(HtmlTags.HYPHENATION);\r\n    if (value == null || value.length() == 0) {\r\n        return null;\r\n    }\r\n    int pos = value.indexOf('_');\r\n    if (pos == -1) {\r\n        return new HyphenationAuto(value, null, 2, 2);\r\n    }\r\n    String lang = value.substring(0, pos);\r\n    String country = value.substring(pos + 1);\r\n    pos = country.indexOf(',');\r\n    if (pos == -1) {\r\n        return new HyphenationAuto(lang, country, 2, 2);\r\n    }\r\n    int leftMin;\r\n    int rightMin = 2;\r\n    value = country.substring(pos + 1);\r\n    country = country.substring(0, pos);\r\n    pos = value.indexOf(',');\r\n    if (pos == -1) {\r\n        leftMin = Integer.parseInt(value);\r\n    } else {\r\n        leftMin = Integer.parseInt(value.substring(0, pos));\r\n        rightMin = Integer.parseInt(value.substring(pos + 1));\r\n    }\r\n    return new HyphenationAuto(lang, country, leftMin, rightMin);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.getDescentPoint",
	"Comment": "gets the descent of a string in points. the descent will always beless than or equal to zero even if all the characters have an higher descent.",
	"Method": "float getDescentPoint(String text,float fontSize){\r\n    return getDescent(text) * 0.001f * fontSize;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.readFDSelect",
	"Comment": "read the fdselect of the font and compute the array and its length",
	"Method": "void readFDSelect(int Font){\r\n    int NumOfGlyphs = fonts[Font].nglyphs;\r\n    int[] FDSelect = new int[NumOfGlyphs];\r\n    seek(fonts[Font].fdselectOffset);\r\n    fonts[Font].FDSelectFormat = getCard8();\r\n    switch(fonts[Font].FDSelectFormat) {\r\n        case 0:\r\n            for (int i = 0; i < NumOfGlyphs; i++) {\r\n                FDSelect[i] = getCard8();\r\n            }\r\n            fonts[Font].FDSelectLength = fonts[Font].nglyphs + 1;\r\n            break;\r\n        case 3:\r\n            int nRanges = getCard16();\r\n            int l = 0;\r\n            int first = getCard16();\r\n            for (int i = 0; i < nRanges; i++) {\r\n                int fd = getCard8();\r\n                int last = getCard16();\r\n                int steps = last - first;\r\n                for (int k = 0; k < steps; k++) {\r\n                    FDSelect[l] = fd;\r\n                    l++;\r\n                }\r\n                first = last;\r\n            }\r\n            fonts[Font].FDSelectLength = 1 + 2 + nRanges * 3 + 2;\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    fonts[Font].FDSelect = FDSelect;\r\n}"
}, {
	"Path": "com.machinepublishers.glass.ui.monocle.KeyState.getModifiers",
	"Comment": "returns a mask of modifiers defined in keyevent for the keys pressedin this state.",
	"Method": "int getModifiers(){\r\n    return modifiers;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfArray.getAsDict",
	"Comment": "returns a pdfobject as a pdfdictionary,resolving indirect references.the object corresponding to the specified index is retrieved andresolvedto a direct object.if it is a pdfdictionary, it is cast down and returned as such.otherwise null is returned.",
	"Method": "PdfDictionary getAsDict(int idx){\r\n    PdfDictionary dict = null;\r\n    PdfObject orig = getDirectObject(idx);\r\n    if (orig != null && orig.isDictionary())\r\n        dict = (PdfDictionary) orig;\r\n    return dict;\r\n}"
}, {
	"Path": "software.amazon.ion.TimestampTest.testValueOfWithMissingFraction",
	"Comment": "todo this replicates a file in the test data suite.we should really be scanning all relevant data files.",
	"Method": "void testValueOfWithMissingFraction(){\r\n    Timestamp.valueOf(\"2010-11-17T12:34:56.Z\");\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfLayer.setZoom",
	"Comment": "specifies a range of magnifications at which the contentin this optional content group is best viewed.",
	"Method": "void setZoom(float min,float max){\r\n    if (min <= 0 && max < 0)\r\n        return;\r\n    PdfDictionary usage = getUsage();\r\n    PdfDictionary dic = new PdfDictionary();\r\n    if (min > 0)\r\n        dic.put(PdfName.MIN_LOWER_CASE, new PdfNumber(min));\r\n    if (max >= 0)\r\n        dic.put(PdfName.MAX_LOWER_CASE, new PdfNumber(max));\r\n    usage.put(PdfName.ZOOM, dic);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPCell.setRotation",
	"Comment": "sets the rotation of the cell. possible values are 0, 90, 180 and 270.",
	"Method": "void setRotation(int rotation){\r\n    rotation %= 360;\r\n    if (rotation < 0) {\r\n        rotation += 360;\r\n    }\r\n    if (rotation % 90 != 0) {\r\n        throw new IllegalArgumentException(MessageLocalization.getComposedMessage(\"rotation.must.be.a.multiple.of.90\"));\r\n    }\r\n    this.rotation = rotation;\r\n}"
}, {
	"Path": "com.google.datastore.snippets.TaskList.formatTasks",
	"Comment": "converts a list of task entities to a list of formatted task strings.",
	"Method": "List<String> formatTasks(Iterator<Entity> tasks){\r\n    List<String> strings = new ArrayList();\r\n    while (tasks.hasNext()) {\r\n        Entity task = tasks.next();\r\n        if (task.getBoolean(\"done\")) {\r\n            strings.add(String.format(\"%d : %s (done)\", task.getKey().getId(), task.getString(\"description\")));\r\n        } else {\r\n            strings.add(String.format(\"%d : %s (created %s)\", task.getKey().getId(), task.getString(\"description\"), task.getTimestamp(\"created\")));\r\n        }\r\n    }\r\n    return strings;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfConcatenate.getWriter",
	"Comment": "gets the pdfcopy instance so that you can add bookmarks or change preferences before you close pdfconcatenate.",
	"Method": "PdfCopy getWriter(){\r\n    return copy;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.addNamedDestinations",
	"Comment": "adds named destinations in bulk.valid keys and values of the map can be found in the mapthat is created by simplenameddestination.",
	"Method": "void addNamedDestinations(Map<String, String> map,int page_offset){\r\n    int page;\r\n    String dest;\r\n    PdfDestination destination;\r\n    for (Map.Entry<String, String> entry : map.entrySet()) {\r\n        dest = entry.getValue();\r\n        page = Integer.parseInt(dest.substring(0, dest.indexOf(\" \")));\r\n        destination = new PdfDestination(dest.substring(dest.indexOf(\" \") + 1));\r\n        addNamedDestination(entry.getKey(), page + page_offset, destination);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PRAcroForm.pushAttrib",
	"Comment": "stack a level of dictionary. merge in a dictionary from this level",
	"Method": "void pushAttrib(PdfDictionary dict){\r\n    PdfDictionary dic = null;\r\n    if (!stack.isEmpty()) {\r\n        dic = stack.get(stack.size() - 1);\r\n    }\r\n    dic = mergeAttrib(dic, dict);\r\n    stack.add(dic);\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.CDL.toJSONArray",
	"Comment": "produce a jsonarray of jsonobjects from a comma delimited text stringusing a supplied jsonarray as the source of element names.",
	"Method": "JSONArray toJSONArray(String string,JSONArray toJSONArray,JSONTokener x,JSONArray toJSONArray,JSONArray names,String string,JSONArray toJSONArray,JSONArray names,JSONTokener x){\r\n    if (names == null || names.length() == 0) {\r\n        return null;\r\n    }\r\n    JSONArray ja = new JSONArray();\r\n    for (; ; ) {\r\n        JSONObject jo = rowToJSONObject(names, x);\r\n        if (jo == null) {\r\n            break;\r\n        }\r\n        ja.put(jo);\r\n    }\r\n    if (ja.length() == 0) {\r\n        return null;\r\n    }\r\n    return ja;\r\n}"
}, {
	"Path": "com.itextpdf.text.FontFactory.registerDirectories",
	"Comment": "register fonts in some probable directories. it usually works in windows,linux and solaris.",
	"Method": "int registerDirectories(){\r\n    return fontImp.registerDirectories();\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.pipeline.AbstractPipeline.content",
	"Comment": "just calls getnext.override this to get notified on encountered content.",
	"Method": "Pipeline<?> content(WorkerContext ctx,Tag currentTag,String text,ProcessObject po){\r\n    return getNext();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfArray.set",
	"Comment": "overwrites a specified location of the array, returning the previousvalue",
	"Method": "PdfObject set(int idx,PdfObject obj){\r\n    return arrayList.set(idx, obj);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.collection.PdfTargetDictionary.setEmbeddedFileName",
	"Comment": "if this dictionary refers to a child that is a document level attachment,\tyou need to specify the name that was used to attach the document.",
	"Method": "void setEmbeddedFileName(String target){\r\n    put(PdfName.N, new PdfString(target, null));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.util.PdfResourceCounter.process",
	"Comment": "processes an object. if the object is indirect, it is added to thelist of resources. if not, it is just processed.",
	"Method": "void process(PdfObject object){\r\n    PRIndirectReference ref = object.getIndRef();\r\n    if (ref == null || resources.put(ref.getNumber(), object) == null) {\r\n        loopOver(object);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfSignatureAppearance.setLayer4Text",
	"Comment": "sets the text identifying the signature status. will be ignored if acro6layers is true.",
	"Method": "void setLayer4Text(String text){\r\n    layer4Text = text;\r\n}"
}, {
	"Path": "com.structurizr.view.DynamicView.getElementId",
	"Comment": "gets the id of the software system or container associated with this view.",
	"Method": "String getElementId(){\r\n    if (this.element != null) {\r\n        return element.getId();\r\n    } else {\r\n        return this.elementId;\r\n    }\r\n}"
}, {
	"Path": "com.structurizr.model.Model.modifyRelationship",
	"Comment": "provides a way for the description and technology to be modified on an existing relationship.",
	"Method": "void modifyRelationship(Relationship relationship,String description,String technology){\r\n    if (relationship == null) {\r\n        throw new IllegalArgumentException(\"A relationship must be specified.\");\r\n    }\r\n    Relationship newRelationship = new Relationship(relationship.getSource(), relationship.getDestination(), description, technology, relationship.getInteractionStyle());\r\n    if (!relationship.getSource().has(newRelationship)) {\r\n        relationship.setDescription(description);\r\n        relationship.setTechnology(technology);\r\n    } else {\r\n        throw new IllegalArgumentException(\"This relationship exists already: \" + newRelationship);\r\n    }\r\n}"
}, {
	"Path": "com.google.appengine.samples.TaskQueueConfigTest.doTest",
	"Comment": "second test because there will already be a task with the given name.",
	"Method": "void doTest(){\r\n    QueueFactory.getQueue(\"my-queue-name\").add(TaskOptions.Builder.withTaskName(\"task29\"));\r\n    Thread.sleep(1000);\r\n    LocalTaskQueue ltq = LocalTaskQueueTestConfig.getLocalTaskQueue();\r\n    QueueStateInfo qsi = ltq.getQueueStateInfo().get(QueueFactory.getQueue(\"my-queue-name\").getQueueName());\r\n    assertEquals(1, qsi.getTaskInfo().size());\r\n    assertEquals(\"task29\", qsi.getTaskInfo().get(0).getTaskName());\r\n}"
}, {
	"Path": "com.itextpdf.awt.geom.gl.Crossing.intersectQuad",
	"Comment": "returns how many times rectangle stripe cross quad curve or the are intersect",
	"Method": "int intersectQuad(double x1,double y1,double cx,double cy,double x2,double y2,double rx1,double ry1,double rx2,double ry2){\r\n    if ((rx2 < x1 && rx2 < cx && rx2 < x2) || (rx1 > x1 && rx1 > cx && rx1 > x2) || (ry1 > y1 && ry1 > cy && ry1 > y2)) {\r\n        return 0;\r\n    }\r\n    if (ry2 < y1 && ry2 < cy && ry2 < y2 && rx1 != x1 && rx1 != x2) {\r\n        if (x1 < x2) {\r\n            return x1 < rx1 && rx1 < x2 ? 1 : 0;\r\n        }\r\n        return x2 < rx1 && rx1 < x1 ? -1 : 0;\r\n    }\r\n    QuadCurve c = new QuadCurve(x1, y1, cx, cy, x2, y2);\r\n    double px1 = rx1 - x1;\r\n    double py1 = ry1 - y1;\r\n    double px2 = rx2 - x1;\r\n    double py2 = ry2 - y1;\r\n    double[] res1 = new double[3];\r\n    double[] res2 = new double[3];\r\n    int rc1 = c.solvePoint(res1, px1);\r\n    int rc2 = c.solvePoint(res2, px2);\r\n    if (rc1 == 0 && rc2 == 0) {\r\n        return 0;\r\n    }\r\n    double minX = px1 - DELTA;\r\n    double maxX = px2 + DELTA;\r\n    double[] bound = new double[28];\r\n    int bc = 0;\r\n    bc = c.addBound(bound, bc, res1, rc1, minX, maxX, false, 0);\r\n    bc = c.addBound(bound, bc, res2, rc2, minX, maxX, false, 1);\r\n    rc2 = c.solveExtrem(res2);\r\n    bc = c.addBound(bound, bc, res2, rc2, minX, maxX, true, 2);\r\n    if (rx1 < x1 && x1 < rx2) {\r\n        bound[bc++] = 0.0;\r\n        bound[bc++] = 0.0;\r\n        bound[bc++] = 0.0;\r\n        bound[bc++] = 4;\r\n    }\r\n    if (rx1 < x2 && x2 < rx2) {\r\n        bound[bc++] = 1.0;\r\n        bound[bc++] = c.ax;\r\n        bound[bc++] = c.ay;\r\n        bound[bc++] = 5;\r\n    }\r\n    int cross = crossBound(bound, bc, py1, py2);\r\n    if (cross != UNKNOWN) {\r\n        return cross;\r\n    }\r\n    return c.cross(res1, rc1, py1, py2);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfLayerMembership.getPdfObject",
	"Comment": "gets the dictionary representing the membership layer. it just returns this.",
	"Method": "PdfObject getPdfObject(){\r\n    return this;\r\n}"
}, {
	"Path": "com.example.Snippets.restoreCryptoKeyVersion",
	"Comment": "restores the given version of a crypto key that is currently scheduled for destruction.",
	"Method": "CryptoKeyVersion restoreCryptoKeyVersion(String projectId,String locationId,String keyRingId,String cryptoKeyId,String version){\r\n    CloudKMS kms = createAuthorizedClient();\r\n    String cryptoKeyVersion = String.format(\"projects/%s/locations/%s/keyRings/%s/cryptoKeys/%s/cryptoKeyVersions/%s\", projectId, locationId, keyRingId, cryptoKeyId, version);\r\n    RestoreCryptoKeyVersionRequest restoreRequest = new RestoreCryptoKeyVersionRequest();\r\n    CryptoKeyVersion restored = kms.projects().locations().keyRings().cryptoKeys().cryptoKeyVersions().restore(cryptoKeyVersion, restoreRequest).execute();\r\n    System.out.println(restored);\r\n    return restored;\r\n}"
}, {
	"Path": "com.example.texttospeech.SynthesizeFile.synthesizeSsmlFile",
	"Comment": "demonstrates using the text to speech client to synthesize a text file or ssml file.",
	"Method": "void synthesizeSsmlFile(String ssmlFile){\r\n    try (TextToSpeechClient textToSpeechClient = TextToSpeechClient.create()) {\r\n        String contents = new String(Files.readAllBytes(Paths.get(ssmlFile)));\r\n        SynthesisInput input = SynthesisInput.newBuilder().setSsml(contents).build();\r\n        VoiceSelectionParams voice = // languageCode = \"en_us\"\r\n        VoiceSelectionParams.newBuilder().setLanguageCode(// ssmlVoiceGender = SsmlVoiceGender.FEMALE\r\n        \"en-US\").setSsmlGender(SsmlVoiceGender.FEMALE).build();\r\n        AudioConfig audioConfig = // MP3 audio.\r\n        AudioConfig.newBuilder().setAudioEncoding(AudioEncoding.MP3).build();\r\n        SynthesizeSpeechResponse response = textToSpeechClient.synthesizeSpeech(input, voice, audioConfig);\r\n        ByteString audioContents = response.getAudioContent();\r\n        try (OutputStream out = new FileOutputStream(\"output.mp3\")) {\r\n            out.write(audioContents.toByteArray());\r\n            System.out.println(\"Audio content written to file \\\"output.mp3\\\"\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.mc.StructureObject.checkStructParent",
	"Comment": "checks if a structparent corresponds with the structparent stored in the object.",
	"Method": "int checkStructParent(int pg,int sp){\r\n    if (pg == pageref && sp == structParent)\r\n        return 1;\r\n    return -1;\r\n}"
}, {
	"Path": "com.structurizr.view.View.getSoftwareSystemId",
	"Comment": "gets the id of the software system this view is associated with.",
	"Method": "String getSoftwareSystemId(){\r\n    if (this.softwareSystem != null) {\r\n        return this.softwareSystem.getId();\r\n    } else {\r\n        return this.softwareSystemId;\r\n    }\r\n}"
}, {
	"Path": "com.sixt.service.framework.rpc.LoadBalancerImpl.getHealthyInstance",
	"Comment": "try to find an endpoint in our primary az.if none found, try further azs.modifies state",
	"Method": "ServiceEndpoint getHealthyInstance(){\r\n    if (!haveEndpoints.get()) {\r\n        try {\r\n            notificationSemaphore.tryAcquire(1, TimeUnit.SECONDS);\r\n        } catch (InterruptedException e) {\r\n        }\r\n    }\r\n    mutex.readLock().lock();\r\n    try {\r\n        for (AvailabilityZone az : availabilityZones) {\r\n            ServiceEndpoint next = az.nextEndpoint();\r\n            if (next != null) {\r\n                logger.debug(\"Returning instance {} for {}\", next.getHostAndPort(), serviceName);\r\n                return next;\r\n            }\r\n        }\r\n        return null;\r\n    } finally {\r\n        mutex.readLock().unlock();\r\n    }\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.zip.Huff.read",
	"Comment": "read bits until a symbol can be identified. the weight of the readsymbol will be incremented.",
	"Method": "int read(BitReader bitreader){\r\n    try {\r\n        this.width = 0;\r\n        Symbol symbol = this.table;\r\n        while (symbol.integer == none) {\r\n            this.width += 1;\r\n            symbol = bitreader.bit() ? symbol.one : symbol.zero;\r\n        }\r\n        tick(symbol.integer);\r\n        if (JSONzip.probe) {\r\n            JSONzip.logchar(symbol.integer, this.width);\r\n        }\r\n        return symbol.integer;\r\n    } catch (Throwable e) {\r\n        throw new JSONException(e);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.ColumnText.getCanvas",
	"Comment": "gets the canvas. if a set of four canvases exists, the textcanvas isreturned.",
	"Method": "PdfContentByte getCanvas(){\r\n    return canvas;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONException.getCause",
	"Comment": "returns the cause of this exception or null if the cause is nonexistentor unknown.",
	"Method": "Throwable getCause(){\r\n    return this.cause;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.qrcode.Version.getProvisionalVersionForDimension",
	"Comment": "deduces version information purely from qr code dimensions.",
	"Method": "Version getProvisionalVersionForDimension(int dimension){\r\n    if (dimension % 4 != 1) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    try {\r\n        return getVersionForNumber((dimension - 17) >> 2);\r\n    } catch (IllegalArgumentException iae) {\r\n        throw iae;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.VerticalText.go",
	"Comment": "outputs the lines to the document. the output can be simulated.",
	"Method": "int go(int go,boolean simulate){\r\n    boolean dirty = false;\r\n    PdfContentByte graphics = null;\r\n    if (text != null) {\r\n        graphics = text.getDuplicate();\r\n    } else if (!simulate)\r\n        throw new NullPointerException(MessageLocalization.getComposedMessage(\"verticaltext.go.with.simulate.eq.eq.false.and.text.eq.eq.null\"));\r\n    int status = 0;\r\n    for (; ; ) {\r\n        if (maxLines <= 0) {\r\n            status = NO_MORE_COLUMN;\r\n            if (chunks.isEmpty())\r\n                status |= NO_MORE_TEXT;\r\n            break;\r\n        }\r\n        if (chunks.isEmpty()) {\r\n            status = NO_MORE_TEXT;\r\n            break;\r\n        }\r\n        PdfLine line = createLine(height);\r\n        if (!simulate && !dirty) {\r\n            text.beginText();\r\n            dirty = true;\r\n        }\r\n        shortenChunkArray();\r\n        if (!simulate) {\r\n            text.setTextMatrix(startX, startY - line.indentLeft());\r\n            writeLine(line, text, graphics);\r\n        }\r\n        --maxLines;\r\n        startX -= leading;\r\n    }\r\n    if (dirty) {\r\n        text.endText();\r\n        text.add(graphics);\r\n    }\r\n    return status;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.PrivateUtils.initialSymtab",
	"Comment": "returns a minimal symtab, either system or local depending on thegiven values, that supports representation as an ionstruct. if theimports are empty, the default system symtab is returned.",
	"Method": "SymbolTable initialSymtab(PrivateLocalSymbolTableFactory lstFactory,SymbolTable defaultSystemSymtab,SymbolTable imports){\r\n    if (imports == null || imports.length == 0) {\r\n        return defaultSystemSymtab;\r\n    }\r\n    if (imports.length == 1 && imports[0].isSystemTable()) {\r\n        return imports[0];\r\n    }\r\n    return lstFactory.newLocalSymtab(defaultSystemSymtab, imports);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfGState.setOverPrintNonStroking",
	"Comment": "sets the flag whether to apply overprint for non stroking painting operations.",
	"Method": "void setOverPrintNonStroking(boolean op){\r\n    put(PdfName.op, op ? PdfBoolean.PDFTRUE : PdfBoolean.PDFFALSE);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BarcodePDF417.getImage",
	"Comment": "gets an image with the barcode. the image will have to bescaled in the y direction by yheightfor the barcodeto have the right printing aspect.",
	"Method": "Image getImage(){\r\n    paintCode();\r\n    byte[] g4 = CCITTG4Encoder.compress(outBits, bitColumns, codeRows);\r\n    return Image.getInstance(bitColumns, codeRows, false, Image.CCITTG4, (options & PDF417_INVERT_BITMAP) == 0 ? 0 : Image.CCITT_BLACKIS1, g4, null);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfFileSpecification.getReference",
	"Comment": "gets the indirect reference to this file specification.multiple invocations will retrieve the same value.",
	"Method": "PdfIndirectReference getReference(){\r\n    if (ref != null)\r\n        return ref;\r\n    ref = writer.addToBody(this).getIndirectReference();\r\n    return ref;\r\n}"
}, {
	"Path": "com.itextpdf.text.FontFactory.registerFamily",
	"Comment": "register a font by giving explicitly the font family and name.",
	"Method": "void registerFamily(String familyName,String fullName,String path){\r\n    fontImp.registerFamily(familyName, fullName, path);\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPUtilsImpl.checkQuotes",
	"Comment": "make sure the open and close quotes are a legitimate pair and return the\tcorrect closing quote or an exception.",
	"Method": "char checkQuotes(String quotes,char openQuote){\r\n    char closeQuote;\r\n    int charKind = classifyCharacter(openQuote);\r\n    if (charKind != UCK_QUOTE) {\r\n        throw new XMPException(\"Invalid quoting character\", XMPError.BADPARAM);\r\n    }\r\n    if (quotes.length() == 1) {\r\n        closeQuote = openQuote;\r\n    } else {\r\n        closeQuote = quotes.charAt(1);\r\n        charKind = classifyCharacter(closeQuote);\r\n        if (charKind != UCK_QUOTE) {\r\n            throw new XMPException(\"Invalid quoting character\", XMPError.BADPARAM);\r\n        }\r\n    }\r\n    if (closeQuote != getClosingQuote(openQuote)) {\r\n        throw new XMPException(\"Mismatched quote pair\", XMPError.BADPARAM);\r\n    }\r\n    return closeQuote;\r\n}"
}, {
	"Path": "com.example.bigquerydatatransfer.QuickstartSample.main",
	"Comment": "list available data sources for the bigquery data transfer service.",
	"Method": "void main(String args){\r\n    String projectId = args[0];\r\n    try (DataTransferServiceClient client = DataTransferServiceClient.create()) {\r\n        String parent = String.format(\"projects/%s\", projectId);\r\n        ListDataSourcesRequest request = ListDataSourcesRequest.newBuilder().setParent(parent).build();\r\n        ListDataSourcesPagedResponse response = client.listDataSources(request);\r\n        System.out.println(\"Supported Data Sources:\");\r\n        for (DataSource dataSource : response.iterateAll()) {\r\n            System.out.println(dataSource.getDisplayName());\r\n            System.out.printf(\"\\tID: %s%n\", dataSource.getDataSourceId());\r\n            System.out.printf(\"\\tFull path: %s%n\", dataSource.getName());\r\n            System.out.printf(\"\\tDescription: %s%n\", dataSource.getDescription());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.ocg.OCGParser.isToRemoved",
	"Comment": "checks if the parser is currently parsing content that needs to be ignored.",
	"Method": "boolean isToRemoved(){\r\n    if (mc_balance > 0)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.codec.TIFFDirectory.getNextIFDOffset",
	"Comment": "returns the offset of the next ifd after the ifd corresponding to thistiffdirectory.",
	"Method": "long getNextIFDOffset(){\r\n    return nextIFDOffset;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfLayer.setUser",
	"Comment": "one of more users for whom this optional content group is primarily intended.",
	"Method": "void setUser(String type,String names){\r\n    PdfDictionary usage = getUsage();\r\n    PdfDictionary dic = new PdfDictionary();\r\n    dic.put(PdfName.TYPE, new PdfName(type));\r\n    PdfArray arr = new PdfArray();\r\n    for (String s : names) arr.add(new PdfString(s, PdfObject.TEXT_UNICODE));\r\n    usage.put(PdfName.NAME, arr);\r\n    usage.put(PdfName.USER, dic);\r\n}"
}, {
	"Path": "com.structurizr.util.ImageUtils.getContentType",
	"Comment": "gets the content type of the specified file representing an image.",
	"Method": "String getContentType(File file){\r\n    if (file == null) {\r\n        throw new IllegalArgumentException(\"A file must be specified.\");\r\n    } else if (!file.exists()) {\r\n        throw new IllegalArgumentException(file.getCanonicalPath() + \" does not exist.\");\r\n    } else if (!file.isFile()) {\r\n        throw new IllegalArgumentException(file.getCanonicalPath() + \" is not a file.\");\r\n    }\r\n    String contentType = URLConnection.guessContentTypeFromName(file.getName());\r\n    if (contentType == null || !contentType.startsWith(\"image/\")) {\r\n        throw new IllegalArgumentException(file.getCanonicalPath() + \" is not a supported image file.\");\r\n    }\r\n    return contentType;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.events.IndexEvents.onGenericTag",
	"Comment": "all the text that is passed to this event, gets registered in the indexentry.",
	"Method": "void onGenericTag(PdfWriter writer,Document document,Rectangle rect,String text){\r\n    indextag.put(text, Integer.valueOf(writer.getPageNumber()));\r\n}"
}, {
	"Path": "com.example.dialogflow.EntityTypeManagement.getEntityTypeIds",
	"Comment": "helper method for testing to get entitytypeid from displayname.",
	"Method": "List<String> getEntityTypeIds(String displayName,String projectId){\r\n    List<String> entityTypesIds = new ArrayList();\r\n    try (EntityTypesClient entityTypesClient = EntityTypesClient.create()) {\r\n        ProjectAgentName parent = ProjectAgentName.of(projectId);\r\n        for (EntityType entityType : entityTypesClient.listEntityTypes(parent).iterateAll()) {\r\n            if (entityType.getDisplayName().equals(displayName)) {\r\n                String[] splitName = entityType.getName().split(\"/\");\r\n                entityTypesIds.add(splitName[splitName.length - 1]);\r\n            }\r\n        }\r\n    }\r\n    return entityTypesIds;\r\n}"
}, {
	"Path": "com.itextpdf.text.Rectangle.cloneNonPositionParameters",
	"Comment": "copies each of the parameters, except the position, from a\trectangle object",
	"Method": "void cloneNonPositionParameters(Rectangle rect){\r\n    this.rotation = rect.rotation;\r\n    this.backgroundColor = rect.backgroundColor;\r\n    this.border = rect.border;\r\n    this.useVariableBorders = rect.useVariableBorders;\r\n    this.borderWidth = rect.borderWidth;\r\n    this.borderWidthLeft = rect.borderWidthLeft;\r\n    this.borderWidthRight = rect.borderWidthRight;\r\n    this.borderWidthTop = rect.borderWidthTop;\r\n    this.borderWidthBottom = rect.borderWidthBottom;\r\n    this.borderColor = rect.borderColor;\r\n    this.borderColorLeft = rect.borderColorLeft;\r\n    this.borderColorRight = rect.borderColorRight;\r\n    this.borderColorTop = rect.borderColorTop;\r\n    this.borderColorBottom = rect.borderColorBottom;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.AssembleIndex",
	"Comment": "function creates the new index, inserting the count,offsetsize,offset array\tand object array.",
	"Method": "byte[] AssembleIndex(int[] NewOffsets,byte[] NewObjects){\r\n    char Count = (char) (NewOffsets.length - 1);\r\n    int Size = NewOffsets[NewOffsets.length - 1];\r\n    byte Offsize;\r\n    if (Size < 0xff)\r\n        Offsize = 1;\r\n    else if (Size < 0xffff)\r\n        Offsize = 2;\r\n    else if (Size < 0xffffff)\r\n        Offsize = 3;\r\n    else\r\n        Offsize = 4;\r\n    byte[] NewIndex = new byte[2 + 1 + Offsize * (Count + 1) + NewObjects.length];\r\n    int Place = 0;\r\n    NewIndex[Place++] = (byte) (Count >>> 8 & 0xff);\r\n    NewIndex[Place++] = (byte) (Count >>> 0 & 0xff);\r\n    NewIndex[Place++] = Offsize;\r\n    for (int newOffset : NewOffsets) {\r\n        int Num = newOffset - NewOffsets[0] + 1;\r\n        switch(Offsize) {\r\n            case 4:\r\n                NewIndex[Place++] = (byte) (Num >>> 24 & 0xff);\r\n            case 3:\r\n                NewIndex[Place++] = (byte) (Num >>> 16 & 0xff);\r\n            case 2:\r\n                NewIndex[Place++] = (byte) (Num >>> 8 & 0xff);\r\n            case 1:\r\n                NewIndex[Place++] = (byte) (Num >>> 0 & 0xff);\r\n        }\r\n    }\r\n    for (byte newObject : NewObjects) {\r\n        NewIndex[Place++] = newObject;\r\n    }\r\n    return NewIndex;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfAction.javaScript",
	"Comment": "creates a javascript action. if the javascript is smaller than50 characters it will be place as a string, otherwise it willbe placed as a compressed stream.",
	"Method": "PdfAction javaScript(String code,PdfWriter writer,boolean unicode,PdfAction javaScript,String code,PdfWriter writer){\r\n    return javaScript(code, writer, false);\r\n}"
}, {
	"Path": "software.amazon.ion.impl.IonReaderBinarySystemX.load_cached_value",
	"Comment": "this checks the state of the raw reader to make surethis is valid.it also checks for an existing cachedvalue of the correct type.it will either cast thecurrent value from an existing type to the type desiredor it will construct the desired type from the rawinput in the raw reader",
	"Method": "void load_cached_value(int value_type){\r\n    if (_v.isEmpty()) {\r\n        load_scalar_value();\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDictionary.getAsBoolean",
	"Comment": "returns a pdfobject as a pdfboolean,resolving indirect references.the object associated with the pdfname given is retrievedand resolved to a direct object.if it is a pdfboolean, it is cast down and returned as such.otherwise null is returned.",
	"Method": "PdfBoolean getAsBoolean(PdfName key){\r\n    PdfBoolean bool = null;\r\n    PdfObject orig = getDirectObject(key);\r\n    if (orig != null && orig.isBoolean())\r\n        bool = (PdfBoolean) orig;\r\n    return bool;\r\n}"
}, {
	"Path": "com.ulisesbocchio.jasyptspringboot.BootstrappingJasyptConfigurationTest.issue_notDecryptedDuringBoostrapPhase",
	"Comment": "this is the real issue being addressed in here in jasyptspringcloudbootstrapconfiguration.",
	"Method": "void issue_notDecryptedDuringBoostrapPhase(){\r\n    startWith(new BaseBootstrappingTestListener() {\r\n        @Override\r\n        public void onApplicationEvent(final ApplicationEnvironmentPreparedEvent event) {\r\n            assertFalse(\"ENC() value is not decrypted during bootstrap phase\", event.getEnvironment().getProperty(\"spring.cloud.config.server.svn.password\").equals(\"mypassword\"));\r\n        }\r\n    }, \"--spring.cloud.bootstrap.enabled=true\", \"--jasypt.encryptor.bootstrap=false\");\r\n    assertNotNull(this.context.getBean(EnableEncryptablePropertiesBeanFactoryPostProcessor.class));\r\n}"
}, {
	"Path": "com.ulisesbocchio.jasyptspringboot.BootstrappingJasyptConfigurationTest.issue_notDecryptedDuringBoostrapPhase",
	"Comment": "this is the real issue being addressed in here in jasyptspringcloudbootstrapconfiguration.",
	"Method": "void issue_notDecryptedDuringBoostrapPhase(){\r\n    assertFalse(\"ENC() value is not decrypted during bootstrap phase\", event.getEnvironment().getProperty(\"spring.cloud.config.server.svn.password\").equals(\"mypassword\"));\r\n}"
}, {
	"Path": "com.example.dialogflow.IntentManagement.getIntentIds",
	"Comment": "helper method for testing to get intentids from displayname.",
	"Method": "List<String> getIntentIds(String displayName,String projectId){\r\n    List<String> intentIds = new ArrayList();\r\n    try (IntentsClient intentsClient = IntentsClient.create()) {\r\n        ProjectAgentName parent = ProjectAgentName.of(projectId);\r\n        for (Intent intent : intentsClient.listIntents(parent).iterateAll()) {\r\n            if (intent.getDisplayName().equals(displayName)) {\r\n                String[] splitName = intent.getName().split(\"/\");\r\n                intentIds.add(splitName[splitName.length - 1]);\r\n            }\r\n        }\r\n    }\r\n    return intentIds;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.OutputStreamCounter.close",
	"Comment": "closes this output stream and releases any system resourcesassociated with this stream. the general contract of closeis that it closes the output stream. a closed stream cannot performoutput operations and cannot be reopened.the close method of outputstream does nothing.",
	"Method": "void close(){\r\n    out.close();\r\n}"
}, {
	"Path": "com.example.cloud.iot.examples.MqttExample.createJwtEs",
	"Comment": "create a cloud iot core jwt for the given project id, signed with the given es key.",
	"Method": "String createJwtEs(String projectId,String privateKeyFile){\r\n    DateTime now = new DateTime();\r\n    JwtBuilder jwtBuilder = Jwts.builder().setIssuedAt(now.toDate()).setExpiration(now.plusMinutes(20).toDate()).setAudience(projectId);\r\n    byte[] keyBytes = Files.readAllBytes(Paths.get(privateKeyFile));\r\n    PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);\r\n    KeyFactory kf = KeyFactory.getInstance(\"EC\");\r\n    return jwtBuilder.signWith(SignatureAlgorithm.ES256, kf.generatePrivate(spec)).compact();\r\n}"
}, {
	"Path": "com.itextpdf.xmp.XMPDateTimeFactory.convertToUTCTime",
	"Comment": "make sure a time is utc. if the time zone is not utc, the time is\tadjusted and the time zone set to be utc.",
	"Method": "XMPDateTime convertToUTCTime(XMPDateTime dateTime){\r\n    long timeInMillis = dateTime.getCalendar().getTimeInMillis();\r\n    GregorianCalendar cal = new GregorianCalendar(UTC);\r\n    cal.setGregorianChange(new Date(Long.MIN_VALUE));\r\n    cal.setTimeInMillis(timeInMillis);\r\n    return new XMPDateTimeImpl(cal);\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.tokenizer.core.SynonymsEntry.add",
	"Comment": "add a new synonyms wordand the newly added word will extends the part of speech and the entityfrom the base word if there are not set",
	"Method": "void add(IWord word){\r\n    if (word.getEntity() == null) {\r\n        word.setEntity(rootWord.getEntity());\r\n    }\r\n    if (word.getPartSpeech() == null) {\r\n        word.setPartSpeech(rootWord.getPartSpeech());\r\n    }\r\n    word.setSyn(this);\r\n    synsList.add(word);\r\n}"
}, {
	"Path": "com.itextpdf.text.Font.getCalculatedStyle",
	"Comment": "gets the style that can be used with the calculated basefont\t.",
	"Method": "int getCalculatedStyle(){\r\n    int style = this.style;\r\n    if (style == UNDEFINED) {\r\n        style = NORMAL;\r\n    }\r\n    if (baseFont != null)\r\n        return style;\r\n    if (family == FontFamily.SYMBOL || family == FontFamily.ZAPFDINGBATS)\r\n        return style;\r\n    else\r\n        return style & ~BOLDITALIC;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.events.PdfPageEventForwarder.onCloseDocument",
	"Comment": "called when the document is closed.\tnote that this method is called with the page number equal to the last\tpage plus one.",
	"Method": "void onCloseDocument(PdfWriter writer,Document document){\r\n    for (PdfPageEvent event : events) {\r\n        event.onCloseDocument(writer, document);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BarcodePDF417.getText",
	"Comment": "gets the bytes that form the barcode. this bytes shouldbe interpreted in the codepage cp437.",
	"Method": "byte[] getText(){\r\n    return this.text;\r\n}"
}, {
	"Path": "org.jbake.template.TemplateEngines.tryLoadEngine",
	"Comment": "this method is used to search for a specific class, telling if loading the engine would succeed. this istypically used to avoid loading optional modules.",
	"Method": "AbstractTemplateEngine tryLoadEngine(JBakeConfiguration config,ContentStore db,String engineClassName){\r\n    try {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Class<? extends AbstractTemplateEngine> engineClass = (Class<? extends AbstractTemplateEngine>) Class.forName(engineClassName, false, TemplateEngines.class.getClassLoader());\r\n        Constructor<? extends AbstractTemplateEngine> ctor = engineClass.getConstructor(JBakeConfiguration.class, ContentStore.class);\r\n        return ctor.newInstance(config, db);\r\n    } catch (Throwable e) {\r\n        LOGGER.warn(\"unable to load engine\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.machinepublishers.glass.ui.monocle.KeyInput.setState",
	"Comment": "called from the input processor to update the key state and sendkey events.",
	"Method": "void setState(KeyState newState){\r\n    if (MonocleSettings.settings.traceEvents) {\r\n        MonocleTrace.traceEvent(\"Set %s\", newState);\r\n    }\r\n    newState.getWindow(true);\r\n    state.getKeysPressed().difference(keys, newState.getKeysPressed());\r\n    if (!keys.isEmpty()) {\r\n        for (int i = 0; i < keys.size(); i++) {\r\n            int key = keys.get(i);\r\n            dispatchKeyEvent(newState, KeyEvent.RELEASE, key);\r\n        }\r\n    }\r\n    keys.clear();\r\n    newState.getKeysPressed().difference(keys, state.getKeysPressed());\r\n    if (!keys.isEmpty()) {\r\n        for (int i = 0; i < keys.size(); i++) {\r\n            int key = keys.get(i);\r\n            if (key == KeyEvent.VK_CAPS_LOCK) {\r\n                capsLock = !capsLock;\r\n            } else if (key == KeyEvent.VK_NUM_LOCK) {\r\n                numLock = !numLock;\r\n            } else if (key == KeyEvent.VK_C && newState.isControlPressed()) {\r\n                AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\r\n                    if (\"1\".equals(System.getenv(\"JAVAFX_DEBUG\"))) {\r\n                        System.exit(0);\r\n                    }\r\n                    return null;\r\n                });\r\n            }\r\n            dispatchKeyEvent(newState, KeyEvent.PRESS, key);\r\n        }\r\n    }\r\n    keys.clear();\r\n    newState.copyTo(state);\r\n}"
}, {
	"Path": "org.jbake.model.DocumentTypes.getDocumentTypes",
	"Comment": "notice additional document types are added automagically before returning them",
	"Method": "String[] getDocumentTypes(){\r\n    Engines.getRecognizedExtensions();\r\n    return DEFAULT_DOC_TYPES.toArray(new String[DEFAULT_DOC_TYPES.size()]);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDictionary.getAsArray",
	"Comment": "returns a pdfobject as a pdfarray,resolving indirect references.the object associated with the pdfname given is retrievedand resolved to a direct object.if it is a pdfarray, it is cast down and returned as such.otherwise null is returned.",
	"Method": "PdfArray getAsArray(PdfName key){\r\n    PdfArray array = null;\r\n    PdfObject orig = getDirectObject(key);\r\n    if (orig != null && orig.isArray())\r\n        array = (PdfArray) orig;\r\n    return array;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.ParseRDF.getRDFTermKind",
	"Comment": "determines the id for a certain rdf term.\tarranged to hopefully minimize the parse time for large xmp.",
	"Method": "int getRDFTermKind(Node node){\r\n    String localName = node.getLocalName();\r\n    String namespace = node.getNamespaceURI();\r\n    if (namespace == null && (\"about\".equals(localName) || \"ID\".equals(localName)) && (node instanceof Attr) && NS_RDF.equals(((Attr) node).getOwnerElement().getNamespaceURI())) {\r\n        namespace = NS_RDF;\r\n    }\r\n    if (NS_RDF.equals(namespace)) {\r\n        if (\"li\".equals(localName)) {\r\n            return RDFTERM_LI;\r\n        } else if (\"parseType\".equals(localName)) {\r\n            return RDFTERM_PARSE_TYPE;\r\n        } else if (\"Description\".equals(localName)) {\r\n            return RDFTERM_DESCRIPTION;\r\n        } else if (\"about\".equals(localName)) {\r\n            return RDFTERM_ABOUT;\r\n        } else if (\"resource\".equals(localName)) {\r\n            return RDFTERM_RESOURCE;\r\n        } else if (\"RDF\".equals(localName)) {\r\n            return RDFTERM_RDF;\r\n        } else if (\"ID\".equals(localName)) {\r\n            return RDFTERM_ID;\r\n        } else if (\"nodeID\".equals(localName)) {\r\n            return RDFTERM_NODE_ID;\r\n        } else if (\"datatype\".equals(localName)) {\r\n            return RDFTERM_DATATYPE;\r\n        } else if (\"aboutEach\".equals(localName)) {\r\n            return RDFTERM_ABOUT_EACH;\r\n        } else if (\"aboutEachPrefix\".equals(localName)) {\r\n            return RDFTERM_ABOUT_EACH_PREFIX;\r\n        } else if (\"bagID\".equals(localName)) {\r\n            return RDFTERM_BAG_ID;\r\n        }\r\n    }\r\n    return RDFTERM_OTHER;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONObject.names",
	"Comment": "produce a jsonarray containing the names of the elements of thisjsonobject.",
	"Method": "JSONArray names(){\r\n    JSONArray ja = new JSONArray();\r\n    Iterator<String> keys = this.keys();\r\n    while (keys.hasNext()) {\r\n        ja.put(keys.next());\r\n    }\r\n    return ja.length() == 0 ? null : ja;\r\n}"
}, {
	"Path": "com.sixt.service.framework.rpc.ServiceDependencyHealthCheck.buildFailedHealthCheck",
	"Comment": "it is unknown whether the dependency is desired or required, so we set to warn",
	"Method": "HealthCheck buildFailedHealthCheck(List<ServiceEndpoint> trippedBreakers){\r\n    StringBuilder sb = new StringBuilder();\r\n    trippedBreakers.forEach(serviceEndpoint -> {\r\n        sb.append(serviceEndpoint.getServiceName()).append('/').append(serviceEndpoint.getAvailZone()).append('/').append(serviceEndpoint.getHostAndPort()).append(' ');\r\n    });\r\n    return new HealthCheck(\"RPC dependencies\", HealthCheck.Status.WARN, sb.toString());\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.setCompressionLevel",
	"Comment": "sets the compression level to be used for streams written by this writer.",
	"Method": "void setCompressionLevel(int compressionLevel){\r\n    if (compressionLevel < PdfStream.NO_COMPRESSION || compressionLevel > PdfStream.BEST_COMPRESSION)\r\n        this.compressionLevel = PdfStream.DEFAULT_COMPRESSION;\r\n    else\r\n        this.compressionLevel = compressionLevel;\r\n}"
}, {
	"Path": "com.itextpdf.text.Rectangle.setUseVariableBorders",
	"Comment": "sets a parameter indicating if the rectangle has variable borders",
	"Method": "void setUseVariableBorders(boolean useVariableBorders){\r\n    this.useVariableBorders = useVariableBorders;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.collection.PdfCollectionField.setOrder",
	"Comment": "the relative order of the field name. fields are sorted in ascending order.",
	"Method": "void setOrder(int i){\r\n    put(PdfName.O, new PdfNumber(i));\r\n}"
}, {
	"Path": "org.jbox2d.common.OBBViewportTransform.getTransform",
	"Comment": "gets the transform of the viewport, transforms around the center. not a copy.",
	"Method": "Mat22 getTransform(){\r\n    return box.R;\r\n}"
}, {
	"Path": "com.example.firestore.snippets.ListenDataSnippets.listenForChanges",
	"Comment": "listen to a query, returning the list of documentchange events in the first snapshot.",
	"Method": "List<DocumentChange> listenForChanges(){\r\n    SettableApiFuture<List<DocumentChange>> future = SettableApiFuture.create();\r\n    db.collection(\"cities\").whereEqualTo(\"state\", \"CA\").addSnapshotListener(new EventListener<QuerySnapshot>() {\r\n        @Override\r\n        public void onEvent(@Nullable QuerySnapshot snapshots, @Nullable FirestoreException e) {\r\n            if (e != null) {\r\n                System.err.println(\"Listen failed: \" + e);\r\n                return;\r\n            }\r\n            for (DocumentChange dc : snapshots.getDocumentChanges()) {\r\n                switch(dc.getType()) {\r\n                    case ADDED:\r\n                        System.out.println(\"New city: \" + dc.getDocument().getData());\r\n                        break;\r\n                    case MODIFIED:\r\n                        System.out.println(\"Modified city: \" + dc.getDocument().getData());\r\n                        break;\r\n                    case REMOVED:\r\n                        System.out.println(\"Removed city: \" + dc.getDocument().getData());\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            if (!future.isDone()) {\r\n                future.set(snapshots.getDocumentChanges());\r\n            }\r\n        }\r\n    });\r\n    return future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "com.example.firestore.snippets.ListenDataSnippets.listenForChanges",
	"Comment": "listen to a query, returning the list of documentchange events in the first snapshot.",
	"Method": "List<DocumentChange> listenForChanges(){\r\n    if (e != null) {\r\n        System.err.println(\"Listen failed: \" + e);\r\n        return;\r\n    }\r\n    for (DocumentChange dc : snapshots.getDocumentChanges()) {\r\n        switch(dc.getType()) {\r\n            case ADDED:\r\n                System.out.println(\"New city: \" + dc.getDocument().getData());\r\n                break;\r\n            case MODIFIED:\r\n                System.out.println(\"Modified city: \" + dc.getDocument().getData());\r\n                break;\r\n            case REMOVED:\r\n                System.out.println(\"Removed city: \" + dc.getDocument().getData());\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    if (!future.isDone()) {\r\n        future.set(snapshots.getDocumentChanges());\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.CalcSubrOffsetSize",
	"Comment": "calculates how many byte it took to write the offset for the subrs in a specific\tprivate dict.",
	"Method": "int CalcSubrOffsetSize(int Offset,int Size){\r\n    int OffsetSize = 0;\r\n    seek(Offset);\r\n    while (getPosition() < Offset + Size) {\r\n        int p1 = getPosition();\r\n        getDictItem();\r\n        int p2 = getPosition();\r\n        if (key == \"Subrs\") {\r\n            OffsetSize = p2 - p1 - 1;\r\n        }\r\n    }\r\n    return OffsetSize;\r\n}"
}, {
	"Path": "com.structurizr.analysis.TypeUtils.findTypesAnnotatedWith",
	"Comment": "finds the set of types that are annotated with the specified annotation.",
	"Method": "Set<Class<?>> findTypesAnnotatedWith(Class<? extends Annotation> annotation,Set<Class<?>> types){\r\n    if (annotation == null) {\r\n        throw new IllegalArgumentException(\"An annotation type must be specified.\");\r\n    }\r\n    return types.stream().filter(c -> c.isAnnotationPresent(annotation)).collect(Collectors.toSet());\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfFileSpecification.setVolatile",
	"Comment": "sets a flag that indicates whether an external file referenced by the filespecification is volatile. if the value is true, applications should nevercache a copy of the file.",
	"Method": "void setVolatile(boolean volatile_file){\r\n    put(PdfName.V, new PdfBoolean(volatile_file));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPCell.setFixedHeight",
	"Comment": "set a fixed height for the cell. this will automatically unsetminimumheight, if set.",
	"Method": "void setFixedHeight(float fixedHeight){\r\n    this.fixedHeight = fixedHeight;\r\n    minimumHeight = 0;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfLayer.createTitle",
	"Comment": "creates a title layer. a title layer is not really a layer but a collection of layersunder the same title heading.",
	"Method": "PdfLayer createTitle(String title,PdfWriter writer){\r\n    if (title == null)\r\n        throw new NullPointerException(MessageLocalization.getComposedMessage(\"title.cannot.be.null\"));\r\n    PdfLayer layer = new PdfLayer(title);\r\n    writer.registerLayer(layer);\r\n    return layer;\r\n}"
}, {
	"Path": "com.example.cloud.iot.examples.MqttExample.createJwtRsa",
	"Comment": "create a cloud iot core jwt for the given project id, signed with the given rsa key.",
	"Method": "String createJwtRsa(String projectId,String privateKeyFile){\r\n    DateTime now = new DateTime();\r\n    JwtBuilder jwtBuilder = Jwts.builder().setIssuedAt(now.toDate()).setExpiration(now.plusMinutes(20).toDate()).setAudience(projectId);\r\n    byte[] keyBytes = Files.readAllBytes(Paths.get(privateKeyFile));\r\n    PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);\r\n    KeyFactory kf = KeyFactory.getInstance(\"RSA\");\r\n    return jwtBuilder.signWith(SignatureAlgorithm.RS256, kf.generatePrivate(spec)).compact();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaWindow.createDimensionDictionary",
	"Comment": "creates a dictionary that can be used for the height and width entries\tof the richmediawindow dictionary.",
	"Method": "PdfDictionary createDimensionDictionary(float d,float max,float min){\r\n    PdfDictionary dict = new PdfDictionary();\r\n    dict.put(PdfName.DEFAULT, new PdfNumber(d));\r\n    dict.put(PdfName.MAX_CAMEL_CASE, new PdfNumber(max));\r\n    dict.put(PdfName.MIN_CAMEL_CASE, new PdfNumber(min));\r\n    return dict;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.lite.IonValueLite.equals",
	"Comment": "implements equality over values.this is currently defined using the equivalence class.",
	"Method": "boolean equals(Object other){\r\n    if (other == this) {\r\n        return true;\r\n    }\r\n    if (other instanceof IonValue) {\r\n        return ionEquals(this, (IonValue) other);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.ByteBuffer.toByteArray",
	"Comment": "creates a newly allocated byte array. its size is the currentsize of this output stream and the valid contents of the bufferhave been copied into it.",
	"Method": "byte[] toByteArray(){\r\n    byte[] newbuf = new byte[count];\r\n    System.arraycopy(buf, 0, newbuf, 0, count);\r\n    return newbuf;\r\n}"
}, {
	"Path": "org.jbox2d.collision.shapes.Shape.getRadius",
	"Comment": "the radius of the underlying shape. this can refer to different things depending on the shapeimplementation",
	"Method": "float getRadius(){\r\n    return m_radius;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.TextField.setDefaultText",
	"Comment": "sets the default text. it is only meaningful for text fields.",
	"Method": "void setDefaultText(String defaultText){\r\n    this.defaultText = defaultText;\r\n}"
}, {
	"Path": "com.itextpdf.text.Rectangle.normalize",
	"Comment": "normalizes the rectangle.\tswitches lower left with upper right if necessary.",
	"Method": "void normalize(){\r\n    if (llx > urx) {\r\n        float a = llx;\r\n        llx = urx;\r\n        urx = a;\r\n    }\r\n    if (lly > ury) {\r\n        float a = lly;\r\n        lly = ury;\r\n        ury = a;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseField.moveFields",
	"Comment": "moves the field keys from from to to. the moved keysare removed from from.",
	"Method": "void moveFields(PdfDictionary from,PdfDictionary to){\r\n    for (Iterator<PdfName> i = from.getKeys().iterator(); i.hasNext(); ) {\r\n        PdfName key = i.next();\r\n        if (fieldKeys.containsKey(key)) {\r\n            if (to != null)\r\n                to.put(key, from.get(key));\r\n            i.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.killIndirect",
	"Comment": "eliminates the reference to the object freeing the memory used by it and clearingthe xref entry.",
	"Method": "PdfObject killIndirect(PdfObject obj){\r\n    if (obj == null || obj.isNull())\r\n        return null;\r\n    PdfObject ret = getPdfObjectRelease(obj);\r\n    if (obj.isIndirect()) {\r\n        PRIndirectReference ref = (PRIndirectReference) obj;\r\n        PdfReader reader = ref.getReader();\r\n        int n = ref.getNumber();\r\n        reader.xrefObj.set(n, null);\r\n        if (reader.partial)\r\n            reader.xref[n * 2] = -1;\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.audit.AuditLogChange.getKey",
	"Comment": "the key which defines the field that was updatedby this change",
	"Method": "String getKey(){\r\n    return key;\r\n}"
}, {
	"Path": "software.amazon.ion.system.IonWriterBuilderBase.getImports",
	"Comment": "gets the imports that will be used to construct the initial localsymbol table.",
	"Method": "SymbolTable[] getImports(){\r\n    return safeCopy(myImports);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStamper.setRotateContents",
	"Comment": "flags the content to be automatically adjusted to compensatethe original page rotation. the default is true.",
	"Method": "void setRotateContents(boolean rotateContents){\r\n    stamper.setRotateContents(rotateContents);\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.pipeline.AbstractPipeline.setNext",
	"Comment": "setnext method. when using this while parsing one can make live\tchanges the pipeline structure. use with caution.",
	"Method": "void setNext(Pipeline<?> next){\r\n    this.next = next;\r\n}"
}, {
	"Path": "software.amazon.ion.DatagramTest.testMaterializationOnRemove",
	"Comment": "verifies that detachment from binary buffer does deep materialization.",
	"Method": "void testMaterializationOnRemove(){\r\n    IonDatagram dg = loader().load(\"[[1]]\");\r\n    IonList l = (IonList) dg.remove(0);\r\n    l = (IonList) l.get(0);\r\n    assertEquals(1, ((IonInt) l.get(0)).intValue());\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.server.core.UriEntry.parseRequestUri",
	"Comment": "parse a given request uri to generate a new urientry instance and return it",
	"Method": "UriEntry parseRequestUri(String requestUri){\r\n    return new UriEntry(requestUri);\r\n}"
}, {
	"Path": "com.example.dlp.Redact.redactImage",
	"Comment": "redact sensitive data from an image using the data loss prevention api.",
	"Method": "void redactImage(String filePath,Likelihood minLikelihood,List<InfoType> infoTypes,String outputPath,String projectId){\r\n    try (DlpServiceClient dlpClient = DlpServiceClient.create()) {\r\n        String mimeType = URLConnection.guessContentTypeFromName(filePath);\r\n        if (mimeType == null) {\r\n            mimeType = MimetypesFileTypeMap.getDefaultFileTypeMap().getContentType(filePath);\r\n        }\r\n        ByteContentItem.BytesType bytesType;\r\n        switch(mimeType) {\r\n            case \"image/jpeg\":\r\n                bytesType = ByteContentItem.BytesType.IMAGE_JPEG;\r\n                break;\r\n            case \"image/bmp\":\r\n                bytesType = ByteContentItem.BytesType.IMAGE_BMP;\r\n                break;\r\n            case \"image/png\":\r\n                bytesType = ByteContentItem.BytesType.IMAGE_PNG;\r\n                break;\r\n            case \"image/svg\":\r\n                bytesType = ByteContentItem.BytesType.IMAGE_SVG;\r\n                break;\r\n            default:\r\n                bytesType = ByteContentItem.BytesType.BYTES_TYPE_UNSPECIFIED;\r\n                break;\r\n        }\r\n        byte[] data = Files.readAllBytes(Paths.get(filePath));\r\n        InspectConfig inspectConfig = InspectConfig.newBuilder().addAllInfoTypes(infoTypes).setMinLikelihood(minLikelihood).build();\r\n        ByteContentItem byteContentItem = ByteContentItem.newBuilder().setType(bytesType).setData(ByteString.copyFrom(data)).build();\r\n        List<RedactImageRequest.ImageRedactionConfig> imageRedactionConfigs = infoTypes.stream().map(infoType -> RedactImageRequest.ImageRedactionConfig.newBuilder().setInfoType(infoType).build()).collect(Collectors.toList());\r\n        RedactImageRequest redactImageRequest = RedactImageRequest.newBuilder().setParent(ProjectName.of(projectId).toString()).addAllImageRedactionConfigs(imageRedactionConfigs).setByteItem(byteContentItem).setInspectConfig(inspectConfig).build();\r\n        RedactImageResponse redactImageResponse = dlpClient.redactImage(redactImageRequest);\r\n        ByteString redactedImageData = redactImageResponse.getRedactedImage();\r\n        FileOutputStream outputStream = new FileOutputStream(outputPath);\r\n        outputStream.write(redactedImageData.toByteArray());\r\n        outputStream.close();\r\n    }\r\n}"
}, {
	"Path": "com.structurizr.model.StaticStructureElement.delivers",
	"Comment": "adds a unidirectional relationship between this element and a person.",
	"Method": "Relationship delivers(Person destination,String description,Relationship delivers,Person destination,String description,String technology,Relationship delivers,Person destination,String description,String technology,InteractionStyle interactionStyle){\r\n    return uses(destination, description, technology, interactionStyle);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.createXmpMetadata",
	"Comment": "use this method to creates xmp metadata basedon the metadata in the pdfdocument.",
	"Method": "void createXmpMetadata(){\r\n    try {\r\n        xmpWriter = createXmpWriter(null, pdf.getInfo());\r\n        if (isTagged()) {\r\n            try {\r\n                xmpWriter.getXmpMeta().setPropertyInteger(XMPConst.NS_PDFUA_ID, PdfProperties.PART, 1, new PropertyOptions(PropertyOptions.SEPARATE_NODE));\r\n            } catch (XMPException e) {\r\n                throw new ExceptionConverter(e);\r\n            }\r\n        }\r\n        xmpMetadata = null;\r\n    } catch (IOException ioe) {\r\n        ioe.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "software.amazon.ion.impl.PrivateUtils.getSidForSymbolTableField",
	"Comment": "returns the symbol id matching a system symbol text of alocal or shared symtab field.",
	"Method": "int getSidForSymbolTableField(String text){\r\n    final int shortestFieldNameLength = 4;\r\n    if (text != null && text.length() >= shortestFieldNameLength) {\r\n        int c = text.charAt(0);\r\n        switch(c) {\r\n            case 'v':\r\n                if (VERSION.equals(text)) {\r\n                    return VERSION_SID;\r\n                }\r\n                break;\r\n            case 'n':\r\n                if (NAME.equals(text)) {\r\n                    return NAME_SID;\r\n                }\r\n                break;\r\n            case 's':\r\n                if (SYMBOLS.equals(text)) {\r\n                    return SYMBOLS_SID;\r\n                }\r\n                break;\r\n            case 'i':\r\n                if (IMPORTS.equals(text)) {\r\n                    return IMPORTS_SID;\r\n                }\r\n                break;\r\n            case 'm':\r\n                if (MAX_ID.equals(text)) {\r\n                    return MAX_ID_SID;\r\n                }\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    return UNKNOWN_SYMBOL_ID;\r\n}"
}, {
	"Path": "com.itextpdf.text.xml.simpleparser.IanaEncodings.getJavaEncoding",
	"Comment": "gets the java encoding from the iana encoding. if the encoding cannot be foundit returns the input.",
	"Method": "String getJavaEncoding(String iana){\r\n    String IANA = iana.toUpperCase();\r\n    String jdec = MAP.get(IANA);\r\n    if (jdec == null)\r\n        jdec = iana;\r\n    return jdec;\r\n}"
}, {
	"Path": "com.example.cloud.iot.examples.HttpExample.publishMessage",
	"Comment": "publish an event or state message using cloud iot core via the http api.",
	"Method": "void publishMessage(String payload,String urlPath,String messageType,String token,String projectId,String cloudRegion,String registryId,String deviceId){\r\n    String devicePath = String.format(\"projects/%s/locations/%s/registries/%s/devices/%s\", projectId, cloudRegion, registryId, deviceId);\r\n    String urlSuffix = messageType.equals(\"event\") ? \"publishEvent\" : \"setState\";\r\n    Base64.Encoder encoder = Base64.getEncoder();\r\n    String encPayload = encoder.encodeToString(payload.getBytes(\"UTF-8\"));\r\n    urlPath = urlPath + devicePath + \":\" + urlSuffix;\r\n    final HttpRequestFactory requestFactory = HTTP_TRANSPORT.createRequestFactory(new HttpRequestInitializer() {\r\n        @Override\r\n        public void initialize(HttpRequest request) {\r\n            request.setParser(new JsonObjectParser(JSON_FACTORY));\r\n        }\r\n    });\r\n    HttpHeaders heads = new HttpHeaders();\r\n    heads.setAuthorization(String.format(\"Bearer %s\", token));\r\n    heads.setContentType(\"application/json; charset=UTF-8\");\r\n    heads.setCacheControl(\"no-cache\");\r\n    JSONObject data = new JSONObject();\r\n    if (messageType.equals(\"event\")) {\r\n        data.put(\"binary_data\", encPayload);\r\n    } else {\r\n        JSONObject state = new JSONObject();\r\n        state.put(\"binary_data\", encPayload);\r\n        data.put(\"state\", state);\r\n    }\r\n    ByteArrayContent content = new ByteArrayContent(\"application/json\", data.toString().getBytes(\"UTF-8\"));\r\n    final HttpRequest req = requestFactory.buildGetRequest(new GenericUrl(urlPath));\r\n    req.setHeaders(heads);\r\n    req.setContent(content);\r\n    req.setRequestMethod(\"POST\");\r\n    ExponentialBackOff backoff = new ExponentialBackOff.Builder().setInitialIntervalMillis(500).setMaxElapsedTimeMillis(900000).setMaxIntervalMillis(6000).setMultiplier(1.5).setRandomizationFactor(0.5).build();\r\n    req.setUnsuccessfulResponseHandler(new HttpBackOffUnsuccessfulResponseHandler(backoff));\r\n    HttpResponse res = req.execute();\r\n    System.out.println(res.getStatusCode());\r\n    System.out.println(res.getStatusMessage());\r\n}"
}, {
	"Path": "com.example.cloud.iot.examples.HttpExample.publishMessage",
	"Comment": "publish an event or state message using cloud iot core via the http api.",
	"Method": "void publishMessage(String payload,String urlPath,String messageType,String token,String projectId,String cloudRegion,String registryId,String deviceId){\r\n    request.setParser(new JsonObjectParser(JSON_FACTORY));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.ColumnText.getRowsDrawn",
	"Comment": "gets the number of rows that were drawn when a table is involved.",
	"Method": "int getRowsDrawn(){\r\n    return rowIdx;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Fixture.getShape",
	"Comment": "get the child shape. you can modify the child shape, however you should not change the numberof vertices because this will crash some collision caching mechanisms.",
	"Method": "Shape getShape(){\r\n    return m_shape;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStamper.getUnderContent",
	"Comment": "gets a pdfcontentbyte to write under the page ofthe original document.",
	"Method": "PdfContentByte getUnderContent(int pageNum){\r\n    return stamper.getUnderContent(pageNum);\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.html.table.TableStyleValues.isLastInRow",
	"Comment": "only used by cells. this boolean is used for adding a horizontal border spacing to the right of a cell.",
	"Method": "boolean isLastInRow(){\r\n    return isLastInRow;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.PdfContentReaderTool.listContentStreamForPage",
	"Comment": "writes information about a specific page from pdfreader to the specified output stream.",
	"Method": "void listContentStreamForPage(PdfReader reader,int pageNum,PrintWriter out){\r\n    out.println(\"==============Page \" + pageNum + \"====================\");\r\n    out.println(\"- - - - - Dictionary - - - - - -\");\r\n    PdfDictionary pageDictionary = reader.getPageN(pageNum);\r\n    out.println(getDictionaryDetail(pageDictionary));\r\n    out.println(\"- - - - - XObject Summary - - - - - -\");\r\n    out.println(getXObjectDetail(pageDictionary.getAsDict(PdfName.RESOURCES)));\r\n    out.println(\"- - - - - Content Stream - - - - - -\");\r\n    RandomAccessFileOrArray f = reader.getSafeFile();\r\n    byte[] contentBytes = reader.getPageContent(pageNum, f);\r\n    f.close();\r\n    out.flush();\r\n    InputStream is = new ByteArrayInputStream(contentBytes);\r\n    int ch;\r\n    while ((ch = is.read()) != -1) {\r\n        out.print((char) ch);\r\n    }\r\n    out.flush();\r\n    out.println(\"- - - - - Text Extraction - - - - - -\");\r\n    String extractedText = PdfTextExtractor.getTextFromPage(reader, pageNum, new LocationTextExtractionStrategy());\r\n    if (extractedText.length() != 0)\r\n        out.println(extractedText);\r\n    else\r\n        out.println(\"No text found on page \" + pageNum);\r\n    out.println();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.getStructureTreeRoot",
	"Comment": "gets the structure tree root. if the document is not marked for tagging it will return null.",
	"Method": "PdfStructureTreeRoot getStructureTreeRoot(){\r\n    if (tagged && structureTreeRoot == null)\r\n        structureTreeRoot = new PdfStructureTreeRoot(this);\r\n    return structureTreeRoot;\r\n}"
}, {
	"Path": "org.jbox2d.callbacks.ContactFilter.shouldCollide",
	"Comment": "return true if contact calculations should be performed between these two shapes.",
	"Method": "boolean shouldCollide(Fixture fixtureA,Fixture fixtureB){\r\n    Filter filterA = fixtureA.getFilterData();\r\n    Filter filterB = fixtureB.getFilterData();\r\n    if (filterA.groupIndex == filterB.groupIndex && filterA.groupIndex != 0) {\r\n        return filterA.groupIndex > 0;\r\n    }\r\n    boolean collide = (filterA.maskBits & filterB.categoryBits) != 0 && (filterA.categoryBits & filterB.maskBits) != 0;\r\n    return collide;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BidiOrder.determineExplicitEmbeddingLevels",
	"Comment": "process embedding format codes.calls processembeddings to generate an embedding array from the explicit format codes.theembedding overrides in the array are then applied to the result types, and the result levels areinitialized.",
	"Method": "void determineExplicitEmbeddingLevels(){\r\n    embeddings = processEmbeddings(resultTypes, paragraphEmbeddingLevel);\r\n    for (int i = 0; i < textLength; ++i) {\r\n        byte level = embeddings[i];\r\n        if ((level & 0x80) != 0) {\r\n            level &= 0x7f;\r\n            resultTypes[i] = typeForLevel(level);\r\n        }\r\n        resultLevels[i] = level;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.TrueTypeFont.readUnicodeString",
	"Comment": "reads a unicode string from the font file. each character isrepresented by two bytes.",
	"Method": "String readUnicodeString(int length){\r\n    StringBuffer buf = new StringBuffer();\r\n    length /= 2;\r\n    for (int k = 0; k < length; ++k) {\r\n        buf.append(rf.readChar());\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PushbuttonField.setIconHorizontalAdjustment",
	"Comment": "a number between 0 and 1 indicating the fraction of leftover space to allocate at the left of the icon.a value of 0 positions the icon at the left of the annotation rectangle.a value of 0.5 centers it within the rectangle. the default is 0.5.",
	"Method": "void setIconHorizontalAdjustment(float iconHorizontalAdjustment){\r\n    if (iconHorizontalAdjustment < 0)\r\n        iconHorizontalAdjustment = 0;\r\n    else if (iconHorizontalAdjustment > 1)\r\n        iconHorizontalAdjustment = 1;\r\n    this.iconHorizontalAdjustment = iconHorizontalAdjustment;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPMetaImpl.setPacketHeader",
	"Comment": "sets the packetheader attributes, only used by the parser.",
	"Method": "void setPacketHeader(String packetHeader){\r\n    this.packetHeader = packetHeader;\r\n}"
}, {
	"Path": "net.dv8tion.jda.bot.sharding.ShardManager.setIdleProvider",
	"Comment": "sets the provider that decides for all shards whether they should be marked as afk or not.this will also change the provider for shards that are created in the future.",
	"Method": "void setIdleProvider(IntFunction<Boolean> idleProvider){\r\n    this.getShardCache().forEach(jda -> jda.getPresence().setIdle(idleProvider.apply(jda.getShardInfo().getShardId())));\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.RevoluteJointDef.initialize",
	"Comment": "initialize the bodies, anchors, and reference angle using the world anchor.",
	"Method": "void initialize(Body b1,Body b2,Vec2 anchor){\r\n    bodyA = b1;\r\n    bodyB = b2;\r\n    bodyA.getLocalPointToOut(anchor, localAnchorA);\r\n    bodyB.getLocalPointToOut(anchor, localAnchorB);\r\n    referenceAngle = bodyB.getAngle() - bodyA.getAngle();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.codec.GifImage.getLogicalScreen",
	"Comment": "gets the logical screen. the images may be smaller and placedin some position in this screen to playback some animation.no image will be be bigger that this.",
	"Method": "int[] getLogicalScreen(){\r\n    return new int[] { width, height };\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentByte.createPrinterGraphics",
	"Comment": "gets a graphics2d to print on. the graphicsare translated to pdf commands.",
	"Method": "java.awt.Graphics2D createPrinterGraphics(float width,float height,java.awt.print.PrinterJob printerJob,java.awt.Graphics2D createPrinterGraphics,float width,float height,boolean convertImagesToJPEG,float quality,java.awt.print.PrinterJob printerJob,java.awt.Graphics2D createPrinterGraphics,float width,float height,FontMapper fontMapper,java.awt.print.PrinterJob printerJob,java.awt.Graphics2D createPrinterGraphics,float width,float height,FontMapper fontMapper,boolean convertImagesToJPEG,float quality,java.awt.print.PrinterJob printerJob){\r\n    return new PdfPrinterGraphics2D(this, width, height, fontMapper, false, convertImagesToJPEG, quality, printerJob);\r\n}"
}, {
	"Path": "software.amazon.ion.impl.IonReaderTextRawTokensX.skip_over_clob_whitespace",
	"Comment": "skip over the whitespace after the clob string and before the closingbraces. throw if a comment is encountered.",
	"Method": "int skip_over_clob_whitespace(){\r\n    return skip_over_whitespace(CommentStrategy.ERROR);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.FilteredRenderListener.renderImage",
	"Comment": "applies filters, then delegates to the delegate if all filters pass",
	"Method": "void renderImage(ImageRenderInfo renderInfo){\r\n    for (RenderFilter filter : filters) {\r\n        if (!filter.allowImage(renderInfo))\r\n            return;\r\n    }\r\n    delegate.renderImage(renderInfo);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStamper.getMoreInfo",
	"Comment": "gets the optional string map to add or change values inthe info dictionary.",
	"Method": "Map<String, String> getMoreInfo(){\r\n    return this.moreInfo;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.XfaForm.findDatasetsNode",
	"Comment": "finds the node contained in the datasets section from apossibly partial name.",
	"Method": "Node findDatasetsNode(String name){\r\n    if (name == null)\r\n        return null;\r\n    name = findDatasetsName(name);\r\n    if (name == null)\r\n        return null;\r\n    return datasetsSom.getName2Node().get(name);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.ocg.OCGParser.printsp",
	"Comment": "writes a pdf object to the outputstream, followed by a space character.",
	"Method": "void printsp(PdfObject o){\r\n    o.toPdf(null, baos);\r\n    baos.write(' ');\r\n}"
}, {
	"Path": "com.structurizr.model.Element.setUrl",
	"Comment": "sets the url where more information about this element can be found.",
	"Method": "void setUrl(String url){\r\n    if (url != null && url.trim().length() > 0) {\r\n        if (Url.isUrl(url)) {\r\n            this.url = url;\r\n        } else {\r\n            throw new IllegalArgumentException(url + \" is not a valid URL.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.Rectangle.rotate",
	"Comment": "rotates the rectangle.\tswaps the values of llx and lly and of urx and ury.",
	"Method": "Rectangle rotate(){\r\n    Rectangle rect = new Rectangle(lly, llx, ury, urx);\r\n    rect.setRotation(rotation + 90);\r\n    return rect;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.XfdfReader.getListValues",
	"Comment": "gets the field values for a list or null if the field does notexist or has no value defined.",
	"Method": "List<String> getListValues(String name){\r\n    return listFields.get(name);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.CuePoint.setTime",
	"Comment": "sets the time value of the cue point in milliseconds to match against\tthe cue point within flash content and for display purposes.",
	"Method": "void setTime(int time){\r\n    put(PdfName.TIME, new PdfNumber(time));\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONObject.optJSONObject",
	"Comment": "get an optional jsonobject associated with a key. it returns null ifthere is no such key, or if its value is not a jsonobject.",
	"Method": "JSONObject optJSONObject(String key){\r\n    Object object = this.opt(key);\r\n    return object instanceof JSONObject ? (JSONObject) object : null;\r\n}"
}, {
	"Path": "com.structurizr.model.CodeElement.setUrl",
	"Comment": "sets the url where more information about this code element can be found.",
	"Method": "void setUrl(String url){\r\n    if (url != null && url.trim().length() > 0) {\r\n        if (Url.isUrl(url)) {\r\n            this.url = url;\r\n        } else {\r\n            throw new IllegalArgumentException(url + \" is not a valid URL.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.TagTest.validateChildNotSetOnSetParent",
	"Comment": "validates that the parent tag does not have the tag set as child when set parent is\tcalled as parent.",
	"Method": "void validateChildNotSetOnSetParent(){\r\n    Tag t = new Tag(\"pappie\");\r\n    Tag t2 = new Tag(\"baby\");\r\n    t2.setParent(t);\r\n    Assert.assertEquals(0, t.getChildren().size());\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.ColumnText.setCanvas",
	"Comment": "sets the canvas. if before a set of four canvases was set, it is beingunset.",
	"Method": "void setCanvas(PdfContentByte canvas){\r\n    this.canvas = canvas;\r\n    this.canvases = null;\r\n    if (compositeColumn != null) {\r\n        compositeColumn.setCanvas(canvas);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentByte.setLeading",
	"Comment": "sets the text leading parameter.the leading parameter is measured in text space units. it specifies the vertical distancebetween the baselines of adjacent lines of text.",
	"Method": "void setLeading(float leading){\r\n    if (!inText && isTagged()) {\r\n        beginText(true);\r\n    }\r\n    state.leading = leading;\r\n    content.append(leading).append(\" TL\").append_i(separator);\r\n}"
}, {
	"Path": "com.structurizr.io.json.EncryptedJsonWriter.write",
	"Comment": "writes an encrypted workspace definition as a json string to the specified writer object.",
	"Method": "void write(EncryptedWorkspace workspace,Writer writer){\r\n    if (workspace == null) {\r\n        throw new IllegalArgumentException(\"EncryptedWorkspace cannot be null.\");\r\n    }\r\n    if (writer == null) {\r\n        throw new IllegalArgumentException(\"Writer cannot be null.\");\r\n    }\r\n    try {\r\n        ObjectMapper objectMapper = new ObjectMapper();\r\n        if (indentOutput) {\r\n            objectMapper.enable(SerializationFeature.INDENT_OUTPUT);\r\n        }\r\n        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\r\n        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);\r\n        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\r\n        objectMapper.setDateFormat(new ISO8601DateFormat());\r\n        writer.write(objectMapper.writeValueAsString(workspace));\r\n    } catch (Exception e) {\r\n        throw new WorkspaceWriterException(\"Could not write as JSON\", e);\r\n    }\r\n}"
}, {
	"Path": "com.example.iap.BuildAndVerifyIapRequestIT.accessIapProtectedResourceFailsWithoutJwtHeader",
	"Comment": "access an iap protected url without signed jwt authorization header",
	"Method": "void accessIapProtectedResourceFailsWithoutJwtHeader(){\r\n    HttpRequest request = httpTransport.createRequestFactory().buildGetRequest(new GenericUrl(IAP_PROTECTED_URL));\r\n    try {\r\n        request.execute();\r\n    } catch (HttpResponseException e) {\r\n        assertEquals(e.getStatusCode(), HttpStatus.SC_UNAUTHORIZED);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.events.PdfPageEventForwarder.onEndPage",
	"Comment": "called when a page is finished, just before being written to the\tdocument.",
	"Method": "void onEndPage(PdfWriter writer,Document document){\r\n    for (PdfPageEvent event : events) {\r\n        event.onEndPage(writer, document);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.events.PdfPageEventForwarder.onParagraph",
	"Comment": "called when a paragraph is written.\tparagraphposition will hold the height at which the\tparagraph will be written to. this is useful to insert bookmarks with\tmore control.",
	"Method": "void onParagraph(PdfWriter writer,Document document,float paragraphPosition){\r\n    for (PdfPageEvent event : events) {\r\n        event.onParagraph(writer, document, paragraphPosition);\r\n    }\r\n}"
}, {
	"Path": "org.jbake.launcher.JettyServer.run",
	"Comment": "run jetty web server serving out supplied path on supplied port",
	"Method": "void run(String path,String port){\r\n    Server server = new Server();\r\n    ServerConnector connector = new ServerConnector(server);\r\n    connector.setHost(\"localhost\");\r\n    connector.setPort(Integer.parseInt(port));\r\n    server.addConnector(connector);\r\n    ResourceHandler resource_handler = new ResourceHandler();\r\n    resource_handler.setDirectoriesListed(true);\r\n    resource_handler.setWelcomeFiles(new String[] { \"index.html\" });\r\n    resource_handler.setResourceBase(path);\r\n    HandlerList handlers = new HandlerList();\r\n    handlers.setHandlers(new Handler[] { resource_handler, new DefaultHandler() });\r\n    server.setHandler(handlers);\r\n    LOGGER.info(\"Serving out contents of: [{}] on http://localhost:{}/\", path, port);\r\n    LOGGER.info(\"(To stop server hit CTRL-C)\");\r\n    try {\r\n        server.start();\r\n        server.join();\r\n    } catch (Exception e) {\r\n        LOGGER.error(\"unable to start server\", e);\r\n    }\r\n}"
}, {
	"Path": "net.dv8tion.jda.bot.sharding.ShardManager.getApplicationInfo",
	"Comment": "used to access bot specific functions like oauth information.",
	"Method": "RestAction<ApplicationInfo> getApplicationInfo(){\r\n    return this.getShardCache().stream().findAny().orElseThrow(() -> new IllegalStateException(\"no active shards\")).asBot().getApplicationInfo();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentByte.saveState",
	"Comment": "saves the graphic state. savestate andrestorestate must be balanced.",
	"Method": "void saveState(){\r\n    PdfWriter.checkPdfIsoConformance(writer, PdfIsoKeys.PDFISOKEY_CANVAS, \"q\");\r\n    if (inText && isTagged()) {\r\n        endText();\r\n    }\r\n    content.append(\"q\").append_i(separator);\r\n    stateList.add(new GraphicState(state));\r\n}"
}, {
	"Path": "com.structurizr.view.ViewSet.createSystemContextView",
	"Comment": "creates a system context view, where the scope of the view is the specified software system.",
	"Method": "SystemContextView createSystemContextView(SoftwareSystem softwareSystem,String key,String description){\r\n    assertThatTheSoftwareSystemIsNotNull(softwareSystem);\r\n    assertThatTheViewKeyIsSpecifiedAndUnique(key);\r\n    SystemContextView view = new SystemContextView(softwareSystem, key, description);\r\n    view.setViewSet(this);\r\n    systemContextViews.add(view);\r\n    return view;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.spatial.MeasureGeospatial.setGPTS",
	"Comment": "an array of numbers that shall be taken pairwise, defining points in\tgeographic space as degrees of latitude and longitude. these values shall\tbe based on the geographic coordinate system described in the gcs\tdictionary.",
	"Method": "void setGPTS(NumberArray pairedpoints){\r\n    put(PdfName.GPTS, pairedpoints);\r\n}"
}, {
	"Path": "com.structurizr.analysis.AbstractComponentFinderStrategy.addSupportingTypesStrategy",
	"Comment": "adds a supporting type strategy to this component finder strategy.",
	"Method": "void addSupportingTypesStrategy(SupportingTypesStrategy supportingTypesStrategy){\r\n    if (supportingTypesStrategy == null) {\r\n        throw new IllegalArgumentException(\"A supporting types strategy must be provided.\");\r\n    }\r\n    supportingTypesStrategies.add(supportingTypesStrategy);\r\n}"
}, {
	"Path": "com.sixt.service.framework.kafka.KafkaPublisher.publishSync",
	"Comment": "synchronously publish one or more messages with a null partition key",
	"Method": "boolean publishSync(String events){\r\n    if (events != null) {\r\n        return publishEvents(true, null, events);\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.InlineImageUtils.parseInlineImageDictionary",
	"Comment": "parses the next inline image dictionary from the parser.the parser must be positioned immediately following the ei operator.the parser will be left with position immediately following the whitespace character that follows the id operator that ends the inline image dictionary.",
	"Method": "PdfDictionary parseInlineImageDictionary(PdfContentParser ps){\r\n    PdfDictionary dictionary = new PdfDictionary();\r\n    for (PdfObject key = ps.readPRObject(); key != null && !\"ID\".equals(key.toString()); key = ps.readPRObject()) {\r\n        PdfObject value = ps.readPRObject();\r\n        PdfName resolvedKey = inlineImageEntryAbbreviationMap.get(key);\r\n        if (resolvedKey == null)\r\n            resolvedKey = (PdfName) key;\r\n        dictionary.put(resolvedKey, getAlternateValue(resolvedKey, value));\r\n    }\r\n    int ch = ps.getTokeniser().read();\r\n    if (!PRTokeniser.isWhitespace(ch))\r\n        throw new IOException(\"Unexpected character \" + ch + \" found after ID in inline image\");\r\n    return dictionary;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.LtvVerifier.getCRLsFromDSS",
	"Comment": "gets a list of x509crl objects from a document security store.",
	"Method": "List<X509CRL> getCRLsFromDSS(){\r\n    List<X509CRL> crls = new ArrayList<X509CRL>();\r\n    if (dss == null)\r\n        return crls;\r\n    PdfArray crlarray = dss.getAsArray(PdfName.CRLS);\r\n    if (crlarray == null)\r\n        return crls;\r\n    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\r\n    for (int i = 0; i < crlarray.size(); i++) {\r\n        PRStream stream = (PRStream) crlarray.getAsStream(i);\r\n        X509CRL crl = (X509CRL) cf.generateCRL(new ByteArrayInputStream(PdfReader.getStreamBytes(stream)));\r\n        crls.add(crl);\r\n    }\r\n    return crls;\r\n}"
}, {
	"Path": "com.itextpdf.text.zugferd.InvoiceDOM.importDateTime",
	"Comment": "set the content of a date tag along with the attribute that defines the format.",
	"Method": "void importDateTime(Element parent,String tag,String dateTimeFormat,Date dateTime){\r\n    if (dateTimeFormat == null)\r\n        return;\r\n    importContent(parent, tag, DF_CODE.convertToString(dateTime, DF_CODE.check(dateTimeFormat)), \"format\", dateTimeFormat);\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.EmbedBuilder.isEmpty",
	"Comment": "checks if the given embed is empty. empty embeds will throw an exception if built",
	"Method": "boolean isEmpty(){\r\n    return title == null && description.length() == 0 && timestamp == null && thumbnail == null && author == null && footer == null && image == null && fields.isEmpty();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.PdfContentReaderTool.main",
	"Comment": "writes information about each page in a pdf file to the specified file, or system.out.",
	"Method": "void main(String[] args){\r\n    try {\r\n        if (args.length < 1 || args.length > 3) {\r\n            System.out.println(\"Usage:  PdfContentReaderTool <pdf file> [<output file>|stdout] [<page num>]\");\r\n            return;\r\n        }\r\n        PrintWriter writer = new PrintWriter(System.out);\r\n        if (args.length >= 2) {\r\n            if (args[1].compareToIgnoreCase(\"stdout\") != 0) {\r\n                System.out.println(\"Writing PDF content to \" + args[1]);\r\n                writer = new PrintWriter(new FileOutputStream(new File(args[1])));\r\n            }\r\n        }\r\n        int pageNum = -1;\r\n        if (args.length >= 3) {\r\n            pageNum = Integer.parseInt(args[2]);\r\n        }\r\n        if (pageNum == -1) {\r\n            listContentStream(new File(args[0]), writer);\r\n        } else {\r\n            listContentStream(new File(args[0]), pageNum, writer);\r\n        }\r\n        writer.flush();\r\n        if (args.length >= 2) {\r\n            writer.close();\r\n            System.out.println(\"Finished writing content to \" + args[1]);\r\n        }\r\n    } catch (Exception e) {\r\n        e.printStackTrace(System.err);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.awt.geom.PolylineShapeIterator.getWindingRule",
	"Comment": "return the winding rule for determining the insideness of the\tpath.",
	"Method": "int getWindingRule(){\r\n    return WIND_NON_ZERO;\r\n}"
}, {
	"Path": "com.structurizr.view.ViewSet.createContainerView",
	"Comment": "creates a container view, where the scope of the view is the specified software system.",
	"Method": "ContainerView createContainerView(SoftwareSystem softwareSystem,String key,String description){\r\n    assertThatTheSoftwareSystemIsNotNull(softwareSystem);\r\n    assertThatTheViewKeyIsSpecifiedAndUnique(key);\r\n    ContainerView view = new ContainerView(softwareSystem, key, description);\r\n    view.setViewSet(this);\r\n    containerViews.add(view);\r\n    return view;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.mc.MCParser.dealWithMcid",
	"Comment": "when an mcid is encountered, the parser will check the liststructure items and turn an annotation into an xobject ifnecessary.",
	"Method": "void dealWithMcid(PdfNumber mcid){\r\n    if (mcid == null)\r\n        return;\r\n    StructureItem item = items.get(0);\r\n    if (LOGGER.isLogging(Level.INFO)) {\r\n        LOGGER.info(String.format(\"Encountered MCID %s in content, comparing with %s\", mcid, item));\r\n    }\r\n    switch(item.checkMCID(pageref.getNumber(), mcid.intValue())) {\r\n        case 0:\r\n            StructureObject obj = (StructureObject) item;\r\n            convertToXObject(obj);\r\n            LOGGER.info(\"Removed structure item from stack.\");\r\n            items.remove(0);\r\n            dealWithMcid(mcid);\r\n            return;\r\n        case 1:\r\n            LOGGER.info(\"Removed structure item from stack.\");\r\n            items.remove(0);\r\n            return;\r\n        default:\r\n            LOGGER.warn(\"MCID not found! There's probably an error in your form!\");\r\n            int check;\r\n            for (int i = 1; i < items.size(); i++) {\r\n                item = items.get(i);\r\n                check = item.checkMCID(pageref.getNumber(), mcid.intValue());\r\n                switch(check) {\r\n                    case 1:\r\n                        LOGGER.info(\"Removed structure item from stack.\");\r\n                        items.remove(i);\r\n                        return;\r\n                    case 0:\r\n                        break;\r\n                }\r\n            }\r\n            throw new DocumentException(MessageLocalization.getComposedMessage(\"can.t.read.document.structure\"));\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDictionary.toPdf",
	"Comment": "writes the pdf representation of this pdfdictionary as anarray of byte to the given outputstream.",
	"Method": "void toPdf(PdfWriter writer,OutputStream os){\r\n    PdfWriter.checkPdfIsoConformance(writer, PdfIsoKeys.PDFISOKEY_OBJECT, this);\r\n    os.write('<');\r\n    os.write('<');\r\n    PdfObject value;\r\n    int type = 0;\r\n    for (Entry<PdfName, PdfObject> e : hashMap.entrySet()) {\r\n        e.getKey().toPdf(writer, os);\r\n        value = e.getValue();\r\n        type = value.type();\r\n        if (type != PdfObject.ARRAY && type != PdfObject.DICTIONARY && type != PdfObject.NAME && type != PdfObject.STRING)\r\n            os.write(' ');\r\n        value.toPdf(writer, os);\r\n    }\r\n    os.write('>');\r\n    os.write('>');\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.TaggedPdfTest.createTaggedPdf25",
	"Comment": "resulting pdf should pass all tests in pac2.13 0 obj should contain three repeating 4 0 r references and three 8 0 r.",
	"Method": "void createTaggedPdf25(){\r\n    Document document = new Document();\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    PdfWriter writer = PdfWriter.getInstance(document, baos);\r\n    writer.setViewerPreferences(PdfWriter.DisplayDocTitle);\r\n    writer.setPdfVersion(PdfWriter.VERSION_1_7);\r\n    writer.setTagged();\r\n    PdfDictionary info = writer.getInfo();\r\n    info.put(PdfName.TITLE, new PdfString(\"Testing\"));\r\n    writer.createXmpMetadata();\r\n    document.open();\r\n    document.addLanguage(\"en_US\");\r\n    document.setAccessibleAttribute(PdfName.LANG, new PdfString(\"en_US\"));\r\n    String longParagraphString = \"Long teeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeext Paragraph testing testing\";\r\n    BaseFont bFont = BaseFont.createFont(\"./src/test/resources/com/itextpdf/text/pdf/FreeMonoBold.ttf\", BaseFont.WINANSI, BaseFont.EMBEDDED);\r\n    Font font = new Font(bFont, 12);\r\n    Paragraph p = new Paragraph(longParagraphString, font);\r\n    document.add(p);\r\n    String longChunkString = \"Long teeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeext Span testing testing\";\r\n    Chunk ck = new Chunk(longChunkString, font);\r\n    p = new Paragraph(ck);\r\n    document.add(p);\r\n    document.close();\r\n    String outPath = \"./target/com/itextpdf/test/pdf/TaggedPdfTest/\";\r\n    String outFile = outPath + \"out25.pdf\";\r\n    FileOutputStream fos = new FileOutputStream(new File(outFile));\r\n    fos.write(baos.toByteArray());\r\n    fos.flush();\r\n    fos.close();\r\n    compareResults(\"25\");\r\n    CompareTool compareTool = new CompareTool();\r\n    String cmpFile = \"./src/test/resources/com/itextpdf/text/pdf/TaggedPdfTest/out25.pdf\";\r\n    String errorMessage = compareTool.compareByContent(outFile, cmpFile, outPath, \"diff_\");\r\n    if (errorMessage != null) {\r\n        Assert.fail(errorMessage);\r\n    }\r\n}"
}, {
	"Path": "net.openhft.affinity.NonForkingAffinityLock.acquireCore",
	"Comment": "assign any free core to this thread.in reality, only one cpu is assigned, the rest of the threads for that core are reservable so they are not used.",
	"Method": "AffinityLock acquireCore(AffinityLock acquireCore,boolean bind,AffinityLock acquireCore,boolean bind,int cpuId,AffinityStrategy strategies){\r\n    return LOCK_INVENTORY.acquireCore(bind, cpuId, strategies);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.createBody",
	"Comment": "create a rigid body given a definition. no reference to the definition is retained.",
	"Method": "Body createBody(BodyDef def){\r\n    assert (isLocked() == false);\r\n    if (isLocked()) {\r\n        return null;\r\n    }\r\n    Body b = new Body(def, this);\r\n    b.m_prev = null;\r\n    b.m_next = m_bodyList;\r\n    if (m_bodyList != null) {\r\n        m_bodyList.m_prev = b;\r\n    }\r\n    m_bodyList = b;\r\n    ++m_bodyCount;\r\n    return b;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.getPdfReaderInstance",
	"Comment": "returns the pdfreaderinstance associated with the specified reader.multiple calls with the same reader object will return the samepdfreaderinstance.",
	"Method": "PdfReaderInstance getPdfReaderInstance(PdfReader reader){\r\n    PdfReaderInstance inst = readerInstances.get(reader);\r\n    if (inst == null) {\r\n        inst = reader.getPdfReaderInstance(this);\r\n        readerInstances.put(reader, inst);\r\n    }\r\n    return inst;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.zip.BitOutputStream.nrBits",
	"Comment": "returns the number of bits that have been written to thisbitoutputstream. this may include bits that have not yet been writtento the underlying outputstream.",
	"Method": "long nrBits(){\r\n    return this.nrBits;\r\n}"
}, {
	"Path": "com.sixt.service.framework.MethodHandlerDictionary.addPostHook",
	"Comment": "add a hook to inspect or modify outgoing responses.invoked in the same order as configured at runtime",
	"Method": "void addPostHook(String endpoint,ServiceMethodPostHook<? extends Message> handlerClass){\r\n    if (GLOBAL.equals(endpoint)) {\r\n        globalPostHooks.add(handlerClass);\r\n    } else {\r\n        List<ServiceMethodPostHook<? extends Message>> hooks = methodPostHooks.get(endpoint);\r\n        if (hooks == null) {\r\n            hooks = new ArrayList();\r\n            methodPostHooks.put(endpoint, hooks);\r\n        }\r\n        hooks.add(handlerClass);\r\n    }\r\n}"
}, {
	"Path": "com.example.dlp.DeIdentification.deIdentifyWithFpe",
	"Comment": "deidentify a string by encrypting sensitive information while preserving format.",
	"Method": "void deIdentifyWithFpe(String string,List<InfoType> infoTypes,FfxCommonNativeAlphabet alphabet,String keyName,String wrappedKey,String projectId,String surrogateType){\r\n    try (DlpServiceClient dlpServiceClient = DlpServiceClient.create()) {\r\n        ContentItem contentItem = ContentItem.newBuilder().setValue(string).build();\r\n        KmsWrappedCryptoKey kmsWrappedCryptoKey = KmsWrappedCryptoKey.newBuilder().setWrappedKey(ByteString.copyFrom(BaseEncoding.base64().decode(wrappedKey))).setCryptoKeyName(keyName).build();\r\n        CryptoKey cryptoKey = CryptoKey.newBuilder().setKmsWrapped(kmsWrappedCryptoKey).build();\r\n        CryptoReplaceFfxFpeConfig cryptoReplaceFfxFpeConfig = CryptoReplaceFfxFpeConfig.newBuilder().setCryptoKey(cryptoKey).setCommonAlphabet(alphabet).setSurrogateInfoType(InfoType.newBuilder().setName(surrogateType).build()).build();\r\n        PrimitiveTransformation primitiveTransformation = PrimitiveTransformation.newBuilder().setCryptoReplaceFfxFpeConfig(cryptoReplaceFfxFpeConfig).build();\r\n        InfoTypeTransformation infoTypeTransformationObject = InfoTypeTransformation.newBuilder().setPrimitiveTransformation(primitiveTransformation).build();\r\n        InfoTypeTransformations infoTypeTransformationArray = InfoTypeTransformations.newBuilder().addTransformations(infoTypeTransformationObject).build();\r\n        InspectConfig inspectConfig = InspectConfig.newBuilder().addAllInfoTypes(infoTypes).build();\r\n        DeidentifyConfig deidentifyConfig = DeidentifyConfig.newBuilder().setInfoTypeTransformations(infoTypeTransformationArray).build();\r\n        DeidentifyContentRequest request = DeidentifyContentRequest.newBuilder().setParent(ProjectName.of(projectId).toString()).setInspectConfig(inspectConfig).setDeidentifyConfig(deidentifyConfig).setItem(contentItem).build();\r\n        DeidentifyContentResponse response = dlpServiceClient.deidentifyContent(request);\r\n        String result = response.getItem().getValue();\r\n        System.out.println(result);\r\n    } catch (Exception e) {\r\n        System.out.println(\"Error in deidentifyWithFpe: \" + e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfLayer.setView",
	"Comment": "indicates that the group should be set to that state when thedocument is opened in a viewer application.",
	"Method": "void setView(boolean view){\r\n    PdfDictionary usage = getUsage();\r\n    PdfDictionary dic = new PdfDictionary();\r\n    dic.put(PdfName.VIEWSTATE, view ? PdfName.ON : PdfName.OFF);\r\n    usage.put(PdfName.VIEW, dic);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPTable.skipColsWithRowspanAbove",
	"Comment": "when updating the row index, cells with rowspan should be taken intoaccount. this is what happens in this method.",
	"Method": "void skipColsWithRowspanAbove(){\r\n    int direction = 1;\r\n    if (runDirection == PdfWriter.RUN_DIRECTION_RTL) {\r\n        direction = -1;\r\n    }\r\n    while (rowSpanAbove(rows.size(), currentColIdx)) {\r\n        currentColIdx += direction;\r\n    }\r\n}"
}, {
	"Path": "com.structurizr.view.ComponentView.addAllElements",
	"Comment": "adds all people, software systems, sibling containers and components belonging to the container in scope.",
	"Method": "void addAllElements(){\r\n    addAllSoftwareSystems();\r\n    addAllPeople();\r\n    addAllContainers();\r\n    addAllComponents();\r\n}"
}, {
	"Path": "com.example.firestore.snippets.ManageDataSnippets.runSimpleTransaction",
	"Comment": "run a simple transaction to perform a field value increment.",
	"Method": "ApiFuture<Void> runSimpleTransaction(){\r\n    final DocumentReference docRef = db.collection(\"cities\").document(\"SF\");\r\n    City city = new City(\"SF\");\r\n    city.setCountry(\"USA\");\r\n    city.setPopulation(860000L);\r\n    docRef.set(city).get();\r\n    ApiFuture<Void> transaction = db.runTransaction(new Transaction.Function<Void>() {\r\n        @Override\r\n        public Void updateCallback(Transaction transaction) throws Exception {\r\n            DocumentSnapshot snapshot = transaction.get(docRef).get();\r\n            long oldPopulation = snapshot.getLong(\"population\");\r\n            transaction.update(docRef, \"population\", oldPopulation + 1);\r\n            return null;\r\n        }\r\n    });\r\n    return transaction;\r\n}"
}, {
	"Path": "com.example.firestore.snippets.ManageDataSnippets.runSimpleTransaction",
	"Comment": "run a simple transaction to perform a field value increment.",
	"Method": "ApiFuture<Void> runSimpleTransaction(){\r\n    DocumentSnapshot snapshot = transaction.get(docRef).get();\r\n    long oldPopulation = snapshot.getLong(\"population\");\r\n    transaction.update(docRef, \"population\", oldPopulation + 1);\r\n    return null;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.PdfContentStreamProcessor.getRenderListener",
	"Comment": "accessor method for the renderlistener object maintained in this class.necessary for implementing custom contentoperator implementations.",
	"Method": "RenderListener getRenderListener(){\r\n    return renderListener;\r\n}"
}, {
	"Path": "com.example.containeranalysis.Samples.getOccurrence",
	"Comment": "retrieves and prints a specified occurrence from the server",
	"Method": "Occurrence getOccurrence(GrafeasV1Beta1Client client,String occurrenceName){\r\n    Occurrence occ = client.getOccurrence(occurrenceName);\r\n    System.out.println(occ);\r\n    return occ;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.tokenizer.core.ADictionary.loadDirectory",
	"Comment": "load the all the words from all the files under a specified lexicon directory",
	"Method": "void loadDirectory(String lexDir){\r\n    File path = new File(lexDir);\r\n    if (!path.exists()) {\r\n        throw new IOException(\"Lexicon directory [\" + lexDir + \"] does'n exists.\");\r\n    }\r\n    File[] files = path.listFiles(new FilenameFilter() {\r\n        @Override\r\n        public boolean accept(File dir, String name) {\r\n            return (name.startsWith(\"lex-\") && name.endsWith(\".lex\"));\r\n        }\r\n    });\r\n    for (File file : files) {\r\n        load(file);\r\n    }\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.tokenizer.core.ADictionary.loadDirectory",
	"Comment": "load the all the words from all the files under a specified lexicon directory",
	"Method": "void loadDirectory(String lexDir){\r\n    return (name.startsWith(\"lex-\") && name.endsWith(\".lex\"));\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.util.IStringBuffer.setLength",
	"Comment": "set the length of the bufferactually it just override the count and the actual bufferhas nothing changed",
	"Method": "int setLength(int length){\r\n    int oldCount = count;\r\n    count = length;\r\n    return oldCount;\r\n}"
}, {
	"Path": "com.structurizr.view.ViewSet.getFilteredViewWithKey",
	"Comment": "finds the filtered view with the specified key, or null if the view does not exist.",
	"Method": "FilteredView getFilteredViewWithKey(String key){\r\n    if (key == null) {\r\n        throw new IllegalArgumentException(\"A key must be specified.\");\r\n    }\r\n    return filteredViews.stream().filter(v -> key.equals(v.getKey())).findFirst().orElse(null);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentByte.createPattern",
	"Comment": "create a new uncolored tiling pattern.variables xstep and ystep are set to the same valuesof width and height.",
	"Method": "PdfPatternPainter createPattern(float width,float height,float xstep,float ystep,PdfPatternPainter createPattern,float width,float height,PdfPatternPainter createPattern,float width,float height,float xstep,float ystep,BaseColor color,PdfPatternPainter createPattern,float width,float height,BaseColor color){\r\n    return createPattern(width, height, width, height, color);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.IntHashtable.get",
	"Comment": "returns the value to which the specified key is mapped in this map.",
	"Method": "int get(int key){\r\n    Entry[] tab = table;\r\n    int hash = key;\r\n    int index = (hash & 0x7FFFFFFF) % tab.length;\r\n    for (Entry e = tab[index]; e != null; e = e.next) {\r\n        if (e.hash == hash && e.key == key) {\r\n            return e.value;\r\n        }\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.CuePoint.setName",
	"Comment": "set the name of the cue point to match against the cue point within\tflash content and for display purposes.",
	"Method": "void setName(PdfString name){\r\n    put(PdfName.NAME, name);\r\n}"
}, {
	"Path": "com.structurizr.model.SoftwareSystem.addContainer",
	"Comment": "adds a container with the specified name, description and technology",
	"Method": "Container addContainer(String name,String description,String technology){\r\n    return getModel().addContainer(this, name, description, technology);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BarcodePDF417.setCodeRows",
	"Comment": "sets the number of barcode rows. this number may be changedto keep the barcode valid.",
	"Method": "void setCodeRows(int codeRows){\r\n    this.codeRows = codeRows;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONWriter.key",
	"Comment": "append a key. the key will be associated with the next value. in anobject, every value must be preceded by a key.",
	"Method": "JSONWriter key(String string){\r\n    if (string == null) {\r\n        throw new JSONException(\"Null key.\");\r\n    }\r\n    if (this.mode == 'k') {\r\n        try {\r\n            this.stack[this.top - 1].putOnce(string, Boolean.TRUE);\r\n            if (this.comma) {\r\n                this.writer.write(',');\r\n            }\r\n            this.writer.write(JSONObject.quote(string));\r\n            this.writer.write(':');\r\n            this.comma = false;\r\n            this.mode = 'o';\r\n            return this;\r\n        } catch (IOException e) {\r\n            throw new JSONException(e);\r\n        }\r\n    }\r\n    throw new JSONException(\"Misplaced key.\");\r\n}"
}, {
	"Path": "net.openhft.affinity.AffinityLock.acquireLock",
	"Comment": "assign a cpu which can be bound to the current thread or another thread.this can be usedfor defining your thread layout centrally and passing the handle via dependency injection.",
	"Method": "AffinityLock acquireLock(AffinityLock acquireLock,boolean bind,AffinityLock acquireLock,int cpuId,AffinityLock acquireLock,boolean bind,int cpuId,AffinityStrategy strategies,AffinityLock acquireLock,AffinityStrategy strategies){\r\n    return acquireLock(false, cpuId, strategies);\r\n}"
}, {
	"Path": "com.example.time.testing.FakeClock.setNow",
	"Comment": "sets the value of the underlying instance for testing purposes.",
	"Method": "FakeClock setNow(ReadableInstant now){\r\n    fakeNowMs.set(now.getMillis());\r\n    return this;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.getLinearVelocityFromWorldPoint",
	"Comment": "get the world linear velocity of a world point attached to this body.",
	"Method": "Vec2 getLinearVelocityFromWorldPoint(Vec2 worldPoint){\r\n    Vec2 out = new Vec2();\r\n    getLinearVelocityFromWorldPointToOut(worldPoint, out);\r\n    return out;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.Kim.characterSize",
	"Comment": "returns the number of bytes needed to contain the character in kimformat.",
	"Method": "int characterSize(int character){\r\n    if (character < 0 || character > 0x10FFFF) {\r\n        throw new JSONException(\"Bad character \" + character);\r\n    }\r\n    return character <= 0x7F ? 1 : character <= 0x3FFF ? 2 : 3;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentByte.localGoto",
	"Comment": "implements a link to other part of the document. the jump willbe made to a local destination with the same name, that must exist.",
	"Method": "void localGoto(String name,float llx,float lly,float urx,float ury){\r\n    pdf.localGoto(name, llx, lly, urx, ury);\r\n}"
}, {
	"Path": "com.itextpdf.text.xml.xmp.XmpReader.replaceDescriptionAttribute",
	"Comment": "replaces the content of an attribute in the description tag.",
	"Method": "boolean replaceDescriptionAttribute(String namespaceURI,String localName,String value){\r\n    NodeList descNodes = domDocument.getElementsByTagNameNS(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\", \"Description\");\r\n    if (descNodes.getLength() == 0) {\r\n        return false;\r\n    }\r\n    Node node;\r\n    for (int i = 0; i < descNodes.getLength(); i++) {\r\n        node = descNodes.item(i);\r\n        Node attr = node.getAttributes().getNamedItemNS(namespaceURI, localName);\r\n        if (attr != null) {\r\n            attr.setNodeValue(value);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.html.table.TableStyleValues.setLastInRow",
	"Comment": "only used by cells. this boolean is used for adding a horizontal border spacing to the right of a cell.",
	"Method": "void setLastInRow(boolean isLastInRow){\r\n    this.isLastInRow = isLastInRow;\r\n}"
}, {
	"Path": "software.amazon.ion.Timestamp.addDay",
	"Comment": "returns a timestamp relative to this one by the given number of days.",
	"Method": "Timestamp addDay(int amount){\r\n    long delta = (long) amount * 24 * 60 * 60 * 1000;\r\n    return addMillis(delta);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.TaggedPdfReaderTool.inspectChild",
	"Comment": "inspects a child of a structured element. this can be an array or a\tdictionary.",
	"Method": "void inspectChild(PdfObject k){\r\n    if (k == null)\r\n        return;\r\n    if (k instanceof PdfArray)\r\n        inspectChildArray((PdfArray) k);\r\n    else if (k instanceof PdfDictionary)\r\n        inspectChildDictionary((PdfDictionary) k);\r\n}"
}, {
	"Path": "com.example.containeranalysis.Samples.createOccurrence",
	"Comment": "creates and returns a new occurrence of a previously created vulnerability note",
	"Method": "Occurrence createOccurrence(GrafeasV1Beta1Client client,String imageUrl,String noteId,String occProjectId,String noteProjectId){\r\n    final NoteName noteName = NoteName.of(noteProjectId, noteId);\r\n    final String occProjectName = ProjectName.format(occProjectId);\r\n    Occurrence.Builder occBuilder = Occurrence.newBuilder();\r\n    occBuilder.setNoteName(noteName.toString());\r\n    Details.Builder detailsBuilder = Details.newBuilder();\r\n    occBuilder.setVulnerability(detailsBuilder);\r\n    Resource.Builder resourceBuilder = Resource.newBuilder();\r\n    resourceBuilder.setUri(imageUrl);\r\n    occBuilder.setResource(resourceBuilder);\r\n    Occurrence newOcc = occBuilder.build();\r\n    return client.createOccurrence(occProjectName, newOcc);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.createFakeFontSubsets",
	"Comment": "finds all the fonts not subset but embedded and marks them as subset.",
	"Method": "int createFakeFontSubsets(){\r\n    int total = 0;\r\n    for (int k = 1; k < xrefObj.size(); ++k) {\r\n        PdfObject obj = getPdfObjectRelease(k);\r\n        if (obj == null || !obj.isDictionary())\r\n            continue;\r\n        PdfDictionary dic = (PdfDictionary) obj;\r\n        if (!existsName(dic, PdfName.TYPE, PdfName.FONT))\r\n            continue;\r\n        if (existsName(dic, PdfName.SUBTYPE, PdfName.TYPE1) || existsName(dic, PdfName.SUBTYPE, PdfName.MMTYPE1) || existsName(dic, PdfName.SUBTYPE, PdfName.TRUETYPE)) {\r\n            String s = getSubsetPrefix(dic);\r\n            if (s != null)\r\n                continue;\r\n            s = getFontName(dic);\r\n            if (s == null)\r\n                continue;\r\n            String ns = BaseFont.createSubsetPrefix() + s;\r\n            PdfDictionary fd = (PdfDictionary) getPdfObjectRelease(dic.get(PdfName.FONTDESCRIPTOR));\r\n            if (fd == null)\r\n                continue;\r\n            if (fd.get(PdfName.FONTFILE) == null && fd.get(PdfName.FONTFILE2) == null && fd.get(PdfName.FONTFILE3) == null)\r\n                continue;\r\n            fd = dic.getAsDict(PdfName.FONTDESCRIPTOR);\r\n            PdfName newName = new PdfName(ns);\r\n            dic.put(PdfName.BASEFONT, newName);\r\n            fd.put(PdfName.FONTNAME, newName);\r\n            setXrefPartialObject(k, dic);\r\n            ++total;\r\n        }\r\n    }\r\n    return total;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseField.setRotation",
	"Comment": "sets the field rotation. this value should be the same asthe page rotation where the field will be shown.",
	"Method": "void setRotation(int rotation){\r\n    if (rotation % 90 != 0)\r\n        throw new IllegalArgumentException(MessageLocalization.getComposedMessage(\"rotation.must.be.a.multiple.of.90\"));\r\n    rotation %= 360;\r\n    if (rotation < 0)\r\n        rotation += 360;\r\n    this.rotation = rotation;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPNodeUtils.serializeNodeValue",
	"Comment": "converts the node value to string, apply special conversions for defined\ttypes in xmp.",
	"Method": "String serializeNodeValue(Object value){\r\n    String strValue;\r\n    if (value == null) {\r\n        strValue = null;\r\n    } else if (value instanceof Boolean) {\r\n        strValue = XMPUtils.convertFromBoolean(((Boolean) value).booleanValue());\r\n    } else if (value instanceof Integer) {\r\n        strValue = XMPUtils.convertFromInteger(((Integer) value).intValue());\r\n    } else if (value instanceof Long) {\r\n        strValue = XMPUtils.convertFromLong(((Long) value).longValue());\r\n    } else if (value instanceof Double) {\r\n        strValue = XMPUtils.convertFromDouble(((Double) value).doubleValue());\r\n    } else if (value instanceof XMPDateTime) {\r\n        strValue = XMPUtils.convertFromDate((XMPDateTime) value);\r\n    } else if (value instanceof GregorianCalendar) {\r\n        XMPDateTime dt = XMPDateTimeFactory.createFromCalendar((GregorianCalendar) value);\r\n        strValue = XMPUtils.convertFromDate(dt);\r\n    } else if (value instanceof byte[]) {\r\n        strValue = XMPUtils.encodeBase64((byte[]) value);\r\n    } else {\r\n        strValue = value.toString();\r\n    }\r\n    return strValue != null ? Utils.removeControlChars(strValue) : null;\r\n}"
}, {
	"Path": "com.itextpdf.text.FontFactoryImp.registerFamily",
	"Comment": "register a font by giving explicitly the font family and name.",
	"Method": "void registerFamily(String familyName,String fullName,String path){\r\n    if (path != null)\r\n        trueTypeFonts.put(fullName, path);\r\n    ArrayList<String> tmp;\r\n    synchronized (fontFamilies) {\r\n        tmp = fontFamilies.get(familyName);\r\n        if (tmp == null) {\r\n            tmp = new ArrayList<String>();\r\n            fontFamilies.put(familyName, tmp);\r\n        }\r\n    }\r\n    synchronized (tmp) {\r\n        if (!tmp.contains(fullName)) {\r\n            int fullNameLength = fullName.length();\r\n            boolean inserted = false;\r\n            for (int j = 0; j < tmp.size(); ++j) {\r\n                if (tmp.get(j).length() >= fullNameLength) {\r\n                    tmp.add(j, fullName);\r\n                    inserted = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!inserted) {\r\n                tmp.add(fullName);\r\n                String newFullName = fullName.toLowerCase();\r\n                if (newFullName.endsWith(\"regular\")) {\r\n                    newFullName = newFullName.substring(0, newFullName.length() - 7).trim();\r\n                    tmp.add(0, fullName.substring(0, newFullName.length()));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.getFontMatrix",
	"Comment": "get default array of six numbers specifying the font matrix, mapping glyph space to text space",
	"Method": "double[] getFontMatrix(){\r\n    return DEFAULT_FONT_MATRIX;\r\n}"
}, {
	"Path": "com.example.dlp.Templates.deleteInspectTemplate",
	"Comment": "delete the dlp inspection configuration template with the specified name.",
	"Method": "void deleteInspectTemplate(String projectId,String templateId){\r\n    String templateName = String.format(\"projects/%s/inspectTemplates/%s\", projectId, templateId);\r\n    try (DlpServiceClient dlpServiceClient = DlpServiceClient.create()) {\r\n        DeleteInspectTemplateRequest request = DeleteInspectTemplateRequest.newBuilder().setName(templateName).build();\r\n        dlpServiceClient.deleteInspectTemplate(request);\r\n        System.out.printf(\"Deleted template: %s\\n\", templateName);\r\n    } catch (Exception e) {\r\n        System.err.printf(\"Error deleting template: %s\\n\", templateName);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.VerificationOK.toString",
	"Comment": "a single string explaining which certificate was verified, how and why.",
	"Method": "String toString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    if (certificate != null) {\r\n        sb.append(certificate.getSubjectDN().getName());\r\n        sb.append(\" verified with \");\r\n    }\r\n    sb.append(verifierClass.getName());\r\n    sb.append(\": \");\r\n    sb.append(message);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "software.amazon.ion.impl.IonReaderTextRawTokensX.load_raw_characters",
	"Comment": "this is used to load a previously marked set of bytesinto the stringbuilder without escaping.it expectsthe caller to have set a save point so that the eofwill stop us at the right time.this does handle utf8 decoding and surrogate encodingas the bytes are transfered.",
	"Method": "void load_raw_characters(StringBuilder sb){\r\n    int c = read_char();\r\n    for (; ; ) {\r\n        c = read_char();\r\n        switch(c) {\r\n            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:\r\n            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:\r\n            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:\r\n                continue;\r\n            case -1:\r\n                return;\r\n            default:\r\n                if (!IonTokenConstsX.is7bitValue(c)) {\r\n                    c = read_large_char_sequence(c);\r\n                }\r\n        }\r\n        if (IonUTF8.needsSurrogateEncoding(c)) {\r\n            sb.append(IonUTF8.highSurrogate(c));\r\n            c = IonUTF8.lowSurrogate(c);\r\n        }\r\n        sb.append((char) c);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BarcodeCodabar.createAwtImage",
	"Comment": "creates a java.awt.image. this image onlycontains the bars without any text.",
	"Method": "java.awt.Image createAwtImage(java.awt.Color foreground,java.awt.Color background){\r\n    int f = foreground.getRGB();\r\n    int g = background.getRGB();\r\n    java.awt.Canvas canvas = new java.awt.Canvas();\r\n    String fullCode = code;\r\n    if (generateChecksum && checksumText)\r\n        fullCode = calculateChecksum(code);\r\n    if (!startStopText)\r\n        fullCode = fullCode.substring(1, fullCode.length() - 1);\r\n    byte[] bars = getBarsCodabar(generateChecksum ? calculateChecksum(code) : code);\r\n    int wide = 0;\r\n    for (int k = 0; k < bars.length; ++k) {\r\n        wide += bars[k];\r\n    }\r\n    int narrow = bars.length - wide;\r\n    int fullWidth = narrow + wide * (int) n;\r\n    boolean print = true;\r\n    int ptr = 0;\r\n    int height = (int) barHeight;\r\n    int[] pix = new int[fullWidth * height];\r\n    for (int k = 0; k < bars.length; ++k) {\r\n        int w = (bars[k] == 0 ? 1 : (int) n);\r\n        int c = g;\r\n        if (print)\r\n            c = f;\r\n        print = !print;\r\n        for (int j = 0; j < w; ++j) pix[ptr++] = c;\r\n    }\r\n    for (int k = fullWidth; k < pix.length; k += fullWidth) {\r\n        System.arraycopy(pix, 0, pix, k, fullWidth);\r\n    }\r\n    java.awt.Image img = canvas.createImage(new java.awt.image.MemoryImageSource(fullWidth, height, pix, 0, fullWidth));\r\n    return img;\r\n}"
}, {
	"Path": "com.itextpdf.awt.geom.gl.Crossing.intersectLine",
	"Comment": "returns how many times rectangle stripe cross line or the are intersect",
	"Method": "int intersectLine(double x1,double y1,double x2,double y2,double rx1,double ry1,double rx2,double ry2){\r\n    if ((rx2 < x1 && rx2 < x2) || (rx1 > x1 && rx1 > x2) || (ry1 > y1 && ry1 > y2)) {\r\n        return 0;\r\n    }\r\n    if (ry2 < y1 && ry2 < y2) {\r\n    } else {\r\n        if (x1 == x2) {\r\n            return CROSSING;\r\n        }\r\n        double bx1, bx2;\r\n        if (x1 < x2) {\r\n            bx1 = x1 < rx1 ? rx1 : x1;\r\n            bx2 = x2 < rx2 ? x2 : rx2;\r\n        } else {\r\n            bx1 = x2 < rx1 ? rx1 : x2;\r\n            bx2 = x1 < rx2 ? x1 : rx2;\r\n        }\r\n        double k = (y2 - y1) / (x2 - x1);\r\n        double by1 = k * (bx1 - x1) + y1;\r\n        double by2 = k * (bx2 - x1) + y1;\r\n        if (by1 < ry1 && by2 < ry1) {\r\n            return 0;\r\n        }\r\n        if (by1 > ry2 && by2 > ry2) {\r\n        } else {\r\n            return CROSSING;\r\n        }\r\n    }\r\n    if (x1 == x2) {\r\n        return 0;\r\n    }\r\n    if (rx1 == x1) {\r\n        return x1 < x2 ? 0 : -1;\r\n    }\r\n    if (rx1 == x2) {\r\n        return x1 < x2 ? 1 : 0;\r\n    }\r\n    if (x1 < x2) {\r\n        return x1 < rx1 && rx1 < x2 ? 1 : 0;\r\n    }\r\n    return x2 < rx1 && rx1 < x1 ? -1 : 0;\r\n}"
}, {
	"Path": "com.structurizr.documentation.AutomaticDocumentationTemplate.addSections",
	"Comment": "adds all files in the specified directory, each in its own section, related to a software system.",
	"Method": "List<Section> addSections(File directory,List<Section> addSections,SoftwareSystem softwareSystem,File directory){\r\n    if (softwareSystem == null) {\r\n        throw new IllegalArgumentException(\"A software system must be specified.\");\r\n    }\r\n    return add(softwareSystem, directory);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.getCompressionLevel",
	"Comment": "returns the compression level used for streams written by this writer.",
	"Method": "int getCompressionLevel(){\r\n    return compressionLevel;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.XfaForm.setDatasetsSom",
	"Comment": "sets the class that contains the datasets processing section of the xfa.",
	"Method": "void setDatasetsSom(Xml2SomDatasets datasetsSom){\r\n    this.datasetsSom = datasetsSom;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPTable.completeRow",
	"Comment": "completes the current row with the default cell. an incomplete row willbe dropped but calling this method will make sure that it will be presentin the table.",
	"Method": "void completeRow(){\r\n    while (!rowCompleted) {\r\n        addCell(defaultCell);\r\n    }\r\n}"
}, {
	"Path": "com.structurizr.view.ContainerView.addAllElements",
	"Comment": "adds all people, software systems and containers that belong to the software system in scope.",
	"Method": "void addAllElements(){\r\n    addAllSoftwareSystems();\r\n    addAllPeople();\r\n    addAllContainers();\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.setDestructionListener",
	"Comment": "register a destruction listener. the listener is owned by you and must remain in scope.",
	"Method": "void setDestructionListener(DestructionListener listener){\r\n    m_destructionListener = listener;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentByte.showTextAlignedKerned",
	"Comment": "shows text kerned right, left or center aligned with rotation.",
	"Method": "void showTextAlignedKerned(int alignment,String text,float x,float y,float rotation){\r\n    showTextAligned(alignment, text, x, y, rotation, true);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfSignatureAppearance.getAppearance",
	"Comment": "gets the main appearance layer.consult ppkappearances.pdffor further details.",
	"Method": "PdfTemplate getAppearance(){\r\n    if (isInvisible()) {\r\n        PdfTemplate t = new PdfTemplate(writer);\r\n        t.setBoundingBox(new Rectangle(0, 0));\r\n        writer.addDirectTemplateSimple(t, null);\r\n        return t;\r\n    }\r\n    if (app[0] == null && !reuseAppearance) {\r\n        createBlankN0();\r\n    }\r\n    if (app[1] == null && !acro6Layers) {\r\n        PdfTemplate t = app[1] = new PdfTemplate(writer);\r\n        t.setBoundingBox(new Rectangle(100, 100));\r\n        writer.addDirectTemplateSimple(t, new PdfName(\"n1\"));\r\n        t.setLiteral(questionMark);\r\n    }\r\n    if (app[2] == null) {\r\n        String text;\r\n        if (layer2Text == null) {\r\n            StringBuilder buf = new StringBuilder();\r\n            buf.append(\"Digitally signed by \");\r\n            String name = null;\r\n            X500Name x500name = CertificateInfo.getSubjectFields((X509Certificate) signCertificate);\r\n            if (x500name != null) {\r\n                name = x500name.getField(\"CN\");\r\n                if (name == null)\r\n                    name = x500name.getField(\"E\");\r\n            }\r\n            if (name == null)\r\n                name = \"\";\r\n            buf.append(name).append('\\n');\r\n            SimpleDateFormat sd = new SimpleDateFormat(\"yyyy.MM.dd HH:mm:ss z\");\r\n            buf.append(\"Date: \").append(sd.format(signDate.getTime()));\r\n            if (reason != null)\r\n                buf.append('\\n').append(reasonCaption).append(reason);\r\n            if (location != null)\r\n                buf.append('\\n').append(locationCaption).append(location);\r\n            text = buf.toString();\r\n        } else\r\n            text = layer2Text;\r\n        PdfTemplate t = app[2] = new PdfTemplate(writer);\r\n        t.setBoundingBox(rect);\r\n        writer.addDirectTemplateSimple(t, new PdfName(\"n2\"));\r\n        if (image != null) {\r\n            if (imageScale == 0) {\r\n                t.addImage(image, rect.getWidth(), 0, 0, rect.getHeight(), 0, 0);\r\n            } else {\r\n                float usableScale = imageScale;\r\n                if (imageScale < 0)\r\n                    usableScale = Math.min(rect.getWidth() / image.getWidth(), rect.getHeight() / image.getHeight());\r\n                float w = image.getWidth() * usableScale;\r\n                float h = image.getHeight() * usableScale;\r\n                float x = (rect.getWidth() - w) / 2;\r\n                float y = (rect.getHeight() - h) / 2;\r\n                t.addImage(image, w, 0, 0, h, x, y);\r\n            }\r\n        }\r\n        Font font;\r\n        if (layer2Font == null)\r\n            font = new Font();\r\n        else\r\n            font = new Font(layer2Font);\r\n        float size = font.getSize();\r\n        Rectangle dataRect = null;\r\n        Rectangle signatureRect = null;\r\n        if (renderingMode == RenderingMode.NAME_AND_DESCRIPTION || renderingMode == RenderingMode.GRAPHIC_AND_DESCRIPTION && this.signatureGraphic != null) {\r\n            signatureRect = new Rectangle(MARGIN, MARGIN, rect.getWidth() / 2 - MARGIN, rect.getHeight() - MARGIN);\r\n            dataRect = new Rectangle(rect.getWidth() / 2 + MARGIN / 2, MARGIN, rect.getWidth() - MARGIN / 2, rect.getHeight() - MARGIN);\r\n            if (rect.getHeight() > rect.getWidth()) {\r\n                signatureRect = new Rectangle(MARGIN, rect.getHeight() / 2, rect.getWidth() - MARGIN, rect.getHeight());\r\n                dataRect = new Rectangle(MARGIN, MARGIN, rect.getWidth() - MARGIN, rect.getHeight() / 2 - MARGIN);\r\n            }\r\n        } else if (renderingMode == RenderingMode.GRAPHIC) {\r\n            if (signatureGraphic == null) {\r\n                throw new IllegalStateException(MessageLocalization.getComposedMessage(\"a.signature.image.should.be.present.when.rendering.mode.is.graphic.only\"));\r\n            }\r\n            signatureRect = new // take all space available\r\n            Rectangle(// take all space available\r\n            MARGIN, MARGIN, rect.getWidth() - MARGIN, rect.getHeight() - MARGIN);\r\n        } else {\r\n            dataRect = new Rectangle(MARGIN, MARGIN, rect.getWidth() - MARGIN, rect.getHeight() * (1 - TOP_SECTION) - MARGIN);\r\n        }\r\n        switch(renderingMode) {\r\n            case NAME_AND_DESCRIPTION:\r\n                String signedBy = CertificateInfo.getSubjectFields((X509Certificate) signCertificate).getField(\"CN\");\r\n                if (signedBy == null)\r\n                    signedBy = CertificateInfo.getSubjectFields((X509Certificate) signCertificate).getField(\"E\");\r\n                if (signedBy == null)\r\n                    signedBy = \"\";\r\n                Rectangle sr2 = new Rectangle(signatureRect.getWidth() - MARGIN, signatureRect.getHeight() - MARGIN);\r\n                float signedSize = ColumnText.fitText(font, signedBy, sr2, -1, runDirection);\r\n                ColumnText ct2 = new ColumnText(t);\r\n                ct2.setRunDirection(runDirection);\r\n                ct2.setSimpleColumn(new Phrase(signedBy, font), signatureRect.getLeft(), signatureRect.getBottom(), signatureRect.getRight(), signatureRect.getTop(), signedSize, Element.ALIGN_LEFT);\r\n                ct2.go();\r\n                break;\r\n            case GRAPHIC_AND_DESCRIPTION:\r\n                if (signatureGraphic == null) {\r\n                    throw new IllegalStateException(MessageLocalization.getComposedMessage(\"a.signature.image.should.be.present.when.rendering.mode.is.graphic.and.description\"));\r\n                }\r\n                ct2 = new ColumnText(t);\r\n                ct2.setRunDirection(runDirection);\r\n                ct2.setSimpleColumn(signatureRect.getLeft(), signatureRect.getBottom(), signatureRect.getRight(), signatureRect.getTop(), 0, Element.ALIGN_RIGHT);\r\n                Image im = Image.getInstance(signatureGraphic);\r\n                im.scaleToFit(signatureRect.getWidth(), signatureRect.getHeight());\r\n                Paragraph p = new Paragraph();\r\n                float x = 0;\r\n                float y = -im.getScaledHeight() + 15;\r\n                x = x + (signatureRect.getWidth() - im.getScaledWidth()) / 2;\r\n                y = y - (signatureRect.getHeight() - im.getScaledHeight()) / 2;\r\n                p.add(new Chunk(im, x + (signatureRect.getWidth() - im.getScaledWidth()) / 2, y, false));\r\n                ct2.addElement(p);\r\n                ct2.go();\r\n                break;\r\n            case GRAPHIC:\r\n                ct2 = new ColumnText(t);\r\n                ct2.setRunDirection(runDirection);\r\n                ct2.setSimpleColumn(signatureRect.getLeft(), signatureRect.getBottom(), signatureRect.getRight(), signatureRect.getTop(), 0, Element.ALIGN_RIGHT);\r\n                im = Image.getInstance(signatureGraphic);\r\n                im.scaleToFit(signatureRect.getWidth(), signatureRect.getHeight());\r\n                p = new Paragraph(signatureRect.getHeight());\r\n                x = (signatureRect.getWidth() - im.getScaledWidth()) / 2;\r\n                y = (signatureRect.getHeight() - im.getScaledHeight()) / 2;\r\n                p.add(new Chunk(im, x, y, false));\r\n                ct2.addElement(p);\r\n                ct2.go();\r\n                break;\r\n            default:\r\n        }\r\n        if (renderingMode != RenderingMode.GRAPHIC) {\r\n            if (size <= 0) {\r\n                Rectangle sr = new Rectangle(dataRect.getWidth(), dataRect.getHeight());\r\n                size = ColumnText.fitText(font, text, sr, 12, runDirection);\r\n            }\r\n            ColumnText ct = new ColumnText(t);\r\n            ct.setRunDirection(runDirection);\r\n            ct.setSimpleColumn(new Phrase(text, font), dataRect.getLeft(), dataRect.getBottom(), dataRect.getRight(), dataRect.getTop(), size, Element.ALIGN_LEFT);\r\n            ct.go();\r\n        }\r\n    }\r\n    if (app[3] == null && !acro6Layers) {\r\n        PdfTemplate t = app[3] = new PdfTemplate(writer);\r\n        t.setBoundingBox(new Rectangle(100, 100));\r\n        writer.addDirectTemplateSimple(t, new PdfName(\"n3\"));\r\n        t.setLiteral(\"% DSBlank\\n\");\r\n    }\r\n    if (app[4] == null && !acro6Layers) {\r\n        PdfTemplate t = app[4] = new PdfTemplate(writer);\r\n        t.setBoundingBox(new Rectangle(0, rect.getHeight() * (1 - TOP_SECTION), rect.getRight(), rect.getTop()));\r\n        writer.addDirectTemplateSimple(t, new PdfName(\"n4\"));\r\n        Font font;\r\n        if (layer2Font == null)\r\n            font = new Font();\r\n        else\r\n            font = new Font(layer2Font);\r\n        String text = \"Signature Not Verified\";\r\n        if (layer4Text != null)\r\n            text = layer4Text;\r\n        Rectangle sr = new Rectangle(rect.getWidth() - 2 * MARGIN, rect.getHeight() * TOP_SECTION - 2 * MARGIN);\r\n        float size = ColumnText.fitText(font, text, sr, 15, runDirection);\r\n        ColumnText ct = new ColumnText(t);\r\n        ct.setRunDirection(runDirection);\r\n        ct.setSimpleColumn(new Phrase(text, font), MARGIN, 0, rect.getWidth() - MARGIN, rect.getHeight() - MARGIN, size, Element.ALIGN_LEFT);\r\n        ct.go();\r\n    }\r\n    int rotation = writer.reader.getPageRotation(page);\r\n    Rectangle rotated = new Rectangle(rect);\r\n    int n = rotation;\r\n    while (n > 0) {\r\n        rotated = rotated.rotate();\r\n        n -= 90;\r\n    }\r\n    if (frm == null) {\r\n        frm = new PdfTemplate(writer);\r\n        frm.setBoundingBox(rotated);\r\n        writer.addDirectTemplateSimple(frm, new PdfName(\"FRM\"));\r\n        float scale = Math.min(rect.getWidth(), rect.getHeight()) * 0.9f;\r\n        float x = (rect.getWidth() - scale) / 2;\r\n        float y = (rect.getHeight() - scale) / 2;\r\n        scale /= 100;\r\n        if (rotation == 90)\r\n            frm.concatCTM(0, 1, -1, 0, rect.getHeight(), 0);\r\n        else if (rotation == 180)\r\n            frm.concatCTM(-1, 0, 0, -1, rect.getWidth(), rect.getHeight());\r\n        else if (rotation == 270)\r\n            frm.concatCTM(0, -1, 1, 0, 0, rect.getWidth());\r\n        if (reuseAppearance) {\r\n            AcroFields af = writer.getAcroFields();\r\n            PdfIndirectReference ref = af.getNormalAppearance(getFieldName());\r\n            if (ref != null) {\r\n                frm.addTemplateReference(ref, new PdfName(\"n0\"), 1, 0, 0, 1, 0, 0);\r\n            } else {\r\n                reuseAppearance = false;\r\n                if (app[0] == null) {\r\n                    createBlankN0();\r\n                }\r\n            }\r\n        }\r\n        if (!reuseAppearance) {\r\n            frm.addTemplate(app[0], 0, 0);\r\n        }\r\n        if (!acro6Layers)\r\n            frm.addTemplate(app[1], scale, 0, 0, scale, x, y);\r\n        frm.addTemplate(app[2], 0, 0);\r\n        if (!acro6Layers) {\r\n            frm.addTemplate(app[3], scale, 0, 0, scale, x, y);\r\n            frm.addTemplate(app[4], 0, 0);\r\n        }\r\n    }\r\n    PdfTemplate napp = new PdfTemplate(writer);\r\n    napp.setBoundingBox(rotated);\r\n    writer.addDirectTemplateSimple(napp, null);\r\n    napp.addTemplate(frm, 0, 0);\r\n    return napp;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.mc.StructureItems.writeParentTree",
	"Comment": "writes the altered parent tree to a pdfwriter and updates the structtreeroot entry.",
	"Method": "void writeParentTree(PdfWriter writer){\r\n    if (structTreeRoot == null)\r\n        return;\r\n    Integer[] numbers = new Integer[parentTree.size()];\r\n    numbers = parentTree.keySet().toArray(numbers);\r\n    Arrays.sort(numbers);\r\n    structTreeRoot.put(PdfName.PARENTTREENEXTKEY, new PdfNumber(numbers[numbers.length - 1] + 1));\r\n    structTreeRoot.put(PdfName.PARENTTREE, PdfNumberTree.writeTree(parentTree, writer));\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.xpath.XMPPathParser.parseRootNode",
	"Comment": "parses the root node of an xmp path, checks if namespace and prefix fit together\tand resolve the property to the base property if it is an alias.",
	"Method": "void parseRootNode(String schemaNS,PathPosition pos,XMPPath expandedXPath){\r\n    while (pos.stepEnd < pos.path.length() && \"/[*\".indexOf(pos.path.charAt(pos.stepEnd)) < 0) {\r\n        pos.stepEnd++;\r\n    }\r\n    if (pos.stepEnd == pos.stepBegin) {\r\n        throw new XMPException(\"Empty initial XMPPath step\", XMPError.BADXPATH);\r\n    }\r\n    String rootProp = verifyXPathRoot(schemaNS, pos.path.substring(pos.stepBegin, pos.stepEnd));\r\n    XMPAliasInfo aliasInfo = XMPMetaFactory.getSchemaRegistry().findAlias(rootProp);\r\n    if (aliasInfo == null) {\r\n        expandedXPath.add(new XMPPathSegment(schemaNS, XMPPath.SCHEMA_NODE));\r\n        XMPPathSegment rootStep = new XMPPathSegment(rootProp, XMPPath.STRUCT_FIELD_STEP);\r\n        expandedXPath.add(rootStep);\r\n    } else {\r\n        expandedXPath.add(new XMPPathSegment(aliasInfo.getNamespace(), XMPPath.SCHEMA_NODE));\r\n        XMPPathSegment rootStep = new XMPPathSegment(verifyXPathRoot(aliasInfo.getNamespace(), aliasInfo.getPropName()), XMPPath.STRUCT_FIELD_STEP);\r\n        rootStep.setAlias(true);\r\n        rootStep.setAliasForm(aliasInfo.getAliasForm().getOptions());\r\n        expandedXPath.add(rootStep);\r\n        if (aliasInfo.getAliasForm().isArrayAltText()) {\r\n            XMPPathSegment qualSelectorStep = new XMPPathSegment(\"[?xml:lang='x-default']\", XMPPath.QUAL_SELECTOR_STEP);\r\n            qualSelectorStep.setAlias(true);\r\n            qualSelectorStep.setAliasForm(aliasInfo.getAliasForm().getOptions());\r\n            expandedXPath.add(qualSelectorStep);\r\n        } else if (aliasInfo.getAliasForm().isArray()) {\r\n            XMPPathSegment indexStep = new XMPPathSegment(\"[1]\", XMPPath.ARRAY_INDEX_STEP);\r\n            indexStep.setAlias(true);\r\n            indexStep.setAliasForm(aliasInfo.getAliasForm().getOptions());\r\n            expandedXPath.add(indexStep);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.destroyBody",
	"Comment": "destroy a rigid body given a definition. no reference to the definition is retained. thisfunction is locked during callbacks.",
	"Method": "void destroyBody(Body body){\r\n    assert (m_bodyCount > 0);\r\n    assert (isLocked() == false);\r\n    if (isLocked()) {\r\n        return;\r\n    }\r\n    JointEdge je = body.m_jointList;\r\n    while (je != null) {\r\n        JointEdge je0 = je;\r\n        je = je.next;\r\n        if (m_destructionListener != null) {\r\n            m_destructionListener.sayGoodbye(je0.joint);\r\n        }\r\n        destroyJoint(je0.joint);\r\n        body.m_jointList = je;\r\n    }\r\n    body.m_jointList = null;\r\n    ContactEdge ce = body.m_contactList;\r\n    while (ce != null) {\r\n        ContactEdge ce0 = ce;\r\n        ce = ce.next;\r\n        m_contactManager.destroy(ce0.contact);\r\n    }\r\n    body.m_contactList = null;\r\n    Fixture f = body.m_fixtureList;\r\n    while (f != null) {\r\n        Fixture f0 = f;\r\n        f = f.m_next;\r\n        if (m_destructionListener != null) {\r\n            m_destructionListener.sayGoodbye(f0);\r\n        }\r\n        f0.destroyProxies(m_contactManager.m_broadPhase);\r\n        f0.destroy();\r\n        body.m_fixtureList = f;\r\n        body.m_fixtureCount -= 1;\r\n    }\r\n    body.m_fixtureList = null;\r\n    body.m_fixtureCount = 0;\r\n    if (body.m_prev != null) {\r\n        body.m_prev.m_next = body.m_next;\r\n    }\r\n    if (body.m_next != null) {\r\n        body.m_next.m_prev = body.m_prev;\r\n    }\r\n    if (body == m_bodyList) {\r\n        m_bodyList = body.m_next;\r\n    }\r\n    --m_bodyCount;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPNodeUtils.lookupLanguageItem",
	"Comment": "looks for the appropriate language item in a text alternative array.item",
	"Method": "int lookupLanguageItem(XMPNode arrayNode,String language){\r\n    if (!arrayNode.getOptions().isArray()) {\r\n        throw new XMPException(\"Language item must be used on array\", XMPError.BADXPATH);\r\n    }\r\n    for (int index = 1; index <= arrayNode.getChildrenLength(); index++) {\r\n        XMPNode child = arrayNode.getChild(index);\r\n        if (!child.hasQualifier() || !XML_LANG.equals(child.getQualifier(1).getName())) {\r\n            continue;\r\n        } else if (language.equals(child.getQualifier(1).getValue())) {\r\n            return index;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.setInitialLeading",
	"Comment": "sets the initial leading for the pdf document.this has to be done before the document is opened.",
	"Method": "void setInitialLeading(float leading){\r\n    if (open)\r\n        throw new DocumentException(MessageLocalization.getComposedMessage(\"you.can.t.set.the.initial.leading.if.the.document.is.already.open\"));\r\n    pdf.setLeading(leading);\r\n}"
}, {
	"Path": "com.itextpdf.text.Utilities.getKeySet",
	"Comment": "gets the keys of a hashtable.\tmarked as deprecated, not used anywhere anymore.",
	"Method": "Set<K> getKeySet(Hashtable<K, V> table){\r\n    return table == null ? Collections.<K>emptySet() : table.keySet();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CJKFont.GetCompatibleFont",
	"Comment": "returns a font compatible with a cjk encoding or null if not found.",
	"Method": "String GetCompatibleFont(String enc){\r\n    loadProperties();\r\n    String registry = null;\r\n    for (Entry<String, Set<String>> e : registryNames.entrySet()) {\r\n        if (e.getValue().contains(enc)) {\r\n            registry = e.getKey();\r\n            for (Entry<String, HashMap<String, Object>> e1 : allFonts.entrySet()) {\r\n                if (registry.equals(e1.getValue().get(\"Registry\")))\r\n                    return e1.getKey();\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfArray.getAsName",
	"Comment": "returns a pdfobject as a pdfname,resolving indirect references.the object corresponding to the specified index is retrieved andresolved to a direct object.if it is a pdfname, it is cast down and returned as such.otherwise null is returned.",
	"Method": "PdfName getAsName(int idx){\r\n    PdfName name = null;\r\n    PdfObject orig = getDirectObject(idx);\r\n    if (orig != null && orig.isName())\r\n        name = (PdfName) orig;\r\n    return name;\r\n}"
}, {
	"Path": "com.itextpdf.text.html.simpleparser.ElementFactory.updateElement",
	"Comment": "method that does the actual element creating for\tthe createparagraph and createlistitem method.",
	"Method": "void updateElement(Paragraph paragraph,ChainedProperties chain){\r\n    String value = chain.getProperty(HtmlTags.ALIGN);\r\n    paragraph.setAlignment(HtmlUtilities.alignmentValue(value));\r\n    paragraph.setHyphenation(getHyphenation(chain));\r\n    setParagraphLeading(paragraph, chain.getProperty(HtmlTags.LEADING));\r\n    value = chain.getProperty(HtmlTags.AFTER);\r\n    if (value != null) {\r\n        try {\r\n            paragraph.setSpacingBefore(Float.parseFloat(value));\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    value = chain.getProperty(HtmlTags.AFTER);\r\n    if (value != null) {\r\n        try {\r\n            paragraph.setSpacingAfter(Float.parseFloat(value));\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    value = chain.getProperty(HtmlTags.EXTRAPARASPACE);\r\n    if (value != null) {\r\n        try {\r\n            paragraph.setExtraParagraphSpace(Float.parseFloat(value));\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    value = chain.getProperty(HtmlTags.INDENT);\r\n    if (value != null) {\r\n        try {\r\n            paragraph.setIndentationLeft(Float.parseFloat(value));\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPNode.assertQualifierNotExisting",
	"Comment": "checks that a qualifier name is not existing on the same level.",
	"Method": "void assertQualifierNotExisting(String qualifierName){\r\n    if (!XMPConst.ARRAY_ITEM_NAME.equals(qualifierName) && findQualifierByName(qualifierName) != null) {\r\n        throw new XMPException(\"Duplicate '\" + qualifierName + \"' qualifier\", XMPError.BADXMP);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.TextField.getExtensionFont",
	"Comment": "gets the extensionfont. this font will be searched before thesubstitution fonts. it may be null.",
	"Method": "BaseFont getExtensionFont(){\r\n    return this.extensionFont;\r\n}"
}, {
	"Path": "com.itextpdf.text.ExceptionConverter.convertException",
	"Comment": "convert an exception into an unchecked exception. return the exception if it isalready an unchecked exception or return an exceptionconverter wrapper otherwise",
	"Method": "RuntimeException convertException(Exception ex){\r\n    if (ex instanceof RuntimeException) {\r\n        return (RuntimeException) ex;\r\n    }\r\n    return new ExceptionConverter(ex);\r\n}"
}, {
	"Path": "com.itextpdf.text.Version.getVersion",
	"Comment": "returns the itext version as shown in the producer line.\titext is a product developed by itext group nv.\titext group requests that you retain the itext producer line\tin every pdf that is created or manipulated using itext.",
	"Method": "String getVersion(){\r\n    return iTextVersion;\r\n}"
}, {
	"Path": "com.example.CryptFile.encrypt",
	"Comment": "encrypts the given plaintext using the specified crypto key.",
	"Method": "byte[] encrypt(String projectId,String locationId,String keyRingId,String cryptoKeyId,byte[] plaintext){\r\n    String resourceName = String.format(\"projects/%s/locations/%s/keyRings/%s/cryptoKeys/%s\", projectId, locationId, keyRingId, cryptoKeyId);\r\n    CloudKMS kms = createAuthorizedClient();\r\n    EncryptRequest request = new EncryptRequest().encodePlaintext(plaintext);\r\n    EncryptResponse response = kms.projects().locations().keyRings().cryptoKeys().encrypt(resourceName, request).execute();\r\n    return response.decodeCiphertext();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfArray.getAsBoolean",
	"Comment": "returns a pdfobject as a pdfboolean,resolving indirect references.the object corresponding to the specified index is retrieved andresolved to a direct object.if it is a pdfboolean, it is cast down and returned assuch. otherwise null is returned.",
	"Method": "PdfBoolean getAsBoolean(int idx){\r\n    PdfBoolean bool = null;\r\n    PdfObject orig = getDirectObject(idx);\r\n    if (orig != null && orig.isBoolean())\r\n        bool = (PdfBoolean) orig;\r\n    return bool;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.setThumbnail",
	"Comment": "use this method to set the thumbnail image for the current page.",
	"Method": "void setThumbnail(Image image){\r\n    pdf.setThumbnail(image);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.CreateNewStringIndex",
	"Comment": "function takes the original string item and adds the new strings\tto accommodate the cid rules",
	"Method": "void CreateNewStringIndex(int Font){\r\n    String fdFontName = fonts[Font].name + \"-OneRange\";\r\n    if (fdFontName.length() > 127)\r\n        fdFontName = fdFontName.substring(0, 127);\r\n    String extraStrings = \"Adobe\" + \"Identity\" + fdFontName;\r\n    int origStringsLen = stringOffsets[stringOffsets.length - 1] - stringOffsets[0];\r\n    int stringsBaseOffset = stringOffsets[0] - 1;\r\n    byte stringsIndexOffSize;\r\n    if (origStringsLen + extraStrings.length() <= 0xff)\r\n        stringsIndexOffSize = 1;\r\n    else if (origStringsLen + extraStrings.length() <= 0xffff)\r\n        stringsIndexOffSize = 2;\r\n    else if (origStringsLen + extraStrings.length() <= 0xffffff)\r\n        stringsIndexOffSize = 3;\r\n    else\r\n        stringsIndexOffSize = 4;\r\n    OutputList.addLast(new UInt16Item((char) (stringOffsets.length - 1 + 3)));\r\n    OutputList.addLast(new UInt8Item((char) stringsIndexOffSize));\r\n    for (int stringOffset : stringOffsets) OutputList.addLast(new IndexOffsetItem(stringsIndexOffSize, stringOffset - stringsBaseOffset));\r\n    int currentStringsOffset = stringOffsets[stringOffsets.length - 1] - stringsBaseOffset;\r\n    currentStringsOffset += \"Adobe\".length();\r\n    OutputList.addLast(new IndexOffsetItem(stringsIndexOffSize, currentStringsOffset));\r\n    currentStringsOffset += \"Identity\".length();\r\n    OutputList.addLast(new IndexOffsetItem(stringsIndexOffSize, currentStringsOffset));\r\n    currentStringsOffset += fdFontName.length();\r\n    OutputList.addLast(new IndexOffsetItem(stringsIndexOffSize, currentStringsOffset));\r\n    OutputList.addLast(new RangeItem(buf, stringOffsets[0], origStringsLen));\r\n    OutputList.addLast(new StringItem(extraStrings));\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.getPosition",
	"Comment": "the world position of the body. avoid creating bodies at the origin since this can lead to manyoverlapping shapes.",
	"Method": "Vec2 getPosition(){\r\n    return position;\r\n}"
}, {
	"Path": "software.amazon.ion.util.EquivalenceTest.testFieldEquals2",
	"Comment": "making the required changes to equivalence.field.hashcode.",
	"Method": "void testFieldEquals2(){\r\n    String intOne = \"1\";\r\n    IonValue v1 = oneValue(intOne);\r\n    IonValue v2 = oneValue(intOne);\r\n    IonValue v3 = oneValue(intOne);\r\n    IonStruct struct = system().newEmptyStruct();\r\n    String fieldName = \"a\";\r\n    struct.add(fieldName, v1);\r\n    struct.add(fieldName, v2);\r\n    struct.add(fieldName, v3);\r\n    assertEquals(3, struct.size());\r\n    Equivalence.Field f1 = new Equivalence.Field(v1, true);\r\n    Equivalence.Field f2 = new Equivalence.Field(v2, true);\r\n    Equivalence.Field f3 = new Equivalence.Field(v3, true);\r\n    assertEquals(f1, f2);\r\n    assertEquals(f2, f1);\r\n    assertEquals(f1, f3);\r\n    assertEquals(f3, f1);\r\n    assertEquals(f2, f3);\r\n    assertEquals(f3, f2);\r\n}"
}, {
	"Path": "software.amazon.ion.util.EquivalenceTest.testFieldEquals1",
	"Comment": "making the required changes to equivalence.field.hashcode.",
	"Method": "void testFieldEquals1(){\r\n    IonValue v1 = oneValue(\"1\");\r\n    IonValue v2 = oneValue(\"2\");\r\n    IonValue v3 = oneValue(\"3\");\r\n    IonStruct struct = system().newEmptyStruct();\r\n    String fieldName = \"a\";\r\n    struct.add(fieldName, v1);\r\n    struct.add(fieldName, v2);\r\n    struct.add(fieldName, v3);\r\n    assertEquals(3, struct.size());\r\n    Equivalence.Field f1 = new Equivalence.Field(v1, true);\r\n    Equivalence.Field f2 = new Equivalence.Field(v2, true);\r\n    Equivalence.Field f3 = new Equivalence.Field(v3, true);\r\n    assertFalse(f1.equals(f2));\r\n    assertFalse(f1.equals(f3));\r\n    assertFalse(f2.equals(f3));\r\n    assertTrue(f1.hashCode() != f2.hashCode());\r\n    assertTrue(f1.hashCode() != f3.hashCode());\r\n}"
}, {
	"Path": "com.itextpdf.text.Rectangle.getVariableBorderWidth",
	"Comment": "helper function returning the border width of a specific side.",
	"Method": "float getVariableBorderWidth(float variableWidthValue,int side){\r\n    if ((border & side) != 0)\r\n        return variableWidthValue != UNDEFINED ? variableWidthValue : borderWidth;\r\n    return 0;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.options.PropertyOptions.mergeWith",
	"Comment": "merges the set options of a another options object with this.\tif the other options set is null, this objects stays the same.",
	"Method": "void mergeWith(PropertyOptions options){\r\n    if (options != null) {\r\n        setOptions(getOptions() | options.getOptions());\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.codec.TIFFDirectory.getFields",
	"Comment": "returns an array of tifffields containing all the fieldsin this directory.",
	"Method": "TIFFField[] getFields(){\r\n    return fields;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.spatial.MeasureGeospatial.setBounds",
	"Comment": "an array of numbers that shall be taken pairwise to define a series of\tpoints that describes the bounds of an area for which geospatial\ttransformations are valid.",
	"Method": "void setBounds(NumberArray bounds){\r\n    super.put(PdfName.BOUNDS, bounds);\r\n}"
}, {
	"Path": "com.itextpdf.text.html.simpleparser.HTMLWorker.pushTableState",
	"Comment": "pushes the values of pendingtr and pendingtd\tto a state stack.",
	"Method": "void pushTableState(){\r\n    tableState.push(new boolean[] { pendingTR, pendingTD });\r\n}"
}, {
	"Path": "com.structurizr.analysis.ComponentFinder.setUrlClassLoader",
	"Comment": "sets a classloader to load classes from instead of the system classloader.",
	"Method": "void setUrlClassLoader(URLClassLoader urlClassLoader){\r\n    this.urlClassLoader = urlClassLoader;\r\n}"
}, {
	"Path": "org.jbox2d.collision.Collision.findMaxSeparation",
	"Comment": "find the max separation between poly1 and poly2 using edge normals from poly1.",
	"Method": "void findMaxSeparation(EdgeResults results,PolygonShape poly1,Transform xf1,PolygonShape poly2,Transform xf2){\r\n    int count1 = poly1.m_count;\r\n    int count2 = poly2.m_count;\r\n    Vec2[] n1s = poly1.m_normals;\r\n    Vec2[] v1s = poly1.m_vertices;\r\n    Vec2[] v2s = poly2.m_vertices;\r\n    Transform.mulTransToOutUnsafe(xf2, xf1, xf);\r\n    final Rot xfq = xf.q;\r\n    int bestIndex = 0;\r\n    float maxSeparation = -Float.MAX_VALUE;\r\n    for (int i = 0; i < count1; i++) {\r\n        Rot.mulToOutUnsafe(xfq, n1s[i], n);\r\n        Transform.mulToOutUnsafe(xf, v1s[i], v1);\r\n        float si = Float.MAX_VALUE;\r\n        for (int j = 0; j < count2; ++j) {\r\n            Vec2 v2sj = v2s[j];\r\n            float sij = n.x * (v2sj.x - v1.x) + n.y * (v2sj.y - v1.y);\r\n            if (sij < si) {\r\n                si = sij;\r\n            }\r\n        }\r\n        if (si > maxSeparation) {\r\n            maxSeparation = si;\r\n            bestIndex = i;\r\n        }\r\n    }\r\n    results.edgeIndex = bestIndex;\r\n    results.separation = maxSeparation;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Fixture.testPoint",
	"Comment": "test a point for containment in this fixture. this only works for convex shapes.",
	"Method": "boolean testPoint(Vec2 p){\r\n    return m_shape.testPoint(m_body.m_xf, p);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.events.PdfPageEventForwarder.onChapterEnd",
	"Comment": "called when the end of a chapter is reached.\tposition will hold the height of the end of the chapter.",
	"Method": "void onChapterEnd(PdfWriter writer,Document document,float position){\r\n    for (PdfPageEvent event : events) {\r\n        event.onChapterEnd(writer, document, position);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.PdfPKCS7.signCertificateChain",
	"Comment": "helper method that creates the collection of certificatesused for the main signature based on the complete listof certificates and the sign certificate.",
	"Method": "void signCertificateChain(){\r\n    ArrayList<Certificate> cc = new ArrayList<Certificate>();\r\n    cc.add(signCert);\r\n    ArrayList<Certificate> oc = new ArrayList<Certificate>(certs);\r\n    for (int k = 0; k < oc.size(); ++k) {\r\n        if (signCert.equals(oc.get(k))) {\r\n            oc.remove(k);\r\n            --k;\r\n            continue;\r\n        }\r\n    }\r\n    boolean found = true;\r\n    while (found) {\r\n        X509Certificate v = (X509Certificate) cc.get(cc.size() - 1);\r\n        found = false;\r\n        for (int k = 0; k < oc.size(); ++k) {\r\n            X509Certificate issuer = (X509Certificate) oc.get(k);\r\n            try {\r\n                if (provider == null)\r\n                    v.verify(issuer.getPublicKey());\r\n                else\r\n                    v.verify(issuer.getPublicKey(), provider);\r\n                found = true;\r\n                cc.add(oc.get(k));\r\n                oc.remove(k);\r\n                break;\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    }\r\n    signCerts = cc;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfSignatureAppearance.addDocMDP",
	"Comment": "adds keys to the signature dictionary that definethe certification level and the permissions.this method is only used for certifying signatures.",
	"Method": "void addDocMDP(PdfDictionary crypto){\r\n    PdfDictionary reference = new PdfDictionary();\r\n    PdfDictionary transformParams = new PdfDictionary();\r\n    transformParams.put(PdfName.P, new PdfNumber(certificationLevel));\r\n    transformParams.put(PdfName.V, new PdfName(\"1.2\"));\r\n    transformParams.put(PdfName.TYPE, PdfName.TRANSFORMPARAMS);\r\n    reference.put(PdfName.TRANSFORMMETHOD, PdfName.DOCMDP);\r\n    reference.put(PdfName.TYPE, PdfName.SIGREF);\r\n    reference.put(PdfName.TRANSFORMPARAMS, transformParams);\r\n    if (writer.getPdfVersion().getVersion() < PdfWriter.VERSION_1_6) {\r\n        reference.put(new PdfName(\"DigestValue\"), new PdfString(\"aa\"));\r\n        PdfArray loc = new PdfArray();\r\n        loc.add(new PdfNumber(0));\r\n        loc.add(new PdfNumber(0));\r\n        reference.put(new PdfName(\"DigestLocation\"), loc);\r\n        reference.put(new PdfName(\"DigestMethod\"), new PdfName(\"MD5\"));\r\n    }\r\n    reference.put(PdfName.DATA, writer.reader.getTrailer().get(PdfName.ROOT));\r\n    PdfArray types = new PdfArray();\r\n    types.add(reference);\r\n    crypto.put(PdfName.REFERENCE, types);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.getPdfObjectRelease",
	"Comment": "reads a pdfobject resolving an indirect referenceif needed. if the reader was opened in partial mode the object will be releasedto save memory.",
	"Method": "PdfObject getPdfObjectRelease(PdfObject obj,PdfObject getPdfObjectRelease,PdfObject obj,PdfObject parent,PdfObject getPdfObjectRelease,int idx){\r\n    PdfObject obj = getPdfObject(idx);\r\n    releaseLastXrefPartial();\r\n    return obj;\r\n}"
}, {
	"Path": "software.amazon.ion.HashCodeDistributionTest.checkChiSquareValue",
	"Comment": "analyze counts against chi^2 distribution at 95% confidence interval.",
	"Method": "void checkChiSquareValue(int[] counts,int totalCount){\r\n    int expectedTotalCount = 0;\r\n    for (int count : counts) {\r\n        expectedTotalCount += count;\r\n    }\r\n    assertEquals(\"Total counts is incorrect\", totalCount, expectedTotalCount);\r\n    if (expectedTotalCount == 0) {\r\n        return;\r\n    }\r\n    double expectedValue = (double) totalCount / (double) counts.length;\r\n    double chiSquared = 0.0;\r\n    for (int count : counts) {\r\n        chiSquared += Math.pow((count - expectedValue), 2) / expectedValue;\r\n    }\r\n    int degreesOfFreedom = counts.length - 1;\r\n    double threshold;\r\n    if (degreesOfFreedom < upperTailChiSquared95Table.length) {\r\n        threshold = upperTailChiSquared95Table[degreesOfFreedom];\r\n    } else {\r\n        double x_p = 1.64;\r\n        threshold = degreesOfFreedom + Math.sqrt(2 * degreesOfFreedom) * x_p + (2.0 / 3.0) * Math.pow(x_p, 2) - (2.0 / 3.0);\r\n    }\r\n    if (chiSquared >= threshold) {\r\n        fail(String.format(\"Chi-square value above 95 percent \" + \"threshold: %1$f, limit: %2$f, nu: %3$d\", chiSquared, threshold, degreesOfFreedom));\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.CertificateUtil.getCRLURL",
	"Comment": "gets the url of the certificate revocation list for a certificate",
	"Method": "String getCRLURL(X509Certificate certificate){\r\n    ASN1Primitive obj;\r\n    try {\r\n        obj = getExtensionValue(certificate, Extension.cRLDistributionPoints.getId());\r\n    } catch (IOException e) {\r\n        obj = null;\r\n    }\r\n    if (obj == null) {\r\n        return null;\r\n    }\r\n    CRLDistPoint dist = CRLDistPoint.getInstance(obj);\r\n    DistributionPoint[] dists = dist.getDistributionPoints();\r\n    for (DistributionPoint p : dists) {\r\n        DistributionPointName distributionPointName = p.getDistributionPoint();\r\n        if (DistributionPointName.FULL_NAME != distributionPointName.getType()) {\r\n            continue;\r\n        }\r\n        GeneralNames generalNames = (GeneralNames) distributionPointName.getName();\r\n        GeneralName[] names = generalNames.getNames();\r\n        for (GeneralName name : names) {\r\n            if (name.getTagNo() != GeneralName.uniformResourceIdentifier) {\r\n                continue;\r\n            }\r\n            DERIA5String derStr = DERIA5String.getInstance((ASN1TaggedObject) name.toASN1Primitive(), false);\r\n            return derStr.getString();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfArray.getAsString",
	"Comment": "returns a pdfobject as a pdfstring,resolving indirect references.the object corresponding to the specified index is retrieved andresolved to a direct object.if it is a pdfstring, it is cast down and returned as such.otherwise null is returned.",
	"Method": "PdfString getAsString(int idx){\r\n    PdfString string = null;\r\n    PdfObject orig = getDirectObject(idx);\r\n    if (orig != null && orig.isString())\r\n        string = (PdfString) orig;\r\n    return string;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.mc.StructureItem.checkStructParent",
	"Comment": "checks if a structparent corresponds with the structparent stored in the structureitem.",
	"Method": "int checkStructParent(int pageref,int structParent){\r\n    return 0;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.getWorldVector",
	"Comment": "get the world coordinates of a vector given the local coordinates.",
	"Method": "Vec2 getWorldVector(Vec2 localVector){\r\n    Vec2 out = new Vec2();\r\n    getWorldVectorToOut(localVector, out);\r\n    return out;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.IonReaderTextRawX.tokenValueIsFinished",
	"Comment": "called by super classes to tell us that thecurrent token has been consumed.",
	"Method": "void tokenValueIsFinished(){\r\n    _scanner.tokenIsFinished();\r\n    if (IonType.BLOB.equals(_value_type) || IonType.CLOB.equals(_value_type)) {\r\n        int state_after_scalar = get_state_after_value();\r\n        set_state(state_after_scalar);\r\n    }\r\n}"
}, {
	"Path": "com.example.cloud.iot.examples.MqttExampleOptions.fromFlags",
	"Comment": "construct an mqttexampleoptions class from command line flags.",
	"Method": "MqttExampleOptions fromFlags(String[] args){\r\n    Options options = new Options();\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"project_id\").hasArg().desc(\"GCP cloud project name.\").required().build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"registry_id\").hasArg().desc(\"Cloud IoT Core registry id.\").required().build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"device_id\").hasArg().desc(\"Cloud IoT Core device id.\").required().build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"private_key_file\").hasArg().desc(\"Path to private key file.\").required().build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"algorithm\").hasArg().desc(\"Encryption algorithm to use to generate the JWT. Either 'RS256' or 'ES256'.\").required().build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"cloud_region\").hasArg().desc(\"GCP cloud region.\").build());\r\n    options.addOption(Option.builder().type(Number.class).longOpt(\"num_messages\").hasArg().desc(\"Number of messages to publish.\").build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"mqtt_bridge_hostname\").hasArg().desc(\"MQTT bridge hostname.\").build());\r\n    options.addOption(Option.builder().type(Number.class).longOpt(\"token_exp_minutes\").hasArg().desc(\"Minutes to JWT token refresh (token expiration time).\").build());\r\n    options.addOption(Option.builder().type(Number.class).longOpt(\"mqtt_bridge_port\").hasArg().desc(\"MQTT bridge port.\").build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"message_type\").hasArg().desc(\"Indicates whether the message is a telemetry event or a device state message\").build());\r\n    options.addOption(Option.builder().type(Number.class).longOpt(\"wait_time\").hasArg().desc(\"Wait time (in seconds) for commands.\").build());\r\n    CommandLineParser parser = new DefaultParser();\r\n    CommandLine commandLine;\r\n    try {\r\n        commandLine = parser.parse(options, args);\r\n        MqttExampleOptions res = new MqttExampleOptions();\r\n        res.projectId = commandLine.getOptionValue(\"project_id\");\r\n        res.registryId = commandLine.getOptionValue(\"registry_id\");\r\n        res.deviceId = commandLine.getOptionValue(\"device_id\");\r\n        res.privateKeyFile = commandLine.getOptionValue(\"private_key_file\");\r\n        res.algorithm = commandLine.getOptionValue(\"algorithm\");\r\n        if (commandLine.hasOption(\"wait_time\")) {\r\n            res.waitTime = ((Number) commandLine.getParsedOptionValue(\"wait_time\")).intValue();\r\n        }\r\n        if (commandLine.hasOption(\"cloud_region\")) {\r\n            res.cloudRegion = commandLine.getOptionValue(\"cloud_region\");\r\n        }\r\n        if (commandLine.hasOption(\"num_messages\")) {\r\n            res.numMessages = ((Number) commandLine.getParsedOptionValue(\"num_messages\")).intValue();\r\n        }\r\n        if (commandLine.hasOption(\"token_exp_minutes\")) {\r\n            res.tokenExpMins = ((Number) commandLine.getParsedOptionValue(\"token_exp_minutes\")).intValue();\r\n        }\r\n        if (commandLine.hasOption(\"mqtt_bridge_hostname\")) {\r\n            res.mqttBridgeHostname = commandLine.getOptionValue(\"mqtt_bridge_hostname\");\r\n        }\r\n        if (commandLine.hasOption(\"mqtt_bridge_port\")) {\r\n            res.mqttBridgePort = ((Number) commandLine.getParsedOptionValue(\"mqtt_bridge_port\")).shortValue();\r\n        }\r\n        if (commandLine.hasOption(\"message_type\")) {\r\n            res.messageType = commandLine.getOptionValue(\"message_type\");\r\n        }\r\n        return res;\r\n    } catch (ParseException e) {\r\n        System.err.println(e.getMessage());\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.jbake.launcher.Init.run",
	"Comment": "performs checks on output folder before extracting template file",
	"Method": "void run(File outputFolder,File templateLocationFolder,String templateType){\r\n    if (!outputFolder.canWrite()) {\r\n        throw new Exception(\"Output folder is not writeable!\");\r\n    }\r\n    File[] contents = outputFolder.listFiles();\r\n    boolean safe = true;\r\n    if (contents != null) {\r\n        for (File content : contents) {\r\n            if (content.isDirectory()) {\r\n                if (content.getName().equalsIgnoreCase(config.getTemplateFolderName())) {\r\n                    safe = false;\r\n                }\r\n                if (content.getName().equalsIgnoreCase(config.getContentFolderName())) {\r\n                    safe = false;\r\n                }\r\n                if (content.getName().equalsIgnoreCase(config.getAssetFolderName())) {\r\n                    safe = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (!safe) {\r\n        throw new Exception(String.format(\"Output folder '%s' already contains structure!\", outputFolder.getAbsolutePath()));\r\n    }\r\n    if (config.getExampleProjectByType(templateType) != null) {\r\n        File templateFile = new File(templateLocationFolder, config.getExampleProjectByType(templateType));\r\n        if (!templateFile.exists()) {\r\n            throw new Exception(\"Cannot find example project file: \" + templateFile.getPath());\r\n        }\r\n        ZipUtil.extract(new FileInputStream(templateFile), outputFolder);\r\n    } else {\r\n        throw new Exception(\"Cannot locate example project type: \" + templateType);\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.callbacks.DebugDraw.getScreenToWorld",
	"Comment": "takes the screen coordinates and returns the world coordinates.",
	"Method": "Vec2 getScreenToWorld(Vec2 argScreen,Vec2 getScreenToWorld,float screenX,float screenY){\r\n    Vec2 screen = new Vec2(screenX, screenY);\r\n    viewportTransform.getScreenToWorld(screen, screen);\r\n    return screen;\r\n}"
}, {
	"Path": "com.itextpdf.text.Chunk.setTextRenderMode",
	"Comment": "sets the text rendering mode. it can outline text, simulate bold and make\ttext invisible.",
	"Method": "Chunk setTextRenderMode(int mode,float strokeWidth,BaseColor strokeColor){\r\n    return setAttribute(TEXTRENDERMODE, new Object[] { Integer.valueOf(mode), new Float(strokeWidth), strokeColor });\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.TSAClientBouncyCastle.getTimeStampToken",
	"Comment": "get rfc 3161 timestamptoken.method may return null indicating that timestamp should be skipped.",
	"Method": "byte[] getTimeStampToken(byte[] imprint){\r\n    byte[] respBytes = null;\r\n    TimeStampRequestGenerator tsqGenerator = new TimeStampRequestGenerator();\r\n    tsqGenerator.setCertReq(true);\r\n    if (tsaReqPolicy != null && tsaReqPolicy.length() > 0) {\r\n        tsqGenerator.setReqPolicy(new ASN1ObjectIdentifier(tsaReqPolicy));\r\n    }\r\n    BigInteger nonce = BigInteger.valueOf(System.currentTimeMillis());\r\n    TimeStampRequest request = tsqGenerator.generate(new ASN1ObjectIdentifier(DigestAlgorithms.getAllowedDigests(digestAlgorithm)), imprint, nonce);\r\n    byte[] requestBytes = request.getEncoded();\r\n    respBytes = getTSAResponse(requestBytes);\r\n    TimeStampResponse response = new TimeStampResponse(respBytes);\r\n    response.validate(request);\r\n    PKIFailureInfo failure = response.getFailInfo();\r\n    int value = (failure == null) ? 0 : failure.intValue();\r\n    if (value != 0) {\r\n        throw new IOException(MessageLocalization.getComposedMessage(\"invalid.tsa.1.response.code.2\", tsaURL, String.valueOf(value)));\r\n    }\r\n    TimeStampToken tsToken = response.getTimeStampToken();\r\n    if (tsToken == null) {\r\n        throw new IOException(MessageLocalization.getComposedMessage(\"tsa.1.failed.to.return.time.stamp.token.2\", tsaURL, response.getStatusString()));\r\n    }\r\n    TimeStampTokenInfo tsTokenInfo = tsToken.getTimeStampInfo();\r\n    byte[] encoded = tsToken.getEncoded();\r\n    LOGGER.info(\"Timestamp generated: \" + tsTokenInfo.getGenTime());\r\n    if (tsaInfo != null) {\r\n        tsaInfo.inspectTimeStampTokenInfo(tsTokenInfo);\r\n    }\r\n    this.tokenSizeEstimate = encoded.length + 32;\r\n    return encoded;\r\n}"
}, {
	"Path": "com.example.dlp.Templates.main",
	"Comment": "command line application to create, list and delete dlp inspect templates.",
	"Method": "void main(String[] args){\r\n    OptionGroup optionsGroup = new OptionGroup();\r\n    optionsGroup.setRequired(true);\r\n    Option createOption = new Option(\"c\", \"create\", false, \"Create inspect template\");\r\n    optionsGroup.addOption(createOption);\r\n    Option listOption = new Option(\"l\", \"list\", false, \"List inspect templates\");\r\n    optionsGroup.addOption(listOption);\r\n    Option deleteOption = new Option(\"d\", \"delete\", false, \"Delete inspect template\");\r\n    optionsGroup.addOption(deleteOption);\r\n    Options commandLineOptions = new Options();\r\n    commandLineOptions.addOptionGroup(optionsGroup);\r\n    Option projectIdOption = Option.builder(\"projectId\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(projectIdOption);\r\n    Option minLikelihoodOption = Option.builder(\"minLikelihood\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(minLikelihoodOption);\r\n    Option infoTypesOption = Option.builder(\"infoTypes\").hasArg(true).required(false).build();\r\n    infoTypesOption.setArgs(Option.UNLIMITED_VALUES);\r\n    commandLineOptions.addOption(infoTypesOption);\r\n    Option templateIdOption = Option.builder(\"templateId\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(templateIdOption);\r\n    Option templateDescription = Option.builder(\"description\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(templateDescription);\r\n    Option templateDisplayNameOption = Option.builder(\"displayName\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(templateDisplayNameOption);\r\n    Option includeQuoteOption = Option.builder(\"includeQuote\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(includeQuoteOption);\r\n    Option maxFindingsOption = Option.builder(\"maxFindings\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(maxFindingsOption);\r\n    CommandLineParser parser = new DefaultParser();\r\n    HelpFormatter formatter = new HelpFormatter();\r\n    CommandLine cmd;\r\n    try {\r\n        cmd = parser.parse(commandLineOptions, args);\r\n    } catch (ParseException e) {\r\n        System.out.println(e.getMessage());\r\n        formatter.printHelp(Redact.class.getName(), commandLineOptions);\r\n        System.exit(1);\r\n        return;\r\n    }\r\n    String projectId = cmd.getOptionValue(projectIdOption.getOpt(), ServiceOptions.getDefaultProjectId());\r\n    if (cmd.hasOption(createOption.getOpt())) {\r\n        String templateId = cmd.getOptionValue(templateIdOption.getOpt());\r\n        String displayName = cmd.getOptionValue(templateDisplayNameOption.getOpt());\r\n        String description = cmd.getOptionValue(templateDescription.getOpt());\r\n        Likelihood minLikelihood = Likelihood.valueOf(cmd.getOptionValue(minLikelihoodOption.getOpt(), Likelihood.LIKELIHOOD_UNSPECIFIED.name()));\r\n        List<InfoType> infoTypesList = new ArrayList();\r\n        String[] infoTypes = cmd.getOptionValues(infoTypesOption.getOpt());\r\n        if (infoTypes != null) {\r\n            for (String infoType : infoTypes) {\r\n                infoTypesList.add(InfoType.newBuilder().setName(infoType).build());\r\n            }\r\n        }\r\n        int maxFindings = Integer.valueOf(cmd.getOptionValue(maxFindingsOption.getOpt(), \"0\"));\r\n        createInspectTemplate(displayName, templateId, description, projectId, infoTypesList, minLikelihood, maxFindings);\r\n    } else if (cmd.hasOption(listOption.getOpt())) {\r\n        listInspectTemplates(projectId);\r\n    } else if (cmd.hasOption(deleteOption.getOpt())) {\r\n        String templateId = cmd.getOptionValue(templateIdOption.getOpt());\r\n        deleteInspectTemplate(projectId, templateId);\r\n    }\r\n}"
}, {
	"Path": "com.example.firestore.snippets.QueryDataSnippets.createOrderByNameDescWithLimitQuery",
	"Comment": "creates a query that combines order by in descending order with the limit operator.",
	"Method": "Query createOrderByNameDescWithLimitQuery(){\r\n    CollectionReference cities = db.collection(\"cities\");\r\n    Query query = cities.orderBy(\"name\", Direction.DESCENDING).limit(3);\r\n    return query;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONObject.optJSONArray",
	"Comment": "get an optional jsonarray associated with a key. it returns null if thereis no such key, or if its value is not a jsonarray.",
	"Method": "JSONArray optJSONArray(String key){\r\n    Object o = this.opt(key);\r\n    return o instanceof JSONArray ? (JSONArray) o : null;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaConfiguration.addInstance",
	"Comment": "adds a richmediainstance to the instances array of this\tconfiguration.",
	"Method": "void addInstance(RichMediaInstance instance){\r\n    instances.add(instance);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BarcodePostnet.createAwtImage",
	"Comment": "creates a java.awt.image. this image onlycontains the bars without any text.",
	"Method": "java.awt.Image createAwtImage(java.awt.Color foreground,java.awt.Color background){\r\n    int f = foreground.getRGB();\r\n    int g = background.getRGB();\r\n    java.awt.Canvas canvas = new java.awt.Canvas();\r\n    int barWidth = (int) x;\r\n    if (barWidth <= 0)\r\n        barWidth = 1;\r\n    int barDistance = (int) n;\r\n    if (barDistance <= barWidth)\r\n        barDistance = barWidth + 1;\r\n    int barShort = (int) size;\r\n    if (barShort <= 0)\r\n        barShort = 1;\r\n    int barTall = (int) barHeight;\r\n    if (barTall <= barShort)\r\n        barTall = barShort + 1;\r\n    int width = ((code.length() + 1) * 5 + 1) * barDistance + barWidth;\r\n    int[] pix = new int[width * barTall];\r\n    byte[] bars = getBarsPostnet(code);\r\n    byte flip = 1;\r\n    if (codeType == PLANET) {\r\n        flip = 0;\r\n        bars[0] = 0;\r\n        bars[bars.length - 1] = 0;\r\n    }\r\n    int idx = 0;\r\n    for (int k = 0; k < bars.length; ++k) {\r\n        boolean dot = (bars[k] == flip);\r\n        for (int j = 0; j < barDistance; ++j) {\r\n            pix[idx + j] = ((dot && j < barWidth) ? f : g);\r\n        }\r\n        idx += barDistance;\r\n    }\r\n    int limit = width * (barTall - barShort);\r\n    for (int k = width; k < limit; k += width) System.arraycopy(pix, 0, pix, k, width);\r\n    idx = limit;\r\n    for (int k = 0; k < bars.length; ++k) {\r\n        for (int j = 0; j < barDistance; ++j) {\r\n            pix[idx + j] = ((j < barWidth) ? f : g);\r\n        }\r\n        idx += barDistance;\r\n    }\r\n    for (int k = limit + width; k < pix.length; k += width) System.arraycopy(pix, limit, pix, k, width);\r\n    java.awt.Image img = canvas.createImage(new java.awt.image.MemoryImageSource(width, barTall, pix, 0, width));\r\n    return img;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPTable.setHeaderRows",
	"Comment": "sets the number of the top rows that constitute the header. this headerhas only meaning if the table is added to document and thetable crosses pages.",
	"Method": "void setHeaderRows(int headerRows){\r\n    if (headerRows < 0) {\r\n        headerRows = 0;\r\n    }\r\n    this.headerRows = headerRows;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.getLinearDamping",
	"Comment": "linear damping is use to reduce the linear velocity. the damping parameter can be larger than1.0f but the damping effect becomes sensitive to the time step when the damping parameter islarge.",
	"Method": "float getLinearDamping(){\r\n    return linearDamping;\r\n}"
}, {
	"Path": "com.google.cloud.storage.storagetransfer.samples.NearlineRequester.main",
	"Comment": "output the contents of a successfully created transferjob.",
	"Method": "void main(String[] args){\r\n    try {\r\n        run(System.out);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.table.KeepRowsTogetherTest.compareDocuments",
	"Comment": "utility method that checks the created file against the cmp file",
	"Method": "void compareDocuments(String file){\r\n    CompareTool compareTool = new CompareTool();\r\n    String errorMessage = compareTool.compareByContent(outFolder + file, cmpFolder + file, outFolder, \"diff\");\r\n    if (errorMessage != null) {\r\n        Assert.fail(errorMessage);\r\n    }\r\n}"
}, {
	"Path": "com.google.cloud.translate.automl.ModelApi.getModelEvaluation",
	"Comment": "demonstrates using the automl client to get model evaluations.",
	"Method": "void getModelEvaluation(String projectId,String computeRegion,String modelId,String modelEvaluationId){\r\n    AutoMlClient client = AutoMlClient.create();\r\n    ModelEvaluationName modelEvaluationFullId = ModelEvaluationName.of(projectId, computeRegion, modelId, modelEvaluationId);\r\n    ModelEvaluation response = client.getModelEvaluation(modelEvaluationFullId);\r\n    System.out.println(response);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.codec.GifImage.skip",
	"Comment": "skips variable length blocks up to and includingnext zero length block.",
	"Method": "void skip(){\r\n    do {\r\n        readBlock();\r\n    } while (blockSize > 0);\r\n}"
}, {
	"Path": "software.amazon.ion.impl.LocalSymbolTable.unknownSymbolName",
	"Comment": "generate the string representation of a symbol with an unknown id.",
	"Method": "String unknownSymbolName(int id){\r\n    assert id > 0;\r\n    return \"$\" + id;\r\n}"
}, {
	"Path": "com.itextpdf.text.Version.getRelease",
	"Comment": "gets the release number.\titext group nv requests that you retain the itext producer line\tin every pdf that is created or manipulated using itext.",
	"Method": "String getRelease(){\r\n    return release;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.pdfcleanup.PdfCleanUpLocation.getCleanUpColor",
	"Comment": "returns a color used to fill the area after erasing it. if null the erased area left uncolored.",
	"Method": "BaseColor getCleanUpColor(){\r\n    return cleanUpColor;\r\n}"
}, {
	"Path": "com.example.iap.BuildAndVerifyIapRequestIT.testGenerateAndVerifyIapRequestIsSuccessful",
	"Comment": "access an iap protected url with a signed jwt authorization header, verify jwt token",
	"Method": "void testGenerateAndVerifyIapRequestIsSuccessful(){\r\n    HttpRequest request = httpTransport.createRequestFactory().buildGetRequest(new GenericUrl(IAP_PROTECTED_URL));\r\n    HttpRequest iapRequest = BuildIapRequest.buildIapRequest(request, IAP_CLIENT_ID);\r\n    HttpResponse response = iapRequest.execute();\r\n    assertEquals(response.getStatusCode(), HttpStatus.SC_OK);\r\n    String headerWithtoken = response.parseAsString();\r\n    String[] split = headerWithtoken.split(\":\");\r\n    assertNotNull(split);\r\n    assertEquals(2, split.length);\r\n    assertEquals(\"x-goog-authenticated-user-jwt\", split[0].trim());\r\n    String jwtToken = split[1].trim();\r\n    HttpRequest verifyJwtRequest = httpTransport.createRequestFactory().buildGetRequest(new GenericUrl(IAP_PROTECTED_URL)).setHeaders(new HttpHeaders().set(\"x-goog-iap-jwt-assertion\", jwtToken));\r\n    boolean verified = verifyIapRequestHeader.verifyJwtForAppEngine(verifyJwtRequest, IAP_PROJECT_NUMBER, IAP_PROJECT_ID);\r\n    assertTrue(verified);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.MotorJoint.getLinearOffset",
	"Comment": "get the target linear offset, in frame a, in meters. do not modify.",
	"Method": "void getLinearOffset(Vec2 out,Vec2 getLinearOffset){\r\n    return m_linearOffset;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.setAutoClearForces",
	"Comment": "set flag to control automatic clearing of forces after each time step.",
	"Method": "void setAutoClearForces(boolean flag){\r\n    if (flag) {\r\n        m_flags |= CLEAR_FORCES;\r\n    } else {\r\n        m_flags &= ~CLEAR_FORCES;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.html.simpleparser.ElementFactory.createParagraph",
	"Comment": "creates an itext paragraph object using the properties\tof the different tags and properties in the hierarchy chain.",
	"Method": "Paragraph createParagraph(ChainedProperties chain){\r\n    Paragraph paragraph = new Paragraph();\r\n    updateElement(paragraph, chain);\r\n    return paragraph;\r\n}"
}, {
	"Path": "software.amazon.ion.system.IonTextWriterBuilder.minimal",
	"Comment": "creates a builder configured to minimize system data, eliminating localsymbol tables and minimizing version markers.",
	"Method": "IonTextWriterBuilder minimal(){\r\n    return standard().withMinimalSystemData();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.getPdfObject",
	"Comment": "reads a pdfobject resolving an indirect referenceif needed.",
	"Method": "PdfObject getPdfObject(PdfObject obj,PdfObject getPdfObject,PdfObject obj,PdfObject parent,PdfObject getPdfObject,int idx){\r\n    try {\r\n        lastXrefPartial = -1;\r\n        if (idx < 0 || idx >= xrefObj.size())\r\n            return null;\r\n        PdfObject obj = xrefObj.get(idx);\r\n        if (!partial || obj != null)\r\n            return obj;\r\n        if (idx * 2 >= xref.length)\r\n            return null;\r\n        obj = readSingleObject(idx);\r\n        lastXrefPartial = -1;\r\n        if (obj != null)\r\n            lastXrefPartial = idx;\r\n        return obj;\r\n    } catch (Exception e) {\r\n        throw new ExceptionConverter(e);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.TrueTypeFont.getFontDescriptor",
	"Comment": "gets the font parameter identified by key. valid valuesfor key are ascent, capheight, descentand italicangle.",
	"Method": "PdfDictionary getFontDescriptor(PdfIndirectReference fontStream,String subsetPrefix,PdfIndirectReference cidset,float getFontDescriptor,int key,float fontSize){\r\n    switch(key) {\r\n        case ASCENT:\r\n            return os_2.sTypoAscender * fontSize / head.unitsPerEm;\r\n        case CAPHEIGHT:\r\n            return os_2.sCapHeight * fontSize / head.unitsPerEm;\r\n        case DESCENT:\r\n            return os_2.sTypoDescender * fontSize / head.unitsPerEm;\r\n        case ITALICANGLE:\r\n            return (float) italicAngle;\r\n        case BBOXLLX:\r\n            return fontSize * head.xMin / head.unitsPerEm;\r\n        case BBOXLLY:\r\n            return fontSize * head.yMin / head.unitsPerEm;\r\n        case BBOXURX:\r\n            return fontSize * head.xMax / head.unitsPerEm;\r\n        case BBOXURY:\r\n            return fontSize * head.yMax / head.unitsPerEm;\r\n        case AWT_ASCENT:\r\n            return fontSize * hhea.Ascender / head.unitsPerEm;\r\n        case AWT_DESCENT:\r\n            return fontSize * hhea.Descender / head.unitsPerEm;\r\n        case AWT_LEADING:\r\n            return fontSize * hhea.LineGap / head.unitsPerEm;\r\n        case AWT_MAXADVANCE:\r\n            return fontSize * hhea.advanceWidthMax / head.unitsPerEm;\r\n        case UNDERLINE_POSITION:\r\n            return (underlinePosition - underlineThickness / 2) * fontSize / head.unitsPerEm;\r\n        case UNDERLINE_THICKNESS:\r\n            return underlineThickness * fontSize / head.unitsPerEm;\r\n        case STRIKETHROUGH_POSITION:\r\n            return os_2.yStrikeoutPosition * fontSize / head.unitsPerEm;\r\n        case STRIKETHROUGH_THICKNESS:\r\n            return os_2.yStrikeoutSize * fontSize / head.unitsPerEm;\r\n        case SUBSCRIPT_SIZE:\r\n            return os_2.ySubscriptYSize * fontSize / head.unitsPerEm;\r\n        case SUBSCRIPT_OFFSET:\r\n            return -os_2.ySubscriptYOffset * fontSize / head.unitsPerEm;\r\n        case SUPERSCRIPT_SIZE:\r\n            return os_2.ySuperscriptYSize * fontSize / head.unitsPerEm;\r\n        case SUPERSCRIPT_OFFSET:\r\n            return os_2.ySuperscriptYOffset * fontSize / head.unitsPerEm;\r\n        case WEIGHT_CLASS:\r\n            return os_2.usWeightClass;\r\n        case WIDTH_CLASS:\r\n            return os_2.usWidthClass;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.itextpdf.text.Image.getInstance",
	"Comment": "gets an instance of a image from a java.awt.image.the image is added as a jpeg with a user defined quality.",
	"Method": "Image getInstance(URL url,Image getInstance,URL url,boolean recoverFromImageError,Image getInstance,String filename,Image getInstance,String filename,boolean recoverFromImageError,Image getInstance,byte imgb,Image getInstance,byte imgb,boolean recoverFromImageError,Image getInstance,int width,int height,int components,int bpc,byte data,Image getInstance,int width,int height,byte[] data,byte[] globals,Image getInstance,int width,int height,boolean reverseBits,int typeCCITT,int parameters,byte[] data,Image getInstance,int width,int height,boolean reverseBits,int typeCCITT,int parameters,byte[] data,int transparency,Image getInstance,int width,int height,int components,int bpc,byte data,int transparency,Image getInstance,PdfTemplate template,Image getInstance,PRIndirectReference ref,Image getInstance,Image image,Image getInstance,java.awt.Image image,java.awt.Color color,boolean forceBW,Image getInstance,java.awt.Image image,java.awt.Color color,Image getInstance,PdfWriter writer,java.awt.Image awtImage,float quality,Image getInstance,PdfContentByte cb,java.awt.Image awtImage,float quality){\r\n    java.awt.image.PixelGrabber pg = new java.awt.image.PixelGrabber(awtImage, 0, 0, -1, -1, true);\r\n    try {\r\n        pg.grabPixels();\r\n    } catch (InterruptedException e) {\r\n        throw new IOException(MessageLocalization.getComposedMessage(\"java.awt.image.interrupted.waiting.for.pixels\"));\r\n    }\r\n    if ((pg.getStatus() & java.awt.image.ImageObserver.ABORT) != 0) {\r\n        throw new IOException(MessageLocalization.getComposedMessage(\"java.awt.image.fetch.aborted.or.errored\"));\r\n    }\r\n    int w = pg.getWidth();\r\n    int h = pg.getHeight();\r\n    PdfTemplate tp = cb.createTemplate(w, h);\r\n    PdfGraphics2D g2d = new PdfGraphics2D(tp, w, h, null, false, true, quality);\r\n    g2d.drawImage(awtImage, 0, 0, null);\r\n    g2d.dispose();\r\n    return getInstance(tp);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.InlineImageUtils.getAlternateValue",
	"Comment": "transforms value abbreviations into their corresponding real value",
	"Method": "PdfObject getAlternateValue(PdfName key,PdfObject value){\r\n    if (key == PdfName.FILTER) {\r\n        if (value instanceof PdfName) {\r\n            PdfName altValue = inlineImageFilterAbbreviationMap.get(value);\r\n            if (altValue != null)\r\n                return altValue;\r\n        } else if (value instanceof PdfArray) {\r\n            PdfArray array = ((PdfArray) value);\r\n            PdfArray altArray = new PdfArray();\r\n            int count = array.size();\r\n            for (int i = 0; i < count; i++) {\r\n                altArray.add(getAlternateValue(key, array.getPdfObject(i)));\r\n            }\r\n            return altArray;\r\n        }\r\n    } else if (key == PdfName.COLORSPACE) {\r\n        PdfName altValue = inlineImageColorSpaceAbbreviationMap.get(value);\r\n        if (altValue != null)\r\n            return altValue;\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.getCodePagesSupported",
	"Comment": "gets the code pages supported by the font. this has only meaningwith true type fonts.",
	"Method": "String[] getCodePagesSupported(){\r\n    return new String[0];\r\n}"
}, {
	"Path": "software.amazon.ion.LoaderTest.loadOneValue",
	"Comment": "parses text as a single ion value.if the text contains more than that,a failure is thrown.",
	"Method": "IonValue loadOneValue(String text){\r\n    IonDatagram dg = loader().load(text);\r\n    if (dg.size() == 0) {\r\n        fail(\"No user values in text: \" + text);\r\n    }\r\n    if (dg.size() > 1) {\r\n        IonValue part = dg.get(1);\r\n        fail(\"Found unexpected part <\" + part + \"> in text: \" + text);\r\n    }\r\n    IonValue value = dg.get(0);\r\n    dg.remove(value);\r\n    return value;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.MakeSignature.signExternalContainer",
	"Comment": "sign the document using an external container, usually a pkcs7. the signature is fully composedexternally, itext will just put the container inside the document.",
	"Method": "void signExternalContainer(PdfSignatureAppearance sap,ExternalSignatureContainer externalSignatureContainer,int estimatedSize){\r\n    PdfSignature dic = new PdfSignature(null, null);\r\n    dic.setReason(sap.getReason());\r\n    dic.setLocation(sap.getLocation());\r\n    dic.setSignatureCreator(sap.getSignatureCreator());\r\n    dic.setContact(sap.getContact());\r\n    dic.setDate(new PdfDate(sap.getSignDate()));\r\n    externalSignatureContainer.modifySigningDictionary(dic);\r\n    sap.setCryptoDictionary(dic);\r\n    HashMap<PdfName, Integer> exc = new HashMap<PdfName, Integer>();\r\n    exc.put(PdfName.CONTENTS, new Integer(estimatedSize * 2 + 2));\r\n    sap.preClose(exc);\r\n    InputStream data = sap.getRangeStream();\r\n    byte[] encodedSig = externalSignatureContainer.sign(data);\r\n    if (estimatedSize < encodedSig.length)\r\n        throw new IOException(\"Not enough space\");\r\n    byte[] paddedSig = new byte[estimatedSize];\r\n    System.arraycopy(encodedSig, 0, paddedSig, 0, encodedSig.length);\r\n    PdfDictionary dic2 = new PdfDictionary();\r\n    dic2.put(PdfName.CONTENTS, new PdfString(paddedSig).setHexWriting(true));\r\n    sap.close(dic2);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.setTampered",
	"Comment": "sets the tampered state. a tampered pdfreader cannot be reused in pdfstamper.",
	"Method": "void setTampered(boolean tampered){\r\n    this.tampered = tampered;\r\n    pageRefs.keepPages();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BarcodeEAN.convertUPCAtoUPCE",
	"Comment": "converts an upca code into an upce code. if the code can notbe converted a null is returned.",
	"Method": "String convertUPCAtoUPCE(String text){\r\n    if (text.length() != 12 || !(text.startsWith(\"0\") || text.startsWith(\"1\")))\r\n        return null;\r\n    if (text.substring(3, 6).equals(\"000\") || text.substring(3, 6).equals(\"100\") || text.substring(3, 6).equals(\"200\")) {\r\n        if (text.substring(6, 8).equals(\"00\"))\r\n            return text.substring(0, 1) + text.substring(1, 3) + text.substring(8, 11) + text.substring(3, 4) + text.substring(11);\r\n    } else if (text.substring(4, 6).equals(\"00\")) {\r\n        if (text.substring(6, 9).equals(\"000\"))\r\n            return text.substring(0, 1) + text.substring(1, 4) + text.substring(9, 11) + \"3\" + text.substring(11);\r\n    } else if (text.substring(5, 6).equals(\"0\")) {\r\n        if (text.substring(6, 10).equals(\"0000\"))\r\n            return text.substring(0, 1) + text.substring(1, 5) + text.substring(10, 11) + \"4\" + text.substring(11);\r\n    } else if (text.charAt(10) >= '5') {\r\n        if (text.substring(6, 10).equals(\"0000\"))\r\n            return text.substring(0, 1) + text.substring(1, 6) + text.substring(10, 11) + text.substring(11);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONArray.optDouble",
	"Comment": "get the optional double value associated with an index. the defaultvalueis returned if there is no value for the index, or if the value is not anumber and cannot be converted to a number.",
	"Method": "double optDouble(int index,double optDouble,int index,double defaultValue){\r\n    try {\r\n        return this.getDouble(index);\r\n    } catch (Exception e) {\r\n        return defaultValue;\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.setPosition",
	"Comment": "the world position of the body. avoid creating bodies at the origin since this can lead to manyoverlapping shapes.",
	"Method": "void setPosition(Vec2 position){\r\n    this.position = position;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.zip.Keep.register",
	"Comment": "register a value in the keep. compact the keep if it is full. the nexttime this value is encountered, its integer can be sent instead.",
	"Method": "void register(Object value){\r\n    if (JSONzip.probe) {\r\n        int integer = find(value);\r\n        if (integer >= 0) {\r\n            JSONzip.log(\"\\nDuplicate key \" + value);\r\n        }\r\n    }\r\n    if (this.length >= this.capacity) {\r\n        compact();\r\n    }\r\n    this.list[this.length] = value;\r\n    this.map.put(value, this.length);\r\n    this.ticks[this.length] = 1;\r\n    if (JSONzip.probe) {\r\n        JSONzip.log(\"<\" + this.length + \" \" + value + \"> \");\r\n    }\r\n    this.length += 1;\r\n}"
}, {
	"Path": "com.example.cloud.iot.examples.HttpExampleOptions.fromFlags",
	"Comment": "construct an httpexampleoptions class from command line flags.",
	"Method": "HttpExampleOptions fromFlags(String[] args){\r\n    Options options = new Options();\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"project_id\").hasArg().desc(\"GCP cloud project name.\").required().build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"registry_id\").hasArg().desc(\"Cloud IoT Core registry id.\").required().build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"device_id\").hasArg().desc(\"Cloud IoT Core device id.\").required().build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"private_key_file\").hasArg().desc(\"Path to private key file.\").required().build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"algorithm\").hasArg().desc(\"Encryption algorithm to use to generate the JWT. Either 'RS256' or 'ES256'.\").required().build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"cloud_region\").hasArg().desc(\"GCP cloud region.\").build());\r\n    options.addOption(Option.builder().type(Number.class).longOpt(\"num_messages\").hasArg().desc(\"Number of messages to publish.\").build());\r\n    options.addOption(Option.builder().type(Number.class).longOpt(\"token_exp_minutes\").hasArg().desc(\"Minutes to JWT token refresh (token expiration time).\").build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"http_bridge_address\").hasArg().desc(\"HTTP bridge address.\").build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"api_version\").hasArg().desc(\"The version to use of the API.\").build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"message_type\").hasArg().desc(\"Indicates whether message is a telemetry event or a device state message\").build());\r\n    CommandLineParser parser = new DefaultParser();\r\n    CommandLine commandLine;\r\n    try {\r\n        commandLine = parser.parse(options, args);\r\n        HttpExampleOptions res = new HttpExampleOptions();\r\n        res.projectId = commandLine.getOptionValue(\"project_id\");\r\n        res.registryId = commandLine.getOptionValue(\"registry_id\");\r\n        res.deviceId = commandLine.getOptionValue(\"device_id\");\r\n        res.privateKeyFile = commandLine.getOptionValue(\"private_key_file\");\r\n        res.algorithm = commandLine.getOptionValue(\"algorithm\");\r\n        if (commandLine.hasOption(\"cloud_region\")) {\r\n            res.cloudRegion = commandLine.getOptionValue(\"cloud_region\");\r\n        }\r\n        if (commandLine.hasOption(\"num_messages\")) {\r\n            res.numMessages = ((Number) commandLine.getParsedOptionValue(\"num_messages\")).intValue();\r\n        }\r\n        if (commandLine.hasOption(\"token_exp_minutes\")) {\r\n            res.tokenExpMins = ((Number) commandLine.getParsedOptionValue(\"token_exp_minutes\")).intValue();\r\n        }\r\n        if (commandLine.hasOption(\"http_bridge_address\")) {\r\n            res.httpBridgeAddress = commandLine.getOptionValue(\"http_bridge_address\");\r\n        }\r\n        if (commandLine.hasOption(\"api_version\")) {\r\n            res.apiVersion = commandLine.getOptionValue(\"api_version\");\r\n        }\r\n        if (commandLine.hasOption(\"message_type\")) {\r\n            res.messageType = commandLine.getOptionValue(\"message_type\");\r\n        }\r\n        return res;\r\n    } catch (ParseException e) {\r\n        System.err.println(e.getMessage());\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.io.GroupedRandomAccessSource.getSourceEntryForOffset",
	"Comment": "returns the sourceentry that contains the byte at the specified offset\tsourcereleased is called as a notification callback so subclasses can take care of cleanup when the source is no longer the active source",
	"Method": "SourceEntry getSourceEntryForOffset(long offset){\r\n    if (offset >= size)\r\n        return null;\r\n    if (offset >= currentSourceEntry.firstByte && offset <= currentSourceEntry.lastByte)\r\n        return currentSourceEntry;\r\n    sourceReleased(currentSourceEntry.source);\r\n    int startAt = getStartingSourceIndex(offset);\r\n    for (int i = startAt; i < sources.length; i++) {\r\n        if (offset >= sources[i].firstByte && offset <= sources[i].lastByte) {\r\n            currentSourceEntry = sources[i];\r\n            sourceInUse(currentSourceEntry.source);\r\n            return currentSourceEntry;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.TSAClientBouncyCastle.getTokenSizeEstimate",
	"Comment": "get the token size estimate.returned value reflects the result of the last succesfull call, padded",
	"Method": "int getTokenSizeEstimate(){\r\n    return tokenSizeEstimate;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.util.PdfResourceCounter.getLength",
	"Comment": "returns the resources needed for the object that was used to createthis pdfresourcecounter. if you pass a map with resources that werealready used by other objects, these objects will not be taken intoaccount.",
	"Method": "long getLength(Map<Integer, PdfObject> res){\r\n    long length = 0;\r\n    PdfObject object;\r\n    for (int ref : resources.keySet()) {\r\n        if (res != null && res.containsKey(ref)) {\r\n            continue;\r\n        }\r\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n        object = resources.get(ref);\r\n        object.toPdf(null, baos);\r\n        length += baos.size();\r\n    }\r\n    return length;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfLayer.setRef",
	"Comment": "sets the pdfindirectreference that represents this layer.this can only be done from pdfstamperimp.",
	"Method": "void setRef(PdfIndirectReference ref){\r\n    this.ref = ref;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentByte.moveTextWithLeading",
	"Comment": "moves to the start of the next line, offset from the start of the current line.as a side effect, this sets the leading parameter in the text state.",
	"Method": "void moveTextWithLeading(float x,float y){\r\n    if (!inText && isTagged()) {\r\n        beginText(true);\r\n    }\r\n    state.xTLM += x;\r\n    state.yTLM += y;\r\n    state.leading = -y;\r\n    if (isTagged() && state.xTLM != state.tx) {\r\n        setTextMatrix(state.aTLM, state.bTLM, state.cTLM, state.dTLM, state.xTLM, state.yTLM);\r\n    } else {\r\n        content.append(x).append(' ').append(y).append(\" TD\").append_i(separator);\r\n    }\r\n}"
}, {
	"Path": "com.example.cloud.iot.examples.DeviceRegistryExampleOptions.fromFlags",
	"Comment": "construct an deviceregistryexampleoptions class from command line flags.",
	"Method": "DeviceRegistryExampleOptions fromFlags(String[] args){\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"command\").hasArg().desc(\"Command to run:\" + \"\\n\\tcreate-iot-topic\" + \"\\n\\tcreate-rsa\" + \"\\n\\tcreate-es\" + \"\\n\\tcreate-unauth\" + \"\\n\\tcreate-registry\" + \"\\n\\tdelete-device\" + \"\\n\\tdelete-registry\" + \"\\n\\tget-device\" + \"\\n\\tget-device-state\" + \"\\n\\tget-iam-permissions\" + \"\\n\\tget-registry\" + \"\\n\\tlist-devices\" + \"\\n\\tlist-registries\" + \"\\n\\tpatch-device-es\" + \"\\n\\tpatch-device-rsa\" + \"\\n\\tset-config\" + \"\\n\\tset-iam-permissions\" + \"\\n\\tsend-command\").required().build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"pubsub_topic\").hasArg().desc(\"Pub/Sub topic to create registry in.\").build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"ec_public_key_file\").hasArg().desc(\"Path to ES256 public key file.\").build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"rsa_certificate_file\").hasArg().desc(\"Path to RS256 certificate file.\").build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"cloud_region\").hasArg().desc(\"GCP cloud region.\").build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"project_id\").hasArg().desc(\"GCP cloud project name.\").build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"registry_name\").hasArg().desc(\"Name for your Device Registry.\").build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"device_id\").hasArg().desc(\"Name for your Device.\").build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"data\").hasArg().desc(\"The command data (string or JSON) to send to the specified device.\").build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"configuration\").hasArg().desc(\"The configuration (string or JSON) to set the specified device to.\").build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"version\").hasArg().desc(\"The configuration version to send on the device (0 is latest).\").build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"member\").hasArg().desc(\"The member used for setting IAM permissions.\").build());\r\n    options.addOption(Option.builder().type(String.class).longOpt(\"role\").hasArg().desc(\"The role (e.g. 'roles/viewer') used when setting IAM permissions.\").build());\r\n    CommandLineParser parser = new DefaultParser();\r\n    CommandLine commandLine;\r\n    try {\r\n        commandLine = parser.parse(options, args);\r\n        DeviceRegistryExampleOptions res = new DeviceRegistryExampleOptions();\r\n        res.command = commandLine.getOptionValue(\"command\");\r\n        if (res.command.equals(\"help\") || res.command.equals(\"\")) {\r\n            throw new ParseException(\"Invalid command, showing help.\");\r\n        }\r\n        if (commandLine.hasOption(\"cloud_region\")) {\r\n            res.cloudRegion = commandLine.getOptionValue(\"cloud_region\");\r\n        }\r\n        if (commandLine.hasOption(\"data\")) {\r\n            res.commandData = commandLine.getOptionValue(\"data\");\r\n        }\r\n        if (commandLine.hasOption(\"device_id\")) {\r\n            res.deviceId = commandLine.getOptionValue(\"device_id\");\r\n        }\r\n        if (commandLine.hasOption(\"project_id\")) {\r\n            res.projectId = commandLine.getOptionValue(\"project_id\");\r\n        } else {\r\n            try {\r\n                res.projectId = System.getenv(\"GOOGLE_CLOUD_PROJECT\");\r\n            } catch (NullPointerException npe) {\r\n                res.projectId = System.getenv(\"GCLOUD_PROJECT\");\r\n            }\r\n        }\r\n        if (commandLine.hasOption(\"pubsub_topic\")) {\r\n            res.pubsubTopic = commandLine.getOptionValue(\"pubsub_topic\");\r\n        } else {\r\n        }\r\n        if (commandLine.hasOption(\"ec_public_key_file\")) {\r\n            res.ecPublicKeyFile = commandLine.getOptionValue(\"ec_public_key_file\");\r\n        }\r\n        if (commandLine.hasOption(\"rsa_certificate_file\")) {\r\n            res.rsaCertificateFile = commandLine.getOptionValue(\"rsa_certificate_file\");\r\n        }\r\n        if (commandLine.hasOption(\"cloud_region\")) {\r\n            res.cloudRegion = commandLine.getOptionValue(\"cloud_region\");\r\n        }\r\n        if (commandLine.hasOption(\"registry_name\")) {\r\n            res.registryName = commandLine.getOptionValue(\"registry_name\");\r\n        }\r\n        if (commandLine.hasOption(\"device_id\")) {\r\n            res.deviceId = commandLine.getOptionValue(\"device_id\");\r\n        }\r\n        if (commandLine.hasOption(\"configuration\")) {\r\n            res.configuration = commandLine.getOptionValue(\"configuration\");\r\n        }\r\n        if (commandLine.hasOption(\"version\")) {\r\n            res.version = new Long(commandLine.getOptionValue(\"version\")).longValue();\r\n        }\r\n        if (commandLine.hasOption(\"member\")) {\r\n            res.member = commandLine.getOptionValue(\"member\");\r\n        }\r\n        if (commandLine.hasOption(\"role\")) {\r\n            res.role = commandLine.getOptionValue(\"role\");\r\n        }\r\n        return res;\r\n    } catch (ParseException e) {\r\n        String header = \"Cloud IoT Core Commandline Example (Device / Registry management): \\n\\n\";\r\n        String footer = \"\\nhttps://cloud.google.com/iot-core\";\r\n        HelpFormatter formatter = new HelpFormatter();\r\n        formatter.printHelp(\"DeviceRegistryExample\", header, options, footer, true);\r\n        System.err.println(e.getMessage());\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfSignatureAppearance.getRect",
	"Comment": "gets the rectangle representing the signature dimensions.",
	"Method": "Rectangle getRect(){\r\n    return rect;\r\n}"
}, {
	"Path": "com.google.cloud.storage.storagetransfer.samples.TransferClientCreator.createStorageTransferClient",
	"Comment": "create a storage transfer client using application default credentials and other defaultsettings.",
	"Method": "Storagetransfer createStorageTransferClient(Storagetransfer createStorageTransferClient,HttpTransport httpTransport,JsonFactory jsonFactory,GoogleCredential credential){\r\n    Preconditions.checkNotNull(httpTransport);\r\n    Preconditions.checkNotNull(jsonFactory);\r\n    Preconditions.checkNotNull(credential);\r\n    if (credential.createScopedRequired()) {\r\n        credential = credential.createScoped(StoragetransferScopes.all());\r\n    }\r\n    HttpRequestInitializer initializer = new RetryHttpInitializerWrapper(credential);\r\n    return new Storagetransfer.Builder(httpTransport, jsonFactory, initializer).setApplicationName(\"storagetransfer-sample\").build();\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.util.IntArrayList.remove",
	"Comment": "remove the element at the specified positionuse system.arraycopy instead of a loop may be more efficient",
	"Method": "void remove(int idx){\r\n    if (idx < 0 || idx > size)\r\n        throw new IndexOutOfBoundsException();\r\n    int numMove = size - idx - 1;\r\n    if (numMove > 0)\r\n        System.arraycopy(items, idx + 1, items, idx, numMove);\r\n    size--;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Fixture.setUserData",
	"Comment": "set the user data. use this to store your application specific data.",
	"Method": "void setUserData(Object data){\r\n    m_userData = data;\r\n}"
}, {
	"Path": "com.machinepublishers.glass.ui.monocle.MouseInput.getState",
	"Comment": "retrieves the current state of mouse buttons and of the cursor.",
	"Method": "void getState(MouseState result){\r\n    state.copyTo(result);\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.TagTest.validateParentSetOnAdd",
	"Comment": "validates that the tags parent is set when adding it as a child",
	"Method": "void validateParentSetOnAdd(){\r\n    Tag t = new Tag(\"pappie\");\r\n    Tag t2 = new Tag(\"baby\");\r\n    t.addChild(t2);\r\n    Assert.assertEquals(t, t2.getParent());\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.css.apply.ChunkCssApplier.getWidestWord",
	"Comment": "method used for retrieving the widest word of a chunk of text. all styles of the chunk will be taken into account when calculating the width of the words.",
	"Method": "float getWidestWord(Chunk c){\r\n    String[] words = c.getContent().split(\"\\\\s\");\r\n    float widestWord = 0;\r\n    for (int i = 0; i < words.length; i++) {\r\n        Chunk word = new Chunk(words[i]);\r\n        copyChunkStyles(c, word);\r\n        if (word.getWidthPoint() > widestWord) {\r\n            widestWord = word.getWidthPoint();\r\n        }\r\n    }\r\n    return widestWord;\r\n}"
}, {
	"Path": "com.sixt.service.framework.servicetest.helper.DockerComposeHelper.waitForImpersonator",
	"Comment": "wait for impersonator to become ready by checking log forsome custom expected phrase",
	"Method": "SuccessOrFailure waitForImpersonator(String logFile,SuccessOrFailure waitForImpersonator,String logFile,String phraseToWaitFor){\r\n    return waitFor(logFile, phraseToWaitFor, \"Impersonator not ready yet\");\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.setAngularDamping",
	"Comment": "angular damping is use to reduce the angular velocity. the damping parameter can be larger than1.0f but the damping effect becomes sensitive to the time step when the damping parameter islarge.",
	"Method": "void setAngularDamping(float angularDamping){\r\n    this.angularDamping = angularDamping;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaWindow.setHeight",
	"Comment": "sets a dictionary with keys default, max, and min describing values for\tthe height of the window in default user space units.",
	"Method": "void setHeight(float defaultHeight,float maxHeight,float minHeight){\r\n    put(PdfName.HEIGHT, createDimensionDictionary(defaultHeight, maxHeight, minHeight));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Barcode.setInkSpreading",
	"Comment": "sets the amount of ink spreading. this value will be subtractedto the width of each bar. the actual value will depend on the inkand the printing medium.",
	"Method": "void setInkSpreading(float inkSpreading){\r\n    this.inkSpreading = inkSpreading;\r\n}"
}, {
	"Path": "com.itextpdf.text.MarkedSection.setBookmarkTitle",
	"Comment": "sets the bookmark title. the bookmark title is the same as the section title but\tcan be changed with this method.",
	"Method": "void setBookmarkTitle(String bookmarkTitle){\r\n    ((Section) element).setBookmarkTitle(bookmarkTitle);\r\n}"
}, {
	"Path": "software.amazon.ion.impl.IonWriterTestCase.reload",
	"Comment": "extracts bytes from the current writer and loads it into a datagram.",
	"Method": "IonDatagram reload(){\r\n    byte[] bytes = outputByteArray();\r\n    IonDatagram dg;\r\n    if (false) {\r\n        try {\r\n            dg = loader().load(bytes);\r\n        } catch (IonException e) {\r\n        }\r\n    }\r\n    dg = loader().load(bytes);\r\n    return dg;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDictionary.put",
	"Comment": "associates the specified pdfobject as value withthe specified pdfname as key in this map.if the map previously contained a mapping for this key, theold value is replaced. if the value isnull or pdfnull the key is deleted.",
	"Method": "void put(PdfName key,PdfObject object){\r\n    if (key == null)\r\n        throw new IllegalArgumentException(MessageLocalization.getComposedMessage(\"key.is.null\"));\r\n    if (object == null || object.isNull())\r\n        hashMap.remove(key);\r\n    else\r\n        hashMap.put(key, object);\r\n}"
}, {
	"Path": "com.structurizr.view.View.removeElementsWithNoRelationships",
	"Comment": "removes all elements that have no relationships to other elements in this view.",
	"Method": "void removeElementsWithNoRelationships(){\r\n    Set<RelationshipView> relationships = getRelationships();\r\n    Set<String> elementIds = new HashSet();\r\n    relationships.forEach(rv -> elementIds.add(rv.getRelationship().getSourceId()));\r\n    relationships.forEach(rv -> elementIds.add(rv.getRelationship().getDestinationId()));\r\n    for (ElementView elementView : getElements()) {\r\n        if (!elementIds.contains(elementView.getId())) {\r\n            removeElement(elementView.getElement());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStamper.getXmlSignatureAppearance",
	"Comment": "gets the xml signing instance. the appearances and other parameters can the be set.",
	"Method": "XmlSignatureAppearance getXmlSignatureAppearance(){\r\n    return sigXmlApp;\r\n}"
}, {
	"Path": "software.amazon.ion.SystemProcessingTestCase.testLocalSymtabWithMalformedSymbolEntries",
	"Comment": "according to the spec malformed symbol entries must be interpreted as null, this testverifies this behavior",
	"Method": "void testLocalSymtabWithMalformedSymbolEntries(){\r\n    checkLocalSymtabWithMalformedSymbolEntry(\"null\");\r\n    checkLocalSymtabWithMalformedSymbolEntry(\"true\");\r\n    checkLocalSymtabWithMalformedSymbolEntry(\"100\");\r\n    checkLocalSymtabWithMalformedSymbolEntry(\"0.123\");\r\n    checkLocalSymtabWithMalformedSymbolEntry(\"-0.12e4\");\r\n    checkLocalSymtabWithMalformedSymbolEntry(\"2013-05-09\");\r\n    checkLocalSymtabWithMalformedSymbolEntry(\"a_symbol\");\r\n    checkLocalSymtabWithMalformedSymbolEntry(\"{{MTIz}}\");\r\n    checkLocalSymtabWithMalformedSymbolEntry(\"{{'''clob_content'''}}\");\r\n    checkLocalSymtabWithMalformedSymbolEntry(\"{a:123}\");\r\n    checkLocalSymtabWithMalformedSymbolEntry(\"[a, b, c]\");\r\n    checkLocalSymtabWithMalformedSymbolEntry(\"(a b c)\");\r\n    checkLocalSymtabWithMalformedSymbolEntry(\"null.string\");\r\n    checkLocalSymtabWithMalformedSymbolEntry(\"['''whee''']\");\r\n}"
}, {
	"Path": "com.sixt.service.framework.health.HealthCheckManager.getSummaryFor",
	"Comment": "we return the most severe of the statuses within the collection",
	"Method": "HealthCheck.Status getSummaryFor(Collection<HealthCheck> checks){\r\n    HealthCheck.Status retval = HealthCheck.Status.PASS;\r\n    for (HealthCheck check : checks) {\r\n        if (check.getStatus().moreSevereThan(retval)) {\r\n            retval = check.getStatus();\r\n        }\r\n    }\r\n    return retval;\r\n}"
}, {
	"Path": "com.itextpdf.text.xml.XMLUtil.findInArray",
	"Comment": "looks for a character in a character array, starting from a certain position",
	"Method": "int findInArray(char needle,char[] haystack,int start){\r\n    for (int i = start; i < haystack.length; i++) {\r\n        if (haystack[i] == ';')\r\n            return i;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.jbox2d.common.Vec2.normalize",
	"Comment": "normalize this vector and return the length before normalization. alters this vector.",
	"Method": "float normalize(){\r\n    float length = length();\r\n    if (length < Settings.EPSILON) {\r\n        return 0f;\r\n    }\r\n    float invLength = 1.0f / length;\r\n    x *= invLength;\r\n    y *= invLength;\r\n    return length;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.PdfTextExtractor.getTextFromPage",
	"Comment": "extract text from a specified page using an extraction strategy.",
	"Method": "String getTextFromPage(PdfReader reader,int pageNumber,TextExtractionStrategy strategy,Map<String, ContentOperator> additionalContentOperators,String getTextFromPage,PdfReader reader,int pageNumber,TextExtractionStrategy strategy,String getTextFromPage,PdfReader reader,int pageNumber){\r\n    return getTextFromPage(reader, pageNumber, new LocationTextExtractionStrategy());\r\n}"
}, {
	"Path": "com.itextpdf.text.io.RandomAccessSourceFactory.setForceRead",
	"Comment": "determines whether the full content of the source will be read into memory",
	"Method": "RandomAccessSourceFactory setForceRead(boolean forceRead){\r\n    this.forceRead = forceRead;\r\n    return this;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.CalcHints",
	"Comment": "the function reads the subroutine and returns the number of the hint in it.\tif a call to another subroutine is found the function calls recursively.",
	"Method": "int CalcHints(int begin,int end,int LBias,int GBias,int[] LSubrsOffsets){\r\n    seek(begin);\r\n    while (getPosition() < end) {\r\n        ReadCommand();\r\n        int pos = getPosition();\r\n        Object TopElement = null;\r\n        if (arg_count > 0)\r\n            TopElement = args[arg_count - 1];\r\n        int NumOfArgs = arg_count;\r\n        HandelStack();\r\n        if (key == \"callsubr\") {\r\n            if (NumOfArgs > 0) {\r\n                int Subr = ((Integer) TopElement).intValue() + LBias;\r\n                CalcHints(LSubrsOffsets[Subr], LSubrsOffsets[Subr + 1], LBias, GBias, LSubrsOffsets);\r\n                seek(pos);\r\n            }\r\n        } else if (key == \"callgsubr\") {\r\n            if (NumOfArgs > 0) {\r\n                int Subr = ((Integer) TopElement).intValue() + GBias;\r\n                CalcHints(gsubrOffsets[Subr], gsubrOffsets[Subr + 1], LBias, GBias, LSubrsOffsets);\r\n                seek(pos);\r\n            }\r\n        } else if (key == \"hstem\" || key == \"vstem\" || key == \"hstemhm\" || key == \"vstemhm\")\r\n            NumOfHints += NumOfArgs / 2;\r\n        else if (key == \"hintmask\" || key == \"cntrmask\") {\r\n            int SizeOfMask = NumOfHints / 8;\r\n            if (NumOfHints % 8 != 0 || SizeOfMask == 0)\r\n                SizeOfMask++;\r\n            for (int i = 0; i < SizeOfMask; i++) getCard8();\r\n        }\r\n    }\r\n    return NumOfHints;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.getAngularDamping",
	"Comment": "angular damping is use to reduce the angular velocity. the damping parameter can be larger than1.0f but the damping effect becomes sensitive to the time step when the damping parameter islarge.",
	"Method": "float getAngularDamping(){\r\n    return angularDamping;\r\n}"
}, {
	"Path": "com.itextpdf.awt.DefaultFontMapper.insertFile",
	"Comment": "inserts one font file into the map. the encodingwill be basefont.cp1252 but can bechanged later.",
	"Method": "int insertFile(File file){\r\n    String name = file.getPath().toLowerCase();\r\n    try {\r\n        if (name.endsWith(\".ttf\") || name.endsWith(\".otf\") || name.endsWith(\".afm\")) {\r\n            Object[] allNames = BaseFont.getAllFontNames(file.getPath(), BaseFont.CP1252, null);\r\n            insertNames(allNames, file.getPath());\r\n            return 1;\r\n        } else if (name.endsWith(\".ttc\")) {\r\n            String[] ttcs = BaseFont.enumerateTTCNames(file.getPath());\r\n            for (int j = 0; j < ttcs.length; ++j) {\r\n                String nt = file.getPath() + \",\" + j;\r\n                Object[] allNames = BaseFont.getAllFontNames(nt, BaseFont.CP1252, null);\r\n                insertNames(allNames, nt);\r\n            }\r\n            return 1;\r\n        }\r\n    } catch (Exception e) {\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.google.cloud.storage.storagetransfer.samples.RequestChecker.checkTransfer",
	"Comment": "creates and executes a query for all associated transferoperations.",
	"Method": "ListOperationsResponse checkTransfer(Storagetransfer client,String projectId,String jobName){\r\n    return client.transferOperations().list(\"transferOperations\").setFilter(\"{\\\"project_id\\\": \\\"\" + projectId + \"\\\", \\\"job_names\\\": [\\\"\" + jobName + \"\\\"] }\").execute();\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.test.DicMerge.merge",
	"Comment": "merge two jcseg dictionary filesremove the duplicate entries and store the entris in a specified file",
	"Method": "int merge(File[] srcFiles,File dstFile){\r\n    IWord word = null;\r\n    BufferedReader reader = null;\r\n    String keywords = null;\r\n    HashMap<String, IWord> entries = new HashMap<String, IWord>();\r\n    for (int j = 0; j < srcFiles.length; j++) {\r\n        String line = null;\r\n        reader = new BufferedReader(new FileReader(srcFiles[j]));\r\n        keywords = reader.readLine();\r\n        while ((line = reader.readLine()) != null) {\r\n            line = line.trim();\r\n            if (line.equals(\"\"))\r\n                continue;\r\n            if (line.length() > 1 && line.charAt(0) == '#')\r\n                continue;\r\n            if (line.indexOf('/') == -1) {\r\n                if (!entries.containsKey(line))\r\n                    entries.put(line, new Word(line, 1));\r\n                continue;\r\n            }\r\n            String[] splits = line.split(\"/\");\r\n            if (splits.length < 4) {\r\n                line = null;\r\n                splits = null;\r\n                continue;\r\n            }\r\n            word = entries.get(splits[0]);\r\n            if (word == null) {\r\n                int type = 0, fre = 0;\r\n                if (splits.length > 4) {\r\n                    fre = Integer.parseInt(splits[4]);\r\n                    type = 2;\r\n                }\r\n                word = new Word(splits[0], fre, type);\r\n                if (!splits[1].equals(\"null\"))\r\n                    word.setPartSpeech(splits[1].split(\",\"));\r\n                if (!(splits[2].equals(\"%\") || splits[2].equals(\"null\")))\r\n                    word.setPinyin(splits[2]);\r\n                entries.put(splits[0], word);\r\n            } else {\r\n                if (!splits[1].equals(\"null\")) {\r\n                    String[] pps = splits[1].split(\",\");\r\n                    if (word.getPartSpeech() == null)\r\n                        word.setPartSpeech(pps);\r\n                    else {\r\n                    }\r\n                    pps = null;\r\n                }\r\n                if (word.getPinyin() == null && !splits[2].equals(\"null\"))\r\n                    word.setPinyin(splits[2]);\r\n            }\r\n        }\r\n        reader.close();\r\n    }\r\n    String[] keys = new String[entries.size()];\r\n    entries.keySet().toArray(keys);\r\n    Sort.quicksort(keys);\r\n    BufferedWriter writer = new BufferedWriter(new FileWriter(dstFile));\r\n    writer.write(keywords);\r\n    writer.write('\\n');\r\n    IStringBuffer isb = new IStringBuffer();\r\n    for (int j = 0; j < keys.length; j++) {\r\n        word = entries.get(keys[j]);\r\n        if (word.getType() == 1) {\r\n            writer.write(word.getValue());\r\n            writer.write('\\n');\r\n            continue;\r\n        }\r\n        isb.clear();\r\n        isb.append(word.getValue());\r\n        isb.append('/');\r\n        if (word.getPartSpeech() == null)\r\n            isb.append(\"null\");\r\n        else {\r\n            String[] ps = word.getPartSpeech();\r\n            for (int i = 0; i < ps.length; i++) {\r\n                if (i == 0)\r\n                    isb.append(ps[0]);\r\n                else {\r\n                    isb.append(',');\r\n                    isb.append(ps[i]);\r\n                }\r\n            }\r\n        }\r\n        isb.append('/');\r\n        if (word.getPinyin() == null)\r\n            isb.append(\"null\");\r\n        else\r\n            isb.append(word.getPinyin());\r\n        isb.append('/');\r\n        if (word.getType() == 2) {\r\n            isb.append('/');\r\n            isb.append(\"\" + word.getFrequency());\r\n        }\r\n        writer.write(isb.buffer(), 0, isb.length());\r\n        writer.write('\\n');\r\n    }\r\n    writer.close();\r\n    return keys.length;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.mc.StructureObject.getObjAsDict",
	"Comment": "returns the object referred to by the objr dictionary.\tnote that this method returns a dictionary which means\tthat in case the object is a stream, only the stream\tdictionary will be returned.",
	"Method": "PdfDictionary getObjAsDict(){\r\n    if (obj.isDictionary())\r\n        return (PdfDictionary) obj;\r\n    return null;\r\n}"
}, {
	"Path": "org.jbox2d.common.Mat22.abs",
	"Comment": "return the matrix composed of the absolute values of all elements.",
	"Method": "Mat22 abs(Mat22 abs,Mat22 R){\r\n    return R.abs();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.getDescent",
	"Comment": "gets the descent of a string in normalized 1000 units. the descent will always beless than or equal to zero even if all the characters have an higher descent.",
	"Method": "int getDescent(String text){\r\n    int min = 0;\r\n    char[] chars = text.toCharArray();\r\n    for (int k = 0; k < chars.length; ++k) {\r\n        int[] bbox = getCharBBox(chars[k]);\r\n        if (bbox != null && bbox[1] < min)\r\n            min = bbox[1];\r\n    }\r\n    return min;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.BuildNewIndex",
	"Comment": "function builds the new offset array, object array and assembles the index.\tused for creating the glyph and subrs subsetted index",
	"Method": "byte[] BuildNewIndex(int[] Offsets,HashMap<Integer, int[]> Used,byte OperatorForUnusedEntries){\r\n    int unusedCount = 0;\r\n    int Offset = 0;\r\n    int[] NewOffsets = new int[Offsets.length];\r\n    for (int i = 0; i < Offsets.length; ++i) {\r\n        NewOffsets[i] = Offset;\r\n        if (Used.containsKey(Integer.valueOf(i))) {\r\n            Offset += Offsets[i + 1] - Offsets[i];\r\n        } else {\r\n            unusedCount++;\r\n        }\r\n    }\r\n    byte[] NewObjects = new byte[Offset + unusedCount];\r\n    int unusedOffset = 0;\r\n    for (int i = 0; i < Offsets.length - 1; ++i) {\r\n        int start = NewOffsets[i];\r\n        int end = NewOffsets[i + 1];\r\n        NewOffsets[i] = start + unusedOffset;\r\n        if (start != end) {\r\n            buf.seek(Offsets[i]);\r\n            buf.readFully(NewObjects, start + unusedOffset, end - start);\r\n        } else {\r\n            NewObjects[start + unusedOffset] = OperatorForUnusedEntries;\r\n            unusedOffset++;\r\n        }\r\n    }\r\n    NewOffsets[Offsets.length - 1] += unusedOffset;\r\n    return AssembleIndex(NewOffsets, NewObjects);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPTable.adjustCellsInRow",
	"Comment": "calculates the extra height needed in a row because of rowspans.",
	"Method": "PdfPRow adjustCellsInRow(int start,int end){\r\n    PdfPRow row = getRow(start);\r\n    if (row.isAdjusted()) {\r\n        return row;\r\n    }\r\n    row = new PdfPRow(row);\r\n    PdfPCell cell;\r\n    PdfPCell[] cells = row.getCells();\r\n    for (int i = 0; i < cells.length; i++) {\r\n        cell = cells[i];\r\n        if (cell == null || cell.getRowspan() == 1) {\r\n            continue;\r\n        }\r\n        int stop = Math.min(end, start + cell.getRowspan());\r\n        float extra = 0;\r\n        for (int k = start + 1; k < stop; k++) {\r\n            extra += getRow(k).getMaxHeights();\r\n        }\r\n        row.setExtraHeight(i, extra);\r\n    }\r\n    row.setAdjusted(true);\r\n    return row;\r\n}"
}, {
	"Path": "com.example.containeranalysis.Samples.getOccurrencesForNote",
	"Comment": "retrieves all the occurrences associated with a specified notehere, all occurrences are printed and counted",
	"Method": "int getOccurrencesForNote(GrafeasV1Beta1Client client,String noteId,String projectId){\r\n    final NoteName noteName = NoteName.of(projectId, noteId);\r\n    int i = 0;\r\n    ListNoteOccurrencesRequest request = ListNoteOccurrencesRequest.newBuilder().setName(noteName.toString()).build();\r\n    for (Occurrence o : client.listNoteOccurrences(request).iterateAll()) {\r\n        System.out.println(o.getName());\r\n        i = i + 1;\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.TextRenderInfo.splitString",
	"Comment": "split pdf string into array of single character pdf strings.",
	"Method": "PdfString[] splitString(PdfString string){\r\n    List<PdfString> strings = new ArrayList<PdfString>();\r\n    String stringValue = string.toString();\r\n    for (int i = 0; i < stringValue.length(); i++) {\r\n        PdfString newString = new PdfString(stringValue.substring(i, i + 1), string.getEncoding());\r\n        String text = decode(newString);\r\n        if (text.length() == 0 && i < stringValue.length() - 1) {\r\n            newString = new PdfString(stringValue.substring(i, i + 2), string.getEncoding());\r\n            i++;\r\n        }\r\n        strings.add(newString);\r\n    }\r\n    return strings.toArray(new PdfString[strings.size()]);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.createAnnotation",
	"Comment": "a wrapper around pdfannotation constructor.it is recommended to use this wrapper instead of direct constructor as this is a convenient way to override pdfannotation construction when needed.",
	"Method": "PdfAnnotation createAnnotation(Rectangle rect,PdfName subtype,PdfAnnotation createAnnotation,float llx,float lly,float urx,float ury,PdfString title,PdfString content,PdfName subtype,PdfAnnotation createAnnotation,float llx,float lly,float urx,float ury,PdfAction action,PdfName subtype){\r\n    PdfAnnotation a = new PdfAnnotation(this, llx, lly, urx, ury, action);\r\n    if (subtype != null)\r\n        a.put(PdfName.SUBTYPE, subtype);\r\n    return a;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.ImageRenderInfo.hasMcid",
	"Comment": "checks if the text belongs to a marked content sequencewith a given mcid.",
	"Method": "boolean hasMcid(int mcid,boolean hasMcid,int mcid,boolean checkTheTopmostLevelOnly){\r\n    if (checkTheTopmostLevelOnly) {\r\n        if (markedContentInfos instanceof ArrayList) {\r\n            Integer infoMcid = getMcid();\r\n            return (infoMcid != null) ? infoMcid == mcid : false;\r\n        }\r\n    } else {\r\n        for (MarkedContentInfo info : markedContentInfos) {\r\n            if (info.hasMcid())\r\n                if (info.getMcid() == mcid)\r\n                    return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.example.Quickstart.createAuthorizedClient",
	"Comment": "creates an authorized cloudkms client service using application default credentials.",
	"Method": "CloudKMS createAuthorizedClient(){\r\n    HttpTransport transport = new NetHttpTransport();\r\n    JsonFactory jsonFactory = new JacksonFactory();\r\n    GoogleCredential credential = GoogleCredential.getApplicationDefault(transport, jsonFactory);\r\n    if (credential.createScopedRequired()) {\r\n        credential = credential.createScoped(CloudKMSScopes.all());\r\n    }\r\n    return new CloudKMS.Builder(transport, jsonFactory, credential).setApplicationName(\"CloudKMS snippets\").build();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentParser.parse",
	"Comment": "parses a single command from the content. each command is output as an array of argumentshaving the command itself as the last element. the returned array will be empty if theend of content was reached.",
	"Method": "ArrayList<PdfObject> parse(ArrayList<PdfObject> ls){\r\n    if (ls == null)\r\n        ls = new ArrayList<PdfObject>();\r\n    else\r\n        ls.clear();\r\n    PdfObject ob = null;\r\n    while ((ob = readPRObject()) != null) {\r\n        ls.add(ob);\r\n        if (ob.type() == COMMAND_TYPE)\r\n            break;\r\n    }\r\n    return ls;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfEncryptionTest.restoreCryptographyRestrictions",
	"Comment": "by using this method we restore cryptography restrictions via reflection.",
	"Method": "void restoreCryptographyRestrictions(){\r\n    try {\r\n        Field field = Class.forName(\"javax.crypto.JceSecurity\").getDeclaredField(\"isRestricted\");\r\n        if (field.isAccessible()) {\r\n            field.set(null, java.lang.Boolean.TRUE);\r\n            field.setAccessible(false);\r\n        }\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BarcodeInter25.createAwtImage",
	"Comment": "creates a java.awt.image. this image onlycontains the bars without any text.",
	"Method": "java.awt.Image createAwtImage(java.awt.Color foreground,java.awt.Color background){\r\n    int f = foreground.getRGB();\r\n    int g = background.getRGB();\r\n    java.awt.Canvas canvas = new java.awt.Canvas();\r\n    String bCode = keepNumbers(code);\r\n    if (generateChecksum)\r\n        bCode += getChecksum(bCode);\r\n    int len = bCode.length();\r\n    int nn = (int) n;\r\n    int fullWidth = len * (3 + 2 * nn) + (6 + nn);\r\n    byte[] bars = getBarsInter25(bCode);\r\n    boolean print = true;\r\n    int ptr = 0;\r\n    int height = (int) barHeight;\r\n    int[] pix = new int[fullWidth * height];\r\n    for (int k = 0; k < bars.length; ++k) {\r\n        int w = (bars[k] == 0 ? 1 : nn);\r\n        int c = g;\r\n        if (print)\r\n            c = f;\r\n        print = !print;\r\n        for (int j = 0; j < w; ++j) pix[ptr++] = c;\r\n    }\r\n    for (int k = fullWidth; k < pix.length; k += fullWidth) {\r\n        System.arraycopy(pix, 0, pix, k, fullWidth);\r\n    }\r\n    java.awt.Image img = canvas.createImage(new java.awt.image.MemoryImageSource(fullWidth, height, pix, 0, fullWidth));\r\n    return img;\r\n}"
}, {
	"Path": "com.example.speech.QuickstartSample.main",
	"Comment": "demonstrates using the speech api to transcribe an audio file.",
	"Method": "void main(String args){\r\n    try (SpeechClient speechClient = SpeechClient.create()) {\r\n        String fileName = \"./resources/audio.raw\";\r\n        Path path = Paths.get(fileName);\r\n        byte[] data = Files.readAllBytes(path);\r\n        ByteString audioBytes = ByteString.copyFrom(data);\r\n        RecognitionConfig config = RecognitionConfig.newBuilder().setEncoding(AudioEncoding.LINEAR16).setSampleRateHertz(16000).setLanguageCode(\"en-US\").build();\r\n        RecognitionAudio audio = RecognitionAudio.newBuilder().setContent(audioBytes).build();\r\n        RecognizeResponse response = speechClient.recognize(config, audio);\r\n        List<SpeechRecognitionResult> results = response.getResultsList();\r\n        for (SpeechRecognitionResult result : results) {\r\n            SpeechRecognitionAlternative alternative = result.getAlternativesList().get(0);\r\n            System.out.printf(\"Transcription: %s%n\", alternative.getTranscript());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.setCropBoxSize",
	"Comment": "use this method to set the crop box.the crop box should not be rotated even if the page is rotated.this change only takes effect in the next page.",
	"Method": "void setCropBoxSize(Rectangle crop){\r\n    pdf.setCropBoxSize(crop);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.mc.StructureItem.checkMCID",
	"Comment": "checks if an mcid corresponds with the mcid stored in the structureitem.",
	"Method": "int checkMCID(int pageref,int mcid){\r\n    return 0;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.mc.StructureItems.getNextMCID",
	"Comment": "finds the next available mcid, which is either the lowest empty id inthe existing range, or the first available higher number.",
	"Method": "int getNextMCID(PdfNumber structParents){\r\n    PdfObject object = parentTree.get(structParents.intValue());\r\n    PdfArray array = (PdfArray) PdfReader.getPdfObject(object);\r\n    for (int i = 0; i < array.size(); i++) {\r\n        if (array.getAsIndirectObject(i) == null) {\r\n            return i;\r\n        }\r\n    }\r\n    return array.size();\r\n}"
}, {
	"Path": "com.google.appengine.samples.TaskQueueTest.doTest",
	"Comment": "second test because there will already be a task with the given name.",
	"Method": "void doTest(){\r\n    QueueFactory.getDefaultQueue().add(TaskOptions.Builder.withTaskName(\"task29\"));\r\n    Thread.sleep(1000);\r\n    LocalTaskQueue ltq = LocalTaskQueueTestConfig.getLocalTaskQueue();\r\n    QueueStateInfo qsi = ltq.getQueueStateInfo().get(QueueFactory.getDefaultQueue().getQueueName());\r\n    assertEquals(1, qsi.getTaskInfo().size());\r\n    assertEquals(\"task29\", qsi.getTaskInfo().get(0).getTaskName());\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.DistanceJoint.getReactionForce",
	"Comment": "get the reaction force given the inverse time step. unit is n.",
	"Method": "void getReactionForce(float inv_dt,Vec2 argOut){\r\n    argOut.x = m_impulse * m_u.x * inv_dt;\r\n    argOut.y = m_impulse * m_u.y * inv_dt;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.codec.LZWCompressor.flush",
	"Comment": "indicate to compressor that no more data to go so write out\tany remaining buffered data.",
	"Method": "void flush(){\r\n    if (prefix_ != -1)\r\n        bf_.writeBits(prefix_, numBits_);\r\n    bf_.writeBits(endOfInfo_, numBits_);\r\n    bf_.flush();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaDeactivation.setCondition",
	"Comment": "sets the activation condition.\tset it to xd, and the annotation is explicitly deactivated by a user action\tor script.\tto pc, and the annotation is deactivated as soon as the page that contains\tthe annotation loses focus as the current page.\tto pi, abd the annotation is deactivated as soon as the entire page that\tcontains the annotation is no longer visible.",
	"Method": "void setCondition(PdfName condition){\r\n    put(PdfName.CONDITION, condition);\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.XMLTokener.nextMeta",
	"Comment": "returns the next xml meta token. this is used for skipping over andstructures.",
	"Method": "Object nextMeta(){\r\n    char c;\r\n    char q;\r\n    do {\r\n        c = next();\r\n    } while (Character.isWhitespace(c));\r\n    switch(c) {\r\n        case 0:\r\n            throw syntaxError(\"Misshaped meta tag\");\r\n        case '<':\r\n            return XML.LT;\r\n        case '>':\r\n            return XML.GT;\r\n        case '/':\r\n            return XML.SLASH;\r\n        case '=':\r\n            return XML.EQ;\r\n        case '!':\r\n            return XML.BANG;\r\n        case '?':\r\n            return XML.QUEST;\r\n        case '\"':\r\n        case '\\'':\r\n            q = c;\r\n            for (; ; ) {\r\n                c = next();\r\n                if (c == 0) {\r\n                    throw syntaxError(\"Unterminated string\");\r\n                }\r\n                if (c == q) {\r\n                    return Boolean.TRUE;\r\n                }\r\n            }\r\n        default:\r\n            for (; ; ) {\r\n                c = next();\r\n                if (Character.isWhitespace(c)) {\r\n                    return Boolean.TRUE;\r\n                }\r\n                switch(c) {\r\n                    case 0:\r\n                    case '<':\r\n                    case '>':\r\n                    case '/':\r\n                    case '=':\r\n                    case '!':\r\n                    case '?':\r\n                    case '\"':\r\n                    case '\\'':\r\n                        back();\r\n                        return Boolean.TRUE;\r\n                }\r\n            }\r\n    }\r\n}"
}, {
	"Path": "software.amazon.ion.impl.lite.IonContextTest.testInsertionWithPadding",
	"Comment": "this attempts to force the input and output contexts to have distinctsymbol ids.",
	"Method": "void testInsertionWithPadding(){\r\n    testInsertion(true);\r\n}"
}, {
	"Path": "com.itextpdf.text.xml.simpleparser.SimpleXMLParser.go",
	"Comment": "does the actual parsing. perform this immediatelyafter creating the parser object.",
	"Method": "void go(Reader r){\r\n    BufferedReader reader;\r\n    if (r instanceof BufferedReader)\r\n        reader = (BufferedReader) r;\r\n    else\r\n        reader = new BufferedReader(r);\r\n    doc.startDocument();\r\n    while (true) {\r\n        if (previousCharacter == -1) {\r\n            character = reader.read();\r\n        } else {\r\n            character = previousCharacter;\r\n            previousCharacter = -1;\r\n        }\r\n        if (character == -1) {\r\n            if (html) {\r\n                if (html && state == TEXT)\r\n                    flush();\r\n                doc.endDocument();\r\n            } else {\r\n                throwException(MessageLocalization.getComposedMessage(\"missing.end.tag\"));\r\n            }\r\n            return;\r\n        }\r\n        if (character == '\\n' && eol) {\r\n            eol = false;\r\n            continue;\r\n        } else if (eol) {\r\n            eol = false;\r\n        } else if (character == '\\n') {\r\n            lines++;\r\n            columns = 0;\r\n        } else if (character == '\\r') {\r\n            eol = true;\r\n            character = '\\n';\r\n            lines++;\r\n            columns = 0;\r\n        } else {\r\n            columns++;\r\n        }\r\n        switch(state) {\r\n            case UNKNOWN:\r\n                if (character == '<') {\r\n                    saveState(TEXT);\r\n                    state = TAG_ENCOUNTERED;\r\n                }\r\n                break;\r\n            case TEXT:\r\n                if (character == '<') {\r\n                    flush();\r\n                    saveState(state);\r\n                    state = TAG_ENCOUNTERED;\r\n                } else if (character == '&') {\r\n                    saveState(state);\r\n                    entity.setLength(0);\r\n                    state = ENTITY;\r\n                    nowhite = true;\r\n                } else if (character == ' ') {\r\n                    if (html && nowhite) {\r\n                        text.append(' ');\r\n                        nowhite = false;\r\n                    } else {\r\n                        if (nowhite) {\r\n                            text.append((char) character);\r\n                        }\r\n                        nowhite = false;\r\n                    }\r\n                } else if (Character.isWhitespace((char) character)) {\r\n                    if (html) {\r\n                    } else {\r\n                        if (nowhite) {\r\n                            text.append((char) character);\r\n                        }\r\n                        nowhite = false;\r\n                    }\r\n                } else {\r\n                    text.append((char) character);\r\n                    nowhite = true;\r\n                }\r\n                break;\r\n            case TAG_ENCOUNTERED:\r\n                initTag();\r\n                if (character == '/') {\r\n                    state = IN_CLOSETAG;\r\n                } else if (character == '?') {\r\n                    restoreState();\r\n                    state = PI;\r\n                } else {\r\n                    text.append((char) character);\r\n                    state = EXAMIN_TAG;\r\n                }\r\n                break;\r\n            case EXAMIN_TAG:\r\n                if (character == '>') {\r\n                    doTag();\r\n                    processTag(true);\r\n                    initTag();\r\n                    state = restoreState();\r\n                } else if (character == '/') {\r\n                    state = SINGLE_TAG;\r\n                } else if (character == '-' && text.toString().equals(\"!-\")) {\r\n                    flush();\r\n                    state = COMMENT;\r\n                } else if (character == '[' && text.toString().equals(\"![CDATA\")) {\r\n                    flush();\r\n                    state = CDATA;\r\n                } else if (character == 'E' && text.toString().equals(\"!DOCTYP\")) {\r\n                    flush();\r\n                    state = PI;\r\n                } else if (Character.isWhitespace((char) character)) {\r\n                    doTag();\r\n                    state = TAG_EXAMINED;\r\n                } else {\r\n                    text.append((char) character);\r\n                }\r\n                break;\r\n            case TAG_EXAMINED:\r\n                if (character == '>') {\r\n                    processTag(true);\r\n                    initTag();\r\n                    state = restoreState();\r\n                } else if (character == '/') {\r\n                    state = SINGLE_TAG;\r\n                } else if (Character.isWhitespace((char) character)) {\r\n                } else {\r\n                    text.append((char) character);\r\n                    state = ATTRIBUTE_KEY;\r\n                }\r\n                break;\r\n            case IN_CLOSETAG:\r\n                if (character == '>') {\r\n                    doTag();\r\n                    processTag(false);\r\n                    if (!html && nested == 0)\r\n                        return;\r\n                    state = restoreState();\r\n                } else {\r\n                    if (!Character.isWhitespace((char) character))\r\n                        text.append((char) character);\r\n                }\r\n                break;\r\n            case SINGLE_TAG:\r\n                if (character != '>')\r\n                    throwException(MessageLocalization.getComposedMessage(\"expected.gt.for.tag.lt.1.gt\", tag));\r\n                doTag();\r\n                processTag(true);\r\n                processTag(false);\r\n                initTag();\r\n                if (!html && nested == 0) {\r\n                    doc.endDocument();\r\n                    return;\r\n                }\r\n                state = restoreState();\r\n                break;\r\n            case CDATA:\r\n                if (character == '>' && text.toString().endsWith(\"]]\")) {\r\n                    text.setLength(text.length() - 2);\r\n                    flush();\r\n                    state = restoreState();\r\n                } else\r\n                    text.append((char) character);\r\n                break;\r\n            case COMMENT:\r\n                if (character == '>' && text.toString().endsWith(\"--\")) {\r\n                    text.setLength(text.length() - 2);\r\n                    flush();\r\n                    state = restoreState();\r\n                } else\r\n                    text.append((char) character);\r\n                break;\r\n            case PI:\r\n                if (character == '>') {\r\n                    state = restoreState();\r\n                    if (state == TEXT)\r\n                        state = UNKNOWN;\r\n                }\r\n                break;\r\n            case ENTITY:\r\n                if (character == ';') {\r\n                    state = restoreState();\r\n                    String cent = entity.toString();\r\n                    entity.setLength(0);\r\n                    char ce = EntitiesToUnicode.decodeEntity(cent);\r\n                    if (ce == '\\0')\r\n                        text.append('&').append(cent).append(';');\r\n                    else\r\n                        text.append(ce);\r\n                } else if (character != '#' && (character < '0' || character > '9') && (character < 'a' || character > 'z') && (character < 'A' || character > 'Z') || entity.length() >= 7) {\r\n                    state = restoreState();\r\n                    previousCharacter = character;\r\n                    text.append('&').append(entity.toString());\r\n                    entity.setLength(0);\r\n                } else {\r\n                    entity.append((char) character);\r\n                }\r\n                break;\r\n            case QUOTE:\r\n                if (html && quoteCharacter == ' ' && character == '>') {\r\n                    flush();\r\n                    processTag(true);\r\n                    initTag();\r\n                    state = restoreState();\r\n                } else if (html && quoteCharacter == ' ' && Character.isWhitespace((char) character)) {\r\n                    flush();\r\n                    state = TAG_EXAMINED;\r\n                } else if (html && quoteCharacter == ' ') {\r\n                    text.append((char) character);\r\n                } else if (character == quoteCharacter) {\r\n                    flush();\r\n                    state = TAG_EXAMINED;\r\n                } else if (\" \\r\\n\t\".indexOf(character) >= 0) {\r\n                    text.append(' ');\r\n                } else if (character == '&') {\r\n                    saveState(state);\r\n                    state = ENTITY;\r\n                    entity.setLength(0);\r\n                } else {\r\n                    text.append((char) character);\r\n                }\r\n                break;\r\n            case ATTRIBUTE_KEY:\r\n                if (Character.isWhitespace((char) character)) {\r\n                    flush();\r\n                    state = ATTRIBUTE_EQUAL;\r\n                } else if (character == '=') {\r\n                    flush();\r\n                    state = ATTRIBUTE_VALUE;\r\n                } else if (html && character == '>') {\r\n                    text.setLength(0);\r\n                    processTag(true);\r\n                    initTag();\r\n                    state = restoreState();\r\n                } else {\r\n                    text.append((char) character);\r\n                }\r\n                break;\r\n            case ATTRIBUTE_EQUAL:\r\n                if (character == '=') {\r\n                    state = ATTRIBUTE_VALUE;\r\n                } else if (Character.isWhitespace((char) character)) {\r\n                } else if (html && character == '>') {\r\n                    text.setLength(0);\r\n                    processTag(true);\r\n                    initTag();\r\n                    state = restoreState();\r\n                } else if (html && character == '/') {\r\n                    flush();\r\n                    state = SINGLE_TAG;\r\n                } else if (html) {\r\n                    flush();\r\n                    text.append((char) character);\r\n                    state = ATTRIBUTE_KEY;\r\n                } else {\r\n                    throwException(MessageLocalization.getComposedMessage(\"error.in.attribute.processing\"));\r\n                }\r\n                break;\r\n            case ATTRIBUTE_VALUE:\r\n                if (character == '\"' || character == '\\'') {\r\n                    quoteCharacter = character;\r\n                    state = QUOTE;\r\n                } else if (Character.isWhitespace((char) character)) {\r\n                } else if (html && character == '>') {\r\n                    flush();\r\n                    processTag(true);\r\n                    initTag();\r\n                    state = restoreState();\r\n                } else if (html) {\r\n                    text.append((char) character);\r\n                    quoteCharacter = ' ';\r\n                    state = QUOTE;\r\n                } else {\r\n                    throwException(MessageLocalization.getComposedMessage(\"error.in.attribute.processing\"));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.CertificateVerifier.verify",
	"Comment": "checks the validity of the certificate, and calls the next\tverifier in the chain, if any.",
	"Method": "List<VerificationOK> verify(X509Certificate signCert,X509Certificate issuerCert,Date signDate){\r\n    if (signDate != null)\r\n        signCert.checkValidity(signDate);\r\n    if (issuerCert != null) {\r\n        signCert.verify(issuerCert.getPublicKey());\r\n    } else {\r\n        signCert.verify(signCert.getPublicKey());\r\n    }\r\n    List<VerificationOK> result = new ArrayList<VerificationOK>();\r\n    if (verifier != null)\r\n        result.addAll(verifier.verify(signCert, issuerCert, signDate));\r\n    return result;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.CreateNonCIDSubrs",
	"Comment": "the function marks the beginning of the subrs index and adds the subsetted subrs\tindex to the output list.",
	"Method": "void CreateNonCIDSubrs(int Font,IndexBaseItem PrivateBase,OffsetItem Subrs){\r\n    OutputList.addLast(new SubrMarkerItem(Subrs, PrivateBase));\r\n    if (NewSubrsIndexNonCID != null) {\r\n        OutputList.addLast(new RangeItem(new RandomAccessFileOrArray(NewSubrsIndexNonCID), 0, NewSubrsIndexNonCID.length));\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.BuildGSubrsUsed",
	"Comment": "function scans the glsubr used arraylist to find recursive calls\tto gsubrs and adds to hashmap & arraylist",
	"Method": "void BuildGSubrsUsed(int Font){\r\n    int LBias = 0;\r\n    int SizeOfNonCIDSubrsUsed = 0;\r\n    if (fonts[Font].privateSubrs >= 0) {\r\n        LBias = CalcBias(fonts[Font].privateSubrs, Font);\r\n        SizeOfNonCIDSubrsUsed = lSubrsUsedNonCID.size();\r\n    }\r\n    for (int i = 0; i < lGSubrsUsed.size(); i++) {\r\n        int Subr = lGSubrsUsed.get(i).intValue();\r\n        if (Subr < gsubrOffsets.length - 1 && Subr >= 0) {\r\n            int Start = gsubrOffsets[Subr];\r\n            int End = gsubrOffsets[Subr + 1];\r\n            if (fonts[Font].isCID)\r\n                ReadASubr(Start, End, GBias, 0, hGSubrsUsed, lGSubrsUsed, null);\r\n            else {\r\n                ReadASubr(Start, End, GBias, LBias, hSubrsUsedNonCID, lSubrsUsedNonCID, fonts[Font].SubrsOffsets);\r\n                if (SizeOfNonCIDSubrsUsed < lSubrsUsedNonCID.size()) {\r\n                    for (int j = SizeOfNonCIDSubrsUsed; j < lSubrsUsedNonCID.size(); j++) {\r\n                        int LSubr = lSubrsUsedNonCID.get(j).intValue();\r\n                        if (LSubr < fonts[Font].SubrsOffsets.length - 1 && LSubr >= 0) {\r\n                            int LStart = fonts[Font].SubrsOffsets[LSubr];\r\n                            int LEnd = fonts[Font].SubrsOffsets[LSubr + 1];\r\n                            ReadASubr(LStart, LEnd, GBias, LBias, hSubrsUsedNonCID, lSubrsUsedNonCID, fonts[Font].SubrsOffsets);\r\n                        }\r\n                    }\r\n                    SizeOfNonCIDSubrsUsed = lSubrsUsedNonCID.size();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.pipeline.AbstractPipeline.open",
	"Comment": "just calls getnext.override this to get notified on encountered opening tags.",
	"Method": "Pipeline<?> open(WorkerContext context,Tag t,ProcessObject po){\r\n    return getNext();\r\n}"
}, {
	"Path": "com.machinepublishers.glass.ui.monocle.MouseState.getWindow",
	"Comment": "returns the glass window on which the coordinates of this state are located.",
	"Method": "MonocleWindow getWindow(boolean recalculateCache){\r\n    if (window == null || recalculateCache) {\r\n        window = (MonocleWindow) MonocleWindowManager.getInstance().getWindowForLocation(x, y);\r\n    }\r\n    return window;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.getStreamBytes",
	"Comment": "get the content from a stream applying the required filters.",
	"Method": "byte[] getStreamBytes(PRStream stream,RandomAccessFileOrArray file,byte[] getStreamBytes,PRStream stream){\r\n    RandomAccessFileOrArray rf = stream.getReader().getSafeFile();\r\n    try {\r\n        rf.reOpen();\r\n        return getStreamBytes(stream, rf);\r\n    } finally {\r\n        try {\r\n            rf.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfGState.setStrokeOpacity",
	"Comment": "sets the current stroking alpha constant, specifying the constant shape orconstant opacity value to be used for stroking operations in the transparentimaging model.",
	"Method": "void setStrokeOpacity(float ca){\r\n    put(PdfName.CA, new PdfNumber(ca));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfImportedPage.setCopied",
	"Comment": "indicate that the resources of the imported page have been copied.",
	"Method": "void setCopied(){\r\n    toCopy = false;\r\n}"
}, {
	"Path": "com.example.dlp.RiskAnalysis.categoricalStatsAnalysis",
	"Comment": "calculate categorical statistics for a column in a bigquery table using the dlp api.",
	"Method": "void categoricalStatsAnalysis(String projectId,String datasetId,String tableId,String columnName,String topicId,String subscriptionId){\r\n    try (DlpServiceClient dlpServiceClient = DlpServiceClient.create()) {\r\n        FieldId fieldId = FieldId.newBuilder().setName(columnName).build();\r\n        CategoricalStatsConfig categoricalStatsConfig = CategoricalStatsConfig.newBuilder().setField(fieldId).build();\r\n        BigQueryTable bigQueryTable = BigQueryTable.newBuilder().setProjectId(projectId).setDatasetId(datasetId).setTableId(tableId).build();\r\n        PrivacyMetric privacyMetric = PrivacyMetric.newBuilder().setCategoricalStatsConfig(categoricalStatsConfig).build();\r\n        ProjectTopicName topicName = ProjectTopicName.of(projectId, topicId);\r\n        PublishToPubSub publishToPubSub = PublishToPubSub.newBuilder().setTopic(topicName.toString()).build();\r\n        Action action = Action.newBuilder().setPubSub(publishToPubSub).build();\r\n        RiskAnalysisJobConfig riskAnalysisJobConfig = RiskAnalysisJobConfig.newBuilder().setSourceTable(bigQueryTable).setPrivacyMetric(privacyMetric).addActions(action).build();\r\n        CreateDlpJobRequest createDlpJobRequest = CreateDlpJobRequest.newBuilder().setParent(ProjectName.of(projectId).toString()).setRiskJob(riskAnalysisJobConfig).build();\r\n        DlpJob dlpJob = dlpServiceClient.createDlpJob(createDlpJobRequest);\r\n        String dlpJobName = dlpJob.getName();\r\n        final SettableApiFuture<Boolean> done = SettableApiFuture.create();\r\n        Subscriber subscriber = Subscriber.newBuilder(ProjectSubscriptionName.newBuilder().setProject(projectId).setSubscription(subscriptionId).build(), (pubsubMessage, ackReplyConsumer) -> {\r\n            if (pubsubMessage.getAttributesCount() > 0 && pubsubMessage.getAttributesMap().get(\"DlpJobName\").equals(dlpJobName)) {\r\n                done.set(true);\r\n                ackReplyConsumer.ack();\r\n            }\r\n        }).build();\r\n        subscriber.startAsync();\r\n        try {\r\n            done.get(1, TimeUnit.MINUTES);\r\n            Thread.sleep(500);\r\n        } catch (TimeoutException e) {\r\n            System.out.println(\"Unable to verify job completion.\");\r\n        }\r\n        DlpJob completedJob = dlpServiceClient.getDlpJob(GetDlpJobRequest.newBuilder().setName(dlpJobName).build());\r\n        System.out.println(\"Job status: \" + completedJob.getState());\r\n        AnalyzeDataSourceRiskDetails riskDetails = completedJob.getRiskDetails();\r\n        AnalyzeDataSourceRiskDetails.CategoricalStatsResult result = riskDetails.getCategoricalStatsResult();\r\n        for (CategoricalStatsHistogramBucket bucket : result.getValueFrequencyHistogramBucketsList()) {\r\n            System.out.printf(\"Most common value occurs %d time(s).\\n\", bucket.getValueFrequencyUpperBound());\r\n            System.out.printf(\"Least common value occurs %d time(s).\\n\", bucket.getValueFrequencyLowerBound());\r\n            for (ValueFrequency valueFrequency : bucket.getBucketValuesList()) {\r\n                System.out.printf(\"Value %s occurs %d time(s).\\n\", valueFrequency.getValue().toString(), valueFrequency.getCount());\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        System.out.println(\"Error in categoricalStatsAnalysis: \" + e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.google.cloud.language.samples.Analyze.classifyFile",
	"Comment": "detects categories in a gcs hosted file using the language beta api.",
	"Method": "void classifyFile(String gcsUri){\r\n    try (LanguageServiceClient language = LanguageServiceClient.create()) {\r\n        Document doc = Document.newBuilder().setGcsContentUri(gcsUri).setType(Type.PLAIN_TEXT).build();\r\n        ClassifyTextRequest request = ClassifyTextRequest.newBuilder().setDocument(doc).build();\r\n        ClassifyTextResponse response = language.classifyText(request);\r\n        for (ClassificationCategory category : response.getCategoriesList()) {\r\n            System.out.printf(\"Category name : %s, Confidence : %.3f\\n\", category.getName(), category.getConfidence());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "software.amazon.ion.impl.lite.IonValueLite.setFieldNameSymbol",
	"Comment": "sets the field name and id based on a symboltoken.both parts of the symboltoken are trusted!",
	"Method": "void setFieldNameSymbol(SymbolToken name){\r\n    assert _fieldId == UNKNOWN_SYMBOL_ID && _fieldName == null;\r\n    _fieldName = name.getText();\r\n    _fieldId = name.getSid();\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.html.table.Table.getTableWidth",
	"Comment": "calculates the total width based on the given widths array and the given\touter width.",
	"Method": "float getTableWidth(float[] widths,float outerWidth){\r\n    float width = 0;\r\n    for (float f : widths) {\r\n        width += f;\r\n    }\r\n    return width + outerWidth;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaActivation.setAnimation",
	"Comment": "sets the animation dictionary describing the preferred method\tthat conforming readers should use to drive keyframe animations\tpresent in this artwork.",
	"Method": "void setAnimation(RichMediaAnimation animation){\r\n    put(PdfName.ANIMATION, animation);\r\n}"
}, {
	"Path": "software.amazon.ion.SequenceTestCase.testModsCausingHeaderOverlap",
	"Comment": "this looks for a subtle encoding problem. if a value has its headerwidened enough to overlap clean content, we must be careful to notoverwrite the content while writing the header.this can happen whenadding annotations.",
	"Method": "void testModsCausingHeaderOverlap(){\r\n    IonDatagram dg = values(\"[\\\"this is a string to overlap\\\"]\");\r\n    IonList v = (IonList) dg.get(0);\r\n    v.addTypeAnnotation(\"one\");\r\n    v.addTypeAnnotation(\"two\");\r\n    v.addTypeAnnotation(\"three\");\r\n    v.addTypeAnnotation(\"four\");\r\n    v.addTypeAnnotation(\"five\");\r\n    v.addTypeAnnotation(\"six\");\r\n    dg = reload(dg);\r\n    v = (IonList) dg.get(0);\r\n    checkString(\"this is a string to overlap\", v.get(0));\r\n}"
}, {
	"Path": "com.itextpdf.testutils.TestResourceUtils.openBytesAsPdf",
	"Comment": "opens the specified bytes using the pdf handler of the workstation.right now, this is implemented only for win32",
	"Method": "void openBytesAsPdf(byte[] bytes){\r\n    File f = writeStreamToTempFile(\"bytes\", new ByteArrayInputStream(bytes));\r\n    String osName = System.getProperty(\"os.name\");\r\n    if (osName.toLowerCase().indexOf(\"win\") >= 0) {\r\n        String[] params = new String[] { \"rundll32\", \"url.dll,FileProtocolHandler\", \"\\\"\" + f.getCanonicalPath() + \"\\\"\" };\r\n        Runtime.getRuntime().exec(params);\r\n        try {\r\n            Thread.sleep(500);\r\n        } catch (InterruptedException e) {\r\n        }\r\n        System.out.println(\"PDF opened for viewing by the following calls: \");\r\n        dumpCurrentStackTrace(System.out);\r\n    } else {\r\n        System.err.println(\"openBytesAsPdf not supported on platform \" + osName);\r\n    }\r\n}"
}, {
	"Path": "software.amazon.ion.impl.LocalSymbolTableImports.find",
	"Comment": "finds a symbol already interned by an import, returning the lowestknown sid.this method will not necessarily return the same instance given thesame input.",
	"Method": "SymbolToken find(String text){\r\n    for (int i = 0; i < myImports.length; i++) {\r\n        SymbolTable importedTable = myImports[i];\r\n        SymbolToken tok = importedTable.find(text);\r\n        if (tok != null) {\r\n            int sid = tok.getSid() + myBaseSids[i];\r\n            text = tok.getText();\r\n            assert text != null;\r\n            return new SymbolTokenImpl(text, sid);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.CDL.rowToString",
	"Comment": "produce a comma delimited text row from a jsonarray. values containingthe comma character will be quoted. troublesome characters may beremoved.",
	"Method": "String rowToString(JSONArray ja){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 0; i < ja.length(); i += 1) {\r\n        if (i > 0) {\r\n            sb.append(',');\r\n        }\r\n        Object object = ja.opt(i);\r\n        if (object != null) {\r\n            String string = object.toString();\r\n            if (string.length() > 0 && (string.indexOf(',') >= 0 || string.indexOf('\\n') >= 0 || string.indexOf('\\r') >= 0 || string.indexOf(0) >= 0 || string.charAt(0) == '\"')) {\r\n                sb.append('\"');\r\n                int length = string.length();\r\n                for (int j = 0; j < length; j += 1) {\r\n                    char c = string.charAt(j);\r\n                    if (c >= ' ' && c != '\"') {\r\n                        sb.append(c);\r\n                    }\r\n                }\r\n                sb.append('\"');\r\n            } else {\r\n                sb.append(string);\r\n            }\r\n        }\r\n    }\r\n    sb.append('\\n');\r\n    return sb.toString();\r\n}"
}, {
	"Path": "software.amazon.ion.IonTestCase.loadTestFile",
	"Comment": "reads the content of an ion file contained in the test data suite.",
	"Method": "IonDatagram loadTestFile(String path){\r\n    File file = getTestdataFile(path);\r\n    return load(file);\r\n}"
}, {
	"Path": "software.amazon.ion.Timestamp.addSecond",
	"Comment": "returns a timestamp relative to this one by the given number of seconds.",
	"Method": "Timestamp addSecond(int amount){\r\n    long delta = (long) amount * 1000;\r\n    return addMillis(delta);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.createJoint",
	"Comment": "create a joint to constrain bodies together. no reference to the definition is retained. thismay cause the connected bodies to cease colliding.",
	"Method": "Joint createJoint(JointDef def){\r\n    assert (isLocked() == false);\r\n    if (isLocked()) {\r\n        return null;\r\n    }\r\n    Joint j = Joint.create(this, def);\r\n    j.m_prev = null;\r\n    j.m_next = m_jointList;\r\n    if (m_jointList != null) {\r\n        m_jointList.m_prev = j;\r\n    }\r\n    m_jointList = j;\r\n    ++m_jointCount;\r\n    j.m_edgeA.joint = j;\r\n    j.m_edgeA.other = j.getBodyB();\r\n    j.m_edgeA.prev = null;\r\n    j.m_edgeA.next = j.getBodyA().m_jointList;\r\n    if (j.getBodyA().m_jointList != null) {\r\n        j.getBodyA().m_jointList.prev = j.m_edgeA;\r\n    }\r\n    j.getBodyA().m_jointList = j.m_edgeA;\r\n    j.m_edgeB.joint = j;\r\n    j.m_edgeB.other = j.getBodyA();\r\n    j.m_edgeB.prev = null;\r\n    j.m_edgeB.next = j.getBodyB().m_jointList;\r\n    if (j.getBodyB().m_jointList != null) {\r\n        j.getBodyB().m_jointList.prev = j.m_edgeB;\r\n    }\r\n    j.getBodyB().m_jointList = j.m_edgeB;\r\n    Body bodyA = def.bodyA;\r\n    Body bodyB = def.bodyB;\r\n    if (def.collideConnected == false) {\r\n        ContactEdge edge = bodyB.getContactList();\r\n        while (edge != null) {\r\n            if (edge.other == bodyA) {\r\n                edge.contact.flagForFiltering();\r\n            }\r\n            edge = edge.next;\r\n        }\r\n    }\r\n    return j;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPNormalizer.touchUpDataModel",
	"Comment": "visit all schemas to do general fixes and handle special cases.",
	"Method": "void touchUpDataModel(XMPMetaImpl xmp){\r\n    XMPNodeUtils.findSchemaNode(xmp.getRoot(), XMPConst.NS_DC, true);\r\n    for (Iterator it = xmp.getRoot().iterateChildren(); it.hasNext(); ) {\r\n        XMPNode currSchema = (XMPNode) it.next();\r\n        if (XMPConst.NS_DC.equals(currSchema.getName())) {\r\n            normalizeDCArrays(currSchema);\r\n        } else if (XMPConst.NS_EXIF.equals(currSchema.getName())) {\r\n            fixGPSTimeStamp(currSchema);\r\n            XMPNode arrayNode = XMPNodeUtils.findChildNode(currSchema, \"exif:UserComment\", false);\r\n            if (arrayNode != null) {\r\n                repairAltText(arrayNode);\r\n            }\r\n        } else if (XMPConst.NS_DM.equals(currSchema.getName())) {\r\n            XMPNode dmCopyright = XMPNodeUtils.findChildNode(currSchema, \"xmpDM:copyright\", false);\r\n            if (dmCopyright != null) {\r\n                migrateAudioCopyright(xmp, dmCopyright);\r\n            }\r\n        } else if (XMPConst.NS_XMP_RIGHTS.equals(currSchema.getName())) {\r\n            XMPNode arrayNode = XMPNodeUtils.findChildNode(currSchema, \"xmpRights:UsageTerms\", false);\r\n            if (arrayNode != null) {\r\n                repairAltText(arrayNode);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfACopy.setOutputIntents",
	"Comment": "copies the output intent dictionary from other document to this one.",
	"Method": "void setOutputIntents(String outputConditionIdentifier,String outputCondition,String registryName,String info,ICC_Profile colorProfile,boolean setOutputIntents,PdfReader reader,boolean checkExistence){\r\n    PdfDictionary catalog = reader.catalog;\r\n    PdfArray outs = catalog.getAsArray(PdfName.OUTPUTINTENTS);\r\n    if (outs == null)\r\n        return false;\r\n    if (outs.size() == 0)\r\n        return false;\r\n    PdfDictionary outa = outs.getAsDict(0);\r\n    PdfObject obj = PdfReader.getPdfObject(outa.get(PdfName.S));\r\n    if (obj == null || !PdfName.GTS_PDFA1.equals(obj))\r\n        return false;\r\n    if (checkExistence)\r\n        return true;\r\n    PRStream stream = (PRStream) PdfReader.getPdfObject(outa.get(PdfName.DESTOUTPUTPROFILE));\r\n    byte[] destProfile = null;\r\n    if (stream != null) {\r\n        destProfile = PdfReader.getStreamBytes(stream);\r\n    }\r\n    setOutputIntents(getNameString(outa, PdfName.OUTPUTCONDITIONIDENTIFIER), getNameString(outa, PdfName.OUTPUTCONDITION), getNameString(outa, PdfName.REGISTRYNAME), getNameString(outa, PdfName.INFO), destProfile);\r\n    return true;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.CrlClientOnline.getEncoded",
	"Comment": "fetches the crl bytes from an url.if no url is passed as parameter, the url will be obtained from the certificate.if you want to load a crl from a local file, subclass this method and pass anurl with the path to the local file to this method. an other option is to usethe crlclientoffline class.",
	"Method": "Collection<byte[]> getEncoded(X509Certificate checkCert,String url){\r\n    if (checkCert == null)\r\n        return null;\r\n    List<URL> urllist = new ArrayList<URL>(urls);\r\n    if (urllist.size() == 0) {\r\n        LOGGER.info(\"Looking for CRL for certificate \" + checkCert.getSubjectDN());\r\n        try {\r\n            if (url == null)\r\n                url = CertificateUtil.getCRLURL(checkCert);\r\n            if (url == null)\r\n                throw new NullPointerException();\r\n            urllist.add(new URL(url));\r\n            LOGGER.info(\"Found CRL url: \" + url);\r\n        } catch (Exception e) {\r\n            LOGGER.info(\"Skipped CRL url: \" + e.getMessage());\r\n        }\r\n    }\r\n    ArrayList<byte[]> ar = new ArrayList<byte[]>();\r\n    for (URL urlt : urllist) {\r\n        try {\r\n            LOGGER.info(\"Checking CRL: \" + urlt);\r\n            HttpURLConnection con = (HttpURLConnection) urlt.openConnection();\r\n            if (con.getResponseCode() / 100 != 2) {\r\n                throw new IOException(MessageLocalization.getComposedMessage(\"invalid.http.response.1\", con.getResponseCode()));\r\n            }\r\n            InputStream inp = (InputStream) con.getContent();\r\n            byte[] buf = new byte[1024];\r\n            ByteArrayOutputStream bout = new ByteArrayOutputStream();\r\n            while (true) {\r\n                int n = inp.read(buf, 0, buf.length);\r\n                if (n <= 0)\r\n                    break;\r\n                bout.write(buf, 0, n);\r\n            }\r\n            inp.close();\r\n            ar.add(bout.toByteArray());\r\n            LOGGER.info(\"Added CRL found at: \" + urlt);\r\n        } catch (Exception e) {\r\n            LOGGER.info(\"Skipped CRL: \" + e.getMessage() + \" for \" + urlt);\r\n        }\r\n    }\r\n    return ar;\r\n}"
}, {
	"Path": "com.example.dlp.DeIdentification.deIdentifyWithMask",
	"Comment": "deidentify a string by masking sensitive information with a character using the dlp api.",
	"Method": "void deIdentifyWithMask(String string,List<InfoType> infoTypes,Character maskingCharacter,int numberToMask,String projectId){\r\n    try (DlpServiceClient dlpServiceClient = DlpServiceClient.create()) {\r\n        ContentItem contentItem = ContentItem.newBuilder().setValue(string).build();\r\n        CharacterMaskConfig characterMaskConfig = CharacterMaskConfig.newBuilder().setMaskingCharacter(maskingCharacter.toString()).setNumberToMask(numberToMask).build();\r\n        PrimitiveTransformation primitiveTransformation = PrimitiveTransformation.newBuilder().setCharacterMaskConfig(characterMaskConfig).build();\r\n        InfoTypeTransformation infoTypeTransformationObject = InfoTypeTransformation.newBuilder().setPrimitiveTransformation(primitiveTransformation).build();\r\n        InfoTypeTransformations infoTypeTransformationArray = InfoTypeTransformations.newBuilder().addTransformations(infoTypeTransformationObject).build();\r\n        InspectConfig inspectConfig = InspectConfig.newBuilder().addAllInfoTypes(infoTypes).build();\r\n        DeidentifyConfig deidentifyConfig = DeidentifyConfig.newBuilder().setInfoTypeTransformations(infoTypeTransformationArray).build();\r\n        DeidentifyContentRequest request = DeidentifyContentRequest.newBuilder().setParent(ProjectName.of(projectId).toString()).setInspectConfig(inspectConfig).setDeidentifyConfig(deidentifyConfig).setItem(contentItem).build();\r\n        DeidentifyContentResponse response = dlpServiceClient.deidentifyContent(request);\r\n        String result = response.getItem().getValue();\r\n        System.out.println(result);\r\n    } catch (Exception e) {\r\n        System.out.println(\"Error in deidentifyWithMask: \" + e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.ColumnText.go",
	"Comment": "outputs the lines to the document. the output can be simulated.",
	"Method": "int go(int go,boolean simulate,int go,boolean simulate,IAccessibleElement elementToGo){\r\n    isWordSplit = false;\r\n    if (composite) {\r\n        return goComposite(simulate);\r\n    }\r\n    ListBody lBody = null;\r\n    if (isTagged(canvas) && elementToGo instanceof ListItem) {\r\n        lBody = ((ListItem) elementToGo).getListBody();\r\n    }\r\n    addWaitingPhrase();\r\n    if (bidiLine == null) {\r\n        return NO_MORE_TEXT;\r\n    }\r\n    descender = 0;\r\n    linesWritten = 0;\r\n    lastX = 0;\r\n    boolean dirty = false;\r\n    float ratio = spaceCharRatio;\r\n    Object[] currentValues = new Object[2];\r\n    PdfFont currentFont = null;\r\n    Float lastBaseFactor = new Float(0);\r\n    currentValues[1] = lastBaseFactor;\r\n    PdfDocument pdf = null;\r\n    PdfContentByte graphics = null;\r\n    PdfContentByte text = null;\r\n    firstLineY = Float.NaN;\r\n    int localRunDirection = runDirection;\r\n    if (canvas != null) {\r\n        graphics = canvas;\r\n        pdf = canvas.getPdfDocument();\r\n        if (!isTagged(canvas)) {\r\n            text = canvas.getDuplicate(inheritGraphicState);\r\n        } else {\r\n            text = canvas;\r\n        }\r\n    } else if (!simulate) {\r\n        throw new NullPointerException(MessageLocalization.getComposedMessage(\"columntext.go.with.simulate.eq.eq.false.and.text.eq.eq.null\"));\r\n    }\r\n    if (!simulate) {\r\n        if (ratio == GLOBAL_SPACE_CHAR_RATIO) {\r\n            ratio = text.getPdfWriter().getSpaceCharRatio();\r\n        } else if (ratio < 0.001f) {\r\n            ratio = 0.001f;\r\n        }\r\n    }\r\n    if (!rectangularMode) {\r\n        float max = 0;\r\n        for (PdfChunk c : bidiLine.chunks) {\r\n            max = Math.max(max, c.height());\r\n        }\r\n        currentLeading = fixedLeading + max * multipliedLeading;\r\n    }\r\n    float firstIndent = 0;\r\n    PdfLine line;\r\n    float x1;\r\n    int status = 0;\r\n    boolean rtl = false;\r\n    while (true) {\r\n        firstIndent = lastWasNewline ? indent : followingIndent;\r\n        if (rectangularMode) {\r\n            if (rectangularWidth <= firstIndent + rightIndent) {\r\n                status = NO_MORE_COLUMN;\r\n                if (bidiLine.isEmpty()) {\r\n                    status |= NO_MORE_TEXT;\r\n                }\r\n                break;\r\n            }\r\n            if (bidiLine.isEmpty()) {\r\n                status = NO_MORE_TEXT;\r\n                break;\r\n            }\r\n            line = bidiLine.processLine(leftX, rectangularWidth - firstIndent - rightIndent, alignment, localRunDirection, arabicOptions, minY, yLine, descender);\r\n            isWordSplit |= bidiLine.isWordSplit();\r\n            if (line == null) {\r\n                status = NO_MORE_TEXT;\r\n                break;\r\n            }\r\n            float[] maxSize = line.getMaxSize(fixedLeading, multipliedLeading);\r\n            if (isUseAscender() && Float.isNaN(firstLineY)) {\r\n                currentLeading = line.getAscender();\r\n            } else {\r\n                currentLeading = Math.max(maxSize[0], maxSize[1] - descender);\r\n            }\r\n            if (yLine > maxY || yLine - currentLeading < minY) {\r\n                status = NO_MORE_COLUMN;\r\n                bidiLine.restore();\r\n                break;\r\n            }\r\n            yLine -= currentLeading;\r\n            if (!simulate && !dirty) {\r\n                if (line.isRTL && canvas.isTagged()) {\r\n                    canvas.beginMarkedContentSequence(PdfName.REVERSEDCHARS);\r\n                    rtl = true;\r\n                }\r\n                text.beginText();\r\n                dirty = true;\r\n            }\r\n            if (Float.isNaN(firstLineY)) {\r\n                firstLineY = yLine;\r\n            }\r\n            updateFilledWidth(rectangularWidth - line.widthLeft());\r\n            x1 = leftX;\r\n        } else {\r\n            float yTemp = yLine - currentLeading;\r\n            float[] xx = findLimitsTwoLines();\r\n            if (xx == null) {\r\n                status = NO_MORE_COLUMN;\r\n                if (bidiLine.isEmpty()) {\r\n                    status |= NO_MORE_TEXT;\r\n                }\r\n                yLine = yTemp;\r\n                break;\r\n            }\r\n            if (bidiLine.isEmpty()) {\r\n                status = NO_MORE_TEXT;\r\n                yLine = yTemp;\r\n                break;\r\n            }\r\n            x1 = Math.max(xx[0], xx[2]);\r\n            float x2 = Math.min(xx[1], xx[3]);\r\n            if (x2 - x1 <= firstIndent + rightIndent) {\r\n                continue;\r\n            }\r\n            line = bidiLine.processLine(x1, x2 - x1 - firstIndent - rightIndent, alignment, localRunDirection, arabicOptions, minY, yLine, descender);\r\n            if (!simulate && !dirty) {\r\n                if (line.isRTL && canvas.isTagged()) {\r\n                    canvas.beginMarkedContentSequence(PdfName.REVERSEDCHARS);\r\n                    rtl = true;\r\n                }\r\n                text.beginText();\r\n                dirty = true;\r\n            }\r\n            if (line == null) {\r\n                status = NO_MORE_TEXT;\r\n                yLine = yTemp;\r\n                break;\r\n            }\r\n        }\r\n        if (isTagged(canvas) && elementToGo instanceof ListItem) {\r\n            if (!Float.isNaN(firstLineY) && !firstLineYDone) {\r\n                if (!simulate) {\r\n                    ListLabel lbl = ((ListItem) elementToGo).getListLabel();\r\n                    canvas.openMCBlock(lbl);\r\n                    Chunk symbol = new Chunk(((ListItem) elementToGo).getListSymbol());\r\n                    symbol.setRole(null);\r\n                    ColumnText.showTextAligned(canvas, Element.ALIGN_LEFT, new Phrase(symbol), leftX + lbl.getIndentation(), firstLineY, 0);\r\n                    canvas.closeMCBlock(lbl);\r\n                }\r\n                firstLineYDone = true;\r\n            }\r\n        }\r\n        if (!simulate) {\r\n            if (lBody != null) {\r\n                canvas.openMCBlock(lBody);\r\n                lBody = null;\r\n            }\r\n            currentValues[0] = currentFont;\r\n            text.setTextMatrix(x1 + (line.isRTL() ? rightIndent : firstIndent) + line.indentLeft(), yLine);\r\n            lastX = pdf.writeLineToContent(line, text, graphics, currentValues, ratio);\r\n            currentFont = (PdfFont) currentValues[0];\r\n        }\r\n        lastWasNewline = repeatFirstLineIndent && line.isNewlineSplit();\r\n        yLine -= line.isNewlineSplit() ? extraParagraphSpace : 0;\r\n        ++linesWritten;\r\n        descender = line.getDescender();\r\n    }\r\n    if (dirty) {\r\n        text.endText();\r\n        if (canvas != text) {\r\n            canvas.add(text);\r\n        }\r\n        if (rtl && canvas.isTagged()) {\r\n            canvas.endMarkedContentSequence();\r\n        }\r\n    }\r\n    return status;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.zip.Keep.compact",
	"Comment": "compact the keep. a keep may contain at most this.capacity elements.the keep contents can be reduced by deleting all elements with low usecounts, and by reducing the use counts of the survivors.",
	"Method": "void compact(){\r\n    int from = 0;\r\n    int to = 0;\r\n    while (from < this.capacity) {\r\n        Object key = this.list[from];\r\n        long usage = age(this.ticks[from]);\r\n        if (usage > 0) {\r\n            this.ticks[to] = usage;\r\n            this.list[to] = key;\r\n            this.map.put(key, to);\r\n            to += 1;\r\n        } else {\r\n            this.map.remove(key);\r\n        }\r\n        from += 1;\r\n    }\r\n    if (to < this.capacity) {\r\n        this.length = to;\r\n    } else {\r\n        this.map.clear();\r\n        this.length = 0;\r\n    }\r\n    this.power = 0;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.CDL.toString",
	"Comment": "produce a comma delimited text from a jsonarray of jsonobjects usinga provided list of names. the list of names is not included in theoutput.",
	"Method": "String toString(JSONArray ja,String toString,JSONArray names,JSONArray ja){\r\n    if (names == null || names.length() == 0) {\r\n        return null;\r\n    }\r\n    StringBuffer sb = new StringBuffer();\r\n    for (int i = 0; i < ja.length(); i += 1) {\r\n        JSONObject jo = ja.optJSONObject(i);\r\n        if (jo != null) {\r\n            sb.append(rowToString(jo.toJSONArray(names)));\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "software.amazon.ion.impl.lite.IonValueLite.validateThisNotNull",
	"Comment": "ensures that this value is not an ion null.used as a helper formethods that have that precondition.",
	"Method": "void validateThisNotNull(){\r\n    if (_isNullValue()) {\r\n        throw new NullValueException();\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.testbed.framework.TestbedModel.getCodedKeys",
	"Comment": "gets the array of coded keys, index corresponding to the coded key value.",
	"Method": "boolean[] getCodedKeys(){\r\n    return codedKeys;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.CDL.rowToJSONArray",
	"Comment": "produce a jsonarray of strings from a row of comma delimited values.",
	"Method": "JSONArray rowToJSONArray(JSONTokener x){\r\n    JSONArray ja = new JSONArray();\r\n    for (; ; ) {\r\n        String value = getValue(x);\r\n        char c = x.next();\r\n        if (value == null || (ja.length() == 0 && value.length() == 0 && c != ',')) {\r\n            return null;\r\n        }\r\n        ja.put(value);\r\n        for (; ; ) {\r\n            if (c == ',') {\r\n                break;\r\n            }\r\n            if (c != ' ') {\r\n                if (c == '\\n' || c == '\\r' || c == 0) {\r\n                    return ja;\r\n                }\r\n                throw x.syntaxError(\"Bad character '\" + c + \"' (\" + (int) c + \").\");\r\n            }\r\n            c = x.next();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.contacts.Contact.flagForFiltering",
	"Comment": "flag this contact for filtering. filtering will occur the next time step.",
	"Method": "void flagForFiltering(){\r\n    m_flags |= FILTER_FLAG;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfObject.toPdf",
	"Comment": "writes the pdf representation of this pdfobject as anarray of bytes to the writer.",
	"Method": "void toPdf(PdfWriter writer,OutputStream os){\r\n    if (bytes != null) {\r\n        PdfWriter.checkPdfIsoConformance(writer, PdfIsoKeys.PDFISOKEY_OBJECT, this);\r\n        os.write(bytes);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.codec.TIFFDirectory.getIFDOffset",
	"Comment": "returns the offset of the ifd corresponding to thistiffdirectory.",
	"Method": "long getIFDOffset(){\r\n    return IFDOffset;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfArray.getPdfObject",
	"Comment": "returns the pdfobject with the specified index.a possible indirect references is not resolved, so the returnedpdfobject may be either a direct object or an indirectreference, depending on how the object is stored in thepdfarray.",
	"Method": "PdfObject getPdfObject(int idx){\r\n    return arrayList.get(idx);\r\n}"
}, {
	"Path": "com.itextpdf.awt.geom.gl.Crossing.intersectCubic",
	"Comment": "returns how many times rectangle stripe cross cubic curve or the are intersect",
	"Method": "int intersectCubic(double x1,double y1,double cx1,double cy1,double cx2,double cy2,double x2,double y2,double rx1,double ry1,double rx2,double ry2){\r\n    if ((rx2 < x1 && rx2 < cx1 && rx2 < cx2 && rx2 < x2) || (rx1 > x1 && rx1 > cx1 && rx1 > cx2 && rx1 > x2) || (ry1 > y1 && ry1 > cy1 && ry1 > cy2 && ry1 > y2)) {\r\n        return 0;\r\n    }\r\n    if (ry2 < y1 && ry2 < cy1 && ry2 < cy2 && ry2 < y2 && rx1 != x1 && rx1 != x2) {\r\n        if (x1 < x2) {\r\n            return x1 < rx1 && rx1 < x2 ? 1 : 0;\r\n        }\r\n        return x2 < rx1 && rx1 < x1 ? -1 : 0;\r\n    }\r\n    CubicCurve c = new CubicCurve(x1, y1, cx1, cy1, cx2, cy2, x2, y2);\r\n    double px1 = rx1 - x1;\r\n    double py1 = ry1 - y1;\r\n    double px2 = rx2 - x1;\r\n    double py2 = ry2 - y1;\r\n    double[] res1 = new double[3];\r\n    double[] res2 = new double[3];\r\n    int rc1 = c.solvePoint(res1, px1);\r\n    int rc2 = c.solvePoint(res2, px2);\r\n    if (rc1 == 0 && rc2 == 0) {\r\n        return 0;\r\n    }\r\n    double minX = px1 - DELTA;\r\n    double maxX = px2 + DELTA;\r\n    double[] bound = new double[40];\r\n    int bc = 0;\r\n    bc = c.addBound(bound, bc, res1, rc1, minX, maxX, false, 0);\r\n    bc = c.addBound(bound, bc, res2, rc2, minX, maxX, false, 1);\r\n    rc2 = c.solveExtremX(res2);\r\n    bc = c.addBound(bound, bc, res2, rc2, minX, maxX, true, 2);\r\n    rc2 = c.solveExtremY(res2);\r\n    bc = c.addBound(bound, bc, res2, rc2, minX, maxX, true, 4);\r\n    if (rx1 < x1 && x1 < rx2) {\r\n        bound[bc++] = 0.0;\r\n        bound[bc++] = 0.0;\r\n        bound[bc++] = 0.0;\r\n        bound[bc++] = 6;\r\n    }\r\n    if (rx1 < x2 && x2 < rx2) {\r\n        bound[bc++] = 1.0;\r\n        bound[bc++] = c.ax;\r\n        bound[bc++] = c.ay;\r\n        bound[bc++] = 7;\r\n    }\r\n    int cross = crossBound(bound, bc, py1, py2);\r\n    if (cross != UNKNOWN) {\r\n        return cross;\r\n    }\r\n    return c.cross(res1, rc1, py1, py2);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.getAscentPoint",
	"Comment": "gets the ascent of a string in points. the ascent will always begreater than or equal to zero even if all the characters have a lower ascent.",
	"Method": "float getAscentPoint(String text,float fontSize){\r\n    return getAscent(text) * 0.001f * fontSize;\r\n}"
}, {
	"Path": "com.itextpdf.text.Rectangle.setRotation",
	"Comment": "sets the rotation of the rectangle. valid values are 0, 90, 180, and 270.",
	"Method": "void setRotation(int rotation){\r\n    this.rotation = rotation % 360;\r\n    switch(this.rotation) {\r\n        case 90:\r\n        case 180:\r\n        case 270:\r\n            break;\r\n        default:\r\n            this.rotation = 0;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.FdfReader.getFields",
	"Comment": "gets all the fields. the map is keyed by the fully qualifiedfield name and the value is a merged pdfdictionarywith the field content.",
	"Method": "HashMap<String, PdfDictionary> getFields(){\r\n    return fields;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONObject.optString",
	"Comment": "get an optional string associated with a key. it returns the defaultvalueif there is no such key.",
	"Method": "String optString(String key,String optString,String key,String defaultValue){\r\n    Object object = this.opt(key);\r\n    return NULL.equals(object) ? defaultValue : object.toString();\r\n}"
}, {
	"Path": "org.jbox2d.callbacks.DebugDraw.getWorldToScreen",
	"Comment": "takes the world coordinates and returns the screen coordinates.",
	"Method": "Vec2 getWorldToScreen(Vec2 argWorld,Vec2 getWorldToScreen,float worldX,float worldY){\r\n    Vec2 argScreen = new Vec2(worldX, worldY);\r\n    viewportTransform.getWorldToScreen(argScreen, argScreen);\r\n    return argScreen;\r\n}"
}, {
	"Path": "software.amazon.ion.system.SimpleCatalog.iterator",
	"Comment": "constructs an iterator that enumerates all of the shared symbol tablesin this catalog, at the time of method invocation. the result representsa snapshot of the state of this catalog.",
	"Method": "Iterator<SymbolTable> iterator(){\r\n    ArrayList<SymbolTable> tables;\r\n    synchronized (myTablesByName) {\r\n        tables = new ArrayList<SymbolTable>(myTablesByName.size());\r\n        Collection<TreeMap<Integer, SymbolTable>> symtabNames = myTablesByName.values();\r\n        for (TreeMap<Integer, SymbolTable> versions : symtabNames) {\r\n            synchronized (versions) {\r\n                tables.addAll(versions.values());\r\n            }\r\n        }\r\n    }\r\n    return tables.iterator();\r\n}"
}, {
	"Path": "com.itextpdf.text.Section.getTitle",
	"Comment": "returns the title, preceded by a certain number of sectionnumbers.",
	"Method": "Paragraph getTitle(){\r\n    return constructTitle(title, numbers, numberDepth, numberStyle);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.mc.StructureMCID.checkMCID",
	"Comment": "checks if the mcid in this object corresponds with the stored number",
	"Method": "int checkMCID(int pg,int mcid){\r\n    if (pageref == -1)\r\n        throw new RuntimeException();\r\n    if (pg == pageref && this.mcid == mcid)\r\n        return 1;\r\n    return -1;\r\n}"
}, {
	"Path": "com.sixt.service.framework.MethodHandlerDictionary.addPreHook",
	"Comment": "add a hook to inspect or modify incoming requests.invoked in the same order as configured at runtime",
	"Method": "void addPreHook(String endpoint,ServiceMethodPreHook<? extends Message> handlerClass){\r\n    if (GLOBAL.equals(endpoint)) {\r\n        globalPreHooks.add(handlerClass);\r\n    } else {\r\n        List<ServiceMethodPreHook<? extends Message>> hooks = methodPreHooks.get(endpoint);\r\n        if (hooks == null) {\r\n            hooks = new ArrayList();\r\n            methodPreHooks.put(endpoint, hooks);\r\n        }\r\n        hooks.add(handlerClass);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.spatial.MeasureRectilinear.setScaleRatio",
	"Comment": "a text string expressing the scale ratio of the drawing in the region\tcorresponding to this dictionary. universally recognized unit\tabbreviations should be used, either matching those of the number format\tarrays in this dictionary or those of commonly used scale ratios.\tif the scale ratio differs in the x and y directions, both scales should\tbe specified.",
	"Method": "void setScaleRatio(PdfString scaleratio){\r\n    put(new PdfName(\"R\"), scaleratio);\r\n}"
}, {
	"Path": "org.jbox2d.testbed.framework.TestbedModel.getKeys",
	"Comment": "gets the array of keys, index corresponding to the char value.",
	"Method": "boolean[] getKeys(){\r\n    return keys;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStamper.getImportedPage",
	"Comment": "gets a page from other pdf document. note that calling this method more thanonce with the same parameters will retrieve the same object.",
	"Method": "PdfImportedPage getImportedPage(PdfReader reader,int pageNumber){\r\n    return stamper.getImportedPage(reader, pageNumber);\r\n}"
}, {
	"Path": "com.structurizr.view.ViewSet.getViewWithKey",
	"Comment": "finds the view with the specified key, or null if the view does not exist.",
	"Method": "View getViewWithKey(String key){\r\n    if (key == null) {\r\n        throw new IllegalArgumentException(\"A key must be specified.\");\r\n    }\r\n    Set<View> views = new HashSet();\r\n    views.addAll(systemLandscapeViews);\r\n    views.addAll(systemContextViews);\r\n    views.addAll(containerViews);\r\n    views.addAll(componentViews);\r\n    views.addAll(dynamicViews);\r\n    views.addAll(deploymentViews);\r\n    return views.stream().filter(v -> key.equals(v.getKey())).findFirst().orElse(null);\r\n}"
}, {
	"Path": "software.amazon.ion.Timestamp.make_localtime",
	"Comment": "applies the local offset from utc to each of the applicable time fieldvalues and returns the new timestamp. in short, this makes the timestamprepresent local time.",
	"Method": "Timestamp make_localtime(){\r\n    int offset = _offset != null ? _offset.intValue() : 0;\r\n    Timestamp localtime = new Timestamp(_precision, _year, _month, _day, _hour, _minute, _second, _fraction, _offset, APPLY_OFFSET_NO);\r\n    localtime.apply_offset(-offset);\r\n    assert localtime._offset == _offset;\r\n    return localtime;\r\n}"
}, {
	"Path": "com.itextpdf.text.html.simpleparser.ElementFactory.createListItem",
	"Comment": "creates an itext paragraph object using the properties\tof the different tags and properties in the hierarchy chain.",
	"Method": "ListItem createListItem(ChainedProperties chain){\r\n    ListItem item = new ListItem();\r\n    updateElement(item, chain);\r\n    return item;\r\n}"
}, {
	"Path": "com.example.Snippets.addMemberToKeyRingPolicy",
	"Comment": "adds the given member to the given keyring, with the given role.",
	"Method": "Policy addMemberToKeyRingPolicy(String projectId,String locationId,String keyRingId,String member,String role){\r\n    CloudKMS kms = createAuthorizedClient();\r\n    String keyring = String.format(\"projects/%s/locations/%s/keyRings/%s\", projectId, locationId, keyRingId);\r\n    Policy iamPolicy = getKeyRingPolicy(projectId, locationId, keyRingId);\r\n    Binding newBinding = new Binding().setRole(role).setMembers(Collections.singletonList(member));\r\n    List<Binding> bindings = iamPolicy.getBindings();\r\n    if (null == bindings) {\r\n        bindings = Collections.singletonList(newBinding);\r\n    } else {\r\n        bindings.add(newBinding);\r\n    }\r\n    iamPolicy.setBindings(bindings);\r\n    Policy newIamPolicy = kms.projects().locations().keyRings().setIamPolicy(keyring, new SetIamPolicyRequest().setPolicy(iamPolicy)).execute();\r\n    System.out.println(\"Response: \" + newIamPolicy);\r\n    return newIamPolicy;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BarcodePDF417.getOutBits",
	"Comment": "gets the raw image bits of the barcode. the image will have tobe scaled in the y direction by yheight.",
	"Method": "byte[] getOutBits(){\r\n    return this.outBits;\r\n}"
}, {
	"Path": "com.itextpdf.text.Image.getCompressionLevel",
	"Comment": "returns the compression level used for images written as a compressed stream.",
	"Method": "int getCompressionLevel(){\r\n    return compressionLevel;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.TrueTypeFontUnicode.getToUnicode",
	"Comment": "creates a tounicode cmap to allow copy and paste from acrobat.",
	"Method": "PdfStream getToUnicode(Object metrics){\r\n    if (metrics.length == 0)\r\n        return null;\r\n    StringBuffer buf = new StringBuffer(\"/CIDInit /ProcSet findresource begin\\n\" + \"12 dict begin\\n\" + \"begincmap\\n\" + \"/CIDSystemInfo\\n\" + \"<< /Registry (TTX+0)\\n\" + \"/Ordering (T42UV)\\n\" + \"/Supplement 0\\n\" + \">> def\\n\" + \"/CMapName /TTX+0 def\\n\" + \"/CMapType 2 def\\n\" + \"1 begincodespacerange\\n\" + \"<0000><FFFF>\\n\" + \"endcodespacerange\\n\");\r\n    int size = 0;\r\n    for (int k = 0; k < metrics.length; ++k) {\r\n        if (size == 0) {\r\n            if (k != 0) {\r\n                buf.append(\"endbfrange\\n\");\r\n            }\r\n            size = Math.min(100, metrics.length - k);\r\n            buf.append(size).append(\" beginbfrange\\n\");\r\n        }\r\n        --size;\r\n        int[] metric = (int[]) metrics[k];\r\n        String fromTo = toHex(metric[0]);\r\n        buf.append(fromTo).append(fromTo).append(toHex(metric[2])).append('\\n');\r\n    }\r\n    buf.append(\"endbfrange\\n\" + \"endcmap\\n\" + \"CMapName currentdict /CMap defineresource pop\\n\" + \"end end\\n\");\r\n    String s = buf.toString();\r\n    PdfStream stream = new PdfStream(PdfEncodings.convertToBytes(s, null));\r\n    stream.flateCompress(compressionLevel);\r\n    return stream;\r\n}"
}, {
	"Path": "com.structurizr.model.ContainerInstance.getContainerId",
	"Comment": "gets the id of the container that this object represents a deployment instance of.",
	"Method": "String getContainerId(){\r\n    if (container != null) {\r\n        return container.getId();\r\n    } else {\r\n        return containerId;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Barcode128.isNextDigits",
	"Comment": "returns true if the next numdigitsstarting from index textindex are numeric skipping any fnc1.",
	"Method": "boolean isNextDigits(String text,int textIndex,int numDigits){\r\n    int len = text.length();\r\n    while (textIndex < len && numDigits > 0) {\r\n        if (text.charAt(textIndex) == FNC1) {\r\n            ++textIndex;\r\n            continue;\r\n        }\r\n        int n = Math.min(2, numDigits);\r\n        if (textIndex + n > len)\r\n            return false;\r\n        while (n-- > 0) {\r\n            char c = text.charAt(textIndex++);\r\n            if (c < '0' || c > '9')\r\n                return false;\r\n            --numDigits;\r\n        }\r\n    }\r\n    return numDigits == 0;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.ColumnText.fitText",
	"Comment": "fits the text to some rectangle adjusting the font size as needed.",
	"Method": "float fitText(Font font,String text,Rectangle rect,float maxFontSize,int runDirection){\r\n    try {\r\n        ColumnText ct = null;\r\n        int status = 0;\r\n        if (maxFontSize <= 0) {\r\n            int cr = 0;\r\n            int lf = 0;\r\n            char[] t = text.toCharArray();\r\n            for (int k = 0; k < t.length; ++k) {\r\n                if (t[k] == '\\n') {\r\n                    ++lf;\r\n                } else if (t[k] == '\\r') {\r\n                    ++cr;\r\n                }\r\n            }\r\n            int minLines = Math.max(cr, lf) + 1;\r\n            maxFontSize = Math.abs(rect.getHeight()) / minLines - 0.001f;\r\n        }\r\n        font.setSize(maxFontSize);\r\n        Phrase ph = new Phrase(text, font);\r\n        ct = new ColumnText(null);\r\n        ct.setSimpleColumn(ph, rect.getLeft(), rect.getBottom(), rect.getRight(), rect.getTop(), maxFontSize, Element.ALIGN_LEFT);\r\n        ct.setRunDirection(runDirection);\r\n        status = ct.go(true);\r\n        if ((status & NO_MORE_TEXT) != 0) {\r\n            return maxFontSize;\r\n        }\r\n        float precision = 0.1f;\r\n        float min = 0;\r\n        float max = maxFontSize;\r\n        float size = maxFontSize;\r\n        for (int k = 0; k < 50; ++k) {\r\n            size = (min + max) / 2;\r\n            ct = new ColumnText(null);\r\n            font.setSize(size);\r\n            ct.setSimpleColumn(new Phrase(text, font), rect.getLeft(), rect.getBottom(), rect.getRight(), rect.getTop(), size, Element.ALIGN_LEFT);\r\n            ct.setRunDirection(runDirection);\r\n            status = ct.go(true);\r\n            if ((status & NO_MORE_TEXT) != 0) {\r\n                if (max - min < size * precision) {\r\n                    return size;\r\n                }\r\n                min = size;\r\n            } else {\r\n                max = size;\r\n            }\r\n        }\r\n        return size;\r\n    } catch (Exception e) {\r\n        throw new ExceptionConverter(e);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.StampContent.getDuplicate",
	"Comment": "gets a duplicate of this pdfcontentbyte. allthe members are copied by reference but the buffer stays different.",
	"Method": "PdfContentByte getDuplicate(){\r\n    return new StampContent((PdfStamperImp) writer, ps);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.getStreamBytesRaw",
	"Comment": "get the content from a stream as it is without applying any filter.",
	"Method": "byte[] getStreamBytesRaw(PRStream stream,RandomAccessFileOrArray file,byte[] getStreamBytesRaw,PRStream stream){\r\n    RandomAccessFileOrArray rf = stream.getReader().getSafeFile();\r\n    try {\r\n        rf.reOpen();\r\n        return getStreamBytesRaw(stream, rf);\r\n    } finally {\r\n        try {\r\n            rf.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.FontFactoryImp.registerDirectories",
	"Comment": "register fonts in some probable directories. it usually works in windows,linux and solaris.",
	"Method": "int registerDirectories(){\r\n    int count = 0;\r\n    String windir = System.getenv(\"windir\");\r\n    String fileseparator = System.getProperty(\"file.separator\");\r\n    if (windir != null && fileseparator != null) {\r\n        count += registerDirectory(windir + fileseparator + \"fonts\");\r\n    }\r\n    count += registerDirectory(\"/usr/share/X11/fonts\", true);\r\n    count += registerDirectory(\"/usr/X/lib/X11/fonts\", true);\r\n    count += registerDirectory(\"/usr/openwin/lib/X11/fonts\", true);\r\n    count += registerDirectory(\"/usr/share/fonts\", true);\r\n    count += registerDirectory(\"/usr/X11R6/lib/X11/fonts\", true);\r\n    count += registerDirectory(\"/Library/Fonts\");\r\n    count += registerDirectory(\"/System/Library/Fonts\");\r\n    return count;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.FontDetails.isSubset",
	"Comment": "indicates if all the glyphs and widths for that particularencoding should be included in the document.",
	"Method": "boolean isSubset(){\r\n    return subset;\r\n}"
}, {
	"Path": "com.structurizr.analysis.AbstractSpringComponentFinderStrategy.setIncludePublicTypesOnly",
	"Comment": "sets whether this component finder strategy only finds components that are based upon public types.",
	"Method": "void setIncludePublicTypesOnly(boolean includePublicTypesOnly){\r\n    this.includePublicTypesOnly = includePublicTypesOnly;\r\n}"
}, {
	"Path": "com.example.texttospeech.SynthesizeText.synthesizeTextWithAudioProfile",
	"Comment": "demonstrates using the text to speech client with audio profiles to synthesize text or ssml",
	"Method": "void synthesizeTextWithAudioProfile(String text,String effectsProfile){\r\n    try (TextToSpeechClient textToSpeechClient = TextToSpeechClient.create()) {\r\n        SynthesisInput input = SynthesisInput.newBuilder().setText(text).build();\r\n        VoiceSelectionParams voice = // languageCode = \"en_us\"\r\n        VoiceSelectionParams.newBuilder().setLanguageCode(// ssmlVoiceGender = SsmlVoiceGender.FEMALE\r\n        \"en-US\").setSsmlGender(SsmlVoiceGender.FEMALE).build();\r\n        AudioConfig audioConfig = // MP3 audio.\r\n        AudioConfig.newBuilder().setAudioEncoding(// audio profile\r\n        AudioEncoding.MP3).addEffectsProfileId(effectsProfile).build();\r\n        SynthesizeSpeechResponse response = textToSpeechClient.synthesizeSpeech(input, voice, audioConfig);\r\n        ByteString audioContents = response.getAudioContent();\r\n        try (OutputStream out = new FileOutputStream(\"output.mp3\")) {\r\n            out.write(audioContents.toByteArray());\r\n            System.out.println(\"Audio content written to file \\\"output.mp3\\\"\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.SignaturePermissions.isCertification",
	"Comment": "getter to find out if the signature is a certification signature.",
	"Method": "boolean isCertification(){\r\n    return certification;\r\n}"
}, {
	"Path": "com.structurizr.model.DeploymentNode.getContainerInstances",
	"Comment": "gets the set of container instances associated with this deployment node.",
	"Method": "Set<ContainerInstance> getContainerInstances(){\r\n    return new HashSet(containerInstances);\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.html.AbstractTagProcessor.getHtmlPipelineContext",
	"Comment": "utility method that fetches the htmlpipelinecontext used if any and if it\tuses the default key.",
	"Method": "HtmlPipelineContext getHtmlPipelineContext(WorkerContext context){\r\n    return ((HtmlPipelineContext) context.get(HtmlPipeline.class.getName()));\r\n}"
}, {
	"Path": "com.itextpdf.text.ListItem.adjustListSymbolFont",
	"Comment": "changes the font of the list symbol to the font of the first chunkin the list item.",
	"Method": "void adjustListSymbolFont(){\r\n    java.util.List<Chunk> cks = getChunks();\r\n    if (!cks.isEmpty() && symbol != null)\r\n        symbol.setFont(cks.get(0).getFont());\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.events.PdfPageEventForwarder.onChapter",
	"Comment": "called when a chapter is written.\tposition will hold the height at which the chapter will be\twritten to.",
	"Method": "void onChapter(PdfWriter writer,Document document,float paragraphPosition,Paragraph title){\r\n    for (PdfPageEvent event : events) {\r\n        event.onChapter(writer, document, paragraphPosition, title);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.FontFactoryImp.registerDirectory",
	"Comment": "register all the fonts in a directory and possibly its subdirectories.",
	"Method": "int registerDirectory(String dir,int registerDirectory,String dir,boolean scanSubdirectories){\r\n    if (LOGGER.isLogging(Level.DEBUG)) {\r\n        LOGGER.debug(String.format(\"Registering directory %s, looking for fonts\", dir));\r\n    }\r\n    int count = 0;\r\n    try {\r\n        File file = new File(dir);\r\n        if (!file.exists() || !file.isDirectory())\r\n            return 0;\r\n        String[] files = file.list();\r\n        if (files == null)\r\n            return 0;\r\n        for (int k = 0; k < files.length; ++k) {\r\n            try {\r\n                file = new File(dir, files[k]);\r\n                if (file.isDirectory()) {\r\n                    if (scanSubdirectories) {\r\n                        count += registerDirectory(file.getAbsolutePath(), true);\r\n                    }\r\n                } else {\r\n                    String name = file.getPath();\r\n                    String suffix = name.length() < 4 ? null : name.substring(name.length() - 4).toLowerCase();\r\n                    if (\".afm\".equals(suffix) || \".pfm\".equals(suffix)) {\r\n                        File pfb = new File(name.substring(0, name.length() - 4) + \".pfb\");\r\n                        if (pfb.exists()) {\r\n                            register(name, null);\r\n                            ++count;\r\n                        }\r\n                    } else if (\".ttf\".equals(suffix) || \".otf\".equals(suffix) || \".ttc\".equals(suffix)) {\r\n                        register(name, null);\r\n                        ++count;\r\n                    }\r\n                }\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    return new AbstractSymbolTable(name, version) {\r\n        public Iterator<String> iterateDeclaredSymbolNames() {\r\n            return new Iterator<String>() {\r\n                int id = 1;\r\n                public boolean hasNext() {\r\n                    return id <= maxId;\r\n                }\r\n                public String next() {\r\n                    if (!hasNext()) {\r\n                        throw new NoSuchElementException();\r\n                    }\r\n                    id++;\r\n                    return null;\r\n                }\r\n                public void remove() {\r\n                    throw new UnsupportedOperationException();\r\n                }\r\n            };\r\n        }\r\n        public boolean isSystemTable() {\r\n            return false;\r\n        }\r\n        public boolean isSubstitute() {\r\n            return true;\r\n        }\r\n        public boolean isSharedTable() {\r\n            return true;\r\n        }\r\n        public boolean isReadOnly() {\r\n            return true;\r\n        }\r\n        public boolean isLocalTable() {\r\n            return false;\r\n        }\r\n        public SymbolToken intern(String text) {\r\n            throw new UnsupportedOperationException(\"Cannot intern into substitute unknown shared symbol table: \" + name + \" version \" + version);\r\n        }\r\n        public SymbolTable getSystemSymbolTable() {\r\n            return systemSymbolTable();\r\n        }\r\n        public int getMaxId() {\r\n            return maxId;\r\n        }\r\n        public SymbolTable[] getImportedTables() {\r\n            return null;\r\n        }\r\n        public int getImportedMaxId() {\r\n            return 0;\r\n        }\r\n        public String findKnownSymbol(int id) {\r\n            return null;\r\n        }\r\n        public SymbolToken find(String text) {\r\n            return null;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    return new Iterator<String>() {\r\n        int id = 1;\r\n        public boolean hasNext() {\r\n            return id <= maxId;\r\n        }\r\n        public String next() {\r\n            if (!hasNext()) {\r\n                throw new NoSuchElementException();\r\n            }\r\n            id++;\r\n            return null;\r\n        }\r\n        public void remove() {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    return id <= maxId;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    if (!hasNext()) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    id++;\r\n    return null;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    return false;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    return true;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    return true;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    return true;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    return false;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    throw new UnsupportedOperationException(\"Cannot intern into substitute unknown shared symbol table: \" + name + \" version \" + version);\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    return systemSymbolTable();\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    return maxId;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    return null;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    return 0;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    return null;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.unknownSharedSymbolTable",
	"Comment": "returns a substitute shared symbol table where none of the symbols are known.",
	"Method": "SymbolTable unknownSharedSymbolTable(String name,int version,int maxId){\r\n    return null;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.LongHashtable.get",
	"Comment": "returns the value to which the specified key is mapped in this map.",
	"Method": "long get(long key){\r\n    Entry[] tab = table;\r\n    int hash = (int) (key ^ (key >>> 32));\r\n    int index = (hash & 0x7FFFFFFF) % tab.length;\r\n    for (Entry e = tab[index]; e != null; e = e.next) {\r\n        if (e.hash == hash && e.key == key) {\r\n            return e.value;\r\n        }\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.structurizr.view.RelationshipView.setVertices",
	"Comment": "sets the collection of vertices used when rendering this relationship.",
	"Method": "void setVertices(Collection<Vertex> vertices){\r\n    if (vertices != null) {\r\n        this.vertices = new LinkedList(vertices);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.LtvVerification.merge",
	"Comment": "merges the validation with any validation already in the document or createsa new one.",
	"Method": "void merge(){\r\n    if (used || validated.isEmpty())\r\n        return;\r\n    used = true;\r\n    PdfDictionary catalog = reader.getCatalog();\r\n    PdfObject dss = catalog.get(PdfName.DSS);\r\n    if (dss == null)\r\n        createDss();\r\n    else\r\n        updateDss();\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPSerializerRDF.addPadding",
	"Comment": "calculates the padding according to the options and write it to the stream.",
	"Method": "void addPadding(int tailLength){\r\n    if (options.getExactPacketLength()) {\r\n        int minSize = outputStream.getBytesWritten() + tailLength * unicodeSize;\r\n        if (minSize > padding) {\r\n            throw new XMPException(\"Can't fit into specified packet size\", XMPError.BADSERIALIZE);\r\n        }\r\n        padding -= minSize;\r\n    }\r\n    padding /= unicodeSize;\r\n    int newlineLen = options.getNewline().length();\r\n    if (padding >= newlineLen) {\r\n        padding -= newlineLen;\r\n        while (padding >= (100 + newlineLen)) {\r\n            writeChars(100, ' ');\r\n            writeNewline();\r\n            padding -= (100 + newlineLen);\r\n        }\r\n        writeChars(padding, ' ');\r\n        writeNewline();\r\n    } else {\r\n        writeChars(padding, ' ');\r\n    }\r\n}"
}, {
	"Path": "software.amazon.ion.impl.IonReaderTextRawTokensX.skipDoubleColon",
	"Comment": "peeks into the input stream to see if the next tokenwould be a double colon.if indeed this is the caseit skips the two colons and returns true.if notit unreads the 1 or 2 real characters it read andreturn false.it always consumes any preceding whitespace.",
	"Method": "boolean skipDoubleColon(){\r\n    int c = skip_over_whitespace();\r\n    if (c != ':') {\r\n        unread_char(c);\r\n        return false;\r\n    }\r\n    c = read_char();\r\n    if (c != ':') {\r\n        unread_char(c);\r\n        unread_char(':');\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.setUserData",
	"Comment": "set the user data. use this to store your application specific data.",
	"Method": "void setUserData(Object data){\r\n    m_userData = data;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.LocalSymbolTableAsStruct.recordLocalSymbolInIonRep",
	"Comment": "not synchronized! call within constructor or from synched method.",
	"Method": "void recordLocalSymbolInIonRep(IonStruct ionRep,String symbolName,int sid){\r\n    assert sid >= myFirstLocalSid;\r\n    ValueFactory sys = ionRep.getSystem();\r\n    IonValue syms = ionRep.get(SYMBOLS);\r\n    while (syms != null && syms.getType() != IonType.LIST) {\r\n        ionRep.remove(syms);\r\n        syms = ionRep.get(SYMBOLS);\r\n    }\r\n    if (syms == null) {\r\n        syms = sys.newEmptyList();\r\n        ionRep.put(SYMBOLS, syms);\r\n    }\r\n    int this_offset = sid - myFirstLocalSid;\r\n    IonValue name = sys.newString(symbolName);\r\n    ((IonList) syms).add(this_offset, name);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDictionary.contains",
	"Comment": "returns true if this pdfdictionary contains amapping for the specified key.",
	"Method": "boolean contains(PdfName key){\r\n    return hashMap.containsKey(key);\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.audio.AudioNatives.ensureOpus",
	"Comment": "checks whether the opus binary was loaded, if not it will be initialized here.this is used by jda to check at runtime whether the opus library is available or not.",
	"Method": "boolean ensureOpus(){\r\n    if (initialized)\r\n        return audioSupported;\r\n    initialized = true;\r\n    try {\r\n        if (OpusLibrary.isInitialized())\r\n            return audioSupported = true;\r\n        audioSupported = OpusLibrary.loadFromJar();\r\n    } catch (Throwable e) {\r\n        handleException(e);\r\n    } finally {\r\n        if (audioSupported)\r\n            LOG.info(\"Audio System successfully setup!\");\r\n        else\r\n            LOG.info(\"Audio System encountered problems while loading, thus, is disabled.\");\r\n    }\r\n    return audioSupported;\r\n}"
}, {
	"Path": "com.structurizr.util.WorkspaceUtils.fromJson",
	"Comment": "converts the specified json string to a workspace instance.",
	"Method": "Workspace fromJson(String json){\r\n    if (json == null || json.trim().length() == 0) {\r\n        throw new IllegalArgumentException(\"A JSON string must be provided.\");\r\n    }\r\n    StringReader stringReader = new StringReader(json);\r\n    return new JsonReader().read(stringReader);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.Vector.cross",
	"Comment": "computes the cross product of this vector and the specified vector",
	"Method": "Vector cross(Matrix by,Vector cross,Vector with){\r\n    float x = vals[I2] * with.vals[I3] - vals[I3] * with.vals[I2];\r\n    float y = vals[I3] * with.vals[I1] - vals[I1] * with.vals[I3];\r\n    float z = vals[I1] * with.vals[I2] - vals[I2] * with.vals[I1];\r\n    return new Vector(x, y, z);\r\n}"
}, {
	"Path": "net.openhft.affinity.NonForkingAffinityLock.cpuLayout",
	"Comment": "set the cpu layout for this machine.cpus which are not mentioned will be ignored.changing the layout will have no impact on thread which have already been assigned.it only affects subsequent assignments.",
	"Method": "void cpuLayout(CpuLayout cpuLayout,CpuLayout cpuLayout){\r\n    return LOCK_INVENTORY.getCpuLayout();\r\n}"
}, {
	"Path": "software.amazon.ion.junit.IonAssert.assertAnnotations",
	"Comment": "verifies that the given value has exactly the given annotations, in thesame order.",
	"Method": "void assertAnnotations(IonValue actual,String expectedAnns){\r\n    String[] actualAnns = actual.getTypeAnnotations();\r\n    assertArrayEquals(\"Ion annotations\", expectedAnns, actualAnns);\r\n}"
}, {
	"Path": "org.jbake.template.ModelExtractors.tryLoadEngine",
	"Comment": "this method is used to search for a specific class, telling if loading the engine would succeed. this istypically used to avoid loading optional modules.",
	"Method": "ModelExtractor tryLoadEngine(String engineClassName){\r\n    try {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Class<? extends ModelExtractor> engineClass = (Class<? extends ModelExtractor>) Class.forName(engineClassName, false, ModelExtractors.class.getClassLoader());\r\n        return engineClass.newInstance();\r\n    } catch (ClassNotFoundException e) {\r\n        return null;\r\n    } catch (InstantiationException e) {\r\n        return null;\r\n    } catch (IllegalAccessException e) {\r\n        return null;\r\n    } catch (NoClassDefFoundError e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.machinepublishers.glass.ui.monocle.MouseInput.setState",
	"Comment": "sets a new state for mouse buttons and coordinates, generating inputevents where appropriate.",
	"Method": "void setState(MouseState newState,boolean synthesized){\r\n    if (MonocleSettings.settings.traceEvents) {\r\n        MonocleTrace.traceEvent(\"Set %s\", newState);\r\n    }\r\n    NativeScreen screen = NativePlatformFactory.getNativePlatform().getScreen();\r\n    int x = Math.max(0, Math.min(newState.getX(), screen.getWidth() - 1));\r\n    int y = Math.max(0, Math.min(newState.getY(), screen.getHeight() - 1));\r\n    newState.setX(x);\r\n    newState.setY(y);\r\n    MonocleWindow oldWindow = state.getWindow(false);\r\n    boolean recalculateWindow = state.getButtonsPressed().isEmpty();\r\n    MonocleWindow window = newState.getWindow(recalculateWindow);\r\n    MonocleView view = (window == null) ? null : (MonocleView) window.getView();\r\n    if (oldWindow != window && oldWindow != null) {\r\n        if (!oldWindow.isEnabled()) {\r\n            RunnableProcessor.runLater(() -> {\r\n                MonocleWindowManager.getInstance().notifyFocusDisabled(oldWindow);\r\n            });\r\n        } else {\r\n            MonocleView oldView = (MonocleView) oldWindow.getView();\r\n            if (oldView != null) {\r\n                int modifiers = state.getModifiers();\r\n                int button = state.getButton();\r\n                boolean isPopupTrigger = false;\r\n                int oldX = state.getX();\r\n                int oldY = state.getY();\r\n                int oldRelX = oldX - oldWindow.getX();\r\n                int oldRelY = oldY - oldWindow.getY();\r\n                try {\r\n                    postMouseEvent(oldView, MouseEvent.EXIT, button, oldRelX, oldRelY, oldX, oldY, modifiers, isPopupTrigger, synthesized);\r\n                } catch (RuntimeException e) {\r\n                    Application.reportException(e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    boolean newAbsoluteLocation = state.getX() != x || state.getY() != y;\r\n    if (newAbsoluteLocation) {\r\n        NativePlatformFactory.getNativePlatform().getCursor().setLocation(x, y);\r\n    }\r\n    if (view == null) {\r\n        newState.copyTo(state);\r\n        return;\r\n    }\r\n    if (window != null && !window.isEnabled()) {\r\n        newState.copyTo(state);\r\n        RunnableProcessor.runLater(() -> {\r\n            MonocleWindowManager.getInstance().notifyFocusDisabled(window);\r\n        });\r\n        return;\r\n    }\r\n    int relX = x - window.getX();\r\n    int relY = y - window.getY();\r\n    if (oldWindow != window && view != null) {\r\n        int modifiers = state.getModifiers();\r\n        int button = state.getButton();\r\n        boolean isPopupTrigger = false;\r\n        postMouseEvent(view, MouseEvent.ENTER, button, relX, relY, x, y, modifiers, isPopupTrigger, synthesized);\r\n    }\r\n    if (oldWindow != window | newAbsoluteLocation) {\r\n        boolean isDrag = !state.getButtonsPressed().isEmpty();\r\n        int eventType = isDrag ? MouseEvent.DRAG : MouseEvent.MOVE;\r\n        int modifiers = state.getModifiers();\r\n        int button = state.getButton();\r\n        boolean isPopupTrigger = false;\r\n        postMouseEvent(view, eventType, button, relX, relY, x, y, modifiers, isPopupTrigger, synthesized);\r\n    }\r\n    newState.getButtonsPressed().difference(buttons, state.getButtonsPressed());\r\n    if (!buttons.isEmpty()) {\r\n        MouseState pressState = new MouseState();\r\n        state.copyTo(pressState);\r\n        for (int i = 0; i < buttons.size(); i++) {\r\n            int button = buttons.get(i);\r\n            pressState.pressButton(button);\r\n            boolean isPopupTrigger = false;\r\n            postMouseEvent(view, MouseEvent.DOWN, button, relX, relY, x, y, pressState.getModifiers(), isPopupTrigger, synthesized);\r\n        }\r\n    }\r\n    buttons.clear();\r\n    state.getButtonsPressed().difference(buttons, newState.getButtonsPressed());\r\n    if (!buttons.isEmpty()) {\r\n        MouseState releaseState = new MouseState();\r\n        state.copyTo(releaseState);\r\n        for (int i = 0; i < buttons.size(); i++) {\r\n            int button = buttons.get(i);\r\n            releaseState.releaseButton(button);\r\n            boolean isPopupTrigger = false;\r\n            postMouseEvent(view, MouseEvent.UP, button, relX, relY, x, y, releaseState.getModifiers(), isPopupTrigger, synthesized);\r\n        }\r\n    }\r\n    buttons.clear();\r\n    if (newState.getWheel() != state.getWheel()) {\r\n        double dY;\r\n        switch(newState.getWheel()) {\r\n            case MouseState.WHEEL_DOWN:\r\n                dY = -1.0;\r\n                break;\r\n            case MouseState.WHEEL_UP:\r\n                dY = 1.0;\r\n                break;\r\n            default:\r\n                dY = 0.0;\r\n                break;\r\n        }\r\n        if (dY != 0.0) {\r\n            int modifiers = newState.getModifiers();\r\n            RunnableProcessor.runLater(() -> {\r\n                view.notifyScroll(relX, relY, x, y, 0.0, dY, modifiers, 1, 0, 0, 0, 1.0, 1.0);\r\n            });\r\n        }\r\n        newState.setWheel(MouseState.WHEEL_NONE);\r\n    }\r\n    newState.copyTo(state);\r\n}"
}, {
	"Path": "com.itextpdf.text.List.setPreSymbol",
	"Comment": "sets the string that has to be added before a number or letter in the list symbol.",
	"Method": "void setPreSymbol(String preSymbol){\r\n    this.preSymbol = preSymbol;\r\n}"
}, {
	"Path": "com.structurizr.model.HttpHealthCheck.addHeader",
	"Comment": "adds a http header, which will be sent with the http request to the health check url.",
	"Method": "void addHeader(String name,String value){\r\n    if (name == null || name.trim().length() == 0) {\r\n        throw new IllegalArgumentException(\"The header name must not be null or empty.\");\r\n    }\r\n    if (value == null) {\r\n        throw new IllegalArgumentException(\"The header value must not be null.\");\r\n    }\r\n    this.headers.put(name, value);\r\n}"
}, {
	"Path": "com.itextpdf.testutils.CompareTool.setFloatRelativeError",
	"Comment": "sets the relative error parameter which will be used in floating point numbers comparison.",
	"Method": "CompareTool setFloatRelativeError(float error){\r\n    this.floatComparisonError = error;\r\n    this.absoluteError = false;\r\n    return this;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPNormalizer.moveExplicitAliases",
	"Comment": "visit all of the top level nodes looking for aliases. if there is\tno base, transplant the alias subtree. if there is a base and strict\taliasing is on, make sure the alias and base subtrees match.",
	"Method": "void moveExplicitAliases(XMPNode tree,ParseOptions options){\r\n    if (!tree.getHasAliases()) {\r\n        return;\r\n    }\r\n    tree.setHasAliases(false);\r\n    boolean strictAliasing = options.getStrictAliasing();\r\n    for (Iterator schemaIt = tree.getUnmodifiableChildren().iterator(); schemaIt.hasNext(); ) {\r\n        XMPNode currSchema = (XMPNode) schemaIt.next();\r\n        if (!currSchema.getHasAliases()) {\r\n            continue;\r\n        }\r\n        for (Iterator propertyIt = currSchema.iterateChildren(); propertyIt.hasNext(); ) {\r\n            XMPNode currProp = (XMPNode) propertyIt.next();\r\n            if (!currProp.isAlias()) {\r\n                continue;\r\n            }\r\n            currProp.setAlias(false);\r\n            XMPAliasInfo info = XMPMetaFactory.getSchemaRegistry().findAlias(currProp.getName());\r\n            if (info != null) {\r\n                XMPNode baseSchema = XMPNodeUtils.findSchemaNode(tree, info.getNamespace(), null, true);\r\n                baseSchema.setImplicit(false);\r\n                XMPNode baseNode = XMPNodeUtils.findChildNode(baseSchema, info.getPrefix() + info.getPropName(), false);\r\n                if (baseNode == null) {\r\n                    if (info.getAliasForm().isSimple()) {\r\n                        String qname = info.getPrefix() + info.getPropName();\r\n                        currProp.setName(qname);\r\n                        baseSchema.addChild(currProp);\r\n                        propertyIt.remove();\r\n                    } else {\r\n                        baseNode = new XMPNode(info.getPrefix() + info.getPropName(), info.getAliasForm().toPropertyOptions());\r\n                        baseSchema.addChild(baseNode);\r\n                        transplantArrayItemAlias(propertyIt, currProp, baseNode);\r\n                    }\r\n                } else if (info.getAliasForm().isSimple()) {\r\n                    if (strictAliasing) {\r\n                        compareAliasedSubtrees(currProp, baseNode, true);\r\n                    }\r\n                    propertyIt.remove();\r\n                } else {\r\n                    XMPNode itemNode = null;\r\n                    if (info.getAliasForm().isArrayAltText()) {\r\n                        int xdIndex = XMPNodeUtils.lookupLanguageItem(baseNode, XMPConst.X_DEFAULT);\r\n                        if (xdIndex != -1) {\r\n                            itemNode = baseNode.getChild(xdIndex);\r\n                        }\r\n                    } else if (baseNode.hasChildren()) {\r\n                        itemNode = baseNode.getChild(1);\r\n                    }\r\n                    if (itemNode == null) {\r\n                        transplantArrayItemAlias(propertyIt, currProp, baseNode);\r\n                    } else {\r\n                        if (strictAliasing) {\r\n                            compareAliasedSubtrees(currProp, itemNode, true);\r\n                        }\r\n                        propertyIt.remove();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        currSchema.setHasAliases(false);\r\n    }\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.util.IPushbackReader.read",
	"Comment": "read the next int from the stream this will check the buffer queue firstand take the first item of the buffer as the result",
	"Method": "int read(int read,char[] cbuf,int off,int len){\r\n    int size = queue.size();\r\n    if (size > 0) {\r\n        throw new IOException(\"Method not implemented yet\");\r\n    }\r\n    return reader.read(cbuf, off, len);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.isBullet",
	"Comment": "is this a fast moving body that should be prevented from tunneling through other moving bodies?note that all bodies are prevented from tunneling through kinematic and static bodies. thissetting is only considered on dynamic bodies.",
	"Method": "boolean isBullet(){\r\n    return bullet;\r\n}"
}, {
	"Path": "com.itextpdf.text.Rectangle.updateBorderBasedOnWidth",
	"Comment": "helper function updating the border flag for a side\tbased on the specified width.\ta width of 0 will disable the border on that side.\tany other width enables it.",
	"Method": "void updateBorderBasedOnWidth(float width,int side){\r\n    useVariableBorders = true;\r\n    if (width > 0)\r\n        enableBorderSide(side);\r\n    else\r\n        disableBorderSide(side);\r\n}"
}, {
	"Path": "software.amazon.ion.system.IonReaderBuilder.mutable",
	"Comment": "returns a mutable builder configured exactly like this one.",
	"Method": "IonReaderBuilder mutable(IonReaderBuilder mutable){\r\n    return copy();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.collection.PdfCollectionField.isCollectionItem",
	"Comment": "checks if the type of the field is suitable for a collection item.",
	"Method": "boolean isCollectionItem(){\r\n    switch(fieldType) {\r\n        case TEXT:\r\n        case DATE:\r\n        case NUMBER:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.testutils.CompareTool.setCompareByContentErrorsLimit",
	"Comment": "sets the maximum errors count which will be returned as the result of the comparison.",
	"Method": "CompareTool setCompareByContentErrorsLimit(int compareByContentMaxErrorCount){\r\n    this.compareByContentErrorsLimit = compareByContentMaxErrorCount;\r\n    return this;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPatternPainter.getXStep",
	"Comment": "returns the horizontal interval when repeating the pattern.",
	"Method": "float getXStep(){\r\n    return this.xstep;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaPosition.setVOffset",
	"Comment": "sets the offset from the alignment point specified by the valign key.\ta positive value for voffset, when valign is either near or center,\toffsets the position towards the far direction. a positive value for\tvoffset, when valign is far, offsets the position towards the near\tdirection.",
	"Method": "void setVOffset(float vOffset){\r\n    put(PdfName.VOFFSET, new PdfNumber(vOffset));\r\n}"
}, {
	"Path": "com.structurizr.view.ViewSet.getConfiguration",
	"Comment": "gets the configuration object associated with this set of views.",
	"Method": "Configuration getConfiguration(){\r\n    return configuration;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfCopyFormsImp.mergeFields",
	"Comment": "this merge fields is slightly different from the mergefields methodof pdfcopyfields.",
	"Method": "void mergeFields(){\r\n    for (int k = 0; k < fields.size(); ++k) {\r\n        Map<String, Item> fd = (fields.get(k)).getFields();\r\n        mergeWithMaster(fd);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.html.HtmlUtilities.parseAttributes",
	"Comment": "this method parses a string with attributes and returns a properties\tobject.",
	"Method": "Properties parseAttributes(String string){\r\n    Properties result = new Properties();\r\n    if (string == null)\r\n        return result;\r\n    StringTokenizer keyValuePairs = new StringTokenizer(string, \";\");\r\n    StringTokenizer keyValuePair;\r\n    String key;\r\n    String value;\r\n    while (keyValuePairs.hasMoreTokens()) {\r\n        keyValuePair = new StringTokenizer(keyValuePairs.nextToken(), \":\");\r\n        if (keyValuePair.hasMoreTokens())\r\n            key = keyValuePair.nextToken().trim();\r\n        else\r\n            continue;\r\n        if (keyValuePair.hasMoreTokens())\r\n            value = keyValuePair.nextToken().trim();\r\n        else\r\n            continue;\r\n        if (value.startsWith(\"\\\"\"))\r\n            value = value.substring(1);\r\n        if (value.endsWith(\"\\\"\"))\r\n            value = value.substring(0, value.length() - 1);\r\n        result.setProperty(key.toLowerCase(), value);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.lite.IonDatagramLite.setSymbolTableAtIndex",
	"Comment": "sets the context of all elements following elementid to context, until it encountersa context different to the original context at elementid.",
	"Method": "void setSymbolTableAtIndex(int elementid,SymbolTable symbols){\r\n    assert (elementid < get_child_count());\r\n    TopLevelContext context = TopLevelContext.wrap(symbols, this);\r\n    TopLevelContext startContext = (TopLevelContext) _children[elementid].getContext();\r\n    while (elementid < get_child_count() && _children[elementid].getContext() == startContext) {\r\n        _children[elementid++].setContext(context);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.PrivateKeySignature.sign",
	"Comment": "signs it using the encryption algorithm in combination withthe digest algorithm.",
	"Method": "byte[] sign(byte[] b){\r\n    String signMode = hashAlgorithm + \"with\" + encryptionAlgorithm;\r\n    Signature sig;\r\n    if (provider == null)\r\n        sig = Signature.getInstance(signMode);\r\n    else\r\n        sig = Signature.getInstance(signMode, provider);\r\n    sig.initSign(pk);\r\n    sig.update(b);\r\n    return sig.sign();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.addSimple",
	"Comment": "adds a spotcolor to the document but not to the page resources.",
	"Method": "FontDetails addSimple(BaseFont bf,ColorDetails addSimple,ICachedColorSpace spc){\r\n    ColorDetails ret = documentColors.get(spc);\r\n    if (ret == null) {\r\n        ret = new ColorDetails(getColorspaceName(), body.getPdfIndirectReference(), spc);\r\n        if (spc instanceof IPdfSpecialColorSpace) {\r\n            ((IPdfSpecialColorSpace) spc).getColorantDetails(this);\r\n        }\r\n        documentColors.put(spc, ret);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.CreateNonCIDPrivate",
	"Comment": "the function creates a private dict for a font that was not cid\tall the keys are copied as is except for the subrs key",
	"Method": "void CreateNonCIDPrivate(int Font,OffsetItem Subr){\r\n    seek(fonts[Font].privateOffset);\r\n    while (getPosition() < fonts[Font].privateOffset + fonts[Font].privateLength) {\r\n        int p1 = getPosition();\r\n        getDictItem();\r\n        int p2 = getPosition();\r\n        if (key == \"Subrs\") {\r\n            OutputList.addLast(Subr);\r\n            OutputList.addLast(new UInt8Item((char) 19));\r\n        } else\r\n            OutputList.addLast(new RangeItem(buf, p1, p2 - p1));\r\n    }\r\n}"
}, {
	"Path": "software.amazon.ion.Timestamp.addMinute",
	"Comment": "returns a timestamp relative to this one by the given number of minutes.",
	"Method": "Timestamp addMinute(int amount){\r\n    long delta = (long) amount * 60 * 1000;\r\n    return addMillis(delta);\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.ParseRDF.rdf_RDF",
	"Comment": "each of these parsing methods is responsible for recognizing an rdf\tsyntax production and adding the appropriate structure to the xmp tree.\tthey simply return for success, failures will throw an exception.",
	"Method": "void rdf_RDF(XMPMetaImpl xmp,Node rdfRdfNode){\r\n    if (rdfRdfNode.hasAttributes()) {\r\n        rdf_NodeElementList(xmp, xmp.getRoot(), rdfRdfNode);\r\n    } else {\r\n        throw new XMPException(\"Invalid attributes of rdf:RDF element\", BADRDF);\r\n    }\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONObject.append",
	"Comment": "append values to the array under a key. if the key does not exist in thejsonobject, then the key is put in the jsonobject with its value being ajsonarray containing the value parameter. if the key was alreadyassociated with a jsonarray, then the value parameter is appended to it.",
	"Method": "JSONObject append(String key,Object value){\r\n    testValidity(value);\r\n    Object object = this.opt(key);\r\n    if (object == null) {\r\n        this.put(key, new JSONArray().put(value));\r\n    } else if (object instanceof JSONArray) {\r\n        this.put(key, ((JSONArray) object).put(value));\r\n    } else {\r\n        throw new JSONException(\"JSONObject[\" + key + \"] is not a JSONArray.\");\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.getAllFontNames",
	"Comment": "gets all the names from the font. only the required tables are read.",
	"Method": "Object[] getAllFontNames(String name,String encoding,byte ttfAfm){\r\n    String nameBase = getBaseName(name);\r\n    BaseFont fontBuilt = null;\r\n    if (nameBase.toLowerCase().endsWith(\".ttf\") || nameBase.toLowerCase().endsWith(\".otf\") || nameBase.toLowerCase().indexOf(\".ttc,\") > 0)\r\n        fontBuilt = new TrueTypeFont(name, CP1252, false, ttfAfm, true, false);\r\n    else\r\n        fontBuilt = createFont(name, encoding, false, false, ttfAfm, null);\r\n    return new Object[] { fontBuilt.getPostscriptFontName(), fontBuilt.getFamilyFontName(), fontBuilt.getFullFontName() };\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfLayerMembership.setVisibilityExpression",
	"Comment": "sets the visibility expression for content belonging to thismembership dictionary.",
	"Method": "void setVisibilityExpression(PdfVisibilityExpression ve){\r\n    put(PdfName.VE, ve);\r\n}"
}, {
	"Path": "com.itextpdf.text.RectangleReadOnly.throwReadOnlyError",
	"Comment": "throws an error because of the read only nature of this object.",
	"Method": "void throwReadOnlyError(){\r\n    throw new UnsupportedOperationException(MessageLocalization.getComposedMessage(\"rectanglereadonly.this.rectangle.is.read.only\"));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.DigestAlgorithms.getMessageDigest",
	"Comment": "creates a messagedigest object that can be used to create a hash.",
	"Method": "MessageDigest getMessageDigest(String hashAlgorithm,String provider){\r\n    if (provider == null || provider.startsWith(\"SunPKCS11\") || provider.startsWith(\"SunMSCAPI\"))\r\n        return MessageDigest.getInstance(DigestAlgorithms.normalizeDigestName(hashAlgorithm));\r\n    else\r\n        return MessageDigest.getInstance(hashAlgorithm, provider);\r\n}"
}, {
	"Path": "org.jbox2d.collision.shapes.Shape.getType",
	"Comment": "get the type of this shape. you can use this to down cast to the concrete shape.",
	"Method": "ShapeType getType(){\r\n    return m_type;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaPosition.setHOffset",
	"Comment": "sets the offset from the alignment point specified by the halign key.\ta positive value for hoffset, when halign is either near or center,\toffsets the position towards the far direction. a positive value for\thoffset, when halign is far, offsets the position towards the near\tdirection.",
	"Method": "void setHOffset(float hOffset){\r\n    put(PdfName.HOFFSET, new PdfNumber(hOffset));\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.Tag.hasChild",
	"Comment": "check if this tag has a child with the given name and namespace.",
	"Method": "boolean hasChild(String name,String ns,boolean hasChild,String name,String ns,boolean recursive){\r\n    if (recursive) {\r\n        return recursiveHasChild(this, name, ns, true);\r\n    } else {\r\n        return recursiveHasChild(this, name, ns, false);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.IntHashtable.put",
	"Comment": "maps the specified key to the specifiedvalue in this hashtable. the key cannot benull. the value can be retrieved by calling the get methodwith a key that is equal to the original key.",
	"Method": "int put(int key,int value){\r\n    Entry[] tab = table;\r\n    int hash = key;\r\n    int index = (hash & 0x7FFFFFFF) % tab.length;\r\n    for (Entry e = tab[index]; e != null; e = e.next) {\r\n        if (e.hash == hash && e.key == key) {\r\n            int old = e.value;\r\n            e.value = value;\r\n            return old;\r\n        }\r\n    }\r\n    if (count >= threshold) {\r\n        rehash();\r\n        tab = table;\r\n        index = (hash & 0x7FFFFFFF) % tab.length;\r\n    }\r\n    Entry e = new Entry(hash, key, value, tab[index]);\r\n    tab[index] = e;\r\n    count++;\r\n    return 0;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfLine.getDescender",
	"Comment": "gets the biggest descender for all the fonts usedin this line.note that this is a negative number.",
	"Method": "float getDescender(){\r\n    float descender = 0;\r\n    for (int k = 0; k < line.size(); ++k) {\r\n        PdfChunk ck = line.get(k);\r\n        if (ck.isImage())\r\n            descender = Math.min(descender, ck.getImageOffsetY());\r\n        else {\r\n            PdfFont font = ck.font();\r\n            float textRise = ck.getTextRise();\r\n            descender = Math.min(descender, (textRise < 0 ? textRise : 0) + font.getFont().getFontDescriptor(BaseFont.DESCENT, font.size()));\r\n        }\r\n    }\r\n    return descender;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.spatial.MeasureGeospatial.getSubType",
	"Comment": "gets the subtype.\tin this case rl for a rectalinear coordinate system.",
	"Method": "PdfName getSubType(){\r\n    return PdfName.GEO;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaParams.setCuePoints",
	"Comment": "sets an array of cuepoint dictionaries containing points\tin time within a flash animation.",
	"Method": "void setCuePoints(PdfArray cuePoints){\r\n    put(PdfName.CUEPOINTS, cuePoints);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDictionary.getAsStream",
	"Comment": "returns a pdfobject as a pdfstream,resolving indirect references.the object associated with the pdfname given is retrievedand resolved to a direct object.if it is a pdfstream, it is cast down and returned as such.otherwise null is returned.",
	"Method": "PdfStream getAsStream(PdfName key){\r\n    PdfStream stream = null;\r\n    PdfObject orig = getDirectObject(key);\r\n    if (orig != null && orig.isStream())\r\n        stream = (PdfStream) orig;\r\n    return stream;\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.css.DefaultCSSResolverTest.cssTagLevelInheritance",
	"Comment": "checks cssinheritance between parent and child on tag level",
	"Method": "void cssTagLevelInheritance(){\r\n    css.setCssInheritance(new CssInheritanceRules() {\r\n        public boolean inheritCssTag(final String tag) {\r\n            return !\"child\".equals(tag);\r\n        }\r\n        public boolean inheritCssSelector(final Tag tag, final String key) {\r\n            return true;\r\n        }\r\n    });\r\n    css.resolveStyles(parent);\r\n    css.resolveStyles(child);\r\n    Map<String, String> css2 = child.getCSS();\r\n    assertTrue(\"font not found\", css2.containsKey(\"fontk\"));\r\n    assertTrue(\"font-size not found\", css2.containsKey(\"font-size\"));\r\n    assertFalse(\"color found while not expected\", css2.containsKey(\"color\"));\r\n    assertEquals(\"Arial\", css2.get(\"fontk\"));\r\n    assertEquals(\"large\", css2.get(\"font-size\"));\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.css.DefaultCSSResolverTest.cssTagLevelInheritance",
	"Comment": "checks cssinheritance between parent and child on tag level",
	"Method": "void cssTagLevelInheritance(){\r\n    return !\"child\".equals(tag);\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.css.DefaultCSSResolverTest.cssTagLevelInheritance",
	"Comment": "checks cssinheritance between parent and child on tag level",
	"Method": "void cssTagLevelInheritance(){\r\n    return true;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfAnnotation.setPlaceInPage",
	"Comment": "places the annotation in a specified page that must be greateror equal to the current one. with pdfstamper the pagecan be any. the first page is 1.",
	"Method": "void setPlaceInPage(int placeInPage){\r\n    this.placeInPage = placeInPage;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.pdfcleanup.PdfCleanUpProcessor.extractLocationsFromRedactAnnots",
	"Comment": "extracts locations from the redact annotations contained in the document and applied to the given page.",
	"Method": "void extractLocationsFromRedactAnnots(List<PdfCleanUpLocation> extractLocationsFromRedactAnnots,int page,PdfDictionary pageDict){\r\n    List<PdfCleanUpLocation> locations = new ArrayList<PdfCleanUpLocation>();\r\n    if (pageDict.contains(PdfName.ANNOTS)) {\r\n        PdfArray annotsArray = pageDict.getAsArray(PdfName.ANNOTS);\r\n        for (int i = 0; i < annotsArray.size(); ++i) {\r\n            PdfIndirectReference annotIndirRef = annotsArray.getAsIndirectObject(i);\r\n            PdfDictionary annotDict = annotsArray.getAsDict(i);\r\n            PdfName annotSubtype = annotDict.getAsName(PdfName.SUBTYPE);\r\n            if (annotSubtype.equals(PdfName.REDACT)) {\r\n                saveRedactAnnotIndirRef(page, annotIndirRef.toString());\r\n                locations.addAll(extractLocationsFromRedactAnnot(page, i, annotDict));\r\n            }\r\n        }\r\n    }\r\n    return locations;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfArray.getAsArray",
	"Comment": "returns a pdfobject as a pdfarray,resolving indirect references.the object corresponding to the specified index is retrieved andresolved to a direct object.if it is a pdfarray, it is cast down and returned as such.otherwise null is returned.",
	"Method": "PdfArray getAsArray(int idx){\r\n    PdfArray array = null;\r\n    PdfObject orig = getDirectObject(idx);\r\n    if (orig != null && orig.isArray())\r\n        array = (PdfArray) orig;\r\n    return array;\r\n}"
}, {
	"Path": "com.google.cloud.language.samples.ModelApi.getOperationStatus",
	"Comment": "demonstrates using the automl client to get operation status.",
	"Method": "void getOperationStatus(String operationFullId){\r\n    AutoMlClient client = AutoMlClient.create();\r\n    Operation response = client.getOperationsClient().getOperation(operationFullId);\r\n    System.out.println(String.format(\"Operation status: %s\", response));\r\n}"
}, {
	"Path": "com.google.cloud.vision.samples.automl.ModelApi.getModelEvaluation",
	"Comment": "demonstrates using the automl client to get model evaluations.",
	"Method": "void getModelEvaluation(String projectId,String computeRegion,String modelId,String modelEvaluationId){\r\n    AutoMlClient client = AutoMlClient.create();\r\n    ModelEvaluationName modelEvaluationFullId = ModelEvaluationName.of(projectId, computeRegion, modelId, modelEvaluationId);\r\n    ModelEvaluation response = client.getModelEvaluation(modelEvaluationFullId);\r\n    System.out.println(response);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.OutputStreamEncryption.close",
	"Comment": "closes this output stream and releases any system resourcesassociated with this stream. the general contract of closeis that it closes the output stream. a closed stream cannot performoutput operations and cannot be reopened.the close method of outputstream does nothing.",
	"Method": "void close(){\r\n    finish();\r\n    out.close();\r\n}"
}, {
	"Path": "com.sixt.service.framework.servicetest.helper.DockerComposeHelper.waitForPostgres",
	"Comment": "wait for postgres to become ready by checking log forsome custom expected phrase",
	"Method": "SuccessOrFailure waitForPostgres(String logFile,SuccessOrFailure waitForPostgres,String logFile,String phraseToWaitFor){\r\n    return waitFor(logFile, phraseToWaitFor, \"Postgres not ready yet\");\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.PrismaticJointDef.initialize",
	"Comment": "initialize the bodies, anchors, axis, and reference angle using the world anchor and worldaxis.",
	"Method": "void initialize(Body b1,Body b2,Vec2 anchor,Vec2 axis){\r\n    bodyA = b1;\r\n    bodyB = b2;\r\n    bodyA.getLocalPointToOut(anchor, localAnchorA);\r\n    bodyB.getLocalPointToOut(anchor, localAnchorB);\r\n    bodyA.getLocalVectorToOut(axis, localAxisA);\r\n    referenceAngle = bodyB.getAngle() - bodyA.getAngle();\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.FixtureDef.isSensor",
	"Comment": "a sensor shape collects contact information but never generates a collision response.",
	"Method": "boolean isSensor(){\r\n    return isSensor;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.setDebugDraw",
	"Comment": "register a routine for debug drawing. the debug draw functions are called inside withworld.drawdebugdata method. the debug draw object is owned by you and must remain in scope.",
	"Method": "void setDebugDraw(DebugDraw debugDraw){\r\n    m_debugDraw = debugDraw;\r\n}"
}, {
	"Path": "com.itextpdf.text.html.HtmlEncoder.encode",
	"Comment": "converts a basecolor into a html representation of this basecolor.",
	"Method": "String encode(String string,String encode,BaseColor color){\r\n    StringBuffer buffer = new StringBuffer(\"#\");\r\n    if (color.getRed() < 16) {\r\n        buffer.append('0');\r\n    }\r\n    buffer.append(Integer.toString(color.getRed(), 16));\r\n    if (color.getGreen() < 16) {\r\n        buffer.append('0');\r\n    }\r\n    buffer.append(Integer.toString(color.getGreen(), 16));\r\n    if (color.getBlue() < 16) {\r\n        buffer.append('0');\r\n    }\r\n    buffer.append(Integer.toString(color.getBlue(), 16));\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfAFileStructureTest.fileHeader",
	"Comment": "the % character of the file header shall occur at byte offset 0 of the file.the file header line shall be immediately followed by a comment consisting of a % character followed by at least four characters, each of whose encoded byte values shall have a decimal value greater than 127.",
	"Method": "void fileHeader(){\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    Document document = new Document();\r\n    PdfWriter.getInstance(document, baos);\r\n    document.open();\r\n    document.add(new Chunk(\"Hello World\"));\r\n    document.close();\r\n    byte[] bytes = baos.toByteArray();\r\n    Assert.assertEquals(bytes[0], '%');\r\n    Assert.assertTrue(bytes[10] < 0);\r\n    Assert.assertTrue(bytes[11] < 0);\r\n    Assert.assertTrue(bytes[12] < 0);\r\n    Assert.assertTrue(bytes[13] < 0);\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.css.DefaultCSSResolverTest.cssTagStyleLevelInheritance",
	"Comment": "checks cssinheritance between parent and child on css element level",
	"Method": "void cssTagStyleLevelInheritance(){\r\n    css.setCssInheritance(new CssInheritanceRules() {\r\n        public boolean inheritCssTag(final String tag) {\r\n            return true;\r\n        }\r\n        public boolean inheritCssSelector(final Tag tag, final String key) {\r\n            return \"child\".equals(tag.getName()) && \"color\".equals(key);\r\n        }\r\n    });\r\n    css.resolveStyles(parent);\r\n    css.resolveStyles(child);\r\n    Map<String, String> css2 = child.getCSS();\r\n    assertTrue(\"font not found\", css2.containsKey(\"fontk\"));\r\n    assertTrue(\"font-size not found\", css2.containsKey(\"font-size\"));\r\n    assertTrue(\"color not found\", css2.containsKey(\"color\"));\r\n    assertEquals(\"Arial\", css2.get(\"fontk\"));\r\n    assertEquals(\"large\", css2.get(\"font-size\"));\r\n    assertEquals(\"blue\", css2.get(\"color\"));\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.css.DefaultCSSResolverTest.cssTagStyleLevelInheritance",
	"Comment": "checks cssinheritance between parent and child on css element level",
	"Method": "void cssTagStyleLevelInheritance(){\r\n    return true;\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.css.DefaultCSSResolverTest.cssTagStyleLevelInheritance",
	"Comment": "checks cssinheritance between parent and child on css element level",
	"Method": "void cssTagStyleLevelInheritance(){\r\n    return \"child\".equals(tag.getName()) && \"color\".equals(key);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStamperImp.addOrder",
	"Comment": "recursive method to reconstruct the documentocgorder variable in the writer.",
	"Method": "void addOrder(PdfLayer parent,PdfArray arr,Map<String, PdfLayer> ocgmap){\r\n    PdfObject obj;\r\n    PdfLayer layer;\r\n    for (int i = 0; i < arr.size(); i++) {\r\n        obj = arr.getPdfObject(i);\r\n        if (obj.isIndirect()) {\r\n            layer = ocgmap.get(obj.toString());\r\n            if (layer != null) {\r\n                layer.setOnPanel(true);\r\n                registerLayer(layer);\r\n                if (parent != null) {\r\n                    parent.addChild(layer);\r\n                }\r\n                if (arr.size() > i + 1 && arr.getPdfObject(i + 1).isArray()) {\r\n                    i++;\r\n                    addOrder(layer, (PdfArray) arr.getPdfObject(i), ocgmap);\r\n                }\r\n            }\r\n        } else if (obj.isArray()) {\r\n            PdfArray sub = (PdfArray) obj;\r\n            if (sub.isEmpty())\r\n                return;\r\n            obj = sub.getPdfObject(0);\r\n            if (obj.isString()) {\r\n                layer = new PdfLayer(obj.toString());\r\n                layer.setOnPanel(true);\r\n                registerLayer(layer);\r\n                if (parent != null) {\r\n                    parent.addChild(layer);\r\n                }\r\n                PdfArray array = new PdfArray();\r\n                for (Iterator<PdfObject> j = sub.listIterator(); j.hasNext(); ) {\r\n                    array.add(j.next());\r\n                }\r\n                addOrder(layer, array, ocgmap);\r\n            } else {\r\n                addOrder(parent, (PdfArray) obj, ocgmap);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.html.AbstractTagProcessor.currentContentToParagraph",
	"Comment": "adds currentcontent list to a paragraph element. if addnewlines is true a\tparagraph object is returned, else a nonewlineparagraph object is\treturned.",
	"Method": "List<Element> currentContentToParagraph(List<Element> currentContent,boolean addNewLines,boolean applyCSS,Tag tag,WorkerContext ctx,List<Element> currentContentToParagraph,List<Element> currentContent,boolean addNewLines){\r\n    return this.currentContentToParagraph(currentContent, addNewLines, false, null, null);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.applyForce",
	"Comment": "apply a force at a world point. if the force is not applied at the center of mass, it willgenerate a torque and affect the angular velocity. this wakes up the body.",
	"Method": "void applyForce(Vec2 force,Vec2 point){\r\n    if (m_type != BodyType.DYNAMIC) {\r\n        return;\r\n    }\r\n    if (isAwake() == false) {\r\n        setAwake(true);\r\n    }\r\n    m_force.x += force.x;\r\n    m_force.y += force.y;\r\n    m_torque += (point.x - m_sweep.c.x) * force.y - (point.y - m_sweep.c.y) * force.x;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.MakeXmlSignature.findElement",
	"Comment": "find signature and signaturevalue elements after marshalization.",
	"Method": "Element findElement(NodeList nodes,String localName){\r\n    for (int i = nodes.getLength() - 1; i >= 0; --i) {\r\n        Node currNode = nodes.item(i);\r\n        if (currNode.getNodeType() == Node.ELEMENT_NODE && currNode.getLocalName().equals(localName))\r\n            return (Element) currNode;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.EmbedBuilder.clear",
	"Comment": "resets this builder to default state.all parts will be either empty or null after this method has returned.",
	"Method": "EmbedBuilder clear(){\r\n    description.setLength(0);\r\n    fields.clear();\r\n    url = null;\r\n    title = null;\r\n    timestamp = null;\r\n    color = Role.DEFAULT_COLOR_RAW;\r\n    thumbnail = null;\r\n    author = null;\r\n    footer = null;\r\n    image = null;\r\n    return this;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfArray.getDirectObject",
	"Comment": "returns the pdfobject with the specified index, resolvinga possible indirect reference to a direct object.thus this method will never return a pdfindirectreferenceobject.",
	"Method": "PdfObject getDirectObject(int idx){\r\n    return PdfReader.getPdfObject(getPdfObject(idx));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDictionary.putEx",
	"Comment": "associates the specified pdfobject as value to thespecified pdfname as key in this map.if the value is a pdfnull, it is treated just asany other pdfobject. if the value isnull however nothing is done.",
	"Method": "void putEx(PdfName key,PdfObject value){\r\n    if (key == null)\r\n        throw new IllegalArgumentException(MessageLocalization.getComposedMessage(\"key.is.null\"));\r\n    if (value == null)\r\n        return;\r\n    put(key, value);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.events.PdfPageEventForwarder.onGenericTag",
	"Comment": "called when a chunk with a generic tag is written.\tit is useful to pinpoint the chunk location to generate\tbookmarks, for example.",
	"Method": "void onGenericTag(PdfWriter writer,Document document,Rectangle rect,String text){\r\n    PdfPageEvent event;\r\n    for (Object element : events) {\r\n        event = (PdfPageEvent) element;\r\n        event.onGenericTag(writer, document, rect, text);\r\n    }\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONWriter.endObject",
	"Comment": "end an object. this method most be called to balance calls toobject.",
	"Method": "JSONWriter endObject(){\r\n    return this.end('k', '}');\r\n}"
}, {
	"Path": "software.amazon.ion.system.IonBinaryWriterBuilder.standard",
	"Comment": "the standard builder of binary writers, with all configurationproperties having their default values.",
	"Method": "IonBinaryWriterBuilder standard(){\r\n    return PrivateIonBinaryWriterBuilder.standard();\r\n}"
}, {
	"Path": "software.amazon.ion.impl.IonUTF8.convertToUTF8Bytes",
	"Comment": "this helper converts the unicodescalar to a sequence of utf8 bytesand copies those bytes into the supplied outputbytes array.if thereis insufficient room in the array to hold the generated bytes it willthrow an arrayindexoutofboundsexception.it does not check for thevalidity of the passed in unicodescalar thoroughly, however it willthrow an invalidunicodecodepoint if the value is less than negativeor the utf8 encoding would exceed 4 bytes.",
	"Method": "int convertToUTF8Bytes(int unicodeScalar,byte[] outputBytes,int offset,int maxLength){\r\n    int dst = offset;\r\n    int end = offset + maxLength;\r\n    switch(getUTF8ByteCount(unicodeScalar)) {\r\n        case 1:\r\n            if (dst >= end)\r\n                throw new ArrayIndexOutOfBoundsException();\r\n            outputBytes[dst++] = (byte) (unicodeScalar & 0xff);\r\n            break;\r\n        case 2:\r\n            if (dst + 1 >= end)\r\n                throw new ArrayIndexOutOfBoundsException();\r\n            outputBytes[dst++] = getByte1Of2(unicodeScalar);\r\n            outputBytes[dst++] = getByte2Of2(unicodeScalar);\r\n            break;\r\n        case 3:\r\n            if (dst + 2 >= end)\r\n                throw new ArrayIndexOutOfBoundsException();\r\n            outputBytes[dst++] = getByte1Of3(unicodeScalar);\r\n            outputBytes[dst++] = getByte2Of3(unicodeScalar);\r\n            outputBytes[dst++] = getByte3Of3(unicodeScalar);\r\n            break;\r\n        case 4:\r\n            if (dst + 3 >= end)\r\n                throw new ArrayIndexOutOfBoundsException();\r\n            outputBytes[dst++] = getByte1Of4(unicodeScalar);\r\n            outputBytes[dst++] = getByte2Of4(unicodeScalar);\r\n            outputBytes[dst++] = getByte3Of4(unicodeScalar);\r\n            outputBytes[dst++] = getByte4Of4(unicodeScalar);\r\n            break;\r\n    }\r\n    return dst - offset;\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.html.SnippetUtil.printAllContent",
	"Comment": "convenient method for retrieving the content of an elementlist.",
	"Method": "void printAllContent(List<Element> elementList){\r\n    int i = 0;\r\n    int j = 0;\r\n    for (Element e : elementList) {\r\n        System.out.println(\"element \" + i + \", runtime class = \" + e.getClass().toString());\r\n        for (Chunk c : e.getChunks()) {\r\n            if (Chunk.NEWLINE.getContent().equals(c.getContent())) {\r\n                System.out.println(\"newline\");\r\n            } else {\r\n                System.out.println(c.getClass().toString() + \" \" + j + \": \" + c.getContent());\r\n            }\r\n            ++j;\r\n        }\r\n        ++i;\r\n        j = 0;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfTemplate.createTemplate",
	"Comment": "creates a new template.creates a new template that is nothing more than a form xobject. this template can be includedin this template or in another template. templates are only writtento the output when the document is closed permitting things like showing text in the first pagethat is only defined in the last page.",
	"Method": "PdfTemplate createTemplate(PdfWriter writer,float width,float height,PdfTemplate createTemplate,PdfWriter writer,float width,float height,PdfName forcedName){\r\n    PdfTemplate template = new PdfTemplate(writer);\r\n    template.setWidth(width);\r\n    template.setHeight(height);\r\n    writer.addDirectTemplateSimple(template, forcedName);\r\n    return template;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.ocg.OCGParser.isVisible",
	"Comment": "checks operands to find out if the corresponding operator needs to be present or not.",
	"Method": "boolean isVisible(List<PdfObject> operands){\r\n    if (operands.size() > 1 && xobj.contains(operands.get(0)))\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.DigestAlgorithms.digest",
	"Comment": "creates a hash using a specific digest algorithm and a provider.",
	"Method": "byte[] digest(InputStream data,String hashAlgorithm,String provider,byte[] digest,InputStream data,MessageDigest messageDigest){\r\n    byte[] buf = new byte[8192];\r\n    int n;\r\n    while ((n = data.read(buf)) > 0) {\r\n        messageDigest.update(buf, 0, n);\r\n    }\r\n    return messageDigest.digest();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.SignaturePermissions.isFillInAllowed",
	"Comment": "getter to find out if filling out fields is allowed after signing.",
	"Method": "boolean isFillInAllowed(){\r\n    return fillInAllowed;\r\n}"
}, {
	"Path": "org.jbake.app.FileUtil.getNotContentFileFilter",
	"Comment": "gets the list of files that are not content files based on their extension.",
	"Method": "FileFilter getNotContentFileFilter(){\r\n    return new FileFilter() {\r\n        @Override\r\n        public boolean accept(File pathname) {\r\n            return !pathname.isHidden() && (pathname.isFile() && !Engines.getRecognizedExtensions().contains(fileExt(pathname))) || (directoryOnlyIfNotIgnored(pathname));\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.jbake.app.FileUtil.getNotContentFileFilter",
	"Comment": "gets the list of files that are not content files based on their extension.",
	"Method": "FileFilter getNotContentFileFilter(){\r\n    return !pathname.isHidden() && (pathname.isFile() && !Engines.getRecognizedExtensions().contains(fileExt(pathname))) || (directoryOnlyIfNotIgnored(pathname));\r\n}"
}, {
	"Path": "com.itextpdf.text.Image.setInitialRotation",
	"Comment": "some image formats, like tiff may present the images rotated that haveto be compensated.",
	"Method": "void setInitialRotation(float initialRotation){\r\n    float old_rot = rotationRadians - this.initialRotation;\r\n    this.initialRotation = initialRotation;\r\n    setRotation(old_rot);\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.tokenizer.core.MMSegFilter.getMaximumMatchChunks",
	"Comment": "1. the maximum match rulethis rule will return the chunks that own the largest word length",
	"Method": "IChunk[] getMaximumMatchChunks(IChunk[] chunks){\r\n    int maxLength = chunks[0].getLength();\r\n    int j;\r\n    for (j = 1; j < chunks.length; j++) {\r\n        if (chunks[j].getLength() > maxLength)\r\n            maxLength = chunks[j].getLength();\r\n    }\r\n    ArrayList<IChunk> chunkArr = new ArrayList<IChunk>(chunks.length);\r\n    for (j = 0; j < chunks.length; j++) {\r\n        if (chunks[j].getLength() == maxLength) {\r\n            chunkArr.add(chunks[j]);\r\n        }\r\n    }\r\n    IChunk[] lchunk = new IChunk[chunkArr.size()];\r\n    chunkArr.toArray(lchunk);\r\n    chunkArr.clear();\r\n    return lchunk;\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.css.apply.MaxLeadingAndSize.getLargestFontFromChildren",
	"Comment": "iterates over all children in a list and returns the largest font size found.",
	"Method": "float getLargestFontFromChildren(List<Tag> children){\r\n    float largestFont = 12;\r\n    for (Tag tag : children) {\r\n        float fontSize = fontSizeTranslator.getFontSize(tag);\r\n        if (fontSize > largestFont) {\r\n            largestFont = fontSize;\r\n        }\r\n    }\r\n    return largestFont;\r\n}"
}, {
	"Path": "org.jbake.template.TemplateEngines.loadEngines",
	"Comment": "this method is used internally to load markup engines. markup engines are found using descriptor files onclasspath, so adding an engine is as easy as adding a jar on classpath with the descriptor file included.",
	"Method": "void loadEngines(JBakeConfiguration config,ContentStore db){\r\n    try {\r\n        ClassLoader cl = TemplateEngines.class.getClassLoader();\r\n        Enumeration<URL> resources = cl.getResources(\"META-INF/org.jbake.parser.TemplateEngines.properties\");\r\n        while (resources.hasMoreElements()) {\r\n            URL url = resources.nextElement();\r\n            Properties props = new Properties();\r\n            props.load(url.openStream());\r\n            for (Map.Entry<Object, Object> entry : props.entrySet()) {\r\n                String className = (String) entry.getKey();\r\n                String[] extensions = ((String) entry.getValue()).split(\",\");\r\n                registerEngine(config, db, className, extensions);\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        LOGGER.error(\"Error loading engines\", e);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.Version.getProduct",
	"Comment": "gets the product name.\titext group nv requests that you retain the itext producer line\tin every pdf that is created or manipulated using itext.",
	"Method": "String getProduct(){\r\n    return iText;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfArray.getAsIndirectObject",
	"Comment": "returns a pdfobject as a pdfindirectreference.the object corresponding to the specified index is retrieved.if it is a pdfindirectreference, it is cast down andreturned as such. otherwise null is returned.",
	"Method": "PdfIndirectReference getAsIndirectObject(int idx){\r\n    PdfIndirectReference ref = null;\r\n    PdfObject orig = getPdfObject(idx);\r\n    if (orig instanceof PdfIndirectReference)\r\n        ref = (PdfIndirectReference) orig;\r\n    return ref;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.XfdfReader.getFieldValue",
	"Comment": "gets the field value or null if the field does notexist or has no value defined.",
	"Method": "String getFieldValue(String name){\r\n    String field = fields.get(name);\r\n    if (field == null)\r\n        return null;\r\n    else\r\n        return field;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Fixture.getBody",
	"Comment": "get the parent body of this fixture. this is null if the fixture is not attached.",
	"Method": "Body getBody(){\r\n    return m_body;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.events.PdfPageEventForwarder.onParagraphEnd",
	"Comment": "called when a paragraph is written.\tparagraphposition will hold the height of the end of the\tparagraph.",
	"Method": "void onParagraphEnd(PdfWriter writer,Document document,float paragraphPosition){\r\n    for (PdfPageEvent event : events) {\r\n        event.onParagraphEnd(writer, document, paragraphPosition);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfLayer.setLanguage",
	"Comment": "specifies the language of the content controlled by thisoptional content group",
	"Method": "void setLanguage(String lang,boolean preferred){\r\n    PdfDictionary usage = getUsage();\r\n    PdfDictionary dic = new PdfDictionary();\r\n    dic.put(PdfName.LANG, new PdfString(lang, PdfObject.TEXT_UNICODE));\r\n    if (preferred)\r\n        dic.put(PdfName.PREFERRED, PdfName.ON);\r\n    usage.put(PdfName.LANGUAGE, dic);\r\n}"
}, {
	"Path": "com.itextpdf.text.Phrase.getInstance",
	"Comment": "gets a special kind of phrase that changes some characters into corresponding symbols.",
	"Method": "Phrase getInstance(String string,Phrase getInstance,int leading,String string,Phrase getInstance,int leading,String string,Font font){\r\n    Phrase p = new Phrase(true);\r\n    p.setLeading(leading);\r\n    p.font = font;\r\n    if (font.getFamily() != FontFamily.SYMBOL && font.getFamily() != FontFamily.ZAPFDINGBATS && font.getBaseFont() == null) {\r\n        int index;\r\n        while ((index = SpecialSymbol.index(string)) > -1) {\r\n            if (index > 0) {\r\n                String firstPart = string.substring(0, index);\r\n                p.add(new Chunk(firstPart, font));\r\n                string = string.substring(index);\r\n            }\r\n            Font symbol = new Font(FontFamily.SYMBOL, font.getSize(), font.getStyle(), font.getColor());\r\n            StringBuffer buf = new StringBuffer();\r\n            buf.append(SpecialSymbol.getCorrespondingSymbol(string.charAt(0)));\r\n            string = string.substring(1);\r\n            while (SpecialSymbol.index(string) == 0) {\r\n                buf.append(SpecialSymbol.getCorrespondingSymbol(string.charAt(0)));\r\n                string = string.substring(1);\r\n            }\r\n            p.add(new Chunk(buf.toString(), symbol));\r\n        }\r\n    }\r\n    if (string != null && string.length() != 0) {\r\n        p.add(new Chunk(string, font));\r\n    }\r\n    return p;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.setFixedRotation",
	"Comment": "set this body to have fixed rotation. this causes the mass to be reset.",
	"Method": "void setFixedRotation(boolean flag){\r\n    if (flag) {\r\n        m_flags |= e_fixedRotationFlag;\r\n    } else {\r\n        m_flags &= ~e_fixedRotationFlag;\r\n    }\r\n    resetMassData();\r\n}"
}, {
	"Path": "com.itextpdf.text.html.simpleparser.ChainedProperties.adjustFontSize",
	"Comment": "if the properties contain a font size, the size may need to\tbe adjusted based on font sizes higher in the hierarchy.",
	"Method": "void adjustFontSize(Map<String, String> attrs){\r\n    String value = attrs.get(HtmlTags.SIZE);\r\n    if (value == null)\r\n        return;\r\n    if (value.endsWith(\"pt\")) {\r\n        attrs.put(HtmlTags.SIZE, value.substring(0, value.length() - 2));\r\n        return;\r\n    }\r\n    String old = getProperty(HtmlTags.SIZE);\r\n    attrs.put(HtmlTags.SIZE, Integer.toString(HtmlUtilities.getIndexedFontSize(value, old)));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.shuffleSubsetNames",
	"Comment": "finds all the font subsets and changes the prefixes to somerandom values.",
	"Method": "int shuffleSubsetNames(){\r\n    int total = 0;\r\n    for (int k = 1; k < xrefObj.size(); ++k) {\r\n        PdfObject obj = getPdfObjectRelease(k);\r\n        if (obj == null || !obj.isDictionary())\r\n            continue;\r\n        PdfDictionary dic = (PdfDictionary) obj;\r\n        if (!existsName(dic, PdfName.TYPE, PdfName.FONT))\r\n            continue;\r\n        if (existsName(dic, PdfName.SUBTYPE, PdfName.TYPE1) || existsName(dic, PdfName.SUBTYPE, PdfName.MMTYPE1) || existsName(dic, PdfName.SUBTYPE, PdfName.TRUETYPE)) {\r\n            String s = getSubsetPrefix(dic);\r\n            if (s == null)\r\n                continue;\r\n            String ns = BaseFont.createSubsetPrefix() + s.substring(7);\r\n            PdfName newName = new PdfName(ns);\r\n            dic.put(PdfName.BASEFONT, newName);\r\n            setXrefPartialObject(k, dic);\r\n            ++total;\r\n            PdfDictionary fd = dic.getAsDict(PdfName.FONTDESCRIPTOR);\r\n            if (fd == null)\r\n                continue;\r\n            fd.put(PdfName.FONTNAME, newName);\r\n        } else if (existsName(dic, PdfName.SUBTYPE, PdfName.TYPE0)) {\r\n            String s = getSubsetPrefix(dic);\r\n            PdfArray arr = dic.getAsArray(PdfName.DESCENDANTFONTS);\r\n            if (arr == null)\r\n                continue;\r\n            if (arr.isEmpty())\r\n                continue;\r\n            PdfDictionary desc = arr.getAsDict(0);\r\n            String sde = getSubsetPrefix(desc);\r\n            if (sde == null)\r\n                continue;\r\n            String ns = BaseFont.createSubsetPrefix();\r\n            if (s != null)\r\n                dic.put(PdfName.BASEFONT, new PdfName(ns + s.substring(7)));\r\n            setXrefPartialObject(k, dic);\r\n            PdfName newName = new PdfName(ns + sde.substring(7));\r\n            desc.put(PdfName.BASEFONT, newName);\r\n            ++total;\r\n            PdfDictionary fd = desc.getAsDict(PdfName.FONTDESCRIPTOR);\r\n            if (fd == null)\r\n                continue;\r\n            fd.put(PdfName.FONTNAME, newName);\r\n        }\r\n    }\r\n    return total;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Barcode.setBaseline",
	"Comment": "sets the text baseline. if positive, the text distance under the bars. if zero or negative,the text distance above the bars.",
	"Method": "void setBaseline(float baseline){\r\n    this.baseline = baseline;\r\n}"
}, {
	"Path": "com.example.vision.Detect.detectHandwrittenOcrGcs",
	"Comment": "performs handwritten text detection on a remote image on google cloud storage.",
	"Method": "void detectHandwrittenOcrGcs(String gcsPath,PrintStream out){\r\n    List<AnnotateImageRequest> requests = new ArrayList();\r\n    ImageSource imgSource = ImageSource.newBuilder().setGcsImageUri(gcsPath).build();\r\n    Image img = Image.newBuilder().setSource(imgSource).build();\r\n    Feature feat = Feature.newBuilder().setType(Type.DOCUMENT_TEXT_DETECTION).build();\r\n    ImageContext imageContext = ImageContext.newBuilder().addLanguageHints(\"en-t-i0-handwrit\").build();\r\n    AnnotateImageRequest request = AnnotateImageRequest.newBuilder().addFeatures(feat).setImage(img).setImageContext(imageContext).build();\r\n    requests.add(request);\r\n    try (ImageAnnotatorClient client = ImageAnnotatorClient.create()) {\r\n        BatchAnnotateImagesResponse response = client.batchAnnotateImages(requests);\r\n        List<AnnotateImageResponse> responses = response.getResponsesList();\r\n        client.close();\r\n        for (AnnotateImageResponse res : responses) {\r\n            if (res.hasError()) {\r\n                out.printf(\"Error: %s\\n\", res.getError().getMessage());\r\n                return;\r\n            }\r\n            TextAnnotation annotation = res.getFullTextAnnotation();\r\n            for (Page page : annotation.getPagesList()) {\r\n                String pageText = \"\";\r\n                for (Block block : page.getBlocksList()) {\r\n                    String blockText = \"\";\r\n                    for (Paragraph para : block.getParagraphsList()) {\r\n                        String paraText = \"\";\r\n                        for (Word word : para.getWordsList()) {\r\n                            String wordText = \"\";\r\n                            for (Symbol symbol : word.getSymbolsList()) {\r\n                                wordText = wordText + symbol.getText();\r\n                                out.format(\"Symbol text: %s (confidence: %f)\\n\", symbol.getText(), symbol.getConfidence());\r\n                            }\r\n                            out.format(\"Word text: %s (confidence: %f)\\n\\n\", wordText, word.getConfidence());\r\n                            paraText = String.format(\"%s %s\", paraText, wordText);\r\n                        }\r\n                        out.println(\"\\nParagraph: \\n\" + paraText);\r\n                        out.format(\"Paragraph Confidence: %f\\n\", para.getConfidence());\r\n                        blockText = blockText + paraText;\r\n                    }\r\n                    pageText = pageText + blockText;\r\n                }\r\n            }\r\n            out.println(\"\\nComplete annotation:\");\r\n            out.println(annotation.getText());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.createParticleGroup",
	"Comment": "create a particle group whose properties have been defined. no reference to the definition isretained.",
	"Method": "ParticleGroup createParticleGroup(ParticleGroupDef def){\r\n    assert (isLocked() == false);\r\n    if (isLocked()) {\r\n        return null;\r\n    }\r\n    ParticleGroup g = m_particleSystem.createParticleGroup(def);\r\n    return g;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.TextRenderInfoTest.testUnicodeEmptyString",
	"Comment": "test introduced to exclude a bug related to a unicode quirk forjapanese. textrenderinfo threw an aioobe for some characters.",
	"Method": "void testUnicodeEmptyString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    String inFile = \"japanese_text.pdf\";\r\n    PdfReader p = TestResourceUtils.getResourceAsPdfReader(this, inFile);\r\n    TextExtractionStrategy strat = new SimpleTextExtractionStrategy();\r\n    sb.append(PdfTextExtractor.getTextFromPage(p, FIRST_PAGE, strat));\r\n    String result = sb.substring(0, sb.indexOf(\"\\n\"));\r\n    String origText = \"SP500\" + \"F\" + \"`SP\" + \"500\";\r\n    Assert.assertEquals(result, origText);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Fixture.setFilterData",
	"Comment": "set the contact filtering data. this is an expensive operation and should not be calledfrequently. this will not update contacts until the next time step when either parent body isawake. this automatically calls refilter.",
	"Method": "void setFilterData(Filter filter){\r\n    m_filter.set(filter);\r\n    refilter();\r\n}"
}, {
	"Path": "software.amazon.ion.impl.PrivateUtils.iterate",
	"Comment": "create a value iterator from a reader.primarily a trampoline for access permission.",
	"Method": "Iterator<IonValue> iterate(ValueFactory valueFactory,IonReader input){\r\n    return new IonIteratorImpl(valueFactory, input);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPTable.copyFormat",
	"Comment": "copies the format of the sourcetable without copying the content.",
	"Method": "void copyFormat(PdfPTable sourceTable){\r\n    rowsNotChecked = sourceTable.rowsNotChecked;\r\n    relativeWidths = new float[sourceTable.getNumberOfColumns()];\r\n    absoluteWidths = new float[sourceTable.getNumberOfColumns()];\r\n    System.arraycopy(sourceTable.relativeWidths, 0, relativeWidths, 0, getNumberOfColumns());\r\n    System.arraycopy(sourceTable.absoluteWidths, 0, absoluteWidths, 0, getNumberOfColumns());\r\n    totalWidth = sourceTable.totalWidth;\r\n    totalHeight = sourceTable.totalHeight;\r\n    currentColIdx = 0;\r\n    tableEvent = sourceTable.tableEvent;\r\n    runDirection = sourceTable.runDirection;\r\n    if (sourceTable.defaultCell instanceof PdfPHeaderCell) {\r\n        defaultCell = new PdfPHeaderCell((PdfPHeaderCell) sourceTable.defaultCell);\r\n    } else {\r\n        defaultCell = new PdfPCell(sourceTable.defaultCell);\r\n    }\r\n    currentRow = new PdfPCell[sourceTable.currentRow.length];\r\n    isColspan = sourceTable.isColspan;\r\n    splitRows = sourceTable.splitRows;\r\n    spacingAfter = sourceTable.spacingAfter;\r\n    spacingBefore = sourceTable.spacingBefore;\r\n    headerRows = sourceTable.headerRows;\r\n    footerRows = sourceTable.footerRows;\r\n    lockedWidth = sourceTable.lockedWidth;\r\n    extendLastRow = sourceTable.extendLastRow;\r\n    headersInEvent = sourceTable.headersInEvent;\r\n    widthPercentage = sourceTable.widthPercentage;\r\n    splitLate = sourceTable.splitLate;\r\n    skipFirstHeader = sourceTable.skipFirstHeader;\r\n    skipLastFooter = sourceTable.skipLastFooter;\r\n    horizontalAlignment = sourceTable.horizontalAlignment;\r\n    keepTogether = sourceTable.keepTogether;\r\n    complete = sourceTable.complete;\r\n    loopCheck = sourceTable.loopCheck;\r\n    id = sourceTable.id;\r\n    role = sourceTable.role;\r\n    if (sourceTable.accessibleAttributes != null) {\r\n        accessibleAttributes = new HashMap<PdfName, PdfObject>(sourceTable.accessibleAttributes);\r\n    }\r\n    header = sourceTable.getHeader();\r\n    body = sourceTable.getBody();\r\n    footer = sourceTable.getFooter();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.FilteredRenderListener.renderText",
	"Comment": "applies filters, then delegates to the delegate if all filters pass",
	"Method": "void renderText(TextRenderInfo renderInfo){\r\n    for (RenderFilter filter : filters) {\r\n        if (!filter.allowText(renderInfo))\r\n            return;\r\n    }\r\n    delegate.renderText(renderInfo);\r\n}"
}, {
	"Path": "com.google.cloud.vision.samples.label.LabelApp.getVisionService",
	"Comment": "connects to the vision api using application default credentials.",
	"Method": "Vision getVisionService(){\r\n    GoogleCredential credential = GoogleCredential.getApplicationDefault().createScoped(VisionScopes.all());\r\n    JsonFactory jsonFactory = JacksonFactory.getDefaultInstance();\r\n    return new Vision.Builder(GoogleNetHttpTransport.newTrustedTransport(), jsonFactory, credential).setApplicationName(APPLICATION_NAME).build();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaPresentation.setNavigationPane",
	"Comment": "sets a flag that indicates the default behavior of the navigation pane\tuser interface element. if true, the navigation pane is visible when\tthe content is initially activated. if false, the navigation pane is\tnot displayed by default.",
	"Method": "void setNavigationPane(PdfBoolean navigationPane){\r\n    put(PdfName.NAVIGATIONPANE, navigationPane);\r\n}"
}, {
	"Path": "com.sixt.service.framework.servicetest.mockservice.ServiceImpersonator.publishEventWithKey",
	"Comment": "publish an event to kafka. we create one publisher per topic.",
	"Method": "void publishEventWithKey(String topic,String key,Message event){\r\n    KafkaPublisher publisher = topicToPublisher.get(topic);\r\n    if (publisher == null) {\r\n        publisher = factory.newBuilder(topic).build();\r\n        topicToPublisher.put(topic, publisher);\r\n    }\r\n    String jsonEvent = ProtobufUtil.protobufToJson(event).toString();\r\n    boolean isPublished = publisher.publishSyncWithKey(key, jsonEvent);\r\n    if (isPublished) {\r\n        logger.info(\"Published event: {}\", jsonEvent);\r\n        new Sleeper().sleepNoException(sleepAfterPublish);\r\n    } else {\r\n        logger.warn(\"Publishing event message {} to Kafka topic {} failed\", jsonEvent, topic);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.awt.geom.gl.Crossing.isInsideNonZero",
	"Comment": "returns true if cross count correspond inside location for non zero path rule",
	"Method": "boolean isInsideNonZero(int cross){\r\n    return cross != 0;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfSignatureAppearance.setReuseAppearance",
	"Comment": "indicates that the existing appearances needs to be reused as layer 0.",
	"Method": "void setReuseAppearance(boolean reuseAppearance){\r\n    this.reuseAppearance = reuseAppearance;\r\n}"
}, {
	"Path": "com.google.cloud.language.samples.Analyze.main",
	"Comment": "detects entities,sentiment and syntax in a document using the natural language api.",
	"Method": "void main(String[] args){\r\n    if (args.length != 2) {\r\n        System.err.println(\"Usage:\");\r\n        System.err.printf(\"\\tjava %s \\\"command\\\" \\\"text to analyze\\\"\\n\", Analyze.class.getCanonicalName());\r\n        System.exit(1);\r\n    }\r\n    String command = args[0];\r\n    String text = args[1];\r\n    if (command.equals(\"classify\")) {\r\n        if (text.startsWith(\"gs://\")) {\r\n            classifyFile(text);\r\n        } else {\r\n            classifyText(text);\r\n        }\r\n    } else if (command.equals(\"entities\")) {\r\n        if (text.startsWith(\"gs://\")) {\r\n            analyzeEntitiesFile(text);\r\n        } else {\r\n            analyzeEntitiesText(text);\r\n        }\r\n    } else if (command.equals(\"sentiment\")) {\r\n        if (text.startsWith(\"gs://\")) {\r\n            analyzeSentimentFile(text);\r\n        } else {\r\n            analyzeSentimentText(text);\r\n        }\r\n    } else if (command.equals(\"syntax\")) {\r\n        if (text.startsWith(\"gs://\")) {\r\n            analyzeSyntaxFile(text);\r\n        } else {\r\n            analyzeSyntaxText(text);\r\n        }\r\n    } else if (command.equals(\"entities-sentiment\")) {\r\n        if (text.startsWith(\"gs://\")) {\r\n            entitySentimentFile(text);\r\n        } else {\r\n            entitySentimentText(text);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.isFixedRotation",
	"Comment": "should this body be prevented from rotating? useful for characters.",
	"Method": "boolean isFixedRotation(){\r\n    return fixedRotation;\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.html.table.Table.widenLastCell",
	"Comment": "adds horizontal border spacing to the right padding of the last cell of\teach row.",
	"Method": "void widenLastCell(List<TableRowElement> tableRows,float horBorderSpacing){\r\n    for (TableRowElement row : tableRows) {\r\n        List<HtmlCell> cells = row.getContent();\r\n        if (cells.size() < 1)\r\n            continue;\r\n        HtmlCell last = cells.get(cells.size() - 1);\r\n        last.getCellValues().setLastInRow(true);\r\n        last.setPaddingRight(last.getPaddingRight() + horBorderSpacing);\r\n    }\r\n}"
}, {
	"Path": "cn.mrdear.util.jniUtil.NativeLibraryLoader.loadLibrary",
	"Comment": "loads a native shared library. it tries the standard system.loadlibrary\tmethod first and if it fails, it looks for the library in the current\tclass path. it will handle libraries packed within jar files, too.",
	"Method": "void loadLibrary(String libraryName){\r\n    try {\r\n        System.loadLibrary(libraryName);\r\n    } catch (UnsatisfiedLinkError e) {\r\n        String fileName = System.mapLibraryName(libraryName);\r\n        int dotPosition = fileName.lastIndexOf('.');\r\n        File file = File.createTempFile(fileName.substring(0, dotPosition), fileName.substring(dotPosition));\r\n        file.deleteOnExit();\r\n        byte[] buffer = new byte[4096];\r\n        InputStream inputStream = NativeLibraryLoader.class.getClassLoader().getResourceAsStream(fileName);\r\n        OutputStream outputStream = new FileOutputStream(file);\r\n        try {\r\n            while (inputStream.available() > 0) {\r\n                int StreamLength = inputStream.read(buffer);\r\n                if (StreamLength >= 0) {\r\n                    outputStream.write(buffer, 0, StreamLength);\r\n                }\r\n            }\r\n        } finally {\r\n            outputStream.close();\r\n            inputStream.close();\r\n        }\r\n        System.load(file.getAbsolutePath());\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPNode.removeQualifiers",
	"Comment": "removes all qualifiers from the node and sets the options appropriate.",
	"Method": "void removeQualifiers(){\r\n    PropertyOptions opts = getOptions();\r\n    opts.setHasQualifiers(false);\r\n    opts.setHasLanguage(false);\r\n    opts.setHasType(false);\r\n    qualifier = null;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDeveloperExtension.getDeveloperExtensions",
	"Comment": "generations the developer extension dictionary corresponding\twith the prefix.",
	"Method": "PdfDictionary getDeveloperExtensions(){\r\n    PdfDictionary developerextensions = new PdfDictionary();\r\n    developerextensions.put(PdfName.BASEVERSION, baseversion);\r\n    developerextensions.put(PdfName.EXTENSIONLEVEL, new PdfNumber(extensionLevel));\r\n    return developerextensions;\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.css.StyleAttrCSSResolver.resolveStyles",
	"Comment": "also taking into account the css properties of any parent tag in the given tag.",
	"Method": "void resolveStyles(Tag t){\r\n    Map<String, String> tagCss = new LinkedHashMap<String, String>();\r\n    Map<String, String> listCss = null;\r\n    if (null != cssFiles && cssFiles.hasFiles()) {\r\n        tagCss = cssFiles.getCSS(t);\r\n        if (t.getName().equalsIgnoreCase(HTML.Tag.P) || t.getName().equalsIgnoreCase(HTML.Tag.TD)) {\r\n            listCss = cssFiles.getCSS(new Tag(HTML.Tag.UL));\r\n        }\r\n    }\r\n    if (null != t.getAttributes() && !t.getAttributes().isEmpty()) {\r\n        if (t.getAttributes().get(HTML.Attribute.CELLPADDING) != null) {\r\n            tagCss.putAll(utils.parseBoxValues(t.getAttributes().get(HTML.Attribute.CELLPADDING), \"cellpadding-\", \"\"));\r\n        }\r\n        if (t.getAttributes().get(HTML.Attribute.CELLSPACING) != null) {\r\n            tagCss.putAll(utils.parseBoxValues(t.getAttributes().get(HTML.Attribute.CELLSPACING), \"cellspacing-\", \"\"));\r\n        }\r\n        String styleAtt = t.getAttributes().get(HTML.Attribute.STYLE);\r\n        if (null != styleAtt && styleAtt.length() > 0) {\r\n            Map<String, String> tagAttrCss = new LinkedHashMap<String, String>();\r\n            String[] styles = styleAtt.split(\";\");\r\n            for (String s : styles) {\r\n                String[] part = s.split(\":\", 2);\r\n                if (part.length == 2) {\r\n                    String key = utils.stripDoubleSpacesTrimAndToLowerCase(part[0]);\r\n                    String value = utils.stripDoubleSpacesAndTrim(part[1]);\r\n                    splitRules(tagAttrCss, key, value);\r\n                }\r\n            }\r\n            for (Entry<String, String> e : tagAttrCss.entrySet()) {\r\n                tagCss.put(e.getKey(), e.getValue());\r\n            }\r\n        }\r\n    }\r\n    Map<String, String> css = t.getCSS();\r\n    if (t.getName() != null) {\r\n        if (t.getName().equalsIgnoreCase(HTML.Tag.I) || t.getName().equalsIgnoreCase(HTML.Tag.CITE) || t.getName().equalsIgnoreCase(HTML.Tag.EM) || t.getName().equalsIgnoreCase(HTML.Tag.VAR) || t.getName().equalsIgnoreCase(HTML.Tag.DFN) || t.getName().equalsIgnoreCase(HTML.Tag.ADDRESS)) {\r\n            tagCss.put(CSS.Property.FONT_STYLE, CSS.Value.ITALIC);\r\n        } else if (t.getName().equalsIgnoreCase(HTML.Tag.B) || t.getName().equalsIgnoreCase(HTML.Tag.STRONG)) {\r\n            tagCss.put(CSS.Property.FONT_WEIGHT, CSS.Value.BOLD);\r\n        } else if (t.getName().equalsIgnoreCase(HTML.Tag.U) || t.getName().equalsIgnoreCase(HTML.Tag.INS)) {\r\n            tagCss.put(CSS.Property.TEXT_DECORATION, CSS.Value.UNDERLINE);\r\n        } else if (t.getName().equalsIgnoreCase(HTML.Tag.S) || t.getName().equalsIgnoreCase(HTML.Tag.STRIKE) || t.getName().equalsIgnoreCase(HTML.Tag.DEL)) {\r\n            tagCss.put(CSS.Property.TEXT_DECORATION, CSS.Value.LINE_THROUGH);\r\n        } else if (t.getName().equalsIgnoreCase(HTML.Tag.BIG)) {\r\n            tagCss.put(CSS.Property.FONT_SIZE, CSS.Value.LARGER);\r\n        } else if (t.getName().equalsIgnoreCase(HTML.Tag.SMALL)) {\r\n            tagCss.put(CSS.Property.FONT_SIZE, CSS.Value.SMALLER);\r\n        }\r\n    }\r\n    if (listCss != null && listCss.containsKey(CSS.Property.LIST_STYLE_TYPE)) {\r\n        css.put(CSS.Property.LIST_STYLE_TYPE, listCss.get(CSS.Property.LIST_STYLE_TYPE));\r\n    }\r\n    if (mustInherit(t.getName()) && null != t.getParent() && null != t.getParent().getCSS()) {\r\n        if (null != this.inherit) {\r\n            for (Entry<String, String> entry : t.getParent().getCSS().entrySet()) {\r\n                String key = entry.getKey();\r\n                if ((tagCss.containsKey(key) && CSS.Value.INHERIT.equals(tagCss.get(key))) || canInherite(t, key)) {\r\n                    if (key.contains(CSS.Property.CELLPADDING) && (HTML.Tag.TD.equals(t.getName()) || HTML.Tag.TH.equals(t.getName()))) {\r\n                        String paddingKey = key.replace(CSS.Property.CELLPADDING, CSS.Property.PADDING);\r\n                        tagCss.put(paddingKey, entry.getValue());\r\n                    } else {\r\n                        css.put(key, entry.getValue());\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            css.putAll(t.getParent().getCSS());\r\n        }\r\n    }\r\n    if (t.getName() != null) {\r\n        if (t.getName().equals(HTML.Tag.FONT)) {\r\n            String font_family = t.getAttributes().get(HTML.Attribute.FACE);\r\n            if (font_family != null)\r\n                css.put(CSS.Property.FONT_FAMILY, font_family);\r\n            String color = t.getAttributes().get(HTML.Attribute.COLOR);\r\n            if (color != null)\r\n                css.put(CSS.Property.COLOR, color);\r\n            String size = t.getAttributes().get(HTML.Attribute.SIZE);\r\n            if (size != null) {\r\n                if (size.equals(\"1\"))\r\n                    css.put(CSS.Property.FONT_SIZE, CSS.Value.XX_SMALL);\r\n                else if (size.equals(\"2\"))\r\n                    css.put(CSS.Property.FONT_SIZE, CSS.Value.X_SMALL);\r\n                else if (size.equals(\"3\"))\r\n                    css.put(CSS.Property.FONT_SIZE, CSS.Value.SMALL);\r\n                else if (size.equals(\"4\"))\r\n                    css.put(CSS.Property.FONT_SIZE, CSS.Value.MEDIUM);\r\n                else if (size.equals(\"5\"))\r\n                    css.put(CSS.Property.FONT_SIZE, CSS.Value.LARGE);\r\n                else if (size.equals(\"6\"))\r\n                    css.put(CSS.Property.FONT_SIZE, CSS.Value.X_LARGE);\r\n                else if (size.equals(\"7\"))\r\n                    css.put(CSS.Property.FONT_SIZE, CSS.Value.XX_LARGE);\r\n            }\r\n        } else if (t.getName().equals(HTML.Tag.A)) {\r\n            css.put(CSS.Property.TEXT_DECORATION, CSS.Value.UNDERLINE);\r\n            css.put(CSS.Property.COLOR, \"blue\");\r\n        }\r\n    }\r\n    for (Entry<String, String> e : tagCss.entrySet()) {\r\n        if (!CSS.Value.INHERIT.equalsIgnoreCase(e.getValue())) {\r\n            if (e.getKey().equals(CSS.Property.TEXT_DECORATION)) {\r\n                String oldValue = css.get(e.getKey());\r\n                css.put(e.getKey(), mergeTextDecorationRules(oldValue, e.getValue()));\r\n            } else {\r\n                css.put(e.getKey(), e.getValue());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.example.cloud.iot.examples.MqttExample.attachCallback",
	"Comment": "attaches the callback used when configuration changes occur.",
	"Method": "void attachCallback(MqttClient client,String deviceId){\r\n    mCallback = new MqttCallback() {\r\n        @Override\r\n        public void connectionLost(Throwable cause) {\r\n        }\r\n        @Override\r\n        public void messageArrived(String topic, MqttMessage message) throws Exception {\r\n            String payload = new String(message.getPayload());\r\n            System.out.println(\"Payload : \" + payload);\r\n        }\r\n        @Override\r\n        public void deliveryComplete(IMqttDeliveryToken token) {\r\n        }\r\n    };\r\n    String configTopic = String.format(\"/devices/%s/config\", deviceId);\r\n    client.subscribe(configTopic, 1);\r\n    String commandTopic = String.format(\"/devices/%s/commands/#\", deviceId);\r\n    client.subscribe(commandTopic, 1);\r\n    client.setCallback(mCallback);\r\n}"
}, {
	"Path": "com.example.cloud.iot.examples.MqttExample.attachCallback",
	"Comment": "attaches the callback used when configuration changes occur.",
	"Method": "void attachCallback(MqttClient client,String deviceId){\r\n}"
}, {
	"Path": "com.example.cloud.iot.examples.MqttExample.attachCallback",
	"Comment": "attaches the callback used when configuration changes occur.",
	"Method": "void attachCallback(MqttClient client,String deviceId){\r\n    String payload = new String(message.getPayload());\r\n    System.out.println(\"Payload : \" + payload);\r\n}"
}, {
	"Path": "com.example.cloud.iot.examples.MqttExample.attachCallback",
	"Comment": "attaches the callback used when configuration changes occur.",
	"Method": "void attachCallback(MqttClient client,String deviceId){\r\n}"
}, {
	"Path": "com.itextpdf.awt.geom.GeneralPath.isInside",
	"Comment": "checks cross count according to path rule to define is it point inside shape or not.",
	"Method": "boolean isInside(int cross){\r\n    if (rule == WIND_NON_ZERO) {\r\n        return Crossing.isInsideNonZero(cross);\r\n    }\r\n    return Crossing.isInsideEvenOdd(cross);\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.html.pdfelement.NoNewLineParagraph.setKeepTogether",
	"Comment": "indicates that the paragraph has to be kept together on one page.",
	"Method": "void setKeepTogether(boolean keeptogether){\r\n    this.keeptogether = keeptogether;\r\n}"
}, {
	"Path": "software.amazon.ion.ListTest.testRemoveFromParsedListKeepsState",
	"Comment": "ensure that removal from a parsed list maintains its state.it can no longer share the same backing store.",
	"Method": "void testRemoveFromParsedListKeepsState(){\r\n    IonList value = (IonList) oneValue(\"[1]\");\r\n    IonInt elt = (IonInt) value.get(0);\r\n    value.remove(elt);\r\n    assertNull(elt.getContainer());\r\n    assertEquals(1, elt.intValue());\r\n}"
}, {
	"Path": "com.itextpdf.text.zugferd.checkers.CodeValidation.isLowercase",
	"Comment": "checks the length of a code and if a code consists of lowercase lettersfrom a to z.",
	"Method": "boolean isLowercase(String code,int chars){\r\n    if (code.length() != chars)\r\n        return false;\r\n    for (char c : code.toCharArray()) if (c < 97 || c > 122)\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.table.KeepRowsTogetherTest.testKeepRowsTogetherWithoutHeader",
	"Comment": "creates two tables and the second table should have one row on pae 1 and every other row on page 2.",
	"Method": "void testKeepRowsTogetherWithoutHeader(){\r\n    final String file = \"withoutheader.pdf\";\r\n    createDocument(file, 1, 10, \"Header for table 2 (should be on page 1, not a header, just first row)\", false, false);\r\n    compareDocuments(file);\r\n}"
}, {
	"Path": "com.example.Snippets.createAuthorizedClient",
	"Comment": "creates an authorized cloudkms client service using application default credentials.",
	"Method": "CloudKMS createAuthorizedClient(){\r\n    HttpTransport transport = new NetHttpTransport();\r\n    JsonFactory jsonFactory = new JacksonFactory();\r\n    GoogleCredential credential = GoogleCredential.getApplicationDefault(transport, jsonFactory);\r\n    if (credential.createScopedRequired()) {\r\n        credential = credential.createScoped(CloudKMSScopes.all());\r\n    }\r\n    return new CloudKMS.Builder(transport, jsonFactory, credential).setApplicationName(\"CloudKMS snippets\").build();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Barcode128.getBarsCode128Raw",
	"Comment": "generates the bars. the input has the actual barcodes, notthe human readable text.",
	"Method": "byte[] getBarsCode128Raw(String text){\r\n    int idx = text.indexOf('?');\r\n    if (idx >= 0)\r\n        text = text.substring(0, idx);\r\n    int chk = text.charAt(0);\r\n    for (int k = 1; k < text.length(); ++k) chk += k * text.charAt(k);\r\n    chk = chk % 103;\r\n    text += (char) chk;\r\n    byte[] bars = new byte[(text.length() + 1) * 6 + 7];\r\n    int k;\r\n    for (k = 0; k < text.length(); ++k) System.arraycopy(BARS[text.charAt(k)], 0, bars, k * 6, 6);\r\n    System.arraycopy(BARS_STOP, 0, bars, k * 6, 7);\r\n    return bars;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.BuildNewLGSubrs",
	"Comment": "function builds the new local & global subsrs indices. if cid then all of\tthe fd array lsubrs will be subsetted.",
	"Method": "void BuildNewLGSubrs(int Font){\r\n    if (fonts[Font].isCID) {\r\n        hSubrsUsed = new HashMap[fonts[Font].fdprivateOffsets.length];\r\n        lSubrsUsed = new ArrayList[fonts[Font].fdprivateOffsets.length];\r\n        NewLSubrsIndex = new byte[fonts[Font].fdprivateOffsets.length][];\r\n        fonts[Font].PrivateSubrsOffset = new int[fonts[Font].fdprivateOffsets.length];\r\n        fonts[Font].PrivateSubrsOffsetsArray = new int[fonts[Font].fdprivateOffsets.length][];\r\n        ArrayList<Integer> FDInList = new ArrayList<Integer>(FDArrayUsed);\r\n        for (int j = 0; j < FDInList.size(); j++) {\r\n            int FD = FDInList.get(j).intValue();\r\n            hSubrsUsed[FD] = new HashMap<Integer, int[]>();\r\n            lSubrsUsed[FD] = new ArrayList<Integer>();\r\n            BuildFDSubrsOffsets(Font, FD);\r\n            if (fonts[Font].PrivateSubrsOffset[FD] >= 0) {\r\n                BuildSubrUsed(Font, FD, fonts[Font].PrivateSubrsOffset[FD], fonts[Font].PrivateSubrsOffsetsArray[FD], hSubrsUsed[FD], lSubrsUsed[FD]);\r\n                NewLSubrsIndex[FD] = BuildNewIndex(fonts[Font].PrivateSubrsOffsetsArray[FD], hSubrsUsed[FD], RETURN_OP);\r\n            }\r\n        }\r\n    } else if (fonts[Font].privateSubrs >= 0) {\r\n        fonts[Font].SubrsOffsets = getIndex(fonts[Font].privateSubrs);\r\n        BuildSubrUsed(Font, -1, fonts[Font].privateSubrs, fonts[Font].SubrsOffsets, hSubrsUsedNonCID, lSubrsUsedNonCID);\r\n    }\r\n    BuildGSubrsUsed(Font);\r\n    if (fonts[Font].privateSubrs >= 0)\r\n        NewSubrsIndexNonCID = BuildNewIndex(fonts[Font].SubrsOffsets, hSubrsUsedNonCID, RETURN_OP);\r\n    NewGSubrsIndex = BuildNewIndexAndCopyAllGSubrs(gsubrOffsets, RETURN_OP);\r\n}"
}, {
	"Path": "com.structurizr.analysis.DefaultTypeRepository.getPackages",
	"Comment": "gets the packages that this type repository is associated with scanning.",
	"Method": "List<String> getPackages(){\r\n    return packagesToScan;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfSignatureAppearance.getLayer",
	"Comment": "gets a template layer to create a signature appearance. the layers can go from 0 to 4,but only layer 0 and 2 will be used if acro6layers is true.consult ppkappearances.pdffor further details.",
	"Method": "PdfTemplate getLayer(int layer){\r\n    if (layer < 0 || layer >= app.length)\r\n        return null;\r\n    PdfTemplate t = app[layer];\r\n    if (t == null) {\r\n        t = app[layer] = new PdfTemplate(writer);\r\n        t.setBoundingBox(rect);\r\n        writer.addDirectTemplateSimple(t, new PdfName(\"n\" + layer));\r\n    }\r\n    return t;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPTable.setHorizontalAlignment",
	"Comment": "sets the horizontal alignment of the table relative to the page. it onlyhas meaning if the width percentage is less than 100%.",
	"Method": "void setHorizontalAlignment(int horizontalAlignment){\r\n    this.horizontalAlignment = horizontalAlignment;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.util.TimeUtil.getTimeKey",
	"Comment": "get and return the time key part of the specified entity string",
	"Method": "String getTimeKey(String entity,String getTimeKey,IWord word,String getTimeKey,int pIdx){\r\n    if (pIdx < 0 || pIdx > 12) {\r\n        return null;\r\n    }\r\n    return KeyMap[pIdx];\r\n}"
}, {
	"Path": "com.structurizr.model.ContainerInstance.getHealthChecks",
	"Comment": "gets the set of health checks associated with this container instance.",
	"Method": "Set<HttpHealthCheck> getHealthChecks(){\r\n    return new HashSet(healthChecks);\r\n}"
}, {
	"Path": "com.itextpdf.text.RectangleReadOnly.setRotation",
	"Comment": "sets the rotation of the rectangle. valid values are 0, 90, 180, and 270.",
	"Method": "void setRotation(int rotation){\r\n    throwReadOnlyError();\r\n}"
}, {
	"Path": "org.jbox2d.collision.Collision.collidePolygonAndCircle",
	"Comment": "compute the collision manifold between a polygon and a circle.",
	"Method": "void collidePolygonAndCircle(Manifold manifold,PolygonShape polygon,Transform xfA,CircleShape circle,Transform xfB){\r\n    manifold.pointCount = 0;\r\n    final Vec2 circlep = circle.m_p;\r\n    final Rot xfBq = xfB.q;\r\n    final Rot xfAq = xfA.q;\r\n    final float cx = (xfBq.c * circlep.x - xfBq.s * circlep.y) + xfB.p.x;\r\n    final float cy = (xfBq.s * circlep.x + xfBq.c * circlep.y) + xfB.p.y;\r\n    final float px = cx - xfA.p.x;\r\n    final float py = cy - xfA.p.y;\r\n    final float cLocalx = (xfAq.c * px + xfAq.s * py);\r\n    final float cLocaly = (-xfAq.s * px + xfAq.c * py);\r\n    int normalIndex = 0;\r\n    float separation = -Float.MAX_VALUE;\r\n    final float radius = polygon.m_radius + circle.m_radius;\r\n    final int vertexCount = polygon.m_count;\r\n    float s;\r\n    final Vec2[] vertices = polygon.m_vertices;\r\n    final Vec2[] normals = polygon.m_normals;\r\n    for (int i = 0; i < vertexCount; i++) {\r\n        final Vec2 vertex = vertices[i];\r\n        final float tempx = cLocalx - vertex.x;\r\n        final float tempy = cLocaly - vertex.y;\r\n        s = normals[i].x * tempx + normals[i].y * tempy;\r\n        if (s > radius) {\r\n            return;\r\n        }\r\n        if (s > separation) {\r\n            separation = s;\r\n            normalIndex = i;\r\n        }\r\n    }\r\n    final int vertIndex1 = normalIndex;\r\n    final int vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;\r\n    final Vec2 v1 = vertices[vertIndex1];\r\n    final Vec2 v2 = vertices[vertIndex2];\r\n    if (separation < Settings.EPSILON) {\r\n        manifold.pointCount = 1;\r\n        manifold.type = ManifoldType.FACE_A;\r\n        final Vec2 normal = normals[normalIndex];\r\n        manifold.localNormal.x = normal.x;\r\n        manifold.localNormal.y = normal.y;\r\n        manifold.localPoint.x = (v1.x + v2.x) * .5f;\r\n        manifold.localPoint.y = (v1.y + v2.y) * .5f;\r\n        final ManifoldPoint mpoint = manifold.points[0];\r\n        mpoint.localPoint.x = circlep.x;\r\n        mpoint.localPoint.y = circlep.y;\r\n        mpoint.id.zero();\r\n        return;\r\n    }\r\n    final float tempX = cLocalx - v1.x;\r\n    final float tempY = cLocaly - v1.y;\r\n    final float temp2X = v2.x - v1.x;\r\n    final float temp2Y = v2.y - v1.y;\r\n    final float u1 = tempX * temp2X + tempY * temp2Y;\r\n    final float temp3X = cLocalx - v2.x;\r\n    final float temp3Y = cLocaly - v2.y;\r\n    final float temp4X = v1.x - v2.x;\r\n    final float temp4Y = v1.y - v2.y;\r\n    final float u2 = temp3X * temp4X + temp3Y * temp4Y;\r\n    if (u1 <= 0f) {\r\n        final float dx = cLocalx - v1.x;\r\n        final float dy = cLocaly - v1.y;\r\n        if (dx * dx + dy * dy > radius * radius) {\r\n            return;\r\n        }\r\n        manifold.pointCount = 1;\r\n        manifold.type = ManifoldType.FACE_A;\r\n        manifold.localNormal.x = cLocalx - v1.x;\r\n        manifold.localNormal.y = cLocaly - v1.y;\r\n        manifold.localNormal.normalize();\r\n        manifold.localPoint.set(v1);\r\n        manifold.points[0].localPoint.set(circlep);\r\n        manifold.points[0].id.zero();\r\n    } else if (u2 <= 0.0f) {\r\n        final float dx = cLocalx - v2.x;\r\n        final float dy = cLocaly - v2.y;\r\n        if (dx * dx + dy * dy > radius * radius) {\r\n            return;\r\n        }\r\n        manifold.pointCount = 1;\r\n        manifold.type = ManifoldType.FACE_A;\r\n        manifold.localNormal.x = cLocalx - v2.x;\r\n        manifold.localNormal.y = cLocaly - v2.y;\r\n        manifold.localNormal.normalize();\r\n        manifold.localPoint.set(v2);\r\n        manifold.points[0].localPoint.set(circlep);\r\n        manifold.points[0].id.zero();\r\n    } else {\r\n        final float fcx = (v1.x + v2.x) * .5f;\r\n        final float fcy = (v1.y + v2.y) * .5f;\r\n        final float tx = cLocalx - fcx;\r\n        final float ty = cLocaly - fcy;\r\n        final Vec2 normal = normals[vertIndex1];\r\n        separation = tx * normal.x + ty * normal.y;\r\n        if (separation > radius) {\r\n            return;\r\n        }\r\n        manifold.pointCount = 1;\r\n        manifold.type = ManifoldType.FACE_A;\r\n        manifold.localNormal.set(normals[vertIndex1]);\r\n        manifold.localPoint.x = fcx;\r\n        manifold.localPoint.y = fcy;\r\n        manifold.points[0].localPoint.set(circlep);\r\n        manifold.points[0].id.zero();\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.SignaturePermissions.getFieldLocks",
	"Comment": "getter for the field lock actions, and fields that are impacted by the action",
	"Method": "List<FieldLock> getFieldLocks(){\r\n    return fieldLocks;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDictionary.getAsIndirectObject",
	"Comment": "returns a pdfobject as a pdfindirectreference.the object associated with the pdfname given is retrievedif it is a pdfindirectreference, it is cast down and returnedas such. otherwise null is returned.",
	"Method": "PdfIndirectReference getAsIndirectObject(PdfName key){\r\n    PdfIndirectReference ref = null;\r\n    PdfObject orig = get(key);\r\n    if (orig != null && orig.isIndirect())\r\n        ref = (PdfIndirectReference) orig;\r\n    return ref;\r\n}"
}, {
	"Path": "com.itextpdf.text.zugferd.checkers.CodeValidation.isNumeric",
	"Comment": "checks the length of a code and if a code consists of numbers only.",
	"Method": "boolean isNumeric(String code,int digits){\r\n    if (code.length() != digits)\r\n        return false;\r\n    for (char c : code.toCharArray()) if (c < 48 || c > 57)\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "com.example.monitoring.Snippets.listTimeSeriesReduce",
	"Comment": "demonstrates listing time series and aggregating and reducing them.",
	"Method": "void listTimeSeriesReduce(){\r\n    MetricServiceClient metricServiceClient = MetricServiceClient.create();\r\n    String projectId = System.getProperty(\"projectId\");\r\n    ProjectName name = ProjectName.of(projectId);\r\n    long startMillis = System.currentTimeMillis() - ((60 * 20) * 1000);\r\n    TimeInterval interval = TimeInterval.newBuilder().setStartTime(Timestamps.fromMillis(startMillis)).setEndTime(Timestamps.fromMillis(System.currentTimeMillis())).build();\r\n    Aggregation aggregation = Aggregation.newBuilder().setAlignmentPeriod(Duration.newBuilder().setSeconds(600).build()).setPerSeriesAligner(Aggregation.Aligner.ALIGN_MEAN).setCrossSeriesReducer(Aggregation.Reducer.REDUCE_MEAN).build();\r\n    ListTimeSeriesRequest.Builder requestBuilder = ListTimeSeriesRequest.newBuilder().setName(name.toString()).setFilter(\"metric.type=\\\"compute.googleapis.com/instance/cpu/utilization\\\"\").setInterval(interval).setAggregation(aggregation);\r\n    ListTimeSeriesRequest request = requestBuilder.build();\r\n    ListTimeSeriesPagedResponse response = metricServiceClient.listTimeSeries(request);\r\n    System.out.println(\"Got timeseries: \");\r\n    for (TimeSeries ts : response.iterateAll()) {\r\n        System.out.println(ts);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.XfaForm.getXfaObject",
	"Comment": "return the xfa object, could be an array, could be a stream.returns null f no xfa object is present.",
	"Method": "PdfObject getXfaObject(PdfReader reader){\r\n    PdfDictionary af = (PdfDictionary) PdfReader.getPdfObjectRelease(reader.getCatalog().get(PdfName.ACROFORM));\r\n    if (af == null) {\r\n        return null;\r\n    }\r\n    return PdfReader.getPdfObjectRelease(af.get(PdfName.XFA));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.isUserProperties",
	"Comment": "gets the flag indicating the presence of structure elements that contain user properties attributes.",
	"Method": "boolean isUserProperties(){\r\n    return this.userProperties;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BidiOrder.removeExplicitCodes",
	"Comment": "rules x9.remove explicit codes so that they may be ignored during the remainderof the main portion of the algorithm.the length of the resulting textis returned.",
	"Method": "int removeExplicitCodes(){\r\n    int w = 0;\r\n    for (int i = 0; i < textLength; ++i) {\r\n        byte t = initialTypes[i];\r\n        if (!(t == LRE || t == RLE || t == LRO || t == RLO || t == PDF || t == BN)) {\r\n            embeddings[w] = embeddings[i];\r\n            resultTypes[w] = resultTypes[i];\r\n            resultLevels[w] = resultLevels[i];\r\n            w++;\r\n        }\r\n    }\r\n    return w;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.setContactListener",
	"Comment": "register a contact event listener. the listener is owned by you and must remain in scope.",
	"Method": "void setContactListener(ContactListener listener){\r\n    m_contactManager.m_contactListener = listener;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.Path.replaceCloseWithLine",
	"Comment": "adds additional line to each closed subpath and makes the subpath unclosed.the line connects the last and the first points of the subpaths.",
	"Method": "List<Integer> replaceCloseWithLine(){\r\n    List<Integer> modifiedSubpathsIndices = new ArrayList<Integer>();\r\n    int i = 0;\r\n    for (Subpath subpath : subpaths) {\r\n        if (subpath.isClosed()) {\r\n            subpath.setClosed(false);\r\n            subpath.addSegment(new Line(subpath.getLastPoint(), subpath.getStartPoint()));\r\n            modifiedSubpathsIndices.add(i);\r\n        }\r\n        ++i;\r\n    }\r\n    return modifiedSubpathsIndices;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONArray.toJSONObject",
	"Comment": "produce a jsonobject by combining a jsonarray of names with the values ofthis jsonarray.",
	"Method": "JSONObject toJSONObject(JSONArray names){\r\n    if (names == null || names.length() == 0 || this.length() == 0) {\r\n        return null;\r\n    }\r\n    JSONObject jo = new JSONObject();\r\n    for (int i = 0; i < names.length(); i += 1) {\r\n        jo.put(names.getString(i), this.opt(i));\r\n    }\r\n    return jo;\r\n}"
}, {
	"Path": "com.sixt.service.framework.kafka.KafkaPublisher.publishSyncWithKey",
	"Comment": "synchronously publish one or more messages with the specified partition key",
	"Method": "boolean publishSyncWithKey(String key,String events){\r\n    if (events != null) {\r\n        return publishEvents(true, key, events);\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.FixtureDef.setSensor",
	"Comment": "a sensor shape collects contact information but never generates a collision response.",
	"Method": "void setSensor(boolean isSensor){\r\n    this.isSensor = isSensor;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDictionary.getAsString",
	"Comment": "returns a pdfobject as a pdfstring,resolving indirect references.the object associated with the pdfname given is retrievedand resolved to a direct object.if it is a pdfstring, it is cast down and returned as such.otherwise null is returned.",
	"Method": "PdfString getAsString(PdfName key){\r\n    PdfString string = null;\r\n    PdfObject orig = getDirectObject(key);\r\n    if (orig != null && orig.isString())\r\n        string = (PdfString) orig;\r\n    return string;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentByte.moveText",
	"Comment": "moves to the start of the next line, offset from the start of the current line.",
	"Method": "void moveText(float x,float y){\r\n    if (!inText && isTagged()) {\r\n        beginText(true);\r\n    }\r\n    state.xTLM += x;\r\n    state.yTLM += y;\r\n    if (isTagged() && state.xTLM != state.tx) {\r\n        setTextMatrix(state.aTLM, state.bTLM, state.cTLM, state.dTLM, state.xTLM, state.yTLM);\r\n    } else {\r\n        content.append(x).append(' ').append(y).append(\" Td\").append_i(separator);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfSignatureAppearance.getPageRect",
	"Comment": "gets the rectangle that represent the position and dimension of the signature in the page.",
	"Method": "Rectangle getPageRect(){\r\n    return pageRect;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.IonRawBinaryWriter.writeBytes",
	"Comment": "writes a raw value into the buffer, updating lengths appropriately.the implication here is that the caller is dumping some valid ion payload with the correct context.",
	"Method": "void writeBytes(byte[] data,int offset,int length){\r\n    prepareValue();\r\n    updateLength(length);\r\n    buffer.writeBytes(data, offset, length);\r\n    finishValue();\r\n}"
}, {
	"Path": "com.google.cloud.language.samples.PredictionApi.predict",
	"Comment": "demonstrates using the automl client to classify the text content",
	"Method": "void predict(String projectId,String computeRegion,String modelId,String filePath){\r\n    PredictionServiceClient predictionClient = PredictionServiceClient.create();\r\n    ModelName name = ModelName.of(projectId, computeRegion, modelId);\r\n    String content = new String(Files.readAllBytes(Paths.get(filePath)));\r\n    TextSnippet textSnippet = TextSnippet.newBuilder().setContent(content).setMimeType(\"text/plain\").build();\r\n    ExamplePayload payload = ExamplePayload.newBuilder().setTextSnippet(textSnippet).build();\r\n    Map<String, String> params = new HashMap<String, String>();\r\n    PredictResponse response = predictionClient.predict(name, payload, params);\r\n    System.out.println(\"Prediction results:\");\r\n    for (AnnotationPayload annotationPayload : response.getPayloadList()) {\r\n        System.out.println(\"Predicted Class name :\" + annotationPayload.getDisplayName());\r\n        System.out.println(\"Predicted Class Score :\" + annotationPayload.getClassification().getScore());\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPTable.resetColumnCount",
	"Comment": "changes the number of columns. any existing rows will be deleted.",
	"Method": "void resetColumnCount(int newColCount){\r\n    if (newColCount <= 0) {\r\n        throw new IllegalArgumentException(MessageLocalization.getComposedMessage(\"the.number.of.columns.in.pdfptable.constructor.must.be.greater.than.zero\"));\r\n    }\r\n    relativeWidths = new float[newColCount];\r\n    for (int k = 0; k < newColCount; ++k) {\r\n        relativeWidths[k] = 1;\r\n    }\r\n    absoluteWidths = new float[relativeWidths.length];\r\n    calculateWidths();\r\n    currentRow = new PdfPCell[absoluteWidths.length];\r\n    totalHeight = 0;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.lockLayer",
	"Comment": "use this method to lock an optional content group.the state of a locked group cannot be changed through the user interfaceof a viewer application. producers can use this entry to prevent the visibilityof content that depends on these groups from being changed by users.",
	"Method": "void lockLayer(PdfLayer layer){\r\n    OCGLocked.add(layer.getRef());\r\n}"
}, {
	"Path": "com.itextpdf.text.List.getPostSymbol",
	"Comment": "returns the string that is after a number or letter in the list symbol.",
	"Method": "String getPostSymbol(){\r\n    return postSymbol;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.tokenizer.SearchSeg.getNextCJKWord",
	"Comment": "get the next cjk word from the current position of the input streamand this function is the core part the most segmentation implements",
	"Method": "IWord getNextCJKWord(int c,int pos){\r\n    String key = null;\r\n    char[] chars = nextCJKSentence(c);\r\n    int cjkidx = 0, ignidx = 0, mnum = 0;\r\n    IWord word = null;\r\n    ArrayList<IWord> mList = new ArrayList<IWord>(8);\r\n    while (cjkidx < chars.length) {\r\n        String sstr = String.valueOf(chars[cjkidx]);\r\n        if (dic.match(ILexicon.CJK_WORD, sstr)) {\r\n            IWord sWord = dic.get(ILexicon.CJK_WORD, sstr).clone();\r\n            sWord.setPosition(pos + cjkidx);\r\n            mList.add(sWord);\r\n        }\r\n        mnum = 0;\r\n        isb.clear().append(chars[cjkidx]);\r\n        for (int j = 1; j < config.MAX_LENGTH && (cjkidx + j) < chars.length; j++) {\r\n            isb.append(chars[cjkidx + j]);\r\n            key = isb.toString();\r\n            if (dic.match(ILexicon.CJK_WORD, key)) {\r\n                mnum = 1;\r\n                ignidx = Math.max(ignidx, cjkidx + j);\r\n                word = dic.get(ILexicon.CJK_WORD, key).clone();\r\n                word.setPosition(pos + cjkidx);\r\n                mList.add(word);\r\n            }\r\n        }\r\n        if (mnum == 0 && (cjkidx == 0 || cjkidx > ignidx)) {\r\n            String temp = String.valueOf(chars[cjkidx]);\r\n            if (!dic.match(ILexicon.CJK_WORD, temp)) {\r\n                word = new Word(temp, ILexicon.UNMATCH_CJK_WORD);\r\n                word.setPosition(pos + cjkidx);\r\n                mList.add(word);\r\n            }\r\n        }\r\n        cjkidx++;\r\n    }\r\n    for (IWord w : mList) {\r\n        key = w.getValue();\r\n        if (config.CLEAR_STOPWORD && dic.match(ILexicon.STOP_WORD, key)) {\r\n            continue;\r\n        }\r\n        wordPool.add(w);\r\n        appendWordFeatures(w);\r\n    }\r\n    mList.clear();\r\n    mList = null;\r\n    return wordPool.size() == 0 ? null : wordPool.remove();\r\n}"
}, {
	"Path": "com.itextpdf.awt.geom.PolylineShape.intersects",
	"Comment": "checks if one of the lines in the polyline intersects\twith a given rectangle.",
	"Method": "boolean intersects(double x,double y,double w,double h,boolean intersects,Rectangle2D r){\r\n    if (np == 0)\r\n        return false;\r\n    Line2D line = new Line2D.Double(x[0], y[0], x[0], y[0]);\r\n    for (int i = 1; i < np; i++) {\r\n        line.setLine(x[i - 1], y[i - 1], x[i], y[i]);\r\n        if (line.intersects(r))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.draw.DottedLineSeparator.getGap",
	"Comment": "getter for the gap between the center of the dots of the dotted line.",
	"Method": "float getGap(){\r\n    return gap;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.EmbedBuilder.appendDescription",
	"Comment": "appends to the description of the embed. this is where the main chunk of text for an embed is typically placed.example",
	"Method": "EmbedBuilder appendDescription(CharSequence description){\r\n    Checks.notNull(description, \"description\");\r\n    Checks.check(this.description.length() + description.length() <= MessageEmbed.TEXT_MAX_LENGTH, \"Description cannot be longer than %d characters.\", MessageEmbed.TEXT_MAX_LENGTH);\r\n    this.description.append(description);\r\n    return this;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.UnifiedInputStreamX.getPosition",
	"Comment": "used to find the current position of this stream in theinput source.",
	"Method": "long getPosition(){\r\n    long file_pos = 0;\r\n    UnifiedDataPageX page = _buffer.getCurrentPage();\r\n    if (page != null) {\r\n        file_pos = page.getFilePosition(_pos);\r\n    }\r\n    return file_pos;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.isBullet",
	"Comment": "is this body treated like a bullet for continuous collision detection?",
	"Method": "boolean isBullet(){\r\n    return (m_flags & e_bulletFlag) == e_bulletFlag;\r\n}"
}, {
	"Path": "com.google.cloud.language.samples.AnalyzeBeta.classifyFile",
	"Comment": "detects categories in a gcs hosted file using the language beta api.",
	"Method": "void classifyFile(String gcsUri){\r\n    try (LanguageServiceClient language = LanguageServiceClient.create()) {\r\n        Document doc = Document.newBuilder().setGcsContentUri(gcsUri).setType(Type.PLAIN_TEXT).build();\r\n        ClassifyTextRequest request = ClassifyTextRequest.newBuilder().setDocument(doc).build();\r\n        ClassifyTextResponse response = language.classifyText(request);\r\n        for (ClassificationCategory category : response.getCategoriesList()) {\r\n            System.out.printf(\"Category name : %s, Confidence : %.3f\\n\", category.getName(), category.getConfidence());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONArray.optJSONObject",
	"Comment": "get the optional jsonobject associated with an index. null is returned ifthe key is not found, or null if the index has no value, or if the valueis not a jsonobject.",
	"Method": "JSONObject optJSONObject(int index){\r\n    Object o = this.opt(index);\r\n    return o instanceof JSONObject ? (JSONObject) o : null;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONArray.optInt",
	"Comment": "get the optional int value associated with an index. the defaultvalue isreturned if there is no value for the index, or if the value is not anumber and cannot be converted to a number.",
	"Method": "int optInt(int index,int optInt,int index,int defaultValue){\r\n    try {\r\n        return this.getInt(index);\r\n    } catch (Exception e) {\r\n        return defaultValue;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.html.simpleparser.CellWrapper.add",
	"Comment": "implements the add method of the textelementarray interface.",
	"Method": "boolean add(Element o){\r\n    cell.addElement(o);\r\n    return true;\r\n}"
}, {
	"Path": "com.google.datastore.snippets.ConceptsTest.setUp",
	"Comment": "initializes datastore and cleans out any residual values.also initializes global variablesused for testing.",
	"Method": "void setUp(){\r\n    datastore = HELPER.getOptions().toBuilder().setNamespace(\"ghijklmnop\").build().getService();\r\n    StructuredQuery<Key> query = Query.newKeyQueryBuilder().build();\r\n    QueryResults<Key> result = datastore.run(query);\r\n    datastore.delete(Iterators.toArray(result, Key.class));\r\n    keyFactory = datastore.newKeyFactory().setKind(\"Task\");\r\n    taskKey = keyFactory.newKey(\"some-arbitrary-key\");\r\n    testEntity = Entity.newBuilder(taskKey, TEST_FULL_ENTITY).build();\r\n    Calendar calendar = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\r\n    calendar.set(1990, JANUARY, 1);\r\n    startDate = Timestamp.of(calendar.getTime());\r\n    calendar.set(2000, JANUARY, 1);\r\n    endDate = Timestamp.of(calendar.getTime());\r\n    calendar.set(1999, DECEMBER, 31);\r\n    includedDate = Timestamp.of(calendar.getTime());\r\n}"
}, {
	"Path": "com.structurizr.view.ElementStyle.getMetadata",
	"Comment": "determines whether the element metadata should be shown or not.",
	"Method": "Boolean getMetadata(){\r\n    return metadata;\r\n}"
}, {
	"Path": "com.structurizr.documentation.Documentation.getTemplate",
	"Comment": "gets the template metadata associated with this documentation.",
	"Method": "TemplateMetadata getTemplate(){\r\n    return template;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BarcodePDF417.getErrorLevel",
	"Comment": "gets the error level correction used for the barcode. it may differentfrom the previously set value.",
	"Method": "int getErrorLevel(){\r\n    return this.errorLevel;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.mc.MCParser.printsp",
	"Comment": "writes a pdf object to the outputstream, followed by a space character.",
	"Method": "void printsp(PdfObject o){\r\n    checkBT();\r\n    o.toPdf(null, baos);\r\n    baos.write(' ');\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPageLabels.removePageLabel",
	"Comment": "removes a page label. the first page label can not be removed, only changed.",
	"Method": "void removePageLabel(int page){\r\n    if (page <= 1)\r\n        return;\r\n    map.remove(Integer.valueOf(page - 1));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.PdfReaderContentParser.processContent",
	"Comment": "processes content from the specified page number using the specified listener",
	"Method": "E processContent(int pageNumber,E renderListener,Map<String, ContentOperator> additionalContentOperators,E processContent,int pageNumber,E renderListener){\r\n    return processContent(pageNumber, renderListener, new HashMap<String, ContentOperator>());\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.RandomAccessFileOrArray.readString",
	"Comment": "reads a string from the font file as bytes using the given encoding.",
	"Method": "String readString(int length,String encoding){\r\n    byte[] buf = new byte[length];\r\n    readFully(buf);\r\n    try {\r\n        return new String(buf, encoding);\r\n    } catch (Exception e) {\r\n        throw new ExceptionConverter(e);\r\n    }\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONArray.optLong",
	"Comment": "get the optional long value associated with an index. the defaultvalue isreturned if there is no value for the index, or if the value is not anumber and cannot be converted to a number.",
	"Method": "long optLong(int index,long optLong,int index,long defaultValue){\r\n    try {\r\n        return this.getLong(index);\r\n    } catch (Exception e) {\r\n        return defaultValue;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.computeUserPassword",
	"Comment": "computes user password if standard encryption handler is used with standard40, standard128 or aes128 encryption algorithm.",
	"Method": "byte[] computeUserPassword(){\r\n    if (!encrypted || !ownerPasswordUsed)\r\n        return null;\r\n    return decrypt.computeUserPassword(password);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStamper.insertPage",
	"Comment": "inserts a blank page. all the pages above and including pagenumber willbe shifted up. if pagenumber is bigger than the total number of pagesthe new page will be the last one.",
	"Method": "void insertPage(int pageNumber,Rectangle mediabox){\r\n    stamper.insertPage(pageNumber, mediabox);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Type1Font.getFontDescriptor",
	"Comment": "gets the font parameter identified by key. valid valuesfor key are ascent, capheight, descent,italicangle, bboxllx, bboxlly, bboxurxand bboxury.",
	"Method": "PdfDictionary getFontDescriptor(PdfIndirectReference fontStream,float getFontDescriptor,int key,float fontSize){\r\n    switch(key) {\r\n        case AWT_ASCENT:\r\n        case ASCENT:\r\n            return Ascender * fontSize / 1000;\r\n        case CAPHEIGHT:\r\n            return CapHeight * fontSize / 1000;\r\n        case AWT_DESCENT:\r\n        case DESCENT:\r\n            return Descender * fontSize / 1000;\r\n        case ITALICANGLE:\r\n            return ItalicAngle;\r\n        case BBOXLLX:\r\n            return llx * fontSize / 1000;\r\n        case BBOXLLY:\r\n            return lly * fontSize / 1000;\r\n        case BBOXURX:\r\n            return urx * fontSize / 1000;\r\n        case BBOXURY:\r\n            return ury * fontSize / 1000;\r\n        case AWT_LEADING:\r\n            return 0;\r\n        case AWT_MAXADVANCE:\r\n            return (urx - llx) * fontSize / 1000;\r\n        case UNDERLINE_POSITION:\r\n            return UnderlinePosition * fontSize / 1000;\r\n        case UNDERLINE_THICKNESS:\r\n            return UnderlineThickness * fontSize / 1000;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPUtilsImpl.removeSchemaChildren",
	"Comment": "remove all schema children according to the flag\tdoallproperties. empty schemas are automatically remove\tby xmpnode",
	"Method": "boolean removeSchemaChildren(XMPNode schemaNode,boolean doAllProperties){\r\n    for (Iterator it = schemaNode.iterateChildren(); it.hasNext(); ) {\r\n        XMPNode currProp = (XMPNode) it.next();\r\n        if (doAllProperties || !Utils.isInternalProperty(schemaNode.getName(), currProp.getName())) {\r\n            it.remove();\r\n        }\r\n    }\r\n    return !schemaNode.hasChildren();\r\n}"
}, {
	"Path": "com.example.appengine.firetactoe.ObjectifyHelper.contextInitialized",
	"Comment": "this will be invoked as part of a warmup request, or the first user request if no warmuprequest.",
	"Method": "void contextInitialized(ServletContextEvent event){\r\n    ObjectifyService.register(Game.class);\r\n}"
}, {
	"Path": "com.google.cloud.language.samples.ModelApi.displayEvaluation",
	"Comment": "demonstrates using the automl client to display model evaluation.",
	"Method": "void displayEvaluation(String projectId,String computeRegion,String modelId,String filter){\r\n    AutoMlClient client = AutoMlClient.create();\r\n    ModelName modelFullId = ModelName.of(projectId, computeRegion, modelId);\r\n    ListModelEvaluationsRequest modelEvaluationsrequest = ListModelEvaluationsRequest.newBuilder().setParent(modelFullId.toString()).setFilter(filter).build();\r\n    String modelEvaluationId = \"\";\r\n    for (ModelEvaluation element : client.listModelEvaluations(modelEvaluationsrequest).iterateAll()) {\r\n        if (element.getAnnotationSpecId() != null) {\r\n            modelEvaluationId = element.getName().split(\"/\")[element.getName().split(\"/\").length - 1];\r\n        }\r\n    }\r\n    ModelEvaluationName modelEvaluationFullId = ModelEvaluationName.of(projectId, computeRegion, modelId, modelEvaluationId);\r\n    ModelEvaluation modelEvaluation = client.getModelEvaluation(modelEvaluationFullId);\r\n    ClassificationEvaluationMetrics classMetrics = modelEvaluation.getClassificationEvaluationMetrics();\r\n    List<ConfidenceMetricsEntry> confidenceMetricsEntries = classMetrics.getConfidenceMetricsEntryList();\r\n    for (ConfidenceMetricsEntry confidenceMetricsEntry : confidenceMetricsEntries) {\r\n        if (confidenceMetricsEntry.getConfidenceThreshold() == 0.5) {\r\n            System.out.println(\"Precision and recall are based on a score threshold of 0.5\");\r\n            System.out.println(String.format(\"Model Precision: %.2f \", confidenceMetricsEntry.getPrecision() * 100) + '%');\r\n            System.out.println(String.format(\"Model Recall: %.2f \", confidenceMetricsEntry.getRecall() * 100) + '%');\r\n            System.out.println(String.format(\"Model F1 Score: %.2f \", confidenceMetricsEntry.getF1Score() * 100) + '%');\r\n            System.out.println(String.format(\"Model Precision@1: %.2f \", confidenceMetricsEntry.getPrecisionAt1() * 100) + '%');\r\n            System.out.println(String.format(\"Model Recall@1: %.2f \", confidenceMetricsEntry.getRecallAt1() * 100) + '%');\r\n            System.out.println(String.format(\"Model F1 Score@1: %.2f \", confidenceMetricsEntry.getF1ScoreAt1() * 100) + '%');\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.CDL.rowToJSONObject",
	"Comment": "produce a jsonobject from a row of comma delimited text, using aparallel jsonarray of strings to provides the names of the elements.",
	"Method": "JSONObject rowToJSONObject(JSONArray names,JSONTokener x){\r\n    JSONArray ja = rowToJSONArray(x);\r\n    return ja != null ? ja.toJSONObject(names) : null;\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.pipeline.ElementHandlerPipelineTest.runContent",
	"Comment": "verifies that the content of the processobject is processed on content.",
	"Method": "void runContent(){\r\n    p.content(context, null, null, po);\r\n    Assert.assertEquals(writable, lst.get(0));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.DocumentFont.getFontDescriptor",
	"Comment": "gets the font parameter identified by key. valid valuesfor key are ascent, capheight, descent,italicangle, bboxllx, bboxlly, bboxurxand bboxury.",
	"Method": "float getFontDescriptor(int key,float fontSize){\r\n    if (cjkMirror != null)\r\n        return cjkMirror.getFontDescriptor(key, fontSize);\r\n    switch(key) {\r\n        case AWT_ASCENT:\r\n        case ASCENT:\r\n            return ascender * fontSize / 1000;\r\n        case CAPHEIGHT:\r\n            return capHeight * fontSize / 1000;\r\n        case AWT_DESCENT:\r\n        case DESCENT:\r\n            return descender * fontSize / 1000;\r\n        case ITALICANGLE:\r\n            return italicAngle;\r\n        case BBOXLLX:\r\n            return llx * fontSize / 1000;\r\n        case BBOXLLY:\r\n            return lly * fontSize / 1000;\r\n        case BBOXURX:\r\n            return urx * fontSize / 1000;\r\n        case BBOXURY:\r\n            return ury * fontSize / 1000;\r\n        case AWT_LEADING:\r\n            return 0;\r\n        case AWT_MAXADVANCE:\r\n            return (urx - llx) * fontSize / 1000;\r\n        case FONT_WEIGHT:\r\n            return fontWeight * fontSize / 1000;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPMetaImpl.evaluateNodeValue",
	"Comment": "evaluates a raw node value to the given value type, apply special\tconversions for defined types in xmp.",
	"Method": "Object evaluateNodeValue(int valueType,XMPNode propNode){\r\n    final Object value;\r\n    String rawValue = propNode.getValue();\r\n    switch(valueType) {\r\n        case VALUE_BOOLEAN:\r\n            value = new Boolean(XMPUtils.convertToBoolean(rawValue));\r\n            break;\r\n        case VALUE_INTEGER:\r\n            value = new Integer(XMPUtils.convertToInteger(rawValue));\r\n            break;\r\n        case VALUE_LONG:\r\n            value = new Long(XMPUtils.convertToLong(rawValue));\r\n            break;\r\n        case VALUE_DOUBLE:\r\n            value = new Double(XMPUtils.convertToDouble(rawValue));\r\n            break;\r\n        case VALUE_DATE:\r\n            value = XMPUtils.convertToDate(rawValue);\r\n            break;\r\n        case VALUE_CALENDAR:\r\n            XMPDateTime dt = XMPUtils.convertToDate(rawValue);\r\n            value = dt.getCalendar();\r\n            break;\r\n        case VALUE_BASE64:\r\n            value = XMPUtils.decodeBase64(rawValue);\r\n            break;\r\n        case VALUE_STRING:\r\n        default:\r\n            value = rawValue != null || propNode.getOptions().isCompositeProperty() ? rawValue : \"\";\r\n            break;\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "com.example.dlp.DeIdentification.reIdentifyWithFpe",
	"Comment": "reidentify a string by encrypting sensitive information while preserving format.",
	"Method": "void reIdentifyWithFpe(String string,FfxCommonNativeAlphabet alphabet,String keyName,String wrappedKey,String projectId,String surrogateType){\r\n    try (DlpServiceClient dlpServiceClient = DlpServiceClient.create()) {\r\n        ContentItem contentItem = ContentItem.newBuilder().setValue(string).build();\r\n        InfoType surrogateTypeObject = InfoType.newBuilder().setName(surrogateType).build();\r\n        KmsWrappedCryptoKey kmsWrappedCryptoKey = KmsWrappedCryptoKey.newBuilder().setWrappedKey(ByteString.copyFrom(BaseEncoding.base64().decode(wrappedKey))).setCryptoKeyName(keyName).build();\r\n        CryptoKey cryptoKey = CryptoKey.newBuilder().setKmsWrapped(kmsWrappedCryptoKey).build();\r\n        CryptoReplaceFfxFpeConfig cryptoReplaceFfxFpeConfig = CryptoReplaceFfxFpeConfig.newBuilder().setCryptoKey(cryptoKey).setCommonAlphabet(alphabet).setSurrogateInfoType(surrogateTypeObject).build();\r\n        PrimitiveTransformation primitiveTransformation = PrimitiveTransformation.newBuilder().setCryptoReplaceFfxFpeConfig(cryptoReplaceFfxFpeConfig).build();\r\n        InfoTypeTransformation infoTypeTransformationObject = InfoTypeTransformation.newBuilder().setPrimitiveTransformation(primitiveTransformation).addInfoTypes(surrogateTypeObject).build();\r\n        InfoTypeTransformations infoTypeTransformationArray = InfoTypeTransformations.newBuilder().addTransformations(infoTypeTransformationObject).build();\r\n        CustomInfoType customInfoType = CustomInfoType.newBuilder().setInfoType(surrogateTypeObject).setSurrogateType(SurrogateType.newBuilder().build()).build();\r\n        InspectConfig inspectConfig = InspectConfig.newBuilder().addCustomInfoTypes(customInfoType).build();\r\n        DeidentifyConfig reidentifyConfig = DeidentifyConfig.newBuilder().setInfoTypeTransformations(infoTypeTransformationArray).build();\r\n        ReidentifyContentRequest request = ReidentifyContentRequest.newBuilder().setParent(ProjectName.of(projectId).toString()).setReidentifyConfig(reidentifyConfig).setInspectConfig(inspectConfig).setItem(contentItem).build();\r\n        ReidentifyContentResponse response = dlpServiceClient.reidentifyContent(request);\r\n        String result = response.getItem().getValue();\r\n        System.out.println(result);\r\n    } catch (Exception e) {\r\n        System.out.println(\"Error in reidentifyWithFpe: \" + e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.qrcode.BitArray.isRange",
	"Comment": "efficient method to check if a range of bits is set, or not set.",
	"Method": "boolean isRange(int start,int end,boolean value){\r\n    if (end < start) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (end == start) {\r\n        return true;\r\n    }\r\n    end--;\r\n    int firstInt = start >> 5;\r\n    int lastInt = end >> 5;\r\n    for (int i = firstInt; i <= lastInt; i++) {\r\n        int firstBit = i > firstInt ? 0 : start & 0x1F;\r\n        int lastBit = i < lastInt ? 31 : end & 0x1F;\r\n        int mask;\r\n        if (firstBit == 0 && lastBit == 31) {\r\n            mask = -1;\r\n        } else {\r\n            mask = 0;\r\n            for (int j = firstBit; j <= lastBit; j++) {\r\n                mask |= 1 << j;\r\n            }\r\n        }\r\n        if ((bits[i] & mask) != (value ? mask : 0)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.xpath.XMPPathParser.verifyQualName",
	"Comment": "verifies whether the qualifier name is not xml conformant or the\tnamespace prefix has not been registered.",
	"Method": "void verifyQualName(String qualName){\r\n    int colonPos = qualName.indexOf(':');\r\n    if (colonPos > 0) {\r\n        String prefix = qualName.substring(0, colonPos);\r\n        if (Utils.isXMLNameNS(prefix)) {\r\n            String regURI = XMPMetaFactory.getSchemaRegistry().getNamespaceURI(prefix);\r\n            if (regURI != null) {\r\n                return;\r\n            }\r\n            throw new XMPException(\"Unknown namespace prefix for qualified name\", XMPError.BADXPATH);\r\n        }\r\n    }\r\n    throw new XMPException(\"Ill-formed qualified name\", XMPError.BADXPATH);\r\n}"
}, {
	"Path": "com.itextpdf.text.Image.simplifyColorspace",
	"Comment": "gets a pdf name from an array or returns the object that was passed.",
	"Method": "void simplifyColorspace(PdfObject simplifyColorspace,PdfArray obj){\r\n    if (obj == null)\r\n        return obj;\r\n    PdfName first = obj.getAsName(0);\r\n    if (PdfName.CALGRAY.equals(first))\r\n        return PdfName.DEVICEGRAY;\r\n    else if (PdfName.CALRGB.equals(first))\r\n        return PdfName.DEVICERGB;\r\n    else\r\n        return obj;\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.parser.XMLParser.addListener",
	"Comment": "if no parserlistener is added, parsing with the parser seemsuseless no?",
	"Method": "XMLParser addListener(XMLParserListener pl){\r\n    listeners.add(pl);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.endpoints.examples.hello.HelloWorldServer.blockUntilShutdown",
	"Comment": "await termination on the main thread since the grpc library uses daemon threads.",
	"Method": "void blockUntilShutdown(){\r\n    if (server != null) {\r\n        server.awaitTermination();\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.isOpenedWithFullPermissions",
	"Comment": "checks if the document was opened with the owner password so that the end applicationcan decide what level of access restrictions to apply. if the document is not encryptedit will return true.",
	"Method": "boolean isOpenedWithFullPermissions(){\r\n    return !encrypted || ownerPasswordUsed || unethicalreading;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.zip.Unzipper.readJSON",
	"Comment": "read a json value. the type of value is determined by the next 3 bits.",
	"Method": "Object readJSON(){\r\n    switch(read(3)) {\r\n        case zipObject:\r\n            return readObject();\r\n        case zipArrayString:\r\n            return readArray(true);\r\n        case zipArrayValue:\r\n            return readArray(false);\r\n        case zipEmptyObject:\r\n            return new JSONObject();\r\n        case zipEmptyArray:\r\n            return new JSONArray();\r\n        case zipTrue:\r\n            return Boolean.TRUE;\r\n        case zipFalse:\r\n            return Boolean.FALSE;\r\n        default:\r\n            return JSONObject.NULL;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BarcodeEAN.createAwtImage",
	"Comment": "creates a java.awt.image. this image onlycontains the bars without any text.",
	"Method": "java.awt.Image createAwtImage(java.awt.Color foreground,java.awt.Color background){\r\n    int f = foreground.getRGB();\r\n    int g = background.getRGB();\r\n    java.awt.Canvas canvas = new java.awt.Canvas();\r\n    int width = 0;\r\n    byte[] bars = null;\r\n    switch(codeType) {\r\n        case EAN13:\r\n            bars = getBarsEAN13(code);\r\n            width = 11 + 12 * 7;\r\n            break;\r\n        case EAN8:\r\n            bars = getBarsEAN8(code);\r\n            width = 11 + 8 * 7;\r\n            break;\r\n        case UPCA:\r\n            bars = getBarsEAN13(\"0\" + code);\r\n            width = 11 + 12 * 7;\r\n            break;\r\n        case UPCE:\r\n            bars = getBarsUPCE(code);\r\n            width = 9 + 6 * 7;\r\n            break;\r\n        case SUPP2:\r\n            bars = getBarsSupplemental2(code);\r\n            width = 6 + 2 * 7;\r\n            break;\r\n        case SUPP5:\r\n            bars = getBarsSupplemental5(code);\r\n            width = 4 + 5 * 7 + 4 * 2;\r\n            break;\r\n        default:\r\n            throw new RuntimeException(MessageLocalization.getComposedMessage(\"invalid.code.type\"));\r\n    }\r\n    boolean print = true;\r\n    int ptr = 0;\r\n    int height = (int) barHeight;\r\n    int[] pix = new int[width * height];\r\n    for (int k = 0; k < bars.length; ++k) {\r\n        int w = bars[k];\r\n        int c = g;\r\n        if (print)\r\n            c = f;\r\n        print = !print;\r\n        for (int j = 0; j < w; ++j) pix[ptr++] = c;\r\n    }\r\n    for (int k = width; k < pix.length; k += width) {\r\n        System.arraycopy(pix, 0, pix, k, width);\r\n    }\r\n    java.awt.Image img = canvas.createImage(new java.awt.image.MemoryImageSource(width, height, pix, 0, width));\r\n    return img;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONObject.optInt",
	"Comment": "get an optional int value associated with a key, or the default if thereis no such key or if the value is not a number. if the value is a string,an attempt will be made to evaluate it as a number.",
	"Method": "int optInt(String key,int optInt,String key,int defaultValue){\r\n    try {\r\n        return this.getInt(key);\r\n    } catch (Exception e) {\r\n        return defaultValue;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.BuildNewIndexAndCopyAllGSubrs",
	"Comment": "function builds the new offset array, object array and assembles the index.\tused for creating the glyph and subrs subsetted index",
	"Method": "byte[] BuildNewIndexAndCopyAllGSubrs(int[] Offsets,byte OperatorForUnusedEntries){\r\n    int unusedCount = 0;\r\n    int Offset = 0;\r\n    int[] NewOffsets = new int[Offsets.length];\r\n    for (int i = 0; i < Offsets.length - 1; ++i) {\r\n        NewOffsets[i] = Offset;\r\n        Offset += Offsets[i + 1] - Offsets[i];\r\n    }\r\n    NewOffsets[Offsets.length - 1] = Offset;\r\n    unusedCount++;\r\n    byte[] NewObjects = new byte[Offset + unusedCount];\r\n    int unusedOffset = 0;\r\n    for (int i = 0; i < Offsets.length - 1; ++i) {\r\n        int start = NewOffsets[i];\r\n        int end = NewOffsets[i + 1];\r\n        NewOffsets[i] = start + unusedOffset;\r\n        if (start != end) {\r\n            buf.seek(Offsets[i]);\r\n            buf.readFully(NewObjects, start + unusedOffset, end - start);\r\n        } else {\r\n            NewObjects[start + unusedOffset] = OperatorForUnusedEntries;\r\n            unusedOffset++;\r\n        }\r\n    }\r\n    NewOffsets[Offsets.length - 1] += unusedOffset;\r\n    return AssembleIndex(NewOffsets, NewObjects);\r\n}"
}, {
	"Path": "com.structurizr.view.ComponentView.addAllContainers",
	"Comment": "adds all other containers in the software system to this view.",
	"Method": "void addAllContainers(){\r\n    getSoftwareSystem().getContainers().forEach(this::add);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStamper.close",
	"Comment": "closes the document. no more content can be written after thedocument is closed.if closing a signed document with an external signature the closing must be donein the pdfsignatureappearance instance.",
	"Method": "void close(){\r\n    if (stamper.closed)\r\n        return;\r\n    if (!hasSignature) {\r\n        mergeVerification();\r\n        stamper.close(moreInfo);\r\n    } else {\r\n        throw new DocumentException(\"Signature defined. Must be closed in PdfSignatureAppearance.\");\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.parser.io.MonitorInputReader.read",
	"Comment": "currently the only overridden method that sends data to the given monitor.",
	"Method": "int read(char[] c){\r\n    int i = super.read(c);\r\n    monitor.read(c);\r\n    return i;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.setAwake",
	"Comment": "set the sleep state of the body. a sleeping body has very low cpu cost.",
	"Method": "void setAwake(boolean flag){\r\n    if (flag) {\r\n        if ((m_flags & e_awakeFlag) == 0) {\r\n            m_flags |= e_awakeFlag;\r\n            m_sleepTime = 0.0f;\r\n        }\r\n    } else {\r\n        m_flags &= ~e_awakeFlag;\r\n        m_sleepTime = 0.0f;\r\n        m_linearVelocity.setZero();\r\n        m_angularVelocity = 0.0f;\r\n        m_force.setZero();\r\n        m_torque = 0.0f;\r\n    }\r\n}"
}, {
	"Path": "com.tozny.crypto.android.AesCbcWithIntegrity.fixPrng",
	"Comment": "ensures that the prng is fixed. should be used before generating any keys.will only run once, and every subsequent call should return immediately.",
	"Method": "void fixPrng(){\r\n    if (!prngFixed.get()) {\r\n        synchronized (PrngFixes.class) {\r\n            if (!prngFixed.get()) {\r\n                PrngFixes.apply();\r\n                prngFixed.set(true);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.getInfo",
	"Comment": "returns the content of the document information dictionary as a hashmapof string.",
	"Method": "HashMap<String, String> getInfo(){\r\n    HashMap<String, String> map = new HashMap<String, String>();\r\n    PdfDictionary info = trailer.getAsDict(PdfName.INFO);\r\n    if (info == null)\r\n        return map;\r\n    for (Object element : info.getKeys()) {\r\n        PdfName key = (PdfName) element;\r\n        PdfObject obj = getPdfObject(info.get(key));\r\n        if (obj == null)\r\n            continue;\r\n        String value = obj.toString();\r\n        switch(obj.type()) {\r\n            case PdfObject.STRING:\r\n                {\r\n                    value = ((PdfString) obj).toUnicodeString();\r\n                    break;\r\n                }\r\n            case PdfObject.NAME:\r\n                {\r\n                    value = PdfName.decodeName(value);\r\n                    break;\r\n                }\r\n        }\r\n        map.put(PdfName.decodeName(key.toString()), value);\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "net.dv8tion.jda.bot.utils.cache.ShardCacheView.getElementById",
	"Comment": "retrieves the jda instance represented by the provided shard id.",
	"Method": "JDA getElementById(int id,JDA getElementById,String id){\r\n    return getElementById(Integer.parseUnsignedInt(id));\r\n}"
}, {
	"Path": "com.example.bigquery.LabelsSample.labelTable",
	"Comment": "add or modify a label on a table.see the bigquerydocumentation.",
	"Method": "void labelTable(String projectId,String datasetId,String tableId,String labelKey,String labelValue){\r\n    GoogleCredential credential = GoogleCredential.getApplicationDefault();\r\n    credential = credential.createScoped(Arrays.asList(\"https://www.googleapis.com/auth/bigquery\"));\r\n    credential.refreshToken();\r\n    String accessToken = credential.getAccessToken();\r\n    Table table = new Table();\r\n    table.addLabel(labelKey, labelValue);\r\n    HttpContent content = new JsonHttpContent(JSON_FACTORY, table);\r\n    String urlFormat = \"https://www.googleapis.com/bigquery/v2/projects/%s/datasets/%s/tables/%s\" + \"?fields=labels&access_token=%s\";\r\n    GenericUrl url = new GenericUrl(String.format(urlFormat, projectId, datasetId, tableId, accessToken));\r\n    HttpRequestFactory requestFactory = HTTP_TRANSPORT.createRequestFactory();\r\n    HttpRequest request = requestFactory.buildPostRequest(url, content);\r\n    request.setParser(JSON_FACTORY.createJsonObjectParser());\r\n    request.setHeaders(new HttpHeaders().set(\"X-HTTP-Method-Override\", \"PATCH\"));\r\n    HttpResponse response = request.execute();\r\n    if (response.getStatusCode() != 200) {\r\n        throw new RuntimeException(response.getStatusMessage());\r\n    }\r\n    Table responseTable = response.parseAs(Table.class);\r\n    System.out.printf(\"Updated label \\\"%s\\\" with value \\\"%s\\\"\\n\", labelKey, responseTable.getLabels().get(labelKey));\r\n}"
}, {
	"Path": "com.itextpdf.text.Section.constructTitle",
	"Comment": "constructs a paragraph that will be used as title for a section or chapter.",
	"Method": "Paragraph constructTitle(Paragraph title,ArrayList<Integer> numbers,int numberDepth,int numberStyle){\r\n    if (title == null) {\r\n        return null;\r\n    }\r\n    int depth = Math.min(numbers.size(), numberDepth);\r\n    if (depth < 1) {\r\n        return title;\r\n    }\r\n    StringBuffer buf = new StringBuffer(\" \");\r\n    for (int i = 0; i < depth; i++) {\r\n        buf.insert(0, \".\");\r\n        buf.insert(0, numbers.get(i).intValue());\r\n    }\r\n    if (numberStyle == NUMBERSTYLE_DOTTED_WITHOUT_FINAL_DOT) {\r\n        buf.deleteCharAt(buf.length() - 2);\r\n    }\r\n    Paragraph result = new Paragraph(title);\r\n    result.add(0, new Chunk(buf.toString(), title.getFont()));\r\n    return result;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfAnnotation.createLine",
	"Comment": "adds a line to the document. move over the line and a tooltip is shown.",
	"Method": "PdfAnnotation createLine(PdfWriter writer,Rectangle rect,String contents,float x1,float y1,float x2,float y2){\r\n    PdfAnnotation annot = writer.createAnnotation(rect, PdfName.LINE);\r\n    annot.put(PdfName.CONTENTS, new PdfString(contents, PdfObject.TEXT_UNICODE));\r\n    PdfArray array = new PdfArray(new PdfNumber(x1));\r\n    array.add(new PdfNumber(y1));\r\n    array.add(new PdfNumber(x2));\r\n    array.add(new PdfNumber(y2));\r\n    annot.put(PdfName.L, array);\r\n    return annot;\r\n}"
}, {
	"Path": "software.amazon.ion.ContainerTestCase.testIteratorRemove",
	"Comment": "using an iterator, remove a value in the container and verifythat the value no longer exists in the container.",
	"Method": "void testIteratorRemove(IonContainer container){\r\n    Iterator<IonValue> it = container.iterator();\r\n    IonValue removedValue = it.next();\r\n    int prevSize = container.size();\r\n    it.remove();\r\n    assertEquals(container.size(), prevSize - 1);\r\n    assertNull(removedValue.getContainer());\r\n    assertNull(removedValue.getFieldName());\r\n    it = container.iterator();\r\n    while (it.hasNext()) {\r\n        IonValue value = it.next();\r\n        assertNotSame(removedValue, value);\r\n    }\r\n    assertFalse(container.remove(removedValue));\r\n}"
}, {
	"Path": "software.amazon.ion.impl.PrivateIonTextAppender.printSymbol",
	"Comment": "print an ion symbol type. this method will check if symbol needs quoting",
	"Method": "void printSymbol(CharSequence text){\r\n    if (text == null) {\r\n        appendAscii(\"null.symbol\");\r\n    } else if (symbolNeedsQuoting(text, true)) {\r\n        appendAscii('\\'');\r\n        printCodePoints(text, SYMBOL_ESCAPE_CODES);\r\n        appendAscii('\\'');\r\n    } else {\r\n        appendAscii(text);\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.getAutoClearForces",
	"Comment": "get the flag that controls automatic clearing of forces after each time step.",
	"Method": "boolean getAutoClearForces(){\r\n    return (m_flags & CLEAR_FORCES) == CLEAR_FORCES;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.tokenizer.core.DictionaryFactory.createSingletonDictionary",
	"Comment": "create a singleton adictionary object according to the jcsegtaskconfig",
	"Method": "ADictionary createSingletonDictionary(JcsegTaskConfig config,ADictionary createSingletonDictionary,JcsegTaskConfig config,boolean loadDic){\r\n    synchronized (LOCK) {\r\n        if (singletonDic == null) {\r\n            singletonDic = createDefaultDictionary(config, loadDic);\r\n        }\r\n    }\r\n    return singletonDic;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfSignatureAppearance.setCertificationLevel",
	"Comment": "sets the document type to certified instead of simply signed.",
	"Method": "void setCertificationLevel(int certificationLevel){\r\n    this.certificationLevel = certificationLevel;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Type3Font.defineGlyph",
	"Comment": "defines a glyph. if the character was already defined it will return the same content",
	"Method": "PdfContentByte defineGlyph(char c,float wx,float llx,float lly,float urx,float ury){\r\n    if (c == 0 || c > 255)\r\n        throw new IllegalArgumentException(MessageLocalization.getComposedMessage(\"the.char.1.doesn.t.belong.in.this.type3.font\", c));\r\n    usedSlot[c] = true;\r\n    Integer ck = Integer.valueOf(c);\r\n    Type3Glyph glyph = char2glyph.get(ck);\r\n    if (glyph != null)\r\n        return glyph;\r\n    widths3.put(c, (int) wx);\r\n    if (!colorized) {\r\n        if (Float.isNaN(this.llx)) {\r\n            this.llx = llx;\r\n            this.lly = lly;\r\n            this.urx = urx;\r\n            this.ury = ury;\r\n        } else {\r\n            this.llx = Math.min(this.llx, llx);\r\n            this.lly = Math.min(this.lly, lly);\r\n            this.urx = Math.max(this.urx, urx);\r\n            this.ury = Math.max(this.ury, ury);\r\n        }\r\n    }\r\n    glyph = new Type3Glyph(writer, pageResources, wx, llx, lly, urx, ury, colorized);\r\n    char2glyph.put(ck, glyph);\r\n    return glyph;\r\n}"
}, {
	"Path": "com.machinepublishers.glass.ui.monocle.RunnableProcessor.invokeLater",
	"Comment": "posts a runnable to the javafx event queue using this runnableprocessor",
	"Method": "void invokeLater(Runnable r){\r\n    queue.postRunnable(r);\r\n}"
}, {
	"Path": "com.itextpdf.text.zugferd.checkers.CodeValidation.isUppercase",
	"Comment": "checks the length of a code and if a code consists of uppercase lettersfrom a to z.",
	"Method": "boolean isUppercase(String code,int chars){\r\n    if (code.length() != chars)\r\n        return false;\r\n    for (char c : code.toCharArray()) if (c < 65 || c > 90)\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "com.example.texttospeech.SynthesizeFile.synthesizeTextFile",
	"Comment": "demonstrates using the text to speech client to synthesize a text file or ssml file.",
	"Method": "void synthesizeTextFile(String textFile){\r\n    try (TextToSpeechClient textToSpeechClient = TextToSpeechClient.create()) {\r\n        String contents = new String(Files.readAllBytes(Paths.get(textFile)));\r\n        SynthesisInput input = SynthesisInput.newBuilder().setText(contents).build();\r\n        VoiceSelectionParams voice = // languageCode = \"en_us\"\r\n        VoiceSelectionParams.newBuilder().setLanguageCode(// ssmlVoiceGender = SsmlVoiceGender.FEMALE\r\n        \"en-US\").setSsmlGender(SsmlVoiceGender.FEMALE).build();\r\n        AudioConfig audioConfig = // MP3 audio.\r\n        AudioConfig.newBuilder().setAudioEncoding(AudioEncoding.MP3).build();\r\n        SynthesizeSpeechResponse response = textToSpeechClient.synthesizeSpeech(input, voice, audioConfig);\r\n        ByteString audioContents = response.getAudioContent();\r\n        try (OutputStream out = new FileOutputStream(\"output.mp3\")) {\r\n            out.write(audioContents.toByteArray());\r\n            System.out.println(\"Audio content written to file \\\"output.mp3\\\"\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPTable.normalizeHeadersFooters",
	"Comment": "makes sure the footers value is lower than the headers value.",
	"Method": "void normalizeHeadersFooters(){\r\n    if (footerRows > headerRows) {\r\n        footerRows = headerRows;\r\n    }\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONTokener.next",
	"Comment": "consume the next character, and check that it matches a specifiedcharacter.",
	"Method": "char next(char next,char c,String next,int n){\r\n    if (n == 0) {\r\n        return \"\";\r\n    }\r\n    char[] chars = new char[n];\r\n    int pos = 0;\r\n    while (pos < n) {\r\n        chars[pos] = this.next();\r\n        if (this.end()) {\r\n            throw this.syntaxError(\"Substring bounds error\");\r\n        }\r\n        pos += 1;\r\n    }\r\n    return new String(chars);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfCopy.getCatalog",
	"Comment": "the getcatalog method is part of pdfwriter.we wrap this so that we can extend it",
	"Method": "PdfDictionary getCatalog(PdfIndirectReference rootObj){\r\n    try {\r\n        PdfDictionary theCat = pdf.getCatalog(rootObj);\r\n        buildStructTreeRootForTagged(theCat);\r\n        if (fieldArray != null) {\r\n            addFieldResources(theCat);\r\n        } else if (mergeFields && acroForm != null) {\r\n            theCat.put(PdfName.ACROFORM, acroForm);\r\n        }\r\n        return theCat;\r\n    } catch (IOException e) {\r\n        throw new ExceptionConverter(e);\r\n    }\r\n}"
}, {
	"Path": "com.machinepublishers.jbrowserdriver.JBrowserDriver.init",
	"Comment": "optionally call this method if you want javafx initialized and the browserwindow opened immediately. otherwise, initialization will happen lazily.",
	"Method": "void init(){\r\n    try {\r\n        synchronized (lock.validated()) {\r\n            remote.init();\r\n        }\r\n    } catch (Throwable t) {\r\n        Util.handleException(t);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.CopyHeader",
	"Comment": "function copies the header from the original fileto the output list",
	"Method": "void CopyHeader(){\r\n    seek(0);\r\n    int major = getCard8();\r\n    int minor = getCard8();\r\n    int hdrSize = getCard8();\r\n    int offSize = getCard8();\r\n    nextIndexOffset = hdrSize;\r\n    OutputList.addLast(new RangeItem(buf, 0, hdrSize));\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.css.apply.ChunkCssApplier.copyChunkStyles",
	"Comment": "method used for copying styles from one chunk to another. could be deprecated if the content of a chunk can be overwritten.",
	"Method": "void copyChunkStyles(Chunk source,Chunk target){\r\n    target.setFont(source.getFont());\r\n    target.setAttributes(source.getAttributes());\r\n    target.setCharacterSpacing(source.getCharacterSpacing());\r\n    target.setHorizontalScaling(source.getHorizontalScaling());\r\n    target.setHorizontalScaling(source.getHorizontalScaling());\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentByte.localDestination",
	"Comment": "the local destination to where a local goto with the samename will jump.",
	"Method": "boolean localDestination(String name,PdfDestination destination){\r\n    return pdf.localDestination(name, destination);\r\n}"
}, {
	"Path": "software.amazon.ion.Timestamp.addHour",
	"Comment": "returns a timestamp relative to this one by the given number of hours.",
	"Method": "Timestamp addHour(int amount){\r\n    long delta = (long) amount * 60 * 60 * 1000;\r\n    return addMillis(delta);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Barcode.setChecksumText",
	"Comment": "sets the property to show the generated checksum in the the text.",
	"Method": "void setChecksumText(boolean checksumText){\r\n    this.checksumText = checksumText;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.OutputStreamEncryption.flush",
	"Comment": "flushes this output stream and forces any buffered output bytesto be written out. the general contract of flush isthat calling it is an indication that, if any bytes previouslywritten have been buffered by the implementation of the outputstream, such bytes should immediately be written to theirintended destination.the flush method of outputstream does nothing.",
	"Method": "void flush(){\r\n    out.flush();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaWindow.setWidth",
	"Comment": "sets a dictionary with keys default, max, and min describing values for\tthe width of the window in default user space units.",
	"Method": "void setWidth(float defaultWidth,float maxWidth,float minWidth){\r\n    put(PdfName.WIDTH, createDimensionDictionary(defaultWidth, maxWidth, minWidth));\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.setBullet",
	"Comment": "is this a fast moving body that should be prevented from tunneling through other moving bodies?note that all bodies are prevented from tunneling through kinematic and static bodies. thissetting is only considered on dynamic bodies.",
	"Method": "void setBullet(boolean bullet){\r\n    this.bullet = bullet;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseField.setRotationFromPage",
	"Comment": "convenience method to set the field rotation the same as thepage rotation.",
	"Method": "void setRotationFromPage(Rectangle page){\r\n    setRotation(page.getRotation());\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPNode.assertChildNotExisting",
	"Comment": "checks that a node name is not existing on the same level, except for array items.",
	"Method": "void assertChildNotExisting(String childName){\r\n    if (!XMPConst.ARRAY_ITEM_NAME.equals(childName) && findChildByName(childName) != null) {\r\n        throw new XMPException(\"Duplicate property or field node '\" + childName + \"'\", XMPError.BADXMP);\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.isAllowSleep",
	"Comment": "set this flag to false if this body should never fall asleep. note that this increases cpuusage.",
	"Method": "boolean isAllowSleep(){\r\n    return allowSleep;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.qrcode.BitMatrix.getRow",
	"Comment": "a fast method to retrieve one row of data from the matrix as a bitarray.",
	"Method": "BitArray getRow(int y,BitArray row){\r\n    if (row == null || row.getSize() < width) {\r\n        row = new BitArray(width);\r\n    }\r\n    int offset = y * rowSize;\r\n    for (int x = 0; x < rowSize; x++) {\r\n        row.setBulk(x << 5, bits[offset + x]);\r\n    }\r\n    return row;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BarcodePDF417.setAspectRatio",
	"Comment": "sets the barcode aspect ratio. a ratio or 0.5 will make thebarcode width twice as large as the height.",
	"Method": "void setAspectRatio(float aspectRatio){\r\n    this.aspectRatio = aspectRatio;\r\n}"
}, {
	"Path": "software.amazon.ion.system.IonSystemBuilder.immutable",
	"Comment": "returns an immutable builder configured exactly like this one.",
	"Method": "IonSystemBuilder immutable(IonSystemBuilder immutable){\r\n    return this;\r\n}"
}, {
	"Path": "software.amazon.ion.streaming.RoundTripStreamingTest.makeText",
	"Comment": "use ionreader to consume the buffer, and iontextwriter to print it out.",
	"Method": "byte[] makeText(byte[] buffer,boolean prettyPrint){\r\n    IonReader in = makeIterator(buffer);\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    IonTextWriterBuilder b = IonTextWriterBuilder.standard();\r\n    if (prettyPrint) {\r\n        b.withPrettyPrinting();\r\n    }\r\n    b.setInitialIvmHandling(SUPPRESS);\r\n    IonWriter tw = b.build(out);\r\n    tw.writeValues(in);\r\n    tw.close();\r\n    byte[] buf = out.toByteArray();\r\n    return buf;\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.css.CssUtils.isRelativeValue",
	"Comment": "checks whether a string contains an allowed value relative to previously set value.",
	"Method": "boolean isRelativeValue(String value){\r\n    return value.contains(CSS.Value.PERCENTAGE) || value.contains(CSS.Value.EM) || value.contains(CSS.Value.EX);\r\n}"
}, {
	"Path": "com.example.cloudtasks.CreateTaskServlet.createAuthorizedClient",
	"Comment": "creates an authorized cloudtasks client service using application default credentials.",
	"Method": "CloudTasks createAuthorizedClient(){\r\n    HttpTransport transport = new NetHttpTransport();\r\n    JsonFactory jsonFactory = new JacksonFactory();\r\n    GoogleCredential credential = GoogleCredential.getApplicationDefault(transport, jsonFactory);\r\n    if (credential.createScopedRequired()) {\r\n        credential = credential.createScoped(CloudTasksScopes.all());\r\n    }\r\n    return new CloudTasks.Builder(transport, jsonFactory, credential).setApplicationName(\"Cloud Tasks Snippets\").build();\r\n}"
}, {
	"Path": "com.itextpdf.text.Image.setInterpolation",
	"Comment": "sets the image interpolation. image interpolation attempts to produce a\tsmooth transition between adjacent sample values.",
	"Method": "void setInterpolation(boolean interpolation){\r\n    this.interpolation = interpolation;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.WriteBuffer.writeByte",
	"Comment": "writes a single octet to the buffer, expanding if necessary.",
	"Method": "void writeByte(byte octet){\r\n    if (remaining() < 1) {\r\n        if (index == blocks.size() - 1) {\r\n            allocateNewBlock();\r\n        }\r\n        index++;\r\n        current = blocks.get(index);\r\n    }\r\n    final Block block = current;\r\n    block.data[block.limit] = octet;\r\n    block.limit++;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Barcode128.getPackedRawDigits",
	"Comment": "packs the digits for charset c also considering fnc1. it assumes that all the parametersare valid.",
	"Method": "String getPackedRawDigits(String text,int textIndex,int numDigits){\r\n    StringBuilder out = new StringBuilder(\"\");\r\n    int start = textIndex;\r\n    while (numDigits > 0) {\r\n        if (text.charAt(textIndex) == FNC1) {\r\n            out.append(FNC1_INDEX);\r\n            ++textIndex;\r\n            continue;\r\n        }\r\n        numDigits -= 2;\r\n        int c1 = text.charAt(textIndex++) - '0';\r\n        int c2 = text.charAt(textIndex++) - '0';\r\n        out.append((char) (c1 * 10 + c2));\r\n    }\r\n    return (char) (textIndex - start) + out.toString();\r\n}"
}, {
	"Path": "software.amazon.ion.impl.lite.IonStructLite.validateFieldName",
	"Comment": "ensures that a given field name is valid. used as a helper formethods that have that precondition.",
	"Method": "void validateFieldName(String fieldName){\r\n    if (fieldName == null) {\r\n        throw new NullPointerException(\"fieldName is null\");\r\n    }\r\n}"
}, {
	"Path": "software.amazon.ion.IonValueDeltaGenerator.generateValues",
	"Comment": "generate a set of ionvalues from the configuration properties thatwere set.",
	"Method": "Set<IonValue> generateValues(){\r\n    switch(valueType) {\r\n        case DECIMAL:\r\n            return generateIonDecimals();\r\n        case FLOAT:\r\n            return generateIonFloats();\r\n        case INT:\r\n            return generateIonInts();\r\n        case SYMBOL:\r\n            return generateIonSymbols();\r\n        case TIMESTAMP:\r\n            return generateIonTimestamps();\r\n        default:\r\n            fail(\"not supported: \" + valueType);\r\n            return null;\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.setBullet",
	"Comment": "should this body be treated like a bullet for continuous collision detection?",
	"Method": "void setBullet(boolean flag){\r\n    if (flag) {\r\n        m_flags |= e_bulletFlag;\r\n    } else {\r\n        m_flags &= ~e_bulletFlag;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDocument.getBoxSize",
	"Comment": "gives the size of a trim, art, crop or bleed box, or null if not defined.",
	"Method": "Rectangle getBoxSize(String boxName){\r\n    PdfRectangle r = thisBoxSize.get(boxName);\r\n    if (r != null) {\r\n        return r.getRectangle();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.structurizr.model.DeploymentNode.uses",
	"Comment": "adds a relationship between this and another deployment node.",
	"Method": "Relationship uses(DeploymentNode destination,String description,String technology,Relationship uses,DeploymentNode destination,String description,String technology,InteractionStyle interactionStyle){\r\n    return getModel().addRelationship(this, destination, description, technology, interactionStyle);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.getUserData",
	"Comment": "get the user data pointer that was provided in the body definition.",
	"Method": "Object getUserData(){\r\n    return m_userData;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.Process",
	"Comment": "the process function extracts one font out of the cff file and returns a\tsubset version of the original.",
	"Method": "byte[] Process(String fontName){\r\n    try {\r\n        buf.reOpen();\r\n        int j;\r\n        for (j = 0; j < fonts.length; j++) if (fontName.equals(fonts[j].name))\r\n            break;\r\n        if (j == fonts.length)\r\n            return null;\r\n        if (gsubrIndexOffset >= 0)\r\n            GBias = CalcBias(gsubrIndexOffset, j);\r\n        BuildNewCharString(j);\r\n        BuildNewLGSubrs(j);\r\n        byte[] Ret = BuildNewFile(j);\r\n        return Ret;\r\n    } finally {\r\n        try {\r\n            buf.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfCopy.copyDictionary",
	"Comment": "translate a prdictionary to a pdfdictionary. also translate all of theobjects contained in it.",
	"Method": "PdfDictionary copyDictionary(PdfDictionary in,boolean keepStruct,boolean directRootKids,PdfDictionary copyDictionary,PdfDictionary in){\r\n    return copyDictionary(in, false, false);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.events.PdfPageEventForwarder.onStartPage",
	"Comment": "called when a page is initialized.\tnote that if even if a page is not written this method is still called.\tit is preferable to use onendpage to avoid infinite loops.",
	"Method": "void onStartPage(PdfWriter writer,Document document){\r\n    for (PdfPageEvent event : events) {\r\n        event.onStartPage(writer, document);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDictionary.clear",
	"Comment": "removes all the pdfobjects and its keys from thepdfdictionary.",
	"Method": "void clear(){\r\n    hashMap.clear();\r\n}"
}, {
	"Path": "com.example.time.testing.FakeClock.resetTime",
	"Comment": "reset the given clock back to the base time with which the fakeclock was initiallyconstructed.",
	"Method": "FakeClock resetTime(){\r\n    fakeNowMs.set(baseTimeMs);\r\n    return this;\r\n}"
}, {
	"Path": "com.example.dlp.Redact.main",
	"Comment": "command line application to redact strings, images using the data loss prevention api.",
	"Method": "void main(String[] args){\r\n    Options commandLineOptions = new Options();\r\n    Option minLikelihoodOption = Option.builder(\"minLikelihood\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(minLikelihoodOption);\r\n    Option infoTypesOption = Option.builder(\"infoTypes\").hasArg(true).required(false).build();\r\n    infoTypesOption.setArgs(Option.UNLIMITED_VALUES);\r\n    commandLineOptions.addOption(infoTypesOption);\r\n    Option inputFilePathOption = Option.builder(\"f\").hasArg(true).longOpt(\"inputFilePath\").required(false).build();\r\n    commandLineOptions.addOption(inputFilePathOption);\r\n    Option outputFilePathOption = Option.builder(\"o\").hasArg(true).longOpt(\"outputFilePath\").required(false).build();\r\n    commandLineOptions.addOption(outputFilePathOption);\r\n    Option projectIdOption = Option.builder(\"projectId\").hasArg(true).required(false).build();\r\n    CommandLineParser parser = new DefaultParser();\r\n    HelpFormatter formatter = new HelpFormatter();\r\n    CommandLine cmd;\r\n    try {\r\n        cmd = parser.parse(commandLineOptions, args);\r\n    } catch (ParseException e) {\r\n        System.out.println(e.getMessage());\r\n        formatter.printHelp(Redact.class.getName(), commandLineOptions);\r\n        System.exit(1);\r\n        return;\r\n    }\r\n    List<InfoType> infoTypesList = new ArrayList();\r\n    String[] infoTypes = cmd.getOptionValues(infoTypesOption.getOpt());\r\n    if (infoTypes != null) {\r\n        for (String infoType : infoTypes) {\r\n            infoTypesList.add(InfoType.newBuilder().setName(infoType).build());\r\n        }\r\n    }\r\n    Likelihood minLikelihood = Likelihood.valueOf(cmd.getOptionValue(minLikelihoodOption.getOpt(), Likelihood.LIKELIHOOD_UNSPECIFIED.name()));\r\n    String inputFilePath = cmd.getOptionValue(inputFilePathOption.getOpt());\r\n    String outputFilePath = cmd.getOptionValue(outputFilePathOption.getOpt());\r\n    String projectId = cmd.getOptionValue(projectIdOption.getOpt(), ServiceOptions.getDefaultProjectId());\r\n    redactImage(inputFilePath, minLikelihood, infoTypesList, outputFilePath, projectId);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.XfaForm.findDatasetsName",
	"Comment": "finds the complete som name contained in the datasets section from apossibly partial name.",
	"Method": "String findDatasetsName(String name){\r\n    if (datasetsSom.getName2Node().containsKey(name))\r\n        return name;\r\n    return datasetsSom.inverseSearchGlobal(Xml2Som.splitParts(name));\r\n}"
}, {
	"Path": "com.itextpdf.text.Version.getInstance",
	"Comment": "gets an instance of the itext version that is currently used.\tnote that itext group requests that you retain the itext producer line\tin every pdf that is created or manipulated using itext.",
	"Method": "Version getInstance(){\r\n    synchronized (staticLock) {\r\n        if (version != null) {\r\n            return version;\r\n        }\r\n    }\r\n    Version localVersion = new Version();\r\n    try {\r\n        Class<?> klass = Class.forName(\"com.itextpdf.licensekey.LicenseKey\");\r\n        if (klass != null) {\r\n            Class[] cArg = { String.class };\r\n            Method m = klass.getMethod(\"getLicenseeInfoForVersion\", cArg);\r\n            Object[] args = { localVersion.release };\r\n            String[] info = (String[]) m.invoke(klass.newInstance(), args);\r\n            if (info[3] != null && info[3].trim().length() > 0) {\r\n                localVersion.key = info[3];\r\n            } else {\r\n                localVersion.key = \"Trial version \";\r\n                if (info[5] == null) {\r\n                    localVersion.key += \"unauthorised\";\r\n                } else {\r\n                    localVersion.key += info[5];\r\n                }\r\n            }\r\n            if (info[4] != null && info[4].trim().length() > 0) {\r\n                localVersion.iTextVersion = info[4];\r\n            } else if (info[2] != null && info[2].trim().length() > 0) {\r\n                localVersion.iTextVersion += \" (\" + info[2];\r\n                if (!localVersion.key.toLowerCase().startsWith(\"trial\")) {\r\n                    localVersion.iTextVersion += \"; licensed version)\";\r\n                } else {\r\n                    localVersion.iTextVersion += \"; \" + localVersion.key + \")\";\r\n                }\r\n            } else if (info[0] != null && info[0].trim().length() > 0) {\r\n                localVersion.iTextVersion += \" (\" + info[0];\r\n                if (!localVersion.key.toLowerCase().startsWith(\"trial\")) {\r\n                    localVersion.iTextVersion += \"; licensed version)\";\r\n                } else {\r\n                    localVersion.iTextVersion += \"; \" + localVersion.key + \")\";\r\n                }\r\n            } else {\r\n                throw new Exception();\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        localVersion.iTextVersion += AGPL;\r\n    }\r\n    return atomicSetVersion(localVersion);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.getTabs",
	"Comment": "returns the value to be used for the tabs entry in the page tree.",
	"Method": "PdfName getTabs(){\r\n    return tabs;\r\n}"
}, {
	"Path": "com.structurizr.analysis.ComponentFinder.getExclusions",
	"Comment": "gets the set of regexes that define which types should be excluded during the component finding process.",
	"Method": "Set<Pattern> getExclusions(){\r\n    return new HashSet(exclusions);\r\n}"
}, {
	"Path": "com.example.bigtable.BigtableHelloWorld.doHelloWorld",
	"Comment": "connects to cloud bigtable, runs some basic operations and prints the results.",
	"Method": "String doHelloWorld(){\r\n    StringBuilder result = new StringBuilder();\r\n    Connection connection = BigtableHelper.getConnection();\r\n    result.append(create(connection));\r\n    result.append(\"<br><br>\");\r\n    try (Table table = connection.getTable(TableName.valueOf(TABLE_NAME))) {\r\n        result.append(\"Write some greetings to the table<br>\");\r\n        for (int i = 0; i < GREETINGS.length; i++) {\r\n            String rowKey = \"greeting\" + i;\r\n            Put put = new Put(Bytes.toBytes(rowKey));\r\n            put.addColumn(COLUMN_FAMILY_NAME, COLUMN_NAME, Bytes.toBytes(GREETINGS[i]));\r\n            table.put(put);\r\n        }\r\n        String rowKey = \"greeting0\";\r\n        Result getResult = table.get(new Get(Bytes.toBytes(rowKey)));\r\n        String greeting = Bytes.toString(getResult.getValue(COLUMN_FAMILY_NAME, COLUMN_NAME));\r\n        result.append(\"Get a single greeting by row key<br>\");\r\n        result.append(\"     \");\r\n        result.append(rowKey);\r\n        result.append(\"= \");\r\n        result.append(greeting);\r\n        result.append(\"<br>\");\r\n        Scan scan = new Scan();\r\n        result.append(\"Scan for all greetings:\");\r\n        ResultScanner scanner = table.getScanner(scan);\r\n        for (Result row : scanner) {\r\n            byte[] valueBytes = row.getValue(COLUMN_FAMILY_NAME, COLUMN_NAME);\r\n            result.append(\"    \");\r\n            result.append(Bytes.toString(valueBytes));\r\n            result.append(\"<br>\");\r\n        }\r\n    } catch (IOException e) {\r\n        result.append(\"Exception while running HelloWorld: \" + e.getMessage() + \"<br>\");\r\n        result.append(e.toString());\r\n        return result.toString();\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "com.google.cloud.translate.automl.ModelApi.listModelEvaluations",
	"Comment": "demonstrates using the automl client to list model evaluations.",
	"Method": "void listModelEvaluations(String projectId,String computeRegion,String modelId,String filter){\r\n    AutoMlClient client = AutoMlClient.create();\r\n    ModelName modelFullId = ModelName.of(projectId, computeRegion, modelId);\r\n    ListModelEvaluationsRequest modelEvaluationsrequest = ListModelEvaluationsRequest.newBuilder().setParent(modelFullId.toString()).setFilter(filter).build();\r\n    System.out.println(\"List of model evaluations:\");\r\n    for (ModelEvaluation element : client.listModelEvaluations(modelEvaluationsrequest).iterateAll()) {\r\n        System.out.println(element);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Type1Font.setPostscriptFontName",
	"Comment": "sets the font name that will appear in the pdf font dictionary.use with care as it can easily make a font unreadable if not embedded.",
	"Method": "void setPostscriptFontName(String name){\r\n    FontName = name;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.LtvVerifier.coversWholeDocument",
	"Comment": "checks if the signature covers the whole document\tand throws an exception if the document was altered",
	"Method": "PdfPKCS7 coversWholeDocument(){\r\n    PdfPKCS7 pkcs7 = fields.verifySignature(signatureName);\r\n    if (fields.signatureCoversWholeDocument(signatureName)) {\r\n        LOGGER.info(\"The timestamp covers whole document.\");\r\n    } else {\r\n        throw new VerificationException(null, \"Signature doesn't cover whole document.\");\r\n    }\r\n    if (pkcs7.verify()) {\r\n        LOGGER.info(\"The signed document has not been modified.\");\r\n        return pkcs7;\r\n    } else {\r\n        throw new VerificationException(null, \"The document was altered after the final signature was applied.\");\r\n    }\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONObject.optLong",
	"Comment": "get an optional long value associated with a key, or the default if thereis no such key or if the value is not a number. if the value is a string,an attempt will be made to evaluate it as a number.",
	"Method": "long optLong(String key,long optLong,String key,long defaultValue){\r\n    try {\r\n        return this.getLong(key);\r\n    } catch (Exception e) {\r\n        return defaultValue;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.PdfPKCS7.isRevocationValid",
	"Comment": "checks if ocsp revocation refers to the document signing certificate.",
	"Method": "boolean isRevocationValid(){\r\n    if (basicResp == null)\r\n        return false;\r\n    if (signCerts.size() < 2)\r\n        return false;\r\n    try {\r\n        X509Certificate[] cs = (X509Certificate[]) getSignCertificateChain();\r\n        SingleResp sr = basicResp.getResponses()[0];\r\n        CertificateID cid = sr.getCertID();\r\n        DigestCalculator digestalg = new JcaDigestCalculatorProviderBuilder().build().get(new AlgorithmIdentifier(cid.getHashAlgOID(), DERNull.INSTANCE));\r\n        X509Certificate sigcer = getSigningCertificate();\r\n        X509Certificate isscer = cs[1];\r\n        CertificateID tis = new CertificateID(digestalg, new JcaX509CertificateHolder(isscer), sigcer.getSerialNumber());\r\n        return tis.equals(cid);\r\n    } catch (Exception ex) {\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.XfaForm.getDatasetsSom",
	"Comment": "gets the class that contains the datasets processing section of the xfa.",
	"Method": "Xml2SomDatasets getDatasetsSom(){\r\n    return datasetsSom;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.pdfcleanup.PdfCleanUpContentOperator.toPdf",
	"Comment": "overriding standard pdfobject.topdf because we need sorted pdfdictionaries.",
	"Method": "void toPdf(PdfObject object,PdfWriter writer,OutputStream os){\r\n    if (object instanceof PdfDictionary) {\r\n        os.write('<');\r\n        os.write('<');\r\n        List<PdfName> keys = new ArrayList<PdfName>(((PdfDictionary) object).getKeys());\r\n        Collections.sort(keys);\r\n        for (PdfName key : keys) {\r\n            toPdf(key, writer, os);\r\n            PdfObject value = ((PdfDictionary) object).get(key);\r\n            int type = value.type();\r\n            if (type != PdfObject.ARRAY && type != PdfObject.DICTIONARY && type != PdfObject.NAME && type != PdfObject.STRING) {\r\n                os.write(' ');\r\n            }\r\n            toPdf(value, writer, os);\r\n        }\r\n        os.write('>');\r\n        os.write('>');\r\n    } else {\r\n        object.toPdf(writer, os);\r\n    }\r\n}"
}, {
	"Path": "com.machinepublishers.glass.ui.monocle.NativePlatform.shutdown",
	"Comment": "called once during javafx shutdown to release platform resources.",
	"Method": "void shutdown(){\r\n    runnableProcessor.shutdown();\r\n    if (cursor != null) {\r\n        cursor.shutdown();\r\n    }\r\n    if (screen != null) {\r\n        screen.shutdown();\r\n    }\r\n}"
}, {
	"Path": "com.squareup.wire.schema.internal.parser.RpcMethodScanner.protoFilePackageMatches",
	"Comment": "has to roughly match.com.example.api.foo matches com.example.foo",
	"Method": "boolean protoFilePackageMatches(String protoClass,String[] packageTokens){\r\n    int index = 0;\r\n    for (int i = 0; i < packageTokens.length; i++) {\r\n        index = protoClass.indexOf(packageTokens[i], index);\r\n        if (index == -1) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jbox2d.testbed.framework.TestbedCamera.moveWorld",
	"Comment": "moves the camera by the given distance in screen coordinates.",
	"Method": "void moveWorld(Vec2 screenDiff){\r\n    transform.getScreenVectorToWorld(screenDiff, worldDiff);\r\n    if (!transform.isYFlip()) {\r\n        worldDiff.y = -worldDiff.y;\r\n    }\r\n    transform.setCenter(transform.getCenter().addLocal(worldDiff));\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.setAllowSleep",
	"Comment": "set this flag to false if this body should never fall asleep. note that this increases cpuusage.",
	"Method": "void setAllowSleep(boolean allowSleep){\r\n    this.allowSleep = allowSleep;\r\n}"
}, {
	"Path": "com.structurizr.view.ViewSet.createDeploymentView",
	"Comment": "creates a deployment view, where the scope of the view is the specified software system.",
	"Method": "DeploymentView createDeploymentView(String key,String description,DeploymentView createDeploymentView,SoftwareSystem softwareSystem,String key,String description){\r\n    assertThatTheSoftwareSystemIsNotNull(softwareSystem);\r\n    assertThatTheViewKeyIsSpecifiedAndUnique(key);\r\n    DeploymentView view = new DeploymentView(softwareSystem, key, description);\r\n    view.setViewSet(this);\r\n    deploymentViews.add(view);\r\n    return view;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Type1Font.getRawWidth",
	"Comment": "gets the width from the font according to the name or,if the name is null, meaning it is a symbolic font,the char c.",
	"Method": "int getRawWidth(int c,String name){\r\n    Object[] metrics;\r\n    if (name == null) {\r\n        metrics = CharMetrics.get(Integer.valueOf(c));\r\n    } else {\r\n        if (name.equals(\".notdef\"))\r\n            return 0;\r\n        metrics = CharMetrics.get(name);\r\n    }\r\n    if (metrics != null)\r\n        return ((Integer) metrics[1]).intValue();\r\n    return 0;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Barcode.isChecksumText",
	"Comment": "gets the property to show the generated checksum in the the text.",
	"Method": "boolean isChecksumText(){\r\n    return checksumText;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentByte.createPrinterGraphicsShapes",
	"Comment": "gets a graphics2d to print on. the graphicsare translated to pdf commands.",
	"Method": "java.awt.Graphics2D createPrinterGraphicsShapes(float width,float height,java.awt.print.PrinterJob printerJob,java.awt.Graphics2D createPrinterGraphicsShapes,float width,float height,boolean convertImagesToJPEG,float quality,java.awt.print.PrinterJob printerJob){\r\n    return new PdfPrinterGraphics2D(this, width, height, null, true, convertImagesToJPEG, quality, printerJob);\r\n}"
}, {
	"Path": "com.example.vision.Detect.detectLocalizedObjectsGcs",
	"Comment": "detects localized objects in a remote image on google cloud storage.",
	"Method": "void detectLocalizedObjectsGcs(String gcsPath,PrintStream out){\r\n    List<AnnotateImageRequest> requests = new ArrayList();\r\n    ImageSource imgSource = ImageSource.newBuilder().setGcsImageUri(gcsPath).build();\r\n    Image img = Image.newBuilder().setSource(imgSource).build();\r\n    AnnotateImageRequest request = AnnotateImageRequest.newBuilder().addFeatures(Feature.newBuilder().setType(Type.OBJECT_LOCALIZATION)).setImage(img).build();\r\n    requests.add(request);\r\n    try (ImageAnnotatorClient client = ImageAnnotatorClient.create()) {\r\n        BatchAnnotateImagesResponse response = client.batchAnnotateImages(requests);\r\n        List<AnnotateImageResponse> responses = response.getResponsesList();\r\n        client.close();\r\n        for (AnnotateImageResponse res : responses) {\r\n            for (LocalizedObjectAnnotation entity : res.getLocalizedObjectAnnotationsList()) {\r\n                out.format(\"Object name: %s\\n\", entity.getName());\r\n                out.format(\"Confidence: %s\\n\", entity.getScore());\r\n                out.format(\"Normalized Vertices:\\n\");\r\n                entity.getBoundingPoly().getNormalizedVerticesList().forEach(vertex -> out.format(\"- (%s, %s)\\n\", vertex.getX(), vertex.getY()));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.LtvVerifier.verify",
	"Comment": "verifies certificates against a list of crls and ocsp responses.",
	"Method": "List<VerificationOK> verify(List<VerificationOK> result,List<VerificationOK> verify,X509Certificate signCert,X509Certificate issuerCert,Date signDate){\r\n    RootStoreVerifier rootStoreVerifier = new RootStoreVerifier(verifier);\r\n    rootStoreVerifier.setRootStore(rootStore);\r\n    CRLVerifier crlVerifier = new CRLVerifier(rootStoreVerifier, getCRLsFromDSS());\r\n    crlVerifier.setRootStore(rootStore);\r\n    crlVerifier.setOnlineCheckingAllowed(latestRevision || onlineCheckingAllowed);\r\n    OCSPVerifier ocspVerifier = new OCSPVerifier(crlVerifier, getOCSPResponsesFromDSS());\r\n    ocspVerifier.setRootStore(rootStore);\r\n    ocspVerifier.setOnlineCheckingAllowed(latestRevision || onlineCheckingAllowed);\r\n    return ocspVerifier.verify(signCert, issuerCert, signDate);\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPNode.addQualifier",
	"Comment": "appends a qualifier to the qualifier list and sets respective options.",
	"Method": "void addQualifier(XMPNode qualNode){\r\n    assertQualifierNotExisting(qualNode.getName());\r\n    qualNode.setParent(this);\r\n    qualNode.getOptions().setQualifier(true);\r\n    getOptions().setHasQualifiers(true);\r\n    if (qualNode.isLanguageNode()) {\r\n        options.setHasLanguage(true);\r\n        getQualifier().add(0, qualNode);\r\n    } else if (qualNode.isTypeNode()) {\r\n        options.setHasType(true);\r\n        getQualifier().add(!options.getHasLanguage() ? 0 : 1, qualNode);\r\n    } else {\r\n        getQualifier().add(qualNode);\r\n    }\r\n}"
}, {
	"Path": "com.example.firestore.snippets.ManageDataSnippets.addDocumentWithDifferentDataTypes",
	"Comment": "add a document to a collection using a map with different supported data types.",
	"Method": "Map<String, Object> addDocumentWithDifferentDataTypes(){\r\n    Map<String, Object> docData = new HashMap();\r\n    docData.put(\"stringExample\", \"Hello, World\");\r\n    docData.put(\"booleanExample\", false);\r\n    docData.put(\"numberExample\", 3.14159265);\r\n    docData.put(\"nullExample\", null);\r\n    ArrayList<Object> arrayExample = new ArrayList();\r\n    Collections.addAll(arrayExample, 5L, true, \"hello\");\r\n    docData.put(\"arrayExample\", arrayExample);\r\n    Map<String, Object> objectExample = new HashMap();\r\n    objectExample.put(\"a\", 5L);\r\n    objectExample.put(\"b\", true);\r\n    docData.put(\"objectExample\", objectExample);\r\n    ApiFuture<WriteResult> future = db.collection(\"data\").document(\"one\").set(docData);\r\n    System.out.println(\"Update time : \" + future.get().getUpdateTime());\r\n    return docData;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONObject.optDouble",
	"Comment": "get an optional double associated with a key, or the defaultvalue ifthere is no such key or if its value is not a number. if the value is astring, an attempt will be made to evaluate it as a number.",
	"Method": "double optDouble(String key,double optDouble,String key,double defaultValue){\r\n    try {\r\n        return this.getDouble(key);\r\n    } catch (Exception e) {\r\n        return defaultValue;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.codec.Base64.decodeToObject",
	"Comment": "attempts to decode base64 data and deserialize a javaobject within. returns null if there was an error.",
	"Method": "Object decodeToObject(String encodedObject){\r\n    byte[] objBytes = decode(encodedObject);\r\n    java.io.ByteArrayInputStream bais = null;\r\n    java.io.ObjectInputStream ois = null;\r\n    Object obj = null;\r\n    try {\r\n        bais = new java.io.ByteArrayInputStream(objBytes);\r\n        ois = new java.io.ObjectInputStream(bais);\r\n        obj = ois.readObject();\r\n    } catch (java.io.IOException e) {\r\n        e.printStackTrace();\r\n    } catch (java.lang.ClassNotFoundException e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        try {\r\n            bais.close();\r\n        } catch (Exception e) {\r\n        }\r\n        try {\r\n            ois.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.TrueTypeFont.readStandardString",
	"Comment": "reads a string from the font file as bytes using the cp1252encoding.",
	"Method": "String readStandardString(int length){\r\n    return rf.readString(length, WINANSI);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.LineDashPattern.getDashPhase",
	"Comment": "getter for the dash phase.the dash phase shall specify the distance into the dash pattern at whichto start the dash. the elements are expressed in user space units.",
	"Method": "float getDashPhase(){\r\n    return dashPhase;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfName.compareTo",
	"Comment": "compares this object with the specified object for order.returns a negative integer, zero, or a positive integer as this objectis less than, equal to, or greater than the specified object.",
	"Method": "int compareTo(PdfName name){\r\n    byte[] myBytes = bytes;\r\n    byte[] objBytes = name.bytes;\r\n    int len = Math.min(myBytes.length, objBytes.length);\r\n    for (int i = 0; i < len; i++) {\r\n        if (myBytes[i] > objBytes[i])\r\n            return 1;\r\n        if (myBytes[i] < objBytes[i])\r\n            return -1;\r\n    }\r\n    if (myBytes.length < objBytes.length)\r\n        return -1;\r\n    if (myBytes.length > objBytes.length)\r\n        return 1;\r\n    return 0;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfArray.getArrayList",
	"Comment": "get the internal arraylist for this pdfarray.not recommended.",
	"Method": "ArrayList<PdfObject> getArrayList(){\r\n    return arrayList;\r\n}"
}, {
	"Path": "com.itextpdf.text.html.simpleparser.HTMLWorker.setProviders",
	"Comment": "setter for the providers.\tif a fontprovider is added, the elementfactory is updated.",
	"Method": "void setProviders(Map<String, Object> providers){\r\n    if (providers == null)\r\n        return;\r\n    this.providers = providers;\r\n    FontProvider ff = null;\r\n    if (providers != null)\r\n        ff = (FontProvider) providers.get(FONT_PROVIDER);\r\n    if (ff != null)\r\n        factory.setFontProvider(ff);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CJKFont.setPostscriptFontName",
	"Comment": "sets the font name that will appear in the pdf font dictionary.use with care as it can easily make a font unreadable if not embedded.",
	"Method": "void setPostscriptFontName(String name){\r\n    fontName = name;\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.TagUtilsTest.testNoSiblingAvailable",
	"Comment": "validates that nosiblingexception is thrown when none is found.",
	"Method": "void testNoSiblingAvailable(){\r\n    parent.addChild(sibling2);\r\n    parent.addChild(sibling3);\r\n    TagUtils.getInstance().getSibling(sibling2, -1);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPageLabels.getPageLabels",
	"Comment": "retrieves the page labels from a pdf as an array of string objects.",
	"Method": "String[] getPageLabels(PdfReader reader){\r\n    int n = reader.getNumberOfPages();\r\n    PdfDictionary dict = reader.getCatalog();\r\n    PdfDictionary labels = (PdfDictionary) PdfReader.getPdfObjectRelease(dict.get(PdfName.PAGELABELS));\r\n    if (labels == null)\r\n        return null;\r\n    String[] labelstrings = new String[n];\r\n    HashMap<Integer, PdfObject> numberTree = PdfNumberTree.readTree(labels);\r\n    int pagecount = 1;\r\n    Integer current;\r\n    String prefix = \"\";\r\n    char type = 'D';\r\n    for (int i = 0; i < n; i++) {\r\n        current = Integer.valueOf(i);\r\n        if (numberTree.containsKey(current)) {\r\n            PdfDictionary d = (PdfDictionary) PdfReader.getPdfObjectRelease(numberTree.get(current));\r\n            if (d.contains(PdfName.ST)) {\r\n                pagecount = ((PdfNumber) d.get(PdfName.ST)).intValue();\r\n            } else {\r\n                pagecount = 1;\r\n            }\r\n            if (d.contains(PdfName.P)) {\r\n                prefix = ((PdfString) d.get(PdfName.P)).toUnicodeString();\r\n            } else {\r\n                prefix = \"\";\r\n            }\r\n            if (d.contains(PdfName.S)) {\r\n                type = ((PdfName) d.get(PdfName.S)).toString().charAt(1);\r\n            } else {\r\n                type = 'e';\r\n            }\r\n        }\r\n        switch(type) {\r\n            default:\r\n                labelstrings[i] = prefix + pagecount;\r\n                break;\r\n            case 'R':\r\n                labelstrings[i] = prefix + RomanNumberFactory.getUpperCaseString(pagecount);\r\n                break;\r\n            case 'r':\r\n                labelstrings[i] = prefix + RomanNumberFactory.getLowerCaseString(pagecount);\r\n                break;\r\n            case 'A':\r\n                labelstrings[i] = prefix + RomanAlphabetFactory.getUpperCaseString(pagecount);\r\n                break;\r\n            case 'a':\r\n                labelstrings[i] = prefix + RomanAlphabetFactory.getLowerCaseString(pagecount);\r\n                break;\r\n            case 'e':\r\n                labelstrings[i] = prefix;\r\n                break;\r\n        }\r\n        pagecount++;\r\n    }\r\n    return labelstrings;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONObject.isNull",
	"Comment": "determine if the value associated with the key is null or if there is novalue.",
	"Method": "boolean isNull(String key){\r\n    return JSONObject.NULL.equals(this.opt(key));\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.zip.Keep.find",
	"Comment": "find the integer value associated with this key, or nothing if this keyis not in the keep.",
	"Method": "int find(Object key){\r\n    Object o = this.map.get(key);\r\n    return o instanceof Integer ? ((Integer) o).intValue() : none;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfGState.setBlendMode",
	"Comment": "the current blend mode to be used in the transparent imaging model.",
	"Method": "void setBlendMode(PdfName bm){\r\n    put(PdfName.BM, bm);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.OcspClientBouncyCastle.getEncoded",
	"Comment": "gets an encoded byte array with ocsp validation. the method should not throw an exception.",
	"Method": "byte[] getEncoded(X509Certificate checkCert,X509Certificate rootCert,String url){\r\n    try {\r\n        BasicOCSPResp basicResponse = getBasicOCSPResp(checkCert, rootCert, url);\r\n        if (basicResponse != null) {\r\n            SingleResp[] responses = basicResponse.getResponses();\r\n            if (responses.length == 1) {\r\n                SingleResp resp = responses[0];\r\n                Object status = resp.getCertStatus();\r\n                if (status == CertificateStatus.GOOD) {\r\n                    return basicResponse.getEncoded();\r\n                } else if (status instanceof org.bouncycastle.ocsp.RevokedStatus) {\r\n                    throw new IOException(MessageLocalization.getComposedMessage(\"ocsp.status.is.revoked\"));\r\n                } else {\r\n                    throw new IOException(MessageLocalization.getComposedMessage(\"ocsp.status.is.unknown\"));\r\n                }\r\n            }\r\n        }\r\n    } catch (Exception ex) {\r\n        if (LOGGER.isLogging(Level.ERROR))\r\n            LOGGER.error(ex.getMessage());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.createSubsetPrefix",
	"Comment": "creates a unique subset prefix to be added to the font name when the font is embedded and subset.",
	"Method": "String createSubsetPrefix(){\r\n    StringBuilder s = new StringBuilder(\"\");\r\n    for (int k = 0; k < 6; ++k) s.append((char) (Math.random() * 26 + 'A'));\r\n    return s + \"+\";\r\n}"
}, {
	"Path": "com.itextpdf.text.RectangleReadOnly.setUseVariableBorders",
	"Comment": "sets a parameter indicating if the rectangle has variable borders",
	"Method": "void setUseVariableBorders(boolean useVariableBorders){\r\n    throwReadOnlyError();\r\n}"
}, {
	"Path": "software.amazon.ion.impl.PrivateUtils.valueIsLocalSymbolTable",
	"Comment": "checks the passed in value and returns whether or notthe value could be a local symbol table.it does thisby checking the type and annotations.",
	"Method": "boolean valueIsLocalSymbolTable(PrivateIonValue v){\r\n    return (v instanceof IonStruct && v.findTypeAnnotation(ION_SYMBOL_TABLE) == 0);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentByte.getDuplicate",
	"Comment": "gets a duplicate of this pdfcontentbyte. allthe members are copied by reference but the buffer stays different.",
	"Method": "PdfContentByte getDuplicate(PdfContentByte getDuplicate,boolean inheritGraphicState){\r\n    PdfContentByte cb = this.getDuplicate();\r\n    if (inheritGraphicState) {\r\n        cb.state = state;\r\n        cb.stateList = stateList;\r\n    }\r\n    return cb;\r\n}"
}, {
	"Path": "com.google.cloud.vision.samples.automl.DatasetApi.exportData",
	"Comment": "demonstrates using the automl client to export a dataset to a google cloud storage bucket.",
	"Method": "void exportData(String projectId,String computeRegion,String datasetId,String gcsUri){\r\n    AutoMlClient client = AutoMlClient.create();\r\n    DatasetName datasetFullId = DatasetName.of(projectId, computeRegion, datasetId);\r\n    GcsDestination gcsDestination = GcsDestination.newBuilder().setOutputUriPrefix(gcsUri).build();\r\n    OutputConfig outputConfig = OutputConfig.newBuilder().setGcsDestination(gcsDestination).build();\r\n    System.out.println(\"Processing export...\");\r\n    Empty response = client.exportDataAsync(datasetFullId, outputConfig).get();\r\n    System.out.println(String.format(\"Dataset exported. %s\", response));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.mc.MCParser.println",
	"Comment": "writes a pdf object to the outputstream, followed by a newline character.",
	"Method": "void println(PdfObject o){\r\n    checkBT();\r\n    o.toPdf(null, baos);\r\n    baos.write('\\n');\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.makeRemoteNamedDestinationsLocal",
	"Comment": "replaces remote named links with local destinations that have the same name.",
	"Method": "void makeRemoteNamedDestinationsLocal(){\r\n    if (remoteToLocalNamedDestinations)\r\n        return;\r\n    remoteToLocalNamedDestinations = true;\r\n    HashMap<Object, PdfObject> names = getNamedDestination(true);\r\n    if (names.isEmpty())\r\n        return;\r\n    for (int k = 1; k <= pageRefs.size(); ++k) {\r\n        PdfDictionary page = pageRefs.getPageN(k);\r\n        PdfObject annotsRef;\r\n        PdfArray annots = (PdfArray) getPdfObject(annotsRef = page.get(PdfName.ANNOTS));\r\n        int annotIdx = lastXrefPartial;\r\n        releaseLastXrefPartial();\r\n        if (annots == null) {\r\n            pageRefs.releasePage(k);\r\n            continue;\r\n        }\r\n        boolean commitAnnots = false;\r\n        for (int an = 0; an < annots.size(); ++an) {\r\n            PdfObject objRef = annots.getPdfObject(an);\r\n            if (convertNamedDestination(objRef, names) && !objRef.isIndirect())\r\n                commitAnnots = true;\r\n        }\r\n        if (commitAnnots)\r\n            setXrefPartialObject(annotIdx, annots);\r\n        if (!commitAnnots || annotsRef.isIndirect())\r\n            pageRefs.releasePage(k);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.spatial.MeasureRectilinear.getSubType",
	"Comment": "gets the subtype.\tin this case rl for a rectilinear coordinate system.",
	"Method": "PdfName getSubType(){\r\n    return PdfName.RL;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.IonReaderTextRawTokensX.skip_whitespace",
	"Comment": "skips whitespace and applies the given commentstrategy to any commentsfound. finishes at the starting position of the next token.",
	"Method": "boolean skip_whitespace(boolean skip_whitespace,CommentStrategy commentStrategy){\r\n    boolean any_whitespace = false;\r\n    int c;\r\n    loop: for (; ; ) {\r\n        c = read_char();\r\n        switch(c) {\r\n            case -1:\r\n                break loop;\r\n            case ' ':\r\n            case '\\t':\r\n            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_1:\r\n            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_2:\r\n            case CharacterSequence.CHAR_SEQ_NEWLINE_SEQUENCE_3:\r\n            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1:\r\n            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2:\r\n            case CharacterSequence.CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3:\r\n                any_whitespace = true;\r\n                break;\r\n            case '/':\r\n                if (!commentStrategy.onComment(this)) {\r\n                    break loop;\r\n                }\r\n                any_whitespace = true;\r\n                break;\r\n            default:\r\n                break loop;\r\n        }\r\n    }\r\n    unread_char(c);\r\n    return any_whitespace;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.FixtureDef.setShape",
	"Comment": "the shape, this must be set. the shape will be cloned, so you can create the shape on thestack.",
	"Method": "void setShape(Shape shape){\r\n    this.shape = shape;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.WeldJointDef.initialize",
	"Comment": "initialize the bodies, anchors, and reference angle using a world anchor point.",
	"Method": "void initialize(Body bA,Body bB,Vec2 anchor){\r\n    bodyA = bA;\r\n    bodyB = bB;\r\n    bodyA.getLocalPointToOut(anchor, localAnchorA);\r\n    bodyB.getLocalPointToOut(anchor, localAnchorB);\r\n    referenceAngle = bodyB.getAngle() - bodyA.getAngle();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BidiOrder.isWhitespace",
	"Comment": "return true if the type is considered a whitespace type for the line break rules.",
	"Method": "boolean isWhitespace(byte biditype){\r\n    switch(biditype) {\r\n        case LRE:\r\n        case RLE:\r\n        case LRO:\r\n        case RLO:\r\n        case PDF:\r\n        case BN:\r\n        case WS:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.tokenizer.core.MMSegFilter.getLargestAverageWordLengthChunks",
	"Comment": "2. largest average word lengththis rule will return the chunks that own the largest average word length",
	"Method": "IChunk[] getLargestAverageWordLengthChunks(IChunk[] chunks){\r\n    double largetAverage = chunks[0].getAverageWordsLength();\r\n    int j;\r\n    for (j = 1; j < chunks.length; j++) {\r\n        if (chunks[j].getAverageWordsLength() > largetAverage) {\r\n            largetAverage = chunks[j].getAverageWordsLength();\r\n        }\r\n    }\r\n    ArrayList<IChunk> chunkArr = new ArrayList<IChunk>(chunks.length);\r\n    for (j = 0; j < chunks.length; j++) {\r\n        if (chunks[j].getAverageWordsLength() == largetAverage) {\r\n            chunkArr.add(chunks[j]);\r\n        }\r\n    }\r\n    IChunk[] lchunk = new IChunk[chunkArr.size()];\r\n    chunkArr.toArray(lchunk);\r\n    chunkArr.clear();\r\n    return lchunk;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDocument.localDestination",
	"Comment": "the local destination to where a local goto with the samename will jump to.",
	"Method": "boolean localDestination(String name,PdfDestination destination){\r\n    Destination dest = localDestinations.get(name);\r\n    if (dest == null)\r\n        dest = new Destination();\r\n    if (dest.destination != null)\r\n        return false;\r\n    dest.destination = destination;\r\n    localDestinations.put(name, dest);\r\n    if (!destination.hasPage())\r\n        destination.addPage(writer.getCurrentPage());\r\n    return true;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.ReconstructFDArray",
	"Comment": "function subsets the fdarray and builds the new one with new offsets",
	"Method": "void ReconstructFDArray(int Font,OffsetItem[] fdPrivate){\r\n    BuildIndexHeader(fonts[Font].FDArrayCount, fonts[Font].FDArrayOffsize, 1);\r\n    OffsetItem[] fdOffsets = new IndexOffsetItem[fonts[Font].FDArrayOffsets.length - 1];\r\n    for (int i = 0; i < fonts[Font].FDArrayOffsets.length - 1; i++) {\r\n        fdOffsets[i] = new IndexOffsetItem(fonts[Font].FDArrayOffsize);\r\n        OutputList.addLast(fdOffsets[i]);\r\n    }\r\n    IndexBaseItem fdArrayBase = new IndexBaseItem();\r\n    OutputList.addLast(fdArrayBase);\r\n    for (int k = 0; k < fonts[Font].FDArrayOffsets.length - 1; k++) {\r\n        seek(fonts[Font].FDArrayOffsets[k]);\r\n        while (getPosition() < fonts[Font].FDArrayOffsets[k + 1]) {\r\n            int p1 = getPosition();\r\n            getDictItem();\r\n            int p2 = getPosition();\r\n            if (key == \"Private\") {\r\n                int NewSize = ((Integer) args[0]).intValue();\r\n                int OrgSubrsOffsetSize = CalcSubrOffsetSize(fonts[Font].fdprivateOffsets[k], fonts[Font].fdprivateLengths[k]);\r\n                if (OrgSubrsOffsetSize != 0)\r\n                    NewSize += 5 - OrgSubrsOffsetSize;\r\n                OutputList.addLast(new DictNumberItem(NewSize));\r\n                fdPrivate[k] = new DictOffsetItem();\r\n                OutputList.addLast(fdPrivate[k]);\r\n                OutputList.addLast(new UInt8Item((char) 18));\r\n                seek(p2);\r\n            } else\r\n                OutputList.addLast(new RangeItem(buf, p1, p2 - p1));\r\n        }\r\n        OutputList.addLast(new IndexMarkerItem(fdOffsets[k], fdArrayBase));\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.resetMassData",
	"Comment": "this resets the mass properties to the sum of the mass properties of the fixtures. thisnormally does not need to be called unless you called setmassdata to override the mass and youlater want to reset the mass.",
	"Method": "void resetMassData(){\r\n    m_mass = 0.0f;\r\n    m_invMass = 0.0f;\r\n    m_I = 0.0f;\r\n    m_invI = 0.0f;\r\n    m_sweep.localCenter.setZero();\r\n    if (m_type == BodyType.STATIC || m_type == BodyType.KINEMATIC) {\r\n        m_sweep.c0.set(m_xf.p);\r\n        m_sweep.c.set(m_xf.p);\r\n        m_sweep.a0 = m_sweep.a;\r\n        return;\r\n    }\r\n    assert (m_type == BodyType.DYNAMIC);\r\n    final Vec2 localCenter = m_world.getPool().popVec2();\r\n    localCenter.setZero();\r\n    final Vec2 temp = m_world.getPool().popVec2();\r\n    final MassData massData = pmd;\r\n    for (Fixture f = m_fixtureList; f != null; f = f.m_next) {\r\n        if (f.m_density == 0.0f) {\r\n            continue;\r\n        }\r\n        f.getMassData(massData);\r\n        m_mass += massData.mass;\r\n        temp.set(massData.center).mulLocal(massData.mass);\r\n        localCenter.addLocal(temp);\r\n        m_I += massData.I;\r\n    }\r\n    if (m_mass > 0.0f) {\r\n        m_invMass = 1.0f / m_mass;\r\n        localCenter.mulLocal(m_invMass);\r\n    } else {\r\n        m_mass = 1.0f;\r\n        m_invMass = 1.0f;\r\n    }\r\n    if (m_I > 0.0f && (m_flags & e_fixedRotationFlag) == 0) {\r\n        m_I -= m_mass * Vec2.dot(localCenter, localCenter);\r\n        assert (m_I > 0.0f);\r\n        m_invI = 1.0f / m_I;\r\n    } else {\r\n        m_I = 0.0f;\r\n        m_invI = 0.0f;\r\n    }\r\n    Vec2 oldCenter = m_world.getPool().popVec2();\r\n    oldCenter.set(m_sweep.c);\r\n    m_sweep.localCenter.set(localCenter);\r\n    Transform.mulToOutUnsafe(m_xf, m_sweep.localCenter, m_sweep.c0);\r\n    m_sweep.c.set(m_sweep.c0);\r\n    temp.set(m_sweep.c).subLocal(oldCenter);\r\n    final Vec2 temp2 = oldCenter;\r\n    Vec2.crossToOutUnsafe(m_angularVelocity, temp, temp2);\r\n    m_linearVelocity.addLocal(temp2);\r\n    m_world.getPool().pushVec2(3);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.shouldCollide",
	"Comment": "this is used to prevent connected bodies from colliding. it may lie, depending on thecollideconnected flag.",
	"Method": "boolean shouldCollide(Body other){\r\n    if (m_type != BodyType.DYNAMIC && other.m_type != BodyType.DYNAMIC) {\r\n        return false;\r\n    }\r\n    for (JointEdge jn = m_jointList; jn != null; jn = jn.next) {\r\n        if (jn.other == other) {\r\n            if (jn.joint.getCollideConnected() == false) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Barcode.setAltText",
	"Comment": "sets the alternate text. if present, this text will be used instead of thetext derived from the supplied code.",
	"Method": "void setAltText(String altText){\r\n    this.altText = altText;\r\n}"
}, {
	"Path": "org.jbox2d.collision.shapes.PolygonShape.validate",
	"Comment": "validate convexity. this is a very time consuming operation.",
	"Method": "boolean validate(){\r\n    for (int i = 0; i < m_count; ++i) {\r\n        int i1 = i;\r\n        int i2 = i < m_count - 1 ? i1 + 1 : 0;\r\n        Vec2 p = m_vertices[i1];\r\n        Vec2 e = pool1.set(m_vertices[i2]).subLocal(p);\r\n        for (int j = 0; j < m_count; ++j) {\r\n            if (j == i1 || j == i2) {\r\n                continue;\r\n            }\r\n            Vec2 v = pool2.set(m_vertices[j]).subLocal(p);\r\n            float c = Vec2.cross(e, v);\r\n            if (c < 0.0f) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.getPageReference",
	"Comment": "use this method to get a reference to a page existing or not.if the page does not exist yet the reference will be createdin advance. if on closing the document, a page number greaterthan the total number of pages was requested, an exceptionis thrown.",
	"Method": "PdfIndirectReference getPageReference(int page){\r\n    --page;\r\n    if (page < 0)\r\n        throw new IndexOutOfBoundsException(MessageLocalization.getComposedMessage(\"the.page.number.must.be.gt.eq.1\"));\r\n    PdfIndirectReference ref;\r\n    if (page < pageReferences.size()) {\r\n        ref = pageReferences.get(page);\r\n        if (ref == null) {\r\n            ref = body.getPdfIndirectReference();\r\n            pageReferences.set(page, ref);\r\n        }\r\n    } else {\r\n        int empty = page - pageReferences.size();\r\n        for (int k = 0; k < empty; ++k) pageReferences.add(null);\r\n        ref = body.getPdfIndirectReference();\r\n        pageReferences.add(ref);\r\n    }\r\n    return ref;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStructureTreeRoot.mapRole",
	"Comment": "maps the user tags to the standard tags. the mapping will allow a standard application to make some sense of the taggeddocument whatever the user tags may be.",
	"Method": "void mapRole(PdfName used,PdfName standard){\r\n    PdfDictionary rm = (PdfDictionary) get(PdfName.ROLEMAP);\r\n    if (rm == null) {\r\n        rm = new PdfDictionary();\r\n        put(PdfName.ROLEMAP, rm);\r\n    }\r\n    rm.put(used, standard);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.ByteBuffer.append",
	"Comment": "appends a string representation of a double accordingto the pdf conventions.",
	"Method": "ByteBuffer append(byte b,int off,int len,ByteBuffer append,byte b,ByteBuffer append,String str,ByteBuffer append,char c,ByteBuffer append,ByteBuffer buf,ByteBuffer append,int i,ByteBuffer append,long i,ByteBuffer append,byte b,ByteBuffer append,float i,ByteBuffer append,double d){\r\n    append(formatDouble(d, this));\r\n    return this;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.tokenizer.core.MMSegFilter.getSmallestVarianceWordLengthChunks",
	"Comment": "the smallest variance word lengththis rule will the chunks that one the smallest variance word length",
	"Method": "IChunk[] getSmallestVarianceWordLengthChunks(IChunk[] chunks){\r\n    double smallestVariance = chunks[0].getWordsVariance();\r\n    int j;\r\n    for (j = 1; j < chunks.length; j++) {\r\n        if (chunks[j].getWordsVariance() < smallestVariance) {\r\n            smallestVariance = chunks[j].getWordsVariance();\r\n        }\r\n    }\r\n    ArrayList<IChunk> chunkArr = new ArrayList<IChunk>(chunks.length);\r\n    for (j = 0; j < chunks.length; j++) {\r\n        if (chunks[j].getWordsVariance() == smallestVariance) {\r\n            chunkArr.add(chunks[j]);\r\n        }\r\n    }\r\n    IChunk[] lchunk = new IChunk[chunkArr.size()];\r\n    chunkArr.toArray(lchunk);\r\n    chunkArr.clear();\r\n    return lchunk;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfGState.setFillOpacity",
	"Comment": "sets the current stroking alpha constant, specifying the constant shape orconstant opacity value to be used for nonstroking operations in the transparentimaging model.",
	"Method": "void setFillOpacity(float ca){\r\n    put(PdfName.ca, new PdfNumber(ca));\r\n}"
}, {
	"Path": "com.structurizr.view.RelationshipView.getId",
	"Comment": "gets the id of the relationship this relationshipview represents.",
	"Method": "String getId(){\r\n    if (relationship != null) {\r\n        return relationship.getId();\r\n    } else {\r\n        return this.id;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfAnnotation.createSquareCircle",
	"Comment": "adds a circle or a square that shows a tooltip when you pass over it.",
	"Method": "PdfAnnotation createSquareCircle(PdfWriter writer,Rectangle rect,String contents,boolean square){\r\n    PdfAnnotation annot;\r\n    if (square)\r\n        annot = writer.createAnnotation(rect, PdfName.SQUARE);\r\n    else\r\n        annot = writer.createAnnotation(rect, PdfName.CIRCLE);\r\n    annot.put(PdfName.CONTENTS, new PdfString(contents, PdfObject.TEXT_UNICODE));\r\n    return annot;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.XML.parse",
	"Comment": "scan the content following the named tag, attaching it to the context.",
	"Method": "boolean parse(XMLTokener x,JSONObject context,String name){\r\n    char c;\r\n    int i;\r\n    JSONObject jsonobject = null;\r\n    String string;\r\n    String tagName;\r\n    Object token;\r\n    token = x.nextToken();\r\n    if (token == BANG) {\r\n        c = x.next();\r\n        if (c == '-') {\r\n            if (x.next() == '-') {\r\n                x.skipPast(\"-->\");\r\n                return false;\r\n            }\r\n            x.back();\r\n        } else if (c == '[') {\r\n            token = x.nextToken();\r\n            if (\"CDATA\".equals(token)) {\r\n                if (x.next() == '[') {\r\n                    string = x.nextCDATA();\r\n                    if (string.length() > 0) {\r\n                        context.accumulate(\"content\", string);\r\n                    }\r\n                    return false;\r\n                }\r\n            }\r\n            throw x.syntaxError(\"Expected 'CDATA['\");\r\n        }\r\n        i = 1;\r\n        do {\r\n            token = x.nextMeta();\r\n            if (token == null) {\r\n                throw x.syntaxError(\"Missing '>' after '<!'.\");\r\n            } else if (token == LT) {\r\n                i += 1;\r\n            } else if (token == GT) {\r\n                i -= 1;\r\n            }\r\n        } while (i > 0);\r\n        return false;\r\n    } else if (token == QUEST) {\r\n        x.skipPast(\"?>\");\r\n        return false;\r\n    } else if (token == SLASH) {\r\n        token = x.nextToken();\r\n        if (name == null) {\r\n            throw x.syntaxError(\"Mismatched close tag \" + token);\r\n        }\r\n        if (!token.equals(name)) {\r\n            throw x.syntaxError(\"Mismatched \" + name + \" and \" + token);\r\n        }\r\n        if (x.nextToken() != GT) {\r\n            throw x.syntaxError(\"Misshaped close tag\");\r\n        }\r\n        return true;\r\n    } else if (token instanceof Character) {\r\n        throw x.syntaxError(\"Misshaped tag\");\r\n    } else {\r\n        tagName = (String) token;\r\n        token = null;\r\n        jsonobject = new JSONObject();\r\n        for (; ; ) {\r\n            if (token == null) {\r\n                token = x.nextToken();\r\n            }\r\n            if (token instanceof String) {\r\n                string = (String) token;\r\n                token = x.nextToken();\r\n                if (token == EQ) {\r\n                    token = x.nextToken();\r\n                    if (!(token instanceof String)) {\r\n                        throw x.syntaxError(\"Missing value\");\r\n                    }\r\n                    jsonobject.accumulate(string, XML.stringToValue((String) token));\r\n                    token = null;\r\n                } else {\r\n                    jsonobject.accumulate(string, \"\");\r\n                }\r\n            } else if (token == SLASH) {\r\n                if (x.nextToken() != GT) {\r\n                    throw x.syntaxError(\"Misshaped tag\");\r\n                }\r\n                if (jsonobject.length() > 0) {\r\n                    context.accumulate(tagName, jsonobject);\r\n                } else {\r\n                    context.accumulate(tagName, \"\");\r\n                }\r\n                return false;\r\n            } else if (token == GT) {\r\n                for (; ; ) {\r\n                    token = x.nextContent();\r\n                    if (token == null) {\r\n                        if (tagName != null) {\r\n                            throw x.syntaxError(\"Unclosed tag \" + tagName);\r\n                        }\r\n                        return false;\r\n                    } else if (token instanceof String) {\r\n                        string = (String) token;\r\n                        if (string.length() > 0) {\r\n                            jsonobject.accumulate(\"content\", XML.stringToValue(string));\r\n                        }\r\n                    } else if (token == LT) {\r\n                        if (parse(x, jsonobject, tagName)) {\r\n                            if (jsonobject.length() == 0) {\r\n                                context.accumulate(tagName, \"\");\r\n                            } else if (jsonobject.length() == 1 && jsonobject.opt(\"content\") != null) {\r\n                                context.accumulate(tagName, jsonobject.opt(\"content\"));\r\n                            } else {\r\n                                context.accumulate(tagName, jsonobject);\r\n                            }\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                throw x.syntaxError(\"Misshaped tag\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.ColumnText.getWidth",
	"Comment": "gets the width that the line will occupy after writing. only the width ofthe first line is returned.",
	"Method": "float getWidth(Phrase phrase,int runDirection,int arabicOptions,float getWidth,Phrase phrase){\r\n    return getWidth(phrase, PdfWriter.RUN_DIRECTION_NO_BIDI, 0);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.contacts.Contact.getManifold",
	"Comment": "get the contact manifold. do not set the point count to zero. instead call disable.",
	"Method": "Manifold getManifold(){\r\n    return m_manifold;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.util.Sort.median",
	"Comment": "get the median of the left, center and rightorder these and hide the pivot by put it the end of of the array",
	"Method": "T median(T[] arr,int left,int right){\r\n    int center = (left + right) / 2;\r\n    if (arr[left].compareTo(arr[center]) > 0)\r\n        swapReferences(arr, left, center);\r\n    if (arr[left].compareTo(arr[right]) > 0)\r\n        swapReferences(arr, left, right);\r\n    if (arr[center].compareTo(arr[right]) > 0)\r\n        swapReferences(arr, center, right);\r\n    swapReferences(arr, center, right - 1);\r\n    return arr[right - 1];\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONTokener.nextString",
	"Comment": "return the characters up to the next close quote character.backslash processing is done. the formal json format does notallow strings in single quotes, but an implementation is allowed toaccept them.",
	"Method": "String nextString(char quote){\r\n    char c;\r\n    StringBuilder sb = new StringBuilder();\r\n    for (; ; ) {\r\n        c = this.next();\r\n        switch(c) {\r\n            case 0:\r\n            case '\\n':\r\n            case '\\r':\r\n                throw this.syntaxError(\"Unterminated string\");\r\n            case '\\\\':\r\n                c = this.next();\r\n                switch(c) {\r\n                    case 'b':\r\n                        sb.append('\\b');\r\n                        break;\r\n                    case 't':\r\n                        sb.append('\\t');\r\n                        break;\r\n                    case 'n':\r\n                        sb.append('\\n');\r\n                        break;\r\n                    case 'f':\r\n                        sb.append('\\f');\r\n                        break;\r\n                    case 'r':\r\n                        sb.append('\\r');\r\n                        break;\r\n                    case 'u':\r\n                        sb.append((char) Integer.parseInt(this.next(4), 16));\r\n                        break;\r\n                    case '\"':\r\n                    case '\\'':\r\n                    case '\\\\':\r\n                    case '/':\r\n                        sb.append(c);\r\n                        break;\r\n                    default:\r\n                        throw this.syntaxError(\"Illegal escape.\");\r\n                }\r\n                break;\r\n            default:\r\n                if (c == quote) {\r\n                    return sb.toString();\r\n                }\r\n                sb.append(c);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.getWorldPoint",
	"Comment": "get the world coordinates of a point given the local coordinates.",
	"Method": "Vec2 getWorldPoint(Vec2 localPoint){\r\n    Vec2 v = new Vec2();\r\n    getWorldPointToOut(localPoint, v);\r\n    return v;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.Cookie.unescape",
	"Comment": "convert %hh sequences to single characters, andconvert plus to space.",
	"Method": "String unescape(String string){\r\n    int length = string.length();\r\n    StringBuilder sb = new StringBuilder(length);\r\n    for (int i = 0; i < length; ++i) {\r\n        char c = string.charAt(i);\r\n        if (c == '+') {\r\n            c = ' ';\r\n        } else if (c == '%' && i + 2 < length) {\r\n            int d = JSONTokener.dehexchar(string.charAt(i + 1));\r\n            int e = JSONTokener.dehexchar(string.charAt(i + 2));\r\n            if (d >= 0 && e >= 0) {\r\n                c = (char) (d * 16 + e);\r\n                i += 2;\r\n            }\r\n        }\r\n        sb.append(c);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.itextpdf.xmp.options.Options.getOptionName",
	"Comment": "looks up or asks the inherited class for the name of an option bit.\tits save that there is only one valid option handed into the method.",
	"Method": "String getOptionName(int option){\r\n    Map optionsNames = procureOptionNames();\r\n    Integer key = new Integer(option);\r\n    String result = (String) optionsNames.get(key);\r\n    if (result == null) {\r\n        result = defineOptionName(option);\r\n        if (result != null) {\r\n            optionsNames.put(key, result);\r\n        } else {\r\n            result = \"<option name not defined>\";\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfImage.generateImgResName",
	"Comment": "called when no resource name is provided in our constructor.this generates a name that is required to be unique within a given resource dictionary.",
	"Method": "void generateImgResName(Image img){\r\n    name = new PdfName(\"img\" + Long.toHexString(img.getMySerialId()));\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.IonRawBinaryWriterTest.testSymbol",
	"Comment": "note that we stick to system symbols for round trip assertions",
	"Method": "void testSymbol(){\r\n    writer.writeSymbolToken(null);\r\n    assertValue(\"null.symbol\");\r\n    writer.writeSymbolToken(systemSymbol(NAME_SID));\r\n    assertValue(\"name\");\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfString.toPdf",
	"Comment": "writes the pdf representation of this pdfstring as an arrayof byte to the specified outputstream.",
	"Method": "void toPdf(PdfWriter writer,OutputStream os){\r\n    PdfWriter.checkPdfIsoConformance(writer, PdfIsoKeys.PDFISOKEY_OBJECT, this);\r\n    byte[] b = getBytes();\r\n    PdfEncryption crypto = null;\r\n    if (writer != null)\r\n        crypto = writer.getEncryption();\r\n    if (crypto != null && !crypto.isEmbeddedFilesOnly())\r\n        b = crypto.encryptByteArray(b);\r\n    if (hexWriting) {\r\n        ByteBuffer buf = new ByteBuffer();\r\n        buf.append('<');\r\n        int len = b.length;\r\n        for (int k = 0; k < len; ++k) buf.appendHex(b[k]);\r\n        buf.append('>');\r\n        os.write(buf.toByteArray());\r\n    } else\r\n        os.write(StringUtils.escapeString(b));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.FdfReader.getFieldValue",
	"Comment": "gets the field value or null if the field does notexist or has no value defined.",
	"Method": "String getFieldValue(String name){\r\n    PdfDictionary field = fields.get(name);\r\n    if (field == null)\r\n        return null;\r\n    PdfObject v = getPdfObject(field.get(PdfName.V));\r\n    if (v == null)\r\n        return null;\r\n    if (v.isName())\r\n        return PdfName.decodeName(((PdfName) v).toString());\r\n    else if (v.isString()) {\r\n        PdfString vs = (PdfString) v;\r\n        if (encoding == null || vs.getEncoding() != null)\r\n            return vs.toUnicodeString();\r\n        byte[] b = vs.getBytes();\r\n        if (b.length >= 2 && b[0] == (byte) 254 && b[1] == (byte) 255)\r\n            return vs.toUnicodeString();\r\n        try {\r\n            if (encoding.equals(PdfName.SHIFT_JIS))\r\n                return new String(b, \"SJIS\");\r\n            else if (encoding.equals(PdfName.UHC))\r\n                return new String(b, \"MS949\");\r\n            else if (encoding.equals(PdfName.GBK))\r\n                return new String(b, \"GBK\");\r\n            else if (encoding.equals(PdfName.BIGFIVE))\r\n                return new String(b, \"Big5\");\r\n            else if (encoding.equals(PdfName.UTF_8))\r\n                return new String(b, \"UTF8\");\r\n        } catch (Exception e) {\r\n        }\r\n        return vs.toUnicodeString();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.PrivateCommandLine.main",
	"Comment": "this main simply prints the version information toallow users to identify the build version of the jar.",
	"Method": "void main(String[] args){\r\n    process_command_line(args);\r\n    info = new JarInfo();\r\n    if (printVersion) {\r\n        doPrintVersion();\r\n    }\r\n    if (printHelp) {\r\n        doPrintHelp();\r\n    }\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.CDL.getValue",
	"Comment": "get the next value. the value can be wrapped in quotes. the value canbe empty.",
	"Method": "String getValue(JSONTokener x){\r\n    char c;\r\n    char q;\r\n    StringBuffer sb;\r\n    do {\r\n        c = x.next();\r\n    } while (c == ' ' || c == '\\t');\r\n    switch(c) {\r\n        case 0:\r\n            return null;\r\n        case '\"':\r\n        case '\\'':\r\n            q = c;\r\n            sb = new StringBuffer();\r\n            for (; ; ) {\r\n                c = x.next();\r\n                if (c == q) {\r\n                    break;\r\n                }\r\n                if (c == 0 || c == '\\n' || c == '\\r') {\r\n                    throw x.syntaxError(\"Missing close quote '\" + q + \"'.\");\r\n                }\r\n                sb.append(c);\r\n            }\r\n            return sb.toString();\r\n        case ',':\r\n            x.back();\r\n            return \"\";\r\n        default:\r\n            x.back();\r\n            return x.nextTo(',');\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfArray.getAsNumber",
	"Comment": "returns a pdfobject as a pdfnumber,resolving indirect references.the object corresponding to the specified index is retrieved andresolved to a direct object.if it is a pdfnumber, it is cast down and returned as such.otherwise null is returned.",
	"Method": "PdfNumber getAsNumber(int idx){\r\n    PdfNumber number = null;\r\n    PdfObject orig = getDirectObject(idx);\r\n    if (orig != null && orig.isNumber())\r\n        number = (PdfNumber) orig;\r\n    return number;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.setRgbTransparencyBlending",
	"Comment": "sets the transparency blending colorspace to rgb. the default blending colorspace iscmyk and will result in faded colors in the screen and in printing. calling this methodwill return the rgb colors to what is expected. the rgb blending will be applied to all subsequent pagesuntil other value is set.note that this is a generic solution that may not work in all cases.",
	"Method": "void setRgbTransparencyBlending(boolean rgbTransparencyBlending){\r\n    this.rgbTransparencyBlending = rgbTransparencyBlending;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDictionary.putAll",
	"Comment": "copies all of the mappings from the specified pdfdictionaryto this pdfdictionary.these mappings will replace any mappings previously contained in thispdfdictionary.",
	"Method": "void putAll(PdfDictionary dic){\r\n    hashMap.putAll(dic.hashMap);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfObject.canBeInObjStm",
	"Comment": "whether this object can be contained in an object stream.pdfobjects of type stream or indirect can not be contained in anobject stream.",
	"Method": "boolean canBeInObjStm(){\r\n    switch(type) {\r\n        case NULL:\r\n        case BOOLEAN:\r\n        case NUMBER:\r\n        case STRING:\r\n        case NAME:\r\n        case ARRAY:\r\n        case DICTIONARY:\r\n            return true;\r\n        case STREAM:\r\n        case INDIRECT:\r\n        default:\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPTable.isExtendLastRow",
	"Comment": "gets the value of the last row extension, taking into account if thefinal row is reached or not.",
	"Method": "boolean isExtendLastRow(boolean isExtendLastRow,boolean newPageFollows){\r\n    if (newPageFollows) {\r\n        return extendLastRow[0];\r\n    }\r\n    return extendLastRow[1];\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.isVertical",
	"Comment": "indicates whether the font is used for verticl writing or not.",
	"Method": "boolean isVertical(){\r\n    return vertical;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPSerializerRDF.writeIndent",
	"Comment": "writes indents and automatically includes the baseindend from the options.",
	"Method": "void writeIndent(int times){\r\n    for (int i = options.getBaseIndent() + times; i > 0; i--) {\r\n        writer.write(options.getIndent());\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentByte.createTemplate",
	"Comment": "creates a new template.creates a new template that is nothing more than a form xobject. this template can be includedin this pdfcontentbyte or in another template. templates are only writtento the output when the document is closed permitting things like showing text in the first pagethat is only defined in the last page.",
	"Method": "PdfTemplate createTemplate(float width,float height,PdfTemplate createTemplate,float width,float height,PdfName forcedName){\r\n    checkWriter();\r\n    PdfTemplate template = new PdfTemplate(writer);\r\n    template.setWidth(width);\r\n    template.setHeight(height);\r\n    writer.addDirectTemplateSimple(template, forcedName);\r\n    return template;\r\n}"
}, {
	"Path": "com.structurizr.view.ComponentView.addNearestNeighbours",
	"Comment": "adds all people, software systems, sibling containers and components that are directly connected to the specified element.",
	"Method": "void addNearestNeighbours(Element element){\r\n    super.addNearestNeighbours(element, SoftwareSystem.class);\r\n    super.addNearestNeighbours(element, Person.class);\r\n    super.addNearestNeighbours(element, Container.class);\r\n    super.addNearestNeighbours(element, Component.class);\r\n}"
}, {
	"Path": "com.example.dlp.Jobs.main",
	"Comment": "command line application to list and delete dlp jobs the data loss prevention api.",
	"Method": "void main(String[] args){\r\n    OptionGroup optionsGroup = new OptionGroup();\r\n    optionsGroup.setRequired(true);\r\n    Option listOption = new Option(\"l\", \"list\", false, \"List DLP Jobs\");\r\n    optionsGroup.addOption(listOption);\r\n    Option deleteOption = new Option(\"d\", \"delete\", false, \"Delete DLP Jobs\");\r\n    optionsGroup.addOption(deleteOption);\r\n    Options commandLineOptions = new Options();\r\n    commandLineOptions.addOptionGroup(optionsGroup);\r\n    Option projectIdOption = Option.builder(\"projectId\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(projectIdOption);\r\n    Option filterOption = Option.builder(\"filter\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(filterOption);\r\n    Option jobTypeOption = Option.builder(\"jobType\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(jobTypeOption);\r\n    Option jobIdOption = Option.builder(\"jobId\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(jobIdOption);\r\n    CommandLineParser parser = new DefaultParser();\r\n    HelpFormatter formatter = new HelpFormatter();\r\n    CommandLine cmd;\r\n    try {\r\n        cmd = parser.parse(commandLineOptions, args);\r\n    } catch (ParseException e) {\r\n        System.out.println(e.getMessage());\r\n        formatter.printHelp(Inspect.class.getName(), commandLineOptions);\r\n        System.exit(1);\r\n        return;\r\n    }\r\n    String projectId = cmd.getOptionValue(projectIdOption.getOpt(), ServiceOptions.getDefaultProjectId());\r\n    if (cmd.hasOption(listOption.getOpt())) {\r\n        String filter = cmd.getOptionValue(filterOption.getOpt(), \"\");\r\n        DlpJobType jobType = DlpJobType.valueOf(cmd.getOptionValue(jobTypeOption.getOpt(), DlpJobType.DLP_JOB_TYPE_UNSPECIFIED.name()));\r\n        listJobs(projectId, filter, jobType);\r\n    }\r\n    if (cmd.hasOption(deleteOption.getOpt())) {\r\n        String jobId = cmd.getOptionValue(jobIdOption.getOpt());\r\n        deleteJob(projectId, jobId);\r\n    }\r\n}"
}, {
	"Path": "com.example.Snippets.destroyCryptoKeyVersion",
	"Comment": "marks the given version of a crypto key to be destroyed at a scheduled future point.",
	"Method": "CryptoKeyVersion destroyCryptoKeyVersion(String projectId,String locationId,String keyRingId,String cryptoKeyId,String version){\r\n    CloudKMS kms = createAuthorizedClient();\r\n    String cryptoKeyVersion = String.format(\"projects/%s/locations/%s/keyRings/%s/cryptoKeys/%s/cryptoKeyVersions/%s\", projectId, locationId, keyRingId, cryptoKeyId, version);\r\n    DestroyCryptoKeyVersionRequest destroyRequest = new DestroyCryptoKeyVersionRequest();\r\n    CryptoKeyVersion destroyed = kms.projects().locations().keyRings().cryptoKeys().cryptoKeyVersions().destroy(cryptoKeyVersion, destroyRequest).execute();\r\n    System.out.println(destroyed);\r\n    return destroyed;\r\n}"
}, {
	"Path": "com.itextpdf.text.Font.difference",
	"Comment": "replaces the attributes that are equal to null with the\tattributes of a given font.",
	"Method": "Font difference(Font font){\r\n    if (font == null)\r\n        return this;\r\n    float dSize = font.size;\r\n    if (dSize == UNDEFINED) {\r\n        dSize = this.size;\r\n    }\r\n    int dStyle = UNDEFINED;\r\n    int style1 = this.style;\r\n    int style2 = font.getStyle();\r\n    if (style1 != UNDEFINED || style2 != UNDEFINED) {\r\n        if (style1 == UNDEFINED)\r\n            style1 = 0;\r\n        if (style2 == UNDEFINED)\r\n            style2 = 0;\r\n        dStyle = style1 | style2;\r\n    }\r\n    BaseColor dColor = font.color;\r\n    if (dColor == null) {\r\n        dColor = this.color;\r\n    }\r\n    if (font.baseFont != null) {\r\n        return new Font(font.baseFont, dSize, dStyle, dColor);\r\n    }\r\n    if (font.getFamily() != FontFamily.UNDEFINED) {\r\n        return new Font(font.family, dSize, dStyle, dColor);\r\n    }\r\n    if (this.baseFont != null) {\r\n        if (dStyle == style1) {\r\n            return new Font(this.baseFont, dSize, dStyle, dColor);\r\n        } else {\r\n            return FontFactory.getFont(this.getFamilyname(), dSize, dStyle, dColor);\r\n        }\r\n    }\r\n    return new Font(this.family, dSize, dStyle, dColor);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.setFixedRotation",
	"Comment": "should this body be prevented from rotating? useful for characters.",
	"Method": "void setFixedRotation(boolean fixedRotation){\r\n    this.fixedRotation = fixedRotation;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.getCidCode",
	"Comment": "gets the cid code given an unicode.it has only meaning with cjk fonts.",
	"Method": "int getCidCode(int c){\r\n    return c;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaActivation.setPresentation",
	"Comment": "sets a richmediapresentation dictionary that contains information\tas to how the annotation and user interface elements will be visually\tlaid out and drawn.",
	"Method": "void setPresentation(RichMediaPresentation richMediaPresentation){\r\n    put(PdfName.PRESENTATION, richMediaPresentation);\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.zip.Keep.bitsize",
	"Comment": "return the number of bits required to contain an integer based on thecurrent length of the keep. as the keep fills up, the number of bitsrequired to identify one of its items goes up.",
	"Method": "int bitsize(){\r\n    while (1 << this.power < this.length) {\r\n        this.power += 1;\r\n    }\r\n    return this.power;\r\n}"
}, {
	"Path": "com.example.firestore.snippets.QueryDataSnippets.createWhereWithOrderByAndLimitQuery",
	"Comment": "creates a query that combines where clause with order by and limit operator.",
	"Method": "Query createWhereWithOrderByAndLimitQuery(){\r\n    CollectionReference cities = db.collection(\"cities\");\r\n    Query query = cities.whereGreaterThan(\"population\", 2500000L).orderBy(\"population\").limit(2);\r\n    return query;\r\n}"
}, {
	"Path": "com.google.cloud.translate.automl.ModelApi.getOperationStatus",
	"Comment": "demonstrates using the automl client to get operation status.",
	"Method": "void getOperationStatus(String operationFullId){\r\n    AutoMlClient client = AutoMlClient.create();\r\n    Operation response = client.getOperationsClient().getOperation(operationFullId);\r\n    System.out.println(String.format(\"Operation status: %s\", response));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaPresentation.setToolbar",
	"Comment": "sets a flag that indicates the default behavior of an interactive\ttoolbar associated with this annotation. if true, a toolbar is\tdisplayed when the annotation is activated and given focus. if false,\ta toolbar is not displayed by default.",
	"Method": "void setToolbar(PdfBoolean toolbar){\r\n    put(PdfName.TOOLBAR, toolbar);\r\n}"
}, {
	"Path": "com.itextpdf.text.Paragraph.setKeepTogether",
	"Comment": "indicates that the paragraph has to be kept together on one page.",
	"Method": "void setKeepTogether(boolean keeptogether){\r\n    this.keeptogether = keeptogether;\r\n}"
}, {
	"Path": "com.structurizr.view.ViewSet.createComponentView",
	"Comment": "creates a component view, where the scope of the view is the specified container.",
	"Method": "ComponentView createComponentView(Container container,String key,String description){\r\n    assertThatTheContainerIsNotNull(container);\r\n    assertThatTheViewKeyIsSpecifiedAndUnique(key);\r\n    ComponentView view = new ComponentView(container, key, description);\r\n    view.setViewSet(this);\r\n    componentViews.add(view);\r\n    return view;\r\n}"
}, {
	"Path": "com.structurizr.model.ContainerInstance.uses",
	"Comment": "adds a relationship between this container instance and another.",
	"Method": "Relationship uses(ContainerInstance destination,String description,String technology,Relationship uses,ContainerInstance destination,String description,String technology,InteractionStyle interactionStyle){\r\n    if (destination != null) {\r\n        return getModel().addRelationship(this, destination, description, technology, interactionStyle);\r\n    } else {\r\n        throw new IllegalArgumentException(\"The destination of a relationship must be specified.\");\r\n    }\r\n}"
}, {
	"Path": "com.example.firestore.snippets.ListenDataSnippets.listenToDocument",
	"Comment": "listen to a single document, returning data after the first snapshot.",
	"Method": "Map<String, Object> listenToDocument(){\r\n    final SettableApiFuture<Map<String, Object>> future = SettableApiFuture.create();\r\n    DocumentReference docRef = db.collection(\"cities\").document(\"SF\");\r\n    docRef.addSnapshotListener(new EventListener<DocumentSnapshot>() {\r\n        @Override\r\n        public void onEvent(@Nullable DocumentSnapshot snapshot, @Nullable FirestoreException e) {\r\n            if (e != null) {\r\n                System.err.println(\"Listen failed: \" + e);\r\n                return;\r\n            }\r\n            if (snapshot != null && snapshot.exists()) {\r\n                System.out.println(\"Current data: \" + snapshot.getData());\r\n            } else {\r\n                System.out.print(\"Current data: null\");\r\n            }\r\n            if (!future.isDone()) {\r\n                future.set(snapshot.getData());\r\n            }\r\n        }\r\n    });\r\n    return future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "com.example.firestore.snippets.ListenDataSnippets.listenToDocument",
	"Comment": "listen to a single document, returning data after the first snapshot.",
	"Method": "Map<String, Object> listenToDocument(){\r\n    if (e != null) {\r\n        System.err.println(\"Listen failed: \" + e);\r\n        return;\r\n    }\r\n    if (snapshot != null && snapshot.exists()) {\r\n        System.out.println(\"Current data: \" + snapshot.getData());\r\n    } else {\r\n        System.out.print(\"Current data: null\");\r\n    }\r\n    if (!future.isDone()) {\r\n        future.set(snapshot.getData());\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.Font.isStandardFont",
	"Comment": "checks if the properties of this font are undefined or null.\tif so, the standard should be used.",
	"Method": "boolean isStandardFont(){\r\n    return family == FontFamily.UNDEFINED && size == UNDEFINED && style == UNDEFINED && color == null && baseFont == null;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPNodeUtils.deleteNode",
	"Comment": "deletes the the given node and its children from its parent.\ttakes care about adjusting the flags.",
	"Method": "void deleteNode(XMPNode node){\r\n    XMPNode parent = node.getParent();\r\n    if (node.getOptions().isQualifier()) {\r\n        parent.removeQualifier(node);\r\n    } else {\r\n        parent.removeChild(node);\r\n    }\r\n    if (!parent.hasChildren() && parent.getOptions().isSchemaNode()) {\r\n        parent.getParent().removeChild(parent);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaParams.setFlashVars",
	"Comment": "sets a text string containing formatted name value pairs passed\tto the flash player context when activated.",
	"Method": "void setFlashVars(String flashVars){\r\n    put(PdfName.FLASHVARS, new PdfString(flashVars));\r\n}"
}, {
	"Path": "com.itextpdf.awt.geom.gl.Crossing.intersectPath",
	"Comment": "returns how many times rectangle stripe cross path or the are intersect",
	"Method": "int intersectPath(PathIterator p,double x,double y,double w,double h){\r\n    int cross = 0;\r\n    int count;\r\n    double mx, my, cx, cy;\r\n    mx = my = cx = cy = 0.0;\r\n    double[] coords = new double[6];\r\n    double rx1 = x;\r\n    double ry1 = y;\r\n    double rx2 = x + w;\r\n    double ry2 = y + h;\r\n    while (!p.isDone()) {\r\n        count = 0;\r\n        switch(p.currentSegment(coords)) {\r\n            case PathIterator.SEG_MOVETO:\r\n                if (cx != mx || cy != my) {\r\n                    count = intersectLine(cx, cy, mx, my, rx1, ry1, rx2, ry2);\r\n                }\r\n                mx = cx = coords[0];\r\n                my = cy = coords[1];\r\n                break;\r\n            case PathIterator.SEG_LINETO:\r\n                count = intersectLine(cx, cy, cx = coords[0], cy = coords[1], rx1, ry1, rx2, ry2);\r\n                break;\r\n            case PathIterator.SEG_QUADTO:\r\n                count = intersectQuad(cx, cy, coords[0], coords[1], cx = coords[2], cy = coords[3], rx1, ry1, rx2, ry2);\r\n                break;\r\n            case PathIterator.SEG_CUBICTO:\r\n                count = intersectCubic(cx, cy, coords[0], coords[1], coords[2], coords[3], cx = coords[4], cy = coords[5], rx1, ry1, rx2, ry2);\r\n                break;\r\n            case PathIterator.SEG_CLOSE:\r\n                if (cy != my || cx != mx) {\r\n                    count = intersectLine(cx, cy, mx, my, rx1, ry1, rx2, ry2);\r\n                }\r\n                cx = mx;\r\n                cy = my;\r\n                break;\r\n        }\r\n        if (count == CROSSING) {\r\n            return CROSSING;\r\n        }\r\n        cross += count;\r\n        p.next();\r\n    }\r\n    if (cy != my) {\r\n        count = intersectLine(cx, cy, mx, my, rx1, ry1, rx2, ry2);\r\n        if (count == CROSSING) {\r\n            return CROSSING;\r\n        }\r\n        cross += count;\r\n    }\r\n    return cross;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.getNormalizedRectangle",
	"Comment": "normalizes a rectangle so that llx and lly are smaller than urx and ury.",
	"Method": "Rectangle getNormalizedRectangle(PdfArray box){\r\n    float llx = ((PdfNumber) getPdfObjectRelease(box.getPdfObject(0))).floatValue();\r\n    float lly = ((PdfNumber) getPdfObjectRelease(box.getPdfObject(1))).floatValue();\r\n    float urx = ((PdfNumber) getPdfObjectRelease(box.getPdfObject(2))).floatValue();\r\n    float ury = ((PdfNumber) getPdfObjectRelease(box.getPdfObject(3))).floatValue();\r\n    return new Rectangle(Math.min(llx, urx), Math.min(lly, ury), Math.max(llx, urx), Math.max(lly, ury));\r\n}"
}, {
	"Path": "com.example.vision.Detect.main",
	"Comment": "detects entities, sentiment, and syntax in a document using the vision api.",
	"Method": "void main(String[] args){\r\n    argsHelper(args, System.out);\r\n}"
}, {
	"Path": "com.itextpdf.text.List.getPreSymbol",
	"Comment": "returns the string that is before a number or letter in the list symbol.",
	"Method": "String getPreSymbol(){\r\n    return preSymbol;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaParams.setBindingMaterialName",
	"Comment": "stores the material name that content is to be bound to.\trequired if binding value is material.",
	"Method": "void setBindingMaterialName(PdfString bindingMaterialName){\r\n    put(PdfName.BINDINGMATERIALNAME, bindingMaterialName);\r\n}"
}, {
	"Path": "com.itextpdf.text.xml.simpleparser.SimpleXMLParser.flush",
	"Comment": "flushes the text that is currently in the buffer.the text can be ignored, added to the documentas content or as comment,... depending on the current state.",
	"Method": "void flush(){\r\n    switch(state) {\r\n        case TEXT:\r\n        case CDATA:\r\n            if (text.length() > 0) {\r\n                doc.text(text.toString());\r\n            }\r\n            break;\r\n        case COMMENT:\r\n            if (comment != null) {\r\n                comment.comment(text.toString());\r\n            }\r\n            break;\r\n        case ATTRIBUTE_KEY:\r\n            attributekey = text.toString();\r\n            if (html)\r\n                attributekey = attributekey.toLowerCase();\r\n            break;\r\n        case QUOTE:\r\n        case ATTRIBUTE_VALUE:\r\n            attributevalue = text.toString();\r\n            attributes.put(attributekey, attributevalue);\r\n            break;\r\n        default:\r\n    }\r\n    text.setLength(0);\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPUtilsImpl.classifyCharacter",
	"Comment": "classifies the character into normal chars, spaces, semicola, quotes,\tcontrol chars.",
	"Method": "int classifyCharacter(char ch){\r\n    if (SPACES.indexOf(ch) >= 0 || (0x2000 <= ch && ch <= 0x200B)) {\r\n        return UCK_SPACE;\r\n    } else if (COMMAS.indexOf(ch) >= 0) {\r\n        return UCK_COMMA;\r\n    } else if (SEMICOLA.indexOf(ch) >= 0) {\r\n        return UCK_SEMICOLON;\r\n    } else if (QUOTES.indexOf(ch) >= 0 || (0x3008 <= ch && ch <= 0x300F) || (0x2018 <= ch && ch <= 0x201F)) {\r\n        return UCK_QUOTE;\r\n    } else if (ch < 0x0020 || CONTROLS.indexOf(ch) >= 0) {\r\n        return UCK_CONTROL;\r\n    } else {\r\n        return UCK_NORMAL;\r\n    }\r\n}"
}, {
	"Path": "com.google.cloud.storage.storagetransfer.samples.AwsRequester.main",
	"Comment": "output the contents of a successfully created transferjob.",
	"Method": "void main(String[] args){\r\n    try {\r\n        run(System.out);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.structurizr.view.DynamicView.checkElement",
	"Comment": "this checks that only appropriate elements can be added to the view.",
	"Method": "void checkElement(Element elementToBeAdded){\r\n    if (!(elementToBeAdded instanceof Person) && !(elementToBeAdded instanceof SoftwareSystem) && !(elementToBeAdded instanceof Container) && !(elementToBeAdded instanceof Component)) {\r\n        throw new IllegalArgumentException(\"Only people, software systems, containers and components can be added to dynamic views.\");\r\n    }\r\n    if (elementToBeAdded instanceof Person) {\r\n        return;\r\n    }\r\n    if (element instanceof SoftwareSystem) {\r\n        if (elementToBeAdded.equals(element)) {\r\n            throw new IllegalArgumentException(elementToBeAdded.getName() + \" is already the scope of this view and cannot be added to it.\");\r\n        }\r\n        if (elementToBeAdded instanceof Container && !elementToBeAdded.getParent().equals(element)) {\r\n            throw new IllegalArgumentException(\"Only containers that reside inside \" + element.getName() + \" can be added to this view.\");\r\n        }\r\n        if (elementToBeAdded instanceof Component) {\r\n            throw new IllegalArgumentException(\"Components can't be added to a dynamic view when the scope is a software system.\");\r\n        }\r\n    }\r\n    if (element instanceof Container) {\r\n        if (elementToBeAdded.equals(element) || elementToBeAdded.equals(element.getParent())) {\r\n            throw new IllegalArgumentException(elementToBeAdded.getName() + \" is already the scope of this view and cannot be added to it.\");\r\n        }\r\n        if (elementToBeAdded instanceof Container && !elementToBeAdded.getParent().equals(element.getParent())) {\r\n            throw new IllegalArgumentException(\"Only containers that reside inside \" + element.getParent().getName() + \" can be added to this view.\");\r\n        }\r\n        if (elementToBeAdded instanceof Component && !elementToBeAdded.getParent().equals(element)) {\r\n            throw new IllegalArgumentException(\"Only components that reside inside \" + element.getName() + \" can be added to this view.\");\r\n        }\r\n    }\r\n    if (element == null) {\r\n        if (!(elementToBeAdded instanceof SoftwareSystem)) {\r\n            throw new IllegalArgumentException(\"Only people and software systems can be added to this dynamic view.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.RectangleReadOnly.normalize",
	"Comment": "normalizes the rectangle.switches lower left with upper right if necessary.",
	"Method": "void normalize(){\r\n    throwReadOnlyError();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaPresentation.setWindow",
	"Comment": "a richmediawindow dictionary that describes the size and\tposition of the floating user interface window when the\tvalue for style is set to windowed.",
	"Method": "void setWindow(RichMediaWindow window){\r\n    put(PdfName.WINDOW, window);\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.Tag.getChild",
	"Comment": "finds the first child that matches the given name and namespace.",
	"Method": "Tag getChild(String name,String ns,Tag getChild,String name,String ns,boolean recursive){\r\n    return recursiveGetChild(this, name, ns, recursive);\r\n}"
}, {
	"Path": "com.google.datastore.snippets.TaskList.listTasks",
	"Comment": "returns a list of all task entities in ascending order of creation time.",
	"Method": "Iterator<Entity> listTasks(){\r\n    Query<Entity> query = Query.newEntityQueryBuilder().setKind(\"Task\").setOrderBy(OrderBy.asc(\"created\")).build();\r\n    return datastore.run(query);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.setParticleRadius",
	"Comment": "change the particle radius. you should set this only once, on world start. if you change theradius during execution, existing particles may explode, shrink, or behave unexpectedly.",
	"Method": "void setParticleRadius(float radius){\r\n    m_particleSystem.setParticleRadius(radius);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BidiOrder.computeMultilineReordering",
	"Comment": "return multiline reordering array for a given level array.reordering does not occur across a line break.",
	"Method": "int[] computeMultilineReordering(byte[] levels,int[] linebreaks){\r\n    int[] result = new int[levels.length];\r\n    int start = 0;\r\n    for (int i = 0; i < linebreaks.length; ++i) {\r\n        int limit = linebreaks[i];\r\n        byte[] templevels = new byte[limit - start];\r\n        System.arraycopy(levels, start, templevels, 0, templevels.length);\r\n        int[] temporder = computeReordering(templevels);\r\n        for (int j = 0; j < temporder.length; ++j) {\r\n            result[start + j] = temporder[j] + start;\r\n        }\r\n        start = limit;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Type1Font.getFullFontStream",
	"Comment": "if the embedded flag is false or if the font is one of the 14 built in types, it returns null,otherwise the font is read and output in a pdfstream object.",
	"Method": "PdfStream getFullFontStream(){\r\n    if (builtinFont || !embedded)\r\n        return null;\r\n    RandomAccessFileOrArray rf = null;\r\n    try {\r\n        String filePfb = fileName.substring(0, fileName.length() - 3) + \"pfb\";\r\n        if (pfb == null)\r\n            rf = new RandomAccessFileOrArray(filePfb, true, Document.plainRandomAccess);\r\n        else\r\n            rf = new RandomAccessFileOrArray(pfb);\r\n        int fileLength = (int) rf.length();\r\n        byte[] st = new byte[fileLength - 18];\r\n        int[] lengths = new int[3];\r\n        int bytePtr = 0;\r\n        for (int k = 0; k < 3; ++k) {\r\n            if (rf.read() != 0x80)\r\n                throw new DocumentException(MessageLocalization.getComposedMessage(\"start.marker.missing.in.1\", filePfb));\r\n            if (rf.read() != PFB_TYPES[k])\r\n                throw new DocumentException(MessageLocalization.getComposedMessage(\"incorrect.segment.type.in.1\", filePfb));\r\n            int size = rf.read();\r\n            size += rf.read() << 8;\r\n            size += rf.read() << 16;\r\n            size += rf.read() << 24;\r\n            lengths[k] = size;\r\n            while (size != 0) {\r\n                int got = rf.read(st, bytePtr, size);\r\n                if (got < 0)\r\n                    throw new DocumentException(MessageLocalization.getComposedMessage(\"premature.end.in.1\", filePfb));\r\n                bytePtr += got;\r\n                size -= got;\r\n            }\r\n        }\r\n        return new StreamFont(st, lengths, compressionLevel);\r\n    } catch (Exception e) {\r\n        throw new DocumentException(e);\r\n    } finally {\r\n        if (rf != null) {\r\n            try {\r\n                rf.close();\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.html.AbstractTagProcessor.updateParagraphFontIfNeeded",
	"Comment": "in case child font is of bigger size than paragraph font, text overlapping may occur.this happens because leading of the lines in paragraph is set based on paragraph font.",
	"Method": "void updateParagraphFontIfNeeded(Phrase p,Element child){\r\n    Font childFont = null;\r\n    if (child instanceof Chunk) {\r\n        childFont = ((Chunk) child).getFont();\r\n    } else if (child instanceof Phrase) {\r\n        childFont = ((Phrase) child).getFont();\r\n    }\r\n    float pFontSize = p.getFont() != null ? p.getFont().getSize() : Font.DEFAULTSIZE;\r\n    if (childFont != null && childFont.getSize() > pFontSize) {\r\n        p.setFont(new Font(Font.FontFamily.UNDEFINED, childFont.getSize()));\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.collection.PdfTargetDictionary.setAdditionalPath",
	"Comment": "if this dictionary refers to an intermediate target, you can\tadd the next target in the sequence.",
	"Method": "void setAdditionalPath(PdfTargetDictionary nested){\r\n    put(PdfName.T, nested);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.TextField.setExtraMargin",
	"Comment": "sets extra margins in text fields to better mimic the acrobat layout.",
	"Method": "void setExtraMargin(float extraMarginLeft,float extraMarginTop){\r\n    this.extraMarginLeft = extraMarginLeft;\r\n    this.extraMarginTop = extraMarginTop;\r\n}"
}, {
	"Path": "com.example.containeranalysis.Samples.getOccurrencesForImage",
	"Comment": "retrieves all the occurrences associated with a specified imagehere, all occurrences are simply printed and counted",
	"Method": "int getOccurrencesForImage(GrafeasV1Beta1Client client,String imageUrl,String projectId){\r\n    final String filterStr = \"resourceUrl=\\\"\" + imageUrl + \"\\\"\";\r\n    final String projectName = ProjectName.format(projectId);\r\n    int i = 0;\r\n    for (Occurrence o : client.listOccurrences(projectName, filterStr).iterateAll()) {\r\n        System.out.println(o.getName());\r\n        i = i + 1;\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfSignatureAppearance.setSignatureCreator",
	"Comment": "sets the name of the application used to create the signature.",
	"Method": "void setSignatureCreator(String signatureCreator){\r\n    this.signatureCreator = signatureCreator;\r\n}"
}, {
	"Path": "com.example.firestore.snippets.QueryDataSnippets.createInvalidRangeWithOrderByQuery",
	"Comment": "creates an instance of an invalid range combined with order. violates the constraint that rangeand order by are required to be on the same field.",
	"Method": "Query createInvalidRangeWithOrderByQuery(){\r\n    CollectionReference cities = db.collection(\"cities\");\r\n    Query query = cities.whereGreaterThan(\"population\", 2500000L).orderBy(\"country\");\r\n    return query;\r\n}"
}, {
	"Path": "com.google.cloud.vision.samples.landmarkdetection.DetectLandmark.getVisionService",
	"Comment": "connects to the vision api using application default credentials.",
	"Method": "Vision getVisionService(){\r\n    GoogleCredential credential = GoogleCredential.getApplicationDefault().createScoped(VisionScopes.all());\r\n    JsonFactory jsonFactory = JacksonFactory.getDefaultInstance();\r\n    return new Vision.Builder(GoogleNetHttpTransport.newTrustedTransport(), jsonFactory, credential).setApplicationName(APPLICATION_NAME).build();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.TextRenderInfo.getWidthAndWordSpacing",
	"Comment": "calculates width and word spacing of a single character pdf string.",
	"Method": "float[] getWidthAndWordSpacing(PdfString string,boolean singleCharString){\r\n    if (singleCharString == false)\r\n        throw new UnsupportedOperationException();\r\n    float[] result = new float[2];\r\n    String decoded = decode(string);\r\n    result[0] = (float) ((gs.font.getWidth(getCharCode(decoded)) * fontMatrix[0]));\r\n    result[1] = decoded.equals(\" \") ? gs.wordSpacing : 0;\r\n    return result;\r\n}"
}, {
	"Path": "net.dv8tion.jda.bot.sharding.DefaultShardManagerBuilder.removeEventListenerProvider",
	"Comment": "removes the provided listener provider from the list of listener providers.",
	"Method": "DefaultShardManagerBuilder removeEventListenerProvider(IntFunction<Object> listenerProvider){\r\n    return this.removeEventListenerProviders(Collections.singleton(listenerProvider));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.TextField.setExtensionFont",
	"Comment": "sets the extensionfont. this font will be searched before thesubstitution fonts. it may be null.",
	"Method": "void setExtensionFont(BaseFont extensionFont){\r\n    this.extensionFont = extensionFont;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStamper.setFreeTextFlattening",
	"Comment": "determines if the freetext annotations are flattened on close.",
	"Method": "void setFreeTextFlattening(boolean flat){\r\n    stamper.setFreeTextFlattening(flat);\r\n}"
}, {
	"Path": "com.structurizr.view.Configuration.setTerminology",
	"Comment": "sets the terminology object associated with this workspace.",
	"Method": "void setTerminology(Terminology terminology){\r\n    this.terminology = terminology;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.TextRenderInfo.hasMcid",
	"Comment": "checks if the text belongs to a marked content sequence\twith a given mcid.",
	"Method": "boolean hasMcid(int mcid,boolean hasMcid,int mcid,boolean checkTheTopmostLevelOnly){\r\n    if (checkTheTopmostLevelOnly) {\r\n        if (markedContentInfos instanceof ArrayList) {\r\n            Integer infoMcid = getMcid();\r\n            return (infoMcid != null) ? infoMcid == mcid : false;\r\n        }\r\n    } else {\r\n        for (MarkedContentInfo info : markedContentInfos) {\r\n            if (info.hasMcid())\r\n                if (info.getMcid() == mcid)\r\n                    return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.itextpdf.text.html.simpleparser.HTMLWorker.processListItem",
	"Comment": "looks for the list object on the stack,\tand adds the listitem to the list.",
	"Method": "void processListItem(){\r\n    if (stack.empty())\r\n        return;\r\n    Element obj = stack.pop();\r\n    if (!(obj instanceof ListItem)) {\r\n        stack.push(obj);\r\n        return;\r\n    }\r\n    if (stack.empty()) {\r\n        document.add(obj);\r\n        return;\r\n    }\r\n    ListItem item = (ListItem) obj;\r\n    Element list = stack.pop();\r\n    if (!(list instanceof com.itextpdf.text.List)) {\r\n        stack.push(list);\r\n        return;\r\n    }\r\n    ((com.itextpdf.text.List) list).add(item);\r\n    item.adjustListSymbolFont();\r\n    stack.push(list);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.BuildNewCharString",
	"Comment": "function uses buildnewindex to create the new index of the subset charstrings",
	"Method": "void BuildNewCharString(int FontIndex){\r\n    NewCharStringsIndex = BuildNewIndex(fonts[FontIndex].charstringsOffsets, GlyphsUsed, ENDCHAR_OP);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.getWidthPointKerned",
	"Comment": "gets the width of a string in points taking kerninginto account.",
	"Method": "float getWidthPointKerned(String text,float fontSize){\r\n    float size = getWidth(text) * 0.001f * fontSize;\r\n    if (!hasKernPairs())\r\n        return size;\r\n    int len = text.length() - 1;\r\n    int kern = 0;\r\n    char[] c = text.toCharArray();\r\n    for (int k = 0; k < len; ++k) {\r\n        kern += getKerning(c[k], c[k + 1]);\r\n    }\r\n    return size + kern * 0.001f * fontSize;\r\n}"
}, {
	"Path": "com.example.spanner.BatchSample.main",
	"Comment": "this example showcases how to create a batch client, partition a query, and concurrently readfrom multiple partitions.",
	"Method": "void main(String[] args){\r\n    if (args.length != 2) {\r\n        System.err.println(\"Usage: BatchSample <instance_id> <database_id>\");\r\n        return;\r\n    }\r\n    String instanceId = args[0];\r\n    String databaseId = args[1];\r\n    SpannerOptions options = SpannerOptions.newBuilder().build();\r\n    Spanner spanner = options.getService();\r\n    int numThreads = Runtime.getRuntime().availableProcessors();\r\n    ExecutorService executor = Executors.newFixedThreadPool(numThreads);\r\n    int totalPartitions;\r\n    AtomicInteger totalRecords = new AtomicInteger(0);\r\n    try {\r\n        BatchClient batchClient = spanner.getBatchClient(DatabaseId.of(options.getProjectId(), instanceId, databaseId));\r\n        final BatchReadOnlyTransaction txn = batchClient.batchReadOnlyTransaction(TimestampBound.strong());\r\n        List<Partition> partitions = txn.partitionQuery(PartitionOptions.getDefaultInstance(), Statement.of(\"SELECT SingerId, FirstName, LastName FROM Singers\"));\r\n        totalPartitions = partitions.size();\r\n        for (final Partition p : partitions) {\r\n            executor.execute(() -> {\r\n                try (ResultSet results = txn.execute(p)) {\r\n                    while (results.next()) {\r\n                        long singerId = results.getLong(0);\r\n                        String firstName = results.getString(1);\r\n                        String lastName = results.getString(2);\r\n                        System.out.println(\"[\" + singerId + \"] \" + firstName + \" \" + lastName);\r\n                        totalRecords.getAndIncrement();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    } finally {\r\n        executor.shutdown();\r\n        executor.awaitTermination(1, TimeUnit.HOURS);\r\n        spanner.close();\r\n    }\r\n    double avgRecordsPerPartition = 0.0;\r\n    if (totalPartitions != 0) {\r\n        avgRecordsPerPartition = (double) totalRecords.get() / totalPartitions;\r\n    }\r\n    System.out.println(\"totalPartitions=\" + totalPartitions);\r\n    System.out.println(\"totalRecords=\" + totalRecords);\r\n    System.out.println(\"avgRecordsPerPartition=\" + avgRecordsPerPartition);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfTransparencyGroup.setIsolated",
	"Comment": "determining the initial backdrop against which its stack is composited.",
	"Method": "void setIsolated(boolean isolated){\r\n    if (isolated)\r\n        put(PdfName.I, PdfBoolean.PDFTRUE);\r\n    else\r\n        remove(PdfName.I);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseField.setBackgroundColor",
	"Comment": "sets the background color. set to null fortransparent background.",
	"Method": "void setBackgroundColor(BaseColor backgroundColor){\r\n    this.backgroundColor = backgroundColor;\r\n}"
}, {
	"Path": "com.machinepublishers.glass.ui.monocle.MonocleDnDClipboard.pushToSystem",
	"Comment": "here the magic happens.when this method is called all input events should be grabbed andappropriate drag notifications should be sent instead of regular inputevents",
	"Method": "void pushToSystem(HashMap<String, Object> cacheData,int supportedActions){\r\n    MouseInput.getInstance().notifyDragStart();\r\n    ((MonocleApplication) Application.GetApplication()).enterDnDEventLoop();\r\n    actionPerformed(Clipboard.ACTION_COPY_OR_MOVE);\r\n}"
}, {
	"Path": "software.amazon.ion.impl.IonReaderTextSystemX.load_or_cast_cached_value",
	"Comment": "this checks the state of the raw reader to make surethis is valid.it also checks for an existing cachedvalue of the correct type.it will either cast thecurrent value from an existing type to the type desiredor it will construct the desired type from the rawinput in the raw reader",
	"Method": "void load_or_cast_cached_value(int value_type){\r\n    load_once();\r\n    if (value_type != 0 && !_v.hasValueOfType(value_type)) {\r\n        cast_cached_value(value_type);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.FontSelector.process",
	"Comment": "process the text so that it will render with a combination of fontsif needed.",
	"Method": "Phrase process(String text){\r\n    if (getSize() == 0)\r\n        throw new IndexOutOfBoundsException(MessageLocalization.getComposedMessage(\"no.font.is.defined\"));\r\n    char[] cc = text.toCharArray();\r\n    int len = cc.length;\r\n    StringBuffer sb = new StringBuffer();\r\n    Phrase ret = new Phrase();\r\n    currentFont = null;\r\n    for (int k = 0; k < len; ++k) {\r\n        Chunk newChunk = processChar(cc, k, sb);\r\n        if (newChunk != null) {\r\n            ret.add(newChunk);\r\n        }\r\n    }\r\n    if (sb.length() > 0) {\r\n        Chunk ck = new Chunk(sb.toString(), currentFont != null ? currentFont : getFont(0));\r\n        ret.add(ck);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.structurizr.io.plantuml.PlantUMLWriter.toString",
	"Comment": "creates plantuml diagram definitions based upon the specified workspace, returning them as strings.",
	"Method": "String[] toString(Workspace workspace){\r\n    if (workspace == null) {\r\n        throw new IllegalArgumentException(\"A workspace must be provided.\");\r\n    }\r\n    StringWriter stringWriter = new StringWriter();\r\n    write(workspace, stringWriter);\r\n    String diagrams = stringWriter.toString();\r\n    if (diagrams != null && diagrams.contains(\"@startuml\")) {\r\n        return stringWriter.toString().split(\"(?=@startuml)\");\r\n    } else {\r\n        return new String[0];\r\n    }\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Block.remaining",
	"Comment": "returns the unused amount of bytes from the limit to the capacity of the data array.",
	"Method": "int remaining(){\r\n    return data.length - limit;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.IonReaderTextRawTokensX.load_digits",
	"Comment": "accumulates digits into the buffer, starting with the given character.",
	"Method": "int load_digits(StringBuilder sb,int c){\r\n    if (!IonTokenConstsX.isDigit(c)) {\r\n        return c;\r\n    }\r\n    sb.append((char) c);\r\n    return readNumeric(sb, Radix.DECIMAL, NumericState.DIGIT);\r\n}"
}, {
	"Path": "com.itextpdf.text.html.simpleparser.HTMLWorker.popTableState",
	"Comment": "pops the values of pendingtr and pendingtd\tfrom a state stack.",
	"Method": "void popTableState(){\r\n    boolean[] state = tableState.pop();\r\n    pendingTR = state[0];\r\n    pendingTD = state[1];\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStamper.isRotateContents",
	"Comment": "checks if the content is automatically adjusted to compensatethe original page rotation.",
	"Method": "boolean isRotateContents(){\r\n    return stamper.isRotateContents();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.FdfWriter.getFields",
	"Comment": "gets all the fields. the map is keyed by the fully qualifiedfield name and the values are pdfobject.",
	"Method": "HashMap<String, Object> getFields(){\r\n    HashMap<String, Object> values = new HashMap<String, Object>();\r\n    iterateFields(values, fields, \"\");\r\n    return values;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.ContentByteUtils.getContentBytesFromContentObject",
	"Comment": "gets the content bytes from a content object, which may be a referencea stream or an array.",
	"Method": "byte[] getContentBytesFromContentObject(PdfObject contentObject){\r\n    final byte[] result;\r\n    switch(contentObject.type()) {\r\n        case PdfObject.INDIRECT:\r\n            final PRIndirectReference ref = (PRIndirectReference) contentObject;\r\n            final PdfObject directObject = PdfReader.getPdfObjectRelease(ref);\r\n            result = getContentBytesFromContentObject(directObject);\r\n            break;\r\n        case PdfObject.STREAM:\r\n            final PRStream stream = (PRStream) PdfReader.getPdfObjectRelease(contentObject);\r\n            result = PdfReader.getStreamBytes(stream);\r\n            break;\r\n        case PdfObject.ARRAY:\r\n            final ByteArrayOutputStream allBytes = new ByteArrayOutputStream();\r\n            final PdfArray contentArray = (PdfArray) contentObject;\r\n            final ListIterator<PdfObject> iter = contentArray.listIterator();\r\n            while (iter.hasNext()) {\r\n                final PdfObject element = iter.next();\r\n                allBytes.write(getContentBytesFromContentObject(element));\r\n                allBytes.write((byte) ' ');\r\n            }\r\n            result = allBytes.toByteArray();\r\n            break;\r\n        default:\r\n            final String msg = \"Unable to handle Content of type \" + contentObject.getClass();\r\n            throw new IllegalStateException(msg);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDictionary.getAsNumber",
	"Comment": "returns a pdfobject as a pdfnumber,resolving indirect references.the object associated with the pdfname given is retrievedand resolved to a direct object.if it is a pdfnumber, it is cast down and returned as such.otherwise null is returned.",
	"Method": "PdfNumber getAsNumber(PdfName key){\r\n    PdfNumber number = null;\r\n    PdfObject orig = getDirectObject(key);\r\n    if (orig != null && orig.isNumber())\r\n        number = (PdfNumber) orig;\r\n    return number;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.codec.TIFFDirectory.getField",
	"Comment": "returns the value of a given tag as a tifffield,or null if the tag is not present.",
	"Method": "TIFFField getField(int tag){\r\n    Integer i = fieldIndex.get(Integer.valueOf(tag));\r\n    if (i == null) {\r\n        return null;\r\n    } else {\r\n        return fields[i.intValue()];\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PushbuttonField.setProportionalIcon",
	"Comment": "sets the way the icon is scaled. if true the icon is scaled proportionally,if false the scaling is done anamorphicaly.",
	"Method": "void setProportionalIcon(boolean proportionalIcon){\r\n    this.proportionalIcon = proportionalIcon;\r\n}"
}, {
	"Path": "com.structurizr.view.ContainerView.addAllContainers",
	"Comment": "adds all containers within the software system in scope to this view.",
	"Method": "void addAllContainers(){\r\n    getSoftwareSystem().getContainers().forEach(this::add);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.LineDashPattern.next",
	"Comment": "calculates and returns the next element which is either gap or dash.",
	"Method": "DashArrayElem next(){\r\n    DashArrayElem ret = currentElem;\r\n    if (dashArray.size() > 0) {\r\n        currentIndex = (currentIndex + 1) % dashArray.size();\r\n        currentElem = new DashArrayElem(dashArray.getAsNumber(currentIndex).floatValue(), isEven(++elemOrdinalNumber));\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.itextpdf.text.Image.setCompressionLevel",
	"Comment": "sets the compression level to be used if the image is written as a compressed stream.",
	"Method": "void setCompressionLevel(int compressionLevel){\r\n    if (compressionLevel < PdfStream.NO_COMPRESSION || compressionLevel > PdfStream.BEST_COMPRESSION)\r\n        this.compressionLevel = PdfStream.DEFAULT_COMPRESSION;\r\n    else\r\n        this.compressionLevel = compressionLevel;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Barcode128.getRawText",
	"Comment": "converts the human readable text to the characters needed tocreate a barcode. some optimization is done to get the shortest code.",
	"Method": "String getRawText(String text,boolean ucc,Barcode128CodeSet codeSet,String getRawText,String text,boolean ucc){\r\n    return getRawText(text, ucc, Barcode128CodeSet.AUTO);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Fixture.getType",
	"Comment": "get the type of the child shape. you can use this to down cast to the concrete shape.",
	"Method": "ShapeType getType(){\r\n    return m_shape.getType();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.mc.MCParser.dealWithXObj",
	"Comment": "when an xobject with a structparent is encountered,we want to remove it from the stack.",
	"Method": "void dealWithXObj(PdfName xobj){\r\n    PdfDictionary dict = xobjects.getAsStream(xobj);\r\n    PdfNumber structParent = dict.getAsNumber(PdfName.STRUCTPARENT);\r\n    if (LOGGER.isLogging(Level.INFO)) {\r\n        LOGGER.info(String.format(\"Encountered StructParent %s in content\", structParent));\r\n    }\r\n    if (structParent == null)\r\n        return;\r\n    StructureItem item = items.get(0);\r\n    if (item.checkStructParent(pageref.getNumber(), structParent.intValue()) == 1)\r\n        items.remove(0);\r\n}"
}, {
	"Path": "software.amazon.ion.system.IonReaderBuilder.immutable",
	"Comment": "returns an immutable builder configured exactly like this one.",
	"Method": "IonReaderBuilder immutable(IonReaderBuilder immutable){\r\n    return this;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.PdfContentStreamProcessor.populateOperators",
	"Comment": "loads all the supported graphics and text state operators in a map.",
	"Method": "void populateOperators(){\r\n    registerContentOperator(DEFAULTOPERATOR, new IgnoreOperatorContentOperator());\r\n    registerContentOperator(\"q\", new PushGraphicsState());\r\n    registerContentOperator(\"Q\", new PopGraphicsState());\r\n    registerContentOperator(\"g\", new SetGrayFill());\r\n    registerContentOperator(\"G\", new SetGrayStroke());\r\n    registerContentOperator(\"rg\", new SetRGBFill());\r\n    registerContentOperator(\"RG\", new SetRGBStroke());\r\n    registerContentOperator(\"k\", new SetCMYKFill());\r\n    registerContentOperator(\"K\", new SetCMYKStroke());\r\n    registerContentOperator(\"cs\", new SetColorSpaceFill());\r\n    registerContentOperator(\"CS\", new SetColorSpaceStroke());\r\n    registerContentOperator(\"sc\", new SetColorFill());\r\n    registerContentOperator(\"SC\", new SetColorStroke());\r\n    registerContentOperator(\"scn\", new SetColorFill());\r\n    registerContentOperator(\"SCN\", new SetColorStroke());\r\n    registerContentOperator(\"cm\", new ModifyCurrentTransformationMatrix());\r\n    registerContentOperator(\"gs\", new ProcessGraphicsStateResource());\r\n    SetTextCharacterSpacing tcOperator = new SetTextCharacterSpacing();\r\n    registerContentOperator(\"Tc\", tcOperator);\r\n    SetTextWordSpacing twOperator = new SetTextWordSpacing();\r\n    registerContentOperator(\"Tw\", twOperator);\r\n    registerContentOperator(\"Tz\", new SetTextHorizontalScaling());\r\n    SetTextLeading tlOperator = new SetTextLeading();\r\n    registerContentOperator(\"TL\", tlOperator);\r\n    registerContentOperator(\"Tf\", new SetTextFont());\r\n    registerContentOperator(\"Tr\", new SetTextRenderMode());\r\n    registerContentOperator(\"Ts\", new SetTextRise());\r\n    registerContentOperator(\"BT\", new BeginText());\r\n    registerContentOperator(\"ET\", new EndText());\r\n    registerContentOperator(\"BMC\", new BeginMarkedContent());\r\n    registerContentOperator(\"BDC\", new BeginMarkedContentDictionary());\r\n    registerContentOperator(\"EMC\", new EndMarkedContent());\r\n    TextMoveStartNextLine tdOperator = new TextMoveStartNextLine();\r\n    registerContentOperator(\"Td\", tdOperator);\r\n    registerContentOperator(\"TD\", new TextMoveStartNextLineWithLeading(tdOperator, tlOperator));\r\n    registerContentOperator(\"Tm\", new TextSetTextMatrix());\r\n    TextMoveNextLine tstarOperator = new TextMoveNextLine(tdOperator);\r\n    registerContentOperator(\"T*\", tstarOperator);\r\n    ShowText tjOperator = new ShowText();\r\n    registerContentOperator(\"Tj\", tjOperator);\r\n    MoveNextLineAndShowText tickOperator = new MoveNextLineAndShowText(tstarOperator, tjOperator);\r\n    registerContentOperator(\"'\", tickOperator);\r\n    registerContentOperator(\"\\\"\", new MoveNextLineAndShowTextWithSpacing(twOperator, tcOperator, tickOperator));\r\n    registerContentOperator(\"TJ\", new ShowTextArray());\r\n    registerContentOperator(\"Do\", new Do());\r\n    registerContentOperator(\"w\", new SetLineWidth());\r\n    registerContentOperator(\"J\", new SetLineCap());\r\n    registerContentOperator(\"j\", new SetLineJoin());\r\n    registerContentOperator(\"M\", new SetMiterLimit());\r\n    registerContentOperator(\"d\", new SetLineDashPattern());\r\n    if (renderListener instanceof ExtRenderListener) {\r\n        int fillStroke = PathPaintingRenderInfo.FILL | PathPaintingRenderInfo.STROKE;\r\n        registerContentOperator(\"m\", new MoveTo());\r\n        registerContentOperator(\"l\", new LineTo());\r\n        registerContentOperator(\"c\", new Curve());\r\n        registerContentOperator(\"v\", new CurveFirstPointDuplicated());\r\n        registerContentOperator(\"y\", new CurveFourhPointDuplicated());\r\n        registerContentOperator(\"h\", new CloseSubpath());\r\n        registerContentOperator(\"re\", new Rectangle());\r\n        registerContentOperator(\"S\", new PaintPath(PathPaintingRenderInfo.STROKE, -1, false));\r\n        registerContentOperator(\"s\", new PaintPath(PathPaintingRenderInfo.STROKE, -1, true));\r\n        registerContentOperator(\"f\", new PaintPath(PathPaintingRenderInfo.FILL, PathPaintingRenderInfo.NONZERO_WINDING_RULE, false));\r\n        registerContentOperator(\"F\", new PaintPath(PathPaintingRenderInfo.FILL, PathPaintingRenderInfo.NONZERO_WINDING_RULE, false));\r\n        registerContentOperator(\"f*\", new PaintPath(PathPaintingRenderInfo.FILL, PathPaintingRenderInfo.EVEN_ODD_RULE, false));\r\n        registerContentOperator(\"B\", new PaintPath(fillStroke, PathPaintingRenderInfo.NONZERO_WINDING_RULE, false));\r\n        registerContentOperator(\"B*\", new PaintPath(fillStroke, PathPaintingRenderInfo.EVEN_ODD_RULE, false));\r\n        registerContentOperator(\"b\", new PaintPath(fillStroke, PathPaintingRenderInfo.NONZERO_WINDING_RULE, true));\r\n        registerContentOperator(\"b*\", new PaintPath(fillStroke, PathPaintingRenderInfo.EVEN_ODD_RULE, true));\r\n        registerContentOperator(\"n\", new PaintPath(PathPaintingRenderInfo.NO_OP, -1, false));\r\n        registerContentOperator(\"W\", new ClipPath(PathPaintingRenderInfo.NONZERO_WINDING_RULE));\r\n        registerContentOperator(\"W*\", new ClipPath(PathPaintingRenderInfo.EVEN_ODD_RULE));\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.MarkedSection.add",
	"Comment": "adds a paragraph, list, table or another section\tto this section.",
	"Method": "void add(int index,Element o,boolean add,Element o){\r\n    return ((Section) element).add(o);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.AcroFields.signatureCoversWholeDocument",
	"Comment": "checks is the signature covers the entire document or just part of it.",
	"Method": "boolean signatureCoversWholeDocument(String name){\r\n    getSignatureNames();\r\n    name = getTranslatedFieldName(name);\r\n    if (!sigNames.containsKey(name))\r\n        return false;\r\n    return sigNames.get(name)[0] == reader.getFileLength();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CJKFont.getFontDescriptor",
	"Comment": "gets the font parameter identified by key. valid valuesfor key are ascent, capheight, descentand italicangle.",
	"Method": "PdfDictionary getFontDescriptor(float getFontDescriptor,int key,float fontSize){\r\n    switch(key) {\r\n        case AWT_ASCENT:\r\n        case ASCENT:\r\n            return getDescNumber(\"Ascent\") * fontSize / 1000;\r\n        case CAPHEIGHT:\r\n            return getDescNumber(\"CapHeight\") * fontSize / 1000;\r\n        case AWT_DESCENT:\r\n        case DESCENT:\r\n            return getDescNumber(\"Descent\") * fontSize / 1000;\r\n        case ITALICANGLE:\r\n            return getDescNumber(\"ItalicAngle\");\r\n        case BBOXLLX:\r\n            return fontSize * getBBox(0) / 1000;\r\n        case BBOXLLY:\r\n            return fontSize * getBBox(1) / 1000;\r\n        case BBOXURX:\r\n            return fontSize * getBBox(2) / 1000;\r\n        case BBOXURY:\r\n            return fontSize * getBBox(3) / 1000;\r\n        case AWT_LEADING:\r\n            return 0;\r\n        case AWT_MAXADVANCE:\r\n            return fontSize * (getBBox(2) - getBBox(0)) / 1000;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.events.PdfPageEventForwarder.onSectionEnd",
	"Comment": "called when the end of a section is reached.\tposition will hold the height of the section end.",
	"Method": "void onSectionEnd(PdfWriter writer,Document document,float position){\r\n    for (PdfPageEvent event : events) {\r\n        event.onSectionEnd(writer, document, position);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.table.KeepTogetherTest.compareDocuments",
	"Comment": "utility method that checks the created file against the cmp file",
	"Method": "void compareDocuments(boolean tagged,boolean keepTogether){\r\n    String file = \"tagged_\" + tagged + \"-keeptogether_\" + keepTogether + \".pdf\";\r\n    CompareTool compareTool = new CompareTool();\r\n    String errorMessage = compareTool.compareByContent(outFolder + file, cmpFolder + file, outFolder, \"diff\");\r\n    if (errorMessage != null) {\r\n        Assert.fail(errorMessage);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.pipeline.ElementHandlerPipelineTest.runClose",
	"Comment": "verifies that the content of the processobject is processed on close.",
	"Method": "void runClose(){\r\n    p.close(context, null, po);\r\n    Assert.assertEquals(writable, lst.get(0));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.spatial.Viewport.setMeasure",
	"Comment": "a measure dictionary that specifies the scale and units that shall apply\tto measurements taken on the contents within the viewport.",
	"Method": "void setMeasure(Measure measure){\r\n    super.put(PdfName.MEASURE, measure);\r\n}"
}, {
	"Path": "org.jbake.app.AssetTest.testUnlistable",
	"Comment": "primary intention is to extend test cases to increase coverage.",
	"Method": "void testUnlistable(){\r\n    config.setAssetFolder(new File(config.getSourceFolder(), \"non-exsitent\"));\r\n    Asset asset = new Asset(config);\r\n    asset.copy();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.CuePoint.setAction",
	"Comment": "sets an action dictionary defining the action that is executed\tif this cue point is triggered, meaning that the flash content\treached the matching cue point during its playback.",
	"Method": "void setAction(PdfObject action){\r\n    if (action instanceof PdfDictionary || action instanceof PdfIndirectReference)\r\n        put(PdfName.A, action);\r\n    else\r\n        throw new IllegalPdfSyntaxException(\"An action should be defined as a dictionary\");\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.Vector.subtract",
	"Comment": "computes the difference between this vector and the specified vector",
	"Method": "Vector subtract(Vector v){\r\n    float x = vals[I1] - v.vals[I1];\r\n    float y = vals[I2] - v.vals[I2];\r\n    float z = vals[I3] - v.vals[I3];\r\n    return new Vector(x, y, z);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.events.IndexEvents.getSortedEntries",
	"Comment": "returns the sorted list with the entries and the collected page numbers.",
	"Method": "List<Entry> getSortedEntries(){\r\n    Map<String, Entry> grouped = new HashMap<String, Entry>();\r\n    for (int i = 0; i < indexentry.size(); i++) {\r\n        Entry e = indexentry.get(i);\r\n        String key = e.getKey();\r\n        Entry master = grouped.get(key);\r\n        if (master != null) {\r\n            master.addPageNumberAndTag(e.getPageNumber(), e.getTag());\r\n        } else {\r\n            e.addPageNumberAndTag(e.getPageNumber(), e.getTag());\r\n            grouped.put(key, e);\r\n        }\r\n    }\r\n    List<Entry> sorted = new ArrayList<Entry>(grouped.values());\r\n    Collections.sort(sorted, comparator);\r\n    return sorted;\r\n}"
}, {
	"Path": "com.example.flexible.websocket.jsr356.ServerSocket.onMessage",
	"Comment": "handle a message received from the client, and echo back to the client.",
	"Method": "void onMessage(String message,Session session){\r\n    logger.fine(\"Message Received  : \" + message);\r\n    session.getAsyncRemote().sendText(message);\r\n}"
}, {
	"Path": "org.jbake.render.DocumentsRenderer.getContentForNav",
	"Comment": "creates a simple content model to use in individual post navigations.",
	"Method": "Map<String, Object> getContentForNav(Map<String, Object> document){\r\n    Map<String, Object> navDocument = new HashMap();\r\n    navDocument.put(Attributes.NO_EXTENSION_URI, document.get(Attributes.NO_EXTENSION_URI));\r\n    navDocument.put(Attributes.URI, document.get(Attributes.URI));\r\n    navDocument.put(Attributes.TITLE, document.get(Attributes.TITLE));\r\n    return navDocument;\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.css.apply.ListStyleTypeCssApplier.apply",
	"Comment": "utility method applying style to a list when no imageprovider is available.",
	"Method": "List apply(List list,Tag t,HtmlPipelineContext context,List apply,List list,Tag t,MarginMemory memory,PageSizeContainable psc,HtmlPipelineContext context,Element apply,List e,Tag t){\r\n    return apply(e, t, null, null, null);\r\n}"
}, {
	"Path": "org.jbake.parser.Engines.loadEngines",
	"Comment": "this method is used internally to load markup engines. markup engines are found using descriptor files on classpath, soadding an engine is as easy as adding a jar on classpath with the descriptor file included.",
	"Method": "void loadEngines(){\r\n    try {\r\n        ClassLoader cl = Engines.class.getClassLoader();\r\n        Enumeration<URL> resources = cl.getResources(\"META-INF/org.jbake.parser.MarkupEngines.properties\");\r\n        while (resources.hasMoreElements()) {\r\n            URL url = resources.nextElement();\r\n            Properties props = new Properties();\r\n            props.load(url.openStream());\r\n            for (Map.Entry<Object, Object> entry : props.entrySet()) {\r\n                String className = (String) entry.getKey();\r\n                String[] extensions = ((String) entry.getValue()).split(\",\");\r\n                registerEngine(className, extensions);\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        LOGGER.error(\"Error loading Engines\", e);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.collection.PdfCollectionField.getValue",
	"Comment": "returns a pdfobject that can be used as the value of a collection item.",
	"Method": "PdfObject getValue(String v){\r\n    switch(fieldType) {\r\n        case TEXT:\r\n            return new PdfString(v, PdfObject.TEXT_UNICODE);\r\n        case DATE:\r\n            return new PdfDate(PdfDate.decode(v));\r\n        case NUMBER:\r\n            return new PdfNumber(v);\r\n    }\r\n    throw new IllegalArgumentException(MessageLocalization.getComposedMessage(\"1.is.not.an.acceptable.value.for.the.field.2\", v, get(PdfName.N).toString()));\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPNodeUtils.findNode",
	"Comment": "follow an expanded path expression to find or create a node.",
	"Method": "XMPNode findNode(XMPNode xmpTree,XMPPath xpath,boolean createNodes,PropertyOptions leafOptions){\r\n    if (xpath == null || xpath.size() == 0) {\r\n        throw new XMPException(\"Empty XMPPath\", XMPError.BADXPATH);\r\n    }\r\n    XMPNode rootImplicitNode = null;\r\n    XMPNode currNode = null;\r\n    currNode = findSchemaNode(xmpTree, xpath.getSegment(XMPPath.STEP_SCHEMA).getName(), createNodes);\r\n    if (currNode == null) {\r\n        return null;\r\n    } else if (currNode.isImplicit()) {\r\n        currNode.setImplicit(false);\r\n        rootImplicitNode = currNode;\r\n    }\r\n    try {\r\n        for (int i = 1; i < xpath.size(); i++) {\r\n            currNode = followXPathStep(currNode, xpath.getSegment(i), createNodes);\r\n            if (currNode == null) {\r\n                if (createNodes) {\r\n                    deleteNode(rootImplicitNode);\r\n                }\r\n                return null;\r\n            } else if (currNode.isImplicit()) {\r\n                currNode.setImplicit(false);\r\n                if (i == 1 && xpath.getSegment(i).isAlias() && xpath.getSegment(i).getAliasForm() != 0) {\r\n                    currNode.getOptions().setOption(xpath.getSegment(i).getAliasForm(), true);\r\n                } else if (i < xpath.size() - 1 && xpath.getSegment(i).getKind() == XMPPath.STRUCT_FIELD_STEP && !currNode.getOptions().isCompositeProperty()) {\r\n                    currNode.getOptions().setStruct(true);\r\n                }\r\n                if (rootImplicitNode == null) {\r\n                    rootImplicitNode = currNode;\r\n                }\r\n            }\r\n        }\r\n    } catch (XMPException e) {\r\n        if (rootImplicitNode != null) {\r\n            deleteNode(rootImplicitNode);\r\n        }\r\n        throw e;\r\n    }\r\n    if (rootImplicitNode != null) {\r\n        currNode.getOptions().mergeWith(leafOptions);\r\n        currNode.setOptions(currNode.getOptions());\r\n    }\r\n    return currNode;\r\n}"
}, {
	"Path": "org.jbox2d.common.OBBViewportTransform.setTransform",
	"Comment": "sets the transform of the viewport. transforms about the center.",
	"Method": "void setTransform(Mat22 transform){\r\n    box.R.set(transform);\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.util.ArrayUtil.startsWith",
	"Comment": "check if there is an element that starts with the specified string",
	"Method": "int startsWith(String str,String[] arr){\r\n    if (arr == null) {\r\n        return -1;\r\n    }\r\n    for (int i = 0; i < arr.length; i++) {\r\n        if (arr[i].startsWith(str)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.structurizr.view.View.removeRelationshipsNotConnectedToElement",
	"Comment": "removes relationships that are not connected to the specified element.",
	"Method": "void removeRelationshipsNotConnectedToElement(Element element){\r\n    if (element != null) {\r\n        getRelationships().stream().map(RelationshipView::getRelationship).filter(r -> !r.getSource().equals(element) && !r.getDestination().equals(element)).forEach(this::remove);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.Jpeg2000.processParameters",
	"Comment": "this method checks if the image is a valid jpeg and processes some parameters.",
	"Method": "void processParameters(){\r\n    type = JPEG2000;\r\n    originalType = ORIGINAL_JPEG2000;\r\n    inp = null;\r\n    try {\r\n        if (rawData == null) {\r\n            inp = url.openStream();\r\n        } else {\r\n            inp = new java.io.ByteArrayInputStream(rawData);\r\n        }\r\n        boxLength = cio_read(4);\r\n        if (boxLength == 0x0000000c) {\r\n            isJp2 = true;\r\n            boxType = cio_read(4);\r\n            if (JP2_JP != boxType) {\r\n                throw new IOException(MessageLocalization.getComposedMessage(\"expected.jp.marker\"));\r\n            }\r\n            if (0x0d0a870a != cio_read(4)) {\r\n                throw new IOException(MessageLocalization.getComposedMessage(\"error.with.jp.marker\"));\r\n            }\r\n            jp2_read_boxhdr();\r\n            if (JP2_FTYP != boxType) {\r\n                throw new IOException(MessageLocalization.getComposedMessage(\"expected.ftyp.marker\"));\r\n            }\r\n            Utilities.skip(inp, boxLength - 8);\r\n            jp2_read_boxhdr();\r\n            do {\r\n                if (JP2_JP2H != boxType) {\r\n                    if (boxType == JP2_JP2C) {\r\n                        throw new IOException(MessageLocalization.getComposedMessage(\"expected.jp2h.marker\"));\r\n                    }\r\n                    Utilities.skip(inp, boxLength - 8);\r\n                    jp2_read_boxhdr();\r\n                }\r\n            } while (JP2_JP2H != boxType);\r\n            jp2_read_boxhdr();\r\n            if (JP2_IHDR != boxType) {\r\n                throw new IOException(MessageLocalization.getComposedMessage(\"expected.ihdr.marker\"));\r\n            }\r\n            scaledHeight = cio_read(4);\r\n            setTop(scaledHeight);\r\n            scaledWidth = cio_read(4);\r\n            setRight(scaledWidth);\r\n            numOfComps = cio_read(2);\r\n            bpc = -1;\r\n            bpc = cio_read(1);\r\n            Utilities.skip(inp, 3);\r\n            jp2_read_boxhdr();\r\n            if (boxType == JP2_BPCC) {\r\n                bpcBoxData = new byte[boxLength - 8];\r\n                inp.read(bpcBoxData, 0, boxLength - 8);\r\n            } else if (boxType == JP2_COLR) {\r\n                do {\r\n                    if (colorSpecBoxes == null)\r\n                        colorSpecBoxes = new ArrayList<ColorSpecBox>();\r\n                    colorSpecBoxes.add(jp2_read_colr());\r\n                    try {\r\n                        jp2_read_boxhdr();\r\n                    } catch (ZeroBoxSizeException ioe) {\r\n                    }\r\n                } while (JP2_COLR == boxType);\r\n            }\r\n        } else if (boxLength == 0xff4fff51) {\r\n            Utilities.skip(inp, 4);\r\n            int x1 = cio_read(4);\r\n            int y1 = cio_read(4);\r\n            int x0 = cio_read(4);\r\n            int y0 = cio_read(4);\r\n            Utilities.skip(inp, 16);\r\n            colorspace = cio_read(2);\r\n            bpc = 8;\r\n            scaledHeight = y1 - y0;\r\n            setTop(scaledHeight);\r\n            scaledWidth = x1 - x0;\r\n            setRight(scaledWidth);\r\n        } else {\r\n            throw new IOException(MessageLocalization.getComposedMessage(\"not.a.valid.jpeg2000.file\"));\r\n        }\r\n    } finally {\r\n        if (inp != null) {\r\n            try {\r\n                inp.close();\r\n            } catch (Exception e) {\r\n            }\r\n            inp = null;\r\n        }\r\n    }\r\n    plainWidth = getWidth();\r\n    plainHeight = getHeight();\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.step",
	"Comment": "take a time step. this performs collision detection, integration, and constraint solution.",
	"Method": "void step(float dt,int velocityIterations,int positionIterations){\r\n    stepTimer.reset();\r\n    tempTimer.reset();\r\n    if ((m_flags & NEW_FIXTURE) == NEW_FIXTURE) {\r\n        m_contactManager.findNewContacts();\r\n        m_flags &= ~NEW_FIXTURE;\r\n    }\r\n    m_flags |= LOCKED;\r\n    step.dt = dt;\r\n    step.velocityIterations = velocityIterations;\r\n    step.positionIterations = positionIterations;\r\n    if (dt > 0.0f) {\r\n        step.inv_dt = 1.0f / dt;\r\n    } else {\r\n        step.inv_dt = 0.0f;\r\n    }\r\n    step.dtRatio = m_inv_dt0 * dt;\r\n    step.warmStarting = m_warmStarting;\r\n    m_profile.stepInit.record(tempTimer.getMilliseconds());\r\n    tempTimer.reset();\r\n    m_contactManager.collide();\r\n    m_profile.collide.record(tempTimer.getMilliseconds());\r\n    if (m_stepComplete && step.dt > 0.0f) {\r\n        tempTimer.reset();\r\n        m_particleSystem.solve(step);\r\n        m_profile.solveParticleSystem.record(tempTimer.getMilliseconds());\r\n        tempTimer.reset();\r\n        solve(step);\r\n        m_profile.solve.record(tempTimer.getMilliseconds());\r\n    }\r\n    if (m_continuousPhysics && step.dt > 0.0f) {\r\n        tempTimer.reset();\r\n        solveTOI(step);\r\n        m_profile.solveTOI.record(tempTimer.getMilliseconds());\r\n    }\r\n    if (step.dt > 0.0f) {\r\n        m_inv_dt0 = step.inv_dt;\r\n    }\r\n    if ((m_flags & CLEAR_FORCES) == CLEAR_FORCES) {\r\n        clearForces();\r\n    }\r\n    m_flags &= ~LOCKED;\r\n    m_profile.step.record(stepTimer.getMilliseconds());\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Fixture.getUserData",
	"Comment": "get the user data that was assigned in the fixture definition. use this to store yourapplication specific data.",
	"Method": "Object getUserData(){\r\n    return m_userData;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.LtvVerification.addVerification",
	"Comment": "alternative addverification.i assume that inputs are deduplicated.",
	"Method": "boolean addVerification(String signatureName,OcspClient ocsp,CrlClient crl,CertificateOption certOption,Level level,CertificateInclusion certInclude,boolean addVerification,String signatureName,Collection<byte[]> ocsps,Collection<byte[]> crls,Collection<byte[]> certs){\r\n    if (used)\r\n        throw new IllegalStateException(MessageLocalization.getComposedMessage(\"verification.already.output\"));\r\n    ValidationData vd = new ValidationData();\r\n    if (ocsps != null) {\r\n        for (byte[] ocsp : ocsps) {\r\n            vd.ocsps.add(buildOCSPResponse(ocsp));\r\n        }\r\n    }\r\n    if (crls != null) {\r\n        for (byte[] crl : crls) {\r\n            vd.crls.add(crl);\r\n        }\r\n    }\r\n    if (certs != null) {\r\n        for (byte[] cert : certs) {\r\n            vd.certs.add(cert);\r\n        }\r\n    }\r\n    validated.put(getSignatureHashKey(signatureName), vd);\r\n    return true;\r\n}"
}, {
	"Path": "com.machinepublishers.jbrowserdriver.JBrowserDriverServer.init",
	"Comment": "optionally call this method if you want javafx initialized and the browserwindow opened immediately. otherwise, initialization will happen lazily.",
	"Method": "void init(){\r\n    context.get().init(this);\r\n}"
}, {
	"Path": "com.machinepublishers.glass.ui.monocle.RunnableProcessor.invokeAndWait",
	"Comment": "posts a runnable to the javafx event queue and waits for the runnableto complete.",
	"Method": "void invokeAndWait(Runnable r){\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    queue.postRunnable(() -> {\r\n        try {\r\n            r.run();\r\n        } finally {\r\n            latch.countDown();\r\n        }\r\n    });\r\n    try {\r\n        latch.await();\r\n    } catch (InterruptedException e) {\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.Utilities.convertToUtf32",
	"Comment": "converts a unicode character in a string to a utf32 code point value",
	"Method": "int convertToUtf32(char highSurrogate,char lowSurrogate,int convertToUtf32,char[] text,int idx,int convertToUtf32,String text,int idx){\r\n    return (text.charAt(idx) - 0xd800) * 0x400 + text.charAt(idx + 1) - 0xdc00 + 0x10000;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.PulleyJointDef.initialize",
	"Comment": "initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors.",
	"Method": "void initialize(Body b1,Body b2,Vec2 ga1,Vec2 ga2,Vec2 anchor1,Vec2 anchor2,float r){\r\n    bodyA = b1;\r\n    bodyB = b2;\r\n    groundAnchorA = ga1;\r\n    groundAnchorB = ga2;\r\n    localAnchorA = bodyA.getLocalPoint(anchor1);\r\n    localAnchorB = bodyB.getLocalPoint(anchor2);\r\n    Vec2 d1 = anchor1.sub(ga1);\r\n    lengthA = d1.length();\r\n    Vec2 d2 = anchor2.sub(ga2);\r\n    lengthB = d2.length();\r\n    ratio = r;\r\n    assert (ratio > Settings.EPSILON);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentByte.createGraphics",
	"Comment": "gets a graphics2d to write on. the graphicsare translated to pdf commands.",
	"Method": "java.awt.Graphics2D createGraphics(float width,float height,java.awt.Graphics2D createGraphics,float width,float height,boolean convertImagesToJPEG,float quality,java.awt.Graphics2D createGraphics,float width,float height,FontMapper fontMapper,java.awt.Graphics2D createGraphics,float width,float height,FontMapper fontMapper,boolean convertImagesToJPEG,float quality){\r\n    return new PdfGraphics2D(this, width, height, fontMapper, false, convertImagesToJPEG, quality);\r\n}"
}, {
	"Path": "com.itextpdf.awt.geom.PolylineShape.getPathIterator",
	"Comment": "returns an iteration object that defines the boundary of the polyline.",
	"Method": "PathIterator getPathIterator(AffineTransform at,PathIterator getPathIterator,AffineTransform at,double flatness){\r\n    return new PolylineShapeIterator(this, at);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.isSubset",
	"Comment": "indicates if all the glyphs and widths for that particularencoding should be included in the document.",
	"Method": "boolean isSubset(){\r\n    return subset;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.setRunDirection",
	"Comment": "use this method to set the run direction.this is only used as a placeholder as it does not affect anything.",
	"Method": "void setRunDirection(int runDirection){\r\n    if (runDirection < RUN_DIRECTION_NO_BIDI || runDirection > RUN_DIRECTION_RTL)\r\n        throw new RuntimeException(MessageLocalization.getComposedMessage(\"invalid.run.direction.1\", runDirection));\r\n    this.runDirection = runDirection;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CMapAwareDocumentFont.processToUnicode",
	"Comment": "parses the tounicode entry, if present, and constructs a cmap for it",
	"Method": "void processToUnicode(){\r\n    PdfObject toUni = PdfReader.getPdfObjectRelease(fontDic.get(PdfName.TOUNICODE));\r\n    if (toUni instanceof PRStream) {\r\n        try {\r\n            byte[] touni = PdfReader.getStreamBytes((PRStream) toUni);\r\n            CidLocationFromByte lb = new CidLocationFromByte(touni);\r\n            toUnicodeCmap = new CMapToUnicode();\r\n            CMapParserEx.parseCid(\"\", toUnicodeCmap, lb);\r\n            uni2cid = toUnicodeCmap.createReverseMapping();\r\n        } catch (IOException e) {\r\n            toUnicodeCmap = null;\r\n            uni2cid = null;\r\n        }\r\n    } else if (isType0) {\r\n        try {\r\n            PdfName encodingName = fontDic.getAsName(PdfName.ENCODING);\r\n            if (encodingName == null)\r\n                return;\r\n            String enc = PdfName.decodeName(encodingName.toString());\r\n            if (!enc.equals(\"Identity-H\"))\r\n                return;\r\n            PdfArray df = (PdfArray) PdfReader.getPdfObjectRelease(fontDic.get(PdfName.DESCENDANTFONTS));\r\n            PdfDictionary cidft = (PdfDictionary) PdfReader.getPdfObjectRelease(df.getPdfObject(0));\r\n            PdfDictionary cidinfo = cidft.getAsDict(PdfName.CIDSYSTEMINFO);\r\n            if (cidinfo == null)\r\n                return;\r\n            PdfString ordering = cidinfo.getAsString(PdfName.ORDERING);\r\n            if (ordering == null)\r\n                return;\r\n            CMapToUnicode touni = IdentityToUnicode.GetMapFromOrdering(ordering.toUnicodeString());\r\n            if (touni == null)\r\n                return;\r\n            toUnicodeCmap = touni;\r\n            uni2cid = toUnicodeCmap.createReverseMapping();\r\n        } catch (IOException e) {\r\n            toUnicodeCmap = null;\r\n            uni2cid = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.example.firestore.snippets.ListenDataSnippets.listenForMultiple",
	"Comment": "listen to a query, returning the names of all cities in the first snapshot.",
	"Method": "List<String> listenForMultiple(){\r\n    final SettableApiFuture<List<String>> future = SettableApiFuture.create();\r\n    db.collection(\"cities\").whereEqualTo(\"state\", \"CA\").addSnapshotListener(new EventListener<QuerySnapshot>() {\r\n        @Override\r\n        public void onEvent(@Nullable QuerySnapshot snapshots, @Nullable FirestoreException e) {\r\n            if (e != null) {\r\n                System.err.println(\"Listen failed:\" + e);\r\n                return;\r\n            }\r\n            List<String> cities = new ArrayList();\r\n            for (DocumentSnapshot doc : snapshots) {\r\n                if (doc.get(\"name\") != null) {\r\n                    cities.add(doc.getString(\"name\"));\r\n                }\r\n            }\r\n            System.out.println(\"Current cites in CA: \" + cities);\r\n            if (!future.isDone()) {\r\n                future.set(cities);\r\n            }\r\n        }\r\n    });\r\n    return future.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "com.example.firestore.snippets.ListenDataSnippets.listenForMultiple",
	"Comment": "listen to a query, returning the names of all cities in the first snapshot.",
	"Method": "List<String> listenForMultiple(){\r\n    if (e != null) {\r\n        System.err.println(\"Listen failed:\" + e);\r\n        return;\r\n    }\r\n    List<String> cities = new ArrayList();\r\n    for (DocumentSnapshot doc : snapshots) {\r\n        if (doc.get(\"name\") != null) {\r\n            cities.add(doc.getString(\"name\"));\r\n        }\r\n    }\r\n    System.out.println(\"Current cites in CA: \" + cities);\r\n    if (!future.isDone()) {\r\n        future.set(cities);\r\n    }\r\n}"
}, {
	"Path": "software.amazon.ion.util.JarInfo.tryLoadBuildProperties",
	"Comment": "returns true if the properties were loaded, otherwise false.",
	"Method": "boolean tryLoadBuildProperties(Manifest manifest){\r\n    Attributes mainAttributes = manifest.getMainAttributes();\r\n    String projectVersion = mainAttributes.getValue(PROJECT_VERSION_ATTRIBUTE);\r\n    String time = mainAttributes.getValue(BUILD_TIME_ATTRIBUTE);\r\n    if (projectVersion == null || time == null) {\r\n        return false;\r\n    }\r\n    ourProjectVersion = projectVersion;\r\n    try {\r\n        ourBuildTime = Timestamp.valueOf(time);\r\n    } catch (IllegalArgumentException e) {\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.openhft.affinity.AffinityLock.assignCurrentThread",
	"Comment": "assigning the current thread has a side effect of preventing the lock being used again untilit is released.",
	"Method": "void assignCurrentThread(boolean bind,boolean wholeCore){\r\n    assignedThread = Thread.currentThread();\r\n    if (bind)\r\n        bind(wholeCore);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.resetContent",
	"Comment": "resets all the direct contents to empty.this happens when a new page is started.",
	"Method": "void resetContent(){\r\n    directContent.reset();\r\n    directContentUnder.reset();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.BuildNewFile",
	"Comment": "the function builds the new output stream according to the subset process",
	"Method": "byte[] BuildNewFile(int Font){\r\n    OutputList = new LinkedList<Item>();\r\n    CopyHeader();\r\n    BuildIndexHeader(1, 1, 1);\r\n    OutputList.addLast(new UInt8Item((char) (1 + fonts[Font].name.length())));\r\n    OutputList.addLast(new StringItem(fonts[Font].name));\r\n    BuildIndexHeader(1, 2, 1);\r\n    OffsetItem topdictIndex1Ref = new IndexOffsetItem(2);\r\n    OutputList.addLast(topdictIndex1Ref);\r\n    IndexBaseItem topdictBase = new IndexBaseItem();\r\n    OutputList.addLast(topdictBase);\r\n    OffsetItem charsetRef = new DictOffsetItem();\r\n    OffsetItem charstringsRef = new DictOffsetItem();\r\n    OffsetItem fdarrayRef = new DictOffsetItem();\r\n    OffsetItem fdselectRef = new DictOffsetItem();\r\n    OffsetItem privateRef = new DictOffsetItem();\r\n    if (!fonts[Font].isCID) {\r\n        OutputList.addLast(new DictNumberItem(fonts[Font].nstrings));\r\n        OutputList.addLast(new DictNumberItem(fonts[Font].nstrings + 1));\r\n        OutputList.addLast(new DictNumberItem(0));\r\n        OutputList.addLast(new UInt8Item((char) 12));\r\n        OutputList.addLast(new UInt8Item((char) 30));\r\n        OutputList.addLast(new DictNumberItem(fonts[Font].nglyphs));\r\n        OutputList.addLast(new UInt8Item((char) 12));\r\n        OutputList.addLast(new UInt8Item((char) 34));\r\n    }\r\n    seek(topdictOffsets[Font]);\r\n    while (getPosition() < topdictOffsets[Font + 1]) {\r\n        int p1 = getPosition();\r\n        getDictItem();\r\n        int p2 = getPosition();\r\n        if (key == \"Encoding\" || key == \"Private\" || key == \"FDSelect\" || key == \"FDArray\" || key == \"charset\" || key == \"CharStrings\") {\r\n        } else {\r\n            OutputList.add(new RangeItem(buf, p1, p2 - p1));\r\n        }\r\n    }\r\n    CreateKeys(fdarrayRef, fdselectRef, charsetRef, charstringsRef);\r\n    OutputList.addLast(new IndexMarkerItem(topdictIndex1Ref, topdictBase));\r\n    if (fonts[Font].isCID)\r\n        OutputList.addLast(getEntireIndexRange(stringIndexOffset));\r\n    else\r\n        CreateNewStringIndex(Font);\r\n    OutputList.addLast(new RangeItem(new RandomAccessFileOrArray(NewGSubrsIndex), 0, NewGSubrsIndex.length));\r\n    if (fonts[Font].isCID) {\r\n        OutputList.addLast(new MarkerItem(fdselectRef));\r\n        if (fonts[Font].fdselectOffset >= 0)\r\n            OutputList.addLast(new RangeItem(buf, fonts[Font].fdselectOffset, fonts[Font].FDSelectLength));\r\n        else\r\n            CreateFDSelect(fdselectRef, fonts[Font].nglyphs);\r\n        OutputList.addLast(new MarkerItem(charsetRef));\r\n        OutputList.addLast(new RangeItem(buf, fonts[Font].charsetOffset, fonts[Font].CharsetLength));\r\n        if (fonts[Font].fdarrayOffset >= 0) {\r\n            OutputList.addLast(new MarkerItem(fdarrayRef));\r\n            Reconstruct(Font);\r\n        } else\r\n            CreateFDArray(fdarrayRef, privateRef, Font);\r\n    } else {\r\n        CreateFDSelect(fdselectRef, fonts[Font].nglyphs);\r\n        CreateCharset(charsetRef, fonts[Font].nglyphs);\r\n        CreateFDArray(fdarrayRef, privateRef, Font);\r\n    }\r\n    if (fonts[Font].privateOffset >= 0) {\r\n        IndexBaseItem PrivateBase = new IndexBaseItem();\r\n        OutputList.addLast(PrivateBase);\r\n        OutputList.addLast(new MarkerItem(privateRef));\r\n        OffsetItem Subr = new DictOffsetItem();\r\n        CreateNonCIDPrivate(Font, Subr);\r\n        CreateNonCIDSubrs(Font, PrivateBase, Subr);\r\n    }\r\n    OutputList.addLast(new MarkerItem(charstringsRef));\r\n    OutputList.addLast(new RangeItem(new RandomAccessFileOrArray(NewCharStringsIndex), 0, NewCharStringsIndex.length));\r\n    int[] currentOffset = new int[1];\r\n    currentOffset[0] = 0;\r\n    Iterator<Item> listIter = OutputList.iterator();\r\n    while (listIter.hasNext()) {\r\n        Item item = listIter.next();\r\n        item.increment(currentOffset);\r\n    }\r\n    listIter = OutputList.iterator();\r\n    while (listIter.hasNext()) {\r\n        Item item = listIter.next();\r\n        item.xref();\r\n    }\r\n    int size = currentOffset[0];\r\n    byte[] b = new byte[size];\r\n    listIter = OutputList.iterator();\r\n    while (listIter.hasNext()) {\r\n        Item item = listIter.next();\r\n        item.emit(b);\r\n    }\r\n    return b;\r\n}"
}, {
	"Path": "com.sixt.service.framework.kafka.KafkaSubscriberBuilder.withOffsetReset",
	"Comment": "unless called, will initialize by starting at the earliest offset",
	"Method": "KafkaSubscriberBuilder<TYPE> withOffsetReset(KafkaSubscriber.OffsetReset value){\r\n    this.offsetReset = value;\r\n    return this;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.IonReaderTextRawTokensX.skip_over_whitespace",
	"Comment": "skip over any whitespace, applying the given commentstrategy toany comments found.",
	"Method": "int skip_over_whitespace(int skip_over_whitespace,CommentStrategy commentStrategy){\r\n    skip_whitespace(commentStrategy);\r\n    return read_char();\r\n}"
}, {
	"Path": "com.itextpdf.text.Section.add",
	"Comment": "adds a paragraph, list, table or another sectionto this section.",
	"Method": "void add(int index,Element element,boolean add,Element element){\r\n    if (isAddedCompletely()) {\r\n        throw new IllegalStateException(MessageLocalization.getComposedMessage(\"this.largeelement.has.already.been.added.to.the.document\"));\r\n    }\r\n    try {\r\n        if (element.type() == Element.SECTION) {\r\n            Section section = (Section) element;\r\n            section.setNumbers(++subsections, numbers);\r\n            return super.add(section);\r\n        } else if (element instanceof MarkedSection && ((MarkedObject) element).element.type() == Element.SECTION) {\r\n            MarkedSection mo = (MarkedSection) element;\r\n            Section section = (Section) mo.element;\r\n            section.setNumbers(++subsections, numbers);\r\n            return super.add(mo);\r\n        } else if (element.isNestable()) {\r\n            return super.add(element);\r\n        } else {\r\n            throw new ClassCastException(MessageLocalization.getComposedMessage(\"you.can.t.add.a.1.to.a.section\", element.getClass().getName()));\r\n        }\r\n    } catch (ClassCastException cce) {\r\n        throw new ClassCastException(MessageLocalization.getComposedMessage(\"insertion.of.illegal.element.1\", cce.getMessage()));\r\n    }\r\n}"
}, {
	"Path": "com.machinepublishers.glass.ui.monocle.KeyState.getWindow",
	"Comment": "returns the glass window on which this event state is located .",
	"Method": "MonocleWindow getWindow(boolean recalculateCache){\r\n    if (window == null || recalculateCache) {\r\n        window = (MonocleWindow) MonocleWindowManager.getInstance().getFocusedWindow();\r\n    }\r\n    return window;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BidiOrder.findRunStart",
	"Comment": "return the start of the run including index that includes only resulttypes in validset.this assumes the value at index is valid, and does not check it.",
	"Method": "int findRunStart(int index,byte[] validSet){\r\n    loop: while (--index >= 0) {\r\n        byte t = resultTypes[index];\r\n        for (int i = 0; i < validSet.length; ++i) {\r\n            if (t == validSet[i]) {\r\n                continue loop;\r\n            }\r\n        }\r\n        return index + 1;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfAnnotation.createStamp",
	"Comment": "adds a stamp to your document. move over the stamp and a tooltip is shown",
	"Method": "PdfAnnotation createStamp(PdfWriter writer,Rectangle rect,String contents,String name){\r\n    PdfAnnotation annot = writer.createAnnotation(rect, PdfName.STAMP);\r\n    annot.put(PdfName.CONTENTS, new PdfString(contents, PdfObject.TEXT_UNICODE));\r\n    annot.put(PdfName.NAME, new PdfName(name));\r\n    return annot;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPTable.getHorizontalAlignment",
	"Comment": "gets the horizontal alignment of the table relative to the page.",
	"Method": "int getHorizontalAlignment(){\r\n    return horizontalAlignment;\r\n}"
}, {
	"Path": "software.amazon.ion.TimestampTest.testCreateWithBogusLocalOffset",
	"Comment": "timestamps with precision coarser than minutes always have unknownlocal offset.",
	"Method": "void testCreateWithBogusLocalOffset(){\r\n    Timestamp ts = createFromUtcFields(Precision.DAY, 2014, 4, 25, 1, 2, 3, null, 60);\r\n    assertEquals(Timestamp.valueOf(\"2014-04-25\"), ts);\r\n    ts = createFromUtcFields(Precision.MONTH, 2014, 4, 25, 1, 2, 3, null, 60);\r\n    assertEquals(Timestamp.valueOf(\"2014-04T\"), ts);\r\n    ts = createFromUtcFields(Precision.YEAR, 2014, 4, 25, 1, 2, 3, null, 60);\r\n    assertEquals(Timestamp.valueOf(\"2014T\"), ts);\r\n}"
}, {
	"Path": "com.example.speech.Recognize.transcribeDiarization",
	"Comment": "transcribe the given audio file using speaker diarization.",
	"Method": "void transcribeDiarization(String fileName){\r\n    Path path = Paths.get(fileName);\r\n    byte[] content = Files.readAllBytes(path);\r\n    try (SpeechClient speechClient = SpeechClient.create()) {\r\n        RecognitionAudio recognitionAudio = RecognitionAudio.newBuilder().setContent(ByteString.copyFrom(content)).build();\r\n        RecognitionConfig config = RecognitionConfig.newBuilder().setEncoding(AudioEncoding.LINEAR16).setLanguageCode(\"en-US\").setSampleRateHertz(8000).setEnableSpeakerDiarization(true).setDiarizationSpeakerCount(2).build();\r\n        RecognizeResponse recognizeResponse = speechClient.recognize(config, recognitionAudio);\r\n        for (SpeechRecognitionResult result : recognizeResponse.getResultsList()) {\r\n            SpeechRecognitionAlternative alternative = result.getAlternatives(0);\r\n            System.out.format(\"Transcript : %s\\n\", alternative.getTranscript());\r\n            System.out.format(\"Speaker Tag %s: %s\\n\", alternative.getWords((alternative.getWordsCount() - 1)).getSpeakerTag(), alternative.getTranscript());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.codec.BmpImage.getImage",
	"Comment": "reads a bmp from a stream. the stream is not closed.the bmp may not have a header and be considered as a plain dib.",
	"Method": "Image getImage(URL url,Image getImage,InputStream is,Image getImage,InputStream is,boolean noHeader,int size,Image getImage,String file,Image getImage,byte data,Image getImage){\r\n    byte[] bdata = null;\r\n    switch(imageType) {\r\n        case VERSION_2_1_BIT:\r\n            return read1Bit(3);\r\n        case VERSION_2_4_BIT:\r\n            return read4Bit(3);\r\n        case VERSION_2_8_BIT:\r\n            return read8Bit(3);\r\n        case VERSION_2_24_BIT:\r\n            bdata = new byte[width * height * 3];\r\n            read24Bit(bdata);\r\n            return new ImgRaw(width, height, 3, 8, bdata);\r\n        case VERSION_3_1_BIT:\r\n            return read1Bit(4);\r\n        case VERSION_3_4_BIT:\r\n            switch((int) compression) {\r\n                case BI_RGB:\r\n                    return read4Bit(4);\r\n                case BI_RLE4:\r\n                    return readRLE4();\r\n                default:\r\n                    throw new RuntimeException(\"Invalid compression specified for BMP file.\");\r\n            }\r\n        case VERSION_3_8_BIT:\r\n            switch((int) compression) {\r\n                case BI_RGB:\r\n                    return read8Bit(4);\r\n                case BI_RLE8:\r\n                    return readRLE8();\r\n                default:\r\n                    throw new RuntimeException(\"Invalid compression specified for BMP file.\");\r\n            }\r\n        case VERSION_3_24_BIT:\r\n            bdata = new byte[width * height * 3];\r\n            read24Bit(bdata);\r\n            return new ImgRaw(width, height, 3, 8, bdata);\r\n        case VERSION_3_NT_16_BIT:\r\n            return read1632Bit(false);\r\n        case VERSION_3_NT_32_BIT:\r\n            return read1632Bit(true);\r\n        case VERSION_4_1_BIT:\r\n            return read1Bit(4);\r\n        case VERSION_4_4_BIT:\r\n            switch((int) compression) {\r\n                case BI_RGB:\r\n                    return read4Bit(4);\r\n                case BI_RLE4:\r\n                    return readRLE4();\r\n                default:\r\n                    throw new RuntimeException(\"Invalid compression specified for BMP file.\");\r\n            }\r\n        case VERSION_4_8_BIT:\r\n            switch((int) compression) {\r\n                case BI_RGB:\r\n                    return read8Bit(4);\r\n                case BI_RLE8:\r\n                    return readRLE8();\r\n                default:\r\n                    throw new RuntimeException(\"Invalid compression specified for BMP file.\");\r\n            }\r\n        case VERSION_4_16_BIT:\r\n            return read1632Bit(false);\r\n        case VERSION_4_24_BIT:\r\n            bdata = new byte[width * height * 3];\r\n            read24Bit(bdata);\r\n            return new ImgRaw(width, height, 3, 8, bdata);\r\n        case VERSION_4_32_BIT:\r\n            return read1632Bit(true);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.itextpdf.text.ExceptionConverter.getException",
	"Comment": "and allow the user of exceptionconverter to get a handle to it.",
	"Method": "Exception getException(){\r\n    return ex;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.mc.StructureItems.processMCID",
	"Comment": "creates a new mcid in the parent tree of the page\tand returns that new mcid so that it can be used\tin the content stream",
	"Method": "int processMCID(PdfNumber structParents,PdfIndirectReference ref){\r\n    if (ref == null)\r\n        throw new DocumentException(MessageLocalization.getComposedMessage(\"can.t.read.document.structure\"));\r\n    PdfObject object = parentTree.get(structParents.intValue());\r\n    PdfArray array = (PdfArray) PdfReader.getPdfObject(object);\r\n    int i = getNextMCID(structParents);\r\n    if (i < array.size()) {\r\n        array.set(i, ref);\r\n        return i;\r\n    }\r\n    array.add(ref);\r\n    return array.size() - 1;\r\n}"
}, {
	"Path": "com.google.cloud.language.samples.ModelApi.listModelEvaluations",
	"Comment": "demonstrates using the automl client to list model evaluations.",
	"Method": "void listModelEvaluations(String projectId,String computeRegion,String modelId,String filter){\r\n    AutoMlClient client = AutoMlClient.create();\r\n    ModelName modelFullId = ModelName.of(projectId, computeRegion, modelId);\r\n    ListModelEvaluationsRequest modelEvaluationsRequest = ListModelEvaluationsRequest.newBuilder().setParent(modelFullId.toString()).setFilter(filter).build();\r\n    for (ModelEvaluation element : client.listModelEvaluations(modelEvaluationsRequest).iterateAll()) {\r\n        System.out.println(element);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.Font.getCalculatedSize",
	"Comment": "gets the size that can be used with the calculated basefont\t.",
	"Method": "float getCalculatedSize(){\r\n    float s = this.size;\r\n    if (s == UNDEFINED) {\r\n        s = DEFAULTSIZE;\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfLayer.getRef",
	"Comment": "gets the pdfindirectreference that represents this layer.",
	"Method": "PdfIndirectReference getRef(){\r\n    return ref;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStamperImp.readOCProperties",
	"Comment": "reads the ocproperties dictionary from the catalog of the existing documentand fills the documentocg, documentocgorder and ocgradiogroup variables in pdfwriter.note that the original ocproperties of the existing document can contain more information.",
	"Method": "void readOCProperties(){\r\n    if (!documentOCG.isEmpty()) {\r\n        return;\r\n    }\r\n    PdfDictionary dict = reader.getCatalog().getAsDict(PdfName.OCPROPERTIES);\r\n    if (dict == null) {\r\n        return;\r\n    }\r\n    PdfArray ocgs = dict.getAsArray(PdfName.OCGS);\r\n    if (ocgs == null) {\r\n        ocgs = new PdfArray();\r\n        dict.put(PdfName.OCGS, ocgs);\r\n    }\r\n    PdfIndirectReference ref;\r\n    PdfLayer layer;\r\n    HashMap<String, PdfLayer> ocgmap = new HashMap<String, PdfLayer>();\r\n    for (Iterator<PdfObject> i = ocgs.listIterator(); i.hasNext(); ) {\r\n        ref = (PdfIndirectReference) i.next();\r\n        layer = new PdfLayer(null);\r\n        layer.setRef(ref);\r\n        layer.setOnPanel(false);\r\n        layer.merge((PdfDictionary) PdfReader.getPdfObject(ref));\r\n        ocgmap.put(ref.toString(), layer);\r\n    }\r\n    PdfDictionary d = dict.getAsDict(PdfName.D);\r\n    PdfArray off = d.getAsArray(PdfName.OFF);\r\n    if (off != null) {\r\n        for (Iterator<PdfObject> i = off.listIterator(); i.hasNext(); ) {\r\n            ref = (PdfIndirectReference) i.next();\r\n            layer = ocgmap.get(ref.toString());\r\n            layer.setOn(false);\r\n        }\r\n    }\r\n    PdfArray order = d.getAsArray(PdfName.ORDER);\r\n    if (order != null) {\r\n        addOrder(null, order, ocgmap);\r\n    }\r\n    documentOCG.addAll(ocgmap.values());\r\n    OCGRadioGroup = d.getAsArray(PdfName.RBGROUPS);\r\n    if (OCGRadioGroup == null)\r\n        OCGRadioGroup = new PdfArray();\r\n    OCGLocked = d.getAsArray(PdfName.LOCKED);\r\n    if (OCGLocked == null)\r\n        OCGLocked = new PdfArray();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.InlineImageUtils.computeBytesPerRow",
	"Comment": "computes the number of unfiltered bytes that each row of the image will contain.if the number of bytes results in a partial terminating byte, this number is rounded upper the pdf specification",
	"Method": "int computeBytesPerRow(PdfDictionary imageDictionary,PdfDictionary colorSpaceDic){\r\n    PdfNumber wObj = imageDictionary.getAsNumber(PdfName.WIDTH);\r\n    PdfNumber bpcObj = imageDictionary.getAsNumber(PdfName.BITSPERCOMPONENT);\r\n    int cpp = getComponentsPerPixel(imageDictionary.getAsName(PdfName.COLORSPACE), colorSpaceDic);\r\n    int w = wObj.intValue();\r\n    int bpc = bpcObj != null ? bpcObj.intValue() : 1;\r\n    int bytesPerRow = (w * bpc * cpp + 7) / 8;\r\n    return bytesPerRow;\r\n}"
}, {
	"Path": "net.dv8tion.jda.bot.sharding.ShardManager.removeEventListeners",
	"Comment": "remove listeners from shards by their id.the provider takes shard ids, and returns a collection of listeners that shall be removed from the respectiveshards.",
	"Method": "void removeEventListeners(IntFunction<Collection<Object>> eventListenerProvider){\r\n    Checks.notNull(eventListenerProvider, \"event listener provider\");\r\n    this.getShardCache().forEach(jda -> jda.removeEventListener(eventListenerProvider.apply(jda.getShardInfo().getShardId())));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfSignatureAppearance.setSignatureEvent",
	"Comment": "sets the signature event to allow modification of the signature dictionary.",
	"Method": "void setSignatureEvent(SignatureEvent signatureEvent){\r\n    this.signatureEvent = signatureEvent;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.XMPMetaFactory.getVersionInfo",
	"Comment": "obtain version information. the xmpversioninfo singleton is created the first timeits requested.",
	"Method": "XMPVersionInfo getVersionInfo(){\r\n    if (versionInfo == null) {\r\n        try {\r\n            final int major = 5;\r\n            final int minor = 1;\r\n            final int micro = 0;\r\n            final int engBuild = 3;\r\n            final boolean debug = false;\r\n            final String message = \"Adobe XMP Core 5.1.0-jc003\";\r\n            versionInfo = new XMPVersionInfo() {\r\n                public int getMajor() {\r\n                    return major;\r\n                }\r\n                public int getMinor() {\r\n                    return minor;\r\n                }\r\n                public int getMicro() {\r\n                    return micro;\r\n                }\r\n                public boolean isDebug() {\r\n                    return debug;\r\n                }\r\n                public int getBuild() {\r\n                    return engBuild;\r\n                }\r\n                public String getMessage() {\r\n                    return message;\r\n                }\r\n                public String toString() {\r\n                    return message;\r\n                }\r\n            };\r\n        } catch (Throwable e) {\r\n            System.out.println(e);\r\n        }\r\n    }\r\n    return versionInfo;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.XMPMetaFactory.getVersionInfo",
	"Comment": "obtain version information. the xmpversioninfo singleton is created the first timeits requested.",
	"Method": "XMPVersionInfo getVersionInfo(){\r\n    return major;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.XMPMetaFactory.getVersionInfo",
	"Comment": "obtain version information. the xmpversioninfo singleton is created the first timeits requested.",
	"Method": "XMPVersionInfo getVersionInfo(){\r\n    return minor;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.XMPMetaFactory.getVersionInfo",
	"Comment": "obtain version information. the xmpversioninfo singleton is created the first timeits requested.",
	"Method": "XMPVersionInfo getVersionInfo(){\r\n    return micro;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.XMPMetaFactory.getVersionInfo",
	"Comment": "obtain version information. the xmpversioninfo singleton is created the first timeits requested.",
	"Method": "XMPVersionInfo getVersionInfo(){\r\n    return debug;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.XMPMetaFactory.getVersionInfo",
	"Comment": "obtain version information. the xmpversioninfo singleton is created the first timeits requested.",
	"Method": "XMPVersionInfo getVersionInfo(){\r\n    return engBuild;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.XMPMetaFactory.getVersionInfo",
	"Comment": "obtain version information. the xmpversioninfo singleton is created the first timeits requested.",
	"Method": "XMPVersionInfo getVersionInfo(){\r\n    return message;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.XMPMetaFactory.getVersionInfo",
	"Comment": "obtain version information. the xmpversioninfo singleton is created the first timeits requested.",
	"Method": "XMPVersionInfo getVersionInfo(){\r\n    return message;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.XfaForm.setTemplateSom",
	"Comment": "sets the class that contains the template processing section of the xfa",
	"Method": "void setTemplateSom(Xml2SomTemplate templateSom){\r\n    this.templateSom = templateSom;\r\n}"
}, {
	"Path": "software.amazon.ion.StructTest.testModsCausingHeaderOverlap",
	"Comment": "this looks for a subtle encoding problem. if a value has its headerwidened enough to overlap clean content, we must be careful to notoverwrite the content while writing the header.this can happen whenadding annotations.",
	"Method": "void testModsCausingHeaderOverlap(){\r\n    IonDatagram dg = values(\"{f:\\\"this is a string to overlap\\\"}\");\r\n    IonStruct v = (IonStruct) dg.get(0);\r\n    v.addTypeAnnotation(\"one\");\r\n    v.addTypeAnnotation(\"two\");\r\n    v.addTypeAnnotation(\"three\");\r\n    v.addTypeAnnotation(\"four\");\r\n    v.addTypeAnnotation(\"five\");\r\n    v.addTypeAnnotation(\"six\");\r\n    IonDatagram dg2 = reload(dg);\r\n    IonStruct v2 = (IonStruct) dg2.get(0);\r\n    IonValue f = v2.get(\"f\");\r\n    checkString(\"this is a string to overlap\", f);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfEncodings.convertToString",
	"Comment": "converts a byte array to a string accordingto the some encoding.",
	"Method": "String convertToString(byte bytes,String encoding){\r\n    if (bytes == null)\r\n        return PdfObject.NOTHING;\r\n    if (encoding == null || encoding.length() == 0) {\r\n        char[] c = new char[bytes.length];\r\n        for (int k = 0; k < bytes.length; ++k) c[k] = (char) (bytes[k] & 0xff);\r\n        return new String(c);\r\n    }\r\n    ExtraEncoding extra = extraEncodings.get(encoding.toLowerCase());\r\n    if (extra != null) {\r\n        String text = extra.byteToChar(bytes, encoding);\r\n        if (text != null)\r\n            return text;\r\n    }\r\n    char[] ch = null;\r\n    if (encoding.equals(BaseFont.WINANSI))\r\n        ch = winansiByteToChar;\r\n    else if (encoding.equals(PdfObject.TEXT_PDFDOCENCODING))\r\n        ch = pdfEncodingByteToChar;\r\n    if (ch != null) {\r\n        int len = bytes.length;\r\n        char[] c = new char[len];\r\n        for (int k = 0; k < len; ++k) {\r\n            c[k] = ch[bytes[k] & 0xff];\r\n        }\r\n        return new String(c);\r\n    }\r\n    try {\r\n        return new String(bytes, encoding);\r\n    } catch (UnsupportedEncodingException e) {\r\n        throw new ExceptionConverter(e);\r\n    }\r\n}"
}, {
	"Path": "software.amazon.ion.impl.UnifiedInputStreamX.refill",
	"Comment": "the refill method is the key override that is filled in bythe various subclasses.it fills either the byte or chararray with a block of data from the input source.as thisis a virtual function the right version will get called foreach source type.since it is only called once per block,and from then on the final method which pulls data fromthe block can return the value this should be a reasonableperformance trade off.",
	"Method": "int refill(){\r\n    UnifiedDataPageX curr = _buffer.getCurrentPage();\r\n    SavePoint sp = _save_points.savePointActiveTop();\r\n    if (!can_fill_new_page()) {\r\n        return refill_is_eof();\r\n    }\r\n    if (sp != null && sp.getEndIdx() == _buffer.getCurrentPageIdx()) {\r\n        return refill_is_eof();\r\n    }\r\n    long file_position;\r\n    int start_pos = UNREAD_LIMIT;\r\n    if (curr == null) {\r\n        file_position = 0;\r\n        start_pos = 0;\r\n    } else {\r\n        file_position = curr.getFilePosition(_pos);\r\n        if (file_position == 0) {\r\n            start_pos = 0;\r\n        }\r\n    }\r\n    int new_idx = _buffer.getNextFilledPageIdx();\r\n    if (new_idx < 0) {\r\n        curr = _buffer.getCurrentPage();\r\n        boolean needs_new_page = (curr == null);\r\n        new_idx = _buffer.getCurrentPageIdx();\r\n        if (_save_points.isSavePointOpen()) {\r\n            new_idx++;\r\n            needs_new_page = true;\r\n        }\r\n        if (needs_new_page) {\r\n            curr = _buffer.getEmptyPageIdx();\r\n        }\r\n        int read = load(curr, start_pos, file_position);\r\n        if (read < 1) {\r\n            return refill_is_eof();\r\n        }\r\n        assert (curr != null && curr.getOffsetOfFilePosition(file_position) == start_pos);\r\n        set_current_page(new_idx, curr, start_pos);\r\n    } else {\r\n        assert (!isEOF());\r\n        if (sp != null) {\r\n            int endidx = sp.getEndIdx();\r\n            if (endidx != -1 && endidx < new_idx) {\r\n                return refill_is_eof();\r\n            }\r\n        }\r\n        curr = _buffer.getPage(new_idx);\r\n        assert (curr.getStartingFileOffset() == file_position);\r\n        set_current_page(new_idx, curr, curr.getStartingOffset());\r\n        if (sp != null && sp.getEndIdx() == new_idx) {\r\n            _limit = sp.getEndPos();\r\n        }\r\n    }\r\n    assert (isEOF() ^ (_limit > 0));\r\n    return _limit;\r\n}"
}, {
	"Path": "com.structurizr.view.StaticView.removeElementsThatAreUnreachableFrom",
	"Comment": "removes all elements that cannot be reached by traversing the graph of relationshipsstarting with the specified element.",
	"Method": "void removeElementsThatAreUnreachableFrom(Element element){\r\n    if (element != null) {\r\n        Set<Element> elementsToShow = new HashSet();\r\n        Set<Element> elementsVisited = new HashSet();\r\n        findElementsToShow(element, element, elementsToShow, elementsVisited);\r\n        for (ElementView elementView : getElements()) {\r\n            if (!elementsToShow.contains(elementView.getElement()) && canBeRemoved(elementView.getElement())) {\r\n                removeElement(elementView.getElement());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStamperImp.setFlatAnnotations",
	"Comment": "if true, annotations with an appearance stream will be flattened.",
	"Method": "void setFlatAnnotations(boolean flatAnnotations){\r\n    this.flatannotations = flatAnnotations;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPUtilsImpl.checkSeparator",
	"Comment": "make sure the separator is ok. it must be one semicolon surrounded by\tzero or more spaces. any of the recognized semicolons or spaces are\tallowed.",
	"Method": "void checkSeparator(String separator){\r\n    boolean haveSemicolon = false;\r\n    for (int i = 0; i < separator.length(); i++) {\r\n        int charKind = classifyCharacter(separator.charAt(i));\r\n        if (charKind == UCK_SEMICOLON) {\r\n            if (haveSemicolon) {\r\n                throw new XMPException(\"Separator can have only one semicolon\", XMPError.BADPARAM);\r\n            }\r\n            haveSemicolon = true;\r\n        } else if (charKind != UCK_SPACE) {\r\n            throw new XMPException(\"Separator can have only spaces and one semicolon\", XMPError.BADPARAM);\r\n        }\r\n    }\r\n    if (!haveSemicolon) {\r\n        throw new XMPException(\"Separator must have one semicolon\", XMPError.BADPARAM);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.css.apply.MaxLeadingAndSize.getLargestLeadingFromChildren",
	"Comment": "iterates over all children in a list and returns the largest leading found.",
	"Method": "float getLargestLeadingFromChildren(List<Tag> children){\r\n    float leading = 0;\r\n    for (Tag tag : children) {\r\n        Float calculatedLineHeight = calculateLeading(tag);\r\n        if (calculatedLineHeight > leading) {\r\n            leading = calculatedLineHeight;\r\n        }\r\n        getLargestLeadingFromChildren(tag.getChildren());\r\n    }\r\n    return leading;\r\n}"
}, {
	"Path": "br.com.leonardoz.features.collections.UsingConcurrentCollections.usingCopyOnWriteArrayList",
	"Comment": "replacement for synchronized list. based on the immutable object concept.\tuse when reading is far more common than writing.\tcreates a new copy every time that the list is modified, only synchronizing\tbriefly to ensure array content visibility.\titerator returns a snapshot of the current state of the collection.\tsupports atomic operations.",
	"Method": "void usingCopyOnWriteArrayList(){\r\n    ExecutorService executor = Executors.newCachedThreadPool();\r\n    System.out.println(\"=== CopyOnWriteArrayList ===\");\r\n    Random random = new Random();\r\n    CopyOnWriteArrayList<Integer> copyOnWriteArrayList = new CopyOnWriteArrayList<Integer>();\r\n    for (int i = 0; i < 100; i++) {\r\n        if (i % 8 == 0) {\r\n            executor.execute(() -> {\r\n                Integer value = random.nextInt(10);\r\n                System.err.println(\"Added \" + value);\r\n                copyOnWriteArrayList.add(value);\r\n            });\r\n        } else {\r\n            executor.execute(() -> {\r\n                StringBuilder sb = new StringBuilder();\r\n                for (Integer vv : copyOnWriteArrayList) {\r\n                    sb.append(vv + \" \");\r\n                }\r\n                System.out.println(\"Reading \" + sb.toString());\r\n            });\r\n        }\r\n    }\r\n    executor.shutdown();\r\n    try {\r\n        executor.awaitTermination(2000, TimeUnit.SECONDS);\r\n        Thread.sleep(2000);\r\n        System.out.println(\"\\n\\n\\n\\n\");\r\n    } catch (InterruptedException e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.getAllNameEntries",
	"Comment": "gets all the entries of the namestable from the font. only the required tables are read.",
	"Method": "String[][] getAllNameEntries(String[][] getAllNameEntries,String name,String encoding,byte ttfAfm){\r\n    String nameBase = getBaseName(name);\r\n    BaseFont fontBuilt = null;\r\n    if (nameBase.toLowerCase().endsWith(\".ttf\") || nameBase.toLowerCase().endsWith(\".otf\") || nameBase.toLowerCase().indexOf(\".ttc,\") > 0)\r\n        fontBuilt = new TrueTypeFont(name, CP1252, false, ttfAfm, true, false);\r\n    else\r\n        fontBuilt = createFont(name, encoding, false, false, ttfAfm, null);\r\n    return fontBuilt.getAllNameEntries();\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPNormalizer.transplantArrayItemAlias",
	"Comment": "moves an alias node of array form to another schema into an array",
	"Method": "void transplantArrayItemAlias(Iterator propertyIt,XMPNode childNode,XMPNode baseArray){\r\n    if (baseArray.getOptions().isArrayAltText()) {\r\n        if (childNode.getOptions().getHasLanguage()) {\r\n            throw new XMPException(\"Alias to x-default already has a language qualifier\", XMPError.BADXMP);\r\n        }\r\n        XMPNode langQual = new XMPNode(XMPConst.XML_LANG, XMPConst.X_DEFAULT, null);\r\n        childNode.addQualifier(langQual);\r\n    }\r\n    propertyIt.remove();\r\n    childNode.setName(XMPConst.ARRAY_ITEM_NAME);\r\n    baseArray.addChild(childNode);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.TrueTypeFontUnicode.convertToBytes",
	"Comment": "a forbidden operation. will throw a null pointer exception.",
	"Method": "byte[] convertToBytes(String text,byte[] convertToBytes,int char1){\r\n    return null;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.collection.PdfCollectionField.setEditable",
	"Comment": "indication if the field value should be editable in the viewer.",
	"Method": "void setEditable(boolean editable){\r\n    put(PdfName.E, new PdfBoolean(editable));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.ColumnText.findLimitsOneLine",
	"Comment": "finds the intersection between the yline and the two columnbounds. it will set the linestatus appropriately.",
	"Method": "float[] findLimitsOneLine(){\r\n    float x1 = findLimitsPoint(leftWall);\r\n    if (lineStatus == LINE_STATUS_OFFLIMITS || lineStatus == LINE_STATUS_NOLINE) {\r\n        return null;\r\n    }\r\n    float x2 = findLimitsPoint(rightWall);\r\n    if (lineStatus == LINE_STATUS_NOLINE) {\r\n        return null;\r\n    }\r\n    return new float[] { x1, x2 };\r\n}"
}, {
	"Path": "org.jbake.parser.MarkupEngine.headerSeparatorDemarcatesHeader",
	"Comment": "checks if header separator demarcates end of metadata header",
	"Method": "boolean headerSeparatorDemarcatesHeader(List<String> contents){\r\n    List<String> subContents = null;\r\n    int index = contents.indexOf(configuration.getHeaderSeparator());\r\n    if (index != -1) {\r\n        subContents = contents.subList(0, index);\r\n        for (String line : subContents) {\r\n            if (!line.contains(\"=\") && !line.isEmpty()) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDocument.close",
	"Comment": "closes the document.once all the content has been written in the body, you have to closethe body. after that nothing can be written to the body anymore.",
	"Method": "void close(){\r\n    if (close) {\r\n        return;\r\n    }\r\n    try {\r\n        if (isTagged(writer)) {\r\n            flushFloatingElements();\r\n            flushLines();\r\n            writer.flushAcroFields();\r\n            writer.flushTaggedObjects();\r\n            if (isPageEmpty()) {\r\n                int pageReferenceCount = writer.pageReferences.size();\r\n                if (pageReferenceCount > 0 && writer.currentPageNumber == pageReferenceCount) {\r\n                    writer.pageReferences.remove(pageReferenceCount - 1);\r\n                }\r\n            }\r\n        } else\r\n            writer.flushAcroFields();\r\n        if (imageWait != null) {\r\n            newPage();\r\n        }\r\n        endPage();\r\n        if (isTagged(writer)) {\r\n            writer.getDirectContent().closeMCBlock(this);\r\n        }\r\n        if (annotationsImp.hasUnusedAnnotations())\r\n            throw new RuntimeException(MessageLocalization.getComposedMessage(\"not.all.annotations.could.be.added.to.the.document.the.document.doesn.t.have.enough.pages\"));\r\n        PdfPageEvent pageEvent = writer.getPageEvent();\r\n        if (pageEvent != null)\r\n            pageEvent.onCloseDocument(writer, this);\r\n        super.close();\r\n        writer.addLocalDestinations(localDestinations);\r\n        calculateOutlineCount();\r\n        writeOutlines();\r\n    } catch (Exception e) {\r\n        throw ExceptionConverter.convertException(e);\r\n    }\r\n    writer.close();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.OutputStreamCounter.flush",
	"Comment": "flushes this output stream and forces any buffered output bytesto be written out. the general contract of flush isthat calling it is an indication that, if any bytes previouslywritten have been buffered by the implementation of the outputstream, such bytes should immediately be written to theirintended destination.the flush method of outputstream does nothing.",
	"Method": "void flush(){\r\n    out.flush();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.getNamedDestination",
	"Comment": "gets all the named destinations as an hashmap. the key is the nameand the value is the destinations array.",
	"Method": "HashMap<Object, PdfObject> getNamedDestination(HashMap<Object, PdfObject> getNamedDestination,boolean keepNames){\r\n    HashMap<Object, PdfObject> names = getNamedDestinationFromNames(keepNames);\r\n    names.putAll(getNamedDestinationFromStrings());\r\n    return names;\r\n}"
}, {
	"Path": "com.example.dlp.Triggers.main",
	"Comment": "command line application to crate, list and delete triggers.",
	"Method": "void main(String[] args){\r\n    OptionGroup optionsGroup = new OptionGroup();\r\n    optionsGroup.setRequired(true);\r\n    Option createTriggerOption = new Option(\"c\", \"create\", false, \"Create trigger to scan a GCS bucket\");\r\n    optionsGroup.addOption(createTriggerOption);\r\n    Option listTriggersOption = new Option(\"l\", \"list\", false, \"List triggers\");\r\n    optionsGroup.addOption(listTriggersOption);\r\n    Option deleteTriggerOption = new Option(\"d\", \"delete\", false, \"Delete trigger\");\r\n    optionsGroup.addOption(deleteTriggerOption);\r\n    Options commandLineOptions = new Options();\r\n    commandLineOptions.addOptionGroup(optionsGroup);\r\n    Option bucketNameOption = Option.builder(\"bucketName\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(bucketNameOption);\r\n    Option gcsFileNameOption = Option.builder(\"fileName\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(gcsFileNameOption);\r\n    Option autoPopulateTimespanOption = Option.builder(\"autoPopulateTimespan\").required(false).build();\r\n    commandLineOptions.addOption(autoPopulateTimespanOption);\r\n    Option minLikelihoodOption = Option.builder(\"minLikelihood\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(minLikelihoodOption);\r\n    Option maxFindingsOption = Option.builder(\"maxFindings\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(maxFindingsOption);\r\n    Option infoTypesOption = Option.builder(\"infoTypes\").hasArg(true).required(false).build();\r\n    infoTypesOption.setArgs(Option.UNLIMITED_VALUES);\r\n    commandLineOptions.addOption(infoTypesOption);\r\n    Option projectIdOption = Option.builder(\"projectId\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(projectIdOption);\r\n    Option triggerIdOption = Option.builder(\"triggerId\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(triggerIdOption);\r\n    Option displayNameOption = Option.builder(\"displayName\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(displayNameOption);\r\n    Option descriptionOption = Option.builder(\"description\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(descriptionOption);\r\n    Option scanPeriodOption = Option.builder(\"scanPeriod\").hasArg(true).required(false).build();\r\n    commandLineOptions.addOption(scanPeriodOption);\r\n    CommandLineParser parser = new DefaultParser();\r\n    HelpFormatter formatter = new HelpFormatter();\r\n    CommandLine cmd;\r\n    try {\r\n        cmd = parser.parse(commandLineOptions, args);\r\n    } catch (ParseException e) {\r\n        System.out.println(e.getMessage());\r\n        formatter.printHelp(DeIdentification.class.getName(), commandLineOptions);\r\n        System.exit(1);\r\n        return;\r\n    }\r\n    String projectId = cmd.getOptionValue(projectIdOption.getOpt(), ServiceOptions.getDefaultProjectId());\r\n    if (cmd.hasOption(\"c\")) {\r\n        Likelihood minLikelihood = Likelihood.valueOf(cmd.getOptionValue(minLikelihoodOption.getOpt(), Likelihood.LIKELIHOOD_UNSPECIFIED.name()));\r\n        int maxFindings = Integer.parseInt(cmd.getOptionValue(maxFindingsOption.getOpt(), \"0\"));\r\n        String triggerId = cmd.getOptionValue(triggerIdOption.getOpt());\r\n        String displayName = cmd.getOptionValue(displayNameOption.getOpt(), \"\");\r\n        String description = cmd.getOptionValue(descriptionOption.getOpt(), \"\");\r\n        String bucketName = cmd.getOptionValue(bucketNameOption.getOpt());\r\n        String fileName = cmd.getOptionValue(gcsFileNameOption.getOpt());\r\n        boolean autoPopulateTimespan = Boolean.valueOf(cmd.getOptionValue(autoPopulateTimespanOption.getOpt()));\r\n        int scanPeriod = Integer.valueOf(cmd.getOptionValue(scanPeriodOption.getOpt()));\r\n        List<InfoType> infoTypesList = new ArrayList();\r\n        if (cmd.hasOption(infoTypesOption.getOpt())) {\r\n            infoTypesList = new ArrayList();\r\n            String[] infoTypes = cmd.getOptionValues(infoTypesOption.getOpt());\r\n            for (String infoType : infoTypes) {\r\n                infoTypesList.add(InfoType.newBuilder().setName(infoType).build());\r\n            }\r\n        }\r\n        createTrigger(triggerId, displayName, description, bucketName, fileName, autoPopulateTimespan, scanPeriod, infoTypesList, minLikelihood, maxFindings, projectId);\r\n    } else if (cmd.hasOption(\"l\")) {\r\n        listTriggers(projectId);\r\n    } else if (cmd.hasOption(\"d\")) {\r\n        String triggerId = cmd.getOptionValue(triggerIdOption.getOpt());\r\n        deleteTrigger(projectId, triggerId);\r\n    }\r\n}"
}, {
	"Path": "com.example.video.Detect.main",
	"Comment": "detects labels, shots, and explicit content in a video using the video intelligence api",
	"Method": "void main(String[] args){\r\n    try {\r\n        argsHelper(args);\r\n    } catch (Exception e) {\r\n        System.out.println(\"Exception while running:\\n\" + e.getMessage() + \"\\n\");\r\n        e.printStackTrace(System.out);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfSignatureAppearance.setAcro6Layers",
	"Comment": "acrobat 6.0 and higher recommends that only layer n0 and n2 be present.use this method with value false if you want to ignore this recommendation.",
	"Method": "void setAcro6Layers(boolean acro6Layers){\r\n    this.acro6Layers = acro6Layers;\r\n}"
}, {
	"Path": "software.amazon.ion.util.Equivalence.ionEqualsByContent",
	"Comment": "checks for structural data equivalence over two ion values. that is,equivalence without considering any annotations.",
	"Method": "boolean ionEqualsByContent(IonValue v1,IonValue v2){\r\n    return ionEqualsImpl(v1, v2, false);\r\n}"
}, {
	"Path": "software.amazon.ion.Timestamp.getZFractionalSecond",
	"Comment": "returns the fractional second of this timestamp.fractional seconds are not affected by local offsets.",
	"Method": "BigDecimal getZFractionalSecond(){\r\n    return this._fraction;\r\n}"
}, {
	"Path": "br.com.leonardoz.features.collections.UsingSynchronizedCollections.insertIfAbsentUnsafe",
	"Comment": "you can have duplicates. try to run multiple times and see the diff in\tresults",
	"Method": "void insertIfAbsentUnsafe(Vector<Long> list,Long value){\r\n    boolean contains = list.contains(value);\r\n    if (!contains) {\r\n        list.add(value);\r\n        System.out.println(\"Value added: \" + value);\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.contacts.Contact.mixFriction",
	"Comment": "friction mixing law. the idea is to allow either fixture to drive the restitution to zero. forexample, anything slides on ice.",
	"Method": "float mixFriction(float friction1,float friction2){\r\n    return MathUtils.sqrt(friction1 * friction2);\r\n}"
}, {
	"Path": "com.structurizr.view.ElementStyle.setDescription",
	"Comment": "sets whether the element description should be shown or not.",
	"Method": "void setDescription(Boolean description){\r\n    this.description = description;\r\n}"
}, {
	"Path": "com.itextpdf.text.Jpeg.processParameters",
	"Comment": "this method checks if the image is a valid jpeg and processes some parameters.",
	"Method": "void processParameters(){\r\n    type = JPEG;\r\n    originalType = ORIGINAL_JPEG;\r\n    InputStream is = null;\r\n    try {\r\n        String errorID;\r\n        if (rawData == null) {\r\n            is = url.openStream();\r\n            errorID = url.toString();\r\n        } else {\r\n            is = new java.io.ByteArrayInputStream(rawData);\r\n            errorID = \"Byte array\";\r\n        }\r\n        if (is.read() != 0xFF || is.read() != 0xD8) {\r\n            throw new BadElementException(MessageLocalization.getComposedMessage(\"1.is.not.a.valid.jpeg.file\", errorID));\r\n        }\r\n        boolean firstPass = true;\r\n        int len;\r\n        while (true) {\r\n            int v = is.read();\r\n            if (v < 0)\r\n                throw new IOException(MessageLocalization.getComposedMessage(\"premature.eof.while.reading.jpg\"));\r\n            if (v == 0xFF) {\r\n                int marker = is.read();\r\n                if (firstPass && marker == M_APP0) {\r\n                    firstPass = false;\r\n                    len = getShort(is);\r\n                    if (len < 16) {\r\n                        Utilities.skip(is, len - 2);\r\n                        continue;\r\n                    }\r\n                    byte[] bcomp = new byte[JFIF_ID.length];\r\n                    int r = is.read(bcomp);\r\n                    if (r != bcomp.length)\r\n                        throw new BadElementException(MessageLocalization.getComposedMessage(\"1.corrupted.jfif.marker\", errorID));\r\n                    boolean found = true;\r\n                    for (int k = 0; k < bcomp.length; ++k) {\r\n                        if (bcomp[k] != JFIF_ID[k]) {\r\n                            found = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!found) {\r\n                        Utilities.skip(is, len - 2 - bcomp.length);\r\n                        continue;\r\n                    }\r\n                    Utilities.skip(is, 2);\r\n                    int units = is.read();\r\n                    int dx = getShort(is);\r\n                    int dy = getShort(is);\r\n                    if (units == 1) {\r\n                        dpiX = dx;\r\n                        dpiY = dy;\r\n                    } else if (units == 2) {\r\n                        dpiX = (int) (dx * 2.54f + 0.5f);\r\n                        dpiY = (int) (dy * 2.54f + 0.5f);\r\n                    }\r\n                    Utilities.skip(is, len - 2 - bcomp.length - 7);\r\n                    continue;\r\n                }\r\n                if (marker == M_APPE) {\r\n                    len = getShort(is) - 2;\r\n                    byte[] byteappe = new byte[len];\r\n                    for (int k = 0; k < len; ++k) {\r\n                        byteappe[k] = (byte) is.read();\r\n                    }\r\n                    if (byteappe.length >= 12) {\r\n                        String appe = new String(byteappe, 0, 5, \"ISO-8859-1\");\r\n                        if (appe.equals(\"Adobe\")) {\r\n                            invert = true;\r\n                        }\r\n                    }\r\n                    continue;\r\n                }\r\n                if (marker == M_APP2) {\r\n                    len = getShort(is) - 2;\r\n                    byte[] byteapp2 = new byte[len];\r\n                    for (int k = 0; k < len; ++k) {\r\n                        byteapp2[k] = (byte) is.read();\r\n                    }\r\n                    if (byteapp2.length >= 14) {\r\n                        String app2 = new String(byteapp2, 0, 11, \"ISO-8859-1\");\r\n                        if (app2.equals(\"ICC_PROFILE\")) {\r\n                            int order = byteapp2[12] & 0xff;\r\n                            int count = byteapp2[13] & 0xff;\r\n                            if (order < 1)\r\n                                order = 1;\r\n                            if (count < 1)\r\n                                count = 1;\r\n                            if (icc == null)\r\n                                icc = new byte[count][];\r\n                            icc[order - 1] = byteapp2;\r\n                        }\r\n                    }\r\n                    continue;\r\n                }\r\n                if (marker == M_APPD) {\r\n                    len = getShort(is) - 2;\r\n                    byte[] byteappd = new byte[len];\r\n                    for (int k = 0; k < len; k++) {\r\n                        byteappd[k] = (byte) is.read();\r\n                    }\r\n                    int k = 0;\r\n                    for (k = 0; k < len - PS_8BIM_RESO.length; k++) {\r\n                        boolean found = true;\r\n                        for (int j = 0; j < PS_8BIM_RESO.length; j++) {\r\n                            if (byteappd[k + j] != PS_8BIM_RESO[j]) {\r\n                                found = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (found)\r\n                            break;\r\n                    }\r\n                    k += PS_8BIM_RESO.length;\r\n                    if (k < len - PS_8BIM_RESO.length) {\r\n                        byte namelength = byteappd[k];\r\n                        namelength++;\r\n                        if (namelength % 2 == 1)\r\n                            namelength++;\r\n                        k += namelength;\r\n                        int resosize = (byteappd[k] << 24) + (byteappd[k + 1] << 16) + (byteappd[k + 2] << 8) + byteappd[k + 3];\r\n                        if (resosize != 16) {\r\n                            continue;\r\n                        }\r\n                        k += 4;\r\n                        int dx = (byteappd[k] << 8) + (byteappd[k + 1] & 0xff);\r\n                        k += 2;\r\n                        k += 2;\r\n                        int unitsx = (byteappd[k] << 8) + (byteappd[k + 1] & 0xff);\r\n                        k += 2;\r\n                        k += 2;\r\n                        int dy = (byteappd[k] << 8) + (byteappd[k + 1] & 0xff);\r\n                        k += 2;\r\n                        k += 2;\r\n                        int unitsy = (byteappd[k] << 8) + (byteappd[k + 1] & 0xff);\r\n                        if (unitsx == 1 || unitsx == 2) {\r\n                            dx = (unitsx == 2 ? (int) (dx * 2.54f + 0.5f) : dx);\r\n                            if (dpiX != 0 && dpiX != dx) {\r\n                            } else\r\n                                dpiX = dx;\r\n                        }\r\n                        if (unitsy == 1 || unitsy == 2) {\r\n                            dy = (unitsy == 2 ? (int) (dy * 2.54f + 0.5f) : dy);\r\n                            if (dpiY != 0 && dpiY != dy) {\r\n                            } else\r\n                                dpiY = dy;\r\n                        }\r\n                    }\r\n                    continue;\r\n                }\r\n                firstPass = false;\r\n                int markertype = marker(marker);\r\n                if (markertype == VALID_MARKER) {\r\n                    Utilities.skip(is, 2);\r\n                    if (is.read() != 0x08) {\r\n                        throw new BadElementException(MessageLocalization.getComposedMessage(\"1.must.have.8.bits.per.component\", errorID));\r\n                    }\r\n                    scaledHeight = getShort(is);\r\n                    setTop(scaledHeight);\r\n                    scaledWidth = getShort(is);\r\n                    setRight(scaledWidth);\r\n                    colorspace = is.read();\r\n                    bpc = 8;\r\n                    break;\r\n                } else if (markertype == UNSUPPORTED_MARKER) {\r\n                    throw new BadElementException(MessageLocalization.getComposedMessage(\"1.unsupported.jpeg.marker.2\", errorID, String.valueOf(marker)));\r\n                } else if (markertype != NOPARAM_MARKER) {\r\n                    Utilities.skip(is, getShort(is) - 2);\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        if (is != null) {\r\n            is.close();\r\n        }\r\n    }\r\n    plainWidth = getWidth();\r\n    plainHeight = getHeight();\r\n    if (icc != null) {\r\n        int total = 0;\r\n        for (int k = 0; k < icc.length; ++k) {\r\n            if (icc[k] == null) {\r\n                icc = null;\r\n                return;\r\n            }\r\n            total += icc[k].length - 14;\r\n        }\r\n        byte[] ficc = new byte[total];\r\n        total = 0;\r\n        for (int k = 0; k < icc.length; ++k) {\r\n            System.arraycopy(icc[k], 14, ficc, total, icc[k].length - 14);\r\n            total += icc[k].length - 14;\r\n        }\r\n        try {\r\n            ICC_Profile icc_prof = ICC_Profile.getInstance(ficc, colorspace);\r\n            tagICC(icc_prof);\r\n        } catch (IllegalArgumentException e) {\r\n        }\r\n        icc = null;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.consolidateNamedDestinations",
	"Comment": "replaces all the local named links with the actual destinations.",
	"Method": "void consolidateNamedDestinations(){\r\n    if (consolidateNamedDestinations)\r\n        return;\r\n    consolidateNamedDestinations = true;\r\n    HashMap<Object, PdfObject> names = getNamedDestination(true);\r\n    if (names.isEmpty())\r\n        return;\r\n    for (int k = 1; k <= pageRefs.size(); ++k) {\r\n        PdfDictionary page = pageRefs.getPageN(k);\r\n        PdfObject annotsRef;\r\n        PdfArray annots = (PdfArray) getPdfObject(annotsRef = page.get(PdfName.ANNOTS));\r\n        int annotIdx = lastXrefPartial;\r\n        releaseLastXrefPartial();\r\n        if (annots == null) {\r\n            pageRefs.releasePage(k);\r\n            continue;\r\n        }\r\n        boolean commitAnnots = false;\r\n        for (int an = 0; an < annots.size(); ++an) {\r\n            PdfObject objRef = annots.getPdfObject(an);\r\n            if (replaceNamedDestination(objRef, names) && !objRef.isIndirect())\r\n                commitAnnots = true;\r\n        }\r\n        if (commitAnnots)\r\n            setXrefPartialObject(annotIdx, annots);\r\n        if (!commitAnnots || annotsRef.isIndirect())\r\n            pageRefs.releasePage(k);\r\n    }\r\n    PdfDictionary outlines = (PdfDictionary) getPdfObjectRelease(catalog.get(PdfName.OUTLINES));\r\n    if (outlines == null)\r\n        return;\r\n    iterateBookmarks(outlines.get(PdfName.FIRST), names);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStamper.getSignatureAppearance",
	"Comment": "gets the signing instance. the appearances and other parameters can the be set.",
	"Method": "PdfSignatureAppearance getSignatureAppearance(){\r\n    return sigApp;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfChunk.getImageScalePercentage",
	"Comment": "returns a scalepercentage in case the image needs to be scaled.",
	"Method": "float getImageScalePercentage(){\r\n    return imageScalePercentage;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDocument.carriageReturn",
	"Comment": "if the current line is not empty or null, it is added to the arraylistof lines and a new empty line is added.",
	"Method": "void carriageReturn(){\r\n    if (lines == null) {\r\n        lines = new ArrayList<PdfLine>();\r\n    }\r\n    if (line != null && line.size() > 0) {\r\n        if (currentHeight + calculateLineHeight() > indentTop() - indentBottom()) {\r\n            if (currentHeight != 0) {\r\n                PdfLine overflowLine = line;\r\n                line = null;\r\n                newPage();\r\n                line = overflowLine;\r\n                overflowLine.left = indentLeft();\r\n            }\r\n        }\r\n        currentHeight += line.height();\r\n        lines.add(line);\r\n        pageEmpty = false;\r\n    }\r\n    if (imageEnd > -1 && currentHeight > imageEnd) {\r\n        imageEnd = -1;\r\n        indentation.imageIndentRight = 0;\r\n        indentation.imageIndentLeft = 0;\r\n    }\r\n    line = new PdfLine(indentLeft(), indentRight(), alignment, leading);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.pdfcleanup.PdfCleanUpProcessor.cleanUp",
	"Comment": "cleans the document by erasing all the areas which are either provided orextracted from redaction annotations.",
	"Method": "void cleanUp(){\r\n    for (Map.Entry<Integer, List<PdfCleanUpLocation>> entry : pdfCleanUpLocations.entrySet()) {\r\n        cleanUpPage(entry.getKey(), entry.getValue());\r\n    }\r\n    pdfStamper.getReader().removeUnusedObjects();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.createFont",
	"Comment": "creates a font based on an existing document font. the created font font may notbehave as expected, depending on the encoding or subset.",
	"Method": "BaseFont createFont(BaseFont createFont,String name,String encoding,boolean embedded,BaseFont createFont,String name,String encoding,boolean embedded,boolean forceRead,BaseFont createFont,String name,String encoding,boolean embedded,boolean cached,byte ttfAfm,byte pfb,BaseFont createFont,String name,String encoding,boolean embedded,boolean cached,byte ttfAfm,byte pfb,boolean noThrow,BaseFont createFont,String name,String encoding,boolean embedded,boolean cached,byte ttfAfm,byte pfb,boolean noThrow,boolean forceRead,BaseFont createFont,PRIndirectReference fontRef){\r\n    return new DocumentFont(fontRef);\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPNormalizer.deleteEmptySchemas",
	"Comment": "remove all empty schemas from the metadata tree that were generated during the rdf parsing.",
	"Method": "void deleteEmptySchemas(XMPNode tree){\r\n    for (Iterator it = tree.iterateChildren(); it.hasNext(); ) {\r\n        XMPNode schema = (XMPNode) it.next();\r\n        if (!schema.hasChildren()) {\r\n            it.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.Rectangle.softCloneNonPositionParameters",
	"Comment": "copies each of the parameters, except the position, from a\trectangle object if the value is set there",
	"Method": "void softCloneNonPositionParameters(Rectangle rect){\r\n    if (rect.rotation != 0)\r\n        this.rotation = rect.rotation;\r\n    if (rect.backgroundColor != null)\r\n        this.backgroundColor = rect.backgroundColor;\r\n    if (rect.border != UNDEFINED)\r\n        this.border = rect.border;\r\n    if (useVariableBorders)\r\n        this.useVariableBorders = rect.useVariableBorders;\r\n    if (rect.borderWidth != UNDEFINED)\r\n        this.borderWidth = rect.borderWidth;\r\n    if (rect.borderWidthLeft != UNDEFINED)\r\n        this.borderWidthLeft = rect.borderWidthLeft;\r\n    if (rect.borderWidthRight != UNDEFINED)\r\n        this.borderWidthRight = rect.borderWidthRight;\r\n    if (rect.borderWidthTop != UNDEFINED)\r\n        this.borderWidthTop = rect.borderWidthTop;\r\n    if (rect.borderWidthBottom != UNDEFINED)\r\n        this.borderWidthBottom = rect.borderWidthBottom;\r\n    if (rect.borderColor != null)\r\n        this.borderColor = rect.borderColor;\r\n    if (rect.borderColorLeft != null)\r\n        this.borderColorLeft = rect.borderColorLeft;\r\n    if (rect.borderColorRight != null)\r\n        this.borderColorRight = rect.borderColorRight;\r\n    if (rect.borderColorTop != null)\r\n        this.borderColorTop = rect.borderColorTop;\r\n    if (rect.borderColorBottom != null)\r\n        this.borderColorBottom = rect.borderColorBottom;\r\n}"
}, {
	"Path": "software.amazon.ion.Timestamp.withLocalOffset",
	"Comment": "returns a timestamp at the same point in time, but with the given localoffset.if this timestamp has precision coarser than minutes, then itis returned unchanged since such timestamps always have an unknownoffset.",
	"Method": "Timestamp withLocalOffset(Integer offset){\r\n    Precision precision = getPrecision();\r\n    if (precision.alwaysUnknownOffset() || safeEquals(offset, getLocalOffset())) {\r\n        return this;\r\n    }\r\n    Timestamp ts = createFromUtcFields(precision, getZYear(), getZMonth(), getZDay(), getZHour(), getZMinute(), getZSecond(), getZFractionalSecond(), offset);\r\n    return ts;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.AcroFields.setField",
	"Comment": "sets the field value and the display string. the display stringis used to build the appearance in the cases where the valueis modified by acrobat with javascript and the algorithm isknown.",
	"Method": "boolean setField(String name,String value,boolean setField,String name,String value,boolean saveAppearance,boolean setField,String name,String value,String display,boolean setField,String name,String value,String display,boolean saveAppearance){\r\n    if (writer == null)\r\n        throw new DocumentException(MessageLocalization.getComposedMessage(\"this.acrofields.instance.is.read.only\"));\r\n    if (xfa.isXfaPresent()) {\r\n        name = xfa.findFieldName(name, this);\r\n        if (name == null)\r\n            return false;\r\n        String shortName = XfaForm.Xml2Som.getShortName(name);\r\n        Node xn = xfa.findDatasetsNode(shortName);\r\n        if (xn == null) {\r\n            xn = xfa.getDatasetsSom().insertNode(xfa.getDatasetsNode(), shortName);\r\n        }\r\n        xfa.setNodeText(xn, value);\r\n    }\r\n    Item item = fields.get(name);\r\n    if (item == null)\r\n        return false;\r\n    PdfDictionary merged = item.getMerged(0);\r\n    PdfName type = merged.getAsName(PdfName.FT);\r\n    if (PdfName.TX.equals(type)) {\r\n        PdfNumber maxLen = merged.getAsNumber(PdfName.MAXLEN);\r\n        int len = 0;\r\n        if (maxLen != null)\r\n            len = maxLen.intValue();\r\n        if (len > 0)\r\n            value = value.substring(0, Math.min(len, value.length()));\r\n    }\r\n    if (display == null)\r\n        display = value;\r\n    if (PdfName.TX.equals(type) || PdfName.CH.equals(type)) {\r\n        PdfString v = new PdfString(value, PdfObject.TEXT_UNICODE);\r\n        for (int idx = 0; idx < item.size(); ++idx) {\r\n            PdfDictionary valueDic = item.getValue(idx);\r\n            valueDic.put(PdfName.V, v);\r\n            valueDic.remove(PdfName.I);\r\n            markUsed(valueDic);\r\n            merged = item.getMerged(idx);\r\n            merged.remove(PdfName.I);\r\n            merged.put(PdfName.V, v);\r\n            PdfDictionary widget = item.getWidget(idx);\r\n            if (generateAppearances) {\r\n                PdfAppearance app = getAppearance(merged, display, name);\r\n                if (PdfName.CH.equals(type)) {\r\n                    PdfNumber n = new PdfNumber(topFirst);\r\n                    widget.put(PdfName.TI, n);\r\n                    merged.put(PdfName.TI, n);\r\n                }\r\n                PdfDictionary appDic = widget.getAsDict(PdfName.AP);\r\n                if (appDic == null) {\r\n                    appDic = new PdfDictionary();\r\n                    widget.put(PdfName.AP, appDic);\r\n                    merged.put(PdfName.AP, appDic);\r\n                }\r\n                appDic.put(PdfName.N, app.getIndirectReference());\r\n                writer.releaseTemplate(app);\r\n            } else {\r\n                widget.remove(PdfName.AP);\r\n                merged.remove(PdfName.AP);\r\n            }\r\n            markUsed(widget);\r\n        }\r\n        return true;\r\n    } else if (PdfName.BTN.equals(type)) {\r\n        PdfNumber ff = item.getMerged(0).getAsNumber(PdfName.FF);\r\n        int flags = 0;\r\n        if (ff != null)\r\n            flags = ff.intValue();\r\n        if ((flags & PdfFormField.FF_PUSHBUTTON) != 0) {\r\n            Image img;\r\n            try {\r\n                img = Image.getInstance(Base64.decode(value));\r\n            } catch (Exception e) {\r\n                return false;\r\n            }\r\n            PushbuttonField pb = getNewPushbuttonFromField(name);\r\n            pb.setImage(img);\r\n            replacePushbuttonField(name, pb.getField());\r\n            return true;\r\n        }\r\n        PdfName v = new PdfName(value);\r\n        ArrayList<String> lopt = new ArrayList<String>();\r\n        PdfArray opts = item.getValue(0).getAsArray(PdfName.OPT);\r\n        if (opts != null) {\r\n            for (int k = 0; k < opts.size(); ++k) {\r\n                PdfString valStr = opts.getAsString(k);\r\n                if (valStr != null)\r\n                    lopt.add(valStr.toUnicodeString());\r\n                else\r\n                    lopt.add(null);\r\n            }\r\n        }\r\n        int vidx = lopt.indexOf(value);\r\n        PdfName vt;\r\n        if (vidx >= 0)\r\n            vt = new PdfName(String.valueOf(vidx));\r\n        else\r\n            vt = v;\r\n        for (int idx = 0; idx < item.size(); ++idx) {\r\n            merged = item.getMerged(idx);\r\n            PdfDictionary widget = item.getWidget(idx);\r\n            PdfDictionary valDict = item.getValue(idx);\r\n            markUsed(item.getValue(idx));\r\n            valDict.put(PdfName.V, vt);\r\n            merged.put(PdfName.V, vt);\r\n            markUsed(widget);\r\n            PdfDictionary appDic = widget.getAsDict(PdfName.AP);\r\n            if (appDic == null)\r\n                return false;\r\n            PdfDictionary normal = appDic.getAsDict(PdfName.N);\r\n            if (isInAP(normal, vt) || normal == null) {\r\n                merged.put(PdfName.AS, vt);\r\n                widget.put(PdfName.AS, vt);\r\n            } else {\r\n                merged.put(PdfName.AS, PdfName.Off);\r\n                widget.put(PdfName.AS, PdfName.Off);\r\n            }\r\n            if (generateAppearances && !saveAppearance) {\r\n                PdfAppearance app = getAppearance(merged, display, name);\r\n                if (normal != null)\r\n                    normal.put(merged.getAsName(PdfName.AS), app.getIndirectReference());\r\n                else\r\n                    appDic.put(PdfName.N, app.getIndirectReference());\r\n                writer.releaseTemplate(app);\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.jbake.parser.Engines.tryLoadEngine",
	"Comment": "this method is used to search for a specific class, telling if loading the engine would succeed. this istypically used to avoid loading optional modules.",
	"Method": "ParserEngine tryLoadEngine(String engineClassName){\r\n    try {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Class<? extends ParserEngine> engineClass = (Class<? extends ParserEngine>) Class.forName(engineClassName, false, Engines.class.getClassLoader());\r\n        return engineClass.getDeclaredConstructor().newInstance();\r\n    } catch (ClassNotFoundException | NoClassDefFoundError | IllegalAccessException | InstantiationException e) {\r\n        return new ErrorEngine(engineClassName);\r\n    } catch (NoSuchMethodException | InvocationTargetException e) {\r\n        LOGGER.error(\"unable to instantiate ParserEngine {}\", engineClassName);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.tokenizer.Word.hashCode",
	"Comment": "rewrite the hash code generate algorithmtake the value as the main factor",
	"Method": "int hashCode(){\r\n    if (h == -1) {\r\n        h = 5381;\r\n        for (int j = 0; j < value.length(); j++) {\r\n            h = h * 33 ^ value.charAt(j);\r\n        }\r\n        h &= 0x7FFFFFFF;\r\n    }\r\n    return h;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseField.setBorderWidth",
	"Comment": "sets the border width in points. to eliminate the borderset the border color to null.",
	"Method": "void setBorderWidth(float borderWidth){\r\n    this.borderWidth = borderWidth;\r\n}"
}, {
	"Path": "com.structurizr.io.json.JsonReader.read",
	"Comment": "reads and parses a workspace definition from a json document.",
	"Method": "Workspace read(Reader reader){\r\n    try {\r\n        ObjectMapper objectMapper = new ObjectMapper();\r\n        objectMapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\r\n        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\r\n        Workspace workspace = objectMapper.readValue(reader, Workspace.class);\r\n        workspace.hydrate();\r\n        return workspace;\r\n    } catch (IOException ioe) {\r\n        throw new WorkspaceReaderException(\"Could not read JSON\", ioe);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDictionary.getAsName",
	"Comment": "returns a pdfobject as a pdfname,resolving indirect references.the object associated with the pdfname given is retrievedand resolved to a direct object.if it is a pdfname, it is cast down and returned as such.otherwise null is returned.",
	"Method": "PdfName getAsName(PdfName key){\r\n    PdfName name = null;\r\n    PdfObject orig = getDirectObject(key);\r\n    if (orig != null && orig.isName())\r\n        name = (PdfName) orig;\r\n    return name;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.hyphenation.TernaryTree.insertBalanced",
	"Comment": "recursively insert the median first and then the median of thelower and upper halves, and so on in order to get a balancedtree. the array of keys is assumed to be sorted in ascendingorder.",
	"Method": "void insertBalanced(String[] k,char[] v,int offset,int n){\r\n    int m;\r\n    if (n < 1) {\r\n        return;\r\n    }\r\n    m = n >> 1;\r\n    insert(k[m + offset], v[m + offset]);\r\n    insertBalanced(k, v, offset, m);\r\n    insertBalanced(k, v, offset + m + 1, n - m - 1);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.SimpleBookmark.exportToXMLNode",
	"Comment": "exports the bookmarks to xml. only of use if the generation is to be include insome other xml document.",
	"Method": "void exportToXMLNode(List<HashMap<String, Object>> list,Writer out,int indent,boolean onlyASCII){\r\n    String dep = \"\";\r\n    if (indent != -1) {\r\n        for (int k = 0; k < indent; ++k) dep += \"  \";\r\n    }\r\n    for (HashMap<String, Object> map : list) {\r\n        String title = null;\r\n        out.write(dep);\r\n        out.write(\"<Title \");\r\n        List<HashMap<String, Object>> kids = null;\r\n        for (Map.Entry<String, Object> entry : map.entrySet()) {\r\n            String key = entry.getKey();\r\n            if (key.equals(\"Title\")) {\r\n                title = (String) entry.getValue();\r\n                continue;\r\n            } else if (key.equals(\"Kids\")) {\r\n                kids = (List<HashMap<String, Object>>) entry.getValue();\r\n                continue;\r\n            } else {\r\n                out.write(key);\r\n                out.write(\"=\\\"\");\r\n                String value = (String) entry.getValue();\r\n                if (key.equals(\"Named\") || key.equals(\"NamedN\"))\r\n                    value = SimpleNamedDestination.escapeBinaryString(value);\r\n                out.write(XMLUtil.escapeXML(value, onlyASCII));\r\n                out.write(\"\\\" \");\r\n            }\r\n        }\r\n        out.write(\">\");\r\n        if (title == null)\r\n            title = \"\";\r\n        out.write(XMLUtil.escapeXML(title, onlyASCII));\r\n        if (kids != null) {\r\n            out.write(\"\\n\");\r\n            exportToXMLNode(kids, out, indent == -1 ? indent : indent + 1, onlyASCII);\r\n            out.write(dep);\r\n        }\r\n        out.write(\"<\/Title>\\n\");\r\n    }\r\n}"
}, {
	"Path": "com.structurizr.api.StructurizrClient.setMergeFromRemote",
	"Comment": "specifies whether the layout of diagrams from a remote workspace should be retained when puttinga new version of the workspace.",
	"Method": "void setMergeFromRemote(boolean mergeFromRemote){\r\n    this.mergeFromRemote = mergeFromRemote;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.PdfContentStreamProcessor.endMarkedContent",
	"Comment": "remove the latest marked content from the stack.keeps track of the bmc, bdc and emc operators.",
	"Method": "void endMarkedContent(){\r\n    markedContentStack.pop();\r\n}"
}, {
	"Path": "software.amazon.ion.ContainerTestCase.testClearContainer",
	"Comment": "clears a container and verifies that it is not a nullvalue, it is empty, its size is 0, and that it has no iterablecontained values.",
	"Method": "void testClearContainer(IonContainer container){\r\n    container.clear();\r\n    assertFalse(container.isNullValue());\r\n    assertTrue(container.isEmpty());\r\n    assertEquals(container.size(), 0);\r\n    assertFalse(container.iterator().hasNext());\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Barcode39.getCode39Ex",
	"Comment": "converts the extended text into a normal, escaped text,ready to generate bars.",
	"Method": "String getCode39Ex(String text){\r\n    StringBuilder out = new StringBuilder(\"\");\r\n    for (int k = 0; k < text.length(); ++k) {\r\n        char c = text.charAt(k);\r\n        if (c > 127)\r\n            throw new IllegalArgumentException(MessageLocalization.getComposedMessage(\"the.character.1.is.illegal.in.code.39.extended\", c));\r\n        char c1 = EXTENDED.charAt(c * 2);\r\n        char c2 = EXTENDED.charAt(c * 2 + 1);\r\n        if (c1 != ' ')\r\n            out.append(c1);\r\n        out.append(c2);\r\n    }\r\n    return out.toString();\r\n}"
}, {
	"Path": "com.structurizr.io.json.JsonWriter.write",
	"Comment": "writes a workspace definition as a json string to the specified writer object.",
	"Method": "void write(Workspace workspace,Writer writer){\r\n    if (workspace == null) {\r\n        throw new IllegalArgumentException(\"Workspace cannot be null.\");\r\n    }\r\n    if (writer == null) {\r\n        throw new IllegalArgumentException(\"Writer cannot be null.\");\r\n    }\r\n    try {\r\n        ObjectMapper objectMapper = new ObjectMapper();\r\n        if (indentOutput) {\r\n            objectMapper.enable(SerializationFeature.INDENT_OUTPUT);\r\n        }\r\n        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\r\n        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);\r\n        objectMapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\r\n        objectMapper.setDateFormat(new ISO8601DateFormat());\r\n        writer.write(objectMapper.writeValueAsString(workspace));\r\n    } catch (IOException ioe) {\r\n        throw new WorkspaceWriterException(\"Could not write as JSON\", ioe);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.internal.PdfViewerPreferencesImp.setViewerPreferences",
	"Comment": "sets the viewer preferences as the sum of several constants.",
	"Method": "void setViewerPreferences(int preferences){\r\n    this.pageLayoutAndMode |= preferences;\r\n    if ((preferences & viewerPreferencesMask) != 0) {\r\n        pageLayoutAndMode = ~viewerPreferencesMask & pageLayoutAndMode;\r\n        if ((preferences & PdfWriter.HideToolbar) != 0)\r\n            viewerPreferences.put(PdfName.HIDETOOLBAR, PdfBoolean.PDFTRUE);\r\n        if ((preferences & PdfWriter.HideMenubar) != 0)\r\n            viewerPreferences.put(PdfName.HIDEMENUBAR, PdfBoolean.PDFTRUE);\r\n        if ((preferences & PdfWriter.HideWindowUI) != 0)\r\n            viewerPreferences.put(PdfName.HIDEWINDOWUI, PdfBoolean.PDFTRUE);\r\n        if ((preferences & PdfWriter.FitWindow) != 0)\r\n            viewerPreferences.put(PdfName.FITWINDOW, PdfBoolean.PDFTRUE);\r\n        if ((preferences & PdfWriter.CenterWindow) != 0)\r\n            viewerPreferences.put(PdfName.CENTERWINDOW, PdfBoolean.PDFTRUE);\r\n        if ((preferences & PdfWriter.DisplayDocTitle) != 0)\r\n            viewerPreferences.put(PdfName.DISPLAYDOCTITLE, PdfBoolean.PDFTRUE);\r\n        if ((preferences & PdfWriter.NonFullScreenPageModeUseNone) != 0)\r\n            viewerPreferences.put(PdfName.NONFULLSCREENPAGEMODE, PdfName.USENONE);\r\n        else if ((preferences & PdfWriter.NonFullScreenPageModeUseOutlines) != 0)\r\n            viewerPreferences.put(PdfName.NONFULLSCREENPAGEMODE, PdfName.USEOUTLINES);\r\n        else if ((preferences & PdfWriter.NonFullScreenPageModeUseThumbs) != 0)\r\n            viewerPreferences.put(PdfName.NONFULLSCREENPAGEMODE, PdfName.USETHUMBS);\r\n        else if ((preferences & PdfWriter.NonFullScreenPageModeUseOC) != 0)\r\n            viewerPreferences.put(PdfName.NONFULLSCREENPAGEMODE, PdfName.USEOC);\r\n        if ((preferences & PdfWriter.DirectionL2R) != 0)\r\n            viewerPreferences.put(PdfName.DIRECTION, PdfName.L2R);\r\n        else if ((preferences & PdfWriter.DirectionR2L) != 0)\r\n            viewerPreferences.put(PdfName.DIRECTION, PdfName.R2L);\r\n        if ((preferences & PdfWriter.PrintScalingNone) != 0)\r\n            viewerPreferences.put(PdfName.PRINTSCALING, PdfName.NONE);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfA1CheckerTest.pdfObjectCheck",
	"Comment": "this method is used in the pdfa2checkertest and pdfa3checkertest, too",
	"Method": "void pdfObjectCheck(String output,PdfAConformanceLevel level,boolean exceptionExpected){\r\n    Document document = new Document();\r\n    PdfAWriter writer = PdfAWriter.getInstance(document, new FileOutputStream(output), level);\r\n    writer.createXmpMetadata();\r\n    document.open();\r\n    Font font = FontFactory.getFont(\"./src/test/resources/com/itextpdf/text/pdf/FreeMonoBold.ttf\", BaseFont.WINANSI, BaseFont.EMBEDDED, 12);\r\n    document.add(new Paragraph(\"Hello World\", font));\r\n    ICC_Profile icc = ICC_Profile.getInstance(new FileInputStream(\"./src/test/resources/com/itextpdf/text/pdf/sRGB Color Space Profile.icm\"));\r\n    writer.setOutputIntents(\"Custom\", \"\", \"http://www.color.org\", \"sRGB IEC61966-2.1\", icc);\r\n    PdfArray array = new PdfArray();\r\n    for (int i = 0; i < 8192; i++) {\r\n        array.add(new PdfNull());\r\n    }\r\n    writer.getExtraCatalog().put(new PdfName(\"TestArray\"), array);\r\n    boolean exceptionThrown = false;\r\n    try {\r\n        document.close();\r\n    } catch (PdfAConformanceException e) {\r\n        if (e.getObject() == array)\r\n            exceptionThrown = true;\r\n    }\r\n    if (exceptionThrown != exceptionExpected) {\r\n        String error = exceptionExpected ? \"\" : \" not\";\r\n        error = String.format(\"PdfAConformanceException should%s be thrown.\", error);\r\n        Assert.fail(error);\r\n    }\r\n}"
}, {
	"Path": "com.machinepublishers.glass.ui.monocle.MonocleWindow.getNativeWindow",
	"Comment": "returns the handle used to create a rendering context in prism",
	"Method": "long getNativeWindow(){\r\n    return id;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaWindow.setPosition",
	"Comment": "sets a richmediaposition dictionary describing the position of the richmediawindow.",
	"Method": "void setPosition(RichMediaPosition position){\r\n    put(PdfName.POSITION, position);\r\n}"
}, {
	"Path": "software.amazon.ion.BinaryTest.ion",
	"Comment": "loads a string literal as ion bytes no cookie required.we encode the string literal as hex digits as it is convenient to read.",
	"Method": "IonValue ion(String hex){\r\n    return system().singleValue(hexToBytes(MAGIC_COOKIE + hex));\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.Tag.addChild",
	"Comment": "add a child tag to this tag. the given tags parent is set to this tag.",
	"Method": "void addChild(Tag t){\r\n    t.setParent(this);\r\n    this.children.add(t);\r\n}"
}, {
	"Path": "com.example.firestore.snippets.RetrieveDataSnippets.getQueryResults",
	"Comment": "return multiple documents from a collection based on a query.",
	"Method": "List<QueryDocumentSnapshot> getQueryResults(){\r\n    ApiFuture<QuerySnapshot> future = db.collection(\"cities\").whereEqualTo(\"capital\", true).get();\r\n    List<QueryDocumentSnapshot> documents = future.get().getDocuments();\r\n    for (DocumentSnapshot document : documents) {\r\n        System.out.println(document.getId() + \" => \" + document.toObject(City.class));\r\n    }\r\n    return documents;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.server.JcsegServer.init",
	"Comment": "initialize the server and register the basic context handler",
	"Method": "void init(){\r\n    QueuedThreadPool threadPool = new QueuedThreadPool();\r\n    threadPool.setMaxThreads(config.getMaxThreadPoolSize());\r\n    threadPool.setIdleTimeout(config.getThreadIdleTimeout());\r\n    server = new Server(threadPool);\r\n    HttpConfiguration http_config = new HttpConfiguration();\r\n    http_config.setOutputBufferSize(config.getOutputBufferSize());\r\n    http_config.setRequestHeaderSize(config.getRequestHeaderSize());\r\n    http_config.setResponseHeaderSize(config.getResponseHeaderSize());\r\n    http_config.setSendServerVersion(false);\r\n    http_config.setSendDateHeader(false);\r\n    ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(http_config));\r\n    connector.setPort(config.getPort());\r\n    connector.setHost(config.getHost());\r\n    connector.setIdleTimeout(config.getHttpIdleTimeout());\r\n    server.addConnector(connector);\r\n}"
}, {
	"Path": "com.tozny.crypto.android.AesCbcWithIntegrity.saltString",
	"Comment": "converts the given salt into a base64 encoded string suitable forstorage.",
	"Method": "String saltString(byte[] salt){\r\n    return Base64.encodeToString(salt, BASE64_FLAGS);\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.util.ArrayUtil.endsWith",
	"Comment": "check if there is an element that ends with the specified string",
	"Method": "int endsWith(String str,String[] arr){\r\n    if (arr == null) {\r\n        return -1;\r\n    }\r\n    for (int i = 0; i < arr.length; i++) {\r\n        if (arr[i].endsWith(str)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONArray.optString",
	"Comment": "get the optional string associated with an index. the defaultvalue isreturned if the key is not found.",
	"Method": "String optString(int index,String optString,int index,String defaultValue){\r\n    Object object = this.opt(index);\r\n    return JSONObject.NULL.equals(object) ? defaultValue : object.toString();\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONArray.put",
	"Comment": "put or replace an object value in the jsonarray. if the index is greaterthan the length of the jsonarray, then null elements will be added asnecessary to pad it out.",
	"Method": "JSONArray put(boolean value,JSONArray put,Collection<Object> value,JSONArray put,double value,JSONArray put,int value,JSONArray put,long value,JSONArray put,Map<String, Object> value,JSONArray put,Object value,JSONArray put,int index,boolean value,JSONArray put,int index,Collection<Object> value,JSONArray put,int index,double value,JSONArray put,int index,int value,JSONArray put,int index,long value,JSONArray put,int index,Map<String, Object> value,JSONArray put,int index,Object value){\r\n    JSONObject.testValidity(value);\r\n    if (index < 0) {\r\n        throw new JSONException(\"JSONArray[\" + index + \"] not found.\");\r\n    }\r\n    if (index < this.length()) {\r\n        this.myArrayList.set(index, value);\r\n    } else {\r\n        while (index != this.length()) {\r\n            this.put(JSONObject.NULL);\r\n        }\r\n        this.put(value);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "software.amazon.ion.Timestamp.addMillis",
	"Comment": "returns a timestamp relative to this one by the given number ofmilliseconds.",
	"Method": "Timestamp addMillis(long amount){\r\n    if (amount == 0)\r\n        return this;\r\n    BigDecimal millis = make_localtime().getDecimalMillis();\r\n    millis = millis.add(BigDecimal.valueOf(amount));\r\n    Timestamp ts = new Timestamp(millis, _precision, _offset);\r\n    ts._fraction = _fraction;\r\n    if (_offset != null && _offset != 0) {\r\n        ts.apply_offset(_offset);\r\n    }\r\n    return ts;\r\n}"
}, {
	"Path": "com.example.bigquery.LabelsSample.labelDataset",
	"Comment": "add or modify a label on a dataset.see the bigquerydocumentation.",
	"Method": "void labelDataset(String projectId,String datasetId,String labelKey,String labelValue){\r\n    GoogleCredential credential = GoogleCredential.getApplicationDefault();\r\n    credential = credential.createScoped(Arrays.asList(\"https://www.googleapis.com/auth/bigquery\"));\r\n    credential.refreshToken();\r\n    String accessToken = credential.getAccessToken();\r\n    Dataset dataset = new Dataset();\r\n    dataset.addLabel(labelKey, labelValue);\r\n    HttpContent content = new JsonHttpContent(JSON_FACTORY, dataset);\r\n    String urlFormat = \"https://www.googleapis.com/bigquery/v2/projects/%s/datasets/%s\" + \"?fields=labels&access_token=%s\";\r\n    GenericUrl url = new GenericUrl(String.format(urlFormat, projectId, datasetId, accessToken));\r\n    HttpRequestFactory requestFactory = HTTP_TRANSPORT.createRequestFactory();\r\n    HttpRequest request = requestFactory.buildPostRequest(url, content);\r\n    request.setParser(JSON_FACTORY.createJsonObjectParser());\r\n    request.setHeaders(new HttpHeaders().set(\"X-HTTP-Method-Override\", \"PATCH\"));\r\n    HttpResponse response = request.execute();\r\n    if (response.getStatusCode() != 200) {\r\n        throw new RuntimeException(response.getStatusMessage());\r\n    }\r\n    Dataset responseDataset = response.parseAs(Dataset.class);\r\n    System.out.printf(\"Updated label \\\"%s\\\" with value \\\"%s\\\"\\n\", labelKey, responseDataset.getLabels().get(labelKey));\r\n}"
}, {
	"Path": "com.itextpdf.testutils.TestResourceUtils.dumpCurrentStackTrace",
	"Comment": "used to track down which tests are still doing things that should really be done only in development",
	"Method": "void dumpCurrentStackTrace(PrintStream out){\r\n    for (StackTraceElement e : Thread.currentThread().getStackTrace()) {\r\n        System.out.println(\"\\t\" + e);\r\n    }\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.util.ArrayUtil.contains",
	"Comment": "check if there is an element that contains the specified string",
	"Method": "int contains(String str,String[] arr){\r\n    if (arr == null) {\r\n        return -1;\r\n    }\r\n    for (int i = 0; i < arr.length; i++) {\r\n        if (arr[i].contains(str)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "software.amazon.ion.system.IonSystemBuilder.mutable",
	"Comment": "returns a mutable builder configured exactly like this one.",
	"Method": "IonSystemBuilder mutable(IonSystemBuilder mutable){\r\n    return copy();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.TrueTypeFont.setPostscriptFontName",
	"Comment": "sets the font name that will appear in the pdf font dictionary.use with care as it can easily make a font unreadable if not embedded.",
	"Method": "void setPostscriptFontName(String name){\r\n    fontName = name;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.table.KeepRowsTogetherTest.testKeepRowsTogetherInCombinationWithSkipFirstHeader",
	"Comment": "creates two tables. the second table has 1 header row and it should skip the first header. 1 line of table 2 should be on page 1, the rest on page 2.",
	"Method": "void testKeepRowsTogetherInCombinationWithSkipFirstHeader(){\r\n    final String file = \"withskipfirstheader.pdf\";\r\n    createDocument(file, 2, 10, \"Header for Table 2\", true, true);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.close",
	"Comment": "closes the reader, and any underlying stream or data source used to create the reader",
	"Method": "void close(){\r\n    try {\r\n        tokens.close();\r\n    } catch (IOException e) {\r\n        throw new ExceptionConverter(e);\r\n    }\r\n}"
}, {
	"Path": "software.amazon.ion.impl.IonWriterTestCase.reread",
	"Comment": "extracts bytes from the current writer and loads it into a datagram.",
	"Method": "IonReader reread(){\r\n    byte[] bytes = outputByteArray();\r\n    return system().newReader(bytes);\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.server.JcsegGlobalResource.removeTokonizerEntry",
	"Comment": "remove a tokenizer entry from tokenizer pool with specified name",
	"Method": "void removeTokonizerEntry(String name){\r\n    tokenizerPool.remove(name);\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.tokenizer.core.DictionaryFactory.createDefaultDictionary",
	"Comment": "create the adictionary according to the jcsegtaskconfigcheck and load the lexicon by default",
	"Method": "ADictionary createDefaultDictionary(JcsegTaskConfig config,boolean sync,boolean loadDic,ADictionary createDefaultDictionary,JcsegTaskConfig config,ADictionary createDefaultDictionary,JcsegTaskConfig config,boolean loadDic){\r\n    return createDefaultDictionary(config, config.isAutoload(), loadDic);\r\n}"
}, {
	"Path": "com.itextpdf.xmp.XMPDateTimeFactory.convertToLocalTime",
	"Comment": "make sure a time is local. if the time zone is not the local zone, the time is adjusted and\tthe time zone set to be local.",
	"Method": "XMPDateTime convertToLocalTime(XMPDateTime dateTime){\r\n    long timeInMillis = dateTime.getCalendar().getTimeInMillis();\r\n    GregorianCalendar cal = new GregorianCalendar();\r\n    cal.setTimeInMillis(timeInMillis);\r\n    return new XMPDateTimeImpl(cal);\r\n}"
}, {
	"Path": "com.example.CryptFile.decrypt",
	"Comment": "decrypts the provided ciphertext with the specified crypto key.",
	"Method": "byte[] decrypt(String projectId,String locationId,String keyRingId,String cryptoKeyId,byte[] ciphertext){\r\n    CloudKMS kms = createAuthorizedClient();\r\n    String cryptoKeyName = String.format(\"projects/%s/locations/%s/keyRings/%s/cryptoKeys/%s\", projectId, locationId, keyRingId, cryptoKeyId);\r\n    DecryptRequest request = new DecryptRequest().encodeCiphertext(ciphertext);\r\n    DecryptResponse response = kms.projects().locations().keyRings().cryptoKeys().decrypt(cryptoKeyName, request).execute();\r\n    return response.decodePlaintext();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.AcroFields.doesSignatureFieldExist",
	"Comment": "checks whether a name exists as a signature field or not. it checks both signed fields and blank signatures.",
	"Method": "boolean doesSignatureFieldExist(String name){\r\n    return getBlankSignatureNames().contains(name) || getSignatureNames().contains(name);\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.zip.JSONzip.postMortem",
	"Comment": "this method is used for testing the implementation of jsonzip. it is notsuitable for any other purpose. it is used to compare a compressor and adecompressor, verifying that the data structures that were built duringzipping and unzipping were the same.",
	"Method": "boolean postMortem(PostMortem pm){\r\n    JSONzip that = (JSONzip) pm;\r\n    return this.namehuff.postMortem(that.namehuff) && this.namekeep.postMortem(that.namekeep) && this.stringkeep.postMortem(that.stringkeep) && this.stringhuff.postMortem(that.stringhuff) && this.valuekeep.postMortem(that.valuekeep);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.ColumnText.findLimitsPoint",
	"Comment": "finds the intersection between the yline and the column. itwill set the linestatus appropriately.",
	"Method": "float findLimitsPoint(ArrayList<float[]> wall){\r\n    lineStatus = LINE_STATUS_OK;\r\n    if (yLine < minY || yLine > maxY) {\r\n        lineStatus = LINE_STATUS_OFFLIMITS;\r\n        return 0;\r\n    }\r\n    for (int k = 0; k < wall.size(); ++k) {\r\n        float[] r = wall.get(k);\r\n        if (yLine < r[0] || yLine > r[1]) {\r\n            continue;\r\n        }\r\n        return r[2] * yLine + r[3];\r\n    }\r\n    lineStatus = LINE_STATUS_NOLINE;\r\n    return 0;\r\n}"
}, {
	"Path": "com.itextpdf.text.Utilities.convertToHex",
	"Comment": "converts an array of bytes to a string of hexadecimal values",
	"Method": "String convertToHex(byte[] bytes){\r\n    ByteBuffer buf = new ByteBuffer();\r\n    for (byte b : bytes) {\r\n        buf.appendHex(b);\r\n    }\r\n    return PdfEncodings.convertToString(buf.toByteArray(), null).toUpperCase();\r\n}"
}, {
	"Path": "com.itextpdf.text.Paragraph.breakUp",
	"Comment": "breaks this paragraph up in different parts, separating paragraphs, lists and tables from each other.",
	"Method": "java.util.List<Element> breakUp(){\r\n    java.util.List<Element> list = new ArrayList<Element>();\r\n    Paragraph tmp = null;\r\n    for (Element e : this) {\r\n        if (e.type() == Element.LIST || e.type() == Element.PTABLE || e.type() == Element.PARAGRAPH) {\r\n            if (tmp != null && tmp.size() > 0) {\r\n                tmp.setSpacingAfter(0);\r\n                list.add(tmp);\r\n                tmp = cloneShallow(false);\r\n            }\r\n            if (list.size() == 0) {\r\n                switch(e.type()) {\r\n                    case Element.PTABLE:\r\n                        ((PdfPTable) e).setSpacingBefore(getSpacingBefore());\r\n                        break;\r\n                    case Element.PARAGRAPH:\r\n                        ((Paragraph) e).setSpacingBefore(getSpacingBefore());\r\n                        break;\r\n                    case Element.LIST:\r\n                        ListItem firstItem = ((List) e).getFirstItem();\r\n                        if (firstItem != null) {\r\n                            firstItem.setSpacingBefore(getSpacingBefore());\r\n                        }\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            list.add(e);\r\n        } else {\r\n            if (tmp == null) {\r\n                tmp = cloneShallow(list.size() == 0);\r\n            }\r\n            tmp.add(e);\r\n        }\r\n    }\r\n    if (tmp != null && tmp.size() > 0) {\r\n        list.add(tmp);\r\n    }\r\n    if (list.size() != 0) {\r\n        Element lastElement = list.get(list.size() - 1);\r\n        switch(lastElement.type()) {\r\n            case Element.PTABLE:\r\n                ((PdfPTable) lastElement).setSpacingAfter(getSpacingAfter());\r\n                break;\r\n            case Element.PARAGRAPH:\r\n                ((Paragraph) lastElement).setSpacingAfter(getSpacingAfter());\r\n                break;\r\n            case Element.LIST:\r\n                ListItem lastItem = ((List) lastElement).getLastItem();\r\n                if (lastItem != null) {\r\n                    lastItem.setSpacingAfter(getSpacingAfter());\r\n                }\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.pipeline.html.HtmlPipeline.getContextKey",
	"Comment": "this allows the descendant classes to be fetched from the context.",
	"Method": "String getContextKey(){\r\n    return HtmlPipeline.class.getName();\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONTokener.back",
	"Comment": "back up one character. this provides a sort of lookahead capability,so that you can test for a digit or letter before attempting to parsethe next number or identifier.",
	"Method": "void back(){\r\n    if (this.usePrevious || this.index <= 0) {\r\n        throw new JSONException(\"Stepping back two steps is not supported\");\r\n    }\r\n    this.index -= 1;\r\n    this.character -= 1;\r\n    this.usePrevious = true;\r\n    this.eof = false;\r\n}"
}, {
	"Path": "com.itextpdf.text.html.simpleparser.StyleSheet.applyStyle",
	"Comment": "resolves the styles based on the tag name and the value\tof the class attribute.",
	"Method": "void applyStyle(String tag,Map<String, String> attrs){\r\n    Map<String, String> map = tagMap.get(tag.toLowerCase());\r\n    if (map != null) {\r\n        Map<String, String> temp = new HashMap<String, String>(map);\r\n        temp.putAll(attrs);\r\n        attrs.putAll(temp);\r\n    }\r\n    String cm = attrs.get(HtmlTags.CLASS);\r\n    if (cm == null)\r\n        return;\r\n    map = classMap.get(cm.toLowerCase());\r\n    if (map == null)\r\n        return;\r\n    attrs.remove(HtmlTags.CLASS);\r\n    Map<String, String> temp = new HashMap<String, String>(map);\r\n    temp.putAll(attrs);\r\n    attrs.putAll(temp);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.BuildFDArrayUsed",
	"Comment": "function reads the fdselect and builds the fdarrayused hashmap according to the glyphs used",
	"Method": "void BuildFDArrayUsed(int Font){\r\n    int[] FDSelect = fonts[Font].FDSelect;\r\n    for (int i = 0; i < glyphsInList.size(); i++) {\r\n        int glyph = glyphsInList.get(i).intValue();\r\n        int FD = FDSelect[glyph];\r\n        FDArrayUsed.add(Integer.valueOf(FD));\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Barcode128.createAwtImage",
	"Comment": "creates a java.awt.image. this image onlycontains the bars without any text.",
	"Method": "java.awt.Image createAwtImage(java.awt.Color foreground,java.awt.Color background){\r\n    int f = foreground.getRGB();\r\n    int g = background.getRGB();\r\n    java.awt.Canvas canvas = new java.awt.Canvas();\r\n    String bCode;\r\n    if (codeType == CODE128_RAW) {\r\n        int idx = code.indexOf('?');\r\n        if (idx >= 0)\r\n            bCode = code.substring(0, idx);\r\n        else\r\n            bCode = code;\r\n    } else {\r\n        bCode = getRawText(code, codeType == CODE128_UCC);\r\n    }\r\n    int len = bCode.length();\r\n    int fullWidth = (len + 2) * 11 + 2;\r\n    byte[] bars = getBarsCode128Raw(bCode);\r\n    boolean print = true;\r\n    int ptr = 0;\r\n    int height = (int) barHeight;\r\n    int[] pix = new int[fullWidth * height];\r\n    for (int k = 0; k < bars.length; ++k) {\r\n        int w = bars[k];\r\n        int c = g;\r\n        if (print)\r\n            c = f;\r\n        print = !print;\r\n        for (int j = 0; j < w; ++j) pix[ptr++] = c;\r\n    }\r\n    for (int k = fullWidth; k < pix.length; k += fullWidth) {\r\n        System.arraycopy(pix, 0, pix, k, fullWidth);\r\n    }\r\n    java.awt.Image img = canvas.createImage(new java.awt.image.MemoryImageSource(fullWidth, height, pix, 0, fullWidth));\r\n    return img;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.FontDetails.convertToBytes",
	"Comment": "converts the text into bytes to be placed in the document.the conversion is done according to the font and the encoding and the charactersused are stored.",
	"Method": "byte[] convertToBytes(String text){\r\n    byte[] b = null;\r\n    switch(fontType) {\r\n        case BaseFont.FONT_TYPE_T3:\r\n            return baseFont.convertToBytes(text);\r\n        case BaseFont.FONT_TYPE_T1:\r\n        case BaseFont.FONT_TYPE_TT:\r\n            {\r\n                b = baseFont.convertToBytes(text);\r\n                int len = b.length;\r\n                for (int k = 0; k < len; ++k) shortTag[b[k] & 0xff] = 1;\r\n                break;\r\n            }\r\n        case BaseFont.FONT_TYPE_CJK:\r\n            {\r\n                int len = text.length();\r\n                if (cjkFont.isIdentity()) {\r\n                    for (int k = 0; k < len; ++k) {\r\n                        cjkTag.put(text.charAt(k), 0);\r\n                    }\r\n                } else {\r\n                    for (int k = 0; k < len; ++k) {\r\n                        int val;\r\n                        if (Utilities.isSurrogatePair(text, k)) {\r\n                            val = Utilities.convertToUtf32(text, k);\r\n                            k++;\r\n                        } else {\r\n                            val = text.charAt(k);\r\n                        }\r\n                        cjkTag.put(cjkFont.getCidCode(val), 0);\r\n                    }\r\n                }\r\n                b = cjkFont.convertToBytes(text);\r\n                break;\r\n            }\r\n        case BaseFont.FONT_TYPE_DOCUMENT:\r\n            {\r\n                b = baseFont.convertToBytes(text);\r\n                break;\r\n            }\r\n        case BaseFont.FONT_TYPE_TTUNI:\r\n            {\r\n                try {\r\n                    int len = text.length();\r\n                    int[] metrics = null;\r\n                    char[] glyph = new char[len];\r\n                    int i = 0;\r\n                    if (symbolic) {\r\n                        b = PdfEncodings.convertToBytes(text, \"symboltt\");\r\n                        len = b.length;\r\n                        for (int k = 0; k < len; ++k) {\r\n                            metrics = ttu.getMetricsTT(b[k] & 0xff);\r\n                            if (metrics == null)\r\n                                continue;\r\n                            longTag.put(Integer.valueOf(metrics[0]), new int[] { metrics[0], metrics[1], ttu.getUnicodeDifferences(b[k] & 0xff) });\r\n                            glyph[i++] = (char) metrics[0];\r\n                        }\r\n                    } else if (canApplyGlyphSubstitution()) {\r\n                        return convertToBytesAfterGlyphSubstitution(text);\r\n                    } else {\r\n                        for (int k = 0; k < len; ++k) {\r\n                            int val;\r\n                            if (Utilities.isSurrogatePair(text, k)) {\r\n                                val = Utilities.convertToUtf32(text, k);\r\n                                k++;\r\n                            } else {\r\n                                val = text.charAt(k);\r\n                            }\r\n                            metrics = ttu.getMetricsTT(val);\r\n                            if (metrics == null)\r\n                                continue;\r\n                            int m0 = metrics[0];\r\n                            Integer gl = Integer.valueOf(m0);\r\n                            if (!longTag.containsKey(gl))\r\n                                longTag.put(gl, new int[] { m0, metrics[1], val });\r\n                            glyph[i++] = (char) m0;\r\n                        }\r\n                    }\r\n                    glyph = Utilities.copyOfRange(glyph, 0, i);\r\n                    b = StringUtils.convertCharsToBytes(glyph);\r\n                } catch (UnsupportedEncodingException e) {\r\n                    throw new ExceptionConverter(e);\r\n                }\r\n                break;\r\n            }\r\n    }\r\n    return b;\r\n}"
}, {
	"Path": "com.structurizr.model.Model.contains",
	"Comment": "determines whether this model contains the specified element.",
	"Method": "boolean contains(Element element){\r\n    return elementsById.values().contains(element);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.spatial.objects.NumberFormatDictionary.setFractionalValue",
	"Comment": "indicate whether and in what manner to display a fractional value from\tthe result of converting to the units of this numberformat means of the\tconversion factor entry.",
	"Method": "void setFractionalValue(Fraction f){\r\n    super.put(PdfName.F, f.getPdfName());\r\n}"
}, {
	"Path": "com.google.cloud.vision.samples.text.TextApp.lookupWords",
	"Comment": "looks up words in the index that the user enters into the console.",
	"Method": "void lookupWords(){\r\n    System.out.println(\"Entering word lookup mode.\");\r\n    System.out.println(\"To index a directory, add an input path argument when you run this command.\");\r\n    System.out.println();\r\n    Console console = System.console();\r\n    if (console == null) {\r\n        System.err.println(\"No console.\");\r\n        System.exit(1);\r\n    }\r\n    while (true) {\r\n        String words = console.readLine(\"Enter word(s) (comma-separated, leave blank to exit): \").trim();\r\n        if (words.equals(\"\")) {\r\n            break;\r\n        }\r\n        index.printLookup(Splitter.on(',').split(words));\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.ImageRenderInfo.createForEmbeddedImage",
	"Comment": "create an imagerenderinfo object based on inline image data.",
	"Method": "ImageRenderInfo createForEmbeddedImage(GraphicsState gs,InlineImageInfo inlineImageInfo,PdfDictionary colorSpaceDictionary,Collection<MarkedContentInfo> markedContentInfo){\r\n    ImageRenderInfo renderInfo = new ImageRenderInfo(gs, inlineImageInfo, colorSpaceDictionary, markedContentInfo);\r\n    return renderInfo;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.EmbedBuilder.setDescription",
	"Comment": "sets the description of the embed. this is where the main chunk of text for an embed is typically placed.example",
	"Method": "EmbedBuilder setDescription(CharSequence description){\r\n    this.description.setLength(0);\r\n    if (description != null && description.length() >= 1)\r\n        appendDescription(description);\r\n    return this;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStamper.getOverContent",
	"Comment": "gets a pdfcontentbyte to write over the page ofthe original document.",
	"Method": "PdfContentByte getOverContent(int pageNum){\r\n    return stamper.getOverContent(pageNum);\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.util.IStringBuffer.resizeTo",
	"Comment": "resize the bufferthis will have to copy the old chars from the old buffer to the new buffer",
	"Method": "void resizeTo(int length){\r\n    if (length <= 0)\r\n        throw new IllegalArgumentException(\"length <= 0\");\r\n    if (length != buff.length) {\r\n        int len = (length > buff.length) ? buff.length : length;\r\n        char[] obuff = buff;\r\n        buff = new char[length];\r\n        System.arraycopy(obuff, 0, buff, 0, len);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPCell.setMinimumHeight",
	"Comment": "set a minimum height for the cell. this will automatically unsetfixedheight, if set.",
	"Method": "void setMinimumHeight(float minimumHeight){\r\n    this.minimumHeight = minimumHeight;\r\n    fixedHeight = 0;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPRow.splitRow",
	"Comment": "splits a row to newheight. the returned row is the remainder. it willreturn null if the newheight was so small that only an empty row wouldresult.",
	"Method": "PdfPRow splitRow(PdfPTable table,int rowIndex,float new_height){\r\n    if (LOGGER.isLogging(Level.INFO)) {\r\n        LOGGER.info(String.format(\"Splitting row %s available height: %s\", rowIndex, new_height));\r\n    }\r\n    PdfPCell[] newCells = new PdfPCell[cells.length];\r\n    float[] calHs = new float[cells.length];\r\n    float[] fixHs = new float[cells.length];\r\n    float[] minHs = new float[cells.length];\r\n    boolean allEmpty = true;\r\n    for (int k = 0; k < cells.length; ++k) {\r\n        float newHeight = new_height;\r\n        PdfPCell cell = cells[k];\r\n        if (cell == null) {\r\n            int index = rowIndex;\r\n            if (table.rowSpanAbove(index, k)) {\r\n                while (table.rowSpanAbove(--index, k)) {\r\n                    newHeight += table.getRow(index).getMaxHeights();\r\n                }\r\n                PdfPRow row = table.getRow(index);\r\n                if (row != null && row.getCells()[k] != null) {\r\n                    newCells[k] = new PdfPCell(row.getCells()[k]);\r\n                    newCells[k].setColumn(null);\r\n                    newCells[k].setRowspan(row.getCells()[k].getRowspan() - rowIndex + index);\r\n                    allEmpty = false;\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n        calHs[k] = cell.getCalculatedHeight();\r\n        fixHs[k] = cell.getFixedHeight();\r\n        minHs[k] = cell.getMinimumHeight();\r\n        Image img = cell.getImage();\r\n        PdfPCell newCell = new PdfPCell(cell);\r\n        if (img != null) {\r\n            float padding = cell.getEffectivePaddingBottom() + cell.getEffectivePaddingTop() + 2;\r\n            if ((img.isScaleToFitHeight() || img.getScaledHeight() + padding < newHeight) && newHeight > padding) {\r\n                newCell.setPhrase(null);\r\n                allEmpty = false;\r\n            }\r\n        } else {\r\n            float y;\r\n            ColumnText ct = ColumnText.duplicate(cell.getColumn());\r\n            float left = cell.getLeft() + cell.getEffectivePaddingLeft();\r\n            float bottom = cell.getTop() + cell.getEffectivePaddingBottom() - newHeight;\r\n            float right = cell.getRight() - cell.getEffectivePaddingRight();\r\n            float top = cell.getTop() - cell.getEffectivePaddingTop();\r\n            switch(cell.getRotation()) {\r\n                case 90:\r\n                case 270:\r\n                    y = setColumn(ct, bottom, left, top, right);\r\n                    break;\r\n                default:\r\n                    y = setColumn(ct, left, bottom + 0.00001f, cell.isNoWrap() ? RIGHT_LIMIT : right, top);\r\n                    break;\r\n            }\r\n            int status;\r\n            try {\r\n                status = ct.go(true);\r\n            } catch (DocumentException e) {\r\n                throw new ExceptionConverter(e);\r\n            }\r\n            boolean thisEmpty = (ct.getYLine() == y);\r\n            if (thisEmpty) {\r\n                newCell.setColumn(ColumnText.duplicate(cell.getColumn()));\r\n                ct.setFilledWidth(0);\r\n            } else if ((status & ColumnText.NO_MORE_TEXT) == 0) {\r\n                newCell.setColumn(ct);\r\n                ct.setFilledWidth(0);\r\n            } else {\r\n                newCell.setPhrase(null);\r\n            }\r\n            allEmpty = (allEmpty && thisEmpty);\r\n        }\r\n        newCells[k] = newCell;\r\n        cell.setCalculatedHeight(newHeight);\r\n    }\r\n    if (allEmpty) {\r\n        for (int k = 0; k < cells.length; ++k) {\r\n            PdfPCell cell = cells[k];\r\n            if (cell == null) {\r\n                continue;\r\n            }\r\n            cell.setCalculatedHeight(calHs[k]);\r\n            if (fixHs[k] > 0) {\r\n                cell.setFixedHeight(fixHs[k]);\r\n            } else {\r\n                cell.setMinimumHeight(minHs[k]);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    calculateHeights();\r\n    PdfPRow split = new PdfPRow(newCells, this);\r\n    split.widths = (float[]) widths.clone();\r\n    return split;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.HandelStack",
	"Comment": "function checks how the current operator effects the run time stack after being run\tan operator may increase or decrease the stack size",
	"Method": "void HandelStack(){\r\n    int StackHandel = StackOpp();\r\n    if (StackHandel < 2) {\r\n        if (StackHandel == 1)\r\n            PushStack();\r\n        else {\r\n            StackHandel *= -1;\r\n            for (int i = 0; i < StackHandel; i++) PopStack();\r\n        }\r\n    } else\r\n        EmptyStack();\r\n}"
}, {
	"Path": "com.google.cloud.vision.samples.text.TextApp.getVisionService",
	"Comment": "connects to the vision api using application default credentials.",
	"Method": "Vision getVisionService(){\r\n    GoogleCredential credential = GoogleCredential.getApplicationDefault().createScoped(VisionScopes.all());\r\n    JsonFactory jsonFactory = JacksonFactory.getDefaultInstance();\r\n    return new Vision.Builder(GoogleNetHttpTransport.newTrustedTransport(), jsonFactory, credential).setApplicationName(APPLICATION_NAME).build();\r\n}"
}, {
	"Path": "net.dv8tion.jda.bot.sharding.DefaultShardManagerBuilder.setMaxReconnectDelay",
	"Comment": "sets the maximum amount of time that jda will back off to wait when attempting to reconnect the mainwebsocket.provided value must be 32 or greater.",
	"Method": "DefaultShardManagerBuilder setMaxReconnectDelay(int maxReconnectDelay){\r\n    Checks.check(maxReconnectDelay >= 32, \"Max reconnect delay must be 32 seconds or greater. You provided %d.\", maxReconnectDelay);\r\n    this.maxReconnectDelay = maxReconnectDelay;\r\n    return this;\r\n}"
}, {
	"Path": "com.itextpdf.text.Rectangle.isUseVariableBorders",
	"Comment": "indicates whether variable width borders are being used.\treturns true if setborderwidthleft, setborderwidthright,\tsetborderwidthtop, or setborderwidthbottom has been called.",
	"Method": "boolean isUseVariableBorders(){\r\n    return useVariableBorders;\r\n}"
}, {
	"Path": "com.itextpdf.text.Image.hasAbsoluteX",
	"Comment": "checks if the images has to be added at an absolute x\tposition.",
	"Method": "boolean hasAbsoluteX(){\r\n    return !Float.isNaN(absoluteX);\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONArray.similar",
	"Comment": "determine if two jsonarrays are similar.they must contain similar sequences.",
	"Method": "boolean similar(Object other){\r\n    if (!(other instanceof JSONArray)) {\r\n        return false;\r\n    }\r\n    int len = this.length();\r\n    if (len != ((JSONArray) other).length()) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < len; i += 1) {\r\n        Object valueThis = this.get(i);\r\n        Object valueOther = ((JSONArray) other).get(i);\r\n        if (valueThis instanceof JSONObject) {\r\n            if (!((JSONObject) valueThis).similar(valueOther)) {\r\n                return false;\r\n            }\r\n        } else if (valueThis instanceof JSONArray) {\r\n            if (!((JSONArray) valueThis).similar(valueOther)) {\r\n                return false;\r\n            }\r\n        } else if (!valueThis.equals(valueOther)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.itextpdf.text.Image.hasAbsoluteY",
	"Comment": "checks if the images has to be added at an absolute\tposition.",
	"Method": "boolean hasAbsoluteY(){\r\n    return !Float.isNaN(absoluteY);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.draw.VerticalPositionMark.setOffset",
	"Comment": "setter for the offset. the offset is relative to the currenty position. if you want to underline something, you have tochoose a negative offset.",
	"Method": "void setOffset(float offset){\r\n    this.offset = offset;\r\n}"
}, {
	"Path": "com.itextpdf.awt.PdfGraphics2D.doAttributes",
	"Comment": "this routine goes through the attributes and sets the fontbefore calling the actual string drawing routine",
	"Method": "void doAttributes(AttributedCharacterIterator iter){\r\n    underline = false;\r\n    strikethrough = false;\r\n    for (AttributedCharacterIterator.Attribute attribute : iter.getAttributes().keySet()) {\r\n        if (!(attribute instanceof TextAttribute))\r\n            continue;\r\n        TextAttribute textattribute = (TextAttribute) attribute;\r\n        if (textattribute.equals(TextAttribute.FONT)) {\r\n            Font font = (Font) iter.getAttributes().get(textattribute);\r\n            setFont(font);\r\n        } else if (textattribute.equals(TextAttribute.UNDERLINE)) {\r\n            if (iter.getAttributes().get(textattribute) == TextAttribute.UNDERLINE_ON)\r\n                underline = true;\r\n        } else if (textattribute.equals(TextAttribute.STRIKETHROUGH)) {\r\n            if (iter.getAttributes().get(textattribute) == TextAttribute.STRIKETHROUGH_ON)\r\n                strikethrough = true;\r\n        } else if (textattribute.equals(TextAttribute.SIZE)) {\r\n            Object obj = iter.getAttributes().get(textattribute);\r\n            if (obj instanceof Integer) {\r\n                int i = ((Integer) obj).intValue();\r\n                setFont(getFont().deriveFont(getFont().getStyle(), i));\r\n            } else if (obj instanceof Float) {\r\n                float f = ((Float) obj).floatValue();\r\n                setFont(getFont().deriveFont(getFont().getStyle(), f));\r\n            }\r\n        } else if (textattribute.equals(TextAttribute.FOREGROUND)) {\r\n            setColor((Color) iter.getAttributes().get(textattribute));\r\n        } else if (textattribute.equals(TextAttribute.FAMILY)) {\r\n            Font font = getFont();\r\n            Map fontAttributes = font.getAttributes();\r\n            fontAttributes.put(TextAttribute.FAMILY, iter.getAttributes().get(textattribute));\r\n            setFont(font.deriveFont(fontAttributes));\r\n        } else if (textattribute.equals(TextAttribute.POSTURE)) {\r\n            Font font = getFont();\r\n            Map fontAttributes = font.getAttributes();\r\n            fontAttributes.put(TextAttribute.POSTURE, iter.getAttributes().get(textattribute));\r\n            setFont(font.deriveFont(fontAttributes));\r\n        } else if (textattribute.equals(TextAttribute.WEIGHT)) {\r\n            Font font = getFont();\r\n            Map fontAttributes = font.getAttributes();\r\n            fontAttributes.put(TextAttribute.WEIGHT, iter.getAttributes().get(textattribute));\r\n            setFont(font.deriveFont(fontAttributes));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.getAscent",
	"Comment": "gets the ascent of a string in normalized 1000 units. the ascent will always begreater than or equal to zero even if all the characters have a lower ascent.",
	"Method": "int getAscent(String text){\r\n    int max = 0;\r\n    char[] chars = text.toCharArray();\r\n    for (int k = 0; k < chars.length; ++k) {\r\n        int[] bbox = getCharBBox(chars[k]);\r\n        if (bbox != null && bbox[3] > max)\r\n            max = bbox[3];\r\n    }\r\n    return max;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BarcodeEANSUPP.createAwtImage",
	"Comment": "creates a java.awt.image. this image onlycontains the bars without any text.",
	"Method": "java.awt.Image createAwtImage(java.awt.Color foreground,java.awt.Color background){\r\n    throw new UnsupportedOperationException(MessageLocalization.getComposedMessage(\"the.two.barcodes.must.be.composed.externally\"));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.getBaseName",
	"Comment": "gets the name without the modifiers bold, italic or bolditalic.",
	"Method": "String getBaseName(String name){\r\n    if (name.endsWith(\",Bold\"))\r\n        return name.substring(0, name.length() - 5);\r\n    else if (name.endsWith(\",Italic\"))\r\n        return name.substring(0, name.length() - 7);\r\n    else if (name.endsWith(\",BoldItalic\"))\r\n        return name.substring(0, name.length() - 11);\r\n    else\r\n        return name;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPSerializerRDF.declareUsedNamespaces",
	"Comment": "writes all used namespaces of the subtree in node to the output. \tthe subtree is recursivly traversed.",
	"Method": "void declareUsedNamespaces(XMPNode node,Set usedPrefixes,int indent){\r\n    if (node.getOptions().isSchemaNode()) {\r\n        String prefix = node.getValue().substring(0, node.getValue().length() - 1);\r\n        declareNamespace(prefix, node.getName(), usedPrefixes, indent);\r\n    } else if (node.getOptions().isStruct()) {\r\n        for (Iterator it = node.iterateChildren(); it.hasNext(); ) {\r\n            XMPNode field = (XMPNode) it.next();\r\n            declareNamespace(field.getName(), null, usedPrefixes, indent);\r\n        }\r\n    }\r\n    for (Iterator it = node.iterateChildren(); it.hasNext(); ) {\r\n        XMPNode child = (XMPNode) it.next();\r\n        declareUsedNamespaces(child, usedPrefixes, indent);\r\n    }\r\n    for (Iterator it = node.iterateQualifier(); it.hasNext(); ) {\r\n        XMPNode qualifier = (XMPNode) it.next();\r\n        declareNamespace(qualifier.getName(), null, usedPrefixes, indent);\r\n        declareUsedNamespaces(qualifier, usedPrefixes, indent);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.html.simpleparser.CellWrapper.createPdfPCell",
	"Comment": "creates a pdfpcell element based on a tag and its properties.",
	"Method": "PdfPCell createPdfPCell(String tag,ChainedProperties chain){\r\n    PdfPCell cell = new PdfPCell((Phrase) null);\r\n    String value = chain.getProperty(HtmlTags.COLSPAN);\r\n    if (value != null)\r\n        cell.setColspan(Integer.parseInt(value));\r\n    value = chain.getProperty(HtmlTags.ROWSPAN);\r\n    if (value != null)\r\n        cell.setRowspan(Integer.parseInt(value));\r\n    if (tag.equals(HtmlTags.TH))\r\n        cell.setHorizontalAlignment(Element.ALIGN_CENTER);\r\n    value = chain.getProperty(HtmlTags.ALIGN);\r\n    if (value != null) {\r\n        cell.setHorizontalAlignment(HtmlUtilities.alignmentValue(value));\r\n    }\r\n    value = chain.getProperty(HtmlTags.VALIGN);\r\n    cell.setVerticalAlignment(Element.ALIGN_MIDDLE);\r\n    if (value != null) {\r\n        cell.setVerticalAlignment(HtmlUtilities.alignmentValue(value));\r\n    }\r\n    value = chain.getProperty(HtmlTags.BORDER);\r\n    float border = 0;\r\n    if (value != null)\r\n        border = Float.parseFloat(value);\r\n    cell.setBorderWidth(border);\r\n    value = chain.getProperty(HtmlTags.CELLPADDING);\r\n    if (value != null)\r\n        cell.setPadding(Float.parseFloat(value));\r\n    cell.setUseDescender(true);\r\n    value = chain.getProperty(HtmlTags.BGCOLOR);\r\n    cell.setBackgroundColor(HtmlUtilities.decodeColor(value));\r\n    return cell;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BarcodePDF417.getCodeRows",
	"Comment": "gets the number of y pixels of outbits.it is also the number of rows in the barcode.",
	"Method": "int getCodeRows(){\r\n    return this.codeRows;\r\n}"
}, {
	"Path": "software.amazon.ion.TimestampTest.testNegativeEpochWithFractionalSeconds",
	"Comment": "ensures that a point in time represented by amillisecond value that is an offset from the epoch withfractional precision has its fractional seconds computed correctly duringconstruction of the timestamp.all variants of constructors that constructs a timestamp with from amilliseconds representation with fractional precision is tested here.all constructors are expected to construct a valid timestamp instance.",
	"Method": "void testNegativeEpochWithFractionalSeconds(){\r\n    BigDecimal negativeEpochDecimalMillis = new BigDecimal(\"-9223372036854.775808\");\r\n    Timestamp expectedTs = Timestamp.forMillis(negativeEpochDecimalMillis, UTC_OFFSET);\r\n    long expectedMillis = expectedTs.getMillis();\r\n    Timestamp expectedTsMillis = Timestamp.forMillis(expectedMillis, UTC_OFFSET);\r\n    Timestamp expectedTsMillisWithNanosPrecision = Timestamp.valueOf(\"1677-09-21T00:12:43.145000000Z\");\r\n    assertEquals(\"-9223372036854.775808\", negativeEpochDecimalMillis.toPlainString());\r\n    assertEquals(-9223372036855L, expectedMillis);\r\n    assertEquals(\"1677-09-21T00:12:43.145224192Z\", expectedTs.toZString());\r\n    assertEquals(\"1677-09-21T00:12:43.145000000Z\", expectedTsMillisWithNanosPrecision.toZString());\r\n    assertEquals(\"1677-09-21T00:12:43.145Z\", expectedTsMillis.toZString());\r\n    assertTrue(expectedTs.compareTo(EARLIEST_ION_TIMESTAMP) > 0);\r\n    assertTrue(expectedTs.compareTo(UNIX_EPOCH_TIMESTAMP) < 0);\r\n    Timestamp actualTs = Timestamp.forMillis(negativeEpochDecimalMillis, UTC_OFFSET);\r\n    assertEquals(expectedTs, actualTs);\r\n    actualTs = Timestamp.forMillis(expectedMillis, UTC_OFFSET);\r\n    assertEquals(expectedTsMillis, actualTs);\r\n    java.sql.Timestamp actualSqlTs = new java.sql.Timestamp(expectedMillis);\r\n    actualTs = Timestamp.forSqlTimestampZ(actualSqlTs);\r\n    assertEquals(expectedTsMillisWithNanosPrecision, actualTs);\r\n    actualSqlTs.setNanos(145224192);\r\n    actualTs = Timestamp.forSqlTimestampZ(actualSqlTs);\r\n    assertEquals(expectedTs, actualTs);\r\n}"
}, {
	"Path": "com.google.cloud.storage.storagetransfer.samples.test.AwsRequesterTest.testRun",
	"Comment": "tests whether awsrequester executes a request to create a transferjob.",
	"Method": "void testRun(){\r\n    System.setProperty(\"projectId\", PROJECT_ID);\r\n    System.setProperty(\"jobDescription\", \"Sample transfer job from S3 to GCS.\");\r\n    System.setProperty(\"awsSourceBucket\", \"cloud-samples-tests\");\r\n    System.setProperty(\"gcsSinkBucket\", PROJECT_ID + \"-storagetransfer\");\r\n    System.setProperty(\"startDate\", \"2000-01-01\");\r\n    System.setProperty(\"startTime\", \"00:00:00\");\r\n    ByteArrayOutputStream outBytes = new ByteArrayOutputStream();\r\n    PrintStream outStream = new PrintStream(outBytes);\r\n    AwsRequester.run(outStream);\r\n    String out = outBytes.toString();\r\n    assertThat(out).contains(\"\\\"description\\\" : \\\"Sample transfer job from S3 to GCS.\\\"\");\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.Kim.equals",
	"Comment": "two kim objects containing exactly the same bytes in the same order areequal to each other.",
	"Method": "boolean equals(Object obj){\r\n    if (!(obj instanceof Kim)) {\r\n        return false;\r\n    }\r\n    Kim that = (Kim) obj;\r\n    if (this == that) {\r\n        return true;\r\n    }\r\n    if (this.hashcode != that.hashcode) {\r\n        return false;\r\n    }\r\n    return java.util.Arrays.equals(this.bytes, that.bytes);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BidiOrder.findRunLimit",
	"Comment": "return the limit of the run starting at index that includes only resulttypes in validset.this checks the value at index, and will return index if that value is not in validset.",
	"Method": "int findRunLimit(int index,int limit,byte[] validSet){\r\n    --index;\r\n    loop: while (++index < limit) {\r\n        byte t = resultTypes[index];\r\n        for (int i = 0; i < validSet.length; ++i) {\r\n            if (t == validSet[i]) {\r\n                continue loop;\r\n            }\r\n        }\r\n        return index;\r\n    }\r\n    return limit;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPNodeUtils.verifySetOptions",
	"Comment": "verifies the propertyoptions for consistancy and updates them as needed. \tif options are null they are created with default values.",
	"Method": "PropertyOptions verifySetOptions(PropertyOptions options,Object itemValue){\r\n    if (options == null) {\r\n        options = new PropertyOptions();\r\n    }\r\n    if (options.isArrayAltText()) {\r\n        options.setArrayAlternate(true);\r\n    }\r\n    if (options.isArrayAlternate()) {\r\n        options.setArrayOrdered(true);\r\n    }\r\n    if (options.isArrayOrdered()) {\r\n        options.setArray(true);\r\n    }\r\n    if (options.isCompositeProperty() && itemValue != null && itemValue.toString().length() > 0) {\r\n        throw new XMPException(\"Structs and arrays can't have values\", XMPError.BADOPTIONS);\r\n    }\r\n    options.assertConsistency(options.getOptions());\r\n    return options;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDocument.getRootOutline",
	"Comment": "gets the root outline. all the outlines must be created with a parent.the first level is created with this outline.",
	"Method": "PdfOutline getRootOutline(){\r\n    return rootOutline;\r\n}"
}, {
	"Path": "org.jbake.template.ModelExtractors.loadEngines",
	"Comment": "this method is used internally to load markup engines. markup engines are found using descriptor files onclasspath, so adding an engine is as easy as adding a jar on classpath with the descriptor file included.",
	"Method": "void loadEngines(){\r\n    try {\r\n        ClassLoader cl = ModelExtractors.class.getClassLoader();\r\n        Enumeration<URL> resources = cl.getResources(PROPERTIES);\r\n        while (resources.hasMoreElements()) {\r\n            URL url = resources.nextElement();\r\n            Properties props = new Properties();\r\n            props.load(url.openStream());\r\n            for (Map.Entry<Object, Object> entry : props.entrySet()) {\r\n                String className = (String) entry.getKey();\r\n                String[] extensions = ((String) entry.getValue()).split(\",\");\r\n                loadAndRegisterEngine(className, extensions);\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.applyTorque",
	"Comment": "apply a torque. this affects the angular velocity without affecting the linear velocity of thecenter of mass. this wakes up the body.",
	"Method": "void applyTorque(float torque){\r\n    if (m_type != BodyType.DYNAMIC) {\r\n        return;\r\n    }\r\n    if (isAwake() == false) {\r\n        setAwake(true);\r\n    }\r\n    m_torque += torque;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStamper.setMoreInfo",
	"Comment": "an optional string map to add or change values inthe info dictionary. entries with nullvalues delete the key in the original info dictionary",
	"Method": "void setMoreInfo(Map<String, String> moreInfo){\r\n    this.moreInfo = moreInfo;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONObject.accumulate",
	"Comment": "accumulate values under a key. it is similar to the put method exceptthat if there is already an object stored under the key then a jsonarrayis stored under the key to hold all of the accumulated values. if thereis already a jsonarray, then the new value is appended to it. incontrast, the put method replaces the previous value.if only one value is accumulated that is not a jsonarray, then the resultwill be the same as using put. but if multiple values are accumulated,then the result will be like append.",
	"Method": "JSONObject accumulate(String key,Object value){\r\n    testValidity(value);\r\n    Object object = this.opt(key);\r\n    if (object == null) {\r\n        this.put(key, value instanceof JSONArray ? new JSONArray().put(value) : value);\r\n    } else if (object instanceof JSONArray) {\r\n        ((JSONArray) object).put(value);\r\n    } else {\r\n        this.put(key, new JSONArray().put(object).put(value));\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.util.PdfResourceCounter.loopOver",
	"Comment": "in case an object is an array, a dictionary or a stream,we need to loop over the entries and process them one by one.",
	"Method": "void loopOver(PdfObject object){\r\n    switch(object.type()) {\r\n        case PdfObject.ARRAY:\r\n            PdfArray array = (PdfArray) object;\r\n            for (int i = 0; i < array.size(); i++) {\r\n                process(array.getDirectObject(i));\r\n            }\r\n            break;\r\n        case PdfObject.DICTIONARY:\r\n        case PdfObject.STREAM:\r\n            PdfDictionary dict = (PdfDictionary) object;\r\n            if (dict.isPages())\r\n                break;\r\n            for (PdfName name : dict.getKeys()) {\r\n                process(dict.getDirectObject(name));\r\n            }\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.awt.geom.PolylineShapeIterator.next",
	"Comment": "moves the iterator to the next segment of the path forwards\talong the primary direction of traversal as long as there are\tmore points in that direction.",
	"Method": "void next(){\r\n    index++;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.tokenizer.core.SegKit.appendSynonyms",
	"Comment": "quick interface to do the synonyms append wordyou got check if the specified has any synonyms first",
	"Method": "void appendSynonyms(LinkedList<IWord> wordPool,IWord wd){\r\n    List<IWord> synList = wd.getSyn().getList();\r\n    synchronized (synList) {\r\n        for (int j = 0; j < synList.size(); j++) {\r\n            IWord curWord = synList.get(j);\r\n            if (curWord.getValue().equals(wd.getValue())) {\r\n                continue;\r\n            }\r\n            IWord synWord = synList.get(j).clone();\r\n            synWord.setPosition(wd.getPosition());\r\n            wordPool.add(synWord);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.structurizr.view.RelationshipView.getRouting",
	"Comment": "gets the routing algorithm used when rendering this relationship.",
	"Method": "Routing getRouting(){\r\n    return routing;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.PdfPKCS7.getEncodedPKCS7",
	"Comment": "gets the bytes for the pkcs7signeddata object. optionally the authenticatedattributesin the signerinfo can also be set. if either of the parameters is null, none will be used.",
	"Method": "byte[] getEncodedPKCS7(byte[] getEncodedPKCS7,byte secondDigest,byte[] getEncodedPKCS7,byte secondDigest,TSAClient tsaClient,byte[] ocsp,Collection<byte[]> crlBytes,CryptoStandard sigtype){\r\n    try {\r\n        if (externalDigest != null) {\r\n            digest = externalDigest;\r\n            if (RSAdata != null)\r\n                RSAdata = externalRSAdata;\r\n        } else if (externalRSAdata != null && RSAdata != null) {\r\n            RSAdata = externalRSAdata;\r\n            sig.update(RSAdata);\r\n            digest = sig.sign();\r\n        } else {\r\n            if (RSAdata != null) {\r\n                RSAdata = messageDigest.digest();\r\n                sig.update(RSAdata);\r\n            }\r\n            digest = sig.sign();\r\n        }\r\n        ASN1EncodableVector digestAlgorithms = new ASN1EncodableVector();\r\n        for (Object element : digestalgos) {\r\n            ASN1EncodableVector algos = new ASN1EncodableVector();\r\n            algos.add(new ASN1ObjectIdentifier((String) element));\r\n            algos.add(DERNull.INSTANCE);\r\n            digestAlgorithms.add(new DERSequence(algos));\r\n        }\r\n        ASN1EncodableVector v = new ASN1EncodableVector();\r\n        v.add(new ASN1ObjectIdentifier(SecurityIDs.ID_PKCS7_DATA));\r\n        if (RSAdata != null)\r\n            v.add(new DERTaggedObject(0, new DEROctetString(RSAdata)));\r\n        DERSequence contentinfo = new DERSequence(v);\r\n        v = new ASN1EncodableVector();\r\n        for (Object element : certs) {\r\n            ASN1InputStream tempstream = new ASN1InputStream(new ByteArrayInputStream(((X509Certificate) element).getEncoded()));\r\n            v.add(tempstream.readObject());\r\n        }\r\n        DERSet dercertificates = new DERSet(v);\r\n        ASN1EncodableVector signerinfo = new ASN1EncodableVector();\r\n        signerinfo.add(new ASN1Integer(signerversion));\r\n        v = new ASN1EncodableVector();\r\n        v.add(CertificateInfo.getIssuer(signCert.getTBSCertificate()));\r\n        v.add(new ASN1Integer(signCert.getSerialNumber()));\r\n        signerinfo.add(new DERSequence(v));\r\n        v = new ASN1EncodableVector();\r\n        v.add(new ASN1ObjectIdentifier(digestAlgorithmOid));\r\n        v.add(new DERNull());\r\n        signerinfo.add(new DERSequence(v));\r\n        if (secondDigest != null) {\r\n            signerinfo.add(new DERTaggedObject(false, 0, getAuthenticatedAttributeSet(secondDigest, ocsp, crlBytes, sigtype)));\r\n        }\r\n        v = new ASN1EncodableVector();\r\n        v.add(new ASN1ObjectIdentifier(digestEncryptionAlgorithmOid));\r\n        v.add(new DERNull());\r\n        signerinfo.add(new DERSequence(v));\r\n        signerinfo.add(new DEROctetString(digest));\r\n        if (tsaClient != null) {\r\n            byte[] tsImprint = tsaClient.getMessageDigest().digest(digest);\r\n            byte[] tsToken = tsaClient.getTimeStampToken(tsImprint);\r\n            if (tsToken != null) {\r\n                ASN1EncodableVector unauthAttributes = buildUnauthenticatedAttributes(tsToken);\r\n                if (unauthAttributes != null) {\r\n                    signerinfo.add(new DERTaggedObject(false, 1, new DERSet(unauthAttributes)));\r\n                }\r\n            }\r\n        }\r\n        ASN1EncodableVector body = new ASN1EncodableVector();\r\n        body.add(new ASN1Integer(version));\r\n        body.add(new DERSet(digestAlgorithms));\r\n        body.add(contentinfo);\r\n        body.add(new DERTaggedObject(false, 0, dercertificates));\r\n        body.add(new DERSet(new DERSequence(signerinfo)));\r\n        ASN1EncodableVector whole = new ASN1EncodableVector();\r\n        whole.add(new ASN1ObjectIdentifier(SecurityIDs.ID_PKCS7_SIGNED_DATA));\r\n        whole.add(new DERTaggedObject(0, new DERSequence(body)));\r\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\r\n        ASN1OutputStream dout = new ASN1OutputStream(bOut);\r\n        dout.writeObject(new DERSequence(whole));\r\n        dout.close();\r\n        return bOut.toByteArray();\r\n    } catch (Exception e) {\r\n        throw new ExceptionConverter(e);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.draw.VerticalPositionMark.getOffset",
	"Comment": "getter for the offset relative to the baseline of the current line.",
	"Method": "float getOffset(){\r\n    return offset;\r\n}"
}, {
	"Path": "com.example.CryptFile.createAuthorizedClient",
	"Comment": "creates an authorized cloudkms client service using application default credentials.",
	"Method": "CloudKMS createAuthorizedClient(){\r\n    HttpTransport transport = new NetHttpTransport();\r\n    JsonFactory jsonFactory = new JacksonFactory();\r\n    GoogleCredential credential = GoogleCredential.getApplicationDefault(transport, jsonFactory);\r\n    if (credential.createScopedRequired()) {\r\n        credential = credential.createScoped(CloudKMSScopes.all());\r\n    }\r\n    return new CloudKMS.Builder(transport, jsonFactory, credential).setApplicationName(\"CloudKMS CryptFile\").build();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.TaggedPdfReaderTool.inspectChildArray",
	"Comment": "if the child of a structured element is an array, we need to loop over\tthe elements.",
	"Method": "void inspectChildArray(PdfArray k){\r\n    if (k == null)\r\n        return;\r\n    for (int i = 0; i < k.size(); i++) {\r\n        inspectChild(k.getDirectObject(i));\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfLine.getAscender",
	"Comment": "gets the maximum size of the ascender for all the fonts usedin this line.",
	"Method": "float getAscender(){\r\n    float ascender = 0;\r\n    for (int k = 0; k < line.size(); ++k) {\r\n        PdfChunk ck = line.get(k);\r\n        if (ck.isImage())\r\n            ascender = Math.max(ascender, ck.getImageHeight() + ck.getImageOffsetY());\r\n        else {\r\n            PdfFont font = ck.font();\r\n            float textRise = ck.getTextRise();\r\n            ascender = Math.max(ascender, (textRise > 0 ? textRise : 0) + font.getFont().getFontDescriptor(BaseFont.ASCENT, font.size()));\r\n        }\r\n    }\r\n    return ascender;\r\n}"
}, {
	"Path": "com.itextpdf.awt.geom.gl.Crossing.fixRoots",
	"Comment": "excludes double roots. roots are double if they lies enough close with each other.",
	"Method": "int fixRoots(double res,int rc){\r\n    int tc = 0;\r\n    for (int i = 0; i < rc; i++) {\r\n        out: {\r\n            for (int j = i + 1; j < rc; j++) {\r\n                if (isZero(res[i] - res[j])) {\r\n                    break out;\r\n                }\r\n            }\r\n            res[tc++] = res[i];\r\n        }\r\n    }\r\n    return tc;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.contacts.Contact.mixRestitution",
	"Comment": "restitution mixing law. the idea is allow for anything to bounce off an inelastic surface. forexample, a superball bounces on anything.",
	"Method": "float mixRestitution(float restitution1,float restitution2){\r\n    return restitution1 > restitution2 ? restitution1 : restitution2;\r\n}"
}, {
	"Path": "com.google.cloud.vision.samples.automl.ModelApi.listModelEvaluations",
	"Comment": "demonstrates using the automl client to list model evaluations.",
	"Method": "void listModelEvaluations(String projectId,String computeRegion,String modelId,String filter){\r\n    AutoMlClient client = AutoMlClient.create();\r\n    ModelName modelFullId = ModelName.of(projectId, computeRegion, modelId);\r\n    ListModelEvaluationsRequest modelEvaluationsrequest = ListModelEvaluationsRequest.newBuilder().setParent(modelFullId.toString()).setFilter(filter).build();\r\n    System.out.println(\"List of model evaluations:\");\r\n    for (ModelEvaluation element : client.listModelEvaluations(modelEvaluationsrequest).iterateAll()) {\r\n        System.out.println(element);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.pdfcleanup.PdfCleanUpRegionFilter.getCoveredAreas",
	"Comment": "calculates intersection of the image and the render filter region in the coordinate system relative to the image.",
	"Method": "List<Rectangle> getCoveredAreas(ImageRenderInfo renderInfo){\r\n    Rectangle imageRect = calcImageRect(renderInfo);\r\n    List<Rectangle> coveredAreas = new ArrayList<Rectangle>();\r\n    if (imageRect == null) {\r\n        return null;\r\n    }\r\n    for (Rectangle rectangle : rectangles) {\r\n        Rectangle intersectionRect = intersection(imageRect, rectangle);\r\n        if (intersectionRect != null) {\r\n            if (imageRect.equals(intersectionRect)) {\r\n                return null;\r\n            }\r\n            coveredAreas.add(transformIntersection(renderInfo.getImageCTM(), intersectionRect));\r\n        }\r\n    }\r\n    return coveredAreas;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaAnnotation.createAnnotation",
	"Comment": "creates the actual annotation and adds different elements to the\tpdfwriter while doing so.",
	"Method": "PdfAnnotation createAnnotation(){\r\n    if (richMediaContent != null) {\r\n        if (!assetsmap.isEmpty()) {\r\n            PdfDictionary assets = PdfNameTree.writeTree(assetsmap, writer);\r\n            richMediaContent.put(PdfName.ASSETS, writer.addToBody(assets).getIndirectReference());\r\n        }\r\n        if (configurations.size() > 0) {\r\n            richMediaContent.put(PdfName.CONFIGURATION, writer.addToBody(configurations).getIndirectReference());\r\n        }\r\n        if (views.size() > 0) {\r\n            richMediaContent.put(PdfName.VIEWS, writer.addToBody(views).getIndirectReference());\r\n        }\r\n        richMediaContentReference = writer.addToBody(richMediaContent).getIndirectReference();\r\n    }\r\n    writer.addDeveloperExtension(PdfDeveloperExtension.ADOBE_1_7_EXTENSIONLEVEL3);\r\n    annot.put(PdfName.RICHMEDIACONTENT, richMediaContentReference);\r\n    annot.put(PdfName.RICHMEDIASETTINGS, writer.addToBody(richMediaSettings).getIndirectReference());\r\n    return annot;\r\n}"
}, {
	"Path": "com.google.cloud.language.samples.Analyze.entitySentimentFile",
	"Comment": "identifies the entity sentiments in the the gcs hosted file using the language beta api.",
	"Method": "void entitySentimentFile(String gcsUri){\r\n    try (LanguageServiceClient language = LanguageServiceClient.create()) {\r\n        Document doc = Document.newBuilder().setGcsContentUri(gcsUri).setType(Type.PLAIN_TEXT).build();\r\n        AnalyzeEntitySentimentRequest request = AnalyzeEntitySentimentRequest.newBuilder().setDocument(doc).setEncodingType(EncodingType.UTF16).build();\r\n        AnalyzeEntitySentimentResponse response = language.analyzeEntitySentiment(request);\r\n        for (Entity entity : response.getEntitiesList()) {\r\n            System.out.printf(\"Entity: %s\\n\", entity.getName());\r\n            System.out.printf(\"Salience: %.3f\\n\", entity.getSalience());\r\n            System.out.printf(\"Sentiment : %s\\n\", entity.getSentiment());\r\n            for (EntityMention mention : entity.getMentionsList()) {\r\n                System.out.printf(\"Begin offset: %d\\n\", mention.getText().getBeginOffset());\r\n                System.out.printf(\"Content: %s\\n\", mention.getText().getContent());\r\n                System.out.printf(\"Magnitude: %.3f\\n\", mention.getSentiment().getMagnitude());\r\n                System.out.printf(\"Sentiment score : %.3f\\n\", mention.getSentiment().getScore());\r\n                System.out.printf(\"Type: %s\\n\\n\", mention.getType());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.DistanceJoint.getReactionTorque",
	"Comment": "get the reaction torque given the inverse time step. unit is nm. this is always zero for adistance joint.",
	"Method": "float getReactionTorque(float inv_dt){\r\n    return 0.0f;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPTable.getWidthPercentage",
	"Comment": "gets the width percentage that the table will occupy in the page.",
	"Method": "float getWidthPercentage(){\r\n    return widthPercentage;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.XfdfReader.getFields",
	"Comment": "gets all the fields. the map is keyed by the fully qualifiedfield name and the value is a merged pdfdictionarywith the field content.",
	"Method": "HashMap<String, String> getFields(){\r\n    return fields;\r\n}"
}, {
	"Path": "com.itextpdf.text.FontFactory.registerDirectory",
	"Comment": "register all the fonts in a directory and possibly its subdirectories.",
	"Method": "int registerDirectory(String dir,int registerDirectory,String dir,boolean scanSubdirectories){\r\n    return fontImp.registerDirectory(dir, scanSubdirectories);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Barcode39.createAwtImage",
	"Comment": "creates a java.awt.image. this image onlycontains the bars without any text.",
	"Method": "java.awt.Image createAwtImage(java.awt.Color foreground,java.awt.Color background){\r\n    int f = foreground.getRGB();\r\n    int g = background.getRGB();\r\n    java.awt.Canvas canvas = new java.awt.Canvas();\r\n    String bCode = code;\r\n    if (extended)\r\n        bCode = getCode39Ex(code);\r\n    if (generateChecksum)\r\n        bCode += getChecksum(bCode);\r\n    int len = bCode.length() + 2;\r\n    int nn = (int) n;\r\n    int fullWidth = len * (6 + 3 * nn) + (len - 1);\r\n    byte[] bars = getBarsCode39(bCode);\r\n    boolean print = true;\r\n    int ptr = 0;\r\n    int height = (int) barHeight;\r\n    int[] pix = new int[fullWidth * height];\r\n    for (int k = 0; k < bars.length; ++k) {\r\n        int w = (bars[k] == 0 ? 1 : nn);\r\n        int c = g;\r\n        if (print)\r\n            c = f;\r\n        print = !print;\r\n        for (int j = 0; j < w; ++j) pix[ptr++] = c;\r\n    }\r\n    for (int k = fullWidth; k < pix.length; k += fullWidth) {\r\n        System.arraycopy(pix, 0, pix, k, fullWidth);\r\n    }\r\n    java.awt.Image img = canvas.createImage(new java.awt.image.MemoryImageSource(fullWidth, height, pix, 0, fullWidth));\r\n    return img;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDocument.open",
	"Comment": "opens the document.you have to open the document before you can begin to add contentto the body of the document.",
	"Method": "void open(){\r\n    if (!open) {\r\n        super.open();\r\n        writer.open();\r\n        rootOutline = new PdfOutline(writer);\r\n        currentOutline = rootOutline;\r\n    }\r\n    try {\r\n        if (isTagged(writer)) {\r\n            openMCDocument = true;\r\n        }\r\n        initPage();\r\n    } catch (DocumentException de) {\r\n        throw new ExceptionConverter(de);\r\n    }\r\n}"
}, {
	"Path": "com.sixt.service.framework.servicetest.mockservice.ServiceImpersonator.publishEvent",
	"Comment": "publish an event to kafka. we create one publisher per topic.uses a null key.",
	"Method": "void publishEvent(String topic,Message event){\r\n    publishEventWithKey(topic, null, event);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.enumerateTTCNames",
	"Comment": "enumerates the postscript font names present inside atrue type collection.",
	"Method": "String[] enumerateTTCNames(String ttcFile,String[] enumerateTTCNames,byte ttcArray){\r\n    return new EnumerateTTC(ttcArray).getNames();\r\n}"
}, {
	"Path": "com.itextpdf.text.Section.setNotAddedYet",
	"Comment": "sets the indication if the section was already added to\tthe document.",
	"Method": "void setNotAddedYet(boolean notAddedYet){\r\n    this.notAddedYet = notAddedYet;\r\n}"
}, {
	"Path": "com.structurizr.analysis.ComponentFinder.exclude",
	"Comment": "adds one or more regexes to the set of regexes that define which types should be excluded during the component finding process.",
	"Method": "void exclude(String regexes){\r\n    if (regexes != null) {\r\n        for (String regex : regexes) {\r\n            this.exclusions.add(Pattern.compile(regex));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.structurizr.view.Configuration.getTerminology",
	"Comment": "gets the terminology object associated with this workspace.",
	"Method": "Terminology getTerminology(){\r\n    return terminology;\r\n}"
}, {
	"Path": "com.itextpdf.text.zugferd.InvoiceDOM.removeEmptyNodes",
	"Comment": "it is forbidden for a zugferd xml to contain empty tags, hencewe use this method recursively to remove empty nodes.",
	"Method": "void removeEmptyNodes(Node node){\r\n    NodeList list = node.getChildNodes();\r\n    for (int i = list.getLength() - 1; i >= 0; i--) {\r\n        removeEmptyNodes(list.item(i));\r\n    }\r\n    boolean emptyElement = node.getNodeType() == Node.ELEMENT_NODE && node.getChildNodes().getLength() == 0;\r\n    boolean emptyText = node.getNodeType() == Node.TEXT_NODE && node.getNodeValue().trim().length() == 0;\r\n    if (emptyElement || emptyText) {\r\n        node.getParentNode().removeChild(node);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfArray.toPdf",
	"Comment": "writes the pdf representation of this pdfarray as an arrayof byte to the specified outputstream.",
	"Method": "void toPdf(PdfWriter writer,OutputStream os){\r\n    PdfWriter.checkPdfIsoConformance(writer, PdfIsoKeys.PDFISOKEY_OBJECT, this);\r\n    os.write('[');\r\n    Iterator<PdfObject> i = arrayList.iterator();\r\n    PdfObject object;\r\n    int type = 0;\r\n    if (i.hasNext()) {\r\n        object = i.next();\r\n        if (object == null)\r\n            object = PdfNull.PDFNULL;\r\n        object.toPdf(writer, os);\r\n    }\r\n    while (i.hasNext()) {\r\n        object = i.next();\r\n        if (object == null)\r\n            object = PdfNull.PDFNULL;\r\n        type = object.type();\r\n        if (type != PdfObject.ARRAY && type != PdfObject.DICTIONARY && type != PdfObject.NAME && type != PdfObject.STRING)\r\n            os.write(' ');\r\n        object.toPdf(writer, os);\r\n    }\r\n    os.write(']');\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.getMassData",
	"Comment": "get the mass data of the body. the rotational inertia is relative to the center of mass.",
	"Method": "void getMassData(MassData data){\r\n    data.mass = m_mass;\r\n    data.I = m_I + m_mass * (m_sweep.localCenter.x * m_sweep.localCenter.x + m_sweep.localCenter.y * m_sweep.localCenter.y);\r\n    data.center.x = m_sweep.localCenter.x;\r\n    data.center.y = m_sweep.localCenter.y;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfChunk.adjustLeft",
	"Comment": "correction for the tab position based on the left starting position.",
	"Method": "void adjustLeft(float newValue){\r\n    Object[] o = (Object[]) attributes.get(Chunk.TAB);\r\n    if (o != null) {\r\n        attributes.put(Chunk.TAB, new Object[] { o[0], o[1], o[2], new Float(newValue) });\r\n    }\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.Property.toJSONObject",
	"Comment": "converts a property file object into a jsonobject. the property file object is a table of name value pairs.",
	"Method": "JSONObject toJSONObject(java.util.Properties properties){\r\n    JSONObject jo = new JSONObject();\r\n    if (properties != null && !properties.isEmpty()) {\r\n        Enumeration enumProperties = properties.propertyNames();\r\n        while (enumProperties.hasMoreElements()) {\r\n            String name = (String) enumProperties.nextElement();\r\n            jo.put(name, properties.getProperty(name));\r\n        }\r\n    }\r\n    return jo;\r\n}"
}, {
	"Path": "com.structurizr.model.Element.getUrl",
	"Comment": "gets the url where more information about this element can be found.",
	"Method": "String getUrl(){\r\n    return url;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.PdfContentReaderTool.getXObjectDetail",
	"Comment": "displays a summary of the entries in the xobject dictionary for the stream",
	"Method": "String getXObjectDetail(PdfDictionary resourceDic){\r\n    StringBuilder sb = new StringBuilder();\r\n    PdfDictionary xobjects = resourceDic.getAsDict(PdfName.XOBJECT);\r\n    if (xobjects == null)\r\n        return \"No XObjects\";\r\n    for (PdfName entryName : xobjects.getKeys()) {\r\n        PdfStream xobjectStream = xobjects.getAsStream(entryName);\r\n        sb.append(\"------ \" + entryName + \" - subtype = \" + xobjectStream.get(PdfName.SUBTYPE) + \" = \" + xobjectStream.getAsNumber(PdfName.LENGTH) + \" bytes ------\\n\");\r\n        if (!xobjectStream.get(PdfName.SUBTYPE).equals(PdfName.IMAGE)) {\r\n            byte[] contentBytes = ContentByteUtils.getContentBytesFromContentObject(xobjectStream);\r\n            InputStream is = new ByteArrayInputStream(contentBytes);\r\n            int ch;\r\n            while ((ch = is.read()) != -1) {\r\n                sb.append((char) ch);\r\n            }\r\n            sb.append(\"------ \" + entryName + \" - subtype = \" + xobjectStream.get(PdfName.SUBTYPE) + \"End of Content\" + \"------\\n\");\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfCopy.copyArray",
	"Comment": "translate a prarray to a pdfarray. also translate all of the objects containedin it",
	"Method": "PdfArray copyArray(PdfArray in,boolean keepStruct,boolean directRootKids,PdfArray copyArray,PdfArray in){\r\n    return copyArray(in, false, false);\r\n}"
}, {
	"Path": "com.structurizr.model.CodeElement.getUrl",
	"Comment": "gets the url where more information about this code element can be found.",
	"Method": "String getUrl(){\r\n    return url;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.FontDetails.setSubset",
	"Comment": "indicates if all the glyphs and widths for that particularencoding should be included in the document. set to falseto include all.",
	"Method": "void setSubset(boolean subset){\r\n    this.subset = subset;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.RootStoreVerifier.setRootStore",
	"Comment": "sets the key store against which a certificate can be checked.",
	"Method": "void setRootStore(KeyStore keyStore){\r\n    this.rootStore = keyStore;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.spatial.MeasureGeospatial.setDisplayCoordinateSystem",
	"Comment": "optional coordinate system that allows a document to be authored\tto display values in a coordinate system other than that associated\twith the source data. for example, a map may be created in a state\tplane coordinate system based on a 1927 datum, but it is possible\tto display its latitude and longitude values in the wgs84 datum\tcorresponding to values reported by a gps device.",
	"Method": "void setDisplayCoordinateSystem(GeographicCoordinateSystem cs){\r\n    super.put(PdfName.DCS, cs);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.events.PdfPageEventForwarder.onSection",
	"Comment": "called when a section is written.\tposition will hold the height at which the section will be\twritten to.",
	"Method": "void onSection(PdfWriter writer,Document document,float paragraphPosition,int depth,Paragraph title){\r\n    for (PdfPageEvent event : events) {\r\n        event.onSection(writer, document, paragraphPosition, depth, title);\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.DistanceJointDef.initialize",
	"Comment": "initialize the bodies, anchors, and length using the world anchors.",
	"Method": "void initialize(Body b1,Body b2,Vec2 anchor1,Vec2 anchor2){\r\n    bodyA = b1;\r\n    bodyB = b2;\r\n    localAnchorA.set(bodyA.getLocalPoint(anchor1));\r\n    localAnchorB.set(bodyB.getLocalPoint(anchor2));\r\n    Vec2 d = anchor2.sub(anchor1);\r\n    length = d.length();\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONWriter.endArray",
	"Comment": "end an array. this method most be called to balance calls toarray.",
	"Method": "JSONWriter endArray(){\r\n    return this.end('a', ']');\r\n}"
}, {
	"Path": "com.itextpdf.text.zugferd.InvoiceDOM.check",
	"Comment": "checks if a string is empty and throws a dataincompleteexception if so.",
	"Method": "void check(String s,String message){\r\n    if (s == null || s.trim().length() == 0)\r\n        throw new DataIncompleteException(message);\r\n}"
}, {
	"Path": "com.itextpdf.awt.geom.GeneralPath.checkBuf",
	"Comment": "checks points and types buffer size to add pointcount points. if necessary realloc buffers to enlarge size.",
	"Method": "void checkBuf(int pointCount,boolean checkMove){\r\n    if (checkMove && typeSize == 0) {\r\n        throw new IllegalPathStateException(Messages.getString(\"awt.20A\"));\r\n    }\r\n    if (typeSize == types.length) {\r\n        byte[] tmp = new byte[typeSize + BUFFER_CAPACITY];\r\n        System.arraycopy(types, 0, tmp, 0, typeSize);\r\n        types = tmp;\r\n    }\r\n    if (pointSize + pointCount > points.length) {\r\n        float[] tmp = new float[pointSize + Math.max(BUFFER_CAPACITY * 2, pointCount)];\r\n        System.arraycopy(points, 0, tmp, 0, pointSize);\r\n        points = tmp;\r\n    }\r\n}"
}, {
	"Path": "com.example.cloud.iot.examples.HttpExample.getConfig",
	"Comment": "publish an event or state message using cloud iot core via the http api.",
	"Method": "void getConfig(String urlPath,String token,String projectId,String cloudRegion,String registryId,String deviceId,String version){\r\n    String devicePath = String.format(\"projects/%s/locations/%s/registries/%s/devices/%s\", projectId, cloudRegion, registryId, deviceId);\r\n    urlPath = urlPath + devicePath + \"/config?local_version=\" + version;\r\n    HttpRequestFactory requestFactory = HTTP_TRANSPORT.createRequestFactory(new HttpRequestInitializer() {\r\n        @Override\r\n        public void initialize(HttpRequest request) {\r\n            request.setParser(new JsonObjectParser(JSON_FACTORY));\r\n        }\r\n    });\r\n    final HttpRequest req = requestFactory.buildGetRequest(new GenericUrl(urlPath));\r\n    HttpHeaders heads = new HttpHeaders();\r\n    heads.setAuthorization(String.format(\"Bearer %s\", token));\r\n    heads.setContentType(\"application/json; charset=UTF-8\");\r\n    heads.setCacheControl(\"no-cache\");\r\n    req.setHeaders(heads);\r\n    ExponentialBackOff backoff = new ExponentialBackOff.Builder().setInitialIntervalMillis(500).setMaxElapsedTimeMillis(900000).setMaxIntervalMillis(6000).setMultiplier(1.5).setRandomizationFactor(0.5).build();\r\n    req.setUnsuccessfulResponseHandler(new HttpBackOffUnsuccessfulResponseHandler(backoff));\r\n    HttpResponse res = req.execute();\r\n    System.out.println(res.getStatusCode());\r\n    System.out.println(res.getStatusMessage());\r\n    InputStream in = res.getContent();\r\n    System.out.println(CharStreams.toString(new InputStreamReader(in, Charsets.UTF_8)));\r\n}"
}, {
	"Path": "com.example.cloud.iot.examples.HttpExample.getConfig",
	"Comment": "publish an event or state message using cloud iot core via the http api.",
	"Method": "void getConfig(String urlPath,String token,String projectId,String cloudRegion,String registryId,String deviceId,String version){\r\n    request.setParser(new JsonObjectParser(JSON_FACTORY));\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.zip.BitInputStream.nrBits",
	"Comment": "get the number of bits that have been read from this bitinputstream.this includes pad bits that have been skipped, but might not includebytes that have been read from the underlying inputstream that have notyet been delivered as bits.",
	"Method": "long nrBits(){\r\n    return this.nrBits;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BidiLine.processLTR",
	"Comment": "method that changes a string with arabic characters into a string in which the ligatures are made.",
	"Method": "String processLTR(String s,int runDirection,int arabicOptions){\r\n    BidiLine bidi = new BidiLine();\r\n    bidi.addChunk(new PdfChunk(new Chunk(s), null));\r\n    bidi.arabicOptions = arabicOptions;\r\n    bidi.getParagraph(runDirection);\r\n    ArrayList<PdfChunk> arr = bidi.createArrayOfPdfChunks(0, bidi.totalTextLength - 1);\r\n    StringBuilder sb = new StringBuilder();\r\n    for (PdfChunk ck : arr) {\r\n        sb.append(ck.toString());\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.itextpdf.text.Phrase.getContent",
	"Comment": "returns the content as a string object.this method differs from tostring because tostring will return an arraylist with the tostring value of the chunks in this phrase.",
	"Method": "String getContent(){\r\n    StringBuffer buf = new StringBuffer();\r\n    for (Chunk c : getChunks()) {\r\n        buf.append(c.toString());\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfLayer.getPdfObject",
	"Comment": "gets the dictionary representing the layer. it just returns this.",
	"Method": "PdfObject getPdfObject(){\r\n    return this;\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.parser.XMLParser.unknownData",
	"Comment": "triggered when the unknownstate encountered anything before encounteringa tag.",
	"Method": "void unknownData(){\r\n    for (XMLParserListener l : listeners) {\r\n        l.unknownText(this.memory.current().toString());\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.LongHashtable.put",
	"Comment": "maps the specified key to the specifiedvalue in this hashtable. the key cannot benull. the value can be retrieved by calling the get methodwith a key that is equal to the original key.",
	"Method": "long put(long key,long value){\r\n    Entry[] tab = table;\r\n    int hash = (int) (key ^ (key >>> 32));\r\n    int index = (hash & 0x7FFFFFFF) % tab.length;\r\n    for (Entry e = tab[index]; e != null; e = e.next) {\r\n        if (e.hash == hash && e.key == key) {\r\n            long old = e.value;\r\n            e.value = value;\r\n            return old;\r\n        }\r\n    }\r\n    if (count >= threshold) {\r\n        rehash();\r\n        tab = table;\r\n        index = (hash & 0x7FFFFFFF) % tab.length;\r\n    }\r\n    Entry e = new Entry(hash, key, value, tab[index]);\r\n    tab[index] = e;\r\n    count++;\r\n    return 0;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDocument.newLine",
	"Comment": "adds the current line to the list of lines and also adds an empty line.",
	"Method": "void newLine(){\r\n    lastElementType = -1;\r\n    carriageReturn();\r\n    if (lines != null && !lines.isEmpty()) {\r\n        lines.add(line);\r\n        currentHeight += line.height();\r\n    }\r\n    line = new PdfLine(indentLeft(), indentRight(), alignment, leading);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPTable.setSkipFirstHeader",
	"Comment": "skips the printing of the first header. used when printing tables insuccession belonging to the same printed table aspect.",
	"Method": "void setSkipFirstHeader(boolean skipFirstHeader){\r\n    this.skipFirstHeader = skipFirstHeader;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.AcroFields.setExtraMargin",
	"Comment": "sets extra margins in text fields to better mimic the acrobat layout.",
	"Method": "void setExtraMargin(float extraMarginLeft,float extraMarginTop){\r\n    this.extraMarginLeft = extraMarginLeft;\r\n    this.extraMarginTop = extraMarginTop;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.StackOpp",
	"Comment": "function checks the key and return the change to the stack after the operator",
	"Method": "int StackOpp(){\r\n    if (key == \"ifelse\")\r\n        return -3;\r\n    if (key == \"roll\" || key == \"put\")\r\n        return -2;\r\n    if (key == \"callsubr\" || key == \"callgsubr\" || key == \"add\" || key == \"sub\" || key == \"div\" || key == \"mul\" || key == \"drop\" || key == \"and\" || key == \"or\" || key == \"eq\")\r\n        return -1;\r\n    if (key == \"abs\" || key == \"neg\" || key == \"sqrt\" || key == \"exch\" || key == \"index\" || key == \"get\" || key == \"not\" || key == \"return\")\r\n        return 0;\r\n    if (key == \"random\" || key == \"dup\")\r\n        return 1;\r\n    return 2;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.TrueTypeFont.getNames",
	"Comment": "extracts the names of the font in all the languages available.",
	"Method": "String[][] getNames(int id){\r\n    int[] table_location;\r\n    table_location = tables.get(\"name\");\r\n    if (table_location == null)\r\n        throw new DocumentException(MessageLocalization.getComposedMessage(\"table.1.does.not.exist.in.2\", \"name\", fileName + style));\r\n    rf.seek(table_location[0] + 2);\r\n    int numRecords = rf.readUnsignedShort();\r\n    int startOfStorage = rf.readUnsignedShort();\r\n    ArrayList<String[]> names = new ArrayList<String[]>();\r\n    for (int k = 0; k < numRecords; ++k) {\r\n        int platformID = rf.readUnsignedShort();\r\n        int platformEncodingID = rf.readUnsignedShort();\r\n        int languageID = rf.readUnsignedShort();\r\n        int nameID = rf.readUnsignedShort();\r\n        int length = rf.readUnsignedShort();\r\n        int offset = rf.readUnsignedShort();\r\n        if (nameID == id) {\r\n            int pos = (int) rf.getFilePointer();\r\n            rf.seek(table_location[0] + startOfStorage + offset);\r\n            String name;\r\n            if (platformID == 0 || platformID == 3 || platformID == 2 && platformEncodingID == 1) {\r\n                name = readUnicodeString(length);\r\n            } else {\r\n                name = readStandardString(length);\r\n            }\r\n            names.add(new String[] { String.valueOf(platformID), String.valueOf(platformEncodingID), String.valueOf(languageID), name });\r\n            rf.seek(pos);\r\n        }\r\n    }\r\n    String[][] thisName = new String[names.size()][];\r\n    for (int k = 0; k < names.size(); ++k) thisName[k] = names.get(k);\r\n    return thisName;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.BodyDef.setLinearDamping",
	"Comment": "linear damping is use to reduce the linear velocity. the damping parameter can be larger than1.0f but the damping effect becomes sensitive to the time step when the damping parameter islarge.",
	"Method": "void setLinearDamping(float linearDamping){\r\n    this.linearDamping = linearDamping;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.AcroFields.getFields",
	"Comment": "gets all the fields. the fields are keyed by the fully qualified field name andthe value is an instance of acrofields.item.",
	"Method": "Map<String, Item> getFields(){\r\n    return fields;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.PdfContentStreamProcessor.getFont",
	"Comment": "gets the font pointed to by the indirect reference. the font may have been cached.",
	"Method": "CMapAwareDocumentFont getFont(PRIndirectReference ind,CMapAwareDocumentFont getFont,PdfDictionary fontResource){\r\n    return new CMapAwareDocumentFont(fontResource);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.XmlSignatureAppearance.getXpathConstructor",
	"Comment": "constructor for xpath expression in case signing only part of xml document.",
	"Method": "XpathConstructor getXpathConstructor(){\r\n    return xpathConstructor;\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.parser.XMLParserMemory.getAttributes",
	"Comment": "returns a map of all attributes and their value found on the current tag.",
	"Method": "Map<String, String> getAttributes(){\r\n    return new LinkedHashMap<String, String>(this.attr);\r\n}"
}, {
	"Path": "com.itextpdf.text.Chunk.setUnderline",
	"Comment": "sets an horizontal line that can be an underline or a strikethrough.\tactually, the line can be anywhere vertically and has always the \tchunk width. multiple call to this method will produce multiple\tlines.",
	"Method": "Chunk setUnderline(float thickness,float yPosition,Chunk setUnderline,BaseColor color,float thickness,float thicknessMul,float yPosition,float yPositionMul,int cap){\r\n    if (attributes == null)\r\n        attributes = new HashMap<String, Object>();\r\n    Object[] obj = { color, new float[] { thickness, thicknessMul, yPosition, yPositionMul, cap } };\r\n    Object[][] unders = Utilities.addToArray((Object[][]) attributes.get(UNDERLINE), obj);\r\n    return setAttribute(UNDERLINE, unders);\r\n}"
}, {
	"Path": "com.structurizr.view.ElementStyle.getDescription",
	"Comment": "determines whether the element description should be shown or not.",
	"Method": "Boolean getDescription(){\r\n    return description;\r\n}"
}, {
	"Path": "com.structurizr.io.plantuml.PlantUMLWriter.toStdOut",
	"Comment": "write the views in the given workspace as plantuml definitions, to stdout.",
	"Method": "void toStdOut(Workspace workspace){\r\n    if (workspace == null) {\r\n        throw new IllegalArgumentException(\"A workspace must be provided.\");\r\n    }\r\n    StringWriter stringWriter = new StringWriter();\r\n    write(workspace, stringWriter);\r\n    System.out.println(stringWriter.toString());\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.Path.getCurrentPoint",
	"Comment": "the current point is the trailing endpoint of the segment most recently added to the current path.",
	"Method": "Point2D getCurrentPoint(){\r\n    return currentPoint;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.XMPPathFactory.composeStructFieldPath",
	"Comment": "compose the path expression for a field in a struct. the result can be added to the\tpath of",
	"Method": "String composeStructFieldPath(String fieldNS,String fieldName){\r\n    assertFieldNS(fieldNS);\r\n    assertFieldName(fieldName);\r\n    XMPPath fieldPath = XMPPathParser.expandXPath(fieldNS, fieldName);\r\n    if (fieldPath.size() != 2) {\r\n        throw new XMPException(\"The field name must be simple\", XMPError.BADXPATH);\r\n    }\r\n    return '/' + fieldPath.getSegment(XMPPath.STEP_ROOT_PROP).getName();\r\n}"
}, {
	"Path": "com.itextpdf.text.io.StreamUtil.inputStreamToArray",
	"Comment": "reads the full content of a stream and returns them in a byte array",
	"Method": "byte[] inputStreamToArray(InputStream is){\r\n    byte[] b = new byte[8192];\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    while (true) {\r\n        int read = is.read(b);\r\n        if (read < 1)\r\n            break;\r\n        out.write(b, 0, read);\r\n    }\r\n    out.close();\r\n    return out.toByteArray();\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.setSleepingAllowed",
	"Comment": "you can disable sleeping on this body. if you disable sleeping, the body will be woken.",
	"Method": "void setSleepingAllowed(boolean flag){\r\n    if (flag) {\r\n        m_flags |= e_autoSleepFlag;\r\n    } else {\r\n        m_flags &= ~e_autoSleepFlag;\r\n        setAwake(true);\r\n    }\r\n}"
}, {
	"Path": "com.example.firestore.snippets.QueryDataSnippets.createRangeWithOrderByQuery",
	"Comment": "creates a query using a range where clause with order by. order by must be based on the samefield as the range clause.",
	"Method": "Query createRangeWithOrderByQuery(){\r\n    CollectionReference cities = db.collection(\"cities\");\r\n    Query query = cities.whereGreaterThan(\"population\", 2500000L).orderBy(\"population\");\r\n    return query;\r\n}"
}, {
	"Path": "com.itextpdf.text.Phrase.addChunk",
	"Comment": "adds a chunk.this method is a hack to solve a problem i had with phrases that were split between chunksin the wrong place.",
	"Method": "boolean addChunk(Chunk chunk){\r\n    Font f = chunk.getFont();\r\n    String c = chunk.getContent();\r\n    if (font != null && !font.isStandardFont()) {\r\n        f = font.difference(chunk.getFont());\r\n    }\r\n    if (size() > 0 && !chunk.hasAttributes()) {\r\n        try {\r\n            Chunk previous = (Chunk) get(size() - 1);\r\n            PdfName previousRole = previous.getRole();\r\n            PdfName chunkRole = chunk.getRole();\r\n            boolean sameRole;\r\n            if (previousRole == null || chunkRole == null)\r\n                sameRole = true;\r\n            else\r\n                sameRole = previousRole.equals(chunkRole);\r\n            if (sameRole && !previous.hasAttributes() && !chunk.hasAccessibleAttributes() && !previous.hasAccessibleAttributes() && (f == null || f.compareTo(previous.getFont()) == 0) && !\"\".equals(previous.getContent().trim()) && !\"\".equals(c.trim())) {\r\n                previous.append(c);\r\n                return true;\r\n            }\r\n        } catch (ClassCastException cce) {\r\n        }\r\n    }\r\n    Chunk newChunk = new Chunk(c, f);\r\n    newChunk.setAttributes(chunk.getAttributes());\r\n    newChunk.role = chunk.getRole();\r\n    newChunk.accessibleAttributes = chunk.getAccessibleAttributes();\r\n    if (hyphenation != null && newChunk.getHyphenation() == null && !newChunk.isEmpty()) {\r\n        newChunk.setHyphenation(hyphenation);\r\n    }\r\n    return super.add(newChunk);\r\n}"
}, {
	"Path": "com.google.cloud.storage.storagetransfer.samples.test.NearlineRequesterTest.testRun",
	"Comment": "tests whether nearlinerequester executes a request to create a transferjob.",
	"Method": "void testRun(){\r\n    System.setProperty(\"projectId\", PROJECT_ID);\r\n    System.setProperty(\"jobDescription\", \"Sample transfer job from GCS to GCS Nearline.\");\r\n    System.setProperty(\"gcsSourceBucket\", PROJECT_ID + \"-storagetransfer-source\");\r\n    System.setProperty(\"gcsNearlineSinkBucket\", PROJECT_ID + \"-storagetransfer-sink\");\r\n    System.setProperty(\"startDate\", \"2000-01-01\");\r\n    System.setProperty(\"startTime\", \"00:00:00\");\r\n    ByteArrayOutputStream outBytes = new ByteArrayOutputStream();\r\n    PrintStream outStream = new PrintStream(outBytes);\r\n    NearlineRequester.run(outStream);\r\n    String out = outBytes.toString();\r\n    assertThat(out).contains(\"\\\"description\\\" : \\\"Sample transfer job from GCS to GCS Nearline.\\\"\");\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.WriteBuffer.writeBytesSlow",
	"Comment": "slow in the sense that we do all kind of block boundary checking",
	"Method": "void writeBytesSlow(byte[] bytes,int off,int len){\r\n    while (len > 0) {\r\n        final Block block = current;\r\n        final int amount = Math.min(len, block.remaining());\r\n        System.arraycopy(bytes, off, block.data, block.limit, amount);\r\n        block.limit += amount;\r\n        off += amount;\r\n        len -= amount;\r\n        if (block.remaining() == 0) {\r\n            if (index == blocks.size() - 1) {\r\n                allocateNewBlock();\r\n            }\r\n            index++;\r\n            current = blocks.get(index);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.getContactList",
	"Comment": "get the world contact list. with the returned contact, use contact.getnext to get the nextcontact in the world list. a null contact indicates the end of the list.",
	"Method": "Contact getContactList(){\r\n    return m_contactManager.m_contactList;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.spatial.MeasureGeospatial.setDisplayUnits",
	"Comment": "three names that identify in order a linear display unit, an area display\tunit, and an angular display unit.",
	"Method": "void setDisplayUnits(Linear l,Square s,Angular a){\r\n    PdfArray arr = new PdfArray();\r\n    arr.add(l.getPdfName());\r\n    arr.add(s.getPdfName());\r\n    arr.add(a.getPdfName());\r\n    super.put(PdfName.PDU, arr);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.CalcBias",
	"Comment": "function calcs bias according to the charstring type and the count\tof the subrs",
	"Method": "int CalcBias(int Offset,int Font){\r\n    seek(Offset);\r\n    int nSubrs = getCard16();\r\n    if (fonts[Font].CharstringType == 1)\r\n        return 0;\r\n    else if (nSubrs < 1240)\r\n        return 107;\r\n    else if (nSubrs < 33900)\r\n        return 1131;\r\n    else\r\n        return 32768;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONArray.length",
	"Comment": "get the number of elements in the jsonarray, included nulls.",
	"Method": "int length(){\r\n    return this.myArrayList.size();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.getImportedPage",
	"Comment": "use this method to get a page from other pdf document.the page can be used as any other pdftemplate.note that calling this method more than once with the same parameterswill retrieve the same object.",
	"Method": "PdfImportedPage getImportedPage(PdfReader reader,int pageNumber){\r\n    return getPdfReaderInstance(reader).getImportedPage(pageNumber);\r\n}"
}, {
	"Path": "org.jbake.app.AssetTest.testWriteProtected",
	"Comment": "primary intention is to extend test cases to increase coverage.",
	"Method": "void testWriteProtected(){\r\n    File assets = new File(config.getSourceFolder(), \"assets\");\r\n    final File cssFile = new File(folder.newFolder(\"css\"), \"bootstrap.min.css\");\r\n    FileUtils.touch(cssFile);\r\n    cssFile.setReadOnly();\r\n    config.setAssetFolder(assets);\r\n    config.setDestinationFolder(folder.getRoot());\r\n    Asset asset = new Asset(config);\r\n    asset.copy();\r\n    Assert.assertFalse(\"At least one error during copy expected\", asset.getErrors().isEmpty());\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfPTable.setSkipLastFooter",
	"Comment": "skips the printing of the last footer. used when printing tables insuccession belonging to the same printed table aspect.",
	"Method": "void setSkipLastFooter(boolean skipLastFooter){\r\n    this.skipLastFooter = skipLastFooter;\r\n}"
}, {
	"Path": "com.example.firestore.snippets.ManageDataSnippets.addDocumentDataWithAutoGeneratedId",
	"Comment": "add a document without explicitly providing the document id. the document id gets automaticallygenerated.",
	"Method": "String addDocumentDataWithAutoGeneratedId(){\r\n    Map<String, Object> data = new HashMap();\r\n    data.put(\"name\", \"Tokyo\");\r\n    data.put(\"country\", \"Japan\");\r\n    ApiFuture<DocumentReference> addedDocRef = db.collection(\"cities\").add(data);\r\n    System.out.println(\"Added document with ID: \" + addedDocRef.get().getId());\r\n    return addedDocRef.get().getId();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.mc.StructureItem.getPageref",
	"Comment": "returns the number of the page object to which the structure item belongs.",
	"Method": "int getPageref(){\r\n    return pageref;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.lite.ReverseBinaryEncoder.writeIonValue",
	"Comment": "writes the ionvalue and its nested values recursively, includingannotations.",
	"Method": "void writeIonValue(IonValue value){\r\n    final int valueOffset = myBuffer.length - myOffset;\r\n    switch(value.getType()) {\r\n        case BLOB:\r\n            writeIonBlobContent((IonBlob) value);\r\n            break;\r\n        case BOOL:\r\n            writeIonBoolContent((IonBool) value);\r\n            break;\r\n        case CLOB:\r\n            writeIonClobContent((IonClob) value);\r\n            break;\r\n        case DECIMAL:\r\n            writeIonDecimalContent((IonDecimal) value);\r\n            break;\r\n        case FLOAT:\r\n            writeIonFloatContent((IonFloat) value);\r\n            break;\r\n        case INT:\r\n            writeIonIntContent((IonInt) value);\r\n            break;\r\n        case NULL:\r\n            writeIonNullContent();\r\n            break;\r\n        case STRING:\r\n            writeIonStringContent((IonString) value);\r\n            break;\r\n        case SYMBOL:\r\n            writeIonSymbolContent((IonSymbol) value);\r\n            break;\r\n        case TIMESTAMP:\r\n            writeIonTimestampContent((IonTimestamp) value);\r\n            break;\r\n        case LIST:\r\n            writeIonListContent((IonList) value);\r\n            break;\r\n        case SEXP:\r\n            writeIonSexpContent((IonSexp) value);\r\n            break;\r\n        case STRUCT:\r\n            writeIonStructContent((IonStruct) value);\r\n            break;\r\n        case DATAGRAM:\r\n            writeIonDatagramContent((IonDatagram) value);\r\n            break;\r\n        default:\r\n            throw new IonException(\"IonType is unknown: \" + value.getType());\r\n    }\r\n    writeAnnotations(value, valueOffset);\r\n}"
}, {
	"Path": "com.ulisesbocchio.jasyptspringboot.EncryptablePropertySourceConverter.needsProxyAnyway",
	"Comment": "some spring boot code actually casts property sources to this specific type so must be proxied.",
	"Method": "boolean needsProxyAnyway(PropertySource<?> ps,boolean needsProxyAnyway,Class<? extends PropertySource<?>> psClass,boolean needsProxyAnyway,String className){\r\n    return Stream.of(\"org.springframework.boot.context.config.ConfigFileApplicationListener$ConfigurationPropertySources\", \"org.springframework.boot.context.properties.source.ConfigurationPropertySourcesPropertySource\").anyMatch(className::equals);\r\n}"
}, {
	"Path": "com.structurizr.view.RelationshipView.getRelationship",
	"Comment": "gets the relationship that this relationshipview represents.",
	"Method": "Relationship getRelationship(){\r\n    return relationship;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentByte.restoreState",
	"Comment": "restores the graphic state. savestate andrestorestate must be balanced.",
	"Method": "void restoreState(){\r\n    PdfWriter.checkPdfIsoConformance(writer, PdfIsoKeys.PDFISOKEY_CANVAS, \"Q\");\r\n    if (inText && isTagged()) {\r\n        endText();\r\n    }\r\n    content.append(\"Q\").append_i(separator);\r\n    int idx = stateList.size() - 1;\r\n    if (idx < 0)\r\n        throw new IllegalPdfSyntaxException(MessageLocalization.getComposedMessage(\"unbalanced.save.restore.state.operators\"));\r\n    state.restore(stateList.get(idx));\r\n    stateList.remove(idx);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.XfaForm.getTemplateSom",
	"Comment": "gets the class that contains the template processing section of the xfa.",
	"Method": "Xml2SomTemplate getTemplateSom(){\r\n    return templateSom;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.destroyJoint",
	"Comment": "destroy a joint. this may cause the connected bodies to begin colliding.",
	"Method": "void destroyJoint(Joint j){\r\n    assert (isLocked() == false);\r\n    if (isLocked()) {\r\n        return;\r\n    }\r\n    boolean collideConnected = j.getCollideConnected();\r\n    if (j.m_prev != null) {\r\n        j.m_prev.m_next = j.m_next;\r\n    }\r\n    if (j.m_next != null) {\r\n        j.m_next.m_prev = j.m_prev;\r\n    }\r\n    if (j == m_jointList) {\r\n        m_jointList = j.m_next;\r\n    }\r\n    Body bodyA = j.getBodyA();\r\n    Body bodyB = j.getBodyB();\r\n    bodyA.setAwake(true);\r\n    bodyB.setAwake(true);\r\n    if (j.m_edgeA.prev != null) {\r\n        j.m_edgeA.prev.next = j.m_edgeA.next;\r\n    }\r\n    if (j.m_edgeA.next != null) {\r\n        j.m_edgeA.next.prev = j.m_edgeA.prev;\r\n    }\r\n    if (j.m_edgeA == bodyA.m_jointList) {\r\n        bodyA.m_jointList = j.m_edgeA.next;\r\n    }\r\n    j.m_edgeA.prev = null;\r\n    j.m_edgeA.next = null;\r\n    if (j.m_edgeB.prev != null) {\r\n        j.m_edgeB.prev.next = j.m_edgeB.next;\r\n    }\r\n    if (j.m_edgeB.next != null) {\r\n        j.m_edgeB.next.prev = j.m_edgeB.prev;\r\n    }\r\n    if (j.m_edgeB == bodyB.m_jointList) {\r\n        bodyB.m_jointList = j.m_edgeB.next;\r\n    }\r\n    j.m_edgeB.prev = null;\r\n    j.m_edgeB.next = null;\r\n    Joint.destroy(j);\r\n    assert (m_jointCount > 0);\r\n    --m_jointCount;\r\n    if (collideConnected == false) {\r\n        ContactEdge edge = bodyB.getContactList();\r\n        while (edge != null) {\r\n            if (edge.other == bodyA) {\r\n                edge.contact.flagForFiltering();\r\n            }\r\n            edge = edge.next;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.CRLVerifier.isSignatureValid",
	"Comment": "checks if a crl verifies against the issuer certificate or a trusted anchor.",
	"Method": "boolean isSignatureValid(X509CRL crl,X509Certificate crlIssuer){\r\n    if (crlIssuer != null) {\r\n        try {\r\n            crl.verify(crlIssuer.getPublicKey());\r\n            return true;\r\n        } catch (GeneralSecurityException e) {\r\n            LOGGER.warn(\"CRL not issued by the same authority as the certificate that is being checked\");\r\n        }\r\n    }\r\n    if (rootStore == null)\r\n        return false;\r\n    try {\r\n        for (Enumeration<String> aliases = rootStore.aliases(); aliases.hasMoreElements(); ) {\r\n            String alias = aliases.nextElement();\r\n            try {\r\n                if (!rootStore.isCertificateEntry(alias))\r\n                    continue;\r\n                X509Certificate anchor = (X509Certificate) rootStore.getCertificate(alias);\r\n                crl.verify(anchor.getPublicKey());\r\n                return true;\r\n            } catch (GeneralSecurityException e) {\r\n                continue;\r\n            }\r\n        }\r\n    } catch (GeneralSecurityException e) {\r\n        return false;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.example.speech.Recognize.transcribeFileWithMetadata",
	"Comment": "transcribe the given audio file and include recognition metadata in the request.",
	"Method": "void transcribeFileWithMetadata(String fileName){\r\n    Path path = Paths.get(fileName);\r\n    byte[] content = Files.readAllBytes(path);\r\n    try (SpeechClient speechClient = SpeechClient.create()) {\r\n        RecognitionAudio recognitionAudio = RecognitionAudio.newBuilder().setContent(ByteString.copyFrom(content)).build();\r\n        RecognitionMetadata metadata = // Some metadata fields are free form strings\r\n        RecognitionMetadata.newBuilder().setInteractionType(InteractionType.DISCUSSION).setMicrophoneDistance(MicrophoneDistance.NEARFIELD).setRecordingDeviceType(RecordingDeviceType.SMARTPHONE).setRecordingDeviceName(// https://www.naics.com/search/\r\n        \"Pixel 2 XL\").setIndustryNaicsCodeOfAudio(519190).build();\r\n        RecognitionConfig config = // Add the metadata to the config\r\n        RecognitionConfig.newBuilder().setEncoding(AudioEncoding.LINEAR16).setLanguageCode(\"en-US\").setSampleRateHertz(8000).setMetadata(metadata).build();\r\n        RecognizeResponse recognizeResponse = speechClient.recognize(config, recognitionAudio);\r\n        for (SpeechRecognitionResult result : recognizeResponse.getResultsList()) {\r\n            SpeechRecognitionAlternative alternative = result.getAlternatives(0);\r\n            System.out.format(\"Transcript: %s\\n\\n\", alternative.getTranscript());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.cloud.language.samples.DatasetApi.exportData",
	"Comment": "demonstrates using the automl client to export a dataset to a google cloud storage bucket.",
	"Method": "void exportData(String projectId,String computeRegion,String datasetId,String gcsUri){\r\n    AutoMlClient client = AutoMlClient.create();\r\n    DatasetName datasetFullId = DatasetName.of(projectId, computeRegion, datasetId);\r\n    GcsDestination gcsDestination = GcsDestination.newBuilder().setOutputUriPrefix(gcsUri).build();\r\n    OutputConfig outputConfig = OutputConfig.newBuilder().setGcsDestination(gcsDestination).build();\r\n    System.out.println(String.format(\"Processing export...\"));\r\n    Empty response = client.exportDataAsync(datasetFullId, outputConfig).get();\r\n    System.out.println(String.format(\"Dataset exported. %s\", response));\r\n}"
}, {
	"Path": "com.example.appengine.sockets.WhoIsClientServlet.doWhoIs",
	"Comment": "open a socket to the whois server, write out the query, and receivethe results.",
	"Method": "String doWhoIs(String server,int port,String name){\r\n    Socket socket = null;\r\n    try {\r\n        socket = new Socket(server, port);\r\n        Writer out = new OutputStreamWriter(socket.getOutputStream(), \"8859_1\");\r\n        socket.setSoTimeout(10000);\r\n        Reader recv = new InputStreamReader(socket.getInputStream(), \"8859_1\");\r\n        out.write(\"=\" + name + \"\\r\\n\");\r\n        out.flush();\r\n        StringBuilder builder = new StringBuilder();\r\n        for (int c = 0; (c = recv.read()) != -1; ) {\r\n            builder.append(String.valueOf((char) c));\r\n        }\r\n        return builder.toString();\r\n    } catch (IOException e) {\r\n        String message = \"whois server failed: \" + server + \" exception:\" + e.toString();\r\n        log.warning(message);\r\n        return message;\r\n    } finally {\r\n        try {\r\n            if (socket != null) {\r\n                socket.close();\r\n            }\r\n        } catch (IOException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfLayerMembership.setVisibilityPolicy",
	"Comment": "sets the visibility policy for content belonging to thismembership dictionary. possible values are allon, anyon, anyoff and alloff.the default value is anyon.",
	"Method": "void setVisibilityPolicy(PdfName type){\r\n    put(PdfName.P, type);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaActivation.setScripts",
	"Comment": "sets an array of indirect object references to file specification\tdictionaries, each of which describe a javascript file that shall\tbe present in the assets name tree of the richmediacontent dictionary.",
	"Method": "void setScripts(PdfArray scripts){\r\n    put(PdfName.SCRIPTS, scripts);\r\n}"
}, {
	"Path": "com.itextpdf.awt.geom.gl.Crossing.intersectShape",
	"Comment": "returns how many times rectangle stripe cross shape or the are intersect",
	"Method": "int intersectShape(Shape s,double x,double y,double w,double h){\r\n    if (!s.getBounds2D().intersects(x, y, w, h)) {\r\n        return 0;\r\n    }\r\n    return intersectPath(s.getPathIterator(null), x, y, w, h);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.ColumnText.setFilledWidth",
	"Comment": "sets the real width used by the largest line. only used to set it to zeroto start another measurement.",
	"Method": "void setFilledWidth(float filledWidth){\r\n    this.filledWidth = filledWidth;\r\n}"
}, {
	"Path": "com.example.iap.BuildIapRequest.buildIapRequest",
	"Comment": "clone request and add an iap bearer authorization header with signed jwt token.",
	"Method": "HttpRequest buildIapRequest(HttpRequest request,String iapClientId){\r\n    ServiceAccountCredentials credentials = getCredentials();\r\n    String jwt = getSignedJwt(credentials, iapClientId);\r\n    if (jwt == null) {\r\n        throw new Exception(\"Unable to create a signed jwt token for : \" + iapClientId + \"with issuer : \" + credentials.getClientEmail());\r\n    }\r\n    String idToken = getGoogleIdToken(jwt);\r\n    if (idToken == null) {\r\n        throw new Exception(\"Unable to retrieve open id token\");\r\n    }\r\n    HttpHeaders httpHeaders = request.getHeaders().clone().setAuthorization(\"Bearer \" + idToken);\r\n    return httpTransport.createRequestFactory().buildRequest(request.getRequestMethod(), request.getUrl(), request.getContent()).setHeaders(httpHeaders);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfReader.getOffsetTokeniser",
	"Comment": "utility method that checks the provided byte source to see if it has junk bytes at the beginning.if junk bytesare found, construct a tokeniser that ignores the junk.otherwise, construct a tokeniser for the byte source as it is",
	"Method": "PRTokeniser getOffsetTokeniser(RandomAccessSource byteSource){\r\n    PRTokeniser tok = new PRTokeniser(new RandomAccessFileOrArray(byteSource));\r\n    int offset = tok.getHeaderOffset();\r\n    if (offset != 0) {\r\n        RandomAccessSource offsetSource = new WindowRandomAccessSource(byteSource, offset);\r\n        tok = new PRTokeniser(new RandomAccessFileOrArray(offsetSource));\r\n    }\r\n    return tok;\r\n}"
}, {
	"Path": "org.jbox2d.collision.Collision.getPointStates",
	"Comment": "compute the point states given two manifolds. the states pertain to the transition frommanifold1 to manifold2. so state1 is either persist or remove while state2 is either add orpersist.",
	"Method": "void getPointStates(PointState[] state1,PointState[] state2,Manifold manifold1,Manifold manifold2){\r\n    for (int i = 0; i < Settings.maxManifoldPoints; i++) {\r\n        state1[i] = PointState.NULL_STATE;\r\n        state2[i] = PointState.NULL_STATE;\r\n    }\r\n    for (int i = 0; i < manifold1.pointCount; i++) {\r\n        ContactID id = manifold1.points[i].id;\r\n        state1[i] = PointState.REMOVE_STATE;\r\n        for (int j = 0; j < manifold2.pointCount; j++) {\r\n            if (manifold2.points[j].id.isEqual(id)) {\r\n                state1[i] = PointState.PERSIST_STATE;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < manifold2.pointCount; i++) {\r\n        ContactID id = manifold2.points[i].id;\r\n        state2[i] = PointState.ADD_STATE;\r\n        for (int j = 0; j < manifold1.pointCount; j++) {\r\n            if (manifold1.points[j].id.isEqual(id)) {\r\n                state2[i] = PointState.PERSIST_STATE;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.DocWriter.writeMarkupAttributes",
	"Comment": "writes the markup attributes of the specified markupattributesobject to the outputstream.",
	"Method": "boolean writeMarkupAttributes(Properties markup){\r\n    if (markup == null)\r\n        return false;\r\n    Iterator<Object> attributeIterator = markup.keySet().iterator();\r\n    String name;\r\n    while (attributeIterator.hasNext()) {\r\n        name = String.valueOf(attributeIterator.next());\r\n        write(name, markup.getProperty(name));\r\n    }\r\n    markup.clear();\r\n    return true;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.XML.noSpace",
	"Comment": "throw an exception if the string contains whitespace.whitespace is not allowed in tagnames and attributes.",
	"Method": "void noSpace(String string){\r\n    int i, length = string.length();\r\n    if (length == 0) {\r\n        throw new JSONException(\"Empty string.\");\r\n    }\r\n    for (i = 0; i < length; i += 1) {\r\n        if (Character.isWhitespace(string.charAt(i))) {\r\n            throw new JSONException(\"'\" + string + \"' contains a space character.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.List.isAutoindent",
	"Comment": "checks if the indentation of list items is done automatically.",
	"Method": "boolean isAutoindent(){\r\n    return autoindent;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.Reconstruct",
	"Comment": "function reconstructs the fdarray, privatedict and lsubr for cid fonts",
	"Method": "void Reconstruct(int Font){\r\n    OffsetItem[] fdPrivate = new DictOffsetItem[fonts[Font].FDArrayOffsets.length - 1];\r\n    IndexBaseItem[] fdPrivateBase = new IndexBaseItem[fonts[Font].fdprivateOffsets.length];\r\n    OffsetItem[] fdSubrs = new DictOffsetItem[fonts[Font].fdprivateOffsets.length];\r\n    ReconstructFDArray(Font, fdPrivate);\r\n    ReconstructPrivateDict(Font, fdPrivate, fdPrivateBase, fdSubrs);\r\n    ReconstructPrivateSubrs(Font, fdPrivateBase, fdSubrs);\r\n}"
}, {
	"Path": "com.google.cloud.vision.samples.facedetect.FaceDetectApp.getVisionService",
	"Comment": "connects to the vision api using application default credentials.",
	"Method": "Vision getVisionService(){\r\n    GoogleCredential credential = GoogleCredential.getApplicationDefault().createScoped(VisionScopes.all());\r\n    JsonFactory jsonFactory = JacksonFactory.getDefaultInstance();\r\n    return new Vision.Builder(GoogleNetHttpTransport.newTrustedTransport(), jsonFactory, credential).setApplicationName(APPLICATION_NAME).build();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.mc.MCParser.convertToXObject",
	"Comment": "converts an annotation structure item to a form xobject annotation.",
	"Method": "void convertToXObject(StructureObject item){\r\n    PdfDictionary structElem = item.getStructElem();\r\n    if (structElem == null)\r\n        return;\r\n    PdfDictionary dict = item.getObjAsDict();\r\n    if (dict == null || !dict.checkType(PdfName.ANNOT))\r\n        return;\r\n    PdfDictionary ap = dict.getAsDict(PdfName.AP);\r\n    if (ap == null)\r\n        return;\r\n    PdfNumber structParent = dict.getAsNumber(PdfName.STRUCTPARENT);\r\n    if (structParent == null)\r\n        return;\r\n    PdfStream stream = ap.getAsStream(PdfName.N);\r\n    if (stream == null)\r\n        return;\r\n    PdfIndirectReference xobjr = ap.getAsIndirectObject(PdfName.N);\r\n    if (xobjr == null)\r\n        return;\r\n    for (int i = 0; i < annots.size(); i++) {\r\n        PdfIndirectReference annotref = annots.getAsIndirectObject(i);\r\n        if (item.getObjRef().getNumber() == annotref.getNumber()) {\r\n            annots.remove(i);\r\n            break;\r\n        }\r\n    }\r\n    PdfDictionary attribute = new PdfDictionary();\r\n    attribute.put(PdfName.O, PdfName.PRINTFIELD);\r\n    PdfString description = dict.getAsString(PdfName.TU);\r\n    if (description == null)\r\n        description = dict.getAsString(PdfName.T);\r\n    if (PdfName.BTN.equals(dict.get(PdfName.FT))) {\r\n        PdfNumber fflags = dict.getAsNumber(PdfName.FF);\r\n        if (fflags != null) {\r\n            int ff = fflags.intValue();\r\n            if ((ff & PdfFormField.FF_PUSHBUTTON) != 0)\r\n                attribute.put(PdfName.ROLE, PdfName.PB);\r\n            if ((ff & PdfFormField.FF_RADIO) != 0)\r\n                attribute.put(PdfName.ROLE, PdfName.rb);\r\n            else\r\n                attribute.put(PdfName.ROLE, PdfName.CB);\r\n        }\r\n    } else {\r\n        attribute.put(PdfName.ROLE, PdfName.TV);\r\n    }\r\n    attribute.put(PdfName.DESC, description);\r\n    PdfString t = structElem.getAsString(PdfName.T);\r\n    if (t == null || t.toString().trim().length() == 0)\r\n        structElem.put(PdfName.T, dict.getAsString(PdfName.T));\r\n    structElem.put(PdfName.A, attribute);\r\n    structElem.put(PdfName.S, PdfName.P);\r\n    structElem.put(PdfName.PG, pageref);\r\n    int mcid = items.processMCID(structParents, item.getRef());\r\n    LOGGER.info(\"Using MCID \" + mcid);\r\n    structElem.put(PdfName.K, new PdfNumber(mcid));\r\n    items.removeFromParentTree(structParent);\r\n    PdfName xobj = new PdfName(\"XObj\" + structParent.intValue());\r\n    LOGGER.info(\"Creating XObject with name \" + xobj);\r\n    xobjects.put(xobj, xobjr);\r\n    PdfArray array = dict.getAsArray(PdfName.RECT);\r\n    Rectangle rect = new Rectangle(array.getAsNumber(0).floatValue(), array.getAsNumber(1).floatValue(), array.getAsNumber(2).floatValue(), array.getAsNumber(3).floatValue());\r\n    rect.normalize();\r\n    if (inText && !btWrite) {\r\n        LOGGER.debug(\"Introducing extra ET\");\r\n        baos.write(\"ET\\n\".getBytes());\r\n        etExtra = true;\r\n    }\r\n    ByteBuffer buf = new ByteBuffer();\r\n    buf.append(\"/P <<\/MCID \");\r\n    buf.append(mcid);\r\n    buf.append(\">> BDC\\n\");\r\n    buf.append(\"q 1 0 0 1 \");\r\n    buf.append(rect.getLeft());\r\n    buf.append(\" \");\r\n    buf.append(rect.getBottom());\r\n    buf.append(\" cm \");\r\n    buf.append(xobj.getBytes());\r\n    buf.append(\" Do Q\\n\");\r\n    buf.append(\"EMC\\n\");\r\n    buf.flush();\r\n    buf.writeTo(baos);\r\n    if (inText)\r\n        btWrite = true;\r\n}"
}, {
	"Path": "com.itextpdf.text.List.normalizeIndentation",
	"Comment": "makes sure all the items in the list have the same indentation.",
	"Method": "void normalizeIndentation(){\r\n    float max = 0;\r\n    for (Element o : list) {\r\n        if (o instanceof ListItem) {\r\n            max = Math.max(max, ((ListItem) o).getIndentationLeft());\r\n        }\r\n    }\r\n    for (Element o : list) {\r\n        if (o instanceof ListItem) {\r\n            ((ListItem) o).setIndentationLeft(max);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "software.amazon.ion.impl.PrivateUtils.isTrivialTable",
	"Comment": "is the table null, system, or local without imported symbols?",
	"Method": "boolean isTrivialTable(SymbolTable table){\r\n    if (table == null)\r\n        return true;\r\n    if (table.isSystemTable())\r\n        return true;\r\n    if (table.isLocalTable()) {\r\n        if (table.getMaxId() == table.getSystemSymbolTable().getMaxId()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.Vector.dot",
	"Comment": "computes the dot product of this vector with the specified vector",
	"Method": "float dot(Vector with){\r\n    return vals[I1] * with.vals[I1] + vals[I2] * with.vals[I2] + vals[I3] * with.vals[I3];\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfGState.setTextKnockout",
	"Comment": "determines the behavior of overlapping glyphs within a text objectin the transparent imaging model.",
	"Method": "void setTextKnockout(boolean tk){\r\n    put(PdfName.TK, tk ? PdfBoolean.PDFTRUE : PdfBoolean.PDFFALSE);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BarcodePDF417.paintCode",
	"Comment": "paints the barcode. if no exception was thrown a valid barcode is available.",
	"Method": "void paintCode(){\r\n    int maxErr, lenErr, tot, pad;\r\n    if ((options & PDF417_USE_RAW_CODEWORDS) != 0) {\r\n        if (lenCodewords > MAX_DATA_CODEWORDS || lenCodewords < 1 || lenCodewords != codewords[0]) {\r\n            throw new IllegalArgumentException(MessageLocalization.getComposedMessage(\"invalid.codeword.size\"));\r\n        }\r\n    } else {\r\n        if (text == null)\r\n            throw new NullPointerException(MessageLocalization.getComposedMessage(\"text.cannot.be.null\"));\r\n        if (text.length > ABSOLUTE_MAX_TEXT_SIZE) {\r\n            throw new IndexOutOfBoundsException(MessageLocalization.getComposedMessage(\"the.text.is.too.big\"));\r\n        }\r\n        segmentList = new SegmentList();\r\n        breakString();\r\n        assemble();\r\n        segmentList = null;\r\n        codewords[0] = lenCodewords = cwPtr;\r\n    }\r\n    maxErr = maxPossibleErrorLevel(MAX_DATA_CODEWORDS + 2 - lenCodewords);\r\n    if ((options & PDF417_USE_ERROR_LEVEL) == 0) {\r\n        if (lenCodewords < 41)\r\n            errorLevel = 2;\r\n        else if (lenCodewords < 161)\r\n            errorLevel = 3;\r\n        else if (lenCodewords < 321)\r\n            errorLevel = 4;\r\n        else\r\n            errorLevel = 5;\r\n    }\r\n    if (errorLevel < 0)\r\n        errorLevel = 0;\r\n    else if (errorLevel > maxErr)\r\n        errorLevel = maxErr;\r\n    if (codeColumns < 1)\r\n        codeColumns = 1;\r\n    else if (codeColumns > 30)\r\n        codeColumns = 30;\r\n    if (codeRows < 3)\r\n        codeRows = 3;\r\n    else if (codeRows > 90)\r\n        codeRows = 90;\r\n    lenErr = 2 << errorLevel;\r\n    boolean fixedColumn = (options & PDF417_FIXED_ROWS) == 0;\r\n    boolean skipRowColAdjust = false;\r\n    tot = lenCodewords + lenErr;\r\n    if ((options & PDF417_FIXED_RECTANGLE) != 0) {\r\n        tot = codeColumns * codeRows;\r\n        if (tot > MAX_DATA_CODEWORDS + 2) {\r\n            tot = getMaxSquare();\r\n        }\r\n        if (tot < lenCodewords + lenErr)\r\n            tot = lenCodewords + lenErr;\r\n        else\r\n            skipRowColAdjust = true;\r\n    } else if ((options & (PDF417_FIXED_COLUMNS | PDF417_FIXED_ROWS)) == 0) {\r\n        double c, b;\r\n        fixedColumn = true;\r\n        if (aspectRatio < 0.001)\r\n            aspectRatio = 0.001f;\r\n        else if (aspectRatio > 1000)\r\n            aspectRatio = 1000;\r\n        b = 73 * aspectRatio - 4;\r\n        c = (-b + Math.sqrt(b * b + 4 * 17 * aspectRatio * (lenCodewords + lenErr) * yHeight)) / (2 * 17 * aspectRatio);\r\n        codeColumns = (int) (c + 0.5);\r\n        if (codeColumns < 1)\r\n            codeColumns = 1;\r\n        else if (codeColumns > 30)\r\n            codeColumns = 30;\r\n    }\r\n    if (!skipRowColAdjust) {\r\n        if (fixedColumn) {\r\n            codeRows = (tot - 1) / codeColumns + 1;\r\n            if (codeRows < 3)\r\n                codeRows = 3;\r\n            else if (codeRows > 90) {\r\n                codeRows = 90;\r\n                codeColumns = (tot - 1) / 90 + 1;\r\n            }\r\n        } else {\r\n            codeColumns = (tot - 1) / codeRows + 1;\r\n            if (codeColumns > 30) {\r\n                codeColumns = 30;\r\n                codeRows = (tot - 1) / 30 + 1;\r\n            }\r\n        }\r\n        tot = codeRows * codeColumns;\r\n    }\r\n    if (tot > MAX_DATA_CODEWORDS + 2) {\r\n        tot = getMaxSquare();\r\n    }\r\n    errorLevel = maxPossibleErrorLevel(tot - lenCodewords);\r\n    lenErr = 2 << errorLevel;\r\n    pad = tot - lenErr - lenCodewords;\r\n    if ((options & PDF417_USE_MACRO) != 0) {\r\n        System.arraycopy(codewords, macroIndex, codewords, macroIndex + pad, lenCodewords - macroIndex);\r\n        cwPtr = lenCodewords + pad;\r\n        while (pad-- != 0) codewords[macroIndex++] = TEXT_MODE;\r\n    } else {\r\n        cwPtr = lenCodewords;\r\n        while (pad-- != 0) codewords[cwPtr++] = TEXT_MODE;\r\n    }\r\n    codewords[0] = lenCodewords = cwPtr;\r\n    calculateErrorCorrection(lenCodewords);\r\n    lenCodewords = tot;\r\n    outPaintCode();\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.pipeline.css.CssResolverPipeline.getContextKey",
	"Comment": "this allows the descendant classes to be fetched from the context.",
	"Method": "String getContextKey(){\r\n    return CssResolverPipeline.class.getName();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.addSubsetRange",
	"Comment": "adds a character range when subsetting. the range is an int arraywhere the first element is the start range inclusive and the second element is theend range inclusive. several ranges are allowed in the same array.",
	"Method": "void addSubsetRange(int[] range){\r\n    if (subsetRanges == null)\r\n        subsetRanges = new ArrayList<int[]>();\r\n    subsetRanges.add(range);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaInstance.setAsset",
	"Comment": "sets a dictionary that shall be an indirect object reference\tto a file specification dictionary that is also referenced\tin the assets name tree of the content of the annotation.",
	"Method": "void setAsset(PdfIndirectReference asset){\r\n    put(PdfName.ASSET, asset);\r\n}"
}, {
	"Path": "com.google.cloud.vision.samples.automl.DatasetApi.importData",
	"Comment": "demonstrates using the automl client to import labeled images.",
	"Method": "void importData(String projectId,String computeRegion,String datasetId,String path){\r\n    AutoMlClient client = AutoMlClient.create();\r\n    DatasetName datasetFullId = DatasetName.of(projectId, computeRegion, datasetId);\r\n    GcsSource.Builder gcsSource = GcsSource.newBuilder();\r\n    String[] inputUris = path.split(\",\");\r\n    for (String inputUri : inputUris) {\r\n        gcsSource.addInputUris(inputUri);\r\n    }\r\n    InputConfig inputConfig = InputConfig.newBuilder().setGcsSource(gcsSource).build();\r\n    System.out.println(\"Processing import...\");\r\n    Empty response = client.importDataAsync(datasetFullId.toString(), inputConfig).get();\r\n    System.out.println(String.format(\"Dataset imported. %s\", response));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.collection.PdfCollectionItem.setPrefix",
	"Comment": "adds a prefix for the collection item.\tyou can only use this method after you have set the value of the item.",
	"Method": "void setPrefix(String key,String prefix){\r\n    PdfName fieldname = new PdfName(key);\r\n    PdfObject o = get(fieldname);\r\n    if (o == null)\r\n        throw new IllegalArgumentException(MessageLocalization.getComposedMessage(\"you.must.set.a.value.before.adding.a.prefix\"));\r\n    PdfDictionary dict = new PdfDictionary(PdfName.COLLECTIONSUBITEM);\r\n    dict.put(PdfName.D, o);\r\n    dict.put(PdfName.P, new PdfString(prefix, PdfObject.TEXT_UNICODE));\r\n    put(fieldname, dict);\r\n}"
}, {
	"Path": "net.openhft.affinity.AffinityLock.cpuLayout",
	"Comment": "set the cpu layout for this machine.cpus which are not mentioned will be ignored. changing the layout will have no impact on thread which have already been assigned. it onlyaffects subsequent assignments.",
	"Method": "void cpuLayout(CpuLayout cpuLayout,CpuLayout cpuLayout){\r\n    return LOCK_INVENTORY.getCpuLayout();\r\n}"
}, {
	"Path": "org.jbox2d.collision.shapes.Shape.setRadius",
	"Comment": "sets the radius of the underlying shape. this can refer to different things depending on theimplementation",
	"Method": "void setRadius(float radius){\r\n    this.m_radius = radius;\r\n}"
}, {
	"Path": "com.itextpdf.text.html.simpleparser.HTMLWorker.processList",
	"Comment": "fetches the list from the stack and adds it to\tthe textelementarray on top of the stack,\tor to the document if the stack is empty.",
	"Method": "void processList(){\r\n    if (stack.empty())\r\n        return;\r\n    Element obj = stack.pop();\r\n    if (!(obj instanceof com.itextpdf.text.List)) {\r\n        stack.push(obj);\r\n        return;\r\n    }\r\n    if (stack.empty())\r\n        document.add(obj);\r\n    else\r\n        ((TextElementArray) stack.peek()).add(obj);\r\n}"
}, {
	"Path": "com.structurizr.view.RelationshipView.setRouting",
	"Comment": "sets the routing algorithm used when rendering this relationship.",
	"Method": "void setRouting(Routing routing){\r\n    this.routing = routing;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.CountCharset",
	"Comment": "calculates the length of the charset according to its format",
	"Method": "int CountCharset(int Offset,int NumofGlyphs){\r\n    int format;\r\n    int Length = 0;\r\n    seek(Offset);\r\n    format = getCard8();\r\n    switch(format) {\r\n        case 0:\r\n            Length = 1 + 2 * NumofGlyphs;\r\n            break;\r\n        case 1:\r\n            Length = 1 + 3 * CountRange(NumofGlyphs, 1);\r\n            break;\r\n        case 2:\r\n            Length = 1 + 4 * CountRange(NumofGlyphs, 2);\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    return Length;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.ParseRDF.parse",
	"Comment": "the main parsing method. the xml tree is walked through from the root node and and xmp tree\tis created. this is a raw parse, the normalisation of the xmp tree happens outside.",
	"Method": "XMPMetaImpl parse(Node xmlRoot){\r\n    XMPMetaImpl xmp = new XMPMetaImpl();\r\n    rdf_RDF(xmp, xmlRoot);\r\n    return xmp;\r\n}"
}, {
	"Path": "com.example.dlp.Metadata.listInfoTypes",
	"Comment": "list the types of sensitive information the dlp api supports.",
	"Method": "void listInfoTypes(String filter,String languageCode){\r\n    try (DlpServiceClient dlpClient = DlpServiceClient.create()) {\r\n        ListInfoTypesRequest listInfoTypesRequest = ListInfoTypesRequest.newBuilder().setFilter(filter).setLanguageCode(languageCode).build();\r\n        ListInfoTypesResponse infoTypesResponse = dlpClient.listInfoTypes(listInfoTypesRequest);\r\n        List<InfoTypeDescription> infoTypeDescriptions = infoTypesResponse.getInfoTypesList();\r\n        for (InfoTypeDescription infoTypeDescription : infoTypeDescriptions) {\r\n            System.out.println(\"Name : \" + infoTypeDescription.getName());\r\n            System.out.println(\"Display name : \" + infoTypeDescription.getDisplayName());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.setParticleGravityScale",
	"Comment": "change the particle gravity scale. adjusts the effect of the global gravity vector onparticles. default value is 1.0f.",
	"Method": "void setParticleGravityScale(float gravityScale){\r\n    m_particleSystem.setParticleGravityScale(gravityScale);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfSignatureAppearance.addFieldMDP",
	"Comment": "adds keys to the signature dictionary that definethe field permissions.this method is only used for signatures that lock fields.",
	"Method": "void addFieldMDP(PdfDictionary crypto,PdfDictionary fieldLock){\r\n    PdfDictionary reference = new PdfDictionary();\r\n    PdfDictionary transformParams = new PdfDictionary();\r\n    transformParams.putAll(fieldLock);\r\n    transformParams.put(PdfName.TYPE, PdfName.TRANSFORMPARAMS);\r\n    transformParams.put(PdfName.V, new PdfName(\"1.2\"));\r\n    reference.put(PdfName.TRANSFORMMETHOD, PdfName.FIELDMDP);\r\n    reference.put(PdfName.TYPE, PdfName.SIGREF);\r\n    reference.put(PdfName.TRANSFORMPARAMS, transformParams);\r\n    reference.put(new PdfName(\"DigestValue\"), new PdfString(\"aa\"));\r\n    PdfArray loc = new PdfArray();\r\n    loc.add(new PdfNumber(0));\r\n    loc.add(new PdfNumber(0));\r\n    reference.put(new PdfName(\"DigestLocation\"), loc);\r\n    reference.put(new PdfName(\"DigestMethod\"), new PdfName(\"MD5\"));\r\n    reference.put(PdfName.DATA, writer.reader.getTrailer().get(PdfName.ROOT));\r\n    PdfArray types = crypto.getAsArray(PdfName.REFERENCE);\r\n    if (types == null)\r\n        types = new PdfArray();\r\n    types.add(reference);\r\n    crypto.put(PdfName.REFERENCE, types);\r\n}"
}, {
	"Path": "com.itextpdf.text.List.setPostSymbol",
	"Comment": "sets the string that has to be added after a number or letter in the list symbol.",
	"Method": "void setPostSymbol(String postSymbol){\r\n    this.postSymbol = postSymbol;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfCopy.copyStream",
	"Comment": "translate a prstream to a pdfstream. the data part copies itself.",
	"Method": "PdfStream copyStream(PRStream in){\r\n    PRStream out = new PRStream(in, null);\r\n    for (Object element : in.getKeys()) {\r\n        PdfName key = (PdfName) element;\r\n        PdfObject value = in.get(key);\r\n        parentObjects.put(value, in);\r\n        PdfObject res = copyObject(value);\r\n        if (res != null)\r\n            out.put(key, res);\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "com.sixt.service.framework.kafka.KafkaPublisher.publishAsync",
	"Comment": "asynchronously publish one or more messages with a null partition key",
	"Method": "void publishAsync(String events){\r\n    if (events != null) {\r\n        publishEvents(false, null, events);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BarcodePDF417.setCodeColumns",
	"Comment": "sets the number of barcode data columns.this number may be changed to keep the barcode valid.",
	"Method": "void setCodeColumns(int codeColumns){\r\n    this.codeColumns = codeColumns;\r\n}"
}, {
	"Path": "com.example.logging.QuickstartSample.main",
	"Comment": "expects a new or existing stackdriver log name as the first argument.",
	"Method": "void main(String args){\r\n    Logging logging = LoggingOptions.getDefaultInstance().getService();\r\n    String logName = args[0];\r\n    String text = \"Hello, world!\";\r\n    LogEntry entry = LogEntry.newBuilder(StringPayload.of(text)).setSeverity(Severity.ERROR).setLogName(logName).setResource(MonitoredResource.newBuilder(\"global\").build()).build();\r\n    logging.write(Collections.singleton(entry));\r\n    System.out.printf(\"Logged: %s%n\", text);\r\n}"
}, {
	"Path": "com.example.texttospeech.SynthesizeText.synthesizeText",
	"Comment": "demonstrates using the text to speech client to synthesize text or ssml.",
	"Method": "void synthesizeText(String text){\r\n    try (TextToSpeechClient textToSpeechClient = TextToSpeechClient.create()) {\r\n        SynthesisInput input = SynthesisInput.newBuilder().setText(text).build();\r\n        VoiceSelectionParams voice = // languageCode = \"en_us\"\r\n        VoiceSelectionParams.newBuilder().setLanguageCode(// ssmlVoiceGender = SsmlVoiceGender.FEMALE\r\n        \"en-US\").setSsmlGender(SsmlVoiceGender.FEMALE).build();\r\n        AudioConfig audioConfig = // MP3 audio.\r\n        AudioConfig.newBuilder().setAudioEncoding(AudioEncoding.MP3).build();\r\n        SynthesizeSpeechResponse response = textToSpeechClient.synthesizeSpeech(input, voice, audioConfig);\r\n        ByteString audioContents = response.getAudioContent();\r\n        try (OutputStream out = new FileOutputStream(\"output.mp3\")) {\r\n            out.write(audioContents.toByteArray());\r\n            System.out.println(\"Audio content written to file \\\"output.mp3\\\"\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.Path.rectangle",
	"Comment": "appends a rectangle to the current path as a complete subpath.",
	"Method": "void rectangle(float x,float y,float w,float h){\r\n    moveTo(x, y);\r\n    lineTo(x + w, y);\r\n    lineTo(x + w, y + h);\r\n    lineTo(x, y + h);\r\n    closeSubpath();\r\n}"
}, {
	"Path": "net.openhft.affinity.NonForkingAffinityLock.acquireLock",
	"Comment": "assign a cpu which can be bound to the current thread or another thread.this can be used for defining your thread layout centrally and passing the handle via dependency injection.",
	"Method": "AffinityLock acquireLock(AffinityLock acquireLock,boolean bind,AffinityLock acquireLock,boolean bind,int cpuId,AffinityStrategy strategies){\r\n    return LOCK_INVENTORY.acquireLock(bind, cpuId, strategies);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.FixtureDef.getShape",
	"Comment": "the shape, this must be set. the shape will be cloned, so you can create the shape on thestack.",
	"Method": "Shape getShape(){\r\n    return shape;\r\n}"
}, {
	"Path": "com.structurizr.view.SystemLandscapeView.addNearestNeighbours",
	"Comment": "adds all software systems and people that are directly connected to the specified element.",
	"Method": "void addNearestNeighbours(Element element){\r\n    if (element == null) {\r\n        throw new IllegalArgumentException(\"An element must be specified.\");\r\n    }\r\n    if (element instanceof Person || element instanceof SoftwareSystem) {\r\n        super.addNearestNeighbours(element, Person.class);\r\n        super.addNearestNeighbours(element, SoftwareSystem.class);\r\n    } else {\r\n        throw new IllegalArgumentException(\"A person or software system must be specified.\");\r\n    }\r\n}"
}, {
	"Path": "com.example.dlp.RiskAnalysis.numericalStatsAnalysis",
	"Comment": "calculate numerical statistics for a column in a bigquery table using the dlp api.",
	"Method": "void numericalStatsAnalysis(String projectId,String datasetId,String tableId,String columnName,String topicId,String subscriptionId){\r\n    try (DlpServiceClient dlpServiceClient = DlpServiceClient.create()) {\r\n        BigQueryTable bigQueryTable = BigQueryTable.newBuilder().setTableId(tableId).setDatasetId(datasetId).setProjectId(projectId).build();\r\n        FieldId fieldId = FieldId.newBuilder().setName(columnName).build();\r\n        NumericalStatsConfig numericalStatsConfig = NumericalStatsConfig.newBuilder().setField(fieldId).build();\r\n        PrivacyMetric privacyMetric = PrivacyMetric.newBuilder().setNumericalStatsConfig(numericalStatsConfig).build();\r\n        String topicName = String.format(\"projects/%s/topics/%s\", projectId, topicId);\r\n        PublishToPubSub publishToPubSub = PublishToPubSub.newBuilder().setTopic(topicName).build();\r\n        Action action = Action.newBuilder().setPubSub(publishToPubSub).build();\r\n        RiskAnalysisJobConfig riskAnalysisJobConfig = RiskAnalysisJobConfig.newBuilder().setSourceTable(bigQueryTable).setPrivacyMetric(privacyMetric).addActions(action).build();\r\n        CreateDlpJobRequest createDlpJobRequest = CreateDlpJobRequest.newBuilder().setParent(ProjectName.of(projectId).toString()).setRiskJob(riskAnalysisJobConfig).build();\r\n        DlpJob dlpJob = dlpServiceClient.createDlpJob(createDlpJobRequest);\r\n        String dlpJobName = dlpJob.getName();\r\n        final SettableApiFuture<Boolean> done = SettableApiFuture.create();\r\n        Subscriber subscriber = Subscriber.newBuilder(ProjectSubscriptionName.newBuilder().setProject(projectId).setSubscription(subscriptionId).build(), (pubsubMessage, ackReplyConsumer) -> {\r\n            if (pubsubMessage.getAttributesCount() > 0 && pubsubMessage.getAttributesMap().get(\"DlpJobName\").equals(dlpJobName)) {\r\n                done.set(true);\r\n                ackReplyConsumer.ack();\r\n            }\r\n        }).build();\r\n        subscriber.startAsync();\r\n        try {\r\n            done.get(1, TimeUnit.MINUTES);\r\n            Thread.sleep(500);\r\n        } catch (TimeoutException e) {\r\n            System.out.println(\"Unable to verify job completion.\");\r\n        }\r\n        DlpJob completedJob = dlpServiceClient.getDlpJob(GetDlpJobRequest.newBuilder().setName(dlpJobName).build());\r\n        System.out.println(\"Job status: \" + completedJob.getState());\r\n        AnalyzeDataSourceRiskDetails riskDetails = completedJob.getRiskDetails();\r\n        AnalyzeDataSourceRiskDetails.NumericalStatsResult result = riskDetails.getNumericalStatsResult();\r\n        System.out.printf(\"Value range : [%.3f, %.3f]\\n\", result.getMinValue().getFloatValue(), result.getMaxValue().getFloatValue());\r\n        int percent = 1;\r\n        Double lastValue = null;\r\n        for (Value quantileValue : result.getQuantileValuesList()) {\r\n            Double currentValue = quantileValue.getFloatValue();\r\n            if (lastValue == null || !lastValue.equals(currentValue)) {\r\n                System.out.printf(\"Value at %s %% quantile : %.3f\", percent, currentValue);\r\n            }\r\n            lastValue = currentValue;\r\n        }\r\n    } catch (Exception e) {\r\n        System.out.println(\"Error in categoricalStatsAnalysis: \" + e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.getJointList",
	"Comment": "get the world joint list. with the returned joint, use joint.getnext to get the next joint inthe world list. a null joint indicates the end of the list.",
	"Method": "Joint getJointList(){\r\n    return m_jointList;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.XMLTokener.skipPast",
	"Comment": "skip characters until past the requested string.if it is not found, we are left at the end of the source with a result of false.",
	"Method": "boolean skipPast(String to){\r\n    boolean b;\r\n    char c;\r\n    int i;\r\n    int j;\r\n    int offset = 0;\r\n    int length = to.length();\r\n    char[] circle = new char[length];\r\n    for (i = 0; i < length; i += 1) {\r\n        c = next();\r\n        if (c == 0) {\r\n            return false;\r\n        }\r\n        circle[i] = c;\r\n    }\r\n    for (; ; ) {\r\n        j = offset;\r\n        b = true;\r\n        for (i = 0; i < length; i += 1) {\r\n            if (circle[j] != to.charAt(i)) {\r\n                b = false;\r\n                break;\r\n            }\r\n            j += 1;\r\n            if (j >= length) {\r\n                j -= length;\r\n            }\r\n        }\r\n        if (b) {\r\n            return true;\r\n        }\r\n        c = next();\r\n        if (c == 0) {\r\n            return false;\r\n        }\r\n        circle[offset] = c;\r\n        offset += 1;\r\n        if (offset >= length) {\r\n            offset -= length;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.cloud.language.samples.ModelApi.getModelEvaluation",
	"Comment": "demonstrates using the automl client to get model evaluations.",
	"Method": "void getModelEvaluation(String projectId,String computeRegion,String modelId,String modelEvaluationId){\r\n    AutoMlClient client = AutoMlClient.create();\r\n    ModelEvaluationName modelEvaluationFullId = ModelEvaluationName.of(projectId, computeRegion, modelId, modelEvaluationId);\r\n    ModelEvaluation response = client.getModelEvaluation(modelEvaluationFullId);\r\n    System.out.println(response);\r\n}"
}, {
	"Path": "com.itextpdf.text.Section.setBookmarkTitle",
	"Comment": "sets the bookmark title. the bookmark title is the same as the section title butcan be changed with this method.",
	"Method": "void setBookmarkTitle(String bookmarkTitle){\r\n    this.bookmarkTitle = bookmarkTitle;\r\n}"
}, {
	"Path": "com.structurizr.io.json.EncryptedJsonReader.read",
	"Comment": "reads and parses a workspace definition from a json document.",
	"Method": "EncryptedWorkspace read(Reader reader){\r\n    try {\r\n        ObjectMapper objectMapper = new ObjectMapper();\r\n        objectMapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\r\n        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\r\n        return objectMapper.readValue(reader, EncryptedWorkspace.class);\r\n    } catch (IOException ioe) {\r\n        throw new WorkspaceReaderException(\"Could not read JSON\", ioe);\r\n    }\r\n}"
}, {
	"Path": "com.google.cloud.vision.samples.automl.ModelApi.getOperationStatus",
	"Comment": "demonstrates using the automl client to get operation status.",
	"Method": "void getOperationStatus(String operationFullId){\r\n    AutoMlClient client = AutoMlClient.create();\r\n    Operation response = client.getOperationsClient().getOperation(operationFullId);\r\n    System.out.println(String.format(\"Operation status: %s\", response));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.table.KeepRowsTogetherTest.createTable",
	"Comment": "utility ethod that creates a table with 41 rows. one of which may or may not be a header.",
	"Method": "PdfPTable createTable(String headerText,boolean headerRows,int tableNumber,boolean skipFirstHeader){\r\n    PdfPTable table = new PdfPTable(1);\r\n    PdfPCell cell1 = new PdfPCell(new Paragraph(headerText));\r\n    table.addCell(cell1);\r\n    if (headerRows) {\r\n        table.setHeaderRows(1);\r\n        if (skipFirstHeader) {\r\n            table.setSkipFirstHeader(skipFirstHeader);\r\n        }\r\n    }\r\n    for (int i = 0; i < 40; i++) {\r\n        table.addCell(\"Tab \" + tableNumber + \", line \" + i);\r\n    }\r\n    return table;\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.symbolNameIterator",
	"Comment": "lazy iterator over the symbol names of an iterator of symbol tokens.",
	"Method": "Iterator<String> symbolNameIterator(Iterator<SymbolToken> tokenIter){\r\n    return new Iterator<String>() {\r\n        public boolean hasNext() {\r\n            return tokenIter.hasNext();\r\n        }\r\n        public String next() {\r\n            return tokenIter.next().getText();\r\n        }\r\n        public void remove() {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.symbolNameIterator",
	"Comment": "lazy iterator over the symbol names of an iterator of symbol tokens.",
	"Method": "Iterator<String> symbolNameIterator(Iterator<SymbolToken> tokenIter){\r\n    return tokenIter.hasNext();\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.symbolNameIterator",
	"Comment": "lazy iterator over the symbol names of an iterator of symbol tokens.",
	"Method": "Iterator<String> symbolNameIterator(Iterator<SymbolToken> tokenIter){\r\n    return tokenIter.next().getText();\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.Symbols.symbolNameIterator",
	"Comment": "lazy iterator over the symbol names of an iterator of symbol tokens.",
	"Method": "Iterator<String> symbolNameIterator(Iterator<SymbolToken> tokenIter){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.structurizr.view.ContainerView.addNearestNeighbours",
	"Comment": "adds all people, software systems and containers that are directly connected to the specified element.",
	"Method": "void addNearestNeighbours(Element element){\r\n    super.addNearestNeighbours(element, Person.class);\r\n    super.addNearestNeighbours(element, SoftwareSystem.class);\r\n    super.addNearestNeighbours(element, Container.class);\r\n}"
}, {
	"Path": "net.dv8tion.jda.bot.sharding.DefaultShardManagerBuilder.removeEventListenerProviders",
	"Comment": "removes all provided listener providers from the list of listener providers.",
	"Method": "DefaultShardManagerBuilder removeEventListenerProviders(Collection<IntFunction<Object>> listenerProviders){\r\n    Checks.noneNull(listenerProviders, \"listener providers\");\r\n    this.listenerProviders.removeAll(listenerProviders);\r\n    return this;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PushbuttonField.setIconFitToBounds",
	"Comment": "if true the icon will be scaled to fit fully within the bounds of the annotation,if false the border width will be taken into account. the defaultis false.",
	"Method": "void setIconFitToBounds(boolean iconFitToBounds){\r\n    this.iconFitToBounds = iconFitToBounds;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfArray.contains",
	"Comment": "checks if the pdfarray already contains a certainpdfobject.",
	"Method": "boolean contains(PdfObject object){\r\n    return arrayList.contains(object);\r\n}"
}, {
	"Path": "com.google.cloud.vision.samples.automl.ModelApi.displayEvaluation",
	"Comment": "demonstrates using the automl client to display model evaluation.",
	"Method": "void displayEvaluation(String projectId,String computeRegion,String modelId,String filter){\r\n    AutoMlClient client = AutoMlClient.create();\r\n    ModelName modelFullId = ModelName.of(projectId, computeRegion, modelId);\r\n    ListModelEvaluationsRequest modelEvaluationsrequest = ListModelEvaluationsRequest.newBuilder().setParent(modelFullId.toString()).setFilter(filter).build();\r\n    String modelEvaluationId = \"\";\r\n    for (ModelEvaluation element : client.listModelEvaluations(modelEvaluationsrequest).iterateAll()) {\r\n        if (element.getAnnotationSpecId() != null) {\r\n            modelEvaluationId = element.getName().split(\"/\")[element.getName().split(\"/\").length - 1];\r\n        }\r\n    }\r\n    ModelEvaluationName modelEvaluationFullId = ModelEvaluationName.of(projectId, computeRegion, modelId, modelEvaluationId);\r\n    ModelEvaluation modelEvaluation = client.getModelEvaluation(modelEvaluationFullId);\r\n    ClassificationEvaluationMetrics classMetrics = modelEvaluation.getClassificationEvaluationMetrics();\r\n    List<ConfidenceMetricsEntry> confidenceMetricsEntries = classMetrics.getConfidenceMetricsEntryList();\r\n    for (ConfidenceMetricsEntry confidenceMetricsEntry : confidenceMetricsEntries) {\r\n        if (confidenceMetricsEntry.getConfidenceThreshold() == 0.5) {\r\n            System.out.println(\"Precision and recall are based on a score threshold of 0.5\");\r\n            System.out.println(String.format(\"Model Precision: %.2f \", confidenceMetricsEntry.getPrecision() * 100) + '%');\r\n            System.out.println(String.format(\"Model Recall: %.2f \", confidenceMetricsEntry.getRecall() * 100) + '%');\r\n            System.out.println(String.format(\"Model F1 score: %.2f \", confidenceMetricsEntry.getF1Score() * 100) + '%');\r\n            System.out.println(String.format(\"Model Precision@1: %.2f \", confidenceMetricsEntry.getPrecisionAt1() * 100) + '%');\r\n            System.out.println(String.format(\"Model Recall@1: %.2f \", confidenceMetricsEntry.getRecallAt1() * 100) + '%');\r\n            System.out.println(String.format(\"Model F1 score@1: %.2f \", confidenceMetricsEntry.getF1ScoreAt1() * 100) + '%');\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jbox2d.testbed.framework.TestbedCamera.zoomToPoint",
	"Comment": "zooms the camera to a point on the screen. the zoom amount is given on camera initialization.",
	"Method": "void zoomToPoint(Vec2 screenPosition,ZoomType zoomType){\r\n    Mat22 zoom;\r\n    switch(zoomType) {\r\n        case ZOOM_IN:\r\n            zoom = upScale;\r\n            break;\r\n        case ZOOM_OUT:\r\n            zoom = downScale;\r\n            break;\r\n        default:\r\n            Preconditions.checkArgument(false, \"Zoom type invalid\");\r\n            return;\r\n    }\r\n    transform.getScreenToWorld(screenPosition, oldCenter);\r\n    transform.mulByTransform(zoom);\r\n    transform.getScreenToWorld(screenPosition, newCenter);\r\n    Vec2 transformedMove = oldCenter.subLocal(newCenter);\r\n    if (!transform.isYFlip()) {\r\n        transformedMove.y = -transformedMove.y;\r\n    }\r\n    transform.setCenter(transform.getCenter().addLocal(transformedMove));\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.html.AbstractTagProcessor.getCSSResolver",
	"Comment": "utility method that fetches the cssresolver from the if any and if it uses the default key.",
	"Method": "CSSResolver getCSSResolver(WorkerContext context){\r\n    return ((ObjectContext<CSSResolver>) context.get(CssResolverPipeline.class.getName())).get();\r\n}"
}, {
	"Path": "com.google.cloud.vision.samples.text.Index.lookup",
	"Comment": "looks up the set of documents containing each word. returns the intersection of these.",
	"Method": "ImmutableSet<String> lookup(Iterable<String> words){\r\n    HashSet<String> documents = null;\r\n    try (Jedis jedis = pool.getResource()) {\r\n        jedis.select(TOKEN_DB);\r\n        for (String word : words) {\r\n            word = stemmer.stem(word.toLowerCase()).toString();\r\n            if (documents == null) {\r\n                documents = new HashSet();\r\n                documents.addAll(jedis.smembers(word));\r\n            } else {\r\n                documents.retainAll(jedis.smembers(word));\r\n            }\r\n        }\r\n    }\r\n    if (documents == null) {\r\n        return ImmutableSet.<String>of();\r\n    }\r\n    return ImmutableSet.<String>copyOf(documents);\r\n}"
}, {
	"Path": "com.itextpdf.text.RectangleReadOnly.cloneNonPositionParameters",
	"Comment": "copies each of the parameters, except the position, from arectangle object",
	"Method": "void cloneNonPositionParameters(Rectangle rect){\r\n    throwReadOnlyError();\r\n}"
}, {
	"Path": "com.google.cloud.language.samples.AnalyzeBeta.main",
	"Comment": "detects entities,sentiment and syntax in a document using the natural language api.",
	"Method": "void main(String[] args){\r\n    if (args.length < 2 || args.length > 4) {\r\n        System.err.println(\"Usage:\");\r\n        System.err.printf(\"\\tjava %s \\\"command\\\" \\\"text to analyze\\\" \\\"language\\\" \\n\", Analyze.class.getCanonicalName());\r\n        System.exit(1);\r\n    }\r\n    String command = args[0];\r\n    String text = args[1];\r\n    String lang = null;\r\n    if (args.length > 2) {\r\n        lang = args[2];\r\n    }\r\n    if (command.equals(\"classify\")) {\r\n        if (text.startsWith(\"gs://\")) {\r\n            classifyFile(text);\r\n        } else {\r\n            classifyText(text);\r\n        }\r\n    } else if (command.equals(\"sentiment\")) {\r\n        analyzeSentimentText(text, lang);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.TextRenderInfo.getCharacterRenderInfos",
	"Comment": "provides detail useful if a listener needs access to the position of each individual glyph in the text render operation",
	"Method": "List<TextRenderInfo> getCharacterRenderInfos(){\r\n    List<TextRenderInfo> rslt = new ArrayList<TextRenderInfo>(string.length());\r\n    PdfString[] strings = splitString(string);\r\n    float totalWidth = 0;\r\n    for (int i = 0; i < strings.length; i++) {\r\n        float[] widthAndWordSpacing = getWidthAndWordSpacing(strings[i], true);\r\n        TextRenderInfo subInfo = new TextRenderInfo(this, strings[i], totalWidth);\r\n        rslt.add(subInfo);\r\n        totalWidth += (widthAndWordSpacing[0] * gs.fontSize + gs.characterSpacing + widthAndWordSpacing[1]) * gs.horizontalScaling;\r\n    }\r\n    for (TextRenderInfo tri : rslt) tri.getUnscaledWidth();\r\n    return rslt;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.draw.DottedLineSeparator.setGap",
	"Comment": "setter for the gap between the center of the dots of the dotted line.",
	"Method": "void setGap(float gap){\r\n    this.gap = gap;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfName.hashCode",
	"Comment": "returns a hash code value for the object.this method is supported for the benefit of hashtables such as those provided byjava.util.hashtable.",
	"Method": "int hashCode(){\r\n    int h = hash;\r\n    if (h == 0) {\r\n        int ptr = 0;\r\n        int len = bytes.length;\r\n        for (int i = 0; i < len; i++) h = 31 * h + (bytes[ptr++] & 0xff);\r\n        hash = h;\r\n    }\r\n    return h;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.BaseFont.getUnicodeDifferences",
	"Comment": "gets the unicode character corresponding to the byte output to the pdf stream.",
	"Method": "char getUnicodeDifferences(int index,char[] getUnicodeDifferences){\r\n    return unicodeDifferences;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfStamper.getAcroFields",
	"Comment": "gets the acrofields object that allows to get and set field valuesand to merge fdf forms.",
	"Method": "AcroFields getAcroFields(){\r\n    return stamper.getAcroFields();\r\n}"
}, {
	"Path": "com.itextpdf.testutils.CompareTool.setFloatAbsoluteError",
	"Comment": "sets the absolute error parameter which will be used in floating point numbers comparison.",
	"Method": "CompareTool setFloatAbsoluteError(float error){\r\n    this.floatComparisonError = error;\r\n    this.absoluteError = true;\r\n    return this;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.joints.FrictionJointDef.initialize",
	"Comment": "initialize the bodies, anchors, axis, and reference angle using the world anchor and worldaxis.",
	"Method": "void initialize(Body bA,Body bB,Vec2 anchor){\r\n    bodyA = bA;\r\n    bodyB = bB;\r\n    bA.getLocalPointToOut(anchor, localAnchorA);\r\n    bB.getLocalPointToOut(anchor, localAnchorB);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PushbuttonField.setIconVerticalAdjustment",
	"Comment": "a number between 0 and 1 indicating the fraction of leftover space to allocate at the bottom of the icon.a value of 0 positions the icon at the bottom of the annotation rectangle.a value of 0.5 centers it within the rectangle. the default is 0.5.",
	"Method": "void setIconVerticalAdjustment(float iconVerticalAdjustment){\r\n    if (iconVerticalAdjustment < 0)\r\n        iconVerticalAdjustment = 0;\r\n    else if (iconVerticalAdjustment > 1)\r\n        iconVerticalAdjustment = 1;\r\n    this.iconVerticalAdjustment = iconVerticalAdjustment;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPSerializerHelper.serialize",
	"Comment": "static method to serialize the metadata object. for each serialisation, a new xmpserializer\tinstance is created, either xmpserializerrdf or xmpserializerplain so thats its possible to \tserialialize the same xmpmeta objects in two threads.",
	"Method": "void serialize(XMPMetaImpl xmp,OutputStream out,SerializeOptions options){\r\n    options = options != null ? options : new SerializeOptions();\r\n    if (options.getSort()) {\r\n        xmp.sort();\r\n    }\r\n    new XMPSerializerRDF().serialize(xmp, out, options);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDocument.localGoto",
	"Comment": "implements a link to other part of the document. the jump willbe made to a local destination with the same name, that must exist.",
	"Method": "void localGoto(String name,float llx,float lly,float urx,float ury){\r\n    PdfAction action = getLocalGotoAction(name);\r\n    annotationsImp.addPlainAnnotation(writer.createAnnotation(llx, lly, urx, ury, action, null));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.SignaturePermissions.isAnnotationsAllowed",
	"Comment": "getter to find out if adding annotations is allowed after signing.",
	"Method": "boolean isAnnotationsAllowed(){\r\n    return annotationsAllowed;\r\n}"
}, {
	"Path": "com.itextpdf.text.xml.simpleparser.SimpleXMLParserTest.whitespaceHtml",
	"Comment": "validate correct whitespace handling of simplexmlhandler.\tcarriage return received as text instead of space.",
	"Method": "void whitespaceHtml(){\r\n    String whitespace = \"<p>sometext\\r moretext<\/p>\";\r\n    String expected = \"sometext moretext\";\r\n    final StringBuilder b = new StringBuilder();\r\n    SimpleXMLParser.parse(new SimpleXMLDocHandler() {\r\n        public void text(final String str) {\r\n            b.append(str);\r\n        }\r\n        public void startElement(final String tag, final Map<String, String> h) {\r\n        }\r\n        public void startDocument() {\r\n        }\r\n        public void endElement(final String tag) {\r\n        }\r\n        public void endDocument() {\r\n        }\r\n    }, null, new StringReader(whitespace), true);\r\n    Assert.assertEquals(expected, b.toString());\r\n}"
}, {
	"Path": "com.itextpdf.text.xml.simpleparser.SimpleXMLParserTest.whitespaceHtml",
	"Comment": "validate correct whitespace handling of simplexmlhandler.\tcarriage return received as text instead of space.",
	"Method": "void whitespaceHtml(){\r\n    b.append(str);\r\n}"
}, {
	"Path": "com.itextpdf.text.xml.simpleparser.SimpleXMLParserTest.whitespaceHtml",
	"Comment": "validate correct whitespace handling of simplexmlhandler.\tcarriage return received as text instead of space.",
	"Method": "void whitespaceHtml(){\r\n}"
}, {
	"Path": "com.itextpdf.text.xml.simpleparser.SimpleXMLParserTest.whitespaceHtml",
	"Comment": "validate correct whitespace handling of simplexmlhandler.\tcarriage return received as text instead of space.",
	"Method": "void whitespaceHtml(){\r\n}"
}, {
	"Path": "com.itextpdf.text.xml.simpleparser.SimpleXMLParserTest.whitespaceHtml",
	"Comment": "validate correct whitespace handling of simplexmlhandler.\tcarriage return received as text instead of space.",
	"Method": "void whitespaceHtml(){\r\n}"
}, {
	"Path": "com.itextpdf.text.xml.simpleparser.SimpleXMLParserTest.whitespaceHtml",
	"Comment": "validate correct whitespace handling of simplexmlhandler.\tcarriage return received as text instead of space.",
	"Method": "void whitespaceHtml(){\r\n}"
}, {
	"Path": "com.example.video.QuickstartSample.main",
	"Comment": "demonstrates using the video intelligence client to detect labels in a video file.",
	"Method": "void main(String[] args){\r\n    try (VideoIntelligenceServiceClient client = VideoIntelligenceServiceClient.create()) {\r\n        String gcsUri = \"gs://demomaker/cat.mp4\";\r\n        AnnotateVideoRequest request = AnnotateVideoRequest.newBuilder().setInputUri(gcsUri).addFeatures(Feature.LABEL_DETECTION).build();\r\n        OperationFuture<AnnotateVideoResponse, AnnotateVideoProgress> response = client.annotateVideoAsync(request);\r\n        System.out.println(\"Waiting for operation to complete...\");\r\n        List<VideoAnnotationResults> results = response.get().getAnnotationResultsList();\r\n        if (results.isEmpty()) {\r\n            System.out.println(\"No labels detected in \" + gcsUri);\r\n            return;\r\n        }\r\n        for (VideoAnnotationResults result : results) {\r\n            System.out.println(\"Labels:\");\r\n            for (LabelAnnotation annotation : result.getSegmentLabelAnnotationsList()) {\r\n                System.out.println(\"Video label description : \" + annotation.getEntity().getDescription());\r\n                for (Entity categoryEntity : annotation.getCategoryEntitiesList()) {\r\n                    System.out.println(\"Label Category description : \" + categoryEntity.getDescription());\r\n                }\r\n                for (LabelSegment segment : annotation.getSegmentsList()) {\r\n                    double startTime = segment.getSegment().getStartTimeOffset().getSeconds() + segment.getSegment().getStartTimeOffset().getNanos() / 1e9;\r\n                    double endTime = segment.getSegment().getEndTimeOffset().getSeconds() + segment.getSegment().getEndTimeOffset().getNanos() / 1e9;\r\n                    System.out.printf(\"Segment location : %.3f:%.3f\\n\", startTime, endTime);\r\n                    System.out.println(\"Confidence : \" + segment.getConfidence());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.openhft.affinity.AffinityLock.acquireCore",
	"Comment": "assign any free core to this thread.in reality, only one cpu is assigned, the rest ofthe threads for that core are reservable so they are not used.",
	"Method": "AffinityLock acquireCore(AffinityLock acquireCore,boolean bind,AffinityLock acquireCore,boolean bind,int cpuId,AffinityStrategy strategies){\r\n    return LOCK_INVENTORY.acquireCore(bind, cpuId, strategies);\r\n}"
}, {
	"Path": "com.sixt.service.framework.kafka.KafkaPublisher.publishAsyncWithKey",
	"Comment": "asynchronously publish one or more messages with a null partition key",
	"Method": "void publishAsyncWithKey(String key,String events){\r\n    if (events != null) {\r\n        publishEvents(false, key, events);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.security.PdfPKCS7.update",
	"Comment": "update the digest with the specified bytes.this method is used both for signing and verifying",
	"Method": "void update(byte[] buf,int off,int len){\r\n    if (RSAdata != null || digestAttr != null || isTsp)\r\n        messageDigest.update(buf, off, len);\r\n    else\r\n        sig.update(buf, off, len);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.setParticleDamping",
	"Comment": "damping is used to reduce the velocity of particles. the damping parameter can be larger than1.0f but the damping effect becomes sensitive to the time step when the damping parameter islarge.",
	"Method": "void setParticleDamping(float damping){\r\n    m_particleSystem.setParticleDamping(damping);\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONTokener.skipTo",
	"Comment": "skip characters until the next character is the requested character.if the requested character is not found, no characters are skipped.",
	"Method": "char skipTo(char to){\r\n    char c;\r\n    try {\r\n        long startIndex = this.index;\r\n        long startCharacter = this.character;\r\n        long startLine = this.line;\r\n        this.reader.mark(1000000);\r\n        do {\r\n            c = this.next();\r\n            if (c == 0) {\r\n                this.reader.reset();\r\n                this.index = startIndex;\r\n                this.character = startCharacter;\r\n                this.line = startLine;\r\n                return c;\r\n            }\r\n        } while (c != to);\r\n    } catch (IOException exception) {\r\n        throw new JSONException(exception);\r\n    }\r\n    this.back();\r\n    return c;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDictionary.getAsDict",
	"Comment": "returns a pdfobject as a pdfdictionary,resolving indirect references.the object associated with the pdfname given is retrievedand resolved to a direct object.if it is a pdfdictionary, it is cast down and returned assuch. otherwise null is returned.",
	"Method": "PdfDictionary getAsDict(PdfName key){\r\n    PdfDictionary dict = null;\r\n    PdfObject orig = getDirectObject(key);\r\n    if (orig != null && orig.isDictionary())\r\n        dict = (PdfDictionary) orig;\r\n    return dict;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.freeReader",
	"Comment": "use this method to writes the reader to the documentand free the memory used by it.the main use is when concatenating multiple documentsto keep the memory usage restricted to the currentappending document.",
	"Method": "void freeReader(PdfReader reader){\r\n    currentPdfReaderInstance = readerInstances.get(reader);\r\n    if (currentPdfReaderInstance == null)\r\n        return;\r\n    currentPdfReaderInstance.writeAllPages();\r\n    currentPdfReaderInstance = null;\r\n    readerInstances.remove(reader);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.getBoxSize",
	"Comment": "use this method to get the size of a trim, art, crop or bleed box,or null if not defined.",
	"Method": "Rectangle getBoxSize(String boxName,Rectangle getBoxSize,String boxName,Rectangle intersectingRectangle){\r\n    Rectangle pdfRectangle = pdf.getBoxSize(boxName);\r\n    if (pdfRectangle == null || intersectingRectangle == null) {\r\n        return null;\r\n    }\r\n    com.itextpdf.awt.geom.Rectangle boxRect = new com.itextpdf.awt.geom.Rectangle(pdfRectangle);\r\n    com.itextpdf.awt.geom.Rectangle intRect = new com.itextpdf.awt.geom.Rectangle(intersectingRectangle);\r\n    com.itextpdf.awt.geom.Rectangle outRect = boxRect.intersection(intRect);\r\n    if (outRect.isEmpty()) {\r\n        return null;\r\n    }\r\n    Rectangle output = new Rectangle((float) outRect.getX(), (float) outRect.getY(), (float) (outRect.getX() + outRect.getWidth()), (float) (outRect.getY() + outRect.getHeight()));\r\n    output.normalize();\r\n    return output;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Type1Font.getKerning",
	"Comment": "gets the kerning between two unicode characters. the charactersare converted to names and this names are used to find the kerningpairs in the hashmap kernpairs.",
	"Method": "int getKerning(int char1,int char2){\r\n    String first = GlyphList.unicodeToName(char1);\r\n    if (first == null)\r\n        return 0;\r\n    String second = GlyphList.unicodeToName(char2);\r\n    if (second == null)\r\n        return 0;\r\n    Object[] obj = KernPairs.get(first);\r\n    if (obj == null)\r\n        return 0;\r\n    for (int k = 0; k < obj.length; k += 2) {\r\n        if (second.equals(obj[k]))\r\n            return ((Integer) obj[k + 1]).intValue();\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.World.getBodyList",
	"Comment": "get the world body list. with the returned body, use body.getnext to get the next body in theworld list. a null body indicates the end of the list.",
	"Method": "Body getBodyList(){\r\n    return m_bodyList;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.ReadCommand",
	"Comment": "the function reads the next command after the file pointer is set",
	"Method": "void ReadCommand(){\r\n    key = null;\r\n    boolean gotKey = false;\r\n    while (!gotKey) {\r\n        char b0 = getCard8();\r\n        if (b0 == 28) {\r\n            int first = getCard8();\r\n            int second = getCard8();\r\n            args[arg_count] = Integer.valueOf(first << 8 | second);\r\n            arg_count++;\r\n            continue;\r\n        }\r\n        if (b0 >= 32 && b0 <= 246) {\r\n            args[arg_count] = Integer.valueOf(b0 - 139);\r\n            arg_count++;\r\n            continue;\r\n        }\r\n        if (b0 >= 247 && b0 <= 250) {\r\n            int w = getCard8();\r\n            args[arg_count] = Integer.valueOf((b0 - 247) * 256 + w + 108);\r\n            arg_count++;\r\n            continue;\r\n        }\r\n        if (b0 >= 251 && b0 <= 254) {\r\n            int w = getCard8();\r\n            args[arg_count] = Integer.valueOf(-(b0 - 251) * 256 - w - 108);\r\n            arg_count++;\r\n            continue;\r\n        }\r\n        if (b0 == 255) {\r\n            int first = getCard8();\r\n            int second = getCard8();\r\n            int third = getCard8();\r\n            int fourth = getCard8();\r\n            args[arg_count] = Integer.valueOf(first << 24 | second << 16 | third << 8 | fourth);\r\n            arg_count++;\r\n            continue;\r\n        }\r\n        if (b0 <= 31 && b0 != 28) {\r\n            gotKey = true;\r\n            if (b0 == 12) {\r\n                int b1 = getCard8();\r\n                if (b1 > SubrsEscapeFuncs.length - 1)\r\n                    b1 = SubrsEscapeFuncs.length - 1;\r\n                key = SubrsEscapeFuncs[b1];\r\n            } else\r\n                key = SubrsFunctions[b0];\r\n            continue;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.zip.Zipper.writeName",
	"Comment": "write the name of an object property. names have their own keep andhuffman encoder because they are expected to be a more restricted set.",
	"Method": "void writeName(String name){\r\n    Kim kim = new Kim(name);\r\n    int integer = this.namekeep.find(kim);\r\n    if (integer != none) {\r\n        one();\r\n        write(integer, this.namekeep);\r\n    } else {\r\n        zero();\r\n        write(kim, this.namehuff, this.namehuffext);\r\n        write(end, namehuff);\r\n        this.namekeep.register(kim);\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.SpecialSymbol.index",
	"Comment": "returns the first occurrence of a special symbol in a string.",
	"Method": "int index(String string){\r\n    int length = string.length();\r\n    for (int i = 0; i < length; i++) {\r\n        if (getCorrespondingSymbol(string.charAt(i)) != ' ') {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONObject.increment",
	"Comment": "increment a property of a jsonobject. if there is no such property,create one with a value of 1. if there is such a property, and if it isan integer, long, double, or float, then add one to it.",
	"Method": "JSONObject increment(String key){\r\n    Object value = this.opt(key);\r\n    if (value == null) {\r\n        this.put(key, 1);\r\n    } else if (value instanceof Integer) {\r\n        this.put(key, (Integer) value + 1);\r\n    } else if (value instanceof Long) {\r\n        this.put(key, (Long) value + 1);\r\n    } else if (value instanceof Double) {\r\n        this.put(key, (Double) value + 1);\r\n    } else if (value instanceof Float) {\r\n        this.put(key, (Float) value + 1);\r\n    } else {\r\n        throw new JSONException(\"Unable to increment [\" + quote(key) + \"].\");\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.itextpdf.text.RectangleReadOnly.softCloneNonPositionParameters",
	"Comment": "copies each of the parameters, except the position, from arectangle object if the value is set there.",
	"Method": "void softCloneNonPositionParameters(Rectangle rect){\r\n    throwReadOnlyError();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfLayer.setPrint",
	"Comment": "specifies that the content in this group is intended foruse in printing",
	"Method": "void setPrint(String subtype,boolean printstate){\r\n    PdfDictionary usage = getUsage();\r\n    PdfDictionary dic = new PdfDictionary();\r\n    dic.put(PdfName.SUBTYPE, new PdfName(subtype));\r\n    dic.put(PdfName.PRINTSTATE, printstate ? PdfName.ON : PdfName.OFF);\r\n    usage.put(PdfName.PRINT, dic);\r\n}"
}, {
	"Path": "software.amazon.ion.impl.bin.PrivateIonManagedBinaryWriterBuilder.withFlatImports",
	"Comment": "adds imports, flattening them to make lookup more efficient.this is particularly usefulwhen a builder instance is long lived.",
	"Method": "PrivateIonManagedBinaryWriterBuilder withFlatImports(SymbolTable tables,PrivateIonManagedBinaryWriterBuilder withFlatImports,List<SymbolTable> tables){\r\n    return withImports(ImportedSymbolResolverMode.FLAT, tables);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfDictionary.getDirectObject",
	"Comment": "returns the pdfobject associated to the specifiedkey, resolving a possible indirect reference to a directobject.this method will never return a pdfindirectreferenceobject.",
	"Method": "PdfObject getDirectObject(PdfName key){\r\n    return PdfReader.getPdfObject(get(key));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfLayerMembership.getRef",
	"Comment": "gets the pdfindirectreference that represents this membership layer.",
	"Method": "PdfIndirectReference getRef(){\r\n    return ref;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.codec.TIFFFaxDecompressor.SetOptions",
	"Comment": "invokes the superclass method and then sets instance variables onthe basis of the metadata set on this decompressor.",
	"Method": "void SetOptions(int fillOrder,int compression,int t4Options,int t6Options){\r\n    this.fillOrder = fillOrder;\r\n    this.compression = compression;\r\n    this.t4Options = t4Options;\r\n    this.t6Options = t6Options;\r\n    this.oneD = (int) (t4Options & 0x01);\r\n    this.uncompressedMode = (int) ((t4Options & 0x02) >> 1);\r\n    this.fillBits = (int) ((t4Options & 0x04) >> 2);\r\n}"
}, {
	"Path": "org.jbox2d.dynamics.Body.setType",
	"Comment": "set the type of this body. this may alter the mass and velocity.",
	"Method": "void setType(BodyType type){\r\n    assert (m_world.isLocked() == false);\r\n    if (m_world.isLocked() == true) {\r\n        return;\r\n    }\r\n    if (m_type == type) {\r\n        return;\r\n    }\r\n    m_type = type;\r\n    resetMassData();\r\n    if (m_type == BodyType.STATIC) {\r\n        m_linearVelocity.setZero();\r\n        m_angularVelocity = 0.0f;\r\n        m_sweep.a0 = m_sweep.a;\r\n        m_sweep.c0.set(m_sweep.c);\r\n        synchronizeFixtures();\r\n    }\r\n    setAwake(true);\r\n    m_force.setZero();\r\n    m_torque = 0.0f;\r\n    ContactEdge ce = m_contactList;\r\n    while (ce != null) {\r\n        ContactEdge ce0 = ce;\r\n        ce = ce.next;\r\n        m_world.m_contactManager.destroy(ce0.contact);\r\n    }\r\n    m_contactList = null;\r\n    BroadPhase broadPhase = m_world.m_contactManager.m_broadPhase;\r\n    for (Fixture f = m_fixtureList; f != null; f = f.m_next) {\r\n        int proxyCount = f.m_proxyCount;\r\n        for (int i = 0; i < proxyCount; ++i) {\r\n            broadPhase.touchProxy(f.m_proxies[i].proxyId);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.HTTPTokener.nextToken",
	"Comment": "get the next token or string. this is used in parsing http headers.",
	"Method": "String nextToken(){\r\n    char c;\r\n    char q;\r\n    StringBuilder sb = new StringBuilder();\r\n    do {\r\n        c = next();\r\n    } while (Character.isWhitespace(c));\r\n    if (c == '\"' || c == '\\'') {\r\n        q = c;\r\n        for (; ; ) {\r\n            c = next();\r\n            if (c < ' ') {\r\n                throw syntaxError(\"Unterminated string.\");\r\n            }\r\n            if (c == q) {\r\n                return sb.toString();\r\n            }\r\n            sb.append(c);\r\n        }\r\n    }\r\n    for (; ; ) {\r\n        if (c == 0 || Character.isWhitespace(c)) {\r\n            return sb.toString();\r\n        }\r\n        sb.append(c);\r\n        c = next();\r\n    }\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.TrueTypeFontSubSet.readStandardString",
	"Comment": "reads a string from the font file as bytes using the cp1252 encoding.",
	"Method": "String readStandardString(int length){\r\n    byte[] buf = new byte[length];\r\n    rf.readFully(buf);\r\n    try {\r\n        return new String(buf, BaseFont.WINANSI);\r\n    } catch (Exception e) {\r\n        throw new ExceptionConverter(e);\r\n    }\r\n}"
}, {
	"Path": "com.machinepublishers.glass.ui.monocle.RunnableProcessor.runLater",
	"Comment": "posts a runnable to the javafx event queue using the globalrunnableprocessor.",
	"Method": "void runLater(Runnable r){\r\n    NativePlatformFactory.getNativePlatform().getRunnableProcessor().invokeLater(r);\r\n}"
}, {
	"Path": "com.itextpdf.awt.DefaultFontMapper.insertDirectory",
	"Comment": "inserts all the fonts recognized by itext in thedirectory into the map. the encodingwill be basefont.cp1252 but can bechanged later.",
	"Method": "int insertDirectory(String dir){\r\n    File file = new File(dir);\r\n    if (!file.exists() || !file.isDirectory())\r\n        return 0;\r\n    File[] files = file.listFiles();\r\n    if (files == null)\r\n        return 0;\r\n    int count = 0;\r\n    for (int k = 0; k < files.length; ++k) {\r\n        count += insertFile(files[k]);\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.SimpleTextExtractionStrategy.renderText",
	"Comment": "captures text using a simplified algorithm for inserting hard returns and spaces",
	"Method": "void renderText(TextRenderInfo renderInfo){\r\n    boolean firstRender = result.length() == 0;\r\n    boolean hardReturn = false;\r\n    LineSegment segment = renderInfo.getBaseline();\r\n    Vector start = segment.getStartPoint();\r\n    Vector end = segment.getEndPoint();\r\n    if (!firstRender) {\r\n        Vector x0 = start;\r\n        Vector x1 = lastStart;\r\n        Vector x2 = lastEnd;\r\n        float dist = (x2.subtract(x1)).cross((x1.subtract(x0))).lengthSquared() / x2.subtract(x1).lengthSquared();\r\n        float sameLineThreshold = 1f;\r\n        if (dist > sameLineThreshold)\r\n            hardReturn = true;\r\n    }\r\n    if (hardReturn) {\r\n        appendTextChunk(\"\\n\");\r\n    } else if (!firstRender) {\r\n        if (result.charAt(result.length() - 1) != ' ' && renderInfo.getText().length() > 0 && renderInfo.getText().charAt(0) != ' ') {\r\n            float spacing = lastEnd.subtract(start).length();\r\n            if (spacing > renderInfo.getSingleSpaceWidth() / 2f) {\r\n                appendTextChunk(\" \");\r\n            }\r\n        }\r\n    } else {\r\n    }\r\n    appendTextChunk(renderInfo.getText());\r\n    lastStart = start;\r\n    lastEnd = end;\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.FixASCIIControlsReader.processChar",
	"Comment": "processes numeric escaped chars to find out if they are a control character.",
	"Method": "char processChar(char ch){\r\n    switch(state) {\r\n        case STATE_START:\r\n            if (ch == '&') {\r\n                state = STATE_AMP;\r\n            }\r\n            return ch;\r\n        case STATE_AMP:\r\n            if (ch == '#') {\r\n                state = STATE_HASH;\r\n            } else {\r\n                state = STATE_ERROR;\r\n            }\r\n            return ch;\r\n        case STATE_HASH:\r\n            if (ch == 'x') {\r\n                control = 0;\r\n                digits = 0;\r\n                state = STATE_HEX;\r\n            } else if ('0' <= ch && ch <= '9') {\r\n                control = Character.digit(ch, 10);\r\n                digits = 1;\r\n                state = STATE_DIG1;\r\n            } else {\r\n                state = STATE_ERROR;\r\n            }\r\n            return ch;\r\n        case STATE_DIG1:\r\n            if ('0' <= ch && ch <= '9') {\r\n                control = control * 10 + Character.digit(ch, 10);\r\n                digits++;\r\n                if (digits <= 5) {\r\n                    state = STATE_DIG1;\r\n                } else {\r\n                    state = STATE_ERROR;\r\n                }\r\n            } else if (ch == ';' && Utils.isControlChar((char) control)) {\r\n                state = STATE_START;\r\n                return (char) control;\r\n            } else {\r\n                state = STATE_ERROR;\r\n            }\r\n            return ch;\r\n        case STATE_HEX:\r\n            if (('0' <= ch && ch <= '9') || ('a' <= ch && ch <= 'f') || ('A' <= ch && ch <= 'F')) {\r\n                control = control * 16 + Character.digit(ch, 16);\r\n                digits++;\r\n                if (digits <= 4) {\r\n                    state = STATE_HEX;\r\n                } else {\r\n                    state = STATE_ERROR;\r\n                }\r\n            } else if (ch == ';' && Utils.isControlChar((char) control)) {\r\n                state = STATE_START;\r\n                return (char) control;\r\n            } else {\r\n                state = STATE_ERROR;\r\n            }\r\n            return ch;\r\n        case STATE_ERROR:\r\n            state = STATE_START;\r\n            return ch;\r\n        default:\r\n            return ch;\r\n    }\r\n}"
}, {
	"Path": "com.structurizr.api.StructurizrClient.setEncryptionStrategy",
	"Comment": "sets the encryption strategy for use when getting or putting workspaces.",
	"Method": "void setEncryptionStrategy(EncryptionStrategy encryptionStrategy){\r\n    this.encryptionStrategy = encryptionStrategy;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfFileSpecification.fileEmbedded",
	"Comment": "creates a file specification with the file embedded. the file maycome from the file system or from a byte array.",
	"Method": "PdfFileSpecification fileEmbedded(PdfWriter writer,String filePath,String fileDisplay,byte fileStore,PdfFileSpecification fileEmbedded,PdfWriter writer,String filePath,String fileDisplay,byte fileStore,int compressionLevel,PdfFileSpecification fileEmbedded,PdfWriter writer,String filePath,String fileDisplay,byte fileStore,boolean compress,PdfFileSpecification fileEmbedded,PdfWriter writer,String filePath,String fileDisplay,byte fileStore,boolean compress,String mimeType,PdfDictionary fileParameter,PdfFileSpecification fileEmbedded,PdfWriter writer,String filePath,String fileDisplay,byte fileStore,String mimeType,PdfDictionary fileParameter,int compressionLevel){\r\n    PdfFileSpecification fs = new PdfFileSpecification();\r\n    fs.writer = writer;\r\n    fs.put(PdfName.F, new PdfString(fileDisplay));\r\n    fs.setUnicodeFileName(fileDisplay, false);\r\n    PdfEFStream stream;\r\n    InputStream in = null;\r\n    PdfIndirectReference ref;\r\n    PdfIndirectReference refFileLength = null;\r\n    try {\r\n        if (fileStore == null) {\r\n            refFileLength = writer.getPdfIndirectReference();\r\n            File file = new File(filePath);\r\n            if (file.canRead()) {\r\n                in = new FileInputStream(filePath);\r\n            } else {\r\n                if (filePath.startsWith(\"file:/\") || filePath.startsWith(\"http://\") || filePath.startsWith(\"https://\") || filePath.startsWith(\"jar:\")) {\r\n                    in = new URL(filePath).openStream();\r\n                } else {\r\n                    in = StreamUtil.getResourceStream(filePath);\r\n                    if (in == null)\r\n                        throw new IOException(MessageLocalization.getComposedMessage(\"1.not.found.as.file.or.resource\", filePath));\r\n                }\r\n            }\r\n            stream = new PdfEFStream(in, writer);\r\n        } else {\r\n            stream = new PdfEFStream(fileStore);\r\n        }\r\n        stream.put(PdfName.TYPE, PdfName.EMBEDDEDFILE);\r\n        stream.flateCompress(compressionLevel);\r\n        PdfDictionary param = new PdfDictionary();\r\n        if (fileParameter != null) {\r\n            param.merge(fileParameter);\r\n        }\r\n        if (!param.contains(PdfName.MODDATE)) {\r\n            param.put(PdfName.MODDATE, new PdfDate());\r\n        }\r\n        if (fileStore == null) {\r\n            stream.put(PdfName.PARAMS, refFileLength);\r\n        } else {\r\n            param.put(PdfName.SIZE, new PdfNumber(stream.getRawLength()));\r\n            stream.put(PdfName.PARAMS, param);\r\n        }\r\n        if (mimeType != null)\r\n            stream.put(PdfName.SUBTYPE, new PdfName(mimeType));\r\n        ref = writer.addToBody(stream).getIndirectReference();\r\n        if (fileStore == null) {\r\n            stream.writeLength();\r\n            param.put(PdfName.SIZE, new PdfNumber(stream.getRawLength()));\r\n            writer.addToBody(param, refFileLength);\r\n        }\r\n    } finally {\r\n        if (in != null)\r\n            try {\r\n                in.close();\r\n            } catch (Exception e) {\r\n            }\r\n    }\r\n    PdfDictionary f = new PdfDictionary();\r\n    f.put(PdfName.F, ref);\r\n    f.put(PdfName.UF, ref);\r\n    fs.put(PdfName.EF, f);\r\n    return fs;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfFormField.setMappingName",
	"Comment": "the mapping name is the name this field uses when submitting form data.",
	"Method": "void setMappingName(String s){\r\n    put(PdfName.TM, new PdfString(s, PdfObject.TEXT_UNICODE));\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfWriter.setDefaultColorspace",
	"Comment": "use this method to sets the default colorspace that will be appliedto all the document. the colorspace is only applied if another colorspacewith the same name is not present in the content.the colorspace is applied immediately when creating templates andat the page end for the main document content.",
	"Method": "void setDefaultColorspace(PdfName key,PdfObject cs){\r\n    if (cs == null || cs.isNull())\r\n        defaultColorspace.remove(key);\r\n    defaultColorspace.put(key, cs);\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONObject.toJSONArray",
	"Comment": "produce a jsonarray containing the values of the members of thisjsonobject.",
	"Method": "JSONArray toJSONArray(JSONArray names){\r\n    if (names == null || names.length() == 0) {\r\n        return null;\r\n    }\r\n    JSONArray ja = new JSONArray();\r\n    for (int i = 0; i < names.length(); i += 1) {\r\n        ja.put(this.opt(names.getString(i)));\r\n    }\r\n    return ja;\r\n}"
}, {
	"Path": "com.example.containeranalysis.Samples.updateOccurrence",
	"Comment": "pushes an update to an occurrence that already exists on the server",
	"Method": "Occurrence updateOccurrence(GrafeasV1Beta1Client client,String occurrenceName,Occurrence updated){\r\n    UpdateOccurrenceRequest request = UpdateOccurrenceRequest.newBuilder().setName(occurrenceName).setOccurrence(updated).build();\r\n    return client.updateOccurrence(request);\r\n}"
}, {
	"Path": "org.lionsoul.jcseg.json.JSONML.toString",
	"Comment": "reverse the jsonml transformation, making an xml text from a jsonarray.",
	"Method": "String toString(JSONArray ja,String toString,JSONObject jo){\r\n    StringBuilder sb = new StringBuilder();\r\n    int i;\r\n    JSONArray ja;\r\n    String key;\r\n    Iterator<String> keys;\r\n    int length;\r\n    Object object;\r\n    String tagName;\r\n    String value;\r\n    tagName = jo.optString(\"tagName\");\r\n    if (tagName == null) {\r\n        return XML.escape(jo.toString());\r\n    }\r\n    XML.noSpace(tagName);\r\n    tagName = XML.escape(tagName);\r\n    sb.append('<');\r\n    sb.append(tagName);\r\n    keys = jo.keys();\r\n    while (keys.hasNext()) {\r\n        key = keys.next();\r\n        if (!\"tagName\".equals(key) && !\"childNodes\".equals(key)) {\r\n            XML.noSpace(key);\r\n            value = jo.optString(key);\r\n            if (value != null) {\r\n                sb.append(' ');\r\n                sb.append(XML.escape(key));\r\n                sb.append('=');\r\n                sb.append('\"');\r\n                sb.append(XML.escape(value));\r\n                sb.append('\"');\r\n            }\r\n        }\r\n    }\r\n    ja = jo.optJSONArray(\"childNodes\");\r\n    if (ja == null) {\r\n        sb.append('/');\r\n        sb.append('>');\r\n    } else {\r\n        sb.append('>');\r\n        length = ja.length();\r\n        for (i = 0; i < length; i += 1) {\r\n            object = ja.get(i);\r\n            if (object != null) {\r\n                if (object instanceof String) {\r\n                    sb.append(XML.escape(object.toString()));\r\n                } else if (object instanceof JSONObject) {\r\n                    sb.append(toString((JSONObject) object));\r\n                } else if (object instanceof JSONArray) {\r\n                    sb.append(toString((JSONArray) object));\r\n                } else {\r\n                    sb.append(object.toString());\r\n                }\r\n            }\r\n        }\r\n        sb.append('<');\r\n        sb.append('/');\r\n        sb.append(tagName);\r\n        sb.append('>');\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.Barcode.getBaseline",
	"Comment": "gets the text baseline.if positive, the text distance under the bars. if zero or negative,the text distance above the bars.",
	"Method": "float getBaseline(){\r\n    return baseline;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.richmedia.RichMediaParams.setSettings",
	"Comment": "a text string used to store settings information associated\twith a flash richmediainstance. it is to be stored and loaded\tby the scripting run time.",
	"Method": "void setSettings(PdfString settings){\r\n    put(PdfName.SETTINGS, settings);\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.entities.Guild.getOwnerId",
	"Comment": "the id for the current owner of this guild.this is useful for debugging purposes or as a shortcut.",
	"Method": "String getOwnerId(){\r\n    return Long.toUnsignedString(getOwnerIdLong());\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.pipeline.ElementHandlerPipelineTest.runOpen",
	"Comment": "verifies that the content of the processobject is processed on open.",
	"Method": "void runOpen(){\r\n    p.open(context, null, po);\r\n    Assert.assertEquals(writable, lst.get(0));\r\n}"
}, {
	"Path": "com.structurizr.api.StructurizrClient.getWorkspaceArchiveLocation",
	"Comment": "gets the location where a copy of the workspace is archived when it is retrieved from the server.",
	"Method": "File getWorkspaceArchiveLocation(){\r\n    return this.workspaceArchiveLocation;\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.CFFFontSubset.BuildFDSubrsOffsets",
	"Comment": "the function finds for the fd array processed the local subr offset and its\toffset array.",
	"Method": "void BuildFDSubrsOffsets(int Font,int FD){\r\n    fonts[Font].PrivateSubrsOffset[FD] = -1;\r\n    seek(fonts[Font].fdprivateOffsets[FD]);\r\n    while (getPosition() < fonts[Font].fdprivateOffsets[FD] + fonts[Font].fdprivateLengths[FD]) {\r\n        getDictItem();\r\n        if (key == \"Subrs\")\r\n            fonts[Font].PrivateSubrsOffset[FD] = ((Integer) args[0]).intValue() + fonts[Font].fdprivateOffsets[FD];\r\n    }\r\n    if (fonts[Font].PrivateSubrsOffset[FD] >= 0)\r\n        fonts[Font].PrivateSubrsOffsetsArray[FD] = getIndex(fonts[Font].PrivateSubrsOffset[FD]);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.InlineImageUtils.parseInlineImage",
	"Comment": "parses an inline image from the provided content parser.the parser must be positioned immediately following the bi operator in the content stream.the parser will be left with current position immediately following the ei operator that terminates the inline image",
	"Method": "InlineImageInfo parseInlineImage(PdfContentParser ps,PdfDictionary colorSpaceDic){\r\n    PdfDictionary inlineImageDictionary = parseInlineImageDictionary(ps);\r\n    byte[] samples = parseInlineImageSamples(inlineImageDictionary, colorSpaceDic, ps);\r\n    return new InlineImageInfo(samples, inlineImageDictionary);\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.parser.PdfContentReaderTool.getDictionaryDetail",
	"Comment": "shows the detail of a dictionary.\tthis is similar to the pdflister functionality.",
	"Method": "String getDictionaryDetail(PdfDictionary dic,String getDictionaryDetail,PdfDictionary dic,int depth){\r\n    StringBuffer builder = new StringBuffer();\r\n    builder.append('(');\r\n    List<PdfName> subDictionaries = new ArrayList<PdfName>();\r\n    for (PdfName key : dic.getKeys()) {\r\n        PdfObject val = dic.getDirectObject(key);\r\n        if (val.isDictionary())\r\n            subDictionaries.add(key);\r\n        builder.append(key);\r\n        builder.append('=');\r\n        builder.append(val);\r\n        builder.append(\", \");\r\n    }\r\n    if (builder.length() >= 2)\r\n        builder.setLength(builder.length() - 2);\r\n    builder.append(')');\r\n    for (PdfName pdfSubDictionaryName : subDictionaries) {\r\n        builder.append('\\n');\r\n        for (int i = 0; i < depth + 1; i++) {\r\n            builder.append('\\t');\r\n        }\r\n        builder.append(\"Subdictionary \");\r\n        builder.append(pdfSubDictionaryName);\r\n        builder.append(\" = \");\r\n        builder.append(getDictionaryDetail(dic.getAsDict(pdfSubDictionaryName), depth + 1));\r\n    }\r\n    return builder.toString();\r\n}"
}, {
	"Path": "com.itextpdf.text.pdf.PdfContentByte.createGraphicsShapes",
	"Comment": "gets a graphics2d to print on. the graphicsare translated to pdf commands.",
	"Method": "java.awt.Graphics2D createGraphicsShapes(float width,float height,java.awt.Graphics2D createGraphicsShapes,float width,float height,boolean convertImagesToJPEG,float quality){\r\n    return new PdfGraphics2D(this, width, height, null, true, convertImagesToJPEG, quality);\r\n}"
}, {
	"Path": "com.itextpdf.tool.xml.pipeline.HtmlPipelineContextTest.verifydefaultAcceptUnknown",
	"Comment": "verifies that the default of accepting unknown tags is true",
	"Method": "void verifydefaultAcceptUnknown(){\r\n    Assert.assertEquals(true, ctx.acceptUnknown());\r\n}"
}, {
	"Path": "com.tozny.crypto.android.AesCbcWithIntegrity.encrypt",
	"Comment": "generates a random iv and encrypts this plain text with the given key. then attachesa hashed mac, which is contained in the ciphertextivmac class.",
	"Method": "CipherTextIvMac encrypt(String plaintext,SecretKeys secretKeys,CipherTextIvMac encrypt,String plaintext,SecretKeys secretKeys,String encoding,CipherTextIvMac encrypt,byte[] plaintext,SecretKeys secretKeys){\r\n    byte[] iv = generateIv();\r\n    Cipher aesCipherForEncryption = Cipher.getInstance(CIPHER_TRANSFORMATION);\r\n    aesCipherForEncryption.init(Cipher.ENCRYPT_MODE, secretKeys.getConfidentialityKey(), new IvParameterSpec(iv));\r\n    iv = aesCipherForEncryption.getIV();\r\n    byte[] byteCipherText = aesCipherForEncryption.doFinal(plaintext);\r\n    byte[] ivCipherConcat = CipherTextIvMac.ivCipherConcat(iv, byteCipherText);\r\n    byte[] integrityMac = generateMac(ivCipherConcat, secretKeys.getIntegrityKey());\r\n    return new CipherTextIvMac(byteCipherText, iv, integrityMac);\r\n}"
}, {
	"Path": "com.itextpdf.xmp.impl.XMPNodeUtils.findChildNode",
	"Comment": "find or create a child node under a given parent node. if the parent node is no \treturns the found or created child node.",
	"Method": "XMPNode findChildNode(XMPNode parent,String childName,boolean createNodes){\r\n    if (!parent.getOptions().isSchemaNode() && !parent.getOptions().isStruct()) {\r\n        if (!parent.isImplicit()) {\r\n            throw new XMPException(\"Named children only allowed for schemas and structs\", XMPError.BADXPATH);\r\n        } else if (parent.getOptions().isArray()) {\r\n            throw new XMPException(\"Named children not allowed for arrays\", XMPError.BADXPATH);\r\n        } else if (createNodes) {\r\n            parent.getOptions().setStruct(true);\r\n        }\r\n    }\r\n    XMPNode childNode = parent.findChildByName(childName);\r\n    if (childNode == null && createNodes) {\r\n        PropertyOptions options = new PropertyOptions();\r\n        childNode = new XMPNode(childName, options);\r\n        childNode.setImplicit(true);\r\n        parent.addChild(childNode);\r\n    }\r\n    assert childNode != null || !createNodes;\r\n    return childNode;\r\n}"
}]