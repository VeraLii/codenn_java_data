[{
	"Path": "org.locationtech.jts.math.DDIOTest.writeAndReadSqrt",
	"Comment": "tests that printing values with many decimal places works. \tthis tests the correctness and robustness of both output and input.",
	"Method": "void writeAndReadSqrt(double x){\r\n    DD xdd = DD.valueOf(x);\r\n    DD xSqrt = xdd.sqrt();\r\n    String s = xSqrt.toString();\r\n    DD xSqrt2 = DD.parse(s);\r\n    DD xx = xSqrt2.multiply(xSqrt2);\r\n    String xxStr = xx.toString();\r\n    DD xx2 = DD.parse(xxStr);\r\n    double err = Math.abs(xx2.doubleValue() - x);\r\n    assertTrue(err < 1e-10);\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.entities.MessageEmbed.getUrl",
	"Comment": "the that was originally placed into chat that spawned this embed.",
	"Method": "String getUrl(String getUrl,String getUrl,String getUrl,String getUrl,String getUrl){\r\n    return url;\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherScroller.getDuration",
	"Comment": "returns how long the scroll event will take, in milliseconds.",
	"Method": "int getDuration(){\r\n    return mDuration;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.functor.BoundedBifunctor.biMapL",
	"Comment": "covariantly map the left parameter into a value that is covariant to contraa.",
	"Method": "BoundedBifunctor<C, B, ContraA, ContraB, BF> biMapL(Function<? super A, ? extends C> fn){\r\n    return biMap(fn, id());\r\n}"
}, {
	"Path": "org.kse.gui.crypto.policyinformation.PolicyQualifierInfoTableModel.load",
	"Comment": "load the policyqualifierinfotablemodel with policy qualifier info.",
	"Method": "void load(List<PolicyQualifierInfo> policyQualifierInfo){\r\n    PolicyQualifierInfo[] policyQualifierInfoArray = policyQualifierInfo.toArray(new PolicyQualifierInfo[policyQualifierInfo.size()]);\r\n    Arrays.sort(policyQualifierInfoArray, new PolicyQualifierInfoComparator());\r\n    data = new Object[policyQualifierInfoArray.length][1];\r\n    int i = 0;\r\n    for (PolicyQualifierInfo policyQualInfo : policyQualifierInfoArray) {\r\n        data[i][0] = policyQualInfo;\r\n        i++;\r\n    }\r\n    fireTableDataChanged();\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.deletePackageFromDatabase",
	"Comment": "removes all the items from the database corresponding to the specified package.",
	"Method": "void deletePackageFromDatabase(Context context,String pn,UserHandleCompat user){\r\n    deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.predicate.RectangleContains.isLineSegmentContainedInBoundary",
	"Comment": "tests if a line segment is contained in the boundary of the target rectangle.",
	"Method": "boolean isLineSegmentContainedInBoundary(Coordinate p0,Coordinate p1){\r\n    if (p0.equals(p1))\r\n        return isPointContainedInBoundary(p0);\r\n    if (p0.x == p1.x) {\r\n        if (p0.x == rectEnv.getMinX() || p0.x == rectEnv.getMaxX())\r\n            return true;\r\n    } else if (p0.y == p1.y) {\r\n        if (p0.y == rectEnv.getMinY() || p0.y == rectEnv.getMaxY())\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.android.launcher3.PagedView.getLayoutTransitionOffsetForPage",
	"Comment": "position. this method returns the magnitude of this stray at any given time.",
	"Method": "int getLayoutTransitionOffsetForPage(int index){\r\n    if (mPageScrolls == null || index >= mPageScrolls.length || index < 0) {\r\n        return 0;\r\n    } else {\r\n        View child = getChildAt(index);\r\n        int scrollOffset = 0;\r\n        LayoutParams lp = (LayoutParams) child.getLayoutParams();\r\n        if (!lp.isFullScreenPage) {\r\n            scrollOffset = mIsRtl ? getPaddingRight() : getPaddingLeft();\r\n        }\r\n        int baselineX = mPageScrolls[index] + scrollOffset + getViewportOffsetX();\r\n        return (int) (child.getX() - baselineX);\r\n    }\r\n}"
}, {
	"Path": "org.joda.money.format.MoneyFormatter.isPrinter",
	"Comment": "checks whether this formatter can print.if the formatter cannot print, an unsupportedoperationexception willbe thrown from the print methods.",
	"Method": "boolean isPrinter(){\r\n    return printerParser.isPrinter();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.functor.BoundedBifunctor.biMapR",
	"Comment": "covariantly map the right parameter into a value that is covariant to contrab.",
	"Method": "BoundedBifunctor<A, C, ContraA, ContraB, BF> biMapR(Function<? super B, ? extends C> fn){\r\n    return biMap(id(), fn);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.union.CascadedPolygonUnion.unionActual",
	"Comment": "encapsulates the actual unioning of two polygonal geometries.",
	"Method": "Geometry unionActual(Geometry g0,Geometry g1){\r\n    return restrictToPolygons(g0.union(g1));\r\n}"
}, {
	"Path": "org.kse.gui.TableColumnAdjuster.setDynamicAdjustment",
	"Comment": "indicate whether changes to the model should cause the width to be dynamically recalculated.",
	"Method": "void setDynamicAdjustment(boolean isDynamicAdjustment){\r\n    if (this.isDynamicAdjustment != isDynamicAdjustment) {\r\n        if (isDynamicAdjustment) {\r\n            table.addPropertyChangeListener(this);\r\n            table.getModel().addTableModelListener(this);\r\n        } else {\r\n            table.removePropertyChangeListener(this);\r\n            table.getModel().removeTableModelListener(this);\r\n        }\r\n    }\r\n    this.isDynamicAdjustment = isDynamicAdjustment;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.lens.Lens.lens",
	"Comment": "static factory method for creating a lens from a getter function and a setter function.",
	"Method": "Lens<S, T, A, B> lens(Function<? super S, ? extends A> getter,BiFunction<? super S, ? super B, ? extends T> setter){\r\n    return new Lens<S, T, A, B>() {\r\n        @Override\r\n        @SuppressWarnings(\"unchecked\")\r\n        public <F extends Functor, FT extends Functor<T, F>, FB extends Functor<B, F>> FT apply(Function<? super A, ? extends FB> fn, S s) {\r\n            return (FT) fn.apply(getter.apply(s)).fmap(b -> setter.apply(s, b));\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.lens.Lens.lens",
	"Comment": "static factory method for creating a lens from a getter function and a setter function.",
	"Method": "Lens<S, T, A, B> lens(Function<? super S, ? extends A> getter,BiFunction<? super S, ? super B, ? extends T> setter){\r\n    return (FT) fn.apply(getter.apply(s)).fmap(b -> setter.apply(s, b));\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.requests.restaction.MessageAction.override",
	"Comment": "whether all fields should be considered when editing a message",
	"Method": "MessageAction override(boolean bool){\r\n    this.override = isEdit() && bool;\r\n    return this;\r\n}"
}, {
	"Path": "com.jsql.model.accessible.CallableHttpHead.call",
	"Comment": "call url to a administration page in head mode and send the result back to view.",
	"Method": "CallableHttpHead call(){\r\n    boolean isUrlIncorrect = false;\r\n    URL targetUrl = null;\r\n    try {\r\n        targetUrl = new URL(this.urlAdminPage);\r\n    } catch (MalformedURLException e) {\r\n        isUrlIncorrect = true;\r\n    }\r\n    if (RessourceAccess.isSearchAdminStopped() || isUrlIncorrect || \"\".equals(targetUrl.getHost())) {\r\n        LOGGER.warn(\"Incorrect URL: \" + this.urlAdminPage);\r\n        return this;\r\n    }\r\n    HttpURLConnection connection = (HttpURLConnection) targetUrl.openConnection();\r\n    connection.setRequestProperty(\"Pragma\", \"no-cache\");\r\n    connection.setRequestProperty(\"Cache-Control\", \"no-cache\");\r\n    connection.setRequestProperty(\"Expires\", \"-1\");\r\n    connection.setRequestMethod(\"HEAD\");\r\n    this.responseCodeHttp = ObjectUtils.firstNonNull(connection.getHeaderField(0), \"\");\r\n    Map<Header, Object> msgHeader = new EnumMap(Header.class);\r\n    msgHeader.put(Header.URL, this.urlAdminPage);\r\n    msgHeader.put(Header.POST, \"\");\r\n    msgHeader.put(Header.HEADER, \"\");\r\n    msgHeader.put(Header.RESPONSE, HeaderUtil.getHttpHeaders(connection));\r\n    Request request = new Request();\r\n    request.setMessage(Interaction.MESSAGE_HEADER);\r\n    request.setParameters(msgHeader);\r\n    MediatorModel.model().sendToViews(request);\r\n    return this;\r\n}"
}, {
	"Path": "org.zeromq.ZMsg.destroy",
	"Comment": "destructor. explicitly destroys all zframes contains in the zmsg",
	"Method": "void destroy(){\r\n    if (frames == null)\r\n        return;\r\n    for (ZFrame f : frames) {\r\n        f.destroy();\r\n    }\r\n    frames.clear();\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.patch.DiffMatchPatch.diffFromDelta",
	"Comment": "given the original text1, and an encoded string which describes theoperations required to transform text1 into text2, compute the full diff.",
	"Method": "List<Diff> diffFromDelta(String text1,String delta){\r\n    List<Diff> diffs = new LinkedList();\r\n    int pointer = 0;\r\n    String[] tokens = delta.split(\"\\t\");\r\n    for (String token : tokens) {\r\n        if (token.length() == 0) {\r\n            continue;\r\n        }\r\n        String param = token.substring(1);\r\n        switch(token.charAt(0)) {\r\n            case '+':\r\n                param = param.replace(\"+\", \"+\");\r\n                try {\r\n                    param = URLDecoder.decode(param, StandardCharsets.UTF_8.name());\r\n                } catch (IllegalArgumentException e) {\r\n                    throw new IllegalArgumentException(\"Illegal escape in diff_fromDelta: \" + param, e);\r\n                }\r\n                diffs.add(new Diff(Operation.INSERT, param));\r\n                break;\r\n            case '-':\r\n            case '=':\r\n                int n;\r\n                try {\r\n                    n = Integer.parseInt(param);\r\n                } catch (NumberFormatException e) {\r\n                    throw new IllegalArgumentException(\"Invalid number in diff_fromDelta: \" + param, e);\r\n                }\r\n                if (n < 0) {\r\n                    throw new IllegalArgumentException(\"Negative number in diff_fromDelta: \" + param);\r\n                }\r\n                String text;\r\n                try {\r\n                    int p1 = pointer;\r\n                    pointer += n;\r\n                    int p2 = pointer;\r\n                    text = text1.substring(p1, p2);\r\n                } catch (StringIndexOutOfBoundsException e) {\r\n                    throw new IllegalArgumentException(\"Delta length (\" + pointer + \") larger than source text length (\" + text1.length() + \").\", e);\r\n                }\r\n                if (token.charAt(0) == '=') {\r\n                    diffs.add(new Diff(Operation.EQUAL, text));\r\n                } else {\r\n                    diffs.add(new Diff(Operation.DELETE, text));\r\n                }\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(\"Invalid diff operation in diff_fromDelta: \" + token.charAt(0));\r\n        }\r\n    }\r\n    if (pointer != text1.length()) {\r\n        throw new IllegalArgumentException(\"Delta length (\" + pointer + \") smaller than source text length (\" + text1.length() + \").\");\r\n    }\r\n    return diffs;\r\n}"
}, {
	"Path": "com.jsql.util.StringUtil.byte2hex",
	"Comment": "convert byte character to hexadecimal stringbuffer character.",
	"Method": "void byte2hex(byte b,StringBuilder buf){\r\n    char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\r\n    int high = (b & 0xf0) >> 4;\r\n    int low = b & 0x0f;\r\n    buf.append(hexChars[high]);\r\n    buf.append(hexChars[low]);\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testbuilder.topostretch.StretchedVertex.displaceFromCornerAwayFromArms",
	"Comment": "displaces a vertex from a corner,with angle limitingused to ensure that the displacement is not close to the arms of the corner.",
	"Method": "Coordinate displaceFromCornerAwayFromArms(Coordinate nearPt,Coordinate p1,Coordinate p2,double dist){\r\n    Coordinate[] corner = orientCorner(nearPt, p1, p2);\r\n    boolean isInsideCorner = isInsideCorner(vertexPt, nearPt, corner[0], corner[1]);\r\n    Vector2D u1 = Vector2D.create(nearPt, corner[0]).normalize();\r\n    Vector2D u2 = Vector2D.create(nearPt, corner[1]).normalize();\r\n    double cornerAng = u1.angle(u2);\r\n    double maxAngToBisec = maxAngleToBisector(cornerAng);\r\n    Vector2D bisec = u2.rotate(cornerAng / 2);\r\n    if (!isInsideCorner) {\r\n        bisec = bisec.multiply(-1);\r\n        double outerAng = 2 * Math.PI - cornerAng;\r\n        maxAngToBisec = maxAngleToBisector(outerAng);\r\n    }\r\n    Vector2D pointwiseDisplacement = Vector2D.create(nearPt, vertexPt).normalize();\r\n    double stretchAng = pointwiseDisplacement.angleTo(bisec);\r\n    double stretchAngClamp = MathUtil.clamp(stretchAng, -maxAngToBisec, maxAngToBisec);\r\n    Vector2D cornerDisplacement = bisec.rotate(-stretchAngClamp).multiply(dist);\r\n    return cornerDisplacement.translate(vertexPt);\r\n}"
}, {
	"Path": "org.locationtech.jts.precision.CommonBitsRemover.removeCommonBits",
	"Comment": "removes the common coordinate bits from a geometry.the coordinates of the geometry are changed.",
	"Method": "Geometry removeCommonBits(Geometry geom){\r\n    if (commonCoord.x == 0.0 && commonCoord.y == 0.0)\r\n        return geom;\r\n    Coordinate invCoord = new Coordinate(commonCoord);\r\n    invCoord.x = -invCoord.x;\r\n    invCoord.y = -invCoord.y;\r\n    Translater trans = new Translater(invCoord);\r\n    geom.apply(trans);\r\n    geom.geometryChanged();\r\n    return geom;\r\n}"
}, {
	"Path": "org.zeromq.ZMsg.recvMsg",
	"Comment": "receives message from socket, returns zmsg object or null if the recv wasinterrupted. does a blocking recv, if you want not to block then use thezloop class or zmq.poller to check for socket input before receiving.",
	"Method": "ZMsg recvMsg(Socket socket,ZMsg recvMsg,Socket socket,int flag){\r\n    if (socket == null)\r\n        throw new IllegalArgumentException(\"socket is null\");\r\n    ZMsg msg = new ZMsg();\r\n    while (true) {\r\n        ZFrame f = ZFrame.recvFrame(socket, flag);\r\n        if (f == null || !f.hasData()) {\r\n            msg.destroy();\r\n            msg = null;\r\n            break;\r\n        }\r\n        msg.add(f);\r\n        if (!f.hasMore())\r\n            break;\r\n    }\r\n    return msg;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.LineIntersector.setMakePrecise",
	"Comment": "force computed intersection to be rounded to a given precision model",
	"Method": "void setMakePrecise(PrecisionModel precisionModel){\r\n    this.precisionModel = precisionModel;\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.GeometryGraph.addEdge",
	"Comment": "add an edge computed externally.the label on the edge is assumedto be correct.",
	"Method": "void addEdge(Edge e){\r\n    insertEdge(e);\r\n    Coordinate[] coord = e.getCoordinates();\r\n    insertPoint(argIndex, coord[0], Location.BOUNDARY);\r\n    insertPoint(argIndex, coord[coord.length - 1], Location.BOUNDARY);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.BufferBuilder.setWorkingPrecisionModel",
	"Comment": "sets the precision model to use during the curve computation and noding,if it is different to the precision model of the geometry.if the precision model is less than the precision of the geometry precision model,the geometry must have previously been rounded to that precision.",
	"Method": "void setWorkingPrecisionModel(PrecisionModel pm){\r\n    workingPrecisionModel = pm;\r\n}"
}, {
	"Path": "org.kse.AuthorityCertificates.getWindowsTrustedRootCertificates",
	"Comment": "get windows trusted root certificates keystore. if not set this is\tloaded.",
	"Method": "KeyStore getWindowsTrustedRootCertificates(){\r\n    if (windowsTrustedRootCertificates == null) {\r\n        windowsTrustedRootCertificates = KeyStoreUtil.loadMsCapiStore(MsCapiStoreType.ROOT);\r\n    }\r\n    return windowsTrustedRootCertificates;\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.patch.DiffMatchPatch.diffCleanupSemantic",
	"Comment": "reduce the number of edits by eliminating semantically trivial equalities.",
	"Method": "void diffCleanupSemantic(LinkedList<Diff> diffs){\r\n    if (diffs.isEmpty()) {\r\n        return;\r\n    }\r\n    boolean changes = false;\r\n    Stack<Diff> equalities = new Stack();\r\n    String lastequality = null;\r\n    ListIterator<Diff> pointer = diffs.listIterator();\r\n    int lengthInsertions1 = 0;\r\n    int lengthDeletions1 = 0;\r\n    int lengthInsertions2 = 0;\r\n    int lengthDeletions2 = 0;\r\n    Diff thisDiff = pointer.next();\r\n    while (thisDiff != null) {\r\n        if (thisDiff.getOperation() == Operation.EQUAL) {\r\n            equalities.push(thisDiff);\r\n            lengthInsertions1 = lengthInsertions2;\r\n            lengthDeletions1 = lengthDeletions2;\r\n            lengthInsertions2 = 0;\r\n            lengthDeletions2 = 0;\r\n            lastequality = thisDiff.getText();\r\n        } else {\r\n            if (thisDiff.getOperation() == Operation.INSERT) {\r\n                lengthInsertions2 += thisDiff.getText().length();\r\n            } else {\r\n                lengthDeletions2 += thisDiff.getText().length();\r\n            }\r\n            if (lastequality != null && lastequality.length() <= Math.max(lengthInsertions1, lengthDeletions1) && lastequality.length() <= Math.max(lengthInsertions2, lengthDeletions2)) {\r\n                while (thisDiff != equalities.lastElement()) {\r\n                    thisDiff = pointer.previous();\r\n                }\r\n                pointer.next();\r\n                pointer.set(new Diff(Operation.DELETE, lastequality));\r\n                pointer.add(new Diff(Operation.INSERT, lastequality));\r\n                equalities.pop();\r\n                if (!equalities.empty()) {\r\n                    equalities.pop();\r\n                }\r\n                if (equalities.empty()) {\r\n                    while (pointer.hasPrevious()) {\r\n                        pointer.previous();\r\n                    }\r\n                } else {\r\n                    thisDiff = equalities.lastElement();\r\n                    while (thisDiff != pointer.previous()) {\r\n                    }\r\n                }\r\n                lengthInsertions1 = 0;\r\n                lengthInsertions2 = 0;\r\n                lengthDeletions1 = 0;\r\n                lengthDeletions2 = 0;\r\n                lastequality = null;\r\n                changes = true;\r\n            }\r\n        }\r\n        thisDiff = pointer.hasNext() ? pointer.next() : null;\r\n    }\r\n    if (changes) {\r\n        this.diffCleanupMerge(diffs);\r\n    }\r\n    this.diffCleanupSemanticLossless(diffs);\r\n    pointer = diffs.listIterator();\r\n    Diff prevDiff = null;\r\n    thisDiff = null;\r\n    if (pointer.hasNext()) {\r\n        prevDiff = pointer.next();\r\n        if (pointer.hasNext()) {\r\n            thisDiff = pointer.next();\r\n        }\r\n    }\r\n    while (thisDiff != null) {\r\n        if (prevDiff.getOperation() == Operation.DELETE && thisDiff.getOperation() == Operation.INSERT) {\r\n            String deletion = prevDiff.getText();\r\n            String insertion = thisDiff.getText();\r\n            int overlapLength1 = this.diffCommonOverlap(deletion, insertion);\r\n            int overlapLength2 = this.diffCommonOverlap(insertion, deletion);\r\n            if (overlapLength1 >= overlapLength2) {\r\n                if (overlapLength1 >= deletion.length() / 2.0 || overlapLength1 >= insertion.length() / 2.0) {\r\n                    pointer.previous();\r\n                    pointer.add(new Diff(Operation.EQUAL, insertion.substring(0, overlapLength1)));\r\n                    prevDiff.setText(deletion.substring(0, deletion.length() - overlapLength1));\r\n                    thisDiff.setText(insertion.substring(overlapLength1));\r\n                }\r\n            } else {\r\n                if (overlapLength2 >= deletion.length() / 2.0 || overlapLength2 >= insertion.length() / 2.0) {\r\n                    pointer.previous();\r\n                    pointer.add(new Diff(Operation.EQUAL, deletion.substring(0, overlapLength2)));\r\n                    prevDiff.setOperation(Operation.INSERT);\r\n                    prevDiff.setText(insertion.substring(0, insertion.length() - overlapLength2));\r\n                    thisDiff.setOperation(Operation.DELETE);\r\n                    thisDiff.setText(deletion.substring(overlapLength2));\r\n                }\r\n            }\r\n            thisDiff = pointer.hasNext() ? pointer.next() : null;\r\n        }\r\n        prevDiff = thisDiff;\r\n        thisDiff = pointer.hasNext() ? pointer.next() : null;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.distance3d.Distance3DOp.distance",
	"Comment": "report the distance between the nearest points on the input geometries.",
	"Method": "double distance(Geometry g0,Geometry g1,double distance){\r\n    if (geom[0] == null || geom[1] == null)\r\n        throw new IllegalArgumentException(\"null geometries are not supported\");\r\n    if (geom[0].isEmpty() || geom[1].isEmpty())\r\n        return 0.0;\r\n    computeMinDistance();\r\n    return minDistance;\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.hasCustomContentToLeft",
	"Comment": "to be overridden by subclasses to hint to launcher that we have custom content",
	"Method": "boolean hasCustomContentToLeft(){\r\n    if (mLauncherCallbacks != null) {\r\n        return mLauncherCallbacks.hasCustomContentToLeft();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.joda.money.format.MoneyParseContext.isFullyParsed",
	"Comment": "checks if the text has been fully parsed such that there is no more text to parse.",
	"Method": "boolean isFullyParsed(){\r\n    return textIndex == getTextLength();\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.utils.KubernetesResourceUtil.getQualifiedName",
	"Comment": "returns qualified name for the specified kubernetes resource",
	"Method": "String getQualifiedName(HasMetadata entity){\r\n    if (entity != null) {\r\n        return \"\" + getNamespace(entity) + \"/\" + getName(entity);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.joda.money.BigMoney.compareTo",
	"Comment": "compares this monetary value to another.the compared values must be in the same currency.",
	"Method": "int compareTo(BigMoneyProvider other){\r\n    BigMoney otherMoney = of(other);\r\n    if (currency.equals(otherMoney.currency) == false) {\r\n        throw new CurrencyMismatchException(getCurrencyUnit(), otherMoney.getCurrencyUnit());\r\n    }\r\n    return amount.compareTo(otherMoney.amount);\r\n}"
}, {
	"Path": "cn.jpush.api.JPushClient.sendIosNotificationWithAlias",
	"Comment": "send an ios notification with alias.if you want to send alert as a json object, maybe this method is what you needed.",
	"Method": "PushResult sendIosNotificationWithAlias(String alert,Map<String, String> extras,String alias,PushResult sendIosNotificationWithAlias,String alert,SMS sms,Map<String, String> extras,String alias,PushResult sendIosNotificationWithAlias,IosAlert alert,Map<String, String> extras,String alias,PushResult sendIosNotificationWithAlias,IosAlert alert,SMS sms,Map<String, String> extras,String alias,PushResult sendIosNotificationWithAlias,JsonObject alert,Map<String, String> extras,String alias,PushResult sendIosNotificationWithAlias,JsonObject alert,SMS sms,Map<String, String> extras,String alias){\r\n    PushPayload payload = PushPayload.newBuilder().setPlatform(Platform.ios()).setAudience(Audience.alias(alias)).setNotification(Notification.ios(alert, extras)).setSMS(sms).build();\r\n    return _pushClient.sendPush(payload);\r\n}"
}, {
	"Path": "com.jdon.container.access.TargetMetaDefHolder.loadMetaDefs",
	"Comment": "for reister in container of defaultcontainerbuilder.registeruserservice",
	"Method": "Map<String, TargetMetaDef> loadMetaDefs(){\r\n    return metaDefs;\r\n}"
}, {
	"Path": "com.jdon.util.jdom.DataFormatFilter.reset",
	"Comment": "reset the filter so that it can be reused.this method is especially useful if the filter failedwith an exception the last time through.",
	"Method": "void reset(){\r\n    state = SEEN_NOTHING;\r\n    stateStack = new Stack();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.product.Product3.rotateL3",
	"Comment": "rotate the first three values of this product one slot to the left.",
	"Method": "Product3<_2, _3, _1> rotateL3(){\r\n    return into((_1, _2, _3) -> product(_2, _3, _1));\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.addItemToDatabase",
	"Comment": "add an item to the database in a specified container. sets the container, screen, cellx andcelly fields of the item. also assigns an id to the item.",
	"Method": "void addItemToDatabase(Context context,ItemInfo item,long container,long screenId,int cellX,int cellY){\r\n    item.container = container;\r\n    item.cellX = cellX;\r\n    item.cellY = cellY;\r\n    if (context instanceof Launcher && screenId < 0 && container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {\r\n        item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);\r\n    } else {\r\n        item.screenId = screenId;\r\n    }\r\n    final ContentValues values = new ContentValues();\r\n    final ContentResolver cr = context.getContentResolver();\r\n    item.onAddToDatabase(context, values);\r\n    item.id = LauncherAppState.getLauncherProvider().generateNewItemId();\r\n    values.put(LauncherSettings.Favorites._ID, item.id);\r\n    final StackTraceElement[] stackTrace = new Throwable().getStackTrace();\r\n    Runnable r = new Runnable() {\r\n        public void run() {\r\n            cr.insert(LauncherSettings.Favorites.CONTENT_URI, values);\r\n            synchronized (sBgLock) {\r\n                checkItemInfoLocked(item.id, item, stackTrace);\r\n                sBgItemsIdMap.put(item.id, item);\r\n                switch(item.itemType) {\r\n                    case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:\r\n                        sBgFolders.put(item.id, (FolderInfo) item);\r\n                    case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:\r\n                    case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:\r\n                        if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP || item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {\r\n                            sBgWorkspaceItems.add(item);\r\n                        } else {\r\n                            if (!sBgFolders.containsKey(item.container)) {\r\n                                String msg = \"adding item: \" + item + \" to a folder that \" + \" doesn't exist\";\r\n                                Log.e(TAG, msg);\r\n                            }\r\n                        }\r\n                        break;\r\n                    case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:\r\n                        sBgAppWidgets.add((LauncherAppWidgetInfo) item);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    runOnWorkerThread(r);\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.addItemToDatabase",
	"Comment": "add an item to the database in a specified container. sets the container, screen, cellx andcelly fields of the item. also assigns an id to the item.",
	"Method": "void addItemToDatabase(Context context,ItemInfo item,long container,long screenId,int cellX,int cellY){\r\n    cr.insert(LauncherSettings.Favorites.CONTENT_URI, values);\r\n    synchronized (sBgLock) {\r\n        checkItemInfoLocked(item.id, item, stackTrace);\r\n        sBgItemsIdMap.put(item.id, item);\r\n        switch(item.itemType) {\r\n            case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:\r\n                sBgFolders.put(item.id, (FolderInfo) item);\r\n            case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:\r\n            case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:\r\n                if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP || item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {\r\n                    sBgWorkspaceItems.add(item);\r\n                } else {\r\n                    if (!sBgFolders.containsKey(item.container)) {\r\n                        String msg = \"adding item: \" + item + \" to a folder that \" + \" doesn't exist\";\r\n                        Log.e(TAG, msg);\r\n                    }\r\n                }\r\n                break;\r\n            case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:\r\n                sBgAppWidgets.add((LauncherAppWidgetInfo) item);\r\n                break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherScroller.timePassed",
	"Comment": "returns the time elapsed since the beginning of the scrolling.",
	"Method": "int timePassed(){\r\n    return (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.requests.restaction.order.OrderAction.swapPosition",
	"Comment": "swaps the currently selected entity with the specified entity.no other entities are affected by this operation.",
	"Method": "M swapPosition(int swapPosition,M swapPosition,T swapEntity){\r\n    Checks.notNull(swapEntity, \"Provided swapEntity\");\r\n    validateInput(swapEntity);\r\n    return swapPosition(orderList.indexOf(swapEntity));\r\n}"
}, {
	"Path": "org.joda.money.BigMoney.withAmount",
	"Comment": "returns a copy of this monetary value with the specified amount.the returned instance will have this currency and the new amount.the scale of the returned instance will be that of the specified bigdecimal.this instance is immutable and unaffected by this method.",
	"Method": "BigMoney withAmount(BigDecimal amount,BigMoney withAmount,double amount){\r\n    return withAmount(BigDecimal.valueOf(amount));\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.index.SegmentIntersector.hasProperIntersection",
	"Comment": "a proper intersection is an intersection which is interior to at least twoline segments.note that a proper intersection is not necessarilyin the interior of the entire geometry, since another edge may havean endpoint equal to the intersection, which according to sfs semanticscan result in the point being on the boundary of the geometry.",
	"Method": "boolean hasProperIntersection(){\r\n    return hasProper;\r\n}"
}, {
	"Path": "org.joda.money.Money.withAmount",
	"Comment": "returns a copy of this monetary value with the specified amount.the returned instance will have this currency and the new amount.no rounding is performed on the amount to be added, so it must have ascale compatible with the currency.this instance is immutable and unaffected by this method.",
	"Method": "Money withAmount(BigDecimal amount,Money withAmount,BigDecimal amount,RoundingMode roundingMode,Money withAmount,double amount,Money withAmount,double amount,RoundingMode roundingMode){\r\n    return with(money.withAmount(amount).withCurrencyScale(roundingMode));\r\n}"
}, {
	"Path": "org.locationtech.jts.io.WKBHexFileReader.read",
	"Comment": "reads a sequence of geometries.\tif an offset is specified, geometries read up to the offset count are skipped.\tif a limit is specified, no more than limit geometries are read.",
	"Method": "List read(List read,BufferedReader bufferedReader){\r\n    List geoms = new ArrayList();\r\n    while (!isAtEndOfFile(bufferedReader) && !isAtLimit(geoms)) {\r\n        String line = bufferedReader.readLine().trim();\r\n        if (line.length() == 0)\r\n            continue;\r\n        Geometry g = wkbReader.read(WKBReader.hexToBytes(line));\r\n        if (count >= offset)\r\n            geoms.add(g);\r\n        count++;\r\n    }\r\n    return geoms;\r\n}"
}, {
	"Path": "com.jsql.view.swing.table.AdjusterTableColumn.setColumnDataIncluded",
	"Comment": "indicates whether to include the model data in the width calculation",
	"Method": "void setColumnDataIncluded(boolean isColumnDataIncluded){\r\n    this.isColumnDataIncluded = isColumnDataIncluded;\r\n}"
}, {
	"Path": "com.android.launcher3.BaseRecyclerView.getFastScrollerThumbInactiveColor",
	"Comment": "returns the inactive thumb color, can be overridden by each subclass.",
	"Method": "int getFastScrollerThumbInactiveColor(int defaultInactiveThumbColor){\r\n    return defaultInactiveThumbColor;\r\n}"
}, {
	"Path": "org.locationtech.jts.io.WKTReader.parseErrorExpected",
	"Comment": "creates a formatted parseexception reporting that the current tokenwas unexpected.",
	"Method": "ParseException parseErrorExpected(StreamTokenizer tokenizer,String expected){\r\n    if (tokenizer.ttype == StreamTokenizer.TT_NUMBER)\r\n        Assert.shouldNeverReachHere(\"Unexpected NUMBER token\");\r\n    if (tokenizer.ttype == StreamTokenizer.TT_EOL)\r\n        Assert.shouldNeverReachHere(\"Unexpected EOL token\");\r\n    String tokenStr = tokenString(tokenizer);\r\n    return parseErrorWithLine(tokenizer, \"Expected \" + expected + \" but found \" + tokenStr);\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.entities.MessageEmbed.getAuthor",
	"Comment": "the information on the creator of the embedded content.this is typically used to represent the account on the providing site.",
	"Method": "AuthorInfo getAuthor(){\r\n    return author;\r\n}"
}, {
	"Path": "org.locationtech.jts.densify.Densifier.setDistanceTolerance",
	"Comment": "sets the distance tolerance for the densification. all line segments\tin the densified geometry will be no longer than the distance tolerance.\tsimplified geometry will be within this distance of the original geometry.\tthe distance tolerance must be positive.",
	"Method": "void setDistanceTolerance(double distanceTolerance){\r\n    if (distanceTolerance <= 0.0)\r\n        throw new IllegalArgumentException(\"Tolerance must be positive\");\r\n    this.distanceTolerance = distanceTolerance;\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.syntax.SQLToken.isWhiteSpace",
	"Comment": "checks this token to see if it is white space. usually tabs, line breaks,form feed, spaces, etc.",
	"Method": "boolean isWhiteSpace(){\r\n    return (this.id >> 8) == 0xE;\r\n}"
}, {
	"Path": "org.kse.crypto.keystore.KeyStoreUtil.loadAppleKeychain",
	"Comment": "load the apple keychain as a keystore. the keystore is not file based and\ttherefore does not need to be saved.",
	"Method": "KeyStore loadAppleKeychain(){\r\n    if (!isAppleKeychainSupported()) {\r\n        throw new CryptoException(res.getString(\"AppleKeychainNotSupported.exception.message\"));\r\n    }\r\n    KeyStore keyStore = null;\r\n    try {\r\n        keyStore = KeyStore.getInstance(KEYCHAIN.jce(), APPLE.jce());\r\n    } catch (KeyStoreException ex) {\r\n        throw new CryptoException(MessageFormat.format(res.getString(\"NoCreateKeyStore.exception.message\"), KEYCHAIN.jce()), ex);\r\n    } catch (NoSuchProviderException ex) {\r\n        throw new CryptoException(MessageFormat.format(res.getString(\"NoCreateKeyStore.exception.message\"), KEYCHAIN.jce()), ex);\r\n    }\r\n    try {\r\n        keyStore.load(null, null);\r\n    } catch (NoSuchAlgorithmException ex) {\r\n        throw new CryptoException(MessageFormat.format(res.getString(\"NoLoadKeyStoreType.exception.message\"), KEYCHAIN.jce()), ex);\r\n    } catch (CertificateException ex) {\r\n        throw new CryptoException(MessageFormat.format(res.getString(\"NoLoadKeyStoreType.exception.message\"), KEYCHAIN.jce()), ex);\r\n    } catch (IOException ex) {\r\n        throw new CryptoException(MessageFormat.format(res.getString(\"NoLoadKeyStoreType.exception.message\"), KEYCHAIN.jce()), ex);\r\n    }\r\n    return keyStore;\r\n}"
}, {
	"Path": "com.jsql.model.accessible.CallableFile.call",
	"Comment": "read a file on the server using sql injection.get partial result if user interrupts the process.",
	"Method": "CallableFile call(){\r\n    String[] sourcePage = { \"\" };\r\n    String resultToParse = \"\";\r\n    try {\r\n        resultToParse = this.suspendableReadFile.run(MediatorModel.model().getVendor().instance().sqlFileRead(this.pathFile), sourcePage, false, 1, null);\r\n    } catch (InjectionFailureException e) {\r\n        IgnoreMessageException exceptionIgnored = new IgnoreMessageException(e);\r\n        LOGGER.trace(exceptionIgnored, exceptionIgnored);\r\n    } catch (StoppedByUserSlidingException e) {\r\n        if (!\"\".equals(e.getSlidingWindowAllRows())) {\r\n            resultToParse = e.getSlidingWindowAllRows();\r\n        } else if (!\"\".equals(e.getSlidingWindowCurrentRows())) {\r\n            resultToParse = e.getSlidingWindowCurrentRows();\r\n        }\r\n        IgnoreMessageException exceptionIgnored = new IgnoreMessageException(e);\r\n        LOGGER.trace(exceptionIgnored, exceptionIgnored);\r\n    }\r\n    this.sourceFile = resultToParse;\r\n    return this;\r\n}"
}, {
	"Path": "org.locationtech.jts.util.GeometricShapeFactory.createArcPolygon",
	"Comment": "creates an elliptical arc polygon.the polygon is formed from the specified arc of an ellipseand the two radii connecting the endpoints to the centre of the ellipse.",
	"Method": "Polygon createArcPolygon(double startAng,double angExtent){\r\n    Envelope env = dim.getEnvelope();\r\n    double xRadius = env.getWidth() / 2.0;\r\n    double yRadius = env.getHeight() / 2.0;\r\n    double centreX = env.getMinX() + xRadius;\r\n    double centreY = env.getMinY() + yRadius;\r\n    double angSize = angExtent;\r\n    if (angSize <= 0.0 || angSize > 2 * Math.PI)\r\n        angSize = 2 * Math.PI;\r\n    double angInc = angSize / (nPts - 1);\r\n    Coordinate[] pts = new Coordinate[nPts + 2];\r\n    int iPt = 0;\r\n    pts[iPt++] = coord(centreX, centreY);\r\n    for (int i = 0; i < nPts; i++) {\r\n        double ang = startAng + angInc * i;\r\n        double x = xRadius * Math.cos(ang) + centreX;\r\n        double y = yRadius * Math.sin(ang) + centreY;\r\n        pts[iPt++] = coord(x, y);\r\n    }\r\n    pts[iPt++] = coord(centreX, centreY);\r\n    LinearRing ring = geomFact.createLinearRing(pts);\r\n    Polygon poly = geomFact.createPolygon(ring);\r\n    return (Polygon) rotate(poly);\r\n}"
}, {
	"Path": "com.jsql.view.i18n.I18nView.addComponentForKey",
	"Comment": "add a graphical component to those whose text must be changed whenthe language changes.",
	"Method": "void addComponentForKey(String key,Object component){\r\n    I18nView.componentsLocalized.get(key).add(component);\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isUSPhoneNumber",
	"Comment": "isusphonenumber returns true if string s is a valid u.s. phone number.must be 10 digits.",
	"Method": "boolean isUSPhoneNumber(String s){\r\n    if (isEmpty(s))\r\n        return defaultEmptyOK;\r\n    String normalizedPhone = stripCharsInBag(s, phoneNumberDelimiters);\r\n    return (isInteger(normalizedPhone) && normalizedPhone.length() == digitsInUSPhoneNumber);\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isSSN",
	"Comment": "isssn returns true if string s is a valid u.s. social security number.must be 9 digits.",
	"Method": "boolean isSSN(String s){\r\n    if (isEmpty(s))\r\n        return defaultEmptyOK;\r\n    String normalizedSSN = stripCharsInBag(s, SSNDelimiters);\r\n    return (isInteger(normalizedSSN) && normalizedSSN.length() == digitsInSocialSecurityNumber);\r\n}"
}, {
	"Path": "com.jdon.cache.UtilCache.remove",
	"Comment": "removes an element from the cache according to the specified key",
	"Method": "void remove(Object key){\r\n    removeObject(key);\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.Envelope.translate",
	"Comment": "translates this envelope by given amounts in the x and y direction.",
	"Method": "void translate(double transX,double transY){\r\n    if (isNull()) {\r\n        return;\r\n    }\r\n    init(getMinX() + transX, getMaxX() + transX, getMinY() + transY, getMaxY() + transY);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.union.CascadedPolygonUnion.unionSafe",
	"Comment": "computes the union of two geometries, either or both of which may be null.",
	"Method": "Geometry unionSafe(Geometry g0,Geometry g1){\r\n    if (g0 == null && g1 == null)\r\n        return null;\r\n    if (g0 == null)\r\n        return g1.copy();\r\n    if (g1 == null)\r\n        return g0.copy();\r\n    return unionOptimized(g0, g1);\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.VoronoiDiagramBuilder.setClipEnvelope",
	"Comment": "sets the envelope to clip the diagram to.\tthe diagram will be clipped to the larger\tof this envelope or an envelope surrounding the sites.",
	"Method": "void setClipEnvelope(Envelope clipEnv){\r\n    this.clipEnv = clipEnv;\r\n}"
}, {
	"Path": "org.kse.gui.crypto.policyinformation.PolicyInformationTableModel.load",
	"Comment": "load the policyinformationtablemodel with policy information.",
	"Method": "void load(List<PolicyInformation> policyInformation){\r\n    PolicyInformation[] policyInformationArray = policyInformation.toArray(new PolicyInformation[policyInformation.size()]);\r\n    Arrays.sort(policyInformationArray, new PolicyInformationComparator());\r\n    data = new Object[policyInformation.size()][1];\r\n    int i = 0;\r\n    for (PolicyInformation policyInfo : policyInformationArray) {\r\n        data[i][0] = policyInfo;\r\n        i++;\r\n    }\r\n    fireTableDataChanged();\r\n}"
}, {
	"Path": "com.android.launcher3.IconCache.removeIconsForPkg",
	"Comment": "removes the entries related to the given package in memory and persistent db.",
	"Method": "void removeIconsForPkg(String packageName,UserHandleCompat user){\r\n    removeFromMemCacheLocked(packageName, user);\r\n    long userSerial = mUserManager.getSerialNumberForUser(user);\r\n    mIconDb.getWritableDatabase().delete(IconDB.TABLE_NAME, IconDB.COLUMN_COMPONENT + \" LIKE ? AND \" + IconDB.COLUMN_USER + \" = ?\", new String[] { packageName + \"/%\", Long.toString(userSerial) });\r\n}"
}, {
	"Path": "org.locationtech.jts.generator.LineStringGenerator.create",
	"Comment": "as the user increases the number of points, the probability of creating a random valid linestring decreases. \tplease take not of this when selecting the generation style, and the number of points. \tmay return null if a geometry could not be created.",
	"Method": "Geometry create(){\r\n    if (geometryFactory == null) {\r\n        throw new NullPointerException(\"GeometryFactory is not declared\");\r\n    }\r\n    if (boundingBox == null || boundingBox.isNull()) {\r\n        throw new NullPointerException(\"Bounding Box is not declared\");\r\n    }\r\n    if (numberPoints < 2) {\r\n        throw new IllegalStateException(\"Too few points\");\r\n    }\r\n    Coordinate[] coords = new Coordinate[numberPoints];\r\n    double x = boundingBox.getMinX();\r\n    double dx = boundingBox.getMaxX() - x;\r\n    double y = boundingBox.getMinY();\r\n    double dy = boundingBox.getMaxY() - y;\r\n    for (int i = 0; i < RUNS; i++) {\r\n        switch(getGenerationAlgorithm()) {\r\n            case VERT:\r\n                fillVert(x, dx, y, dy, coords, geometryFactory);\r\n                break;\r\n            case HORZ:\r\n                fillHorz(x, dx, y, dy, coords, geometryFactory);\r\n                break;\r\n            case ARC:\r\n                fillArc(x, dx, y, dy, coords, geometryFactory);\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"Invalid Alg. Specified\");\r\n        }\r\n        LineString ls = geometryFactory.createLineString(coords);\r\n        IsValidOp valid = new IsValidOp(ls);\r\n        if (valid.isValid()) {\r\n            return ls;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.android.launcher3.DragController.addDragListener",
	"Comment": "sets the drag listner which will be notified when a drag starts or ends.",
	"Method": "void addDragListener(DragListener l){\r\n    mListeners.add(l);\r\n}"
}, {
	"Path": "org.joda.money.format.MoneyAmountStyle.withDecimalPointCharacter",
	"Comment": "returns a copy of this style with the specified decimal point character.for english, this is a dot.",
	"Method": "MoneyAmountStyle withDecimalPointCharacter(Character decimalPointCharacter){\r\n    int dpVal = (decimalPointCharacter == null ? -1 : decimalPointCharacter);\r\n    if (dpVal == this.decimalPointCharacter) {\r\n        return this;\r\n    }\r\n    return new MoneyAmountStyle(zeroCharacter, positiveCharacter, negativeCharacter, dpVal, groupingStyle, groupingCharacter, groupingSize, extendedGroupingSize, forceDecimalPoint, absValue);\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.patch.DiffMatchPatch.diffLinesToCharsMunge",
	"Comment": "split a text into a list of strings.reduce the texts to a string ofhashes where each unicode character represents one line.",
	"Method": "String diffLinesToCharsMunge(String text,List<String> lineArray,Map<String, Integer> lineHash){\r\n    int lineStart = 0;\r\n    int lineEnd = -1;\r\n    String line;\r\n    StringBuilder chars = new StringBuilder();\r\n    while (lineEnd < text.length() - 1) {\r\n        lineEnd = text.indexOf('\\n', lineStart);\r\n        if (lineEnd == -1) {\r\n            lineEnd = text.length() - 1;\r\n        }\r\n        line = text.substring(lineStart, lineEnd + 1);\r\n        lineStart = lineEnd + 1;\r\n        if (lineHash.containsKey(line)) {\r\n            chars.append(String.valueOf((char) (int) lineHash.get(line)));\r\n        } else {\r\n            lineArray.add(line);\r\n            lineHash.put(line, lineArray.size() - 1);\r\n            chars.append(String.valueOf((char) (lineArray.size() - 1)));\r\n        }\r\n    }\r\n    return chars.toString();\r\n}"
}, {
	"Path": "com.jsql.view.swing.table.AdjusterTableColumn.getColumnDataWidth",
	"Comment": "calculate the width based on the widest cell renderer for the given column.",
	"Method": "int getColumnDataWidth(int column){\r\n    if (!this.isColumnDataIncluded) {\r\n        return 0;\r\n    }\r\n    int preferredWidth = 0;\r\n    int maxWidth = this.tableAdjust.getColumnModel().getColumn(column).getMaxWidth();\r\n    for (int row = 0; row < this.tableAdjust.getRowCount(); row++) {\r\n        preferredWidth = Math.max(preferredWidth, this.getCellDataWidth(row, column));\r\n        if (preferredWidth >= maxWidth) {\r\n            break;\r\n        }\r\n    }\r\n    return preferredWidth;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.LineSegment.closestPoint",
	"Comment": "computes the closest point on this line segment to another point.",
	"Method": "Coordinate closestPoint(Coordinate p){\r\n    double factor = projectionFactor(p);\r\n    if (factor > 0 && factor < 1) {\r\n        return project(p);\r\n    }\r\n    double dist0 = p0.distance(p);\r\n    double dist1 = p1.distance(p);\r\n    if (dist0 < dist1)\r\n        return p0;\r\n    return p1;\r\n}"
}, {
	"Path": "org.kse.crypto.filetype.CryptoFileUtil.detectFileType",
	"Comment": "detect the cryptographic file type of the supplied input stream.",
	"Method": "CryptoFileType detectFileType(File file,CryptoFileType detectFileType,byte[] data){\r\n    EncryptionType pkcs8EncType = Pkcs8Util.getEncryptionType(data);\r\n    if (pkcs8EncType != null) {\r\n        if (pkcs8EncType == ENCRYPTED) {\r\n            return ENC_PKCS8_PVK;\r\n        } else if (pkcs8EncType == UNENCRYPTED) {\r\n            return UNENC_PKCS8_PVK;\r\n        }\r\n    }\r\n    EncryptionType msPvkEncType = MsPvkUtil.getEncryptionType(data);\r\n    if (msPvkEncType != null) {\r\n        if (msPvkEncType == ENCRYPTED) {\r\n            return ENC_MS_PVK;\r\n        } else if (msPvkEncType == UNENCRYPTED) {\r\n            return UNENC_MS_PVK;\r\n        }\r\n    }\r\n    EncryptionType openSslPvkEncType = OpenSslPvkUtil.getEncryptionType(data);\r\n    if (openSslPvkEncType != null) {\r\n        if (openSslPvkEncType == ENCRYPTED) {\r\n            return ENC_OPENSSL_PVK;\r\n        } else if (openSslPvkEncType == UNENCRYPTED) {\r\n            return UNENC_OPENSSL_PVK;\r\n        }\r\n    }\r\n    try {\r\n        OpenSslPubUtil.load(data);\r\n        return OPENSSL_PUB;\r\n    } catch (Exception ex) {\r\n    } catch (OutOfMemoryError ex) {\r\n    }\r\n    try {\r\n        if (X509CertUtil.loadCertificates(data).length > 0) {\r\n            return CERT;\r\n        }\r\n    } catch (Exception ex) {\r\n    }\r\n    try {\r\n        X509CertUtil.loadCRL(data);\r\n        return CRL;\r\n    } catch (Exception ex) {\r\n    }\r\n    CsrType csrType = detectCsrType(data);\r\n    if (csrType != null) {\r\n        return csrType.getCryptoFileType();\r\n    }\r\n    KeyStoreType keyStoreType = detectKeyStoreType(data);\r\n    if (keyStoreType != null) {\r\n        return keyStoreType.getCryptoFileType();\r\n    }\r\n    return UNKNOWN;\r\n}"
}, {
	"Path": "org.kse.crypto.ecc.EccUtil.getNamedCurve",
	"Comment": "determines the name of the domain parameters that were used for generating the key.",
	"Method": "String getNamedCurve(Key key){\r\n    if (!(key instanceof ECKey)) {\r\n        throw new InvalidParameterException(\"Not a EC private key.\");\r\n    }\r\n    ECKey ecKey = (ECKey) key;\r\n    ECParameterSpec params = ecKey.getParams();\r\n    if (!(params instanceof ECNamedCurveSpec)) {\r\n        return \"\";\r\n    }\r\n    ECNamedCurveSpec ecPrivateKeySpec = (ECNamedCurveSpec) params;\r\n    String namedCurve = ecPrivateKeySpec.getName();\r\n    return namedCurve;\r\n}"
}, {
	"Path": "org.joda.money.Money.isSameCurrency",
	"Comment": "checks if this instance and the specified instance have the same currency.",
	"Method": "boolean isSameCurrency(BigMoneyProvider other){\r\n    return money.isSameCurrency(other);\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct5.projectD",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the fourth slot value.",
	"Method": "Maybe<D> projectD(){\r\n    return project()._4();\r\n}"
}, {
	"Path": "org.locationtech.jts.precision.CoordinatePrecisionReducerFilter.filter",
	"Comment": "rounds the coordinates in the sequence to match the precisionmodel",
	"Method": "void filter(CoordinateSequence seq,int i){\r\n    seq.setOrdinate(i, 0, precModel.makePrecise(seq.getOrdinate(i, 0)));\r\n    seq.setOrdinate(i, 1, precModel.makePrecise(seq.getOrdinate(i, 1)));\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct5.projectC",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the third slot value.",
	"Method": "Maybe<C> projectC(){\r\n    return project()._3();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct5.projectB",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the second slot value.",
	"Method": "Maybe<B> projectB(){\r\n    return project()._2();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct5.projectA",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the first slot value.",
	"Method": "Maybe<A> projectA(){\r\n    return project()._1();\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.Coordinate.equalInZ",
	"Comment": "tests if another coordinate has the same value for z, within a tolerance.",
	"Method": "boolean equalInZ(Coordinate c,double tolerance){\r\n    return NumberUtil.equalsWithTolerance(this.getZ(), c.getZ(), tolerance);\r\n}"
}, {
	"Path": "org.locationtech.jts.index.chain.MonotoneChain.select",
	"Comment": "determine all the line segments in the chain whose envelopes overlapthe searchenvelope, and process them.the monotone chain search algorithm attempts to optimize performance by not calling the select action on chain segmentswhich it can determine are not in the search envelope.however, itcall the select action on segmentswhich do not intersect the search envelope.this saves on the overhead of checking envelope intersectioneach time, since clients may be able to do this more efficiently.",
	"Method": "void select(Envelope searchEnv,MonotoneChainSelectAction mcs){\r\n    computeSelect(searchEnv, start, end, mcs);\r\n}"
}, {
	"Path": "org.locationtech.jts.index.intervalrtree.SortedPackedIntervalRTree.insert",
	"Comment": "adds an item to the index which is associated with the given interval",
	"Method": "void insert(double min,double max,Object item){\r\n    if (root != null)\r\n        throw new IllegalStateException(\"Index cannot be added to once it has been queried\");\r\n    leaves.add(new IntervalRTreeLeafNode(min, max, item));\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct5.projectE",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the fifth slot value.",
	"Method": "Maybe<E> projectE(){\r\n    return project()._5();\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.entities.impl.JDAImpl.getGatewayBot",
	"Comment": "this method also checks for a valid bot token as it is required to get the recommended shard count.",
	"Method": "Pair<String, Integer> getGatewayBot(){\r\n    return getSessionController().getGatewayBot(this);\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifInterface.getRotationForOrientationValue",
	"Comment": "returns the rotation degrees corresponding to an exiftag orientationvalue.",
	"Method": "int getRotationForOrientationValue(short orientation){\r\n    switch(orientation) {\r\n        case Orientation.TOP_LEFT:\r\n            return 0;\r\n        case Orientation.RIGHT_TOP:\r\n            return 90;\r\n        case Orientation.BOTTOM_LEFT:\r\n            return 180;\r\n        case Orientation.RIGHT_BOTTOM:\r\n            return 270;\r\n        default:\r\n            return 0;\r\n    }\r\n}"
}, {
	"Path": "test.jts.perf.PerformanceTestCase.setRunIterations",
	"Comment": "sets the number of iterations to execute the test methods in each test run.",
	"Method": "void setRunIterations(int runIter){\r\n    this.runIter = runIter;\r\n}"
}, {
	"Path": "com.jdon.aop.interceptor.SessionContextInterceptor.setSessionContext",
	"Comment": "webserviceaccessorimp create sessioncontext and save infomation into it",
	"Method": "void setSessionContext(Object targetObject,TargetMetaRequest targetMetaRequest){\r\n    if (isSessionContextAcceptables.contains(targetMetaRequest.getTargetMetaDef().getName())) {\r\n        SessionContextAcceptable myResult = (SessionContextAcceptable) targetObject;\r\n        SessionContext sessionContext = targetMetaRequest.getSessionContext();\r\n        myResult.setSessionContext(sessionContext);\r\n    } else if (isSessionContextAcceptablesAnnotations.containsKey(targetMetaRequest.getTargetMetaDef().getName())) {\r\n        Method method = isSessionContextAcceptablesAnnotations.get(targetMetaRequest.getTargetMetaDef().getName());\r\n        try {\r\n            Object[] sessionContexts = new SessionContext[1];\r\n            sessionContexts[0] = targetMetaRequest.getSessionContext();\r\n            method.invoke(targetObject, sessionContexts);\r\n        } catch (Exception e) {\r\n            Debug.logError(\"[JdonFramework]the target must has method setSessionContext(SessionContext sessionContext) : \" + e, module);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.jsql.view.swing.table.AdjusterTableColumn.setDynamicAdjustment",
	"Comment": "indicate whether changes to the model should cause the width to be dynamically recalculated.",
	"Method": "void setDynamicAdjustment(boolean isDynamicAdjustment){\r\n    if (this.isDynamicAdjustment != isDynamicAdjustment) {\r\n        if (isDynamicAdjustment) {\r\n            this.tableAdjust.addPropertyChangeListener(this);\r\n            this.tableAdjust.getModel().addTableModelListener(this);\r\n        } else {\r\n            this.tableAdjust.removePropertyChangeListener(this);\r\n            this.tableAdjust.getModel().removeTableModelListener(this);\r\n        }\r\n    }\r\n    this.isDynamicAdjustment = isDynamicAdjustment;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.IsSimpleOp.hasNonEndpointIntersection",
	"Comment": "for all edges, check if there are any intersections which are not at an endpoint.the geometry is not simple if there are intersections not at endpoints.",
	"Method": "boolean hasNonEndpointIntersection(GeometryGraph graph){\r\n    for (Iterator i = graph.getEdgeIterator(); i.hasNext(); ) {\r\n        Edge e = (Edge) i.next();\r\n        int maxSegmentIndex = e.getMaximumSegmentIndex();\r\n        for (Iterator eiIt = e.getEdgeIntersectionList().iterator(); eiIt.hasNext(); ) {\r\n            EdgeIntersection ei = (EdgeIntersection) eiIt.next();\r\n            if (!ei.isEndPoint(maxSegmentIndex)) {\r\n                nonSimpleLocation = ei.getCoordinate();\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.valid.IsValidOp.checkConsistentArea",
	"Comment": "checks that the arrangement of edges in a polygonal geometry graphforms a consistent area.",
	"Method": "void checkConsistentArea(GeometryGraph graph){\r\n    ConsistentAreaTester cat = new ConsistentAreaTester(graph);\r\n    boolean isValidArea = cat.isNodeConsistentArea();\r\n    if (!isValidArea) {\r\n        validErr = new TopologyValidationError(TopologyValidationError.SELF_INTERSECTION, cat.getInvalidPoint());\r\n        return;\r\n    }\r\n    if (cat.hasDuplicateRings()) {\r\n        validErr = new TopologyValidationError(TopologyValidationError.DUPLICATE_RINGS, cat.getInvalidPoint());\r\n    }\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifInterface.addGpsTags",
	"Comment": "creates and sets all to the gps tags for a give latitude and longitude.",
	"Method": "boolean addGpsTags(double latitude,double longitude){\r\n    ExifTag latTag = buildTag(TAG_GPS_LATITUDE, toExifLatLong(latitude));\r\n    ExifTag longTag = buildTag(TAG_GPS_LONGITUDE, toExifLatLong(longitude));\r\n    ExifTag latRefTag = buildTag(TAG_GPS_LATITUDE_REF, latitude >= 0 ? ExifInterface.GpsLatitudeRef.NORTH : ExifInterface.GpsLatitudeRef.SOUTH);\r\n    ExifTag longRefTag = buildTag(TAG_GPS_LONGITUDE_REF, longitude >= 0 ? ExifInterface.GpsLongitudeRef.EAST : ExifInterface.GpsLongitudeRef.WEST);\r\n    if (latTag == null || longTag == null || latRefTag == null || longRefTag == null) {\r\n        return false;\r\n    }\r\n    setTag(latTag);\r\n    setTag(longTag);\r\n    setTag(latRefTag);\r\n    setTag(longRefTag);\r\n    return true;\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherScroller.fling",
	"Comment": "start scrolling based on a fling gesture. the distance travelled willdepend on the initial velocity of the fling.",
	"Method": "void fling(int startX,int startY,int velocityX,int velocityY,int minX,int maxX,int minY,int maxY){\r\n    if (mFlywheel && !mFinished) {\r\n        float oldVel = getCurrVelocity();\r\n        float dx = (float) (mFinalX - mStartX);\r\n        float dy = (float) (mFinalY - mStartY);\r\n        float hyp = (float) Math.hypot(dx, dy);\r\n        float ndx = dx / hyp;\r\n        float ndy = dy / hyp;\r\n        float oldVelocityX = ndx * oldVel;\r\n        float oldVelocityY = ndy * oldVel;\r\n        if (Math.signum(velocityX) == Math.signum(oldVelocityX) && Math.signum(velocityY) == Math.signum(oldVelocityY)) {\r\n            velocityX += oldVelocityX;\r\n            velocityY += oldVelocityY;\r\n        }\r\n    }\r\n    mMode = FLING_MODE;\r\n    mFinished = false;\r\n    float velocity = (float) Math.hypot(velocityX, velocityY);\r\n    mVelocity = velocity;\r\n    mDuration = getSplineFlingDuration(velocity);\r\n    mStartTime = AnimationUtils.currentAnimationTimeMillis();\r\n    mStartX = startX;\r\n    mStartY = startY;\r\n    float coeffX = velocity == 0 ? 1.0f : velocityX / velocity;\r\n    float coeffY = velocity == 0 ? 1.0f : velocityY / velocity;\r\n    double totalDistance = getSplineFlingDistance(velocity);\r\n    mDistance = (int) (totalDistance * Math.signum(velocity));\r\n    mMinX = minX;\r\n    mMaxX = maxX;\r\n    mMinY = minY;\r\n    mMaxY = maxY;\r\n    mFinalX = startX + (int) Math.round(totalDistance * coeffX);\r\n    mFinalX = Math.min(mFinalX, mMaxX);\r\n    mFinalX = Math.max(mFinalX, mMinX);\r\n    mFinalY = startY + (int) Math.round(totalDistance * coeffY);\r\n    mFinalY = Math.min(mFinalY, mMaxY);\r\n    mFinalY = Math.max(mFinalY, mMinY);\r\n}"
}, {
	"Path": "com.jdon.util.UtilDateTime.toDate",
	"Comment": "makes a date from separate ints for month, day, year, hour, minute, and\tsecond.",
	"Method": "java.util.Date toDate(String dateTime,java.util.Date toDate,String date,String time,java.util.Date toDate,String monthStr,String dayStr,String yearStr,String hourStr,String minuteStr,String secondStr,java.util.Date toDate,int month,int day,int year,int hour,int minute,int second){\r\n    Calendar calendar = Calendar.getInstance();\r\n    try {\r\n        calendar.set(year, month - 1, day, hour, minute, second);\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n    return new java.util.Date(calendar.getTime().getTime());\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.MinimumDiameter.getMinimumDiameter",
	"Comment": "gets the length of the minimum diameter enclosing a geometry",
	"Method": "Geometry getMinimumDiameter(Geometry geom){\r\n    return (new MinimumDiameter(geom)).getDiameter();\r\n}"
}, {
	"Path": "com.jdon.bussinessproxy.remote.http.HttpClient.getThreadLock",
	"Comment": "this method is used to limit the concurrent http call to the max fixed by\tmaxthreadcount and to wait the end of the first call that will return the\tsession id.",
	"Method": "void getThreadLock(){\r\n    while (sessionId == null && curUsedThread > 1) {\r\n        try {\r\n            Debug.logVerbose(\"No session. Only one thread is authorized. Waiting ...\", module);\r\n            wait();\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    while (curUsedThread >= maxThreadCount) {\r\n        try {\r\n            Debug.logVerbose(\"[JdonFramework]Max concurent http call reached. Waiting ...\", module);\r\n            wait();\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    curUsedThread++;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.OffsetCurveBuilder.getBufferParameters",
	"Comment": "gets the buffer parameters being used to generate the curve.",
	"Method": "BufferParameters getBufferParameters(){\r\n    return bufParams;\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isHour",
	"Comment": "ishour returns true if string s is a valid number between 0 and 23.",
	"Method": "boolean isHour(String s){\r\n    if (isEmpty(s))\r\n        return defaultEmptyOK;\r\n    return isIntegerInRange(s, 0, 23);\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.IteratedNoder.node",
	"Comment": "node the input segment strings onceand create the split edges between the nodes",
	"Method": "void node(Collection segStrings,int[] numInteriorIntersections){\r\n    IntersectionAdder si = new IntersectionAdder(li);\r\n    MCIndexNoder noder = new MCIndexNoder();\r\n    noder.setSegmentIntersector(si);\r\n    noder.computeNodes(segStrings);\r\n    nodedSegStrings = noder.getNodedSubstrings();\r\n    numInteriorIntersections[0] = si.numInteriorIntersections;\r\n}"
}, {
	"Path": "org.locationtech.jts.simplify.TaggedLineStringSimplifier.setDistanceTolerance",
	"Comment": "sets the distance tolerance for the simplification.all vertices in the simplified geometry will be within thisdistance of the original geometry.",
	"Method": "void setDistanceTolerance(double distanceTolerance){\r\n    this.distanceTolerance = distanceTolerance;\r\n}"
}, {
	"Path": "com.jsql.util.GitUtil.sendReport",
	"Comment": "connect to github webservices and create an issue on the repository.used by translation protocol, unhandled exception detection and manual issue reporting.",
	"Method": "void sendReport(String reportBody,ShowOnConsole showOnConsole,String reportTitle){\r\n    if (!ProxyUtil.isChecked(showOnConsole)) {\r\n        return;\r\n    }\r\n    HttpURLConnection connection = null;\r\n    try {\r\n        URL githubUrl = new URL(PropertiesUtil.getInstance().getProperties().getProperty(\"github.issues.url\"));\r\n        connection = (HttpURLConnection) githubUrl.openConnection();\r\n        connection.setDefaultUseCaches(false);\r\n        connection.setUseCaches(false);\r\n        connection.setRequestProperty(\"Pragma\", \"no-cache\");\r\n        connection.setRequestProperty(\"Cache-Control\", \"no-cache\");\r\n        connection.setRequestProperty(\"Expires\", \"-1\");\r\n        connection.setRequestProperty(\"Content-Type\", \"application/json\");\r\n        // TODO define in properties\r\n        connection.setRequestProperty(\"Authorization\", \"token \" + StringUtils.newStringUtf8(Base64.decodeBase64(PropertiesUtil.getInstance().getProperties().getProperty(\"github.token\"))));\r\n        connection.setReadTimeout(ConnectionUtil.getTimeout());\r\n        connection.setConnectTimeout(ConnectionUtil.getTimeout());\r\n        connection.setDoOutput(true);\r\n        DataOutputStream dataOut = new DataOutputStream(connection.getOutputStream());\r\n        dataOut.writeBytes(new JSONObject().put(\"title\", reportTitle).put(\"body\", StringUtil.decimalHtmlEncode(reportBody)).toString());\r\n        dataOut.flush();\r\n        dataOut.close();\r\n        GitUtil.readGithubResponse(connection, showOnConsole);\r\n    } catch (IOException | NoClassDefFoundError e) {\r\n        if (showOnConsole == ShowOnConsole.YES) {\r\n            LOGGER.warn(\"Error during Git report connection: \" + e.getMessage(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.functions.Fn1.strengthen",
	"Comment": "pair a value with the input to this function, and preserve the paired value through to the output.",
	"Method": "Fn1<Tuple2<C, A>, Tuple2<C, B>> strengthen(){\r\n    return t -> t.fmap(this);\r\n}"
}, {
	"Path": "org.locationtech.jts.io.oracle.OraWriter.writeOrdsOriented",
	"Comment": "writes ordinates in the orientationspecified by the iswriteccw ccw flag.coordinates are reversed if necessary.",
	"Method": "int writeOrdsOriented(CoordinateSequence seq,int dim,double[] ordData,int ordIndex,boolean isWriteCCW){\r\n    Coordinate[] coords = seq.toCoordinateArray();\r\n    boolean isCCW = CGAlgorithms.isCCW(coords);\r\n    if (isCCW != isWriteCCW) {\r\n        return writeOrdsReverse(seq, dim, ordData, ordIndex);\r\n    }\r\n    return writeOrds(seq, dim, ordData, ordIndex);\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.syntax.SQLToken.isSeparator",
	"Comment": "checks this token to see if it is a separator. separators are explainedin java languagespecification.",
	"Method": "boolean isSeparator(){\r\n    return (this.id >> 8) == 0x4;\r\n}"
}, {
	"Path": "org.kse.gui.JMenuRecentFiles.getRecentFiles",
	"Comment": "get the set of recent files currently maintained by the menu in order.",
	"Method": "File[] getRecentFiles(){\r\n    ArrayList<File> recentFiles = new ArrayList();\r\n    for (int i = 0; i < jmiRecentFiles.length; i++) {\r\n        if (jmiRecentFiles[i] == null) {\r\n            break;\r\n        }\r\n        recentFiles.add(jmiRecentFiles[i].getFile());\r\n    }\r\n    return recentFiles.toArray(new File[recentFiles.size()]);\r\n}"
}, {
	"Path": "org.locationtech.jtstest.function.ValidationFunctions.invalidLocations",
	"Comment": "validates all geometries in a collection independently.errors are returned as points at the invalid location",
	"Method": "Geometry invalidLocations(Geometry g){\r\n    List invalidLoc = new ArrayList();\r\n    for (int i = 0; i < g.getNumGeometries(); i++) {\r\n        Geometry geom = g.getGeometryN(i);\r\n        IsValidOp ivop = new IsValidOp(geom);\r\n        TopologyValidationError err = ivop.getValidationError();\r\n        if (err != null) {\r\n            invalidLoc.add(g.getFactory().createPoint(err.getCoordinate()));\r\n        }\r\n    }\r\n    return g.getFactory().buildGeometry(invalidLoc);\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DD.selfSqr",
	"Comment": "squares this object.to prevent altering constants, this method must only be used on values known to be newly created.",
	"Method": "DD selfSqr(){\r\n    return this.selfMultiply(this);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.predicate.RectangleContains.isLineStringContainedInBoundary",
	"Comment": "tests if a linestring is completely contained in the boundary of the target rectangle.",
	"Method": "boolean isLineStringContainedInBoundary(LineString line){\r\n    CoordinateSequence seq = line.getCoordinateSequence();\r\n    Coordinate p0 = new Coordinate();\r\n    Coordinate p1 = new Coordinate();\r\n    for (int i = 0; i < seq.size() - 1; i++) {\r\n        seq.getCoordinate(i, p0);\r\n        seq.getCoordinate(i + 1, p1);\r\n        if (!isLineSegmentContainedInBoundary(p0, p1))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.Length.ofLine",
	"Comment": "computes the length of a linestring specified by a sequence of points.",
	"Method": "double ofLine(CoordinateSequence pts){\r\n    int n = pts.size();\r\n    if (n <= 1)\r\n        return 0.0;\r\n    double len = 0.0;\r\n    Coordinate p = new Coordinate();\r\n    pts.getCoordinate(0, p);\r\n    double x0 = p.x;\r\n    double y0 = p.y;\r\n    for (int i = 1; i < n; i++) {\r\n        pts.getCoordinate(i, p);\r\n        double x1 = p.x;\r\n        double y1 = p.y;\r\n        double dx = x1 - x0;\r\n        double dy = y1 - y0;\r\n        len += Math.sqrt(dx * dx + dy * dy);\r\n        x0 = x1;\r\n        y0 = y1;\r\n    }\r\n    return len;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.util.AffineTransformation.shear",
	"Comment": "updates the value of this transformationto that of a shear transformation composed with the current value.",
	"Method": "AffineTransformation shear(double xShear,double yShear){\r\n    compose(shearInstance(xShear, yShear));\r\n    return this;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.MinimumBoundingCircle.getDiameter",
	"Comment": "gets a geometry representing the diameter of the computed minimum boundingcircle.",
	"Method": "Geometry getDiameter(){\r\n    compute();\r\n    switch(extremalPts.length) {\r\n        case 0:\r\n            return input.getFactory().createLineString();\r\n        case 1:\r\n            return input.getFactory().createPoint(centre);\r\n    }\r\n    Coordinate p0 = extremalPts[0];\r\n    Coordinate p1 = extremalPts[1];\r\n    return input.getFactory().createLineString(new Coordinate[] { p0, p1 });\r\n}"
}, {
	"Path": "org.joda.money.Money.plusMajor",
	"Comment": "returns a copy of this monetary value with the amount in major units added.this adds an amount in major units, leaving the minor units untouched.for example, usd 23.45 plus 138 gives usd 161.45.this instance is immutable and unaffected by this method.",
	"Method": "Money plusMajor(long amountToAdd){\r\n    return with(money.plusMajor(amountToAdd));\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.overlay.LineBuilder.collectLineEdge",
	"Comment": "collect line edges which are in the result.line edges are in the result if they are not part ofan area boundary, if they are in the result of the overlay operation,and if they are not covered by a result area.",
	"Method": "void collectLineEdge(DirectedEdge de,int opCode,List edges){\r\n    Label label = de.getLabel();\r\n    Edge e = de.getEdge();\r\n    if (de.isLineEdge()) {\r\n        if (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {\r\n            edges.add(e);\r\n            de.setVisitedEdge(true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifData.hasCompressedThumbnail",
	"Comment": "returns true it this header contains a compressed thumbnail.",
	"Method": "boolean hasCompressedThumbnail(){\r\n    return mThumbnail != null;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.MinimumDiameter.getLength",
	"Comment": "gets the length of the minimum diameter of the input geometry",
	"Method": "double getLength(){\r\n    computeMinimumDiameter();\r\n    return minWidth;\r\n}"
}, {
	"Path": "com.android.launcher3.IconCache.updateIconsForPkg",
	"Comment": "updates the entries related to the given package in memory and persistent db.",
	"Method": "void updateIconsForPkg(String packageName,UserHandleCompat user){\r\n    removeIconsForPkg(packageName, user);\r\n    try {\r\n        PackageInfo info = mPackageManager.getPackageInfo(packageName, PackageManager.GET_UNINSTALLED_PACKAGES);\r\n        long userSerial = mUserManager.getSerialNumberForUser(user);\r\n        for (LauncherActivityInfoCompat app : mLauncherApps.getActivityList(packageName, user)) {\r\n            addIconToDBAndMemCache(app, info, userSerial);\r\n        }\r\n    } catch (NameNotFoundException e) {\r\n        Log.d(TAG, \"Package not found\", e);\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.snapround.GeometryNoder.node",
	"Comment": "nodes the linework of a set of geometrys using snaprounding.",
	"Method": "List node(Collection geoms){\r\n    Geometry geom0 = (Geometry) geoms.iterator().next();\r\n    geomFact = geom0.getFactory();\r\n    List segStrings = toSegmentStrings(extractLines(geoms));\r\n    Noder sr = new MCIndexSnapRounder(pm);\r\n    sr.computeNodes(segStrings);\r\n    Collection nodedLines = sr.getNodedSubstrings();\r\n    if (isValidityChecked) {\r\n        NodingValidator nv = new NodingValidator(nodedLines);\r\n        nv.checkValid();\r\n    }\r\n    return toLineStrings(nodedLines);\r\n}"
}, {
	"Path": "org.kse.gui.crypto.accessdescription.AccessDescriptionsTableHeadRend.getTableCellRendererComponent",
	"Comment": "returns the rendered header cell for the supplied value and column.",
	"Method": "Component getTableCellRendererComponent(JTable jTable,Object value,boolean isSelected,boolean hasFocus,int row,int col){\r\n    Component c = delegate.getTableCellRendererComponent(jTable, value, isSelected, hasFocus, row, col);\r\n    if (c instanceof JLabel) {\r\n        JLabel header = (JLabel) c;\r\n        if (col == 0) {\r\n            header.setToolTipText(res.getString(\"AccessDescriptionsTableHeadRend.AccessMethodColumn.tooltip\"));\r\n        } else {\r\n            header.setToolTipText(res.getString(\"AccessDescriptionsTableHeadRend.AccessLocationColumn.tooltip\"));\r\n        }\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "com.jdon.util.RequestUtil.decodePasswordCookie",
	"Comment": "unrafels a cookie string containing a username and password.",
	"Method": "String[] decodePasswordCookie(String cookieVal){\r\n    if (cookieVal == null || cookieVal.length() <= 0) {\r\n        return null;\r\n    }\r\n    char[] chars = cookieVal.toCharArray();\r\n    byte[] bytes = new byte[chars.length / 2];\r\n    int b;\r\n    for (int n = 0, m = 0; n < bytes.length; n++) {\r\n        b = chars[m++] - ENCODE_CHAR_OFFSET1;\r\n        b |= (chars[m++] - ENCODE_CHAR_OFFSET2) << 4;\r\n        bytes[n] = (byte) (b ^ (ENCODE_XORMASK + n));\r\n    }\r\n    cookieVal = new String(bytes);\r\n    int pos = cookieVal.indexOf(ENCODE_DELIMETER);\r\n    String username = (pos < 0) ? \"\" : cookieVal.substring(0, pos);\r\n    String password = (pos < 0) ? \"\" : cookieVal.substring(pos + 1);\r\n    return new String[] { username, password };\r\n}"
}, {
	"Path": "org.kse.ApplicationSettings.getInstance",
	"Comment": "get singleton instance of application settings. if first call the\tapplication settings are loaded.",
	"Method": "ApplicationSettings getInstance(){\r\n    if (applicationSettings == null) {\r\n        applicationSettings = new ApplicationSettings();\r\n    }\r\n    return applicationSettings;\r\n}"
}, {
	"Path": "org.locationtech.jts.io.WKTReader.parseErrorWithLine",
	"Comment": "creates a formatted parseexception reporting that the current tokenwas unexpected.",
	"Method": "ParseException parseErrorWithLine(StreamTokenizer tokenizer,String msg){\r\n    return new ParseException(msg + \" (line \" + tokenizer.lineno() + \")\");\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.overlay.OverlayOp.replaceCollapsedEdges",
	"Comment": "if edges which have undergone dimensional collapse are found,replace them with a new edge which is a l edge",
	"Method": "void replaceCollapsedEdges(){\r\n    List newEdges = new ArrayList();\r\n    for (Iterator it = edgeList.iterator(); it.hasNext(); ) {\r\n        Edge e = (Edge) it.next();\r\n        if (e.isCollapsed()) {\r\n            it.remove();\r\n            newEdges.add(e.getCollapsedEdge());\r\n        }\r\n    }\r\n    edgeList.addAll(newEdges);\r\n}"
}, {
	"Path": "com.jdon.servicelocator.ejb.ServiceLocator.getRemoteHome",
	"Comment": "will get the ejb remote home factory. clients need to cast to the type of\tejbhome they desire",
	"Method": "EJBHome getRemoteHome(String jndiHomeName,Class className){\r\n    EJBHome home = null;\r\n    try {\r\n        Object objref = ic.lookup(jndiHomeName);\r\n        Object obj = PortableRemoteObject.narrow(objref, className);\r\n        home = (EJBHome) obj;\r\n    } catch (NamingException ne) {\r\n        throw new ServiceLocatorException(ne);\r\n    } catch (Exception e) {\r\n        throw new ServiceLocatorException(e);\r\n    }\r\n    return home;\r\n}"
}, {
	"Path": "org.locationtech.jts.simplify.TaggedLineStringSimplifier.flatten",
	"Comment": "flattens a section of the line betweenindexes start and end,replacing them with a line between the endpoints.the input and output indexes are updatedto reflect this.",
	"Method": "LineSegment flatten(int start,int end){\r\n    Coordinate p0 = linePts[start];\r\n    Coordinate p1 = linePts[end];\r\n    LineSegment newSeg = new LineSegment(p0, p1);\r\n    remove(line, start, end);\r\n    outputIndex.add(newSeg);\r\n    return newSeg;\r\n}"
}, {
	"Path": "org.locationtech.jtstest.util.StringUtil.stringOfChar",
	"Comment": "returns a string of the given length consisting entirely of the given character",
	"Method": "String stringOfChar(char ch,int count){\r\n    StringBuffer buf = new StringBuffer();\r\n    for (int i = 0; i < count; i++) {\r\n        buf.append(ch);\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.bindFolders",
	"Comment": "implementation of the method from launchermodel.callbacks.",
	"Method": "void bindFolders(LongArrayMap<FolderInfo> folders){\r\n    Runnable r = new Runnable() {\r\n        public void run() {\r\n            bindFolders(folders);\r\n        }\r\n    };\r\n    if (waitUntilResume(r)) {\r\n        return;\r\n    }\r\n    sFolders = folders.clone();\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.bindFolders",
	"Comment": "implementation of the method from launchermodel.callbacks.",
	"Method": "void bindFolders(LongArrayMap<FolderInfo> folders){\r\n    bindFolders(folders);\r\n}"
}, {
	"Path": "com.android.launcher3.AutoInstallsLayout.loadLayout",
	"Comment": "loads the layout in the db and returns the number of entries added on the desktop.",
	"Method": "int loadLayout(SQLiteDatabase db,ArrayList<Long> screenIds){\r\n    mDb = db;\r\n    try {\r\n        return parseLayout(mLayoutId, screenIds);\r\n    } catch (Exception e) {\r\n        Log.w(TAG, \"Got exception parsing layout.\", e);\r\n        return -1;\r\n    }\r\n}"
}, {
	"Path": "org.kse.version.JavaVersion.isBelow",
	"Comment": "compares version of the current jre with the passed version.",
	"Method": "boolean isBelow(JavaVersion javaVersion){\r\n    return compareTo(javaVersion) < 0;\r\n}"
}, {
	"Path": "com.android.launcher3.AutoInstallsLayout.parseContainerAndScreen",
	"Comment": "parses container and screenid attribute from the current tag, and puts it in the out.",
	"Method": "void parseContainerAndScreen(XmlResourceParser parser,long[] out){\r\n    if (HOTSEAT_CONTAINER_NAME.equals(getAttributeValue(parser, ATTR_CONTAINER))) {\r\n        out[0] = Favorites.CONTAINER_HOTSEAT;\r\n        long rank = Long.parseLong(getAttributeValue(parser, ATTR_RANK));\r\n        out[1] = (rank < mHotseatAllAppsRank) ? rank : (rank + 1);\r\n    } else {\r\n        out[0] = Favorites.CONTAINER_DESKTOP;\r\n        out[1] = Long.parseLong(getAttributeValue(parser, ATTR_SCREEN));\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.predicate.RectangleIntersects.intersects",
	"Comment": "tests whether the given geometry intersectsthe query rectangle.",
	"Method": "boolean intersects(Polygon rectangle,Geometry b,boolean intersects,Geometry geom,boolean intersects,boolean intersects){\r\n    if (!rectEnv.intersects(geom.getEnvelopeInternal()))\r\n        return false;\r\n    EnvelopeIntersectsVisitor visitor = new EnvelopeIntersectsVisitor(rectEnv);\r\n    visitor.applyTo(geom);\r\n    if (visitor.intersects())\r\n        return true;\r\n    GeometryContainsPointVisitor ecpVisitor = new GeometryContainsPointVisitor(rectangle);\r\n    ecpVisitor.applyTo(geom);\r\n    if (ecpVisitor.containsPoint())\r\n        return true;\r\n    RectangleIntersectsSegmentVisitor riVisitor = new RectangleIntersectsSegmentVisitor(rectangle);\r\n    riVisitor.applyTo(geom);\r\n    if (riVisitor.intersects())\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testbuilder.model.GeometryEditModel.locateVertex",
	"Comment": "locates a vertex of the current geometrywithin the given tolerance, if any.returns the closest point on the segment.",
	"Method": "GeometryLocation locateVertex(Coordinate testPt,double tolerance){\r\n    Geometry geom = getGeometry();\r\n    if (geom == null)\r\n        return null;\r\n    return GeometryPointLocater.locateVertex(getGeometry(), testPt, tolerance);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.BufferParameters.setSimplifyFactor",
	"Comment": "sets the factor used to determine the simplify distance tolerancefor input simplification.simplifying can increase the performance of computing buffers.generally the simplify factor should be greater than 0.values between 0.01 and .1 produce relatively good accuracy for the generate buffer.larger values sacrifice accuracy in return for performance.",
	"Method": "void setSimplifyFactor(double simplifyFactor){\r\n    this.simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.util.GeometryCombiner.extractFactory",
	"Comment": "extracts the geometryfactory used by the geometries in a collection",
	"Method": "GeometryFactory extractFactory(Collection geoms){\r\n    if (geoms.isEmpty())\r\n        return null;\r\n    return ((Geometry) geoms.iterator().next()).getFactory();\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.SegmentNodeList.checkSplitEdgesCorrectness",
	"Comment": "checks the correctness of the set of split edges corresponding to this edge.",
	"Method": "void checkSplitEdgesCorrectness(List splitEdges){\r\n    Coordinate[] edgePts = edge.getCoordinates();\r\n    SegmentString split0 = (SegmentString) splitEdges.get(0);\r\n    Coordinate pt0 = split0.getCoordinate(0);\r\n    if (!pt0.equals2D(edgePts[0]))\r\n        throw new RuntimeException(\"bad split edge start point at \" + pt0);\r\n    SegmentString splitn = (SegmentString) splitEdges.get(splitEdges.size() - 1);\r\n    Coordinate[] splitnPts = splitn.getCoordinates();\r\n    Coordinate ptn = splitnPts[splitnPts.length - 1];\r\n    if (!ptn.equals2D(edgePts[edgePts.length - 1]))\r\n        throw new RuntimeException(\"bad split edge end point at \" + ptn);\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.importexport.DExportCertificates.exportHead",
	"Comment": "export head certificate only? only applicable for key pair entries.",
	"Method": "boolean exportHead(){\r\n    return !exportChain;\r\n}"
}, {
	"Path": "org.joda.money.CurrencyUnit.compareTo",
	"Comment": "compares this currency to another by alphabetical comparison of the code.",
	"Method": "int compareTo(CurrencyUnit other){\r\n    return code.compareTo(other.code);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.valid.TopologyValidationError.toString",
	"Comment": "gets a message describing the type and location of this error.",
	"Method": "String toString(){\r\n    String locStr = \"\";\r\n    if (pt != null)\r\n        locStr = \" at or near point \" + pt;\r\n    return getMessage() + locStr;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.IntersectionMatrix.add",
	"Comment": "adds one matrix to another.addition is defined by taking the maximum dimension value of each positionin the summand matrices.",
	"Method": "void add(IntersectionMatrix im){\r\n    for (int i = 0; i < 3; i++) {\r\n        for (int j = 0; j < 3; j++) {\r\n            setAtLeast(i, j, im.get(i, j));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.kse.ApplicationSettings.addSslPort",
	"Comment": "add a new ssl port to start of current list of ports.\tmaximum number is 10. if port is already in list, it is brought to the first position.",
	"Method": "void addSslPort(String newSslPort){\r\n    String newSslPorts = StringUtils.addToList(newSslPort, getSslPorts(), 10);\r\n    setSslPorts(newSslPorts);\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.importexport.DImportKeyPairType.importOpenSsl",
	"Comment": "has the user chosen to import from openssl private key and certificate\tfile combination?",
	"Method": "boolean importOpenSsl(){\r\n    return jrbOpenSsl.isSelected();\r\n}"
}, {
	"Path": "org.locationtech.jts.precision.SimpleGeometryPrecisionReducer.reduce",
	"Comment": "convenience method for doing precision reduction on a single geometry,\twith collapses removed and keeping the geometry precision model the same.",
	"Method": "Geometry reduce(Geometry g,PrecisionModel precModel,Geometry reduce,Geometry geom){\r\n    GeometryEditor geomEdit;\r\n    if (changePrecisionModel) {\r\n        GeometryFactory newFactory = new GeometryFactory(newPrecisionModel, geom.getFactory().getSRID());\r\n        geomEdit = new GeometryEditor(newFactory);\r\n    } else\r\n        geomEdit = new GeometryEditor();\r\n    return geomEdit.edit(geom, new PrecisionReducerCoordinateOperation());\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.util.AffineTransformation.isDone",
	"Comment": "reports that this filter should continue to be executed until all coordinates have been transformed.",
	"Method": "boolean isDone(){\r\n    return false;\r\n}"
}, {
	"Path": "org.joda.money.Money.negated",
	"Comment": "returns a copy of this monetary value with the amount negated.this instance is immutable and unaffected by this method.",
	"Method": "Money negated(){\r\n    return with(money.negated());\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.RevokedCertsTableModel.load",
	"Comment": "load the revokedcertstablemodel with an array of x.509 crl entries.",
	"Method": "void load(X509CRLEntry[] revokedCerts){\r\n    TreeMap<BigInteger, X509CRLEntry> sortedRevokedCerts = new TreeMap();\r\n    for (int i = 0; i < revokedCerts.length; i++) {\r\n        sortedRevokedCerts.put(revokedCerts[i].getSerialNumber(), revokedCerts[i]);\r\n    }\r\n    data = new Object[sortedRevokedCerts.size()][2];\r\n    int i = 0;\r\n    for (Iterator<?> itr = sortedRevokedCerts.entrySet().iterator(); itr.hasNext(); i++) {\r\n        X509CRLEntry x509CrlEntry = (X509CRLEntry) ((Map.Entry) itr.next()).getValue();\r\n        data[i][0] = x509CrlEntry.getSerialNumber();\r\n        data[i][1] = x509CrlEntry.getRevocationDate();\r\n    }\r\n    fireTableDataChanged();\r\n}"
}, {
	"Path": "com.android.launcher3.CellLayout.pointToCellRounded",
	"Comment": "given a point, return the cell that most closely encloses that point",
	"Method": "void pointToCellRounded(int x,int y,int[] result){\r\n    pointToCellExact(x + (mCellWidth / 2), y + (mCellHeight / 2), result);\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.MinimumBoundingCircle.getFarthestPoints",
	"Comment": "gets a geometry representing a line between the two farthest pointsin the input.these points will be two of the extremal points of the minimum bounding circle.they also lie on the convex hull of the input.",
	"Method": "Geometry getFarthestPoints(){\r\n    compute();\r\n    switch(extremalPts.length) {\r\n        case 0:\r\n            return input.getFactory().createLineString();\r\n        case 1:\r\n            return input.getFactory().createPoint(centre);\r\n    }\r\n    Coordinate p0 = extremalPts[0];\r\n    Coordinate p1 = extremalPts[extremalPts.length - 1];\r\n    return input.getFactory().createLineString(new Coordinate[] { p0, p1 });\r\n}"
}, {
	"Path": "com.jsql.i18n.I18n.valueByKey",
	"Comment": "return the text corresponding to a i18n key in the properties.",
	"Method": "String valueByKey(String key){\r\n    return (String) I18n.localeDefault.getObject(key);\r\n}"
}, {
	"Path": "org.locationtech.jts.linearref.LinearLocation.compareLocationValues",
	"Comment": "compares this object with the specified index values for order.",
	"Method": "int compareLocationValues(int componentIndex1,int segmentIndex1,double segmentFraction1,int compareLocationValues,int componentIndex0,int segmentIndex0,double segmentFraction0,int componentIndex1,int segmentIndex1,double segmentFraction1){\r\n    if (componentIndex0 < componentIndex1)\r\n        return -1;\r\n    if (componentIndex0 > componentIndex1)\r\n        return 1;\r\n    if (segmentIndex0 < segmentIndex1)\r\n        return -1;\r\n    if (segmentIndex0 > segmentIndex1)\r\n        return 1;\r\n    if (segmentFraction0 < segmentFraction1)\r\n        return -1;\r\n    if (segmentFraction0 > segmentFraction1)\r\n        return 1;\r\n    return 0;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.lens.lenses.ListLens.asCopy",
	"Comment": "convenience static factory method for creating a lens over a copy of a list. useful for composition to avoidmutating a list reference.",
	"Method": "Lens.Simple<List<X>, List<X>> asCopy(){\r\n    return simpleLens(ArrayList::new, (xs, ys) -> ys);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.distance.DistanceOp.distance",
	"Comment": "report the distance between the nearest points on the input geometries.",
	"Method": "double distance(Geometry g0,Geometry g1,double distance){\r\n    if (geom[0] == null || geom[1] == null)\r\n        throw new IllegalArgumentException(\"null geometries are not supported\");\r\n    if (geom[0].isEmpty() || geom[1].isEmpty())\r\n        return 0.0;\r\n    computeMinDistance();\r\n    return minDistance;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.entities.MessageEmbed.getSiteProvider",
	"Comment": "the information on site from which the embed was generated from.if discord did not generate any deliverable information about the site, this returns null.",
	"Method": "Provider getSiteProvider(){\r\n    return siteProvider;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.managers.AccountManager.setPassword",
	"Comment": "sets the password for the currently logged in client account.if the new password is equal to the current password this does nothing.",
	"Method": "AccountManager setPassword(String newPassword,String currentPassword){\r\n    Checks.notNull(newPassword, \"password\");\r\n    Checks.check(newPassword.length() >= 6 && newPassword.length() <= 128, \"Password must be between 2-128 characters long\");\r\n    this.currentPassword = currentPassword;\r\n    this.password = newPassword;\r\n    set |= PASSWORD;\r\n    return this;\r\n}"
}, {
	"Path": "org.locationtech.jts.edgegraph.EdgeGraph.findEdge",
	"Comment": "finds an edge in this graph with the given originand destination, if one exists.",
	"Method": "HalfEdge findEdge(Coordinate orig,Coordinate dest){\r\n    HalfEdge e = (HalfEdge) vertexMap.get(orig);\r\n    if (e == null)\r\n        return null;\r\n    return e.find(dest);\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.prep.PreparedPolygonPredicate.isAnyTestComponentInTargetInterior",
	"Comment": "tests whether any component of the test geometry intersectsthe interior of the target geometry.handles test geometries with both linear and point components.",
	"Method": "boolean isAnyTestComponentInTargetInterior(Geometry testGeom){\r\n    List coords = ComponentCoordinateExtracter.getCoordinates(testGeom);\r\n    for (Iterator i = coords.iterator(); i.hasNext(); ) {\r\n        Coordinate p = (Coordinate) i.next();\r\n        int loc = targetPointLocator.locate(p);\r\n        if (loc == Location.INTERIOR)\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.joda.money.Money.minus",
	"Comment": "returns a copy of this monetary value with the amount subtracted.this subtracts the specified amount from this monetary amount, returning a new object.if the amount to subtract exceeds the scale of the currency, then therounding mode will be used to adjust the result.this instance is immutable and unaffected by this method.",
	"Method": "Money minus(Iterable<Money> moniesToSubtract,Money minus,Money moneyToSubtract,Money minus,BigDecimal amountToSubtract,Money minus,BigDecimal amountToSubtract,RoundingMode roundingMode,Money minus,double amountToSubtract,Money minus,double amountToSubtract,RoundingMode roundingMode){\r\n    return with(money.minusRetainScale(amountToSubtract, roundingMode));\r\n}"
}, {
	"Path": "org.locationtech.jts.precision.MinimumClearance.getLine",
	"Comment": "gets a linestring containing two pointswhich are at the minimum clearance distancefor the given geometry.",
	"Method": "Geometry getLine(Geometry g,LineString getLine){\r\n    compute();\r\n    if (minClearancePts == null || minClearancePts[0] == null)\r\n        return inputGeom.getFactory().createLineString();\r\n    return inputGeom.getFactory().createLineString(minClearancePts);\r\n}"
}, {
	"Path": "org.locationtech.jtsexample.geom.ExtendedCoordinateSequenceFactory.instance",
	"Comment": "returns the singleton instance of extendedcoordinatesequencefactory",
	"Method": "ExtendedCoordinateSequenceFactory instance(){\r\n    return instance;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.hlist.Tuple5.fill",
	"Comment": "given a value of type a, produced an instance of this tuple with each slot set to that value.",
	"Method": "Tuple5<A, A, A, A, A> fill(A a){\r\n    return tuple(a, a, a, a, a);\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.util.AffineTransformationBuilder.compute",
	"Comment": "computes the transformation matrix by solving the two systems of linear equationsdefined by the control point mappings,if this is possible.",
	"Method": "boolean compute(){\r\n    double[] bx = new double[] { dest0.x, dest1.x, dest2.x };\r\n    double[] row0 = solve(bx);\r\n    if (row0 == null)\r\n        return false;\r\n    m00 = row0[0];\r\n    m01 = row0[1];\r\n    m02 = row0[2];\r\n    double[] by = new double[] { dest0.y, dest1.y, dest2.y };\r\n    double[] row1 = solve(by);\r\n    if (row1 == null)\r\n        return false;\r\n    m10 = row1[0];\r\n    m11 = row1[1];\r\n    m12 = row1[2];\r\n    return true;\r\n}"
}, {
	"Path": "com.jsql.model.accessible.RessourceAccess.stopSearchingFile",
	"Comment": "mark the search of files to stop.any ongoing file reading is interrupted and any new file readis cancelled.",
	"Method": "void stopSearchingFile(){\r\n    RessourceAccess.isSearchFileStopped = true;\r\n    for (CallableFile callable : RessourceAccess.callablesReadFile) {\r\n        callable.getSuspendableReadFile().stop();\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.index.kdtree.KdTree.insertExact",
	"Comment": "inserts a point known to be beyond the distance tolerance of any existing node.the point is inserted at the bottom of the exact splitting path, so that tree shape is deterministic.",
	"Method": "KdNode insertExact(Coordinate p,Object data){\r\n    KdNode currentNode = root;\r\n    KdNode leafNode = root;\r\n    boolean isOddLevel = true;\r\n    boolean isLessThan = true;\r\n    while (currentNode != null) {\r\n        if (currentNode != null) {\r\n            boolean isInTolerance = p.distance(currentNode.getCoordinate()) <= tolerance;\r\n            if (isInTolerance) {\r\n                currentNode.increment();\r\n                return currentNode;\r\n            }\r\n        }\r\n        if (isOddLevel) {\r\n            isLessThan = p.x < currentNode.getX();\r\n        } else {\r\n            isLessThan = p.y < currentNode.getY();\r\n        }\r\n        leafNode = currentNode;\r\n        if (isLessThan) {\r\n            currentNode = currentNode.getLeft();\r\n        } else {\r\n            currentNode = currentNode.getRight();\r\n        }\r\n        isOddLevel = !isOddLevel;\r\n    }\r\n    numberOfNodes = numberOfNodes + 1;\r\n    KdNode node = new KdNode(p, data);\r\n    if (isLessThan) {\r\n        leafNode.setLeft(node);\r\n    } else {\r\n        leafNode.setRight(node);\r\n    }\r\n    return node;\r\n}"
}, {
	"Path": "com.android.launcher3.ShortcutAndWidgetContainer.setInvertIfRtl",
	"Comment": "set whether or not to invert the layout horizontally if the layout is in rtl mode.",
	"Method": "void setInvertIfRtl(boolean invert){\r\n    mInvertIfRtl = invert;\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.Edge.addIntersection",
	"Comment": "add an edgeintersection for intersection intindex.an intersection that falls exactly on a vertex of the edge is normalizedto use the higher of the two possible segmentindexes",
	"Method": "void addIntersection(LineIntersector li,int segmentIndex,int geomIndex,int intIndex){\r\n    Coordinate intPt = new Coordinate(li.getIntersection(intIndex));\r\n    int normalizedSegmentIndex = segmentIndex;\r\n    double dist = li.getEdgeDistance(geomIndex, intIndex);\r\n    int nextSegIndex = normalizedSegmentIndex + 1;\r\n    if (nextSegIndex < pts.length) {\r\n        Coordinate nextPt = pts[nextSegIndex];\r\n        if (intPt.equals2D(nextPt)) {\r\n            normalizedSegmentIndex = nextSegIndex;\r\n            dist = 0.0;\r\n        }\r\n    }\r\n    EdgeIntersection ei = eiList.add(intPt, normalizedSegmentIndex, dist);\r\n}"
}, {
	"Path": "org.kse.gui.TableColumnAdjuster.restoreColumn",
	"Comment": "restore the width of the specified column to its previous width",
	"Method": "void restoreColumn(int column){\r\n    TableColumn tableColumn = table.getColumnModel().getColumn(column);\r\n    Integer width = columnSizes.get(tableColumn);\r\n    if (width != null) {\r\n        table.getTableHeader().setResizingColumn(tableColumn);\r\n        tableColumn.setWidth(width.intValue());\r\n    }\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.events.user.UserTypingEvent.isFromType",
	"Comment": "whether the user started typing in a channel of the specified type.",
	"Method": "boolean isFromType(ChannelType type){\r\n    return channel.getType() == type;\r\n}"
}, {
	"Path": "com.jsql.view.swing.bruteforce.Hash.byte2hex",
	"Comment": "convert byte character to hexadecimal stringbuffer character.",
	"Method": "void byte2hex(byte b,StringBuilder buf){\r\n    char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\r\n    int high = (b & 0xf0) >> 4;\r\n    int low = b & 0x0f;\r\n    buf.append(hexChars[high]);\r\n    buf.append(hexChars[low]);\r\n}"
}, {
	"Path": "com.android.launcher3.FolderPagedView.completePendingPageChanges",
	"Comment": "finish animation all the views which are animating across pages",
	"Method": "void completePendingPageChanges(){\r\n    if (!mPendingAnimations.isEmpty()) {\r\n        HashMap<View, Runnable> pendingViews = new HashMap(mPendingAnimations);\r\n        for (Map.Entry<View, Runnable> e : pendingViews.entrySet()) {\r\n            e.getKey().animate().cancel();\r\n            e.getValue().run();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.Label.merge",
	"Comment": "merge this label with another one.merging updates any null attributes of this label with the attributes from lbl",
	"Method": "void merge(Label lbl){\r\n    for (int i = 0; i < 2; i++) {\r\n        if (elt[i] == null && lbl.elt[i] != null) {\r\n            elt[i] = new TopologyLocation(lbl.elt[i]);\r\n        } else {\r\n            elt[i].merge(lbl.elt[i]);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.kse.gui.KeyStoreTableHeadRend.getTableCellRendererComponent",
	"Comment": "returns the rendered header cell for the supplied value and column.",
	"Method": "Component getTableCellRendererComponent(JTable jtKeyStore,Object value,boolean isSelected,boolean hasFocus,int row,int col){\r\n    Component c = delegate.getTableCellRendererComponent(jtKeyStore, value, isSelected, hasFocus, row, col);\r\n    if (c instanceof JLabel) {\r\n        JLabel header = (JLabel) c;\r\n        if (col == 0) {\r\n            header.setText(\"\");\r\n            ImageIcon icon = new ImageIcon(getClass().getResource(res.getString(\"KeyStoreTableHeadRend.TypeColumn.image\")));\r\n            header.setIcon(icon);\r\n            header.setHorizontalAlignment(CENTER);\r\n            header.setVerticalAlignment(CENTER);\r\n            header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.TypeColumn.tooltip\"));\r\n        } else if (col == 1) {\r\n            header.setText(\"\");\r\n            ImageIcon icon = new ImageIcon(getClass().getResource(res.getString(\"KeyStoreTableHeadRend.LockStatusColumn.image\")));\r\n            header.setIcon(icon);\r\n            header.setHorizontalAlignment(CENTER);\r\n            header.setVerticalAlignment(CENTER);\r\n            header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.LockStatusColumn.tooltip\"));\r\n        } else if (col == 2) {\r\n            header.setText(\"\");\r\n            ImageIcon icon = new ImageIcon(getClass().getResource(res.getString(\"KeyStoreTableHeadRend.CertExpiryStatusColumn.image\")));\r\n            header.setIcon(icon);\r\n            header.setHorizontalAlignment(CENTER);\r\n            header.setVerticalAlignment(CENTER);\r\n            header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.CertExpiryStatusColumn.tooltip\"));\r\n        } else {\r\n            header.setHorizontalAlignment(LEFT);\r\n            if (col == keyStoreTableColumns.colEntryName()) {\r\n                header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.NameColumn.tooltip\"));\r\n            } else if (col == keyStoreTableColumns.colAlgorithm()) {\r\n                header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.AlgorithmColumn.tooltip\"));\r\n            } else if (col == keyStoreTableColumns.colKeySize()) {\r\n                header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.KeySizeColumn.tooltip\"));\r\n            } else if (col == keyStoreTableColumns.colCertificateExpiry()) {\r\n                header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.CertExpiryColumn.tooltip\"));\r\n            } else if (col == keyStoreTableColumns.colLastModified()) {\r\n                header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.LastModifiedColumn.tooltip\"));\r\n            } else if (col == keyStoreTableColumns.colAKI()) {\r\n                header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.AKIColumn.tooltip\"));\r\n            } else if (col == keyStoreTableColumns.colSKI()) {\r\n                header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.SKIColumn.tooltip\"));\r\n            } else if (col == keyStoreTableColumns.colIssuerDN()) {\r\n                header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.IssuerDNColumn.tooltip\"));\r\n            } else if (col == keyStoreTableColumns.colSubjectDN()) {\r\n                header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.SubjectDNColumn.tooltip\"));\r\n            } else if (col == keyStoreTableColumns.colIssuerCN()) {\r\n                header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.IssuerCNColumn.tooltip\"));\r\n            } else if (col == keyStoreTableColumns.colSubjectCN()) {\r\n                header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.SubjectCNColumn.tooltip\"));\r\n            } else if (col == keyStoreTableColumns.colIssuerO()) {\r\n                header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.IssuerOColumn.tooltip\"));\r\n            } else if (col == keyStoreTableColumns.colSubjectO()) {\r\n                header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.SubjectOColumn.tooltip\"));\r\n            } else if (col == keyStoreTableColumns.colCurve()) {\r\n                header.setToolTipText(res.getString(\"KeyStoreTableHeadRend.CurveColumn.tooltip\"));\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "org.locationtech.jts.linearref.LinearLocation.isEndpoint",
	"Comment": "tests whether this location is an endpoint ofthe linear component it refers to.",
	"Method": "boolean isEndpoint(Geometry linearGeom){\r\n    LineString lineComp = (LineString) linearGeom.getGeometryN(componentIndex);\r\n    int nseg = lineComp.getNumPoints() - 1;\r\n    return segmentIndex >= nseg || (segmentIndex == nseg && segmentFraction >= 1.0);\r\n}"
}, {
	"Path": "org.locationtech.jtstest.geomfunction.GeometryFunctionRegistry.find",
	"Comment": "finds the first function which matches the given name and argument count.",
	"Method": "GeometryFunction find(String name,Class[] paramTypes,GeometryFunction find,String name,int argCount,GeometryFunction find,String name){\r\n    for (Iterator i = functions.iterator(); i.hasNext(); ) {\r\n        GeometryFunction func = (GeometryFunction) i.next();\r\n        String funcName = func.getName();\r\n        if (funcName.equalsIgnoreCase(name))\r\n            return func;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.jdon.controller.model.PageIterator.getNextElement",
	"Comment": "returns the next available element of primary key collection, or null ifthere are no more elements to return.",
	"Method": "Object getNextElement(){\r\n    Object element = null;\r\n    while (currentIndex + 1 < endIndex && element == null) {\r\n        currentIndex++;\r\n        element = getElement();\r\n    }\r\n    return element;\r\n}"
}, {
	"Path": "org.kse.crypto.x509.X509ExtensionSet.addExtension",
	"Comment": "add an extension to the set. any existing extension with the same oid\twill be removed in preference of this one.",
	"Method": "void addExtension(String oid,boolean isCritical,byte[] value){\r\n    removeExtension(oid);\r\n    if (isCritical) {\r\n        criticalExtensions.put(oid, value);\r\n    } else {\r\n        nonCriticalExtensions.put(oid, value);\r\n    }\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.events.self.SelfUpdateNitroEvent.wasNitro",
	"Comment": "whether or not a nitro subscription used to be active before.",
	"Method": "boolean wasNitro(){\r\n    return getOldValue();\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.entities.RichPresence.getLargeImage",
	"Comment": "information on the large image displayed in the profile view",
	"Method": "Image getLargeImage(){\r\n    return largeImage;\r\n}"
}, {
	"Path": "org.zeromq.ZMsg.dump",
	"Comment": "dump the message in human readable format. this should only be used fordebugging and tracing, inefficient in handling large messages.",
	"Method": "void dump(Appendable out){\r\n    try {\r\n        StringWriter sw = new StringWriter();\r\n        PrintWriter pw = new PrintWriter(sw);\r\n        pw.printf(\"--------------------------------------\\n\");\r\n        for (ZFrame frame : frames) {\r\n            pw.printf(\"[d] %s\\n\", frame.getData().length, frame.toString());\r\n        }\r\n        out.append(sw.getBuffer());\r\n        sw.close();\r\n    } catch (IOException e) {\r\n        throw new RuntimeException(\"Message dump exception \" + super.toString(), e);\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.CellLayout.regionToCenterPoint",
	"Comment": "given a cell coordinate and span return the point that represents the center of the regio",
	"Method": "void regionToCenterPoint(int cellX,int cellY,int spanX,int spanY,int[] result){\r\n    final int hStartPadding = getPaddingLeft();\r\n    final int vStartPadding = getPaddingTop();\r\n    result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap) + (spanX * mCellWidth + (spanX - 1) * mWidthGap) / 2;\r\n    result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap) + (spanY * mCellHeight + (spanY - 1) * mHeightGap) / 2;\r\n}"
}, {
	"Path": "com.android.launcher3.CellLayout.regionToRect",
	"Comment": "given a cell coordinate and span fills out a corresponding pixel rect",
	"Method": "void regionToRect(int cellX,int cellY,int spanX,int spanY,Rect result){\r\n    final int hStartPadding = getPaddingLeft();\r\n    final int vStartPadding = getPaddingTop();\r\n    final int left = hStartPadding + cellX * (mCellWidth + mWidthGap);\r\n    final int top = vStartPadding + cellY * (mCellHeight + mHeightGap);\r\n    result.set(left, top, left + (spanX * mCellWidth + (spanX - 1) * mWidthGap), top + (spanY * mCellHeight + (spanY - 1) * mHeightGap));\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.BufferOp.setQuadrantSegments",
	"Comment": "sets the number of segments used to approximate a angle fillet",
	"Method": "void setQuadrantSegments(int quadrantSegments){\r\n    bufParams.setQuadrantSegments(quadrantSegments);\r\n}"
}, {
	"Path": "org.locationtech.jts.io.gml2.StaticMultiPolygonTest.testSingleMultiPolygonManyPointsHolesRoundTrip",
	"Comment": "round trip test for a single multipolygon with lots of points",
	"Method": "void testSingleMultiPolygonManyPointsHolesRoundTrip(){\r\n    PolygonGenerator pgc = new PolygonGenerator();\r\n    pgc.setGeometryFactory(geometryFactory);\r\n    pgc.setGenerationAlgorithm(PolygonGenerator.BOX);\r\n    pgc.setNumberPoints(1000);\r\n    pgc.setNumberHoles(4);\r\n    MultiGenerator pg = new MultiGenerator(pgc);\r\n    pg.setBoundingBox(new Envelope(0, 10, 0, 10));\r\n    pg.setNumberGeometries(3);\r\n    pg.setGeometryFactory(geometryFactory);\r\n    MultiPolygon pt = (MultiPolygon) pg.create();\r\n    checkRoundTrip(pt);\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testbuilder.ui.tools.BoxBandTool.getCoordinates",
	"Comment": "gets the coordinates for the rectanglestarting at the first point clicked.the coordinates are oriented cw.",
	"Method": "List getCoordinates(){\r\n    Coordinate start = toModelSnapped(zoomBoxStart);\r\n    Coordinate end = toModelSnapped(zoomBoxEnd);\r\n    boolean isCW = (start.x < end.x && start.y < end.y) || (start.x > end.x && start.y > end.y);\r\n    Coordinate mid1 = new Coordinate(start.x, end.y);\r\n    Coordinate mid2 = new Coordinate(end.x, start.y);\r\n    List coords = new ArrayList();\r\n    coords.add(new Coordinate(start));\r\n    if (isCW)\r\n        coords.add(mid1);\r\n    else\r\n        coords.add(mid2);\r\n    coords.add(new Coordinate(end));\r\n    if (isCW)\r\n        coords.add(mid2);\r\n    else\r\n        coords.add(mid1);\r\n    coords.add(new Coordinate(start));\r\n    return coords;\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DD.selfDivide",
	"Comment": "divides this object by the argument, returning this.to prevent altering constants, this method must only be used on values known to be newly created.",
	"Method": "DD selfDivide(DD y,DD selfDivide,double y,DD selfDivide,double yhi,double ylo){\r\n    double hc, tc, hy, ty, C, c, U, u;\r\n    C = hi / yhi;\r\n    c = SPLIT * C;\r\n    hc = c - C;\r\n    u = SPLIT * yhi;\r\n    hc = c - hc;\r\n    tc = C - hc;\r\n    hy = u - yhi;\r\n    U = C * yhi;\r\n    hy = u - hy;\r\n    ty = yhi - hy;\r\n    u = (((hc * hy - U) + hc * ty) + tc * hy) + tc * ty;\r\n    c = ((((hi - U) - u) + lo) - C * ylo) / yhi;\r\n    u = C + c;\r\n    hi = u;\r\n    lo = (C - u) + c;\r\n    return this;\r\n}"
}, {
	"Path": "com.android.launcher3.Hotseat.hasIcons",
	"Comment": "returns whether there are other icons than the all apps button in the hotseat.",
	"Method": "boolean hasIcons(){\r\n    return mContent.getShortcutsAndWidgets().getChildCount() > 1;\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.utils.KubernetesResourceUtil.getOrCreateMetadata",
	"Comment": "null safe operation for getting metadata of a kubernetes resource",
	"Method": "ObjectMeta getOrCreateMetadata(HasMetadata entity){\r\n    ObjectMeta metadata = entity.getMetadata();\r\n    if (metadata == null) {\r\n        metadata = new ObjectMeta();\r\n        entity.setMetadata(metadata);\r\n    }\r\n    return metadata;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.RobustLineIntersector.normalizeToEnvCentre",
	"Comment": "normalize the supplied coordinates toso that the midpoint of their intersection envelopelies at the origin.",
	"Method": "void normalizeToEnvCentre(Coordinate n00,Coordinate n01,Coordinate n10,Coordinate n11,Coordinate normPt){\r\n    double minX0 = n00.x < n01.x ? n00.x : n01.x;\r\n    double minY0 = n00.y < n01.y ? n00.y : n01.y;\r\n    double maxX0 = n00.x > n01.x ? n00.x : n01.x;\r\n    double maxY0 = n00.y > n01.y ? n00.y : n01.y;\r\n    double minX1 = n10.x < n11.x ? n10.x : n11.x;\r\n    double minY1 = n10.y < n11.y ? n10.y : n11.y;\r\n    double maxX1 = n10.x > n11.x ? n10.x : n11.x;\r\n    double maxY1 = n10.y > n11.y ? n10.y : n11.y;\r\n    double intMinX = minX0 > minX1 ? minX0 : minX1;\r\n    double intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;\r\n    double intMinY = minY0 > minY1 ? minY0 : minY1;\r\n    double intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;\r\n    double intMidX = (intMinX + intMaxX) / 2.0;\r\n    double intMidY = (intMinY + intMaxY) / 2.0;\r\n    normPt.x = intMidX;\r\n    normPt.y = intMidY;\r\n    n00.x -= normPt.x;\r\n    n00.y -= normPt.y;\r\n    n01.x -= normPt.x;\r\n    n01.y -= normPt.y;\r\n    n10.x -= normPt.x;\r\n    n10.y -= normPt.y;\r\n    n11.x -= normPt.x;\r\n    n11.y -= normPt.y;\r\n}"
}, {
	"Path": "com.jdon.util.task.TaskEngine.scheduleTask",
	"Comment": "schedules a task to periodically run. this is useful for tasks such as\tupdating search indexes, deleting old data at periodic intervals, etc.",
	"Method": "TimerTask scheduleTask(Runnable task,long delay,long period,TimerTask scheduleTask,Runnable task,int priority,long delay,long period){\r\n    TimerTask timerTask = new ScheduledTask(task, priority);\r\n    taskTimer.scheduleAtFixedRate(timerTask, delay, period);\r\n    return timerTask;\r\n}"
}, {
	"Path": "org.joda.money.Money.plus",
	"Comment": "returns a copy of this monetary value with the amount added.this adds the specified amount to this monetary amount, returning a new object.if the amount to add exceeds the scale of the currency, then therounding mode will be used to adjust the result.this instance is immutable and unaffected by this method.",
	"Method": "Money plus(Iterable<Money> moniesToAdd,Money plus,Money moneyToAdd,Money plus,BigDecimal amountToAdd,Money plus,BigDecimal amountToAdd,RoundingMode roundingMode,Money plus,double amountToAdd,Money plus,double amountToAdd,RoundingMode roundingMode){\r\n    return with(money.plusRetainScale(amountToAdd, roundingMode));\r\n}"
}, {
	"Path": "org.joda.money.format.MoneyAmountStyle.withForcedDecimalPoint",
	"Comment": "returns a copy of this style with the specified decimal point setting.",
	"Method": "MoneyAmountStyle withForcedDecimalPoint(boolean forceDecimalPoint){\r\n    if (this.forceDecimalPoint == forceDecimalPoint) {\r\n        return this;\r\n    }\r\n    return new MoneyAmountStyle(zeroCharacter, positiveCharacter, negativeCharacter, decimalPointCharacter, groupingStyle, groupingCharacter, groupingSize, extendedGroupingSize, forceDecimalPoint, absValue);\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifInterface.getThumbnailBytes",
	"Comment": "returns the thumbnail from ifd1 as a byte array, or null if none exists.the bytes may either be an uncompressed strip as specified in the exifstandard or a jpeg compressed image.",
	"Method": "byte[] getThumbnailBytes(){\r\n    if (mData.hasCompressedThumbnail()) {\r\n        return mData.getCompressedThumbnail();\r\n    } else if (mData.hasUncompressedStrip()) {\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DD.pow",
	"Comment": "computes the value of this number raised to an integral power.follows semantics of java math.pow as closely as possible.",
	"Method": "DD pow(int exp){\r\n    if (exp == 0.0)\r\n        return valueOf(1.0);\r\n    DD r = new DD(this);\r\n    DD s = valueOf(1.0);\r\n    int n = Math.abs(exp);\r\n    if (n > 1) {\r\n        while (n > 0) {\r\n            if (n % 2 == 1) {\r\n                s.selfMultiply(r);\r\n            }\r\n            n /= 2;\r\n            if (n > 0)\r\n                r = r.sqr();\r\n        }\r\n    } else {\r\n        s = r;\r\n    }\r\n    if (exp < 0)\r\n        return s.reciprocal();\r\n    return s;\r\n}"
}, {
	"Path": "org.locationtech.jtslab.snapround.GeometryCoordinateReplacer.edit",
	"Comment": "gets the snapped coordinate array for an atomic geometry,or null if it has collapsed.",
	"Method": "CoordinateSequence edit(CoordinateSequence coordSeq,Geometry geometry,GeometryFactory targetFactory){\r\n    if (geometryLinesMap.containsKey(geometry)) {\r\n        Coordinate[] pts = (Coordinate[]) geometryLinesMap.get(geometry);\r\n        boolean isValidPts = isValidSize(pts, geometry);\r\n        if (!isValidPts)\r\n            return null;\r\n        return targetFactory.getCoordinateSequenceFactory().create(pts);\r\n    }\r\n    return coordSeq;\r\n}"
}, {
	"Path": "org.kse.AuthorityCertificates.getCaCertificates",
	"Comment": "get ca certificates keystore. if not set this is not loaded. instead load\tseperately and set it for future reference.",
	"Method": "KeyStore getCaCertificates(){\r\n    return caCertificates;\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.DocumentReader.reset",
	"Comment": "reset this reader to the last mark, or the beginning of the document if a mark has not been set.",
	"Method": "void reset(){\r\n    if (this.mark == -1) {\r\n        this.position = 0;\r\n    } else {\r\n        this.position = this.mark;\r\n    }\r\n    this.mark = -1;\r\n}"
}, {
	"Path": "com.jdon.cache.UtilCache.setMaxSize",
	"Comment": "sets the maximum number of elements in the cache. if 0, there is no\tmaximum.",
	"Method": "void setMaxSize(long maxSize){\r\n    if (maxSize <= 0) {\r\n        keyLRUList.clear();\r\n    } else if (maxSize > 0 && this.maxSize <= 0) {\r\n        Iterator keys = cacheLineTable.keySet().iterator();\r\n        while (keys.hasNext()) {\r\n            keyLRUList.add(keys.next());\r\n        }\r\n    }\r\n    if (maxSize > 0 && cacheLineTable.size() > maxSize) {\r\n        while (cacheLineTable.size() > maxSize) {\r\n            Object lastKey = keyLRUList.getLast();\r\n            removeObject(lastKey);\r\n        }\r\n    }\r\n    this.maxSize = maxSize;\r\n}"
}, {
	"Path": "com.jdon.cache.UtilCache.getMaxSize",
	"Comment": "returns the current maximum number of elements in the cache",
	"Method": "long getMaxSize(){\r\n    return maxSize;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.CoordinateSequence.getZ",
	"Comment": "returns ordinate z of the specified coordinate if available.",
	"Method": "double getZ(int index){\r\n    if (hasZ()) {\r\n        return getOrdinate(index, 2);\r\n    } else {\r\n        return Double.NaN;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.util.AffineTransformation.equals",
	"Comment": "tests if an object is an affinetransformation and has the same matrix asthis transformation.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == null)\r\n        return false;\r\n    if (!(obj instanceof AffineTransformation))\r\n        return false;\r\n    AffineTransformation trans = (AffineTransformation) obj;\r\n    return m00 == trans.m00 && m01 == trans.m01 && m02 == trans.m02 && m10 == trans.m10 && m11 == trans.m11 && m12 == trans.m12;\r\n}"
}, {
	"Path": "org.locationtech.jts.linearref.LocationIndexedLine.clampIndex",
	"Comment": "computes a valid index for this lineby clamping the given index to the valid range of index values",
	"Method": "LinearLocation clampIndex(LinearLocation index){\r\n    LinearLocation loc = index.copy();\r\n    loc.clamp(linearGeom);\r\n    return loc;\r\n}"
}, {
	"Path": "org.locationtech.jts.index.quadtree.DoubleBits.toString",
	"Comment": "a representation of the double bits formatted for easy readability",
	"Method": "String toString(){\r\n    String numStr = Long.toBinaryString(xBits);\r\n    String zero64 = \"0000000000000000000000000000000000000000000000000000000000000000\";\r\n    String padStr = zero64 + numStr;\r\n    String bitStr = padStr.substring(padStr.length() - 64);\r\n    String str = bitStr.substring(0, 1) + \"  \" + bitStr.substring(1, 12) + \"(\" + getExponent() + \") \" + bitStr.substring(12) + \" [ \" + x + \" ]\";\r\n    return str;\r\n}"
}, {
	"Path": "org.kse.gui.TableColumnAdjuster.setColumnDataIncluded",
	"Comment": "indicates whether to include the model data in the width calculation",
	"Method": "void setColumnDataIncluded(boolean isColumnDataIncluded){\r\n    this.isColumnDataIncluded = isColumnDataIncluded;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.Segment.equalsTopo",
	"Comment": "determines whether two segments are topologically equal.i.e. equal up to orientation.",
	"Method": "boolean equalsTopo(Segment s){\r\n    return ls.equalsTopo(s.getLineSegment());\r\n}"
}, {
	"Path": "com.jsql.util.HeaderUtil.checkResponseHeader",
	"Comment": "verify the headers received after a request, detect authentication response andsend the headers to the view.",
	"Method": "void checkResponseHeader(HttpURLConnection connection,String urlByUser){\r\n    Map<Header, Object> msgHeader = new EnumMap(Header.class);\r\n    msgHeader.put(Header.URL, urlByUser);\r\n    msgHeader.put(Header.RESPONSE, HeaderUtil.getHttpHeaders(connection));\r\n    Map<String, String> mapResponse = (Map<String, String>) msgHeader.get(Header.RESPONSE);\r\n    if (Pattern.matches(\"4\\\\d\\\\d\", Integer.toString(connection.getResponseCode())) && mapResponse.containsKey(\"WWW-Authenticate\") && mapResponse.get(\"WWW-Authenticate\") != null && mapResponse.get(\"WWW-Authenticate\").startsWith(\"Basic \")) {\r\n        LOGGER.warn(\"Basic Authentication detected.\\n\" + \"Please define and enable authentication information in the panel Preferences.\\n\" + \"Or open Advanced panel, add 'Authorization: Basic b3N..3Jk' to the Header, replace b3N..3Jk with the string 'osUserName:osPassword' encoded in Base64. You can use the Coder in jSQL to encode the string.\");\r\n    } else if (Pattern.matches(\"4\\\\d\\\\d\", Integer.toString(connection.getResponseCode())) && mapResponse.containsKey(\"WWW-Authenticate\") && \"NTLM\".equals(mapResponse.get(\"WWW-Authenticate\"))) {\r\n        LOGGER.warn(\"NTLM Authentication detected.\\n\" + \"Please define and enable authentication information in the panel Preferences.\\n\" + \"Or add username, password and domain information to the URL, e.g. http://domain\\\%user:password@127.0.0.1/[..]\");\r\n    } else if (Pattern.matches(\"4\\\\d\\\\d\", Integer.toString(connection.getResponseCode())) && mapResponse.containsKey(\"WWW-Authenticate\") && mapResponse.get(\"WWW-Authenticate\") != null && mapResponse.get(\"WWW-Authenticate\").startsWith(\"Digest \")) {\r\n        LOGGER.warn(\"Digest Authentication detected.\\n\" + \"Please define and enable authentication information in the panel Preferences.\");\r\n    } else if (Pattern.matches(\"4\\\\d\\\\d\", Integer.toString(connection.getResponseCode())) && mapResponse.containsKey(\"WWW-Authenticate\") && \"Negotiate\".equals(mapResponse.get(\"WWW-Authenticate\"))) {\r\n        LOGGER.warn(\"Negotiate Authentication detected.\\n\" + \"Please add username, password and domain information to the URL, e.g. http://domain\\\%user:password@127.0.0.1/[..]\");\r\n    } else if (Pattern.matches(\"1\\\\d\\\\d\", Integer.toString(connection.getResponseCode()))) {\r\n        LOGGER.trace(\"Found status HTTP \" + connection.getResponseCode() + \" Informational\");\r\n    } else if (Pattern.matches(\"2\\\\d\\\\d\", Integer.toString(connection.getResponseCode()))) {\r\n        LOGGER.debug(\"Found status HTTP \" + connection.getResponseCode() + \" Success\");\r\n    } else if (Pattern.matches(\"3\\\\d\\\\d\", Integer.toString(connection.getResponseCode()))) {\r\n        LOGGER.warn(\"Found status HTTP \" + connection.getResponseCode() + \" Redirection\");\r\n        if (!PreferencesUtil.isFollowingRedirection()) {\r\n            LOGGER.warn(\"If injection fails please test again with option 'Follow HTTP redirection' enabled.\");\r\n        } else {\r\n            LOGGER.info(\"Redirecting to the next page...\");\r\n        }\r\n    } else if (Pattern.matches(\"4\\\\d\\\\d\", Integer.toString(connection.getResponseCode()))) {\r\n        LOGGER.warn(\"Found status HTTP \" + connection.getResponseCode() + \" Client Error\");\r\n    } else if (Pattern.matches(\"5\\\\d\\\\d\", Integer.toString(connection.getResponseCode()))) {\r\n        LOGGER.warn(\"Found status HTTP \" + connection.getResponseCode() + \" Server Error\");\r\n    } else {\r\n        LOGGER.trace(\"Found status HTTP \" + connection.getResponseCode() + \" Unknown\");\r\n    }\r\n    Exception exception = null;\r\n    StringBuilder pageSource = new StringBuilder();\r\n    try (BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {\r\n        char[] buffer = new char[4096];\r\n        while (reader.read(buffer) > 0) {\r\n            pageSource.append(buffer);\r\n        }\r\n        reader.close();\r\n    } catch (IOException errorInputStream) {\r\n        exception = errorInputStream;\r\n        InputStream errorStream = connection.getErrorStream();\r\n        if (errorStream != null) {\r\n            try (BufferedReader reader = new BufferedReader(new InputStreamReader(errorStream))) {\r\n                char[] buffer = new char[4096];\r\n                while (reader.read(buffer) > 0) {\r\n                    pageSource.append(buffer);\r\n                }\r\n                reader.close();\r\n            } catch (Exception errorErrorStream) {\r\n                exception = new IOException(\"Exception reading Error Stream\", errorErrorStream);\r\n            }\r\n        }\r\n    }\r\n    if (PreferencesUtil.isNotTestingConnection()) {\r\n        if (exception != null) {\r\n            LOGGER.debug(\"Connection test disabled, ignoring response HTTP \" + connection.getResponseCode() + \"...\");\r\n        }\r\n        exception = null;\r\n    } else if (exception != null) {\r\n        LOGGER.info(\"Please select option 'Disable connection test' and run again\");\r\n    }\r\n    Elements elementsForm = Jsoup.parse(pageSource.toString()).select(\"form\");\r\n    StringBuilder result = new StringBuilder();\r\n    Map<Element, List<Element>> mapForms = new HashMap();\r\n    for (Element form : elementsForm) {\r\n        mapForms.put(form, new ArrayList());\r\n        result.append(\"\\n<form action=\\\"\");\r\n        result.append(form.attr(\"action\"));\r\n        result.append(\"\\\" method=\\\"\");\r\n        result.append(form.attr(\"method\"));\r\n        result.append(\"\\\" />\");\r\n        for (Element input : form.select(\"input\")) {\r\n            result.append(\"\\n    <input name=\\\"\");\r\n            result.append(input.attr(\"name\"));\r\n            result.append(\"\\\" value=\\\"\");\r\n            result.append(input.attr(\"value\"));\r\n            result.append(\"\\\" />\");\r\n            mapForms.get(form).add(input);\r\n        }\r\n        Collections.reverse(mapForms.get(form));\r\n    }\r\n    if (!elementsForm.isEmpty()) {\r\n        if (!PreferencesUtil.isParsingForm()) {\r\n            if (connection.getResponseCode() != 200) {\r\n                LOGGER.trace(\"Found \" + elementsForm.size() + \" ignored <form> in HTML body:\" + result);\r\n                LOGGER.info(\"WAF can detect missing form parameters, you may enable 'Add <input> parameters' in Preferences and retry\");\r\n            } else {\r\n                LOGGER.trace(\"Found \" + elementsForm.size() + \" <form> in HTML body while status 200 Success:\" + result);\r\n            }\r\n        } else {\r\n            LOGGER.debug(\"Found \" + elementsForm.size() + \" <form> in HTML body, adding input(s) to requests:\" + result);\r\n            for (Entry<Element, List<Element>> form : mapForms.entrySet()) {\r\n                for (Element input : form.getValue()) {\r\n                    if (\"get\".equalsIgnoreCase(form.getKey().attr(\"method\"))) {\r\n                        ParameterUtil.getQueryString().add(0, new SimpleEntry<String, String>(input.attr(\"name\"), input.attr(\"value\")));\r\n                    } else if (\"post\".equalsIgnoreCase(form.getKey().attr(\"method\"))) {\r\n                        ParameterUtil.getRequest().add(0, new SimpleEntry<String, String>(input.attr(\"name\"), input.attr(\"value\")));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Optional<SimpleEntry<String, String>> optionalTokenCsrf = Jsoup.parse(pageSource.toString()).select(\"input\").select(\"[name=csrf_token], [name=csrfToken]\").stream().findFirst().map(input -> new SimpleEntry<String, String>(input.attr(\"name\"), input.attr(\"value\")));\r\n    if (optionalTokenCsrf.isPresent()) {\r\n        SimpleEntry<String, String> tokenCsrfFound = optionalTokenCsrf.get();\r\n        if (PreferencesUtil.isProcessingCsrf()) {\r\n            LOGGER.debug(\"Found Csrf token \" + tokenCsrfFound.getKey() + \"=\" + tokenCsrfFound.getValue() + \" in HTML body, adding token to querystring, request and header\");\r\n            ConnectionUtil.setTokenCsrf(tokenCsrfFound);\r\n        } else {\r\n            LOGGER.warn(\"Found Csrf token '\" + tokenCsrfFound.getKey() + \"=\" + tokenCsrfFound.getValue() + \"' in HTML body\");\r\n            exception = new IOException(\"please activate Csrf processing in Preferences\");\r\n        }\r\n    }\r\n    msgHeader.put(Header.SOURCE, pageSource.toString());\r\n    Request request = new Request();\r\n    request.setMessage(Interaction.MESSAGE_HEADER);\r\n    request.setParameters(msgHeader);\r\n    MediatorModel.model().sendToViews(request);\r\n    if (exception != null) {\r\n        throw new IOException(exception);\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.updateOverlayBounds",
	"Comment": "updates the bounds of all the overlays to match the new fixed bounds.",
	"Method": "void updateOverlayBounds(Rect newBounds){\r\n    mAppsView.setSearchBarBounds(newBounds);\r\n    mWidgetsView.setSearchBarBounds(newBounds);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.overlay.PolygonBuilder.sortShellsAndHoles",
	"Comment": "for all rings in the input list,determine whether the ring is a shell or a holeand add it to the appropriate list.due to the way the directededges were linked,a ring is a shell if it is oriented cw, a hole otherwise.",
	"Method": "void sortShellsAndHoles(List edgeRings,List shellList,List freeHoleList){\r\n    for (Iterator it = edgeRings.iterator(); it.hasNext(); ) {\r\n        EdgeRing er = (EdgeRing) it.next();\r\n        if (er.isHole()) {\r\n            freeHoleList.add(er);\r\n        } else {\r\n            shellList.add(er);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.planargraph.DirectedEdgeStar.getCoordinate",
	"Comment": "returns the coordinate for the node at which this star is based",
	"Method": "Coordinate getCoordinate(){\r\n    Iterator it = iterator();\r\n    if (!it.hasNext())\r\n        return null;\r\n    DirectedEdge e = (DirectedEdge) it.next();\r\n    return e.getCoordinate();\r\n}"
}, {
	"Path": "com.android.launcher3.Workspace.isFinishedSwitchingState",
	"Comment": "this differs from isswitchingstate in that we take into account how far the transition has completed.",
	"Method": "boolean isFinishedSwitchingState(){\r\n    return !mIsSwitchingState || (mTransitionProgress > 0.5f);\r\n}"
}, {
	"Path": "com.jdon.util.jdom.DataFormatFilter.startElement",
	"Comment": "add newline and indentation prior to start tag.each tag will begin on a new line, and will beindented by the current indent step times the numberof ancestors that the element has.the newline and indentation will be passed on downthe filter chain through regular characters events.",
	"Method": "void startElement(String uri,String localName,String qName,Attributes atts){\r\n    if (!stateStack.empty()) {\r\n        doNewline();\r\n        doIndent();\r\n    }\r\n    stateStack.push(SEEN_ELEMENT);\r\n    state = SEEN_NOTHING;\r\n    super.startElement(uri, localName, qName, atts);\r\n}"
}, {
	"Path": "com.android.launcher3.Folder.onTouchEvent",
	"Comment": "we need to handle touch events to prevent them from falling through to the workspace below.",
	"Method": "boolean onTouchEvent(MotionEvent ev){\r\n    return true;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.hlist.Tuple6.fill",
	"Comment": "given a value of type a, produced an instance of this tuple with each slot set to that value.",
	"Method": "Tuple6<A, A, A, A, A, A> fill(A a){\r\n    return tuple(a, a, a, a, a, a);\r\n}"
}, {
	"Path": "org.kse.crypto.publickey.OpenSslPubUtil.load",
	"Comment": "load an unencrypted openssl public key from the stream. the encoding of\tthe public key may be pem or der.",
	"Method": "PublicKey load(byte[] pkData){\r\n    PemInfo pemInfo = PemUtil.decode(pkData);\r\n    if (pemInfo != null) {\r\n        pkData = pemInfo.getContent();\r\n    }\r\n    try {\r\n        SubjectPublicKeyInfo publicKeyInfo = SubjectPublicKeyInfo.getInstance(pkData);\r\n        return new JcaPEMKeyConverter().getPublicKey(publicKeyInfo);\r\n    } catch (Exception ex) {\r\n        throw new CryptoException(res.getString(\"NoLoadOpenSslPublicKey.exception.message\"), ex);\r\n    }\r\n}"
}, {
	"Path": "com.jdon.controller.service.WebServiceFactory.getService",
	"Comment": "get a service instance the service must have a interface and implements",
	"Method": "Object getService(String name,RequestWrapper request,Object getService,TargetMetaDef targetMetaDef,RequestWrapper request,Object getService,TargetMetaDef targetMetaDef,AppContextWrapper acw,Object getService,String name,AppContextWrapper acw){\r\n    ContainerWrapper cw = containerCallback.getContainerWrapper();\r\n    if (!cw.isStart()) {\r\n        Debug.logError(\"JdonFramework not yet started, please try later \", module);\r\n        return null;\r\n    }\r\n    TargetMetaDef targetMetaDef = userTargetMetaDefFactory.getTargetMetaDef(name, cw);\r\n    if (targetMetaDef == null)\r\n        return null;\r\n    Debug.logVerbose(\"[JdonFramework] service=\" + name + \"  found, and now return the service instance\", module);\r\n    Object result = getService(targetMetaDef, acw);\r\n    return result;\r\n}"
}, {
	"Path": "com.jdon.aop.reflection.MethodInvokerUtil.createTargetObject",
	"Comment": "if target service is ejb object, cache it, so this function can active\tstateful session bean.",
	"Method": "Object createTargetObject(TargetServiceFactory targetServiceFactory){\r\n    Debug.logVerbose(\"[JdonFramework] now getTargetObject by visitor \", module);\r\n    Object targetObjRef = null;\r\n    try {\r\n        TargetMetaRequest targetMetaRequest = targetMetaRequestsHolder.getTargetMetaRequest();\r\n        TargetMetaDef targetMetaDef = targetMetaRequest.getTargetMetaDef();\r\n        if (targetMetaDef.isEJB()) {\r\n            ComponentVisitor cm = targetMetaRequest.getComponentVisitor();\r\n            targetMetaRequest.setVisitableName(ComponentKeys.TARGETSERVICE_FACTORY);\r\n            Debug.logVerbose(ComponentKeys.TARGETSERVICE_FACTORY + \" in action (cache)\", module);\r\n            targetObjRef = cm.visit();\r\n        } else {\r\n            Debug.logVerbose(\"[JdonFramework] not active targer service instance cache !!!!\", module);\r\n            targetObjRef = targetServiceFactory.create();\r\n        }\r\n    } catch (Exception e) {\r\n        Debug.logError(\"[JdonFramework]createTargetObject error: \" + e, module);\r\n    }\r\n    return targetObjRef;\r\n}"
}, {
	"Path": "org.kse.gui.LnfUtil.matchLnf",
	"Comment": "do the supplied l&f object and l&f info object refer to the same l&f?",
	"Method": "boolean matchLnf(LookAndFeel lookAndFeel,UIManager.LookAndFeelInfo lookAndFeelInfo){\r\n    return lookAndFeel.getClass().getName().equals(lookAndFeelInfo.getClassName());\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.startWorkspaceStateChangeAnimation",
	"Comment": "updates the workspace and interaction state on state change, and return the animation to thisnew state.",
	"Method": "Animator startWorkspaceStateChangeAnimation(Workspace.State toState,int toPage,boolean animated,HashMap<View, Integer> layerViews){\r\n    Workspace.State fromState = mWorkspace.getState();\r\n    Animator anim = mWorkspace.setStateWithAnimation(toState, toPage, animated, layerViews);\r\n    updateInteraction(fromState, toState);\r\n    return anim;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.utils.PermissionUtil.isApplied",
	"Comment": "check whether the specified permission is applied in the bits",
	"Method": "boolean isApplied(long permissions,long perms){\r\n    return (permissions & perms) == perms;\r\n}"
}, {
	"Path": "org.locationtech.jtstest.util.StringUtil.replaceAll",
	"Comment": "returns original with all occurrences of oldsubstring replaced by newsubstring",
	"Method": "String replaceAll(String original,String oldSubstring,String newSubstring){\r\n    return replace(original, oldSubstring, newSubstring, true);\r\n}"
}, {
	"Path": "com.android.launcher3.util.FocusLogic.shouldConsume",
	"Comment": "returns true only if this utility class handles the key code.",
	"Method": "boolean shouldConsume(int keyCode){\r\n    return (keyCode == KeyEvent.KEYCODE_DPAD_LEFT || keyCode == KeyEvent.KEYCODE_DPAD_RIGHT || keyCode == KeyEvent.KEYCODE_DPAD_UP || keyCode == KeyEvent.KEYCODE_DPAD_DOWN || keyCode == KeyEvent.KEYCODE_MOVE_HOME || keyCode == KeyEvent.KEYCODE_MOVE_END || keyCode == KeyEvent.KEYCODE_PAGE_UP || keyCode == KeyEvent.KEYCODE_PAGE_DOWN || keyCode == KeyEvent.KEYCODE_DEL || keyCode == KeyEvent.KEYCODE_FORWARD_DEL);\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.ConformingDelaunayTriangulator.enforceConstraints",
	"Comment": "enforces the supplied constraints into the triangulation.",
	"Method": "void enforceConstraints(){\r\n    addConstraintVertices();\r\n    int count = 0;\r\n    int splits = 0;\r\n    do {\r\n        splits = enforceGabriel(segments);\r\n        count++;\r\n        Debug.println(\"Iter: \" + count + \"   Splits: \" + splits + \"   Current # segments = \" + segments.size());\r\n    } while (splits > 0 && count < MAX_SPLIT_ITER);\r\n    if (count == MAX_SPLIT_ITER) {\r\n        Debug.println(\"ABORTED! Too many iterations while enforcing constraints\");\r\n        if (!Debug.isDebugging())\r\n            throw new ConstraintEnforcementException(\"Too many splitting iterations while enforcing constraints.  Last split point was at: \", splitPt);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.Geometry.isWithinDistance",
	"Comment": "tests whether the distance from this geometryto another is less than or equal to a specified value.",
	"Method": "boolean isWithinDistance(Geometry geom,double distance){\r\n    double envDist = getEnvelopeInternal().distance(geom.getEnvelopeInternal());\r\n    if (envDist > distance)\r\n        return false;\r\n    return DistanceOp.isWithinDistance(this, geom, distance);\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision.locate",
	"Comment": "locates the edge between the given vertices, if it exists in the\tsubdivision.",
	"Method": "QuadEdge locate(Vertex v,QuadEdge locate,Coordinate p,QuadEdge locate,Coordinate p0,Coordinate p1){\r\n    QuadEdge e = locator.locate(new Vertex(p0));\r\n    if (e == null)\r\n        return null;\r\n    QuadEdge base = e;\r\n    if (e.dest().getCoordinate().equals2D(p0))\r\n        base = e.sym();\r\n    QuadEdge locEdge = base;\r\n    do {\r\n        if (locEdge.dest().getCoordinate().equals2D(p1))\r\n            return locEdge;\r\n        locEdge = locEdge.oNext();\r\n    } while (locEdge != base);\r\n    return null;\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifInterface.convertLatOrLongToDouble",
	"Comment": "gets the double representation of the gps latitude or longitudecoordinate.",
	"Method": "double convertLatOrLongToDouble(Rational[] coordinate,String reference){\r\n    try {\r\n        double degrees = coordinate[0].toDouble();\r\n        double minutes = coordinate[1].toDouble();\r\n        double seconds = coordinate[2].toDouble();\r\n        double result = degrees + minutes / 60.0 + seconds / 3600.0;\r\n        if ((reference.equals(\"S\") || reference.equals(\"W\"))) {\r\n            return -result;\r\n        }\r\n        return result;\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdgeTriangle.nextIndex",
	"Comment": "finds the next index around the triangle. index may be an edge or vertex\tindex.",
	"Method": "int nextIndex(int index){\r\n    return index = (index + 1) % 3;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdgeUtil.findEdgesIncidentOnOrigin",
	"Comment": "gets all edges which are incident on the origin of the given edge.",
	"Method": "List findEdgesIncidentOnOrigin(QuadEdge start){\r\n    List incEdge = new ArrayList();\r\n    QuadEdge qe = start;\r\n    do {\r\n        incEdge.add(qe);\r\n        qe = qe.oNext();\r\n    } while (qe != start);\r\n    return incEdge;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.prep.PreparedPolygonCovers.covers",
	"Comment": "tests whether this preparedpolygon covers a given geometry.",
	"Method": "boolean covers(PreparedPolygon prep,Geometry geom,boolean covers,Geometry geom){\r\n    return eval(geom);\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.functions.Fn6.apply",
	"Comment": "partially apply this function by taking its first five arguments.",
	"Method": "G apply(A a,B b,C c,D d,E e,F f,Fn5<B, C, D, E, F, G> apply,A a,Fn4<C, D, E, F, G> apply,A a,B b,Fn3<D, E, F, G> apply,A a,B b,C c,Fn2<E, F, G> apply,A a,B b,C c,D d,Fn1<F, G> apply,A a,B b,C c,D d,E e){\r\n    return (f) -> apply(a, b, c, d, e, f);\r\n}"
}, {
	"Path": "org.locationtech.jts.linearref.LinearLocation.normalize",
	"Comment": "ensures the individual values are locally valid.does not ensure that the indexes are valid fora particular linear geometry.",
	"Method": "void normalize(){\r\n    if (segmentFraction < 0.0) {\r\n        segmentFraction = 0.0;\r\n    }\r\n    if (segmentFraction > 1.0) {\r\n        segmentFraction = 1.0;\r\n    }\r\n    if (componentIndex < 0) {\r\n        componentIndex = 0;\r\n        segmentIndex = 0;\r\n        segmentFraction = 0.0;\r\n    }\r\n    if (segmentIndex < 0) {\r\n        segmentIndex = 0;\r\n        segmentFraction = 0.0;\r\n    }\r\n    if (segmentFraction == 1.0) {\r\n        segmentFraction = 0.0;\r\n        segmentIndex += 1;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.io.oracle.OraWriter.setDimension",
	"Comment": "sets the coordinate dimension for the created oracle geometries.",
	"Method": "void setDimension(int outputDimension){\r\n    if (outputDimension < 2)\r\n        throw new IllegalArgumentException(\"Output dimension must be >= 2\");\r\n    this.outputDimension = outputDimension;\r\n}"
}, {
	"Path": "org.locationtech.jts.index.quadtree.Root.insertContained",
	"Comment": "insert an item which is known to be contained in the tree rooted atthe given quadnode root.lower levels of the tree will be createdif necessary to hold the item.",
	"Method": "void insertContained(Node tree,Envelope itemEnv,Object item){\r\n    Assert.isTrue(tree.getEnvelope().contains(itemEnv));\r\n    boolean isZeroX = IntervalSize.isZeroWidth(itemEnv.getMinX(), itemEnv.getMaxX());\r\n    boolean isZeroY = IntervalSize.isZeroWidth(itemEnv.getMinY(), itemEnv.getMaxY());\r\n    NodeBase node;\r\n    if (isZeroX || isZeroY)\r\n        node = tree.find(itemEnv);\r\n    else\r\n        node = tree.getNode(itemEnv);\r\n    node.add(item);\r\n}"
}, {
	"Path": "com.android.launcher3.CellLayout.beginOrAdjustReorderPreviewAnimations",
	"Comment": "this method starts or changes the reorder preview animations",
	"Method": "void beginOrAdjustReorderPreviewAnimations(ItemConfiguration solution,View dragView,int delay,int mode){\r\n    int childCount = mShortcutsAndWidgets.getChildCount();\r\n    for (int i = 0; i < childCount; i++) {\r\n        View child = mShortcutsAndWidgets.getChildAt(i);\r\n        if (child == dragView)\r\n            continue;\r\n        CellAndSpan c = solution.map.get(child);\r\n        boolean skip = mode == ReorderPreviewAnimation.MODE_HINT && solution.intersectingViews != null && !solution.intersectingViews.contains(child);\r\n        LayoutParams lp = (LayoutParams) child.getLayoutParams();\r\n        if (c != null && !skip) {\r\n            ReorderPreviewAnimation rha = new ReorderPreviewAnimation(child, mode, lp.cellX, lp.cellY, c.x, c.y, c.spanX, c.spanY);\r\n            rha.animate();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isContiguousZipCode",
	"Comment": "returns true if string s is a valid contiguous u.s. zip code.must be 5 or 9 digits only.",
	"Method": "boolean isContiguousZipCode(String s){\r\n    boolean retval = false;\r\n    if (isZipCode(s)) {\r\n        if (isEmpty(s))\r\n            retval = defaultEmptyOK;\r\n        else {\r\n            String normalizedZip = s.substring(0, 5);\r\n            int iZip = Integer.parseInt(normalizedZip);\r\n            if ((iZip >= 96701 && iZip <= 96898) || (iZip >= 99501 && iZip <= 99950))\r\n                retval = false;\r\n            else\r\n                retval = true;\r\n        }\r\n    }\r\n    return retval;\r\n}"
}, {
	"Path": "com.android.launcher3.DragView.setIntrinsicIconScaleFactor",
	"Comment": "sets the scale of the view over the normal workspace icon size.",
	"Method": "void setIntrinsicIconScaleFactor(float scale){\r\n    mIntrinsicIconScale = scale;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.OffsetSegmentGenerator.addMitreJoin",
	"Comment": "adds a mitre join connecting the two reflex offset segments.the mitre will be beveled if it exceeds the mitre ratio limit.",
	"Method": "void addMitreJoin(Coordinate p,LineSegment offset0,LineSegment offset1,double distance){\r\n    boolean isMitreWithinLimit = true;\r\n    Coordinate intPt = null;\r\n    try {\r\n        intPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);\r\n        double mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);\r\n        if (mitreRatio > bufParams.getMitreLimit())\r\n            isMitreWithinLimit = false;\r\n    } catch (NotRepresentableException ex) {\r\n        intPt = new Coordinate(0, 0);\r\n        isMitreWithinLimit = false;\r\n    }\r\n    if (isMitreWithinLimit) {\r\n        segList.addPt(intPt);\r\n    } else {\r\n        addLimitedMitreJoin(offset0, offset1, distance, bufParams.getMitreLimit());\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherStateTransitionAnimation.startAnimationToOverlay",
	"Comment": "creates and starts a new animation to a particular overlay view.",
	"Method": "AnimatorSet startAnimationToOverlay(Workspace.State fromWorkspaceState,Workspace.State toWorkspaceState,View buttonView,View toView,View contentView,View revealView,View overlaySearchBarView,boolean animated,PrivateTransitionCallbacks pCb){\r\n    final AnimatorSet animation = LauncherAnimUtils.createAnimatorSet();\r\n    final Resources res = mLauncher.getResources();\r\n    final boolean material = Utilities.ATLEAST_LOLLIPOP;\r\n    final int revealDuration = res.getInteger(R.integer.config_overlayRevealTime);\r\n    final int itemsAlphaStagger = res.getInteger(R.integer.config_overlayItemsAlphaStagger);\r\n    final View fromView = mLauncher.getWorkspace();\r\n    final HashMap<View, Integer> layerViews = new HashMap();\r\n    boolean initialized = buttonView != null;\r\n    cancelAnimation();\r\n    Animator workspaceAnim = mLauncher.startWorkspaceStateChangeAnimation(toWorkspaceState, -1, animated, layerViews);\r\n    startWorkspaceSearchBarAnimation(animation, fromWorkspaceState, toWorkspaceState, animated ? revealDuration : 0, overlaySearchBarView);\r\n    if (animated && initialized) {\r\n        int width = revealView.getMeasuredWidth();\r\n        int height = revealView.getMeasuredHeight();\r\n        float revealRadius = (float) Math.hypot(width / 2, height / 2);\r\n        revealView.setVisibility(View.VISIBLE);\r\n        revealView.setAlpha(0f);\r\n        revealView.setTranslationY(0f);\r\n        revealView.setTranslationX(0f);\r\n        final float revealViewToAlpha;\r\n        final float revealViewToXDrift;\r\n        final float revealViewToYDrift;\r\n        if (material) {\r\n            int[] buttonViewToPanelDelta = Utilities.getCenterDeltaInScreenSpace(revealView, buttonView, null);\r\n            revealViewToAlpha = pCb.getMaterialRevealViewFinalAlpha(revealView);\r\n            revealViewToYDrift = buttonViewToPanelDelta[1];\r\n            revealViewToXDrift = buttonViewToPanelDelta[0];\r\n        } else {\r\n            revealViewToAlpha = 0f;\r\n            revealViewToYDrift = 2 * height / 3;\r\n            revealViewToXDrift = 0;\r\n        }\r\n        PropertyValuesHolder panelAlpha = PropertyValuesHolder.ofFloat(\"alpha\", revealViewToAlpha, 1f);\r\n        PropertyValuesHolder panelDriftY = PropertyValuesHolder.ofFloat(\"translationY\", revealViewToYDrift, 0);\r\n        PropertyValuesHolder panelDriftX = PropertyValuesHolder.ofFloat(\"translationX\", revealViewToXDrift, 0);\r\n        ObjectAnimator panelAlphaAndDrift = ObjectAnimator.ofPropertyValuesHolder(revealView, panelAlpha, panelDriftY, panelDriftX);\r\n        panelAlphaAndDrift.setDuration(revealDuration);\r\n        panelAlphaAndDrift.setInterpolator(new LogDecelerateInterpolator(100, 0));\r\n        layerViews.put(revealView, BUILD_AND_SET_LAYER);\r\n        animation.play(panelAlphaAndDrift);\r\n        if (overlaySearchBarView != null) {\r\n            overlaySearchBarView.setAlpha(0f);\r\n            ObjectAnimator searchBarAlpha = ObjectAnimator.ofFloat(overlaySearchBarView, \"alpha\", 0f, 1f);\r\n            searchBarAlpha.setDuration(100);\r\n            searchBarAlpha.setInterpolator(new AccelerateInterpolator(1.5f));\r\n            layerViews.put(overlaySearchBarView, BUILD_AND_SET_LAYER);\r\n            animation.play(searchBarAlpha);\r\n        }\r\n        contentView.setVisibility(View.VISIBLE);\r\n        contentView.setAlpha(0f);\r\n        contentView.setTranslationY(revealViewToYDrift);\r\n        layerViews.put(contentView, BUILD_AND_SET_LAYER);\r\n        ObjectAnimator pageDrift = ObjectAnimator.ofFloat(contentView, \"translationY\", revealViewToYDrift, 0);\r\n        pageDrift.setDuration(revealDuration);\r\n        pageDrift.setInterpolator(new LogDecelerateInterpolator(100, 0));\r\n        pageDrift.setStartDelay(itemsAlphaStagger);\r\n        animation.play(pageDrift);\r\n        ObjectAnimator itemsAlpha = ObjectAnimator.ofFloat(contentView, \"alpha\", 0f, 1f);\r\n        itemsAlpha.setDuration(revealDuration);\r\n        itemsAlpha.setInterpolator(new AccelerateInterpolator(1.5f));\r\n        itemsAlpha.setStartDelay(itemsAlphaStagger);\r\n        animation.play(itemsAlpha);\r\n        if (material) {\r\n            float startRadius = pCb.getMaterialRevealViewStartFinalRadius();\r\n            AnimatorListenerAdapter listener = pCb.getMaterialRevealViewAnimatorListener(revealView, buttonView);\r\n            Animator reveal = UiThreadCircularReveal.createCircularReveal(revealView, width / 2, height / 2, startRadius, revealRadius);\r\n            reveal.setDuration(revealDuration);\r\n            reveal.setInterpolator(new LogDecelerateInterpolator(100, 0));\r\n            if (listener != null) {\r\n                reveal.addListener(listener);\r\n            }\r\n            animation.play(reveal);\r\n        }\r\n        animation.addListener(new AnimatorListenerAdapter() {\r\n            @Override\r\n            public void onAnimationEnd(Animator animation) {\r\n                dispatchOnLauncherTransitionEnd(fromView, animated, false);\r\n                dispatchOnLauncherTransitionEnd(toView, animated, false);\r\n                revealView.setVisibility(View.INVISIBLE);\r\n                for (View v : layerViews.keySet()) {\r\n                    if (layerViews.get(v) == BUILD_AND_SET_LAYER) {\r\n                        v.setLayerType(View.LAYER_TYPE_NONE, null);\r\n                    }\r\n                }\r\n                cleanupAnimation();\r\n                pCb.onTransitionComplete();\r\n            }\r\n        });\r\n        if (workspaceAnim != null) {\r\n            animation.play(workspaceAnim);\r\n        }\r\n        dispatchOnLauncherTransitionPrepare(fromView, animated, false);\r\n        dispatchOnLauncherTransitionPrepare(toView, animated, false);\r\n        final AnimatorSet stateAnimation = animation;\r\n        final Runnable startAnimRunnable = new Runnable() {\r\n            public void run() {\r\n                if (mCurrentAnimation != stateAnimation)\r\n                    return;\r\n                dispatchOnLauncherTransitionStart(fromView, animated, false);\r\n                dispatchOnLauncherTransitionStart(toView, animated, false);\r\n                for (View v : layerViews.keySet()) {\r\n                    if (layerViews.get(v) == BUILD_AND_SET_LAYER) {\r\n                        v.setLayerType(View.LAYER_TYPE_HARDWARE, null);\r\n                    }\r\n                    if (Utilities.ATLEAST_LOLLIPOP && Utilities.isViewAttachedToWindow(v)) {\r\n                        v.buildLayer();\r\n                    }\r\n                }\r\n                toView.requestFocus();\r\n                stateAnimation.start();\r\n            }\r\n        };\r\n        toView.bringToFront();\r\n        toView.setVisibility(View.VISIBLE);\r\n        toView.post(startAnimRunnable);\r\n        return animation;\r\n    } else {\r\n        toView.setTranslationX(0.0f);\r\n        toView.setTranslationY(0.0f);\r\n        toView.setScaleX(1.0f);\r\n        toView.setScaleY(1.0f);\r\n        toView.setVisibility(View.VISIBLE);\r\n        toView.bringToFront();\r\n        contentView.setVisibility(View.VISIBLE);\r\n        dispatchOnLauncherTransitionPrepare(fromView, animated, false);\r\n        dispatchOnLauncherTransitionStart(fromView, animated, false);\r\n        dispatchOnLauncherTransitionEnd(fromView, animated, false);\r\n        dispatchOnLauncherTransitionPrepare(toView, animated, false);\r\n        dispatchOnLauncherTransitionStart(toView, animated, false);\r\n        dispatchOnLauncherTransitionEnd(toView, animated, false);\r\n        pCb.onTransitionComplete();\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherStateTransitionAnimation.startAnimationToOverlay",
	"Comment": "creates and starts a new animation to a particular overlay view.",
	"Method": "AnimatorSet startAnimationToOverlay(Workspace.State fromWorkspaceState,Workspace.State toWorkspaceState,View buttonView,View toView,View contentView,View revealView,View overlaySearchBarView,boolean animated,PrivateTransitionCallbacks pCb){\r\n    dispatchOnLauncherTransitionEnd(fromView, animated, false);\r\n    dispatchOnLauncherTransitionEnd(toView, animated, false);\r\n    revealView.setVisibility(View.INVISIBLE);\r\n    for (View v : layerViews.keySet()) {\r\n        if (layerViews.get(v) == BUILD_AND_SET_LAYER) {\r\n            v.setLayerType(View.LAYER_TYPE_NONE, null);\r\n        }\r\n    }\r\n    cleanupAnimation();\r\n    pCb.onTransitionComplete();\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherStateTransitionAnimation.startAnimationToOverlay",
	"Comment": "creates and starts a new animation to a particular overlay view.",
	"Method": "AnimatorSet startAnimationToOverlay(Workspace.State fromWorkspaceState,Workspace.State toWorkspaceState,View buttonView,View toView,View contentView,View revealView,View overlaySearchBarView,boolean animated,PrivateTransitionCallbacks pCb){\r\n    if (mCurrentAnimation != stateAnimation)\r\n        return;\r\n    dispatchOnLauncherTransitionStart(fromView, animated, false);\r\n    dispatchOnLauncherTransitionStart(toView, animated, false);\r\n    for (View v : layerViews.keySet()) {\r\n        if (layerViews.get(v) == BUILD_AND_SET_LAYER) {\r\n            v.setLayerType(View.LAYER_TYPE_HARDWARE, null);\r\n        }\r\n        if (Utilities.ATLEAST_LOLLIPOP && Utilities.isViewAttachedToWindow(v)) {\r\n            v.buildLayer();\r\n        }\r\n    }\r\n    toView.requestFocus();\r\n    stateAnimation.start();\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.LineIntersector.isInteriorIntersection",
	"Comment": "tests whether either intersection point is an interior point of the specified input segment.",
	"Method": "boolean isInteriorIntersection(boolean isInteriorIntersection,int inputLineIndex){\r\n    for (int i = 0; i < result; i++) {\r\n        if (!(intPt[i].equals2D(inputLines[inputLineIndex][0]) || intPt[i].equals2D(inputLines[inputLineIndex][1]))) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.EdgeList.findEqualEdge",
	"Comment": "if there is an edge equal to e already in the list, return it.otherwise return null.",
	"Method": "Edge findEqualEdge(Edge e){\r\n    OrientedCoordinateArray oca = new OrientedCoordinateArray(e.getCoordinates());\r\n    Edge matchEdge = (Edge) ocaMap.get(oca);\r\n    return matchEdge;\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.deleteFolderContentsFromDatabase",
	"Comment": "remove the contents of the specified folder from the database",
	"Method": "void deleteFolderContentsFromDatabase(Context context,FolderInfo info){\r\n    final ContentResolver cr = context.getContentResolver();\r\n    Runnable r = new Runnable() {\r\n        public void run() {\r\n            cr.delete(LauncherSettings.Favorites.getContentUri(info.id), null, null);\r\n            synchronized (sBgLock) {\r\n                sBgItemsIdMap.remove(info.id);\r\n                sBgFolders.remove(info.id);\r\n                sBgWorkspaceItems.remove(info);\r\n            }\r\n            cr.delete(LauncherSettings.Favorites.CONTENT_URI, LauncherSettings.Favorites.CONTAINER + \"=\" + info.id, null);\r\n            synchronized (sBgLock) {\r\n                for (ItemInfo childInfo : info.contents) {\r\n                    sBgItemsIdMap.remove(childInfo.id);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    runOnWorkerThread(r);\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.deleteFolderContentsFromDatabase",
	"Comment": "remove the contents of the specified folder from the database",
	"Method": "void deleteFolderContentsFromDatabase(Context context,FolderInfo info){\r\n    cr.delete(LauncherSettings.Favorites.getContentUri(info.id), null, null);\r\n    synchronized (sBgLock) {\r\n        sBgItemsIdMap.remove(info.id);\r\n        sBgFolders.remove(info.id);\r\n        sBgWorkspaceItems.remove(info);\r\n    }\r\n    cr.delete(LauncherSettings.Favorites.CONTENT_URI, LauncherSettings.Favorites.CONTAINER + \"=\" + info.id, null);\r\n    synchronized (sBgLock) {\r\n        for (ItemInfo childInfo : info.contents) {\r\n            sBgItemsIdMap.remove(childInfo.id);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.EdgeRing.getEdges",
	"Comment": "returns the list of directededges that make up this edgering",
	"Method": "List getEdges(){\r\n    return edges;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.lens.lenses.MapLens.asCopy",
	"Comment": "a lens that focuses on a copy of a map. useful for composition to avoid mutating a map reference.",
	"Method": "Lens.Simple<Map<K, V>, Map<K, V>> asCopy(){\r\n    return simpleLens(HashMap::new, (__, copy) -> copy);\r\n}"
}, {
	"Path": "org.zeromq.ZFrame.hasData",
	"Comment": "convenience method to ascertain if this frame contains some message data",
	"Method": "boolean hasData(){\r\n    return data != null;\r\n}"
}, {
	"Path": "org.kse.gui.about.SystemPropertiesTableCellRend.getTableCellRendererComponent",
	"Comment": "returns the rendered cell for the supplied value and column.",
	"Method": "Component getTableCellRendererComponent(JTable jtSystemProperties,Object value,boolean isSelected,boolean hasFocus,int row,int col){\r\n    JLabel cell = (JLabel) super.getTableCellRendererComponent(jtSystemProperties, value, isSelected, hasFocus, row, col);\r\n    cell.setHorizontalAlignment(LEFT);\r\n    cell.setBorder(new EmptyBorder(0, 5, 0, 5));\r\n    return cell;\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isWhitespace",
	"Comment": "returns true if string s is empty or whitespace characters only.",
	"Method": "boolean isWhitespace(String s){\r\n    if (isEmpty(s))\r\n        return true;\r\n    for (int i = 0; i < s.length(); i++) {\r\n        char c = s.charAt(i);\r\n        if (whitespace.indexOf(c) == -1)\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.utils.tuple.MutablePair.of",
	"Comment": "obtains an immutable pair of from two objects inferring the generic types.this factory allows the pair to be created using inference toobtain the generic types.",
	"Method": "MutablePair<L, R> of(L left,R right){\r\n    return new MutablePair(left, right);\r\n}"
}, {
	"Path": "org.joda.money.format.MoneyAmountStyle.of",
	"Comment": "gets a localized style.this creates a localized style for the specified locale.grouping will be enabled, forced decimal point will be disabled,absolute values will be disabled.",
	"Method": "MoneyAmountStyle of(Locale locale){\r\n    return getLocalizedStyle(locale);\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.TopologyLocation.merge",
	"Comment": "merge updates only the null attributes of this objectwith the attributes of another.",
	"Method": "void merge(TopologyLocation gl){\r\n    if (gl.location.length > location.length) {\r\n        int[] newLoc = new int[3];\r\n        newLoc[Position.ON] = location[Position.ON];\r\n        newLoc[Position.LEFT] = Location.NONE;\r\n        newLoc[Position.RIGHT] = Location.NONE;\r\n        location = newLoc;\r\n    }\r\n    for (int i = 0; i < location.length; i++) {\r\n        if (location[i] == Location.NONE && i < gl.location.length)\r\n            location[i] = gl.location[i];\r\n    }\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.product.Product3.rotateR3",
	"Comment": "rotate the first three values of this product one slot to the right.",
	"Method": "Product3<_3, _1, _2> rotateR3(){\r\n    return into((_1, _2, _3) -> product(_3, _1, _2));\r\n}"
}, {
	"Path": "com.jdon.model.query.block.BlockStrategy.locate",
	"Comment": "looking for the primary be equals to locateid in the result for the sql\tsentence.",
	"Method": "Block locate(String sqlquery,Collection queryParams,Object locateId){\r\n    int blockSize = getBlockLength();\r\n    Block block = null;\r\n    int index = -1;\r\n    int prevBlockStart = Integer.MIN_VALUE;\r\n    int nextBlockStart = Integer.MIN_VALUE;\r\n    int start = 0;\r\n    Debug.logVerbose(\"[JdonFramework]try to locate a block locateId= \" + locateId + \" blockSize=\" + blockSize, module);\r\n    try {\r\n        while (index == -1) {\r\n            block = getBlock(sqlquery, queryParams, start, blockSize);\r\n            if (block == null)\r\n                break;\r\n            List list = block.getList();\r\n            index = list.indexOf(locateId);\r\n            if ((index >= 0) && (index < list.size())) {\r\n                Debug.logVerbose(\"[JdonFramework]found the locateId, index= \" + index, module);\r\n                if ((index == 0) && (block.getStart() >= blockSize))\r\n                    prevBlockStart = start - blockSize;\r\n                else if (index == blockSize - 1)\r\n                    nextBlockStart = start + blockSize;\r\n                break;\r\n            } else {\r\n                if (block.getCount() >= blockSize)\r\n                    start = start + blockSize;\r\n                else\r\n                    break;\r\n            }\r\n        }\r\n        if (index == -1) {\r\n            Debug.logVerbose(\"[JdonFramework] not locate the block that have the locateId= \" + locateId, module);\r\n            return null;\r\n        }\r\n        if (prevBlockStart != Integer.MIN_VALUE) {\r\n            Block prevBlock = getBlock(sqlquery, queryParams, prevBlockStart, blockSize);\r\n            prevBlock.getList().addAll(block.getList());\r\n            prevBlock.setStart(prevBlock.getStart() + prevBlock.getCount());\r\n            prevBlock.setCount(prevBlock.getCount() + block.getCount());\r\n            return prevBlock;\r\n        } else if (nextBlockStart != Integer.MIN_VALUE) {\r\n            Block nextBlock = getBlock(sqlquery, queryParams, nextBlockStart, blockSize);\r\n            if (nextBlock != null) {\r\n                block.getList().addAll(nextBlock.getList());\r\n                block.setCount(block.getCount() + nextBlock.getCount());\r\n            }\r\n            return block;\r\n        } else\r\n            return block;\r\n    } catch (Exception e) {\r\n        Debug.logError(\" locate Block error\" + e, module);\r\n    }\r\n    return block;\r\n}"
}, {
	"Path": "org.kse.gui.FileChooserFactory.getPkiPathFileChooser",
	"Comment": "get a jfilechooser filtered for pki path certificate files.",
	"Method": "JFileChooser getPkiPathFileChooser(){\r\n    JFileChooser chooser = getFileChooser();\r\n    chooser.addChoosableFileFilter(new FileExtFilter(new String[] { PKI_PATH_EXT }, PKI_PATH_FILE_DESC));\r\n    return chooser;\r\n}"
}, {
	"Path": "com.android.launcher3.accessibility.WorkspaceAccessibilityHelper.intersectsValidDropTarget",
	"Comment": "find the virtual view id corresponding to the top left corner of any drop region by whichthe passed id is contained. for an icon, this is simply",
	"Method": "int intersectsValidDropTarget(int id){\r\n    int mCountX = mView.getCountX();\r\n    int mCountY = mView.getCountY();\r\n    int x = id % mCountX;\r\n    int y = id / mCountX;\r\n    LauncherAccessibilityDelegate.DragInfo dragInfo = mDelegate.getDragInfo();\r\n    if (dragInfo.dragType == DragType.WIDGET && mView.isHotseat()) {\r\n        return INVALID_POSITION;\r\n    }\r\n    if (dragInfo.dragType == DragType.WIDGET) {\r\n        boolean fits = false;\r\n        int spanX = dragInfo.info.spanX;\r\n        int spanY = dragInfo.info.spanY;\r\n        for (int m = 0; m < spanX; m++) {\r\n            for (int n = 0; n < spanY; n++) {\r\n                fits = true;\r\n                int x0 = x - m;\r\n                int y0 = y - n;\r\n                if (x0 < 0 || y0 < 0)\r\n                    continue;\r\n                for (int i = x0; i < x0 + spanX; i++) {\r\n                    if (!fits)\r\n                        break;\r\n                    for (int j = y0; j < y0 + spanY; j++) {\r\n                        if (i >= mCountX || j >= mCountY || mView.isOccupied(i, j)) {\r\n                            fits = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (fits) {\r\n                    return x0 + mCountX * y0;\r\n                }\r\n            }\r\n        }\r\n        return INVALID_POSITION;\r\n    } else {\r\n        View child = mView.getChildAt(x, y);\r\n        if (child == null || child == dragInfo.item) {\r\n            return id;\r\n        } else if (dragInfo.dragType != DragType.FOLDER) {\r\n            ItemInfo info = (ItemInfo) child.getTag();\r\n            if (info instanceof AppInfo || info instanceof FolderInfo || info instanceof ShortcutInfo) {\r\n                return id;\r\n            }\r\n        }\r\n        return INVALID_POSITION;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.prep.PreparedPolygonPredicate.isAnyTestComponentInTarget",
	"Comment": "tests whether any component of the test geometry intersectsthe area of the target geometry.handles test geometries with both linear and point components.",
	"Method": "boolean isAnyTestComponentInTarget(Geometry testGeom){\r\n    List coords = ComponentCoordinateExtracter.getCoordinates(testGeom);\r\n    for (Iterator i = coords.iterator(); i.hasNext(); ) {\r\n        Coordinate p = (Coordinate) i.next();\r\n        int loc = targetPointLocator.locate(p);\r\n        if (loc != Location.EXTERIOR)\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isZipCode",
	"Comment": "iszipcode returns true if string s is a valid u.s. zip code.must be 5 or 9 digits only.",
	"Method": "boolean isZipCode(String s){\r\n    if (isEmpty(s))\r\n        return defaultEmptyOK;\r\n    String normalizedZip = stripCharsInBag(s, ZipCodeDelimiters);\r\n    return (isInteger(normalizedZip) && ((normalizedZip.length() == digitsInZipCode1) || (normalizedZip.length() == digitsInZipCode2)));\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.ConstraintVertex.merge",
	"Comment": "merges the constraint data in the vertex other into this vertex. this method is called when an inserted vertex isvery close to an existing vertex in the triangulation.",
	"Method": "void merge(ConstraintVertex other){\r\n    if (other.isOnConstraint) {\r\n        isOnConstraint = true;\r\n        constraint = other.constraint;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.index.strtree.AbstractSTRtree.createParentBoundables",
	"Comment": "sorts the childboundables then divides them into groups of size m, wherem is the node capacity.",
	"Method": "List createParentBoundables(List childBoundables,int newLevel){\r\n    Assert.isTrue(!childBoundables.isEmpty());\r\n    ArrayList parentBoundables = new ArrayList();\r\n    parentBoundables.add(createNode(newLevel));\r\n    ArrayList sortedChildBoundables = new ArrayList(childBoundables);\r\n    Collections.sort(sortedChildBoundables, getComparator());\r\n    for (Iterator i = sortedChildBoundables.iterator(); i.hasNext(); ) {\r\n        Boundable childBoundable = (Boundable) i.next();\r\n        if (lastNode(parentBoundables).getChildBoundables().size() == getNodeCapacity()) {\r\n            parentBoundables.add(createNode(newLevel));\r\n        }\r\n        lastNode(parentBoundables).addChildBoundable(childBoundable);\r\n    }\r\n    return parentBoundables;\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.NodingIntersectionFinder.isInteriorVertexIntersection",
	"Comment": "tests if two vertices with at least one in a segmentstring interiorare equal.",
	"Method": "boolean isInteriorVertexIntersection(Coordinate p00,Coordinate p01,Coordinate p10,Coordinate p11,boolean isEnd00,boolean isEnd01,boolean isEnd10,boolean isEnd11,boolean isInteriorVertexIntersection,Coordinate p0,Coordinate p1,boolean isEnd0,boolean isEnd1){\r\n    if (isEnd0 && isEnd1)\r\n        return false;\r\n    if (p0.equals2D(p1)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.EdgeConnectedTriangleTraversal.visitAll",
	"Comment": "subclasses call this method to perform the visiting process.",
	"Method": "void visitAll(TraversalVisitor visitor){\r\n    while (!triQueue.isEmpty()) {\r\n        QuadEdgeTriangle tri = (QuadEdgeTriangle) triQueue.removeFirst();\r\n        process(tri, visitor);\r\n    }\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct3.diverge",
	"Comment": "diverge this coproduct by introducing another possible type that it could represent.",
	"Method": "CoProduct4<A, B, C, D, ? extends CoProduct4<A, B, C, D, ?>> diverge(){\r\n    return new CoProduct4<A, B, C, D, CoProduct4<A, B, C, D, ?>>() {\r\n        @Override\r\n        public <R> R match(Function<? super A, ? extends R> aFn, Function<? super B, ? extends R> bFn, Function<? super C, ? extends R> cFn, Function<? super D, ? extends R> dFn) {\r\n            return CoProduct3.this.match(aFn, bFn, cFn);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct3.diverge",
	"Comment": "diverge this coproduct by introducing another possible type that it could represent.",
	"Method": "CoProduct4<A, B, C, D, ? extends CoProduct4<A, B, C, D, ?>> diverge(){\r\n    return CoProduct3.this.match(aFn, bFn, cFn);\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.impl.PackedCoordinateSequenceFactory.create",
	"Comment": "create a packed coordinate sequence from the provided array.",
	"Method": "CoordinateSequence create(Coordinate[] coordinates,CoordinateSequence create,CoordinateSequence coordSeq,CoordinateSequence create,double[] packedCoordinates,int dimension,CoordinateSequence create,double[] packedCoordinates,int dimension,int measures,CoordinateSequence create,float[] packedCoordinates,int dimension,CoordinateSequence create,float[] packedCoordinates,int dimension,int measures,CoordinateSequence create,int size,int dimension,CoordinateSequence create,int size,int dimension,int measures){\r\n    if (type == DOUBLE) {\r\n        return new PackedCoordinateSequence.Double(size, dimension, measures);\r\n    } else {\r\n        return new PackedCoordinateSequence.Float(size, dimension, measures);\r\n    }\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct3.projectB",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the second slot value.",
	"Method": "Maybe<B> projectB(){\r\n    return project()._2();\r\n}"
}, {
	"Path": "org.locationtech.jts.linearref.LengthIndexedLine.clampIndex",
	"Comment": "computes a valid index for this lineby clamping the given index to the valid range of index values",
	"Method": "double clampIndex(double index){\r\n    double posIndex = positiveIndex(index);\r\n    double startIndex = getStartIndex();\r\n    if (posIndex < startIndex)\r\n        return startIndex;\r\n    double endIndex = getEndIndex();\r\n    if (posIndex > endIndex)\r\n        return endIndex;\r\n    return posIndex;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct3.projectA",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the first slot value.",
	"Method": "Maybe<A> projectA(){\r\n    return project()._1();\r\n}"
}, {
	"Path": "org.locationtech.jtstest.geomfunction.StaticMethodGeometryFunction.createFullArgs",
	"Comment": "creates an arg array which includes the target geometry as the first argument",
	"Method": "Object[] createFullArgs(Geometry g,Object[] arg){\r\n    int fullArgLen = 1;\r\n    if (arg != null)\r\n        fullArgLen = arg.length + 1;\r\n    Object[] fullArg = new Object[fullArgLen];\r\n    fullArg[0] = g;\r\n    for (int i = 1; i < fullArgLen; i++) {\r\n        fullArg[i] = arg[i - 1];\r\n    }\r\n    return fullArg;\r\n}"
}, {
	"Path": "com.android.launcher3.AllAppsList.updatePackage",
	"Comment": "add and remove icons for this package which has been updated.",
	"Method": "void updatePackage(Context context,String packageName,UserHandleCompat user){\r\n    final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);\r\n    final List<LauncherActivityInfoCompat> matches = launcherApps.getActivityList(packageName, user);\r\n    if (matches.size() > 0) {\r\n        for (int i = data.size() - 1; i >= 0; i--) {\r\n            final AppInfo applicationInfo = data.get(i);\r\n            final ComponentName component = applicationInfo.intent.getComponent();\r\n            if (user.equals(applicationInfo.user) && packageName.equals(component.getPackageName())) {\r\n                if (!findActivity(matches, component)) {\r\n                    removed.add(applicationInfo);\r\n                    data.remove(i);\r\n                }\r\n            }\r\n        }\r\n        for (final LauncherActivityInfoCompat info : matches) {\r\n            AppInfo applicationInfo = findApplicationInfoLocked(info.getComponentName().getPackageName(), user, info.getComponentName().getClassName());\r\n            if (applicationInfo == null) {\r\n                add(new AppInfo(context, info, user, mIconCache));\r\n            } else {\r\n                mIconCache.getTitleAndIcon(applicationInfo, info, true);\r\n                modified.add(applicationInfo);\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = data.size() - 1; i >= 0; i--) {\r\n            final AppInfo applicationInfo = data.get(i);\r\n            final ComponentName component = applicationInfo.intent.getComponent();\r\n            if (user.equals(applicationInfo.user) && packageName.equals(component.getPackageName())) {\r\n                removed.add(applicationInfo);\r\n                mIconCache.remove(component, user);\r\n                data.remove(i);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct3.projectC",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the third slot value.",
	"Method": "Maybe<C> projectC(){\r\n    return project()._3();\r\n}"
}, {
	"Path": "com.android.launcher3.AppWidgetsRestoredReceiver.restoreAppWidgetIds",
	"Comment": "updates the app widgets whose id has changed during the restore process.",
	"Method": "void restoreAppWidgetIds(Context context,int[] oldWidgetIds,int[] newWidgetIds){\r\n    final ContentResolver cr = context.getContentResolver();\r\n    final List<Integer> idsToRemove = new ArrayList<Integer>();\r\n    final AppWidgetManager widgets = AppWidgetManager.getInstance(context);\r\n    for (int i = 0; i < oldWidgetIds.length; i++) {\r\n        Log.i(TAG, \"Widget state restore id \" + oldWidgetIds[i] + \" => \" + newWidgetIds[i]);\r\n        final AppWidgetProviderInfo provider = widgets.getAppWidgetInfo(newWidgetIds[i]);\r\n        final int state;\r\n        if (LauncherModel.isValidProvider(provider)) {\r\n            state = LauncherAppWidgetInfo.FLAG_UI_NOT_READY;\r\n        } else {\r\n            state = LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY;\r\n        }\r\n        ContentValues values = new ContentValues();\r\n        values.put(LauncherSettings.Favorites.APPWIDGET_ID, newWidgetIds[i]);\r\n        values.put(LauncherSettings.Favorites.RESTORED, state);\r\n        String[] widgetIdParams = new String[] { Integer.toString(oldWidgetIds[i]) };\r\n        int result = cr.update(Favorites.CONTENT_URI, values, \"appWidgetId=? and (restored & 1) = 1\", widgetIdParams);\r\n        if (result == 0) {\r\n            Cursor cursor = cr.query(Favorites.CONTENT_URI, new String[] { Favorites.APPWIDGET_ID }, \"appWidgetId=?\", widgetIdParams, null);\r\n            try {\r\n                if (!cursor.moveToFirst()) {\r\n                    idsToRemove.add(newWidgetIds[i]);\r\n                }\r\n            } finally {\r\n                cursor.close();\r\n            }\r\n        }\r\n    }\r\n    if (!idsToRemove.isEmpty()) {\r\n        final AppWidgetHost appWidgetHost = new AppWidgetHost(context, Launcher.APPWIDGET_HOST_ID);\r\n        new AsyncTask<Void, Void, Void>() {\r\n            public Void doInBackground(Void... args) {\r\n                for (Integer id : idsToRemove) {\r\n                    appWidgetHost.deleteAppWidgetId(id);\r\n                    Log.e(TAG, \"Widget no longer present, appWidgetId=\" + id);\r\n                }\r\n                return null;\r\n            }\r\n        }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, (Void) null);\r\n    }\r\n    LauncherAppState app = LauncherAppState.getInstanceNoCreate();\r\n    if (app != null) {\r\n        app.reloadWorkspace();\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.AppWidgetsRestoredReceiver.restoreAppWidgetIds",
	"Comment": "updates the app widgets whose id has changed during the restore process.",
	"Method": "void restoreAppWidgetIds(Context context,int[] oldWidgetIds,int[] newWidgetIds){\r\n    for (Integer id : idsToRemove) {\r\n        appWidgetHost.deleteAppWidgetId(id);\r\n        Log.e(TAG, \"Widget no longer present, appWidgetId=\" + id);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherStateTransitionAnimation.startAnimationToWorkspace",
	"Comment": "starts and animation to the workspace from the current overlay view.",
	"Method": "void startAnimationToWorkspace(Launcher.State fromState,Workspace.State fromWorkspaceState,Workspace.State toWorkspaceState,int toWorkspacePage,boolean animated,Runnable onCompleteRunnable){\r\n    if (toWorkspaceState != Workspace.State.NORMAL && toWorkspaceState != Workspace.State.SPRING_LOADED && toWorkspaceState != Workspace.State.OVERVIEW) {\r\n        Log.e(TAG, \"Unexpected call to startAnimationToWorkspace\");\r\n    }\r\n    if (fromState == Launcher.State.APPS || fromState == Launcher.State.APPS_SPRING_LOADED) {\r\n        startAnimationToWorkspaceFromAllApps(fromWorkspaceState, toWorkspaceState, toWorkspacePage, animated, onCompleteRunnable);\r\n    } else {\r\n        startAnimationToWorkspaceFromWidgets(fromWorkspaceState, toWorkspaceState, toWorkspacePage, animated, onCompleteRunnable);\r\n    }\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.lens.Lens.simpleLens",
	"Comment": "static factory method for creating a simple lens from a getter function and a setter function.",
	"Method": "Lens.Simple<S, A> simpleLens(Function<? super S, ? extends A> getter,BiFunction<? super S, ? super A, ? extends S> setter){\r\n    return adapt(lens(getter, setter));\r\n}"
}, {
	"Path": "com.android.launcher3.Workspace.getAllShortcutAndWidgetContainers",
	"Comment": "we should only use this to search for specific children.do not use this method to modifyshortcutsandwidgetscontainer directly. includes shortcutandwidgetcontainers fromthe hotseat and workspace pages",
	"Method": "ArrayList<ShortcutAndWidgetContainer> getAllShortcutAndWidgetContainers(){\r\n    ArrayList<ShortcutAndWidgetContainer> childrenLayouts = new ArrayList<ShortcutAndWidgetContainer>();\r\n    int screenCount = getChildCount();\r\n    for (int screen = 0; screen < screenCount; screen++) {\r\n        childrenLayouts.add(((CellLayout) getChildAt(screen)).getShortcutsAndWidgets());\r\n    }\r\n    if (mLauncher.getHotseat() != null) {\r\n        childrenLayouts.add(mLauncher.getHotseat().getLayout().getShortcutsAndWidgets());\r\n    }\r\n    return childrenLayouts;\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.utils.Serialization.unmarshal",
	"Comment": "unmarshals a stream optionally performing placeholder substitution to the stream.",
	"Method": "T unmarshal(InputStream is,T unmarshal,InputStream is,Map<String, String> parameters,T unmarshal,InputStream is,ObjectMapper mapper,T unmarshal,InputStream is,ObjectMapper mapper,Map<String, String> parameters,T unmarshal,String str,Class<T> type,T unmarshal,String str,Class<T> type,Map<String, String> parameters,T unmarshal,InputStream is,Class<T> type,T unmarshal,InputStream is,Class<T> type,Map<String, String> parameters,T unmarshal,InputStream is,TypeReference<T> type,T unmarshal,InputStream is,TypeReference<T> type,Map<String, String> parameters){\r\n    InputStream wrapped = parameters != null && !parameters.isEmpty() ? new ReplaceValueStream(parameters).createInputStream(is) : is;\r\n    try (BufferedInputStream bis = new BufferedInputStream(wrapped)) {\r\n        bis.mark(-1);\r\n        int intch;\r\n        do {\r\n            intch = bis.read();\r\n        } while (intch > -1 && Character.isWhitespace(intch));\r\n        bis.reset();\r\n        ObjectMapper mapper = JSON_MAPPER;\r\n        if (intch != '{') {\r\n            mapper = YAML_MAPPER;\r\n        }\r\n        return mapper.readValue(bis, type);\r\n    } catch (IOException e) {\r\n        throw KubernetesClientException.launderThrowable(e);\r\n    }\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.functions.specialized.Predicate.predicate",
	"Comment": "static factory method to create a predicate from a function.",
	"Method": "Predicate<A> predicate(Function<? super A, ? extends Boolean> predicate){\r\n    return predicate::apply;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.PointLocator.intersects",
	"Comment": "convenience method to test a point for intersection witha geometry",
	"Method": "boolean intersects(Coordinate p,Geometry geom){\r\n    return locate(p, geom) != Location.EXTERIOR;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.linemerge.LineMergeEdge.getLine",
	"Comment": "returns the linestring specifying the vertices of this edge.",
	"Method": "LineString getLine(){\r\n    return line;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.CoordinateSequences.ensureValidRing",
	"Comment": "ensures that a coordinatesequence forms a valid ring, returning a new closed sequence of the correct length if required.if the input sequence is already a valid ring, it is returned without modification.if the input sequence is too short or is not closed, it is extended with one or more copies of the start point.",
	"Method": "CoordinateSequence ensureValidRing(CoordinateSequenceFactory fact,CoordinateSequence seq){\r\n    int n = seq.size();\r\n    if (n == 0)\r\n        return seq;\r\n    if (n <= 3)\r\n        return createClosedRing(fact, seq, 4);\r\n    boolean isClosed = seq.getOrdinate(0, CoordinateSequence.X) == seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) == seq.getOrdinate(n - 1, CoordinateSequence.Y);\r\n    if (isClosed)\r\n        return seq;\r\n    return createClosedRing(fact, seq, n + 1);\r\n}"
}, {
	"Path": "org.locationtech.jts.io.ByteOrderDataInStream.setInStream",
	"Comment": "allows a single byteorderdatainstream to be reusedon multiple instreams.",
	"Method": "void setInStream(InStream stream){\r\n    this.stream = stream;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.relate.EdgeEndBundleStar.updateIM",
	"Comment": "update the im with the contribution for the edgestubs around the node.",
	"Method": "void updateIM(IntersectionMatrix im){\r\n    for (Iterator it = iterator(); it.hasNext(); ) {\r\n        EdgeEndBundle esb = (EdgeEndBundle) it.next();\r\n        esb.updateIM(im);\r\n    }\r\n}"
}, {
	"Path": "org.kse.crypto.x509.X509CertUtil.verifyCertificate",
	"Comment": "verify that one x.509 certificate was signed using the private key that\tcorresponds to the public key of a second certificate.",
	"Method": "boolean verifyCertificate(X509Certificate signedCert,X509Certificate signingCert){\r\n    try {\r\n        signedCert.verify(signingCert.getPublicKey());\r\n        return true;\r\n    } catch (InvalidKeyException | SignatureException ex) {\r\n        return false;\r\n    } catch (NoSuchProviderException | NoSuchAlgorithmException | CertificateException ex) {\r\n        throw new CryptoException(res.getString(\"NoVerifyCertificate.exception.message\"), ex);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.planargraph.Node.isRemoved",
	"Comment": "tests whether this node has been removed from its containing graph",
	"Method": "boolean isRemoved(){\r\n    return pt == null;\r\n}"
}, {
	"Path": "com.jsql.util.GitUtil.showNews",
	"Comment": "displays news informations on the console from github web service.infos concern the general roadmap for the application, current development statusand other useful statements for the community.",
	"Method": "void showNews(){\r\n    try {\r\n        JSONArray news = GitUtil.getJSONObject().getJSONArray(\"news\");\r\n        for (int index = 0; index < news.length(); index++) {\r\n            LOGGER.info(news.get(index));\r\n        }\r\n    } catch (IOException e) {\r\n        LOGGER.warn(\"Connection to the Github News Webservice failed\", e);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.io.oracle.OraUtil.toInteger",
	"Comment": "converts an oracle datum into an int value, with a default value used if the datum is null.",
	"Method": "int toInteger(Datum datum,int defaultValue){\r\n    if (datum == null)\r\n        return defaultValue;\r\n    return ((NUMBER) datum).intValue();\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.GeometryGraph.addPolygonRing",
	"Comment": "adds a polygon ring to the graph.empty rings are ignored.the left and right topological location arguments assume that the ring is oriented cw.if the ring is in the opposite orientation,the left and right locations must be interchanged.",
	"Method": "void addPolygonRing(LinearRing lr,int cwLeft,int cwRight){\r\n    if (lr.isEmpty())\r\n        return;\r\n    Coordinate[] coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());\r\n    if (coord.length < 4) {\r\n        hasTooFewPoints = true;\r\n        invalidPoint = coord[0];\r\n        return;\r\n    }\r\n    int left = cwLeft;\r\n    int right = cwRight;\r\n    if (Orientation.isCCW(coord)) {\r\n        left = cwRight;\r\n        right = cwLeft;\r\n    }\r\n    Edge e = new Edge(coord, new Label(argIndex, Location.BOUNDARY, left, right));\r\n    lineEdgeMap.put(lr, e);\r\n    insertEdge(e);\r\n    insertPoint(argIndex, coord[0], Location.BOUNDARY);\r\n}"
}, {
	"Path": "org.locationtech.jts.planargraph.Node.getOutEdges",
	"Comment": "returns the collection of directededges that leave this node.",
	"Method": "DirectedEdgeStar getOutEdges(){\r\n    return deStar;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.functions.Fn5.apply",
	"Comment": "partially apply this function by taking its first four arguments.",
	"Method": "F apply(A a,B b,C c,D d,E e,Fn4<B, C, D, E, F> apply,A a,Fn3<C, D, E, F> apply,A a,B b,Fn2<D, E, F> apply,A a,B b,C c,Fn1<E, F> apply,A a,B b,C c,D d){\r\n    return (e) -> apply(a, b, c, d, e);\r\n}"
}, {
	"Path": "org.locationtech.jts.index.sweepline.SweepLineIndex.buildIndex",
	"Comment": "because delete events have a link to their corresponding insert event,it is possible to compute exactly the range of events which must becompared to a given insert event object.",
	"Method": "void buildIndex(){\r\n    if (indexBuilt)\r\n        return;\r\n    Collections.sort(events);\r\n    for (int i = 0; i < events.size(); i++) {\r\n        SweepLineEvent ev = (SweepLineEvent) events.get(i);\r\n        if (ev.isDelete()) {\r\n            ev.getInsertEvent().setDeleteEventIndex(i);\r\n        }\r\n    }\r\n    indexBuilt = true;\r\n}"
}, {
	"Path": "org.zeromq.ZCertStore.startCheckThread",
	"Comment": "start simple thread that checks if the the directory timestamp changed or the overall count of files did change. if yes it will reload all certificates again",
	"Method": "void startCheckThread(int checkTime){\r\n    if (fileCheckRunning) {\r\n        return;\r\n    }\r\n    fileCheckRunning = true;\r\n    new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            while (fileCheckRunning && !requestStopThread) {\r\n                checkAndReload();\r\n                try {\r\n                    Thread.sleep(checkTime);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            fileCheckRunning = false;\r\n            requestStopThread = false;\r\n        }\r\n    }).start();\r\n}"
}, {
	"Path": "org.zeromq.ZCertStore.startCheckThread",
	"Comment": "start simple thread that checks if the the directory timestamp changed or the overall count of files did change. if yes it will reload all certificates again",
	"Method": "void startCheckThread(int checkTime){\r\n    while (fileCheckRunning && !requestStopThread) {\r\n        checkAndReload();\r\n        try {\r\n            Thread.sleep(checkTime);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    fileCheckRunning = false;\r\n    requestStopThread = false;\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.IntersectionAdder.hasProperInteriorIntersection",
	"Comment": "a proper interior intersection is a proper intersection which is notcontained in the set of boundary nodes set for this segmentintersector.",
	"Method": "boolean hasProperInteriorIntersection(){\r\n    return hasProperInterior;\r\n}"
}, {
	"Path": "com.android.launcher3.DeleteDropTarget.removeWorkspaceOrFolderItem",
	"Comment": "removes the item from the workspace. if the view is not null, it also removes the view.",
	"Method": "boolean removeWorkspaceOrFolderItem(Launcher launcher,ItemInfo item,View view){\r\n    if (item instanceof ShortcutInfo) {\r\n        LauncherModel.deleteItemFromDatabase(launcher, item);\r\n    } else if (item instanceof FolderInfo) {\r\n        FolderInfo folder = (FolderInfo) item;\r\n        launcher.removeFolder(folder);\r\n        LauncherModel.deleteFolderContentsFromDatabase(launcher, folder);\r\n    } else if (item instanceof LauncherAppWidgetInfo) {\r\n        final LauncherAppWidgetInfo widget = (LauncherAppWidgetInfo) item;\r\n        launcher.removeAppWidget(widget);\r\n        LauncherModel.deleteItemFromDatabase(launcher, widget);\r\n        final LauncherAppWidgetHost appWidgetHost = launcher.getAppWidgetHost();\r\n        if (appWidgetHost != null && !widget.isCustomWidget() && widget.isWidgetIdValid()) {\r\n            new AsyncTask<Void, Void, Void>() {\r\n                public Void doInBackground(Void... args) {\r\n                    appWidgetHost.deleteAppWidgetId(widget.appWidgetId);\r\n                    return null;\r\n                }\r\n            }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);\r\n        }\r\n    } else {\r\n        return false;\r\n    }\r\n    if (view != null) {\r\n        launcher.getWorkspace().removeWorkspaceItem(view);\r\n        launcher.getWorkspace().stripEmptyScreens();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.android.launcher3.DeleteDropTarget.removeWorkspaceOrFolderItem",
	"Comment": "removes the item from the workspace. if the view is not null, it also removes the view.",
	"Method": "boolean removeWorkspaceOrFolderItem(Launcher launcher,ItemInfo item,View view){\r\n    appWidgetHost.deleteAppWidgetId(widget.appWidgetId);\r\n    return null;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.NonEncroachingSplitPointFinder.projectedSplitPoint",
	"Comment": "computes a split point which is the projection of the encroaching point on the segment",
	"Method": "Coordinate projectedSplitPoint(Segment seg,Coordinate encroachPt){\r\n    LineSegment lineSeg = seg.getLineSegment();\r\n    Coordinate projPt = lineSeg.project(encroachPt);\r\n    return projPt;\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.DirectedEdge.computeDirectedLabel",
	"Comment": "compute the label in the appropriate orientation for this diredge",
	"Method": "void computeDirectedLabel(){\r\n    label = new Label(edge.getLabel());\r\n    if (!isForward)\r\n        label.flip();\r\n}"
}, {
	"Path": "org.locationtech.jtslab.edgeray.EdgeRay.areaTermBoth",
	"Comment": "computes the area term for the edge rays in both directions along an edge.",
	"Method": "double areaTermBoth(double x0,double y0,double x1,double y1){\r\n    double dx = x1 - x0;\r\n    double dy = y1 - y0;\r\n    double len = Math.sqrt(dx * dx + dy * dy);\r\n    double u0x = dx / len;\r\n    double u0y = dy / len;\r\n    double n0x = u0y;\r\n    double n0y = -u0x;\r\n    double u1x = -u0x;\r\n    double u1y = -u0y;\r\n    double n1x = -u1y;\r\n    double n1y = u1x;\r\n    double areaTerm0 = 0.5 * (x0 * u0x + y0 * u0y) * (x0 * n0x + y0 * n0y);\r\n    double areaTerm1 = 0.5 * (x1 * u1x + y1 * u1y) * (x1 * n1x + y1 * n1y);\r\n    return areaTerm0 + areaTerm1;\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.getFolderById",
	"Comment": "find a folder in the db, creating the folderinfo if necessary, and adding it to folderlist.",
	"Method": "FolderInfo getFolderById(Context context,LongArrayMap<FolderInfo> folderList,long id){\r\n    final ContentResolver cr = context.getContentResolver();\r\n    Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null, \"_id=? and (itemType=? or itemType=?)\", new String[] { String.valueOf(id), String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER) }, null);\r\n    try {\r\n        if (c.moveToFirst()) {\r\n            final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);\r\n            final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);\r\n            final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);\r\n            final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);\r\n            final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);\r\n            final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);\r\n            final int optionsIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.OPTIONS);\r\n            FolderInfo folderInfo = null;\r\n            switch(c.getInt(itemTypeIndex)) {\r\n                case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:\r\n                    folderInfo = findOrMakeFolder(folderList, id);\r\n                    break;\r\n            }\r\n            folderInfo.title = c.getString(titleIndex);\r\n            folderInfo.id = id;\r\n            folderInfo.container = c.getInt(containerIndex);\r\n            folderInfo.screenId = c.getInt(screenIndex);\r\n            folderInfo.cellX = c.getInt(cellXIndex);\r\n            folderInfo.cellY = c.getInt(cellYIndex);\r\n            folderInfo.options = c.getInt(optionsIndex);\r\n            return folderInfo;\r\n        }\r\n    } finally {\r\n        c.close();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.locationtech.jts.edgegraph.HalfEdge.degree",
	"Comment": "computes the degree of the origin vertex.the degree is the number of edgesoriginating from the vertex.",
	"Method": "int degree(){\r\n    int degree = 0;\r\n    HalfEdge e = this;\r\n    do {\r\n        degree++;\r\n        e = e.oNext();\r\n    } while (e != this);\r\n    return degree;\r\n}"
}, {
	"Path": "org.kse.gui.KseFrame.setDefaultStatusBarText",
	"Comment": "set the text in the status bar to reflect the status of the active\tkeystore.",
	"Method": "void setDefaultStatusBarText(){\r\n    KeyStoreHistory history = getActiveKeyStoreHistory();\r\n    if (history == null) {\r\n        setStatusBarText(res.getString(\"KseFrame.noKeyStore.statusbar\"));\r\n    } else {\r\n        setStatusBarText(getKeyStoreStatusText(history));\r\n    }\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.Colorer.color",
	"Comment": "tell the syntax highlighting thread to take another look at this\tsection of the document. it will process this as a fifo. this method\tshould be done inside a doclock.",
	"Method": "void color(int position,int adjustment){\r\n    if (position < this.lastPosition) {\r\n        if (this.lastPosition < position - adjustment) {\r\n            this.change -= this.lastPosition - position;\r\n        } else {\r\n            this.change += adjustment;\r\n        }\r\n    }\r\n    synchronized (this.eventsLock) {\r\n        if (!this.events.isEmpty()) {\r\n            RecolorEvent curLast = this.events.getLast();\r\n            if (adjustment < 0 && curLast.getAdjustment() < 0) {\r\n                if (position == curLast.getPosition()) {\r\n                    curLast.setAdjustment(curLast.getAdjustment() + adjustment);\r\n                    return;\r\n                }\r\n            } else if (adjustment >= 0 && curLast.getAdjustment() >= 0) {\r\n                if (position == curLast.getPosition() + curLast.getAdjustment()) {\r\n                    curLast.setAdjustment(curLast.getAdjustment() + adjustment);\r\n                    return;\r\n                } else if (curLast.getPosition() == position + adjustment) {\r\n                    curLast.setPosition(position);\r\n                    curLast.setAdjustment(curLast.getAdjustment() + adjustment);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        this.events.add(new RecolorEvent(position, adjustment));\r\n        this.eventsLock.notifyAll();\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.allapps.AllAppsSearchBarController.initialize",
	"Comment": "sets the references to the apps model and the search result callback.",
	"Method": "void initialize(AlphabeticalAppsList apps,Callbacks cb){\r\n    mApps = apps;\r\n    mCb = cb;\r\n    onInitialize();\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.onClickSettingsButton",
	"Comment": "event handler for a click on the settings button that appears after a long presson the home screen.",
	"Method": "void onClickSettingsButton(View v){\r\n    if (LOGD)\r\n        Log.d(TAG, \"onClickSettingsButton\");\r\n    if (mLauncherCallbacks != null) {\r\n        mLauncherCallbacks.onClickSettingsButton(v);\r\n    } else {\r\n        startActivity(new Intent(this, SettingsActivity.class));\r\n    }\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.product.Product6.rotateR6",
	"Comment": "rotate the first six values of this product one slot to the right.",
	"Method": "Product6<_6, _1, _2, _3, _4, _5> rotateR6(){\r\n    return into((_1, _2, _3, _4, _5, _6) -> product(_6, _1, _2, _3, _4, _5));\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.CGAlgorithmsDD.intersection",
	"Comment": "computes an intersection point between two linesusing dd arithmetic.currently does not handle case of parallel lines.",
	"Method": "Coordinate intersection(Coordinate p1,Coordinate p2,Coordinate q1,Coordinate q2){\r\n    DD denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));\r\n    DD denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));\r\n    DD denom = denom1.subtract(denom2);\r\n    DD numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\r\n    DD numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\r\n    DD numx = numx1.subtract(numx2);\r\n    double fracP = numx.selfDivide(denom).doubleValue();\r\n    double x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();\r\n    DD numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\r\n    DD numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\r\n    DD numy = numy1.subtract(numy2);\r\n    double fracQ = numy.selfDivide(denom).doubleValue();\r\n    double y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();\r\n    return new Coordinate(x, y);\r\n}"
}, {
	"Path": "org.locationtech.jts.generator.PolygonGenerator.create",
	"Comment": "as the user increases the number of points, the probability of creating a random valid polygon decreases. \tplease take not of this when selecting the generation style, and the number of points. \tmay return null if a geometry could not be created.",
	"Method": "Geometry create(){\r\n    if (geometryFactory == null) {\r\n        throw new NullPointerException(\"GeometryFactory is not declared\");\r\n    }\r\n    if (boundingBox == null || boundingBox.isNull()) {\r\n        throw new NullPointerException(\"Bounding Box is not declared\");\r\n    }\r\n    if (numberPoints < 4) {\r\n        throw new IllegalStateException(\"Too few points\");\r\n    }\r\n    double x = boundingBox.getMinX();\r\n    double dx = boundingBox.getMaxX() - x;\r\n    double y = boundingBox.getMinY();\r\n    double dy = boundingBox.getMaxY() - y;\r\n    Polygon p = null;\r\n    for (int i = 0; i < RUNS; i++) {\r\n        switch(getGenerationAlgorithm()) {\r\n            case BOX:\r\n                p = createBox(x, dx, y, dy, numberHoles, numberPoints, geometryFactory);\r\n                break;\r\n            case ARC:\r\n                p = createArc(x, dx, y, dy, numberHoles, numberPoints, geometryFactory);\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"Invalid Alg. Specified\");\r\n        }\r\n        IsValidOp valid = new IsValidOp(p);\r\n        if (valid.isValid()) {\r\n            return p;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.distance.DistanceOp.isWithinDistance",
	"Comment": "test whether two geometries lie within a given distance of each other.",
	"Method": "boolean isWithinDistance(Geometry g0,Geometry g1,double distance){\r\n    DistanceOp distOp = new DistanceOp(g0, g1, distance);\r\n    return distOp.distance() <= distance;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.CGAlgorithms.distancePointLine",
	"Comment": "computes the distance from a point to a sequence of line segments.",
	"Method": "double distancePointLine(Coordinate p,Coordinate A,Coordinate B,double distancePointLine,Coordinate p,Coordinate[] line){\r\n    if (line.length == 0)\r\n        throw new IllegalArgumentException(\"Line array must contain at least one vertex\");\r\n    double minDistance = p.distance(line[0]);\r\n    for (int i = 0; i < line.length - 1; i++) {\r\n        double dist = distancePointLine(p, line[i], line[i + 1]);\r\n        if (dist < minDistance) {\r\n            minDistance = dist;\r\n        }\r\n    }\r\n    return minDistance;\r\n}"
}, {
	"Path": "com.example.android.justjava.MainActivity.displayQuantity",
	"Comment": "this method displays the given quantity value on the screen.",
	"Method": "void displayQuantity(int numberOfCoffees){\r\n    TextView quantityTextView = (TextView) findViewById(R.id.quantity_text_view);\r\n    quantityTextView.setText(\"\" + numberOfCoffees);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.overlay.LineBuilder.labelIsolatedLine",
	"Comment": "label an isolated node with its relationship to the target geometry.",
	"Method": "void labelIsolatedLine(Edge e,int targetIndex){\r\n    int loc = ptLocator.locate(e.getCoordinate(), op.getArgGeometry(targetIndex));\r\n    e.getLabel().setLocation(targetIndex, loc);\r\n}"
}, {
	"Path": "com.jsql.view.swing.table.AdjusterTableColumn.restoreColumn",
	"Comment": "restore the width of the specified column to its previous width",
	"Method": "void restoreColumn(int column){\r\n    TableColumn tableColumn = this.tableAdjust.getColumnModel().getColumn(column);\r\n    Integer width = this.columnSizes.get(tableColumn);\r\n    if (width != null) {\r\n        this.tableAdjust.getTableHeader().setResizingColumn(tableColumn);\r\n        tableColumn.setWidth(width.intValue());\r\n    }\r\n}"
}, {
	"Path": "com.jdon.controller.service.WebServiceAccessorImp.execute",
	"Comment": "1. create a sessioncontext object in httpsession 2. save the principle\tname in the session context. the principle name the\trequest.getprinciplenme you can save more attribute in the sessioncontext\tobject by replcaing this class in container.xmlsessioncontextinterceptor will get the sessioncontext into targetobject\timplements sessionacceptable",
	"Method": "Object execute(RequestWrapper request,Object execute){\r\n    ContainerWrapper cw = containerCallback.getContainerWrapper();\r\n    if (!cw.isStart()) {\r\n        Debug.logError(\"JdonFramework not yet started, please try later \", module);\r\n        return null;\r\n    }\r\n    return serviceAccessor.executeService(cw);\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.utils.Utils.replaceAllWithoutRegex",
	"Comment": "replaces all occurrences of the from text with to text without any regular expressions",
	"Method": "String replaceAllWithoutRegex(String text,String from,String to){\r\n    if (text == null) {\r\n        return null;\r\n    }\r\n    int idx = 0;\r\n    while (true) {\r\n        idx = text.indexOf(from, idx);\r\n        if (idx >= 0) {\r\n            text = text.substring(0, idx) + to + text.substring(idx + from.length());\r\n            idx += to.length();\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    return text;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.valid.IsValidOp.findPtNotNode",
	"Comment": "find a point from the list of testcoordsthat is not a node in the edge for the list of searchcoords",
	"Method": "Coordinate findPtNotNode(Coordinate[] testCoords,LinearRing searchRing,GeometryGraph graph){\r\n    Edge searchEdge = graph.findEdge(searchRing);\r\n    EdgeIntersectionList eiList = searchEdge.getEdgeIntersectionList();\r\n    for (int i = 0; i < testCoords.length; i++) {\r\n        Coordinate pt = testCoords[i];\r\n        if (!eiList.isIntersection(pt))\r\n            return pt;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.jdon.persistence.hibernate.HibernateTemplate.isCacheQueries",
	"Comment": "return whether to cache all queries executed by this template.",
	"Method": "boolean isCacheQueries(){\r\n    return cacheQueries;\r\n}"
}, {
	"Path": "org.kse.gui.about.EnvironmentVariablesTableCellRend.getTableCellRendererComponent",
	"Comment": "returns the rendered cell for the supplied value and column.",
	"Method": "Component getTableCellRendererComponent(JTable jtEnvironmentVariables,Object value,boolean isSelected,boolean hasFocus,int row,int col){\r\n    JLabel cell = (JLabel) super.getTableCellRendererComponent(jtEnvironmentVariables, value, isSelected, hasFocus, row, col);\r\n    cell.setHorizontalAlignment(LEFT);\r\n    cell.setBorder(new EmptyBorder(0, 5, 0, 5));\r\n    return cell;\r\n}"
}, {
	"Path": "org.kse.crypto.signing.JarSigner.createAttributeText",
	"Comment": "create manifest attribute text from the supplied attribute name and value",
	"Method": "String createAttributeText(String attributeName,String attributeValue){\r\n    String attributeText = MessageFormat.format(ATTR_TEMPLATE, attributeName, attributeValue);\r\n    StringBuilder sb = new StringBuilder();\r\n    String remainingText = attributeText;\r\n    while (true) {\r\n        if (remainingText.length() > 70) {\r\n            sb.append(remainingText.substring(0, 70));\r\n            sb.append(CRLF);\r\n            sb.append(\" \");\r\n            remainingText = remainingText.substring(70);\r\n        } else {\r\n            sb.append(remainingText);\r\n            break;\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.android.launcher3.allapps.AlphabeticalAppsList.getAndUpdateCachedSectionName",
	"Comment": "returns the cached section name for the given title, recomputing and updating the cache ifthe title has no cached section name.",
	"Method": "String getAndUpdateCachedSectionName(CharSequence title){\r\n    String sectionName = mCachedSectionNames.get(title);\r\n    if (sectionName == null) {\r\n        sectionName = mIndexer.computeSectionName(title);\r\n        mCachedSectionNames.put(title, sectionName);\r\n    }\r\n    return sectionName;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.NonRobustRayCrossingCounter.isOnSegment",
	"Comment": "reports whether the point lies exactly on one of the supplied segments.this method may be called at any time as segments are processed.if the result of this method is true, no further segments need be supplied, since the resultwill never change again.",
	"Method": "boolean isOnSegment(){\r\n    return isPointOnSegment;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.validate.BufferDistanceValidator.getErrorIndicator",
	"Comment": "gets a geometry which indicates the location and nature of a validation failure.the indicator is a line segment showing the location and sizeof the distance discrepancy.",
	"Method": "Geometry getErrorIndicator(){\r\n    return errorIndicator;\r\n}"
}, {
	"Path": "org.kse.gui.PlatformUtil.createDialogButtonPanel",
	"Comment": "create a dialog button panel with the order and alignment dependent on\tthe platform.",
	"Method": "JPanel createDialogButtonPanel(JButton jbPositive,JPanel createDialogButtonPanel,JButton[] jbPositives,JPanel createDialogButtonPanel,JButton jbPositive,JButton jbNegative,JPanel createDialogButtonPanel,JButton[] jbPositives,JButton jbNegative,JPanel createDialogButtonPanel,JButton jbPositive,JButton jbNegative,JButton jbOther,JPanel createDialogButtonPanel,JButton jbPositive,JButton jbNegative,JButton[] jbOther,JPanel createDialogButtonPanel,JButton[] jbPositives,JButton jbNegative,JButton[] jbOthers,String insets){\r\n    if (insets == null) {\r\n        insets = \"\";\r\n    } else {\r\n        insets += \",\";\r\n    }\r\n    JPanel panel = new JPanel(new MigLayout(insets + \"nogrid, fillx, aligny 100%\"));\r\n    if (jbPositives != null) {\r\n        for (JButton jButton : jbPositives) {\r\n            panel.add(jButton, \"tag ok\");\r\n        }\r\n    }\r\n    if (jbOthers != null) {\r\n        for (JButton jButton : jbOthers) {\r\n            panel.add(jButton, \"sgx\");\r\n        }\r\n    }\r\n    if (jbNegative != null) {\r\n        panel.add(jbNegative, \"tag cancel\");\r\n    }\r\n    return panel;\r\n}"
}, {
	"Path": "com.android.launcher3.Workspace.createDragOutline",
	"Comment": "returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.responsibility for the bitmap is transferred to the caller.",
	"Method": "Bitmap createDragOutline(View v,int padding,Bitmap createDragOutline,Bitmap orig,int padding,int w,int h,boolean clipAlpha){\r\n    final int outlineColor = getResources().getColor(R.color.outline_color);\r\n    final Bitmap b = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);\r\n    mCanvas.setBitmap(b);\r\n    Rect src = new Rect(0, 0, orig.getWidth(), orig.getHeight());\r\n    float scaleFactor = Math.min((w - padding) / (float) orig.getWidth(), (h - padding) / (float) orig.getHeight());\r\n    int scaledWidth = (int) (scaleFactor * orig.getWidth());\r\n    int scaledHeight = (int) (scaleFactor * orig.getHeight());\r\n    Rect dst = new Rect(0, 0, scaledWidth, scaledHeight);\r\n    dst.offset((w - scaledWidth) / 2, (h - scaledHeight) / 2);\r\n    mCanvas.drawBitmap(orig, src, dst, null);\r\n    mOutlineHelper.applyExpensiveOutlineWithBlur(b, mCanvas, outlineColor, outlineColor, clipAlpha);\r\n    mCanvas.setBitmap(null);\r\n    return b;\r\n}"
}, {
	"Path": "com.android.launcher3.util.WallpaperUtils.wallpaperTravelToScreenWidthRatio",
	"Comment": "as a ratio of screen height, the total distance we want the parallax effect to spanhorizontally",
	"Method": "float wallpaperTravelToScreenWidthRatio(int width,int height){\r\n    float aspectRatio = width / (float) height;\r\n    final float ASPECT_RATIO_LANDSCAPE = 16 / 10f;\r\n    final float ASPECT_RATIO_PORTRAIT = 10 / 16f;\r\n    final float WALLPAPER_WIDTH_TO_SCREEN_RATIO_LANDSCAPE = 1.5f;\r\n    final float WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT = 1.2f;\r\n    final float x = (WALLPAPER_WIDTH_TO_SCREEN_RATIO_LANDSCAPE - WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT) / (ASPECT_RATIO_LANDSCAPE - ASPECT_RATIO_PORTRAIT);\r\n    final float y = WALLPAPER_WIDTH_TO_SCREEN_RATIO_PORTRAIT - x * ASPECT_RATIO_PORTRAIT;\r\n    return x * aspectRatio + y;\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.NodingIntersectionFinder.setKeepIntersections",
	"Comment": "sets whether intersection points are recorded.if the only need is to count intersection points, this can be set to false.default is true.",
	"Method": "void setKeepIntersections(boolean keepIntersections){\r\n    this.keepIntersections = keepIntersections;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.valid.TopologyValidationError.getMessage",
	"Comment": "gets an error message describing this error.the error message does not describe the location of the error.",
	"Method": "String getMessage(){\r\n    return errMsg[errorType];\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.DPreferences.getLookFeelDecoration",
	"Comment": "get whether or not the look & feel should be used for window decoration.",
	"Method": "boolean getLookFeelDecoration(){\r\n    return lookFeelDecorated;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.BufferSubgraph.addReachable",
	"Comment": "adds all nodes and edges reachable from this node to the subgraph.uses an explicit stack to avoid a large depth of recursion.",
	"Method": "void addReachable(Node startNode){\r\n    Stack nodeStack = new Stack();\r\n    nodeStack.add(startNode);\r\n    while (!nodeStack.empty()) {\r\n        Node node = (Node) nodeStack.pop();\r\n        add(node, nodeStack);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.NonRobustRayCrossingCounter.isPointInPolygon",
	"Comment": "tests whether the point lies in or on \tthe ring, polygon\tor multipolygon from which the processed segments were provided.\tthis method only determines the correct location \tif all relevant segments must have been processed.",
	"Method": "boolean isPointInPolygon(){\r\n    return getLocation() != Location.EXTERIOR;\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DD.magnitude",
	"Comment": "determines the decimal magnitude of a number.the magnitude is the exponent of the greatest power of 10 which is less thanor equal to the number.",
	"Method": "int magnitude(double x){\r\n    double xAbs = Math.abs(x);\r\n    double xLog10 = Math.log(xAbs) / Math.log(10);\r\n    int xMag = (int) Math.floor(xLog10);\r\n    double xApprox = Math.pow(10, xMag);\r\n    if (xApprox * 10 <= xAbs)\r\n        xMag += 1;\r\n    return xMag;\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.NodedSegmentString.addIntersections",
	"Comment": "adds edgeintersections for one or bothintersections found for a segment of an edge to the edge intersection list.",
	"Method": "void addIntersections(LineIntersector li,int segmentIndex,int geomIndex){\r\n    for (int i = 0; i < li.getIntersectionNum(); i++) {\r\n        addIntersection(li, segmentIndex, geomIndex, i);\r\n    }\r\n}"
}, {
	"Path": "test.jts.perf.operation.predicate.RectangleIntersectsPerfTest.createRectangles",
	"Comment": "creates a set of rectangular polygons which cover the given envelope.the rectangles at least nrect rectangles are created.",
	"Method": "Geometry[] createRectangles(Envelope env,int nRect,double rectSize){\r\n    int nSide = 1 + (int) Math.sqrt((double) nRect);\r\n    double dx = env.getWidth() / nSide;\r\n    double dy = env.getHeight() / nSide;\r\n    List rectList = new ArrayList();\r\n    for (int i = 0; i < nSide; i++) {\r\n        for (int j = 0; j < nSide; j++) {\r\n            double baseX = env.getMinX() + i * dx;\r\n            double baseY = env.getMinY() + j * dy;\r\n            Envelope envRect = new Envelope(baseX, baseX + dx, baseY, baseY + dy);\r\n            Geometry rect = fact.toGeometry(envRect);\r\n            rectList.add(rect);\r\n        }\r\n    }\r\n    return GeometryFactory.toGeometryArray(rectList);\r\n}"
}, {
	"Path": "com.jsql.view.swing.panel.util.MetalUtilsCustom.isLeftToRight",
	"Comment": "convenience function for determining componentorientation.helps usavoid having munge directives throughout the code.",
	"Method": "boolean isLeftToRight(Component c){\r\n    return c.getComponentOrientation().isLeftToRight();\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.util.AffineTransformation.rotate",
	"Comment": "updates the value of this transformationto that of a rotation around a given point composed with the current value,with the sin and cos of the rotation angle specified directly.",
	"Method": "AffineTransformation rotate(double theta,AffineTransformation rotate,double sinTheta,double cosTheta,AffineTransformation rotate,double theta,double x,double y,AffineTransformation rotate,double sinTheta,double cosTheta,double x,double y){\r\n    compose(rotationInstance(sinTheta, cosTheta, x, y));\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.money.Money.equals",
	"Comment": "checks if this monetary value equals another.the comparison takes into account the scale.the compared values must be in the same currency.",
	"Method": "boolean equals(Object other){\r\n    if (this == other) {\r\n        return true;\r\n    }\r\n    if (other instanceof Money) {\r\n        Money otherMoney = (Money) other;\r\n        return money.equals(otherMoney.money);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.locationtech.jts.io.oracle.StaticMultiPolygonTest.testSingleMultiPolygonManyPointsHolesRoundTrip",
	"Comment": "round trip test for a single multipolygon with lotsa points",
	"Method": "void testSingleMultiPolygonManyPointsHolesRoundTrip(){\r\n    PolygonGenerator pgc = new PolygonGenerator();\r\n    pgc.setGeometryFactory(geometryFactory);\r\n    pgc.setGenerationAlgorithm(PolygonGenerator.BOX);\r\n    pgc.setNumberPoints(1000);\r\n    pgc.setNumberHoles(4);\r\n    MultiGenerator pg = new MultiGenerator(pgc);\r\n    pg.setBoundingBox(new Envelope(0, 10, 0, 10));\r\n    pg.setNumberGeometries(3);\r\n    pg.setGeometryFactory(geometryFactory);\r\n    MultiPolygon pt = (MultiPolygon) pg.create();\r\n    OraWriter ow = new OraWriter();\r\n    STRUCT st = ow.write(pt, getConnection());\r\n    OraReader or = new OraReader();\r\n    MultiPolygon pt2 = (MultiPolygon) or.read(st);\r\n    assertTrue(\"The input MultiPolygon is not the same as the output MultiPolygon\", pt.equals(pt2));\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.addOrMoveItemInDatabase",
	"Comment": "adds an item to the db if it was not created previously, or move it to a new",
	"Method": "void addOrMoveItemInDatabase(Context context,ItemInfo item,long container,long screenId,int cellX,int cellY){\r\n    if (item.container == ItemInfo.NO_ID) {\r\n        addItemToDatabase(context, item, container, screenId, cellX, cellY);\r\n    } else {\r\n        moveItemInDatabase(context, item, container, screenId, cellX, cellY);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.io.kml.KMLWriter.setPrecision",
	"Comment": "sets the maximum number of decimal places to output in ordinate values.useful for limiting output size.",
	"Method": "void setPrecision(int precision){\r\n    if (precision >= 0)\r\n        numberFormatter = createFormatter(precision);\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.RobustLineIntersectionTest.testRoundedPointsNotAltered",
	"Comment": "tests a case where intersection point is rounded, and it is computed as a nearest endpoint.exposed a bug due to aliasing of endpoint. md 8 mar 2013",
	"Method": "void testRoundedPointsNotAltered(){\r\n    checkInputNotAltered(\"LINESTRING (-58.00593335955 -1.43739086465, -513.86101637525 -457.29247388035)\", \"LINESTRING (-215.22279674875 -158.65425425385, -218.1208801283 -160.68343590235)\", 100000);\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DD.selfMultiply",
	"Comment": "multiplies this object by the argument, returning this.to prevent altering constants, this method must only be used on values known to be newly created.",
	"Method": "DD selfMultiply(DD y,DD selfMultiply,double y,DD selfMultiply,double yhi,double ylo){\r\n    double hx, tx, hy, ty, C, c;\r\n    C = SPLIT * hi;\r\n    hx = C - hi;\r\n    c = SPLIT * yhi;\r\n    hx = C - hx;\r\n    tx = hi - hx;\r\n    hy = c - yhi;\r\n    C = hi * yhi;\r\n    hy = c - hy;\r\n    ty = yhi - hy;\r\n    c = ((((hx * hy - C) + hx * ty) + tx * hy) + tx * ty) + (hi * ylo + lo * yhi);\r\n    double zhi = C + c;\r\n    hx = C - zhi;\r\n    double zlo = c + hx;\r\n    hi = zhi;\r\n    lo = zlo;\r\n    return this;\r\n}"
}, {
	"Path": "org.kse.gui.TableColumnAdjuster.setColumnHeaderIncluded",
	"Comment": "indicates whether to include the header in the width calculation",
	"Method": "void setColumnHeaderIncluded(boolean isColumnHeaderIncluded){\r\n    this.isColumnHeaderIncluded = isColumnHeaderIncluded;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.Geometry.getFactory",
	"Comment": "gets the factory which contains the context in which this geometry was created.",
	"Method": "GeometryFactory getFactory(){\r\n    return factory;\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.syntax.SQLToken.isOperator",
	"Comment": "checks this token to see if it is a operator. operators are explained injava languagespecification.",
	"Method": "boolean isOperator(){\r\n    return (this.id >> 8) == 0x5;\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testbuilder.GeometryPopupMenu.show",
	"Comment": "record model coordinate of click point for use in menu operations",
	"Method": "void show(Component invoker,int x,int y){\r\n    GeometryEditPanel editPanel = (GeometryEditPanel) invoker;\r\n    clickCoord = editPanel.getViewport().toModelCoordinate(new java.awt.Point(x, y));\r\n    super.show(invoker, x, y);\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.IncrementalDelaunayTriangulator.insertSite",
	"Comment": "inserts a new point into a subdivision representing a delaunay\ttriangulation, and fixes the affected edges so that the result is still a\tdelaunay triangulation.",
	"Method": "QuadEdge insertSite(Vertex v){\r\n    QuadEdge e = subdiv.locate(v);\r\n    if (subdiv.isVertexOfEdge(e, v)) {\r\n        return e;\r\n    } else if (subdiv.isOnEdge(e, v.getCoordinate())) {\r\n        e = e.oPrev();\r\n        subdiv.delete(e.oNext());\r\n    }\r\n    QuadEdge base = subdiv.makeEdge(e.orig(), v);\r\n    QuadEdge.splice(base, e);\r\n    QuadEdge startEdge = base;\r\n    do {\r\n        base = subdiv.connect(e, base.sym());\r\n        e = base.oPrev();\r\n    } while (e.lNext() != startEdge);\r\n    do {\r\n        QuadEdge t = e.oPrev();\r\n        if (t.dest().rightOf(e) && v.isInCircle(e.orig(), t.dest(), e.dest())) {\r\n            QuadEdge.swap(e);\r\n            e = e.oPrev();\r\n        } else if (e.oNext() == startEdge) {\r\n            return base;\r\n        } else {\r\n            e = e.oNext().lPrev();\r\n        }\r\n    } while (true);\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.Area.ofRingSigned",
	"Comment": "computes the signed area for a ring. the signed area is positive if thering is oriented cw, negative if the ring is oriented ccw, and zero if thering is degenerate or flat.",
	"Method": "double ofRingSigned(Coordinate[] ring,double ofRingSigned,CoordinateSequence ring){\r\n    int n = ring.size();\r\n    if (n < 3)\r\n        return 0.0;\r\n    Coordinate p0 = new Coordinate();\r\n    Coordinate p1 = new Coordinate();\r\n    Coordinate p2 = new Coordinate();\r\n    ring.getCoordinate(0, p1);\r\n    ring.getCoordinate(1, p2);\r\n    double x0 = p1.x;\r\n    p2.x -= x0;\r\n    double sum = 0.0;\r\n    for (int i = 1; i < n - 1; i++) {\r\n        p0.y = p1.y;\r\n        p1.x = p2.x;\r\n        p1.y = p2.y;\r\n        ring.getCoordinate(i + 1, p2);\r\n        p2.x -= x0;\r\n        sum += p1.x * (p0.y - p2.y);\r\n    }\r\n    return sum / 2.0;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.functions.Fn4.apply",
	"Comment": "partially apply this function by taking its first three arguments.",
	"Method": "E apply(A a,B b,C c,D d,Fn3<B, C, D, E> apply,A a,Fn2<C, D, E> apply,A a,B b,Fn1<D, E> apply,A a,B b,C c){\r\n    return (d) -> apply(a, b, c, d);\r\n}"
}, {
	"Path": "com.jdon.controller.model.Model.setCacheable",
	"Comment": "in the past version, this method name is setcacheble, now change it after\t1.3 !",
	"Method": "void setCacheable(boolean cacheable){\r\n    this.cacheable = cacheable;\r\n}"
}, {
	"Path": "com.jdon.util.jdom.DataFormatFilter.startDocument",
	"Comment": "filter a start document event.reset state and pass the event on for further processing.",
	"Method": "void startDocument(){\r\n    reset();\r\n    super.startDocument();\r\n}"
}, {
	"Path": "org.kse.crypto.signing.JarSigner.writeJarEntries",
	"Comment": "write out all jar entries from source jar to output stream excepting\tmanifest and existing signature files for the supplied signature name",
	"Method": "void writeJarEntries(JarFile jar,JarOutputStream jos,String signatureName){\r\n    for (Enumeration<?> jarEntries = jar.entries(); jarEntries.hasMoreElements(); ) {\r\n        JarEntry jarEntry = (JarEntry) jarEntries.nextElement();\r\n        if (!jarEntry.isDirectory()) {\r\n            String entryName = jarEntry.getName();\r\n            String sigFileLocation = MessageFormat.format(METAINF_FILE_LOCATION, signatureName, SIGNATURE_EXT).toUpperCase();\r\n            String dsaSigBlockLocation = MessageFormat.format(METAINF_FILE_LOCATION, signatureName, DSA_SIG_BLOCK_EXT);\r\n            String rsaSigBlockLocation = MessageFormat.format(METAINF_FILE_LOCATION, signatureName, RSA_SIG_BLOCK_EXT);\r\n            if ((!entryName.equalsIgnoreCase(MANIFEST_LOCATION)) && (!entryName.equalsIgnoreCase(sigFileLocation)) && (!entryName.equalsIgnoreCase(dsaSigBlockLocation)) && (!entryName.equalsIgnoreCase(rsaSigBlockLocation))) {\r\n                JarEntry newJarEntry = new JarEntry(jarEntry.getName());\r\n                newJarEntry.setMethod(jarEntry.getMethod());\r\n                newJarEntry.setCompressedSize(jarEntry.getCompressedSize());\r\n                newJarEntry.setCrc(jarEntry.getCrc());\r\n                jos.putNextEntry(newJarEntry);\r\n                try (InputStream jis = jar.getInputStream(jarEntry)) {\r\n                    byte[] buffer = new byte[2048];\r\n                    int read = -1;\r\n                    while ((read = jis.read(buffer)) != -1) {\r\n                        jos.write(buffer, 0, read);\r\n                    }\r\n                    jos.closeEntry();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.AllAppsList.removePackage",
	"Comment": "remove the apps for the given apk identified by packagename.",
	"Method": "void removePackage(String packageName,UserHandleCompat user){\r\n    final List<AppInfo> data = this.data;\r\n    for (int i = data.size() - 1; i >= 0; i--) {\r\n        AppInfo info = data.get(i);\r\n        final ComponentName component = info.intent.getComponent();\r\n        if (info.user.equals(user) && packageName.equals(component.getPackageName())) {\r\n            removed.add(info);\r\n            data.remove(i);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.kse.gui.ticker.DefaultTickerRenderer.getTickerRendererComponent",
	"Comment": "get the rendering component for the specified jticker and ticker item",
	"Method": "JComponent getTickerRendererComponent(JTicker ticker,Object value){\r\n    setText(value.toString());\r\n    return this;\r\n}"
}, {
	"Path": "com.jsql.view.swing.ui.ComponentBorder.paintBorder",
	"Comment": "in this case a real component is to be painted. setting the location of the component will cause it to be painted at that location.",
	"Method": "void paintBorder(Component c,Graphics g,int x,int y,int width,int height){\r\n    float x2 = ComponentOrientation.getOrientation(I18n.getLocaleDefault()) == ComponentOrientation.RIGHT_TO_LEFT ? (0 + this.component.getWidth()) * this.component.getAlignmentX() + x : (width - this.component.getWidth()) * this.component.getAlignmentX() + x;\r\n    float y2 = (height - this.component.getHeight()) * this.component.getAlignmentY() + y;\r\n    this.component.setLocation((int) x2 + this.addX, (int) y2 + this.addY);\r\n}"
}, {
	"Path": "org.locationtech.jts.linearref.LengthIndexedLine.isValidIndex",
	"Comment": "tests whether an index is in the valid index range for the line.",
	"Method": "boolean isValidIndex(double index){\r\n    return (index >= getStartIndex() && index <= getEndIndex());\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.union.CascadedPolygonUnion.reduceToGeometries",
	"Comment": "reduces a tree of geometries to a list of geometriesby recursively unioning the subtrees in the list.",
	"Method": "List reduceToGeometries(List geomTree){\r\n    List geoms = new ArrayList();\r\n    for (Iterator i = geomTree.iterator(); i.hasNext(); ) {\r\n        Object o = i.next();\r\n        Geometry geom = null;\r\n        if (o instanceof List) {\r\n            geom = unionTree((List) o);\r\n        } else if (o instanceof Geometry) {\r\n            geom = (Geometry) o;\r\n        }\r\n        geoms.add(geom);\r\n    }\r\n    return geoms;\r\n}"
}, {
	"Path": "org.kse.gui.TableColumnAdjuster.installActions",
	"Comment": "install actions to give user control of certain functionality.",
	"Method": "void installActions(){\r\n    installColumnAction(true, true, \"adjustColumn\", \"control ADD\");\r\n    installColumnAction(false, true, \"adjustColumns\", \"control shift ADD\");\r\n    installColumnAction(true, false, \"restoreColumn\", \"control SUBTRACT\");\r\n    installColumnAction(false, false, \"restoreColumns\", \"control shift SUBTRACT\");\r\n    installToggleAction(true, false, \"toggleDynamic\", \"control MULTIPLY\");\r\n    installToggleAction(false, true, \"toggleLarger\", \"control DIVIDE\");\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.getRestoredItemIntent",
	"Comment": "make an intent object for a restored application or shortcut item that pointsto the market page for the item.",
	"Method": "Intent getRestoredItemIntent(Cursor c,Context context,Intent intent){\r\n    ComponentName componentName = intent.getComponent();\r\n    return getMarketIntent(componentName.getPackageName());\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.prep.PreparedPolygonPredicate.isAllTestComponentsInTarget",
	"Comment": "tests whether all components of the test geometry \tare contained in the target geometry.handles both linear and point components.",
	"Method": "boolean isAllTestComponentsInTarget(Geometry testGeom){\r\n    List coords = ComponentCoordinateExtracter.getCoordinates(testGeom);\r\n    for (Iterator i = coords.iterator(); i.hasNext(); ) {\r\n        Coordinate p = (Coordinate) i.next();\r\n        int loc = targetPointLocator.locate(p);\r\n        if (loc == Location.EXTERIOR)\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.functions.Fn1.diMap",
	"Comment": "exercise both dimapl and dimapr over this function in the same invocation.",
	"Method": "Fn1<Z, C> diMap(Function<? super Z, ? extends A> lFn,Function<? super B, ? extends C> rFn){\r\n    return lFn.andThen(this).andThen(rFn)::apply;\r\n}"
}, {
	"Path": "org.kse.gui.LnfUtil.useLnfForPlatform",
	"Comment": "use the appropriate look and feel for the current platform.",
	"Method": "String useLnfForPlatform(){\r\n    String lnfClassName = null;\r\n    if (OperatingSystem.isMacOs() || OperatingSystem.isWindows()) {\r\n        lnfClassName = UIManager.getSystemLookAndFeelClassName();\r\n    } else {\r\n        String xdgCurrentDesktop = System.getenv(\"XDG_CURRENT_DESKTOP\");\r\n        if (\"Unity\".equalsIgnoreCase(xdgCurrentDesktop) || \"XFCE\".equalsIgnoreCase(xdgCurrentDesktop) || \"GNOME\".equalsIgnoreCase(xdgCurrentDesktop) || \"X-Cinnamon\".equalsIgnoreCase(xdgCurrentDesktop) || \"LXDE\".equalsIgnoreCase(xdgCurrentDesktop)) {\r\n            lnfClassName = UIManager.getSystemLookAndFeelClassName();\r\n        } else {\r\n            lnfClassName = Plastic3DLookAndFeel.class.getName();\r\n        }\r\n    }\r\n    useLnf(lnfClassName);\r\n    return lnfClassName;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.PolygonizeDirectedEdge.setNext",
	"Comment": "sets the next directed edge in the edgering that this directed edge is a member",
	"Method": "void setNext(PolygonizeDirectedEdge next){\r\n    this.next = next;\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.importexport.DImportKeyPairType.importPvk",
	"Comment": "has the user chosen to import from pvk private key and certificate file\tcombination?",
	"Method": "boolean importPvk(){\r\n    return jrbPvk.isSelected();\r\n}"
}, {
	"Path": "com.android.launcher3.BaseContainerView.isValidSearchBarBounds",
	"Comment": "returns whether the search bar bounds we got are considered valid.",
	"Method": "boolean isValidSearchBarBounds(Rect searchBarBounds){\r\n    return !searchBarBounds.isEmpty() && searchBarBounds.right <= getMeasuredWidth() && searchBarBounds.bottom <= getMeasuredHeight();\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.prep.PreparedPolygonContains.contains",
	"Comment": "tests whether this preparedpolygon contains a given geometry.",
	"Method": "boolean contains(PreparedPolygon prep,Geometry geom,boolean contains,Geometry geom){\r\n    return eval(geom);\r\n}"
}, {
	"Path": "com.android.launcher3.CellLayout.cellToPoint",
	"Comment": "given a cell coordinate, return the point that represents the upper left corner of that cell",
	"Method": "void cellToPoint(int cellX,int cellY,int[] result){\r\n    final int hStartPadding = getPaddingLeft();\r\n    final int vStartPadding = getPaddingTop();\r\n    result[0] = hStartPadding + cellX * (mCellWidth + mWidthGap);\r\n    result[1] = vStartPadding + cellY * (mCellHeight + mHeightGap);\r\n}"
}, {
	"Path": "org.locationtech.jts.index.chain.MonotoneChain.getCoordinates",
	"Comment": "return the subsequence of coordinates forming this chain.allocates a new array to hold the coordinates",
	"Method": "Coordinate[] getCoordinates(){\r\n    Coordinate[] coord = new Coordinate[end - start + 1];\r\n    int index = 0;\r\n    for (int i = start; i <= end; i++) {\r\n        coord[index++] = pts[i];\r\n    }\r\n    return coord;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.overlay.OverlayOp.cancelDuplicateResultEdges",
	"Comment": "if both a diredge and its sym are marked as being in the result, cancelthem out.",
	"Method": "void cancelDuplicateResultEdges(){\r\n    for (Iterator it = graph.getEdgeEnds().iterator(); it.hasNext(); ) {\r\n        DirectedEdge de = (DirectedEdge) it.next();\r\n        DirectedEdge sym = de.getSym();\r\n        if (de.isInResult() && sym.isInResult()) {\r\n            de.setInResult(false);\r\n            sym.setInResult(false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.jdon.model.query.JdbcUtil.setQueryParams",
	"Comment": "queryparam type only support string integer float or long double bye\tshort if you need operate other types, you must use jdbc directly!",
	"Method": "void setQueryParams(Collection queryParams,PreparedStatement ps){\r\n    if ((queryParams == null) || (queryParams.size() == 0))\r\n        return;\r\n    int i = 1;\r\n    Object key = null;\r\n    Iterator iter = queryParams.iterator();\r\n    while (iter.hasNext()) {\r\n        key = iter.next();\r\n        if (key != null) {\r\n            convertType(i, key, ps);\r\n            Debug.logVerbose(\"[JdonFramework] parameter \" + i + \" = \" + key.toString(), module);\r\n        } else {\r\n            Debug.logWarning(\"[JdonFramework] parameter \" + i + \" is null\", module);\r\n            ps.setString(i, \"\");\r\n        }\r\n        i++;\r\n    }\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.DocPosition.equals",
	"Comment": "two docpositions are equal iff they have the same internal position.",
	"Method": "boolean equals(Object obj){\r\n    if (obj instanceof DocPosition) {\r\n        DocPosition d = (DocPosition) obj;\r\n        return this.position == d.position;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.kse.crypto.x509.X509CertUtil.orderX509CertChain",
	"Comment": "order the supplied array of x.509 certificates in issued to issuer order.",
	"Method": "X509Certificate[] orderX509CertChain(X509Certificate certs){\r\n    if (certs == null) {\r\n        return new X509Certificate[0];\r\n    }\r\n    if (certs.length <= 1) {\r\n        return certs;\r\n    }\r\n    ArrayList<ArrayList<X509Certificate>> paths = new ArrayList();\r\n    for (int i = 0; i < certs.length; i++) {\r\n        ArrayList<X509Certificate> path = new ArrayList();\r\n        X509Certificate issuerCert = certs[i];\r\n        path.add(issuerCert);\r\n        X509Certificate newIssuer = null;\r\n        while ((newIssuer = findIssuedCert(issuerCert, certs)) != null) {\r\n            issuerCert = newIssuer;\r\n            path.add(0, newIssuer);\r\n        }\r\n        paths.add(path);\r\n    }\r\n    ArrayList<X509Certificate> longestPath = paths.get(0);\r\n    for (int i = 1; i < paths.size(); i++) {\r\n        ArrayList<X509Certificate> path = paths.get(i);\r\n        if (path.size() > longestPath.size()) {\r\n            longestPath = path;\r\n        }\r\n    }\r\n    return longestPath.toArray(new X509Certificate[longestPath.size()]);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.BufferParameters.isSingleSided",
	"Comment": "tests whether the buffer is to be generated on a single side only.",
	"Method": "boolean isSingleSided(){\r\n    return isSingleSided;\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.OrientedCoordinateArray.orientation",
	"Comment": "computes the canonical orientation for a coordinate array.",
	"Method": "boolean orientation(Coordinate[] pts){\r\n    return CoordinateArrays.increasingDirection(pts) == 1;\r\n}"
}, {
	"Path": "org.locationtech.jts.io.oracle.OraUtil.toNUMBER",
	"Comment": "convenience method for number construction.double.nan is represented as null to agree with jts use.",
	"Method": "NUMBER toNUMBER(double number){\r\n    if (Double.isNaN(number)) {\r\n        return null;\r\n    }\r\n    return new NUMBER(number);\r\n}"
}, {
	"Path": "io.fabric8.openshift.client.dsl.internal.DeploymentConfigOperationsImpl.waitUntilDeploymentConfigIsScaled",
	"Comment": "lets wait until there are enough ready pods of the given deployment",
	"Method": "void waitUntilDeploymentConfigIsScaled(int count){\r\n    final BlockingQueue<Object> queue = new ArrayBlockingQueue<Object>(1);\r\n    final AtomicReference<Integer> replicasRef = new AtomicReference(0);\r\n    final String name = checkName(getItem());\r\n    final String namespace = checkNamespace(getItem());\r\n    final Runnable deploymentPoller = new Runnable() {\r\n        public void run() {\r\n            try {\r\n                DeploymentConfig deploymentConfig = get();\r\n                if (deploymentConfig == null) {\r\n                    if (count == 0) {\r\n                        queue.put(true);\r\n                        return;\r\n                    } else {\r\n                        queue.put(new IllegalStateException(\"Can't wait for DeploymentConfig: \" + checkName(getItem()) + \" in namespace: \" + checkName(getItem()) + \" to scale. Resource is no longer available.\"));\r\n                        return;\r\n                    }\r\n                }\r\n                replicasRef.set(deploymentConfig.getStatus().getReplicas());\r\n                int currentReplicas = deploymentConfig.getStatus().getReplicas() != null ? deploymentConfig.getStatus().getReplicas() : 0;\r\n                if (deploymentConfig.getStatus().getObservedGeneration() >= deploymentConfig.getMetadata().getGeneration() && Objects.equals(deploymentConfig.getSpec().getReplicas(), currentReplicas)) {\r\n                    queue.put(true);\r\n                } else {\r\n                    LOG.debug(\"Only {}/{} pods scheduled for DeploymentConfig: {} in namespace: {} seconds so waiting...\", deploymentConfig.getStatus().getReplicas(), deploymentConfig.getSpec().getReplicas(), deploymentConfig.getMetadata().getName(), namespace);\r\n                }\r\n            } catch (Throwable t) {\r\n                LOG.error(\"Error while waiting for Deployment to be scaled.\", t);\r\n            }\r\n        }\r\n    };\r\n    ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\r\n    ScheduledFuture poller = executor.scheduleWithFixedDelay(deploymentPoller, 0, POLL_INTERVAL_MS, TimeUnit.MILLISECONDS);\r\n    try {\r\n        if (Utils.waitUntilReady(queue, getConfig().getScaleTimeout(), TimeUnit.MILLISECONDS)) {\r\n            LOG.debug(\"{}/{} pod(s) ready for DeploymentConfig: {} in namespace: {}.\", replicasRef.get(), count, name, namespace);\r\n        } else {\r\n            LOG.error(\"{}/{} pod(s) ready for DeploymentConfig: {} in namespace: {}  after waiting for {} seconds so giving up\", replicasRef.get(), count, name, namespace, TimeUnit.MILLISECONDS.toSeconds(getConfig().getScaleTimeout()));\r\n        }\r\n    } finally {\r\n        poller.cancel(true);\r\n        executor.shutdown();\r\n    }\r\n}"
}, {
	"Path": "io.fabric8.openshift.client.dsl.internal.DeploymentConfigOperationsImpl.waitUntilDeploymentConfigIsScaled",
	"Comment": "lets wait until there are enough ready pods of the given deployment",
	"Method": "void waitUntilDeploymentConfigIsScaled(int count){\r\n    try {\r\n        DeploymentConfig deploymentConfig = get();\r\n        if (deploymentConfig == null) {\r\n            if (count == 0) {\r\n                queue.put(true);\r\n                return;\r\n            } else {\r\n                queue.put(new IllegalStateException(\"Can't wait for DeploymentConfig: \" + checkName(getItem()) + \" in namespace: \" + checkName(getItem()) + \" to scale. Resource is no longer available.\"));\r\n                return;\r\n            }\r\n        }\r\n        replicasRef.set(deploymentConfig.getStatus().getReplicas());\r\n        int currentReplicas = deploymentConfig.getStatus().getReplicas() != null ? deploymentConfig.getStatus().getReplicas() : 0;\r\n        if (deploymentConfig.getStatus().getObservedGeneration() >= deploymentConfig.getMetadata().getGeneration() && Objects.equals(deploymentConfig.getSpec().getReplicas(), currentReplicas)) {\r\n            queue.put(true);\r\n        } else {\r\n            LOG.debug(\"Only {}/{} pods scheduled for DeploymentConfig: {} in namespace: {} seconds so waiting...\", deploymentConfig.getStatus().getReplicas(), deploymentConfig.getSpec().getReplicas(), deploymentConfig.getMetadata().getName(), namespace);\r\n        }\r\n    } catch (Throwable t) {\r\n        LOG.error(\"Error while waiting for Deployment to be scaled.\", t);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.Centroid.addLineSegments",
	"Comment": "adds the line segments defined by an array of coordinatesto the linear centroid accumulators.",
	"Method": "void addLineSegments(Coordinate[] pts){\r\n    double lineLen = 0.0;\r\n    for (int i = 0; i < pts.length - 1; i++) {\r\n        double segmentLen = pts[i].distance(pts[i + 1]);\r\n        if (segmentLen == 0.0)\r\n            continue;\r\n        lineLen += segmentLen;\r\n        double midx = (pts[i].x + pts[i + 1].x) / 2;\r\n        lineCentSum.x += segmentLen * midx;\r\n        double midy = (pts[i].y + pts[i + 1].y) / 2;\r\n        lineCentSum.y += segmentLen * midy;\r\n    }\r\n    totalLength += lineLen;\r\n    if (lineLen == 0.0 && pts.length > 0)\r\n        addPoint(pts[0]);\r\n}"
}, {
	"Path": "com.jsql.util.ConnectionUtil.testConnection",
	"Comment": "check that the connection to the website is working correctly.it uses authentication defined by user, with fixed timeout, and warnuser in case of authentication detected.",
	"Method": "void testConnection(){\r\n    if (PreferencesUtil.isProcessingCookies()) {\r\n        CookieManager cookieManager = new CookieManager();\r\n        CookieHandler.setDefault(cookieManager);\r\n    } else {\r\n        CookieHandler.setDefault(null);\r\n    }\r\n    HttpURLConnection connection = null;\r\n    try {\r\n        if (AuthenticationUtil.isKerberos()) {\r\n            String loginKerberos = Pattern.compile(\"(?s)\\\\{.*\").matcher(StringUtils.join(Files.readAllLines(Paths.get(AuthenticationUtil.getPathKerberosLogin()), Charset.defaultCharset()), \"\")).replaceAll(\"\").trim();\r\n            SpnegoHttpURLConnection spnego = new SpnegoHttpURLConnection(loginKerberos);\r\n            connection = spnego.connect(new URL(ConnectionUtil.getUrlByUser()));\r\n        } else {\r\n            connection = (HttpURLConnection) new URL(// Ignore injection point during the test\r\n            ConnectionUtil.getUrlByUser().replace(InjectionModel.STAR, \"\")).openConnection();\r\n        }\r\n        connection.setReadTimeout(ConnectionUtil.getTimeout());\r\n        connection.setConnectTimeout(ConnectionUtil.getTimeout());\r\n        connection.setDefaultUseCaches(false);\r\n        connection.setRequestProperty(\"Pragma\", \"no-cache\");\r\n        connection.setRequestProperty(\"Cache-Control\", \"no-cache\");\r\n        connection.setRequestProperty(\"Expires\", \"-1\");\r\n        ConnectionUtil.fixJcifsTimeout(connection);\r\n        for (SimpleEntry<String, String> header : ParameterUtil.getHeader()) {\r\n            HeaderUtil.sanitizeHeaders(connection, header);\r\n        }\r\n        HeaderUtil.checkResponseHeader(connection, ConnectionUtil.getUrlByUser().replace(InjectionModel.STAR, \"\"));\r\n    } catch (Exception e) {\r\n        String message = Optional.ofNullable(e.getMessage()).orElse(\"\");\r\n        throw new InjectionFailureException(\"Connection failed: \" + message.replace(e.getClass().getName() + \": \", \"\"), e);\r\n    }\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct7.projectE",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the fifth slot value.",
	"Method": "Maybe<E> projectE(){\r\n    return project()._5();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct7.projectF",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the sixth slot value.",
	"Method": "Maybe<F> projectF(){\r\n    return project()._6();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct7.projectC",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the third slot value.",
	"Method": "Maybe<C> projectC(){\r\n    return project()._3();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct7.projectD",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the fourth slot value.",
	"Method": "Maybe<D> projectD(){\r\n    return project()._4();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct7.projectA",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the first slot value.",
	"Method": "Maybe<A> projectA(){\r\n    return project()._1();\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.RobustLineIntersectionTest.testCentralEndpointHeuristicFailure",
	"Comment": "following cases were failures when using the centralendpointintersector heuristic.\tthis is because one segment lies at a significant angle to the other,\twith only one endpoint is close to the other segment.\tthe ce heuristic chose the wrong endpoint to return.\tthe fix is to use a new heuristic which out of the 4 endpoints\tchooses the one which is closest to the other segment.\tthis works in all known failure cases.",
	"Method": "void testCentralEndpointHeuristicFailure(){\r\n    checkIntersection(\"LINESTRING (163.81867067 -211.31840378, 165.9174252 -214.1665075)\", \"LINESTRING (2.84139601 -57.95412726, 469.59990601 -502.63851732)\", 1, \"POINT (163.81867067 -211.31840378)\", 0);\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct7.projectB",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the second slot value.",
	"Method": "Maybe<B> projectB(){\r\n    return project()._2();\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.requests.restaction.order.OrderAction.getSelectedPosition",
	"Comment": "the currently selected positionthat is in focus for all modification operations of this orderaction instance",
	"Method": "int getSelectedPosition(){\r\n    return selectedPosition;\r\n}"
}, {
	"Path": "com.jdon.util.jdom.XMLProperties.getChildrenProperties",
	"Comment": "return all children property names of a parent property as a string\tarray, or an empty array if the if there are no children. for example,\tgiven the properties x.y.a, x.y.b, and x.y.c,\tthen the child properties of x.y are a, b, and\tc.",
	"Method": "String[] getChildrenProperties(String parent){\r\n    String[] propName = parsePropertyName(parent);\r\n    Element element = doc.getRootElement();\r\n    for (int i = 0; i < propName.length; i++) {\r\n        element = element.getChild(propName[i]);\r\n        if (element == null) {\r\n            return new String[] {};\r\n        }\r\n    }\r\n    List children = element.getChildren();\r\n    int childCount = children.size();\r\n    String[] childrenNames = new String[childCount];\r\n    for (int i = 0; i < childCount; i++) {\r\n        childrenNames[i] = ((Element) children.get(i)).getName();\r\n    }\r\n    return childrenNames;\r\n}"
}, {
	"Path": "com.jsql.view.swing.table.AdjusterTableColumn.setColumnHeaderIncluded",
	"Comment": "indicates whether to include the header in the width calculation",
	"Method": "void setColumnHeaderIncluded(boolean isColumnHeaderIncluded){\r\n    this.isColumnHeaderIncluded = isColumnHeaderIncluded;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.LineIntersector.setPrecisionModel",
	"Comment": "force computed intersection to be rounded to a given precision model.no getter is provided, because the precision model is not required to be specified.",
	"Method": "void setPrecisionModel(PrecisionModel precisionModel){\r\n    this.precisionModel = precisionModel;\r\n}"
}, {
	"Path": "org.locationtech.jts.linearref.LinearLocation.setToEnd",
	"Comment": "sets the value of this location torefer to the end of a linear geometry.",
	"Method": "void setToEnd(Geometry linear){\r\n    componentIndex = linear.getNumGeometries() - 1;\r\n    LineString lastLine = (LineString) linear.getGeometryN(componentIndex);\r\n    segmentIndex = lastLine.getNumPoints() - 1;\r\n    segmentFraction = 1.0;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.distance3d.PlanarPolygon3D.averagePoint",
	"Comment": "computes a point which is the average of all coordinates\tin a sequence.\tif the sequence lies in a single plane,\tthe computed point also lies in the plane.",
	"Method": "Coordinate averagePoint(CoordinateSequence seq){\r\n    Coordinate a = new Coordinate(0, 0, 0);\r\n    int n = seq.size();\r\n    for (int i = 0; i < n; i++) {\r\n        a.x += seq.getOrdinate(i, CoordinateSequence.X);\r\n        a.y += seq.getOrdinate(i, CoordinateSequence.Y);\r\n        a.setZ(a.getZ() + seq.getOrdinate(i, CoordinateSequence.Z));\r\n    }\r\n    a.x /= n;\r\n    a.y /= n;\r\n    a.setZ(a.getZ() / n);\r\n    return a;\r\n}"
}, {
	"Path": "com.android.launcher3.DeviceProfile.getWorkspacePadding",
	"Comment": "returns the workspace padding in the specified orientation",
	"Method": "Rect getWorkspacePadding(boolean isLayoutRtl){\r\n    Rect searchBarBounds = getSearchBarBounds(isLayoutRtl);\r\n    Rect padding = new Rect();\r\n    if (isLandscape && transposeLayoutWithOrientation) {\r\n        if (isLayoutRtl) {\r\n            padding.set(hotseatBarHeightPx, edgeMarginPx, searchBarBounds.width(), edgeMarginPx);\r\n        } else {\r\n            padding.set(searchBarBounds.width(), edgeMarginPx, hotseatBarHeightPx, edgeMarginPx);\r\n        }\r\n    } else {\r\n        if (isTablet) {\r\n            float gapScale = 1f + (dragViewScale - 1f) / 2f;\r\n            int width = getCurrentWidth();\r\n            int height = getCurrentHeight();\r\n            int paddingTop = searchBarBounds.bottom;\r\n            int paddingBottom = hotseatBarHeightPx + pageIndicatorHeightPx;\r\n            int availableWidth = Math.max(0, width - (int) ((inv.numColumns * cellWidthPx) + (inv.numColumns * gapScale * cellWidthPx)));\r\n            int availableHeight = Math.max(0, height - paddingTop - paddingBottom - (int) (2 * inv.numRows * cellHeightPx));\r\n            padding.set(availableWidth / 2, paddingTop + availableHeight / 2, availableWidth / 2, paddingBottom + availableHeight / 2);\r\n        } else {\r\n            padding.set(desiredWorkspaceLeftRightMarginPx - defaultWidgetPadding.left, searchBarBounds.bottom, desiredWorkspaceLeftRightMarginPx - defaultWidgetPadding.right, hotseatBarHeightPx + pageIndicatorHeightPx);\r\n        }\r\n    }\r\n    return padding;\r\n}"
}, {
	"Path": "org.zeromq.ZContext.destroy",
	"Comment": "destructor. call this to gracefully terminate context and close any managed 0mq sockets",
	"Method": "void destroy(){\r\n    ListIterator<Socket> itr = sockets.listIterator();\r\n    while (itr.hasNext()) {\r\n        destroySocket(itr.next());\r\n    }\r\n    sockets.clear();\r\n    if (isMain() && context != null)\r\n        context.term();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct7.projectG",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the seventh slot value.",
	"Method": "Maybe<G> projectG(){\r\n    return project()._7();\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifInterface.getThumbnail",
	"Comment": "returns the thumbnail if it is jpeg compressed, or null if none exists.",
	"Method": "byte[] getThumbnail(){\r\n    return mData.getCompressedThumbnail();\r\n}"
}, {
	"Path": "org.kse.utilities.history.KeyStoreState.append",
	"Comment": "append a state subsequently to this one and set it to be the current\tstate.",
	"Method": "void append(KeyStoreState keyStoreState){\r\n    keyStoreState.previous = this;\r\n    this.next = keyStoreState;\r\n    keyStoreState.setAsCurrentState();\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherAppWidgetInfo.notifyWidgetSizeChanged",
	"Comment": "trigger an update callback to the widget to notify it that its size has changed.",
	"Method": "void notifyWidgetSizeChanged(Launcher launcher){\r\n    AppWidgetResizeFrame.updateWidgetSizeRanges(hostView, launcher, spanX, spanY);\r\n    mHasNotifiedInitialWidgetSizeChanged = true;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.Envelope.minExtent",
	"Comment": "gets the minimum extent of this envelope across both dimensions.",
	"Method": "double minExtent(){\r\n    if (isNull())\r\n        return 0.0;\r\n    double w = getWidth();\r\n    double h = getHeight();\r\n    if (w < h)\r\n        return w;\r\n    return h;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdgeTriangle.isBorder",
	"Comment": "tests whether this triangle is adjacent to the outside of the subdivision.",
	"Method": "boolean isBorder(boolean isBorder,int i){\r\n    return getAdjacentTriangleAcrossEdge(i) == null;\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isDateAfterToday",
	"Comment": "isdate returns true if string argument date forms a valid date and is after today.",
	"Method": "boolean isDateAfterToday(String date){\r\n    if (isEmpty(date))\r\n        return defaultEmptyOK;\r\n    int dateSlash1 = date.indexOf(\"/\");\r\n    int dateSlash2 = date.lastIndexOf(\"/\");\r\n    if (dateSlash1 <= 0)\r\n        return false;\r\n    java.util.Date passed = null;\r\n    if (dateSlash1 == dateSlash2) {\r\n        String month = date.substring(0, dateSlash1);\r\n        String day = \"28\";\r\n        String year = date.substring(dateSlash1 + 1);\r\n        if (!isDate(year, month, day))\r\n            return false;\r\n        try {\r\n            int monthInt = Integer.parseInt(month);\r\n            int yearInt = Integer.parseInt(year);\r\n            Calendar calendar = Calendar.getInstance();\r\n            calendar.set(yearInt, monthInt - 1, 0, 0, 0, 0);\r\n            calendar.add(Calendar.MONTH, 1);\r\n            passed = new java.util.Date(calendar.getTime().getTime());\r\n        } catch (Exception e) {\r\n            passed = null;\r\n        }\r\n    } else {\r\n        String month = date.substring(0, dateSlash1);\r\n        String day = date.substring(dateSlash1 + 1, dateSlash2);\r\n        String year = date.substring(dateSlash2 + 1);\r\n        if (!isDate(year, month, day))\r\n            return false;\r\n        passed = UtilDateTime.toDate(month, day, year, \"0\", \"0\", \"0\");\r\n    }\r\n    java.util.Date now = UtilDateTime.nowDate();\r\n    if (passed != null) {\r\n        return passed.after(now);\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.index.SimpleMCSweepLineIntersector.prepareEvents",
	"Comment": "because delete events have a link to their corresponding insert event,it is possible to compute exactly the range of events which must becompared to a given insert event object.",
	"Method": "void prepareEvents(){\r\n    Collections.sort(events);\r\n    for (int i = 0; i < events.size(); i++) {\r\n        SweepLineEvent ev = (SweepLineEvent) events.get(i);\r\n        if (ev.isDelete()) {\r\n            ev.getInsertEvent().setDeleteEventIndex(i);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.io.oracle.StaticMultiPolygonTest.testSingleMultiPolygonManyPointsManyHolesRoundTrip",
	"Comment": "round trip test for a single multipolygon with lotsa points",
	"Method": "void testSingleMultiPolygonManyPointsManyHolesRoundTrip(){\r\n    PolygonGenerator pgc = new PolygonGenerator();\r\n    pgc.setGeometryFactory(geometryFactory);\r\n    pgc.setGenerationAlgorithm(PolygonGenerator.BOX);\r\n    pgc.setNumberPoints(100);\r\n    pgc.setNumberHoles(100);\r\n    MultiGenerator pg = new MultiGenerator(pgc);\r\n    pg.setBoundingBox(new Envelope(0, 10, 0, 10));\r\n    pg.setNumberGeometries(3);\r\n    pg.setGeometryFactory(geometryFactory);\r\n    MultiPolygon pt = (MultiPolygon) pg.create();\r\n    OraWriter ow = new OraWriter();\r\n    STRUCT st = ow.write(pt, getConnection());\r\n    OraReader or = new OraReader();\r\n    MultiPolygon pt2 = (MultiPolygon) or.read(st);\r\n    assertTrue(\"The input MultiPolygon is not the same as the output MultiPolygon\", pt.equals(pt2));\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.FastNodingValidator.getErrorMessage",
	"Comment": "returns an error message indicating the segments containingthe intersection.",
	"Method": "String getErrorMessage(){\r\n    if (isValid)\r\n        return \"no intersections found\";\r\n    Coordinate[] intSegs = segInt.getIntersectionSegments();\r\n    return \"found non-noded intersection between \" + WKTWriter.toLineString(intSegs[0], intSegs[1]) + \" and \" + WKTWriter.toLineString(intSegs[2], intSegs[3]);\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.Envelope.distance",
	"Comment": "computes the distance between this and anotherenvelope.the distance between overlapping envelopes is 0.otherwise, thedistance is the euclidean distance between the closest points.",
	"Method": "double distance(Envelope env){\r\n    if (intersects(env))\r\n        return 0;\r\n    double dx = 0.0;\r\n    if (maxx < env.minx)\r\n        dx = env.minx - maxx;\r\n    else if (minx > env.maxx)\r\n        dx = minx - env.maxx;\r\n    double dy = 0.0;\r\n    if (maxy < env.miny)\r\n        dy = env.miny - maxy;\r\n    else if (miny > env.maxy)\r\n        dy = miny - env.maxy;\r\n    if (dx == 0.0)\r\n        return dy;\r\n    if (dy == 0.0)\r\n        return dx;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}"
}, {
	"Path": "com.jdon.util.jdom.DataUnformatFilter.reset",
	"Comment": "reset the filter so that it can be reused.\tthis method is especially useful if the filter failed with an exception\tthe last time through.",
	"Method": "void reset(){\r\n    state = SEEN_NOTHING;\r\n    stateStack = new Stack();\r\n    whitespace = new StringBuilder();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct4.diverge",
	"Comment": "diverge this coproduct by introducing another possible type that it could represent.",
	"Method": "CoProduct5<A, B, C, D, E, ? extends CoProduct5<A, B, C, D, E, ?>> diverge(){\r\n    return new CoProduct5<A, B, C, D, E, CoProduct5<A, B, C, D, E, ?>>() {\r\n        @Override\r\n        public <R> R match(Function<? super A, ? extends R> aFn, Function<? super B, ? extends R> bFn, Function<? super C, ? extends R> cFn, Function<? super D, ? extends R> dFn, Function<? super E, ? extends R> eFn) {\r\n            return CoProduct4.this.match(aFn, bFn, cFn, dFn);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct4.diverge",
	"Comment": "diverge this coproduct by introducing another possible type that it could represent.",
	"Method": "CoProduct5<A, B, C, D, E, ? extends CoProduct5<A, B, C, D, E, ?>> diverge(){\r\n    return CoProduct4.this.match(aFn, bFn, cFn, dFn);\r\n}"
}, {
	"Path": "com.android.launcher3.PagedView.isTouchPointInViewportWithBuffer",
	"Comment": "returns whether x and y originated within the buffered viewport",
	"Method": "boolean isTouchPointInViewportWithBuffer(int x,int y){\r\n    sTmpRect.set(mViewport.left - mViewport.width() / 2, mViewport.top, mViewport.right + mViewport.width() / 2, mViewport.bottom);\r\n    return sTmpRect.contains(x, y);\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.DirectedEdgeStar.computeLabelling",
	"Comment": "compute the labelling for all diredges in this star, as wellas the overall labelling",
	"Method": "void computeLabelling(GeometryGraph[] geom){\r\n    super.computeLabelling(geom);\r\n    label = new Label(Location.NONE);\r\n    for (Iterator it = iterator(); it.hasNext(); ) {\r\n        EdgeEnd ee = (EdgeEnd) it.next();\r\n        Edge e = ee.getEdge();\r\n        Label eLabel = e.getLabel();\r\n        for (int i = 0; i < 2; i++) {\r\n            int eLoc = eLabel.getLocation(i);\r\n            if (eLoc == Location.INTERIOR || eLoc == Location.BOUNDARY)\r\n                label.setLocation(i, Location.INTERIOR);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.PagedView.getNextPage",
	"Comment": "returns the index of page to be shown immediately afterwards.",
	"Method": "int getNextPage(){\r\n    return (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.CoordinateArrays.ptNotInList",
	"Comment": "finds a point in a list of points which is not contained in another list of points",
	"Method": "Coordinate ptNotInList(Coordinate[] testPts,Coordinate[] pts){\r\n    for (int i = 0; i < testPts.length; i++) {\r\n        Coordinate testPt = testPts[i];\r\n        if (CoordinateArrays.indexOf(testPt, pts) < 0)\r\n            return testPt;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.hlist.Tuple7.fill",
	"Comment": "given a value of type a, produced an instance of this tuple with each slot set to that value.",
	"Method": "Tuple7<A, A, A, A, A, A, A> fill(A a){\r\n    return tuple(a, a, a, a, a, a, a);\r\n}"
}, {
	"Path": "com.samskivert.mustache.Escapers.simple",
	"Comment": "returns an escaper that replaces a list of text sequences with canned replacements.",
	"Method": "Mustache.Escaper simple(String[] repls){\r\n    return new Mustache.Escaper() {\r\n        @Override\r\n        public String escape(String text) {\r\n            for (String[] escape : repls) {\r\n                text = text.replace(escape[0], escape[1]);\r\n            }\r\n            return text;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.samskivert.mustache.Escapers.simple",
	"Comment": "returns an escaper that replaces a list of text sequences with canned replacements.",
	"Method": "Mustache.Escaper simple(String[] repls){\r\n    for (String[] escape : repls) {\r\n        text = text.replace(escape[0], escape[1]);\r\n    }\r\n    return text;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.LineIntersector.getIntersectionNum",
	"Comment": "returns the number of intersection points found.this will be either 0, 1 or 2.",
	"Method": "int getIntersectionNum(){\r\n    return result;\r\n}"
}, {
	"Path": "com.jsql.util.GitUtil.getJSONObject",
	"Comment": "instanciate the jsonobject from json data if not already set.",
	"Method": "JSONObject getJSONObject(){\r\n    if (GitUtil.jsonObject == null) {\r\n        String json = ConnectionUtil.getSource(PropertiesUtil.getInstance().getProperties().getProperty(\"github.webservice.url\"));\r\n        try {\r\n            GitUtil.jsonObject = new JSONObject(json);\r\n        } catch (JSONException e) {\r\n            GitUtil.jsonObject = new JSONObject(\"{\\\"version\\\": \\\"0\\\", \\\"news\\\": []}\");\r\n            LOGGER.warn(\"Fetching JSON configuration from Github failed, check your connection or update jsql\", e);\r\n        }\r\n    }\r\n    return GitUtil.jsonObject;\r\n}"
}, {
	"Path": "org.kse.gui.about.SystemPropertiesTableModel.load",
	"Comment": "load the systempropertiestablemodel with system properties.",
	"Method": "void load(){\r\n    Properties sysProps = System.getProperties();\r\n    TreeMap<String, String> sortedSysProps = new TreeMap(new SystemPropertyComparator());\r\n    for (Enumeration<?> names = sysProps.propertyNames(); names.hasMoreElements(); ) {\r\n        String name = (String) names.nextElement();\r\n        String value = sysProps.getProperty(name);\r\n        if (name.equals(\"line.separator\")) {\r\n            value = convertLineSeperatorToBePrintable(value);\r\n        }\r\n        sortedSysProps.put(name, value);\r\n    }\r\n    data = new Object[sortedSysProps.size()][2];\r\n    int i = 0;\r\n    for (Iterator<Entry<String, String>> itrSorted = sortedSysProps.entrySet().iterator(); itrSorted.hasNext(); i++) {\r\n        Entry<String, String> property = itrSorted.next();\r\n        data[i][0] = property.getKey();\r\n        data[i][1] = property.getValue();\r\n    }\r\n    fireTableDataChanged();\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.Geometry.distance",
	"Comment": "returns the minimum distance between this geometry and another geometry.",
	"Method": "double distance(Geometry g){\r\n    return DistanceOp.distance(this, g);\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.util.GeometryEditor.setCopyUserData",
	"Comment": "sets whether the user data is copied to the edit result.only the object reference is copied.",
	"Method": "void setCopyUserData(boolean isUserDataCopied){\r\n    this.isUserDataCopied = isUserDataCopied;\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.Edge.updateIM",
	"Comment": "updates an im from the label for an edge.handles edges from both l and a geometries.",
	"Method": "void updateIM(Label label,IntersectionMatrix im){\r\n    im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);\r\n    if (label.isArea()) {\r\n        im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);\r\n        im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.IsSimpleOp.isSimplePolygonal",
	"Comment": "computes simplicity for polygonal geometries.polygonal geometries are simple if and only ifall of their component rings are simple.",
	"Method": "boolean isSimplePolygonal(Geometry geom){\r\n    List rings = LinearComponentExtracter.getLines(geom);\r\n    for (Iterator i = rings.iterator(); i.hasNext(); ) {\r\n        LinearRing ring = (LinearRing) i.next();\r\n        if (!isSimpleLinearGeometry(ring))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.ConformingDelaunayTriangulationBuilder.getSubdivision",
	"Comment": "gets the quadedgesubdivision which models the computed triangulation.",
	"Method": "QuadEdgeSubdivision getSubdivision(){\r\n    create();\r\n    return subdiv;\r\n}"
}, {
	"Path": "org.zeromq.ZFrame.recv",
	"Comment": "internal method to call recv on the socket. does not trap anyzmqexceptions but expects caling routine to handle them.",
	"Method": "byte[] recv(Socket socket,int flags){\r\n    try {\r\n        data = socket.recv(flags);\r\n        more = socket.hasReceiveMore();\r\n    } catch (ZMQException e) {\r\n        ZMQ.Error error = ZMQ.Error.findByCode(e.getErrorCode());\r\n        if (error == ZMQ.Error.ETERM || error == ZMQ.Error.ENOTSOCK) {\r\n            data = null;\r\n            more = false;\r\n        } else {\r\n            throw e;\r\n        }\r\n    }\r\n    return data;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.prep.AbstractPreparedPolygonContains.eval",
	"Comment": "evaluate the contains or covers relationship\tfor the given geometry.",
	"Method": "boolean eval(Geometry geom){\r\n    boolean isAllInTargetArea = isAllTestComponentsInTarget(geom);\r\n    if (!isAllInTargetArea)\r\n        return false;\r\n    if (requireSomePointInInterior && geom.getDimension() == 0) {\r\n        boolean isAnyInTargetInterior = isAnyTestComponentInTargetInterior(geom);\r\n        return isAnyInTargetInterior;\r\n    }\r\n    boolean properIntersectionImpliesNotContained = isProperIntersectionImpliesNotContainedSituation(geom);\r\n    findAndClassifyIntersections(geom);\r\n    if (properIntersectionImpliesNotContained && hasProperIntersection)\r\n        return false;\r\n    if (hasSegmentIntersection && !hasNonProperIntersection)\r\n        return false;\r\n    if (hasSegmentIntersection) {\r\n        return fullTopologicalPredicate(geom);\r\n    }\r\n    if (geom instanceof Polygonal) {\r\n        boolean isTargetInTestArea = isAnyTargetComponentInAreaTest(geom, prepPoly.getRepresentativePoints());\r\n        if (isTargetInTestArea)\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.jsql.view.swing.table.AdjusterTableColumn.installActions",
	"Comment": "install actions to give user control of certain functionality.",
	"Method": "void installActions(){\r\n    this.installColumnAction(true, true, \"adjustColumn\", \"control ADD\");\r\n    this.installColumnAction(false, true, \"adjustColumns\", \"control shift ADD\");\r\n    this.installColumnAction(true, false, \"restoreColumn\", \"control SUBTRACT\");\r\n    this.installColumnAction(false, false, \"restoreColumns\", \"control shift SUBTRACT\");\r\n    this.installToggleAction(true, false, \"toggleDynamic\", \"control MULTIPLY\");\r\n    this.installToggleAction(false, true, \"toggleLarger\", \"control DIVIDE\");\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.relate.EdgeEndBuilder.createEdgeEndForNext",
	"Comment": "create a stubedge for the edge after the intersection eicurr.the next intersection is providedin case it is the endpoint for the stub edge.otherwise, the next point from the parent edge will be the endpoint.eicurr will always be an edgeintersection, but einext may be null.",
	"Method": "void createEdgeEndForNext(Edge edge,List l,EdgeIntersection eiCurr,EdgeIntersection eiNext){\r\n    int iNext = eiCurr.segmentIndex + 1;\r\n    if (iNext >= edge.getNumPoints() && eiNext == null)\r\n        return;\r\n    Coordinate pNext = edge.getCoordinate(iNext);\r\n    if (eiNext != null && eiNext.segmentIndex == eiCurr.segmentIndex)\r\n        pNext = eiNext.coord;\r\n    EdgeEnd e = new EdgeEnd(edge, eiCurr.coord, pNext, new Label(edge.getLabel()));\r\n    l.add(e);\r\n}"
}, {
	"Path": "org.joda.money.Money.convertedTo",
	"Comment": "returns a copy of this monetary value converted into another currencyusing the specified conversion rate, with a rounding mode used to adjustthe decimal places in the result.this instance is immutable and unaffected by this method.",
	"Method": "Money convertedTo(CurrencyUnit currency,BigDecimal conversionMultipler,RoundingMode roundingMode){\r\n    return with(money.convertedTo(currency, conversionMultipler).withCurrencyScale(roundingMode));\r\n}"
}, {
	"Path": "com.android.launcher3.PagedView.mapPointFromViewToParent",
	"Comment": "convenience methods to map points from self to parent and vice versa",
	"Method": "float[] mapPointFromViewToParent(View v,float x,float y){\r\n    sTmpPoint[0] = x;\r\n    sTmpPoint[1] = y;\r\n    v.getMatrix().mapPoints(sTmpPoint);\r\n    sTmpPoint[0] += v.getLeft();\r\n    sTmpPoint[1] += v.getTop();\r\n    return sTmpPoint;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision.connect",
	"Comment": "creates a new quadedge connecting the destination of a to the origin of b,\tin such a way that all three have the same left face after the connection\tis complete. the quadedge is recorded in the edges list.",
	"Method": "QuadEdge connect(QuadEdge a,QuadEdge b){\r\n    QuadEdge q = QuadEdge.connect(a, b);\r\n    quadEdges.add(q);\r\n    return q;\r\n}"
}, {
	"Path": "com.android.launcher3.CellLayout.cellToCenterPoint",
	"Comment": "given a cell coordinate, return the point that represents the center of the cell",
	"Method": "void cellToCenterPoint(int cellX,int cellY,int[] result){\r\n    regionToCenterPoint(cellX, cellY, 1, 1, result);\r\n}"
}, {
	"Path": "com.jdon.aop.interceptor.StatefulInterceptor.invoke",
	"Comment": "check the pojoservice if implements statefulpojoservice using\tcomponentvisitor, we can get targetobjref from httpsession.",
	"Method": "Object invoke(MethodInvocation invocation){\r\n    ProxyMethodInvocation pmi = (ProxyMethodInvocation) invocation;\r\n    TargetMetaRequest targetMetaRequest = targetMetaRequestsHolder.getTargetMetaRequest();\r\n    TargetMetaDef targetMetaDef = targetMetaRequest.getTargetMetaDef();\r\n    if (targetMetaDef.isEJB())\r\n        return invocation.proceed();\r\n    if (!isStateful(targetMetaDef)) {\r\n        return invocation.proceed();\r\n    }\r\n    Debug.logVerbose(\"[JdonFramework] enter StatefulInterceptor\", module);\r\n    Object result = null;\r\n    try {\r\n        ComponentVisitor cm = targetMetaRequest.getComponentVisitor();\r\n        targetMetaRequest.setVisitableName(ComponentKeys.TARGETSERVICE_FACTORY);\r\n        Debug.logVerbose(ComponentKeys.TARGETSERVICE_FACTORY + \" in action (Stateful)\", module);\r\n        Object targetObjRef = cm.visit();\r\n        pmi.setThis(targetObjRef);\r\n        result = invocation.proceed();\r\n    } catch (Exception ex) {\r\n        Debug.logError(\"[JdonFramework]StatefulInterceptor error: \" + ex, module);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherClings.showMigrationCling",
	"Comment": "shows the migration cling.this flow is mutually exclusive with showfirstruncling, and only runs if this launcherpackage was not preinstalled and there exists a db to migrate from.",
	"Method": "void showMigrationCling(){\r\n    mIsVisible = true;\r\n    mLauncher.hideWorkspaceSearchAndHotseat();\r\n    ViewGroup root = (ViewGroup) mLauncher.findViewById(R.id.launcher);\r\n    View inflated = mInflater.inflate(R.layout.migration_cling, root);\r\n    inflated.findViewById(R.id.cling_dismiss_migration_copy_apps).setOnClickListener(this);\r\n    inflated.findViewById(R.id.cling_dismiss_migration_use_default).setOnClickListener(this);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.Polygonizer.setCheckRingsValid",
	"Comment": "allows disabling the valid ring checking, to optimize situations where invalid rings are not expected.the default is true.",
	"Method": "void setCheckRingsValid(boolean isCheckingRingsValid){\r\n    this.isCheckingRingsValid = isCheckingRingsValid;\r\n}"
}, {
	"Path": "org.joda.money.format.MoneyAmountStyle.withGroupingCharacter",
	"Comment": "returns a copy of this style with the specified grouping character.for english, this is a comma.",
	"Method": "MoneyAmountStyle withGroupingCharacter(Character groupingCharacter){\r\n    int groupingVal = (groupingCharacter == null ? -1 : groupingCharacter);\r\n    if (groupingVal == this.groupingCharacter) {\r\n        return this;\r\n    }\r\n    return new MoneyAmountStyle(zeroCharacter, positiveCharacter, negativeCharacter, decimalPointCharacter, groupingStyle, groupingVal, groupingSize, extendedGroupingSize, forceDecimalPoint, absValue);\r\n}"
}, {
	"Path": "com.jsql.util.ConnectionUtil.fixCustomRequestMethod",
	"Comment": "fix a wrong doing by java core developers on design of http method definition.compatible http methods are stored in an array but it cannot be modified in orderto define your own method, whereas method should be customizable.",
	"Method": "void fixCustomRequestMethod(HttpURLConnection connection,String customMethod){\r\n    try {\r\n        connection.setRequestMethod(customMethod);\r\n    } catch (final ProtocolException pe) {\r\n        IgnoreMessageException exceptionIgnored = new IgnoreMessageException(pe);\r\n        LOGGER.trace(exceptionIgnored, exceptionIgnored);\r\n        try {\r\n            final Class<?> httpURLConnectionClass = connection.getClass();\r\n            final Class<?> parentClass = httpURLConnectionClass.getSuperclass();\r\n            final Field methodField;\r\n            Field methods = parentClass.getDeclaredField(\"methods\");\r\n            methods.setAccessible(true);\r\n            Array.set(methods.get(connection), 1, customMethod);\r\n            if (parentClass == HttpsURLConnection.class) {\r\n                methodField = parentClass.getSuperclass().getDeclaredField(\"method\");\r\n            } else {\r\n                methodField = parentClass.getDeclaredField(\"method\");\r\n            }\r\n            methodField.setAccessible(true);\r\n            methodField.set(connection, customMethod);\r\n        } catch (Exception e) {\r\n            LOGGER.warn(\"Custom Request method definition failed, forcing method GET\", e);\r\n            connection.setRequestMethod(\"GET\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.DialogHelper.populateSigAlgs",
	"Comment": "populate a jcombobox with signature algorithms depending on the key pair type.",
	"Method": "void populateSigAlgs(KeyPairType keyPairType,PrivateKey privateKey,JComboBox<SignatureType> jcbSignatureAlgorithm){\r\n    List<SignatureType> sigAlgs;\r\n    switch(keyPairType) {\r\n        case RSA:\r\n            KeyInfo keyInfo = KeyPairUtil.getKeyInfo(privateKey);\r\n            sigAlgs = SignatureType.rsaSignatureTypes(keyInfo.getSize());\r\n            break;\r\n        case DSA:\r\n            sigAlgs = SignatureType.dsaSignatureTypes();\r\n            break;\r\n        case EC:\r\n        default:\r\n            sigAlgs = SignatureType.ecdsaSignatureTypes();\r\n    }\r\n    jcbSignatureAlgorithm.removeAllItems();\r\n    for (SignatureType sigAlg : sigAlgs) {\r\n        jcbSignatureAlgorithm.addItem(sigAlg);\r\n    }\r\n    if (sigAlgs.contains(SignatureType.SHA256_RSA)) {\r\n        jcbSignatureAlgorithm.setSelectedItem(SignatureType.SHA256_RSA);\r\n    } else if (sigAlgs.contains(SignatureType.SHA256_ECDSA)) {\r\n        jcbSignatureAlgorithm.setSelectedItem(SignatureType.SHA256_ECDSA);\r\n    } else if (sigAlgs.contains(SignatureType.SHA256_DSA)) {\r\n        jcbSignatureAlgorithm.setSelectedItem(SignatureType.SHA256_DSA);\r\n    } else {\r\n        jcbSignatureAlgorithm.setSelectedIndex(0);\r\n    }\r\n}"
}, {
	"Path": "net.dv8tion.jda.webhook.WebhookMessageBuilder.append",
	"Comment": "appends to the currently set content of the resulting message.",
	"Method": "WebhookMessageBuilder append(String content){\r\n    Checks.notNull(content, \"Content\");\r\n    Checks.check(this.content.length() + content.length() <= 2000, \"Content may not exceed 2000 characters!\");\r\n    this.content.append(content);\r\n    return this;\r\n}"
}, {
	"Path": "org.kse.crypto.x509.X509CertUtil.matchCertificate",
	"Comment": "check whether or not a trusted certificate in the supplied keystore\tmatches the supplied x.509 certificate.",
	"Method": "String matchCertificate(KeyStore keyStore,X509Certificate cert){\r\n    try {\r\n        for (Enumeration<String> aliases = keyStore.aliases(); aliases.hasMoreElements(); ) {\r\n            String alias = aliases.nextElement();\r\n            if (keyStore.isCertificateEntry(alias)) {\r\n                X509Certificate compCert = X509CertUtil.convertCertificate(keyStore.getCertificate(alias));\r\n                if (cert.equals(compCert)) {\r\n                    return alias;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    } catch (KeyStoreException ex) {\r\n        throw new CryptoException(res.getString(\"NoMatchCertificate.exception.message\"), ex);\r\n    }\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.DocumentReader.read",
	"Comment": "read and fill the buffer.this method will always fill the buffer unless the end of the document is reached.",
	"Method": "int read(int read,char[] cbuf,int read,char[] cbuf,int off,int len){\r\n    if (this.position < this.document.getLength()) {\r\n        int length = len;\r\n        if (this.position + length >= this.document.getLength()) {\r\n            length = this.document.getLength() - (int) this.position;\r\n        }\r\n        if (off + length >= cbuf.length) {\r\n            length = cbuf.length - off;\r\n        }\r\n        try {\r\n            String s = this.document.getText((int) this.position, length);\r\n            this.position += length;\r\n            for (int i = 0; i < length; i++) {\r\n                cbuf[off + i] = s.charAt(i);\r\n            }\r\n            return length;\r\n        } catch (BadLocationException e) {\r\n            IgnoreMessageException exceptionIgnored = new IgnoreMessageException(e);\r\n            LOGGER.trace(exceptionIgnored, exceptionIgnored);\r\n            return -1;\r\n        }\r\n    } else {\r\n        return -1;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.OffsetCurveSetBuilder.addPolygonRing",
	"Comment": "adds an offset curve for a polygon ring.the side and left and right topological location argumentsassume that the ring is oriented cw.if the ring is in the opposite orientation,the left and right locations must be interchanged and the side flipped.",
	"Method": "void addPolygonRing(Coordinate[] coord,double offsetDistance,int side,int cwLeftLoc,int cwRightLoc){\r\n    if (offsetDistance == 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE)\r\n        return;\r\n    int leftLoc = cwLeftLoc;\r\n    int rightLoc = cwRightLoc;\r\n    if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && Orientation.isCCW(coord)) {\r\n        leftLoc = cwRightLoc;\r\n        rightLoc = cwLeftLoc;\r\n        side = Position.opposite(side);\r\n    }\r\n    Coordinate[] curve = curveBuilder.getRingCurve(coord, side, offsetDistance);\r\n    addCurve(curve, leftLoc, rightLoc);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.distance.DistanceOp.nearestPoints",
	"Comment": "report the coordinates of the nearest points in the input geometries.the points are presented in the same order as the input geometries.",
	"Method": "Coordinate[] nearestPoints(Geometry g0,Geometry g1,Coordinate[] nearestPoints){\r\n    computeMinDistance();\r\n    Coordinate[] nearestPts = new Coordinate[] { minDistanceLocation[0].getCoordinate(), minDistanceLocation[1].getCoordinate() };\r\n    return nearestPts;\r\n}"
}, {
	"Path": "org.kse.crypto.ecc.EccUtil.findLongestCurveName",
	"Comment": "finds the longest curve name in all curves that are provided by bc.",
	"Method": "String findLongestCurveName(){\r\n    String longestCurveName = \"\";\r\n    for (CurveSet curveSet : CurveSet.values()) {\r\n        List<String> curveNames = curveSet.getAllCurveNames();\r\n        for (String curveName : curveNames) {\r\n            if (curveName.length() > longestCurveName.length()) {\r\n                longestCurveName = curveName;\r\n            }\r\n        }\r\n    }\r\n    return longestCurveName;\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.PlanarGraph.findEdgeInSameDirection",
	"Comment": "returns the edge which starts at p0 and whose first segment isparallel to p1",
	"Method": "Edge findEdgeInSameDirection(Coordinate p0,Coordinate p1){\r\n    for (int i = 0; i < edges.size(); i++) {\r\n        Edge e = (Edge) edges.get(i);\r\n        Coordinate[] eCoord = e.getCoordinates();\r\n        if (matchInSameDirection(p0, p1, eCoord[0], eCoord[1]))\r\n            return e;\r\n        if (matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2]))\r\n            return e;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.kse.version.JavaVersion.isAtLeast",
	"Comment": "compares version of the current jre with the passed version.",
	"Method": "boolean isAtLeast(JavaVersion javaVersion){\r\n    return compareTo(javaVersion) >= 0;\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.shortcutExists",
	"Comment": "returns true if the shortcuts already exists on the workspace. this must be called afterthe workspace has been loaded. we identify a shortcut by its intent.",
	"Method": "boolean shortcutExists(Context context,Intent intent,UserHandleCompat user){\r\n    assertWorkspaceLoaded();\r\n    final String intentWithPkg, intentWithoutPkg;\r\n    if (intent.getComponent() != null) {\r\n        String packageName = intent.getComponent().getPackageName();\r\n        if (intent.getPackage() != null) {\r\n            intentWithPkg = intent.toUri(0);\r\n            intentWithoutPkg = new Intent(intent).setPackage(null).toUri(0);\r\n        } else {\r\n            intentWithPkg = new Intent(intent).setPackage(packageName).toUri(0);\r\n            intentWithoutPkg = intent.toUri(0);\r\n        }\r\n    } else {\r\n        intentWithPkg = intent.toUri(0);\r\n        intentWithoutPkg = intent.toUri(0);\r\n    }\r\n    synchronized (sBgLock) {\r\n        for (ItemInfo item : sBgItemsIdMap) {\r\n            if (item instanceof ShortcutInfo) {\r\n                ShortcutInfo info = (ShortcutInfo) item;\r\n                Intent targetIntent = info.promisedIntent == null ? info.intent : info.promisedIntent;\r\n                if (targetIntent != null && info.user.equals(user)) {\r\n                    String s = targetIntent.toUri(0);\r\n                    if (intentWithPkg.equals(s) || intentWithoutPkg.equals(s)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.patch.Diff.hashCode",
	"Comment": "create a numeric hash value for a diff.this function is not used by dmp.",
	"Method": "int hashCode(){\r\n    final int prime = 31;\r\n    int result = this.operation == null ? 0 : this.operation.hashCode();\r\n    result += prime * (this.text == null ? 0 : this.text.hashCode());\r\n    return result;\r\n}"
}, {
	"Path": "org.locationtech.jts.index.bintree.NodeBase.addAllItemsFromOverlapping",
	"Comment": "adds items in the tree which potentially overlap the query intervalto the given collection.if the query interval is null, add all items in the tree.",
	"Method": "void addAllItemsFromOverlapping(Interval interval,Collection resultItems){\r\n    if (interval != null && !isSearchMatch(interval))\r\n        return;\r\n    resultItems.addAll(items);\r\n    if (subnode[0] != null)\r\n        subnode[0].addAllItemsFromOverlapping(interval, resultItems);\r\n    if (subnode[1] != null)\r\n        subnode[1].addAllItemsFromOverlapping(interval, resultItems);\r\n}"
}, {
	"Path": "net.dv8tion.jda.webhook.WebhookMessageBuilder.setContent",
	"Comment": "sets the content of the resulting message.this will override the previous content.",
	"Method": "WebhookMessageBuilder setContent(String content){\r\n    Checks.check(content == null || content.length() <= 2000, \"Content may not exceed 2000 characters!\");\r\n    if (content != null)\r\n        this.content.replace(0, content.length(), content);\r\n    else\r\n        this.content.setLength(0);\r\n    return this;\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.SimpleSegmentSetMutualIntersector.intersect",
	"Comment": "processes all of the segment pairs in the given segment stringsusing the given segmentintersector.",
	"Method": "void intersect(SegmentString ss0,SegmentString ss1,SegmentIntersector segInt){\r\n    Coordinate[] pts0 = ss0.getCoordinates();\r\n    Coordinate[] pts1 = ss1.getCoordinates();\r\n    for (int i0 = 0; i0 < pts0.length - 1; i0++) {\r\n        for (int i1 = 0; i1 < pts1.length - 1; i1++) {\r\n            segInt.processIntersections(ss0, i0, ss1, i1);\r\n            if (segInt.isDone())\r\n                return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.jsql.util.AuthenticationUtil.setAuthentication",
	"Comment": "apply jcifs or kerberos authentication to the jvm.in case of jcifs, which is the default connection processing, it also definesstandard timeout configuration.",
	"Method": "void setAuthentication(){\r\n    if (AuthenticationUtil.isKerberos) {\r\n        if (System.getProperty(\"java.protocol.handler.pkgs\") != null) {\r\n            System.setProperty(\"java.protocol.handler.pkgs\", System.getProperty(\"java.protocol.handler.pkgs\").replace(\"|jcifs\", \"\").replace(\"jcifs\", \"\"));\r\n        }\r\n        System.setProperty(\"java.security.krb5.conf\", AuthenticationUtil.pathKerberosKrb5);\r\n        System.setProperty(\"java.security.auth.login.config\", AuthenticationUtil.pathKerberosLogin);\r\n        System.setProperty(\"spnego.krb5.conf\", AuthenticationUtil.pathKerberosKrb5);\r\n        System.setProperty(\"spnego.login.conf\", AuthenticationUtil.pathKerberosLogin);\r\n    } else {\r\n        System.setProperty(\"java.protocol.handler.pkgs\", \"\");\r\n        System.setProperty(\"java.security.krb5.conf\", \"\");\r\n        System.setProperty(\"java.security.auth.login.config\", \"\");\r\n        System.setProperty(\"spnego.krb5.conf\", \"\");\r\n        System.setProperty(\"spnego.login.conf\", \"\");\r\n        System.setProperty(\"jcifs.smb.client.responseTimeout\", ConnectionUtil.getTimeout().toString());\r\n        System.setProperty(\"jcifs.smb.client.soTimeout\", ConnectionUtil.getTimeout().toString());\r\n        jcifs.Config.setProperty(\"jcifs.smb.client.responseTimeout\", ConnectionUtil.getTimeout().toString());\r\n        jcifs.Config.setProperty(\"jcifs.smb.client.soTimeout\", ConnectionUtil.getTimeout().toString());\r\n        jcifs.Config.registerSmbURLHandler();\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.compat.BaseAlphabeticIndex.getBucketIndex",
	"Comment": "returns the index of the bucket in which the given string should appear.",
	"Method": "int getBucketIndex(String s,int getBucketIndex,String s){\r\n    if (s.isEmpty()) {\r\n        return UNKNOWN_BUCKET_INDEX;\r\n    }\r\n    int index = BUCKETS.indexOf(s.substring(0, 1).toUpperCase());\r\n    if (index != -1) {\r\n        return index;\r\n    }\r\n    return UNKNOWN_BUCKET_INDEX;\r\n}"
}, {
	"Path": "org.locationtech.jtstest.util.StringUtil.replaceFirst",
	"Comment": "returns original with the first occurrenc of oldsubstring replaced by newsubstring",
	"Method": "String replaceFirst(String original,String oldSubstring,String newSubstring){\r\n    return replace(original, oldSubstring, newSubstring, false);\r\n}"
}, {
	"Path": "org.joda.money.Money.multipliedBy",
	"Comment": "returns a copy of this monetary value multiplied by the specified value.this takes this amount and multiplies it by the specified value.this instance is immutable and unaffected by this method.",
	"Method": "Money multipliedBy(BigDecimal valueToMultiplyBy,RoundingMode roundingMode,Money multipliedBy,double valueToMultiplyBy,RoundingMode roundingMode,Money multipliedBy,long valueToMultiplyBy){\r\n    return with(money.multipliedBy(valueToMultiplyBy));\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.BufferBuilder.insertUniqueEdge",
	"Comment": "inserted edges are checked to see if an identical edge already exists.if so, the edge is not inserted, but its label is mergedwith the existing edge.",
	"Method": "void insertUniqueEdge(Edge e){\r\n    Edge existingEdge = edgeList.findEqualEdge(e);\r\n    if (existingEdge != null) {\r\n        Label existingLabel = existingEdge.getLabel();\r\n        Label labelToMerge = e.getLabel();\r\n        if (!existingEdge.isPointwiseEqual(e)) {\r\n            labelToMerge = new Label(e.getLabel());\r\n            labelToMerge.flip();\r\n        }\r\n        existingLabel.merge(labelToMerge);\r\n        int mergeDelta = depthDelta(labelToMerge);\r\n        int existingDelta = existingEdge.getDepthDelta();\r\n        int newDelta = existingDelta + mergeDelta;\r\n        existingEdge.setDepthDelta(newDelta);\r\n    } else {\r\n        edgeList.add(e);\r\n        e.setDepthDelta(depthDelta(e.getLabel()));\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdge.equalsOriented",
	"Comment": "tests if this quadedge and another have the same line segment geometrywith the same orientation.",
	"Method": "boolean equalsOriented(QuadEdge qe){\r\n    if (orig().getCoordinate().equals2D(qe.orig().getCoordinate()) && dest().getCoordinate().equals2D(qe.dest().getCoordinate()))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.locationtech.jts.io.gml2.StaticMultiPolygonTest.testSingleMultiPolygonManyPointsManyHolesRoundTrip",
	"Comment": "round trip test for a single multipolygon with lots of points",
	"Method": "void testSingleMultiPolygonManyPointsManyHolesRoundTrip(){\r\n    PolygonGenerator pgc = new PolygonGenerator();\r\n    pgc.setGeometryFactory(geometryFactory);\r\n    pgc.setGenerationAlgorithm(PolygonGenerator.BOX);\r\n    pgc.setNumberPoints(100);\r\n    pgc.setNumberHoles(100);\r\n    MultiGenerator pg = new MultiGenerator(pgc);\r\n    pg.setBoundingBox(new Envelope(0, 10, 0, 10));\r\n    pg.setNumberGeometries(3);\r\n    pg.setGeometryFactory(geometryFactory);\r\n    MultiPolygon pt = (MultiPolygon) pg.create();\r\n    checkRoundTrip(pt);\r\n}"
}, {
	"Path": "org.locationtech.jtstest.util.StringUtil.toCommaDelimitedString",
	"Comment": "returns the elements of c separated by commas. c must not be empty.",
	"Method": "String toCommaDelimitedString(Collection c){\r\n    if (c.isEmpty()) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    StringBuffer result = new StringBuffer();\r\n    for (Iterator i = c.iterator(); i.hasNext(); ) {\r\n        Object o = i.next();\r\n        result.append(\", \" + o.toString());\r\n    }\r\n    return result.substring(1);\r\n}"
}, {
	"Path": "com.jdon.servicelocator.ejb.ServiceLocator.getLocalHome",
	"Comment": "will get the ejb local home factory. clients need to cast to the type of\tejbhome they desire",
	"Method": "EJBLocalHome getLocalHome(String jndiHomeName){\r\n    EJBLocalHome home = null;\r\n    try {\r\n        home = (EJBLocalHome) ic.lookup(jndiHomeName);\r\n    } catch (NamingException ne) {\r\n        throw new ServiceLocatorException(ne);\r\n    } catch (Exception e) {\r\n        throw new ServiceLocatorException(e);\r\n    }\r\n    return home;\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.SegmentNodeList.findCollapsesFromInsertedNodes",
	"Comment": "adds nodes for any collapsed edge pairs caused by inserted nodescollapsed edge pairs occur when the same coordinate is inserted as a nodeboth before and after an existing edge vertex.to provide the correct fully noded semantics,the vertex must be added as a node as well.",
	"Method": "void findCollapsesFromInsertedNodes(List collapsedVertexIndexes){\r\n    int[] collapsedVertexIndex = new int[1];\r\n    Iterator it = iterator();\r\n    SegmentNode eiPrev = (SegmentNode) it.next();\r\n    while (it.hasNext()) {\r\n        SegmentNode ei = (SegmentNode) it.next();\r\n        boolean isCollapsed = findCollapseIndex(eiPrev, ei, collapsedVertexIndex);\r\n        if (isCollapsed)\r\n            collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0]));\r\n        eiPrev = ei;\r\n    }\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.importexport.DImportKeyPairPkcs8.getPrivateKey",
	"Comment": "get the private part of the key pair chosen by the user for import.",
	"Method": "PrivateKey getPrivateKey(){\r\n    return privateKey;\r\n}"
}, {
	"Path": "cn.jpush.api.JPushClient.createMonthlySchedule",
	"Comment": "create a monthly schedule push with a custom frequency at the appointed days.",
	"Method": "ScheduleResult createMonthlySchedule(String name,String start,String end,String time,String[] points,PushPayload push,ScheduleResult createMonthlySchedule,String name,String start,String end,String time,int frequency,String[] points,PushPayload push){\r\n    Preconditions.checkArgument(null != points && points.length > 0, \"The points must not be empty.\");\r\n    return createPeriodicalSchedule(name, start, end, time, TimeUnit.MONTH, frequency, points, push);\r\n}"
}, {
	"Path": "org.kse.crypto.keystore.KeyStoreUtil.containsKey",
	"Comment": "does the supplied keystore contain any key entries? ie any entries that\tcontain a key with no certificate chain.",
	"Method": "boolean containsKey(KeyStore keyStore){\r\n    try {\r\n        Enumeration<String> aliases = keyStore.aliases();\r\n        while (aliases.hasMoreElements()) {\r\n            String alias = aliases.nextElement();\r\n            if (isKeyEntry(alias, keyStore)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    } catch (KeyStoreException ex) {\r\n        throw new CryptoException(res.getString(\"NoCheckKeyStoreKeys.exception.message\"), ex);\r\n    }\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.hlist.Tuple4.fill",
	"Comment": "given a value of type a, produced an instance of this tuple with each slot set to that value.",
	"Method": "Tuple4<A, A, A, A> fill(A a){\r\n    return tuple(a, a, a, a);\r\n}"
}, {
	"Path": "com.jdon.persistence.hibernate.util.ThreadLocalSessionProvider.getFactory",
	"Comment": "gets the factory attribute of the basesessionprovider object",
	"Method": "SessionFactory getFactory(){\r\n    return _factory;\r\n}"
}, {
	"Path": "org.joda.money.format.MoneyParseContext.isComplete",
	"Comment": "checks if the context contains a currency and amount suitable for creatinga monetary value.",
	"Method": "boolean isComplete(){\r\n    return currency != null && amount != null;\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.daysInFebruary",
	"Comment": "given integer argument year, returns number of days in february of that year.",
	"Method": "int daysInFebruary(int year){\r\n    return (((year % 4 == 0) && ((!(year % 100 == 0)) || (year % 400 == 0))) ? 29 : 28);\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testrunner.TestReader.parseResultMatcher",
	"Comment": "parses an optional resultmatcher element. \t\tthe default is to leave this unspecified .",
	"Method": "ResultMatcher parseResultMatcher(Element runElement){\r\n    Element goElement = runElement.getChild(TAG_resultMatcher);\r\n    if (goElement == null) {\r\n        return null;\r\n    }\r\n    String goClass = goElement.getTextTrim();\r\n    ResultMatcher resultMatcher = (ResultMatcher) getInstance(goClass, ResultMatcher.class);\r\n    if (resultMatcher == null) {\r\n        throw new TestParseException(\"Could not create instance of ResultMatcher from class \" + goClass);\r\n    }\r\n    return resultMatcher;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.MessageBuilder.setContent",
	"Comment": "sets the content of the resulting messagethis will replace already added content.",
	"Method": "MessageBuilder setContent(String content){\r\n    if (content == null) {\r\n        builder.setLength(0);\r\n    } else {\r\n        Checks.check(content.length() <= Message.MAX_CONTENT_LENGTH, \"Content length may not exceed %d!\", Message.MAX_CONTENT_LENGTH);\r\n        final int newLength = Math.max(builder.length(), content.length());\r\n        builder.replace(0, newLength, content);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.joda.money.Money.plusMinor",
	"Comment": "returns a copy of this monetary value with the amount in minor units added.this adds an amount in minor units.for example, usd 23.45 plus 138 gives usd 24.83.this instance is immutable and unaffected by this method.",
	"Method": "Money plusMinor(long amountToAdd){\r\n    return with(money.plusMinor(amountToAdd));\r\n}"
}, {
	"Path": "com.jsql.view.swing.table.FixedColumnTable.fixColumnSize",
	"Comment": "specify the number of columns to be fixed and the scroll pane containing the table.",
	"Method": "void fixColumnSize(int fixedColumns,JScrollPane scrollPane){\r\n    this.scrollPane = scrollPane;\r\n    this.mainTable = (JTable) scrollPane.getViewport().getView();\r\n    this.mainTable.setAutoCreateColumnsFromModel(false);\r\n    this.mainTable.addPropertyChangeListener(this);\r\n    this.fixedTable = new JTable() {\r\n        @Override\r\n        public boolean isCellEditable(int row, int column) {\r\n            return false;\r\n        }\r\n    };\r\n    this.fixedTable.setAutoCreateColumnsFromModel(false);\r\n    final DefaultTableModel modelFixedTable = new DefaultTableModel() {\r\n        @Override\r\n        public int getColumnCount() {\r\n            return 2;\r\n        }\r\n        @Override\r\n        public boolean isCellEditable(int row, int col) {\r\n            return false;\r\n        }\r\n        @Override\r\n        public int getRowCount() {\r\n            return FixedColumnTable.this.mainTable.getRowCount();\r\n        }\r\n        @Override\r\n        public Class<?> getColumnClass(int colNum) {\r\n            Class<?> columnClass;\r\n            if (colNum == 0) {\r\n                columnClass = String.class;\r\n            } else {\r\n                columnClass = super.getColumnClass(colNum);\r\n            }\r\n            return columnClass;\r\n        }\r\n    };\r\n    this.fixedTable.setModel(modelFixedTable);\r\n    this.fixedTable.setSelectionModel(this.mainTable.getSelectionModel());\r\n    this.fixedTable.setRowHeight(20);\r\n    this.fixedTable.setFocusable(false);\r\n    this.fixedTable.getTableHeader().setReorderingAllowed(false);\r\n    this.fixedTable.setGridColor(Color.LIGHT_GRAY);\r\n    this.fixedTable.getTableHeader().setDefaultRenderer(new RowHeaderRenderer() {\r\n        @Override\r\n        public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\r\n            JComponent label = (JComponent) super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\r\n            label.setBorder(BorderFactory.createMatteBorder(1, 0, 1, 1, Color.LIGHT_GRAY));\r\n            return label;\r\n        }\r\n    });\r\n    TableColumnModel columnModel = this.mainTable.getColumnModel();\r\n    for (int i = 0; i < fixedColumns; i++) {\r\n        TableColumn column = columnModel.getColumn(i);\r\n        column.setMinWidth(0);\r\n        column.setMaxWidth(0);\r\n        this.fixedTable.getColumnModel().addColumn(new TableColumn(i));\r\n    }\r\n    this.fixedTable.getColumnModel().getColumn(0).setCellRenderer(new RowHeaderRenderer());\r\n    this.fixedTable.getColumnModel().getColumn(0).setResizable(false);\r\n    this.fixedTable.getColumnModel().getColumn(0).setPreferredWidth(38);\r\n    this.fixedTable.getColumnModel().getColumn(1).setCellRenderer(new RowHeaderRenderer());\r\n    this.fixedTable.getColumnModel().getColumn(1).setResizable(false);\r\n    this.fixedTable.getColumnModel().getColumn(1).setPreferredWidth(38);\r\n    this.mainTable.getRowSorter().addRowSorterListener(rowSorterEvent -> {\r\n        modelFixedTable.fireTableDataChanged();\r\n        for (int i = 0; i < FixedColumnTable.this.mainTable.getRowCount(); i++) {\r\n            FixedColumnTable.this.fixedTable.setValueAt(FixedColumnTable.this.mainTable.getValueAt(i, 0), i, 0);\r\n            FixedColumnTable.this.fixedTable.setValueAt(FixedColumnTable.this.mainTable.getValueAt(i, 1), i, 1);\r\n        }\r\n    });\r\n    this.mainTable.getSelectionModel().addListSelectionListener(listSelectionEvent -> modelFixedTable.fireTableRowsUpdated(0, modelFixedTable.getRowCount() - 1));\r\n    for (int i = 0; i < this.mainTable.getRowCount(); i++) {\r\n        this.fixedTable.setValueAt(this.mainTable.getValueAt(i, 0), i, 0);\r\n        this.fixedTable.setValueAt(this.mainTable.getValueAt(i, 1), i, 1);\r\n    }\r\n    this.fixedTable.setPreferredScrollableViewportSize(this.fixedTable.getPreferredSize());\r\n    scrollPane.setRowHeaderView(this.fixedTable);\r\n    scrollPane.setCorner(ScrollPaneConstants.UPPER_LEFT_CORNER, this.fixedTable.getTableHeader());\r\n    scrollPane.getRowHeader().addChangeListener(this);\r\n}"
}, {
	"Path": "com.jsql.view.swing.table.FixedColumnTable.fixColumnSize",
	"Comment": "specify the number of columns to be fixed and the scroll pane containing the table.",
	"Method": "void fixColumnSize(int fixedColumns,JScrollPane scrollPane){\r\n    return false;\r\n}"
}, {
	"Path": "com.jsql.view.swing.table.FixedColumnTable.fixColumnSize",
	"Comment": "specify the number of columns to be fixed and the scroll pane containing the table.",
	"Method": "void fixColumnSize(int fixedColumns,JScrollPane scrollPane){\r\n    return 2;\r\n}"
}, {
	"Path": "com.jsql.view.swing.table.FixedColumnTable.fixColumnSize",
	"Comment": "specify the number of columns to be fixed and the scroll pane containing the table.",
	"Method": "void fixColumnSize(int fixedColumns,JScrollPane scrollPane){\r\n    return false;\r\n}"
}, {
	"Path": "com.jsql.view.swing.table.FixedColumnTable.fixColumnSize",
	"Comment": "specify the number of columns to be fixed and the scroll pane containing the table.",
	"Method": "void fixColumnSize(int fixedColumns,JScrollPane scrollPane){\r\n    return FixedColumnTable.this.mainTable.getRowCount();\r\n}"
}, {
	"Path": "com.jsql.view.swing.table.FixedColumnTable.fixColumnSize",
	"Comment": "specify the number of columns to be fixed and the scroll pane containing the table.",
	"Method": "void fixColumnSize(int fixedColumns,JScrollPane scrollPane){\r\n    Class<?> columnClass;\r\n    if (colNum == 0) {\r\n        columnClass = String.class;\r\n    } else {\r\n        columnClass = super.getColumnClass(colNum);\r\n    }\r\n    return columnClass;\r\n}"
}, {
	"Path": "com.jsql.view.swing.table.FixedColumnTable.fixColumnSize",
	"Comment": "specify the number of columns to be fixed and the scroll pane containing the table.",
	"Method": "void fixColumnSize(int fixedColumns,JScrollPane scrollPane){\r\n    JComponent label = (JComponent) super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\r\n    label.setBorder(BorderFactory.createMatteBorder(1, 0, 1, 1, Color.LIGHT_GRAY));\r\n    return label;\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.DPreferences.getEnableImportCaReplyTrustCheck",
	"Comment": "get whether or not trust checks are enabled when importing ca replies.",
	"Method": "boolean getEnableImportCaReplyTrustCheck(){\r\n    return enableImportCaReplyTrustCheck;\r\n}"
}, {
	"Path": "com.jdon.controller.model.PageIterator.getPreviousElement",
	"Comment": "returns the previous element, or null if there are no more elements toreturn.",
	"Method": "Object getPreviousElement(){\r\n    Object element = null;\r\n    while (currentIndex >= startIndex && element == null) {\r\n        currentIndex--;\r\n        element = getElement();\r\n    }\r\n    return element;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.impl.CoordinateArraySequence.toCoordinateArray",
	"Comment": "this method exposes the internal array of coordinate objects",
	"Method": "Coordinate[] toCoordinateArray(){\r\n    return coordinates;\r\n}"
}, {
	"Path": "com.jsql.util.ThreadUtil.reset",
	"Comment": "force to stop every threads still running and empty the list wherethey were instanciated in order to be garbage collected.",
	"Method": "void reset(){\r\n    try {\r\n        for (AbstractSuspendable<?> suspendable : ThreadUtil.suspendables.values()) {\r\n            suspendable.stop();\r\n        }\r\n        ThreadUtil.suspendables.clear();\r\n    } catch (ConcurrentModificationException e) {\r\n        LOGGER.error(e, e);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.planargraph.GraphComponent.isVisited",
	"Comment": "tests if a component has been visited during the course of a graph algorithm",
	"Method": "boolean isVisited(){\r\n    return isVisited;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.prep.AbstractPreparedPolygonContains.isSingleShell",
	"Comment": "tests whether a geometry consists of a single polygon with no holes.",
	"Method": "boolean isSingleShell(Geometry geom){\r\n    if (geom.getNumGeometries() != 1)\r\n        return false;\r\n    Polygon poly = (Polygon) geom.getGeometryN(0);\r\n    int numHoles = poly.getNumInteriorRing();\r\n    if (numHoles == 0)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "com.jsql.util.ExceptionUtil.setUncaughtExceptionHandler",
	"Comment": "add the error reporting mecanism on top of the jvm in order tointercept and process the error to github.",
	"Method": "void setUncaughtExceptionHandler(){\r\n    Thread.setDefaultUncaughtExceptionHandler(new ExceptionHandler());\r\n    try {\r\n        SwingUtilities.invokeAndWait(() -> Thread.currentThread().setUncaughtExceptionHandler(new ExceptionHandler()));\r\n    } catch (InvocationTargetException | InterruptedException e) {\r\n        LOGGER.error(\"Unhandled Exception on ExceptionUtil\", e);\r\n    }\r\n}"
}, {
	"Path": "org.kse.gui.KeyStoreTableModel.load",
	"Comment": "load the keystoretablemodel with the entries from a keystore.",
	"Method": "void load(KeyStoreHistory history){\r\n    this.history = history;\r\n    KeyStoreState currentState = history.getCurrentState();\r\n    KeyStore keyStore = currentState.getKeyStore();\r\n    KeyStoreType type = KeyStoreType.resolveJce(keyStore.getType());\r\n    Enumeration<String> aliases = keyStore.aliases();\r\n    TreeMap<String, String> sortedAliases = new TreeMap(new AliasComparator());\r\n    while (aliases.hasMoreElements()) {\r\n        String alias = aliases.nextElement();\r\n        if (!KeyStoreUtil.isSupportedEntryType(alias, keyStore)) {\r\n            continue;\r\n        }\r\n        sortedAliases.put(alias, alias);\r\n    }\r\n    data = new Object[sortedAliases.size()][nofColumns];\r\n    int i = 0;\r\n    for (Iterator<Entry<String, String>> itr = sortedAliases.entrySet().iterator(); itr.hasNext(); i++) {\r\n        String alias = itr.next().getKey();\r\n        String entryType = null;\r\n        if (KeyStoreUtil.isTrustedCertificateEntry(alias, keyStore)) {\r\n            entryType = TRUST_CERT_ENTRY;\r\n        } else if (KeyStoreUtil.isKeyPairEntry(alias, keyStore)) {\r\n            entryType = KEY_PAIR_ENTRY;\r\n        } else {\r\n            entryType = KEY_ENTRY;\r\n        }\r\n        data[i][0] = entryType;\r\n        if ((entryType.equals(KEY_PAIR_ENTRY) || entryType.equals(KEY_ENTRY)) && type.hasEntryPasswords()) {\r\n            if (currentState.getEntryPassword(alias) != null) {\r\n                data[i][1] = Boolean.FALSE;\r\n            } else {\r\n                data[i][1] = Boolean.TRUE;\r\n            }\r\n        } else {\r\n            data[i][1] = null;\r\n        }\r\n        Date expiry = getCertificateExpiry(alias, keyStore);\r\n        Calendar c = Calendar.getInstance();\r\n        Calendar a = Calendar.getInstance();\r\n        c.setTime(new Date());\r\n        a.setTime(new Date());\r\n        a.add(Calendar.DATE, expiryWarnDays);\r\n        if (expiry == null) {\r\n            data[i][2] = null;\r\n        } else {\r\n            if (expiry.before(c.getTime())) {\r\n                data[i][2] = 2;\r\n            } else {\r\n                if (expiry.before(a.getTime())) {\r\n                    data[i][2] = 1;\r\n                } else {\r\n                    data[i][2] = 0;\r\n                }\r\n            }\r\n        }\r\n        if (iNameColumn > 0) {\r\n            data[i][iNameColumn] = alias;\r\n            if (alias.length() > iColWidth[iNameColumn]) {\r\n                iColWidth[iNameColumn] = alias.length();\r\n            }\r\n        }\r\n        KeyInfo keyInfo = getKeyInfo(alias, keyStore, currentState);\r\n        if (keyInfo != null) {\r\n            if (iAlgorithmColumn > 0) {\r\n                data[i][iAlgorithmColumn] = getAlgorithmName(keyInfo);\r\n                if (iColWidth[iAlgorithmColumn] < data[i][iAlgorithmColumn].toString().length()) {\r\n                    iColWidth[iAlgorithmColumn] = data[i][iAlgorithmColumn].toString().length();\r\n                }\r\n            }\r\n            if (iKeySizeColumn > 0) {\r\n                data[i][iKeySizeColumn] = keyInfo.getSize();\r\n            }\r\n            if (keyStoreTableColumns.getEnableCurve()) {\r\n                data[i][iCurveColumn] = keyInfo.getDetailedAlgorithm();\r\n                if (iColWidth[iCurveColumn] < data[i][iCurveColumn].toString().length()) {\r\n                    iColWidth[iCurveColumn] = data[i][iCurveColumn].toString().length();\r\n                }\r\n            }\r\n        }\r\n        if (iCertExpiryColumn > 0) {\r\n            if (expiry != null) {\r\n                data[i][iCertExpiryColumn] = expiry;\r\n            } else {\r\n                data[i][iCertExpiryColumn] = null;\r\n            }\r\n        }\r\n        if (iLastModifiedColumn > 0) {\r\n            if (!keyStore.getType().equals(KeyStoreType.PKCS12.jce()) && !keyStore.getType().equals(KeyStoreType.PKCS11.jce())) {\r\n                data[i][iLastModifiedColumn] = keyStore.getCreationDate(alias);\r\n            } else {\r\n                data[i][iLastModifiedColumn] = null;\r\n            }\r\n        }\r\n        if (iSubjectDNColumn > 0) {\r\n            if (entryType != KEY_ENTRY) {\r\n                data[i][iSubjectDNColumn] = getCertificateSubjectDN(alias, keyStore);\r\n                if (iColWidth[iSubjectDNColumn] < data[i][iSubjectDNColumn].toString().length()) {\r\n                    iColWidth[iSubjectDNColumn] = data[i][iSubjectDNColumn].toString().length();\r\n                }\r\n            } else {\r\n                data[i][iSubjectDNColumn] = null;\r\n            }\r\n        }\r\n        if (iIssuerDNColumn > 0) {\r\n            if (entryType != KEY_ENTRY) {\r\n                data[i][iIssuerDNColumn] = getCertificateIssuerDN(alias, keyStore);\r\n                if (iColWidth[iIssuerDNColumn] < data[i][iIssuerDNColumn].toString().length()) {\r\n                    iColWidth[iIssuerDNColumn] = data[i][iIssuerDNColumn].toString().length();\r\n                }\r\n            } else {\r\n                data[i][iIssuerDNColumn] = null;\r\n            }\r\n        }\r\n        if (iSubjectCNColumn > 0) {\r\n            if (entryType != KEY_ENTRY) {\r\n                data[i][iSubjectCNColumn] = getCertificateSubjectCN(alias, keyStore);\r\n                if (iColWidth[iSubjectCNColumn] < data[i][iSubjectCNColumn].toString().length()) {\r\n                    iColWidth[iSubjectCNColumn] = data[i][iSubjectCNColumn].toString().length();\r\n                }\r\n            } else {\r\n                data[i][iSubjectCNColumn] = null;\r\n            }\r\n        }\r\n        if (iIssuerCNColumn > 0) {\r\n            if (entryType != KEY_ENTRY) {\r\n                data[i][iIssuerCNColumn] = getCertificateIssuerCN(alias, keyStore);\r\n                if (iColWidth[iIssuerCNColumn] < data[i][iIssuerCNColumn].toString().length()) {\r\n                    iColWidth[iIssuerCNColumn] = data[i][iIssuerCNColumn].toString().length();\r\n                }\r\n            } else {\r\n                data[i][iIssuerCNColumn] = null;\r\n            }\r\n        }\r\n        if (iSubjectOColumn > 0) {\r\n            if (entryType != KEY_ENTRY) {\r\n                data[i][iSubjectOColumn] = getCertificateSubjectO(alias, keyStore);\r\n                if (iColWidth[iSubjectOColumn] < data[i][iSubjectOColumn].toString().length()) {\r\n                    iColWidth[iSubjectOColumn] = data[i][iSubjectOColumn].toString().length();\r\n                }\r\n            } else {\r\n                data[i][iSubjectOColumn] = null;\r\n            }\r\n        }\r\n        if (iIssuerOColumn > 0) {\r\n            if (entryType != KEY_ENTRY) {\r\n                data[i][iIssuerOColumn] = getCertificateIssuerO(alias, keyStore);\r\n                if (iColWidth[iIssuerOColumn] < data[i][iIssuerOColumn].toString().length()) {\r\n                    iColWidth[iIssuerOColumn] = data[i][iIssuerOColumn].toString().length();\r\n                }\r\n            } else {\r\n                data[i][iIssuerOColumn] = null;\r\n            }\r\n        }\r\n        if (iAKIColumn > 0) {\r\n            if (entryType != KEY_ENTRY) {\r\n                data[i][iAKIColumn] = getCertificateAKI(alias, keyStore);\r\n                if (iColWidth[iAKIColumn] < data[i][iAKIColumn].toString().length()) {\r\n                    iColWidth[iAKIColumn] = data[i][iAKIColumn].toString().length();\r\n                }\r\n            } else {\r\n                data[i][iAKIColumn] = null;\r\n            }\r\n        }\r\n        if (iSKIColumn > 0) {\r\n            if (entryType != KEY_ENTRY) {\r\n                data[i][iSKIColumn] = getCertificateSKI(alias, keyStore);\r\n                if (iColWidth[iSKIColumn] < data[i][iSKIColumn].toString().length()) {\r\n                    iColWidth[iSKIColumn] = data[i][iSKIColumn].toString().length();\r\n                }\r\n            } else {\r\n                data[i][iSKIColumn] = null;\r\n            }\r\n        }\r\n    }\r\n    fireTableDataChanged();\r\n}"
}, {
	"Path": "com.jdon.model.query.PageIteratorSolver.locate",
	"Comment": "looking for a block in that there is a primary key is equals to the\tlocateid. for the sql sentence.",
	"Method": "Block locate(String sqlquery,Collection queryParams,Object locateId){\r\n    return blockStrategy.locate(sqlquery, queryParams, locateId);\r\n}"
}, {
	"Path": "org.kse.gui.crypto.policymapping.PolicyMappingsTableModel.load",
	"Comment": "load the policymappingstablemodel with policy mappings.",
	"Method": "void load(PolicyMappings policyMappings){\r\n    ASN1Sequence policyMappingsSeq = (ASN1Sequence) policyMappings.toASN1Primitive();\r\n    ASN1Encodable[] asn1EncArray = policyMappingsSeq.toArray();\r\n    PolicyMapping[] policyMappingsArray = new PolicyMapping[asn1EncArray.length];\r\n    for (int i = 0; i < asn1EncArray.length; i++) {\r\n        policyMappingsArray[i] = PolicyMapping.getInstance(asn1EncArray[i]);\r\n    }\r\n    Arrays.sort(policyMappingsArray, new IssuerDomainPolicyComparator());\r\n    data = new Object[policyMappingsArray.length][2];\r\n    int i = 0;\r\n    for (PolicyMapping policyMapping : policyMappingsArray) {\r\n        data[i][0] = policyMapping;\r\n        data[i][1] = policyMapping;\r\n        i++;\r\n    }\r\n    fireTableDataChanged();\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DD.stringOfChar",
	"Comment": "creates a string of a given length containing the given character",
	"Method": "String stringOfChar(char ch,int len){\r\n    StringBuffer buf = new StringBuffer();\r\n    for (int i = 0; i < len; i++) {\r\n        buf.append(ch);\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isNotPoBox",
	"Comment": "isnotpobox returns true if address argument does not contain anything that looks like a a po box.",
	"Method": "boolean isNotPoBox(String s){\r\n    if (isEmpty(s))\r\n        return defaultEmptyOK;\r\n    String sl = s.toLowerCase();\r\n    if (sl.indexOf(\"p.o. b\") != -1)\r\n        return false;\r\n    if (sl.indexOf(\"p.o.b\") != -1)\r\n        return false;\r\n    if (sl.indexOf(\"p.o b\") != -1)\r\n        return false;\r\n    if (sl.indexOf(\"p o b\") != -1)\r\n        return false;\r\n    if (sl.indexOf(\"po b\") != -1)\r\n        return false;\r\n    if (sl.indexOf(\"pobox\") != -1)\r\n        return false;\r\n    if (sl.indexOf(\"po#\") != -1)\r\n        return false;\r\n    if (sl.indexOf(\"po #\") != -1)\r\n        return false;\r\n    if (sl.indexOf(\"p.0. b\") != -1)\r\n        return false;\r\n    if (sl.indexOf(\"p.0.b\") != -1)\r\n        return false;\r\n    if (sl.indexOf(\"p.0 b\") != -1)\r\n        return false;\r\n    if (sl.indexOf(\"p 0 b\") != -1)\r\n        return false;\r\n    if (sl.indexOf(\"p0 b\") != -1)\r\n        return false;\r\n    if (sl.indexOf(\"p0box\") != -1)\r\n        return false;\r\n    if (sl.indexOf(\"p0#\") != -1)\r\n        return false;\r\n    if (sl.indexOf(\"p0 #\") != -1)\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "com.jdon.persistence.hibernate.HibernateTemplate.getQueryCacheRegion",
	"Comment": "return the name of the cache region for queries executed by this\ttemplate.",
	"Method": "String getQueryCacheRegion(){\r\n    return queryCacheRegion;\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isDate",
	"Comment": "isdate returns true if string argument date forms a valid date.",
	"Method": "boolean isDate(String year,String month,String day,boolean isDate,String date){\r\n    if (isEmpty(date))\r\n        return defaultEmptyOK;\r\n    String month;\r\n    String day;\r\n    String year;\r\n    int dateSlash1 = date.indexOf(\"/\");\r\n    int dateSlash2 = date.lastIndexOf(\"/\");\r\n    if (dateSlash1 <= 0 || dateSlash1 == dateSlash2)\r\n        return false;\r\n    month = date.substring(0, dateSlash1);\r\n    day = date.substring(dateSlash1 + 1, dateSlash2);\r\n    year = date.substring(dateSlash2 + 1);\r\n    return isDate(year, month, day);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.overlay.OverlayOp.mergeSymLabels",
	"Comment": "for nodes which have edges from only one geometry incident on them,the previous step will have left their diredges with no labelling for the othergeometry.however, the sym diredge may have a labelling for the othergeometry, so merge the two labels.",
	"Method": "void mergeSymLabels(){\r\n    for (Iterator nodeit = graph.getNodes().iterator(); nodeit.hasNext(); ) {\r\n        Node node = (Node) nodeit.next();\r\n        ((DirectedEdgeStar) node.getEdges()).mergeSymLabels();\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.linearref.LengthIndexedLineTest.testOffsetStartPointRepeatedPoint",
	"Comment": "these tests work for lengthindexedline, but not locationindexedline",
	"Method": "void testOffsetStartPointRepeatedPoint(){\r\n    runOffsetTest(\"LINESTRING (0 0, 10 10, 10 10, 20 20)\", \"POINT(0 0)\", 1.0, \"POINT (-0.7071067811865475 0.7071067811865475)\");\r\n    runOffsetTest(\"LINESTRING (0 0, 10 10, 10 10, 20 20)\", \"POINT(0 0)\", -1.0, \"POINT (0.7071067811865475 -0.7071067811865475)\");\r\n    runOffsetTest(\"LINESTRING (0 0, 10 10, 10 10, 20 20)\", \"POINT(10 10)\", 5.0, \"POINT (6.464466094067262 13.535533905932738)\");\r\n    runOffsetTest(\"LINESTRING (0 0, 10 10, 10 10, 20 20)\", \"POINT(10 10)\", -5.0, \"POINT (13.535533905932738 6.464466094067262)\");\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.hlist.HList.cons",
	"Comment": "static factory method for creating an hlist from the given head and tail.",
	"Method": "HCons<NewHead, ? extends HList> cons(NewHead newHead,HCons<Head, Tail> cons,Head head,Tail tail,HCons<NewHead, ? extends HCons<Head, Tail>> cons,NewHead newHead,SingletonHList<Head> cons,Head head){\r\n    return new HCons(head, tail);\r\n}"
}, {
	"Path": "com.jsql.view.swing.shadow.ShadowPopupBorder.paintBorder",
	"Comment": "paints the border for the specified component with the specifiedposition and size.",
	"Method": "void paintBorder(Component c,Graphics g,int x,int y,int width,int height){\r\n    try {\r\n        JComponent popup = (JComponent) c;\r\n        Image hShadowBg = (Image) popup.getClientProperty(ShadowPopupFactory.PROP_HORIZONTAL_BACKGROUND);\r\n        if (hShadowBg != null) {\r\n            g.drawImage(hShadowBg, x, y + height - 5, c);\r\n        }\r\n        Image vShadowBg = (Image) popup.getClientProperty(ShadowPopupFactory.PROP_VERTICAL_BACKGROUND);\r\n        if (vShadowBg != null) {\r\n            g.drawImage(vShadowBg, x + width - 5, y, c);\r\n        }\r\n        g.drawImage(shadow, x + 5, y + height - 5, x + 10, y + height, 0, 6, 5, 11, null, c);\r\n        g.drawImage(shadow, x + 10, y + height - 5, x + width - 5, y + height, 5, 6, 6, 11, null, c);\r\n        g.drawImage(shadow, x + width - 5, y + 5, x + width, y + 10, 6, 0, 11, 5, null, c);\r\n        g.drawImage(shadow, x + width - 5, y + 10, x + width, y + height - 5, 6, 5, 11, 6, null, c);\r\n        g.drawImage(shadow, x + width - 5, y + height - 5, x + width, y + height, 6, 6, 11, 11, null, c);\r\n    } catch (ClassCastException e) {\r\n        LOGGER.error(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifInterface.getAllTags",
	"Comment": "get the exif tags in this exifinterface object or null if none exist.",
	"Method": "List<ExifTag> getAllTags(){\r\n    return mData.getAllTags();\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.getCellLayout",
	"Comment": "returns the celllayout of the specified container at the specified screen.",
	"Method": "CellLayout getCellLayout(long container,long screenId){\r\n    if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {\r\n        if (mHotseat != null) {\r\n            return mHotseat.getLayout();\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        return mWorkspace.getScreenWithId(screenId);\r\n    }\r\n}"
}, {
	"Path": "com.jsql.view.swing.dialog.OrderedProperties.removeProperty",
	"Comment": "removes the property with the specified key, if it is present. returnsthe value of the property, or null if there was no property withthe specified key.",
	"Method": "String removeProperty(String key){\r\n    return this.properties.remove(key);\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.product.Product4.rotateR4",
	"Comment": "rotate the first four values of this product one slot to the right.",
	"Method": "Product4<_4, _1, _2, _3> rotateR4(){\r\n    return into((_1, _2, _3, _4) -> product(_4, _1, _2, _3));\r\n}"
}, {
	"Path": "org.kse.crypto.x509.X509CertUtil.getCertsEncodedX509Pem",
	"Comment": "x.509 encode a number of certificates and pem the encoding.",
	"Method": "String getCertsEncodedX509Pem(X509Certificate[] certs){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (X509Certificate cert : certs) {\r\n        sb.append(getCertEncodedX509Pem(cert));\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.kse.gui.KseFrame.showHideToolBar",
	"Comment": "if the tool bar is currently displayed hide it and vice versa.",
	"Method": "void showHideToolBar(){\r\n    Container contentPane = frame.getContentPane();\r\n    boolean toolBarShown = false;\r\n    for (int i = 0; i < contentPane.getComponentCount(); i++) {\r\n        if (contentPane.getComponent(i).equals(jtbToolBar)) {\r\n            toolBarShown = true;\r\n            break;\r\n        }\r\n    }\r\n    if (toolBarShown) {\r\n        frame.getContentPane().remove(jtbToolBar);\r\n        applicationSettings.setShowToolBar(false);\r\n    } else {\r\n        frame.getContentPane().add(jtbToolBar, BorderLayout.NORTH);\r\n        applicationSettings.setShowToolBar(true);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.edgegraph.HalfEdge.create",
	"Comment": "creates a halfedge pair representing an edgebetween two vertices located at coordinates p0 and p1.",
	"Method": "HalfEdge create(Coordinate p0,Coordinate p1){\r\n    HalfEdge e0 = new HalfEdge(p0);\r\n    HalfEdge e1 = new HalfEdge(p1);\r\n    e0.init(e1);\r\n    return e0;\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testrunner.TestReader.parseGeometryOperation",
	"Comment": "parses an optional geometryoperation element. \t\tthe default is to leave this unspecified .",
	"Method": "GeometryOperation parseGeometryOperation(Element runElement){\r\n    Element goElement = runElement.getChild(TAG_geometryOperation);\r\n    if (goElement == null) {\r\n        return null;\r\n    }\r\n    String goClass = goElement.getTextTrim();\r\n    GeometryOperation geomOp = (GeometryOperation) getInstance(goClass, GeometryOperation.class);\r\n    if (geomOp == null) {\r\n        throw new TestParseException(\"Could not create instance of GeometryOperation from class \" + goClass);\r\n    }\r\n    return geomOp;\r\n}"
}, {
	"Path": "org.kse.utilities.StringUtils.trimAndConvertEmptyToNull",
	"Comment": "trims passed string and converts it to null if the resulting string has length zero.",
	"Method": "String trimAndConvertEmptyToNull(String str){\r\n    if (str == null) {\r\n        return null;\r\n    }\r\n    String newStr = str.trim();\r\n    if (newStr.length() < 1) {\r\n        return null;\r\n    }\r\n    return newStr;\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.NodingIntersectionFinder.setCheckEndSegmentsOnly",
	"Comment": "sets whether only end segments should be tested for interior intersection.this is a performance optimization that may be used ifthe segments have been previously noded by an appropriate algorithm.it may be known that any potential noding failures will occur only inend segments.",
	"Method": "void setCheckEndSegmentsOnly(boolean isCheckEndSegmentsOnly){\r\n    this.isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.bindRestoreItemsChange",
	"Comment": "update the state of a package, typically related to install state.implementation of the method from launchermodel.callbacks.",
	"Method": "void bindRestoreItemsChange(HashSet<ItemInfo> updates){\r\n    Runnable r = new Runnable() {\r\n        public void run() {\r\n            bindRestoreItemsChange(updates);\r\n        }\r\n    };\r\n    if (waitUntilResume(r)) {\r\n        return;\r\n    }\r\n    mWorkspace.updateRestoreItems(updates);\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.bindRestoreItemsChange",
	"Comment": "update the state of a package, typically related to install state.implementation of the method from launchermodel.callbacks.",
	"Method": "void bindRestoreItemsChange(HashSet<ItemInfo> updates){\r\n    bindRestoreItemsChange(updates);\r\n}"
}, {
	"Path": "org.locationtech.jts.linearref.LengthIndexedLineTest.testComputeZNaN",
	"Comment": "tests that if the input does not have z ordinates, neither does the output.",
	"Method": "void testComputeZNaN(){\r\n    Geometry linearGeom = read(\"LINESTRING (0 0, 10 10 10)\");\r\n    LengthIndexedLine indexedLine = new LengthIndexedLine(linearGeom);\r\n    double projIndex = indexedLine.project(new Coordinate(5, 5));\r\n    Coordinate projPt = indexedLine.extractPoint(projIndex);\r\n    assertTrue(Double.isNaN(projPt.getZ()));\r\n}"
}, {
	"Path": "com.jsql.view.swing.panel.util.ActionHideShowResult.actionPerformed",
	"Comment": "hide bottom panel if both main and bottom are visible, alsodisplays an ersatz bar replacing tabbedpane.or else if only main panel is visible then displays bottom paneland hide ersatz panel.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    if (MediatorGui.frame().getSplitHorizontalTopBottom().getTopComponent().isVisible() && MediatorGui.frame().getSplitHorizontalTopBottom().getBottomComponent().isVisible()) {\r\n        PanelConsoles.setLoc(MediatorGui.frame().getSplitHorizontalTopBottom().getDividerLocation());\r\n        MediatorGui.frame().getSplitHorizontalTopBottom().getTopComponent().setVisible(false);\r\n        MediatorGui.frame().getSplitHorizontalTopBottom().disableDragSize();\r\n        PanelConsoles.getButtonShowNorth().setVisible(false);\r\n    } else if (MediatorGui.frame().getSplitHorizontalTopBottom().getTopComponent().isVisible() && !MediatorGui.frame().getSplitHorizontalTopBottom().getBottomComponent().isVisible()) {\r\n        MediatorGui.frame().getSplitHorizontalTopBottom().setDividerLocation(PanelConsoles.getLoc());\r\n        MediatorGui.frame().getSplitHorizontalTopBottom().getBottomComponent().setVisible(true);\r\n        MediatorGui.frame().getSplitHorizontalTopBottom().getTopComponent().setVisible(true);\r\n        MediatorGui.frame().getSplitHorizontalTopBottom().enableDragSize();\r\n    }\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.dsl.base.OperationSupport.handleGet",
	"Comment": "send an http, optionally performing placeholder substitution to the response.",
	"Method": "T handleGet(URL resourceUrl,Class<T> type,T handleGet,URL resourceUrl,Class<T> type,Map<String, String> parameters){\r\n    Request.Builder requestBuilder = new Request.Builder().get().url(resourceUrl);\r\n    return handleResponse(requestBuilder, type, parameters);\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.Distance.pointToSegmentString",
	"Comment": "computes the distance from a point to a sequence of line segments.",
	"Method": "double pointToSegmentString(Coordinate p,Coordinate[] line){\r\n    if (line.length == 0)\r\n        throw new IllegalArgumentException(\"Line array must contain at least one vertex\");\r\n    double minDistance = p.distance(line[0]);\r\n    for (int i = 0; i < line.length - 1; i++) {\r\n        double dist = Distance.pointToSegment(p, line[i], line[i + 1]);\r\n        if (dist < minDistance) {\r\n            minDistance = dist;\r\n        }\r\n    }\r\n    return minDistance;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.CoordinateSequence.getM",
	"Comment": "returns ordinate m of the specified coordinate if available.",
	"Method": "double getM(int index){\r\n    if (hasM()) {\r\n        final int mIndex = getDimension() - getMeasures();\r\n        return getOrdinate(index, mIndex);\r\n    } else {\r\n        return Double.NaN;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.LineSegment.toGeometry",
	"Comment": "creates a linestring with the same coordinates as this segment",
	"Method": "LineString toGeometry(GeometryFactory geomFactory){\r\n    return geomFactory.createLineString(new Coordinate[] { p0, p1 });\r\n}"
}, {
	"Path": "com.jdon.container.pico.JdonInstantiatingComponentAdapter.newInstance",
	"Comment": "instantiate an object with given parameters and respect the accessible\tflag.",
	"Method": "Object newInstance(Constructor constructor,Object[] parameters){\r\n    if (allowNonPublicClasses) {\r\n        constructor.setAccessible(true);\r\n    }\r\n    return constructor.newInstance(parameters);\r\n}"
}, {
	"Path": "org.kse.gui.dnd.DragKeyPairEntry.getContent",
	"Comment": "get entry content as binary. used to generate dragged file name.",
	"Method": "byte[] getContent(){\r\n    return contentBytes;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.distance.IndexedFacetDistance.distance",
	"Comment": "computes the distance between two geometries usingthe indexed approach.for geometries with many segments or points, this can be faster than using a simple distancealgorithm.",
	"Method": "double distance(Geometry g1,Geometry g2,double distance,ItemBoundable item1,ItemBoundable item2){\r\n    IndexedFacetDistance dist = new IndexedFacetDistance(g1);\r\n    return dist.getDistance(g2);\r\n}"
}, {
	"Path": "org.kse.gui.crypto.JValidityPeriod.getValidityEnd",
	"Comment": "compute validity end date, based on chosen period and relative to validity\tstart date.",
	"Method": "Date getValidityEnd(Date validityStart){\r\n    Calendar validityDate = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\r\n    validityDate.setTime(validityStart);\r\n    int periodType = jcbType.getSelectedIndex();\r\n    int periodValue = ((Number) jsValue.getValue()).intValue();\r\n    switch(periodType) {\r\n        case YEARS:\r\n            validityDate.add(Calendar.YEAR, periodValue);\r\n            break;\r\n        case MONTHS:\r\n            validityDate.add(Calendar.MONTH, periodValue);\r\n            break;\r\n        case WEEKS:\r\n            validityDate.add(Calendar.WEEK_OF_MONTH, periodValue);\r\n            break;\r\n        default:\r\n            validityDate.add(Calendar.DAY_OF_WEEK, periodValue);\r\n            break;\r\n    }\r\n    return validityDate.getTime();\r\n}"
}, {
	"Path": "org.locationtech.jts.edgegraph.HalfEdge.equals",
	"Comment": "tests whether this edge has the given orig and dest vertices.",
	"Method": "boolean equals(Coordinate p0,Coordinate p1){\r\n    return orig.equals2D(p0) && sym.orig.equals(p1);\r\n}"
}, {
	"Path": "com.android.launcher3.IconCache.getEntryForPackageLocked",
	"Comment": "gets an entry for the package, which can be used as a fallback entry for various components.this method is not thread safe, it must be called from a synchronized method.",
	"Method": "CacheEntry getEntryForPackageLocked(String packageName,UserHandleCompat user,boolean useLowResIcon){\r\n    ComponentKey cacheKey = getPackageKey(packageName, user);\r\n    CacheEntry entry = mCache.get(cacheKey);\r\n    if (entry == null || (entry.isLowResIcon && !useLowResIcon)) {\r\n        entry = new CacheEntry();\r\n        boolean entryUpdated = true;\r\n        if (!getEntryFromDB(cacheKey, entry, useLowResIcon)) {\r\n            try {\r\n                int flags = UserHandleCompat.myUserHandle().equals(user) ? 0 : PackageManager.GET_UNINSTALLED_PACKAGES;\r\n                PackageInfo info = mPackageManager.getPackageInfo(packageName, flags);\r\n                ApplicationInfo appInfo = info.applicationInfo;\r\n                if (appInfo == null) {\r\n                    throw new NameNotFoundException(\"ApplicationInfo is null\");\r\n                }\r\n                Drawable drawable = mUserManager.getBadgedDrawableForUser(appInfo.loadIcon(mPackageManager), user);\r\n                entry.icon = Utilities.createIconBitmap(drawable, mContext);\r\n                entry.title = appInfo.loadLabel(mPackageManager);\r\n                entry.contentDescription = mUserManager.getBadgedLabelForUser(entry.title, user);\r\n                entry.isLowResIcon = false;\r\n                ContentValues values = newContentValues(entry.icon, entry.title.toString(), mPackageBgColor);\r\n                addIconToDB(values, cacheKey.componentName, info, mUserManager.getSerialNumberForUser(user));\r\n            } catch (NameNotFoundException e) {\r\n                if (DEBUG)\r\n                    Log.d(TAG, \"Application not installed \" + packageName);\r\n                entryUpdated = false;\r\n            }\r\n        }\r\n        if (entryUpdated) {\r\n            mCache.put(cacheKey, entry);\r\n        }\r\n    }\r\n    return entry;\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifOutputStream.setExifData",
	"Comment": "sets the exifdata to be written into the jpeg file. should be calledbefore writing image data.",
	"Method": "void setExifData(ExifData exifData){\r\n    mExifData = exifData;\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testrunner.TopologyTestApp.isGeometryOperationSpecified",
	"Comment": "tests whether a geometryoperation was specified on the command line",
	"Method": "boolean isGeometryOperationSpecified(){\r\n    return geometryOp != defaultOp;\r\n}"
}, {
	"Path": "org.locationtech.jts.util.CollectionUtil.apply",
	"Comment": "executes a function on each item in a collection but doesnot accumulate the result",
	"Method": "void apply(Collection coll,Function func){\r\n    for (Iterator i = coll.iterator(); i.hasNext(); ) {\r\n        func.execute(i.next());\r\n    }\r\n}"
}, {
	"Path": "com.samskivert.mustache.Mustache.compiler",
	"Comment": "returns a compiler that escapes html by default and does not use standards mode.",
	"Method": "Compiler compiler(){\r\n    return new Compiler(false, false, null, false, false, false, DEFAULT_FORMATTER, Escapers.HTML, FAILING_LOADER, new DefaultCollector(), new Delims());\r\n}"
}, {
	"Path": "org.joda.money.format.MoneyFormatterBuilder.appendLiteral",
	"Comment": "appends a literal to the builder.the localized currency symbol is the symbol as chosen by the localeof the formatter.",
	"Method": "MoneyFormatterBuilder appendLiteral(CharSequence literal){\r\n    if (literal == null || literal.length() == 0) {\r\n        return this;\r\n    }\r\n    LiteralPrinterParser pp = new LiteralPrinterParser(literal.toString());\r\n    return appendInternal(pp, pp);\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifData.getUserComment",
	"Comment": "decodes the user comment tag into string as specified in the exifstandard. returns null if decoding failed.",
	"Method": "String getUserComment(){\r\n    IfdData ifdData = mIfdDatas[IfdId.TYPE_IFD_0];\r\n    if (ifdData == null) {\r\n        return null;\r\n    }\r\n    ExifTag tag = ifdData.getTag(ExifInterface.getTrueTagKey(ExifInterface.TAG_USER_COMMENT));\r\n    if (tag == null) {\r\n        return null;\r\n    }\r\n    if (tag.getComponentCount() < 8) {\r\n        return null;\r\n    }\r\n    byte[] buf = new byte[tag.getComponentCount()];\r\n    tag.getBytes(buf);\r\n    byte[] code = new byte[8];\r\n    System.arraycopy(buf, 0, code, 0, 8);\r\n    try {\r\n        if (Arrays.equals(code, USER_COMMENT_ASCII)) {\r\n            return new String(buf, 8, buf.length - 8, \"US-ASCII\");\r\n        } else if (Arrays.equals(code, USER_COMMENT_JIS)) {\r\n            return new String(buf, 8, buf.length - 8, \"EUC-JP\");\r\n        } else if (Arrays.equals(code, USER_COMMENT_UNICODE)) {\r\n            return new String(buf, 8, buf.length - 8, \"UTF-16\");\r\n        } else {\r\n            return null;\r\n        }\r\n    } catch (UnsupportedEncodingException e) {\r\n        Log.w(TAG, \"Failed to decode the user comment\");\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.relate.RelateOp.getIntersectionMatrix",
	"Comment": "gets the intersectionmatrix for the spatial relationshipbetween the input geometries.",
	"Method": "IntersectionMatrix getIntersectionMatrix(){\r\n    return relate.computeIM();\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.stripCharsNotInBag",
	"Comment": "removes all characters which do not appear in string bag from string s.",
	"Method": "String stripCharsNotInBag(String s,String bag){\r\n    int i;\r\n    String returnString = \"\";\r\n    for (i = 0; i < s.length(); i++) {\r\n        char c = s.charAt(i);\r\n        if (bag.indexOf(c) != -1)\r\n            returnString += c;\r\n    }\r\n    return returnString;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.Geometry.setUserData",
	"Comment": "a simple scheme for applications to add their own custom data to a geometry.an example use might be to add an object representing a coordinate reference system.note that user data objects are not present in geometries created byconstruction methods.",
	"Method": "void setUserData(Object userData){\r\n    this.userData = userData;\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.importexport.DExportCertificates.exportChain",
	"Comment": "export entire certificate chain? only applicable for key pair entries.",
	"Method": "boolean exportChain(){\r\n    return exportChain;\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.unbindWorkspaceItemsOnMainThread",
	"Comment": "unbinds all the sbgworkspaceitems and sbgappwidgets on the main thread",
	"Method": "void unbindWorkspaceItemsOnMainThread(){\r\n    final ArrayList<ItemInfo> tmpItems = new ArrayList<ItemInfo>();\r\n    synchronized (sBgLock) {\r\n        tmpItems.addAll(sBgWorkspaceItems);\r\n        tmpItems.addAll(sBgAppWidgets);\r\n    }\r\n    Runnable r = new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            for (ItemInfo item : tmpItems) {\r\n                item.unbind();\r\n            }\r\n        }\r\n    };\r\n    runOnMainThread(r);\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.unbindWorkspaceItemsOnMainThread",
	"Comment": "unbinds all the sbgworkspaceitems and sbgappwidgets on the main thread",
	"Method": "void unbindWorkspaceItemsOnMainThread(){\r\n    for (ItemInfo item : tmpItems) {\r\n        item.unbind();\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.valid.ConsistentAreaTester.isNodeEdgeAreaLabelsConsistent",
	"Comment": "check all nodes to see if their labels are consistent.if any are not, return false",
	"Method": "boolean isNodeEdgeAreaLabelsConsistent(){\r\n    for (Iterator nodeIt = nodeGraph.getNodeIterator(); nodeIt.hasNext(); ) {\r\n        RelateNode node = (RelateNode) nodeIt.next();\r\n        if (!node.getEdges().isAreaLabelsConsistent(geomGraph)) {\r\n            invalidPoint = node.getCoordinate().copy();\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.product.Product6.rotateL6",
	"Comment": "rotate the first six values of this product one slot to the left.",
	"Method": "Product6<_2, _3, _4, _5, _6, _1> rotateL6(){\r\n    return into((_1, _2, _3, _4, _5, _6) -> product(_2, _3, _4, _5, _6, _1));\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherScroller.computeScrollOffset",
	"Comment": "call this when you want to know the new location.if it returns true,the animation is not yet finished.",
	"Method": "boolean computeScrollOffset(){\r\n    if (mFinished) {\r\n        return false;\r\n    }\r\n    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);\r\n    if (timePassed < mDuration) {\r\n        switch(mMode) {\r\n            case SCROLL_MODE:\r\n                float x = timePassed * mDurationReciprocal;\r\n                if (mInterpolator == null)\r\n                    x = viscousFluid(x);\r\n                else\r\n                    x = mInterpolator.getInterpolation(x);\r\n                mCurrX = mStartX + Math.round(x * mDeltaX);\r\n                mCurrY = mStartY + Math.round(x * mDeltaY);\r\n                break;\r\n            case FLING_MODE:\r\n                final float t = (float) timePassed / mDuration;\r\n                final int index = (int) (NB_SAMPLES * t);\r\n                float distanceCoef = 1.f;\r\n                float velocityCoef = 0.f;\r\n                if (index < NB_SAMPLES) {\r\n                    final float t_inf = (float) index / NB_SAMPLES;\r\n                    final float t_sup = (float) (index + 1) / NB_SAMPLES;\r\n                    final float d_inf = SPLINE_POSITION[index];\r\n                    final float d_sup = SPLINE_POSITION[index + 1];\r\n                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);\r\n                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;\r\n                }\r\n                mCurrVelocity = velocityCoef * mDistance / mDuration * 1000.0f;\r\n                mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));\r\n                mCurrX = Math.min(mCurrX, mMaxX);\r\n                mCurrX = Math.max(mCurrX, mMinX);\r\n                mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));\r\n                mCurrY = Math.min(mCurrY, mMaxY);\r\n                mCurrY = Math.max(mCurrY, mMinY);\r\n                if (mCurrX == mFinalX && mCurrY == mFinalY) {\r\n                    mFinished = true;\r\n                }\r\n                break;\r\n        }\r\n    } else {\r\n        mCurrX = mFinalX;\r\n        mCurrY = mFinalY;\r\n        mFinished = true;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.android.launcher3.BaseRecyclerView.synchronizeScrollBarThumbOffsetToViewScroll",
	"Comment": "updates the scrollbar thumb offset to match the visible scroll of the recycler view.it doesthis by mapping the available scroll area of the recycler view to the available space for thescroll bar.",
	"Method": "void synchronizeScrollBarThumbOffsetToViewScroll(ScrollPositionState scrollPosState,int rowCount){\r\n    int availableScrollBarHeight = getAvailableScrollBarHeight();\r\n    int availableScrollHeight = getAvailableScrollHeight(rowCount, scrollPosState.rowHeight);\r\n    if (availableScrollHeight <= 0) {\r\n        mScrollbar.setThumbOffset(-1, -1);\r\n        return;\r\n    }\r\n    int scrollY = getPaddingTop() + (scrollPosState.rowIndex * scrollPosState.rowHeight) - scrollPosState.rowTopOffset;\r\n    int scrollBarY = mBackgroundPadding.top + (int) (((float) scrollY / availableScrollHeight) * availableScrollBarHeight);\r\n    int scrollBarX;\r\n    if (Utilities.isRtl(getResources())) {\r\n        scrollBarX = mBackgroundPadding.left;\r\n    } else {\r\n        scrollBarX = getWidth() - mBackgroundPadding.right - mScrollbar.getThumbWidth();\r\n    }\r\n    mScrollbar.setThumbOffset(scrollBarX, scrollBarY);\r\n}"
}, {
	"Path": "com.jdon.model.ModelHandlerManagerImp.makeModelObject",
	"Comment": "create model instance from the model class that read from the xml\tconfigure.",
	"Method": "Object makeModelObject(String formName){\r\n    Object object = null;\r\n    Class modelClass = null;\r\n    try {\r\n        modelClass = (Class) modelFactory.getModelClasses(formName);\r\n        if (modelClass == null) {\r\n            throw new Exception(\" not found the model in config xml, formName=\" + formName);\r\n        }\r\n        object = modelClass.newInstance();\r\n        modelProxyInjection.injectProperties(object);\r\n    } catch (Exception e) {\r\n        Debug.logError(\"[JdonFramework]--> call Model: \" + modelClass + \" error:\" + e, module);\r\n    }\r\n    return object;\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.importexport.DImportKeyPairPkcs8.getCertificateChain",
	"Comment": "get the certificate chain part of the key pair chosen by the user for\timport.",
	"Method": "Certificate[] getCertificateChain(){\r\n    return certificateChain;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.functor.Applicative.coerce",
	"Comment": "convenience method for coercing this applicative instance into another concrete type. unsafe.",
	"Method": "Concrete coerce(){\r\n    return (Concrete) this;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.VoronoiDiagramBuilder.setTolerance",
	"Comment": "sets the snapping tolerance which will be used\tto improved the robustness of the triangulation computation.\ta tolerance of 0.0 specifies that no snapping will take place.",
	"Method": "void setTolerance(double tolerance){\r\n    this.tolerance = tolerance;\r\n}"
}, {
	"Path": "com.jsql.view.swing.console.SwingAppender.insertText",
	"Comment": "colorizes the specified message for the specified log4j level.",
	"Method": "void insertText(String message,Level level,ThrowableInformation throwableInformation){\r\n    if (consoleTextPane == null || javaTextPane == null) {\r\n        return;\r\n    }\r\n    switch(level.toInt()) {\r\n        case Level.TRACE_INT:\r\n            if (throwableInformation == null || !(throwableInformation.getThrowable() instanceof IgnoreMessageException)) {\r\n                consoleTextPane.append(message, TRACE);\r\n            }\r\n            break;\r\n        case Priority.ERROR_INT:\r\n            javaTextPane.append(message, WARN);\r\n            javaTextPane.getProxy().setCaretPosition(javaTextPane.getProxy().getDocument().getLength());\r\n            if (throwableInformation != null && throwableInformation.getThrowableStrRep() != null) {\r\n                for (String rep : throwableInformation.getThrowableStrRep()) {\r\n                    javaTextPane.append(rep, ERROR);\r\n                }\r\n            }\r\n            break;\r\n        case Priority.WARN_INT:\r\n            consoleTextPane.append(message, WARN);\r\n            break;\r\n        case Priority.INFO_INT:\r\n            consoleTextPane.append(message, INFO);\r\n            break;\r\n        case Priority.DEBUG_INT:\r\n            consoleTextPane.append(message, DEBUG);\r\n            break;\r\n        case Priority.FATAL_INT:\r\n            break;\r\n        case Priority.ALL_INT:\r\n        default:\r\n            consoleTextPane.append(message, ALL);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.kse.crypto.keystore.KeyStoreUtil.loadMsCapiStore",
	"Comment": "load an ms capi store as a keystore. the keystore is not file based and\ttherefore does not need to be saved.",
	"Method": "KeyStore loadMsCapiStore(MsCapiStoreType msCapiStoreType){\r\n    if (!areMsCapiStoresSupported()) {\r\n        ApplicationSettings.getInstance().setUseWindowsTrustedRootCertificates(false);\r\n        throw new CryptoException(res.getString(\"MsCapiStoresNotSupported.exception.message\"));\r\n    }\r\n    KeyStore keyStore = null;\r\n    try {\r\n        keyStore = KeyStore.getInstance(msCapiStoreType.jce(), MS_CAPI.jce());\r\n    } catch (KeyStoreException ex) {\r\n        throw new CryptoException(MessageFormat.format(res.getString(\"NoCreateKeyStore.exception.message\"), msCapiStoreType.jce()), ex);\r\n    } catch (NoSuchProviderException ex) {\r\n        throw new CryptoException(MessageFormat.format(res.getString(\"NoCreateKeyStore.exception.message\"), msCapiStoreType.jce()), ex);\r\n    }\r\n    try {\r\n        keyStore.load(null, null);\r\n    } catch (NoSuchAlgorithmException ex) {\r\n        throw new CryptoException(MessageFormat.format(res.getString(\"NoLoadKeyStoreType.exception.message\"), msCapiStoreType.jce()), ex);\r\n    } catch (CertificateException ex) {\r\n        throw new CryptoException(MessageFormat.format(res.getString(\"NoLoadKeyStoreType.exception.message\"), msCapiStoreType.jce()), ex);\r\n    } catch (IOException ex) {\r\n        throw new CryptoException(MessageFormat.format(res.getString(\"NoLoadKeyStoreType.exception.message\"), msCapiStoreType.jce()), ex);\r\n    }\r\n    return keyStore;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.prep.PreparedPolygonIntersects.intersects",
	"Comment": "tests whether this preparedpolygon intersects a given geometry.",
	"Method": "boolean intersects(PreparedPolygon prep,Geometry geom,boolean intersects,Geometry geom){\r\n    boolean isInPrepGeomArea = isAnyTestComponentInTarget(geom);\r\n    if (isInPrepGeomArea)\r\n        return true;\r\n    if (geom.getDimension() == 0)\r\n        return false;\r\n    List lineSegStr = SegmentStringUtil.extractSegmentStrings(geom);\r\n    if (lineSegStr.size() > 0) {\r\n        boolean segsIntersect = prepPoly.getIntersectionFinder().intersects(lineSegStr);\r\n        if (segsIntersect)\r\n            return true;\r\n    }\r\n    if (geom.getDimension() == 2) {\r\n        boolean isPrepGeomInArea = isAnyTargetComponentInAreaTest(geom, prepPoly.getRepresentativePoints());\r\n        if (isPrepGeomInArea)\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.jsql.model.accessible.CallableHttpHead.isHttpResponseOk",
	"Comment": "check if http response is either 2xx or 3xx, which corrsponds toa acceptable response from the website.",
	"Method": "boolean isHttpResponseOk(){\r\n    return this.responseCodeHttp.matches(\".+[23]\\\\d\\\\d.+\");\r\n}"
}, {
	"Path": "com.jsql.i18n.I18n.checkCurrentLanguage",
	"Comment": "verify if there is a language properties file corresponding to the current system language.if not then it invites the user to use the translation process.",
	"Method": "void checkCurrentLanguage(){\r\n    URL path = I18n.class.getResource(\"/com/jsql/i18n/jsql_\" + Locale.getDefault().getLanguage() + \".properties\");\r\n    if (!\"en\".equals(Locale.getDefault().getLanguage()) && path == null) {\r\n        String languageHost = Locale.getDefault().getDisplayLanguage(Locale.ENGLISH);\r\n        LOGGER.debug(\"Language \" + languageHost + \" is not supported, \" + \"please contribute and translate pieces of jSQL into \" + languageHost + \": \" + \"click on the top right button and open menu [Community], choose a language using [I help translate jSQL] and \" + \"translate some text into \" + languageHost + \" then click on [Send]. The developer will add your translation \" + \"to the next release.\");\r\n    }\r\n}"
}, {
	"Path": "com.jdon.util.task.TaskEngine.nextTask",
	"Comment": "return the next task in the queue. if no task is available, this method\twill block until a task is added to the queue.",
	"Method": "Runnable nextTask(){\r\n    synchronized (lock) {\r\n        while (taskList.isEmpty()) {\r\n            try {\r\n                lock.wait();\r\n            } catch (InterruptedException ie) {\r\n            }\r\n        }\r\n        return (Runnable) taskList.removeLast();\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.Folder.positionAndSizeAsIcon",
	"Comment": "this method is intended to make the userfolder to be visually identical in size and positionto its associated foldericon. this allows for a seamless transition into the expanded state.",
	"Method": "void positionAndSizeAsIcon(){\r\n    if (!(getParent() instanceof DragLayer))\r\n        return;\r\n    setScaleX(0.8f);\r\n    setScaleY(0.8f);\r\n    setAlpha(0f);\r\n    mState = STATE_SMALL;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.events.ShutdownEvent.getCode",
	"Comment": "the server close code that was in the disconnect close frameof this jda instance.",
	"Method": "int getCode(){\r\n    return code;\r\n}"
}, {
	"Path": "com.android.launcher3.compat.LauncherActivityInfoCompat.fromResolveInfo",
	"Comment": "creates a launcheractivityinfocompat for the primary user.",
	"Method": "LauncherActivityInfoCompat fromResolveInfo(ResolveInfo info,Context context){\r\n    return new LauncherActivityInfoCompatV16(context, info);\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.Vertex.circleCenter",
	"Comment": "computes the centre of the circumcircle of this vertex and two others.",
	"Method": "Vertex circleCenter(Vertex b,Vertex c){\r\n    Vertex a = new Vertex(this.getX(), this.getY());\r\n    HCoordinate cab = bisector(a, b);\r\n    HCoordinate cbc = bisector(b, c);\r\n    HCoordinate hcc = new HCoordinate(cab, cbc);\r\n    Vertex cc = null;\r\n    try {\r\n        cc = new Vertex(hcc.getX(), hcc.getY());\r\n    } catch (NotRepresentableException nre) {\r\n        System.err.println(\"a: \" + a + \"  b: \" + b + \"  c: \" + c);\r\n        System.err.println(nre);\r\n    }\r\n    return cc;\r\n}"
}, {
	"Path": "com.android.launcher3.Workspace.onDropCompleted",
	"Comment": "called at the end of a drag which originated on the workspace.",
	"Method": "void onDropCompleted(View target,DragObject d,boolean isFlingToDelete,boolean success){\r\n    if (mDeferDropAfterUninstall) {\r\n        mDeferredAction = new Runnable() {\r\n            public void run() {\r\n                onDropCompleted(target, d, isFlingToDelete, success);\r\n                mDeferredAction = null;\r\n            }\r\n        };\r\n        return;\r\n    }\r\n    boolean beingCalledAfterUninstall = mDeferredAction != null;\r\n    if (success && !(beingCalledAfterUninstall && !mUninstallSuccessful)) {\r\n        if (target != this && mDragInfo != null) {\r\n            removeWorkspaceItem(mDragInfo.cell);\r\n        }\r\n    } else if (mDragInfo != null) {\r\n        final CellLayout cellLayout = mLauncher.getCellLayout(mDragInfo.container, mDragInfo.screenId);\r\n        if (cellLayout != null) {\r\n            cellLayout.onDropChild(mDragInfo.cell);\r\n        } else if (LauncherAppState.isDogfoodBuild()) {\r\n            throw new RuntimeException(\"Invalid state: cellLayout == null in \" + \"Workspace#onDropCompleted. Please file a bug. \");\r\n        }\r\n        ;\r\n    }\r\n    if ((d.cancelled || (beingCalledAfterUninstall && !mUninstallSuccessful)) && mDragInfo.cell != null) {\r\n        mDragInfo.cell.setVisibility(VISIBLE);\r\n    }\r\n    mDragOutline = null;\r\n    mDragInfo = null;\r\n}"
}, {
	"Path": "com.android.launcher3.Workspace.onDropCompleted",
	"Comment": "called at the end of a drag which originated on the workspace.",
	"Method": "void onDropCompleted(View target,DragObject d,boolean isFlingToDelete,boolean success){\r\n    onDropCompleted(target, d, isFlingToDelete, success);\r\n    mDeferredAction = null;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.VariableWidthBuffer.interpolate",
	"Comment": "computes a list of values for the points along a line byinterpolating between values for the start and end point.the interpolation isbased on the distance of each point along the linerelative to the total line length.",
	"Method": "double[] interpolate(LineString line,double start,double end){\r\n    start = Math.abs(start);\r\n    end = Math.abs(end);\r\n    double[] widths = new double[line.getNumPoints()];\r\n    widths[0] = start;\r\n    widths[widths.length - 1] = end;\r\n    double totalLen = line.getLength();\r\n    Coordinate[] pts = line.getCoordinates();\r\n    double currLen = 0;\r\n    for (int i = 1; i < widths.length; i++) {\r\n        double segLen = pts[i].distance(pts[i - 1]);\r\n        currLen += segLen;\r\n        double lenFrac = currLen / totalLen;\r\n        double delta = lenFrac * (end - start);\r\n        widths[i] = start + delta;\r\n    }\r\n    return widths;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.validate.BufferResultValidator.getErrorIndicator",
	"Comment": "gets a geometry which indicates the location and nature of a validation failure.if the failure is due to the buffer curve being too far or too close to the input, the indicator is a line segment showing the location and sizeof the discrepancy.",
	"Method": "Geometry getErrorIndicator(){\r\n    return errorIndicator;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.linemerge.LineSequencer.reverse",
	"Comment": "reverse the sequence.this requires reversing the order of the diredges, and flippingeach diredge as well",
	"Method": "List reverse(List seq,LineString reverse,LineString line){\r\n    Coordinate[] pts = line.getCoordinates();\r\n    Coordinate[] revPts = new Coordinate[pts.length];\r\n    int len = pts.length;\r\n    for (int i = 0; i < len; i++) {\r\n        revPts[len - 1 - i] = new Coordinate(pts[i]);\r\n    }\r\n    return line.getFactory().createLineString(revPts);\r\n}"
}, {
	"Path": "com.jdon.servicelocator.web.ServiceLocator.getLocalHome",
	"Comment": "will get the ejb local home factory. if this ejb home factory has already beenclients need to cast to the type of ejbhome they desire",
	"Method": "EJBLocalHome getLocalHome(String jndiHomeName){\r\n    Debug.logVerbose(\"[JdonFramework] -- > getLocalHome.... \", module);\r\n    EJBLocalHome home = null;\r\n    try {\r\n        if (cache.containsKey(jndiHomeName)) {\r\n            home = (EJBLocalHome) cache.get(jndiHomeName);\r\n        } else {\r\n            Debug.logVerbose(\"[JdonFramework]  lookUp LocalHome.... \", module);\r\n            home = (EJBLocalHome) ic.lookup(jndiHomeName);\r\n            cache.put(jndiHomeName, home);\r\n        }\r\n    } catch (NamingException ne) {\r\n        throw new ServiceLocatorException(ne);\r\n    } catch (Exception e) {\r\n        throw new ServiceLocatorException(e);\r\n    }\r\n    return home;\r\n}"
}, {
	"Path": "com.android.launcher3.allapps.AlphabeticalAppsList.getSections",
	"Comment": "returns sections of all the current filtered applications.",
	"Method": "List<SectionInfo> getSections(){\r\n    return mSections;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.GeometryFactory.createLineString",
	"Comment": "creates a linestring using the given coordinatesequence.a null or empty coordinatesequence creates an empty linestring.",
	"Method": "LineString createLineString(LineString createLineString,Coordinate[] coordinates,LineString createLineString,CoordinateSequence coordinates){\r\n    return new LineString(coordinates, this);\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.events.ExceptionEvent.isLogged",
	"Comment": "whether this throwable was already printed using the jda logging system",
	"Method": "boolean isLogged(){\r\n    return logged;\r\n}"
}, {
	"Path": "com.android.launcher3.model.AppNameComparator.compareTitles",
	"Comment": "compares two titles with the same return value semantics as comparator.",
	"Method": "int compareTitles(String titleA,String titleB){\r\n    boolean aStartsWithLetter = (titleA.length() > 0) && Character.isLetterOrDigit(titleA.codePointAt(0));\r\n    boolean bStartsWithLetter = (titleB.length() > 0) && Character.isLetterOrDigit(titleB.codePointAt(0));\r\n    if (aStartsWithLetter && !bStartsWithLetter) {\r\n        return -1;\r\n    } else if (!aStartsWithLetter && bStartsWithLetter) {\r\n        return 1;\r\n    }\r\n    return mCollator.compare(titleA, titleB);\r\n}"
}, {
	"Path": "org.kse.gui.dnd.DragTrustedCertificateEntry.getExtension",
	"Comment": "get entry file extension. used to generate dragged file name.",
	"Method": "String getExtension(){\r\n    return EXTENSION;\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.EdgeIntersectionList.addEndpoints",
	"Comment": "adds entries for the first and last points of the edge to the list",
	"Method": "void addEndpoints(){\r\n    int maxSegIndex = edge.pts.length - 1;\r\n    add(edge.pts[0], 0, 0.0);\r\n    add(edge.pts[maxSegIndex], maxSegIndex, 0.0);\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.EdgeEndStar.insertEdgeEnd",
	"Comment": "insert an edgeend into the map, and clear the edgelist cache,since the list of edges has now changed",
	"Method": "void insertEdgeEnd(EdgeEnd e,Object obj){\r\n    edgeMap.put(e, obj);\r\n    edgeList = null;\r\n}"
}, {
	"Path": "org.locationtech.jts.io.oracle.OraWriter.isWriteAsRectangle",
	"Comment": "tests if a polygon can be written aa a rectangle.rectangles are only supported without a srid!",
	"Method": "boolean isWriteAsRectangle(Polygon polygon){\r\n    if (!isOptimizeRectangle)\r\n        return false;\r\n    if (lrsDim(polygon) != 0) {\r\n        return false;\r\n    }\r\n    return polygon.isRectangle();\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.startGlobalSearch",
	"Comment": "starts the global search activity. this code is a copied from searchmanager",
	"Method": "void startGlobalSearch(String initialQuery,boolean selectInitialQuery,Bundle appSearchData,Rect sourceBounds){\r\n    final SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);\r\n    ComponentName globalSearchActivity = searchManager.getGlobalSearchActivity();\r\n    if (globalSearchActivity == null) {\r\n        Log.w(TAG, \"No global search activity found.\");\r\n        return;\r\n    }\r\n    Intent intent = new Intent(SearchManager.INTENT_ACTION_GLOBAL_SEARCH);\r\n    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\r\n    intent.setComponent(globalSearchActivity);\r\n    if (appSearchData == null) {\r\n        appSearchData = new Bundle();\r\n    } else {\r\n        appSearchData = new Bundle(appSearchData);\r\n    }\r\n    if (!appSearchData.containsKey(\"source\")) {\r\n        appSearchData.putString(\"source\", getPackageName());\r\n    }\r\n    intent.putExtra(SearchManager.APP_DATA, appSearchData);\r\n    if (!TextUtils.isEmpty(initialQuery)) {\r\n        intent.putExtra(SearchManager.QUERY, initialQuery);\r\n    }\r\n    if (selectInitialQuery) {\r\n        intent.putExtra(SearchManager.EXTRA_SELECT_QUERY, selectInitialQuery);\r\n    }\r\n    intent.setSourceBounds(sourceBounds);\r\n    try {\r\n        startActivity(intent);\r\n    } catch (ActivityNotFoundException ex) {\r\n        Log.e(TAG, \"Global search activity not found: \" + globalSearchActivity);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.prep.BasicPreparedGeometry.envelopesIntersect",
	"Comment": "determines whether a geometry g interacts with this geometry by testing the geometry envelopes.",
	"Method": "boolean envelopesIntersect(Geometry g){\r\n    if (!baseGeom.getEnvelopeInternal().intersects(g.getEnvelopeInternal()))\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.Coordinates.create",
	"Comment": "factory method providing access to common coordinate implementations.",
	"Method": "Coordinate create(int dimension,Coordinate create,int dimension,int measures){\r\n    if (dimension == 2) {\r\n        return new CoordinateXY();\r\n    } else if (dimension == 3 && measures == 0) {\r\n        return new Coordinate();\r\n    } else if (dimension == 3 && measures == 1) {\r\n        return new CoordinateXYM();\r\n    } else if (dimension == 4 && measures == 1) {\r\n        return new CoordinateXYZM();\r\n    }\r\n    return new Coordinate();\r\n}"
}, {
	"Path": "org.locationtech.jtstest.geomop.StaticMethodGeometryFunction.createFullArgs",
	"Comment": "creates an arg array which includes the target geometry as the first argument",
	"Method": "Object[] createFullArgs(Geometry g,Object[] arg){\r\n    int fullArgLen = 1;\r\n    if (arg != null)\r\n        fullArgLen = arg.length + 1;\r\n    Object[] fullArg = new Object[fullArgLen];\r\n    fullArg[0] = g;\r\n    for (int i = 1; i < fullArgLen; i++) {\r\n        fullArg[i] = arg[i - 1];\r\n    }\r\n    return fullArg;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct7.converge",
	"Comment": "converge this coproduct down to a lower order coproduct by mapping the last possible type into an earlierpossible type.",
	"Method": "CoProduct6<A, B, C, D, E, F, ? extends CoProduct6<A, B, C, D, E, F, ?>> converge(Function<? super G, ? extends CoProduct6<A, B, C, D, E, F, ?>> convergenceFn){\r\n    return match(Choice6::a, Choice6::b, Choice6::c, Choice6::d, Choice6::e, Choice6::f, convergenceFn::apply);\r\n}"
}, {
	"Path": "org.locationtech.jts.simplify.TaggedLineStringSimplifier.isInLineSection",
	"Comment": "tests whether a segment is in a section of a taggedlinestring",
	"Method": "boolean isInLineSection(TaggedLineString line,int[] sectionIndex,TaggedLineSegment seg){\r\n    if (seg.getParent() != line.getParent())\r\n        return false;\r\n    int segIndex = seg.getIndex();\r\n    if (segIndex >= sectionIndex[0] && segIndex < sectionIndex[1])\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.PolygonizeGraph.convertMaximalToMinimalEdgeRings",
	"Comment": "convert the maximal edge rings found by the initial graph traversalinto the minimal edge rings required by jts polygon topology rules.",
	"Method": "void convertMaximalToMinimalEdgeRings(List ringEdges){\r\n    for (Iterator i = ringEdges.iterator(); i.hasNext(); ) {\r\n        PolygonizeDirectedEdge de = (PolygonizeDirectedEdge) i.next();\r\n        long label = de.getLabel();\r\n        List intNodes = findIntersectionNodes(de, label);\r\n        if (intNodes == null)\r\n            continue;\r\n        for (Iterator iNode = intNodes.iterator(); iNode.hasNext(); ) {\r\n            Node node = (Node) iNode.next();\r\n            computeNextCCWEdges(node, label);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.PagedView.updateCurrentPageScroll",
	"Comment": "updates the scroll of the current page immediately to its final scroll position.we use thisin customizepagedview to allow tabs to share the same pagedview while resetting the scroll ofthe previous tab page.",
	"Method": "void updateCurrentPageScroll(){\r\n    int newX = 0;\r\n    if (0 <= mCurrentPage && mCurrentPage < getPageCount()) {\r\n        newX = getScrollForPage(mCurrentPage);\r\n    }\r\n    scrollTo(newX, 0);\r\n    mScroller.setFinalX(newX);\r\n    forceFinishScroller();\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DD.toStandardNotation",
	"Comment": "returns the string representation of this value in standard notation.",
	"Method": "String toStandardNotation(){\r\n    String specialStr = getSpecialNumberString();\r\n    if (specialStr != null)\r\n        return specialStr;\r\n    int[] magnitude = new int[1];\r\n    String sigDigits = extractSignificantDigits(true, magnitude);\r\n    int decimalPointPos = magnitude[0] + 1;\r\n    String num = sigDigits;\r\n    if (sigDigits.charAt(0) == '.') {\r\n        num = \"0\" + sigDigits;\r\n    } else if (decimalPointPos < 0) {\r\n        num = \"0.\" + stringOfChar('0', -decimalPointPos) + sigDigits;\r\n    } else if (sigDigits.indexOf('.') == -1) {\r\n        int numZeroes = decimalPointPos - sigDigits.length();\r\n        String zeroes = stringOfChar('0', numZeroes);\r\n        num = sigDigits + zeroes + \".0\";\r\n    }\r\n    if (this.isNegative())\r\n        return \"-\" + num;\r\n    return num;\r\n}"
}, {
	"Path": "com.jdon.util.StringUtil.encodeString",
	"Comment": "encode a string using base64 encoding. used when storing passwords as\tcookies.\tthis is weak encoding in that anyone can use the decodestring routine to\treverse the encoding.",
	"Method": "String encodeString(String str){\r\n    return Base64.encodeBytes((str.getBytes())).trim();\r\n}"
}, {
	"Path": "org.kse.gui.KseFrame.showHideStatusBar",
	"Comment": "if the status bar is currently displayed hide it and vice versa.",
	"Method": "void showHideStatusBar(){\r\n    Container contentPane = frame.getContentPane();\r\n    boolean statusBarShown = false;\r\n    for (int i = 0; i < contentPane.getComponentCount(); i++) {\r\n        if (contentPane.getComponent(i).equals(jlStatusBar)) {\r\n            statusBarShown = true;\r\n            break;\r\n        }\r\n    }\r\n    if (statusBarShown) {\r\n        frame.getContentPane().remove(jlStatusBar);\r\n        applicationSettings.setShowStatusBar(false);\r\n    } else {\r\n        frame.getContentPane().add(jlStatusBar, BorderLayout.SOUTH);\r\n        applicationSettings.setShowStatusBar(true);\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.InstallShortcutReceiver.convertToLauncherActivityIfPossible",
	"Comment": "tries to create a new pendinginstallshortcutinfo which represents the same target,but is an app target and not a shortcut.",
	"Method": "PendingInstallShortcutInfo convertToLauncherActivityIfPossible(PendingInstallShortcutInfo original){\r\n    if (original.isLuncherActivity()) {\r\n        return original;\r\n    }\r\n    if (!Utilities.isLauncherAppTarget(original.launchIntent) || !original.user.equals(UserHandleCompat.myUserHandle())) {\r\n        return original;\r\n    }\r\n    PackageManager pm = original.mContext.getPackageManager();\r\n    ResolveInfo info = pm.resolveActivity(original.launchIntent, 0);\r\n    if (info == null) {\r\n        return original;\r\n    }\r\n    LauncherActivityInfoCompat launcherInfo = LauncherActivityInfoCompat.fromResolveInfo(info, original.mContext);\r\n    return new PendingInstallShortcutInfo(launcherInfo, original.mContext);\r\n}"
}, {
	"Path": "org.kse.gui.actions.TrustedCertificateDetailsAction.showCertificateSelectedEntry",
	"Comment": "show the certificate details of the selected keystore entry.",
	"Method": "void showCertificateSelectedEntry(){\r\n    try {\r\n        KeyStoreHistory history = kseFrame.getActiveKeyStoreHistory();\r\n        KeyStore keyStore = history.getCurrentState().getKeyStore();\r\n        String alias = kseFrame.getSelectedEntryAlias();\r\n        X509Certificate[] certs = new X509Certificate[1];\r\n        certs[0] = X509CertUtil.convertCertificate(keyStore.getCertificate(alias));\r\n        DViewCertificate dViewCertificate = new DViewCertificate(frame, MessageFormat.format(res.getString(\"TrustedCertificateDetailsAction.CertDetailsEntry.Title\"), alias), certs, kseFrame, DViewCertificate.EXPORT);\r\n        dViewCertificate.setLocationRelativeTo(frame);\r\n        dViewCertificate.setVisible(true);\r\n    } catch (Exception ex) {\r\n        DError.displayError(frame, ex);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.PointLocation.locateInRing",
	"Comment": "determines whether a point lies in the interior, on the boundary, or in theexterior of a ring. the ring may be oriented in either direction.this method does not first check the point against the envelope ofthe ring.",
	"Method": "int locateInRing(Coordinate p,Coordinate[] ring){\r\n    return RayCrossingCounter.locatePointInRing(p, ring);\r\n}"
}, {
	"Path": "org.locationtech.jts.shape.random.RandomPointsInGridBuilder.setConstrainedToCircle",
	"Comment": "sets whether generated points are constrained to liewithin a circle contained within each grid cell.this provides greater separation between pointsin adjacent cells.the default is to not be constrained to a circle.",
	"Method": "void setConstrainedToCircle(boolean isConstrainedToCircle){\r\n    this.isConstrainedToCircle = isConstrainedToCircle;\r\n}"
}, {
	"Path": "org.locationtech.jts.simplify.GeometryOperationValidator.test",
	"Comment": "tests if the result is valid.throws an exception if result is not valid.this allows chaining multiple tests together.",
	"Method": "void test(){\r\n    testSameStructure();\r\n    testValid();\r\n    testExpectedResult();\r\n}"
}, {
	"Path": "com.jdon.controller.WebAppUtil.getInterceptorKey",
	"Comment": "get the key for the interceptor, by the key, use can add his interceptor\tto the container",
	"Method": "String getInterceptorKey(){\r\n    return InterceptorsChain.NAME;\r\n}"
}, {
	"Path": "org.locationtech.jts.io.oracle.OraUtil.toIntArray",
	"Comment": "converts an oracle array into a int array, with a default value used to represent null values.",
	"Method": "int[] toIntArray(ARRAY array,int defaultValue,int[] toIntArray,Datum data,int defaultValue){\r\n    if (data == null)\r\n        return null;\r\n    int[] array = new int[data.length];\r\n    for (int i = 0; i < data.length; i++) {\r\n        array[i] = toInteger(data[i], defaultValue);\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.DirectedEdgeStar.computeDepths",
	"Comment": "compute the directededge depths for a subsequence of the edge array.",
	"Method": "void computeDepths(DirectedEdge de,int computeDepths,int startIndex,int endIndex,int startDepth){\r\n    int currDepth = startDepth;\r\n    for (int i = startIndex; i < endIndex; i++) {\r\n        DirectedEdge nextDe = (DirectedEdge) edgeList.get(i);\r\n        Label label = nextDe.getLabel();\r\n        nextDe.setEdgeDepths(Position.RIGHT, currDepth);\r\n        currDepth = nextDe.getDepth(Position.LEFT);\r\n    }\r\n    return currDepth;\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DDIOTest.writeRepeatedSqr",
	"Comment": "this routine simply tests for robustness of the tostring function.",
	"Method": "void writeRepeatedSqr(DD xdd){\r\n    if (xdd.ge(DD.valueOf(1)))\r\n        throw new IllegalArgumentException(\"Argument must be < 1\");\r\n    int count = 0;\r\n    while (xdd.doubleValue() > 1e-300) {\r\n        count++;\r\n        if (count == 100)\r\n            count = count;\r\n        double x = xdd.doubleValue();\r\n        DD xSqr = xdd.sqr();\r\n        String s = xSqr.toString();\r\n        DD xSqr2 = DD.parse(s);\r\n        xdd = xSqr;\r\n    }\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.IfdData.equals",
	"Comment": "returns true if all tags in this two ifds are equal. note that tags ofifds offset or thumbnail offset will be ignored.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj == null) {\r\n        return false;\r\n    }\r\n    if (obj instanceof IfdData) {\r\n        IfdData data = (IfdData) obj;\r\n        if (data.getId() == mIfdId && data.getTagCount() == getTagCount()) {\r\n            ExifTag[] tags = data.getAllTags();\r\n            for (ExifTag tag : tags) {\r\n                if (ExifInterface.isOffsetTag(tag.getTagId())) {\r\n                    continue;\r\n                }\r\n                ExifTag tag2 = mExifTags.get(tag.getTagId());\r\n                if (!tag.equals(tag2)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.requests.Requester.execute",
	"Comment": "used to execute a request. processes request related to provided bucket.",
	"Method": "Long execute(Request<?> apiRequest,Long execute,Request<?> apiRequest,boolean handleOnRateLimit,Long execute,Request<?> apiRequest,boolean retried,boolean handleOnRatelimit){\r\n    Route.CompiledRoute route = apiRequest.getRoute();\r\n    Long retryAfter = rateLimiter.getRateLimit(route);\r\n    if (retryAfter != null) {\r\n        if (handleOnRatelimit)\r\n            apiRequest.handleResponse(new Response(retryAfter, Collections.emptySet()));\r\n        return retryAfter;\r\n    }\r\n    okhttp3.Request.Builder builder = new okhttp3.Request.Builder();\r\n    String url = DISCORD_API_PREFIX + route.getCompiledRoute();\r\n    builder.url(url);\r\n    String method = apiRequest.getRoute().getMethod().toString();\r\n    RequestBody body = apiRequest.getBody();\r\n    if (body == null && HttpMethod.requiresRequestBody(method))\r\n        body = EMPTY_BODY;\r\n    builder.method(method, body).header(\"user-agent\", USER_AGENT).header(\"accept-encoding\", \"gzip\");\r\n    if (url.startsWith(DISCORD_API_PREFIX) && api.getToken() != null)\r\n        builder.header(\"authorization\", api.getToken());\r\n    if (apiRequest.getHeaders() != null) {\r\n        for (Entry<String, String> header : apiRequest.getHeaders().entrySet()) builder.addHeader(header.getKey(), header.getValue());\r\n    }\r\n    okhttp3.Request request = builder.build();\r\n    Set<String> rays = new LinkedHashSet();\r\n    okhttp3.Response[] responses = new okhttp3.Response[4];\r\n    okhttp3.Response lastResponse = null;\r\n    try {\r\n        int attempt = 0;\r\n        do {\r\n            Call call = httpClient.newCall(request);\r\n            lastResponse = call.execute();\r\n            responses[attempt] = lastResponse;\r\n            String cfRay = lastResponse.header(\"CF-RAY\");\r\n            if (cfRay != null)\r\n                rays.add(cfRay);\r\n            if (lastResponse.code() < 500)\r\n                break;\r\n            attempt++;\r\n            LOG.debug(\"Requesting {} -> {} returned status {}... retrying (attempt {})\", apiRequest.getRoute().getMethod(), url, lastResponse.code(), attempt);\r\n            try {\r\n                Thread.sleep(50 * attempt);\r\n            } catch (InterruptedException ignored) {\r\n            }\r\n        } while (attempt < 3 && lastResponse.code() >= 500);\r\n        if (lastResponse.code() >= 500) {\r\n            Response response = new Response(lastResponse, -1, rays);\r\n            apiRequest.handleResponse(response);\r\n            return null;\r\n        }\r\n        retryAfter = rateLimiter.handleResponse(route, lastResponse);\r\n        if (!rays.isEmpty())\r\n            LOG.debug(\"Received response with following cf-rays: {}\", rays);\r\n        if (retryAfter == null)\r\n            apiRequest.handleResponse(new Response(lastResponse, -1, rays));\r\n        else if (handleOnRatelimit)\r\n            apiRequest.handleResponse(new Response(lastResponse, retryAfter, rays));\r\n        return retryAfter;\r\n    } catch (SocketTimeoutException e) {\r\n        if (retryOnTimeout && !retried)\r\n            return execute(apiRequest, true, handleOnRatelimit);\r\n        LOG.error(\"Requester timed out while executing a request\", e);\r\n        apiRequest.handleResponse(new Response(lastResponse, e, rays));\r\n        return null;\r\n    } catch (Exception e) {\r\n        LOG.error(\"There was an exception while executing a REST request\", e);\r\n        apiRequest.handleResponse(new Response(lastResponse, e, rays));\r\n        return null;\r\n    } finally {\r\n        for (okhttp3.Response r : responses) {\r\n            if (r == null)\r\n                break;\r\n            r.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.BufferOp.getResultGeometry",
	"Comment": "returns the buffer computed for a geometry for a given buffer distance.",
	"Method": "Geometry getResultGeometry(double distance){\r\n    this.distance = distance;\r\n    computeGeometry();\r\n    return resultGeometry;\r\n}"
}, {
	"Path": "com.jsql.model.accessible.RessourceAccess.createSqlShell",
	"Comment": "create sql shell on the server. override user name and password eventually.",
	"Method": "void createSqlShell(String pathShell,String urlShell,String username,String password){\r\n    if (!RessourceAccess.isReadingAllowed()) {\r\n        return;\r\n    }\r\n    String sourceShellToInject = PropertiesUtil.getInstance().getProperties().getProperty(\"shell.sql\").replace(DataAccess.LEAD_IN_SHELL, DataAccess.LEAD).replace(DataAccess.TRAIL_IN_SHELL, DataAccess.TRAIL);\r\n    String pathShellFixed = pathShell;\r\n    if (!pathShellFixed.matches(\".*/$\")) {\r\n        pathShellFixed += \"/\";\r\n    }\r\n    MediatorModel.model().injectWithoutIndex(MediatorModel.model().getVendor().instance().sqlTextIntoFile(sourceShellToInject, pathShellFixed + FILENAME_SQLSHELL));\r\n    String resultInjection;\r\n    String[] sourcePage = { \"\" };\r\n    try {\r\n        resultInjection = new SuspendableGetRows().run(MediatorModel.model().getVendor().instance().sqlFileRead(pathShellFixed + FILENAME_SQLSHELL), sourcePage, false, 1, null);\r\n        if (\"\".equals(resultInjection)) {\r\n            throw new JSqlException(\"payload integrity verification: Empty payload\");\r\n        }\r\n    } catch (JSqlException e) {\r\n        throw new JSqlException(\"injected payload does not match source\", e);\r\n    }\r\n    if (!urlShell.isEmpty()) {\r\n        urlShell = urlShell.replaceAll(\"/*$\", \"\") + \"/\";\r\n    }\r\n    String url = urlShell;\r\n    if (\"\".equals(url)) {\r\n        url = ConnectionUtil.getUrlBase();\r\n    }\r\n    if (resultInjection.indexOf(sourceShellToInject) > -1) {\r\n        LOGGER.debug(\"SQL payload created into \\\"\" + pathShellFixed + FILENAME_SQLSHELL + \"\\\"\");\r\n        String urlWithoutProtocol = url.replaceAll(\"^https?://[^/]*\", \"\");\r\n        String urlProtocol;\r\n        if (\"/\".equals(urlWithoutProtocol)) {\r\n            urlProtocol = url.replaceAll(\"/+$\", \"\");\r\n        } else {\r\n            urlProtocol = url.replace(urlWithoutProtocol, \"\");\r\n        }\r\n        String urlWithoutFileName = urlWithoutProtocol.replaceAll(\"[^/]*$\", \"\").replaceAll(\"/+\", \"/\");\r\n        List<String> directoryNames = new ArrayList();\r\n        if (urlWithoutFileName.split(\"/\").length == 0) {\r\n            directoryNames.add(\"/\");\r\n        }\r\n        for (String directoryName : urlWithoutFileName.split(\"/\")) {\r\n            directoryNames.add(directoryName + \"/\");\r\n        }\r\n        ExecutorService taskExecutor = Executors.newFixedThreadPool(10, new ThreadFactoryCallable(\"CallableCreateSqlShell\"));\r\n        CompletionService<CallableHttpHead> taskCompletionService = new ExecutorCompletionService(taskExecutor);\r\n        StringBuilder urlPart = new StringBuilder();\r\n        for (String segment : directoryNames) {\r\n            urlPart.append(segment);\r\n            taskCompletionService.submit(new CallableHttpHead(urlProtocol + urlPart.toString() + FILENAME_SQLSHELL));\r\n        }\r\n        int submittedTasks = directoryNames.size() * 1;\r\n        int tasksHandled;\r\n        String urlSuccess = null;\r\n        for (tasksHandled = 0; tasksHandled < submittedTasks; tasksHandled++) {\r\n            try {\r\n                CallableHttpHead currentCallable = taskCompletionService.take().get();\r\n                if (currentCallable.isHttpResponseOk()) {\r\n                    urlSuccess = currentCallable.getUrl();\r\n                    if (!urlShell.isEmpty() && urlSuccess.replace(FILENAME_SQLSHELL, \"\").equals(urlShell) || urlSuccess.replace(FILENAME_SQLSHELL, \"\").equals(urlProtocol + urlWithoutFileName)) {\r\n                        LOGGER.debug(\"Connection to payload found at expected location \\\"\" + urlSuccess + \"\\\"\");\r\n                    } else {\r\n                        LOGGER.debug(\"Connection to payload found at unexpected location \\\"\" + urlSuccess + \"\\\"\");\r\n                    }\r\n                } else {\r\n                    LOGGER.trace(\"Connection to payload not found at \\\"\" + currentCallable.getUrl() + \"\\\"\");\r\n                }\r\n            } catch (InterruptedException | ExecutionException e) {\r\n                LOGGER.error(\"Interruption while checking SQL shell\", e);\r\n            }\r\n        }\r\n        taskExecutor.shutdown();\r\n        taskExecutor.awaitTermination(5, TimeUnit.SECONDS);\r\n        if (urlSuccess != null) {\r\n            Request request = new Request();\r\n            request.setMessage(Interaction.CREATE_SQL_SHELL_TAB);\r\n            request.setParameters(pathShellFixed.replace(FILENAME_SQLSHELL, \"\"), urlSuccess, username, password);\r\n            MediatorModel.model().sendToViews(request);\r\n        } else {\r\n            LOGGER.warn(\"HTTP connection to SQL payload not found\");\r\n        }\r\n    } else {\r\n        throw new JSqlException(\"Incorrect SQL payload integrity: \" + sourcePage[0].trim().replaceAll(\"\\\\n\", \"\\\\\\\\\\\\n\"));\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.Hotseat.getCellXFromOrder",
	"Comment": "get the orientation specific coordinates given an invariant order in the hotseat.",
	"Method": "int getCellXFromOrder(int rank){\r\n    return mHasVerticalHotseat ? 0 : rank;\r\n}"
}, {
	"Path": "org.kse.gui.FileChooserFactory.getOpenSslPvkFileChooser",
	"Comment": "get a jfilechooser filtered for openssl private key files.",
	"Method": "JFileChooser getOpenSslPvkFileChooser(){\r\n    JFileChooser chooser = getFileChooser();\r\n    chooser.addChoosableFileFilter(new FileExtFilter(new String[] { OPENSSL_PVK_EXT }, OPENSSL_PVK_FILE_DESC));\r\n    return chooser;\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.SegmentNodeList.getSplitCoordinates",
	"Comment": "gets the list of coordinates for the fully noded segment string,including all original segment string vertices and verticesintroduced by nodes in this list.repeated coordinates are collapsed.",
	"Method": "Coordinate[] getSplitCoordinates(){\r\n    CoordinateList coordList = new CoordinateList();\r\n    addEndpoints();\r\n    Iterator it = iterator();\r\n    SegmentNode eiPrev = (SegmentNode) it.next();\r\n    while (it.hasNext()) {\r\n        SegmentNode ei = (SegmentNode) it.next();\r\n        addEdgeCoordinates(eiPrev, ei, coordList);\r\n        eiPrev = ei;\r\n    }\r\n    return coordList.toCoordinateArray();\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.CoordinateArrays.removeRepeatedPoints",
	"Comment": "if the coordinate array argument has repeated points,constructs a new array containing no repeated points.otherwise, returns the argument.",
	"Method": "Coordinate[] removeRepeatedPoints(Coordinate[] coord){\r\n    if (!hasRepeatedPoints(coord))\r\n        return coord;\r\n    CoordinateList coordList = new CoordinateList(coord, false);\r\n    return coordList.toCoordinateArray();\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.requests.restaction.pagination.PaginationAction.getLast",
	"Comment": "the most recent entity retrieved by this paginationaction instance",
	"Method": "T getLast(){\r\n    final T last = this.last;\r\n    if (last == null)\r\n        throw new NoSuchElementException(\"No entities have been retrieved yet.\");\r\n    return last;\r\n}"
}, {
	"Path": "org.kse.gui.crypto.accessdescription.AccessDescriptionsTableModel.load",
	"Comment": "load the accessdescriptionstablemodel with access descriptions.",
	"Method": "void load(List<AccessDescription> accessDescriptions){\r\n    AccessDescription[] accessDescriptionsArray = accessDescriptions.toArray(new AccessDescription[accessDescriptions.size()]);\r\n    Arrays.sort(accessDescriptionsArray, new AccessDescriptionMethodComparator());\r\n    data = new Object[accessDescriptionsArray.length][2];\r\n    int i = 0;\r\n    for (AccessDescription accessDescription : accessDescriptionsArray) {\r\n        data[i][0] = accessDescription;\r\n        data[i][1] = accessDescription;\r\n        i++;\r\n    }\r\n    fireTableDataChanged();\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision.isFrameEdge",
	"Comment": "tests whether a quadedge is an edge incident on a frame triangle vertex.",
	"Method": "boolean isFrameEdge(QuadEdge e){\r\n    if (isFrameVertex(e.orig()) || isFrameVertex(e.dest()))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.locationtech.jts.math.Vector2D.equals",
	"Comment": "tests if a vector o has the same values for the x and y\tcomponents.",
	"Method": "boolean equals(Object o){\r\n    if (!(o instanceof Vector2D)) {\r\n        return false;\r\n    }\r\n    Vector2D v = (Vector2D) o;\r\n    return x == v.x && y == v.y;\r\n}"
}, {
	"Path": "org.locationtech.jts.edgegraph.EdgeGraph.createEdge",
	"Comment": "creates a single halfedge.override to use a different halfedge subclass.",
	"Method": "HalfEdge createEdge(Coordinate orig){\r\n    return new HalfEdge(orig);\r\n}"
}, {
	"Path": "org.kse.crypto.jcepolicy.JcePolicyUtil.getJcePolicyDownloadUrl",
	"Comment": "get jce unlimited strength jurisdiction policy download url for the\tcurrent jre.",
	"Method": "String getJcePolicyDownloadUrl(){\r\n    JavaVersion jreVersion = JavaVersion.getJreVersion();\r\n    int major = jreVersion.getMajor();\r\n    int middle = jreVersion.getMinor();\r\n    int minor = jreVersion.getSecurity();\r\n    String version = MessageFormat.format(\"{0}.{1}.{2}\", major, middle, minor);\r\n    String url = MessageFormat.format(URLs.JCE_POLICY_DOWNLOAD_URL, version);\r\n    return url;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.distance.ConnectedElementPointFilter.getCoordinates",
	"Comment": "returns a list containing a coordinate from each polygon, linestring, and pointfound inside the specified geometry. thus, if the specified geometry isnot a geometrycollection, an empty list will be returned.",
	"Method": "List getCoordinates(Geometry geom){\r\n    List pts = new ArrayList();\r\n    geom.apply(new ConnectedElementPointFilter(pts));\r\n    return pts;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.valid.IsValidOp.checkShellInsideHole",
	"Comment": "this routine checks to see if a shell is properly contained in a hole.it assumes that the edges of the shell and hole do notproperly intersect.",
	"Method": "Coordinate checkShellInsideHole(LinearRing shell,LinearRing hole,GeometryGraph graph){\r\n    Coordinate[] shellPts = shell.getCoordinates();\r\n    Coordinate[] holePts = hole.getCoordinates();\r\n    Coordinate shellPt = findPtNotNode(shellPts, hole, graph);\r\n    if (shellPt != null) {\r\n        boolean insideHole = PointLocation.isInRing(shellPt, holePts);\r\n        if (!insideHole) {\r\n            return shellPt;\r\n        }\r\n    }\r\n    Coordinate holePt = findPtNotNode(holePts, shell, graph);\r\n    if (holePt != null) {\r\n        boolean insideShell = PointLocation.isInRing(holePt, shellPts);\r\n        if (insideShell) {\r\n            return holePt;\r\n        }\r\n        return null;\r\n    }\r\n    Assert.shouldNeverReachHere(\"points in shell and hole appear to be equal\");\r\n    return null;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.LinearRing.getBoundaryDimension",
	"Comment": "returns dimension.false, since by definition linearrings donot have a boundary.",
	"Method": "int getBoundaryDimension(){\r\n    return Dimension.FALSE;\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testbuilder.ui.tools.BoxBandTool.getEnvelope",
	"Comment": "gets the envelope of the indicated rectangle,in model coordinates.",
	"Method": "Envelope getEnvelope(){\r\n    Coordinate start = toModelSnapped(zoomBoxStart);\r\n    Coordinate end = toModelSnapped(zoomBoxEnd);\r\n    return new Envelope(start, end);\r\n}"
}, {
	"Path": "org.locationtech.jtstest.geomop.OverlayValidatedGeometryOperation.invokeValidatedOverlayOp",
	"Comment": "invokes an overlay op, optionally using snapping,and optionally validating the result.",
	"Method": "Result invokeValidatedOverlayOp(int opCode,Geometry g0,Object[] args){\r\n    Geometry result = null;\r\n    Geometry g1 = (Geometry) args[0];\r\n    result = invokeGeometryOverlayMethod(opCode, g0, g1);\r\n    validate(opCode, g0, g1, result);\r\n    areaValidate(g0, g1);\r\n    if (returnEmptyGC) {\r\n        result = result.getFactory().createGeometryCollection(null);\r\n    }\r\n    return new GeometryResult(result);\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.lens.Lens.both",
	"Comment": "dually focus on two lenses at the same time. requires s and t to be invariant betweenlenses.",
	"Method": "Lens<S, S, Tuple2<A, B>, Tuple2<C, D>> both(Lens<S, S, A, C> f,Lens<S, S, B, D> g,Lens.Simple<S, Tuple2<A, B>> both,Lens.Simple<S, A> f,Lens.Simple<S, B> g,Lens.Simple<S, Tuple2<A, B>> both,Lens<S, S, A, A> f,Lens<S, S, B, B> g){\r\n    return adapt(both((Lens<S, S, A, A>) f, g));\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isUSPhoneAreaCode",
	"Comment": "isusphoneareacode returns true if string s is a valid u.s. phone area code.must be 3 digits.",
	"Method": "boolean isUSPhoneAreaCode(String s){\r\n    if (isEmpty(s))\r\n        return defaultEmptyOK;\r\n    String normalizedPhone = stripCharsInBag(s, phoneNumberDelimiters);\r\n    return (isInteger(normalizedPhone) && normalizedPhone.length() == digitsInUSPhoneAreaCode);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.OffsetSegmentGenerator.addCornerFillet",
	"Comment": "add points for a circular fillet around a reflex corner.adds the start and end points",
	"Method": "void addCornerFillet(Coordinate p,Coordinate p0,Coordinate p1,int direction,double radius){\r\n    double dx0 = p0.x - p.x;\r\n    double dy0 = p0.y - p.y;\r\n    double startAngle = Math.atan2(dy0, dx0);\r\n    double dx1 = p1.x - p.x;\r\n    double dy1 = p1.y - p.y;\r\n    double endAngle = Math.atan2(dy1, dx1);\r\n    if (direction == Orientation.CLOCKWISE) {\r\n        if (startAngle <= endAngle)\r\n            startAngle += 2.0 * Math.PI;\r\n    } else {\r\n        if (startAngle >= endAngle)\r\n            startAngle -= 2.0 * Math.PI;\r\n    }\r\n    segList.addPt(p0);\r\n    addDirectedFillet(p, startAngle, endAngle, direction, radius);\r\n    segList.addPt(p1);\r\n}"
}, {
	"Path": "com.jdon.servicelocator.web.ServiceLocator.getRemoteHome",
	"Comment": "will get the ejb remote home factory. if this ejb home factory has already beenclients need to cast to the type of ejbhome they desire",
	"Method": "EJBHome getRemoteHome(String jndiHomeName,Class className){\r\n    EJBHome home = null;\r\n    try {\r\n        if (cache.containsKey(jndiHomeName)) {\r\n            home = (EJBHome) cache.get(jndiHomeName);\r\n        } else {\r\n            Object objref = ic.lookup(jndiHomeName);\r\n            Object obj = PortableRemoteObject.narrow(objref, className);\r\n            home = (EJBHome) obj;\r\n            cache.put(jndiHomeName, home);\r\n        }\r\n    } catch (NamingException ne) {\r\n        throw new ServiceLocatorException(ne);\r\n    } catch (Exception e) {\r\n        throw new ServiceLocatorException(e);\r\n    }\r\n    return home;\r\n}"
}, {
	"Path": "com.android.launcher3.AutoInstallsLayout.parseLayout",
	"Comment": "parses the layout and returns the number of elements added on the homescreen.",
	"Method": "int parseLayout(int layoutId,ArrayList<Long> screenIds){\r\n    XmlResourceParser parser = mSourceRes.getXml(layoutId);\r\n    beginDocument(parser, mRootTag);\r\n    final int depth = parser.getDepth();\r\n    int type;\r\n    HashMap<String, TagParser> tagParserMap = getLayoutElementsMap();\r\n    int count = 0;\r\n    while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() > depth) && type != XmlPullParser.END_DOCUMENT) {\r\n        if (type != XmlPullParser.START_TAG) {\r\n            continue;\r\n        }\r\n        count += parseAndAddNode(parser, tagParserMap, screenIds);\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.jsql.util.AuthenticationUtil.set",
	"Comment": "get new authentication settings from the view, update the utility class,persist settings to the jvm and apply changes to the system.",
	"Method": "void set(boolean isAuthentication,String usernameAuthentication,String passwordAuthentication,boolean isKerberos,String kerberosKrb5Conf,String kerberosLoginConf){\r\n    boolean isRestartRequired = false;\r\n    if (AuthenticationUtil.isKerberos && !new File(AuthenticationUtil.pathKerberosKrb5).exists() && !kerberosKrb5Conf.equals(AuthenticationUtil.pathKerberosKrb5)) {\r\n        isRestartRequired = true;\r\n    }\r\n    AuthenticationUtil.isAuthentication = isAuthentication;\r\n    AuthenticationUtil.usernameAuthentication = usernameAuthentication;\r\n    AuthenticationUtil.passwordAuthentication = passwordAuthentication;\r\n    AuthenticationUtil.isKerberos = isKerberos;\r\n    AuthenticationUtil.pathKerberosKrb5 = kerberosKrb5Conf;\r\n    AuthenticationUtil.pathKerberosLogin = kerberosLoginConf;\r\n    Preferences preferences = Preferences.userRoot().node(InjectionModel.class.getName());\r\n    preferences.putBoolean(\"isDigestAuthentication\", AuthenticationUtil.isAuthentication);\r\n    preferences.put(\"usernameDigest\", AuthenticationUtil.usernameAuthentication);\r\n    preferences.put(\"passwordDigest\", AuthenticationUtil.passwordAuthentication);\r\n    preferences.putBoolean(\"enableKerberos\", AuthenticationUtil.isKerberos);\r\n    preferences.put(\"kerberosKrb5Conf\", AuthenticationUtil.pathKerberosKrb5);\r\n    preferences.put(\"kerberosLoginConf\", AuthenticationUtil.pathKerberosLogin);\r\n    if (AuthenticationUtil.isKerberos) {\r\n        if (!new File(AuthenticationUtil.pathKerberosKrb5).exists()) {\r\n            LOGGER.warn(\"Krb5 file not found: \" + AuthenticationUtil.pathKerberosKrb5);\r\n        }\r\n        if (!new File(AuthenticationUtil.pathKerberosLogin).exists()) {\r\n            LOGGER.warn(\"Login file not found: \" + AuthenticationUtil.pathKerberosLogin);\r\n        }\r\n    }\r\n    AuthCacheValue.setAuthCache(new AuthCacheImpl());\r\n    if (AuthenticationUtil.isAuthentication) {\r\n        Authenticator.setDefault(new Authenticator() {\r\n            @Override\r\n            protected PasswordAuthentication getPasswordAuthentication() {\r\n                return new PasswordAuthentication(AuthenticationUtil.usernameAuthentication, AuthenticationUtil.passwordAuthentication.toCharArray());\r\n            }\r\n        });\r\n    } else {\r\n        Authenticator.setDefault(null);\r\n    }\r\n    AuthenticationUtil.setAuthentication();\r\n    if (isRestartRequired && JOptionPane.showConfirmDialog(MediatorGui.frame(), \"File krb5.conf has changed, please restart.\", \"Restart\", JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION) {\r\n        new ActionNewWindow().actionPerformed(null);\r\n    }\r\n}"
}, {
	"Path": "com.jsql.util.AuthenticationUtil.set",
	"Comment": "get new authentication settings from the view, update the utility class,persist settings to the jvm and apply changes to the system.",
	"Method": "void set(boolean isAuthentication,String usernameAuthentication,String passwordAuthentication,boolean isKerberos,String kerberosKrb5Conf,String kerberosLoginConf){\r\n    return new PasswordAuthentication(AuthenticationUtil.usernameAuthentication, AuthenticationUtil.passwordAuthentication.toCharArray());\r\n}"
}, {
	"Path": "org.locationtech.jts.linearref.LinearGeometryBuilder.setFixInvalidLines",
	"Comment": "allows invalid lines to be ignored rather than causing exceptions.an invalid line is one which has only one unique point.",
	"Method": "void setFixInvalidLines(boolean fixInvalidLines){\r\n    this.fixInvalidLines = fixInvalidLines;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.requests.restaction.MessageAction.isEdit",
	"Comment": "whether this messageaction will be used to update an existing message.",
	"Method": "boolean isEdit(){\r\n    return finalizeRoute().getMethod() == Method.PATCH;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.CoordinateArrays.atLeastNCoordinatesOrNothing",
	"Comment": "returns either the given coordinate array if its length is greater than thegiven amount, or an empty coordinate array.",
	"Method": "Coordinate[] atLeastNCoordinatesOrNothing(int n,Coordinate[] c){\r\n    return c.length >= n ? c : new Coordinate[] {};\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.LinearRing.isClosed",
	"Comment": "tests whether this ring is closed.empty rings are closed by definition.",
	"Method": "boolean isClosed(){\r\n    if (isEmpty()) {\r\n        return true;\r\n    }\r\n    return super.isClosed();\r\n}"
}, {
	"Path": "com.samskivert.mustache.Mustache.compile",
	"Comment": "compiles the supplied template into a repeatedly executable intermediate form.",
	"Method": "Template compile(String template,Template compile,Reader source,Template compile,Reader source,Compiler compiler){\r\n    Accumulator accum = new Parser(compiler).parse(source);\r\n    return new Template(trim(accum.finish(), true), compiler);\r\n}"
}, {
	"Path": "org.kse.gui.ticker.JTicker.calculatePreferredSize",
	"Comment": "calculate the preferred size of the ticker based on its items.",
	"Method": "Dimension calculatePreferredSize(){\r\n    int width = (int) getPreferredSize().getWidth();\r\n    int height = 0;\r\n    int items = model.getSize();\r\n    for (int i = 0; i < items; i++) {\r\n        Object value = model.get(i);\r\n        JComponent component = renderer.getTickerRendererComponent(this, value);\r\n        Dimension cell = component.getPreferredSize();\r\n        height = Math.max(height, (int) cell.getHeight());\r\n    }\r\n    Insets insets = getInsets();\r\n    return new Dimension((width + insets.left + insets.right), (height + insets.top + insets.bottom));\r\n}"
}, {
	"Path": "org.kse.gui.JMenuRecentFiles.add",
	"Comment": "add a recent file menu item to the menu. only call when the menu is\tcompletely populated with standard menu items and separators.",
	"Method": "void add(JMenuItemRecentFile jmirfNew){\r\n    int index = findRecentFile(jmirfNew.getFile());\r\n    if (index == 0) {\r\n        return;\r\n    }\r\n    removeAllRecentFiles();\r\n    jmirfNew.setPosition(1);\r\n    if (index != -1) {\r\n        for (int i = 0; i <= index; i++) {\r\n            JMenuItemRecentFile jmirfTmp = jmiRecentFiles[i];\r\n            jmiRecentFiles[i] = jmirfNew;\r\n            jmirfNew = jmirfTmp;\r\n            jmirfNew.setPosition(i + 2);\r\n        }\r\n    } else {\r\n        for (int i = 0; i < jmiRecentFiles.length; i++) {\r\n            JMenuItemRecentFile jmirfTmp = jmiRecentFiles[i];\r\n            jmiRecentFiles[i] = jmirfNew;\r\n            jmirfNew = jmirfTmp;\r\n            if (jmirfNew == null) {\r\n                break;\r\n            }\r\n            jmirfNew.setPosition(i + 2);\r\n        }\r\n    }\r\n    addAllRecentFiles();\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.getTopOffsetForCustomContent",
	"Comment": "the custom content needs to offset its content to account for the qsb",
	"Method": "int getTopOffsetForCustomContent(){\r\n    return mWorkspace.getPaddingTop();\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.FastNodingValidator.checkValid",
	"Comment": "checks for an intersection and throwsa topologyexception if one is found.",
	"Method": "void checkValid(){\r\n    execute();\r\n    if (!isValid)\r\n        throw new TopologyException(getErrorMessage(), segInt.getInteriorIntersection());\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.DPreferences.getUseWinTrustRootCertificates",
	"Comment": "get whether or not the usage of windows trusted root certificates has\tbeen chosen.",
	"Method": "boolean getUseWinTrustRootCertificates(){\r\n    return useWinTrustRootCertificates;\r\n}"
}, {
	"Path": "org.kse.gui.crypto.policyinformation.PolicyQualifierInfoTableHeadRend.getTableCellRendererComponent",
	"Comment": "returns the rendered header cell for the supplied value and column.",
	"Method": "Component getTableCellRendererComponent(JTable jTable,Object value,boolean isSelected,boolean hasFocus,int row,int col){\r\n    Component c = delegate.getTableCellRendererComponent(jTable, value, isSelected, hasFocus, row, col);\r\n    if (c instanceof JLabel) {\r\n        JLabel header = (JLabel) c;\r\n        header.setToolTipText(res.getString(\"PolicyQualifierInfoTableHeadRend.PolicyQualifierInfoColumn.tooltip\"));\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.overlay.PointBuilder.build",
	"Comment": "computes the point geometries which will appear in the result,given the specified overlay operation.",
	"Method": "List build(int opCode){\r\n    extractNonCoveredResultNodes(opCode);\r\n    return resultPointList;\r\n}"
}, {
	"Path": "org.joda.money.format.MoneyFormatter.withLocale",
	"Comment": "returns a copy of this instance with the specified locale.changing the locale may change the style of output depending on how theformatter has been configured.",
	"Method": "MoneyFormatter withLocale(Locale locale){\r\n    checkNotNull(locale, \"Locale must not be null\");\r\n    return new MoneyFormatter(locale, printerParser);\r\n}"
}, {
	"Path": "com.jdon.persistence.hibernate.HibernateTemplate.doHibernate",
	"Comment": "execute the action specified by the given action object within a session.",
	"Method": "Object doHibernate(HibernateCallback action){\r\n    Session session = sessionProvider.getSession();\r\n    try {\r\n        Object result = action.execute(session);\r\n        return result;\r\n    } catch (Exception ex) {\r\n        logger.error(\"exception while execute\", ex);\r\n        try {\r\n            sessionProvider.rollback();\r\n        } catch (HibernateException ee) {\r\n            logger.error(\"error while session rollback\", ee);\r\n        } finally {\r\n            sessionProvider.resetSession();\r\n        }\r\n        throw new Exception(ex);\r\n    } finally {\r\n    }\r\n}"
}, {
	"Path": "com.jdon.controller.service.ServiceFacade.getServiceFactory",
	"Comment": "the model configure in jdonframework.xml will execute the service\tdirectly.\tand the remote servlet will call this method",
	"Method": "ServiceFactory getServiceFactory(AppContextWrapper sc){\r\n    ContainerWrapper containerWrapper = containerFinder.findContainer(sc);\r\n    ServiceFactory serviceFactory = (ServiceFactory) containerWrapper.lookup(ComponentKeys.WEBSERVICE_FACTORY);\r\n    return serviceFactory;\r\n}"
}, {
	"Path": "com.jsql.view.swing.ui.ComponentBorder.adjustBorderInsets",
	"Comment": "the complimentary edges of the border may need to be adjusted to allow the component to fit completely in the bounds of the parent component.",
	"Method": "void adjustBorderInsets(){\r\n    Insets parentInsets = this.parent.getInsets();\r\n    if (this.edge == Edge.RIGHT || this.edge == Edge.LEFT) {\r\n        int parentHeight = this.parent.getPreferredSize().height - parentInsets.top - parentInsets.bottom;\r\n        int diff = this.component.getHeight() - parentHeight;\r\n        if (diff > 0) {\r\n            int topDiff = (int) (diff * this.alignment);\r\n            int bottomDiff = diff - topDiff;\r\n            this.borderInsets.top += topDiff;\r\n            this.borderInsets.bottom += bottomDiff;\r\n        }\r\n    }\r\n    if (this.edge == Edge.TOP || this.edge == Edge.BOTTOM) {\r\n        int parentWidth = this.parent.getPreferredSize().width - parentInsets.left - parentInsets.right;\r\n        int diff = this.component.getWidth() - parentWidth;\r\n        if (diff > 0) {\r\n            int leftDiff = (int) (diff * this.alignment);\r\n            int rightDiff = diff - leftDiff;\r\n            this.borderInsets.left += leftDiff;\r\n            this.borderInsets.right += rightDiff;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.EdgeRing.getShell",
	"Comment": "gets the shell for this ring.the shell is the ring itself if it is not a hole, otherwise its parent shell.",
	"Method": "EdgeRing getShell(){\r\n    if (isHole())\r\n        return shell;\r\n    return this;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.Polygonizer.findOuterShells",
	"Comment": "for each outer hole finds and includes a single outer shell.this seeds the traversal algorithm for finding only polygonal shells.",
	"Method": "void findOuterShells(List shellList){\r\n    for (Iterator i = shellList.iterator(); i.hasNext(); ) {\r\n        EdgeRing er = (EdgeRing) i.next();\r\n        EdgeRing outerHoleER = er.getOuterHole();\r\n        if (outerHoleER != null && !outerHoleER.isProcessed()) {\r\n            er.setIncluded(true);\r\n            outerHoleER.setProcessed(true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.DirectedEdge.isInteriorAreaEdge",
	"Comment": "this is an interior area edge if its label is an area label for both geometries and for each geometry both sides are in the interior.",
	"Method": "boolean isInteriorAreaEdge(){\r\n    boolean isInteriorAreaEdge = true;\r\n    for (int i = 0; i < 2; i++) {\r\n        if (!(label.isArea(i) && label.getLocation(i, Position.LEFT) == Location.INTERIOR && label.getLocation(i, Position.RIGHT) == Location.INTERIOR)) {\r\n            isInteriorAreaEdge = false;\r\n        }\r\n    }\r\n    return isInteriorAreaEdge;\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifData.removeThumbnailData",
	"Comment": "removes the thumbnail and its related tags. ifd1 will be removed.",
	"Method": "void removeThumbnailData(){\r\n    clearThumbnailAndStrips();\r\n    mIfdDatas[IfdId.TYPE_IFD_1] = null;\r\n}"
}, {
	"Path": "com.jdon.model.handler.XmlModelHandler.initModelIF",
	"Comment": "if your application need initialize the modelform, this method is a\toption. extends thie method.",
	"Method": "Object initModelIF(EventModel em,ModelForm form,HttpServletRequest request,Object initModelIF,EventModel em,ModelForm form,ServletContext scontext){\r\n    Object result = null;\r\n    try {\r\n        HandlerMetaDef hm = this.modelMapping.getHandlerMetaDef();\r\n        String serviceName = hm.getServiceRef();\r\n        Debug.logVerbose(\"[JdonFramework] construct the CRUD method for the service:\" + serviceName, module);\r\n        MethodMetaArgs methodMetaArgs = maFactory.createinitMethod(hm, em);\r\n        AppContextWrapper acw = new ServletContextWrapper(scontext);\r\n        Service service = serviceFacade.getService(acw);\r\n        if (methodMetaArgs != null)\r\n            result = service.execute(serviceName, methodMetaArgs, acw);\r\n    } catch (Exception e) {\r\n        Debug.logError(\"[JdonFramework] initModel error: \" + e, module);\r\n        throw new Exception(e);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.jdon.util.FileUtil.CopyDir",
	"Comment": "this class copies an input files of a directory to another directory not\tinclude subdir",
	"Method": "void CopyDir(String sourcedir,String destdir){\r\n    File dest = new File(destdir);\r\n    File source = new File(sourcedir);\r\n    String[] files = source.list();\r\n    try {\r\n        makehome(destdir);\r\n    } catch (Exception ex) {\r\n        throw new Exception(\"CopyDir:\" + ex.getMessage());\r\n    }\r\n    for (int i = 0; i < files.length; i++) {\r\n        String sourcefile = source + File.separator + files[i];\r\n        String destfile = dest + File.separator + files[i];\r\n        File temp = new File(sourcefile);\r\n        if (temp.isFile()) {\r\n            try {\r\n                copy(sourcefile, destfile);\r\n            } catch (Exception ex) {\r\n                throw new Exception(\"CopyDir:\" + ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.linearref.LinearIterator.getComponentIndex",
	"Comment": "the component index of the vertex the iterator is currently at.",
	"Method": "int getComponentIndex(){\r\n    return componentIndex;\r\n}"
}, {
	"Path": "com.jsql.view.swing.ui.ComponentBorder.install",
	"Comment": "install this border on the specified component by replacing the existing border with a compoundborder containing the original border and our componentborder this method should only be invoked once all the properties of this class have been set. installing the border more than once will cause unpredictable results.",
	"Method": "void install(JComponent parent){\r\n    this.parent = parent;\r\n    this.determineInsetsAndAlignment();\r\n    Border current = parent.getBorder();\r\n    if (current == null) {\r\n        parent.setBorder(this);\r\n    } else {\r\n        CompoundBorder compound = new CompoundBorder(current, this);\r\n        parent.setBorder(compound);\r\n    }\r\n    parent.add(this.component);\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.patch.DiffMatchPatch.patchDeepCopy",
	"Comment": "given an array of patches, return another array that is identical.",
	"Method": "LinkedList<Patch> patchDeepCopy(List<Patch> patches){\r\n    LinkedList<Patch> patchesCopy = new LinkedList();\r\n    for (Patch aPatch : patches) {\r\n        Patch patchCopy = new Patch();\r\n        for (Diff aDiff : aPatch.getDiffs()) {\r\n            Diff diffCopy = new Diff(aDiff.getOperation(), aDiff.getText());\r\n            patchCopy.getDiffs().add(diffCopy);\r\n        }\r\n        patchCopy.setStart1(aPatch.getStart1());\r\n        patchCopy.setStart2(aPatch.getStart2());\r\n        patchCopy.setLength1(aPatch.getLength1());\r\n        patchCopy.setLength2(aPatch.getLength2());\r\n        patchesCopy.add(patchCopy);\r\n    }\r\n    return patchesCopy;\r\n}"
}, {
	"Path": "org.locationtech.jtstest.util.FileUtil.copyFile",
	"Comment": "copies the source file to the destination filename.posted by mark thorntonon usenet.",
	"Method": "void copyFile(File source,File destination){\r\n    RandomAccessFile out = new RandomAccessFile(destination, \"rw\");\r\n    out.setLength(source.length());\r\n    FileInputStream in = new FileInputStream(source);\r\n    byte[] buffer = new byte[16384];\r\n    while (true) {\r\n        int n = in.read(buffer);\r\n        if (n == -1)\r\n            break;\r\n        out.write(buffer, 0, n);\r\n    }\r\n    in.close();\r\n    out.close();\r\n}"
}, {
	"Path": "com.jsql.util.GitUtil.sendUnhandledException",
	"Comment": "define the body of an issue to send to github for an unhandled exception.it adds different system data to the body and remove sensible data likeinjection url.",
	"Method": "void sendUnhandledException(String threadName,Throwable throwable){\r\n    String javaVersion = System.getProperty(\"java.version\");\r\n    String osArch = System.getProperty(\"os.arch\");\r\n    String clientDescription = \"```\\n\" + \"jSQL: v\" + InjectionModel.getVersionJsql() + \"\\n\" + \"Java: v\" + javaVersion + \"-\" + osArch + \"-\" + System.getProperty(\"user.language\") + \" on \" + System.getProperty(\"java.runtime.name\") + \"\\n\" + \"OS: \" + System.getProperty(\"os.name\") + \" (v\" + System.getProperty(\"os.version\") + \")\\n\" + \"Desktop: \" + (System.getProperty(\"sun.desktop\") != null ? System.getProperty(\"sun.desktop\") : \"undefined\") + \"\\n\" + \"Strategy: \" + (MediatorModel.model().getStrategy() != null ? MediatorModel.model().getStrategy().instance().getName() : \"undefined\") + \"\\n\" + \"Db engine: \" + MediatorModel.model().getVendor().toString() + \"\\n\" + \"```\\n\" + \"```\\n\" + \"Exception on \" + threadName + \"\\n\" + ExceptionUtils.getStackTrace(throwable).trim() + \"\\n\" + \"```\";\r\n    clientDescription = clientDescription.replaceAll(\"(https?://[.a-zA-Z_0-9]*)+\", \"\");\r\n    GitUtil.sendReport(clientDescription, ShowOnConsole.NO, \"Unhandled \" + throwable.getClass().getSimpleName());\r\n}"
}, {
	"Path": "org.kse.gui.ticker.ClickableLinkTickerRenderer.getTickerRendererComponent",
	"Comment": "get the rendering component for the specified jticker and ticker item",
	"Method": "JComponent getTickerRendererComponent(JTicker ticker,Object value){\r\n    String text = value.toString();\r\n    setText(\"<html>\" + text + \"<\/html>\");\r\n    determineLinks(getText());\r\n    addMouseListener(new MouseAdapter() {\r\n        @Override\r\n        public void mouseClicked(MouseEvent e) {\r\n            String link = getLink(e.getPoint());\r\n            if (link == null)\r\n                return;\r\n            try {\r\n                Desktop.getDesktop().browse(new URI(link));\r\n            } catch (Exception ex) {\r\n                JOptionPane.showMessageDialog(null, \"Could not open link\", \"Error\", JOptionPane.ERROR_MESSAGE);\r\n            }\r\n        }\r\n    });\r\n    return this;\r\n}"
}, {
	"Path": "org.kse.gui.ticker.ClickableLinkTickerRenderer.getTickerRendererComponent",
	"Comment": "get the rendering component for the specified jticker and ticker item",
	"Method": "JComponent getTickerRendererComponent(JTicker ticker,Object value){\r\n    String link = getLink(e.getPoint());\r\n    if (link == null)\r\n        return;\r\n    try {\r\n        Desktop.getDesktop().browse(new URI(link));\r\n    } catch (Exception ex) {\r\n        JOptionPane.showMessageDialog(null, \"Could not open link\", \"Error\", JOptionPane.ERROR_MESSAGE);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.DefaultCoordinateSequence.toCoordinateArray",
	"Comment": "this method exposes the internal array of coordinate objects",
	"Method": "Coordinate[] toCoordinateArray(){\r\n    return coordinates;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.relate.EdgeEndBuilder.createEdgeEndForPrev",
	"Comment": "create a edgestub for the edge before the intersection eicurr.the previous intersection is providedin case it is the endpoint for the stub edge.otherwise, the previous point from the parent edge will be the endpoint.eicurr will always be an edgeintersection, but eiprev may be null.",
	"Method": "void createEdgeEndForPrev(Edge edge,List l,EdgeIntersection eiCurr,EdgeIntersection eiPrev){\r\n    int iPrev = eiCurr.segmentIndex;\r\n    if (eiCurr.dist == 0.0) {\r\n        if (iPrev == 0)\r\n            return;\r\n        iPrev--;\r\n    }\r\n    Coordinate pPrev = edge.getCoordinate(iPrev);\r\n    if (eiPrev != null && eiPrev.segmentIndex >= iPrev)\r\n        pPrev = eiPrev.coord;\r\n    Label label = new Label(edge.getLabel());\r\n    label.flip();\r\n    EdgeEnd e = new EdgeEnd(edge, eiCurr.coord, pPrev, label);\r\n    l.add(e);\r\n}"
}, {
	"Path": "com.android.launcher3.CellLayout.getViewsIntersectingRegion",
	"Comment": "for a given cell and span, fetch the set of views intersecting the region.",
	"Method": "void getViewsIntersectingRegion(int cellX,int cellY,int spanX,int spanY,View dragView,Rect boundingRect,ArrayList<View> intersectingViews){\r\n    if (boundingRect != null) {\r\n        boundingRect.set(cellX, cellY, cellX + spanX, cellY + spanY);\r\n    }\r\n    intersectingViews.clear();\r\n    Rect r0 = new Rect(cellX, cellY, cellX + spanX, cellY + spanY);\r\n    Rect r1 = new Rect();\r\n    final int count = mShortcutsAndWidgets.getChildCount();\r\n    for (int i = 0; i < count; i++) {\r\n        View child = mShortcutsAndWidgets.getChildAt(i);\r\n        if (child == dragView)\r\n            continue;\r\n        LayoutParams lp = (LayoutParams) child.getLayoutParams();\r\n        r1.set(lp.cellX, lp.cellY, lp.cellX + lp.cellHSpan, lp.cellY + lp.cellVSpan);\r\n        if (Rect.intersects(r0, r1)) {\r\n            mIntersectingViews.add(child);\r\n            if (boundingRect != null) {\r\n                boundingRect.union(r1);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.importexport.DImportKeyPairPkcs12.getCertificateChain",
	"Comment": "get the certificate chain part of the key pair chosen by the user for\timport.",
	"Method": "X509Certificate[] getCertificateChain(X509Certificate[] getCertificateChain){\r\n    return certificateChain;\r\n}"
}, {
	"Path": "org.locationtech.jts.index.bintree.Node.find",
	"Comment": "returns the smallest existingnode containing the envelope.",
	"Method": "NodeBase find(Interval searchInterval){\r\n    int subnodeIndex = getSubnodeIndex(searchInterval, centre);\r\n    if (subnodeIndex == -1)\r\n        return this;\r\n    if (subnode[subnodeIndex] != null) {\r\n        Node node = subnode[subnodeIndex];\r\n        return node.find(searchInterval);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.locationtech.jts.edgegraph.HalfEdge.next",
	"Comment": "gets the next edge ccw around the destination vertex of this edge.if the vertex has degree 1 then this is the sym edge.",
	"Method": "HalfEdge next(){\r\n    return next;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.validate.BufferDistanceValidator.checkMinimumDistance",
	"Comment": "checks that two geometries are at least a minimum distance apart.",
	"Method": "void checkMinimumDistance(Geometry g1,Geometry g2,double minDist){\r\n    DistanceOp distOp = new DistanceOp(g1, g2, minDist);\r\n    minDistanceFound = distOp.distance();\r\n    if (minDistanceFound < minDist) {\r\n        isValid = false;\r\n        Coordinate[] pts = distOp.nearestPoints();\r\n        errorLocation = distOp.nearestPoints()[1];\r\n        errorIndicator = g1.getFactory().createLineString(pts);\r\n        errMsg = \"Distance between buffer curve and input is too small \" + \"(\" + minDistanceFound + \" at \" + WKTWriter.toLineString(pts[0], pts[1]) + \" )\";\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testrunner.JTSTestRunnerCmd.isGeometryOperationSpecified",
	"Comment": "tests whether a geometryoperation was specified on the command line",
	"Method": "boolean isGeometryOperationSpecified(){\r\n    return geometryOp != defaultOp;\r\n}"
}, {
	"Path": "com.android.launcher3.allapps.AllAppsGridAdapter.setLastSearchQuery",
	"Comment": "sets the last search query that was made, used to show when there are no results and to alsoseed the intent for searching the market.",
	"Method": "void setLastSearchQuery(String query){\r\n    Resources res = mLauncher.getResources();\r\n    String formatStr = res.getString(R.string.all_apps_no_search_results);\r\n    mLastSearchQuery = query;\r\n    mEmptySearchMessage = String.format(formatStr, query);\r\n    if (mMarketAppName != null) {\r\n        mMarketSearchMessage = String.format(res.getString(R.string.all_apps_search_market_message), mMarketAppName);\r\n        mMarketSearchIntent = createMarketSearchIntent(query);\r\n    }\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.DPreferences.getUseCaCertificates",
	"Comment": "get whether or not the usage of ca certificates has been chosen.",
	"Method": "boolean getUseCaCertificates(){\r\n    return useCaCertificates;\r\n}"
}, {
	"Path": "org.locationtech.jts.io.kml.KMLWriter.setZ",
	"Comment": "sets the z value to be output for all coordinates.this overrides any z value present in the geometry coordinates.",
	"Method": "void setZ(double zVal){\r\n    this.zVal = zVal;\r\n}"
}, {
	"Path": "org.locationtech.jts.io.oracle.OraWriterCreateTest.testXY_GeometryCollection_MultiPoint",
	"Comment": "multipoints can be written directly as collection elements.",
	"Method": "void testXY_GeometryCollection_MultiPoint(){\r\n    checkValue(MDSYS.SDO_GEOMETRY(2004, NULL, NULL, MDSYS.SDO_ELEM_INFO_ARRAY(1, 1, 3, 7, 2, 1), MDSYS.SDO_ORDINATE_ARRAY(1, 1, 2, 2, 3, 3, 1, 2, 2, 1)), \"GEOMETRYCOLLECTION (MULTIPOINT (1 1, 2 2, 3 3), LINESTRING (1 2, 2 1) )\");\r\n}"
}, {
	"Path": "org.locationtech.jts.io.gml2.StaticMultiPolygonTest.testSingleMultiPolygonManyPointsNoHoleRoundTrip",
	"Comment": "round trip test for a single multipolygon with lots of points",
	"Method": "void testSingleMultiPolygonManyPointsNoHoleRoundTrip(){\r\n    PolygonGenerator pgc = new PolygonGenerator();\r\n    pgc.setGeometryFactory(geometryFactory);\r\n    pgc.setGenerationAlgorithm(PolygonGenerator.BOX);\r\n    pgc.setNumberPoints(1000);\r\n    MultiGenerator pg = new MultiGenerator(pgc);\r\n    pg.setBoundingBox(new Envelope(0, 10, 0, 10));\r\n    pg.setNumberGeometries(3);\r\n    pg.setGeometryFactory(geometryFactory);\r\n    MultiPolygon pt = (MultiPolygon) pg.create();\r\n    checkRoundTrip(pt);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.distance.DistanceOp.nearestLocations",
	"Comment": "report the locations of the nearest points in the input geometries.the locations are presented in the same order as the input geometries.",
	"Method": "GeometryLocation[] nearestLocations(){\r\n    computeMinDistance();\r\n    return minDistanceLocation;\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.Node.isIncidentEdgeInResult",
	"Comment": "tests whether any incident edge is flagged asbeing in the result.this test can be used to determine if the node is in the result,since if any incident edge is in the result, the node must be in the result as well.",
	"Method": "boolean isIncidentEdgeInResult(){\r\n    for (Iterator it = getEdges().getEdges().iterator(); it.hasNext(); ) {\r\n        DirectedEdge de = (DirectedEdge) it.next();\r\n        if (de.getEdge().isInResult())\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.MessageBuilder.replaceFirst",
	"Comment": "replaces the first substring that matches the target string with the specified replacement string.",
	"Method": "MessageBuilder replaceFirst(String target,String replacement){\r\n    int index = builder.indexOf(target);\r\n    if (index != -1) {\r\n        builder.replace(index, index + target.length(), replacement);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.zeromq.ZContext.shadow",
	"Comment": "creates new shadow context. shares same underlying org.zeromq.context instance but has own list of managedsockets, io thread count etc.",
	"Method": "ZContext shadow(ZContext ctx){\r\n    ZContext shadow = new ZContext();\r\n    shadow.setContext(ctx.getContext());\r\n    shadow.setMain(false);\r\n    return shadow;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.relate.EdgeEndBundle.computeLabel",
	"Comment": "this computes the overall edge label for the set ofedges in this edgestubbundle.it essentially mergesthe on and side labels for each edge.these labels must be compatible",
	"Method": "void computeLabel(BoundaryNodeRule boundaryNodeRule){\r\n    boolean isArea = false;\r\n    for (Iterator it = iterator(); it.hasNext(); ) {\r\n        EdgeEnd e = (EdgeEnd) it.next();\r\n        if (e.getLabel().isArea())\r\n            isArea = true;\r\n    }\r\n    if (isArea)\r\n        label = new Label(Location.NONE, Location.NONE, Location.NONE);\r\n    else\r\n        label = new Label(Location.NONE);\r\n    for (int i = 0; i < 2; i++) {\r\n        computeLabelOn(i, boundaryNodeRule);\r\n        if (isArea)\r\n            computeLabelSides(i);\r\n    }\r\n}"
}, {
	"Path": "com.jdon.persistence.hibernate.HibernateTemplate.getFetchSize",
	"Comment": "return the fetch size specified for this hibernatetemplate.",
	"Method": "int getFetchSize(){\r\n    return fetchSize;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.valid.ValidSelfTouchingRingFormingHoleTest.testDisconnectedInteriorShellSelfTouchAtNonVertex",
	"Comment": "ensure that the disconnected interior condition is not validated",
	"Method": "void testDisconnectedInteriorShellSelfTouchAtNonVertex(){\r\n    String wkt = \"POLYGON ((40 180, 40 60, 240 60, 240 180, 140 60, 40 180))\";\r\n    checkIsValidSTR(wkt, false);\r\n    checkIsValidDefault(wkt, false);\r\n}"
}, {
	"Path": "org.zeromq.ZMsg.wrap",
	"Comment": "push frame plus empty frame to front of message, before 1st frame.message takes ownership of frame, will destroy it when message is sent.",
	"Method": "void wrap(ZFrame frame){\r\n    if (frame != null) {\r\n        push(new ZFrame(\"\"));\r\n        push(frame);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jtstest.util.FileUtil.deleteFiles",
	"Comment": "deletes the files in the directory, but does not remove the directory.",
	"Method": "void deleteFiles(String directoryName){\r\n    File dir = new File(directoryName);\r\n    File[] files = dir.listFiles();\r\n    for (int i = 0; i < files.length; i++) {\r\n        files[i].delete();\r\n    }\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.HighlightedDocument.color",
	"Comment": "color a section of the document. the actual coloring will start somewhere\tbefore the requested position and continue as long as needed.",
	"Method": "void color(int position,int adjustment){\r\n    this.colorer.color(position, adjustment);\r\n}"
}, {
	"Path": "org.locationtech.jtstest.util.StringUtil.stripHTMLTags",
	"Comment": "removes the html tags from the given string, inserting line breaks at appropriate places. needs a little work.",
	"Method": "String stripHTMLTags(String original){\r\n    boolean skipping = false;\r\n    boolean writing = false;\r\n    StringBuffer buffer = new StringBuffer();\r\n    StringTokenizer tokenizer = new StringTokenizer(original, \"<>\", true);\r\n    while (tokenizer.hasMoreTokens()) {\r\n        String token = tokenizer.nextToken();\r\n        if (token.equalsIgnoreCase(\"<\")) {\r\n            skipping = true;\r\n            writing = false;\r\n            continue;\r\n        }\r\n        if (token.equalsIgnoreCase(\">\")) {\r\n            skipping = false;\r\n            continue;\r\n        }\r\n        if (!skipping) {\r\n            if (token.trim().length() == 0) {\r\n                continue;\r\n            }\r\n            if (!writing) {\r\n                buffer.append(\"\\n\");\r\n            }\r\n            writing = true;\r\n            buffer.append(token.trim());\r\n        }\r\n    }\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.IntersectionAdder.hasProperIntersection",
	"Comment": "a proper intersection is an intersection which is interior to at least twoline segments.note that a proper intersection is not necessarilyin the interior of the entire geometry, since another edge may havean endpoint equal to the intersection, which according to sfs semanticscan result in the point being on the boundary of the geometry.",
	"Method": "boolean hasProperIntersection(){\r\n    return hasProper;\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.dsl.base.BaseOperation.isApiGroup",
	"Comment": "return true if this is an api group where the versions include a slash in them",
	"Method": "boolean isApiGroup(){\r\n    return apiGroupVersion != null && apiGroupVersion.indexOf('/') > 0;\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.patch.DiffMatchPatch.diffCommonOverlap",
	"Comment": "determine if the suffix of one string is the prefix of another.",
	"Method": "int diffCommonOverlap(String valueText1,String valueText2){\r\n    String text1 = valueText1;\r\n    String text2 = valueText2;\r\n    int text1Length = text1.length();\r\n    int text2Length = text2.length();\r\n    if (text1Length == 0 || text2Length == 0) {\r\n        return 0;\r\n    }\r\n    if (text1Length > text2Length) {\r\n        text1 = text1.substring(text1Length - text2Length);\r\n    } else if (text1Length < text2Length) {\r\n        text2 = text2.substring(0, text1Length);\r\n    }\r\n    int textLength = Math.min(text1Length, text2Length);\r\n    if (text1.equals(text2)) {\r\n        return textLength;\r\n    }\r\n    int best = 0;\r\n    int length = 1;\r\n    while (true) {\r\n        String pattern = text1.substring(textLength - length);\r\n        int found = text2.indexOf(pattern);\r\n        if (found == -1) {\r\n            return best;\r\n        }\r\n        length += found;\r\n        if (found == 0 || text1.substring(textLength - length).equals(text2.substring(0, length))) {\r\n            best = length;\r\n            length++;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.kse.ApplicationSettings.addSslHost",
	"Comment": "add a new ssl host to start of current list of hosts.\tmaximum number is 10. if host is already in list, it is brought to the first position.",
	"Method": "void addSslHost(String newSslHost){\r\n    String newSslHosts = StringUtils.addToList(newSslHost, getSslHosts(), 10);\r\n    setSslHosts(newSslHosts);\r\n}"
}, {
	"Path": "org.kse.gui.crypto.policyinformation.PolicyInformationTableHeadRend.getTableCellRendererComponent",
	"Comment": "returns the rendered header cell for the supplied value and column.",
	"Method": "Component getTableCellRendererComponent(JTable jTable,Object value,boolean isSelected,boolean hasFocus,int row,int col){\r\n    Component c = delegate.getTableCellRendererComponent(jTable, value, isSelected, hasFocus, row, col);\r\n    if (c instanceof JLabel) {\r\n        JLabel header = (JLabel) c;\r\n        header.setToolTipText(res.getString(\"PolicyInformationTableHeadRend.PolicyInformationColumn.tooltip\"));\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "cn.jpush.api.push.model.PushPayload.messageAll",
	"Comment": "the shortcut of building a simple message object to all platforms and all audiences",
	"Method": "PushPayload messageAll(String msgContent,PushPayload messageAll,String msgContent,SMS sms){\r\n    return new Builder().setPlatform(Platform.all()).setAudience(Audience.all()).setMessage(Message.content(msgContent)).setSMS(sms).build();\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.util.AffineTransformation.reflect",
	"Comment": "updates the value of this transformationto that of a reflection transformation composed with the current value.",
	"Method": "AffineTransformation reflect(double x0,double y0,double x1,double y1,AffineTransformation reflect,double x,double y){\r\n    compose(reflectionInstance(x, y));\r\n    return this;\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.dsl.base.OperationSupport.assertResponseCode",
	"Comment": "checks if the response status code is the expected and throws the appropriate kubernetesclientexception if not.",
	"Method": "void assertResponseCode(Request request,Response response){\r\n    int statusCode = response.code();\r\n    String customMessage = config.getErrorMessages().get(statusCode);\r\n    if (response.isSuccessful()) {\r\n        return;\r\n    } else if (customMessage != null) {\r\n        throw requestFailure(request, createStatus(statusCode, combineMessages(customMessage, createStatus(response))));\r\n    } else {\r\n        throw requestFailure(request, createStatus(response));\r\n    }\r\n}"
}, {
	"Path": "com.jdon.util.ObjectCreator.createObject",
	"Comment": "instantaite an object instance, requires a constractor with parameters",
	"Method": "Object createObject(String className,Object createObject,Class classObject,Object createObject,String className,Object[] params,Object createObject,Class classObject,Object[] params){\r\n    Constructor[] constructors = classObject.getConstructors();\r\n    Object object = null;\r\n    for (int counter = 0; counter < constructors.length; counter++) {\r\n        try {\r\n            object = constructors[counter].newInstance(params);\r\n        } catch (Exception e) {\r\n            if (e instanceof InvocationTargetException)\r\n                ((InvocationTargetException) e).getTargetException().printStackTrace();\r\n        }\r\n    }\r\n    if (object == null)\r\n        throw new InstantiationException();\r\n    return object;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.Angle.getTurn",
	"Comment": "returns whether an angle must turn clockwise or counterclockwiseto overlap another angle.",
	"Method": "int getTurn(double ang1,double ang2){\r\n    double crossproduct = Math.sin(ang2 - ang1);\r\n    if (crossproduct > 0) {\r\n        return COUNTERCLOCKWISE;\r\n    }\r\n    if (crossproduct < 0) {\r\n        return CLOCKWISE;\r\n    }\r\n    return NONE;\r\n}"
}, {
	"Path": "org.locationtech.jts.index.bintree.Node.getNode",
	"Comment": "returns the subnode containing the envelope.creates the node ifit does not already exist.",
	"Method": "Node getNode(Interval searchInterval){\r\n    int subnodeIndex = getSubnodeIndex(searchInterval, centre);\r\n    if (subnodeIndex != -1) {\r\n        Node node = getSubnode(subnodeIndex);\r\n        return node.getNode(searchInterval);\r\n    } else {\r\n        return this;\r\n    }\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.utils.KubernetesResourceUtil.getResourceVersion",
	"Comment": "returns the resource version for the entity or null if it does not have one",
	"Method": "String getResourceVersion(HasMetadata entity){\r\n    if (entity != null) {\r\n        ObjectMeta metadata = entity.getMetadata();\r\n        if (metadata != null) {\r\n            String resourceVersion = metadata.getResourceVersion();\r\n            if (!Utils.isNullOrEmpty(resourceVersion)) {\r\n                return resourceVersion;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct4.converge",
	"Comment": "converge this coproduct down to a lower order coproduct by mapping the last possible type into an earlierpossible type.",
	"Method": "CoProduct3<A, B, C, ? extends CoProduct3<A, B, C, ?>> converge(Function<? super D, ? extends CoProduct3<A, B, C, ?>> convergenceFn){\r\n    return match(a -> new CoProduct3<A, B, C, CoProduct3<A, B, C, ?>>() {\r\n        @Override\r\n        public <R> R match(Function<? super A, ? extends R> aFn, Function<? super B, ? extends R> bFn, Function<? super C, ? extends R> cFn) {\r\n            return aFn.apply(a);\r\n        }\r\n    }, b -> new CoProduct3<A, B, C, CoProduct3<A, B, C, ?>>() {\r\n        @Override\r\n        public <R> R match(Function<? super A, ? extends R> aFn, Function<? super B, ? extends R> bFn, Function<? super C, ? extends R> cFn) {\r\n            return bFn.apply(b);\r\n        }\r\n    }, c -> new CoProduct3<A, B, C, CoProduct3<A, B, C, ?>>() {\r\n        @Override\r\n        public <R> R match(Function<? super A, ? extends R> aFn, Function<? super B, ? extends R> bFn, Function<? super C, ? extends R> cFn) {\r\n            return cFn.apply(c);\r\n        }\r\n    }, convergenceFn);\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct4.converge",
	"Comment": "converge this coproduct down to a lower order coproduct by mapping the last possible type into an earlierpossible type.",
	"Method": "CoProduct3<A, B, C, ? extends CoProduct3<A, B, C, ?>> converge(Function<? super D, ? extends CoProduct3<A, B, C, ?>> convergenceFn){\r\n    return aFn.apply(a);\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct4.converge",
	"Comment": "converge this coproduct down to a lower order coproduct by mapping the last possible type into an earlierpossible type.",
	"Method": "CoProduct3<A, B, C, ? extends CoProduct3<A, B, C, ?>> converge(Function<? super D, ? extends CoProduct3<A, B, C, ?>> convergenceFn){\r\n    return bFn.apply(b);\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct4.converge",
	"Comment": "converge this coproduct down to a lower order coproduct by mapping the last possible type into an earlierpossible type.",
	"Method": "CoProduct3<A, B, C, ? extends CoProduct3<A, B, C, ?>> converge(Function<? super D, ? extends CoProduct3<A, B, C, ?>> convergenceFn){\r\n    return cFn.apply(c);\r\n}"
}, {
	"Path": "org.kse.crypto.x509.PolicyMappingsUtil.getListOfPolicyMappings",
	"Comment": "creates list of policymapping objects from an policymappings object.",
	"Method": "List<PolicyMapping> getListOfPolicyMappings(PolicyMappings policyMappings){\r\n    ASN1Sequence policyMappingsSeq = (ASN1Sequence) policyMappings.toASN1Primitive();\r\n    ASN1Encodable[] policyMappingsArray = policyMappingsSeq.toArray();\r\n    List<PolicyMapping> policyMappingsList = new ArrayList();\r\n    for (ASN1Encodable asn1Encodable : policyMappingsArray) {\r\n        policyMappingsList.add(PolicyMapping.getInstance(asn1Encodable));\r\n    }\r\n    return policyMappingsList;\r\n}"
}, {
	"Path": "cn.jpush.api.JPushClient.sendIosNotificationWithRegistrationID",
	"Comment": "send an ios notification with registrationids.if you want to send alert as a json object, maybe this method is what you needed.",
	"Method": "PushResult sendIosNotificationWithRegistrationID(String alert,Map<String, String> extras,String registrationID,PushResult sendIosNotificationWithRegistrationID,String alert,SMS sms,Map<String, String> extras,String registrationID,PushResult sendIosNotificationWithRegistrationID,IosAlert alert,Map<String, String> extras,String registrationID,PushResult sendIosNotificationWithRegistrationID,IosAlert alert,SMS sms,Map<String, String> extras,String registrationID,PushResult sendIosNotificationWithRegistrationID,JsonObject alert,Map<String, String> extras,String registrationID,PushResult sendIosNotificationWithRegistrationID,JsonObject alert,SMS sms,Map<String, String> extras,String registrationID){\r\n    PushPayload payload = PushPayload.newBuilder().setPlatform(Platform.ios()).setAudience(Audience.registrationId(registrationID)).setNotification(Notification.ios(alert, extras)).setSMS(sms).build();\r\n    return _pushClient.sendPush(payload);\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.RectangleLineIntersector.intersects",
	"Comment": "tests whether the query rectangle intersects a given line segment.",
	"Method": "boolean intersects(Coordinate p0,Coordinate p1){\r\n    Envelope segEnv = new Envelope(p0, p1);\r\n    if (!rectEnv.intersects(segEnv))\r\n        return false;\r\n    if (rectEnv.intersects(p0))\r\n        return true;\r\n    if (rectEnv.intersects(p1))\r\n        return true;\r\n    if (p0.compareTo(p1) > 0) {\r\n        Coordinate tmp = p0;\r\n        p0 = p1;\r\n        p1 = tmp;\r\n    }\r\n    boolean isSegUpwards = false;\r\n    if (p1.y > p0.y)\r\n        isSegUpwards = true;\r\n    if (isSegUpwards) {\r\n        li.computeIntersection(p0, p1, diagDown0, diagDown1);\r\n    } else {\r\n        li.computeIntersection(p0, p1, diagUp0, diagUp1);\r\n    }\r\n    if (li.hasIntersection())\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "com.jsql.util.PreferencesUtil.loadSavedPreferences",
	"Comment": "initialize the utility class with previously saved jvm preferences and applyloaded settings to the system.",
	"Method": "void loadSavedPreferences(){\r\n    Preferences prefs = Preferences.userRoot().node(InjectionModel.class.getName());\r\n    PreferencesUtil.setPathFile(prefs.get(\"pathFile\", System.getProperty(\"user.dir\")));\r\n    PreferencesUtil.setIsCheckUpdateActivated(prefs.getBoolean(\"isCheckingUpdate\", true));\r\n    PreferencesUtil.setReportingBugs(prefs.getBoolean(\"isReportingBugs\", true));\r\n    PreferencesUtil.setEvasionIsEnabled(prefs.getBoolean(\"isEvading\", false));\r\n    PreferencesUtil.setFollowingRedirection(prefs.getBoolean(\"isFollowingRedirection\", false));\r\n    PreferencesUtil.setNotInjectingMetadata(prefs.getBoolean(\"isNotInjectingMetadata\", false));\r\n    PreferencesUtil.setCheckingAllParam(prefs.getBoolean(\"isCheckingAllParam\", false));\r\n    PreferencesUtil.setCheckingAllURLParam(prefs.getBoolean(\"isCheckingAllURLParam\", false));\r\n    PreferencesUtil.setCheckingAllRequestParam(prefs.getBoolean(\"isCheckingAllRequestParam\", false));\r\n    PreferencesUtil.setCheckingAllHeaderParam(prefs.getBoolean(\"isCheckingAllHeaderParam\", false));\r\n    PreferencesUtil.setCheckingAllJSONParam(prefs.getBoolean(\"isCheckingAllJSONParam\", false));\r\n    PreferencesUtil.setCheckingAllCookieParam(prefs.getBoolean(\"isCheckingAllCookieParam\", false));\r\n    PreferencesUtil.setCheckingAllSOAPParam(prefs.getBoolean(\"isCheckingAllSOAPParam\", false));\r\n    PreferencesUtil.setParsingForm(prefs.getBoolean(\"isParsingForm\", false));\r\n    PreferencesUtil.setNotTestingConnection(prefs.getBoolean(\"isNotTestingConnection\", false));\r\n    PreferencesUtil.setProcessingCookies(prefs.getBoolean(\"isProcessingCookies\", false));\r\n    PreferencesUtil.setProcessingCsrf(prefs.getBoolean(\"isProcessingCsrf\", false));\r\n    PreferencesUtil.setTamperingBase64(prefs.getBoolean(\"isTamperingBase64\", false));\r\n    PreferencesUtil.setTamperingEqualToLike(prefs.getBoolean(\"isTamperingEqualToLike\", false));\r\n    PreferencesUtil.setTamperingFunctionComment(prefs.getBoolean(\"isTamperingFunctionComment\", false));\r\n    PreferencesUtil.setTamperingVersionComment(prefs.getBoolean(\"isTamperingVersionComment\", false));\r\n    PreferencesUtil.setTamperingRandomCase(prefs.getBoolean(\"isTamperingRandomCase\", false));\r\n    PreferencesUtil.setTamperingEval(prefs.getBoolean(\"isTamperingEval\", false));\r\n    PreferencesUtil.setTamperingSpaceToDashComment(prefs.getBoolean(\"isTamperingSpaceToDashComment\", false));\r\n    PreferencesUtil.setTamperingSpaceToMultlineComment(prefs.getBoolean(\"isTamperingSpaceToMultlineComment\", false));\r\n    PreferencesUtil.setTamperingSpaceToSharpComment(prefs.getBoolean(\"isTamperingSpaceToSharpComment\", false));\r\n    PreferencesUtil.setIs4K(prefs.getBoolean(\"is4K\", false));\r\n    HttpURLConnection.setFollowRedirects(PreferencesUtil.isFollowingRedirection());\r\n}"
}, {
	"Path": "com.jdon.util.UtilDateTime.toSqlDate",
	"Comment": "makes a java.sql.date from separate ints for month, day, year",
	"Method": "java.sql.Date toSqlDate(String date,java.sql.Date toSqlDate,String monthStr,String dayStr,String yearStr,java.sql.Date toSqlDate,int month,int day,int year){\r\n    java.util.Date newDate = toDate(month, day, year, 0, 0, 0);\r\n    if (newDate != null)\r\n        return new java.sql.Date(newDate.getTime());\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "com.jdon.controller.WebAppUtil.getContainerKey",
	"Comment": "get the key for the application container user can directly get his\tcontainer from servletcontext by the key.",
	"Method": "String getContainerKey(){\r\n    return ContainerRegistryBuilder.APPLICATION_CONTEXT_ATTRIBUTE_NAME;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct6.diverge",
	"Comment": "diverge this coproduct by introducing another possible type that it could represent.",
	"Method": "CoProduct7<A, B, C, D, E, F, G, ? extends CoProduct7<A, B, C, D, E, F, G, ?>> diverge(){\r\n    return new CoProduct7<A, B, C, D, E, F, G, CoProduct7<A, B, C, D, E, F, G, ?>>() {\r\n        @Override\r\n        public <R> R match(Function<? super A, ? extends R> aFn, Function<? super B, ? extends R> bFn, Function<? super C, ? extends R> cFn, Function<? super D, ? extends R> dFn, Function<? super E, ? extends R> eFn, Function<? super F, ? extends R> fFn, Function<? super G, ? extends R> gFn) {\r\n            return CoProduct6.this.match(aFn, bFn, cFn, dFn, eFn, fFn);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct6.diverge",
	"Comment": "diverge this coproduct by introducing another possible type that it could represent.",
	"Method": "CoProduct7<A, B, C, D, E, F, G, ? extends CoProduct7<A, B, C, D, E, F, G, ?>> diverge(){\r\n    return CoProduct6.this.match(aFn, bFn, cFn, dFn, eFn, fFn);\r\n}"
}, {
	"Path": "com.android.launcher3.AllAppsList.findApplicationInfoLocked",
	"Comment": "find an applicationinfo object for the given packagename and classname.",
	"Method": "AppInfo findApplicationInfoLocked(String packageName,UserHandleCompat user,String className){\r\n    for (AppInfo info : data) {\r\n        final ComponentName component = info.intent.getComponent();\r\n        if (user.equals(info.user) && packageName.equals(component.getPackageName()) && className.equals(component.getClassName())) {\r\n            return info;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdgeTriangle.getNeighbours",
	"Comment": "gets the neighbours of this triangle. if there is no neighbour triangle,\tthe array element is null",
	"Method": "QuadEdgeTriangle[] getNeighbours(){\r\n    QuadEdgeTriangle[] neigh = new QuadEdgeTriangle[3];\r\n    for (int i = 0; i < 3; i++) {\r\n        neigh[i] = (QuadEdgeTriangle) getEdge(i).sym().getData();\r\n    }\r\n    return neigh;\r\n}"
}, {
	"Path": "org.kse.crypto.signing.JarSigner.ignoreJarEntry",
	"Comment": "ignore a jar entry for signing? jar entries which should not be\tsigned are the manifest files, signature files and signature block files",
	"Method": "boolean ignoreJarEntry(JarEntry jarEntry){\r\n    String entryName = jarEntry.getName();\r\n    if (entryName.startsWith(\"META-INF/\")) {\r\n        if (entryName.equalsIgnoreCase(MANIFEST_LOCATION)) {\r\n            return true;\r\n        }\r\n        if (entryName.toUpperCase().endsWith(SIGNATURE_EXT)) {\r\n            return true;\r\n        }\r\n        if (entryName.toUpperCase().endsWith(RSA_SIG_BLOCK_EXT)) {\r\n            return true;\r\n        }\r\n        if (entryName.toUpperCase().endsWith(DSA_SIG_BLOCK_EXT)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DD.ge",
	"Comment": "tests whether this value is greater than or equals to another doubledouble value.",
	"Method": "boolean ge(DD y){\r\n    return (hi > y.hi) || (hi == y.hi && lo >= y.lo);\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision.getTriangleCoordinates",
	"Comment": "gets the coordinates for each triangle in the subdivision as an array.",
	"Method": "List getTriangleCoordinates(boolean includeFrame){\r\n    TriangleCoordinatesVisitor visitor = new TriangleCoordinatesVisitor();\r\n    visitTriangles(visitor, includeFrame);\r\n    return visitor.getTriangles();\r\n}"
}, {
	"Path": "com.android.launcher3.AppWidgetResizeFrame.commitResize",
	"Comment": "this is the final step of the resize. here we save the new widget size and positionto launchermodel and animate the resize frame.",
	"Method": "void commitResize(){\r\n    resizeWidgetIfNeeded(true);\r\n    requestLayout();\r\n}"
}, {
	"Path": "com.android.launcher3.SpringLoadedDragController.setAlarm",
	"Comment": "set a new alarm to expire for the screen that we are hovering over now",
	"Method": "void setAlarm(CellLayout cl){\r\n    mAlarm.cancelAlarm();\r\n    mAlarm.setAlarm((cl == null) ? ENTER_SPRING_LOAD_CANCEL_HOVER_TIME : ENTER_SPRING_LOAD_HOVER_TIME);\r\n    mScreen = cl;\r\n}"
}, {
	"Path": "com.jdon.controller.model.Model.isCacheable",
	"Comment": "in the past version, this method name is iscacheble, now change it after\t1.3 !",
	"Method": "boolean isCacheable(){\r\n    return cacheable;\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.utils.KubernetesResourceUtil.getOrCreateLabels",
	"Comment": "null safe get method for getting labels of a kubernetes resource",
	"Method": "Map<String, String> getOrCreateLabels(HasMetadata entity){\r\n    ObjectMeta metadata = getOrCreateMetadata(entity);\r\n    Map<String, String> answer = metadata.getLabels();\r\n    if (answer == null) {\r\n        answer = new LinkedHashMap();\r\n        metadata.setLabels(answer);\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "org.joda.money.BigMoney.convertRetainScale",
	"Comment": "returns a copy of this monetary value converted into another currencyusing the specified conversion rate, with a rounding mode used to adjustthe decimal places in the result.the result will have the same scale as this instance even though it willbe in a different currency.this instance is immutable and unaffected by this method.",
	"Method": "BigMoney convertRetainScale(CurrencyUnit currency,BigDecimal conversionMultipler,RoundingMode roundingMode){\r\n    return convertedTo(currency, conversionMultipler).withScale(getScale(), roundingMode);\r\n}"
}, {
	"Path": "org.locationtech.jts.simplify.TaggedLinesSimplifier.setDistanceTolerance",
	"Comment": "sets the distance tolerance for the simplification.all vertices in the simplified geometry will be within thisdistance of the original geometry.",
	"Method": "void setDistanceTolerance(double distanceTolerance){\r\n    this.distanceTolerance = distanceTolerance;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.CGAlgorithms.length",
	"Comment": "computes the length of a linestring specified by a sequence of points.",
	"Method": "double length(CoordinateSequence pts){\r\n    int n = pts.size();\r\n    if (n <= 1)\r\n        return 0.0;\r\n    double len = 0.0;\r\n    Coordinate p = new Coordinate();\r\n    pts.getCoordinate(0, p);\r\n    double x0 = p.x;\r\n    double y0 = p.y;\r\n    for (int i = 1; i < n; i++) {\r\n        pts.getCoordinate(i, p);\r\n        double x1 = p.x;\r\n        double y1 = p.y;\r\n        double dx = x1 - x0;\r\n        double dy = y1 - y0;\r\n        len += Math.sqrt(dx * dx + dy * dy);\r\n        x0 = x1;\r\n        y0 = y1;\r\n    }\r\n    return len;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.valid.ConsistentAreaTester.isNodeConsistentArea",
	"Comment": "check all nodes to see if their labels are consistent with area topology.",
	"Method": "boolean isNodeConsistentArea(){\r\n    SegmentIntersector intersector = geomGraph.computeSelfNodes(li, true, true);\r\n    if (intersector.hasProperIntersection()) {\r\n        invalidPoint = intersector.getProperIntersectionPoint();\r\n        return false;\r\n    }\r\n    nodeGraph.build(geomGraph);\r\n    return isNodeEdgeAreaLabelsConsistent();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct8.converge",
	"Comment": "converge this coproduct down to a lower order coproduct by mapping the last possible type into an earlierpossible type.",
	"Method": "CoProduct7<A, B, C, D, E, F, G, ? extends CoProduct7<A, B, C, D, E, F, G, ?>> converge(Function<? super H, ? extends CoProduct7<A, B, C, D, E, F, G, ?>> convergenceFn){\r\n    return match(Choice7::a, Choice7::b, Choice7::c, Choice7::d, Choice7::e, Choice7::f, Choice7::g, convergenceFn::apply);\r\n}"
}, {
	"Path": "org.joda.money.BigMoney.abs",
	"Comment": "returns a copy of this monetary value with a positive amount.this instance is immutable and unaffected by this method.",
	"Method": "BigMoney abs(){\r\n    return (isNegative() ? negated() : this);\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.utils.cache.UnifiedMemberCacheView.getElementsByUsername",
	"Comment": "creates an immutable list of all members matching the given username.this will check the name of the wrapped user.",
	"Method": "List<Member> getElementsByUsername(String name,boolean ignoreCase,List<Member> getElementsByUsername,String name){\r\n    return getElementsByUsername(name, false);\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DD.gt",
	"Comment": "tests whether this value is greater than another doubledouble value.",
	"Method": "boolean gt(DD y){\r\n    return (hi > y.hi) || (hi == y.hi && lo > y.lo);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.PolygonizeGraph.computeNextCCWEdges",
	"Comment": "computes the next edge pointers going ccw around the given node, for thegiven edgering label.this algorithm has the effect of converting maximal edgerings into minimal edgerings",
	"Method": "void computeNextCCWEdges(Node node,long label){\r\n    DirectedEdgeStar deStar = node.getOutEdges();\r\n    PolygonizeDirectedEdge firstOutDE = null;\r\n    PolygonizeDirectedEdge prevInDE = null;\r\n    List edges = deStar.getEdges();\r\n    for (int i = edges.size() - 1; i >= 0; i--) {\r\n        PolygonizeDirectedEdge de = (PolygonizeDirectedEdge) edges.get(i);\r\n        PolygonizeDirectedEdge sym = (PolygonizeDirectedEdge) de.getSym();\r\n        PolygonizeDirectedEdge outDE = null;\r\n        if (de.getLabel() == label)\r\n            outDE = de;\r\n        PolygonizeDirectedEdge inDE = null;\r\n        if (sym.getLabel() == label)\r\n            inDE = sym;\r\n        if (outDE == null && inDE == null)\r\n            continue;\r\n        if (inDE != null) {\r\n            prevInDE = inDE;\r\n        }\r\n        if (outDE != null) {\r\n            if (prevInDE != null) {\r\n                prevInDE.setNext(outDE);\r\n                prevInDE = null;\r\n            }\r\n            if (firstOutDE == null)\r\n                firstOutDE = outDE;\r\n        }\r\n    }\r\n    if (prevInDE != null) {\r\n        Assert.isTrue(firstOutDE != null);\r\n        prevInDE.setNext(firstOutDE);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.precision.MinimumClearance.getDistance",
	"Comment": "computes the minimum clearance distance for the given geometry.",
	"Method": "double getDistance(Geometry g,double getDistance){\r\n    compute();\r\n    return minClearance;\r\n}"
}, {
	"Path": "org.kse.crypto.keystore.KeyStoreUtil.isTrustedCertificateEntry",
	"Comment": "is the named entry in the keystore a trusted certificate entry?",
	"Method": "boolean isTrustedCertificateEntry(String alias,KeyStore keyStore){\r\n    return keyStore.isCertificateEntry(alias);\r\n}"
}, {
	"Path": "org.locationtech.jts.awt.ShapeWriter.setRemoveDuplicatePoints",
	"Comment": "sets whether duplicate consecutive points should be eliminated.\tthis can reduce the size of the generated shapes\tand improve rendering speed, especially in situations\twhere a transform reduces the extent of the geometry.\tthe default is false.",
	"Method": "void setRemoveDuplicatePoints(boolean doRemoveDuplicatePoints){\r\n    this.doRemoveDuplicatePoints = doRemoveDuplicatePoints;\r\n}"
}, {
	"Path": "org.locationtech.jts.precision.CommonBitsRemover.getCommonCoordinate",
	"Comment": "the common bits of the coordinates in the supplied geometries.",
	"Method": "Coordinate getCommonCoordinate(Coordinate getCommonCoordinate){\r\n    return commonCoord;\r\n}"
}, {
	"Path": "org.locationtech.jts.planargraph.Edge.getDirEdge",
	"Comment": "returns one of the directededges associated with this edge.",
	"Method": "DirectedEdge getDirEdge(int i,DirectedEdge getDirEdge,Node fromNode){\r\n    if (dirEdge[0].getFromNode() == fromNode)\r\n        return dirEdge[0];\r\n    if (dirEdge[1].getFromNode() == fromNode)\r\n        return dirEdge[1];\r\n    return null;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.util.AffineTransformation.scale",
	"Comment": "updates the value of this transformationto that of a scale transformation composed with the current value.",
	"Method": "AffineTransformation scale(double xScale,double yScale){\r\n    compose(scaleInstance(xScale, yScale));\r\n    return this;\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.patch.DiffMatchPatch.diffLinesToChars",
	"Comment": "split two texts into a list of strings.reduce the texts to a string ofhashes where each unicode character represents one line.",
	"Method": "LinesToCharsResult diffLinesToChars(String text1,String text2){\r\n    List<String> lineArray = new ArrayList();\r\n    Map<String, Integer> lineHash = new HashMap();\r\n    lineArray.add(\"\");\r\n    String chars1 = this.diffLinesToCharsMunge(text1, lineArray, lineHash);\r\n    String chars2 = this.diffLinesToCharsMunge(text2, lineArray, lineHash);\r\n    return new LinesToCharsResult(chars1, chars2, lineArray);\r\n}"
}, {
	"Path": "org.locationtech.jts.precision.GeometryPrecisionReducer.reduce",
	"Comment": "convenience method for doing precision reduction on a single geometry,\twith collapses removed and keeping the geometry precision model the same,and preserving polygonal topology.",
	"Method": "Geometry reduce(Geometry g,PrecisionModel precModel,Geometry reduce,Geometry geom){\r\n    Geometry reducePW = reducePointwise(geom);\r\n    if (isPointwise)\r\n        return reducePW;\r\n    if (!(reducePW instanceof Polygonal))\r\n        return reducePW;\r\n    if (reducePW.isValid())\r\n        return reducePW;\r\n    return fixPolygonalTopology(reducePW);\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.dsl.base.BaseOperation.updateApiVersionResource",
	"Comment": "updates the list or single item if it has a missing or incorrect apiversion",
	"Method": "void updateApiVersionResource(Object resource){\r\n    if (resource instanceof HasMetadata) {\r\n        HasMetadata hasMetadata = (HasMetadata) resource;\r\n        updateApiVersion(hasMetadata);\r\n    } else if (resource instanceof KubernetesResourceList) {\r\n        KubernetesResourceList list = (KubernetesResourceList) resource;\r\n        updateApiVersion(list);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.OrientationIndexFailureTest.testSanity",
	"Comment": "this is included to confirm this test is operating correctly",
	"Method": "void testSanity(){\r\n    assertTrue(OrientationIndexTest.isAllOrientationsEqual(OrientationIndexTest.getCoordinates(\"LINESTRING ( 0 0, 0 1, 1 1)\")));\r\n}"
}, {
	"Path": "org.locationtech.jts.precision.CommonBitsRemover.add",
	"Comment": "add a geometry to the set of geometries whose common bits arebeing computed.after this method has executed thecommon coordinate reflects the common bits of all addedgeometries.",
	"Method": "void add(Geometry geom){\r\n    geom.apply(ccFilter);\r\n    commonCoord = ccFilter.getCommonCoordinate();\r\n}"
}, {
	"Path": "com.samskivert.mustache.Template.getSectionValue",
	"Comment": "returns the value of the specified variable, noting that it is intended to be used as thecontents for a section.",
	"Method": "Object getSectionValue(Context ctx,String name,int line){\r\n    Object value = getValue(ctx, name, line, !_compiler.strictSections);\r\n    return (value == null) ? Collections.emptyList() : value;\r\n}"
}, {
	"Path": "cn.jpush.api.JPushClient.createWeeklySchedule",
	"Comment": "create a weekly schedule push with a custom frequency at the appointed days.",
	"Method": "ScheduleResult createWeeklySchedule(String name,String start,String end,String time,Week[] days,PushPayload push,ScheduleResult createWeeklySchedule,String name,String start,String end,String time,int frequency,Week[] days,PushPayload push){\r\n    Preconditions.checkArgument(null != days && days.length > 0, \"The days must not be empty.\");\r\n    String[] points = new String[days.length];\r\n    for (int i = 0; i < days.length; i++) {\r\n        points[i] = days[i].name();\r\n    }\r\n    return createPeriodicalSchedule(name, start, end, time, TimeUnit.WEEK, frequency, points, push);\r\n}"
}, {
	"Path": "com.android.launcher3.Workspace.createDragBitmap",
	"Comment": "returns a new bitmap to show when the given view is being dragged around.responsibility for the bitmap is transferred to the caller.",
	"Method": "Bitmap createDragBitmap(View v,AtomicInteger expectedPadding){\r\n    Bitmap b;\r\n    int padding = expectedPadding.get();\r\n    if (v instanceof TextView) {\r\n        Drawable d = getTextViewIcon((TextView) v);\r\n        Rect bounds = getDrawableBounds(d);\r\n        b = Bitmap.createBitmap(bounds.width() + padding, bounds.height() + padding, Bitmap.Config.ARGB_8888);\r\n        expectedPadding.set(padding - bounds.left - bounds.top);\r\n    } else {\r\n        b = Bitmap.createBitmap(v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);\r\n    }\r\n    mCanvas.setBitmap(b);\r\n    drawDragView(v, mCanvas, padding);\r\n    mCanvas.setBitmap(null);\r\n    return b;\r\n}"
}, {
	"Path": "io.fabric8.openshift.client.dsl.internal.SubjectAccessReviewOperationImpl.checkNamespace",
	"Comment": "subject access review is a category on its own so we need to override the default behavior.",
	"Method": "String checkNamespace(T item){\r\n    String operationNs = getNamespace();\r\n    String itemNs = (item instanceof HasMetadata && ((HasMetadata) item).getMetadata() != null) ? ((HasMetadata) item).getMetadata().getNamespace() : null;\r\n    if (Utils.isNullOrEmpty(operationNs) && Utils.isNullOrEmpty(itemNs)) {\r\n        return null;\r\n    } else if (Utils.isNullOrEmpty(itemNs)) {\r\n        return operationNs;\r\n    } else if (Utils.isNullOrEmpty(operationNs)) {\r\n        return itemNs;\r\n    } else if (itemNs.equals(operationNs)) {\r\n        return itemNs;\r\n    }\r\n    throw new KubernetesClientException(\"Namespace mismatch. Item namespace:\" + itemNs + \". Operation namespace:\" + operationNs + \".\");\r\n}"
}, {
	"Path": "org.zeromq.ZContext.createSocket",
	"Comment": "creates a new managed socket within this zcontext instance. use this to get automatic management of the socket atshutdown",
	"Method": "Socket createSocket(int type){\r\n    if (context == null)\r\n        context = ZMQ.context(ioThreads);\r\n    Socket socket = context.socket(type);\r\n    sockets.add(socket);\r\n    return socket;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.distance.DistanceOp.closestPoints",
	"Comment": "compute the the closest points of two geometries.the points are presented in the same order as the input geometries.",
	"Method": "Coordinate[] closestPoints(Geometry g0,Geometry g1,Coordinate[] closestPoints){\r\n    return nearestPoints();\r\n}"
}, {
	"Path": "com.jsql.view.swing.shadow.ShadowPopup.reset",
	"Comment": "reinitializes this shadowpopup using the given parameters.",
	"Method": "void reset(Component owner,Component contents,int x,int y,Popup popup){\r\n    this.owner = owner;\r\n    this.contents = contents;\r\n    this.popup = popup;\r\n    this.x = x;\r\n    this.y = y;\r\n    Dimension contentsPrefSize = new Dimension();\r\n    try {\r\n        contentsPrefSize = contents.getPreferredSize();\r\n    } catch (NullPointerException e) {\r\n        LOGGER.error(e.getMessage(), e);\r\n    }\r\n    if (contentsPrefSize.width <= 0 || contentsPrefSize.height <= 0) {\r\n        return;\r\n    }\r\n    for (Container p = contents.getParent(); p != null; p = p.getParent()) {\r\n        if (p instanceof JWindow || p instanceof Panel) {\r\n            p.setBackground(contents.getBackground());\r\n            this.heavyWeightContainer = p;\r\n            break;\r\n        }\r\n    }\r\n    JComponent parent = (JComponent) contents.getParent();\r\n    this.oldOpaque = parent.isOpaque();\r\n    this.oldBorder = parent.getBorder();\r\n    parent.setOpaque(false);\r\n    parent.setBorder(SHADOW_BORDER);\r\n    if (this.heavyWeightContainer != null) {\r\n        this.heavyWeightContainer.setSize(this.heavyWeightContainer.getPreferredSize());\r\n    } else {\r\n        parent.setSize(parent.getPreferredSize());\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jtstest.util.StringUtil.format",
	"Comment": "returns d as a string truncated to the specified number of decimal places",
	"Method": "String format(double d,int decimals){\r\n    double factor = Math.pow(10, decimals);\r\n    double digits = Math.round(factor * d);\r\n    return ((int) Math.floor(digits / factor)) + \".\" + ((int) (digits % factor));\r\n}"
}, {
	"Path": "com.android.launcher3.Utilities.findSystemApk",
	"Comment": "finds a system apk which had a broadcast receiver listening to a particular action.",
	"Method": "Pair<String, Resources> findSystemApk(String action,PackageManager pm){\r\n    final Intent intent = new Intent(action);\r\n    for (ResolveInfo info : pm.queryBroadcastReceivers(intent, 0)) {\r\n        if (info.activityInfo != null && (info.activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {\r\n            final String packageName = info.activityInfo.packageName;\r\n            try {\r\n                final Resources res = pm.getResourcesForApplication(packageName);\r\n                return Pair.create(packageName, res);\r\n            } catch (NameNotFoundException e) {\r\n                Log.w(TAG, \"Failed to find resources for \" + packageName);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifInterface.getOrientationValueForRotation",
	"Comment": "returns the orientation exiftag value for a given number of degrees.",
	"Method": "short getOrientationValueForRotation(int degrees){\r\n    degrees %= 360;\r\n    if (degrees < 0) {\r\n        degrees += 360;\r\n    }\r\n    if (degrees < 90) {\r\n        return Orientation.TOP_LEFT;\r\n    } else if (degrees < 180) {\r\n        return Orientation.RIGHT_TOP;\r\n    } else if (degrees < 270) {\r\n        return Orientation.BOTTOM_LEFT;\r\n    } else {\r\n        return Orientation.RIGHT_BOTTOM;\r\n    }\r\n}"
}, {
	"Path": "org.joda.money.BigMoney.checkCurrencyEqual",
	"Comment": "validates that the currency of this money and the specified money match.",
	"Method": "BigMoney checkCurrencyEqual(BigMoneyProvider moneyProvider){\r\n    BigMoney money = of(moneyProvider);\r\n    if (isSameCurrency(money) == false) {\r\n        throw new CurrencyMismatchException(getCurrencyUnit(), money.getCurrencyUnit());\r\n    }\r\n    return money;\r\n}"
}, {
	"Path": "org.joda.money.format.MoneyAmountStyle.withGroupingSize",
	"Comment": "returns a copy of this style with the specified grouping size.",
	"Method": "MoneyAmountStyle withGroupingSize(Integer groupingSize){\r\n    int sizeVal = (groupingSize == null ? -1 : groupingSize);\r\n    if (groupingSize != null && sizeVal <= 0) {\r\n        throw new IllegalArgumentException(\"Grouping size must be greater than zero\");\r\n    }\r\n    if (sizeVal == this.groupingSize) {\r\n        return this;\r\n    }\r\n    return new MoneyAmountStyle(zeroCharacter, positiveCharacter, negativeCharacter, decimalPointCharacter, groupingStyle, groupingCharacter, sizeVal, extendedGroupingSize, forceDecimalPoint, absValue);\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.MessageBuilder.isEmpty",
	"Comment": "checks if the message contains any contend. this includes text as well as embeds.",
	"Method": "boolean isEmpty(){\r\n    return builder.length() == 0 && embed == null;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.LastFoundQuadEdgeLocator.locate",
	"Comment": "locates an edge e, such that either v is on e, or e is an edge of a triangle containing v.the search starts from the last located edge and proceeds on the general direction of v.",
	"Method": "QuadEdge locate(Vertex v){\r\n    if (!lastEdge.isLive()) {\r\n        init();\r\n    }\r\n    QuadEdge e = subdiv.locateFromEdge(v, lastEdge);\r\n    lastEdge = e;\r\n    return e;\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.onClickPendingWidget",
	"Comment": "event handler for the app widget view which has not fully restored.",
	"Method": "void onClickPendingWidget(PendingAppWidgetHostView v){\r\n    if (mIsSafeModeEnabled) {\r\n        Toast.makeText(this, R.string.safemode_widget_error, Toast.LENGTH_SHORT).show();\r\n        return;\r\n    }\r\n    final LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) v.getTag();\r\n    if (v.isReadyForClickSetup()) {\r\n        int widgetId = info.appWidgetId;\r\n        AppWidgetProviderInfo appWidgetInfo = mAppWidgetManager.getAppWidgetInfo(widgetId);\r\n        if (appWidgetInfo != null) {\r\n            mPendingAddWidgetInfo = LauncherAppWidgetProviderInfo.fromProviderInfo(this, appWidgetInfo);\r\n            mPendingAddInfo.copyFrom(info);\r\n            mPendingAddWidgetId = widgetId;\r\n            AppWidgetManagerCompat.getInstance(this).startConfigActivity(appWidgetInfo, info.appWidgetId, this, mAppWidgetHost, REQUEST_RECONFIGURE_APPWIDGET);\r\n        }\r\n    } else if (info.installProgress < 0) {\r\n        final String packageName = info.providerName.getPackageName();\r\n        showBrokenAppInstallDialog(packageName, new DialogInterface.OnClickListener() {\r\n            public void onClick(DialogInterface dialog, int id) {\r\n                startActivitySafely(v, LauncherModel.getMarketIntent(packageName), info);\r\n            }\r\n        });\r\n    } else {\r\n        final String packageName = info.providerName.getPackageName();\r\n        startActivitySafely(v, LauncherModel.getMarketIntent(packageName), info);\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.onClickPendingWidget",
	"Comment": "event handler for the app widget view which has not fully restored.",
	"Method": "void onClickPendingWidget(PendingAppWidgetHostView v){\r\n    startActivitySafely(v, LauncherModel.getMarketIntent(packageName), info);\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.Position.opposite",
	"Comment": "returns left if the position is right, right if the position is left, or the positionotherwise.",
	"Method": "int opposite(int position){\r\n    if (position == LEFT)\r\n        return RIGHT;\r\n    if (position == RIGHT)\r\n        return LEFT;\r\n    return position;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.valid.IsValidOp.isValid",
	"Comment": "computes the validity of the geometry,and returns true if it is valid.",
	"Method": "boolean isValid(Geometry geom,boolean isValid,Coordinate coord,boolean isValid){\r\n    checkValid(parentGeometry);\r\n    return validErr == null;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.prep.BasicPreparedGeometry.envelopeCovers",
	"Comment": "determines whether the envelope of this geometry covers the geometry g.",
	"Method": "boolean envelopeCovers(Geometry g){\r\n    if (!baseGeom.getEnvelopeInternal().covers(g.getEnvelopeInternal()))\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.util.LinearComponentExtracter.setForceToLineString",
	"Comment": "indicates that linearring components should be converted to pure linestrings.",
	"Method": "void setForceToLineString(boolean isForcedToLineString){\r\n    this.isForcedToLineString = isForcedToLineString;\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DD.toSciNotation",
	"Comment": "returns the string representation of this value in scientific notation.",
	"Method": "String toSciNotation(){\r\n    if (isZero())\r\n        return SCI_NOT_ZERO;\r\n    String specialStr = getSpecialNumberString();\r\n    if (specialStr != null)\r\n        return specialStr;\r\n    int[] magnitude = new int[1];\r\n    String digits = extractSignificantDigits(false, magnitude);\r\n    String expStr = SCI_NOT_EXPONENT_CHAR + magnitude[0];\r\n    if (digits.charAt(0) == '0') {\r\n        throw new IllegalStateException(\"Found leading zero: \" + digits);\r\n    }\r\n    String trailingDigits = \"\";\r\n    if (digits.length() > 1)\r\n        trailingDigits = digits.substring(1);\r\n    String digitsWithDecimal = digits.charAt(0) + \".\" + trailingDigits;\r\n    if (this.isNegative())\r\n        return \"-\" + digitsWithDecimal + expStr;\r\n    return digitsWithDecimal + expStr;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.OffsetSegmentGenerator.addBevelJoin",
	"Comment": "adds a bevel join connecting the two offset segmentsaround a reflex corner.",
	"Method": "void addBevelJoin(LineSegment offset0,LineSegment offset1){\r\n    segList.addPt(offset0.p1);\r\n    segList.addPt(offset1.p0);\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision.getTriangleEdges",
	"Comment": "gets a list of the triangles\tin the subdivision, specified as\tan array of the primary quadedges around the triangle.",
	"Method": "void getTriangleEdges(QuadEdge startQE,QuadEdge[] triEdge,List getTriangleEdges,boolean includeFrame,List getTriangleEdges){\r\n    TriangleEdgesListVisitor visitor = new TriangleEdgesListVisitor();\r\n    visitTriangles(visitor, includeFrame);\r\n    return visitor.getTriangleEdges();\r\n}"
}, {
	"Path": "com.android.launcher3.allapps.AllAppsGridAdapter.updateBackgroundPadding",
	"Comment": "notifies the adapter of the background padding so that it can draw things correctly in theitem decorator.",
	"Method": "void updateBackgroundPadding(Rect padding){\r\n    mBackgroundPadding.set(padding);\r\n}"
}, {
	"Path": "org.kse.gui.actions.KeyPairCertificateChainDetailsAction.showCertificateSelectedEntry",
	"Comment": "show the certificate details of the selected keystore entry.",
	"Method": "void showCertificateSelectedEntry(){\r\n    try {\r\n        KeyStoreHistory history = kseFrame.getActiveKeyStoreHistory();\r\n        KeyStore keyStore = history.getCurrentState().getKeyStore();\r\n        String alias = kseFrame.getSelectedEntryAlias();\r\n        X509Certificate[] certs = X509CertUtil.convertCertificates(keyStore.getCertificateChain(alias));\r\n        DViewCertificate dViewCertificate = new DViewCertificate(frame, MessageFormat.format(res.getString(\"KeyPairCertificateChainDetailsAction.CertDetailsEntry.Title\"), alias), certs, kseFrame, DViewCertificate.EXPORT);\r\n        dViewCertificate.setLocationRelativeTo(frame);\r\n        dViewCertificate.setVisible(true);\r\n    } catch (Exception ex) {\r\n        DError.displayError(frame, ex);\r\n    }\r\n}"
}, {
	"Path": "org.kse.gui.crypto.generalsubtree.GeneralSubtreesTableHeadRend.getTableCellRendererComponent",
	"Comment": "returns the rendered header cell for the supplied value and column.",
	"Method": "Component getTableCellRendererComponent(JTable jTable,Object value,boolean isSelected,boolean hasFocus,int row,int col){\r\n    Component c = delegate.getTableCellRendererComponent(jTable, value, isSelected, hasFocus, row, col);\r\n    if (c instanceof JLabel) {\r\n        JLabel header = (JLabel) c;\r\n        if (col == 0) {\r\n            header.setToolTipText(res.getString(\"GeneralSubtreesTableHeadRend.BaseColumn.tooltip\"));\r\n        } else if (col == 1) {\r\n            header.setToolTipText(res.getString(\"GeneralSubtreesTableHeadRend.MinimumColumn.tooltip\"));\r\n        } else {\r\n            header.setToolTipText(res.getString(\"GeneralSubtreesTableHeadRend.MaximumColumn.tooltip\"));\r\n        }\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifInterface.setCompressedThumbnail",
	"Comment": "sets the thumbnail to be a jpeg compressed bitmap. clears any priorthumbnail.",
	"Method": "boolean setCompressedThumbnail(byte[] thumb,boolean setCompressedThumbnail,Bitmap thumb){\r\n    ByteArrayOutputStream thumbnail = new ByteArrayOutputStream();\r\n    if (!thumb.compress(Bitmap.CompressFormat.JPEG, 90, thumbnail)) {\r\n        return false;\r\n    }\r\n    return setCompressedThumbnail(thumbnail.toByteArray());\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.BufferParameters.bufferDistanceError",
	"Comment": "computes the maximum distance error due to a given levelof approximation to a true arc.",
	"Method": "double bufferDistanceError(int quadSegs){\r\n    double alpha = Math.PI / 2.0 / quadSegs;\r\n    return 1 - Math.cos(alpha / 2.0);\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.JDABuilder.setMaxReconnectDelay",
	"Comment": "sets the maximum amount of time that jda will back off to wait when attempting to reconnect the mainwebsocket.provided value must be 32 or greater.",
	"Method": "JDABuilder setMaxReconnectDelay(int maxReconnectDelay){\r\n    Checks.check(maxReconnectDelay >= 32, \"Max reconnect delay must be 32 seconds or greater. You provided %d.\", maxReconnectDelay);\r\n    this.maxReconnectDelay = maxReconnectDelay;\r\n    return this;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.overlay.OverlayOp.overlayOp",
	"Comment": "computes an overlay operation for the given geometry arguments.",
	"Method": "Geometry overlayOp(Geometry geom0,Geometry geom1,int opCode){\r\n    OverlayOp gov = new OverlayOp(geom0, geom1);\r\n    Geometry geomOv = gov.getResultGeometry(opCode);\r\n    return geomOv;\r\n}"
}, {
	"Path": "org.kse.gui.crypto.generalsubtree.GeneralSubtreesTableModel.load",
	"Comment": "load the generalsubtreestablemodel with general subtrees.",
	"Method": "void load(GeneralSubtrees generalSubtrees){\r\n    List<GeneralSubtree> generalSubtreesList = generalSubtrees.getGeneralSubtrees();\r\n    Collections.sort(generalSubtreesList, new GeneralSubtreeBaseComparator());\r\n    data = new Object[generalSubtreesList.size()][3];\r\n    int i = 0;\r\n    for (GeneralSubtree generalSubtree : generalSubtreesList) {\r\n        data[i][0] = generalSubtree;\r\n        data[i][1] = generalSubtree;\r\n        data[i][2] = generalSubtree;\r\n        i++;\r\n    }\r\n    fireTableDataChanged();\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.Vertex.isCCW",
	"Comment": "tests whether the triangle formed by this vertex and twoother vertices is in ccw orientation.",
	"Method": "boolean isCCW(Vertex b,Vertex c){\r\n    return (b.p.x - p.x) * (c.p.y - p.y) - (b.p.y - p.y) * (c.p.x - p.x) > 0;\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testbuilder.model.GeometryEditModel.addComponent",
	"Comment": "adds a geometry component of the currently selected type,to the currently selected geometry.",
	"Method": "void addComponent(List coordList){\r\n    GeometryCombiner creator = new GeometryCombiner(JTSTestBuilder.getGeometryFactory());\r\n    Geometry newGeom = null;\r\n    switch(getGeometryType()) {\r\n        case GeometryType.POLYGON:\r\n            newGeom = creator.addPolygonRing(getGeometry(), getRing(coordList));\r\n            break;\r\n        case GeometryType.LINESTRING:\r\n            Coordinate[] pts = CoordinateArrays.toCoordinateArray(coordList);\r\n            newGeom = creator.addLineString(getGeometry(), pts);\r\n            break;\r\n        case GeometryType.POINT:\r\n            newGeom = creator.addPoint(getGeometry(), (Coordinate) coordList.get(0));\r\n            break;\r\n    }\r\n    setGeometry(newGeom);\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.CallableBlind.isTrue",
	"Comment": "check if a result page means the sql query is true,confirm that nothing in the resulting page is also definedin the pages from every false sql queries.",
	"Method": "boolean isTrue(){\r\n    for (Diff falseDiff : InjectionBlind.getConstantFalseMark()) {\r\n        if (this.opcodes.contains(falseDiff)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.DocPositionComparator.equals",
	"Comment": "does this comparator equal another?since all docpositioncomparators are the same, theyare all equal.",
	"Method": "boolean equals(Object obj){\r\n    return this == obj;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.linemerge.LineMergeGraph.addEdge",
	"Comment": "adds an edge, directededges, and nodes for the given linestring representationof an edge. empty lines or lines with all coordinates equal are not added.",
	"Method": "void addEdge(LineString lineString){\r\n    if (lineString.isEmpty()) {\r\n        return;\r\n    }\r\n    Coordinate[] coordinates = CoordinateArrays.removeRepeatedPoints(lineString.getCoordinates());\r\n    if (coordinates.length <= 1)\r\n        return;\r\n    Coordinate startCoordinate = coordinates[0];\r\n    Coordinate endCoordinate = coordinates[coordinates.length - 1];\r\n    Node startNode = getNode(startCoordinate);\r\n    Node endNode = getNode(endCoordinate);\r\n    DirectedEdge directedEdge0 = new LineMergeDirectedEdge(startNode, endNode, coordinates[1], true);\r\n    DirectedEdge directedEdge1 = new LineMergeDirectedEdge(endNode, startNode, coordinates[coordinates.length - 2], false);\r\n    Edge edge = new LineMergeEdge(lineString);\r\n    edge.setDirectedEdges(directedEdge0, directedEdge1);\r\n    add(edge);\r\n}"
}, {
	"Path": "com.android.launcher3.Utilities.calculateTextHeight",
	"Comment": "calculates the height of a given string at a specific text size.",
	"Method": "float calculateTextHeight(float textSizePx){\r\n    Paint p = new Paint();\r\n    p.setTextSize(textSizePx);\r\n    Paint.FontMetrics fm = p.getFontMetrics();\r\n    return -fm.top + fm.bottom;\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isMonth",
	"Comment": "ismonth returns true if string s is a valid month number between 1 and 12.",
	"Method": "boolean isMonth(String s){\r\n    if (isEmpty(s))\r\n        return defaultEmptyOK;\r\n    return isIntegerInRange(s, 1, 12);\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.ConformingDelaunayTriangulator.getVertexFactory",
	"Comment": "gets the constraintvertexfactory used to create new constraint vertices at split points.",
	"Method": "ConstraintVertexFactory getVertexFactory(){\r\n    return vertexFactory;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.events.UpdateEvent.getEntityType",
	"Comment": "class representation of the affected entity, useful when dealing with refection.",
	"Method": "Class<E> getEntityType(){\r\n    return (Class<E>) getEntity().getClass();\r\n}"
}, {
	"Path": "com.jdon.aop.AopClient.invoke",
	"Comment": "dynamic proxy active this method when client call userservice.xxxmethod",
	"Method": "Object invoke(Object invoke,TargetMetaRequest targetMetaRequest,Method method,Object[] args){\r\n    targetMetaRequestsHolder.setTargetMetaRequest(targetMetaRequest);\r\n    Debug.logVerbose(\"[JdonFramework] enter AOP invoker2 for:\" + targetMetaRequest.getTargetMetaDef().getClassName() + \" method:\" + method.getName(), module);\r\n    Object result = null;\r\n    MethodInvocation methodInvocation = null;\r\n    try {\r\n        List<MethodInterceptor> chain = advisorChainFactory.create(targetMetaRequest.getTargetMetaDef());\r\n        methodInvocation = new ProxyMethodInvocation(chain, targetMetaRequestsHolder, targetServiceFactory, method, args);\r\n        Debug.logVerbose(\"[JdonFramework] MethodInvocation will proceed ... \", module);\r\n        result = methodInvocation.proceed();\r\n    } catch (Exception ex) {\r\n        Debug.logError(ex, module);\r\n        throw new Exception(ex);\r\n    } catch (Throwable ex) {\r\n        throw new Throwable(ex);\r\n    } finally {\r\n        targetMetaRequestsHolder.clear();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.jsql.util.StringUtil.decimalHtmlEncode",
	"Comment": "convert special characters like chinese and arabic letters to the corresponding html entities.",
	"Method": "String decimalHtmlEncode(String text){\r\n    return StringUtil.encode(text, DECIMAL_HTML_ENCODER);\r\n}"
}, {
	"Path": "org.locationtech.jts.dissolve.DissolveHalfEdge.isStart",
	"Comment": "tests whether this edge is the starting segmentin a linestring being dissolved.",
	"Method": "boolean isStart(){\r\n    return isStart;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.distance3d.Distance3DOp.nearestPoints",
	"Comment": "report the coordinates of the nearest points in the input geometries. the\tpoints are presented in the same order as the input geometries.",
	"Method": "Coordinate[] nearestPoints(Geometry g0,Geometry g1,Coordinate[] nearestPoints){\r\n    computeMinDistance();\r\n    Coordinate[] nearestPts = new Coordinate[] { minDistanceLocation[0].getCoordinate(), minDistanceLocation[1].getCoordinate() };\r\n    return nearestPts;\r\n}"
}, {
	"Path": "com.android.launcher3.IconCache.cacheLocked",
	"Comment": "retrieves the entry from the cache. if the entry is not present, it creates a new entry.this method is not thread safe, it must be called from a synchronized method.",
	"Method": "CacheEntry cacheLocked(ComponentName componentName,LauncherActivityInfoCompat info,UserHandleCompat user,boolean usePackageIcon,boolean useLowResIcon){\r\n    ComponentKey cacheKey = new ComponentKey(componentName, user);\r\n    CacheEntry entry = mCache.get(cacheKey);\r\n    if (entry == null || (entry.isLowResIcon && !useLowResIcon)) {\r\n        entry = new CacheEntry();\r\n        mCache.put(cacheKey, entry);\r\n        if (!getEntryFromDB(cacheKey, entry, useLowResIcon)) {\r\n            if (info != null) {\r\n                entry.icon = Utilities.createIconBitmap(info.getBadgedIcon(mIconDpi), mContext);\r\n            } else {\r\n                if (usePackageIcon) {\r\n                    CacheEntry packageEntry = getEntryForPackageLocked(componentName.getPackageName(), user, false);\r\n                    if (packageEntry != null) {\r\n                        if (DEBUG)\r\n                            Log.d(TAG, \"using package default icon for \" + componentName.toShortString());\r\n                        entry.icon = packageEntry.icon;\r\n                        entry.title = packageEntry.title;\r\n                        entry.contentDescription = packageEntry.contentDescription;\r\n                    }\r\n                }\r\n                if (entry.icon == null) {\r\n                    if (DEBUG)\r\n                        Log.d(TAG, \"using default icon for \" + componentName.toShortString());\r\n                    entry.icon = getDefaultIcon(user);\r\n                }\r\n            }\r\n        }\r\n        if (TextUtils.isEmpty(entry.title) && info != null) {\r\n            entry.title = info.getLabel();\r\n            entry.contentDescription = mUserManager.getBadgedLabelForUser(entry.title, user);\r\n        }\r\n    }\r\n    return entry;\r\n}"
}, {
	"Path": "org.locationtech.jts.io.oracle.StaticMultiPolygonTest.testSingleMultiPolygonManyPointsNoHoleRoundTrip",
	"Comment": "round trip test for a single multipolygon with lotsa points",
	"Method": "void testSingleMultiPolygonManyPointsNoHoleRoundTrip(){\r\n    PolygonGenerator pgc = new PolygonGenerator();\r\n    pgc.setGeometryFactory(geometryFactory);\r\n    pgc.setGenerationAlgorithm(PolygonGenerator.BOX);\r\n    pgc.setNumberPoints(1000);\r\n    MultiGenerator pg = new MultiGenerator(pgc);\r\n    pg.setBoundingBox(new Envelope(0, 10, 0, 10));\r\n    pg.setNumberGeometries(3);\r\n    pg.setGeometryFactory(geometryFactory);\r\n    MultiPolygon pt = (MultiPolygon) pg.create();\r\n    OraWriter ow = new OraWriter();\r\n    STRUCT st = ow.write(pt, getConnection());\r\n    OraReader or = new OraReader();\r\n    MultiPolygon pt2 = (MultiPolygon) or.read(st);\r\n    assertTrue(\"The input MultiPolygon is not the same as the output MultiPolygon\", pt.equals(pt2));\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.patch.DiffMatchPatch.diffCompute",
	"Comment": "find the differences between two texts.assumes that the texts do nothave any common prefix or suffix.",
	"Method": "LinkedList<Diff> diffCompute(String text1,String text2,boolean checklines,long deadline){\r\n    LinkedList<Diff> diffs = new LinkedList();\r\n    if (text1.length() == 0) {\r\n        diffs.add(new Diff(Operation.INSERT, text2));\r\n        return diffs;\r\n    }\r\n    if (text2.length() == 0) {\r\n        diffs.add(new Diff(Operation.DELETE, text1));\r\n        return diffs;\r\n    }\r\n    {\r\n        String longtext = text1.length() > text2.length() ? text1 : text2;\r\n        String shorttext = text1.length() > text2.length() ? text2 : text1;\r\n        int i = longtext.indexOf(shorttext);\r\n        if (i != -1) {\r\n            Operation op = (text1.length() > text2.length()) ? Operation.DELETE : Operation.INSERT;\r\n            diffs.add(new Diff(op, longtext.substring(0, i)));\r\n            diffs.add(new Diff(Operation.EQUAL, shorttext));\r\n            diffs.add(new Diff(op, longtext.substring(i + shorttext.length())));\r\n            return diffs;\r\n        }\r\n        if (shorttext.length() == 1) {\r\n            diffs.add(new Diff(Operation.DELETE, text1));\r\n            diffs.add(new Diff(Operation.INSERT, text2));\r\n            return diffs;\r\n        }\r\n    }\r\n    String[] hm = this.diffHalfMatch(text1, text2);\r\n    if (hm != null) {\r\n        String text1A = hm[0];\r\n        String text1B = hm[1];\r\n        String text2A = hm[2];\r\n        String text2B = hm[3];\r\n        String midCommon = hm[4];\r\n        LinkedList<Diff> diffsA = this.diffMain(text1A, text2A, checklines, deadline);\r\n        List<Diff> diffsB = this.diffMain(text1B, text2B, checklines, deadline);\r\n        diffs = diffsA;\r\n        diffs.add(new Diff(Operation.EQUAL, midCommon));\r\n        diffs.addAll(diffsB);\r\n        return diffs;\r\n    }\r\n    if (checklines && text1.length() > 100 && text2.length() > 100) {\r\n        return this.diffLineMode(text1, text2, deadline);\r\n    }\r\n    return this.diffBisect(text1, text2, deadline);\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.IntersectionAdder.hasInteriorIntersection",
	"Comment": "an interior intersection is an intersection which isin the interior of some segment.",
	"Method": "boolean hasInteriorIntersection(){\r\n    return hasInterior;\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifInterface.getExifWriterStream",
	"Comment": "returns an outputstream object that writes to a file. exif tags in thisexifinterface object will be added to a jpeg image written to thisstream, removing prior exif tags. other methods of this exifinterfaceobject should not be called until the returned outputstream has beenclosed.",
	"Method": "OutputStream getExifWriterStream(OutputStream outStream,OutputStream getExifWriterStream,String exifOutFileName){\r\n    if (exifOutFileName == null) {\r\n        throw new IllegalArgumentException(NULL_ARGUMENT_STRING);\r\n    }\r\n    OutputStream out = null;\r\n    try {\r\n        out = (OutputStream) new FileOutputStream(exifOutFileName);\r\n    } catch (FileNotFoundException e) {\r\n        closeSilently(out);\r\n        throw e;\r\n    }\r\n    return getExifWriterStream(out);\r\n}"
}, {
	"Path": "org.locationtech.jtstest.util.StringUtil.rightPad",
	"Comment": "pads the string with the given character until it has the given length. if original is longer than the given length, returns original.",
	"Method": "String rightPad(String original,int length,char padChar){\r\n    if (original.length() >= length) {\r\n        return original;\r\n    }\r\n    return original + stringOfChar(padChar, length - original.length());\r\n}"
}, {
	"Path": "test.jts.perf.geom.prep.PreparedPolygonIntersectsPerfTest.testPrepGeomNotCached",
	"Comment": "tests using preparedgeometry, but creating a newpreparedgeometry object each time.this tests whether there is a penalty for using the pg algorithm as a complete replacement for the original algorithm.",
	"Method": "int testPrepGeomNotCached(int iter,Geometry g,List lines){\r\n    if (iter == 0)\r\n        System.out.println(\"Using NON-CACHED Prepared Geometry\");\r\n    PreparedGeometryFactory pgFact = new PreparedGeometryFactory();\r\n    int count = 0;\r\n    for (Iterator i = lines.iterator(); i.hasNext(); ) {\r\n        LineString line = (LineString) i.next();\r\n        PreparedGeometry prepGeom = pgFact.create(g);\r\n        if (prepGeom.intersects(line))\r\n            count++;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.jdon.persistence.hibernate.HibernateTemplate.getMaxResults",
	"Comment": "return the maximum number of rows specified for this hibernatetemplate.",
	"Method": "int getMaxResults(){\r\n    return maxResults;\r\n}"
}, {
	"Path": "com.jdon.container.factory.ContainerBuilderFactory.createContainerBuilder",
	"Comment": "the main method in this class, read all components include interceptors\tfrom xml configure file.\tcreate a micro container instance. and then returen a containerbuilder\tinstance",
	"Method": "ContainerRegistryBuilder createContainerBuilder(AppContextWrapper context,ContainerRegistryBuilder createContainerBuilder,AppContextWrapper context,ContainerWrapper cw,ContainerComponents configComponents,ContainerComponents aspectConfigComponents){\r\n    return new AnnotationContainerBuilder(context, cw, configComponents, aspectConfigComponents, containerLoaderAnnotation);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.OffsetCurveBuilder.getRingCurve",
	"Comment": "this method handles the degenerate cases of single points and lines,as well as rings.",
	"Method": "Coordinate[] getRingCurve(Coordinate[] inputPts,int side,double distance){\r\n    this.distance = distance;\r\n    if (inputPts.length <= 2)\r\n        return getLineCurve(inputPts, distance);\r\n    if (distance == 0.0) {\r\n        return copyCoordinates(inputPts);\r\n    }\r\n    OffsetSegmentGenerator segGen = getSegGen(distance);\r\n    computeRingBufferCurve(inputPts, side, segGen);\r\n    return segGen.getCoordinates();\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.utils.ReplaceValueStream.replaceValues",
	"Comment": "returns a stream with the template parameter expressions replaced",
	"Method": "InputStream replaceValues(InputStream is,Map<String, String> valuesMap,String replaceValues,String json){\r\n    String answer = json;\r\n    for (Map.Entry<String, String> entry : valuesMap.entrySet()) {\r\n        String key = entry.getKey();\r\n        String value = entry.getValue();\r\n        answer = Utils.replaceAllWithoutRegex(answer, \"${\" + key + \"}\", value);\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "com.jsql.util.StringUtil.encode",
	"Comment": "non trivial methods to convert unicode characters to html entities.",
	"Method": "void encode(char c,StringBuilder buff,String encode,String text,CharEncoder encoder){\r\n    StringBuilder buff = new StringBuilder();\r\n    for (int i = 0; i < text.length(); i++) {\r\n        if (text.charAt(i) > 128) {\r\n            encoder.encode(text.charAt(i), buff);\r\n        } else {\r\n            buff.append(text.charAt(i));\r\n        }\r\n    }\r\n    return \"\" + buff;\r\n}"
}, {
	"Path": "org.kse.gui.crypto.generalname.GeneralNamesTableHeadRend.getTableCellRendererComponent",
	"Comment": "returns the rendered header cell for the supplied value and column.",
	"Method": "Component getTableCellRendererComponent(JTable jTable,Object value,boolean isSelected,boolean hasFocus,int row,int col){\r\n    Component c = delegate.getTableCellRendererComponent(jTable, value, isSelected, hasFocus, row, col);\r\n    if (c instanceof JLabel) {\r\n        JLabel header = (JLabel) c;\r\n        header.setToolTipText(res.getString(\"GeneralNamesTableHeadRend.GeneralNameColumn.tooltip\"));\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "com.jsql.view.swing.panel.util.ActionHideShowConsole.actionPerformed",
	"Comment": "hide bottom panel if both main and bottom are visible, alsodisplays an ersatz bar replacing tabbedpane.or else if only main panel is visible then displays bottom paneland hide ersatz panel.",
	"Method": "void actionPerformed(ActionEvent e){\r\n    if (MediatorGui.frame().getSplitHorizontalTopBottom().getTopComponent().isVisible() && MediatorGui.frame().getSplitHorizontalTopBottom().getBottomComponent().isVisible()) {\r\n        PanelConsoles.setLoc(MediatorGui.frame().getSplitHorizontalTopBottom().getDividerLocation());\r\n        MediatorGui.frame().getSplitHorizontalTopBottom().getBottomComponent().setVisible(false);\r\n        this.panel.setVisible(true);\r\n        MediatorGui.frame().getSplitHorizontalTopBottom().disableDragSize();\r\n    } else if (this.panel.isVisible() || !MediatorGui.frame().getSplitHorizontalTopBottom().getTopComponent().isVisible() && MediatorGui.frame().getSplitHorizontalTopBottom().getBottomComponent().isVisible()) {\r\n        MediatorGui.frame().getSplitHorizontalTopBottom().getBottomComponent().setVisible(true);\r\n        MediatorGui.frame().getSplitHorizontalTopBottom().getTopComponent().setVisible(true);\r\n        this.panel.setVisible(false);\r\n        MediatorGui.frame().getSplitHorizontalTopBottom().setDividerLocation(PanelConsoles.getLoc());\r\n        MediatorGui.frame().getSplitHorizontalTopBottom().enableDragSize();\r\n        PanelConsoles.getButtonShowNorth().setVisible(true);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.index.strtree.AbstractSTRtree.getNodeCapacity",
	"Comment": "returns the maximum number of child nodes that a node may have.",
	"Method": "int getNodeCapacity(){\r\n    return nodeCapacity;\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifInterface.setTagDefinition",
	"Comment": "creates a new tag definition in this exifinterface object for a given tidand default ifd. creating a definition with the same tid and default ifdas a previous definition will override it.",
	"Method": "int setTagDefinition(short tagId,int defaultIfd,short tagType,short defaultComponentCount,int[] allowedIfds){\r\n    if (sBannedDefines.contains(tagId)) {\r\n        return TAG_NULL;\r\n    }\r\n    if (ExifTag.isValidType(tagType) && ExifTag.isValidIfd(defaultIfd)) {\r\n        int tagDef = defineTag(defaultIfd, tagId);\r\n        if (tagDef == TAG_NULL) {\r\n            return TAG_NULL;\r\n        }\r\n        int[] otherDefs = getTagDefinitionsForTagId(tagId);\r\n        SparseIntArray infos = getTagInfo();\r\n        boolean defaultCheck = false;\r\n        for (int i : allowedIfds) {\r\n            if (defaultIfd == i) {\r\n                defaultCheck = true;\r\n            }\r\n            if (!ExifTag.isValidIfd(i)) {\r\n                return TAG_NULL;\r\n            }\r\n        }\r\n        if (!defaultCheck) {\r\n            return TAG_NULL;\r\n        }\r\n        int ifdFlags = getFlagsFromAllowedIfds(allowedIfds);\r\n        if (otherDefs != null) {\r\n            for (int def : otherDefs) {\r\n                int tagInfo = infos.get(def);\r\n                int allowedFlags = getAllowedIfdFlagsFromInfo(tagInfo);\r\n                if ((ifdFlags & allowedFlags) != 0) {\r\n                    return TAG_NULL;\r\n                }\r\n            }\r\n        }\r\n        getTagInfo().put(tagDef, ifdFlags << 24 | (tagType << 16) | defaultComponentCount);\r\n        return tagDef;\r\n    }\r\n    return TAG_NULL;\r\n}"
}, {
	"Path": "com.jsql.util.GitUtil.checkUpdate",
	"Comment": "verify if application is up to date against the version on github.",
	"Method": "void checkUpdate(ShowOnConsole displayUpdateMessage){\r\n    if (displayUpdateMessage == ShowOnConsole.YES) {\r\n        LOGGER.trace(I18n.valueByKey(\"UPDATE_LOADING\"));\r\n    }\r\n    try {\r\n        Float versionGit = Float.parseFloat(GitUtil.getJSONObject().getString(\"version\"));\r\n        if (versionGit > Float.parseFloat(InjectionModel.getVersionJsql())) {\r\n            LOGGER.warn(I18n.valueByKey(\"UPDATE_NEW_VERSION\"));\r\n        } else if (displayUpdateMessage == ShowOnConsole.YES) {\r\n            LOGGER.debug(I18n.valueByKey(\"UPDATE_UPTODATE\"));\r\n        }\r\n    } catch (NumberFormatException | IOException e) {\r\n        LOGGER.warn(I18n.valueByKey(\"UPDATE_EXCEPTION\"), e);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.edgegraph.HalfEdge.deltaX",
	"Comment": "the x component of the distance between the orig and dest vertices.",
	"Method": "double deltaX(){\r\n    return sym.orig.x - orig.x;\r\n}"
}, {
	"Path": "com.android.launcher3.SearchDropTargetBar.deferOnDragEnd",
	"Comment": "this is called to defer hiding the delete drop target until the drop animation has completed,instead of hiding immediately when the drag has ended.",
	"Method": "void deferOnDragEnd(){\r\n    mDeferOnDragEnd = true;\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.GraphComponent.updateIM",
	"Comment": "update the im with the contribution for this component.a component only contributes if it has a labelling for both parent geometries",
	"Method": "void updateIM(IntersectionMatrix im){\r\n    Assert.isTrue(label.getGeometryCount() >= 2, \"found partial label\");\r\n    computeIM(im);\r\n}"
}, {
	"Path": "org.locationtech.jts.edgegraph.HalfEdge.deltaY",
	"Comment": "the y component of the distance between the orig and dest vertices.",
	"Method": "double deltaY(){\r\n    return sym.orig.y - orig.y;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.functions.Fn8.apply",
	"Comment": "partially apply this function by taking its first seven arguments.",
	"Method": "I apply(A a,B b,C c,D d,E e,F f,G g,H h,Fn7<B, C, D, E, F, G, H, I> apply,A a,Fn6<C, D, E, F, G, H, I> apply,A a,B b,Fn5<D, E, F, G, H, I> apply,A a,B b,C c,Fn4<E, F, G, H, I> apply,A a,B b,C c,D d,Fn3<F, G, H, I> apply,A a,B b,C c,D d,E e,Fn2<G, H, I> apply,A a,B b,C c,D d,E e,F f,Fn1<H, I> apply,A a,B b,C c,D d,E e,F f,G g){\r\n    return (h) -> apply(a, b, c, d, e, f, g, h);\r\n}"
}, {
	"Path": "test.jts.perf.math.TriPredicate.isInCircleRobust",
	"Comment": "tests if a point is inside the circle defined by the points a, b, c. this test uses robust computation.",
	"Method": "boolean isInCircleRobust(Coordinate a,Coordinate b,Coordinate c,Coordinate p){\r\n    return isInCircleDD(a, b, c, p);\r\n}"
}, {
	"Path": "net.dv8tion.jda.webhook.WebhookMessageBuilder.getFileAmount",
	"Comment": "the amount of files added to this webhookmessagebuilder instance",
	"Method": "int getFileAmount(){\r\n    return fileIndex;\r\n}"
}, {
	"Path": "org.locationtech.jts.edgegraph.HalfEdge.insertAfter",
	"Comment": "insert an edge with the same origin after this one.assumes that the inserted edge is in the correctposition around the ring.",
	"Method": "void insertAfter(HalfEdge e){\r\n    Assert.equals(orig, e.orig());\r\n    HalfEdge save = oNext();\r\n    sym.setNext(e);\r\n    e.sym().setNext(save);\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdge.delete",
	"Comment": "marks this quadedge as being deleted.this does not free the memory used bythis quadedge quartet, but indicatesthat this edge no longer participatesin a subdivision.",
	"Method": "void delete(){\r\n    rot = null;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.EdgeRing.setShell",
	"Comment": "sets the containing shell ring of a ring that has been determined to be a hole.",
	"Method": "void setShell(EdgeRing shell){\r\n    this.shell = shell;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.overlay.OverlayOp.labelIncompleteNode",
	"Comment": "label an isolated node with its relationship to the target geometry.",
	"Method": "void labelIncompleteNode(Node n,int targetIndex){\r\n    int loc = ptLocator.locate(n.getCoordinate(), arg[targetIndex].getGeometry());\r\n    n.getLabel().setLocation(targetIndex, loc);\r\n}"
}, {
	"Path": "com.jsql.view.swing.table.ComparatorColumn.compare",
	"Comment": "custom compare to sort numbers as numbers.strings as strings, with numbers ordered before strings.",
	"Method": "int compare(T object1,T object2){\r\n    boolean isFirstNumber = true;\r\n    boolean isSecondNumber = true;\r\n    String value1 = object1.toString().trim();\r\n    String value2 = object2.toString().trim();\r\n    try {\r\n        Long.parseLong(value1);\r\n    } catch (NumberFormatException e) {\r\n        isFirstNumber = false;\r\n    }\r\n    try {\r\n        Long.parseLong(value2);\r\n    } catch (NumberFormatException e) {\r\n        isSecondNumber = false;\r\n    }\r\n    int sortOrder;\r\n    if (isFirstNumber && isSecondNumber) {\r\n        sortOrder = Long.valueOf(value1).compareTo(Long.valueOf(value2));\r\n    } else if (isFirstNumber) {\r\n        sortOrder = -1;\r\n    } else if (isSecondNumber) {\r\n        sortOrder = 1;\r\n    } else {\r\n        sortOrder = value1.compareToIgnoreCase(value2);\r\n    }\r\n    return sortOrder;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.lens.lenses.CollectionLens.asCopy",
	"Comment": "convenience static factory method for creating a lens that focuses on a copy of a collection, givena function that creates the copy. useful for composition to avoid mutating a collection reference.",
	"Method": "Lens.Simple<CX, CX> asCopy(Function<? super CX, ? extends CX> copyFn){\r\n    return simpleLens(copyFn, (__, copy) -> copy);\r\n}"
}, {
	"Path": "org.locationtech.jts.precision.GeometryPrecisionReducer.setPointwise",
	"Comment": "sets whether the precision reduction will be done in pointwise fashion only.pointwise precision reduction reduces the precisionof the individual coordinates only, but doesnot attempt to recreate valid topology.this is only relevant for geometries containing polygonal components.",
	"Method": "void setPointwise(boolean isPointwise){\r\n    this.isPointwise = isPointwise;\r\n}"
}, {
	"Path": "org.locationtech.jtslab.snapround.GeometryCoordinateReplacer.isValidSize",
	"Comment": "tests if a coordinate array has a size which is valid for the containing geometry.",
	"Method": "boolean isValidSize(Coordinate[] pts,Geometry geom){\r\n    if (pts.length == 0)\r\n        return true;\r\n    int minSize = minimumNonEmptyCoordinatesSize(geom);\r\n    if (pts.length < minSize) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.android.launcher3.BaseRecyclerView.onInterceptTouchEvent",
	"Comment": "we intercept the touch handling only to support fast scrolling when initiated from thescroll bar.otherwise, we fall back to the default recyclerview touch handling.",
	"Method": "boolean onInterceptTouchEvent(RecyclerView rv,MotionEvent ev){\r\n    return handleTouchEvent(ev);\r\n}"
}, {
	"Path": "com.android.launcher3.Folder.hideItem",
	"Comment": "to correspond to the animation of the icon back into the folder. this is",
	"Method": "void hideItem(ShortcutInfo info){\r\n    View v = getViewForInfo(info);\r\n    v.setVisibility(INVISIBLE);\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.index.SegmentIntersector.hasProperInteriorIntersection",
	"Comment": "a proper interior intersection is a proper intersection which is notcontained in the set of boundary nodes set for this segmentintersector.",
	"Method": "boolean hasProperInteriorIntersection(){\r\n    return hasProperInterior;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.prep.PreparedPolygonContainsProperly.containsProperly",
	"Comment": "tests whether this preparedpolygon containsproperly a given geometry.",
	"Method": "boolean containsProperly(PreparedPolygon prep,Geometry geom,boolean containsProperly,Geometry geom){\r\n    boolean isAllInPrepGeomAreaInterior = isAllTestComponentsInTargetInterior(geom);\r\n    if (!isAllInPrepGeomAreaInterior)\r\n        return false;\r\n    List lineSegStr = SegmentStringUtil.extractSegmentStrings(geom);\r\n    boolean segsIntersect = prepPoly.getIntersectionFinder().intersects(lineSegStr);\r\n    if (segsIntersect)\r\n        return false;\r\n    if (geom instanceof Polygonal) {\r\n        boolean isTargetGeomInTestArea = isAnyTargetComponentInAreaTest(geom, prepPoly.getRepresentativePoints());\r\n        if (isTargetGeomInTestArea)\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.GeometryFactory.createPolygon",
	"Comment": "constructs a polygon with the given exterior boundary andinterior boundaries.",
	"Method": "Polygon createPolygon(LinearRing shell,LinearRing[] holes,Polygon createPolygon,CoordinateSequence shell,Polygon createPolygon,Coordinate[] shell,Polygon createPolygon,LinearRing shell,Polygon createPolygon){\r\n    return createPolygon(null, null);\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.SegmentIntersectionDetector.setFindAllIntersectionTypes",
	"Comment": "sets whether processing can terminate once any intersection is found.",
	"Method": "void setFindAllIntersectionTypes(boolean findAllTypes){\r\n    this.findAllTypes = findAllTypes;\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifData.getTag",
	"Comment": "returns the tag with a given tid in the given ifd if the tag exists.otherwise returns null.",
	"Method": "ExifTag getTag(short tag,int ifd){\r\n    IfdData ifdData = mIfdDatas[ifd];\r\n    return (ifdData == null) ? null : ifdData.getTag(tag);\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.RobustLineIntersector.isInSegmentEnvelopes",
	"Comment": "tests whether a point lies in the envelopes of both input segments.a correctly computed intersection point should return truefor this test.since this test is for debugging purposes only, no attempt ismade to optimize the envelope test.",
	"Method": "boolean isInSegmentEnvelopes(Coordinate intPt){\r\n    Envelope env0 = new Envelope(inputLines[0][0], inputLines[0][1]);\r\n    Envelope env1 = new Envelope(inputLines[1][0], inputLines[1][1]);\r\n    return env0.contains(intPt) && env1.contains(intPt);\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifData.addTag",
	"Comment": "adds the given exiftag to the given ifd and returns an existing exiftagwith the same tid or null if none exist.",
	"Method": "ExifTag addTag(ExifTag tag,ExifTag addTag,ExifTag tag,int ifdId){\r\n    if (tag != null && ExifTag.isValidIfd(ifdId)) {\r\n        IfdData ifdData = getOrCreateIfdData(ifdId);\r\n        return ifdData.setTag(tag);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.product.Product7.rotateR7",
	"Comment": "rotate the first seven values of this product one slot to the right.",
	"Method": "Product7<_7, _1, _2, _3, _4, _5, _6> rotateR7(){\r\n    return into((_1, _2, _3, _4, _5, _6, _7) -> product(_7, _1, _2, _3, _4, _5, _6));\r\n}"
}, {
	"Path": "com.android.launcher3.IconCache.removeFromMemCacheLocked",
	"Comment": "remove any records for the supplied package name from memory.",
	"Method": "void removeFromMemCacheLocked(String packageName,UserHandleCompat user){\r\n    HashSet<ComponentKey> forDeletion = new HashSet<ComponentKey>();\r\n    for (ComponentKey key : mCache.keySet()) {\r\n        if (key.componentName.getPackageName().equals(packageName) && key.user.equals(user)) {\r\n            forDeletion.add(key);\r\n        }\r\n    }\r\n    for (ComponentKey condemned : forDeletion) {\r\n        mCache.remove(condemned);\r\n    }\r\n}"
}, {
	"Path": "org.joda.money.format.MoneyFormatter.isParser",
	"Comment": "checks whether this formatter can parse.if the formatter cannot parse, an unsupportedoperationexception willbe thrown from the print methods.",
	"Method": "boolean isParser(){\r\n    return printerParser.isParser();\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.DefaultCoordinateSequenceFactory.instance",
	"Comment": "returns the singleton instance of defaultcoordinatesequencefactory",
	"Method": "DefaultCoordinateSequenceFactory instance(){\r\n    return instanceObject;\r\n}"
}, {
	"Path": "com.android.launcher3.DragController.setScrollView",
	"Comment": "set which view scrolls for touch events near the edge of the screen.",
	"Method": "void setScrollView(View v){\r\n    mScrollView = v;\r\n}"
}, {
	"Path": "org.locationtech.jts.index.quadtree.Node.getNode",
	"Comment": "returns the subquad containing the envelope searchenv.creates the subquad ifit does not already exist.",
	"Method": "Node getNode(Envelope searchEnv){\r\n    int subnodeIndex = getSubnodeIndex(searchEnv, centrex, centrey);\r\n    if (subnodeIndex != -1) {\r\n        Node node = getSubnode(subnodeIndex);\r\n        return node.getNode(searchEnv);\r\n    } else {\r\n        return this;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.VariableWidthBuffer.buffer",
	"Comment": "creates a buffer polygon along a line with the width interpolatedbetween a start width and an end width.",
	"Method": "Geometry buffer(Geometry line,double startWidth,double endWidth){\r\n    double[] width = VariableWidthBuffer.interpolate((LineString) line, startWidth, endWidth);\r\n    VariableWidthBuffer vb = new VariableWidthBuffer(line, width);\r\n    return vb.getResult();\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.Edge.computeIM",
	"Comment": "update the im with the contribution for this component.a component only contributes if it has a labelling for both parent geometries",
	"Method": "void computeIM(IntersectionMatrix im){\r\n    updateIM(label, im);\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherStateTransitionAnimation.startWorkspaceSearchBarAnimation",
	"Comment": "coordinates the workspace search bar animation along with the launcher state animation.",
	"Method": "void startWorkspaceSearchBarAnimation(AnimatorSet animation,Workspace.State fromWorkspaceState,Workspace.State toWorkspaceState,int duration,View overlaySearchBar){\r\n    final SearchDropTargetBar.State toSearchBarState = toWorkspaceState.getSearchDropTargetBarState();\r\n    if (overlaySearchBar != null) {\r\n        if ((toWorkspaceState == Workspace.State.NORMAL) && (fromWorkspaceState == Workspace.State.NORMAL_HIDDEN)) {\r\n            mLauncher.getSearchDropTargetBar().animateToState(toSearchBarState, 0);\r\n        } else if (fromWorkspaceState == Workspace.State.NORMAL) {\r\n            animation.addListener(new AnimatorListenerAdapter() {\r\n                @Override\r\n                public void onAnimationEnd(Animator animation) {\r\n                    mLauncher.getSearchDropTargetBar().animateToState(toSearchBarState, 0);\r\n                }\r\n            });\r\n        } else {\r\n            mLauncher.getSearchDropTargetBar().animateToState(toSearchBarState, duration);\r\n        }\r\n    } else {\r\n        mLauncher.getSearchDropTargetBar().animateToState(toSearchBarState, duration);\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherStateTransitionAnimation.startWorkspaceSearchBarAnimation",
	"Comment": "coordinates the workspace search bar animation along with the launcher state animation.",
	"Method": "void startWorkspaceSearchBarAnimation(AnimatorSet animation,Workspace.State fromWorkspaceState,Workspace.State toWorkspaceState,int duration,View overlaySearchBar){\r\n    mLauncher.getSearchDropTargetBar().animateToState(toSearchBarState, 0);\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.DirectedEdge.setEdgeDepths",
	"Comment": "set both edge depths.one depth for a given side is provided.the other iscomputed depending on the location transition and the depthdelta of the edge.",
	"Method": "void setEdgeDepths(int position,int depth){\r\n    int depthDelta = getEdge().getDepthDelta();\r\n    if (!isForward)\r\n        depthDelta = -depthDelta;\r\n    int directionFactor = 1;\r\n    if (position == Position.LEFT)\r\n        directionFactor = -1;\r\n    int oppositePos = Position.opposite(position);\r\n    int delta = depthDelta * directionFactor;\r\n    int oppositeDepth = depth + delta;\r\n    setDepth(position, depth);\r\n    setDepth(oppositePos, oppositeDepth);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.IsSimpleOp.isSimpleGeometryCollection",
	"Comment": "semantics for geometrycollection is simple iff all components are simple.",
	"Method": "boolean isSimpleGeometryCollection(Geometry geom){\r\n    for (int i = 0; i < geom.getNumGeometries(); i++) {\r\n        Geometry comp = geom.getGeometryN(i);\r\n        if (!computeSimple(comp))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.bindAppWidget",
	"Comment": "add the views for a widget to the workspace.implementation of the method from launchermodel.callbacks.",
	"Method": "void bindAppWidget(LauncherAppWidgetInfo item){\r\n    Runnable r = new Runnable() {\r\n        public void run() {\r\n            bindAppWidget(item);\r\n        }\r\n    };\r\n    if (waitUntilResume(r)) {\r\n        return;\r\n    }\r\n    final long start = DEBUG_WIDGETS ? SystemClock.uptimeMillis() : 0;\r\n    if (DEBUG_WIDGETS) {\r\n        Log.d(TAG, \"bindAppWidget: \" + item);\r\n    }\r\n    final Workspace workspace = mWorkspace;\r\n    LauncherAppWidgetProviderInfo appWidgetInfo = LauncherModel.getProviderInfo(this, item.providerName, item.user);\r\n    if (!mIsSafeModeEnabled && ((item.restoreStatus & LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0) && (item.restoreStatus != LauncherAppWidgetInfo.RESTORE_COMPLETED)) {\r\n        if (appWidgetInfo == null) {\r\n            if (DEBUG_WIDGETS) {\r\n                Log.d(TAG, \"Removing restored widget: id=\" + item.appWidgetId + \" belongs to component \" + item.providerName + \", as the povider is null\");\r\n            }\r\n            LauncherModel.deleteItemFromDatabase(this, item);\r\n            return;\r\n        }\r\n        if ((item.restoreStatus & LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) != 0) {\r\n            PendingAddWidgetInfo pendingInfo = new PendingAddWidgetInfo(this, appWidgetInfo, null);\r\n            pendingInfo.spanX = item.spanX;\r\n            pendingInfo.spanY = item.spanY;\r\n            pendingInfo.minSpanX = item.minSpanX;\r\n            pendingInfo.minSpanY = item.minSpanY;\r\n            Bundle options = null;\r\n            WidgetHostViewLoader.getDefaultOptionsForWidget(this, pendingInfo);\r\n            int newWidgetId = mAppWidgetHost.allocateAppWidgetId();\r\n            boolean success = mAppWidgetManager.bindAppWidgetIdIfAllowed(newWidgetId, appWidgetInfo, options);\r\n            if (!success) {\r\n                mAppWidgetHost.deleteAppWidgetId(newWidgetId);\r\n                if (DEBUG_WIDGETS) {\r\n                    Log.d(TAG, \"Removing restored widget: id=\" + item.appWidgetId + \" belongs to component \" + item.providerName + \", as the launcher is unable to bing a new widget id\");\r\n                }\r\n                LauncherModel.deleteItemFromDatabase(this, item);\r\n                return;\r\n            }\r\n            item.appWidgetId = newWidgetId;\r\n            item.restoreStatus = (appWidgetInfo.configure == null) ? LauncherAppWidgetInfo.RESTORE_COMPLETED : LauncherAppWidgetInfo.FLAG_UI_NOT_READY;\r\n            LauncherModel.updateItemInDatabase(this, item);\r\n        } else if (((item.restoreStatus & LauncherAppWidgetInfo.FLAG_UI_NOT_READY) != 0) && (appWidgetInfo.configure == null)) {\r\n            item.restoreStatus = LauncherAppWidgetInfo.RESTORE_COMPLETED;\r\n            LauncherModel.updateItemInDatabase(this, item);\r\n        }\r\n    }\r\n    if (!mIsSafeModeEnabled && item.restoreStatus == LauncherAppWidgetInfo.RESTORE_COMPLETED) {\r\n        final int appWidgetId = item.appWidgetId;\r\n        if (DEBUG_WIDGETS) {\r\n            Log.d(TAG, \"bindAppWidget: id=\" + item.appWidgetId + \" belongs to component \" + appWidgetInfo.provider);\r\n        }\r\n        item.hostView = mAppWidgetHost.createView(this, appWidgetId, appWidgetInfo);\r\n        item.minSpanX = appWidgetInfo.minSpanX;\r\n        item.minSpanY = appWidgetInfo.minSpanY;\r\n    } else {\r\n        appWidgetInfo = null;\r\n        PendingAppWidgetHostView view = new PendingAppWidgetHostView(this, item, mIsSafeModeEnabled);\r\n        view.updateIcon(mIconCache);\r\n        item.hostView = view;\r\n        item.hostView.updateAppWidget(null);\r\n        item.hostView.setOnClickListener(this);\r\n    }\r\n    item.hostView.setTag(item);\r\n    item.onBindAppWidget(this);\r\n    workspace.addInScreen(item.hostView, item.container, item.screenId, item.cellX, item.cellY, item.spanX, item.spanY, false);\r\n    if (!item.isCustomWidget()) {\r\n        addWidgetToAutoAdvanceIfNeeded(item.hostView, appWidgetInfo);\r\n    }\r\n    workspace.requestLayout();\r\n    if (DEBUG_WIDGETS) {\r\n        Log.d(TAG, \"bound widget id=\" + item.appWidgetId + \" in \" + (SystemClock.uptimeMillis() - start) + \"ms\");\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.bindAppWidget",
	"Comment": "add the views for a widget to the workspace.implementation of the method from launchermodel.callbacks.",
	"Method": "void bindAppWidget(LauncherAppWidgetInfo item){\r\n    bindAppWidget(item);\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherStateTransitionAnimation.startAnimationToWorkspaceFromWidgets",
	"Comment": "starts and animation to the workspace from the widgets view.",
	"Method": "void startAnimationToWorkspaceFromWidgets(Workspace.State fromWorkspaceState,Workspace.State toWorkspaceState,int toWorkspacePage,boolean animated,Runnable onCompleteRunnable){\r\n    final WidgetsContainerView widgetsView = mLauncher.getWidgetsView();\r\n    PrivateTransitionCallbacks cb = new PrivateTransitionCallbacks() {\r\n        @Override\r\n        float getMaterialRevealViewFinalAlpha(View revealView) {\r\n            return 0.3f;\r\n        }\r\n        @Override\r\n        public AnimatorListenerAdapter getMaterialRevealViewAnimatorListener(final View revealView, final View widgetsButtonView) {\r\n            return new AnimatorListenerAdapter() {\r\n                public void onAnimationEnd(Animator animation) {\r\n                    revealView.setVisibility(View.INVISIBLE);\r\n                }\r\n            };\r\n        }\r\n    };\r\n    mCurrentAnimation = startAnimationToWorkspaceFromOverlay(fromWorkspaceState, toWorkspaceState, toWorkspacePage, mLauncher.getWidgetsButton(), widgetsView, widgetsView.getContentView(), widgetsView.getRevealView(), null, animated, onCompleteRunnable, cb);\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherStateTransitionAnimation.startAnimationToWorkspaceFromWidgets",
	"Comment": "starts and animation to the workspace from the widgets view.",
	"Method": "void startAnimationToWorkspaceFromWidgets(Workspace.State fromWorkspaceState,Workspace.State toWorkspaceState,int toWorkspacePage,boolean animated,Runnable onCompleteRunnable){\r\n    return 0.3f;\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherStateTransitionAnimation.startAnimationToWorkspaceFromWidgets",
	"Comment": "starts and animation to the workspace from the widgets view.",
	"Method": "void startAnimationToWorkspaceFromWidgets(Workspace.State fromWorkspaceState,Workspace.State toWorkspaceState,int toWorkspacePage,boolean animated,Runnable onCompleteRunnable){\r\n    return new AnimatorListenerAdapter() {\r\n        public void onAnimationEnd(Animator animation) {\r\n            revealView.setVisibility(View.INVISIBLE);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherStateTransitionAnimation.startAnimationToWorkspaceFromWidgets",
	"Comment": "starts and animation to the workspace from the widgets view.",
	"Method": "void startAnimationToWorkspaceFromWidgets(Workspace.State fromWorkspaceState,Workspace.State toWorkspaceState,int toWorkspacePage,boolean animated,Runnable onCompleteRunnable){\r\n    revealView.setVisibility(View.INVISIBLE);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.linemerge.LineSequencer.isSequenceable",
	"Comment": "tests whether the arrangement of linestrings has a validsequence.",
	"Method": "boolean isSequenceable(){\r\n    computeSequence();\r\n    return isSequenceable;\r\n}"
}, {
	"Path": "org.locationtech.jts.io.WKTFileReader.read",
	"Comment": "reads a sequence of geometries.\tif an offset is specified, geometries read up to the offset count are skipped.\tif a limit is specified, no more than limit geometries are read.",
	"Method": "List read(List read,BufferedReader bufferedReader){\r\n    List geoms = new ArrayList();\r\n    while (!isAtEndOfFile(bufferedReader) && !isAtLimit(geoms)) {\r\n        Geometry g = wktReader.read(bufferedReader);\r\n        if (count >= offset)\r\n            geoms.add(g);\r\n        count++;\r\n    }\r\n    return geoms;\r\n}"
}, {
	"Path": "org.locationtech.jts.linearref.LocationIndexedLine.isValidIndex",
	"Comment": "tests whether an index is in the valid index range for the line.",
	"Method": "boolean isValidIndex(LinearLocation index){\r\n    return index.isValid(linearGeom);\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.createShortcut",
	"Comment": "creates a view representing a shortcut inflated from the specified resource.",
	"Method": "View createShortcut(ShortcutInfo info,View createShortcut,ViewGroup parent,ShortcutInfo info){\r\n    BubbleTextView favorite = (BubbleTextView) mInflater.inflate(R.layout.app_icon, parent, false);\r\n    favorite.applyFromShortcutInfo(info, mIconCache);\r\n    favorite.setCompoundDrawablePadding(mDeviceProfile.iconDrawablePaddingPx);\r\n    favorite.setOnClickListener(this);\r\n    favorite.setOnFocusChangeListener(mFocusHandler);\r\n    return favorite;\r\n}"
}, {
	"Path": "com.android.launcher3.AppWidgetResizeFrame.resizeWidgetIfNeeded",
	"Comment": "based on the current deltas, we determine if and how to resize the widget.",
	"Method": "void resizeWidgetIfNeeded(boolean onDismiss){\r\n    int xThreshold = mCellLayout.getCellWidth() + mCellLayout.getWidthGap();\r\n    int yThreshold = mCellLayout.getCellHeight() + mCellLayout.getHeightGap();\r\n    int deltaX = mDeltaX + mDeltaXAddOn;\r\n    int deltaY = mDeltaY + mDeltaYAddOn;\r\n    float hSpanIncF = 1.0f * deltaX / xThreshold - mRunningHInc;\r\n    float vSpanIncF = 1.0f * deltaY / yThreshold - mRunningVInc;\r\n    int hSpanInc = 0;\r\n    int vSpanInc = 0;\r\n    int cellXInc = 0;\r\n    int cellYInc = 0;\r\n    int countX = mCellLayout.getCountX();\r\n    int countY = mCellLayout.getCountY();\r\n    if (Math.abs(hSpanIncF) > RESIZE_THRESHOLD) {\r\n        hSpanInc = Math.round(hSpanIncF);\r\n    }\r\n    if (Math.abs(vSpanIncF) > RESIZE_THRESHOLD) {\r\n        vSpanInc = Math.round(vSpanIncF);\r\n    }\r\n    if (!onDismiss && (hSpanInc == 0 && vSpanInc == 0))\r\n        return;\r\n    CellLayout.LayoutParams lp = (CellLayout.LayoutParams) mWidgetView.getLayoutParams();\r\n    int spanX = lp.cellHSpan;\r\n    int spanY = lp.cellVSpan;\r\n    int cellX = lp.useTmpCoords ? lp.tmpCellX : lp.cellX;\r\n    int cellY = lp.useTmpCoords ? lp.tmpCellY : lp.cellY;\r\n    int hSpanDelta = 0;\r\n    int vSpanDelta = 0;\r\n    if (mLeftBorderActive) {\r\n        cellXInc = Math.max(-cellX, hSpanInc);\r\n        cellXInc = Math.min(lp.cellHSpan - mMinHSpan, cellXInc);\r\n        hSpanInc *= -1;\r\n        hSpanInc = Math.min(cellX, hSpanInc);\r\n        hSpanInc = Math.max(-(lp.cellHSpan - mMinHSpan), hSpanInc);\r\n        hSpanDelta = -hSpanInc;\r\n    } else if (mRightBorderActive) {\r\n        hSpanInc = Math.min(countX - (cellX + spanX), hSpanInc);\r\n        hSpanInc = Math.max(-(lp.cellHSpan - mMinHSpan), hSpanInc);\r\n        hSpanDelta = hSpanInc;\r\n    }\r\n    if (mTopBorderActive) {\r\n        cellYInc = Math.max(-cellY, vSpanInc);\r\n        cellYInc = Math.min(lp.cellVSpan - mMinVSpan, cellYInc);\r\n        vSpanInc *= -1;\r\n        vSpanInc = Math.min(cellY, vSpanInc);\r\n        vSpanInc = Math.max(-(lp.cellVSpan - mMinVSpan), vSpanInc);\r\n        vSpanDelta = -vSpanInc;\r\n    } else if (mBottomBorderActive) {\r\n        vSpanInc = Math.min(countY - (cellY + spanY), vSpanInc);\r\n        vSpanInc = Math.max(-(lp.cellVSpan - mMinVSpan), vSpanInc);\r\n        vSpanDelta = vSpanInc;\r\n    }\r\n    mDirectionVector[0] = 0;\r\n    mDirectionVector[1] = 0;\r\n    if (mLeftBorderActive || mRightBorderActive) {\r\n        spanX += hSpanInc;\r\n        cellX += cellXInc;\r\n        if (hSpanDelta != 0) {\r\n            mDirectionVector[0] = mLeftBorderActive ? -1 : 1;\r\n        }\r\n    }\r\n    if (mTopBorderActive || mBottomBorderActive) {\r\n        spanY += vSpanInc;\r\n        cellY += cellYInc;\r\n        if (vSpanDelta != 0) {\r\n            mDirectionVector[1] = mTopBorderActive ? -1 : 1;\r\n        }\r\n    }\r\n    if (!onDismiss && vSpanDelta == 0 && hSpanDelta == 0)\r\n        return;\r\n    if (onDismiss) {\r\n        mDirectionVector[0] = mLastDirectionVector[0];\r\n        mDirectionVector[1] = mLastDirectionVector[1];\r\n    } else {\r\n        mLastDirectionVector[0] = mDirectionVector[0];\r\n        mLastDirectionVector[1] = mDirectionVector[1];\r\n    }\r\n    if (mCellLayout.createAreaForResize(cellX, cellY, spanX, spanY, mWidgetView, mDirectionVector, onDismiss)) {\r\n        lp.tmpCellX = cellX;\r\n        lp.tmpCellY = cellY;\r\n        lp.cellHSpan = spanX;\r\n        lp.cellVSpan = spanY;\r\n        mRunningVInc += vSpanDelta;\r\n        mRunningHInc += hSpanDelta;\r\n        if (!onDismiss) {\r\n            updateWidgetSizeRanges(mWidgetView, mLauncher, spanX, spanY);\r\n        }\r\n    }\r\n    mWidgetView.requestLayout();\r\n}"
}, {
	"Path": "org.joda.money.format.MoneyAmountStyle.withExtendedGroupingSize",
	"Comment": "returns a copy of this style with the specified extended grouping size.",
	"Method": "MoneyAmountStyle withExtendedGroupingSize(Integer extendedGroupingSize){\r\n    int sizeVal = (extendedGroupingSize == null ? -1 : extendedGroupingSize);\r\n    if (extendedGroupingSize != null && sizeVal < 0) {\r\n        throw new IllegalArgumentException(\"Extended grouping size must not be negative\");\r\n    }\r\n    if (sizeVal == this.extendedGroupingSize) {\r\n        return this;\r\n    }\r\n    return new MoneyAmountStyle(zeroCharacter, positiveCharacter, negativeCharacter, decimalPointCharacter, groupingStyle, groupingCharacter, groupingSize, sizeVal, forceDecimalPoint, absValue);\r\n}"
}, {
	"Path": "com.jsql.util.CertificateUtil.ignoreCertificationChain",
	"Comment": "configure a fake ssl context in order to ignore malformed certificate.",
	"Method": "void ignoreCertificationChain(){\r\n    TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\r\n        @Override\r\n        public X509Certificate[] getAcceptedIssuers() {\r\n            return new X509Certificate[0];\r\n        }\r\n        @Override\r\n        public void checkClientTrusted(X509Certificate[] certs, String authType) {\r\n        }\r\n        @Override\r\n        public void checkServerTrusted(X509Certificate[] certs, String authType) {\r\n        }\r\n    } };\r\n    try {\r\n        SSLContext sc = SSLContext.getInstance(\"SSL\");\r\n        sc.init(null, trustAllCerts, new java.security.SecureRandom());\r\n        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\r\n    } catch (Exception e) {\r\n        LOGGER.warn(\"Error ignoring untrusted SSL: \" + e.getMessage(), e);\r\n    }\r\n    HttpsURLConnection.setDefaultHostnameVerifier((String hostname, SSLSession sslSession) -> true);\r\n}"
}, {
	"Path": "com.jsql.util.CertificateUtil.ignoreCertificationChain",
	"Comment": "configure a fake ssl context in order to ignore malformed certificate.",
	"Method": "void ignoreCertificationChain(){\r\n    return new X509Certificate[0];\r\n}"
}, {
	"Path": "com.jsql.util.CertificateUtil.ignoreCertificationChain",
	"Comment": "configure a fake ssl context in order to ignore malformed certificate.",
	"Method": "void ignoreCertificationChain(){\r\n}"
}, {
	"Path": "com.jsql.util.CertificateUtil.ignoreCertificationChain",
	"Comment": "configure a fake ssl context in order to ignore malformed certificate.",
	"Method": "void ignoreCertificationChain(){\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.util.SineStarFactory.setArmLengthRatio",
	"Comment": "sets the ration of the length of each arm to the distance from the tipof the arm to the centre of the star.value should be between 0.0 and 1.0",
	"Method": "void setArmLengthRatio(double armLengthRatio){\r\n    this.armLengthRatio = armLengthRatio;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.LineIntersector.isIntersection",
	"Comment": "test whether a point is a intersection point of two line segments.note that if the intersection is a line segment, this method only tests forequality with the endpoints of the intersection segment.it does not return true ifthe input point is internal to the intersection segment.",
	"Method": "boolean isIntersection(Coordinate pt){\r\n    for (int i = 0; i < result; i++) {\r\n        if (intPt[i].equals2D(pt)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.EdgeRing.getCoordinates",
	"Comment": "computes the list of coordinates which are contained in this ring.the coordinates are computed once only and cached.",
	"Method": "Coordinate[] getCoordinates(){\r\n    if (ringPts == null) {\r\n        CoordinateList coordList = new CoordinateList();\r\n        for (Iterator i = deList.iterator(); i.hasNext(); ) {\r\n            DirectedEdge de = (DirectedEdge) i.next();\r\n            PolygonizeEdge edge = (PolygonizeEdge) de.getEdge();\r\n            addEdge(edge.getLine().getCoordinates(), de.getEdgeDirection(), coordList);\r\n        }\r\n        ringPts = coordList.toCoordinateArray();\r\n    }\r\n    return ringPts;\r\n}"
}, {
	"Path": "org.zeromq.ZMsg.contentSize",
	"Comment": "return total number of bytes contained in all zframes in this zmsg",
	"Method": "long contentSize(){\r\n    long size = 0;\r\n    for (ZFrame f : frames) {\r\n        size += f.size();\r\n    }\r\n    return size;\r\n}"
}, {
	"Path": "com.jsql.view.swing.shadow.ShadowPopupFactory.uninstall",
	"Comment": "uninstalls the shadowpopupfactory and restores the originalpopup factory as the new shared popup factory.",
	"Method": "void uninstall(){\r\n    PopupFactory factory = PopupFactory.getSharedInstance();\r\n    if (!(factory instanceof ShadowPopupFactory)) {\r\n        return;\r\n    }\r\n    PopupFactory stored = ((ShadowPopupFactory) factory).storedFactory;\r\n    PopupFactory.setSharedInstance(stored);\r\n}"
}, {
	"Path": "com.jsql.view.swing.shadow.SystemUtils.getSystemProperty",
	"Comment": "tries to look up the system property for the given key.in untrusted environments this may throw a securityexception.in this case we catch the exception and answer an empty string.",
	"Method": "String getSystemProperty(String key){\r\n    try {\r\n        return System.getProperty(key);\r\n    } catch (SecurityException e) {\r\n        LOGGER.error(\"Can't access the System property \" + key + \": \" + e.getMessage(), e);\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.overlay.PolygonBuilder.findShell",
	"Comment": "this method takes a list of minimaledgerings derived from a maximaledgering,and tests whether they form a polygon.this is the case if there is a single shellin the list.in this case the shell is returned.the other possibility is that they are a series of connected holes, in which caseno shell is returned.",
	"Method": "EdgeRing findShell(List minEdgeRings){\r\n    int shellCount = 0;\r\n    EdgeRing shell = null;\r\n    for (Iterator it = minEdgeRings.iterator(); it.hasNext(); ) {\r\n        EdgeRing er = (MinimalEdgeRing) it.next();\r\n        if (!er.isHole()) {\r\n            shell = er;\r\n            shellCount++;\r\n        }\r\n    }\r\n    Assert.isTrue(shellCount <= 1, \"found two shells in MinimalEdgeRing list\");\r\n    return shell;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.overlay.snap.LineStringSnapper.snapTo",
	"Comment": "snaps the vertices and segments of the source linestring to the given set of snap vertices.",
	"Method": "Coordinate[] snapTo(Coordinate[] snapPts){\r\n    CoordinateList coordList = new CoordinateList(srcPts);\r\n    snapVertices(coordList, snapPts);\r\n    snapSegments(coordList, snapPts);\r\n    Coordinate[] newPts = coordList.toCoordinateArray();\r\n    return newPts;\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.bindShortcutsChanged",
	"Comment": "some shortcuts were updated in the background.implementation of the method from launchermodel.callbacks.",
	"Method": "void bindShortcutsChanged(ArrayList<ShortcutInfo> updated,ArrayList<ShortcutInfo> removed,UserHandleCompat user){\r\n    Runnable r = new Runnable() {\r\n        public void run() {\r\n            bindShortcutsChanged(updated, removed, user);\r\n        }\r\n    };\r\n    if (waitUntilResume(r)) {\r\n        return;\r\n    }\r\n    if (!updated.isEmpty()) {\r\n        mWorkspace.updateShortcuts(updated);\r\n    }\r\n    if (!removed.isEmpty()) {\r\n        HashSet<ComponentName> removedComponents = new HashSet<ComponentName>();\r\n        for (ShortcutInfo si : removed) {\r\n            removedComponents.add(si.getTargetComponent());\r\n        }\r\n        mWorkspace.removeItemsByComponentName(removedComponents, user);\r\n        mDragController.onAppsRemoved(new ArrayList<String>(), removedComponents);\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.bindShortcutsChanged",
	"Comment": "some shortcuts were updated in the background.implementation of the method from launchermodel.callbacks.",
	"Method": "void bindShortcutsChanged(ArrayList<ShortcutInfo> updated,ArrayList<ShortcutInfo> removed,UserHandleCompat user){\r\n    bindShortcutsChanged(updated, removed, user);\r\n}"
}, {
	"Path": "com.android.launcher3.DragController.addDropTarget",
	"Comment": "add a droptarget to the list of potential places to receive drop events.",
	"Method": "void addDropTarget(DropTarget target){\r\n    mDropTargets.add(target);\r\n}"
}, {
	"Path": "org.kse.gui.actions.CloseAction.closeActiveKeyStore",
	"Comment": "close the active keystore. allow the user to save it if there are unsaved\tchanges.",
	"Method": "boolean closeActiveKeyStore(){\r\n    return closeKeyStore(kseFrame.getActiveKeyStoreHistory());\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct4.projectD",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the fourth slot value.",
	"Method": "Maybe<D> projectD(){\r\n    return project()._4();\r\n}"
}, {
	"Path": "com.android.launcher3.widget.WidgetsRecyclerView.setWidgets",
	"Comment": "sets the widget model in this view, used to determine the fast scroll position.",
	"Method": "void setWidgets(WidgetsModel widgets){\r\n    mWidgets = widgets;\r\n}"
}, {
	"Path": "org.jpmml.evaluator.FieldValue.isIn",
	"Comment": "checks if this value is contained in the set of reference values.",
	"Method": "boolean isIn(HasValueSet<?> hasValueSet,boolean isIn,HasParsedValueSet<?> hasParsedValueSet,boolean isIn,Collection<FieldValue> values){\r\n    Predicate<FieldValue> predicate = new Predicate<FieldValue>() {\r\n        @Override\r\n        public boolean test(FieldValue value) {\r\n            if (Objects.equals(FieldValues.MISSING_VALUE, value)) {\r\n                return false;\r\n            }\r\n            return equalsValue(value);\r\n        }\r\n    };\r\n    return values.stream().anyMatch(predicate);\r\n}"
}, {
	"Path": "org.jpmml.evaluator.FieldValue.isIn",
	"Comment": "checks if this value is contained in the set of reference values.",
	"Method": "boolean isIn(HasValueSet<?> hasValueSet,boolean isIn,HasParsedValueSet<?> hasParsedValueSet,boolean isIn,Collection<FieldValue> values){\r\n    if (Objects.equals(FieldValues.MISSING_VALUE, value)) {\r\n        return false;\r\n    }\r\n    return equalsValue(value);\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isIntegerInRange",
	"Comment": "isintegerinrange returns true if string s is an integer within the range of integer arguments a and b, inclusive.",
	"Method": "boolean isIntegerInRange(String s,int a,int b){\r\n    if (isEmpty(s))\r\n        return defaultEmptyOK;\r\n    if (!isSignedInteger(s))\r\n        return false;\r\n    int num = Integer.parseInt(s);\r\n    return ((num >= a) && (num <= b));\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.Try.catching",
	"Comment": "catch any thrown t satisfying predicate and map it to a success value.",
	"Method": "Try<T, A> catching(Class<S> throwableType,Function<? super S, ? extends A> recoveryFn,Try<T, A> catching,Function<? super T, ? extends Boolean> predicate,Function<? super T, ? extends A> recoveryFn){\r\n    return match(t -> predicate.apply(t) ? success(recoveryFn.apply(t)) : failure(t), Try::success);\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.syntax.SQLLexer.yypushback",
	"Comment": "pushes the specified amount of characters back into the input stream.they will be read again by then next call of the scanning method",
	"Method": "void yypushback(int number){\r\n    if (number > this.yylength()) {\r\n        this.zzScanError(ZZ_PUSHBACK_2BIG);\r\n    }\r\n    this.zzMarkedPos -= number;\r\n}"
}, {
	"Path": "org.locationtech.jts.precision.CommonBitsOpTest.testPackedCoordinateSequence",
	"Comment": "tests an issue where commonbitsremover was not persisting changes to some kinds of coordinatesequences",
	"Method": "void testPackedCoordinateSequence(){\r\n    GeometryFactory pcsFactory = new GeometryFactory(PackedCoordinateSequenceFactory.DOUBLE_FACTORY);\r\n    Geometry geom0 = read(pcsFactory, \"POLYGON ((210 210, 210 220, 220 220, 220 210, 210 210))\");\r\n    Geometry geom1 = read(\"POLYGON ((225 225, 225 215, 215 215, 215 225, 225 225))\");\r\n    CommonBitsOp cbo = new CommonBitsOp(true);\r\n    Geometry result = cbo.intersection(geom0, geom1);\r\n    Geometry expected = geom0.intersection(geom1);\r\n    checkEqual(expected, result);\r\n}"
}, {
	"Path": "org.locationtech.jts.io.kml.KMLWriter.createFormatter",
	"Comment": "creates the decimalformat used to write doubleswith a sufficient number of decimal places.",
	"Method": "DecimalFormat createFormatter(int precision){\r\n    DecimalFormatSymbols symbols = new DecimalFormatSymbols();\r\n    symbols.setDecimalSeparator('.');\r\n    DecimalFormat format = new DecimalFormat(\"0.\" + StringUtil.chars('#', precision), symbols);\r\n    format.setDecimalSeparatorAlwaysShown(false);\r\n    return format;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct4.projectB",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the second slot value.",
	"Method": "Maybe<B> projectB(){\r\n    return project()._2();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct4.projectC",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the third slot value.",
	"Method": "Maybe<C> projectC(){\r\n    return project()._3();\r\n}"
}, {
	"Path": "com.android.launcher3.Workspace.removeItemsByComponentName",
	"Comment": "removes items that match the item info specified. when applications are removedas a part of an update, this is called to ensure that other widgets and applicationshortcuts are not removed.",
	"Method": "void removeItemsByComponentName(HashSet<ComponentName> componentNames,UserHandleCompat user){\r\n    ArrayList<CellLayout> cellLayouts = getWorkspaceAndHotseatCellLayouts();\r\n    for (final CellLayout layoutParent : cellLayouts) {\r\n        final ViewGroup layout = layoutParent.getShortcutsAndWidgets();\r\n        final HashMap<ItemInfo, View> children = new HashMap<ItemInfo, View>();\r\n        for (int j = 0; j < layout.getChildCount(); j++) {\r\n            final View view = layout.getChildAt(j);\r\n            children.put((ItemInfo) view.getTag(), view);\r\n        }\r\n        final ArrayList<View> childrenToRemove = new ArrayList<View>();\r\n        final HashMap<FolderInfo, ArrayList<ShortcutInfo>> folderAppsToRemove = new HashMap<FolderInfo, ArrayList<ShortcutInfo>>();\r\n        LauncherModel.ItemInfoFilter filter = new LauncherModel.ItemInfoFilter() {\r\n            @Override\r\n            public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {\r\n                if (parent instanceof FolderInfo) {\r\n                    if (componentNames.contains(cn) && info.user.equals(user)) {\r\n                        FolderInfo folder = (FolderInfo) parent;\r\n                        ArrayList<ShortcutInfo> appsToRemove;\r\n                        if (folderAppsToRemove.containsKey(folder)) {\r\n                            appsToRemove = folderAppsToRemove.get(folder);\r\n                        } else {\r\n                            appsToRemove = new ArrayList<ShortcutInfo>();\r\n                            folderAppsToRemove.put(folder, appsToRemove);\r\n                        }\r\n                        appsToRemove.add((ShortcutInfo) info);\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (componentNames.contains(cn) && info.user.equals(user)) {\r\n                        childrenToRemove.add(children.get(info));\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n        };\r\n        LauncherModel.filterItemInfos(children.keySet(), filter);\r\n        for (FolderInfo folder : folderAppsToRemove.keySet()) {\r\n            ArrayList<ShortcutInfo> appsToRemove = folderAppsToRemove.get(folder);\r\n            for (ShortcutInfo info : appsToRemove) {\r\n                folder.remove(info);\r\n            }\r\n        }\r\n        for (View child : childrenToRemove) {\r\n            layoutParent.removeViewInLayout(child);\r\n            if (child instanceof DropTarget) {\r\n                mDragController.removeDropTarget((DropTarget) child);\r\n            }\r\n        }\r\n        if (childrenToRemove.size() > 0) {\r\n            layout.requestLayout();\r\n            layout.invalidate();\r\n        }\r\n    }\r\n    stripEmptyScreens();\r\n}"
}, {
	"Path": "com.android.launcher3.Workspace.removeItemsByComponentName",
	"Comment": "removes items that match the item info specified. when applications are removedas a part of an update, this is called to ensure that other widgets and applicationshortcuts are not removed.",
	"Method": "void removeItemsByComponentName(HashSet<ComponentName> componentNames,UserHandleCompat user){\r\n    if (parent instanceof FolderInfo) {\r\n        if (componentNames.contains(cn) && info.user.equals(user)) {\r\n            FolderInfo folder = (FolderInfo) parent;\r\n            ArrayList<ShortcutInfo> appsToRemove;\r\n            if (folderAppsToRemove.containsKey(folder)) {\r\n                appsToRemove = folderAppsToRemove.get(folder);\r\n            } else {\r\n                appsToRemove = new ArrayList<ShortcutInfo>();\r\n                folderAppsToRemove.put(folder, appsToRemove);\r\n            }\r\n            appsToRemove.add((ShortcutInfo) info);\r\n            return true;\r\n        }\r\n    } else {\r\n        if (componentNames.contains(cn) && info.user.equals(user)) {\r\n            childrenToRemove.add(children.get(info));\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct4.projectA",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the first slot value.",
	"Method": "Maybe<A> projectA(){\r\n    return project()._1();\r\n}"
}, {
	"Path": "com.android.launcher3.allapps.AllAppsRecyclerView.setApps",
	"Comment": "sets the list of apps in this view, used to determine the fastscroll position.",
	"Method": "void setApps(AlphabeticalAppsList apps){\r\n    mApps = apps;\r\n}"
}, {
	"Path": "com.android.launcher3.WidgetPreviewLoader.readFromDb",
	"Comment": "reads the preview bitmap from the db or null if the preview is not in the db.",
	"Method": "Bitmap readFromDb(WidgetCacheKey key,Bitmap recycle,PreviewLoadTask loadTask){\r\n    Cursor cursor = null;\r\n    try {\r\n        cursor = mDb.getReadableDatabase().query(CacheDb.TABLE_NAME, new String[] { CacheDb.COLUMN_PREVIEW_BITMAP }, CacheDb.COLUMN_COMPONENT + \" = ? AND \" + CacheDb.COLUMN_USER + \" = ? AND \" + CacheDb.COLUMN_SIZE + \" = ?\", new String[] { key.componentName.flattenToString(), Long.toString(mUserManager.getSerialNumberForUser(key.user)), key.size }, null, null, null);\r\n        if (loadTask.isCancelled()) {\r\n            return null;\r\n        }\r\n        if (cursor.moveToNext()) {\r\n            byte[] blob = cursor.getBlob(0);\r\n            BitmapFactory.Options opts = new BitmapFactory.Options();\r\n            opts.inBitmap = recycle;\r\n            try {\r\n                if (!loadTask.isCancelled()) {\r\n                    return BitmapFactory.decodeByteArray(blob, 0, blob.length, opts);\r\n                }\r\n            } catch (Exception e) {\r\n                return null;\r\n            }\r\n        }\r\n    } catch (SQLException e) {\r\n        Log.w(TAG, \"Error loading preview from DB\", e);\r\n    } finally {\r\n        if (cursor != null) {\r\n            cursor.close();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct6.projectF",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the sixth slot value.",
	"Method": "Maybe<F> projectF(){\r\n    return project()._6();\r\n}"
}, {
	"Path": "org.joda.money.BigMoney.isLessThan",
	"Comment": "checks if this monetary value is less than another.the compared values must be in the same currency.",
	"Method": "boolean isLessThan(BigMoneyProvider other){\r\n    return compareTo(other) < 0;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct6.projectC",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the third slot value.",
	"Method": "Maybe<C> projectC(){\r\n    return project()._3();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct6.projectB",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the second slot value.",
	"Method": "Maybe<B> projectB(){\r\n    return project()._2();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct6.projectE",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the fifth slot value.",
	"Method": "Maybe<E> projectE(){\r\n    return project()._5();\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.getRestoredItemInfo",
	"Comment": "make an shortcutinfo object for a restored application or shortcut item that pointsto a package that is not yet installed on the system.",
	"Method": "ShortcutInfo getRestoredItemInfo(Cursor c,int titleIndex,Intent intent,int promiseType,int itemType,CursorIconInfo iconInfo,Context context){\r\n    final ShortcutInfo info = new ShortcutInfo();\r\n    info.user = UserHandleCompat.myUserHandle();\r\n    Bitmap icon = iconInfo.loadIcon(c, info, context);\r\n    if (icon == null) {\r\n        mIconCache.getTitleAndIcon(info, intent, info.user, false);\r\n    } else {\r\n        info.setIcon(icon);\r\n    }\r\n    if ((promiseType & ShortcutInfo.FLAG_RESTORED_ICON) != 0) {\r\n        String title = (c != null) ? c.getString(titleIndex) : null;\r\n        if (!TextUtils.isEmpty(title)) {\r\n            info.title = Utilities.trim(title);\r\n        }\r\n    } else if ((promiseType & ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {\r\n        if (TextUtils.isEmpty(info.title)) {\r\n            info.title = (c != null) ? Utilities.trim(c.getString(titleIndex)) : \"\";\r\n        }\r\n    } else {\r\n        throw new InvalidParameterException(\"Invalid restoreType \" + promiseType);\r\n    }\r\n    info.contentDescription = mUserManager.getBadgedLabelForUser(info.title, info.user);\r\n    info.itemType = itemType;\r\n    info.promisedIntent = intent;\r\n    info.status = promiseType;\r\n    return info;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct6.projectD",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the fourth slot value.",
	"Method": "Maybe<D> projectD(){\r\n    return project()._4();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct6.projectA",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the first slot value.",
	"Method": "Maybe<A> projectA(){\r\n    return project()._1();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.product.Product4.rotateL4",
	"Comment": "rotate the first four values of this product one slot to the left.",
	"Method": "Product4<_2, _3, _4, _1> rotateL4(){\r\n    return into((_1, _2, _3, _4) -> product(_2, _3, _4, _1));\r\n}"
}, {
	"Path": "com.jdon.cache.UtilCache.getUseSoftReference",
	"Comment": "return whether or not the cache lines should use a soft reference to the",
	"Method": "boolean getUseSoftReference(){\r\n    return this.useSoftReference;\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.onClickWallpaperPicker",
	"Comment": "event handler for the wallpaper picker button that appears after a long presson the home screen.",
	"Method": "void onClickWallpaperPicker(View v){\r\n    if (LOGD)\r\n        Log.d(TAG, \"onClickWallpaperPicker\");\r\n    startActivityForResult(new Intent(Intent.ACTION_SET_WALLPAPER).setPackage(getPackageName()), REQUEST_PICK_WALLPAPER);\r\n    if (mLauncherCallbacks != null) {\r\n        mLauncherCallbacks.onClickWallpaperPicker(v);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jtstest.function.BufferByUnionFunctions.bufferBySegments",
	"Comment": "buffer polygons by buffering the individual boundary segments and\teither unioning or differencing them.",
	"Method": "Geometry bufferBySegments(Geometry g,double distance){\r\n    Geometry segs = LineHandlingFunctions.extractSegments(g);\r\n    double posDist = Math.abs(distance);\r\n    Geometry segBuf = bufferByComponents(segs, posDist);\r\n    if (distance < 0.0)\r\n        return g.difference(segBuf);\r\n    return g.union(segBuf);\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.CoordinateSequenceComparator.compare",
	"Comment": "compare two doubles, allowing for nan values.nan is treated as being less than any valid number.",
	"Method": "int compare(double a,double b,int compare,Object o1,Object o2){\r\n    CoordinateSequence s1 = (CoordinateSequence) o1;\r\n    CoordinateSequence s2 = (CoordinateSequence) o2;\r\n    int size1 = s1.size();\r\n    int size2 = s2.size();\r\n    int dim1 = s1.getDimension();\r\n    int dim2 = s2.getDimension();\r\n    int minDim = dim1;\r\n    if (dim2 < minDim)\r\n        minDim = dim2;\r\n    boolean dimLimited = false;\r\n    if (dimensionLimit <= minDim) {\r\n        minDim = dimensionLimit;\r\n        dimLimited = true;\r\n    }\r\n    if (!dimLimited) {\r\n        if (dim1 < dim2)\r\n            return -1;\r\n        if (dim1 > dim2)\r\n            return 1;\r\n    }\r\n    int i = 0;\r\n    while (i < size1 && i < size2) {\r\n        int ptComp = compareCoordinate(s1, s2, i, minDim);\r\n        if (ptComp != 0)\r\n            return ptComp;\r\n        i++;\r\n    }\r\n    if (i < size1)\r\n        return 1;\r\n    if (i < size2)\r\n        return -1;\r\n    return 0;\r\n}"
}, {
	"Path": "com.android.launcher3.PreloadIconDrawable.maybePerformFinishedAnimation",
	"Comment": "runs the finish animation if it is has not been run after last level change.",
	"Method": "void maybePerformFinishedAnimation(){\r\n    if (mAnimationProgress > ANIMATION_PROGRESS_STOPPED) {\r\n        return;\r\n    }\r\n    if (mAnimator != null) {\r\n        mAnimator.cancel();\r\n    }\r\n    setAnimationProgress(ANIMATION_PROGRESS_STARTED);\r\n    mAnimator = ObjectAnimator.ofFloat(this, \"animationProgress\", ANIMATION_PROGRESS_STARTED, ANIMATION_PROGRESS_COMPLETED);\r\n    mAnimator.start();\r\n}"
}, {
	"Path": "org.locationtech.jtstest.function.NodingFunctions.scaledNoding",
	"Comment": "runs a scalednoder on input.input vertices should be rounded to precision model.",
	"Method": "Geometry scaledNoding(Geometry geom,double scaleFactor){\r\n    List segs = createSegmentStrings(geom);\r\n    PrecisionModel fixedPM = new PrecisionModel(scaleFactor);\r\n    Noder noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());\r\n    noder.computeNodes(segs);\r\n    Collection nodedSegStrings = noder.getNodedSubstrings();\r\n    return SegmentStringUtil.toGeometry(nodedSegStrings, FunctionsUtil.getFactoryOrDefault(geom));\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherAppWidgetHost.onProviderChanged",
	"Comment": "called when the appwidget provider for a appwidget has been upgraded to a new apk.",
	"Method": "void onProviderChanged(int appWidgetId,AppWidgetProviderInfo appWidget){\r\n    LauncherAppWidgetProviderInfo info = LauncherAppWidgetProviderInfo.fromProviderInfo(mLauncher, appWidget);\r\n    super.onProviderChanged(appWidgetId, info);\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.Edge.addIntersections",
	"Comment": "adds edgeintersections for one or bothintersections found for a segment of an edge to the edge intersection list.",
	"Method": "void addIntersections(LineIntersector li,int segmentIndex,int geomIndex){\r\n    for (int i = 0; i < li.getIntersectionNum(); i++) {\r\n        addIntersection(li, segmentIndex, geomIndex, i);\r\n    }\r\n}"
}, {
	"Path": "com.jdon.bussinessproxy.remote.hessian.HessianToJdonRequestProcessor.getMethod",
	"Comment": "finds method of class by using mangled name from incoming request",
	"Method": "Method getMethod(Class clz,String mangledMethodName){\r\n    Map<String, Method> methods = methodsByComponentType.get(clz);\r\n    if (methods == null) {\r\n        methods = new HashMap<String, Method>();\r\n        methodsByComponentType.put(clz, methods);\r\n        for (Method method : clz.getDeclaredMethods()) {\r\n            Class<?>[] param = method.getParameterTypes();\r\n            String mangledName1 = method.getName() + \"__\" + param.length;\r\n            String mangledName2 = AbstractSkeleton.mangleName(method, false);\r\n            if (param.length == 0 || !methods.containsKey(method.getName())) {\r\n                methods.put(method.getName(), method);\r\n            }\r\n            methods.put(mangledName1, method);\r\n            methods.put(mangledName2, method);\r\n        }\r\n    }\r\n    return (Method) methods.get(mangledMethodName);\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.syntax.SQLToken.toString",
	"Comment": "get a representation of this token as a human readable string. the formatof this string is subject to change and should only be used for debuggingpurposes.",
	"Method": "String toString(){\r\n    return \"Token #\" + Integer.toHexString(this.id) + \": \" + this.getDescription() + \" Line \" + this.lineNumber + \" from \" + this.charBegin + \" to \" + this.charEnd + \" : \" + this.contents;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.relate.RelateNode.computeIM",
	"Comment": "update the im with the contribution for this component.a component only contributes if it has a labelling for both parent geometries",
	"Method": "void computeIM(IntersectionMatrix im){\r\n    im.setAtLeastIfValid(label.getLocation(0), label.getLocation(1), 0);\r\n}"
}, {
	"Path": "org.locationtech.jts.io.oracle.OraReader.setDimension",
	"Comment": "sets the coordinate dimension to use for created geometries.",
	"Method": "void setDimension(int outputDimension){\r\n    if (outputDimension < 2)\r\n        throw new IllegalArgumentException(\"Output dimension must be >= 2\");\r\n    this.outputDimension = outputDimension;\r\n}"
}, {
	"Path": "org.kse.gui.KeyStoreTableCellRend.getTableCellRendererComponent",
	"Comment": "returns the rendered cell for the supplied value and column.",
	"Method": "Component getTableCellRendererComponent(JTable jtKeyStore,Object value,boolean isSelected,boolean hasFocus,int row,int col){\r\n    JLabel cell = (JLabel) super.getTableCellRendererComponent(jtKeyStore, value, isSelected, hasFocus, row, col);\r\n    if (col == 0) {\r\n        ImageIcon icon = null;\r\n        if (KeyStoreTableModel.KEY_PAIR_ENTRY.equals(value)) {\r\n            icon = new ImageIcon(getClass().getResource(res.getString(\"KeyStoreTableCellRend.KeyPairEntry.image\")));\r\n            cell.setToolTipText(res.getString(\"KeyStoreTableCellRend.KeyPairEntry.tooltip\"));\r\n        } else if (KeyStoreTableModel.TRUST_CERT_ENTRY.equals(value)) {\r\n            icon = new ImageIcon(getClass().getResource(res.getString(\"KeyStoreTableCellRend.TrustCertEntry.image\")));\r\n            cell.setToolTipText(res.getString(\"KeyStoreTableCellRend.TrustCertEntry.tooltip\"));\r\n        } else {\r\n            icon = new ImageIcon(getClass().getResource(res.getString(\"KeyStoreTableCellRend.KeyEntry.image\")));\r\n            cell.setToolTipText(res.getString(\"KeyStoreTableCellRend.KeyEntry.tooltip\"));\r\n        }\r\n        cell.setIcon(icon);\r\n        cell.setText(\"\");\r\n        cell.setVerticalAlignment(CENTER);\r\n        cell.setHorizontalAlignment(CENTER);\r\n    } else if (col == 1) {\r\n        if (value == null) {\r\n            cell.setIcon(null);\r\n            cell.setText(\"-\");\r\n            cell.setToolTipText(res.getString(\"KeyStoreTableCellRend.NoLockStatus.tooltip\"));\r\n            cell.setHorizontalAlignment(CENTER);\r\n        } else {\r\n            ImageIcon icon = null;\r\n            if (value.equals(Boolean.TRUE)) {\r\n                icon = new ImageIcon(getClass().getResource(res.getString(\"KeyStoreTableCellRend.LockedEntry.image\")));\r\n                cell.setToolTipText(res.getString(\"KeyStoreTableCellRend.LockedEntry.tooltip\"));\r\n            } else {\r\n                icon = new ImageIcon(getClass().getResource(res.getString(\"KeyStoreTableCellRend.UnlockedEntry.image\")));\r\n                cell.setToolTipText(res.getString(\"KeyStoreTableCellRend.UnlockedEntry.tooltip\"));\r\n            }\r\n            cell.setIcon(icon);\r\n            cell.setText(\"\");\r\n            cell.setVerticalAlignment(CENTER);\r\n            cell.setHorizontalAlignment(CENTER);\r\n        }\r\n    } else if (col == 2) {\r\n        if (value == null) {\r\n            cell.setIcon(null);\r\n            cell.setText(\"-\");\r\n            cell.setToolTipText(res.getString(\"KeyStoreTableCellRend.NoCertExpiry.tooltip\"));\r\n            cell.setHorizontalAlignment(CENTER);\r\n        } else {\r\n            ImageIcon icon = null;\r\n            if (value.equals(2)) {\r\n                icon = new ImageIcon(getClass().getResource(res.getString(\"KeyStoreTableCellRend.CertExpiredEntry.image\")));\r\n                cell.setToolTipText(res.getString(\"KeyStoreTableCellRend.CertExpiredEntry.tooltip\"));\r\n            } else {\r\n                if (value.equals(1)) {\r\n                    icon = new ImageIcon(getClass().getResource(res.getString(\"KeyStoreTableCellRend.CertAlmostExpiredEntry.image\")));\r\n                    cell.setToolTipText(res.getString(\"KeyStoreTableCellRend.CertAlmostExpiredEntry.tooltip\"));\r\n                } else {\r\n                    icon = new ImageIcon(getClass().getResource(res.getString(\"KeyStoreTableCellRend.CertUnexpiredEntry.image\")));\r\n                    cell.setToolTipText(res.getString(\"KeyStoreTableCellRend.CertUnexpiredEntry.tooltip\"));\r\n                }\r\n            }\r\n            cell.setIcon(icon);\r\n            cell.setText(\"\");\r\n            cell.setVerticalAlignment(CENTER);\r\n            cell.setHorizontalAlignment(CENTER);\r\n        }\r\n    } else {\r\n        return writeCell(cell, value);\r\n    }\r\n    return cell;\r\n}"
}, {
	"Path": "com.jsql.view.swing.tree.PanelNode.hideIcon",
	"Comment": "mask the node icon for example when the loader component is displayed.",
	"Method": "void hideIcon(){\r\n    this.icon.setVisible(false);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.valid.IsValidOp.getValidationError",
	"Comment": "computes the validity of the geometry,and if not valid returns the validation error for the geometry,or null if the geometry is valid.",
	"Method": "TopologyValidationError getValidationError(){\r\n    checkValid(parentGeometry);\r\n    return validErr;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.union.CascadedPolygonUnion.getGeometry",
	"Comment": "gets the element at a given list index, ornull if the index is out of range.",
	"Method": "Geometry getGeometry(List list,int index){\r\n    if (index >= list.size())\r\n        return null;\r\n    return (Geometry) list.get(index);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.BufferOp.bufferOp",
	"Comment": "computes the buffer for a geometry for a given buffer distanceand accuracy of approximation.",
	"Method": "Geometry bufferOp(Geometry g,double distance,Geometry bufferOp,Geometry g,double distance,BufferParameters params,Geometry bufferOp,Geometry g,double distance,int quadrantSegments,Geometry bufferOp,Geometry g,double distance,int quadrantSegments,int endCapStyle){\r\n    BufferOp bufOp = new BufferOp(g);\r\n    bufOp.setQuadrantSegments(quadrantSegments);\r\n    bufOp.setEndCapStyle(endCapStyle);\r\n    Geometry geomBuf = bufOp.getResultGeometry(distance);\r\n    return geomBuf;\r\n}"
}, {
	"Path": "org.jpmml.evaluator.DistributionUtil.probability",
	"Comment": "calculates the value of the specified probability function at the specified point.",
	"Method": "double probability(ContinuousDistribution distribution,Number x,double probability,GaussianDistribution gaussianDistribution,Number x,double probability,PoissonDistribution poissonDistribution,Number x){\r\n    org.apache.commons.math3.distribution.PoissonDistribution distribution = new org.apache.commons.math3.distribution.PoissonDistribution(null, poissonDistribution.getMean(), org.apache.commons.math3.distribution.PoissonDistribution.DEFAULT_EPSILON, org.apache.commons.math3.distribution.PoissonDistribution.DEFAULT_MAX_ITERATIONS);\r\n    x = (Number) TypeUtil.cast(DataType.INTEGER, x);\r\n    return distribution.probability(x.intValue());\r\n}"
}, {
	"Path": "org.joda.money.BigMoney.isSameCurrency",
	"Comment": "checks if this instance and the specified instance have the same currency.",
	"Method": "boolean isSameCurrency(BigMoneyProvider money){\r\n    return (currency.equals(of(money).getCurrencyUnit()));\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.snapround.GeometryNoder.setValidate",
	"Comment": "sets whether noding validity is checked after noding is performed.",
	"Method": "void setValidate(boolean isValidityChecked){\r\n    this.isValidityChecked = isValidityChecked;\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.importexport.DImportKeyPairPkcs12.getPrivateKey",
	"Comment": "get the private part of the key pair chosen by the user for import.",
	"Method": "PrivateKey getPrivateKey(PrivateKey getPrivateKey){\r\n    return privateKey;\r\n}"
}, {
	"Path": "org.locationtech.jts.io.kml.KMLWriter.setLinePrefix",
	"Comment": "sets a tag string which is prefixed to every emitted text line.this can be used to indent the geometry text in a containing document.",
	"Method": "void setLinePrefix(String linePrefix){\r\n    this.linePrefix = linePrefix;\r\n}"
}, {
	"Path": "org.locationtech.jts.planargraph.Edge.isRemoved",
	"Comment": "tests whether this edge has been removed from its containing graph",
	"Method": "boolean isRemoved(){\r\n    return dirEdge == null;\r\n}"
}, {
	"Path": "com.jsql.view.i18n.I18nView.componentsByKey",
	"Comment": "get a list of graphical components whose text correspondsto the i18n key in the properties.",
	"Method": "List<Object> componentsByKey(String key){\r\n    return I18nView.componentsLocalized.get(key);\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testrunner.TestReader.getInstance",
	"Comment": "gets an instance of a class with the given name, and ensures that the class is assignable to a specified baseclass.",
	"Method": "Object getInstance(String classname,Class baseClass){\r\n    Object o = null;\r\n    try {\r\n        Class goClass = Class.forName(classname);\r\n        if (!(baseClass.isAssignableFrom(goClass)))\r\n            return null;\r\n        o = goClass.newInstance();\r\n    } catch (Exception ex) {\r\n        return null;\r\n    }\r\n    return o;\r\n}"
}, {
	"Path": "com.jdon.controller.WebAppUtil.getComponentInstance",
	"Comment": "get a component that registered in container. the component is not\tdifferent from the service. the component instance is single instance any\tintercepter will be disable",
	"Method": "Object getComponentInstance(String name,HttpServletRequest request,Object getComponentInstance,String name,ServletContext sc){\r\n    ContainerWrapper containerWrapper = scf.findContainer(new ServletContextWrapper(sc));\r\n    if (!containerWrapper.isStart()) {\r\n        Debug.logError(\"JdonFramework not yet started, please try later \", module);\r\n        return null;\r\n    }\r\n    return containerWrapper.lookup(name);\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.impl.CoordinateSequenceTestBase.isEqual",
	"Comment": "tests for equality using all supported accessors,to provides test coverage for them.",
	"Method": "boolean isEqual(CoordinateSequence seq,Coordinate[] coords,boolean isEqual,double expected,double actual){\r\n    return expected == actual || (Double.isNaN(expected) && Double.isNaN(actual));\r\n}"
}, {
	"Path": "org.joda.money.BigMoney.withCurrencyUnit",
	"Comment": "returns a copy of this monetary value with the specified currency.the returned instance will have the specified currency and the amountfrom this instance. no currency conversion or alteration to the scale occurs.this instance is immutable and unaffected by this method.",
	"Method": "BigMoney withCurrencyUnit(CurrencyUnit currency){\r\n    MoneyUtils.checkNotNull(currency, \"CurrencyUnit must not be null\");\r\n    if (this.currency == currency) {\r\n        return this;\r\n    }\r\n    return new BigMoney(currency, amount);\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifInterface.getUserComment",
	"Comment": "decodes the user comment tag into string as specified in the exifstandard. returns null if decoding failed.",
	"Method": "String getUserComment(){\r\n    return mData.getUserComment();\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.utils.tuple.ImmutablePair.of",
	"Comment": "obtains an immutable pair of from two objects inferring the generic types.this factory allows the pair to be created using inference toobtain the generic types.",
	"Method": "ImmutablePair<L, R> of(L left,R right){\r\n    return new ImmutablePair(left, right);\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.index.SimpleSweepLineIntersector.prepareEvents",
	"Comment": "because delete events have a link to their corresponding insert event,it is possible to compute exactly the range of events which must becompared to a given insert event object.",
	"Method": "void prepareEvents(){\r\n    Collections.sort(events);\r\n    for (int i = 0; i < events.size(); i++) {\r\n        SweepLineEvent ev = (SweepLineEvent) events.get(i);\r\n        if (ev.isDelete()) {\r\n            ev.getInsertEvent().setDeleteEventIndex(i);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.requests.restaction.order.OrderAction.getCurrentOrder",
	"Comment": "immutable list representing the currently selected orderof entities in this orderaction instance",
	"Method": "List<T> getCurrentOrder(){\r\n    return Collections.unmodifiableList(orderList);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.OffsetSegmentGenerator.addLimitedMitreJoin",
	"Comment": "adds a limited mitre join connecting the two reflex offset segments.a limited mitre is a mitre which is beveled at the distancedetermined by the mitre ratio limit.",
	"Method": "void addLimitedMitreJoin(LineSegment offset0,LineSegment offset1,double distance,double mitreLimit){\r\n    Coordinate basePt = seg0.p1;\r\n    double ang0 = Angle.angle(basePt, seg0.p0);\r\n    double angDiff = Angle.angleBetweenOriented(seg0.p0, basePt, seg1.p1);\r\n    double angDiffHalf = angDiff / 2;\r\n    double midAng = Angle.normalize(ang0 + angDiffHalf);\r\n    double mitreMidAng = Angle.normalize(midAng + Math.PI);\r\n    double mitreDist = mitreLimit * distance;\r\n    double bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));\r\n    double bevelHalfLen = distance - bevelDelta;\r\n    double bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);\r\n    double bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);\r\n    Coordinate bevelMidPt = new Coordinate(bevelMidX, bevelMidY);\r\n    LineSegment mitreMidLine = new LineSegment(basePt, bevelMidPt);\r\n    Coordinate bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);\r\n    Coordinate bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);\r\n    if (side == Position.LEFT) {\r\n        segList.addPt(bevelEndLeft);\r\n        segList.addPt(bevelEndRight);\r\n    } else {\r\n        segList.addPt(bevelEndRight);\r\n        segList.addPt(bevelEndLeft);\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.getCurrentWorkspaceScreen",
	"Comment": "implementation of the method from launchermodel.callbacks.",
	"Method": "int getCurrentWorkspaceScreen(){\r\n    if (mWorkspace != null) {\r\n        return mWorkspace.getCurrentPage();\r\n    } else {\r\n        return SCREEN_COUNT / 2;\r\n    }\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.stripCharsInBag",
	"Comment": "removes all characters which appear in string bag from string s.",
	"Method": "String stripCharsInBag(String s,String bag){\r\n    int i;\r\n    String returnString = \"\";\r\n    for (i = 0; i < s.length(); i++) {\r\n        char c = s.charAt(i);\r\n        if (bag.indexOf(c) == -1)\r\n            returnString += c;\r\n    }\r\n    return returnString;\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.syntax.SQLToken.isIdentifier",
	"Comment": "checks this token to see if it is an identifier. identifiers areexplained in javalanguage specification.",
	"Method": "boolean isIdentifier(){\r\n    return (this.id >> 8) == 0x2;\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.dsl.base.HasMetadataOperation.periodicWatchUntilReady",
	"Comment": "a wait method that combines watching and polling.the need for that is that in some cases a pure watcher approach consistently fails.",
	"Method": "T periodicWatchUntilReady(int i,long started,long interval,long amount){\r\n    T item = fromServer().get();\r\n    if (Readiness.isReady(item)) {\r\n        return item;\r\n    }\r\n    ReadinessWatcher<T> watcher = new ReadinessWatcher(item);\r\n    try (Watch watch = watch(item.getMetadata().getResourceVersion(), watcher)) {\r\n        try {\r\n            return watcher.await(interval, TimeUnit.MILLISECONDS);\r\n        } catch (KubernetesClientTimeoutException e) {\r\n            if (i <= 0) {\r\n                throw e;\r\n            }\r\n        }\r\n        long remaining = (started + amount) - System.currentTimeMillis();\r\n        long next = Math.max(0, Math.min(remaining, interval));\r\n        return periodicWatchUntilReady(i - 1, started, next, amount);\r\n    }\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.functions.Fn2.apply",
	"Comment": "partially apply this function by passing its first argument.",
	"Method": "C apply(A a,B b,Fn1<B, C> apply,A a){\r\n    return (b) -> apply(a, b);\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.updateWorkspaceScreenOrder",
	"Comment": "update the order of the workspace screens in the database. the array list containsa list of screen ids in the order that they should appear.",
	"Method": "void updateWorkspaceScreenOrder(Context context,ArrayList<Long> screens){\r\n    final ArrayList<Long> screensCopy = new ArrayList<Long>(screens);\r\n    final ContentResolver cr = context.getContentResolver();\r\n    final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;\r\n    Iterator<Long> iter = screensCopy.iterator();\r\n    while (iter.hasNext()) {\r\n        long id = iter.next();\r\n        if (id < 0) {\r\n            iter.remove();\r\n        }\r\n    }\r\n    Runnable r = new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            ArrayList<ContentProviderOperation> ops = new ArrayList<ContentProviderOperation>();\r\n            ops.add(ContentProviderOperation.newDelete(uri).build());\r\n            int count = screensCopy.size();\r\n            for (int i = 0; i < count; i++) {\r\n                ContentValues v = new ContentValues();\r\n                long screenId = screensCopy.get(i);\r\n                v.put(LauncherSettings.WorkspaceScreens._ID, screenId);\r\n                v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);\r\n                ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());\r\n            }\r\n            try {\r\n                cr.applyBatch(LauncherProvider.AUTHORITY, ops);\r\n            } catch (Exception ex) {\r\n                throw new RuntimeException(ex);\r\n            }\r\n            synchronized (sBgLock) {\r\n                sBgWorkspaceScreens.clear();\r\n                sBgWorkspaceScreens.addAll(screensCopy);\r\n            }\r\n        }\r\n    };\r\n    runOnWorkerThread(r);\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.updateWorkspaceScreenOrder",
	"Comment": "update the order of the workspace screens in the database. the array list containsa list of screen ids in the order that they should appear.",
	"Method": "void updateWorkspaceScreenOrder(Context context,ArrayList<Long> screens){\r\n    ArrayList<ContentProviderOperation> ops = new ArrayList<ContentProviderOperation>();\r\n    ops.add(ContentProviderOperation.newDelete(uri).build());\r\n    int count = screensCopy.size();\r\n    for (int i = 0; i < count; i++) {\r\n        ContentValues v = new ContentValues();\r\n        long screenId = screensCopy.get(i);\r\n        v.put(LauncherSettings.WorkspaceScreens._ID, screenId);\r\n        v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);\r\n        ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());\r\n    }\r\n    try {\r\n        cr.applyBatch(LauncherProvider.AUTHORITY, ops);\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n    synchronized (sBgLock) {\r\n        sBgWorkspaceScreens.clear();\r\n        sBgWorkspaceScreens.addAll(screensCopy);\r\n    }\r\n}"
}, {
	"Path": "com.jsql.util.ConnectionUtil.fixJcifsTimeout",
	"Comment": "fix a bug introduced by authentication library jcifs which ignoredefault timeout of connection.use reflectivity to set connecttimeout and readtimeout attributs.",
	"Method": "void fixJcifsTimeout(HttpURLConnection connection){\r\n    Class<?> classConnection = connection.getClass();\r\n    boolean connectionIsWrapped = true;\r\n    Field privateFieldURLConnection = null;\r\n    try {\r\n        privateFieldURLConnection = classConnection.getDeclaredField(\"connection\");\r\n    } catch (Exception e) {\r\n        connectionIsWrapped = false;\r\n        IgnoreMessageException exceptionIgnored = new IgnoreMessageException(e);\r\n        LOGGER.trace(exceptionIgnored, exceptionIgnored);\r\n    }\r\n    if (connectionIsWrapped) {\r\n        try {\r\n            privateFieldURLConnection.setAccessible(true);\r\n            URLConnection privateURLConnection = (URLConnection) privateFieldURLConnection.get(connection);\r\n            Class<?> classURLConnectionPrivate = privateURLConnection.getClass();\r\n            final Class<?> parentClass = classURLConnectionPrivate.getSuperclass();\r\n            if (parentClass == HttpsURLConnection.class) {\r\n                return;\r\n            }\r\n            Field privateFieldConnectTimeout = classURLConnectionPrivate.getDeclaredField(\"connectTimeout\");\r\n            privateFieldConnectTimeout.setAccessible(true);\r\n            privateFieldConnectTimeout.setInt(privateURLConnection, ConnectionUtil.getTimeout());\r\n            Field privateFieldReadTimeout = classURLConnectionPrivate.getDeclaredField(\"readTimeout\");\r\n            privateFieldReadTimeout.setAccessible(true);\r\n            privateFieldReadTimeout.setInt(privateURLConnection, ConnectionUtil.getTimeout());\r\n        } catch (Exception e) {\r\n            LOGGER.warn(\"Fix jcifs timeout failed: \" + e.getMessage(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.NodingIntersectionFinder.createIntersectionCounter",
	"Comment": "creates an intersection finder which counts all interior intersections.\tthe intersections are note recorded to reduce memory usage.",
	"Method": "NodingIntersectionFinder createIntersectionCounter(LineIntersector li){\r\n    NodingIntersectionFinder finder = new NodingIntersectionFinder(li);\r\n    finder.setFindAllIntersections(true);\r\n    finder.setKeepIntersections(false);\r\n    return finder;\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifInterface.defineTag",
	"Comment": "returns the constant representing a tag with a given tid and default ifd.",
	"Method": "int defineTag(int ifdId,short tagId){\r\n    return (tagId & 0x0000ffff) | (ifdId << 16);\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.CoordinateArrays.toCoordinateArray",
	"Comment": "converts the given collection of coordinates into a coordinate array.",
	"Method": "Coordinate[] toCoordinateArray(Collection coordList){\r\n    return (Coordinate[]) coordList.toArray(coordArrayType);\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.patch.DiffMatchPatch.diffMain",
	"Comment": "find the differences between two texts.simplifies the problem bystripping any common prefix or suffix off the texts before diffing.",
	"Method": "List<Diff> diffMain(String text1,String text2,LinkedList<Diff> diffMain,String text1,String text2,boolean checklines,LinkedList<Diff> diffMain,String valueText1,String valueText2,boolean checklines,long deadline){\r\n    String text1 = valueText1;\r\n    String text2 = valueText2;\r\n    if (text1 == null || text2 == null) {\r\n        throw new IllegalArgumentException(\"Null inputs. (diff_main)\");\r\n    }\r\n    LinkedList<Diff> diffs;\r\n    if (text1.equals(text2)) {\r\n        diffs = new LinkedList();\r\n        if (text1.length() != 0) {\r\n            diffs.add(new Diff(Operation.EQUAL, text1));\r\n        }\r\n        return diffs;\r\n    }\r\n    int commonlength = this.diffCommonPrefix(text1, text2);\r\n    String commonprefix = text1.substring(0, commonlength);\r\n    text1 = text1.substring(commonlength);\r\n    text2 = text2.substring(commonlength);\r\n    commonlength = this.diffCommonSuffix(text1, text2);\r\n    String commonsuffix = text1.substring(text1.length() - commonlength);\r\n    text1 = text1.substring(0, text1.length() - commonlength);\r\n    text2 = text2.substring(0, text2.length() - commonlength);\r\n    diffs = this.diffCompute(text1, text2, checklines, deadline);\r\n    if (commonprefix.length() != 0) {\r\n        diffs.addFirst(new Diff(Operation.EQUAL, commonprefix));\r\n    }\r\n    if (commonsuffix.length() != 0) {\r\n        diffs.addLast(new Diff(Operation.EQUAL, commonsuffix));\r\n    }\r\n    this.diffCleanupMerge(diffs);\r\n    return diffs;\r\n}"
}, {
	"Path": "org.kse.gui.actions.CloseAction.closeKeyStore",
	"Comment": "close the supplied keystore. allow the user to save it if there are\tunsaved changes.",
	"Method": "boolean closeKeyStore(KeyStoreHistory history){\r\n    KeyStoreState currentState = history.getCurrentState();\r\n    if (needSave(currentState)) {\r\n        kseFrame.focusOnKeyStore(currentState.getKeyStore());\r\n        int wantSave = wantSave(history);\r\n        if (wantSave == JOptionPane.YES_OPTION) {\r\n            boolean saved = saveKeyStore(history);\r\n            if (!saved) {\r\n                return false;\r\n            }\r\n            currentState = history.getCurrentState();\r\n        } else if ((wantSave == JOptionPane.CANCEL_OPTION) || (wantSave == JOptionPane.CLOSED_OPTION)) {\r\n            return false;\r\n        }\r\n    }\r\n    kseFrame.removeKeyStore(currentState.getKeyStore());\r\n    kseFrame.updateControls(true);\r\n    return true;\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.NodedSegmentString.addIntersectionNode",
	"Comment": "adds an intersection node for a given point and segment to this segment string.if an intersection already exists for this exact location, the existingnode will be returned.",
	"Method": "SegmentNode addIntersectionNode(Coordinate intPt,int segmentIndex){\r\n    int normalizedSegmentIndex = segmentIndex;\r\n    int nextSegIndex = normalizedSegmentIndex + 1;\r\n    if (nextSegIndex < pts.length) {\r\n        Coordinate nextPt = pts[nextSegIndex];\r\n        if (intPt.equals2D(nextPt)) {\r\n            normalizedSegmentIndex = nextSegIndex;\r\n        }\r\n    }\r\n    SegmentNode ei = nodeList.add(intPt, normalizedSegmentIndex);\r\n    return ei;\r\n}"
}, {
	"Path": "org.locationtech.jts.planargraph.NodeMap.find",
	"Comment": "returns the node at the given location, or null if no node was there.",
	"Method": "Node find(Coordinate coord){\r\n    return (Node) nodeMap.get(coord);\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.bindAllApplications",
	"Comment": "add the icons for all apps.implementation of the method from launchermodel.callbacks.",
	"Method": "void bindAllApplications(ArrayList<AppInfo> apps){\r\n    if (waitUntilResume(mBindAllApplicationsRunnable, true)) {\r\n        mTmpAppsList = apps;\r\n        return;\r\n    }\r\n    if (mAppsView != null) {\r\n        mAppsView.setApps(apps);\r\n    }\r\n    if (mLauncherCallbacks != null) {\r\n        mLauncherCallbacks.bindAllApplications(apps);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.index.strtree.AbstractSTRtree.isEmpty",
	"Comment": "tests whether the index contains any items.this method does not build the index,so items can still be inserted after it has been called.",
	"Method": "boolean isEmpty(){\r\n    if (!built)\r\n        return itemBoundables.isEmpty();\r\n    return root.isEmpty();\r\n}"
}, {
	"Path": "com.jdon.controller.model.PageIterator.hasPrevious",
	"Comment": "returns true if there are previous elements in the iteration.",
	"Method": "boolean hasPrevious(){\r\n    if (currentIndex == startIndex) {\r\n        return false;\r\n    }\r\n    if (previousElement == null) {\r\n        previousElement = getPreviousElement();\r\n        if (previousElement == null) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.jdon.model.query.JdbcUtil.extract",
	"Comment": "return a list in the list, every object is a map, by database column\tname, we can get the its result from map",
	"Method": "List extract(ResultSet rs){\r\n    ResultSetMetaData meta = rs.getMetaData();\r\n    int count = meta.getColumnCount();\r\n    List ret = new ArrayList();\r\n    while (rs.next()) {\r\n        Map map = new LinkedHashMap(count);\r\n        for (int i = 1; i <= count; i++) {\r\n            map.put(meta.getColumnName(i), rs.getObject(i));\r\n        }\r\n        ret.add(map);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.jdon.util.UtilDateTime.toTimestamp",
	"Comment": "makes a timestamp from separate ints for month, day, year, hour, minute,\tand second.",
	"Method": "java.sql.Timestamp toTimestamp(String dateTime,java.sql.Timestamp toTimestamp,String date,String time,java.sql.Timestamp toTimestamp,String monthStr,String dayStr,String yearStr,String hourStr,String minuteStr,String secondStr,java.sql.Timestamp toTimestamp,int month,int day,int year,int hour,int minute,int second){\r\n    java.util.Date newDate = toDate(month, day, year, hour, minute, second);\r\n    if (newDate != null)\r\n        return new java.sql.Timestamp(newDate.getTime());\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "org.joda.money.CurrencyUnit.equals",
	"Comment": "checks if this currency equals another currency.the comparison checks the 3 letter currency code.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == this) {\r\n        return true;\r\n    }\r\n    if (obj instanceof CurrencyUnit) {\r\n        return code.equals(((CurrencyUnit) obj).code);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.PolygonizeDirectedEdge.setRing",
	"Comment": "sets the ring of directed edges that this directed edge isa member of.",
	"Method": "void setRing(EdgeRing edgeRing){\r\n    this.edgeRing = edgeRing;\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testbuilder.BusyDialog.setDescription",
	"Comment": "sets the string displayed in the busydialog. can be safely calledby the awt event dispatching thread and threads other than theawt event dispatching thread.",
	"Method": "void setDescription(String description){\r\n    this.description = description;\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.NodingIntersectionFinder.createAllIntersectionsFinder",
	"Comment": "creates an intersection finder which finds all interior intersections.\tthe intersections are recorded for later inspection.",
	"Method": "NodingIntersectionFinder createAllIntersectionsFinder(LineIntersector li){\r\n    NodingIntersectionFinder finder = new NodingIntersectionFinder(li);\r\n    finder.setFindAllIntersections(true);\r\n    return finder;\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testbuilder.ui.tools.IndicatorTool.getShape",
	"Comment": "gets the shape for displaying the current state of the action.subclasses should override.",
	"Method": "Shape getShape(){\r\n    return null;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdge.sym",
	"Comment": "gets the edge from the destination to the origin of this edge.",
	"Method": "QuadEdge sym(){\r\n    return rot.rot;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.entities.MessageHistory.isEmpty",
	"Comment": "whether this messagehistory instance has retrieved any messages.",
	"Method": "boolean isEmpty(){\r\n    return size() == 0;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.OffsetCurveBuilder.simplifyTolerance",
	"Comment": "computes the distance tolerance to use during inputline simplification.",
	"Method": "double simplifyTolerance(double bufDistance){\r\n    return bufDistance * bufParams.getSimplifyFactor();\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.getCellLayoutChildId",
	"Comment": "creates a new unique child id, for a given cell span across all layouts.",
	"Method": "int getCellLayoutChildId(long container,long screen,int localCellX,int localCellY,int spanX,int spanY){\r\n    return (((int) container & 0xFF) << 24) | ((int) screen & 0xFF) << 16 | (localCellX & 0xFF) << 8 | (localCellY & 0xFF);\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.util.AffineTransformationFactory.createFromControlVectors",
	"Comment": "creates an affinetransformation defined by a set of control vectors.\tbetween one and three vectors must be supplied.",
	"Method": "AffineTransformation createFromControlVectors(Coordinate src0,Coordinate src1,Coordinate src2,Coordinate dest0,Coordinate dest1,Coordinate dest2,AffineTransformation createFromControlVectors,Coordinate src0,Coordinate src1,Coordinate dest0,Coordinate dest1,AffineTransformation createFromControlVectors,Coordinate src0,Coordinate dest0,AffineTransformation createFromControlVectors,Coordinate[] src,Coordinate[] dest){\r\n    if (src.length != dest.length)\r\n        throw new IllegalArgumentException(\"Src and Dest arrays are not the same length\");\r\n    if (src.length <= 0)\r\n        throw new IllegalArgumentException(\"Too few control points\");\r\n    if (src.length > 3)\r\n        throw new IllegalArgumentException(\"Too many control points\");\r\n    if (src.length == 1)\r\n        return createFromControlVectors(src[0], dest[0]);\r\n    if (src.length == 2)\r\n        return createFromControlVectors(src[0], src[1], dest[0], dest[1]);\r\n    return createFromControlVectors(src[0], src[1], src[2], dest[0], dest[1], dest[2]);\r\n}"
}, {
	"Path": "org.locationtech.jts.io.oracle.OraReader.extractCoords",
	"Comment": "constructs a coordinate sequence from the ordinatesfor a given elementtaking into account the input and output dimensions.the number of ordinates read per coordinate is given by outputdim.the number of ordinates for each input point is given by orddim.the ordinate array length must be a multiple of this value.",
	"Method": "CoordinateSequence extractCoords(OraGeom oraGeom,int elemIndex,CoordinateSequence extractCoords,OraGeom oraGeom,double[] ordinates,CoordinateSequence extractCoords,OraGeom oraGeom,double[] ordinates,int start,int end){\r\n    CoordinateSequenceFactory csFactory = geometryFactory.getCoordinateSequenceFactory();\r\n    if ((ordinates == null) || (ordinates.length == 0)) {\r\n        return csFactory.create(new Coordinate[0]);\r\n    }\r\n    int ordDim = oraGeom.ordDim();\r\n    int csDim = ordDim;\r\n    if (outputDimension != OraGeom.NULL_DIMENSION) {\r\n        csDim = outputDimension;\r\n    }\r\n    int nCoord = (ordDim == 0 ? 0 : (end - start) / ordDim);\r\n    CoordinateSequence cs = csFactory.create(nCoord, csDim);\r\n    int actualCSDim = cs.getDimension();\r\n    int readDim = Math.min(actualCSDim, ordDim);\r\n    for (int iCoord = 0; iCoord < nCoord; iCoord++) {\r\n        for (int iDim = 0; iDim < readDim; iDim++) {\r\n            int ordIndex = start + iCoord * ordDim + iDim - 1;\r\n            cs.setOrdinate(iCoord, iDim, ordinates[ordIndex]);\r\n        }\r\n    }\r\n    return cs;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.union.UnaryUnionOp.unionWithNull",
	"Comment": "computes the union of two geometries, either of both of which may be null.",
	"Method": "Geometry unionWithNull(Geometry g0,Geometry g1){\r\n    if (g0 == null && g1 == null)\r\n        return null;\r\n    if (g1 == null)\r\n        return g0;\r\n    if (g0 == null)\r\n        return g1;\r\n    return g0.union(g1);\r\n}"
}, {
	"Path": "com.android.launcher3.CellLayout.setInvertIfRtl",
	"Comment": "set whether or not to invert the layout horizontally if the layout is in rtl mode.",
	"Method": "void setInvertIfRtl(boolean invert){\r\n    mShortcutsAndWidgets.setInvertIfRtl(invert);\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.ConformingDelaunayTriangulator.getTolerance",
	"Comment": "gets the tolerance value used to construct the triangulation.",
	"Method": "double getTolerance(){\r\n    return tolerance;\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testbuilder.GeometryTreeModel.valueForPathChanged",
	"Comment": "messaged when the user has altered the value for the item identified bypath to newvalue. not used by this model.",
	"Method": "void valueForPathChanged(TreePath path,Object newValue){\r\n    System.out.println(\"*** valueForPathChanged : \" + path + \" --> \" + newValue);\r\n}"
}, {
	"Path": "org.locationtech.jts.precision.CommonBitsOp.computeResultPrecision",
	"Comment": "if required, returning the result to the original precision if required.in this current implementation, no rounding is performed on thereshifted result geometry, which means that it is possiblethat the returned geometry is invalid.",
	"Method": "Geometry computeResultPrecision(Geometry result){\r\n    if (returnToOriginalPrecision)\r\n        cbr.addCommonBits(result);\r\n    return result;\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.syntax.SQLToken.isError",
	"Comment": "checks this token to see if it is an error. unfinished comments, numbersthat are too big, unclosed strings, etc.",
	"Method": "boolean isError(){\r\n    return (this.id >> 8) == 0xF;\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifData.addIfdData",
	"Comment": "adds ifd data. if ifd data of the same type already exists, it will bereplaced by the new data.",
	"Method": "void addIfdData(IfdData data){\r\n    mIfdDatas[data.getId()] = data;\r\n}"
}, {
	"Path": "org.locationtech.jts.io.WKBReader.readCoordinate",
	"Comment": "reads a coordinate value with the specified dimensionality.makes the x and y ordinates precise according to the precision modelin use.",
	"Method": "void readCoordinate(){\r\n    for (int i = 0; i < inputDimension; i++) {\r\n        if (i <= 1) {\r\n            ordValues[i] = precisionModel.makePrecise(dis.readDouble());\r\n        } else {\r\n            ordValues[i] = dis.readDouble();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.overlay.PolygonBuilder.buildMaximalEdgeRings",
	"Comment": "for all directededges in result, form them into maximaledgerings",
	"Method": "List buildMaximalEdgeRings(Collection dirEdges){\r\n    List maxEdgeRings = new ArrayList();\r\n    for (Iterator it = dirEdges.iterator(); it.hasNext(); ) {\r\n        DirectedEdge de = (DirectedEdge) it.next();\r\n        if (de.isInResult() && de.getLabel().isArea()) {\r\n            if (de.getEdgeRing() == null) {\r\n                MaximalEdgeRing er = new MaximalEdgeRing(de, geometryFactory);\r\n                maxEdgeRings.add(er);\r\n                er.setInResult();\r\n            }\r\n        }\r\n    }\r\n    return maxEdgeRings;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.functions.Fn7.apply",
	"Comment": "partially apply this function by taking its first six arguments.",
	"Method": "H apply(A a,B b,C c,D d,E e,F f,G g,Fn6<B, C, D, E, F, G, H> apply,A a,Fn5<C, D, E, F, G, H> apply,A a,B b,Fn4<D, E, F, G, H> apply,A a,B b,C c,Fn3<E, F, G, H> apply,A a,B b,C c,D d,Fn2<F, G, H> apply,A a,B b,C c,D d,E e,Fn1<G, H> apply,A a,B b,C c,D d,E e,F f){\r\n    return (g) -> apply(a, b, c, d, e, f, g);\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.MessageBuilder.replaceLast",
	"Comment": "replaces the last substring that matches the target string with the specified replacement string.",
	"Method": "MessageBuilder replaceLast(String target,String replacement){\r\n    int index = builder.lastIndexOf(target);\r\n    if (index != -1) {\r\n        builder.replace(index, index + target.length(), replacement);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.jsql.view.swing.bruteforce.DigestMD4.engineReset",
	"Comment": "resets this object disregarding any temporary data present at thetime of the invocation of this call.",
	"Method": "void engineReset(){\r\n    this.context[0] = 0x67452301;\r\n    this.context[1] = 0xEFCDAB89;\r\n    this.context[2] = 0x98BADCFE;\r\n    this.context[3] = 0x10325476;\r\n    this.count = 0L;\r\n    for (int i = 0; i < BLOCK_LENGTH; i++) {\r\n        this.buffer[i] = 0;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.validate.BufferDistanceValidator.checkMaximumDistance",
	"Comment": "checks that the furthest distance from the buffer curve to the inputis less than the given maximum distance.this uses the oriented hausdorff distance metric.it corresponds to findingthe point on the buffer curve which is furthest from some point on the input.",
	"Method": "void checkMaximumDistance(Geometry input,Geometry bufCurve,double maxDist){\r\n    DiscreteHausdorffDistance haus = new DiscreteHausdorffDistance(bufCurve, input);\r\n    haus.setDensifyFraction(0.25);\r\n    maxDistanceFound = haus.orientedDistance();\r\n    if (maxDistanceFound > maxDist) {\r\n        isValid = false;\r\n        Coordinate[] pts = haus.getCoordinates();\r\n        errorLocation = pts[1];\r\n        errorIndicator = input.getFactory().createLineString(pts);\r\n        errMsg = \"Distance between buffer curve and input is too large \" + \"(\" + maxDistanceFound + \" at \" + WKTWriter.toLineString(pts[0], pts[1]) + \")\";\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.SegmentIntersectionDetector.setFindProper",
	"Comment": "sets whether processing must continue until a proper intersection is found.",
	"Method": "void setFindProper(boolean findProper){\r\n    this.findProper = findProper;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.EdgeRing.isOuterHole",
	"Comment": "tests whether this ring is an outer hole.a hole is an outer hole if it is not contained by a shell.",
	"Method": "boolean isOuterHole(){\r\n    if (!isHole)\r\n        return false;\r\n    return !hasShell();\r\n}"
}, {
	"Path": "cn.jpush.api.push.model.PushPayload.alertAll",
	"Comment": "the shortcut of building a simple alert notification object to all platforms and all audiences",
	"Method": "PushPayload alertAll(String alert,PushPayload alertAll,String alert,SMS sms){\r\n    return new Builder().setPlatform(Platform.all()).setAudience(Audience.all()).setNotification(Notification.alert(alert)).setSMS(sms).build();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.product.Product7.rotateL7",
	"Comment": "rotate the first seven values of this product one slot to the left.",
	"Method": "Product7<_2, _3, _4, _5, _6, _7, _1> rotateL7(){\r\n    return into((_1, _2, _3, _4, _5, _6, _7) -> product(_2, _3, _4, _5, _6, _7, _1));\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.hlist.Tuple3.fill",
	"Comment": "given a value of type a, produced an instance of this tuple with each slot set to that value.",
	"Method": "Tuple3<A, A, A> fill(A a){\r\n    return tuple(a, a, a);\r\n}"
}, {
	"Path": "org.kse.gui.actions.SaveAction.saveKeyStore",
	"Comment": "save the supplied keystore back to the file it was originally opened\tfrom.",
	"Method": "boolean saveKeyStore(KeyStoreHistory history){\r\n    File saveFile = null;\r\n    try {\r\n        KeyStoreState currentState = history.getCurrentState();\r\n        kseFrame.focusOnKeyStore(currentState.getKeyStore());\r\n        saveFile = history.getFile();\r\n        if (saveFile == null) {\r\n            return saveKeyStoreAs(history);\r\n        }\r\n        Password password = currentState.getPassword();\r\n        if (password == null) {\r\n            SetPasswordAction setPasswordAction = new SetPasswordAction(kseFrame);\r\n            if (setPasswordAction.setKeyStorePassword()) {\r\n                currentState = history.getCurrentState();\r\n                password = currentState.getPassword();\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n        KeyStoreUtil.save(currentState.getKeyStore(), saveFile, password);\r\n        currentState.setPassword(password);\r\n        currentState.setAsSavedState();\r\n        kseFrame.updateControls(false);\r\n        return true;\r\n    } catch (FileNotFoundException ex) {\r\n        JOptionPane.showMessageDialog(frame, MessageFormat.format(res.getString(\"SaveAction.NoWriteFile.message\"), saveFile), res.getString(\"SaveAction.SaveKeyStore.Title\"), JOptionPane.WARNING_MESSAGE);\r\n        return false;\r\n    } catch (Exception ex) {\r\n        DError.displayError(frame, ex);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.jdon.controller.service.WebServiceImp.execute",
	"Comment": "running the service, and return the result without session",
	"Method": "Object execute(String name,MethodMetaArgs methodMetaArgs,RequestWrapper request,Object execute,TargetMetaDef targetMetaDef,MethodMetaArgs methodMetaArgs,RequestWrapper request,Object execute,String name,MethodMetaArgs methodMetaArgs,AppContextWrapper acw,Object execute,TargetMetaDef targetMetaDef,MethodMetaArgs methodMetaArgs,AppContextWrapper acw){\r\n    Debug.logVerbose(\"[JdonFramework]enter service execution core \", module);\r\n    userTargetMetaDefFactory.createTargetMetaRequest(targetMetaDef, acw);\r\n    TargetMetaRequest targetMetaRequest = userTargetMetaDefFactory.targetMetaRequestsHolder.getTargetMetaRequest();\r\n    targetMetaRequest.setMethodMetaArgs(methodMetaArgs);\r\n    return webServiceAccessor.execute();\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.syntax.SQLLexer.getNextToken",
	"Comment": "next token method that allows you to control if whitespace and commentsare returned as tokens.",
	"Method": "Token getNextToken(boolean returnComments,boolean returnWhiteSpace,Token getNextToken){\r\n    int zzInput;\r\n    int zzAction;\r\n    int zzCurrentPosL;\r\n    int zzMarkedPosL;\r\n    int zzEndReadL = this.zzEndRead;\r\n    char[] zzBufferL = this.zzBuffer;\r\n    char[] zzCMapL = ZZ_CMAP;\r\n    int[] zzTransL = ZZ_TRANS;\r\n    int[] zzRowMapL = ZZ_ROWMAP;\r\n    int[] zzAttrL = ZZ_ATTRIBUTE;\r\n    while (true) {\r\n        zzMarkedPosL = this.zzMarkedPos;\r\n        this.yychar += zzMarkedPosL - this.zzStartRead;\r\n        boolean zzR = false;\r\n        int zzCh;\r\n        int zzCharCount;\r\n        for (zzCurrentPosL = this.zzStartRead; zzCurrentPosL < zzMarkedPosL; zzCurrentPosL += zzCharCount) {\r\n            zzCh = Character.codePointAt(zzBufferL, zzCurrentPosL, zzMarkedPosL);\r\n            zzCharCount = Character.charCount(zzCh);\r\n            switch(zzCh) {\r\n                case '':\r\n                case '\f':\r\n                case '?':\r\n                case '?':\r\n                case '?':\r\n                    this.yyline++;\r\n                    zzR = false;\r\n                    break;\r\n                case '\\r':\r\n                    this.yyline++;\r\n                    zzR = true;\r\n                    break;\r\n                case '\\n':\r\n                    if (zzR) {\r\n                        zzR = false;\r\n                    } else {\r\n                        this.yyline++;\r\n                    }\r\n                    break;\r\n                default:\r\n                    zzR = false;\r\n            }\r\n        }\r\n        if (zzR) {\r\n            boolean zzPeek;\r\n            if (zzMarkedPosL < zzEndReadL) {\r\n                zzPeek = zzBufferL[zzMarkedPosL] == '\\n';\r\n            } else if (this.zzAtEOF) {\r\n                zzPeek = false;\r\n            } else {\r\n                boolean eof = this.zzRefill();\r\n                zzEndReadL = this.zzEndRead;\r\n                zzMarkedPosL = this.zzMarkedPos;\r\n                zzBufferL = this.zzBuffer;\r\n                if (eof) {\r\n                    zzPeek = false;\r\n                } else {\r\n                    zzPeek = zzBufferL[zzMarkedPosL] == '\\n';\r\n                }\r\n            }\r\n            if (zzPeek) {\r\n                this.yyline--;\r\n            }\r\n        }\r\n        zzAction = -1;\r\n        zzCurrentPosL = this.zzCurrentPos = this.zzStartRead = zzMarkedPosL;\r\n        this.zzState = ZZ_LEXSTATE[this.zzLexicalState];\r\n        int zzAttributes = zzAttrL[this.zzState];\r\n        if ((zzAttributes & 1) == 1) {\r\n            zzAction = this.zzState;\r\n        }\r\n        zzForAction: {\r\n            while (true) {\r\n                if (zzCurrentPosL < zzEndReadL) {\r\n                    zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\r\n                    zzCurrentPosL += Character.charCount(zzInput);\r\n                } else if (this.zzAtEOF) {\r\n                    zzInput = YYEOF;\r\n                    break zzForAction;\r\n                } else {\r\n                    this.zzCurrentPos = zzCurrentPosL;\r\n                    this.zzMarkedPos = zzMarkedPosL;\r\n                    boolean eof = this.zzRefill();\r\n                    zzCurrentPosL = this.zzCurrentPos;\r\n                    zzMarkedPosL = this.zzMarkedPos;\r\n                    zzBufferL = this.zzBuffer;\r\n                    zzEndReadL = this.zzEndRead;\r\n                    if (eof) {\r\n                        zzInput = YYEOF;\r\n                        break zzForAction;\r\n                    } else {\r\n                        zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL, zzEndReadL);\r\n                        zzCurrentPosL += Character.charCount(zzInput);\r\n                    }\r\n                }\r\n                int zzNext = zzTransL[zzRowMapL[this.zzState] + zzCMapL[zzInput]];\r\n                if (zzNext == -1) {\r\n                    break zzForAction;\r\n                }\r\n                this.zzState = zzNext;\r\n                zzAttributes = zzAttrL[this.zzState];\r\n                if ((zzAttributes & 1) == 1) {\r\n                    zzAction = this.zzState;\r\n                    zzMarkedPosL = zzCurrentPosL;\r\n                    if ((zzAttributes & 8) == 8) {\r\n                        break zzForAction;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.zzMarkedPos = zzMarkedPosL;\r\n        if (zzInput == YYEOF && this.zzStartRead == this.zzCurrentPos) {\r\n            this.zzAtEOF = true;\r\n            switch(this.zzLexicalState) {\r\n                case COMMENT:\r\n                    {\r\n                        this.nextState = YYINITIAL;\r\n                        this.lastToken = SQLToken.ERROR_UNCLOSED_COMMENT;\r\n                        SQLToken t = new SQLToken(this.lastToken, this.commentBuffer.toString(), this.commentStartLine, this.commentStartChar, this.commentStartChar + this.commentBuffer.length(), this.nextState);\r\n                        this.yybegin(this.nextState);\r\n                        return t;\r\n                    }\r\n                case 964:\r\n                    break;\r\n                default:\r\n                    return null;\r\n            }\r\n        } else {\r\n            switch(zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\r\n                case 1:\r\n                    {\r\n                        this.nextState = YYINITIAL;\r\n                        this.lastToken = SQLToken.WHITE_SPACE;\r\n                        String text = this.yytext();\r\n                        SQLToken t = new SQLToken(this.lastToken, text, this.yyline, this.yychar, this.yychar + text.length(), this.nextState);\r\n                        this.yybegin(this.nextState);\r\n                        return t;\r\n                    }\r\n                case 19:\r\n                    break;\r\n                case 2:\r\n                    {\r\n                        this.nextState = COMMENT;\r\n                        this.commentBuffer.append(this.yytext());\r\n                        this.yybegin(this.nextState);\r\n                    }\r\n                case 20:\r\n                    break;\r\n                case 3:\r\n                    {\r\n                        this.nextState = YYINITIAL;\r\n                        this.lastToken = SQLToken.IDENTIFIER;\r\n                        String text = this.yytext();\r\n                        SQLToken t = new SQLToken(this.lastToken, text, this.yyline, this.yychar, this.yychar + text.length(), this.nextState);\r\n                        this.yybegin(this.nextState);\r\n                        return t;\r\n                    }\r\n                case 21:\r\n                    break;\r\n                case 4:\r\n                    {\r\n                        this.nextState = YYINITIAL;\r\n                        this.lastToken = SQLToken.RESERVED_WORD;\r\n                        String text = this.yytext();\r\n                        SQLToken t = new SQLToken(this.lastToken, text, this.yyline, this.yychar, this.yychar + text.length(), this.nextState);\r\n                        this.yybegin(this.nextState);\r\n                        return t;\r\n                    }\r\n                case 22:\r\n                    break;\r\n                case 5:\r\n                    {\r\n                        this.nextState = YYINITIAL;\r\n                        this.lastToken = SQLToken.ERROR;\r\n                        String text = this.yytext();\r\n                        SQLToken t = new SQLToken(this.lastToken, text, this.yyline, this.yychar, this.yychar + text.length(), this.nextState);\r\n                        this.yybegin(this.nextState);\r\n                        return t;\r\n                    }\r\n                case 23:\r\n                    break;\r\n                case 6:\r\n                    {\r\n                        this.nextState = YYINITIAL;\r\n                        this.lastToken = SQLToken.OPERATOR;\r\n                        String text = this.yytext();\r\n                        SQLToken t = new SQLToken(this.lastToken, text, this.yyline, this.yychar, this.yychar + text.length(), this.nextState);\r\n                        this.yybegin(this.nextState);\r\n                        return t;\r\n                    }\r\n                case 24:\r\n                    break;\r\n                case 7:\r\n                    {\r\n                        this.nextState = YYINITIAL;\r\n                        this.lastToken = SQLToken.LITERAL_INTEGER;\r\n                        String text = this.yytext();\r\n                        SQLToken t = new SQLToken(this.lastToken, text, this.yyline, this.yychar, this.yychar + text.length(), this.nextState);\r\n                        this.yybegin(this.nextState);\r\n                        return t;\r\n                    }\r\n                case 25:\r\n                    break;\r\n                case 8:\r\n                    {\r\n                        this.nextState = YYINITIAL;\r\n                        this.lastToken = SQLToken.SEPARATOR;\r\n                        String text = this.yytext();\r\n                        SQLToken t = new SQLToken(this.lastToken, text, this.yyline, this.yychar, this.yychar + text.length(), this.nextState);\r\n                        this.yybegin(this.nextState);\r\n                        return t;\r\n                    }\r\n                case 26:\r\n                    break;\r\n                case 9:\r\n                    {\r\n                        this.commentNestCount--;\r\n                        this.commentBuffer.append(this.yytext());\r\n                        if (this.commentNestCount == 0) {\r\n                            this.nextState = YYINITIAL;\r\n                            this.lastToken = SQLToken.COMMENT_TRADITIONAL;\r\n                            SQLToken t = new SQLToken(this.lastToken, this.commentBuffer.toString(), this.commentStartLine, this.commentStartChar, this.commentStartChar + this.commentBuffer.length(), this.nextState);\r\n                            this.yybegin(this.nextState);\r\n                            return t;\r\n                        }\r\n                    }\r\n                case 27:\r\n                    break;\r\n                case 10:\r\n                    {\r\n                        this.nextState = YYINITIAL;\r\n                        this.lastToken = SQLToken.COMMENT_END_OF_LINE;\r\n                        String text = this.yytext();\r\n                        SQLToken t = new SQLToken(this.lastToken, text, this.yyline, this.yychar, this.yychar + text.length(), this.nextState);\r\n                        this.yybegin(this.nextState);\r\n                        return t;\r\n                    }\r\n                case 28:\r\n                    break;\r\n                case 11:\r\n                    {\r\n                        this.nextState = YYINITIAL;\r\n                        this.lastToken = SQLToken.LITERAL_FLOAT;\r\n                        String text = this.yytext();\r\n                        SQLToken t = new SQLToken(this.lastToken, text, this.yyline, this.yychar, this.yychar + text.length(), this.nextState);\r\n                        this.yybegin(this.nextState);\r\n                        return t;\r\n                    }\r\n                case 29:\r\n                    break;\r\n                case 12:\r\n                    {\r\n                        this.nextState = YYINITIAL;\r\n                        this.lastToken = SQLToken.LITERAL_STRING;\r\n                        String text = this.yytext();\r\n                        SQLToken t = new SQLToken(this.lastToken, text, this.yyline, this.yychar, this.yychar + text.length(), this.nextState);\r\n                        this.yybegin(this.nextState);\r\n                        return t;\r\n                    }\r\n                case 30:\r\n                    break;\r\n                case 13:\r\n                    {\r\n                        this.nextState = YYINITIAL;\r\n                        this.lastToken = SQLToken.ERROR_UNCLOSED_STRING;\r\n                        String text = this.yytext();\r\n                        SQLToken t = new SQLToken(this.lastToken, text, this.yyline, this.yychar, this.yychar + text.length(), this.nextState);\r\n                        this.yybegin(this.nextState);\r\n                        return t;\r\n                    }\r\n                case 31:\r\n                    break;\r\n                case 14:\r\n                    {\r\n                        this.nextState = COMMENT;\r\n                        this.commentBuffer.setLength(0);\r\n                        this.commentBuffer.append(this.yytext());\r\n                        this.commentNestCount = 1;\r\n                        this.commentStartLine = this.yyline;\r\n                        this.commentStartChar = this.yychar;\r\n                        this.yybegin(this.nextState);\r\n                    }\r\n                case 32:\r\n                    break;\r\n                case 15:\r\n                    {\r\n                        this.nextState = COMMENT;\r\n                        this.commentBuffer.append(this.yytext());\r\n                        this.commentNestCount++;\r\n                        this.yybegin(this.nextState);\r\n                    }\r\n                case 33:\r\n                    break;\r\n                case 16:\r\n                    {\r\n                        this.nextState = YYINITIAL;\r\n                        this.lastToken = SQLToken.ERROR_UNCLOSED_BIT_STRING;\r\n                        String text = this.yytext();\r\n                        SQLToken t = new SQLToken(this.lastToken, text, this.yyline, this.yychar, this.yychar + text.length(), this.nextState);\r\n                        this.yybegin(this.nextState);\r\n                        return t;\r\n                    }\r\n                case 34:\r\n                    break;\r\n                case 17:\r\n                    {\r\n                        this.nextState = YYINITIAL;\r\n                        this.lastToken = SQLToken.ERROR_BAD_BIT_STRING;\r\n                        String text = this.yytext();\r\n                        SQLToken t = new SQLToken(this.lastToken, text, this.yyline, this.yychar, this.yychar + text.length(), this.nextState);\r\n                        this.yybegin(this.nextState);\r\n                        return t;\r\n                    }\r\n                case 35:\r\n                    break;\r\n                case 18:\r\n                    {\r\n                        this.nextState = YYINITIAL;\r\n                        this.lastToken = SQLToken.LITERAL_BIT_STRING;\r\n                        String text = this.yytext();\r\n                        SQLToken t = new SQLToken(this.lastToken, text, this.yyline, this.yychar, this.yychar + text.length(), this.nextState);\r\n                        this.yybegin(this.nextState);\r\n                        return t;\r\n                    }\r\n                case 36:\r\n                    break;\r\n                default:\r\n                    this.zzScanError(ZZ_NO_MATCH);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.createIconDrawable",
	"Comment": "returns a fastbitmapdrawable with the icon, accurately sized.",
	"Method": "FastBitmapDrawable createIconDrawable(Bitmap icon){\r\n    FastBitmapDrawable d = new FastBitmapDrawable(icon);\r\n    d.setFilterBitmap(true);\r\n    resizeIconDrawable(d);\r\n    return d;\r\n}"
}, {
	"Path": "test.jts.perf.algorithm.PointInRingRobustnessTest.pointInRingWindingNumber",
	"Comment": "winding number algorithm included for comparison purposes.this is almost equivalent to the raycrossing algorithm,except that it checks all crossing segments instead of just the ones to the right of the point.this produces the same results as cgalgorithmsdd",
	"Method": "boolean pointInRingWindingNumber(Coordinate p,Coordinate[] ring){\r\n    int winding = 0;\r\n    int n = ring.length;\r\n    for (int i = 0; i < n - 1; i++) {\r\n        if (ring[i].y <= p.y) {\r\n            if (ring[i + 1].y > p.y) {\r\n                if (Orientation.LEFT == Orientation.index(ring[i], ring[i + 1], p))\r\n                    winding++;\r\n            }\r\n        } else {\r\n            if (ring[i + 1].y <= p.y)\r\n                if (Orientation.RIGHT == Orientation.index(ring[i], ring[i + 1], p))\r\n                    winding--;\r\n        }\r\n    }\r\n    return winding != 0;\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testrunner.TestReader.parsePrecisionModel",
	"Comment": "parses an optional precisionmodel element.the default is to use a floating model.",
	"Method": "PrecisionModel parsePrecisionModel(Element runElement){\r\n    PrecisionModel precisionModel = new PrecisionModel();\r\n    Element precisionModelElement = runElement.getChild(\"precisionModel\");\r\n    if (precisionModelElement == null) {\r\n        return precisionModel;\r\n    }\r\n    Attribute typeAttribute = precisionModelElement.getAttribute(\"type\");\r\n    Attribute scaleAttribute = precisionModelElement.getAttribute(\"scale\");\r\n    if (typeAttribute == null && scaleAttribute == null) {\r\n        throw new TestParseException(\"Missing type attribute in <precisionModel>\");\r\n    }\r\n    if (scaleAttribute != null || (typeAttribute != null && typeAttribute.getValue().trim().equalsIgnoreCase(\"FIXED\"))) {\r\n        if (typeAttribute != null && typeAttribute.getValue().trim().equalsIgnoreCase(\"FLOATING\")) {\r\n            throw new TestParseException(\"scale attribute not allowed in floating <precisionModel>\");\r\n        }\r\n        precisionModel = createPrecisionModel(precisionModelElement);\r\n    }\r\n    return precisionModel;\r\n}"
}, {
	"Path": "org.locationtech.jts.planargraph.GraphComponent.isMarked",
	"Comment": "tests if a component has been marked at some point during the processinginvolving this graph.",
	"Method": "boolean isMarked(){\r\n    return isMarked;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.ConformingDelaunayTriangulationBuilder.setTolerance",
	"Comment": "sets the snapping tolerance which will be used\tto improved the robustness of the triangulation computation.\ta tolerance of 0.0 specifies that no snapping will take place.",
	"Method": "void setTolerance(double tolerance){\r\n    this.tolerance = tolerance;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdge.equalsNonOriented",
	"Comment": "tests if this quadedge and another have the same line segment geometry, regardless of orientation.",
	"Method": "boolean equalsNonOriented(QuadEdge qe){\r\n    if (equalsOriented(qe))\r\n        return true;\r\n    if (equalsOriented(qe.sym()))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "com.jsql.view.swing.shell.AbstractShell.appendPrompt",
	"Comment": "add a colored string to the textpane, measure prompt at the same time.",
	"Method": "void appendPrompt(String string,Color color,boolean isAddingPrompt){\r\n    try {\r\n        StyleConstants.setForeground(this.style, color);\r\n        this.styledDocument.insertString(this.styledDocument.getLength(), string, this.style);\r\n        if (isAddingPrompt) {\r\n            this.prompt += string;\r\n        }\r\n    } catch (BadLocationException e) {\r\n        LOGGER.error(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.PolygonizeGraph.getEdgeRings",
	"Comment": "computes the minimal edgerings formed by the edges in this graph.",
	"Method": "List getEdgeRings(){\r\n    computeNextCWEdges();\r\n    label(dirEdges, -1);\r\n    List maximalRings = findLabeledEdgeRings(dirEdges);\r\n    convertMaximalToMinimalEdgeRings(maximalRings);\r\n    List edgeRingList = new ArrayList();\r\n    for (Iterator i = dirEdges.iterator(); i.hasNext(); ) {\r\n        PolygonizeDirectedEdge de = (PolygonizeDirectedEdge) i.next();\r\n        if (de.isMarked())\r\n            continue;\r\n        if (de.isInRing())\r\n            continue;\r\n        EdgeRing er = findEdgeRing(de);\r\n        edgeRingList.add(er);\r\n    }\r\n    return edgeRingList;\r\n}"
}, {
	"Path": "org.kse.gui.ticker.JTicker.actionPerformed",
	"Comment": "triggered by the timer firing. update item positions and repaint ticker.",
	"Method": "void actionPerformed(ActionEvent event){\r\n    offset -= increment;\r\n    int last = positions.length - 1;\r\n    int min = -positions[last];\r\n    if (offset < min) {\r\n        offset = 0;\r\n    }\r\n    repaint();\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.distance3d.Distance3DOp.isWithinDistance",
	"Comment": "test whether two geometries lie within a given distance of each other.",
	"Method": "boolean isWithinDistance(Geometry g0,Geometry g1,double distance){\r\n    Distance3DOp distOp = new Distance3DOp(g0, g1, distance);\r\n    return distOp.distance() <= distance;\r\n}"
}, {
	"Path": "org.locationtech.jtslab.geom.util.GeometryEditorEx.setCopyUserData",
	"Comment": "sets whether the user data is copied to the edit result.only the object reference is copied.",
	"Method": "void setCopyUserData(boolean isUserDataCopied){\r\n    this.isUserDataCopied = isUserDataCopied;\r\n}"
}, {
	"Path": "org.locationtech.jts.planargraph.PlanarGraph.edgeIterator",
	"Comment": "returns an iterator over the edges in this planargraph, in the order in which theywere added.",
	"Method": "Iterator edgeIterator(){\r\n    return edges.iterator();\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.utils.KubernetesResourceUtil.sanitizeName",
	"Comment": "returns an identifier from the given string that can be used as resource name.",
	"Method": "String sanitizeName(String name){\r\n    if (name != null) {\r\n        return name.replaceAll(\"[^A-Za-z0-9]+\", \"-\");\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.kse.gui.about.EnvironmentVariablesTableModel.load",
	"Comment": "load the environmentvariablestablemodel with environment variables.",
	"Method": "void load(){\r\n    TreeMap<String, String> envs = new TreeMap(new EnvironmentVariableComparator());\r\n    envs.putAll(System.getenv());\r\n    data = new String[envs.size()][2];\r\n    int i = 0;\r\n    for (Iterator<Entry<String, String>> itrSorted = envs.entrySet().iterator(); itrSorted.hasNext(); i++) {\r\n        Map.Entry<String, String> property = itrSorted.next();\r\n        data[i][0] = property.getKey();\r\n        data[i][1] = property.getValue();\r\n    }\r\n    fireTableDataChanged();\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.util.AffineTransformation.scaleInstance",
	"Comment": "creates a transformation for a scaling relative to the origin.",
	"Method": "AffineTransformation scaleInstance(double xScale,double yScale,AffineTransformation scaleInstance,double xScale,double yScale,double x,double y){\r\n    AffineTransformation trans = new AffineTransformation();\r\n    trans.translate(-x, -y);\r\n    trans.scale(xScale, yScale);\r\n    trans.translate(x, y);\r\n    return trans;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.PointLocation.isOnLine",
	"Comment": "tests whether a point lies on the line defined by a list ofcoordinates.",
	"Method": "boolean isOnLine(Coordinate p,Coordinate[] line,boolean isOnLine,Coordinate p,CoordinateSequence line){\r\n    LineIntersector lineIntersector = new RobustLineIntersector();\r\n    Coordinate p0 = new Coordinate();\r\n    Coordinate p1 = new Coordinate();\r\n    int n = line.size();\r\n    for (int i = 1; i < n; i++) {\r\n        line.getCoordinate(i - 1, p0);\r\n        line.getCoordinate(i, p1);\r\n        lineIntersector.computeIntersection(p, p0, p1);\r\n        if (lineIntersector.hasIntersection()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.dsl.base.BaseOperation.apiVersion",
	"Comment": "returns the api version falling back to the items apiversion if not null.",
	"Method": "String apiVersion(T item,String apiVersion){\r\n    if (apiVersion != null && !apiVersion.isEmpty()) {\r\n        return trimVersion(apiVersion);\r\n    } else if (item instanceof HasMetadata) {\r\n        return trimVersion(((HasMetadata) item).getApiVersion());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.getFirstRunActivity",
	"Comment": "to be overridden by subclasses to launch any first run activity",
	"Method": "Intent getFirstRunActivity(){\r\n    if (mLauncherCallbacks != null) {\r\n        return mLauncherCallbacks.getFirstRunActivity();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.locationtech.jts.precision.GeometryPrecisionReducer.changePM",
	"Comment": "duplicates a geometry to one that uses a different precisionmodel,without changing any coordinate values.",
	"Method": "Geometry changePM(Geometry geom,PrecisionModel newPM){\r\n    GeometryEditor geomEditor = createEditor(geom.getFactory(), newPM);\r\n    return geomEditor.edit(geom, new GeometryEditor.NoOpGeometryOperation());\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.utils.KubernetesResourceUtil.getOrCreateAnnotations",
	"Comment": "null safe get for fetching annotations from metadata of kubernetes resource",
	"Method": "Map<String, String> getOrCreateAnnotations(HasMetadata entity){\r\n    ObjectMeta metadata = getOrCreateMetadata(entity);\r\n    Map<String, String> answer = metadata.getAnnotations();\r\n    if (answer == null) {\r\n        answer = new LinkedHashMap();\r\n        metadata.setAnnotations(answer);\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "com.jdon.strutsutil.ModelListAction.setModellistByModel",
	"Comment": "the elements in pageiterator is model type we directly add them in result",
	"Method": "void setModellistByModel(ModelListForm listForm,PageIterator pageIterator,HttpServletRequest request){\r\n    Collection c = null;\r\n    try {\r\n        listForm.setAllCount(pageIterator.getAllCount());\r\n        if (pageIterator.getCount() != 0)\r\n            listForm.setCount(pageIterator.getCount());\r\n        c = new ArrayList(pageIterator.getSize());\r\n        while (pageIterator.hasNext()) {\r\n            Object o = pageIterator.next();\r\n            if (o != null)\r\n                c.add(o);\r\n        }\r\n        Debug.logVerbose(\"[JdonFramework] listForm 's property: getList size is \" + c.size(), module);\r\n        pageIterator.reset();\r\n    } catch (Exception e) {\r\n        Debug.logError(\" setModellistByModel error \" + e, module);\r\n        c = new ArrayList();\r\n    }\r\n    listForm.setList(c);\r\n}"
}, {
	"Path": "org.kse.gui.KseFrame.getSelectedEntryAlias",
	"Comment": "get the alias of the entry currently selected in the keystore table if",
	"Method": "String getSelectedEntryAlias(){\r\n    JTable jtKeyStore = getActiveKeyStoreTable();\r\n    int row = jtKeyStore.getSelectedRow();\r\n    if (row == -1) {\r\n        return null;\r\n    }\r\n    String alias = (String) jtKeyStore.getValueAt(row, 3);\r\n    return alias;\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.dsl.base.OperationSupport.handleResponse",
	"Comment": "send an http request and handle the response, optionally performing placeholder substitution to the response.",
	"Method": "T handleResponse(Request.Builder requestBuilder,Class<T> type,T handleResponse,Request.Builder requestBuilder,Class<T> type,Map<String, String> parameters,T handleResponse,OkHttpClient client,Request.Builder requestBuilder,Class<T> type,T handleResponse,OkHttpClient client,Request.Builder requestBuilder,Class<T> type,Map<String, String> parameters){\r\n    VersionUsageUtils.log(this.resourceT, this.apiVersion);\r\n    Request request = requestBuilder.build();\r\n    Response response = client.newCall(request).execute();\r\n    try (ResponseBody body = response.body()) {\r\n        assertResponseCode(request, response);\r\n        if (type != null) {\r\n            try (InputStream bodyInputStream = body.byteStream()) {\r\n                return Serialization.unmarshal(bodyInputStream, type, parameters);\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    } catch (Exception e) {\r\n        if (e instanceof KubernetesClientException) {\r\n            throw e;\r\n        }\r\n        throw requestException(request, e);\r\n    } finally {\r\n        if (response != null && response.body() != null) {\r\n            response.body().close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.DirectedEdge.setVisitedEdge",
	"Comment": "setvisitededge marks both directededges attached to a given edge.this is used for edges corresponding to lines, which will onlyappear oriented in a single direction in the result.",
	"Method": "void setVisitedEdge(boolean isVisited){\r\n    setVisited(isVisited);\r\n    sym.setVisited(isVisited);\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.syntax.SQLToken.getCharEnd",
	"Comment": "get the offset into the input in characters at which this token ended",
	"Method": "int getCharEnd(){\r\n    return this.charEnd;\r\n}"
}, {
	"Path": "org.kse.gui.crypto.policymapping.PolicyMappingsTableHeadRend.getTableCellRendererComponent",
	"Comment": "returns the rendered header cell for the supplied value and column.",
	"Method": "Component getTableCellRendererComponent(JTable jTable,Object value,boolean isSelected,boolean hasFocus,int row,int col){\r\n    Component c = delegate.getTableCellRendererComponent(jTable, value, isSelected, hasFocus, row, col);\r\n    if (c instanceof JLabel) {\r\n        JLabel header = (JLabel) c;\r\n        if (col == 0) {\r\n            header.setToolTipText(res.getString(\"PolicyMappingsTableHeadRend.IssuerDomainPolicyColumn.tooltip\"));\r\n        } else {\r\n            header.setToolTipText(res.getString(\"PolicyMappingsTableHeadRend.SubjectDomainPolicyColumn.tooltip\"));\r\n        }\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision.delete",
	"Comment": "deletes a quadedge from the subdivision. linked quadedges are updated to\treflect the deletion.",
	"Method": "void delete(QuadEdge e){\r\n    QuadEdge.splice(e, e.oPrev());\r\n    QuadEdge.splice(e.sym(), e.sym().oPrev());\r\n    QuadEdge eSym = e.sym();\r\n    QuadEdge eRot = e.rot();\r\n    QuadEdge eRotSym = e.rot().sym();\r\n    quadEdges.remove(e);\r\n    quadEdges.remove(eSym);\r\n    quadEdges.remove(eRot);\r\n    quadEdges.remove(eRotSym);\r\n    e.delete();\r\n    eSym.delete();\r\n    eRot.delete();\r\n    eRotSym.delete();\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.LineSegment.distance",
	"Comment": "computes the distance between this line segment and a given point.",
	"Method": "double distance(LineSegment ls,double distance,Coordinate p){\r\n    return Distance.pointToSegment(p, p0, p1);\r\n}"
}, {
	"Path": "org.locationtech.jts.io.oracle.OraWriterCreateTest.testXY_GeometryCollection_MultiPolygon_Doc",
	"Comment": "multipolygons in geometrycollections are written as a sequence of polygons.",
	"Method": "void testXY_GeometryCollection_MultiPolygon_Doc(){\r\n    checkValue(MDSYS.SDO_GEOMETRY(2004, NULL, NULL, MDSYS.SDO_ELEM_INFO_ARRAY(1, 1, 1, 3, 2, 1, 7, 1003, 1, 17, 1003, 1, 25, 2003, 1), MDSYS.SDO_ORDINATE_ARRAY(1, 1, 1, 2, 2, 1, 2, 2, 3, 2, 3, 3, 2, 3, 2, 2, 5, 1, 9, 5, 5, 5, 5, 1, 5, 3, 6, 4, 6, 3, 5, 3)), \"GEOMETRYCOLLECTION (POINT (1 1), LINESTRING (1 2, 2 1), MULTIPOLYGON (((2 2, 3 2, 3 3, 2 3, 2 2)), ((5 1, 9 5, 5 5, 5 1), (5 3, 6 4, 6 3, 5 3))) )\");\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdge.swap",
	"Comment": "turns an edge counterclockwise inside its enclosing quadrilateral.",
	"Method": "void swap(QuadEdge e){\r\n    QuadEdge a = e.oPrev();\r\n    QuadEdge b = e.sym().oPrev();\r\n    splice(e, a);\r\n    splice(e.sym(), b);\r\n    splice(e, a.lNext());\r\n    splice(e.sym(), b.lNext());\r\n    e.setOrig(a.dest());\r\n    e.setDest(b.dest());\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.VertexTaggedGeometryDataMapper.transferData",
	"Comment": "input is assumed to be a multigeometry\tin which every component has its userdata\tset to be a coordinate which is the key to the output data.\tthe coordinate is used to determine\tthe output data object to be written back into the component.",
	"Method": "void transferData(Geometry targetGeom){\r\n    for (int i = 0; i < targetGeom.getNumGeometries(); i++) {\r\n        Geometry geom = targetGeom.getGeometryN(i);\r\n        Coordinate vertexKey = (Coordinate) geom.getUserData();\r\n        if (vertexKey == null)\r\n            continue;\r\n        geom.setUserData(coordDataMap.get(vertexKey));\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testrunner.EqualityResultMatcher.isMatch",
	"Comment": "tests whether the two results are equal within the given\ttolerance.the input parameters are not considered.",
	"Method": "boolean isMatch(Geometry geom,String opName,Object[] args,Result actualResult,Result expectedResult,double tolerance){\r\n    return actualResult.equals(expectedResult, tolerance);\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.DPreferences.getEnableImportTrustedCertTrustCheck",
	"Comment": "get whether or not trust checks are enabled when importing trusted\tcertificates.",
	"Method": "boolean getEnableImportTrustedCertTrustCheck(){\r\n    return enableImportTrustedCertTrustCheck;\r\n}"
}, {
	"Path": "com.jdon.controller.context.web.RequestWrapperFactory.create",
	"Comment": "create a httpservletrequestwrapper with session supports. this method\twill create httpsession.",
	"Method": "RequestWrapper create(HttpServletRequest request){\r\n    HttpSession session = request.getSession();\r\n    AppContextWrapper acw = new ServletContextWrapper(session.getServletContext());\r\n    SessionWrapper sw = new HttpSessionWrapper(session);\r\n    ContextHolder contextHolder = new ContextHolder(acw, sw);\r\n    return new HttpServletRequestWrapper(request, contextHolder);\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.ConvexHull.grahamScan",
	"Comment": "uses the graham scan algorithm to compute the convex hull vertices.",
	"Method": "Stack grahamScan(Coordinate[] c){\r\n    Coordinate p;\r\n    Stack ps = new Stack();\r\n    ps.push(c[0]);\r\n    ps.push(c[1]);\r\n    ps.push(c[2]);\r\n    for (int i = 3; i < c.length; i++) {\r\n        p = (Coordinate) ps.pop();\r\n        while (!ps.empty() && Orientation.index((Coordinate) ps.peek(), p, c[i]) > 0) {\r\n            p = (Coordinate) ps.pop();\r\n        }\r\n        ps.push(p);\r\n        ps.push(c[i]);\r\n    }\r\n    ps.push(c[0]);\r\n    return ps;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.PolygonizeDirectedEdge.isInRing",
	"Comment": "returns the ring of directed edges that this directed edge isa member of, or null if the ring has not been set.",
	"Method": "boolean isInRing(){\r\n    return edgeRing != null;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.CoordinateList.closeRing",
	"Comment": "ensure this coordlist is a ring, by adding the start point if necessary",
	"Method": "void closeRing(){\r\n    if (size() > 0) {\r\n        Coordinate duplicate = get(0).copy();\r\n        add(duplicate, false);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DD.selfAdd",
	"Comment": "adds the argument to the value of this.to prevent altering constants, this method must only be used on values known to be newly created.",
	"Method": "DD selfAdd(DD y,DD selfAdd,double y,DD selfAdd,double yhi,double ylo){\r\n    double H, h, T, t, S, s, e, f;\r\n    S = hi + yhi;\r\n    T = lo + ylo;\r\n    e = S - hi;\r\n    f = T - lo;\r\n    s = S - e;\r\n    t = T - f;\r\n    s = (yhi - e) + (hi - s);\r\n    t = (ylo - f) + (lo - t);\r\n    e = s + T;\r\n    H = S + e;\r\n    h = e + (S - H);\r\n    e = t + h;\r\n    double zhi = H + e;\r\n    double zlo = e + (H - zhi);\r\n    hi = zhi;\r\n    lo = zlo;\r\n    return this;\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.ensurePendingDropLayoutExists",
	"Comment": "check to see if a given screen id exists. if not, create it at the end, return the new id.",
	"Method": "long ensurePendingDropLayoutExists(long screenId){\r\n    CellLayout dropLayout = (CellLayout) mWorkspace.getScreenWithId(screenId);\r\n    if (dropLayout == null) {\r\n        mWorkspace.addExtraEmptyScreen();\r\n        return mWorkspace.commitExtraEmptyScreen();\r\n    } else {\r\n        return screenId;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jtstest.util.StringUtil.leftPad",
	"Comment": "pads the string with the given character until it has the given length. if original is longer than the given length, returns original.",
	"Method": "String leftPad(String original,int length,char padChar){\r\n    if (original.length() >= length) {\r\n        return original;\r\n    }\r\n    return stringOfChar(padChar, length - original.length()) + original;\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.Quadrant.quadrant",
	"Comment": "returns the quadrant of a directed line segment from p0 to p1.",
	"Method": "int quadrant(double dx,double dy,int quadrant,Coordinate p0,Coordinate p1){\r\n    if (p1.x == p0.x && p1.y == p0.y)\r\n        throw new IllegalArgumentException(\"Cannot compute the quadrant for two identical points \" + p0);\r\n    if (p1.x >= p0.x) {\r\n        if (p1.y >= p0.y)\r\n            return NE;\r\n        else\r\n            return SE;\r\n    } else {\r\n        if (p1.y >= p0.y)\r\n            return NW;\r\n        else\r\n            return SW;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.BufferSubgraph.create",
	"Comment": "creates the subgraph consisting of all edges reachable from this node.finds the edges in the graph and the rightmost coordinate.",
	"Method": "void create(Node node){\r\n    addReachable(node);\r\n    finder.findEdge(dirEdgeList);\r\n    rightMostCoord = finder.getCoordinate();\r\n}"
}, {
	"Path": "com.jsql.view.i18n.I18nView.valueByKey",
	"Comment": "return the text corresponding to a i18n key in the properties.",
	"Method": "String valueByKey(String key){\r\n    String result;\r\n    if (I18n.getLocaleDefault().getLanguage() == new Locale(\"zh\").getLanguage()) {\r\n        result = \"<html><span style=\\\"font-family:'\" + HelperUi.FONT_NAME_UBUNTU_REGULAR + \"'\\\">\" + I18n.valueByKey(key) + \"<\/span><\/html>\";\r\n    } else {\r\n        result = I18n.valueByKey(key);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testbuilder.ui.SwingWorker.get",
	"Comment": "return the value created by the construct method.returns null if either the constructing thread or the currentthread was interrupted before a value was produced.",
	"Method": "Thread get(Object get){\r\n    while (true) {\r\n        Thread t = threadVar.get();\r\n        if (t == null) {\r\n            return getValue();\r\n        }\r\n        try {\r\n            t.join();\r\n        } catch (InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.relate.RelateNode.updateIMFromEdges",
	"Comment": "update the im with the contribution for the edgeends incident on this node.",
	"Method": "void updateIMFromEdges(IntersectionMatrix im){\r\n    ((EdgeEndBundleStar) edges).updateIM(im);\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.Geometry.norm",
	"Comment": "creates a new geometry which is a normalizedcopy of this geometry.",
	"Method": "Geometry norm(){\r\n    Geometry copy = copy();\r\n    copy.normalize();\r\n    return copy;\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.openFolder",
	"Comment": "opens the user folder described by the specified tag. the opening of the folderis animated relative to the specified view. if the view is null, no animationis played.",
	"Method": "void openFolder(FolderIcon folderIcon){\r\n    Folder folder = folderIcon.getFolder();\r\n    Folder openFolder = mWorkspace != null ? mWorkspace.getOpenFolder() : null;\r\n    if (openFolder != null && openFolder != folder) {\r\n        closeFolder();\r\n    }\r\n    FolderInfo info = folder.mInfo;\r\n    info.opened = true;\r\n    ((CellLayout.LayoutParams) folderIcon.getLayoutParams()).canReorder = false;\r\n    if (folder.getParent() == null) {\r\n        mDragLayer.addView(folder);\r\n        mDragController.addDropTarget((DropTarget) folder);\r\n    } else {\r\n        Log.w(TAG, \"Opening folder (\" + folder + \") which already has a parent (\" + folder.getParent() + \").\");\r\n    }\r\n    folder.animateOpen();\r\n    growAndFadeOutFolderIcon(folderIcon);\r\n    folder.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);\r\n    getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.runOnMainThread",
	"Comment": "runs the specified runnable immediately if called from the main thread, otherwise it isposted on the main thread handler.",
	"Method": "void runOnMainThread(Runnable r){\r\n    if (sWorkerThread.getThreadId() == Process.myTid()) {\r\n        mHandler.post(r);\r\n    } else {\r\n        r.run();\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.overlay.MaximalEdgeRing.linkDirectedEdgesForMinimalEdgeRings",
	"Comment": "for all nodes in this edgering,link the directededges at the node to form minimaledgerings",
	"Method": "void linkDirectedEdgesForMinimalEdgeRings(){\r\n    DirectedEdge de = startDe;\r\n    do {\r\n        Node node = de.getNode();\r\n        ((DirectedEdgeStar) node.getEdges()).linkMinimalDirectedEdges(this);\r\n        de = de.getNext();\r\n    } while (de != startDe);\r\n}"
}, {
	"Path": "org.joda.money.BigMoney.isCurrencyScale",
	"Comment": "checks if this money has the scale of the currency.each currency has a default scale, such as 2 for usd and 0 for jpy.this method checks if the current scale matches the default scale.",
	"Method": "boolean isCurrencyScale(){\r\n    return amount.scale() == currency.getDecimalPlaces();\r\n}"
}, {
	"Path": "org.locationtech.jts.io.oracle.OraWriter.writeGeometryOrdinates",
	"Comment": "writes the ordinate values extracted from each element geometryinto a double array.this optimizes memory usage by only allocating the singledouble array required to pass the ordinates to the oracle struct.",
	"Method": "double[] writeGeometryOrdinates(List elemTriplets,List ordGeoms,int ordSize,int dim){\r\n    double[] ords = new double[ordSize];\r\n    int ordIndex = 0;\r\n    for (int ielem = 0; ielem < elemTriplets.size(); ielem++) {\r\n        int[] triplet = (int[]) elemTriplets.get(ielem);\r\n        int startOffset = triplet[0];\r\n        Assert.isTrue(startOffset == ordIndex + 1, \"ElemInfo computed startingOffset does not match actual ordinates position\");\r\n        int elemType = triplet[1];\r\n        int interp = triplet[2];\r\n        Geometry geom = (Geometry) ordGeoms.get(ielem);\r\n        switch(elemType) {\r\n            case OraGeom.ETYPE.POINT:\r\n                if (interp == 1) {\r\n                    ordIndex = writeOrds(((Point) geom).getCoordinateSequence(), dim, ords, ordIndex);\r\n                } else {\r\n                    ordIndex = writeOrds((MultiPoint) geom, dim, ords, ordIndex);\r\n                }\r\n                break;\r\n            case OraGeom.ETYPE.LINE:\r\n                ordIndex = writeOrds(((LineString) geom).getCoordinateSequence(), dim, ords, ordIndex);\r\n                break;\r\n            case OraGeom.ETYPE.POLYGON_EXTERIOR:\r\n                if (interp == OraGeom.INTERP.RECTANGLE) {\r\n                    ordIndex = writeRectangleOrds(geom, dim, ords, ordIndex);\r\n                } else {\r\n                    ordIndex = writeOrdsOriented(((LineString) geom).getCoordinateSequence(), dim, ords, ordIndex, true);\r\n                }\r\n                break;\r\n            case OraGeom.ETYPE.POLYGON_INTERIOR:\r\n                ordIndex = writeOrdsOriented(((LineString) geom).getCoordinateSequence(), dim, ords, ordIndex, false);\r\n                break;\r\n        }\r\n    }\r\n    return ords;\r\n}"
}, {
	"Path": "com.jdon.model.query.block.BlockStrategy.getBlock",
	"Comment": "get the current block being avaliable to the query condition",
	"Method": "Block getBlock(String sqlquery,Collection queryParams,int startIndex,int count,Block getBlock,QueryConditonDatakey qcdk){\r\n    Block clientBlock = new Block(qcdk.getStart(), qcdk.getCount());\r\n    if (clientBlock.getCount() > this.blockLength)\r\n        clientBlock.setCount(this.blockLength);\r\n    List list = getBlockKeys(qcdk);\r\n    Block dataBlock = new Block(qcdk.getBlockStart(), list.size());\r\n    int currentStart = clientBlock.getStart() - dataBlock.getStart();\r\n    Block currentBlock = new Block(currentStart, clientBlock.getCount());\r\n    currentBlock.setList(list);\r\n    try {\r\n        int lastCount = dataBlock.getCount() + dataBlock.getStart() - clientBlock.getStart();\r\n        Debug.logVerbose(\"[JdonFramework] lastCount=\" + lastCount, module);\r\n        if (lastCount < clientBlock.getCount()) {\r\n            if (dataBlock.getCount() == this.blockLength) {\r\n                int newStartIndex = dataBlock.getStart() + dataBlock.getCount();\r\n                int newCount = clientBlock.getCount() - lastCount;\r\n                qcdk.setStart(newStartIndex);\r\n                qcdk.setCount(newCount);\r\n                Debug.logVerbose(\"[JdonFramework]  newStartIndex=\" + newStartIndex + \" newCount=\" + newCount, module);\r\n                Block nextBlock = getBlock(qcdk);\r\n                Debug.logVerbose(\"[JdonFramework]  nextBlock.getCount()=\" + nextBlock.getCount(), module);\r\n                currentBlock.setCount(currentBlock.getCount() + nextBlock.getCount());\r\n            } else {\r\n                currentBlock.setCount(lastCount);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        Debug.logError(\" getBlock error\" + e, module);\r\n    }\r\n    return currentBlock;\r\n}"
}, {
	"Path": "org.kse.gui.JMenuRecentFiles.invalidate",
	"Comment": "invalidate a recent file menu item by removing it from the menu. call\twhen a recent file no longer exists.",
	"Method": "void invalidate(JMenuItemRecentFile jmirfOld){\r\n    int index = findRecentFile(jmirfOld.getFile());\r\n    if (index == -1) {\r\n        return;\r\n    }\r\n    removeAllRecentFiles();\r\n    for (int i = index; i < jmiRecentFiles.length; i++) {\r\n        if (i < (jmiRecentFiles.length - 1)) {\r\n            jmiRecentFiles[i] = jmiRecentFiles[i + 1];\r\n            if (jmiRecentFiles[i + 1] != null) {\r\n                jmiRecentFiles[i].setPosition(i + 1);\r\n            }\r\n        } else {\r\n            jmiRecentFiles[i] = null;\r\n        }\r\n    }\r\n    addAllRecentFiles();\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifInterface.setTagValue",
	"Comment": "sets the value of an exiftag if it exists in the given ifd. the valuemust be the correct type and length for that exiftag.",
	"Method": "boolean setTagValue(int tagId,int ifdId,Object val,boolean setTagValue,int tagId,Object val){\r\n    int ifdId = getDefinedTagDefaultIfd(tagId);\r\n    return setTagValue(tagId, ifdId, val);\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.CGAlgorithmsDD.signOfDet2x2",
	"Comment": "computes the sign of the determinant of the 2x2 matrixwith the given entries.",
	"Method": "int signOfDet2x2(DD x1,DD y1,DD x2,DD y2,int signOfDet2x2,double dx1,double dy1,double dx2,double dy2){\r\n    DD x1 = DD.valueOf(dx1);\r\n    DD y1 = DD.valueOf(dy1);\r\n    DD x2 = DD.valueOf(dx2);\r\n    DD y2 = DD.valueOf(dy2);\r\n    DD det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\r\n    return det.signum();\r\n}"
}, {
	"Path": "org.kse.crypto.privatekey.OpenSslPvkUtil.loadEncrypted",
	"Comment": "load an encrypted openssl private key from the specified stream. the\tencoding of the private key will be pem.",
	"Method": "PrivateKey loadEncrypted(byte[] pvkData,Password password){\r\n    EncryptionType encType = getEncryptionType(pvkData);\r\n    if (encType == null) {\r\n        throw new CryptoException(res.getString(\"NotValidOpenSsl.exception.message\"));\r\n    }\r\n    if (encType == UNENCRYPTED) {\r\n        throw new PrivateKeyUnencryptedException(res.getString(\"OpenSslIsUnencrypted.exception.message\"));\r\n    }\r\n    PemInfo pemInfo = PemUtil.decode(pvkData);\r\n    byte[] encKey = pemInfo.getContent();\r\n    PemAttributes attributes = pemInfo.getAttributes();\r\n    String dekInfo = attributes.get(DEK_INFO_ATTR_NAME).getValue();\r\n    int separator = dekInfo.indexOf(',');\r\n    if (separator == -1) {\r\n        throw new CryptoException(MessageFormat.format(res.getString(\"OpenSslDekInfoMalformed.exception.message\"), dekInfo));\r\n    }\r\n    String encAlg = dekInfo.substring(0, separator);\r\n    String salt = dekInfo.substring(separator + 1);\r\n    byte[] saltBytes = hexToBytes(salt);\r\n    OpenSslPbeType pbeType = OpenSslPbeType.resolveDekInfo(encAlg);\r\n    if (pbeType == null) {\r\n        throw new PrivateKeyPbeNotSupportedException(encAlg, MessageFormat.format(res.getString(\"PrivateKeyWrappingAlgUnsupported.exception.message\"), encAlg));\r\n    }\r\n    try {\r\n        byte[] decryptKey = deriveKeyFromPassword(password, saltBytes, pbeType.keySize());\r\n        Cipher cipher = createCipher(pbeType.jceCipher(), decryptKey, saltBytes, DECRYPT_MODE);\r\n        byte[] key = cipher.doFinal(encKey);\r\n        return load(key);\r\n    } catch (GeneralSecurityException ex) {\r\n        throw new CryptoException(MessageFormat.format(res.getString(\"OpenSslDecryptionFailed.exception.message\"), pbeType.friendly()), ex);\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.SearchDropTargetBar.animateViewAlpha",
	"Comment": "convenience method to animate the alpha of a view using hardware layers.",
	"Method": "void animateViewAlpha(LauncherViewPropertyAnimator animator,View v,float alpha,int duration){\r\n    if (v == null) {\r\n        return;\r\n    }\r\n    animator.cancel();\r\n    if (Float.compare(v.getAlpha(), alpha) != 0) {\r\n        if (duration > 0) {\r\n            animator.alpha(alpha).withLayer().setDuration(duration).start();\r\n        } else {\r\n            v.setAlpha(alpha);\r\n            AlphaUpdateListener.updateVisibility(v, mAccessibilityEnabled);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.BoundaryOp.getBoundary",
	"Comment": "computes a geometry representing the boundary of a geometry.",
	"Method": "Geometry getBoundary(Geometry g,Geometry getBoundary,Geometry g,BoundaryNodeRule bnRule,Geometry getBoundary){\r\n    if (geom instanceof LineString)\r\n        return boundaryLineString((LineString) geom);\r\n    if (geom instanceof MultiLineString)\r\n        return boundaryMultiLineString((MultiLineString) geom);\r\n    return geom.getBoundary();\r\n}"
}, {
	"Path": "com.jdon.cache.UtilCache.containsKey",
	"Comment": "returns a boolean specifying whether or not an element with the specified\tkey is in the cache. if the requested element hasexpired, it is removed\tbefore it is looked up which causes the function to return false.",
	"Method": "boolean containsKey(Object key){\r\n    CacheLine line = (CacheLine) cacheLineTable.get(key);\r\n    if (hasExpired(line)) {\r\n        removeObject(key);\r\n        line = null;\r\n    }\r\n    if (line != null) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.functions.Fn3.apply",
	"Comment": "partially apply this function by taking its first two arguments.",
	"Method": "D apply(A a,B b,C c,Fn2<B, C, D> apply,A a,Fn1<C, D> apply,A a,B b){\r\n    return (c) -> apply(a, b, c);\r\n}"
}, {
	"Path": "com.android.launcher3.DeviceProfile.getHotseatRect",
	"Comment": "the rect returned will be extended to below the system ui that covers the workspace",
	"Method": "Rect getHotseatRect(){\r\n    if (isVerticalBarLayout()) {\r\n        return new Rect(availableWidthPx - hotseatBarHeightPx, 0, Integer.MAX_VALUE, availableHeightPx);\r\n    } else {\r\n        return new Rect(0, availableHeightPx - hotseatBarHeightPx, availableWidthPx, Integer.MAX_VALUE);\r\n    }\r\n}"
}, {
	"Path": "net.dv8tion.jda.webhook.WebhookMessageBuilder.setUsername",
	"Comment": "sets the username that should be used for the resulting message.this will override the default username of the webhook.",
	"Method": "WebhookMessageBuilder setUsername(String username){\r\n    this.username = Helpers.isBlank(username) ? null : username;\r\n    return this;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.hlist.Tuple8.fill",
	"Comment": "given a value of type a, produced an instance of this tuple with each slot set to that value.",
	"Method": "Tuple8<A, A, A, A, A, A, A, A> fill(A a){\r\n    return tuple(a, a, a, a, a, a, a, a);\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifData.getCompressedThumbnail",
	"Comment": "gets the compressed thumbnail. returns null if there is no compressedthumbnail.",
	"Method": "byte[] getCompressedThumbnail(){\r\n    return mThumbnail;\r\n}"
}, {
	"Path": "com.android.launcher3.Folder.prepareAccessibilityDrop",
	"Comment": "when performing an accessibility drop, ondrop is sent immediately after ondragenter. so weneed to complete all transient states based on timers.",
	"Method": "void prepareAccessibilityDrop(){\r\n    if (mReorderAlarm.alarmPending()) {\r\n        mReorderAlarm.cancelAlarm();\r\n        mReorderAlarmListener.onAlarm(mReorderAlarm);\r\n    }\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.patch.DiffMatchPatch.patchFromText",
	"Comment": "parse a textual representation of patches and return a list of patchobjects.",
	"Method": "List<Patch> patchFromText(String textline){\r\n    List<Patch> patches = new LinkedList();\r\n    if (textline.length() == 0) {\r\n        return patches;\r\n    }\r\n    List<String> textList = Arrays.asList(textline.split(\"\\n\"));\r\n    Deque<String> text = new LinkedList(textList);\r\n    Patch patch;\r\n    Pattern patchHeader = Pattern.compile(\"^@@ -(\\\\d+),?(\\\\d*) \\\\+(\\\\d+),?(\\\\d*) @@$\");\r\n    Matcher m;\r\n    char sign;\r\n    String line;\r\n    while (!text.isEmpty()) {\r\n        m = patchHeader.matcher(text.getFirst());\r\n        if (!m.matches()) {\r\n            throw new IllegalArgumentException(\"Invalid patch string: \" + text.getFirst());\r\n        }\r\n        patch = new Patch();\r\n        patches.add(patch);\r\n        patch.setStart1(Integer.parseInt(m.group(1)));\r\n        if (m.group(2).length() == 0) {\r\n            patch.setStart1(patch.getStart1() - 1);\r\n            patch.setLength1(1);\r\n        } else if (\"0\".equals(m.group(2))) {\r\n            patch.setLength1(0);\r\n        } else {\r\n            patch.setStart1(patch.getStart1() - 1);\r\n            patch.setLength1(Integer.parseInt(m.group(2)));\r\n        }\r\n        patch.setStart2(Integer.parseInt(m.group(3)));\r\n        if (m.group(4).length() == 0) {\r\n            patch.setStart2(patch.getStart2() - 1);\r\n            patch.setLength2(1);\r\n        } else if (\"0\".equals(m.group(4))) {\r\n            patch.setLength2(0);\r\n        } else {\r\n            patch.setStart2(patch.getStart2() - 1);\r\n            patch.setLength2(Integer.parseInt(m.group(4)));\r\n        }\r\n        text.removeFirst();\r\n        while (!text.isEmpty()) {\r\n            try {\r\n                sign = text.getFirst().charAt(0);\r\n            } catch (IndexOutOfBoundsException e) {\r\n                IgnoreMessageException exceptionIgnored = new IgnoreMessageException(e);\r\n                LOGGER.trace(exceptionIgnored, exceptionIgnored);\r\n                text.removeFirst();\r\n                continue;\r\n            }\r\n            line = text.getFirst().substring(1);\r\n            line = line.replace(\"+\", \"+\");\r\n            try {\r\n                line = URLDecoder.decode(line, StandardCharsets.UTF_8.name());\r\n            } catch (IllegalArgumentException e) {\r\n                throw new IllegalArgumentException(\"Illegal escape in patch_fromText: \" + line, e);\r\n            }\r\n            if (sign == '-') {\r\n                patch.getDiffs().add(new Diff(Operation.DELETE, line));\r\n            } else if (sign == '+') {\r\n                patch.getDiffs().add(new Diff(Operation.INSERT, line));\r\n            } else if (sign == ' ') {\r\n                patch.getDiffs().add(new Diff(Operation.EQUAL, line));\r\n            } else if (sign == '@') {\r\n                break;\r\n            } else {\r\n                throw new IllegalArgumentException(\"Invalid patch mode '\" + sign + \"' in: \" + line);\r\n            }\r\n            text.removeFirst();\r\n        }\r\n    }\r\n    return patches;\r\n}"
}, {
	"Path": "com.android.launcher3.PagedView.notifyPageSwitchListener",
	"Comment": "should be called whenever the page changes. in the case of a scroll, we wait until the pagehas settled.",
	"Method": "void notifyPageSwitchListener(){\r\n    if (mPageSwitchListener != null) {\r\n        mPageSwitchListener.onPageSwitch(getPageAt(getNextPage()), getNextPage());\r\n    }\r\n    updatePageIndicator();\r\n}"
}, {
	"Path": "com.jdon.strutsutil.treeview.TreeControlTag.replace",
	"Comment": "replace any occurrence of the specified placeholder in the specified\ttemplate string with the specified replacement value.",
	"Method": "String replace(String template,String placeholder,String value){\r\n    if (template == null)\r\n        return (null);\r\n    if ((placeholder == null) || (value == null))\r\n        return (template);\r\n    while (true) {\r\n        int index = template.indexOf(placeholder);\r\n        if (index < 0)\r\n            break;\r\n        StringBuilder temp = new StringBuilder(template.substring(0, index));\r\n        temp.append(value);\r\n        temp.append(template.substring(index + placeholder.length()));\r\n        template = temp.toString();\r\n    }\r\n    return (template);\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.importexport.DImportKeyPairPvk.getCertificateChain",
	"Comment": "get the certificate chain part of the key pair chosen by the user for\timport.",
	"Method": "Certificate[] getCertificateChain(){\r\n    return certificateChain;\r\n}"
}, {
	"Path": "com.android.launcher3.Hotseat.getOrderInHotseat",
	"Comment": "get the orientation invariant order of the item in the hotseat for persistence.",
	"Method": "int getOrderInHotseat(int x,int y){\r\n    return mHasVerticalHotseat ? (mContent.getCountY() - y - 1) : x;\r\n}"
}, {
	"Path": "com.android.launcher3.util.ManagedProfileHeuristic.processPackageAdd",
	"Comment": "updates the list of installed apps and adds any new icons on homescreen or work folder.",
	"Method": "void processPackageAdd(String[] packages){\r\n    mHomescreenApps = new ArrayList();\r\n    mWorkFolderApps = new ArrayList();\r\n    HashSet<String> packageSet = new HashSet();\r\n    final boolean userAppsExisted = getUserApps(packageSet);\r\n    boolean newPackageAdded = false;\r\n    long installTime = System.currentTimeMillis();\r\n    LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(mContext);\r\n    for (String packageName : packages) {\r\n        if (!packageSet.contains(packageName)) {\r\n            packageSet.add(packageName);\r\n            newPackageAdded = true;\r\n            List<LauncherActivityInfoCompat> activities = launcherApps.getActivityList(packageName, mUser);\r\n            if (!activities.isEmpty()) {\r\n                markForAddition(activities.get(0), installTime);\r\n            }\r\n        }\r\n    }\r\n    if (newPackageAdded) {\r\n        mPrefs.edit().putStringSet(mPackageSetKey, packageSet).apply();\r\n        finalizeAdditions(userAppsExisted);\r\n    }\r\n}"
}, {
	"Path": "cn.jpush.api.push.model.notification.Notification.alert",
	"Comment": "quick set all platform alert. platform notification can override this alert.",
	"Method": "Notification alert(Object alert){\r\n    return newBuilder().setAlert(alert).build();\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.PlanarGraph.addEdges",
	"Comment": "add a set of edges to the graph.for each edge two directededgeswill be created.directededges are not linked by this method.",
	"Method": "void addEdges(List edgesToAdd){\r\n    for (Iterator it = edgesToAdd.iterator(); it.hasNext(); ) {\r\n        Edge e = (Edge) it.next();\r\n        edges.add(e);\r\n        DirectedEdge de1 = new DirectedEdge(e, true);\r\n        DirectedEdge de2 = new DirectedEdge(e, false);\r\n        de1.setSym(de2);\r\n        de2.setSym(de1);\r\n        add(de1);\r\n        add(de2);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.planargraph.DirectedEdge.isRemoved",
	"Comment": "tests whether this directed edge has been removed from its containing graph",
	"Method": "boolean isRemoved(){\r\n    return parentEdge == null;\r\n}"
}, {
	"Path": "org.kse.crypto.keypair.KeyPairUtil.validKeyPair",
	"Comment": "check that the supplied private and public keys actually comprise a valid\tkey pair.",
	"Method": "boolean validKeyPair(PrivateKey privateKey,PublicKey publicKey){\r\n    try {\r\n        String privateAlgorithm = privateKey.getAlgorithm();\r\n        String publicAlgorithm = publicKey.getAlgorithm();\r\n        if (!privateAlgorithm.equals(publicAlgorithm)) {\r\n            return false;\r\n        }\r\n        if (privateAlgorithm.equals(RSA.jce())) {\r\n            byte[] toSign = \"Rivest Shamir Adleman\".getBytes();\r\n            String signatureAlgorithm = \"SHA256withRSA\";\r\n            byte[] signature = sign(toSign, privateKey, signatureAlgorithm);\r\n            return verify(toSign, signature, publicKey, signatureAlgorithm);\r\n        } else if (privateAlgorithm.equals(DSA.jce())) {\r\n            byte[] toSign = \"Digital Signature Algorithm\".getBytes();\r\n            String signatureAlgorithm = \"SHA1withDSA\";\r\n            byte[] signature = sign(toSign, privateKey, signatureAlgorithm);\r\n            return verify(toSign, signature, publicKey, signatureAlgorithm);\r\n        } else if (privateAlgorithm.equals(EC.jce())) {\r\n            byte[] toSign = \"EC Digital Signature Algorithm\".getBytes();\r\n            String signatureAlgorithm = \"SHA256withECDSA\";\r\n            byte[] signature = sign(toSign, privateKey, signatureAlgorithm);\r\n            return verify(toSign, signature, publicKey, signatureAlgorithm);\r\n        } else {\r\n            throw new CryptoException(MessageFormat.format(res.getString(\"NoCheckCompriseValidKeypairAlg.exception.message\"), privateAlgorithm));\r\n        }\r\n    } catch (GeneralSecurityException ex) {\r\n        throw new CryptoException(res.getString(\"NoCheckCompriseValidKeypair.exception.message\"), ex);\r\n    }\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.dsl.base.OperationSupport.handleReplace",
	"Comment": "replace a resource, optionally performing placeholder substitution to the response.",
	"Method": "T handleReplace(T updated,Class<T> type,T handleReplace,T updated,Class<T> type,Map<String, String> parameters){\r\n    RequestBody body = RequestBody.create(JSON, JSON_MAPPER.writeValueAsString(updated));\r\n    Request.Builder requestBuilder = new Request.Builder().put(body).url(getResourceUrl(checkNamespace(updated), checkName(updated)));\r\n    return handleResponse(requestBuilder, type, parameters);\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.ConformingDelaunayTriangulator.getConvexHull",
	"Comment": "gets the convex hull of all the sites in the triangulation,\tincluding constraint vertices.\tonly valid after the constraints have been enforced.",
	"Method": "Geometry getConvexHull(){\r\n    return convexHull;\r\n}"
}, {
	"Path": "org.kse.crypto.x509.X509CertUtil.convertCertificate",
	"Comment": "convert the supplied certificate object into an x509certificate object.",
	"Method": "X509Certificate convertCertificate(Certificate certIn){\r\n    try {\r\n        CertificateFactory cf = CertificateFactory.getInstance(X509_CERT_TYPE, BOUNCY_CASTLE.jce());\r\n        ByteArrayInputStream bais = new ByteArrayInputStream(certIn.getEncoded());\r\n        return (X509Certificate) cf.generateCertificate(bais);\r\n    } catch (CertificateException | NoSuchProviderException e) {\r\n        throw new CryptoException(res.getString(\"NoConvertCertificate.exception.message\"), e);\r\n    }\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifInterface.getThumbnailBitmap",
	"Comment": "returns the thumbnail from ifd1 as a bitmap, or null if none exists.",
	"Method": "Bitmap getThumbnailBitmap(){\r\n    if (mData.hasCompressedThumbnail()) {\r\n        byte[] thumb = mData.getCompressedThumbnail();\r\n        return BitmapFactory.decodeByteArray(thumb, 0, thumb.length);\r\n    } else if (mData.hasUncompressedStrip()) {\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.syntax.SQLToken.isLiteral",
	"Comment": "checks this token to see if it is a literal. literals are explained in java languagespecification.",
	"Method": "boolean isLiteral(){\r\n    return (this.id >> 8) == 0x3;\r\n}"
}, {
	"Path": "com.android.launcher3.Workspace.findMatchingPageForDragOver",
	"Comment": "this method returns the celllayout that is currently being dragged to. in order to dragto a celllayout, either the touch point must be directly over the celllayout, or as a secondstrategy, we see if the dragview is overlapping any celllayout and choose the closest onereturn null if no celllayout is currently being dragged over",
	"Method": "CellLayout findMatchingPageForDragOver(DragView dragView,float originX,float originY,boolean exact){\r\n    final int screenCount = getChildCount();\r\n    CellLayout bestMatchingScreen = null;\r\n    float smallestDistSoFar = Float.MAX_VALUE;\r\n    for (int i = 0; i < screenCount; i++) {\r\n        if (mScreenOrder.get(i) == CUSTOM_CONTENT_SCREEN_ID) {\r\n            continue;\r\n        }\r\n        CellLayout cl = (CellLayout) getChildAt(i);\r\n        final float[] touchXy = { originX, originY };\r\n        cl.getMatrix().invert(mTempInverseMatrix);\r\n        mapPointFromSelfToChild(cl, touchXy, mTempInverseMatrix);\r\n        if (touchXy[0] >= 0 && touchXy[0] <= cl.getWidth() && touchXy[1] >= 0 && touchXy[1] <= cl.getHeight()) {\r\n            return cl;\r\n        }\r\n        if (!exact) {\r\n            final float[] cellLayoutCenter = mTempCellLayoutCenterCoordinates;\r\n            cellLayoutCenter[0] = cl.getWidth() / 2;\r\n            cellLayoutCenter[1] = cl.getHeight() / 2;\r\n            mapPointFromChildToSelf(cl, cellLayoutCenter);\r\n            touchXy[0] = originX;\r\n            touchXy[1] = originY;\r\n            float dist = squaredDistance(touchXy, cellLayoutCenter);\r\n            if (dist < smallestDistSoFar) {\r\n                smallestDistSoFar = dist;\r\n                bestMatchingScreen = cl;\r\n            }\r\n        }\r\n    }\r\n    return bestMatchingScreen;\r\n}"
}, {
	"Path": "org.locationtech.jts.dissolve.DissolveHalfEdge.setStart",
	"Comment": "sets this edge to be the start segment of an input linestring.",
	"Method": "void setStart(){\r\n    isStart = true;\r\n}"
}, {
	"Path": "org.kse.crypto.privatekey.MsPvkUtil.loadEncrypted",
	"Comment": "load an encrypted pvk private key from the specified stream.",
	"Method": "PrivateKey loadEncrypted(byte[] pvk,Password password){\r\n    try {\r\n        ByteBuffer bb = ByteBuffer.wrap(pvk);\r\n        bb.order(ByteOrder.LITTLE_ENDIAN);\r\n        long keyType = readReservedMagicKeyType(bb);\r\n        long encrypted = UnsignedUtil.getInt(bb);\r\n        if (encrypted != PVK_ENCRYPTED) {\r\n            throw new PrivateKeyUnencryptedException(MessageFormat.format(res.getString(\"MsPvkIsUnencrypted.exception.message\"), Long.toHexString(encrypted), Long.toHexString(PVK_ENCRYPTED)));\r\n        }\r\n        long saltLength = UnsignedUtil.getInt(bb);\r\n        if (saltLength != ENCRYPTED_SALT_LENGTH) {\r\n            throw new CryptoException(MessageFormat.format(res.getString(\"InvalidMsPvkSaltLengthField.exception.message\"), Long.toHexString(saltLength), Long.toHexString(ENCRYPTED_SALT_LENGTH)));\r\n        }\r\n        long keyLength = UnsignedUtil.getInt(bb);\r\n        byte[] strongKey = new byte[16];\r\n        byte[] weakKey = new byte[16];\r\n        byte[] salt = new byte[(int) saltLength];\r\n        bb.get(salt);\r\n        MessageDigest messagedigest = MessageDigest.getInstance(\"SHA1\");\r\n        byte[] passwordBytes = new String(password.toCharArray()).getBytes();\r\n        byte[] saltAndPassword = new byte[salt.length + passwordBytes.length];\r\n        System.arraycopy(salt, 0, saltAndPassword, 0, salt.length);\r\n        System.arraycopy(passwordBytes, 0, saltAndPassword, salt.length, passwordBytes.length);\r\n        byte[] key = messagedigest.digest(saltAndPassword);\r\n        System.arraycopy(key, 0, strongKey, 0, 16);\r\n        System.arraycopy(key, 0, weakKey, 0, 5);\r\n        for (int i = 5; i < 16; i++) {\r\n            weakKey[i] = 0;\r\n        }\r\n        readPrivateKeyBlobHeader(bb, keyType);\r\n        byte[] encryptedPrivateKeyBlob = new byte[bb.remaining()];\r\n        bb.get(encryptedPrivateKeyBlob);\r\n        if (keyLength != (encryptedPrivateKeyBlob.length + BLOB_HEADER_LENGTH)) {\r\n            throw new CryptoException(MessageFormat.format(res.getString(\"InvalidMsPvkKeyLengthField.exception.message\"), Long.toHexString(keyLength), Long.toHexString(encryptedPrivateKeyBlob.length + BLOB_HEADER_LENGTH)));\r\n        }\r\n        byte[] decryptedPrivateKeyBlob = decryptPrivateKeyBlob(encryptedPrivateKeyBlob, strongKey);\r\n        if (decryptedPrivateKeyBlob == null) {\r\n            decryptedPrivateKeyBlob = decryptPrivateKeyBlob(encryptedPrivateKeyBlob, weakKey);\r\n            if (decryptedPrivateKeyBlob == null) {\r\n                throw new CryptoException(res.getString(\"NoDecryptMsPvkCheckPassword.exception.message\"));\r\n            }\r\n        }\r\n        return blobToPrivateKey(decryptedPrivateKeyBlob);\r\n    } catch (GeneralSecurityException ex) {\r\n        throw new CryptoException(res.getString(\"NoLoadMsPvk.exception.message\"), ex);\r\n    }\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.importexport.DImportKeyPairPvk.getPrivateKey",
	"Comment": "get the private part of the key pair chosen by the user for import.",
	"Method": "PrivateKey getPrivateKey(){\r\n    return privateKey;\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isMinute",
	"Comment": "isminute returns true if string s is a valid number between 0 and 59.",
	"Method": "boolean isMinute(String s){\r\n    if (isEmpty(s))\r\n        return defaultEmptyOK;\r\n    return isIntegerInRange(s, 0, 59);\r\n}"
}, {
	"Path": "com.android.launcher3.CellLayout.pointToCellExact",
	"Comment": "given a point, return the cell that strictly encloses that point",
	"Method": "void pointToCellExact(int x,int y,int[] result){\r\n    final int hStartPadding = getPaddingLeft();\r\n    final int vStartPadding = getPaddingTop();\r\n    result[0] = (x - hStartPadding) / (mCellWidth + mWidthGap);\r\n    result[1] = (y - vStartPadding) / (mCellHeight + mHeightGap);\r\n    final int xAxis = mCountX;\r\n    final int yAxis = mCountY;\r\n    if (result[0] < 0)\r\n        result[0] = 0;\r\n    if (result[0] >= xAxis)\r\n        result[0] = xAxis - 1;\r\n    if (result[1] < 0)\r\n        result[1] = 0;\r\n    if (result[1] >= yAxis)\r\n        result[1] = yAxis - 1;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.MinimumBoundingCircle.getCentre",
	"Comment": "gets the centre point of the computed minimum bounding circle.",
	"Method": "Coordinate getCentre(){\r\n    compute();\r\n    return centre;\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.utils.KubernetesResourceUtil.getLabels",
	"Comment": "returns the labels of the given metadata object or an empty map if the metadata or labels are null",
	"Method": "Map<String, String> getLabels(ObjectMeta metadata){\r\n    if (metadata != null) {\r\n        Map<String, String> labels = metadata.getLabels();\r\n        if (labels != null) {\r\n            return labels;\r\n        }\r\n    }\r\n    return Collections.EMPTY_MAP;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.distance.DiscreteHausdorffDistanceTest.testLinesShowingDiscretenessEffect",
	"Comment": "shows effects of limiting hd to verticesanswer is not true hausdorff distance.",
	"Method": "void testLinesShowingDiscretenessEffect(){\r\n    runTest(\"LINESTRING (130 0, 0 0, 0 150)\", \"LINESTRING (10 10, 10 150, 130 10)\", 14.142135623730951);\r\n    runTest(\"LINESTRING (130 0, 0 0, 0 150)\", \"LINESTRING (10 10, 10 150, 130 10)\", 0.5, 70.0);\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testbuilder.ui.tools.BoxBandTool.getCoordinatesOfEnvelope",
	"Comment": "getes the coordinates for the rectanglestarting with the lower left point.the coordinates are oriented cw.",
	"Method": "List getCoordinatesOfEnvelope(){\r\n    Envelope env = getEnvelope();\r\n    List coords = new ArrayList();\r\n    coords.add(new Coordinate(env.getMinX(), env.getMinY()));\r\n    coords.add(new Coordinate(env.getMinX(), env.getMaxY()));\r\n    coords.add(new Coordinate(env.getMaxX(), env.getMaxY()));\r\n    coords.add(new Coordinate(env.getMaxX(), env.getMinY()));\r\n    coords.add(new Coordinate(env.getMinX(), env.getMinY()));\r\n    return coords;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.RayCrossingCounter.isOnSegment",
	"Comment": "reports whether the point lies exactly on one of the supplied segments.this method may be called at any time as segments are processed.if the result of this method is true, no further segments need be supplied, since the resultwill never change again.",
	"Method": "boolean isOnSegment(){\r\n    return isPointOnSegment;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.relate.RelateComputer.labelIsolatedEdge",
	"Comment": "label an isolated edge of a graph with its relationship to the target geometry.if the target has dim 2 or 1, the edge can either be in the interior or the exterior.if the target has dim 0, the edge must be in the exterior",
	"Method": "void labelIsolatedEdge(Edge e,int targetIndex,Geometry target){\r\n    if (target.getDimension() > 0) {\r\n        int loc = ptLocator.locate(e.getCoordinate(), target);\r\n        e.getLabel().setAllLocations(targetIndex, loc);\r\n    } else {\r\n        e.getLabel().setAllLocations(targetIndex, Location.EXTERIOR);\r\n    }\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.entities.ISnowflake.getId",
	"Comment": "the snowflake id of this entity. this is unique to every entity and will never change.",
	"Method": "String getId(){\r\n    return Long.toUnsignedString(getIdLong());\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testrunner.GuiUtil.invokeAndWait",
	"Comment": "runs r in the event dispatch thread, which may be the current thread.waits for r to finish before returning.",
	"Method": "void invokeAndWait(Runnable r){\r\n    if (SwingUtilities.isEventDispatchThread()) {\r\n        r.run();\r\n    } else {\r\n        SwingUtilities.invokeAndWait(r);\r\n    }\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.syntax.SQLToken.getCharBegin",
	"Comment": "get the offset into the input in characters at which this token started",
	"Method": "int getCharBegin(){\r\n    return this.charBegin;\r\n}"
}, {
	"Path": "org.locationtech.jts.util.Debug.addWatch",
	"Comment": "adds an object to be watched.a watched object can be printed out at any time.currently only supports one watched object at a time.",
	"Method": "void addWatch(Object obj){\r\n    debug.instanceAddWatch(obj);\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.startBinding",
	"Comment": "refreshes the shortcuts shown on the workspace.implementation of the method from launchermodel.callbacks.",
	"Method": "void startBinding(){\r\n    setWorkspaceLoading(true);\r\n    mBindOnResumeCallbacks.clear();\r\n    mWorkspace.clearDropTargets();\r\n    mWorkspace.removeAllWorkspaceScreens();\r\n    mWidgetsToAdvance.clear();\r\n    if (mHotseat != null) {\r\n        mHotseat.resetLayout();\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.Polygonizer.getDangles",
	"Comment": "gets the list of dangling lines found during polygonization.",
	"Method": "Collection getDangles(){\r\n    polygonize();\r\n    return dangles;\r\n}"
}, {
	"Path": "org.locationtech.jts.index.kdtree.KdNode.getCount",
	"Comment": "returns the number of inserted points that are coincident at this location.",
	"Method": "int getCount(){\r\n    return count;\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.onInteractionEnd",
	"Comment": "called when the user stops interacting with the launcher.this implies that the user is now on the homescreen and is not doing housekeeping.",
	"Method": "void onInteractionEnd(){\r\n    if (mLauncherCallbacks != null) {\r\n        mLauncherCallbacks.onInteractionEnd();\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.RayCrossingCounter.isPointInPolygon",
	"Comment": "tests whether the point lies in or on \tthe ring, polygon\tor multipolygon from which the processed segments were provided.\tthis method only determines the correct location \tif all relevant segments must have been processed.",
	"Method": "boolean isPointInPolygon(){\r\n    return getLocation() != Location.EXTERIOR;\r\n}"
}, {
	"Path": "com.android.gallery3d.glrenderer.BasicTexture.setSize",
	"Comment": "sets the content size of this texture. in opengl, the actual texturesize must be of power of 2, the size of the content may be smaller.",
	"Method": "void setSize(int width,int height){\r\n    mWidth = width;\r\n    mHeight = height;\r\n    mTextureWidth = width > 0 ? Utils.nextPowerOf2(width) : 0;\r\n    mTextureHeight = height > 0 ? Utils.nextPowerOf2(height) : 0;\r\n    if (mTextureWidth > MAX_TEXTURE_SIZE || mTextureHeight > MAX_TEXTURE_SIZE) {\r\n        Log.w(TAG, String.format(\"texture is too large: %d x %d\", mTextureWidth, mTextureHeight), new Exception());\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.generator.MultiGenerator.create",
	"Comment": "creates a geometry collection representing the set of child geometries created.",
	"Method": "Geometry create(){\r\n    if (generator == null)\r\n        throw new NullPointerException(\"Missing child generator\");\r\n    if (numberGeometries < 1)\r\n        throw new IllegalStateException(\"Too few child geoms to create\");\r\n    ArrayList geoms = new ArrayList(numberGeometries);\r\n    GridGenerator grid = GeometryGenerator.createGridGenerator();\r\n    grid.setBoundingBox(boundingBox);\r\n    grid.setGeometryFactory(geometryFactory);\r\n    switch(generationAlgorithm) {\r\n        case BOX:\r\n            int nrow = (int) Math.sqrt(numberGeometries);\r\n            int ncol = numberGeometries / nrow;\r\n            grid.setNumberRows(nrow);\r\n            grid.setNumberColumns(ncol);\r\n            break;\r\n        case VERT:\r\n            grid.setNumberRows(1);\r\n            grid.setNumberColumns(numberGeometries);\r\n            break;\r\n        case HORZ:\r\n            grid.setNumberRows(numberGeometries);\r\n            grid.setNumberColumns(1);\r\n            break;\r\n        default:\r\n            throw new IllegalStateException(\"Invalid Alg. Specified\");\r\n    }\r\n    while (grid.canCreate()) {\r\n        generator.setBoundingBox(grid.createEnv());\r\n        geoms.add(generator.create());\r\n    }\r\n    if (generator instanceof PointGenerator) {\r\n        return geometryFactory.createMultiPoint((Point[]) geoms.toArray(new Point[numberGeometries]));\r\n    } else {\r\n        if (generator instanceof LineStringGenerator) {\r\n            return geometryFactory.createMultiLineString((LineString[]) geoms.toArray(new LineString[numberGeometries]));\r\n        } else {\r\n            if (generator instanceof PolygonGenerator) {\r\n                return geometryFactory.createMultiPolygon((Polygon[]) geoms.toArray(new Polygon[numberGeometries]));\r\n            } else {\r\n                return geometryFactory.createGeometryCollection((Geometry[]) geoms.toArray(new Geometry[numberGeometries]));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.importexport.DImportKeyPairOpenSsl.getPrivateKey",
	"Comment": "get the private part of the key pair chosen by the user for import.",
	"Method": "PrivateKey getPrivateKey(){\r\n    return privateKey;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.overlay.snap.GeometrySnapper.computeOverlaySnapTolerance",
	"Comment": "estimates the snap tolerance for a geometry, taking into account its precision model.",
	"Method": "double computeOverlaySnapTolerance(Geometry g,double computeOverlaySnapTolerance,Geometry g0,Geometry g1){\r\n    return Math.min(computeOverlaySnapTolerance(g0), computeOverlaySnapTolerance(g1));\r\n}"
}, {
	"Path": "org.kse.gui.actions.KeyStoreExplorerAction.unlockEntry",
	"Comment": "unlock a key or key pair entry. updates the keystore history with the\tpassword.",
	"Method": "Password unlockEntry(String alias,KeyStoreState state){\r\n    try {\r\n        KeyStore keyStore = state.getKeyStore();\r\n        DGetPassword dGetPassword = new DGetPassword(frame, MessageFormat.format(res.getString(\"KeyStoreExplorerAction.UnlockEntry.Title\"), alias));\r\n        dGetPassword.setLocationRelativeTo(frame);\r\n        dGetPassword.setVisible(true);\r\n        Password password = dGetPassword.getPassword();\r\n        if (password == null) {\r\n            return null;\r\n        }\r\n        keyStore.getKey(alias, password.toCharArray());\r\n        state.setEntryPassword(alias, password);\r\n        kseFrame.updateControls(true);\r\n        return password;\r\n    } catch (GeneralSecurityException ex) {\r\n        String problemStr = MessageFormat.format(res.getString(\"KeyStoreExplorerAction.NoUnlockEntry.Problem\"), alias);\r\n        String[] causes = new String[] { res.getString(\"KeyStoreExplorerAction.PasswordIncorrectEntry.Cause\") };\r\n        Problem problem = new Problem(problemStr, causes, ex);\r\n        DProblem dProblem = new DProblem(frame, res.getString(\"KeyStoreExplorerAction.ProblemUnlockingEntry.Title\"), problem);\r\n        dProblem.setLocationRelativeTo(frame);\r\n        dProblem.setVisible(true);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.distance.IndexedFacetDistance.getDistance",
	"Comment": "computes the distance from the base geometry to the given geometry.",
	"Method": "double getDistance(Geometry g){\r\n    STRtree tree2 = FacetSequenceTreeBuilder.build(g);\r\n    Object[] obj = cachedTree.nearestNeighbour(tree2, new FacetSequenceDistance());\r\n    return facetDistance(obj);\r\n}"
}, {
	"Path": "org.locationtech.jts.linearref.LinearLocation.getSegmentLength",
	"Comment": "gets the length of the segment in the givengeometry containing this location.",
	"Method": "double getSegmentLength(Geometry linearGeom){\r\n    LineString lineComp = (LineString) linearGeom.getGeometryN(componentIndex);\r\n    int segIndex = segmentIndex;\r\n    if (segmentIndex >= lineComp.getNumPoints() - 1)\r\n        segIndex = lineComp.getNumPoints() - 2;\r\n    Coordinate p0 = lineComp.getCoordinateN(segIndex);\r\n    Coordinate p1 = lineComp.getCoordinateN(segIndex + 1);\r\n    return p0.distance(p1);\r\n}"
}, {
	"Path": "org.joda.money.format.MoneyFormatterBuilder.append",
	"Comment": "appends the printers and parsers from the specified formatter to this builder.if the specified formatter cannot print, then the the output of thisbuilder will be unable to print. if the specified formatter cannot parse,then the output of this builder will be unable to parse.",
	"Method": "MoneyFormatterBuilder append(MoneyFormatter formatter,MoneyFormatterBuilder append,MoneyPrinter printer,MoneyParser parser){\r\n    return appendInternal(printer, parser);\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.Colorer.run",
	"Comment": "the colorer runs forever and may sleep for long periods of time. it\tshould be interrupted every time there is something for it to do.",
	"Method": "void run(){\r\n    while (this.document.get() != null) {\r\n        try {\r\n            RecolorEvent re = new RecolorEvent(0, 0);\r\n            synchronized (this.eventsLock) {\r\n                while (this.events.isEmpty() && this.document.get() != null) {\r\n                    this.eventsLock.wait(1000);\r\n                }\r\n                if (!this.events.isEmpty()) {\r\n                    re = this.events.removeFirst();\r\n                }\r\n            }\r\n            this.processEvent(re.getPosition(), re.getAdjustment());\r\n            Thread.sleep(100);\r\n        } catch (InterruptedException e) {\r\n            LOGGER.error(e, e);\r\n            Thread.currentThread().interrupt();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.findOrMakeFolder",
	"Comment": "return an existing folderinfo object if we have encountered this id previously,or make a new one.",
	"Method": "FolderInfo findOrMakeFolder(LongArrayMap<FolderInfo> folders,long id){\r\n    FolderInfo folderInfo = folders.get(id);\r\n    if (folderInfo == null) {\r\n        folderInfo = new FolderInfo();\r\n        folders.put(id, folderInfo);\r\n    }\r\n    return folderInfo;\r\n}"
}, {
	"Path": "org.kse.utilities.history.KeyStoreState.createBasisForNextState",
	"Comment": "create the basis for the next state based on this one. makes a copy of\tthe current state excluding its position in the history.",
	"Method": "KeyStoreState createBasisForNextState(HistoryAction action){\r\n    KeyStoreState copy = new KeyStoreState();\r\n    copy.history = this.history;\r\n    copy.keyStore = KeyStoreUtil.copy(this.keyStore);\r\n    if (this.password != null) {\r\n        copy.password = new Password(this.password);\r\n    }\r\n    HashMap<String, Password> keyPairPasswordsCopy = new HashMap();\r\n    for (String alias : entryPasswords.keySet()) {\r\n        keyPairPasswordsCopy.put(alias, new Password(entryPasswords.get(alias)));\r\n    }\r\n    copy.entryPasswords = keyPairPasswordsCopy;\r\n    copy.action = action;\r\n    return copy;\r\n}"
}, {
	"Path": "org.jpmml.evaluator.TargetField.getCategories",
	"Comment": "returns the range of categories for this categorical or ordinal field.",
	"Method": "List<String> getCategories(){\r\n    List<String> categories = FieldUtil.getCategories(getField());\r\n    if (categories != null && !categories.isEmpty()) {\r\n        return categories;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.relate.RelateComputer.computeDisjointIM",
	"Comment": "if the geometries are disjoint, we need to enter their dimension andboundary dimension in the ext rows in the im",
	"Method": "void computeDisjointIM(IntersectionMatrix im){\r\n    Geometry ga = arg[0].getGeometry();\r\n    if (!ga.isEmpty()) {\r\n        im.set(Location.INTERIOR, Location.EXTERIOR, ga.getDimension());\r\n        im.set(Location.BOUNDARY, Location.EXTERIOR, ga.getBoundaryDimension());\r\n    }\r\n    Geometry gb = arg[1].getGeometry();\r\n    if (!gb.isEmpty()) {\r\n        im.set(Location.EXTERIOR, Location.INTERIOR, gb.getDimension());\r\n        im.set(Location.EXTERIOR, Location.BOUNDARY, gb.getBoundaryDimension());\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.relate.EdgeEndBundle.updateIM",
	"Comment": "update the im with the contribution for the computed label for the edgestubs.",
	"Method": "void updateIM(IntersectionMatrix im){\r\n    Edge.updateIM(label, im);\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.extensions.ExtensionsTableHeadRend.getTableCellRendererComponent",
	"Comment": "returns the rendered header cell for the supplied value and column.",
	"Method": "Component getTableCellRendererComponent(JTable jtExtensions,Object value,boolean isSelected,boolean hasFocus,int row,int col){\r\n    Component c = delegate.getTableCellRendererComponent(jtExtensions, value, isSelected, hasFocus, row, col);\r\n    if (c instanceof JLabel) {\r\n        JLabel header = (JLabel) c;\r\n        if (col == 0) {\r\n            header.setText(\"\");\r\n            ImageIcon icon = new ImageIcon(getClass().getResource(res.getString(\"ExtensionsTableHeadRend.CriticalColumn.image\")));\r\n            header.setIcon(icon);\r\n            header.setHorizontalAlignment(CENTER);\r\n            header.setVerticalAlignment(CENTER);\r\n            header.setToolTipText(res.getString(\"ExtensionsTableHeadRend.CriticalColumn.tooltip\"));\r\n        } else {\r\n            header.setText(value.toString());\r\n            header.setHorizontalAlignment(LEFT);\r\n            if (col == 1) {\r\n                header.setToolTipText(res.getString(\"ExtensionsTableHeadRend.NameColumn.tooltip\"));\r\n            } else {\r\n                header.setToolTipText(res.getString(\"ExtensionsTableHeadRend.OidColumn.tooltip\"));\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.NonEncroachingSplitPointFinder.findSplitPoint",
	"Comment": "a basic strategy for finding split points when nothing extra is known about the geometry ofthe situation.",
	"Method": "Coordinate findSplitPoint(Segment seg,Coordinate encroachPt){\r\n    LineSegment lineSeg = seg.getLineSegment();\r\n    double segLen = lineSeg.getLength();\r\n    double midPtLen = segLen / 2;\r\n    SplitSegment splitSeg = new SplitSegment(lineSeg);\r\n    Coordinate projPt = projectedSplitPoint(seg, encroachPt);\r\n    double nonEncroachDiam = projPt.distance(encroachPt) * 2 * 0.8;\r\n    double maxSplitLen = nonEncroachDiam;\r\n    if (maxSplitLen > midPtLen) {\r\n        maxSplitLen = midPtLen;\r\n    }\r\n    splitSeg.setMinimumLength(maxSplitLen);\r\n    splitSeg.splitAt(projPt);\r\n    return splitSeg.getSplitPoint();\r\n}"
}, {
	"Path": "com.jsql.view.swing.dialog.OrderedProperties.copyOf",
	"Comment": "creates a new instance that will have both the same property entries andthe same behavior as the given source.note that the source instance and the copy instance will share the samecomparator instance if a custom ordering had been configured on the source.",
	"Method": "OrderedProperties copyOf(OrderedProperties source){\r\n    OrderedPropertiesBuilder builder = new OrderedPropertiesBuilder();\r\n    builder.withSuppressDateInComment(source.suppressDate);\r\n    if (source.properties instanceof TreeMap) {\r\n        builder.withOrdering(((TreeMap<String, String>) source.properties).comparator());\r\n    }\r\n    OrderedProperties result = builder.build();\r\n    for (Map.Entry<String, String> entry : source.entrySet()) {\r\n        result.setProperty(entry.getKey(), entry.getValue());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.android.launcher3.allapps.AlphabeticalAppsList.getFastScrollerSections",
	"Comment": "returns fast scroller sections of all the current filtered applications.",
	"Method": "List<FastScrollSectionInfo> getFastScrollerSections(){\r\n    return mFastScrollerSections;\r\n}"
}, {
	"Path": "org.jpmml.evaluator.FieldValue.compareTo",
	"Comment": "calculates the order between this value and the reference value.",
	"Method": "int compareTo(HasValue<?> hasValue,int compareTo,HasParsedValue<?> hasParsedValue,int compareTo,FieldValue that){\r\n    if ((this.getOpType() != that.getOpType()) || (this.getDataType() != that.getDataType())) {\r\n        throw new ClassCastException();\r\n    }\r\n    return compareToValue(that);\r\n}"
}, {
	"Path": "org.locationtech.jts.planargraph.algorithm.ConnectedSubgraphFinder.addReachable",
	"Comment": "adds all nodes and edges reachable from this node to the subgraph.uses an explicit stack to avoid a large depth of recursion.",
	"Method": "void addReachable(Node startNode,Subgraph subgraph){\r\n    Stack nodeStack = new Stack();\r\n    nodeStack.add(startNode);\r\n    while (!nodeStack.empty()) {\r\n        Node node = (Node) nodeStack.pop();\r\n        addEdges(node, nodeStack, subgraph);\r\n    }\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.requests.RequestFuture.anyOf",
	"Comment": "returns a new completablefuture that is completed when any ofthe given futures complete, with the same result.otherwise, if it completed exceptionally, the returnedcompletablefuture also does so, with a completionexceptionholding this exception as its cause.if no futuresare provided, returns an incomplete completablefuture.",
	"Method": "CompletableFuture<Object> anyOf(RequestFuture<?> cfs,CompletableFuture<Object> anyOf,Collection<F> cfs){\r\n    Checks.notNull(cfs, \"Collection\");\r\n    CompletableFuture[] all = cfs.stream().map(CompletableFuture.class::cast).toArray(CompletableFuture[]::new);\r\n    return CompletableFuture.anyOf(all);\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdge.rot",
	"Comment": "gets the dual of this edge, directed from its right to its left.",
	"Method": "QuadEdge rot(){\r\n    return rot;\r\n}"
}, {
	"Path": "org.joda.money.Money.dividedBy",
	"Comment": "returns a copy of this monetary value divided by the specified value.this takes this amount and divides it by the specified value, roundingthe result is rounded as specified.this instance is immutable and unaffected by this method.",
	"Method": "Money dividedBy(BigDecimal valueToDivideBy,RoundingMode roundingMode,Money dividedBy,double valueToDivideBy,RoundingMode roundingMode,Money dividedBy,long valueToDivideBy,RoundingMode roundingMode){\r\n    return with(money.dividedBy(valueToDivideBy, roundingMode));\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testrunner.GeometryOperationLoader.createGeometryOperation",
	"Comment": "if anything bad happens while creating the geometry operation, just print a message and fail",
	"Method": "GeometryOperation createGeometryOperation(ClassLoader classLoader,String geomOpClassname){\r\n    Class geomOpClass = null;\r\n    try {\r\n        geomOpClass = classLoader.loadClass(geomOpClassname);\r\n    } catch (ClassNotFoundException ex) {\r\n        System.out.println(\"ERROR: Class not found - \" + geomOpClassname);\r\n        return null;\r\n    }\r\n    try {\r\n        GeometryOperation geometryOp = (GeometryOperation) geomOpClass.newInstance();\r\n        return geometryOp;\r\n    } catch (Exception ex) {\r\n        System.out.println(ex.getMessage());\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.index.intervalrtree.SortedPackedIntervalRTree.query",
	"Comment": "search for intervals in the index which intersect the given closed intervaland apply the visitor to them.",
	"Method": "void query(double min,double max,ItemVisitor visitor){\r\n    init();\r\n    root.query(min, max, visitor);\r\n}"
}, {
	"Path": "org.locationtech.jts.index.bintree.Key.computeKey",
	"Comment": "return a square envelope containing the argument envelope,whose extent is a power of two and which is based at a power of 2",
	"Method": "void computeKey(Interval itemInterval){\r\n    level = computeLevel(itemInterval);\r\n    interval = new Interval();\r\n    computeInterval(level, itemInterval);\r\n    while (!interval.contains(itemInterval)) {\r\n        level += 1;\r\n        computeInterval(level, itemInterval);\r\n    }\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.entities.MessageReaction.isSelf",
	"Comment": "whether the currently logged in account has reacted with this reaction",
	"Method": "boolean isSelf(){\r\n    return self;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.EdgeRing.ptNotInList",
	"Comment": "finds a point in a list of points which is not contained in another list of points",
	"Method": "Coordinate ptNotInList(Coordinate[] testPts,Coordinate[] pts){\r\n    for (int i = 0; i < testPts.length; i++) {\r\n        Coordinate testPt = testPts[i];\r\n        if (!isInList(testPt, pts))\r\n            return testPt;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.zeromq.ZMsg.duplicate",
	"Comment": "creates copy of this zmsg. also duplicates all frame content.",
	"Method": "ZMsg duplicate(){\r\n    ZMsg msg = new ZMsg();\r\n    for (ZFrame f : frames) msg.add(f.duplicate());\r\n    return msg;\r\n}"
}, {
	"Path": "org.kse.gui.KseRestart.restart",
	"Comment": "restart keystore explorer in the same manner in which it was started.",
	"Method": "void restart(){\r\n    if (System.getProperty(KSE_EXE) != null) {\r\n        restartAsKseExe();\r\n    } else if (System.getProperty(KSE_APP) != null) {\r\n        restartAsKseApp();\r\n    } else if (System.getProperty(JAVA_CLASS_PATH).equals(KSE_JAR)) {\r\n        restartAsKseJar();\r\n    } else {\r\n        restartAsKseClass();\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.CGAlgorithms.signedArea",
	"Comment": "computes the signed area for a ring. the signed area is positive if thering is oriented cw, negative if the ring is oriented ccw, and zero if thering is degenerate or flat.",
	"Method": "double signedArea(Coordinate[] ring,double signedArea,CoordinateSequence ring){\r\n    int n = ring.size();\r\n    if (n < 3)\r\n        return 0.0;\r\n    Coordinate p0 = new Coordinate();\r\n    Coordinate p1 = new Coordinate();\r\n    Coordinate p2 = new Coordinate();\r\n    ring.getCoordinate(0, p1);\r\n    ring.getCoordinate(1, p2);\r\n    double x0 = p1.x;\r\n    p2.x -= x0;\r\n    double sum = 0.0;\r\n    for (int i = 1; i < n - 1; i++) {\r\n        p0.y = p1.y;\r\n        p1.x = p2.x;\r\n        p1.y = p2.y;\r\n        ring.getCoordinate(i + 1, p2);\r\n        p2.x -= x0;\r\n        sum += p1.x * (p0.y - p2.y);\r\n    }\r\n    return sum / 2.0;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.validate.BufferResultValidator.isValidMsg",
	"Comment": "checks whether the geometry buffer is valid, and returns an error message if not.",
	"Method": "String isValidMsg(Geometry g,double distance,Geometry result){\r\n    BufferResultValidator validator = new BufferResultValidator(g, distance, result);\r\n    if (!validator.isValid())\r\n        return validator.getErrorMessage();\r\n    return null;\r\n}"
}, {
	"Path": "org.joda.money.BigMoney.negated",
	"Comment": "returns a copy of this monetary value with the amount negated.this instance is immutable and unaffected by this method.",
	"Method": "BigMoney negated(){\r\n    if (isZero()) {\r\n        return this;\r\n    }\r\n    return BigMoney.of(currency, amount.negate());\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.BufferBuilder.createEmptyResultGeometry",
	"Comment": "gets the standard result for an empty buffer.since buffer always returns a polygonal result,this is chosen to be an empty polygon.",
	"Method": "Geometry createEmptyResultGeometry(){\r\n    Geometry emptyGeom = geomFact.createPolygon();\r\n    return emptyGeom;\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.syntax.SQLToken.isReservedWord",
	"Comment": "checks this token to see if it is a reserved word. reserved words areexplained in javalanguage specification.",
	"Method": "boolean isReservedWord(){\r\n    return (this.id >> 8) == 0x1;\r\n}"
}, {
	"Path": "org.kse.gui.TableColumnAdjuster.restoreColumns",
	"Comment": "restore the widths of the columns in the table to its previous width",
	"Method": "void restoreColumns(){\r\n    TableColumnModel tcm = table.getColumnModel();\r\n    for (int i = 0; i < tcm.getColumnCount(); i++) {\r\n        restoreColumn(i);\r\n    }\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.product.Product5.rotateL5",
	"Comment": "rotate the first five values of this product one slot to the left.",
	"Method": "Product5<_2, _3, _4, _5, _1> rotateL5(){\r\n    return into((_1, _2, _3, _4, _5) -> product(_2, _3, _4, _5, _1));\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.syntax.SQLLexer.yytext",
	"Comment": "returns the text matched by the current regular expression.",
	"Method": "String yytext(){\r\n    return new String(this.zzBuffer, this.zzStartRead, this.zzMarkedPos - this.zzStartRead);\r\n}"
}, {
	"Path": "org.locationtech.jts.io.gml2.GMLWriter.writeLineString",
	"Comment": "1195123.37289257,381985.763974674 1195120.22369473,381964.660533343 1195118.14929823,381942.597718511",
	"Method": "void writeLineString(LineString ls,Writer writer,int level){\r\n    startLine(level, writer);\r\n    startGeomTag(GMLConstants.GML_LINESTRING, ls, writer);\r\n    write(ls.getCoordinates(), writer, level + 1);\r\n    startLine(level, writer);\r\n    endGeomTag(GMLConstants.GML_LINESTRING, writer);\r\n}"
}, {
	"Path": "org.locationtech.jts.precision.GeometryPrecisionReducer.reducePointwise",
	"Comment": "convenience method for doing pointwise precision reduction on a single geometry,\twith collapses removed and keeping the geometry precision model the same,but not preserving valid polygonal topology.",
	"Method": "Geometry reducePointwise(Geometry g,PrecisionModel precModel,Geometry reducePointwise,Geometry geom){\r\n    GeometryEditor geomEdit;\r\n    if (changePrecisionModel) {\r\n        GeometryFactory newFactory = createFactory(geom.getFactory(), targetPM);\r\n        geomEdit = new GeometryEditor(newFactory);\r\n    } else\r\n        geomEdit = new GeometryEditor();\r\n    boolean finalRemoveCollapsed = removeCollapsed;\r\n    if (geom.getDimension() >= 2)\r\n        finalRemoveCollapsed = true;\r\n    Geometry reduceGeom = geomEdit.edit(geom, new PrecisionReducerCoordinateOperation(targetPM, finalRemoveCollapsed));\r\n    return reduceGeom;\r\n}"
}, {
	"Path": "org.locationtech.jts.index.strtree.BoundablePair.getDistance",
	"Comment": "gets the minimum possible distance between the boundables inthis pair. if the members are both items, this will be theexact distance between them.otherwise, this distance will be a lower bound on the distances between the items in the members.",
	"Method": "double getDistance(){\r\n    return distance;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.PointLocation.isInRing",
	"Comment": "tests whether a point lies inside or on a ring. the ring may be oriented ineither direction. a point lying exactly on the ring boundary is consideredto be inside the ring.this method does not first check the point against the envelope ofthe ring.",
	"Method": "boolean isInRing(Coordinate p,Coordinate[] ring){\r\n    return PointLocation.locateInRing(p, ring) != Location.EXTERIOR;\r\n}"
}, {
	"Path": "org.locationtech.jts.index.kdtree.KdTree.findBestMatchNode",
	"Comment": "finds the node in the tree which is the best match for a pointbeing inserted.the match is made deterministic by returning the lowest of any nodes whichlie the same distance from the point.there may be no match if the point is not within the distance tolerance of anyexisting node.",
	"Method": "KdNode findBestMatchNode(Coordinate p){\r\n    BestMatchVisitor visitor = new BestMatchVisitor(p, tolerance);\r\n    query(visitor.queryEnvelope(), visitor);\r\n    return visitor.getNode();\r\n}"
}, {
	"Path": "com.jdon.model.query.PageIteratorSolver.getPageIterator",
	"Comment": "same as getdatas the parameters sort is different from the getdatas\tmethod",
	"Method": "PageIterator getPageIterator(String sqlqueryAllCount,String sqlquery,String queryParam,int start,int count,PageIterator getPageIterator,String sqlqueryAllCount,String sqlquery,Collection queryParams,int startIndex,int count){\r\n    Debug.logVerbose(\"[JdonFramework]enter getPageIterator .. start= \" + startIndex + \" count=\" + count, module);\r\n    if (queryParams == null) {\r\n        Debug.logError(\" the parameters collection is null\", module);\r\n        return new PageIterator();\r\n    }\r\n    if ((count > blockStrategy.getBlockLength()) || (count <= 0)) {\r\n        count = blockStrategy.getBlockLength();\r\n    }\r\n    Block currentBlock = getBlock(sqlquery, queryParams, startIndex, count);\r\n    if (currentBlock == null) {\r\n        return new PageIterator();\r\n    }\r\n    startIndex = currentBlock.getStart();\r\n    int endIndex = startIndex + currentBlock.getCount();\r\n    Object[] keys = currentBlock.getList().toArray();\r\n    int allCount = getDatasAllCount(queryParams, sqlqueryAllCount);\r\n    Debug.logVerbose(\"[JdonFramework]currentBlock: startIndex=\" + startIndex + \" endIndex=\" + endIndex + \" keys length=\" + keys.length, module);\r\n    if (endIndex < startIndex) {\r\n        Debug.logWarning(\"WARNNING : endIndex < startIndex\", module);\r\n        return new PageIterator();\r\n    } else {\r\n        return new PageIterator(allCount, keys, startIndex, endIndex, count);\r\n    }\r\n}"
}, {
	"Path": "org.joda.money.format.MoneyAmountStyle.isForcedDecimalPoint",
	"Comment": "gets whether to always use the decimal point, even if there is no fraction.",
	"Method": "boolean isForcedDecimalPoint(){\r\n    return forceDecimalPoint;\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.Edge.getDepthDelta",
	"Comment": "the depthdelta is the change in depth as an edge is crossed from r to l",
	"Method": "int getDepthDelta(){\r\n    return depthDelta;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.DelaunayTriangulationBuilder.setTolerance",
	"Comment": "sets the snapping tolerance which will be used\tto improved the robustness of the triangulation computation.\ta tolerance of 0.0 specifies that no snapping will take place.",
	"Method": "void setTolerance(double tolerance){\r\n    this.tolerance = tolerance;\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifParser.skipRemainingTagsInCurrentIfd",
	"Comment": "skips the tags area of current ifd, if the parser is not in the tag area,nothing will happen.",
	"Method": "void skipRemainingTagsInCurrentIfd(){\r\n    int endOfTags = mIfdStartOffset + OFFSET_SIZE + TAG_SIZE * mNumOfTagInIfd;\r\n    int offset = mTiffStream.getReadByteCount();\r\n    if (offset > endOfTags) {\r\n        return;\r\n    }\r\n    if (mNeedToParseOffsetsInCurrentIfd) {\r\n        while (offset < endOfTags) {\r\n            mTag = readTag();\r\n            offset += TAG_SIZE;\r\n            if (mTag == null) {\r\n                continue;\r\n            }\r\n            checkOffsetOrImageTag(mTag);\r\n        }\r\n    } else {\r\n        skipTo(endOfTags);\r\n    }\r\n    long ifdOffset = readUnsignedLong();\r\n    if (mIfdType == IfdId.TYPE_IFD_0 && (isIfdRequested(IfdId.TYPE_IFD_1) || isThumbnailRequested())) {\r\n        if (ifdOffset > 0) {\r\n            registerIfd(IfdId.TYPE_IFD_1, ifdOffset);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.edgegraph.HalfEdge.find",
	"Comment": "finds the edge starting at the origin of this edgewith the given dest vertex,if any.",
	"Method": "HalfEdge find(Coordinate dest){\r\n    HalfEdge oNext = this;\r\n    do {\r\n        if (oNext == null)\r\n            return null;\r\n        if (oNext.dest().equals2D(dest))\r\n            return oNext;\r\n        oNext = oNext.oNext();\r\n    } while (oNext != this);\r\n    return null;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.GeometryCollection.getCoordinates",
	"Comment": "collects all coordinates of all subgeometries into an array.note that while changes to the coordinate objects themselvesmay modify the geometries in place, the returned array as suchis only a temporary container which is not synchronized back.",
	"Method": "Coordinate[] getCoordinates(){\r\n    Coordinate[] coordinates = new Coordinate[getNumPoints()];\r\n    int k = -1;\r\n    for (int i = 0; i < geometries.length; i++) {\r\n        Coordinate[] childCoordinates = geometries[i].getCoordinates();\r\n        for (int j = 0; j < childCoordinates.length; j++) {\r\n            k++;\r\n            coordinates[k] = childCoordinates[j];\r\n        }\r\n    }\r\n    return coordinates;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.PolygonizeDirectedEdge.getNext",
	"Comment": "returns the next directed edge in the edgering that this directed edge is a member",
	"Method": "PolygonizeDirectedEdge getNext(){\r\n    return next;\r\n}"
}, {
	"Path": "com.jdon.util.jdom.DataUnformatFilter.startDocument",
	"Comment": "filter a start document event.\treset state and pass the event on for further processing.",
	"Method": "void startDocument(){\r\n    reset();\r\n    super.startDocument();\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.utils.tuple.Pair.of",
	"Comment": "obtains an immutable pair of from two objects inferring the generic types.this factory allows the pair to be created using inference toobtain the generic types.",
	"Method": "Pair<L, R> of(L left,R right){\r\n    return new ImmutablePair(left, right);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.distance3d.Distance3DOp.computeMinDistancePolygonRings",
	"Comment": "compute distance between a polygon and the rings of another.",
	"Method": "void computeMinDistancePolygonRings(PlanarPolygon3D poly,Polygon ringPoly,boolean flip){\r\n    computeMinDistancePolygonLine(poly, ringPoly.getExteriorRing(), flip);\r\n    if (isDone)\r\n        return;\r\n    int nHole = ringPoly.getNumInteriorRing();\r\n    for (int i = 0; i < nHole; i++) {\r\n        computeMinDistancePolygonLine(poly, ringPoly.getInteriorRingN(i), flip);\r\n        if (isDone)\r\n            return;\r\n    }\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.dsl.internal.NamespaceVisitFromServerGetWatchDeleteRecreateWaitApplicableListImpl.checkReady",
	"Comment": "waits until the latch reaches to zero and then checks if the expected result",
	"Method": "boolean checkReady(CountDownLatch latch,int expected,AtomicInteger actual,long amount,TimeUnit timeUnit){\r\n    try {\r\n        if (latch.await(amount, timeUnit)) {\r\n            return actual.intValue() == expected;\r\n        }\r\n        return false;\r\n    } catch (InterruptedException e) {\r\n        Thread.currentThread().interrupt();\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.jdon.util.MultiHashMap.put",
	"Comment": "associates the specified value with the specified key and subkey in this map.if the map previously contained a mapping for this key and subkey , the old value is replaced.",
	"Method": "Object put(Object key,Object subKey,Object value){\r\n    HashMap a = (HashMap) super.get(key);\r\n    if (a == null) {\r\n        a = new HashMap();\r\n        super.put(key, a);\r\n    }\r\n    return a.put(subKey, value);\r\n}"
}, {
	"Path": "com.jsql.view.swing.table.AdjusterTableColumn.restoreColumns",
	"Comment": "restore the widths of the columns in the table to its previous width",
	"Method": "void restoreColumns(){\r\n    TableColumnModel tcm = this.tableAdjust.getColumnModel();\r\n    for (int i = 0; i < tcm.getColumnCount(); i++) {\r\n        this.restoreColumn(i);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.DirectedEdgeStar.mergeSymLabels",
	"Comment": "for each diredge in the star,merge the label from the sym diredge into the label",
	"Method": "void mergeSymLabels(){\r\n    for (Iterator it = iterator(); it.hasNext(); ) {\r\n        DirectedEdge de = (DirectedEdge) it.next();\r\n        Label label = de.getLabel();\r\n        label.merge(de.getSym().getLabel());\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DD.equals",
	"Comment": "tests whether this value is equal to another doubledouble value.",
	"Method": "boolean equals(DD y){\r\n    return hi == y.hi && lo == y.lo;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct7.diverge",
	"Comment": "diverge this coproduct by introducing another possible type that it could represent.",
	"Method": "CoProduct8<A, B, C, D, E, F, G, H, ? extends CoProduct8<A, B, C, D, E, F, G, H, ?>> diverge(){\r\n    return new CoProduct8<A, B, C, D, E, F, G, H, CoProduct8<A, B, C, D, E, F, G, H, ?>>() {\r\n        @Override\r\n        public <R> R match(Function<? super A, ? extends R> aFn, Function<? super B, ? extends R> bFn, Function<? super C, ? extends R> cFn, Function<? super D, ? extends R> dFn, Function<? super E, ? extends R> eFn, Function<? super F, ? extends R> fFn, Function<? super G, ? extends R> gFn, Function<? super H, ? extends R> hFn) {\r\n            return CoProduct7.this.match(aFn, bFn, cFn, dFn, eFn, fFn, gFn);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct7.diverge",
	"Comment": "diverge this coproduct by introducing another possible type that it could represent.",
	"Method": "CoProduct8<A, B, C, D, E, F, G, H, ? extends CoProduct8<A, B, C, D, E, F, G, H, ?>> diverge(){\r\n    return CoProduct7.this.match(aFn, bFn, cFn, dFn, eFn, fFn, gFn);\r\n}"
}, {
	"Path": "com.android.launcher3.util.ManagedProfileHeuristic.finalizeWorkFolder",
	"Comment": "adds and binds shortcuts marked to be added to the work folder.",
	"Method": "void finalizeWorkFolder(){\r\n    if (mWorkFolderApps.isEmpty()) {\r\n        return;\r\n    }\r\n    Collections.sort(mWorkFolderApps, new Comparator<ShortcutInfo>() {\r\n        @Override\r\n        public int compare(ShortcutInfo lhs, ShortcutInfo rhs) {\r\n            return Long.compare(lhs.firstInstallTime, rhs.firstInstallTime);\r\n        }\r\n    });\r\n    String folderIdKey = USER_FOLDER_ID_PREFIX + mUserSerial;\r\n    if (mPrefs.contains(folderIdKey)) {\r\n        long folderId = mPrefs.getLong(folderIdKey, 0);\r\n        final FolderInfo workFolder = mModel.findFolderById(folderId);\r\n        if (workFolder == null || !workFolder.hasOption(FolderInfo.FLAG_WORK_FOLDER)) {\r\n            mHomescreenApps.addAll(mWorkFolderApps);\r\n            return;\r\n        }\r\n        saveWorkFolderShortcuts(folderId, workFolder.contents.size());\r\n        final ArrayList<ShortcutInfo> shortcuts = mWorkFolderApps;\r\n        new MainThreadExecutor().execute(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (ShortcutInfo info : shortcuts) {\r\n                    workFolder.add(info);\r\n                }\r\n            }\r\n        });\r\n    } else {\r\n        final FolderInfo workFolder = new FolderInfo();\r\n        workFolder.title = mContext.getText(R.string.work_folder_name);\r\n        workFolder.setOption(FolderInfo.FLAG_WORK_FOLDER, true, null);\r\n        for (ShortcutInfo info : mWorkFolderApps) {\r\n            workFolder.add(info);\r\n        }\r\n        ArrayList<ItemInfo> itemList = new ArrayList<ItemInfo>(1);\r\n        itemList.add(workFolder);\r\n        mModel.addAndBindAddedWorkspaceItems(mContext, itemList);\r\n        mPrefs.edit().putLong(USER_FOLDER_ID_PREFIX + mUserSerial, workFolder.id).apply();\r\n        saveWorkFolderShortcuts(workFolder.id, 0);\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.util.ManagedProfileHeuristic.finalizeWorkFolder",
	"Comment": "adds and binds shortcuts marked to be added to the work folder.",
	"Method": "void finalizeWorkFolder(){\r\n    return Long.compare(lhs.firstInstallTime, rhs.firstInstallTime);\r\n}"
}, {
	"Path": "com.android.launcher3.util.ManagedProfileHeuristic.finalizeWorkFolder",
	"Comment": "adds and binds shortcuts marked to be added to the work folder.",
	"Method": "void finalizeWorkFolder(){\r\n    for (ShortcutInfo info : shortcuts) {\r\n        workFolder.add(info);\r\n    }\r\n}"
}, {
	"Path": "com.jdon.util.UtilDateTime.toSqlTime",
	"Comment": "makes a java.sql.time from separate ints for hour, minute, and second.",
	"Method": "java.sql.Time toSqlTime(String time,java.sql.Time toSqlTime,String hourStr,String minuteStr,String secondStr,java.sql.Time toSqlTime,int hour,int minute,int second){\r\n    java.util.Date newDate = toDate(0, 0, 0, hour, minute, second);\r\n    if (newDate != null)\r\n        return new java.sql.Time(newDate.getTime());\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.Triangle.angleBisector",
	"Comment": "computes the point at which the bisector of the angle abc cuts the segment",
	"Method": "Coordinate angleBisector(Coordinate a,Coordinate b,Coordinate c){\r\n    double len0 = b.distance(a);\r\n    double len2 = b.distance(c);\r\n    double frac = len0 / (len0 + len2);\r\n    double dx = c.x - a.x;\r\n    double dy = c.y - a.y;\r\n    Coordinate splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);\r\n    return splitPt;\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.ConvexHull.toCoordinateArray",
	"Comment": "an alternative to stack.toarray, which is not present in earlier versionsof java.",
	"Method": "Coordinate[] toCoordinateArray(Stack stack){\r\n    Coordinate[] coordinates = new Coordinate[stack.size()];\r\n    for (int i = 0; i < stack.size(); i++) {\r\n        Coordinate coordinate = (Coordinate) stack.get(i);\r\n        coordinates[i] = coordinate;\r\n    }\r\n    return coordinates;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct5.converge",
	"Comment": "converge this coproduct down to a lower order coproduct by mapping the last possible type into an earlierpossible type.",
	"Method": "CoProduct4<A, B, C, D, ? extends CoProduct4<A, B, C, D, ?>> converge(Function<? super E, ? extends CoProduct4<A, B, C, D, ?>> convergenceFn){\r\n    return match(a -> new CoProduct4<A, B, C, D, CoProduct4<A, B, C, D, ?>>() {\r\n        @Override\r\n        public <R> R match(Function<? super A, ? extends R> aFn, Function<? super B, ? extends R> bFn, Function<? super C, ? extends R> cFn, Function<? super D, ? extends R> dFn) {\r\n            return aFn.apply(a);\r\n        }\r\n    }, b -> new CoProduct4<A, B, C, D, CoProduct4<A, B, C, D, ?>>() {\r\n        @Override\r\n        public <R> R match(Function<? super A, ? extends R> aFn, Function<? super B, ? extends R> bFn, Function<? super C, ? extends R> cFn, Function<? super D, ? extends R> dFn) {\r\n            return bFn.apply(b);\r\n        }\r\n    }, c -> new CoProduct4<A, B, C, D, CoProduct4<A, B, C, D, ?>>() {\r\n        @Override\r\n        public <R> R match(Function<? super A, ? extends R> aFn, Function<? super B, ? extends R> bFn, Function<? super C, ? extends R> cFn, Function<? super D, ? extends R> dFn) {\r\n            return cFn.apply(c);\r\n        }\r\n    }, d -> new CoProduct4<A, B, C, D, CoProduct4<A, B, C, D, ?>>() {\r\n        @Override\r\n        public <R> R match(Function<? super A, ? extends R> aFn, Function<? super B, ? extends R> bFn, Function<? super C, ? extends R> cFn, Function<? super D, ? extends R> dFn) {\r\n            return dFn.apply(d);\r\n        }\r\n    }, convergenceFn::apply);\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct5.converge",
	"Comment": "converge this coproduct down to a lower order coproduct by mapping the last possible type into an earlierpossible type.",
	"Method": "CoProduct4<A, B, C, D, ? extends CoProduct4<A, B, C, D, ?>> converge(Function<? super E, ? extends CoProduct4<A, B, C, D, ?>> convergenceFn){\r\n    return aFn.apply(a);\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct5.converge",
	"Comment": "converge this coproduct down to a lower order coproduct by mapping the last possible type into an earlierpossible type.",
	"Method": "CoProduct4<A, B, C, D, ? extends CoProduct4<A, B, C, D, ?>> converge(Function<? super E, ? extends CoProduct4<A, B, C, D, ?>> convergenceFn){\r\n    return bFn.apply(b);\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct5.converge",
	"Comment": "converge this coproduct down to a lower order coproduct by mapping the last possible type into an earlierpossible type.",
	"Method": "CoProduct4<A, B, C, D, ? extends CoProduct4<A, B, C, D, ?>> converge(Function<? super E, ? extends CoProduct4<A, B, C, D, ?>> convergenceFn){\r\n    return cFn.apply(c);\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct5.converge",
	"Comment": "converge this coproduct down to a lower order coproduct by mapping the last possible type into an earlierpossible type.",
	"Method": "CoProduct4<A, B, C, D, ? extends CoProduct4<A, B, C, D, ?>> converge(Function<? super E, ? extends CoProduct4<A, B, C, D, ?>> convergenceFn){\r\n    return dFn.apply(d);\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.onPackageIconsUpdated",
	"Comment": "called when the icons for packages have been updated in the icon cache.",
	"Method": "void onPackageIconsUpdated(HashSet<String> updatedPackages,UserHandleCompat user){\r\n    final Callbacks callbacks = getCallback();\r\n    final ArrayList<AppInfo> updatedApps = new ArrayList();\r\n    final ArrayList<ShortcutInfo> updatedShortcuts = new ArrayList();\r\n    synchronized (sBgLock) {\r\n        for (ItemInfo info : sBgItemsIdMap) {\r\n            if (info instanceof ShortcutInfo && user.equals(info.user) && info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {\r\n                ShortcutInfo si = (ShortcutInfo) info;\r\n                ComponentName cn = si.getTargetComponent();\r\n                if (cn != null && updatedPackages.contains(cn.getPackageName())) {\r\n                    si.updateIcon(mIconCache);\r\n                    updatedShortcuts.add(si);\r\n                }\r\n            }\r\n        }\r\n        mBgAllAppsList.updateIconsAndLabels(updatedPackages, user, updatedApps);\r\n    }\r\n    if (!updatedShortcuts.isEmpty()) {\r\n        final UserHandleCompat userFinal = user;\r\n        mHandler.post(new Runnable() {\r\n            public void run() {\r\n                Callbacks cb = getCallback();\r\n                if (cb != null && callbacks == cb) {\r\n                    cb.bindShortcutsChanged(updatedShortcuts, new ArrayList<ShortcutInfo>(), userFinal);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    if (!updatedApps.isEmpty()) {\r\n        mHandler.post(new Runnable() {\r\n            public void run() {\r\n                Callbacks cb = getCallback();\r\n                if (cb != null && callbacks == cb) {\r\n                    cb.bindAppsUpdated(updatedApps);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    loadAndBindWidgetsAndShortcuts(callbacks, false);\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.onPackageIconsUpdated",
	"Comment": "called when the icons for packages have been updated in the icon cache.",
	"Method": "void onPackageIconsUpdated(HashSet<String> updatedPackages,UserHandleCompat user){\r\n    Callbacks cb = getCallback();\r\n    if (cb != null && callbacks == cb) {\r\n        cb.bindShortcutsChanged(updatedShortcuts, new ArrayList<ShortcutInfo>(), userFinal);\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.onPackageIconsUpdated",
	"Comment": "called when the icons for packages have been updated in the icon cache.",
	"Method": "void onPackageIconsUpdated(HashSet<String> updatedPackages,UserHandleCompat user){\r\n    Callbacks cb = getCallback();\r\n    if (cb != null && callbacks == cb) {\r\n        cb.bindAppsUpdated(updatedApps);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testbuilder.GeometryTreeModel.addTreeModelListener",
	"Comment": "adds a listener for the treemodelevent posted after the tree changes.",
	"Method": "void addTreeModelListener(TreeModelListener l){\r\n    treeModelListeners.addElement(l);\r\n}"
}, {
	"Path": "org.locationtech.jts.io.sde.SdeReader.getDimension",
	"Comment": "gets the maximum number of coordinate dimensions which will be read.",
	"Method": "int getDimension(){\r\n    return maxDimensionToRead;\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.patch.DiffMatchPatch.matchBitapScore",
	"Comment": "compute and return the score for a match with e errors and x location.",
	"Method": "double matchBitapScore(int e,int x,int loc,String pattern){\r\n    float accuracy = (float) e / pattern.length();\r\n    int proximity = Math.abs(loc - x);\r\n    return accuracy + (proximity / (float) MATCH_DISTANCE);\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testbuilder.GeometryEditPanel.drawRevealMask",
	"Comment": "draws a mask surround to indicate that geometry is being visually altered",
	"Method": "void drawRevealMask(Graphics2D g){\r\n    double viewWidth = viewport.getWidthInView();\r\n    double viewHeight = viewport.getHeightInView();\r\n    float minExtent = (float) Math.min(viewWidth, viewHeight);\r\n    float maskWidth = (float) (minExtent * AppConstants.MASK_WIDTH_FRAC / 2);\r\n    Area mask = new Area(new Rectangle2D.Float((float) 0, (float) 0, (float) viewWidth, (float) viewHeight));\r\n    Area maskHole = new Area(new Rectangle2D.Float((float) maskWidth, (float) maskWidth, ((float) viewWidth) - 2 * maskWidth, ((float) viewHeight) - 2 * maskWidth));\r\n    mask.subtract(maskHole);\r\n    g.setColor(AppConstants.MASK_CLR);\r\n    g.fill(mask);\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.CGAlgorithms.isOnLine",
	"Comment": "tests whether a point lies on the line segments defined by a list ofcoordinates.",
	"Method": "boolean isOnLine(Coordinate p,Coordinate[] pt){\r\n    LineIntersector lineIntersector = new RobustLineIntersector();\r\n    for (int i = 1; i < pt.length; i++) {\r\n        Coordinate p0 = pt[i - 1];\r\n        Coordinate p1 = pt[i];\r\n        lineIntersector.computeIntersection(p, p0, p1);\r\n        if (lineIntersector.hasIntersection()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.dsl.internal.DeploymentOperationsImpl.waitUntilDeploymentIsScaled",
	"Comment": "lets wait until there are enough ready pods of the given deployment",
	"Method": "void waitUntilDeploymentIsScaled(int count){\r\n    final BlockingQueue<Object> queue = new ArrayBlockingQueue(1);\r\n    final AtomicReference<Integer> replicasRef = new AtomicReference(0);\r\n    final String name = checkName(getItem());\r\n    final String namespace = checkNamespace(getItem());\r\n    final Runnable deploymentPoller = new Runnable() {\r\n        public void run() {\r\n            try {\r\n                Deployment deployment = get();\r\n                if (deployment == null) {\r\n                    if (count == 0) {\r\n                        queue.put(true);\r\n                        return;\r\n                    } else {\r\n                        queue.put(new IllegalStateException(\"Can't wait for Deployment: \" + checkName(getItem()) + \" in namespace: \" + checkName(getItem()) + \" to scale. Resource is no longer available.\"));\r\n                        return;\r\n                    }\r\n                }\r\n                replicasRef.set(deployment.getStatus().getReplicas());\r\n                int currentReplicas = deployment.getStatus().getReplicas() != null ? deployment.getStatus().getReplicas() : 0;\r\n                long generation = deployment.getMetadata().getGeneration() != null ? deployment.getMetadata().getGeneration() : 0;\r\n                long observedGeneration = deployment.getStatus() != null && deployment.getStatus().getObservedGeneration() != null ? deployment.getStatus().getObservedGeneration() : -1;\r\n                if (observedGeneration >= generation && Objects.equals(deployment.getSpec().getReplicas(), currentReplicas)) {\r\n                    queue.put(true);\r\n                } else {\r\n                    LOG.debug(\"Only {}/{} pods scheduled for Deployment: {} in namespace: {} seconds so waiting...\", deployment.getStatus().getReplicas(), deployment.getSpec().getReplicas(), deployment.getMetadata().getName(), namespace);\r\n                }\r\n            } catch (Throwable t) {\r\n                LOG.error(\"Error while waiting for Deployment to be scaled.\", t);\r\n            }\r\n        }\r\n    };\r\n    ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\r\n    ScheduledFuture poller = executor.scheduleWithFixedDelay(deploymentPoller, 0, POLL_INTERVAL_MS, TimeUnit.MILLISECONDS);\r\n    try {\r\n        if (Utils.waitUntilReady(queue, getConfig().getScaleTimeout(), TimeUnit.MILLISECONDS)) {\r\n            LOG.debug(\"{}/{} pod(s) ready for Deployment: {} in namespace: {}.\", replicasRef.get(), count, name, namespace);\r\n        } else {\r\n            LOG.error(\"{}/{} pod(s) ready for Deployment: {} in namespace: {}  after waiting for {} seconds so giving up\", replicasRef.get(), count, name, namespace, TimeUnit.MILLISECONDS.toSeconds(getConfig().getScaleTimeout()));\r\n        }\r\n    } finally {\r\n        poller.cancel(true);\r\n        executor.shutdown();\r\n    }\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.dsl.internal.DeploymentOperationsImpl.waitUntilDeploymentIsScaled",
	"Comment": "lets wait until there are enough ready pods of the given deployment",
	"Method": "void waitUntilDeploymentIsScaled(int count){\r\n    try {\r\n        Deployment deployment = get();\r\n        if (deployment == null) {\r\n            if (count == 0) {\r\n                queue.put(true);\r\n                return;\r\n            } else {\r\n                queue.put(new IllegalStateException(\"Can't wait for Deployment: \" + checkName(getItem()) + \" in namespace: \" + checkName(getItem()) + \" to scale. Resource is no longer available.\"));\r\n                return;\r\n            }\r\n        }\r\n        replicasRef.set(deployment.getStatus().getReplicas());\r\n        int currentReplicas = deployment.getStatus().getReplicas() != null ? deployment.getStatus().getReplicas() : 0;\r\n        long generation = deployment.getMetadata().getGeneration() != null ? deployment.getMetadata().getGeneration() : 0;\r\n        long observedGeneration = deployment.getStatus() != null && deployment.getStatus().getObservedGeneration() != null ? deployment.getStatus().getObservedGeneration() : -1;\r\n        if (observedGeneration >= generation && Objects.equals(deployment.getSpec().getReplicas(), currentReplicas)) {\r\n            queue.put(true);\r\n        } else {\r\n            LOG.debug(\"Only {}/{} pods scheduled for Deployment: {} in namespace: {} seconds so waiting...\", deployment.getStatus().getReplicas(), deployment.getSpec().getReplicas(), deployment.getMetadata().getName(), namespace);\r\n        }\r\n    } catch (Throwable t) {\r\n        LOG.error(\"Error while waiting for Deployment to be scaled.\", t);\r\n    }\r\n}"
}, {
	"Path": "com.jsql.util.AuthenticationUtil.setKerberosCifs",
	"Comment": "initialize the utility class with preferences from the jvmand apply environment settings.",
	"Method": "void setKerberosCifs(){\r\n    Preferences prefs = Preferences.userRoot().node(InjectionModel.class.getName());\r\n    AuthenticationUtil.isAuthentication = prefs.getBoolean(\"isDigestAuthentication\", false);\r\n    AuthenticationUtil.usernameAuthentication = prefs.get(\"usernameDigest\", \"\");\r\n    AuthenticationUtil.passwordAuthentication = prefs.get(\"passwordDigest\", \"\");\r\n    AuthenticationUtil.isKerberos = prefs.getBoolean(\"enableKerberos\", false);\r\n    AuthenticationUtil.pathKerberosKrb5 = prefs.get(\"kerberosKrb5Conf\", \"\");\r\n    AuthenticationUtil.pathKerberosLogin = prefs.get(\"kerberosLoginConf\", \"\");\r\n    AuthCacheValue.setAuthCache(new AuthCacheImpl());\r\n    if (AuthenticationUtil.isAuthentication) {\r\n        Authenticator.setDefault(new Authenticator() {\r\n            @Override\r\n            protected PasswordAuthentication getPasswordAuthentication() {\r\n                return new PasswordAuthentication(AuthenticationUtil.usernameAuthentication, AuthenticationUtil.passwordAuthentication.toCharArray());\r\n            }\r\n        });\r\n    }\r\n    AuthenticationUtil.setAuthentication();\r\n}"
}, {
	"Path": "com.jsql.util.AuthenticationUtil.setKerberosCifs",
	"Comment": "initialize the utility class with preferences from the jvmand apply environment settings.",
	"Method": "void setKerberosCifs(){\r\n    return new PasswordAuthentication(AuthenticationUtil.usernameAuthentication, AuthenticationUtil.passwordAuthentication.toCharArray());\r\n}"
}, {
	"Path": "com.jsql.model.accessible.RessourceAccess.readFile",
	"Comment": "attempt to read files in parallel by their path from the website using injection.reading file needs a file right on the server.the user can interrupt the process at any time.",
	"Method": "void readFile(List<ItemList> pathsFiles){\r\n    if (!RessourceAccess.isReadingAllowed()) {\r\n        return;\r\n    }\r\n    int countFileFound = 0;\r\n    ExecutorService taskExecutor = Executors.newFixedThreadPool(10, new ThreadFactoryCallable(\"CallableReadFile\"));\r\n    CompletionService<CallableFile> taskCompletionService = new ExecutorCompletionService(taskExecutor);\r\n    for (ItemList pathFile : pathsFiles) {\r\n        CallableFile callableFile = new CallableFile(pathFile.toString());\r\n        taskCompletionService.submit(callableFile);\r\n        RessourceAccess.callablesReadFile.add(callableFile);\r\n    }\r\n    List<String> duplicate = new ArrayList();\r\n    int submittedTasks = pathsFiles.size();\r\n    int tasksHandled;\r\n    for (tasksHandled = 0; tasksHandled < submittedTasks && !RessourceAccess.isSearchFileStopped; tasksHandled++) {\r\n        CallableFile currentCallable = taskCompletionService.take().get();\r\n        if (!\"\".equals(currentCallable.getSourceFile())) {\r\n            String name = currentCallable.getPathFile().substring(currentCallable.getPathFile().lastIndexOf('/') + 1, currentCallable.getPathFile().length());\r\n            String content = currentCallable.getSourceFile();\r\n            String path = currentCallable.getPathFile();\r\n            Request request = new Request();\r\n            request.setMessage(Interaction.CREATE_FILE_TAB);\r\n            request.setParameters(name, content, path);\r\n            MediatorModel.model().sendToViews(request);\r\n            if (!duplicate.contains(path.replace(name, \"\"))) {\r\n                LOGGER.info(\"Shell might be possible in folder \" + path.replace(name, \"\"));\r\n            }\r\n            duplicate.add(path.replace(name, \"\"));\r\n            countFileFound++;\r\n        }\r\n    }\r\n    for (CallableFile callableReadFile : RessourceAccess.callablesReadFile) {\r\n        callableReadFile.getSuspendableReadFile().stop();\r\n    }\r\n    RessourceAccess.callablesReadFile.clear();\r\n    taskExecutor.shutdown();\r\n    taskExecutor.awaitTermination(5, TimeUnit.SECONDS);\r\n    RessourceAccess.isSearchFileStopped = false;\r\n    String result = \"Found \" + countFileFound + \" file\" + (countFileFound > 1 ? 's' : \"\") + \" \" + (tasksHandled != submittedTasks ? \"of \" + tasksHandled + \" processed \" : \"\") + \"on \" + submittedTasks + \" files checked\";\r\n    if (countFileFound > 0) {\r\n        LOGGER.debug(result);\r\n    } else {\r\n        LOGGER.warn(result);\r\n    }\r\n    Request request = new Request();\r\n    request.setMessage(Interaction.END_FILE_SEARCH);\r\n    MediatorModel.model().sendToViews(request);\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DD.selfSubtract",
	"Comment": "subtracts the argument from the value of this.to prevent altering constants, this method must only be used on values known to be newly created.",
	"Method": "DD selfSubtract(DD y,DD selfSubtract,double y){\r\n    if (isNaN())\r\n        return this;\r\n    return selfAdd(-y, 0.0);\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct8.projectA",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the first slot value.",
	"Method": "Maybe<A> projectA(){\r\n    return project()._1();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct8.projectB",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the second slot value.",
	"Method": "Maybe<B> projectB(){\r\n    return project()._2();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct8.projectC",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the third slot value.",
	"Method": "Maybe<C> projectC(){\r\n    return project()._3();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct8.projectD",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the fourth slot value.",
	"Method": "Maybe<D> projectD(){\r\n    return project()._4();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct6.converge",
	"Comment": "converge this coproduct down to a lower order coproduct by mapping the last possible type into an earlierpossible type.",
	"Method": "CoProduct5<A, B, C, D, E, ? extends CoProduct5<A, B, C, D, E, ?>> converge(Function<? super F, ? extends CoProduct5<A, B, C, D, E, ?>> convergenceFn){\r\n    return match(Choice5::a, Choice5::b, Choice5::c, Choice5::d, Choice5::e, convergenceFn::apply);\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct8.projectE",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the fifth slot value.",
	"Method": "Maybe<E> projectE(){\r\n    return project()._5();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct8.projectF",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the sixth slot value.",
	"Method": "Maybe<F> projectF(){\r\n    return project()._6();\r\n}"
}, {
	"Path": "com.jsql.view.i18n.I18nView.keys",
	"Comment": "return the i18n keys of components whose text is replacedwhen the translation changes.",
	"Method": "Set<String> keys(){\r\n    return I18nView.componentsLocalized.keySet();\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct8.projectG",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the seventh slot value.",
	"Method": "Maybe<G> projectG(){\r\n    return project()._7();\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.requests.restaction.pagination.PaginationAction.getFirst",
	"Comment": "the first cached entity retrieved by this paginationaction instance",
	"Method": "T getFirst(){\r\n    if (cached.isEmpty())\r\n        throw new NoSuchElementException(\"No entities have been retrieved yet.\");\r\n    return cached.get(0);\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct8.projectH",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the eighth slot value.",
	"Method": "Maybe<H> projectH(){\r\n    return project()._8();\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.predicate.RectangleContains.isPointContainedInBoundary",
	"Comment": "tests if a point is contained in the boundary of the target rectangle.",
	"Method": "boolean isPointContainedInBoundary(Point point,boolean isPointContainedInBoundary,Coordinate pt){\r\n    return pt.x == rectEnv.getMinX() || pt.x == rectEnv.getMaxX() || pt.y == rectEnv.getMinY() || pt.y == rectEnv.getMaxY();\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.distance.GeometryLocation.isInsideArea",
	"Comment": "tests whether this location represents a point inside an area geometry.",
	"Method": "boolean isInsideArea(){\r\n    return segIndex == INSIDE_AREA;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdgeSubdivision.isFrameBorderEdge",
	"Comment": "tests whether a quadedge is an edge on the border of the frame facets and\tthe internal facets. e.g. an edge which does not itself touch a frame\tvertex, but which touches an edge which does.",
	"Method": "boolean isFrameBorderEdge(QuadEdge e){\r\n    QuadEdge[] leftTri = new QuadEdge[3];\r\n    getTriangleEdges(e, leftTri);\r\n    QuadEdge[] rightTri = new QuadEdge[3];\r\n    getTriangleEdges(e.sym(), rightTri);\r\n    Vertex vLeftTriOther = e.lNext().dest();\r\n    if (isFrameVertex(vLeftTriOther))\r\n        return true;\r\n    Vertex vRightTriOther = e.sym().lNext().dest();\r\n    if (isFrameVertex(vRightTriOther))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.kse.gui.dialogs.RevokedCertsTableHeadRend.getTableCellRendererComponent",
	"Comment": "returns the rendered header cell for the supplied value and column.",
	"Method": "Component getTableCellRendererComponent(JTable jTable,Object value,boolean isSelected,boolean hasFocus,int row,int col){\r\n    Component c = delegate.getTableCellRendererComponent(jTable, value, isSelected, hasFocus, row, col);\r\n    if (c instanceof JLabel) {\r\n        JLabel header = (JLabel) c;\r\n        if (col == 0) {\r\n            header.setToolTipText(res.getString(\"RevokedCertsTableHeadRend.SerialNumberColumn.tooltip\"));\r\n        } else {\r\n            header.setToolTipText(res.getString(\"RevokedCertsTableHeadRend.RevocationDateColumn.tooltip\"));\r\n        }\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.patch.DiffMatchPatch.diffCharsToLines",
	"Comment": "rehydrate the text in a diff from a string of line hashes to real lines oftext.",
	"Method": "void diffCharsToLines(List<Diff> diffs,List<String> lineArray){\r\n    StringBuilder text;\r\n    for (Diff diff : diffs) {\r\n        text = new StringBuilder();\r\n        for (int y = 0; y < diff.getText().length(); y++) {\r\n            text.append(lineArray.get(diff.getText().charAt(y)));\r\n        }\r\n        diff.setText(text.toString());\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.BufferSubgraph.getEnvelope",
	"Comment": "computes the envelope of the edges in the subgraph.the envelope is cached after being computed.",
	"Method": "Envelope getEnvelope(){\r\n    if (env == null) {\r\n        Envelope edgeEnv = new Envelope();\r\n        for (Iterator it = dirEdgeList.iterator(); it.hasNext(); ) {\r\n            DirectedEdge dirEdge = (DirectedEdge) it.next();\r\n            Coordinate[] pts = dirEdge.getEdge().getCoordinates();\r\n            for (int i = 0; i < pts.length - 1; i++) {\r\n                edgeEnv.expandToInclude(pts[i]);\r\n            }\r\n        }\r\n        env = edgeEnv;\r\n    }\r\n    return env;\r\n}"
}, {
	"Path": "com.android.launcher3.Workspace.getPageAreaRelativeToDragLayer",
	"Comment": "computes the area relative to draglayer which is used to display a page.",
	"Method": "void getPageAreaRelativeToDragLayer(Rect outArea){\r\n    CellLayout child = (CellLayout) getChildAt(getNextPage());\r\n    if (child == null) {\r\n        return;\r\n    }\r\n    ShortcutAndWidgetContainer boundingLayout = child.getShortcutsAndWidgets();\r\n    mTempXY[0] = getViewportOffsetX() + getPaddingLeft() + boundingLayout.getLeft();\r\n    mTempXY[1] = child.getTop() + boundingLayout.getTop();\r\n    float scale = mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(this, mTempXY);\r\n    outArea.set(mTempXY[0], mTempXY[1], (int) (mTempXY[0] + scale * boundingLayout.getMeasuredWidth()), (int) (mTempXY[1] + scale * boundingLayout.getMeasuredHeight()));\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.utils.WidgetUtil.getWidgetBanner",
	"Comment": "gets the banner image for the specified guild of the specified type.this banner will only be available if the guild in question has thewidget enabled. additionally, this method can be used independently ofbeing on the guild in question.",
	"Method": "String getWidgetBanner(Guild guild,BannerType type,String getWidgetBanner,String guildId,BannerType type){\r\n    Checks.notNull(guildId, \"GuildId\");\r\n    Checks.notNull(type, \"BannerType\");\r\n    return String.format(WIDGET_PNG, guildId, type.name().toLowerCase());\r\n}"
}, {
	"Path": "com.android.launcher3.DragController.isFlingingToDelete",
	"Comment": "determines whether the user flung the current item to delete it.",
	"Method": "PointF isFlingingToDelete(DragSource source){\r\n    if (mFlingToDeleteDropTarget == null)\r\n        return null;\r\n    if (!source.supportsFlingToDelete())\r\n        return null;\r\n    ViewConfiguration config = ViewConfiguration.get(mLauncher);\r\n    mVelocityTracker.computeCurrentVelocity(1000, config.getScaledMaximumFlingVelocity());\r\n    if (mVelocityTracker.getYVelocity() < mFlingToDeleteThresholdVelocity) {\r\n        PointF vel = new PointF(mVelocityTracker.getXVelocity(), mVelocityTracker.getYVelocity());\r\n        PointF upVec = new PointF(0f, -1f);\r\n        float theta = (float) Math.acos(((vel.x * upVec.x) + (vel.y * upVec.y)) / (vel.length() * upVec.length()));\r\n        if (theta <= Math.toRadians(MAX_FLING_DEGREES)) {\r\n            return vel;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.copyFolderIconToImage",
	"Comment": "this method draws the foldericon to an imageview and then adds and positions that imageviewin the draglayer in the exact absolute location of the original foldericon.",
	"Method": "void copyFolderIconToImage(FolderIcon fi){\r\n    final int width = fi.getMeasuredWidth();\r\n    final int height = fi.getMeasuredHeight();\r\n    if (mFolderIconImageView == null) {\r\n        mFolderIconImageView = new ImageView(this);\r\n    }\r\n    if (mFolderIconBitmap == null || mFolderIconBitmap.getWidth() != width || mFolderIconBitmap.getHeight() != height) {\r\n        mFolderIconBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\r\n        mFolderIconCanvas = new Canvas(mFolderIconBitmap);\r\n    }\r\n    DragLayer.LayoutParams lp;\r\n    if (mFolderIconImageView.getLayoutParams() instanceof DragLayer.LayoutParams) {\r\n        lp = (DragLayer.LayoutParams) mFolderIconImageView.getLayoutParams();\r\n    } else {\r\n        lp = new DragLayer.LayoutParams(width, height);\r\n    }\r\n    float scale = mDragLayer.getDescendantRectRelativeToSelf(fi, mRectForFolderAnimation);\r\n    lp.customPosition = true;\r\n    lp.x = mRectForFolderAnimation.left;\r\n    lp.y = mRectForFolderAnimation.top;\r\n    lp.width = (int) (scale * width);\r\n    lp.height = (int) (scale * height);\r\n    mFolderIconCanvas.drawColor(0, PorterDuff.Mode.CLEAR);\r\n    fi.draw(mFolderIconCanvas);\r\n    mFolderIconImageView.setImageBitmap(mFolderIconBitmap);\r\n    if (fi.getFolder() != null) {\r\n        mFolderIconImageView.setPivotX(fi.getFolder().getPivotXForIconAnimation());\r\n        mFolderIconImageView.setPivotY(fi.getFolder().getPivotYForIconAnimation());\r\n    }\r\n    if (mDragLayer.indexOfChild(mFolderIconImageView) != -1) {\r\n        mDragLayer.removeView(mFolderIconImageView);\r\n    }\r\n    mDragLayer.addView(mFolderIconImageView, lp);\r\n    if (fi.getFolder() != null) {\r\n        fi.getFolder().bringToFront();\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.getIntroScreen",
	"Comment": "full screen intro screen to be shown and dismissed before the launcher can be used.",
	"Method": "View getIntroScreen(){\r\n    if (mLauncherCallbacks != null) {\r\n        return mLauncherCallbacks.getIntroScreen();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.android.gallery3d.exif.ExifParser.checkOffsetOrImageTag",
	"Comment": "check the tag, if the tag is one of the offset tag that points to the ifdor image the caller is interested in, register the ifd or image.",
	"Method": "void checkOffsetOrImageTag(ExifTag tag){\r\n    if (tag.getComponentCount() == 0) {\r\n        return;\r\n    }\r\n    short tid = tag.getTagId();\r\n    int ifd = tag.getIfd();\r\n    if (tid == TAG_EXIF_IFD && checkAllowed(ifd, ExifInterface.TAG_EXIF_IFD)) {\r\n        if (isIfdRequested(IfdId.TYPE_IFD_EXIF) || isIfdRequested(IfdId.TYPE_IFD_INTEROPERABILITY)) {\r\n            registerIfd(IfdId.TYPE_IFD_EXIF, tag.getValueAt(0));\r\n        }\r\n    } else if (tid == TAG_GPS_IFD && checkAllowed(ifd, ExifInterface.TAG_GPS_IFD)) {\r\n        if (isIfdRequested(IfdId.TYPE_IFD_GPS)) {\r\n            registerIfd(IfdId.TYPE_IFD_GPS, tag.getValueAt(0));\r\n        }\r\n    } else if (tid == TAG_INTEROPERABILITY_IFD && checkAllowed(ifd, ExifInterface.TAG_INTEROPERABILITY_IFD)) {\r\n        if (isIfdRequested(IfdId.TYPE_IFD_INTEROPERABILITY)) {\r\n            registerIfd(IfdId.TYPE_IFD_INTEROPERABILITY, tag.getValueAt(0));\r\n        }\r\n    } else if (tid == TAG_JPEG_INTERCHANGE_FORMAT && checkAllowed(ifd, ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT)) {\r\n        if (isThumbnailRequested()) {\r\n            registerCompressedImage(tag.getValueAt(0));\r\n        }\r\n    } else if (tid == TAG_JPEG_INTERCHANGE_FORMAT_LENGTH && checkAllowed(ifd, ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH)) {\r\n        if (isThumbnailRequested()) {\r\n            mJpegSizeTag = tag;\r\n        }\r\n    } else if (tid == TAG_STRIP_OFFSETS && checkAllowed(ifd, ExifInterface.TAG_STRIP_OFFSETS)) {\r\n        if (isThumbnailRequested()) {\r\n            if (tag.hasValue()) {\r\n                for (int i = 0; i < tag.getComponentCount(); i++) {\r\n                    if (tag.getDataType() == ExifTag.TYPE_UNSIGNED_SHORT) {\r\n                        registerUncompressedStrip(i, tag.getValueAt(i));\r\n                    } else {\r\n                        registerUncompressedStrip(i, tag.getValueAt(i));\r\n                    }\r\n                }\r\n            } else {\r\n                mCorrespondingEvent.put(tag.getOffset(), new ExifTagEvent(tag, false));\r\n            }\r\n        }\r\n    } else if (tid == TAG_STRIP_BYTE_COUNTS && checkAllowed(ifd, ExifInterface.TAG_STRIP_BYTE_COUNTS) && isThumbnailRequested() && tag.hasValue()) {\r\n        mStripSizeTag = tag;\r\n    }\r\n}"
}, {
	"Path": "org.kse.crypto.x509.PolicyMappingsUtil.createFromList",
	"Comment": "creates policymappings objects from list of policymapping",
	"Method": "PolicyMappings createFromList(List<PolicyMapping> listOfPolicyMappings){\r\n    CertPolicyId[] issuerDomainPolicies = new CertPolicyId[listOfPolicyMappings.size()];\r\n    CertPolicyId[] subjectDomainPolicies = new CertPolicyId[listOfPolicyMappings.size()];\r\n    for (int i = 0; i < listOfPolicyMappings.size(); i++) {\r\n        PolicyMapping policyMapping = listOfPolicyMappings.get(i);\r\n        issuerDomainPolicies[i] = CertPolicyId.getInstance(policyMapping.getIssuerDomainPolicy());\r\n        subjectDomainPolicies[i] = CertPolicyId.getInstance(policyMapping.getSubjectDomainPolicy());\r\n    }\r\n    return new PolicyMappings(issuerDomainPolicies, subjectDomainPolicies);\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.utils.Utils.waitUntilReady",
	"Comment": "wait until an other thread signals the completion of a task.if an exception is passed, it will be propagated to the caller.",
	"Method": "boolean waitUntilReady(BlockingQueue<Object> queue,long amount,TimeUnit timeUnit){\r\n    try {\r\n        Object obj = queue.poll(amount, timeUnit);\r\n        if (obj instanceof Boolean) {\r\n            return (Boolean) obj;\r\n        } else if (obj instanceof Throwable) {\r\n            throw (Throwable) obj;\r\n        }\r\n        return false;\r\n    } catch (Throwable t) {\r\n        throw KubernetesClientException.launderThrowable(t);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.edgegraph.HalfEdge.insert",
	"Comment": "inserts an edgeinto the ring of edges around the origin vertex of this edge.the inserted edge must have the same origin as this edge.",
	"Method": "void insert(HalfEdge e){\r\n    if (oNext() == this) {\r\n        insertAfter(e);\r\n        return;\r\n    }\r\n    int ecmp = compareTo(e);\r\n    HalfEdge ePrev = this;\r\n    do {\r\n        HalfEdge oNext = ePrev.oNext();\r\n        int cmp = oNext.compareTo(e);\r\n        if (cmp != ecmp || oNext == this) {\r\n            ePrev.insertAfter(e);\r\n            return;\r\n        }\r\n        ePrev = oNext;\r\n    } while (ePrev != this);\r\n    Assert.shouldNeverReachHere();\r\n}"
}, {
	"Path": "org.kse.crypto.privatekey.OpenSslPvkUtil.load",
	"Comment": "load an unencrypted openssl private key from the stream. the encoding of\tthe private key may be pem or der.",
	"Method": "PrivateKey load(byte[] pvkData){\r\n    EncryptionType encType = getEncryptionType(pvkData);\r\n    if (encType == null) {\r\n        throw new CryptoException(res.getString(\"NotValidOpenSsl.exception.message\"));\r\n    }\r\n    if (encType == ENCRYPTED) {\r\n        throw new PrivateKeyEncryptedException(res.getString(\"OpenSslIsEncrypted.exception.message\"));\r\n    }\r\n    PemInfo pemInfo = PemUtil.decode(pvkData);\r\n    if (pemInfo != null) {\r\n        pvkData = pemInfo.getContent();\r\n    }\r\n    try (ASN1InputStream asn1InputStream = new ASN1InputStream(pvkData)) {\r\n        ASN1Primitive openSsl = asn1InputStream.readObject();\r\n        asn1InputStream.close();\r\n        if (openSsl instanceof ASN1Sequence) {\r\n            ASN1Sequence seq = (ASN1Sequence) openSsl;\r\n            if (seq.size() == 9) {\r\n                BigInteger version = ((ASN1Integer) seq.getObjectAt(0)).getValue();\r\n                BigInteger modulus = ((ASN1Integer) seq.getObjectAt(1)).getValue();\r\n                BigInteger publicExponent = ((ASN1Integer) seq.getObjectAt(2)).getValue();\r\n                BigInteger privateExponent = ((ASN1Integer) seq.getObjectAt(3)).getValue();\r\n                BigInteger primeP = ((ASN1Integer) seq.getObjectAt(4)).getValue();\r\n                BigInteger primeQ = ((ASN1Integer) seq.getObjectAt(5)).getValue();\r\n                BigInteger primeExponentP = ((ASN1Integer) seq.getObjectAt(6)).getValue();\r\n                BigInteger primeExponenetQ = ((ASN1Integer) seq.getObjectAt(7)).getValue();\r\n                BigInteger crtCoefficient = ((ASN1Integer) seq.getObjectAt(8)).getValue();\r\n                if (!version.equals(VERSION)) {\r\n                    throw new CryptoException(MessageFormat.format(res.getString(\"OpenSslVersionIncorrect.exception.message\"), \"\" + VERSION.intValue(), \"\" + version.intValue()));\r\n                }\r\n                RSAPrivateCrtKeySpec rsaPrivateCrtKeySpec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, primeP, primeQ, primeExponentP, primeExponenetQ, crtCoefficient);\r\n                KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\r\n                return keyFactory.generatePrivate(rsaPrivateCrtKeySpec);\r\n            } else if (seq.size() == 6) {\r\n                BigInteger version = ((ASN1Integer) seq.getObjectAt(0)).getValue();\r\n                BigInteger primeModulusP = ((ASN1Integer) seq.getObjectAt(1)).getValue();\r\n                BigInteger primeQ = ((ASN1Integer) seq.getObjectAt(2)).getValue();\r\n                BigInteger generatorG = ((ASN1Integer) seq.getObjectAt(3)).getValue();\r\n                BigInteger secretExponentX = ((ASN1Integer) seq.getObjectAt(5)).getValue();\r\n                if (!version.equals(VERSION)) {\r\n                    throw new CryptoException(MessageFormat.format(res.getString(\"OpenSslVersionIncorrect.exception.message\"), \"\" + VERSION.intValue(), \"\" + version.intValue()));\r\n                }\r\n                DSAPrivateKeySpec dsaPrivateKeySpec = new DSAPrivateKeySpec(secretExponentX, primeModulusP, primeQ, generatorG);\r\n                KeyFactory keyFactory = KeyFactory.getInstance(\"DSA\");\r\n                return keyFactory.generatePrivate(dsaPrivateKeySpec);\r\n            } else if (seq.size() >= 2) {\r\n                org.bouncycastle.asn1.sec.ECPrivateKey pKey = org.bouncycastle.asn1.sec.ECPrivateKey.getInstance(seq);\r\n                AlgorithmIdentifier algId = new AlgorithmIdentifier(X9ObjectIdentifiers.id_ecPublicKey, pKey.getParameters());\r\n                PrivateKeyInfo privInfo = new PrivateKeyInfo(algId, pKey);\r\n                return new JcaPEMKeyConverter().getPrivateKey(privInfo);\r\n            } else {\r\n                throw new CryptoException(MessageFormat.format(res.getString(\"OpenSslSequenceIncorrectSize.exception.message\"), \"\" + seq.size()));\r\n            }\r\n        } else {\r\n            throw new CryptoException(res.getString(\"OpenSslSequenceNotFound.exception.message\"));\r\n        }\r\n    } catch (Exception ex) {\r\n        throw new CryptoException(res.getString(\"NoLoadOpenSslPrivateKey.exception.message\"), ex);\r\n    }\r\n}"
}, {
	"Path": "com.samskivert.mustache.Template.getValue",
	"Comment": "called by executing segments to obtain the value of the specified variable in the suppliedcontext.",
	"Method": "Object getValue(Context ctx,String name,int line,boolean missingIsNull){\r\n    if (name.equals(FIRST_NAME)) {\r\n        return ctx.onFirst;\r\n    } else if (name.equals(LAST_NAME)) {\r\n        return ctx.onLast;\r\n    } else if (name.equals(INDEX_NAME)) {\r\n        return ctx.index;\r\n    }\r\n    if (_compiler.standardsMode) {\r\n        Object value = getValueIn(ctx.data, name, line);\r\n        return checkForMissing(name, line, missingIsNull, value);\r\n    }\r\n    for (Context pctx = ctx; pctx != null; pctx = pctx.parent) {\r\n        Object value = getValueIn(pctx.data, name, line);\r\n        if (value != NO_FETCHER_FOUND)\r\n            return value;\r\n    }\r\n    if (!name.equals(DOT_NAME) && name.indexOf(DOT_NAME) != -1) {\r\n        return getCompoundValue(ctx, name, line, missingIsNull);\r\n    } else {\r\n        return checkForMissing(name, line, missingIsNull, NO_FETCHER_FOUND);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.EdgeRing.containsPoint",
	"Comment": "this method will cause the ring to be computed.it will also check any holes, if they have been assigned.",
	"Method": "boolean containsPoint(Coordinate p){\r\n    LinearRing shell = getLinearRing();\r\n    Envelope env = shell.getEnvelopeInternal();\r\n    if (!env.contains(p))\r\n        return false;\r\n    if (!PointLocation.isInRing(p, shell.getCoordinates()))\r\n        return false;\r\n    for (Iterator i = holes.iterator(); i.hasNext(); ) {\r\n        EdgeRing hole = (EdgeRing) i.next();\r\n        if (hole.containsPoint(p))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.kse.crypto.ecc.EccUtil.isCurveAvailable",
	"Comment": "checks if the given named curve is known by the provider backing the keystoretype.",
	"Method": "boolean isCurveAvailable(String curveName,KeyStoreType keyStoreType){\r\n    if (isBouncyCastleKeyStore(keyStoreType)) {\r\n        return true;\r\n    }\r\n    if (availableSunCurves.length == 0) {\r\n        return false;\r\n    }\r\n    for (String curve : availableSunCurves) {\r\n        if (curve.contains(curveName)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.locationtech.jts.planargraph.DirectedEdge.print",
	"Comment": "prints a detailed string representation of this directededge to the given printstream.",
	"Method": "void print(PrintStream out){\r\n    String className = getClass().getName();\r\n    int lastDotPos = className.lastIndexOf('.');\r\n    String name = className.substring(lastDotPos + 1);\r\n    out.print(\"  \" + name + \": \" + p0 + \" - \" + p1 + \" \" + quadrant + \":\" + angle);\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.Vertex.interpolateZValue",
	"Comment": "for this vertex enclosed in a triangle defined by three vertices v0, v1 and v2, interpolatea z value from the surrounding vertices.",
	"Method": "double interpolateZValue(Vertex v0,Vertex v1,Vertex v2){\r\n    double x0 = v0.getX();\r\n    double y0 = v0.getY();\r\n    double a = v1.getX() - x0;\r\n    double b = v2.getX() - x0;\r\n    double c = v1.getY() - y0;\r\n    double d = v2.getY() - y0;\r\n    double det = a * d - b * c;\r\n    double dx = this.getX() - x0;\r\n    double dy = this.getY() - y0;\r\n    double t = (d * dx - b * dy) / det;\r\n    double u = (-c * dx + a * dy) / det;\r\n    double z = v0.getZ() + t * (v1.getZ() - v0.getZ()) + u * (v2.getZ() - v0.getZ());\r\n    return z;\r\n}"
}, {
	"Path": "com.android.launcher3.allapps.AlphabeticalAppsList.getAdapterItems",
	"Comment": "returns the current filtered list of applications broken down into their sections.",
	"Method": "List<AdapterItem> getAdapterItems(){\r\n    return mAdapterItems;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.requests.restaction.pagination.PaginationAction.cacheSize",
	"Comment": "the current amount of cached entities for this paginationaction",
	"Method": "int cacheSize(){\r\n    return cached.size();\r\n}"
}, {
	"Path": "com.android.launcher3.allapps.AlphabeticalAppsList.updateAdapterItems",
	"Comment": "updates the set of filtered apps with the current filter.at this point, we expectmcachedsectionnames to have been calculated for the set of all apps in mapps.",
	"Method": "void updateAdapterItems(){\r\n    SectionInfo lastSectionInfo = null;\r\n    String lastSectionName = null;\r\n    FastScrollSectionInfo lastFastScrollerSectionInfo = null;\r\n    int position = 0;\r\n    int appIndex = 0;\r\n    mFilteredApps.clear();\r\n    mFastScrollerSections.clear();\r\n    mAdapterItems.clear();\r\n    mSections.clear();\r\n    if (DEBUG_PREDICTIONS) {\r\n        if (mPredictedAppComponents.isEmpty() && !mApps.isEmpty()) {\r\n            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));\r\n            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));\r\n            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));\r\n            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));\r\n        }\r\n    }\r\n    mPredictedApps.clear();\r\n    if (mPredictedAppComponents != null && !mPredictedAppComponents.isEmpty() && !hasFilter()) {\r\n        for (ComponentKey ck : mPredictedAppComponents) {\r\n            AppInfo info = mComponentToAppMap.get(ck);\r\n            if (info != null) {\r\n                mPredictedApps.add(info);\r\n            } else {\r\n                if (LauncherAppState.isDogfoodBuild()) {\r\n                    Log.e(TAG, \"Predicted app not found: \" + ck.flattenToString(mLauncher));\r\n                }\r\n            }\r\n            if (mPredictedApps.size() == mNumPredictedAppsPerRow) {\r\n                break;\r\n            }\r\n        }\r\n        if (!mPredictedApps.isEmpty()) {\r\n            lastSectionInfo = new SectionInfo();\r\n            lastFastScrollerSectionInfo = new FastScrollSectionInfo(\"\");\r\n            AdapterItem sectionItem = AdapterItem.asSectionBreak(position++, lastSectionInfo);\r\n            mSections.add(lastSectionInfo);\r\n            mFastScrollerSections.add(lastFastScrollerSectionInfo);\r\n            mAdapterItems.add(sectionItem);\r\n            for (AppInfo info : mPredictedApps) {\r\n                AdapterItem appItem = AdapterItem.asPredictedApp(position++, lastSectionInfo, \"\", lastSectionInfo.numApps++, info, appIndex++);\r\n                if (lastSectionInfo.firstAppItem == null) {\r\n                    lastSectionInfo.firstAppItem = appItem;\r\n                    lastFastScrollerSectionInfo.fastScrollToItem = appItem;\r\n                }\r\n                mAdapterItems.add(appItem);\r\n                mFilteredApps.add(info);\r\n            }\r\n        }\r\n    }\r\n    for (AppInfo info : getFiltersAppInfos()) {\r\n        String sectionName = getAndUpdateCachedSectionName(info.title);\r\n        if (lastSectionInfo == null || !sectionName.equals(lastSectionName)) {\r\n            lastSectionName = sectionName;\r\n            lastSectionInfo = new SectionInfo();\r\n            lastFastScrollerSectionInfo = new FastScrollSectionInfo(sectionName);\r\n            mSections.add(lastSectionInfo);\r\n            mFastScrollerSections.add(lastFastScrollerSectionInfo);\r\n            if (!hasFilter()) {\r\n                AdapterItem sectionItem = AdapterItem.asSectionBreak(position++, lastSectionInfo);\r\n                mAdapterItems.add(sectionItem);\r\n            }\r\n        }\r\n        AdapterItem appItem = AdapterItem.asApp(position++, lastSectionInfo, sectionName, lastSectionInfo.numApps++, info, appIndex++);\r\n        if (lastSectionInfo.firstAppItem == null) {\r\n            lastSectionInfo.firstAppItem = appItem;\r\n            lastFastScrollerSectionInfo.fastScrollToItem = appItem;\r\n        }\r\n        mAdapterItems.add(appItem);\r\n        mFilteredApps.add(info);\r\n    }\r\n    if (hasFilter()) {\r\n        if (hasNoFilteredResults()) {\r\n            mAdapterItems.add(AdapterItem.asEmptySearch(position++));\r\n        } else {\r\n            mAdapterItems.add(AdapterItem.asDivider(position++));\r\n        }\r\n        mAdapterItems.add(AdapterItem.asMarketSearch(position++));\r\n    }\r\n    mergeSections();\r\n    if (mNumAppsPerRow != 0) {\r\n        int numAppsInSection = 0;\r\n        int numAppsInRow = 0;\r\n        int rowIndex = -1;\r\n        for (AdapterItem item : mAdapterItems) {\r\n            item.rowIndex = 0;\r\n            if (item.viewType == AllAppsGridAdapter.SECTION_BREAK_VIEW_TYPE) {\r\n                numAppsInSection = 0;\r\n            } else if (item.viewType == AllAppsGridAdapter.ICON_VIEW_TYPE || item.viewType == AllAppsGridAdapter.PREDICTION_ICON_VIEW_TYPE) {\r\n                if (numAppsInSection % mNumAppsPerRow == 0) {\r\n                    numAppsInRow = 0;\r\n                    rowIndex++;\r\n                }\r\n                item.rowIndex = rowIndex;\r\n                item.rowAppIndex = numAppsInRow;\r\n                numAppsInSection++;\r\n                numAppsInRow++;\r\n            }\r\n        }\r\n        mNumAppRowsInAdapter = rowIndex + 1;\r\n        switch(mFastScrollDistributionMode) {\r\n            case FAST_SCROLL_FRACTION_DISTRIBUTE_BY_ROWS_FRACTION:\r\n                float rowFraction = 1f / mNumAppRowsInAdapter;\r\n                for (FastScrollSectionInfo info : mFastScrollerSections) {\r\n                    AdapterItem item = info.fastScrollToItem;\r\n                    if (item.viewType != AllAppsGridAdapter.ICON_VIEW_TYPE && item.viewType != AllAppsGridAdapter.PREDICTION_ICON_VIEW_TYPE) {\r\n                        info.touchFraction = 0f;\r\n                        continue;\r\n                    }\r\n                    float subRowFraction = item.rowAppIndex * (rowFraction / mNumAppsPerRow);\r\n                    info.touchFraction = item.rowIndex * rowFraction + subRowFraction;\r\n                }\r\n                break;\r\n            case FAST_SCROLL_FRACTION_DISTRIBUTE_BY_NUM_SECTIONS:\r\n                float perSectionTouchFraction = 1f / mFastScrollerSections.size();\r\n                float cumulativeTouchFraction = 0f;\r\n                for (FastScrollSectionInfo info : mFastScrollerSections) {\r\n                    AdapterItem item = info.fastScrollToItem;\r\n                    if (item.viewType != AllAppsGridAdapter.ICON_VIEW_TYPE && item.viewType != AllAppsGridAdapter.PREDICTION_ICON_VIEW_TYPE) {\r\n                        info.touchFraction = 0f;\r\n                        continue;\r\n                    }\r\n                    info.touchFraction = cumulativeTouchFraction;\r\n                    cumulativeTouchFraction += perSectionTouchFraction;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    if (mAdapter != null) {\r\n        mAdapter.notifyDataSetChanged();\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.noding.FastSegmentSetIntersectionFinder.getSegmentSetIntersector",
	"Comment": "gets the segment set intersector used by this class.\tthis allows other uses of the same underlying indexed structure.",
	"Method": "SegmentSetMutualIntersector getSegmentSetIntersector(){\r\n    return segSetMutInt;\r\n}"
}, {
	"Path": "org.joda.money.Money.abs",
	"Comment": "returns a copy of this monetary value with a positive amount.this instance is immutable and unaffected by this method.",
	"Method": "Money abs(){\r\n    return (isNegative() ? negated() : this);\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.bindAppsUpdated",
	"Comment": "a package was updated.implementation of the method from launchermodel.callbacks.",
	"Method": "void bindAppsUpdated(ArrayList<AppInfo> apps){\r\n    Runnable r = new Runnable() {\r\n        public void run() {\r\n            bindAppsUpdated(apps);\r\n        }\r\n    };\r\n    if (waitUntilResume(r)) {\r\n        return;\r\n    }\r\n    if (mAppsView != null) {\r\n        mAppsView.updateApps(apps);\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.bindAppsUpdated",
	"Comment": "a package was updated.implementation of the method from launchermodel.callbacks.",
	"Method": "void bindAppsUpdated(ArrayList<AppInfo> apps){\r\n    bindAppsUpdated(apps);\r\n}"
}, {
	"Path": "org.locationtech.jts.util.GeometricShapeFactory.setRotation",
	"Comment": "sets the rotation angle to use for the shape.the rotation is applied relative to the centre of the shape.",
	"Method": "void setRotation(double radians){\r\n    rotationAngle = radians;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.EdgeRing.findDirEdgesInRing",
	"Comment": "traverses a ring of directededges, accumulating them into a list.this assumes that all dangling directed edges have been removedfrom the graph, so that there is always a next diredge.",
	"Method": "List findDirEdgesInRing(PolygonizeDirectedEdge startDE){\r\n    PolygonizeDirectedEdge de = startDE;\r\n    List edges = new ArrayList();\r\n    do {\r\n        edges.add(de);\r\n        de = de.getNext();\r\n        Assert.isTrue(de != null, \"found null DE in ring\");\r\n        Assert.isTrue(de == startDE || !de.isInRing(), \"found DE already in ring\");\r\n    } while (de != startDE);\r\n    return edges;\r\n}"
}, {
	"Path": "org.joda.money.BigMoney.isGreaterThan",
	"Comment": "checks if this monetary value is greater than another.the compared values must be in the same currency.",
	"Method": "boolean isGreaterThan(BigMoneyProvider other){\r\n    return compareTo(other) > 0;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.relate.RelateComputer.labelIsolatedNode",
	"Comment": "label an isolated node with its relationship to the target geometry.",
	"Method": "void labelIsolatedNode(Node n,int targetIndex){\r\n    int loc = ptLocator.locate(n.getCoordinate(), arg[targetIndex].getGeometry());\r\n    n.getLabel().setAllLocations(targetIndex, loc);\r\n}"
}, {
	"Path": "org.kse.gui.crypto.JValidityPeriod.getValidityPeriodMs",
	"Comment": "get chosen validity period in msecs, relative to validity start date.",
	"Method": "long getValidityPeriodMs(long getValidityPeriodMs,Date validityStart){\r\n    Date validityEnd = getValidityEnd(validityStart);\r\n    return validityEnd.getTime() - validityStart.getTime();\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isDay",
	"Comment": "isday returns true if string s is a valid day number between 1 and 31.",
	"Method": "boolean isDay(String s){\r\n    if (isEmpty(s))\r\n        return defaultEmptyOK;\r\n    return isIntegerInRange(s, 1, 31);\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.initialize",
	"Comment": "set this as the current launcher activity object for the loader.",
	"Method": "void initialize(Callbacks callbacks){\r\n    synchronized (mLock) {\r\n        unbindItemInfosAndClearQueuedBindRunnables();\r\n        mCallbacks = new WeakReference<Callbacks>(callbacks);\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.Workspace.findNearestArea",
	"Comment": "calculate the nearest cell where the given object would be dropped.pixelx and pixely should be in the coordinate system of layout",
	"Method": "int[] findNearestArea(int pixelX,int pixelY,int spanX,int spanY,CellLayout layout,int[] recycle){\r\n    return layout.findNearestArea(pixelX, pixelY, spanX, spanY, recycle);\r\n}"
}, {
	"Path": "org.joda.money.format.MoneyFormatterBuilder.appendCurrencySymbolLocalized",
	"Comment": "appends the localized currency symbol to the builder.the localized currency symbol is the symbol as chosen by the localeof the formatter.symbols cannot be parsed.",
	"Method": "MoneyFormatterBuilder appendCurrencySymbolLocalized(){\r\n    return appendInternal(SingletonPrinters.LOCALIZED_SYMBOL, null);\r\n}"
}, {
	"Path": "org.locationtech.jts.algorithm.MinimumBoundingCircle.getExtremalPoints",
	"Comment": "gets the extremal points which define the computed minimum bounding circle.\tthere may be zero, one, two or three of these points,\tdepending on the number of points in the input\tand the geometry of those points.",
	"Method": "Coordinate[] getExtremalPoints(){\r\n    compute();\r\n    return extremalPts;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.MessageBuilder.clear",
	"Comment": "clears the current builder. useful for mass message creation.",
	"Method": "MessageBuilder clear(){\r\n    this.builder.setLength(0);\r\n    this.embed = null;\r\n    this.isTTS = false;\r\n    return this;\r\n}"
}, {
	"Path": "com.jdon.bussinessproxy.remote.HessianToJdonServlet.service",
	"Comment": "servlet to handle incoming hessian requests and invoke hessiantojdonrequestprocessor.",
	"Method": "void service(ServletRequest req,ServletResponse resp){\r\n    HttpServletRequest request = (HttpServletRequest) req;\r\n    HttpServletResponse response = (HttpServletResponse) resp;\r\n    final String beanName = request.getPathInfo().substring(1);\r\n    htorp.process(beanName, request, response);\r\n}"
}, {
	"Path": "org.locationtech.jtstest.testrunner.BufferResultMatcher.isMatch",
	"Comment": "tests whether the two results are equal within the given\ttolerance.the input parameters are not considered.",
	"Method": "boolean isMatch(Geometry geom,String opName,Object[] args,Result actualResult,Result expectedResult,double tolerance){\r\n    if (!opName.equalsIgnoreCase(\"buffer\"))\r\n        return defaultMatcher.isMatch(geom, opName, args, actualResult, expectedResult, tolerance);\r\n    double distance = Double.parseDouble((String) args[0]);\r\n    return isBufferResultMatch(((GeometryResult) actualResult).getGeometry(), ((GeometryResult) expectedResult).getGeometry(), distance);\r\n}"
}, {
	"Path": "com.jdon.container.visitor.http.HttpSessionVisitorFactoryImp.createtVisitor",
	"Comment": "return a componentvisitor with cache. the httpsession is used for\toptimizing the component performance",
	"Method": "ComponentVisitor createtVisitor(SessionWrapper session,TargetMetaDef targetMetaDef){\r\n    if (session != null)\r\n        return createtSessionVisitor(session, targetMetaDef);\r\n    else\r\n        return new NoSessionProxyComponentVisitor(componentVisitor, targetMetaRequestsHolder);\r\n}"
}, {
	"Path": "com.android.launcher3.BaseContainerView.updateBackgroundAndPaddings",
	"Comment": "update the backgrounds and padding in response to a change in the bounds or insets.",
	"Method": "void updateBackgroundAndPaddings(){\r\n    Rect padding;\r\n    Rect searchBarBounds = new Rect();\r\n    if (!isValidSearchBarBounds(mFixedSearchBarBounds)) {\r\n        padding = new Rect(mInsets.left + mContainerBoundsInset, (mHasSearchBar ? 0 : (mInsets.top + mContainerBoundsInset)), mInsets.right + mContainerBoundsInset, mInsets.bottom + mContainerBoundsInset);\r\n        searchBarBounds.set(mInsets.left + mContainerBoundsInset, mInsets.top + mContainerBoundsInset, getMeasuredWidth() - (mInsets.right + mContainerBoundsInset), 0);\r\n    } else {\r\n        padding = new Rect(mFixedSearchBarBounds.left, (mHasSearchBar ? 0 : (mInsets.top + mContainerBoundsInset)), getMeasuredWidth() - mFixedSearchBarBounds.right, mInsets.bottom + mContainerBoundsInset);\r\n        searchBarBounds.set(mFixedSearchBarBounds);\r\n    }\r\n    if (!padding.equals(mContentPadding) || !searchBarBounds.equals(mSearchBarBounds)) {\r\n        mContentPadding.set(padding);\r\n        mContentBounds.set(padding.left, padding.top, getMeasuredWidth() - padding.right, getMeasuredHeight() - padding.bottom);\r\n        mSearchBarBounds.set(searchBarBounds);\r\n        onUpdateBackgroundAndPaddings(mSearchBarBounds, padding);\r\n    }\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.events.Event.getResponseNumber",
	"Comment": "the current sequence for this event.this can be used to keep events in order when making sequencing system.",
	"Method": "long getResponseNumber(){\r\n    return responseNumber;\r\n}"
}, {
	"Path": "org.joda.money.Money.withCurrencyUnit",
	"Comment": "returns a copy of this monetary value with the specified currency.the returned instance will have the specified currency and the amountfrom this instance. if the number of decimal places differs between thecurrencies, then the amount may be rounded.this instance is immutable and unaffected by this method.",
	"Method": "Money withCurrencyUnit(CurrencyUnit currency,Money withCurrencyUnit,CurrencyUnit currency,RoundingMode roundingMode){\r\n    return with(money.withCurrencyUnit(currency).withCurrencyScale(roundingMode));\r\n}"
}, {
	"Path": "org.kse.gui.RecentKeyStoreFileActionListener.actionPerformed",
	"Comment": "action to perform to open the keystore file in response to an\tactionevent.",
	"Method": "void actionPerformed(ActionEvent evt){\r\n    kseFrame.setDefaultStatusBarText();\r\n    if (!recentFile.isFile()) {\r\n        JMenuItemRecentFile jmiRecentFile = (JMenuItemRecentFile) evt.getSource();\r\n        JMenuRecentFiles jmRecentFiles = jmiRecentFile.getRecentFilesMenu();\r\n        jmRecentFiles.invalidate(jmiRecentFile);\r\n        JOptionPane.showMessageDialog(kseFrame.getUnderlyingFrame(), MessageFormat.format(res.getString(\"RecentKeyStoreFileActionListener.NotFile.message\"), recentFile), res.getString(\"RecentKeyStoreFileActionListener.OpenKeyStore.Title\"), JOptionPane.WARNING_MESSAGE);\r\n        return;\r\n    }\r\n    OpenAction openAction = new OpenAction(kseFrame);\r\n    openAction.openKeyStore(recentFile);\r\n}"
}, {
	"Path": "com.jdon.async.disruptor.ValueEventProcessor.waitForBlocking",
	"Comment": "not really block, the waiting time is longer than not block.",
	"Method": "EventResultDisruptor waitForBlocking(){\r\n    SequenceBarrier barrier = ringBuffer.newBarrier();\r\n    try {\r\n        long a = barrier.waitFor(waitAtSequence);\r\n        if (ringBuffer != null)\r\n            return ringBuffer.get(a);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    } finally {\r\n        barrier.alert();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.util.AffineTransformation.setToReflectionBasic",
	"Comment": "explicitly computes the math for a reflection.may not work.",
	"Method": "AffineTransformation setToReflectionBasic(double x0,double y0,double x1,double y1){\r\n    if (x0 == x1 && y0 == y1) {\r\n        throw new IllegalArgumentException(\"Reflection line points must be distinct\");\r\n    }\r\n    double dx = x1 - x0;\r\n    double dy = y1 - y0;\r\n    double d = Math.sqrt(dx * dx + dy * dy);\r\n    double sin = dy / d;\r\n    double cos = dx / d;\r\n    double cs2 = 2 * sin * cos;\r\n    double c2s2 = cos * cos - sin * sin;\r\n    m00 = c2s2;\r\n    m01 = cs2;\r\n    m02 = 0.0;\r\n    m10 = cs2;\r\n    m11 = -c2s2;\r\n    m12 = 0.0;\r\n    return this;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.union.CascadedPolygonUnion.union",
	"Comment": "computes the union of the input geometries.\tthis method discards the input geometries as they are processed.\tin many input cases this reduces the memory retained\tas the operation proceeds. \toptimal memory usage is achieved \tby disposing of the original input collection \tbefore calling this method.",
	"Method": "Geometry union(Collection polys,Geometry union){\r\n    if (inputPolys == null)\r\n        throw new IllegalStateException(\"union() method cannot be called twice\");\r\n    if (inputPolys.isEmpty())\r\n        return null;\r\n    geomFactory = ((Geometry) inputPolys.iterator().next()).getFactory();\r\n    STRtree index = new STRtree(STRTREE_NODE_CAPACITY);\r\n    for (Iterator i = inputPolys.iterator(); i.hasNext(); ) {\r\n        Geometry item = (Geometry) i.next();\r\n        index.insert(item.getEnvelopeInternal(), item);\r\n    }\r\n    inputPolys = null;\r\n    List itemTree = index.itemsTree();\r\n    Geometry unionAll = unionTree(itemTree);\r\n    return unionAll;\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.DocumentReader.skip",
	"Comment": "skip characters of input.this method will always skip the maximum number of characters unlessthe end of the file is reached.",
	"Method": "long skip(long n){\r\n    if (this.position + n <= this.document.getLength()) {\r\n        this.position += n;\r\n        return n;\r\n    } else {\r\n        long oldPos = this.position;\r\n        this.position = this.document.getLength();\r\n        return this.document.getLength() - oldPos;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.OffsetSegmentGenerator.computeOffsetSegment",
	"Comment": "compute an offset segment for an input segment on a given side and at a given distance.the offset points are computed in full double precision, for accuracy.",
	"Method": "void computeOffsetSegment(LineSegment seg,int side,double distance,LineSegment offset){\r\n    int sideSign = side == Position.LEFT ? 1 : -1;\r\n    double dx = seg.p1.x - seg.p0.x;\r\n    double dy = seg.p1.y - seg.p0.y;\r\n    double len = Math.sqrt(dx * dx + dy * dy);\r\n    double ux = sideSign * distance * dx / len;\r\n    double uy = sideSign * distance * dy / len;\r\n    offset.p0.x = seg.p0.x - uy;\r\n    offset.p0.y = seg.p0.y + ux;\r\n    offset.p1.x = seg.p1.x - uy;\r\n    offset.p1.y = seg.p1.y + ux;\r\n}"
}, {
	"Path": "com.android.launcher3.AutoInstallsLayout.parseAndAddNode",
	"Comment": "parses the current node and returns the number of elements added.",
	"Method": "int parseAndAddNode(XmlResourceParser parser,HashMap<String, TagParser> tagParserMap,ArrayList<Long> screenIds){\r\n    if (TAG_INCLUDE.equals(parser.getName())) {\r\n        final int resId = getAttributeResourceValue(parser, ATTR_WORKSPACE, 0);\r\n        if (resId != 0) {\r\n            return parseLayout(resId, screenIds);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n    mValues.clear();\r\n    parseContainerAndScreen(parser, mTemp);\r\n    final long container = mTemp[0];\r\n    final long screenId = mTemp[1];\r\n    mValues.put(Favorites.CONTAINER, container);\r\n    mValues.put(Favorites.SCREEN, screenId);\r\n    mValues.put(Favorites.CELLX, getAttributeValue(parser, ATTR_X));\r\n    mValues.put(Favorites.CELLY, getAttributeValue(parser, ATTR_Y));\r\n    TagParser tagParser = tagParserMap.get(parser.getName());\r\n    if (tagParser == null) {\r\n        if (LOGD)\r\n            Log.d(TAG, \"Ignoring unknown element tag: \" + parser.getName());\r\n        return 0;\r\n    }\r\n    long newElementId = tagParser.parseAndAdd(parser);\r\n    if (newElementId >= 0) {\r\n        if (!screenIds.contains(screenId) && container == Favorites.CONTAINER_DESKTOP) {\r\n            screenIds.add(screenId);\r\n        }\r\n        return 1;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.Segment.intersection",
	"Comment": "computes the intersection point between this segment and another one.",
	"Method": "Coordinate intersection(Segment s){\r\n    return ls.intersection(s.getLineSegment());\r\n}"
}, {
	"Path": "org.locationtech.jtstest.geomop.GeometryFunctionRegistry.find",
	"Comment": "finds the first function which matches the given name and argument count.",
	"Method": "GeometryFunction find(String name,int argCount,GeometryFunction find,String name){\r\n    for (Iterator i = functions.iterator(); i.hasNext(); ) {\r\n        GeometryFunction func = (GeometryFunction) i.next();\r\n        String funcName = func.getName();\r\n        if (funcName.equalsIgnoreCase(name))\r\n            return func;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.locationtech.jts.io.kml.KMLWriterTest.normalizeKML",
	"Comment": "normalizes an xml string by converting all whitespace to a single blank char.",
	"Method": "String normalizeKML(String kml){\r\n    String condenseSpace = kml.replaceAll(\"\\\\s+\", \" \").trim();\r\n    String removeRedundantSpace = condenseSpace.replaceAll(\"> <\", \"><\");\r\n    return removeRedundantSpace;\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.DocPosition.adjustPosition",
	"Comment": "adjust this position.this is useful in cases that an amount of text is insertedor removed before this position.",
	"Method": "DocPosition adjustPosition(int adjustment){\r\n    this.position += adjustment;\r\n    return this;\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.updateSessionDisplayInfo",
	"Comment": "updates the icons and label of all pending icons for the provided package name.",
	"Method": "void updateSessionDisplayInfo(String packageName){\r\n    Runnable updateRunnable = new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            synchronized (sBgLock) {\r\n                final ArrayList<ShortcutInfo> updates = new ArrayList();\r\n                final UserHandleCompat user = UserHandleCompat.myUserHandle();\r\n                for (ItemInfo info : sBgItemsIdMap) {\r\n                    if (info instanceof ShortcutInfo) {\r\n                        ShortcutInfo si = (ShortcutInfo) info;\r\n                        ComponentName cn = si.getTargetComponent();\r\n                        if (si.isPromise() && (cn != null) && packageName.equals(cn.getPackageName())) {\r\n                            if (si.hasStatusFlag(ShortcutInfo.FLAG_AUTOINTALL_ICON)) {\r\n                                mIconCache.getTitleAndIcon(si, si.promisedIntent, user, si.shouldUseLowResIcon());\r\n                            } else {\r\n                                si.updateIcon(mIconCache);\r\n                            }\r\n                            updates.add(si);\r\n                        }\r\n                    }\r\n                }\r\n                if (!updates.isEmpty()) {\r\n                    Runnable r = new Runnable() {\r\n                        public void run() {\r\n                            Callbacks callbacks = getCallback();\r\n                            if (callbacks != null) {\r\n                                callbacks.bindShortcutsChanged(updates, new ArrayList<ShortcutInfo>(), user);\r\n                            }\r\n                        }\r\n                    };\r\n                    mHandler.post(r);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    runOnWorkerThread(updateRunnable);\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.updateSessionDisplayInfo",
	"Comment": "updates the icons and label of all pending icons for the provided package name.",
	"Method": "void updateSessionDisplayInfo(String packageName){\r\n    synchronized (sBgLock) {\r\n        final ArrayList<ShortcutInfo> updates = new ArrayList();\r\n        final UserHandleCompat user = UserHandleCompat.myUserHandle();\r\n        for (ItemInfo info : sBgItemsIdMap) {\r\n            if (info instanceof ShortcutInfo) {\r\n                ShortcutInfo si = (ShortcutInfo) info;\r\n                ComponentName cn = si.getTargetComponent();\r\n                if (si.isPromise() && (cn != null) && packageName.equals(cn.getPackageName())) {\r\n                    if (si.hasStatusFlag(ShortcutInfo.FLAG_AUTOINTALL_ICON)) {\r\n                        mIconCache.getTitleAndIcon(si, si.promisedIntent, user, si.shouldUseLowResIcon());\r\n                    } else {\r\n                        si.updateIcon(mIconCache);\r\n                    }\r\n                    updates.add(si);\r\n                }\r\n            }\r\n        }\r\n        if (!updates.isEmpty()) {\r\n            Runnable r = new Runnable() {\r\n                public void run() {\r\n                    Callbacks callbacks = getCallback();\r\n                    if (callbacks != null) {\r\n                        callbacks.bindShortcutsChanged(updates, new ArrayList<ShortcutInfo>(), user);\r\n                    }\r\n                }\r\n            };\r\n            mHandler.post(r);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.updateSessionDisplayInfo",
	"Comment": "updates the icons and label of all pending icons for the provided package name.",
	"Method": "void updateSessionDisplayInfo(String packageName){\r\n    Callbacks callbacks = getCallback();\r\n    if (callbacks != null) {\r\n        callbacks.bindShortcutsChanged(updates, new ArrayList<ShortcutInfo>(), user);\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.CellLayout.findNearestArea",
	"Comment": "find a starting cell position that will fit the given bounds nearest the requestedcell location. uses euclidean distance to score multiple vacant areas.",
	"Method": "int[] findNearestArea(int pixelX,int pixelY,int minSpanX,int minSpanY,int spanX,int spanY,boolean ignoreOccupied,int[] result,int[] resultSpan,int[] findNearestArea,int cellX,int cellY,int spanX,int spanY,int[] direction,boolean[][] occupied,boolean blockOccupied,int[] result,int[] findNearestArea,int pixelX,int pixelY,int spanX,int spanY,int[] result){\r\n    return findNearestArea(pixelX, pixelY, spanX, spanY, spanX, spanY, false, result, null);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.Polygonizer.getInvalidRingLines",
	"Comment": "gets the list of lines forming invalid rings found during polygonization.",
	"Method": "Collection getInvalidRingLines(){\r\n    polygonize();\r\n    return invalidRingLines;\r\n}"
}, {
	"Path": "org.kse.gui.KeyStoreTableColumns.getNofColumns",
	"Comment": "get number of columns selected. the actual table has 3 columns more, as the first 3 are fixed.",
	"Method": "int getNofColumns(){\r\n    int col = 0;\r\n    if (bEnableEntryName) {\r\n        col++;\r\n    }\r\n    if (bEnableAlgorithm) {\r\n        col++;\r\n    }\r\n    if (bEnableKeySize) {\r\n        col++;\r\n    }\r\n    if (bEnableCertificateExpiry) {\r\n        col++;\r\n    }\r\n    if (bEnableLastModified) {\r\n        col++;\r\n    }\r\n    if (bEnableSKI) {\r\n        col++;\r\n    }\r\n    if (bEnableAKI) {\r\n        col++;\r\n    }\r\n    if (bEnableIssuerDN) {\r\n        col++;\r\n    }\r\n    if (bEnableSubjectDN) {\r\n        col++;\r\n    }\r\n    if (bEnableCurve) {\r\n        col++;\r\n    }\r\n    if (bEnableIssuerCN) {\r\n        col++;\r\n    }\r\n    if (bEnableSubjectCN) {\r\n        col++;\r\n    }\r\n    if (bEnableIssuerO) {\r\n        col++;\r\n    }\r\n    if (bEnableSubjectO) {\r\n        col++;\r\n    }\r\n    return col;\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.runOnWorkerThread",
	"Comment": "runs the specified runnable immediately if called from the worker thread, otherwise it isposted on the worker thread handler.",
	"Method": "void runOnWorkerThread(Runnable r){\r\n    if (sWorkerThread.getThreadId() == Process.myTid()) {\r\n        r.run();\r\n    } else {\r\n        sWorker.post(r);\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.IconCache.cachePackageInstallInfo",
	"Comment": "adds a default package entry in the cache. this entry is not persisted and will be removedwhen the cache is flushed.",
	"Method": "void cachePackageInstallInfo(String packageName,UserHandleCompat user,Bitmap icon,CharSequence title){\r\n    removeFromMemCacheLocked(packageName, user);\r\n    ComponentKey cacheKey = getPackageKey(packageName, user);\r\n    CacheEntry entry = mCache.get(cacheKey);\r\n    if (entry == null) {\r\n        entry = new CacheEntry();\r\n        mCache.put(cacheKey, entry);\r\n    }\r\n    if (!TextUtils.isEmpty(title)) {\r\n        entry.title = title;\r\n    }\r\n    if (icon != null) {\r\n        entry.icon = Utilities.createIconBitmap(icon, mContext);\r\n    }\r\n}"
}, {
	"Path": "com.jdon.cache.UtilCache.setExpireTime",
	"Comment": "sets the expire time for the cache elements. if 0, elements never expire.",
	"Method": "void setExpireTime(long expireTime){\r\n    if (this.expireTime <= 0 && expireTime > 0) {\r\n        long currentTime = System.currentTimeMillis();\r\n        Iterator values = cacheLineTable.values().iterator();\r\n        while (values.hasNext()) {\r\n            CacheLine line = (CacheLine) values.next();\r\n            line.setLoadTime(currentTime);\r\n        }\r\n    } else if (this.expireTime <= 0 && expireTime > 0) {\r\n    }\r\n    this.expireTime = expireTime;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.Maybe.toEither",
	"Comment": "if this value is absent, return the value supplied by lsupplier wrapped in either.left.otherwise, wrap the value in either.right and return it.",
	"Method": "Either<L, A> toEither(Supplier<L> lSupplier){\r\n    return fmap(Either::<L, A>right).orElseGet(() -> left(lSupplier.get()));\r\n}"
}, {
	"Path": "org.kse.gui.KseFrame.removeKeyStore",
	"Comment": "removed the supplied keystore from the set of loaded keystores.",
	"Method": "void removeKeyStore(KeyStore keyStore){\r\n    int index = findKeyStoreIndex(keyStore);\r\n    if (index >= 0) {\r\n        keyStoreTables.remove(index);\r\n        histories.remove(index).nullPasswords();\r\n        jkstpKeyStores.remove(index);\r\n    }\r\n}"
}, {
	"Path": "com.jsql.util.ThreadUtil.remove",
	"Comment": "remove the thread corresponding to the component in order to begarbage collected. the thread should be stopped prior the deletion.",
	"Method": "void remove(AbstractElementDatabase elementDatabase){\r\n    ThreadUtil.suspendables.remove(elementDatabase);\r\n}"
}, {
	"Path": "org.locationtech.jts.io.oracle.OraWriterCreateTest.INVALID_testXY_RectangleMultiPolygon",
	"Comment": "orawriter does not support writing polygons with more than one ring as rectangles,so these tests are disabled.",
	"Method": "void INVALID_testXY_RectangleMultiPolygon(){\r\n    OraGeom oraGeom = MDSYS.SDO_GEOMETRY(2007, NULL, NULL, MDSYS.SDO_ELEM_INFO_ARRAY(1, 1003, 3, 5, 2003, 3, 9, 1003, 3), MDSYS.SDO_ORDINATE_ARRAY(0, 0, 50, 50, 40, 40, 20, 20, 60, 0, 70, 10));\r\n    checkValueRectangle(oraGeom, \"MULTIPOLYGON (((0 0, 50 0, 50 50, 0 50, 0 0), (40 40, 20 40, 20 20, 40 20, 40 40)), ((60 0, 70 0, 70 10, 60 10, 60 0)))\");\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.BufferInputLineSimplifier.deleteShallowConcavities",
	"Comment": "uses a sliding window containing 3 vertices to detect shallow anglesin which the middle vertex can be deleted, since it does notaffect the shape of the resulting buffer in a significant way.",
	"Method": "boolean deleteShallowConcavities(){\r\n    int index = 1;\r\n    int midIndex = findNextNonDeletedIndex(index);\r\n    int lastIndex = findNextNonDeletedIndex(midIndex);\r\n    boolean isChanged = false;\r\n    while (lastIndex < inputLine.length) {\r\n        boolean isMiddleVertexDeleted = false;\r\n        if (isDeletable(index, midIndex, lastIndex, distanceTol)) {\r\n            isDeleted[midIndex] = DELETE;\r\n            isMiddleVertexDeleted = true;\r\n            isChanged = true;\r\n        }\r\n        if (isMiddleVertexDeleted)\r\n            index = lastIndex;\r\n        else\r\n            index = midIndex;\r\n        midIndex = findNextNonDeletedIndex(index);\r\n        lastIndex = findNextNonDeletedIndex(midIndex);\r\n    }\r\n    return isChanged;\r\n}"
}, {
	"Path": "org.locationtech.jts.simplify.DouglasPeuckerLineSimplifier.setDistanceTolerance",
	"Comment": "sets the distance tolerance for the simplification.all vertices in the simplified linestring will be within thisdistance of the original linestring.",
	"Method": "void setDistanceTolerance(double distanceTolerance){\r\n    this.distanceTolerance = distanceTolerance;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct5.diverge",
	"Comment": "diverge this coproduct by introducing another possible type that it could represent.",
	"Method": "CoProduct6<A, B, C, D, E, F, ? extends CoProduct6<A, B, C, D, E, F, ?>> diverge(){\r\n    return new CoProduct6<A, B, C, D, E, F, CoProduct6<A, B, C, D, E, F, ?>>() {\r\n        @Override\r\n        public <R> R match(Function<? super A, ? extends R> aFn, Function<? super B, ? extends R> bFn, Function<? super C, ? extends R> cFn, Function<? super D, ? extends R> dFn, Function<? super E, ? extends R> eFn, Function<? super F, ? extends R> fFn) {\r\n            return CoProduct5.this.match(aFn, bFn, cFn, dFn, eFn);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct5.diverge",
	"Comment": "diverge this coproduct by introducing another possible type that it could represent.",
	"Method": "CoProduct6<A, B, C, D, E, F, ? extends CoProduct6<A, B, C, D, E, F, ?>> diverge(){\r\n    return CoProduct5.this.match(aFn, bFn, cFn, dFn, eFn);\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.findSpaceForItem",
	"Comment": "find a position on the screen for the given size or adds a new screen.",
	"Method": "Pair<Long, int[]> findSpaceForItem(Context context,ArrayList<Long> workspaceScreens,ArrayList<Long> addedWorkspaceScreensFinal,int spanX,int spanY){\r\n    LongSparseArray<ArrayList<ItemInfo>> screenItems = new LongSparseArray();\r\n    assertWorkspaceLoaded();\r\n    synchronized (sBgLock) {\r\n        for (ItemInfo info : sBgItemsIdMap) {\r\n            if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {\r\n                ArrayList<ItemInfo> items = screenItems.get(info.screenId);\r\n                if (items == null) {\r\n                    items = new ArrayList();\r\n                    screenItems.put(info.screenId, items);\r\n                }\r\n                items.add(info);\r\n            }\r\n        }\r\n    }\r\n    long screenId = 0;\r\n    int[] cordinates = new int[2];\r\n    boolean found = false;\r\n    int screenCount = workspaceScreens.size();\r\n    int preferredScreenIndex = workspaceScreens.isEmpty() ? 0 : 1;\r\n    if (preferredScreenIndex < screenCount) {\r\n        screenId = workspaceScreens.get(preferredScreenIndex);\r\n        found = findNextAvailableIconSpaceInScreen(screenItems.get(screenId), cordinates, spanX, spanY);\r\n    }\r\n    if (!found) {\r\n        for (int screen = 1; screen < screenCount; screen++) {\r\n            screenId = workspaceScreens.get(screen);\r\n            if (findNextAvailableIconSpaceInScreen(screenItems.get(screenId), cordinates, spanX, spanY)) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (!found) {\r\n        screenId = LauncherAppState.getLauncherProvider().generateNewScreenId();\r\n        workspaceScreens.add(screenId);\r\n        addedWorkspaceScreensFinal.add(screenId);\r\n        if (!findNextAvailableIconSpaceInScreen(screenItems.get(screenId), cordinates, spanX, spanY)) {\r\n            throw new RuntimeException(\"Can't find space to add the item\");\r\n        }\r\n    }\r\n    return Pair.create(screenId, cordinates);\r\n}"
}, {
	"Path": "org.zeromq.ZContext.destroySocket",
	"Comment": "destroys managed socket within this context and remove from sockets list",
	"Method": "void destroySocket(Socket s){\r\n    if (s == null)\r\n        return;\r\n    if (sockets.contains(s)) {\r\n        try {\r\n            s.setLinger(linger);\r\n        } catch (ZMQException e) {\r\n            if (e.getErrorCode() != ZMQ.ETERM()) {\r\n                throw e;\r\n            }\r\n        }\r\n        s.close();\r\n        sockets.remove(s);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.NodeFactory.createNode",
	"Comment": "the basic node constructor does not allow for incident edges",
	"Method": "Node createNode(Coordinate coord){\r\n    return new Node(coord, null);\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdge.invRot",
	"Comment": "gets the dual of this edge, directed from its left to its right.",
	"Method": "QuadEdge invRot(){\r\n    return rot.sym();\r\n}"
}, {
	"Path": "com.android.launcher3.Launcher.hasFirstRunActivity",
	"Comment": "to be overridden by subclasses to indicate that there is an activity to launchbefore showing the standard launcher experience.",
	"Method": "boolean hasFirstRunActivity(){\r\n    if (mLauncherCallbacks != null) {\r\n        return mLauncherCallbacks.hasFirstRunActivity();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DDIOTest.writeRepeatedSqrt",
	"Comment": "this routine simply tests for robustness of the tostring function.",
	"Method": "void writeRepeatedSqrt(DD xdd){\r\n    int count = 0;\r\n    while (xdd.doubleValue() > 1e-300) {\r\n        count++;\r\n        double x = xdd.doubleValue();\r\n        DD xSqrt = xdd.sqrt();\r\n        String s = xSqrt.toString();\r\n        DD xSqrt2 = DD.parse(s);\r\n        DD xx = xSqrt2.multiply(xSqrt2);\r\n        double err = Math.abs(xx.doubleValue() - x);\r\n        xdd = xSqrt;\r\n        DD distFrom1DD = xSqrt.subtract(DD.valueOf(1.0));\r\n        double distFrom1 = distFrom1DD.doubleValue();\r\n        if (Math.abs(distFrom1) < 1.0e-40)\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.GeometryFactory.getPrecisionModel",
	"Comment": "returns the precisionmodel that geometries created by this factorywill be associated with.",
	"Method": "PrecisionModel getPrecisionModel(){\r\n    return precisionModel;\r\n}"
}, {
	"Path": "com.android.launcher3.Hotseat.setOnLongClickListener",
	"Comment": "registers the specified listener on the cell layout of the hotseat.",
	"Method": "void setOnLongClickListener(OnLongClickListener l){\r\n    mContent.setOnLongClickListener(l);\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isUSPhoneMainNumber",
	"Comment": "isusphonemainnumber returns true if string s is a valid u.s. phone main number.must be 7 digits.",
	"Method": "boolean isUSPhoneMainNumber(String s){\r\n    if (isEmpty(s))\r\n        return defaultEmptyOK;\r\n    String normalizedPhone = stripCharsInBag(s, phoneNumberDelimiters);\r\n    return (isInteger(normalizedPhone) && normalizedPhone.length() == digitsInUSPhoneMainNumber);\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.DirectedEdgeStar.updateLabelling",
	"Comment": "update incomplete diredge labels from the labelling for the node",
	"Method": "void updateLabelling(Label nodeLabel){\r\n    for (Iterator it = iterator(); it.hasNext(); ) {\r\n        DirectedEdge de = (DirectedEdge) it.next();\r\n        Label label = de.getLabel();\r\n        label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));\r\n        label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.util.AffineTransformation.translate",
	"Comment": "updates the value of this transformationto that of a translation transformation composed with the current value.",
	"Method": "AffineTransformation translate(double x,double y){\r\n    compose(translationInstance(x, y));\r\n    return this;\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DD.sqrt",
	"Comment": "computes the positive square root of this value.if the number is nan or negative, nan is returned.",
	"Method": "DD sqrt(DD sqrt,double x){\r\n    return valueOf(x).sqrt();\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.OffsetSegmentGenerator.addLineEndCap",
	"Comment": "add an end cap around point p1, terminating a line segment coming from p0",
	"Method": "void addLineEndCap(Coordinate p0,Coordinate p1){\r\n    LineSegment seg = new LineSegment(p0, p1);\r\n    LineSegment offsetL = new LineSegment();\r\n    computeOffsetSegment(seg, Position.LEFT, distance, offsetL);\r\n    LineSegment offsetR = new LineSegment();\r\n    computeOffsetSegment(seg, Position.RIGHT, distance, offsetR);\r\n    double dx = p1.x - p0.x;\r\n    double dy = p1.y - p0.y;\r\n    double angle = Math.atan2(dy, dx);\r\n    switch(bufParams.getEndCapStyle()) {\r\n        case BufferParameters.CAP_ROUND:\r\n            segList.addPt(offsetL.p1);\r\n            addDirectedFillet(p1, angle + Math.PI / 2, angle - Math.PI / 2, Orientation.CLOCKWISE, distance);\r\n            segList.addPt(offsetR.p1);\r\n            break;\r\n        case BufferParameters.CAP_FLAT:\r\n            segList.addPt(offsetL.p1);\r\n            segList.addPt(offsetR.p1);\r\n            break;\r\n        case BufferParameters.CAP_SQUARE:\r\n            Coordinate squareCapSideOffset = new Coordinate();\r\n            squareCapSideOffset.x = Math.abs(distance) * Math.cos(angle);\r\n            squareCapSideOffset.y = Math.abs(distance) * Math.sin(angle);\r\n            Coordinate squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);\r\n            Coordinate squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);\r\n            segList.addPt(squareCapLOffset);\r\n            segList.addPt(squareCapROffset);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.index.strtree.AbstractSTRtree.build",
	"Comment": "creates parent nodes, grandparent nodes, and so forth up to the rootnode, for the data that has been inserted into the tree. can only becalled once, and thus can be called only after all of the data has beeninserted into the tree.",
	"Method": "void build(){\r\n    if (built)\r\n        return;\r\n    root = itemBoundables.isEmpty() ? createNode(0) : createHigherLevels(itemBoundables, -1);\r\n    itemBoundables = null;\r\n    built = true;\r\n}"
}, {
	"Path": "org.kse.utilities.net.ManualProxySelector.equals",
	"Comment": "is this manualproxyselector object equal to another object?",
	"Method": "boolean equals(Object object){\r\n    if (object == this) {\r\n        return true;\r\n    }\r\n    if (!(object instanceof ManualProxySelector)) {\r\n        return false;\r\n    }\r\n    ManualProxySelector cmpManualProxySelector = (ManualProxySelector) object;\r\n    ProxyAddress proxyHttpAddress = this.getHttpProxyAddress();\r\n    ProxyAddress cmpHttpProxyAddress = cmpManualProxySelector.getHttpProxyAddress();\r\n    boolean httpEquals = (proxyHttpAddress == null ? cmpHttpProxyAddress == null : proxyHttpAddress.equals(cmpHttpProxyAddress));\r\n    if (!httpEquals) {\r\n        return false;\r\n    }\r\n    ProxyAddress proxyHttpsAddress = this.getHttpsProxyAddress();\r\n    ProxyAddress cmpHttpsProxyAddress = cmpManualProxySelector.getHttpsProxyAddress();\r\n    boolean httpsEquals = (proxyHttpsAddress == null ? cmpHttpsProxyAddress == null : proxyHttpsAddress.equals(cmpHttpsProxyAddress));\r\n    if (!httpsEquals) {\r\n        return false;\r\n    }\r\n    ProxyAddress proxyFtpAddress = this.getFtpProxyAddress();\r\n    ProxyAddress cmpFtpProxyAddress = cmpManualProxySelector.getFtpProxyAddress();\r\n    boolean ftpEquals = (proxyFtpAddress == null ? cmpFtpProxyAddress == null : proxyFtpAddress.equals(cmpFtpProxyAddress));\r\n    if (!ftpEquals) {\r\n        return false;\r\n    }\r\n    ProxyAddress proxySocksAddress = this.getSocksProxyAddress();\r\n    ProxyAddress cmpSocksProxyAddress = cmpManualProxySelector.getSocksProxyAddress();\r\n    boolean socksEquals = (proxySocksAddress == null ? cmpSocksProxyAddress == null : proxySocksAddress.equals(cmpSocksProxyAddress));\r\n    return socksEquals;\r\n}"
}, {
	"Path": "net.dv8tion.jda.webhook.WebhookMessageBuilder.setAvatarUrl",
	"Comment": "sets the avatar url that should be used for the resulting message.this will override the default avatar of the webhook.",
	"Method": "WebhookMessageBuilder setAvatarUrl(String avatarUrl){\r\n    this.avatarUrl = Helpers.isBlank(avatarUrl) ? null : avatarUrl;\r\n    return this;\r\n}"
}, {
	"Path": "org.locationtech.jts.index.bintree.Root.insertContained",
	"Comment": "insert an item which is known to be contained in the tree rooted atthe given node.lower levels of the tree will be createdif necessary to hold the item.",
	"Method": "void insertContained(Node tree,Interval itemInterval,Object item){\r\n    Assert.isTrue(tree.getInterval().contains(itemInterval));\r\n    boolean isZeroArea = IntervalSize.isZeroWidth(itemInterval.getMin(), itemInterval.getMax());\r\n    NodeBase node;\r\n    if (isZeroArea)\r\n        node = tree.find(itemInterval);\r\n    else\r\n        node = tree.getNode(itemInterval);\r\n    node.add(item);\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.utils.KubernetesResourceUtil.hasResourceVersion",
	"Comment": "returns true if this entity has a valid non blank resourceversion in its metadata",
	"Method": "boolean hasResourceVersion(HasMetadata entity){\r\n    return getResourceVersion(entity) != null;\r\n}"
}, {
	"Path": "com.android.launcher3.allapps.AllAppsRecyclerView.smoothSnapToPosition",
	"Comment": "smoothly snaps to a given position.we do this manually by calculating the keyframesourselves and animating the scroll on the recycler view.",
	"Method": "void smoothSnapToPosition(int position,ScrollPositionState scrollPosState){\r\n    removeCallbacks(mSmoothSnapNextFrameRunnable);\r\n    int curScrollY = getPaddingTop() + (scrollPosState.rowIndex * scrollPosState.rowHeight) - scrollPosState.rowTopOffset;\r\n    int newScrollY = getScrollAtPosition(position, scrollPosState.rowHeight);\r\n    int numFrames = mFastScrollFrames.length;\r\n    for (int i = 0; i < numFrames; i++) {\r\n        mFastScrollFrames[i] = (newScrollY - curScrollY) / numFrames;\r\n    }\r\n    mFastScrollFrameIndex = 0;\r\n    postOnAnimation(mSmoothSnapNextFrameRunnable);\r\n}"
}, {
	"Path": "com.jdon.util.jdom.XMLFilterBase.setProperty",
	"Comment": "set the value of a property.this will always fail if the parent is null.",
	"Method": "void setProperty(String name,Object value){\r\n    for (int i = 0; i < LEXICAL_HANDLER_NAMES.length; i++) {\r\n        if (LEXICAL_HANDLER_NAMES[i].equals(name)) {\r\n            setLexicalHandler((LexicalHandler) value);\r\n            return;\r\n        }\r\n    }\r\n    super.setProperty(name, value);\r\n}"
}, {
	"Path": "com.android.launcher3.util.ManagedProfileHeuristic.processUserApps",
	"Comment": "checks the list of user apps and adds icons for newly installed apps on the homescreen orworkfolder.",
	"Method": "void processUserApps(List<LauncherActivityInfoCompat> apps){\r\n    mHomescreenApps = new ArrayList();\r\n    mWorkFolderApps = new ArrayList();\r\n    HashSet<String> packageSet = new HashSet();\r\n    final boolean userAppsExisted = getUserApps(packageSet);\r\n    boolean newPackageAdded = false;\r\n    for (LauncherActivityInfoCompat info : apps) {\r\n        String packageName = info.getComponentName().getPackageName();\r\n        if (!packageSet.contains(packageName)) {\r\n            packageSet.add(packageName);\r\n            newPackageAdded = true;\r\n            try {\r\n                PackageInfo pkgInfo = mContext.getPackageManager().getPackageInfo(packageName, PackageManager.GET_UNINSTALLED_PACKAGES);\r\n                markForAddition(info, pkgInfo.firstInstallTime);\r\n            } catch (NameNotFoundException e) {\r\n                Log.e(TAG, \"Unknown package \" + packageName, e);\r\n            }\r\n        }\r\n    }\r\n    if (newPackageAdded) {\r\n        mPrefs.edit().putStringSet(mPackageSetKey, packageSet).apply();\r\n        finalizeAdditions(userAppsExisted);\r\n    }\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.patch.DiffMatchPatch.diffHalfMatchI",
	"Comment": "does a substring of shorttext exist within longtext such that thesubstring is at least half the length of longtext?",
	"Method": "String[] diffHalfMatchI(String longtext,String shorttext,int i){\r\n    String seed = longtext.substring(i, i + longtext.length() / 4);\r\n    int j = -1;\r\n    String bestCommon = \"\";\r\n    String bestLongtextA = \"\";\r\n    String bestLongtextB = \"\";\r\n    String bestShorttextA = \"\";\r\n    String bestShorttextB = \"\";\r\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\r\n        int prefixLength = this.diffCommonPrefix(longtext.substring(i), shorttext.substring(j));\r\n        int suffixLength = this.diffCommonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\r\n        if (bestCommon.length() < suffixLength + prefixLength) {\r\n            bestCommon = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\r\n            bestLongtextA = longtext.substring(0, i - suffixLength);\r\n            bestLongtextB = longtext.substring(i + prefixLength);\r\n            bestShorttextA = shorttext.substring(0, j - suffixLength);\r\n            bestShorttextB = shorttext.substring(j + prefixLength);\r\n        }\r\n    }\r\n    if (bestCommon.length() * 2 >= longtext.length()) {\r\n        return new String[] { bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB, bestCommon };\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.kse.crypto.x509.X509CertUtil.convertCertificates",
	"Comment": "convert the supplied array of certificate objects into x509certificate\tobjects.",
	"Method": "X509Certificate[] convertCertificates(Certificate[] certsIn){\r\n    if (certsIn == null) {\r\n        return new X509Certificate[0];\r\n    }\r\n    X509Certificate[] certsOut = new X509Certificate[certsIn.length];\r\n    for (int i = 0; i < certsIn.length; i++) {\r\n        certsOut[i] = convertCertificate(certsIn[i]);\r\n    }\r\n    return certsOut;\r\n}"
}, {
	"Path": "com.android.launcher3.BaseRecyclerViewFastScrollBar.isNearThumb",
	"Comment": "returns whether the specified points are near the scroll bar bounds.",
	"Method": "boolean isNearThumb(int x,int y){\r\n    mTmpRect.set(mThumbOffset.x, mThumbOffset.y, mThumbOffset.x + mThumbWidth, mThumbOffset.y + mThumbHeight);\r\n    mTmpRect.inset(mTouchInset, mTouchInset);\r\n    return mTmpRect.contains(x, y);\r\n}"
}, {
	"Path": "com.jsql.view.swing.sql.lexer.syntax.SQLToken.errorString",
	"Comment": "get a string that explains the error, if this token is an error.",
	"Method": "String errorString(){\r\n    String s;\r\n    if (this.isError()) {\r\n        s = \"Error on line \" + this.lineNumber + \": \";\r\n        switch(this.id) {\r\n            case ERROR:\r\n                s += \"Unexpected token: \" + this.contents;\r\n                break;\r\n            case ERROR_UNCLOSED_COMMENT:\r\n                s += \"Unclosed comment: \" + this.contents;\r\n                break;\r\n            case ERROR_UNCLOSED_STRING:\r\n                s += \"Unclosed string literal: \" + this.contents;\r\n                break;\r\n            case ERROR_UNCLOSED_BIT_STRING:\r\n                s += \"Unclosed bit-string literal: \" + this.contents;\r\n                break;\r\n            case ERROR_BAD_BIT_STRING:\r\n                s += \"Bit-strings can only contain 0 and 1: \" + this.contents;\r\n                break;\r\n        }\r\n    } else {\r\n        s = null;\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.patch.DiffMatchPatch.diffCleanupEfficiency",
	"Comment": "reduce the number of edits by eliminating operationally trivial equalities.",
	"Method": "void diffCleanupEfficiency(LinkedList<Diff> diffs){\r\n    if (diffs.isEmpty()) {\r\n        return;\r\n    }\r\n    boolean changes = false;\r\n    Stack<Diff> equalities = new Stack();\r\n    String lastequality = null;\r\n    ListIterator<Diff> pointer = diffs.listIterator();\r\n    boolean preIns = false;\r\n    boolean preDel = false;\r\n    boolean postIns = false;\r\n    boolean postDel = false;\r\n    Diff thisDiff = pointer.next();\r\n    Diff safeDiff = thisDiff;\r\n    while (thisDiff != null) {\r\n        if (thisDiff.getOperation() == Operation.EQUAL) {\r\n            if (thisDiff.getText().length() < DIFF_EDIT_COST && (postIns || postDel)) {\r\n                equalities.push(thisDiff);\r\n                preIns = postIns;\r\n                preDel = postDel;\r\n                lastequality = thisDiff.getText();\r\n            } else {\r\n                equalities.clear();\r\n                lastequality = null;\r\n                safeDiff = thisDiff;\r\n            }\r\n            postIns = postDel = false;\r\n        } else {\r\n            if (thisDiff.getOperation() == Operation.DELETE) {\r\n                postDel = true;\r\n            } else {\r\n                postIns = true;\r\n            }\r\n            if (lastequality != null && ((preIns && preDel && postIns && postDel) || ((lastequality.length() < DIFF_EDIT_COST / 2) && ((preIns ? 1 : 0) + (preDel ? 1 : 0) + (postIns ? 1 : 0) + (postDel ? 1 : 0)) == 3))) {\r\n                while (thisDiff != equalities.lastElement()) {\r\n                    thisDiff = pointer.previous();\r\n                }\r\n                pointer.next();\r\n                pointer.set(new Diff(Operation.DELETE, lastequality));\r\n                thisDiff = new Diff(Operation.INSERT, lastequality);\r\n                pointer.add(thisDiff);\r\n                equalities.pop();\r\n                lastequality = null;\r\n                if (preIns && preDel) {\r\n                    postIns = postDel = true;\r\n                    equalities.clear();\r\n                    safeDiff = thisDiff;\r\n                } else {\r\n                    if (!equalities.empty()) {\r\n                        equalities.pop();\r\n                    }\r\n                    if (equalities.empty()) {\r\n                        thisDiff = safeDiff;\r\n                    } else {\r\n                        thisDiff = equalities.lastElement();\r\n                    }\r\n                    while (thisDiff != pointer.previous()) {\r\n                    }\r\n                    postIns = postDel = false;\r\n                }\r\n                changes = true;\r\n            }\r\n        }\r\n        thisDiff = pointer.hasNext() ? pointer.next() : null;\r\n    }\r\n    if (changes) {\r\n        this.diffCleanupMerge(diffs);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.Geometry.getInteriorPoint",
	"Comment": "computes an interior point of this geometry.an interior point is guaranteed to lie in the interior of the geometry,if it possible to calculate such a point exactly. otherwise,the point may lie on the boundary of the geometry.the interior point of an empty geometry is point empty.",
	"Method": "Point getInteriorPoint(){\r\n    if (isEmpty())\r\n        return factory.createPoint();\r\n    Coordinate interiorPt = null;\r\n    int dim = getDimension();\r\n    if (dim == 0) {\r\n        InteriorPointPoint intPt = new InteriorPointPoint(this);\r\n        interiorPt = intPt.getInteriorPoint();\r\n    } else if (dim == 1) {\r\n        InteriorPointLine intPt = new InteriorPointLine(this);\r\n        interiorPt = intPt.getInteriorPoint();\r\n    } else {\r\n        InteriorPointArea intPt = new InteriorPointArea(this);\r\n        interiorPt = intPt.getInteriorPoint();\r\n    }\r\n    return createPointFromInternalCoord(interiorPt, this);\r\n}"
}, {
	"Path": "org.locationtech.jts.io.gml2.GMLHandler.getGeometry",
	"Comment": "gets the geometry parsed by this handler.\tthis method should only be called after the parser has completed execution",
	"Method": "Geometry getGeometry(){\r\n    if (stack.size() == 1) {\r\n        Handler h = (Handler) stack.peek();\r\n        if (h.children.size() == 1)\r\n            return (Geometry) h.children.get(0);\r\n        return gf.createGeometryCollection((Geometry[]) h.children.toArray(new Geometry[stack.size()]));\r\n    }\r\n    throw new IllegalStateException(\"Parse did not complete as expected, there are \" + stack.size() + \" elements on the Stack\");\r\n}"
}, {
	"Path": "com.jdon.util.FileUtil.recursiveRemoveDir",
	"Comment": "this class del a directory recursively,that means delete all files and\tdirectorys.",
	"Method": "void recursiveRemoveDir(File directory){\r\n    if (!directory.exists())\r\n        throw new IOException(directory.toString() + \" do not exist!\");\r\n    String[] filelist = directory.list();\r\n    File tmpFile = null;\r\n    for (int i = 0; i < filelist.length; i++) {\r\n        tmpFile = new File(directory.getAbsolutePath(), filelist[i]);\r\n        if (tmpFile.isDirectory()) {\r\n            recursiveRemoveDir(tmpFile);\r\n        } else if (tmpFile.isFile()) {\r\n            try {\r\n                tmpFile.delete();\r\n            } catch (Exception ex) {\r\n                throw new Exception(tmpFile.toString() + \" can not be deleted \" + ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        directory.delete();\r\n    } catch (Exception ex) {\r\n        throw new Exception(directory.toString() + \" can not be deleted \" + ex.getMessage());\r\n    } finally {\r\n        filelist = null;\r\n    }\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isTime",
	"Comment": "istime returns true if string argument time forms a valid time.",
	"Method": "boolean isTime(String hour,String minute,String second,boolean isTime,String time){\r\n    if (isEmpty(time))\r\n        return defaultEmptyOK;\r\n    String hour;\r\n    String minute;\r\n    String second;\r\n    int timeColon1 = time.indexOf(\":\");\r\n    int timeColon2 = time.lastIndexOf(\":\");\r\n    if (timeColon1 <= 0)\r\n        return false;\r\n    hour = time.substring(0, timeColon1);\r\n    if (timeColon1 == timeColon2) {\r\n        minute = time.substring(timeColon1 + 1);\r\n        second = \"0\";\r\n    } else {\r\n        minute = time.substring(timeColon1 + 1, timeColon2);\r\n        second = time.substring(timeColon2 + 1);\r\n    }\r\n    return isTime(hour, minute, second);\r\n}"
}, {
	"Path": "com.jsql.util.ProxyUtil.setProxy",
	"Comment": "initialize proxy information from jvm already saved preferences.",
	"Method": "void setProxy(){\r\n    Preferences prefs = Preferences.userRoot().node(InjectionModel.class.getName());\r\n    ProxyUtil.setUsingProxy(prefs.getBoolean(\"isUsingProxy\", false));\r\n    ProxyUtil.setUsingProxyHttps(prefs.getBoolean(\"isUsingProxyHttps\", false));\r\n    ProxyUtil.setProxyAddress(prefs.get(\"proxyAddress\", HTTP_PROXY_DEFAULT_ADDRESS));\r\n    ProxyUtil.setProxyPort(prefs.get(\"proxyPort\", HTTP_PROXY_DEFAULT_PORT));\r\n    ProxyUtil.setProxyAddressHttps(prefs.get(\"proxyAddressHttps\", HTTPS_PROXY_DEFAULT_ADDRESS));\r\n    ProxyUtil.setProxyPortHttps(prefs.get(\"proxyPortHttps\", HTTPS_PROXY_DEFAULT_PORT));\r\n    if (ProxyUtil.isUsingProxy()) {\r\n        System.setProperty(PROPERTIES_HTTP_PROXY_HOST, ProxyUtil.getProxyAddress());\r\n        System.setProperty(PROPERTIES_HTTP_PROXY_PORT, ProxyUtil.getProxyPort());\r\n    }\r\n    if (ProxyUtil.isUsingProxyHttps()) {\r\n        System.setProperty(PROPERTIES_HTTPS_PROXY_HOST, ProxyUtil.getProxyAddressHttps());\r\n        System.setProperty(PROPERTIES_HTTPS_PROXY_PORT, ProxyUtil.getProxyPortHttps());\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.valid.ValidSelfTouchingRingFormingHoleTest.testDisconnectedInteriorShellSelfTouchAtVertex",
	"Comment": "ensure that the disconnected interior condition is not validated",
	"Method": "void testDisconnectedInteriorShellSelfTouchAtVertex(){\r\n    String wkt = \"POLYGON ((20 20, 20 100, 140 100, 140 180, 260 180, 260 100, 140 100, 140 20, 20 20))\";\r\n    checkIsValidSTR(wkt, false);\r\n    checkIsValidDefault(wkt, false);\r\n}"
}, {
	"Path": "org.joda.money.format.MoneyAmountStyle.getExtendedGroupingSize",
	"Comment": "gets the size of each group, not typically used.this is primarily used to enable the indian number system, where the groupclosest to the decimal point is of size 3 and other groups are of size 2.the extended grouping size is used for groups that are not next to the decimal point.the value zero is used to indicate that extended grouping is not needed.",
	"Method": "Integer getExtendedGroupingSize(){\r\n    return extendedGroupingSize < 0 ? null : extendedGroupingSize;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.union.CascadedPolygonUnion.binaryUnion",
	"Comment": "unions a section of a list using a recursive binary union on each halfof the section.",
	"Method": "Geometry binaryUnion(List geoms,Geometry binaryUnion,List geoms,int start,int end){\r\n    if (end - start <= 1) {\r\n        Geometry g0 = getGeometry(geoms, start);\r\n        return unionSafe(g0, null);\r\n    } else if (end - start == 2) {\r\n        return unionSafe(getGeometry(geoms, start), getGeometry(geoms, start + 1));\r\n    } else {\r\n        int mid = (end + start) / 2;\r\n        Geometry g0 = binaryUnion(geoms, start, mid);\r\n        Geometry g1 = binaryUnion(geoms, mid, end);\r\n        return unionSafe(g0, g1);\r\n    }\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.product.Product8.rotateR8",
	"Comment": "rotate all eight values of this product one slot to the right.",
	"Method": "Product8<_8, _1, _2, _3, _4, _5, _6, _7> rotateR8(){\r\n    return into((_1, _2, _3, _4, _5, _6, _7, _8) -> product(_8, _1, _2, _3, _4, _5, _6, _7));\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.internal.KubeConfigUtils.getUserToken",
	"Comment": "returns the current user token for the config and current context",
	"Method": "String getUserToken(Config config,Context context){\r\n    AuthInfo authInfo = getUserAuthInfo(config, context);\r\n    if (authInfo != null) {\r\n        return authInfo.getToken();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.buffer.BufferInputLineSimplifier.simplify",
	"Comment": "simplify the input coordinate list.if the distance tolerance is positive, concavities on the left side of the line are simplified.if the supplied distance tolerance is negative,concavities on the right side of the line are simplified.",
	"Method": "Coordinate[] simplify(Coordinate[] inputLine,double distanceTol,Coordinate[] simplify,double distanceTol){\r\n    this.distanceTol = Math.abs(distanceTol);\r\n    if (distanceTol < 0)\r\n        angleOrientation = Orientation.CLOCKWISE;\r\n    isDeleted = new byte[inputLine.length];\r\n    boolean isChanged = false;\r\n    do {\r\n        isChanged = deleteShallowConcavities();\r\n    } while (isChanged);\r\n    return collapseLine();\r\n}"
}, {
	"Path": "com.android.launcher3.CellLayout.findNearestVacantArea",
	"Comment": "find a vacant area that will fit the given bounds nearest the requestedcell location. uses euclidean distance to score multiple vacant areas.",
	"Method": "int[] findNearestVacantArea(int pixelX,int pixelY,int spanX,int spanY,int[] result,int[] findNearestVacantArea,int pixelX,int pixelY,int minSpanX,int minSpanY,int spanX,int spanY,int[] result,int[] resultSpan){\r\n    return findNearestArea(pixelX, pixelY, minSpanX, minSpanY, spanX, spanY, true, result, resultSpan);\r\n}"
}, {
	"Path": "org.kse.crypto.x509.X509CertUtil.getShortName",
	"Comment": "get short name for certificate. common name if available, otherwise use\tentire distinguished name.",
	"Method": "String getShortName(X509Certificate cert){\r\n    X500Name subject = X500NameUtils.x500PrincipalToX500Name(cert.getSubjectX500Principal());\r\n    String shortName = X500NameUtils.extractCN(subject);\r\n    if (StringUtils.isBlank(shortName)) {\r\n        shortName = subject.toString();\r\n    }\r\n    return shortName;\r\n}"
}, {
	"Path": "org.kse.crypto.x509.GeneralNameUtil.safeToString",
	"Comment": "get string representation for general names that cannot cause a\tioexception to be thrown. unsupported are edipartyname, othername and\tx400address. returns a blank string for these.",
	"Method": "String safeToString(GeneralName generalName,boolean addLinkForURI){\r\n    if (generalName == null) {\r\n        return \"\";\r\n    }\r\n    switch(generalName.getTagNo()) {\r\n        case GeneralName.directoryName:\r\n            X500Name directoryName = (X500Name) generalName.getName();\r\n            return MessageFormat.format(res.getString(\"GeneralNameUtil.DirectoryGeneralName\"), directoryName.toString());\r\n        case GeneralName.dNSName:\r\n            DERIA5String dnsName = (DERIA5String) generalName.getName();\r\n            return MessageFormat.format(res.getString(\"GeneralNameUtil.DnsGeneralName\"), dnsName.getString());\r\n        case GeneralName.iPAddress:\r\n            byte[] ipAddressBytes = ((ASN1OctetString) generalName.getName()).getOctets();\r\n            String ipAddressString = \"\";\r\n            try {\r\n                ipAddressString = InetAddress.getByAddress(ipAddressBytes).getHostAddress();\r\n            } catch (UnknownHostException e) {\r\n            }\r\n            return MessageFormat.format(res.getString(\"GeneralNameUtil.IpAddressGeneralName\"), ipAddressString);\r\n        case GeneralName.registeredID:\r\n            ASN1ObjectIdentifier registeredId = (ASN1ObjectIdentifier) generalName.getName();\r\n            return MessageFormat.format(res.getString(\"GeneralNameUtil.RegisteredIdGeneralName\"), ObjectIdUtil.toString(registeredId));\r\n        case GeneralName.rfc822Name:\r\n            DERIA5String rfc822Name = (DERIA5String) generalName.getName();\r\n            return MessageFormat.format(res.getString(\"GeneralNameUtil.Rfc822GeneralName\"), rfc822Name.getString());\r\n        case GeneralName.uniformResourceIdentifier:\r\n            DERIA5String uri = (DERIA5String) generalName.getName();\r\n            String link = addLinkForURI ? \"<a href=\\\"\" + uri.getString() + \"\\\">\" + uri.getString() + \"<\/a>\" : uri.getString();\r\n            return MessageFormat.format(res.getString(\"GeneralNameUtil.UriGeneralName\"), link);\r\n        case GeneralName.otherName:\r\n            return parseUPN(generalName);\r\n        default:\r\n            return \"\";\r\n    }\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.AbstractInjectionBoolean.inject",
	"Comment": "process the whole blind injection, character by character, bit by bit.",
	"Method": "String inject(String inj,AbstractSuspendable<String> suspendable){\r\n    List<char[]> bytes = new ArrayList();\r\n    int indexCharacter = 0;\r\n    ExecutorService taskExecutor = Executors.newFixedThreadPool(150, new ThreadFactoryCallable(\"CallableAbstractBlind\"));\r\n    CompletionService<T> taskCompletionService = new ExecutorCompletionService(taskExecutor);\r\n    taskCompletionService.submit(this.getCallable(inj, 0, IS_TESTING_LENGTH));\r\n    int submittedTasks = 1;\r\n    int countAsciiCode255 = 0;\r\n    while (submittedTasks > 0) {\r\n        if (suspendable.isSuspended()) {\r\n            taskExecutor.shutdown();\r\n            boolean isTerminated = false;\r\n            try {\r\n                isTerminated = taskExecutor.awaitTermination(0, TimeUnit.SECONDS);\r\n            } catch (InterruptedException e) {\r\n                LOGGER.error(e.getMessage(), e);\r\n                Thread.currentThread().interrupt();\r\n            }\r\n            if (!isTerminated) {\r\n                taskExecutor.shutdownNow();\r\n            }\r\n            StoppedByUserSlidingException e = new StoppedByUserSlidingException();\r\n            StringBuilder result = new StringBuilder();\r\n            for (char[] c : bytes) {\r\n                try {\r\n                    int charCode = Integer.parseInt(new String(c), 2);\r\n                    String str = Character.toString((char) charCode);\r\n                    result.append(str);\r\n                } catch (NumberFormatException err) {\r\n                }\r\n            }\r\n            e.setSlidingWindowAllRows(result.toString());\r\n            throw e;\r\n        }\r\n        try {\r\n            T currentCallable = taskCompletionService.take().get();\r\n            submittedTasks--;\r\n            if (currentCallable.isTestingLength()) {\r\n                if (currentCallable.isTrue()) {\r\n                    indexCharacter++;\r\n                    bytes.add(new char[] { 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x' });\r\n                    taskCompletionService.submit(this.getCallable(inj, indexCharacter, IS_TESTING_LENGTH));\r\n                    for (int bit : new int[] { 1, 2, 4, 8, 16, 32, 64, 128 }) {\r\n                        taskCompletionService.submit(this.getCallable(inj, indexCharacter, bit));\r\n                    }\r\n                    submittedTasks += 9;\r\n                }\r\n            } else {\r\n                char[] codeAsciiInBinary = bytes.get(currentCallable.getCurrentIndex() - 1);\r\n                codeAsciiInBinary[(int) (8 - (Math.log(2) + Math.log(currentCallable.getCurrentBit())) / Math.log(2))] = currentCallable.isTrue() ? '1' : '0';\r\n                try {\r\n                    int codeAscii = Integer.parseInt(new String(codeAsciiInBinary), 2);\r\n                    String charText = Character.toString((char) codeAscii);\r\n                    if (codeAscii == 255 || codeAscii == 0) {\r\n                        if (submittedTasks != 0 && countAsciiCode255 > 9 && (countAsciiCode255 * 100 / submittedTasks) > 50) {\r\n                            LOGGER.warn(\"Boolean false positives spotted, stopping...\");\r\n                            break;\r\n                        }\r\n                        countAsciiCode255++;\r\n                    }\r\n                    Request interaction = new Request();\r\n                    interaction.setMessage(Interaction.MESSAGE_BINARY);\r\n                    interaction.setParameters(new String(codeAsciiInBinary) + \"=\" + charText.replaceAll(\"\\\\n\", \"\\\\\\\\\\\\n\").replaceAll(\"\\\\r\", \"\\\\\\\\\\\\r\").replaceAll(\"\\\\t\", \"\\\\\\\\\\\\t\"));\r\n                    MediatorModel.model().sendToViews(interaction);\r\n                } catch (NumberFormatException err) {\r\n                }\r\n            }\r\n        } catch (InterruptedException | ExecutionException e) {\r\n            LOGGER.error(e.getMessage(), e);\r\n        }\r\n    }\r\n    try {\r\n        taskExecutor.shutdown();\r\n        taskExecutor.awaitTermination(15, TimeUnit.SECONDS);\r\n    } catch (InterruptedException e) {\r\n        LOGGER.error(e.getMessage(), e);\r\n        Thread.currentThread().interrupt();\r\n    }\r\n    StringBuilder result = new StringBuilder();\r\n    for (char[] c : bytes) {\r\n        try {\r\n            int charCode = Integer.parseInt(new String(c), 2);\r\n            String str = Character.toString((char) charCode);\r\n            result.append(str);\r\n        } catch (NumberFormatException err) {\r\n        }\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherModel.moveItemsInDatabase",
	"Comment": "move items in the db to a new . we assume that thecellx, celly have already been updated on the iteminfos.",
	"Method": "void moveItemsInDatabase(Context context,ArrayList<ItemInfo> items,long container,int screen){\r\n    ArrayList<ContentValues> contentValues = new ArrayList<ContentValues>();\r\n    int count = items.size();\r\n    for (int i = 0; i < count; i++) {\r\n        ItemInfo item = items.get(i);\r\n        item.container = container;\r\n        if (context instanceof Launcher && screen < 0 && container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {\r\n            item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX, item.cellY);\r\n        } else {\r\n            item.screenId = screen;\r\n        }\r\n        final ContentValues values = new ContentValues();\r\n        values.put(LauncherSettings.Favorites.CONTAINER, item.container);\r\n        values.put(LauncherSettings.Favorites.CELLX, item.cellX);\r\n        values.put(LauncherSettings.Favorites.CELLY, item.cellY);\r\n        values.put(LauncherSettings.Favorites.RANK, item.rank);\r\n        values.put(LauncherSettings.Favorites.SCREEN, item.screenId);\r\n        contentValues.add(values);\r\n    }\r\n    updateItemsInDatabaseHelper(context, contentValues, items, \"moveItemInDatabase\");\r\n}"
}, {
	"Path": "org.locationtech.jts.triangulate.quadedge.QuadEdge.connect",
	"Comment": "creates a new quadedge connecting the destination of a to the origin ofb, in such a way that all three have the same left face after theconnection is complete. additionally, the data pointers of the new edgeare set.",
	"Method": "QuadEdge connect(QuadEdge a,QuadEdge b){\r\n    QuadEdge e = makeEdge(a.dest(), b.orig());\r\n    splice(e, a.lNext());\r\n    splice(e.sym(), b);\r\n    return e;\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.entities.RichPresence.getSmallImage",
	"Comment": "information on the small corner image displayed in the profile view",
	"Method": "Image getSmallImage(){\r\n    return smallImage;\r\n}"
}, {
	"Path": "org.zeromq.ZAuth.authenticateGSS",
	"Comment": "callback for authorizing an authenticated gss connection.returns true if the connection is authorized, false otherwise.default implementation authorizes all authenticated connections.",
	"Method": "boolean authenticateGSS(ZAPRequest request){\r\n    if (verbose) {\r\n        System.out.printf(\"I: ALLOWED (GSSAPI allow any client) principal = %s identity = %s%n\", request.principal, request.identity);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.kse.crypto.Password.equals",
	"Comment": "is the supplied object equal to the password wrapper, i.e. do they wrap the\tsame password.",
	"Method": "boolean equals(Object object){\r\n    if (object == this) {\r\n        return true;\r\n    }\r\n    if (!(object instanceof Password)) {\r\n        return false;\r\n    }\r\n    Password password = (Password) object;\r\n    if (password.wrappedPassword == null) {\r\n        return wrappedPassword == null;\r\n    }\r\n    if (wrappedPassword.length != password.wrappedPassword.length) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < wrappedPassword.length; i++) {\r\n        if (wrappedPassword[i] != password.wrappedPassword[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.Try.forfeit",
	"Comment": "if this is a failure, return the wrapped value. otherwise, apply the success value to fn and returnthe result.",
	"Method": "T forfeit(Function<? super A, ? extends T> fn){\r\n    return match(id(), fn);\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.prep.PreparedPolygonPredicate.isAllTestComponentsInTargetInterior",
	"Comment": "tests whether all components of the test geometry \tare contained in the interior of the target geometry.handles both linear and point components.",
	"Method": "boolean isAllTestComponentsInTargetInterior(Geometry testGeom){\r\n    List coords = ComponentCoordinateExtracter.getCoordinates(testGeom);\r\n    for (Iterator i = coords.iterator(); i.hasNext(); ) {\r\n        Coordinate p = (Coordinate) i.next();\r\n        int loc = targetPointLocator.locate(p);\r\n        if (loc != Location.INTERIOR)\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.util.AffineTransformation.isIdentity",
	"Comment": "tests if this transformation is the identity transformation.",
	"Method": "boolean isIdentity(){\r\n    return (m00 == 1 && m01 == 0 && m02 == 0 && m10 == 0 && m11 == 1 && m12 == 0);\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.distance3d.Distance3DOp.nearestLocations",
	"Comment": "report the locations of the nearest points in the input geometries. the\tlocations are presented in the same order as the input geometries.",
	"Method": "GeometryLocation[] nearestLocations(){\r\n    computeMinDistance();\r\n    return minDistanceLocation;\r\n}"
}, {
	"Path": "org.kse.AuthorityCertificates.getDefaultCaCertificatesLocation",
	"Comment": "get the default location for the ca certificates keystore.",
	"Method": "File getDefaultCaCertificatesLocation(){\r\n    String javaInstallDir = System.getProperty(\"java.home\");\r\n    String fileSep = System.getProperty(\"file.separator\");\r\n    File cacertsFile = new File(javaInstallDir, \"lib\" + fileSep + \"security\" + fileSep + \"cacerts\");\r\n    try {\r\n        return cacertsFile.getCanonicalFile();\r\n    } catch (IOException e) {\r\n        return cacertsFile;\r\n    }\r\n}"
}, {
	"Path": "com.jdon.util.UtilValidate.isSecond",
	"Comment": "issecond returns true if string s is a valid number between 0 and 59.",
	"Method": "boolean isSecond(String s){\r\n    if (isEmpty(s))\r\n        return defaultEmptyOK;\r\n    return isIntegerInRange(s, 0, 59);\r\n}"
}, {
	"Path": "com.jsql.model.injection.strategy.blind.patch.DiffMatchPatch.patchMake",
	"Comment": "compute a list of patches to turn text1 into text2.text2 is not provided, diffs are the delta between text1 and text2.",
	"Method": "List<Patch> patchMake(String text1,String text2,List<Patch> patchMake,LinkedList<Diff> diffs,List<Patch> patchMake,String text1,Deque<Diff> diffs){\r\n    if (text1 == null || diffs == null) {\r\n        throw new IllegalArgumentException(\"Null inputs. (patch_make)\");\r\n    }\r\n    List<Patch> patches = new LinkedList();\r\n    if (diffs.isEmpty()) {\r\n        return patches;\r\n    }\r\n    Patch patch = new Patch();\r\n    int charCount1 = 0;\r\n    int charCount2 = 0;\r\n    String prepatchText = text1;\r\n    String postpatchText = text1;\r\n    for (Diff aDiff : diffs) {\r\n        if (patch.getDiffs().isEmpty() && aDiff.getOperation() != Operation.EQUAL) {\r\n            patch.setStart1(charCount1);\r\n            patch.setStart2(charCount2);\r\n        }\r\n        switch(aDiff.getOperation()) {\r\n            case INSERT:\r\n                patch.getDiffs().add(aDiff);\r\n                patch.setLength2(patch.getLength2() + aDiff.getText().length());\r\n                postpatchText = postpatchText.substring(0, charCount2) + aDiff.getText() + postpatchText.substring(charCount2);\r\n                break;\r\n            case DELETE:\r\n                patch.setLength1(patch.getLength1() + aDiff.getText().length());\r\n                patch.getDiffs().add(aDiff);\r\n                postpatchText = postpatchText.substring(0, charCount2) + postpatchText.substring(charCount2 + aDiff.getText().length());\r\n                break;\r\n            case EQUAL:\r\n                if (aDiff.getText().length() <= 2 * PATCH_MARGIN && !patch.getDiffs().isEmpty() && aDiff != diffs.getLast()) {\r\n                    patch.getDiffs().add(aDiff);\r\n                    patch.setLength1(patch.getLength1() + aDiff.getText().length());\r\n                    patch.setLength2(patch.getLength2() + aDiff.getText().length());\r\n                }\r\n                if (aDiff.getText().length() >= 2 * PATCH_MARGIN && !patch.getDiffs().isEmpty()) {\r\n                    this.patchAddContext(patch, prepatchText);\r\n                    patches.add(patch);\r\n                    patch = new Patch();\r\n                    prepatchText = postpatchText;\r\n                    charCount1 = charCount2;\r\n                }\r\n                break;\r\n        }\r\n        if (aDiff.getOperation() != Operation.INSERT) {\r\n            charCount1 += aDiff.getText().length();\r\n        }\r\n        if (aDiff.getOperation() != Operation.DELETE) {\r\n            charCount2 += aDiff.getText().length();\r\n        }\r\n    }\r\n    if (!patch.getDiffs().isEmpty()) {\r\n        this.patchAddContext(patch, prepatchText);\r\n        patches.add(patch);\r\n    }\r\n    return patches;\r\n}"
}, {
	"Path": "org.locationtech.jts.planargraph.NodeMap.add",
	"Comment": "adds a node to the map, replacing any that is already at that location.",
	"Method": "Node add(Node n){\r\n    nodeMap.put(n.getCoordinate(), n);\r\n    return n;\r\n}"
}, {
	"Path": "com.android.launcher3.BubbleTextView.reapplyItemInfo",
	"Comment": "applies the item info if it is same as what the view is pointing to currently.",
	"Method": "void reapplyItemInfo(ItemInfo info){\r\n    if (getTag() == info) {\r\n        mIconLoadRequest = null;\r\n        mDisableRelayout = true;\r\n        if (info instanceof AppInfo) {\r\n            applyFromApplicationInfo((AppInfo) info);\r\n        } else if (info instanceof ShortcutInfo) {\r\n            applyFromShortcutInfo((ShortcutInfo) info, LauncherAppState.getInstance().getIconCache());\r\n            if ((info.rank < FolderIcon.NUM_ITEMS_IN_PREVIEW) && (info.container >= 0)) {\r\n                View folderIcon = mLauncher.getWorkspace().getHomescreenIconByItemId(info.container);\r\n                if (folderIcon != null) {\r\n                    folderIcon.invalidate();\r\n                }\r\n            }\r\n        } else if (info instanceof PackageItemInfo) {\r\n            applyFromPackageItemInfo((PackageItemInfo) info);\r\n        }\r\n        mDisableRelayout = false;\r\n    }\r\n}"
}, {
	"Path": "org.kse.crypto.signing.MidletSigner.readJadFile",
	"Comment": "read the attributes of the supplied jad file as properties.",
	"Method": "Properties readJadFile(File jadFile){\r\n    try (FileInputStream fileInputStream = new FileInputStream(jadFile);\r\n        InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream);\r\n        LineNumberReader lnr = new LineNumberReader(inputStreamReader)) {\r\n        Properties jadProperties = new Properties();\r\n        String line = null;\r\n        while ((line = lnr.readLine()) != null) {\r\n            int index = line.indexOf(\": \");\r\n            if (index == -1) {\r\n                throw new IOException(res.getString(\"NoReadJadCorrupt.exception.message\"));\r\n            }\r\n            String name = line.substring(0, index);\r\n            String value = line.substring(index + 2);\r\n            jadProperties.setProperty(name, value);\r\n        }\r\n        return jadProperties;\r\n    }\r\n}"
}, {
	"Path": "com.android.launcher3.LauncherProvider.createWorkspaceLoaderFromAppRestriction",
	"Comment": "creates workspace loader from an xml resource listed in the app restrictions.",
	"Method": "AutoInstallsLayout createWorkspaceLoaderFromAppRestriction(){\r\n    if (!Utilities.ATLEAST_JB_MR2) {\r\n        return null;\r\n    }\r\n    Context ctx = getContext();\r\n    UserManager um = (UserManager) ctx.getSystemService(Context.USER_SERVICE);\r\n    Bundle bundle = um.getApplicationRestrictions(ctx.getPackageName());\r\n    if (bundle == null) {\r\n        return null;\r\n    }\r\n    String packageName = bundle.getString(RESTRICTION_PACKAGE_NAME);\r\n    if (packageName != null) {\r\n        try {\r\n            Resources targetResources = ctx.getPackageManager().getResourcesForApplication(packageName);\r\n            return AutoInstallsLayout.get(ctx, packageName, targetResources, mOpenHelper.mAppWidgetHost, mOpenHelper);\r\n        } catch (NameNotFoundException e) {\r\n            Log.e(TAG, \"Target package for restricted profile not found\", e);\r\n            return null;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DD.le",
	"Comment": "tests whether this value is less than or equal to another doubledouble value.",
	"Method": "boolean le(DD y){\r\n    return (hi < y.hi) || (hi == y.hi && lo <= y.lo);\r\n}"
}, {
	"Path": "org.locationtech.jts.dissolve.LineDissolverTest.testRingWithTail",
	"Comment": "shows that rings with incident lines are created with the correct node point.",
	"Method": "void testRingWithTail(){\r\n    checkDissolve(\"MULTILINESTRING ((0 0, 1 0, 1 1), (0 0, 0 1, 1 1), (1 0, 2 0))\", \"MULTILINESTRING ((1 0, 0 0, 0 1, 1 1, 1 0), (1 0, 2 0))\");\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct2.projectA",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the first slot value.",
	"Method": "Maybe<A> projectA(){\r\n    return project()._1();\r\n}"
}, {
	"Path": "com.jdon.util.Base64.decodeToObject",
	"Comment": "attempts to decode base64 data and deserialize a javaobject within. returns null if there was an error.",
	"Method": "Object decodeToObject(String encodedObject){\r\n    byte[] objBytes = decode(encodedObject);\r\n    java.io.ByteArrayInputStream bais = null;\r\n    java.io.ObjectInputStream ois = null;\r\n    Object obj = null;\r\n    try {\r\n        bais = new java.io.ByteArrayInputStream(objBytes);\r\n        ois = new java.io.ObjectInputStream(bais);\r\n        obj = ois.readObject();\r\n    } catch (java.io.IOException e) {\r\n        throw e;\r\n    } catch (java.lang.ClassNotFoundException e) {\r\n        throw e;\r\n    } finally {\r\n        try {\r\n            bais.close();\r\n        } catch (Exception e) {\r\n        }\r\n        try {\r\n            ois.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "org.locationtech.jts.geom.Envelope.maxExtent",
	"Comment": "gets the maximum extent of this envelope across both dimensions.",
	"Method": "double maxExtent(){\r\n    if (isNull())\r\n        return 0.0;\r\n    double w = getWidth();\r\n    double h = getHeight();\r\n    if (w > h)\r\n        return w;\r\n    return h;\r\n}"
}, {
	"Path": "com.jsql.view.swing.console.SwingAppender.append",
	"Comment": "method from log4j appenderskeleton that gets a call for all log4j events.",
	"Method": "void append(LoggingEvent event){\r\n    SwingUtilities.invokeLater(() -> this.insertText(this.layout.format(event), event.getLevel(), event.getThrowableInformation()));\r\n}"
}, {
	"Path": "io.fabric8.kubernetes.client.KubernetesClientTimeoutException.notReadyToString",
	"Comment": "creates a string listing all the resources that are not ready.",
	"Method": "String notReadyToString(Iterable<HasMetadata> resources){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"Resources that are not ready: \");\r\n    boolean first = true;\r\n    for (HasMetadata r : resources) {\r\n        if (first) {\r\n            first = false;\r\n        } else {\r\n            sb.append(\", \");\r\n        }\r\n        sb.append(\"[Kind:\").append(r.getKind()).append(\" Name:\").append(r.getMetadata().getName()).append(\" Namespace:\").append(r.getMetadata().getNamespace()).append(\"]\");\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.locationtech.jts.geomgraph.DirectedEdge.getSym",
	"Comment": "each edge gives rise to a pair of symmetric directededges, in oppositedirections.",
	"Method": "DirectedEdge getSym(){\r\n    return sym;\r\n}"
}, {
	"Path": "org.locationtech.jts.math.DD.lt",
	"Comment": "tests whether this value is less than another doubledouble value.",
	"Method": "boolean lt(DD y){\r\n    return (hi < y.hi) || (hi == y.hi && lo < y.lo);\r\n}"
}, {
	"Path": "org.locationtech.jts.precision.CommonBitsRemover.addCommonBits",
	"Comment": "adds the common coordinate bits back into a geometry.the coordinates of the geometry are changed.",
	"Method": "void addCommonBits(Geometry geom){\r\n    Translater trans = new Translater(commonCoord);\r\n    geom.apply(trans);\r\n    geom.geometryChanged();\r\n}"
}, {
	"Path": "org.kse.gui.CurrentDirectory.updateForFile",
	"Comment": "update currentdirectory based on the supplied file. if the file exists\tthen its parent is used.",
	"Method": "void updateForFile(File file){\r\n    if (file != null) {\r\n        File directory = file.getParentFile();\r\n        update(directory);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.jts.operation.polygonize.PolygonizeGraph.findLabeledEdgeRings",
	"Comment": "finds and labels all edgerings in the graph.the edge rings are labeling with unique integers.the labeling allows detecting cut edges.",
	"Method": "List findLabeledEdgeRings(Collection dirEdges){\r\n    List edgeRingStarts = new ArrayList();\r\n    long currLabel = 1;\r\n    for (Iterator i = dirEdges.iterator(); i.hasNext(); ) {\r\n        PolygonizeDirectedEdge de = (PolygonizeDirectedEdge) i.next();\r\n        if (de.isMarked())\r\n            continue;\r\n        if (de.getLabel() >= 0)\r\n            continue;\r\n        edgeRingStarts.add(de);\r\n        List edges = EdgeRing.findDirEdgesInRing(de);\r\n        label(edges, currLabel);\r\n        currLabel++;\r\n    }\r\n    return edgeRingStarts;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.product.Product5.rotateR5",
	"Comment": "rotate the first five values of this product one slot to the right.",
	"Method": "Product5<_5, _1, _2, _3, _4> rotateR5(){\r\n    return into((_1, _2, _3, _4, _5) -> product(_5, _1, _2, _3, _4));\r\n}"
}, {
	"Path": "org.kse.crypto.signing.JarSigner.getManifestMainAttrs",
	"Comment": "get main attributes of jar manifest as a string. gets original\tmanifest verbatim. if there is no manifest in jar it returns a string\twith those two attributes",
	"Method": "String getManifestMainAttrs(JarFile jar,String signer,String getManifestMainAttrs,JarFile jar){\r\n    String manifestContent = getManifest(jar);\r\n    try (StringReader stringReader = new StringReader(manifestContent);\r\n        LineNumberReader lnr = new LineNumberReader(stringReader)) {\r\n        StringBuilder sb = new StringBuilder();\r\n        String line = null;\r\n        while ((line = lnr.readLine()) != null) {\r\n            if (line.trim().length() == 0) {\r\n                break;\r\n            }\r\n            sb.append(line);\r\n            sb.append(CRLF);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}"
}, {
	"Path": "net.dv8tion.jda.core.entities.MessageEmbed.getDescription",
	"Comment": "the description of the embedded resource.this is provided only if discord could find a description for the embedded resource using the provided url.commonly, this is null. be careful when using it.",
	"Method": "String getDescription(){\r\n    return description;\r\n}"
}, {
	"Path": "com.jdon.container.pico.PicoContainerWrapper.getComponentNewInstance",
	"Comment": "this method will usually create a new instance each time it is called",
	"Method": "Object getComponentNewInstance(String name){\r\n    Debug.logVerbose(\"[JdonFramework]getComponentNewInstance: name=\" + name, module);\r\n    ComponentAdapter componentAdapter = container.getComponentAdapter(name);\r\n    if (componentAdapter == null) {\r\n        Debug.logWarning(\"[JdonFramework]Not find the component in container :\" + name, module);\r\n        return null;\r\n    }\r\n    return componentAdapter.getComponentInstance(container);\r\n}"
}, {
	"Path": "org.locationtech.jts.linearref.ExtractLineByLocation.extract",
	"Comment": "extracts a subline of the input.if endthe linear geometry computed will be reversed.",
	"Method": "Geometry extract(Geometry line,LinearLocation start,LinearLocation end,Geometry extract,LinearLocation start,LinearLocation end){\r\n    if (end.compareTo(start) < 0) {\r\n        return reverse(computeLinear(end, start));\r\n    }\r\n    return computeLinear(start, end);\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.adt.coproduct.CoProduct2.projectB",
	"Comment": "convenience method for projecting this coproduct onto a product and then extracting the second slot value.",
	"Method": "Maybe<B> projectB(){\r\n    return project()._2();\r\n}"
}, {
	"Path": "com.android.launcher3.DeviceProfile.computeAllAppsButtonSize",
	"Comment": "determine the exact visual footprint of the all apps button, taking into account scalingand internal padding of the drawable.",
	"Method": "void computeAllAppsButtonSize(Context context){\r\n    Resources res = context.getResources();\r\n    float padding = res.getInteger(R.integer.config_allAppsButtonPaddingPercent) / 100f;\r\n    allAppsButtonVisualSize = (int) (hotseatIconSizePx * (1 - padding));\r\n}"
}, {
	"Path": "com.android.launcher3.FolderPagedView.allocateRankForNewItem",
	"Comment": "create space for a new item at the end, and returns the rank for that item.also sets the current page to the last page.",
	"Method": "int allocateRankForNewItem(ShortcutInfo info){\r\n    int rank = getItemCount();\r\n    ArrayList<View> views = new ArrayList<View>(mFolder.getItemsInReadingOrder());\r\n    views.add(rank, null);\r\n    arrangeChildren(views, views.size(), false);\r\n    setCurrentPage(rank / mMaxItemsPerPage);\r\n    return rank;\r\n}"
}, {
	"Path": "com.jnape.palatable.lambda.functions.Fn1.diMapL",
	"Comment": "contravariantly map over the argument to this function, producing a function that takes the new argument type,and produces the same result.",
	"Method": "Fn1<Z, B> diMapL(Function<? super Z, ? extends A> fn){\r\n    return (Fn1<Z, B>) Strong.super.<Z>diMapL(fn);\r\n}"
}]