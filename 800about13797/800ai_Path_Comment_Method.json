[{
	"Path": "org.lwjgl.util.applet.AppletLoader.switchApplet",
	"Comment": "replace the current applet with the lwjgl applet\tusing appletstub and initialise and start it",
	"Method": "void switchApplet(){\r\n    setState(STATE_SWITCHING_APPLET);\r\n    percentage = 100;\r\n    debug_sleep(2000);\r\n    Thread.currentThread().setContextClassLoader(classLoader);\r\n    Class appletClass = classLoader.loadClass(getParameter(\"al_main\"));\r\n    lwjglApplet = (Applet) appletClass.newInstance();\r\n    lwjglApplet.setStub(this);\r\n    lwjglApplet.setSize(getWidth(), getHeight());\r\n    setLayout(new BorderLayout());\r\n    add(lwjglApplet);\r\n    validate();\r\n    setState(STATE_INITIALIZE_REAL_APPLET);\r\n    lwjglApplet.init();\r\n    setState(STATE_START_REAL_APPLET);\r\n    lwjglApplet.start();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.skins.SkinUnpacker.getCurrentFileName",
	"Comment": "returns the name of the current file being unpacked, or null if none.",
	"Method": "String getCurrentFileName(){\r\n    if (files == null || fileIndex == -1)\r\n        return null;\r\n    return files[fileIndex].getName();\r\n}"
}, {
	"Path": "com.j256.ormlite.stmt.QueryBuilder.getSelectColumnsAsString",
	"Comment": "return the selected columns in the query or an empty list if none were specified.",
	"Method": "String getSelectColumnsAsString(){\r\n    if (countOfQuery != null) {\r\n        return \"COUNT(\" + countOfQuery + \")\";\r\n    } else if (selectList == null) {\r\n        return \"\";\r\n    } else {\r\n        return selectList.toString();\r\n    }\r\n}"
}, {
	"Path": "ddf.minim.Minim.setOutputMixer",
	"Comment": "when using the javasound implementation of minim, this sets the javasound mixer \tthat will be used for obtain output destinations such as those required by audioouput, \taudioplayer, audiosample, and so forth. \tthis method will be replaced in a future version.",
	"Method": "void setOutputMixer(Mixer mixer){\r\n    if (mimp instanceof JSMinim) {\r\n        ((JSMinim) mimp).setOutputMixer(mixer);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.claimBottomFreeSpace",
	"Comment": "scrolls down the text to use new space made available by a resize or by deleted lines.",
	"Method": "void claimBottomFreeSpace(){\r\n    if (ime.getCompositionOffset() != -1)\r\n        return;\r\n    if (isFixedLineHeight()) {\r\n        int newVerticalOffset = Math.max(0, renderer.getHeight() - clientAreaHeight);\r\n        if (newVerticalOffset < getVerticalScrollOffset()) {\r\n            scrollVertical(newVerticalOffset - getVerticalScrollOffset(), true);\r\n        }\r\n    } else {\r\n        int bottomIndex = getPartialBottomIndex();\r\n        int height = getLinePixel(bottomIndex + 1);\r\n        if (clientAreaHeight > height) {\r\n            scrollVertical(-getAvailableHeightAbove(clientAreaHeight - height), true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.opencensus.contrib.agent.instrumentation.ThreadInstrumentationBenchmark.automatic",
	"Comment": "this benchmark attempts to measure the performance with automatic context propagation.",
	"Method": "void automatic(Blackhole blackhole){\r\n    Thread t = new Thread(new MyRunnable(blackhole));\r\n    t.start();\r\n    t.join();\r\n}"
}, {
	"Path": "org.lwjgl.test.opengles.util.Sphere.setTextureFlag",
	"Comment": "specifies if texture coordinates should be generated for\tquadrics rendered with qobj. if the value of texturecoords is true,\tthen texture coordinates are generated, and if texturecoords is false,\tthey are not.. the default is false.\tthe manner in which texture coordinates are generated depends upon the\tspecific quadric rendered.",
	"Method": "void setTextureFlag(boolean textureFlag){\r\n    this.textureFlag = textureFlag;\r\n}"
}, {
	"Path": "com.iwebpp.node.HttpParser.http_message_needs_eof",
	"Comment": "does the parser need to see an eof to find the end of the message?",
	"Method": "boolean http_message_needs_eof(){\r\n    if (type == http_parser_type.HTTP_REQUEST) {\r\n        return false;\r\n    }\r\n    if (status_code / 100 == 1 || status_code == 204 || status_code == 304 || (flags & Flags.F_SKIPBODY.flag) != 0) {\r\n        return false;\r\n    }\r\n    if ((flags & Flags.F_CHUNKED.flag) != 0 || content_length != ULLONG_MAX()) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getTopPixel",
	"Comment": "gets the top pixel.the top pixel is the pixel position of the line that is currently at the top of the widget. the text widget can be scrolled by pixels by dragging the scroll thumb so that a partial line may be displayed at the top the widget.the top pixel changes when the widget is scrolled.the top pixel does not include the widget trimming.",
	"Method": "int getTopPixel(){\r\n    checkWidget();\r\n    return getVerticalScrollOffset();\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix4f.translate",
	"Comment": "translate the source matrix and stash the result in the destination matrix",
	"Method": "Matrix4f translate(Vector2f vec,Matrix4f translate,Vector3f vec,Matrix4f translate,Vector3f vec,Matrix4f dest,Matrix4f translate,Vector3f vec,Matrix4f src,Matrix4f dest,Matrix4f translate,Vector2f vec,Matrix4f dest,Matrix4f translate,Vector2f vec,Matrix4f src,Matrix4f dest){\r\n    if (dest == null)\r\n        dest = new Matrix4f();\r\n    dest.m30 += src.m00 * vec.x + src.m10 * vec.y;\r\n    dest.m31 += src.m01 * vec.x + src.m11 * vec.y;\r\n    dest.m32 += src.m02 * vec.x + src.m12 * vec.y;\r\n    dest.m33 += src.m03 * vec.x + src.m13 * vec.y;\r\n    return dest;\r\n}"
}, {
	"Path": "org.newdawn.slick.gui.TextField.setBackgroundColor",
	"Comment": "set the background color. set to null to disable the background",
	"Method": "void setBackgroundColor(Color color){\r\n    background = color;\r\n}"
}, {
	"Path": "com.iwebpp.node.stream.Readable2.fromList",
	"Comment": "length is the combined lengths of all the buffers in the list.",
	"Method": "Object fromList(int n,State state){\r\n    List<Object> list = state.buffer;\r\n    int length = state.getLength();\r\n    boolean stringMode = state.getDecoder() != null;\r\n    boolean objectMode = !!state.isObjectMode();\r\n    Object ret;\r\n    debug(TAG, \"fromList n=\" + n);\r\n    if (list.size() == 0)\r\n        return null;\r\n    if (length == 0) {\r\n        debug(TAG, \"length == 0\");\r\n        ret = null;\r\n    } else if (objectMode) {\r\n        debug(TAG, \"objectMode\");\r\n        ret = list.get(0);\r\n    } else if (n == 0 || n >= length) {\r\n        debug(TAG, \"n==0 || n >= length\");\r\n        if (stringMode) {\r\n            ret = TextUtils.join(\"\", list);\r\n            debug(TAG, \"join.string:\" + ret.toString());\r\n        } else {\r\n            ret = Util.concatByteBuffer(list, length);\r\n        }\r\n        list.clear();\r\n    } else {\r\n        if (n < Util.chunkLength(list.get(0))) {\r\n            debug(TAG, \"n < Util.chunkLength(list.get(0))\");\r\n            Object buf = list.get(0);\r\n            ret = Util.chunkSlice(buf, 0, n);\r\n            list.set(0, Util.chunkSlice(buf, n));\r\n        } else if (n == Util.chunkLength(list.get(0))) {\r\n            debug(TAG, \"n == Util.chunkLength(list.get(0))\");\r\n            ret = list.remove(0);\r\n        } else {\r\n            debug(TAG, \"complex case\");\r\n            if (stringMode) {\r\n                debug(TAG, \"stringMode\");\r\n                ret = \"\";\r\n            } else {\r\n                ret = ByteBuffer.allocate(n);\r\n            }\r\n            int c = 0;\r\n            for (int i = 0, l = list.size(); i < l && c < n; i++) {\r\n                Object buf = list.get(0);\r\n                int cpy = Math.min(n - c, Util.chunkLength(buf));\r\n                if (stringMode) {\r\n                    String rs = (String) ret;\r\n                    rs += (String) (Util.chunkSlice(buf, 0, cpy));\r\n                    ret = rs;\r\n                    debug(TAG, \"string mode complex buf:\" + buf.toString());\r\n                    debug(TAG, \"string mode ret buf:\" + ret.toString());\r\n                } else {\r\n                    ByteBuffer rb = (ByteBuffer) ret;\r\n                    rb.put((ByteBuffer) Util.chunkSlice(buf, 0, cpy));\r\n                }\r\n                if (cpy < Util.chunkLength(buf))\r\n                    list.set(0, Util.chunkSlice(buf, cpy));\r\n                else\r\n                    list.remove(0);\r\n                c += cpy;\r\n            }\r\n            if (!stringMode)\r\n                ((ByteBuffer) ret).flip();\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.cut",
	"Comment": "moves the selected text to the clipboard.the text will be put in the clipboard in plain text format and rtf format.",
	"Method": "void cut(){\r\n    checkWidget();\r\n    if (copySelection(DND.CLIPBOARD)) {\r\n        if (blockSelection && blockXLocation != -1) {\r\n            insertBlockSelectionText((char) 0, SWT.NULL);\r\n        } else {\r\n            doDelete();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "me.imid.swipebacklayout.lib.SwipeBackLayout.setScrimColor",
	"Comment": "set a color to use for the scrim that obscures primary content while a\tdrawer is open.",
	"Method": "void setScrimColor(int color){\r\n    mScrimColor = color;\r\n    invalidate();\r\n}"
}, {
	"Path": "com.openhtmltopdf.nonvisualregressiontests.NonVisualRegressionTest.testLinkAreaMultipleBoxes",
	"Comment": "tests that an inline link with multiple inline boxes generates one link annotation for each line.ie. multiple inline boxes are concatenated into one rect for the purposes of creating a link area.",
	"Method": "void testLinkAreaMultipleBoxes(){\r\n    PDDocument doc = run(\"link-area-multiple-boxes\");\r\n    assertEquals(2, doc.getPage(0).getAnnotations().size());\r\n    PDAnnotationLink link = (PDAnnotationLink) doc.getPage(0).getAnnotations().get(0);\r\n    assertEquals(6.0, link.getRectangle().getLowerLeftX(), 1.0d);\r\n    assertEquals(130.012, link.getRectangle().getLowerLeftY(), 1.0d);\r\n    assertEquals(138.6, link.getRectangle().getUpperRightX(), 1.0d);\r\n    assertEquals(144.0, link.getRectangle().getUpperRightY(), 1.0d);\r\n    link = (PDAnnotationLink) doc.getPage(0).getAnnotations().get(1);\r\n    assertEquals(6.0, link.getRectangle().getLowerLeftX(), 1.0d);\r\n    assertEquals(113.28, link.getRectangle().getLowerLeftY(), 1.0d);\r\n    assertEquals(112.57, link.getRectangle().getUpperRightX(), 1.0d);\r\n    assertEquals(127.27, link.getRectangle().getUpperRightY(), 1.0d);\r\n    remove(\"link-area-multiple-boxes\", doc);\r\n}"
}, {
	"Path": "com.iwebpp.nodeandroid.test.ActivityInstrumentationTestCase.dont_testHttp",
	"Comment": "fixme this has a perpetual event looptodo this should be put in a separate test",
	"Method": "void dont_testHttp(){\r\n    String content = \"Log.d('RhinoTest', 'HttpTest, js');\";\r\n    content += \"var srv = http.createServer(NCC, function(req, res){\" + \"  Log.d('RhinoTest', 'req.url:'+req.url()+',headers:'+req.headers());\" + \"  res.setHeader('from', 'Rhino js http');\" + \"  res.writeHead(200);\" + \"  res.end('http from js', 'utf-8', null);\" + \"});\";\r\n    content += \"srv.listen(51669, '0.0.0.0', function(){\" + \"  Log.d('RhinoTest', 'Http server listening on 0.0.0.0:51669');\" + \"});\";\r\n    content += \"NCC.setTimeout(function(){\" + \"  Log.d('RhinoTest', 'http get ...');\";\r\n    content += \"  NCC.setInterval(function(){\" + \"    Log.d('RhinoTest', 'http get iteration ');\";\r\n    content += \"    http.get(NCC, 'http://localhost:51669', function(res){\" + \"      Log.d('RhinoTest', 'http got response, headers:'+res.headers());\" + \"\" + \"      res.setEncoding('utf-8');\" + \"\" + \"      res.on('data', function(data){\" + \"        Log.d('RhinoTest', 'http:'+data.toString());\" + \"      });\" + \"    });\";\r\n    content += \"  }, 2000);\";\r\n    content += \"}, 2000);\";\r\n    runScript(content);\r\n}"
}, {
	"Path": "com.openhtmltopdf.nonvisualregressiontests.NonVisualRegressionTest.testLinkAreaMultipleLine",
	"Comment": "tests that an inline link over multiple lines generates at least one link annotation for each line.",
	"Method": "void testLinkAreaMultipleLine(){\r\n    PDDocument doc = run(\"link-area-multiple-line\");\r\n    assertEquals(2, doc.getPage(0).getAnnotations().size());\r\n    PDAnnotationLink link = (PDAnnotationLink) doc.getPage(0).getAnnotations().get(0);\r\n    assertEquals(6.0, link.getRectangle().getLowerLeftX(), 1.0d);\r\n    assertEquals(130.012, link.getRectangle().getLowerLeftY(), 1.0d);\r\n    assertEquals(138.6, link.getRectangle().getUpperRightX(), 1.0d);\r\n    assertEquals(144.0, link.getRectangle().getUpperRightY(), 1.0d);\r\n    link = (PDAnnotationLink) doc.getPage(0).getAnnotations().get(1);\r\n    assertEquals(6.0, link.getRectangle().getLowerLeftX(), 1.0d);\r\n    assertEquals(116.02, link.getRectangle().getLowerLeftY(), 1.0d);\r\n    assertEquals(101.13, link.getRectangle().getUpperRightX(), 1.0d);\r\n    assertEquals(130.01, link.getRectangle().getUpperRightY(), 1.0d);\r\n    remove(\"link-area-multiple-line\", doc);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.user.UserSelectOverlay.setConsumeAndClose",
	"Comment": "whether to consume all unprocessed events, and close the overlay.",
	"Method": "void setConsumeAndClose(boolean flag){\r\n    this.consumeAndClose = flag;\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.getMaxBitmapDimensions",
	"Comment": "in sdk 14 and above, use canvas max bitmap width and height instead of the default 2048, to avoid redundant tiling.",
	"Method": "Point getMaxBitmapDimensions(Canvas canvas){\r\n    if (VERSION.SDK_INT >= 14) {\r\n        try {\r\n            int maxWidth = (Integer) Canvas.class.getMethod(\"getMaximumBitmapWidth\").invoke(canvas);\r\n            int maxHeight = (Integer) Canvas.class.getMethod(\"getMaximumBitmapHeight\").invoke(canvas);\r\n            return new Point(maxWidth, maxHeight);\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return new Point(2048, 2048);\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.setPaddingLeft",
	"Comment": "sets the padding to the left of a glyph on the glyphpage to allow for effects to be drawn.",
	"Method": "void setPaddingLeft(int paddingLeft){\r\n    this.paddingLeft = paddingLeft;\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.destroy",
	"Comment": "releases all resources used by this unicodefont. this method should be called when this unicodefont instance is no longer\tneeded.",
	"Method": "void destroy(){\r\n    clearGlyphs();\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Quaternion.normalise",
	"Comment": "normalise this quaternion and place the result in another quaternion.",
	"Method": "Quaternion normalise(Quaternion src,Quaternion dest,Quaternion normalise,Quaternion dest){\r\n    return normalise(this, dest);\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGL.eglGetCurrentDisplay",
	"Comment": "returns the egl display associated with the current context.",
	"Method": "EGLDisplay eglGetCurrentDisplay(){\r\n    return new EGLDisplay(neglGetCurrentDisplay());\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getStyleRangeAtOffset",
	"Comment": "returns the style range at the given offset.returns null if a linestylelistener has been set or if a style is not setfor the offset. should not be called if a linestylelistener has been set since the listener maintains the styles.",
	"Method": "StyleRange getStyleRangeAtOffset(int offset){\r\n    checkWidget();\r\n    if (offset < 0 || offset >= getCharCount()) {\r\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\r\n    }\r\n    if (!isListening(ST.LineGetStyle)) {\r\n        StyleRange[] ranges = renderer.getStyleRanges(offset, 1, true);\r\n        if (ranges != null)\r\n            return ranges[0];\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.openhtmltopdf.layout.SharedContext.setMedia",
	"Comment": "set the current media type. this is usually something like screenor print . see the media section of the css 2.1 spec for more information on mediatypes.",
	"Method": "void setMedia(String media){\r\n    this.media = media;\r\n}"
}, {
	"Path": "ddf.minim.ugens.Waves.square",
	"Comment": "constructs a perfect square wave with the specified duty cycle.",
	"Method": "Wavetable square(float dutyCycle){\r\n    return pulse(dutyCycle);\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.displaylist.DisplayListCollector.collect",
	"Comment": "the main method to create a list of paint instruction for each page.",
	"Method": "void collect(RenderingContext c,Layer layer,DisplayListContainer dlPages,Set<CollectFlags> flags){\r\n    if (layer.getMaster().getStyle().isFixed() && !flags.contains(CollectFlags.INCLUDE_FIXED_BOXES)) {\r\n        DisplayListOperation dlo = new PaintFixedLayer(layer);\r\n        addItem(dlo, 0, _pages.size() - 1, dlPages);\r\n        return;\r\n    }\r\n    List<PageInfo> layerPages = PagedBoxCollector.findLayerPages(c, layer, _pages);\r\n    int layerPageStart = findStartPage(c, layer);\r\n    int layerPageEnd = findEndPage(c, layer);\r\n    boolean pushedClip = false;\r\n    Rectangle parentClip = layer.getMaster().getParentClipBox(c, layer.getParent());\r\n    if (parentClip != null) {\r\n        DisplayListOperation dlo = new PaintPushClipRect(parentClip);\r\n        addItem(dlo, layerPages, dlPages);\r\n        pushedClip = true;\r\n    }\r\n    if (layer.hasLocalTransform()) {\r\n        addTransformItem(layer.getMaster(), layerPages, dlPages);\r\n    }\r\n    if (layer.isRootLayer() && layer.getMaster().hasRootElementBackground(c)) {\r\n        DisplayListOperation dlo = new PaintRootElementBackground(layer.getMaster());\r\n        addItem(dlo, dlPages.getMinPage(), dlPages.getMaxPage(), dlPages);\r\n    }\r\n    if (!layer.isInline() && ((BlockBox) layer.getMaster()).isReplaced()) {\r\n        collectReplacedElementLayer(c, layer, dlPages, layerPageStart, layerPageEnd);\r\n    } else {\r\n        PagedBoxCollector collector = createBoundedBoxCollector(layerPageStart, layerPageEnd);\r\n        collector.collectFloats(c, layer);\r\n        collector.collect(c, layer);\r\n        if (!layer.isInline() && layer.getMaster() instanceof BlockBox) {\r\n            collectLayerBackgroundAndBorder(c, layer, dlPages, layerPageStart, layerPageEnd);\r\n        }\r\n        if (layer.isRootLayer() || layer.isStackingContext()) {\r\n            collectLayers(c, layer.getSortedLayers(Layer.NEGATIVE), dlPages, flags);\r\n        }\r\n        for (int pageNumber = layerPageStart; pageNumber <= layerPageEnd; pageNumber++) {\r\n            PageResult pg = collector.getPageResult(pageNumber);\r\n            DisplayListPageContainer dlPageList = dlPages.getPageInstructions(pageNumber);\r\n            processPage(c, layer, pg, dlPageList, true, pageNumber, -1);\r\n            processShadowPages(c, layer, pageNumber, pg, dlPageList, true);\r\n        }\r\n        if (layer.isRootLayer() || layer.isStackingContext()) {\r\n            collectLayers(c, layer.collectLayers(Layer.AUTO), dlPages, flags);\r\n            collectLayers(c, layer.getSortedLayers(Layer.ZERO), dlPages, flags);\r\n            collectLayers(c, layer.getSortedLayers(Layer.POSITIVE), dlPages, flags);\r\n        }\r\n    }\r\n    if (layer.hasLocalTransform()) {\r\n        DisplayListOperation dlo = new PaintPopTransformLayer(layer.getMaster());\r\n        addItem(dlo, layerPages, dlPages);\r\n    }\r\n    if (pushedClip) {\r\n        DisplayListOperation dlo = new PaintPopClipRect();\r\n        addItem(dlo, layerPages, dlPages);\r\n    }\r\n}"
}, {
	"Path": "ddf.minim.ugens.Frequency.ofHertz",
	"Comment": "construct a frequency that represents the provided hertz.",
	"Method": "Frequency ofHertz(float hz){\r\n    return new Frequency(hz);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doWordNext",
	"Comment": "moves the caret to the end of the next word.if a selection exists, move the caret to the end of the selectionand remove the selection.",
	"Method": "void doWordNext(){\r\n    if (selection.y - selection.x > 0) {\r\n        setCaretOffset(selection.y, SWT.DEFAULT);\r\n        showCaret();\r\n    } else {\r\n        doSelectionWordNext();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getBidiColoring",
	"Comment": "gets the bidi coloring mode.when true the bidi text displayalgorithm is applied to segments of text that are the samecolor.",
	"Method": "boolean getBidiColoring(){\r\n    checkWidget();\r\n    return bidiColoring;\r\n}"
}, {
	"Path": "io.opencensus.exporter.stats.prometheus.PrometheusExportUtils.convertToLabelNames",
	"Comment": "converts the list of label keys to a list of string label names. also sanitizes the label keys.",
	"Method": "List<String> convertToLabelNames(List<LabelKey> labelKeys){\r\n    final List<String> labelNames = new ArrayList<String>(labelKeys.size());\r\n    for (LabelKey labelKey : labelKeys) {\r\n        labelNames.add(Collector.sanitizeMetricName(labelKey.getKey()));\r\n    }\r\n    return labelNames;\r\n}"
}, {
	"Path": "orestes.bloomfilter.cachesketch.ExpirationQueue.setEnabled",
	"Comment": "either enables or disables the queue, controllig if it expires items.",
	"Method": "boolean setEnabled(boolean enabled){\r\n    return enabled ? enable() : disable();\r\n}"
}, {
	"Path": "com.android.volley.toolbox.NetworkImageView.setDefaultImageResId",
	"Comment": "sets the default image resource id to be used for this view until the attempt to load itcompletes.",
	"Method": "void setDefaultImageResId(int defaultImage){\r\n    mDefaultImageId = defaultImage;\r\n}"
}, {
	"Path": "uk.co.senab.photoview.PhotoViewAttacher.checkAndDisplayMatrix",
	"Comment": "helper method that simply checks the matrix, and then displays the result",
	"Method": "void checkAndDisplayMatrix(){\r\n    if (checkMatrixBounds()) {\r\n        setImageViewMatrix(getDrawMatrix());\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGLKHRReusableSync.eglSignalSyncKHR",
	"Comment": "signals or unsignals the sync object by changing its status to\tthe specified mode.",
	"Method": "void eglSignalSyncKHR(EGLDisplay dpy,EGLSyncKHR sync,int mode){\r\n    if (!neglSignalSyncKHR(dpy.getPointer(), sync.getPointer(), mode))\r\n        throwEGLError(\"Failed to signal the KHR fence sync object.\");\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.RenderingContext.isPaged",
	"Comment": "returns true if the currently set media type is paged. currently returnstrue only for print , projection , and embossed ,handheld , and tv . see the media section of the css2.1 spec for more information on media types.",
	"Method": "boolean isPaged(){\r\n    return sharedContext.isPaged();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.GameData.getReplay",
	"Comment": "returns a replay object encapsulating all game data.\tif a replay already exists and frames is null, the existing object will be returned.",
	"Method": "Replay getReplay(ReplayFrame[] frames,LifeFrame[] lifeFrames,Beatmap beatmap){\r\n    if (replay != null && frames == null)\r\n        return replay;\r\n    if (frames == null)\r\n        return null;\r\n    replay = new Replay();\r\n    replay.mode = Beatmap.MODE_OSU;\r\n    replay.version = Updater.get().getBuildDate();\r\n    replay.beatmapHash = (beatmap == null) ? \"\" : beatmap.md5Hash;\r\n    replay.playerName = UserList.get().getCurrentUser().getName();\r\n    replay.replayHash = Long.toString(System.currentTimeMillis());\r\n    replay.hit300 = (short) hitResultCount[HIT_300];\r\n    replay.hit100 = (short) hitResultCount[HIT_100];\r\n    replay.hit50 = (short) hitResultCount[HIT_50];\r\n    replay.geki = (short) hitResultCount[HIT_300G];\r\n    replay.katu = (short) (hitResultCount[HIT_300K] + hitResultCount[HIT_100K]);\r\n    replay.miss = (short) hitResultCount[HIT_MISS];\r\n    replay.score = (int) score;\r\n    replay.combo = (short) comboMax;\r\n    replay.perfect = (comboMax == fullObjectCount);\r\n    replay.mods = GameMod.getModState();\r\n    replay.lifeFrames = lifeFrames;\r\n    replay.timestamp = new Date();\r\n    replay.frames = frames;\r\n    replay.seed = 0;\r\n    replay.loaded = true;\r\n    return replay;\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.constants.CSSName.countCSSNames",
	"Comment": "returns a count of all css properties known to this class, shorthand and primitive.",
	"Method": "int countCSSNames(){\r\n    return CSSName.maxAssigned;\r\n}"
}, {
	"Path": "ddf.minim.effects.BandPass.setBandWidth",
	"Comment": "sets the band width of the filter. doing this will cause the coefficientsto be recalculated.",
	"Method": "void setBandWidth(float bandWidth){\r\n    bw = bandWidth / sampleRate();\r\n    calcCoeff();\r\n}"
}, {
	"Path": "com.j256.ormlite.stmt.Where.raw",
	"Comment": "add a raw statement as part of the where that can be anything that the database supports. using more structured\tmethods is recommended but this gives more control over the query and allows you to utilize database specific\tfeatures.",
	"Method": "Where<T, ID> raw(String rawStatement,ArgumentHolder args){\r\n    for (ArgumentHolder arg : args) {\r\n        String columnName = arg.getColumnName();\r\n        if (columnName == null) {\r\n            if (arg.getSqlType() == null) {\r\n                throw new IllegalArgumentException(\"Either the column name or SqlType must be set on each argument\");\r\n            }\r\n        } else {\r\n            arg.setMetaInfo(findColumnFieldType(columnName));\r\n        }\r\n    }\r\n    addClause(new Raw(rawStatement, args));\r\n    return this;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.db.ScoreDB.getMapScoresExcluding",
	"Comment": "retrieves the game scores for a beatmap while excluding a score.",
	"Method": "ScoreData[] getMapScoresExcluding(Beatmap beatmap,String exclude){\r\n    if (connection == null)\r\n        return null;\r\n    List<ScoreData> list = new ArrayList<ScoreData>();\r\n    try {\r\n        selectMapStmt.setInt(1, beatmap.beatmapID);\r\n        selectMapStmt.setString(2, beatmap.title);\r\n        selectMapStmt.setString(3, beatmap.artist);\r\n        selectMapStmt.setString(4, beatmap.creator);\r\n        selectMapStmt.setString(5, beatmap.version);\r\n        ResultSet rs = selectMapStmt.executeQuery();\r\n        while (rs.next()) {\r\n            ScoreData s = new ScoreData(rs);\r\n            if (s.replayString != null && s.replayString.equals(exclude)) {\r\n            } else {\r\n                list.add(s);\r\n            }\r\n        }\r\n        rs.close();\r\n    } catch (SQLException e) {\r\n        ErrorHandler.error(\"Failed to read scores from database.\", e, true);\r\n        return null;\r\n    }\r\n    return getSortedArray(list);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.HitObject.init",
	"Comment": "initializes the hitobject data type with container dimensions.",
	"Method": "void init(int width,int height){\r\n    containerHeight = height;\r\n    int swidth = width;\r\n    int sheight = height;\r\n    if (swidth * 3 > sheight * 4)\r\n        swidth = sheight * 4 / 3;\r\n    else\r\n        sheight = swidth * 3 / 4;\r\n    xMultiplier = swidth / 640f;\r\n    yMultiplier = sheight / 480f;\r\n    xOffset = (int) (width - MAX_X * xMultiplier) / 2;\r\n    yOffset = (int) (height - MAX_Y * yMultiplier) / 2;\r\n}"
}, {
	"Path": "org.lwjgl.openal.ALC10.alcGetCurrentContext",
	"Comment": "the application can query for, and obtain an handle to, the current context for the\t application. if there is no current context, null is returned.",
	"Method": "ALCcontext alcGetCurrentContext(){\r\n    ALCcontext context = null;\r\n    long context_address = nalcGetCurrentContext();\r\n    if (context_address != 0) {\r\n        synchronized (ALC10.contexts) {\r\n            context = ALC10.contexts.get(context_address);\r\n        }\r\n    }\r\n    return context;\r\n}"
}, {
	"Path": "ddf.minim.analysis.BeatDetect.detectSize",
	"Comment": "in frequency energy mode this returns the number of frequency bands \tcurrently being used. in sound energy mode this always returns 0.",
	"Method": "int detectSize(){\r\n    if (algorithm == FREQ_ENERGY) {\r\n        return spect.avgSize();\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "org.lwjgl.BufferUtils.createPointerBuffer",
	"Comment": "construct a pointerbuffer with the specified number\tof elements.",
	"Method": "PointerBuffer createPointerBuffer(int size){\r\n    return PointerBuffer.allocateDirect(size);\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.FSImageWriter.newJpegWriter",
	"Comment": "convenience method for initializing a writer for the jpeg image format.",
	"Method": "FSImageWriter newJpegWriter(float quality){\r\n    FSImageWriter writer = new FSImageWriter(\"jpg\");\r\n    writer.setWriteCompressionMode(ImageWriteParam.MODE_EXPLICIT);\r\n    writer.setWriteCompressionType(\"JPEG\");\r\n    writer.setWriteCompressionQuality(quality);\r\n    return writer;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.skins.Skin.getHitCircleFontOverlap",
	"Comment": "returns the amount of overlap between the hit circle font sprites.",
	"Method": "int getHitCircleFontOverlap(){\r\n    return hitCircleOverlap;\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Vector4f.add",
	"Comment": "add a vector to another vector and place the result in a destination\tvector.",
	"Method": "Vector4f add(Vector4f left,Vector4f right,Vector4f dest){\r\n    if (dest == null)\r\n        return new Vector4f(left.x + right.x, left.y + right.y, left.z + right.z, left.w + right.w);\r\n    else {\r\n        dest.set(left.x + right.x, left.y + right.y, left.z + right.z, left.w + right.w);\r\n        return dest;\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix4f.sub",
	"Comment": "subtract the right matrix from the left and place the result in a third matrix.",
	"Method": "Matrix4f sub(Matrix4f left,Matrix4f right,Matrix4f dest){\r\n    if (dest == null)\r\n        dest = new Matrix4f();\r\n    dest.m00 = left.m00 - right.m00;\r\n    dest.m01 = left.m01 - right.m01;\r\n    dest.m02 = left.m02 - right.m02;\r\n    dest.m03 = left.m03 - right.m03;\r\n    dest.m10 = left.m10 - right.m10;\r\n    dest.m11 = left.m11 - right.m11;\r\n    dest.m12 = left.m12 - right.m12;\r\n    dest.m13 = left.m13 - right.m13;\r\n    dest.m20 = left.m20 - right.m20;\r\n    dest.m21 = left.m21 - right.m21;\r\n    dest.m22 = left.m22 - right.m22;\r\n    dest.m23 = left.m23 - right.m23;\r\n    dest.m30 = left.m30 - right.m30;\r\n    dest.m31 = left.m31 - right.m31;\r\n    dest.m32 = left.m32 - right.m32;\r\n    dest.m33 = left.m33 - right.m33;\r\n    return dest;\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Vector4f.negate",
	"Comment": "negate a vector and place the result in a destination vector.",
	"Method": "Vector negate(Vector4f negate,Vector4f dest){\r\n    if (dest == null)\r\n        dest = new Vector4f();\r\n    dest.x = -x;\r\n    dest.y = -y;\r\n    dest.z = -z;\r\n    dest.w = -w;\r\n    return dest;\r\n}"
}, {
	"Path": "ddf.minim.javasound.FloatSampleBuffer.expandChannel",
	"Comment": "mix up of 1 channel to n channels.\tit copies the first channel to all newly created channels.",
	"Method": "void expandChannel(int targetChannelCount){\r\n    if (getChannelCount() != 1) {\r\n        throw new IllegalArgumentException(\"FloatSampleBuffer: can only expand channels for mono signals.\");\r\n    }\r\n    for (int ch = 1; ch < targetChannelCount; ch++) {\r\n        addChannel(false);\r\n        copyChannel(0, ch);\r\n    }\r\n}"
}, {
	"Path": "io.opencensus.contrib.zpages.TraceConfigzZPageHandler.emitTraceParamsTable",
	"Comment": "prints a table to a printwriter that shows existing trace parameters.",
	"Method": "void emitTraceParamsTable(TraceParams params,PrintWriter out){\r\n    out.write(\"<b class=\\\"title\\\">Active tracing parameters:<\/b><br>\\n\" + \"<table class=\\\"small\\\" rules=\\\"all\\\">\\n\" + \"  <tr>\\n\" + \"    <td class=\\\"col_headR\\\">Name<\/td>\\n\" + \"    <td class=\\\"col_head\\\">Value<\/td>\\n\" + \"  <\/tr>\\n\");\r\n    out.printf(\"  <tr>%n    <td>Sampler<\/td>%n    <td>%s<\/td>%n  <\/tr>%n\", params.getSampler().getDescription());\r\n    out.printf(\"  <tr>%n    <td>MaxNumberOfAttributes<\/td>%n    <td>%d<\/td>%n  <\/tr>%n\", params.getMaxNumberOfAttributes());\r\n    out.printf(\"  <tr>%n    <td>MaxNumberOfAnnotations<\/td>%n    <td>%d<\/td>%n  <\/tr>%n\", params.getMaxNumberOfAnnotations());\r\n    out.printf(\"  <tr>%n    <td>MaxNumberOfNetworkEvents<\/td>%n    <td>%d<\/td>%n  <\/tr>%n\", params.getMaxNumberOfNetworkEvents());\r\n    out.printf(\"  <tr>%n    <td>MaxNumberOfLinks<\/td>%n    <td>%d<\/td>%n  <\/tr>%n\", params.getMaxNumberOfLinks());\r\n    out.write(\"<\/table>\\n\");\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.setDisplayListCaching",
	"Comment": "sets if this unicodefont caches the glyph drawing instructions to improve performance. \tdefault is true. text rendering is very slow without display list caching.",
	"Method": "void setDisplayListCaching(boolean displayListCaching){\r\n    this.displayListCaching = displayListCaching;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doSelectionLineUp",
	"Comment": "moves the caret one line up and to the same character offset relative to the beginning of the line. moves the caret to the end of the new line if the new line is shorter than the character offset.moves the caret to the beginning of the document if it is already on thefirst line.adjusts the selection according to the caret change. this can either addto or subtract from the old selection, depending on the previous selectiondirection.",
	"Method": "void doSelectionLineUp(){\r\n    int oldColumnX = columnX = getPointAtOffset(caretOffset).x;\r\n    doLineUp(true);\r\n    columnX = oldColumnX;\r\n}"
}, {
	"Path": "com.joestelmach.natty.WalkerState.markDateInvocation",
	"Comment": "ensures that the first invocation of a date seekingrule is captured",
	"Method": "void markDateInvocation(){\r\n    _updatePreviousDates = !_dateGivenInGroup;\r\n    _dateGivenInGroup = true;\r\n    _dateGroup.setDateInferred(false);\r\n    if (_firstDateInvocationInGroup) {\r\n        if (_timeGivenInGroup) {\r\n            int hours = _calendar.get(Calendar.HOUR_OF_DAY);\r\n            int minutes = _calendar.get(Calendar.MINUTE);\r\n            int seconds = _calendar.get(Calendar.SECOND);\r\n            resetCalendar();\r\n            _calendar.set(Calendar.HOUR_OF_DAY, hours);\r\n            _calendar.set(Calendar.MINUTE, minutes);\r\n            _calendar.set(Calendar.SECOND, seconds);\r\n        } else {\r\n            resetCalendar();\r\n        }\r\n        _firstDateInvocationInGroup = false;\r\n    }\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.setDebug",
	"Comment": "enables visual debugging, showing tile boundaries and sizes.",
	"Method": "void setDebug(boolean debug){\r\n    this.debug = debug;\r\n}"
}, {
	"Path": "ddf.minim.ugens.FilePlayer.getMetaData",
	"Comment": "returns the meta data for the recording being played by this player.",
	"Method": "AudioMetaData getMetaData(){\r\n    return mFileStream.getMetaData();\r\n}"
}, {
	"Path": "com.android.volley.NetworkDispatcher.quit",
	"Comment": "forces this dispatcher to quit immediately.if any requests are still inthe queue, they are not guaranteed to be processed.",
	"Method": "void quit(){\r\n    mQuit = true;\r\n    interrupt();\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doSelection",
	"Comment": "updates the selection to extend to the current caret position.",
	"Method": "void doSelection(int direction){\r\n    int redrawStart = -1;\r\n    int redrawEnd = -1;\r\n    if (selectionAnchor == -1) {\r\n        selectionAnchor = selection.x;\r\n    }\r\n    if (direction == ST.COLUMN_PREVIOUS) {\r\n        if (caretOffset < selection.x) {\r\n            redrawEnd = selection.x;\r\n            redrawStart = selection.x = caretOffset;\r\n            if (selection.y != selectionAnchor) {\r\n                redrawEnd = selection.y;\r\n                selection.y = selectionAnchor;\r\n            }\r\n        } else if (selectionAnchor == selection.x && caretOffset < selection.y) {\r\n            redrawEnd = selection.y;\r\n            redrawStart = selection.y = caretOffset;\r\n        }\r\n    } else {\r\n        if (caretOffset > selection.y) {\r\n            redrawStart = selection.y;\r\n            redrawEnd = selection.y = caretOffset;\r\n            if (selection.x != selectionAnchor) {\r\n                redrawStart = selection.x;\r\n                selection.x = selectionAnchor;\r\n            }\r\n        } else if (selectionAnchor == selection.y && caretOffset > selection.x) {\r\n            redrawStart = selection.x;\r\n            redrawEnd = selection.x = caretOffset;\r\n        }\r\n    }\r\n    if (redrawStart != -1 && redrawEnd != -1) {\r\n        internalRedrawRange(redrawStart, redrawEnd - redrawStart);\r\n        sendSelectionEvent();\r\n    }\r\n    sendAccessibleTextCaretMoved();\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.addLineStyleListener",
	"Comment": "adds a line style listener. a linegetstyle event is sent by the widget to determine the styles for a line.",
	"Method": "void addLineStyleListener(LineStyleListener listener){\r\n    checkWidget();\r\n    if (listener == null)\r\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\r\n    if (!isListening(ST.LineGetStyle)) {\r\n        setStyleRanges(0, 0, null, null, true);\r\n        renderer.clearLineStyle(0, content.getLineCount());\r\n    }\r\n    addListener(ST.LineGetStyle, new StyledTextListener(listener));\r\n    setCaretLocation();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.OptionsOverlay.updateSearch",
	"Comment": "update the visible options to conform to the search string.",
	"Method": "void updateSearch(){\r\n    OptionGroup lastHeader = null;\r\n    boolean lastHeaderMatches = false;\r\n    for (OptionGroup group : groups) {\r\n        boolean groupMatches = group.getName().toLowerCase().contains(lastSearchText);\r\n        if (group.getOptions() == null) {\r\n            lastHeaderMatches = groupMatches;\r\n            lastHeader = group;\r\n            group.setVisible(false);\r\n            continue;\r\n        }\r\n        boolean allOptionsHidden = true;\r\n        for (GameOption option : group.getOptions()) {\r\n            if (lastHeaderMatches || groupMatches) {\r\n                allOptionsHidden = false;\r\n                toggleOption(option, true);\r\n                continue;\r\n            }\r\n            if (option.matches(lastSearchText)) {\r\n                allOptionsHidden = false;\r\n                toggleOption(option, true);\r\n            } else\r\n                toggleOption(option, false);\r\n        }\r\n        if (allOptionsHidden)\r\n            group.setVisible(false);\r\n        else {\r\n            if (lastHeader != null)\r\n                lastHeader.setVisible(true);\r\n            group.setVisible(true);\r\n        }\r\n    }\r\n    resetOpenDropdownMenu();\r\n    updateHoverOption(prevMouseX, prevMouseY);\r\n    updateActiveSection();\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.fileSRect",
	"Comment": "converts source rectangle from tile, which treats the image file as if it were in the correct orientation already,to the rectangle of the image that needs to be loaded.",
	"Method": "Rect fileSRect(Rect sRect){\r\n    if (getRequiredRotation() == 0) {\r\n        return sRect;\r\n    } else if (getRequiredRotation() == 90) {\r\n        return new Rect(sRect.top, sHeight - sRect.right, sRect.bottom, sHeight - sRect.left);\r\n    } else if (getRequiredRotation() == 180) {\r\n        return new Rect(sWidth - sRect.right, sHeight - sRect.bottom, sWidth - sRect.left, sHeight - sRect.top);\r\n    } else {\r\n        return new Rect(sWidth - sRect.bottom, sRect.left, sWidth - sRect.top, sRect.right);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.Options.isSliderSnaking",
	"Comment": "returns whether or not sliders should snake in or just appear fully at once.",
	"Method": "boolean isSliderSnaking(){\r\n    return GameOption.SNAKING_SLIDERS.getBooleanValue();\r\n}"
}, {
	"Path": "com.android.volley.toolbox.NetworkImageView.setErrorImageResId",
	"Comment": "sets the error image resource id to be used for this view in the event that the imagerequested fails to load.",
	"Method": "void setErrorImageResId(int errorImage){\r\n    mErrorImageId = errorImage;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.setDoubleClickEnabled",
	"Comment": "sets whether the widget implements double click mouse behavior.",
	"Method": "void setDoubleClickEnabled(boolean enable){\r\n    checkWidget();\r\n    doubleClickEnabled = enable;\r\n}"
}, {
	"Path": "org.newdawn.slick.gui.TextField.doPaste",
	"Comment": "do the paste into the field, overrideable for custom behaviour",
	"Method": "void doPaste(String text){\r\n    recordOldPosition();\r\n    for (int i = 0; i < text.length(); i++) {\r\n        keyPressed(-1, text.charAt(i));\r\n    }\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.resetScaleAndCenter",
	"Comment": "fully zoom out and return the image to the middle of the screen. this might be useful if you have a view pagerand want images to be reset when the user has moved to another page.",
	"Method": "void resetScaleAndCenter(){\r\n    this.anim = null;\r\n    this.pendingScale = limitedScale(0);\r\n    if (isImageReady()) {\r\n        this.sPendingCenter = new PointF(sWidth() / 2, sHeight() / 2);\r\n    } else {\r\n        this.sPendingCenter = new PointF(0, 0);\r\n    }\r\n    invalidate();\r\n}"
}, {
	"Path": "io.opencensus.internal.Provider.createInstance",
	"Comment": "tries to create an instance of the given rawclass as a subclass of the given superclass.",
	"Method": "T createInstance(Class<?> rawClass,Class<T> superclass){\r\n    try {\r\n        return rawClass.asSubclass(superclass).getConstructor().newInstance();\r\n    } catch (Exception e) {\r\n        throw new ServiceConfigurationError(\"Provider \" + rawClass.getName() + \" could not be instantiated.\", e);\r\n    }\r\n}"
}, {
	"Path": "io.opencensus.contrib.agent.instrumentation.ExecutorInstrumentationBenchmark.automatic",
	"Comment": "this benchmark attempts to measure the performance with automatic context propagation.",
	"Method": "void automatic(Blackhole blackhole){\r\n    MoreExecutors.directExecutor().execute(new MyRunnable(blackhole));\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.setOrientation",
	"Comment": "sets the image orientation. this can be freely called at any time.",
	"Method": "void setOrientation(int orientation){\r\n    if (!VALID_ORIENTATIONS.contains(orientation)) {\r\n        throw new IllegalArgumentException(\"Invalid orientation: \" + orientation);\r\n    }\r\n    this.orientation = orientation;\r\n    reset(false);\r\n    invalidate();\r\n    requestLayout();\r\n}"
}, {
	"Path": "io.opencensus.exporter.stats.stackdriver.StackdriverExporterWorker.registerMetricDescriptor",
	"Comment": "exact same metric has already been registered. returns false otherwise.",
	"Method": "boolean registerMetricDescriptor(io.opencensus.metrics.export.MetricDescriptor metricDescriptor){\r\n    io.opencensus.metrics.export.MetricDescriptor existingMetricDescriptor = registeredMetricDescriptors.get(metricDescriptor.getName());\r\n    if (existingMetricDescriptor != null) {\r\n        if (existingMetricDescriptor.equals(metricDescriptor)) {\r\n            return true;\r\n        } else {\r\n            logger.log(Level.WARNING, \"A different metric with the same name is already registered: \" + existingMetricDescriptor);\r\n            return false;\r\n        }\r\n    }\r\n    registeredMetricDescriptors.put(metricDescriptor.getName(), metricDescriptor);\r\n    Span span = tracer.getCurrentSpan();\r\n    span.addAnnotation(\"Create Stackdriver Metric.\");\r\n    MetricDescriptor stackDriverMetricDescriptor = StackdriverExportUtils.createMetricDescriptor(metricDescriptor, projectId, domain, displayNamePrefix);\r\n    CreateMetricDescriptorRequest request = CreateMetricDescriptorRequest.newBuilder().setName(projectName.toString()).setMetricDescriptor(stackDriverMetricDescriptor).build();\r\n    try {\r\n        metricServiceClient.createMetricDescriptor(request);\r\n        span.addAnnotation(\"Finish creating MetricDescriptor.\");\r\n        return true;\r\n    } catch (ApiException e) {\r\n        logger.log(Level.WARNING, \"ApiException thrown when creating MetricDescriptor.\", e);\r\n        span.setStatus(Status.CanonicalCode.valueOf(e.getStatusCode().getCode().name()).toStatus().withDescription(\"ApiException thrown when creating MetricDescriptor: \" + exceptionMessage(e)));\r\n        return false;\r\n    } catch (Throwable e) {\r\n        logger.log(Level.WARNING, \"Exception thrown when creating MetricDescriptor.\", e);\r\n        span.setStatus(Status.UNKNOWN.withDescription(\"Exception thrown when creating MetricDescriptor: \" + exceptionMessage(e)));\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.debug_sleep",
	"Comment": "utility method for sleeping\twill only really sleep if debug has been enabled",
	"Method": "void debug_sleep(long ms){\r\n    if (debugMode) {\r\n        sleep(ms);\r\n    }\r\n}"
}, {
	"Path": "com.j256.ormlite.dao.BaseForeignCollection.retainAll",
	"Comment": "uses the iterator to run through the dao and retain only the items that are in the passed in collection. this\twill remove the items from the associated database table as well.",
	"Method": "boolean retainAll(Collection<?> collection){\r\n    if (dao == null) {\r\n        return false;\r\n    }\r\n    boolean changed = false;\r\n    CloseableIterator<T> iterator = closeableIterator();\r\n    try {\r\n        while (iterator.hasNext()) {\r\n            T data = iterator.next();\r\n            if (!collection.contains(data)) {\r\n                iterator.remove();\r\n                changed = true;\r\n            }\r\n        }\r\n        return changed;\r\n    } finally {\r\n        IOUtils.closeQuietly(iterator);\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Vector2f.normalise",
	"Comment": "normalise this vector and place the result in another vector.",
	"Method": "Vector2f normalise(Vector2f dest){\r\n    float l = length();\r\n    if (dest == null)\r\n        dest = new Vector2f(x / l, y / l);\r\n    else\r\n        dest.set(x / l, y / l);\r\n    return dest;\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.limitedSCenter",
	"Comment": "given a requested source center and scale, calculate what the actual center will have to be to keep the image inpan limits, keeping the requested center as near to the middle of the screen as allowed.",
	"Method": "PointF limitedSCenter(PointF sCenter,float scale){\r\n    PointF vTranslate = vTranslateForSCenter(sCenter, scale);\r\n    int mY = getHeight() / 2;\r\n    float sx = ((getWidth() / 2) - vTranslate.x) / scale;\r\n    float sy = ((getHeight() / 2) - vTranslate.y) / scale;\r\n    return new PointF(sx, sy);\r\n}"
}, {
	"Path": "org.lwjgl.opengles.GLContext.getSupportedExtensions",
	"Comment": "determine which extensions are available and returns the context profile mask. helper method to contextcapabilities.",
	"Method": "void getSupportedExtensions(Set<String> supported_extensions){\r\n    final String version = glGetString(GL_VERSION);\r\n    if (version == null)\r\n        throw new IllegalStateException(\"glGetString(GL_VERSION) returned null - possibly caused by missing current context.\");\r\n    final String VERSION_PREFIX = \"OpenGL ES \";\r\n    final StringTokenizer version_tokenizer = new StringTokenizer(version.substring(VERSION_PREFIX.length()), \". \");\r\n    int majorVersion = 0;\r\n    int minorVersion = 0;\r\n    try {\r\n        majorVersion = Integer.parseInt(version_tokenizer.nextToken());\r\n        minorVersion = Integer.parseInt(version_tokenizer.nextToken());\r\n    } catch (NumberFormatException e) {\r\n        LWJGLUtil.log(\"The major and/or minor OpenGL version is malformed: \" + e.getMessage());\r\n    }\r\n    if (3 <= majorVersion)\r\n        supported_extensions.add(\"OpenGLES30\");\r\n    if (2 <= majorVersion)\r\n        supported_extensions.add(\"OpenGLES20\");\r\n    final String extensions_string = glGetString(GL_EXTENSIONS);\r\n    if (extensions_string == null)\r\n        throw new IllegalStateException(\"glGetString(GL_EXTENSIONS) returned null - is there a context current?\");\r\n    final StringTokenizer tokenizer = new StringTokenizer(extensions_string);\r\n    while (tokenizer.hasMoreTokens()) supported_extensions.add(tokenizer.nextToken());\r\n}"
}, {
	"Path": "io.opencensus.exporter.stats.stackdriver.StackdriverExportUtils.createMetricDescriptor",
	"Comment": "convert a opencensus metricdescriptor to a stackdriver metricdescriptor",
	"Method": "MetricDescriptor createMetricDescriptor(io.opencensus.metrics.export.MetricDescriptor metricDescriptor,String projectId,String domain,String displayNamePrefix){\r\n    MetricDescriptor.Builder builder = MetricDescriptor.newBuilder();\r\n    String type = generateType(metricDescriptor.getName(), domain);\r\n    builder.setName(\"projects/\" + projectId + \"/metricDescriptors/\" + type);\r\n    builder.setType(type);\r\n    builder.setDescription(metricDescriptor.getDescription());\r\n    builder.setDisplayName(createDisplayName(metricDescriptor.getName(), displayNamePrefix));\r\n    for (LabelKey labelKey : metricDescriptor.getLabelKeys()) {\r\n        builder.addLabels(createLabelDescriptor(labelKey));\r\n    }\r\n    builder.addLabels(LabelDescriptor.newBuilder().setKey(OPENCENSUS_TASK).setDescription(OPENCENSUS_TASK_DESCRIPTION).setValueType(ValueType.STRING).build());\r\n    builder.setUnit(metricDescriptor.getUnit());\r\n    builder.setMetricKind(createMetricKind(metricDescriptor.getType()));\r\n    builder.setValueType(createValueType(metricDescriptor.getType()));\r\n    return builder.build();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.user.UserSelectOverlay.contains",
	"Comment": "returns true if the coordinates are within the overlay bounds.",
	"Method": "boolean contains(float cx,float cy){\r\n    return ((cx > x && cx < x + width) && (cy > y && cy < y + height));\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.ImageLoader.isLoading",
	"Comment": "returns whether an image is currently loading in another thread.",
	"Method": "boolean isLoading(){\r\n    return (loaderThread != null && loaderThread.isAlive());\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.invokeBlockAction",
	"Comment": "returns true if an action should not be performed when block selection in active",
	"Method": "boolean invokeBlockAction(int action){\r\n    switch(action) {\r\n        case ST.LINE_UP:\r\n        case ST.LINE_DOWN:\r\n        case ST.LINE_START:\r\n        case ST.LINE_END:\r\n        case ST.COLUMN_PREVIOUS:\r\n        case ST.COLUMN_NEXT:\r\n        case ST.PAGE_UP:\r\n        case ST.PAGE_DOWN:\r\n        case ST.WORD_PREVIOUS:\r\n        case ST.WORD_NEXT:\r\n        case ST.TEXT_START:\r\n        case ST.TEXT_END:\r\n        case ST.WINDOW_START:\r\n        case ST.WINDOW_END:\r\n            clearBlockSelection(false, false);\r\n            return false;\r\n        case ST.SELECT_LINE_UP:\r\n            doBlockLineVertical(true);\r\n            return true;\r\n        case ST.SELECT_LINE_DOWN:\r\n            doBlockLineVertical(false);\r\n            return true;\r\n        case ST.SELECT_LINE_START:\r\n            doBlockLineHorizontal(false);\r\n            return true;\r\n        case ST.SELECT_LINE_END:\r\n            doBlockLineHorizontal(true);\r\n            return false;\r\n        case ST.SELECT_COLUMN_PREVIOUS:\r\n            doBlockColumn(false);\r\n            return true;\r\n        case ST.SELECT_COLUMN_NEXT:\r\n            doBlockColumn(true);\r\n            return true;\r\n        case ST.SELECT_WORD_PREVIOUS:\r\n            doBlockWord(false);\r\n            return true;\r\n        case ST.SELECT_WORD_NEXT:\r\n            doBlockWord(true);\r\n            return true;\r\n        case ST.SELECT_ALL:\r\n            return false;\r\n        case ST.SELECT_TEXT_START:\r\n            doBlockContentStartEnd(false);\r\n            break;\r\n        case ST.SELECT_TEXT_END:\r\n            doBlockContentStartEnd(true);\r\n            break;\r\n        case ST.SELECT_PAGE_UP:\r\n        case ST.SELECT_PAGE_DOWN:\r\n        case ST.SELECT_WINDOW_START:\r\n        case ST.SELECT_WINDOW_END:\r\n            return true;\r\n        case ST.CUT:\r\n        case ST.COPY:\r\n        case ST.PASTE:\r\n            return false;\r\n        case ST.DELETE_PREVIOUS:\r\n        case ST.DELETE_NEXT:\r\n            if (blockXLocation != -1) {\r\n                insertBlockSelectionText((char) 0, action);\r\n                return true;\r\n            }\r\n            return false;\r\n        case ST.DELETE_WORD_PREVIOUS:\r\n        case ST.DELETE_WORD_NEXT:\r\n            return blockXLocation != -1;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.skins.Skin.isComboBurstRandom",
	"Comment": "returns whether combo bursts should appear in random order.",
	"Method": "boolean isComboBurstRandom(){\r\n    return comboBurstRandom;\r\n}"
}, {
	"Path": "org.lwjgl.util.WaveData.create",
	"Comment": "creates a wavedata container from the specified inputstream",
	"Method": "WaveData create(URL path,WaveData create,String path,WaveData create,InputStream is,WaveData create,byte[] buffer,WaveData create,ByteBuffer buffer,WaveData create,AudioInputStream ais){\r\n    AudioFormat audioformat = ais.getFormat();\r\n    int channels = 0;\r\n    if (audioformat.getChannels() == 1) {\r\n        if (audioformat.getSampleSizeInBits() == 8) {\r\n            channels = AL10.AL_FORMAT_MONO8;\r\n        } else if (audioformat.getSampleSizeInBits() == 16) {\r\n            channels = AL10.AL_FORMAT_MONO16;\r\n        } else {\r\n            assert false : \"Illegal sample size\";\r\n        }\r\n    } else if (audioformat.getChannels() == 2) {\r\n        if (audioformat.getSampleSizeInBits() == 8) {\r\n            channels = AL10.AL_FORMAT_STEREO8;\r\n        } else if (audioformat.getSampleSizeInBits() == 16) {\r\n            channels = AL10.AL_FORMAT_STEREO16;\r\n        } else {\r\n            assert false : \"Illegal sample size\";\r\n        }\r\n    } else {\r\n        assert false : \"Only mono or stereo is supported\";\r\n    }\r\n    ByteBuffer buffer = null;\r\n    try {\r\n        int available = ais.available();\r\n        if (available <= 0) {\r\n            available = ais.getFormat().getChannels() * (int) ais.getFrameLength() * ais.getFormat().getSampleSizeInBits() / 8;\r\n        }\r\n        byte[] buf = new byte[ais.available()];\r\n        int read = 0, total = 0;\r\n        while ((read = ais.read(buf, total, buf.length - total)) != -1 && total < buf.length) {\r\n            total += read;\r\n        }\r\n        buffer = convertAudioBytes(buf, audioformat.getSampleSizeInBits() == 16, audioformat.isBigEndian() ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN);\r\n    } catch (IOException ioe) {\r\n        return null;\r\n    }\r\n    WaveData wavedata = new WaveData(buffer, channels, (int) audioformat.getSampleRate());\r\n    try {\r\n        ais.close();\r\n    } catch (IOException ioe) {\r\n    }\r\n    return wavedata;\r\n}"
}, {
	"Path": "com.openhtmltopdf.swing.SwingReplacedElementFactory.lookupImageReplacedElement",
	"Comment": "retrieves a replacedelement for an image from cache, or null if not found.",
	"Method": "ReplacedElement lookupImageReplacedElement(Element elem,String ruri,int cssWidth,int cssHeight,ReplacedElement lookupImageReplacedElement,Element e,String uri){\r\n    return lookupImageReplacedElement(e, uri, -1, -1);\r\n}"
}, {
	"Path": "io.opencensus.metrics.Metrics.loadMetricsComponent",
	"Comment": "any provider that may be used for metricscomponent can be added here.",
	"Method": "MetricsComponent loadMetricsComponent(ClassLoader classLoader){\r\n    try {\r\n        return Provider.createInstance(Class.forName(\"io.opencensus.impl.metrics.MetricsComponentImpl\", true, classLoader), MetricsComponent.class);\r\n    } catch (ClassNotFoundException e) {\r\n        logger.log(Level.FINE, \"Couldn't load full implementation for MetricsComponent, now trying to load lite \" + \"implementation.\", e);\r\n    }\r\n    try {\r\n        return Provider.createInstance(Class.forName(\"io.opencensus.impllite.metrics.MetricsComponentImplLite\", true, classLoader), MetricsComponent.class);\r\n    } catch (ClassNotFoundException e) {\r\n        logger.log(Level.FINE, \"Couldn't load lite implementation for MetricsComponent, now using default \" + \"implementation for MetricsComponent.\", e);\r\n    }\r\n    return MetricsComponent.newNoopMetricsComponent();\r\n}"
}, {
	"Path": "org.lwjgl.opengl.NVVideoCaptureUtil.glQueryVideoCaptureDeviceNV",
	"Comment": "use this method to query the unique id of the physical device backing a\tvideo capture device handle.",
	"Method": "boolean glQueryVideoCaptureDeviceNV(long device,int attribute,IntBuffer value){\r\n    checkExtension();\r\n    BufferChecks.checkBuffer(value, 1);\r\n    return nglQueryVideoCaptureDeviceNV(getPeerInfo(), device, attribute, value, value.position());\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.DownloadNode.maxResultsShown",
	"Comment": "returns the max number of search result buttons to be shown at a time.",
	"Method": "int maxResultsShown(){\r\n    return maxResultsShown;\r\n}"
}, {
	"Path": "ddf.minim.ugens.Waves.randomNHarms",
	"Comment": "constructs a waveform by summing together the first numberofharmonics \tin the harmonic series with randomly chosen amplitudes. this often \tsounds like an organ.",
	"Method": "Wavetable randomNHarms(int numberOfHarmonics){\r\n    float[] harmAmps = new float[numberOfHarmonics];\r\n    for (int i = 0; i < numberOfHarmonics; i++) {\r\n        harmAmps[i] = (float) Math.random() * 2 - 1;\r\n    }\r\n    Wavetable builtWave = WavetableGenerator.gen10(tableSize, harmAmps);\r\n    builtWave.normalize();\r\n    return builtWave;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.setTextLimit",
	"Comment": "sets the text limit to the specified number of characters.the text limit specifies the amount of text thatthe user can type into the widget.",
	"Method": "void setTextLimit(int limit){\r\n    checkWidget();\r\n    if (limit == 0) {\r\n        SWT.error(SWT.ERROR_CANNOT_BE_ZERO);\r\n    }\r\n    textLimit = limit;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.BeatmapSetList.deleteSongGroup",
	"Comment": "deletes a song group from the list, and also deletes the beatmap\tdirectory associated with the node.",
	"Method": "boolean deleteSongGroup(BeatmapSetNode node){\r\n    if (node == null)\r\n        return false;\r\n    int index = node.index;\r\n    BeatmapSetNode ePrev = getBaseNode(index - 1), eCur = getBaseNode(index), eNext = getBaseNode(index + 1);\r\n    if (ePrev != null) {\r\n        if (ePrev.index == expandedIndex)\r\n            expandedEndNode.next = eNext;\r\n        else if (eNext != null && eNext.index == expandedIndex)\r\n            ePrev.next = expandedStartNode;\r\n        else\r\n            ePrev.next = eNext;\r\n    }\r\n    if (eNext != null) {\r\n        if (eNext.index == expandedIndex)\r\n            expandedStartNode.prev = ePrev;\r\n        else if (ePrev != null && ePrev.index == expandedIndex)\r\n            eNext.prev = expandedEndNode;\r\n        else\r\n            eNext.prev = ePrev;\r\n    }\r\n    BeatmapSet beatmapSet = node.getBeatmapSet();\r\n    Beatmap beatmap = beatmapSet.get(0);\r\n    nodes.remove(index);\r\n    parsedNodes.remove(eCur);\r\n    groupNodes.remove(eCur);\r\n    mapCount -= beatmapSet.size();\r\n    if (beatmap.beatmapSetID > 0)\r\n        MSIDdb.remove(beatmap.beatmapSetID);\r\n    for (Beatmap bm : beatmapSet) {\r\n        if (bm.md5Hash != null)\r\n            this.beatmapHashDB.remove(bm.md5Hash);\r\n    }\r\n    for (int i = index, size = size(); i < size; i++) nodes.get(i).index = i;\r\n    if (index == expandedIndex) {\r\n        expandedIndex = -1;\r\n        expandedStartNode = expandedEndNode = null;\r\n    } else if (expandedIndex > index) {\r\n        expandedIndex--;\r\n        BeatmapSetNode expandedNode = expandedStartNode;\r\n        for (int i = 0, size = expandedNode.getBeatmapSet().size(); i < size && expandedNode != null; i++, expandedNode = expandedNode.next) expandedNode.index = expandedIndex;\r\n    }\r\n    File dir = beatmap.getFile().getParentFile();\r\n    if (MusicController.trackExists() || MusicController.isTrackLoading()) {\r\n        File audioFile = MusicController.getBeatmap().audioFilename;\r\n        if (audioFile != null && audioFile.equals(beatmap.audioFilename)) {\r\n            MusicController.reset();\r\n            Utils.gc(true);\r\n        }\r\n    }\r\n    BeatmapDB.delete(dir.getName());\r\n    BeatmapWatchService ws = (Options.isWatchServiceEnabled()) ? BeatmapWatchService.get() : null;\r\n    if (ws != null)\r\n        ws.pause();\r\n    try {\r\n        Utils.deleteToTrash(dir);\r\n    } catch (IOException e) {\r\n        ErrorHandler.error(\"Could not delete song group.\", e, true);\r\n    }\r\n    if (ws != null)\r\n        ws.resume();\r\n    return true;\r\n}"
}, {
	"Path": "orestes.bloomfilter.cachesketch.ExpiringBloomFilter.reportWrite",
	"Comment": "reports a write on an object, adding it to the underlying bloom filter for the remaining ttl",
	"Method": "Long reportWrite(T element,TimeUnit unit,boolean reportWrite,T element){\r\n    return reportWrite(element, TimeUnit.MILLISECONDS) != null;\r\n}"
}, {
	"Path": "ddf.minim.AudioOutput.setDurationFactor",
	"Comment": "the duration factor of an audiooutput defines how durations passed to playnote calls \tare scaled before being queued. if your duration factor is 0.5 and you queue a note \twith a duration of 2, the actual duration will become 1. this might be useful if \tyou want to queue a string of notes first with long durations and then very short durations.\tby default the duration factor is 1.",
	"Method": "void setDurationFactor(float durationFactor){\r\n    noteManager.setDurationFactor(durationFactor);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.OszUnpacker.unpackAllFiles",
	"Comment": "invokes the unpacker for each osz archive in a root directory.",
	"Method": "File[] unpackAllFiles(File root,File dest){\r\n    List<File> dirs = new ArrayList<File>();\r\n    files = root.listFiles(new FilenameFilter() {\r\n        @Override\r\n        public boolean accept(File dir, String name) {\r\n            return name.toLowerCase().endsWith(\".osz\");\r\n        }\r\n    });\r\n    if (files == null || files.length < 1) {\r\n        files = null;\r\n        return new File[0];\r\n    }\r\n    BeatmapWatchService ws = (Options.isWatchServiceEnabled()) ? BeatmapWatchService.get() : null;\r\n    if (ws != null)\r\n        ws.pause();\r\n    for (File file : files) {\r\n        fileIndex++;\r\n        String dirName = file.getName().substring(0, file.getName().lastIndexOf('.'));\r\n        File songDir = new File(dest, dirName);\r\n        if (!songDir.isDirectory()) {\r\n            songDir.mkdir();\r\n            Utils.unzip(file, songDir);\r\n            file.delete();\r\n            dirs.add(songDir);\r\n        }\r\n    }\r\n    if (ws != null)\r\n        ws.resume();\r\n    fileIndex = -1;\r\n    files = null;\r\n    if (!dirs.isEmpty()) {\r\n        String text = String.format(\"Imported %d new beatmap pack%s.\", dirs.size(), dirs.size() == 1 ? \"\" : \"s\");\r\n        UI.getNotificationManager().sendNotification(text);\r\n    }\r\n    return dirs.toArray(new File[dirs.size()]);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.OszUnpacker.unpackAllFiles",
	"Comment": "invokes the unpacker for each osz archive in a root directory.",
	"Method": "File[] unpackAllFiles(File root,File dest){\r\n    return name.toLowerCase().endsWith(\".osz\");\r\n}"
}, {
	"Path": "orestes.bloomfilter.cachesketch.ExpiringBloomFilter.reportWrites",
	"Comment": "reports a write on a list of objects, adding it to the underlying bloom filter for the remaining ttl",
	"Method": "List<Boolean> reportWrites(List<T> elements,List<Long> reportWrites,List<T> elements,TimeUnit unit){\r\n    return elements.stream().map(el -> reportWrite(el, unit)).collect(Collectors.toList());\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.Download.getTimeRemaining",
	"Comment": "returns the last calculated eta, or null if not downloading.",
	"Method": "String getTimeRemaining(){\r\n    updateReadSoFar();\r\n    return lastTimeRemaining;\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testRunningOverflowHidden",
	"Comment": "tests a running div with overflow hidden containing a larger replaced img.",
	"Method": "void testRunningOverflowHidden(){\r\n    assertTrue(vt.runTest(\"running-overflow-hidden\"));\r\n}"
}, {
	"Path": "ddf.minim.AudioOutput.getDurationFactor",
	"Comment": "return the current value of the duration factor for this output.",
	"Method": "float getDurationFactor(){\r\n    return noteManager.getDurationFactor();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.states.Game.musicPositionBarContains",
	"Comment": "returns true if the coordinates are within the music position bar bounds.",
	"Method": "boolean musicPositionBarContains(float cx,float cy){\r\n    return ((cx > musicBarX && cx < musicBarX + musicBarWidth) && (cy > musicBarY && cy < musicBarY + musicBarHeight));\r\n}"
}, {
	"Path": "com.android.volley.Request.setShouldCache",
	"Comment": "set whether or not responses to this request should be cached.",
	"Method": "Request<?> setShouldCache(boolean shouldCache){\r\n    mShouldCache = shouldCache;\r\n    return this;\r\n}"
}, {
	"Path": "com.j256.ormlite.field.FieldType.extractRawJavaFieldValue",
	"Comment": "return the value from the field in the object that is defined by this fieldtype.",
	"Method": "FV extractRawJavaFieldValue(Object object){\r\n    Object val;\r\n    if (fieldGetMethod == null) {\r\n        try {\r\n            val = field.get(object);\r\n        } catch (Exception e) {\r\n            throw SqlExceptionUtil.create(\"Could not get field value for \" + this, e);\r\n        }\r\n    } else {\r\n        try {\r\n            val = fieldGetMethod.invoke(object);\r\n        } catch (Exception e) {\r\n            throw SqlExceptionUtil.create(\"Could not call \" + fieldGetMethod + \" for \" + this, e);\r\n        }\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    FV converted = (FV) val;\r\n    return converted;\r\n}"
}, {
	"Path": "ddf.minim.ugens.TickRate.isInterpolating",
	"Comment": "returns whether or not this tickrate currently has interpolation on.",
	"Method": "boolean isInterpolating(){\r\n    return bInterpolate;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.BeatmapDifficultyCalculator.calculate",
	"Comment": "calculates the difficulty values and star ratings for the beatmap.",
	"Method": "void calculate(){\r\n    if (beatmap.objects == null || beatmap.timingPoints == null) {\r\n        Log.error(String.format(\"Trying to calculate difficulty values for beatmap '%s' with %s not yet loaded.\", beatmap.toString(), (beatmap.objects == null) ? \"hit objects\" : \"timing points\"));\r\n        return;\r\n    }\r\n    HitObject[] hitObjects = beatmap.objects;\r\n    this.tpHitObjects = new tpHitObject[hitObjects.length];\r\n    float circleRadius = (PLAYFIELD_WIDTH / 16.0f) * (1.0f - 0.7f * (beatmap.circleSize - 5.0f) / 5.0f);\r\n    int timingPointIndex = 0;\r\n    float beatLengthBase = 1, beatLength = 1;\r\n    if (!beatmap.timingPoints.isEmpty()) {\r\n        TimingPoint timingPoint = beatmap.timingPoints.get(0);\r\n        if (!timingPoint.isInherited()) {\r\n            beatLengthBase = beatLength = timingPoint.getBeatLength();\r\n            timingPointIndex++;\r\n        }\r\n    }\r\n    for (int i = 0; i < hitObjects.length; i++) {\r\n        HitObject hitObject = hitObjects[i];\r\n        int hitObjectTime = hitObject.getTime();\r\n        while (timingPointIndex < beatmap.timingPoints.size()) {\r\n            TimingPoint timingPoint = beatmap.timingPoints.get(timingPointIndex);\r\n            if (timingPoint.getTime() > hitObjectTime)\r\n                break;\r\n            if (!timingPoint.isInherited())\r\n                beatLengthBase = beatLength = timingPoint.getBeatLength();\r\n            else\r\n                beatLength = beatLengthBase * timingPoint.getSliderMultiplier();\r\n            timingPointIndex++;\r\n        }\r\n        tpHitObjects[i] = new tpHitObject(hitObject, circleRadius, beatmap, beatLength);\r\n    }\r\n    if (!calculateStrainValues()) {\r\n        Log.error(\"Could not compute strain values. Aborting difficulty calculation.\");\r\n        return;\r\n    }\r\n    difficulties[DIFFICULTY_SPEED] = calculateDifficulty(DIFFICULTY_SPEED);\r\n    difficulties[DIFFICULTY_AIM] = calculateDifficulty(DIFFICULTY_AIM);\r\n    stars[DIFFICULTY_SPEED] = Math.sqrt(difficulties[DIFFICULTY_SPEED]) * STAR_SCALING_FACTOR;\r\n    stars[DIFFICULTY_AIM] = Math.sqrt(difficulties[DIFFICULTY_AIM]) * STAR_SCALING_FACTOR;\r\n    this.starRating = stars[DIFFICULTY_SPEED] + stars[DIFFICULTY_AIM] + Math.abs(stars[DIFFICULTY_SPEED] - stars[DIFFICULTY_AIM]) * EXTREME_SCALING_FACTOR;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.audio.MusicController.isTrackDimmed",
	"Comment": "returns whether or not the volume of the current track, if any,\thas been dimmed.",
	"Method": "boolean isTrackDimmed(){\r\n    return trackDimmed;\r\n}"
}, {
	"Path": "org.mewx.wenku8.reader.view.WenkuReaderPageView.calcFromLast",
	"Comment": "calc page from last to firstlastlineindex & lastwordindex set.",
	"Method": "void calcFromLast(){\r\n    int heightSum = 0;\r\n    boolean isFirst = true;\r\n    mLoader.setCurrentIndex(lastLineIndex);\r\n    LineLoop: for (int curLineIndex = lastLineIndex, curWordIndex = lastWordIndex; curLineIndex >= 0; ) {\r\n        WenkuReaderLoader.ElementType curType = mLoader.getCurrentType();\r\n        String curString = mLoader.getCurrentAsString();\r\n        if (curType == WenkuReaderLoader.ElementType.IMAGE_DEPENDENT && lineInfoList.size() != 0) {\r\n            Log.d(\"MewX\", \"jump 1\");\r\n            firstLineIndex = curLineIndex + 1;\r\n            firstWordIndex = 0;\r\n            mLoader.setCurrentIndex(firstLineIndex);\r\n            lineInfoList = new ArrayList();\r\n            calcFromFirst();\r\n            break;\r\n        } else if (curType == WenkuReaderLoader.ElementType.IMAGE_DEPENDENT) {\r\n            lastLineIndex = firstLineIndex = mLoader.getCurrentIndex();\r\n            firstWordIndex = 0;\r\n            lastWordIndex = mLoader.getCurrentAsString().length() - 1;\r\n            LineInfo li = new LineInfo();\r\n            li.type = WenkuReaderLoader.ElementType.IMAGE_DEPENDENT;\r\n            li.text = mLoader.getCurrentAsString();\r\n            lineInfoList.add(li);\r\n            break;\r\n        }\r\n        int tempWidth = 0;\r\n        List<LineInfo> curList = new ArrayList();\r\n        String temp = \"\";\r\n        for (int i = 0; i < curString.length(); ) {\r\n            if (i == 0) {\r\n                tempWidth += fontHeight + fontHeight;\r\n                temp = \"�?�?\";\r\n            }\r\n            String c = curString.charAt(i) + \"\";\r\n            int width = (int) textPaint.measureText(c);\r\n            if (tempWidth + width > textAreaSize.x) {\r\n                LineInfo li = new LineInfo();\r\n                li.type = WenkuReaderLoader.ElementType.TEXT;\r\n                li.text = temp;\r\n                curList.add(li);\r\n                if (i >= curWordIndex)\r\n                    break;\r\n                tempWidth = 0;\r\n                temp = \"\";\r\n                continue;\r\n            } else {\r\n                temp = temp + c;\r\n                tempWidth += width;\r\n                i++;\r\n            }\r\n            if (i == curString.length()) {\r\n                LineInfo li = new LineInfo();\r\n                li.type = WenkuReaderLoader.ElementType.TEXT;\r\n                li.text = temp;\r\n                curList.add(li);\r\n            }\r\n        }\r\n        for (int i = curList.size() - 1; i >= 0; i--) {\r\n            if (isFirst)\r\n                isFirst = false;\r\n            else if (i == curList.size() - 1)\r\n                heightSum += pxParagraphDistance;\r\n            else\r\n                heightSum += pxLineDistance;\r\n            heightSum += fontHeight;\r\n            if (heightSum > textAreaSize.y) {\r\n                int indexCount = -2;\r\n                for (int j = 0; j <= i; j++) indexCount += curList.get(j).text.length();\r\n                firstLineIndex = curLineIndex;\r\n                firstWordIndex = indexCount + 1;\r\n                if (firstWordIndex + 1 >= curString.length()) {\r\n                    firstLineIndex = curLineIndex + 1;\r\n                    firstWordIndex = 0;\r\n                }\r\n                break LineLoop;\r\n            }\r\n            lineInfoList.add(0, curList.get(i));\r\n        }\r\n        for (LineInfo li : lineInfoList) Log.d(\"MewX\", \"full: \" + li.text);\r\n        if (curLineIndex - 1 >= 0) {\r\n            mLoader.setCurrentIndex(--curLineIndex);\r\n            curWordIndex = mLoader.getCurrentAsString().length();\r\n        } else {\r\n            Log.d(\"MewX\", \"jump 2\");\r\n            firstLineIndex = 0;\r\n            firstWordIndex = 0;\r\n            mLoader.setCurrentIndex(firstLineIndex);\r\n            lineInfoList = new ArrayList();\r\n            calcFromFirst();\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.opencensus.implcore.internal.CurrentState.set",
	"Comment": "sets current state to the given state. returns true if the current state is changed, falseotherwise.",
	"Method": "boolean set(State state){\r\n    while (true) {\r\n        InternalState internalState = currentInternalState.get();\r\n        checkState(!internalState.isRead, \"State was already read, cannot set state.\");\r\n        if (state == internalState.state) {\r\n            return false;\r\n        } else {\r\n            if (!currentInternalState.compareAndSet(internalState, state == State.ENABLED ? InternalState.ENABLED_NOT_READ : InternalState.DISABLED_NOT_READ)) {\r\n                continue;\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.util.Rectangle.union",
	"Comment": "computes the union of this rectangle with the \tspecified rectangle. returns a new \trectangle that \trepresents the union of the two rectangles",
	"Method": "WritableRectangle union(ReadableRectangle r,WritableRectangle dest){\r\n    int x1 = Math.min(x, r.getX());\r\n    int x2 = Math.max(x + width, r.getX() + r.getWidth());\r\n    int y1 = Math.min(y, r.getY());\r\n    int y2 = Math.max(y + height, r.getY() + r.getHeight());\r\n    dest.setBounds(x1, y1, x2 - x1, y2 - y1);\r\n    return dest;\r\n}"
}, {
	"Path": "me.imid.swipebacklayout.lib.ViewDragHelper.continueSettling",
	"Comment": "move the captured settling view by the appropriate amount for the currenttime. if continuesettling returns true, the caller shouldcall it again on the next frame to continue.",
	"Method": "boolean continueSettling(boolean deferCallbacks){\r\n    if (mDragState == STATE_SETTLING) {\r\n        boolean keepGoing = mScroller.computeScrollOffset();\r\n        final int x = mScroller.getCurrX();\r\n        final int y = mScroller.getCurrY();\r\n        final int dx = x - mCapturedView.getLeft();\r\n        final int dy = y - mCapturedView.getTop();\r\n        if (dx != 0) {\r\n            mCapturedView.offsetLeftAndRight(dx);\r\n        }\r\n        if (dy != 0) {\r\n            mCapturedView.offsetTopAndBottom(dy);\r\n        }\r\n        if (dx != 0 || dy != 0) {\r\n            mCallback.onViewPositionChanged(mCapturedView, x, y, dx, dy);\r\n        }\r\n        if (keepGoing && x == mScroller.getFinalX() && y == mScroller.getFinalY()) {\r\n            mScroller.abortAnimation();\r\n            keepGoing = mScroller.isFinished();\r\n        }\r\n        if (!keepGoing) {\r\n            if (deferCallbacks) {\r\n                mParentView.post(mSetIdleRunnable);\r\n            } else {\r\n                setDragState(STATE_IDLE);\r\n            }\r\n        }\r\n    }\r\n    return mDragState == STATE_SETTLING;\r\n}"
}, {
	"Path": "ddf.minim.analysis.FourierTransform.getAverageBandWidth",
	"Comment": "returns the bandwidth of the requested average band. using this information and the return value of getaveragecenterfrequency you can determine the lower and upper frequency of any average band.",
	"Method": "float getAverageBandWidth(int averageIndex){\r\n    if (whichAverage == LINAVG) {\r\n        int avgWidth = (int) spectrum.length / averages.length;\r\n        return avgWidth * getBandWidth();\r\n    } else if (whichAverage == LOGAVG) {\r\n        int octave = averageIndex / avgPerOctave;\r\n        float lowFreq, hiFreq, freqStep;\r\n        if (octave == 0) {\r\n            lowFreq = 0;\r\n        } else {\r\n            lowFreq = (sampleRate / 2) / (float) Math.pow(2, octaves - octave);\r\n        }\r\n        hiFreq = (sampleRate / 2) / (float) Math.pow(2, octaves - octave - 1);\r\n        freqStep = (hiFreq - lowFreq) / avgPerOctave;\r\n        return freqStep;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.objects.curves.CurveType.init",
	"Comment": "initialize the curve points and distance.\tmust be called by inherited classes.",
	"Method": "void init(float approxlength){\r\n    this.ncurve = (int) (approxlength / 4) + 2;\r\n    this.curve = new Vec2f[ncurve];\r\n    for (int i = 0; i < ncurve; i++) curve[i] = pointAt(i / (float) (ncurve - 1));\r\n    this.curveDis = new float[ncurve];\r\n    this.totalDistance = 0;\r\n    for (int i = 0; i < ncurve; i++) {\r\n        curveDis[i] = (i == 0) ? 0 : curve[i].cpy().sub(curve[i - 1]).len();\r\n        totalDistance += curveDis[i];\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.skins.Skin.getComboFontOverlap",
	"Comment": "returns the amount of overlap between the combo font sprites.",
	"Method": "int getComboFontOverlap(){\r\n    return comboOverlap;\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix4f.scale",
	"Comment": "scales the source matrix and put the result in the destination matrix",
	"Method": "Matrix4f scale(Vector3f vec,Matrix4f scale,Vector3f vec,Matrix4f src,Matrix4f dest){\r\n    if (dest == null)\r\n        dest = new Matrix4f();\r\n    dest.m00 = src.m00 * vec.x;\r\n    dest.m01 = src.m01 * vec.x;\r\n    dest.m02 = src.m02 * vec.x;\r\n    dest.m03 = src.m03 * vec.x;\r\n    dest.m10 = src.m10 * vec.y;\r\n    dest.m11 = src.m11 * vec.y;\r\n    dest.m12 = src.m12 * vec.y;\r\n    dest.m13 = src.m13 * vec.y;\r\n    dest.m20 = src.m20 * vec.z;\r\n    dest.m21 = src.m21 * vec.z;\r\n    dest.m22 = src.m22 * vec.z;\r\n    dest.m23 = src.m23 * vec.z;\r\n    return dest;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.GameData.getGrade",
	"Comment": "returns letter grade based on score data,\tor grade.null if no objects have been processed.",
	"Method": "Grade getGrade(int hit300,int hit100,int hit50,int miss,boolean silver,Grade getGrade){\r\n    boolean silver = (scoreData == null) ? (GameMod.HIDDEN.isActive() || GameMod.FLASHLIGHT.isActive()) : (scoreData.mods & (GameMod.HIDDEN.getBit() | GameMod.FLASHLIGHT.getBit())) != 0;\r\n    return getGrade(hitResultCount[HIT_300], hitResultCount[HIT_100], hitResultCount[HIT_50], hitResultCount[HIT_MISS], silver);\r\n}"
}, {
	"Path": "ddf.minim.ugens.Wavetable.scale",
	"Comment": "multiplies each value of the underlying waveform by scale.",
	"Method": "void scale(float scale){\r\n    for (int i = 0; i < waveform.length; i++) {\r\n        waveform[i] *= scale;\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.DownloadNode.downloadContains",
	"Comment": "returns true if the coordinates are within the bounds of the\tdownload information button at the given index.",
	"Method": "boolean downloadContains(float cx,float cy,int index){\r\n    float y = infoBaseY + (index * infoHeight);\r\n    return ((cx > infoBaseX && cx <= containerWidth) && (cy > y && cy < y + infoHeight));\r\n}"
}, {
	"Path": "org.lwjgl.examples.spaceinvaders.Game.notifyWin",
	"Comment": "notification that the player has won since all the aliens\tare dead.",
	"Method": "void notifyWin(){\r\n    message = youWin;\r\n    waitingForKeyPress = true;\r\n    soundManager.playSound(SOUND_WIN);\r\n}"
}, {
	"Path": "com.openhtmltopdf.resource.FSEntityResolver.getEntities",
	"Comment": "returns an unmodifiable map of entities parsed by this resolver.",
	"Method": "Map<String, String> getEntities(){\r\n    return Collections.unmodifiableMap(entities);\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.getYOffset",
	"Comment": "returns the distance from the y drawing location to the top most pixel of the \tspecified text.",
	"Method": "int getYOffset(String text){\r\n    if (text == null)\r\n        throw new IllegalArgumentException(\"text cannot be null.\");\r\n    DisplayList displayList = null;\r\n    if (displayListCaching) {\r\n        displayList = (DisplayList) displayLists.get(text);\r\n        if (displayList != null && displayList.yOffset != null)\r\n            return displayList.yOffset.intValue();\r\n    }\r\n    int index = text.indexOf('\\n');\r\n    if (index != -1)\r\n        text = text.substring(0, index);\r\n    char[] chars = text.toCharArray();\r\n    GlyphVector vector = font.layoutGlyphVector(GlyphPage.renderContext, chars, 0, chars.length, Font.LAYOUT_LEFT_TO_RIGHT);\r\n    int yOffset = ascent + vector.getPixelBounds(null, 0, 0).y;\r\n    if (displayList != null)\r\n        displayList.yOffset = new Short((short) yOffset);\r\n    return yOffset;\r\n}"
}, {
	"Path": "com.j256.ormlite.table.TableUtils.addDropTableStatements",
	"Comment": "generate and return the list of statements to drop a database table.",
	"Method": "void addDropTableStatements(DatabaseType databaseType,TableInfo<T, ID> tableInfo,List<String> statements){\r\n    List<String> statementsBefore = new ArrayList<String>();\r\n    List<String> statementsAfter = new ArrayList<String>();\r\n    for (FieldType fieldType : tableInfo.getFieldTypes()) {\r\n        databaseType.dropColumnArg(fieldType, statementsBefore, statementsAfter);\r\n    }\r\n    StringBuilder sb = new StringBuilder(64);\r\n    sb.append(\"DROP TABLE \");\r\n    databaseType.appendEscapedEntityName(sb, tableInfo.getTableName());\r\n    sb.append(' ');\r\n    statements.addAll(statementsBefore);\r\n    statements.add(sb.toString());\r\n    statements.addAll(statementsAfter);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.addVerifyKeyListener",
	"Comment": "adds a verify key listener. a verifykey event is sent by the widget when a key is pressed. the widget ignores the key press if the listener sets the doit field of the event to false.",
	"Method": "void addVerifyKeyListener(VerifyKeyListener listener){\r\n    checkWidget();\r\n    if (listener == null)\r\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\r\n    addListener(ST.VerifyKey, new StyledTextListener(listener));\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.replaceLast",
	"Comment": "replaces the last occurrence of the specified target substring with\tthe specified replacement string in a string.",
	"Method": "String replaceLast(String original,String target,String replacement){\r\n    int index = original.lastIndexOf(target);\r\n    if (index == -1) {\r\n        return original;\r\n    }\r\n    return original.substring(0, index) + replacement + original.substring(index + target.length());\r\n}"
}, {
	"Path": "com.joestelmach.natty.AbstractTest.parseSingleDate",
	"Comment": "parses the given value, asserting that one and only one date is produced.",
	"Method": "Date parseSingleDate(String value,Date referenceDate){\r\n    List<Date> dates = parseCollection(referenceDate, value);\r\n    Assert.assertEquals(1, dates.size());\r\n    return dates.get(0);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.DownloadNode.getTitle",
	"Comment": "returns the song title.\tif configured, the unicode string will be returned instead.",
	"Method": "String getTitle(){\r\n    return (Options.useUnicodeMetadata() && titleUnicode != null && !titleUnicode.isEmpty()) ? titleUnicode : title;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.skins.Skin.isAllowSliderBallTint",
	"Comment": "returns whether the slider ball should be tinted with the slider combo color.",
	"Method": "boolean isAllowSliderBallTint(){\r\n    return allowSliderBallTint;\r\n}"
}, {
	"Path": "com.j256.ormlite.field.FieldType.getFieldValueIfNotDefault",
	"Comment": "return the value of field in the data argument if it is not the default value for the class. if it is the default\tthen null is returned.",
	"Method": "FV getFieldValueIfNotDefault(Object object){\r\n    @SuppressWarnings(\"unchecked\")\r\n    FV fieldValue = (FV) extractJavaFieldValue(object);\r\n    if (isFieldValueDefault(fieldValue)) {\r\n        return null;\r\n    } else {\r\n        return fieldValue;\r\n    }\r\n}"
}, {
	"Path": "ddf.minim.ugens.Wavetable.offset",
	"Comment": "apply a dc offset to this wavetable. in other words, add\tamount to every sample.",
	"Method": "void offset(float amount){\r\n    for (int i = 0; i < waveform.length; ++i) {\r\n        waveform[i] += amount;\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.util.mapped.MappedSet.create",
	"Comment": "creates a mappedset by linking the specified mappedobjects.",
	"Method": "MappedSet2 create(MappedObject a,MappedObject b,MappedSet3 create,MappedObject a,MappedObject b,MappedObject c,MappedSet4 create,MappedObject a,MappedObject b,MappedObject c,MappedObject d){\r\n    return new MappedSet4(a, b, c, d);\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.displaylist.PagedBoxCollector.getMaxXFromTransformedBox",
	"Comment": "there is a matrix in effect. we need the max x to see how many shadow pages need creating.",
	"Method": "double getMaxXFromTransformedBox(Rectangle bounds,AffineTransform transform){\r\n    FourPoint corners = getCornersFromTransformedBounds(bounds, transform);\r\n    double maxX = Math.max(corners.ul.getX(), corners.ur.getX());\r\n    maxX = Math.max(corners.ll.getX(), maxX);\r\n    maxX = Math.max(corners.lr.getX(), maxX);\r\n    return maxX;\r\n}"
}, {
	"Path": "com.openhtmltopdf.layout.LayoutContext.getBidiSplitterFactory",
	"Comment": "the bidi splitter is used to split text runs into ltr and rtl visual ordering.",
	"Method": "BidiSplitterFactory getBidiSplitterFactory(){\r\n    return this._bidiSplitterFactory;\r\n}"
}, {
	"Path": "com.joestelmach.natty.WalkerState.seasonalDateFromIcs",
	"Comment": "finds and returns the date for the given event summary and year within the given ics file,or null if not present.",
	"Method": "Date seasonalDateFromIcs(String icsFileName,String eventSummary,int year){\r\n    Map<Integer, Date> dates = getDatesFromIcs(icsFileName, eventSummary, year, year);\r\n    return dates.get(year - (eventSummary.equals(Holiday.NEW_YEARS_EVE.getSummary()) ? 1 : 0));\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix2f.invert",
	"Comment": "invert the source matrix and place the result in the destination matrix.",
	"Method": "Matrix invert(Matrix2f invert,Matrix2f src,Matrix2f dest){\r\n    float determinant = src.determinant();\r\n    if (determinant != 0) {\r\n        if (dest == null)\r\n            dest = new Matrix2f();\r\n        float determinant_inv = 1f / determinant;\r\n        float t00 = src.m11 * determinant_inv;\r\n        float t01 = -src.m01 * determinant_inv;\r\n        float t11 = src.m00 * determinant_inv;\r\n        float t10 = -src.m10 * determinant_inv;\r\n        dest.m00 = t00;\r\n        dest.m01 = t01;\r\n        dest.m10 = t10;\r\n        dest.m11 = t11;\r\n        return dest;\r\n    } else\r\n        return null;\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testHorizPageOverflowAbsolute",
	"Comment": "tests that absolute positioned blocks overflow onto inserted shadow page.",
	"Method": "void testHorizPageOverflowAbsolute(){\r\n    assertTrue(vt.runTest(\"horiz-page-overflow-absolute\"));\r\n}"
}, {
	"Path": "com.j256.ormlite.field.FieldType.getJavaDefaultValueDefault",
	"Comment": "return whether or not the field value passed in is the default value for the type of the field. null will return\ttrue.",
	"Method": "Object getJavaDefaultValueDefault(){\r\n    if (field.getType() == boolean.class) {\r\n        return DEFAULT_VALUE_BOOLEAN;\r\n    } else if (field.getType() == byte.class || field.getType() == Byte.class) {\r\n        return DEFAULT_VALUE_BYTE;\r\n    } else if (field.getType() == char.class || field.getType() == Character.class) {\r\n        return DEFAULT_VALUE_CHAR;\r\n    } else if (field.getType() == short.class || field.getType() == Short.class) {\r\n        return DEFAULT_VALUE_SHORT;\r\n    } else if (field.getType() == int.class || field.getType() == Integer.class) {\r\n        return DEFAULT_VALUE_INT;\r\n    } else if (field.getType() == long.class || field.getType() == Long.class) {\r\n        return DEFAULT_VALUE_LONG;\r\n    } else if (field.getType() == float.class || field.getType() == Float.class) {\r\n        return DEFAULT_VALUE_FLOAT;\r\n    } else if (field.getType() == double.class || field.getType() == Double.class) {\r\n        return DEFAULT_VALUE_DOUBLE;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "ddf.minim.AudioInput.enableMonitoring",
	"Comment": "when monitoring is enabled, you will be able to hear the audio that is coming through the input.",
	"Method": "void enableMonitoring(){\r\n    if (hasControl(VOLUME)) {\r\n        setVolume(1);\r\n        m_isMonitoring = true;\r\n    } else if (hasControl(GAIN)) {\r\n        setGain(0);\r\n        m_isMonitoring = true;\r\n    } else {\r\n        Minim.error(\"Monitoring is not available on this AudioInput.\");\r\n    }\r\n}"
}, {
	"Path": "org.newdawn.slick.Input.isKeyPressed",
	"Comment": "check if a particular key has been pressed since this method \twas last called for the specified key",
	"Method": "boolean isKeyPressed(int code){\r\n    if (pressed[code]) {\r\n        pressed[code] = false;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "orestes.bloomfilter.FilterBuilder.optimalN",
	"Comment": "calculates the amount of elements a bloom filter for which the given configuration of size and hashes isoptimal.",
	"Method": "int optimalN(long k,long m){\r\n    return (int) Math.ceil((Math.log(2) * m) / k);\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.newmatch.Matcher.getPECascadedStyle",
	"Comment": "may return null.we assume that restyle has already been done by a getcascadedstyle if necessary.",
	"Method": "CascadedStyle getPECascadedStyle(Object e,String pseudoElement,CascadedStyle getPECascadedStyle,Object e,String pseudoElement){\r\n    Mapper em = getMapper(e);\r\n    return em.getPECascadedStyle(e, pseudoElement);\r\n}"
}, {
	"Path": "com.j256.ormlite.field.FieldType.getForeignIdField",
	"Comment": "return the id of the associated foreign object or null if none.",
	"Method": "FieldType getForeignIdField(){\r\n    return foreignIdField;\r\n}"
}, {
	"Path": "com.android.volley.toolbox.ImageLoader.batchResponse",
	"Comment": "starts the runnable for batched delivery of responses if it is not already started.",
	"Method": "void batchResponse(String cacheKey,BatchedImageRequest request){\r\n    mBatchedResponses.put(cacheKey, request);\r\n    if (mRunnable == null) {\r\n        mRunnable = new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                for (BatchedImageRequest bir : mBatchedResponses.values()) {\r\n                    for (ImageContainer container : bir.mContainers) {\r\n                        if (container.mListener == null) {\r\n                            continue;\r\n                        }\r\n                        if (bir.getError() == null) {\r\n                            container.mBitmap = bir.mResponseBitmap;\r\n                            container.mListener.onResponse(container, false);\r\n                        } else {\r\n                            container.mListener.onErrorResponse(bir.getError());\r\n                        }\r\n                    }\r\n                }\r\n                mBatchedResponses.clear();\r\n                mRunnable = null;\r\n            }\r\n        };\r\n        mHandler.postDelayed(mRunnable, mBatchResponseDelayMs);\r\n    }\r\n}"
}, {
	"Path": "com.android.volley.toolbox.ImageLoader.batchResponse",
	"Comment": "starts the runnable for batched delivery of responses if it is not already started.",
	"Method": "void batchResponse(String cacheKey,BatchedImageRequest request){\r\n    for (BatchedImageRequest bir : mBatchedResponses.values()) {\r\n        for (ImageContainer container : bir.mContainers) {\r\n            if (container.mListener == null) {\r\n                continue;\r\n            }\r\n            if (bir.getError() == null) {\r\n                container.mBitmap = bir.mResponseBitmap;\r\n                container.mListener.onResponse(container, false);\r\n            } else {\r\n                container.mListener.onErrorResponse(bir.getError());\r\n            }\r\n        }\r\n    }\r\n    mBatchedResponses.clear();\r\n    mRunnable = null;\r\n}"
}, {
	"Path": "io.opencensus.contrib.logcorrelation.log4j2.OpenCensusTraceContextDataInjector.rawContextData",
	"Comment": "note that this method does not need to return an object that can be passed to another thread.",
	"Method": "ReadOnlyStringMap rawContextData(){\r\n    return ContextDataUtils.getContextAndTracingData();\r\n}"
}, {
	"Path": "org.lwjgl.opengl.Display.makeCurrent",
	"Comment": "make the display the current rendering context for gl calls.",
	"Method": "void makeCurrent(){\r\n    drawable.makeCurrent();\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.newmatch.Selector.getAppropriateSibling",
	"Comment": "gets the appropriatesibling attribute of the selector object",
	"Method": "Object getAppropriateSibling(Object e,TreeResolver treeRes){\r\n    Object sibling = null;\r\n    switch(_axis) {\r\n        case IMMEDIATE_SIBLING_AXIS:\r\n            sibling = treeRes.getPreviousSiblingElement(e);\r\n            break;\r\n        default:\r\n            XRLog.exception(\"Bad sibling axis\");\r\n    }\r\n    return sibling;\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.trimExtensionByCapabilities",
	"Comment": "trims the passed file string based on the available capabilities",
	"Method": "String trimExtensionByCapabilities(String file){\r\n    if (!pack200Supported) {\r\n        file = file.replace(\".pack\", \"\");\r\n    }\r\n    if (!lzmaSupported && file.endsWith(\".lzma\")) {\r\n        file = file.replace(\".lzma\", \"\");\r\n        System.out.println(\"LZMA decoder (lzma.jar) not found, trying \" + file + \" without lzma extension.\");\r\n    }\r\n    return file;\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.InlineLayoutBox.getInlineChildren",
	"Comment": "either box, including inlinelayoutbox or inlinetext objects.",
	"Method": "List<Object> getInlineChildren(){\r\n    return _inlineChildren == null ? Collections.emptyList() : _inlineChildren;\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.forceCenterOnNextDraw",
	"Comment": "after the image has been changed or rotated the next call to draw, with dimensions known, should recenter the image.setting pending scale and center forces this.",
	"Method": "void forceCenterOnNextDraw(){\r\n    this.sPendingCenter = new PointF(0, 0);\r\n    this.scale = 0f;\r\n}"
}, {
	"Path": "ddf.minim.ugens.Waves.triangleh",
	"Comment": "builds an approximation of a perfect triangle wave by summing together\tharmonically related sine waves.",
	"Method": "Wavetable triangleh(int numberOfHarmonics){\r\n    float[] content = new float[numberOfHarmonics + 1];\r\n    for (int i = 0; i < numberOfHarmonics; i += 2) {\r\n        content[i] = (float) (Math.pow(-1, i / 2) * 8 / Math.PI / Math.PI / Math.pow(i + 1, 2));\r\n        content[i + 1] = 0;\r\n    }\r\n    return WavetableGenerator.gen10(tableSize, content);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.handleTextSet",
	"Comment": "called when the widget content is set programmatically, overwriting the old content. resets the caret position, selection and scroll offsets. recalculates the content width and scroll bars. redraws the widget.",
	"Method": "void handleTextSet(TextChangedEvent event){\r\n    reset();\r\n    int newCharCount = getCharCount();\r\n    sendAccessibleTextChanged(0, newCharCount, lastCharCount);\r\n    lastCharCount = newCharCount;\r\n    setAlignment();\r\n}"
}, {
	"Path": "com.j256.ormlite.table.DatabaseTableConfigLoader.loadDatabaseConfigFromReader",
	"Comment": "load in a number of database configuration entries from a buffered reader.",
	"Method": "List<DatabaseTableConfig<?>> loadDatabaseConfigFromReader(BufferedReader reader){\r\n    List<DatabaseTableConfig<?>> list = new ArrayList<DatabaseTableConfig<?>>();\r\n    while (true) {\r\n        DatabaseTableConfig<?> config = DatabaseTableConfigLoader.fromReader(reader);\r\n        if (config == null) {\r\n            break;\r\n        }\r\n        list.add(config);\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.GLContext.getFunctionAddress",
	"Comment": "helper method to get a pointer to a named function in the opengl library.",
	"Method": "long getFunctionAddress(String[] aliases,long getFunctionAddress,String name){\r\n    ByteBuffer buffer = MemoryUtil.encodeASCII(name);\r\n    return ngetFunctionAddress(MemoryUtil.getAddress(buffer));\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.updateSelection",
	"Comment": "updates the selection and caret position depending on the text change.if the selection intersects with the replaced text, the selection is reset and the caret moved to the end of the new text.if the selection is behind the replaced text it is moved so that thesame text remains selected.if the selection is before the replaced text it is left unchanged.",
	"Method": "void updateSelection(int startOffset,int replacedLength,int newLength){\r\n    if (selection.y <= startOffset) {\r\n        if (wordWrap)\r\n            setCaretLocation();\r\n        return;\r\n    }\r\n    if (selection.x < startOffset) {\r\n        internalRedrawRange(selection.x, startOffset - selection.x);\r\n    }\r\n    if (selection.y > startOffset + replacedLength && selection.x < startOffset + replacedLength) {\r\n        int netNewLength = newLength - replacedLength;\r\n        int redrawStart = startOffset + newLength;\r\n        internalRedrawRange(redrawStart, selection.y + netNewLength - redrawStart);\r\n    }\r\n    if (selection.y > startOffset && selection.x < startOffset + replacedLength) {\r\n        setSelection(startOffset + newLength, 0, true, false);\r\n    } else {\r\n        setSelection(selection.x + newLength - replacedLength, selection.y - selection.x, true, false);\r\n    }\r\n    setCaretLocation();\r\n}"
}, {
	"Path": "ddf.minim.ugens.Sampler.setSample",
	"Comment": "sets the sample data used by this sampler by copying the \tcontents of the provided multichannelbuffer into the internal buffer.",
	"Method": "void setSample(MultiChannelBuffer newSampleData,float sampleRate){\r\n    sampleData.set(newSampleData);\r\n    sampleDataSampleRate = sampleRate;\r\n    basePlaybackRate = sampleRate / sampleRate();\r\n}"
}, {
	"Path": "orestes.bloomfilter.cachesketch.ExpiringBloomFilter.cleanupTTLs",
	"Comment": "cleans all expired time to live entries that have been tracked.",
	"Method": "void cleanupTTLs(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.db.ScoreDB.updateDatabase",
	"Comment": "applies any database updates by comparing the current version to the\tstored version.does nothing if tables have not been created.",
	"Method": "void updateDatabase(){\r\n    try (Statement stmt = connection.createStatement()) {\r\n        int version = 0;\r\n        String sql = \"SELECT name FROM sqlite_master WHERE type = 'table' AND name = 'info'\";\r\n        ResultSet rs = stmt.executeQuery(sql);\r\n        boolean infoExists = rs.isBeforeFirst();\r\n        rs.close();\r\n        if (!infoExists) {\r\n            sql = \"SELECT name FROM sqlite_master WHERE type = 'table' AND name = 'scores'\";\r\n            ResultSet scoresRS = stmt.executeQuery(sql);\r\n            boolean scoresExists = scoresRS.isBeforeFirst();\r\n            scoresRS.close();\r\n            if (!scoresExists)\r\n                return;\r\n        } else {\r\n            sql = \"SELECT value FROM info WHERE key = 'version'\";\r\n            ResultSet versionRS = stmt.executeQuery(sql);\r\n            String versionString = (versionRS.next()) ? versionRS.getString(1) : \"0\";\r\n            versionRS.close();\r\n            try {\r\n                version = Integer.parseInt(versionString);\r\n            } catch (NumberFormatException e) {\r\n            }\r\n        }\r\n        if (version >= DATABASE_VERSION)\r\n            return;\r\n        for (String query : getUpdateQueries(version)) stmt.executeUpdate(query);\r\n        if (infoExists) {\r\n            PreparedStatement ps = connection.prepareStatement(\"REPLACE INTO info (key, value) VALUES ('version', ?)\");\r\n            ps.setString(1, Integer.toString(DATABASE_VERSION));\r\n            ps.executeUpdate();\r\n            ps.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.PointerBuffer.remaining",
	"Comment": "returns the number of elements between the current position and the\tlimit.",
	"Method": "int remaining(){\r\n    return view.remaining();\r\n}"
}, {
	"Path": "org.lwjgl.util.glu.tessellation.Sweep.AddWinding",
	"Comment": "when we merge two edges into one, we need to compute the combinedwinding of the new edge.",
	"Method": "void AddWinding(GLUhalfEdge eDst,GLUhalfEdge eSrc){\r\n    eDst.winding += eSrc.winding;\r\n    eDst.Sym.winding += eSrc.Sym.winding;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGLKHRReusableSync.eglClientWaitSyncKHR",
	"Comment": "blocks the calling thread until the specified sync object is\tsignaled, or until a specified timeout value expires.",
	"Method": "int eglClientWaitSyncKHR(EGLDisplay dpy,EGLSyncKHR sync,int flags,long timeout){\r\n    return EGLKHRFenceSync.eglClientWaitSyncKHR(dpy, sync, flags, timeout);\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.interpolate",
	"Comment": "linear interpolation between the previous and current physics state based on the amount oftimestep remaining after processing the rendering delta time in timestep sized chunks.",
	"Method": "void interpolate(double alpha){\r\n    mCurrentState.position = mCurrentState.position * alpha + mPreviousState.position * (1 - alpha);\r\n    mCurrentState.velocity = mCurrentState.velocity * alpha + mPreviousState.velocity * (1 - alpha);\r\n}"
}, {
	"Path": "com.openhtmltopdf.simple.extend.XhtmlCssOnlyNamespaceHandler.getLinkUri",
	"Comment": "gets the linkuri attribute of the xhtmlnamespacehandler object",
	"Method": "String getLinkUri(org.w3c.dom.Element e){\r\n    String href = null;\r\n    if (e.getNodeName().equalsIgnoreCase(\"a\") && e.hasAttribute(\"href\")) {\r\n        href = e.getAttribute(\"href\");\r\n    }\r\n    return href;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.objects.Circle.init",
	"Comment": "initializes the circle data type with map modifiers, images, and dimensions.",
	"Method": "void init(GameContainer container,float circleDiameter){\r\n    diameter = circleDiameter * HitObject.getXMultiplier();\r\n    int diameterInt = (int) diameter;\r\n    GameImage.HITCIRCLE.setImage(GameImage.HITCIRCLE.getImage().getScaledCopy(diameterInt, diameterInt));\r\n    GameImage.HITCIRCLE_OVERLAY.setImage(GameImage.HITCIRCLE_OVERLAY.getImage().getScaledCopy(diameterInt, diameterInt));\r\n    GameImage.APPROACHCIRCLE.setImage(GameImage.APPROACHCIRCLE.getImage().getScaledCopy(diameterInt, diameterInt));\r\n}"
}, {
	"Path": "ddf.minim.MultiChannelBuffer.set",
	"Comment": "copy the data in the provided multichannelbuffer to this multichannelbuffer.\tdoing so will change both the buffer size and channel count of this\tmultichannelbuffer to be the same as the copied buffer.",
	"Method": "void set(MultiChannelBuffer otherBuffer){\r\n    bufferSize = otherBuffer.bufferSize;\r\n    channels = otherBuffer.channels.clone();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ScoreData.getTimeSince",
	"Comment": "returns the time since achieving the score, or null if over 24 hours.\tthis value will not change after the first call.",
	"Method": "String getTimeSince(){\r\n    if (timeSince == null) {\r\n        long seconds = (System.currentTimeMillis() / 1000L) - timestamp;\r\n        if (seconds < 60)\r\n            timeSince = String.format(\"%ds\", seconds);\r\n        else if (seconds < 3600)\r\n            timeSince = String.format(\"%dm\", seconds / 60L);\r\n        else if (seconds < 86400)\r\n            timeSince = String.format(\"%dh\", seconds / 3600L);\r\n        else\r\n            timeSince = \"\";\r\n    }\r\n    return (timeSince.isEmpty()) ? null : timeSince;\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.value.FSCssValue.toString",
	"Comment": "returns the string representation of the instance, in this case, the csstext value.",
	"Method": "String toString(){\r\n    return getCssText();\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.getPaddingBottom",
	"Comment": "returns the padding below a glyph on the glyphpage to allow for effects to be drawn.",
	"Method": "int getPaddingBottom(){\r\n    return paddingBottom;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doContent",
	"Comment": "replaces the selection with the character or insert the character at the current caret position if no selection exists.if a carriage return was typed replace it with the line break character used by the widget on this platform.",
	"Method": "void doContent(char key){\r\n    if (blockSelection && blockXLocation != -1) {\r\n        insertBlockSelectionText(key, SWT.NULL);\r\n        return;\r\n    }\r\n    Event event = new Event();\r\n    event.start = selection.x;\r\n    event.end = selection.y;\r\n    if (key == SWT.CR || key == SWT.LF) {\r\n        if (!isSingleLine()) {\r\n            event.text = getLineDelimiter();\r\n        }\r\n    } else if (selection.x == selection.y && overwrite && key != TAB) {\r\n        int lineIndex = content.getLineAtOffset(event.end);\r\n        int lineOffset = content.getOffsetAtLine(lineIndex);\r\n        String line = content.getLine(lineIndex);\r\n        if (event.end < lineOffset + line.length()) {\r\n            event.end++;\r\n        }\r\n        event.text = new String(new char[] { key });\r\n    } else {\r\n        event.text = new String(new char[] { key });\r\n    }\r\n    if (event.text != null) {\r\n        if (textLimit > 0 && content.getCharCount() - (event.end - event.start) >= textLimit) {\r\n            return;\r\n        }\r\n        sendKeyEvent(event);\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.simple.extend.XhtmlCssOnlyNamespaceHandler.getNamespace",
	"Comment": "gets the namespace attribute of the xhtmlnamespacehandler object",
	"Method": "String getNamespace(){\r\n    return _namespace;\r\n}"
}, {
	"Path": "com.j256.ormlite.stmt.StatementBuilder.appendWhereStatement",
	"Comment": "append the where part of the statement to the stringbuilder.",
	"Method": "boolean appendWhereStatement(StringBuilder sb,List<ArgumentHolder> argList,WhereOperation operation){\r\n    if (where == null) {\r\n        return operation == WhereOperation.FIRST;\r\n    }\r\n    operation.appendBefore(sb);\r\n    where.appendSql((addTableName ? getTableName() : null), sb, argList);\r\n    operation.appendAfter(sb);\r\n    return false;\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.getRestSpeedThreshold",
	"Comment": "returns the speed at which the spring should be considered at rest in pixels per second",
	"Method": "double getRestSpeedThreshold(){\r\n    return mRestSpeedThreshold;\r\n}"
}, {
	"Path": "com.openhtmltopdf.pdfboxout.PdfBoxFastOutputDevice.paintBackground",
	"Comment": "we use paintbackground to do extra stuff such as processing links, forms and form controls.",
	"Method": "void paintBackground(RenderingContext c,Box box){\r\n    super.paintBackground(c, box);\r\n    _linkManager.processLinkLater(c, box, _page, _pageHeight, _transform);\r\n    if (box.getElement() != null && box.getElement().getNodeName().equals(\"form\")) {\r\n        _formState.addFormIfRequired(box, this);\r\n    } else if (box.getElement() != null && ArrayUtil.isOneOf(box.getElement().getNodeName(), \"input\", \"textarea\", \"button\", \"select\", \"openhtmltopdf-combo\")) {\r\n        _formState.addControlIfRequired(box, _page, _transform, c, _pageHeight);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.objects.Slider.drawExperimentalSliderTrack",
	"Comment": "draws the slider track for the experimental style sliders.",
	"Method": "boolean drawExperimentalSliderTrack(int trackPosition,double snakingSliderProgress,float sliderAlpha){\r\n    double curveIntervalTo = Options.isSliderSnaking() ? snakingSliderProgress : 1d;\r\n    double curveIntervalFrom = 0d;\r\n    if (Options.isExperimentalSliderShrinking()) {\r\n        double sliderProgress = (trackPosition - hitObject.getTime() - ((double) sliderTime * (hitObject.getRepeatCount() - 1))) / sliderTime;\r\n        if (sliderProgress > 0)\r\n            curveIntervalFrom = sliderProgress;\r\n    }\r\n    int curveLength = curve.getCurvePoints().length;\r\n    if (Options.isExperimentalSliderMerging() && game.getPlayState() != Game.PlayState.LOSE) {\r\n        if (Options.isExperimentalSliderShrinking() && curveIntervalFrom > 0) {\r\n            if (hitObject.getRepeatCount() % 2 == 0) {\r\n                game.addMergedSliderPointsToRender(baseSliderFrom, baseSliderFrom + (int) ((1d - curveIntervalFrom) * curveLength));\r\n            } else {\r\n                game.addMergedSliderPointsToRender(baseSliderFrom + (int) (curveIntervalFrom * curveLength) + 1, baseSliderFrom + (int) (curveIntervalTo * curve.getCurvePoints().length));\r\n            }\r\n        } else {\r\n            game.addMergedSliderPointsToRender(baseSliderFrom, baseSliderFrom + (int) (curveIntervalTo * curve.getCurvePoints().length));\r\n        }\r\n    } else {\r\n        if (Options.isExperimentalSliderShrinking() && curveIntervalFrom > 0 && hitObject.getRepeatCount() % 2 == 0) {\r\n            curve.splice((int) ((1d - curveIntervalFrom) * curveLength), curveLength);\r\n            curveIntervalFrom = 0d;\r\n        }\r\n        float oldBlackAlpha = Colors.BLACK_ALPHA.a;\r\n        Colors.BLACK_ALPHA.a = sliderAlpha;\r\n        curve.draw(Colors.BLACK_ALPHA, (int) (curveIntervalFrom * curveLength), (int) (curveIntervalTo * curveLength));\r\n        Colors.BLACK_ALPHA.a = oldBlackAlpha;\r\n    }\r\n    return curveIntervalTo == 1d;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doContentEnd",
	"Comment": "moves the caret after the last character of the widget content.",
	"Method": "void doContentEnd(){\r\n    if (isSingleLine()) {\r\n        doLineEnd();\r\n    } else {\r\n        int length = content.getCharCount();\r\n        setCaretOffset(length, SWT.DEFAULT);\r\n        showCaret();\r\n    }\r\n}"
}, {
	"Path": "ddf.minim.analysis.BeatDetect.isOnset",
	"Comment": "in frequency energy mode this returns true when a beat has been detect in\tthe ith frequency band. in sound energy mode\tthis always returns false.",
	"Method": "boolean isOnset(boolean isOnset,int i){\r\n    if (algorithm == SOUND_ENERGY) {\r\n        return false;\r\n    }\r\n    return fIsOnset[i];\r\n}"
}, {
	"Path": "com.j256.ormlite.dao.BaseForeignCollection.addAll",
	"Comment": "add the collection of elements to this collection. this will also them to the associated database table.",
	"Method": "boolean addAll(Collection<? extends T> collection){\r\n    boolean changed = false;\r\n    for (T data : collection) {\r\n        try {\r\n            if (addElement(data)) {\r\n                changed = true;\r\n            }\r\n        } catch (SQLException e) {\r\n            throw new IllegalStateException(\"Could not create data elements in dao\", e);\r\n        }\r\n    }\r\n    return changed;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.replay.ReplayImporter.importAllReplaysFromDir",
	"Comment": "invokes the importer for each osr file in a directory, adding the replay\tto the score database and moving the file into the replay directory.",
	"Method": "void importAllReplaysFromDir(File dir){\r\n    files = dir.listFiles(new FilenameFilter() {\r\n        @Override\r\n        public boolean accept(File dir, String name) {\r\n            return name.toLowerCase().endsWith(\".osr\");\r\n        }\r\n    });\r\n    if (files == null || files.length < 1) {\r\n        files = null;\r\n        return;\r\n    }\r\n    File replayDir = Options.getReplayDir();\r\n    if (!replayDir.isDirectory()) {\r\n        if (!replayDir.mkdir()) {\r\n            ErrorHandler.error(String.format(\"Failed to create replay directory '%s'.\", replayDir.getAbsolutePath()), null, false);\r\n            return;\r\n        }\r\n    }\r\n    int importCount = 0;\r\n    for (File file : files) {\r\n        fileIndex++;\r\n        Replay r = new Replay(file);\r\n        try {\r\n            r.loadHeader();\r\n        } catch (IOException e) {\r\n            moveToFailedDirectory(file);\r\n            ErrorHandler.error(String.format(\"Failed to import replay '%s'. The replay file could not be parsed.\", file.getName()), e, false);\r\n            continue;\r\n        }\r\n        Beatmap beatmap = BeatmapSetList.get().getBeatmapFromHash(r.beatmapHash);\r\n        if (beatmap != null) {\r\n            ScoreDB.addScore(r.getScoreData(beatmap));\r\n            File moveToFile = new File(replayDir, String.format(\"%s.osr\", r.getReplayFilename()));\r\n            try {\r\n                Files.move(file.toPath(), moveToFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\r\n                importCount++;\r\n            } catch (IOException e) {\r\n                Log.warn(String.format(\"Failed to move replay '%s' to the replay directory '%s'.\", file, replayDir), e);\r\n            }\r\n        } else {\r\n            moveToFailedDirectory(file);\r\n            ErrorHandler.error(String.format(\"Failed to import replay '%s'. The associated beatmap could not be found.\", file.getName()), null, false);\r\n            continue;\r\n        }\r\n    }\r\n    fileIndex = -1;\r\n    files = null;\r\n    if (importCount > 0) {\r\n        String text = String.format(\"Imported %d replay%s.\", importCount, importCount == 1 ? \"\" : \"s\");\r\n        UI.getNotificationManager().sendNotification(text);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.replay.ReplayImporter.importAllReplaysFromDir",
	"Comment": "invokes the importer for each osr file in a directory, adding the replay\tto the score database and moving the file into the replay directory.",
	"Method": "void importAllReplaysFromDir(File dir){\r\n    return name.toLowerCase().endsWith(\".osr\");\r\n}"
}, {
	"Path": "com.openhtmltopdf.java2d.Java2DFontResolver.getFontInstanceHashName",
	"Comment": "gets the hash key for a concrete instance of a font.this incorporates size, weight, etc.",
	"Method": "String getFontInstanceHashName(SharedContext ctx,String name,float size,IdentValue weight,IdentValue style,IdentValue variant){\r\n    return name + \"-\" + (size * ctx.getTextRenderer().getFontScale()) + \"-\" + weight + \"-\" + style + \"-\" + variant;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.GLContext.unloadOpenGLLibrary",
	"Comment": "the opengl library reference count is decremented, and if it reaches 0, the library is unloaded.",
	"Method": "void unloadOpenGLLibrary(){\r\n    gl_ref_count--;\r\n    if (gl_ref_count == 0 && LWJGLUtil.getPlatform() != LWJGLUtil.PLATFORM_LINUX)\r\n        nUnloadOpenGLLibrary();\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.setSelectionRange",
	"Comment": "sets the selection.the new selection may not be visible. call showselection to scroll the selectioninto view. a negative length places the caret at the visual start of the selection.",
	"Method": "void setSelectionRange(int start,int length){\r\n    checkWidget();\r\n    int contentLength = getCharCount();\r\n    start = Math.max(0, Math.min(start, contentLength));\r\n    int end = start + length;\r\n    if (end < 0) {\r\n        length = -start;\r\n    } else {\r\n        if (end > contentLength)\r\n            length = contentLength - start;\r\n    }\r\n    if (isLineDelimiter(start) || isLineDelimiter(start + length)) {\r\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\r\n    }\r\n    setSelection(start, length, false, true);\r\n    setCaretLocation();\r\n}"
}, {
	"Path": "com.openhtmltopdf.nonvisualregressiontests.NonVisualRegressionTest.testLinkTransformTarget",
	"Comment": "tests that a simple block link successfully links to an element that is transformed to top of third page.",
	"Method": "void testLinkTransformTarget(){\r\n    PDDocument doc = run(\"link-transform-target\");\r\n    assertEquals(1, doc.getPage(0).getAnnotations().size());\r\n    assertThat(doc.getPage(0).getAnnotations().get(0), instanceOf(PDAnnotationLink.class));\r\n    PDAnnotationLink link = (PDAnnotationLink) doc.getPage(0).getAnnotations().get(0);\r\n    assertThat(link.getRectangle(), rectEquals(new PDRectangle(0f, 0f, 100f, 10f), 100d));\r\n    assertThat(link.getAction(), instanceOf(PDActionGoTo.class));\r\n    PDActionGoTo action = (PDActionGoTo) link.getAction();\r\n    assertThat(action.getDestination(), instanceOf(PDPageXYZDestination.class));\r\n    PDPageXYZDestination dest = (PDPageXYZDestination) action.getDestination();\r\n    assertEquals(doc.getPage(2), dest.getPage());\r\n    assertEquals(cssPixelYToPdfPoints(0, 100), dest.getTop(), 1.0d);\r\n    remove(\"link-transform-target\", doc);\r\n}"
}, {
	"Path": "org.lwjgl.opengl.ContextGL.destroy",
	"Comment": "request destruction of the context. if the context is current, no context will be current after this call.\tthe context is destroyed when no thread has it current.",
	"Method": "void destroy(){\r\n    if (destroyed)\r\n        return;\r\n    destroy_requested = true;\r\n    boolean was_current = isCurrent();\r\n    int error = GL_NO_ERROR;\r\n    if (was_current) {\r\n        try {\r\n            error = glGetError();\r\n        } catch (Exception e) {\r\n        }\r\n        releaseCurrent();\r\n    }\r\n    checkDestroy();\r\n    if (was_current && error != GL_NO_ERROR)\r\n        throw new OpenGLException(error);\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.Configuration.loadDefaultProperties",
	"Comment": "loads the default set of properties, which may be overridden.",
	"Method": "void loadDefaultProperties(){\r\n    try {\r\n        InputStream readStream = GeneralUtil.openStreamFromClasspath(new DefaultCSSMarker(), SF_FILE_NAME);\r\n        if (readStream == null) {\r\n            System.err.println(\"WARNING: Flying Saucer: No configuration files found in classpath using URL: \" + SF_FILE_NAME + \", resorting to hard-coded fallback properties.\");\r\n            this.properties = newFallbackProperties();\r\n        } else {\r\n            try {\r\n                this.properties = new Properties();\r\n                this.properties.load(readStream);\r\n            } finally {\r\n                readStream.close();\r\n            }\r\n        }\r\n    } catch (RuntimeException rex) {\r\n        throw rex;\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(\"Could not load properties file for configuration.\", ex);\r\n    }\r\n    info(\"Configuration loaded from \" + SF_FILE_NAME);\r\n}"
}, {
	"Path": "org.lwjgl.opencl.CLProgram.registerCLKernels",
	"Comment": "called from clcreatekernelsinprogram to register new clkernels.",
	"Method": "void registerCLKernels(PointerBuffer kernels){\r\n    for (int i = kernels.position(); i < kernels.limit(); i++) {\r\n        final long pointer = kernels.get(i);\r\n        if (pointer != 0)\r\n            new CLKernel(pointer, this);\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.openal.ALC10.alcCreateContext",
	"Comment": "a context is created using alccreatecontext. the device parameter has to be a valid\t device. the attribute list can be null, or a zero terminated list of integer pairs\t composed of valid alc attribute tokens and requested values.\t context creation will fail if the application requests attributes that, by themselves,\t can not be provided. context creation will fail if the combination of specified\t attributes can not be provided. context creation will fail if a specified attribute, or\t the combination of attributes, does not match the default values for unspecified\t attributes.",
	"Method": "ALCcontext alcCreateContext(ALCdevice device,IntBuffer attrList){\r\n    long context_address = nalcCreateContext(getDevice(device), MemoryUtil.getAddressSafe(attrList));\r\n    Util.checkALCError(device);\r\n    if (context_address != 0) {\r\n        ALCcontext context = new ALCcontext(context_address);\r\n        synchronized (ALC10.contexts) {\r\n            contexts.put(context_address, context);\r\n            device.addContext(context);\r\n        }\r\n        return context;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getLineCountWhole",
	"Comment": "returns the number of lines that can be completely displayed in the widget client area.",
	"Method": "int getLineCountWhole(){\r\n    if (isFixedLineHeight()) {\r\n        int lineHeight = renderer.getLineHeight();\r\n        return lineHeight != 0 ? clientAreaHeight / lineHeight : 1;\r\n    }\r\n    return getBottomIndex() - topIndex + 1;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGLKHRFenceSync.eglCreateSyncKHR",
	"Comment": "creates a fence sync object for the specified egl display and returns\ta handle to the new object.",
	"Method": "EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy,int type,IntBuffer attrib_list){\r\n    checkAttribList(attrib_list);\r\n    final long pointer = neglCreateSyncKHR(dpy.getPointer(), type, MemoryUtil.getAddressSafe(attrib_list));\r\n    if (pointer == EGL_NO_SYNC_KHR)\r\n        throwEGLError(\"Failed to create KHR fence sync object.\");\r\n    return new EGLSyncKHR(pointer);\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testTransformStaticPageMargin",
	"Comment": "with a static block, rotate, large page margin, no block margin or padding.",
	"Method": "void testTransformStaticPageMargin(){\r\n    assertTrue(vt.runTest(\"transform-static-page-margin\"));\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.setZoomEnabled",
	"Comment": "enable or disable zoom gesture detection. disabling zoom locks the the current scale.",
	"Method": "void setZoomEnabled(boolean zoomEnabled){\r\n    this.zoomEnabled = zoomEnabled;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGL.eglQueryContext",
	"Comment": "returns the value of the specified egl context attribute in the value parameter.",
	"Method": "void eglQueryContext(EGLDisplay dpy,EGLContext ctx,int attribute,IntBuffer value){\r\n    BufferChecks.checkBuffer(value, 1);\r\n    if (!neglQueryContext(dpy.getPointer(), ctx.getPointer(), attribute, MemoryUtil.getAddress(value)))\r\n        throwEGLError(\"Failed to query context attribute.\");\r\n}"
}, {
	"Path": "io.opencensus.trace.Tracing.loadTraceComponent",
	"Comment": "any provider that may be used for tracecomponent can be added here.",
	"Method": "TraceComponent loadTraceComponent(ClassLoader classLoader){\r\n    try {\r\n        return Provider.createInstance(Class.forName(\"io.opencensus.impl.trace.TraceComponentImpl\", true, classLoader), TraceComponent.class);\r\n    } catch (ClassNotFoundException e) {\r\n        logger.log(Level.FINE, \"Couldn't load full implementation for TraceComponent, now trying to load lite \" + \"implementation.\", e);\r\n    }\r\n    try {\r\n        return Provider.createInstance(Class.forName(\"io.opencensus.impllite.trace.TraceComponentImplLite\", true, classLoader), TraceComponent.class);\r\n    } catch (ClassNotFoundException e) {\r\n        logger.log(Level.FINE, \"Couldn't load lite implementation for TraceComponent, now using \" + \"default implementation for TraceComponent.\", e);\r\n    }\r\n    return TraceComponent.newNoopTraceComponent();\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.setPaddingAdvanceX",
	"Comment": "sets the additional amount to offset glyphs on the x axis. this is typically set to a negative number when left or right\tpadding is used so that glyphs are not spaced too far apart.",
	"Method": "void setPaddingAdvanceX(int paddingAdvanceX){\r\n    this.paddingAdvanceX = paddingAdvanceX;\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.setPaddingRight",
	"Comment": "sets the padding to the right of a glyph on the glyphpage to allow for effects to be drawn.",
	"Method": "void setPaddingRight(int paddingRight){\r\n    this.paddingRight = paddingRight;\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.setPaddingAdvanceY",
	"Comment": "sets the additional amount to offset a line of text on the y axis. this is typically set to a negative number when top or\tbottom padding is used so that lines of text are not spaced too far apart.",
	"Method": "void setPaddingAdvanceY(int paddingAdvanceY){\r\n    this.paddingAdvanceY = paddingAdvanceY;\r\n}"
}, {
	"Path": "orestes.bloomfilter.json.BloomFilterConverter.toBase64",
	"Comment": "converts a normal or counting bloom filter to a base64 encoded string containing its bits.",
	"Method": "String toBase64(BloomFilter<?> source,String toBase64,byte[] bits){\r\n    return new String(Base64.getEncoder().encode(bits), StandardCharsets.UTF_8);\r\n}"
}, {
	"Path": "org.newdawn.slick.Input.clearControlPressedRecord",
	"Comment": "clear the state for iscontrolpressed method. this will reset all\tcontrols to not pressed",
	"Method": "void clearControlPressedRecord(){\r\n    for (int i = 0; i < controllers.size(); i++) {\r\n        Arrays.fill(controllerPressed[i], false);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.skins.Skin.getSongSelectInactiveTextColor",
	"Comment": "returns the color of the inactive text in the song selection menu.",
	"Method": "Color getSongSelectInactiveTextColor(){\r\n    return songSelectInactiveText;\r\n}"
}, {
	"Path": "com.j256.ormlite.misc.TransactionManager.initialize",
	"Comment": "if you are using the spring type wiring, this should be called after all of the set methods.",
	"Method": "void initialize(){\r\n    if (connectionSource == null) {\r\n        throw new IllegalStateException(\"dataSource was not set on \" + getClass().getSimpleName());\r\n    }\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.setTileBackgroundColor",
	"Comment": "set a solid color to render behind tiles, useful for displaying transparent pngs.",
	"Method": "void setTileBackgroundColor(int tileBgColor){\r\n    if (Color.alpha(tileBgColor) == 0) {\r\n        tileBgPaint = null;\r\n    } else {\r\n        tileBgPaint = new Paint();\r\n        tileBgPaint.setStyle(Style.FILL);\r\n        tileBgPaint.setColor(tileBgColor);\r\n    }\r\n    invalidate();\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doCursorNext",
	"Comment": "moves the caret to the end of the selection if a selection exists.otherwise, if no selection exists move the cursor according to the cursor selection rules.",
	"Method": "void doCursorNext(){\r\n    if (selection.y - selection.x > 0) {\r\n        setCaretOffset(selection.y, PREVIOUS_OFFSET_TRAILING);\r\n        showCaret();\r\n    } else {\r\n        doSelectionCursorNext();\r\n    }\r\n}"
}, {
	"Path": "com.android.volley.Response.success",
	"Comment": "returns a successful response containing the parsed result.",
	"Method": "Response<T> success(T result,Cache.Entry cacheEntry){\r\n    return new Response<T>(result, cacheEntry);\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.Configuration.valueAsLong",
	"Comment": "returns the value for key in the configurationas a long, or the defaultprovided value if not found or if the value is not a valid long. awarning is issued to the log if the property is not defined, or if theconversion from string fails.",
	"Method": "long valueAsLong(String key,long defaultVal){\r\n    String val = valueFor(key);\r\n    if (val == null) {\r\n        return defaultVal;\r\n    }\r\n    long lval;\r\n    try {\r\n        lval = Long.valueOf(val).longValue();\r\n    } catch (NumberFormatException nex) {\r\n        XRLog.exception(\"Property '\" + key + \"' was requested as a long, but \" + \"value of '\" + val + \"' is not a long. Check configuration.\");\r\n        lval = defaultVal;\r\n    }\r\n    return lval;\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.getFontFile",
	"Comment": "returns the path to the ttf file for this unicodefont, or null. if this unicodefont was created without specifying the ttf\tfile, it will try to determine the path using sun classes. if this fails, null is returned.",
	"Method": "String getFontFile(){\r\n    if (ttfFileRef == null) {\r\n        try {\r\n            Object font2D = Class.forName(\"sun.font.FontManager\").getDeclaredMethod(\"getFont2D\", new Class[] { Font.class }).invoke(null, new Object[] { font });\r\n            Field platNameField = Class.forName(\"sun.font.PhysicalFont\").getDeclaredField(\"platName\");\r\n            platNameField.setAccessible(true);\r\n            ttfFileRef = (String) platNameField.get(font2D);\r\n        } catch (Throwable ignored) {\r\n        }\r\n        if (ttfFileRef == null)\r\n            ttfFileRef = \"\";\r\n    }\r\n    if (ttfFileRef.length() == 0)\r\n        return null;\r\n    return ttfFileRef;\r\n}"
}, {
	"Path": "com.openhtmltopdf.DOMBuilder.jsoup2DOM",
	"Comment": "returns a w3c dom that exposes the same content as the supplied jsoupdocument into a w3c dom.",
	"Method": "Document jsoup2DOM(org.jsoup.nodes.Document jsoupDocument){\r\n    Document document = null;\r\n    try {\r\n        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\r\n        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\r\n        document = docBuilder.newDocument();\r\n        Map<String, String> nsMap = new HashMap<String, String>();\r\n        createDOM(jsoupDocument, document, document, nsMap);\r\n    } catch (ParserConfigurationException pce) {\r\n        throw new RuntimeException(pce);\r\n    }\r\n    return document;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getContent",
	"Comment": "returns the content implementation that is used for text storage.",
	"Method": "StyledTextContent getContent(){\r\n    checkWidget();\r\n    return content;\r\n}"
}, {
	"Path": "com.openhtmltopdf.pdfboxout.PdfBoxRenderer.setDidValues",
	"Comment": "sets the document information dictionary values from html metadata",
	"Method": "void setDidValues(PDDocument doc){\r\n    PDDocumentInformation info = new PDDocumentInformation();\r\n    info.setCreationDate(Calendar.getInstance());\r\n    if (_producer == null) {\r\n        info.setProducer(\"openhtmltopdf.com\");\r\n    } else {\r\n        info.setProducer(_producer);\r\n    }\r\n    for (Metadata metadata : _outputDevice.getMetadata()) {\r\n        String name = metadata.getName();\r\n        if (name.isEmpty())\r\n            continue;\r\n        String content = metadata.getContent();\r\n        if (content == null)\r\n            continue;\r\n        if (name.equals(\"title\"))\r\n            info.setTitle(content);\r\n        else if (name.equals(\"author\"))\r\n            info.setAuthor(content);\r\n        else if (name.equals(\"subject\"))\r\n            info.setSubject(content);\r\n        else if (name.equals(\"keywords\"))\r\n            info.setKeywords(content);\r\n        else\r\n            info.setCustomMetadataValue(name, content);\r\n    }\r\n    doc.setDocumentInformation(info);\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGLConfig.getDisplay",
	"Comment": "returns the egl display from which this egl config was retrieved.",
	"Method": "EGLDisplay getDisplay(){\r\n    return display;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.MacOSXCanvasImplementation.findConfiguration",
	"Comment": "find a proper graphicsconfiguration from the given graphicsdevice and pixelformat.",
	"Method": "GraphicsConfiguration findConfiguration(GraphicsDevice device,PixelFormat pixel_format){\r\n    return null;\r\n}"
}, {
	"Path": "me.imid.swipebacklayout.lib.ViewDragHelper.setMinVelocity",
	"Comment": "set the minimum velocity that will be detected as having a magnitudegreater than zero in pixels per second. callback methods accepting avelocity will be clamped appropriately.",
	"Method": "void setMinVelocity(float minVel){\r\n    mMinVelocity = minVel;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.addPaintObjectListener",
	"Comment": "adds a paint object listener. a paint object event is sent by the widget when an objectneeds to be drawn.",
	"Method": "void addPaintObjectListener(PaintObjectListener listener){\r\n    checkWidget();\r\n    if (listener == null)\r\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\r\n    addListener(ST.PaintObject, new StyledTextListener(listener));\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.OptionsOverlay.hasSearchResults",
	"Comment": "checks if the specified search filter matches one or more options.",
	"Method": "boolean hasSearchResults(String searchText){\r\n    for (OptionGroup group : groups) {\r\n        if (group.getName().toLowerCase().contains(searchText))\r\n            return true;\r\n        if (group.getOptions() == null)\r\n            continue;\r\n        for (GameOption option : group.getOptions()) {\r\n            if (option.matches(searchText))\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.android.volley.CacheDispatcher.quit",
	"Comment": "forces this dispatcher to quit immediately.if any requests are still inthe queue, they are not guaranteed to be processed.",
	"Method": "void quit(){\r\n    mQuit = true;\r\n    interrupt();\r\n}"
}, {
	"Path": "org.lwjgl.util.mapped.MappedObjectTransformer.transformMappedObject",
	"Comment": "removes final from methods that will be overriden by subclasses.",
	"Method": "byte[] transformMappedObject(byte[] bytecode){\r\n    final ClassWriter cw = new ClassWriter(0);\r\n    ClassVisitor cv = new ClassAdapter(cw) {\r\n        private final String[] DEFINALIZE_LIST = { VIEWADDRESS_METHOD_NAME, NEXT_METHOD_NAME, ALIGN_METHOD_NAME, SIZEOF_METHOD_NAME, CAPACITY_METHOD_NAME };\r\n        public MethodVisitor visitMethod(int access, final String name, final String desc, final String signature, final String[] exceptions) {\r\n            for (String method : DEFINALIZE_LIST) {\r\n                if (name.equals(method)) {\r\n                    access &= ~ACC_FINAL;\r\n                    break;\r\n                }\r\n            }\r\n            return super.visitMethod(access, name, desc, signature, exceptions);\r\n        }\r\n    };\r\n    new ClassReader(bytecode).accept(cv, 0);\r\n    return cw.toByteArray();\r\n}"
}, {
	"Path": "org.lwjgl.util.mapped.MappedObjectTransformer.transformMappedObject",
	"Comment": "removes final from methods that will be overriden by subclasses.",
	"Method": "byte[] transformMappedObject(byte[] bytecode){\r\n    for (String method : DEFINALIZE_LIST) {\r\n        if (name.equals(method)) {\r\n            access &= ~ACC_FINAL;\r\n            break;\r\n        }\r\n    }\r\n    return super.visitMethod(access, name, desc, signature, exceptions);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.render.CurveRenderState.renderCurve",
	"Comment": "do the actual drawing of the curve into the currently bound framebuffer.",
	"Method": "void renderCurve(Color color,Color borderColor,int to){\r\n    staticState.initGradient();\r\n    RenderState state = saveRenderState();\r\n    staticState.initShaderProgram();\r\n    GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, vboID);\r\n    GL20.glUseProgram(staticState.program);\r\n    GL20.glEnableVertexAttribArray(staticState.attribLoc);\r\n    GL20.glEnableVertexAttribArray(staticState.texCoordLoc);\r\n    GL20.glUniform1i(staticState.texLoc, 0);\r\n    GL20.glUniform4f(staticState.colLoc, color.r, color.g, color.b, color.a);\r\n    GL20.glUniform4f(staticState.colBorderLoc, borderColor.r, borderColor.g, borderColor.b, borderColor.a);\r\n    float lastSegmentX = to == 0 ? curve[1].x - curve[0].x : curve[to].x - curve[to - 1].x;\r\n    float lastSegmentY = to == 0 ? curve[1].y - curve[0].y : curve[to].y - curve[to - 1].y;\r\n    float lastSegmentInvLen = 1.f / (float) Math.hypot(lastSegmentX, lastSegmentY);\r\n    GL20.glUniform4f(staticState.endPointLoc, curve[to].x, curve[to].y, lastSegmentX * lastSegmentInvLen, lastSegmentY * lastSegmentInvLen);\r\n    GL20.glVertexAttribPointer(staticState.attribLoc, 4, GL11.GL_FLOAT, false, 6 * 4, 2 * 4);\r\n    GL20.glVertexAttribPointer(staticState.texCoordLoc, 2, GL11.GL_FLOAT, false, 6 * 4, 0);\r\n    GL11.glColorMask(false, false, false, false);\r\n    GL11.glDrawArrays(GL11.GL_TRIANGLES, 0, pointIndices[to]);\r\n    GL11.glColorMask(true, true, true, true);\r\n    GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);\r\n    GL11.glDepthFunc(GL11.GL_EQUAL);\r\n    GL11.glDrawArrays(GL11.GL_TRIANGLES, 0, pointIndices[to]);\r\n    GL11.glDepthFunc(GL11.GL_LESS);\r\n    GL11.glFlush();\r\n    GL20.glDisableVertexAttribArray(staticState.texCoordLoc);\r\n    GL20.glDisableVertexAttribArray(staticState.attribLoc);\r\n    restoreRenderState(state);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.skins.Skin.isSliderBallFlipped",
	"Comment": "returns whether the slider ball should be flipped horizontally during a reverse.",
	"Method": "boolean isSliderBallFlipped(){\r\n    return sliderBallFlip;\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.getPaddingLeft",
	"Comment": "returns the padding to the left of a glyph on the glyphpage to allow for effects to be drawn.",
	"Method": "int getPaddingLeft(){\r\n    return paddingLeft;\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.XRSimpleLogFormatter.format",
	"Comment": "format the given log record and return the formatted string.",
	"Method": "String format(LogRecord record){\r\n    Throwable th = record.getThrown();\r\n    String thName = \"\";\r\n    String thMessage = \"\";\r\n    String trace = null;\r\n    if (th != null) {\r\n        StringWriter sw = new StringWriter();\r\n        th.printStackTrace(new PrintWriter(sw));\r\n        trace = sw.toString();\r\n        thName = th.getClass().getName();\r\n        thMessage = th.getMessage();\r\n    }\r\n    String[] args = { String.valueOf(record.getMillis()), record.getLoggerName(), record.getLevel().toString(), record.getSourceClassName(), record.getSourceMethodName(), record.getMessage(), thName, thMessage, trace };\r\n    String log = null;\r\n    if (th == null) {\r\n        log = mformat.format(args);\r\n    } else {\r\n        log = exmformat.format(args);\r\n    }\r\n    return log;\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.getEndValue",
	"Comment": "get the rest value used for determining the displacement of the spring",
	"Method": "double getEndValue(){\r\n    return mEndValue;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getOffsetAtLocation",
	"Comment": "returns the offset of the character at the given location relative to the first character in the document.the return value reflects the character offset that the caret willbe placed at if a mouse click occurred at the specified location.if the x coordinate of the location is beyond the center of a characterthe returned offset will be behind the character.",
	"Method": "int getOffsetAtLocation(Point point){\r\n    checkWidget();\r\n    if (point == null) {\r\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\r\n    }\r\n    int[] trailing = new int[1];\r\n    int offset = getOffsetAtPoint(point.x, point.y, trailing, true);\r\n    if (offset == -1) {\r\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\r\n    }\r\n    return offset + trailing[0];\r\n}"
}, {
	"Path": "itdelatrisu.opsu.objects.curves.Curve.splice",
	"Comment": "splices a section of the curve for drawing, based on the given curve point indices.",
	"Method": "void splice(int from,int to){\r\n    if (legacyRenderState == null)\r\n        return;\r\n    legacyRenderState.splice(from, to);\r\n}"
}, {
	"Path": "io.opencensus.exporter.trace.instana.InstanaTraceExporter.createAndRegister",
	"Comment": "creates and registers the instana trace exporter to the opencensus library. only one instanaexporter can be registered at any point.",
	"Method": "void createAndRegister(String agentEndpoint){\r\n    synchronized (monitor) {\r\n        checkState(handler == null, \"Instana exporter is already registered.\");\r\n        Handler newHandler = new InstanaExporterHandler(new URL(agentEndpoint));\r\n        handler = newHandler;\r\n        register(Tracing.getExportComponent().getSpanExporter(), newHandler);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ui.MenuButton.removeHoverEffects",
	"Comment": "removes all hover effects that have been set for the button.",
	"Method": "void removeHoverEffects(){\r\n    this.hoverEffect = 0;\r\n    this.scale = null;\r\n    this.alpha = null;\r\n    this.angle = null;\r\n    autoAnimationForward = true;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getLineStyleData",
	"Comment": "returns the line style data for the given line or null if there is if there is a linestylelistener but it does not set any styles, the styledtextevent.styles field will be initialized to an empty array.",
	"Method": "StyledTextEvent getLineStyleData(int lineOffset,String line){\r\n    return sendLineEvent(ST.LineGetStyle, lineOffset, line);\r\n}"
}, {
	"Path": "orestes.bloomfilter.BloomFilter.remove",
	"Comment": "destroys the bloom filter by deleting its contents and metadata",
	"Method": "void remove(){\r\n    clear();\r\n}"
}, {
	"Path": "ddf.minim.effects.ChebFilter.setType",
	"Comment": "sets the type of the filter. either chebfilter.lp or chebfilter.hp",
	"Method": "void setType(int t){\r\n    if (t != LP && t != HP) {\r\n        Minim.error(\"Invalid filter type, defaulting to low pass.\");\r\n        t = LP;\r\n    }\r\n    if (type != t) {\r\n        type = t;\r\n        calcCoeff();\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.Options.getBeatmapDir",
	"Comment": "returns the beatmap directory.\tif invalid, this will attempt to search for the directory,\tand if nothing found, will create one.",
	"Method": "File getBeatmapDir(){\r\n    if (beatmapDir != null && beatmapDir.isDirectory())\r\n        return beatmapDir;\r\n    File osuDir = getOsuInstallationDirectory();\r\n    if (osuDir != null) {\r\n        beatmapDir = new File(osuDir, BEATMAP_DIR.getName());\r\n        if (beatmapDir.isDirectory())\r\n            return beatmapDir;\r\n    }\r\n    beatmapDir = BEATMAP_DIR;\r\n    if (!beatmapDir.isDirectory() && !beatmapDir.mkdir())\r\n        ErrorHandler.error(String.format(\"Failed to create beatmap directory at '%s'.\", beatmapDir.getAbsolutePath()), null, false);\r\n    return beatmapDir;\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.sheet.Ruleset.getPropertyDeclarations",
	"Comment": "returns an iterator of propertydeclarations pulled from thiscssstylerule.",
	"Method": "List<PropertyDeclaration> getPropertyDeclarations(){\r\n    return Collections.unmodifiableList(_props);\r\n}"
}, {
	"Path": "com.openhtmltopdf.swing.ImageLoadQueue.kill",
	"Comment": "indicates that no more items will be added to the queue, no more items currently in the queue will be loaded,and that worker threads polling this queue should shut down.",
	"Method": "void kill(){\r\n    _loadQueue.addLast(KILL_SWITCH);\r\n    notifyAll();\r\n}"
}, {
	"Path": "com.openhtmltopdf.context.StylesheetFactoryImpl.putStylesheet",
	"Comment": "adds a stylesheet to the factory cache. will overwrite older entry forsame key.",
	"Method": "void putStylesheet(String key,Stylesheet sheet){\r\n    _cache.put(key, sheet);\r\n}"
}, {
	"Path": "com.android.volley.Request.deliverError",
	"Comment": "delivers error message to the errorlistener that the request wasinitialized with.",
	"Method": "void deliverError(VolleyError error){\r\n    if (mErrorListener != null) {\r\n        mErrorListener.onErrorResponse(error);\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.PointerBuffer.hasRemaining",
	"Comment": "tells whether there are any elements between the current position and\tthe limit.",
	"Method": "boolean hasRemaining(){\r\n    return view.hasRemaining();\r\n}"
}, {
	"Path": "uk.co.senab.photoview.DefaultOnDoubleTapListener.setPhotoViewAttacher",
	"Comment": "allows to change photoviewattacher within range of single instance",
	"Method": "void setPhotoViewAttacher(PhotoViewAttacher newPhotoViewAttacher){\r\n    this.photoViewAttacher = newPhotoViewAttacher;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.db.BeatmapDB.updateDatabase",
	"Comment": "applies any database updates by comparing the current version to the\tstored version.does nothing if tables have not been created.",
	"Method": "void updateDatabase(){\r\n    try (Statement stmt = connection.createStatement()) {\r\n        int version = 0;\r\n        String sql = \"SELECT name FROM sqlite_master WHERE type = 'table' AND name = 'info'\";\r\n        ResultSet rs = stmt.executeQuery(sql);\r\n        boolean infoExists = rs.isBeforeFirst();\r\n        rs.close();\r\n        if (!infoExists) {\r\n            sql = \"SELECT name FROM sqlite_master WHERE type = 'table' AND name = 'beatmaps'\";\r\n            ResultSet beatmapsRS = stmt.executeQuery(sql);\r\n            boolean beatmapsExists = beatmapsRS.isBeforeFirst();\r\n            beatmapsRS.close();\r\n            if (!beatmapsExists)\r\n                return;\r\n        } else {\r\n            sql = \"SELECT value FROM info WHERE key = 'version'\";\r\n            ResultSet versionRS = stmt.executeQuery(sql);\r\n            String versionString = (versionRS.next()) ? versionRS.getString(1) : \"0\";\r\n            versionRS.close();\r\n            try {\r\n                version = Integer.parseInt(versionString);\r\n            } catch (NumberFormatException e) {\r\n            }\r\n        }\r\n        if (version >= DATABASE_VERSION)\r\n            return;\r\n        for (String query : getUpdateQueries(version)) stmt.executeUpdate(query);\r\n        if (infoExists) {\r\n            PreparedStatement ps = connection.prepareStatement(\"REPLACE INTO info (key, value) VALUES ('version', ?)\");\r\n            ps.setString(1, Integer.toString(DATABASE_VERSION));\r\n            ps.executeUpdate();\r\n            ps.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.opencensus.contrib.agent.instrumentation.ExecutorInstrumentationBenchmark.manual",
	"Comment": "this benchmark attempts to measure the performance with manual context propagation.",
	"Method": "void manual(Blackhole blackhole){\r\n    MoreExecutors.directExecutor().execute(Context.current().wrap(new MyRunnable(blackhole)));\r\n}"
}, {
	"Path": "org.lwjgl.test.applet.GearsApplet.init",
	"Comment": "initialise applet by adding a canvas to it, this canvas will start the lwjgl display and game loop\tin another thread. it will also stop the game loop and destroy the display on canvas removal when\tapplet is destroyed.",
	"Method": "void init(){\r\n    setLayout(new BorderLayout());\r\n    try {\r\n        display_parent = new Canvas() {\r\n            public void addNotify() {\r\n                super.addNotify();\r\n                startLWJGL();\r\n            }\r\n            public void removeNotify() {\r\n                stopLWJGL();\r\n                super.removeNotify();\r\n            }\r\n        };\r\n        display_parent.setSize(getWidth(), getHeight());\r\n        add(display_parent);\r\n        display_parent.setFocusable(true);\r\n        display_parent.requestFocus();\r\n        display_parent.setIgnoreRepaint(true);\r\n        setVisible(true);\r\n    } catch (Exception e) {\r\n        System.err.println(e);\r\n        throw new RuntimeException(\"Unable to create display\");\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.test.applet.GearsApplet.init",
	"Comment": "initialise applet by adding a canvas to it, this canvas will start the lwjgl display and game loop\tin another thread. it will also stop the game loop and destroy the display on canvas removal when\tapplet is destroyed.",
	"Method": "void init(){\r\n    super.addNotify();\r\n    startLWJGL();\r\n}"
}, {
	"Path": "org.lwjgl.test.applet.GearsApplet.init",
	"Comment": "initialise applet by adding a canvas to it, this canvas will start the lwjgl display and game loop\tin another thread. it will also stop the game loop and destroy the display on canvas removal when\tapplet is destroyed.",
	"Method": "void init(){\r\n    stopLWJGL();\r\n    super.removeNotify();\r\n}"
}, {
	"Path": "org.newdawn.slick.GameContainer.setSmoothDeltas",
	"Comment": "indicate if we want to smooth deltas. this feature will report\ta delta based on the fps not the time passed. this works well with \tvsync.",
	"Method": "void setSmoothDeltas(boolean smoothDeltas){\r\n    this.smoothDeltas = smoothDeltas;\r\n}"
}, {
	"Path": "org.lwjgl.input.Keyboard.areRepeatEventsEnabled",
	"Comment": "check whether repeat events are currently reported or not.",
	"Method": "boolean areRepeatEventsEnabled(){\r\n    synchronized (OpenGLPackageAccess.global_lock) {\r\n        return repeat_enabled;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.addModifyListener",
	"Comment": "adds a modify listener. a modify event is sent by the widget when the widget text has changed.",
	"Method": "void addModifyListener(ModifyListener modifyListener){\r\n    checkWidget();\r\n    if (modifyListener == null)\r\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\r\n    addListener(SWT.Modify, new TypedListener(modifyListener));\r\n}"
}, {
	"Path": "io.opencensus.exporter.stats.signalfx.SignalFxSessionAdaptor.adapt",
	"Comment": "converts the given metric into datapoints that can be sent to signalfx.",
	"Method": "List<DataPoint> adapt(Metric metric){\r\n    MetricDescriptor metricDescriptor = metric.getMetricDescriptor();\r\n    MetricType metricType = getType(metricDescriptor.getType());\r\n    if (metricType == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    DataPoint.Builder shared = DataPoint.newBuilder();\r\n    shared.setMetric(metricDescriptor.getName());\r\n    shared.setMetricType(metricType);\r\n    ArrayList<DataPoint> datapoints = Lists.newArrayList();\r\n    for (TimeSeries timeSeries : metric.getTimeSeriesList()) {\r\n        DataPoint.Builder builder = shared.clone();\r\n        builder.addAllDimensions(createDimensions(metricDescriptor.getLabelKeys(), timeSeries.getLabelValues()));\r\n        List<Point> points = timeSeries.getPoints();\r\n        datapoints.ensureCapacity(datapoints.size() + points.size());\r\n        for (Point point : points) {\r\n            datapoints.add(builder.setValue(createDatum(point.getValue())).build());\r\n        }\r\n    }\r\n    return datapoints;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.CallbackUtil.unregisterCallbacks",
	"Comment": "releases references to any callbacks associated with the specified gl context.",
	"Method": "void unregisterCallbacks(Object context){\r\n    final ContextCapabilities caps = GLContext.getCapabilities();\r\n    Long userParam = contextUserParamsKHR.remove(caps);\r\n    if (userParam != null)\r\n        deleteGlobalRef(userParam);\r\n}"
}, {
	"Path": "com.openhtmltopdf.java2d.Java2DTextRenderer.getGlyphPositions",
	"Comment": "this method gets glyph positions for purposes of selecting text. we are not too worried about selecting textat this point so we just use the first font available.",
	"Method": "float[] getGlyphPositions(OutputDevice outputDevice,FSFont font,String text,float[] getGlyphPositions,OutputDevice outputDevice,FSFont font,FSGlyphVector fsGlyphVector){\r\n    Object aaHint = null;\r\n    Object fracHint = null;\r\n    Graphics2D graphics = ((Java2DOutputDevice) outputDevice).getGraphics();\r\n    Font awtFont = ((AWTFSFont) font).getAWTFonts().get(0);\r\n    if (awtFont.getSize() > threshold) {\r\n        aaHint = graphics.getRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING);\r\n        graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, antiAliasRenderingHint);\r\n    }\r\n    fracHint = graphics.getRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS);\r\n    graphics.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, fractionalFontMetricsHint);\r\n    GlyphVector vector = ((AWTFSGlyphVector) fsGlyphVector).getGlyphVector();\r\n    float[] result = vector.getGlyphPositions(0, vector.getNumGlyphs() + 1, null);\r\n    if (awtFont.getSize() > threshold) {\r\n        graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, aaHint);\r\n    }\r\n    graphics.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, fracHint);\r\n    return result;\r\n}"
}, {
	"Path": "com.openhtmltopdf.java2d.Java2DFontResolver.createFont",
	"Comment": "creates a concrete instance of a font at specified size, weight, style and variant.",
	"Method": "Font createFont(SharedContext ctx,Font rootFont,float size,IdentValue weight,IdentValue style,IdentValue variant){\r\n    int fontConst = Font.PLAIN;\r\n    if (weight != null && (weight == IdentValue.BOLD || weight == IdentValue.FONT_WEIGHT_700 || weight == IdentValue.FONT_WEIGHT_800 || weight == IdentValue.FONT_WEIGHT_900)) {\r\n        fontConst = fontConst | Font.BOLD;\r\n    }\r\n    if (style != null && (style == IdentValue.ITALIC || style == IdentValue.OBLIQUE)) {\r\n        fontConst = fontConst | Font.ITALIC;\r\n    }\r\n    size *= ctx.getTextRenderer().getFontScale();\r\n    Font fnt = rootFont.deriveFont(fontConst, size);\r\n    if (variant != null) {\r\n        if (variant == IdentValue.SMALL_CAPS) {\r\n            fnt = fnt.deriveFont((float) (((float) fnt.getSize()) * 0.6));\r\n        }\r\n    }\r\n    return fnt;\r\n}"
}, {
	"Path": "com.openhtmltopdf.context.StandardAttributeResolver.isVisited",
	"Comment": "gets the visited attribute of the standardattributeresolver object",
	"Method": "boolean isVisited(Object e){\r\n    return isLink(e) && uac.isVisited(nsh.getLinkUri((Element) e));\r\n}"
}, {
	"Path": "org.lwjgl.LibraryPathUtil.getRelativeLWJGLLibraryPath",
	"Comment": "returns plugin relative path to native libraries according to\tcurrent operating system.",
	"Method": "String getRelativeLWJGLLibraryPath(){\r\n    int iOS = -1;\r\n    String osname = System.getProperty(\"os.name\").toLowerCase();\r\n    String osarch = System.getProperty(\"os.arch\").toLowerCase();\r\n    if (osname.startsWith(\"windows\")) {\r\n        iOS = 0;\r\n    } else if (osname.startsWith(\"mac\")) {\r\n        iOS = 1;\r\n    } else if (osname.startsWith(\"linux\")) {\r\n        iOS = 2;\r\n    } else if (osname.startsWith(\"solaris\")) {\r\n        iOS = 3;\r\n    }\r\n    if (iOS >= 0 && iOS < NATIVEPATH.length) {\r\n        String base = \"native\" + File.separator + NATIVEPATH[iOS];\r\n        return base;\r\n    } else {\r\n        throw new OSNotSupportedException(osname, osarch);\r\n    }\r\n}"
}, {
	"Path": "com.facebook.rebound.SpringSystem.create",
	"Comment": "create a new springsystem providing the appropriate constructor parameters to work properlyin an android environment.",
	"Method": "SpringSystem create(){\r\n    return new SpringSystem(AndroidSpringLooperFactory.createSpringLooper());\r\n}"
}, {
	"Path": "org.mewx.wenku8.activity.MainActivity.onCreateOptionsMenu",
	"Comment": "hard menu button works like the soft menu button.and this will control all the menu appearance,i can handle the button list by edit this function.",
	"Method": "boolean onCreateOptionsMenu(Menu menu){\r\n    if (!mNavigationDrawerFragment.isDrawerOpen()) {\r\n        switch(status) {\r\n            case LATEST:\r\n                if (getSupportActionBar() != null)\r\n                    getSupportActionBar().setTitle(getResources().getString(R.string.main_menu_latest));\r\n                getMenuInflater().inflate(R.menu.menu_latest, menu);\r\n                break;\r\n            case RKLIST:\r\n                if (getSupportActionBar() != null)\r\n                    getSupportActionBar().setTitle(getResources().getString(R.string.main_menu_rklist));\r\n                break;\r\n            case FAV:\r\n                if (getSupportActionBar() != null)\r\n                    getSupportActionBar().setTitle(getResources().getString(R.string.main_menu_fav));\r\n                break;\r\n            case CONFIG:\r\n                if (getSupportActionBar() != null)\r\n                    getSupportActionBar().setTitle(getResources().getString(R.string.main_menu_config));\r\n                break;\r\n        }\r\n    } else {\r\n        if (getSupportActionBar() != null)\r\n            getSupportActionBar().setTitle(getResources().getString(R.string.app_name));\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.displaylist.DisplayListPainter.updateTableHeaderFooterPosition",
	"Comment": "if the container is a table and it is set to paginate then update its header\tand footer position for this page.",
	"Method": "void updateTableHeaderFooterPosition(RenderingContext c,BlockBox container){\r\n    if (container.getStyle().isTable()) {\r\n        TableBox table = (TableBox) container;\r\n        if (table.hasContentLimitContainer()) {\r\n            table.updateHeaderFooterPosition(c);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.opencensus.exporter.trace.stackdriver.StackdriverV2ExporterHandler.toAttributesProto",
	"Comment": "these are the attributes of the span, where usually we may add more attributes like the agent.",
	"Method": "Attributes toAttributesProto(io.opencensus.trace.export.SpanData.Attributes attributes,Map<String, AttributeValue> resourceLabels){\r\n    Attributes.Builder attributesBuilder = toAttributesBuilderProto(attributes.getAttributeMap(), attributes.getDroppedAttributesCount());\r\n    attributesBuilder.putAttributeMap(AGENT_LABEL_KEY, AGENT_LABEL_VALUE);\r\n    for (Entry<String, AttributeValue> entry : resourceLabels.entrySet()) {\r\n        attributesBuilder.putAttributeMap(entry.getKey(), entry.getValue());\r\n    }\r\n    return attributesBuilder.build();\r\n}"
}, {
	"Path": "org.lwjgl.opengles.PixelFormat.matchesNonZero",
	"Comment": "returns true if the requested attribute matches the attribute in the specified egl config.\tif the requested attribute is equal to 1, then it will match with any egl config attribute\tthat is greater than 0.",
	"Method": "boolean matchesNonZero(Attrib attrib,EGLConfig config){\r\n    final int reqValue = getAttrib(attrib);\r\n    final int cfgValue = config.getAttribute(attrib.getEGLAttrib());\r\n    return reqValue == cfgValue || (reqValue == 1 && cfgValue > 0);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.Download.setRequestHeaders",
	"Comment": "sets additional http headers to use in the download request.",
	"Method": "void setRequestHeaders(Map<String, String> headers){\r\n    this.requestHeaders = headers;\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix2f.transform",
	"Comment": "transform a vector by a matrix and return the result in a destination\tvector.",
	"Method": "Vector2f transform(Matrix2f left,Vector2f right,Vector2f dest){\r\n    if (dest == null)\r\n        dest = new Vector2f();\r\n    float x = left.m00 * right.x + left.m10 * right.y;\r\n    float y = left.m01 * right.x + left.m11 * right.y;\r\n    dest.x = x;\r\n    dest.y = y;\r\n    return dest;\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Quaternion.setFromMatrix",
	"Comment": "sets the value of the source quaternion using the rotational component of the\tpassed matrix.",
	"Method": "Quaternion setFromMatrix(Matrix4f m,Quaternion setFromMatrix,Matrix4f m,Quaternion q,Quaternion setFromMatrix,Matrix3f m,Quaternion setFromMatrix,Matrix3f m,Quaternion q){\r\n    return q.setFromMat(m.m00, m.m01, m.m02, m.m10, m.m11, m.m12, m.m20, m.m21, m.m22);\r\n}"
}, {
	"Path": "org.newdawn.slick.Input.resetInputTransform",
	"Comment": "reset the transformation being applied to the input to the default",
	"Method": "void resetInputTransform(){\r\n    setOffset(0, 0);\r\n    setScale(1, 1);\r\n}"
}, {
	"Path": "com.openhtmltopdf.bidi.ParagraphSplitter.splitRoot",
	"Comment": "this starts everything by recursively dividing the document into paragraphs.",
	"Method": "void splitRoot(LayoutContext c,Document doc){\r\n    boolean isLiveImplementation = c.getBidiReorderer().isLiveImplementation();\r\n    CalculatedStyle style = c.getSharedContext().getStyle(doc.getDocumentElement());\r\n    IdentValue direction = style.getDirection();\r\n    Paragraph parent = isLiveImplementation ? new Paragraph(direction) : new FakeParagraph(direction);\r\n    if (isLiveImplementation) {\r\n        allParagraphs = new ArrayList<Paragraph>();\r\n        paragraphs = new HashMap<Text, Paragraph>();\r\n        blocks = new HashMap<Element, Paragraph>();\r\n        splitParagraphs(c, doc, parent);\r\n    } else {\r\n        allParagraphs = Collections.singletonList(parent);\r\n        paragraphs = Collections.emptyMap();\r\n        blocks = Collections.emptyMap();\r\n    }\r\n}"
}, {
	"Path": "ddf.minim.ugens.Waves.triangle",
	"Comment": "constructs a perfect triangle wave with the specified duty cycle.",
	"Method": "Wavetable triangle(float dutyCycle){\r\n    dutyCycle = Math.max(0, Math.min(dutyCycle, 1));\r\n    int a = (int) (tableSize * dutyCycle * 0.5);\r\n    return WavetableGenerator.gen7(tableSize, new float[] { 0, -1, 0, 1, 0 }, new int[] { a, a, tSby2 - a, tableSize - tSby2 - a });\r\n}"
}, {
	"Path": "com.j256.ormlite.field.FieldType.getType",
	"Comment": "return the class of the field associated with this field type.",
	"Method": "Class<?> getType(){\r\n    return field.getType();\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Quaternion.scale",
	"Comment": "scale the source quaternion by scale and put the result in the destination",
	"Method": "Vector scale(float scale,Quaternion scale,float scale,Quaternion src,Quaternion dest){\r\n    if (dest == null)\r\n        dest = new Quaternion();\r\n    dest.x = src.x * scale;\r\n    dest.y = src.y * scale;\r\n    dest.z = src.z * scale;\r\n    dest.w = src.w * scale;\r\n    return dest;\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.newmatch.CascadedStyle.createLayoutStyle",
	"Comment": "creates a cascadedstyle using style information fromstartingpoint and then adding the property declarationsfrom decls.",
	"Method": "CascadedStyle createLayoutStyle(PropertyDeclaration[] decls,CascadedStyle createLayoutStyle,List<PropertyDeclaration> decls,CascadedStyle createLayoutStyle,CascadedStyle startingPoint,PropertyDeclaration[] decls){\r\n    return new CascadedStyle(startingPoint, Arrays.asList(decls).iterator());\r\n}"
}, {
	"Path": "itdelatrisu.opsu.render.LegacyCurveRenderState.renderCurve",
	"Comment": "do the actual drawing of the curve into the currently bound framebuffer.",
	"Method": "void renderCurve(Color color,Color borderColor,int from,int to,boolean clearFirst){\r\n    staticState.initGradient();\r\n    RenderState state = saveRenderState();\r\n    staticState.initShaderProgram();\r\n    GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, fbo.getVbo());\r\n    GL20.glUseProgram(staticState.program);\r\n    GL20.glEnableVertexAttribArray(staticState.attribLoc);\r\n    GL20.glEnableVertexAttribArray(staticState.texCoordLoc);\r\n    GL20.glUniform1i(staticState.texLoc, 0);\r\n    GL20.glUniform3f(staticState.colLoc, color.r, color.g, color.b);\r\n    GL20.glUniform4f(staticState.colBorderLoc, borderColor.r, borderColor.g, borderColor.b, borderColor.a);\r\n    GL20.glVertexAttribPointer(staticState.attribLoc, 4, GL11.GL_FLOAT, false, 6 * 4, 2 * 4);\r\n    GL20.glVertexAttribPointer(staticState.texCoordLoc, 2, GL11.GL_FLOAT, false, 6 * 4, 0);\r\n    if (clearFirst)\r\n        GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);\r\n    if (pointsToRender == null) {\r\n        for (int i = from * 2; i < to * 2 - 1; ++i) {\r\n            if (spliceFrom <= i && i <= spliceTo)\r\n                continue;\r\n            GL11.glDrawArrays(GL11.GL_TRIANGLE_FAN, i * (NewCurveStyleState.DIVIDES + 2), NewCurveStyleState.DIVIDES + 2);\r\n        }\r\n    } else {\r\n        Iterator<Integer> iter = pointsToRender.iterator();\r\n        while (iter.hasNext()) {\r\n            for (int i = iter.next() * 2, end = iter.next() * 2 - 1; i < end; ++i) GL11.glDrawArrays(GL11.GL_TRIANGLE_FAN, i * (NewCurveStyleState.DIVIDES + 2), NewCurveStyleState.DIVIDES + 2);\r\n        }\r\n    }\r\n    GL11.glFlush();\r\n    GL20.glDisableVertexAttribArray(staticState.texCoordLoc);\r\n    GL20.glDisableVertexAttribArray(staticState.attribLoc);\r\n    restoreRenderState(state);\r\n}"
}, {
	"Path": "com.facebook.rebound.ui.SpringConfiguratorView.destroy",
	"Comment": "remove the configurator from its parent and clean up springs and listeners",
	"Method": "void destroy(){\r\n    ViewGroup parent = (ViewGroup) getParent();\r\n    if (parent != null) {\r\n        parent.removeView(this);\r\n    }\r\n    mRevealerSpring.destroy();\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.parser.Lexer.yytext",
	"Comment": "returns the text matched by the current regular expression.",
	"Method": "String yytext(){\r\n    return new String(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);\r\n}"
}, {
	"Path": "com.openhtmltopdf.pdfboxout.PdfRendererBuilder.useCacheStore",
	"Comment": "use a specific cache. cache values should be thread safe, so provided your cache store itself\tis thread safe can be used accross threads.",
	"Method": "PdfRendererBuilder useCacheStore(CacheStore which,FSCacheEx<String, FSCacheValue> cache){\r\n    state._caches.put(which, cache);\r\n    return this;\r\n}"
}, {
	"Path": "com.android.volley.DefaultRetryPolicy.retry",
	"Comment": "prepares for the next retry by applying a backoff to the timeout.",
	"Method": "void retry(VolleyError error){\r\n    mCurrentRetryCount++;\r\n    mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);\r\n    if (!hasAttemptRemaining()) {\r\n        throw error;\r\n    }\r\n}"
}, {
	"Path": "com.android.volley.RequestQueueIntegrationTest.add_dedupeByCacheKey",
	"Comment": "asserts that requests with same cache key are processed in order.needs to be an integration test because relies on complex interactions between various queues",
	"Method": "void add_dedupeByCacheKey(){\r\n    Request req1 = new MockRequest();\r\n    Request req2 = new MockRequest();\r\n    RequestFinishedListener listener = mock(RequestFinishedListener.class);\r\n    Answer<NetworkResponse> delayAnswer = new Answer<NetworkResponse>() {\r\n        @Override\r\n        public NetworkResponse answer(InvocationOnMock invocationOnMock) throws Throwable {\r\n            Thread.sleep(20);\r\n            return mock(NetworkResponse.class);\r\n        }\r\n    };\r\n    when(mMockNetwork.performRequest(req1)).thenAnswer(delayAnswer);\r\n    when(mMockNetwork.performRequest(req2)).thenReturn(mock(NetworkResponse.class));\r\n    RequestQueue queue = new RequestQueue(new NoCache(), mMockNetwork, 3, mDelivery);\r\n    queue.addRequestFinishedListener(listener);\r\n    queue.add(req1);\r\n    queue.add(req2);\r\n    queue.start();\r\n    verifyNoMoreInteractions(listener);\r\n    verify(listener, timeout(TIMEOUT)).onRequestFinished(req1);\r\n    verify(listener, timeout(TIMEOUT)).onRequestFinished(req2);\r\n    queue.stop();\r\n}"
}, {
	"Path": "com.android.volley.RequestQueueIntegrationTest.add_dedupeByCacheKey",
	"Comment": "asserts that requests with same cache key are processed in order.needs to be an integration test because relies on complex interactions between various queues",
	"Method": "void add_dedupeByCacheKey(){\r\n    Thread.sleep(20);\r\n    return mock(NetworkResponse.class);\r\n}"
}, {
	"Path": "io.opencensus.exporter.trace.ocagent.OcAgentTraceServiceExportRpcHandler.onExport",
	"Comment": "sends the export request to agent if the stream is still connected, otherwise do nothing.",
	"Method": "void onExport(ExportTraceServiceRequest request){\r\n    if (isCompleted() || exportRequestObserver == null) {\r\n        return;\r\n    }\r\n    try {\r\n        exportRequestObserver.onNext(request);\r\n    } catch (Exception e) {\r\n        onComplete(e);\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.newmatch.CascadedStyle.createAnonymousStyle",
	"Comment": "creates a cascadedstyle, setting the display property toto the value of the display parameter.",
	"Method": "CascadedStyle createAnonymousStyle(IdentValue display){\r\n    CSSPrimitiveValue val = new PropertyValue(display);\r\n    List<PropertyDeclaration> props = Collections.singletonList(new PropertyDeclaration(CSSName.DISPLAY, val, true, StylesheetInfo.USER));\r\n    return new CascadedStyle(props.iterator());\r\n}"
}, {
	"Path": "itdelatrisu.opsu.render.FrameBufferCache.init",
	"Comment": "set the width and height of the framebuffers in this cache.\tshould be called before anything is inserted into the map.",
	"Method": "void init(int width,int height){\r\n    FrameBufferCache.width = width;\r\n    FrameBufferCache.height = height;\r\n}"
}, {
	"Path": "com.openhtmltopdf.pdfboxout.PdfBoxFastOutputDevice.initializePage",
	"Comment": "start a page. a new pdf page starts a new content stream so all graphics state has to be set back to default.",
	"Method": "void initializePage(PDPageContentStream currentPage,PDPage page,float height){\r\n    _cp = new PdfContentStreamAdapter(currentPage);\r\n    _page = page;\r\n    _pageHeight = height;\r\n    _desiredPageState.fillColor = null;\r\n    _desiredPageState.strokeColor = null;\r\n    pushState(new PageState());\r\n    _transform = new AffineTransform();\r\n    _transform.scale(1.0d / _dotsPerPoint, 1.0d / _dotsPerPoint);\r\n    _stroke = transformStroke(STROKE_ONE);\r\n    _originalStroke = _stroke;\r\n    _oldStroke = _stroke;\r\n    setStrokeDiff(_stroke, null);\r\n}"
}, {
	"Path": "io.opencensus.testing.common.TestClock.getNanos",
	"Comment": "converts timestamp into nanoseconds since time 0 and throws an exception if it overflows.",
	"Method": "long getNanos(Timestamp time){\r\n    return LongMath.checkedAdd(LongMath.checkedMultiply(time.getSeconds(), NUM_NANOS_PER_SECOND), time.getNanos());\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.setRestSpeedThreshold",
	"Comment": "sets the speed at which the spring should be considered at rest.",
	"Method": "Spring setRestSpeedThreshold(double restSpeedThreshold){\r\n    mRestSpeedThreshold = restSpeedThreshold;\r\n    return this;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getHorizontalPixel",
	"Comment": "returns the horizontal scroll offset relative to the start of the line.",
	"Method": "int getHorizontalPixel(){\r\n    checkWidget();\r\n    return horizontalScrollOffset;\r\n}"
}, {
	"Path": "com.openhtmltopdf.nonvisualregressiontests.NonVisualRegressionTest.rectEquals",
	"Comment": "expected rect is in top down css pixel units. actual rect is in bottom up pdf points.",
	"Method": "CustomTypeSafeMatcher<PDRectangle> rectEquals(PDRectangle expected,double pageHeight){\r\n    return new RectangleCompare(expected, pageHeight);\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.imageUpdate",
	"Comment": "when an animated gif frame is ready to be drawn the imageobserver\twill call this method.\tthe image frame is copied into a buffer, which is then drawn.\tthis is done to prevent image tearing on gif animations.",
	"Method": "boolean imageUpdate(Image img,int flag,int x,int y,int width,int height){\r\n    if (state == STATE_DONE)\r\n        return false;\r\n    if (flag == ImageObserver.FRAMEBITS && !painting) {\r\n        Image buffer;\r\n        if (img == logo)\r\n            buffer = logoBuffer;\r\n        else\r\n            buffer = progressbarBuffer;\r\n        Graphics g = buffer.getGraphics();\r\n        g.setColor(bgColor);\r\n        g.fillRect(0, 0, buffer.getWidth(null), buffer.getHeight(null));\r\n        if (img == progressbar && logo != null) {\r\n            g.drawImage(logoBuffer, progressbar.getWidth(null) / 2 - logo.getWidth(null) / 2, progressbar.getHeight(null) / 2 - logo.getHeight(null) / 2, null);\r\n        }\r\n        g.drawImage(img, 0, 0, this);\r\n        g.dispose();\r\n        repaint();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.render.Rendertarget.createRTTFramebuffer",
	"Comment": "creates a rendertarget with a texture that it renders the color buffer in\tand a renderbuffer that it renders the depth to.",
	"Method": "Rendertarget createRTTFramebuffer(int width,int height){\r\n    int old_framebuffer = GL11.glGetInteger(EXTFramebufferObject.GL_FRAMEBUFFER_BINDING_EXT);\r\n    int old_texture = GL11.glGetInteger(GL11.GL_TEXTURE_BINDING_2D);\r\n    Rendertarget buffer = new Rendertarget(width, height);\r\n    buffer.bind();\r\n    int fboTexture = buffer.textureID;\r\n    GL11.glBindTexture(GL11.GL_TEXTURE_2D, fboTexture);\r\n    GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, 4, width, height, 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_INT, (ByteBuffer) null);\r\n    GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);\r\n    GL11.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);\r\n    EXTFramebufferObject.glBindRenderbufferEXT(EXTFramebufferObject.GL_RENDERBUFFER_EXT, buffer.depthBufferID);\r\n    EXTFramebufferObject.glRenderbufferStorageEXT(EXTFramebufferObject.GL_RENDERBUFFER_EXT, GL11.GL_DEPTH_COMPONENT, width, height);\r\n    EXTFramebufferObject.glFramebufferRenderbufferEXT(EXTFramebufferObject.GL_FRAMEBUFFER_EXT, EXTFramebufferObject.GL_DEPTH_ATTACHMENT_EXT, EXTFramebufferObject.GL_RENDERBUFFER_EXT, buffer.depthBufferID);\r\n    EXTFramebufferObject.glFramebufferTexture2DEXT(EXTFramebufferObject.GL_FRAMEBUFFER_EXT, EXTFramebufferObject.GL_COLOR_ATTACHMENT0_EXT, GL11.GL_TEXTURE_2D, fboTexture, 0);\r\n    GL11.glBindTexture(GL11.GL_TEXTURE_2D, old_texture);\r\n    EXTFramebufferObject.glBindFramebufferEXT(EXTFramebufferObject.GL_FRAMEBUFFER_EXT, old_framebuffer);\r\n    return buffer;\r\n}"
}, {
	"Path": "org.lwjgl.util.mapped.MappedObject.copyRange",
	"Comment": "copies and amount of sizeofinstances bytes, from the\tcurrent mapped object, to the specified mapped object. note that\tthis includes any padding bytes that are part of sizeof.",
	"Method": "void copyRange(T target,int instances){\r\n    throw new InternalError(\"type not registered\");\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.BeatmapSetList.getBaseNode",
	"Comment": "returns the beatmapsetnode at an index, disregarding expansions.",
	"Method": "BeatmapSetNode getBaseNode(int index){\r\n    if (index < 0 || index >= size())\r\n        return null;\r\n    return nodes.get(index);\r\n}"
}, {
	"Path": "orestes.bloomfilter.redis.RedisBitSet.getBulk",
	"Comment": "fetches the values at the given index positions in a multi transaction. this guarantees a consistent view.",
	"Method": "Boolean[] getBulk(int indexes){\r\n    List<Boolean> results = pool.allowingSlaves().transactionallyDo(p -> {\r\n        for (int index : indexes) {\r\n            get(p, index);\r\n        }\r\n    });\r\n    return results.toArray(new Boolean[indexes.length]);\r\n}"
}, {
	"Path": "com.android.volley.toolbox.ImageRequest.doParse",
	"Comment": "the real guts of parsenetworkresponse. broken out for readability.",
	"Method": "Response<Bitmap> doParse(NetworkResponse response){\r\n    byte[] data = response.data;\r\n    BitmapFactory.Options decodeOptions = new BitmapFactory.Options();\r\n    Bitmap bitmap = null;\r\n    if (mMaxWidth == 0 && mMaxHeight == 0) {\r\n        decodeOptions.inPreferredConfig = mDecodeConfig;\r\n        bitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);\r\n    } else {\r\n        decodeOptions.inJustDecodeBounds = true;\r\n        BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);\r\n        int actualWidth = decodeOptions.outWidth;\r\n        int actualHeight = decodeOptions.outHeight;\r\n        int desiredWidth = getResizedDimension(mMaxWidth, mMaxHeight, actualWidth, actualHeight, mScaleType);\r\n        int desiredHeight = getResizedDimension(mMaxHeight, mMaxWidth, actualHeight, actualWidth, mScaleType);\r\n        decodeOptions.inJustDecodeBounds = false;\r\n        decodeOptions.inSampleSize = findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight);\r\n        Bitmap tempBitmap = BitmapFactory.decodeByteArray(data, 0, data.length, decodeOptions);\r\n        if (tempBitmap != null && (tempBitmap.getWidth() > desiredWidth || tempBitmap.getHeight() > desiredHeight)) {\r\n            bitmap = Bitmap.createScaledBitmap(tempBitmap, desiredWidth, desiredHeight, true);\r\n            tempBitmap.recycle();\r\n        } else {\r\n            bitmap = tempBitmap;\r\n        }\r\n    }\r\n    if (bitmap == null) {\r\n        return Response.error(new ParseError(response));\r\n    } else {\r\n        return Response.success(bitmap, HttpHeaderParser.parseCacheHeaders(response));\r\n    }\r\n}"
}, {
	"Path": "ddf.minim.javasound.FloatSampleBuffer.writeByteBuffer",
	"Comment": "write the contents of the byte array to this buffer, overwriting existing\tdata. if the byte array has fewer channels than this float buffer, only\tthe first channels are written. vice versa, if the byte buffer has more\tchannels than this float buffer, only the first channels of the byte\tbuffer are written to this buffer.\tthe format and the number of samples of this float buffer are not\tchanged, so if the byte array has more samples than fit into this float\tbuffer, it is not expanded.",
	"Method": "int writeByteBuffer(byte[] buffer,int srcByteOffset,AudioFormat format,int dstSampleOffset,int aSampleCount){\r\n    if (dstSampleOffset + aSampleCount > getSampleCount()) {\r\n        aSampleCount = getSampleCount() - dstSampleOffset;\r\n    }\r\n    int lChannels = format.getChannels();\r\n    if (lChannels > getChannelCount()) {\r\n        lChannels = getChannelCount();\r\n    }\r\n    if (lChannels > format.getChannels()) {\r\n        lChannels = format.getChannels();\r\n    }\r\n    for (int channel = 0; channel < lChannels; channel++) {\r\n        float[] data = getChannel(channel);\r\n        FloatSampleTools.byte2floatGeneric(buffer, srcByteOffset, format.getFrameSize(), data, dstSampleOffset, aSampleCount, format);\r\n        srcByteOffset += format.getFrameSize() / format.getChannels();\r\n    }\r\n    return aSampleCount;\r\n}"
}, {
	"Path": "me.imid.swipebacklayout.lib.ViewDragHelper.setEdgeSize",
	"Comment": "set the size of an edge. this is the range in pixels along the edges ofthis view that will actively detect edge touches or drags if edgetracking is enabled.",
	"Method": "void setEdgeSize(int size){\r\n    mEdgeSize = size;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.video.Video.hasVideoBacklogOver",
	"Comment": "returns whether the frame backlog is over the given number of frames.",
	"Method": "boolean hasVideoBacklogOver(int frameCount,long syncTime){\r\n    return (videoIndex + frameCount) * frameInterval <= syncTime;\r\n}"
}, {
	"Path": "org.lwjgl.examples.spaceinvaders.ShipEntity.move",
	"Comment": "request that the ship move itself based on an elapsed ammount of",
	"Method": "void move(long delta){\r\n    if ((dx < 0) && (x < LEFT_BORDER)) {\r\n        return;\r\n    }\r\n    if ((dx > 0) && (x > RIGHT_BORDER)) {\r\n        return;\r\n    }\r\n    super.move(delta);\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.getDescent",
	"Comment": "gets the distance from the baseline to the bottom of most alphanumeric characters \twith descenders.",
	"Method": "int getDescent(){\r\n    return descent;\r\n}"
}, {
	"Path": "io.opencensus.exporter.trace.jaeger.JaegerTraceExporter.createAndRegister",
	"Comment": "creates and registers the jaeger trace exporter to the opencensus library. only one jaegerexporter can be registered at any point.",
	"Method": "void createAndRegister(String thriftEndpoint,String serviceName){\r\n    synchronized (monitor) {\r\n        checkState(handler == null, \"Jaeger exporter is already registered.\");\r\n        final SpanExporter.Handler newHandler = newHandler(thriftEndpoint, serviceName);\r\n        JaegerTraceExporter.handler = newHandler;\r\n        register(Tracing.getExportComponent().getSpanExporter(), newHandler);\r\n    }\r\n}"
}, {
	"Path": "ddf.minim.NoteManager.addEvent",
	"Comment": "but we store them as taking place at a specific time, rather than a relative time.",
	"Method": "void addEvent(float startTime,float duration,Instrument instrument){\r\n    int on = now + (int) (sampleRate * (startTime + noteOffset) * 60f / tempo);\r\n    Integer onAt = new Integer(on);\r\n    float actualDuration = duration * durationFactor * 60f / tempo;\r\n    if (events.containsKey(onAt)) {\r\n        ArrayList<NoteEvent> eventsAtOn = events.get(onAt);\r\n        eventsAtOn.add(new NoteOnEvent(instrument, actualDuration));\r\n    } else {\r\n        ArrayList<NoteEvent> eventsAtOn = new ArrayList<NoteEvent>();\r\n        eventsAtOn.add(new NoteOnEvent(instrument, actualDuration));\r\n        events.put(onAt, eventsAtOn);\r\n    }\r\n    Integer offAt = new Integer(on + (int) (sampleRate * actualDuration));\r\n    if (events.containsKey(offAt)) {\r\n        ArrayList<NoteEvent> eventsAtOff = events.get(offAt);\r\n        eventsAtOff.add(new NoteOffEvent(instrument));\r\n    } else {\r\n        ArrayList<NoteEvent> eventsAtOff = new ArrayList<NoteEvent>();\r\n        eventsAtOff.add(new NoteOffEvent(instrument));\r\n        events.put(offAt, eventsAtOff);\r\n    }\r\n}"
}, {
	"Path": "ddf.minim.analysis.FourierTransform.avgSize",
	"Comment": "returns the number of averages currently being calculated.",
	"Method": "int avgSize(){\r\n    return averages.length;\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix2f.sub",
	"Comment": "subtract the right matrix from the left and place the result in a third matrix.",
	"Method": "Matrix2f sub(Matrix2f left,Matrix2f right,Matrix2f dest){\r\n    if (dest == null)\r\n        dest = new Matrix2f();\r\n    dest.m00 = left.m00 - right.m00;\r\n    dest.m01 = left.m01 - right.m01;\r\n    dest.m10 = left.m10 - right.m10;\r\n    dest.m11 = left.m11 - right.m11;\r\n    return dest;\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.isImageReady",
	"Comment": "call to find whether the view is initialised and ready for rendering tiles.",
	"Method": "boolean isImageReady(){\r\n    return readySent && vTranslate != null && tileMap != null && sWidth > 0 && sHeight > 0;\r\n}"
}, {
	"Path": "org.newdawn.slick.Image.getResourceReference",
	"Comment": "get the reference to the resource this image was loaded from, if any. note that\tthis can be null in the cases where an image was programatically generated.",
	"Method": "String getResourceReference(){\r\n    return ref;\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.animateScaleAndCenter",
	"Comment": "creates a scale animation builder, that when started will animate a zoom in or out. if this would move the imagebeyond the panning limits, the image is automatically panned during the animation.",
	"Method": "AnimationBuilder animateScaleAndCenter(float scale,PointF sCenter){\r\n    if (!isImageReady()) {\r\n        return null;\r\n    }\r\n    return new AnimationBuilder(scale, sCenter);\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testHiddenInsideTransform",
	"Comment": "tests that overflow hidden inside a transformed element correctly usesthe transformed coordinate space.",
	"Method": "void testHiddenInsideTransform(){\r\n    assertTrue(vt.runTest(\"hidden-inside-transform\"));\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGL.eglQueryString",
	"Comment": "returns a string describing some aspect of the egl implementation running on the specified display.",
	"Method": "String eglQueryString(EGLDisplay dpy,int name){\r\n    return neglQueryString(dpy.getPointer(), name);\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.constants.CSSName.compareTo",
	"Comment": "assumed to be consistent with equals because cssname is in essence an enum",
	"Method": "int compareTo(Object object){\r\n    if (object == null)\r\n        throw new NullPointerException();\r\n    return FS_ID - ((CSSName) object).FS_ID;\r\n}"
}, {
	"Path": "ddf.minim.ugens.Oscil.setPhase",
	"Comment": "set the amount that the phase will be offset by. oscil steps its time\tfrom 0 to 1, which means that the phase is also normalized. however, it\tstill makes sense to set the phase to greater than 1 or even to a\tnegative number.",
	"Method": "void setPhase(float newPhase){\r\n    phase.setLastValue(newPhase);\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.vTranslateForSCenter",
	"Comment": "get the translation required to place a given source coordinate at the center of the screen. accepts the desiredscale as an argument, so this is independent of current translate and scale. the result is fitted to bounds, puttingthe image point as near to the screen center as permitted.",
	"Method": "PointF vTranslateForSCenter(PointF sCenter,float scale){\r\n    PointF vTranslate = new PointF((getWidth() / 2) - (sCenter.x * scale), (getHeight() / 2) - (sCenter.y * scale));\r\n    ScaleAndTranslate sat = new ScaleAndTranslate(scale, vTranslate);\r\n    fitToBounds(true, sat);\r\n    return vTranslate;\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.newmatch.Selector.getChainedSelector",
	"Comment": "get the next selector in the chain, for matching against elements alongthe appropriate axis",
	"Method": "Selector getChainedSelector(){\r\n    return chainedSelector;\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.displaylist.DisplayListCollector.collectRoot",
	"Comment": "use this method to collect all boxes recursively into a list of paint instructions\tfor each page.",
	"Method": "DisplayListContainer collectRoot(RenderingContext c,Layer rootLayer){\r\n    if (!rootLayer.isRootLayer()) {\r\n        return null;\r\n    }\r\n    rootLayer.propagateCurrentTransformationMatrix(c);\r\n    DisplayListContainer displayList = new ArrayDisplayListContainer(0, _pages.size() - 1);\r\n    collect(c, rootLayer, displayList, EnumSet.noneOf(CollectFlags.class));\r\n    return displayList;\r\n}"
}, {
	"Path": "io.opencensus.common.Duration.create",
	"Comment": "creates a new time duration from given seconds and nanoseconds.",
	"Method": "Duration create(long seconds,int nanos){\r\n    if (seconds < -MAX_SECONDS) {\r\n        throw new IllegalArgumentException(\"'seconds' is less than minimum (\" + -MAX_SECONDS + \"): \" + seconds);\r\n    }\r\n    if (seconds > MAX_SECONDS) {\r\n        throw new IllegalArgumentException(\"'seconds' is greater than maximum (\" + MAX_SECONDS + \"): \" + seconds);\r\n    }\r\n    if (nanos < -MAX_NANOS) {\r\n        throw new IllegalArgumentException(\"'nanos' is less than minimum (\" + -MAX_NANOS + \"): \" + nanos);\r\n    }\r\n    if (nanos > MAX_NANOS) {\r\n        throw new IllegalArgumentException(\"'nanos' is greater than maximum (\" + MAX_NANOS + \"): \" + nanos);\r\n    }\r\n    if ((seconds < 0 && nanos > 0) || (seconds > 0 && nanos < 0)) {\r\n        throw new IllegalArgumentException(\"'seconds' and 'nanos' have inconsistent sign: seconds=\" + seconds + \", nanos=\" + nanos);\r\n    }\r\n    return new AutoValue_Duration(seconds, nanos);\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.vTranslateForSCenter",
	"Comment": "get the translation required to place a given source coordinate at the center of the screen. accepts the desiredscale as an argument, so this is independent of current translate and scale. the result is fitted to bounds, puttingthe image point as near to the screen center as permitted.",
	"Method": "PointF vTranslateForSCenter(PointF sCenter,float scale){\r\n    PointF vTranslate = new PointF((getWidth() / 2) - (sCenter.x * scale), (getHeight() / 2) - (sCenter.y * scale));\r\n    ScaleAndTranslate sat = new ScaleAndTranslate(scale, vTranslate);\r\n    fitToBounds(true, sat);\r\n    return vTranslate;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.WindowsRegistry.queryRegistrationKey",
	"Comment": "query the registry value specified by the root key, subkey, value tuple",
	"Method": "String queryRegistrationKey(int root_key,String subkey,String value){\r\n    switch(root_key) {\r\n        case HKEY_CLASSES_ROOT:\r\n        case HKEY_CURRENT_USER:\r\n        case HKEY_LOCAL_MACHINE:\r\n        case HKEY_USERS:\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Invalid enum: \" + root_key);\r\n    }\r\n    return nQueryRegistrationKey(root_key, subkey, value);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.Utils.deleteDirectory",
	"Comment": "recursively deletes all files and folders in a directory, then\tdeletes the directory itself.",
	"Method": "void deleteDirectory(File dir){\r\n    if (dir == null || !dir.isDirectory())\r\n        return;\r\n    File[] files = dir.listFiles();\r\n    if (files != null && files.length > 0) {\r\n        for (File file : files) {\r\n            if (file.isDirectory())\r\n                deleteDirectory(file);\r\n            else\r\n                file.delete();\r\n        }\r\n    }\r\n    dir.delete();\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix3f.add",
	"Comment": "add two matrices together and place the result in a third matrix.",
	"Method": "Matrix3f add(Matrix3f left,Matrix3f right,Matrix3f dest){\r\n    if (dest == null)\r\n        dest = new Matrix3f();\r\n    dest.m00 = left.m00 + right.m00;\r\n    dest.m01 = left.m01 + right.m01;\r\n    dest.m02 = left.m02 + right.m02;\r\n    dest.m10 = left.m10 + right.m10;\r\n    dest.m11 = left.m11 + right.m11;\r\n    dest.m12 = left.m12 + right.m12;\r\n    dest.m20 = left.m20 + right.m20;\r\n    dest.m21 = left.m21 + right.m21;\r\n    dest.m22 = left.m22 + right.m22;\r\n    return dest;\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.style.derived.BorderPropertySet.lighten",
	"Comment": "returns the colors for brighter parts of each side for a particular decoration style",
	"Method": "BorderPropertySet lighten(IdentValue style){\r\n    BorderPropertySet bc = new BorderPropertySet(this);\r\n    bc._topColor = _topColor == null ? null : _topColor.lightenColor();\r\n    bc._bottomColor = _bottomColor == null ? null : _bottomColor.lightenColor();\r\n    bc._leftColor = _leftColor == null ? null : _leftColor.lightenColor();\r\n    bc._rightColor = _rightColor == null ? null : _rightColor.lightenColor();\r\n    return bc;\r\n}"
}, {
	"Path": "ddf.minim.ugens.Wavetable.normalize",
	"Comment": "normalizes the wavetable by finding the largest amplitude in the table\tand scaling the table by the inverse of that amount. the result is that\tthe largest value in the table will now have an amplitude of 1 and\teverything else is scaled proportionally.",
	"Method": "void normalize(){\r\n    float max = Float.MIN_VALUE;\r\n    for (int i = 0; i < waveform.length; i++) {\r\n        if (Math.abs(waveform[i]) > max)\r\n            max = Math.abs(waveform[i]);\r\n    }\r\n    scale(1 / max);\r\n}"
}, {
	"Path": "com.j256.ormlite.table.TableUtils.dropTable",
	"Comment": "issue the database statements to drop the table associated with a dao.",
	"Method": "int dropTable(ConnectionSource connectionSource,Class<T> dataClass,boolean ignoreErrors,int dropTable,Dao<T, ID> dao,boolean ignoreErrors,int dropTable,ConnectionSource connectionSource,DatabaseTableConfig<T> tableConfig,boolean ignoreErrors){\r\n    DatabaseType databaseType = connectionSource.getDatabaseType();\r\n    Dao<T, ID> dao = DaoManager.createDao(connectionSource, tableConfig);\r\n    if (dao instanceof BaseDaoImpl<?, ?>) {\r\n        return doDropTable(databaseType, connectionSource, ((BaseDaoImpl<?, ?>) dao).getTableInfo(), ignoreErrors);\r\n    } else {\r\n        tableConfig.extractFieldTypes(connectionSource);\r\n        TableInfo<T, ID> tableInfo = new TableInfo<T, ID>(databaseType, null, tableConfig);\r\n        return doDropTable(databaseType, connectionSource, tableInfo, ignoreErrors);\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.opengl.APIUtil.getLengths",
	"Comment": "returns a buffer containing the lengths of the specified strings.",
	"Method": "IntBuffer getLengths(ContextCapabilities caps,IntBuffer getLengths,ContextCapabilities caps,int size,long getLengths,ContextCapabilities caps,CharSequence[] strings){\r\n    IntBuffer buffer = getLengths(caps, strings.length);\r\n    for (CharSequence string : strings) buffer.put(string.length());\r\n    buffer.flip();\r\n    return MemoryUtil.getAddress0(buffer);\r\n}"
}, {
	"Path": "ddf.minim.Minim.loadFileStream",
	"Comment": "load the file into an audiorecordingstream with a buffer size of 1024 \tsamples.",
	"Method": "AudioRecordingStream loadFileStream(String filename,int bufferSize,boolean inMemory,AudioRecordingStream loadFileStream,String filename){\r\n    return loadFileStream(filename, 1024, false);\r\n}"
}, {
	"Path": "com.openhtmltopdf.pdfboxout.PdfBoxSlowOutputDevice.initializePage",
	"Comment": "start a page. a new pdf page starts a new content stream so all graphics state has to be set back to default.",
	"Method": "void initializePage(PDPageContentStream currentPage,PDPage page,float height){\r\n    _cp = new PdfContentStreamAdapter(currentPage);\r\n    _page = page;\r\n    _pageHeight = height;\r\n    if (!isFastRenderer()) {\r\n        _cp.saveGraphics();\r\n    }\r\n    _transform = new AffineTransform();\r\n    _transform.scale(1.0d / _dotsPerPoint, 1.0d / _dotsPerPoint);\r\n    _absoluteTransformOriginX = 0;\r\n    _absoluteTransformOriginY += height * _dotsPerPoint;\r\n    _stroke = transformStroke(STROKE_ONE);\r\n    _originalStroke = _stroke;\r\n    _oldStroke = _stroke;\r\n    setStrokeDiff(_stroke, null);\r\n    if (_defaultDestination == null) {\r\n        PDPageFitHeightDestination dest = new PDPageFitHeightDestination();\r\n        dest.setPage(page);\r\n    }\r\n}"
}, {
	"Path": "org.newdawn.slick.Input.setDoubleClickInterval",
	"Comment": "set the double click interval, the time between the first\tand second clicks that should be interpreted as a \tdouble click.",
	"Method": "void setDoubleClickInterval(int delay){\r\n    doubleClickDelay = delay;\r\n}"
}, {
	"Path": "io.opencensus.exporter.stats.stackdriver.StackdriverStatsExporter.createMetricServiceClient",
	"Comment": "initialize metricserviceclient inside lock to avoid creating multiple clients.",
	"Method": "MetricServiceClient createMetricServiceClient(Credentials credentials){\r\n    MetricServiceSettings.Builder settingsBuilder = MetricServiceSettings.newBuilder().setTransportChannelProvider(InstantiatingGrpcChannelProvider.newBuilder().setHeaderProvider(OPENCENSUS_USER_AGENT_HEADER_PROVIDER).build());\r\n    if (credentials != null) {\r\n        settingsBuilder.setCredentialsProvider(FixedCredentialsProvider.create(credentials));\r\n    }\r\n    return MetricServiceClient.create(settingsBuilder.build());\r\n}"
}, {
	"Path": "com.j256.ormlite.stmt.StatementBuilder.reset",
	"Comment": "clear out all of the statement settings so we can reuse the builder.",
	"Method": "void reset(){\r\n    where = null;\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.calculateInSampleSize",
	"Comment": "calculates sample size to fit the source image in given bounds.",
	"Method": "int calculateInSampleSize(){\r\n    float adjustedScale = scale;\r\n    if (minimumTileDpi > 0) {\r\n        DisplayMetrics metrics = getResources().getDisplayMetrics();\r\n        float averageDpi = (metrics.xdpi + metrics.ydpi) / 2;\r\n        adjustedScale = (minimumTileDpi / averageDpi) * scale;\r\n    }\r\n    int reqWidth = (int) (sWidth() * adjustedScale);\r\n    int reqHeight = (int) (sHeight() * adjustedScale);\r\n    int inSampleSize = 1;\r\n    if (reqWidth == 0 || reqHeight == 0) {\r\n        return 32;\r\n    }\r\n    if (sHeight() > reqHeight || sWidth() > reqWidth) {\r\n        final int heightRatio = Math.round((float) sHeight() / (float) reqHeight);\r\n        final int widthRatio = Math.round((float) sWidth() / (float) reqWidth);\r\n        inSampleSize = heightRatio < widthRatio ? heightRatio : widthRatio;\r\n    }\r\n    int power = 1;\r\n    while (power * 2 < inSampleSize) {\r\n        power = power * 2;\r\n    }\r\n    return power;\r\n}"
}, {
	"Path": "ddf.minim.AudioRecorder.beginRecord",
	"Comment": "begins recording audio from the current record source. if recording waspreviously halted, and the save method was not called, samples will beappended to the end of the material recorded so far.",
	"Method": "void beginRecord(){\r\n    recorder.beginRecord();\r\n}"
}, {
	"Path": "com.openhtmltopdf.resource.FSCatalog.addHandlers",
	"Comment": "adds the default entityresolved and errorhandler for the sax parser.",
	"Method": "void addHandlers(XMLReader xmlReader,ContentHandler ch){\r\n    try {\r\n        xmlReader.setContentHandler(ch);\r\n        xmlReader.setErrorHandler(new ErrorHandler() {\r\n            public void error(SAXParseException ex) {\r\n                if (XRLog.isLoggingEnabled()) {\r\n                    XRLog.xmlEntities(Level.WARNING, ex.getMessage());\r\n                }\r\n            }\r\n            public void fatalError(SAXParseException ex) {\r\n                if (XRLog.isLoggingEnabled()) {\r\n                    XRLog.xmlEntities(Level.WARNING, ex.getMessage());\r\n                }\r\n            }\r\n            public void warning(SAXParseException ex) {\r\n                if (XRLog.isLoggingEnabled()) {\r\n                    XRLog.xmlEntities(Level.WARNING, ex.getMessage());\r\n                }\r\n            }\r\n        });\r\n    } catch (Exception ex) {\r\n        throw new XRRuntimeException(\"Failed on configuring SAX parser/XMLReader.\", ex);\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.resource.FSCatalog.addHandlers",
	"Comment": "adds the default entityresolved and errorhandler for the sax parser.",
	"Method": "void addHandlers(XMLReader xmlReader,ContentHandler ch){\r\n    if (XRLog.isLoggingEnabled()) {\r\n        XRLog.xmlEntities(Level.WARNING, ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.resource.FSCatalog.addHandlers",
	"Comment": "adds the default entityresolved and errorhandler for the sax parser.",
	"Method": "void addHandlers(XMLReader xmlReader,ContentHandler ch){\r\n    if (XRLog.isLoggingEnabled()) {\r\n        XRLog.xmlEntities(Level.WARNING, ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.resource.FSCatalog.addHandlers",
	"Comment": "adds the default entityresolved and errorhandler for the sax parser.",
	"Method": "void addHandlers(XMLReader xmlReader,ContentHandler ch){\r\n    if (XRLog.isLoggingEnabled()) {\r\n        XRLog.xmlEntities(Level.WARNING, ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.newdawn.slick.openal.SoundStore.stopSoundEffect",
	"Comment": "stop a playing sound identified by the id returned from playing. this utility method\tshould only be used when needing to stop sound effects that may have been played \tmore than once and need to be explicitly stopped.",
	"Method": "void stopSoundEffect(int id){\r\n    AL10.alSourceStop(id);\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix3f.transform",
	"Comment": "transform a vector by a matrix and return the result in a destination\tvector.",
	"Method": "Vector3f transform(Matrix3f left,Vector3f right,Vector3f dest){\r\n    if (dest == null)\r\n        dest = new Vector3f();\r\n    float x = left.m00 * right.x + left.m10 * right.y + left.m20 * right.z;\r\n    float y = left.m01 * right.x + left.m11 * right.y + left.m21 * right.z;\r\n    float z = left.m02 * right.x + left.m12 * right.y + left.m22 * right.z;\r\n    dest.x = x;\r\n    dest.y = y;\r\n    dest.z = z;\r\n    return dest;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGLSurface.getDisplay",
	"Comment": "returns the egl display from which this egl surface was created.",
	"Method": "EGLDisplay getDisplay(){\r\n    return display;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.DownloadNode.downloadIconContains",
	"Comment": "returns true if the coordinates are within the bounds of the\tdownload action icon at the given index.",
	"Method": "boolean downloadIconContains(float cx,float cy,int index){\r\n    int iconWidth = GameImage.DELETE.getImage().getWidth();\r\n    float edgeX = infoBaseX + infoWidth * 0.985f;\r\n    float y = infoBaseY + (index * infoHeight);\r\n    float marginY = infoHeight * 0.04f;\r\n    return ((cx > edgeX - iconWidth && cx < edgeX) && (cy > y + marginY && cy < y + marginY + iconWidth));\r\n}"
}, {
	"Path": "com.openhtmltopdf.simple.extend.XhtmlCssOnlyNamespaceHandler.getElementStyling",
	"Comment": "gets the elementstyling attribute of the xhtmlnamespacehandler object",
	"Method": "String getElementStyling(org.w3c.dom.Element e){\r\n    StringBuilder style = new StringBuilder();\r\n    if (e.getNodeName().equals(\"td\") || e.getNodeName().equals(\"th\")) {\r\n        String s;\r\n        s = getAttribute(e, \"colspan\");\r\n        if (s != null) {\r\n            style.append(\"-fs-table-cell-colspan: \");\r\n            style.append(s);\r\n            style.append(\";\");\r\n        }\r\n        s = getAttribute(e, \"rowspan\");\r\n        if (s != null) {\r\n            style.append(\"-fs-table-cell-rowspan: \");\r\n            style.append(s);\r\n            style.append(\";\");\r\n        }\r\n    } else if (e.getNodeName().equals(\"img\")) {\r\n        String s;\r\n        s = getAttribute(e, \"width\");\r\n        if (s != null) {\r\n            style.append(\"width: \");\r\n            style.append(convertToLength(s));\r\n            style.append(\";\");\r\n        }\r\n        s = getAttribute(e, \"height\");\r\n        if (s != null) {\r\n            style.append(\"height: \");\r\n            style.append(convertToLength(s));\r\n            style.append(\";\");\r\n        }\r\n    } else if (e.getNodeName().equals(\"colgroup\") || e.getNodeName().equals(\"col\")) {\r\n        String s;\r\n        s = getAttribute(e, \"span\");\r\n        if (s != null) {\r\n            style.append(\"-fs-table-cell-colspan: \");\r\n            style.append(s);\r\n            style.append(\";\");\r\n        }\r\n        s = getAttribute(e, \"width\");\r\n        if (s != null) {\r\n            style.append(\"width: \");\r\n            style.append(convertToLength(s));\r\n            style.append(\";\");\r\n        }\r\n    }\r\n    style.append(e.getAttribute(\"style\"));\r\n    return style.toString();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ui.MenuButton.contains",
	"Comment": "returns true if the coordinates are within the button bounds and the\tpixel at the specified location has an alpha level above the given bound.",
	"Method": "boolean contains(float cx,float cy,boolean contains,float cx,float cy,float alpha){\r\n    Image image = this.img;\r\n    if (image == null)\r\n        image = anim.getCurrentFrame();\r\n    float xRad = img.getWidth() / 2f, yRad = img.getHeight() / 2f;\r\n    return ((cx > x - xRad && cx < x + xRad) && (cy > y - yRad && cy < y + yRad) && image.getAlphaAt((int) (cx - (x - xRad)), (int) (cy - (y - yRad))) > alpha);\r\n}"
}, {
	"Path": "org.lwjgl.openal.Util.checkALError",
	"Comment": "checks for any al errors and throws an unchecked exception on errors",
	"Method": "void checkALError(){\r\n    int err = AL10.alGetError();\r\n    if (err != AL10.AL_NO_ERROR)\r\n        throw new OpenALException(err);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.states.Game.hasMoreObjects",
	"Comment": "returns whether there are any more objects remaining in the map.",
	"Method": "boolean hasMoreObjects(){\r\n    return objectIndex < gameObjects.length || !passedObjects.isEmpty();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.Options.isExperimentalSliderMerging",
	"Comment": "returns whether or not to merge overlapping sliders together when drawing.\tonly applies to experimental sliders.",
	"Method": "boolean isExperimentalSliderMerging(){\r\n    return GameOption.EXPERIMENTAL_SLIDERS_MERGE.getBooleanValue();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.audio.MusicController.getPosition",
	"Comment": "returns the position in the current track, in milliseconds.\tif no track is loaded, 0 will be returned.",
	"Method": "int getPosition(boolean useOffsets){\r\n    int offset = 0;\r\n    if (useOffsets) {\r\n        offset += Options.getMusicOffset();\r\n        if (lastBeatmap != null)\r\n            offset += lastBeatmap.localMusicOffset;\r\n    }\r\n    if (isPlaying())\r\n        return (int) (player.getPosition() * 1000 + offset);\r\n    else if (isPaused())\r\n        return Math.max((int) (pauseTime * 1000 + offset), 0);\r\n    else\r\n        return 0;\r\n}"
}, {
	"Path": "org.mewx.wenku8.util.LightUserSession.isUserInfoSet",
	"Comment": "this function will only judge whether the username and the password var is set.not judging what letters are they contains.",
	"Method": "boolean isUserInfoSet(){\r\n    return username != null && password != null && username.length() != 0 && password.length() != 0;\r\n}"
}, {
	"Path": "org.lwjgl.opencl.CLPlatform.getDevices",
	"Comment": "returns a list of the available devices on this platform that\tmatch the specified type, filtered by the specified filter.",
	"Method": "List<CLDevice> getDevices(int device_type,List<CLDevice> getDevices,int device_type,Filter<CLDevice> filter,List<CLDevice> getDevices,CLPlatform platform,int device_type,Filter<CLDevice> filter){\r\n    return util.getDevices(this, device_type, filter);\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.getCurrentDisplacementDistance",
	"Comment": "get the displacement of the springs current value from its rest value.",
	"Method": "double getCurrentDisplacementDistance(){\r\n    return getDisplacementDistanceForState(mCurrentState);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.GameData.getCurrentScoreData",
	"Comment": "returns a scoredata object encapsulating all current game data.",
	"Method": "ScoreData getCurrentScoreData(Beatmap beatmap,boolean slidingScore){\r\n    ScoreData sd = new ScoreData();\r\n    sd.timestamp = System.currentTimeMillis() / 1000L;\r\n    sd.MID = beatmap.beatmapID;\r\n    sd.MSID = beatmap.beatmapSetID;\r\n    sd.title = beatmap.title;\r\n    sd.artist = beatmap.artist;\r\n    sd.creator = beatmap.creator;\r\n    sd.version = beatmap.version;\r\n    sd.hit300 = hitResultCount[HIT_300];\r\n    sd.hit100 = hitResultCount[HIT_100];\r\n    sd.hit50 = hitResultCount[HIT_50];\r\n    sd.geki = hitResultCount[HIT_300G];\r\n    sd.katu = hitResultCount[HIT_300K] + hitResultCount[HIT_100K];\r\n    sd.miss = hitResultCount[HIT_MISS];\r\n    sd.score = slidingScore ? scoreDisplay : score;\r\n    sd.combo = comboMax;\r\n    sd.perfect = (comboMax == fullObjectCount);\r\n    sd.mods = GameMod.getModState();\r\n    sd.replayString = (replay == null) ? null : replay.getReplayFilename();\r\n    sd.playerName = GameMod.AUTO.isActive() ? UserList.AUTO_USER_NAME : UserList.get().getCurrentUser().getName();\r\n    return sd;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.video.FFmpeg.getDefaultNativeFilename",
	"Comment": "returns the expected file name of the ffmpeg shared library, based on\tthe current operating system and architecture.",
	"Method": "String getDefaultNativeFilename(){\r\n    String resourceName = \"ffmpeg\";\r\n    if (Extractor.isMac)\r\n        resourceName += \"-mac\";\r\n    else {\r\n        resourceName += Extractor.is64bit ? \"64\" : \"32\";\r\n        if (Extractor.isWindows)\r\n            resourceName += \".exe\";\r\n    }\r\n    return resourceName;\r\n}"
}, {
	"Path": "org.lwjgl.util.glu.Util.nearestPower",
	"Comment": "method nearestpower.\tcompute the nearest power of 2 number.this algorithm is a little strange, but it works quite well.",
	"Method": "int nearestPower(int value){\r\n    int i;\r\n    i = 1;\r\n    if (value == 0)\r\n        return -1;\r\n    for (; ; ) {\r\n        if (value == 1) {\r\n            return i;\r\n        } else if (value == 3) {\r\n            return i << 2;\r\n        }\r\n        value >>= 1;\r\n        i <<= 1;\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.opengl.XRandR.parseScreenHeader",
	"Comment": "parses a screen configuration header and extracts information about the position of the screen.",
	"Method": "void parseScreenHeader(int[] screenPosition,String resPos){\r\n    Matcher m = SCREEN_HEADER_PATTERN.matcher(resPos);\r\n    if (!m.matches()) {\r\n        screenPosition[0] = 0;\r\n        screenPosition[1] = 0;\r\n        return;\r\n    }\r\n    screenPosition[0] = Integer.parseInt(m.group(3));\r\n    screenPosition[1] = Integer.parseInt(m.group(4));\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.Configuration.finer",
	"Comment": "used internally to log a message about the class at level finer",
	"Method": "void finer(String msg){\r\n    if (logLevel.intValue() <= Level.FINER.intValue()) {\r\n        println(Level.FINER, msg);\r\n    }\r\n}"
}, {
	"Path": "com.j256.ormlite.stmt.QueryBuilder.addJoinInfo",
	"Comment": "add join info to the query. this can be called multiple times to join with more than one table.",
	"Method": "void addJoinInfo(JoinType type,String localColumnName,String joinedColumnName,QueryBuilder<?, ?> joinedQueryBuilder,JoinWhereOperation operation){\r\n    JoinInfo joinInfo = new JoinInfo(type, joinedQueryBuilder, operation);\r\n    if (localColumnName == null) {\r\n        matchJoinedFields(joinInfo, joinedQueryBuilder);\r\n    } else {\r\n        matchJoinedFieldsByName(joinInfo, localColumnName, joinedColumnName, joinedQueryBuilder);\r\n    }\r\n    if (joinList == null) {\r\n        joinList = new ArrayList<JoinInfo>();\r\n    }\r\n    joinList.add(joinInfo);\r\n}"
}, {
	"Path": "com.openhtmltopdf.pdfboxout.DOMUtil.findClosestEnclosingElementWithNodeName",
	"Comment": "helper function to find an enclosing element with given node name. returns null on failure.",
	"Method": "Element findClosestEnclosingElementWithNodeName(Node e,String nodeName){\r\n    Node parent;\r\n    while ((parent = e.getParentNode()) != null) {\r\n        if (parent.getNodeType() == Node.ELEMENT_NODE && parent.getNodeName().equals(nodeName)) {\r\n            return (Element) parent;\r\n        }\r\n        e = parent;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.lwjgl.input.Controllers.getEventButtonState",
	"Comment": "gets the state of the button that generated the current event",
	"Method": "boolean getEventButtonState(){\r\n    return event.getButtonState();\r\n}"
}, {
	"Path": "io.opencensus.contrib.monitoredresource.util.MonitoredResource.firstNonNull",
	"Comment": "returns the first of two given parameters that is not null, if either is, or otherwisethrows a nullpointerexception.",
	"Method": "T firstNonNull(T first,T second){\r\n    if (first != null) {\r\n        return first;\r\n    }\r\n    if (second != null) {\r\n        return second;\r\n    }\r\n    throw new NullPointerException(\"Both parameters are null\");\r\n}"
}, {
	"Path": "com.openhtmltopdf.java2d.api.Java2DRendererBuilder.runFirstPage",
	"Comment": "uselayoutgraphics and topageprocessor must have\tbeen called. also a document must have been set with one of the with methods. this will build the renderer and output the first page of the\tdocument to the specified page processor.",
	"Method": "void runFirstPage(){\r\n    Java2DRenderer renderer = this.buildJava2DRenderer();\r\n    renderer.layout();\r\n    if (state._pagingMode == Layer.PAGED_MODE_PRINT)\r\n        renderer.writePage(0);\r\n    else\r\n        renderer.writeSinglePage();\r\n}"
}, {
	"Path": "org.lwjgl.input.Mouse.setCursorPosition",
	"Comment": "set the position of the cursor. if the cursor is not grabbed,\tthe native cursor is moved to the new position.",
	"Method": "void setCursorPosition(int new_x,int new_y){\r\n    synchronized (OpenGLPackageAccess.global_lock) {\r\n        if (!isCreated())\r\n            throw new IllegalStateException(\"Mouse is not created\");\r\n        x = event_x = new_x;\r\n        y = event_y = new_y;\r\n        if (!isGrabbed() && (Cursor.getCapabilities() & Cursor.CURSOR_ONE_BIT_TRANSPARENCY) != 0) {\r\n            implementation.setCursorPosition(x, y);\r\n        } else {\r\n            grab_x = new_x;\r\n            grab_y = new_y;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.opengl.GLContext.setCapabilities",
	"Comment": "set the current capabilities instance. it contains the flags used\tto test for support of a particular extension.",
	"Method": "void setCapabilities(ContextCapabilities capabilities){\r\n    current_capabilities.set(capabilities);\r\n    CapabilitiesCacheEntry thread_cache_entry = thread_cache_entries.get();\r\n    if (thread_cache_entry == null) {\r\n        thread_cache_entry = new CapabilitiesCacheEntry();\r\n        thread_cache_entries.set(thread_cache_entry);\r\n    }\r\n    thread_cache_entry.owner = Thread.currentThread();\r\n    thread_cache_entry.capabilities = capabilities;\r\n    fast_path_cache = thread_cache_entry;\r\n}"
}, {
	"Path": "org.newdawn.slick.openal.SoundStore.getCurrentMusicVolume",
	"Comment": "get the volume scalar of the music that is currently playing.",
	"Method": "float getCurrentMusicVolume(){\r\n    return lastCurrentMusicVolume;\r\n}"
}, {
	"Path": "org.newdawn.slick.GameContainer.setPaused",
	"Comment": "indicates if the game should be paused, i.e. if updates\tshould be propogated through to the game.",
	"Method": "void setPaused(boolean paused){\r\n    this.paused = paused;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.render.FrameBufferCache.shutdown",
	"Comment": "clear the cache pool of framebuffers.\tif there were any previous framebuffers in the cache, delete them.\tthis is necessary for cases when the game gets restarted with a\tdifferent resolution without closing the process.",
	"Method": "void shutdown(){\r\n    FrameBufferCache fbcInstance = FrameBufferCache.getInstance();\r\n    for (Rendertarget target : fbcInstance.cache) {\r\n        target.destroyRTT();\r\n    }\r\n    fbcInstance.cache.clear();\r\n    fbcInstance.freeMap();\r\n}"
}, {
	"Path": "orestes.bloomfilter.cachesketch.ExpiringBloomFilterPureRedis.triggerExpirationHandling",
	"Comment": "triggers the expiration handling before the given delay is expired.",
	"Method": "void triggerExpirationHandling(long delay,TimeUnit unit){\r\n    if (!isEnabled)\r\n        return;\r\n    long delayInMilliseconds = MILLISECONDS.convert(delay, unit);\r\n    long currentDelay = job.getDelay(MILLISECONDS);\r\n    if (currentDelay > (delayInMilliseconds + MIN_JOB_DELAY)) {\r\n        scheduleJob(false, delay, unit);\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.newmatch.Selector.getElementStylingOrder",
	"Comment": "gets the elementstylingorder attribute of the selector class",
	"Method": "String getElementStylingOrder(){\r\n    return \"1\" + \"000\" + \"000\" + \"000\" + \"00000\";\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testRunningReplacedTransform",
	"Comment": "tests a replaced img with a transform as the running element.",
	"Method": "void testRunningReplacedTransform(){\r\n    assertTrue(vt.runTest(\"running-replaced-transform\"));\r\n}"
}, {
	"Path": "com.openhtmltopdf.bidi.ParagraphSplitter.lookupParagraph",
	"Comment": "get the paragraph object that a text node is associated with.should never return null.",
	"Method": "Paragraph lookupParagraph(Text node){\r\n    return paragraphs.isEmpty() ? allParagraphs.get(0) : paragraphs.get(node);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.DownloadNode.resultIconContains",
	"Comment": "returns true if the coordinates are within the bounds of the\tdownload result action icon at the given index.",
	"Method": "boolean resultIconContains(float cx,float cy,int index){\r\n    int iconWidth = GameImage.MUSIC_PLAY.getImage().getWidth();\r\n    float x = buttonBaseX + buttonWidth * 0.001f;\r\n    float y = buttonBaseY + (index * buttonOffset) + buttonHeight / 2f;\r\n    return ((cx > x && cx < x + iconWidth) && (cy > y - iconWidth / 2 && cy < y + iconWidth / 2));\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.GeneralUtil.dumpShortException",
	"Comment": "dumps an exception to the console, only the last 5 lines of the stacktrace.",
	"Method": "void dumpShortException(Exception ex){\r\n    String s = ex.getMessage();\r\n    if (s == null || s.trim().equals(\"null\")) {\r\n        s = \"{no ex. message}\";\r\n    }\r\n    System.out.println(s + \", \" + ex.getClass());\r\n    StackTraceElement[] stes = ex.getStackTrace();\r\n    for (int i = 0; i < stes.length && i < 5; i++) {\r\n        StackTraceElement ste = stes[i];\r\n        System.out.println(\"  \" + ste.getClassName() + \".\" + ste.getMethodName() + \"(ln \" + ste.getLineNumber() + \")\");\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.setBidiColoring",
	"Comment": "sets the bidi coloring mode.when true the bidi text displayalgorithm is applied to segments of text that are the samecolor.",
	"Method": "void setBidiColoring(boolean mode){\r\n    checkWidget();\r\n    bidiColoring = mode;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.OptionsOverlay.updateSliderOption",
	"Comment": "updates a slider option based on the current mouse coordinates.",
	"Method": "void updateSliderOption(int mouseX,int mouseY){\r\n    int min = hoverOption.getMinValue();\r\n    int max = hoverOption.getMaxValue();\r\n    int value = min + Math.round((float) (max - min) * (mouseX - sliderOptionStartX) / sliderOptionWidth);\r\n    hoverOption.setValue(Utils.clamp(value, min, max));\r\n}"
}, {
	"Path": "org.lwjgl.examples.spaceinvaders.ShotEntity.collidedWith",
	"Comment": "notification that this shot has collided with another\tentity",
	"Method": "void collidedWith(Entity other){\r\n    if (used) {\r\n        return;\r\n    }\r\n    if (other instanceof AlienEntity) {\r\n        game.removeEntity(this);\r\n        game.removeEntity(other);\r\n        game.notifyAlienKilled();\r\n        used = true;\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.layout.SharedContext.getMmPerDotParent",
	"Comment": "gets the dpi attribute in a more useful form of the renderingcontext object",
	"Method": "float getMmPerDotParent(){\r\n    return this.mmPerDot;\r\n}"
}, {
	"Path": "com.android.volley.toolbox.DiskBasedCache.initialize",
	"Comment": "initializes the diskbasedcache by scanning for all files currently in thespecified root directory. creates the root directory if necessary.",
	"Method": "void initialize(){\r\n    if (!mRootDirectory.exists()) {\r\n        if (!mRootDirectory.mkdirs()) {\r\n            VolleyLog.e(\"Unable to create cache dir %s\", mRootDirectory.getAbsolutePath());\r\n        }\r\n        return;\r\n    }\r\n    File[] files = mRootDirectory.listFiles();\r\n    if (files == null) {\r\n        return;\r\n    }\r\n    for (File file : files) {\r\n        BufferedInputStream fis = null;\r\n        try {\r\n            fis = new BufferedInputStream(new FileInputStream(file));\r\n            CacheHeader entry = CacheHeader.readHeader(fis);\r\n            entry.size = file.length();\r\n            putEntry(entry.key, entry);\r\n        } catch (IOException e) {\r\n            if (file != null) {\r\n                file.delete();\r\n            }\r\n        } finally {\r\n            try {\r\n                if (fis != null) {\r\n                    fis.close();\r\n                }\r\n            } catch (IOException ignored) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doDelete",
	"Comment": "deletes the next character. delete the selected text if any.",
	"Method": "void doDelete(){\r\n    Event event = new Event();\r\n    event.text = \"\";\r\n    if (selection.x != selection.y) {\r\n        event.start = selection.x;\r\n        event.end = selection.y;\r\n        sendKeyEvent(event);\r\n    } else if (caretOffset < content.getCharCount()) {\r\n        int line = content.getLineAtOffset(caretOffset);\r\n        int lineOffset = content.getOffsetAtLine(line);\r\n        int lineLength = content.getLine(line).length();\r\n        if (caretOffset == lineOffset + lineLength) {\r\n            event.start = caretOffset;\r\n            event.end = content.getOffsetAtLine(line + 1);\r\n        } else {\r\n            event.start = caretOffset;\r\n            event.end = getClusterNext(caretOffset, line);\r\n        }\r\n        sendKeyEvent(event);\r\n    }\r\n}"
}, {
	"Path": "uk.co.senab.photoview.PhotoViewAttacher.getDisplayRect",
	"Comment": "helper method that maps the supplied matrix to the current drawable",
	"Method": "RectF getDisplayRect(RectF getDisplayRect,Matrix matrix){\r\n    ImageView imageView = getImageView();\r\n    if (null != imageView) {\r\n        Drawable d = imageView.getDrawable();\r\n        if (null != d) {\r\n            mDisplayRect.set(0, 0, d.getIntrinsicWidth(), d.getIntrinsicHeight());\r\n            matrix.mapRect(mDisplayRect);\r\n            return mDisplayRect;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testTransformStaticNoPageMargin",
	"Comment": "with a static block, rotate, no page margin, no block margin or padding.",
	"Method": "void testTransformStaticNoPageMargin(){\r\n    assertTrue(vt.runTest(\"transform-static-no-page-margin\"));\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGLKHRFenceSync.eglClientWaitSyncKHR",
	"Comment": "blocks the calling thread until the specified sync object is\tsignaled, or until a specified timeout value expires.",
	"Method": "int eglClientWaitSyncKHR(EGLDisplay dpy,EGLSyncKHR sync,int flags,long timeout){\r\n    final int status = neglClientWaitSyncKHR(dpy.getPointer(), sync.getPointer(), flags, timeout);\r\n    if (status == EGL_FALSE)\r\n        throwEGLError(\"Failed to block on KHR fence sync object.\");\r\n    return status;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.BeatmapSet.matches",
	"Comment": "checks whether the beatmap set matches a given search query.",
	"Method": "boolean matches(String query,boolean matches,String type,String operator,float value){\r\n    for (Beatmap beatmap : beatmaps) {\r\n        float v;\r\n        switch(type) {\r\n            case \"ar\":\r\n                v = beatmap.approachRate;\r\n                break;\r\n            case \"cs\":\r\n                v = beatmap.circleSize;\r\n                break;\r\n            case \"od\":\r\n                v = beatmap.overallDifficulty;\r\n                break;\r\n            case \"hp\":\r\n                v = beatmap.HPDrainRate;\r\n                break;\r\n            case \"bpm\":\r\n                v = beatmap.bpmMax;\r\n                break;\r\n            case \"length\":\r\n                v = beatmap.endTime / 1000;\r\n                break;\r\n            case \"star\":\r\n            case \"stars\":\r\n                v = Math.round(beatmap.starRating * 100) / 100f;\r\n                break;\r\n            default:\r\n                return false;\r\n        }\r\n        boolean met;\r\n        switch(operator) {\r\n            case \"=\":\r\n            case \"==\":\r\n                met = (v == value);\r\n                break;\r\n            case \">\":\r\n                met = (v > value);\r\n                break;\r\n            case \">=\":\r\n                met = (v >= value);\r\n                break;\r\n            case \"<\":\r\n                met = (v < value);\r\n                break;\r\n            case \"<=\":\r\n                met = (v <= value);\r\n                break;\r\n            default:\r\n                return false;\r\n        }\r\n        if (met)\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "ddf.minim.ugens.Oscil.setAmplitude",
	"Comment": "sets the amplitude of this oscil. you might want to do this to change the\tamplitude of this oscil in response to a button press or something. for\tcontrolling amplitude continuously over time you will usually want to use\tthe amplitude input.",
	"Method": "void setAmplitude(float newAmp){\r\n    amplitude.setLastValue(newAmp);\r\n}"
}, {
	"Path": "com.j256.ormlite.field.FieldType.configDaoInformation",
	"Comment": "because we go recursive in a lot of situations if we construct daos inside of the fieldtype constructor, we have\tto do this 2nd pass initialization so we can better use the dao caches.",
	"Method": "void configDaoInformation(ConnectionSource connectionSource,Class<?> parentClass){\r\n    Class<?> fieldClass = field.getType();\r\n    DatabaseType databaseType = connectionSource.getDatabaseType();\r\n    TableInfo<?, ?> foreignTableInfo;\r\n    final FieldType foreignIdField;\r\n    final FieldType foreignRefField;\r\n    final FieldType foreignFieldType;\r\n    final BaseDaoImpl<?, ?> foreignDao;\r\n    final MappedQueryForFieldEq<Object, Object> mappedQueryForForeignField;\r\n    String foreignColumnName = fieldConfig.getForeignColumnName();\r\n    if (fieldConfig.isForeignAutoRefresh() || foreignColumnName != null) {\r\n        DatabaseTableConfig<?> tableConfig = fieldConfig.getForeignTableConfig();\r\n        if (tableConfig == null) {\r\n            foreignDao = (BaseDaoImpl<?, ?>) DaoManager.createDao(connectionSource, fieldClass);\r\n            foreignTableInfo = foreignDao.getTableInfo();\r\n        } else {\r\n            tableConfig.extractFieldTypes(connectionSource);\r\n            foreignDao = (BaseDaoImpl<?, ?>) DaoManager.createDao(connectionSource, tableConfig);\r\n            foreignTableInfo = foreignDao.getTableInfo();\r\n        }\r\n        foreignIdField = foreignTableInfo.getIdField();\r\n        if (foreignIdField == null) {\r\n            throw new IllegalArgumentException(\"Foreign field \" + fieldClass + \" does not have id field\");\r\n        }\r\n        if (foreignColumnName == null) {\r\n            foreignRefField = foreignIdField;\r\n        } else {\r\n            foreignRefField = foreignTableInfo.getFieldTypeByColumnName(foreignColumnName);\r\n            if (foreignRefField == null) {\r\n                throw new IllegalArgumentException(\"Foreign field \" + fieldClass + \" does not have field named '\" + foreignColumnName + \"'\");\r\n            }\r\n        }\r\n        @SuppressWarnings(\"unchecked\")\r\n        MappedQueryForFieldEq<Object, Object> castMappedQueryForForeignField = (MappedQueryForFieldEq<Object, Object>) MappedQueryForFieldEq.build(databaseType, foreignTableInfo, foreignRefField);\r\n        mappedQueryForForeignField = castMappedQueryForForeignField;\r\n        foreignFieldType = null;\r\n    } else if (fieldConfig.isForeign()) {\r\n        if (this.dataPersister != null && this.dataPersister.isPrimitive()) {\r\n            throw new IllegalArgumentException(\"Field \" + this + \" is a primitive class \" + fieldClass + \" but marked as foreign\");\r\n        }\r\n        DatabaseTableConfig<?> tableConfig = fieldConfig.getForeignTableConfig();\r\n        if (tableConfig != null) {\r\n            tableConfig.extractFieldTypes(connectionSource);\r\n            foreignDao = (BaseDaoImpl<?, ?>) DaoManager.createDao(connectionSource, tableConfig);\r\n        } else {\r\n            foreignDao = (BaseDaoImpl<?, ?>) DaoManager.createDao(connectionSource, fieldClass);\r\n        }\r\n        foreignTableInfo = foreignDao.getTableInfo();\r\n        foreignIdField = foreignTableInfo.getIdField();\r\n        if (foreignIdField == null) {\r\n            throw new IllegalArgumentException(\"Foreign field \" + fieldClass + \" does not have id field\");\r\n        }\r\n        foreignRefField = foreignIdField;\r\n        if (isForeignAutoCreate() && !foreignIdField.isGeneratedId()) {\r\n            throw new IllegalArgumentException(\"Field \" + field.getName() + \", if foreignAutoCreate = true then class \" + fieldClass.getSimpleName() + \" must have id field with generatedId = true\");\r\n        }\r\n        foreignFieldType = null;\r\n        mappedQueryForForeignField = null;\r\n    } else if (fieldConfig.isForeignCollection()) {\r\n        if (fieldClass != Collection.class && !ForeignCollection.class.isAssignableFrom(fieldClass)) {\r\n            throw new SQLException(\"Field class for '\" + field.getName() + \"' must be of class \" + ForeignCollection.class.getSimpleName() + \" or Collection.\");\r\n        }\r\n        Type type = field.getGenericType();\r\n        if (!(type instanceof ParameterizedType)) {\r\n            throw new SQLException(\"Field class for '\" + field.getName() + \"' must be a parameterized Collection.\");\r\n        }\r\n        Type[] genericArguments = ((ParameterizedType) type).getActualTypeArguments();\r\n        if (genericArguments.length == 0) {\r\n            throw new SQLException(\"Field class for '\" + field.getName() + \"' must be a parameterized Collection with at least 1 type.\");\r\n        }\r\n        if (genericArguments[0] instanceof TypeVariable) {\r\n            genericArguments = ((ParameterizedType) parentClass.getGenericSuperclass()).getActualTypeArguments();\r\n        }\r\n        if (!(genericArguments[0] instanceof Class)) {\r\n            throw new SQLException(\"Field class for '\" + field.getName() + \"' must be a parameterized Collection whose generic argument is an entity class not: \" + genericArguments[0]);\r\n        }\r\n        Class<?> collectionClazz = (Class<?>) genericArguments[0];\r\n        DatabaseTableConfig<?> tableConfig = fieldConfig.getForeignTableConfig();\r\n        BaseDaoImpl<Object, Object> foundDao;\r\n        if (tableConfig == null) {\r\n            @SuppressWarnings(\"unchecked\")\r\n            BaseDaoImpl<Object, Object> castDao = (BaseDaoImpl<Object, Object>) DaoManager.createDao(connectionSource, collectionClazz);\r\n            foundDao = castDao;\r\n        } else {\r\n            @SuppressWarnings(\"unchecked\")\r\n            BaseDaoImpl<Object, Object> castDao = (BaseDaoImpl<Object, Object>) DaoManager.createDao(connectionSource, tableConfig);\r\n            foundDao = castDao;\r\n        }\r\n        foreignDao = foundDao;\r\n        foreignFieldType = findForeignFieldType(collectionClazz, parentClass, (BaseDaoImpl<?, ?>) foundDao);\r\n        foreignIdField = null;\r\n        foreignRefField = null;\r\n        foreignTableInfo = null;\r\n        mappedQueryForForeignField = null;\r\n    } else {\r\n        foreignTableInfo = null;\r\n        foreignIdField = null;\r\n        foreignRefField = null;\r\n        foreignFieldType = null;\r\n        foreignDao = null;\r\n        mappedQueryForForeignField = null;\r\n    }\r\n    this.mappedQueryForForeignField = mappedQueryForForeignField;\r\n    this.foreignTableInfo = foreignTableInfo;\r\n    this.foreignFieldType = foreignFieldType;\r\n    this.foreignDao = foreignDao;\r\n    this.foreignIdField = foreignIdField;\r\n    this.foreignRefField = foreignRefField;\r\n    if (this.foreignRefField != null) {\r\n        assignDataType(databaseType, this.foreignRefField.getDataPersister());\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.user.UserButton.hoverUpdate",
	"Comment": "processes a hover action depending on whether or not the cursor\tis hovering over the button.",
	"Method": "void hoverUpdate(int delta,boolean isHover){\r\n    if (flashing) {\r\n        if (!bgAlpha.update(-delta / 2))\r\n            flashing = false;\r\n    } else {\r\n        int d = delta * (isHover ? 1 : -1);\r\n        bgAlpha.update(d);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.Utils.getTimeString",
	"Comment": "returns a formatted time string for a given number of seconds.",
	"Method": "String getTimeString(int seconds){\r\n    if (seconds < 60)\r\n        return (seconds == 1) ? \"1 second\" : String.format(\"%d seconds\", seconds);\r\n    else if (seconds < 3600)\r\n        return String.format(\"d:d\", seconds / 60, seconds % 60);\r\n    else\r\n        return String.format(\"d:d:d\", seconds / 3600, (seconds / 60) % 60, seconds % 60);\r\n}"
}, {
	"Path": "com.facebook.rebound.SpringConfig.fromOrigamiTensionAndFriction",
	"Comment": "a helper to make creating a springconfig easier with values mapping to the origami values.",
	"Method": "SpringConfig fromOrigamiTensionAndFriction(double qcTension,double qcFriction){\r\n    return new SpringConfig(OrigamiValueConverter.tensionFromOrigamiValue(qcTension), OrigamiValueConverter.frictionFromOrigamiValue(qcFriction));\r\n}"
}, {
	"Path": "org.lwjgl.PointerBuffer.newInstance",
	"Comment": "this method is used in slice and duplicate instead of normal object construction,\tso that subclasses can return themselves.",
	"Method": "PointerBuffer newInstance(ByteBuffer source,PointerBuffer newInstance,ByteBuffer source){\r\n    return new PointerBuffer(source);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.audio.MusicController.getDuration",
	"Comment": "returns the duration of the current track, in milliseconds.\tcurrently only works for mp3s.",
	"Method": "int getDuration(){\r\n    if (!trackExists() || lastBeatmap == null)\r\n        return -1;\r\n    if (duration == 0) {\r\n        if (lastBeatmap.audioFilename.getName().endsWith(\".mp3\")) {\r\n            try {\r\n                AudioFileFormat fileFormat = AudioSystem.getAudioFileFormat(lastBeatmap.audioFilename);\r\n                if (fileFormat instanceof TAudioFileFormat) {\r\n                    Map<?, ?> properties = ((TAudioFileFormat) fileFormat).properties();\r\n                    Long microseconds = (Long) properties.get(\"duration\");\r\n                    duration = (int) (microseconds / 1000);\r\n                    return duration;\r\n                }\r\n            } catch (UnsupportedAudioFileException | IOException e) {\r\n            }\r\n        }\r\n        duration = lastBeatmap.endTime;\r\n    }\r\n    return duration;\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testTransformFloat",
	"Comment": "with a floated static block, rotate, large page margin, small block margin, small padding, small border.",
	"Method": "void testTransformFloat(){\r\n    assertTrue(vt.runTest(\"transform-float\"));\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doWordPrevious",
	"Comment": "moves the caret to the start of the previous word.if a selection exists, move the caret to the start of the selectionand remove the selection.",
	"Method": "void doWordPrevious(){\r\n    if (selection.y - selection.x > 0) {\r\n        setCaretOffset(selection.x, SWT.DEFAULT);\r\n        showCaret();\r\n    } else {\r\n        doSelectionWordPrevious();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.reset",
	"Comment": "resets the caret position, selection and scroll offsets. recalculatethe content width and scroll bars. redraw the widget.",
	"Method": "void reset(){\r\n    ScrollBar verticalBar = getVerticalBar();\r\n    ScrollBar horizontalBar = getHorizontalBar();\r\n    setCaretOffset(0, SWT.DEFAULT);\r\n    topIndex = 0;\r\n    topIndexY = 0;\r\n    verticalScrollOffset = 0;\r\n    horizontalScrollOffset = 0;\r\n    resetSelection();\r\n    renderer.setContent(content);\r\n    if (verticalBar != null) {\r\n        verticalBar.setSelection(0);\r\n    }\r\n    if (horizontalBar != null) {\r\n        horizontalBar.setSelection(0);\r\n    }\r\n    resetCache(0, 0);\r\n    setCaretLocation();\r\n    super.redraw();\r\n}"
}, {
	"Path": "com.openhtmltopdf.layout.WhitespaceStripper.stripWhitespace",
	"Comment": "this function strips all whitespace from the text according to the css2.1 spec on whitespace handling. it accounts for the different whitespacesettings like normal, nowrap, pre, etc",
	"Method": "boolean stripWhitespace(InlineBox iB,boolean collapseLeading){\r\n    IdentValue whitespace = iB.getStyle().getIdent(CSSName.WHITE_SPACE);\r\n    String text = iB.getText();\r\n    text = collapseWhitespace(iB, whitespace, text, collapseLeading);\r\n    boolean collapseNext = (text.endsWith(SPACE) && (whitespace == IdentValue.NORMAL || whitespace == IdentValue.NOWRAP || whitespace == IdentValue.PRE));\r\n    iB.setText(text);\r\n    if (text.trim().equals(\"\")) {\r\n        if (whitespace == IdentValue.NORMAL || whitespace == IdentValue.NOWRAP) {\r\n            iB.setRemovableWhitespace(true);\r\n        } else if (whitespace == IdentValue.PRE) {\r\n            iB.setRemovableWhitespace(false);\r\n        } else if (text.indexOf(EOL) < 0) {\r\n            iB.setRemovableWhitespace(true);\r\n        }\r\n    }\r\n    return text.equals(\"\") ? collapseLeading : collapseNext;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.skins.SkinLoader.getSkinDirectories",
	"Comment": "returns a list of all subdirectories in the skins directory.",
	"Method": "File[] getSkinDirectories(File root){\r\n    ArrayList<File> dirs = new ArrayList<File>();\r\n    for (File dir : root.listFiles()) {\r\n        if (dir.isDirectory())\r\n            dirs.add(dir);\r\n    }\r\n    return dirs.toArray(new File[dirs.size()]);\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.onSizeChanged",
	"Comment": "on resize, preserve center and scale. various behaviours are possible, override this method to use another.",
	"Method": "void onSizeChanged(int w,int h,int oldw,int oldh){\r\n    if (readySent) {\r\n        setScaleAndCenter(getScale(), getCenter());\r\n    }\r\n}"
}, {
	"Path": "ddf.minim.ugens.GranulateRandom.sampleRateChanged",
	"Comment": "use this method to notify granulaterandom that the sample rate has changed.",
	"Method": "void sampleRateChanged(){\r\n    timeStep = 1.0f / sampleRate();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.db.BeatmapDB.updateLocalOffset",
	"Comment": "updates the local music offset for a beatmap in the database.",
	"Method": "void updateLocalOffset(Beatmap beatmap){\r\n    if (connection == null)\r\n        return;\r\n    try {\r\n        setLocalOffsetStmt.setInt(1, beatmap.localMusicOffset);\r\n        setLocalOffsetStmt.setString(2, beatmap.getFile().getParentFile().getName());\r\n        setLocalOffsetStmt.setString(3, beatmap.getFile().getName());\r\n        setLocalOffsetStmt.executeUpdate();\r\n    } catch (SQLException e) {\r\n        ErrorHandler.error(String.format(\"Failed to update local music offset for beatmap '%s' in database.\", beatmap.toString()), e, true);\r\n    }\r\n}"
}, {
	"Path": "sun.awt.X11.XKeysym.getKeypadKeysym",
	"Comment": "get a keypad keysym derived from a keycode. i do not check if this is a keypad event, i just presume it.",
	"Method": "long getKeypadKeysym(XKeyEvent ev){\r\n    int ndx = 0;\r\n    long keysym = XConstants.NoSymbol;\r\n    if (XToolkit.isXsunKPBehavior() && !XToolkit.isXKBenabled()) {\r\n        if ((ev.get_state() & XConstants.ShiftMask) != 0) {\r\n            ndx = 3;\r\n            keysym = xkeycode2keysym(ev, ndx);\r\n        } else {\r\n            ndx = 2;\r\n            keysym = xkeycode2keysym(ev, ndx);\r\n        }\r\n    } else {\r\n        if ((ev.get_state() & XConstants.ShiftMask) != 0 || ((ev.get_state() & XConstants.LockMask) != 0 && (XToolkit.modLockIsShiftLock != 0))) {\r\n            ndx = 0;\r\n            keysym = xkeycode2keysym(ev, ndx);\r\n        } else {\r\n            ndx = 1;\r\n            keysym = xkeycode2keysym(ev, ndx);\r\n        }\r\n    }\r\n    return keysym;\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.displaylist.DisplayListCollector.processPage",
	"Comment": "convert a list of boxes to a list of paint instructions for a page.",
	"Method": "void processPage(RenderingContext c,Layer layer,PageResult pg,DisplayListPageContainer dlPageList,boolean includeFloats,int pageNumber,int shadowPageNumber){\r\n    if (!pg.blocks().isEmpty()) {\r\n        Map<TableCellBox, List<CollapsedBorderSide>> collapsedTableBorders = pg.tcells().isEmpty() ? null : collectCollapsedTableBorders(c, pg.tcells());\r\n        DisplayListOperation dlo = new PaintBackgroundAndBorders(pg.blocks(), collapsedTableBorders);\r\n        dlPageList.addOp(dlo);\r\n    }\r\n    if (includeFloats) {\r\n        for (BlockBox floater : pg.floats()) {\r\n            collectFloatAsLayer(c, layer, floater, dlPageList, pageNumber, shadowPageNumber);\r\n        }\r\n    }\r\n    if (!pg.listItems().isEmpty()) {\r\n        DisplayListOperation dlo = new PaintListMarkers(pg.listItems());\r\n        dlPageList.addOp(dlo);\r\n    }\r\n    if (!pg.inlines().isEmpty()) {\r\n        DisplayListOperation dlo = new PaintInlineContent(pg.inlines());\r\n        dlPageList.addOp(dlo);\r\n    }\r\n    if (!pg.replaceds().isEmpty()) {\r\n        DisplayListOperation dlo = new PaintReplacedElements(pg.replaceds());\r\n        dlPageList.addOp(dlo);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ui.BackButton.contains",
	"Comment": "returns true if the coordinates are within the button bounds.",
	"Method": "boolean contains(float cx,float cy){\r\n    if (backButton != null)\r\n        return backButton.contains(cx, cy);\r\n    return buttonYpos - paddingY < cy && cx < realButtonWidth;\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.BlockBox.calcLayoutHeight",
	"Comment": "oh oh! up to this method height is used to track content height. after this method it is usedto track total layout height!",
	"Method": "void calcLayoutHeight(LayoutContext c,BorderPropertySet border,RectPropertySet margin,RectPropertySet padding){\r\n    setHeight(getHeight() + ((int) margin.top() + (int) border.top() + (int) padding.top() + (int) padding.bottom() + (int) border.bottom() + (int) margin.bottom()));\r\n    setChildrenHeight(getChildrenHeight() + ((int) margin.top() + (int) border.top() + (int) padding.top() + (int) padding.bottom() + (int) border.bottom() + (int) margin.bottom()));\r\n}"
}, {
	"Path": "com.android.volley.Request.getOriginUrl",
	"Comment": "returns the url of the request before any redirects have occurred.",
	"Method": "String getOriginUrl(){\r\n    return mUrl;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.objects.curves.Vec2f.midPoint",
	"Comment": "finds the midpoint between this vector and another vector.",
	"Method": "Vec2f midPoint(Vec2f o){\r\n    return new Vec2f((x + o.x) / 2, (y + o.y) / 2);\r\n}"
}, {
	"Path": "ddf.minim.analysis.BeatDetect.getDetectCenterFrequency",
	"Comment": "returns the center frequency of the ith frequency band.\tin sound energy mode this always returns 0.",
	"Method": "float getDetectCenterFrequency(int i){\r\n    if (algorithm == FREQ_ENERGY) {\r\n        return spect.getAverageCenterFrequency(i);\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.iwebpp.wspp.Receiver.expectHeader",
	"Comment": "waits for a certain amount of header bytes to be available, then fires a callback.",
	"Method": "void expectHeader(int length,PacketHandler handler){\r\n    debug(TAG, \"expectHeader, length:\" + length + \",handler:\" + handler);\r\n    if (length == 0) {\r\n        handler.onPacket(null);\r\n        return;\r\n    }\r\n    this.expectBuffer = (ByteBuffer) Util.chunkSlice(this.headerBuffer, this.expectOffset, this.expectOffset + length);\r\n    this.expectHandler = handler;\r\n    int toRead = length;\r\n    while (toRead > 0 && this.overflow.size() > 0) {\r\n        ByteBuffer fromOverflow = this.overflow.remove(this.overflow.size() - 1);\r\n        if (toRead < fromOverflow.capacity())\r\n            this.overflow.add((ByteBuffer) Util.chunkSlice(fromOverflow, toRead, fromOverflow.capacity()));\r\n        int read = Math.min(fromOverflow.capacity(), toRead);\r\n        BufferUtil.fastCopy(read, (ByteBuffer) fromOverflow, this.expectBuffer, this.expectOffset);\r\n        this.expectOffset += read;\r\n        toRead -= read;\r\n    }\r\n    debug(TAG, \"expectHeader, expectBuffer:\" + expectBuffer + \",expectOffset:\" + expectOffset);\r\n}"
}, {
	"Path": "io.opencensus.exporter.stats.prometheus.PrometheusExportUtils.createDescribableMetricFamilySamples",
	"Comment": "used only for prometheus metric registry, should not contain any actual samples.",
	"Method": "MetricFamilySamples createDescribableMetricFamilySamples(MetricDescriptor metricDescriptor){\r\n    String name = Collector.sanitizeMetricName(metricDescriptor.getName());\r\n    Type type = getType(metricDescriptor.getType());\r\n    List<String> labelNames = convertToLabelNames(metricDescriptor.getLabelKeys());\r\n    if (containsDisallowedLeLabelForHistogram(labelNames, type)) {\r\n        throw new IllegalStateException(\"Prometheus Histogram cannot have a label named 'le', \" + \"because it is a reserved label for bucket boundaries. \" + \"Please remove this key from your view.\");\r\n    }\r\n    if (containsDisallowedQuantileLabelForSummary(labelNames, type)) {\r\n        throw new IllegalStateException(\"Prometheus Summary cannot have a label named 'quantile', \" + \"because it is a reserved label. Please remove this key from your view.\");\r\n    }\r\n    return new MetricFamilySamples(name, type, metricDescriptor.getDescription(), Collections.<Sample>emptyList());\r\n}"
}, {
	"Path": "org.newdawn.slick.Music.pitchFade",
	"Comment": "fade the pitch and speed of this music to the pitch specified",
	"Method": "void pitchFade(int duration,float endPitch){\r\n    pitchStart = pitch;\r\n    pitchEnd = endPitch;\r\n    pitchDuration = duration;\r\n    pitchTime = duration;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.skins.Skin.isHitCircleOverlayAboveNumber",
	"Comment": "returns whether the hit circle overlay should be drawn above the combo number.",
	"Method": "boolean isHitCircleOverlayAboveNumber(){\r\n    return hitCircleOverlayAboveNumber;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ui.UI.drawTooltip",
	"Comment": "draws a tooltip, if any, near the current mouse coordinates,\tbounded by the container dimensions.",
	"Method": "void drawTooltip(Graphics g){\r\n    if (tooltipAlpha.getTime() == 0 || tooltip == null || tooltip.isEmpty())\r\n        return;\r\n    int containerWidth = container.getWidth(), containerHeight = container.getHeight();\r\n    int margin = containerWidth / 100, textMarginX = 2;\r\n    int offset = GameImage.CURSOR_MIDDLE.getImage().getWidth() / 2;\r\n    int lineHeight = Fonts.SMALL.getLineHeight();\r\n    int textWidth = textMarginX * 2, textHeight = lineHeight;\r\n    if (tooltipNewlines) {\r\n        String[] lines = tooltip.split(\"\\\\n\");\r\n        int maxWidth = Fonts.SMALL.getWidth(lines[0]);\r\n        for (int i = 1; i < lines.length; i++) {\r\n            int w = Fonts.SMALL.getWidth(lines[i]);\r\n            if (w > maxWidth)\r\n                maxWidth = w;\r\n        }\r\n        textWidth += maxWidth;\r\n        textHeight += lineHeight * (lines.length - 1);\r\n    } else\r\n        textWidth += Fonts.SMALL.getWidth(tooltip);\r\n    int x = input.getMouseX() + offset, y = input.getMouseY() + offset;\r\n    if (x + textWidth > containerWidth - margin)\r\n        x = containerWidth - margin - textWidth;\r\n    else if (x < margin)\r\n        x = margin;\r\n    if (y + textHeight > containerHeight - margin)\r\n        y = containerHeight - margin - textHeight;\r\n    else if (y < margin)\r\n        y = margin;\r\n    float alpha = tooltipAlpha.getValue();\r\n    float oldAlpha = Colors.BLACK_ALPHA.a;\r\n    Colors.BLACK_ALPHA.a = alpha;\r\n    g.setColor(Colors.BLACK_ALPHA);\r\n    Colors.BLACK_ALPHA.a = oldAlpha;\r\n    g.fillRect(x, y, textWidth, textHeight);\r\n    oldAlpha = Colors.DARK_GRAY.a;\r\n    Colors.DARK_GRAY.a = alpha;\r\n    g.setColor(Colors.DARK_GRAY);\r\n    g.setLineWidth(1);\r\n    g.drawRect(x, y, textWidth, textHeight);\r\n    Colors.DARK_GRAY.a = oldAlpha;\r\n    oldAlpha = Colors.WHITE_ALPHA.a;\r\n    Colors.WHITE_ALPHA.a = alpha;\r\n    Fonts.SMALL.drawString(x + textMarginX, y, tooltip, Colors.WHITE_ALPHA);\r\n    Colors.WHITE_ALPHA.a = oldAlpha;\r\n}"
}, {
	"Path": "ddf.minim.analysis.FourierTransform.getFreq",
	"Comment": "gets the amplitude of the requested frequency in the spectrum.",
	"Method": "float getFreq(float freq){\r\n    return getBand(freqToIndex(freq));\r\n}"
}, {
	"Path": "io.opencensus.benchmarks.trace.RecordTraceEventsBenchmark.addMessageEvent",
	"Comment": "this benchmark attempts to measure performance of adding a network event to the span.",
	"Method": "Span addMessageEvent(Data data){\r\n    data.span.addMessageEvent(io.opencensus.trace.MessageEvent.builder(Type.RECEIVED, 1).setUncompressedMessageSize(3).build());\r\n    return data.span;\r\n}"
}, {
	"Path": "com.facebook.rebound.BaseSpringSystem.registerSpring",
	"Comment": "registers a spring to this basespringsystem so it can be iterated if active.",
	"Method": "void registerSpring(Spring spring){\r\n    if (spring == null) {\r\n        throw new IllegalArgumentException(\"spring is required\");\r\n    }\r\n    if (mSpringRegistry.containsKey(spring.getId())) {\r\n        throw new IllegalArgumentException(\"spring is already registered\");\r\n    }\r\n    mSpringRegistry.put(spring.getId(), spring);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.handleTextChanged",
	"Comment": "updates the caret position and selection and the scroll bars to reflect the content change.",
	"Method": "void handleTextChanged(TextChangedEvent event){\r\n    int offset = ime.getCompositionOffset();\r\n    if (offset != -1 && lastTextChangeStart < offset) {\r\n        ime.setCompositionOffset(offset + lastTextChangeNewCharCount - lastTextChangeReplaceCharCount);\r\n    }\r\n    int firstLine = content.getLineAtOffset(lastTextChangeStart);\r\n    resetCache(firstLine, 0);\r\n    if (!isFixedLineHeight() && topIndex > firstLine) {\r\n        topIndex = firstLine;\r\n        topIndexY = 0;\r\n        super.redraw();\r\n    } else {\r\n        int lastLine = firstLine + lastTextChangeNewLineCount;\r\n        int firstLineTop = getLinePixel(firstLine);\r\n        int newLastLineBottom = getLinePixel(lastLine + 1);\r\n        if (lastLineBottom != newLastLineBottom) {\r\n            super.redraw();\r\n        } else {\r\n            super.redraw(0, firstLineTop, clientAreaWidth, newLastLineBottom - firstLineTop, false);\r\n            redrawLinesBullet(renderer.redrawLines);\r\n        }\r\n    }\r\n    renderer.redrawLines = null;\r\n    if (!(blockSelection && blockXLocation != -1)) {\r\n        updateSelection(lastTextChangeStart, lastTextChangeReplaceCharCount, lastTextChangeNewCharCount);\r\n    }\r\n    if (lastTextChangeReplaceLineCount > 0 || wordWrap) {\r\n        claimBottomFreeSpace();\r\n    }\r\n    if (lastTextChangeReplaceCharCount > 0) {\r\n        claimRightFreeSpace();\r\n    }\r\n    sendAccessibleTextChanged(lastTextChangeStart, lastTextChangeNewCharCount, 0);\r\n    lastCharCount += lastTextChangeNewCharCount;\r\n    lastCharCount -= lastTextChangeReplaceCharCount;\r\n    setAlignment();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.GameData.calculateDifficultyMultiplier",
	"Comment": "computes and stores the difficulty multiplier used in the score formula.",
	"Method": "void calculateDifficultyMultiplier(float drainRate,float circleSize,float overallDifficulty){\r\n    float sum = drainRate + circleSize + overallDifficulty;\r\n    if (sum <= 5f)\r\n        difficultyMultiplier = 2;\r\n    else if (sum <= 12f)\r\n        difficultyMultiplier = 3;\r\n    else if (sum <= 17f)\r\n        difficultyMultiplier = 4;\r\n    else if (sum <= 24f)\r\n        difficultyMultiplier = 5;\r\n    else\r\n        difficultyMultiplier = 6;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.AWTGLCanvas.destroy",
	"Comment": "destroy the opengl context. this happens when the component becomes undisplayable",
	"Method": "void destroy(){\r\n    synchronized (SYNC_LOCK) {\r\n        try {\r\n            if (context != null) {\r\n                context.forceDestroy();\r\n                context = null;\r\n                reentry_count = 0;\r\n                peer_info.destroy();\r\n                peer_info = null;\r\n            }\r\n        } catch (LWJGLException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.handleKeyDown",
	"Comment": "if a verifykey listener exists, verify that the key that was enteredshould be processed.",
	"Method": "void handleKeyDown(Event event){\r\n    if (clipboardSelection == null) {\r\n        clipboardSelection = new Point(selection.x, selection.y);\r\n    }\r\n    newOrientation = SWT.NONE;\r\n    event.stateMask &= SWT.MODIFIER_MASK;\r\n    Event verifyEvent = new Event();\r\n    verifyEvent.character = event.character;\r\n    verifyEvent.keyCode = event.keyCode;\r\n    verifyEvent.keyLocation = event.keyLocation;\r\n    verifyEvent.stateMask = event.stateMask;\r\n    verifyEvent.doit = true;\r\n    notifyListeners(ST.VerifyKey, verifyEvent);\r\n    if (verifyEvent.doit) {\r\n        if ((event.stateMask & SWT.MODIFIER_MASK) == SWT.CTRL && event.keyCode == SWT.SHIFT && isBidiCaret()) {\r\n            newOrientation = event.keyLocation == SWT.LEFT ? SWT.LEFT_TO_RIGHT : SWT.RIGHT_TO_LEFT;\r\n        }\r\n        handleKey(event);\r\n    }\r\n}"
}, {
	"Path": "me.imid.swipebacklayout.lib.SwipeBackLayout.setEdgeSize",
	"Comment": "set the size of an edge. this is the range in pixels along the edges of\tthis view that will actively detect edge touches or drags if edge\ttracking is enabled.",
	"Method": "void setEdgeSize(int size){\r\n    mDragHelper.setEdgeSize(size);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.objects.Spinner.init",
	"Comment": "initializes the spinner data type with images and dimensions.",
	"Method": "void init(GameContainer container,float difficulty){\r\n    width = container.getWidth();\r\n    height = container.getHeight();\r\n    overallDifficulty = difficulty;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.Pbuffer.isBufferLost",
	"Comment": "method to test for validity of the buffer. if this function returns true, the buffer contents is lost. the buffer can still\tbe used, but the results are undefined. the application is expected to release the buffer if needed, destroy it and recreate\ta new buffer.",
	"Method": "boolean isBufferLost(){\r\n    checkDestroyed();\r\n    return Display.getImplementation().isBufferLost(peer_info);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.render.CurveRenderState.init",
	"Comment": "set the width and height of the container that curves get drawn into.\tshould be called before any curves are drawn.",
	"Method": "void init(int width,int height,float circleDiameter){\r\n    containerWidth = width;\r\n    containerHeight = height;\r\n    scale = (int) (circleDiameter * HitObject.getXMultiplier());\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getOffsetAtLine",
	"Comment": "returns the character offset of the first character of the given line.",
	"Method": "int getOffsetAtLine(int lineIndex){\r\n    checkWidget();\r\n    if (lineIndex < 0 || (lineIndex > 0 && lineIndex >= content.getLineCount())) {\r\n        SWT.error(SWT.ERROR_INVALID_RANGE);\r\n    }\r\n    return content.getOffsetAtLine(lineIndex);\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testTransformAbsolute",
	"Comment": "with an absolute block, rotate, large page margin, small block margin, small padding, small border.",
	"Method": "void testTransformAbsolute(){\r\n    assertTrue(vt.runTest(\"transform-absolute\"));\r\n}"
}, {
	"Path": "com.j256.ormlite.dao.EagerForeignCollection.hashCode",
	"Comment": "this is just a call to the hashcode method of the internal results list.",
	"Method": "int hashCode(){\r\n    return results.hashCode();\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualtest.VisualTester.calcCombinedIntensity",
	"Comment": "calculate the combined intensity of a pixel and normalizes it to a value of at most 255.",
	"Method": "int calcCombinedIntensity(int element){\r\n    final Color color = new Color(element);\r\n    return Math.min(255, (color.getRed() + color.getGreen() + color.getRed()) / 3);\r\n}"
}, {
	"Path": "com.openhtmltopdf.java2d.Java2DTextRenderer.getGlyphVector",
	"Comment": "this method gets a glyph vector for purposes of selecting text. we are not too worried about selecting textat this point so we just use the first font available.",
	"Method": "FSGlyphVector getGlyphVector(OutputDevice outputDevice,FSFont font,String text){\r\n    Object aaHint = null;\r\n    Object fracHint = null;\r\n    Graphics2D graphics = ((Java2DOutputDevice) outputDevice).getGraphics();\r\n    Font awtFont = ((AWTFSFont) font).getAWTFonts().get(0);\r\n    if (awtFont.getSize() > threshold) {\r\n        aaHint = graphics.getRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING);\r\n        graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, antiAliasRenderingHint);\r\n    }\r\n    fracHint = graphics.getRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS);\r\n    graphics.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, fractionalFontMetricsHint);\r\n    GlyphVector vector = awtFont.createGlyphVector(graphics.getFontRenderContext(), text);\r\n    if (awtFont.getSize() > threshold) {\r\n        graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, aaHint);\r\n    }\r\n    graphics.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, fracHint);\r\n    return new AWTFSGlyphVector(vector);\r\n}"
}, {
	"Path": "com.nbsp.materialfilepicker.MaterialFilePicker.withSupportFragment",
	"Comment": "specifies support fragment which will be used tostart file picker",
	"Method": "MaterialFilePicker withSupportFragment(android.support.v4.app.Fragment fragment){\r\n    if (mActivity != null || mFragment != null) {\r\n        throw new RuntimeException(\"You must pass either Activity, Fragment or SupportFragment\");\r\n    }\r\n    mSupportFragment = fragment;\r\n    return this;\r\n}"
}, {
	"Path": "ddf.minim.ugens.FilePlayer.close",
	"Comment": "calling close will close the audiorecordingstream that this wraps, \twhich is proper cleanup for using the stream.",
	"Method": "void close(){\r\n    mFileStream.close();\r\n}"
}, {
	"Path": "com.j256.ormlite.stmt.mapped.MappedRefresh.executeRefresh",
	"Comment": "execute our refresh query statement and then update all of the fields in data with the fields from the result.",
	"Method": "int executeRefresh(DatabaseConnection databaseConnection,T data,ObjectCache objectCache){\r\n    @SuppressWarnings(\"unchecked\")\r\n    ID id = (ID) idField.extractJavaFieldValue(data);\r\n    T result = super.execute(databaseConnection, id, null);\r\n    if (result == null) {\r\n        return 0;\r\n    }\r\n    for (FieldType fieldType : resultsFieldTypes) {\r\n        if (fieldType != idField) {\r\n            fieldType.assignField(data, fieldType.extractJavaFieldValue(result), false, objectCache);\r\n        }\r\n    }\r\n    return 1;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.Display.setTitle",
	"Comment": "set the title of the window. this may be ignored by the underlying os.",
	"Method": "void setTitle(String newTitle){\r\n    synchronized (GlobalLock.lock) {\r\n        if (newTitle == null) {\r\n            newTitle = \"\";\r\n        }\r\n        title = newTitle;\r\n        if (isCreated())\r\n            display_impl.setTitle(title);\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Vector3f.normalise",
	"Comment": "normalise this vector and place the result in another vector.",
	"Method": "Vector3f normalise(Vector3f dest){\r\n    float l = length();\r\n    if (dest == null)\r\n        dest = new Vector3f(x / l, y / l, z / l);\r\n    else\r\n        dest.set(x / l, y / l, z / l);\r\n    return dest;\r\n}"
}, {
	"Path": "com.facebook.rebound.SpringLooper.setSpringSystem",
	"Comment": "set the basespringsystem that the springlooper will call back to.",
	"Method": "void setSpringSystem(BaseSpringSystem springSystem){\r\n    mSpringSystem = springSystem;\r\n}"
}, {
	"Path": "com.android.volley.CacheDispatcherTest.cacheMiss",
	"Comment": "a cache miss does not post a response and puts the request on the network queue.",
	"Method": "void cacheMiss(){\r\n    mCacheQueue.add(mRequest);\r\n    mCacheQueue.waitUntilEmpty(TIMEOUT_MILLIS);\r\n    assertFalse(mDelivery.wasEitherResponseCalled());\r\n    assertTrue(mNetworkQueue.size() > 0);\r\n    Request request = mNetworkQueue.take();\r\n    assertNull(request.getCacheEntry());\r\n}"
}, {
	"Path": "org.lwjgl.opencl.CLProgram.getInfoDevices",
	"Comment": "returns an array of cldevices associated with this program.",
	"Method": "CLDevice[] getInfoDevices(CLDevice[] getInfoDevices,CLProgram program){\r\n    return util.getInfoDevices(this);\r\n}"
}, {
	"Path": "org.lwjgl.test.openal.EFX10Test.efxUtilTest",
	"Comment": "checks openal for every efx 1.0 effect and filter and prints the result to the console.",
	"Method": "void efxUtilTest(){\r\n    setupEfx();\r\n    System.out.println();\r\n    System.out.println(\"Checking supported effects ...\");\r\n    if (EFXUtil.isEffectSupported(EFX10.AL_EFFECT_NULL)) {\r\n        System.out.println(\"AL_EFFECT_NULL is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_EFFECT_NULL is NOT supported.\");\r\n    }\r\n    if (EFXUtil.isEffectSupported(EFX10.AL_EFFECT_EAXREVERB)) {\r\n        System.out.println(\"AL_EFFECT_EAXREVERB is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_EFFECT_EAXREVERB is NOT supported.\");\r\n    }\r\n    if (EFXUtil.isEffectSupported(EFX10.AL_EFFECT_REVERB)) {\r\n        System.out.println(\"AL_EFFECT_REVERB is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_EFFECT_REVERB is NOT supported.\");\r\n    }\r\n    if (EFXUtil.isEffectSupported(EFX10.AL_EFFECT_CHORUS)) {\r\n        System.out.println(\"AL_EFFECT_CHORUS is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_EFFECT_CHORUS is NOT supported.\");\r\n    }\r\n    if (EFXUtil.isEffectSupported(EFX10.AL_EFFECT_DISTORTION)) {\r\n        System.out.println(\"AL_EFFECT_DISTORTION is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_EFFECT_DISTORTION is NOT supported.\");\r\n    }\r\n    if (EFXUtil.isEffectSupported(EFX10.AL_EFFECT_ECHO)) {\r\n        System.out.println(\"AL_EFFECT_ECHO is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_EFFECT_ECHO is NOT supported.\");\r\n    }\r\n    if (EFXUtil.isEffectSupported(EFX10.AL_EFFECT_FLANGER)) {\r\n        System.out.println(\"AL_EFFECT_FLANGER is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_EFFECT_FLANGER is NOT supported.\");\r\n    }\r\n    if (EFXUtil.isEffectSupported(EFX10.AL_EFFECT_FREQUENCY_SHIFTER)) {\r\n        System.out.println(\"AL_EFFECT_FREQUENCY_SHIFTER is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_EFFECT_FREQUENCY_SHIFTER is NOT supported.\");\r\n    }\r\n    if (EFXUtil.isEffectSupported(EFX10.AL_EFFECT_VOCAL_MORPHER)) {\r\n        System.out.println(\"AL_EFFECT_VOCAL_MORPHER is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_EFFECT_VOCAL_MORPHER is NOT supported.\");\r\n    }\r\n    if (EFXUtil.isEffectSupported(EFX10.AL_EFFECT_PITCH_SHIFTER)) {\r\n        System.out.println(\"AL_EFFECT_PITCH_SHIFTER is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_EFFECT_PITCH_SHIFTER is NOT supported.\");\r\n    }\r\n    if (EFXUtil.isEffectSupported(EFX10.AL_EFFECT_RING_MODULATOR)) {\r\n        System.out.println(\"AL_EFFECT_RING_MODULATOR is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_EFFECT_RING_MODULATOR is NOT supported.\");\r\n    }\r\n    if (EFXUtil.isEffectSupported(EFX10.AL_EFFECT_AUTOWAH)) {\r\n        System.out.println(\"AL_EFFECT_AUTOWAH is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_EFFECT_AUTOWAH is NOT supported.\");\r\n    }\r\n    if (EFXUtil.isEffectSupported(EFX10.AL_EFFECT_COMPRESSOR)) {\r\n        System.out.println(\"AL_EFFECT_COMPRESSOR is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_EFFECT_COMPRESSOR is NOT supported.\");\r\n    }\r\n    if (EFXUtil.isEffectSupported(EFX10.AL_EFFECT_EQUALIZER)) {\r\n        System.out.println(\"AL_EFFECT_EQUALIZER is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_EFFECT_EQUALIZER is NOT supported.\");\r\n    }\r\n    System.out.println();\r\n    System.out.println(\"Checking supported filters ...\");\r\n    if (EFXUtil.isFilterSupported(EFX10.AL_FILTER_NULL)) {\r\n        System.out.println(\"AL_FILTER_NULL is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_FILTER_NULL is NOT supported.\");\r\n    }\r\n    if (EFXUtil.isFilterSupported(EFX10.AL_FILTER_LOWPASS)) {\r\n        System.out.println(\"AL_FILTER_LOWPASS is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_FILTER_LOWPASS is NOT supported.\");\r\n    }\r\n    if (EFXUtil.isFilterSupported(EFX10.AL_FILTER_HIGHPASS)) {\r\n        System.out.println(\"AL_FILTER_HIGHPASS is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_FILTER_HIGHPASS is NOT supported.\");\r\n    }\r\n    if (EFXUtil.isFilterSupported(EFX10.AL_FILTER_BANDPASS)) {\r\n        System.out.println(\"AL_FILTER_BANDPASS is supported.\");\r\n    } else {\r\n        System.out.println(\"AL_FILTER_BANDPASS is NOT supported.\");\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.checkStyle",
	"Comment": "hides the scroll bars if widget is created in single line mode.",
	"Method": "int checkStyle(int style){\r\n    if ((style & SWT.SINGLE) != 0) {\r\n        style &= ~(SWT.H_SCROLL | SWT.V_SCROLL | SWT.WRAP | SWT.MULTI);\r\n    } else {\r\n        style |= SWT.MULTI;\r\n        if ((style & SWT.WRAP) != 0) {\r\n            style &= ~SWT.H_SCROLL;\r\n        }\r\n    }\r\n    style |= SWT.NO_REDRAW_RESIZE | SWT.DOUBLE_BUFFERED | SWT.NO_BACKGROUND;\r\n    return style & ~SWT.CENTER;\r\n}"
}, {
	"Path": "org.lwjgl.examples.spaceinvaders.GameApplet.init",
	"Comment": "initialise applet by adding a canvas to it, this canvas will start the lwjgl display and game loop\tin another thread. it will also stop the game loop and destroy the display on canvas removal when\tapplet is destroyed.",
	"Method": "void init(){\r\n    setLayout(new BorderLayout());\r\n    try {\r\n        display_parent = new Canvas() {\r\n            public void addNotify() {\r\n                super.addNotify();\r\n                startLWJGL();\r\n            }\r\n            public void removeNotify() {\r\n                stopLWJGL();\r\n                super.removeNotify();\r\n            }\r\n        };\r\n        display_parent.setSize(getWidth(), getHeight());\r\n        add(display_parent);\r\n        display_parent.setFocusable(true);\r\n        display_parent.requestFocus();\r\n        display_parent.setIgnoreRepaint(true);\r\n        setVisible(true);\r\n    } catch (Exception e) {\r\n        System.err.println(e);\r\n        throw new RuntimeException(\"Unable to create display\");\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.examples.spaceinvaders.GameApplet.init",
	"Comment": "initialise applet by adding a canvas to it, this canvas will start the lwjgl display and game loop\tin another thread. it will also stop the game loop and destroy the display on canvas removal when\tapplet is destroyed.",
	"Method": "void init(){\r\n    super.addNotify();\r\n    startLWJGL();\r\n}"
}, {
	"Path": "org.lwjgl.examples.spaceinvaders.GameApplet.init",
	"Comment": "initialise applet by adding a canvas to it, this canvas will start the lwjgl display and game loop\tin another thread. it will also stop the game loop and destroy the display on canvas removal when\tapplet is destroyed.",
	"Method": "void init(){\r\n    stopLWJGL();\r\n    super.removeNotify();\r\n}"
}, {
	"Path": "io.opencensus.contrib.http.HttpServerHandler.handleEnd",
	"Comment": "close an http span.this method will set status of the span and end it.",
	"Method": "void handleEnd(Span span,P response,Throwable error){\r\n    spanEnd(span, response, error);\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.Configuration.logAfterLoad",
	"Comment": "writes a log of loaded properties to the plumbing.init logger.",
	"Method": "void logAfterLoad(){\r\n    Enumeration elem = properties.keys();\r\n    List lp = Collections.list(elem);\r\n    Collections.sort(lp);\r\n    Iterator iter = lp.iterator();\r\n    finer(\"Configuration contains \" + properties.size() + \" keys.\");\r\n    finer(\"List of configuration properties, after override:\");\r\n    while (iter.hasNext()) {\r\n        String key = (String) iter.next();\r\n        String val = properties.getProperty(key);\r\n        finer(\"  \" + key + \" = \" + val);\r\n    }\r\n    finer(\"Properties list complete.\");\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.displaylist.PagedBoxCollector.findAdjustedBoundsForContentBox",
	"Comment": "finds the document coordinates content box bounds of a box adjusted for transform and clipped according to overflow hidden.",
	"Method": "Rectangle findAdjustedBoundsForContentBox(CssContext c,Box container){\r\n    Rectangle bounds = container.getContentAreaEdge(container.getAbsX(), container.getAbsY(), c);\r\n    AffineTransform transform = container.getContainingLayer().getCurrentTransformMatrix();\r\n    Area overflowClip = container.getAbsoluteClipBox(c);\r\n    transformBounds(bounds, transform);\r\n    bounds = applyOverflowClip(bounds, overflowClip);\r\n    return bounds;\r\n}"
}, {
	"Path": "org.newdawn.slick.Input.consumeEvent",
	"Comment": "notification from an event handle that an event has been consumed",
	"Method": "void consumeEvent(){\r\n    consumed = true;\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.setDebug",
	"Comment": "enables visual debugging, showing bitmap and state details.",
	"Method": "void setDebug(boolean debug){\r\n    this.debug = debug;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ui.Cursor.update",
	"Comment": "rotates the cursor by a degree determined by a delta interval.\tif the old style cursor is being used, this will do nothing.",
	"Method": "void update(int delta){\r\n    cursorAngle += delta / 40f;\r\n    cursorAngle %= 360;\r\n}"
}, {
	"Path": "com.openhtmltopdf.simple.extend.XhtmlCssOnlyNamespaceHandler.getClass",
	"Comment": "gets the class attribute of the xhtmlnamespacehandler object",
	"Method": "String getClass(org.w3c.dom.Element e){\r\n    return e.getAttribute(\"class\");\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ui.MenuButton.setHoverRadius",
	"Comment": "set x and y radius of the button based on current scale factor\tand expansion direction.",
	"Method": "void setHoverRadius(){\r\n    Image image = this.img;\r\n    if (image == null)\r\n        image = anim.getCurrentFrame();\r\n    int xOffset = 0, yOffset = 0;\r\n    float currentScale = scale.getValue();\r\n    if (dir != Expand.CENTER) {\r\n        xOffset = (int) ((currentScale - 1f) * image.getWidth());\r\n        yOffset = (int) ((currentScale - 1f) * image.getHeight());\r\n        if (dir == Expand.UP || dir == Expand.DOWN)\r\n            xOffset = 0;\r\n        if (dir == Expand.RIGHT || dir == Expand.LEFT)\r\n            yOffset = 0;\r\n        if (dir == Expand.RIGHT || dir == Expand.DOWN_RIGHT || dir == Expand.UP_RIGHT)\r\n            xOffset *= -1;\r\n        if (dir == Expand.DOWN || dir == Expand.DOWN_LEFT || dir == Expand.DOWN_RIGHT)\r\n            yOffset *= -1;\r\n    }\r\n    this.xRadius = ((image.getWidth() * currentScale) + xOffset) / 2f;\r\n    this.yRadius = ((image.getHeight() * currentScale) + yOffset) / 2f;\r\n}"
}, {
	"Path": "com.openhtmltopdf.pdfboxout.PdfBoxForm.createCheckboxAppearance",
	"Comment": "creates a checkbox appearance stream. uses an ordinal of the zapf dingbats font for the check mark.",
	"Method": "PDAppearanceStream createCheckboxAppearance(CheckboxStyle style,PDDocument doc,PDResources resources,PDAppearanceStream createCheckboxAppearance,String appear,PDDocument doc,PDResources resources){\r\n    PDAppearanceStream s = new PDAppearanceStream(doc);\r\n    s.setBBox(new PDRectangle(100f, 100f));\r\n    OutputStream os = null;\r\n    try {\r\n        os = s.getContentStream().createOutputStream();\r\n        os.write(appear.getBytes(\"ASCII\"));\r\n    } catch (IOException e) {\r\n        throw new PdfContentStreamAdapter.PdfException(\"createCheckboxAppearance\", e);\r\n    } finally {\r\n        try {\r\n            if (os != null)\r\n                os.close();\r\n        } catch (IOException e) {\r\n        }\r\n    }\r\n    s.setResources(resources);\r\n    return s;\r\n}"
}, {
	"Path": "org.lwjgl.input.Cursor.createCursors",
	"Comment": "creates the actual cursor, using a platform specific class",
	"Method": "CursorElement[] createCursors(int width,int height,int xHotspot,int yHotspot,int numImages,IntBuffer images,IntBuffer delays){\r\n    IntBuffer images_copy = BufferUtils.createIntBuffer(images.remaining());\r\n    flipImages(width, height, numImages, images, images_copy);\r\n    CursorElement[] cursors;\r\n    switch(LWJGLUtil.getPlatform()) {\r\n        case LWJGLUtil.PLATFORM_MACOSX:\r\n            convertARGBtoABGR(images_copy);\r\n            cursors = new CursorElement[numImages];\r\n            for (int i = 0; i < numImages; i++) {\r\n                Object handle = Mouse.getImplementation().createCursor(width, height, xHotspot, yHotspot, 1, images_copy, null);\r\n                long delay = (delays != null) ? delays.get(i) : 0;\r\n                long timeout = System.currentTimeMillis();\r\n                cursors[i] = new CursorElement(handle, delay, timeout);\r\n                images_copy.position(width * height * (i + 1));\r\n            }\r\n            break;\r\n        case LWJGLUtil.PLATFORM_WINDOWS:\r\n            cursors = new CursorElement[numImages];\r\n            for (int i = 0; i < numImages; i++) {\r\n                int size = width * height;\r\n                for (int j = 0; j < size; j++) {\r\n                    int index = j + (i * size);\r\n                    int alpha = images_copy.get(index) >> 24 & 0xff;\r\n                    if (alpha != 0xff) {\r\n                        images_copy.put(index, 0);\r\n                    }\r\n                }\r\n                Object handle = Mouse.getImplementation().createCursor(width, height, xHotspot, yHotspot, 1, images_copy, null);\r\n                long delay = (delays != null) ? delays.get(i) : 0;\r\n                long timeout = System.currentTimeMillis();\r\n                cursors[i] = new CursorElement(handle, delay, timeout);\r\n                images_copy.position(width * height * (i + 1));\r\n            }\r\n            break;\r\n        case LWJGLUtil.PLATFORM_LINUX:\r\n            Object handle = Mouse.getImplementation().createCursor(width, height, xHotspot, yHotspot, numImages, images_copy, delays);\r\n            CursorElement cursor_element = new CursorElement(handle, -1, -1);\r\n            cursors = new CursorElement[] { cursor_element };\r\n            break;\r\n        default:\r\n            throw new RuntimeException(\"Unknown OS\");\r\n    }\r\n    return cursors;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.claimRightFreeSpace",
	"Comment": "scrolls text to the right to use new space made available by a resize.",
	"Method": "void claimRightFreeSpace(){\r\n    int newHorizontalOffset = Math.max(0, renderer.getWidth() - clientAreaWidth);\r\n    if (newHorizontalOffset < horizontalScrollOffset) {\r\n        scrollHorizontal(newHorizontalOffset - horizontalScrollOffset, true);\r\n    }\r\n}"
}, {
	"Path": "com.android.volley.toolbox.ByteArrayPool.getBuf",
	"Comment": "returns a buffer from the pool if one is available in the requested size, or allocates a newone if a pooled one is not available.",
	"Method": "byte[] getBuf(int len){\r\n    for (int i = 0; i < mBuffersBySize.size(); i++) {\r\n        byte[] buf = mBuffersBySize.get(i);\r\n        if (buf.length >= len) {\r\n            mCurrentSize -= buf.length;\r\n            mBuffersBySize.remove(i);\r\n            mBuffersByLastUse.remove(buf);\r\n            return buf;\r\n        }\r\n    }\r\n    return new byte[len];\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.Beatmap.getSliderBorderColor",
	"Comment": "returns the slider border color.\tif the beatmap does not provide a color, the skin color will be returned instead.",
	"Method": "Color getSliderBorderColor(){\r\n    return (sliderBorder != null) ? sliderBorder : Options.getSkin().getSliderBorderColor();\r\n}"
}, {
	"Path": "com.openhtmltopdf.java2d.api.Java2DRendererBuilder.useInitialPageNumber",
	"Comment": "used to set an initial page number for use with page counters, etc.",
	"Method": "Java2DRendererBuilder useInitialPageNumber(int pageNumberInitial){\r\n    state._initialPageNumber = pageNumberInitial;\r\n    return this;\r\n}"
}, {
	"Path": "io.opencensus.exporter.trace.ocagent.FakeOcAgentTraceServiceGrpcImpl.setUpdatedLibraryConfig",
	"Comment": "sets the updatedlibraryconfig that will be passed to client.",
	"Method": "void setUpdatedLibraryConfig(UpdatedLibraryConfig updatedLibraryConfig){\r\n    this.updatedLibraryConfig = updatedLibraryConfig;\r\n}"
}, {
	"Path": "ddf.minim.Controller.isShiftingGain",
	"Comment": "returns true if the gain is currently shifting.if no gain control is available this method returns false.",
	"Method": "boolean isShiftingGain(){\r\n    return gshift;\r\n}"
}, {
	"Path": "ddf.minim.AudioSource.getFormat",
	"Comment": "returns an audioformat object that describes the audio properties \tof this sound generating object. this is often useful information \twhen doing sound analysis or some synthesis, but typically you\twill not need to know about the specific format.",
	"Method": "AudioFormat getFormat(){\r\n    return stream.getFormat();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.video.FFmpeg.setNativeDir",
	"Comment": "sets the directory in which to look for the ffmpeg shared library.",
	"Method": "void setNativeDir(File dir){\r\n    FFMPEG_PATH = new File(dir, DEFAULT_NATIVE_FILENAME);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.objects.curves.Curve.getX",
	"Comment": "returns the scaled x coordinate of the control point at index i.",
	"Method": "float getX(int i){\r\n    return (i == 0) ? x : sliderX[i - 1];\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.Configuration.valueAsDouble",
	"Comment": "returns the value for key in the configuration as a double, or thedefault provided value if not found or if the value is not a validdouble. a warning is issued to the log if the property is not defined, orif the conversion from string fails.",
	"Method": "double valueAsDouble(String key,double defaultVal){\r\n    String val = valueFor(key);\r\n    if (val == null) {\r\n        return defaultVal;\r\n    }\r\n    double dval;\r\n    try {\r\n        dval = Double.valueOf(val).doubleValue();\r\n    } catch (NumberFormatException nex) {\r\n        XRLog.exception(\"Property '\" + key + \"' was requested as a double, but \" + \"value of '\" + val + \"' is not a double. Check configuration.\");\r\n        dval = defaultVal;\r\n    }\r\n    return dval;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.objects.curves.Curve.getY",
	"Comment": "returns the scaled y coordinate of the control point at index i.",
	"Method": "float getY(int i){\r\n    return (i == 0) ? y : sliderY[i - 1];\r\n}"
}, {
	"Path": "com.j256.ormlite.dao.DaoManager.createDaoFromConfig",
	"Comment": "creates the dao if we have config information cached and caches the dao.",
	"Method": "D createDaoFromConfig(ConnectionSource connectionSource,Class<T> clazz){\r\n    if (configMap == null) {\r\n        return null;\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    DatabaseTableConfig<T> config = (DatabaseTableConfig<T>) configMap.get(clazz);\r\n    if (config == null) {\r\n        return null;\r\n    }\r\n    Dao<T, ?> configedDao = doCreateDao(connectionSource, config);\r\n    @SuppressWarnings(\"unchecked\")\r\n    D castDao = (D) configedDao;\r\n    return castDao;\r\n}"
}, {
	"Path": "io.opencensus.contrib.zpages.RpczZPageHandler.getDurationInSecs",
	"Comment": "calculates the duration of the given cumulativedata in seconds.",
	"Method": "double getDurationInSecs(ViewData.AggregationWindowData.CumulativeData cumulativeData){\r\n    return toDoubleSeconds(cumulativeData.getEnd().subtractTimestamp(cumulativeData.getStart()));\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGL.eglGetCurrentSurface",
	"Comment": "returns the egl surfaces used for rendering by the current context.\tif there is no context current, null is returned.",
	"Method": "EGLSurface eglGetCurrentSurface(int readdraw){\r\n    final long surface = neglGetCurrentSurface(readdraw);\r\n    if (surface == EGL_NO_SURFACE)\r\n        return null;\r\n    EGLDisplay display = eglGetCurrentDisplay();\r\n    final IntBuffer attrib_list = APIUtil.getBufferInt();\r\n    if (!neglQuerySurface(display.getPointer(), surface, EGL_CONFIG_ID, MemoryUtil.getAddress0(attrib_list)))\r\n        throwEGLError(\"Failed to query surface EGL config ID.\");\r\n    final EGLConfig config = getEGLConfig(display, attrib_list);\r\n    return new EGLSurface(display, config, surface);\r\n}"
}, {
	"Path": "orestes.bloomfilter.memory.CountingBloomFilterMemory.increment",
	"Comment": "increment the internal counter upon insertion of new elements.",
	"Method": "long increment(int index){\r\n    int low = index * config().countingBits();\r\n    int high = (index + 1) * config().countingBits();\r\n    boolean incremented = false;\r\n    long count = 0;\r\n    int pos = 0;\r\n    for (int i = (high - 1); i >= low; i--) {\r\n        if (!counts.get(i) && !incremented) {\r\n            counts.set(i);\r\n            incremented = true;\r\n        } else if (!incremented) {\r\n            counts.set(i, false);\r\n        }\r\n        if (counts.get(i)) {\r\n            count += Math.pow(2, pos);\r\n        }\r\n        pos++;\r\n    }\r\n    if (!incremented) {\r\n        overflowHandler.run();\r\n        for (int i = (high - 1); i >= low; i--) {\r\n            counts.set(i);\r\n        }\r\n        count = (long) Math.pow(2, config().countingBits() - 1);\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.displaylist.TransformCreator.createPageCoordinatesTranform",
	"Comment": "creates a transform that can be applied to a page, either pdf or java2d.\tthis transform can be applied on top of other tranforms already in effect on the page.",
	"Method": "AffineTransform createPageCoordinatesTranform(RenderingContext c,Box box,PageBox page,int shadowPageNumber){\r\n    TransformYOrigin yOrigin = c.getOutputDevice().isPDF() ? TransformYOrigin.PAGE_BOTTOM : TransformYOrigin.PAGE_TOP;\r\n    AffineTransform start = new AffineTransform();\r\n    createTransform(c, box, page, start, yOrigin, shadowPageNumber);\r\n    return start;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.Options.isWatchServiceEnabled",
	"Comment": "returns whether or not the beatmap watch service is enabled.",
	"Method": "boolean isWatchServiceEnabled(){\r\n    return GameOption.ENABLE_WATCH_SERVICE.getBooleanValue();\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.GeneralUtil.classNameOnly",
	"Comment": "given a string classname, returns just the classname with no package",
	"Method": "String classNameOnly(Object o,String classNameOnly,String cname){\r\n    String s = \"[null object ref]\";\r\n    if (cname != null) {\r\n        s = cname.substring(cname.lastIndexOf('.') + 1);\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.GameData.updateRankingDisplays",
	"Comment": "updates displayed ranking elements based on a delta value.",
	"Method": "void updateRankingDisplays(int delta,int mouseX,int mouseY){\r\n    Image graphImg = GameImage.RANKING_GRAPH.getImage();\r\n    float graphX = 416 * GameImage.getUIscale();\r\n    float graphY = 688 * GameImage.getUIscale();\r\n    if (isGameplay && mouseX >= graphX - graphImg.getWidth() / 2f && mouseX <= graphX + graphImg.getWidth() / 2f && mouseY >= graphY - graphImg.getHeight() / 2f && mouseY <= graphY + graphImg.getHeight() / 2f) {\r\n        if (performanceString == null)\r\n            performanceString = getPerformanceString(hitErrors);\r\n        UI.updateTooltip(delta, performanceString, true);\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.examples.spaceinvaders.Entity.move",
	"Comment": "request that this entity move itself based on a certain ammount\tof time passing.",
	"Method": "void move(long delta){\r\n    x += (delta * dx) / 1000;\r\n    y += (delta * dy) / 1000;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.audio.MusicController.updateTimingPoint",
	"Comment": "updates the timing point information for the current track position.",
	"Method": "boolean updateTimingPoint(){\r\n    Beatmap map = getBeatmap();\r\n    if (!isPlaying() || map == null || map.timingPoints == null || map.timingPoints.isEmpty())\r\n        return false;\r\n    if (timingPointIndex == 0 && lastTimingPoint == null && !map.timingPoints.isEmpty()) {\r\n        TimingPoint timingPoint = map.timingPoints.get(0);\r\n        if (!timingPoint.isInherited())\r\n            lastTimingPoint = timingPoint;\r\n    }\r\n    int trackPosition = getPosition(false);\r\n    for (int i = timingPointIndex + 1; i < map.timingPoints.size(); i++) {\r\n        TimingPoint timingPoint = map.timingPoints.get(i);\r\n        if (trackPosition < timingPoint.getTime())\r\n            break;\r\n        timingPointIndex = i;\r\n        if (!timingPoint.isInherited() && timingPoint.getBeatLength() > 0)\r\n            lastTimingPoint = timingPoint;\r\n    }\r\n    if (lastTimingPoint == null)\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ScoreData.areaContains",
	"Comment": "returns true if the coordinates are within the bounds of the\tscore button area.",
	"Method": "boolean areaContains(float cx,float cy){\r\n    return ((cx >= 0 && cx < baseX + buttonWidth) && (cy > baseY && cy < baseY + buttonOffset * SongMenu.MAX_SCORE_BUTTONS));\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.BeatmapParser.getCurrentFileName",
	"Comment": "returns the name of the current file being parsed, or null if none.",
	"Method": "String getCurrentFileName(){\r\n    if (status == Status.PARSING)\r\n        return (currentFile != null) ? currentFile.getName() : null;\r\n    else\r\n        return (status == Status.NONE) ? null : \"\";\r\n}"
}, {
	"Path": "org.lwjgl.openal.ALC10.alcGetContextsDevice",
	"Comment": "the application can query for, and obtain an handle to, the device of a given context.",
	"Method": "ALCdevice alcGetContextsDevice(ALCcontext context){\r\n    ALCdevice device = null;\r\n    long device_address = nalcGetContextsDevice(getContext(context));\r\n    if (device_address != 0) {\r\n        synchronized (ALC10.devices) {\r\n            device = ALC10.devices.get(device_address);\r\n        }\r\n    }\r\n    return device;\r\n}"
}, {
	"Path": "ddf.minim.ugens.DefaultInstrument.noteOn",
	"Comment": "turn on the default instrument.\ttypically, you will not call this directly.\tit will be called at the appropriate time by \tthe audioouput you schedule a note with.",
	"Method": "void noteOn(float dur){\r\n    summer.patch(output);\r\n    toneEnv.setDampTimeFromDuration(dur);\r\n    toneEnv.activate();\r\n    noiseEnv.activate();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.states.Game.getPointAt",
	"Comment": "returns the point at the t value between a start and end point.",
	"Method": "Vec2f getPointAt(float startX,float startY,float endX,float endY,float t){\r\n    if (GameMod.AUTOPILOT.isActive())\r\n        t = Utils.clamp(t * 2f, 0f, 1f);\r\n    return new Vec2f(startX + (endX - startX) * t, startY + (endY - startY) * t);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.insert",
	"Comment": "inserts a string.the old selection is replaced with the new text.",
	"Method": "void insert(String string){\r\n    checkWidget();\r\n    if (string == null) {\r\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\r\n    }\r\n    if (blockSelection) {\r\n        insertBlockSelectionText(string, false);\r\n    } else {\r\n        Point sel = getSelectionRange();\r\n        replaceTextRange(sel.x, sel.y, string);\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix2f.negate",
	"Comment": "negate the source matrix and stash the result in the destination matrix.",
	"Method": "Matrix negate(Matrix2f negate,Matrix2f dest,Matrix2f negate,Matrix2f src,Matrix2f dest){\r\n    if (dest == null)\r\n        dest = new Matrix2f();\r\n    dest.m00 = -src.m00;\r\n    dest.m01 = -src.m01;\r\n    dest.m10 = -src.m10;\r\n    dest.m11 = -src.m11;\r\n    return dest;\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.setOvershootClampingEnabled",
	"Comment": "force the spring to clamp at its end value to avoid overshooting the target value.",
	"Method": "Spring setOvershootClampingEnabled(boolean overshootClampingEnabled){\r\n    mOvershootClampingEnabled = overshootClampingEnabled;\r\n    return this;\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix2f.transpose",
	"Comment": "transpose the source matrix and place the result in the destination matrix.",
	"Method": "Matrix transpose(Matrix2f transpose,Matrix2f dest,Matrix2f transpose,Matrix2f src,Matrix2f dest){\r\n    if (dest == null)\r\n        dest = new Matrix2f();\r\n    float m01 = src.m10;\r\n    float m10 = src.m01;\r\n    dest.m01 = m01;\r\n    dest.m10 = m10;\r\n    return dest;\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.getJarInfo",
	"Comment": "this method will get the files sizes of the files to download.\tit wil further get the lastmodified time of files\tand save it in a hashmap, if cache is enabled it will mark\tthose files that have not changed since last download to not\tredownloaded.",
	"Method": "void getJarInfo(File dir){\r\n    setState(STATE_CHECKING_CACHE);\r\n    filesLastModified = new HashMap<String, Long>();\r\n    fileSizes = new int[urlList.length];\r\n    File timestampsFile = new File(dir, \"timestamps\");\r\n    if (timestampsFile.exists()) {\r\n        setState(STATE_CHECKING_FOR_UPDATES);\r\n        filesLastModified = readHashMapFile(timestampsFile);\r\n    }\r\n    ExecutorService executorService = Executors.newFixedThreadPool(concurrentLookupThreads);\r\n    Queue<Future> requests = new LinkedList<Future>();\r\n    final Object sync = new Integer(1);\r\n    for (int j = 0; j < urlList.length; j++) {\r\n        final int i = j;\r\n        Future request = executorService.submit(new Runnable() {\r\n            public void run() {\r\n                try {\r\n                    URLConnection urlconnection = urlList[i].openConnection();\r\n                    urlconnection.setDefaultUseCaches(false);\r\n                    if (urlconnection instanceof HttpURLConnection) {\r\n                        ((HttpURLConnection) urlconnection).setRequestMethod(\"HEAD\");\r\n                    }\r\n                    fileSizes[i] = urlconnection.getContentLength();\r\n                    long lastModified = urlconnection.getLastModified();\r\n                    String fileName = getFileName(urlList[i]);\r\n                    if (cacheEnabled && lastModified != 0 && filesLastModified.containsKey(fileName)) {\r\n                        long savedLastModified = filesLastModified.get(fileName);\r\n                        if (savedLastModified == lastModified) {\r\n                            fileSizes[i] = -2;\r\n                        }\r\n                    }\r\n                    if (fileSizes[i] >= 0) {\r\n                        synchronized (sync) {\r\n                            totalDownloadSize += fileSizes[i];\r\n                        }\r\n                    }\r\n                    filesLastModified.put(fileName, lastModified);\r\n                } catch (Exception e) {\r\n                    throw new RuntimeException(\"Failed to fetch information for \" + urlList[i], e);\r\n                }\r\n            }\r\n        });\r\n        requests.add(request);\r\n    }\r\n    while (!requests.isEmpty()) {\r\n        Iterator<Future> iterator = requests.iterator();\r\n        while (iterator.hasNext()) {\r\n            Future request = iterator.next();\r\n            if (request.isDone()) {\r\n                request.get();\r\n                iterator.remove();\r\n                percentage = 5 + (int) (10 * (urlList.length - requests.size()) / (float) urlList.length);\r\n            }\r\n        }\r\n        Thread.sleep(10);\r\n    }\r\n    executorService.shutdown();\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.getJarInfo",
	"Comment": "this method will get the files sizes of the files to download.\tit wil further get the lastmodified time of files\tand save it in a hashmap, if cache is enabled it will mark\tthose files that have not changed since last download to not\tredownloaded.",
	"Method": "void getJarInfo(File dir){\r\n    try {\r\n        URLConnection urlconnection = urlList[i].openConnection();\r\n        urlconnection.setDefaultUseCaches(false);\r\n        if (urlconnection instanceof HttpURLConnection) {\r\n            ((HttpURLConnection) urlconnection).setRequestMethod(\"HEAD\");\r\n        }\r\n        fileSizes[i] = urlconnection.getContentLength();\r\n        long lastModified = urlconnection.getLastModified();\r\n        String fileName = getFileName(urlList[i]);\r\n        if (cacheEnabled && lastModified != 0 && filesLastModified.containsKey(fileName)) {\r\n            long savedLastModified = filesLastModified.get(fileName);\r\n            if (savedLastModified == lastModified) {\r\n                fileSizes[i] = -2;\r\n            }\r\n        }\r\n        if (fileSizes[i] >= 0) {\r\n            synchronized (sync) {\r\n                totalDownloadSize += fileSizes[i];\r\n            }\r\n        }\r\n        filesLastModified.put(fileName, lastModified);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(\"Failed to fetch information for \" + urlList[i], e);\r\n    }\r\n}"
}, {
	"Path": "ddf.minim.AudioSource.removeListener",
	"Comment": "removes an audiolistener that was previously \tadded to this sound object.",
	"Method": "void removeListener(AudioListener listener){\r\n    splitter.removeListener(listener);\r\n}"
}, {
	"Path": "ddf.minim.javasound.JSMinim.getAudioInputStream",
	"Comment": "this method is also part of appletmpegspiworkaround, which uses yet\tanother workaround to load an internet radio stream.",
	"Method": "AudioInputStream getAudioInputStream(String filename,AudioInputStream getAudioInputStream,URL url,AudioInputStream getAudioInputStream,InputStream is,AudioInputStream getAudioInputStream,AudioFormat targetFormat,AudioInputStream sourceStream){\r\n    try {\r\n        return AudioSystem.getAudioInputStream(targetFormat, sourceStream);\r\n    } catch (IllegalArgumentException iae) {\r\n        debug(\"Using AppletMpegSPIWorkaround to get codec\");\r\n        try {\r\n            Class.forName(\"javazoom.spi.mpeg.sampled.convert.MpegFormatConversionProvider\");\r\n            return new javazoom.spi.mpeg.sampled.convert.MpegFormatConversionProvider().getAudioInputStream(targetFormat, sourceStream);\r\n        } catch (ClassNotFoundException cnfe) {\r\n            throw new IllegalArgumentException(\"Mpeg codec not properly installed\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.Sys.getTime",
	"Comment": "gets the current value of the hires timer, in ticks. when the sys class is first loaded\tthe hires timer is reset to 0. if no hires timer is present then this method will always\treturn 0.notez bien that the hires timer will wrap around.",
	"Method": "long getTime(){\r\n    return implementation.getTime() & 0x7FFFFFFFFFFFFFFFL;\r\n}"
}, {
	"Path": "io.opencensus.exporter.trace.ocagent.FakeOcAgentTraceServiceGrpcImpl.closeConfigStream",
	"Comment": "closes config stream and resets the reference to configrequestobserver.",
	"Method": "void closeConfigStream(){\r\n    configResponseObserver.onCompleted();\r\n}"
}, {
	"Path": "com.openhtmltopdf.outputdevice.helper.BaseRendererBuilder.useUnicodeBidiSplitter",
	"Comment": "provides a text splitter to split text into directional runs. does nothing by\tdefault.",
	"Method": "TFinalClass useUnicodeBidiSplitter(BidiSplitterFactory splitter){\r\n    state._splitter = splitter;\r\n    return (TFinalClass) this;\r\n}"
}, {
	"Path": "io.opencensus.exporter.trace.jaeger.JaegerTraceExporter.createWithSender",
	"Comment": "creates and registers the jaeger trace exporter to the opencensus library using the providedhttpsender. only one jaeger exporter can be registered at any point.",
	"Method": "void createWithSender(HttpSender httpSender,String serviceName){\r\n    synchronized (monitor) {\r\n        checkState(handler == null, \"Jaeger exporter is already registered.\");\r\n        final SpanExporter.Handler newHandler = newHandlerWithSender(httpSender, serviceName);\r\n        JaegerTraceExporter.handler = newHandler;\r\n        register(Tracing.getExportComponent().getSpanExporter(), newHandler);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.user.UserButton.getIconImage",
	"Comment": "returns the user icon image with the given identifier,\tor the default image if invalid.",
	"Method": "Image getIconImage(int id){\r\n    int i = (id < 0 || id >= getIconCount()) ? 0 : id;\r\n    return GameImage.USER.getImages()[i].getScaledCopy(iconSize, iconSize);\r\n}"
}, {
	"Path": "ddf.minim.analysis.FourierTransform.calcAvg",
	"Comment": "calculate the average amplitude of the frequency band bounded bylowfreq and hifreq, inclusive.",
	"Method": "float calcAvg(float lowFreq,float hiFreq){\r\n    int lowBound = freqToIndex(lowFreq);\r\n    int hiBound = freqToIndex(hiFreq);\r\n    float avg = 0;\r\n    for (int i = lowBound; i <= hiBound; i++) {\r\n        avg += spectrum[i];\r\n    }\r\n    avg /= (hiBound - lowBound + 1);\r\n    return avg;\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testHiddenBorder",
	"Comment": "tests than an inline block, floated, with border, that the border is visible. issue 297.",
	"Method": "void testHiddenBorder(){\r\n    assertTrue(vt.runTest(\"hidden-border\"));\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGL.eglSwapInterval",
	"Comment": "specifies the minimum number of video frame periods per buffer swap for\tthe window associated with the current context.",
	"Method": "void eglSwapInterval(EGLDisplay dpy,int interval){\r\n    if (!neglSwapInterval(dpy.getPointer(), interval))\r\n        throwEGLError(\"Failed to set swap interval.\");\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Vector2f.add",
	"Comment": "add a vector to another vector and place the result in a destination\tvector.",
	"Method": "Vector2f add(Vector2f left,Vector2f right,Vector2f dest){\r\n    if (dest == null)\r\n        return new Vector2f(left.x + right.x, left.y + right.y);\r\n    else {\r\n        dest.set(left.x + right.x, left.y + right.y);\r\n        return dest;\r\n    }\r\n}"
}, {
	"Path": "org.newdawn.slick.Input.disableControllers",
	"Comment": "disables support for controllers. this means the jinput jar and native libs \tare not required.",
	"Method": "void disableControllers(){\r\n    controllersInited = true;\r\n}"
}, {
	"Path": "ddf.minim.MultiChannelBuffer.setChannel",
	"Comment": "sets all of the values in a particular channel using \tthe values of the provided float array. the array\tshould be at least as long as the current buffer size\tof this buffer and this will only copy as many samples\tas fit into its current buffer size.",
	"Method": "void setChannel(int channelNumber,float[] samples){\r\n    System.arraycopy(samples, 0, channels[channelNumber], 0, bufferSize);\r\n}"
}, {
	"Path": "org.newdawn.slick.Input.removeControllerListener",
	"Comment": "remove a controller listener that will no longer be notified",
	"Method": "void removeControllerListener(ControllerListener listener){\r\n    controllerListeners.remove(listener);\r\n    if (!mouseListeners.contains(listener) && !keyListeners.contains(listener)) {\r\n        allListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.opengl.GLContext.getSupportedExtensions",
	"Comment": "determine which extensions are available and returns the context profile mask. helper method to contextcapabilities.",
	"Method": "int getSupportedExtensions(Set<String> supported_extensions){\r\n    final String version = glGetString(GL_VERSION);\r\n    if (version == null)\r\n        throw new IllegalStateException(\"glGetString(GL_VERSION) returned null - possibly caused by missing current context.\");\r\n    final StringTokenizer version_tokenizer = new StringTokenizer(version, \". \");\r\n    final String major_string = version_tokenizer.nextToken();\r\n    final String minor_string = version_tokenizer.nextToken();\r\n    int majorVersion = 0;\r\n    int minorVersion = 0;\r\n    try {\r\n        majorVersion = Integer.parseInt(major_string);\r\n        minorVersion = Integer.parseInt(minor_string);\r\n    } catch (NumberFormatException e) {\r\n        LWJGLUtil.log(\"The major and/or minor OpenGL version is malformed: \" + e.getMessage());\r\n    }\r\n    final int[][] GL_VERSIONS = { { 1, 2, 3, 4, 5 }, { 0, 1 }, { 0, 1, 2, 3 }, { 0, 1, 2, 3, 4, 5 } };\r\n    for (int major = 1; major <= GL_VERSIONS.length; major++) {\r\n        int[] minors = GL_VERSIONS[major - 1];\r\n        for (int minor : minors) {\r\n            if (major < majorVersion || (major == majorVersion && minor <= minorVersion))\r\n                supported_extensions.add(\"OpenGL\" + Integer.toString(major) + Integer.toString(minor));\r\n        }\r\n    }\r\n    int profileMask = 0;\r\n    if (majorVersion < 3) {\r\n        final String extensions_string = glGetString(GL_EXTENSIONS);\r\n        if (extensions_string == null)\r\n            throw new IllegalStateException(\"glGetString(GL_EXTENSIONS) returned null - is there a context current?\");\r\n        final StringTokenizer tokenizer = new StringTokenizer(extensions_string);\r\n        while (tokenizer.hasMoreTokens()) supported_extensions.add(tokenizer.nextToken());\r\n    } else {\r\n        final int extensionCount = glGetInteger(GL_NUM_EXTENSIONS);\r\n        for (int i = 0; i < extensionCount; i++) supported_extensions.add(glGetStringi(GL_EXTENSIONS, i));\r\n        if (3 < majorVersion || 2 <= minorVersion) {\r\n            Util.checkGLError();\r\n            try {\r\n                profileMask = glGetInteger(GL_CONTEXT_PROFILE_MASK);\r\n                Util.checkGLError();\r\n            } catch (OpenGLException e) {\r\n                LWJGLUtil.log(\"Failed to retrieve CONTEXT_PROFILE_MASK\");\r\n            }\r\n        }\r\n    }\r\n    return profileMask;\r\n}"
}, {
	"Path": "com.openhtmltopdf.java2d.api.Java2DRendererBuilder.runPaged",
	"Comment": "uselayoutgraphics and topageprocessor must have\tbeen called. also a document must have been set with one of the with methods. this will build the renderer and output each page of the document to\tthe specified page processor.",
	"Method": "void runPaged(){\r\n    Java2DRenderer renderer = this.buildJava2DRenderer();\r\n    renderer.layout();\r\n    if (state._pagingMode == Layer.PAGED_MODE_PRINT)\r\n        renderer.writePages();\r\n    else\r\n        renderer.writeSinglePage();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.Options.setDisplayMode",
	"Comment": "sets the container size and makes the window borderless if the container\tsize is identical to the screen resolution.\tif the configured resolution is larger than the screen size, the smallest\tavailable resolution will be used.",
	"Method": "void setDisplayMode(Container app){\r\n    int screenWidth = app.getScreenWidth();\r\n    int screenHeight = app.getScreenHeight();\r\n    boolean fullscreen = isFullscreen();\r\n    if (screenWidth < resolution.getWidth() || screenHeight < resolution.getHeight())\r\n        resolution = Resolution.RES_800_600;\r\n    if (fullscreen && !resolution.hasFullscreenDisplayMode())\r\n        fullscreen = false;\r\n    try {\r\n        app.setDisplayMode(resolution.getWidth(), resolution.getHeight(), fullscreen);\r\n    } catch (SlickException e) {\r\n        ErrorHandler.error(\"Failed to set display mode.\", e, true);\r\n    }\r\n    if (!fullscreen) {\r\n        boolean borderless = (screenWidth == resolution.getWidth() && screenHeight == resolution.getHeight());\r\n        System.setProperty(\"org.lwjgl.opengl.Window.undecorated\", Boolean.toString(borderless));\r\n    }\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.onImageInited",
	"Comment": "called by worker task when decoder is ready and image size and exif orientation is known.",
	"Method": "void onImageInited(Bitmap bitmap,int sWidth,int sHeight,int sOrientation){\r\n    this.sWidth = sWidth;\r\n    this.sHeight = sHeight;\r\n    this.sOrientation = sOrientation;\r\n    this.bitmap = bitmap;\r\n    forceCenterOnNextDraw();\r\n    requestLayout();\r\n    invalidate();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.OptionsOverlay.adjustSlider",
	"Comment": "handles a slider adjustment to the given mouse coordinates.",
	"Method": "void adjustSlider(int mouseX,int mouseY){\r\n    int oldSliderValue = hoverOption.getIntegerValue();\r\n    updateSliderOption(mouseX, mouseY);\r\n    if (hoverOption.getIntegerValue() != oldSliderValue && sliderSoundDelay == 0) {\r\n        sliderSoundDelay = SLIDER_SOUND_INTERVAL;\r\n        SoundController.playSound(SoundEffect.MENUCLICK);\r\n    }\r\n}"
}, {
	"Path": "me.imid.swipebacklayout.lib.SwipeBackLayout.setScrollThresHold",
	"Comment": "set scroll threshold, we will close the activity, when scrollpercent over\tthis value",
	"Method": "void setScrollThresHold(float threshold){\r\n    if (threshold >= 1.0f || threshold <= 0) {\r\n        throw new IllegalArgumentException(\"Threshold value should be between 0 and 1.0\");\r\n    }\r\n    mScrollThreshold = threshold;\r\n}"
}, {
	"Path": "org.lwjgl.util.input.ControllerAdapter.getRXAxisValue",
	"Comment": "get the value from the rx axis if there is one. if no rx axis is defined\ta zero value will be returned.",
	"Method": "float getRXAxisValue(){\r\n    return 0f;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.audio.SoundController.playTrack",
	"Comment": "plays a track from a remote url.\tif a track is currently playing, it will be stopped.",
	"Method": "boolean playTrack(String url,String filename,LineListener listener){\r\n    stopTrack();\r\n    File dir = Options.TEMP_DIR;\r\n    if (!dir.isDirectory())\r\n        dir.mkdir();\r\n    final File downloadFile = new File(dir, filename);\r\n    boolean complete;\r\n    if (downloadFile.isFile()) {\r\n        complete = true;\r\n    } else {\r\n        Download download = new Download(url, downloadFile.getAbsolutePath());\r\n        download.setListener(new DownloadListener() {\r\n            @Override\r\n            public void completed() {\r\n            }\r\n            @Override\r\n            public void error() {\r\n                UI.getNotificationManager().sendBarNotification(\"Failed to download track preview.\");\r\n            }\r\n        });\r\n        try {\r\n            download.start().join();\r\n        } catch (InterruptedException e) {\r\n        }\r\n        complete = (download.getStatus() == Download.Status.COMPLETE);\r\n    }\r\n    if (complete) {\r\n        try {\r\n            AudioInputStream audioIn = AudioSystem.getAudioInputStream(downloadFile);\r\n            currentTrack = loadClip(filename, audioIn);\r\n            playClip(currentTrack, Options.getMusicVolume() * Options.getMasterVolume(), listener);\r\n            return true;\r\n        } catch (Exception e) {\r\n            throw new SlickException(String.format(\"Failed to load clip '%s'.\", url));\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.audio.SoundController.playTrack",
	"Comment": "plays a track from a remote url.\tif a track is currently playing, it will be stopped.",
	"Method": "boolean playTrack(String url,String filename,LineListener listener){\r\n}"
}, {
	"Path": "itdelatrisu.opsu.audio.SoundController.playTrack",
	"Comment": "plays a track from a remote url.\tif a track is currently playing, it will be stopped.",
	"Method": "boolean playTrack(String url,String filename,LineListener listener){\r\n    UI.getNotificationManager().sendBarNotification(\"Failed to download track preview.\");\r\n}"
}, {
	"Path": "me.imid.swipebacklayout.lib.ViewDragHelper.getMinVelocity",
	"Comment": "return the currently configured minimum velocity. any flings with amagnitude less than this value in pixels per second. callback methodsaccepting a velocity will receive zero as a velocity value if the realdetected velocity was below this threshold.",
	"Method": "float getMinVelocity(){\r\n    return mMinVelocity;\r\n}"
}, {
	"Path": "com.openhtmltopdf.pdfboxout.PdfRendererBuilder.usePdfVersion",
	"Comment": "set the pdf version, typically we use 1.7. if you set a lower version, it is\tyour responsibility to make sure no more recent pdf features are used.",
	"Method": "PdfRendererBuilder usePdfVersion(float version){\r\n    state._pdfVersion = version;\r\n    return this;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getLocationAtOffset",
	"Comment": "returns the x, y location of the upper left corner of the character bounding box at the specified offset in the text. the point is relative to the upper left corner of the widget client area.",
	"Method": "Point getLocationAtOffset(int offset){\r\n    checkWidget();\r\n    if (offset < 0 || offset > getCharCount()) {\r\n        SWT.error(SWT.ERROR_INVALID_RANGE);\r\n    }\r\n    return getPointAtOffset(offset);\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.updateClassPath",
	"Comment": "edits the classpath at runtime to include the jars\tthat have just been downloaded and then adds the\tlwjgl natives folder property.",
	"Method": "void updateClassPath(String path){\r\n    setState(STATE_UPDATING_CLASSPATH);\r\n    percentage = 95;\r\n    URL[] urls = new URL[urlList.length];\r\n    for (int i = 0; i < urlList.length; i++) {\r\n        String file = new File(path, getJarName(urlList[i])).toURI().toString();\r\n        file = file.replace(\"!\", \"!\");\r\n        urls[i] = new URL(file);\r\n    }\r\n    final Certificate[] certs = getCurrentCertificates();\r\n    String osName = System.getProperty(\"os.name\");\r\n    final boolean isMacOS = (osName.startsWith(\"Mac\") || osName.startsWith(\"Darwin\"));\r\n    classLoader = new URLClassLoader(urls) {\r\n        protected PermissionCollection getPermissions(CodeSource codesource) {\r\n            PermissionCollection perms = null;\r\n            try {\r\n                perms = new Permissions();\r\n                if (certificatesMatch(certs, codesource.getCertificates())) {\r\n                    perms.add(new AllPermission());\r\n                    return perms;\r\n                }\r\n                String host = getCodeBase().getHost();\r\n                if (host != null && (host.length() > 0)) {\r\n                    perms.add(new SocketPermission(host, \"connect,accept\"));\r\n                } else if (\"file\".equals(codesource.getLocation().getProtocol())) {\r\n                    String path = codesource.getLocation().getFile().replace('/', File.separatorChar);\r\n                    perms.add(new FilePermission(path, \"read\"));\r\n                }\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n            return perms;\r\n        }\r\n        protected String findLibrary(String libname) {\r\n            String libPath = path + \"natives\" + File.separator + LWJGLUtil.mapLibraryName(libname);\r\n            if (new File(libPath).exists()) {\r\n                return libPath;\r\n            }\r\n            return super.findLibrary(libname);\r\n        }\r\n    };\r\n    debug_sleep(2000);\r\n    unloadNatives(path);\r\n    System.setProperty(\"org.lwjgl.librarypath\", path + \"natives\");\r\n    System.setProperty(\"net.java.games.input.librarypath\", path + \"natives\");\r\n    System.setProperty(\"java.library.path\", path + \"natives\");\r\n    natives_loaded = true;\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.updateClassPath",
	"Comment": "edits the classpath at runtime to include the jars\tthat have just been downloaded and then adds the\tlwjgl natives folder property.",
	"Method": "void updateClassPath(String path){\r\n    PermissionCollection perms = null;\r\n    try {\r\n        perms = new Permissions();\r\n        if (certificatesMatch(certs, codesource.getCertificates())) {\r\n            perms.add(new AllPermission());\r\n            return perms;\r\n        }\r\n        String host = getCodeBase().getHost();\r\n        if (host != null && (host.length() > 0)) {\r\n            perms.add(new SocketPermission(host, \"connect,accept\"));\r\n        } else if (\"file\".equals(codesource.getLocation().getProtocol())) {\r\n            String path = codesource.getLocation().getFile().replace('/', File.separatorChar);\r\n            perms.add(new FilePermission(path, \"read\"));\r\n        }\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n    return perms;\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.updateClassPath",
	"Comment": "edits the classpath at runtime to include the jars\tthat have just been downloaded and then adds the\tlwjgl natives folder property.",
	"Method": "void updateClassPath(String path){\r\n    String libPath = path + \"natives\" + File.separator + LWJGLUtil.mapLibraryName(libname);\r\n    if (new File(libPath).exists()) {\r\n        return libPath;\r\n    }\r\n    return super.findLibrary(libname);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.db.BeatmapDB.getUpdateQueries",
	"Comment": "returns a list of sql queries to apply, in order, to update from\tthe given database version to the latest version.",
	"Method": "List<String> getUpdateQueries(int version){\r\n    List<String> list = new LinkedList<String>();\r\n    if (version < 20161222) {\r\n        list.add(\"ALTER TABLE beatmaps ADD COLUMN dateAdded INTEGER\");\r\n        list.add(\"ALTER TABLE beatmaps ADD COLUMN favorite BOOLEAN\");\r\n        list.add(\"ALTER TABLE beatmaps ADD COLUMN playCount INTEGER\");\r\n        list.add(\"ALTER TABLE beatmaps ADD COLUMN lastPlayed INTEGER\");\r\n        list.add(\"UPDATE beatmaps SET dateAdded = 0, favorite = 0, playCount = 0, lastPlayed = 0\");\r\n    }\r\n    if (version < 20161225) {\r\n        list.add(\"ALTER TABLE beatmaps ADD COLUMN localOffset INTEGER\");\r\n        list.add(\"UPDATE beatmaps SET localOffset = 0\");\r\n    }\r\n    if (version < 20170128) {\r\n        list.add(\"ALTER TABLE beatmaps ADD COLUMN video TEXT\");\r\n        list.add(\"ALTER TABLE beatmaps ADD COLUMN videoOffset INTEGER\");\r\n        list.add(\"UPDATE beatmaps SET videoOffset = 0\");\r\n    }\r\n    if (version < 20170221) {\r\n        list.add(\"UPDATE beatmaps SET stars = -1\");\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGLKHRReusableSync.eglCreateSyncKHR",
	"Comment": "creates a fence sync object for the specified egl display and returns\ta handle to the new object.",
	"Method": "EGLSyncKHR eglCreateSyncKHR(EGLDisplay dpy,int type,IntBuffer attrib_list){\r\n    return EGLKHRFenceSync.eglCreateSyncKHR(dpy, type, attrib_list);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.BeatmapParser.parseDirectories",
	"Comment": "invokes parser for each directory in the given array and\tadds the beatmaps to the existing beatmapsetlist.",
	"Method": "BeatmapSetNode parseDirectories(File[] dirs,BeatmapSetNode parseDirectories,File[] dirs,BeatmapSetList oldBeatmapList){\r\n    if (dirs == null)\r\n        return null;\r\n    status = Status.PARSING;\r\n    currentDirectoryIndex = 0;\r\n    totalDirectories = dirs.length;\r\n    Map<String, BeatmapDB.LastModifiedMapEntry> lastModifiedMap = BeatmapDB.getLastModifiedMap();\r\n    List<ArrayList<Beatmap>> allBeatmaps = new LinkedList<ArrayList<Beatmap>>();\r\n    List<Beatmap> cachedBeatmaps = new LinkedList<Beatmap>();\r\n    List<Beatmap> parsedBeatmaps = new LinkedList<Beatmap>();\r\n    BeatmapWatchService ws = (Options.isWatchServiceEnabled()) ? BeatmapWatchService.get() : null;\r\n    BeatmapSetNode lastNode = null;\r\n    long timestamp = System.currentTimeMillis();\r\n    for (File dir : dirs) {\r\n        currentDirectoryIndex++;\r\n        if (!dir.isDirectory())\r\n            continue;\r\n        File[] files = dir.listFiles(new FilenameFilter() {\r\n            @Override\r\n            public boolean accept(File dir, String name) {\r\n                return name.toLowerCase().endsWith(\".osu\");\r\n            }\r\n        });\r\n        if (files == null || files.length < 1)\r\n            continue;\r\n        ArrayList<Beatmap> beatmaps = new ArrayList<Beatmap>(files.length);\r\n        for (File file : files) {\r\n            currentFile = file;\r\n            String beatmapPath = String.format(\"%s/%s\", dir.getName(), file.getName());\r\n            if (lastModifiedMap != null) {\r\n                BeatmapDB.LastModifiedMapEntry entry = lastModifiedMap.get(beatmapPath);\r\n                if (entry != null) {\r\n                    if (entry.getLastModified() == file.lastModified()) {\r\n                        if (entry.getMode() == Beatmap.MODE_OSU) {\r\n                            Beatmap beatmap = new Beatmap(file);\r\n                            beatmaps.add(beatmap);\r\n                            cachedBeatmaps.add(beatmap);\r\n                        }\r\n                        continue;\r\n                    } else\r\n                        BeatmapDB.delete(dir.getName(), file.getName());\r\n                }\r\n            }\r\n            Beatmap beatmap = null;\r\n            try {\r\n                beatmap = parseFile(file, dir, beatmaps, false);\r\n            } catch (Exception e) {\r\n                ErrorHandler.error(String.format(\"Failed to parse beatmap file '%s'.\", file.getAbsolutePath()), e, true);\r\n            }\r\n            if (beatmap != null) {\r\n                Beatmap oldBeatmap;\r\n                if (oldBeatmapList != null && (oldBeatmap = oldBeatmapList.getBeatmapFromHash(beatmap.md5Hash)) != null)\r\n                    oldBeatmap.copyAdditionalFields(beatmap);\r\n                if (beatmap.dateAdded < 1)\r\n                    beatmap.dateAdded = timestamp;\r\n                if (beatmap.mode == Beatmap.MODE_OSU)\r\n                    beatmaps.add(beatmap);\r\n                parsedBeatmaps.add(beatmap);\r\n            }\r\n        }\r\n        if (!beatmaps.isEmpty()) {\r\n            beatmaps.trimToSize();\r\n            allBeatmaps.add(beatmaps);\r\n            if (ws != null)\r\n                ws.registerAll(dir.toPath());\r\n        }\r\n        if (Thread.interrupted())\r\n            break;\r\n    }\r\n    if (!cachedBeatmaps.isEmpty()) {\r\n        status = Status.CACHE;\r\n        BeatmapDB.load(cachedBeatmaps, BeatmapDB.LOAD_NONARRAY);\r\n    }\r\n    for (ArrayList<Beatmap> beatmaps : allBeatmaps) {\r\n        Collections.sort(beatmaps);\r\n        lastNode = BeatmapSetList.get().addSongGroup(beatmaps);\r\n    }\r\n    stringdb = new HashMap<String, String>();\r\n    if (!parsedBeatmaps.isEmpty()) {\r\n        status = Status.INSERTING;\r\n        BeatmapDB.insert(parsedBeatmaps);\r\n    }\r\n    status = Status.NONE;\r\n    currentFile = null;\r\n    currentDirectoryIndex = -1;\r\n    totalDirectories = -1;\r\n    return lastNode;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.BeatmapParser.parseDirectories",
	"Comment": "invokes parser for each directory in the given array and\tadds the beatmaps to the existing beatmapsetlist.",
	"Method": "BeatmapSetNode parseDirectories(File[] dirs,BeatmapSetNode parseDirectories,File[] dirs,BeatmapSetList oldBeatmapList){\r\n    return name.toLowerCase().endsWith(\".osu\");\r\n}"
}, {
	"Path": "com.android.volley.RequestQueue.removeRequestFinishedListener",
	"Comment": "remove a requestfinishedlistener. has no effect if listener was not previously added.",
	"Method": "void removeRequestFinishedListener(RequestFinishedListener<T> listener){\r\n    synchronized (mFinishedListeners) {\r\n        mFinishedListeners.remove(listener);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.states.MainMenu.enterSongMenu",
	"Comment": "enters the song menu, or the downloads menu if no beatmaps are loaded.",
	"Method": "void enterSongMenu(){\r\n    int state = Opsu.STATE_SONGMENU;\r\n    if (BeatmapSetList.get().getMapSetCount() == 0) {\r\n        ((DownloadsMenu) game.getState(Opsu.STATE_DOWNLOADSMENU)).notifyOnLoad(\"Download some beatmaps to get started!\");\r\n        state = Opsu.STATE_DOWNLOADSMENU;\r\n    }\r\n    game.enterState(state, new EasedFadeOutTransition(), new FadeInTransition());\r\n}"
}, {
	"Path": "com.android.volley.toolbox.DiskBasedCache.get",
	"Comment": "returns the cache entry with the specified key if it exists, null otherwise.",
	"Method": "Entry get(String key){\r\n    CacheHeader entry = mEntries.get(key);\r\n    if (entry == null) {\r\n        return null;\r\n    }\r\n    File file = getFileForKey(key);\r\n    CountingInputStream cis = null;\r\n    try {\r\n        cis = new CountingInputStream(new BufferedInputStream(new FileInputStream(file)));\r\n        CacheHeader.readHeader(cis);\r\n        byte[] data = streamToBytes(cis, (int) (file.length() - cis.bytesRead));\r\n        return entry.toCacheEntry(data);\r\n    } catch (IOException e) {\r\n        VolleyLog.d(\"%s: %s\", file.getAbsolutePath(), e.toString());\r\n        remove(key);\r\n        return null;\r\n    } catch (NegativeArraySizeException e) {\r\n        VolleyLog.d(\"%s: %s\", file.getAbsolutePath(), e.toString());\r\n        remove(key);\r\n        return null;\r\n    } finally {\r\n        if (cis != null) {\r\n            try {\r\n                cis.close();\r\n            } catch (IOException ioe) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.newdawn.slick.Image.destroy",
	"Comment": "destroy the image and release any native resources. \tcalls on a destroyed image have undefined results",
	"Method": "void destroy(){\r\n    if (isDestroyed()) {\r\n        return;\r\n    }\r\n    flushPixelData();\r\n    destroyed = true;\r\n    texture.release();\r\n    GraphicsFactory.releaseGraphicsForImage(this);\r\n}"
}, {
	"Path": "org.lwjgl.opengles.Util.translateGLErrorString",
	"Comment": "translates a gl error code to a string describing the error.",
	"Method": "String translateGLErrorString(int error_code){\r\n    switch(error_code) {\r\n        case GL_NO_ERROR:\r\n            return \"No error\";\r\n        case GL_INVALID_ENUM:\r\n            return \"Invalid enum\";\r\n        case GL_INVALID_VALUE:\r\n            return \"Invalid value\";\r\n        case GL_INVALID_OPERATION:\r\n            return \"Invalid operation\";\r\n        case GL_OUT_OF_MEMORY:\r\n            return \"Out of memory\";\r\n        default:\r\n            return null;\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.Configuration.valueAsFloat",
	"Comment": "returns the value for key in the configuration as a float, or the defaultprovided value if not found or if the value is not a valid float. awarning is issued to the log if the property is not defined, or if theconversion from string fails.",
	"Method": "float valueAsFloat(String key,float defaultVal){\r\n    String val = valueFor(key);\r\n    if (val == null) {\r\n        return defaultVal;\r\n    }\r\n    float fval;\r\n    try {\r\n        fval = Float.valueOf(val).floatValue();\r\n    } catch (NumberFormatException nex) {\r\n        XRLog.exception(\"Property '\" + key + \"' was requested as a float, but \" + \"value of '\" + val + \"' is not a float. Check configuration.\");\r\n        fval = defaultVal;\r\n    }\r\n    return fval;\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Vector4f.normalise",
	"Comment": "normalise this vector and place the result in another vector.",
	"Method": "Vector4f normalise(Vector4f dest){\r\n    float l = length();\r\n    if (dest == null)\r\n        dest = new Vector4f(x / l, y / l, z / l, w / l);\r\n    else\r\n        dest.set(x / l, y / l, z / l, w / l);\r\n    return dest;\r\n}"
}, {
	"Path": "org.newdawn.slick.openal.SoundStore.setDeferredLoading",
	"Comment": "true if we should only record the request to load in the intentionof loading the sound later",
	"Method": "void setDeferredLoading(boolean deferred){\r\n    this.deferred = deferred;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.APIUtil.getBuffer",
	"Comment": "returns a buffer containing the specified strings as bytes.",
	"Method": "long getBuffer(CharSequence string,long getBuffer,CharSequence string,int offset,long getBuffer,CharSequence[] strings){\r\n    final ByteBuffer buffer = getBufferByte(getTotalLength(strings));\r\n    for (CharSequence string : strings) encode(buffer, string);\r\n    buffer.flip();\r\n    return MemoryUtil.getAddress0(buffer);\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix3f.mul",
	"Comment": "multiply the right matrix by the left and place the result in a third matrix.",
	"Method": "Matrix3f mul(Matrix3f left,Matrix3f right,Matrix3f dest){\r\n    if (dest == null)\r\n        dest = new Matrix3f();\r\n    float m00 = left.m00 * right.m00 + left.m10 * right.m01 + left.m20 * right.m02;\r\n    float m01 = left.m01 * right.m00 + left.m11 * right.m01 + left.m21 * right.m02;\r\n    float m02 = left.m02 * right.m00 + left.m12 * right.m01 + left.m22 * right.m02;\r\n    float m10 = left.m00 * right.m10 + left.m10 * right.m11 + left.m20 * right.m12;\r\n    float m11 = left.m01 * right.m10 + left.m11 * right.m11 + left.m21 * right.m12;\r\n    float m12 = left.m02 * right.m10 + left.m12 * right.m11 + left.m22 * right.m12;\r\n    float m20 = left.m00 * right.m20 + left.m10 * right.m21 + left.m20 * right.m22;\r\n    float m21 = left.m01 * right.m20 + left.m11 * right.m21 + left.m21 * right.m22;\r\n    float m22 = left.m02 * right.m20 + left.m12 * right.m21 + left.m22 * right.m22;\r\n    dest.m00 = m00;\r\n    dest.m01 = m01;\r\n    dest.m02 = m02;\r\n    dest.m10 = m10;\r\n    dest.m11 = m11;\r\n    dest.m12 = m12;\r\n    dest.m20 = m20;\r\n    dest.m21 = m21;\r\n    dest.m22 = m22;\r\n    return dest;\r\n}"
}, {
	"Path": "com.openhtmltopdf.context.StandardAttributeResolver.getElementStyling",
	"Comment": "gets the elementstyling attribute of the standardattributeresolver object",
	"Method": "String getElementStyling(Object e){\r\n    return nsh.getElementStyling((Element) e);\r\n}"
}, {
	"Path": "org.lwjgl.PointerBuffer.remainingByte",
	"Comment": "returns the number of bytes between the current position and the\tlimit.",
	"Method": "int remainingByte(){\r\n    return remaining() * getPointerSize();\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.resetScaleAndCenter",
	"Comment": "fully zoom out and return the image to the middle of the screen. this might be useful if you have a view pagerand want images to be reset when the user has moved to another page.",
	"Method": "void resetScaleAndCenter(){\r\n    this.anim = null;\r\n    this.pendingScale = limitedScale(0);\r\n    if (isImageReady()) {\r\n        this.sPendingCenter = new PointF(sWidth() / 2, sHeight() / 2);\r\n    } else {\r\n        this.sPendingCenter = new PointF(0, 0);\r\n    }\r\n    invalidate();\r\n}"
}, {
	"Path": "io.opencensus.contrib.agent.bootstrap.ContextTrampoline.attachContextForThread",
	"Comment": "attaches the context that was previously saved for the specified thread.",
	"Method": "void attachContextForThread(Thread thread){\r\n    contextStrategy.attachContextForThread(thread);\r\n}"
}, {
	"Path": "orestes.bloomfilter.BloomFilter.toBytes",
	"Comment": "converts an element to the byte array representation used for hashing.",
	"Method": "byte[] toBytes(T element){\r\n    return element.toString().getBytes(FilterBuilder.defaultCharset());\r\n}"
}, {
	"Path": "org.lwjgl.util.input.ControllerAdapter.getZAxisValue",
	"Comment": "get the value from the z axis if there is one. if no z axis is defined a\tzero value will be returned.",
	"Method": "float getZAxisValue(){\r\n    return 0f;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.BeatmapSetList.containsBeatmapSetID",
	"Comment": "returns whether or not the list contains the given beatmap set id.\tnote that ids for older maps might have been improperly parsed, so\tthere is no guarantee that this method will return an accurate value.",
	"Method": "boolean containsBeatmapSetID(int id){\r\n    return MSIDdb.contains(id);\r\n}"
}, {
	"Path": "org.lwjgl.opengl.PixelFormat.withSRGB",
	"Comment": "returns a new pixelformat object with the same properties as this pixelformat and the new srgb value.",
	"Method": "PixelFormat withSRGB(boolean sRGB){\r\n    final PixelFormat pf = new PixelFormat(this);\r\n    pf.sRGB = sRGB;\r\n    return pf;\r\n}"
}, {
	"Path": "ddf.minim.SignalSplitter.bufferSize",
	"Comment": "the buffer size this was constructed with. arrays passed to generate should be the same length.",
	"Method": "int bufferSize(){\r\n    return bs;\r\n}"
}, {
	"Path": "me.imid.swipebacklayout.lib.ViewDragHelper.setMaxVelocity",
	"Comment": "set the max velocity that will be detected as having a magnitudegreater than zero in pixels per second. callback methods accepting avelocity will be clamped appropriately.",
	"Method": "void setMaxVelocity(float maxVel){\r\n    mMaxVelocity = maxVel;\r\n}"
}, {
	"Path": "com.openhtmltopdf.simple.extend.XhtmlCssOnlyNamespaceHandler.getStylesheets",
	"Comment": "gets the stylesheetlinks attribute of the xhtmlnamespacehandler object",
	"Method": "StylesheetInfo[] getStylesheets(org.w3c.dom.Document doc){\r\n    List result = new ArrayList();\r\n    result.addAll(Arrays.asList(super.getStylesheets(doc)));\r\n    Element html = doc.getDocumentElement();\r\n    Element head = findFirstChild(html, \"head\");\r\n    if (head != null) {\r\n        Node current = head.getFirstChild();\r\n        while (current != null) {\r\n            if (current.getNodeType() == Node.ELEMENT_NODE) {\r\n                Element elem = (Element) current;\r\n                StylesheetInfo info = null;\r\n                String elemName = elem.getLocalName();\r\n                if (elemName == null) {\r\n                    elemName = elem.getTagName();\r\n                }\r\n                if (elemName.equals(\"link\")) {\r\n                    info = readLinkElement(elem);\r\n                } else if (elemName.equals(\"style\")) {\r\n                    info = readStyleElement(elem);\r\n                }\r\n                if (info != null) {\r\n                    result.add(info);\r\n                }\r\n            }\r\n            current = current.getNextSibling();\r\n        }\r\n    }\r\n    return (StylesheetInfo[]) result.toArray(new StylesheetInfo[result.size()]);\r\n}"
}, {
	"Path": "com.openhtmltopdf.nonvisualregressiontests.NonVisualRegressionTest.testLinkAreaTransformNested",
	"Comment": "tests a link element inside a transformed element in the page content.",
	"Method": "void testLinkAreaTransformNested(){\r\n    PDDocument doc = run(\"link-area-transform-nested\");\r\n    assertEquals(1, doc.getPage(0).getAnnotations().size());\r\n    assertThat(doc.getPage(0).getAnnotations().get(0), instanceOf(PDAnnotationLink.class));\r\n    PDAnnotationLink link = (PDAnnotationLink) doc.getPage(0).getAnnotations().get(0);\r\n    assertThat(link.getRectangle(), rectEquals(new PDRectangle(60f, 62f, 50f, 100f), 200d));\r\n    remove(\"link-area-transform-nested\", doc);\r\n}"
}, {
	"Path": "io.opencensus.exporter.trace.ocagent.TraceProtoUtils.getCurrentTraceConfig",
	"Comment": "creates a traceconfig proto message with current traceparams.",
	"Method": "TraceConfig getCurrentTraceConfig(io.opencensus.trace.config.TraceConfig traceConfig){\r\n    TraceParams traceParams = traceConfig.getActiveTraceParams();\r\n    return toTraceConfigProto(traceParams);\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.getRestDisplacementThreshold",
	"Comment": "get the threshold of displacement from rest below which the spring should be considered at rest",
	"Method": "double getRestDisplacementThreshold(){\r\n    return mDisplacementFromRestThreshold;\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Vector3f.sub",
	"Comment": "subtract a vector from another vector and place the result in a destination\tvector.",
	"Method": "Vector3f sub(Vector3f left,Vector3f right,Vector3f dest){\r\n    if (dest == null)\r\n        return new Vector3f(left.x - right.x, left.y - right.y, left.z - right.z);\r\n    else {\r\n        dest.set(left.x - right.x, left.y - right.y, left.z - right.z);\r\n        return dest;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.calculateTopIndex",
	"Comment": "calculates the top index based on the current vertical scroll offset.the top index is the index of the topmost fully visible line or thetopmost partially visible line if no line is fully visible.the top index starts at 0.",
	"Method": "void calculateTopIndex(int delta){\r\n    int oldTopIndex = topIndex;\r\n    int oldTopIndexY = topIndexY;\r\n    if (isFixedLineHeight()) {\r\n        int verticalIncrement = getVerticalIncrement();\r\n        if (verticalIncrement == 0) {\r\n            return;\r\n        }\r\n        topIndex = Compatibility.ceil(getVerticalScrollOffset(), verticalIncrement);\r\n        if (topIndex > 0) {\r\n            if (clientAreaHeight > 0) {\r\n                int bottomPixel = getVerticalScrollOffset() + clientAreaHeight;\r\n                int fullLineTopPixel = topIndex * verticalIncrement;\r\n                int fullLineVisibleHeight = bottomPixel - fullLineTopPixel;\r\n                if (fullLineVisibleHeight < verticalIncrement) {\r\n                    topIndex--;\r\n                }\r\n            } else if (topIndex >= content.getLineCount()) {\r\n                topIndex = content.getLineCount() - 1;\r\n            }\r\n        }\r\n    } else {\r\n        if (delta >= 0) {\r\n            delta -= topIndexY;\r\n            int lineIndex = topIndex;\r\n            int lineCount = content.getLineCount();\r\n            while (lineIndex < lineCount) {\r\n                if (delta <= 0)\r\n                    break;\r\n                delta -= renderer.getLineHeight(lineIndex++);\r\n            }\r\n            if (lineIndex < lineCount && -delta + renderer.getLineHeight(lineIndex) <= clientAreaHeight - topMargin - bottomMargin) {\r\n                topIndex = lineIndex;\r\n                topIndexY = -delta;\r\n            } else {\r\n                topIndex = lineIndex - 1;\r\n                topIndexY = -renderer.getLineHeight(topIndex) - delta;\r\n            }\r\n        } else {\r\n            delta -= topIndexY;\r\n            int lineIndex = topIndex;\r\n            while (lineIndex > 0) {\r\n                int lineHeight = renderer.getLineHeight(lineIndex - 1);\r\n                if (delta + lineHeight > 0)\r\n                    break;\r\n                delta += lineHeight;\r\n                lineIndex--;\r\n            }\r\n            if (lineIndex == 0 || -delta + renderer.getLineHeight(lineIndex) <= clientAreaHeight - topMargin - bottomMargin) {\r\n                topIndex = lineIndex;\r\n                topIndexY = -delta;\r\n            } else {\r\n                topIndex = lineIndex - 1;\r\n                topIndexY = -renderer.getLineHeight(topIndex) - delta;\r\n            }\r\n        }\r\n    }\r\n    if (topIndex != oldTopIndex || oldTopIndexY != topIndexY) {\r\n        int width = renderer.getWidth();\r\n        renderer.calculateClientArea();\r\n        if (width != renderer.getWidth()) {\r\n            setScrollBars(false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.OptionsOverlay.contains",
	"Comment": "returns true if the coordinates are within the overlay bounds.",
	"Method": "boolean contains(float cx,float cy){\r\n    return ((cx > x && cx < x + width) && (cy > y && cy < y + height));\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.loadGlyphs",
	"Comment": "loads up to the specified number of queued glyphs to the backing textures. this is typically called from the game loop to\tload glyphs on the fly that were requested for display but have not yet been loaded.",
	"Method": "boolean loadGlyphs(boolean loadGlyphs,int maxGlyphsToLoad){\r\n    if (queuedGlyphs.isEmpty())\r\n        return false;\r\n    if (effects.isEmpty())\r\n        throw new IllegalStateException(\"The UnicodeFont must have at least one effect before any glyphs can be loaded.\");\r\n    for (Iterator iter = queuedGlyphs.iterator(); iter.hasNext(); ) {\r\n        Glyph glyph = (Glyph) iter.next();\r\n        int codePoint = glyph.getCodePoint();\r\n        if (glyph.getWidth() == 0 || codePoint == ' ') {\r\n            iter.remove();\r\n            continue;\r\n        }\r\n        if (glyph.isMissing()) {\r\n            if (missingGlyph != null) {\r\n                if (glyph != missingGlyph)\r\n                    iter.remove();\r\n                continue;\r\n            }\r\n            missingGlyph = glyph;\r\n        }\r\n    }\r\n    Collections.sort(queuedGlyphs, heightComparator);\r\n    for (Iterator iter = glyphPages.iterator(); iter.hasNext(); ) {\r\n        GlyphPage glyphPage = (GlyphPage) iter.next();\r\n        maxGlyphsToLoad -= glyphPage.loadGlyphs(queuedGlyphs, maxGlyphsToLoad);\r\n        if (maxGlyphsToLoad == 0 || queuedGlyphs.isEmpty())\r\n            return true;\r\n    }\r\n    while (!queuedGlyphs.isEmpty()) {\r\n        GlyphPage glyphPage = new GlyphPage(this, glyphPageWidth, glyphPageHeight);\r\n        glyphPages.add(glyphPage);\r\n        maxGlyphsToLoad -= glyphPage.loadGlyphs(queuedGlyphs, maxGlyphsToLoad);\r\n        if (maxGlyphsToLoad == 0)\r\n            return true;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.lwjgl.util.mapped.MappedObject.capacity",
	"Comment": "returns the number of mapped objects that fit in the mapped buffer.",
	"Method": "int capacity(){\r\n    throw new InternalError(\"type not registered\");\r\n}"
}, {
	"Path": "com.openhtmltopdf.layout.SharedContext.setDefaultPageSize",
	"Comment": "set the default page dimensions. these may be overridden in css.\tif not set in css and null here, a4 will be used.",
	"Method": "void setDefaultPageSize(Float pageWidth,Float pageHeight,boolean isInches){\r\n    this.defaultPageWidth = pageWidth;\r\n    this.defaultPageHeight = pageHeight;\r\n    this.defaultPageSizeIsInches = isInches;\r\n}"
}, {
	"Path": "com.j256.ormlite.field.DatabaseFieldConfig.findMatchingEnumVal",
	"Comment": "internal method that finds the matching enum for a configured field that has the name argument.",
	"Method": "Enum<?> findMatchingEnumVal(Field field,String unknownEnumName){\r\n    if (unknownEnumName == null || unknownEnumName.length() == 0) {\r\n        return null;\r\n    }\r\n    for (Enum<?> enumVal : (Enum<?>[]) field.getType().getEnumConstants()) {\r\n        if (enumVal.name().equals(unknownEnumName)) {\r\n            return enumVal;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"Unknwown enum unknown name \" + unknownEnumName + \" for field \" + field);\r\n}"
}, {
	"Path": "org.lwjgl.examples.spaceinvaders.Game.removeEntity",
	"Comment": "remove an entity from the game. the entity removed will\tno longer move or be drawn.",
	"Method": "void removeEntity(Entity entity){\r\n    removeList.add(entity);\r\n}"
}, {
	"Path": "ddf.minim.analysis.FourierTransform.timeSize",
	"Comment": "returns the length of the time domain signal expected by this transform.",
	"Method": "int timeSize(){\r\n    return timeSize;\r\n}"
}, {
	"Path": "org.zalando.nakadi.service.EventTypeChangeListener.registerListener",
	"Comment": "it is impossible to unregister listener while receiving notification via authorizationchangelistener",
	"Method": "Closeable registerListener(Consumer<String> authorizationChangeListener,Collection<String> eventTypes){\r\n    final InternalListener listener = new InternalListener(eventTypes, authorizationChangeListener);\r\n    readWriteLock.writeLock().lock();\r\n    try {\r\n        eventTypes.stream().map(eventType -> eventTypeToListeners.computeIfAbsent(eventType, e -> new HashSet<InternalListener>())).forEach(cachedData -> cachedData.add(listener));\r\n    } finally {\r\n        readWriteLock.writeLock().unlock();\r\n    }\r\n    return listener;\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.BorderPainter.generateBorderBounds",
	"Comment": "generates a full round rectangle that is made of bounds and border",
	"Method": "Path2D generateBorderBounds(Rectangle bounds,BorderPropertySet border,boolean inside){\r\n    Path2D path = generateBorderShape(bounds, TOP, border, false, inside ? 1 : 0, 1);\r\n    path.append(generateBorderShape(bounds, RIGHT, border, false, inside ? 1 : 0, 1), true);\r\n    path.append(generateBorderShape(bounds, BOTTOM, border, false, inside ? 1 : 0, 1), true);\r\n    path.append(generateBorderShape(bounds, LEFT, border, false, inside ? 1 : 0, 1), true);\r\n    return path;\r\n}"
}, {
	"Path": "com.openhtmltopdf.pdfboxout.PdfBoxSlowOutputDevice.setMetadata",
	"Comment": "replaces all copies of the named metadata with a single value. a a newvalue of null will result in the removal of all copies of the namedmetadata. use addmetadata to append additional values withthe same name.",
	"Method": "void setMetadata(String name,String value){\r\n    if (name != null) {\r\n        boolean remove = (value == null);\r\n        int free = -1;\r\n        for (int i = 0, len = _metadata.size(); i < len; i++) {\r\n            Metadata m = _metadata.get(i);\r\n            if (m != null) {\r\n                if (m.getName().equalsIgnoreCase(name)) {\r\n                    if (!remove) {\r\n                        remove = true;\r\n                        m.setContent(value);\r\n                    } else {\r\n                        _metadata.set(i, null);\r\n                    }\r\n                }\r\n            } else if (free == -1) {\r\n                free = i;\r\n            }\r\n        }\r\n        if (!remove) {\r\n            Metadata m = new Metadata(name, value);\r\n            if (free == -1) {\r\n                _metadata.add(m);\r\n            } else {\r\n                _metadata.set(free, m);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.swing.AWTFontResolver.createFont",
	"Comment": "creates a concrete instance of a font at specified size, weight, style and variant.",
	"Method": "Font createFont(SharedContext ctx,Font rootFont,float size,IdentValue weight,IdentValue style,IdentValue variant){\r\n    int fontConst = Font.PLAIN;\r\n    if (weight != null && (weight == IdentValue.BOLD || weight == IdentValue.FONT_WEIGHT_700 || weight == IdentValue.FONT_WEIGHT_800 || weight == IdentValue.FONT_WEIGHT_900)) {\r\n        fontConst = fontConst | Font.BOLD;\r\n    }\r\n    if (style != null && (style == IdentValue.ITALIC || style == IdentValue.OBLIQUE)) {\r\n        fontConst = fontConst | Font.ITALIC;\r\n    }\r\n    size *= ctx.getTextRenderer().getFontScale();\r\n    Font fnt = rootFont.deriveFont(fontConst, size);\r\n    if (variant != null) {\r\n        if (variant == IdentValue.SMALL_CAPS) {\r\n            fnt = fnt.deriveFont((float) (((float) fnt.getSize()) * 0.6));\r\n        }\r\n    }\r\n    return fnt;\r\n}"
}, {
	"Path": "orestes.bloomfilter.BloomFilter.getBitsPerElement",
	"Comment": "calculates the numbers of bits per element, based on the expected number of inserted elementsexpectedelements.",
	"Method": "double getBitsPerElement(int n){\r\n    return config().size() / (double) n;\r\n}"
}, {
	"Path": "com.j256.ormlite.table.DatabaseTableConfig.fromClass",
	"Comment": "extract the databasetableconfig for a particular class by looking for class and field annotations. this is used\tby internal classes to configure a class.",
	"Method": "DatabaseTableConfig<T> fromClass(ConnectionSource connectionSource,Class<T> clazz){\r\n    DatabaseType databaseType = connectionSource.getDatabaseType();\r\n    String tableName = extractTableName(databaseType, clazz);\r\n    if (databaseType.isEntityNamesMustBeUpCase()) {\r\n        tableName = databaseType.upCaseEntityName(tableName);\r\n    }\r\n    return new DatabaseTableConfig<T>(databaseType, clazz, tableName, extractFieldTypes(connectionSource, clazz, tableName));\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testTransformWithinTransform",
	"Comment": "with static blocks, rotate then translate, no page margin, no block margin or padding.",
	"Method": "void testTransformWithinTransform(){\r\n    assertTrue(vt.runTest(\"transform-inside-transform\"));\r\n}"
}, {
	"Path": "org.newdawn.slick.Input.getAxisCount",
	"Comment": "get the number of axis that are avaiable on a given controller",
	"Method": "int getAxisCount(int controller){\r\n    return ((Controller) controllers.get(controller)).getAxisCount();\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.Configuration.valueAsChar",
	"Comment": "returns the value for key in the configuration as a character, or adefault value if not found. a warning is issued to the log if theproperty is not defined, or if the configuration value is too longto be a char. if the configuration value is longer than a singlecharacter, only the first character is returned.",
	"Method": "char valueAsChar(String key,char defaultVal){\r\n    String val = valueFor(key);\r\n    if (val == null) {\r\n        return defaultVal;\r\n    }\r\n    if (val.length() > 1) {\r\n        XRLog.exception(\"Property '\" + key + \"' was requested as a character. The value of '\" + val + \"' is too long to be a char. Returning only the first character.\");\r\n    }\r\n    return val.charAt(0);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.replay.Replay.getReplayFilename",
	"Comment": "returns the file name of where the replay should be saved and loaded,\tor null if the required fields are not set.",
	"Method": "String getReplayFilename(){\r\n    if (replayHash == null)\r\n        return null;\r\n    return String.format(\"%s-%d%d%d%d%d%d\", replayHash, hit300, hit100, hit50, geki, katu, miss);\r\n}"
}, {
	"Path": "io.opencensus.stats.Stats.loadStatsComponent",
	"Comment": "any provider that may be used for statscomponent can be added here.",
	"Method": "StatsComponent loadStatsComponent(ClassLoader classLoader){\r\n    try {\r\n        return Provider.createInstance(Class.forName(\"io.opencensus.impl.stats.StatsComponentImpl\", true, classLoader), StatsComponent.class);\r\n    } catch (ClassNotFoundException e) {\r\n        logger.log(Level.FINE, \"Couldn't load full implementation for StatsComponent, now trying to load lite \" + \"implementation.\", e);\r\n    }\r\n    try {\r\n        return Provider.createInstance(Class.forName(\"io.opencensus.impllite.stats.StatsComponentImplLite\", true, classLoader), StatsComponent.class);\r\n    } catch (ClassNotFoundException e) {\r\n        logger.log(Level.FINE, \"Couldn't load lite implementation for StatsComponent, now using \" + \"default implementation for StatsComponent.\", e);\r\n    }\r\n    return NoopStats.newNoopStatsComponent();\r\n}"
}, {
	"Path": "com.openhtmltopdf.context.StandardAttributeResolver.getLang",
	"Comment": "gets the lang attribute of the standardattributeresolver object",
	"Method": "String getLang(Object e){\r\n    return nsh.getLang((Element) e);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.render.FrameBufferCache.getInstance",
	"Comment": "there should only ever be one framebuffer cache, this function returns\tthat one framebuffer cache instance.\tif there was no instance created already then this function creates it.",
	"Method": "FrameBufferCache getInstance(){\r\n    if (instance == null)\r\n        instance = new FrameBufferCache();\r\n    return instance;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ui.UI.updateFPS",
	"Comment": "updates the fps display by a delta interval.\talso changes the frame rate if the window has lost or restored focus.",
	"Method": "void updateFPS(int delta){\r\n    boolean focus = (game.getCurrentStateID() == Opsu.STATE_GAME) ? true : container.hasFocus();\r\n    container.setTargetFrameRate(focus ? Options.getTargetFPS() : IDLE_FPS);\r\n    if (Options.isFPSCounterEnabled()) {\r\n        int fps = container.getFPS();\r\n        float multiplier = delta / 250f;\r\n        if (fpsDisplay < fps)\r\n            fpsDisplay = Math.min(fpsDisplay + (fps - fpsDisplay) * multiplier, fps);\r\n        else if (fpsDisplay > fps)\r\n            fpsDisplay = Math.max(fpsDisplay - (fpsDisplay - fps) * multiplier, fps);\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.swing.SwingReplacedElementFactory.storeImageReplacedElement",
	"Comment": "adds a replacedelement containing an image to a cache of images for quick lookup.",
	"Method": "void storeImageReplacedElement(Element e,ReplacedElement cc,String uri,int cssWidth,int cssHeight){\r\n    if (imageComponents == null) {\r\n        imageComponents = new HashMap();\r\n    }\r\n    CacheKey key = new CacheKey(e, uri, cssWidth, cssHeight);\r\n    imageComponents.put(key, cc);\r\n}"
}, {
	"Path": "org.newdawn.slick.openal.SoundStore.isPlaying",
	"Comment": "check if the supplied player is currently being polled by this\tsound store.",
	"Method": "boolean isPlaying(int index,boolean isPlaying,OpenALStreamPlayer player){\r\n    return stream == player;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.Pbuffer.releaseTexImage",
	"Comment": "releases the currently bound texture from the buffer specified.",
	"Method": "void releaseTexImage(int buffer){\r\n    checkDestroyed();\r\n    Display.getImplementation().releaseTexImageFromPbuffer(peer_info, buffer);\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.onDraw",
	"Comment": "draw method should not be called until the view has dimensions so the first calls are used as triggers to calculatethe scale and center.",
	"Method": "void onDraw(Canvas canvas){\r\n    super.onDraw(canvas);\r\n    createPaints();\r\n    if (sWidth == 0 || sHeight == 0 || bitmap == null || getWidth() == 0 || getHeight() == 0) {\r\n        return;\r\n    }\r\n    if (sPendingCenter != null && pendingScale != null) {\r\n        if (vTranslate == null) {\r\n            vTranslate = new PointF(0, 0);\r\n        }\r\n        scale = pendingScale;\r\n        vTranslate.x = (getWidth() / 2) - (scale * sPendingCenter.x);\r\n        vTranslate.y = (getHeight() / 2) - (scale * sPendingCenter.y);\r\n        sPendingCenter = null;\r\n        pendingScale = null;\r\n        fitToBounds(true);\r\n    }\r\n    fitToBounds(false);\r\n    if (!readySent) {\r\n        readySent = true;\r\n        new Thread(new Runnable() {\r\n            public void run() {\r\n                onImageReady();\r\n            }\r\n        }).start();\r\n    }\r\n    if (anim != null) {\r\n        long scaleElapsed = System.currentTimeMillis() - anim.time;\r\n        boolean finished = scaleElapsed > anim.duration;\r\n        scaleElapsed = Math.min(scaleElapsed, anim.duration);\r\n        scale = ease(anim.easing, scaleElapsed, anim.scaleStart, anim.scaleEnd - anim.scaleStart, anim.duration);\r\n        float vFocusNowX = ease(anim.easing, scaleElapsed, anim.vFocusStart.x, anim.vFocusEnd.x - anim.vFocusStart.x, anim.duration);\r\n        float vFocusNowY = ease(anim.easing, scaleElapsed, anim.vFocusStart.y, anim.vFocusEnd.y - anim.vFocusStart.y, anim.duration);\r\n        PointF vFocus = sourceToViewCoord(anim.sCenterEnd);\r\n        vTranslate.x -= vFocus.x - vFocusNowX;\r\n        vTranslate.y -= vFocus.y - vFocusNowY;\r\n        fitToBounds(finished || (anim.scaleStart == anim.scaleEnd));\r\n        if (finished) {\r\n            anim = null;\r\n        }\r\n        invalidate();\r\n    }\r\n    Matrix matrix = new Matrix();\r\n    matrix.postScale(scale, scale);\r\n    matrix.postRotate(getOrientation());\r\n    matrix.postTranslate(vTranslate.x, vTranslate.y);\r\n    if (getOrientation() == ORIENTATION_180) {\r\n        matrix.postTranslate(scale * sWidth, scale * sHeight);\r\n    } else if (getOrientation() == ORIENTATION_90) {\r\n        matrix.postTranslate(scale * sHeight, 0);\r\n    } else if (getOrientation() == ORIENTATION_270) {\r\n        matrix.postTranslate(0, scale * sWidth);\r\n    }\r\n    if (tileBgPaint != null) {\r\n        RectF sRect = new RectF(0f, 0f, sWidth, sHeight);\r\n        matrix.mapRect(sRect);\r\n        canvas.drawRect(sRect, tileBgPaint);\r\n    }\r\n    canvas.drawBitmap(bitmap, matrix, bitmapPaint);\r\n    if (debug) {\r\n        canvas.drawText(\"Scale: \" + String.format(\"%.2f\", scale), 5, 15, debugPaint);\r\n        canvas.drawText(\"Translate: \" + String.format(\"%.2f\", vTranslate.x) + \":\" + String.format(\"%.2f\", vTranslate.y), 5, 35, debugPaint);\r\n        PointF center = getCenter();\r\n        canvas.drawText(\"Source center: \" + String.format(\"%.2f\", center.x) + \":\" + String.format(\"%.2f\", center.y), 5, 55, debugPaint);\r\n        if (anim != null) {\r\n            PointF vCenterStart = sourceToViewCoord(anim.sCenterStart);\r\n            PointF vCenterEndRequested = sourceToViewCoord(anim.sCenterEndRequested);\r\n            PointF vCenterEnd = sourceToViewCoord(anim.sCenterEnd);\r\n            canvas.drawCircle(vCenterStart.x, vCenterStart.y, 10, debugPaint);\r\n            canvas.drawCircle(vCenterEndRequested.x, vCenterEndRequested.y, 20, debugPaint);\r\n            canvas.drawCircle(vCenterEnd.x, vCenterEnd.y, 25, debugPaint);\r\n            canvas.drawCircle(getWidth() / 2, getHeight() / 2, 30, debugPaint);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.onDraw",
	"Comment": "draw method should not be called until the view has dimensions so the first calls are used as triggers to calculatethe scale and center.",
	"Method": "void onDraw(Canvas canvas){\r\n    onImageReady();\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.animateScaleAndCenter",
	"Comment": "creates a scale animation builder, that when started will animate a zoom in or out. if this would move the imagebeyond the panning limits, the image is automatically panned during the animation.",
	"Method": "AnimationBuilder animateScaleAndCenter(float scale,PointF sCenter){\r\n    if (!isImageReady()) {\r\n        return null;\r\n    }\r\n    return new AnimationBuilder(scale, sCenter);\r\n}"
}, {
	"Path": "com.j256.ormlite.table.TableInfo.getFieldTypes",
	"Comment": "return the array of field types associated with the object.",
	"Method": "FieldType[] getFieldTypes(){\r\n    return fieldTypes;\r\n}"
}, {
	"Path": "ddf.minim.ugens.Bypass.activate",
	"Comment": "activate the bypass functionality. in other words, the wrapped ugen will not\thave an effect on the ugen patched to this bypass.",
	"Method": "void activate(){\r\n    mActive = true;\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.getGlyph",
	"Comment": "returns the glyph for the specified codepoint. if the glyph does not exist yet, \tit is created and queued to be loaded.",
	"Method": "Glyph getGlyph(int glyphCode,int codePoint,Rectangle bounds,GlyphVector vector,int index,Glyph getGlyph,int glyphCode,int codePoint,Rectangle bounds,GlyphVector vector,int index,UnicodeFont f){\r\n    if (glyphCode < 0 || glyphCode >= MAX_GLYPH_CODE) {\r\n        return new Glyph(codePoint, bounds, vector, index, this) {\r\n            @Override\r\n            public boolean isMissing() {\r\n                return true;\r\n            }\r\n        };\r\n    }\r\n    int pageIndex = glyphCode / PAGE_SIZE;\r\n    int glyphIndex = glyphCode & (PAGE_SIZE - 1);\r\n    Glyph glyph = null;\r\n    Glyph[] page = glyphs[pageIndex];\r\n    if (page != null) {\r\n        glyph = page[glyphIndex];\r\n        if (glyph != null)\r\n            return glyph;\r\n    } else\r\n        page = glyphs[pageIndex] = new Glyph[PAGE_SIZE];\r\n    glyph = page[glyphIndex] = new Glyph(codePoint, bounds, vector, index, f);\r\n    queuedGlyphs.add(glyph);\r\n    return glyph;\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.getGlyph",
	"Comment": "returns the glyph for the specified codepoint. if the glyph does not exist yet, \tit is created and queued to be loaded.",
	"Method": "Glyph getGlyph(int glyphCode,int codePoint,Rectangle bounds,GlyphVector vector,int index,Glyph getGlyph,int glyphCode,int codePoint,Rectangle bounds,GlyphVector vector,int index,UnicodeFont f){\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.paste",
	"Comment": "replaces the selection with the text on the dnd.clipboardclipboardor, if there is no selection,inserts the text at the current caret offset. if the widget has the swt.single style and the clipboard text contains more than one line, only the first line withoutline delimiters isinserted in the widget.",
	"Method": "void paste(){\r\n    checkWidget();\r\n    String text = (String) getClipboardContent(DND.CLIPBOARD);\r\n    if (text != null && text.length() > 0) {\r\n        if (blockSelection) {\r\n            boolean fillWithSpaces = isFixedLineHeight() && renderer.fixedPitch;\r\n            int offset = insertBlockSelectionText(text, fillWithSpaces);\r\n            setCaretOffset(offset, SWT.DEFAULT);\r\n            clearBlockSelection(true, true);\r\n            setCaretLocation();\r\n            return;\r\n        }\r\n        Event event = new Event();\r\n        event.start = selection.x;\r\n        event.end = selection.y;\r\n        event.text = getModelDelimitedText(text);\r\n        sendKeyEvent(event);\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.IOUtil.openStreamAtUrl",
	"Comment": "attempts to open a connection, and a stream, to the uri provided. timeouts will be set for opening the connectionand reading from it. will return the stream, or null if unable to open or read or a timeout occurred. does notbuffer the stream.",
	"Method": "InputStream openStreamAtUrl(String uri){\r\n    InputStream is = null;\r\n    try {\r\n        final URLConnection uc = new URL(uri).openConnection();\r\n        System.setProperty(\"sun.net.client.defaultConnectTimeout\", String.valueOf(10 * 1000));\r\n        System.setProperty(\"sun.net.client.defaultReadTimeout\", String.valueOf(30 * 1000));\r\n        uc.connect();\r\n        is = uc.getInputStream();\r\n    } catch (java.net.MalformedURLException e) {\r\n        XRLog.exception(\"bad URL given: \" + uri, e);\r\n    } catch (FileNotFoundException e) {\r\n        XRLog.exception(\"item at URI \" + uri + \" not found\");\r\n    } catch (IOException e) {\r\n        XRLog.exception(\"IO problem for \" + uri, e);\r\n    }\r\n    return is;\r\n}"
}, {
	"Path": "org.lwjgl.opencl.CLMem.getGLTextureInfoInt",
	"Comment": "returns the int value of the specified parameter. applicable to clmem objects\tthat have been created by gl textures only.",
	"Method": "int getGLTextureInfoInt(int param_name,int getGLTextureInfoInt,CLMem mem,int param_name){\r\n    return util.getGLTextureInfoInt(this, param_name);\r\n}"
}, {
	"Path": "com.android.volley.Request.setCacheEntry",
	"Comment": "annotates this request with an entry retrieved for it from cache.used for cache coherency support.",
	"Method": "Request<?> setCacheEntry(Cache.Entry entry){\r\n    mCacheEntry = entry;\r\n    return this;\r\n}"
}, {
	"Path": "ddf.minim.ugens.GranulateRandom.setAllTimeParameters",
	"Comment": "immediately sets all public class members concerning time to new values.",
	"Method": "void setAllTimeParameters(float grainLengthMin,float spaceLengthMin,float fadeLengthMin,float grainLengthMax,float spaceLengthMax,float fadeLengthMax){\r\n    setAllParameters(grainLengthMin, spaceLengthMin, fadeLengthMin, grainLengthMax, spaceLengthMax, fadeLengthMax, minAmp, maxAmp);\r\n}"
}, {
	"Path": "org.lwjgl.opengl.APIUtil.getBuffer",
	"Comment": "returns a buffer containing the specified strings as bytes.",
	"Method": "long getBuffer(ContextCapabilities caps,CharSequence string,long getBuffer,ContextCapabilities caps,CharSequence string,int offset,long getBuffer,ContextCapabilities caps,CharSequence[] strings){\r\n    final ByteBuffer buffer = getBufferByte(caps, getTotalLength(strings));\r\n    for (CharSequence string : strings) encode(buffer, string);\r\n    buffer.flip();\r\n    return MemoryUtil.getAddress0(buffer);\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.initialiseTileMap",
	"Comment": "once source image and view dimensions are known, creates a map of sample size to tile grid.",
	"Method": "void initialiseTileMap(Point maxTileDimensions){\r\n    this.tileMap = new LinkedHashMap<Integer, List<Tile>>();\r\n    int sampleSize = fullImageSampleSize;\r\n    int xTiles = 1;\r\n    int yTiles = 1;\r\n    while (true) {\r\n        int sTileWidth = sWidth() / xTiles;\r\n        int sTileHeight = sHeight() / yTiles;\r\n        int subTileWidth = sTileWidth / sampleSize;\r\n        int subTileHeight = sTileHeight / sampleSize;\r\n        while (subTileWidth > maxTileDimensions.x || (subTileWidth > getWidth() * 1.25 && sampleSize < fullImageSampleSize)) {\r\n            xTiles += 1;\r\n            sTileWidth = sWidth() / xTiles;\r\n            subTileWidth = sTileWidth / sampleSize;\r\n        }\r\n        while (subTileHeight > maxTileDimensions.y || (subTileHeight > getHeight() * 1.25 && sampleSize < fullImageSampleSize)) {\r\n            yTiles += 1;\r\n            sTileHeight = sHeight() / yTiles;\r\n            subTileHeight = sTileHeight / sampleSize;\r\n        }\r\n        List<Tile> tileGrid = new ArrayList<Tile>(xTiles * yTiles);\r\n        for (int x = 0; x < xTiles; x++) {\r\n            for (int y = 0; y < yTiles; y++) {\r\n                Tile tile = new Tile();\r\n                tile.sampleSize = sampleSize;\r\n                tile.visible = sampleSize == fullImageSampleSize;\r\n                tile.sRect = new Rect(x * sTileWidth, y * sTileHeight, (x + 1) * sTileWidth, (y + 1) * sTileHeight);\r\n                tileGrid.add(tile);\r\n            }\r\n        }\r\n        tileMap.put(sampleSize, tileGrid);\r\n        if (sampleSize == 1) {\r\n            break;\r\n        } else {\r\n            sampleSize /= 2;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.awt.X11.XWindow.xSetBackground",
	"Comment": "do a full paint for most peers. so we cannot call setbackground in postinit.",
	"Method": "void xSetBackground(Color c){\r\n    XToolkit.awtLock();\r\n    try {\r\n        winBackground(c);\r\n        if (!doEraseBackground()) {\r\n            return;\r\n        }\r\n        ColorModel cm = getColorModel();\r\n        int pixel = PixelConverter.instance.rgbToPixel(c.getRGB(), cm);\r\n        XlibWrapper.XSetWindowBackground(XToolkit.getDisplay(), getContentWindow(), pixel);\r\n    } finally {\r\n        XToolkit.awtUnlock();\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.skins.Skin.getStarBreakAdditiveColor",
	"Comment": "returns the color of the stars that fall from the cursor during breaks.",
	"Method": "Color getStarBreakAdditiveColor(){\r\n    return starBreakAdditive;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.states.Game.calculateStacks",
	"Comment": "performs stacking calculations on all hit objects, and updates their\tpositions if necessary.",
	"Method": "void calculateStacks(){\r\n    for (int i = gameObjects.length - 1; i > 0; i--) {\r\n        HitObject hitObjectI = beatmap.objects[i];\r\n        if (hitObjectI.getStack() != 0 || hitObjectI.isSpinner())\r\n            continue;\r\n        for (int n = i - 1; n >= 0; n--) {\r\n            HitObject hitObjectN = beatmap.objects[n];\r\n            if (hitObjectN.isSpinner())\r\n                continue;\r\n            float timeI = hitObjectI.getTime() - (approachTime * beatmap.stackLeniency);\r\n            float timeN = hitObjectN.isSlider() ? gameObjects[n].getEndTime() : hitObjectN.getTime();\r\n            if (timeI > timeN)\r\n                break;\r\n            if (hitObjectN.isSlider()) {\r\n                Vec2f p1 = gameObjects[i].getPointAt(hitObjectI.getTime());\r\n                Vec2f p2 = gameObjects[n].getPointAt(gameObjects[n].getEndTime());\r\n                float distance = Utils.distance(p1.x, p1.y, p2.x, p2.y);\r\n                if (distance < STACK_LENIENCE * HitObject.getXMultiplier()) {\r\n                    int offset = hitObjectI.getStack() - hitObjectN.getStack() + 1;\r\n                    for (int j = n + 1; j <= i; j++) {\r\n                        HitObject hitObjectJ = beatmap.objects[j];\r\n                        p1 = gameObjects[j].getPointAt(hitObjectJ.getTime());\r\n                        distance = Utils.distance(p1.x, p1.y, p2.x, p2.y);\r\n                        if (distance < STACK_LENIENCE * HitObject.getXMultiplier())\r\n                            hitObjectJ.setStack(hitObjectJ.getStack() - offset);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            float distance = Utils.distance(hitObjectI.getX(), hitObjectI.getY(), hitObjectN.getX(), hitObjectN.getY());\r\n            if (distance < STACK_LENIENCE) {\r\n                hitObjectN.setStack(hitObjectI.getStack() + 1);\r\n                hitObjectI = hitObjectN;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < gameObjects.length; i++) {\r\n        if (beatmap.objects[i].getStack() != 0)\r\n            gameObjects[i].updatePosition();\r\n    }\r\n}"
}, {
	"Path": "com.android.volley.Request.getCacheKey",
	"Comment": "returns the cache key for this request.by default, this is the url.",
	"Method": "String getCacheKey(){\r\n    return mMethod + \":\" + mUrl;\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.displaylist.PagedBoxCollector.findLayerPages",
	"Comment": "returns the pages a layer appears on including inserted overflow pages.takes into account any transform and overflow hidden clipping.",
	"Method": "List<PageInfo> findLayerPages(CssContext c,Layer layer,List<PageBox> pages){\r\n    PageFinder finder = new PageFinder(pages);\r\n    Rectangle bounds = findLayerRect(c, layer);\r\n    Box container = layer.getMaster();\r\n    AffineTransform transform = container.getContainingLayer().getCurrentTransformMatrix();\r\n    Area overflowClip = container.getAbsoluteClipBox(c);\r\n    transformBounds(bounds, transform);\r\n    bounds = applyOverflowClip(bounds, overflowClip);\r\n    int firstPage = finder.findPageAdjusted(c, (int) bounds.getMinY());\r\n    int lastPage = finder.findPageAdjusted(c, (int) bounds.getMaxY());\r\n    List<PageInfo> result = new ArrayList<PageInfo>();\r\n    for (int i = firstPage; i <= lastPage; i++) {\r\n        result.add(new PageInfo(i, PageInfo.BASE_PAGE));\r\n        if (pages.get(i).shouldInsertPages()) {\r\n            int maxXShadowPage = pages.get(i).getMaxShadowPagesForXPos(c, (int) bounds.getMaxX());\r\n            int minXShadowPage = pages.get(i).getMaxShadowPagesForXPos(c, (int) bounds.getMinX());\r\n            int shadowPageCount = Math.max(maxXShadowPage, minXShadowPage);\r\n            shadowPageCount = Math.min(shadowPageCount, pages.get(i).getMaxInsertedPages());\r\n            for (int j = 0; j < shadowPageCount; j++) {\r\n                result.add(new PageInfo(i, j));\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.DownloadList.getDownload",
	"Comment": "gets the download for a beatmap set id, or null if not in the list.",
	"Method": "Download getDownload(int beatmapSetID){\r\n    DownloadNode node = map.get(beatmapSetID);\r\n    return (node == null) ? null : node.getDownload();\r\n}"
}, {
	"Path": "com.j256.ormlite.dao.EagerForeignCollection.equals",
	"Comment": "this is just a call to the equals method of the internal results list.",
	"Method": "boolean equals(Object obj){\r\n    if (!(obj instanceof EagerForeignCollection)) {\r\n        return false;\r\n    }\r\n    @SuppressWarnings(\"rawtypes\")\r\n    EagerForeignCollection other = (EagerForeignCollection) obj;\r\n    return results.equals(other.results);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.Updater.getBuildDate",
	"Comment": "returns the build date, or the current date if not available.",
	"Method": "int getBuildDate(){\r\n    if (buildDate == -1) {\r\n        Date date = null;\r\n        try {\r\n            Properties props = new Properties();\r\n            props.load(ResourceLoader.getResourceAsStream(Options.VERSION_FILE));\r\n            String build = props.getProperty(\"build.date\");\r\n            if (build == null || build.equals(\"${timestamp}\") || build.equals(\"${maven.build.timestamp}\"))\r\n                date = new Date();\r\n            else {\r\n                DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm\", Locale.ENGLISH);\r\n                date = format.parse(build);\r\n            }\r\n        } catch (Exception e) {\r\n            date = new Date();\r\n        } finally {\r\n            DateFormat dateFormat = new SimpleDateFormat(\"yyyyMMdd\");\r\n            buildDate = Integer.parseInt(dateFormat.format(date));\r\n        }\r\n    }\r\n    return buildDate;\r\n}"
}, {
	"Path": "org.lwjgl.opencl.CLMem.getImageFormat",
	"Comment": "returns the image format. applicable to image objects only.",
	"Method": "CLImageFormat getImageFormat(){\r\n    return util.getImageInfoFormat(this);\r\n}"
}, {
	"Path": "org.lwjgl.input.Keyboard.getEventKey",
	"Comment": "please note that the key code returned is not valid against thecurrent keyboard layout. to get the actual character pressed callgeteventcharacter",
	"Method": "int getEventKey(){\r\n    synchronized (OpenGLPackageAccess.global_lock) {\r\n        return current_event.key;\r\n    }\r\n}"
}, {
	"Path": "org.newdawn.slick.Image.drawWarped",
	"Comment": "draw the image in a warper rectangle. the effects this can \thave are many and varied, might be interesting though.",
	"Method": "void drawWarped(float x1,float y1,float x2,float y2,float x3,float y3,float x4,float y4){\r\n    Color.white.bind();\r\n    texture.bind();\r\n    GL.glTranslatef(x1, y1, 0);\r\n    if (angle != 0) {\r\n        GL.glTranslatef(centerX, centerY, 0.0f);\r\n        GL.glRotatef(angle, 0.0f, 0.0f, 1.0f);\r\n        GL.glTranslatef(-centerX, -centerY, 0.0f);\r\n    }\r\n    GL.glBegin(SGL.GL_QUADS);\r\n    init();\r\n    GL.glTexCoord2f(textureOffsetX, textureOffsetY);\r\n    GL.glVertex3f(0, 0, 0);\r\n    GL.glTexCoord2f(textureOffsetX, textureOffsetY + textureHeight);\r\n    GL.glVertex3f(x2 - x1, y2 - y1, 0);\r\n    GL.glTexCoord2f(textureOffsetX + textureWidth, textureOffsetY + textureHeight);\r\n    GL.glVertex3f(x3 - x1, y3 - y1, 0);\r\n    GL.glTexCoord2f(textureOffsetX + textureWidth, textureOffsetY);\r\n    GL.glVertex3f(x4 - x1, y4 - y1, 0);\r\n    GL.glEnd();\r\n    if (angle != 0) {\r\n        GL.glTranslatef(centerX, centerY, 0.0f);\r\n        GL.glRotatef(-angle, 0.0f, 0.0f, 1.0f);\r\n        GL.glTranslatef(-centerX, -centerY, 0.0f);\r\n    }\r\n    GL.glTranslatef(-x1, -y1, 0);\r\n}"
}, {
	"Path": "org.lwjgl.input.ControllerEvent.getButtonState",
	"Comment": "check the button is pressed or not, when this event was caused",
	"Method": "boolean getButtonState(){\r\n    return buttonState;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doSelectionLineDown",
	"Comment": "moves the caret one line down and to the same character offset relative to the beginning of the line. moves the caret to the end of the new line if the new line is shorter than the character offset.moves the caret to the end of the text if the caret already is on the last line.adjusts the selection according to the caret change. this can either addto or subtract from the old selection, depending on the previous selectiondirection.",
	"Method": "void doSelectionLineDown(){\r\n    int oldColumnX = columnX = getPointAtOffset(caretOffset).x;\r\n    doLineDown(true);\r\n    columnX = oldColumnX;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.PixelFormat.withAccumulationBitsPerPixel",
	"Comment": "returns a new pixelformat object with the same properties as this pixelformat and the new bits per pixel in the accumulation buffer value.",
	"Method": "PixelFormat withAccumulationBitsPerPixel(int accum_bpp){\r\n    if (accum_bpp < 0)\r\n        throw new IllegalArgumentException(\"Invalid number of bits per pixel in the accumulation buffer specified: \" + accum_bpp);\r\n    final PixelFormat pf = new PixelFormat(this);\r\n    pf.accum_bpp = accum_bpp;\r\n    return pf;\r\n}"
}, {
	"Path": "ddf.minim.AudioPlayer.getMetaData",
	"Comment": "returns the meta data for the recording being played by this player.",
	"Method": "AudioMetaData getMetaData(){\r\n    return recording.getMetaData();\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.wasAtRest",
	"Comment": "check if the spring was at rest in the prior iteration. this is used for ensuring the endingcallbacks are fired as the spring comes to a rest.",
	"Method": "boolean wasAtRest(){\r\n    return mWasAtRest;\r\n}"
}, {
	"Path": "ddf.minim.MultiChannelBuffer.getChannel",
	"Comment": "returns the requested channel as a float array.\tyou should not necessarily assume that the \tmodifying the returned array will modify \tthe values in this buffer.",
	"Method": "float[] getChannel(int channelNumber){\r\n    return channels[channelNumber];\r\n}"
}, {
	"Path": "com.openhtmltopdf.layout.Layer.collectLayers",
	"Comment": "called recusively to collect all descendant layers in a stacking context so they can be painted in correct order.those descendants that are under their own stacking contexts are excluded.",
	"Method": "List<Layer> collectLayers(int which){\r\n    List<Layer> result = new ArrayList<Layer>();\r\n    List<Layer> children = getChildren();\r\n    result.addAll(getStackingContextLayers(which));\r\n    for (Layer child : children) {\r\n        if (!child.isStackingContext()) {\r\n            if (which == AUTO && child.isZIndexAuto()) {\r\n                result.add(child);\r\n            } else if (which == NEGATIVE && child.getZIndex() < 0) {\r\n                result.add(child);\r\n            } else if (which == POSITIVE && child.getZIndex() > 0) {\r\n                result.add(child);\r\n            } else if (which == ZERO && !child.isZIndexAuto() && child.getZIndex() == 0) {\r\n                result.add(child);\r\n            }\r\n            result.addAll(child.collectLayers(which));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGL.eglGetCurrentContext",
	"Comment": "returns the current egl context for the current rendering api.\tif there is no context current, null is returned.",
	"Method": "EGLContext eglGetCurrentContext(){\r\n    final long ctx = neglGetCurrentContext();\r\n    if (ctx == EGL_NO_CONTEXT)\r\n        return null;\r\n    final EGLDisplay display = eglGetCurrentDisplay();\r\n    final IntBuffer attrib_list = APIUtil.getBufferInt();\r\n    neglQueryContext(display.getPointer(), ctx, EGL_CONFIG_ID, MemoryUtil.getAddress0(attrib_list));\r\n    final EGLConfig config = getEGLConfig(display, attrib_list);\r\n    return new EGLContext(display, config, ctx);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.handleMouseDown",
	"Comment": "updates the caret location and selection if mouse button 1 has been pressed.",
	"Method": "void handleMouseDown(Event event){\r\n    forceFocus();\r\n    if (dragDetect && checkDragDetect(event))\r\n        return;\r\n    if (event.button == 2) {\r\n        String text = (String) getClipboardContent(DND.SELECTION_CLIPBOARD);\r\n        if (text != null && text.length() > 0) {\r\n            doMouseLocationChange(event.x, event.y, false);\r\n            Event e = new Event();\r\n            e.start = selection.x;\r\n            e.end = selection.y;\r\n            e.text = getModelDelimitedText(text);\r\n            sendKeyEvent(e);\r\n        }\r\n    }\r\n    if ((event.button != 1) || (IS_MAC && (event.stateMask & SWT.MOD4) != 0)) {\r\n        return;\r\n    }\r\n    clickCount = event.count;\r\n    if (clickCount == 1) {\r\n        boolean select = (event.stateMask & SWT.MOD2) != 0;\r\n        doMouseLocationChange(event.x, event.y, select);\r\n    } else {\r\n        if (doubleClickEnabled) {\r\n            boolean wordSelect = (clickCount & 1) == 0;\r\n            int offset = getOffsetAtPoint(event.x, event.y, null);\r\n            int lineIndex = content.getLineAtOffset(offset);\r\n            int lineOffset = content.getOffsetAtLine(lineIndex);\r\n            if (wordSelect) {\r\n                int min = blockSelection ? lineOffset : 0;\r\n                int max = blockSelection ? lineOffset + content.getLine(lineIndex).length() : content.getCharCount();\r\n                int start = Math.max(min, getWordPrevious(offset, SWT.MOVEMENT_WORD_START));\r\n                int end = Math.min(max, getWordNext(start, SWT.MOVEMENT_WORD_END));\r\n                setSelection(start, end - start, false, true);\r\n                sendSelectionEvent();\r\n            } else {\r\n                if (blockSelection) {\r\n                    setBlockSelectionLocation(leftMargin, event.y, clientAreaWidth - rightMargin, event.y, true);\r\n                } else {\r\n                    int lineEnd = content.getCharCount();\r\n                    if (lineIndex + 1 < content.getLineCount()) {\r\n                        lineEnd = content.getOffsetAtLine(lineIndex + 1);\r\n                    }\r\n                    setSelection(lineOffset, lineEnd - lineOffset, false, false);\r\n                    sendSelectionEvent();\r\n                }\r\n            }\r\n            doubleClickSelection = new Point(selection.x, selection.y);\r\n            showCaret();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testHorizPageOverflowFixed",
	"Comment": "tests that fixed blocks do not overflow onto inserted shadow pages.",
	"Method": "void testHorizPageOverflowFixed(){\r\n    assertTrue(vt.runTest(\"horiz-page-overflow-fixed\"));\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.ScalingOptions.applyRenderingHints",
	"Comment": "applies any rendering hints configured for these scalingoptions to a graphics2d instance before image\toperations are called on it. these might be",
	"Method": "void applyRenderingHints(Graphics2D g2){\r\n    g2.setRenderingHints(getRenderingHints());\r\n}"
}, {
	"Path": "org.lwjgl.examples.spaceinvaders.Game.frameRendering",
	"Comment": "notification that a frame is being rendered. responsible for\trunning game logic and rendering the scene.",
	"Method": "void frameRendering(){\r\n    Display.sync(60);\r\n    long delta = getTime() - lastLoopTime;\r\n    lastLoopTime = getTime();\r\n    lastFpsTime += delta;\r\n    fps++;\r\n    if (lastFpsTime >= 1000) {\r\n        Display.setTitle(WINDOW_TITLE + \" (FPS: \" + fps + \")\");\r\n        lastFpsTime = 0;\r\n        fps = 0;\r\n    }\r\n    if (!waitingForKeyPress && !soundManager.isPlayingSound()) {\r\n        for (Entity entity : entities) {\r\n            entity.move(delta);\r\n        }\r\n    }\r\n    for (Entity entity : entities) {\r\n        entity.draw();\r\n    }\r\n    for (int p = 0; p < entities.size(); p++) {\r\n        for (int s = p + 1; s < entities.size(); s++) {\r\n            Entity me = entities.get(p);\r\n            Entity him = entities.get(s);\r\n            if (me.collidesWith(him)) {\r\n                me.collidedWith(him);\r\n                him.collidedWith(me);\r\n            }\r\n        }\r\n    }\r\n    entities.removeAll(removeList);\r\n    removeList.clear();\r\n    if (logicRequiredThisLoop) {\r\n        for (Entity entity : entities) {\r\n            entity.doLogic();\r\n        }\r\n        logicRequiredThisLoop = false;\r\n    }\r\n    if (waitingForKeyPress) {\r\n        message.draw(325, 250);\r\n    }\r\n    ship.setHorizontalMovement(0);\r\n    mouseX = Mouse.getDX();\r\n    boolean leftPressed = hasInput(Keyboard.KEY_LEFT);\r\n    boolean rightPressed = hasInput(Keyboard.KEY_RIGHT);\r\n    boolean firePressed = hasInput(Keyboard.KEY_SPACE);\r\n    if (!waitingForKeyPress && !soundManager.isPlayingSound()) {\r\n        if ((leftPressed) && (!rightPressed)) {\r\n            ship.setHorizontalMovement(-moveSpeed);\r\n        } else if ((rightPressed) && (!leftPressed)) {\r\n            ship.setHorizontalMovement(moveSpeed);\r\n        }\r\n        if (firePressed) {\r\n            tryToFire();\r\n        }\r\n    } else {\r\n        if (!firePressed) {\r\n            fireHasBeenReleased = true;\r\n        }\r\n        if ((firePressed) && (fireHasBeenReleased) && !soundManager.isPlayingSound()) {\r\n            waitingForKeyPress = false;\r\n            fireHasBeenReleased = false;\r\n            startGame();\r\n            soundManager.playSound(SOUND_START);\r\n        }\r\n    }\r\n    if ((Display.isCloseRequested() || Keyboard.isKeyDown(Keyboard.KEY_ESCAPE)) && isApplication) {\r\n        Game.gameRunning = false;\r\n    }\r\n}"
}, {
	"Path": "io.opencensus.implcore.stats.StatsTestUtil.assertAggregationMapEquals",
	"Comment": "compare the actual and expected aggregationmap within the given tolerance.",
	"Method": "void assertAggregationMapEquals(Map<? extends List<? extends TagValue>, ? extends AggregationData> actual,Map<? extends List<? extends TagValue>, ? extends AggregationData> expected,double tolerance){\r\n    assertThat(actual.keySet()).containsExactlyElementsIn(expected.keySet());\r\n    for (Entry<? extends List<? extends TagValue>, ? extends AggregationData> entry : actual.entrySet()) {\r\n        assertAggregationDataEquals(expected.get(entry.getKey()), entry.getValue(), tolerance);\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.opengles.APIUtil.getLengths",
	"Comment": "returns a buffer containing the lengths of the specified strings.",
	"Method": "IntBuffer getLengths(IntBuffer getLengths,int size,long getLengths,CharSequence[] strings){\r\n    IntBuffer buffer = getLengths(strings.length);\r\n    for (CharSequence string : strings) buffer.put(string.length());\r\n    buffer.flip();\r\n    return MemoryUtil.getAddress0(buffer);\r\n}"
}, {
	"Path": "ddf.minim.analysis.FourierTransform.setFreq",
	"Comment": "sets the amplitude of the requested frequency in the spectrum toa.",
	"Method": "void setFreq(float freq,float a){\r\n    setBand(freqToIndex(freq), a);\r\n}"
}, {
	"Path": "com.j256.ormlite.table.DatabaseTableConfig.extractFieldTypes",
	"Comment": "extract the field types from the fieldconfigs if they have not already been configured.",
	"Method": "void extractFieldTypes(ConnectionSource connectionSource,FieldType[] extractFieldTypes,ConnectionSource connectionSource,Class<T> clazz,String tableName){\r\n    List<FieldType> fieldTypes = new ArrayList<FieldType>();\r\n    for (Class<?> classWalk = clazz; classWalk != null; classWalk = classWalk.getSuperclass()) {\r\n        for (Field field : classWalk.getDeclaredFields()) {\r\n            FieldType fieldType = FieldType.createFieldType(connectionSource, tableName, field, clazz);\r\n            if (fieldType != null) {\r\n                fieldTypes.add(fieldType);\r\n            }\r\n        }\r\n    }\r\n    if (fieldTypes.isEmpty()) {\r\n        throw new IllegalArgumentException(\"No fields have a \" + DatabaseField.class.getSimpleName() + \" annotation in \" + clazz);\r\n    }\r\n    return fieldTypes.toArray(new FieldType[fieldTypes.size()]);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.setStyleRange",
	"Comment": "adds the specified style.the new style overwrites existing styles for the specified range.existing style ranges are adjusted if they partially overlap with the new style. to clear an individual style, call setstylerange with a stylerange that has null attributes. should not be called if a linestylelistener has been set since the listener maintains the styles.",
	"Method": "void setStyleRange(StyleRange range){\r\n    checkWidget();\r\n    if (isListening(ST.LineGetStyle))\r\n        return;\r\n    if (range != null) {\r\n        if (range.isUnstyled()) {\r\n            setStyleRanges(range.start, range.length, null, null, false);\r\n        } else {\r\n            setStyleRanges(range.start, 0, null, new StyleRange[] { range }, false);\r\n        }\r\n    } else {\r\n        setStyleRanges(0, 0, null, null, true);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.addCaretListener",
	"Comment": "adds a caret listener. caretevent is sent when the caret offset changes.",
	"Method": "void addCaretListener(CaretListener listener){\r\n    checkWidget();\r\n    if (listener == null)\r\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\r\n    addListener(ST.CaretMoved, new StyledTextListener(listener));\r\n}"
}, {
	"Path": "org.newdawn.slick.openal.SoundStore.setMaxSources",
	"Comment": "set the maximum number of concurrent sound effects that will be \tattempted",
	"Method": "void setMaxSources(int max){\r\n    this.maxSources = max;\r\n}"
}, {
	"Path": "io.opencensus.exporter.trace.ocagent.OcAgentNodeUtils.getLibraryInfo",
	"Comment": "creates library info with the given opencensus java version.",
	"Method": "LibraryInfo getLibraryInfo(String currentOcJavaVersion){\r\n    return LibraryInfo.newBuilder().setLanguage(Language.JAVA).setCoreLibraryVersion(currentOcJavaVersion).setExporterVersion(OC_AGENT_EXPORTER_VERSION).build();\r\n}"
}, {
	"Path": "com.android.volley.toolbox.NetworkImageView.getImageURL",
	"Comment": "gets the url of the image that should be loaded into this view, or null if no url has been set.the image may or may not already be downloaded and set into the view.",
	"Method": "String getImageURL(){\r\n    return mUrl;\r\n}"
}, {
	"Path": "org.newdawn.slick.GameContainer.setMaximumLogicUpdateInterval",
	"Comment": "set the maximum amount of time in milliseconds that can passed\tinto the update method. useful for collision detection without\tsweeping.",
	"Method": "void setMaximumLogicUpdateInterval(int interval){\r\n    maximumLogicInterval = interval;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.objects.Slider.getCircleAlphaAfterRepeat",
	"Comment": "get the alpha level used to fade in circles & reversearrows after repeat",
	"Method": "float getCircleAlphaAfterRepeat(int trackPosition,boolean endCircle){\r\n    int ticksN = ticksT == null ? 0 : ticksT.length;\r\n    float t = getT(trackPosition, false);\r\n    if (endCircle) {\r\n        t = 1f - t;\r\n    }\r\n    if (currentRepeats % 2 == (endCircle ? 0 : 1)) {\r\n        t = 1f;\r\n    }\r\n    return Utils.clamp(t * (ticksN + 1), 0f, 1f);\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.value.FSCssValue.setCssText",
	"Comment": "not supported, class is immutable. sets the string representation of thecurrent value.",
	"Method": "void setCssText(String cssText){\r\n    this._cssText = cssText;\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.XRLog.setLoggingEnabled",
	"Comment": "turns logging on or off, without affecting logging configuration.",
	"Method": "void setLoggingEnabled(boolean loggingEnabled){\r\n    XRLog.loggingEnabled = loggingEnabled;\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testHorizPageOverflowHiddenHidden",
	"Comment": "tests that overflow hidden clipping works on generated shadow page. includes case where contentis absolute block and a case where content is a static block.",
	"Method": "void testHorizPageOverflowHiddenHidden(){\r\n    assertTrue(vt.runTest(\"horiz-page-overflow-hidden-hidden\"));\r\n}"
}, {
	"Path": "com.snowcattle.game.service.net.proxy.handler.ProxyFrontendHandler.closeOnFlush",
	"Comment": "closes the specified channel after all queued write requests are flushed.",
	"Method": "void closeOnFlush(Channel ch){\r\n    if (ch.isActive()) {\r\n        ch.flush();\r\n        ch.close();\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.util.glu.Quadric.setTextureFlag",
	"Comment": "specifies if texture coordinates should be generated forquadrics rendered with qobj. if the value of texturecoords is true,then texture coordinates are generated, and if texturecoords is false,they are not.. the default is false.the manner in which texture coordinates are generated depends upon thespecific quadric rendered.",
	"Method": "void setTextureFlag(boolean textureFlag){\r\n    this.textureFlag = textureFlag;\r\n}"
}, {
	"Path": "com.j256.ormlite.dao.DaoManager.addCachedDatabaseConfigs",
	"Comment": "this adds database table configurations to the internal cache which can be used to speed up dao construction.\tthis is especially true of android and other mobile platforms.",
	"Method": "void addCachedDatabaseConfigs(Collection<DatabaseTableConfig<?>> configs){\r\n    Map<Class<?>, DatabaseTableConfig<?>> newMap;\r\n    if (configMap == null) {\r\n        newMap = new HashMap<Class<?>, DatabaseTableConfig<?>>();\r\n    } else {\r\n        newMap = new HashMap<Class<?>, DatabaseTableConfig<?>>(configMap);\r\n    }\r\n    for (DatabaseTableConfig<?> config : configs) {\r\n        newMap.put(config.getDataClass(), config);\r\n        logger.info(\"Loaded configuration for {}\", config.getDataClass());\r\n    }\r\n    configMap = newMap;\r\n}"
}, {
	"Path": "com.joestelmach.natty.WalkerState.seekToSeason",
	"Comment": "seeks forward or backwards to a particular season based on the current date",
	"Method": "void seekToSeason(String seasonString,String direction,String seekAmount){\r\n    Season season = Season.valueOf(seasonString);\r\n    assert (season != null);\r\n    seekToIcsEvent(SEASON_ICS_FILE, season.getSummary(), direction, seekAmount);\r\n}"
}, {
	"Path": "ddf.minim.AudioSource.type",
	"Comment": "the type is an int describing the number of channels\tthis sound object has.",
	"Method": "int type(){\r\n    return stream.getFormat().getChannels();\r\n}"
}, {
	"Path": "ddf.minim.signals.Oscillator.setFreq",
	"Comment": "sets the frequency of the oscillator in hz. if portamento is on, thefrequency of the oscillator will transition from the current frequency tof.",
	"Method": "void setFreq(float f){\r\n    newFreq = f;\r\n    float msStep = (newFreq - freq) / portSpeed;\r\n    float spms = srate / 1000;\r\n    portStep = msStep / spms;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.BeatmapSetNode.getInfo",
	"Comment": "returns an array of strings containing beatmap information for the\tselected beatmap, or null if none selected.",
	"Method": "String[] getInfo(){\r\n    return (beatmapIndex < 0) ? null : beatmapSet.getInfo(beatmapIndex);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.setClipboardContent",
	"Comment": "copies the specified text range to the clipboard.the text will be placedin the clipboard in plain text format and rtf format.",
	"Method": "void setClipboardContent(int start,int length,int clipboardType){\r\n    if (clipboardType == DND.SELECTION_CLIPBOARD && !(IS_MOTIF || IS_GTK))\r\n        return;\r\n    TextTransfer plainTextTransfer = TextTransfer.getInstance();\r\n    TextWriter plainTextWriter = new TextWriter(start, length);\r\n    String plainText = getPlatformDelimitedText(plainTextWriter);\r\n    Object[] data;\r\n    Transfer[] types;\r\n    if (clipboardType == DND.SELECTION_CLIPBOARD) {\r\n        data = new Object[] { plainText };\r\n        types = new Transfer[] { plainTextTransfer };\r\n    } else {\r\n        RTFTransfer rtfTransfer = RTFTransfer.getInstance();\r\n        RTFWriter rtfWriter = new RTFWriter(start, length);\r\n        String rtfText = getPlatformDelimitedText(rtfWriter);\r\n        data = new Object[] { rtfText, plainText };\r\n        types = new Transfer[] { rtfTransfer, plainTextTransfer };\r\n    }\r\n    clipboard.setContents(data, types, clipboardType);\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.setEndValue",
	"Comment": "set the rest value to determine the displacement for the spring",
	"Method": "Spring setEndValue(double endValue){\r\n    if (mEndValue == endValue && isAtRest()) {\r\n        return this;\r\n    }\r\n    mStartValue = getCurrentValue();\r\n    mEndValue = endValue;\r\n    mSpringSystem.activateSpring(this.getId());\r\n    for (SpringListener listener : mListeners) {\r\n        listener.onSpringEndStateChange(this);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "me.imid.swipebacklayout.lib.ViewDragHelper.canScroll",
	"Comment": "tests scrollability within child views of v given a delta of dx.",
	"Method": "boolean canScroll(View v,boolean checkV,int dx,int dy,int x,int y){\r\n    if (v instanceof ViewGroup) {\r\n        final ViewGroup group = (ViewGroup) v;\r\n        final int scrollX = v.getScrollX();\r\n        final int scrollY = v.getScrollY();\r\n        final int count = group.getChildCount();\r\n        for (int i = count - 1; i >= 0; i--) {\r\n            final View child = group.getChildAt(i);\r\n            if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && canScroll(child, true, dx, dy, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return checkV && (ViewCompat.canScrollHorizontally(v, -dx) || ViewCompat.canScrollVertically(v, -dy));\r\n}"
}, {
	"Path": "org.newdawn.slick.Input.getAbsoluteMouseX",
	"Comment": "get the absolute x position of the mouse cursor within the container",
	"Method": "int getAbsoluteMouseX(){\r\n    return Mouse.getX();\r\n}"
}, {
	"Path": "org.newdawn.slick.Input.getAbsoluteMouseY",
	"Comment": "get the absolute y position of the mouse cursor within the container",
	"Method": "int getAbsoluteMouseY(){\r\n    return height - Mouse.getY() - 1;\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.displaylist.PagedBoxCollector.addLineBoxToAll",
	"Comment": "adds a line box to the base page if needed and any shadow pages as needed.",
	"Method": "void addLineBoxToAll(CssContext c,Layer layer,LineBox container,int basePageNumber,boolean includeShadowPages){\r\n    PageResult pageResult = getPageResult(basePageNumber);\r\n    PageBox pageBox = getPageBox(basePageNumber);\r\n    Rectangle pageClip = pageResult.getContentWindowOnDocument(pageBox, c);\r\n    if (intersectsAggregateBounds(pageClip, container)) {\r\n        pageResult.addInline(container);\r\n        ((LineBox) container).addAllChildren(pageResult._inlines, layer);\r\n    }\r\n    if (includeShadowPages && pageBox.shouldInsertPages()) {\r\n        addBoxToShadowPages(c, container, basePageNumber, pageResult, null, null, layer, AddInlineToShadowPage.INSTANCE);\r\n    }\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.setZoomEnabled",
	"Comment": "enable or disable zoom gesture detection. disabling zoom locks the the current scale.",
	"Method": "void setZoomEnabled(boolean zoomEnabled){\r\n    this.zoomEnabled = zoomEnabled;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.skins.Skin.getScoreFontOverlap",
	"Comment": "returns the amount of overlap between the score font sprites.",
	"Method": "int getScoreFontOverlap(){\r\n    return scoreOverlap;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.skins.Skin.isSpinnerFrequencyModulated",
	"Comment": "returns whether the sound frequency should be modulated depending on the spinner score.",
	"Method": "boolean isSpinnerFrequencyModulated(){\r\n    return spinnerFrequencyModulate;\r\n}"
}, {
	"Path": "com.iwebpp.wspp.Receiver.expectData",
	"Comment": "waits for a certain amount of data bytes to be available, then fires a callback.",
	"Method": "void expectData(int length,PacketHandler handler){\r\n    debug(TAG, \"expectData, length:\" + length + \",handler:\" + handler);\r\n    if (length == 0) {\r\n        handler.onPacket(null);\r\n        return;\r\n    }\r\n    this.expectBuffer = this.allocateFromPool(length, this.state.fragmentedOperation);\r\n    this.expectHandler = handler;\r\n    int toRead = length;\r\n    while (toRead > 0 && this.overflow.size() > 0) {\r\n        ByteBuffer fromOverflow = this.overflow.remove(this.overflow.size() - 1);\r\n        if (toRead < fromOverflow.capacity())\r\n            this.overflow.add((ByteBuffer) Util.chunkSlice(fromOverflow, toRead, fromOverflow.capacity()));\r\n        int read = Math.min(fromOverflow.capacity(), toRead);\r\n        BufferUtil.fastCopy(read, fromOverflow, this.expectBuffer, this.expectOffset);\r\n        this.expectOffset += read;\r\n        toRead -= read;\r\n    }\r\n    debug(TAG, \"expectData, expectBuffer:\" + expectBuffer + \",expectOffset:\" + expectOffset);\r\n}"
}, {
	"Path": "com.joestelmach.natty.Parser.parse",
	"Comment": "parses the given input value for one or more groups ofdate alternatives with relative dates resolved accordingto referencedate",
	"Method": "List<DateGroup> parse(String value,List<DateGroup> parse,String value,Date referenceDate){\r\n    ANTLRInputStream input = null;\r\n    try {\r\n        input = new ANTLRNoCaseInputStream(new ByteArrayInputStream(value.getBytes()));\r\n    } catch (IOException e) {\r\n        _logger.error(\"could not lex input\", e);\r\n    }\r\n    DateLexer lexer = new DateLexer(input);\r\n    List<TokenStream> streams = collectTokenStreams(new CommonTokenStream(lexer));\r\n    List<DateGroup> groups = new ArrayList<DateGroup>();\r\n    TokenStream lastStream = null;\r\n    for (TokenStream stream : streams) {\r\n        lastStream = stream;\r\n        List<Token> tokens = ((NattyTokenSource) stream.getTokenSource()).getTokens();\r\n        DateGroup group = singleParse(stream, value, referenceDate);\r\n        while ((group == null || group.getDates().size() == 0) && tokens.size() > 0) {\r\n            if (group == null || group.getDates().size() == 0) {\r\n                List<Token> endRemovedTokens = new ArrayList<Token>(tokens);\r\n                while ((group == null || group.getDates().isEmpty()) && !endRemovedTokens.isEmpty()) {\r\n                    endRemovedTokens = endRemovedTokens.subList(0, endRemovedTokens.size() - 1);\r\n                    TokenStream newStream = new CommonTokenStream(new NattyTokenSource(endRemovedTokens));\r\n                    group = singleParse(newStream, value, referenceDate);\r\n                    lastStream = newStream;\r\n                }\r\n                while ((group == null || group.getDates().isEmpty()) && tokens.size() >= 1) {\r\n                    tokens = tokens.subList(1, tokens.size());\r\n                    Iterator<Token> iter = tokens.iterator();\r\n                    while (iter.hasNext()) {\r\n                        Token token = iter.next();\r\n                        if (!DateParser.FOLLOW_empty_in_parse186.member(token.getType())) {\r\n                            iter.remove();\r\n                        } else {\r\n                            break;\r\n                        }\r\n                    }\r\n                    TokenStream newStream = new CommonTokenStream(new NattyTokenSource(tokens));\r\n                    group = singleParse(newStream, value, referenceDate);\r\n                    lastStream = newStream;\r\n                }\r\n            }\r\n        }\r\n        if (group != null && !group.getDates().isEmpty() && (streams.size() == 1 || !group.isDateInferred() || !isAllNumeric(lastStream))) {\r\n            group.setFullText(value);\r\n            String prefix = group.getPrefix(1);\r\n            String suffix = group.getSuffix(1);\r\n            if ((prefix.isEmpty() || !Character.isLetter(prefix.charAt(0))) && (suffix.isEmpty() || !Character.isLetter(suffix.charAt(0)))) {\r\n                groups.add(group);\r\n            }\r\n        }\r\n    }\r\n    return groups;\r\n}"
}, {
	"Path": "org.lwjgl.openal.EFXUtil.testSupportGeneric",
	"Comment": "generic test function to see if an efx object supports a given kind of type. works foreffects and filters.",
	"Method": "boolean testSupportGeneric(int objectType,int typeValue){\r\n    switch(objectType) {\r\n        case EFFECT:\r\n        case FILTER:\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Invalid objectType: \" + objectType);\r\n    }\r\n    boolean supported = false;\r\n    if (isEfxSupported()) {\r\n        alGetError();\r\n        int genError;\r\n        int testObject = 0;\r\n        try {\r\n            switch(objectType) {\r\n                case EFFECT:\r\n                    testObject = alGenEffects();\r\n                    break;\r\n                case FILTER:\r\n                    testObject = alGenFilters();\r\n                    break;\r\n                default:\r\n                    throw new IllegalArgumentException(\"Invalid objectType: \" + objectType);\r\n            }\r\n            genError = alGetError();\r\n        } catch (final OpenALException debugBuildException) {\r\n            if (debugBuildException.getMessage().contains(\"AL_OUT_OF_MEMORY\")) {\r\n                genError = AL_OUT_OF_MEMORY;\r\n            } else {\r\n                genError = AL_INVALID_OPERATION;\r\n            }\r\n        }\r\n        if (genError == AL_NO_ERROR) {\r\n            alGetError();\r\n            int setError;\r\n            try {\r\n                switch(objectType) {\r\n                    case EFFECT:\r\n                        alEffecti(testObject, AL_EFFECT_TYPE, typeValue);\r\n                        break;\r\n                    case FILTER:\r\n                        alFilteri(testObject, AL_FILTER_TYPE, typeValue);\r\n                        break;\r\n                    default:\r\n                        throw new IllegalArgumentException(\"Invalid objectType: \" + objectType);\r\n                }\r\n                setError = alGetError();\r\n            } catch (final OpenALException debugBuildException) {\r\n                setError = AL_INVALID_VALUE;\r\n            }\r\n            if (setError == AL_NO_ERROR) {\r\n                supported = true;\r\n            }\r\n            try {\r\n                switch(objectType) {\r\n                    case EFFECT:\r\n                        alDeleteEffects(testObject);\r\n                        break;\r\n                    case FILTER:\r\n                        alDeleteFilters(testObject);\r\n                        break;\r\n                    default:\r\n                        throw new IllegalArgumentException(\"Invalid objectType: \" + objectType);\r\n                }\r\n            } catch (final OpenALException debugBuildException) {\r\n            }\r\n        } else if (genError == AL_OUT_OF_MEMORY) {\r\n            throw new OpenALException(genError);\r\n        }\r\n    }\r\n    return supported;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.Utils.deleteToTrash",
	"Comment": "deletes a file or directory.if a system trash directory is available,\tthe file or directory will be moved there instead.",
	"Method": "boolean deleteToTrash(File file){\r\n    if (file == null)\r\n        throw new IOException(\"File cannot be null.\");\r\n    if (!file.exists())\r\n        throw new IOException(String.format(\"File '%s' does not exist.\", file.getAbsolutePath()));\r\n    FileUtils fileUtils = FileUtils.getInstance();\r\n    if (fileUtils.hasTrash()) {\r\n        try {\r\n            fileUtils.moveToTrash(new File[] { file });\r\n            return true;\r\n        } catch (IOException e) {\r\n            Log.warn(String.format(\"Failed to move file '%s' to trash.\", file.getAbsolutePath()), e);\r\n        }\r\n    }\r\n    if (file.isDirectory())\r\n        deleteDirectory(file);\r\n    else\r\n        file.delete();\r\n    return false;\r\n}"
}, {
	"Path": "org.lwjgl.opencl.APIUtil.getLengths",
	"Comment": "returns a buffer containing the lengths of the specified buffers.",
	"Method": "PointerBuffer getLengths(PointerBuffer getLengths,int size,long getLengths,CharSequence[] strings,long getLengths,ByteBuffer[] buffers){\r\n    PointerBuffer lengths = getLengths(buffers.length);\r\n    for (ByteBuffer buffer : buffers) lengths.put(buffer.remaining());\r\n    lengths.flip();\r\n    return MemoryUtil.getAddress0(lengths);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.objects.Slider.init",
	"Comment": "initializes the slider data type with images and dimensions.",
	"Method": "void init(GameContainer container,float circleDiameter,Beatmap beatmap){\r\n    containerWidth = container.getWidth();\r\n    containerHeight = container.getHeight();\r\n    diameter = circleDiameter * HitObject.getXMultiplier();\r\n    int diameterInt = (int) diameter;\r\n    followRadius = diameter / 2 * 3f;\r\n    if (GameImage.SLIDER_BALL.hasBeatmapSkinImages() || (!GameImage.SLIDER_BALL.hasBeatmapSkinImage() && GameImage.SLIDER_BALL.getImages() != null))\r\n        sliderBallImages = GameImage.SLIDER_BALL.getImages();\r\n    else\r\n        sliderBallImages = new Image[] { GameImage.SLIDER_BALL.getImage() };\r\n    for (int i = 0; i < sliderBallImages.length; i++) sliderBallImages[i] = sliderBallImages[i].getScaledCopy(diameterInt * 118 / 128, diameterInt * 118 / 128);\r\n    GameImage.SLIDER_FOLLOWCIRCLE.setImage(GameImage.SLIDER_FOLLOWCIRCLE.getImage().getScaledCopy(diameterInt * 259 / 128, diameterInt * 259 / 128));\r\n    GameImage.REVERSEARROW.setImage(GameImage.REVERSEARROW.getImage().getScaledCopy(diameterInt, diameterInt));\r\n    GameImage.SLIDER_TICK.setImage(GameImage.SLIDER_TICK.getImage().getScaledCopy(diameterInt / 4, diameterInt / 4));\r\n    sliderMultiplier = beatmap.sliderMultiplier;\r\n    sliderTickRate = beatmap.sliderTickRate;\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.onDraw",
	"Comment": "draw method should not be called until the view has dimensions so the first calls are used as triggers to calculatethe scaling and tiling required. once the view is setup, tiles are displayed as they are loaded.",
	"Method": "void onDraw(Canvas canvas){\r\n    super.onDraw(canvas);\r\n    createPaints();\r\n    if (sWidth == 0 || sHeight == 0 || decoder == null || getWidth() == 0 || getHeight() == 0) {\r\n        return;\r\n    }\r\n    if (tileMap == null) {\r\n        initialiseBaseLayer(getMaxBitmapDimensions(canvas));\r\n        return;\r\n    }\r\n    if (sPendingCenter != null && pendingScale != null) {\r\n        scale = pendingScale;\r\n        vTranslate.x = (getWidth() / 2) - (scale * sPendingCenter.x);\r\n        vTranslate.y = (getHeight() / 2) - (scale * sPendingCenter.y);\r\n        sPendingCenter = null;\r\n        pendingScale = null;\r\n        fitToBounds(true);\r\n        refreshRequiredTiles(true);\r\n    }\r\n    fitToBounds(false);\r\n    if (!readySent) {\r\n        readySent = true;\r\n        new Thread(new Runnable() {\r\n            public void run() {\r\n                onImageReady();\r\n            }\r\n        }).start();\r\n    }\r\n    if (anim != null) {\r\n        long scaleElapsed = System.currentTimeMillis() - anim.time;\r\n        boolean finished = scaleElapsed > anim.duration;\r\n        scaleElapsed = Math.min(scaleElapsed, anim.duration);\r\n        scale = ease(anim.easing, scaleElapsed, anim.scaleStart, anim.scaleEnd - anim.scaleStart, anim.duration);\r\n        float vFocusNowX = ease(anim.easing, scaleElapsed, anim.vFocusStart.x, anim.vFocusEnd.x - anim.vFocusStart.x, anim.duration);\r\n        float vFocusNowY = ease(anim.easing, scaleElapsed, anim.vFocusStart.y, anim.vFocusEnd.y - anim.vFocusStart.y, anim.duration);\r\n        PointF vFocus = sourceToViewCoord(anim.sCenterEnd);\r\n        vTranslate.x -= vFocus.x - vFocusNowX;\r\n        vTranslate.y -= vFocus.y - vFocusNowY;\r\n        fitToBounds(finished || (anim.scaleStart == anim.scaleEnd));\r\n        refreshRequiredTiles(finished);\r\n        if (finished) {\r\n            anim = null;\r\n        }\r\n        invalidate();\r\n    }\r\n    int sampleSize = Math.min(fullImageSampleSize, calculateInSampleSize());\r\n    boolean hasMissingTiles = false;\r\n    for (Map.Entry<Integer, List<Tile>> tileMapEntry : tileMap.entrySet()) {\r\n        if (tileMapEntry.getKey() == sampleSize) {\r\n            for (Tile tile : tileMapEntry.getValue()) {\r\n                if (tile.visible && (tile.loading || tile.bitmap == null)) {\r\n                    hasMissingTiles = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (Map.Entry<Integer, List<Tile>> tileMapEntry : tileMap.entrySet()) {\r\n        if (tileMapEntry.getKey() == sampleSize || hasMissingTiles) {\r\n            for (Tile tile : tileMapEntry.getValue()) {\r\n                Rect vRect = convertRect(sourceToViewRect(tile.sRect));\r\n                if (!tile.loading && tile.bitmap != null) {\r\n                    if (tileBgPaint != null) {\r\n                        canvas.drawRect(vRect, tileBgPaint);\r\n                    }\r\n                    canvas.drawBitmap(tile.bitmap, null, vRect, bitmapPaint);\r\n                    if (debug) {\r\n                        canvas.drawRect(vRect, debugPaint);\r\n                    }\r\n                } else if (tile.loading && debug) {\r\n                    canvas.drawText(\"LOADING\", vRect.left + 5, vRect.top + 35, debugPaint);\r\n                }\r\n                if (tile.visible && debug) {\r\n                    canvas.drawText(\"ISS \" + tile.sampleSize + \" RECT \" + tile.sRect.top + \",\" + tile.sRect.left + \",\" + tile.sRect.bottom + \",\" + tile.sRect.right, vRect.left + 5, vRect.top + 15, debugPaint);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (debug) {\r\n        canvas.drawText(\"Scale: \" + String.format(\"%.2f\", scale), 5, 15, debugPaint);\r\n        canvas.drawText(\"Translate: \" + String.format(\"%.2f\", vTranslate.x) + \":\" + String.format(\"%.2f\", vTranslate.y), 5, 35, debugPaint);\r\n        PointF center = getCenter();\r\n        canvas.drawText(\"Source center: \" + String.format(\"%.2f\", center.x) + \":\" + String.format(\"%.2f\", center.y), 5, 55, debugPaint);\r\n        if (anim != null) {\r\n            PointF vCenterStart = sourceToViewCoord(anim.sCenterStart);\r\n            PointF vCenterEndRequested = sourceToViewCoord(anim.sCenterEndRequested);\r\n            PointF vCenterEnd = sourceToViewCoord(anim.sCenterEnd);\r\n            canvas.drawCircle(vCenterStart.x, vCenterStart.y, 10, debugPaint);\r\n            canvas.drawCircle(vCenterEndRequested.x, vCenterEndRequested.y, 20, debugPaint);\r\n            canvas.drawCircle(vCenterEnd.x, vCenterEnd.y, 25, debugPaint);\r\n            canvas.drawCircle(getWidth() / 2, getHeight() / 2, 30, debugPaint);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.onDraw",
	"Comment": "draw method should not be called until the view has dimensions so the first calls are used as triggers to calculatethe scaling and tiling required. once the view is setup, tiles are displayed as they are loaded.",
	"Method": "void onDraw(Canvas canvas){\r\n    onImageReady();\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getModelDelimitedText",
	"Comment": "returns a string that uses only the line delimiter specified by the styledtextcontent implementation.returns only the first line if the widget has the swt.single style.",
	"Method": "String getModelDelimitedText(String text){\r\n    int length = text.length();\r\n    if (length == 0) {\r\n        return text;\r\n    }\r\n    int crIndex = 0;\r\n    int lfIndex = 0;\r\n    int i = 0;\r\n    StringBuffer convertedText = new StringBuffer(length);\r\n    String delimiter = getLineDelimiter();\r\n    while (i < length) {\r\n        if (crIndex != -1) {\r\n            crIndex = text.indexOf(SWT.CR, i);\r\n        }\r\n        if (lfIndex != -1) {\r\n            lfIndex = text.indexOf(SWT.LF, i);\r\n        }\r\n        if (lfIndex == -1 && crIndex == -1) {\r\n            break;\r\n        } else if ((crIndex < lfIndex && crIndex != -1) || lfIndex == -1) {\r\n            convertedText.append(text.substring(i, crIndex));\r\n            if (lfIndex == crIndex + 1) {\r\n                i = lfIndex + 1;\r\n            } else {\r\n                i = crIndex + 1;\r\n            }\r\n        } else {\r\n            convertedText.append(text.substring(i, lfIndex));\r\n            i = lfIndex + 1;\r\n        }\r\n        if (isSingleLine()) {\r\n            break;\r\n        }\r\n        convertedText.append(delimiter);\r\n    }\r\n    if (i < length && (!isSingleLine() || convertedText.length() == 0)) {\r\n        convertedText.append(text.substring(i));\r\n    }\r\n    return convertedText.toString();\r\n}"
}, {
	"Path": "org.lwjgl.opengl.WindowsCanvasImplementation.findConfiguration",
	"Comment": "find a proper graphicsconfiguration from the given graphicsdevice and pixelformat.",
	"Method": "GraphicsConfiguration findConfiguration(GraphicsDevice device,PixelFormat pixel_format){\r\n    return null;\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.setPanEnabled",
	"Comment": "enable or disable pan gesture detection. disabling pan causes the image to be centered.",
	"Method": "void setPanEnabled(boolean panEnabled){\r\n    this.panEnabled = panEnabled;\r\n    if (!panEnabled && vTranslate != null) {\r\n        vTranslate.x = (getWidth() / 2) - (scale * (sWidth() / 2));\r\n        vTranslate.y = (getHeight() / 2) - (scale * (sHeight() / 2));\r\n        if (isImageReady()) {\r\n            invalidate();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mewx.wenku8.util.LightCache.copyFile",
	"Comment": "copy file from one place to another place,if target parent path does not exist, then create them",
	"Method": "void copyFile(String from,String to,Boolean forceWrite){\r\n    File fromFile = new File(from);\r\n    File toFile = new File(to);\r\n    if (!fromFile.exists() || !fromFile.isFile() || !fromFile.canRead() || toFile.exists() && !forceWrite)\r\n        return;\r\n    if (!toFile.getParentFile().exists() && !toFile.getParentFile().mkdirs())\r\n        Log.d(TAG, \"Failed to create parent dirs for target file: \" + to);\r\n    if (toFile.exists() && forceWrite && !toFile.delete())\r\n        Log.d(TAG, \"Failed to create or delete target file: \" + to);\r\n    try {\r\n        java.io.FileInputStream fosFrom = new java.io.FileInputStream(fromFile);\r\n        java.io.FileOutputStream fosTo = new FileOutputStream(toFile);\r\n        byte[] bt = new byte[1024];\r\n        int c;\r\n        while ((c = fosFrom.read(bt)) > 0) fosTo.write(bt, 0, c);\r\n        fosFrom.close();\r\n        fosTo.close();\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getSelectionRanges",
	"Comment": "returns the ranges of text that are inside the block selection rectangle.the ranges array contains start and length pairs. when the receiver is notin block selection mode the return arrays contains the start and length ofthe regular selection.",
	"Method": "int[] getSelectionRanges(){\r\n    checkWidget();\r\n    if (blockSelection && blockXLocation != -1) {\r\n        Rectangle rect = getBlockSelectionPosition();\r\n        int firstLine = rect.y;\r\n        int lastLine = rect.height;\r\n        int left = rect.x;\r\n        int right = rect.width;\r\n        int[] ranges = new int[(lastLine - firstLine + 1) * 2];\r\n        int index = 0;\r\n        for (int lineIndex = firstLine; lineIndex <= lastLine; lineIndex++) {\r\n            int start = getOffsetAtPoint(left, 0, lineIndex, null);\r\n            int end = getOffsetAtPoint(right, 0, lineIndex, null);\r\n            if (start > end) {\r\n                int temp = start;\r\n                start = end;\r\n                end = temp;\r\n            }\r\n            ranges[index++] = start;\r\n            ranges[index++] = end - start;\r\n        }\r\n        return ranges;\r\n    }\r\n    return new int[] { selection.x, selection.y - selection.x };\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.servers.DownloadServer.getDownloadRequestHeaders",
	"Comment": "returns any http request headers that should be set in the download request.",
	"Method": "Map<String, String> getDownloadRequestHeaders(){\r\n    return null;\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix3f.transpose",
	"Comment": "transpose the source matrix and place the result into the destination matrix",
	"Method": "Matrix transpose(Matrix3f transpose,Matrix3f dest,Matrix3f transpose,Matrix3f src,Matrix3f dest){\r\n    if (dest == null)\r\n        dest = new Matrix3f();\r\n    float m00 = src.m00;\r\n    float m01 = src.m10;\r\n    float m02 = src.m20;\r\n    float m10 = src.m01;\r\n    float m11 = src.m11;\r\n    float m12 = src.m21;\r\n    float m20 = src.m02;\r\n    float m21 = src.m12;\r\n    float m22 = src.m22;\r\n    dest.m00 = m00;\r\n    dest.m01 = m01;\r\n    dest.m02 = m02;\r\n    dest.m10 = m10;\r\n    dest.m11 = m11;\r\n    dest.m12 = m12;\r\n    dest.m20 = m20;\r\n    dest.m21 = m21;\r\n    dest.m22 = m22;\r\n    return dest;\r\n}"
}, {
	"Path": "io.opencensus.contrib.logcorrelation.log4j2.OpenCensusTraceContextDataInjector.injectContextData",
	"Comment": "note that this method must return an object that can be passed to another thread.",
	"Method": "StringMap injectContextData(List<Property> properties,StringMap reusable){\r\n    return ContextDataUtils.injectContextData(properties, reusable);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.BeatmapSetList.search",
	"Comment": "creates a new list of song groups in which each group contains a match to a search query.",
	"Method": "boolean search(String query){\r\n    if (query == null)\r\n        return false;\r\n    query = query.trim().toLowerCase();\r\n    if (lastQuery != null && query.equals(lastQuery))\r\n        return false;\r\n    lastQuery = query;\r\n    LinkedList<String> terms = new LinkedList<String>(Arrays.asList(query.split(\"\\\\s+\")));\r\n    if (query.isEmpty() || terms.isEmpty()) {\r\n        nodes = groupNodes;\r\n        return true;\r\n    }\r\n    LinkedList<String> condType = new LinkedList<String>();\r\n    LinkedList<String> condOperator = new LinkedList<String>();\r\n    LinkedList<Float> condValue = new LinkedList<Float>();\r\n    Iterator<String> termIter = terms.iterator();\r\n    while (termIter.hasNext()) {\r\n        String term = termIter.next();\r\n        Matcher m = SEARCH_CONDITION_PATTERN.matcher(term);\r\n        if (m.find()) {\r\n            condType.add(m.group(1));\r\n            condOperator.add(m.group(2));\r\n            condValue.add(Float.parseFloat(m.group(3)));\r\n            termIter.remove();\r\n        }\r\n    }\r\n    nodes = new ArrayList<BeatmapSetNode>();\r\n    if (terms.isEmpty()) {\r\n        String type = condType.remove();\r\n        String operator = condOperator.remove();\r\n        float value = condValue.remove();\r\n        for (BeatmapSetNode node : groupNodes) {\r\n            if (node.getBeatmapSet().matches(type, operator, value))\r\n                nodes.add(node);\r\n        }\r\n    } else {\r\n        String term = terms.remove();\r\n        for (BeatmapSetNode node : groupNodes) {\r\n            if (node.getBeatmapSet().matches(term))\r\n                nodes.add(node);\r\n        }\r\n    }\r\n    while (!terms.isEmpty()) {\r\n        if (nodes.isEmpty())\r\n            return true;\r\n        String term = terms.remove();\r\n        Iterator<BeatmapSetNode> nodeIter = nodes.iterator();\r\n        while (nodeIter.hasNext()) {\r\n            BeatmapSetNode node = nodeIter.next();\r\n            if (!node.getBeatmapSet().matches(term))\r\n                nodeIter.remove();\r\n        }\r\n    }\r\n    while (!condType.isEmpty()) {\r\n        if (nodes.isEmpty())\r\n            return true;\r\n        String type = condType.remove();\r\n        String operator = condOperator.remove();\r\n        float value = condValue.remove();\r\n        Iterator<BeatmapSetNode> nodeIter = nodes.iterator();\r\n        while (nodeIter.hasNext()) {\r\n            BeatmapSetNode node = nodeIter.next();\r\n            if (!node.getBeatmapSet().matches(type, operator, value))\r\n                nodeIter.remove();\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.CallbackUtil.registerContextCallback",
	"Comment": "associates the current opengl context with the specified global reference. if there\tis no context current, the global reference is deleted and an exception is thrown.\tany previous callback registrations will be cleared.",
	"Method": "void registerContextCallback(long userParam,Map<ContextCapabilities, Long> contextUserData){\r\n    ContextCapabilities caps = GLContext.getCapabilities();\r\n    if (caps == null) {\r\n        deleteGlobalRef(userParam);\r\n        throw new IllegalStateException(\"No context is current.\");\r\n    }\r\n    final Long userParam_old = contextUserData.remove(caps);\r\n    if (userParam_old != null)\r\n        deleteGlobalRef(userParam_old);\r\n    if (userParam != 0)\r\n        contextUserData.put(caps, userParam);\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.value.FSCssValue.setStringValue",
	"Comment": "not supported, class is immutable. a method to set the string value withthe specified unit.",
	"Method": "void setStringValue(short stringType,String stringValue){\r\n    throw new XRRuntimeException(\"FSCssValue is immutable.\");\r\n}"
}, {
	"Path": "com.openhtmltopdf.context.StyleReference.setDocumentContext",
	"Comment": "sets the documentcontext attribute of the stylereference object",
	"Method": "void setDocumentContext(SharedContext context,NamespaceHandler nsh,Document doc,UserInterface ui){\r\n    _context = context;\r\n    _nsh = nsh;\r\n    _doc = doc;\r\n    AttributeResolver attRes = new StandardAttributeResolver(_nsh, _uac, ui);\r\n    List<StylesheetInfo> infos = getStylesheets();\r\n    XRLog.match(\"media = \" + _context.getMedia());\r\n    _matcher = new com.openhtmltopdf.css.newmatch.Matcher(new DOMTreeResolver(), attRes, _stylesheetFactory, readAndParseAll(infos, _context.getMedia()), _context.getMedia());\r\n}"
}, {
	"Path": "com.openhtmltopdf.nonvisualregressiontests.NonVisualRegressionTest.testLinkAfterOverflowTarget",
	"Comment": "tests that a simple block link successfully links to an element that is after an inserted overflow page.",
	"Method": "void testLinkAfterOverflowTarget(){\r\n    PDDocument doc = run(\"link-after-overflow-target\");\r\n    assertEquals(1, doc.getPage(0).getAnnotations().size());\r\n    assertThat(doc.getPage(0).getAnnotations().get(0), instanceOf(PDAnnotationLink.class));\r\n    PDAnnotationLink link = (PDAnnotationLink) doc.getPage(0).getAnnotations().get(0);\r\n    assertThat(link.getRectangle(), rectEquals(new PDRectangle(10f, 10f, 80f, 10f), 100d));\r\n    assertThat(link.getAction(), instanceOf(PDActionGoTo.class));\r\n    PDActionGoTo action = (PDActionGoTo) link.getAction();\r\n    assertThat(action.getDestination(), instanceOf(PDPageXYZDestination.class));\r\n    PDPageXYZDestination dest = (PDPageXYZDestination) action.getDestination();\r\n    assertEquals(doc.getPage(2), dest.getPage());\r\n    assertEquals(cssPixelYToPdfPoints(10, 100), dest.getTop(), 1.0d);\r\n    remove(\"link-after-overflow-target\", doc);\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Vector2f.sub",
	"Comment": "subtract a vector from another vector and place the result in a destination\tvector.",
	"Method": "Vector2f sub(Vector2f left,Vector2f right,Vector2f dest){\r\n    if (dest == null)\r\n        return new Vector2f(left.x - right.x, left.y - right.y);\r\n    else {\r\n        dest.set(left.x - right.x, left.y - right.y);\r\n        return dest;\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.AbstractOutputDevice.getFontSpecification",
	"Comment": "gets the fontspecification for this abstractoutputdevice.",
	"Method": "FontSpecification getFontSpecification(){\r\n    return _fontSpec;\r\n}"
}, {
	"Path": "org.lwjgl.opencl.CLProgram.createKernelsInProgram",
	"Comment": "creates kernel objects for all kernels functions in this program.",
	"Method": "CLKernel[] createKernelsInProgram(CLKernel[] createKernelsInProgram,CLProgram program){\r\n    return util.createKernelsInProgram(this);\r\n}"
}, {
	"Path": "org.lwjgl.opengles.PixelFormat.matches",
	"Comment": "returns true if the requested attribute matches the attribute in the specified egl config.",
	"Method": "boolean matches(Attrib attrib,EGLConfig config){\r\n    return getAttrib(attrib) == config.getAttribute(attrib.getEGLAttrib());\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doLineDown",
	"Comment": "moves the caret one line down and to the same character offset relative to the beginning of the line. move the caret to the end of the new line if the new line is shorter than the character offset.",
	"Method": "void doLineDown(boolean select){\r\n    int caretLine = getCaretLine();\r\n    int lineCount = content.getLineCount();\r\n    int y = 0;\r\n    boolean lastLine = false;\r\n    if (wordWrap) {\r\n        int lineOffset = content.getOffsetAtLine(caretLine);\r\n        int offsetInLine = caretOffset - lineOffset;\r\n        TextLayout layout = renderer.getTextLayout(caretLine);\r\n        int lineIndex = getVisualLineIndex(layout, offsetInLine);\r\n        int layoutLineCount = layout.getLineCount();\r\n        if (lineIndex == layoutLineCount - 1) {\r\n            lastLine = caretLine == lineCount - 1;\r\n            caretLine++;\r\n        } else {\r\n            y = layout.getLineBounds(lineIndex + 1).y;\r\n        }\r\n        renderer.disposeTextLayout(layout);\r\n    } else {\r\n        lastLine = caretLine == lineCount - 1;\r\n        caretLine++;\r\n    }\r\n    if (lastLine) {\r\n        if (select) {\r\n            setCaretOffset(content.getCharCount(), SWT.DEFAULT);\r\n        }\r\n    } else {\r\n        int[] alignment = new int[1];\r\n        int offset = getOffsetAtPoint(columnX, y, caretLine, alignment);\r\n        setCaretOffset(offset, alignment[0]);\r\n    }\r\n    int oldColumnX = columnX;\r\n    int oldHScrollOffset = horizontalScrollOffset;\r\n    if (select) {\r\n        setMouseWordSelectionAnchor();\r\n        doSelection(ST.COLUMN_NEXT);\r\n    }\r\n    showCaret();\r\n    int hScrollChange = oldHScrollOffset - horizontalScrollOffset;\r\n    columnX = oldColumnX + hScrollChange;\r\n}"
}, {
	"Path": "com.github.pires.obd.utils.CommandAvailabilityHelper.digestAvailabilityString",
	"Comment": "digests the given string into an array of integers which can be used to check for command availability",
	"Method": "int[] digestAvailabilityString(String availabilityString){\r\n    if (availabilityString.length() % 8 != 0) {\r\n        throw new IllegalArgumentException(\"Invalid length for Availability String supplied: \" + availabilityString);\r\n    }\r\n    int[] availabilityArray = new int[availabilityString.length() / 2];\r\n    for (int i = 0, a = 0; i < availabilityArray.length; ++i, a += 2) {\r\n        availabilityArray[i] = 16 * parseHexChar(availabilityString.charAt(a)) + parseHexChar(availabilityString.charAt(a + 1));\r\n    }\r\n    return availabilityArray;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getPlatformDelimitedText",
	"Comment": "returns the content in the specified range using the platform line delimiter to separate lines.",
	"Method": "String getPlatformDelimitedText(TextWriter writer){\r\n    int end = writer.getStart() + writer.getCharCount();\r\n    int startLine = content.getLineAtOffset(writer.getStart());\r\n    int endLine = content.getLineAtOffset(end);\r\n    String endLineText = content.getLine(endLine);\r\n    int endLineOffset = content.getOffsetAtLine(endLine);\r\n    for (int i = startLine; i <= endLine; i++) {\r\n        writer.writeLine(content.getLine(i), content.getOffsetAtLine(i));\r\n        if (i < endLine) {\r\n            writer.writeLineDelimiter(PlatformLineDelimiter);\r\n        }\r\n    }\r\n    if (end > endLineOffset + endLineText.length()) {\r\n        writer.writeLineDelimiter(PlatformLineDelimiter);\r\n    }\r\n    writer.close();\r\n    return writer.toString();\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.Configuration.valueAsShort",
	"Comment": "returns the value for key in the configuration as a short, or the defaultprovided value if not found or if the value is not a valid short. awarning is issued to the log if the property is not defined, or if theconversion from string fails.",
	"Method": "int valueAsShort(String key,short defaultVal){\r\n    String val = valueFor(key);\r\n    if (val == null) {\r\n        return defaultVal;\r\n    }\r\n    short sval;\r\n    try {\r\n        sval = Short.valueOf(val).shortValue();\r\n    } catch (NumberFormatException nex) {\r\n        XRLog.exception(\"Property '\" + key + \"' was requested as a short, but \" + \"value of '\" + val + \"' is not a short. Check configuration.\");\r\n        sval = defaultVal;\r\n    }\r\n    return sval;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.NativeLoader.isNativeFile",
	"Comment": "returns whether the given file name is a native file for the current operating system.",
	"Method": "boolean isNativeFile(String entryName){\r\n    String osName = System.getProperty(\"os.name\");\r\n    String name = entryName.toLowerCase();\r\n    if (osName.startsWith(\"Win\")) {\r\n        if (name.endsWith(\".dll\"))\r\n            return true;\r\n    } else if (osName.startsWith(\"Linux\")) {\r\n        if (name.endsWith(\".so\"))\r\n            return true;\r\n    } else if (osName.startsWith(\"Mac\") || osName.startsWith(\"Darwin\")) {\r\n        if (name.endsWith(\".dylib\") || name.endsWith(\".jnilib\"))\r\n            return true;\r\n    }\r\n    if (name.equals(FFmpeg.DEFAULT_NATIVE_FILENAME.toLowerCase()))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.lwjgl.openal.ALC10.alcDestroyContext",
	"Comment": "the correct way to destroy a context is to first release it using alcmakecurrent and\t null. applications should not attempt to destroy a current context.",
	"Method": "void alcDestroyContext(ALCcontext context){\r\n    synchronized (ALC10.contexts) {\r\n        ALCdevice device = alcGetContextsDevice(context);\r\n        nalcDestroyContext(getContext(context));\r\n        device.removeContext(context);\r\n        context.setInvalid();\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.pdfboxout.PdfBoxFastOutputDevice.setMetadata",
	"Comment": "replaces all copies of the named metadata with a single value. a a newvalue of null will result in the removal of all copies of the namedmetadata. use addmetadata to append additional values withthe same name.",
	"Method": "void setMetadata(String name,String value){\r\n    if (name != null) {\r\n        boolean remove = (value == null);\r\n        int free = -1;\r\n        for (int i = 0, len = _metadata.size(); i < len; i++) {\r\n            Metadata m = _metadata.get(i);\r\n            if (m != null) {\r\n                if (m.getName().equalsIgnoreCase(name)) {\r\n                    if (!remove) {\r\n                        remove = true;\r\n                        m.setContent(value);\r\n                    } else {\r\n                        _metadata.set(i, null);\r\n                    }\r\n                }\r\n            } else if (free == -1) {\r\n                free = i;\r\n            }\r\n        }\r\n        if (!remove) {\r\n            Metadata m = new Metadata(name, value);\r\n            if (free == -1) {\r\n                _metadata.add(m);\r\n            } else {\r\n                _metadata.set(free, m);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ui.DropdownMenu.contains",
	"Comment": "returns true if the coordinates are within the menu bounds.",
	"Method": "boolean contains(float cx,float cy){\r\n    return (cx > x && cx < x + width && ((cy > y && cy < y + baseHeight) || (expanded && cy > y + offsetY && cy < y + height)));\r\n}"
}, {
	"Path": "itdelatrisu.opsu.Utils.openInFileManager",
	"Comment": "opens the file manager to the given location.\tif the location is a file, it will be highlighted if possible.",
	"Method": "void openInFileManager(File file){\r\n    File f = file;\r\n    if (f.isFile()) {\r\n        String osName = System.getProperty(\"os.name\");\r\n        if (osName.startsWith(\"Win\")) {\r\n            Runtime.getRuntime().exec(\"explorer.exe /select,\" + f.getAbsolutePath());\r\n            return;\r\n        } else if (osName.startsWith(\"Mac\")) {\r\n            Runtime.getRuntime().exec(\"open -R \" + f.getAbsolutePath());\r\n            return;\r\n        }\r\n        f = f.getParentFile();\r\n    }\r\n    if (f.isDirectory()) {\r\n        if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.OPEN))\r\n            Desktop.getDesktop().open(f);\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.getMessages",
	"Comment": "retrieves the current message for the current status. \tused by liveconnect when running in headless mode.",
	"Method": "String[] getMessages(){\r\n    return headlessMessage;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.Updater.updatedToVersion",
	"Comment": "returns the version the program was just updated to, or null if not updated.",
	"Method": "String updatedToVersion(){\r\n    return (justUpdated()) ? updatedToVersion : null;\r\n}"
}, {
	"Path": "io.opencensus.benchmarks.trace.RecordTraceEventsBenchmark.addAnnotation",
	"Comment": "this benchmark attempts to measure performance of adding an annotation to the span.",
	"Method": "Span addAnnotation(Data data){\r\n    data.span.addAnnotation(ANNOTATION_DESCRIPTION);\r\n    return data.span;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ScoreData.buttonContains",
	"Comment": "returns true if the coordinates are within the bounds of the\tbutton at the given index.",
	"Method": "boolean buttonContains(float cx,float cy,int index){\r\n    float y = baseY + (index * buttonOffset);\r\n    return ((cx >= 0 && cx < baseX + buttonWidth) && (cy > y && cy < y + buttonHeight));\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.servers.DownloadServer.isDownloadInBrowser",
	"Comment": "returns whether downloads must be made through a web browser.",
	"Method": "boolean isDownloadInBrowser(){\r\n    return false;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.objects.curves.CurveType.getCurveDistances",
	"Comment": "returns the distances between a point of the curve and the last point.",
	"Method": "float[] getCurveDistances(){\r\n    return curveDis;\r\n}"
}, {
	"Path": "org.lwjgl.util.mapped.MappedObject.runViewConstructor",
	"Comment": "any code in the default constructor will not run automatically. this method\tcan be used to execute that code on the current view.",
	"Method": "void runViewConstructor(){\r\n    throw new InternalError(\"type not registered\");\r\n}"
}, {
	"Path": "io.opencensus.contrib.agent.instrumentation.ThreadInstrumentationBenchmark.manual",
	"Comment": "this benchmark attempts to measure the performance with manual context propagation.",
	"Method": "void manual(Blackhole blackhole){\r\n    Thread t = new Thread(Context.current().wrap(new MyRunnable(blackhole)));\r\n    t.start();\r\n    t.join();\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testHorizPageOverflowFloat",
	"Comment": "tests that static floated blocks overflow onto inserted shadow page.",
	"Method": "void testHorizPageOverflowFloat(){\r\n    assertTrue(vt.runTest(\"horiz-page-overflow-float\"));\r\n}"
}, {
	"Path": "org.lwjgl.PointerBuffer.getPointerSize",
	"Comment": "returns the pointer size in bytes, based on the underlying architecture.",
	"Method": "int getPointerSize(){\r\n    return is64Bit ? 8 : 4;\r\n}"
}, {
	"Path": "com.openhtmltopdf.nonvisualregressiontests.NonVisualRegressionTest.testLinkOnOverflowTarget",
	"Comment": "tests that a simple block link successfully links to an element on an inserted overflow page.",
	"Method": "void testLinkOnOverflowTarget(){\r\n    PDDocument doc = run(\"link-on-overflow-target\");\r\n    assertEquals(1, doc.getPage(0).getAnnotations().size());\r\n    assertThat(doc.getPage(0).getAnnotations().get(0), instanceOf(PDAnnotationLink.class));\r\n    PDAnnotationLink link = (PDAnnotationLink) doc.getPage(0).getAnnotations().get(0);\r\n    assertThat(link.getRectangle(), rectEquals(new PDRectangle(10f, 10f, 80f, 10f), 100d));\r\n    assertThat(link.getAction(), instanceOf(PDActionGoTo.class));\r\n    PDActionGoTo action = (PDActionGoTo) link.getAction();\r\n    assertThat(action.getDestination(), instanceOf(PDPageXYZDestination.class));\r\n    PDPageXYZDestination dest = (PDPageXYZDestination) action.getDestination();\r\n    assertEquals(doc.getPage(2), dest.getPage());\r\n    assertEquals(cssPixelYToPdfPoints(11, 100), dest.getTop(), 1.0d);\r\n    remove(\"link-on-overflow-target\", doc);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.Options.isLoadVerbose",
	"Comment": "returns whether or not to render loading text in the splash screen.",
	"Method": "boolean isLoadVerbose(){\r\n    return GameOption.LOAD_VERBOSE.getBooleanValue();\r\n}"
}, {
	"Path": "com.j256.ormlite.table.TableInfo.createObject",
	"Comment": "create and return an object of this type using our reflection constructor.",
	"Method": "T createObject(){\r\n    try {\r\n        T instance;\r\n        ObjectFactory<T> factory = null;\r\n        if (baseDaoImpl != null) {\r\n            factory = baseDaoImpl.getObjectFactory();\r\n        }\r\n        if (factory == null) {\r\n            instance = constructor.newInstance();\r\n        } else {\r\n            instance = factory.createObject(constructor, baseDaoImpl.getDataClass());\r\n        }\r\n        wireNewInstance(baseDaoImpl, instance);\r\n        return instance;\r\n    } catch (Exception e) {\r\n        throw SqlExceptionUtil.create(\"Could not create object for \" + constructor.getDeclaringClass(), e);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.BeatmapSetList.expand",
	"Comment": "expands the node at an index by inserting a new node for each beatmap\tin that node and hiding the group node.",
	"Method": "BeatmapSetNode expand(int index){\r\n    unexpand();\r\n    BeatmapSetNode node = getBaseNode(index);\r\n    if (node == null)\r\n        return null;\r\n    expandedStartNode = expandedEndNode = null;\r\n    BeatmapSet beatmapSet = node.getBeatmapSet();\r\n    BeatmapSetNode prevNode = node.prev;\r\n    BeatmapSetNode nextNode = node.next;\r\n    for (int i = 0, size = beatmapSet.size(); i < size; i++) {\r\n        BeatmapSetNode newNode = new BeatmapSetNode(beatmapSet);\r\n        newNode.index = index;\r\n        newNode.beatmapIndex = i;\r\n        newNode.prev = node;\r\n        if (i == 0) {\r\n            expandedStartNode = newNode;\r\n            newNode.prev = prevNode;\r\n            if (prevNode != null)\r\n                prevNode.next = newNode;\r\n        }\r\n        node.next = newNode;\r\n        node = node.next;\r\n    }\r\n    if (nextNode != null) {\r\n        node.next = nextNode;\r\n        nextNode.prev = node;\r\n    }\r\n    expandedEndNode = node;\r\n    expandedIndex = index;\r\n    return expandedStartNode;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getCaretOffset",
	"Comment": "returns the caret position relative to the start of the text.",
	"Method": "int getCaretOffset(){\r\n    checkWidget();\r\n    return caretOffset;\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix3f.negate",
	"Comment": "negate the source matrix and place the result in the destination matrix.",
	"Method": "Matrix negate(Matrix3f negate,Matrix3f dest,Matrix3f negate,Matrix3f src,Matrix3f dest){\r\n    if (dest == null)\r\n        dest = new Matrix3f();\r\n    dest.m00 = -src.m00;\r\n    dest.m01 = -src.m02;\r\n    dest.m02 = -src.m01;\r\n    dest.m10 = -src.m10;\r\n    dest.m11 = -src.m12;\r\n    dest.m12 = -src.m11;\r\n    dest.m20 = -src.m20;\r\n    dest.m21 = -src.m22;\r\n    dest.m22 = -src.m21;\r\n    return dest;\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.FSImageWriter.getImageWriteParameters",
	"Comment": "returns the image output parameters to control the output image quality, compression, etc. by defaultthis uses the compression values set in this class. override this method to get full control over theimagewriteparam used in image output.",
	"Method": "ImageWriteParam getImageWriteParameters(ImageWriter writer){\r\n    ImageWriteParam param = writer.getDefaultWriteParam();\r\n    if (param.canWriteCompressed()) {\r\n        if (writeCompressionMode != ImageWriteParam.MODE_COPY_FROM_METADATA) {\r\n            param.setCompressionMode(writeCompressionMode);\r\n            if (writeCompressionMode == ImageWriteParam.MODE_EXPLICIT) {\r\n                param.setCompressionType(writeCompressionType);\r\n                param.setCompressionQuality(writeCompressionQuality);\r\n            }\r\n        }\r\n    }\r\n    return param;\r\n}"
}, {
	"Path": "ddf.minim.Controller.setGain",
	"Comment": "sets the gain. if a gain control is not available,this does nothing.",
	"Method": "void setGain(float value){\r\n    setValue(GAIN, value);\r\n}"
}, {
	"Path": "ddf.minim.ugens.DefaultInstrument.noteOff",
	"Comment": "turn off the default instrument.\ttypically, you will not call this directly.\tit will be called at the appropriate time by \tthe audioouput you schedule a note with.",
	"Method": "void noteOff(){\r\n    summer.unpatch(output);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.showCaret",
	"Comment": "sets the caret location and scrolls the caret offset into view.",
	"Method": "void showCaret(){\r\n    Rectangle bounds = getBoundsAtOffset(caretOffset);\r\n    if (!showLocation(bounds, true)) {\r\n        setCaretLocation();\r\n    }\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.isCaching",
	"Comment": "returns true if this unicodefont caches the glyph drawing instructions to \timprove performance.",
	"Method": "boolean isCaching(){\r\n    return displayListCaching;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.GameData.handleHitResult",
	"Comment": "handles a hit result and performs all associated calculations.",
	"Method": "int handleHitResult(int time,int result,float x,float y,Color color,boolean end,HitObject hitObject,HitObjectType hitResultType,int repeat,boolean noIncrementCombo){\r\n    int hitValue = 0;\r\n    switch(result) {\r\n        case HIT_300:\r\n            hitValue = 300;\r\n            break;\r\n        case HIT_100:\r\n            hitValue = 100;\r\n            comboEnd |= 1;\r\n            break;\r\n        case HIT_50:\r\n            hitValue = 50;\r\n            comboEnd |= 2;\r\n            break;\r\n        case HIT_MISS:\r\n            hitValue = 0;\r\n            comboEnd |= 2;\r\n            resetComboStreak();\r\n            break;\r\n        default:\r\n            return HIT_MISS;\r\n    }\r\n    if (hitValue > 0) {\r\n        SoundController.playHitSound(hitObject.getEdgeHitSoundType(repeat), hitObject.getSampleSet(repeat), hitObject.getAdditionSampleSet(repeat));\r\n        changeScore(getScoreForHit(hitValue, hitObject));\r\n        if (!noIncrementCombo)\r\n            incrementComboStreak();\r\n    }\r\n    health.changeHealthForHit(result);\r\n    hitResultCount[result]++;\r\n    fullObjectCount++;\r\n    if (end) {\r\n        if (comboEnd == 0) {\r\n            result = HIT_300G;\r\n            health.changeHealthForHit(HIT_300G);\r\n            hitResultCount[result]++;\r\n        } else if ((comboEnd & 2) == 0) {\r\n            if (result == HIT_100) {\r\n                result = HIT_100K;\r\n                health.changeHealthForHit(HIT_100K);\r\n                hitResultCount[result]++;\r\n            } else if (result == HIT_300) {\r\n                result = HIT_300K;\r\n                health.changeHealthForHit(HIT_300K);\r\n                hitResultCount[result]++;\r\n            }\r\n        } else if (hitValue > 0)\r\n            health.changeHealthForHit(HIT_MU);\r\n        comboEnd = 0;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "ddf.minim.ugens.GranulateRandom.randomBetween",
	"Comment": "todo place randombetween somewhere more generic and useful.",
	"Method": "float randomBetween(float min,float max){\r\n    return (max - min) * (float) Math.random() + min;\r\n}"
}, {
	"Path": "io.opencensus.contrib.agent.instrumentation.ExecutorInstrumentationBenchmark.none",
	"Comment": "this benchmark attempts to measure the performance without any context propagation.",
	"Method": "void none(Blackhole blackhole){\r\n    MoreExecutors.directExecutor().execute(new MyRunnable(blackhole));\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.systemShouldAdvance",
	"Comment": "check if this spring should be advanced by the system. the rule is if the spring iscurrently at rest and it was at rest in the previous advance, the system can skip this spring",
	"Method": "boolean systemShouldAdvance(){\r\n    return !isAtRest() || !wasAtRest();\r\n}"
}, {
	"Path": "com.openhtmltopdf.java2d.api.DefaultPageProcessor.createLayoutGraphics",
	"Comment": "create a graphics device that can be supplied to uselayoutgraphics.\tthe caller is responsible for calling dispose on the returned device.",
	"Method": "Graphics2D createLayoutGraphics(){\r\n    BufferedImage bf = new BufferedImage(1, 1, _imageType);\r\n    return bf.createGraphics();\r\n}"
}, {
	"Path": "io.opencensus.exporter.stats.stackdriver.StackdriverExportUtils.createBucketOptions",
	"Comment": "convert a opencensus bucketoptions to a stackdriver bucketoptions",
	"Method": "BucketOptions createBucketOptions(io.opencensus.metrics.export.Distribution.BucketOptions bucketOptions){\r\n    final BucketOptions.Builder builder = BucketOptions.newBuilder();\r\n    if (bucketOptions == null) {\r\n        return builder.build();\r\n    }\r\n    return bucketOptions.match(bucketOptionsExplicitFunction, Functions.<BucketOptions>throwIllegalArgumentException());\r\n}"
}, {
	"Path": "org.newdawn.slick.Image.getName",
	"Comment": "return a meaningful tagging name that has been assigned to this image.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.getAscent",
	"Comment": "gets the distance from the baseline to the y drawing location.",
	"Method": "int getAscent(){\r\n    return ascent;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.Options.isDefaultPlayfieldForced",
	"Comment": "returns whether or not to override the beatmap background with the default playfield background.",
	"Method": "boolean isDefaultPlayfieldForced(){\r\n    return GameOption.FORCE_DEFAULT_PLAYFIELD.getBooleanValue();\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.setIndent",
	"Comment": "sets the line indentation of the widget.it is the amount of blank space, in pixels, at the beginning of each line. when a line wraps in several lines only the first one is indented.",
	"Method": "void setIndent(int indent){\r\n    checkWidget();\r\n    if (this.indent == indent || indent < 0)\r\n        return;\r\n    this.indent = indent;\r\n    resetCache(0, content.getLineCount());\r\n    setCaretLocation();\r\n    super.redraw();\r\n}"
}, {
	"Path": "orestes.bloomfilter.test.comparisons.BloomFilterMagnus.createHash",
	"Comment": "generates a digest based on the contents of an array of bytes.",
	"Method": "int createHash(String val,Charset charset,int createHash,String val,int createHash,byte[] data){\r\n    return createHashes(data, 1)[0];\r\n}"
}, {
	"Path": "org.mewx.wenku8.activity.MainActivity.changeFragment",
	"Comment": "this function will be called by navigationdrawerfragment,once called, change fragment.",
	"Method": "void changeFragment(Fragment targetFragment){\r\n    if (getSupportActionBar() != null) {\r\n        if (status == FRAGMENT_LIST.RKLIST)\r\n            getSupportActionBar().setElevation(0);\r\n        else\r\n            getSupportActionBar().setElevation(getResources().getDimension(R.dimen.toolbar_elevation));\r\n    }\r\n    getSupportFragmentManager().beginTransaction().replace(R.id.container, targetFragment, \"fragment\").setTransitionStyle(FragmentTransaction.TRANSIT_FRAGMENT_FADE).commit();\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.Box.getHeight",
	"Comment": "uh oh! this refers to content height during layout but total height after layout!",
	"Method": "int getHeight(){\r\n    return _height;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doPageStart",
	"Comment": "moves the cursor to the beginning of the first fully visible line.",
	"Method": "void doPageStart(){\r\n    int topOffset;\r\n    if (wordWrap) {\r\n        int y, lineIndex;\r\n        if (topIndexY > 0) {\r\n            lineIndex = topIndex - 1;\r\n            y = renderer.getLineHeight(lineIndex) - topIndexY;\r\n        } else {\r\n            lineIndex = topIndex;\r\n            y = -topIndexY;\r\n        }\r\n        TextLayout layout = renderer.getTextLayout(lineIndex);\r\n        int index = 0;\r\n        int lineCount = layout.getLineCount();\r\n        while (index < lineCount) {\r\n            Rectangle bounds = layout.getLineBounds(index);\r\n            if (y <= bounds.y)\r\n                break;\r\n            index++;\r\n        }\r\n        if (index == lineCount) {\r\n            topOffset = content.getOffsetAtLine(lineIndex + 1);\r\n        } else {\r\n            topOffset = content.getOffsetAtLine(lineIndex) + layout.getLineOffsets()[index];\r\n        }\r\n        renderer.disposeTextLayout(layout);\r\n    } else {\r\n        topOffset = content.getOffsetAtLine(topIndex);\r\n    }\r\n    if (caretOffset > topOffset) {\r\n        setCaretOffset(topOffset, OFFSET_LEADING);\r\n        showCaret();\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.BufferUtils.getOffset",
	"Comment": "a helper function which is used to get the byte offset in an arbitrary buffer\tbased on its position",
	"Method": "int getOffset(Buffer buffer){\r\n    return buffer.position() << getElementSizeExponent(buffer);\r\n}"
}, {
	"Path": "org.lwjgl.opengl.GLContext.getCapabilities",
	"Comment": "returns the capabilities instance associated with the specified context object.",
	"Method": "ContextCapabilities getCapabilities(ContextCapabilities getCapabilities,Object context){\r\n    return capability_cache.get(context);\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGL.eglGetConfigsNum",
	"Comment": "returns the number of eglconfigs that are available on the specified display.",
	"Method": "int eglGetConfigsNum(EGLDisplay dpy){\r\n    IntBuffer num_config = APIUtil.getBufferInt();\r\n    if (!neglGetConfigs(dpy.getPointer(), 0L, 0, MemoryUtil.getAddress0(num_config)))\r\n        throwEGLError(\"Failed to get EGL configs.\");\r\n    return num_config.get(0);\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.Configuration.valueAsByte",
	"Comment": "returns the value for key in the configuration as a byte, or the defaultprovided value if not found or if the value is not a valid byte. awarning is issued to the log if the property is not defined, or if theconversion from string fails.",
	"Method": "int valueAsByte(String key,byte defaultVal){\r\n    String val = valueFor(key);\r\n    if (val == null) {\r\n        return defaultVal;\r\n    }\r\n    byte bval;\r\n    try {\r\n        bval = Byte.valueOf(val).byteValue();\r\n    } catch (NumberFormatException nex) {\r\n        XRLog.exception(\"Property '\" + key + \"' was requested as a byte, but \" + \"value of '\" + val + \"' is not a byte. Check configuration.\");\r\n        bval = defaultVal;\r\n    }\r\n    return bval;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.states.DownloadsMenu.resetSearchTimer",
	"Comment": "resets the search timer, but respects the minimum request interval.",
	"Method": "void resetSearchTimer(){\r\n    if (!searchTimerReset) {\r\n        if (searchTimer < MIN_REQUEST_INTERVAL)\r\n            searchTimer = SEARCH_DELAY - MIN_REQUEST_INTERVAL;\r\n        else\r\n            searchTimer = SEARCH_DELAY;\r\n        searchTimerReset = true;\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.states.Game.getFadeInTime",
	"Comment": "returns the amount of time for hit objects to fade in, in milliseconds.",
	"Method": "int getFadeInTime(){\r\n    return fadeInTime;\r\n}"
}, {
	"Path": "org.newdawn.slick.Image.getRotation",
	"Comment": "get the current angle of rotation for this image.the image will be rotated around its center.",
	"Method": "float getRotation(){\r\n    return angle;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.Display.createWindow",
	"Comment": "create the native window peer from the given mode and fullscreen flag.\ta native context must exist, and it will be attached to the window.",
	"Method": "void createWindow(){\r\n    if (window_created) {\r\n        return;\r\n    }\r\n    Canvas tmp_parent = isFullscreen() ? null : parent;\r\n    if (tmp_parent != null && !tmp_parent.isDisplayable())\r\n        throw new LWJGLException(\"Parent.isDisplayable() must be true\");\r\n    if (tmp_parent != null) {\r\n        tmp_parent.addComponentListener(component_listener);\r\n    }\r\n    DisplayMode mode = getEffectiveMode();\r\n    display_impl.createWindow(drawable, mode, tmp_parent, getWindowX(), getWindowY());\r\n    window_created = true;\r\n    width = Display.getDisplayMode().getWidth();\r\n    height = Display.getDisplayMode().getHeight();\r\n    setTitle(title);\r\n    initControls();\r\n    if (cached_icons != null) {\r\n        setIcon(cached_icons);\r\n    } else {\r\n        setIcon(new ByteBuffer[] { LWJGLUtil.LWJGLIcon32x32, LWJGLUtil.LWJGLIcon16x16 });\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.constants.IdentValue.addValue",
	"Comment": "adds a feature to the value attribute of the identvalue class",
	"Method": "IdentValue addValue(String ident){\r\n    if (ALL_IDENT_VALUES == null) {\r\n        ALL_IDENT_VALUES = new HashMap<String, IdentValue>();\r\n    }\r\n    IdentValue val = new IdentValue(ident);\r\n    ALL_IDENT_VALUES.put(ident, val);\r\n    return val;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ScoreData.getGrade",
	"Comment": "returns letter grade based on score data,\tor grade.null if no objects have been processed.",
	"Method": "Grade getGrade(){\r\n    if (grade == null)\r\n        grade = GameData.getGrade(hit300, hit100, hit50, miss, ((mods & GameMod.HIDDEN.getBit()) > 0 || (mods & GameMod.FLASHLIGHT.getBit()) > 0));\r\n    return grade;\r\n}"
}, {
	"Path": "org.newdawn.slick.Input.addControllerListener",
	"Comment": "add a controller listener to be notified of controller input events",
	"Method": "void addControllerListener(ControllerListener listener){\r\n    if (controllerListeners.contains(listener)) {\r\n        return;\r\n    }\r\n    controllerListeners.add(listener);\r\n    allListeners.add(listener);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.Utils.isJarRunning",
	"Comment": "returns whether or not the application is running within a jar.",
	"Method": "boolean isJarRunning(){\r\n    return Opsu.class.getResource(String.format(\"%s.class\", Opsu.class.getSimpleName())).toString().startsWith(\"jar:\");\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGLNVSync.eglCreateFenceSyncNV",
	"Comment": "creates a fence sync object for the specified egl display and returns\ta handle to the new object.",
	"Method": "EGLSyncNV eglCreateFenceSyncNV(EGLDisplay dpy,int condition,IntBuffer attrib_list){\r\n    checkAttribList(attrib_list);\r\n    final long pointer = neglCreateFenceSyncNV(dpy.getPointer(), condition, MemoryUtil.getAddressSafe(attrib_list));\r\n    if (pointer == EGL_NO_SYNC_NV)\r\n        throwEGLError(\"Failed to create NV fence sync object.\");\r\n    return new EGLSyncNV(pointer);\r\n}"
}, {
	"Path": "org.lwjgl.opengl.ContextGLES.destroy",
	"Comment": "request destruction of the context. if the context is current, no context will be current after this call.\tthe context is destroyed when no thread has it current.",
	"Method": "void destroy(){\r\n    if (destroyed)\r\n        return;\r\n    destroy_requested = true;\r\n    boolean was_current = isCurrent();\r\n    int error = GLES20.GL_NO_ERROR;\r\n    if (was_current) {\r\n        if (org.lwjgl.opengles.GLContext.getCapabilities() != null && GLContext.getCapabilities().OpenGLES20)\r\n            error = GLES20.glGetError();\r\n        try {\r\n            releaseCurrent();\r\n        } catch (PowerManagementEventException e) {\r\n        }\r\n    }\r\n    checkDestroy();\r\n    if (was_current && error != GLES20.GL_NO_ERROR)\r\n        throw new OpenGLException(error);\r\n}"
}, {
	"Path": "ddf.minim.MultiChannelBuffer.setBufferSize",
	"Comment": "set the length of this buffer in sample frames.\tdoing this will retain all of the sample data \tthat can fit into the new buffer size.",
	"Method": "void setBufferSize(int bufferSize){\r\n    if (this.bufferSize != bufferSize) {\r\n        this.bufferSize = bufferSize;\r\n        for (int i = 0; i < channels.length; ++i) {\r\n            float[] newChannel = new float[bufferSize];\r\n            System.arraycopy(channels[i], 0, newChannel, 0, (bufferSize < channels[i].length ? bufferSize : channels[i].length));\r\n            channels[i] = newChannel;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mewx.wenku8.global.api.Wenku8API.getUserLoginParams",
	"Comment": "this part is user related, and is using the latest api 22 features.banned namevaluepair, httppost.",
	"Method": "ContentValues getUserLoginParams(String username,String password){\r\n    String temp = \"action=login&username=\" + LightNetwork.encodeToHttp(username) + \"&password=\" + LightNetwork.encodeToHttp(password);\r\n    return getEncryptedCV(temp);\r\n}"
}, {
	"Path": "io.opencensus.implcore.stats.StatsTestUtil.assertDistributionDataEquals",
	"Comment": "compare the expected and actual distributiondata within the given tolerance.",
	"Method": "void assertDistributionDataEquals(DistributionData expected,DistributionData actual,double tolerance){\r\n    assertThat(actual.getMean()).isWithin(tolerance).of(expected.getMean());\r\n    assertThat(actual.getCount()).isEqualTo(expected.getCount());\r\n    assertThat(actual.getMean()).isWithin(tolerance).of(expected.getMean());\r\n    assertThat(actual.getSumOfSquaredDeviations()).isWithin(tolerance).of(expected.getSumOfSquaredDeviations());\r\n    assertThat(removeTrailingZeros(actual.getBucketCounts())).isEqualTo(removeTrailingZeros(expected.getBucketCounts()));\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.HitObject.getScaledSliderY",
	"Comment": "returns a list of scaled slider y coordinates.\tnote that this method will create a new array.",
	"Method": "float[] getScaledSliderY(){\r\n    if (sliderY == null)\r\n        return null;\r\n    float[] y = new float[sliderY.length];\r\n    if (GameMod.HARD_ROCK.isActive()) {\r\n        for (int i = 0; i < y.length; i++) y[i] = containerHeight - ((sliderY[i] + stack * stackOffset) * yMultiplier + yOffset);\r\n    } else {\r\n        for (int i = 0; i < y.length; i++) y[i] = (sliderY[i] - stack * stackOffset) * yMultiplier + yOffset;\r\n    }\r\n    return y;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.HitObject.getScaledSliderX",
	"Comment": "returns a list of scaled slider x coordinates.\tnote that this method will create a new array.",
	"Method": "float[] getScaledSliderX(){\r\n    if (sliderX == null)\r\n        return null;\r\n    float[] x = new float[sliderX.length];\r\n    for (int i = 0; i < x.length; i++) x[i] = (sliderX[i] - stack * stackOffset) * xMultiplier + xOffset;\r\n    return x;\r\n}"
}, {
	"Path": "com.openhtmltopdf.swing.SwingReplacedElementFactory.reset",
	"Comment": "clears out any references to elements or items created by this factory so far.",
	"Method": "void reset(){\r\n    forms = null;\r\n}"
}, {
	"Path": "org.zalando.nakadi.repository.MultiTimelineEventConsumer.poll",
	"Comment": "gets data from current event consumers. it tries to use as less list allocations as it is possible.",
	"Method": "List<ConsumedEvent> poll(){\r\n    List<ConsumedEvent> result = null;\r\n    boolean newCollectionCreated = false;\r\n    for (final EventConsumer consumer : eventConsumers.values()) {\r\n        final List<ConsumedEvent> partialResult = consumer.readEvents();\r\n        if (null == result) {\r\n            result = partialResult;\r\n        } else {\r\n            if (!newCollectionCreated) {\r\n                result = new ArrayList(result);\r\n                newCollectionCreated = true;\r\n            }\r\n            result.addAll(partialResult);\r\n        }\r\n    }\r\n    return result == null ? Collections.emptyList() : result;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGLNVSync.eglSignalSyncNV",
	"Comment": "signals or unsignals the sync object by changing its status to\tthe specified mode.",
	"Method": "void eglSignalSyncNV(EGLSyncNV sync,int mode){\r\n    if (!neglSignalSyncNV(sync.getPointer(), mode))\r\n        throwEGLError(\"Failed to signal the NV fence sync object.\");\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.DownloadList.getNode",
	"Comment": "returns the downloadnode at an index, or null if the index is out of bounds.",
	"Method": "DownloadNode getNode(int index){\r\n    try {\r\n        return nodes.get(index);\r\n    } catch (IndexOutOfBoundsException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.LWJGLUtil.getPathFromClassLoader",
	"Comment": "tries to locate named library from the current classloader\tthis method exists because native libraries are loaded from native code, and as such\tis exempt from classloader library loading rutines. it therefore always fails.\twe therefore invoke the protected method of the classloader to see if it can\tlocate it.",
	"Method": "String getPathFromClassLoader(String libname,ClassLoader classloader){\r\n    Class<?> c = null;\r\n    try {\r\n        log(\"getPathFromClassLoader: searching for: \" + libname);\r\n        c = classloader.getClass();\r\n        while (c != null) {\r\n            final Class<?> clazz = c;\r\n            try {\r\n                return AccessController.doPrivileged(new PrivilegedExceptionAction<String>() {\r\n                    public String run() throws Exception {\r\n                        Method findLibrary = clazz.getDeclaredMethod(\"findLibrary\", String.class);\r\n                        findLibrary.setAccessible(true);\r\n                        String path = (String) findLibrary.invoke(classloader, libname);\r\n                        return path;\r\n                    }\r\n                });\r\n            } catch (PrivilegedActionException e) {\r\n                log(\"Failed to locate findLibrary method: \" + e.getCause());\r\n                c = c.getSuperclass();\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        log(\"Failure locating \" + e + \" using classloader:\" + c);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.lwjgl.LWJGLUtil.getPathFromClassLoader",
	"Comment": "tries to locate named library from the current classloader\tthis method exists because native libraries are loaded from native code, and as such\tis exempt from classloader library loading rutines. it therefore always fails.\twe therefore invoke the protected method of the classloader to see if it can\tlocate it.",
	"Method": "String getPathFromClassLoader(String libname,ClassLoader classloader){\r\n    Method findLibrary = clazz.getDeclaredMethod(\"findLibrary\", String.class);\r\n    findLibrary.setAccessible(true);\r\n    String path = (String) findLibrary.invoke(classloader, libname);\r\n    return path;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.ContextGL.releaseDrawable",
	"Comment": "release the context from its drawable. this is necessary on some platforms,\tlike mac os x, where binding the context to a drawable and binding the context\tfor rendering are two distinct actions and where calling releasedrawable\ton every releasecurrentcontext results in artifacts.",
	"Method": "void releaseDrawable(){\r\n    if (destroyed)\r\n        throw new IllegalStateException(\"Context is destroyed\");\r\n    implementation.releaseDrawable(getHandle());\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGLDisplay.query",
	"Comment": "returns a string describing some aspect of the egl implementation running on the specified display.",
	"Method": "String query(int name){\r\n    checkInitialized();\r\n    return eglQueryString(this, name);\r\n}"
}, {
	"Path": "com.iwebpp.node.stream.Transform._read",
	"Comment": "that we got here means that the readable side wants more data.",
	"Method": "void _read(int size){\r\n    final TransformState ts = this._transformState;\r\n    if (!Util.isNull(ts.writechunk) && ts.writecb != null && !ts.transforming) {\r\n        ts.transforming = true;\r\n        this._transform(ts.writechunk, ts.writeencoding, new afterTransformCallback() {\r\n            @Override\r\n            public void afterTransform(String error, Object data) throws Exception {\r\n                ts.afterTransform(error, null);\r\n            }\r\n        });\r\n    } else {\r\n        ts.needTransform = true;\r\n    }\r\n}"
}, {
	"Path": "com.iwebpp.node.stream.Transform._read",
	"Comment": "that we got here means that the readable side wants more data.",
	"Method": "void _read(int size){\r\n    ts.afterTransform(error, null);\r\n}"
}, {
	"Path": "org.lwjgl.util.generator.NativeTypeTranslator.getAnnotation",
	"Comment": "check if the annotation is itself annotated with a certain annotation type",
	"Method": "T getAnnotation(AnnotationMirror annotation,Class<T> type){\r\n    return annotation.getAnnotationType().asElement().getAnnotation(type);\r\n}"
}, {
	"Path": "ddf.minim.ugens.Pan.setChannelCount",
	"Comment": "pan overrides setchannelcount to ensure that it can \tnever be set to output more or fewer than 2 channels.",
	"Method": "void setChannelCount(int numberOfChannels){\r\n    if (numberOfChannels == 2) {\r\n        super.setChannelCount(numberOfChannels);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Pan MUST be ticked with STEREO output! It doesn't make sense in any other context!\");\r\n    }\r\n}"
}, {
	"Path": "org.newdawn.slick.GameContainer.setMultiSample",
	"Comment": "indicate whether we want to try to use fullscreen multisampling. this will\tgive antialiasing across the whole scene using a hardware feature.",
	"Method": "void setMultiSample(int samples){\r\n    this.samples = samples;\r\n}"
}, {
	"Path": "com.openhtmltopdf.swing.NaiveUserAgent.isVisited",
	"Comment": "returns true if the given uri was visited, meaning it was requested at some point since initialization.",
	"Method": "boolean isVisited(String uri){\r\n    return false;\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix3f.invert",
	"Comment": "invert the source matrix and put the result into the destination matrix",
	"Method": "Matrix invert(Matrix3f invert,Matrix3f src,Matrix3f dest){\r\n    float determinant = src.determinant();\r\n    if (determinant != 0) {\r\n        if (dest == null)\r\n            dest = new Matrix3f();\r\n        float determinant_inv = 1f / determinant;\r\n        float t00 = src.m11 * src.m22 - src.m12 * src.m21;\r\n        float t01 = -src.m10 * src.m22 + src.m12 * src.m20;\r\n        float t02 = src.m10 * src.m21 - src.m11 * src.m20;\r\n        float t10 = -src.m01 * src.m22 + src.m02 * src.m21;\r\n        float t11 = src.m00 * src.m22 - src.m02 * src.m20;\r\n        float t12 = -src.m00 * src.m21 + src.m01 * src.m20;\r\n        float t20 = src.m01 * src.m12 - src.m02 * src.m11;\r\n        float t21 = -src.m00 * src.m12 + src.m02 * src.m10;\r\n        float t22 = src.m00 * src.m11 - src.m01 * src.m10;\r\n        dest.m00 = t00 * determinant_inv;\r\n        dest.m11 = t11 * determinant_inv;\r\n        dest.m22 = t22 * determinant_inv;\r\n        dest.m01 = t10 * determinant_inv;\r\n        dest.m10 = t01 * determinant_inv;\r\n        dest.m20 = t02 * determinant_inv;\r\n        dest.m02 = t20 * determinant_inv;\r\n        dest.m12 = t21 * determinant_inv;\r\n        dest.m21 = t12 * determinant_inv;\r\n        return dest;\r\n    } else\r\n        return null;\r\n}"
}, {
	"Path": "io.opencensus.contrib.logcorrelation.stackdriver.OpenCensusTraceLoggingEnhancer.enhanceLogEntry",
	"Comment": "this method avoids getting the current span when the feature is disabled, for efficiency.",
	"Method": "void enhanceLogEntry(LogEntry.Builder builder){\r\n    addTracingData(tracePrefix, getCurrentSpanContext(), builder);\r\n}"
}, {
	"Path": "io.opencensus.implcore.internal.VarInt.getVarInt",
	"Comment": "reads a varint from the given inputstream and returns the decoded value as an int.",
	"Method": "int getVarInt(byte[] src,int offset,int[] dst,int getVarInt,ByteBuffer src,int getVarInt,InputStream inputStream){\r\n    int result = 0;\r\n    int shift = 0;\r\n    int b;\r\n    do {\r\n        if (shift >= 32) {\r\n            throw new IndexOutOfBoundsException(\"varint too long\");\r\n        }\r\n        b = inputStream.read();\r\n        result |= (b & 0x7F) << shift;\r\n        shift += 7;\r\n    } while ((b & 0x80) != 0);\r\n    return result;\r\n}"
}, {
	"Path": "com.openhtmltopdf.nonvisualregressiontests.NonVisualRegressionTest.testFormControlText",
	"Comment": "tests the positioning, size, name and value of a text type form control.",
	"Method": "void testFormControlText(){\r\n    PDDocument doc = run(\"form-control-text\");\r\n    assertEquals(1, doc.getPage(0).getAnnotations().size());\r\n    assertThat(doc.getPage(0).getAnnotations().get(0), instanceOf(PDAnnotationWidget.class));\r\n    PDAnnotationWidget widget = (PDAnnotationWidget) doc.getPage(0).getAnnotations().get(0);\r\n    assertThat(widget.getRectangle(), rectEquals(new PDRectangle(23f, 23f, 100f, 20f), 200));\r\n    PDAcroForm form = doc.getDocumentCatalog().getAcroForm();\r\n    assertEquals(1, form.getFields().size());\r\n    assertThat(form.getFields().get(0), instanceOf(PDTextField.class));\r\n    PDTextField field = (PDTextField) form.getFields().get(0);\r\n    assertEquals(\"text-input\", field.getFullyQualifiedName());\r\n    assertEquals(\"Hello World!\", field.getValue());\r\n    remove(\"form-control-text\", doc);\r\n}"
}, {
	"Path": "org.lwjgl.opengl.NVVideoCaptureUtil.glLockVideoCaptureDeviceNV",
	"Comment": "to lock a video capture device to a display connection, use this method.\tbefore using a video capture device, it must be locked.once a\tvideo capture device is locked by a process, no other process can\tlock a video capture device with the same unique id until the lock\tis released or the process ends.",
	"Method": "boolean glLockVideoCaptureDeviceNV(long device){\r\n    checkExtension();\r\n    return nglLockVideoCaptureDeviceNV(getPeerInfo(), device);\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.getLWJGLCacheDir",
	"Comment": "get path to the lwjgl cache directory. this location will be where\tthe os keeps temporary files.",
	"Method": "String getLWJGLCacheDir(){\r\n    String cacheDir = System.getProperty(\"deployment.user.cachedir\");\r\n    if (cacheDir == null || System.getProperty(\"os.name\").startsWith(\"Win\")) {\r\n        cacheDir = System.getProperty(\"java.io.tmpdir\");\r\n    }\r\n    return cacheDir + File.separator + \"lwjglcache\";\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.handleResize",
	"Comment": "recalculates the scroll bars. rewraps all lines when in word wrap mode.",
	"Method": "void handleResize(Event event){\r\n    int oldHeight = clientAreaHeight;\r\n    int oldWidth = clientAreaWidth;\r\n    Rectangle clientArea = getClientArea();\r\n    clientAreaHeight = clientArea.height;\r\n    clientAreaWidth = clientArea.width;\r\n    if (!alwaysShowScroll && ignoreResize != 0)\r\n        return;\r\n    redrawMargins(oldHeight, oldWidth);\r\n    if (wordWrap) {\r\n        if (oldWidth != clientAreaWidth) {\r\n            renderer.reset(0, content.getLineCount());\r\n            verticalScrollOffset = -1;\r\n            renderer.calculateIdle();\r\n            super.redraw();\r\n        }\r\n        if (oldHeight != clientAreaHeight) {\r\n            if (oldHeight == 0)\r\n                topIndexY = 0;\r\n            setScrollBars(true);\r\n        }\r\n        setCaretLocation();\r\n    } else {\r\n        renderer.calculateClientArea();\r\n        setScrollBars(true);\r\n        claimRightFreeSpace();\r\n        if (clientAreaWidth != 0) {\r\n            ScrollBar horizontalBar = getHorizontalBar();\r\n            if (horizontalBar != null && horizontalBar.getVisible()) {\r\n                if (horizontalScrollOffset != horizontalBar.getSelection()) {\r\n                    horizontalBar.setSelection(horizontalScrollOffset);\r\n                    horizontalScrollOffset = horizontalBar.getSelection();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    updateCaretVisibility();\r\n    claimBottomFreeSpace();\r\n    setAlignment();\r\n}"
}, {
	"Path": "com.openhtmltopdf.nonvisualregressiontests.NonVisualRegressionTest.testLinkAreaPageMarginTransform",
	"Comment": "tests a link area inside a transformed element in the page margin.",
	"Method": "void testLinkAreaPageMarginTransform(){\r\n    PDDocument doc = run(\"link-area-page-margin-transform\");\r\n    assertEquals(1, doc.getPage(0).getAnnotations().size());\r\n    assertEquals(1, doc.getPage(1).getAnnotations().size());\r\n    PDAnnotationLink link = (PDAnnotationLink) doc.getPage(0).getAnnotations().get(0);\r\n    assertThat(link.getRectangle(), rectEquals(new PDRectangle(170f, 70f, 10f, 30f), 100d));\r\n    link = (PDAnnotationLink) doc.getPage(1).getAnnotations().get(0);\r\n    assertThat(link.getRectangle(), rectEquals(new PDRectangle(170f, 70f, 10f, 30f), 100d));\r\n    remove(\"link-area-page-margin-transform\", doc);\r\n}"
}, {
	"Path": "com.nbsp.materialfilepicker.MaterialFilePicker.withFilterDirectories",
	"Comment": "if directoriesfilter is true directories will also be affected by filter,the default value of directories filter is false",
	"Method": "MaterialFilePicker withFilterDirectories(boolean directoriesFilter){\r\n    mDirectoriesFilter = directoriesFilter;\r\n    return this;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGL.eglMakeCurrent",
	"Comment": "binds the specified context to the current thread and to the draw and read surfaces.",
	"Method": "void eglMakeCurrent(EGLDisplay dpy,EGLSurface draw,EGLSurface read,EGLContext ctx){\r\n    if (!neglMakeCurrent(dpy.getPointer(), draw == null ? EGL_NO_SURFACE : draw.getPointer(), read == null ? EGL_NO_SURFACE : read.getPointer(), ctx == null ? EGL_NO_CONTEXT : ctx.getPointer())) {\r\n        final int error = eglGetError();\r\n        if (error == EGL_CONTEXT_LOST)\r\n            throw new PowerManagementEventException();\r\n        else\r\n            throwEGLError(\"Failed to change the current context.\", error);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.Options.isDynamicBackgroundEnabled",
	"Comment": "returns whether or not the main menu background should be the current beatmap background image.",
	"Method": "boolean isDynamicBackgroundEnabled(){\r\n    return GameOption.DYNAMIC_BACKGROUND.getBooleanValue();\r\n}"
}, {
	"Path": "com.openhtmltopdf.layout.TextUtil.isFirstLetterSeparatorChar",
	"Comment": "according to the css spec the first letter includes certain punctuation immediatelypreceding or following the actual first letter.",
	"Method": "boolean isFirstLetterSeparatorChar(int currentChar){\r\n    switch(Character.getType(currentChar)) {\r\n        case Character.START_PUNCTUATION:\r\n        case Character.END_PUNCTUATION:\r\n        case Character.INITIAL_QUOTE_PUNCTUATION:\r\n        case Character.FINAL_QUOTE_PUNCTUATION:\r\n        case Character.OTHER_PUNCTUATION:\r\n        case Character.SPACE_SEPARATOR:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix3f.sub",
	"Comment": "subtract the right matrix from the left and place the result in a third matrix.",
	"Method": "Matrix3f sub(Matrix3f left,Matrix3f right,Matrix3f dest){\r\n    if (dest == null)\r\n        dest = new Matrix3f();\r\n    dest.m00 = left.m00 - right.m00;\r\n    dest.m01 = left.m01 - right.m01;\r\n    dest.m02 = left.m02 - right.m02;\r\n    dest.m10 = left.m10 - right.m10;\r\n    dest.m11 = left.m11 - right.m11;\r\n    dest.m12 = left.m12 - right.m12;\r\n    dest.m20 = left.m20 - right.m20;\r\n    dest.m21 = left.m21 - right.m21;\r\n    dest.m22 = left.m22 - right.m22;\r\n    return dest;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getLineBackgroundData",
	"Comment": "returns the line background data for the given line or null if there is none.",
	"Method": "StyledTextEvent getLineBackgroundData(int lineOffset,String line){\r\n    return sendLineEvent(ST.LineGetBackground, lineOffset, line);\r\n}"
}, {
	"Path": "sun.awt.X11.XWindow.prePostEvent",
	"Comment": "returns true if the event has been handled and should not beposted to java.",
	"Method": "boolean prePostEvent(AWTEvent e){\r\n    return false;\r\n}"
}, {
	"Path": "org.lwjgl.util.glu.Util.glGetIntegerv",
	"Comment": "convenience method for returning an int, rather than getting it out of a buffer yourself.",
	"Method": "int glGetIntegerv(int what){\r\n    scratch.rewind();\r\n    glGetInteger(what, scratch);\r\n    return scratch.get();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.render.FrameBufferCache.freeMap",
	"Comment": "clear the cache of all the mappings. this does not actually delete the\tcached framebuffers, it merely frees them all up to get mapped anew.",
	"Method": "void freeMap(){\r\n    cacheMap.clear();\r\n}"
}, {
	"Path": "io.opencensus.exporter.stats.stackdriver.StackdriverExportUtils.createDistribution",
	"Comment": "convert a opencensus distribution to a stackdriver distribution",
	"Method": "Distribution createDistribution(io.opencensus.metrics.export.Distribution distribution){\r\n    return Distribution.newBuilder().setBucketOptions(createBucketOptions(distribution.getBucketOptions())).addAllBucketCounts(createBucketCounts(distribution.getBuckets())).setCount(distribution.getCount()).setMean(distribution.getCount() == 0 ? 0 : distribution.getSum() / distribution.getCount()).setSumOfSquaredDeviation(distribution.getSumOfSquaredDeviations()).build();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.Download.getDownloadSpeed",
	"Comment": "returns the last calculated download speed, or null if not downloading.",
	"Method": "String getDownloadSpeed(){\r\n    updateReadSoFar();\r\n    return lastDownloadSpeed;\r\n}"
}, {
	"Path": "org.lwjgl.openal.Util.checkALCError",
	"Comment": "checks for any alc errors and throws an unchecked exception on errors",
	"Method": "void checkALCError(ALCdevice device){\r\n    int err = ALC10.alcGetError(device);\r\n    if (err != ALC10.ALC_NO_ERROR)\r\n        throw new OpenALException(ALC10.alcGetString(AL.getDevice(), err));\r\n}"
}, {
	"Path": "org.lwjgl.opengl.PixelFormat.withAlphaBits",
	"Comment": "returns a new pixelformat object with the same properties as this pixelformat and the new alpha bits value.",
	"Method": "PixelFormat withAlphaBits(int alpha){\r\n    if (alpha < 0)\r\n        throw new IllegalArgumentException(\"Invalid number of alpha bits specified: \" + alpha);\r\n    final PixelFormat pf = new PixelFormat(this);\r\n    pf.alpha = alpha;\r\n    return pf;\r\n}"
}, {
	"Path": "orestes.bloomfilter.test.comparisons.BloomFilterMagnus.equals",
	"Comment": "compares the contents of two instances to see if they are equal.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == null) {\r\n        return false;\r\n    }\r\n    if (getClass() != obj.getClass()) {\r\n        return false;\r\n    }\r\n    BloomFilterMagnus<?> other = (BloomFilterMagnus<?>) obj;\r\n    if (this.expectedNumberOfFilterElements != other.expectedNumberOfFilterElements) {\r\n        return false;\r\n    }\r\n    if (this.k != other.k) {\r\n        return false;\r\n    }\r\n    if (this.bitSetSize != other.bitSetSize) {\r\n        return false;\r\n    }\r\n    if (this.bitset != other.bitset && (this.bitset == null || !this.bitset.equals(other.bitset))) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.openhtmltopdf.nonvisualregressiontests.NonVisualRegressionTest.testFormControlAfterOverflowPage",
	"Comment": "tests the positioning, size, name and value of a form control appearing after an overflow page.",
	"Method": "void testFormControlAfterOverflowPage(){\r\n    PDDocument doc = run(\"form-control-after-overflow-page\");\r\n    assertEquals(0, doc.getPage(0).getAnnotations().size());\r\n    assertEquals(0, doc.getPage(1).getAnnotations().size());\r\n    assertEquals(1, doc.getPage(2).getAnnotations().size());\r\n    assertThat(doc.getPage(2).getAnnotations().get(0), instanceOf(PDAnnotationWidget.class));\r\n    PDAnnotationWidget widget = (PDAnnotationWidget) doc.getPage(2).getAnnotations().get(0);\r\n    assertThat(widget.getRectangle(), rectEquals(new PDRectangle(13f, 13f, 60f, 30f), 100));\r\n    PDAcroForm form = doc.getDocumentCatalog().getAcroForm();\r\n    assertEquals(1, form.getFields().size());\r\n    assertThat(form.getFields().get(0), instanceOf(PDTextField.class));\r\n    PDTextField field = (PDTextField) form.getFields().get(0);\r\n    assertEquals(\"text-input\", field.getFullyQualifiedName());\r\n    assertEquals(\"Hello World!\", field.getValue());\r\n    remove(\"form-control-after-overflow-page\", doc);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.Beatmap.compareTo",
	"Comment": "compares two beatmap objects first by overall difficulty, then by total objects.",
	"Method": "int compareTo(Beatmap that){\r\n    int cmp = Float.compare(this.overallDifficulty, that.overallDifficulty);\r\n    if (cmp == 0)\r\n        cmp = Integer.compare(this.hitObjectCircle + this.hitObjectSlider + this.hitObjectSpinner, that.hitObjectCircle + that.hitObjectSlider + that.hitObjectSpinner);\r\n    return cmp;\r\n}"
}, {
	"Path": "org.newdawn.slick.GameContainer.setDefaultFont",
	"Comment": "set the default font that will be intialised in the graphics held in this container",
	"Method": "void setDefaultFont(Font font){\r\n    if (font != null) {\r\n        this.defaultFont = font;\r\n    } else {\r\n        Log.warn(\"Please provide a non null font\");\r\n    }\r\n}"
}, {
	"Path": "com.j256.ormlite.stmt.QueryBuilder.setAlias",
	"Comment": "add an alias for this table. in from clause, the table will use as to define the alias, and qualified fields will\tbe qualified using the alias instead of table name.",
	"Method": "QueryBuilder<T, ID> setAlias(String alias){\r\n    this.alias = alias;\r\n    return this;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.Options.isExperimentalSliderShrinking",
	"Comment": "returns whether or not sliders should shrink toward their ending point.\tonly applies to experimental sliders.",
	"Method": "boolean isExperimentalSliderShrinking(){\r\n    return GameOption.EXPERIMENTAL_SLIDERS_SHRINK.getBooleanValue();\r\n}"
}, {
	"Path": "com.j256.ormlite.field.FieldType.convertStringToJavaField",
	"Comment": "convert a string value into the appropriate java field value.",
	"Method": "Object convertStringToJavaField(String value,int columnPos){\r\n    if (value == null) {\r\n        return null;\r\n    } else {\r\n        return fieldConverter.resultStringToJava(this, value, columnPos);\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.downloadJars",
	"Comment": "will download the jars from the server using the list of urls\tin urllist, while at the same time updating progress bar",
	"Method": "void downloadJars(String path){\r\n    setState(STATE_DOWNLOADING);\r\n    URLConnection urlconnection;\r\n    int initialPercentage = percentage = 15;\r\n    int amountDownloaded = 0;\r\n    byte[] buffer = new byte[65536];\r\n    for (int i = 0; i < urlList.length; i++) {\r\n        if (fileSizes[i] == -2)\r\n            continue;\r\n        int unsuccessfulAttempts = 0;\r\n        int maxUnsuccessfulAttempts = 3;\r\n        boolean downloadFile = true;\r\n        String currentFile = getFileName(urlList[i]);\r\n        while (downloadFile) {\r\n            downloadFile = false;\r\n            debug_sleep(2000);\r\n            try {\r\n                urlconnection = urlList[i].openConnection();\r\n                urlconnection.setUseCaches(false);\r\n                if (urlconnection instanceof HttpURLConnection) {\r\n                    urlconnection.setRequestProperty(\"Cache-Control\", \"no-store,max-age=0,no-cache\");\r\n                    urlconnection.connect();\r\n                }\r\n                InputStream inputstream = getJarInputStream(currentFile, urlconnection);\r\n                FileOutputStream fos = new FileOutputStream(path + currentFile);\r\n                int bufferSize;\r\n                int currentDownload = 0;\r\n                long downloadStartTime = System.currentTimeMillis();\r\n                int downloadedAmount = 0;\r\n                String downloadSpeedMessage = \"\";\r\n                try {\r\n                    while ((bufferSize = inputstream.read(buffer, 0, buffer.length)) != -1) {\r\n                        debug_sleep(10);\r\n                        fos.write(buffer, 0, bufferSize);\r\n                        currentDownload += bufferSize;\r\n                        int totalDownloaded = amountDownloaded + currentDownload;\r\n                        percentage = initialPercentage + ((totalDownloaded * 45) / totalDownloadSize);\r\n                        subtaskMessage = \"Retrieving: \" + currentFile + \" \" + ((totalDownloaded * 100) / totalDownloadSize) + \"%\";\r\n                        downloadedAmount += bufferSize;\r\n                        long timeLapse = System.currentTimeMillis() - downloadStartTime;\r\n                        if (timeLapse >= 1000) {\r\n                            float downloadSpeed = (float) downloadedAmount / timeLapse;\r\n                            downloadSpeed = ((int) (downloadSpeed * 100)) / 100f;\r\n                            downloadSpeedMessage = \" - \" + downloadSpeed + \" KB/sec\";\r\n                            downloadedAmount = 0;\r\n                            downloadStartTime = System.currentTimeMillis();\r\n                        }\r\n                        subtaskMessage += downloadSpeedMessage;\r\n                    }\r\n                } finally {\r\n                    inputstream.close();\r\n                    fos.close();\r\n                }\r\n                if (urlconnection instanceof HttpURLConnection) {\r\n                    if (currentDownload == fileSizes[i]) {\r\n                    } else if (fileSizes[i] <= 0 && currentDownload != 0) {\r\n                    } else {\r\n                        throw new Exception(\"size mismatch on download of \" + currentFile + \" expected \" + fileSizes[i] + \" got \" + currentDownload);\r\n                    }\r\n                }\r\n                amountDownloaded += fileSizes[i];\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n                unsuccessfulAttempts++;\r\n                if (unsuccessfulAttempts < maxUnsuccessfulAttempts) {\r\n                    downloadFile = true;\r\n                    Thread.sleep(100);\r\n                } else {\r\n                    throw new Exception(\"failed to download \" + currentFile + \" after \" + maxUnsuccessfulAttempts + \" attempts\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n    subtaskMessage = \"\";\r\n}"
}, {
	"Path": "com.android.volley.DefaultRetryPolicy.hasAttemptRemaining",
	"Comment": "returns true if this policy has attempts remaining, false otherwise.",
	"Method": "boolean hasAttemptRemaining(){\r\n    return mCurrentRetryCount <= mMaxNumRetries;\r\n}"
}, {
	"Path": "com.openhtmltopdf.context.StandardAttributeResolver.getID",
	"Comment": "gets the id attribute of the standardattributeresolver object",
	"Method": "String getID(Object e){\r\n    return nsh.getID((Element) e);\r\n}"
}, {
	"Path": "ddf.minim.ugens.ADSR.sampleRateChanged",
	"Comment": "use this method to notify the adsr that the sample rate has changed.",
	"Method": "void sampleRateChanged(){\r\n    timeStepSize = 1 / sampleRate();\r\n}"
}, {
	"Path": "com.openhtmltopdf.context.StandardAttributeResolver.isActive",
	"Comment": "gets the active attribute of the standardattributeresolver object",
	"Method": "boolean isActive(Object e){\r\n    return ui.isActive((Element) e);\r\n}"
}, {
	"Path": "org.lwjgl.util.Rectangle.intersection",
	"Comment": "computes the intersection of this rectangle with the \tspecified rectangle. returns a new rectangle \tthat represents the intersection of the two rectangles.\tif the two rectangles do not intersect, the result will be\tan empty rectangle.",
	"Method": "Rectangle intersection(ReadableRectangle r,Rectangle dest){\r\n    int tx1 = this.x;\r\n    int ty1 = this.y;\r\n    int rx1 = r.getX();\r\n    int ry1 = r.getY();\r\n    long tx2 = tx1;\r\n    tx2 += this.width;\r\n    long ty2 = ty1;\r\n    ty2 += this.height;\r\n    long rx2 = rx1;\r\n    rx2 += r.getWidth();\r\n    long ry2 = ry1;\r\n    ry2 += r.getHeight();\r\n    if (tx1 < rx1)\r\n        tx1 = rx1;\r\n    if (ty1 < ry1)\r\n        ty1 = ry1;\r\n    if (tx2 > rx2)\r\n        tx2 = rx2;\r\n    if (ty2 > ry2)\r\n        ty2 = ry2;\r\n    tx2 -= tx1;\r\n    ty2 -= ty1;\r\n    if (tx2 < Integer.MIN_VALUE)\r\n        tx2 = Integer.MIN_VALUE;\r\n    if (ty2 < Integer.MIN_VALUE)\r\n        ty2 = Integer.MIN_VALUE;\r\n    if (dest == null)\r\n        dest = new Rectangle(tx1, ty1, (int) tx2, (int) ty2);\r\n    else\r\n        dest.setBounds(tx1, ty1, (int) tx2, (int) ty2);\r\n    return dest;\r\n}"
}, {
	"Path": "org.lwjgl.input.Controllers.poll",
	"Comment": "poll the controllers available. this will both update their state\tand generate events that must be cleared.",
	"Method": "void poll(){\r\n    for (int i = 0; i < controllers.size(); i++) {\r\n        getController(i).poll();\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.test.applet.GearsApplet.startLWJGL",
	"Comment": "once the canvas is created its add notify method will call this method to\tstart the lwjgl display and game loop in another thread.",
	"Method": "void startLWJGL(){\r\n    gameThread = new Thread() {\r\n        public void run() {\r\n            running = true;\r\n            try {\r\n                Display.setParent(display_parent);\r\n                Display.create();\r\n                initGL();\r\n            } catch (LWJGLException e) {\r\n                e.printStackTrace();\r\n            }\r\n            gameLoop();\r\n        }\r\n    };\r\n    gameThread.start();\r\n}"
}, {
	"Path": "org.lwjgl.test.applet.GearsApplet.startLWJGL",
	"Comment": "once the canvas is created its add notify method will call this method to\tstart the lwjgl display and game loop in another thread.",
	"Method": "void startLWJGL(){\r\n    running = true;\r\n    try {\r\n        Display.setParent(display_parent);\r\n        Display.create();\r\n        initGL();\r\n    } catch (LWJGLException e) {\r\n        e.printStackTrace();\r\n    }\r\n    gameLoop();\r\n}"
}, {
	"Path": "org.newdawn.slick.gui.TextField.doUndo",
	"Comment": "do the undo of the paste, overrideable for custom behaviour",
	"Method": "void doUndo(int oldCursorPos,String oldText){\r\n    if (oldText != null) {\r\n        setText(oldText);\r\n        setCursorPos(oldCursorPos);\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.context.StandardAttributeResolver.isLink",
	"Comment": "gets the link attribute of the standardattributeresolver object",
	"Method": "boolean isLink(Object e){\r\n    return nsh.getLinkUri((Element) e) != null;\r\n}"
}, {
	"Path": "org.lwjgl.examples.spaceinvaders.Game.startGame",
	"Comment": "start a fresh game, this should clear out any old data and\tcreate a new set.",
	"Method": "void startGame(){\r\n    entities.clear();\r\n    initEntities();\r\n}"
}, {
	"Path": "ddf.minim.Minim.createSample",
	"Comment": "creates an audiosample using the provided left and right channel\tsample data.",
	"Method": "AudioSample createSample(float[] sampleData,AudioFormat format,AudioSample createSample,float[] sampleData,AudioFormat format,int bufferSize,AudioSample createSample,float[] leftSampleData,float[] rightSampleData,AudioFormat format,AudioSample createSample,float[] leftSampleData,float[] rightSampleData,AudioFormat format,int bufferSize){\r\n    AudioSample sample = mimp.getAudioSample(leftSampleData, rightSampleData, format, bufferSize);\r\n    addSource(sample);\r\n    return sample;\r\n}"
}, {
	"Path": "ddf.minim.ugens.Damp.setDampTimeFromDuration",
	"Comment": "set the attack time and damp time parameters based on a duration.\tif the current attack time is positive, and less than the total duration, \tthen the damp time is the total duration after the attack time, otherwise, \tthe attack time and damp time are both set to half the duration.",
	"Method": "void setDampTimeFromDuration(float duration){\r\n    float tmpDampTime = duration - attackTime;\r\n    if (tmpDampTime > 0.0f) {\r\n        dampTime = tmpDampTime;\r\n    } else {\r\n        attackTime = duration / 2.0f;\r\n        dampTime = duration / 2.0f;\r\n    }\r\n}"
}, {
	"Path": "orestes.bloomfilter.cachesketch.ExpiringBloomFilterPureRedis.estimateNextDelay",
	"Comment": "returns the delay in milliseconds when to next check the queue for expired items.",
	"Method": "long estimateNextDelay(){\r\n    try (Jedis jedis = pool.getResource()) {\r\n        long now = now();\r\n        long max = now + MAX_JOB_DELAY;\r\n        Set<Tuple> nextQueueItems = jedis.zrangeByScoreWithScores(keys.EXPIRATION_QUEUE_KEY, 0, max, 0, 5);\r\n        if (nextQueueItems.isEmpty()) {\r\n            LOG.debug(\"[{}] Queue empty, next try in {}ms\", config.name(), MAX_JOB_DELAY);\r\n            return MAX_JOB_DELAY;\r\n        }\r\n        long next = nextQueueItems.stream().skip(random.nextInt(nextQueueItems.size())).findFirst().map(Tuple::getScore).map(it -> Math.min(MAX_JOB_DELAY, Math.max(MIN_JOB_DELAY, it.longValue() - now))).orElse(MAX_JOB_DELAY);\r\n        LOG.debug(\"[{}] Estimated a next delay of {}ms\", config.name(), next);\r\n        return next;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getHorizontalIndex",
	"Comment": "returns the horizontal scroll offset relative to the start of the line.",
	"Method": "int getHorizontalIndex(){\r\n    checkWidget();\r\n    return horizontalScrollOffset / getHorizontalIncrement();\r\n}"
}, {
	"Path": "org.newdawn.slick.openal.SoundStore.setCurrentMusicVolume",
	"Comment": "set the music volume of the current playing music. does not affect the global volume",
	"Method": "void setCurrentMusicVolume(float volume){\r\n    if (volume < 0) {\r\n        volume = 0;\r\n    }\r\n    if (volume > 1) {\r\n        volume = 1;\r\n    }\r\n    if (soundWorks) {\r\n        lastCurrentMusicVolume = volume;\r\n        AL10.alSourcef(sources.get(0), AL10.AL_GAIN, lastCurrentMusicVolume * musicVolume);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getTextRange",
	"Comment": "returns the widget content starting at start for length characters.",
	"Method": "String getTextRange(int start,int length){\r\n    checkWidget();\r\n    int contentLength = getCharCount();\r\n    int end = start + length;\r\n    if (start > end || start < 0 || end > contentLength) {\r\n        SWT.error(SWT.ERROR_INVALID_RANGE);\r\n    }\r\n    return content.getTextRange(start, length);\r\n}"
}, {
	"Path": "orestes.bloomfilter.test.comparisons.BloomFilterMagnus.getExpectedNumberOfElements",
	"Comment": "returns the expected number of elements to be inserted into the filter.this value is the same value as the one passed to the constructor.",
	"Method": "int getExpectedNumberOfElements(){\r\n    return expectedNumberOfFilterElements;\r\n}"
}, {
	"Path": "com.openhtmltopdf.layout.SharedContext.setTextRenderer",
	"Comment": "sets the textrenderer attribute of the renderingcontext object",
	"Method": "void setTextRenderer(TextRenderer textRenderer){\r\n    this.textRenderer = textRenderer;\r\n}"
}, {
	"Path": "ddf.minim.ugens.Waves.sawh",
	"Comment": "builds an approximation of a perfect sawtooth wave by summing together\tharmonically related sine waves.",
	"Method": "Wavetable sawh(int numberOfHarmonics){\r\n    float[] content = new float[numberOfHarmonics];\r\n    for (int i = 0; i < numberOfHarmonics; i++) {\r\n        content[i] = (float) ((-2) / ((i + 1) * Math.PI) * Math.pow(-1, i + 1));\r\n    }\r\n    return WavetableGenerator.gen10(tableSize, content);\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix4f.mul",
	"Comment": "multiply the right matrix by the left and place the result in a third matrix.",
	"Method": "Matrix4f mul(Matrix4f left,Matrix4f right,Matrix4f dest){\r\n    if (dest == null)\r\n        dest = new Matrix4f();\r\n    float m00 = left.m00 * right.m00 + left.m10 * right.m01 + left.m20 * right.m02 + left.m30 * right.m03;\r\n    float m01 = left.m01 * right.m00 + left.m11 * right.m01 + left.m21 * right.m02 + left.m31 * right.m03;\r\n    float m02 = left.m02 * right.m00 + left.m12 * right.m01 + left.m22 * right.m02 + left.m32 * right.m03;\r\n    float m03 = left.m03 * right.m00 + left.m13 * right.m01 + left.m23 * right.m02 + left.m33 * right.m03;\r\n    float m10 = left.m00 * right.m10 + left.m10 * right.m11 + left.m20 * right.m12 + left.m30 * right.m13;\r\n    float m11 = left.m01 * right.m10 + left.m11 * right.m11 + left.m21 * right.m12 + left.m31 * right.m13;\r\n    float m12 = left.m02 * right.m10 + left.m12 * right.m11 + left.m22 * right.m12 + left.m32 * right.m13;\r\n    float m13 = left.m03 * right.m10 + left.m13 * right.m11 + left.m23 * right.m12 + left.m33 * right.m13;\r\n    float m20 = left.m00 * right.m20 + left.m10 * right.m21 + left.m20 * right.m22 + left.m30 * right.m23;\r\n    float m21 = left.m01 * right.m20 + left.m11 * right.m21 + left.m21 * right.m22 + left.m31 * right.m23;\r\n    float m22 = left.m02 * right.m20 + left.m12 * right.m21 + left.m22 * right.m22 + left.m32 * right.m23;\r\n    float m23 = left.m03 * right.m20 + left.m13 * right.m21 + left.m23 * right.m22 + left.m33 * right.m23;\r\n    float m30 = left.m00 * right.m30 + left.m10 * right.m31 + left.m20 * right.m32 + left.m30 * right.m33;\r\n    float m31 = left.m01 * right.m30 + left.m11 * right.m31 + left.m21 * right.m32 + left.m31 * right.m33;\r\n    float m32 = left.m02 * right.m30 + left.m12 * right.m31 + left.m22 * right.m32 + left.m32 * right.m33;\r\n    float m33 = left.m03 * right.m30 + left.m13 * right.m31 + left.m23 * right.m32 + left.m33 * right.m33;\r\n    dest.m00 = m00;\r\n    dest.m01 = m01;\r\n    dest.m02 = m02;\r\n    dest.m03 = m03;\r\n    dest.m10 = m10;\r\n    dest.m11 = m11;\r\n    dest.m12 = m12;\r\n    dest.m13 = m13;\r\n    dest.m20 = m20;\r\n    dest.m21 = m21;\r\n    dest.m22 = m22;\r\n    dest.m23 = m23;\r\n    dest.m30 = m30;\r\n    dest.m31 = m31;\r\n    dest.m32 = m32;\r\n    dest.m33 = m33;\r\n    return dest;\r\n}"
}, {
	"Path": "org.mewx.wenku8.fragment.NavigationDrawerFragment.setHighLightButton",
	"Comment": "this function will highlight the button selected, and switch to the fragment in mainactivity.",
	"Method": "void setHighLightButton(MainActivity.FRAGMENT_LIST f){\r\n    if (Build.VERSION.SDK_INT < 16) {\r\n        try {\r\n            switch(f) {\r\n                case RKLIST:\r\n                    ((TextView) mainActivity.findViewById(R.id.main_menu_text_rklist)).setTextColor(getResources().getColor(R.color.menu_item_blue));\r\n                    ((ImageButton) mainActivity.findViewById(R.id.main_menu_ic_rklist)).setColorFilter(getResources().getColor(R.color.menu_item_blue));\r\n                    break;\r\n                case LATEST:\r\n                    ((TextView) mainActivity.findViewById(R.id.main_menu_text_latest)).setTextColor(getResources().getColor(R.color.menu_item_blue));\r\n                    ((ImageButton) mainActivity.findViewById(R.id.main_menu_ic_latest)).setColorFilter(getResources().getColor(R.color.menu_item_blue));\r\n                    break;\r\n                case FAV:\r\n                    ((TextView) mainActivity.findViewById(R.id.main_menu_text_fav)).setTextColor(getResources().getColor(R.color.menu_item_blue));\r\n                    ((ImageButton) mainActivity.findViewById(R.id.main_menu_ic_fav)).setColorFilter(getResources().getColor(R.color.menu_item_blue));\r\n                    break;\r\n                case CONFIG:\r\n                    ((TextView) mainActivity.findViewById(R.id.main_menu_text_config)).setTextColor(getResources().getColor(R.color.menu_item_blue));\r\n                    ((ImageButton) mainActivity.findViewById(R.id.main_menu_ic_config)).setColorFilter(getResources().getColor(R.color.menu_item_blue));\r\n                    break;\r\n            }\r\n        } catch (NullPointerException e) {\r\n            Toast.makeText(mainActivity, \"NullPointerException in setHighLightButton(); sdk16-\", Toast.LENGTH_SHORT).show();\r\n            e.printStackTrace();\r\n        }\r\n    } else {\r\n        try {\r\n            switch(f) {\r\n                case RKLIST:\r\n                    mainActivity.findViewById(R.id.main_menu_rklist).setBackground(getResources().getDrawable(R.drawable.btn_menu_item_selected));\r\n                    ((TextView) mainActivity.findViewById(R.id.main_menu_text_rklist)).setTextColor(getResources().getColor(R.color.menu_text_color_selected));\r\n                    ((ImageButton) mainActivity.findViewById(R.id.main_menu_ic_rklist)).setColorFilter(getResources().getColor(R.color.menu_item_white));\r\n                    break;\r\n                case LATEST:\r\n                    mainActivity.findViewById(R.id.main_menu_latest).setBackground(getResources().getDrawable(R.drawable.btn_menu_item_selected));\r\n                    ((TextView) mainActivity.findViewById(R.id.main_menu_text_latest)).setTextColor(getResources().getColor(R.color.menu_text_color_selected));\r\n                    ((ImageButton) mainActivity.findViewById(R.id.main_menu_ic_latest)).setColorFilter(getResources().getColor(R.color.menu_item_white));\r\n                    break;\r\n                case FAV:\r\n                    mainActivity.findViewById(R.id.main_menu_fav).setBackground(getResources().getDrawable(R.drawable.btn_menu_item_selected));\r\n                    ((TextView) mainActivity.findViewById(R.id.main_menu_text_fav)).setTextColor(getResources().getColor(R.color.menu_text_color_selected));\r\n                    ((ImageButton) mainActivity.findViewById(R.id.main_menu_ic_fav)).setColorFilter(getResources().getColor(R.color.menu_item_white));\r\n                    break;\r\n                case CONFIG:\r\n                    mainActivity.findViewById(R.id.main_menu_config).setBackground(getResources().getDrawable(R.drawable.btn_menu_item_selected));\r\n                    ((TextView) mainActivity.findViewById(R.id.main_menu_text_config)).setTextColor(getResources().getColor(R.color.menu_text_color_selected));\r\n                    ((ImageButton) mainActivity.findViewById(R.id.main_menu_ic_config)).setColorFilter(getResources().getColor(R.color.menu_item_white));\r\n                    break;\r\n            }\r\n        } catch (NullPointerException e) {\r\n            Toast.makeText(mainActivity, \"NullPointerException in setHighLightButton();\", Toast.LENGTH_SHORT).show();\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.j256.ormlite.table.DatabaseTableConfig.getFieldTypes",
	"Comment": "return the field types associated with this configuration.",
	"Method": "FieldType[] getFieldTypes(DatabaseType databaseType){\r\n    if (fieldTypes == null) {\r\n        throw new SQLException(\"Field types have not been extracted in table config\");\r\n    }\r\n    return fieldTypes;\r\n}"
}, {
	"Path": "com.android.volley.CacheDispatcherTest.expiredCacheHit",
	"Comment": "an expired cache hit does not post a response and queues to the network.",
	"Method": "void expiredCacheHit(){\r\n    Cache.Entry entry = CacheTestUtils.makeRandomCacheEntry(null, true, true);\r\n    mCache.setEntryToReturn(entry);\r\n    mCacheQueue.add(mRequest);\r\n    mCacheQueue.waitUntilEmpty(TIMEOUT_MILLIS);\r\n    assertFalse(mDelivery.wasEitherResponseCalled());\r\n    assertTrue(mNetworkQueue.size() > 0);\r\n    Request request = mNetworkQueue.take();\r\n    assertSame(entry, request.getCacheEntry());\r\n}"
}, {
	"Path": "org.lwjgl.opengles.GLContext.getCapabilities",
	"Comment": "get the current capabilities instance. it contains the flags used\tto test for support of a particular extension.",
	"Method": "ContextCapabilities getCapabilities(){\r\n    CapabilitiesCacheEntry recent_cache_entry = fast_path_cache;\r\n    if (recent_cache_entry.owner == Thread.currentThread()) {\r\n        return recent_cache_entry.capabilities;\r\n    } else\r\n        return getThreadLocalCapabilities();\r\n}"
}, {
	"Path": "org.lwjgl.opengl.GLContext.initNativeStubs",
	"Comment": "helper method to contextcapabilities. it will try to initialize the native stubs,\tand remove the given extension name from the extension set if the initialization fails.",
	"Method": "void initNativeStubs(Class<?> extension_class,Set supported_extensions,String ext_name){\r\n    resetNativeStubs(extension_class);\r\n    if (supported_extensions.contains(ext_name)) {\r\n        try {\r\n            AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {\r\n                public Object run() throws Exception {\r\n                    Method init_stubs_method = extension_class.getDeclaredMethod(\"initNativeStubs\");\r\n                    init_stubs_method.invoke(null);\r\n                    return null;\r\n                }\r\n            });\r\n        } catch (Exception e) {\r\n            LWJGLUtil.log(\"Failed to initialize extension \" + extension_class + \" - exception: \" + e);\r\n            supported_extensions.remove(ext_name);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.opengl.GLContext.initNativeStubs",
	"Comment": "helper method to contextcapabilities. it will try to initialize the native stubs,\tand remove the given extension name from the extension set if the initialization fails.",
	"Method": "void initNativeStubs(Class<?> extension_class,Set supported_extensions,String ext_name){\r\n    Method init_stubs_method = extension_class.getDeclaredMethod(\"initNativeStubs\");\r\n    init_stubs_method.invoke(null);\r\n    return null;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.render.Rendertarget.destroyRTT",
	"Comment": "destroy the opengl objects associated with this rendertarget. do not try\tto use this rendertarget with opengl after calling this method.",
	"Method": "void destroyRTT(){\r\n    EXTFramebufferObject.glDeleteFramebuffersEXT(fboID);\r\n    EXTFramebufferObject.glDeleteRenderbuffersEXT(depthBufferID);\r\n    GL11.glDeleteTextures(textureID);\r\n    GL15.glDeleteBuffers(vboID);\r\n}"
}, {
	"Path": "com.j256.ormlite.field.FieldType.buildForeignCollection",
	"Comment": "build and return a foreign collection based on the field settings that matches the id argument. this can return\tnull in certain circumstances.",
	"Method": "BaseForeignCollection<FT, FID> buildForeignCollection(Object parent,FID id){\r\n    if (foreignFieldType == null) {\r\n        return null;\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    Dao<FT, FID> castDao = (Dao<FT, FID>) foreignDao;\r\n    if (!fieldConfig.isForeignCollectionEager()) {\r\n        return new LazyForeignCollection<FT, FID>(castDao, parent, id, foreignFieldType, fieldConfig.getForeignCollectionOrderColumnName(), fieldConfig.isForeignCollectionOrderAscending());\r\n    }\r\n    LevelCounters levelCounters = threadLevelCounters.get();\r\n    if (levelCounters == null) {\r\n        if (fieldConfig.getForeignCollectionMaxEagerLevel() == 0) {\r\n            return new LazyForeignCollection<FT, FID>(castDao, parent, id, foreignFieldType, fieldConfig.getForeignCollectionOrderColumnName(), fieldConfig.isForeignCollectionOrderAscending());\r\n        }\r\n        levelCounters = new LevelCounters();\r\n        threadLevelCounters.set(levelCounters);\r\n    }\r\n    if (levelCounters.foreignCollectionLevel == 0) {\r\n        levelCounters.foreignCollectionLevelMax = fieldConfig.getForeignCollectionMaxEagerLevel();\r\n    }\r\n    if (levelCounters.foreignCollectionLevel >= levelCounters.foreignCollectionLevelMax) {\r\n        return new LazyForeignCollection<FT, FID>(castDao, parent, id, foreignFieldType, fieldConfig.getForeignCollectionOrderColumnName(), fieldConfig.isForeignCollectionOrderAscending());\r\n    }\r\n    levelCounters.foreignCollectionLevel++;\r\n    try {\r\n        return new EagerForeignCollection<FT, FID>(castDao, parent, id, foreignFieldType, fieldConfig.getForeignCollectionOrderColumnName(), fieldConfig.isForeignCollectionOrderAscending());\r\n    } finally {\r\n        levelCounters.foreignCollectionLevel--;\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.openal.EFXUtil.isEffectSupported",
	"Comment": "tests openal to see whether the given effect type is supported. this is done by creating aneffect of the given type. if creation succeeds the effect is supported.",
	"Method": "boolean isEffectSupported(int effectType){\r\n    switch(effectType) {\r\n        case AL_EFFECT_NULL:\r\n        case AL_EFFECT_EAXREVERB:\r\n        case AL_EFFECT_REVERB:\r\n        case AL_EFFECT_CHORUS:\r\n        case AL_EFFECT_DISTORTION:\r\n        case AL_EFFECT_ECHO:\r\n        case AL_EFFECT_FLANGER:\r\n        case AL_EFFECT_FREQUENCY_SHIFTER:\r\n        case AL_EFFECT_VOCAL_MORPHER:\r\n        case AL_EFFECT_PITCH_SHIFTER:\r\n        case AL_EFFECT_RING_MODULATOR:\r\n        case AL_EFFECT_AUTOWAH:\r\n        case AL_EFFECT_COMPRESSOR:\r\n        case AL_EFFECT_EQUALIZER:\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown or invalid effect type: \" + effectType);\r\n    }\r\n    return testSupportGeneric(EFFECT, effectType);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.GameData.drawHitResults",
	"Comment": "draws stored hit results and removes them from the list as necessary.",
	"Method": "void drawHitResults(int trackPosition,boolean over){\r\n    Iterator<HitObjectResult> iter = hitResultList.iterator();\r\n    while (iter.hasNext()) {\r\n        HitObjectResult hitResult = iter.next();\r\n        if (hitResult.time + HITRESULT_TIME > trackPosition) {\r\n            if (over) {\r\n                if (hitResult.hitResultType == HitObjectType.SPINNER && hitResult.result != HIT_MISS && Options.getSkin().getVersion() == 1) {\r\n                    Image spinnerOsu = GameImage.SPINNER_OSU.getImage();\r\n                    spinnerOsu.setAlpha(hitResult.alpha);\r\n                    spinnerOsu.drawCentered(width / 2, height / 4);\r\n                    spinnerOsu.setAlpha(1f);\r\n                } else if (Options.isHitLightingEnabled() && !hitResult.hideResult && hitResult.result != HIT_MISS && hitResult.result != HIT_SLIDER30 && hitResult.result != HIT_SLIDER10) {\r\n                    Image lighting = GameImage.LIGHTING.getImage();\r\n                    lighting.setAlpha(hitResult.alpha);\r\n                    lighting.drawCentered(hitResult.x, hitResult.y, hitResult.color);\r\n                }\r\n                if (!hitResult.hideResult && (hitResult.hitResultType == HitObjectType.CIRCLE || hitResult.hitResultType == HitObjectType.SLIDER_FIRST || hitResult.hitResultType == HitObjectType.SLIDER_LAST || hitResult.hitResultType == HitObjectType.SPINNER || (hitResult.hitResultType == HitObjectType.SLIDERTICK && Options.getSkin().getVersion() == 1))) {\r\n                    float scaleProgress = AnimationEquation.IN_OUT_BOUNCE.calc((float) Utils.clamp(trackPosition - hitResult.time, 0, HITCIRCLE_TEXT_BOUNCE_TIME) / HITCIRCLE_TEXT_BOUNCE_TIME);\r\n                    float scale = 1f + (HITCIRCLE_TEXT_ANIM_SCALE - 1f) * scaleProgress;\r\n                    float fadeProgress = AnimationEquation.OUT_CUBIC.calc((float) Utils.clamp((trackPosition - hitResult.time) - HITCIRCLE_FADE_TIME, 0, HITCIRCLE_TEXT_FADE_TIME) / HITCIRCLE_TEXT_FADE_TIME);\r\n                    float alpha = 1f - fadeProgress;\r\n                    Image scaledHitResult = hitResults[hitResult.result].getScaledCopy(scale);\r\n                    scaledHitResult.setAlpha(alpha);\r\n                    scaledHitResult.drawCentered(hitResult.x, hitResult.y);\r\n                }\r\n                hitResult.alpha = 1 - ((float) (trackPosition - hitResult.time) / HITRESULT_FADE_TIME);\r\n            } else {\r\n                if (!GameMod.HIDDEN.isActive())\r\n                    drawHitAnimations(hitResult, trackPosition);\r\n            }\r\n        } else {\r\n            if (hitResult.curve != null)\r\n                hitResult.curve.discardGeometry();\r\n            iter.remove();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGL.eglSurfaceAttrib",
	"Comment": "sets the specified egl surface attribute to the specified value.",
	"Method": "void eglSurfaceAttrib(EGLDisplay dpy,EGLSurface surface,int attribute,int value){\r\n    if (!neglSurfaceAttrib(dpy.getPointer(), surface.getPointer(), attribute, value))\r\n        throwEGLError(\"Failed to set surface attribute.\");\r\n}"
}, {
	"Path": "org.lwjgl.opengl.PixelFormat.withCoverageSamples",
	"Comment": "returns a new pixelformat object with the same properties as this pixelformat and the new color samples\tand coverage samples values.",
	"Method": "PixelFormat withCoverageSamples(int colorSamples,PixelFormat withCoverageSamples,int colorSamples,int coverageSamples){\r\n    if (coverageSamples < 0 || colorSamples < 0 || (coverageSamples == 0 && 0 < colorSamples) || coverageSamples < colorSamples)\r\n        throw new IllegalArgumentException(\"Invalid number of coverage samples specified: \" + coverageSamples + \" - \" + colorSamples);\r\n    final PixelFormat pf = new PixelFormat(this);\r\n    pf.samples = coverageSamples;\r\n    pf.colorSamples = colorSamples;\r\n    return pf;\r\n}"
}, {
	"Path": "com.j256.ormlite.table.DatabaseTableConfig.setTableName",
	"Comment": "set the table name. if not specified then the name is gotten from the class name.",
	"Method": "void setTableName(String tableName){\r\n    this.tableName = tableName;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.XRandR.parseScreenModeline",
	"Comment": "parses a screen configuration and adds it to one of the lists if valid.",
	"Method": "void parseScreenModeline(List<Screen> allModes,List<Screen> current,String name,int width,int height,String[] modeLine,int[] screenPosition){\r\n    for (int i = 1; i < modeLine.length; i++) {\r\n        String freqS = modeLine[i];\r\n        if (\"+\".equals(freqS)) {\r\n            continue;\r\n        }\r\n        Matcher m = FREQ_PATTERN.matcher(freqS);\r\n        if (!m.matches()) {\r\n            LWJGLUtil.log(\"Frequency match failed: \" + Arrays.toString(modeLine));\r\n            return;\r\n        }\r\n        String freq = m.group(1);\r\n        Screen s = new Screen(name, width, height, freq, 0, 0);\r\n        if (freqS.contains(\"*\")) {\r\n            current.add(new Screen(name, width, height, freq, screenPosition[0], screenPosition[1]));\r\n            allModes.add(0, s);\r\n        } else {\r\n            allModes.add(s);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.opencensus.exporter.trace.ocagent.OcAgentTraceServiceConfigRpcHandler.sendInitialMessage",
	"Comment": "subsequent updated library configs, unless the stream is interrupted.",
	"Method": "void sendInitialMessage(Node node){\r\n    io.opencensus.proto.trace.v1.TraceConfig currentTraceConfigProto = TraceProtoUtils.getCurrentTraceConfig(traceConfig);\r\n    CurrentLibraryConfig firstConfig = CurrentLibraryConfig.newBuilder().setNode(node).setConfig(currentTraceConfigProto).build();\r\n    sendCurrentConfig(firstConfig);\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGLDisplay.chooseConfig",
	"Comment": "returns the available egl configs on this display that satisfy the specified list of attributes.",
	"Method": "EGLConfig[] chooseConfig(IntBuffer attrib_list,EGLConfig[] configs,IntBuffer num_config){\r\n    checkInitialized();\r\n    return eglChooseConfig(this, attrib_list, configs, num_config);\r\n}"
}, {
	"Path": "io.opencensus.tags.Tags.loadTagsComponent",
	"Comment": "any provider that may be used for tagscomponent can be added here.",
	"Method": "TagsComponent loadTagsComponent(ClassLoader classLoader){\r\n    try {\r\n        return Provider.createInstance(Class.forName(\"io.opencensus.impl.tags.TagsComponentImpl\", true, classLoader), TagsComponent.class);\r\n    } catch (ClassNotFoundException e) {\r\n        logger.log(Level.FINE, \"Couldn't load full implementation for TagsComponent, now trying to load lite \" + \"implementation.\", e);\r\n    }\r\n    try {\r\n        return Provider.createInstance(Class.forName(\"io.opencensus.impllite.tags.TagsComponentImplLite\", true, classLoader), TagsComponent.class);\r\n    } catch (ClassNotFoundException e) {\r\n        logger.log(Level.FINE, \"Couldn't load lite implementation for TagsComponent, now using \" + \"default implementation for TagsComponent.\", e);\r\n    }\r\n    return NoopTags.newNoopTagsComponent();\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getDoubleClickEnabled",
	"Comment": "returns whether the widget implements double click mouse behavior.",
	"Method": "boolean getDoubleClickEnabled(){\r\n    checkWidget();\r\n    return doubleClickEnabled;\r\n}"
}, {
	"Path": "ddf.minim.ugens.Reciprocal.setReciprocal",
	"Comment": "used to change the fixeddenominator value after instantiation",
	"Method": "void setReciprocal(float fixedDenominator){\r\n    denominator.setLastValue(fixedDenominator);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.skins.SkinUnpacker.unpackAllFiles",
	"Comment": "invokes the unpacker for each osk archive in a root directory.",
	"Method": "File[] unpackAllFiles(File root,File dest){\r\n    List<File> dirs = new ArrayList<File>();\r\n    files = root.listFiles(new FilenameFilter() {\r\n        @Override\r\n        public boolean accept(File dir, String name) {\r\n            return name.toLowerCase().endsWith(\".osk\");\r\n        }\r\n    });\r\n    if (files == null || files.length < 1) {\r\n        files = null;\r\n        return new File[0];\r\n    }\r\n    for (File file : files) {\r\n        fileIndex++;\r\n        String dirName = file.getName().substring(0, file.getName().lastIndexOf('.'));\r\n        File skinDir = new File(dest, dirName);\r\n        if (!skinDir.isDirectory()) {\r\n            skinDir.mkdir();\r\n            Utils.unzip(file, skinDir);\r\n            file.delete();\r\n            dirs.add(skinDir);\r\n        }\r\n    }\r\n    fileIndex = -1;\r\n    files = null;\r\n    if (!dirs.isEmpty()) {\r\n        String text = String.format(\"Imported %d new skin%s.\", dirs.size(), dirs.size() == 1 ? \"\" : \"s\");\r\n        UI.getNotificationManager().sendNotification(text);\r\n    }\r\n    return dirs.toArray(new File[dirs.size()]);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.skins.SkinUnpacker.unpackAllFiles",
	"Comment": "invokes the unpacker for each osk archive in a root directory.",
	"Method": "File[] unpackAllFiles(File root,File dest){\r\n    return name.toLowerCase().endsWith(\".osk\");\r\n}"
}, {
	"Path": "com.j256.ormlite.field.FieldType.getGenericType",
	"Comment": "return the generic type of the field associated with this field type.",
	"Method": "Type getGenericType(){\r\n    return field.getGenericType();\r\n}"
}, {
	"Path": "io.opencensus.trace.Tracestate.get",
	"Comment": "returns the value to which the specified key is mapped, or null if this map contains no mappingfor the key.",
	"Method": "String get(String key){\r\n    for (Entry entry : getEntries()) {\r\n        if (entry.getKey().equals(key)) {\r\n            return entry.getValue();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "ddf.minim.ugens.Wavetable.smooth",
	"Comment": "smooth out the values in the table by using a moving average window.",
	"Method": "void smooth(int windowLength){\r\n    if (windowLength < 1)\r\n        return;\r\n    float[] temp = (float[]) waveform.clone();\r\n    for (int i = windowLength; i < waveform.length; i++) {\r\n        float avg = 0;\r\n        for (int j = i - windowLength; j <= i; j++) {\r\n            avg += temp[j] / windowLength;\r\n        }\r\n        waveform[i] = avg;\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.PageBox.retrievePageMetadata",
	"Comment": "but given the existing api, this is about the only place it can be done",
	"Method": "void retrievePageMetadata(LayoutContext c){\r\n    List props = getPageInfo().getXMPPropertyList();\r\n    if (props != null && props.size() > 0) {\r\n        for (Iterator i = props.iterator(); i.hasNext(); ) {\r\n            PropertyDeclaration decl = (PropertyDeclaration) i.next();\r\n            if (decl.getCSSName() == CSSName.CONTENT) {\r\n                PropertyValue value = (PropertyValue) decl.getValue();\r\n                List values = value.getValues();\r\n                if (values.size() == 1) {\r\n                    PropertyValue funcVal = (PropertyValue) values.get(0);\r\n                    if (funcVal.getPropertyValueType() == PropertyValue.VALUE_TYPE_FUNCTION) {\r\n                        FSFunction func = funcVal.getFunction();\r\n                        if (BoxBuilder.isElementFunction(func)) {\r\n                            BlockBox metadata = BoxBuilder.getRunningBlock(c, funcVal);\r\n                            if (metadata != null) {\r\n                                _metadata = metadata.getElement();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doCursorPrevious",
	"Comment": "moves the caret to the start of the selection if a selection exists.otherwise, if no selection exists move the cursor according to the cursor selection rules.",
	"Method": "void doCursorPrevious(){\r\n    if (selection.y - selection.x > 0) {\r\n        setCaretOffset(selection.x, OFFSET_LEADING);\r\n        showCaret();\r\n    } else {\r\n        doSelectionCursorPrevious();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getTextBounds",
	"Comment": "returns the smallest bounding rectangle that includes the characters between two offsets.",
	"Method": "Rectangle getTextBounds(int start,int end){\r\n    checkWidget();\r\n    int contentLength = getCharCount();\r\n    if (start < 0 || start >= contentLength || end < 0 || end >= contentLength || start > end) {\r\n        SWT.error(SWT.ERROR_INVALID_RANGE);\r\n    }\r\n    int lineStart = content.getLineAtOffset(start);\r\n    int lineEnd = content.getLineAtOffset(end);\r\n    Rectangle rect;\r\n    int y = getLinePixel(lineStart);\r\n    int height = 0;\r\n    int left = 0x7fffffff, right = 0;\r\n    for (int i = lineStart; i <= lineEnd; i++) {\r\n        int lineOffset = content.getOffsetAtLine(i);\r\n        TextLayout layout = renderer.getTextLayout(i);\r\n        int length = layout.getText().length();\r\n        if (length > 0) {\r\n            if (i == lineStart) {\r\n                if (i == lineEnd) {\r\n                    rect = layout.getBounds(start - lineOffset, end - lineOffset);\r\n                } else {\r\n                    rect = layout.getBounds(start - lineOffset, length);\r\n                }\r\n                y += rect.y;\r\n            } else if (i == lineEnd) {\r\n                rect = layout.getBounds(0, end - lineOffset);\r\n            } else {\r\n                rect = layout.getBounds();\r\n            }\r\n            left = Math.min(left, rect.x);\r\n            right = Math.max(right, rect.x + rect.width);\r\n            height += rect.height;\r\n        } else {\r\n            height += renderer.getLineHeight();\r\n        }\r\n        renderer.disposeTextLayout(layout);\r\n    }\r\n    rect = new Rectangle(left, y, right - left, height);\r\n    rect.x += leftMargin - horizontalScrollOffset;\r\n    return rect;\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.compareVersion",
	"Comment": "this method will return true if the version stored in the file\tmatches the supplied string version.",
	"Method": "boolean compareVersion(File versionFile,String version){\r\n    if (versionFile.exists()) {\r\n        String s = readStringFile(versionFile);\r\n        if (s != null && s.equals(version)) {\r\n            percentage = 90;\r\n            if (debugMode) {\r\n                System.out.println(\"Loading Cached Applet Version: \" + version);\r\n            }\r\n            debug_sleep(2000);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.openhtmltopdf.context.StandardAttributeResolver.isHover",
	"Comment": "gets the hover attribute of the standardattributeresolver object",
	"Method": "boolean isHover(Object e){\r\n    return ui.isHover((Element) e);\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix4f.transform",
	"Comment": "transform a vector by a matrix and return the result in a destination\tvector.",
	"Method": "Vector4f transform(Matrix4f left,Vector4f right,Vector4f dest){\r\n    if (dest == null)\r\n        dest = new Vector4f();\r\n    float x = left.m00 * right.x + left.m10 * right.y + left.m20 * right.z + left.m30 * right.w;\r\n    float y = left.m01 * right.x + left.m11 * right.y + left.m21 * right.z + left.m31 * right.w;\r\n    float z = left.m02 * right.x + left.m12 * right.y + left.m22 * right.z + left.m32 * right.w;\r\n    float w = left.m03 * right.x + left.m13 * right.y + left.m23 * right.z + left.m33 * right.w;\r\n    dest.x = x;\r\n    dest.y = y;\r\n    dest.z = z;\r\n    dest.w = w;\r\n    return dest;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.OptionsOverlay.setConsumeAndClose",
	"Comment": "whether to consume all unprocessed events, and close the overlay.",
	"Method": "void setConsumeAndClose(boolean flag){\r\n    this.consumeAndClose = flag;\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.setPanEnabled",
	"Comment": "enable or disable pan gesture detection. disabling pan causes the image to be centered.",
	"Method": "void setPanEnabled(boolean panEnabled){\r\n    this.panEnabled = panEnabled;\r\n    if (!panEnabled && vTranslate != null) {\r\n        vTranslate.x = (getWidth() / 2) - (scale * (sWidth() / 2));\r\n        vTranslate.y = (getHeight() / 2) - (scale * (sHeight() / 2));\r\n        if (isImageReady()) {\r\n            refreshRequiredTiles(true);\r\n            invalidate();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.blackbox_vision.materialcalendarview.view.CalendarView.showDatePickerDialog",
	"Comment": "todo review it, we need to provide a material design version of picker for month and year",
	"Method": "void showDatePickerDialog(){\r\n    calendar = Calendar.getInstance(Locale.getDefault());\r\n    final int year = calendar.get(Calendar.YEAR);\r\n    final int month = calendar.get(Calendar.MONTH);\r\n    final int day = calendar.get(Calendar.DAY_OF_MONTH);\r\n    pickerDialog = new DatePickerDialog(getContext(), R.style.CalendarViewTitle, this::onDateSet, year, month, day);\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\r\n        setSpinnerVisibility(\"day\", View.GONE);\r\n        setSpinnerVisibility(\"month\", View.VISIBLE);\r\n        setSpinnerVisibility(\"year\", View.VISIBLE);\r\n    } else {\r\n        final Field[] f = pickerDialog.getDatePicker().getClass().getDeclaredFields();\r\n        for (Field field : f) {\r\n            setSpinnerVisibility(field, \"mDayPicker|mDaySpinner\", View.GONE);\r\n            setSpinnerVisibility(field, \"mMonthPicker|mMonthSpinner\", View.VISIBLE);\r\n            setSpinnerVisibility(field, \"mYearPicker|mYearSpinner\", View.VISIBLE);\r\n        }\r\n    }\r\n    pickerDialog.show();\r\n}"
}, {
	"Path": "ddf.minim.ugens.Oscil.sampleRateChanged",
	"Comment": "this routine will be called any time the sample rate changes.",
	"Method": "void sampleRateChanged(){\r\n    oneOverSampleRate = 1 / sampleRate();\r\n    stepSize = frequency.getLastValue() * oneOverSampleRate;\r\n    prevFreq = frequency.getLastValue();\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.setWrapIndent",
	"Comment": "sets the wrap line indentation of the widget.it is the amount of blank space, in pixels, at the beginning of each wrapped line.when a line wraps in several lines all the lines but the first one is indentedby this amount.",
	"Method": "void setWrapIndent(int wrapIndent){\r\n    checkWidget();\r\n    if (this.wrapIndent == wrapIndent || wrapIndent < 0)\r\n        return;\r\n    this.wrapIndent = wrapIndent;\r\n    resetCache(0, content.getLineCount());\r\n    setCaretLocation();\r\n    super.redraw();\r\n}"
}, {
	"Path": "org.newdawn.slick.gui.TextField.setConsumeEvents",
	"Comment": "indicate if the input events should be consumed by this field",
	"Method": "void setConsumeEvents(boolean consume){\r\n    this.consume = consume;\r\n}"
}, {
	"Path": "com.openhtmltopdf.test.SwingImageReplacer.storeImageReplacedElement",
	"Comment": "adds a replacedelement containing an image to a cache of images for quick lookup.",
	"Method": "void storeImageReplacedElement(Element e,ReplacedElement cc){\r\n    System.out.println(\"\\n*** Cached image for element\");\r\n    imageComponents.put(e, cc);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.Beatmap.hasLoadedBackground",
	"Comment": "returns whether there is a loaded beatmap background image.",
	"Method": "boolean hasLoadedBackground(){\r\n    if (bg == null)\r\n        return false;\r\n    ImageLoader imageLoader = bgImageCache.get(bg);\r\n    return (imageLoader != null && imageLoader.getImage() != null);\r\n}"
}, {
	"Path": "org.lwjgl.util.input.ControllerAdapter.getXAxisValue",
	"Comment": "get the value from the x axis if there is one. if no x axis is defined a\tzero value will be returned.",
	"Method": "float getXAxisValue(){\r\n    return 0f;\r\n}"
}, {
	"Path": "org.newdawn.slick.Input.getKeyName",
	"Comment": "get the character representation of the key identified by the specified code",
	"Method": "String getKeyName(int code){\r\n    return Keyboard.getKeyName(code);\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.setTileBackgroundColor",
	"Comment": "set a solid color to render behind tiles, useful for displaying transparent pngs.",
	"Method": "void setTileBackgroundColor(int tileBgColor){\r\n    if (Color.alpha(tileBgColor) == 0) {\r\n        tileBgPaint = null;\r\n    } else {\r\n        tileBgPaint = new Paint();\r\n        tileBgPaint.setStyle(Style.FILL);\r\n        tileBgPaint.setColor(tileBgColor);\r\n    }\r\n    invalidate();\r\n}"
}, {
	"Path": "com.openhtmltopdf.test.SwingImageReplacer.lookupImageReplacedElement",
	"Comment": "retrieves a replacedelement for an image from cache, or null if not found.",
	"Method": "ReplacedElement lookupImageReplacedElement(Element e){\r\n    if (imageComponents.size() == 0) {\r\n        return null;\r\n    }\r\n    ReplacedElement replacedElement = (ReplacedElement) imageComponents.get(e);\r\n    return replacedElement;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.Display.destroy",
	"Comment": "destroy the display. after this call, there will be no current gl rendering context,\tregardless of whether the display was the current rendering context.",
	"Method": "void destroy(){\r\n    if (isCreated()) {\r\n        drawable.destroy();\r\n    }\r\n}"
}, {
	"Path": "io.opencensus.exporter.trace.ocagent.OcAgentNodeUtils.getProcessIdentifier",
	"Comment": "creates process identifier with the given jvm name and start time.",
	"Method": "ProcessIdentifier getProcessIdentifier(String jvmName,Timestamp censusTimestamp){\r\n    String hostname;\r\n    int pid;\r\n    int delimiterIndex = jvmName.indexOf('@');\r\n    if (delimiterIndex < 1) {\r\n        try {\r\n            hostname = InetAddress.getLocalHost().getHostName();\r\n        } catch (UnknownHostException e) {\r\n            hostname = \"localhost\";\r\n        }\r\n        pid = new SecureRandom().nextInt();\r\n    } else {\r\n        hostname = jvmName.substring(delimiterIndex + 1, jvmName.length());\r\n        try {\r\n            pid = Integer.parseInt(jvmName.substring(0, delimiterIndex));\r\n        } catch (NumberFormatException e) {\r\n            pid = new SecureRandom().nextInt();\r\n        }\r\n    }\r\n    return ProcessIdentifier.newBuilder().setHostName(hostname).setPid(pid).setStartTimestamp(TraceProtoUtils.toTimestampProto(censusTimestamp)).build();\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Vector3f.add",
	"Comment": "add a vector to another vector and place the result in a destination\tvector.",
	"Method": "Vector3f add(Vector3f left,Vector3f right,Vector3f dest){\r\n    if (dest == null)\r\n        return new Vector3f(left.x + right.x, left.y + right.y, left.z + right.z);\r\n    else {\r\n        dest.set(left.x + right.x, left.y + right.y, left.z + right.z);\r\n        return dest;\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.Beatmap.getTitle",
	"Comment": "returns the song title.\tif configured, the unicode string will be returned instead.",
	"Method": "String getTitle(){\r\n    return (Options.useUnicodeMetadata() && !titleUnicode.isEmpty()) ? titleUnicode : title;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ui.BackButton.hoverUpdate",
	"Comment": "processes a hover action depending on whether or not the cursor\tis hovering over the button.",
	"Method": "void hoverUpdate(int delta,int cx,int cy){\r\n    if (backButton != null) {\r\n        backButton.hoverUpdate(delta, cx, cy);\r\n        return;\r\n    }\r\n    boolean wasHovered = isHovered;\r\n    isHovered = buttonYpos - paddingY < cy && cx < realButtonWidth;\r\n    if (isHovered) {\r\n        if (!wasHovered)\r\n            animationTime = 0;\r\n        animationTime += delta;\r\n        if (animationTime > ANIMATION_TIME)\r\n            animationTime = ANIMATION_TIME;\r\n    } else {\r\n        if (wasHovered)\r\n            animationTime = ANIMATION_TIME;\r\n        animationTime -= delta;\r\n        if (animationTime < 0)\r\n            animationTime = 0;\r\n    }\r\n}"
}, {
	"Path": "org.newdawn.slick.openal.SoundStore.getSourceCount",
	"Comment": "retrieve the number of openal sound sources that have been\tdetermined at initialisation.",
	"Method": "int getSourceCount(){\r\n    return sourceCount;\r\n}"
}, {
	"Path": "org.lwjgl.opencl.CLPlatform.getPlatforms",
	"Comment": "returns a list of the available platforms, filtered by the specified filter.",
	"Method": "List<CLPlatform> getPlatforms(List<CLPlatform> getPlatforms,Filter<CLPlatform> filter,List<CLPlatform> getPlatforms,Filter<CLPlatform> filter){\r\n    return util.getPlatforms(filter);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.Updater.showButton",
	"Comment": "returns whether or not the updater button should be displayed.",
	"Method": "boolean showButton(){\r\n    return (status == Status.UPDATE_AVAILABLE || status == Status.UPDATE_DOWNLOADED || status == Status.UPDATE_DOWNLOADING);\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGL.eglTerminate",
	"Comment": "release the resources associated with the specified egl display.",
	"Method": "void eglTerminate(EGLDisplay dpy){\r\n    if (!neglTerminate(dpy.getPointer()))\r\n        throwEGLError(\"Failed to terminate EGL display.\");\r\n}"
}, {
	"Path": "com.j256.ormlite.stmt.mapped.MappedQueryForFieldEq.execute",
	"Comment": "query for an object in the database which matches the id argument.",
	"Method": "T execute(DatabaseConnection databaseConnection,ID id,ObjectCache objectCache){\r\n    if (objectCache != null) {\r\n        T result = objectCache.get(clazz, id);\r\n        if (result != null) {\r\n            return result;\r\n        }\r\n    }\r\n    Object[] args = new Object[] { convertIdToFieldObject(id) };\r\n    Object result = databaseConnection.queryForOne(statement, args, argFieldTypes, this, objectCache);\r\n    if (result == null) {\r\n        logger.debug(\"{} using '{}' and {} args, got no results\", label, statement, args.length);\r\n    } else if (result == DatabaseConnection.MORE_THAN_ONE) {\r\n        logger.error(\"{} using '{}' and {} args, got >1 results\", label, statement, args.length);\r\n        logArgs(args);\r\n        throw new SQLException(label + \" got more than 1 result: \" + statement);\r\n    } else {\r\n        logger.debug(\"{} using '{}' and {} args, got 1 result\", label, statement, args.length);\r\n    }\r\n    logArgs(args);\r\n    @SuppressWarnings(\"unchecked\")\r\n    T castResult = (T) result;\r\n    return castResult;\r\n}"
}, {
	"Path": "org.lwjgl.util.input.ControllerAdapter.getYAxisValue",
	"Comment": "get the value from the y axis if there is one. if no y axis is defined a\tzero value will be returned.",
	"Method": "float getYAxisValue(){\r\n    return 0f;\r\n}"
}, {
	"Path": "orestes.bloomfilter.redis.RedisBitSet.overwriteBitSet",
	"Comment": "overwrite the contents of this redisbitset by the given bitset.",
	"Method": "void overwriteBitSet(BitSet bits){\r\n    pool.safelyDo(jedis -> jedis.set(SafeEncoder.encode(name), toByteArrayReverse(bits)));\r\n}"
}, {
	"Path": "org.lwjgl.opengl.PixelFormat.withSamples",
	"Comment": "returns a new pixelformat object with the same properties as this pixelformat and the new samples value.",
	"Method": "PixelFormat withSamples(int samples){\r\n    if (samples < 0)\r\n        throw new IllegalArgumentException(\"Invalid number of samples specified: \" + samples);\r\n    final PixelFormat pf = new PixelFormat(this);\r\n    pf.samples = samples;\r\n    return pf;\r\n}"
}, {
	"Path": "com.openhtmltopdf.nonvisualregressiontests.NonVisualRegressionTest.testBookmarkHeadSimple",
	"Comment": "tests that a simple head bookmark linking to top of the second page works.",
	"Method": "void testBookmarkHeadSimple(){\r\n    PDDocument doc = run(\"bookmark-head-simple\");\r\n    PDDocumentOutline outline = doc.getDocumentCatalog().getDocumentOutline();\r\n    PDOutlineItem bm = outline.getFirstChild();\r\n    assertThat(bm.getTitle(), equalTo(\"Test bookmark\"));\r\n    assertThat(bm.getDestination(), instanceOf(PDPageXYZDestination.class));\r\n    PDPageXYZDestination dest = (PDPageXYZDestination) bm.getDestination();\r\n    assertEquals(dest.getPage(), doc.getPage(1));\r\n    assertEquals(doc.getPage(1).getMediaBox().getUpperRightY(), dest.getTop(), 1.0d);\r\n    remove(\"bookmark-head-simple\", doc);\r\n}"
}, {
	"Path": "com.j256.ormlite.support.BaseConnectionSource.isSingleConnection",
	"Comment": "return true if the two connections seem to one one connection under the covers.",
	"Method": "boolean isSingleConnection(DatabaseConnection conn1,DatabaseConnection conn2){\r\n    conn1.setAutoCommit(true);\r\n    conn2.setAutoCommit(true);\r\n    try {\r\n        conn1.setAutoCommit(false);\r\n        if (conn2.isAutoCommit()) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    } finally {\r\n        conn1.setAutoCommit(true);\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.opengles.PixelFormat.setAttrib",
	"Comment": "sets the value of an attribute to the current configuration.\tif the value matches the default attribute value, the\tattribute will be removed from the configuration.",
	"Method": "void setAttrib(Attrib attrib,int value){\r\n    if (attrib.defaultValue == value)\r\n        config.remove(attrib);\r\n    else\r\n        config.put(attrib, value);\r\n}"
}, {
	"Path": "org.lwjgl.LWJGLUtil.isMacOSXEqualsOrBetterThan",
	"Comment": "method to determine if the current system is running a version of\tmac os x better than the given version. this is only useful for mac os x\tspecific code and will not work for any other platform.",
	"Method": "boolean isMacOSXEqualsOrBetterThan(int major_required,int minor_required){\r\n    String os_version = getPrivilegedProperty(\"os.version\");\r\n    StringTokenizer version_tokenizer = new StringTokenizer(os_version, \".\");\r\n    int major;\r\n    int minor;\r\n    try {\r\n        String major_str = version_tokenizer.nextToken();\r\n        String minor_str = version_tokenizer.nextToken();\r\n        major = Integer.parseInt(major_str);\r\n        minor = Integer.parseInt(minor_str);\r\n    } catch (Exception e) {\r\n        LWJGLUtil.log(\"Exception occurred while trying to determine OS version: \" + e);\r\n        return false;\r\n    }\r\n    return major > major_required || (major == major_required && minor >= minor_required);\r\n}"
}, {
	"Path": "ddf.minim.ugens.Bypass.deactivate",
	"Comment": "deactivate the bypass functionality. in other words, the wrapped ugen will \thave an effect on the ugen patched to this bypass, as if it was in the \tsignal chain in place of this bypass.",
	"Method": "void deactivate(){\r\n    mActive = false;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.CallbackUtil.registerContextCallback",
	"Comment": "associates the current opengl context with the specified global reference. if there\tis no context current, the global reference is deleted and an exception is thrown.\tany previous callback registrations will be cleared.",
	"Method": "void registerContextCallback(long userParam,Map<ContextCapabilities, Long> contextUserData){\r\n    ContextCapabilities caps = GLContext.getCapabilities();\r\n    if (caps == null) {\r\n        deleteGlobalRef(userParam);\r\n        throw new IllegalStateException(\"No context is current.\");\r\n    }\r\n    final Long userParam_old = contextUserData.remove(caps);\r\n    if (userParam_old != null)\r\n        deleteGlobalRef(userParam_old);\r\n    if (userParam != 0)\r\n        contextUserData.put(caps, userParam);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.states.Game.getTimingPointMultiplier",
	"Comment": "returns the slider multiplier given by the current timing point.",
	"Method": "float getTimingPointMultiplier(){\r\n    return beatLength / beatLengthBase;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ui.Fonts.wrap",
	"Comment": "wraps the given string into a list of split lines based on the width.",
	"Method": "List<String> wrap(org.newdawn.slick.Font font,String text,int width,boolean newlines){\r\n    List<String> list = new ArrayList<String>();\r\n    String str = text;\r\n    String line = \"\";\r\n    int i = 0;\r\n    int lastSpace = -1;\r\n    while (i < str.length()) {\r\n        char c = str.charAt(i);\r\n        if (Character.isWhitespace(c))\r\n            lastSpace = i;\r\n        String append = line + c;\r\n        if (font.getWidth(append) > width || (newlines && c == '\\n')) {\r\n            int split = (lastSpace != -1) ? lastSpace : i;\r\n            int splitTrimmed = split;\r\n            if (lastSpace != -1 && split < str.length() - 1)\r\n                splitTrimmed++;\r\n            list.add(str.substring(0, split));\r\n            str = str.substring(splitTrimmed);\r\n            line = \"\";\r\n            i = 0;\r\n            lastSpace = -1;\r\n        } else {\r\n            line = append;\r\n            i++;\r\n        }\r\n    }\r\n    if (str.length() != 0)\r\n        list.add(str);\r\n    return list;\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Vector4f.sub",
	"Comment": "subtract a vector from another vector and place the result in a destination\tvector.",
	"Method": "Vector4f sub(Vector4f left,Vector4f right,Vector4f dest){\r\n    if (dest == null)\r\n        return new Vector4f(left.x - right.x, left.y - right.y, left.z - right.z, left.w - right.w);\r\n    else {\r\n        dest.set(left.x - right.x, left.y - right.y, left.z - right.z, left.w - right.w);\r\n        return dest;\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.opencl.CLMem.getGLObjectName",
	"Comment": "returns the gl object name. applicable to clmem objects\tthat have been created gl objects only.",
	"Method": "int getGLObjectName(int getGLObjectName,CLMem mem){\r\n    return util.getGLObjectName(this);\r\n}"
}, {
	"Path": "io.opencensus.implcore.stats.MeasureMapInternal.getAttachments",
	"Comment": "returns the contextual information associated with an example value.",
	"Method": "Map<String, String> getAttachments(){\r\n    return attachments;\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix4f.add",
	"Comment": "add two matrices together and place the result in a third matrix.",
	"Method": "Matrix4f add(Matrix4f left,Matrix4f right,Matrix4f dest){\r\n    if (dest == null)\r\n        dest = new Matrix4f();\r\n    dest.m00 = left.m00 + right.m00;\r\n    dest.m01 = left.m01 + right.m01;\r\n    dest.m02 = left.m02 + right.m02;\r\n    dest.m03 = left.m03 + right.m03;\r\n    dest.m10 = left.m10 + right.m10;\r\n    dest.m11 = left.m11 + right.m11;\r\n    dest.m12 = left.m12 + right.m12;\r\n    dest.m13 = left.m13 + right.m13;\r\n    dest.m20 = left.m20 + right.m20;\r\n    dest.m21 = left.m21 + right.m21;\r\n    dest.m22 = left.m22 + right.m22;\r\n    dest.m23 = left.m23 + right.m23;\r\n    dest.m30 = left.m30 + right.m30;\r\n    dest.m31 = left.m31 + right.m31;\r\n    dest.m32 = left.m32 + right.m32;\r\n    dest.m33 = left.m33 + right.m33;\r\n    return dest;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.CallbackUtil.registerContextCallbackARB",
	"Comment": "associates the current opengl context with the specified global reference. if there\tis no context current, the global reference is deleted and an exception is thrown.\tany previous callback registrations will be cleared.",
	"Method": "void registerContextCallbackARB(long userParam){\r\n    registerContextCallback(userParam, contextUserParamsARB);\r\n}"
}, {
	"Path": "io.opencensus.benchmarks.trace.RecordTraceEventsBenchmark.addLink",
	"Comment": "this benchmark attempts to measure performance of adding a link to the span.",
	"Method": "Span addLink(Data data){\r\n    data.span.addLink(Link.fromSpanContext(data.linkedSpan.getContext(), Link.Type.PARENT_LINKED_SPAN));\r\n    return data.span;\r\n}"
}, {
	"Path": "ddf.minim.effects.Convolver.setKernal",
	"Comment": "sets the kernal to k. the values in k arecopied so it is not possible to alter the kernal after it has been setexcept by setting it again.",
	"Method": "void setKernal(float[] k){\r\n    kernal = new float[k.length];\r\n    System.arraycopy(k, 0, kernal, 0, k.length);\r\n    outputL = new float[sigLen + kernal.length - 1];\r\n    outputR = new float[sigLen + kernal.length - 1];\r\n    overlapL = new float[outputL.length - sigLen];\r\n    overlapR = new float[outputR.length - sigLen];\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.DownscaleQuality.forString",
	"Comment": "retrieves the downscalequality instance for the corresponding string.",
	"Method": "DownscaleQuality forString(String type,DownscaleQuality dflt){\r\n    DownscaleQuality q = (DownscaleQuality) constList.get(type);\r\n    return q == null ? dflt : q;\r\n}"
}, {
	"Path": "ddf.minim.javasound.FloatSampleBuffer.setChannelCountImpl",
	"Comment": "internal setter for channel count, just change the variable. from\toutside, use addchannel, insertchannel, removechannel",
	"Method": "void setChannelCountImpl(int newChannelCount){\r\n    if (channelCount != newChannelCount) {\r\n        channelCount = newChannelCount;\r\n        this.lastConvertToByteArrayFormat = null;\r\n    }\r\n}"
}, {
	"Path": "com.android.volley.toolbox.ImageLoader.setBatchedResponseDelay",
	"Comment": "sets the amount of time to wait after the first response arrives before delivering allresponses. batching can be disabled entirely by passing in 0.",
	"Method": "void setBatchedResponseDelay(int newBatchedResponseDelayMs){\r\n    mBatchResponseDelayMs = newBatchedResponseDelayMs;\r\n}"
}, {
	"Path": "org.lwjgl.opencl.CL.getFunctionAddress",
	"Comment": "helper method to get a pointer to a named function in the opencl library.",
	"Method": "long getFunctionAddress(String[] aliases,long getFunctionAddress,String name){\r\n    ByteBuffer buffer = MemoryUtil.encodeASCII(name);\r\n    return ngetFunctionAddress(MemoryUtil.getAddress(buffer));\r\n}"
}, {
	"Path": "org.lwjgl.opengles.GLContext.loadOpenGLLibrary",
	"Comment": "if the opengl reference count is 0, the library is loaded. the reference count is then incremented.",
	"Method": "void loadOpenGLLibrary(){\r\n    if (gl_ref_count == 0)\r\n        nLoadOpenGLLibrary();\r\n    gl_ref_count++;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.GLContext.setCapabilities",
	"Comment": "set the current capabilities instance. it contains the flags used\tto test for support of a particular extension.",
	"Method": "void setCapabilities(ContextCapabilities capabilities){\r\n    current_capabilities.set(capabilities);\r\n    CapabilitiesCacheEntry thread_cache_entry = thread_cache_entries.get();\r\n    if (thread_cache_entry == null) {\r\n        thread_cache_entry = new CapabilitiesCacheEntry();\r\n        thread_cache_entries.set(thread_cache_entry);\r\n    }\r\n    thread_cache_entry.owner = Thread.currentThread();\r\n    thread_cache_entry.capabilities = capabilities;\r\n    fast_path_cache = thread_cache_entry;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.installDefaultContent",
	"Comment": "creates content change listeners and set the default content model.",
	"Method": "void installDefaultContent(){\r\n    textChangeListener = new TextChangeListener() {\r\n        public void textChanging(TextChangingEvent event) {\r\n            handleTextChanging(event);\r\n        }\r\n        public void textChanged(TextChangedEvent event) {\r\n            handleTextChanged(event);\r\n        }\r\n        public void textSet(TextChangedEvent event) {\r\n            handleTextSet(event);\r\n        }\r\n    };\r\n    content = new DefaultContent();\r\n    content.addTextChangeListener(textChangeListener);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.installDefaultContent",
	"Comment": "creates content change listeners and set the default content model.",
	"Method": "void installDefaultContent(){\r\n    handleTextChanging(event);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.installDefaultContent",
	"Comment": "creates content change listeners and set the default content model.",
	"Method": "void installDefaultContent(){\r\n    handleTextChanged(event);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.installDefaultContent",
	"Comment": "creates content change listeners and set the default content model.",
	"Method": "void installDefaultContent(){\r\n    handleTextSet(event);\r\n}"
}, {
	"Path": "com.openhtmltopdf.test.XLayout.getIntrinsicDimensions",
	"Comment": "gets the intrinsicdimensions attribute of the xlayout object",
	"Method": "Dimension getIntrinsicDimensions(LayoutContext c,Element elem){\r\n    return new Dimension(50, 50);\r\n}"
}, {
	"Path": "org.newdawn.slick.GameContainer.setAlwaysRender",
	"Comment": "indicate whether we want this container to render when it has focus",
	"Method": "void setAlwaysRender(boolean alwaysRender){\r\n    this.alwaysRender = alwaysRender;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.addSelectionListener",
	"Comment": "adds a selection listener. a selection event is sent by the widget when the user changes the selection.when widgetselected is called, the event x and y fields containthe start and end caret indices of the selection.widgetdefaultselected is not called for styledtexts.",
	"Method": "void addSelectionListener(SelectionListener listener){\r\n    checkWidget();\r\n    if (listener == null)\r\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\r\n    addListener(SWT.Selection, new TypedListener(listener));\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.setRestDisplacementThreshold",
	"Comment": "set the threshold of displacement from rest below which the spring should be considered at rest",
	"Method": "Spring setRestDisplacementThreshold(double displacementFromRestThreshold){\r\n    mDisplacementFromRestThreshold = displacementFromRestThreshold;\r\n    return this;\r\n}"
}, {
	"Path": "orestes.bloomfilter.test.comparisons.BloomFilterMagnus.expectedFalsePositiveProbability",
	"Comment": "calculates the expected probability of false positives based onthe number of expected filter elements and the size of the bloom filter.the value returned by this method is the expected rate of falsepositives, assuming the number of inserted elements equals the number ofexpected elements. if the number of elements in the bloom filter is lessthan the expected value, the true probability of false positives will be lower.",
	"Method": "double expectedFalsePositiveProbability(){\r\n    return getFalsePositiveProbability(expectedNumberOfFilterElements);\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.onImageInited",
	"Comment": "called by worker task when decoder is ready and image size and exif orientation is known.",
	"Method": "void onImageInited(BitmapRegionDecoder decoder,int sWidth,int sHeight,int sOrientation){\r\n    this.decoder = decoder;\r\n    this.sWidth = sWidth;\r\n    this.sHeight = sHeight;\r\n    this.sOrientation = sOrientation;\r\n    requestLayout();\r\n    invalidate();\r\n}"
}, {
	"Path": "org.newdawn.slick.Music.update",
	"Comment": "update the current music applying any effects that need to updated per \ttick.",
	"Method": "void update(int delta){\r\n    if (!playing) {\r\n        return;\r\n    }\r\n    if (pitchTime > 0) {\r\n        pitchTime -= delta;\r\n        if (pitchTime < 0) {\r\n            pitchTime = 0;\r\n        }\r\n        float offset = (pitchEnd - pitchStart) * (1 - (pitchTime / (float) pitchDuration));\r\n        setPitch(pitchStart + offset);\r\n    }\r\n    if (fadeTime > 0) {\r\n        fadeTime -= delta;\r\n        if (fadeTime <= 0) {\r\n            fadeTime = 0;\r\n            if (stopAfterFade) {\r\n                stop();\r\n                return;\r\n            }\r\n        }\r\n        float offset = (fadeEndGain - fadeStartGain) * (1 - (fadeTime / (float) fadeDuration));\r\n        setVolume(fadeStartGain + offset);\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.sheet.PropertyDeclaration.getCSSName",
	"Comment": "gets the cssname attribute of the propertydeclaration object",
	"Method": "CSSName getCSSName(){\r\n    return cssName;\r\n}"
}, {
	"Path": "org.newdawn.slick.GameContainer.enableSharedContext",
	"Comment": "enable shared opengl context. after calling this all containers created \twill shared a single parent context",
	"Method": "void enableSharedContext(){\r\n    try {\r\n        SHARED_DRAWABLE = new Pbuffer(64, 64, new PixelFormat(8, 0, 0), null);\r\n    } catch (LWJGLException e) {\r\n        throw new SlickException(\"Unable to create the pbuffer used for shard context, buffers not supported\", e);\r\n    }\r\n}"
}, {
	"Path": "ddf.minim.Minim.loadFile",
	"Comment": "loads the requested file into an audioplayer.\tthe default buffer size is 1024 samples and the \tbuffer size determines the size of the left, right, \tand mix audiobuffer fields on the returned audioplayer.",
	"Method": "AudioPlayer loadFile(String filename,AudioPlayer loadFile,String filename,int bufferSize){\r\n    AudioPlayer player = null;\r\n    AudioRecordingStream rec = mimp.getAudioRecordingStream(filename, bufferSize, false);\r\n    if (rec != null) {\r\n        AudioFormat format = rec.getFormat();\r\n        AudioOut out = mimp.getAudioOutput(format.getChannels(), bufferSize, format.getSampleRate(), format.getSampleSizeInBits());\r\n        if (out != null) {\r\n            player = new AudioPlayer(rec, out);\r\n        } else {\r\n            rec.close();\r\n        }\r\n    }\r\n    if (player != null) {\r\n        addSource(player);\r\n    } else {\r\n        error(\"Couldn't load the file \" + filename);\r\n    }\r\n    return player;\r\n}"
}, {
	"Path": "ddf.minim.ugens.GranulateSteady.sampleRateChanged",
	"Comment": "use this method to notify granulatesteady that the sample rate has changed.",
	"Method": "void sampleRateChanged(){\r\n    timeStep = 1.0f / sampleRate();\r\n}"
}, {
	"Path": "io.opencensus.contrib.agent.instrumentation.ThreadInstrumentationBenchmark.none",
	"Comment": "this benchmark attempts to measure the performance without any context propagation.",
	"Method": "void none(Blackhole blackhole){\r\n    Thread t = new Thread(new MyRunnable(blackhole));\r\n    t.start();\r\n    t.join();\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.appletResize",
	"Comment": "transfers the call of appletresize from the stub to the lwjglapplet.",
	"Method": "void appletResize(int width,int height){\r\n    resize(width, height);\r\n}"
}, {
	"Path": "com.j256.ormlite.field.FieldType.extractJavaFieldValue",
	"Comment": "return the value from the field in the object that is defined by this fieldtype. if the field is a foreign object\tthen the id of the field is returned instead.",
	"Method": "Object extractJavaFieldValue(Object object){\r\n    Object val = extractRawJavaFieldValue(object);\r\n    if (foreignRefField != null && val != null) {\r\n        val = foreignRefField.extractRawJavaFieldValue(val);\r\n    }\r\n    return val;\r\n}"
}, {
	"Path": "ddf.minim.AudioOutput.getNoteOffset",
	"Comment": "return the current value of the note offset for this output.",
	"Method": "float getNoteOffset(){\r\n    return noteManager.getNoteOffset();\r\n}"
}, {
	"Path": "ddf.minim.javasound.FloatSampleBuffer.addChannel",
	"Comment": "add a channel to this buffer, e.g. adding a channel to a mono buffer will make it a stereo buffer.",
	"Method": "void addChannel(boolean silent){\r\n    insertChannel(getChannelCount(), silent);\r\n}"
}, {
	"Path": "io.opencensus.exporter.stats.prometheus.PrometheusExportUtils.getSamples",
	"Comment": "converts a point value in metric to a list of prometheus samples.",
	"Method": "List<Sample> getSamples(String name,List<String> labelNames,List<LabelValue> labelValuesList,Value value){\r\n    Preconditions.checkArgument(labelNames.size() == labelValuesList.size(), \"Keys and Values don't have same size.\");\r\n    final List<Sample> samples = Lists.newArrayList();\r\n    final List<String> labelValues = new ArrayList<String>(labelValuesList.size());\r\n    for (LabelValue labelValue : labelValuesList) {\r\n        String val = labelValue == null ? \"\" : labelValue.getValue();\r\n        labelValues.add(val == null ? \"\" : val);\r\n    }\r\n    return value.match(new Function<Double, List<Sample>>() {\r\n        @Override\r\n        public List<Sample> apply(Double arg) {\r\n            samples.add(new Sample(name, labelNames, labelValues, arg));\r\n            return samples;\r\n        }\r\n    }, new Function<Long, List<Sample>>() {\r\n        @Override\r\n        public List<Sample> apply(Long arg) {\r\n            samples.add(new Sample(name, labelNames, labelValues, arg));\r\n            return samples;\r\n        }\r\n    }, new Function<Distribution, List<Sample>>() {\r\n        @Override\r\n        public List<Sample> apply(final Distribution arg) {\r\n            BucketOptions bucketOptions = arg.getBucketOptions();\r\n            List<Double> boundaries = new ArrayList();\r\n            if (bucketOptions != null) {\r\n                boundaries = bucketOptions.match(new Function<ExplicitOptions, List<Double>>() {\r\n                    @Override\r\n                    public List<Double> apply(ExplicitOptions arg) {\r\n                        return arg.getBucketBoundaries();\r\n                    }\r\n                }, Functions.<List<Double>>throwIllegalArgumentException());\r\n            }\r\n            List<String> labelNamesWithLe = new ArrayList<String>(labelNames);\r\n            labelNamesWithLe.add(LABEL_NAME_BUCKET_BOUND);\r\n            long cumulativeCount = 0;\r\n            for (int i = 0; i < arg.getBuckets().size(); i++) {\r\n                List<String> labelValuesWithLe = new ArrayList<String>(labelValues);\r\n                String bucketBoundary = doubleToGoString(i < boundaries.size() ? boundaries.get(i) : Double.POSITIVE_INFINITY);\r\n                labelValuesWithLe.add(bucketBoundary);\r\n                cumulativeCount += arg.getBuckets().get(i).getCount();\r\n                samples.add(new MetricFamilySamples.Sample(name + SAMPLE_SUFFIX_BUCKET, labelNamesWithLe, labelValuesWithLe, cumulativeCount));\r\n            }\r\n            samples.add(new MetricFamilySamples.Sample(name + SAMPLE_SUFFIX_COUNT, labelNames, labelValues, arg.getCount()));\r\n            samples.add(new MetricFamilySamples.Sample(name + SAMPLE_SUFFIX_SUM, labelNames, labelValues, arg.getSum()));\r\n            return samples;\r\n        }\r\n    }, new Function<Summary, List<Sample>>() {\r\n        @Override\r\n        public List<Sample> apply(Summary arg) {\r\n            Long count = arg.getCount();\r\n            if (count != null) {\r\n                samples.add(new MetricFamilySamples.Sample(name + SAMPLE_SUFFIX_COUNT, labelNames, labelValues, count));\r\n            }\r\n            Double sum = arg.getSum();\r\n            if (sum != null) {\r\n                samples.add(new MetricFamilySamples.Sample(name + SAMPLE_SUFFIX_SUM, labelNames, labelValues, sum));\r\n            }\r\n            List<ValueAtPercentile> valueAtPercentiles = arg.getSnapshot().getValueAtPercentiles();\r\n            List<String> labelNamesWithQuantile = new ArrayList<String>(labelNames);\r\n            labelNamesWithQuantile.add(LABEL_NAME_QUANTILE);\r\n            for (ValueAtPercentile valueAtPercentile : valueAtPercentiles) {\r\n                List<String> labelValuesWithQuantile = new ArrayList<String>(labelValues);\r\n                labelValuesWithQuantile.add(doubleToGoString(valueAtPercentile.getPercentile() / 100));\r\n                samples.add(new MetricFamilySamples.Sample(name, labelNamesWithQuantile, labelValuesWithQuantile, valueAtPercentile.getValue()));\r\n            }\r\n            return samples;\r\n        }\r\n    }, Functions.<List<Sample>>throwIllegalArgumentException());\r\n}"
}, {
	"Path": "io.opencensus.exporter.stats.prometheus.PrometheusExportUtils.getSamples",
	"Comment": "converts a point value in metric to a list of prometheus samples.",
	"Method": "List<Sample> getSamples(String name,List<String> labelNames,List<LabelValue> labelValuesList,Value value){\r\n    samples.add(new Sample(name, labelNames, labelValues, arg));\r\n    return samples;\r\n}"
}, {
	"Path": "io.opencensus.exporter.stats.prometheus.PrometheusExportUtils.getSamples",
	"Comment": "converts a point value in metric to a list of prometheus samples.",
	"Method": "List<Sample> getSamples(String name,List<String> labelNames,List<LabelValue> labelValuesList,Value value){\r\n    samples.add(new Sample(name, labelNames, labelValues, arg));\r\n    return samples;\r\n}"
}, {
	"Path": "io.opencensus.exporter.stats.prometheus.PrometheusExportUtils.getSamples",
	"Comment": "converts a point value in metric to a list of prometheus samples.",
	"Method": "List<Sample> getSamples(String name,List<String> labelNames,List<LabelValue> labelValuesList,Value value){\r\n    BucketOptions bucketOptions = arg.getBucketOptions();\r\n    List<Double> boundaries = new ArrayList();\r\n    if (bucketOptions != null) {\r\n        boundaries = bucketOptions.match(new Function<ExplicitOptions, List<Double>>() {\r\n            @Override\r\n            public List<Double> apply(ExplicitOptions arg) {\r\n                return arg.getBucketBoundaries();\r\n            }\r\n        }, Functions.<List<Double>>throwIllegalArgumentException());\r\n    }\r\n    List<String> labelNamesWithLe = new ArrayList<String>(labelNames);\r\n    labelNamesWithLe.add(LABEL_NAME_BUCKET_BOUND);\r\n    long cumulativeCount = 0;\r\n    for (int i = 0; i < arg.getBuckets().size(); i++) {\r\n        List<String> labelValuesWithLe = new ArrayList<String>(labelValues);\r\n        String bucketBoundary = doubleToGoString(i < boundaries.size() ? boundaries.get(i) : Double.POSITIVE_INFINITY);\r\n        labelValuesWithLe.add(bucketBoundary);\r\n        cumulativeCount += arg.getBuckets().get(i).getCount();\r\n        samples.add(new MetricFamilySamples.Sample(name + SAMPLE_SUFFIX_BUCKET, labelNamesWithLe, labelValuesWithLe, cumulativeCount));\r\n    }\r\n    samples.add(new MetricFamilySamples.Sample(name + SAMPLE_SUFFIX_COUNT, labelNames, labelValues, arg.getCount()));\r\n    samples.add(new MetricFamilySamples.Sample(name + SAMPLE_SUFFIX_SUM, labelNames, labelValues, arg.getSum()));\r\n    return samples;\r\n}"
}, {
	"Path": "io.opencensus.exporter.stats.prometheus.PrometheusExportUtils.getSamples",
	"Comment": "converts a point value in metric to a list of prometheus samples.",
	"Method": "List<Sample> getSamples(String name,List<String> labelNames,List<LabelValue> labelValuesList,Value value){\r\n    return arg.getBucketBoundaries();\r\n}"
}, {
	"Path": "io.opencensus.exporter.stats.prometheus.PrometheusExportUtils.getSamples",
	"Comment": "converts a point value in metric to a list of prometheus samples.",
	"Method": "List<Sample> getSamples(String name,List<String> labelNames,List<LabelValue> labelValuesList,Value value){\r\n    Long count = arg.getCount();\r\n    if (count != null) {\r\n        samples.add(new MetricFamilySamples.Sample(name + SAMPLE_SUFFIX_COUNT, labelNames, labelValues, count));\r\n    }\r\n    Double sum = arg.getSum();\r\n    if (sum != null) {\r\n        samples.add(new MetricFamilySamples.Sample(name + SAMPLE_SUFFIX_SUM, labelNames, labelValues, sum));\r\n    }\r\n    List<ValueAtPercentile> valueAtPercentiles = arg.getSnapshot().getValueAtPercentiles();\r\n    List<String> labelNamesWithQuantile = new ArrayList<String>(labelNames);\r\n    labelNamesWithQuantile.add(LABEL_NAME_QUANTILE);\r\n    for (ValueAtPercentile valueAtPercentile : valueAtPercentiles) {\r\n        List<String> labelValuesWithQuantile = new ArrayList<String>(labelValues);\r\n        labelValuesWithQuantile.add(doubleToGoString(valueAtPercentile.getPercentile() / 100));\r\n        samples.add(new MetricFamilySamples.Sample(name, labelNamesWithQuantile, labelValuesWithQuantile, valueAtPercentile.getValue()));\r\n    }\r\n    return samples;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.DownloadNode.getArtist",
	"Comment": "returns the song artist.\tif configured, the unicode string will be returned instead.",
	"Method": "String getArtist(){\r\n    return (Options.useUnicodeMetadata() && artistUnicode != null && !artistUnicode.isEmpty()) ? artistUnicode : artist;\r\n}"
}, {
	"Path": "com.j256.ormlite.field.FieldType.assignField",
	"Comment": "assign to the data object the val corresponding to the fieldtype.",
	"Method": "void assignField(Object data,Object val,boolean parentObject,ObjectCache objectCache){\r\n    if (logger.isLevelEnabled(Level.TRACE)) {\r\n        logger.trace(\"assiging from data {}, val {}: {}\", (data == null ? \"null\" : data.getClass()), (val == null ? \"null\" : val.getClass()), val);\r\n    }\r\n    if (foreignRefField != null && val != null) {\r\n        Object foreignRef = extractJavaFieldValue(data);\r\n        if (foreignRef != null && foreignRef.equals(val)) {\r\n            return;\r\n        }\r\n        Object cachedVal;\r\n        ObjectCache foreignCache = foreignDao.getObjectCache();\r\n        if (foreignCache == null) {\r\n            cachedVal = null;\r\n        } else {\r\n            cachedVal = foreignCache.get(getType(), val);\r\n        }\r\n        if (cachedVal != null) {\r\n            val = cachedVal;\r\n        } else if (!parentObject) {\r\n            val = createForeignObject(val, objectCache);\r\n        }\r\n    }\r\n    if (fieldSetMethod == null) {\r\n        try {\r\n            field.set(data, val);\r\n        } catch (IllegalArgumentException e) {\r\n            if (val == null) {\r\n                throw SqlExceptionUtil.create(\"Could not assign object '\" + val + \"' to field \" + this, e);\r\n            } else {\r\n                throw SqlExceptionUtil.create(\"Could not assign object '\" + val + \"' of type \" + val.getClass() + \" to field \" + this, e);\r\n            }\r\n        } catch (IllegalAccessException e) {\r\n            throw SqlExceptionUtil.create(\"Could not assign object '\" + val + \"' of type \" + val.getClass() + \"' to field \" + this, e);\r\n        }\r\n    } else {\r\n        try {\r\n            fieldSetMethod.invoke(data, val);\r\n        } catch (Exception e) {\r\n            throw SqlExceptionUtil.create(\"Could not call \" + fieldSetMethod + \" on object with '\" + val + \"' for \" + this, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.volley.toolbox.PoolingByteArrayOutputStream.expand",
	"Comment": "ensures there is enough space in the buffer for the given number of additional bytes.",
	"Method": "void expand(int i){\r\n    if (count + i <= buf.length) {\r\n        return;\r\n    }\r\n    byte[] newbuf = mPool.getBuf((count + i) * 2);\r\n    System.arraycopy(buf, 0, newbuf, 0, count);\r\n    mPool.returnBuf(buf);\r\n    buf = newbuf;\r\n}"
}, {
	"Path": "org.lwjgl.util.input.ControllerAdapter.getButtonCount",
	"Comment": "retrieve the number of buttons available on this controller",
	"Method": "int getButtonCount(){\r\n    return 0;\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.Configuration.keysByPrefix",
	"Comment": "returns all configuration keys that start with prefix. iterator will beempty if no such keys are found.",
	"Method": "Iterator keysByPrefix(String prefix){\r\n    Configuration conf = instance();\r\n    Iterator iter = conf.properties.keySet().iterator();\r\n    List l = new ArrayList();\r\n    while (iter.hasNext()) {\r\n        String key = (String) iter.next();\r\n        if (key.startsWith(prefix)) {\r\n            l.add(key);\r\n        }\r\n    }\r\n    return l.iterator();\r\n}"
}, {
	"Path": "org.lwjgl.opengl.PixelFormat.withAccumulationAlpha",
	"Comment": "returns a new pixelformat object with the same properties as this pixelformat and the new alpha bits in the accumulation buffer value.",
	"Method": "PixelFormat withAccumulationAlpha(int accum_alpha){\r\n    if (accum_alpha < 0)\r\n        throw new IllegalArgumentException(\"Invalid number of alpha bits in the accumulation buffer specified: \" + accum_alpha);\r\n    final PixelFormat pf = new PixelFormat(this);\r\n    pf.accum_alpha = accum_alpha;\r\n    return pf;\r\n}"
}, {
	"Path": "com.j256.ormlite.stmt.Where.between",
	"Comment": "add a between clause so the column must be between the low and high parameters.",
	"Method": "Where<T, ID> between(String columnName,Object low,Object high){\r\n    addClause(new Between(columnName, findColumnFieldType(columnName), low, high));\r\n    return this;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.render.LegacyCurveRenderState.init",
	"Comment": "set the width and height of the container that curves get drawn into.\tshould be called before any curves are drawn.",
	"Method": "void init(int width,int height,float circleDiameter){\r\n    containerWidth = width;\r\n    containerHeight = height;\r\n    scale = (int) (circleDiameter * HitObject.getXMultiplier());\r\n    FrameBufferCache.init(width, height);\r\n    NewCurveStyleState.initUnitCone();\r\n}"
}, {
	"Path": "org.newdawn.slick.openal.SoundStore.init",
	"Comment": "initialise the sound effects stored. this must be called\tbefore anything else will work",
	"Method": "void init(){\r\n    if (inited) {\r\n        return;\r\n    }\r\n    Log.info(\"Initialising sounds..\");\r\n    inited = true;\r\n    AccessController.doPrivileged(new PrivilegedAction() {\r\n        @Override\r\n        public Object run() {\r\n            try {\r\n                AL.create();\r\n                soundWorks = true;\r\n                sounds = true;\r\n                music = true;\r\n                Log.info(\"- Sound works\");\r\n            } catch (Exception e) {\r\n                Log.error(\"Sound initialisation failure.\");\r\n                Log.error(e);\r\n                soundWorks = false;\r\n                sounds = false;\r\n                music = false;\r\n            }\r\n            return null;\r\n        }\r\n    });\r\n    if (soundWorks) {\r\n        sourceCount = 0;\r\n        sources = BufferUtils.createIntBuffer(maxSources);\r\n        while (AL10.alGetError() == AL10.AL_NO_ERROR) {\r\n            IntBuffer temp = BufferUtils.createIntBuffer(1);\r\n            try {\r\n                AL10.alGenSources(temp);\r\n                if (AL10.alGetError() == AL10.AL_NO_ERROR) {\r\n                    sourceCount++;\r\n                    sources.put(temp.get(0));\r\n                    if (sourceCount > maxSources - 1) {\r\n                        break;\r\n                    }\r\n                }\r\n            } catch (OpenALException e) {\r\n                break;\r\n            }\r\n        }\r\n        Log.info(\"- \" + sourceCount + \" OpenAL source available\");\r\n        if (AL10.alGetError() != AL10.AL_NO_ERROR) {\r\n            sounds = false;\r\n            music = false;\r\n            soundWorks = false;\r\n            Log.error(\"- AL init failed\");\r\n        } else {\r\n            FloatBuffer listenerOri = BufferUtils.createFloatBuffer(6).put(new float[] { 0.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f });\r\n            FloatBuffer listenerVel = BufferUtils.createFloatBuffer(3).put(new float[] { 0.0f, 0.0f, 0.0f });\r\n            FloatBuffer listenerPos = BufferUtils.createFloatBuffer(3).put(new float[] { 0.0f, 0.0f, 0.0f });\r\n            listenerPos.flip();\r\n            listenerVel.flip();\r\n            listenerOri.flip();\r\n            AL10.alListener(AL10.AL_POSITION, listenerPos);\r\n            AL10.alListener(AL10.AL_VELOCITY, listenerVel);\r\n            AL10.alListener(AL10.AL_ORIENTATION, listenerOri);\r\n            Log.info(\"- Sounds source generated\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.newdawn.slick.openal.SoundStore.init",
	"Comment": "initialise the sound effects stored. this must be called\tbefore anything else will work",
	"Method": "void init(){\r\n    try {\r\n        AL.create();\r\n        soundWorks = true;\r\n        sounds = true;\r\n        music = true;\r\n        Log.info(\"- Sound works\");\r\n    } catch (Exception e) {\r\n        Log.error(\"Sound initialisation failure.\");\r\n        Log.error(e);\r\n        soundWorks = false;\r\n        sounds = false;\r\n        music = false;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "ddf.minim.analysis.FFT.fft",
	"Comment": "bit reversing is not necessary as the data will already be bit reversed",
	"Method": "void fft(){\r\n    for (int halfSize = 1; halfSize < real.length; halfSize *= 2) {\r\n        float phaseShiftStepR = cos(halfSize);\r\n        float phaseShiftStepI = sin(halfSize);\r\n        float currentPhaseShiftR = 1.0f;\r\n        float currentPhaseShiftI = 0.0f;\r\n        for (int fftStep = 0; fftStep < halfSize; fftStep++) {\r\n            for (int i = fftStep; i < real.length; i += 2 * halfSize) {\r\n                int off = i + halfSize;\r\n                float tr = (currentPhaseShiftR * real[off]) - (currentPhaseShiftI * imag[off]);\r\n                float ti = (currentPhaseShiftR * imag[off]) + (currentPhaseShiftI * real[off]);\r\n                real[off] = real[i] - tr;\r\n                imag[off] = imag[i] - ti;\r\n                real[i] += tr;\r\n                imag[i] += ti;\r\n            }\r\n            float tmpR = currentPhaseShiftR;\r\n            currentPhaseShiftR = (tmpR * phaseShiftStepR) - (currentPhaseShiftI * phaseShiftStepI);\r\n            currentPhaseShiftI = (tmpR * phaseShiftStepI) + (currentPhaseShiftI * phaseShiftStepR);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.Box.setHeight",
	"Comment": "uh oh! this refers to content height during layout but total height after layout!",
	"Method": "void setHeight(int height){\r\n    _height = height;\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.getPaddingRight",
	"Comment": "returns the padding to the right of a glyph on the glyphpage to allow for effects to be drawn.",
	"Method": "int getPaddingRight(){\r\n    return paddingRight;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.PixelFormat.withDepthBits",
	"Comment": "returns a new pixelformat object with the same properties as this pixelformat and the new depth bits value.",
	"Method": "PixelFormat withDepthBits(int depth){\r\n    if (depth < 0)\r\n        throw new IllegalArgumentException(\"Invalid number of depth bits specified: \" + depth);\r\n    final PixelFormat pf = new PixelFormat(this);\r\n    pf.depth = depth;\r\n    return pf;\r\n}"
}, {
	"Path": "com.openhtmltopdf.context.StandardAttributeResolver.getAttributeValue",
	"Comment": "gets the attributevalue attribute of the standardattributeresolver object",
	"Method": "String getAttributeValue(Object e,String attrName,String getAttributeValue,Object e,String namespaceURI,String attrName){\r\n    return nsh.getAttributeValue((Element) e, namespaceURI, attrName);\r\n}"
}, {
	"Path": "com.openhtmltopdf.outputdevice.helper.BaseRendererBuilder.withW3cDocument",
	"Comment": "provides a w3c dom document acquired from an external source.",
	"Method": "TFinalClass withW3cDocument(org.w3c.dom.Document doc,String baseUri){\r\n    state._document = doc;\r\n    state._baseUri = baseUri;\r\n    return (TFinalClass) this;\r\n}"
}, {
	"Path": "ddf.minim.ugens.Waves.saw",
	"Comment": "constructs a perfect sawtooth wave with the specified duty cycle.",
	"Method": "Wavetable saw(float dutyCycle){\r\n    dutyCycle = Math.max(0, Math.min(dutyCycle, 1));\r\n    int a = (int) (tableSize * dutyCycle);\r\n    return WavetableGenerator.gen7(tableSize, new float[] { 0, -1, 1, 0 }, new int[] { a, 0, tableSize - a });\r\n}"
}, {
	"Path": "itdelatrisu.opsu.states.MainMenu.previousTrack",
	"Comment": "plays the previous track, or does nothing if the stack is empty.",
	"Method": "void previousTrack(){\r\n    if (!previous.isEmpty()) {\r\n        SongMenu menu = (SongMenu) game.getState(Opsu.STATE_SONGMENU);\r\n        menu.setFocus(BeatmapSetList.get().getBaseNode(previous.pop()), -1, true, false);\r\n        lastMeasureProgress = 0f;\r\n        if (Options.isDynamicBackgroundEnabled())\r\n            bgAlpha.setTime(0);\r\n    }\r\n    musicInfoProgress.setTime(0);\r\n}"
}, {
	"Path": "ddf.minim.ugens.GranulateSteady.setAllTimeParameters",
	"Comment": "immediately sets all public class members concerning time to new values.",
	"Method": "void setAllTimeParameters(float grainLength,float spaceLength,float fadeLength){\r\n    setAllParameters(grainLength, spaceLength, fadeLength, minAmp, maxAmp);\r\n}"
}, {
	"Path": "org.mewx.wenku8.reader.view.WenkuReaderPageView.calcFromFirst",
	"Comment": "calc page from first to last.firstlineindex & firstwordindex set.",
	"Method": "void calcFromFirst(){\r\n    int widthSum = 0;\r\n    int heightSum = fontHeight;\r\n    StringBuilder tempText = new StringBuilder();\r\n    Log.d(\"MewX\", \"firstLineIndex = \" + firstLineIndex + \"; firstWordIndex = \" + firstWordIndex);\r\n    for (int curLineIndex = firstLineIndex, curWordIndex = firstWordIndex; curLineIndex < mLoader.getElementCount(); ) {\r\n        if (curWordIndex == 0 && mLoader.getCurrentType() == WenkuReaderLoader.ElementType.TEXT) {\r\n            widthSum = 2 * fontHeight;\r\n            tempText = new StringBuilder(\"�?�?\");\r\n        } else if (mLoader.getCurrentType() == WenkuReaderLoader.ElementType.IMAGE_DEPENDENT) {\r\n            if (lineInfoList.size() != 0) {\r\n                lastLineIndex = mLoader.getCurrentIndex() - 1;\r\n                mLoader.setCurrentIndex(lastLineIndex);\r\n                lastWordIndex = mLoader.getCurrentAsString().length() - 1;\r\n                break;\r\n            }\r\n            lastLineIndex = firstLineIndex = mLoader.getCurrentIndex();\r\n            firstWordIndex = 0;\r\n            lastWordIndex = mLoader.getCurrentAsString().length() - 1;\r\n            LineInfo li = new LineInfo();\r\n            li.type = WenkuReaderLoader.ElementType.IMAGE_DEPENDENT;\r\n            li.text = mLoader.getCurrentAsString();\r\n            lineInfoList.add(li);\r\n            break;\r\n        }\r\n        if (mLoader.getCurrentAsString() == null || mLoader.getCurrentAsString().length() == 0) {\r\n            Log.d(\"MewX\", \"empty string! in \" + curLineIndex + \"(\" + curWordIndex + \")\");\r\n            curWordIndex = 0;\r\n            if (curLineIndex >= mLoader.getElementCount()) {\r\n                break;\r\n            }\r\n            mLoader.setCurrentIndex(++curLineIndex);\r\n            continue;\r\n        }\r\n        String temp = mLoader.getCurrentAsString().charAt(curWordIndex) + \"\";\r\n        int tempWidth = (int) textPaint.measureText(temp);\r\n        if (widthSum + tempWidth > textAreaSize.x) {\r\n            LineInfo li = new LineInfo();\r\n            li.type = WenkuReaderLoader.ElementType.TEXT;\r\n            li.text = tempText.toString();\r\n            lineInfoList.add(li);\r\n            heightSum += pxLineDistance;\r\n            if (heightSum + fontHeight > textAreaSize.y) {\r\n                if (curWordIndex > 0) {\r\n                    lastLineIndex = curLineIndex;\r\n                    lastWordIndex = curWordIndex - 1;\r\n                } else if (curLineIndex > 0) {\r\n                    mLoader.setCurrentIndex(--curLineIndex);\r\n                    lastLineIndex = curLineIndex;\r\n                    lastWordIndex = mLoader.getCurrentAsString().length() - 1;\r\n                } else {\r\n                    lastLineIndex = lastWordIndex = 0;\r\n                }\r\n                break;\r\n            }\r\n            tempText = new StringBuilder(temp);\r\n            widthSum = tempWidth;\r\n            heightSum += fontHeight;\r\n        } else {\r\n            tempText.append(temp);\r\n            widthSum += tempWidth;\r\n        }\r\n        if (curWordIndex + 1 >= mLoader.getCurrentAsString().length()) {\r\n            LineInfo li = new LineInfo();\r\n            li.type = WenkuReaderLoader.ElementType.TEXT;\r\n            li.text = tempText.toString();\r\n            lineInfoList.add(li);\r\n            heightSum += pxParagraphDistance;\r\n            if (heightSum + fontHeight > textAreaSize.y) {\r\n                lastLineIndex = mLoader.getCurrentIndex();\r\n                lastWordIndex = mLoader.getCurrentAsString().length() - 1;\r\n                break;\r\n            }\r\n            heightSum += fontHeight;\r\n            widthSum = 0;\r\n            tempText = new StringBuilder();\r\n            curWordIndex = 0;\r\n            if (curLineIndex + 1 >= mLoader.getElementCount()) {\r\n                lastLineIndex = curLineIndex;\r\n                lastWordIndex = mLoader.getCurrentAsString().length() - 1;\r\n                break;\r\n            }\r\n            mLoader.setCurrentIndex(++curLineIndex);\r\n        } else {\r\n            curWordIndex++;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.replay.ReplayFrame.getTimeDiff",
	"Comment": "returns the time since the previous action, in milliseconds.",
	"Method": "int getTimeDiff(){\r\n    return timeDiff;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getTopIndex",
	"Comment": "gets the top index.the top index is the index of the fully visible line that is currently at the top of the widget or the topmost partially visible line if no line is fully visible. the top index changes when the widget is scrolled. indexing is zero based.",
	"Method": "int getTopIndex(){\r\n    checkWidget();\r\n    return topIndex;\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.setCurrentValue",
	"Comment": "set the displaced value to determine the displacement for the spring from the rest value.this value is retained and used to calculate the displacement ratio.this also updates the start value of the spring.",
	"Method": "Spring setCurrentValue(double currentValue){\r\n    mStartValue = currentValue;\r\n    mCurrentState.position = currentValue;\r\n    mSpringSystem.activateSpring(this.getId());\r\n    for (SpringListener listener : mListeners) {\r\n        listener.onSpringUpdate(this);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.openhtmltopdf.nonvisualregressiontests.NonVisualRegressionTest.testFormControlOverflowPage",
	"Comment": "tests the positioning, size, name and value of a form control on an overflow page.",
	"Method": "void testFormControlOverflowPage(){\r\n    PDDocument doc = run(\"form-control-overflow-page\");\r\n    assertEquals(0, doc.getPage(0).getAnnotations().size());\r\n    assertEquals(1, doc.getPage(1).getAnnotations().size());\r\n    assertThat(doc.getPage(1).getAnnotations().get(0), instanceOf(PDAnnotationWidget.class));\r\n    PDAnnotationWidget widget = (PDAnnotationWidget) doc.getPage(1).getAnnotations().get(0);\r\n    assertThat(widget.getRectangle(), rectEquals(new PDRectangle(33f, 14f, 40f, 20f), 100));\r\n    PDAcroForm form = doc.getDocumentCatalog().getAcroForm();\r\n    assertEquals(1, form.getFields().size());\r\n    assertThat(form.getFields().get(0), instanceOf(PDTextField.class));\r\n    PDTextField field = (PDTextField) form.getFields().get(0);\r\n    assertEquals(\"text-input\", field.getFullyQualifiedName());\r\n    assertEquals(\"Hello World!\", field.getValue());\r\n    remove(\"form-control-overflow-page\", doc);\r\n}"
}, {
	"Path": "org.lwjgl.opengl.CallbackUtil.registerContextCallbackAMD",
	"Comment": "associates the current opengl context with the specified global reference. if there\tis no context current, the global reference is deleted and an exception is thrown.\tany previous callback registrations will be cleared.",
	"Method": "void registerContextCallbackAMD(long userParam){\r\n    registerContextCallback(userParam, contextUserParamsAMD);\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.AbstractOutputDevice.setFontSpecification",
	"Comment": "sets the fontspecification for this abstractoutputdevice.",
	"Method": "void setFontSpecification(FontSpecification fs){\r\n    _fontSpec = fs;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGL.eglGetDisplay",
	"Comment": "obtains an egl display from the specified native display and initializes it.",
	"Method": "EGLDisplay eglGetDisplay(long display_id){\r\n    final long pointer = neglGetDisplay(display_id);\r\n    if (pointer == EGL_NO_DISPLAY)\r\n        throw new LWJGLException(\"Failed to get EGL display from native display handle: \" + display_id);\r\n    return new EGLDisplay(pointer);\r\n}"
}, {
	"Path": "ddf.minim.javasound.FloatSampleBuffer.checkFormatSupported",
	"Comment": "verify that the specified audioformat can be converted to and from. if\tthe format is not supported, an illegalargumentexception is thrown.",
	"Method": "void checkFormatSupported(AudioFormat format){\r\n    FloatSampleTools.getFormatType(format);\r\n}"
}, {
	"Path": "com.iwebpp.node.net.AbstractSocket._read",
	"Comment": "just call handle.readstart until we have enough in the buffer",
	"Method": "void _read(int n){\r\n    final AbstractSocket self = this;\r\n    debug(TAG, \"_read\");\r\n    if (this._connecting || null == this._handle) {\r\n        debug(TAG, \"_read wait for connection\");\r\n        this.once(\"connect\", new Listener() {\r\n            @Override\r\n            public void onEvent(Object data) throws Exception {\r\n                self._read(n);\r\n            }\r\n        });\r\n    } else if (!this._handle.reading) {\r\n        debug(TAG, \"AbstractSocket._read readStart\");\r\n        this._handle.reading = true;\r\n        this._handle.readStart();\r\n    }\r\n}"
}, {
	"Path": "com.iwebpp.node.net.AbstractSocket._read",
	"Comment": "just call handle.readstart until we have enough in the buffer",
	"Method": "void _read(int n){\r\n    self._read(n);\r\n}"
}, {
	"Path": "io.opencensus.implcore.internal.CurrentState.getInternal",
	"Comment": "returns the current state without updating the status as being read.",
	"Method": "State getInternal(){\r\n    return currentInternalState.get().state;\r\n}"
}, {
	"Path": "com.openhtmltopdf.resource.FSCatalog.parseCatalog",
	"Comment": "parses an xml catalog file and returns a map of public ids to local uris readfrom the catalog. only the catalog public elements are parsed.",
	"Method": "Map<String, String> parseCatalog(String catalogURI,Map<String, String> parseCatalog,InputSource inputSource){\r\n    XMLReader xmlReader = XMLResource.newXMLReader();\r\n    CatalogContentHandler ch = new CatalogContentHandler();\r\n    addHandlers(xmlReader, ch);\r\n    setFeature(xmlReader, \"http://xml.org/sax/features/validation\", false);\r\n    try {\r\n        xmlReader.parse(inputSource);\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(\"Failed on configuring SAX to DOM transformer.\", ex);\r\n    }\r\n    return ch.getEntityMap();\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.animateScale",
	"Comment": "creates a scale animation builder, that when started will animate a zoom in or out. if this would move the imagebeyond the panning limits, the image is automatically panned during the animation.",
	"Method": "AnimationBuilder animateScale(float scale){\r\n    if (!isImageReady()) {\r\n        return null;\r\n    }\r\n    return new AnimationBuilder(scale);\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.onTouchEvent",
	"Comment": "handle touch events. one finger pans, and two finger pinch and zoom plus panning.",
	"Method": "boolean onTouchEvent(MotionEvent event){\r\n    PointF vCenterEnd;\r\n    float vDistEnd;\r\n    if (anim != null && !anim.interruptible) {\r\n        getParent().requestDisallowInterceptTouchEvent(true);\r\n        return true;\r\n    } else {\r\n        anim = null;\r\n    }\r\n    if (vTranslate == null) {\r\n        return true;\r\n    }\r\n    if (detector == null || detector.onTouchEvent(event)) {\r\n        return true;\r\n    }\r\n    int touchCount = event.getPointerCount();\r\n    switch(event.getAction()) {\r\n        case MotionEvent.ACTION_DOWN:\r\n        case MotionEvent.ACTION_POINTER_1_DOWN:\r\n        case MotionEvent.ACTION_POINTER_2_DOWN:\r\n            anim = null;\r\n            getParent().requestDisallowInterceptTouchEvent(true);\r\n            maxTouchCount = Math.max(maxTouchCount, touchCount);\r\n            if (touchCount >= 2) {\r\n                if (zoomEnabled) {\r\n                    float distance = distance(event.getX(0), event.getX(1), event.getY(0), event.getY(1));\r\n                    scaleStart = scale;\r\n                    vDistStart = distance;\r\n                    vTranslateStart = new PointF(vTranslate.x, vTranslate.y);\r\n                    vCenterStart = new PointF((event.getX(0) + event.getX(1)) / 2, (event.getY(0) + event.getY(1)) / 2);\r\n                } else {\r\n                    maxTouchCount = 0;\r\n                }\r\n                handler.removeMessages(MESSAGE_LONG_CLICK);\r\n            } else {\r\n                vTranslateStart = new PointF(vTranslate.x, vTranslate.y);\r\n                vCenterStart = new PointF(event.getX(), event.getY());\r\n                handler.sendEmptyMessageDelayed(MESSAGE_LONG_CLICK, 600);\r\n            }\r\n            return true;\r\n        case MotionEvent.ACTION_MOVE:\r\n            boolean consumed = false;\r\n            if (maxTouchCount > 0) {\r\n                if (touchCount >= 2) {\r\n                    vDistEnd = distance(event.getX(0), event.getX(1), event.getY(0), event.getY(1));\r\n                    vCenterEnd = new PointF((event.getX(0) + event.getX(1)) / 2, (event.getY(0) + event.getY(1)) / 2);\r\n                    if (zoomEnabled && (distance(vCenterStart.x, vCenterEnd.x, vCenterStart.y, vCenterEnd.y) > 5 || Math.abs(vDistEnd - vDistStart) > 5 || isPanning)) {\r\n                        isZooming = true;\r\n                        isPanning = true;\r\n                        consumed = true;\r\n                        scale = Math.min(maxScale, (vDistEnd / vDistStart) * scaleStart);\r\n                        if (scale <= minScale()) {\r\n                            vDistStart = vDistEnd;\r\n                            scaleStart = minScale();\r\n                            vCenterStart = vCenterEnd;\r\n                            vTranslateStart = vTranslate;\r\n                        } else if (panEnabled) {\r\n                            float vLeftStart = vCenterStart.x - vTranslateStart.x;\r\n                            float vTopStart = vCenterStart.y - vTranslateStart.y;\r\n                            float vLeftNow = vLeftStart * (scale / scaleStart);\r\n                            float vTopNow = vTopStart * (scale / scaleStart);\r\n                            vTranslate.x = vCenterEnd.x - vLeftNow;\r\n                            vTranslate.y = vCenterEnd.y - vTopNow;\r\n                        } else if (sRequestedCenter != null) {\r\n                            vTranslate.x = (getWidth() / 2) - (scale * sRequestedCenter.x);\r\n                            vTranslate.y = (getHeight() / 2) - (scale * sRequestedCenter.y);\r\n                        } else {\r\n                            vTranslate.x = (getWidth() / 2) - (scale * (sWidth() / 2));\r\n                            vTranslate.y = (getHeight() / 2) - (scale * (sHeight() / 2));\r\n                        }\r\n                        fitToBounds(true);\r\n                        refreshRequiredTiles(false);\r\n                    }\r\n                } else if (!isZooming) {\r\n                    float dx = Math.abs(event.getX() - vCenterStart.x);\r\n                    float dy = Math.abs(event.getY() - vCenterStart.y);\r\n                    if (dx > 5 || dy > 5 || isPanning) {\r\n                        consumed = true;\r\n                        vTranslate.x = vTranslateStart.x + (event.getX() - vCenterStart.x);\r\n                        vTranslate.y = vTranslateStart.y + (event.getY() - vCenterStart.y);\r\n                        float lastX = vTranslate.x;\r\n                        float lastY = vTranslate.y;\r\n                        fitToBounds(true);\r\n                        if (lastX == vTranslate.x || (lastY == vTranslate.y && dy > 10) || isPanning) {\r\n                            isPanning = true;\r\n                        } else if (dx > 5) {\r\n                            maxTouchCount = 0;\r\n                            handler.removeMessages(MESSAGE_LONG_CLICK);\r\n                            getParent().requestDisallowInterceptTouchEvent(false);\r\n                        }\r\n                        if (!panEnabled) {\r\n                            vTranslate.x = vTranslateStart.x;\r\n                            vTranslate.y = vTranslateStart.y;\r\n                            getParent().requestDisallowInterceptTouchEvent(false);\r\n                        }\r\n                        refreshRequiredTiles(false);\r\n                    }\r\n                }\r\n            }\r\n            if (consumed) {\r\n                handler.removeMessages(MESSAGE_LONG_CLICK);\r\n                invalidate();\r\n                return true;\r\n            }\r\n            break;\r\n        case MotionEvent.ACTION_UP:\r\n        case MotionEvent.ACTION_POINTER_UP:\r\n        case MotionEvent.ACTION_POINTER_2_UP:\r\n            handler.removeMessages(MESSAGE_LONG_CLICK);\r\n            if (maxTouchCount > 0 && (isZooming || isPanning)) {\r\n                if (isZooming && touchCount == 2) {\r\n                    isPanning = true;\r\n                    vTranslateStart = new PointF(vTranslate.x, vTranslate.y);\r\n                    if (event.getActionIndex() == 1) {\r\n                        vCenterStart = new PointF(event.getX(0), event.getY(0));\r\n                    } else {\r\n                        vCenterStart = new PointF(event.getX(1), event.getY(1));\r\n                    }\r\n                }\r\n                if (touchCount < 3) {\r\n                    isZooming = false;\r\n                }\r\n                if (touchCount < 2) {\r\n                    isPanning = false;\r\n                    maxTouchCount = 0;\r\n                }\r\n                refreshRequiredTiles(true);\r\n                return true;\r\n            }\r\n            if (touchCount == 1) {\r\n                isZooming = false;\r\n                isPanning = false;\r\n                maxTouchCount = 0;\r\n            }\r\n            return true;\r\n    }\r\n    return super.onTouchEvent(event);\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testRunningTransform",
	"Comment": "tests a simple rotate transform of the running elements themselves.",
	"Method": "void testRunningTransform(){\r\n    assertTrue(vt.runTest(\"running-transform\"));\r\n}"
}, {
	"Path": "ddf.minim.signals.Oscillator.portamento",
	"Comment": "sets how many milliseconds it should take to transition from one frequencyto another when setting a new frequency.",
	"Method": "void portamento(int millis){\r\n    if (millis <= 0) {\r\n        Minim.error(\"Oscillator.portamento: The portamento speed must be greater than zero.\");\r\n    }\r\n    port = true;\r\n    portSpeed = millis;\r\n}"
}, {
	"Path": "com.j256.ormlite.stmt.mapped.MappedDeleteCollection.build",
	"Comment": "this is private because the execute is the only method that should be called here.",
	"Method": "MappedDeleteCollection<T, ID> build(DatabaseType databaseType,TableInfo<T, ID> tableInfo,int dataSize){\r\n    FieldType idField = tableInfo.getIdField();\r\n    if (idField == null) {\r\n        throw new SQLException(\"Cannot delete \" + tableInfo.getDataClass() + \" because it doesn't have an id field defined\");\r\n    }\r\n    StringBuilder sb = new StringBuilder(128);\r\n    appendTableName(databaseType, sb, \"DELETE FROM \", tableInfo.getTableName());\r\n    FieldType[] argFieldTypes = new FieldType[dataSize];\r\n    appendWhereIds(databaseType, idField, sb, dataSize, argFieldTypes);\r\n    return new MappedDeleteCollection<T, ID>(tableInfo, sb.toString(), argFieldTypes);\r\n}"
}, {
	"Path": "ddf.minim.Minim.getInputStream",
	"Comment": "get the input as an audiostream that you can read from yourself, rather\tthan wrapped in an audioinput that does that work for you.",
	"Method": "AudioStream getInputStream(int type,int bufferSize,float sampleRate,int bitDepth){\r\n    AudioStream stream = mimp.getAudioInput(type, bufferSize, sampleRate, bitDepth);\r\n    streams.add(stream);\r\n    return stream;\r\n}"
}, {
	"Path": "ddf.minim.Controller.isShiftingBalance",
	"Comment": "returns true if the balance is currently shifting.if no gain control is available this method returns false.",
	"Method": "boolean isShiftingBalance(){\r\n    return bshift;\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.onSizeChanged",
	"Comment": "on resize, preserve center and scale. various behaviours are possible, override this method to use another.",
	"Method": "void onSizeChanged(int w,int h,int oldw,int oldh){\r\n    if (readySent) {\r\n        setScaleAndCenter(getScale(), getCenter());\r\n    }\r\n}"
}, {
	"Path": "com.joestelmach.natty.WalkerState.seekToHoliday",
	"Comment": "seeks forward or backwards to a particular holiday based on the current date",
	"Method": "void seekToHoliday(String holidayString,String direction,String seekAmount){\r\n    Holiday holiday = Holiday.valueOf(holidayString);\r\n    assert (holiday != null);\r\n    seekToIcsEvent(HOLIDAY_ICS_FILE, holiday.getSummary(), direction, seekAmount);\r\n}"
}, {
	"Path": "io.opencensus.examples.grpc.helloworld.HelloWorldServer.blockUntilShutdown",
	"Comment": "await termination on the main thread since the grpc library uses daemon threads.",
	"Method": "void blockUntilShutdown(){\r\n    if (server != null) {\r\n        server.awaitTermination();\r\n    }\r\n}"
}, {
	"Path": "io.opencensus.exporter.trace.zipkin.ZipkinExporterHandler.produceLocalEndpoint",
	"Comment": "logic borrowed from brave.internal.platform.producelocalendpoint",
	"Method": "Endpoint produceLocalEndpoint(String serviceName){\r\n    Endpoint.Builder builder = Endpoint.newBuilder().serviceName(serviceName);\r\n    try {\r\n        Enumeration<NetworkInterface> nics = NetworkInterface.getNetworkInterfaces();\r\n        if (nics == null) {\r\n            return builder.build();\r\n        }\r\n        while (nics.hasMoreElements()) {\r\n            NetworkInterface nic = nics.nextElement();\r\n            Enumeration<InetAddress> addresses = nic.getInetAddresses();\r\n            while (addresses.hasMoreElements()) {\r\n                InetAddress address = addresses.nextElement();\r\n                if (address.isSiteLocalAddress()) {\r\n                    builder.ip(address);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.log(Level.FINE, \"error reading nics\", e);\r\n        }\r\n    }\r\n    return builder.build();\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.style.DerivedValue.isDeclaredInherit",
	"Comment": "if value is declared inherit should always be the identvalue.inherit,not a derivedvalue",
	"Method": "boolean isDeclaredInherit(){\r\n    return false;\r\n}"
}, {
	"Path": "org.lwjgl.BufferChecks.checkBufferSize",
	"Comment": "helper method to ensure a buffer is big enough to receive data from a\toperation.",
	"Method": "void checkBufferSize(Buffer buf,int size){\r\n    if (LWJGLUtil.CHECKS && buf.remaining() < size) {\r\n        throwBufferSizeException(buf, size);\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.outputdevice.helper.BaseRendererBuilder.useUriResolver",
	"Comment": "provides a uri resolver to resolve relative uris or private uri schemes.",
	"Method": "TFinalClass useUriResolver(FSUriResolver resolver){\r\n    state._resolver = resolver;\r\n    return (TFinalClass) this;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.objects.curves.Vec2f.add",
	"Comment": "adds nx to the x component and ny to the y component of this vector.",
	"Method": "Vec2f add(Vec2f o,Vec2f add,float nx,float ny){\r\n    x += nx;\r\n    y += ny;\r\n    return this;\r\n}"
}, {
	"Path": "ddf.minim.effects.IIRFilter.validFreq",
	"Comment": "returns true if the frequency is valid for this filter. subclasses can override this method if they want to limit center frequencies to certain ranges to avoid becoming unstable. the default implementation simply makes sure that f is positive.",
	"Method": "boolean validFreq(float f){\r\n    return f > 0;\r\n}"
}, {
	"Path": "com.j256.ormlite.table.DatabaseTableConfigLoader.readFields",
	"Comment": "read all of the fields information from the configuration file.",
	"Method": "void readFields(BufferedReader reader,DatabaseTableConfig<T> config){\r\n    List<DatabaseFieldConfig> fields = new ArrayList<DatabaseFieldConfig>();\r\n    while (true) {\r\n        String line;\r\n        try {\r\n            line = reader.readLine();\r\n        } catch (IOException e) {\r\n            throw SqlExceptionUtil.create(\"Could not read next field from config file\", e);\r\n        }\r\n        if (line == null || line.equals(CONFIG_FILE_FIELDS_END)) {\r\n            break;\r\n        }\r\n        DatabaseFieldConfig fieldConfig = DatabaseFieldConfigLoader.fromReader(reader);\r\n        if (fieldConfig == null) {\r\n            break;\r\n        }\r\n        fields.add(fieldConfig);\r\n    }\r\n    config.setFieldConfigs(fields);\r\n}"
}, {
	"Path": "ddf.minim.ugens.Delay.setDelTime",
	"Comment": "changes the time in between the echos to the value specified.",
	"Method": "void setDelTime(float delayTime){\r\n    delTime.setLastValue(delayTime);\r\n}"
}, {
	"Path": "io.blackbox_vision.materialcalendarview.view.CalendarView.canScroll",
	"Comment": "tests scroll ability within child views of v given a delta of dx.",
	"Method": "boolean canScroll(View v,boolean checkV,int dx,int x,int y){\r\n    if (v instanceof ViewGroup) {\r\n        final ViewGroup group = (ViewGroup) v;\r\n        final int scrollX = v.getScrollX();\r\n        final int scrollY = v.getScrollY();\r\n        final int count = group.getChildCount();\r\n        for (int i = count - 1; i >= 0; i--) {\r\n            final View child = group.getChildAt(i);\r\n            if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && canScroll(child, true, dx, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return checkV && ViewCompat.canScrollHorizontally(v, -dx);\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.Configuration.valueAsInt",
	"Comment": "returns the value for key in the configuration as an integer, or adefault value if not found or if the value is not a valid integer. awarning is issued to the log if the property is not defined, or if theconversion from string fails.",
	"Method": "int valueAsInt(String key,int defaultVal){\r\n    String val = valueFor(key);\r\n    if (val == null) {\r\n        return defaultVal;\r\n    }\r\n    int ival;\r\n    try {\r\n        ival = Integer.valueOf(val).intValue();\r\n    } catch (NumberFormatException nex) {\r\n        XRLog.exception(\"Property '\" + key + \"' was requested as an integer, but \" + \"value of '\" + val + \"' is not an integer. Check configuration.\");\r\n        ival = defaultVal;\r\n    }\r\n    return ival;\r\n}"
}, {
	"Path": "ddf.minim.AudioSnippet.close",
	"Comment": "closes the snippet so that any resources it is using can be released. this\tshould be called when you are finished using this snippet.",
	"Method": "void close(){\r\n    recording.close();\r\n}"
}, {
	"Path": "org.lwjgl.util.generator.GeneratorProcessor.getGeneratorLastModified",
	"Comment": "gets the time of the latest change on the generator classes.",
	"Method": "long getGeneratorLastModified(String bin_path){\r\n    long lastModified = getDirectoryLastModified(bin_path, \"/org/lwjgl/util/generator\");\r\n    lastModified = Math.max(lastModified, getDirectoryLastModified(bin_path, \"/org/lwjgl/util/generator/openal\"));\r\n    lastModified = Math.max(lastModified, getDirectoryLastModified(bin_path, \"/org/lwjgl/util/generator/opengl\"));\r\n    lastModified = Math.max(lastModified, getDirectoryLastModified(bin_path, \"/org/lwjgl/util/generator/opencl\"));\r\n    return lastModified;\r\n}"
}, {
	"Path": "ddf.minim.UGen.channelCount",
	"Comment": "returns the number of channels this ugen has been configured to generate.",
	"Method": "int channelCount(int channelCount){\r\n    return m_lastValues.length;\r\n}"
}, {
	"Path": "orestes.bloomfilter.FilterBuilder.expectedElements",
	"Comment": "sets the number of expected elements. in combination with the tolerable false positive probability, this is usedto infer the optimal size and optimal number of hash functions of the filter.",
	"Method": "FilterBuilder expectedElements(int expectedElements,int expectedElements){\r\n    return expectedElements;\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.constants.CSSName.addProperty",
	"Comment": "adds a feature to the property attribute of the cssname class",
	"Method": "CSSName addProperty(String propName,Object type,String initialValue,Object inherit,PropertyBuilder builder,CSSName addProperty,String propName,Object type,String initialValue,Object inherit,boolean implemented,PropertyBuilder builder){\r\n    CSSName cssName = new CSSName(propName, initialValue, (inherit == INHERITS), implemented, builder);\r\n    ALL_PROPERTY_NAMES.put(propName, cssName);\r\n    if (type == PRIMITIVE) {\r\n        ALL_PRIMITIVE_PROPERTY_NAMES.put(propName, cssName);\r\n    }\r\n    return cssName;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.addLineBackgroundListener",
	"Comment": "adds a line background listener. a linegetbackground event is sent by the widget to determine the background color for a line.",
	"Method": "void addLineBackgroundListener(LineBackgroundListener listener){\r\n    checkWidget();\r\n    if (listener == null)\r\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\r\n    if (!isListening(ST.LineGetBackground)) {\r\n        renderer.clearLineBackground(0, content.getLineCount());\r\n    }\r\n    addListener(ST.LineGetBackground, new StyledTextListener(listener));\r\n}"
}, {
	"Path": "ddf.minim.javasound.JSBufferedSampleRecorder.save",
	"Comment": "saves the audio in the internal buffer to a file using the current settings for file type and file name.",
	"Method": "AudioRecordingStream save(){\r\n    if (isRecording()) {\r\n        system.error(\"You must stop recording before you can write to a file.\");\r\n    } else {\r\n        int channels = format.getChannels();\r\n        int length = left.capacity();\r\n        int totalSamples = (buffers.size() / channels) * length;\r\n        FloatSampleBuffer fsb = new FloatSampleBuffer(channels, totalSamples, format.getSampleRate());\r\n        if (channels == 1) {\r\n            for (int i = 0; i < buffers.size(); i++) {\r\n                int offset = i * length;\r\n                FloatBuffer fb = (FloatBuffer) buffers.get(i);\r\n                fb.rewind();\r\n                fb.get(fsb.getChannel(0), offset, length);\r\n            }\r\n        } else {\r\n            for (int i = 0; i < buffers.size(); i += 2) {\r\n                int offset = (i / 2) * length;\r\n                FloatBuffer fbL = (FloatBuffer) buffers.get(i);\r\n                FloatBuffer fbR = (FloatBuffer) buffers.get(i + 1);\r\n                fbL.rewind();\r\n                fbL.get(fsb.getChannel(0), offset, length);\r\n                fbR.rewind();\r\n                fbR.get(fsb.getChannel(1), offset, length);\r\n            }\r\n        }\r\n        int sampleFrames = fsb.getByteArrayBufferSize(format) / format.getFrameSize();\r\n        ByteArrayInputStream bais = new ByteArrayInputStream(fsb.convertToByteArray(format));\r\n        AudioInputStream ais = new AudioInputStream(bais, format, sampleFrames);\r\n        if (AudioSystem.isFileTypeSupported(type, ais)) {\r\n            File out = new File(name);\r\n            try {\r\n                AudioSystem.write(ais, type, out);\r\n            } catch (IOException e) {\r\n                system.error(\"AudioRecorder.save: Error attempting to save buffer to \" + name + \"\\n\" + e.getMessage());\r\n            }\r\n            if (out.length() == 0) {\r\n                system.error(\"AudioRecorder.save: Error attempting to save buffer to \" + name + \", the output file is empty.\");\r\n            }\r\n        } else {\r\n            system.error(\"AudioRecorder.save: Can't write \" + type.toString() + \" using format \" + format.toString() + \".\");\r\n        }\r\n    }\r\n    String filePath = filePath();\r\n    AudioInputStream ais = system.getAudioInputStream(filePath);\r\n    SourceDataLine sdl = system.getSourceDataLine(ais.getFormat(), 1024);\r\n    long length = AudioUtils.frames2Millis(ais.getFrameLength(), format);\r\n    BasicMetaData meta = new BasicMetaData(filePath, length, ais.getFrameLength());\r\n    JSPCMAudioRecordingStream recording = new JSPCMAudioRecordingStream(system, meta, ais, sdl, 1024);\r\n    return recording;\r\n}"
}, {
	"Path": "com.openhtmltopdf.pdfboxout.PdfBoxBookmarkManager.createBoxDestination",
	"Comment": "creates a pdpagexyzdestination with the y set to the min y of the border box and the x and z set to null. takes into account any transforms set for the box as well as inserted overflow pages.",
	"Method": "PDPageXYZDestination createBoxDestination(RenderingContext c,PDDocument writer,PdfBoxFastOutputDevice od,float dotsPerPoint,Box root,Box box){\r\n    List<PageBox> pages = root.getLayer().getPages();\r\n    Rectangle bounds = PagedBoxCollector.findAdjustedBoundsForBorderBox(c, box, pages);\r\n    int pageBoxIndex = PagedBoxCollector.findPageForY(c, bounds.getMinY(), pages);\r\n    PageBox page = pages.get(pageBoxIndex);\r\n    int distanceFromTop = page.getMarginBorderPadding(c, CalculatedStyle.TOP);\r\n    distanceFromTop += bounds.getMinY() - page.getTop();\r\n    int shadowPage = PagedBoxCollector.getShadowPageForBounds(c, bounds, page);\r\n    int pdfPageIndex = shadowPage == -1 ? page.getBasePagePdfPageIndex() : shadowPage + 1 + page.getBasePagePdfPageIndex();\r\n    PDPageXYZDestination target = new PDPageXYZDestination();\r\n    target.setTop((int) (od.normalizeY(distanceFromTop, page.getHeight(c)) / dotsPerPoint));\r\n    target.setPage(writer.getPage(pdfPageIndex));\r\n    return target;\r\n}"
}, {
	"Path": "org.lwjgl.util.input.ControllerAdapter.getRZAxisValue",
	"Comment": "get the value from the rz axis if there is one. if no rz axis is defined\ta zero value will be returned.",
	"Method": "float getRZAxisValue(){\r\n    return 0f;\r\n}"
}, {
	"Path": "orestes.bloomfilter.cachesketch.ExpiringBloomFilter.isKnown",
	"Comment": "determines whether each of the given input elements is known and returns a list of boolean values where eachboolean represents whether or not the corresponding element in the input list is known.an object is known if it is cached or was removed from the cache not for longer than the grace period.",
	"Method": "boolean isKnown(T element,List<Boolean> isKnown,List<T> elements){\r\n    return elements.stream().map(this::isKnown).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.newdawn.slick.Music.setPosition",
	"Comment": "seeks to a position in the music. for streaming music, seeking before the current position causes \tthe stream to be reloaded.",
	"Method": "boolean setPosition(float position){\r\n    synchronized (musicLock) {\r\n        if (playing) {\r\n            requiredPosition = -1;\r\n            positioning = true;\r\n            playing = false;\r\n            boolean result = sound.setPosition(position);\r\n            playing = true;\r\n            positioning = false;\r\n            return result;\r\n        } else {\r\n            requiredPosition = position;\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.j256.ormlite.field.FieldType.convertJavaFieldToSqlArgValue",
	"Comment": "convert a field value to something suitable to be stored in the database.",
	"Method": "Object convertJavaFieldToSqlArgValue(Object fieldVal){\r\n    if (fieldVal == null) {\r\n        return null;\r\n    } else {\r\n        return fieldConverter.javaToSqlArg(this, fieldVal);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.states.MainMenu.nextTrack",
	"Comment": "plays the next track, and adds the previous one to the stack.",
	"Method": "void nextTrack(boolean user){\r\n    lastMeasureProgress = 0f;\r\n    boolean isTheme = MusicController.isThemePlaying();\r\n    if (isTheme && !user) {\r\n        MusicController.playAt(0, false);\r\n        return;\r\n    }\r\n    SongMenu menu = (SongMenu) game.getState(Opsu.STATE_SONGMENU);\r\n    BeatmapSetNode node = menu.setFocus(BeatmapSetList.get().getRandomNode(), -1, true, false);\r\n    boolean sameAudio = false;\r\n    if (node != null) {\r\n        sameAudio = MusicController.getBeatmap().audioFilename.equals(node.getBeatmapSet().get(0).audioFilename);\r\n        if (!isTheme && !sameAudio)\r\n            previous.add(node.index);\r\n    }\r\n    if (Options.isDynamicBackgroundEnabled() && !sameAudio && !MusicController.isThemePlaying())\r\n        bgAlpha.setTime(0);\r\n    musicInfoProgress.setTime(0);\r\n}"
}, {
	"Path": "com.j256.ormlite.field.FieldType.extractJavaFieldToSqlArgValue",
	"Comment": "extract a field from an object and convert to something suitable to be passed to sql as an argument.",
	"Method": "Object extractJavaFieldToSqlArgValue(Object object){\r\n    return convertJavaFieldToSqlArgValue(extractJavaFieldValue(object));\r\n}"
}, {
	"Path": "ddf.minim.analysis.FourierTransform.freqToIndex",
	"Comment": "returns the index of the frequency band that contains the requestedfrequency.",
	"Method": "int freqToIndex(float freq){\r\n    if (freq < getBandWidth() / 2)\r\n        return 0;\r\n    if (freq > sampleRate / 2 - getBandWidth() / 2)\r\n        return spectrum.length - 1;\r\n    float fraction = freq / (float) sampleRate;\r\n    int i = Math.round(timeSize * fraction);\r\n    return i;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.db.DBController.createConnection",
	"Comment": "establishes a connection to the database given by the path string.",
	"Method": "Connection createConnection(String path){\r\n    try {\r\n        return DriverManager.getConnection(String.format(\"jdbc:sqlite:%s\", path));\r\n    } catch (SQLException e) {\r\n        throw new SQLException(String.format(\"Could not connect to database: '%s'.\", path), e);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.Updater.updatedFromVersion",
	"Comment": "returns the version the program was just updated from, or null if not updated.",
	"Method": "String updatedFromVersion(){\r\n    return (justUpdated()) ? updatedFromVersion : null;\r\n}"
}, {
	"Path": "com.android.volley.Request.setRequestQueue",
	"Comment": "associates this request with the given queue. the request queue will be notified when thisrequest has finished.",
	"Method": "Request<?> setRequestQueue(RequestQueue requestQueue){\r\n    mRequestQueue = requestQueue;\r\n    return this;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGL.eglQuerySurface",
	"Comment": "returns the value of the specified egl surface attribute in the value parameter.",
	"Method": "void eglQuerySurface(EGLDisplay dpy,EGLSurface surface,int attribute,IntBuffer value){\r\n    BufferChecks.checkBuffer(value, 1);\r\n    if (!neglQuerySurface(dpy.getPointer(), surface.getPointer(), attribute, MemoryUtil.getAddress(value)))\r\n        throwEGLError(\"Failed to query surface attribute.\");\r\n}"
}, {
	"Path": "ddf.minim.javasound.FloatSampleBuffer.grow",
	"Comment": "grow the channels array to allow at least channelcount elements. if\t!lazy, then channels will be resized to be exactly channelcount elements.\tthe new elements will be null.",
	"Method": "void grow(int newChannelCount,boolean lazy){\r\n    if (channels.length < newChannelCount || !lazy) {\r\n        Object[] newChannels = new Object[newChannelCount];\r\n        System.arraycopy(channels, 0, newChannels, 0, (channelCount < newChannelCount) ? channelCount : newChannelCount);\r\n        this.channels = newChannels;\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.Beatmap.getArtist",
	"Comment": "returns the song artist.\tif configured, the unicode string will be returned instead.",
	"Method": "String getArtist(){\r\n    return (Options.useUnicodeMetadata() && !artistUnicode.isEmpty()) ? artistUnicode : artist;\r\n}"
}, {
	"Path": "com.j256.ormlite.table.TableUtils.createTableIfNotExists",
	"Comment": "create a table if it does not already exist. this is not supported by all databases.",
	"Method": "int createTableIfNotExists(ConnectionSource connectionSource,Class<T> dataClass,int createTableIfNotExists,ConnectionSource connectionSource,DatabaseTableConfig<T> tableConfig){\r\n    Dao<T, ?> dao = DaoManager.createDao(connectionSource, tableConfig);\r\n    return doCreateTable(dao, true);\r\n}"
}, {
	"Path": "com.nbsp.materialfilepicker.MaterialFilePicker.withPath",
	"Comment": "specifies start directory for picker,which will be shown to user at the beginning",
	"Method": "MaterialFilePicker withPath(String path){\r\n    mCurrentPath = path;\r\n    return this;\r\n}"
}, {
	"Path": "com.openhtmltopdf.java2d.api.Java2DRendererBuilder.toSinglePage",
	"Comment": "render everything to a single page. i.e. only one big page is genereated, no\tpagebreak will be done. the page is only as height as needed.",
	"Method": "Java2DRendererBuilder toSinglePage(FSPageProcessor pageProcessor){\r\n    state._pagingMode = Layer.PAGED_MODE_SCREEN;\r\n    state._pageProcessor = pageProcessor;\r\n    return this;\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix4f.invert",
	"Comment": "invert the source matrix and put the result in the destination",
	"Method": "Matrix invert(Matrix4f invert,Matrix4f src,Matrix4f dest){\r\n    float determinant = src.determinant();\r\n    if (determinant != 0) {\r\n        if (dest == null)\r\n            dest = new Matrix4f();\r\n        float determinant_inv = 1f / determinant;\r\n        float t00 = determinant3x3(src.m11, src.m12, src.m13, src.m21, src.m22, src.m23, src.m31, src.m32, src.m33);\r\n        float t01 = -determinant3x3(src.m10, src.m12, src.m13, src.m20, src.m22, src.m23, src.m30, src.m32, src.m33);\r\n        float t02 = determinant3x3(src.m10, src.m11, src.m13, src.m20, src.m21, src.m23, src.m30, src.m31, src.m33);\r\n        float t03 = -determinant3x3(src.m10, src.m11, src.m12, src.m20, src.m21, src.m22, src.m30, src.m31, src.m32);\r\n        float t10 = -determinant3x3(src.m01, src.m02, src.m03, src.m21, src.m22, src.m23, src.m31, src.m32, src.m33);\r\n        float t11 = determinant3x3(src.m00, src.m02, src.m03, src.m20, src.m22, src.m23, src.m30, src.m32, src.m33);\r\n        float t12 = -determinant3x3(src.m00, src.m01, src.m03, src.m20, src.m21, src.m23, src.m30, src.m31, src.m33);\r\n        float t13 = determinant3x3(src.m00, src.m01, src.m02, src.m20, src.m21, src.m22, src.m30, src.m31, src.m32);\r\n        float t20 = determinant3x3(src.m01, src.m02, src.m03, src.m11, src.m12, src.m13, src.m31, src.m32, src.m33);\r\n        float t21 = -determinant3x3(src.m00, src.m02, src.m03, src.m10, src.m12, src.m13, src.m30, src.m32, src.m33);\r\n        float t22 = determinant3x3(src.m00, src.m01, src.m03, src.m10, src.m11, src.m13, src.m30, src.m31, src.m33);\r\n        float t23 = -determinant3x3(src.m00, src.m01, src.m02, src.m10, src.m11, src.m12, src.m30, src.m31, src.m32);\r\n        float t30 = -determinant3x3(src.m01, src.m02, src.m03, src.m11, src.m12, src.m13, src.m21, src.m22, src.m23);\r\n        float t31 = determinant3x3(src.m00, src.m02, src.m03, src.m10, src.m12, src.m13, src.m20, src.m22, src.m23);\r\n        float t32 = -determinant3x3(src.m00, src.m01, src.m03, src.m10, src.m11, src.m13, src.m20, src.m21, src.m23);\r\n        float t33 = determinant3x3(src.m00, src.m01, src.m02, src.m10, src.m11, src.m12, src.m20, src.m21, src.m22);\r\n        dest.m00 = t00 * determinant_inv;\r\n        dest.m11 = t11 * determinant_inv;\r\n        dest.m22 = t22 * determinant_inv;\r\n        dest.m33 = t33 * determinant_inv;\r\n        dest.m01 = t10 * determinant_inv;\r\n        dest.m10 = t01 * determinant_inv;\r\n        dest.m20 = t02 * determinant_inv;\r\n        dest.m02 = t20 * determinant_inv;\r\n        dest.m12 = t21 * determinant_inv;\r\n        dest.m21 = t12 * determinant_inv;\r\n        dest.m03 = t30 * determinant_inv;\r\n        dest.m30 = t03 * determinant_inv;\r\n        dest.m13 = t31 * determinant_inv;\r\n        dest.m31 = t13 * determinant_inv;\r\n        dest.m32 = t23 * determinant_inv;\r\n        dest.m23 = t32 * determinant_inv;\r\n        return dest;\r\n    } else\r\n        return null;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.audio.SoundController.getSoundFileName",
	"Comment": "returns the sound file name, with extension, by first looking through\tthe skins directory and then the default resource locations.",
	"Method": "String getSoundFileName(String filename){\r\n    String wav = String.format(\"%s.wav\", filename), mp3 = String.format(\"%s.mp3\", filename);\r\n    File skinDir = Options.getSkin().getDirectory();\r\n    if (skinDir != null) {\r\n        File skinWAV = new File(skinDir, wav), skinMP3 = new File(skinDir, mp3);\r\n        if (skinWAV.isFile())\r\n            return skinWAV.getAbsolutePath();\r\n        if (skinMP3.isFile())\r\n            return skinMP3.getAbsolutePath();\r\n    }\r\n    if (ResourceLoader.resourceExists(wav))\r\n        return wav;\r\n    if (ResourceLoader.resourceExists(mp3))\r\n        return mp3;\r\n    return null;\r\n}"
}, {
	"Path": "orestes.bloomfilter.redis.BloomFilterRedis.getRedisBitSet",
	"Comment": "returns the underlying redisbitset implementation of this redisbloomfilter",
	"Method": "RedisBitSet getRedisBitSet(){\r\n    return bloom;\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.sheet.StylesheetInfo.getStylesheet",
	"Comment": "gets the stylesheet attribute of the stylesheetinfo object",
	"Method": "Stylesheet getStylesheet(){\r\n    return stylesheet;\r\n}"
}, {
	"Path": "org.lwjgl.util.Point.equals",
	"Comment": "determines whether an instance of point2d is equal\tto this point.two instances of point2d are equal if\tthe values of their x and y member \tfields, representing their position in the coordinate space, are\tthe same.",
	"Method": "boolean equals(Object obj){\r\n    if (obj instanceof Point) {\r\n        Point pt = (Point) obj;\r\n        return (x == pt.x) && (y == pt.y);\r\n    }\r\n    return super.equals(obj);\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.getJarInputStream",
	"Comment": "retrieves a jar files input stream. this method exists primarily to fix an opera hang in getinputstream",
	"Method": "InputStream getJarInputStream(String currentFile,URLConnection urlconnection){\r\n    final InputStream[] is = new InputStream[1];\r\n    for (int j = 0; j < 3 && is[0] == null; j++) {\r\n        Thread t = new Thread() {\r\n            public void run() {\r\n                try {\r\n                    is[0] = urlconnection.getInputStream();\r\n                } catch (IOException e) {\r\n                }\r\n            }\r\n        };\r\n        t.setName(\"JarInputStreamThread\");\r\n        t.start();\r\n        int iterationCount = 0;\r\n        while (is[0] == null && iterationCount++ < 5) {\r\n            try {\r\n                t.join(1000);\r\n            } catch (InterruptedException inte) {\r\n            }\r\n        }\r\n        if (is[0] == null) {\r\n            try {\r\n                t.interrupt();\r\n                t.join();\r\n            } catch (InterruptedException inte) {\r\n            }\r\n        }\r\n    }\r\n    if (is[0] == null) {\r\n        throw new Exception(\"Unable to get input stream for \" + currentFile);\r\n    }\r\n    return is[0];\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.getJarInputStream",
	"Comment": "retrieves a jar files input stream. this method exists primarily to fix an opera hang in getinputstream",
	"Method": "InputStream getJarInputStream(String currentFile,URLConnection urlconnection){\r\n    try {\r\n        is[0] = urlconnection.getInputStream();\r\n    } catch (IOException e) {\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Quaternion.negate",
	"Comment": "calculate the conjugate of this quaternion and put it into the given one",
	"Method": "Quaternion negate(Quaternion dest,Quaternion negate,Quaternion src,Quaternion dest,Vector negate){\r\n    return negate(this, this);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getKeyBinding",
	"Comment": "returns the action assigned to the key.returns swt.null if there is no action associated with the key.",
	"Method": "int getKeyBinding(int key){\r\n    checkWidget();\r\n    Integer action = (Integer) keyActionMap.get(new Integer(key));\r\n    return action == null ? SWT.NULL : action.intValue();\r\n}"
}, {
	"Path": "org.lwjgl.opengl.PixelFormat.withStencilBits",
	"Comment": "returns a new pixelformat object with the same properties as this pixelformat and the new stencil bits value.",
	"Method": "PixelFormat withStencilBits(int stencil){\r\n    if (stencil < 0)\r\n        throw new IllegalArgumentException(\"Invalid number of stencil bits specified: \" + stencil);\r\n    final PixelFormat pf = new PixelFormat(this);\r\n    pf.stencil = stencil;\r\n    return pf;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getTextLimit",
	"Comment": "returns the maximum number of characters that the receiver is capable of holding.",
	"Method": "int getTextLimit(){\r\n    checkWidget();\r\n    return textLimit;\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.sheet.StylesheetInfo.setStylesheet",
	"Comment": "sets the stylesheet attribute of the stylesheetinfo object",
	"Method": "void setStylesheet(Stylesheet stylesheet){\r\n    this.stylesheet = stylesheet;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.GLContext.loadOpenGLLibrary",
	"Comment": "if the opengl reference count is 0, the library is loaded. the reference count is then incremented.",
	"Method": "void loadOpenGLLibrary(){\r\n    if (gl_ref_count == 0)\r\n        nLoadOpenGLLibrary();\r\n    gl_ref_count++;\r\n}"
}, {
	"Path": "com.github.pires.obd.utils.CommandAvailabilityHelper.isAvailable",
	"Comment": "checks whether the command identified by commandpid is available, as noted by availabilityarray",
	"Method": "boolean isAvailable(String commandPid,String availabilityString,boolean safetyReturn,boolean isAvailable,String commandPid,String availabilityString,boolean isAvailable,String commandPid,int[] availabilityArray,boolean safetyReturn,boolean isAvailable,String commandPid,int[] availabilityArray){\r\n    if (commandPid.equals(\"00\"))\r\n        return true;\r\n    int cmdNumber = Integer.parseInt(commandPid, 16);\r\n    int arrayIndex = (cmdNumber - 1) / 8;\r\n    if (arrayIndex > availabilityArray.length - 1)\r\n        throw new IllegalArgumentException(\"availabilityArray does not contain enough entries to check for command \" + commandPid);\r\n    while (cmdNumber > 8) {\r\n        cmdNumber -= 8;\r\n    }\r\n    int requestedAvailability;\r\n    switch(cmdNumber) {\r\n        case 1:\r\n            requestedAvailability = 128;\r\n            break;\r\n        case 2:\r\n            requestedAvailability = 64;\r\n            break;\r\n        case 3:\r\n            requestedAvailability = 32;\r\n            break;\r\n        case 4:\r\n            requestedAvailability = 16;\r\n            break;\r\n        case 5:\r\n            requestedAvailability = 8;\r\n            break;\r\n        case 6:\r\n            requestedAvailability = 4;\r\n            break;\r\n        case 7:\r\n            requestedAvailability = 2;\r\n            break;\r\n        case 8:\r\n            requestedAvailability = 1;\r\n            break;\r\n        default:\r\n            throw new RuntimeException(\"This is not supposed to happen.\");\r\n    }\r\n    return requestedAvailability == (requestedAvailability & availabilityArray[arrayIndex]);\r\n}"
}, {
	"Path": "com.j256.ormlite.stmt.Where.rawComparison",
	"Comment": "make a comparison where the operator is specified by the caller. it is up to the caller to specify an appropriate\toperator for the database and that it be formatted correctly.",
	"Method": "Where<T, ID> rawComparison(String columnName,String rawOperator,Object value){\r\n    addClause(new SimpleComparison(columnName, findColumnFieldType(columnName), value, rawOperator));\r\n    return this;\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testTransformStaticBlockMargin",
	"Comment": "with a static block, rotate, large page margin, small block margin, no padding.",
	"Method": "void testTransformStaticBlockMargin(){\r\n    assertTrue(vt.runTest(\"transform-static-block-margin\"));\r\n}"
}, {
	"Path": "com.iwebpp.wspp.Sender.frameAndSend",
	"Comment": "frames and sends a piece of data according to the hybi websocket protocol.",
	"Method": "boolean frameAndSend(int opcode,Object data,boolean finalFragment,boolean maskData,WriteCB cb){\r\n    debug(TAG, \"frameAndSend,opcode:\" + opcode + \",data:\" + data + \",mask:\" + maskData);\r\n    if (data != null && data instanceof ByteBuffer) {\r\n        ByteBuffer bd = (ByteBuffer) data;\r\n        String dstr = \"\";\r\n        for (int i = 0; i < bd.capacity(); i++) dstr += \" \" + bd.get(i);\r\n        debug(TAG, dstr);\r\n    }\r\n    boolean canModifyData = false;\r\n    boolean out = false;\r\n    if (data == null) {\r\n        ByteBuffer tbw;\r\n        if (maskData) {\r\n            tbw = ByteBuffer.allocate(6);\r\n            tbw.put((byte) (opcode | (finalFragment ? 0x80 : 0)));\r\n            tbw.put((byte) (0 | (maskData ? 0x80 : 0)));\r\n            tbw.putInt(0);\r\n        } else {\r\n            tbw = ByteBuffer.allocate(2);\r\n            tbw.put((byte) (opcode | (finalFragment ? 0x80 : 0)));\r\n            tbw.put((byte) (0 | (maskData ? 0x80 : 0)));\r\n        }\r\n        tbw.flip();\r\n        try {\r\n            out = this._socket.write(tbw, null, cb);\r\n        } catch (Exception e) {\r\n            if (cb != null)\r\n                cb.writeDone(e.toString());\r\n            else\r\n                this.emit(\"error\", e.toString());\r\n        }\r\n        return out;\r\n    }\r\n    if (!Util.isBuffer(data)) {\r\n        if (Util.isString(data)) {\r\n            canModifyData = true;\r\n            data = Util.chunkToBuffer(data, \"utf8\");\r\n        } else {\r\n            if (cb != null)\r\n                cb.writeDone(\"Invalid data\");\r\n            else\r\n                this.emit(\"error\", \"Invalid data\");\r\n            return out;\r\n        }\r\n    }\r\n    debug(TAG, \"frameAndSend ... 1, data:\" + data.toString());\r\n    int dataLength = Util.chunkByteLength(data, null);\r\n    int dataOffset = maskData ? 6 : 2;\r\n    int secondByte = dataLength;\r\n    if (dataLength >= 65536) {\r\n        dataOffset += 8;\r\n        secondByte = 127;\r\n    } else if (dataLength > 125) {\r\n        dataOffset += 2;\r\n        secondByte = 126;\r\n    }\r\n    boolean mergeBuffers = dataLength < 32768 || (maskData && !canModifyData);\r\n    int totalLength = mergeBuffers ? dataLength + dataOffset : dataOffset;\r\n    ByteBuffer outputBuffer = ByteBuffer.allocate(totalLength);\r\n    outputBuffer.put(0, (byte) (finalFragment ? opcode | 0x80 : opcode));\r\n    switch(secondByte) {\r\n        case 126:\r\n            outputBuffer.order(ByteOrder.BIG_ENDIAN).putShort(2, (short) dataLength);\r\n            break;\r\n        case 127:\r\n            outputBuffer.order(ByteOrder.BIG_ENDIAN).putInt(2, 0);\r\n            outputBuffer.order(ByteOrder.BIG_ENDIAN).putInt(6, dataLength);\r\n            break;\r\n    }\r\n    if (maskData) {\r\n        outputBuffer.put(1, (byte) (secondByte | 0x80));\r\n        byte[] mask = this._randomMask != null ? this._randomMask : (this._randomMask = getRandomMask());\r\n        outputBuffer.put(dataOffset - 4, mask[0]);\r\n        outputBuffer.put(dataOffset - 3, mask[1]);\r\n        outputBuffer.put(dataOffset - 2, mask[2]);\r\n        outputBuffer.put(dataOffset - 1, mask[3]);\r\n        if (mergeBuffers) {\r\n            BufferUtil.mask((ByteBuffer) data, mask, outputBuffer, dataOffset, dataLength);\r\n            try {\r\n                BufferUtil.renewBuffer(outputBuffer);\r\n                debug(TAG, \"outputBuffer 3:\" + outputBuffer);\r\n                out = this._socket.write(outputBuffer, null, cb);\r\n            } catch (Exception e) {\r\n                if (cb != null)\r\n                    cb.writeDone(e.toString());\r\n                else\r\n                    this.emit(\"error\", e.toString());\r\n            }\r\n        } else {\r\n            BufferUtil.mask((ByteBuffer) data, mask, (ByteBuffer) data, 0, dataLength);\r\n            try {\r\n                BufferUtil.renewBuffer(outputBuffer);\r\n                debug(TAG, \"outputBuffer 1:\" + outputBuffer);\r\n                this._socket.write(outputBuffer, null, null);\r\n                BufferUtil.renewBuffer((ByteBuffer) data);\r\n                debug(TAG, \"data 1:\" + (ByteBuffer) data);\r\n                out = this._socket.write(data, null, cb);\r\n            } catch (Exception e) {\r\n                if (cb != null)\r\n                    cb.writeDone(e.toString());\r\n                else\r\n                    this.emit(\"error\", e.toString());\r\n            }\r\n        }\r\n    } else {\r\n        outputBuffer.put(1, (byte) secondByte);\r\n        if (mergeBuffers) {\r\n            ByteBuffer tfc = (ByteBuffer) data;\r\n            BufferUtil.fastCopy(tfc.capacity(), tfc, outputBuffer, dataOffset);\r\n            try {\r\n                BufferUtil.renewBuffer(outputBuffer);\r\n                debug(TAG, \"outputBuffer 2:\" + outputBuffer);\r\n                out = this._socket.write(outputBuffer, null, cb);\r\n            } catch (Exception e) {\r\n                if (cb != null)\r\n                    cb.writeDone(e.toString());\r\n                else\r\n                    this.emit(\"error\", e.toString());\r\n            }\r\n        } else {\r\n            try {\r\n                BufferUtil.renewBuffer(outputBuffer);\r\n                debug(TAG, \"outputBuffer 0:\" + outputBuffer);\r\n                this._socket.write(outputBuffer, null, null);\r\n                BufferUtil.renewBuffer((ByteBuffer) data);\r\n                debug(TAG, \"data 0:\" + (ByteBuffer) data);\r\n                out = this._socket.write(data, null, cb);\r\n            } catch (Exception e) {\r\n                if (cb != null)\r\n                    cb.writeDone(e.toString());\r\n                else\r\n                    this.emit(\"error\", e.toString());\r\n            }\r\n        }\r\n    }\r\n    debug(TAG, \"frameAndSend ... 2\");\r\n    return out;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.Util.translateEGLErrorString",
	"Comment": "translates an egl error code to a string describing the error.",
	"Method": "String translateEGLErrorString(int error_code){\r\n    switch(error_code) {\r\n        case EGL_NOT_INITIALIZED:\r\n            return \"EGL not initialized\";\r\n        case EGL_BAD_ACCESS:\r\n            return \"Bad access\";\r\n        case EGL_BAD_ALLOC:\r\n            return \"Bad allocation\";\r\n        case EGL_BAD_ATTRIBUTE:\r\n            return \"Bad attribute\";\r\n        case EGL_BAD_CONFIG:\r\n            return \"Bad config\";\r\n        case EGL_BAD_CONTEXT:\r\n            return \"Bad EGL context\";\r\n        case EGL_BAD_CURRENT_SURFACE:\r\n            return \"Bad current EGL surface\";\r\n        case EGL_BAD_DISPLAY:\r\n            return \"Bad EGL display\";\r\n        case EGL_BAD_MATCH:\r\n            return \"Bad match\";\r\n        case EGL_BAD_NATIVE_PIXMAP:\r\n            return \"Bad native pixmap\";\r\n        case EGL_BAD_NATIVE_WINDOW:\r\n            return \"Bad native window\";\r\n        case EGL_BAD_PARAMETER:\r\n            return \"Bad parameter\";\r\n        case EGL_BAD_SURFACE:\r\n            return \"Bad EGL surface\";\r\n        case EGL_CONTEXT_LOST:\r\n            return \"EGL context lost\";\r\n        default:\r\n            return null;\r\n    }\r\n}"
}, {
	"Path": "com.android.volley.Request.getRetryPolicy",
	"Comment": "returns the retry policy that should be usedfor this request.",
	"Method": "RetryPolicy getRetryPolicy(){\r\n    return mRetryPolicy;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.addWordMovementListener",
	"Comment": "adds a word movement listener. a movement event is sent when the boundary of a word is needed. for example, this occurs during word next and word previous actions.",
	"Method": "void addWordMovementListener(MovementListener movementListener){\r\n    checkWidget();\r\n    if (movementListener == null)\r\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\r\n    addListener(ST.WordNext, new StyledTextListener(movementListener));\r\n    addListener(ST.WordPrevious, new StyledTextListener(movementListener));\r\n}"
}, {
	"Path": "com.openhtmltopdf.pdfboxout.quads.KongAlgo.getIndex",
	"Comment": "this is a helper function for accessing consecutive points of the polygon\tvector. it ensures that no indexoutofboundsexception occurs.",
	"Method": "int getIndex(int index,int offset){\r\n    int newindex;\r\n    if (isDebug)\r\n        System.out.println(\"size \" + points.size() + \" index:\" + index + \" offset:\" + offset);\r\n    if (index + offset >= points.size())\r\n        newindex = points.size() - (index + offset);\r\n    else {\r\n        if (index + offset < 0)\r\n            newindex = points.size() + (index + offset);\r\n        else\r\n            newindex = index + offset;\r\n    }\r\n    if (isDebug)\r\n        System.out.println(\"new index = \" + newindex);\r\n    return newindex;\r\n}"
}, {
	"Path": "io.opencensus.exporter.stats.stackdriver.StackdriverStatsExporter.createAndRegisterWithCredentialsAndProjectId",
	"Comment": "creates a stackdriverstatsexporter for an explicit project id and using explicit credentials,with default monitored resource.only one stackdriver exporter can be created.",
	"Method": "void createAndRegisterWithCredentialsAndProjectId(Credentials credentials,String projectId,Duration exportInterval){\r\n    checkNotNull(credentials, \"credentials\");\r\n    checkNotNull(projectId, \"projectId\");\r\n    checkNotNull(exportInterval, \"exportInterval\");\r\n    createInternal(credentials, projectId, exportInterval, null, null);\r\n}"
}, {
	"Path": "com.iwebpp.nodeandroid.test.ActivityInstrumentationTestCase.dont_testHttpp",
	"Comment": "fixme this has a perpetual event looptodo this should be put in a separate test",
	"Method": "void dont_testHttpp(){\r\n    String content = \"Log.d('RhinoTest', 'HttppTest, js');\";\r\n    content += \"var srv = httpp.createServer(NCC, function(req, res){\" + \"  Log.d('RhinoTest', 'httpp req.url:'+req.url()+',headers:'+req.headers());\" + \"  res.setHeader('from', 'Rhino js httpp');\" + \"  res.writeHead(200);\" + \"  res.end('httpp from js', 'utf-8', null);\" + \"});\";\r\n    content += \"srv.listen(51669, '0.0.0.0', function(){\" + \"  Log.d('RhinoTest', 'Httpp server listening on 0.0.0.0:51669');\" + \"});\";\r\n    content += \"NCC.setTimeout(function(){\" + \"  Log.d('RhinoTest', 'httpp get ...');\";\r\n    content += \"  NCC.setInterval(function(){\" + \"    Log.d('RhinoTest', 'httpp get iteration ');\";\r\n    content += \"    httpp.get(NCC, 'http://localhost:51669', function(res){\" + \"      Log.d('RhinoTest', 'httpp got response, headers:'+res.headers());\" + \"\" + \"      res.setEncoding('utf-8');\" + \"\" + \"      res.on('data', function(data){\" + \"        Log.d('RhinoTest', 'httpp:'+data.toString());\" + \"      });\" + \"    });\";\r\n    content += \"  }, 2000);\";\r\n    content += \"}, 2000);\";\r\n    runScript(content);\r\n}"
}, {
	"Path": "org.lwjgl.opengl.XRandR.restoreConfiguration",
	"Comment": "restores the configuration for all connected display devices.\tused on exit or in case of a crash to reset all devices.",
	"Method": "void restoreConfiguration(){\r\n    if (savedConfiguration != null) {\r\n        setConfiguration(true, savedConfiguration);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.states.MainMenu.musicPositionBarContains",
	"Comment": "returns true if the coordinates are within the music position bar bounds.",
	"Method": "boolean musicPositionBarContains(float cx,float cy){\r\n    return ((cx > musicBarX && cx < musicBarX + musicBarWidth) && (cy > musicBarY && cy < musicBarY + musicBarHeight));\r\n}"
}, {
	"Path": "org.lwjgl.opengles.CallbackUtil.registerContextCallbackKHR",
	"Comment": "associates the current opengl context with the specified global reference. if there\tis no context current, the global reference is deleted and an exception is thrown.\tany previous callback registrations will be cleared.",
	"Method": "void registerContextCallbackKHR(long userParam){\r\n    registerContextCallback(userParam, contextUserParamsKHR);\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix2f.mul",
	"Comment": "multiply the right matrix by the left and place the result in a third matrix.",
	"Method": "Matrix2f mul(Matrix2f left,Matrix2f right,Matrix2f dest){\r\n    if (dest == null)\r\n        dest = new Matrix2f();\r\n    float m00 = left.m00 * right.m00 + left.m10 * right.m01;\r\n    float m01 = left.m01 * right.m00 + left.m11 * right.m01;\r\n    float m10 = left.m00 * right.m10 + left.m10 * right.m11;\r\n    float m11 = left.m01 * right.m10 + left.m11 * right.m11;\r\n    dest.m00 = m00;\r\n    dest.m01 = m01;\r\n    dest.m10 = m10;\r\n    dest.m11 = m11;\r\n    return dest;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.BeatmapSetList.getNode",
	"Comment": "returns the beatmapsetnode a given number of positions forward or backwards.",
	"Method": "BeatmapSetNode getNode(BeatmapSetNode node,int shift){\r\n    BeatmapSetNode startNode = node;\r\n    if (shift > 0) {\r\n        for (int i = 0; i < shift && startNode != null; i++) startNode = startNode.next;\r\n    } else {\r\n        for (int i = 0; i < shift && startNode != null; i++) startNode = startNode.prev;\r\n    }\r\n    return startNode;\r\n}"
}, {
	"Path": "com.openhtmltopdf.layout.Layer.propagateCurrentTransformationMatrix",
	"Comment": "recursively propagates the transformation matrix. this must be done after layout of the masterbox and its children as this method relies on the box width and height for relative units in the transforms and transform origins.",
	"Method": "void propagateCurrentTransformationMatrix(CssContext c){\r\n    AffineTransform parentCtm = _parent == null ? null : _parent._ctm;\r\n    _ctm = _hasLocalTransform ? TransformCreator.createDocumentCoordinatesTransform(getMaster(), c, parentCtm) : parentCtm;\r\n    for (Layer child : getChildren()) {\r\n        child.propagateCurrentTransformationMatrix(c);\r\n    }\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.setDoubleTapZoomStyle",
	"Comment": "set the type of zoom animation to be used for double taps. see static fields.",
	"Method": "void setDoubleTapZoomStyle(int doubleTapZoomStyle){\r\n    if (!VALID_ZOOM_STYLES.contains(doubleTapZoomStyle)) {\r\n        throw new IllegalArgumentException(\"Invalid zoom style: \" + doubleTapZoomStyle);\r\n    }\r\n    this.doubleTapZoomStyle = doubleTapZoomStyle;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.AWTUtil.getPointerLocation",
	"Comment": "use reflection to access the jdk 1.5 pointer location, if possible and\tonly if the given component is on the same screen as the cursor. return\tnull otherwise.",
	"Method": "Point getPointerLocation(Component component){\r\n    try {\r\n        final GraphicsConfiguration config = component.getGraphicsConfiguration();\r\n        if (config != null) {\r\n            PointerInfo pointer_info = AccessController.doPrivileged(new PrivilegedExceptionAction<PointerInfo>() {\r\n                public PointerInfo run() throws Exception {\r\n                    return MouseInfo.getPointerInfo();\r\n                }\r\n            });\r\n            GraphicsDevice device = pointer_info.getDevice();\r\n            if (device == config.getDevice()) {\r\n                return pointer_info.getLocation();\r\n            }\r\n            return null;\r\n        }\r\n    } catch (Exception e) {\r\n        LWJGLUtil.log(\"Failed to query pointer location: \" + e.getCause());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.AWTUtil.getPointerLocation",
	"Comment": "use reflection to access the jdk 1.5 pointer location, if possible and\tonly if the given component is on the same screen as the cursor. return\tnull otherwise.",
	"Method": "Point getPointerLocation(Component component){\r\n    return MouseInfo.getPointerInfo();\r\n}"
}, {
	"Path": "ddf.minim.AudioSource.addListener",
	"Comment": "add an audiolistener to this sound generating object,\twhich will have its samples method called every time\tthis object generates a new buffer of samples.",
	"Method": "void addListener(AudioListener listener){\r\n    splitter.addListener(listener);\r\n}"
}, {
	"Path": "org.newdawn.slick.Music.setVolume",
	"Comment": "set the volume of the music as a factor of the global volume setting",
	"Method": "void setVolume(float volume){\r\n    if (volume > 1) {\r\n        volume = 1;\r\n    } else if (volume < 0) {\r\n        volume = 0;\r\n    }\r\n    this.volume = volume;\r\n    if (currentMusic == this) {\r\n        SoundStore.get().setCurrentMusicVolume(volume);\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.util.input.ControllerAdapter.getRYAxisValue",
	"Comment": "get the value from the ry axis if there is one. if no ry axis is defined\ta zero value will be returned.",
	"Method": "float getRYAxisValue(){\r\n    return 0f;\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.ImageUtil.convertToBufferedImage",
	"Comment": "utility method to convert an awt image to a bufferedimage. size is preserved, bufferedimage is compatiblewith current display device.",
	"Method": "BufferedImage convertToBufferedImage(Image awtImg,int type){\r\n    BufferedImage bimg;\r\n    if (awtImg instanceof BufferedImage) {\r\n        bimg = (BufferedImage) awtImg;\r\n    } else {\r\n        bimg = createCompatibleBufferedImage(awtImg.getWidth(null), awtImg.getHeight(null), type);\r\n        Graphics2D g = bimg.createGraphics();\r\n        g.drawImage(awtImg, 0, 0, null, null);\r\n        g.dispose();\r\n    }\r\n    return bimg;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.BeatmapParser.getDBString",
	"Comment": "returns the string object in the database for the given string.\tif none, insert the string into the database and return the original string.",
	"Method": "String getDBString(String s){\r\n    String DBString = stringdb.get(s);\r\n    if (DBString == null) {\r\n        stringdb.put(s, s);\r\n        return s;\r\n    } else\r\n        return DBString;\r\n}"
}, {
	"Path": "org.lwjgl.opencl.CLMem.getImageChannelOrder",
	"Comment": "returns the image channel order. applicable to image objects only.",
	"Method": "int getImageChannelOrder(){\r\n    return util.getImageInfoFormat(this, 0);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doSelectionCursorPrevious",
	"Comment": "moves the caret to the previous character or to the end of the previous line if the cursor is at the beginning of a line.",
	"Method": "void doSelectionCursorPrevious(){\r\n    int caretLine = getCaretLine();\r\n    int lineOffset = content.getOffsetAtLine(caretLine);\r\n    int offsetInLine = caretOffset - lineOffset;\r\n    if (offsetInLine > 0) {\r\n        int offset = getClusterPrevious(caretOffset, caretLine);\r\n        setCaretOffset(offset, OFFSET_LEADING);\r\n        showCaret();\r\n    } else if (caretLine > 0) {\r\n        caretLine--;\r\n        lineOffset = content.getOffsetAtLine(caretLine);\r\n        int offset = lineOffset + content.getLine(caretLine).length();\r\n        setCaretOffset(offset, OFFSET_LEADING);\r\n        showCaret();\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.nonvisualregressiontests.NonVisualRegressionTest.testLinkSimpleBlock",
	"Comment": "tests that a simple block link successfully links to a simple block target on second page.",
	"Method": "void testLinkSimpleBlock(){\r\n    PDDocument doc = run(\"link-simple-block\");\r\n    assertEquals(1, doc.getPage(0).getAnnotations().size());\r\n    assertThat(doc.getPage(0).getAnnotations().get(0), instanceOf(PDAnnotationLink.class));\r\n    PDAnnotationLink link = (PDAnnotationLink) doc.getPage(0).getAnnotations().get(0);\r\n    assertThat(link.getRectangle(), rectEquals(new PDRectangle(0f, 0f, 100f, 10f), 200d));\r\n    assertThat(link.getAction(), instanceOf(PDActionGoTo.class));\r\n    PDActionGoTo action = (PDActionGoTo) link.getAction();\r\n    assertThat(action.getDestination(), instanceOf(PDPageXYZDestination.class));\r\n    PDPageXYZDestination dest = (PDPageXYZDestination) action.getDestination();\r\n    assertEquals(doc.getPage(1), dest.getPage());\r\n    assertEquals(cssPixelYToPdfPoints(0, 200), dest.getTop(), 1.0d);\r\n    remove(\"link-simple-block\", doc);\r\n}"
}, {
	"Path": "io.blackbox_vision.materialcalendarview.view.CalendarView.takeStyles",
	"Comment": "method that gets and set the attributes of the calendarview class.",
	"Method": "void takeStyles(AttributeSet attrs){\r\n    final TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.MaterialCalendarView, 0, 0);\r\n    final int white = ContextCompat.getColor(getContext(), android.R.color.white);\r\n    final int black = ContextCompat.getColor(getContext(), android.R.color.black);\r\n    final int dayDisableBackground = ContextCompat.getColor(getContext(), R.color.day_disabled_background_color);\r\n    final int dayDisableTextColor = ContextCompat.getColor(getContext(), R.color.day_disabled_text_color);\r\n    final int daySelectedBackground = ContextCompat.getColor(getContext(), R.color.selected_day_background);\r\n    final int dayCurrent = ContextCompat.getColor(getContext(), R.color.current_day_of_month);\r\n    final int endColor = ContextCompat.getColor(getContext(), R.color.weekend_color);\r\n    try {\r\n        buttonBackgroundColor = a.getColor(R.styleable.MaterialCalendarView_calendarButtonBackgroundColor, black);\r\n        calendarBackgroundColor = a.getColor(R.styleable.MaterialCalendarView_calendarBackgroundColor, white);\r\n        titleBackgroundColor = a.getColor(R.styleable.MaterialCalendarView_calendarTitleBackgroundColor, white);\r\n        titleTextColor = a.getColor(R.styleable.MaterialCalendarView_calendarTitleTextColor, white);\r\n        weekBackgroundColor = a.getColor(R.styleable.MaterialCalendarView_calendarWeekBackgroundColor, white);\r\n        dayOfWeekTextColor = a.getColor(R.styleable.MaterialCalendarView_calendarDayOfWeekTextColor, dayDisableTextColor);\r\n        dayOfMonthTextColor = a.getColor(R.styleable.MaterialCalendarView_calendarDayOfMonthTextColor, black);\r\n        disabledDayBackgroundColor = a.getColor(R.styleable.MaterialCalendarView_calendarDisabledDayBackgroundColor, dayDisableBackground);\r\n        disabledDayTextColor = a.getColor(R.styleable.MaterialCalendarView_calendarDisabledDayTextColor, dayDisableTextColor);\r\n        selectedDayBackgroundColor = a.getColor(R.styleable.MaterialCalendarView_calendarSelectedDayBackgroundColor, daySelectedBackground);\r\n        selectedDayTextColor = a.getColor(R.styleable.MaterialCalendarView_calendarSelectedDayTextColor, white);\r\n        currentDayBackgroundColor = a.getColor(R.styleable.MaterialCalendarView_calendarCurrentDayBackgroundColor, dayCurrent);\r\n        currentDayTextColor = a.getColor(R.styleable.MaterialCalendarView_calendarCurrentDayTextColor, dayCurrent);\r\n        weekendTextColor = a.getColor(R.styleable.MaterialCalendarView_calendarWeekendTextColor, endColor);\r\n        weekendDays = a.getInteger(R.styleable.MaterialCalendarView_calendarWeekendDays, 0);\r\n        isOverflowDateVisible = a.getBoolean(R.styleable.MaterialCalendarView_calendarIsOverflowDatesVisible, true);\r\n        isMultiSelectDayEnabled = a.getBoolean(R.styleable.MaterialCalendarView_calendarIsMultiSelectDayEnabled, false);\r\n        backButtonDrawable = a.getResourceId(R.styleable.MaterialCalendarView_calendarBackButtonDrawable, R.drawable.ic_keyboard_arrow_left_black_24dp);\r\n        nextButtonDrawable = a.getResourceId(R.styleable.MaterialCalendarView_calendarBackButtonDrawable, R.drawable.ic_keyboard_arrow_right_black_24dp);\r\n    } finally {\r\n        if (null != a) {\r\n            a.recycle();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ui.KineticScrolling.setSpeedMultiplier",
	"Comment": "sets the multiplier for how fast the target position will be reached.",
	"Method": "void setSpeedMultiplier(float multiplier){\r\n    if (multiplier <= 0f)\r\n        throw new IllegalArgumentException(\"Speed multiplier must be above zero.\");\r\n    this.speedMultiplier = multiplier;\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.newmatch.Selector.addCondition",
	"Comment": "adds a feature to the condition attribute of the selector object",
	"Method": "void addCondition(Condition c){\r\n    if (conditions == null) {\r\n        conditions = new java.util.ArrayList<Condition>();\r\n    }\r\n    if (_pe != null) {\r\n        conditions.add(Condition.createUnsupportedCondition());\r\n        XRLog.match(Level.WARNING, \"Trying to append conditions to pseudoElement \" + _pe);\r\n    }\r\n    conditions.add(c);\r\n}"
}, {
	"Path": "io.opencensus.contrib.zpages.RpczZPageHandler.getStats",
	"Comment": "gets rpc stats by its view definition, and set it to stats snapshot.",
	"Method": "void getStats(StatsSnapshot snapshot,AggregationData data,View view,ViewData.AggregationWindowData windowData){\r\n    if (view == RPC_CLIENT_ROUNDTRIP_LATENCY_VIEW || view == RPC_SERVER_SERVER_LATENCY_VIEW) {\r\n        snapshot.avgLatencyTotal = ((DistributionData) data).getMean();\r\n    } else if (view == RPC_CLIENT_ROUNDTRIP_LATENCY_MINUTE_VIEW || view == RPC_SERVER_SERVER_LATENCY_MINUTE_VIEW) {\r\n        snapshot.avgLatencyLastMinute = ((AggregationData.MeanData) data).getMean();\r\n    } else if (view == RPC_CLIENT_ROUNDTRIP_LATENCY_HOUR_VIEW || view == RPC_SERVER_SERVER_LATENCY_HOUR_VIEW) {\r\n        snapshot.avgLatencyLastHour = ((AggregationData.MeanData) data).getMean();\r\n    } else if (view == RPC_CLIENT_ERROR_COUNT_VIEW || view == RPC_SERVER_ERROR_COUNT_VIEW) {\r\n        snapshot.errorsTotal = ((AggregationData.MeanData) data).getCount();\r\n    } else if (view == RPC_CLIENT_ERROR_COUNT_MINUTE_VIEW || view == RPC_SERVER_ERROR_COUNT_MINUTE_VIEW) {\r\n        snapshot.errorsLastMinute = ((AggregationData.MeanData) data).getCount();\r\n    } else if (view == RPC_CLIENT_ERROR_COUNT_HOUR_VIEW || view == RPC_SERVER_ERROR_COUNT_HOUR_VIEW) {\r\n        snapshot.errorsLastHour = ((AggregationData.MeanData) data).getCount();\r\n    } else if (view == RPC_CLIENT_REQUEST_BYTES_VIEW || view == RPC_SERVER_REQUEST_BYTES_VIEW) {\r\n        DistributionData distributionData = (DistributionData) data;\r\n        snapshot.inputRateTotal = distributionData.getCount() * distributionData.getMean() / BYTES_PER_KB / getDurationInSecs((ViewData.AggregationWindowData.CumulativeData) windowData);\r\n    } else if (view == RPC_CLIENT_REQUEST_BYTES_MINUTE_VIEW || view == RPC_SERVER_REQUEST_BYTES_MINUTE_VIEW) {\r\n        AggregationData.MeanData meanData = (AggregationData.MeanData) data;\r\n        snapshot.inputRateLastMinute = meanData.getMean() * meanData.getCount() / BYTES_PER_KB / SECONDS_PER_MINUTE;\r\n    } else if (view == RPC_CLIENT_REQUEST_BYTES_HOUR_VIEW || view == RPC_SERVER_REQUEST_BYTES_HOUR_VIEW) {\r\n        AggregationData.MeanData meanData = (AggregationData.MeanData) data;\r\n        snapshot.inputRateLastHour = meanData.getMean() * meanData.getCount() / BYTES_PER_KB / SECONDS_PER_HOUR;\r\n    } else if (view == RPC_CLIENT_RESPONSE_BYTES_VIEW || view == RPC_SERVER_RESPONSE_BYTES_VIEW) {\r\n        DistributionData distributionData = (DistributionData) data;\r\n        snapshot.outputRateTotal = distributionData.getCount() * distributionData.getMean() / BYTES_PER_KB / getDurationInSecs((ViewData.AggregationWindowData.CumulativeData) windowData);\r\n    } else if (view == RPC_CLIENT_RESPONSE_BYTES_MINUTE_VIEW || view == RPC_SERVER_RESPONSE_BYTES_MINUTE_VIEW) {\r\n        AggregationData.MeanData meanData = (AggregationData.MeanData) data;\r\n        snapshot.outputRateLastMinute = meanData.getMean() * meanData.getCount() / BYTES_PER_KB / SECONDS_PER_MINUTE;\r\n    } else if (view == RPC_CLIENT_RESPONSE_BYTES_HOUR_VIEW || view == RPC_SERVER_RESPONSE_BYTES_HOUR_VIEW) {\r\n        AggregationData.MeanData meanData = (AggregationData.MeanData) data;\r\n        snapshot.outputRateLastHour = meanData.getMean() * meanData.getCount() / BYTES_PER_KB / SECONDS_PER_HOUR;\r\n    } else if (view == RPC_CLIENT_STARTED_COUNT_MINUTE_VIEW || view == RPC_SERVER_STARTED_COUNT_MINUTE_VIEW) {\r\n        snapshot.countLastMinute = ((CountData) data).getCount();\r\n        snapshot.rpcRateLastMinute = snapshot.countLastMinute / SECONDS_PER_MINUTE;\r\n    } else if (view == RPC_CLIENT_STARTED_COUNT_HOUR_VIEW || view == RPC_SERVER_STARTED_COUNT_HOUR_VIEW) {\r\n        snapshot.countLastHour = ((CountData) data).getCount();\r\n        snapshot.rpcRateLastHour = snapshot.countLastHour / SECONDS_PER_HOUR;\r\n    } else if (view == RPC_CLIENT_STARTED_COUNT_CUMULATIVE_VIEW || view == RPC_SERVER_STARTED_COUNT_CUMULATIVE_VIEW) {\r\n        snapshot.countTotal = ((CountData) data).getCount();\r\n        snapshot.rpcRateTotal = snapshot.countTotal / getDurationInSecs((ViewData.AggregationWindowData.CumulativeData) windowData);\r\n    }\r\n}"
}, {
	"Path": "org.newdawn.slick.openal.SoundStore.playAsSound",
	"Comment": "play the specified buffer as a sound effect with the specified\tpitch and gain.",
	"Method": "int playAsSound(int buffer,float pitch,float gain,boolean loop){\r\n    return playAsSoundAt(buffer, pitch, gain, loop, 0, 0, 0);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.BeatmapSetList.deleteSong",
	"Comment": "deletes a song from a song group, and also deletes the beatmap file.\tif this causes the song group to be empty, then the song group and\tbeatmap directory will be deleted altogether.",
	"Method": "boolean deleteSong(BeatmapSetNode node){\r\n    if (node == null || node.beatmapIndex == -1 || node.index != expandedIndex)\r\n        return false;\r\n    int size = node.getBeatmapSet().size();\r\n    if (size == 1)\r\n        return deleteSongGroup(node);\r\n    BeatmapSetNode expandedNode = node.next;\r\n    for (int i = node.beatmapIndex + 1; i < size && expandedNode != null && expandedNode.index == node.index; i++, expandedNode = expandedNode.next) expandedNode.beatmapIndex--;\r\n    Beatmap beatmap = node.getBeatmapSet().remove(node.beatmapIndex);\r\n    mapCount--;\r\n    if (beatmap.md5Hash != null)\r\n        beatmapHashDB.remove(beatmap.md5Hash);\r\n    if (node.prev != null)\r\n        node.prev.next = node.next;\r\n    if (node.next != null)\r\n        node.next.prev = node.prev;\r\n    File file = beatmap.getFile();\r\n    BeatmapDB.delete(file.getParentFile().getName(), file.getName());\r\n    BeatmapWatchService ws = (Options.isWatchServiceEnabled()) ? BeatmapWatchService.get() : null;\r\n    if (ws != null)\r\n        ws.pause();\r\n    try {\r\n        Utils.deleteToTrash(file);\r\n    } catch (IOException e) {\r\n        ErrorHandler.error(\"Could not delete song.\", e, true);\r\n    }\r\n    if (ws != null)\r\n        ws.resume();\r\n    return true;\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.value.FSCssValue.getPrimitiveType",
	"Comment": "the type of the value as defined by the constants specified above.",
	"Method": "short getPrimitiveType(){\r\n    return primitiveType;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.db.ScoreDB.getUpdateQueries",
	"Comment": "returns a list of sql queries to apply, in order, to update from\tthe given database version to the latest version.",
	"Method": "List<String> getUpdateQueries(int version){\r\n    List<String> list = new LinkedList<String>();\r\n    if (version < 20140311)\r\n        list.add(\"ALTER TABLE scores ADD COLUMN replay TEXT\");\r\n    if (version < 20150401)\r\n        list.add(\"ALTER TABLE scores ADD COLUMN playerName TEXT\");\r\n    if (version < 20170201)\r\n        list.add(String.format(\"UPDATE scores SET playerName = '%s' WHERE playerName IS NULL\", UserList.DEFAULT_USER_NAME));\r\n    return list;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.DownloadNode.resultContains",
	"Comment": "returns true if the coordinates are within the bounds of the\tdownload result button at the given index.",
	"Method": "boolean resultContains(float cx,float cy,int index){\r\n    float y = buttonBaseY + (index * buttonOffset);\r\n    return ((cx > buttonBaseX && cx < buttonBaseX + buttonWidth) && (cy > y && cy < y + buttonHeight));\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.constants.CSSName.toString",
	"Comment": "returns a string representation of the object, in this case, always thefull css property name in lowercase.",
	"Method": "String toString(){\r\n    return this.propName;\r\n}"
}, {
	"Path": "io.opencensus.implcore.stats.MeasureToViewMap.filterExportedViews",
	"Comment": "returns the subset of the given views that should be exported",
	"Method": "Set<View> filterExportedViews(Collection<View> allViews){\r\n    Set<View> views = Sets.newHashSet();\r\n    for (View view : allViews) {\r\n        if (view.getWindow() instanceof View.AggregationWindow.Cumulative) {\r\n            views.add(view);\r\n        }\r\n    }\r\n    return Collections.unmodifiableSet(views);\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.getRequiredRotation",
	"Comment": "determines the rotation to be applied to the bitmap, based on exif orientation or chosen setting.",
	"Method": "int getRequiredRotation(){\r\n    if (orientation == ORIENTATION_USE_EXIF) {\r\n        return sOrientation;\r\n    } else {\r\n        return orientation;\r\n    }\r\n}"
}, {
	"Path": "ddf.minim.AudioRecorder.endRecord",
	"Comment": "halts the recording of audio from the current record source.",
	"Method": "void endRecord(){\r\n    recorder.endRecord();\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testHorizPageOverflowTransform",
	"Comment": "tests that content transformed past page edge generates a shadow page.",
	"Method": "void testHorizPageOverflowTransform(){\r\n    assertTrue(vt.runTest(\"horiz-page-overflow-transform\"));\r\n}"
}, {
	"Path": "com.openhtmltopdf.swing.AWTFontResolver.getFontInstanceHashName",
	"Comment": "gets the hash key for a concrete instance of a font.this incorporates size, weight, etc.",
	"Method": "String getFontInstanceHashName(SharedContext ctx,String name,float size,IdentValue weight,IdentValue style,IdentValue variant){\r\n    return name + \"-\" + (size * ctx.getTextRenderer().getFontScale()) + \"-\" + weight + \"-\" + style + \"-\" + variant;\r\n}"
}, {
	"Path": "com.joestelmach.natty.ThreadSafetyTest.validateThread",
	"Comment": "we need this method, because validatedate and validatetime are not thread safe.",
	"Method": "void validateThread(Date date,int baseMinute){\r\n    validateDate(date, 4, 4, 2012);\r\n    validateTime(date, 1, baseMinute, 0);\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.getPaddingAdvanceY",
	"Comment": "gets the additional amount to offset a line of text on the y axis.",
	"Method": "int getPaddingAdvanceY(){\r\n    return paddingAdvanceY;\r\n}"
}, {
	"Path": "org.lwjgl.input.Keyboard.getEventNanoseconds",
	"Comment": "gets the time in nanoseconds of the current event.\tonly useful for relative comparisons with other\tkeyboard events, as the absolute time has no defined\torigin.",
	"Method": "long getEventNanoseconds(){\r\n    synchronized (OpenGLPackageAccess.global_lock) {\r\n        return current_event.nanos;\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.java2d.api.Java2DRendererBuilder.toPageProcessor",
	"Comment": "output the document in paged format. the user can use the\tdefaultpageprocessor or use its source as a reference to code their own page\tprocessor for advanced usage.",
	"Method": "Java2DRendererBuilder toPageProcessor(FSPageProcessor pageProcessor){\r\n    state._pagingMode = Layer.PAGED_MODE_PRINT;\r\n    state._pageProcessor = pageProcessor;\r\n    return this;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.skins.Skin.isCursorCentered",
	"Comment": "returns whether the cursor should have an origin in the center.",
	"Method": "boolean isCursorCentered(){\r\n    return cursorCentre;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doBackspace",
	"Comment": "deletes the previous character. delete the selected text if any.move the caret in front of the deleted text.",
	"Method": "void doBackspace(){\r\n    Event event = new Event();\r\n    event.text = \"\";\r\n    if (selection.x != selection.y) {\r\n        event.start = selection.x;\r\n        event.end = selection.y;\r\n        sendKeyEvent(event);\r\n    } else if (caretOffset > 0) {\r\n        int lineIndex = content.getLineAtOffset(caretOffset);\r\n        int lineOffset = content.getOffsetAtLine(lineIndex);\r\n        if (caretOffset == lineOffset) {\r\n            lineOffset = content.getOffsetAtLine(lineIndex - 1);\r\n            event.start = lineOffset + content.getLine(lineIndex - 1).length();\r\n            event.end = caretOffset;\r\n        } else {\r\n            boolean isSurrogate = false;\r\n            String lineText = content.getLine(lineIndex);\r\n            char ch = lineText.charAt(caretOffset - lineOffset - 1);\r\n            if (0xDC00 <= ch && ch <= 0xDFFF) {\r\n                if (caretOffset - lineOffset - 2 >= 0) {\r\n                    ch = lineText.charAt(caretOffset - lineOffset - 2);\r\n                    isSurrogate = 0xD800 <= ch && ch <= 0xDBFF;\r\n                }\r\n            }\r\n            TextLayout layout = renderer.getTextLayout(lineIndex);\r\n            int start = layout.getPreviousOffset(caretOffset - lineOffset, isSurrogate ? SWT.MOVEMENT_CLUSTER : SWT.MOVEMENT_CHAR);\r\n            renderer.disposeTextLayout(layout);\r\n            event.start = start + lineOffset;\r\n            event.end = caretOffset;\r\n        }\r\n        sendKeyEvent(event);\r\n    }\r\n}"
}, {
	"Path": "orestes.bloomfilter.FilterBuilder.falsePositiveProbability",
	"Comment": "sets the tolerable false positive probability. in combination with the number of expected elements, this is usedto infer the optimal size and optimal number of hash functions of the filter.",
	"Method": "FilterBuilder falsePositiveProbability(double falsePositiveProbability,double falsePositiveProbability){\r\n    return falsePositiveProbability;\r\n}"
}, {
	"Path": "io.opencensus.common.Timestamp.create",
	"Comment": "creates a new timestamp from given seconds and nanoseconds.",
	"Method": "Timestamp create(long seconds,int nanos){\r\n    if (seconds < -MAX_SECONDS) {\r\n        throw new IllegalArgumentException(\"'seconds' is less than minimum (\" + -MAX_SECONDS + \"): \" + seconds);\r\n    }\r\n    if (seconds > MAX_SECONDS) {\r\n        throw new IllegalArgumentException(\"'seconds' is greater than maximum (\" + MAX_SECONDS + \"): \" + seconds);\r\n    }\r\n    if (nanos < 0) {\r\n        throw new IllegalArgumentException(\"'nanos' is less than zero: \" + nanos);\r\n    }\r\n    if (nanos > MAX_NANOS) {\r\n        throw new IllegalArgumentException(\"'nanos' is greater than maximum (\" + MAX_NANOS + \"): \" + nanos);\r\n    }\r\n    return new AutoValue_Timestamp(seconds, nanos);\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.value.FSCssValue.setFloatValue",
	"Comment": "not supported, class is immutable. a method to set the float value with aspecified unit.",
	"Method": "void setFloatValue(short unitType,float floatValue){\r\n    throw new XRRuntimeException(\"FSCssValue is immutable.\");\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testRtlPageOverflowHiddenHidden",
	"Comment": "tests that blocks with overflow hidden work correctly on overflow pages.",
	"Method": "void testRtlPageOverflowHiddenHidden(){\r\n    assertTrue(vt.runTest(\"rtl-page-overflow-hidden-hidden\"));\r\n}"
}, {
	"Path": "org.lwjgl.test.openal.EFX10Test.silentTests",
	"Comment": "runs a series of api calls similar to the tutorials in the effects extension guide of theopenal sdk. nothing is played in this method.",
	"Method": "void silentTests(){\r\n    setupEfx();\r\n    final ALCdevice device = AL.getDevice();\r\n    final IntBuffer contextAttribList = BufferUtils.createIntBuffer(8);\r\n    contextAttribList.put(ALC10.ALC_FREQUENCY);\r\n    contextAttribList.put(44100);\r\n    contextAttribList.put(ALC10.ALC_REFRESH);\r\n    contextAttribList.put(60);\r\n    contextAttribList.put(ALC10.ALC_SYNC);\r\n    contextAttribList.put(ALC10.ALC_FALSE);\r\n    contextAttribList.rewind();\r\n    contextAttribList.put(EFX10.ALC_MAX_AUXILIARY_SENDS);\r\n    contextAttribList.put(2);\r\n    final ALCcontext newContext = ALC10.alcCreateContext(device, contextAttribList);\r\n    if (newContext == null) {\r\n        throw new Exception(\"Failed to create context.\");\r\n    }\r\n    final int contextCurResult = ALC10.alcMakeContextCurrent(newContext);\r\n    if (contextCurResult == ALC10.ALC_FALSE) {\r\n        throw new Exception(\"Failed to make context current.\");\r\n    }\r\n    System.out.println(\"AL_VERSION: \" + AL10.alGetString(AL10.AL_VERSION));\r\n    final IntBuffer buff = BufferUtils.createIntBuffer(1);\r\n    ALC10.alcGetInteger(device, EFX10.ALC_EFX_MAJOR_VERSION, buff);\r\n    System.out.println(\"ALC_EFX_MAJOR_VERSION: \" + buff.get(0));\r\n    ALC10.alcGetInteger(device, EFX10.ALC_EFX_MINOR_VERSION, buff);\r\n    System.out.println(\"ALC_EFX_MINOR_VERSION: \" + buff.get(0));\r\n    ALC10.alcGetInteger(device, EFX10.ALC_MAX_AUXILIARY_SENDS, buff);\r\n    final int maxAuxSends = buff.get(0);\r\n    System.out.println(\"ALC_MAX_AUXILIARY_SENDS: \" + maxAuxSends);\r\n    int numAuxSlots = 0;\r\n    final int[] auxEffectSlots = new int[4];\r\n    AL10.alGetError();\r\n    for (numAuxSlots = 0; numAuxSlots < 4; numAuxSlots++) {\r\n        auxEffectSlots[numAuxSlots] = EFX10.alGenAuxiliaryEffectSlots();\r\n        if (AL10.alGetError() != AL10.AL_NO_ERROR) {\r\n            break;\r\n        }\r\n    }\r\n    System.out.println(\"Created \" + numAuxSlots + \" aux effect slots.\");\r\n    int numEffects = 0;\r\n    final int[] effects = new int[2];\r\n    for (numEffects = 0; numEffects < 2; numEffects++) {\r\n        effects[numEffects] = EFX10.alGenEffects();\r\n        if (AL10.alGetError() != AL10.AL_NO_ERROR) {\r\n            break;\r\n        }\r\n    }\r\n    System.out.println(\"Created \" + numEffects + \" effects.\");\r\n    AL10.alGetError();\r\n    if (EFX10.alIsEffect(effects[0])) {\r\n        EFX10.alEffecti(effects[0], EFX10.AL_EFFECT_TYPE, EFX10.AL_EFFECT_REVERB);\r\n        if (AL10.alGetError() != AL10.AL_NO_ERROR) {\r\n            System.out.println(\"Reverb effect not supported.\");\r\n        } else {\r\n            EFX10.alEffectf(effects[0], EFX10.AL_REVERB_DECAY_TIME, 5.0f);\r\n            System.out.println(\"Reverb effect created.\");\r\n        }\r\n    } else {\r\n        throw new Exception(\"First effect not a valid effect.\");\r\n    }\r\n    AL10.alGetError();\r\n    if (EFX10.alIsEffect(effects[1])) {\r\n        EFX10.alEffecti(effects[1], EFX10.AL_EFFECT_TYPE, EFX10.AL_EFFECT_FLANGER);\r\n        if (AL10.alGetError() != AL10.AL_NO_ERROR) {\r\n            System.out.println(\"Flanger effect not support.\");\r\n        } else {\r\n            EFX10.alEffecti(effects[1], EFX10.AL_FLANGER_PHASE, 180);\r\n            System.out.println(\"Flanger effect created.\");\r\n        }\r\n    } else {\r\n        throw new Exception(\"Second effect not a valid effect.\");\r\n    }\r\n    AL10.alGetError();\r\n    final int filter = EFX10.alGenFilters();\r\n    if (AL10.alGetError() != AL10.AL_NO_ERROR) {\r\n        throw new Exception(\"Failed to create filter.\");\r\n    }\r\n    System.out.println(\"Generated a filter.\");\r\n    if (EFX10.alIsFilter(filter)) {\r\n        EFX10.alFilteri(filter, EFX10.AL_FILTER_TYPE, EFX10.AL_FILTER_LOWPASS);\r\n        if (AL10.alGetError() != AL10.AL_NO_ERROR) {\r\n            System.out.println(\"Low pass filter not supported.\");\r\n        } else {\r\n            EFX10.alFilterf(filter, EFX10.AL_LOWPASS_GAIN, 0.5f);\r\n            EFX10.alFilterf(filter, EFX10.AL_LOWPASS_GAINHF, 0.5f);\r\n            System.out.println(\"Low pass filter created.\");\r\n        }\r\n    }\r\n    AL10.alGetError();\r\n    EFX10.alAuxiliaryEffectSloti(auxEffectSlots[0], EFX10.AL_EFFECTSLOT_EFFECT, effects[0]);\r\n    if (AL10.alGetError() != AL10.AL_NO_ERROR) {\r\n        throw new Exception(\"Failed to attach effect to aux effect slot.\");\r\n    }\r\n    System.out.println(\"Successfully loaded effect into effect slot.\");\r\n    final int source = AL10.alGenSources();\r\n    AL11.alSource3i(source, EFX10.AL_AUXILIARY_SEND_FILTER, auxEffectSlots[0], 0, EFX10.AL_FILTER_NULL);\r\n    if (AL10.alGetError() != AL10.AL_NO_ERROR) {\r\n        throw new Exception(\"Failed to configure Source Send 0\");\r\n    }\r\n    System.out.println(\"Linked aux effect slot to soutce slot 0\");\r\n    AL11.alSource3i(source, EFX10.AL_AUXILIARY_SEND_FILTER, auxEffectSlots[1], 1, filter);\r\n    if (AL10.alGetError() != AL10.AL_NO_ERROR) {\r\n        throw new Exception(\"Failed to configure Source Send 1\");\r\n    }\r\n    System.out.println(\"Linked aux effect slot to soutce slot 1\");\r\n    AL11.alSource3i(source, EFX10.AL_AUXILIARY_SEND_FILTER, EFX10.AL_EFFECTSLOT_NULL, 0, EFX10.AL_FILTER_NULL);\r\n    if (AL10.alGetError() != AL10.AL_NO_ERROR) {\r\n        throw new Exception(\"Failed to disable Source Send 0\");\r\n    }\r\n    System.out.println(\"Disabled source send 0\");\r\n    AL11.alSource3i(source, EFX10.AL_AUXILIARY_SEND_FILTER, EFX10.AL_EFFECTSLOT_NULL, 1, EFX10.AL_FILTER_NULL);\r\n    if (AL10.alGetError() != AL10.AL_NO_ERROR) {\r\n        throw new Exception(\"Failed to disable Source Send 1\");\r\n    }\r\n    System.out.println(\"Disabled source send 1\");\r\n    AL10.alSourcei(source, EFX10.AL_DIRECT_FILTER, filter);\r\n    if (AL10.alGetError() == AL10.AL_NO_ERROR) {\r\n        {\r\n            System.out.println(\"Successfully applied a direct path filter\");\r\n            AL10.alSourcei(source, EFX10.AL_DIRECT_FILTER, EFX10.AL_FILTER_NULL);\r\n            if (AL10.alGetError() == AL10.AL_NO_ERROR) {\r\n                System.out.println(\"Successfully removed direct filter\");\r\n            }\r\n        }\r\n        AL11.alSource3i(source, EFX10.AL_AUXILIARY_SEND_FILTER, auxEffectSlots[0], 0, filter);\r\n        if (AL10.alGetError() == AL10.AL_NO_ERROR) {\r\n            {\r\n                System.out.println(\"Successfully applied aux send filter\");\r\n                AL11.alSource3i(source, EFX10.AL_AUXILIARY_SEND_FILTER, auxEffectSlots[0], 0, EFX10.AL_FILTER_NULL);\r\n                if (AL10.alGetError() == AL10.AL_NO_ERROR) {\r\n                    System.out.println(\"Successfully removed filter\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n    AL10.alSourcef(source, EFX10.AL_CONE_OUTER_GAINHF, 0.5f);\r\n    if (AL10.alGetError() == AL10.AL_NO_ERROR) {\r\n        System.out.println(\"Successfully set cone outside gain filter\");\r\n    }\r\n    AL10.alListenerf(EFX10.AL_METERS_PER_UNIT, 0.3f);\r\n    if (AL10.alGetError() == AL10.AL_NO_ERROR) {\r\n        System.out.println(\"Successfully set distance units\");\r\n    }\r\n    final IntBuffer auxEffectSlotsBuf = (IntBuffer) BufferUtils.createIntBuffer(auxEffectSlots.length).put(auxEffectSlots).rewind();\r\n    EFX10.alDeleteAuxiliaryEffectSlots(auxEffectSlotsBuf);\r\n    final IntBuffer effectsBuf = (IntBuffer) BufferUtils.createIntBuffer(effects.length).put(effects).rewind();\r\n    EFX10.alDeleteEffects(effectsBuf);\r\n    EFX10.alDeleteFilters(filter);\r\n    AL.destroy();\r\n}"
}, {
	"Path": "com.j256.ormlite.dao.DaoManager.lookupDao",
	"Comment": "helper method to lookup a dao if it has already been associated with the class. otherwise this returns null.",
	"Method": "D lookupDao(ConnectionSource connectionSource,Class<T> clazz,D lookupDao,ConnectionSource connectionSource,DatabaseTableConfig<T> tableConfig,Dao<?, ?> lookupDao,ClassConnectionSource key,Dao<?, ?> lookupDao,TableConfigConnectionSource key){\r\n    if (tableConfigMap == null) {\r\n        tableConfigMap = new HashMap<TableConfigConnectionSource, Dao<?, ?>>();\r\n    }\r\n    Dao<?, ?> dao = tableConfigMap.get(key);\r\n    if (dao == null) {\r\n        return null;\r\n    } else {\r\n        return dao;\r\n    }\r\n}"
}, {
	"Path": "com.nbsp.materialfilepicker.MaterialFilePicker.start",
	"Comment": "open material file picker activity.you should set activity or fragment before calling this method",
	"Method": "void start(){\r\n    if (mActivity == null && mFragment == null && mSupportFragment == null) {\r\n        throw new RuntimeException(\"You must pass Activity/Fragment by calling withActivity/withFragment/withSupportFragment method\");\r\n    }\r\n    if (mRequestCode == null) {\r\n        throw new RuntimeException(\"You must pass request code by calling withRequestCode method\");\r\n    }\r\n    Intent intent = getIntent();\r\n    if (mActivity != null) {\r\n        mActivity.startActivityForResult(intent, mRequestCode);\r\n    } else if (mFragment != null) {\r\n        mFragment.startActivityForResult(intent, mRequestCode);\r\n    } else {\r\n        mSupportFragment.startActivityForResult(intent, mRequestCode);\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.context.StyleReference.getPseudoElementStyle",
	"Comment": "gets the pseudoelementstyle attribute of the stylereference object",
	"Method": "CascadedStyle getPseudoElementStyle(Node node,String pseudoElement){\r\n    Element e = null;\r\n    if (node.getNodeType() == Node.ELEMENT_NODE) {\r\n        e = (Element) node;\r\n    } else {\r\n        e = (Element) node.getParentNode();\r\n    }\r\n    return _matcher.getPECascadedStyle(e, pseudoElement);\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix2f.add",
	"Comment": "add two matrices together and place the result in a third matrix.",
	"Method": "Matrix2f add(Matrix2f left,Matrix2f right,Matrix2f dest){\r\n    if (dest == null)\r\n        dest = new Matrix2f();\r\n    dest.m00 = left.m00 + right.m00;\r\n    dest.m01 = left.m01 + right.m01;\r\n    dest.m10 = left.m10 + right.m10;\r\n    dest.m11 = left.m11 + right.m11;\r\n    return dest;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ui.animations.AnimatedValue.updateValue",
	"Comment": "recalculates the value by applying the animation equation with the current time.",
	"Method": "void updateValue(){\r\n    float t = eqn.calc((float) time / duration);\r\n    this.value = base + (t * diff);\r\n}"
}, {
	"Path": "org.lwjgl.opengl.PixelFormat.withStereo",
	"Comment": "returns a new pixelformat object with the same properties as this pixelformat and the new stereo value.",
	"Method": "PixelFormat withStereo(boolean stereo){\r\n    final PixelFormat pf = new PixelFormat(this);\r\n    pf.stereo = stereo;\r\n    return pf;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.DownloadNode.downloadAreaContains",
	"Comment": "returns true if the coordinates are within the bounds of the\tdownload information button area.",
	"Method": "boolean downloadAreaContains(float cx,float cy){\r\n    return ((cx > infoBaseX && cx <= containerWidth) && (cy > infoBaseY && cy < infoBaseY + infoHeight * maxDownloadsShown));\r\n}"
}, {
	"Path": "ddf.minim.Controller.isShiftingVolume",
	"Comment": "returns true if the volume is currently shifting.if no volume control is available this method returns false.",
	"Method": "boolean isShiftingVolume(){\r\n    return vshift;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.GLContext.initNativeStubs",
	"Comment": "helper method to contextcapabilities. it will try to initialize the native stubs,\tand remove the given extension name from the extension set if the initialization fails.",
	"Method": "void initNativeStubs(Class extension_class,Set<String> supported_extensions,String ext_name){\r\n    if (supported_extensions.contains(ext_name)) {\r\n        try {\r\n            doInitNativeStubs(extension_class);\r\n        } catch (LWJGLException e) {\r\n            LWJGLUtil.log(\"Failed to initialize extension \" + extension_class + \" - exception: \" + e);\r\n            supported_extensions.remove(ext_name);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.context.StandardAttributeResolver.getClass",
	"Comment": "gets the class attribute of the standardattributeresolver object",
	"Method": "String getClass(Object e){\r\n    return nsh.getClass((Element) e);\r\n}"
}, {
	"Path": "com.openhtmltopdf.pdfboxout.quads.KongAlgo.isConvex",
	"Comment": "returns true if the point p2 is convex considered the actual polygon. p1, p2\tand p3 are three consecutive points of the polygon.",
	"Method": "boolean isConvex(Point2D.Float p1,Point2D.Float p2,Point2D.Float p3){\r\n    Point2D.Float v = new Point2D.Float(p2.x - p1.x, p2.y - p1.y);\r\n    float res = p3.x * v.y - p3.y * v.x + v.x * p1.y - v.y * p1.x;\r\n    return !((res > 0 && isCw) || (res <= 0 && !isCw));\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.getStartValue",
	"Comment": "get the displacement value from the last time setcurrentvalue was called.",
	"Method": "double getStartValue(){\r\n    return mStartValue;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.GLContext.getPlatformSpecificFunctionAddress",
	"Comment": "helper method to get a pointer to a named function in the opengl library\twith a name dependent on the current platform",
	"Method": "long getPlatformSpecificFunctionAddress(String function_prefix,String[] os_prefixes,String[] os_function_prefixes,String function){\r\n    String os_name = AccessController.doPrivileged(new PrivilegedAction<String>() {\r\n        public String run() {\r\n            return System.getProperty(\"os.name\");\r\n        }\r\n    });\r\n    for (int i = 0; i < os_prefixes.length; i++) if (os_name.startsWith(os_prefixes[i])) {\r\n        String platform_function_name = function.replaceFirst(function_prefix, os_function_prefixes[i]);\r\n        long address = getFunctionAddress(platform_function_name);\r\n        return address;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.GLContext.getPlatformSpecificFunctionAddress",
	"Comment": "helper method to get a pointer to a named function in the opengl library\twith a name dependent on the current platform",
	"Method": "long getPlatformSpecificFunctionAddress(String function_prefix,String[] os_prefixes,String[] os_function_prefixes,String function){\r\n    return System.getProperty(\"os.name\");\r\n}"
}, {
	"Path": "orestes.bloomfilter.redis.CountingBloomFilterRedis.addAndEstimateCountRaw",
	"Comment": "adds all elements to the bloom filter and returns the estimated count of the inserted elements.",
	"Method": "long addAndEstimateCountRaw(byte[] element,List<Long> addAndEstimateCountRaw,Collection<T> elements){\r\n    List<int[]> allHashes = elements.stream().map(el -> hash(toBytes(el))).collect(toList());\r\n    List<Object> results = pool.transactionallyRetry(p -> {\r\n        for (int[] hashes : allHashes) {\r\n            for (int position : hashes) {\r\n                bloom.set(p, position, true);\r\n            }\r\n        }\r\n        for (int[] hashes : allHashes) {\r\n            for (int position : hashes) {\r\n                p.hincrBy(keys.COUNTS_KEY.getBytes(), RedisUtils.encodeKey(position), 1);\r\n            }\r\n        }\r\n    }, keys.BITS_KEY, keys.COUNTS_KEY);\r\n    List<Long> mins = new LinkedList();\r\n    for (int i = results.size() / 2; i < results.size(); i += config().hashes()) {\r\n        long min = results.subList(i, i + config().hashes()).stream().map(val -> (Long) val).min(Comparator.<Long>naturalOrder()).get();\r\n        mins.add(min);\r\n    }\r\n    return mins;\r\n}"
}, {
	"Path": "com.facebook.rebound.Spring.setAtRest",
	"Comment": "set the spring to be at rest by making its end value equal to its current value and settingvelocity to 0.",
	"Method": "Spring setAtRest(){\r\n    mEndValue = mCurrentState.position;\r\n    mTempState.position = mCurrentState.position;\r\n    mCurrentState.velocity = 0;\r\n    return this;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.PixelFormat.withAuxBuffers",
	"Comment": "returns a new pixelformat object with the same properties as this pixelformat and the new auxiliary buffers value.",
	"Method": "PixelFormat withAuxBuffers(int num_aux_buffers){\r\n    if (num_aux_buffers < 0)\r\n        throw new IllegalArgumentException(\"Invalid number of auxiliary buffers specified: \" + num_aux_buffers);\r\n    final PixelFormat pf = new PixelFormat(this);\r\n    pf.num_aux_buffers = num_aux_buffers;\r\n    return pf;\r\n}"
}, {
	"Path": "ddf.minim.ugens.LiveInput.close",
	"Comment": "calling close will close the audiostream that this wraps, \twhich is proper cleanup for using the stream.",
	"Method": "void close(){\r\n    mInputStream.close();\r\n}"
}, {
	"Path": "org.newdawn.slick.openal.SoundStore.playAsSoundAt",
	"Comment": "play the specified buffer as a sound effect with the specified\tpitch and gain.",
	"Method": "int playAsSoundAt(int buffer,float pitch,float gain,boolean loop,float x,float y,float z){\r\n    gain *= soundVolume;\r\n    if (gain == 0) {\r\n        gain = 0.001f;\r\n    }\r\n    if (soundWorks) {\r\n        if (sounds) {\r\n            int nextSource = findFreeSource();\r\n            if (nextSource == -1) {\r\n                return -1;\r\n            }\r\n            AL10.alSourceStop(sources.get(nextSource));\r\n            AL10.alSourcei(sources.get(nextSource), AL10.AL_BUFFER, buffer);\r\n            AL10.alSourcef(sources.get(nextSource), AL10.AL_PITCH, pitch);\r\n            AL10.alSourcef(sources.get(nextSource), AL10.AL_GAIN, gain);\r\n            AL10.alSourcei(sources.get(nextSource), AL10.AL_LOOPING, loop ? AL10.AL_TRUE : AL10.AL_FALSE);\r\n            sourcePos.clear();\r\n            sourceVel.clear();\r\n            sourceVel.put(new float[] { 0, 0, 0 });\r\n            sourcePos.put(new float[] { x, y, z });\r\n            sourcePos.flip();\r\n            sourceVel.flip();\r\n            AL10.alSource(sources.get(nextSource), AL10.AL_POSITION, sourcePos);\r\n            AL10.alSource(sources.get(nextSource), AL10.AL_VELOCITY, sourceVel);\r\n            AL10.alSourcePlay(sources.get(nextSource));\r\n            return nextSource;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.openhtmltopdf.outputdevice.helper.BaseRendererBuilder.testMode",
	"Comment": "whether to use test mode and output the pdf uncompressed. turned off by\tdefault.",
	"Method": "TFinalClass testMode(boolean mode){\r\n    state._testMode = mode;\r\n    return (TFinalClass) this;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.audio.MusicController.reset",
	"Comment": "completely resets musiccontroller state.\tstops the current track, cancels track conversions, erases\ttemporary files, releases openal sources, and resets state.",
	"Method": "void reset(){\r\n    stop();\r\n    if (isTrackLoading()) {\r\n        trackLoader.interrupt();\r\n        try {\r\n            trackLoader.join();\r\n        } catch (InterruptedException e) {\r\n            ErrorHandler.error(null, e, true);\r\n        }\r\n    }\r\n    trackLoader = null;\r\n    lastBeatmap = null;\r\n    duration = 0;\r\n    trackEnded = false;\r\n    themePlaying = false;\r\n    pauseTime = 0f;\r\n    trackDimmed = false;\r\n    resetTimingPoint();\r\n    destroyOpenAL();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.DownloadNode.resultAreaContains",
	"Comment": "returns true if the coordinates are within the bounds of the\tdownload result button area.",
	"Method": "boolean resultAreaContains(float cx,float cy){\r\n    return ((cx > buttonBaseX && cx < buttonBaseX + buttonWidth) && (cy > buttonBaseY && cy < buttonBaseY + buttonOffset * maxResultsShown));\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.getPaddingTop",
	"Comment": "returns the padding above a glyph on the glyphpage to allow for effects to be drawn.",
	"Method": "int getPaddingTop(){\r\n    return paddingTop;\r\n}"
}, {
	"Path": "ddf.minim.Minim.loadMetaData",
	"Comment": "load the metadata for the file without keeping a stream open. \tuse this to get access to id3 tags or similar.",
	"Method": "AudioMetaData loadMetaData(String filename){\r\n    AudioRecordingStream stream = mimp.getAudioRecordingStream(filename, 0, false);\r\n    AudioMetaData data = stream.getMetaData();\r\n    stream.close();\r\n    return data;\r\n}"
}, {
	"Path": "com.j256.ormlite.stmt.StatementExecutor.updateId",
	"Comment": "update an object in the database to change its id to the newid parameter.",
	"Method": "int updateId(DatabaseConnection databaseConnection,T data,ID newId,ObjectCache objectCache){\r\n    if (mappedUpdateId == null) {\r\n        mappedUpdateId = MappedUpdateId.build(databaseType, tableInfo);\r\n    }\r\n    int result = mappedUpdateId.execute(databaseConnection, data, newId, objectCache);\r\n    if (dao != null && !localIsInBatchMode.get()) {\r\n        dao.notifyChanges();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.android.volley.Request.cancel",
	"Comment": "mark this request as canceled.no callback will be delivered.",
	"Method": "void cancel(){\r\n    mCanceled = true;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doSelectionCursorNext",
	"Comment": "moves the caret to the next character or to the beginning of the next line if the cursor is at the end of a line.",
	"Method": "void doSelectionCursorNext(){\r\n    int caretLine = getCaretLine();\r\n    int lineOffset = content.getOffsetAtLine(caretLine);\r\n    int offsetInLine = caretOffset - lineOffset;\r\n    int offset, alignment;\r\n    if (offsetInLine < content.getLine(caretLine).length()) {\r\n        TextLayout layout = renderer.getTextLayout(caretLine);\r\n        offsetInLine = layout.getNextOffset(offsetInLine, SWT.MOVEMENT_CLUSTER);\r\n        int lineStart = layout.getLineOffsets()[layout.getLineIndex(offsetInLine)];\r\n        renderer.disposeTextLayout(layout);\r\n        offset = offsetInLine + lineOffset;\r\n        alignment = offsetInLine == lineStart ? OFFSET_LEADING : PREVIOUS_OFFSET_TRAILING;\r\n        setCaretOffset(offset, alignment);\r\n        showCaret();\r\n    } else if (caretLine < content.getLineCount() - 1 && !isSingleLine()) {\r\n        caretLine++;\r\n        offset = content.getOffsetAtLine(caretLine);\r\n        alignment = PREVIOUS_OFFSET_TRAILING;\r\n        setCaretOffset(offset, alignment);\r\n        showCaret();\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.replay.ReplayImporter.getCurrentFileName",
	"Comment": "returns the name of the current file being imported, or null if none.",
	"Method": "String getCurrentFileName(){\r\n    if (files == null || fileIndex == -1)\r\n        return null;\r\n    return files[fileIndex].getName();\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.Updater.setUpdateInfo",
	"Comment": "sets the version information if the program was just updated.",
	"Method": "void setUpdateInfo(String fromVersion,String toVersion){\r\n    this.updatedFromVersion = fromVersion;\r\n    this.updatedToVersion = toVersion;\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.setPaddingTop",
	"Comment": "sets the padding above a glyph on the glyphpage to allow for effects to be drawn.",
	"Method": "void setPaddingTop(int paddingTop){\r\n    this.paddingTop = paddingTop;\r\n}"
}, {
	"Path": "ddf.minim.ugens.Waves.pulse",
	"Comment": "constructs a perfect square wave with the specified duty cycle.",
	"Method": "Wavetable pulse(float dutyCycle){\r\n    dutyCycle = Math.max(0, Math.min(dutyCycle, 1));\r\n    return WavetableGenerator.gen7(tableSize, new float[] { -1, -1, 1, 1 }, new int[] { (int) (dutyCycle * tableSize), 0, tableSize - (int) (dutyCycle * tableSize) });\r\n}"
}, {
	"Path": "ddf.minim.effects.IIRFilter.printCoeff",
	"Comment": "prints the current values of the coefficients to the console.",
	"Method": "void printCoeff(){\r\n    System.out.println(\"Filter coefficients: \");\r\n    if (a != null) {\r\n        for (int i = 0; i < a.length; i++) {\r\n            System.out.print(\"  A\" + i + \": \" + a[i]);\r\n        }\r\n    }\r\n    System.out.println();\r\n    if (b != null) {\r\n        for (int i = 0; i < b.length; i++) {\r\n            System.out.print(\"  B\" + (i + 1) + \": \" + b[i]);\r\n        }\r\n        System.out.println();\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.input.Mouse.isInsideWindow",
	"Comment": "retrieves whether or not the mouse cursor is within the bounds of the window.if the mouse cursor was moved outside the display during a drag, then the result of callingthis method will be true until the button is released.",
	"Method": "boolean isInsideWindow(){\r\n    return implementation.isInsideWindow();\r\n}"
}, {
	"Path": "ddf.minim.MultiChannelBuffer.setSample",
	"Comment": "sets the value of a sample in the given channel at the given\toffset from the beginning of the buffer.",
	"Method": "void setSample(int channelNumber,int sampleIndex,float value){\r\n    channels[channelNumber][sampleIndex] = value;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getLineDelimiter",
	"Comment": "returns the line delimiter used for entering new lines by key downor paste operation.",
	"Method": "String getLineDelimiter(){\r\n    checkWidget();\r\n    return content.getLineDelimiter();\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.setDoubleTapZoomStyle",
	"Comment": "set the type of zoom animation to be used for double taps. see static fields.",
	"Method": "void setDoubleTapZoomStyle(int doubleTapZoomStyle){\r\n    if (!VALID_ZOOM_STYLES.contains(doubleTapZoomStyle)) {\r\n        throw new IllegalArgumentException(\"Invalid zoom style: \" + doubleTapZoomStyle);\r\n    }\r\n    this.doubleTapZoomStyle = doubleTapZoomStyle;\r\n}"
}, {
	"Path": "ddf.minim.AudioPlayer.isLooping",
	"Comment": "returns true if the audioplayer is currently playingand has more than one loop left to play.",
	"Method": "boolean isLooping(){\r\n    return recording.getLoopCount() != 0;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getBlockSelectionBounds",
	"Comment": "returns the block selection bounds. the bounds is relative to the upper left corner of the document.",
	"Method": "Rectangle getBlockSelectionBounds(){\r\n    Rectangle rect;\r\n    if (blockSelection && blockXLocation != -1) {\r\n        rect = getBlockSelectionRectangle();\r\n    } else {\r\n        Point startPoint = getPointAtOffset(selection.x);\r\n        Point endPoint = getPointAtOffset(selection.y);\r\n        int height = getLineHeight(selection.y);\r\n        rect = new Rectangle(startPoint.x, startPoint.y, endPoint.x - startPoint.x, endPoint.y + height - startPoint.y);\r\n        if (selection.x == selection.y) {\r\n            rect.width = getCaretWidth();\r\n        }\r\n    }\r\n    rect.x += horizontalScrollOffset;\r\n    rect.y += getVerticalScrollOffset();\r\n    return rect;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.Options.isMouseDisabled",
	"Comment": "returns whether or not the mouse buttons are disabled during gameplay.",
	"Method": "boolean isMouseDisabled(){\r\n    return GameOption.DISABLE_MOUSE_BUTTONS.getBooleanValue();\r\n}"
}, {
	"Path": "com.j256.ormlite.table.DatabaseTableConfig.getConstructor",
	"Comment": "return the constructor for this class. if not constructor has been set on the class then it will be found on the\tclass through reflection.",
	"Method": "Constructor<T> getConstructor(){\r\n    if (constructor == null) {\r\n        constructor = findNoArgConstructor(dataClass);\r\n    }\r\n    return constructor;\r\n}"
}, {
	"Path": "ddf.minim.Controller.isShiftingPan",
	"Comment": "returns true if the pan is currently shifting.if no gain control is available this method returns false.",
	"Method": "boolean isShiftingPan(){\r\n    return pshift;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.Beatmap.isBackgroundLoading",
	"Comment": "returns whether the beatmap background image is currently loading.",
	"Method": "boolean isBackgroundLoading(){\r\n    if (bg == null)\r\n        return false;\r\n    ImageLoader imageLoader = bgImageCache.get(bg);\r\n    return (imageLoader != null && imageLoader.isLoading());\r\n}"
}, {
	"Path": "orestes.bloomfilter.memory.CountingBloomFilterMemory.decrement",
	"Comment": "decrements the internal counter upon deletion and unsets the bloom filter bit if necessary.",
	"Method": "long decrement(int index){\r\n    int low = index * config().countingBits();\r\n    int high = (index + 1) * config().countingBits();\r\n    boolean decremented = false;\r\n    boolean nonZero = false;\r\n    long count = 0;\r\n    int pos = 0;\r\n    for (int i = (high - 1); i >= low; i--) {\r\n        if (!decremented) {\r\n            if (counts.get(i)) {\r\n                counts.set(i, false);\r\n                decremented = true;\r\n            } else {\r\n                counts.set(i, true);\r\n                nonZero = true;\r\n            }\r\n        } else {\r\n            if (counts.get(i)) {\r\n                nonZero = true;\r\n            }\r\n        }\r\n        if (counts.get(i)) {\r\n            count += Math.pow(2, pos);\r\n        }\r\n        pos++;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.openhtmltopdf.pdfboxout.PdfBoxRenderer.close",
	"Comment": "cleanup thread resources. must be called after finishing with the renderer.",
	"Method": "void close(){\r\n    this.cleanup();\r\n}"
}, {
	"Path": "org.lwjgl.opengl.CallbackUtil.unregisterCallbacks",
	"Comment": "releases references to any callbacks associated with the specified gl context.",
	"Method": "void unregisterCallbacks(Object context){\r\n    final ContextCapabilities caps = GLContext.getCapabilities(context);\r\n    Long userParam = contextUserParamsARB.remove(caps);\r\n    if (userParam != null)\r\n        deleteGlobalRef(userParam);\r\n    userParam = contextUserParamsAMD.remove(caps);\r\n    if (userParam != null)\r\n        deleteGlobalRef(userParam);\r\n    userParam = contextUserParamsKHR.remove(caps);\r\n    if (userParam != null)\r\n        deleteGlobalRef(userParam);\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.style.derived.BorderPropertySet.getSideWidth",
	"Comment": "helper function for normalizeborderradius. gets the max side width for each of the corners or the side width whichever is larger",
	"Method": "float getSideWidth(BorderRadiusCorner left,BorderRadiusCorner right,float sideWidth){\r\n    return Math.max(sideWidth, left.getMaxRight(sideWidth) + right.getMaxLeft(sideWidth));\r\n}"
}, {
	"Path": "com.openhtmltopdf.outputdevice.helper.BaseRendererBuilder.useDefaultPageSize",
	"Comment": "specifies the default page size to use if none is specified in css.",
	"Method": "TFinalClass useDefaultPageSize(float pageWidth,float pageHeight,PageSizeUnits units){\r\n    state._pageWidth = pageWidth;\r\n    state._pageHeight = pageHeight;\r\n    state._isPageSizeInches = (units == PageSizeUnits.INCHES);\r\n    return (TFinalClass) this;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ui.DropdownMenu.baseContains",
	"Comment": "returns true if the coordinates are within the base item bounds.",
	"Method": "boolean baseContains(float cx,float cy){\r\n    return (cx > x && cx < x + width && cy > y && cy < y + baseHeight);\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.isZipValid",
	"Comment": "this method will check if a zip file is valid by running through it\tand checking for any corruption and crc failures",
	"Method": "boolean isZipValid(File file){\r\n    try {\r\n        ZipFile zipFile = new ZipFile(file);\r\n        try {\r\n            Enumeration e = zipFile.entries();\r\n            byte[] buffer = new byte[4096];\r\n            while (e.hasMoreElements()) {\r\n                ZipEntry zipEntry = (ZipEntry) e.nextElement();\r\n                CRC32 crc = new CRC32();\r\n                BufferedInputStream bis = new BufferedInputStream(zipFile.getInputStream(zipEntry));\r\n                CheckedInputStream cis = new CheckedInputStream(bis, crc);\r\n                while (cis.read(buffer, 0, buffer.length) != -1) {\r\n                }\r\n                if (crc.getValue() != zipEntry.getCrc()) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        } finally {\r\n            zipFile.close();\r\n        }\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.render.Rendertarget.getTextureID",
	"Comment": "get the texture id of the texture this rendertarget renders into.",
	"Method": "int getTextureID(){\r\n    return textureID;\r\n}"
}, {
	"Path": "com.joestelmach.natty.Parser.addGroup",
	"Comment": "cleans up the given group and adds it to the list of groups if still valid",
	"Method": "void addGroup(List<Token> group,List<List<Token>> groups){\r\n    if (group.isEmpty())\r\n        return;\r\n    while (!group.isEmpty() && IGNORED_TRAILING_TOKENS.contains(group.get(group.size() - 1).getType())) {\r\n        group.remove(group.size() - 1);\r\n    }\r\n    if (!group.isEmpty()) {\r\n        groups.add(group);\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.parser.Lexer.yypushback",
	"Comment": "pushes the specified amount of characters back into the input stream.they will be read again by then next call of the scanning method",
	"Method": "void yypushback(int number){\r\n    if (number > yylength())\r\n        zzScanError(ZZ_PUSHBACK_2BIG);\r\n    zzMarkedPos -= number;\r\n}"
}, {
	"Path": "com.iwebpp.node.stream.Writable2.writeOrBuffer",
	"Comment": "if we return false, then we need a drain event, so set that flag.",
	"Method": "boolean writeOrBuffer(Writable2 stream,State state,Object chunk,String encoding,WriteCB cb){\r\n    chunk = decodeChunk(state, chunk, encoding);\r\n    if (Util.isBuffer(chunk))\r\n        encoding = \"buffer\";\r\n    int len = state.objectMode ? 1 : Util.chunkLength(chunk);\r\n    state.setLength(state.getLength() + len);\r\n    boolean ret = state.getLength() < state.highWaterMark;\r\n    if (!ret)\r\n        state.needDrain = true;\r\n    if (state.writing || state.corked != 0)\r\n        state.getBuffer().add(new WriteReq(chunk, encoding, cb));\r\n    else\r\n        doWrite(stream, state, false, len, chunk, encoding, cb);\r\n    return ret;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.objects.curves.EqualDistanceMultiCurve.init",
	"Comment": "initialize the curve points with equal distance.\tmust be called by inherited classes.",
	"Method": "void init(LinkedList<CurveType> curvesList){\r\n    this.ncurve = (int) (hitObject.getPixelLength() / CURVE_POINTS_SEPERATION);\r\n    this.curve = new Vec2f[ncurve + 1];\r\n    float distanceAt = 0;\r\n    Iterator<CurveType> iter = curvesList.iterator();\r\n    int curPoint = 0;\r\n    CurveType curCurve = iter.next();\r\n    Vec2f lastCurve = curCurve.getCurvePoint()[0];\r\n    float lastDistanceAt = 0;\r\n    float pixelLength = hitObject.getPixelLength() * HitObject.getXMultiplier();\r\n    for (int i = 0; i < ncurve + 1; i++) {\r\n        int prefDistance = (int) (i * pixelLength / ncurve);\r\n        while (distanceAt < prefDistance) {\r\n            lastDistanceAt = distanceAt;\r\n            lastCurve = curCurve.getCurvePoint()[curPoint];\r\n            curPoint++;\r\n            if (curPoint >= curCurve.getCurvesCount()) {\r\n                if (iter.hasNext()) {\r\n                    curCurve = iter.next();\r\n                    curPoint = 0;\r\n                } else {\r\n                    curPoint = curCurve.getCurvesCount() - 1;\r\n                    if (lastDistanceAt == distanceAt) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            distanceAt += curCurve.getCurveDistances()[curPoint];\r\n        }\r\n        Vec2f thisCurve = curCurve.getCurvePoint()[curPoint];\r\n        if (distanceAt - lastDistanceAt > 1) {\r\n            float t = (prefDistance - lastDistanceAt) / (distanceAt - lastDistanceAt);\r\n            curve[i] = new Vec2f(Utils.lerp(lastCurve.x, thisCurve.x, t), Utils.lerp(lastCurve.y, thisCurve.y, t));\r\n        } else\r\n            curve[i] = thisCurve;\r\n    }\r\n    Vec2f c1 = curve[0];\r\n    int cnt = 1;\r\n    if (cnt > ncurve) {\r\n        return;\r\n    }\r\n    Vec2f c2 = curve[cnt++];\r\n    while (cnt <= ncurve && c2.cpy().sub(c1).len() < 1) c2 = curve[cnt++];\r\n    this.startAngle = (float) (Math.atan2(c2.y - c1.y, c2.x - c1.x) * 180 / Math.PI);\r\n    c1 = curve[ncurve];\r\n    cnt = ncurve - 1;\r\n    c2 = curve[cnt--];\r\n    while (cnt >= 0 && c2.cpy().sub(c1).len() < 1) c2 = curve[cnt--];\r\n    this.endAngle = (float) (Math.atan2(c2.y - c1.y, c2.x - c1.x) * 180 / Math.PI);\r\n}"
}, {
	"Path": "io.mappedbus.MappedBusReader.hasRecovered",
	"Comment": "indicates whether all records available when the reader was created have been read.",
	"Method": "boolean hasRecovered(){\r\n    return limit >= initialLimit;\r\n}"
}, {
	"Path": "com.openhtmltopdf.pdfboxout.PdfBoxPerDocumentFormState.findEnclosingForm",
	"Comment": "helper function to find an enclosing pdfboxform given a control element.",
	"Method": "PdfBoxForm findEnclosingForm(Node e){\r\n    Element frmElement = DOMUtil.findClosestEnclosingElementWithNodeName(e, \"form\");\r\n    if (frmElement != null && forms.containsKey(frmElement)) {\r\n        return forms.get(frmElement);\r\n    }\r\n    XRLog.general(Level.WARNING, \"Found form control (\" + e.getNodeName() + \") with no enclosing form. Ignoring.\");\r\n    return null;\r\n}"
}, {
	"Path": "com.j256.ormlite.field.FieldType.isFieldValueDefault",
	"Comment": "return whether or not the field value passed in is the default value for the type of the field. null will return\ttrue.",
	"Method": "boolean isFieldValueDefault(Object fieldValue){\r\n    if (fieldValue == null) {\r\n        return true;\r\n    } else {\r\n        return fieldValue.equals(getJavaDefaultValueDefault());\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.layout.SharedContext.isPaged",
	"Comment": "returns true if the currently set media type is paged. currently returnstrue only for print , projection , and embossed ,handheld , and tv . see the media section of the css2.1 spec for more information on media types.",
	"Method": "boolean isPaged(){\r\n    if (media.equals(\"print\")) {\r\n        return true;\r\n    }\r\n    if (media.equals(\"projection\")) {\r\n        return true;\r\n    }\r\n    if (media.equals(\"embossed\")) {\r\n        return true;\r\n    }\r\n    if (media.equals(\"handheld\")) {\r\n        return true;\r\n    }\r\n    if (media.equals(\"tv\")) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testHiddenGrandchildAbsoluteEscapes",
	"Comment": "tests that a grandchild absolute overflows its grandparent with overflow hidden,when the grandparent is not the containing block.",
	"Method": "void testHiddenGrandchildAbsoluteEscapes(){\r\n    assertTrue(vt.runTest(\"hidden-grandchild-absolute-escapes\"));\r\n}"
}, {
	"Path": "org.lwjgl.PointerBuffer.equals",
	"Comment": "tells whether or not this buffer is equal to another object.\t two pointer buffers are equal if, and only if,\t\t they have the same element type,\t they have the same number of remaining elements, and\t\t the two sequences of remaining elements, considered\tindependently of their starting positions, are pointwise equal.\t\t\t a pointer buffer is not equal to any other type of object.",
	"Method": "boolean equals(Object ob){\r\n    if (!(ob instanceof PointerBuffer))\r\n        return false;\r\n    PointerBuffer that = (PointerBuffer) ob;\r\n    if (this.remaining() != that.remaining())\r\n        return false;\r\n    int p = this.position();\r\n    for (int i = this.limit() - 1, j = that.limit() - 1; i >= p; i--, j--) {\r\n        long v1 = this.get(i);\r\n        long v2 = that.get(j);\r\n        if (v1 != v2) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.j256.ormlite.stmt.mapped.BaseMappedQuery.setParentInformation",
	"Comment": "if we have a foreign collection object then this sets the value on the foreign object in the class.",
	"Method": "void setParentInformation(Object parent,Object parentId){\r\n    this.parent = parent;\r\n    this.parentId = parentId;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.Display.sync",
	"Comment": "an accurate sync method that will attempt to run at a constant frame rate.\tit should be called once every frame.",
	"Method": "void sync(int fps){\r\n    Sync.sync(fps);\r\n}"
}, {
	"Path": "com.j256.ormlite.field.FieldType.getForeignRefField",
	"Comment": "return the field associated with the foreign object or null if none.",
	"Method": "FieldType getForeignRefField(){\r\n    return foreignRefField;\r\n}"
}, {
	"Path": "com.openhtmltopdf.nonvisualregressiontests.NonVisualRegressionTest.testLinkInlineTarget",
	"Comment": "tests that a link can successfully target a destination comprised of an inline element.",
	"Method": "void testLinkInlineTarget(){\r\n    PDDocument doc = run(\"link-inline-target\");\r\n    PDAnnotationLink link = (PDAnnotationLink) doc.getPage(0).getAnnotations().get(0);\r\n    assertThat(link.getAction(), instanceOf(PDActionGoTo.class));\r\n    PDActionGoTo action = (PDActionGoTo) link.getAction();\r\n    assertThat(action.getDestination(), instanceOf(PDPageXYZDestination.class));\r\n    PDPageXYZDestination dest = (PDPageXYZDestination) action.getDestination();\r\n    assertEquals(doc.getPage(1), dest.getPage());\r\n    assertEquals(cssPixelYToPdfPoints(0, 100), dest.getTop(), 1.0d);\r\n    remove(\"link-inline-target\", doc);\r\n}"
}, {
	"Path": "com.openhtmltopdf.java2d.Java2DTextRenderer.getGlyphBounds",
	"Comment": "this method gets glyph bounds for purposes of selecting text. we are not too worried about selecting textat this point so we just use the first font available.",
	"Method": "Rectangle getGlyphBounds(OutputDevice outputDevice,FSFont font,FSGlyphVector fsGlyphVector,int index,float x,float y){\r\n    Object aaHint = null;\r\n    Object fracHint = null;\r\n    Graphics2D graphics = ((Java2DOutputDevice) outputDevice).getGraphics();\r\n    Font awtFont = ((AWTFSFont) font).getAWTFonts().get(0);\r\n    if (awtFont.getSize() > threshold) {\r\n        aaHint = graphics.getRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING);\r\n        graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, antiAliasRenderingHint);\r\n    }\r\n    fracHint = graphics.getRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS);\r\n    graphics.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, fractionalFontMetricsHint);\r\n    GlyphVector vector = ((AWTFSGlyphVector) fsGlyphVector).getGlyphVector();\r\n    Rectangle result = vector.getGlyphPixelBounds(index, graphics.getFontRenderContext(), x, y);\r\n    if (awtFont.getSize() > threshold) {\r\n        graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, aaHint);\r\n    }\r\n    graphics.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, fracHint);\r\n    return result;\r\n}"
}, {
	"Path": "io.opencensus.contrib.http.util.HttpTraceUtil.parseResponseStatus",
	"Comment": "parse opencensus status from http response status code.this method serves a default routine to map http status code to open census status. themapping is defined in google apicanonical error code, and the behavior is defined in opencensusspecs.",
	"Method": "Status parseResponseStatus(int statusCode,Throwable error){\r\n    String message = null;\r\n    if (error != null) {\r\n        message = error.getMessage();\r\n        if (message == null) {\r\n            message = error.getClass().getSimpleName();\r\n        }\r\n    }\r\n    if (statusCode == 0) {\r\n        return Status.UNKNOWN.withDescription(message);\r\n    } else {\r\n        if (statusCode >= 200 && statusCode < 400) {\r\n            return Status.OK;\r\n        } else {\r\n            switch(statusCode) {\r\n                case 100:\r\n                    return STATUS_100;\r\n                case 101:\r\n                    return STATUS_101;\r\n                case 400:\r\n                    return Status.INVALID_ARGUMENT.withDescription(message);\r\n                case 401:\r\n                    return Status.UNAUTHENTICATED.withDescription(message);\r\n                case 402:\r\n                    return STATUS_402;\r\n                case 403:\r\n                    return Status.PERMISSION_DENIED.withDescription(message);\r\n                case 404:\r\n                    return Status.NOT_FOUND.withDescription(message);\r\n                case 405:\r\n                    return STATUS_405;\r\n                case 406:\r\n                    return STATUS_406;\r\n                case 407:\r\n                    return STATUS_407;\r\n                case 408:\r\n                    return STATUS_408;\r\n                case 409:\r\n                    return STATUS_409;\r\n                case 410:\r\n                    return STATUS_410;\r\n                case 411:\r\n                    return STATUS_411;\r\n                case 412:\r\n                    return STATUS_412;\r\n                case 413:\r\n                    return STATUS_413;\r\n                case 414:\r\n                    return STATUS_414;\r\n                case 415:\r\n                    return STATUS_415;\r\n                case 416:\r\n                    return STATUS_416;\r\n                case 417:\r\n                    return STATUS_417;\r\n                case 429:\r\n                    return Status.RESOURCE_EXHAUSTED.withDescription(message);\r\n                case 500:\r\n                    return STATUS_500;\r\n                case 501:\r\n                    return Status.UNIMPLEMENTED.withDescription(message);\r\n                case 502:\r\n                    return STATUS_502;\r\n                case 503:\r\n                    return Status.UNAVAILABLE.withDescription(message);\r\n                case 504:\r\n                    return Status.DEADLINE_EXCEEDED.withDescription(message);\r\n                case 505:\r\n                    return STATUS_505;\r\n                default:\r\n                    return Status.UNKNOWN.withDescription(message);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.examples.spaceinvaders.GameApplet.startLWJGL",
	"Comment": "once the canvas is created its add notify method will call this method to\tstart the lwjgl display and game loop in another thread.",
	"Method": "void startLWJGL(){\r\n    gameThread = new Thread() {\r\n        public void run() {\r\n            try {\r\n                Display.setParent(display_parent);\r\n            } catch (LWJGLException e) {\r\n                e.printStackTrace();\r\n            }\r\n            game = new Game(false);\r\n            game.execute();\r\n        }\r\n    };\r\n    gameThread.start();\r\n}"
}, {
	"Path": "org.lwjgl.examples.spaceinvaders.GameApplet.startLWJGL",
	"Comment": "once the canvas is created its add notify method will call this method to\tstart the lwjgl display and game loop in another thread.",
	"Method": "void startLWJGL(){\r\n    try {\r\n        Display.setParent(display_parent);\r\n    } catch (LWJGLException e) {\r\n        e.printStackTrace();\r\n    }\r\n    game = new Game(false);\r\n    game.execute();\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGLNVSync.eglClientWaitSyncNV",
	"Comment": "blocks the calling thread until the specified sync object is\tsignaled, or until a specified timeout value expires.",
	"Method": "int eglClientWaitSyncNV(EGLSyncNV sync,int flags,long timeout){\r\n    final int status = neglClientWaitSyncNV(sync.getPointer(), flags, timeout);\r\n    if (status == EGL_FALSE)\r\n        throwEGLError(\"Failed to block on NV fence sync object.\");\r\n    return status;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.Options.isMouseWheelDisabled",
	"Comment": "returns whether or not the mouse wheel is disabled during gameplay.",
	"Method": "boolean isMouseWheelDisabled(){\r\n    return GameOption.DISABLE_MOUSE_WHEEL.getBooleanValue();\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix4f.rotate",
	"Comment": "rotates the source matrix around the given axis the specified angle and\tput the result in the destination matrix.",
	"Method": "Matrix4f rotate(float angle,Vector3f axis,Matrix4f rotate,float angle,Vector3f axis,Matrix4f dest,Matrix4f rotate,float angle,Vector3f axis,Matrix4f src,Matrix4f dest){\r\n    if (dest == null)\r\n        dest = new Matrix4f();\r\n    float c = (float) Math.cos(angle);\r\n    float s = (float) Math.sin(angle);\r\n    float oneminusc = 1.0f - c;\r\n    float xy = axis.x * axis.y;\r\n    float yz = axis.y * axis.z;\r\n    float xz = axis.x * axis.z;\r\n    float xs = axis.x * s;\r\n    float ys = axis.y * s;\r\n    float zs = axis.z * s;\r\n    float f00 = axis.x * axis.x * oneminusc + c;\r\n    float f01 = xy * oneminusc + zs;\r\n    float f02 = xz * oneminusc - ys;\r\n    float f10 = xy * oneminusc - zs;\r\n    float f11 = axis.y * axis.y * oneminusc + c;\r\n    float f12 = yz * oneminusc + xs;\r\n    float f20 = xz * oneminusc + ys;\r\n    float f21 = yz * oneminusc - xs;\r\n    float f22 = axis.z * axis.z * oneminusc + c;\r\n    float t00 = src.m00 * f00 + src.m10 * f01 + src.m20 * f02;\r\n    float t01 = src.m01 * f00 + src.m11 * f01 + src.m21 * f02;\r\n    float t02 = src.m02 * f00 + src.m12 * f01 + src.m22 * f02;\r\n    float t03 = src.m03 * f00 + src.m13 * f01 + src.m23 * f02;\r\n    float t10 = src.m00 * f10 + src.m10 * f11 + src.m20 * f12;\r\n    float t11 = src.m01 * f10 + src.m11 * f11 + src.m21 * f12;\r\n    float t12 = src.m02 * f10 + src.m12 * f11 + src.m22 * f12;\r\n    float t13 = src.m03 * f10 + src.m13 * f11 + src.m23 * f12;\r\n    dest.m20 = src.m00 * f20 + src.m10 * f21 + src.m20 * f22;\r\n    dest.m21 = src.m01 * f20 + src.m11 * f21 + src.m21 * f22;\r\n    dest.m22 = src.m02 * f20 + src.m12 * f21 + src.m22 * f22;\r\n    dest.m23 = src.m03 * f20 + src.m13 * f21 + src.m23 * f22;\r\n    dest.m00 = t00;\r\n    dest.m01 = t01;\r\n    dest.m02 = t02;\r\n    dest.m03 = t03;\r\n    dest.m10 = t10;\r\n    dest.m11 = t11;\r\n    dest.m12 = t12;\r\n    dest.m13 = t13;\r\n    return dest;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.states.DownloadsMenu.scrollLists",
	"Comment": "processes a shift in the search result and downloads list start indices,\tif the mouse coordinates are within the area bounds.",
	"Method": "void scrollLists(int cx,int cy,int shift){\r\n    if (DownloadNode.resultAreaContains(cx, cy))\r\n        startResultPos.scrollOffset(shift * DownloadNode.getButtonOffset());\r\n    else if (DownloadNode.downloadAreaContains(cx, cy))\r\n        startDownloadIndexPos.scrollOffset(shift * DownloadNode.getInfoHeight());\r\n}"
}, {
	"Path": "io.opencensus.exporter.trace.stackdriver.StackdriverExporter.createAndRegisterWithCredentialsAndProjectId",
	"Comment": "creates and registers the stackdriver trace exporter to the opencensus library for an explicitproject id and using explicit credentials. only one stackdriver exporter can be registered atany point.",
	"Method": "void createAndRegisterWithCredentialsAndProjectId(Credentials credentials,String projectId){\r\n    StackdriverTraceExporter.createAndRegister(StackdriverTraceConfiguration.builder().setCredentials(credentials).setProjectId(projectId).build());\r\n}"
}, {
	"Path": "org.lwjgl.opengl.LinuxCanvasImplementation.findConfiguration",
	"Comment": "find a proper graphicsconfiguration from the given graphicsdevice and pixelformat.",
	"Method": "GraphicsConfiguration findConfiguration(GraphicsDevice device,PixelFormat pixel_format){\r\n    try {\r\n        int screen = getScreenFromDevice(device);\r\n        int visual_id_matching_format = findVisualIDFromFormat(screen, pixel_format);\r\n        GraphicsConfiguration[] configurations = device.getConfigurations();\r\n        for (GraphicsConfiguration configuration : configurations) {\r\n            int visual_id = getVisualIDFromConfiguration(configuration);\r\n            if (visual_id == visual_id_matching_format)\r\n                return configuration;\r\n        }\r\n    } catch (LWJGLException e) {\r\n        LWJGLUtil.log(\"Got exception while trying to determine configuration: \" + e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.objects.curves.Curve.init",
	"Comment": "set the width and height of the container that curves get drawn into.\tshould be called before any curves are drawn.",
	"Method": "void init(int width,int height,float circleDiameter,Color borderColor){\r\n    Curve.borderColor = borderColor;\r\n    ContextCapabilities capabilities = GLContext.getCapabilities();\r\n    mmsliderSupported = capabilities.OpenGL30;\r\n    if (mmsliderSupported) {\r\n        CurveRenderState.init(width, height, circleDiameter);\r\n        LegacyCurveRenderState.init(width, height, circleDiameter);\r\n    } else {\r\n        if (Options.getSkin().getSliderStyle() != Skin.STYLE_PEPPYSLIDER)\r\n            Log.warn(\"New slider style requires OpenGL 3.0.\");\r\n    }\r\n}"
}, {
	"Path": "com.facebook.rebound.ui.SpringConfiguratorView.generateHierarchy",
	"Comment": "programmatically build up the view hierarchy to avoid the need for resources.",
	"Method": "View generateHierarchy(Context context){\r\n    Resources resources = getResources();\r\n    FrameLayout.LayoutParams params;\r\n    int fivePx = dpToPx(5, resources);\r\n    int tenPx = dpToPx(10, resources);\r\n    int twentyPx = dpToPx(20, resources);\r\n    TableLayout.LayoutParams tableLayoutParams = new TableLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1f);\r\n    tableLayoutParams.setMargins(0, 0, fivePx, 0);\r\n    LinearLayout seekWrapper;\r\n    FrameLayout root = new FrameLayout(context);\r\n    params = createLayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, dpToPx(300, resources));\r\n    root.setLayoutParams(params);\r\n    FrameLayout container = new FrameLayout(context);\r\n    params = createMatchParams();\r\n    params.setMargins(0, twentyPx, 0, 0);\r\n    container.setLayoutParams(params);\r\n    container.setBackgroundColor(Color.argb(100, 0, 0, 0));\r\n    root.addView(container);\r\n    mSpringSelectorSpinner = new Spinner(context, Spinner.MODE_DIALOG);\r\n    params = createMatchWrapParams();\r\n    params.gravity = Gravity.TOP;\r\n    params.setMargins(tenPx, tenPx, tenPx, 0);\r\n    mSpringSelectorSpinner.setLayoutParams(params);\r\n    container.addView(mSpringSelectorSpinner);\r\n    LinearLayout linearLayout = new LinearLayout(context);\r\n    params = createMatchWrapParams();\r\n    params.setMargins(0, 0, 0, dpToPx(80, resources));\r\n    params.gravity = Gravity.BOTTOM;\r\n    linearLayout.setLayoutParams(params);\r\n    linearLayout.setOrientation(LinearLayout.VERTICAL);\r\n    container.addView(linearLayout);\r\n    seekWrapper = new LinearLayout(context);\r\n    params = createMatchWrapParams();\r\n    params.setMargins(tenPx, tenPx, tenPx, twentyPx);\r\n    seekWrapper.setPadding(tenPx, tenPx, tenPx, tenPx);\r\n    seekWrapper.setLayoutParams(params);\r\n    seekWrapper.setOrientation(LinearLayout.HORIZONTAL);\r\n    linearLayout.addView(seekWrapper);\r\n    mTensionSeekBar = new SeekBar(context);\r\n    mTensionSeekBar.setLayoutParams(tableLayoutParams);\r\n    seekWrapper.addView(mTensionSeekBar);\r\n    mTensionLabel = new TextView(getContext());\r\n    mTensionLabel.setTextColor(mTextColor);\r\n    params = createLayoutParams(dpToPx(50, resources), ViewGroup.LayoutParams.MATCH_PARENT);\r\n    mTensionLabel.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);\r\n    mTensionLabel.setLayoutParams(params);\r\n    mTensionLabel.setMaxLines(1);\r\n    seekWrapper.addView(mTensionLabel);\r\n    seekWrapper = new LinearLayout(context);\r\n    params = createMatchWrapParams();\r\n    params.setMargins(tenPx, tenPx, tenPx, twentyPx);\r\n    seekWrapper.setPadding(tenPx, tenPx, tenPx, tenPx);\r\n    seekWrapper.setLayoutParams(params);\r\n    seekWrapper.setOrientation(LinearLayout.HORIZONTAL);\r\n    linearLayout.addView(seekWrapper);\r\n    mFrictionSeekBar = new SeekBar(context);\r\n    mFrictionSeekBar.setLayoutParams(tableLayoutParams);\r\n    seekWrapper.addView(mFrictionSeekBar);\r\n    mFrictionLabel = new TextView(getContext());\r\n    mFrictionLabel.setTextColor(mTextColor);\r\n    params = createLayoutParams(dpToPx(50, resources), ViewGroup.LayoutParams.MATCH_PARENT);\r\n    mFrictionLabel.setGravity(Gravity.CENTER_VERTICAL | Gravity.LEFT);\r\n    mFrictionLabel.setLayoutParams(params);\r\n    mFrictionLabel.setMaxLines(1);\r\n    seekWrapper.addView(mFrictionLabel);\r\n    View nub = new View(context);\r\n    params = createLayoutParams(dpToPx(60, resources), dpToPx(40, resources));\r\n    params.gravity = Gravity.TOP | Gravity.CENTER;\r\n    nub.setLayoutParams(params);\r\n    nub.setOnTouchListener(new OnNubTouchListener());\r\n    nub.setBackgroundColor(Color.argb(255, 0, 164, 209));\r\n    root.addView(nub);\r\n    return root;\r\n}"
}, {
	"Path": "org.newdawn.slick.Image.getAlphaAt",
	"Comment": "get the alpha value of a pixel at a specified location in this image,\tor 1f if the image does not support transparency.",
	"Method": "float getAlphaAt(int x,int y){\r\n    if (!texture.hasAlpha())\r\n        return 1f;\r\n    if (pixelData == null)\r\n        pixelData = texture.getTextureData();\r\n    x = x * texture.getImageWidth() / width;\r\n    y = y * texture.getImageHeight() / height;\r\n    int xo = (int) (textureOffsetX * texture.getTextureWidth());\r\n    int yo = (int) (textureOffsetY * texture.getTextureHeight());\r\n    x = (textureWidth < 0) ? xo - x : xo + x;\r\n    y = (textureHeight < 0) ? yo - y : yo + y;\r\n    int offset = x + (y * texture.getTextureWidth());\r\n    offset *= 4;\r\n    return (offset + 3 >= pixelData.length) ? 1f : translate(pixelData[offset + 3]) / 255f;\r\n}"
}, {
	"Path": "org.lwjgl.PointerBuffer.compareTo",
	"Comment": "compares this buffer to another.\t two pointer buffers are compared by comparing their sequences of\tremaining elements lexicographically, without regard to the starting\tposition of each sequence within its corresponding buffer.\t a pointer buffer is not comparable to any other type of object.",
	"Method": "int compareTo(Object o){\r\n    final PointerBuffer that = (PointerBuffer) o;\r\n    int n = this.position() + Math.min(this.remaining(), that.remaining());\r\n    for (int i = this.position(), j = that.position(); i < n; i++, j++) {\r\n        long v1 = this.get(i);\r\n        long v2 = that.get(j);\r\n        if (v1 == v2)\r\n            continue;\r\n        if (v1 < v2)\r\n            return -1;\r\n        return +1;\r\n    }\r\n    return this.remaining() - that.remaining();\r\n}"
}, {
	"Path": "org.lwjgl.test.opengl.pbuffers.TextureRenderer.enable",
	"Comment": "this will be called before rendering to the renderer. implementations should setup the pbuffer context as necessary.",
	"Method": "void enable(){\r\n    try {\r\n        if (pbuffer.isBufferLost()) {\r\n            System.out.println(\"Buffer contents lost - recreating the pbuffer\");\r\n            pbuffer.destroy();\r\n            pbuffer = init(width, height, texID);\r\n        }\r\n        pbuffer.makeCurrent();\r\n    } catch (LWJGLException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.github.pires.obd.commands.pressure.PressureCommand.preparePressureValue",
	"Comment": "some pressurecommand subclasses will need to implement this method inorder to determine the final kpa value.to read tempvalue",
	"Method": "int preparePressureValue(){\r\n    return buffer.get(2);\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Vector3f.negate",
	"Comment": "negate a vector and place the result in a destination vector.",
	"Method": "Vector negate(Vector3f negate,Vector3f dest){\r\n    if (dest == null)\r\n        dest = new Vector3f();\r\n    dest.x = -x;\r\n    dest.y = -y;\r\n    dest.z = -z;\r\n    return dest;\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.setPaddingBottom",
	"Comment": "sets the padding below a glyph on the glyphpage to allow for effects to be drawn.",
	"Method": "void setPaddingBottom(int paddingBottom){\r\n    this.paddingBottom = paddingBottom;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.Options.isExperimentalSliderStyle",
	"Comment": "returns whether or not to use the experimental slider style.",
	"Method": "boolean isExperimentalSliderStyle(){\r\n    return GameOption.EXPERIMENTAL_SLIDERS.getBooleanValue();\r\n}"
}, {
	"Path": "com.j256.ormlite.stmt.mapped.BaseMappedStatement.getFieldObjects",
	"Comment": "return the array of field objects pulled from the data object.",
	"Method": "Object[] getFieldObjects(Object data){\r\n    Object[] objects = new Object[argFieldTypes.length];\r\n    for (int i = 0; i < argFieldTypes.length; i++) {\r\n        FieldType fieldType = argFieldTypes[i];\r\n        if (fieldType.isAllowGeneratedIdInsert()) {\r\n            objects[i] = fieldType.getFieldValueIfNotDefault(data);\r\n        } else {\r\n            objects[i] = fieldType.extractJavaFieldToSqlArgValue(data);\r\n        }\r\n        if (objects[i] == null) {\r\n            objects[i] = fieldType.getDefaultValue();\r\n        }\r\n    }\r\n    return objects;\r\n}"
}, {
	"Path": "me.imid.swipebacklayout.lib.ViewDragHelper.isEdgeTouched",
	"Comment": "check if any of the edges specified were initially touched by the pointerwith the specified id. if there is no currently active gesture or ifthere is no pointer with the given id currently down this method willreturn false.",
	"Method": "boolean isEdgeTouched(int edges,boolean isEdgeTouched,int edges,int pointerId){\r\n    return isPointerDown(pointerId) && (mInitialEdgeTouched[pointerId] & edges) != 0;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.Updater.checkForUpdates",
	"Comment": "checks the program version against the version file on the update server.",
	"Method": "void checkForUpdates(){\r\n    if (status != Status.INITIAL || Options.USE_XDG)\r\n        return;\r\n    status = Status.CHECKING;\r\n    if (currentVersion == null) {\r\n        Properties props = new Properties();\r\n        props.load(ResourceLoader.getResourceAsStream(Options.VERSION_FILE));\r\n        if ((currentVersion = getVersion(props)) == null) {\r\n            status = Status.INTERNAL_ERROR;\r\n            return;\r\n        }\r\n    }\r\n    String s = null;\r\n    try {\r\n        s = Utils.readDataFromUrl(new URL(OpsuConstants.VERSION_REMOTE));\r\n    } catch (UnknownHostException e) {\r\n        Log.warn(String.format(\"Check for updates failed. Please check your internet connection, or your connection to %s.\", OpsuConstants.VERSION_REMOTE));\r\n    }\r\n    if (s == null) {\r\n        status = Status.CONNECTION_ERROR;\r\n        return;\r\n    }\r\n    Properties props = new Properties();\r\n    props.load(new StringReader(s));\r\n    if ((latestVersion = getVersion(props)) == null) {\r\n        status = Status.INTERNAL_ERROR;\r\n        return;\r\n    }\r\n    if (latestVersion.compareTo(currentVersion) <= 0)\r\n        status = Status.UP_TO_DATE;\r\n    else {\r\n        String updateURL = props.getProperty(\"file\");\r\n        if (updateURL == null) {\r\n            status = Status.INTERNAL_ERROR;\r\n            return;\r\n        }\r\n        status = Status.UPDATE_AVAILABLE;\r\n        String localPath = String.format(\"%s%copsu-update-%s\", System.getProperty(\"user.dir\"), File.separatorChar, latestVersion.toString());\r\n        String rename = String.format(\"opsu-%s.jar\", latestVersion.toString());\r\n        download = new Download(updateURL, localPath, rename);\r\n        download.setListener(new DownloadListener() {\r\n            @Override\r\n            public void completed() {\r\n                status = Status.UPDATE_DOWNLOADED;\r\n                UI.getNotificationManager().sendNotification(\"Update has finished downloading.\", Colors.GREEN);\r\n            }\r\n            @Override\r\n            public void error() {\r\n                status = Status.CONNECTION_ERROR;\r\n                UI.getNotificationManager().sendNotification(\"Update failed due to a connection error.\", Color.red);\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.Updater.checkForUpdates",
	"Comment": "checks the program version against the version file on the update server.",
	"Method": "void checkForUpdates(){\r\n    status = Status.UPDATE_DOWNLOADED;\r\n    UI.getNotificationManager().sendNotification(\"Update has finished downloading.\", Colors.GREEN);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.Updater.checkForUpdates",
	"Comment": "checks the program version against the version file on the update server.",
	"Method": "void checkForUpdates(){\r\n    status = Status.CONNECTION_ERROR;\r\n    UI.getNotificationManager().sendNotification(\"Update failed due to a connection error.\", Color.red);\r\n}"
}, {
	"Path": "com.snowcattle.game.service.net.proxy.handler.ProxyBackendHandler.closeOnFlush",
	"Comment": "closes the specified channel after all queued write requests are flushed.",
	"Method": "void closeOnFlush(Channel ch){\r\n    if (ch.isActive()) {\r\n        ch.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);\r\n        ch.close();\r\n    }\r\n}"
}, {
	"Path": "me.imid.swipebacklayout.lib.ViewDragHelper.getEdgeSize",
	"Comment": "return the size of an edge. this is the range in pixels along the edgesof this view that will actively detect edge touches or drags if edgetracking is enabled.",
	"Method": "int getEdgeSize(){\r\n    return mEdgeSize;\r\n}"
}, {
	"Path": "com.openhtmltopdf.outputdevice.helper.BaseRendererBuilder.defaultTextDirection",
	"Comment": "the default text direction of the document. ltr by default.",
	"Method": "TFinalClass defaultTextDirection(TextDirection textDirection){\r\n    state._textDirection = textDirection == TextDirection.RTL;\r\n    return (TFinalClass) this;\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGLDisplay.isExtensionSupported",
	"Comment": "returns true if the specified egl extension is supported by this egl display.",
	"Method": "boolean isExtensionSupported(String eglExtension){\r\n    checkInitialized();\r\n    if (extensions == null) {\r\n        extensions = new HashSet<String>(16);\r\n        final StringTokenizer tokenizer = new StringTokenizer(eglQueryString(this, EGL_EXTENSIONS));\r\n        while (tokenizer.hasMoreTokens()) extensions.add(tokenizer.nextToken());\r\n    }\r\n    return extensions.contains(eglExtension);\r\n}"
}, {
	"Path": "com.openhtmltopdf.java2d.Java2DTextRenderer.getWidthSlow",
	"Comment": "this method divides the string up into font runs, then measures each font run, addingit to the total. we do this, rather than get the width of each character,in case kerning is enabled and it also may be faster.",
	"Method": "int getWidthSlow(FontContext fc,List<Font> fonts,String string){\r\n    List<FontRun> runs = divideIntoFontRuns(fonts, string);\r\n    int width = 0;\r\n    for (FontRun run : runs) {\r\n        width += getWidthFast(fc, run.fnt, run.sb.toString());\r\n    }\r\n    return width;\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix4f.transpose",
	"Comment": "transpose the source matrix and place the result in the destination matrix",
	"Method": "Matrix transpose(Matrix4f transpose,Matrix4f dest,Matrix4f transpose,Matrix4f src,Matrix4f dest){\r\n    if (dest == null)\r\n        dest = new Matrix4f();\r\n    float m00 = src.m00;\r\n    float m01 = src.m10;\r\n    float m02 = src.m20;\r\n    float m03 = src.m30;\r\n    float m10 = src.m01;\r\n    float m11 = src.m11;\r\n    float m12 = src.m21;\r\n    float m13 = src.m31;\r\n    float m20 = src.m02;\r\n    float m21 = src.m12;\r\n    float m22 = src.m22;\r\n    float m23 = src.m32;\r\n    float m30 = src.m03;\r\n    float m31 = src.m13;\r\n    float m32 = src.m23;\r\n    float m33 = src.m33;\r\n    dest.m00 = m00;\r\n    dest.m01 = m01;\r\n    dest.m02 = m02;\r\n    dest.m03 = m03;\r\n    dest.m10 = m10;\r\n    dest.m11 = m11;\r\n    dest.m12 = m12;\r\n    dest.m13 = m13;\r\n    dest.m20 = m20;\r\n    dest.m21 = m21;\r\n    dest.m22 = m22;\r\n    dest.m23 = m23;\r\n    dest.m30 = m30;\r\n    dest.m31 = m31;\r\n    dest.m32 = m32;\r\n    dest.m33 = m33;\r\n    return dest;\r\n}"
}, {
	"Path": "com.android.volley.Request.hasHadResponseDelivered",
	"Comment": "returns true if this request has had a response delivered for it.",
	"Method": "boolean hasHadResponseDelivered(){\r\n    return mResponseDelivered;\r\n}"
}, {
	"Path": "org.lwjgl.input.Mouse.getEventNanoseconds",
	"Comment": "gets the time in nanoseconds of the current event.\tonly useful for relative comparisons with other\tmouse events, as the absolute time has no defined\torigin.",
	"Method": "long getEventNanoseconds(){\r\n    synchronized (OpenGLPackageAccess.global_lock) {\r\n        return event_nanos;\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.OpenUtil.isCodePointPrintable",
	"Comment": "checks if a code point is printable. if false, it can be safely discarded at the \trendering stage, else it should be replaced with the replacement character,\tif a suitable glyph can not be found.",
	"Method": "boolean isCodePointPrintable(int codePoint){\r\n    if (Character.isISOControl(codePoint))\r\n        return false;\r\n    int category = Character.getType(codePoint);\r\n    return !(category == Character.CONTROL || category == Character.FORMAT || category == Character.UNASSIGNED || category == Character.PRIVATE_USE || category == Character.SURROGATE);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.Options.setNextFPS",
	"Comment": "sets the target frame rate to the next available option, and sends a\tbar notification about the action.",
	"Method": "void setNextFPS(GameContainer container){\r\n    int index = (targetFPSindex + 1) % targetFPS.length;\r\n    if (index == targetFPS.length - 1)\r\n        index = 0;\r\n    GameOption.TARGET_FPS.selectItem(index, container);\r\n    UI.getNotificationManager().sendBarNotification(String.format(\"Frame limiter: %s\", GameOption.TARGET_FPS.getValueString()));\r\n}"
}, {
	"Path": "com.openhtmltopdf.layout.BoxBuilder.doBidi",
	"Comment": "attempts to divide a text node further into directional text runs, either ltr or rtl.",
	"Method": "InlineBox doBidi(LayoutContext c,Text textNode,Element parent,CalculatedStyle parentStyle,InlineBox previousIB,List children){\r\n    Paragraph para = c.getParagraphSplitter().lookupParagraph(textNode);\r\n    if (para == null) {\r\n        return doFakeBidi(c, textNode, parent, parentStyle, previousIB, children);\r\n    }\r\n    int startIndex = para.getFirstCharIndexInParagraph(textNode);\r\n    if (startIndex < 0) {\r\n        return doFakeBidi(c, textNode, parent, parentStyle, previousIB, children);\r\n    }\r\n    int nodeIndex = 0;\r\n    String runText;\r\n    BidiTextRun prevSplit = para.prevSplit(startIndex);\r\n    assert (prevSplit != null);\r\n    assert (prevSplit.getStart() <= startIndex);\r\n    int maxRunLength = prevSplit.getLength() - (startIndex - prevSplit.getStart());\r\n    int splitLength = Math.min(maxRunLength, textNode.getLength());\r\n    nodeIndex += splitLength;\r\n    startIndex += splitLength;\r\n    assert (prevSplit.getDirection() == BidiSplitter.LTR || prevSplit.getDirection() == BidiSplitter.RTL);\r\n    if (splitLength == textNode.getLength()) {\r\n        runText = textNode.getData();\r\n    } else {\r\n        runText = textNode.getData().substring(0, nodeIndex);\r\n    }\r\n    if (prevSplit.getDirection() == BidiSplitter.RTL) {\r\n        runText = c.getBidiReorderer().shapeText(runText);\r\n    }\r\n    InlineBox child = createInlineBox(runText, parent, parentStyle, textNode);\r\n    child.setTextDirection(prevSplit.getDirection());\r\n    previousIB = setupInlineChild(child, previousIB);\r\n    children.add(child);\r\n    if (splitLength != textNode.getLength()) {\r\n        do {\r\n            BidiTextRun newSplit = para.nextSplit(startIndex);\r\n            assert (newSplit != null);\r\n            int newLength;\r\n            if (newSplit != null) {\r\n                int newMaxRunLength = newSplit.getLength() - (startIndex - newSplit.getStart());\r\n                newLength = Math.min(newMaxRunLength, textNode.getLength() - nodeIndex);\r\n                runText = textNode.getData().substring(nodeIndex, nodeIndex + newLength);\r\n                if (newSplit.getDirection() == BidiSplitter.RTL) {\r\n                    runText = c.getBidiReorderer().shapeText(runText);\r\n                }\r\n                startIndex += newLength;\r\n                nodeIndex += newLength;\r\n                child = createInlineBox(runText, parent, parentStyle, textNode);\r\n                child.setTextDirection(newSplit.getDirection());\r\n                previousIB = setupInlineChild(child, previousIB);\r\n                children.add(child);\r\n            } else {\r\n                newLength = textNode.getLength() - nodeIndex;\r\n                runText = textNode.getData().substring(nodeIndex, newLength);\r\n                child = createInlineBox(runText, parent, parentStyle, textNode);\r\n                child.setTextDirection(c.getDefaultTextDirection());\r\n                previousIB = setupInlineChild(child, previousIB);\r\n                children.add(child);\r\n                startIndex += newLength;\r\n                nodeIndex += newLength;\r\n            }\r\n        } while (nodeIndex < textNode.getLength());\r\n    }\r\n    return previousIB;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.downloads.servers.DownloadServer.disableSSLInDownloads",
	"Comment": "returns whether ssl certificate validation should be disabled for downloads.",
	"Method": "boolean disableSSLInDownloads(){\r\n    return false;\r\n}"
}, {
	"Path": "com.android.volley.Request.compareTo",
	"Comment": "our comparator sorts from high to low priority, and secondarily bysequence number to provide fifo ordering.",
	"Method": "int compareTo(Request<T> other){\r\n    Priority left = this.getPriority();\r\n    Priority right = other.getPriority();\r\n    return left == right ? this.mSequence - other.mSequence : right.ordinal() - left.ordinal();\r\n}"
}, {
	"Path": "com.openhtmltopdf.layout.Layer.applyTranform",
	"Comment": "applies the transforms specified for the box and returns a list of inverse transforms that should beapplied once the transformed element has been output.",
	"Method": "List<AffineTransform> applyTranform(RenderingContext c,Box box){\r\n    FSDerivedValue transforms = box.getStyle().valueByName(CSSName.TRANSFORM);\r\n    if (transforms.isIdent() && transforms.asIdentValue() == IdentValue.NONE)\r\n        return Collections.emptyList();\r\n    float relOriginX = box.getStyle().getFloatPropertyProportionalWidth(CSSName.FS_TRANSFORM_ORIGIN_X, box.getWidth(), c);\r\n    float relOriginY = box.getStyle().getFloatPropertyProportionalHeight(CSSName.FS_TRANSFORM_ORIGIN_Y, box.getHeight(), c);\r\n    float flipFactor = c.getOutputDevice().isPDF() ? -1 : 1;\r\n    float absTranslateX = relOriginX + box.getAbsX();\r\n    float absTranslateY = relOriginY + box.getAbsY();\r\n    float relTranslateX = absTranslateX - c.getOutputDevice().getAbsoluteTransformOriginX();\r\n    float relTranslateY = absTranslateY - c.getOutputDevice().getAbsoluteTransformOriginY();\r\n    if (c.getOutputDevice().isPDF()) {\r\n        RectPropertySet margin = c.getPage().getMargin(c);\r\n        relTranslateX += margin.left();\r\n        relTranslateY += margin.top();\r\n        for (int i = 0; i < c.getPageNo() && i < getPages().size(); i++) {\r\n            RectPropertySet prevMargin = getPages().get(i).getMargin(c);\r\n            relTranslateY += prevMargin.top() + prevMargin.bottom();\r\n        }\r\n        MarginBoxName[] marginBoxNames = c.getPage().getCurrentMarginBoxNames();\r\n        if (marginBoxNames != null) {\r\n            boolean isLeft = false, isTop = false, isRight = false, isTopRight = false, isTopLeft = true, isBottom = false, isBottomRight = false, isBottomLeft = false;\r\n            for (MarginBoxName name : marginBoxNames) {\r\n                if (name == MarginBoxName.LEFT_TOP || name == MarginBoxName.LEFT_MIDDLE || name == MarginBoxName.LEFT_BOTTOM)\r\n                    isLeft = true;\r\n                if (name == MarginBoxName.TOP_LEFT || name == MarginBoxName.TOP_CENTER || name == MarginBoxName.TOP_RIGHT)\r\n                    isTop = true;\r\n                if (name == MarginBoxName.BOTTOM_LEFT || name == MarginBoxName.BOTTOM_CENTER || name == MarginBoxName.BOTTOM_RIGHT)\r\n                    isBottom = true;\r\n                if (name == MarginBoxName.TOP_LEFT_CORNER)\r\n                    isTopLeft = true;\r\n                if (name == MarginBoxName.TOP_RIGHT_CORNER)\r\n                    isTopRight = true;\r\n                if (name == MarginBoxName.BOTTOM_LEFT_CORNER)\r\n                    isBottomLeft = true;\r\n                if (name == MarginBoxName.BOTTOM_RIGHT_CORNER)\r\n                    isBottomRight = true;\r\n            }\r\n            if (isLeft)\r\n                relTranslateX -= margin.left();\r\n            if (isTop)\r\n                relTranslateY -= margin.top();\r\n            if (isBottom)\r\n                relTranslateY -= margin.top() + margin.bottom();\r\n            if (isTopLeft) {\r\n                relTranslateX -= margin.left();\r\n                relTranslateY -= margin.top();\r\n            }\r\n            if (isTopRight) {\r\n                relTranslateX -= margin.left();\r\n                relTranslateY -= margin.top();\r\n            }\r\n            if (isRight) {\r\n                relTranslateY -= margin.top();\r\n                relTranslateX -= margin.left() + margin.right();\r\n            }\r\n            if (isBottom) {\r\n                relTranslateY -= margin.top() + margin.bottom();\r\n            }\r\n            if (isBottomLeft) {\r\n            }\r\n            if (isBottomRight) {\r\n                relTranslateX -= margin.left();\r\n                relTranslateY -= margin.top() + margin.bottom();\r\n            }\r\n        }\r\n    }\r\n    List<PropertyValue> transformList = (List<PropertyValue>) ((ListValue) transforms).getValues();\r\n    List<AffineTransform> resultTransforms = new ArrayList<AffineTransform>();\r\n    AffineTransform translateToOrigin = AffineTransform.getTranslateInstance(relTranslateX, relTranslateY);\r\n    AffineTransform translateBackFromOrigin = AffineTransform.getTranslateInstance(-relTranslateX, -relTranslateY);\r\n    resultTransforms.add(translateToOrigin);\r\n    applyTransformFunctions(flipFactor, transformList, resultTransforms);\r\n    resultTransforms.add(translateBackFromOrigin);\r\n    return c.getOutputDevice().pushTransforms(resultTransforms);\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Vector2f.negate",
	"Comment": "negate a vector and place the result in a destination vector.",
	"Method": "Vector negate(Vector2f negate,Vector2f dest){\r\n    if (dest == null)\r\n        dest = new Vector2f();\r\n    dest.x = -x;\r\n    dest.y = -y;\r\n    return dest;\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.getRequiredRotation",
	"Comment": "determines the rotation to be applied to tiles, based on exif orientation or chosen setting.",
	"Method": "int getRequiredRotation(){\r\n    if (orientation == ORIENTATION_USE_EXIF) {\r\n        return sOrientation;\r\n    } else {\r\n        return orientation;\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.Options.isUpdaterDisabled",
	"Comment": "returns whether or not automatic checking for updates is disabled.",
	"Method": "boolean isUpdaterDisabled(){\r\n    return GameOption.DISABLE_UPDATER.getBooleanValue();\r\n}"
}, {
	"Path": "org.lwjgl.util.Rectangle.contains",
	"Comment": "checks whether or not this rectangle entirely contains \tthe specified rectangle.",
	"Method": "boolean contains(ReadablePoint p,boolean contains,int X,int Y,boolean contains,ReadableRectangle r,boolean contains,int X,int Y,int W,int H){\r\n    int w = this.width;\r\n    int h = this.height;\r\n    if ((w | h | W | H) < 0) {\r\n        return false;\r\n    }\r\n    int x = this.x;\r\n    int y = this.y;\r\n    if (X < x || Y < y) {\r\n        return false;\r\n    }\r\n    w += x;\r\n    W += X;\r\n    if (W <= X) {\r\n        if (w >= x || W > w)\r\n            return false;\r\n    } else {\r\n        if (w >= x && W > w)\r\n            return false;\r\n    }\r\n    h += y;\r\n    H += Y;\r\n    if (H <= Y) {\r\n        if (h >= y || H > h)\r\n            return false;\r\n    } else {\r\n        if (h >= y && H > h)\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.addVerifyListener",
	"Comment": "adds a verify listener. a verify event is sent by the widget when the widget text is about to change. the listener can set the event text and the doit field to change the text that is set in the widget or to force the widget to ignore the text change.",
	"Method": "void addVerifyListener(VerifyListener verifyListener){\r\n    checkWidget();\r\n    if (verifyListener == null)\r\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\r\n    addListener(SWT.Verify, new TypedListener(verifyListener));\r\n}"
}, {
	"Path": "ddf.minim.ugens.ADSR.noteOff",
	"Comment": "specifies that the adsr envelope should start the release time.",
	"Method": "void noteOff(){\r\n    timeFromOff = 0f;\r\n    isTurnedOff = true;\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testHorizPageOverflowStatic",
	"Comment": "tests that static blocks overflow onto inserted shadow page.",
	"Method": "void testHorizPageOverflowStatic(){\r\n    assertTrue(vt.runTest(\"horiz-page-overflow-static\"));\r\n}"
}, {
	"Path": "me.imid.swipebacklayout.lib.SwipeBackLayout.addSwipeListener",
	"Comment": "add a callback to be invoked when a swipe event is sent to this view.",
	"Method": "void addSwipeListener(SwipeListener listener){\r\n    if (mListeners == null) {\r\n        mListeners = new ArrayList<SwipeListener>();\r\n    }\r\n    mListeners.add(listener);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.NativeLoader.loadNatives",
	"Comment": "unpacks natives for the current operating system to the natives directory.",
	"Method": "void loadNatives(){\r\n    if (!nativeDir.exists())\r\n        nativeDir.mkdir();\r\n    JarFile jarFile = Utils.getJarFile();\r\n    if (jarFile == null)\r\n        return;\r\n    Enumeration<JarEntry> entries = jarFile.entries();\r\n    while (entries.hasMoreElements()) {\r\n        JarEntry e = entries.nextElement();\r\n        if (e == null)\r\n            break;\r\n        File f = new File(nativeDir, e.getName());\r\n        if (isNativeFile(e.getName()) && !e.isDirectory() && e.getName().indexOf('/') == -1 && !f.exists()) {\r\n            InputStream in = jarFile.getInputStream(jarFile.getEntry(e.getName()));\r\n            OutputStream out = new FileOutputStream(f);\r\n            byte[] buffer = new byte[65536];\r\n            int bufferSize;\r\n            while ((bufferSize = in.read(buffer, 0, buffer.length)) != -1) out.write(buffer, 0, bufferSize);\r\n            in.close();\r\n            out.close();\r\n        }\r\n    }\r\n    jarFile.close();\r\n}"
}, {
	"Path": "ddf.minim.Controller.setVolume",
	"Comment": "sets the volume. if a volume control is not available,this does nothing.",
	"Method": "void setVolume(float value){\r\n    setValue(VOLUME, value);\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.style.derived.BorderPropertySet.darken",
	"Comment": "returns the colors for brighter parts of each side for a particular decoration style",
	"Method": "BorderPropertySet darken(IdentValue style){\r\n    BorderPropertySet bc = new BorderPropertySet(this);\r\n    bc._topColor = _topColor == null ? null : _topColor.darkenColor();\r\n    bc._bottomColor = _bottomColor == null ? null : _bottomColor.darkenColor();\r\n    bc._leftColor = _leftColor == null ? null : _leftColor.darkenColor();\r\n    bc._rightColor = _rightColor == null ? null : _rightColor.darkenColor();\r\n    return bc;\r\n}"
}, {
	"Path": "com.openhtmltopdf.layout.SharedContext.getReplacementText",
	"Comment": "the replacement text to be used if a character cannot be \trenderered by the current or fallback fonts.",
	"Method": "String getReplacementText(){\r\n    return this.replacementText;\r\n}"
}, {
	"Path": "org.newdawn.slick.UnicodeFont.getLeading",
	"Comment": "gets the extra distance between the descent of one line of text to the ascent of the next.",
	"Method": "int getLeading(){\r\n    return leading;\r\n}"
}, {
	"Path": "com.android.volley.toolbox.ImageLoader.getImageListener",
	"Comment": "the default implementation of imagelistener which handles basic functionalityof showing a default image until the network response is received, at which pointit will switch to either the actual image or the error image.",
	"Method": "ImageListener getImageListener(ImageView view,int defaultImageResId,int errorImageResId){\r\n    return new ImageListener() {\r\n        @Override\r\n        public void onErrorResponse(VolleyError error) {\r\n            if (errorImageResId != 0) {\r\n                view.setImageResource(errorImageResId);\r\n            }\r\n        }\r\n        @Override\r\n        public void onResponse(ImageContainer response, boolean isImmediate) {\r\n            if (response.getBitmap() != null) {\r\n                view.setImageBitmap(response.getBitmap());\r\n            } else if (defaultImageResId != 0) {\r\n                view.setImageResource(defaultImageResId);\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.android.volley.toolbox.ImageLoader.getImageListener",
	"Comment": "the default implementation of imagelistener which handles basic functionalityof showing a default image until the network response is received, at which pointit will switch to either the actual image or the error image.",
	"Method": "ImageListener getImageListener(ImageView view,int defaultImageResId,int errorImageResId){\r\n    if (errorImageResId != 0) {\r\n        view.setImageResource(errorImageResId);\r\n    }\r\n}"
}, {
	"Path": "com.android.volley.toolbox.ImageLoader.getImageListener",
	"Comment": "the default implementation of imagelistener which handles basic functionalityof showing a default image until the network response is received, at which pointit will switch to either the actual image or the error image.",
	"Method": "ImageListener getImageListener(ImageView view,int defaultImageResId,int errorImageResId){\r\n    if (response.getBitmap() != null) {\r\n        view.setImageBitmap(response.getBitmap());\r\n    } else if (defaultImageResId != 0) {\r\n        view.setImageResource(defaultImageResId);\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.opengles.PixelFormat.getBestMatch",
	"Comment": "returns the egl config from the specified array that best matches this pixelformat.",
	"Method": "EGLConfig getBestMatch(EGLConfig[] configs){\r\n    if (configs == null || configs.length == 0)\r\n        throw new IllegalArgumentException(\"No EGLConfigs specified.\");\r\n    if (configs.length == 1)\r\n        return configs[0];\r\n    for (EGLConfig config : configs) {\r\n        if (config == null)\r\n            continue;\r\n        if (!(matches(ALPHA_SIZE, config) && matchesNonZero(DEPTH_SIZE, config) && matchesNonZero(STENCIL_SIZE, config)))\r\n            continue;\r\n        final int luminance = getAttrib(LUMINANCE_SIZE);\r\n        if (0 < luminance && !matches(LUMINANCE_SIZE, config))\r\n            continue;\r\n        if (luminance == 0 && !(matches(RED_SIZE, config) && matches(GREEN_SIZE, config) && matches(BLUE_SIZE, config)))\r\n            continue;\r\n        if (!(matches(SAMPLE_BUFFERS, config) && matches(SAMPLES, config)))\r\n            continue;\r\n        return config;\r\n    }\r\n    LWJGLUtil.log(\"Could not find an exact EGLConfig match for the PixelFormat requested, using first returned.\");\r\n    return configs[0];\r\n}"
}, {
	"Path": "com.android.volley.Response.error",
	"Comment": "returns a failed response containing the given error code and an optionallocalized message displayed to the user.",
	"Method": "Response<T> error(VolleyError error){\r\n    return new Response<T>(error);\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.displaylist.PagedBoxCollector.findAdjustedBoundsForBorderBox",
	"Comment": "finds the document coordinates border box bounds of a box adjusted for transform and clipped according to overflow hidden.",
	"Method": "Rectangle findAdjustedBoundsForBorderBox(CssContext c,Box container,List<PageBox> pages){\r\n    Rectangle bounds = container.getBorderBox(c);\r\n    AffineTransform transform = container.getContainingLayer().getCurrentTransformMatrix();\r\n    Area overflowClip = container.getAbsoluteClipBox(c);\r\n    transformBounds(bounds, transform);\r\n    bounds = applyOverflowClip(bounds, overflowClip);\r\n    return bounds;\r\n}"
}, {
	"Path": "org.lwjgl.opengl.CallbackUtil.registerContextCallbackKHR",
	"Comment": "associates the current opengl context with the specified global reference. if there\tis no context current, the global reference is deleted and an exception is thrown.\tany previous callback registrations will be cleared.",
	"Method": "void registerContextCallbackKHR(long userParam){\r\n    registerContextCallback(userParam, contextUserParamsKHR);\r\n}"
}, {
	"Path": "org.lwjgl.opengl.Display.setInitialBackground",
	"Comment": "set the initial color of the display. this method is called before the display is created and will set the\tbackground color to the one specified in this method.",
	"Method": "void setInitialBackground(float red,float green,float blue){\r\n    r = red;\r\n    g = green;\r\n    b = blue;\r\n}"
}, {
	"Path": "org.lwjgl.PointerWrapperAbstract.isValid",
	"Comment": "returns true if this object represents a valid pointer.\tthe pointer might be invalid because it is null or because\tsome other action has deleted the object that this pointer\trepresents.",
	"Method": "boolean isValid(){\r\n    return pointer != 0;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getLineBackground",
	"Comment": "returns the background color of the line at the given index.returns null if a linebackgroundlistener has been set or if no background color has been specified for the line. should not be called if alinebackgroundlistener has been set since the listener maintains theline background colors.",
	"Method": "Color getLineBackground(int index){\r\n    checkWidget();\r\n    if (index < 0 || index > content.getLineCount()) {\r\n        SWT.error(SWT.ERROR_INVALID_ARGUMENT);\r\n    }\r\n    return isListening(ST.LineGetBackground) ? null : renderer.getLineBackground(index, null);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.states.SongMenu.resetTrackOnLoad",
	"Comment": "triggers a reset of the music track upon entering this state.",
	"Method": "void resetTrackOnLoad(){\r\n    resetTrack = true;\r\n}"
}, {
	"Path": "org.lwjgl.opencl.CLChecks.getElementSize",
	"Comment": "returns the number of bytes per element for the specified image format.",
	"Method": "int getElementSize(ByteBuffer format){\r\n    final int channelOrder = format.getInt(format.position() + 0);\r\n    final int channelType = format.getInt(format.position() + 4);\r\n    return getChannelCount(channelOrder) * getChannelSize(channelType);\r\n}"
}, {
	"Path": "com.openhtmltopdf.java2d.api.Java2DRendererBuilder.useLayoutGraphics",
	"Comment": "compulsory method. the layout graphics are used to measure text and should be\tfrom an image or device with the same characteristics as the output graphicsw\tprovided by the page processor.",
	"Method": "Java2DRendererBuilder useLayoutGraphics(Graphics2D g2d){\r\n    state._layoutGraphics = g2d;\r\n    return this;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.user.UserButton.contains",
	"Comment": "returns true if the coordinates are within the button bounds.",
	"Method": "boolean contains(int cx,int cy){\r\n    return ((cx > x && cx < x + buttonWidth) && (cy > y && cy < y + buttonHeight));\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.onTileLoaded",
	"Comment": "called by worker task when a tile has loaded. redraws the view.",
	"Method": "void onTileLoaded(){\r\n    invalidate();\r\n}"
}, {
	"Path": "ddf.minim.analysis.FourierTransform.getSpectrumImaginary",
	"Comment": "get the imaginary part of the complex representation of the spectrum.",
	"Method": "float[] getSpectrumImaginary(){\r\n    return imag;\r\n}"
}, {
	"Path": "ddf.minim.effects.IIRFilter.initArrays",
	"Comment": "initializes the in and out arrays based on the number of coefficients beingused.",
	"Method": "void initArrays(int numChannels){\r\n    int memSize = (a.length >= b.length) ? a.length : b.length;\r\n    in = new float[numChannels][memSize];\r\n    out = new float[numChannels][memSize];\r\n}"
}, {
	"Path": "com.j256.ormlite.dao.BaseDaoImpl.clearAllInternalObjectCaches",
	"Comment": "special call mostly used in testing to clear the internal object caches so we can reset state.",
	"Method": "void clearAllInternalObjectCaches(){\r\n    if (defaultObjectCache != null) {\r\n        defaultObjectCache.clearAll();\r\n        defaultObjectCache = null;\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.audio.SoundController.getCurrentFileName",
	"Comment": "returns the name of the current file being loaded, or null if none.",
	"Method": "String getCurrentFileName(){\r\n    return (currentFileName != null) ? currentFileName : null;\r\n}"
}, {
	"Path": "com.j256.ormlite.support.BaseConnectionSource.isSavedConnection",
	"Comment": "return true if the connection being released is the one that has been saved.",
	"Method": "boolean isSavedConnection(DatabaseConnection connection){\r\n    NestedConnection currentSaved = specialConnection.get();\r\n    if (currentSaved == null) {\r\n        return false;\r\n    } else if (currentSaved.connection == connection) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "io.opencensus.benchmarks.trace.RecordTraceEventsBenchmark.putAttribute",
	"Comment": "this benchmark attempts to measure performance of adding an attribute to the span.",
	"Method": "Span putAttribute(Data data){\r\n    data.span.putAttribute(ATTRIBUTE_KEY, AttributeValue.stringAttributeValue(ATTRIBUTE_VALUE));\r\n    return data.span;\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testRtlPageOverflowTransform",
	"Comment": "tests that transforms to the left of the page margin generate an overflow page.",
	"Method": "void testRtlPageOverflowTransform(){\r\n    assertTrue(vt.runTest(\"rtl-page-overflow-transform\"));\r\n}"
}, {
	"Path": "org.newdawn.slick.GameContainer.getGraphics",
	"Comment": "get the graphics context used by this container. note that this \tvalue may vary over the life time of the game.",
	"Method": "Graphics getGraphics(){\r\n    return graphics;\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.setWordWrap",
	"Comment": "sets whether the widget wraps lines.this overrides the creation style bit swt.wrap.",
	"Method": "void setWordWrap(boolean wrap){\r\n    checkWidget();\r\n    if ((getStyle() & SWT.SINGLE) != 0)\r\n        return;\r\n    if (wordWrap == wrap)\r\n        return;\r\n    if (wordWrap && blockSelection)\r\n        setBlockSelection(false);\r\n    wordWrap = wrap;\r\n    setVariableLineHeight();\r\n    resetCache(0, content.getLineCount());\r\n    horizontalScrollOffset = 0;\r\n    ScrollBar horizontalBar = getHorizontalBar();\r\n    if (horizontalBar != null) {\r\n        horizontalBar.setVisible(!wordWrap);\r\n    }\r\n    setScrollBars(true);\r\n    setCaretLocation();\r\n    super.redraw();\r\n}"
}, {
	"Path": "io.opencensus.exporter.trace.ocagent.FakeOcAgentTraceServiceGrpcImpl.getUpdatedLibraryConfig",
	"Comment": "gets the updatedlibraryconfig that will be passed to client.",
	"Method": "UpdatedLibraryConfig getUpdatedLibraryConfig(){\r\n    return updatedLibraryConfig;\r\n}"
}, {
	"Path": "com.openhtmltopdf.nonvisualregressiontests.NonVisualRegressionTest.testBookmarkHeadNested",
	"Comment": "tests that a nested head bookmark linking to top of the third page works.",
	"Method": "void testBookmarkHeadNested(){\r\n    PDDocument doc = run(\"bookmark-head-nested\");\r\n    PDDocumentOutline outline = doc.getDocumentCatalog().getDocumentOutline();\r\n    PDOutlineItem bm1 = outline.getFirstChild();\r\n    assertThat(bm1.getTitle(), equalTo(\"Outer\"));\r\n    assertThat(bm1.getDestination(), instanceOf(PDPageXYZDestination.class));\r\n    PDPageXYZDestination dest1 = (PDPageXYZDestination) bm1.getDestination();\r\n    assertEquals(dest1.getPage(), doc.getPage(1));\r\n    assertEquals(doc.getPage(1).getMediaBox().getUpperRightY(), dest1.getTop(), 1.0d);\r\n    PDOutlineItem bm2 = bm1.getFirstChild();\r\n    assertThat(bm2.getTitle(), equalTo(\"Inner\"));\r\n    assertThat(bm2.getDestination(), instanceOf(PDPageXYZDestination.class));\r\n    PDPageXYZDestination dest2 = (PDPageXYZDestination) bm2.getDestination();\r\n    assertEquals(dest2.getPage(), doc.getPage(2));\r\n    assertEquals(doc.getPage(2).getMediaBox().getUpperRightY(), dest2.getTop(), 1.0d);\r\n    remove(\"bookmark-head-nested\", doc);\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.ArrayUtil.isOneOf",
	"Comment": "tests if left is equal to one of the rights. also returns true if both are null.",
	"Method": "boolean isOneOf(T left,T rights){\r\n    for (T candidate : rights) {\r\n        if (candidate == null && left == null) {\r\n            return true;\r\n        } else if (left != null && left.equals(candidate)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.Configuration.info",
	"Comment": "used internally to log a message about the class at level info",
	"Method": "void info(String msg){\r\n    if (logLevel.intValue() <= Level.INFO.intValue()) {\r\n        println(Level.INFO, msg);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.skins.Skin.getSongSelectActiveTextColor",
	"Comment": "returns the color of the active text in the song selection menu.",
	"Method": "Color getSongSelectActiveTextColor(){\r\n    return songSelectActiveText;\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.isImageReady",
	"Comment": "call to find whether the view is initialised and ready for rendering the bitmap.",
	"Method": "boolean isImageReady(){\r\n    return readySent && vTranslate != null && bitmap != null && sWidth > 0 && sHeight > 0;\r\n}"
}, {
	"Path": "ddf.minim.AudioInput.isMonitoring",
	"Comment": "returns whether or not this audioinput is monitoring.in other words, whether you will hear in your speakersthe audio coming into the input.",
	"Method": "boolean isMonitoring(){\r\n    return m_isMonitoring;\r\n}"
}, {
	"Path": "org.lwjgl.util.glu.tessellation.Render.Marked",
	"Comment": "macros which keep track of faces we have marked temporarily, and allowus to backtrack when necessary.with triangle fans, this is notreally necessary, since the only awkward case is a loop of trianglesaround a single origin vertex.however with strips the situation ismore complicated, and we need a general tracking method like theone here.",
	"Method": "boolean Marked(GLUface f){\r\n    return !f.inside || f.marked;\r\n}"
}, {
	"Path": "ddf.minim.javasound.FloatSampleBuffer.changeSampleCount",
	"Comment": "resizes this buffer.\tif keepoldsamples is true, as much as possible samples are\tretained. if the buffer is enlarged, silence is added at the end. if\tkeepoldsamples is false, existing samples may get\tdiscarded, the buffer may then contain random samples.",
	"Method": "void changeSampleCount(int newSampleCount,boolean keepOldSamples){\r\n    int oldSampleCount = getSampleCount();\r\n    if (oldSampleCount >= newSampleCount) {\r\n        setSampleCountImpl(newSampleCount);\r\n        return;\r\n    }\r\n    if (channelCount == 1 || channelCount == 2) {\r\n        float[] ch = getChannel(0);\r\n        if (ch.length < newSampleCount) {\r\n            float[] newCh = new float[newSampleCount];\r\n            if (keepOldSamples && oldSampleCount > 0) {\r\n                System.arraycopy(ch, 0, newCh, 0, oldSampleCount);\r\n            }\r\n            channels[0] = newCh;\r\n        } else if (keepOldSamples) {\r\n            for (int i = oldSampleCount; i < newSampleCount; i++) {\r\n                ch[i] = 0.0f;\r\n            }\r\n        }\r\n        if (channelCount == 2) {\r\n            ch = getChannel(1);\r\n            if (ch.length < newSampleCount) {\r\n                float[] newCh = new float[newSampleCount];\r\n                if (keepOldSamples && oldSampleCount > 0) {\r\n                    System.arraycopy(ch, 0, newCh, 0, oldSampleCount);\r\n                }\r\n                channels[1] = newCh;\r\n            } else if (keepOldSamples) {\r\n                for (int i = oldSampleCount; i < newSampleCount; i++) {\r\n                    ch[i] = 0.0f;\r\n                }\r\n            }\r\n        }\r\n        setSampleCountImpl(newSampleCount);\r\n        return;\r\n    }\r\n    Object[] oldChannels = null;\r\n    if (keepOldSamples) {\r\n        oldChannels = getAllChannels();\r\n    }\r\n    init(getChannelCount(), newSampleCount, getSampleRate());\r\n    if (keepOldSamples) {\r\n        int copyCount = newSampleCount < oldSampleCount ? newSampleCount : oldSampleCount;\r\n        for (int ch = 0; ch < this.channelCount; ch++) {\r\n            float[] oldSamples = (float[]) oldChannels[ch];\r\n            float[] newSamples = (float[]) channels[ch];\r\n            if (oldSamples != newSamples) {\r\n                System.arraycopy(oldSamples, 0, newSamples, 0, copyCount);\r\n            }\r\n            if (oldSampleCount < newSampleCount) {\r\n                for (int i = oldSampleCount; i < newSampleCount; i++) {\r\n                    newSamples[i] = 0.0f;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.newdawn.slick.Image.copy",
	"Comment": "get a copy of this image. this is a shallow copy and does not \tduplicate image adata.",
	"Method": "Image copy(){\r\n    init();\r\n    return getSubImage(0, 0, width, height);\r\n}"
}, {
	"Path": "org.newdawn.slick.openal.OpenALStreamPlayer.stream",
	"Comment": "stream some data from the audio stream to the buffer indicates by the id",
	"Method": "boolean stream(int bufferId){\r\n    try {\r\n        int count = audio.read(buffer);\r\n        if (count != -1) {\r\n            streamPos += count;\r\n            bufferData.clear();\r\n            bufferData.put(buffer, 0, count);\r\n            bufferData.flip();\r\n            int format = audio.getChannels() > 1 ? AL10.AL_FORMAT_STEREO16 : AL10.AL_FORMAT_MONO16;\r\n            try {\r\n                AL10.alBufferData(bufferId, format, bufferData, audio.getRate());\r\n            } catch (OpenALException e) {\r\n                Log.error(\"Failed to loop buffer: \" + bufferId + \" \" + format + \" \" + count + \" \" + audio.getRate(), e);\r\n                return false;\r\n            }\r\n        } else {\r\n            if (loop) {\r\n                musicLength = streamPos;\r\n                initStreams();\r\n                stream(bufferId);\r\n            } else {\r\n                done = true;\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    } catch (IOException e) {\r\n        Log.error(e);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.j256.ormlite.field.FieldType.isObjectsFieldValueDefault",
	"Comment": "return whether or not the data object has a default value passed for this field of this type.",
	"Method": "boolean isObjectsFieldValueDefault(Object object){\r\n    Object fieldValue = extractJavaFieldValue(object);\r\n    return isFieldValueDefault(fieldValue);\r\n}"
}, {
	"Path": "org.lwjgl.opengl.PixelFormat.withBitsPerPixel",
	"Comment": "returns a new pixelformat object with the same properties as this pixelformat and the new bits per pixel value.",
	"Method": "PixelFormat withBitsPerPixel(int bpp){\r\n    if (bpp < 0)\r\n        throw new IllegalArgumentException(\"Invalid number of bits per pixel specified: \" + bpp);\r\n    final PixelFormat pf = new PixelFormat(this);\r\n    pf.bpp = bpp;\r\n    return pf;\r\n}"
}, {
	"Path": "org.lwjgl.util.Rectangle.isEmpty",
	"Comment": "determines whether or not this rectangle is empty. a \trectangle is empty if its width or its height is less \tthan or equal to zero.",
	"Method": "boolean isEmpty(){\r\n    return (width <= 0) || (height <= 0);\r\n}"
}, {
	"Path": "org.lwjgl.opengl.Sync.sync",
	"Comment": "an accurate sync method that will attempt to run at a constant frame rate.\tit should be called once every frame.",
	"Method": "void sync(int fps){\r\n    if (fps <= 0)\r\n        return;\r\n    if (!initialised)\r\n        initialise();\r\n    try {\r\n        for (long t0 = getTime(), t1; (nextFrame - t0) > sleepDurations.avg(); t0 = t1) {\r\n            Thread.sleep(1);\r\n            sleepDurations.add((t1 = getTime()) - t0);\r\n        }\r\n        sleepDurations.dampenForLowResTicker();\r\n        for (long t0 = getTime(), t1; (nextFrame - t0) > yieldDurations.avg(); t0 = t1) {\r\n            Thread.yield();\r\n            yieldDurations.add((t1 = getTime()) - t0);\r\n        }\r\n    } catch (InterruptedException e) {\r\n    }\r\n    nextFrame = Math.max(nextFrame + NANOS_IN_SECOND / fps, getTime());\r\n}"
}, {
	"Path": "orestes.bloomfilter.test.comparisons.BloomFilterMagnus.getFalsePositiveProbability",
	"Comment": "get the current probability of a false positive. the probability is calculated fromthe size of the bloom filter and the current number of elements added to it.",
	"Method": "double getFalsePositiveProbability(double numberOfElements,double getFalsePositiveProbability){\r\n    return getFalsePositiveProbability(numberOfAddedElements);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.handleMouseMove",
	"Comment": "updates the caret location and selection if mouse button 1 is pressed during the mouse move.",
	"Method": "void handleMouseMove(Event event){\r\n    if (clickCount > 0) {\r\n        update();\r\n        doAutoScroll(event);\r\n        doMouseLocationChange(event.x, event.y, true);\r\n    }\r\n    if (renderer.hasLinks) {\r\n        doMouseLinkCursor(event.x, event.y);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.Utils.standardDeviation",
	"Comment": "calculates the standard deviation of the numbers in the list.",
	"Method": "double standardDeviation(List<Integer> list){\r\n    float avg = 0f;\r\n    for (int i : list) avg += i;\r\n    avg /= list.size();\r\n    float var = 0f;\r\n    for (int i : list) var += (i - avg) * (i - avg);\r\n    var /= list.size();\r\n    return Math.sqrt(var);\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testHiddenGrandchildFixedEscapes",
	"Comment": "tests that a grandchild fixed overflows its grandparent with overflow hidden,because the grandparent is not the containing block, the viewport is, eventhough the grandparent has position relative.",
	"Method": "void testHiddenGrandchildFixedEscapes(){\r\n    assertTrue(vt.runTest(\"hidden-grandchild-fixed-escapes\"));\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.limitedSCenter",
	"Comment": "given a requested source center and scale, calculate what the actual center will have to be to keep the image inpan limits, keeping the requested center as near to the middle of the screen as allowed.",
	"Method": "PointF limitedSCenter(PointF sCenter,float scale){\r\n    PointF vTranslate = vTranslateForSCenter(sCenter, scale);\r\n    int mY = getHeight() / 2;\r\n    float sx = ((getWidth() / 2) - vTranslate.x) / scale;\r\n    float sy = ((getHeight() / 2) - vTranslate.y) / scale;\r\n    return new PointF(sx, sy);\r\n}"
}, {
	"Path": "io.opencensus.contrib.http.HttpClientHandler.handleEnd",
	"Comment": "close an http span.this method will set status of the span and end it.",
	"Method": "void handleEnd(Span span,P response,Throwable error){\r\n    spanEnd(span, response, error);\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.getCurrentCertificates",
	"Comment": "returns the current certificate chain of the appletloader",
	"Method": "Certificate[] getCurrentCertificates(){\r\n    Certificate[] certificate = AppletLoader.class.getProtectionDomain().getCodeSource().getCertificates();\r\n    if (certificate == null) {\r\n        URL location = AppletLoader.class.getProtectionDomain().getCodeSource().getLocation();\r\n        JarURLConnection jurl = (JarURLConnection) (new URL(\"jar:\" + location.toString() + \"!/org/lwjgl/util/applet/AppletLoader.class\").openConnection());\r\n        jurl.setDefaultUseCaches(true);\r\n        certificate = jurl.getCertificates();\r\n        jurl.setDefaultUseCaches(false);\r\n    }\r\n    return certificate;\r\n}"
}, {
	"Path": "com.android.volley.toolbox.HttpClientStack.createHttpRequest",
	"Comment": "creates the appropriate subclass of httpurirequest for passed in request.",
	"Method": "HttpUriRequest createHttpRequest(Request<?> request,Map<String, String> additionalHeaders){\r\n    switch(request.getMethod()) {\r\n        case Method.DEPRECATED_GET_OR_POST:\r\n            {\r\n                byte[] postBody = request.getPostBody();\r\n                if (postBody != null) {\r\n                    HttpPost postRequest = new HttpPost(request.getUrl());\r\n                    postRequest.addHeader(HEADER_CONTENT_TYPE, request.getPostBodyContentType());\r\n                    HttpEntity entity;\r\n                    entity = new ByteArrayEntity(postBody);\r\n                    postRequest.setEntity(entity);\r\n                    return postRequest;\r\n                } else {\r\n                    return new HttpGet(request.getUrl());\r\n                }\r\n            }\r\n        case Method.GET:\r\n            return new HttpGet(request.getUrl());\r\n        case Method.DELETE:\r\n            return new HttpDelete(request.getUrl());\r\n        case Method.POST:\r\n            {\r\n                HttpPost postRequest = new HttpPost(request.getUrl());\r\n                postRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());\r\n                setEntityIfNonEmptyBody(postRequest, request);\r\n                return postRequest;\r\n            }\r\n        case Method.PUT:\r\n            {\r\n                HttpPut putRequest = new HttpPut(request.getUrl());\r\n                putRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());\r\n                setEntityIfNonEmptyBody(putRequest, request);\r\n                return putRequest;\r\n            }\r\n        case Method.HEAD:\r\n            return new HttpHead(request.getUrl());\r\n        case Method.OPTIONS:\r\n            return new HttpOptions(request.getUrl());\r\n        case Method.TRACE:\r\n            return new HttpTrace(request.getUrl());\r\n        case Method.PATCH:\r\n            {\r\n                HttpPatch patchRequest = new HttpPatch(request.getUrl());\r\n                patchRequest.addHeader(HEADER_CONTENT_TYPE, request.getBodyContentType());\r\n                setEntityIfNonEmptyBody(patchRequest, request);\r\n                return patchRequest;\r\n            }\r\n        default:\r\n            throw new IllegalStateException(\"Unknown request method.\");\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.context.StandardAttributeResolver.isFocus",
	"Comment": "gets the focus attribute of the standardattributeresolver object",
	"Method": "boolean isFocus(Object e){\r\n    return ui.isFocus((Element) e);\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testHiddenGrandchildAbsolute",
	"Comment": "tests that a grandchild absolute does not overflow its grandparent with overflow hidden.",
	"Method": "void testHiddenGrandchildAbsolute(){\r\n    assertTrue(vt.runTest(\"hidden-grandchild-absolute\"));\r\n}"
}, {
	"Path": "com.openhtmltopdf.layout.SharedContext.removeFromThread",
	"Comment": "this removes the shared context from a thread local to avoid memory leaks.",
	"Method": "void removeFromThread(){\r\n    ThreadCtx.get().setSharedContext(null);\r\n}"
}, {
	"Path": "io.opencensus.implcore.stats.IntervalBucket.record",
	"Comment": "puts a new value into the internal mutableaggregations, based on the tagvalues.",
	"Method": "void record(List<TagValue> tagValues,double value,Map<String, String> attachments,Timestamp timestamp){\r\n    if (!tagValueAggregationMap.containsKey(tagValues)) {\r\n        tagValueAggregationMap.put(tagValues, RecordUtils.createMutableAggregation(aggregation, measure));\r\n    }\r\n    tagValueAggregationMap.get(tagValues).add(value, attachments, timestamp);\r\n}"
}, {
	"Path": "orestes.bloomfilter.BloomFilter.hash",
	"Comment": "returns the k hash values for an inputs element in byte array form",
	"Method": "int[] hash(byte[] bytes,int[] hash,String value){\r\n    return hash(value.getBytes(FilterBuilder.defaultCharset()));\r\n}"
}, {
	"Path": "org.lwjgl.opengl.NVVideoCaptureUtil.glReleaseVideoCaptureDeviceNV",
	"Comment": "use this method when finished capturing data on a locked video capture device\tto unlock it.",
	"Method": "boolean glReleaseVideoCaptureDeviceNV(long device){\r\n    checkExtension();\r\n    return nglReleaseVideoCaptureDeviceNV(getPeerInfo(), device);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.handleKey",
	"Comment": "if an action has been registered for the key stroke execute the action.otherwise, if a character has been entered treat it as new content.",
	"Method": "void handleKey(Event event){\r\n    int action;\r\n    caretAlignment = PREVIOUS_OFFSET_TRAILING;\r\n    System.out.println(\"handel key event=\" + event);\r\n    if (event.keyCode != 0) {\r\n        action = getKeyBinding(event.keyCode | event.stateMask);\r\n        System.out.println(\"action!=\" + action);\r\n    } else {\r\n        action = getKeyBinding(event.character | event.stateMask);\r\n        System.out.println(\"2action!=\" + action);\r\n        if (action == SWT.NULL) {\r\n            if ((event.stateMask & SWT.CTRL) != 0 && event.character <= 31) {\r\n                int c = event.character + 64;\r\n                action = getKeyBinding(c | event.stateMask);\r\n            }\r\n        }\r\n    }\r\n    if (action == SWT.NULL) {\r\n        boolean ignore = false;\r\n        System.out.println(\"ignore!\");\r\n        if (IS_MAC) {\r\n            ignore = (event.stateMask ^ SWT.COMMAND) == 0 || (event.stateMask ^ (SWT.COMMAND | SWT.SHIFT)) == 0;\r\n        } else if (IS_MOTIF) {\r\n            ignore = (event.stateMask ^ SWT.CTRL) == 0 || (event.stateMask ^ (SWT.CTRL | SWT.SHIFT)) == 0;\r\n        } else {\r\n            ignore = (event.stateMask ^ SWT.ALT) == 0 || (event.stateMask ^ SWT.CTRL) == 0 || (event.stateMask ^ (SWT.ALT | SWT.SHIFT)) == 0 || (event.stateMask ^ (SWT.CTRL | SWT.SHIFT)) == 0;\r\n        }\r\n        if (!ignore && event.character > 31 && event.character != SWT.DEL || event.character == SWT.CR || event.character == SWT.LF || event.character == TAB) {\r\n            doContent(event.character);\r\n            update();\r\n        }\r\n    } else {\r\n        invokeAction(action);\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.render.PageBox.shouldInsertPages",
	"Comment": "should shadow pages be inserted for cut off content for this page.",
	"Method": "boolean shouldInsertPages(){\r\n    return getMaxInsertedPages() > 0;\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView.refreshRequiredTiles",
	"Comment": "loads the optimum tiles for display at the current scale and translate, so the screen can be filled with tilesthat are at least as high resolution as the screen. frees up bitmaps that are now off the screen.",
	"Method": "void refreshRequiredTiles(boolean load){\r\n    int sampleSize = Math.min(fullImageSampleSize, calculateInSampleSize());\r\n    RectF vVisRect = new RectF(0, 0, getWidth(), getHeight());\r\n    RectF sVisRect = viewToSourceRect(vVisRect);\r\n    for (Map.Entry<Integer, List<Tile>> tileMapEntry : tileMap.entrySet()) {\r\n        for (Tile tile : tileMapEntry.getValue()) {\r\n            if (tile.sampleSize < sampleSize || (tile.sampleSize > sampleSize && tile.sampleSize != fullImageSampleSize)) {\r\n                tile.visible = false;\r\n                if (tile.bitmap != null) {\r\n                    tile.bitmap.recycle();\r\n                    tile.bitmap = null;\r\n                }\r\n            }\r\n            if (tile.sampleSize == sampleSize) {\r\n                if (RectF.intersects(sVisRect, convertRect(tile.sRect))) {\r\n                    tile.visible = true;\r\n                    if (!tile.loading && tile.bitmap == null && load) {\r\n                        BitmapTileTask task = new BitmapTileTask(this, decoder, decoderLock, tile);\r\n                        task.execute();\r\n                    }\r\n                } else if (tile.sampleSize != fullImageSampleSize) {\r\n                    tile.visible = false;\r\n                    if (tile.bitmap != null) {\r\n                        tile.bitmap.recycle();\r\n                        tile.bitmap = null;\r\n                    }\r\n                }\r\n            } else if (tile.sampleSize == fullImageSampleSize) {\r\n                tile.visible = true;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.volley.toolbox.ByteArrayPool.trim",
	"Comment": "removes buffers from the pool until it is under its size limit.",
	"Method": "void trim(){\r\n    while (mCurrentSize > mSizeLimit) {\r\n        byte[] buf = mBuffersByLastUse.remove(0);\r\n        mBuffersBySize.remove(buf);\r\n        mCurrentSize -= buf.length;\r\n    }\r\n}"
}, {
	"Path": "org.newdawn.slick.Input.setMouseClickTolerance",
	"Comment": "set the pixel distance the mouse can move to accept a mouse click. \tdefault is 5.",
	"Method": "void setMouseClickTolerance(int mouseClickTolerance){\r\n    this.mouseClickTolerance = mouseClickTolerance;\r\n}"
}, {
	"Path": "io.opencensus.implcore.internal.VarInt.getVarLong",
	"Comment": "reads an up to 64 bit long varint from the current position of the given bytebuffer and returnsthe decoded value as long.the position of the buffer is advanced to the first byte after the decoded varint.",
	"Method": "long getVarLong(ByteBuffer src){\r\n    long tmp;\r\n    if ((tmp = src.get()) >= 0) {\r\n        return tmp;\r\n    }\r\n    long result = tmp & 0x7f;\r\n    if ((tmp = src.get()) >= 0) {\r\n        result |= tmp << 7;\r\n    } else {\r\n        result |= (tmp & 0x7f) << 7;\r\n        if ((tmp = src.get()) >= 0) {\r\n            result |= tmp << 14;\r\n        } else {\r\n            result |= (tmp & 0x7f) << 14;\r\n            if ((tmp = src.get()) >= 0) {\r\n                result |= tmp << 21;\r\n            } else {\r\n                result |= (tmp & 0x7f) << 21;\r\n                if ((tmp = src.get()) >= 0) {\r\n                    result |= tmp << 28;\r\n                } else {\r\n                    result |= (tmp & 0x7f) << 28;\r\n                    if ((tmp = src.get()) >= 0) {\r\n                        result |= tmp << 35;\r\n                    } else {\r\n                        result |= (tmp & 0x7f) << 35;\r\n                        if ((tmp = src.get()) >= 0) {\r\n                            result |= tmp << 42;\r\n                        } else {\r\n                            result |= (tmp & 0x7f) << 42;\r\n                            if ((tmp = src.get()) >= 0) {\r\n                                result |= tmp << 49;\r\n                            } else {\r\n                                result |= (tmp & 0x7f) << 49;\r\n                                if ((tmp = src.get()) >= 0) {\r\n                                    result |= tmp << 56;\r\n                                } else {\r\n                                    result |= (tmp & 0x7f) << 56;\r\n                                    result |= ((long) src.get()) << 63;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "io.opencensus.exporter.trace.ocagent.OcAgentNodeUtils.getNodeInfo",
	"Comment": "creates a node with information from the opencensus library and environment variables.",
	"Method": "Node getNodeInfo(String serviceName){\r\n    String jvmName = ManagementFactory.getRuntimeMXBean().getName();\r\n    Timestamp censusTimestamp = Timestamp.fromMillis(System.currentTimeMillis());\r\n    return Node.newBuilder().setIdentifier(getProcessIdentifier(jvmName, censusTimestamp)).setLibraryInfo(getLibraryInfo(OpenCensusLibraryInformation.VERSION)).setServiceInfo(getServiceInfo(serviceName)).build();\r\n}"
}, {
	"Path": "com.j256.ormlite.dao.BaseDaoImpl.initialize",
	"Comment": "initialize the various dao configurations after the various setters have been called.",
	"Method": "void initialize(){\r\n    if (initialized) {\r\n        return;\r\n    }\r\n    if (connectionSource == null) {\r\n        throw new IllegalStateException(\"connectionSource was never set on \" + getClass().getSimpleName());\r\n    }\r\n    databaseType = connectionSource.getDatabaseType();\r\n    if (databaseType == null) {\r\n        throw new IllegalStateException(\"connectionSource is getting a null DatabaseType in \" + getClass().getSimpleName());\r\n    }\r\n    if (tableConfig == null) {\r\n        tableInfo = new TableInfo<T, ID>(connectionSource, this, dataClass);\r\n    } else {\r\n        tableConfig.extractFieldTypes(connectionSource);\r\n        tableInfo = new TableInfo<T, ID>(databaseType, this, tableConfig);\r\n    }\r\n    statementExecutor = new StatementExecutor<T, ID>(databaseType, tableInfo, this);\r\n    List<BaseDaoImpl<?, ?>> daoConfigList = daoConfigLevelLocal.get();\r\n    daoConfigList.add(this);\r\n    if (daoConfigList.size() > 1) {\r\n        return;\r\n    }\r\n    try {\r\n        for (int i = 0; i < daoConfigList.size(); i++) {\r\n            BaseDaoImpl<?, ?> dao = daoConfigList.get(i);\r\n            DaoManager.registerDao(connectionSource, dao);\r\n            try {\r\n                for (FieldType fieldType : dao.getTableInfo().getFieldTypes()) {\r\n                    fieldType.configDaoInformation(connectionSource, dao.getDataClass());\r\n                }\r\n            } catch (SQLException e) {\r\n                DaoManager.unregisterDao(connectionSource, dao);\r\n                throw e;\r\n            }\r\n            dao.initialized = true;\r\n        }\r\n    } finally {\r\n        daoConfigList.clear();\r\n        daoConfigLevelLocal.remove();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doLineUp",
	"Comment": "moves the caret one line up and to the same character offset relative to the beginning of the line. move the caret to the end of the new line if the new line is shorter than the character offset.",
	"Method": "void doLineUp(boolean select){\r\n    int caretLine = getCaretLine(), y = 0;\r\n    boolean firstLine = false;\r\n    if (wordWrap) {\r\n        int lineOffset = content.getOffsetAtLine(caretLine);\r\n        int offsetInLine = caretOffset - lineOffset;\r\n        TextLayout layout = renderer.getTextLayout(caretLine);\r\n        int lineIndex = getVisualLineIndex(layout, offsetInLine);\r\n        if (lineIndex == 0) {\r\n            firstLine = caretLine == 0;\r\n            if (!firstLine) {\r\n                caretLine--;\r\n                y = renderer.getLineHeight(caretLine) - 1;\r\n            }\r\n        } else {\r\n            y = layout.getLineBounds(lineIndex - 1).y;\r\n        }\r\n        renderer.disposeTextLayout(layout);\r\n    } else {\r\n        firstLine = caretLine == 0;\r\n        caretLine--;\r\n    }\r\n    if (firstLine) {\r\n        if (select) {\r\n            setCaretOffset(0, SWT.DEFAULT);\r\n        }\r\n    } else {\r\n        int[] alignment = new int[1];\r\n        int offset = getOffsetAtPoint(columnX, y, caretLine, alignment);\r\n        setCaretOffset(offset, alignment[0]);\r\n    }\r\n    int oldColumnX = columnX;\r\n    int oldHScrollOffset = horizontalScrollOffset;\r\n    if (select)\r\n        setMouseWordSelectionAnchor();\r\n    showCaret();\r\n    if (select)\r\n        doSelection(ST.COLUMN_PREVIOUS);\r\n    int hScrollChange = oldHScrollOffset - horizontalScrollOffset;\r\n    columnX = oldColumnX + hScrollChange;\r\n}"
}, {
	"Path": "org.lwjgl.util.Rectangle.intersects",
	"Comment": "determines whether or not this rectangle and the specified \trectangle intersect. two rectangles intersect if \ttheir intersection is nonempty.",
	"Method": "boolean intersects(ReadableRectangle r){\r\n    int tw = this.width;\r\n    int th = this.height;\r\n    int rw = r.getWidth();\r\n    int rh = r.getHeight();\r\n    if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) {\r\n        return false;\r\n    }\r\n    int tx = this.x;\r\n    int ty = this.y;\r\n    int rx = r.getX();\r\n    int ry = r.getY();\r\n    rw += rx;\r\n    rh += ry;\r\n    tw += tx;\r\n    th += ty;\r\n    return ((rw < rx || rw > tx) && (rh < ry || rh > ty) && (tw < tx || tw > rx) && (th < ty || th > ry));\r\n}"
}, {
	"Path": "com.j256.ormlite.logger.LocalLog.openLogFile",
	"Comment": "reopen the associated static logging stream. set to null to redirect to system.out.",
	"Method": "void openLogFile(String logPath){\r\n    if (logPath == null) {\r\n        printStream = System.out;\r\n    } else {\r\n        try {\r\n            printStream = new PrintStream(new File(logPath));\r\n        } catch (FileNotFoundException e) {\r\n            throw new IllegalArgumentException(\"Log file \" + logPath + \" was not found\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "ddf.minim.javasound.FloatSampleBuffer.setSampleCountImpl",
	"Comment": "internal setter for sample count, just change the variable. from outside,\tuse changesamplecount",
	"Method": "void setSampleCountImpl(int newSampleCount){\r\n    if (sampleCount != newSampleCount) {\r\n        sampleCount = newSampleCount;\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.swing.NaiveUserAgent.openStream",
	"Comment": "gets a inputstream for the resource identified by a resolved uri.",
	"Method": "InputStream openStream(String uri){\r\n    java.io.InputStream is = null;\r\n    try {\r\n        URI urlObj = new URI(uri);\r\n        String protocol = urlObj.getScheme();\r\n        if (hasProtocolFactory(protocol)) {\r\n            return getProtocolFactory(protocol).getUrl(uri).getStream();\r\n        } else {\r\n            try {\r\n                is = new URL(uri).openStream();\r\n            } catch (java.net.MalformedURLException e) {\r\n                XRLog.exception(\"bad URL given: \" + uri, e);\r\n            } catch (java.io.FileNotFoundException e) {\r\n                XRLog.exception(\"item at URI \" + uri + \" not found\", e);\r\n            } catch (java.io.IOException e) {\r\n                XRLog.exception(\"IO problem for \" + uri, e);\r\n            }\r\n        }\r\n    } catch (URISyntaxException e1) {\r\n        XRLog.exception(\"bad URL given: \" + uri, e1);\r\n    }\r\n    return is;\r\n}"
}, {
	"Path": "org.newdawn.slick.Input.addPrimaryListener",
	"Comment": "add a listener to be notified of input events. this listener\twill get events before others that are currently registered",
	"Method": "void addPrimaryListener(InputListener listener){\r\n    removeListener(listener);\r\n    keyListeners.add(0, listener);\r\n    mouseListeners.add(0, listener);\r\n    controllerListeners.add(0, listener);\r\n    allListeners.add(listener);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.addExtendedModifyListener",
	"Comment": "adds an extended modify listener. an extendedmodify event is sent by the widget when the widget text has changed.",
	"Method": "void addExtendedModifyListener(ExtendedModifyListener extendedModifyListener){\r\n    checkWidget();\r\n    if (extendedModifyListener == null)\r\n        SWT.error(SWT.ERROR_NULL_ARGUMENT);\r\n    StyledTextListener typedListener = new StyledTextListener(extendedModifyListener);\r\n    addListener(ST.ExtendedModify, typedListener);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ui.StarStream.isEmpty",
	"Comment": "returns whether there are any stars currently in this stream.",
	"Method": "boolean isEmpty(){\r\n    return stars.isEmpty();\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.animateScale",
	"Comment": "creates a scale animation builder, that when started will animate a zoom in or out. if this would move the imagebeyond the panning limits, the image is automatically panned during the animation.",
	"Method": "AnimationBuilder animateScale(float scale){\r\n    if (!isImageReady()) {\r\n        return null;\r\n    }\r\n    return new AnimationBuilder(scale);\r\n}"
}, {
	"Path": "com.openhtmltopdf.css.style.CalculatedStyle.deriveStyle",
	"Comment": "derives a child style from this style.depends on the ability to return the identical cascadedstyle each time a child style is needed",
	"Method": "CalculatedStyle deriveStyle(CascadedStyle matched){\r\n    String fingerprint = matched.getFingerprint();\r\n    CalculatedStyle cs = _childCache.get(fingerprint);\r\n    if (cs == null) {\r\n        cs = new CalculatedStyle(this, matched);\r\n        _childCache.put(fingerprint, cs);\r\n    }\r\n    return cs;\r\n}"
}, {
	"Path": "com.davemorrissey.labs.subscaleview.ScaleImageView.onTouchEvent",
	"Comment": "handle touch events. one finger pans, and two finger pinch and zoom plus panning.",
	"Method": "boolean onTouchEvent(MotionEvent event){\r\n    PointF vCenterEnd;\r\n    float vDistEnd;\r\n    if (anim != null && !anim.interruptible) {\r\n        getParent().requestDisallowInterceptTouchEvent(true);\r\n        return true;\r\n    } else {\r\n        anim = null;\r\n    }\r\n    if (vTranslate == null) {\r\n        return true;\r\n    }\r\n    if (detector == null || detector.onTouchEvent(event)) {\r\n        return true;\r\n    }\r\n    int touchCount = event.getPointerCount();\r\n    switch(event.getAction()) {\r\n        case MotionEvent.ACTION_DOWN:\r\n        case MotionEvent.ACTION_POINTER_1_DOWN:\r\n        case MotionEvent.ACTION_POINTER_2_DOWN:\r\n            anim = null;\r\n            getParent().requestDisallowInterceptTouchEvent(true);\r\n            maxTouchCount = Math.max(maxTouchCount, touchCount);\r\n            if (touchCount >= 2) {\r\n                if (zoomEnabled) {\r\n                    float distance = distance(event.getX(0), event.getX(1), event.getY(0), event.getY(1));\r\n                    scaleStart = scale;\r\n                    vDistStart = distance;\r\n                    vTranslateStart = new PointF(vTranslate.x, vTranslate.y);\r\n                    vCenterStart = new PointF((event.getX(0) + event.getX(1)) / 2, (event.getY(0) + event.getY(1)) / 2);\r\n                } else {\r\n                    maxTouchCount = 0;\r\n                }\r\n                handler.removeMessages(MESSAGE_LONG_CLICK);\r\n            } else {\r\n                vTranslateStart = new PointF(vTranslate.x, vTranslate.y);\r\n                vCenterStart = new PointF(event.getX(), event.getY());\r\n                handler.sendEmptyMessageDelayed(MESSAGE_LONG_CLICK, 600);\r\n            }\r\n            return true;\r\n        case MotionEvent.ACTION_MOVE:\r\n            boolean consumed = false;\r\n            if (maxTouchCount > 0) {\r\n                if (touchCount >= 2) {\r\n                    vDistEnd = distance(event.getX(0), event.getX(1), event.getY(0), event.getY(1));\r\n                    vCenterEnd = new PointF((event.getX(0) + event.getX(1)) / 2, (event.getY(0) + event.getY(1)) / 2);\r\n                    if (zoomEnabled && (distance(vCenterStart.x, vCenterEnd.x, vCenterStart.y, vCenterEnd.y) > 5 || Math.abs(vDistEnd - vDistStart) > 5 || isPanning)) {\r\n                        isZooming = true;\r\n                        isPanning = true;\r\n                        consumed = true;\r\n                        scale = Math.min(maxScale, (vDistEnd / vDistStart) * scaleStart);\r\n                        if (scale <= minScale()) {\r\n                            vDistStart = vDistEnd;\r\n                            scaleStart = minScale();\r\n                            vCenterStart = vCenterEnd;\r\n                            vTranslateStart = vTranslate;\r\n                        } else if (panEnabled) {\r\n                            float vLeftStart = vCenterStart.x - vTranslateStart.x;\r\n                            float vTopStart = vCenterStart.y - vTranslateStart.y;\r\n                            float vLeftNow = vLeftStart * (scale / scaleStart);\r\n                            float vTopNow = vTopStart * (scale / scaleStart);\r\n                            vTranslate.x = vCenterEnd.x - vLeftNow;\r\n                            vTranslate.y = vCenterEnd.y - vTopNow;\r\n                        } else if (sRequestedCenter != null) {\r\n                            vTranslate.x = (getWidth() / 2) - (scale * sRequestedCenter.x);\r\n                            vTranslate.y = (getHeight() / 2) - (scale * sRequestedCenter.y);\r\n                        } else {\r\n                            vTranslate.x = (getWidth() / 2) - (scale * (sWidth() / 2));\r\n                            vTranslate.y = (getHeight() / 2) - (scale * (sHeight() / 2));\r\n                        }\r\n                        fitToBounds(true);\r\n                    }\r\n                } else if (!isZooming) {\r\n                    float dx = Math.abs(event.getX() - vCenterStart.x);\r\n                    float dy = Math.abs(event.getY() - vCenterStart.y);\r\n                    if (dx > 5 || dy > 5 || isPanning) {\r\n                        consumed = true;\r\n                        vTranslate.x = vTranslateStart.x + (event.getX() - vCenterStart.x);\r\n                        vTranslate.y = vTranslateStart.y + (event.getY() - vCenterStart.y);\r\n                        float lastX = vTranslate.x;\r\n                        float lastY = vTranslate.y;\r\n                        fitToBounds(true);\r\n                        if (lastX == vTranslate.x || (lastY == vTranslate.y && dy > 10) || isPanning) {\r\n                            isPanning = true;\r\n                        } else if (dx > 5) {\r\n                            maxTouchCount = 0;\r\n                            handler.removeMessages(MESSAGE_LONG_CLICK);\r\n                            getParent().requestDisallowInterceptTouchEvent(false);\r\n                        }\r\n                        if (!panEnabled) {\r\n                            vTranslate.x = vTranslateStart.x;\r\n                            vTranslate.y = vTranslateStart.y;\r\n                            getParent().requestDisallowInterceptTouchEvent(false);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (consumed) {\r\n                handler.removeMessages(MESSAGE_LONG_CLICK);\r\n                invalidate();\r\n                return true;\r\n            }\r\n            break;\r\n        case MotionEvent.ACTION_UP:\r\n        case MotionEvent.ACTION_POINTER_UP:\r\n        case MotionEvent.ACTION_POINTER_2_UP:\r\n            handler.removeMessages(MESSAGE_LONG_CLICK);\r\n            if (maxTouchCount > 0 && (isZooming || isPanning)) {\r\n                if (isZooming && touchCount == 2) {\r\n                    isPanning = true;\r\n                    vTranslateStart = new PointF(vTranslate.x, vTranslate.y);\r\n                    if (event.getActionIndex() == 1) {\r\n                        vCenterStart = new PointF(event.getX(0), event.getY(0));\r\n                    } else {\r\n                        vCenterStart = new PointF(event.getX(1), event.getY(1));\r\n                    }\r\n                }\r\n                if (touchCount < 3) {\r\n                    isZooming = false;\r\n                }\r\n                if (touchCount < 2) {\r\n                    isPanning = false;\r\n                    maxTouchCount = 0;\r\n                }\r\n                return true;\r\n            }\r\n            if (touchCount == 1) {\r\n                isZooming = false;\r\n                isPanning = false;\r\n                maxTouchCount = 0;\r\n            }\r\n            return true;\r\n    }\r\n    return super.onTouchEvent(event);\r\n}"
}, {
	"Path": "org.lwjgl.examples.spaceinvaders.Game.gameLoop",
	"Comment": "run the main game loop. this method keeps rendering the scene\tand requesting that the callback update its screen.",
	"Method": "void gameLoop(){\r\n    while (Game.gameRunning) {\r\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\r\n        glMatrixMode(GL_MODELVIEW);\r\n        glLoadIdentity();\r\n        frameRendering();\r\n        Display.update();\r\n    }\r\n    soundManager.destroy();\r\n    Display.destroy();\r\n}"
}, {
	"Path": "org.lwjgl.opengles.EGL.eglChooseConfigNum",
	"Comment": "returns the number of eglconfigs that are available on the specified display and\tmatch the speficied list of attributes.",
	"Method": "int eglChooseConfigNum(EGLDisplay dpy,IntBuffer attrib_list){\r\n    checkAttribList(attrib_list);\r\n    IntBuffer num_config = APIUtil.getBufferInt();\r\n    if (!neglChooseConfig(dpy.getPointer(), MemoryUtil.getAddressSafe(attrib_list), 0L, 0, MemoryUtil.getAddress0(num_config)))\r\n        throwEGLError(\"Failed to get EGL configs.\");\r\n    return num_config.get(0);\r\n}"
}, {
	"Path": "com.openhtmltopdf.pdfboxout.PdfBoxSlowOutputDevice.paintBackground",
	"Comment": "we use paintbackground to do extra stuff such as processing links, forms and form controls.",
	"Method": "void paintBackground(RenderingContext c,Box box){\r\n    super.paintBackground(c, box);\r\n    _linkManager.processLinkLater(c, box, _page, _pageHeight, _transform);\r\n    if (box.getElement() != null && box.getElement().getNodeName().equals(\"form\")) {\r\n        _formState.addFormIfRequired(box, this);\r\n    } else if (box.getElement() != null && ArrayUtil.isOneOf(box.getElement().getNodeName(), \"input\", \"textarea\", \"button\", \"select\", \"openhtmltopdf-combo\")) {\r\n        _formState.addControlIfRequired(box, _page, _transform, c, _pageHeight);\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testTransformMultiTranform",
	"Comment": "with single static block, rotate then translate, small page margin, no block margin or padding.",
	"Method": "void testTransformMultiTranform(){\r\n    assertTrue(vt.runTest(\"transform-multi-transform\"));\r\n}"
}, {
	"Path": "org.lwjgl.openal.EFXUtil.isFilterSupported",
	"Comment": "tests openal to see whether the given filter type is supported. this is done by creating afilter of the given type. if creation succeeds the filter is supported.",
	"Method": "boolean isFilterSupported(int filterType){\r\n    switch(filterType) {\r\n        case AL_FILTER_NULL:\r\n        case AL_FILTER_LOWPASS:\r\n        case AL_FILTER_HIGHPASS:\r\n        case AL_FILTER_BANDPASS:\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown or invalid filter type: \" + filterType);\r\n    }\r\n    return testSupportGeneric(FILTER, filterType);\r\n}"
}, {
	"Path": "itdelatrisu.opsu.Opsu.errorAndExit",
	"Comment": "throws an error and exits the application with the given message.",
	"Method": "void errorAndExit(Throwable e,String message,boolean report){\r\n    if (Utils.isJarRunning() && Utils.getRunningDirectory() != null && Utils.getRunningDirectory().getAbsolutePath().indexOf('!') != -1)\r\n        ErrorHandler.error(\"JARs cannot be run from some paths containing the '!' character. \" + \"Please rename the file/directories and try again.\\n\\n\" + \"Path: \" + Utils.getRunningDirectory().getAbsolutePath(), null, false);\r\n    else\r\n        ErrorHandler.error(message, e, report);\r\n    System.exit(1);\r\n}"
}, {
	"Path": "ddf.minim.javasound.MpegAudioFileReader.getAudioFileFormat",
	"Comment": "returns audiofileformat from inputstream and medialength.",
	"Method": "AudioFileFormat getAudioFileFormat(File file,AudioFileFormat getAudioFileFormat,URL url,AudioFileFormat getAudioFileFormat,InputStream inputStream,long mediaLength){\r\n    system.debug(\"MpegAudioFileReader.getAudioFileFormat(InputStream inputStream, long mediaLength): begin\");\r\n    HashMap<String, Object> aff_properties = new HashMap<String, Object>();\r\n    HashMap<String, Object> af_properties = new HashMap<String, Object>();\r\n    int mLength = (int) mediaLength;\r\n    int size = inputStream.available();\r\n    PushbackInputStream pis = new PushbackInputStream(inputStream, MARK_LIMIT);\r\n    byte[] head = new byte[22];\r\n    pis.read(head);\r\n    system.debug(\"InputStream : \" + inputStream + \" =>\" + new String(head));\r\n    if ((head[0] == 'R') && (head[1] == 'I') && (head[2] == 'F') && (head[3] == 'F') && (head[8] == 'W') && (head[9] == 'A') && (head[10] == 'V') && (head[11] == 'E')) {\r\n        system.debug(\"RIFF/WAV stream found\");\r\n        int isPCM = ((head[21] << 8) & 0x0000FF00) | ((head[20]) & 0x00000FF);\r\n        if (weak == null) {\r\n            if (isPCM == 1)\r\n                throw new UnsupportedAudioFileException(\"WAV PCM stream found\");\r\n        }\r\n    } else if ((head[0] == '.') && (head[1] == 's') && (head[2] == 'n') && (head[3] == 'd')) {\r\n        system.debug(\"AU stream found\");\r\n        if (weak == null)\r\n            throw new UnsupportedAudioFileException(\"AU stream found\");\r\n    } else if ((head[0] == 'F') && (head[1] == 'O') && (head[2] == 'R') && (head[3] == 'M') && (head[8] == 'A') && (head[9] == 'I') && (head[10] == 'F') && (head[11] == 'F')) {\r\n        system.debug(\"AIFF stream found\");\r\n        if (weak == null)\r\n            throw new UnsupportedAudioFileException(\"AIFF stream found\");\r\n    } else if (((head[0] == 'M') | (head[0] == 'm')) && ((head[1] == 'A') | (head[1] == 'a')) && ((head[2] == 'C') | (head[2] == 'c'))) {\r\n        system.debug(\"APE stream found\");\r\n        if (weak == null)\r\n            throw new UnsupportedAudioFileException(\"APE stream found\");\r\n    } else if (((head[0] == 'F') | (head[0] == 'f')) && ((head[1] == 'L') | (head[1] == 'l')) && ((head[2] == 'A') | (head[2] == 'a')) && ((head[3] == 'C') | (head[3] == 'c'))) {\r\n        system.debug(\"FLAC stream found\");\r\n        if (weak == null)\r\n            throw new UnsupportedAudioFileException(\"FLAC stream found\");\r\n    } else if (((head[0] == 'I') | (head[0] == 'i')) && ((head[1] == 'C') | (head[1] == 'c')) && ((head[2] == 'Y') | (head[2] == 'y'))) {\r\n        pis.unread(head);\r\n        loadShoutcastInfo(pis, aff_properties);\r\n    } else if (((head[0] == 'O') | (head[0] == 'o')) && ((head[1] == 'G') | (head[1] == 'g')) && ((head[2] == 'G') | (head[2] == 'g'))) {\r\n        system.debug(\"Ogg stream found\");\r\n        if (weak == null)\r\n            throw new UnsupportedAudioFileException(\"Ogg stream found\");\r\n    } else {\r\n        pis.unread(head);\r\n    }\r\n    int nVersion = AudioSystem.NOT_SPECIFIED;\r\n    int nLayer = AudioSystem.NOT_SPECIFIED;\r\n    int nMode = AudioSystem.NOT_SPECIFIED;\r\n    int FrameSize = AudioSystem.NOT_SPECIFIED;\r\n    int nFrequency = AudioSystem.NOT_SPECIFIED;\r\n    int nTotalFrames = AudioSystem.NOT_SPECIFIED;\r\n    float FrameRate = AudioSystem.NOT_SPECIFIED;\r\n    int BitRate = AudioSystem.NOT_SPECIFIED;\r\n    int nChannels = AudioSystem.NOT_SPECIFIED;\r\n    int nHeader = AudioSystem.NOT_SPECIFIED;\r\n    int nTotalMS = AudioSystem.NOT_SPECIFIED;\r\n    boolean nVBR = false;\r\n    AudioFormat.Encoding encoding = null;\r\n    try {\r\n        Bitstream m_bitstream = new Bitstream(pis);\r\n        aff_properties.put(\"mp3.header.pos\", new Integer(m_bitstream.header_pos()));\r\n        Header m_header = m_bitstream.readFrame();\r\n        if (m_header == null) {\r\n            throw new UnsupportedAudioFileException(\"Unable to read mp3 header\");\r\n        }\r\n        nVersion = m_header.version();\r\n        if (nVersion == 2)\r\n            aff_properties.put(\"mp3.version.mpeg\", Float.toString(2.5f));\r\n        else\r\n            aff_properties.put(\"mp3.version.mpeg\", Integer.toString(2 - nVersion));\r\n        nLayer = m_header.layer();\r\n        aff_properties.put(\"mp3.version.layer\", Integer.toString(nLayer));\r\n        nMode = m_header.mode();\r\n        aff_properties.put(\"mp3.mode\", new Integer(nMode));\r\n        nChannels = nMode == 3 ? 1 : 2;\r\n        aff_properties.put(\"mp3.channels\", new Integer(nChannels));\r\n        nVBR = m_header.vbr();\r\n        af_properties.put(\"vbr\", new Boolean(nVBR));\r\n        aff_properties.put(\"mp3.vbr\", new Boolean(nVBR));\r\n        aff_properties.put(\"mp3.vbr.scale\", new Integer(m_header.vbr_scale()));\r\n        FrameSize = m_header.calculate_framesize();\r\n        aff_properties.put(\"mp3.framesize.bytes\", new Integer(FrameSize));\r\n        if (FrameSize < 0) {\r\n            throw new UnsupportedAudioFileException(\"Invalid FrameSize : \" + FrameSize);\r\n        }\r\n        nFrequency = m_header.frequency();\r\n        aff_properties.put(\"mp3.frequency.hz\", new Integer(nFrequency));\r\n        FrameRate = (float) ((1.0 / (m_header.ms_per_frame())) * 1000.0);\r\n        aff_properties.put(\"mp3.framerate.fps\", new Float(FrameRate));\r\n        if (FrameRate < 0) {\r\n            throw new UnsupportedAudioFileException(\"Invalid FrameRate : \" + FrameRate);\r\n        }\r\n        if (mLength != AudioSystem.NOT_SPECIFIED) {\r\n            aff_properties.put(\"mp3.length.bytes\", new Integer(mLength));\r\n            nTotalFrames = m_header.max_number_of_frames(mLength);\r\n            aff_properties.put(\"mp3.length.frames\", new Integer(nTotalFrames));\r\n        }\r\n        BitRate = m_header.bitrate();\r\n        af_properties.put(\"bitrate\", new Integer(BitRate));\r\n        aff_properties.put(\"mp3.bitrate.nominal.bps\", new Integer(BitRate));\r\n        nHeader = m_header.getSyncHeader();\r\n        encoding = sm_aEncodings[nVersion][nLayer - 1];\r\n        aff_properties.put(\"mp3.version.encoding\", encoding.toString());\r\n        if (mLength != AudioSystem.NOT_SPECIFIED) {\r\n            nTotalMS = Math.round(m_header.total_ms(mLength));\r\n            aff_properties.put(\"duration\", new Long((long) nTotalMS * 1000L));\r\n        }\r\n        aff_properties.put(\"mp3.copyright\", new Boolean(m_header.copyright()));\r\n        aff_properties.put(\"mp3.original\", new Boolean(m_header.original()));\r\n        aff_properties.put(\"mp3.crc\", new Boolean(m_header.checksums()));\r\n        aff_properties.put(\"mp3.padding\", new Boolean(m_header.padding()));\r\n        InputStream id3v2 = m_bitstream.getRawID3v2();\r\n        if (id3v2 != null) {\r\n            aff_properties.put(\"mp3.id3tag.v2\", id3v2);\r\n            parseID3v2Frames(id3v2, aff_properties);\r\n        }\r\n        if (TDebug.TraceAudioFileReader)\r\n            TDebug.out(m_header.toString());\r\n    } catch (Exception e) {\r\n        system.debug(\"not a MPEG stream: \" + e.toString());\r\n        throw new UnsupportedAudioFileException(\"not a MPEG stream: \" + e.toString());\r\n    }\r\n    int cVersion = (nHeader >> 19) & 0x3;\r\n    if (cVersion == 1) {\r\n        system.debug(\"not a MPEG stream: wrong version\");\r\n        throw new UnsupportedAudioFileException(\"not a MPEG stream: wrong version\");\r\n    }\r\n    int cSFIndex = (nHeader >> 10) & 0x3;\r\n    if (cSFIndex == 3) {\r\n        system.debug(\"not a MPEG stream: wrong sampling rate\");\r\n        throw new UnsupportedAudioFileException(\"not a MPEG stream: wrong sampling rate\");\r\n    }\r\n    if ((size == mediaLength) && (mediaLength != AudioSystem.NOT_SPECIFIED)) {\r\n        byte[] id3v1 = new byte[128];\r\n        int toSkip = inputStream.available() - id3v1.length;\r\n        if (toSkip > 0) {\r\n            inputStream.skip(inputStream.available() - id3v1.length);\r\n        }\r\n        inputStream.read(id3v1, 0, id3v1.length);\r\n        if ((id3v1[0] == 'T') && (id3v1[1] == 'A') && (id3v1[2] == 'G')) {\r\n            parseID3v1Frames(id3v1, aff_properties);\r\n        }\r\n    }\r\n    AudioFormat format = new // SampleSizeInBits\r\n    MpegAudioFormat(// SampleSizeInBits\r\n    encoding, (float) nFrequency, AudioSystem.NOT_SPECIFIED, nChannels, -1, FrameRate, true, af_properties);\r\n    return new MpegAudioFileFormat(MpegFileFormatType.MP3, format, nTotalFrames, mLength, aff_properties);\r\n}"
}, {
	"Path": "com.j256.ormlite.table.TableUtils.createTable",
	"Comment": "issue the database statements to create the table associated with a table configuration.",
	"Method": "int createTable(ConnectionSource connectionSource,Class<T> dataClass,int createTable,Dao<?, ?> dao,int createTable,ConnectionSource connectionSource,DatabaseTableConfig<T> tableConfig){\r\n    Dao<T, ?> dao = DaoManager.createDao(connectionSource, tableConfig);\r\n    return doCreateTable(dao, false);\r\n}"
}, {
	"Path": "me.imid.swipebacklayout.lib.ViewDragHelper.clampMag",
	"Comment": "clamp the magnitude of value for absmin and absmax. if the value is belowthe minimum, it will be clamped to zero. if the value is above themaximum, it will be clamped to the maximum.",
	"Method": "int clampMag(int value,int absMin,int absMax,float clampMag,float value,float absMin,float absMax){\r\n    final float absValue = Math.abs(value);\r\n    if (absValue < absMin)\r\n        return 0;\r\n    if (absValue > absMax)\r\n        return value > 0 ? absMax : -absMax;\r\n    return value;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.states.SongMenu.getScoreDataForNode",
	"Comment": "returns all the score data for an beatmapsetnode from scoremap.\tif no score data is available for the node, return null.",
	"Method": "ScoreData[] getScoreDataForNode(BeatmapSetNode node,boolean setTimeSince){\r\n    if (scoreMap == null || scoreMap.isEmpty() || node.beatmapIndex == -1)\r\n        return null;\r\n    Beatmap beatmap = node.getSelectedBeatmap();\r\n    ScoreData[] scores = scoreMap.get(beatmap.version);\r\n    if (scores == null || scores.length < 1)\r\n        return null;\r\n    ScoreData s = scores[0];\r\n    if (beatmap.beatmapID == s.MID && beatmap.beatmapSetID == s.MSID && beatmap.title.equals(s.title) && beatmap.artist.equals(s.artist) && beatmap.creator.equals(s.creator)) {\r\n        for (int i = 0; i < scores.length; i++) {\r\n            if (setTimeSince)\r\n                scores[i].getTimeSince();\r\n            scores[i].loadGlyphs();\r\n        }\r\n        return scores;\r\n    } else\r\n        return null;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.Options.loadSkin",
	"Comment": "loads the skin given by the current skin directory.\tif the directory is invalid, the default skin will be loaded.",
	"Method": "void loadSkin(){\r\n    File skinDir = getSkinDir();\r\n    if (skinDir == null)\r\n        skinName = Skin.DEFAULT_SKIN_NAME;\r\n    ResourceLoader.removeAllResourceLocations();\r\n    if (skinDir == null)\r\n        skin = new Skin(null);\r\n    else {\r\n        skin = SkinLoader.loadSkin(skinDir);\r\n        ResourceLoader.addResourceLocation(new FileSystemLocation(skinDir));\r\n    }\r\n    ResourceLoader.addResourceLocation(new ClasspathLocation());\r\n    ResourceLoader.addResourceLocation(new FileSystemLocation(new File(\".\")));\r\n    ResourceLoader.addResourceLocation(new FileSystemLocation(new File(\"./res/\")));\r\n}"
}, {
	"Path": "com.openhtmltopdf.layout.BoxBuilder.reorderTableContent",
	"Comment": "reorganizes a table so that the header is the first row group and thefooter the last.if the table has caption boxes, they will be pulledout and added to an anonymous block box along with the table itself.if not, the table is returned.",
	"Method": "BlockBox reorderTableContent(LayoutContext c,TableBox table){\r\n    List<Box> topCaptions = new ArrayList<Box>();\r\n    Box header = null;\r\n    List<Box> bodies = new ArrayList<Box>();\r\n    Box footer = null;\r\n    List<Box> bottomCaptions = new ArrayList<Box>();\r\n    for (Iterator i = table.getChildIterator(); i.hasNext(); ) {\r\n        Box b = (Box) i.next();\r\n        IdentValue display = b.getStyle().getIdent(CSSName.DISPLAY);\r\n        if (display == IdentValue.TABLE_CAPTION) {\r\n            IdentValue side = b.getStyle().getIdent(CSSName.CAPTION_SIDE);\r\n            if (side == IdentValue.BOTTOM) {\r\n                bottomCaptions.add(b);\r\n            } else {\r\n                topCaptions.add(b);\r\n            }\r\n        } else if (display == IdentValue.TABLE_HEADER_GROUP && header == null) {\r\n            header = b;\r\n        } else if (display == IdentValue.TABLE_FOOTER_GROUP && footer == null) {\r\n            footer = b;\r\n        } else {\r\n            bodies.add(b);\r\n        }\r\n    }\r\n    table.removeAllChildren();\r\n    if (header != null) {\r\n        ((TableSectionBox) header).setHeader(true);\r\n        table.addChild(header);\r\n    }\r\n    table.addAllChildren(bodies);\r\n    if (footer != null) {\r\n        ((TableSectionBox) footer).setFooter(true);\r\n        table.addChild(footer);\r\n    }\r\n    if (topCaptions.size() == 0 && bottomCaptions.size() == 0) {\r\n        return table;\r\n    } else {\r\n        CalculatedStyle anonStyle;\r\n        if (table.getStyle().isFloated()) {\r\n            CascadedStyle cascadedStyle = CascadedStyle.createLayoutStyle(new PropertyDeclaration[] { CascadedStyle.createLayoutPropertyDeclaration(CSSName.DISPLAY, IdentValue.BLOCK), CascadedStyle.createLayoutPropertyDeclaration(CSSName.FLOAT, table.getStyle().getIdent(CSSName.FLOAT)) });\r\n            anonStyle = table.getStyle().deriveStyle(cascadedStyle);\r\n        } else {\r\n            anonStyle = table.getStyle().createAnonymousStyle(IdentValue.BLOCK);\r\n        }\r\n        BlockBox anonBox = new BlockBox();\r\n        anonBox.setStyle(anonStyle);\r\n        anonBox.setAnonymous(true);\r\n        anonBox.setFromCaptionedTable(true);\r\n        anonBox.setElement(table.getElement());\r\n        anonBox.setChildrenContentType(BlockBox.CONTENT_BLOCK);\r\n        anonBox.addAllChildren(topCaptions);\r\n        anonBox.addChild(table);\r\n        anonBox.addAllChildren(bottomCaptions);\r\n        if (table.getStyle().isFloated()) {\r\n            anonBox.setFloatedBoxData(new FloatedBoxData());\r\n            table.setFloatedBoxData(null);\r\n            CascadedStyle original = c.getSharedContext().getCss().getCascadedStyle(table.getElement(), false);\r\n            CascadedStyle modified = CascadedStyle.createLayoutStyle(original, new PropertyDeclaration[] { CascadedStyle.createLayoutPropertyDeclaration(CSSName.FLOAT, IdentValue.NONE) });\r\n            table.setStyle(table.getStyle().getParent().deriveStyle(modified));\r\n        }\r\n        return anonBox;\r\n    }\r\n}"
}, {
	"Path": "ddf.minim.Minim.loadSample",
	"Comment": "loads the requested file into an audiosample.\tby default, the buffer size used is 1024.",
	"Method": "AudioSample loadSample(String filename,AudioSample loadSample,String filename,int bufferSize){\r\n    AudioSample sample = mimp.getAudioSample(filename, bufferSize);\r\n    addSource(sample);\r\n    return sample;\r\n}"
}, {
	"Path": "orestes.bloomfilter.cachesketch.ExpiringBloomFilterRedis.onExpire",
	"Comment": "handler for the expiration queue, removes entry from bloom filter",
	"Method": "void onExpire(ExpiringItem<T> entry){\r\n    this.removeAndEstimateCount(entry.getItem());\r\n}"
}, {
	"Path": "ddf.minim.MultiChannelBuffer.setChannelCount",
	"Comment": "set the number of channels this buffer contains.\tdoing this will retain any existing channels \tunder the new channel count.",
	"Method": "void setChannelCount(int numChannels){\r\n    if (channels.length != numChannels) {\r\n        float[][] newChannels = new float[numChannels][bufferSize];\r\n        for (int c = 0; c < channels.length && c < numChannels; ++c) {\r\n            newChannels[c] = channels[c];\r\n        }\r\n        channels = newChannels;\r\n    }\r\n}"
}, {
	"Path": "org.lwjgl.LibraryPathUtil.getLWJGLLibraryPath",
	"Comment": "returns absolute path of native lwjgl libraries according to\tcurrent operating system, this path is also set as \tsystem property.",
	"Method": "String getLWJGLLibraryPath(BundleContext context){\r\n    String base = getRelativeLWJGLLibraryPath();\r\n    Bundle fragment = context.getBundle();\r\n    URL url = FileLocator.resolve(fragment.getEntry(base));\r\n    File fileDir = new File(url.getPath());\r\n    String path = fileDir.getPath();\r\n    System.setProperty(LWJGL_SYSTEM_PROPERTY, path);\r\n    return path;\r\n}"
}, {
	"Path": "com.android.volley.toolbox.ByteArrayPool.returnBuf",
	"Comment": "returns a buffer to the pool, throwing away old buffers if the pool would exceed its allottedsize.",
	"Method": "void returnBuf(byte[] buf){\r\n    if (buf == null || buf.length > mSizeLimit) {\r\n        return;\r\n    }\r\n    mBuffersByLastUse.add(buf);\r\n    int pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);\r\n    if (pos < 0) {\r\n        pos = -pos - 1;\r\n    }\r\n    mBuffersBySize.add(pos, buf);\r\n    mCurrentSize += buf.length;\r\n    trim();\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testTransformFloatInsideTransform",
	"Comment": "tests that a floated block inside a transformed element does not escape.",
	"Method": "void testTransformFloatInsideTransform(){\r\n    assertTrue(vt.runTest(\"transform-float-inside-transform\"));\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.Configuration.fine",
	"Comment": "used internally to log a message about the class at level fine",
	"Method": "void fine(String msg){\r\n    if (logLevel.intValue() <= Level.FINE.intValue()) {\r\n        println(Level.FINE, msg);\r\n    }\r\n}"
}, {
	"Path": "com.j256.ormlite.stmt.StatementExecutor.buildIterator",
	"Comment": "create and return a selectiterator for the class using the default mapped query for all statement.",
	"Method": "SelectIterator<T, ID> buildIterator(BaseDaoImpl<T, ID> classDao,ConnectionSource connectionSource,int resultFlags,ObjectCache objectCache,SelectIterator<T, ID> buildIterator,BaseDaoImpl<T, ID> classDao,ConnectionSource connectionSource,PreparedStmt<T> preparedStmt,ObjectCache objectCache,int resultFlags){\r\n    DatabaseConnection connection = connectionSource.getReadOnlyConnection(tableInfo.getTableName());\r\n    CompiledStatement compiledStatement = null;\r\n    try {\r\n        compiledStatement = preparedStmt.compile(connection, StatementType.SELECT, resultFlags);\r\n        SelectIterator<T, ID> iterator = new SelectIterator<T, ID>(tableInfo.getDataClass(), classDao, preparedStmt, connectionSource, connection, compiledStatement, preparedStmt.getStatement(), objectCache);\r\n        connection = null;\r\n        compiledStatement = null;\r\n        return iterator;\r\n    } finally {\r\n        IOUtils.closeThrowSqlException(compiledStatement, \"compiled statement\");\r\n        if (connection != null) {\r\n            connectionSource.releaseConnection(connection);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.doContentStart",
	"Comment": "moves the caret in front of the first character of the widget content.",
	"Method": "void doContentStart(){\r\n    setCaretOffset(0, SWT.DEFAULT);\r\n    showCaret();\r\n}"
}, {
	"Path": "org.lwjgl.opencl.APIUtil.getBuffer",
	"Comment": "returns a buffer containing the specified strings as bytes.",
	"Method": "long getBuffer(CharSequence string,long getBuffer,CharSequence string,int offset,long getBuffer,CharSequence[] strings){\r\n    final ByteBuffer buffer = getBufferByte(getTotalLength(strings));\r\n    for (CharSequence string : strings) encode(buffer, string);\r\n    buffer.flip();\r\n    return MemoryUtil.getAddress0(buffer);\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.getLinePixel",
	"Comment": "returns the top pixel, relative to the client area, of a given line.clamps out of ranges index.",
	"Method": "int getLinePixel(int lineIndex){\r\n    checkWidget();\r\n    int lineCount = content.getLineCount();\r\n    lineIndex = Math.max(0, Math.min(lineCount, lineIndex));\r\n    if (isFixedLineHeight()) {\r\n        int lineHeight = renderer.getLineHeight();\r\n        return lineIndex * lineHeight - getVerticalScrollOffset() + topMargin;\r\n    }\r\n    if (lineIndex == topIndex)\r\n        return topIndexY + topMargin;\r\n    int height = topIndexY;\r\n    if (lineIndex > topIndex) {\r\n        for (int i = topIndex; i < lineIndex; i++) {\r\n            height += renderer.getLineHeight(i);\r\n        }\r\n    } else {\r\n        for (int i = topIndex - 1; i >= lineIndex; i--) {\r\n            height -= renderer.getLineHeight(i);\r\n        }\r\n    }\r\n    return height + topMargin;\r\n}"
}, {
	"Path": "ddf.minim.analysis.FourierTransform.getSpectrumReal",
	"Comment": "get the real part of the complex representation of the spectrum.",
	"Method": "float[] getSpectrumReal(){\r\n    return real;\r\n}"
}, {
	"Path": "org.lwjgl.opencl.CLMem.getImageChannelType",
	"Comment": "returns the image channel type. applicable to image objects only.",
	"Method": "int getImageChannelType(){\r\n    return util.getImageInfoFormat(this, 1);\r\n}"
}, {
	"Path": "io.opencensus.exporter.trace.jaeger.JaegerExporterHandlerIntegrationTest.startContainer",
	"Comment": "starts a docker container optionally. for example, skips if docker is unavailable.",
	"Method": "void startContainer(){\r\n    try {\r\n        container = new GenericContainer(JAEGER_IMAGE).withExposedPorts(JAEGER_HTTP_PORT, JAEGER_HTTP_PORT_THRIFT).waitingFor(new HttpWaitStrategy());\r\n        container.start();\r\n    } catch (RuntimeException e) {\r\n        throw new AssumptionViolatedException(\"could not start docker container\", e);\r\n    }\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.OptionsOverlay.getOptionAtPosition",
	"Comment": "returns the option at the given position, using the current scroll offset.",
	"Method": "GameOption getOptionAtPosition(int cx,int cy){\r\n    if (cy < y || cy < textSearchYOffset * 2 + Fonts.LARGE.getLineHeight() || cx < x + optionStartX || cx > x + optionStartX + optionWidth)\r\n        return null;\r\n    int mouseVirtualY = (int) (scrolling.getPosition() + cy - y - optionStartY);\r\n    for (OptionGroup group : groups) {\r\n        if (!group.isVisible())\r\n            continue;\r\n        mouseVirtualY -= optionGroupPadding;\r\n        if (group.getOptions() == null)\r\n            continue;\r\n        for (GameOption option : group.getOptions()) {\r\n            if (!option.isVisible())\r\n                continue;\r\n            if (mouseVirtualY <= optionHeight) {\r\n                if (mouseVirtualY >= 0) {\r\n                    int indicatorPos = (int) (scrolling.getPosition() + cy - mouseVirtualY);\r\n                    if (indicatorPos != this.indicatorPos + indicatorOffsetToNextPos) {\r\n                        this.indicatorPos += indicatorOffsetToNextPos;\r\n                        indicatorOffsetToNextPos = indicatorPos - this.indicatorPos;\r\n                        indicatorMoveAnimationTime = 1;\r\n                    }\r\n                    return option;\r\n                }\r\n                return null;\r\n            }\r\n            mouseVirtualY -= optionHeight;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.special.ResideMenu.ResideMenu.setMenuListener",
	"Comment": "if you need to do something on the action of closing or opening menu, set\tthe listener here.",
	"Method": "void setMenuListener(OnMenuListener menuListener){\r\n    this.menuListener = menuListener;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.ErrorHandler.getIssueURI",
	"Comment": "returns the issue reporting uri with the given title and body.",
	"Method": "URI getIssueURI(String title,String body,URI getIssueURI,String error,Throwable e,String trace){\r\n    String issueTitle = (error != null) ? error : (e.getMessage() != null) ? e.getMessage() : \"null\";\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(getEnvironmentInfoForIssue());\r\n    if (error != null) {\r\n        sb.append(\"**Error:** `\");\r\n        sb.append(error);\r\n        sb.append(\"`\\n\");\r\n    }\r\n    if (trace != null) {\r\n        sb.append(\"**Stack trace:**\");\r\n        sb.append(\"\\n```\\n\");\r\n        sb.append(trace);\r\n        sb.append(\"```\");\r\n    }\r\n    return getIssueURI(issueTitle, sb.toString());\r\n}"
}, {
	"Path": "com.openhtmltopdf.swing.SwingReplacedElementFactory.getForm",
	"Comment": "returns the xhtmlform associated with an element in cache, or null if not found.",
	"Method": "XhtmlForm getForm(Element e){\r\n    if (forms == null) {\r\n        return null;\r\n    }\r\n    return (XhtmlForm) forms.get(e);\r\n}"
}, {
	"Path": "me.imid.swipebacklayout.lib.SwipeBackLayout.setSwipeListener",
	"Comment": "register a callback to be invoked when a swipe event is sent to this\tview.",
	"Method": "void setSwipeListener(SwipeListener listener){\r\n    addSwipeListener(listener);\r\n}"
}, {
	"Path": "io.opencensus.implcore.internal.CurrentState.get",
	"Comment": "returns the current state and updates the status as being read.",
	"Method": "State get(){\r\n    InternalState internalState = currentInternalState.get();\r\n    while (!internalState.isRead) {\r\n        currentInternalState.compareAndSet(internalState, internalState.state == State.ENABLED ? InternalState.ENABLED_READ : InternalState.DISABLED_READ);\r\n        internalState = currentInternalState.get();\r\n    }\r\n    return internalState.state;\r\n}"
}, {
	"Path": "ddf.minim.Minim.setInputMixer",
	"Comment": "when using the javasound implementation of minim, this sets the javasound mixer \tthat will be used for obtaining input sources such as audioinputs.\tthis method will be replaced in a future version.",
	"Method": "void setInputMixer(Mixer mixer){\r\n    if (mimp instanceof JSMinim) {\r\n        ((JSMinim) mimp).setInputMixer(mixer);\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.util.Configuration.valueFor",
	"Comment": "returns the value for key in the configuration, or the default providedvalue if not found. a warning is issued to the log if the property is notdefined, and if the default is null.",
	"Method": "String valueFor(String key,String valueFor,String key,String defaultVal){\r\n    Configuration conf = instance();\r\n    String val = conf.properties.getProperty(key);\r\n    val = (val == null ? defaultVal : val);\r\n    if (val == null) {\r\n        conf.warning(\"CONFIGURATION: no value found for key \" + key + \" and no default given.\");\r\n    }\r\n    return val;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.beatmap.OszUnpacker.getCurrentFileName",
	"Comment": "returns the name of the current file being unpacked, or null if none.",
	"Method": "String getCurrentFileName(){\r\n    if (files == null || fileIndex == -1)\r\n        return null;\r\n    return files[fileIndex].getName();\r\n}"
}, {
	"Path": "org.lwjgl.opengl.GLContext.unloadOpenGLLibrary",
	"Comment": "the opengl library reference count is decremented, and if it reaches 0, the library is unloaded.",
	"Method": "void unloadOpenGLLibrary(){\r\n    gl_ref_count--;\r\n    if (gl_ref_count == 0 && LWJGLUtil.getPlatform() != LWJGLUtil.PLATFORM_LINUX)\r\n        nUnloadOpenGLLibrary();\r\n}"
}, {
	"Path": "com.iwebpp.node.http.IncomingMessage.destroy",
	"Comment": "it, since something else is destroying this connection anyway.",
	"Method": "void destroy(String error){\r\n    if (this.socket != null)\r\n        this.socket.destroy(error);\r\n}"
}, {
	"Path": "orestes.bloomfilter.FilterBuilder.isCompatibleTo",
	"Comment": "checks whether a configuration is compatible to another configuration based on the size of the bloom filter andits hash functions.",
	"Method": "boolean isCompatibleTo(FilterBuilder other){\r\n    return this.size() == other.size() && this.hashes() == other.hashes() && this.hashMethod() == other.hashMethod();\r\n}"
}, {
	"Path": "org.lwjgl.opencl.CLMem.getGLObjectType",
	"Comment": "returns the gl object type. applicable to clmem objects\tthat have been created gl objects only.",
	"Method": "int getGLObjectType(int getGLObjectType,CLMem mem){\r\n    return util.getGLObjectType(this);\r\n}"
}, {
	"Path": "org.lwjgl.util.vector.Matrix4f.negate",
	"Comment": "negate this matrix and place the result in a destination matrix.",
	"Method": "Matrix negate(Matrix4f negate,Matrix4f dest,Matrix4f negate,Matrix4f src,Matrix4f dest){\r\n    if (dest == null)\r\n        dest = new Matrix4f();\r\n    dest.m00 = -src.m00;\r\n    dest.m01 = -src.m01;\r\n    dest.m02 = -src.m02;\r\n    dest.m03 = -src.m03;\r\n    dest.m10 = -src.m10;\r\n    dest.m11 = -src.m11;\r\n    dest.m12 = -src.m12;\r\n    dest.m13 = -src.m13;\r\n    dest.m20 = -src.m20;\r\n    dest.m21 = -src.m21;\r\n    dest.m22 = -src.m22;\r\n    dest.m23 = -src.m23;\r\n    dest.m30 = -src.m30;\r\n    dest.m31 = -src.m31;\r\n    dest.m32 = -src.m32;\r\n    dest.m33 = -src.m33;\r\n    return dest;\r\n}"
}, {
	"Path": "org.newdawn.slick.Image.getColor",
	"Comment": "get the colour of a pixel at a specified location in this image",
	"Method": "Color getColor(int x,int y){\r\n    if (pixelData == null) {\r\n        pixelData = texture.getTextureData();\r\n    }\r\n    int xo = (int) (textureOffsetX * texture.getTextureWidth());\r\n    int yo = (int) (textureOffsetY * texture.getTextureHeight());\r\n    if (textureWidth < 0) {\r\n        x = xo - x;\r\n    } else {\r\n        x = xo + x;\r\n    }\r\n    if (textureHeight < 0) {\r\n        y = yo - y;\r\n    } else {\r\n        y = yo + y;\r\n    }\r\n    int offset = x + (y * texture.getTextureWidth());\r\n    offset *= texture.hasAlpha() ? 4 : 3;\r\n    if (texture.hasAlpha()) {\r\n        return new Color(translate(pixelData[offset]), translate(pixelData[offset + 1]), translate(pixelData[offset + 2]), translate(pixelData[offset + 3]));\r\n    } else {\r\n        return new Color(translate(pixelData[offset]), translate(pixelData[offset + 1]), translate(pixelData[offset + 2]));\r\n    }\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualregressiontests.VisualRegressionTest.testTransformStaticBlockPadding",
	"Comment": "with a static block, rotate, large page margin, no block margin, small padding.",
	"Method": "void testTransformStaticBlockPadding(){\r\n    assertTrue(vt.runTest(\"transform-static-block-padding\"));\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.getApplet",
	"Comment": "retrieves the applet that has been loaded. useful for liveconnect.",
	"Method": "Applet getApplet(){\r\n    return lwjglApplet;\r\n}"
}, {
	"Path": "itdelatrisu.opsu.options.Options.isGameplaySoundDisabled",
	"Comment": "returns whether or not sound effects are disabled during gameplay.",
	"Method": "boolean isGameplaySoundDisabled(){\r\n    return GameOption.DISABLE_GAMEPLAY_SOUNDS.getBooleanValue();\r\n}"
}, {
	"Path": "org.eclipse.swt.custom.StyledText.setLineSpacing",
	"Comment": "sets the line spacing of the widget. the line spacing applies for all lines.",
	"Method": "void setLineSpacing(int lineSpacing){\r\n    checkWidget();\r\n    if (this.lineSpacing == lineSpacing || lineSpacing < 0)\r\n        return;\r\n    this.lineSpacing = lineSpacing;\r\n    setVariableLineHeight();\r\n    resetCache(0, content.getLineCount());\r\n    setCaretLocation();\r\n    super.redraw();\r\n}"
}, {
	"Path": "ddf.minim.SignalSplitter.addListener",
	"Comment": "adds a listener who will be notified each time this receives or creates a new buffer of samples. if the listener has already been added, it will not be added again.",
	"Method": "void addListener(AudioListener listener){\r\n    if (!listeners.contains(listener)) {\r\n        listeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "orestes.bloomfilter.test.comparisons.BloomFilterMagnus.getK",
	"Comment": "returns the value chosen for k.k is the optimal number of hash functions based on the sizeof the bloom filter and the expected number of inserted elements.",
	"Method": "int getK(){\r\n    return k;\r\n}"
}, {
	"Path": "org.lwjgl.util.applet.AppletLoader.loadJarURLs",
	"Comment": "reads list of jars to download and adds the urls to urllist\talso finds out which os you are on and adds appropriate native\tjar to the urllist",
	"Method": "void loadJarURLs(){\r\n    setState(STATE_DETERMINING_PACKAGES);\r\n    String jarList = getParameter(\"al_jars\");\r\n    String nativeJarList = null;\r\n    String osName = System.getProperty(\"os.name\");\r\n    if (osName.startsWith(\"Win\")) {\r\n        if (System.getProperty(\"os.arch\").endsWith(\"64\")) {\r\n            nativeJarList = getParameter(\"al_windows64\");\r\n        } else {\r\n            nativeJarList = getParameter(\"al_windows32\");\r\n        }\r\n        if (nativeJarList == null) {\r\n            nativeJarList = getParameter(\"al_windows\");\r\n        }\r\n    } else if (osName.startsWith(\"Linux\") || osName.startsWith(\"Unix\")) {\r\n        if (System.getProperty(\"os.arch\").endsWith(\"64\")) {\r\n            nativeJarList = getParameter(\"al_linux64\");\r\n        } else {\r\n            nativeJarList = getParameter(\"al_linux32\");\r\n        }\r\n        if (nativeJarList == null) {\r\n            nativeJarList = getParameter(\"al_linux\");\r\n        }\r\n    } else if (osName.startsWith(\"Mac\") || osName.startsWith(\"Darwin\")) {\r\n        if (System.getProperty(\"os.arch\").endsWith(\"64\")) {\r\n            nativeJarList = getParameter(\"al_mac64\");\r\n        } else if (System.getProperty(\"os.arch\").contains(\"ppc\")) {\r\n            nativeJarList = getParameter(\"al_macppc\");\r\n        } else {\r\n            nativeJarList = getParameter(\"al_mac32\");\r\n        }\r\n        if (nativeJarList == null) {\r\n            nativeJarList = getParameter(\"al_mac\");\r\n        }\r\n    } else if (osName.startsWith(\"Solaris\") || osName.startsWith(\"SunOS\")) {\r\n        nativeJarList = getParameter(\"al_solaris\");\r\n    } else if (osName.startsWith(\"FreeBSD\")) {\r\n        nativeJarList = getParameter(\"al_freebsd\");\r\n    } else if (osName.startsWith(\"OpenBSD\")) {\r\n        nativeJarList = getParameter(\"al_openbsd\");\r\n    } else {\r\n        fatalErrorOccured(\"OS (\" + osName + \") not supported\", null);\r\n        return;\r\n    }\r\n    if (nativeJarList == null) {\r\n        fatalErrorOccured(\"no lwjgl natives files found\", null);\r\n        return;\r\n    }\r\n    jarList = trimExtensionByCapabilities(jarList);\r\n    StringTokenizer jars = new StringTokenizer(jarList, \", \");\r\n    nativeJarList = trimExtensionByCapabilities(nativeJarList);\r\n    StringTokenizer nativeJars = new StringTokenizer(nativeJarList, \", \");\r\n    int jarCount = jars.countTokens();\r\n    nativeJarCount = nativeJars.countTokens();\r\n    urlList = new URL[jarCount + nativeJarCount];\r\n    URL path = getCodeBase();\r\n    for (int i = 0; i < jarCount; i++) {\r\n        urlList[i] = new URL(path, jars.nextToken());\r\n    }\r\n    for (int i = jarCount; i < jarCount + nativeJarCount; i++) {\r\n        urlList[i] = new URL(path, nativeJars.nextToken());\r\n    }\r\n}"
}, {
	"Path": "ddf.minim.ugens.Midi2Hz.setMidiNoteIn",
	"Comment": "set the fixed value this will use if midinotein is not patched.",
	"Method": "void setMidiNoteIn(float fixedMidiNoteIn){\r\n    midiNoteIn.setLastValue(fixedMidiNoteIn);\r\n}"
}, {
	"Path": "ddf.minim.ugens.Waves.squareh",
	"Comment": "builds an approximation of a perfect square wave by summing together\tharmonically related sine waves.",
	"Method": "Wavetable squareh(int numberOfHarmonics){\r\n    float[] content = new float[numberOfHarmonics + 1];\r\n    for (int i = 0; i < numberOfHarmonics; i += 2) {\r\n        content[i] = (float) 1 / (i + 1);\r\n        content[i + 1] = 0;\r\n    }\r\n    return WavetableGenerator.gen10(tableSize, content);\r\n}"
}, {
	"Path": "ddf.minim.ugens.GranulateSteady.reset",
	"Comment": "sets the state of this granulate to the very start of a grain. \tuseful for syncing the granulate timing with other audio.",
	"Method": "void reset(){\r\n    timeSinceGrainStart = 0.0f;\r\n    insideGrain = true;\r\n    grainLength = grainLen.getLastValue();\r\n    checkFadeLength();\r\n    fadeLength = fadeLen.getLastValue();\r\n    checkFadeLength();\r\n}"
}, {
	"Path": "ddf.minim.ugens.FilePlayer.isLooping",
	"Comment": "returns true if this is currently playing and has more than one loop \tleft to play.",
	"Method": "boolean isLooping(){\r\n    return mFileStream.getLoopCount() != 0;\r\n}"
}, {
	"Path": "com.openhtmltopdf.visualtest.VisualTester.levelIntensity",
	"Comment": "levels the color intensity to at least 50 and at most maxintensity.",
	"Method": "int levelIntensity(int darkness,int maxIntensity){\r\n    return Math.min(maxIntensity, Math.max(50, darkness));\r\n}"
}]