[{
	"Path": "quickfix.mina.acceptor.DynamicAcceptorSessionProviderTest.testDynamicSessionIsAddedToSessionConnector",
	"Comment": "verify that if a new session comes in it gets added to the list in session connector",
	"Method": "void testDynamicSessionIsAddedToSessionConnector(){\r\n    MySessionConnector connector = new MySessionConnector(settings, null);\r\n    SessionID id1 = new SessionID(\"FIX.4.2\", \"me\", \"SENDERSUB\", \"SENDERLOC\", \"you\", \"TARGETSUB\", \"TARGETLOC\", null);\r\n    Session session = provider.getSession(id1, connector);\r\n    assertEquals(1, connector.sessions.size());\r\n    session = provider.getSession(id1, connector);\r\n    assertEquals(1, connector.sessions.size());\r\n    session.close();\r\n    SessionID id2 = new SessionID(\"FIX.4.2\", \"SENDER2\", \"SENDERSUB\", \"SENDERLOC\", \"TARGET2\", \"TARGETSUB\", \"TARGETLOC\", null);\r\n    Session session2 = provider.getSession(id2, connector);\r\n    assertEquals(2, connector.sessions.size());\r\n    session2.close();\r\n}"
}, {
	"Path": "com.google.gwt.sample.mobilewebapp.client.ui.PieChart.isSupported",
	"Comment": "runtime check for whether the canvas element is supported in this browser.",
	"Method": "boolean isSupported(){\r\n    return Canvas.isSupported();\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.ForceDirectedLayout.getMassValue",
	"Comment": "get the mass value associated with the given node. subclasses shouldoverride this method to perform custom mass assignment.",
	"Method": "float getMassValue(VisualItem n){\r\n    return 1.0f;\r\n}"
}, {
	"Path": "prefuse.data.io.GraphMLWriter.checkGraphMLSchema",
	"Comment": "checks if all schema types are compatible with the graphml specification.the graphml spec only allows the types int,long, float, double,boolean, and string.",
	"Method": "void checkGraphMLSchema(Schema s){\r\n    for (int i = 0; i < s.getColumnCount(); ++i) {\r\n        Class type = s.getColumnType(i);\r\n        if (TYPES.get(type) == null) {\r\n            throw new DataIOException(\"Data type unsupported by the \" + \"GraphML format: \" + type.getName());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.ui.JToggleGroup.setGroupFocusable",
	"Comment": "sets if the various toggle buttons can receive the keyboard focus.",
	"Method": "void setGroupFocusable(boolean b){\r\n    for (int i = 0; i < getComponentCount(); ++i) {\r\n        Component c = getComponent(i);\r\n        if (c instanceof JToggleButton)\r\n            c.setFocusable(b);\r\n    }\r\n}"
}, {
	"Path": "prefuse.Visualization.addDerivedTable",
	"Comment": "add a derived table, a visualtable that is cascaded from anexisting visualtable. this is useful for creating visualitemsthat inherit a set of visual properties from another group ofvisualitems. this might be used, for example, in the creationof small multiples where only a few visual attributes varyacross the multiples.",
	"Method": "VisualTable addDerivedTable(String group,String source,Predicate filter,Schema override){\r\n    VisualTable src = (VisualTable) getGroup(source);\r\n    VisualTable vt = new VisualTable(src, this, group, filter, override);\r\n    addDataGroup(group, vt, getSourceData(source));\r\n    return vt;\r\n}"
}, {
	"Path": "com.restfb.json.Json.parse",
	"Comment": "reads the entire input stream from the given reader and parses it as json. the input must contain a valid jsonvalue, optionally padded with whitespace.characters are read in chunks and buffered internally, therefore wrapping an existing reader in an additionalbufferedreader does not improve reading performance.",
	"Method": "JsonValue parse(String string,JsonValue parse,Reader reader){\r\n    if (reader == null) {\r\n        throw new NullPointerException(READER_IS_NULL);\r\n    }\r\n    return new JsonParser(reader).parse();\r\n}"
}, {
	"Path": "prefuse.activity.ActivityMap.runAfter",
	"Comment": "schedules the activity corresponding to the afterkey to be runimmediately after the completion of the activity corresponding to the beforekey. this method has no scheduling effect on the activitycorresponding to the before key.",
	"Method": "Activity runAfter(String beforeKey,String afterKey){\r\n    Activity before = get(beforeKey);\r\n    Activity after = get(afterKey);\r\n    if (before != null && after != null)\r\n        ActivityManager.scheduleAfter(before, after);\r\n    return after;\r\n}"
}, {
	"Path": "picard.sam.CreateSequenceDictionary.makeSequenceDictionary",
	"Comment": "read all the sequences from the given reference file, and convert into samsequencerecords",
	"Method": "SAMSequenceDictionary makeSequenceDictionary(File referenceFile){\r\n    final ReferenceSequenceFile refSeqFile = ReferenceSequenceFileFactory.getReferenceSequenceFile(referenceFile, TRUNCATE_NAMES_AT_WHITESPACE);\r\n    ReferenceSequence refSeq;\r\n    final List<SAMSequenceRecord> ret = new ArrayList();\r\n    final Set<String> sequenceNames = new HashSet();\r\n    for (int numSequences = 0; numSequences < NUM_SEQUENCES && (refSeq = refSeqFile.nextSequence()) != null; ++numSequences) {\r\n        if (sequenceNames.contains(refSeq.getName())) {\r\n            throw new PicardException(\"Sequence name appears more than once in reference: \" + refSeq.getName());\r\n        }\r\n        sequenceNames.add(refSeq.getName());\r\n        ret.add(makeSequenceRecord(refSeq));\r\n    }\r\n    return new SAMSequenceDictionary(ret);\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAMediaAudio.isAAC",
	"Comment": "returns true if this media uses the aac audio codec, false otherwise.",
	"Method": "boolean isAAC(){\r\n    return getCodecA() != null && getCodecA().equalsIgnoreCase(FormatConfiguration.AAC);\r\n}"
}, {
	"Path": "me.vickychijwani.spectre.auth.LoginOrchestrator.normalizeBlogUrl",
	"Comment": "this function is in loginorchestrator because it is only useful when taking in user input",
	"Method": "String normalizeBlogUrl(String inputBlogUrl){\r\n    return inputBlogUrl.trim().replaceFirst(\"^(.*)/ghost/?$\", \"$1\");\r\n}"
}, {
	"Path": "picard.sam.markduplicates.EstimateLibraryComplexity.getNextGroup",
	"Comment": "pulls out of the iterator the next group of reads that can be compared to each other toidentify duplicates.",
	"Method": "List<PairedReadSequence> getNextGroup(PeekableIterator<PairedReadSequence> iterator){\r\n    final List<PairedReadSequence> group = new ArrayList<PairedReadSequence>();\r\n    final PairedReadSequence first = iterator.next();\r\n    group.add(first);\r\n    outer: while (iterator.hasNext()) {\r\n        final PairedReadSequence next = iterator.peek();\r\n        for (int i = 0; i < MIN_IDENTICAL_BASES; ++i) {\r\n            if (first.read1[i] != next.read1[i] || first.read2[i] != next.read2[i])\r\n                break outer;\r\n        }\r\n        group.add(iterator.next());\r\n    }\r\n    return group;\r\n}"
}, {
	"Path": "prefuse.Visualization.add",
	"Comment": "add a data set to this visualization, using the given data group name.a visual abstraction of the data will be created and registered withthe visualization. an exception will be thrown if the group name isalready in use.",
	"Method": "VisualTupleSet add(String group,TupleSet data,VisualTupleSet add,String group,TupleSet data,Predicate filter){\r\n    if (data instanceof Table) {\r\n        return addTable(group, (Table) data, filter);\r\n    } else if (data instanceof Tree) {\r\n        return addTree(group, (Tree) data, filter);\r\n    } else if (data instanceof Graph) {\r\n        return addGraph(group, (Graph) data, filter);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Unsupported TupleSet type.\");\r\n    }\r\n}"
}, {
	"Path": "cn.hugeterry.ployfun.core.delaunay.ArraySet.containsAny",
	"Comment": "true iff any member of the collection is also in the arrayset.",
	"Method": "boolean containsAny(Collection<?> collection){\r\n    for (Object item : collection) if (this.contains(item))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "prefuse.data.search.LuceneSearcher.getAnalyzer",
	"Comment": "returns the analyzer used to process text. see lucene documentationfor more details.",
	"Method": "Analyzer getAnalyzer(){\r\n    return analyzer;\r\n}"
}, {
	"Path": "picard.util.BaitDesigner.makeBaitName",
	"Comment": "takes a target name and a bait index and creates a uniform bait name.",
	"Method": "String makeBaitName(String targetName,int baitIndex,int totalBaits){\r\n    final String total = fmt.format(totalBaits);\r\n    String bait = fmt.format(baitIndex);\r\n    while (bait.length() < total.length()) bait = \"0\" + bait;\r\n    return targetName + \"_bait#\" + bait;\r\n}"
}, {
	"Path": "prefuse.render.EdgeRenderer.getVerticalAlignment1",
	"Comment": "get the vertical aligment of the edge mount point with the first node.",
	"Method": "int getVerticalAlignment1(){\r\n    return m_yAlign1;\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.ForceDirectedLayout.initSimulator",
	"Comment": "loads the simulator with all relevant force items and springs.",
	"Method": "void initSimulator(ForceSimulator fsim){\r\n    TupleSet ts = m_vis.getGroup(m_nodeGroup);\r\n    if (ts == null)\r\n        return;\r\n    try {\r\n        ts.addColumns(FORCEITEM_SCHEMA);\r\n    } catch (IllegalArgumentException iae) {\r\n    }\r\n    float startX = (referrer == null ? 0f : (float) referrer.getX());\r\n    float startY = (referrer == null ? 0f : (float) referrer.getY());\r\n    startX = Float.isNaN(startX) ? 0f : startX;\r\n    startY = Float.isNaN(startY) ? 0f : startY;\r\n    Iterator iter = m_vis.visibleItems(m_nodeGroup);\r\n    while (iter.hasNext()) {\r\n        VisualItem item = (VisualItem) iter.next();\r\n        ForceItem fitem = (ForceItem) item.get(FORCEITEM);\r\n        fitem.mass = getMassValue(item);\r\n        double x = item.getEndX();\r\n        double y = item.getEndY();\r\n        fitem.location[0] = (Double.isNaN(x) ? startX : (float) x);\r\n        fitem.location[1] = (Double.isNaN(y) ? startY : (float) y);\r\n        fsim.addItem(fitem);\r\n    }\r\n    if (m_edgeGroup != null) {\r\n        iter = m_vis.visibleItems(m_edgeGroup);\r\n        while (iter.hasNext()) {\r\n            EdgeItem e = (EdgeItem) iter.next();\r\n            NodeItem n1 = e.getSourceItem();\r\n            ForceItem f1 = (ForceItem) n1.get(FORCEITEM);\r\n            NodeItem n2 = e.getTargetItem();\r\n            ForceItem f2 = (ForceItem) n2.get(FORCEITEM);\r\n            float coeff = getSpringCoefficient(e);\r\n            float slen = getSpringLength(e);\r\n            fsim.addSpring(f1, f2, (coeff >= 0 ? coeff : -1.f), (slen >= 0 ? slen : -1.f));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.render.EdgeRenderer.getVerticalAlignment2",
	"Comment": "get the vertical aligment of the edge mount point with the second node.",
	"Method": "int getVerticalAlignment2(){\r\n    return m_yAlign2;\r\n}"
}, {
	"Path": "py4j.Base64.decode",
	"Comment": "decodes a base64 encoded char array. all illegal characters will be\tignored and can handle both arrays with and without line separators.",
	"Method": "byte[] decode(byte[] sArr,byte[] decode,byte[] sArr,int sOff,int sLen,byte[] decode,char[] sArr,byte[] decode,String str){\r\n    int sLen = str != null ? str.length() : 0;\r\n    if (sLen == 0)\r\n        return new byte[0];\r\n    int sepCnt = 0;\r\n    for (// base64 this loop can be commented out.\r\n    int i = 0; // base64 this loop can be commented out.\r\n    i < sLen; i++) if (IA[str.charAt(i)] < 0)\r\n        sepCnt++;\r\n    if ((sLen - sepCnt) % 4 != 0)\r\n        return null;\r\n    int pad = 0;\r\n    for (int i = sLen; i > 1 && IA[str.charAt(--i)] <= 0; ) if (str.charAt(i) == '=')\r\n        pad++;\r\n    int len = ((sLen - sepCnt) * 6 >> 3) - pad;\r\n    byte[] dArr = new byte[len];\r\n    for (int s = 0, d = 0; d < len; ) {\r\n        int i = 0;\r\n        for (int j = 0; j < 4; j++) {\r\n            int c = IA[str.charAt(s++)];\r\n            if (c >= 0)\r\n                i |= c << (18 - j * 6);\r\n            else\r\n                j--;\r\n        }\r\n        dArr[d++] = (byte) (i >> 16);\r\n        if (d < len) {\r\n            dArr[d++] = (byte) (i >> 8);\r\n            if (d < len)\r\n                dArr[d++] = (byte) i;\r\n        }\r\n    }\r\n    return dArr;\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.setSystemUpdateId",
	"Comment": "sets the update counter for all resources. when all resources need\tto be refreshed, this counter should be updated.",
	"Method": "void setSystemUpdateId(int systemUpdateId){\r\n    DLNAResource.systemUpdateId = systemUpdateId;\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.getSystemUpdateId",
	"Comment": "returns the update counter for all resources. when all resources need\tto be refreshed, this counter is updated.",
	"Method": "int getSystemUpdateId(){\r\n    return systemUpdateId;\r\n}"
}, {
	"Path": "org.pcollections.AmortizedPQueue.offer",
	"Comment": "these 2 methods are not applicable to a persistent collection.",
	"Method": "boolean offer(E o){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "prefuse.data.util.TableIterator.canGetFloat",
	"Comment": "check if the given data field can return primitive floatvalues.",
	"Method": "boolean canGetFloat(String field){\r\n    return m_table.canGetFloat(field);\r\n}"
}, {
	"Path": "peergos.shared.util.EfficientHashMap.plugHole",
	"Comment": "tricky, we left a hole in the map, which we have to fill. the only way todo this is to search forwards through the map shuffling back values thatmatch this index until we hit a null.",
	"Method": "void plugHole(int hole){\r\n    int index = hole + 1;\r\n    if (index == keys.length) {\r\n        index = 0;\r\n    }\r\n    while (keys[index] != null) {\r\n        int targetIndex = getKeyIndex(unmaskNullKey(keys[index]));\r\n        if (hole < index) {\r\n            if (!(hole < targetIndex && targetIndex <= index)) {\r\n                keys[hole] = keys[index];\r\n                values[hole] = values[index];\r\n                keys[index] = null;\r\n                values[index] = null;\r\n                hole = index;\r\n            }\r\n        } else {\r\n            if (index < targetIndex && targetIndex <= hole) {\r\n                keys[hole] = keys[index];\r\n                values[hole] = values[index];\r\n                keys[index] = null;\r\n                values[index] = null;\r\n                hole = index;\r\n            }\r\n        }\r\n        if (++index == keys.length) {\r\n            index = 0;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.Display.printComponent",
	"Comment": "paints the graph to the provided graphics context, for output to aprinter.this method does not double buffer the painting, in order toprovide the maximum print quality.this method may not be working correctly,and will be repaired at a later date.",
	"Method": "void printComponent(Graphics g){\r\n    boolean wasHighQuality = m_highQuality;\r\n    try {\r\n        m_highQuality = true;\r\n        paintDisplay((Graphics2D) g, getSize());\r\n    } finally {\r\n        m_highQuality = wasHighQuality;\r\n    }\r\n}"
}, {
	"Path": "picard.analysis.TheoreticalSensitivity.calculateSensitivities",
	"Comment": "this is a utility function to calculate the metrics specific to runningtheoretical sensitivity over several different allele fractions.",
	"Method": "List<TheoreticalSensitivityMetrics> calculateSensitivities(int simulationSize,Histogram<Integer> depthHistogram,Histogram<Integer> baseQHistogram,List<Double> alleleFractions){\r\n    final List<TheoreticalSensitivityMetrics> metricsOverVariousAlleleFractions = new ArrayList();\r\n    final double logOddsThreshold = 6.2;\r\n    for (final double alleleFraction : alleleFractions) {\r\n        final TheoreticalSensitivityMetrics theoreticalSensitivityMetrics = new TheoreticalSensitivityMetrics();\r\n        theoreticalSensitivityMetrics.ALLELE_FRACTION = alleleFraction;\r\n        theoreticalSensitivityMetrics.THEORETICAL_SENSITIVITY = TheoreticalSensitivity.theoreticalSensitivity(depthHistogram, baseQHistogram, simulationSize, logOddsThreshold, alleleFraction);\r\n        theoreticalSensitivityMetrics.THEORETICAL_SENSITIVITY_Q = QualityUtil.getPhredScoreFromErrorProbability((1 - theoreticalSensitivityMetrics.THEORETICAL_SENSITIVITY));\r\n        theoreticalSensitivityMetrics.SAMPLE_SIZE = simulationSize;\r\n        theoreticalSensitivityMetrics.LOG_ODDS_THRESHOLD = logOddsThreshold;\r\n        metricsOverVariousAlleleFractions.add(theoreticalSensitivityMetrics);\r\n    }\r\n    return metricsOverVariousAlleleFractions;\r\n}"
}, {
	"Path": "com.restfb.json.ParseException.getOffset",
	"Comment": "returns the absolute index of the character at which the error occurred. the index of the first character of adocument is 0.",
	"Method": "int getOffset(){\r\n    return offset;\r\n}"
}, {
	"Path": "prefuse.Display.rotateAbs",
	"Comment": "rotates the view provided by this display by the given angle in radians,anchoring the rotation at the specified point in absolute coordinates.",
	"Method": "void rotateAbs(Point2D p,double theta){\r\n    double zx = p.getX(), zy = p.getY();\r\n    damageReport();\r\n    m_transform.translate(zx, zy);\r\n    m_transform.rotate(theta);\r\n    m_transform.translate(-zx, -zy);\r\n    try {\r\n        m_itransform = m_transform.createInverse();\r\n    } catch (Exception e) {\r\n    }\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.stopPlaying",
	"Comment": "plugin implementation. when this item is going to stop playing, it will notify all the startstoplistener\tobjects available.",
	"Method": "void stopPlaying(String rendererId){\r\n    final DLNAResource self = this;\r\n    final String requestId = getRequestId(rendererId);\r\n    Runnable defer = new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                Thread.sleep(STOP_PLAYING_DELAY);\r\n            } catch (InterruptedException e) {\r\n                logger.error(\"stopPlaying sleep interrupted\", e);\r\n            }\r\n            synchronized (requestIdToRefcount) {\r\n                final Integer refCount = requestIdToRefcount.get(requestId);\r\n                assert refCount != null;\r\n                assert refCount > 0;\r\n                requestIdToRefcount.put(requestId, refCount - 1);\r\n                Runnable r = new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        if (refCount == 1) {\r\n                            InetAddress rendererIpAddress;\r\n                            try {\r\n                                rendererIpAddress = InetAddress.getByName(rendererId);\r\n                                RendererConfiguration renderer = RendererConfiguration.getRendererConfigurationBySocketAddress(rendererIpAddress);\r\n                                String rendererName = \"unknown renderer\";\r\n                                try {\r\n                                    rendererName = renderer.getRendererName();\r\n                                } catch (NullPointerException e) {\r\n                                }\r\n                                logger.info(\"Stopped sending {} to {} on {}\", getSystemName(), rendererName, rendererId);\r\n                            } catch (UnknownHostException ex) {\r\n                                logger.debug(\"\" + ex);\r\n                            }\r\n                            PMS.get().getFrame().setStatusLine(\"\");\r\n                            for (final ExternalListener listener : ExternalFactory.getExternalListeners()) {\r\n                                if (listener instanceof StartStopListener) {\r\n                                    Runnable fireStartStopEvent = new Runnable() {\r\n                                        @Override\r\n                                        public void run() {\r\n                                            try {\r\n                                                ((StartStopListener) listener).donePlaying(getMedia(), self);\r\n                                            } catch (Throwable t) {\r\n                                                logger.error(\"Notification of donePlaying event failed for StartStopListener {}\", listener.getClass(), t);\r\n                                            }\r\n                                        }\r\n                                    };\r\n                                    new Thread(fireStartStopEvent, \"StopPlaying Event for \" + listener.name()).start();\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                };\r\n                new Thread(r, \"StopPlaying Event\").start();\r\n            }\r\n        }\r\n    };\r\n    new Thread(defer, \"StopPlaying Event Deferrer\").start();\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.stopPlaying",
	"Comment": "plugin implementation. when this item is going to stop playing, it will notify all the startstoplistener\tobjects available.",
	"Method": "void stopPlaying(String rendererId){\r\n    try {\r\n        Thread.sleep(STOP_PLAYING_DELAY);\r\n    } catch (InterruptedException e) {\r\n        logger.error(\"stopPlaying sleep interrupted\", e);\r\n    }\r\n    synchronized (requestIdToRefcount) {\r\n        final Integer refCount = requestIdToRefcount.get(requestId);\r\n        assert refCount != null;\r\n        assert refCount > 0;\r\n        requestIdToRefcount.put(requestId, refCount - 1);\r\n        Runnable r = new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                if (refCount == 1) {\r\n                    InetAddress rendererIpAddress;\r\n                    try {\r\n                        rendererIpAddress = InetAddress.getByName(rendererId);\r\n                        RendererConfiguration renderer = RendererConfiguration.getRendererConfigurationBySocketAddress(rendererIpAddress);\r\n                        String rendererName = \"unknown renderer\";\r\n                        try {\r\n                            rendererName = renderer.getRendererName();\r\n                        } catch (NullPointerException e) {\r\n                        }\r\n                        logger.info(\"Stopped sending {} to {} on {}\", getSystemName(), rendererName, rendererId);\r\n                    } catch (UnknownHostException ex) {\r\n                        logger.debug(\"\" + ex);\r\n                    }\r\n                    PMS.get().getFrame().setStatusLine(\"\");\r\n                    for (final ExternalListener listener : ExternalFactory.getExternalListeners()) {\r\n                        if (listener instanceof StartStopListener) {\r\n                            Runnable fireStartStopEvent = new Runnable() {\r\n                                @Override\r\n                                public void run() {\r\n                                    try {\r\n                                        ((StartStopListener) listener).donePlaying(getMedia(), self);\r\n                                    } catch (Throwable t) {\r\n                                        logger.error(\"Notification of donePlaying event failed for StartStopListener {}\", listener.getClass(), t);\r\n                                    }\r\n                                }\r\n                            };\r\n                            new Thread(fireStartStopEvent, \"StopPlaying Event for \" + listener.name()).start();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        new Thread(r, \"StopPlaying Event\").start();\r\n    }\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.stopPlaying",
	"Comment": "plugin implementation. when this item is going to stop playing, it will notify all the startstoplistener\tobjects available.",
	"Method": "void stopPlaying(String rendererId){\r\n    if (refCount == 1) {\r\n        InetAddress rendererIpAddress;\r\n        try {\r\n            rendererIpAddress = InetAddress.getByName(rendererId);\r\n            RendererConfiguration renderer = RendererConfiguration.getRendererConfigurationBySocketAddress(rendererIpAddress);\r\n            String rendererName = \"unknown renderer\";\r\n            try {\r\n                rendererName = renderer.getRendererName();\r\n            } catch (NullPointerException e) {\r\n            }\r\n            logger.info(\"Stopped sending {} to {} on {}\", getSystemName(), rendererName, rendererId);\r\n        } catch (UnknownHostException ex) {\r\n            logger.debug(\"\" + ex);\r\n        }\r\n        PMS.get().getFrame().setStatusLine(\"\");\r\n        for (final ExternalListener listener : ExternalFactory.getExternalListeners()) {\r\n            if (listener instanceof StartStopListener) {\r\n                Runnable fireStartStopEvent = new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        try {\r\n                            ((StartStopListener) listener).donePlaying(getMedia(), self);\r\n                        } catch (Throwable t) {\r\n                            logger.error(\"Notification of donePlaying event failed for StartStopListener {}\", listener.getClass(), t);\r\n                        }\r\n                    }\r\n                };\r\n                new Thread(fireStartStopEvent, \"StopPlaying Event for \" + listener.name()).start();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.stopPlaying",
	"Comment": "plugin implementation. when this item is going to stop playing, it will notify all the startstoplistener\tobjects available.",
	"Method": "void stopPlaying(String rendererId){\r\n    try {\r\n        ((StartStopListener) listener).donePlaying(getMedia(), self);\r\n    } catch (Throwable t) {\r\n        logger.error(\"Notification of donePlaying event failed for StartStopListener {}\", listener.getClass(), t);\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.Graph.neighbors",
	"Comment": "get an iterator over all neighbor nodes for the given node in the graph.",
	"Method": "Iterator neighbors(Node n){\r\n    return new NeighborIterator(n, edges(n));\r\n}"
}, {
	"Path": "picard.util.BaitDesigner.writePoolFiles",
	"Comment": "writes out fasta files for each pool and also agilent format files if requested.",
	"Method": "void writePoolFiles(File dir,String basename,IntervalList baits){\r\n    final int copies;\r\n    if (FILL_POOLS && baits.size() < POOL_SIZE)\r\n        copies = (int) Math.floor(POOL_SIZE / (double) baits.size());\r\n    else\r\n        copies = 1;\r\n    int written = 0;\r\n    int nextPool = 0;\r\n    BufferedWriter out = null;\r\n    BufferedWriter agilentOut = null;\r\n    final String prefix = DESIGN_NAME.substring(0, Math.min(DESIGN_NAME.length(), 8)) + \"_\";\r\n    final NumberFormat fmt = new DecimalFormat(\"000000\");\r\n    try {\r\n        for (int i = 0; i < copies; ++i) {\r\n            final boolean rc = i % 2 == 1;\r\n            int baitId = 1;\r\n            for (final Interval interval : baits) {\r\n                final Bait bait = (Bait) interval;\r\n                if (written++ % POOL_SIZE == 0) {\r\n                    if (out != null)\r\n                        out.close();\r\n                    if (agilentOut != null)\r\n                        agilentOut.close();\r\n                    final String filename = basename + \".pool\" + nextPool++ + \".design.\";\r\n                    out = IOUtil.openFileForBufferedWriting(new File(dir, filename + \"fasta\"));\r\n                    if (OUTPUT_AGILENT_FILES) {\r\n                        agilentOut = IOUtil.openFileForBufferedWriting(new File(dir, filename + \"txt\"));\r\n                    }\r\n                }\r\n                writeBaitFasta(out, interval, rc);\r\n                if (OUTPUT_AGILENT_FILES) {\r\n                    agilentOut.append(prefix).append(fmt.format(baitId++));\r\n                    agilentOut.append(\"\\t\");\r\n                    agilentOut.append(getBaitSequence(bait, rc).toUpperCase());\r\n                    agilentOut.newLine();\r\n                }\r\n            }\r\n        }\r\n        CloserUtil.close(out);\r\n        CloserUtil.close(agilentOut);\r\n    } catch (Exception e) {\r\n        throw new PicardException(\"Error while writing pool files.\", e);\r\n    }\r\n}"
}, {
	"Path": "net.pms.test.formats.FormatFactoryTest.testSingleFormat",
	"Comment": "verify if a filename is recognized as a given format. use\tnull as formatname when no match is expected.",
	"Method": "void testSingleFormat(String filename,String formatName){\r\n    Format result = FormatFactory.getAssociatedExtension(filename);\r\n    if (result != null) {\r\n        assertEquals(\"\\\"\" + filename + \"\\\" is expected to match\", formatName, result.toString());\r\n    } else {\r\n        assertNull(\"\\\"\" + filename + \"\\\" is expected to match nothing\", formatName);\r\n    }\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.ContactDatabase.queryContactsByCategoryAndFirstName",
	"Comment": "query all contacts for the specified category that begin with the specifiedfirst name prefix.",
	"Method": "List<ContactInfo> queryContactsByCategoryAndFirstName(Category category,String firstNamePrefix){\r\n    List<ContactInfo> matches = new ArrayList<ContactInfo>();\r\n    for (ContactInfo contact : dataProvider.getList()) {\r\n        if (contact.getCategory() == category && contact.getFirstName().startsWith(firstNamePrefix)) {\r\n            matches.add(contact);\r\n        }\r\n    }\r\n    return matches;\r\n}"
}, {
	"Path": "peergos.shared.cbor.CborDecoder.readMajorType",
	"Comment": "reads the next major type from the underlying input stream, and verifies whether it matches the given expectation.",
	"Method": "int readMajorType(int majorType){\r\n    int ib = m_is.read();\r\n    if (majorType != ((ib >>> 5) & 0x07)) {\r\n        fail(\"Unexpected type: %s, expected: %s!\", getName(ib), getName(majorType));\r\n    }\r\n    return ib & 0x1F;\r\n}"
}, {
	"Path": "picard.sam.markduplicates.util.MarkQueue.updateDuplicationMetrics",
	"Comment": "updates the duplication metrics given the provided duplicate",
	"Method": "void updateDuplicationMetrics(ReadEndsForMateCigar duplicate,DuplicationMetrics metrics){\r\n    if (!duplicate.getRecord().getReadPairedFlag() || duplicate.getRecord().getMateUnmappedFlag()) {\r\n        ++metrics.UNPAIRED_READ_DUPLICATES;\r\n    } else {\r\n        ++metrics.READ_PAIR_DUPLICATES;\r\n    }\r\n    this.numDuplicates++;\r\n}"
}, {
	"Path": "prefuse.data.Table.canSetFloat",
	"Comment": "check if the setfloat method can safely be used for thegiven data field.",
	"Method": "boolean canSetFloat(String field){\r\n    Column col = getColumn(field);\r\n    return (col == null ? false : col.canSetFloat());\r\n}"
}, {
	"Path": "com.goodiebag.pinview.Pinview.updateEnabledState",
	"Comment": "disable views ahead of current focus, so a selector can change the drawing of those views.",
	"Method": "void updateEnabledState(){\r\n    int currentTag = Math.max(0, getIndexOfCurrentFocus());\r\n    for (int index = 0; index < editTextList.size(); index++) {\r\n        EditText editText = editTextList.get(index);\r\n        editText.setEnabled(index <= currentTag);\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.collections.IntObjectHashMap.rehash",
	"Comment": "rehashes the contents of the receiver into a new table with a smaller orlarger capacity. this method is called automatically when the number ofkeys in the receiver exceeds the high water mark or falls below the lowwater mark.",
	"Method": "void rehash(int newCapacity){\r\n    int oldCapacity = table.length;\r\n    int[] oldTable = table;\r\n    Object[] oldValues = values;\r\n    byte[] oldState = state;\r\n    int[] newTable = new int[newCapacity];\r\n    Object[] newValues = new Object[newCapacity];\r\n    byte[] newState = new byte[newCapacity];\r\n    this.lowWaterMark = chooseLowWaterMark(newCapacity, this.minLoadFactor);\r\n    this.highWaterMark = chooseHighWaterMark(newCapacity, this.maxLoadFactor);\r\n    this.table = newTable;\r\n    this.values = newValues;\r\n    this.state = newState;\r\n    this.freeEntries = newCapacity - this.distinct;\r\n    for (int i = oldCapacity; i-- > 0; ) {\r\n        if (oldState[i] == FULL) {\r\n            int element = oldTable[i];\r\n            int index = indexOfInsertion(element);\r\n            newTable[index] = element;\r\n            newValues[index] = oldValues[i];\r\n            newState[index] = FULL;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getAssScale",
	"Comment": "returns the font scale used for ass subtitling. default value is 1.4.",
	"Method": "String getAssScale(){\r\n    return getString(KEY_ASS_SCALE, \"1.4\");\r\n}"
}, {
	"Path": "picard.sam.CleanSam.doWork",
	"Comment": "do the work after command line has been parsed.runtimeexception may be thrown by this method, and are reported appropriately.",
	"Method": "int doWork(){\r\n    IOUtil.assertFileIsReadable(INPUT);\r\n    IOUtil.assertFileIsWritable(OUTPUT);\r\n    final SamReaderFactory factory = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE);\r\n    if (VALIDATION_STRINGENCY == ValidationStringency.STRICT) {\r\n        factory.validationStringency(ValidationStringency.LENIENT);\r\n    }\r\n    final SamReader reader = factory.open(INPUT);\r\n    final SAMFileWriter writer = new SAMFileWriterFactory().makeSAMOrBAMWriter(reader.getFileHeader(), true, OUTPUT);\r\n    final CloseableIterator<SAMRecord> it = reader.iterator();\r\n    final ProgressLogger progress = new ProgressLogger(Log.getInstance(CleanSam.class));\r\n    while (it.hasNext()) {\r\n        final SAMRecord rec = it.next();\r\n        AbstractAlignmentMerger.createNewCigarsIfMapsOffEndOfReference(rec);\r\n        if (rec.getReadUnmappedFlag() && 0 != rec.getMappingQuality()) {\r\n            rec.setMappingQuality(0);\r\n        }\r\n        writer.addAlignment(rec);\r\n        progress.record(rec);\r\n    }\r\n    writer.close();\r\n    it.close();\r\n    CloserUtil.close(reader);\r\n    return 0;\r\n}"
}, {
	"Path": "net.pms.configuration.WindowsDefaultPaths.getBinariesPath",
	"Comment": "returns the path where binaries can be found. this path differs between\tthe build phase and the test phase. the path will end with a slash unless\tit is empty.",
	"Method": "String getBinariesPath(){\r\n    String path = PropertiesUtil.getProjectProperties().get(\"project.binaries.dir\");\r\n    if (isNotBlank(path)) {\r\n        if (path.endsWith(\"/\")) {\r\n            return path;\r\n        } else {\r\n            return path + \"/\";\r\n        }\r\n    } else {\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "net.pms.xmlwise.XmlElement.removeAttribute",
	"Comment": "convenience method to remove an attribute from this element.",
	"Method": "boolean removeAttribute(String attribute){\r\n    return m_attributes.remove(attribute) != null;\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.removeChild",
	"Comment": "unsupported operation. spanning trees should not be edited.",
	"Method": "boolean removeChild(int node,boolean removeChild,Node n){\r\n    throw new UnsupportedOperationException(\"Changes to tree structure not allowed for spanning trees.\");\r\n}"
}, {
	"Path": "me.vickychijwani.spectre.model.entity.PendingAction.equals",
	"Comment": "todo remember to update equals, parcelable methods, and db migration whenever fields are changed!",
	"Method": "boolean equals(Object o){\r\n    if (this == o)\r\n        return true;\r\n    if (o == null || getClass() != o.getClass())\r\n        return false;\r\n    PendingAction that = (PendingAction) o;\r\n    return getType() != null ? getType().equals(that.getType()) : that.getType() == null;\r\n}"
}, {
	"Path": "com.google.gwt.sample.mail.client.Mail.onModuleLoad",
	"Comment": "this method constructs the application user interface by instantiatingcontrols and hooking up event handler.",
	"Method": "void onModuleLoad(){\r\n    GWT.<GlobalResources>create(GlobalResources.class).css().ensureInjected();\r\n    DockLayoutPanel outer = binder.createAndBindUi(this);\r\n    Window.enableScrolling(false);\r\n    Window.setMargin(\"0px\");\r\n    Element topElem = outer.getWidgetContainerElement(topPanel);\r\n    topElem.getStyle().setZIndex(2);\r\n    topElem.getStyle().setOverflow(Overflow.VISIBLE);\r\n    mailList.setListener(new MailList.Listener() {\r\n        public void onItemSelected(MailItem item) {\r\n            mailDetail.setItem(item);\r\n        }\r\n    });\r\n    RootLayoutPanel root = RootLayoutPanel.get();\r\n    root.add(outer);\r\n}"
}, {
	"Path": "com.google.gwt.sample.mail.client.Mail.onModuleLoad",
	"Comment": "this method constructs the application user interface by instantiatingcontrols and hooking up event handler.",
	"Method": "void onModuleLoad(){\r\n    mailDetail.setItem(item);\r\n}"
}, {
	"Path": "picard.sam.markduplicates.util.MarkQueue.getLocations",
	"Comment": "returns the nonduplicatereadendsset of read ends that should be considered for tracking optical duplicates.",
	"Method": "Set<ReadEnds> getLocations(ReadEndsForMateCigar current){\r\n    if (!shouldBeInLocations(current))\r\n        throw new PicardException(\"Not implemented\");\r\n    final Set<ReadEnds> locationSet = current.getReadEndSetForOpticalDuplicates();\r\n    if (null == locationSet)\r\n        throw new PicardException(\"Locations was empty: unexpected error\");\r\n    return locationSet;\r\n}"
}, {
	"Path": "prefuse.data.util.TableIterator.canSetInt",
	"Comment": "check if the setint method can safely be used for thegiven data field.",
	"Method": "boolean canSetInt(String field){\r\n    return m_table.canSetInt(field);\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.canGetBoolean",
	"Comment": "indicates if convenience get method can be called withoutan exception being thrown for the boolean type.",
	"Method": "boolean canGetBoolean(){\r\n    return canGet(boolean.class);\r\n}"
}, {
	"Path": "org.quickfixj.codegenerator.GenerateMojo.setSchemaDirectory",
	"Comment": "sets the directory containing schemas for code generation.",
	"Method": "void setSchemaDirectory(File schemaDirectory){\r\n    this.schemaDirectory = schemaDirectory;\r\n}"
}, {
	"Path": "prefuse.data.io.FixedWidthTextTableSchema.getColumnStart",
	"Comment": "gets the starting character number for the given column index",
	"Method": "int getColumnStart(int idx){\r\n    return cols[idx];\r\n}"
}, {
	"Path": "java.nio.Buffer.limit",
	"Comment": "sets the limit of this buffer.\tif the current position in the buffer is in excess of newlimit then, on returning from this call, it will have\tbeen adjusted to be equivalent to newlimit. if the mark is set and is greater than the new limit, then it is\tcleared.",
	"Method": "int limit(Buffer limit,int newLimit){\r\n    if (newLimit < 0 || newLimit > capacity) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    limit = newLimit;\r\n    if (position > newLimit) {\r\n        position = newLimit;\r\n    }\r\n    if ((mark != UNSET_MARK) && (mark > newLimit)) {\r\n        mark = UNSET_MARK;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getMencoderNoAssOutline",
	"Comment": "returns the subfont outline parameter used for subtitling without ass.\tdefault value is 1.",
	"Method": "String getMencoderNoAssOutline(){\r\n    return getString(KEY_MENCODER_NOASS_OUTLINE, \"1\");\r\n}"
}, {
	"Path": "me.vickychijwani.spectre.util.Pair.create",
	"Comment": "convenience method for creating an appropriately typed pair.",
	"Method": "Pair<A, B> create(A a,B b){\r\n    return new Pair<A, B>(a, b);\r\n}"
}, {
	"Path": "quickfix.DayConverter.toString",
	"Comment": "convert a day offset into a day name. this method handlesinternational week day names based on the default locale.",
	"Method": "String toString(int dayOffset){\r\n    String[] dayNames = new DateFormatSymbols(Locale.US).getWeekdays();\r\n    if (dayOffset > 0 && dayOffset < dayNames.length) {\r\n        return dayNames[dayOffset].toLowerCase();\r\n    }\r\n    throw new ConfigError(\"invalid offset for day: \" + dayOffset);\r\n}"
}, {
	"Path": "picard.util.RExecutor.writeScriptFile",
	"Comment": "writes the classpath resource named by rscriptname to the temp dir.",
	"Method": "File writeScriptFile(String rScriptName){\r\n    InputStream scriptStream = null;\r\n    OutputStream scriptFileStream = null;\r\n    try {\r\n        scriptStream = RExecutor.class.getClassLoader().getResourceAsStream(rScriptName);\r\n        if (scriptStream == null) {\r\n            throw new IllegalArgumentException(\"Script [\" + rScriptName + \"] not found in classpath\");\r\n        }\r\n        final File scriptFile = File.createTempFile(\"script\", \".R\");\r\n        scriptFileStream = IOUtil.openFileForWriting(scriptFile);\r\n        IOUtil.copyStream(scriptStream, scriptFileStream);\r\n        return scriptFile;\r\n    } catch (IOException e) {\r\n        throw new PicardException(\"Unexpected exception creating R script file [\" + rScriptName + \"]\", e);\r\n    } finally {\r\n        if (scriptStream != null) {\r\n            try {\r\n                scriptStream.close();\r\n            } catch (IOException ignored) {\r\n            }\r\n        }\r\n        if (scriptFileStream != null) {\r\n            try {\r\n                scriptFileStream.close();\r\n            } catch (IOException ignored) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.pms.newgui.HelpTab.getList",
	"Comment": "return the editor pane for the help tab containing the help contents.",
	"Method": "JEditorPane getList(){\r\n    return editorPane;\r\n}"
}, {
	"Path": "com.restfb.util.UrlUtils.removeQueryParameter",
	"Comment": "remove the given key from the url query string and return the new url as string.",
	"Method": "String removeQueryParameter(String url,String key){\r\n    String[] urlParts = url.split(\"\\\\?\");\r\n    if (urlParts.length == 2) {\r\n        Map<String, List<String>> paramMap = extractParametersFromQueryString(urlParts[1]);\r\n        if (paramMap.containsKey(key)) {\r\n            String queryValue = paramMap.get(key).get(0);\r\n            String result = url.replace(key + \"=\" + queryValue, \"\");\r\n            result = result.replace(\"?&\", \"?\").replace(\"&&\", \"&\");\r\n            if (result.endsWith(\"&\")) {\r\n                return result.substring(0, result.length() - 1);\r\n            } else {\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n    return url;\r\n}"
}, {
	"Path": "prefuse.action.filter.FisheyeTreeFilter.setSources",
	"Comment": "set the name of the group to use as source nodes for measuringgraph distance. these form the roots from which the graph distanceis measured.",
	"Method": "void setSources(String sources){\r\n    m_sources = sources;\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.RadialTreeLayout.calcAngularBounds",
	"Comment": "calculates the angular bounds of the layout, attempting topreserve the angular orientation of the display across transitions.",
	"Method": "void calcAngularBounds(NodeItem r){\r\n    if (m_prevRoot == null || !m_prevRoot.isValid() || r == m_prevRoot) {\r\n        m_prevRoot = r;\r\n        return;\r\n    }\r\n    NodeItem p = m_prevRoot;\r\n    while (true) {\r\n        NodeItem pp = (NodeItem) p.getParent();\r\n        if (pp == r) {\r\n            break;\r\n        } else if (pp == null) {\r\n            m_prevRoot = r;\r\n            return;\r\n        }\r\n        p = pp;\r\n    }\r\n    double dt = 0;\r\n    Iterator iter = sortedChildren(r);\r\n    while (iter.hasNext()) {\r\n        Node n = (Node) iter.next();\r\n        if (n == p)\r\n            break;\r\n        dt += ((Params) n.get(PARAMS)).width;\r\n    }\r\n    double rw = ((Params) r.get(PARAMS)).width;\r\n    double pw = ((Params) p.get(PARAMS)).width;\r\n    dt = -MathLib.TWO_PI * (dt + pw / 2) / rw;\r\n    m_theta1 = dt + Math.atan2(p.getY() - r.getY(), p.getX() - r.getX());\r\n    m_theta2 = m_theta1 + MathLib.TWO_PI;\r\n    m_prevRoot = r;\r\n}"
}, {
	"Path": "net.pms.util.AVCHeader.getBit",
	"Comment": "returns the value of one particular bit in the header buffer and\tautomatically increases the bit counter field to point at the next bit.\tif the bit counter is too high and the buffer is too small to retrieve\ta proper bit value, 0 is returned.",
	"Method": "int getBit(){\r\n    int pos = currentBit / 8;\r\n    int modulo = currentBit % 8;\r\n    currentBit++;\r\n    if (buffer != null && pos < buffer.length) {\r\n        return (buffer[pos] & (1 << (7 - modulo))) >> (7 - modulo);\r\n    } else {\r\n        if (!parseFailed) {\r\n            logger.error(\"Cannot parse AVC header, buffer length is \" + buffer.length);\r\n            parseFailed = true;\r\n        }\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "prefuse.activity.ActivityManager.run",
	"Comment": "main scheduling thread loop. this is automatically started uponinitialization of the activitymanager.",
	"Method": "void run(){\r\n    _setRunning(true);\r\n    while (_keepRunning()) {\r\n        if (_activityCount() > 0) {\r\n            long currentTime = System.currentTimeMillis();\r\n            long t = -1;\r\n            synchronized (this) {\r\n                for (int i = 0; i < m_activities.size(); i++) {\r\n                    Activity a = (Activity) m_activities.get(i);\r\n                    m_tmp.add(a);\r\n                    if (currentTime >= a.getStopTime()) {\r\n                        m_activities.remove(i--);\r\n                        a.setScheduled(false);\r\n                    }\r\n                }\r\n                if (m_activities.size() == 0) {\r\n                    m_nextTime = Long.MAX_VALUE;\r\n                }\r\n            }\r\n            for (int i = 0; i < m_tmp.size(); i++) {\r\n                Activity a = (Activity) m_tmp.get(i);\r\n                long s = a.runActivity(currentTime);\r\n                t = (s < 0 ? t : t < 0 ? s : Math.min(t, s));\r\n            }\r\n            m_tmp.clear();\r\n            if (t == -1)\r\n                continue;\r\n            try {\r\n                synchronized (this) {\r\n                    wait(t);\r\n                }\r\n            } catch (InterruptedException e) {\r\n            }\r\n        } else {\r\n            try {\r\n                synchronized (this) {\r\n                    wait();\r\n                }\r\n            } catch (InterruptedException e) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.display.Clip.limit",
	"Comment": "limit the clip such that it fits within the specified region.",
	"Method": "void limit(double x1,double y1,double x2,double y2){\r\n    clip[0] = Math.max(clip[0], x1);\r\n    clip[1] = Math.max(clip[1], y1);\r\n    clip[6] = Math.min(clip[6], x2);\r\n    clip[7] = Math.min(clip[7], y2);\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setUseCache",
	"Comment": "set to true if pms should cache scanned media in its internal database,\tspeeding up later retrieval.",
	"Method": "void setUseCache(boolean value){\r\n    configuration.setProperty(KEY_USE_CACHE, value);\r\n}"
}, {
	"Path": "prefuse.action.assignment.DataShapeAction.setDefaultShape",
	"Comment": "this operation is not supported by the datashapeaction type.calling this method will result in a thrown exception.",
	"Method": "void setDefaultShape(int defaultShape){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getMaximumBitrate",
	"Comment": "returns the maximum video bitrate to be used by mencoder and ffmpeg.",
	"Method": "String getMaximumBitrate(){\r\n    String maximumBitrate = getString(KEY_MAX_BITRATE, \"110\");\r\n    if (\"0\".equals(maximumBitrate)) {\r\n        maximumBitrate = \"1000\";\r\n    }\r\n    return maximumBitrate;\r\n}"
}, {
	"Path": "prefuse.data.query.ListQueryBinding.createList",
	"Comment": "create a new interactive list for interacting with the query.",
	"Method": "JList createList(){\r\n    JList list = new JList(m_model);\r\n    list.setSelectionModel(m_model);\r\n    return list;\r\n}"
}, {
	"Path": "prefuse.data.Table.rows",
	"Comment": "get a filtered iterator over the row numbers of this table, returningonly the rows whose tuples match the given filter predicate.",
	"Method": "IntIterator rows(IntIterator rows,Predicate filter,IntIterator rows,boolean reverse){\r\n    return m_rows.rows(reverse);\r\n}"
}, {
	"Path": "picard.analysis.directed.CollectTargetedMetrics.doWork",
	"Comment": "asserts that files are readable and writable and then fires off anhsmetricscalculator instance to do the real work.",
	"Method": "int doWork(){\r\n    for (final File targetInterval : TARGET_INTERVALS) IOUtil.assertFileIsReadable(targetInterval);\r\n    IOUtil.assertFileIsReadable(INPUT);\r\n    IOUtil.assertFileIsWritable(OUTPUT);\r\n    if (PER_TARGET_COVERAGE != null)\r\n        IOUtil.assertFileIsWritable(PER_TARGET_COVERAGE);\r\n    final SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT);\r\n    final IntervalList targetIntervals = IntervalList.fromFiles(TARGET_INTERVALS);\r\n    SequenceUtil.assertSequenceDictionariesEqual(reader.getFileHeader().getSequenceDictionary(), targetIntervals.getHeader().getSequenceDictionary());\r\n    SequenceUtil.assertSequenceDictionariesEqual(reader.getFileHeader().getSequenceDictionary(), getProbeIntervals().getHeader().getSequenceDictionary());\r\n    ReferenceSequenceFile ref = null;\r\n    if (REFERENCE_SEQUENCE != null) {\r\n        IOUtil.assertFileIsReadable(REFERENCE_SEQUENCE);\r\n        ref = ReferenceSequenceFileFactory.getReferenceSequenceFile(REFERENCE_SEQUENCE);\r\n        SequenceUtil.assertSequenceDictionariesEqual(reader.getFileHeader().getSequenceDictionary(), ref.getSequenceDictionary(), INPUT, REFERENCE_SEQUENCE);\r\n    }\r\n    final COLLECTOR collector = makeCollector(METRIC_ACCUMULATION_LEVEL, reader.getFileHeader().getReadGroups(), ref, PER_TARGET_COVERAGE, PER_BASE_COVERAGE, targetIntervals, getProbeIntervals(), getProbeSetName(), NEAR_DISTANCE);\r\n    final ProgressLogger progress = new ProgressLogger(log);\r\n    for (final SAMRecord record : reader) {\r\n        collector.acceptRecord(record, null);\r\n        progress.record(record);\r\n    }\r\n    final MetricsFile<METRIC, Integer> metrics = getMetricsFile();\r\n    collector.finish();\r\n    collector.addAllLevelsToFile(metrics);\r\n    metrics.write(OUTPUT);\r\n    if (THEORETICAL_SENSITIVITY_OUTPUT != null) {\r\n        final MetricsFile<TheoreticalSensitivityMetrics, ?> theoreticalSensitivityMetrics = getMetricsFile();\r\n        log.info(\"Calculating theoretical sentitivity at \" + ALLELE_FRACTION.size() + \" allele fractions.\");\r\n        List<TheoreticalSensitivityMetrics> tsm = TheoreticalSensitivity.calculateSensitivities(SAMPLE_SIZE, collector.getDepthHistogram(), collector.getBaseQualityHistogram(), ALLELE_FRACTION);\r\n        theoreticalSensitivityMetrics.addAllMetrics(tsm);\r\n        theoreticalSensitivityMetrics.write(THEORETICAL_SENSITIVITY_OUTPUT);\r\n    }\r\n    CloserUtil.close(reader);\r\n    return 0;\r\n}"
}, {
	"Path": "prefuse.data.search.PrefixSearchTupleSet.setDelimiterString",
	"Comment": "sets the delimiter string used to divide data values andqueries into separate words. by default, the delimiter consistsof just whitespace characters.",
	"Method": "void setDelimiterString(String delim){\r\n    m_delim = delim;\r\n}"
}, {
	"Path": "com.google.gwt.sample.mail.client.MailList.setListener",
	"Comment": "sets the listener that will be notified when an item is selected.",
	"Method": "void setListener(Listener listener){\r\n    this.listener = listener;\r\n}"
}, {
	"Path": "prefuse.util.force.Spring.getFactory",
	"Comment": "retrieve the springfactory instance, which serves as an object poolfor spring instances.",
	"Method": "SpringFactory getFactory(){\r\n    return s_factory;\r\n}"
}, {
	"Path": "prefuse.util.PrefuseLib.updateVisible",
	"Comment": "update the visibility of an item. the current visibility will become thenew starting visibility, while the given visibility value will becomethe new current and ending visibility.",
	"Method": "void updateVisible(VisualItem item,boolean val){\r\n    item.setStartVisible(item.isVisible());\r\n    item.setVisible(val);\r\n    item.setEndVisible(val);\r\n}"
}, {
	"Path": "picard.util.RExecutor.executeFromClasspath",
	"Comment": "executes the given r script that is stored in a file on the classpath. the script fileis read from the classpath and written to a temp file then executed by a call to rscript.blocks until the r script is complete.",
	"Method": "int executeFromClasspath(String rScriptName,String arguments){\r\n    final File scriptFile = writeScriptFile(rScriptName);\r\n    final int returnCode = executeFromFile(scriptFile, arguments);\r\n    htsjdk.samtools.util.IOUtil.deleteFiles(scriptFile);\r\n    return returnCode;\r\n}"
}, {
	"Path": "prefuse.data.search.KeywordSearchTupleSet.unindex",
	"Comment": "this method throws an exception, as unidexing is not supported.",
	"Method": "void unindex(Tuple t,String attrName){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "prefuse.util.collections.CopyOnWriteArrayList.iterator",
	"Comment": "returns an iterator over the elements in this list in proper sequence.the returned iterator provides a snapshot of the state of the listwhen the iterator was constructed. no synchronization is needed whiletraversing the iterator. the iterator does not support theremove method.",
	"Method": "Iterator iterator(Iterator iterator){\r\n    return new COWIterator(getArray(), 0);\r\n}"
}, {
	"Path": "prefuse.action.EncoderAction.add",
	"Comment": "add a mapping rule to this encoderaction. this method is protected,subclasses should crate public add methods of their own to enforcetheir own type constraints.",
	"Method": "void add(Predicate p,Object value){\r\n    if (m_chain == null)\r\n        m_chain = new PredicateChain();\r\n    if (value instanceof Action)\r\n        ((Action) value).setVisualization(m_vis);\r\n    m_chain.add(p, value);\r\n}"
}, {
	"Path": "prefuse.util.ColorLib.getInterpolatedPalette",
	"Comment": "returns a color palette of default size that ranges from onegiven color to the other.",
	"Method": "int[] getInterpolatedPalette(int size,int c1,int c2,int[] getInterpolatedPalette,int c1,int c2){\r\n    return getInterpolatedPalette(DEFAULT_MAP_SIZE, c1, c2);\r\n}"
}, {
	"Path": "net.pms.configuration.MacDefaultPaths.getBinariesPath",
	"Comment": "returns the path where binaries can be found. this path differs between\tthe build phase and the test phase. the path will end with a slash unless\tit is empty.",
	"Method": "String getBinariesPath(){\r\n    String path = PropertiesUtil.getProjectProperties().get(\"project.binaries.dir\");\r\n    if (isNotBlank(path)) {\r\n        if (path.endsWith(\"/\")) {\r\n            return path;\r\n        } else {\r\n            return path + \"/\";\r\n        }\r\n    } else {\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "net.paoding.rose.util.Base64.encodeToString",
	"Comment": "encodes a byte array into base64 notation. the resulting string will\tbe created using the platform default encoding.",
	"Method": "String encodeToString(byte[] source){\r\n    return new String(encode(source));\r\n}"
}, {
	"Path": "io.github.benas.randombeans.util.CharacterUtils.collectPrintableCharactersOf",
	"Comment": "returns a list of all printable charaters of the given charset.",
	"Method": "List<Character> collectPrintableCharactersOf(Charset charset){\r\n    List<Character> chars = new ArrayList();\r\n    for (int i = Character.MIN_VALUE; i < Character.MAX_VALUE; i++) {\r\n        char character = (char) i;\r\n        if (isPrintable(character)) {\r\n            String characterAsString = Character.toString(character);\r\n            byte[] encoded = characterAsString.getBytes(charset);\r\n            String decoded = new String(encoded, charset);\r\n            if (characterAsString.equals(decoded)) {\r\n                chars.add(character);\r\n            }\r\n        }\r\n    }\r\n    return chars;\r\n}"
}, {
	"Path": "prefuse.util.ui.JValueSlider.setSliderValue",
	"Comment": "private set the slider position based upon the current value",
	"Method": "void setSliderValue(){\r\n    int val;\r\n    if (m_value instanceof Double || m_value instanceof Float) {\r\n        double value = m_value.doubleValue();\r\n        double min = m_min.doubleValue();\r\n        double max = m_max.doubleValue();\r\n        val = m_smin + (int) Math.round(m_srange * ((value - min) / (max - min)));\r\n    } else {\r\n        long value = m_value.longValue();\r\n        long min = m_min.longValue();\r\n        long max = m_max.longValue();\r\n        val = m_smin + (int) ((m_srange * (value - min)) / (max - min));\r\n    }\r\n    m_slider.setValue(val);\r\n}"
}, {
	"Path": "prefuse.data.Graph.isDirected",
	"Comment": "indicates if the edges of this graph are directed or undirected.",
	"Method": "boolean isDirected(){\r\n    return m_directed;\r\n}"
}, {
	"Path": "prefuse.activity.ActivityManager._stop",
	"Comment": "stops the activity manager thread. all scheduled actvities arecanceled, and then the thread is then notified to stop running.",
	"Method": "void _stop(){\r\n    while (m_activities.size() > 0) {\r\n        Activity a = (Activity) m_activities.get(m_activities.size() - 1);\r\n        a.cancel();\r\n    }\r\n    _setRunning(false);\r\n    notify();\r\n}"
}, {
	"Path": "picard.illumina.ClusterDataToSamConverter.withMolecularIndexTag",
	"Comment": "sets the sam tag to use to store the molecular index bases.if multiple molecular indexes exist, it will concatenate themand store them in this tag.",
	"Method": "ClusterDataToSamConverter withMolecularIndexTag(String molecularIndexTag){\r\n    if (molecularIndexTag == null)\r\n        throw new IllegalArgumentException(\"Molecular index tag was null\");\r\n    this.MOLECULAR_INDEX_TAG = molecularIndexTag;\r\n    return this;\r\n}"
}, {
	"Path": "net.pms.formats.Format.skip",
	"Comment": "returns whether or not the matched extension of this format is among\tthe list of supplied extensions.",
	"Method": "boolean skip(String extensions,String moreExtensions){\r\n    if (extensions != null && extensions.length() > 0) {\r\n        StringTokenizer st = new StringTokenizer(extensions, \",\");\r\n        while (st.hasMoreTokens()) {\r\n            String id = st.nextToken().toLowerCase();\r\n            if (matchedExtension != null && matchedExtension.toLowerCase().equals(id)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    if (moreExtensions != null && moreExtensions.length() > 0) {\r\n        StringTokenizer st = new StringTokenizer(moreExtensions, \",\");\r\n        while (st.hasMoreTokens()) {\r\n            String id = st.nextToken().toLowerCase();\r\n            if (matchedExtension != null && matchedExtension.toLowerCase().equals(id)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "prefuse.data.Table.rowsSortedBy",
	"Comment": "get an iterator over the rows of this table, sorted by the given datafield. this method will create an index over the field if one doesnot yet exist.",
	"Method": "IntIterator rowsSortedBy(String field,boolean ascend){\r\n    Class type = getColumnType(field);\r\n    Index index = getIndex(field, type, true);\r\n    int t = ascend ? Index.TYPE_ASCENDING : Index.TYPE_DESCENDING;\r\n    return index.allRows(t);\r\n}"
}, {
	"Path": "picard.sam.markduplicates.EstimateLibraryComplexityTest.testMaxDiffRate",
	"Comment": "does not find duplicates since the difference rate was too high across the entire read",
	"Method": "void testMaxDiffRate(String testName,int numDuplicates,int numReadPairsExamined){\r\n    final File input = new File(TEST_DATA_DIR, testName);\r\n    final File output = File.createTempFile(\"estimateLibraryComplexity\", \".els_metrics\");\r\n    output.deleteOnExit();\r\n    final List<String> args = new ArrayList();\r\n    args.add(\"INPUT=\" + input.getAbsolutePath());\r\n    args.add(\"OUTPUT=\" + output.getAbsolutePath());\r\n    args.add(\"MAX_DIFF_RATE=0.0\");\r\n    args.add(\"MIN_GROUP_COUNT=1\");\r\n    Assert.assertEquals(runPicardCommandLine(args), 0);\r\n    examineMetricsFile(output, numDuplicates, numReadPairsExamined);\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeProbabilities.getMostLikelyIndex",
	"Comment": "returns the index of the highest probability which can then be used to look updiploidhaplotypes or diploidgenotypes as appropriate.",
	"Method": "int getMostLikelyIndex(){\r\n    final double[] probs = getPosteriorProbabilities();\r\n    if (probs[0] > probs[1] && probs[0] > probs[2])\r\n        return 0;\r\n    else if (probs[1] > probs[2])\r\n        return 1;\r\n    else\r\n        return 2;\r\n}"
}, {
	"Path": "picard.util.BedToIntervalListTest.testBedToIntervalListSequenceDictionaryDataProvider",
	"Comment": "test for each of the file categories supported by samsequencedictionaryextractor",
	"Method": "Object[][] testBedToIntervalListSequenceDictionaryDataProvider(){\r\n    return new Object[][] { { \"seq_dict_test.dictionary.interval_list\" }, { \"seq_dict_test.dictionary.fasta\" }, { \"seq_dict_test.dictionary.dict\" }, { \"seq_dict_test.dictionary.sam\" }, { \"seq_dict_test.dictionary.vcf\" } };\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.canGetString",
	"Comment": "indicates if convenience get method can be called withoutan exception being thrown for the string type.",
	"Method": "boolean canGetString(){\r\n    return true;\r\n}"
}, {
	"Path": "picard.util.AsyncIterator.checkAndRethrow",
	"Comment": "checks to see if an exception has been raised in the reader thread and if so rethrows it as an erroror runtimeexception as appropriate.",
	"Method": "void checkAndRethrow(){\r\n    final Throwable t = this.ex.get();\r\n    if (t != null) {\r\n        if (t instanceof Error)\r\n            throw (Error) t;\r\n        if (t instanceof RuntimeException)\r\n            throw (RuntimeException) t;\r\n        else\r\n            throw new RuntimeException(t);\r\n    }\r\n}"
}, {
	"Path": "quickfix.SessionState.dequeueMessagesUpTo",
	"Comment": "remove messages from messagequeue up to a given sequence number.",
	"Method": "void dequeueMessagesUpTo(int seqnum){\r\n    for (int i = 1; i < seqnum; i++) {\r\n        dequeue(i);\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.Table.getMetadata",
	"Comment": "return a metadata instance providing summary information about a column.",
	"Method": "ColumnMetadata getMetadata(String field){\r\n    ColumnEntry e = (ColumnEntry) m_entries.get(field);\r\n    if (e == null) {\r\n        throw new IllegalArgumentException(\"Unknown column name: \" + field);\r\n    }\r\n    return e.metadata;\r\n}"
}, {
	"Path": "prefuse.util.GraphicsLib.stackSpline",
	"Comment": "computes a set of curves using the cardinal spline approach, butusing straight lines for completely horizontal or vertical segments.",
	"Method": "GeneralPath stackSpline(GeneralPath p,float[] pts,float epsilon,float slack,boolean closed,float tx,float ty,GeneralPath stackSpline,GeneralPath p,float pts,int start,int npoints,float epsilon,float slack,boolean closed,float tx,float ty){\r\n    int len = 2 * npoints;\r\n    int end = start + len;\r\n    if (len < 6) {\r\n        throw new IllegalArgumentException(\"To create spline requires at least 3 points\");\r\n    }\r\n    float dx1, dy1, dx2, dy2;\r\n    if (closed) {\r\n        dx2 = pts[start + 2] - pts[end - 2];\r\n        dy2 = pts[start + 3] - pts[end - 1];\r\n    } else {\r\n        dx2 = pts[start + 4] - pts[start];\r\n        dy2 = pts[start + 5] - pts[start + 1];\r\n    }\r\n    int i;\r\n    for (i = start + 2; i < end - 2; i += 2) {\r\n        dx1 = dx2;\r\n        dy1 = dy2;\r\n        dx2 = pts[i + 2] - pts[i - 2];\r\n        dy2 = pts[i + 3] - pts[i - 1];\r\n        if (Math.abs(pts[i] - pts[i - 2]) < epsilon || Math.abs(pts[i + 1] - pts[i - 1]) < epsilon) {\r\n            p.lineTo(tx + pts[i], ty + pts[i + 1]);\r\n        } else {\r\n            p.curveTo(tx + pts[i - 2] + slack * dx1, ty + pts[i - 1] + slack * dy1, tx + pts[i] - slack * dx2, ty + pts[i + 1] - slack * dy2, tx + pts[i], ty + pts[i + 1]);\r\n        }\r\n    }\r\n    dx1 = dx2;\r\n    dy1 = dy2;\r\n    dx2 = pts[start] - pts[i - 2];\r\n    dy2 = pts[start + 1] - pts[i - 1];\r\n    if (Math.abs(pts[i] - pts[i - 2]) < epsilon || Math.abs(pts[i + 1] - pts[i - 1]) < epsilon) {\r\n        p.lineTo(tx + pts[i], ty + pts[i + 1]);\r\n    } else {\r\n        p.curveTo(tx + pts[i - 2] + slack * dx1, ty + pts[i - 1] + slack * dy1, tx + pts[i] - slack * dx2, ty + pts[i + 1] - slack * dy2, tx + pts[i], ty + pts[i + 1]);\r\n    }\r\n    if (closed) {\r\n        if (Math.abs(pts[end - 2] - pts[0]) < epsilon || Math.abs(pts[end - 1] - pts[1]) < epsilon) {\r\n            p.lineTo(tx + pts[0], ty + pts[1]);\r\n        } else {\r\n            dx1 = dx2;\r\n            dy1 = dy2;\r\n            dx2 = pts[start + 2] - pts[end - 2];\r\n            dy2 = pts[start + 3] - pts[end - 1];\r\n            p.curveTo(tx + pts[end - 2] + slack * dx1, ty + pts[end - 1] + slack * dy1, tx + pts[0] - slack * dx2, ty + pts[1] - slack * dy2, tx + pts[0], ty + pts[1]);\r\n        }\r\n        p.closePath();\r\n    }\r\n    return p;\r\n}"
}, {
	"Path": "net.pms.PMS.getRootFolder",
	"Comment": "returns the root folder for a given renderer. there could be the case\twhere a given media renderer needs a different root structure.",
	"Method": "RootFolder getRootFolder(RendererConfiguration renderer){\r\n    if (renderer == null) {\r\n        renderer = RendererConfiguration.getDefaultConf();\r\n    }\r\n    return renderer.getRootFolder();\r\n}"
}, {
	"Path": "picard.vcf.GatherVcfs.gatherConventionally",
	"Comment": "code for gathering multiple vcfs that works regardless of input format and output format, but can be slow.",
	"Method": "void gatherConventionally(SAMSequenceDictionary sequenceDictionary,boolean createIndex,List<File> inputFiles,File outputFile){\r\n    final EnumSet<Options> options = EnumSet.copyOf(VariantContextWriterBuilder.DEFAULT_OPTIONS);\r\n    if (createIndex) {\r\n        options.add(Options.INDEX_ON_THE_FLY);\r\n    } else {\r\n        options.remove(Options.INDEX_ON_THE_FLY);\r\n    }\r\n    final VariantContextWriter out = new VariantContextWriterBuilder().setOptions(options).setOutputFile(outputFile).setReferenceDictionary(sequenceDictionary).build();\r\n    final ProgressLogger progress = new ProgressLogger(log, 10000);\r\n    VariantContext lastContext = null;\r\n    File lastFile = null;\r\n    VCFHeader firstHeader = null;\r\n    VariantContextComparator comparator = null;\r\n    for (final File f : inputFiles) {\r\n        log.debug(\"Gathering from file: \", f.getAbsolutePath());\r\n        final VCFFileReader variantReader = new VCFFileReader(f, false);\r\n        final PeekableIterator<VariantContext> variantIterator = new PeekableIterator(variantReader.iterator());\r\n        final VCFHeader header = variantReader.getFileHeader();\r\n        if (firstHeader == null) {\r\n            firstHeader = header;\r\n            out.writeHeader(firstHeader);\r\n            comparator = new VariantContextComparator(firstHeader.getContigLines());\r\n        }\r\n        if (lastContext != null && variantIterator.hasNext()) {\r\n            final VariantContext vc = variantIterator.peek();\r\n            if (comparator.compare(vc, lastContext) <= 0) {\r\n                throw new IllegalArgumentException(\"First variant in file \" + f.getAbsolutePath() + \" is at \" + vc.getContig() + \":\" + vc.getStart() + \" but last variant in earlier file \" + lastFile.getAbsolutePath() + \" is at \" + lastContext.getContig() + \":\" + lastContext.getStart());\r\n            }\r\n        }\r\n        while (variantIterator.hasNext()) {\r\n            lastContext = variantIterator.next();\r\n            out.add(lastContext);\r\n            progress.record(lastContext.getContig(), lastContext.getStart());\r\n        }\r\n        lastFile = f;\r\n        CloserUtil.close(variantIterator);\r\n        CloserUtil.close(variantReader);\r\n    }\r\n    out.close();\r\n}"
}, {
	"Path": "py4j.reflection.ReflectionEngine.getPublicStaticFieldNames",
	"Comment": "retrieve the names of all the public static fields in the clazz",
	"Method": "String[] getPublicStaticFieldNames(Class<?> clazz){\r\n    Field[] fields = clazz.getFields();\r\n    Set<String> fieldNames = new HashSet<String>();\r\n    for (Field field : fields) {\r\n        if (Modifier.isPublic(field.getModifiers()) && Modifier.isStatic(field.getModifiers())) {\r\n            fieldNames.add(field.getName());\r\n        }\r\n    }\r\n    return (String[]) fieldNames.toArray(new String[fieldNames.size()]);\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeMap.getIntervalList",
	"Comment": "returns an intervallist with an entry for every snp in every haplotype in the map.",
	"Method": "IntervalList getIntervalList(){\r\n    this.intervals = this.intervals.sorted();\r\n    return this.intervals;\r\n}"
}, {
	"Path": "prefuse.action.layout.AxisLayout.setDataField",
	"Comment": "set the data field used by this axis layout action. the values of thedata field will determine the position of items along the axis. notethat this method does not affect the other parameters of this action. inparticular, clients that have provided a custom range model forsetting the axis range may need to appropriately update the modelsetting for use with the new data field setting.",
	"Method": "void setDataField(String field){\r\n    m_field = field;\r\n    if (!m_modelSet)\r\n        m_model = null;\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.canSet",
	"Comment": "indicates if the set method can be called withoutan exception being thrown for the given type.",
	"Method": "boolean canSet(Class type){\r\n    if (type == null)\r\n        return false;\r\n    if (m_columnType.isPrimitive()) {\r\n        return m_columnType.isAssignableFrom(type) || TypeLib.getWrapperType(m_columnType).isAssignableFrom(type) || String.class.isAssignableFrom(type);\r\n    } else {\r\n        return m_columnType.isAssignableFrom(type);\r\n    }\r\n}"
}, {
	"Path": "picard.filter.CountingFilter.getFilteredBases",
	"Comment": "gets the number of bases that have been filtered out thus far.",
	"Method": "long getFilteredBases(){\r\n    return this.filteredBases;\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.text.CwBasicText.createTextExample",
	"Comment": "create a textbox example that includes the text box and an optional handlerthat updates a label with the currently selected text.",
	"Method": "HorizontalPanel createTextExample(TextBoxBase textBox,boolean addSelection){\r\n    HorizontalPanel hPanel = new HorizontalPanel();\r\n    hPanel.setSpacing(4);\r\n    hPanel.add(textBox);\r\n    if (addSelection) {\r\n        final Label label = new Label(constants.cwBasicTextSelected() + \": 0, 0\");\r\n        textBox.addKeyUpHandler(new KeyUpHandler() {\r\n            public void onKeyUp(KeyUpEvent event) {\r\n                updateSelectionLabel(textBox, label);\r\n            }\r\n        });\r\n        textBox.addClickHandler(new ClickHandler() {\r\n            public void onClick(ClickEvent event) {\r\n                updateSelectionLabel(textBox, label);\r\n            }\r\n        });\r\n        hPanel.add(label);\r\n    }\r\n    return hPanel;\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.text.CwBasicText.createTextExample",
	"Comment": "create a textbox example that includes the text box and an optional handlerthat updates a label with the currently selected text.",
	"Method": "HorizontalPanel createTextExample(TextBoxBase textBox,boolean addSelection){\r\n    updateSelectionLabel(textBox, label);\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.text.CwBasicText.createTextExample",
	"Comment": "create a textbox example that includes the text box and an optional handlerthat updates a label with the currently selected text.",
	"Method": "HorizontalPanel createTextExample(TextBoxBase textBox,boolean addSelection){\r\n    updateSelectionLabel(textBox, label);\r\n}"
}, {
	"Path": "prefuse.render.EdgeRenderer.getArrowTrans",
	"Comment": "returns an affine transformation that maps the arrowhead shapeto the position and orientation specified by the providedline segment end points.",
	"Method": "AffineTransform getArrowTrans(Point2D p1,Point2D p2,double width){\r\n    m_arrowTrans.setToTranslation(p2.getX(), p2.getY());\r\n    m_arrowTrans.rotate(-HALF_PI + Math.atan2(p2.getY() - p1.getY(), p2.getX() - p1.getX()));\r\n    if (width > 1) {\r\n        double scalar = width / 4;\r\n        m_arrowTrans.scale(scalar, scalar);\r\n    }\r\n    return m_arrowTrans;\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAMediaAudio.isMP3",
	"Comment": "returns true if this media uses the mp3 audio codec, false otherwise.",
	"Method": "boolean isMP3(){\r\n    return getCodecA() != null && getCodecA().equalsIgnoreCase(FormatConfiguration.MP3);\r\n}"
}, {
	"Path": "java.io.PushbackInputStream.close",
	"Comment": "this method closes the stream and releases any associated resources.",
	"Method": "void close(){\r\n    buf = null;\r\n    super.close();\r\n}"
}, {
	"Path": "picard.illumina.parser.ClusterIntensityFileReader.getValue",
	"Comment": "get the value for the given args.value is returned as a signed short regardless of whether storage isin bytes or shorts.",
	"Method": "short getValue(int cluster,IntensityChannel channel,int cycle){\r\n    if (cycle < header.firstCycle || cycle >= header.firstCycle + header.numCycles) {\r\n        throw new IllegalArgumentException(\"Requested cycle (\" + cycle + \") number out of range.  First cycle=\" + header.firstCycle + \"; numCycles=\" + header.numCycles);\r\n    }\r\n    if (cluster < 0 || cluster >= header.numClusters) {\r\n        throw new IllegalArgumentException(\"Requested cluster (\" + cluster + \") number out of range. numClustersInTile=\" + header.numClusters);\r\n    }\r\n    final int relativeCycle = cycle - header.firstCycle;\r\n    final int position = HEADER_SIZE + relativeCycle * cycleSize + channel.ordinal() * channelSize + cluster * header.elementSize;\r\n    buf.position(position);\r\n    if (header.elementSize == 1) {\r\n        return buf.get();\r\n    } else {\r\n        return buf.getShort();\r\n    }\r\n}"
}, {
	"Path": "com.restfb.json.JsonObject.names",
	"Comment": "returns a list of the names in this object in document order. the returned list is backed by this object and willreflect subsequent changes. it cannot be used to modify this object. attempts to modify the returned list willresult in an exception.",
	"Method": "List<String> names(){\r\n    return Collections.unmodifiableList(names);\r\n}"
}, {
	"Path": "prefuse.data.parser.TypeInferencer.sample",
	"Comment": "sample the given text string for the given data column index.",
	"Method": "void sample(int column,String value){\r\n    rangeCheck(column, true);\r\n    ((ParserFactory) m_factories.get(column)).sample(value);\r\n}"
}, {
	"Path": "picard.sam.SamErrorMetric.ReadBaseStratification.wrapStaticFunction",
	"Comment": "a factory for generating stateless stratifier instances given a static function and a string",
	"Method": "RecordAndOffsetStratifier<T> wrapStaticFunction(BiFunction<RecordAndOffset, SAMLocusAndReference, T> staticStratify,String suffix,RecordAndOffsetStratifier<T> wrapStaticFunction,Function<RecordAndOffset, T> staticStratify,String suffix){\r\n    return wrapStaticFunction((rao, ignored) -> staticStratify.apply(rao), suffix);\r\n}"
}, {
	"Path": "OpticalFlow.OpticalFlow_CaptureVerletParticles.ParticleSystem.clearShapes",
	"Comment": "not sure if this is necessary, but i guess opengl stuff needs to be released internally.",
	"Method": "void clearShapes(){\r\n    if (shp_particlesystem != null) {\r\n        for (int i = shp_particlesystem.getChildCount() - 1; i >= 0; i--) {\r\n            shp_particlesystem.removeChild(i);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "picard.util.ClippingUtilityTest.testAdapterListTruncation",
	"Comment": "confirm that after the requisite number of sightings of adapter, the list is trimmed",
	"Method": "void testAdapterListTruncation(IlluminaAdapterPair adapterPair){\r\n    final int thresholdForTruncatingAdapterList = 20;\r\n    final int readLength = 100;\r\n    final AdapterMarker marker = new AdapterMarker(IlluminaUtil.IlluminaAdapterPair.values()).setThresholdForSelectingAdaptersToKeep(thresholdForTruncatingAdapterList);\r\n    int adapterPosition = 1;\r\n    Assert.assertTrue(adapterPosition + thresholdForTruncatingAdapterList < readLength - ClippingUtility.MIN_MATCH_BASES, \"Test is configured improperly -- eventually will not be enough adapter bases in read.\");\r\n    int originalNumberOfAdapters = marker.getAdapters().length;\r\n    for (int i = 0; i < thresholdForTruncatingAdapterList; ++i) {\r\n        SAMRecord rec = new SAMRecord(null);\r\n        rec.setReadString(makeBogusReadString(readLength));\r\n        AdapterPair matchedPair = marker.adapterTrimIlluminaSingleRead(rec);\r\n        Assert.assertNull(matchedPair);\r\n        Assert.assertNull(rec.getAttribute(ReservedTagConstants.XT));\r\n        Assert.assertEquals(marker.getAdapters().length, originalNumberOfAdapters);\r\n        rec = createSamRecordWithAdapterSequence(readLength, adapterPair, adapterPosition);\r\n        matchedPair = marker.adapterTrimIlluminaSingleRead(rec);\r\n        Assert.assertNotNull(matchedPair);\r\n        Assert.assertEquals(rec.getIntegerAttribute(ReservedTagConstants.XT).intValue(), adapterPosition + 1, rec.getReadString() + \" matched \" + matchedPair);\r\n        adapterPosition++;\r\n    }\r\n    Assert.assertEquals(marker.getAdapters().length, 1, \"Did not truncate adapter list to 1 element\");\r\n    Assert.assertTrue(marker.getAdapters()[0].getName().contains(adapterPair.getName()), String.format(\"Expected '%s' to contain '%s'\", marker.getAdapters()[0].getName(), adapterPair.getName()));\r\n}"
}, {
	"Path": "prefuse.data.util.TableIterator.canSetLong",
	"Comment": "check if the setlong method can safely be used for thegiven data field.",
	"Method": "boolean canSetLong(String field){\r\n    return m_table.canSetLong(field);\r\n}"
}, {
	"Path": "picard.sam.BestEndMapqPrimaryAlignmentStrategy.randomlySelectPrimaryFromBest",
	"Comment": "randomly picks one of the best alignments and puts it into the 0th slot of the list.",
	"Method": "void randomlySelectPrimaryFromBest(List<SAMRecord> recs){\r\n    if (recs.isEmpty())\r\n        return;\r\n    final int bestMapq = recs.get(0).getMappingQuality();\r\n    int i;\r\n    for (i = 1; i < recs.size() && recs.get(i).getMappingQuality() == bestMapq; ++i) {\r\n    }\r\n    final int bestIndex = random.nextInt(i);\r\n    if (bestIndex == 0)\r\n        return;\r\n    final SAMRecord tmp = recs.get(0);\r\n    recs.set(0, recs.get(bestIndex));\r\n    recs.set(bestIndex, tmp);\r\n}"
}, {
	"Path": "org.quickfixj.codegenerator.GenerateMojo.getOutputDirectory",
	"Comment": "returns the destination directory to used during code generation.",
	"Method": "File getOutputDirectory(){\r\n    return outputDirectory;\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAMediaAudio.isVorbis",
	"Comment": "returns true if this media uses the ogg vorbis audio codec, false otherwise.",
	"Method": "boolean isVorbis(){\r\n    return getCodecA() != null && getCodecA().equalsIgnoreCase(\"vorbis\");\r\n}"
}, {
	"Path": "prefuse.data.CascadedTable.setRowFilter",
	"Comment": "sets the predicate determining which rows of the parenttable are included in this one.",
	"Method": "void setRowFilter(Predicate rowFilter){\r\n    if (m_rowFilter != null) {\r\n        m_rowFilter.removeExpressionListener(m_listener);\r\n    }\r\n    m_rowFilter = rowFilter == null ? BooleanLiteral.TRUE : rowFilter;\r\n    if (m_rowFilter != BooleanLiteral.TRUE)\r\n        m_rowFilter.addExpressionListener(m_listener);\r\n    filterRows();\r\n}"
}, {
	"Path": "net.pms.encoders.PlayerFactory.initialize",
	"Comment": "constructor that registers all players based on the given configuration,\tframe and registry.",
	"Method": "void initialize(PmsConfiguration configuration){\r\n    utils = PMS.get().getRegistry();\r\n    registerPlayers(configuration);\r\n}"
}, {
	"Path": "prefuse.render.LabelRenderer.setVerticalPadding",
	"Comment": "sets the amount of padding in pixels between the content and the border of this item along the vertical dimension.",
	"Method": "void setVerticalPadding(int ypad){\r\n    m_vertBorder = ypad;\r\n}"
}, {
	"Path": "prefuse.util.ui.JSearchPanel.setLock",
	"Comment": "set the lock, an object to synchronize on while issuing queries.",
	"Method": "void setLock(Object lock){\r\n    m_lock = lock;\r\n}"
}, {
	"Path": "cn.hugeterry.ployfun.core.delaunay.Pnt.extend",
	"Comment": "create a new pnt by adding additional coordinates to this pnt.",
	"Method": "Pnt extend(double coords){\r\n    double[] result = new double[coordinates.length + coords.length];\r\n    System.arraycopy(coordinates, 0, result, 0, coordinates.length);\r\n    System.arraycopy(coords, 0, result, coordinates.length, coords.length);\r\n    return new Pnt(result);\r\n}"
}, {
	"Path": "prefuse.action.distortion.Distortion.correct",
	"Comment": "corrects the anchor position, such that if the anchor is outside thelayout bounds, the anchor is adjusted to be the nearest point on theedge of the bounds.",
	"Method": "Point2D correct(Point2D anchor,Rectangle2D bounds){\r\n    if (anchor == null)\r\n        return anchor;\r\n    double x = anchor.getX(), y = anchor.getY();\r\n    double x1 = bounds.getMinX(), y1 = bounds.getMinY();\r\n    double x2 = bounds.getMaxX(), y2 = bounds.getMaxY();\r\n    x = (x < x1 ? x1 : (x > x2 ? x2 : x));\r\n    y = (y < y1 ? y1 : (y > y2 ? y2 : y));\r\n    m_tmp.setLocation(x, y);\r\n    return m_tmp;\r\n}"
}, {
	"Path": "prefuse.data.Tree.addChild",
	"Comment": "add a child node to the given parent node. an edge between the twowill also be created.",
	"Method": "int addChild(int parent,Node addChild,Node parent){\r\n    nodeCheck(parent, true);\r\n    return getNode(addChild(parent.getRow()));\r\n}"
}, {
	"Path": "picard.util.DbSnpBitSetUtil.isDbSnpSite",
	"Comment": "returns true if there is a dbsnp entry at pos in sequencename, otherwise false",
	"Method": "boolean isDbSnpSite(String sequenceName,int pos){\r\n    return sequenceToBitSet.get(sequenceName) != null && pos <= sequenceToBitSet.get(sequenceName).length() && sequenceToBitSet.get(sequenceName).get(pos);\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.RadialTreeLayout.getAutoScale",
	"Comment": "indicates if the layout automatically scales to fit the layout bounds.",
	"Method": "boolean getAutoScale(){\r\n    return m_autoScale;\r\n}"
}, {
	"Path": "picard.analysis.WgsMetricsProcessorImpl.processFile",
	"Comment": "method gets the data from iterator for each locus and processes it with the help of collector.",
	"Method": "void processFile(){\r\n    long counter = 0;\r\n    while (iterator.hasNext()) {\r\n        final AbstractLocusInfo<T> info = iterator.next();\r\n        final ReferenceSequence ref = refWalker.get(info.getSequenceIndex());\r\n        boolean referenceBaseN = collector.isReferenceBaseN(info.getPosition(), ref);\r\n        collector.addInfo(info, ref, referenceBaseN);\r\n        if (referenceBaseN) {\r\n            continue;\r\n        }\r\n        progress.record(info.getSequenceName(), info.getPosition());\r\n        if (collector.isTimeToStop(++counter)) {\r\n            break;\r\n        }\r\n        collector.setCounter(counter);\r\n    }\r\n    final long sumBaseQ = Arrays.stream(collector.unfilteredBaseQHistogramArray).sum();\r\n    final long sumDepthHisto = LongStream.rangeClosed(0, collector.coverageCap).map(i -> (i * collector.unfilteredDepthHistogramArray[(int) i])).sum();\r\n    if (sumBaseQ != sumDepthHisto) {\r\n        log.error(\"Coverage and baseQ distributions contain different amount of bases!\");\r\n    }\r\n}"
}, {
	"Path": "prefuse.Visualization.addAggregates",
	"Comment": "add a group of aggregates to this visualization. aggregates areused to visually represent groups of visualitems.",
	"Method": "AggregateTable addAggregates(String group,AggregateTable addAggregates,String group,Schema schema){\r\n    AggregateTable vat = new AggregateTable(this, group, schema);\r\n    addDataGroup(group, vat, null);\r\n    return vat;\r\n}"
}, {
	"Path": "picard.fastq.BamToBfqWriter.countWritableRecords",
	"Comment": "count the number of records in the bamfile that could potentially be written",
	"Method": "int countWritableRecords(){\r\n    int count = 0;\r\n    final SamReader reader = SamReaderFactory.makeDefault().open(this.bamFile);\r\n    if (!reader.getFileHeader().getSortOrder().equals(SAMFileHeader.SortOrder.queryname)) {\r\n        throw new PicardException(\"Input file (\" + this.bamFile.getAbsolutePath() + \") needs to be sorted by queryname.\");\r\n    }\r\n    final PeekableIterator<SAMRecord> it = new PeekableIterator<SAMRecord>(reader.iterator());\r\n    if (!this.pairedReads) {\r\n        final List<SamRecordFilter> filters = new ArrayList<SamRecordFilter>();\r\n        filters.add(new TagFilter(ReservedTagConstants.XN, 1));\r\n        if (!this.includeNonPfReads) {\r\n            filters.add(new FailsVendorReadQualityFilter());\r\n        }\r\n        final FilteringSamIterator itr = new FilteringSamIterator(it, new AggregateFilter(filters));\r\n        while (itr.hasNext()) {\r\n            itr.next();\r\n            count++;\r\n        }\r\n    } else {\r\n        while (it.hasNext()) {\r\n            final SAMRecord first = it.next();\r\n            final SAMRecord second = it.next();\r\n            if (first.getAttribute(ReservedTagConstants.XN) != null && second.getAttribute(ReservedTagConstants.XN) != null) {\r\n            } else if (!this.includeNonPfReads && (first.getReadFailsVendorQualityCheckFlag() || second.getReadFailsVendorQualityCheckFlag())) {\r\n            } else {\r\n                count++;\r\n            }\r\n        }\r\n    }\r\n    it.close();\r\n    CloserUtil.close(reader);\r\n    return count;\r\n}"
}, {
	"Path": "picard.sam.markduplicates.util.MarkQueue.getToMarkQueueMinimumDistance",
	"Comment": "returns the minimum genomic distance such that we can be assured that all duplicates have been considered.",
	"Method": "int getToMarkQueueMinimumDistance(){\r\n    return this.toMarkQueueMinimumDistance;\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.isHover",
	"Comment": "indicates if the given row currently has the mouse pointer over it.",
	"Method": "boolean isHover(int row){\r\n    return getBoolean(row, VisualItem.HOVER);\r\n}"
}, {
	"Path": "picard.sam.SamErrorMetric.ErrorMetric.computeQScore",
	"Comment": "compute a qscore given the number of errors and the total number of bases.uses a false count of 1 int the denominator and 1 in the numerator.",
	"Method": "int computeQScore(long numberOfErrors,int computeQScore,long numberOfErrors,long nTotalBases){\r\n    return QualityUtil.getPhredScoreFromErrorProbability((numberOfErrors + PRIOR_ERROR) / (nTotalBases + 1.0D));\r\n}"
}, {
	"Path": "picard.sam.markduplicates.EstimateLibraryComplexity.splitByLibrary",
	"Comment": "takes a list of pairedreadsequence objects and splits them into lists by library.",
	"Method": "Map<String, List<PairedReadSequence>> splitByLibrary(List<PairedReadSequence> input,List<SAMReadGroupRecord> rgs){\r\n    final Map<String, List<PairedReadSequence>> out = new HashMap();\r\n    for (final PairedReadSequence seq : input) {\r\n        String library;\r\n        if (seq.getReadGroup() != -1) {\r\n            library = rgs.get(seq.getReadGroup()).getLibrary();\r\n            if (library == null)\r\n                library = \"Unknown\";\r\n        } else {\r\n            library = \"Unknown\";\r\n        }\r\n        List<PairedReadSequence> librarySeqs = out.get(library);\r\n        if (librarySeqs == null) {\r\n            librarySeqs = new ArrayList();\r\n            out.put(library, librarySeqs);\r\n        }\r\n        librarySeqs.add(seq);\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "prefuse.data.CascadedTable.getParentTable",
	"Comment": "get the parent table from which this cascaded table inherits values.",
	"Method": "Table getParentTable(){\r\n    return m_parent;\r\n}"
}, {
	"Path": "net.pms.PMS.setHelpPage",
	"Comment": "sets the relative url of a context sensitive help page located in the\tdocumentation directory.",
	"Method": "void setHelpPage(String page){\r\n    helpPage = page;\r\n}"
}, {
	"Path": "com.google.gwt.sample.dynatablerf.client.PersonEditorWorkflow.onCancel",
	"Comment": "called by the cancel button when it is clicked. this method will just teardown the ui and clear the state of the workflow.",
	"Method": "void onCancel(ClickEvent event){\r\n    dialog.hide();\r\n}"
}, {
	"Path": "java.nio.CharBuffer.put",
	"Comment": "writes chars from the given char array, starting from the specified offset, to the current position and increases the\tposition by the number of chars written.",
	"Method": "CharBuffer put(char c,CharBuffer put,char[] src,CharBuffer put,char[] src,int off,int len){\r\n    int length = src.length;\r\n    if ((off < 0) || (len < 0) || (long) off + (long) len > length) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    if (len > remaining()) {\r\n        throw new BufferOverflowException();\r\n    }\r\n    for (int i = off; i < off + len; i++) {\r\n        put(src[i]);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "prefuse.Visualization.getDisplay",
	"Comment": "get the display at the given list index. displays are numbered by theorder in which they are added to this visualization.",
	"Method": "Display getDisplay(int idx){\r\n    return (Display) m_displays.get(idx);\r\n}"
}, {
	"Path": "prefuse.action.filter.GraphDistanceFilter.getSources",
	"Comment": "get the name of the group to use as source nodes for measuringgraph distance. these form the roots from which the graph distanceis measured.",
	"Method": "String getSources(){\r\n    return m_sources;\r\n}"
}, {
	"Path": "prefuse.util.ColorLib.hsb",
	"Comment": "get the color code for the given hue, saturation, and brightnessvalues, translating from hsb color space to rgb color space.",
	"Method": "int hsb(float h,float s,float b){\r\n    return Color.HSBtoRGB(h, s, b);\r\n}"
}, {
	"Path": "prefuse.data.Table.setTuple",
	"Comment": "clears the contents of this table and then attempts to add the giventuple instance.",
	"Method": "Tuple setTuple(Tuple t){\r\n    clear();\r\n    return addTuple(t);\r\n}"
}, {
	"Path": "prefuse.data.query.RangeQueryBinding.getModel",
	"Comment": "return the valuedrangemodel constructed by this dynamic query binding.this model backs any user interface components generated by thisinstance.",
	"Method": "ValuedRangeModel getModel(){\r\n    return m_model;\r\n}"
}, {
	"Path": "picard.sam.testers.SamFileTester.runTest",
	"Comment": "sets up the basic command line arguments for input and output and runs instancemain.",
	"Method": "void runTest(){\r\n    final File input = createInputFile();\r\n    output = new File(outputDir, \"output.sam\");\r\n    args.add(\"INPUT=\" + input.getAbsoluteFile());\r\n    args.add(\"OUTPUT=\" + output.getAbsoluteFile());\r\n    Assert.assertEquals(runPicardCommandLine(args), 0);\r\n    test();\r\n}"
}, {
	"Path": "prefuse.activity.Activity.setScheduled",
	"Comment": "sets whether or not this activity has been scheduled. this method shouldonly be called by the activitymanager.",
	"Method": "void setScheduled(boolean s){\r\n    boolean fire;\r\n    synchronized (this) {\r\n        fire = (s && !m_isScheduled);\r\n        m_isScheduled = s;\r\n    }\r\n    if (fire)\r\n        fireActivityScheduled();\r\n}"
}, {
	"Path": "prefuse.controls.AbstractZoomControl.isZoomOverItem",
	"Comment": "indicates if the zoom control will work while the mouse isover a visualitem.",
	"Method": "boolean isZoomOverItem(){\r\n    return m_zoomOverItem;\r\n}"
}, {
	"Path": "com.restfb.json.JsonObject.iterator",
	"Comment": "returns an iterator over the members of this object in document order. the returned iterator cannot be used tomodify this object.",
	"Method": "Iterator<Member> iterator(){\r\n    final Iterator<String> namesIterator = names.iterator();\r\n    final Iterator<JsonValue> valuesIterator = values.iterator();\r\n    return new Iterator<JsonObject.Member>() {\r\n        public boolean hasNext() {\r\n            return namesIterator.hasNext();\r\n        }\r\n        public Member next() {\r\n            String name = namesIterator.next();\r\n            JsonValue value = valuesIterator.next();\r\n            return new Member(name, value);\r\n        }\r\n        public void remove() {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.restfb.json.JsonObject.iterator",
	"Comment": "returns an iterator over the members of this object in document order. the returned iterator cannot be used tomodify this object.",
	"Method": "Iterator<Member> iterator(){\r\n    return namesIterator.hasNext();\r\n}"
}, {
	"Path": "com.restfb.json.JsonObject.iterator",
	"Comment": "returns an iterator over the members of this object in document order. the returned iterator cannot be used tomodify this object.",
	"Method": "Iterator<Member> iterator(){\r\n    String name = namesIterator.next();\r\n    JsonValue value = valuesIterator.next();\r\n    return new Member(name, value);\r\n}"
}, {
	"Path": "com.restfb.json.JsonObject.iterator",
	"Comment": "returns an iterator over the members of this object in document order. the returned iterator cannot be used tomodify this object.",
	"Method": "Iterator<Member> iterator(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "picard.vcf.filter.TestFilterVcf.testNoFiltering",
	"Comment": "tests that all records get pass set as their filter when extreme values are used for filtering.",
	"Method": "void testNoFiltering(File input){\r\n    final File out = testFiltering(input, \".vcf.gz\", 0, 0, 0, Double.MAX_VALUE);\r\n    final VCFFileReader in = new VCFFileReader(out, false);\r\n    for (final VariantContext ctx : in) {\r\n        if (!ctx.filtersWereApplied() || ctx.isFiltered()) {\r\n            Assert.fail(\"Context should not have been filtered: \" + ctx.toString());\r\n        }\r\n    }\r\n    in.close();\r\n}"
}, {
	"Path": "picard.illumina.ClusterDataToSamConverter.withMolecularIndexQualityTag",
	"Comment": "sets the sam tag to use to store the molecular index base qualities.if multiple molecular indexes exist, it will concatenate themand store them in this tag.",
	"Method": "ClusterDataToSamConverter withMolecularIndexQualityTag(String molecularIndexQualityTag){\r\n    if (molecularIndexQualityTag == null) {\r\n        throw new IllegalArgumentException(\"Molecular index quality tag was null\");\r\n    }\r\n    this.MOLECULAR_INDEX_QUALITY_TAG = molecularIndexQualityTag;\r\n    return this;\r\n}"
}, {
	"Path": "prefuse.Display.addItemBoundsListener",
	"Comment": "add an itemboundslistener to receive notifications when the boundsoccupied by the visualitems in this display change.",
	"Method": "void addItemBoundsListener(ItemBoundsListener ibl){\r\n    if (m_bounders == null)\r\n        m_bounders = new CopyOnWriteArrayList();\r\n    m_bounders.add(ibl);\r\n}"
}, {
	"Path": "prefuse.data.util.Sort.getComparator",
	"Comment": "generates a comparator to be used for sorting tuples drawn fromthe given tuple set.",
	"Method": "Comparator getComparator(TupleSet ts){\r\n    Schema s = null;\r\n    if (ts instanceof Table) {\r\n        s = ((Table) ts).getSchema();\r\n    } else {\r\n        if (ts.getTupleCount() == 0)\r\n            return new NullComparator();\r\n        s = ((Tuple) ts.tuples().next()).getSchema();\r\n    }\r\n    CompositeComparator cc = new CompositeComparator(m_fields.length);\r\n    for (int i = 0; i < m_fields.length; ++i) {\r\n        cc.add(new TupleComparator(m_fields[i], s.getColumnType(m_fields[i]), m_ascend[i]));\r\n    }\r\n    return cc;\r\n}"
}, {
	"Path": "com.restfb.types.OpenGraphPropertyConfig.getStructConfig",
	"Comment": "for struct properties, the config for the nested properties",
	"Method": "Map<String, OpenGraphPropertyConfig> getStructConfig(){\r\n    return Collections.unmodifiableMap(structConfig);\r\n}"
}, {
	"Path": "prefuse.data.column.ColumnMetadata.getOrdinalMap",
	"Comment": "get a map between all unique column values and their integer indexin the sort order of those values. for example, the minimum valuemaps to 0, the next greater value to 1, etc.",
	"Method": "Map getOrdinalMap(){\r\n    accessCheck();\r\n    if (m_ordinalM == null && m_dynamic) {\r\n        Object[] a = getOrdinalArray();\r\n        m_ordinalM = new HashMap();\r\n        for (int i = 0; i < a.length; ++i) m_ordinalM.put(a[i], new Integer(i));\r\n    }\r\n    return m_ordinalM;\r\n}"
}, {
	"Path": "prefuse.data.Table.tuples",
	"Comment": "get an iterator over the tuples for the given rows in this table.",
	"Method": "Iterator tuples(Iterator tuples,IntIterator rows){\r\n    return m_tuples.iterator(rows);\r\n}"
}, {
	"Path": "net.pms.util.Iso639.putCode",
	"Comment": "add a full language name and up to three language codes to the mapping.\tthe language codes can be null.",
	"Method": "void putCode(String language,String iso6391,String iso6392,String iso6392bis){\r\n    ArrayList<String> codeArray = new ArrayList<String>();\r\n    if (iso6391 != null) {\r\n        codeArray.add(iso6391);\r\n    }\r\n    if (iso6392 != null) {\r\n        codeArray.add(iso6392);\r\n    }\r\n    if (iso6392bis != null) {\r\n        codeArray.add(iso6392bis);\r\n    }\r\n    String[] newCodes = new String[codeArray.size()];\r\n    codeArray.toArray(newCodes);\r\n    links.put(language, newCodes);\r\n}"
}, {
	"Path": "picard.analysis.artifacts.ContextAccumulator.fillHalfRecords",
	"Comment": "fills a halfcontextaccumulator by summing over the appropriate counts from a fullcontextaccumulator.",
	"Method": "void fillHalfRecords(ContextAccumulator fullContextAccumulator,int contextSize){\r\n    final String padding = StringUtil.repeatCharNTimes('N', contextSize);\r\n    for (Map.Entry<String, AlignmentAccumulator[]> fullContext : fullContextAccumulator.artifactMap.entrySet()) {\r\n        final String fullContextKey = fullContext.getKey();\r\n        final char centralBase = fullContextKey.charAt(contextSize);\r\n        final String leadingContextKey = fullContextKey.substring(0, contextSize) + centralBase + padding;\r\n        final String trailingContextKey = padding + centralBase + fullContextKey.substring(contextSize + 1, fullContextKey.length());\r\n        final AlignmentAccumulator[] trailingAlignmentAccumulators = this.artifactMap.get(trailingContextKey);\r\n        final AlignmentAccumulator[] leadingAlignmentAccumulators = this.artifactMap.get(leadingContextKey);\r\n        final AlignmentAccumulator[] fullAlignmentAccumulators = fullContext.getValue();\r\n        for (int i = 0; i < fullAlignmentAccumulators.length; i++) {\r\n            trailingAlignmentAccumulators[i].merge(fullAlignmentAccumulators[i]);\r\n            leadingAlignmentAccumulators[i].merge(fullAlignmentAccumulators[i]);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "me.vickychijwani.spectre.account.AccountManager.hasActiveBlog",
	"Comment": "the active blog is the one that the user has currently selected in the blog switcher ui",
	"Method": "boolean hasActiveBlog(){\r\n    return !TextUtils.isEmpty(getActiveBlogUrl());\r\n}"
}, {
	"Path": "prefuse.Display.prepareGraphics",
	"Comment": "sets the transform of the provided graphics context to be thetransform of this display and sets the desired rendering hints.",
	"Method": "void prepareGraphics(Graphics2D g){\r\n    if (m_transform != null)\r\n        g.transform(m_transform);\r\n    setRenderingHints(g);\r\n}"
}, {
	"Path": "prefuse.util.StrokeLib.getDerivedStroke",
	"Comment": "get a stroke with the same properties as the given stroke, but witha modified width value.",
	"Method": "BasicStroke getDerivedStroke(BasicStroke s,float width){\r\n    if (s.getLineWidth() == width) {\r\n        return s;\r\n    } else {\r\n        return getStroke(width * s.getLineWidth(), s.getEndCap(), s.getLineJoin(), s.getMiterLimit(), s.getDashArray(), s.getDashPhase());\r\n    }\r\n}"
}, {
	"Path": "picard.fingerprint.Fingerprint.merge",
	"Comment": "merges the likelihoods from the supplied fingerprint into the likelihoods for this fingerprint.",
	"Method": "void merge(Fingerprint other){\r\n    final Set<HaplotypeBlock> haps = new HashSet();\r\n    haps.addAll(keySet());\r\n    haps.addAll(other.keySet());\r\n    for (final HaplotypeBlock haplotype : haps) {\r\n        HaplotypeProbabilities probabilities = get(haplotype);\r\n        final HaplotypeProbabilities otherProbabilities = other.get(haplotype);\r\n        if (probabilities == null) {\r\n            probabilities = otherProbabilities;\r\n            put(haplotype, probabilities);\r\n        } else if (otherProbabilities != null) {\r\n            probabilities.merge(otherProbabilities);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "quickfix.SessionSettings.getDouble",
	"Comment": "gets a double value from the default section of the settings.",
	"Method": "double getDouble(String key,double getDouble,SessionID sessionID,String key){\r\n    try {\r\n        return Double.parseDouble(getString(sessionID, key));\r\n    } catch (final NumberFormatException e) {\r\n        throw new FieldConvertError(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.canSetString",
	"Comment": "indicates if convenience set method can be called withoutan exception being thrown for the string type.",
	"Method": "boolean canSetString(){\r\n    return m_parser != null && !(m_parser instanceof ObjectParser);\r\n}"
}, {
	"Path": "net.pms.dlna.virtual.VirtualFolder.getThumbnailContentType",
	"Comment": "returns the thumbnailcontenttype associated to the thumbnail associated to this container.",
	"Method": "String getThumbnailContentType(){\r\n    return thumbnailContentType;\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.ForceDirectedLayout.getMaxTimeStep",
	"Comment": "get the maximum timestep allowed for integrating node settings betweenruns of this layout. when computation times are longer than desired,and node positions are changing dramatically between animated frames,the max step time can be lowered to suppress node movement.",
	"Method": "long getMaxTimeStep(){\r\n    return m_maxstep;\r\n}"
}, {
	"Path": "picard.metrics.MultiLevelCollector.setup",
	"Comment": "use an init method so that overloaded methods in subclasses can pass use parameters that are initialized in their constructor",
	"Method": "void setup(Set<MetricAccumulationLevel> accumulationLevels,List<SAMReadGroupRecord> samRgRecords){\r\n    outputOrderedDistributors = new ArrayList<Distributor>(4);\r\n    if (accumulationLevels.contains(MetricAccumulationLevel.ALL_READS)) {\r\n        outputOrderedDistributors.add(new AllReadsDistributor(samRgRecords));\r\n    }\r\n    if (accumulationLevels.contains(MetricAccumulationLevel.SAMPLE)) {\r\n        outputOrderedDistributors.add(new SampleDistributor(samRgRecords));\r\n    }\r\n    if (accumulationLevels.contains(MetricAccumulationLevel.LIBRARY)) {\r\n        outputOrderedDistributors.add(new LibraryDistributor(samRgRecords));\r\n    }\r\n    if (accumulationLevels.contains(MetricAccumulationLevel.READ_GROUP)) {\r\n        outputOrderedDistributors.add(new ReadGroupCollector(samRgRecords));\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.tuple.CompositeTupleSet.hasSet",
	"Comment": "indicates if this composite contains a tupleset with the given name.",
	"Method": "boolean hasSet(String name){\r\n    return m_map.containsKey(name);\r\n}"
}, {
	"Path": "net.pms.util.PlayerUtil.isImage",
	"Comment": "returns whether or not the supplied dlna resource is an image file.",
	"Method": "boolean isImage(DLNAResource resource,boolean isImage,DLNAResource resource,Format.Identifier identifier){\r\n    return isType(resource, Format.IMAGE, identifier);\r\n}"
}, {
	"Path": "picard.fingerprint.FingerprintChecker.setMinimumBaseQuality",
	"Comment": "sets the minimum base quality for bases used when computing a fingerprint from sequence data.",
	"Method": "void setMinimumBaseQuality(int minimumBaseQuality){\r\n    this.minimumBaseQuality = minimumBaseQuality;\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeBlock.getSnps",
	"Comment": "returns an unmodifiable, unordered, collection of all snps in this haplotype block.",
	"Method": "Collection<Snp> getSnps(){\r\n    return Collections.unmodifiableCollection(this.snpsByName.values());\r\n}"
}, {
	"Path": "prefuse.data.Graph.dispose",
	"Comment": "dispose of this graph. unregisters this graph as a listener to itsincluded tables.",
	"Method": "void dispose(){\r\n    getNodeTable().removeTableListener(m_listener);\r\n    getEdgeTable().removeTableListener(m_listener);\r\n}"
}, {
	"Path": "prefuse.data.Schema.lockSchema",
	"Comment": "locks the schema, preventing any additional changes. locked schemascan not be unlocked! cloned copies of a locked schema will not inheritthis locked status.",
	"Method": "Schema lockSchema(){\r\n    m_locked = true;\r\n    return this;\r\n}"
}, {
	"Path": "prefuse.data.Graph.clearEdges",
	"Comment": "internal method for clearing the edge table, removing all edges.",
	"Method": "void clearEdges(){\r\n    getEdgeTable().clear();\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.setId",
	"Comment": "set the id of this resource based on the index in its parent container.\tits main purpose is to be unique in the parent container. the method is\tautomatically called by addchildinternal, so most of the time it is not\tnecessary to call it explicitly.",
	"Method": "void setId(String id){\r\n    this.id = id;\r\n}"
}, {
	"Path": "quickfix.ApplicationExtendedFunctionalAdapter.removeBeforeSessionResetListener",
	"Comment": "remove a consumer of sessionid from onbeforesessionreset operation.",
	"Method": "void removeBeforeSessionResetListener(Consumer<SessionID> onBeforeSessionReset){\r\n    onBeforeSessionResetListeners.remove(onBeforeSessionReset);\r\n}"
}, {
	"Path": "quickfix.CompositeLogFactory.create",
	"Comment": "create the composite log. this is typically used by the sessionfactory.",
	"Method": "Log create(SessionID sessionID){\r\n    Log[] logs = new Log[logFactories.length];\r\n    for (int i = 0; i < logFactories.length; i++) {\r\n        if (logFactories[i] instanceof LocationAwareLogFactory) {\r\n            logs[i] = ((LocationAwareLogFactory) logFactories[i]).create(sessionID, CompositeLog.class.getName());\r\n        } else {\r\n            logs[i] = logFactories[i].create(sessionID);\r\n        }\r\n    }\r\n    return new CompositeLog(logs);\r\n}"
}, {
	"Path": "quickfix.mina.message.FIXMessageDecoder.parseMessage",
	"Comment": "this method cannot move the buffer position until a message is found or anerror has occurred. otherwise, mina will compact the buffer and we losedata.",
	"Method": "boolean parseMessage(IoBuffer in,ProtocolDecoderOutput out){\r\n    try {\r\n        boolean messageFound = false;\r\n        while (in.hasRemaining() && !messageFound) {\r\n            if (state == SEEKING_HEADER) {\r\n                long headerPos = HEADER_PATTERN.find(in, position);\r\n                if (headerPos == -1L) {\r\n                    break;\r\n                }\r\n                int headerOffset = (int) headerPos;\r\n                int headerLength = (int) (headerPos >>> 32);\r\n                in.position(headerOffset);\r\n                if (log.isDebugEnabled()) {\r\n                    log.debug(\"detected header: {}\", getBufferDebugInfo(in));\r\n                }\r\n                position = headerOffset + headerLength;\r\n                state = PARSING_LENGTH;\r\n            }\r\n            if (state == PARSING_LENGTH) {\r\n                byte ch = 0;\r\n                while (position < in.limit()) {\r\n                    ch = in.get(position++);\r\n                    if (ch < '0' || ch > '9') {\r\n                        if (bodyLength == 0) {\r\n                            handleError(in, in.position() + 1, \"Encountered invalid body length: \" + (char) ch, false);\r\n                        }\r\n                        break;\r\n                    }\r\n                    bodyLength = bodyLength * 10 + (ch - '0');\r\n                }\r\n                if (state == SEEKING_HEADER) {\r\n                    continue;\r\n                }\r\n                if (ch == SOH) {\r\n                    state = READING_BODY;\r\n                    if (log.isDebugEnabled()) {\r\n                        log.debug(\"body length = {}: {}\", bodyLength, getBufferDebugInfo(in));\r\n                    }\r\n                } else {\r\n                    if (position < in.limit()) {\r\n                        String messageString = getMessageStringForError(in);\r\n                        handleError(in, in.position() + 1, \"Length format error in message (last character: \" + (char) ch + \"): \" + messageString, false);\r\n                        continue;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (state == READING_BODY) {\r\n                if (in.limit() - position < bodyLength) {\r\n                    break;\r\n                }\r\n                position += bodyLength;\r\n                state = PARSING_CHECKSUM;\r\n                if (log.isDebugEnabled()) {\r\n                    log.debug(\"message body found: {}\", getBufferDebugInfo(in));\r\n                }\r\n            }\r\n            if (state == PARSING_CHECKSUM) {\r\n                if (CHECKSUM_PATTERN.match(in, position) > 0) {\r\n                    if (in.get(position - 1) != SOH) {\r\n                        handleError(in, position, \"checksum field not preceded by SOH, bad length?\", isLogon(in));\r\n                        continue;\r\n                    }\r\n                    if (log.isDebugEnabled()) {\r\n                        log.debug(\"found checksum: {}\", getBufferDebugInfo(in));\r\n                    }\r\n                    position += CHECKSUM_PATTERN.getMinLength();\r\n                } else {\r\n                    if (position + CHECKSUM_PATTERN.getMinLength() <= in.limit()) {\r\n                        int recoveryPosition = position + 1;\r\n                        handleError(in, recoveryPosition, \"did not find checksum field, bad length?\", isLogon(in));\r\n                        continue;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                String messageString = getMessageString(in);\r\n                if (log.isDebugEnabled()) {\r\n                    log.debug(\"parsed message: {} {}\", getBufferDebugInfo(in), messageString);\r\n                }\r\n                out.write(messageString);\r\n                state = SEEKING_HEADER;\r\n                bodyLength = 0;\r\n                messageFound = true;\r\n            }\r\n        }\r\n        return messageFound;\r\n    } catch (Throwable t) {\r\n        resetState();\r\n        if (t instanceof ProtocolCodecException) {\r\n            throw (ProtocolCodecException) t;\r\n        } else {\r\n            throw new ProtocolCodecException(t);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "paperparcel.Utils.findLargestPublicConstructor",
	"Comment": "returns the public constructor in a given class with the largest number of arguments, ornull if there are no public constructors.",
	"Method": "ExecutableElement findLargestPublicConstructor(TypeElement typeElement){\r\n    List<ExecutableElement> constructors = FluentIterable.from(ElementFilter.constructorsIn(typeElement.getEnclosedElements())).filter(FILTER_NON_PUBLIC).toList();\r\n    if (constructors.size() == 0) {\r\n        return null;\r\n    }\r\n    return PARAMETER_COUNT_ORDER.max(constructors);\r\n}"
}, {
	"Path": "prefuse.render.LabelRenderer.getHorizontalPadding",
	"Comment": "returns the amount of padding in pixels between the content and the border of this item along the horizontal dimension.",
	"Method": "int getHorizontalPadding(){\r\n    return m_horizBorder;\r\n}"
}, {
	"Path": "com.restfb.types.User.getIdsForApps",
	"Comment": "businesses can claim ownership of multiple apps using business manager.this method returns the list of ids that this user has in any of those other apps",
	"Method": "List<UserIDForApp> getIdsForApps(){\r\n    return unmodifiableList(idsForApps);\r\n}"
}, {
	"Path": "net.pms.newgui.HelpTab.build",
	"Comment": "set up the panel for the help tab and load its contents from a file.",
	"Method": "JComponent build(){\r\n    FormLayout layout = new FormLayout(\"left:pref, 0:grow\", \"pref, fill:default:grow\");\r\n    PanelBuilder builder = new PanelBuilder(layout);\r\n    builder.opaque(true);\r\n    CellConstraints cc = new CellConstraints();\r\n    editorPane = new JEditorPane();\r\n    editorPane.setEditable(false);\r\n    editorPane.setContentType(\"text/html\");\r\n    editorPane.setBackground(Color.WHITE);\r\n    updateContents();\r\n    editorPane.addHyperlinkListener(new HyperlinkListener() {\r\n        public void hyperlinkUpdate(HyperlinkEvent event) {\r\n            try {\r\n                if (event.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {\r\n                    String urlString = event.getURL().toExternalForm();\r\n                    if (urlString.startsWith(\"http://\") || urlString.startsWith(\"https://\") || urlString.startsWith(\"ftp://\")) {\r\n                        URI uri = new URI(urlString);\r\n                        Desktop.getDesktop().browse(uri);\r\n                    } else {\r\n                        editorPane.setPage(event.getURL());\r\n                    }\r\n                }\r\n            } catch (IOException e) {\r\n                logger.debug(\"Caught exception\", e);\r\n            } catch (URISyntaxException e) {\r\n                logger.debug(\"Caught exception\", e);\r\n            }\r\n        }\r\n    });\r\n    JScrollPane pane = new JScrollPane(editorPane, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);\r\n    pane.setPreferredSize(new Dimension(500, 400));\r\n    pane.setBorder(BorderFactory.createEmptyBorder());\r\n    builder.add(pane, cc.xy(2, 2));\r\n    return builder.getPanel();\r\n}"
}, {
	"Path": "net.pms.newgui.HelpTab.build",
	"Comment": "set up the panel for the help tab and load its contents from a file.",
	"Method": "JComponent build(){\r\n    try {\r\n        if (event.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {\r\n            String urlString = event.getURL().toExternalForm();\r\n            if (urlString.startsWith(\"http://\") || urlString.startsWith(\"https://\") || urlString.startsWith(\"ftp://\")) {\r\n                URI uri = new URI(urlString);\r\n                Desktop.getDesktop().browse(uri);\r\n            } else {\r\n                editorPane.setPage(event.getURL());\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        logger.debug(\"Caught exception\", e);\r\n    } catch (URISyntaxException e) {\r\n        logger.debug(\"Caught exception\", e);\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.Table.canGetLong",
	"Comment": "check if the given data field can return primitive longvalues.",
	"Method": "boolean canGetLong(String field){\r\n    Column col = getColumn(field);\r\n    return (col == null ? false : col.canGetLong());\r\n}"
}, {
	"Path": "picard.sam.AbstractAlignmentMerger.fixNmMdAndUq",
	"Comment": "calculates and sets the nm, md, and and uq tags from the record and the reference",
	"Method": "void fixNmMdAndUq(SAMRecord record,ReferenceSequenceFileWalker refSeqWalker,boolean isBisulfiteSequence){\r\n    final byte[] referenceBases = refSeqWalker.get(record.getReferenceIndex()).getBases();\r\n    SequenceUtil.calculateMdAndNmTags(record, referenceBases, true, !isBisulfiteSequence);\r\n    if (isBisulfiteSequence) {\r\n        record.setAttribute(SAMTag.NM.name(), SequenceUtil.calculateSamNmTag(record, referenceBases, 0, isBisulfiteSequence));\r\n    }\r\n    fixUq(record, refSeqWalker, isBisulfiteSequence);\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.getEndFont",
	"Comment": "get the ending font for the row. the font is used as the defaulttypeface for drawing text for this item.",
	"Method": "Font getEndFont(int row){\r\n    return (Font) get(row, VisualItem.ENDFONT);\r\n}"
}, {
	"Path": "java.nio.Buffer.rewind",
	"Comment": "rewinds this buffer.\tthe position is set to zero, and the mark is cleared. the content of this buffer is not changed.",
	"Method": "Buffer rewind(){\r\n    position = 0;\r\n    mark = UNSET_MARK;\r\n    return this;\r\n}"
}, {
	"Path": "prefuse.controls.AnchorUpdateControl.moveEvent",
	"Comment": "registers a mouse move event, updating the anchor point for allregistered layout instances.",
	"Method": "void moveEvent(MouseEvent e){\r\n    Display d = (Display) e.getSource();\r\n    d.getAbsoluteCoordinate(e.getPoint(), m_tmp);\r\n    for (int i = 0; i < m_layouts.length; i++) m_layouts[i].setLayoutAnchor(m_tmp);\r\n    runAction(e);\r\n}"
}, {
	"Path": "prefuse.data.util.FilterIteratorFactory.rows",
	"Comment": "get a filtered iterator over the rows in the given table,filtered by the given predicate.",
	"Method": "IntIterator rows(Table t,Predicate p){\r\n    IntIterator iter = null;\r\n    iter = getOptimizedIterator(t, p);\r\n    if (iter == null) {\r\n        iter = new FilterRowIterator(t.rows(), t, p);\r\n    }\r\n    return iter;\r\n}"
}, {
	"Path": "picard.util.ClippingUtility.attemptOneSidedMatch",
	"Comment": "when an adapter is matched in only one end of a pair, we check it again withstricter thresholds.if it still matches, then we trim both ends of the readat the same location.",
	"Method": "boolean attemptOneSidedMatch(SAMRecord read1,SAMRecord read2,int index1,int index2,int stricterMinMatchBases){\r\n    final int matchedIndex = index1 == NO_MATCH ? index2 : index1;\r\n    final SAMRecord matchedRead = index1 == NO_MATCH ? read2 : read1;\r\n    if (matchedRead.getReadLength() - matchedIndex >= stricterMinMatchBases) {\r\n        if (read1.getReadBases().length > matchedIndex) {\r\n            read1.setAttribute(ReservedTagConstants.XT, matchedIndex + 1);\r\n        }\r\n        if (read2.getReadBases().length > matchedIndex) {\r\n            read2.setAttribute(ReservedTagConstants.XT, matchedIndex + 1);\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.i18n.CwNumberFormat.showErrorMessage",
	"Comment": "show an error message. pass in null to clear the error message.",
	"Method": "void showErrorMessage(String errorMsg){\r\n    if (errorMsg == null) {\r\n        formattedBox.removeStyleName(\"cw-RedText\");\r\n    } else {\r\n        formattedBox.setText(errorMsg);\r\n        formattedBox.addStyleName(\"cw-RedText\");\r\n    }\r\n}"
}, {
	"Path": "picard.analysis.TheoreticalSensitivity.drawSumOfQScores",
	"Comment": "simulates the sum of base qualities taken from reads that support the alternate allele bytaking advantage of the fact that the sum of draws from a distribution tends towards agaussian per the central limit theorem.",
	"Method": "int drawSumOfQScores(int altDepth,double averageQuality,double standardDeviationQuality,double z){\r\n    return (int) (altDepth * averageQuality + z * Math.sqrt(altDepth) * standardDeviationQuality);\r\n}"
}, {
	"Path": "prefuse.data.io.sql.DatabaseDataSource.getExistingRow",
	"Comment": "see if a retrieved database row is already represented in the giventable.",
	"Method": "int getExistingRow(Table t,ResultSet rset,String keyField){\r\n    if (keyField == null)\r\n        return -1;\r\n    Class type = t.getColumnType(keyField);\r\n    if (type == null)\r\n        return -1;\r\n    Index index = t.index(keyField);\r\n    if (type == int.class) {\r\n        return index.get(rset.getInt(keyField));\r\n    } else if (type == long.class) {\r\n        return index.get(rset.getLong(keyField));\r\n    } else if (type == float.class) {\r\n        return index.get(rset.getFloat(keyField));\r\n    } else if (type == double.class) {\r\n        return index.get(rset.getDouble(keyField));\r\n    } else if (!type.isPrimitive()) {\r\n        return index.get(rset.getObject(keyField));\r\n    } else {\r\n        return -1;\r\n    }\r\n}"
}, {
	"Path": "picard.sam.AbstractAlignmentMerger.setAttributesToReverse",
	"Comment": "sets the set of attributes to be reversed on reads marked as negative strand.",
	"Method": "void setAttributesToReverse(Set<String> attributesToReverse){\r\n    this.attributesToReverse = attributesToReverse;\r\n}"
}, {
	"Path": "picard.illumina.IlluminaBasecallsToSamTest.testCorruptDataReturnCode",
	"Comment": "ensures that a run missing a barcode from the parameters file throws an error.",
	"Method": "void testCorruptDataReturnCode(){\r\n    boolean exceptionThrown = false;\r\n    try {\r\n        runStandardTest(9, \"dualBarcode.\", \"negative_test.params\", 2, \"30T8B8B\", BASECALLS_DIR, TEST_DATA_DIR, null, false, ClusterDataToSamConverter.PopulateBarcode.ORPHANS_ONLY, false);\r\n    } catch (Throwable e) {\r\n        exceptionThrown = true;\r\n    } finally {\r\n        Assert.assertTrue(exceptionThrown);\r\n    }\r\n}"
}, {
	"Path": "picard.sam.markduplicates.MarkDuplicatesWithMateCigarIterator.nextIfRecordIsUnmappedAtEOF",
	"Comment": "this handles unmapped records at the end of the file.if this is the first time we have found them, then wecan empty the tomarkqueue and call markduplicatesandgetthenextavailable, otherwise we can just emit them.theduplication metrics will be updated.",
	"Method": "SAMRecord nextIfRecordIsUnmappedAtEOF(SAMRecord record){\r\n    if (foundUnmappedEOFReads) {\r\n        final SAMRecord unmappedRecord = backingIterator.next();\r\n        if (!record.isSecondaryOrSupplementary()) {\r\n            final DuplicationMetrics metrics = getMetrics(record);\r\n            ++metrics.UNMAPPED_READS;\r\n        }\r\n        if (!outputBuffer.isEmpty()) {\r\n            throw new PicardException(\"Encountered unmapped reads at the end of the file, but the alignment start buffer was not empty.\");\r\n        }\r\n        return unmappedRecord;\r\n    } else {\r\n        foundUnmappedEOFReads = true;\r\n        referenceIndex = header.getSequenceDictionary().getSequences().size();\r\n        tryPollingTheToMarkQueue(true, null);\r\n        return markDuplicatesAndGetTheNextAvailable();\r\n    }\r\n}"
}, {
	"Path": "prefuse.activity.Activity.isEnabled",
	"Comment": "indicates whether or not this activity is currently enabled.",
	"Method": "boolean isEnabled(){\r\n    return m_enabled;\r\n}"
}, {
	"Path": "prefuse.data.Table.canSetDouble",
	"Comment": "check if the setdouble method can safely be used for thegiven data field.",
	"Method": "boolean canSetDouble(String field){\r\n    Column col = getColumn(field);\r\n    return (col == null ? false : col.canSetDouble());\r\n}"
}, {
	"Path": "prefuse.data.search.LuceneSearcher.getIndexSearcher",
	"Comment": "returns the lucene indexsearcher. see lucene documentationfor more details.",
	"Method": "Searcher getIndexSearcher(){\r\n    return searcher;\r\n}"
}, {
	"Path": "net.pms.network.UPNPHelper.shutDownListener",
	"Comment": "shut down the threads that send alive messages and listen to responses.",
	"Method": "void shutDownListener(){\r\n    listenerThread.interrupt();\r\n    aliveThread.interrupt();\r\n}"
}, {
	"Path": "com.egzosn.pay.paypal.bean.order.CartBase.getSoftDescriptor",
	"Comment": "soft descriptor used when charging this funding source. if length exceeds max length, the value will be truncated",
	"Method": "String getSoftDescriptor(){\r\n    return this.softDescriptor;\r\n}"
}, {
	"Path": "quickfix.MessageUtils.length",
	"Comment": "calculates the length of the byte representationof the given string in the given charset.",
	"Method": "int length(Charset charset,String data){\r\n    return CharsetSupport.isStringEquivalent(charset) ? data.length() : data.getBytes(charset).length;\r\n}"
}, {
	"Path": "org.quickfixj.codegenerator.GenerateMojo.setFieldPackage",
	"Comment": "sets the default package to be used during field code generation.",
	"Method": "void setFieldPackage(String fieldPackage){\r\n    this.fieldPackage = fieldPackage;\r\n}"
}, {
	"Path": "picard.vcf.GenotypeConcordanceCounts.getSum",
	"Comment": "returns the sum of all pairs of tuples defined by the truth state set and call state set.",
	"Method": "long getSum(Set<TruthState> truthStateSet,Set<CallState> callStateSet,long getSum){\r\n    return getSum(new HashSet<TruthState>(Arrays.asList(TruthState.values())), new HashSet<CallState>(Arrays.asList(CallState.values())));\r\n}"
}, {
	"Path": "picard.illumina.parser.readers.ClocsFileReader.checkAndAdvanceBin",
	"Comment": "compute offset for next bin and then increment the bin number and reset block information",
	"Method": "void checkAndAdvanceBin(){\r\n    while (currentClusterInBin >= numClustersInBin && currentBin < numBins) {\r\n        if ((currentBin + 1) % NUM_BINS_IN_ROW == 0) {\r\n            xOffset = 0;\r\n            yOffset += BLOCK_SIZE;\r\n        } else {\r\n            xOffset += BLOCK_SIZE;\r\n        }\r\n        currentBin += 1;\r\n        if (currentBin < numBins) {\r\n            startBlock();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "picard.sam.markduplicates.util.MarkQueue.shouldBeInLocations",
	"Comment": "returns true if we should track this for optical duplicate detection, false otherwise",
	"Method": "boolean shouldBeInLocations(ReadEndsForMateCigar current){\r\n    return (current.isPaired() && 0 == current.hasUnmapped);\r\n}"
}, {
	"Path": "net.pms.network.UPNPHelper.sendDiscover",
	"Comment": "send upnp discovery search message to discover devices of interest on\tthe network.",
	"Method": "void sendDiscover(String host,int port,String st){\r\n    String usn = PMS.get().usn();\r\n    String serverHost = PMS.get().getServer().getHost();\r\n    int serverPort = PMS.get().getServer().getPort();\r\n    SimpleDateFormat sdf = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss\", Locale.US);\r\n    sdf.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\r\n    if (st.equals(usn)) {\r\n        usn = \"\";\r\n    } else {\r\n        usn += \"::\";\r\n    }\r\n    StringBuilder discovery = new StringBuilder();\r\n    discovery.append(\"HTTP/1.1 200 OK\").append(CRLF);\r\n    discovery.append(\"CACHE-CONTROL: max-age=1200\").append(CRLF);\r\n    discovery.append(\"DATE: \").append(sdf.format(new Date(System.currentTimeMillis()))).append(\" GMT\").append(CRLF);\r\n    discovery.append(\"LOCATION: http://\").append(serverHost).append(\":\").append(serverPort).append(\"/description/fetch\").append(CRLF);\r\n    discovery.append(\"SERVER: \").append(PMS.get().getServerName()).append(CRLF);\r\n    discovery.append(\"ST: \").append(st).append(CRLF);\r\n    discovery.append(\"EXT: \").append(CRLF);\r\n    discovery.append(\"USN: \").append(usn).append(st).append(CRLF);\r\n    discovery.append(\"Content-Length: 0\").append(CRLF).append(CRLF);\r\n    sendReply(host, port, discovery.toString());\r\n}"
}, {
	"Path": "prefuse.Display.getItemSorter",
	"Comment": "get the itemsorter that determines the rendering order of thevisualitems. items are drawn in ascending order of the scores providedby the itemsorter.",
	"Method": "ItemSorter getItemSorter(){\r\n    return m_queue.sort;\r\n}"
}, {
	"Path": "prefuse.util.PredicateChain.add",
	"Comment": "add a new rule to the end of the chain, associating a predicatecondition with an object value.",
	"Method": "void add(Predicate p,Object val){\r\n    if (m_tail == null) {\r\n        m_tail = new IfExpression(p, new ObjectLiteral(val), m_head);\r\n        m_head = m_tail;\r\n    } else {\r\n        IfExpression ie = new IfExpression(p, new ObjectLiteral(val), m_tail.getElseExpression());\r\n        m_tail.setElseExpression(ie);\r\n        m_tail = ie;\r\n    }\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAMediaAudio.isDTS",
	"Comment": "returns true if this media uses the dts audio codec, false otherwise.",
	"Method": "boolean isDTS(){\r\n    return getCodecA() != null && (getCodecA().startsWith(\"dts\") || getCodecA().equalsIgnoreCase(\"dca\") || getCodecA().equalsIgnoreCase(\"dca (dts)\"));\r\n}"
}, {
	"Path": "com.egzosn.pay.paypal.bean.order.CartBase.setSoftDescriptor",
	"Comment": "soft descriptor used when charging this funding source. if length exceeds max length, the value will be truncated",
	"Method": "CartBase setSoftDescriptor(String softDescriptor){\r\n    this.softDescriptor = softDescriptor;\r\n    return this;\r\n}"
}, {
	"Path": "picard.illumina.parser.TileMetricsUtil.renderTileMetricsFileFromBasecallingDirectory",
	"Comment": "returns the path to the tilemetrics file given the basecalling directory.",
	"Method": "File renderTileMetricsFileFromBasecallingDirectory(File illuminaRunDirectory,int numCycles,boolean isNovaSeq){\r\n    return findTileMetricsFiles(illuminaRunDirectory, numCycles, isNovaSeq).get(0);\r\n}"
}, {
	"Path": "prefuse.data.Table.canGetDouble",
	"Comment": "check if the given data field can return primitive doublevalues.",
	"Method": "boolean canGetDouble(String field){\r\n    Column col = getColumn(field);\r\n    return (col == null ? false : col.canGetDouble());\r\n}"
}, {
	"Path": "net.pms.dlna.virtual.VirtualFolder.isValid",
	"Comment": "returns true, as a container is always a valid item to add to another container.",
	"Method": "boolean isValid(){\r\n    return true;\r\n}"
}, {
	"Path": "com.restfb.types.Conversation.getTags",
	"Comment": "a list of tags indicating the message folder, and whether the conversation is read and seen.",
	"Method": "List<Tag> getTags(){\r\n    return unmodifiableList(tags);\r\n}"
}, {
	"Path": "prefuse.data.Tree.removeChildEdge",
	"Comment": "remove a child edge from the tree. the child node and its subtreewill also be removed from the tree.",
	"Method": "boolean removeChildEdge(int edge,boolean removeChildEdge,Edge e){\r\n    edgeCheck(e, true);\r\n    return removeChild(getTargetNode(e.getRow()));\r\n}"
}, {
	"Path": "com.restfb.types.webhook.messaging.MessageItem.isLike",
	"Comment": "the user may send a like and this method can be used to discover the three know versions of the sticker",
	"Method": "boolean isLike(){\r\n    return \"369239263222822\".equals(stickerId) || \"369239343222814\".equals(stickerId) || \"369239383222810\".equals(stickerId);\r\n}"
}, {
	"Path": "prefuse.render.EdgeRenderer.getHorizontalAlignment2",
	"Comment": "get the horizontal aligment of the edge mount point with the secondnode.",
	"Method": "int getHorizontalAlignment2(){\r\n    return m_xAlign2;\r\n}"
}, {
	"Path": "prefuse.data.Table.getColumnName",
	"Comment": "get the data field name of the column at the given column number.",
	"Method": "String getColumnName(int col){\r\n    return (String) m_names.get(col);\r\n}"
}, {
	"Path": "prefuse.render.EdgeRenderer.getHorizontalAlignment1",
	"Comment": "get the horizontal aligment of the edge mount point with the first node.",
	"Method": "int getHorizontalAlignment1(){\r\n    return m_xAlign1;\r\n}"
}, {
	"Path": "py4j.ClientServer.getPythonServerEntryPoint",
	"Comment": "gets a reference to the entry point on the python side. this is often\tnecessary if java is driving the communication because java cannot call\tstatic methods, initialize python objects or load python modules yet.",
	"Method": "Object getPythonServerEntryPoint(Class[] interfacesToImplement){\r\n    return pythonClient.getPythonServerEntryPoint(gateway, interfacesToImplement);\r\n}"
}, {
	"Path": "picard.util.DbSnpBitSetUtil.createSnpAndIndelBitSets",
	"Comment": "factory method to create both a snp bitmask and an indel bitmask in a single pass of the vcf.if intervals are given, consider only snp and indel sites that overlap the intervals.if log is given,progress loading the variants will be written to the log.",
	"Method": "DbSnpBitSets createSnpAndIndelBitSets(File dbSnpFile,SAMSequenceDictionary sequenceDictionary,DbSnpBitSets createSnpAndIndelBitSets,File dbSnpFile,SAMSequenceDictionary sequenceDictionary,IntervalList intervals,DbSnpBitSets createSnpAndIndelBitSets,File dbSnpFile,SAMSequenceDictionary sequenceDictionary,IntervalList intervals,Optional<Log> log){\r\n    final DbSnpBitSets sets = new DbSnpBitSets();\r\n    sets.snps = new DbSnpBitSetUtil();\r\n    sets.indels = new DbSnpBitSetUtil();\r\n    final Map<DbSnpBitSetUtil, Set<VariantType>> map = new HashMap();\r\n    map.put(sets.snps, EnumSet.of(VariantType.SNP));\r\n    map.put(sets.indels, EnumSet.of(VariantType.insertion, VariantType.deletion));\r\n    loadVcf(dbSnpFile, sequenceDictionary, map, intervals, log);\r\n    return sets;\r\n}"
}, {
	"Path": "prefuse.data.io.sql.DefaultSQLDataHandler.isIgnoreUnknownTypes",
	"Comment": "indicates if unknown or unrecognized sql data types should simply beignored.",
	"Method": "boolean isIgnoreUnknownTypes(){\r\n    return m_ignoreUnknownTypes;\r\n}"
}, {
	"Path": "picard.sam.CreateSequenceDictionary.doWork",
	"Comment": "do the work after command line has been parsed.runtimeexception may be thrown by this method, and are reported appropriately.",
	"Method": "int doWork(){\r\n    if (OUTPUT.exists()) {\r\n        throw new PicardException(OUTPUT.getAbsolutePath() + \" already exists.  Delete this file and try again, or specify a different output file.\");\r\n    }\r\n    final Map<String, Set<String>> aliasesByContig = loadContigAliasesMap();\r\n    final SortingCollection<String> sequenceNames = makeSortingCollection();\r\n    try (BufferedWriter writer = makeWriter()) {\r\n        final ReferenceSequenceFile refSeqFile = ReferenceSequenceFileFactory.getReferenceSequenceFile(REFERENCE_SEQUENCE, TRUNCATE_NAMES_AT_WHITESPACE);\r\n        SAMSequenceDictionaryCodec samDictCodec = new SAMSequenceDictionaryCodec(writer);\r\n        samDictCodec.encodeHeaderLine(false);\r\n        for (ReferenceSequence refSeq = refSeqFile.nextSequence(); refSeq != null; refSeq = refSeqFile.nextSequence()) {\r\n            final SAMSequenceRecord samSequenceRecord = makeSequenceRecord(refSeq);\r\n            final Set<String> aliases = aliasesByContig.get(samSequenceRecord.getSequenceName());\r\n            if (aliases != null) {\r\n                samSequenceRecord.setAttribute(AN_ATTRIBUTE, String.join(\",\", aliases));\r\n            }\r\n            samDictCodec.encodeSequenceRecord(samSequenceRecord);\r\n            sequenceNames.add(refSeq.getName());\r\n        }\r\n    } catch (FileNotFoundException e) {\r\n        throw new PicardException(\"File \" + OUTPUT.getAbsolutePath() + \" not found\");\r\n    } catch (IOException e) {\r\n        throw new PicardException(\"Can't write to or close output file \" + OUTPUT.getAbsolutePath());\r\n    }\r\n    final CloseableIterator<String> iterator = sequenceNames.iterator();\r\n    if (!iterator.hasNext())\r\n        return 0;\r\n    String current = iterator.next();\r\n    while (iterator.hasNext()) {\r\n        final String next = iterator.next();\r\n        if (current.equals(next)) {\r\n            OUTPUT.delete();\r\n            throw new PicardException(\"Sequence name \" + current + \" appears more than once in reference file\");\r\n        }\r\n        current = next;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.google.gwt.sample.dynatablerf.server.PersonSource.of",
	"Comment": "create a personsource that will read through to the given source and makecopies of any objects that are requested.",
	"Method": "PersonSource of(List<Person> people,ScheduleSource schedules,PersonSource of,PersonSource backing,ScheduleSource scheduleBacking){\r\n    return new CopyOnRead(backing, scheduleBacking);\r\n}"
}, {
	"Path": "prefuse.data.Schema.isAssignableFrom",
	"Comment": "indicates if values from a given schema can be safely assigned todata using this schema. the input schema must be less than orequal in length to this schema, and all contained columns in thegiven schema must have matching names and types to this schema.this method does not consider default values settings or thelocked status of the schemas. for example, if the given schemahas different default values than this one, this will have noimpact on the assignability of the two.",
	"Method": "boolean isAssignableFrom(Schema s){\r\n    int ssize = s.getColumnCount();\r\n    if (ssize > m_size)\r\n        return false;\r\n    for (int i = 0; i < ssize; ++i) {\r\n        int idx = getColumnIndex(s.getColumnName(i));\r\n        if (idx < 0)\r\n            return false;\r\n        if (!m_types[idx].equals(s.getColumnType(i)))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "picard.sam.SamToFastqWithTagsTest.testOkGroupedFiles",
	"Comment": "make sure the interleaved fastq and sequence tag fastq contain the same mate pairs",
	"Method": "void testOkGroupedFiles(String samFilename,String[] groupFiles){\r\n    final File samFile = new File(TEST_DATA_DIR, samFilename);\r\n    final Map<String, Set<String>> outputSets = new HashMap(groupFiles.length);\r\n    final String tmpDir = IOUtil.getDefaultTmpDir().getAbsolutePath() + \"/\";\r\n    final String[] args = { \"INPUT=\" + samFile.getAbsolutePath(), \"OUTPUT_PER_RG=true\", \"OUTPUT_DIR=\" + tmpDir, \"INTERLEAVE=true\", \"STG=CR,UR\", \"QTG=CY,UY\" };\r\n    runPicardCommandLine(args);\r\n    Set<String> outputHeaderSet1;\r\n    Set<String> outputHeaderSet2;\r\n    for (final String groupPUName : groupFiles) {\r\n        String keyName1 = groupPUName + \"_1\";\r\n        String keyName2 = groupPUName + \"_CR_UR\";\r\n        String fname1 = tmpDir + \"/\" + keyName1 + \".fastq\";\r\n        String fname2 = tmpDir + \"/\" + keyName2 + \".fastq\";\r\n        File f1 = new File(fname1);\r\n        File f2 = new File(fname2);\r\n        f1.deleteOnExit();\r\n        f2.deleteOnExit();\r\n        IOUtil.assertFileIsReadable(f1);\r\n        IOUtil.assertFileIsReadable(f2);\r\n        outputHeaderSet1 = SamToFastqTest.createFastqReadHeaderSet(f1);\r\n        outputHeaderSet2 = SamToFastqTest.createFastqReadHeaderSet(f2);\r\n        outputSets.put(keyName1, outputHeaderSet1);\r\n        outputSets.put(keyName2, outputHeaderSet2);\r\n        Assert.assertEquals(outputHeaderSet1.size(), outputHeaderSet2.size());\r\n    }\r\n    final Map<String, Map<String, SamToFastqTest.MatePair>> map = SamToFastqTest.createPUPairsMap(samFile);\r\n    for (final Map.Entry<String, Map<String, SamToFastqTest.MatePair>> groupEntry : map.entrySet()) {\r\n        for (final Map.Entry<String, SamToFastqTest.MatePair> entry : groupEntry.getValue().entrySet()) {\r\n            final SamToFastqTest.MatePair mpair = entry.getValue();\r\n            outputHeaderSet1 = outputSets.get(groupEntry.getKey() + \"_1\");\r\n            outputHeaderSet2 = outputSets.get(groupEntry.getKey() + \"_CR_UR\");\r\n            Assert.assertNotNull(mpair.mate1);\r\n            Assert.assertNotNull(mpair.mate2);\r\n            Assert.assertEquals(mpair.mate1.getReadName(), mpair.mate2.getReadName());\r\n            final String readName = mpair.mate1.getReadName();\r\n            Assert.assertTrue(outputHeaderSet1.contains(readName + \"/1\"));\r\n            Assert.assertTrue(outputHeaderSet2.contains(readName + \"/2\"));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.action.layout.StackedAreaChart.getPaddingPercentage",
	"Comment": "gets the percentage of the layout bounds that should be reserved forempty space at the top of the stack.",
	"Method": "double getPaddingPercentage(){\r\n    return m_padding;\r\n}"
}, {
	"Path": "prefuse.util.ColorLib.getColor",
	"Comment": "get a java color object for the given red, green, and blue values.",
	"Method": "Color getColor(float r,float g,float b,float a,Color getColor,float r,float g,float b,Color getColor,int r,int g,int b,int a,Color getColor,int r,int g,int b,Color getColor,int rgba){\r\n    Color c = null;\r\n    if ((c = (Color) colorMap.get(rgba)) == null) {\r\n        c = new Color(rgba, true);\r\n        colorMap.put(rgba, c);\r\n        misses++;\r\n    }\r\n    lookups++;\r\n    return c;\r\n}"
}, {
	"Path": "picard.fingerprint.FingerprintUtils.createVCSetFromFingerprint",
	"Comment": "a utility function that takes a fingerprint and returns a variantcontextset with variants representing the haplotypes in the fingerprint",
	"Method": "VariantContextSet createVCSetFromFingerprint(Fingerprint fingerPrint,ReferenceSequenceFile reference,String sample){\r\n    final VariantContextSet variantContexts = new VariantContextSet(reference.getSequenceDictionary());\r\n    fingerPrint.values().stream().map(hp -> hp.getRepresentativeSnp().getName()).filter(Objects::nonNull).filter(n -> !n.equals(\"\")).collect(Collectors.groupingBy(Function.identity(), Collectors.counting())).entrySet().stream().filter(e -> e.getValue() > 1).findFirst().ifPresent(e -> {\r\n        throw new IllegalArgumentException(\"Found same SNP name twice (\" + e.getKey() + \") in fingerprint. Cannot create a VCF.\");\r\n    });\r\n    fingerPrint.values().stream().map(hp -> getVariantContext(reference, sample, hp)).forEach(variantContexts::add);\r\n    return variantContexts;\r\n}"
}, {
	"Path": "com.restfb.logging.RestFBLogger.getLoggerInstance",
	"Comment": "returns the instance of the logger that belongs to the category.",
	"Method": "RestFBLogger getLoggerInstance(String logCategory){\r\n    Object obj;\r\n    Class[] ctrTypes = new Class[] { String.class };\r\n    Object[] ctrArgs = new Object[] { logCategory };\r\n    try {\r\n        Constructor loggerClassConstructor = usedLoggerClass.getConstructor(ctrTypes);\r\n        obj = loggerClassConstructor.newInstance(ctrArgs);\r\n    } catch (Exception e) {\r\n        throw new FacebookLoggerException(\"cannot create logger: \" + logCategory);\r\n    }\r\n    return (RestFBLogger) obj;\r\n}"
}, {
	"Path": "picard.illumina.parser.readers.MMapBackedIteratorFactoryTest.fileAsBytes",
	"Comment": "remember that the mmappedbinaryfilereader assumes little endianness",
	"Method": "byte[] fileAsBytes(int start,int end){\r\n    final int[] bInts = { 0x31, 0x22, 0x41, 0x01, 0x45, 0x6E, 0x64, 0x4F, 0x66, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x42, 0x6F, 0x64, 0x79, 0x50, 0x61, 0x72, 0x74, 0x6F, 0x66, 0x54, 0x68, 0x65, 0x46, 0x69, 0x6C, 0x65, 0x37, 0x37, 0x0A, 0x45, 0x6E, 0x64, 0x43, 0x6F, 0x6D, 0x6D, 0x75, 0x6E, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E };\r\n    final int total = end - start + 1;\r\n    final byte[] bytes = new byte[total];\r\n    for (int i = 0; i < total; i++) {\r\n        bytes[i] = (byte) bInts[start + i];\r\n    }\r\n    return bytes;\r\n}"
}, {
	"Path": "net.pms.newgui.GeneralTab.addRenderers",
	"Comment": "add the renderer configuration selection after they have been intialized.",
	"Method": "void addRenderers(){\r\n    ArrayList<RendererConfiguration> allConfs = RendererConfiguration.getAllRendererConfigurations();\r\n    ArrayList<Object> keyValues = new ArrayList<Object>();\r\n    ArrayList<Object> nameValues = new ArrayList<Object>();\r\n    keyValues.add(\"\");\r\n    nameValues.add(Messages.getString(\"NetworkTab.37\"));\r\n    if (allConfs != null) {\r\n        sortRendererConfiurationsByName(allConfs);\r\n        for (RendererConfiguration renderer : allConfs) {\r\n            if (renderer != null) {\r\n                keyValues.add(renderer.getRendererName());\r\n                nameValues.add(renderer.getRendererName());\r\n            }\r\n        }\r\n    }\r\n    final KeyedComboBoxModel renderersKcbm = new KeyedComboBoxModel((Object[]) keyValues.toArray(new Object[keyValues.size()]), (Object[]) nameValues.toArray(new Object[nameValues.size()]));\r\n    renderers.setModel(renderersKcbm);\r\n    renderers.setEditable(false);\r\n    String defaultRenderer = configuration.getRendererDefault();\r\n    renderersKcbm.setSelectedKey(defaultRenderer);\r\n    if (renderers.getSelectedIndex() == -1) {\r\n        renderers.setSelectedIndex(0);\r\n    }\r\n    renderers.addItemListener(new ItemListener() {\r\n        public void itemStateChanged(ItemEvent e) {\r\n            if (e.getStateChange() == ItemEvent.SELECTED) {\r\n                logger.info(\"Setting renderer default: \\\"\" + renderersKcbm.getSelectedKey() + \"\\\"\");\r\n                configuration.setRendererDefault((String) renderersKcbm.getSelectedKey());\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "net.pms.newgui.GeneralTab.addRenderers",
	"Comment": "add the renderer configuration selection after they have been intialized.",
	"Method": "void addRenderers(){\r\n    if (e.getStateChange() == ItemEvent.SELECTED) {\r\n        logger.info(\"Setting renderer default: \\\"\" + renderersKcbm.getSelectedKey() + \"\\\"\");\r\n        configuration.setRendererDefault((String) renderersKcbm.getSelectedKey());\r\n    }\r\n}"
}, {
	"Path": "net.pms.network.HTTPResourceAuthenticator.addURL",
	"Comment": "examine a url and if it contains user information, store the username\tand password for that host.",
	"Method": "void addURL(URL url){\r\n    if (url.getUserInfo() != null) {\r\n        siteinfo.put(url.getHost(), url.getUserInfo());\r\n    }\r\n}"
}, {
	"Path": "quickfix.Session.setNextTargetMsgSeqNum",
	"Comment": "set the next expected target message sequence number. this method is notsynchronized.",
	"Method": "void setNextTargetMsgSeqNum(int num){\r\n    state.getMessageStore().setNextTargetMsgSeqNum(num);\r\n}"
}, {
	"Path": "prefuse.data.column.ColumnMetadata.getDeviation",
	"Comment": "get the standard deviation of numeric values in the column. if this columndoes not contain numeric values, this method will result in anexception being thrown.",
	"Method": "double getDeviation(){\r\n    accessCheck();\r\n    if (m_stdev == null && m_dynamic) {\r\n        m_stdev = new Double(DataLib.deviation(m_table.tuples(), m_field, getMean()));\r\n    }\r\n    return m_stdev.doubleValue();\r\n}"
}, {
	"Path": "prefuse.data.io.CSVTableWriter.isPrintHeader",
	"Comment": "indicates if this writer will write a header row with the column names.",
	"Method": "boolean isPrintHeader(){\r\n    return m_printHeader;\r\n}"
}, {
	"Path": "picard.sam.MergeBamAlignmentTest.testMergingFromSeparatedReadTrimmedAlignments",
	"Comment": "minimal test of merging data from separate read 1 and read 2 alignments",
	"Method": "void testMergingFromSeparatedReadTrimmedAlignments(File unmapped,List<File> r1Align,List<File> r2Align,int r1Trim,int r2Trim,String testName){\r\n    final File output = File.createTempFile(\"mergeMultipleAlignmentsTest\", \".sam\");\r\n    output.deleteOnExit();\r\n    doMergeAlignment(unmapped, null, r1Align, r2Align, r1Trim, r2Trim, false, true, false, 1, \"0\", \"1.0\", \"align!\", \"myAligner\", true, fasta, output, SamPairUtil.PairOrientation.FR, null, null, null, null, null);\r\n    SamReaderFactory factory = SamReaderFactory.makeDefault();\r\n    final SamReader result = factory.open(output);\r\n    for (final SAMRecord sam : result) {\r\n        final List<File> rFiles = sam.getFirstOfPairFlag() ? r1Align : r2Align;\r\n        SAMRecord alignment = null;\r\n        for (final File f : rFiles) {\r\n            for (final SAMRecord tmp : factory.open(f)) {\r\n                if (tmp.getReadName().equals(sam.getReadName())) {\r\n                    alignment = tmp;\r\n                    break;\r\n                }\r\n            }\r\n            if (alignment != null)\r\n                break;\r\n        }\r\n        final int trim = sam.getFirstOfPairFlag() ? r1Trim : r2Trim;\r\n        final int notWrittenToFastq = sam.getReadLength() - (trim + alignment.getReadLength());\r\n        final int beginning = sam.getReadNegativeStrandFlag() ? notWrittenToFastq : trim;\r\n        final int end = sam.getReadNegativeStrandFlag() ? trim : notWrittenToFastq;\r\n        if (!sam.getReadUnmappedFlag()) {\r\n            final CigarElement firstMergedCigarElement = sam.getCigar().getCigarElement(0);\r\n            final CigarElement lastMergedCigarElement = sam.getCigar().getCigarElement(sam.getCigar().getCigarElements().size() - 1);\r\n            final CigarElement firstAlignedCigarElement = alignment.getCigar().getCigarElement(0);\r\n            final CigarElement lastAlignedCigarElement = alignment.getCigar().getCigarElement(alignment.getCigar().getCigarElements().size() - 1);\r\n            if (beginning > 0) {\r\n                Assert.assertEquals(firstMergedCigarElement.getOperator(), CigarOperator.S, \"First element is not a soft clip\");\r\n                Assert.assertEquals(firstMergedCigarElement.getLength(), beginning + ((firstAlignedCigarElement.getOperator() == CigarOperator.S) ? firstAlignedCigarElement.getLength() : 0));\r\n            }\r\n            if (end > 0) {\r\n                Assert.assertEquals(lastMergedCigarElement.getOperator(), CigarOperator.S, \"Last element is not a soft clip\");\r\n                Assert.assertEquals(lastMergedCigarElement.getLength(), end + ((lastAlignedCigarElement.getOperator() == CigarOperator.S) ? lastAlignedCigarElement.getLength() : 0));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "picard.vcf.GenotypeConcordanceCounts.getSpecificity",
	"Comment": "returns the specificity defined by the scheme across the subset of truth states.",
	"Method": "double getSpecificity(GenotypeConcordanceScheme scheme,TruthState[] truthStateArray){\r\n    double numerator = 0.0;\r\n    double denominator = 0.0;\r\n    scheme.validateScheme();\r\n    for (final TruthState truthState : truthStateArray) {\r\n        for (final CallState callState : CallState.values()) {\r\n            final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState);\r\n            final long count = getCount(truthAndCallStates);\r\n            for (final ContingencyState contingencyState : scheme.getConcordanceStateArray(truthAndCallStates)) {\r\n                if (ContingencyState.TN == contingencyState) {\r\n                    numerator += count;\r\n                    denominator += count;\r\n                } else if (ContingencyState.FP == contingencyState) {\r\n                    denominator += count;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return (numerator / denominator);\r\n}"
}, {
	"Path": "prefuse.data.util.TupleComparator.compare",
	"Comment": "compares two tuples. if either input object is not a tuple,a classcastexception will be thrown.",
	"Method": "int compare(Object o1,Object o2){\r\n    Tuple t1 = (Tuple) o1, t2 = (Tuple) o2;\r\n    int c = 0;\r\n    if (m_col == -1) {\r\n        if (m_type == int.class || m_type == byte.class) {\r\n            c = ((LiteralComparator) m_cmp).compare(t1.getInt(m_field), t2.getInt(m_field));\r\n        } else if (m_type == double.class) {\r\n            c = ((LiteralComparator) m_cmp).compare(t1.getDouble(m_field), t2.getDouble(m_field));\r\n        } else if (m_type == long.class) {\r\n            c = ((LiteralComparator) m_cmp).compare(t1.getLong(m_field), t2.getLong(m_field));\r\n        } else if (m_type == float.class) {\r\n            c = ((LiteralComparator) m_cmp).compare(t1.getFloat(m_field), t2.getFloat(m_field));\r\n        } else if (m_type == boolean.class) {\r\n            c = ((LiteralComparator) m_cmp).compare(t1.getBoolean(m_field), t2.getBoolean(m_field));\r\n        } else if (!m_type.isPrimitive()) {\r\n            c = m_cmp.compare(t1.get(m_field), t2.get(m_field));\r\n        } else {\r\n            throw new IllegalStateException(\"Unsupported type: \" + m_type.getName());\r\n        }\r\n    } else {\r\n        if (m_type == int.class || m_type == byte.class) {\r\n            c = ((LiteralComparator) m_cmp).compare(t1.getInt(m_col), t2.getInt(m_col));\r\n        } else if (m_type == double.class) {\r\n            c = ((LiteralComparator) m_cmp).compare(t1.getDouble(m_col), t2.getDouble(m_col));\r\n        } else if (m_type == long.class) {\r\n            c = ((LiteralComparator) m_cmp).compare(t1.getLong(m_col), t2.getLong(m_col));\r\n        } else if (m_type == float.class) {\r\n            c = ((LiteralComparator) m_cmp).compare(t1.getFloat(m_col), t2.getFloat(m_col));\r\n        } else if (m_type == boolean.class) {\r\n            c = ((LiteralComparator) m_cmp).compare(t1.getBoolean(m_col), t2.getBoolean(m_col));\r\n        } else if (!m_type.isPrimitive()) {\r\n            c = m_cmp.compare(t1.get(m_col), t2.get(m_col));\r\n        } else {\r\n            throw new IllegalStateException(\"Unsupported type: \" + m_type.getName());\r\n        }\r\n    }\r\n    return m_rev * c;\r\n}"
}, {
	"Path": "me.vickychijwani.spectre.view.fragments.WebViewFragment.newInstance",
	"Comment": "returns a new webviewfragment which will load the desired url.",
	"Method": "WebViewFragment newInstance(String url){\r\n    WebViewFragment fragment = new WebViewFragment();\r\n    Bundle args = new Bundle();\r\n    args.putString(BundleKeys.URL, url);\r\n    args.putInt(KEY_LAYOUT_ID, R.layout.fragment_web_view_nested_scroll);\r\n    fragment.setArguments(args);\r\n    return fragment;\r\n}"
}, {
	"Path": "prefuse.util.ColorLib.hsba",
	"Comment": "get the color code for the given hue, saturation, and brightnessvalues, translating from hsb color space to rgb color space.",
	"Method": "int hsba(float h,float s,float b,float a){\r\n    return setAlpha(Color.HSBtoRGB(h, s, b), (int) (a * 255 + 0.5) & 0xFF);\r\n}"
}, {
	"Path": "prefuse.data.util.BreadthFirstIterator.getDepth",
	"Comment": "get the traversal depth at which a particular tuple was encountered.",
	"Method": "int getDepth(Tuple t){\r\n    return m_queue.getDepth(t);\r\n}"
}, {
	"Path": "prefuse.data.Graph.getAdjacentNode",
	"Comment": "given an edge and an incident node, return the other nodeconnected to the edge.",
	"Method": "int getAdjacentNode(int edge,int node,Node getAdjacentNode,Edge e,Node n){\r\n    edgeCheck(e, true);\r\n    nodeCheck(n, true);\r\n    return getNode(getAdjacentNode(e.getRow(), n.getRow()));\r\n}"
}, {
	"Path": "prefuse.Visualization.addTable",
	"Comment": "adds a data table to this visualization, using the given data groupname. a visual abstraction of the data will be created and registeredwith the visualization. an exception will be thrown if the group nameis already in use.",
	"Method": "VisualTable addTable(String group,VisualTable addTable,String group,Schema schema,VisualTable addTable,String group,Table table,VisualTable addTable,String group,Table table,Predicate filter,VisualTable addTable,String group,Table table,Schema schema,VisualTable addTable,String group,Table table,Predicate filter,Schema schema,VisualTable addTable,VisualTable table){\r\n    addDataGroup(table.getGroup(), table, table.getParentTable());\r\n    table.setVisualization(this);\r\n    return table;\r\n}"
}, {
	"Path": "py4j.Base64.encodeToString",
	"Comment": "encodes a raw byte array into a base64 string representation\ti accordance with rfc 2045.",
	"Method": "String encodeToString(byte[] sArr,boolean lineSep){\r\n    return new String(encodeToChar(sArr, lineSep));\r\n}"
}, {
	"Path": "picard.analysis.RrbsMetricsCollector.getCurRefIndex",
	"Comment": "accounts for the fact that negative strand counts have been reversed",
	"Method": "int getCurRefIndex(int refStart,int blockLength,int idx,boolean isNegative){\r\n    return isNegative ? refStart + (blockLength - 1) - idx - 1 : refStart + idx;\r\n}"
}, {
	"Path": "prefuse.render.LabelRenderer.setHorizontalPadding",
	"Comment": "sets the amount of padding in pixels between the content and the border of this item along the horizontal dimension.",
	"Method": "void setHorizontalPadding(int xpad){\r\n    m_horizBorder = xpad;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setForcedSubtitleLanguage",
	"Comment": "sets the iso 639 language code for the subtitle language that should\tbe forced.",
	"Method": "void setForcedSubtitleLanguage(String value){\r\n    configuration.setProperty(KEY_FORCED_SUBTITLE_LANGUAGE, value);\r\n}"
}, {
	"Path": "picard.analysis.TheoreticalSensitivity.trimDistribution",
	"Comment": "removes trailing zeros in a distribution.the purpose of this function is to prevent otherfunctions from evaluating in regions where the distribution has zero probability.if the array consists of only zeros or is empty, an empty array is returned.",
	"Method": "double[] trimDistribution(double[] distribution){\r\n    int endOfDistribution = distribution.length;\r\n    if (distribution.length == 0) {\r\n        return distribution;\r\n    }\r\n    while (distribution[endOfDistribution - 1] == 0) {\r\n        endOfDistribution--;\r\n        if (endOfDistribution == 0)\r\n            break;\r\n    }\r\n    return Arrays.copyOfRange(distribution, 0, endOfDistribution);\r\n}"
}, {
	"Path": "prefuse.Display.paintBufferToScreen",
	"Comment": "paints the offscreen buffer to the provided graphics context.",
	"Method": "void paintBufferToScreen(Graphics g){\r\n    synchronized (this) {\r\n        g.drawImage(m_offscreen, 0, 0, null);\r\n    }\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.getLastRefreshTime",
	"Comment": "returns the timestamp when this resource was last refreshed.",
	"Method": "long getLastRefreshTime(){\r\n    return lastRefreshTime;\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.lists.CwStackPanel.getHeaderString",
	"Comment": "get a string representation of the header that includes an image and sometext.",
	"Method": "String getHeaderString(String text,ImageResource image){\r\n    HorizontalPanel hPanel = new HorizontalPanel();\r\n    hPanel.setSpacing(0);\r\n    hPanel.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);\r\n    hPanel.add(new Image(image));\r\n    HTML headerText = new HTML(text);\r\n    headerText.setStyleName(\"cw-StackPanelHeader\");\r\n    hPanel.add(headerText);\r\n    return hPanel.getElement().getString();\r\n}"
}, {
	"Path": "prefuse.activity.ActivityMap.get",
	"Comment": "returns the activity associated with the given key. if the key is notfound in this map, the parent map is consulted. if no result is found,null is returned.",
	"Method": "Activity get(String key){\r\n    Activity a = (Activity) m_map.get(key);\r\n    return (a == null && m_parent != null ? m_parent.get(key) : a);\r\n}"
}, {
	"Path": "prefuse.action.layout.StackedAreaChart.setPaddingPercentage",
	"Comment": "sets the percentage of the layout bounds that should be reserved forempty space at the top of the stack.",
	"Method": "void setPaddingPercentage(double p){\r\n    if (p < 0 || p > 1)\r\n        throw new IllegalArgumentException(\"Illegal padding percentage: \" + p);\r\n    m_padding = p;\r\n}"
}, {
	"Path": "picard.illumina.parser.IlluminaTextIterator.next",
	"Comment": "read the next record from the list of input files, and load into data argument.",
	"Method": "String[] next(){\r\n    if (!hasNext()) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    return parser.next();\r\n}"
}, {
	"Path": "picard.sam.PositionBasedDownsampleSamTest.setupBuilder",
	"Comment": "create a samfile with one tile and randomly placed reads within it.",
	"Method": "void setupBuilder(){\r\n    final int numReads = 10000;\r\n    final String flowCellBarcode = \"TESTBARCODE\";\r\n    final int maxX = 10000;\r\n    final int maxY = 20000;\r\n    final int minX = 1000;\r\n    final int minY = 2000;\r\n    final String separator = \":\";\r\n    final int lane = 1;\r\n    final int tile = 2203;\r\n    final Random rg = new Random(31);\r\n    setBuilder.setReadGroup(readGroupRecord);\r\n    setBuilder.setUseNmFlag(true);\r\n    for (int i = 0; i < numReads; i++) {\r\n        final int x = rg.nextInt(maxX) + minX;\r\n        final int y = rg.nextInt(maxY) + minY;\r\n        final String readName = flowCellBarcode + separator + lane + separator + tile + separator + x + separator + y;\r\n        setBuilder.addPair(readName, 1, 1, 100);\r\n    }\r\n    tempDir = IOUtil.createTempDir(\"pds_test\", \"PositionalDownsampling\");\r\n    tempSamFile = File.createTempFile(\"PositionalDownsampleSam\", \".bam\", tempDir);\r\n    BufferedLineReader bufferedLineReader = null;\r\n    try {\r\n        bufferedLineReader = new BufferedLineReader(new FileInputStream(dict));\r\n    } catch (FileNotFoundException e) {\r\n        e.printStackTrace();\r\n    }\r\n    final SAMTextHeaderCodec codec = new SAMTextHeaderCodec();\r\n    final SAMFileHeader header = codec.decode(bufferedLineReader, dict.toString());\r\n    readGroupRecord.setSample(sample);\r\n    readGroupRecord.setPlatform(platform);\r\n    readGroupRecord.setLibrary(library);\r\n    header.setSortOrder(SAMFileHeader.SortOrder.coordinate);\r\n    header.addReadGroup(readGroupRecord);\r\n    setBuilder.setHeader(header);\r\n    final SAMFileWriter writer = new SAMFileWriterFactory().setCreateIndex(true).makeBAMWriter(header, false, tempSamFile);\r\n    for (final SAMRecord record : setBuilder) {\r\n        writer.addAlignment(record);\r\n    }\r\n    writer.close();\r\n}"
}, {
	"Path": "prefuse.data.tuple.CompositeTupleSet.setNames",
	"Comment": "get an iterator over the names of all the tuplesets in this composite.",
	"Method": "Iterator setNames(){\r\n    return m_map.keySet().iterator();\r\n}"
}, {
	"Path": "net.paoding.rose.jade.context.spring.JadeComponentProvider.setResourcePattern",
	"Comment": "set the resource pattern to use when scanning the classpath. thisvalue will be appended to each base package name.",
	"Method": "void setResourcePattern(String resourcePattern){\r\n    Assert.notNull(resourcePattern, \"'resourcePattern' must not be null\");\r\n    this.resourcePattern = resourcePattern;\r\n}"
}, {
	"Path": "picard.illumina.ClusterDataToSamConverter.withTagPerMolecularIndex",
	"Comment": "sets the sam tags to use to store the bases each molecular index.this will only be used if there are more than one molecularindex. if fewer tags are given than molecular indexes found, then the remaining molecular indexes will be concatenated and storedin the last tag.if more tags are provided than molecular indexes found, the additional tags will not be used.",
	"Method": "ClusterDataToSamConverter withTagPerMolecularIndex(List<String> tagPerMolecularIndex){\r\n    if (tagPerMolecularIndex == null) {\r\n        throw new IllegalArgumentException(\"Null given for tagPerMolecularIndex\");\r\n    }\r\n    this.tagPerMolecularIndex = tagPerMolecularIndex;\r\n    return this;\r\n}"
}, {
	"Path": "net.pms.dlna.RootFolder.parseFeedKey",
	"Comment": "splits the first part of a web.conf spec into a pair of strings\trepresenting the resource type and its dlna folder.",
	"Method": "String[] parseFeedKey(String spec){\r\n    String[] pair = StringUtils.split(spec, \".\", 2);\r\n    if (pair == null || pair.length < 2) {\r\n        pair = new String[2];\r\n    }\r\n    if (pair[0] == null) {\r\n        pair[0] = \"\";\r\n    }\r\n    return pair;\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeMap.getHaplotype",
	"Comment": "queries a haplotypeblock by snp chromosome and position. returns null if none found.",
	"Method": "HaplotypeBlock getHaplotype(Snp snp,HaplotypeBlock getHaplotype,String snpName,HaplotypeBlock getHaplotype,String chrom,int pos){\r\n    return this.haplotypesBySnpLocus.get(toKey(chrom, pos));\r\n}"
}, {
	"Path": "com.goodiebag.pinview.Pinview.onTextChanged",
	"Comment": "fired when text changes in the edittexts.backspace is also identified here.",
	"Method": "void onTextChanged(CharSequence charSequence,int start,int i1,int count){\r\n    if (charSequence.length() == 1 && currentFocus != null) {\r\n        final int currentTag = getIndexOfCurrentFocus();\r\n        if (currentTag < mPinLength - 1) {\r\n            long delay = 1;\r\n            if (mPassword)\r\n                delay = 25;\r\n            this.postDelayed(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    EditText nextEditText = editTextList.get(currentTag + 1);\r\n                    nextEditText.setEnabled(true);\r\n                    nextEditText.requestFocus();\r\n                }\r\n            }, delay);\r\n        } else {\r\n        }\r\n        if (currentTag == mPinLength - 1 && inputType == InputType.NUMBER || currentTag == mPinLength - 1 && mPassword) {\r\n            finalNumberPin = true;\r\n        }\r\n    } else if (charSequence.length() == 0) {\r\n        int currentTag = getIndexOfCurrentFocus();\r\n        mDelPressed = true;\r\n        if (editTextList.get(currentTag).getText().length() > 0)\r\n            editTextList.get(currentTag).setText(\"\");\r\n    }\r\n    for (int index = 0; index < mPinLength; index++) {\r\n        if (editTextList.get(index).getText().length() < 1)\r\n            break;\r\n        if (!fromSetValue && index + 1 == mPinLength && mListener != null)\r\n            mListener.onDataEntered(this, true);\r\n    }\r\n    updateEnabledState();\r\n}"
}, {
	"Path": "com.goodiebag.pinview.Pinview.onTextChanged",
	"Comment": "fired when text changes in the edittexts.backspace is also identified here.",
	"Method": "void onTextChanged(CharSequence charSequence,int start,int i1,int count){\r\n    EditText nextEditText = editTextList.get(currentTag + 1);\r\n    nextEditText.setEnabled(true);\r\n    nextEditText.requestFocus();\r\n}"
}, {
	"Path": "com.restfb.json.WritingBuffer.flush",
	"Comment": "flushes the internal buffer but does not flush the wrapped writer.",
	"Method": "void flush(){\r\n    writer.write(buffer, 0, fill);\r\n    fill = 0;\r\n}"
}, {
	"Path": "prefuse.action.assignment.DataSizeAction.setDefaultSize",
	"Comment": "this operation is not supported by the datasizeaction type.calling this method will result in a thrown exception.",
	"Method": "void setDefaultSize(double defaultSize){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "prefuse.util.collections.IntObjectHashMap.removeKey",
	"Comment": "removes the given key with its associated element from the receiver, ifpresent.",
	"Method": "boolean removeKey(int key){\r\n    int i = indexOfKey(key);\r\n    if (i < 0)\r\n        return false;\r\n    this.state[i] = REMOVED;\r\n    this.values[i] = null;\r\n    this.distinct--;\r\n    if (this.distinct < this.lowWaterMark) {\r\n        int newCapacity = chooseShrinkCapacity(this.distinct, this.minLoadFactor, this.maxLoadFactor);\r\n        rehash(newCapacity);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getMencoderCustomOptions",
	"Comment": "returns custom commandline options to pass on to mencoder.",
	"Method": "String getMencoderCustomOptions(){\r\n    return getString(KEY_MENCODER_CUSTOM_OPTIONS, \"\");\r\n}"
}, {
	"Path": "prefuse.data.Tree.getSpanningTree",
	"Comment": "returns a spanning tree over this tree. if no spanning treehas been constructed at an alternative root, this method simply returnsa pointer to this tree instance. if a spanning tree rooted at analternative node has been created, that tree is returned.",
	"Method": "Tree getSpanningTree(Tree getSpanningTree,Node root){\r\n    nodeCheck(root, true);\r\n    if (m_spanning == null) {\r\n        if (m_root == root.getRow()) {\r\n            return this;\r\n        } else {\r\n            m_spanning = new SpanningTree(this, root);\r\n        }\r\n    } else if (m_spanning.getRoot() != root) {\r\n        m_spanning.buildSpanningTree(root);\r\n    }\r\n    return m_spanning;\r\n}"
}, {
	"Path": "com.google.gwt.sample.dynatablerf.client.widgets.NameLabel.cancelSubscription",
	"Comment": "unhook event notifications when being permanently disposed of byfavoriteswidget.",
	"Method": "void cancelSubscription(){\r\n    if (subscription != null) {\r\n        subscription.removeHandler();\r\n    }\r\n}"
}, {
	"Path": "net.pms.util.Iso639.isCodeMatching",
	"Comment": "verifies that a full language name is matching an iso code. returns true\tif a match can be made, false otherwise.",
	"Method": "boolean isCodeMatching(String language,String code){\r\n    if (language == null || code == null) {\r\n        return false;\r\n    }\r\n    String isoCode = normalize(code);\r\n    String[] codes = links.get(language);\r\n    for (String c : codes) {\r\n        if (c.equalsIgnoreCase(isoCode)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "paperparcel.Utils.getAnnotationWithSimpleName",
	"Comment": "finds an annotation with the given name on the given element, or null if not found.",
	"Method": "AnnotationMirror getAnnotationWithSimpleName(Element element,String name){\r\n    for (AnnotationMirror mirror : element.getAnnotationMirrors()) {\r\n        String annotationName = mirror.getAnnotationType().asElement().getSimpleName().toString();\r\n        if (name.equals(annotationName)) {\r\n            return mirror;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "picard.util.CircularByteBuffer.close",
	"Comment": "signals that the buffer is closed and no further writes will occur.",
	"Method": "void close(){\r\n    this.closed = true;\r\n    notify();\r\n}"
}, {
	"Path": "prefuse.data.io.DelimitedTextTableWriter.setPrintHeader",
	"Comment": "sets if this writer will write a header row with the column names.",
	"Method": "void setPrintHeader(boolean printHeader){\r\n    m_printHeader = printHeader;\r\n}"
}, {
	"Path": "net.pms.configuration.Build.getUpdateServerURL",
	"Comment": "returns the url where the newest version of the software can be downloaded.",
	"Method": "String getUpdateServerURL(){\r\n    return StringUtils.isNotBlank(UPDATE_SERVER_URL) ? UPDATE_SERVER_URL : null;\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.ForceDirectedLayout.getSpringLength",
	"Comment": "get the spring length for the given edge. subclasses shouldoverride this method to perform custom spring length assignment.",
	"Method": "float getSpringLength(EdgeItem e){\r\n    return -1.f;\r\n}"
}, {
	"Path": "prefuse.data.Table.canSet",
	"Comment": "check if the set method for the given data field canaccept values of a given target type.",
	"Method": "boolean canSet(String field,Class type){\r\n    Column c = getColumn(field);\r\n    return (c == null ? false : c.canSet(type));\r\n}"
}, {
	"Path": "io.github.benas.randombeans.util.ClassGraphFacade.getPublicConcreteSubTypesOf",
	"Comment": "searches the classpath for all public concrete subtypes of the given interface or abstract class.",
	"Method": "List<Class<?>> getPublicConcreteSubTypesOf(Class<T> type){\r\n    return typeToConcreteSubTypes.computeIfAbsent(type, ClassGraphFacade::searchForPublicConcreteSubTypesOf);\r\n}"
}, {
	"Path": "io.github.benas.randombeans.util.ReflectionUtils.getPublicConcreteSubTypesOf",
	"Comment": "searches the classpath for all public concrete subtypes of the given interface or abstract class.",
	"Method": "List<Class<?>> getPublicConcreteSubTypesOf(Class<T> type){\r\n    return ClassGraphFacade.getPublicConcreteSubTypesOf(type);\r\n}"
}, {
	"Path": "me.vickychijwani.spectre.util.EditTextSelectionState.focusAndRestoreSelectionState",
	"Comment": "focus the associated edittext and restore its selection state.",
	"Method": "void focusAndRestoreSelectionState(){\r\n    EditText focusedEditView = this.getEditText();\r\n    int start = this.getSelectionStart();\r\n    int end = this.getSelectionEnd();\r\n    final int len = focusedEditView.getText().length();\r\n    focusedEditView.requestFocus();\r\n    if (start <= end && start >= 0 && start <= len && end >= 0 && end <= len) {\r\n        focusedEditView.setSelection(start, end);\r\n    } else if (end >= 0 && end <= len) {\r\n        focusedEditView.setSelection(end);\r\n    }\r\n}"
}, {
	"Path": "net.pms.util.Version.equals",
	"Comment": "returns true if this version equals the supplied object,\tfalse otherwise",
	"Method": "boolean equals(Object other){\r\n    if (other instanceof Version) {\r\n        return compareTo((Version) other) == 0;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getMinMemoryBufferSize",
	"Comment": "returns the preferred minimum size for the transcoding memory buffer in megabytes.\tdefault value is 12.",
	"Method": "int getMinMemoryBufferSize(){\r\n    return getInt(KEY_MIN_MEMORY_BUFFER_SIZE, 12);\r\n}"
}, {
	"Path": "prefuse.action.assignment.StrokeAction.setDefaultStroke",
	"Comment": "set the default basicstroke to be assigned to items. items will beassigned the default stroke if they do not match any registered rules.",
	"Method": "void setDefaultStroke(BasicStroke f){\r\n    defaultStroke = f;\r\n}"
}, {
	"Path": "picard.vcf.VcfTestUtils.createTemporaryIndexedVcfFromInput",
	"Comment": "given a vcf file, create a temporary vcf file with an index file. both the temporary file and its index aredeleted when the jvm exits.",
	"Method": "File createTemporaryIndexedVcfFromInput(File vcfFile,String tempFilePrefix,File createTemporaryIndexedVcfFromInput,File vcfFile,String tempFilePrefix,String suffix){\r\n    final String extension;\r\n    if (suffix != null) {\r\n        extension = suffix;\r\n    } else if (vcfFile.getAbsolutePath().endsWith(\".vcf\")) {\r\n        extension = \".vcf\";\r\n    } else if (vcfFile.getAbsolutePath().endsWith(\".vcf.gz\")) {\r\n        extension = \".vcf.gz\";\r\n    } else {\r\n        extension = \"\";\r\n    }\r\n    if (!extension.equals(\".vcf\") && !extension.equals(\".vcf.gz\")) {\r\n        throw new IllegalArgumentException(\"couldn't find a .vcf or .vcf.gz ending for input file \" + vcfFile.getAbsolutePath());\r\n    }\r\n    File output = createTemporaryIndexedFile(tempFilePrefix, extension);\r\n    try (final VCFFileReader in = new VCFFileReader(vcfFile, false)) {\r\n        final VCFHeader header = in.getFileHeader();\r\n        try (final VariantContextWriter out = new VariantContextWriterBuilder().setReferenceDictionary(header.getSequenceDictionary()).setOptions(EnumSet.of(Options.INDEX_ON_THE_FLY)).setOutputFile(output).build()) {\r\n            out.writeHeader(header);\r\n            for (final VariantContext ctx : in) {\r\n                out.add(ctx);\r\n            }\r\n        }\r\n    }\r\n    return output;\r\n}"
}, {
	"Path": "prefuse.action.layout.GridLayout.analyzeGraphGrid",
	"Comment": "analyzes a set of nodes to try and determine grid dimensions. currentlylooks for the edge count on a node to drop to 2 to determine the end ofa row.",
	"Method": "int[] analyzeGraphGrid(TupleSet ts){\r\n    int m, n;\r\n    Iterator iter = ts.tuples();\r\n    iter.next();\r\n    for (n = 2; iter.hasNext(); n++) {\r\n        Node nd = (Node) iter.next();\r\n        if (nd.getDegree() == 2)\r\n            break;\r\n    }\r\n    m = ts.getTupleCount() / n;\r\n    return new int[] { m, n };\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.isMencoderSubFribidi",
	"Comment": "returns whether or not mencoder should use fribidi mode, which\tis needed to display subtitles in languages that read from right to\tleft, like arabic, farsi, hebrew, urdu, etc. default value is false.",
	"Method": "boolean isMencoderSubFribidi(){\r\n    return getBoolean(KEY_MENCODER_SUB_FRIBIDI, false);\r\n}"
}, {
	"Path": "com.restfb.DebugHeaderInfo.getUsedVersion",
	"Comment": "get the version, facebook used internally to fulfill the request",
	"Method": "Version getUsedVersion(){\r\n    return usedVersion;\r\n}"
}, {
	"Path": "me.vickychijwani.spectre.util.AppUtils.setLocale",
	"Comment": "set the app to use the given locale. useful for testing translations. this is normallynot needed because the device locale is applied automatically.",
	"Method": "void setLocale(Context context,Locale locale){\r\n    Locale.setDefault(locale);\r\n    Resources res = context.getResources();\r\n    DisplayMetrics dm = res.getDisplayMetrics();\r\n    android.content.res.Configuration conf = res.getConfiguration();\r\n    conf.locale = Locale.getDefault();\r\n    res.updateConfiguration(conf, dm);\r\n}"
}, {
	"Path": "com.restfb.json.JsonArray.readFrom",
	"Comment": "reads a json array from the given reader.characters are read in chunks and buffered internally, therefore wrapping an existing reader in an additionalbufferedreader does not improve reading performance.",
	"Method": "JsonArray readFrom(Reader reader,JsonArray readFrom,String string){\r\n    return JsonValue.readFrom(string).asArray();\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeProbabilitiesUsingLogLikelihoods.merge",
	"Comment": "merges information from another haplotype probabilities object for the same haplotype intothis object. useful for when probabilities need to be merged to levels higher than theread group, e.g. the sample or individual.",
	"Method": "void merge(HaplotypeProbabilities other){\r\n    if (!this.getHaplotype().equals(other.getHaplotype())) {\r\n        throw new IllegalArgumentException(\"Mismatched haplotypes in call to HaplotypeProbabilities.merge(): \" + getHaplotype() + \", \" + other.getHaplotype());\r\n    }\r\n    if (!(other instanceof HaplotypeProbabilitiesUsingLogLikelihoods)) {\r\n        throw new IllegalArgumentException(\"Can only merge HaplotypeProbabilities of same class.\");\r\n    }\r\n    final HaplotypeProbabilitiesUsingLogLikelihoods o = (HaplotypeProbabilitiesUsingLogLikelihoods) other;\r\n    setLogLikelihoods(MathUtil.sum(getLogLikelihoods(), o.getLogLikelihoods()));\r\n}"
}, {
	"Path": "net.pms.configuration.RendererConfiguration.getTranscodedSize",
	"Comment": "returns the size to report back to the renderer when transcoding media\tas defined in the renderer configuration. default value is 0.",
	"Method": "long getTranscodedSize(){\r\n    return getLong(TRANSCODED_SIZE, 0);\r\n}"
}, {
	"Path": "picard.util.BaitDesigner.writeParametersFile",
	"Comment": "method that writes out all the parameter values that were used in the design using reflection.",
	"Method": "void writeParametersFile(File file){\r\n    try {\r\n        final BufferedWriter out = IOUtil.openFileForBufferedWriting(file);\r\n        for (final Field field : getClass().getDeclaredFields()) {\r\n            if (Modifier.isPrivate(field.getModifiers()))\r\n                continue;\r\n            final String name = field.getName();\r\n            if (name.toUpperCase().equals(name) && !name.equals(\"USAGE\")) {\r\n                final Object value = field.get(this);\r\n                if (value != null) {\r\n                    out.append(name);\r\n                    out.append(\"=\");\r\n                    out.append(value.toString());\r\n                    out.newLine();\r\n                }\r\n            }\r\n        }\r\n        out.close();\r\n    } catch (Exception e) {\r\n        throw new PicardException(\"Error writing out parameters file.\", e);\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.ColorLib.rgba",
	"Comment": "get the color code for the given red, green, blue, and alpha values.",
	"Method": "int rgba(int r,int g,int b,int a,int rgba,float r,float g,float b,float a){\r\n    return ((((int) (a * 255 + 0.5)) & 0xFF) << 24) | ((((int) (r * 255 + 0.5)) & 0xFF) << 16) | ((((int) (g * 255 + 0.5)) & 0xFF) << 8) | (((int) (b * 255 + 0.5)) & 0xFF);\r\n}"
}, {
	"Path": "prefuse.util.ui.PrefuseTableModel.getRow",
	"Comment": "get the prefuse table row for a row index into this table model.",
	"Method": "int getRow(int rowIndex){\r\n    if (m_rowmap == null)\r\n        initRowMap();\r\n    return m_rowmap[rowIndex];\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAMediaInfo.isAspectRatioMismatch",
	"Comment": "check if media has different aspect ratios for container and video track.",
	"Method": "boolean isAspectRatioMismatch(){\r\n    return isNotBlank(getAspectRatioContainer()) && !equalsIgnoreCase(getAspectRatioContainer(), getAspectRatioVideoTrack());\r\n}"
}, {
	"Path": "prefuse.data.CascadedTable.filterColumns",
	"Comment": "determines which columns are inherited from the backing parent table.",
	"Method": "void filterColumns(){\r\n    if (m_parent == null)\r\n        return;\r\n    for (int i = 0; i < m_pnames.size(); ++i) {\r\n        String name = (String) m_pnames.get(i);\r\n        Column col = m_parent.getColumn(name);\r\n        boolean contained = m_names.contains(name);\r\n        boolean removedFromParent = (col == null);\r\n        if (removedFromParent || !m_colFilter.include(col, name) || contained) {\r\n            m_pnames.remove(i--);\r\n            if (!contained) {\r\n                ((ColumnEntry) m_entries.get(name)).dispose();\r\n                m_entries.remove(name);\r\n            }\r\n            fireTableEvent(m_rows.getMinimumRow(), m_rows.getMaximumRow(), i, EventConstants.DELETE);\r\n        }\r\n    }\r\n    m_pnames.clear();\r\n    Iterator pcols = m_parent.getColumnNames();\r\n    for (int i = 0, j = m_columns.size(); pcols.hasNext(); ++i) {\r\n        String name = (String) pcols.next();\r\n        Column col = m_parent.getColumn(i);\r\n        if (m_colFilter.include(col, name) && !m_names.contains(name)) {\r\n            m_pnames.add(name);\r\n            ColumnEntry entry = (ColumnEntry) m_entries.get(name);\r\n            if (entry == null) {\r\n                entry = new ColumnEntry(j++, col, new ColumnMetadata(this, name));\r\n                m_entries.put(name, entry);\r\n                fireTableEvent(m_rows.getMinimumRow(), m_rows.getMaximumRow(), i, EventConstants.INSERT);\r\n            } else {\r\n                entry.colnum = j++;\r\n            }\r\n            m_lastCol = m_columns.size() - 1;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "py4j.ClientServer.shutdown",
	"Comment": "shuts down the java server so that it stops accepting requests and it\tcloses existing connections.",
	"Method": "void shutdown(){\r\n    this.javaServer.shutdown(true);\r\n}"
}, {
	"Path": "picard.sam.markduplicates.ElcHashBasedDuplicatesFinder.populateDupCandidates",
	"Comment": "populate pairedreadsequence.dupcandidates with duplicate candidatesbased on the same hash on the same position.",
	"Method": "void populateDupCandidates(List<PairedReadSequence> seqs){\r\n    readsByHashInGroup.clear();\r\n    for (PairedReadSequence prs : seqs) {\r\n        int[][] readHashValues = { prs.hashes1, prs.hashes2 };\r\n        for (int[] readHashValue : readHashValues) {\r\n            for (int key : readHashValue) {\r\n                final List<PairedReadSequence> dupCandidates = readsByHashInGroup.computeIfAbsent(key, k -> new ArrayList());\r\n                dupCandidates.add(prs);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.Table.getModificationCount",
	"Comment": "get the number of times this table has been modified. adding rows,deleting rows, and updating table cell values all contribute tothis count.",
	"Method": "int getModificationCount(){\r\n    return m_modCount;\r\n}"
}, {
	"Path": "prefuse.activity.ActivityMap.size",
	"Comment": "returns the number of mappings in this activitymap. does not includemappings stored in the parent map.",
	"Method": "int size(){\r\n    return m_map.size();\r\n}"
}, {
	"Path": "prefuse.util.ui.UILib.getBox",
	"Comment": "convenience method for creating a box user interface widget container.",
	"Method": "Box getBox(Component[] c,boolean horiz,int margin,int spacing,Box getBox,Component[] c,boolean horiz,int margin1,int margin2,int spacing){\r\n    Box b = new Box(horiz ? BoxLayout.X_AXIS : BoxLayout.Y_AXIS);\r\n    addStrut(b, horiz, margin1);\r\n    for (int i = 0; i < c.length; ++i) {\r\n        if (i > 0) {\r\n            addStrut(b, horiz, spacing);\r\n            addGlue(b, horiz);\r\n        }\r\n        b.add(c[i]);\r\n    }\r\n    addStrut(b, horiz, margin2);\r\n    return b;\r\n}"
}, {
	"Path": "picard.sam.markduplicates.MarkDuplicatesWithMateCigar.setPGIdsSeen",
	"Comment": "generate the list of program records seen in the sam file, approximating this with those in the header that were notthemselves mentioned elsewhere.",
	"Method": "void setPGIdsSeen(SAMFileHeader header){\r\n    final Set<String> pgIdsSeenAsPrevious = new HashSet<String>();\r\n    for (final SAMProgramRecord samProgramRecord : header.getProgramRecords()) {\r\n        final String previousProgramGroupID = samProgramRecord.getPreviousProgramGroupId();\r\n        if (null != previousProgramGroupID)\r\n            pgIdsSeenAsPrevious.add(previousProgramGroupID);\r\n    }\r\n    for (final SAMProgramRecord samProgramRecord : header.getProgramRecords()) {\r\n        final String pgId = samProgramRecord.getId();\r\n        if (!pgIdsSeenAsPrevious.contains(pgId))\r\n            this.pgIdsSeen.add(pgId);\r\n    }\r\n}"
}, {
	"Path": "py4j.NetworkUtil.quietlySetLinger",
	"Comment": "will send a rst packet on close, which should make both remote\twrite and read operations fail.",
	"Method": "void quietlySetLinger(Socket socket){\r\n    try {\r\n        socket.setSoLinger(true, 0);\r\n    } catch (Exception e) {\r\n        logger.log(Level.FINE, \"Cannot set linger on socket.\", e);\r\n    }\r\n}"
}, {
	"Path": "picard.sam.FastqToSam.doPaired",
	"Comment": "more complicated method that takes two fastq files and builds pairing information in the sam.",
	"Method": "int doPaired(FastqReader freader1,FastqReader freader2,SAMFileWriter writer){\r\n    int readCount = 0;\r\n    final ProgressLogger progress = new ProgressLogger(LOG);\r\n    for (; freader1.hasNext() && freader2.hasNext(); readCount++) {\r\n        final FastqRecord frec1 = freader1.next();\r\n        final FastqRecord frec2 = freader2.next();\r\n        final String frec1Name = SequenceUtil.getSamReadNameFromFastqHeader(frec1.getReadHeader());\r\n        final String frec2Name = SequenceUtil.getSamReadNameFromFastqHeader(frec2.getReadHeader());\r\n        final String baseName = getBaseName(frec1Name, frec2Name, freader1, freader2);\r\n        final SAMRecord srec1 = createSamRecord(writer.getFileHeader(), baseName, frec1, true);\r\n        srec1.setFirstOfPairFlag(true);\r\n        srec1.setSecondOfPairFlag(false);\r\n        writer.addAlignment(srec1);\r\n        progress.record(srec1);\r\n        final SAMRecord srec2 = createSamRecord(writer.getFileHeader(), baseName, frec2, true);\r\n        srec2.setFirstOfPairFlag(false);\r\n        srec2.setSecondOfPairFlag(true);\r\n        writer.addAlignment(srec2);\r\n        progress.record(srec2);\r\n    }\r\n    if (freader1.hasNext() || freader2.hasNext()) {\r\n        throw new PicardException(\"Input paired fastq files must be the same length\");\r\n    }\r\n    return readCount;\r\n}"
}, {
	"Path": "prefuse.data.io.sql.CompositeSQLDataHandler.removeHandler",
	"Comment": "remove a custom data handler for a given column name. subsequentto this method, the column will use the default handler.",
	"Method": "boolean removeHandler(String columnName){\r\n    if (m_overrides == null)\r\n        return false;\r\n    else\r\n        return m_overrides.remove(columnName) != null;\r\n}"
}, {
	"Path": "prefuse.util.ColorMap.setMinValue",
	"Comment": "sets the minimum value that corresponds to the firstcolor in the color map.",
	"Method": "void setMinValue(double minValue){\r\n    this.minValue = minValue;\r\n}"
}, {
	"Path": "net.pms.newgui.RestrictedFileSystemView.getSystemIcon",
	"Comment": "icon for a file, directory, or folder as it would be displayed in a system file browser.",
	"Method": "Icon getSystemIcon(File f){\r\n    if (f != null) {\r\n        return UIManager.getIcon(f.isDirectory() ? \"FileView.directoryIcon\" : \"FileView.fileIcon\");\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "picard.sam.BestMapqPrimaryAlignmentSelectionStrategy.pickPrimaryAlignment",
	"Comment": "primary alignment was filtered out.need to select a new one.",
	"Method": "void pickPrimaryAlignment(HitsForInsert hits){\r\n    if (hits.numHits() == 0)\r\n        throw new IllegalArgumentException(\"No alignments to pick from\");\r\n    hits.coordinateByHitIndex();\r\n    final NumPrimaryAlignmentState firstEndAlignmentState = hits.tallyPrimaryAlignments(true);\r\n    final NumPrimaryAlignmentState secondEndAlignmentState = hits.tallyPrimaryAlignments(false);\r\n    if ((firstEndAlignmentState == NumPrimaryAlignmentState.NONE && secondEndAlignmentState == NumPrimaryAlignmentState.NONE) || firstEndAlignmentState == NumPrimaryAlignmentState.MORE_THAN_ONE || secondEndAlignmentState == NumPrimaryAlignmentState.MORE_THAN_ONE) {\r\n        final List<Integer> primaryAlignmentIndices = new ArrayList<Integer>(hits.numHits());\r\n        int bestMapQ = -1;\r\n        for (int i = 0; i < hits.numHits(); ++i) {\r\n            final int firstEndMapq;\r\n            if (hits.getFirstOfPair(i) != null) {\r\n                firstEndMapq = hits.getFirstOfPair(i).getMappingQuality();\r\n            } else {\r\n                firstEndMapq = 0;\r\n            }\r\n            final int secondEndMapq;\r\n            if (hits.getSecondOfPair(i) != null) {\r\n                secondEndMapq = hits.getSecondOfPair(i).getMappingQuality();\r\n            } else {\r\n                secondEndMapq = 0;\r\n            }\r\n            int thisMapQ = SAMUtils.combineMapqs(firstEndMapq, secondEndMapq);\r\n            if (thisMapQ > bestMapQ) {\r\n                bestMapQ = thisMapQ;\r\n                primaryAlignmentIndices.clear();\r\n            }\r\n            if (thisMapQ == bestMapQ)\r\n                primaryAlignmentIndices.add(i);\r\n        }\r\n        final int primaryAlignmentIndex;\r\n        if (primaryAlignmentIndices.size() == 1)\r\n            primaryAlignmentIndex = primaryAlignmentIndices.get(0);\r\n        else if (primaryAlignmentIndices.size() > 1)\r\n            primaryAlignmentIndex = primaryAlignmentIndices.get(random.nextInt(primaryAlignmentIndices.size()));\r\n        else\r\n            throw new IllegalStateException(\"Never found a best MAPQ -- should never happen\");\r\n        hits.setPrimaryAlignment(primaryAlignmentIndex);\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.tuple.CompositeTupleSet.removeSet",
	"Comment": "remove the tupleset with the given name from this composite.",
	"Method": "TupleSet removeSet(String name){\r\n    TupleSet ts = (TupleSet) m_map.remove(name);\r\n    if (ts != null) {\r\n        m_sets.remove(ts);\r\n        if (m_lstnr != null)\r\n            ts.removeTupleSetListener(m_lstnr);\r\n    }\r\n    return ts;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getMencoderNoAssScale",
	"Comment": "returns the subfont text scale parameter used for subtitling without ass.\tdefault value is 3.",
	"Method": "String getMencoderNoAssScale(){\r\n    return getString(KEY_MENCODER_NOASS_SCALE, \"3\");\r\n}"
}, {
	"Path": "quickfix.ApplicationExtendedFunctionalAdapter.addOnBeforeSessionResetListener",
	"Comment": "add a consumer of sessionid to listen to onbeforesessionreset operation.",
	"Method": "void addOnBeforeSessionResetListener(Consumer<SessionID> onBeforeSessionReset){\r\n    onBeforeSessionResetListeners.add(onBeforeSessionReset);\r\n}"
}, {
	"Path": "com.restfb.types.Payment.getActions",
	"Comment": "the list of different action types that have occurred in this payment.",
	"Method": "List<Action> getActions(){\r\n    return Collections.unmodifiableList(actions);\r\n}"
}, {
	"Path": "prefuse.util.ArrayLib.binarySearch",
	"Comment": "perform a binary search over a sorted range of an array for the givenkey.",
	"Method": "int binarySearch(int[] a,int key,int binarySearch,int[] a,int key,int length,int binarySearch,int[] a,int key,int begin,int end,int binarySearch,Object[] a,Object key,int binarySearch,Object[] a,Object key,int length,int binarySearch,Object[] a,Object key,int begin,int end,int binarySearch,Object[] a,Object key,Comparator cp,int binarySearch,Object[] a,Object key,Comparator cp,int length,int binarySearch,Object[] a,Object key,Comparator cp,int begin,int end){\r\n    int x1 = begin;\r\n    int x2 = end;\r\n    int i = x1 + (x2 - x1) / 2, c;\r\n    while (x1 < x2) {\r\n        c = cp.compare(a[i], key);\r\n        if (c == 0) {\r\n            return i;\r\n        } else if (c < 0) {\r\n            x1 = i + 1;\r\n        } else {\r\n            x2 = i;\r\n        }\r\n        i = x1 + (x2 - x1) / 2;\r\n    }\r\n    return -1 * (i + 1);\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.MainMenuTreeViewModel.getContentWidgetForToken",
	"Comment": "get the content widget associated with the specified history token.",
	"Method": "ContentWidget getContentWidgetForToken(String token){\r\n    return contentToken.get(token);\r\n}"
}, {
	"Path": "prefuse.action.assignment.FontAction.getFont",
	"Comment": "returns the font to use for a given visualitem. subclasses shouldoverride this method to perform customized font assignment.",
	"Method": "Font getFont(VisualItem item){\r\n    Object o = lookup(item);\r\n    if (o != null) {\r\n        if (o instanceof FontAction) {\r\n            return ((FontAction) o).getFont(item);\r\n        } else if (o instanceof Font) {\r\n            return (Font) o;\r\n        } else {\r\n            Logger.getLogger(this.getClass().getName()).warning(\"Unrecognized Object from predicate chain.\");\r\n        }\r\n    }\r\n    return defaultFont;\r\n}"
}, {
	"Path": "picard.cmdline.PicardCommandLine.extractCommandLineProgram",
	"Comment": "returns the command line program specified, or prints the usage and exits with exit code 1",
	"Method": "CommandLineProgram extractCommandLineProgram(String[] args,List<String> packageList,String commandLineName){\r\n    final Map<String, Class<?>> simpleNameToClass = new HashMap();\r\n    final List<String> missingAnnotationClasses = new ArrayList();\r\n    processAllCommandLinePrograms(packageList, (Class<CommandLineProgram> clazz, CommandLineProgramProperties clProperties) -> {\r\n        if (null == clProperties) {\r\n            missingAnnotationClasses.add(clazz.getSimpleName());\r\n        } else if (!clProperties.omitFromCommandLine()) {\r\n            if (simpleNameToClass.containsKey(clazz.getSimpleName())) {\r\n                throw new RuntimeException(\"Simple class name collision: \" + clazz.getSimpleName());\r\n            }\r\n            simpleNameToClass.put(clazz.getSimpleName(), clazz);\r\n        }\r\n    });\r\n    if (!missingAnnotationClasses.isEmpty()) {\r\n        throw new RuntimeException(\"The following classes are missing the required CommandLineProgramProperties annotation: \" + missingAnnotationClasses.stream().collect(Collectors.joining((\", \"))));\r\n    }\r\n    final Set<Class<?>> classes = new HashSet();\r\n    classes.addAll(simpleNameToClass.values());\r\n    if (args.length < 1) {\r\n        printUsage(classes, commandLineName);\r\n    } else {\r\n        if (args[0].equals(\"-h\")) {\r\n            printUsage(classes, commandLineName);\r\n        } else if (args[0].equals(\"--list-commands\")) {\r\n            printCommandList(classes);\r\n        } else {\r\n            if (simpleNameToClass.containsKey(args[0])) {\r\n                final Class clazz = simpleNameToClass.get(args[0]);\r\n                try {\r\n                    return (CommandLineProgram) clazz.newInstance();\r\n                } catch (final InstantiationException e) {\r\n                    throw new RuntimeException(e);\r\n                } catch (final IllegalAccessException e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n            printUsage(classes, commandLineName);\r\n            printUnknown(classes, args[0]);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "prefuse.util.io.PasswordAuthenticator.setAuthentication",
	"Comment": "creates a new passwordauthenticator for the given name and password andsets it as the default authenticator for use within java networking.",
	"Method": "void setAuthentication(String username,String password){\r\n    Authenticator.setDefault(new PasswordAuthenticator(username, password));\r\n}"
}, {
	"Path": "prefuse.data.io.FixedWidthTextTableWriter.pack",
	"Comment": "pads or truncates a string as necessary to fit within the column length.",
	"Method": "String pack(String value,int len,boolean prepend,char pad){\r\n    int vlen = value.length();\r\n    if (vlen < len) {\r\n        StringBuffer sbuf = new StringBuffer();\r\n        if (prepend)\r\n            sbuf.append(value);\r\n        for (int i = len; i < vlen; ++i) sbuf.append(pad);\r\n        if (!prepend)\r\n            sbuf.append(value);\r\n        return sbuf.toString();\r\n    } else {\r\n        return value.substring(0, len);\r\n    }\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeProbabilitiesUsingLogLikelihoods.getLodMostProbableGenotype",
	"Comment": "overridden to calculate the lod from the loglikelihoods instead of the probabilitiesbecause it will allow for more accurate calculation before overflowing.",
	"Method": "double getLodMostProbableGenotype(){\r\n    final double[] logs = getShiftedLogPosterior();\r\n    double biggest = -Double.MAX_VALUE;\r\n    double secondBiggest = biggest;\r\n    for (double prob : logs) {\r\n        if (prob > biggest) {\r\n            secondBiggest = biggest;\r\n            biggest = prob;\r\n            continue;\r\n        }\r\n        if (prob > secondBiggest) {\r\n            secondBiggest = prob;\r\n        }\r\n    }\r\n    return biggest - secondBiggest;\r\n}"
}, {
	"Path": "java.nio.Buffer.position",
	"Comment": "sets the position of this buffer.\tif the mark is set and it is greater than the new position, then it is cleared.",
	"Method": "int position(Buffer position,int newPosition){\r\n    if (newPosition < 0 || newPosition > limit) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    position = newPosition;\r\n    if ((mark != UNSET_MARK) && (mark > position)) {\r\n        mark = UNSET_MARK;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "picard.vcf.filter.TestFilterVcf.testAbFiltering",
	"Comment": "tests that sites with a het allele balance0.4 are marked as filtered out.",
	"Method": "void testAbFiltering(){\r\n    final Set<String> fails = CollectionUtil.makeSet(\"tf2\", \"rs28566954\", \"rs28548431\");\r\n    final File out = testFiltering(INPUT, \".vcf.gz\", 0.4, 0, 0, Double.MAX_VALUE);\r\n    final ListMap<String, String> filters = slurpFilters(out);\r\n    Assert.assertEquals(sorted(filters.keySet()), sorted(fails), \"Failed sites did not match expected set of failed sites.\");\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getAssShadow",
	"Comment": "returns the shadow parameter used for ass subtitling. default value is 1.",
	"Method": "String getAssShadow(){\r\n    return getString(KEY_ASS_SHADOW, \"1\");\r\n}"
}, {
	"Path": "picard.vcf.VcfTestUtils.createTemporaryIndexedFile",
	"Comment": "this method creates a temporary vcf or bam file and its appropriately named index file, and will delete them on exit.",
	"Method": "File createTemporaryIndexedFile(String prefix,String suffix){\r\n    final File out = File.createTempFile(prefix, suffix);\r\n    out.deleteOnExit();\r\n    String indexFileExtension = null;\r\n    if (suffix.endsWith(\"vcf.gz\")) {\r\n        indexFileExtension = \".tbi\";\r\n    } else if (suffix.endsWith(\"vcf\")) {\r\n        indexFileExtension = \".idx\";\r\n    } else if (suffix.endsWith(\".bam\")) {\r\n        indexFileExtension = \".bai\";\r\n    }\r\n    if (indexFileExtension != null) {\r\n        final File indexOut = new File(out.getAbsolutePath() + indexFileExtension);\r\n        indexOut.deleteOnExit();\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "quickfix.mina.message.PatternMatcher.getMinLength",
	"Comment": "returns the minimum number of bytes that the pattern can match.if the pattern has no optional characters, this is simply thepattern length.",
	"Method": "int getMinLength(){\r\n    return minLength;\r\n}"
}, {
	"Path": "peergos.shared.util.EfficientHashMap.ensureSizeFor",
	"Comment": "ensures the map is large enough to contain the specified number of entries.default access to avoid synthetic accessors from inner classes.",
	"Method": "void ensureSizeFor(int expectedSize){\r\n    if (keys.length * 3 >= expectedSize * 4) {\r\n        return;\r\n    }\r\n    int newCapacity = keys.length << 1;\r\n    while (newCapacity * 3 < expectedSize * 4) {\r\n        newCapacity <<= 1;\r\n    }\r\n    Object[] oldKeys = keys;\r\n    Object[] oldValues = values;\r\n    initTable(newCapacity);\r\n    for (int i = 0; i < oldKeys.length; ++i) {\r\n        Object k = oldKeys[i];\r\n        if (k != null) {\r\n            int newIndex = getKeyIndex(unmaskNullKey(k));\r\n            while (keys[newIndex] != null) {\r\n                if (++newIndex == keys.length) {\r\n                    newIndex = 0;\r\n                }\r\n            }\r\n            keys[newIndex] = k;\r\n            values[newIndex] = oldValues[i];\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.Graph.getEdgeTargetField",
	"Comment": "get the data field used to denote the target node in an edge table.",
	"Method": "String getEdgeTargetField(){\r\n    return m_tkey;\r\n}"
}, {
	"Path": "net.pms.util.Version.getRevision",
	"Comment": "returns the third integer element of this version string,\tor 0 if a third integer was not defined or could not be parsed",
	"Method": "int getRevision(){\r\n    if (elements.length > 2) {\r\n        return elements[2];\r\n    } else {\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.SquarifiedTreeMapLayout.getFrameWidth",
	"Comment": "gets the amount of desired framing space, in pixels, betweenparent rectangles and their enclosed children.",
	"Method": "double getFrameWidth(){\r\n    return m_frame;\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.ContentWidget.ensureWidgetInitialized",
	"Comment": "ensure that the demo widget has been initialized. note that initializationcan fail if there is a network failure.",
	"Method": "void ensureWidgetInitialized(){\r\n    if (widgetInitializing || widgetInitialized) {\r\n        return;\r\n    }\r\n    widgetInitializing = true;\r\n    asyncOnInitialize(new AsyncCallback<Widget>() {\r\n        public void onFailure(Throwable reason) {\r\n            widgetInitializing = false;\r\n            Window.alert(\"Failed to download code for this widget (\" + reason + \")\");\r\n        }\r\n        public void onSuccess(Widget result) {\r\n            widgetInitializing = false;\r\n            widgetInitialized = true;\r\n            Widget widget = result;\r\n            if (widget != null) {\r\n                view.setExample(widget);\r\n            }\r\n            onInitializeComplete();\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.ContentWidget.ensureWidgetInitialized",
	"Comment": "ensure that the demo widget has been initialized. note that initializationcan fail if there is a network failure.",
	"Method": "void ensureWidgetInitialized(){\r\n    widgetInitializing = false;\r\n    Window.alert(\"Failed to download code for this widget (\" + reason + \")\");\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.ContentWidget.ensureWidgetInitialized",
	"Comment": "ensure that the demo widget has been initialized. note that initializationcan fail if there is a network failure.",
	"Method": "void ensureWidgetInitialized(){\r\n    widgetInitializing = false;\r\n    widgetInitialized = true;\r\n    Widget widget = result;\r\n    if (widget != null) {\r\n        view.setExample(widget);\r\n    }\r\n    onInitializeComplete();\r\n}"
}, {
	"Path": "picard.util.help.PicardHelpDoclet.start",
	"Comment": "create a doclet of the appropriate type and generate the freemarker templates properties.",
	"Method": "boolean start(RootDoc rootDoc){\r\n    return new picard.util.help.PicardHelpDoclet().startProcessDocs(rootDoc);\r\n}"
}, {
	"Path": "net.pms.util.Version.isLessThan",
	"Comment": "returns true if this version is less than the supplied\tversion, false otherwise",
	"Method": "boolean isLessThan(Version other){\r\n    return compareTo(other) < 0;\r\n}"
}, {
	"Path": "prefuse.activity.ActivityMap.run",
	"Comment": "schedules the activity corresponding to the given key to be runimmediately by the activitymanager.",
	"Method": "Activity run(String key){\r\n    Activity a = get(key);\r\n    if (a != null)\r\n        ActivityManager.scheduleNow(a);\r\n    return a;\r\n}"
}, {
	"Path": "org.pcap4j.packet.DnsDomainName.toString",
	"Comment": "convert this object to string representation including all fields info and decompressed domainname.",
	"Method": "String toString(String toString,byte[] headerRawData){\r\n    if (labels.size() == 0 && pointer == null) {\r\n        return \"<ROOT>\";\r\n    }\r\n    if (pointer == null) {\r\n        return name;\r\n    } else {\r\n        String decompressedName;\r\n        try {\r\n            decompressedName = decompress(headerRawData);\r\n        } catch (IllegalRawDataException e) {\r\n            LOG.error(\"Error occurred during building complete name.\", e);\r\n            decompressedName = \"Error occurred during building complete name\";\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(decompressedName).append(\" (name: \").append(name).append(\", pointer: \").append(pointer).append(\")\");\r\n        return sb.toString();\r\n    }\r\n}"
}, {
	"Path": "io.github.benas.randombeans.FieldExclusionChecker.shouldBeExcluded",
	"Comment": "given the current population context, should the field be excluded from being populated ?",
	"Method": "boolean shouldBeExcluded(Field field,RandomizationContext context){\r\n    if (isStatic(field)) {\r\n        return true;\r\n    }\r\n    Set<String> excludedFields = context.getExcludedFields();\r\n    if (excludedFields.isEmpty()) {\r\n        return false;\r\n    }\r\n    return excludedFields.contains(context.getFieldFullName(field));\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.setDefaultRenderer",
	"Comment": "sets the default renderer configuration for this resource.",
	"Method": "void setDefaultRenderer(RendererConfiguration defaultRenderer){\r\n    this.defaultRenderer = defaultRenderer;\r\n}"
}, {
	"Path": "prefuse.util.ColorMap.setMaxValue",
	"Comment": "sets the maximum value that corresponds to the lastcolor in the color map.",
	"Method": "void setMaxValue(double maxValue){\r\n    this.maxValue = maxValue;\r\n}"
}, {
	"Path": "prefuse.data.tuple.CompositeTupleSet.clear",
	"Comment": "clear this tupleset, calling clear on all contained tuplesetinstances. all contained tuplesets remain members of thiscomposite, but they have their data cleared.",
	"Method": "void clear(){\r\n    Iterator sets = m_map.entrySet().iterator();\r\n    while (sets.hasNext()) {\r\n        Map.Entry entry = (Map.Entry) sets.next();\r\n        ((TupleSet) entry.getValue()).clear();\r\n    }\r\n    m_count = 0;\r\n}"
}, {
	"Path": "picard.sam.markduplicates.EstimateLibraryComplexityTest.testSimpleDuplicatesWithSecondaryAndSupplementaryRecords",
	"Comment": "finds duplicates as expected ignoring secondary and supplementary records.",
	"Method": "void testSimpleDuplicatesWithSecondaryAndSupplementaryRecords(String testName,int numDuplicates,int numReadPairsExamined){\r\n    final File input = new File(TEST_DATA_DIR, testName);\r\n    final File output = File.createTempFile(\"estimateLibraryComplexity\", \".els_metrics\");\r\n    output.deleteOnExit();\r\n    final List<String> args = new ArrayList();\r\n    args.add(\"INPUT=\" + input.getAbsolutePath());\r\n    args.add(\"OUTPUT=\" + output.getAbsolutePath());\r\n    args.add(\"MIN_GROUP_COUNT=1\");\r\n    Assert.assertEquals(runPicardCommandLine(args), 0);\r\n    examineMetricsFile(output, numDuplicates, numReadPairsExamined);\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.setEndFont",
	"Comment": "set the ending font for the row. the font is used as the defaulttypeface for drawing text for this item.",
	"Method": "void setEndFont(int row,Font font){\r\n    set(row, VisualItem.ENDFONT, font);\r\n}"
}, {
	"Path": "prefuse.action.layout.Layout.setLayoutBounds",
	"Comment": "explicitly set the layout bounds. a reference to the input rectangleinstance is maintained, not a copy, and so any subsequent changes tothe rectangle object will also change the layout bounds.",
	"Method": "void setLayoutBounds(Rectangle2D b){\r\n    m_bounds = b;\r\n}"
}, {
	"Path": "picard.sam.markduplicates.util.MarkQueue.poll",
	"Comment": "the poll method will return the read end that isthe duplicate of all comparable read ends thathave been seen.all comparable read ends and the returned read end will have their seen duplicate flag nonduplicatereadendsset.we usethe minimum genomic distance to determine when all the comparable reads have been examined.",
	"Method": "ReadEndsForMateCigar poll(SamRecordTrackingBuffer outputBuffer,SAMFileHeader header,OpticalDuplicateFinder opticalDuplicateFinder,LibraryIdGenerator libraryIdGenerator){\r\n    final ReadEndsForMateCigar current = this.nonDuplicateReadEndsSet.pollFirst();\r\n    if (current.isPaired()) {\r\n        if (this.otherEndOfNonDuplicateReadEndsSet.contains(current)) {\r\n            final ReadEndsForMateCigar pair = this.otherEndOfNonDuplicateReadEndsSet.subSet(current, true, current, true).first();\r\n            outputBuffer.setResultState(pair.getSamRecordIndex(), false);\r\n            this.otherEndOfNonDuplicateReadEndsSet.remove(current);\r\n        }\r\n        if (null == this.tmpReadEnds) {\r\n            this.tmpReadEnds = new ReadEndsForMateCigar(header, current.getSamRecordIndex(), opticalDuplicateFinder, current.libraryId);\r\n            this.tmpReadEnds.read2ReferenceIndex = this.tmpReadEnds.read2Coordinate = -1;\r\n            this.tmpReadEnds.samRecordWithOrdinal = null;\r\n        } else {\r\n            this.tmpReadEnds.read1ReferenceIndex = current.read1ReferenceIndex;\r\n            this.tmpReadEnds.read1Coordinate = current.read1Coordinate;\r\n        }\r\n        if (current.orientation == ReadEnds.FF || current.orientation == ReadEnds.FR || current.orientation == ReadEnds.F) {\r\n            this.tmpReadEnds.orientation = ReadEnds.F;\r\n        } else {\r\n            this.tmpReadEnds.orientation = ReadEnds.R;\r\n        }\r\n        if (this.nonDuplicateReadEndsSet.contains(this.tmpReadEnds)) {\r\n            final SortedSet<ReadEndsForMateCigar> sortedSet = this.nonDuplicateReadEndsSet.subSet(this.tmpReadEnds, true, this.tmpReadEnds, true);\r\n            if (1 != sortedSet.size())\r\n                throw new PicardException(\"SortedSet should have size one (has size \" + sortedSet.size() + \" )\");\r\n            final ReadEndsForMateCigar duplicate = sortedSet.first();\r\n            outputBuffer.setResultState(duplicate.getSamRecordIndex(), true);\r\n            this.nonDuplicateReadEndsSet.remove(this.tmpReadEnds);\r\n            updateDuplicationMetrics(duplicate, libraryIdGenerator.getMetricsByLibrary(libraryIdGenerator.getLibraryName(header, duplicate.getRecord())));\r\n        }\r\n    }\r\n    outputBuffer.setResultState(current.getSamRecordIndex(), false);\r\n    return current;\r\n}"
}, {
	"Path": "prefuse.util.io.IOLib.streamFromString",
	"Comment": "get an input string corresponding to the given location string. thestring will first be resolved to a url and an input stream will berequested from the url connection. if this fails, the location willbe resolved against the file system. also, if a gzip file is found,the input stream will also be wrapped by a gzipinputstream. if thelocation string can not be resolved, a null value is returned",
	"Method": "InputStream streamFromString(String location){\r\n    InputStream is = null;\r\n    URL url = urlFromString(location, null, false);\r\n    if (url != null) {\r\n        is = url.openStream();\r\n    } else {\r\n        File f = new File(location);\r\n        if (f.exists())\r\n            is = new FileInputStream(f);\r\n    }\r\n    if (is == null) {\r\n        return null;\r\n    } else if (isGZipFile(location)) {\r\n        return new GZIPInputStream(is);\r\n    } else {\r\n        return is;\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.util.TableIterator.canSetFloat",
	"Comment": "check if the setfloat method can safely be used for thegiven data field.",
	"Method": "boolean canSetFloat(String field){\r\n    return m_table.canSetFloat(field);\r\n}"
}, {
	"Path": "picard.fingerprint.Snp.flip",
	"Comment": "returns a new snp object with the alleles swapped and maf corrected.",
	"Method": "Snp flip(){\r\n    return new Snp(name, chrom, pos, allele2, allele1, 1 - maf, fingerprintPanels);\r\n}"
}, {
	"Path": "picard.sam.MergeBamAlignmentTest.testShortFragmentClipping",
	"Comment": "test that clipping of fr reads for fragments shorter than read length happens only when it should.",
	"Method": "void testShortFragmentClipping(){\r\n    final File output = File.createTempFile(\"testShortFragmentClipping\", \".sam\");\r\n    output.deleteOnExit();\r\n    doMergeAlignment(new File(TEST_DATA_DIR, \"cliptest.unmapped.sam\"), Collections.singletonList(new File(TEST_DATA_DIR, \"cliptest.aligned.sam\")), null, null, null, null, false, true, false, 1, \"0\", \"1.0\", \"align!\", \"myAligner\", true, new File(TEST_DATA_DIR, \"cliptest.fasta\"), output, SamPairUtil.PairOrientation.FR, null, null, null, null, null);\r\n    final SamReader result = SamReaderFactory.makeDefault().open(output);\r\n    final Map<String, SAMRecord> firstReadEncountered = new HashMap<String, SAMRecord>();\r\n    for (final SAMRecord rec : result) {\r\n        final SAMRecord otherEnd = firstReadEncountered.get(rec.getReadName());\r\n        if (otherEnd == null) {\r\n            firstReadEncountered.put(rec.getReadName(), rec);\r\n        } else {\r\n            final int fragmentStart = Math.min(rec.getAlignmentStart(), otherEnd.getAlignmentStart());\r\n            final int fragmentEnd = Math.max(rec.getAlignmentEnd(), otherEnd.getAlignmentEnd());\r\n            final String[] readNameFields = rec.getReadName().split(\":\");\r\n            final int expectedFragmentStart = Integer.parseInt(readNameFields[1]);\r\n            final int expectedFragmentEnd = Integer.parseInt(readNameFields[2]);\r\n            Assert.assertEquals(fragmentStart, expectedFragmentStart, rec.getReadName());\r\n            Assert.assertEquals(fragmentEnd, expectedFragmentEnd, rec.getReadName());\r\n        }\r\n    }\r\n    result.close();\r\n}"
}, {
	"Path": "prefuse.data.query.ListQueryBinding.createRadioGroup",
	"Comment": "creates a new group of radio buttons for interacting with the query.",
	"Method": "JToggleGroup createRadioGroup(){\r\n    return createToggleGroup(JToggleGroup.RADIO);\r\n}"
}, {
	"Path": "prefuse.controls.AbstractZoomControl.setZoomOverItem",
	"Comment": "determines if the zoom control will work while the mouse isover a visualitem",
	"Method": "void setZoomOverItem(boolean zoomOverItem){\r\n    this.m_zoomOverItem = zoomOverItem;\r\n}"
}, {
	"Path": "prefuse.util.display.Clip.grow",
	"Comment": "grow the clip width and height by the given value. the minimumcoordinates will be unchanged.",
	"Method": "void grow(double b){\r\n    clip[6] += b;\r\n    clip[7] += b;\r\n}"
}, {
	"Path": "prefuse.data.io.sql.DatabaseDataSource.getSchema",
	"Comment": "given the metadata for a sql result set and a data value handler for thatresult set, returns a corresponding schema for a prefuse table.",
	"Method": "Schema getSchema(ResultSetMetaData metadata,SQLDataHandler handler){\r\n    int ncols = metadata.getColumnCount();\r\n    Schema schema = new Schema(ncols);\r\n    for (int i = 1; i <= ncols; ++i) {\r\n        String name = metadata.getColumnName(i);\r\n        int sqlType = metadata.getColumnType(i);\r\n        Class type = handler.getDataType(name, sqlType);\r\n        if (type != null)\r\n            schema.addColumn(name, type);\r\n    }\r\n    return schema;\r\n}"
}, {
	"Path": "net.pms.PMS.logSystemInfo",
	"Comment": "log system properties identifying java, the os and encoding and log\twarnings where appropriate.",
	"Method": "void logSystemInfo(){\r\n    long memoryInMB = Runtime.getRuntime().maxMemory() / 1048576;\r\n    logger.info(\"Java: \" + System.getProperty(\"java.vm.name\") + \" \" + System.getProperty(\"java.version\") + \" by \" + System.getProperty(\"java.vendor\"));\r\n    logger.info(\"OS: \" + System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.arch\") + \" \" + System.getProperty(\"os.version\"));\r\n    logger.info(\"Encoding: \" + System.getProperty(\"file.encoding\"));\r\n    logger.info(\"Memory: \" + memoryInMB + \" \" + Messages.getString(\"StatusTab.12\"));\r\n    logger.info(\"\");\r\n    if (Platform.isMac()) {\r\n        String osVersion = System.getProperty(\"os.version\");\r\n        String[] versionNumbers = osVersion.split(\"\\\\.\");\r\n        if (versionNumbers.length > 1) {\r\n            try {\r\n                int osVersionMinor = Integer.parseInt(versionNumbers[1]);\r\n                if (osVersionMinor < 6) {\r\n                    logger.warn(\"-----------------------------------------------------------------\");\r\n                    logger.warn(\"WARNING!\");\r\n                    logger.warn(\"PMS ships with binaries compiled for Mac OS X 10.6 or higher.\");\r\n                    logger.warn(\"You are running an older version of Mac OS X so PMS may not work!\");\r\n                    logger.warn(\"More information in the FAQ:\");\r\n                    logger.warn(\"http://www.ps3mediaserver.org/forum/viewtopic.php?f=6&t=3507&p=66371#p66371\");\r\n                    logger.warn(\"-----------------------------------------------------------------\");\r\n                    logger.warn(\"\");\r\n                }\r\n            } catch (NumberFormatException e) {\r\n                logger.debug(\"Cannot parse minor os.version number\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.Tree.childEdgeRows",
	"Comment": "get an iterator over the edge ids for edges connecting child nodes toa given parent",
	"Method": "IntIterator childEdgeRows(int node){\r\n    return super.outEdgeRows(node);\r\n}"
}, {
	"Path": "prefuse.data.util.RowManager.isValidRow",
	"Comment": "indicates if a given row value is a valid, occupied row of the table.",
	"Method": "boolean isValidRow(int row){\r\n    return (row >= m_firstid && row <= m_curid && (m_openrows == null || !m_openrows.containsKey(row)));\r\n}"
}, {
	"Path": "prefuse.data.Table.canGetFloat",
	"Comment": "check if the given data field can return primitive floatvalues.",
	"Method": "boolean canGetFloat(String field){\r\n    Column col = getColumn(field);\r\n    return (col == null ? false : col.canGetFloat());\r\n}"
}, {
	"Path": "prefuse.util.TimeLib.getDate",
	"Comment": "get a new date instance of the specified subclass and given long value.",
	"Method": "long getDate(Calendar c,int year,int month,int day,Date getDate,Class type,long d){\r\n    try {\r\n        Constructor c = type.getConstructor(new Class[] { long.class });\r\n        return (Date) c.newInstance(new Object[] { new Long(d) });\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "prefuse.Visualization.getSourceData",
	"Comment": "get the source data tupleset backing the given visual tuple set.",
	"Method": "TupleSet getSourceData(String group,TupleSet getSourceData,VisualTupleSet ts){\r\n    return (TupleSet) m_source.get(ts.getGroup());\r\n}"
}, {
	"Path": "prefuse.data.expression.parser.ExpressionParser.unescape",
	"Comment": "replace escape sequences with represented characters. thisincludes newlines, tabs, and quotes.",
	"Method": "String unescape(String s){\r\n    int len = s.length(), base = 0, idx;\r\n    String escapes = \"tnrbf\\\\\\\"'\";\r\n    String chars = \"\\t\\n\\r\\b\\f\\\\\\\"'\";\r\n    StringBuffer sbuf = null;\r\n    while ((idx = s.indexOf('\\\\', base)) != -1) {\r\n        if (sbuf != null)\r\n            sbuf.append(s.substring(base, idx));\r\n        if (idx + 1 == len)\r\n            break;\r\n        char c = s.charAt(idx + 1);\r\n        int cidx = escapes.indexOf(c);\r\n        if (cidx == -1) {\r\n            sbuf.append('\\\\');\r\n            sbuf.append(c);\r\n        } else {\r\n            if (sbuf == null)\r\n                sbuf = new StringBuffer(s.substring(base, idx));\r\n            sbuf.append(chars.charAt(cidx));\r\n        }\r\n        base = idx + 2;\r\n    }\r\n    if (sbuf != null && base < len)\r\n        sbuf.append(s.substring(base));\r\n    return (sbuf == null ? s : sbuf.toString());\r\n}"
}, {
	"Path": "picard.sam.AbstractAlignmentMerger.setAddPGTagToReads",
	"Comment": "set addpgtagtoreads. if true, the pg will be added to reads when applicable. if false, the pg tag will not be added.default is true",
	"Method": "void setAddPGTagToReads(boolean addPGTagToReads){\r\n    this.addPGTagToReads = addPGTagToReads;\r\n}"
}, {
	"Path": "net.pms.util.PlayerUtil.isVideo",
	"Comment": "returns whether or not the supplied dlna resource is a video file.",
	"Method": "boolean isVideo(DLNAResource resource,boolean isVideo,DLNAResource resource,Format.Identifier identifier){\r\n    return isType(resource, Format.VIDEO, identifier);\r\n}"
}, {
	"Path": "io.github.benas.randombeans.EnhancedRandomBuilder.randomize",
	"Comment": "register a supplier as randomizer for a given field.the field type must be provided in the field definition",
	"Method": "EnhancedRandomBuilder randomize(FieldDefinition<T, F> fieldDefinition,Randomizer<R> randomizer,EnhancedRandomBuilder randomize,FieldDefinition<T, F> fieldDefinition,Supplier<R> supplier,EnhancedRandomBuilder randomize,Class<T> type,Randomizer<R> randomizer,EnhancedRandomBuilder randomize,Class<T> type,Supplier<R> supplier){\r\n    return randomize(type, asRandomizer(supplier));\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.ForceDirectedLayout.getSpringCoefficient",
	"Comment": "get the spring coefficient for the given edge, which controls thetension or strength of the spring. subclasses shouldoverride this method to perform custom spring tension assignment.",
	"Method": "float getSpringCoefficient(EdgeItem e){\r\n    return -1.f;\r\n}"
}, {
	"Path": "picard.sam.SamErrorMetric.CollectSamErrorMetrics.CompareVariantContextToLocus",
	"Comment": "compares a variantcontext to a locus providing information regarding possible overlap, or relative location",
	"Method": "int CompareVariantContextToLocus(SAMSequenceDictionary dictionary,VariantContext variantContext,Locus locus){\r\n    final int indexDiff = dictionary.getSequenceIndex(variantContext.getContig()) - locus.getSequenceIndex();\r\n    if (indexDiff != 0) {\r\n        return indexDiff < 0 ? Integer.MIN_VALUE : Integer.MAX_VALUE;\r\n    }\r\n    if (locus.getPosition() < variantContext.getStart())\r\n        return variantContext.getStart() - locus.getPosition();\r\n    if (locus.getPosition() > variantContext.getEnd())\r\n        return variantContext.getEnd() - locus.getPosition();\r\n    return 0;\r\n}"
}, {
	"Path": "prefuse.visual.VisualTree.fireGraphEvent",
	"Comment": "fire a graph event. makes sure to invalidate all edges connectedto a node that has been updated.",
	"Method": "void fireGraphEvent(Table t,int first,int last,int col,int type){\r\n    if (type == EventConstants.UPDATE && col == VisualItem.IDX_VALIDATED && t == getNodeTable()) {\r\n        VisualTable nodes = (VisualTable) t;\r\n        VisualTable edges = (VisualTable) getEdgeTable();\r\n        for (int i = first; i <= last; ++i) {\r\n            if (nodes.isValidated(i))\r\n                continue;\r\n            IntIterator erows = edgeRows(i);\r\n            while (erows.hasNext()) {\r\n                int erow = erows.nextInt();\r\n                edges.setValidated(erow, false);\r\n            }\r\n        }\r\n    }\r\n    super.fireGraphEvent(t, first, last, col, type);\r\n}"
}, {
	"Path": "prefuse.data.io.TreeMLWriter.nextNode",
	"Comment": "find the next node in the depth first iteration, closing off openbranch tags as needed.",
	"Method": "Node nextNode(Node x,XMLWriter xml){\r\n    Node n, c;\r\n    if ((c = x.getChild(0)) != null) {\r\n    } else if ((c = x.getNextSibling()) != null) {\r\n        xml.end();\r\n    } else {\r\n        c = x.getParent();\r\n        xml.end();\r\n        while (c != null) {\r\n            if ((n = c.getNextSibling()) != null) {\r\n                c = n;\r\n                xml.end();\r\n                break;\r\n            }\r\n            c = c.getParent();\r\n            xml.end();\r\n        }\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "prefuse.activity.ActivityMap.alwaysRunAfter",
	"Comment": "schedules the activity corresponding to the afterkey to always be runimmediately after the completion of the activity corresponding to the beforekey. this method has no scheduling effect on the activitycorresponding to the before key.",
	"Method": "Activity alwaysRunAfter(String beforeKey,String afterKey){\r\n    Activity before = get(beforeKey);\r\n    Activity after = get(afterKey);\r\n    if (before != null && after != null)\r\n        ActivityManager.alwaysScheduleAfter(before, after);\r\n    return after;\r\n}"
}, {
	"Path": "prefuse.data.Table.isAddColumnSupported",
	"Comment": "returns true, as this table supports the addition of new data fields.",
	"Method": "boolean isAddColumnSupported(){\r\n    return true;\r\n}"
}, {
	"Path": "prefuse.Visualization.getVisualItem",
	"Comment": "get the visualitem associated with a source data tuple, if it exists.",
	"Method": "VisualItem getVisualItem(String group,Tuple t){\r\n    TupleSet ts = getVisualGroup(group);\r\n    VisualTable vt;\r\n    if (ts instanceof VisualTable) {\r\n        vt = (VisualTable) ts;\r\n    } else if (ts instanceof Graph) {\r\n        Graph g = (Graph) ts;\r\n        vt = (VisualTable) (t instanceof Node ? g.getNodeTable() : g.getEdgeTable());\r\n    } else {\r\n        return null;\r\n    }\r\n    int pr = t.getRow();\r\n    int cr = vt.getChildRow(pr);\r\n    return cr < 0 ? null : vt.getItem(cr);\r\n}"
}, {
	"Path": "picard.illumina.parser.IlluminaDataProviderFactory.findPreferredAvailableFormat",
	"Comment": "given a data type find the most preferred file format that also has files available",
	"Method": "SupportedIlluminaFormat findPreferredAvailableFormat(IlluminaDataType dt,IlluminaFileUtil fileUtil){\r\n    return findPreferredFormat(dt, fileUtil, true);\r\n}"
}, {
	"Path": "com.restfb.json.ParseException.getLine",
	"Comment": "returns the number of the line in which the error occurred. the first line counts as 1.",
	"Method": "int getLine(){\r\n    return line;\r\n}"
}, {
	"Path": "prefuse.data.Table.canSetBoolean",
	"Comment": "check if the setboolean method can safely be used for thegiven data field.",
	"Method": "boolean canSetBoolean(String field){\r\n    Column col = getColumn(field);\r\n    return (col == null ? false : col.canSetBoolean());\r\n}"
}, {
	"Path": "prefuse.data.search.Trie.find",
	"Comment": "look up the given word in this trie. if a match is found, a trienodeis returned. this node is the root of a subtree containing all thematches to the query.",
	"Method": "TrieNode find(String word,TrieNode find,String word,TrieBranch b,int depth){\r\n    char c = getChar(word, depth);\r\n    int i = getIndex(b.chars, c);\r\n    if (i == -1) {\r\n        return null;\r\n    } else if (word.length() - 1 == depth) {\r\n        return b.children[i];\r\n    } else if (b.children[i] instanceof TrieLeaf) {\r\n        return equalityCheck(word, (TrieLeaf) b.children[i]);\r\n    } else {\r\n        return find(word, (TrieBranch) b.children[i], depth + 1);\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.DataLib.toArray",
	"Comment": "get an array containing all data values for a given tuple iterationand field.",
	"Method": "Object[] toArray(Iterator tuples,String field){\r\n    Object[] array = new Object[100];\r\n    int i = 0;\r\n    for (; tuples.hasNext(); ++i) {\r\n        if (i >= array.length)\r\n            array = ArrayLib.resize(array, 3 * array.length / 2);\r\n        array[i] = ((Tuple) tuples.next()).get(field);\r\n    }\r\n    return ArrayLib.trim(array, i);\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeProbabilitiesUsingLogLikelihoods.getRepresentativeSnp",
	"Comment": "simple returns the snp from the haplotype that has the lowest genome coordinate.",
	"Method": "Snp getRepresentativeSnp(){\r\n    return getHaplotype().getFirstSnp();\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.other.CwAnimation.createOptionsBar",
	"Comment": "create an options panel that allows users to select a widget and reposition",
	"Method": "Widget createOptionsBar(){\r\n    VerticalPanel optionsBar = new VerticalPanel();\r\n    optionsBar.setSpacing(5);\r\n    optionsBar.setHorizontalAlignment(HasHorizontalAlignment.ALIGN_CENTER);\r\n    optionsBar.add(new HTML(\"<b>\" + constants.cwAnimationOptions() + \"<\/b>\"));\r\n    startButton = new Button(constants.cwAnimationStart());\r\n    startButton.addStyleName(\"sc-FixedWidthButton\");\r\n    startButton.addClickHandler(new ClickHandler() {\r\n        public void onClick(ClickEvent event) {\r\n            animation.run(2000);\r\n        }\r\n    });\r\n    optionsBar.add(startButton);\r\n    cancelButton = new Button(constants.cwAnimationCancel());\r\n    cancelButton.addStyleName(\"sc-FixedWidthButton\");\r\n    cancelButton.addClickHandler(new ClickHandler() {\r\n        public void onClick(ClickEvent event) {\r\n            animation.cancel();\r\n        }\r\n    });\r\n    optionsBar.add(cancelButton);\r\n    return optionsBar;\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.other.CwAnimation.createOptionsBar",
	"Comment": "create an options panel that allows users to select a widget and reposition",
	"Method": "Widget createOptionsBar(){\r\n    animation.run(2000);\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.other.CwAnimation.createOptionsBar",
	"Comment": "create an options panel that allows users to select a widget and reposition",
	"Method": "Widget createOptionsBar(){\r\n    animation.cancel();\r\n}"
}, {
	"Path": "picard.illumina.parser.IlluminaFileUtil.getUtil",
	"Comment": "given a file type, get the parameterized file util object associated with it",
	"Method": "ParameterizedFileUtil getUtil(SupportedIlluminaFormat format){\r\n    ParameterizedFileUtil parameterizedFileUtil = utils.get(format);\r\n    if (parameterizedFileUtil == null) {\r\n        switch(format) {\r\n            case Bcl:\r\n                final ParameterizedFileUtil bclFileUtil = new PerTilePerCycleFileUtil(\".bcl\", basecallLaneDir, new BclFileFaker(), lane);\r\n                final ParameterizedFileUtil gzBclFileUtil = new PerTilePerCycleFileUtil(\".bcl.gz\", basecallLaneDir, new BclFileFaker(), lane);\r\n                if (bclFileUtil.filesAvailable() && !gzBclFileUtil.filesAvailable()) {\r\n                    parameterizedFileUtil = bclFileUtil;\r\n                } else if (!bclFileUtil.filesAvailable() && gzBclFileUtil.filesAvailable()) {\r\n                    parameterizedFileUtil = gzBclFileUtil;\r\n                } else if (!bclFileUtil.filesAvailable() && !gzBclFileUtil.filesAvailable()) {\r\n                    parameterizedFileUtil = bclFileUtil;\r\n                } else {\r\n                    throw new PicardException(\"Not all BCL files in \" + basecallLaneDir.getAbsolutePath() + \" have the same extension!\");\r\n                }\r\n                utils.put(SupportedIlluminaFormat.Bcl, parameterizedFileUtil);\r\n                break;\r\n            case Locs:\r\n                parameterizedFileUtil = new PerTileOrPerRunFileUtil(\".locs\", intensityLaneDir, new LocsFileFaker(), lane);\r\n                utils.put(SupportedIlluminaFormat.Locs, parameterizedFileUtil);\r\n                break;\r\n            case Clocs:\r\n                parameterizedFileUtil = new PerTileFileUtil(\".clocs\", intensityLaneDir, new ClocsFileFaker(), lane);\r\n                utils.put(SupportedIlluminaFormat.Clocs, parameterizedFileUtil);\r\n                break;\r\n            case Pos:\r\n                parameterizedFileUtil = new PerTileFileUtil(\"_pos.txt\", intensityDir, new PosFileFaker(), lane);\r\n                utils.put(SupportedIlluminaFormat.Pos, parameterizedFileUtil);\r\n                break;\r\n            case Filter:\r\n                parameterizedFileUtil = new PerTileFileUtil(\".filter\", basecallLaneDir, new FilterFileFaker(), lane);\r\n                utils.put(SupportedIlluminaFormat.Filter, parameterizedFileUtil);\r\n                break;\r\n            case Barcode:\r\n                parameterizedFileUtil = new PerTileFileUtil(\"_barcode.txt\", barcodeDir != null ? barcodeDir : basecallDir, new BarcodeFileFaker(), lane, false);\r\n                utils.put(SupportedIlluminaFormat.Barcode, parameterizedFileUtil);\r\n                break;\r\n            case MultiTileFilter:\r\n                parameterizedFileUtil = new MultiTileFilterFileUtil(basecallLaneDir, lane);\r\n                utils.put(SupportedIlluminaFormat.MultiTileFilter, parameterizedFileUtil);\r\n                break;\r\n            case MultiTileLocs:\r\n                parameterizedFileUtil = new MultiTileLocsFileUtil(new File(intensityDir, basecallLaneDir.getName()), basecallLaneDir, lane);\r\n                utils.put(SupportedIlluminaFormat.MultiTileLocs, parameterizedFileUtil);\r\n                break;\r\n            case MultiTileBcl:\r\n                parameterizedFileUtil = new MultiTileBclFileUtil(basecallLaneDir, lane);\r\n                utils.put(SupportedIlluminaFormat.MultiTileBcl, parameterizedFileUtil);\r\n                break;\r\n        }\r\n    }\r\n    return parameterizedFileUtil;\r\n}"
}, {
	"Path": "prefuse.Display.getInverseTransform",
	"Comment": "returns a reference to the inverse of the affinetransformation used bythis display. direct changes made to this reference will corrupt thestate of this display.",
	"Method": "AffineTransform getInverseTransform(){\r\n    return m_itransform;\r\n}"
}, {
	"Path": "net.pms.network.RequestHandlerV2.filterIp",
	"Comment": "applies the ip filter to the specified internet address. returns true\tif the address is not allowed and therefore should be filtered out,\tfalse otherwise.",
	"Method": "boolean filterIp(InetAddress inetAddress){\r\n    return !PMS.getConfiguration().getIpFiltering().allowed(inetAddress);\r\n}"
}, {
	"Path": "io.github.benas.randombeans.util.ReflectionUtils.isPrimitiveFieldWithDefaultValue",
	"Comment": "check if a field has a primitive type and matching default value which is set by the compiler.",
	"Method": "boolean isPrimitiveFieldWithDefaultValue(Object object,Field field){\r\n    Class<?> fieldType = field.getType();\r\n    if (!fieldType.isPrimitive()) {\r\n        return false;\r\n    }\r\n    Object fieldValue = getFieldValue(object, field);\r\n    if (fieldValue == null) {\r\n        return false;\r\n    }\r\n    if (fieldType.equals(boolean.class) && (boolean) fieldValue == false) {\r\n        return true;\r\n    }\r\n    if (fieldType.equals(byte.class) && (byte) fieldValue == (byte) 0) {\r\n        return true;\r\n    }\r\n    if (fieldType.equals(short.class) && (short) fieldValue == (short) 0) {\r\n        return true;\r\n    }\r\n    if (fieldType.equals(int.class) && (int) fieldValue == 0) {\r\n        return true;\r\n    }\r\n    if (fieldType.equals(long.class) && (long) fieldValue == 0L) {\r\n        return true;\r\n    }\r\n    if (fieldType.equals(float.class) && (float) fieldValue == 0.0F) {\r\n        return true;\r\n    }\r\n    if (fieldType.equals(double.class) && (double) fieldValue == 0.0D) {\r\n        return true;\r\n    }\r\n    if (fieldType.equals(char.class) && (char) fieldValue == '') {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.isRendererForceDefault",
	"Comment": "returns true when pms should not try to guess connecting renderers\tand instead force picking the defined fallback renderer. default\tvalue is false, which means pms will attempt to recognize connecting\trenderers by their headers.",
	"Method": "boolean isRendererForceDefault(){\r\n    return getBoolean(KEY_RENDERER_FORCE_DEFAULT, false);\r\n}"
}, {
	"Path": "com.restfb.types.Photo.getTags",
	"Comment": "an array containing the users and their positions in this photo. the x and y coordinates are percentages from theleft and top edges of the photo, respectively.",
	"Method": "List<Tag> getTags(){\r\n    return unmodifiableList(tags);\r\n}"
}, {
	"Path": "prefuse.Visualization.items",
	"Comment": "get an iterator over all items in the given group which match the givenpredicate filter.",
	"Method": "Iterator items(Iterator items,Predicate filter,Iterator items,String group,Iterator items,String group,String expr,Iterator items,String group,Predicate filter){\r\n    if (ALL_ITEMS.equals(group))\r\n        return items(filter);\r\n    TupleSet t = getGroup(group);\r\n    return (t == null ? Collections.EMPTY_LIST.iterator() : t.tuples(filter));\r\n}"
}, {
	"Path": "com.restfb.json.JsonValue.isTrue",
	"Comment": "detects whether this value represents the json literal true.",
	"Method": "boolean isTrue(){\r\n    return false;\r\n}"
}, {
	"Path": "com.restfb.exception.generator.DefaultFacebookExceptionGenerator.skipResponseStatusExceptionParsing",
	"Comment": "checks if a string may be a json and contains a error string somewhere, this is used for speedup the error parsing",
	"Method": "void skipResponseStatusExceptionParsing(String json){\r\n    if (!json.startsWith(\"{\")) {\r\n        throw new ResponseErrorJsonParsingException();\r\n    }\r\n    int subStrEnd = Math.min(50, json.length());\r\n    if (!json.substring(0, subStrEnd).contains(\"\\\"error\\\"\")) {\r\n        throw new ResponseErrorJsonParsingException();\r\n    }\r\n}"
}, {
	"Path": "quickfix.Message.getInvalidTag",
	"Comment": "returns the first invalid tag, which is all that can be reportedin the resulting fix reject message.",
	"Method": "int getInvalidTag(){\r\n    return exception != null ? exception.getField() : 0;\r\n}"
}, {
	"Path": "prefuse.util.display.RenderingQueue.clean",
	"Comment": "clears the rendering queue and resizes internal arrays to a small size.this should help reclaim used memory.",
	"Method": "void clean(){\r\n    clear();\r\n    ritems = new VisualItem[DEFAULT_SIZE];\r\n    rscores = new int[DEFAULT_SIZE];\r\n    pitems = new VisualItem[DEFAULT_SIZE];\r\n    pscores = new int[DEFAULT_SIZE];\r\n    items_buf = null;\r\n    scores_buf = null;\r\n}"
}, {
	"Path": "net.pms.configuration.ConfigurationReader.getCustomProperty",
	"Comment": "return the object value for a custom configuration key.\treturns an object if the key exists, or null otherwise.",
	"Method": "Object getCustomProperty(String property){\r\n    Object value = configuration.getProperty(property);\r\n    log(property, value, null);\r\n    return value;\r\n}"
}, {
	"Path": "org.quickfixj.codegenerator.GenerateMojo.setOutputDirectory",
	"Comment": "sets the destination directory to used during code generation.",
	"Method": "void setOutputDirectory(File outputDirectory){\r\n    this.outputDirectory = outputDirectory;\r\n}"
}, {
	"Path": "prefuse.data.Schema.clone",
	"Comment": "creates a copy of this schema. this might be useful for creatingextended schemas from a shared base schema. cloned copiesof a locked schema will not inherit the locked status.",
	"Method": "Object clone(){\r\n    Schema s = new Schema(m_size);\r\n    for (int i = 0; i < m_size; ++i) {\r\n        s.addColumn(m_names[i], m_types[i], m_dflts[i]);\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "prefuse.Display.rotate",
	"Comment": "rotates the view provided by this display by the given angle in radians,anchoring the rotation at the specified point in screen coordinates.",
	"Method": "void rotate(Point2D p,double theta){\r\n    m_itransform.transform(p, m_tmpPoint);\r\n    rotateAbs(m_tmpPoint, theta);\r\n}"
}, {
	"Path": "picard.illumina.BasecallsConverter.setConverter",
	"Comment": "must be called before dotileprocessing.this is not passed in the ctor because often theilluminadataproviderfactory is needed in order to construct the converter.",
	"Method": "void setConverter(ClusterDataConverter<CLUSTER_OUTPUT_RECORD> converter){\r\n    this.converter = converter;\r\n}"
}, {
	"Path": "prefuse.util.ui.JRangeSlider.getMaximum",
	"Comment": "gets the maximum possible value for either the low value or the high value.",
	"Method": "int getMaximum(){\r\n    return model.getMaximum();\r\n}"
}, {
	"Path": "com.restfb.json.JsonValue.isNull",
	"Comment": "detects whether this value represents the json literal null.",
	"Method": "boolean isNull(){\r\n    return false;\r\n}"
}, {
	"Path": "net.pms.network.HTTPResource.downloadAndSend",
	"Comment": "creates an inputstream based on a url. this is used while accessing external resources\tlike online radio stations.",
	"Method": "InputStream downloadAndSend(String u,boolean saveOnDisk){\r\n    URL url = new URL(u);\r\n    File f = null;\r\n    if (saveOnDisk) {\r\n        String host = url.getHost();\r\n        String hostName = convertURLToFileName(host);\r\n        String fileName = url.getFile();\r\n        fileName = convertURLToFileName(fileName);\r\n        File hostDir = new File(PMS.getConfiguration().getTempFolder(), hostName);\r\n        if (!hostDir.isDirectory()) {\r\n            if (!hostDir.mkdir()) {\r\n                logger.debug(\"Cannot create directory: {}\", hostDir.getAbsolutePath());\r\n            }\r\n        }\r\n        f = new File(hostDir, fileName);\r\n        if (f.exists()) {\r\n            return new FileInputStream(f);\r\n        }\r\n    }\r\n    byte[] content = downloadAndSendBinary(u, saveOnDisk, f);\r\n    return new ByteArrayInputStream(content);\r\n}"
}, {
	"Path": "com.restfb.json.PrettyPrint.indentWithTabs",
	"Comment": "do not break lines, but still insert whitespace between values.",
	"Method": "PrettyPrint indentWithTabs(){\r\n    return new PrettyPrint(new char[] { '\\t' });\r\n}"
}, {
	"Path": "picard.util.MathUtil.indexOfMin",
	"Comment": "returns the index of the smallest element in the array.if there are multiple equal minima thenthe earliest one in the array is returned.",
	"Method": "int indexOfMin(int[] nums,int indexOfMin,double[] nums){\r\n    double min = nums[0];\r\n    int index = 0;\r\n    for (int i = 1; i < nums.length; ++i) {\r\n        if (nums[i] < min) {\r\n            min = nums[i];\r\n            index = i;\r\n        }\r\n    }\r\n    return index;\r\n}"
}, {
	"Path": "picard.illumina.parser.ParameterizedFileUtil.makeLaneTileRegex",
	"Comment": "return a regex string for finding lane and tile given a file extension pattern",
	"Method": "String makeLaneTileRegex(String fileNameEndPattern,int lane){\r\n    if (lane < 0) {\r\n        throw new PicardException(\"Lane (\" + lane + \") cannot be negative\");\r\n    }\r\n    return \"^\" + \"s_\" + lane + \"_(\\\\d{1,5})\" + fileNameEndPattern + \"$\";\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.setTupleManagers",
	"Comment": "unsupported operation. spanning trees should not be edited.",
	"Method": "void setTupleManagers(TupleManager ntm,TupleManager etm){\r\n    throw new UnsupportedOperationException(\"Changes to graph structure not allowed for spanning trees.\");\r\n}"
}, {
	"Path": "prefuse.util.ui.JToggleGroup.getAxisType",
	"Comment": "get the box axis type used to orient the toggle group component.",
	"Method": "int getAxisType(){\r\n    return m_axis;\r\n}"
}, {
	"Path": "me.vickychijwani.spectre.util.KeyboardUtils.defocusAndHideKeyboard",
	"Comment": "clear focus from the current view and hide the soft keyboard.",
	"Method": "void defocusAndHideKeyboard(Activity activity){\r\n    if (activity == null)\r\n        return;\r\n    View view = activity.getCurrentFocus();\r\n    if (view != null) {\r\n        view.clearFocus();\r\n        hideKeyboard(activity, view.getWindowToken());\r\n    }\r\n}"
}, {
	"Path": "prefuse.Visualization.setRendererFactory",
	"Comment": "set the rendererfactory used by this visualization. the rendererfactoryis responsible for providing the renderer instances used to drawthe visualitems.",
	"Method": "void setRendererFactory(RendererFactory rf){\r\n    invalidateAll();\r\n    m_renderers = rf;\r\n}"
}, {
	"Path": "prefuse.util.io.IOLib.getGraphFile",
	"Comment": "present a file chooser dialog for loading a graph or tree data set.",
	"Method": "Graph getGraphFile(Component c){\r\n    JFileChooser jfc = new JFileChooser();\r\n    jfc.setDialogType(JFileChooser.OPEN_DIALOG);\r\n    jfc.setDialogTitle(\"Open Graph or Tree File\");\r\n    jfc.setAcceptAllFileFilterUsed(false);\r\n    SimpleFileFilter ff;\r\n    ff = new SimpleFileFilter(\"xml\", \"TreeML File (*.xml, *.treeml)\", new TreeMLReader());\r\n    ff.addExtension(\"treeml\");\r\n    ff.addExtension(\"gz\");\r\n    jfc.setFileFilter(ff);\r\n    ff = new SimpleFileFilter(\"xml\", \"GraphML File (*.xml, *.graphml)\", new GraphMLReader());\r\n    ff.addExtension(\"graphml\");\r\n    ff.addExtension(\"gz\");\r\n    jfc.setFileFilter(ff);\r\n    int retval = jfc.showOpenDialog(c);\r\n    if (retval != JFileChooser.APPROVE_OPTION)\r\n        return null;\r\n    File f = jfc.getSelectedFile();\r\n    ff = (SimpleFileFilter) jfc.getFileFilter();\r\n    GraphReader gr = (GraphReader) ff.getUserData();\r\n    try {\r\n        return gr.readGraph(streamFromString(f.getAbsolutePath()));\r\n    } catch (Exception e) {\r\n        Logger.getLogger(IOLib.class.getName()).warning(e.getMessage() + \"\\n\" + StringLib.getStackTrace(e));\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.isSkipTranscode",
	"Comment": "returns true if transcoding should be skipped for this resource.",
	"Method": "boolean isSkipTranscode(){\r\n    return skipTranscode;\r\n}"
}, {
	"Path": "picard.illumina.parser.PerTileCycleParser.seekToTile",
	"Comment": "clear the current set of cyclefileparsers and replace them with the ones for the tile indicated by onebasedtilenumber",
	"Method": "void seekToTile(int tile){\r\n    currentTile = tile;\r\n    int totalCycles = 0;\r\n    final List<File> tileFiles = new ArrayList<File>();\r\n    for (final Map.Entry<Integer, IlluminaFileMap> entry : cyclesToTileFiles.entrySet()) {\r\n        tileFiles.add(entry.getValue().get(currentTile));\r\n        ++totalCycles;\r\n    }\r\n    cycleFilesParser = makeCycleFileParser(tileFiles, cycleFilesParser);\r\n    if (totalCycles != outputMapping.getTotalOutputCycles()) {\r\n        throw new PicardException(\"Number of cycle OUTPUT files found (\" + totalCycles + \") does not equal the number expected (\" + outputMapping.getTotalOutputCycles() + \")\");\r\n    }\r\n}"
}, {
	"Path": "quickfix.MessageUtils.newInvalidMessageException",
	"Comment": "returns an invalidmessage exception with optionally attached fix message.",
	"Method": "InvalidMessage newInvalidMessageException(String errorMessage,Message fixMessage){\r\n    if (fixMessage != null) {\r\n        return new InvalidMessage(errorMessage, fixMessage);\r\n    }\r\n    return new InvalidMessage(errorMessage);\r\n}"
}, {
	"Path": "io.github.benas.randombeans.util.ReflectionUtils.isAnnotationPresent",
	"Comment": "checks if field or corresponding read method is annotated with given annotationtype.",
	"Method": "boolean isAnnotationPresent(Field field,Class<? extends Annotation> annotationType){\r\n    final Optional<Method> readMethod = getReadMethod(field);\r\n    return field.isAnnotationPresent(annotationType) || readMethod.isPresent() && readMethod.get().isAnnotationPresent(annotationType);\r\n}"
}, {
	"Path": "py4j.Gateway.putNewObject",
	"Comment": "adds a new object to the gateway bindings and return the generated id.\tshould never be called by other classes except subclasses and testing\tclasses.",
	"Method": "String putNewObject(Object object){\r\n    String id = getNextObjectId();\r\n    bindings.put(id, object);\r\n    return id;\r\n}"
}, {
	"Path": "picard.illumina.parser.IlluminaDataProviderFactory.makeDataProvider",
	"Comment": "call this method to create a clusterdata iterator over the specified tiles.",
	"Method": "NewIlluminaDataProvider makeDataProvider(List<File> cbcls,List<AbstractIlluminaPositionFileReader.PositionInfo> locs,File[] filterFiles,int tileNum,File barcodeFile,BaseIlluminaDataProvider makeDataProvider,BaseIlluminaDataProvider makeDataProvider,List<Integer> requestedTiles){\r\n    if (requestedTiles == null) {\r\n        requestedTiles = availableTiles;\r\n    } else {\r\n        if (requestedTiles.isEmpty()) {\r\n            throw new PicardException(\"Zero length tile list supplied to makeDataProvider, you must specify at least 1 tile OR pass NULL to use all available tiles\");\r\n        }\r\n    }\r\n    final Map<IlluminaParser, Set<IlluminaDataType>> parsersToDataType = new HashMap();\r\n    for (final Map.Entry<SupportedIlluminaFormat, Set<IlluminaDataType>> fmToDt : formatToDataTypes.entrySet()) {\r\n        parsersToDataType.put(makeParser(fmToDt.getKey(), requestedTiles), fmToDt.getValue());\r\n    }\r\n    log.debug(\"The following parsers will be used by IlluminaDataProvider: \" + StringUtil.join(\",\" + parsersToDataType.keySet()));\r\n    return new IlluminaDataProvider(outputMapping, parsersToDataType, basecallDirectory, lane);\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.ForceDirectedLayout.getReferrer",
	"Comment": "get the referrer item to use to set x or y coordinates that areinitialized to nan.",
	"Method": "VisualItem getReferrer(){\r\n    return referrer;\r\n}"
}, {
	"Path": "net.pms.newgui.RestrictedFileSystemView.createFileSystemRoot",
	"Comment": "creates a new file object for f with correct behavior for a file system root\tdirectory.",
	"Method": "File createFileSystemRoot(File f){\r\n    return new FileSystemRoot(f);\r\n}"
}, {
	"Path": "me.vickychijwani.spectre.util.Pair.hashCode",
	"Comment": "compute a hash code using the hash codes of the underlying objects",
	"Method": "int hashCode(){\r\n    return (first == null ? 0 : first.hashCode()) ^ (second == null ? 0 : second.hashCode());\r\n}"
}, {
	"Path": "picard.sam.HitsForInsert.tallyPrimaryAlignments",
	"Comment": "determine if there is a single primary alignment in a list of alignments.",
	"Method": "NumPrimaryAlignmentState tallyPrimaryAlignments(List<SAMRecord> records,NumPrimaryAlignmentState tallyPrimaryAlignments,boolean firstEnd){\r\n    if (firstEnd)\r\n        return tallyPrimaryAlignments(firstOfPairOrFragment);\r\n    else\r\n        return tallyPrimaryAlignments(secondOfPair);\r\n}"
}, {
	"Path": "picard.analysis.CounterManager.rebase",
	"Comment": "rebases inner counter arrays so that 0 index of array represents the new locus position",
	"Method": "void rebase(int locusPosition){\r\n    if (locusPosition < offset) {\r\n        throw new IllegalArgumentException(\"Position in the reference sequence is lesser than offset.\");\r\n    }\r\n    for (Counter counter : arrays) {\r\n        final int[] array = counter.array;\r\n        final int skipLength = locusPosition - offset;\r\n        System.arraycopy(array, skipLength, array, 0, arrayLength - skipLength);\r\n        Arrays.fill(array, arrayLength - skipLength, arrayLength, 0);\r\n    }\r\n    offset = locusPosition;\r\n}"
}, {
	"Path": "prefuse.util.ui.JPrefuseTree.convertValueToText",
	"Comment": "returns a string label for node instances by looking up thelabel data field specified in the constructor of this class.",
	"Method": "String convertValueToText(Object value,boolean selected,boolean expanded,boolean leaf,int row,boolean hasFocus){\r\n    if (value == null)\r\n        return \"\";\r\n    if (value instanceof Node) {\r\n        Object o = ((Node) value).get(m_field);\r\n        if (o.getClass().isArray()) {\r\n            return StringLib.getArrayString(o);\r\n        } else {\r\n            return o.toString();\r\n        }\r\n    } else {\r\n        return value.toString();\r\n    }\r\n}"
}, {
	"Path": "prefuse.render.EdgeRenderer.getArrowHeadHeight",
	"Comment": "get the height of the untransformed arrow head. this is the distance,in pixels, from the tip of the arrow to its base.",
	"Method": "int getArrowHeadHeight(){\r\n    return m_arrowHeight;\r\n}"
}, {
	"Path": "picard.illumina.parser.ParameterizedFileUtil.getTiledFiles",
	"Comment": "return all files that match pattern of the given file type in the given base directory",
	"Method": "IlluminaFileMap getTiledFiles(File baseDirectory,Pattern pattern){\r\n    final IlluminaFileMap fileMap = new IlluminaFileMap();\r\n    if (baseDirectory.exists()) {\r\n        IOUtil.assertDirectoryIsReadable(baseDirectory);\r\n        final File[] files = IOUtil.getFilesMatchingRegexp(baseDirectory, pattern);\r\n        for (final File file : files) {\r\n            if (!skipEmptyFiles || file.length() > 0) {\r\n                fileMap.put(fileToTile(file.getName()), file);\r\n            }\r\n        }\r\n    }\r\n    return fileMap;\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.canSetInt",
	"Comment": "indicates if convenience set method can be called withoutan exception being thrown for the int type.",
	"Method": "boolean canSetInt(){\r\n    return canSet(int.class);\r\n}"
}, {
	"Path": "prefuse.util.ColorLib.getGrayscalePalette",
	"Comment": "returns a color palette of default size that ranges from white toblack through shades of gray.",
	"Method": "int[] getGrayscalePalette(int size,int[] getGrayscalePalette){\r\n    return getGrayscalePalette(DEFAULT_MAP_SIZE);\r\n}"
}, {
	"Path": "picard.vcf.GenotypeConcordanceCounts.validateCountsAgainstScheme",
	"Comment": "validates that there are no counts for na states in the underlying scheme",
	"Method": "void validateCountsAgainstScheme(GenotypeConcordanceScheme scheme){\r\n    final Set<ContingencyState> naContingencyStates = getContingencyStateSet(GenotypeConcordanceScheme.NA);\r\n    for (final TruthState truthState : TruthState.values()) {\r\n        for (final CallState callState : CallState.values()) {\r\n            final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState);\r\n            if (0 < getCount(truthAndCallStates)) {\r\n                final Set<ContingencyState> contingencyStates = getContingencyStateSet(scheme.getConcordanceStateArray(truthAndCallStates));\r\n                if (contingencyStates.containsAll(naContingencyStates)) {\r\n                    throw new PicardException(String.format(\"Found counts for an illegal set of states: [%s, %s]\", truthState.name(), callState.name()));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.ui.JToggleGroup.setLabels",
	"Comment": "set the labels to use for the objects contained in the list model.",
	"Method": "void setLabels(String[] labels){\r\n    if (labels.length < m_data.getSize()) {\r\n        throw new IllegalArgumentException(\"Alias array is too short\");\r\n    }\r\n    m_labels = labels;\r\n    initUI();\r\n}"
}, {
	"Path": "com.restfb.json.JsonValue.isFalse",
	"Comment": "detects whether this value represents the json literal false.",
	"Method": "boolean isFalse(){\r\n    return false;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getLanguage",
	"Comment": "get the code of the preferred language for the pms user interface. default\tis based on the locale.",
	"Method": "String getLanguage(){\r\n    String def = Locale.getDefault().getLanguage();\r\n    if (def == null) {\r\n        def = \"en\";\r\n    }\r\n    return getString(KEY_LANGUAGE, def);\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Base64Coder.decode",
	"Comment": "decodes a byte array from base64 format. no blanks or line breaks are allowed within the base64 encoded input data.",
	"Method": "byte[] decode(String s,byte[] decode,String s,CharMap inverseCharMap,byte[] decode,char[] in,byte[] inverseCharMap,byte[] decode,char[] in,CharMap inverseCharMap,byte[] decode,char[] in,byte[] decode,char[] in,int iOff,int iLen,CharMap inverseCharMap,byte[] decode,char[] in,int iOff,int iLen,byte[] inverseCharMap){\r\n    if (iLen % 4 != 0) {\r\n        throw new IllegalArgumentException(\"Length of Base64 encoded input string is not a multiple of 4.\");\r\n    }\r\n    while (iLen > 0 && in[iOff + iLen - 1] == '=') {\r\n        iLen--;\r\n    }\r\n    int oLen = (iLen * 3) / 4;\r\n    byte[] out = new byte[oLen];\r\n    int ip = iOff;\r\n    int iEnd = iOff + iLen;\r\n    int op = 0;\r\n    while (ip < iEnd) {\r\n        int i0 = in[ip++];\r\n        int i1 = in[ip++];\r\n        int i2 = ip < iEnd ? in[ip++] : 'A';\r\n        int i3 = ip < iEnd ? in[ip++] : 'A';\r\n        if (i0 > 127 || i1 > 127 || i2 > 127 || i3 > 127) {\r\n            throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n        }\r\n        int b0 = inverseCharMap[i0];\r\n        int b1 = inverseCharMap[i1];\r\n        int b2 = inverseCharMap[i2];\r\n        int b3 = inverseCharMap[i3];\r\n        if (b0 < 0 || b1 < 0 || b2 < 0 || b3 < 0) {\r\n            throw new IllegalArgumentException(\"Illegal character in Base64 encoded data.\");\r\n        }\r\n        int o0 = (b0 << 2) | (b1 >>> 4);\r\n        int o1 = ((b1 & 0xf) << 4) | (b2 >>> 2);\r\n        int o2 = ((b2 & 3) << 6) | b3;\r\n        out[op++] = (byte) o0;\r\n        if (op < oLen) {\r\n            out[op++] = (byte) o1;\r\n        }\r\n        if (op < oLen) {\r\n            out[op++] = (byte) o2;\r\n        }\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "picard.fingerprint.CrosscheckFingerprints.crossCheckFingerprints",
	"Comment": "method that pairwise checks every pair of groups and reports a lod score for the two groupscoming from the same individual.",
	"Method": "int crossCheckFingerprints(Map<FingerprintIdDetails, Fingerprint> lhsFingerprints,Map<FingerprintIdDetails, Fingerprint> rhsFingerprints,CrosscheckMetric.DataType type,List<CrosscheckMetric> metrics){\r\n    int unexpectedResults = 0;\r\n    long checksMade = 0;\r\n    final int logEvery = 100_000;\r\n    final List<FingerprintIdDetails> lhsFingerprintIdDetails = new ArrayList(lhsFingerprints.keySet());\r\n    final List<FingerprintIdDetails> rhsFingerprintIdDetails = new ArrayList(rhsFingerprints.keySet());\r\n    final long totalChecks = lhsFingerprintIdDetails.size() * ((long) rhsFingerprintIdDetails.size());\r\n    for (int row = 0; row < lhsFingerprintIdDetails.size(); row++) {\r\n        final FingerprintIdDetails lhsId = lhsFingerprintIdDetails.get(row);\r\n        for (int col = 0; col < rhsFingerprintIdDetails.size(); col++) {\r\n            final FingerprintIdDetails rhsId = rhsFingerprintIdDetails.get(col);\r\n            final boolean expectedToMatch = EXPECT_ALL_GROUPS_TO_MATCH || lhsId.sample.equals(rhsId.sample);\r\n            final MatchResults results = FingerprintChecker.calculateMatchResults(lhsFingerprints.get(lhsId), rhsFingerprints.get(rhsId), GENOTYPING_ERROR_RATE, LOSS_OF_HET_RATE, false, CALCULATE_TUMOR_AWARE_RESULTS);\r\n            final FingerprintResult result = getMatchResults(expectedToMatch, results);\r\n            if (!OUTPUT_ERRORS_ONLY || result == FingerprintResult.INCONCLUSIVE || !result.isExpected()) {\r\n                metrics.add(getMatchDetails(result, results, lhsId, rhsId, type));\r\n            }\r\n            if (result != FingerprintResult.INCONCLUSIVE && !result.isExpected())\r\n                unexpectedResults++;\r\n            if (crosscheckMatrix != null) {\r\n                crosscheckMatrix[row][col] = results.getLOD();\r\n            }\r\n            if (++checksMade % logEvery == 0) {\r\n                log.info(\"Compared \" + checksMade + \" of \" + totalChecks);\r\n            }\r\n        }\r\n    }\r\n    return unexpectedResults;\r\n}"
}, {
	"Path": "picard.util.MathUtil.sum",
	"Comment": "returns the sum of the elements in the array starting with start and ending before stop.",
	"Method": "double[] sum(double[] lhs,double[] rhs,double sum,double[] arr,long sum,long[] arr,int start,int stop,double sum,double logValues){\r\n    long result = 0;\r\n    for (int i = start; i < stop; ++i) {\r\n        result += arr[i];\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "picard.sam.MergeBamAlignmentTest.testEarliestFragmentStrategyPaired",
	"Comment": "confirm that paired reads are rejected by primaryalignmentstrategy.earliestfragment.",
	"Method": "void testEarliestFragmentStrategyPaired(){\r\n    final File output = File.createTempFile(\"mergeTest\", \".sam\");\r\n    output.deleteOnExit();\r\n    final File unmappedSam = File.createTempFile(\"unmapped.\", \".sam\");\r\n    unmappedSam.deleteOnExit();\r\n    final SAMFileWriterFactory factory = new SAMFileWriterFactory();\r\n    final SAMFileHeader header = new SAMFileHeader();\r\n    header.setSortOrder(SAMFileHeader.SortOrder.queryname);\r\n    final String cigar = \"16M\";\r\n    final SAMRecord firstOfPair = new SAMRecord(header);\r\n    firstOfPair.setReadName(\"theRead\");\r\n    firstOfPair.setReadString(\"ACGTACGTACGTACGT\");\r\n    firstOfPair.setBaseQualityString(\"5555555555555555\");\r\n    firstOfPair.setReadUnmappedFlag(true);\r\n    firstOfPair.setReadPairedFlag(true);\r\n    firstOfPair.setFirstOfPairFlag(true);\r\n    final SAMRecord secondOfPair = new SAMRecord(header);\r\n    secondOfPair.setReadName(\"theRead\");\r\n    secondOfPair.setReadString(\"ACGTACGTACGTACGT\");\r\n    secondOfPair.setBaseQualityString(\"5555555555555555\");\r\n    secondOfPair.setReadUnmappedFlag(true);\r\n    secondOfPair.setReadPairedFlag(true);\r\n    secondOfPair.setSecondOfPairFlag(true);\r\n    SamPairUtil.setMateInfo(firstOfPair, secondOfPair);\r\n    final SAMFileWriter unmappedWriter = factory.makeSAMWriter(header, false, unmappedSam);\r\n    unmappedWriter.addAlignment(firstOfPair);\r\n    unmappedWriter.addAlignment(secondOfPair);\r\n    unmappedWriter.close();\r\n    final File alignedSam = File.createTempFile(\"aligned.\", \".sam\");\r\n    alignedSam.deleteOnExit();\r\n    header.setSequenceDictionary(SAMSequenceDictionaryExtractor.extractDictionary(sequenceDict2.toPath()));\r\n    final SAMFileWriter alignedWriter = factory.makeSAMWriter(header, false, alignedSam);\r\n    for (int i = 1; i <= 2; ++i) {\r\n        final SAMRecord firstOfPairAligned = new SAMRecord(header);\r\n        firstOfPairAligned.setReadName(firstOfPair.getReadName());\r\n        firstOfPairAligned.setReadBases(firstOfPair.getReadBases());\r\n        firstOfPairAligned.setBaseQualities(firstOfPair.getBaseQualities());\r\n        firstOfPairAligned.setReferenceName(\"chr1\");\r\n        firstOfPairAligned.setAlignmentStart(i);\r\n        firstOfPairAligned.setCigarString(cigar);\r\n        firstOfPairAligned.setMappingQuality(100);\r\n        firstOfPairAligned.setReadPairedFlag(true);\r\n        firstOfPairAligned.setFirstOfPairFlag(true);\r\n        firstOfPairAligned.setAttribute(SAMTag.HI.name(), i);\r\n        final SAMRecord secondOfPairAligned = new SAMRecord(header);\r\n        secondOfPairAligned.setReadName(secondOfPair.getReadName());\r\n        secondOfPairAligned.setReadBases(secondOfPair.getReadBases());\r\n        secondOfPairAligned.setBaseQualities(secondOfPair.getBaseQualities());\r\n        secondOfPairAligned.setReferenceName(\"chr1\");\r\n        secondOfPairAligned.setAlignmentStart(i + 10);\r\n        secondOfPairAligned.setCigarString(cigar);\r\n        secondOfPairAligned.setMappingQuality(100);\r\n        secondOfPairAligned.setReadPairedFlag(true);\r\n        secondOfPairAligned.setSecondOfPairFlag(true);\r\n        secondOfPairAligned.setAttribute(SAMTag.HI.name(), i);\r\n        SamPairUtil.setMateInfo(firstOfPairAligned, secondOfPairAligned);\r\n        alignedWriter.addAlignment(firstOfPairAligned);\r\n        alignedWriter.addAlignment(secondOfPairAligned);\r\n    }\r\n    alignedWriter.close();\r\n    doMergeAlignment(unmappedSam, Collections.singletonList(alignedSam), null, null, null, null, false, true, false, 1, \"0\", \"1.0\", \"align!\", \"myAligner\", true, fasta, output, SamPairUtil.PairOrientation.FR, MergeBamAlignment.PrimaryAlignmentStrategy.EarliestFragment, null, null, null, null);\r\n    Assert.fail(\"Exception was not thrown\");\r\n}"
}, {
	"Path": "prefuse.render.AbstractShapeRenderer.drawShape",
	"Comment": "draws the specified shape into the provided graphics context, usingstroke and fill color values from the specified visualitem. this methodcan be called by subclasses in custom rendering routines.",
	"Method": "void drawShape(Graphics2D g,VisualItem item,Shape shape){\r\n    GraphicsLib.paint(g, item, shape, getStroke(item), getRenderType(item));\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeProbabilitiesFromSequence.merge",
	"Comment": "merges information from another haplotype probabilities object for the same haplotype intothis object. useful for when probabilities need tobe merged to levels higher than theread group, e.g. the sample or individual.",
	"Method": "void merge(HaplotypeProbabilities other){\r\n    super.merge(other);\r\n    if (!this.getHaplotype().equals(other.getHaplotype())) {\r\n        throw new IllegalArgumentException(\"Mismatched haplotypes in call to HaplotypeProbabilities.merge(): \" + getHaplotype() + \", \" + other.getHaplotype());\r\n    }\r\n    if (!(other instanceof HaplotypeProbabilitiesFromSequence)) {\r\n        throw new IllegalArgumentException(\"Can only merge() HaplotypeProbabilities of same class: Tried to merge a \" + this.getClass().getName() + \" with a \" + other.getClass().getName() + \".\");\r\n    }\r\n    final HaplotypeProbabilitiesFromSequence o = (HaplotypeProbabilitiesFromSequence) other;\r\n    this.obsAllele1 += o.obsAllele1;\r\n    this.obsAllele2 += o.obsAllele2;\r\n    this.obsAlleleOther += o.obsAlleleOther;\r\n}"
}, {
	"Path": "net.pms.util.Version.compareTo",
	"Comment": "compares this version to the supplied version and returns\tan int which indicates whether this version is\tless than, equal to, or greater than the supplied version.",
	"Method": "int compareTo(Version other){\r\n    final int[] longerElements, shorterElements;\r\n    final int sign;\r\n    if (elements.length >= other.elements.length) {\r\n        longerElements = elements;\r\n        shorterElements = other.elements;\r\n        sign = 1;\r\n    } else {\r\n        longerElements = other.elements;\r\n        shorterElements = elements;\r\n        sign = -1;\r\n    }\r\n    for (int i = 0; i < longerElements.length; ++i) {\r\n        int val = i < shorterElements.length ? shorterElements[i] : 0;\r\n        if (longerElements[i] != val) {\r\n            return (longerElements[i] - val) * sign;\r\n        }\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "prefuse.render.AbstractShapeRenderer.getRenderType",
	"Comment": "returns a value indicating if a shape is drawn by its outline, by a fill, or both. the default is to draw both.",
	"Method": "int getRenderType(VisualItem item){\r\n    return m_renderType;\r\n}"
}, {
	"Path": "net.pms.PMS.checkProcessExistence",
	"Comment": "executes a new process and creates a fork that waits for its results.\ttodo extend explanation on where this is being used.",
	"Method": "boolean checkProcessExistence(String name,boolean error,File workDir,String params){\r\n    logger.debug(\"launching: \" + params[0]);\r\n    try {\r\n        ProcessBuilder pb = new ProcessBuilder(params);\r\n        if (workDir != null) {\r\n            pb.directory(workDir);\r\n        }\r\n        final Process process = pb.start();\r\n        OutputTextConsumer stderrConsumer = new OutputTextConsumer(process.getErrorStream(), false);\r\n        stderrConsumer.start();\r\n        OutputTextConsumer outConsumer = new OutputTextConsumer(process.getInputStream(), false);\r\n        outConsumer.start();\r\n        Runnable r = new Runnable() {\r\n            public void run() {\r\n                ProcessUtil.waitFor(process);\r\n            }\r\n        };\r\n        Thread checkThread = new Thread(r, \"PMS Checker\");\r\n        checkThread.start();\r\n        checkThread.join(60000);\r\n        checkThread.interrupt();\r\n        checkThread = null;\r\n        if (params[0].equals(\"vlc\") && stderrConsumer.getResults().get(0).startsWith(\"VLC\")) {\r\n            return true;\r\n        }\r\n        if (params[0].equals(\"ffmpeg\") && stderrConsumer.getResults().get(0).startsWith(\"FF\")) {\r\n            return true;\r\n        }\r\n        int exit = process.exitValue();\r\n        if (exit != 0) {\r\n            if (error) {\r\n                logger.info(\"[\" + exit + \"] Cannot launch \" + name + \" / Check the presence of \" + params[0] + \" ...\");\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    } catch (Exception e) {\r\n        if (error) {\r\n            logger.error(\"Cannot launch \" + name + \" / Check the presence of \" + params[0] + \" ...\", e);\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.pms.PMS.checkProcessExistence",
	"Comment": "executes a new process and creates a fork that waits for its results.\ttodo extend explanation on where this is being used.",
	"Method": "boolean checkProcessExistence(String name,boolean error,File workDir,String params){\r\n    ProcessUtil.waitFor(process);\r\n}"
}, {
	"Path": "com.google.gwt.sample.mobilewebapp.client.desktop.DesktopTaskEditView.setGlassPanelVisible",
	"Comment": "show or hide the glass panel used to lock the ui will the task loads.",
	"Method": "void setGlassPanelVisible(boolean visible){\r\n    if (glassPanel == null) {\r\n        glassPanel = new DecoratedPopupPanel(false, true);\r\n        glassPanel.setWidget(new Label(\"Loading...\"));\r\n    }\r\n    if (visible) {\r\n        glassPanel.center();\r\n    } else {\r\n        glassPanel.hide();\r\n    }\r\n}"
}, {
	"Path": "prefuse.render.LabelRenderer.setVerticalAlignment",
	"Comment": "set the vertical alignment of this node with respect to itsx, y coordinates.",
	"Method": "void setVerticalAlignment(int align){\r\n    m_yAlign = align;\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.setStartFont",
	"Comment": "set the starting font for the row. the font is used as the defaulttypeface for drawing text for this item.",
	"Method": "void setStartFont(int row,Font font){\r\n    set(row, VisualItem.STARTFONT, font);\r\n}"
}, {
	"Path": "picard.illumina.parser.readers.BclQualityEvaluationStrategy.assertMinimumQualities",
	"Comment": "reviews the qualities observed thus far and throws an exception if any are below the minimum quality threshold.",
	"Method": "void assertMinimumQualities(){\r\n    final Collection<String> errorTokens = new LinkedList<String>();\r\n    for (final Map.Entry<Byte, AtomicInteger> entry : this.qualityCountMap.entrySet()) {\r\n        if (generateRevisedQuality(entry.getKey()) < minimumRevisedQuality) {\r\n            errorTokens.add(String.format(\"quality %s observed %s times\", entry.getKey(), entry.getValue()));\r\n        }\r\n    }\r\n    if (!errorTokens.isEmpty()) {\r\n        throw new PicardException(String.format(\"Found BCL qualities that fell beneath minimum threshold of %s: %s.\", minimumRevisedQuality, CollectionUtil.join(errorTokens, \"; \")));\r\n    }\r\n}"
}, {
	"Path": "quickfix.Session.receivedLogout",
	"Comment": "predicate indicating whether a logout message has been received. this canbe used to determine if a session ended with an unexpected disconnect.",
	"Method": "boolean receivedLogout(){\r\n    return state.isLogoutReceived();\r\n}"
}, {
	"Path": "prefuse.Visualization.removeGroup",
	"Comment": "removes a data group from this visualization. if the group is a focusgroup, the group will simply be removed, and any subsequent attempts toretrieve the group will return null. if the group is a primary group, itwill be removed, and any members of the group will also be removedfrom any registered focus groups.",
	"Method": "boolean removeGroup(String group){\r\n    TupleSet ts = getFocusGroup(group);\r\n    if (ts != null) {\r\n        for (Iterator items = ts.tuples(ValidatedPredicate.TRUE); items.hasNext(); ) {\r\n            ((VisualItem) items.next()).setValidated(false);\r\n        }\r\n        ts.clear();\r\n        m_focus.remove(group);\r\n        return true;\r\n    }\r\n    ts = getVisualGroup(group);\r\n    if (ts == null) {\r\n        return false;\r\n    }\r\n    TupleSet[] focus = new TupleSet[m_focus.size()];\r\n    m_focus.values().toArray(focus);\r\n    for (Iterator items = ts.tuples(); items.hasNext(); ) {\r\n        VisualItem item = (VisualItem) items.next();\r\n        for (int j = 0; j < focus.length; ++j) {\r\n            focus[j].removeTuple(item);\r\n        }\r\n        item.setValidated(false);\r\n    }\r\n    if (ts instanceof CompositeTupleSet) {\r\n        CompositeTupleSet cts = (CompositeTupleSet) ts;\r\n        for (Iterator names = cts.setNames(); names.hasNext(); ) {\r\n            String name = (String) names.next();\r\n            String subgroup = PrefuseLib.getGroupName(group, name);\r\n            m_visual.remove(subgroup);\r\n            m_source.remove(subgroup);\r\n        }\r\n    }\r\n    m_visual.remove(group);\r\n    m_source.remove(group);\r\n    return true;\r\n}"
}, {
	"Path": "prefuse.Visualization.getFocusGroup",
	"Comment": "retrieve the focus data group of the given group name. only secondary,or focus, groups will be considered.",
	"Method": "TupleSet getFocusGroup(String group){\r\n    return (TupleSet) m_focus.get(group);\r\n}"
}, {
	"Path": "prefuse.data.tuple.CompositeTupleSet.removeTuple",
	"Comment": "removes the tuple from its source set if that source set is containedwithin this composite.",
	"Method": "boolean removeTuple(Tuple t){\r\n    Table table = t.getTable();\r\n    if (m_sets.contains(table)) {\r\n        return table.removeTuple(t);\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.RadialTreeLayout.setAutoScale",
	"Comment": "set whether or not the layout should automatically scale itselfto fit the layout bounds.",
	"Method": "void setAutoScale(boolean s){\r\n    m_autoScale = s;\r\n}"
}, {
	"Path": "com.restfb.DefaultJsonMapper.facebookFieldNamesWithMultipleMappings",
	"Comment": "finds any facebook json fields that are mapped to more than 1 java field.",
	"Method": "Set<String> facebookFieldNamesWithMultipleMappings(List<FieldWithAnnotation<Facebook>> fieldsWithAnnotation){\r\n    Map<String, Integer> facebookFieldsNamesWithOccurrenceCount = new HashMap();\r\n    Set<String> facebookFieldNamesWithMultipleMappings = new HashSet();\r\n    for (FieldWithAnnotation<Facebook> fieldWithAnnotation : fieldsWithAnnotation) {\r\n        String fieldName = getFacebookFieldName(fieldWithAnnotation);\r\n        int occurrenceCount = facebookFieldsNamesWithOccurrenceCount.containsKey(fieldName) ? facebookFieldsNamesWithOccurrenceCount.get(fieldName) : 0;\r\n        facebookFieldsNamesWithOccurrenceCount.put(fieldName, occurrenceCount + 1);\r\n    }\r\n    for (Entry<String, Integer> entry : facebookFieldsNamesWithOccurrenceCount.entrySet()) {\r\n        if (entry.getValue() > 1) {\r\n            facebookFieldNamesWithMultipleMappings.add(entry.getKey());\r\n        }\r\n    }\r\n    return unmodifiableSet(facebookFieldNamesWithMultipleMappings);\r\n}"
}, {
	"Path": "net.paoding.rose.jade.context.spring.JadeComponentProvider.isCandidateComponent",
	"Comment": "determine whether the given class does not match any exclude filterand does match at least one include filter.",
	"Method": "boolean isCandidateComponent(MetadataReader metadataReader){\r\n    for (TypeFilter tf : this.excludeFilters) {\r\n        if (tf.match(metadataReader, this.metadataReaderFactory)) {\r\n            return false;\r\n        }\r\n    }\r\n    for (TypeFilter tf : this.includeFilters) {\r\n        if (tf.match(metadataReader, this.metadataReaderFactory)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.pms.configuration.RendererConfiguration.resetAddressAssociation",
	"Comment": "reset gathered information on ip address associations with renderers.",
	"Method": "void resetAddressAssociation(){\r\n    addressAssociation = new HashMap<InetAddress, RendererConfiguration>();\r\n}"
}, {
	"Path": "prefuse.data.Table.canGetDate",
	"Comment": "check if the given data field can return primitive datevalues.",
	"Method": "boolean canGetDate(String field){\r\n    Column col = getColumn(field);\r\n    return (col == null ? false : col.canGetDate());\r\n}"
}, {
	"Path": "net.paoding.rose.jade.context.spring.JadeComponentProvider.setResourceLoader",
	"Comment": "set the resourceloader to use for resource locations. this willtypically be a resourcepatternresolver implementation.default is pathmatchingresourcepatternresolver, also capable ofresource pattern resolving through the resourcepatternresolverinterface.",
	"Method": "void setResourceLoader(ResourceLoader resourceLoader){\r\n    this.resourcePatternResolver = ResourcePatternUtils.getResourcePatternResolver(resourceLoader);\r\n    this.metadataReaderFactory = new CachingMetadataReaderFactory(resourceLoader);\r\n}"
}, {
	"Path": "picard.fingerprint.FingerprintUtils.writeFingerPrint",
	"Comment": "a function that takes a fingerprint and writes it as a vcf to a file",
	"Method": "void writeFingerPrint(Fingerprint fingerprint,File outputFile,File referenceSequenceFileName,String sample,String source){\r\n    try (final ReferenceSequenceFile ref = ReferenceSequenceFileFactory.getReferenceSequenceFile(referenceSequenceFileName);\r\n        final VariantContextWriter variantContextWriter = getVariantContextWriter(outputFile, referenceSequenceFileName, sample, source, ref)) {\r\n        createVCSetFromFingerprint(fingerprint, ref, sample).forEach(variantContextWriter::add);\r\n    }\r\n}"
}, {
	"Path": "quickfix.DataDictionary.copyGroups",
	"Comment": "copy groups including their data dictionaries and validation settings",
	"Method": "void copyGroups(Map<IntStringPair, GroupInfo> lhs,Map<IntStringPair, GroupInfo> rhs){\r\n    lhs.clear();\r\n    for (Map.Entry<IntStringPair, GroupInfo> entry : rhs.entrySet()) {\r\n        GroupInfo value = new GroupInfo(entry.getValue().getDelimiterField(), new DataDictionary(entry.getValue().getDataDictionary()));\r\n        lhs.put(entry.getKey(), value);\r\n    }\r\n}"
}, {
	"Path": "picard.illumina.parser.IlluminaDataProviderFactory.setApplyEamssFiltering",
	"Comment": "sets whether or not eamss filtering will be applied if parsing bcl files for bases and quality scores.",
	"Method": "void setApplyEamssFiltering(boolean applyEamssFiltering){\r\n    this.applyEamssFiltering = applyEamssFiltering;\r\n}"
}, {
	"Path": "prefuse.util.ColorLib.getHotPalette",
	"Comment": "returns a color map of default size that moves from black tored to yellow to white.",
	"Method": "int[] getHotPalette(int size,int[] getHotPalette){\r\n    return getHotPalette(DEFAULT_MAP_SIZE);\r\n}"
}, {
	"Path": "picard.cmdline.PicardCommandLine.main",
	"Comment": "override this if you want to include different java packages to search for classes that extend commandlineprogram.",
	"Method": "void main(String[] args){\r\n    System.exit(new PicardCommandLine().instanceMain(args, getPackageList(), COMMAND_LINE_NAME));\r\n}"
}, {
	"Path": "picard.util.RExecutor.executeFromFile",
	"Comment": "executes the given r script that is stored in a file by a call to rscript.blocks until the r script is complete.",
	"Method": "int executeFromFile(File scriptFile,String arguments){\r\n    final String[] command = new String[arguments.length + 2];\r\n    command[0] = R_EXE;\r\n    command[1] = scriptFile.getAbsolutePath();\r\n    System.arraycopy(arguments, 0, command, 2, arguments.length);\r\n    LOG.info(String.format(\"Executing R script via command: %s\", CollectionUtil.join(Arrays.asList(command), \" \")));\r\n    return ProcessExecutor.execute(command);\r\n}"
}, {
	"Path": "com.restfb.json.JsonObject.readFrom",
	"Comment": "reads a json object from the given reader.characters are read in chunks and buffered internally, therefore wrapping an existing reader in an additionalbufferedreader does not improve reading performance.",
	"Method": "JsonObject readFrom(Reader reader,JsonObject readFrom,String string){\r\n    return JsonValue.readFrom(string).asObject();\r\n}"
}, {
	"Path": "quickfix.SessionState.setResetRangeFromLastExpectedLogonNextSeqNumLogon",
	"Comment": "no actual resend request has occurred but at logon we populated tag 789 so that the other side knows weare missing messages without an explicit resend request and should immediately reply with the missingmessages.this is expected to be called only in the scenario where target is too high on logon and tag 789 is supported.",
	"Method": "void setResetRangeFromLastExpectedLogonNextSeqNumLogon(){\r\n    synchronized (lock) {\r\n        setResendRange(getLastExpectedLogonNextSeqNum(), 0);\r\n        setLastExpectedLogonNextSeqNum(0);\r\n    }\r\n}"
}, {
	"Path": "prefuse.Display.removeItemBoundsListener",
	"Comment": "remove an itemboundslistener to receive notifications when the boundsoccupied by the visualitems in this display change.",
	"Method": "void removeItemBoundsListener(ItemBoundsListener ibl){\r\n    m_bounders.remove(ibl);\r\n}"
}, {
	"Path": "net.pms.encoders.Player.setAudioAndSubs",
	"Comment": "that handle just one facet of its functionality. it also needs to be decoupled from mencoder",
	"Method": "void setAudioAndSubs(String fileName,DLNAMediaInfo media,OutputParams params,PmsConfiguration configuration){\r\n    if (params.aid == null && media != null) {\r\n        StringTokenizer st = new StringTokenizer(configuration.getAudioLanguages(), \",\");\r\n        while (st != null && st.hasMoreTokens()) {\r\n            String lang = st.nextToken();\r\n            lang = lang.trim();\r\n            logger.trace(\"Looking for an audio track with lang: \" + lang);\r\n            for (DLNAMediaAudio audio : media.getAudioTracksList()) {\r\n                if (audio.matchCode(lang)) {\r\n                    params.aid = audio;\r\n                    logger.trace(\"Matched audio track: \" + audio);\r\n                    st = null;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (params.aid == null && media.getAudioTracksList().size() > 0) {\r\n        for (DLNAMediaAudio audio : media.getAudioTracksList()) {\r\n            if (audio.isDTS()) {\r\n                params.aid = audio;\r\n                logger.trace(\"Found priority audio track with DTS: \" + audio);\r\n                break;\r\n            }\r\n        }\r\n        if (params.aid == null) {\r\n            params.aid = media.getAudioTracksList().get(0);\r\n            logger.trace(\"Chose a default audio track: \" + params.aid);\r\n        }\r\n    }\r\n    String currentLang = null;\r\n    DLNAMediaSubtitle matchedSub = null;\r\n    if (params.aid != null) {\r\n        currentLang = params.aid.getLang();\r\n    }\r\n    if (params.sid != null && params.sid.getId() == -1) {\r\n        logger.trace(\"Don't want subtitles!\");\r\n        params.sid = null;\r\n        return;\r\n    }\r\n    StringTokenizer st1 = new StringTokenizer(configuration.getAudioSubLanguages(), \";\");\r\n    while (st1.hasMoreTokens()) {\r\n        String pair = st1.nextToken();\r\n        if (pair.contains(\",\")) {\r\n            String audio = pair.substring(0, pair.indexOf(\",\"));\r\n            String sub = pair.substring(pair.indexOf(\",\") + 1);\r\n            audio = audio.trim();\r\n            sub = sub.trim();\r\n            logger.trace(\"Searching for a match for: \" + currentLang + \" with \" + audio + \" and \" + sub);\r\n            if (Iso639.isCodesMatching(audio, currentLang) || (currentLang != null && audio.equals(\"*\"))) {\r\n                if (sub.equals(\"off\")) {\r\n                    matchedSub = new DLNAMediaSubtitle();\r\n                    matchedSub.setLang(\"off\");\r\n                } else {\r\n                    for (DLNAMediaSubtitle present_sub : media.getSubtitleTracksList()) {\r\n                        if (present_sub.matchCode(sub) || sub.equals(\"*\")) {\r\n                            matchedSub = present_sub;\r\n                            logger.trace(\"Found a match: \" + matchedSub);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                if (matchedSub != null) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (matchedSub != null && params.sid == null) {\r\n        if (configuration.isDisableSubtitles() || (matchedSub.getLang() != null && matchedSub.getLang().equals(\"off\"))) {\r\n            logger.trace(\" Disabled the subtitles: \" + matchedSub);\r\n        } else {\r\n            params.sid = matchedSub;\r\n        }\r\n    }\r\n    if (!configuration.isDisableSubtitles() && params.sid == null && media != null) {\r\n        File video = new File(fileName);\r\n        FileUtil.isSubtitlesExists(video, media, false);\r\n        if (configuration.isAutoloadExternalSubtitles()) {\r\n            boolean forcedSubsFound = false;\r\n            for (DLNAMediaSubtitle sub : media.getSubtitleTracksList()) {\r\n                if (matchedSub != null && matchedSub.getLang() != null && matchedSub.getLang().equals(\"off\")) {\r\n                    StringTokenizer st = new StringTokenizer(configuration.getForcedSubtitleTags(), \",\");\r\n                    while (st != null && sub.getFlavor() != null && st.hasMoreTokens()) {\r\n                        String forcedTags = st.nextToken();\r\n                        forcedTags = forcedTags.trim();\r\n                        if (sub.getFlavor().toLowerCase().indexOf(forcedTags) > -1 && Iso639.isCodesMatching(sub.getLang(), configuration.getForcedSubtitleLanguage())) {\r\n                            logger.trace(\"Forcing preferred subtitles : \" + sub.getLang() + \"/\" + sub.getFlavor());\r\n                            logger.trace(\"Forced subtitles track : \" + sub);\r\n                            if (sub.getExternalFile() != null) {\r\n                                logger.trace(\"Found external forced file : \" + sub.getExternalFile().getAbsolutePath());\r\n                            }\r\n                            params.sid = sub;\r\n                            forcedSubsFound = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (forcedSubsFound == true) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    logger.trace(\"Found subtitles track: \" + sub);\r\n                    if (sub.getExternalFile() != null) {\r\n                        logger.trace(\"Found external file: \" + sub.getExternalFile().getAbsolutePath());\r\n                        params.sid = sub;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (matchedSub != null && matchedSub.getLang() != null && matchedSub.getLang().equals(\"off\")) {\r\n            return;\r\n        }\r\n        if (params.sid == null) {\r\n            StringTokenizer st = new StringTokenizer(configuration.getSubtitlesLanguages(), \",\");\r\n            while (st != null && st.hasMoreTokens()) {\r\n                String lang = st.nextToken();\r\n                lang = lang.trim();\r\n                logger.trace(\"Looking for a subtitle track with lang: \" + lang);\r\n                for (DLNAMediaSubtitle sub : media.getSubtitleTracksList()) {\r\n                    if (sub.matchCode(lang)) {\r\n                        params.sid = sub;\r\n                        logger.trace(\"Matched sub track: \" + params.sid);\r\n                        st = null;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.pms.util.NaturalComparator.getNaturalComparator",
	"Comment": "returns a comparator that compares contained numbers based on their numeric values and compares other partsusing the given collator.",
	"Method": "Comparator<String> getNaturalComparator(Comparator<String> getNaturalComparator,Collator collator){\r\n    if (collator == null) {\r\n        throw new NullPointerException(\"collator must not be null\");\r\n    }\r\n    return new Comparator<String>() {\r\n        public int compare(String o1, String o2) {\r\n            return compareNatural(collator, o1, o2);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "net.pms.util.NaturalComparator.getNaturalComparator",
	"Comment": "returns a comparator that compares contained numbers based on their numeric values and compares other partsusing the given collator.",
	"Method": "Comparator<String> getNaturalComparator(Comparator<String> getNaturalComparator,Collator collator){\r\n    return compareNatural(collator, o1, o2);\r\n}"
}, {
	"Path": "net.paoding.rose.web.paramresolver.ServletRequestDataBinder.getInternalBindingResult",
	"Comment": "return the internal bindingresult held by this databinder, asabstractpropertybindingresult.",
	"Method": "AbstractPropertyBindingResult getInternalBindingResult(){\r\n    AbstractPropertyBindingResult bindingResult = super.getInternalBindingResult();\r\n    PropertyEditorRegistry registry = bindingResult.getPropertyEditorRegistry();\r\n    registry.registerCustomEditor(Date.class, new DateEditor(Date.class));\r\n    registry.registerCustomEditor(java.sql.Date.class, new DateEditor(java.sql.Date.class));\r\n    registry.registerCustomEditor(java.sql.Time.class, new DateEditor(java.sql.Time.class));\r\n    registry.registerCustomEditor(java.sql.Timestamp.class, new DateEditor(java.sql.Timestamp.class));\r\n    return bindingResult;\r\n}"
}, {
	"Path": "picard.sam.MergeBamAlignmentTest.testFragmentMultiHitWithFiltering",
	"Comment": "read a single fragment read from a file, and create one or more aligned records for the read pair based onthe lists, merge with the original read, and assert expected results.",
	"Method": "void testFragmentMultiHitWithFiltering(String description,List<HitSpec> hitSpecs,Integer expectedPrimaryHitIndex,int expectedNumReads,int expectedPrimaryMapq){\r\n    final File unmappedSam = new File(TEST_DATA_DIR, \"multihit.filter.fragment.unmapped.sam\");\r\n    final SAMRecordIterator unmappedSamFileIterator = SamReaderFactory.makeDefault().open(unmappedSam).iterator();\r\n    final SAMRecord unmappedRec = unmappedSamFileIterator.next();\r\n    unmappedSamFileIterator.close();\r\n    final File alignedSam = File.createTempFile(\"aligned.\", \".sam\");\r\n    alignedSam.deleteOnExit();\r\n    final SAMFileHeader alignedHeader = new SAMFileHeader();\r\n    alignedHeader.setSortOrder(SAMFileHeader.SortOrder.queryname);\r\n    alignedHeader.setSequenceDictionary(SamReaderFactory.makeDefault().getFileHeader(sequenceDict).getSequenceDictionary());\r\n    final SAMFileWriter alignedWriter = new SAMFileWriterFactory().makeSAMWriter(alignedHeader, true, alignedSam);\r\n    for (int i = 0; i < hitSpecs.size(); ++i) {\r\n        final HitSpec hitSpec = hitSpecs.get(i);\r\n        final SAMRecord mappedRec = makeRead(alignedHeader, unmappedRec, hitSpec, i);\r\n        if (mappedRec != null) {\r\n            alignedWriter.addAlignment(mappedRec);\r\n        }\r\n    }\r\n    alignedWriter.close();\r\n    final File mergedSam = File.createTempFile(\"merged.\", \".sam\");\r\n    mergedSam.deleteOnExit();\r\n    doMergeAlignment(unmappedSam, Collections.singletonList(alignedSam), null, null, null, null, false, true, false, 1, \"0\", \"1.0\", \"align!\", \"myAligner\", false, fasta, mergedSam, null, null, null, null, null, null);\r\n    assertSamValid(mergedSam);\r\n    final SamReader mergedReader = SamReaderFactory.makeDefault().open(mergedSam);\r\n    int numReads = 0;\r\n    Integer primaryHitIndex = null;\r\n    int primaryMapq = 0;\r\n    for (final SAMRecord rec : mergedReader) {\r\n        ++numReads;\r\n        if (!rec.getNotPrimaryAlignmentFlag() && !rec.getReadUnmappedFlag()) {\r\n            final Integer hitIndex = rec.getIntegerAttribute(SAMTag.HI.name());\r\n            final int newHitIndex = (hitIndex == null ? -1 : hitIndex);\r\n            Assert.assertNull(primaryHitIndex);\r\n            primaryHitIndex = newHitIndex;\r\n            primaryMapq = rec.getMappingQuality();\r\n        }\r\n    }\r\n    Assert.assertEquals(numReads, expectedNumReads);\r\n    Assert.assertEquals(primaryHitIndex, expectedPrimaryHitIndex);\r\n    Assert.assertEquals(primaryMapq, expectedPrimaryMapq);\r\n}"
}, {
	"Path": "net.pms.newgui.RestrictedFileSystemView.getSystemTypeDescription",
	"Comment": "type description for a file, directory, or folder as it would be displayed in a system file browser.",
	"Method": "String getSystemTypeDescription(File f){\r\n    return null;\r\n}"
}, {
	"Path": "picard.illumina.ExtractIlluminaBarcodes.getBarcodeFile",
	"Comment": "create a barcode filename corresponding to the given tile qseq file.",
	"Method": "File getBarcodeFile(int tile){\r\n    return new File(OUTPUT_DIR, \"s_\" + LANE + \"_\" + tileNumberFormatter.format(tile) + \"_barcode.txt\" + (COMPRESS_OUTPUTS ? \".gz\" : \"\"));\r\n}"
}, {
	"Path": "prefuse.data.parser.ParserFactory.getParser",
	"Comment": "analyzes a column of the given array of string values to determine an acceptable parser data type.",
	"Method": "DataParser getParser(DataParser getParser,Class type,DataParser getParser,String[] data,int startRow,DataParser getParser,String[][] data,int col,int startRow){\r\n    if (data == null || data.length == 0)\r\n        return null;\r\n    int nrows = data.length;\r\n    this.reset();\r\n    for (int row = startRow; row < nrows; ++row) {\r\n        this.sample(data[row][col]);\r\n    }\r\n    DataParser parser = getParser();\r\n    return parser;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setRendererForceDefault",
	"Comment": "set to true when pms should not try to guess connecting renderers\tand instead force picking the defined fallback renderer. set to false\tto make pms attempt to recognize connecting renderers by their headers.",
	"Method": "void setRendererForceDefault(boolean value){\r\n    configuration.setProperty(KEY_RENDERER_FORCE_DEFAULT, value);\r\n}"
}, {
	"Path": "picard.analysis.CollectJumpingLibraryMetrics.doWork",
	"Comment": "calculates the detailed statistics about the jumping library and then generates the results.",
	"Method": "int doWork(){\r\n    for (File f : INPUT) {\r\n        IOUtil.assertFileIsReadable(f);\r\n    }\r\n    IOUtil.assertFileIsWritable(OUTPUT);\r\n    Histogram<Integer> innieHistogram = new Histogram<Integer>();\r\n    Histogram<Integer> outieHistogram = new Histogram<Integer>();\r\n    int fragments = 0;\r\n    int innies = 0;\r\n    int outies = 0;\r\n    int innieDupes = 0;\r\n    int outieDupes = 0;\r\n    int crossChromPairs = 0;\r\n    int superSized = 0;\r\n    int tandemPairs = 0;\r\n    double chimeraSizeMinimum = Math.max(getOutieMode(), (double) CHIMERA_KB_MIN);\r\n    for (File f : INPUT) {\r\n        SamReader reader = SamReaderFactory.makeDefault().open(f);\r\n        if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.coordinate) {\r\n            throw new PicardException(\"SAM file must \" + f.getName() + \" must be sorted in coordintate order\");\r\n        }\r\n        for (SAMRecord sam : reader) {\r\n            if (!sam.getFirstOfPairFlag()) {\r\n                continue;\r\n            }\r\n            if (sam.getReadUnmappedFlag()) {\r\n                if (!sam.getMateUnmappedFlag()) {\r\n                    fragments++;\r\n                    continue;\r\n                }\r\n                if (sam.getReferenceIndex() == SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX) {\r\n                    break;\r\n                }\r\n                continue;\r\n            }\r\n            if (sam.getMateUnmappedFlag()) {\r\n                fragments++;\r\n                continue;\r\n            }\r\n            if ((sam.getAttribute(SAMTag.MQ.name()) != null && sam.getIntegerAttribute(SAMTag.MQ.name()) < MINIMUM_MAPPING_QUALITY) || sam.getMappingQuality() < MINIMUM_MAPPING_QUALITY) {\r\n                continue;\r\n            }\r\n            final int absInsertSize = Math.abs(sam.getInferredInsertSize());\r\n            if (absInsertSize > chimeraSizeMinimum) {\r\n                superSized++;\r\n            } else if (sam.getMateNegativeStrandFlag() == sam.getReadNegativeStrandFlag()) {\r\n                tandemPairs++;\r\n            } else if (!sam.getMateReferenceIndex().equals(sam.getReferenceIndex())) {\r\n                crossChromPairs++;\r\n            } else {\r\n                final PairOrientation pairOrientation = SamPairUtil.getPairOrientation(sam);\r\n                if (pairOrientation == PairOrientation.RF) {\r\n                    outieHistogram.increment(absInsertSize);\r\n                    outies++;\r\n                    if (sam.getDuplicateReadFlag()) {\r\n                        outieDupes++;\r\n                    }\r\n                } else if (pairOrientation == PairOrientation.FR) {\r\n                    innieHistogram.increment(absInsertSize);\r\n                    innies++;\r\n                    if (sam.getDuplicateReadFlag()) {\r\n                        innieDupes++;\r\n                    }\r\n                } else {\r\n                    throw new IllegalStateException(\"This should never happen\");\r\n                }\r\n            }\r\n        }\r\n        CloserUtil.close(reader);\r\n    }\r\n    MetricsFile<JumpingLibraryMetrics, Integer> metricsFile = getMetricsFile();\r\n    JumpingLibraryMetrics metrics = new JumpingLibraryMetrics();\r\n    metrics.JUMP_PAIRS = outies;\r\n    metrics.JUMP_DUPLICATE_PAIRS = outieDupes;\r\n    metrics.JUMP_DUPLICATE_PCT = outies != 0 ? outieDupes / (double) outies : 0;\r\n    metrics.JUMP_LIBRARY_SIZE = (outies > 0 && outieDupes > 0) ? DuplicationMetrics.estimateLibrarySize(outies, outies - outieDupes) : 0;\r\n    outieHistogram.trimByTailLimit(TAIL_LIMIT);\r\n    metrics.JUMP_MEAN_INSERT_SIZE = outieHistogram.getMean();\r\n    metrics.JUMP_STDEV_INSERT_SIZE = outieHistogram.getStandardDeviation();\r\n    metrics.NONJUMP_PAIRS = innies;\r\n    metrics.NONJUMP_DUPLICATE_PAIRS = innieDupes;\r\n    metrics.NONJUMP_DUPLICATE_PCT = innies != 0 ? innieDupes / (double) innies : 0;\r\n    metrics.NONJUMP_LIBRARY_SIZE = (innies > 0 && innieDupes > 0) ? DuplicationMetrics.estimateLibrarySize(innies, innies - innieDupes) : 0;\r\n    innieHistogram.trimByTailLimit(TAIL_LIMIT);\r\n    metrics.NONJUMP_MEAN_INSERT_SIZE = innieHistogram.getMean();\r\n    metrics.NONJUMP_STDEV_INSERT_SIZE = innieHistogram.getStandardDeviation();\r\n    metrics.CHIMERIC_PAIRS = crossChromPairs + superSized + tandemPairs;\r\n    metrics.FRAGMENTS = fragments;\r\n    double totalPairs = outies + innies + metrics.CHIMERIC_PAIRS;\r\n    metrics.PCT_JUMPS = totalPairs != 0 ? outies / totalPairs : 0;\r\n    metrics.PCT_NONJUMPS = totalPairs != 0 ? innies / totalPairs : 0;\r\n    metrics.PCT_CHIMERAS = totalPairs != 0 ? metrics.CHIMERIC_PAIRS / totalPairs : 0;\r\n    metricsFile.addMetric(metrics);\r\n    metricsFile.write(OUTPUT);\r\n    return 0;\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeBlock.getDiploidHaplotype",
	"Comment": "gets the diploid haplotype for this haplotype block given the provided snp and snpgenotype.",
	"Method": "DiploidHaplotype getDiploidHaplotype(Snp snp,DiploidGenotype gt){\r\n    if (!contains(snp))\r\n        throw new IllegalArgumentException(\"Snp is not part of haplotype \" + snp);\r\n    return DiploidHaplotype.values()[snp.indexOf(gt)];\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.setStroke",
	"Comment": "set the current stroke used to draw lines and shape outlines.",
	"Method": "void setStroke(int row,BasicStroke stroke){\r\n    set(row, VisualItem.STROKE, stroke);\r\n}"
}, {
	"Path": "prefuse.data.CascadedTable.getRowFilter",
	"Comment": "gets ths predicate determining which rows of the parenttable are included in this one.",
	"Method": "Predicate getRowFilter(){\r\n    return m_rowFilter;\r\n}"
}, {
	"Path": "peergos.shared.util.Futures.reduceAll",
	"Comment": "reduce a set of input values against an identity where the composition step is asynchronous",
	"Method": "CompletableFuture<T> reduceAll(Collection<V> input,T identity,BiFunction<T, V, CompletableFuture<T>> composer,BiFunction<T, T, T> combiner){\r\n    CompletableFuture<T> identityFut = CompletableFuture.completedFuture(identity);\r\n    return input.stream().reduce(identityFut, (a, b) -> a.thenCompose(res -> composer.apply(res, b)), (a, b) -> a.thenCompose(x -> b.thenApply(y -> combiner.apply(x, y))));\r\n}"
}, {
	"Path": "picard.cmdline.PicardCommandLine.printUnknown",
	"Comment": "when a command does not match any known command, searches for similar commands, using the same method as git",
	"Method": "void printUnknown(Set<Class<?>> classes,String command){\r\n    final Map<Class, Integer> distances = new HashMap<Class, Integer>();\r\n    int bestDistance = Integer.MAX_VALUE;\r\n    int bestN = 0;\r\n    for (final Class clazz : classes) {\r\n        final String name = clazz.getSimpleName();\r\n        final int distance;\r\n        if (name.equals(command)) {\r\n            throw new RuntimeException(\"Command matches: \" + command);\r\n        }\r\n        if (name.startsWith(command) || (MINIMUM_SUBSTRING_LENGTH <= command.length() && name.contains(command))) {\r\n            distance = 0;\r\n        } else {\r\n            distance = StringUtil.levenshteinDistance(command, name, 0, 2, 1, 4);\r\n        }\r\n        distances.put(clazz, distance);\r\n        if (distance < bestDistance) {\r\n            bestDistance = distance;\r\n            bestN = 1;\r\n        } else if (distance == bestDistance) {\r\n            bestN++;\r\n        }\r\n    }\r\n    if (0 == bestDistance && bestN == classes.size()) {\r\n        bestDistance = HELP_SIMILARITY_FLOOR + 1;\r\n    }\r\n    System.err.println(String.format(\"'%s' is not a valid command. See PicardCommandLine -h for more information.\", command));\r\n    if (bestDistance < HELP_SIMILARITY_FLOOR) {\r\n        System.err.println(String.format(\"Did you mean %s?\", (bestN < 2) ? \"this\" : \"one of these\"));\r\n        for (final Class clazz : classes) {\r\n            if (bestDistance == distances.get(clazz)) {\r\n                System.err.println(String.format(\"        %s\", clazz.getSimpleName()));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "picard.vcf.GenotypeConcordanceCounts.Ppv",
	"Comment": "returns the ppv defined by the scheme across the subset of call states.",
	"Method": "double Ppv(GenotypeConcordanceScheme scheme,CallState[] callStateList){\r\n    double numerator = 0.0;\r\n    double denominator = 0.0;\r\n    scheme.validateScheme();\r\n    for (final CallState callState : callStateList) {\r\n        for (final TruthState truthState : TruthState.values()) {\r\n            final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState);\r\n            final long count = getCount(truthAndCallStates);\r\n            for (final ContingencyState contingencyState : scheme.getConcordanceStateArray(truthAndCallStates)) {\r\n                if (ContingencyState.TP == contingencyState) {\r\n                    numerator += count;\r\n                    denominator += count;\r\n                } else if (ContingencyState.FP == contingencyState) {\r\n                    denominator += count;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return (numerator / denominator);\r\n}"
}, {
	"Path": "quickfix.DataDictionary.isGroup",
	"Comment": "predicate for determining if a field is a group count field for a messagetype.",
	"Method": "boolean isGroup(String msg,int field){\r\n    return groups.containsKey(new IntStringPair(field, msg));\r\n}"
}, {
	"Path": "picard.vcf.GenotypeConcordance.outputDetailMetricsFile",
	"Comment": "outputs the detailed statistics tables for snp and indel match categories.",
	"Method": "void outputDetailMetricsFile(VariantContext.Type variantType,MetricsFile<GenotypeConcordanceDetailMetrics, ?> genotypeConcordanceDetailMetricsFile,GenotypeConcordanceCounts counter,String truthSampleName,String callSampleName,boolean missingSitesHomRef,boolean outputAllRows){\r\n    final GenotypeConcordanceSchemeFactory schemeFactory = new GenotypeConcordanceSchemeFactory();\r\n    final GenotypeConcordanceScheme scheme = schemeFactory.getScheme(missingSitesHomRef);\r\n    scheme.validateScheme();\r\n    for (final TruthState truthState : TruthState.values()) {\r\n        for (final CallState callState : CallState.values()) {\r\n            final long count = counter.getCount(truthState, callState);\r\n            final String contingencyValues = scheme.getContingencyStateString(truthState, callState);\r\n            if (count > 0 || outputAllRows) {\r\n                final GenotypeConcordanceDetailMetrics detailMetrics = new GenotypeConcordanceDetailMetrics();\r\n                detailMetrics.VARIANT_TYPE = variantType;\r\n                detailMetrics.TRUTH_SAMPLE = truthSampleName;\r\n                detailMetrics.CALL_SAMPLE = callSampleName;\r\n                detailMetrics.TRUTH_STATE = truthState;\r\n                detailMetrics.CALL_STATE = callState;\r\n                detailMetrics.COUNT = count;\r\n                detailMetrics.CONTINGENCY_VALUES = contingencyValues;\r\n                genotypeConcordanceDetailMetricsFile.addMetric(detailMetrics);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "peergos.shared.scrypt.com.lambdaworks.codec.Base64.decode",
	"Comment": "decode base64 chars to bytes using the supplied decode table and paddingcharacter.",
	"Method": "byte[] decode(char[] chars,byte[] decode,char[] src,int[] table,char pad){\r\n    int len = src.length;\r\n    if (len == 0)\r\n        return new byte[0];\r\n    int padCount = (src[len - 1] == pad ? (src[len - 2] == pad ? 2 : 1) : 0);\r\n    int bytes = (len * 6 >> 3) - padCount;\r\n    int blocks = (bytes / 3) * 3;\r\n    byte[] dst = new byte[bytes];\r\n    int si = 0, di = 0;\r\n    while (di < blocks) {\r\n        int n = table[src[si++]] << 18 | table[src[si++]] << 12 | table[src[si++]] << 6 | table[src[si++]];\r\n        dst[di++] = (byte) (n >> 16);\r\n        dst[di++] = (byte) (n >> 8);\r\n        dst[di++] = (byte) n;\r\n    }\r\n    if (di < bytes) {\r\n        int n = 0;\r\n        switch(len - si) {\r\n            case 4:\r\n                n |= table[src[si + 3]];\r\n            case 3:\r\n                n |= table[src[si + 2]] << 6;\r\n            case 2:\r\n                n |= table[src[si + 1]] << 12;\r\n            case 1:\r\n                n |= table[src[si]] << 18;\r\n        }\r\n        for (int r = 16; di < bytes; r -= 8) {\r\n            dst[di++] = (byte) (n >> r);\r\n        }\r\n    }\r\n    return dst;\r\n}"
}, {
	"Path": "prefuse.action.layout.AxisLabelLayout.setNumberFormat",
	"Comment": "set the formatter used to format labels for numerical values.",
	"Method": "void setNumberFormat(NumberFormat nf){\r\n    m_nf = nf;\r\n}"
}, {
	"Path": "net.pms.configuration.ConfigurationReader.getStringList",
	"Comment": "return a list of string values for a given configuration\tkey. first, the key is looked up in the current configuration settings. if it\texists and contains a valid value, that value is returned. if the key contains an\tinvalid value or cannot be found, a list with the specified default values is\treturned.",
	"Method": "List<String> getStringList(String key,String def){\r\n    List<String> value;\r\n    String stringValue = getString(key, def);\r\n    if (stringValue != null) {\r\n        String[] array = stringValue.split(\",\");\r\n        List<String> result = new ArrayList<String>(array.length);\r\n        for (String s : array) {\r\n            if (s.trim().length() > 0) {\r\n                result.add(s.trim());\r\n            }\r\n        }\r\n        value = result;\r\n    } else {\r\n        value = Collections.emptyList();\r\n    }\r\n    log(key, stringValue, def);\r\n    return value;\r\n}"
}, {
	"Path": "prefuse.data.io.sql.DefaultSQLDataHandler.setIgnoreUnknownTypes",
	"Comment": "set if unknown or unrecognized sql data types should simply be ignored.",
	"Method": "void setIgnoreUnknownTypes(boolean ignore){\r\n    m_ignoreUnknownTypes = ignore;\r\n}"
}, {
	"Path": "net.pms.xmlwise.XmlElement.getIntAttribute",
	"Comment": "get an integer attribute for this element, defaulting to a default value if the attribute is missing.",
	"Method": "int getIntAttribute(String attribute,int getIntAttribute,String attribute,int defaultValue){\r\n    return containsAttribute(attribute) ? getIntAttribute(attribute) : defaultValue;\r\n}"
}, {
	"Path": "prefuse.action.layout.AxisLayout.getDataField",
	"Comment": "get the data field used by this axis layout action. the values of thedata field determine the position of items along the axis.",
	"Method": "String getDataField(){\r\n    return m_field;\r\n}"
}, {
	"Path": "cn.hugeterry.ployfun.core.delaunay.Triangulation.update",
	"Comment": "update the triangulation by removing the cavity triangles and thenfilling the cavity with new triangles.",
	"Method": "Triangle update(Pnt site,Set<Triangle> cavity){\r\n    Set<Set<Pnt>> boundary = new HashSet<Set<Pnt>>();\r\n    Set<Triangle> theTriangles = new HashSet<Triangle>();\r\n    for (Triangle triangle : cavity) {\r\n        theTriangles.addAll(neighbors(triangle));\r\n        for (Pnt vertex : triangle) {\r\n            Set<Pnt> facet = triangle.facetOpposite(vertex);\r\n            if (boundary.contains(facet))\r\n                boundary.remove(facet);\r\n            else\r\n                boundary.add(facet);\r\n        }\r\n    }\r\n    theTriangles.removeAll(cavity);\r\n    for (Triangle triangle : cavity) triGraph.remove(triangle);\r\n    Set<Triangle> newTriangles = new HashSet<Triangle>();\r\n    for (Set<Pnt> vertices : boundary) {\r\n        vertices.add(site);\r\n        Triangle tri = new Triangle(vertices);\r\n        triGraph.add(tri);\r\n        newTriangles.add(tri);\r\n    }\r\n    theTriangles.addAll(newTriangles);\r\n    for (Triangle triangle : newTriangles) for (Triangle other : theTriangles) if (triangle.isNeighbor(other))\r\n        triGraph.add(triangle, other);\r\n    return newTriangles.iterator().next();\r\n}"
}, {
	"Path": "quickfix.Session.setTargetDefaultApplicationVersionID",
	"Comment": "sets the default application version id for messages received by this session.this is called by the acceptoriohandler upon reception of a logon message andshould not be called by user code.",
	"Method": "void setTargetDefaultApplicationVersionID(ApplVerID applVerID){\r\n    targetDefaultApplVerID.set(applVerID);\r\n}"
}, {
	"Path": "picard.illumina.parser.IlluminaDataProviderFactory.getAvailableTiles",
	"Comment": "return the list of tiles available for this flowcell and lane.these are in ascending numerical order.",
	"Method": "List<Integer> getAvailableTiles(){\r\n    return availableTiles;\r\n}"
}, {
	"Path": "picard.illumina.parser.PerTileCycleParser.makeCycleFileParser",
	"Comment": "for a given cycle, return a cyclefilesparser.it will close the cyclefilesparser if not null.",
	"Method": "CycleFilesParser<ILLUMINA_DATA> makeCycleFileParser(List<File> file,CycleFilesParser<ILLUMINA_DATA> cycleFilesParser,CycleFilesParser<ILLUMINA_DATA> makeCycleFileParser,List<File> file){\r\n    if (cycleFilesParser != null)\r\n        cycleFilesParser.close();\r\n    return makeCycleFileParser(file);\r\n}"
}, {
	"Path": "peergos.server.storage.FileContentAddressedStorage.remove",
	"Comment": "remove all files stored as part of this filecontentaddressedstorage.",
	"Method": "void remove(){\r\n    root.toFile().delete();\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getAssMargin",
	"Comment": "returns the margin used for ass subtitling. default value is 10.",
	"Method": "String getAssMargin(){\r\n    return getString(KEY_ASS_MARGIN, \"10\");\r\n}"
}, {
	"Path": "picard.illumina.parser.BclParser.makeCycleFileParser",
	"Comment": "create a bcl parser for an individual cycle and wrap it with the cyclefilesparser interface which populatesthe correct cycle in bcldata.",
	"Method": "CycleFilesParser<BclData> makeCycleFileParser(List<File> files){\r\n    return new BclDataCycleFileParser(files);\r\n}"
}, {
	"Path": "picard.sam.AbstractAlignmentMerger.getAttributesToReverse",
	"Comment": "gets the set of attributes to be reversed on reads marked as negative strand.",
	"Method": "Set<String> getAttributesToReverse(){\r\n    return attributesToReverse;\r\n}"
}, {
	"Path": "picard.sam.BestEndMapqPrimaryAlignmentStrategy.pickPrimaryAlignment",
	"Comment": "primary alignment was filtered out.need to select a new one.",
	"Method": "void pickPrimaryAlignment(HitsForInsert hits){\r\n    if (hits.numHits() == 0)\r\n        throw new IllegalArgumentException(\"No alignments to pick from\");\r\n    Collections.sort(hits.firstOfPairOrFragment, MAPQ_COMPARATOR);\r\n    Collections.sort(hits.secondOfPair, MAPQ_COMPARATOR);\r\n    randomlySelectPrimaryFromBest(hits.firstOfPairOrFragment);\r\n    randomlySelectPrimaryFromBest(hits.secondOfPair);\r\n    hits.setPrimaryAlignment(0);\r\n    if (!hits.isPaired())\r\n        return;\r\n    if (hits.firstOfPairOrFragment.size() <= 1 || hits.secondOfPair.size() <= 1)\r\n        return;\r\n    final int amountToSlide = hits.firstOfPairOrFragment.size() - 1;\r\n    for (int i = 0; i < amountToSlide; ++i) {\r\n        hits.secondOfPair.add(1, null);\r\n    }\r\n}"
}, {
	"Path": "net.paoding.rose.jade.context.spring.JadeComponentProvider.getResourceLoader",
	"Comment": "return the resourceloader that this component provider uses.",
	"Method": "ResourceLoader getResourceLoader(){\r\n    return this.resourcePatternResolver;\r\n}"
}, {
	"Path": "prefuse.data.parser.ParserFactory.sample",
	"Comment": "sample a data value against the parsers, updating theparser candidates.",
	"Method": "void sample(String val){\r\n    for (int i = 0; i < m_parsers.length; ++i) {\r\n        if (m_isCandidate[i]) {\r\n            m_isCandidate[i] = m_parsers[i].canParse(val);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.restfb.json.JsonValue.asLong",
	"Comment": "returns this json value as a long value, assuming that this value represents a json number that can beinterpreted as java long. if this is not the case, an exception is thrown.to be interpreted as java long, the json number must neither contain an exponent nor a fraction part.moreover, the number must be in the long range.",
	"Method": "long asLong(){\r\n    throw new UnsupportedOperationException(\"Not a number: \" + toString());\r\n}"
}, {
	"Path": "org.quickfixj.codegenerator.GenerateMojo.getSchemaDirectory",
	"Comment": "returns the directory containing schemas for code generation.",
	"Method": "File getSchemaDirectory(){\r\n    return schemaDirectory;\r\n}"
}, {
	"Path": "picard.vcf.GenotypeConcordance.indexExists",
	"Comment": "determines whether an index file exists for the given vcf file using standard extension suffixes",
	"Method": "boolean indexExists(File vcf){\r\n    return Tribble.indexFile(vcf).exists() || Tribble.tabixIndexFile(vcf).exists();\r\n}"
}, {
	"Path": "picard.util.help.HelpConstants.getSuperCategoryProperty",
	"Comment": "given a group name, return a supercategory string for use by the online doc system to determine whichsupercateogry the group is in. the strings returned by this method should match those used in thecorresponding help template.",
	"Method": "String getSuperCategoryProperty(String groupName){\r\n    return getSuperCategoryMap().getOrDefault(groupName, \"other\");\r\n}"
}, {
	"Path": "prefuse.util.collections.CopyOnWriteArrayList.toString",
	"Comment": "returns a string representation of this list, containingthe string representation of each element.",
	"Method": "String toString(){\r\n    Object[] elements = getArray();\r\n    int maxIndex = elements.length - 1;\r\n    StringBuffer buf = new StringBuffer();\r\n    buf.append(\"[\");\r\n    for (int i = 0; i <= maxIndex; i++) {\r\n        buf.append(String.valueOf(elements[i]));\r\n        if (i < maxIndex)\r\n            buf.append(\", \");\r\n    }\r\n    buf.append(\"]\");\r\n    return buf.toString();\r\n}"
}, {
	"Path": "prefuse.util.ui.UILib.setFont",
	"Comment": "sets the font for a component and allcomponents contained within it.",
	"Method": "void setFont(Component c,Font font){\r\n    c.setFont(font);\r\n    if (c instanceof Container) {\r\n        Container con = (Container) c;\r\n        for (int i = 0; i < con.getComponentCount(); ++i) setFont(con.getComponent(i), font);\r\n    }\r\n}"
}, {
	"Path": "picard.illumina.parser.IlluminaTextIterator.seekToTile",
	"Comment": "jump so that the next record returned will be the first one from the specified tile.",
	"Method": "void seekToTile(int oneBasedTileNumber){\r\n    CloserUtil.close(parser);\r\n    currentTile = oneBasedTileNumber;\r\n    initializeParser();\r\n}"
}, {
	"Path": "net.pms.util.KeyedComboBoxModel.fireListDataEvent",
	"Comment": "notifies all registered list data listener of the given event.",
	"Method": "void fireListDataEvent(ListDataEvent evt){\r\n    if (tempListeners == null) {\r\n        tempListeners = listdatalistener.toArray(new ListDataListener[listdatalistener.size()]);\r\n    }\r\n    for (int i = 0; i < tempListeners.length; i++) {\r\n        final ListDataListener l = tempListeners[i];\r\n        if (l != null && evt != null) {\r\n            l.contentsChanged(evt);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.restfb.types.Application.getAuthReferralExtendedPerms",
	"Comment": "extended permissions that a person can choose to grant when authenticated referrals are enabled.",
	"Method": "List<String> getAuthReferralExtendedPerms(){\r\n    return Collections.unmodifiableList(authReferralExtendedPerms);\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.canGetDate",
	"Comment": "indicates if convenience get method can be called withoutan exception being thrown for the date type.",
	"Method": "boolean canGetDate(){\r\n    return canGet(Date.class);\r\n}"
}, {
	"Path": "prefuse.render.LabelRenderer.getText",
	"Comment": "returns the text to draw. subclasses can override this class toperform custom text selection.",
	"Method": "String getText(VisualItem item){\r\n    String s = null;\r\n    if (item.canGetString(m_labelName)) {\r\n        return item.getString(m_labelName);\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "com.restfb.types.webhook.messaging.MessagingAttachment.isLocation",
	"Comment": "convenience method to check if the attachment type is location",
	"Method": "boolean isLocation(){\r\n    return LOCATION.equals(type);\r\n}"
}, {
	"Path": "prefuse.data.Table.canSetInt",
	"Comment": "check if the setint method can safely be used for thegiven data field.",
	"Method": "boolean canSetInt(String field){\r\n    Column col = getColumn(field);\r\n    return (col == null ? false : col.canSetInt());\r\n}"
}, {
	"Path": "prefuse.Visualization.damageReport",
	"Comment": "report damage to associated displays, indicating a region that will needto be redrawn.",
	"Method": "void damageReport(VisualItem item,Rectangle2D region){\r\n    for (int i = 0; i < m_displays.size(); ++i) {\r\n        Display d = getDisplay(i);\r\n        if (d.getPredicate().getBoolean(item)) {\r\n            d.damageReport(region);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.pms.configuration.ConfigurationReader.getBoolean",
	"Comment": "return the boolean value for a given configuration key. first, the\tkey is looked up in the current configuration settings. if it exists and contains\ta valid value, that value is returned. if the key contains an invalid value or\tcannot be found, the specified default value is returned.",
	"Method": "boolean getBoolean(String key,boolean def){\r\n    boolean value;\r\n    try {\r\n        value = configuration.getBoolean(key, def);\r\n    } catch (ConversionException e) {\r\n        value = def;\r\n    }\r\n    log(key, value, def);\r\n    return value;\r\n}"
}, {
	"Path": "peergos.server.storage.IpfsWrapper.waitForDaemon",
	"Comment": "wait until the ipfs id comamnd returns a sensible response.the ipfs daemon can take up to 30 seconds to startresponding to requests once the daemon is started.",
	"Method": "void waitForDaemon(int timeoutSeconds){\r\n    long start = System.currentTimeMillis();\r\n    double duration = 0;\r\n    while (duration < timeoutSeconds) {\r\n        synchronized (this) {\r\n            if (process != null && !process.isAlive())\r\n                throw new IllegalStateException(\"ipfs daemon terminated with return code \" + process.exitValue());\r\n        }\r\n        if (isHttpApiListening(config.apiPort))\r\n            return;\r\n        try {\r\n            Thread.sleep(1000);\r\n        } catch (InterruptedException ie) {\r\n        }\r\n        long current = System.currentTimeMillis();\r\n        duration = (double) (current - start) / 1000.0;\r\n    }\r\n    throw new IllegalStateException(\"ipfs daemon is not ready after specified timeout \" + timeoutSeconds + \" seconds.\");\r\n}"
}, {
	"Path": "picard.illumina.parser.readers.BclQualityEvaluationStrategy.getPoorQualityFrequencies",
	"Comment": "returns a view of number of qualities that failed, where the key is the quality score and the value is the number of observations.",
	"Method": "Map<Byte, Integer> getPoorQualityFrequencies(){\r\n    final Map<Byte, Integer> qualityCountMapCopy = new HashMap<Byte, Integer>();\r\n    for (final Map.Entry<Byte, AtomicInteger> entry : qualityCountMap.entrySet()) {\r\n        qualityCountMapCopy.put(entry.getKey(), entry.getValue().intValue());\r\n    }\r\n    return Collections.unmodifiableMap(qualityCountMapCopy);\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.getDefaultValue",
	"Comment": "returns the default value for rows that have not been set explicitly.",
	"Method": "Object getDefaultValue(){\r\n    return m_defaultValue;\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.isFixed",
	"Comment": "indicates if the given row is fixed, and so will not have its positionchanged by any layout or distortion actions.",
	"Method": "boolean isFixed(int row){\r\n    return getBoolean(row, VisualItem.FIXED);\r\n}"
}, {
	"Path": "prefuse.activity.ActivityMap.clear",
	"Comment": "clears the contents of this activitymap. does not affect the parent map.",
	"Method": "void clear(){\r\n    m_map.clear();\r\n}"
}, {
	"Path": "net.pms.dlna.virtual.VirtualVideoAction.getThumbnailInputStream",
	"Comment": "returns either a green tick mark or a red cross that represents the actual\tvalue of this item",
	"Method": "InputStream getThumbnailInputStream(){\r\n    return getResourceInputStream(enabled ? thumbnailIconOK : thumbnailIconKO);\r\n}"
}, {
	"Path": "io.github.benas.randombeans.util.ReflectionUtils.filterSameParameterizedTypes",
	"Comment": "filters a list of types to keep only elements having the same parameterized types as the given type.",
	"Method": "List<Class<?>> filterSameParameterizedTypes(List<Class<?>> types,Type type){\r\n    if (type instanceof ParameterizedType) {\r\n        Type[] fieldArugmentTypes = ((ParameterizedType) type).getActualTypeArguments();\r\n        List<Class<?>> typesWithSameParameterizedTypes = new ArrayList();\r\n        for (Class<?> currentConcreteType : types) {\r\n            List<Type[]> actualTypeArguments = getActualTypeArgumentsOfGenericInterfaces(currentConcreteType);\r\n            typesWithSameParameterizedTypes.addAll(actualTypeArguments.stream().filter(currentTypeArguments -> Arrays.equals(fieldArugmentTypes, currentTypeArguments)).map(currentTypeArguments -> currentConcreteType).collect(toList()));\r\n        }\r\n        return typesWithSameParameterizedTypes;\r\n    }\r\n    return types;\r\n}"
}, {
	"Path": "prefuse.util.ui.JPrefuseTree.showTreeWindow",
	"Comment": "create a new window displaying the contents of the input tree asa swing jtree.",
	"Method": "JFrame showTreeWindow(Tree t,String labelField){\r\n    JPrefuseTree tree = new JPrefuseTree(t, labelField);\r\n    String title = t.toString();\r\n    if (t instanceof VisualTree) {\r\n        title = ((VisualTree) t).getGroup() + \" \" + title;\r\n    }\r\n    JFrame frame = new JFrame(title);\r\n    frame.getContentPane().add(new JScrollPane(tree));\r\n    frame.pack();\r\n    frame.setVisible(true);\r\n    return frame;\r\n}"
}, {
	"Path": "prefuse.action.assignment.ColorAction.setField",
	"Comment": "set the color field name that this coloraction should set. thecoloraction will automatically try to update the start and endvalues for this field if it is an interpolated field.",
	"Method": "void setField(String field){\r\n    m_colorField = field;\r\n    m_startField = PrefuseLib.getStartField(field);\r\n    m_endField = PrefuseLib.getEndField(field);\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getRendererForceIp",
	"Comment": "returns a string containing a list of ip addresses and the renderer\tprofiles that should be forced to match them. can be empty if no profile\tshould be forced on any ip address.",
	"Method": "String getRendererForceIp(){\r\n    return getString(KEY_RENDERER_FORCE_IP, \"\");\r\n}"
}, {
	"Path": "prefuse.data.search.PrefixSearchTupleSet.getDelimiterString",
	"Comment": "returns the delimiter string used to divide data values andqueries into separate words. by default, the value consistsof just whitespace characters.",
	"Method": "String getDelimiterString(){\r\n    return m_delim;\r\n}"
}, {
	"Path": "picard.analysis.replicates.CollectIndependentReplicateMetrics.calculateEditDistance",
	"Comment": "gives the edit distance between this barcode and another of the same length.",
	"Method": "byte calculateEditDistance(String lhs,String rhs){\r\n    assert (lhs.length() == rhs.length());\r\n    byte tmp = 0;\r\n    for (int i = 0; i < rhs.length(); ++i) {\r\n        if (rhs.charAt(i) != lhs.charAt(i))\r\n            ++tmp;\r\n    }\r\n    return tmp;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setAudioUsePCM",
	"Comment": "sets whether or not the pulse code modulation audio format should be\tforced.",
	"Method": "void setAudioUsePCM(boolean value){\r\n    configuration.setProperty(KEY_AUDIO_USE_PCM, value);\r\n}"
}, {
	"Path": "com.restfb.types.Application.getAuthReferralFriendPerms",
	"Comment": "basic friends permissions that a user must grant when authenticated referrals are enabled.",
	"Method": "List<String> getAuthReferralFriendPerms(){\r\n    return Collections.unmodifiableList(authReferralFriendPerms);\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.canSetDate",
	"Comment": "indicates if convenience set method can be called withoutan exception being thrown for the date type.",
	"Method": "boolean canSetDate(){\r\n    return canSet(Date.class);\r\n}"
}, {
	"Path": "prefuse.controls.ZoomToFitControl.setZoomOverItem",
	"Comment": "determines if the zoom control will work while the mouse isover a visualitem",
	"Method": "void setZoomOverItem(boolean zoomOverItem){\r\n    this.m_zoomOverItem = zoomOverItem;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.isTsmuxerForceFps",
	"Comment": "if the framerate is not recognized correctly and the video runs too fast or too\tslow, tsmuxer can be forced to parse the fps from ffmpeg. default value is true.",
	"Method": "boolean isTsmuxerForceFps(){\r\n    return getBoolean(KEY_TSMUXER_FORCEFPS, true);\r\n}"
}, {
	"Path": "com.restfb.types.webhook.FeedReactionValue.isCommentReaction",
	"Comment": "returns true if the reaction was made on a comment, false if the reaction was made on apost",
	"Method": "boolean isCommentReaction(){\r\n    return commentId != null;\r\n}"
}, {
	"Path": "java.nio.Buffer.flip",
	"Comment": "flips this buffer.\tthe limit is set to the current position, then the position is set to zero, and the mark is cleared.\tthe content of this buffer is not changed.",
	"Method": "Buffer flip(){\r\n    limit = position;\r\n    position = 0;\r\n    mark = UNSET_MARK;\r\n    return this;\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.setHover",
	"Comment": "set the hover flag. this is set automatically by the prefuse framework,so should not need to be set explicitly by application code.",
	"Method": "void setHover(int row,boolean value){\r\n    setBoolean(row, VisualItem.HOVER, value);\r\n}"
}, {
	"Path": "net.paoding.rose.web.portal.util.Enumerator.nextElement",
	"Comment": "returns the next element of this enumeration if this enumeration hasat least one more element to provide.",
	"Method": "T nextElement(){\r\n    return (iterator.next());\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeProbabilitiesUsingLogLikelihoods.getLogLikelihoods",
	"Comment": "since this class uses loglikelihoods natively, we override and return the native variable",
	"Method": "double[] getLogLikelihoods(){\r\n    return this.loglikelihoods;\r\n}"
}, {
	"Path": "org.pcap4j.core.PcapNetworkInterface.isLoopBack",
	"Comment": "returns if this network interface is loopback.this method may always return false on some environments.",
	"Method": "boolean isLoopBack(){\r\n    return loopBack;\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.setParent",
	"Comment": "set the parent object, usually a folder type of resource. in the dldi\tqueries, the upnp server needs to give out the parent container where\tthe item is. the parent represents such a container.",
	"Method": "void setParent(DLNAResource parent){\r\n    this.parent = parent;\r\n}"
}, {
	"Path": "net.pms.network.RequestV2.getLowRange",
	"Comment": "when sending an input stream, the lowrange indicates which byte to start from.",
	"Method": "long getLowRange(){\r\n    return lowRange;\r\n}"
}, {
	"Path": "quickfix.DataDictionary.hasFieldValue",
	"Comment": "predicate for determining if a field has enumerated values.",
	"Method": "boolean hasFieldValue(int field){\r\n    final Set<String> values = fieldValues.get(field);\r\n    return values != null && !values.isEmpty();\r\n}"
}, {
	"Path": "prefuse.util.DataLib.deviation",
	"Comment": "get the standard deviation of a tuple data value. if any tuple does nothave the named field or the field is not a numeric data type, nan will bereturned.",
	"Method": "double deviation(Iterator tuples,String field,double deviation,Iterator tuples,String field,double mean){\r\n    try {\r\n        int count = 0;\r\n        double sumsq = 0;\r\n        double x;\r\n        while (tuples.hasNext()) {\r\n            x = ((Tuple) tuples.next()).getDouble(field) - mean;\r\n            sumsq += x * x;\r\n            ++count;\r\n        }\r\n        return Math.sqrt(sumsq / count);\r\n    } catch (Exception e) {\r\n        return Double.NaN;\r\n    }\r\n}"
}, {
	"Path": "prefuse.Display.reset",
	"Comment": "resets the display by clearing the offscreen buffer and flushing theinternal rendering queue. this method can help reclaim memory when adisplay is not visible.",
	"Method": "void reset(){\r\n    m_offscreen = null;\r\n    m_queue.clean();\r\n}"
}, {
	"Path": "net.pms.xmlwise.XmlElement.getDoubleAttribute",
	"Comment": "get an double attribute for this element, defaulting to a default value if the attribute is missing.",
	"Method": "double getDoubleAttribute(String attribute,double getDoubleAttribute,String attribute,double defaultValue){\r\n    return containsAttribute(attribute) ? getDoubleAttribute(attribute) : defaultValue;\r\n}"
}, {
	"Path": "prefuse.data.Table.canGet",
	"Comment": "check if the get method for the given data field returnsvalues that are compatible with a given target type.",
	"Method": "boolean canGet(String field,Class type){\r\n    Column c = getColumn(field);\r\n    return (c == null ? false : c.canGet(type));\r\n}"
}, {
	"Path": "prefuse.data.CascadedTable.getParentRow",
	"Comment": "given a row in this table, return the corresponding row in the parenttable.",
	"Method": "int getParentRow(int row){\r\n    return ((CascadedRowManager) m_rows).getParentRow(row);\r\n}"
}, {
	"Path": "picard.sam.markduplicates.util.PhysicalLocationForMateCigarSet.replace",
	"Comment": "replaces a given end with the other end.this ensures that that current is in this set",
	"Method": "void replace(ReadEndsForMateCigar current,ReadEndsForMateCigar other){\r\n    final PhysicalLocationForMateCigar location = new PhysicalLocationForMateCigar(current);\r\n    if (!physicalLocations.contains(location)) {\r\n        throw new PicardException(\"Trying to replace something not in the set\");\r\n    }\r\n    this.remove(current);\r\n    this.add(other);\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.i18n.CwNumberFormat.updateFormattedValue",
	"Comment": "update the formatted value based on the user entered value and pattern.",
	"Method": "void updateFormattedValue(){\r\n    String sValue = valueBox.getText();\r\n    if (!sValue.equals(\"\")) {\r\n        try {\r\n            double value = Double.parseDouble(sValue);\r\n            String formattedValue = activeFormat.format(value);\r\n            formattedBox.setText(formattedValue);\r\n            showErrorMessage(null);\r\n        } catch (NumberFormatException e) {\r\n            showErrorMessage(constants.cwNumberFormatFailedToParseInput());\r\n        }\r\n    } else {\r\n        formattedBox.setText(\"<None>\");\r\n    }\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.FruchtermanReingoldLayout.getMaxIterations",
	"Comment": "get the maximum number of iterations to run of this algorithm.",
	"Method": "int getMaxIterations(){\r\n    return maxIter;\r\n}"
}, {
	"Path": "picard.sam.MergeSamFilesTest.unsortedInputSortedOutputTest",
	"Comment": "confirm that unsorted input can result in coordinate sorted output, with index created.",
	"Method": "void unsortedInputSortedOutputTest(){\r\n    final File unsortedInputTestDataDir = new File(TEST_DATA_DIR, \"unsorted_input\");\r\n    final File mergedOutput = File.createTempFile(\"unsortedInputSortedOutputTest.\", BamFileIoUtils.BAM_FILE_EXTENSION);\r\n    mergedOutput.deleteOnExit();\r\n    final String[] args = { \"I=\" + new File(unsortedInputTestDataDir, \"1.sam\").getAbsolutePath(), \"I=\" + new File(unsortedInputTestDataDir, \"2.sam\").getAbsolutePath(), \"O=\" + mergedOutput.getAbsolutePath(), \"SO=coordinate\" };\r\n    final int mergeExitStatus = runPicardCommandLine(args);\r\n    Assert.assertEquals(mergeExitStatus, 0);\r\n    final SamReader reader = SamReaderFactory.makeDefault().open(mergedOutput);\r\n    Assert.assertEquals(reader.getFileHeader().getSortOrder(), SAMFileHeader.SortOrder.coordinate);\r\n    new ValidateSamTester().assertSamValid(mergedOutput);\r\n    CloserUtil.close(reader);\r\n}"
}, {
	"Path": "picard.sam.markduplicates.MarkDuplicatesWithMateCigarIterator.checkCigarForSkips",
	"Comment": "checks a cigar for the presence of n operators. reads with skipped bases may be spliced rnaseq reads",
	"Method": "boolean checkCigarForSkips(Cigar cigar){\r\n    final List<CigarElement> elements = cigar.getCigarElements();\r\n    for (final CigarElement el : elements) {\r\n        if (el.getOperator() == CigarOperator.N)\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "Fluid2D.Fluid_VerletParticleCollisionSystem.ParticleSystem.clearShapes",
	"Comment": "not sure if this is necessary, but i guess opengl stuff needs to be released internally.",
	"Method": "void clearShapes(){\r\n    if (shp_particlesystem != null) {\r\n        for (int i = shp_particlesystem.getChildCount() - 1; i >= 0; i--) {\r\n            shp_particlesystem.removeChild(i);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.activity.Activity.runAfter",
	"Comment": "schedules this activity to start immediately after another activity.this activity will be scheduled to start immediately after thefirst one finishes, overwriting any previously set starttime. if thefirst activity is cancelled, this one will not run.this functionality is provided by using an activitylistener to monitorthe first activity. the listener is removed upon completion orcancellation of the first activity.this method does not in any way affect the scheduling of the first activity. if the first activity is never scheduled, this activitywill correspondingly never be run unless scheduled by a separatescheduling call.",
	"Method": "void runAfter(Activity before){\r\n    ActivityManager.scheduleAfter(before, this);\r\n}"
}, {
	"Path": "net.paoding.rose.RoseVersion.getVersion",
	"Comment": "return the full version string of the present spring codebase, ornull if it cannot be determined.",
	"Method": "String getVersion(){\r\n    Package pkg = RoseVersion.class.getPackage();\r\n    return (pkg != null ? pkg.getImplementationVersion() : null);\r\n}"
}, {
	"Path": "picard.util.TabbedTextFileWithHeaderParser.iterator",
	"Comment": "creates the iterator object.it is illegal to have more than one iterator extanton the same parser object.",
	"Method": "CloseableIterator<Row> iterator(){\r\n    if (extantIterator != null) {\r\n        throw new ConcurrentModificationException(\"Only one iterator allowed at a time.\");\r\n    }\r\n    extantIterator = new TheIterator();\r\n    return extantIterator;\r\n}"
}, {
	"Path": "com.egzosn.pay.paypal.bean.order.Error.setDebugId",
	"Comment": "paypal internal identifier used for correlation purposes.",
	"Method": "Error setDebugId(String debugId){\r\n    this.debugId = debugId;\r\n    return this;\r\n}"
}, {
	"Path": "prefuse.render.AbstractShapeRenderer.setRenderType",
	"Comment": "sets a value indicating if a shape is drawn by its outline, by a fill, or both. the default is to draw both.",
	"Method": "void setRenderType(int type){\r\n    if (type < RENDER_TYPE_NONE || type > RENDER_TYPE_DRAW_AND_FILL) {\r\n        throw new IllegalArgumentException(\"Unrecognized render type.\");\r\n    }\r\n    m_renderType = type;\r\n}"
}, {
	"Path": "prefuse.data.expression.FunctionTable.createFunction",
	"Comment": "get a new function instance for the function with the given name.",
	"Method": "Function createFunction(String name){\r\n    Class type = (Class) s_functionTable.get(name);\r\n    if (type == null) {\r\n        throw new IllegalArgumentException(\"Unrecognized function name\");\r\n    }\r\n    try {\r\n        return (Function) type.newInstance();\r\n    } catch (InstantiationException e) {\r\n        throw new RuntimeException(e);\r\n    } catch (IllegalAccessException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "quickfix.JdbcLogFactory.setDataSource",
	"Comment": "set a data source to be used by the jdbclog to accessthe database.",
	"Method": "void setDataSource(DataSource dataSource){\r\n    this.dataSource = dataSource;\r\n}"
}, {
	"Path": "quickfix.Session.sendToTarget",
	"Comment": "send a message to the session specified by the provided session id.",
	"Method": "boolean sendToTarget(Message message,boolean sendToTarget,Message message,String qualifier,boolean sendToTarget,Message message,String senderCompID,String targetCompID,boolean sendToTarget,Message message,String senderCompID,String targetCompID,String qualifier,boolean sendToTarget,Message message,SessionID sessionID){\r\n    final Session session = lookupSession(sessionID);\r\n    if (session == null) {\r\n        throw new SessionNotFound();\r\n    }\r\n    message.setSessionID(sessionID);\r\n    return session.send(message);\r\n}"
}, {
	"Path": "picard.sam.MultiHitAlignedReadIterator.replaceHardWithSoftClips",
	"Comment": "replaces hard clips with soft clips and fills in bases and qualities with dummy values as needed.",
	"Method": "void replaceHardWithSoftClips(SAMRecord rec){\r\n    if (rec.getReadUnmappedFlag())\r\n        return;\r\n    if (rec.getCigar().isEmpty())\r\n        return;\r\n    List<CigarElement> elements = rec.getCigar().getCigarElements();\r\n    final CigarElement first = elements.get(0);\r\n    final CigarElement last = elements.size() == 1 ? null : elements.get(elements.size() - 1);\r\n    final int startHardClip = first.getOperator() == CigarOperator.H ? first.getLength() : 0;\r\n    final int endHardClip = (last != null && last.getOperator() == CigarOperator.H) ? last.getLength() : 0;\r\n    if (startHardClip + endHardClip > 0) {\r\n        final int len = rec.getReadBases().length + startHardClip + endHardClip;\r\n        final byte[] bases = new byte[len];\r\n        Arrays.fill(bases, (byte) 'N');\r\n        System.arraycopy(rec.getReadBases(), 0, bases, startHardClip, rec.getReadBases().length);\r\n        final byte[] quals = new byte[len];\r\n        Arrays.fill(quals, (byte) 2);\r\n        System.arraycopy(rec.getBaseQualities(), 0, quals, startHardClip, rec.getBaseQualities().length);\r\n        elements = new ArrayList<CigarElement>(elements);\r\n        if (startHardClip > 0)\r\n            elements.set(0, new CigarElement(first.getLength(), CigarOperator.S));\r\n        if (endHardClip > 0)\r\n            elements.set(elements.size() - 1, new CigarElement(last.getLength(), CigarOperator.S));\r\n        rec.setReadBases(bases);\r\n        rec.setBaseQualities(quals);\r\n        rec.setCigar(new Cigar(elements));\r\n    }\r\n}"
}, {
	"Path": "picard.sam.markduplicates.UmiUtil.setMolecularIdentifier",
	"Comment": "set molecular identifier tag of record using umi and alignment start position along with top and bottom strand information",
	"Method": "void setMolecularIdentifier(SAMRecord rec,String assignedUmi,String molecularIdentifierTag,boolean duplexUmis){\r\n    if (molecularIdentifierTag == null) {\r\n        return;\r\n    }\r\n    final StringBuilder molecularIdentifier = new StringBuilder();\r\n    molecularIdentifier.append(rec.getContig());\r\n    molecularIdentifier.append(CONTIG_SEPARATOR);\r\n    molecularIdentifier.append(rec.getReadNegativeStrandFlag() ? rec.getAlignmentStart() : rec.getMateAlignmentStart());\r\n    molecularIdentifier.append(UMI_NAME_SEPARATOR);\r\n    molecularIdentifier.append(assignedUmi);\r\n    if (duplexUmis) {\r\n        molecularIdentifier.append(isTopStrand(rec) ? TOP_STRAND_DUPLEX : BOTTOM_STRAND_DUPLEX);\r\n    }\r\n    rec.setAttribute(molecularIdentifierTag, molecularIdentifier.toString());\r\n}"
}, {
	"Path": "SoftBody2D.SoftBody2D_DifferentialGrowth_Closed.SoftBody2D_DifferentialGrowth_Closed.sortParticles",
	"Comment": "save particles in a sorted list, as they are lined up in the chain",
	"Method": "void sortParticles(){\r\n    particles_sorted_count = 0;\r\n    DwParticle2D pstart = particles[0];\r\n    DwParticle2D pprev = null;\r\n    DwParticle2D pcurr = pstart;\r\n    DwParticle2D pnext = null;\r\n    while (pcurr != null && pnext != pstart) {\r\n        particles_sorted[particles_sorted_count++] = pcurr;\r\n        pnext = getNextParticle(pcurr, pprev);\r\n        pprev = pcurr;\r\n        pcurr = pnext;\r\n    }\r\n}"
}, {
	"Path": "picard.illumina.parser.readers.ClocsFileReaderTest.multiBinPassingClocsFiles",
	"Comment": "these are all essentially the same file but with 0 or more empty bins spread through them",
	"Method": "Object[][] multiBinPassingClocsFiles(){\r\n    return new Object[][] { { MULTI_BIN_PASSING_CLOCS_FILE, 0, 2102 }, { MBCF_W_EMPTY_BINS_AT_START, 2, 2103 }, { MBCF_W_EMPTY_BINS_AT_END, 0, 2104 } };\r\n}"
}, {
	"Path": "quickfix.DataDictionary.isRequiredHeaderField",
	"Comment": "predicate for determining if a header field is a required field",
	"Method": "boolean isRequiredHeaderField(int field){\r\n    return isRequiredField(HEADER_ID, field);\r\n}"
}, {
	"Path": "prefuse.Display.getVisibleItemCount",
	"Comment": "returns the number of visible items processed by this display. thisincludes items not currently visible on screen due to the currentpanning or zooming state.",
	"Method": "int getVisibleItemCount(){\r\n    return m_visibleCount;\r\n}"
}, {
	"Path": "prefuse.util.ui.JSearchPanel.setShowCancel",
	"Comment": "indicates if the component should show the cancel query button.",
	"Method": "void setShowCancel(boolean b){\r\n    m_showCancel = b;\r\n    initUI();\r\n    validate();\r\n}"
}, {
	"Path": "com.yheriatovych.reductor.Action.create",
	"Comment": "factory method to create action with defined type and any number of attached values as payload",
	"Method": "Action create(String type,Object values){\r\n    return new Action(type, values);\r\n}"
}, {
	"Path": "prefuse.data.util.TableIterator.canGetInt",
	"Comment": "check if the given data field can return primitive intvalues.",
	"Method": "boolean canGetInt(String field){\r\n    return m_table.canGetInt(field);\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.getUpdateId",
	"Comment": "returns the update counter for this resource. when the resource needs\tto be refreshed, its counter is updated.",
	"Method": "int getUpdateId(){\r\n    return updateId;\r\n}"
}, {
	"Path": "picard.sam.HitsForInsert.numHits",
	"Comment": "note that a single alignment for each end of a read pair is counted as a single hit.",
	"Method": "int numHits(){\r\n    return Math.max(firstOfPairOrFragment.size(), secondOfPair.size());\r\n}"
}, {
	"Path": "prefuse.action.filter.GraphDistanceFilter.setSources",
	"Comment": "set the name of the group to use as source nodes for measuringgraph distance. these form the roots from which the graph distanceis measured.",
	"Method": "void setSources(String sources){\r\n    m_sources = sources;\r\n}"
}, {
	"Path": "prefuse.visual.AggregateTable.aggregateContains",
	"Comment": "indicates if an item is a member of the aggregate at the given row",
	"Method": "boolean aggregateContains(int row,VisualItem member){\r\n    return getAggregatedRow(row, member) >= 0;\r\n}"
}, {
	"Path": "prefuse.data.Table.isCellEditable",
	"Comment": "indicates if the value of the given table cell can be changed.",
	"Method": "boolean isCellEditable(int row,int col){\r\n    if (!m_rows.isValidRow(row)) {\r\n        return false;\r\n    } else {\r\n        return getColumn(col).isCellEditable(row);\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.collections.AbstractHashMap.chooseLowWaterMark",
	"Comment": "returns new low water mark threshold based on current capacity andminloadfactor.",
	"Method": "int chooseLowWaterMark(int capacity,double minLoad){\r\n    return (int) (capacity * minLoad);\r\n}"
}, {
	"Path": "prefuse.data.util.TableIterator.canSetBoolean",
	"Comment": "check if the setboolean method can safely be used for thegiven data field.",
	"Method": "boolean canSetBoolean(String field){\r\n    return m_table.canSetBoolean(field);\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.i18n.CwDateTimeFormat.updateFormattedValue",
	"Comment": "update the formatted value based on the user entered value and pattern.",
	"Method": "void updateFormattedValue(){\r\n    String sValue = valueBox.getText();\r\n    if (!sValue.equals(\"\")) {\r\n        try {\r\n            Date date = new Date(sValue);\r\n            String formattedValue = activeFormat.format(date);\r\n            formattedBox.setText(formattedValue);\r\n            showErrorMessage(null);\r\n        } catch (IllegalArgumentException e) {\r\n            showErrorMessage(constants.cwDateTimeFormatFailedToParseInput());\r\n        }\r\n    } else {\r\n        formattedBox.setText(\"<None>\");\r\n    }\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.getSplitTrack",
	"Comment": "returns the number of the track to split from this resource.",
	"Method": "int getSplitTrack(){\r\n    return splitTrack;\r\n}"
}, {
	"Path": "picard.analysis.AdapterUtility.prepareAdapterSequences",
	"Comment": "converts the supplied adapter sequences to byte arrays in both fwd and rc",
	"Method": "byte[][] prepareAdapterSequences(List<String> adapterSequence){\r\n    final Set<String> kmers = new HashSet();\r\n    for (final String seq : adapterSequence) {\r\n        for (int i = 0; i <= seq.length() - ADAPTER_MATCH_LENGTH; ++i) {\r\n            final String kmer = seq.substring(i, i + ADAPTER_MATCH_LENGTH).toUpperCase();\r\n            int ns = 0;\r\n            for (final char ch : kmer.toCharArray()) if (ch == 'N')\r\n                ++ns;\r\n            if (ns <= MAX_ADAPTER_ERRORS) {\r\n                kmers.add(kmer);\r\n                kmers.add(SequenceUtil.reverseComplement(kmer));\r\n            }\r\n        }\r\n    }\r\n    final byte[][] adapterKmers = new byte[kmers.size()][];\r\n    int i = 0;\r\n    for (final String kmer : kmers) {\r\n        adapterKmers[i++] = StringUtil.stringToBytes(kmer);\r\n    }\r\n    return adapterKmers;\r\n}"
}, {
	"Path": "prefuse.action.layout.AxisLabelLayout.isAscending",
	"Comment": "indicates if the axis values should be presented in ascending orderalong the axis.",
	"Method": "boolean isAscending(){\r\n    return m_asc;\r\n}"
}, {
	"Path": "com.restfb.json.JsonValue.asString",
	"Comment": "returns this json value as string, assuming that this value represents a json string. if this is not the case, anexception is thrown.",
	"Method": "String asString(){\r\n    throw new UnsupportedOperationException(\"Not a string: \" + toString());\r\n}"
}, {
	"Path": "picard.vcf.GenotypeConcordanceScheme.getConcordanceStateArray",
	"Comment": "get the concordance state array associate with the given truth state and call state tuple.",
	"Method": "ContingencyState[] getConcordanceStateArray(TruthState truthState,CallState callState,ContingencyState[] getConcordanceStateArray,TruthAndCallStates truthAndCallStates){\r\n    return this.scheme.get(truthAndCallStates);\r\n}"
}, {
	"Path": "prefuse.data.util.TableIterator.canGetDouble",
	"Comment": "check if the given data field can return primitive doublevalues.",
	"Method": "boolean canGetDouble(String field){\r\n    return m_table.canGetDouble(field);\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeMap.withoutChromosomes",
	"Comment": "returns a copy of this haplotype map that excludes haplotypes on the chromosomes provided.",
	"Method": "HaplotypeMap withoutChromosomes(Set<String> chroms){\r\n    final HaplotypeMap out = new HaplotypeMap(getHeader());\r\n    for (final HaplotypeBlock block : this.haplotypeBlocks) {\r\n        if (!chroms.contains(block.getFirstSnp().getChrom())) {\r\n            out.addHaplotype(block);\r\n        }\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.clear",
	"Comment": "unsupported operation. spanning trees should not be edited.",
	"Method": "void clear(){\r\n    throw new UnsupportedOperationException(\"Changes to graph structure not allowed for spanning trees.\");\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.removeTuple",
	"Comment": "unsupported operation. spanning trees should not be edited.",
	"Method": "boolean removeTuple(Tuple t){\r\n    throw new UnsupportedOperationException(\"Changes to graph structure not allowed for spanning trees.\");\r\n}"
}, {
	"Path": "picard.vcf.SortVcfsTest.validateSortingResults",
	"Comment": "checks the ordering and total number of variant context entries in the specified output vcf file.does not check explicitly that the vc genomic positions match exactly those from the inputs. we assume this behavior from other tests.",
	"Method": "void validateSortingResults(File output,int expectedVariantContextCount){\r\n    final VCFFileReader outputReader = new VCFFileReader(output, false);\r\n    final VariantContextComparator outputComparator = outputReader.getFileHeader().getVCFRecordComparator();\r\n    VariantContext last = null;\r\n    int variantContextCount = 0;\r\n    final CloseableIterator<VariantContext> iterator = outputReader.iterator();\r\n    while (iterator.hasNext()) {\r\n        final VariantContext outputContext = iterator.next();\r\n        if (last != null)\r\n            Assert.assertTrue(outputComparator.compare(last, outputContext) <= 0);\r\n        last = outputContext;\r\n        variantContextCount++;\r\n    }\r\n    iterator.close();\r\n    Assert.assertEquals(variantContextCount, expectedVariantContextCount);\r\n}"
}, {
	"Path": "prefuse.data.expression.parser.ParseException.add_escapes",
	"Comment": "used to convert raw characters to their escaped versionwhen these raw version cannot be used as part of an asciistring literal.",
	"Method": "String add_escapes(String str){\r\n    StringBuffer retval = new StringBuffer();\r\n    char ch;\r\n    for (int i = 0; i < str.length(); i++) {\r\n        switch(str.charAt(i)) {\r\n            case 0:\r\n                continue;\r\n            case '\\b':\r\n                retval.append(\"\\\\b\");\r\n                continue;\r\n            case '\\t':\r\n                retval.append(\"\\\\t\");\r\n                continue;\r\n            case '\\n':\r\n                retval.append(\"\\\\n\");\r\n                continue;\r\n            case '\\f':\r\n                retval.append(\"\\\\f\");\r\n                continue;\r\n            case '\\r':\r\n                retval.append(\"\\\\r\");\r\n                continue;\r\n            case '\\\"':\r\n                retval.append(\"\\\\\\\"\");\r\n                continue;\r\n            case '\\'':\r\n                retval.append(\"\\\\\\'\");\r\n                continue;\r\n            case '\\\\':\r\n                retval.append(\"\\\\\\\\\");\r\n                continue;\r\n            default:\r\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\r\n                    String s = \"0000\" + Integer.toString(ch, 16);\r\n                    retval.append(\"\\\%u\" + s.substring(s.length() - 4, s.length()));\r\n                } else {\r\n                    retval.append(ch);\r\n                }\r\n                continue;\r\n        }\r\n    }\r\n    return retval.toString();\r\n}"
}, {
	"Path": "com.egzosn.pay.paypal.bean.order.Error.setInformationLink",
	"Comment": "uri for detailed information related to this error for the developer.",
	"Method": "Error setInformationLink(String informationLink){\r\n    this.informationLink = informationLink;\r\n    return this;\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.getFont",
	"Comment": "get the current font for the row. the font is used as the defaulttypeface for drawing text for this item.",
	"Method": "Font getFont(int row){\r\n    return (Font) get(row, VisualItem.FONT);\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getMencoderNoAssBlur",
	"Comment": "returns the subfont blur parameter used for subtitling without ass.\tdefault value is 1.",
	"Method": "String getMencoderNoAssBlur(){\r\n    return getString(KEY_MENCODER_NOASS_BLUR, \"1\");\r\n}"
}, {
	"Path": "prefuse.data.Table.getIndex",
	"Comment": "retrieve, without creating, an index for the given data field.",
	"Method": "Index getIndex(String field,Index getIndex,String field,Class expType,boolean create){\r\n    if (!expType.equals(getColumnType(field))) {\r\n        throw new IllegalArgumentException(\"Column type does not match.\");\r\n    }\r\n    if (getIndex(field) == null && create) {\r\n        index(field);\r\n    }\r\n    return getIndex(field);\r\n}"
}, {
	"Path": "net.pms.io.UnbufferedOutputFile.close",
	"Comment": "closes the piped streams and releases any system resources associated with\tthem. this object may no longer be used for writing bytes.",
	"Method": "void close(){\r\n    pipedInputStream.close();\r\n    pipedOutputStream.close();\r\n}"
}, {
	"Path": "prefuse.data.util.FilterIteratorFactory.tuples",
	"Comment": "get a filtered iterator over the tuples in the given set,filtered by the given predicate.",
	"Method": "Iterator tuples(TupleSet ts,Predicate p){\r\n    if (p == null)\r\n        return ts.tuples();\r\n    Iterator iter = null;\r\n    if (ts instanceof Table) {\r\n        Table t = (Table) ts;\r\n        IntIterator ii = getOptimizedIterator(t, p);\r\n        if (ii != null)\r\n            iter = t.tuples(ii);\r\n    }\r\n    if (iter == null) {\r\n        iter = new FilterIterator(ts.tuples(), p);\r\n    }\r\n    return iter;\r\n}"
}, {
	"Path": "prefuse.util.display.Clip.transform",
	"Comment": "transform the clip contents. a new clip region will be createdwhich is the bounding box of the transformed region.",
	"Method": "void transform(AffineTransform at){\r\n    clip[2] = clip[0];\r\n    clip[3] = clip[7];\r\n    clip[4] = clip[6];\r\n    clip[5] = clip[1];\r\n    at.transform(clip, 0, clip, 0, 4);\r\n    double xmin = clip[0], ymin = clip[1];\r\n    double xmax = clip[6], ymax = clip[7];\r\n    for (int i = 0; i < 7; i += 2) {\r\n        if (clip[i] < xmin)\r\n            xmin = clip[i];\r\n        if (clip[i] > xmax)\r\n            xmax = clip[i];\r\n        if (clip[i + 1] < ymin)\r\n            ymin = clip[i + 1];\r\n        if (clip[i + 1] > ymax)\r\n            ymax = clip[i + 1];\r\n    }\r\n    clip[0] = xmin;\r\n    clip[1] = ymin;\r\n    clip[6] = xmax;\r\n    clip[7] = ymax;\r\n}"
}, {
	"Path": "prefuse.controls.NeighborHighlightControl.setHighlightWithInvisibleEdge",
	"Comment": "determines if neighbor nodes with edges currently not visible stillget highlighted.",
	"Method": "void setHighlightWithInvisibleEdge(boolean highlightWithInvisibleEdge){\r\n    this.highlightWithInvisibleEdge = highlightWithInvisibleEdge;\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.i18n.CwDateTimeFormat.showErrorMessage",
	"Comment": "show an error message. pass in null to clear the error message.",
	"Method": "void showErrorMessage(String errorMsg){\r\n    if (errorMsg == null) {\r\n        formattedBox.removeStyleName(\"cw-RedText\");\r\n    } else {\r\n        formattedBox.setText(errorMsg);\r\n        formattedBox.addStyleName(\"cw-RedText\");\r\n    }\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.setBounds",
	"Comment": "set the bounding box for an item. this method is used by renderermodules when the bounds are validated, or set by processing actionsused in conjunction with renderers that do not perform boundsmanagement.",
	"Method": "void setBounds(int row,double x,double y,double w,double h){\r\n    getBounds(row).setRect(x, y, w, h);\r\n    fireTableEvent(row, row, getColumnNumber(VisualItem.BOUNDS), EventConstants.UPDATE);\r\n}"
}, {
	"Path": "org.pcap4j.core.BpfProgram.applyFilter",
	"Comment": "apply the filter on a given packet.return true if the packet given passes the filter that is built from this program.",
	"Method": "boolean applyFilter(Packet packet,boolean applyFilter,byte[] packet,boolean applyFilter,byte[] packet,int orgPacketLen,int packetLen){\r\n    synchronized (lock) {\r\n        if (freed) {\r\n            return false;\r\n        }\r\n        if (program.bf_insns == null) {\r\n            program.read();\r\n        }\r\n        return NativeMappings.bpf_filter(program.bf_insns, packet, orgPacketLen, packetLen) != 0;\r\n    }\r\n}"
}, {
	"Path": "prefuse.Display.invalidate",
	"Comment": "invalidates this component. overridden to ensure that aninternal damage report is generated.",
	"Method": "void invalidate(){\r\n    damageReport();\r\n    super.invalidate();\r\n}"
}, {
	"Path": "picard.sam.SamErrorMetric.BaseErrorCalculationTest.testOverlappingErrorCalculatorWithManyReadsData",
	"Comment": "dataprovider used in order to avoid timing the generation of the input file.",
	"Method": "Object[][] testOverlappingErrorCalculatorWithManyReadsData(){\r\n    final File temp = File.createTempFile(\"Overlapping\", \".bam\");\r\n    temp.deleteOnExit();\r\n    try (final ReferenceSequenceFileWalker referenceSequenceFileWalker = new ReferenceSequenceFileWalker(new File(\"testdata/picard/sam/BamErrorMetrics/chrM.reference.fasta\"))) {\r\n        final SAMRecordSetBuilder builder = new SAMRecordSetBuilder();\r\n        builder.getHeader().setSequenceDictionary(referenceSequenceFileWalker.getSequenceDictionary());\r\n        for (int i = 0; i < 4000; i++) {\r\n            builder.addPair(\"Read\" + i, 0, 1, 1, false, false, \"36M\", \"36M\", true, false, 20);\r\n        }\r\n        try (final SAMFileWriter writer = new SAMFileWriterFactory().setCompressionLevel(2).makeBAMWriter(builder.getHeader(), false, temp)) {\r\n            builder.forEach(writer::addAlignment);\r\n        }\r\n    }\r\n    return new Object[][] { { temp } };\r\n}"
}, {
	"Path": "com.egzosn.pay.paypal.bean.order.Error.getInformationLink",
	"Comment": "uri for detailed information related to this error for the developer.",
	"Method": "String getInformationLink(){\r\n    return this.informationLink;\r\n}"
}, {
	"Path": "net.pms.util.PlayerUtil.isWebVideo",
	"Comment": "returns whether or not the supplied dlna resource is a web video file.",
	"Method": "boolean isWebVideo(DLNAResource resource){\r\n    return isType(resource, Format.VIDEO, Format.Identifier.WEB);\r\n}"
}, {
	"Path": "com.goodiebag.pinview.Pinview.initAttributes",
	"Comment": "this method gets the attribute values from the xml, if not found it takes the default values.",
	"Method": "void initAttributes(Context context,AttributeSet attrs,int defStyleAttr){\r\n    if (attrs != null) {\r\n        final TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.Pinview, defStyleAttr, 0);\r\n        mPinBackground = array.getResourceId(R.styleable.Pinview_pinBackground, mPinBackground);\r\n        mPinLength = array.getInt(R.styleable.Pinview_pinLength, mPinLength);\r\n        mPinHeight = (int) array.getDimension(R.styleable.Pinview_pinHeight, mPinHeight);\r\n        mPinWidth = (int) array.getDimension(R.styleable.Pinview_pinWidth, mPinWidth);\r\n        mSplitWidth = (int) array.getDimension(R.styleable.Pinview_splitWidth, mSplitWidth);\r\n        mTextSize = (int) array.getDimension(R.styleable.Pinview_textSize, mTextSize);\r\n        mCursorVisible = array.getBoolean(R.styleable.Pinview_cursorVisible, mCursorVisible);\r\n        mPassword = array.getBoolean(R.styleable.Pinview_password, mPassword);\r\n        mForceKeyboard = array.getBoolean(R.styleable.Pinview_forceKeyboard, mForceKeyboard);\r\n        mHint = array.getString(R.styleable.Pinview_hint);\r\n        InputType[] its = InputType.values();\r\n        inputType = its[array.getInt(R.styleable.Pinview_inputType, 0)];\r\n        array.recycle();\r\n    }\r\n}"
}, {
	"Path": "picard.analysis.CollectMultipleMetricsTest.setupBuilder",
	"Comment": "create a samfile with different samples, read groups and libraries that overlap for testing.",
	"Method": "void setupBuilder(){\r\n    final int numReads = 100;\r\n    final String flowCellBarcode = \"TESTBARCODE\";\r\n    tempSamFile = File.createTempFile(\"CollectGcBias\", \".bam\", TEST_DIR);\r\n    final File tempSamIndex = new File(tempSamFile.getAbsolutePath().replace(\"bam\", \"bai\"));\r\n    final File tempSamFileUnsorted = File.createTempFile(\"CollectGcBias\", \".bam\", TEST_DIR);\r\n    tempSamFileUnsorted.deleteOnExit();\r\n    tempSamIndex.deleteOnExit();\r\n    tempSamFile.deleteOnExit();\r\n    BufferedLineReader bufferedLineReader = null;\r\n    try {\r\n        bufferedLineReader = new BufferedLineReader(new FileInputStream(dict));\r\n    } catch (FileNotFoundException e) {\r\n        e.printStackTrace();\r\n    }\r\n    final SAMTextHeaderCodec codec = new SAMTextHeaderCodec();\r\n    final SAMFileHeader header = codec.decode(bufferedLineReader, dict.toString());\r\n    header.setSortOrder(SAMFileHeader.SortOrder.unsorted);\r\n    setup(numReads, flowCellBarcode, 1, readGroupId1, readGroupRecord1, sample1, library1, header, setBuilder1);\r\n    setup(numReads, flowCellBarcode, 2, readGroupId2, readGroupRecord2, sample1, library2, header, setBuilder2);\r\n    setup(numReads, flowCellBarcode, 3, readGroupId3, readGroupRecord3, sample2, library3, header, setBuilder3);\r\n    final SAMFileWriter writer = new SAMFileWriterFactory().setCreateIndex(true).makeBAMWriter(header, false, tempSamFileUnsorted);\r\n    for (final SAMRecord record : setBuilder1) {\r\n        writer.addAlignment(record);\r\n    }\r\n    for (final SAMRecord record : setBuilder2) {\r\n        writer.addAlignment(record);\r\n    }\r\n    for (final SAMRecord record : setBuilder3) {\r\n        writer.addAlignment(record);\r\n    }\r\n    writer.close();\r\n    final SortSam sorter = new SortSam();\r\n    final String[] args = new String[] { \"INPUT=\" + tempSamFileUnsorted.getAbsolutePath(), \"OUTPUT=\" + tempSamFile.getAbsolutePath(), \"SORT_ORDER=coordinate\" };\r\n    sorter.instanceMain(args);\r\n}"
}, {
	"Path": "picard.sam.MergeBamAlignmentTest.testEarliestFragmentStrategy",
	"Comment": "various scenarios for earliestfragmentstrategy.confirms that one of the expected ones is selected.note that there may be an arbitrary selection due to a tie.",
	"Method": "void testEarliestFragmentStrategy(String testName,MultipleAlignmentSpec[] specs){\r\n    final File output = File.createTempFile(testName, \".sam\");\r\n    output.deleteOnExit();\r\n    final File[] sams = createSamFilesToBeMerged(specs);\r\n    doMergeAlignment(sams[0], Collections.singletonList(sams[1]), null, null, null, null, false, true, false, 1, \"0\", \"1.0\", \"align!\", \"myAligner\", true, fasta, output, SamPairUtil.PairOrientation.FR, MergeBamAlignment.PrimaryAlignmentStrategy.EarliestFragment, ONE_OF_THE_BEST_TAG, null, false, null);\r\n    final SamReader mergedReader = SamReaderFactory.makeDefault().open(output);\r\n    boolean seenPrimary = false;\r\n    for (final SAMRecord rec : mergedReader) {\r\n        if (!rec.getNotPrimaryAlignmentFlag()) {\r\n            seenPrimary = true;\r\n            final Integer oneOfTheBest = rec.getIntegerAttribute(ONE_OF_THE_BEST_TAG);\r\n            Assert.assertEquals(oneOfTheBest, new Integer(1), \"Read not marked as one of the best is primary: \" + rec);\r\n        }\r\n    }\r\n    CloserUtil.close(mergedReader);\r\n    Assert.assertTrue(seenPrimary, \"Never saw primary alignment\");\r\n}"
}, {
	"Path": "com.restfb.types.Account.getTasks",
	"Comment": "a list of tasks allowed to perform for this page.see tasks list here",
	"Method": "List<String> getTasks(){\r\n    return unmodifiableList(tasks);\r\n}"
}, {
	"Path": "net.pms.util.KeyedComboBoxModel.findDataElementIndex",
	"Comment": "searches an element by its data value. this method is called by the\tsetselecteditem method and returns the first occurence of the element.",
	"Method": "int findDataElementIndex(Object anItem){\r\n    if (anItem == null) {\r\n        throw new NullPointerException(\"Item to find must not be null\");\r\n    }\r\n    for (int i = 0; i < data.size(); i++) {\r\n        final ComboBoxItemPair datacon = data.get(i);\r\n        if (anItem.equals(datacon.getKey())) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.panels.CwAbsolutePanel.updateSelectedItem",
	"Comment": "update the top and left position text fields when the user selects a newitem to move.",
	"Method": "void updateSelectedItem(){\r\n    String name = listBox.getValue(listBox.getSelectedIndex());\r\n    Widget item = widgetMap.get(name);\r\n    topPosBox.setText(absolutePanel.getWidgetTop(item) + \"\");\r\n    leftPosBox.setText(absolutePanel.getWidgetLeft(item) + \"\");\r\n}"
}, {
	"Path": "prefuse.activity.Activity.isScheduled",
	"Comment": "indicates if this activity is currently scheduledwith the activitymanager",
	"Method": "boolean isScheduled(){\r\n    return m_isScheduled;\r\n}"
}, {
	"Path": "py4j.reflection.ReflectionEngine.getPublicStaticClassNames",
	"Comment": "retrieve the names of all the public static classes in the clazz",
	"Method": "String[] getPublicStaticClassNames(Class<?> clazz){\r\n    Class<?>[] classes = clazz.getClasses();\r\n    Set<String> classNames = new HashSet<String>();\r\n    for (Class<?> clazz2 : classes) {\r\n        if (Modifier.isPublic(clazz2.getModifiers()) && Modifier.isStatic(clazz2.getModifiers())) {\r\n            classNames.add(clazz2.getSimpleName());\r\n        }\r\n    }\r\n    return (String[]) classNames.toArray(new String[classNames.size()]);\r\n}"
}, {
	"Path": "cn.hugeterry.ployfun.core.delaunay.Triangle.getVertexButNot",
	"Comment": "get arbitrary vertex of this triangle, but not any of the bad vertices.",
	"Method": "Pnt getVertexButNot(Pnt badVertices){\r\n    Collection<Pnt> bad = Arrays.asList(badVertices);\r\n    for (Pnt v : this) if (!bad.contains(v))\r\n        return v;\r\n    throw new NoSuchElementException(\"No vertex found\");\r\n}"
}, {
	"Path": "prefuse.data.Table.removeTuple",
	"Comment": "remove a tuple from this table. if the tuple is a member of this table,its row is deleted from the table. otherwise, nothing is done.",
	"Method": "boolean removeTuple(Tuple t){\r\n    if (containsTuple(t)) {\r\n        removeRow(t.getRow());\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.pms.test.formats.FormatRecognitionTest.testPlaystationImageTiffCompatibility",
	"Comment": "test the compatibility of the playstation 3 with the tiff format.",
	"Method": "void testPlaystationImageTiffCompatibility(){\r\n    assumeTrue(mediaInfoParserIsValid);\r\n    RendererConfiguration conf = RendererConfiguration.getRendererConfigurationByName(\"Playstation 3\");\r\n    assertNotNull(\"Renderer named \\\"Playstation 3\\\" found.\", conf);\r\n    DLNAMediaInfo info = new DLNAMediaInfo();\r\n    info.setContainer(\"tiff\");\r\n    Format format = new TIF();\r\n    format.match(\"test.tiff\");\r\n    assertEquals(\"PS3 is compatible with TIFF\", true, conf.isCompatible(info, format));\r\n}"
}, {
	"Path": "net.pms.configuration.Build.isUpdatable",
	"Comment": "determines whether or not this pms build can be updated to a more\trecent version.",
	"Method": "boolean isUpdatable(){\r\n    return IS_UPDATABLE && Platform.isWindows() && getUpdateServerURL() != null;\r\n}"
}, {
	"Path": "prefuse.data.Table.addRow",
	"Comment": "add a row to this table. all data columns will be notified and willtake on the appropriate default values for the added row.",
	"Method": "int addRow(){\r\n    int r = m_rows.addRow();\r\n    updateRowCount();\r\n    fireTableEvent(r, r, TableModelEvent.ALL_COLUMNS, TableModelEvent.INSERT);\r\n    return r;\r\n}"
}, {
	"Path": "picard.sam.util.Pair.equals",
	"Comment": "calculate whether this pair object is equal to another object.",
	"Method": "boolean equals(Object o){\r\n    if (this == o)\r\n        return true;\r\n    if (!(o instanceof Pair))\r\n        return false;\r\n    final Pair other = (Pair) o;\r\n    return Objects.equals(left, other.left) && Objects.equals(right, other.right);\r\n}"
}, {
	"Path": "peergos.shared.scrypt.com.lambdaworks.codec.Base64.encode",
	"Comment": "encode bytes to base64 chars using the supplied encode table and withoptional padding.",
	"Method": "char[] encode(byte[] bytes,char[] encode,byte[] bytes,boolean padded,char[] encode,byte[] src,char[] table,char pad){\r\n    int len = src.length;\r\n    if (len == 0)\r\n        return new char[0];\r\n    int blocks = (len / 3) * 3;\r\n    int chars = ((len - 1) / 3 + 1) << 2;\r\n    int tail = len - blocks;\r\n    if (pad == 0 && tail > 0)\r\n        chars -= 3 - tail;\r\n    char[] dst = new char[chars];\r\n    int si = 0, di = 0;\r\n    while (si < blocks) {\r\n        int n = (src[si++] & 0xff) << 16 | (src[si++] & 0xff) << 8 | (src[si++] & 0xff);\r\n        dst[di++] = table[(n >>> 18) & 0x3f];\r\n        dst[di++] = table[(n >>> 12) & 0x3f];\r\n        dst[di++] = table[(n >>> 6) & 0x3f];\r\n        dst[di++] = table[n & 0x3f];\r\n    }\r\n    if (tail > 0) {\r\n        int n = (src[si] & 0xff) << 10;\r\n        if (tail == 2)\r\n            n |= (src[++si] & 0xff) << 2;\r\n        dst[di++] = table[(n >>> 12) & 0x3f];\r\n        dst[di++] = table[(n >>> 6) & 0x3f];\r\n        if (tail == 2)\r\n            dst[di++] = table[n & 0x3f];\r\n        if (pad != 0) {\r\n            if (tail == 1)\r\n                dst[di++] = pad;\r\n            dst[di] = pad;\r\n        }\r\n    }\r\n    return dst;\r\n}"
}, {
	"Path": "com.egzosn.pay.paypal.bean.order.RedirectUrls.getCancelUrl",
	"Comment": "url where the payer would be redirected to after canceling the payment. required for paypal account payments.",
	"Method": "String getCancelUrl(){\r\n    return this.cancelUrl;\r\n}"
}, {
	"Path": "picard.vcf.MendelianViolations.MendelianViolationDetector.isMendelianViolation",
	"Comment": "tests whether the alleles of the offspring are possible given the alleles of the parents.",
	"Method": "boolean isMendelianViolation(Genotype p1,Genotype p2,Genotype off){\r\n    final Allele offAllele1 = off.getAllele(0);\r\n    final Allele offAllele2 = off.getAllele(1);\r\n    if (p1.getAlleles().contains(offAllele1) && p2.getAlleles().contains(offAllele2))\r\n        return false;\r\n    if (p2.getAlleles().contains(offAllele1) && p1.getAlleles().contains(offAllele2))\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "net.pms.network.NetworkConfiguration.getAllAvailableAddresses",
	"Comment": "returns the list of discovered available addresses for the provided list\tof network interfaces.",
	"Method": "Set<InetAddress> getAllAvailableAddresses(Enumeration<NetworkInterface> networkInterfaces){\r\n    Set<InetAddress> addrSet = new HashSet<InetAddress>();\r\n    while (networkInterfaces.hasMoreElements()) {\r\n        NetworkInterface ni = networkInterfaces.nextElement();\r\n        Set<InetAddress> set = addressMap.get(ni.getName());\r\n        if (set != null) {\r\n            addrSet.addAll(set);\r\n        }\r\n    }\r\n    return addrSet;\r\n}"
}, {
	"Path": "prefuse.action.layout.AxisLabelLayout.getNumberFormat",
	"Comment": "get the formatter used to format labels for numerical values.",
	"Method": "NumberFormat getNumberFormat(){\r\n    return m_nf;\r\n}"
}, {
	"Path": "prefuse.data.expression.FunctionTable.addFunction",
	"Comment": "add a function to the function table. it will then become availablefor use with compiled statements of the prefuse expression language.",
	"Method": "void addFunction(String name,Class type){\r\n    if (!Function.class.isAssignableFrom(type)) {\r\n        throw new IllegalArgumentException(\"Type argument must be a subclass of FunctionExpression.\");\r\n    }\r\n    if (hasFunction(name)) {\r\n        throw new IllegalArgumentException(\"Function with that name already exists\");\r\n    }\r\n    String lo = name.toLowerCase();\r\n    String hi = name.toUpperCase();\r\n    if (!name.equals(lo) && !name.equals(hi))\r\n        throw new IllegalArgumentException(\"Name can't have mixed case, try \\\"\" + hi + \"\\\" instead.\");\r\n    s_functionTable.put(lo, type);\r\n    s_functionTable.put(hi, type);\r\n}"
}, {
	"Path": "quickfix.DataDictionary.isRequiredTrailerField",
	"Comment": "predicate for determining if a trailer field is a required field",
	"Method": "boolean isRequiredTrailerField(int field){\r\n    return isRequiredField(TRAILER_ID, field);\r\n}"
}, {
	"Path": "picard.analysis.MergeableMetricBase.canMerge",
	"Comment": "checks if this instance can be merged with anotherother must have all the fields that this instance has, andthe fields that are annotated as mergebyassertequals must contain the same value",
	"Method": "boolean canMerge(MergeableMetricBase other){\r\n    try {\r\n        for (final Field field : this.getClass().getDeclaredFields()) {\r\n            if (field.isSynthetic())\r\n                continue;\r\n            field.get(other);\r\n            final Annotation[] equalAnnotations = field.getAnnotationsByType(MergeByAssertEquals.class);\r\n            if (equalAnnotations.length != 0) {\r\n                if (field.get(this) == null)\r\n                    return true;\r\n                if (field.get(other) == null)\r\n                    return true;\r\n                if (!field.get(this).equals(field.get(other)))\r\n                    return false;\r\n            }\r\n        }\r\n    } catch (final Exception e) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "prefuse.data.expression.Literal.getLiteral",
	"Comment": "evaluate the given tuple and data field and return theresult as a new literal instance.",
	"Method": "Literal getLiteral(Tuple t,String field,Literal getLiteral,Object val,Literal getLiteral,Object val,Class type){\r\n    if (TypeLib.isNumericType(type)) {\r\n        return new NumericLiteral(val);\r\n    } else if (type == boolean.class) {\r\n        return new BooleanLiteral(((Boolean) val).booleanValue());\r\n    } else {\r\n        if (type.isInstance(val)) {\r\n            return new ObjectLiteral(val);\r\n        } else {\r\n            throw new IllegalArgumentException(\"Object does \" + \"not match the provided Class type.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.io.sql.DatabaseDataSource.getData",
	"Comment": "executes a query and returns the results in a table instance.",
	"Method": "Table getData(String query,Table getData,String query,String keyField,Table getData,Table t,String query,Table getData,Table t,String query,String keyField,Table getData,Table t,String query,String keyField,Object lock){\r\n    ResultSet rs;\r\n    try {\r\n        rs = executeQuery(query);\r\n    } catch (SQLException e) {\r\n        throw new DataIOException(e);\r\n    }\r\n    return process(t, rs, keyField, lock);\r\n}"
}, {
	"Path": "com.restfb.json.JsonArray.add",
	"Comment": "appends the json representation of the specified string to the end of this array.",
	"Method": "JsonArray add(int value,JsonArray add,long value,JsonArray add,float value,JsonArray add,double value,JsonArray add,boolean value,JsonArray add,String value,JsonArray add,JsonValue value){\r\n    if (value == null) {\r\n        throw new NullPointerException(\"value is null\");\r\n    }\r\n    values.add(value);\r\n    return this;\r\n}"
}, {
	"Path": "com.restfb.types.webhook.messaging.AccountLinkingItem.isUnlinked",
	"Comment": "convenience method to check the status of the account linking",
	"Method": "boolean isUnlinked(){\r\n    return UNLINKED.equals(status);\r\n}"
}, {
	"Path": "net.pms.dlna.RootFolder.parseFeedValue",
	"Comment": "splits the second part of a web.conf spec into a triple of strings\trepresenting the dlna path, resource uri and optional thumbnail uri.",
	"Method": "String[] parseFeedValue(String spec){\r\n    StringTokenizer st = new StringTokenizer(spec, \",\");\r\n    String[] triple = new String[3];\r\n    int i = 0;\r\n    while (st.hasMoreTokens()) {\r\n        triple[i++] = st.nextToken();\r\n    }\r\n    return triple;\r\n}"
}, {
	"Path": "picard.illumina.parser.PerTilePerCycleFileUtil.getFiles",
	"Comment": "returns a cycleilluminafilemap with all available tiles but limited to the cycles passed in.any cycles that are missingcycle files or directories will be removed from the cycle list that is kept.",
	"Method": "CycleIlluminaFileMap getFiles(CycleIlluminaFileMap getFiles,List<Integer> tiles,CycleIlluminaFileMap getFiles,int[] cycles,CycleIlluminaFileMap getFiles,List<Integer> tiles,int[] cycles){\r\n    final Set<Integer> filteredCycles = removeNonExistentCycles(cycles);\r\n    return cycleFileMap.keep(tiles, filteredCycles);\r\n}"
}, {
	"Path": "java.io.PushbackInputStream.skip",
	"Comment": "this method skips the specified number of bytes in the stream.itreturns the actual number of bytes skipped, which may be less than therequested amount.this method first discards bytes from the buffer, then calls theskip method on the underlying inputstream toskip additional bytes if necessary.",
	"Method": "long skip(long n){\r\n    final long origN = n;\r\n    if (n > 0L) {\r\n        int numread = (int) Math.min((long) (buf.length - pos), n);\r\n        pos += numread;\r\n        n -= numread;\r\n        if (n > 0)\r\n            n -= super.skip(n);\r\n    }\r\n    return origN - n;\r\n}"
}, {
	"Path": "picard.sam.SamToFastqWithTags.setupTagSplitValues",
	"Comment": "sets up the groupings of sequence tags, quality tags, and separator strings so we dont have to calculate them for every loop",
	"Method": "void setupTagSplitValues(){\r\n    SPLIT_SEQUENCE_TAGS = new ArrayList();\r\n    SPLIT_QUALITY_TAGS = new ArrayList();\r\n    SPLIT_SEPARATOR_TAGS = new ArrayList();\r\n    for (int i = 0; i < SEQUENCE_TAG_GROUP.size(); i++) {\r\n        SPLIT_SEQUENCE_TAGS.add(SEQUENCE_TAG_GROUP.get(i).trim().split(\",\"));\r\n        SPLIT_QUALITY_TAGS.add(QUALITY_TAG_GROUP.isEmpty() ? null : QUALITY_TAG_GROUP.get(i).trim().split(\",\"));\r\n        SPLIT_SEPARATOR_TAGS.add(TAG_GROUP_SEPERATOR.isEmpty() ? TAG_SPLIT_DEFAULT_SEP : TAG_GROUP_SEPERATOR.get(i));\r\n    }\r\n}"
}, {
	"Path": "peergos.shared.cbor.CborEncoder.writeInt",
	"Comment": "writes a signed or unsigned integer value in canonical cbor format, that is, tries to encode it in a little bytes as possible..",
	"Method": "void writeInt(long value){\r\n    long sign = value >> 63;\r\n    int mt = (int) (sign & NEG_INT_MASK);\r\n    value = (sign ^ value);\r\n    writeUInt(mt, value);\r\n}"
}, {
	"Path": "prefuse.action.layout.AxisLabelLayout.setAscending",
	"Comment": "sets if the axis values should be presented in ascending orderalong the axis.",
	"Method": "void setAscending(boolean asc){\r\n    m_asc = asc;\r\n}"
}, {
	"Path": "org.pcollections.tests.HashPMapTest.testRandomlyAgainstJavaMap",
	"Comment": "compares the behavior of java.util.hashmap to the behavior of hashtreepmap.",
	"Method": "void testRandomlyAgainstJavaMap(){\r\n    PMap<Integer, Integer> pmap = HashTreePMap.empty();\r\n    Map<Integer, Integer> map = new HashMap<Integer, Integer>();\r\n    Random r = new Random();\r\n    for (int i = 0; i < 10000; i++) {\r\n        if (pmap.size() == 0 || r.nextBoolean()) {\r\n            int k = r.nextInt(), v = r.nextInt();\r\n            assertEquals(map.containsKey(k), pmap.containsKey(k));\r\n            assertEquals(map.get(k), pmap.get(k));\r\n            map.put(k, v);\r\n            pmap = pmap.plus(k, v);\r\n        } else {\r\n            int j = r.nextInt(pmap.size());\r\n            for (Entry<Integer, Integer> e : pmap.entrySet()) {\r\n                int k = e.getKey();\r\n                assertTrue(map.containsKey(k));\r\n                assertTrue(pmap.containsKey(k));\r\n                assertEquals(map.get(k), pmap.get(k));\r\n                assertTrue(map.entrySet().contains(e));\r\n                assertTrue(pmap.entrySet().contains(e));\r\n                UtilityTest.assertEqualsAndHash(pmap, pmap.plus(k, e.getValue()));\r\n                if (j-- == 0) {\r\n                    map.remove(k);\r\n                    pmap = pmap.minus(k);\r\n                    assertFalse(pmap.entrySet().contains(e));\r\n                }\r\n            }\r\n        }\r\n        int k = r.nextInt();\r\n        assertEquals(map.containsKey(k), pmap.containsKey(k));\r\n        assertEquals(map.get(k), pmap.get(k));\r\n        map.remove(k);\r\n        pmap = pmap.minus(k);\r\n        String s = Integer.toString(k);\r\n        assertFalse(pmap.containsKey(s));\r\n        assertEquals(null, pmap.get(s));\r\n        assertFalse(pmap.entrySet().contains(s));\r\n        pmap = pmap.minus(s);\r\n        assertEquals(map.size(), pmap.size());\r\n        UtilityTest.assertEqualsAndHash(map, pmap);\r\n        UtilityTest.assertEqualsAndHash(map.entrySet(), pmap.entrySet());\r\n        UtilityTest.assertEqualsAndHash(pmap, HashTreePMap.from(pmap));\r\n        UtilityTest.assertEqualsAndHash(HashTreePMap.empty(), pmap.minusAll(pmap.keySet()));\r\n        UtilityTest.assertEqualsAndHash(pmap, pmap.plusAll(pmap));\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Base64Coder.encode",
	"Comment": "encodes a byte array into base64 format. no blanks or line breaks are inserted in the output.",
	"Method": "char[] encode(byte[] in,char[] encode,byte[] in,CharMap charMap,char[] encode,byte[] in,char[] charMap,char[] encode,byte[] in,int iLen,char[] encode,byte[] in,int iOff,int iLen,CharMap charMap,char[] encode,byte[] in,int iOff,int iLen,char[] charMap){\r\n    int oDataLen = (iLen * 4 + 2) / 3;\r\n    int oLen = ((iLen + 2) / 3) * 4;\r\n    char[] out = new char[oLen];\r\n    int ip = iOff;\r\n    int iEnd = iOff + iLen;\r\n    int op = 0;\r\n    while (ip < iEnd) {\r\n        int i0 = in[ip++] & 0xff;\r\n        int i1 = ip < iEnd ? in[ip++] & 0xff : 0;\r\n        int i2 = ip < iEnd ? in[ip++] & 0xff : 0;\r\n        int o0 = i0 >>> 2;\r\n        int o1 = ((i0 & 3) << 4) | (i1 >>> 4);\r\n        int o2 = ((i1 & 0xf) << 2) | (i2 >>> 6);\r\n        int o3 = i2 & 0x3F;\r\n        out[op++] = charMap[o0];\r\n        out[op++] = charMap[o1];\r\n        out[op] = op < oDataLen ? charMap[o2] : '=';\r\n        op++;\r\n        out[op] = op < oDataLen ? charMap[o3] : '=';\r\n        op++;\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "prefuse.data.Table.canSetDate",
	"Comment": "check if the setdate method can safely be used for thegiven data field.",
	"Method": "boolean canSetDate(String field){\r\n    Column col = getColumn(field);\r\n    return (col == null ? false : col.canSetDate());\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeMap.getSnp",
	"Comment": "queries a snp by chromosome and position. returns null if none found.",
	"Method": "Snp getSnp(String chrom,int pos){\r\n    return this.snpsByPosition.get(toKey(chrom, pos));\r\n}"
}, {
	"Path": "picard.sam.RevertSam.fetchByReadName",
	"Comment": "generates a list by consuming from the iterator in order starting with the first availableread and continuing while subsequent reads share the same read name. if there are no readsremaining returns an empty list.",
	"Method": "List<SAMRecord> fetchByReadName(PeekableIterator<SAMRecord> iterator){\r\n    final List<SAMRecord> out = new ArrayList();\r\n    if (iterator.hasNext()) {\r\n        final SAMRecord first = iterator.next();\r\n        out.add(first);\r\n        while (iterator.hasNext() && iterator.peek().getReadName().equals(first.getReadName())) {\r\n            out.add(iterator.next());\r\n        }\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "prefuse.data.query.ListQueryBinding.createCheckboxGroup",
	"Comment": "creates a new group of check boxes for interacting with the query.",
	"Method": "JToggleGroup createCheckboxGroup(){\r\n    return createToggleGroup(JToggleGroup.CHECKBOX);\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAMediaAudio.isNonPCMEncodedAudio",
	"Comment": "returns true if this media uses an ac3, dts or truehd codec, false otherwise.",
	"Method": "boolean isNonPCMEncodedAudio(){\r\n    return isAC3() || isDTS() || isTrueHD();\r\n}"
}, {
	"Path": "prefuse.util.FontLib.getFont",
	"Comment": "get a font instance with the given font family name, style, and size",
	"Method": "Font getFont(String name,double size,Font getFont,String name,int style,double size,Font getFont,String name,int style,int size){\r\n    int key = (name.hashCode() << 8) + (size << 2) + style;\r\n    Font f = null;\r\n    if ((f = (Font) fontMap.get(key)) == null) {\r\n        f = new Font(name, style, size);\r\n        fontMap.put(key, f);\r\n        misses++;\r\n    }\r\n    lookups++;\r\n    return f;\r\n}"
}, {
	"Path": "prefuse.action.assignment.FontAction.setDefaultFont",
	"Comment": "set the default font to be assigned to items. items will be assignedthe default font if they do not match any registered rules.",
	"Method": "void setDefaultFont(Font f){\r\n    defaultFont = f;\r\n}"
}, {
	"Path": "net.paoding.rose.jade.rowmapper.BeanPropertyRowMapper.mapRow",
	"Comment": "extract the values for all columns in the current row.utilizes public setters and result set metadata.",
	"Method": "Object mapRow(ResultSet rs,int rowNumber){\r\n    Object mappedObject = instantiateClass(this.mappedClass);\r\n    BeanWrapper bw = new BeanWrapperImpl(mappedObject);\r\n    ResultSetMetaData rsmd = rs.getMetaData();\r\n    int columnCount = rsmd.getColumnCount();\r\n    boolean warnEnabled = logger.isWarnEnabled();\r\n    boolean debugEnabled = logger.isDebugEnabled();\r\n    Set<String> populatedProperties = (checkProperties ? new HashSet<String>() : null);\r\n    for (int index = 1; index <= columnCount; index++) {\r\n        String column = JdbcUtils.lookupColumnName(rsmd, index).toLowerCase();\r\n        PropertyDescriptor pd = this.mappedFields.get(column);\r\n        if (pd != null) {\r\n            try {\r\n                Object value = JdbcUtils.getResultSetValue(rs, index, pd.getPropertyType());\r\n                if (debugEnabled && rowNumber == 0) {\r\n                    logger.debug(\"Mapping column '\" + column + \"' to property '\" + pd.getName() + \"' of type \" + pd.getPropertyType());\r\n                }\r\n                bw.setPropertyValue(pd.getName(), value);\r\n                if (populatedProperties != null) {\r\n                    populatedProperties.add(pd.getName());\r\n                }\r\n            } catch (NotWritablePropertyException ex) {\r\n                throw new DataRetrievalFailureException(\"Unable to map column \" + column + \" to property \" + pd.getName(), ex);\r\n            }\r\n        } else {\r\n            if (checkColumns) {\r\n                throw new InvalidDataAccessApiUsageException(\"Unable to map column '\" + column + \"' to any properties of bean \" + this.mappedClass.getName());\r\n            }\r\n            if (warnEnabled && rowNumber == 0) {\r\n                logger.warn(\"Unable to map column '\" + column + \"' to any properties of bean \" + this.mappedClass.getName());\r\n            }\r\n        }\r\n    }\r\n    if (populatedProperties != null && !populatedProperties.equals(this.mappedProperties)) {\r\n        throw new InvalidDataAccessApiUsageException(\"Given ResultSet does not contain all fields \" + \"necessary to populate object of class [\" + this.mappedClass + \"]: \" + this.mappedProperties);\r\n    }\r\n    return mappedObject;\r\n}"
}, {
	"Path": "com.restfb.types.Account.getPerms",
	"Comment": "a list of permissions the user has for this page.see roles list here",
	"Method": "List<String> getPerms(){\r\n    return unmodifiableList(perms);\r\n}"
}, {
	"Path": "picard.sam.markduplicates.ElcHashBasedDuplicatesFinder.initHashLength",
	"Comment": "calculate hash length based on minreadlength and numberofhashesingroup",
	"Method": "void initHashLength(List<PairedReadSequence> sequences){\r\n    for (PairedReadSequence prs : sequences) {\r\n        int minReadLength = Math.min(Math.min(prs.read1.length, prs.read2.length), maxReadLength);\r\n        int numberOfHashes = (int) ((minReadLength - minIdenticalBases) * maxDiffRate) + 1;\r\n        if (numberOfHashes > numberOfHashesInGroup) {\r\n            numberOfHashesInGroup = numberOfHashes;\r\n        }\r\n        if (minReadLenInGroup > minReadLength) {\r\n            minReadLenInGroup = minReadLength;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.PrefuseLib.getMinimalVisualSchema",
	"Comment": "get the minimal schema needed for a unique visualitem. can be usefulfor derived groups that inherit other visual properties from aanother visual data group.",
	"Method": "Schema getMinimalVisualSchema(){\r\n    Schema s = new Schema();\r\n    s.addColumn(VisualItem.VALIDATED, boolean.class, Boolean.FALSE);\r\n    s.addColumn(VisualItem.VISIBLE, boolean.class, Boolean.TRUE);\r\n    s.addColumn(VisualItem.STARTVISIBLE, boolean.class, Boolean.FALSE);\r\n    s.addColumn(VisualItem.ENDVISIBLE, boolean.class, Boolean.TRUE);\r\n    s.addColumn(VisualItem.INTERACTIVE, boolean.class, Boolean.TRUE);\r\n    s.addColumn(VisualItem.BOUNDS, Rectangle2D.class, new Rectangle2D.Double());\r\n    return s;\r\n}"
}, {
	"Path": "net.pms.PMS.getDatabase",
	"Comment": "used to get the database. needed in the case of the xbox 360, that requires a database.\tfor its queries.",
	"Method": "DLNAMediaDatabase getDatabase(){\r\n    if (configuration.getUseCache()) {\r\n        if (database == null) {\r\n            initializeDatabase();\r\n        }\r\n        return database;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.getDefaultRenderer",
	"Comment": "returns the default renderer configuration for this resource.",
	"Method": "RendererConfiguration getDefaultRenderer(){\r\n    return defaultRenderer;\r\n}"
}, {
	"Path": "picard.analysis.CollectAlignmentSummaryMetrics.makeReferenceArgumentCollection",
	"Comment": "overridden to make it visible on the commandline and to change the doc.",
	"Method": "ReferenceArgumentCollection makeReferenceArgumentCollection(){\r\n    return new CollectAlignmentRefArgCollection();\r\n}"
}, {
	"Path": "prefuse.util.ColorMap.getMinValue",
	"Comment": "gets the minimum value that corresponds to the firstcolor in the color map.",
	"Method": "double getMinValue(){\r\n    return minValue;\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAMediaAudio.isPCM",
	"Comment": "returns true if this media uses audio that is pcm encoded, false otherwise.",
	"Method": "boolean isPCM(){\r\n    return getCodecA() != null && (getCodecA().startsWith(\"pcm\") || getCodecA().equals(\"LPCM\"));\r\n}"
}, {
	"Path": "prefuse.action.layout.StackedAreaChart.getThreshold",
	"Comment": "get the minimum height threshold under which stacks should not bemade visible.",
	"Method": "double getThreshold(){\r\n    return m_threshold;\r\n}"
}, {
	"Path": "picard.illumina.parser.IlluminaDataProviderFactory.findUnmatchedTypes",
	"Comment": "given a set of formats to data types they provide, find any requested data types that do not have a format associated with them and return them",
	"Method": "Set<IlluminaDataType> findUnmatchedTypes(Set<IlluminaDataType> requestedDataTypes,Map<SupportedIlluminaFormat, Set<IlluminaDataType>> formatToMatchedTypes){\r\n    final Set<IlluminaDataType> copiedTypes = new HashSet(requestedDataTypes);\r\n    for (final Set<IlluminaDataType> matchedTypes : formatToMatchedTypes.values()) {\r\n        copiedTypes.removeAll(matchedTypes);\r\n    }\r\n    return copiedTypes;\r\n}"
}, {
	"Path": "prefuse.util.PrefuseLib.getGroupName",
	"Comment": "get the group name for the given parent and child group, simplyconcatenating them together with a group delimiter in between.",
	"Method": "String getGroupName(String parent,String child){\r\n    return parent + GROUP_DELIMITER + child;\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.getId",
	"Comment": "returns the id of this resource based on the index in its parent\tcontainer. its main purpose is to be unique in the parent container.",
	"Method": "String getId(){\r\n    return id;\r\n}"
}, {
	"Path": "picard.fingerprint.CrosscheckFingerprints.checkFingerprintsBySample",
	"Comment": "method that checks each sample from fingerprints1 against that sample from fingerprints2 and reports a lod score for the two groupscoming from the same individual.",
	"Method": "int checkFingerprintsBySample(Map<FingerprintIdDetails, Fingerprint> fingerprints1,Map<FingerprintIdDetails, Fingerprint> fingerprints2,List<CrosscheckMetric> metrics){\r\n    int unexpectedResults = 0;\r\n    final Map<FingerprintIdDetails, Fingerprint> fingerprints1BySample = mergeFingerprintsBy(fingerprints1, getFingerprintIdDetailsStringFunction(CrosscheckMetric.DataType.SAMPLE));\r\n    final Map<FingerprintIdDetails, Fingerprint> fingerprints2BySample = mergeFingerprintsBy(fingerprints2, getFingerprintIdDetailsStringFunction(CrosscheckMetric.DataType.SAMPLE));\r\n    final Map<String, FingerprintIdDetails> sampleToDetail1 = fingerprints1BySample.keySet().stream().collect(Collectors.toMap(id -> id.group, id -> id));\r\n    final Map<String, FingerprintIdDetails> sampleToDetail2 = fingerprints2BySample.keySet().stream().collect(Collectors.toMap(id -> id.group, id -> id));\r\n    Set<String> samples = new HashSet();\r\n    samples.addAll(sampleToDetail1.keySet());\r\n    samples.addAll(sampleToDetail2.keySet());\r\n    for (final String sample : samples) {\r\n        final FingerprintIdDetails lhsID = sampleToDetail1.get(sample);\r\n        final FingerprintIdDetails rhsID = sampleToDetail2.get(sample);\r\n        if (lhsID == null || rhsID == null) {\r\n            log.error(String.format(\"sample %s is missing from %s group\", sample, lhsID == null ? \"LEFT\" : \"RIGHT\"));\r\n            unexpectedResults++;\r\n            continue;\r\n        }\r\n        final MatchResults results = FingerprintChecker.calculateMatchResults(fingerprints1BySample.get(lhsID), fingerprints2BySample.get(rhsID), GENOTYPING_ERROR_RATE, LOSS_OF_HET_RATE, false, CALCULATE_TUMOR_AWARE_RESULTS);\r\n        final CrosscheckMetric.FingerprintResult result = getMatchResults(true, results);\r\n        if (!OUTPUT_ERRORS_ONLY || !result.isExpected()) {\r\n            metrics.add(getMatchDetails(result, results, lhsID, rhsID, CrosscheckMetric.DataType.SAMPLE));\r\n        }\r\n        if (result != FingerprintResult.INCONCLUSIVE && !result.isExpected())\r\n            unexpectedResults++;\r\n    }\r\n    return unexpectedResults;\r\n}"
}, {
	"Path": "prefuse.util.ui.PrefuseTableModel.initRowMap",
	"Comment": "initialize mapping between prefuse table rows and the rows reportedby this model.",
	"Method": "void initRowMap(){\r\n    m_rowmap = new int[m_table.getRowCount()];\r\n    IntIterator rows = m_table.rows();\r\n    for (int i = 0; rows.hasNext(); ++i) {\r\n        m_rowmap[i] = rows.nextInt();\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.addNodeRow",
	"Comment": "unsupported operation. spanning trees should not be edited.",
	"Method": "int addNodeRow(){\r\n    throw new UnsupportedOperationException(\"Changes to graph structure not allowed for spanning trees.\");\r\n}"
}, {
	"Path": "org.quickfixj.codegenerator.GenerateMojo.getDictFile",
	"Comment": "returns the dictionary file for which code generation should be executed.",
	"Method": "File getDictFile(){\r\n    return dictFile;\r\n}"
}, {
	"Path": "net.pms.io.BasicSystemUtils.getPingCommand",
	"Comment": "return the platform specific ping command for the given host address,\tping count and packet size.",
	"Method": "String[] getPingCommand(String hostAddress,int count,int packetSize){\r\n    return new String[] { \"ping\", \"-c\", Integer.toString(count), \"-s\", Integer.toString(packetSize), hostAddress };\r\n}"
}, {
	"Path": "prefuse.activity.Activity.alwaysRunAfter",
	"Comment": "schedules this activity to start immediately after another activity.this activity will be scheduled to start immediately after thefirst one finishes, overwriting any previously set starttime. if thefirst activity is cancelled, this one will not run.this functionality is provided by using an activitylistener to monitorthe first activity. the listener will persist across mulitple runs,meaning the second activity will always be evoked upon a successfulfinish of the first.this method does not in any way affect the scheduling of the first activity. if the first activity is never scheduled, this activitywill correspondingly never be run unless scheduled by a separatescheduling call.",
	"Method": "void alwaysRunAfter(Activity before){\r\n    ActivityManager.alwaysScheduleAfter(before, this);\r\n}"
}, {
	"Path": "prefuse.data.io.AbstractTextTableReader.getColumnNames",
	"Comment": "subclasses can override this to provide column names througha custom mechanism.",
	"Method": "ArrayList getColumnNames(){\r\n    return new ArrayList();\r\n}"
}, {
	"Path": "net.pms.test.formats.FormatRecognitionTest.testPlaystationVideoMkvCompatibility",
	"Comment": "test the compatibility of the playstation 3 with the mpg format.",
	"Method": "void testPlaystationVideoMkvCompatibility(){\r\n    assumeTrue(mediaInfoParserIsValid);\r\n    RendererConfiguration conf = RendererConfiguration.getRendererConfigurationByName(\"Playstation 3\");\r\n    assertNotNull(\"Renderer named \\\"Playstation 3\\\" found.\", conf);\r\n    DLNAMediaInfo info = new DLNAMediaInfo();\r\n    info.setContainer(\"mkv\");\r\n    DLNAMediaAudio audio = new DLNAMediaAudio();\r\n    audio.setCodecA(\"ac3\");\r\n    audio.getAudioProperties().setNumberOfChannels(5);\r\n    List<DLNAMediaAudio> audioCodes = new ArrayList<DLNAMediaAudio>();\r\n    audioCodes.add(audio);\r\n    info.setAudioTracksList(audioCodes);\r\n    info.setCodecV(\"mp4\");\r\n    Format format = new MPG();\r\n    format.match(\"test.mkv\");\r\n    assertEquals(\"PS3 is incompatible with MKV\", false, conf.isCompatible(info, format));\r\n}"
}, {
	"Path": "prefuse.action.filter.FisheyeTreeFilter.getSources",
	"Comment": "get the name of the group to use as source nodes for measuringgraph distance. these form the roots from which the graph distanceis measured.",
	"Method": "String getSources(){\r\n    return m_sources;\r\n}"
}, {
	"Path": "com.restfb.json.PrettyPrint.indentWithSpaces",
	"Comment": "print every value on a separate line. use the given number of spaces for indentation.",
	"Method": "PrettyPrint indentWithSpaces(int number){\r\n    if (number < 0) {\r\n        throw new IllegalArgumentException(\"number is negative\");\r\n    }\r\n    char[] chars = new char[number];\r\n    Arrays.fill(chars, ' ');\r\n    return new PrettyPrint(chars);\r\n}"
}, {
	"Path": "prefuse.Visualization.addGraph",
	"Comment": "adds a graph to this visualization, using the given data groupname. a visual abstraction of the data will be created and registeredwith the visualization. an exception will be thrown if the group nameis already in use.",
	"Method": "VisualGraph addGraph(String group,Graph graph,VisualGraph addGraph,String group,Graph graph,Predicate filter,VisualGraph addGraph,String group,Graph graph,Predicate filter,Schema nodeSchema,Schema edgeSchema){\r\n    checkGroupExists(group);\r\n    String ngroup = PrefuseLib.getGroupName(group, Graph.NODES);\r\n    String egroup = PrefuseLib.getGroupName(group, Graph.EDGES);\r\n    VisualTable nt, et;\r\n    nt = addTable(ngroup, graph.getNodeTable(), filter, nodeSchema);\r\n    et = addTable(egroup, graph.getEdgeTable(), filter, edgeSchema);\r\n    VisualGraph vg = new VisualGraph(nt, et, graph.isDirected(), graph.getNodeKeyField(), graph.getEdgeSourceField(), graph.getEdgeTargetField());\r\n    vg.setVisualization(this);\r\n    vg.setGroup(group);\r\n    addDataGroup(group, vg, graph);\r\n    TupleManager ntm = new TupleManager(nt, vg, TableNodeItem.class);\r\n    TupleManager etm = new TupleManager(et, vg, TableEdgeItem.class);\r\n    nt.setTupleManager(ntm);\r\n    et.setTupleManager(etm);\r\n    vg.setTupleManagers(ntm, etm);\r\n    return vg;\r\n}"
}, {
	"Path": "prefuse.util.collections.AbstractHashMap.setUp",
	"Comment": "initializes the receiver. you will almost certainly need to override thismethod in subclasses to initialize the hash table.",
	"Method": "void setUp(int initialCapacity,double minLoadFactor,double maxLoadFactor){\r\n    if (initialCapacity < 0)\r\n        throw new IllegalArgumentException(\"Initial Capacity must not be less than zero: \" + initialCapacity);\r\n    if (minLoadFactor < 0.0 || minLoadFactor >= 1.0)\r\n        throw new IllegalArgumentException(\"Illegal minLoadFactor: \" + minLoadFactor);\r\n    if (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0)\r\n        throw new IllegalArgumentException(\"Illegal maxLoadFactor: \" + maxLoadFactor);\r\n    if (minLoadFactor >= maxLoadFactor)\r\n        throw new IllegalArgumentException(\"Illegal minLoadFactor: \" + minLoadFactor + \" and maxLoadFactor: \" + maxLoadFactor);\r\n}"
}, {
	"Path": "picard.util.MathUtil.indexOfMax",
	"Comment": "returns the index of the largest element in the array.if there are multiple equal maxima thenthe earliest one in the array is returned.",
	"Method": "int indexOfMax(double[] nums,int indexOfMax,long[] nums){\r\n    long max = nums[0];\r\n    int index = 0;\r\n    for (int i = 1; i < nums.length; ++i) {\r\n        if (nums[i] > max) {\r\n            max = nums[i];\r\n            index = i;\r\n        }\r\n    }\r\n    return index;\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.canSetDouble",
	"Comment": "indicates if convenience set method can be called withoutan exception being thrown for the double type.",
	"Method": "boolean canSetDouble(){\r\n    return canSet(double.class);\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.RadialTreeLayout.reset",
	"Comment": "clears references to graph tuples.the group and visualization areretained.",
	"Method": "void reset(){\r\n    super.reset();\r\n    m_prevRoot = null;\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.Showcase.injectThemeStyleSheet",
	"Comment": "inject the gwt theme style sheet based on the rtl direction of the currentlocale.",
	"Method": "void injectThemeStyleSheet(){\r\n    String styleSheet = \"gwt/\" + THEME + \"/\" + THEME;\r\n    styleSheet += LocaleInfo.getCurrentLocale().isRTL() ? \"_rtl.css\" : \".css\";\r\n    String modulePath = GWT.getModuleBaseURL();\r\n    LinkElement linkElem = Document.get().createLinkElement();\r\n    linkElem.setRel(\"stylesheet\");\r\n    linkElem.setType(\"text/css\");\r\n    linkElem.setHref(modulePath + styleSheet);\r\n    getHeadElement().appendChild(linkElem);\r\n}"
}, {
	"Path": "picard.sam.markduplicates.MarkDuplicatesWithMateCigarIterator.flush",
	"Comment": "gets a samrecord if one is available after marking.this enforces that we return records in the originalcoordinate sort order in a stable fashion.",
	"Method": "SAMRecord flush(){\r\n    while (!outputBuffer.isEmpty() && outputBuffer.canEmit()) {\r\n        final SAMRecord record = outputBuffer.next().getRecord();\r\n        if (!removeDuplicates || !record.getDuplicateReadFlag()) {\r\n            return record;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "prefuse.util.io.XMLWriter.end",
	"Comment": "close the most recently opened tag. the tag will be followed by anewline, and the indentation level will be decreased.",
	"Method": "void end(){\r\n    String tag = (String) m_tagStack.remove(m_tagStack.size() - 1);\r\n    spacing();\r\n    m_out.print('<');\r\n    m_out.print('/');\r\n    m_out.print(tag);\r\n    m_out.print('>');\r\n    println();\r\n}"
}, {
	"Path": "picard.util.AdapterMarker.substringAndRemoveTrailingNs",
	"Comment": "truncate to the given length, and in addition truncate any trailing ns.",
	"Method": "String substringAndRemoveTrailingNs(String s,int length){\r\n    length = Math.min(length, s.length());\r\n    final byte[] bytes = StringUtil.stringToBytes(s);\r\n    while (length > 0 && SequenceUtil.isNoCall(bytes[length - 1])) {\r\n        length--;\r\n    }\r\n    return s.substring(0, length);\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.isInteractive",
	"Comment": "indicates if this item is interactive, meaning it can potentiallyrespond to mouse and keyboard input events.",
	"Method": "boolean isInteractive(int row){\r\n    return getBoolean(row, VisualItem.INTERACTIVE);\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.ForceDirectedLayout.setMaxTimeStep",
	"Comment": "set the maximum timestep allowed for integrating node settings betweenruns of this layout. when computation times are longer than desired,and node positions are changing dramatically between animated frames,the max step time can be lowered to suppress node movement.",
	"Method": "void setMaxTimeStep(long maxstep){\r\n    this.m_maxstep = maxstep;\r\n}"
}, {
	"Path": "quickfix.Session.isSessionTime",
	"Comment": "predicate for determining if the session should be active at the currenttime.",
	"Method": "boolean isSessionTime(){\r\n    return sessionSchedule == null || sessionSchedule.isSessionTime();\r\n}"
}, {
	"Path": "picard.vcf.filter.TestFilterVcf.slurpFilters",
	"Comment": "consumes a vcf and returns a listmap where each they keys are the ids of filtered out sites and the values are the set of filters.",
	"Method": "ListMap<String, String> slurpFilters(File vcf){\r\n    final ListMap<String, String> map = new ListMap();\r\n    final VCFFileReader in = new VCFFileReader(vcf, false);\r\n    for (final VariantContext ctx : in) {\r\n        if (ctx.isNotFiltered())\r\n            continue;\r\n        for (final String filter : ctx.getFilters()) {\r\n            map.add(ctx.getID(), filter);\r\n        }\r\n    }\r\n    in.close();\r\n    return map;\r\n}"
}, {
	"Path": "net.pms.configuration.RendererConfiguration.isCompatible",
	"Comment": "returns whether or not the renderer can handle the given format\tnatively, based on its configuration in the renderer.conf. if it can\thandle a format natively, content can be streamed to the renderer. if\tnot, content should be transcoded before sending it to the renderer.",
	"Method": "boolean isCompatible(DLNAMediaInfo mediainfo,Format format){\r\n    if (isMediaParserV2() && mediainfo != null && getFormatConfiguration().match(mediainfo) != null) {\r\n        return true;\r\n    }\r\n    if (format != null) {\r\n        String noTranscode = \"\";\r\n        if (PMS.getConfiguration() != null) {\r\n            noTranscode = PMS.getConfiguration().getDisableTranscodeForExtensions();\r\n        }\r\n        return format.skip(noTranscode, getStreamedExtensions());\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.isAvisynth",
	"Comment": "returns whether or not this resource is handled by avisynth.",
	"Method": "boolean isAvisynth(){\r\n    return avisynth;\r\n}"
}, {
	"Path": "picard.sam.markduplicates.MarkDuplicatesWithMateCigarIterator.getNumRecordsWithNoMateCigar",
	"Comment": "useful for statistics after the iterator has been exhausted and closed.",
	"Method": "int getNumRecordsWithNoMateCigar(){\r\n    enforceClosed();\r\n    return numRecordsWithNoMateCigar;\r\n}"
}, {
	"Path": "com.google.gwt.sample.dynatablerf.client.widgets.DayCheckBox.onLoad",
	"Comment": "attach to the event bus only when the widget is actually attached to thedom.",
	"Method": "void onLoad(){\r\n    filterRegistration = eventBus.addHandler(FilterChangeEvent.TYPE, new FilterChangeEvent.Handler() {\r\n        public void onFilterChanged(FilterChangeEvent e) {\r\n            if (e.getDay() == getDay()) {\r\n                setValue(e.isSelected());\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.google.gwt.sample.dynatablerf.client.widgets.DayCheckBox.onLoad",
	"Comment": "attach to the event bus only when the widget is actually attached to thedom.",
	"Method": "void onLoad(){\r\n    if (e.getDay() == getDay()) {\r\n        setValue(e.isSelected());\r\n    }\r\n}"
}, {
	"Path": "net.pms.util.FormLayoutUtil.flipHorizontally",
	"Comment": "creates and returns a horizontally flipped clone of the given cell\tconstraints object with the grid position adjusted to the given column\tcount. flips the horizontal alignment and the left and right insets. and\tswaps the left and right cell positions according to the specified column\tcount.",
	"Method": "CellConstraints flipHorizontally(CellConstraints cc,CellConstraints flipHorizontally,CellConstraints cc,int columnCount){\r\n    CellConstraints flipped = flipHorizontally(cc);\r\n    flipped.gridX = columnCount + 1 - cc.gridX - cc.gridWidth + 1;\r\n    return flipped;\r\n}"
}, {
	"Path": "prefuse.data.util.TableIterator.canGetBoolean",
	"Comment": "check if the given data field can return primitive booleanvalues.",
	"Method": "boolean canGetBoolean(String field){\r\n    return m_table.canGetBoolean(field);\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.isVisible",
	"Comment": "indicates if the given row is currently set to be visible. items withthe visible flag set false will not be drawn by a display. invisibleitems are also by necessity not interactive, regardless of the value ofthe interactive flag.",
	"Method": "boolean isVisible(int row){\r\n    return getBoolean(row, VisualItem.VISIBLE);\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.setNoName",
	"Comment": "sets whether or not this is a nameless resource. this is particularly\tuseful in the virtual transcode folder for a file, where the same file\tis copied many times with different audio and subtitle settings. in that\tcase the name of the file becomes irrelevant and only the settings\tneed to be shown.",
	"Method": "void setNoName(boolean noName){\r\n    this.noName = noName;\r\n}"
}, {
	"Path": "net.pms.io.OutputParams.manageFastStart",
	"Comment": "set some values to allow fast streaming start of transcoded videos",
	"Method": "void manageFastStart(){\r\n    if (mediaRenderer != null && mediaRenderer.isTranscodeFastStart()) {\r\n        waitbeforestart = 0;\r\n        minBufferSize = 1;\r\n    }\r\n}"
}, {
	"Path": "picard.cmdline.CommandLineProgram.getMetricsFile",
	"Comment": "gets a metricsfile with default headers already written into it.",
	"Method": "MetricsFile<A, B> getMetricsFile(){\r\n    final MetricsFile<A, B> file = new MetricsFile();\r\n    for (final Header h : this.defaultHeaders) {\r\n        file.addHeader(h);\r\n    }\r\n    return file;\r\n}"
}, {
	"Path": "prefuse.data.column.DateColumn.canSet",
	"Comment": "indicates if the set method can be called withoutan exception being thrown for the given type.",
	"Method": "boolean canSet(Class type){\r\n    if (type == null)\r\n        return false;\r\n    if (Number.class.isAssignableFrom(type) || String.class.isAssignableFrom(type)) {\r\n        return true;\r\n    } else {\r\n        return m_columnType.isAssignableFrom(type);\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.DataLib.mean",
	"Comment": "get the mean value of a tuple data value. if any tuple does not have thenamed field or the field is not a numeric data type, nan will be returned.",
	"Method": "double mean(Iterator tuples,String field){\r\n    try {\r\n        int count = 0;\r\n        double sum = 0;\r\n        while (tuples.hasNext()) {\r\n            sum += ((Tuple) tuples.next()).getDouble(field);\r\n            ++count;\r\n        }\r\n        return sum / count;\r\n    } catch (Exception e) {\r\n        return Double.NaN;\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.TimeLib.getUnitsBetween",
	"Comment": "get the number of time units between the two given timestamps.",
	"Method": "int getUnitsBetween(long t0,long t1,int field){\r\n    boolean negative = false;\r\n    if (t1 < t0) {\r\n        long tmp = t1;\r\n        t1 = t0;\r\n        t0 = tmp;\r\n        negative = true;\r\n    }\r\n    GregorianCalendar gc1 = new GregorianCalendar();\r\n    GregorianCalendar gc2 = new GregorianCalendar();\r\n    gc1.setTimeInMillis(t0);\r\n    gc2.setTimeInMillis(t1);\r\n    int est = estimateUnitsBetween(t0, t1, field);\r\n    boolean multiYear = isMultiYear(field);\r\n    if (multiYear) {\r\n        gc1.add(Calendar.YEAR, -field * (est - 2));\r\n        est = -field * est;\r\n    } else {\r\n        gc1.add(field, est - 2);\r\n    }\r\n    int f = multiYear ? Calendar.YEAR : field;\r\n    int inc = multiYear ? -field : 1;\r\n    for (int i = est - inc; ; i += inc) {\r\n        gc1.add(f, inc);\r\n        if (gc1.after(gc2)) {\r\n            return negative ? inc - i : i - inc;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.pms.network.NetworkConfiguration.getAddressForNetworkInterfaceName",
	"Comment": "returns the default ip address associated with the the given interface name,\tor null if it has not been discovered.",
	"Method": "InterfaceAssociation getAddressForNetworkInterfaceName(String name){\r\n    return mainAddress.get(name);\r\n}"
}, {
	"Path": "quickfix.SessionSettings.isSetting",
	"Comment": "predicate for determining if a setting is in the default section.",
	"Method": "boolean isSetting(String key,boolean isSetting,SessionID sessionID,String key){\r\n    return getOrCreateSessionProperties(sessionID).getProperty(key) != null;\r\n}"
}, {
	"Path": "quickfix.Session.getExpectedSenderNum",
	"Comment": "retrieves the expected sender sequence number. this method is notsynchronized.",
	"Method": "int getExpectedSenderNum(){\r\n    try {\r\n        return state.getMessageStore().getNextSenderMsgSeqNum();\r\n    } catch (final IOException e) {\r\n        getLog().onErrorEvent(\"getNextSenderMsgSeqNum failed: \" + e.getMessage());\r\n        return -1;\r\n    }\r\n}"
}, {
	"Path": "com.handsomezhou.contactssearch.util.ViewUtil.setHideIme",
	"Comment": "hide soft keyboard on android after clicking outside edittext",
	"Method": "void setHideIme(Activity activity,View view){\r\n    if (null == activity || null == view) {\r\n        return;\r\n    }\r\n    if (!(view instanceof EditText)) {\r\n        view.setOnTouchListener(new OnTouchListener() {\r\n            @Override\r\n            public boolean onTouch(View v, MotionEvent event) {\r\n                ViewUtil.hideSoftKeyboard(activity);\r\n                return false;\r\n            }\r\n        });\r\n    }\r\n    if (view instanceof ViewGroup) {\r\n        for (int i = 0; i < ((ViewGroup) view).getChildCount(); i++) {\r\n            View innerView = ((ViewGroup) view).getChildAt(i);\r\n            setHideIme(activity, innerView);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.handsomezhou.contactssearch.util.ViewUtil.setHideIme",
	"Comment": "hide soft keyboard on android after clicking outside edittext",
	"Method": "void setHideIme(Activity activity,View view){\r\n    ViewUtil.hideSoftKeyboard(activity);\r\n    return false;\r\n}"
}, {
	"Path": "picard.fingerprint.CrosscheckFingerprints.crossCheckGrouped",
	"Comment": "method that crosschecks fingerprints from one list of fingerprints against those in anotherputting the results in a list of crosscheckmetics.",
	"Method": "int crossCheckGrouped(Map<FingerprintIdDetails, Fingerprint> lhsFingerprints,Map<FingerprintIdDetails, Fingerprint> rhsFingerprints,List<CrosscheckMetric> metrics,Function<FingerprintIdDetails, String> by,CrosscheckMetric.DataType type){\r\n    final Map<FingerprintIdDetails, Fingerprint> lhsFingerprintsByGroup = mergeFingerprintsBy(lhsFingerprints, by);\r\n    final Map<FingerprintIdDetails, Fingerprint> rhsFingerprintsByGroup = mergeFingerprintsBy(rhsFingerprints, by);\r\n    if (MATRIX_OUTPUT != null) {\r\n        crosscheckMatrix = new double[lhsFingerprintsByGroup.size()][];\r\n        for (int row = 0; row < lhsFingerprintsByGroup.size(); row++) {\r\n            crosscheckMatrix[row] = new double[rhsFingerprintsByGroup.size()];\r\n        }\r\n        lhsFingerprintsByGroup.keySet().forEach(k -> lhsMatrixKeys.add(k.group));\r\n        rhsFingerprintsByGroup.keySet().forEach(k -> rhsMatrixKeys.add(k.group));\r\n    }\r\n    return crossCheckFingerprints(lhsFingerprintsByGroup, rhsFingerprintsByGroup, type, metrics);\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeProbabilitiesFromContaminatorSequence.updateLikelihoods",
	"Comment": "a function needed to update the loglikelihoods from the likelihoodmap.",
	"Method": "void updateLikelihoods(){\r\n    final double[] ll = new double[Genotype.values().length];\r\n    for (final Genotype contGeno : Genotype.values()) {\r\n        ll[contGeno.v] = log10(MathUtil.sum(MathUtil.multiply(this.getPriorProbablities(), likelihoodMap[contGeno.v])));\r\n    }\r\n    setLogLikelihoods(ll);\r\n}"
}, {
	"Path": "prefuse.visual.AggregateTable.getAggregatedRow",
	"Comment": "get the row index to the aggregate mapping table for the givenaggregate and contained visualitem.",
	"Method": "int getAggregatedRow(int row,VisualItem member){\r\n    Index index = m_aggregated.index(MEMBER_HASH);\r\n    int hash = getHashCode(member);\r\n    int ar = index.get(hash);\r\n    if (ar < 0) {\r\n        return -1;\r\n    } else if (m_aggregated.getInt(ar, AGGREGATE) == row) {\r\n        return ar;\r\n    } else {\r\n        for (IntIterator rows = index.rows(hash); rows.hasNext(); ) {\r\n            ar = rows.nextInt();\r\n            if (m_aggregated.getInt(ar, AGGREGATE) == row)\r\n                return ar;\r\n        }\r\n        return -1;\r\n    }\r\n}"
}, {
	"Path": "picard.illumina.parser.IlluminaDataProviderFactory.findPreferredFormat",
	"Comment": "given a data type find the most preferred file format even if files are not available",
	"Method": "SupportedIlluminaFormat findPreferredFormat(IlluminaDataType dt,IlluminaFileUtil fileUtil,SupportedIlluminaFormat findPreferredFormat,IlluminaDataType dt,IlluminaFileUtil fileUtil,boolean checkAvailable){\r\n    final List<SupportedIlluminaFormat> preferredFormats = DATA_TYPE_TO_PREFERRED_FORMATS.get(dt);\r\n    SupportedIlluminaFormat format = null;\r\n    for (int i = 0; i < preferredFormats.size() && format == null; i++) {\r\n        if (checkAvailable && fileUtil.getUtil(preferredFormats.get(i)).filesAvailable()) {\r\n            format = preferredFormats.get(i);\r\n        } else if (!checkAvailable) {\r\n            format = preferredFormats.get(i);\r\n        }\r\n    }\r\n    return format;\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.canGetInt",
	"Comment": "indicates if convenience get method can be called withoutan exception being thrown for the int type.",
	"Method": "boolean canGetInt(){\r\n    return canGet(int.class);\r\n}"
}, {
	"Path": "prefuse.activity.ActivityManager.scheduleAfter",
	"Comment": "schedules an activity to start immediately after another activity.the second activity will be scheduled to start immediately after thefirst one finishes, overwriting any previously set starttime. if thefirst activity is cancelled, the second one will not run.this functionality is provided by using an activitylistener to monitorthe first activity. the listener is removed upon completion orcancellation of the first activity.this method does not effect the scheduling of the first activity.",
	"Method": "void scheduleAfter(Activity before,Activity after){\r\n    getInstance()._scheduleAfter(before, after);\r\n}"
}, {
	"Path": "picard.sam.markduplicates.util.AbstractMarkDuplicatesCommandLineProgram.openInputs",
	"Comment": "since this may read its inputs more than once this method does all the openingand checking of the inputs.",
	"Method": "SamHeaderAndIterator openInputs(boolean eagerlyDecode){\r\n    final List<SAMFileHeader> headers = new ArrayList(INPUT.size());\r\n    final List<SamReader> readers = new ArrayList(INPUT.size());\r\n    for (final String input : INPUT) {\r\n        SamReaderFactory readerFactory = SamReaderFactory.makeDefault();\r\n        SamReader reader = eagerlyDecode ? readerFactory.enable(SamReaderFactory.Option.EAGERLY_DECODE).open(SamInputResource.of(input)) : readerFactory.open(SamInputResource.of(input));\r\n        final SAMFileHeader header = reader.getFileHeader();\r\n        headers.add(header);\r\n        readers.add(reader);\r\n    }\r\n    if (ASSUME_SORT_ORDER != null || ASSUME_SORTED) {\r\n        if (ASSUME_SORT_ORDER == null) {\r\n            ASSUME_SORT_ORDER = SAMFileHeader.SortOrder.coordinate;\r\n            ASSUME_SORTED = false;\r\n        }\r\n        headers.get(0).setSortOrder(ASSUME_SORT_ORDER);\r\n    }\r\n    if (headers.size() == 1) {\r\n        return new SamHeaderAndIterator(headers.get(0), readers.get(0).iterator());\r\n    } else {\r\n        final SamFileHeaderMerger headerMerger = new SamFileHeaderMerger(headers.get(0).getSortOrder(), headers, false);\r\n        final MergingSamRecordIterator iterator = new MergingSamRecordIterator(headerMerger, readers, ASSUME_SORT_ORDER != null);\r\n        return new SamHeaderAndIterator(headerMerger.getMergedHeader(), iterator);\r\n    }\r\n}"
}, {
	"Path": "prefuse.Display.setRenderingHints",
	"Comment": "sets the rendering hints that should be used while drawingthe visualization to the screen. subclasses can overridethis method to set hints as desired. such subclasses shouldconsider honoring the high quality flag in one form or another.",
	"Method": "void setRenderingHints(Graphics2D g){\r\n    if (m_highQuality) {\r\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\r\n    } else {\r\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\r\n    }\r\n    g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\r\n    g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);\r\n}"
}, {
	"Path": "net.pms.encoders.VLCVideo.genConfig",
	"Comment": "pick codecs for vlc based on formats the renderer supports.",
	"Method": "CodecConfig genConfig(RendererConfiguration renderer){\r\n    CodecConfig codecConfig = new CodecConfig();\r\n    if (renderer.isTranscodeToWMV()) {\r\n        logger.debug(\"Using XBox WMV codecs\");\r\n        codecConfig.videoCodec = \"wmv2\";\r\n        codecConfig.audioCodec = \"wma\";\r\n        codecConfig.container = \"asf\";\r\n    } else {\r\n        codecConfig.videoCodec = \"mp2v\";\r\n        codecConfig.audioCodec = \"mp2a\";\r\n        if (renderer.isTranscodeToMPEGTSAC3()) {\r\n            logger.debug(\"Using standard DLNA codecs with an MPEG-PS container\");\r\n            codecConfig.container = \"ts\";\r\n        } else {\r\n            logger.debug(\"Using standard DLNA codecs with an MPEG-TS (default) container\");\r\n            codecConfig.container = \"ps\";\r\n        }\r\n    }\r\n    logger.trace(\"Using \" + codecConfig.videoCodec + \", \" + codecConfig.audioCodec + \", \" + codecConfig.container);\r\n    if (sampleRateOverride.isSelected()) {\r\n        codecConfig.sampleRate = Integer.valueOf(sampleRate.getText());\r\n    }\r\n    if (audioSyncEnabled.isSelected()) {\r\n        codecConfig.extraTrans.put(\"audio-sync\", \"\");\r\n    }\r\n    return codecConfig;\r\n}"
}, {
	"Path": "prefuse.util.DataLib.sum",
	"Comment": "get the sum of a tuple data value. if any tuple does not have the namedfield or the field is not a numeric data type, nan will be returned.",
	"Method": "double sum(Iterator tuples,String field){\r\n    try {\r\n        double sum = 0;\r\n        while (tuples.hasNext()) {\r\n            sum += ((Tuple) tuples.next()).getDouble(field);\r\n        }\r\n        return sum;\r\n    } catch (Exception e) {\r\n        return Double.NaN;\r\n    }\r\n}"
}, {
	"Path": "net.pms.configuration.RendererConfiguration.isVideoRescale",
	"Comment": "returns true if the renderer has a maximum supported width\tor height, false otherwise.",
	"Method": "boolean isVideoRescale(){\r\n    return getMaxVideoWidth() > 0 && getMaxVideoHeight() > 0;\r\n}"
}, {
	"Path": "net.pms.PMS.getHelpPage",
	"Comment": "returns the relative url of a context sensitive help page in the\tdocumentation directory.",
	"Method": "String getHelpPage(){\r\n    return helpPage;\r\n}"
}, {
	"Path": "peergos.shared.cbor.CborEncoder.writeUInt",
	"Comment": "encodes and writes an unsigned integer value, that is, tries to encode it in a little bytes as possible.",
	"Method": "void writeUInt(int mt,long value){\r\n    if (value < 0x18L) {\r\n        m_os.write((int) (mt | value));\r\n    } else if (value < 0x100L) {\r\n        writeUInt8(mt, (int) value);\r\n    } else if (value < 0x10000L) {\r\n        writeUInt16(mt, (int) value);\r\n    } else if (value < 0x100000000L) {\r\n        writeUInt32(mt, (int) value);\r\n    } else {\r\n        writeUInt64(mt, value);\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.io.FixedWidthTextTableSchema.getColumnEnd",
	"Comment": "sets the ending character number for the given column index. this value\tis one greater than the last character position for the column.",
	"Method": "int getColumnEnd(int idx){\r\n    return cols[idx + 1];\r\n}"
}, {
	"Path": "prefuse.controls.NeighborHighlightControl.isHighlightWithInvisibleEdge",
	"Comment": "indicates if neighbor nodes with edges currently not visible stillget highlighted.",
	"Method": "boolean isHighlightWithInvisibleEdge(){\r\n    return highlightWithInvisibleEdge;\r\n}"
}, {
	"Path": "picard.sam.markduplicates.util.MarkQueue.setToMarkQueueMinimumDistance",
	"Comment": "sets the minimum genomic distance such that we can be assured that all duplicates have been considered.",
	"Method": "void setToMarkQueueMinimumDistance(int toMarkQueueMinimumDistance){\r\n    this.toMarkQueueMinimumDistance = toMarkQueueMinimumDistance;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setMencoderScaler",
	"Comment": "set to true if mencoder should be used to upscale the video to an\toptimal resolution. set to false to leave upscaling to the renderer.",
	"Method": "void setMencoderScaler(boolean value){\r\n    configuration.setProperty(KEY_MENCODER_SCALER, value);\r\n}"
}, {
	"Path": "com.google.gwt.sample.mobilewebapp.client.mobile.MobileTaskEditView.setGlassPanelVisible",
	"Comment": "show or hide the glass panel used to lock the ui will the task loads.",
	"Method": "void setGlassPanelVisible(boolean visible){\r\n    if (glassPanel == null) {\r\n        glassPanel = new DecoratedPopupPanel(false, true);\r\n        glassPanel.setWidget(new Label(\"Loading...\"));\r\n    }\r\n    if (visible) {\r\n        glassPanel.center();\r\n    } else {\r\n        glassPanel.hide();\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.Graph.inEdgeRows",
	"Comment": "get an iterator over all edges that have the given node as a target.that is, edges that link into the given target node.",
	"Method": "IntIterator inEdgeRows(int node){\r\n    return edgeRows(node, INEDGES);\r\n}"
}, {
	"Path": "com.restfb.json.Json.array",
	"Comment": "creates a new jsonarray that contains the json representations of the given strings.",
	"Method": "JsonValue array(JsonArray array,int values,JsonArray array,long values,JsonArray array,float values,JsonArray array,double values,JsonArray array,boolean values,JsonArray array,String strings){\r\n    if (strings == null) {\r\n        throw new NullPointerException(VALUES_IS_NULL);\r\n    }\r\n    JsonArray array = new JsonArray();\r\n    for (String value : strings) {\r\n        array.add(value);\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.ContactDatabase.generateContacts",
	"Comment": "generate the specified number of contacts and add them to the dataprovider.",
	"Method": "void generateContacts(int count){\r\n    List<ContactInfo> contacts = dataProvider.getList();\r\n    for (int i = 0; i < count; i++) {\r\n        contacts.add(createContactInfo());\r\n    }\r\n}"
}, {
	"Path": "picard.fingerprint.Snp.indexOf",
	"Comment": "gets the index of the supplied genotype within the genotypes for this snp.",
	"Method": "int indexOf(DiploidGenotype gt){\r\n    for (int i = 0; i < this.genotypes.length; ++i) {\r\n        if (gt == this.genotypes[i])\r\n            return i;\r\n    }\r\n    throw new IllegalArgumentException(\"Genotype \" + gt + \" is not valid for this SNP.\");\r\n}"
}, {
	"Path": "prefuse.action.layout.AxisLayout.setFilter",
	"Comment": "set a predicate filter to limit which items are considered for layout.only items for which the predicate returns a true value are includedin the layout computation.",
	"Method": "void setFilter(Predicate filter){\r\n    m_filter = filter;\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAMediaAudio.isMpegAudio",
	"Comment": "returns true if this media uses the mpeg audio audio codec, false otherwise.",
	"Method": "boolean isMpegAudio(){\r\n    return getCodecA() != null && getCodecA().equalsIgnoreCase(\"mp2\");\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.addItem",
	"Comment": "add a new row to the table and return the visualitem for that row. onlyallowed if there is no parent table, otherwise an exception will result.",
	"Method": "VisualItem addItem(){\r\n    return getItem(addRow());\r\n}"
}, {
	"Path": "prefuse.Display.addPaintListener",
	"Comment": "add a paintlistener to this display to receive notificationsabout paint events.",
	"Method": "void addPaintListener(PaintListener pl){\r\n    if (m_painters == null)\r\n        m_painters = new CopyOnWriteArrayList();\r\n    m_painters.add(pl);\r\n}"
}, {
	"Path": "picard.sam.BamIndexStats.doWork",
	"Comment": "main method for the program.checks that input file is present andreadable, then iterates through the index printing meta data to stdout.",
	"Method": "int doWork(){\r\n    if (INPUT.getName().endsWith(BAMIndex.BAMIndexSuffix))\r\n        log.warn(\"INPUT should be the BAM file name, not its index file\");\r\n    IOUtil.assertFileIsReadable(INPUT);\r\n    BAMIndexMetaData.printIndexStats(INPUT);\r\n    return 0;\r\n}"
}, {
	"Path": "prefuse.activity.ActivityManager.stopThread",
	"Comment": "stops the activity manager thread. all scheduled actvities arecanceled, and then the thread is then notified to stop running.",
	"Method": "void stopThread(){\r\n    ActivityManager am;\r\n    synchronized (ActivityManager.class) {\r\n        am = s_instance;\r\n    }\r\n    if (am != null)\r\n        am._stop();\r\n}"
}, {
	"Path": "prefuse.data.Table.canGetString",
	"Comment": "check if the given data field can return primitive stringvalues.",
	"Method": "boolean canGetString(String field){\r\n    Column col = getColumn(field);\r\n    return (col == null ? false : col.canGetString());\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeProbabilitiesFromSequence.addToProbs",
	"Comment": "adds a base observation with the observed quality to the evidence for this haplotypebased on the fact that the snp is part of the haplotype.",
	"Method": "void addToProbs(Snp snp,byte base,byte qual){\r\n    assertSnpPartOfHaplotype(snp);\r\n    final double[] ll = getLogLikelihoods();\r\n    final double pError = QualityUtil.getErrorProbabilityFromPhredScore(qual);\r\n    if (base == snp.getAllele1()) {\r\n        obsAllele1++;\r\n        for (final Genotype g : Genotype.values()) {\r\n            final double pAlt = g.v / 2d;\r\n            ll[g.v] += log10((1d - pAlt) * (1d - pError) + pAlt * pError);\r\n        }\r\n    } else if (base == snp.getAllele2()) {\r\n        obsAllele2++;\r\n        for (final Genotype g : Genotype.values()) {\r\n            final double pAlt = 1 - g.v / 2d;\r\n            ll[g.v] += log10((1d - pAlt) * (1d - pError) + pAlt * pError);\r\n        }\r\n    } else {\r\n        obsAlleleOther++;\r\n    }\r\n    setLogLikelihoods(ll);\r\n}"
}, {
	"Path": "peergos.shared.util.EfficientHashMap.findKeyOrEmpty",
	"Comment": "returns the index in the key table at which a particular key resides, orthe index of an empty slot in the table where this key should be insertedif it is not already in the table. default access to avoid syntheticaccessors from inner classes.",
	"Method": "int findKeyOrEmpty(Object k){\r\n    int index = getKeyIndex(k);\r\n    while (true) {\r\n        Object existing = keys[index];\r\n        if (existing == null) {\r\n            return index;\r\n        }\r\n        if (keyEquals(k, unmaskNullKey(existing))) {\r\n            return index;\r\n        }\r\n        if (++index == keys.length) {\r\n            index = 0;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "picard.illumina.parser.IlluminaFileMap.getFilesStartingAt",
	"Comment": "return the list of files in order starting at the given tile and containing all files with tile numbers greater than startingtile thatare within this map",
	"Method": "List<File> getFilesStartingAt(int startingTile){\r\n    return new ArrayList<File>(this.tailMap(startingTile).values());\r\n}"
}, {
	"Path": "com.restfb.DefaultFacebookClient.toParameterString",
	"Comment": "generate the parameter string to be included in the facebook api request.",
	"Method": "String toParameterString(Parameter parameters,String toParameterString,boolean withJsonParameter,Parameter parameters){\r\n    if (!isBlank(accessToken)) {\r\n        parameters = parametersWithAdditionalParameter(Parameter.with(ACCESS_TOKEN_PARAM_NAME, accessToken), parameters);\r\n    }\r\n    if (!isBlank(accessToken) && !isBlank(appSecret)) {\r\n        parameters = parametersWithAdditionalParameter(Parameter.with(APP_SECRET_PROOF_PARAM_NAME, obtainAppSecretProof(accessToken, appSecret)), parameters);\r\n    }\r\n    if (withJsonParameter) {\r\n        parameters = parametersWithAdditionalParameter(Parameter.with(FORMAT_PARAM_NAME, \"json\"), parameters);\r\n    }\r\n    StringBuilder parameterStringBuilder = new StringBuilder();\r\n    boolean first = true;\r\n    for (Parameter parameter : parameters) {\r\n        if (first) {\r\n            first = false;\r\n        } else {\r\n            parameterStringBuilder.append(\"&\");\r\n        }\r\n        parameterStringBuilder.append(urlEncode(parameter.name));\r\n        parameterStringBuilder.append(\"=\");\r\n        parameterStringBuilder.append(urlEncodedValueForParameterName(parameter.name, parameter.value));\r\n    }\r\n    return parameterStringBuilder.toString();\r\n}"
}, {
	"Path": "net.pms.configuration.ConfigurationReader.getInt",
	"Comment": "return the int value for a given configuration key. first, the key\tis looked up in the current configuration settings. if it exists and contains a\tvalid value, that value is returned. if the key contains an invalid value or\tcannot be found, the specified default value is returned.",
	"Method": "int getInt(String key,int def){\r\n    int value;\r\n    try {\r\n        value = configuration.getInt(key, def);\r\n    } catch (ConversionException e) {\r\n        value = def;\r\n    }\r\n    log(key, value, def);\r\n    return value;\r\n}"
}, {
	"Path": "prefuse.action.layout.StackedAreaChart.setThreshold",
	"Comment": "set the minimum height threshold under which stacks should not bemade visible.",
	"Method": "void setThreshold(double threshold){\r\n    m_threshold = (float) threshold;\r\n}"
}, {
	"Path": "prefuse.data.Graph.updateNodeData",
	"Comment": "update the link table to accomodate an inserted or deleted node",
	"Method": "void updateNodeData(int r,boolean added){\r\n    if (added) {\r\n        m_links.addRow();\r\n    } else {\r\n        m_nodeTuples.invalidate(r);\r\n        m_links.removeRow(r);\r\n    }\r\n}"
}, {
	"Path": "picard.sam.DuplicationMetrics.f",
	"Comment": "method that is used in the computation of estimated library size.",
	"Method": "double f(double x,double c,double n){\r\n    return c / x - 1 + Math.exp(-n / x);\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeProbabilities.hasEvidence",
	"Comment": "returns true if evidence has been added, false if the probabilities are just the priors.",
	"Method": "boolean hasEvidence(){\r\n    return true;\r\n}"
}, {
	"Path": "prefuse.data.io.sql.DatabaseDataSource.process",
	"Comment": "process the results of a sql query, putting retrieved data into atable instance. if a null table is provided, a new table with theappropriate schema will be created.",
	"Method": "Table process(Table t,ResultSet rset,String key,Object lock){\r\n    int count = 0;\r\n    long timein = System.currentTimeMillis();\r\n    try {\r\n        ResultSetMetaData metadata = rset.getMetaData();\r\n        int ncols = metadata.getColumnCount();\r\n        if (t == null) {\r\n            t = getSchema(metadata, m_handler).instantiate();\r\n            if (key != null) {\r\n                try {\r\n                    t.index(key);\r\n                    s_logger.info(\"Indexed field: \" + key);\r\n                } catch (Exception e) {\r\n                    s_logger.warning(\"Error indexing field: \" + key);\r\n                }\r\n            }\r\n        }\r\n        lock = (lock == null ? t : lock);\r\n        while (rset.next()) {\r\n            synchronized (lock) {\r\n                int row = getExistingRow(t, rset, key);\r\n                if (row < 0) {\r\n                    row = t.addRow();\r\n                }\r\n                for (int i = 1; i <= ncols; ++i) {\r\n                    m_handler.process(t, row, rset, i);\r\n                }\r\n            }\r\n            ++count;\r\n        }\r\n    } catch (SQLException e) {\r\n        throw new DataIOException(e);\r\n    }\r\n    long time = System.currentTimeMillis() - timein;\r\n    s_logger.info(\"Internal query processing completed: \" + count + \" rows, \" + (time / 1000) + \".\" + (time % 1000) + \" seconds.\");\r\n    return t;\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.isExpanded",
	"Comment": "indicates the given row is expanded. only used for items that arepart of a graph structure.",
	"Method": "boolean isExpanded(int row){\r\n    return getBoolean(row, VisualItem.EXPANDED);\r\n}"
}, {
	"Path": "net.pms.dlna.virtual.VirtualFolder.getName",
	"Comment": "returns a string representing the container. this string is used in\tthe upnp contentbrowser service.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "peergos.shared.cbor.CborDecoder.readMajorTypeWithSize",
	"Comment": "reads the next major type from the underlying input stream, verifies whether it matches the given expectation, and decodes the payload into a size.",
	"Method": "long readMajorTypeWithSize(int majorType){\r\n    return readUInt(readMajorType(majorType), true);\r\n}"
}, {
	"Path": "quickfix.SLF4JLog.log",
	"Comment": "made protected to enable unit testing of callerfqcn coming through correctly",
	"Method": "void log(org.slf4j.Logger log,String text){\r\n    if (log.isInfoEnabled()) {\r\n        if (log instanceof LocationAwareLogger) {\r\n            final LocationAwareLogger la = (LocationAwareLogger) log;\r\n            la.log(null, callerFQCN, LocationAwareLogger.INFO_INT, text, null, null);\r\n        } else {\r\n            log.info(text);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "py4j.reflection.ReflectionEngine.getPublicStaticMethodNames",
	"Comment": "retrieve the names of all the public static methods in the clazz",
	"Method": "String[] getPublicStaticMethodNames(Class<?> clazz){\r\n    Method[] methods = clazz.getMethods();\r\n    Set<String> methodNames = new HashSet<String>();\r\n    for (Method method : methods) {\r\n        if (Modifier.isPublic(method.getModifiers()) && Modifier.isStatic(method.getModifiers())) {\r\n            methodNames.add(method.getName());\r\n        }\r\n    }\r\n    return (String[]) methodNames.toArray(new String[methodNames.size()]);\r\n}"
}, {
	"Path": "prefuse.activity.Activity.setRunning",
	"Comment": "sets a flag indicating whether or not this activity is currently running",
	"Method": "boolean setRunning(boolean s){\r\n    boolean b = m_isRunning;\r\n    m_isRunning = s;\r\n    return b;\r\n}"
}, {
	"Path": "prefuse.visual.AggregateTable.clearAggregateMappings",
	"Comment": "clears all aggregates mappings for the aggregate at the given row,optionally issuing a table update.",
	"Method": "void clearAggregateMappings(int row,boolean update){\r\n    Index index = m_aggregated.index(AGGREGATE);\r\n    boolean fire = false;\r\n    for (IntIterator rows = index.rows(row); rows.hasNext(); ) {\r\n        int r = rows.nextInt();\r\n        rows.remove();\r\n        m_aggregated.removeRow(r);\r\n        fire = true;\r\n    }\r\n    if (update && fire)\r\n        fireTableEvent(row, row, EventConstants.ALL_COLUMNS, EventConstants.UPDATE);\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.panels.CwAbsolutePanel.createOptionsBar",
	"Comment": "create an options panel that allows users to select a widget and reposition",
	"Method": "Widget createOptionsBar(){\r\n    FlexTable optionsBar = new FlexTable();\r\n    topPosBox = new TextBox();\r\n    topPosBox.setWidth(\"3em\");\r\n    topPosBox.setText(\"100\");\r\n    leftPosBox = new TextBox();\r\n    leftPosBox.setWidth(\"3em\");\r\n    leftPosBox.setText(\"60\");\r\n    listBox = new ListBox();\r\n    optionsBar.setHTML(0, 0, constants.cwAbsolutePanelItemsToMove());\r\n    optionsBar.setWidget(0, 1, listBox);\r\n    optionsBar.setHTML(1, 0, constants.cwAbsolutePanelTop());\r\n    optionsBar.setWidget(1, 1, topPosBox);\r\n    optionsBar.setHTML(2, 0, constants.cwAbsolutePanelLeft());\r\n    optionsBar.setWidget(2, 1, leftPosBox);\r\n    for (String name : widgetMap.keySet()) {\r\n        listBox.addItem(name);\r\n    }\r\n    listBox.addChangeHandler(new ChangeHandler() {\r\n        public void onChange(ChangeEvent event) {\r\n            updateSelectedItem();\r\n        }\r\n    });\r\n    KeyUpHandler repositionHandler = new KeyUpHandler() {\r\n        public void onKeyUp(KeyUpEvent event) {\r\n            repositionItem();\r\n        }\r\n    };\r\n    topPosBox.addKeyUpHandler(repositionHandler);\r\n    leftPosBox.addKeyUpHandler(repositionHandler);\r\n    return optionsBar;\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.panels.CwAbsolutePanel.createOptionsBar",
	"Comment": "create an options panel that allows users to select a widget and reposition",
	"Method": "Widget createOptionsBar(){\r\n    updateSelectedItem();\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.panels.CwAbsolutePanel.createOptionsBar",
	"Comment": "create an options panel that allows users to select a widget and reposition",
	"Method": "Widget createOptionsBar(){\r\n    repositionItem();\r\n}"
}, {
	"Path": "prefuse.data.Table.canSetString",
	"Comment": "check if the setstring method can safely be used for thegiven data field.",
	"Method": "boolean canSetString(String field){\r\n    Column col = getColumn(field);\r\n    return (col == null ? false : col.canSetString());\r\n}"
}, {
	"Path": "quickfix.mina.message.PatternMatcher.calculateMinLength",
	"Comment": "calculates the minimum number of bytes that the pattern can match.",
	"Method": "int calculateMinLength(){\r\n    int len = 0;\r\n    for (byte b : pattern) {\r\n        if (b < 'a' || b > 'z') {\r\n            len++;\r\n        }\r\n    }\r\n    return len;\r\n}"
}, {
	"Path": "picard.sam.FastqToSam.doWork",
	"Comment": "simply invokes the right method for unpaired or paired data.",
	"Method": "int doWork(){\r\n    IOUtil.assertFileIsReadable(FASTQ);\r\n    if (FASTQ2 != null) {\r\n        IOUtil.assertFileIsReadable(FASTQ2);\r\n    }\r\n    IOUtil.assertFileIsWritable(OUTPUT);\r\n    final SAMFileHeader header = createSamFileHeader();\r\n    final SAMFileWriter writer = new SAMFileWriterFactory().makeSAMOrBAMWriter(header, false, OUTPUT);\r\n    QUALITY_FORMAT = FastqToSam.determineQualityFormat(fileToFastqReader(FASTQ), (FASTQ2 == null) ? null : fileToFastqReader(FASTQ2), QUALITY_FORMAT);\r\n    final List<FastqReader> readers1 = new ArrayList<FastqReader>();\r\n    final List<FastqReader> readers2 = new ArrayList<FastqReader>();\r\n    if (USE_SEQUENTIAL_FASTQS) {\r\n        for (final File fastq : getSequentialFileList(FASTQ)) {\r\n            readers1.add(fileToFastqReader(fastq));\r\n        }\r\n        if (null != FASTQ2) {\r\n            for (final File fastq : getSequentialFileList(FASTQ2)) {\r\n                readers2.add(fileToFastqReader(fastq));\r\n            }\r\n            if (readers1.size() != readers2.size()) {\r\n                throw new PicardException(String.format(\"Found %d files for FASTQ and %d files for FASTQ2.\", readers1.size(), readers2.size()));\r\n            }\r\n        }\r\n    } else {\r\n        readers1.add(fileToFastqReader(FASTQ));\r\n        if (FASTQ2 != null) {\r\n            readers2.add(fileToFastqReader(FASTQ2));\r\n        }\r\n    }\r\n    for (int idx = 0; idx < readers1.size(); idx++) {\r\n        makeItSo(readers1.get(idx), (readers2.isEmpty()) ? null : readers2.get(idx), writer);\r\n    }\r\n    for (final FastqReader reader : readers1) reader.close();\r\n    for (final FastqReader reader : readers2) reader.close();\r\n    writer.close();\r\n    return 0;\r\n}"
}, {
	"Path": "quickfix.FileLog.clear",
	"Comment": "deletes the log files. do not perform any log operations while performingthis operation.",
	"Method": "void clear(){\r\n    try {\r\n        close();\r\n        openLogStreams(false);\r\n    } catch (IOException e) {\r\n        System.err.println(\"Could not clear log: \" + getClass().getName());\r\n    }\r\n}"
}, {
	"Path": "com.restfb.json.Json.object",
	"Comment": "creates a new empty jsonobject. this is equivalent to creating a new jsonobject using the constructor.",
	"Method": "JsonObject object(){\r\n    return new JsonObject();\r\n}"
}, {
	"Path": "prefuse.data.util.FilterIteratorFactory.getOptimizedIterator",
	"Comment": "get an optimized iterator over the rows of a table, if possible.",
	"Method": "IntIterator getOptimizedIterator(Table t,Predicate p){\r\n    if (t.getRowCount() < OPTIMIZATION_THRESHOLD)\r\n        return null;\r\n    if (p instanceof ColumnExpression) {\r\n        return getColumnIterator(t, ((ColumnExpression) p).getColumnName(), true);\r\n    } else if (p instanceof NotPredicate) {\r\n        Predicate pp = ((NotPredicate) p).getPredicate();\r\n        if (pp instanceof ColumnExpression) {\r\n            return getColumnIterator(t, ((ColumnExpression) pp).getColumnName(), false);\r\n        }\r\n    } else if (p instanceof AndPredicate) {\r\n        return getAndIterator(t, (AndPredicate) p);\r\n    } else if (p instanceof OrPredicate) {\r\n        return getOrIterator(t, (OrPredicate) p);\r\n    } else if (p instanceof ComparisonPredicate) {\r\n        return getComparisonIterator(t, (ComparisonPredicate) p);\r\n    } else if (p instanceof RangePredicate) {\r\n        return getRangeIterator(t, (RangePredicate) p);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "prefuse.util.collections.CopyOnWriteArrayList.removeAll",
	"Comment": "removes from this list all of its elements that are contained inthe specified collection. this is a particularly expensive operationin this class because of the need for an internal temporary array.",
	"Method": "boolean removeAll(Collection c){\r\n    Object[] elements = getArray();\r\n    int len = elements.length;\r\n    if (len != 0) {\r\n        int newlen = 0;\r\n        Object[] temp = new Object[len];\r\n        for (int i = 0; i < len; ++i) {\r\n            Object element = elements[i];\r\n            if (!c.contains(element))\r\n                temp[newlen++] = element;\r\n        }\r\n        if (newlen != len) {\r\n            setArray(copyOfRange(temp, 0, newlen, Object[].class));\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "prefuse.data.Table.isValidRow",
	"Comment": "indicates if the given row number corresponds to a valid table row.",
	"Method": "boolean isValidRow(int row){\r\n    return m_rows.isValidRow(row);\r\n}"
}, {
	"Path": "org.quickfixj.codegenerator.GenerateMojo.getPackaging",
	"Comment": "returns the default package to be used during code generation.",
	"Method": "String getPackaging(){\r\n    return packaging;\r\n}"
}, {
	"Path": "prefuse.visual.AggregateTable.validRowCheck",
	"Comment": "check a row for validity, optionally throwing an exception when aninvalid row is found.",
	"Method": "boolean validRowCheck(int row,boolean throwException){\r\n    if (isValidRow(row)) {\r\n        return true;\r\n    } else if (throwException) {\r\n        throw new IllegalArgumentException(\"Invalid row value: \" + row);\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.google.gwt.sample.dynatablerf.client.PersonEditorWorkflow.edit",
	"Comment": "construct and display the ui that will be used to edit the currentpersonproxy, using the given requestcontext to accumulate the edits.",
	"Method": "void edit(RequestContext requestContext){\r\n    editorDriver = GWT.create(Driver.class);\r\n    editorDriver.initialize(requestFactory, personEditor);\r\n    if (requestContext == null) {\r\n        this.favorite.setVisible(true);\r\n        fetchAndEdit();\r\n        return;\r\n    }\r\n    editorDriver.edit(person, requestContext);\r\n    personEditor.focus();\r\n    favorite.setValue(manager.isFavorite(person), false);\r\n    dialog.center();\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setMinimized",
	"Comment": "set to true if pms should start minimized, i.e. without its window\topened.",
	"Method": "void setMinimized(boolean value){\r\n    configuration.setProperty(KEY_MINIMIZED, value);\r\n}"
}, {
	"Path": "prefuse.data.expression.AbstractExpression.hasListeners",
	"Comment": "indicates if any listeners are registered with this expression.",
	"Method": "boolean hasListeners(){\r\n    return m_listeners != null && m_listeners.size() > 0;\r\n}"
}, {
	"Path": "com.google.gwt.sample.mobilewebapp.client.tablet.TabletTaskEditView.setGlassPanelVisible",
	"Comment": "show or hide the glass panel used to lock the ui will the task loads.",
	"Method": "void setGlassPanelVisible(boolean visible){\r\n    if (glassPanel == null) {\r\n        glassPanel = new DecoratedPopupPanel(false, true);\r\n        glassPanel.setGlassEnabled(true);\r\n        glassPanel.setWidget(new Label(\"Loading...\"));\r\n    }\r\n    if (visible) {\r\n        glassPanel.center();\r\n    } else {\r\n        glassPanel.hide();\r\n    }\r\n}"
}, {
	"Path": "quickfix.DataDictionary.isAppMessage",
	"Comment": "predicate for determining if a message is in the app category.",
	"Method": "boolean isAppMessage(String msgType){\r\n    return MESSAGE_CATEGORY_APP.equals(messageCategory.get(msgType));\r\n}"
}, {
	"Path": "org.pcap4j.core.PcapNetworkInterface.isUp",
	"Comment": "returns if this network interface is up.this method may always return false on some environments.",
	"Method": "boolean isUp(){\r\n    return up;\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.isEndVisible",
	"Comment": "indictes if the end visible flag is set to true. this is thevisibility value consulted for the ending value of the visibilityfield at the end of an animated transition.",
	"Method": "boolean isEndVisible(int row){\r\n    return getBoolean(row, VisualItem.ENDVISIBLE);\r\n}"
}, {
	"Path": "prefuse.Display.repaintImmediate",
	"Comment": "immediately repaints the contents of the offscreen bufferto the screen. this bypasses the usual rendering loop.",
	"Method": "void repaintImmediate(){\r\n    Graphics g = this.getGraphics();\r\n    if (g != null && m_offscreen != null) {\r\n        paintBufferToScreen(g);\r\n    }\r\n}"
}, {
	"Path": "picard.vcf.filter.TestFilterVcf.testGqFiltering",
	"Comment": "tests that genotypes with low gq are filtered appropriately.",
	"Method": "void testGqFiltering(){\r\n    final Set<String> fails = CollectionUtil.makeSet(\"rs71509448\");\r\n    {\r\n        final File out = testFiltering(INPUT, \".vcf.gz\", 0, 0, 20, Double.MAX_VALUE);\r\n        final ListMap<String, String> filters = slurpFilters(out);\r\n        Assert.assertEquals(filters.size(), 0, \"Should not have filtered sites: \" + filters);\r\n    }\r\n    {\r\n        final File out = testFiltering(INPUT, \".vcf.gz\", 0, 0, 21, Double.MAX_VALUE);\r\n        final ListMap<String, String> filters = slurpFilters(out);\r\n        Assert.assertEquals(filters.size(), 0, \"Should not have filtered sites: \" + filters);\r\n    }\r\n    {\r\n        final File out = testFiltering(INPUT, \".vcf.gz\", 0, 0, 22, Double.MAX_VALUE);\r\n        final ListMap<String, String> filters = slurpFilters(out);\r\n        Assert.assertEquals(sorted(filters.keySet()), sorted(fails), \"Failed sites did not match expected set of failed sites.\");\r\n    }\r\n}"
}, {
	"Path": "net.pms.network.NetworkConfiguration.isRelevantAddress",
	"Comment": "returns true if the provided address is relevant, i.e. when the address\tis not an ipv6 address or a loopback address.",
	"Method": "boolean isRelevantAddress(InetAddress address){\r\n    return !(address instanceof Inet6Address || address.isLoopbackAddress());\r\n}"
}, {
	"Path": "picard.sam.markduplicates.UmiMetrics.addUmiObservationN",
	"Comment": "add an observation of a umi containing at least one n to the metrics",
	"Method": "void addUmiObservationN(){\r\n    observedUmiWithNs++;\r\n}"
}, {
	"Path": "net.pms.external.ExternalFactory.registerListener",
	"Comment": "stores the instance of an external listener in a list for later\tretrieval. the same instance will only be stored once.",
	"Method": "void registerListener(ExternalListener listener){\r\n    if (!externalListeners.contains(listener)) {\r\n        externalListeners.add(listener);\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.Schema.isLocked",
	"Comment": "indicates if this schema is locked. locked schemas can not be edited.",
	"Method": "boolean isLocked(){\r\n    return m_locked;\r\n}"
}, {
	"Path": "com.google.gwt.sample.core.linker.SimpleAppCacheLinker.getCacheExtraFiles",
	"Comment": "obtains the extra files to include in the manifest. ensures the returnedarray is not null.",
	"Method": "String[] getCacheExtraFiles(){\r\n    String[] cacheExtraFiles = otherCachedFiles();\r\n    return cacheExtraFiles == null ? new String[0] : Arrays.copyOf(cacheExtraFiles, cacheExtraFiles.length);\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setMencoderNoAssBlur",
	"Comment": "set the subfont blur parameter used for subtitling without ass.",
	"Method": "void setMencoderNoAssBlur(String value){\r\n    configuration.setProperty(KEY_MENCODER_NOASS_BLUR, value);\r\n}"
}, {
	"Path": "prefuse.data.io.CSVTableWriter.setPrintHeader",
	"Comment": "sets if this writer will write a header row with the column names.",
	"Method": "void setPrintHeader(boolean printHeader){\r\n    m_printHeader = printHeader;\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.startPlaying",
	"Comment": "plugin implementation. when this item is going to play, it will notify all\tthe startstoplistener objects available.",
	"Method": "void startPlaying(String rendererId){\r\n    final String requestId = getRequestId(rendererId);\r\n    synchronized (requestIdToRefcount) {\r\n        Integer temp = requestIdToRefcount.get(requestId);\r\n        if (temp == null) {\r\n            temp = 0;\r\n        }\r\n        final Integer refCount = temp;\r\n        requestIdToRefcount.put(requestId, refCount + 1);\r\n        if (refCount == 0) {\r\n            final DLNAResource self = this;\r\n            Runnable r = new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    InetAddress rendererIpAddress;\r\n                    try {\r\n                        rendererIpAddress = InetAddress.getByName(rendererId);\r\n                        RendererConfiguration renderer = RendererConfiguration.getRendererConfigurationBySocketAddress(rendererIpAddress);\r\n                        String rendererName = \"unknown renderer\";\r\n                        try {\r\n                            rendererName = renderer.getRendererName();\r\n                        } catch (NullPointerException e) {\r\n                        }\r\n                        logger.info(\"Started sending {} to {} on {}\", getSystemName(), rendererName, rendererId);\r\n                    } catch (UnknownHostException ex) {\r\n                        logger.debug(\"\" + ex);\r\n                    }\r\n                    for (final ExternalListener listener : ExternalFactory.getExternalListeners()) {\r\n                        if (listener instanceof StartStopListener) {\r\n                            Runnable fireStartStopEvent = new Runnable() {\r\n                                @Override\r\n                                public void run() {\r\n                                    try {\r\n                                        ((StartStopListener) listener).nowPlaying(getMedia(), self);\r\n                                    } catch (Throwable t) {\r\n                                        logger.error(\"Notification of startPlaying event failed for StartStopListener {}\", listener.getClass(), t);\r\n                                    }\r\n                                }\r\n                            };\r\n                            new Thread(fireStartStopEvent, \"StartPlaying Event for \" + listener.name()).start();\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            new Thread(r, \"StartPlaying Event\").start();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.startPlaying",
	"Comment": "plugin implementation. when this item is going to play, it will notify all\tthe startstoplistener objects available.",
	"Method": "void startPlaying(String rendererId){\r\n    InetAddress rendererIpAddress;\r\n    try {\r\n        rendererIpAddress = InetAddress.getByName(rendererId);\r\n        RendererConfiguration renderer = RendererConfiguration.getRendererConfigurationBySocketAddress(rendererIpAddress);\r\n        String rendererName = \"unknown renderer\";\r\n        try {\r\n            rendererName = renderer.getRendererName();\r\n        } catch (NullPointerException e) {\r\n        }\r\n        logger.info(\"Started sending {} to {} on {}\", getSystemName(), rendererName, rendererId);\r\n    } catch (UnknownHostException ex) {\r\n        logger.debug(\"\" + ex);\r\n    }\r\n    for (final ExternalListener listener : ExternalFactory.getExternalListeners()) {\r\n        if (listener instanceof StartStopListener) {\r\n            Runnable fireStartStopEvent = new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    try {\r\n                        ((StartStopListener) listener).nowPlaying(getMedia(), self);\r\n                    } catch (Throwable t) {\r\n                        logger.error(\"Notification of startPlaying event failed for StartStopListener {}\", listener.getClass(), t);\r\n                    }\r\n                }\r\n            };\r\n            new Thread(fireStartStopEvent, \"StartPlaying Event for \" + listener.name()).start();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.startPlaying",
	"Comment": "plugin implementation. when this item is going to play, it will notify all\tthe startstoplistener objects available.",
	"Method": "void startPlaying(String rendererId){\r\n    try {\r\n        ((StartStopListener) listener).nowPlaying(getMedia(), self);\r\n    } catch (Throwable t) {\r\n        logger.error(\"Notification of startPlaying event failed for StartStopListener {}\", listener.getClass(), t);\r\n    }\r\n}"
}, {
	"Path": "peergos.server.corenode.IpfsCoreNode.update",
	"Comment": "update the existing mappings based on the diff between the current champ and the champ with the supplied root.",
	"Method": "void update(MaybeMultihash newRoot){\r\n    updateAllMappings(signer.publicKeyHash, currentRoot, newRoot, ipfs, chains, reverseLookup, usernames);\r\n    this.currentRoot = newRoot;\r\n}"
}, {
	"Path": "picard.illumina.parser.CycleIlluminaFileMap.assertValid",
	"Comment": "assert that this map has an iterator for all of the expectedtiles and each iterator has expectedcycles numberof files.also, assert that each cycle file for a given tile is the same size",
	"Method": "void assertValid(List<Integer> expectedTiles,int[] expectedCycles){\r\n    if (size() != expectedCycles.length) {\r\n        throw new PicardException(\"Expected CycledIlluminaFileMap to contain \" + expectedCycles.length + \" cycles but only \" + size() + \" were found!\");\r\n    }\r\n    if (this.firstEntry().getValue().size() != expectedTiles.size()) {\r\n        throw new PicardException(\"Expected CycledIlluminaFileMap to contain \" + expectedTiles.size() + \" tiles but only \" + this.firstEntry().getValue().size() + \" were found!\");\r\n    }\r\n}"
}, {
	"Path": "picard.vcf.filter.TestFilterVcf.testFilteringToVcfWithNoSequenceDictionary",
	"Comment": "tests that attempting to write to an uncompressed vcf fails if the input has no sequence dictionary",
	"Method": "void testFilteringToVcfWithNoSequenceDictionary(){\r\n    final File out = File.createTempFile(\"filterVcfTest.\", \".vcf\");\r\n    out.deleteOnExit();\r\n    final FilterVcf filterer = new FilterVcf();\r\n    filterer.CREATE_INDEX = true;\r\n    filterer.INPUT = BAD_INPUT;\r\n    filterer.OUTPUT = out;\r\n    filterer.MIN_AB = 0;\r\n    filterer.MIN_DP = 18;\r\n    filterer.MIN_GQ = 0;\r\n    filterer.MAX_FS = Double.MAX_VALUE;\r\n    filterer.doWork();\r\n}"
}, {
	"Path": "prefuse.Visualization.cancel",
	"Comment": "cancel the action with the given name, if it has been scheduled.",
	"Method": "Activity cancel(String action){\r\n    return m_actions.cancel(action);\r\n}"
}, {
	"Path": "picard.sam.FastqToSam.error",
	"Comment": "little utility to give error messages corresponding to line numbers in the input files.",
	"Method": "String error(FastqReader freader,String str){\r\n    return str + \" at line \" + freader.getLineNumber() + \" in file \" + freader.getFile().getAbsolutePath();\r\n}"
}, {
	"Path": "com.egzosn.pay.paypal.bean.order.CartBase.getReferenceId",
	"Comment": "merchant identifier to the purchase unit. optional parameter",
	"Method": "String getReferenceId(){\r\n    return this.referenceId;\r\n}"
}, {
	"Path": "prefuse.data.Tree.removeChild",
	"Comment": "remove a node and its entire subtree rooted at the node from the tree.",
	"Method": "boolean removeChild(int node,boolean removeChild,Node n){\r\n    nodeCheck(n, true);\r\n    return removeChild(n.getRow());\r\n}"
}, {
	"Path": "java.lang.Throwable.getSuppressed",
	"Comment": "returns the array of exception that this one suppressedexceptions.",
	"Method": "Throwable[] getSuppressed(){\r\n    if (suppressedExceptions == null) {\r\n        suppressedExceptions = new Throwable[0];\r\n    }\r\n    return suppressedExceptions;\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.setEdgeTable",
	"Comment": "unsupported operation. spanning trees should not be edited.",
	"Method": "void setEdgeTable(Table edges){\r\n    throw new UnsupportedOperationException(\"Changes to graph structure not allowed for spanning trees.\");\r\n}"
}, {
	"Path": "net.pms.configuration.RendererConfiguration.getMaxVideoHeight",
	"Comment": "returns the maximum video height supported by the renderer as defined\tin the renderer configuration. the default value 0 means unlimited.",
	"Method": "int getMaxVideoHeight(){\r\n    return getInt(MAX_VIDEO_HEIGHT, 1080);\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCellValidation.isAddressValid",
	"Comment": "checks if an address is valid. a valid address consists of a numberfollowed by a street name, which may be composed of multiple words.",
	"Method": "boolean isAddressValid(String address){\r\n    if (address == null) {\r\n        return false;\r\n    }\r\n    String[] parts = address.split(\" \");\r\n    if (parts.length < 2) {\r\n        return false;\r\n    }\r\n    try {\r\n        Integer.parseInt(parts[0]);\r\n    } catch (NumberFormatException e) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.pms.encoders.Player.isVideoHardwareAccelerationReady",
	"Comment": "each engine capable of video hardware acceleration must \toverride this method and set\treturn true.",
	"Method": "boolean isVideoHardwareAccelerationReady(){\r\n    return false;\r\n}"
}, {
	"Path": "picard.fingerprint.FingerprintChecker.getLociToGenotype",
	"Comment": "takes a set of fingerprints and returns an intervallist containing all the loci thatcan be productively examined in sequencing data to compare to one or more of thefingerprints.",
	"Method": "IntervalList getLociToGenotype(Collection<Fingerprint> fingerprints){\r\n    final IntervalList intervals = new IntervalList(this.haplotypes.getHeader());\r\n    for (final Fingerprint fp : fingerprints) {\r\n        for (final HaplotypeProbabilities genotype : fp.values()) {\r\n            final HaplotypeBlock h = genotype.getHaplotype();\r\n            for (final Snp snp : h.getSnps()) {\r\n                intervals.add(new Interval(snp.getChrom(), snp.getPos(), snp.getPos(), false, snp.getName()));\r\n            }\r\n        }\r\n    }\r\n    return intervals.uniqued();\r\n}"
}, {
	"Path": "prefuse.controls.ZoomToFitControl.isZoomOverItem",
	"Comment": "indicates if the zoom control will work while the mouse isover a visualitem.",
	"Method": "boolean isZoomOverItem(){\r\n    return m_zoomOverItem;\r\n}"
}, {
	"Path": "prefuse.util.TypeLib.isWrapperInstance",
	"Comment": "indicates if an object is an instance of a wrapper class for a givenprimitive type.",
	"Method": "boolean isWrapperInstance(Class type,Object instance){\r\n    if (!type.isPrimitive())\r\n        throw new IllegalArgumentException(\"Input type must be a primitive\");\r\n    if (int.class == type && instance instanceof Integer) {\r\n        return true;\r\n    } else if (long.class == type && instance instanceof Long) {\r\n        return true;\r\n    } else if (float.class == type && instance instanceof Float) {\r\n        return true;\r\n    } else if (double.class == type && instance instanceof Double) {\r\n        return true;\r\n    } else if (boolean.class == type && instance instanceof Boolean) {\r\n        return true;\r\n    } else if (short.class == type && instance instanceof Short) {\r\n        return true;\r\n    } else if (byte.class == type && instance instanceof Byte) {\r\n        return true;\r\n    } else if (char.class == type && instance instanceof Character) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getNumberOfCpuCores",
	"Comment": "returns the number of cpu cores that should be used for transcoding.",
	"Method": "int getNumberOfCpuCores(){\r\n    int nbcores = Runtime.getRuntime().availableProcessors();\r\n    if (nbcores < 1) {\r\n        nbcores = 1;\r\n    }\r\n    return getInt(KEY_NUMBER_OF_CPU_CORES, nbcores);\r\n}"
}, {
	"Path": "org.pcollections.tests.ConsPStackTest.testRandomlyAgainstJavaList",
	"Comment": "compares the behavior of java.util.linkedlist to the behavior of conspstack.",
	"Method": "void testRandomlyAgainstJavaList(){\r\n    PStack<Integer> pstack = ConsPStack.empty();\r\n    List<Integer> list = new LinkedList<Integer>();\r\n    Random r = new Random();\r\n    for (int i = 0; i < 1000; i++) {\r\n        if (pstack.size() == 0 || r.nextBoolean()) {\r\n            if (r.nextBoolean()) {\r\n                Integer v = r.nextInt();\r\n                assertEquals(list.contains(v), pstack.contains(v));\r\n                list.add(0, v);\r\n                pstack = pstack.plus(v);\r\n            } else {\r\n                int k = r.nextInt(pstack.size() + 1);\r\n                Integer v = r.nextInt();\r\n                assertEquals(list.contains(v), pstack.contains(v));\r\n                if (k < pstack.size())\r\n                    assertEquals(list.get(k), pstack.get(k));\r\n                list.add(k, v);\r\n                pstack = pstack.plus(k, v);\r\n            }\r\n        } else if (r.nextBoolean()) {\r\n            int k = r.nextInt(pstack.size());\r\n            Integer v = r.nextInt();\r\n            list.set(k, v);\r\n            pstack = pstack.with(k, v);\r\n        } else {\r\n            int j = r.nextInt(pstack.size()), k = 0;\r\n            for (Integer e : pstack) {\r\n                assertTrue(list.contains(e));\r\n                assertTrue(pstack.contains(e));\r\n                assertEquals(e, pstack.get(k));\r\n                assertEquals(list.get(k), pstack.get(k));\r\n                UtilityTest.assertEqualsAndHash(pstack, pstack.minus(k).plus(k, pstack.get(k)));\r\n                UtilityTest.assertEqualsAndHash(pstack, pstack.plus(k, 10).minus(k));\r\n                if (k == j) {\r\n                    list.remove(k);\r\n                    pstack = pstack.minus(k);\r\n                    k--;\r\n                    j = -1;\r\n                }\r\n                k++;\r\n            }\r\n        }\r\n        Integer v = r.nextInt();\r\n        assertEquals(list.contains(v), pstack.contains(v));\r\n        list.remove(v);\r\n        pstack = pstack.minus(v);\r\n        String s = Integer.toString(v);\r\n        assertFalse(pstack.contains(v));\r\n        pstack = pstack.minus(s);\r\n        assertEquals(list.size(), pstack.size());\r\n        UtilityTest.assertEqualsAndHash(list, pstack);\r\n        UtilityTest.assertEqualsAndHash(pstack, ConsPStack.from(pstack));\r\n        UtilityTest.assertEqualsAndHash(ConsPStack.empty(), pstack.minusAll(pstack));\r\n        UtilityTest.assertEqualsAndHash(pstack, ConsPStack.empty().plusAll(UtilityTest.reverse(pstack)));\r\n        UtilityTest.assertEqualsAndHash(pstack, ConsPStack.singleton(10).plusAll(1, UtilityTest.reverse(pstack)).minus(0));\r\n    }\r\n}"
}, {
	"Path": "picard.sam.markduplicates.AbstractMarkDuplicatesCommandLineProgramTester.updateExpectedDuplicationMetrics",
	"Comment": "fill in expected duplication metrics directly from the input records given to this tester",
	"Method": "void updateExpectedDuplicationMetrics(){\r\n    final FormatUtil formatter = new FormatUtil();\r\n    try (final CloseableIterator<SAMRecord> inputRecordIterator = this.getRecordIterator()) {\r\n        while (inputRecordIterator.hasNext()) {\r\n            final SAMRecord record = inputRecordIterator.next();\r\n            if (record.isSecondaryOrSupplementary()) {\r\n                ++expectedMetrics.SECONDARY_OR_SUPPLEMENTARY_RDS;\r\n            } else {\r\n                final String key = samRecordToDuplicatesFlagsKey(record);\r\n                if (!this.duplicateFlags.containsKey(key)) {\r\n                    System.err.println(\"DOES NOT CONTAIN KEY: \" + key);\r\n                }\r\n                final boolean isDuplicate = this.duplicateFlags.get(key);\r\n                if (record.getReadUnmappedFlag()) {\r\n                    ++expectedMetrics.UNMAPPED_READS;\r\n                } else if (!record.getReadPairedFlag() || record.getMateUnmappedFlag()) {\r\n                    ++expectedMetrics.UNPAIRED_READS_EXAMINED;\r\n                    if (isDuplicate) {\r\n                        ++expectedMetrics.UNPAIRED_READ_DUPLICATES;\r\n                    }\r\n                } else {\r\n                    ++expectedMetrics.READ_PAIRS_EXAMINED;\r\n                    if (isDuplicate) {\r\n                        ++expectedMetrics.READ_PAIR_DUPLICATES;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    expectedMetrics.READ_PAIR_DUPLICATES = expectedMetrics.READ_PAIR_DUPLICATES / 2;\r\n    expectedMetrics.READ_PAIRS_EXAMINED = expectedMetrics.READ_PAIRS_EXAMINED / 2;\r\n    expectedMetrics.calculateDerivedFields();\r\n    expectedMetrics.PERCENT_DUPLICATION = formatter.parseDouble(formatter.format(expectedMetrics.PERCENT_DUPLICATION));\r\n}"
}, {
	"Path": "org.pcap4j.core.PcapHandle.breakLoop",
	"Comment": "breaks a loop which this handle is working on.the loop may not be broken immediately on some osesbecause of buffering or something.as a workaround, letting this capture some bogus packetsafter calling this method may work.",
	"Method": "void breakLoop(){\r\n    if (!open) {\r\n        throw new NotOpenException();\r\n    }\r\n    if (!handleLock.readLock().tryLock()) {\r\n        throw new NotOpenException();\r\n    }\r\n    try {\r\n        if (!open) {\r\n            throw new NotOpenException();\r\n        }\r\n        logger.info(\"Break loop.\");\r\n        NativeMappings.pcap_breakloop(handle);\r\n    } finally {\r\n        handleLock.readLock().unlock();\r\n    }\r\n}"
}, {
	"Path": "com.restfb.types.Page.getScreenNames",
	"Comment": "external accounts. applicable to pages representing people",
	"Method": "List<ScreenName> getScreenNames(){\r\n    return unmodifiableList(screenNames);\r\n}"
}, {
	"Path": "net.pms.configuration.RendererConfiguration.getMaxVideoWidth",
	"Comment": "returns the maximum video width supported by the renderer as defined in\tthe renderer configuration. the default value 0 means unlimited.",
	"Method": "int getMaxVideoWidth(){\r\n    return getInt(MAX_VIDEO_WIDTH, 1920);\r\n}"
}, {
	"Path": "prefuse.action.assignment.DataSizeAction.is2DArea",
	"Comment": "indicates if the size values set by this function represent 2d areas.that is, if the size is a 2d area or a 1d length. the size value willbe scaled appropriately to facilitate better perception of sizedifferences.",
	"Method": "boolean is2DArea(){\r\n    return m_is2DArea;\r\n}"
}, {
	"Path": "net.pms.util.FormLayoutUtil.flip",
	"Comment": "returns an array of column specifications that is built from the given\tencoded column specifications by flipping each column spec and reversing\ttheir order.",
	"Method": "String flip(String encodedColumnSpecs,CellConstraints flip,CellConstraints cc,String colSpec,ComponentOrientation orientation){\r\n    if (orientation.isLeftToRight()) {\r\n        return cc;\r\n    } else {\r\n        int columnCount = colSpec.split(\",\").length;\r\n        return flipHorizontally(cc, columnCount);\r\n    }\r\n}"
}, {
	"Path": "picard.util.AsyncIterator.getNext",
	"Comment": "set thenext to the next item to be returned, or null if there are no more items.",
	"Method": "void getNext(){\r\n    assertOpen();\r\n    checkAndRethrow();\r\n    try {\r\n        theNext = null;\r\n        while (!this.queue.isEmpty() || !this.readerRunnable.isDone()) {\r\n            theNext = this.queue.poll(5, TimeUnit.SECONDS);\r\n            checkAndRethrow();\r\n            if (theNext != null)\r\n                break;\r\n        }\r\n    } catch (InterruptedException ie) {\r\n        throw new RuntimeException(\"Interrupted queueing item for writing.\", ie);\r\n    }\r\n    checkAndRethrow();\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getForcedSubtitleTags",
	"Comment": "returns the tag string that identifies the subtitle language that\tshould be forced.",
	"Method": "String getForcedSubtitleTags(){\r\n    return getString(KEY_FORCED_SUBTITLE_TAGS, \"forced\");\r\n}"
}, {
	"Path": "net.pms.util.Version.getMajor",
	"Comment": "returns the first integer element of this version string,\tor 0 if a first integer was not defined or could not be parsed",
	"Method": "int getMajor(){\r\n    if (elements.length > 0) {\r\n        return elements[0];\r\n    } else {\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "picard.analysis.directed.CollectTargetedMetricsTest.setupBuilder",
	"Comment": "create a samfile with 40000 reads for testing whether a cap is found.",
	"Method": "void setupBuilder(){\r\n    final String readName = \"TESTBARCODE\";\r\n    tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"CollectTargetedMetrics\", \".bam\");\r\n    final File tempSamFileUnsorted = VcfTestUtils.createTemporaryIndexedFile(\"CollectTargetedMetrics\", \".bam\");\r\n    final SAMFileHeader header = new SAMFileHeader();\r\n    try {\r\n        header.setSequenceDictionary(SAMSequenceDictionaryExtractor.extractDictionary(dict.toPath()));\r\n        header.setSortOrder(SAMFileHeader.SortOrder.unsorted);\r\n    } catch (final SAMException e) {\r\n        e.printStackTrace();\r\n    }\r\n    final SAMReadGroupRecord readGroupRecord = new SAMReadGroupRecord(readGroupId);\r\n    readGroupRecord.setSample(sample);\r\n    readGroupRecord.setPlatform(platform);\r\n    readGroupRecord.setLibrary(library);\r\n    readGroupRecord.setPlatformUnit(readGroupId);\r\n    header.addReadGroup(readGroupRecord);\r\n    final SAMRecordSetBuilder setBuilder = new SAMRecordSetBuilder(true, SAMFileHeader.SortOrder.coordinate);\r\n    setBuilder.setRandomSeed(RANDOM_SEED);\r\n    setBuilder.setReadGroup(readGroupRecord);\r\n    setBuilder.setUseNmFlag(true);\r\n    setBuilder.setHeader(header);\r\n    final String separator = \":\";\r\n    final int ID = 1;\r\n    final int max = 15000;\r\n    final int min = 1;\r\n    final Random rg = new Random(5);\r\n    for (int i = 0; i < numReads; i++) {\r\n        final int start = rg.nextInt(max) + min;\r\n        final String newReadName = readName + separator + ID + separator + i;\r\n        setBuilder.addPair(newReadName, 0, start + ID, start + ID + LENGTH);\r\n    }\r\n    final SAMFileWriter writer = new SAMFileWriterFactory().setCreateIndex(true).makeBAMWriter(header, false, tempSamFileUnsorted);\r\n    for (final SAMRecord record : setBuilder) {\r\n        writer.addAlignment(record);\r\n    }\r\n    writer.close();\r\n    final SortSam sorter = new SortSam();\r\n    final String[] args = new String[] { \"INPUT=\" + tempSamFileUnsorted.getAbsolutePath(), \"OUTPUT=\" + tempSamFile.getAbsolutePath(), \"SORT_ORDER=coordinate\" };\r\n    sorter.instanceMain(args);\r\n    outfile = File.createTempFile(\"test\", \".TargetedMetrics_Coverage\");\r\n    perTargetOutfile = File.createTempFile(\"perTarget\", \".perTargetCoverage\");\r\n    tsOutfile = File.createTempFile(\"test\", \".TheoreticalSensitivityMetrics\");\r\n    outfile.deleteOnExit();\r\n    perTargetOutfile.deleteOnExit();\r\n    tsOutfile.deleteOnExit();\r\n}"
}, {
	"Path": "prefuse.action.layout.AxisLayout.getFilter",
	"Comment": "get the predicate filter to limit which items are considered for layout.only items for which the predicate returns a true value are includedin the layout computation.",
	"Method": "Predicate getFilter(){\r\n    return m_filter;\r\n}"
}, {
	"Path": "prefuse.util.TimeLib.getTime",
	"Comment": "get a timestamp for the given hour, minute, and second. the date willbe assumed to be january 1, 1970.",
	"Method": "long getTime(Calendar c,int hour,int minute,int second){\r\n    c.clear(Calendar.MILLISECOND);\r\n    c.set(1970, 0, 1, hour, minute, second);\r\n    return c.getTimeInMillis();\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeProbabilities.getPosteriorProbabilities",
	"Comment": "returns the posterior probabilities using the population frequency as a prior.",
	"Method": "double[] getPosteriorProbabilities(){\r\n    return pNormalizeVector(multiply(getLikelihoods(), getPriorProbablities()));\r\n}"
}, {
	"Path": "net.pms.configuration.RendererConfiguration.getRendererConfigurationBySocketAddress",
	"Comment": "tries to find a matching renderer based on the configuration setting\tfor forced ip address and renderer combinations. if there is no\tmatch, the address is looked up in the address association map which\tcontains a mapping of previously encountered ip addresses and their\trenderers.",
	"Method": "RendererConfiguration getRendererConfigurationBySocketAddress(InetAddress inetAddress){\r\n    String forced = pmsConfiguration.getRendererForceIp();\r\n    if (forced != null && !\"\".equals(forced)) {\r\n        for (String tuple : forced.split(\",\")) {\r\n            if (tuple.indexOf(\"@\") > -1) {\r\n                String name = tuple.split(\"@\")[0];\r\n                String ip = tuple.split(\"@\")[1];\r\n                if (!\"\".equals(name) && !\"\".equals(ip)) {\r\n                    IpFilter filter = new IpFilter(ip);\r\n                    if (filter.isMatch(inetAddress)) {\r\n                        RendererConfiguration renderer = getRendererConfigurationByName(name);\r\n                        if (renderer != null) {\r\n                            logger.trace(\"Forcing renderer match to \\\"\" + renderer.getRendererName() + \"\\\" based on forced IP address configuration\");\r\n                            addressAssociation.put(inetAddress, renderer);\r\n                            return renderer;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return addressAssociation.get(inetAddress);\r\n}"
}, {
	"Path": "picard.illumina.parser.Tile.ensureSoleTilePhasingValuesPerRead",
	"Comment": "for any given tiletemplateread, we want to make sure that there is only a single tilephasingvalue",
	"Method": "Collection<TilePhasingValue> ensureSoleTilePhasingValuesPerRead(Collection<TilePhasingValue> tilePhasingValues){\r\n    final Map<TileTemplateRead, List<TilePhasingValue>> partitionedMap = tilePhasingValues.stream().collect(Collectors.groupingBy(TilePhasingValue::getTileTemplateRead));\r\n    final Collection<TilePhasingValue> newTilePhasingValues = new LinkedList();\r\n    for (final TileTemplateRead read : partitionedMap.keySet()) {\r\n        newTilePhasingValues.add(CollectionUtil.getSoleElement(partitionedMap.get(read)));\r\n    }\r\n    return newTilePhasingValues;\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.setUpdateId",
	"Comment": "sets the update counter for this resource. when the resource needs\tto be refreshed, its counter should be updated.",
	"Method": "void setUpdateId(int updateId){\r\n    this.updateId = updateId;\r\n}"
}, {
	"Path": "picard.sam.SamAlignmentMerger.getQuerynameSortedAlignedRecords",
	"Comment": "reads the aligned sam records into a sortingcollection and returns an iterator over that collection",
	"Method": "CloseableIterator<SAMRecord> getQuerynameSortedAlignedRecords(){\r\n    final CloseableIterator<SAMRecord> mergingIterator;\r\n    final SAMFileHeader header;\r\n    if (alignedSamFile != null && !alignedSamFile.isEmpty()) {\r\n        final List<SAMFileHeader> headers = new ArrayList(alignedSamFile.size());\r\n        final List<SamReader> readers = new ArrayList(alignedSamFile.size());\r\n        for (final File f : this.alignedSamFile) {\r\n            final SamReader r = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(f);\r\n            headers.add(r.getFileHeader());\r\n            readers.add(r);\r\n            if (getProgramRecord() == null && r.getFileHeader().getProgramRecords().size() == 1) {\r\n                setProgramRecord(r.getFileHeader().getProgramRecords().iterator().next());\r\n            }\r\n        }\r\n        alignedSamDictionary = headers.get(0).getSequenceDictionary();\r\n        headers.stream().map(SAMFileHeader::getSequenceDictionary).forEach(alignedSamDictionary::assertSameDictionary);\r\n        final SamFileHeaderMerger headerMerger = new SamFileHeaderMerger(SortOrder.queryname, headers, false);\r\n        mergingIterator = new MergingSamRecordIterator(headerMerger, readers, true);\r\n        header = headerMerger.getMergedHeader();\r\n    } else {\r\n        mergingIterator = new SeparateEndAlignmentIterator(this.read1AlignedSamFile, this.read2AlignedSamFile, referenceFasta);\r\n        header = ((SeparateEndAlignmentIterator) mergingIterator).getHeader();\r\n        alignedSamDictionary = header.getSequenceDictionary();\r\n        if (getProgramRecord() == null && header.getProgramRecords().size() == 1) {\r\n            setProgramRecord(header.getProgramRecords().iterator().next());\r\n        }\r\n    }\r\n    if (!forceSort) {\r\n        return mergingIterator;\r\n    }\r\n    final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class, new BAMRecordCodec(header), new SAMRecordQueryNameComparator(), MAX_RECORDS_IN_RAM);\r\n    int count = 0;\r\n    while (mergingIterator.hasNext()) {\r\n        alignmentSorter.add(mergingIterator.next());\r\n        count++;\r\n        if (count > 0 && count % 1000000 == 0) {\r\n            log.info(\"Read \" + count + \" records from alignment SAM/BAM.\");\r\n        }\r\n    }\r\n    log.info(\"Finished reading \" + count + \" total records from alignment SAM/BAM.\");\r\n    mergingIterator.close();\r\n    return new DelegatingIterator<SAMRecord>(alignmentSorter.iterator()) {\r\n        @Override\r\n        public void close() {\r\n            super.close();\r\n            alignmentSorter.cleanup();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "picard.sam.SamAlignmentMerger.getQuerynameSortedAlignedRecords",
	"Comment": "reads the aligned sam records into a sortingcollection and returns an iterator over that collection",
	"Method": "CloseableIterator<SAMRecord> getQuerynameSortedAlignedRecords(){\r\n    super.close();\r\n    alignmentSorter.cleanup();\r\n}"
}, {
	"Path": "net.pms.test.formats.FormatRecognitionTest.testPlaystationAudioMp3Compatibility",
	"Comment": "test the compatibility of the playstation 3 with the mp3 format.",
	"Method": "void testPlaystationAudioMp3Compatibility(){\r\n    assumeTrue(mediaInfoParserIsValid);\r\n    RendererConfiguration conf = RendererConfiguration.getRendererConfigurationByName(\"Playstation 3\");\r\n    assertNotNull(\"Renderer named \\\"Playstation 3\\\" found.\", conf);\r\n    DLNAMediaInfo info = new DLNAMediaInfo();\r\n    info.setContainer(\"mp3\");\r\n    info.setMimeType(HTTPResource.AUDIO_MP3_TYPEMIME);\r\n    DLNAMediaAudio audio = new DLNAMediaAudio();\r\n    audio.getAudioProperties().setNumberOfChannels(2);\r\n    List<DLNAMediaAudio> audioCodes = new ArrayList<DLNAMediaAudio>();\r\n    audioCodes.add(audio);\r\n    info.setAudioTracksList(audioCodes);\r\n    Format format = new MP3();\r\n    format.match(\"test.mp3\");\r\n    assertEquals(\"PS3 is compatible with MP3\", true, conf.isCompatible(info, format));\r\n    audio.getAudioProperties().setNumberOfChannels(5);\r\n    assertEquals(\"PS3 is incompatible with five channel MP3\", false, conf.isCompatible(info, format));\r\n}"
}, {
	"Path": "py4j.GatewayServer.getPythonServerEntryPoint",
	"Comment": "gets a reference to the entry point on the python side. this is often\tnecessary if java is driving the communication because java cannot call\tstatic methods, initialize python objects or load python modules yet.",
	"Method": "Object getPythonServerEntryPoint(Class[] interfacesToImplement){\r\n    return getCallbackClient().getPythonServerEntryPoint(gateway, interfacesToImplement);\r\n}"
}, {
	"Path": "prefuse.data.search.LuceneSearcher.search",
	"Comment": "searches the lucene index using the given query string, returns an objectwhich provides access to the search results.",
	"Method": "Hits search(String query){\r\n    if (m_readMode) {\r\n        Query q;\r\n        if (fields.length == 1) {\r\n            q = QueryParser.parse(query, fields[0], analyzer);\r\n        } else {\r\n            q = MultiFieldQueryParser.parse(query, fields, analyzer);\r\n        }\r\n        return searcher.search(q);\r\n    } else {\r\n        throw new IllegalStateException(\"Searches can only be performed when \" + \"the LuceneSearcher is in read mode\");\r\n    }\r\n}"
}, {
	"Path": "picard.fingerprint.FingerprintChecker.setmaximalPLDifference",
	"Comment": "sets the maximal difference in pl scores considered when reading pls from a vcf.",
	"Method": "void setmaximalPLDifference(int maximalPLDifference){\r\n    this.maximalPLDifference = maximalPLDifference;\r\n}"
}, {
	"Path": "prefuse.data.query.ListQueryBinding.createComponent",
	"Comment": "creates a new group of check boxes for interacting with the query.",
	"Method": "JComponent createComponent(){\r\n    return createCheckboxGroup();\r\n}"
}, {
	"Path": "prefuse.Visualization.repaint",
	"Comment": "issue a repaint request, causing all displays associated with thisvisualization to be repainted.",
	"Method": "void repaint(){\r\n    Iterator items = items(ValidatedPredicate.FALSE);\r\n    while (items.hasNext()) {\r\n        ((VisualItem) items.next()).validateBounds();\r\n    }\r\n    for (int i = 0; i < m_displays.size(); ++i) {\r\n        getDisplay(i).repaint();\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.ui.JToggleGroup.setMargin",
	"Comment": "set the margin, in pixels, to use at the ends of the jtogglegroup.",
	"Method": "void setMargin(int margin){\r\n    if (margin < 0)\r\n        throw new IllegalArgumentException(\"Margin is less than zero.\");\r\n    m_margin = margin;\r\n    initUI();\r\n}"
}, {
	"Path": "net.pms.configuration.IpFilter.isMatch",
	"Comment": "decides whether or not the ip address matches this filter. if the filter\tis empty, false is returned.",
	"Method": "boolean isMatch(InetAddress addr){\r\n    for (Predicate predicate : matchers) {\r\n        if (predicate.match(addr)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.isMencoderScaler",
	"Comment": "returns true if mencoder should be used to upscale the video to an\toptimal resolution. default value is false, meaning the renderer will\tupscale the video itself.",
	"Method": "boolean isMencoderScaler(){\r\n    return getBoolean(KEY_MENCODER_SCALER, false);\r\n}"
}, {
	"Path": "picard.sam.util.PhysicalLocation.hasLocation",
	"Comment": "default implementation of a method to check whether real location data has been set.",
	"Method": "boolean hasLocation(){\r\n    return getTile() != NO_VALUE;\r\n}"
}, {
	"Path": "com.restfb.types.Application.getAuthReferralUserPerms",
	"Comment": "basic user permissions that a user must grant when authenticated referrals are enabled.",
	"Method": "List<String> getAuthReferralUserPerms(){\r\n    return Collections.unmodifiableList(authReferralUserPerms);\r\n}"
}, {
	"Path": "picard.cmdline.PicardCommandLine.instanceMain",
	"Comment": "the main method.give a list of java packages in which to search for classes that extend commandlineprogram.those will be includedon the command line.",
	"Method": "int instanceMain(String[] args,List<String> packageList,String commandLineName,int instanceMain,String[] args){\r\n    return instanceMain(args, getPackageList(), COMMAND_LINE_NAME);\r\n}"
}, {
	"Path": "prefuse.util.force.ForceSimulator.accumulate",
	"Comment": "accumulate all forces acting on the items in this simulation",
	"Method": "void accumulate(){\r\n    for (int i = 0; i < iflen; i++) iforces[i].init(this);\r\n    for (int i = 0; i < sflen; i++) sforces[i].init(this);\r\n    Iterator itemIter = items.iterator();\r\n    while (itemIter.hasNext()) {\r\n        ForceItem item = (ForceItem) itemIter.next();\r\n        item.force[0] = 0.0f;\r\n        item.force[1] = 0.0f;\r\n        for (int i = 0; i < iflen; i++) iforces[i].getForce(item);\r\n    }\r\n    Iterator springIter = springs.iterator();\r\n    while (springIter.hasNext()) {\r\n        Spring s = (Spring) springIter.next();\r\n        for (int i = 0; i < sflen; i++) {\r\n            sforces[i].getForce(s);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.i18n.CwNumberFormat.updatePattern",
	"Comment": "update the selected pattern based on the pattern in the list.",
	"Method": "void updatePattern(){\r\n    switch(patternList.getSelectedIndex()) {\r\n        case 0:\r\n            activeFormat = NumberFormat.getDecimalFormat();\r\n            patternBox.setText(activeFormat.getPattern());\r\n            patternBox.setEnabled(false);\r\n            break;\r\n        case 1:\r\n            activeFormat = NumberFormat.getCurrencyFormat();\r\n            patternBox.setText(activeFormat.getPattern());\r\n            patternBox.setEnabled(false);\r\n            break;\r\n        case 2:\r\n            activeFormat = NumberFormat.getScientificFormat();\r\n            patternBox.setText(activeFormat.getPattern());\r\n            patternBox.setEnabled(false);\r\n            break;\r\n        case 3:\r\n            activeFormat = NumberFormat.getPercentFormat();\r\n            patternBox.setText(activeFormat.getPattern());\r\n            patternBox.setEnabled(false);\r\n            break;\r\n        case 4:\r\n            patternBox.setEnabled(true);\r\n            String pattern = patternBox.getText();\r\n            try {\r\n                activeFormat = NumberFormat.getFormat(pattern);\r\n            } catch (IllegalArgumentException e) {\r\n                showErrorMessage(constants.cwNumberFormatInvalidPattern());\r\n                return;\r\n            }\r\n            break;\r\n    }\r\n    updateFormattedValue();\r\n}"
}, {
	"Path": "com.restfb.json.JsonArray.values",
	"Comment": "returns a list of the values in this array in document order. the returned list is backed by this array and willreflect subsequent changes. it cannot be used to modify this array. attempts to modify the returned list willresult in an exception.",
	"Method": "List<JsonValue> values(){\r\n    return Collections.unmodifiableList(values);\r\n}"
}, {
	"Path": "picard.illumina.parser.PerTilePerCycleFileUtil.getTiles",
	"Comment": "discover all files of this type in expectedbase that match pattern and construct a list of tilesavailable based on these files.the same number of tiles is expected in each cycle dir.",
	"Method": "List<Integer> getTiles(){\r\n    return tiles;\r\n}"
}, {
	"Path": "com.google.gwt.sample.dynatablerf.client.PersonEditorWorkflow.onValueChanged",
	"Comment": "called by the favorite checkbox when its value has been toggled.",
	"Method": "void onValueChanged(ValueChangeEvent<Boolean> event){\r\n    manager.setFavorite(person.stableId(), favorite.getValue());\r\n}"
}, {
	"Path": "prefuse.data.CascadedTable.removeCascadedRow",
	"Comment": "internal method for removing a cascaded row from this table.",
	"Method": "boolean removeCascadedRow(int row){\r\n    boolean rv = super.removeRow(row);\r\n    if (rv)\r\n        ((CascadedRowManager) m_rows).remove(row);\r\n    return rv;\r\n}"
}, {
	"Path": "com.google.gwt.sample.json.client.JSON.addChildren",
	"Comment": "add the object presented by the jsonvalue as a children to the requestedtreeitem.",
	"Method": "void addChildren(TreeItem treeItem,JSONValue jsonValue){\r\n    JSONArray jsonArray;\r\n    JSONObject jsonObject;\r\n    JSONString jsonString;\r\n    if ((jsonArray = jsonValue.isArray()) != null) {\r\n        for (int i = 0; i < jsonArray.size(); ++i) {\r\n            TreeItem child = treeItem.addItem(getChildText(\"[\" + Integer.toString(i) + \"]\"));\r\n            addChildren(child, jsonArray.get(i));\r\n        }\r\n    } else if ((jsonObject = jsonValue.isObject()) != null) {\r\n        Set<String> keys = jsonObject.keySet();\r\n        for (String key : keys) {\r\n            TreeItem child = treeItem.addItem(getChildText(key));\r\n            addChildren(child, jsonObject.get(key));\r\n        }\r\n    } else if ((jsonString = jsonValue.isString()) != null) {\r\n        treeItem.addItem(SafeHtmlUtils.fromString(jsonString.stringValue()));\r\n    } else {\r\n        treeItem.addItem(getChildText(jsonValue.toString()));\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.ui.JRangeSlider.setLowValue",
	"Comment": "sets the low value shown by this range slider. this causes the range slider to berepainted and a changeevent to be fired.",
	"Method": "void setLowValue(int lowValue){\r\n    int e = (model.getValue() - lowValue) + model.getExtent();\r\n    model.setRangeProperties(lowValue, e, model.getMinimum(), model.getMaximum(), false);\r\n    model.setValue(lowValue);\r\n}"
}, {
	"Path": "prefuse.util.StringLib.capitalizeFirstOnly",
	"Comment": "capitalize all letters preceded by whitespace, and lower caseall other letters.",
	"Method": "String capitalizeFirstOnly(String s){\r\n    if (s == null)\r\n        return null;\r\n    if (s.length() == 0)\r\n        return s;\r\n    StringBuffer sbuf = new StringBuffer();\r\n    char c = s.charAt(0);\r\n    sbuf.append(Character.toUpperCase(c));\r\n    boolean space = Character.isWhitespace(c);\r\n    for (int i = 1; i < s.length(); ++i) {\r\n        c = s.charAt(i);\r\n        if (Character.isWhitespace(c)) {\r\n            space = true;\r\n        } else if (space) {\r\n            c = Character.toUpperCase(c);\r\n            space = false;\r\n        } else {\r\n            c = Character.toLowerCase(c);\r\n        }\r\n        sbuf.append(c);\r\n    }\r\n    return sbuf.toString();\r\n}"
}, {
	"Path": "prefuse.util.PrefuseLib.getDisplayStats",
	"Comment": "returns a string showing debugging info such as number of visualizeditems and the current frame rate.",
	"Method": "String getDisplayStats(Display d){\r\n    float fr = Math.round(d.getFrameRate() * 100f) / 100f;\r\n    Runtime rt = Runtime.getRuntime();\r\n    long tm = rt.totalMemory() / (2 << 20);\r\n    long fm = rt.freeMemory() / (2 << 20);\r\n    long mm = rt.maxMemory() / (2 << 20);\r\n    StringBuffer sb = new StringBuffer();\r\n    sb.append(\"frame rate: \").append(fr).append(\"fps - \");\r\n    sb.append(d.getVisibleItemCount()).append(\" items - \");\r\n    sb.append(\"fonts(\").append(FontLib.getCacheMissCount());\r\n    sb.append(\") colors(\");\r\n    sb.append(ColorLib.getCacheMissCount()).append(')');\r\n    sb.append(\" mem(\");\r\n    sb.append(tm - fm).append(\"M / \");\r\n    sb.append(mm).append(\"M)\");\r\n    sb.append(\" (x:\");\r\n    sb.append(StringLib.formatNumber(d.getDisplayX(), 2));\r\n    sb.append(\", y:\");\r\n    sb.append(StringLib.formatNumber(d.getDisplayY(), 2));\r\n    sb.append(\", z:\");\r\n    sb.append(StringLib.formatNumber(d.getScale(), 5)).append(\")\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "prefuse.data.Tree.childEdges",
	"Comment": "get an iterator over the edges connecting child nodes to a given parent",
	"Method": "Iterator childEdges(Node n){\r\n    return super.outEdges(n);\r\n}"
}, {
	"Path": "prefuse.data.tuple.TableTuple.validityCheck",
	"Comment": "internal validity check. throw an exception if the tuple is not valid.",
	"Method": "void validityCheck(){\r\n    if (m_row == -1) {\r\n        throw new IllegalStateException(\"This tuple is no longer valid. \" + \"It has been deleted from its table\");\r\n    }\r\n}"
}, {
	"Path": "picard.util.ClippingUtility.adapterTrimIlluminaPairedReads",
	"Comment": "invokes adaptertrimilluminaread with explicit parameters for a pair of reads.more general form of two overloads.returns a warning string when the trim positions found differed for each read.",
	"Method": "String adapterTrimIlluminaPairedReads(SAMRecord read1,SAMRecord read2,AdapterPair adapters,String adapterTrimIlluminaPairedReads,SAMRecord read1,SAMRecord read2,AdapterPair adapters,int minMatchBases,double maxErrorRate,AdapterPair adapterTrimIlluminaPairedReads,SAMRecord read1,SAMRecord read2,AdapterPair adapters,AdapterPair adapterTrimIlluminaPairedReads,SAMRecord read1,SAMRecord read2,int minMatchBases,double maxErrorRate,AdapterPair adapters){\r\n    AdapterPair matched = null;\r\n    for (final AdapterPair adapterPair : adapters) {\r\n        final int index1 = findIndexOfClipSequence(getReadBases(read1), adapterPair.get3PrimeAdapterBytes(), minMatchBases, maxErrorRate);\r\n        final int index2 = findIndexOfClipSequence(getReadBases(read2), adapterPair.get5PrimeAdapterBytesInReadOrder(), minMatchBases, maxErrorRate);\r\n        if (index1 == index2) {\r\n            if (index1 != NO_MATCH) {\r\n                read1.setAttribute(ReservedTagConstants.XT, index1 + 1);\r\n                read2.setAttribute(ReservedTagConstants.XT, index2 + 1);\r\n                return adapterPair;\r\n            } else {\r\n            }\r\n        } else if (index1 == NO_MATCH || index2 == NO_MATCH) {\r\n            if (attemptOneSidedMatch(read1, read2, index1, index2, 2 * minMatchBases)) {\r\n                matched = adapterPair;\r\n            }\r\n        } else {\r\n        }\r\n    }\r\n    return matched;\r\n}"
}, {
	"Path": "picard.vcf.GenotypeConcordance.spliceOrAppendString",
	"Comment": "inserts the given string into the destination string at the given index.if the index is past the end of thedestination string, the given string is appended to the destination.if the destination string is thespanning deletion allele it will be returned unchanged.",
	"Method": "String spliceOrAppendString(String destination,String toInsert,int insertIdx){\r\n    if (destination.equals(Allele.SPAN_DEL_STRING)) {\r\n        return destination;\r\n    }\r\n    if (insertIdx <= destination.length()) {\r\n        return destination.substring(0, insertIdx) + toInsert + destination.substring(insertIdx);\r\n    }\r\n    return destination + toInsert;\r\n}"
}, {
	"Path": "picard.util.FifoBufferTest.testFifoBuffer",
	"Comment": "simply invokes the real test method many times with different inputs.",
	"Method": "void testFifoBuffer(){\r\n    test(1);\r\n    test(2);\r\n    test(3);\r\n    test(4);\r\n    test(5);\r\n    test(6);\r\n    test(7);\r\n    test(8);\r\n    test(9);\r\n    test(10);\r\n    test(10.1345);\r\n    test(150);\r\n}"
}, {
	"Path": "prefuse.util.ui.JRangeSlider.setMaximum",
	"Comment": "sets the maximum possible value for either the low value or the high value.",
	"Method": "void setMaximum(int maximum){\r\n    model.setMaximum(maximum);\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.getStartFont",
	"Comment": "get the starting font for the row. the font is used as the defaulttypeface for drawing text for this item.",
	"Method": "Font getStartFont(int row){\r\n    return (Font) get(row, VisualItem.STARTFONT);\r\n}"
}, {
	"Path": "prefuse.render.LabelRenderer.setImageField",
	"Comment": "set the data field for image locations. the value storedin the data field should be a url, a file within the current classpath,a file on the filesystem, or null for no image. if theimagefield parameter is null, no images at all will bedrawn.",
	"Method": "void setImageField(String imageField){\r\n    if (imageField != null)\r\n        m_images = new ImageFactory();\r\n    m_imageName = imageField;\r\n}"
}, {
	"Path": "picard.sam.markduplicates.util.PhysicalLocationForMateCigarSet.add",
	"Comment": "adds the end to this set, if not already added based on physical location",
	"Method": "void add(ReadEndsForMateCigar end){\r\n    final PhysicalLocationForMateCigar location = new PhysicalLocationForMateCigar(end);\r\n    if (!physicalLocations.contains(location)) {\r\n        readEnds.add(end);\r\n        physicalLocations.add(new PhysicalLocationForMateCigar(location));\r\n    }\r\n}"
}, {
	"Path": "net.pms.xmlwise.Xmlwise.createXml",
	"Comment": "creates a document from a string and transforms it into an xmlelement tree.",
	"Method": "XmlElement createXml(String xml){\r\n    return new XmlElement(createDocument(xml).getDocumentElement());\r\n}"
}, {
	"Path": "com.egzosn.pay.paypal.bean.order.Error.getDebugId",
	"Comment": "paypal internal identifier used for correlation purposes.",
	"Method": "String getDebugId(){\r\n    return this.debugId;\r\n}"
}, {
	"Path": "picard.sam.SamErrorMetric.ReadBaseStratification.wrapStaticReadFunction",
	"Comment": "a simpler factory for generating stateless stratifier instances given a static function and a string",
	"Method": "RecordStratifier<T> wrapStaticReadFunction(Function<SAMRecord, T> staticStratify,String suffix){\r\n    return new RecordStratifier<T>() {\r\n        @Override\r\n        public T stratify(final SAMRecord sam) {\r\n            return staticStratify.apply(sam);\r\n        }\r\n        @Override\r\n        public String getSuffix() {\r\n            return suffix;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "picard.sam.SamErrorMetric.ReadBaseStratification.wrapStaticReadFunction",
	"Comment": "a simpler factory for generating stateless stratifier instances given a static function and a string",
	"Method": "RecordStratifier<T> wrapStaticReadFunction(Function<SAMRecord, T> staticStratify,String suffix){\r\n    return staticStratify.apply(sam);\r\n}"
}, {
	"Path": "picard.sam.SamErrorMetric.ReadBaseStratification.wrapStaticReadFunction",
	"Comment": "a simpler factory for generating stateless stratifier instances given a static function and a string",
	"Method": "RecordStratifier<T> wrapStaticReadFunction(Function<SAMRecord, T> staticStratify,String suffix){\r\n    return suffix;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setMencoderSubFribidi",
	"Comment": "sets whether or not mencoder should use fribidi mode, which\tis needed to display subtitles in languages that read from right to\tleft, like arabic, farsi, hebrew, urdu, etc. default value is false.",
	"Method": "void setMencoderSubFribidi(boolean value){\r\n    configuration.setProperty(KEY_MENCODER_SUB_FRIBIDI, value);\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.canSetBoolean",
	"Comment": "indicates if convenience set method can be called withoutan exception being thrown for the boolean type.",
	"Method": "boolean canSetBoolean(){\r\n    return canSet(boolean.class);\r\n}"
}, {
	"Path": "prefuse.action.layout.StackedAreaChart.setNormalized",
	"Comment": "sets if the stacks are normalized, such that eachcolumn is independently scaled.",
	"Method": "void setNormalized(boolean b){\r\n    m_norm = b;\r\n}"
}, {
	"Path": "picard.analysis.AbstractWgsMetricsCollector.setCounter",
	"Comment": "sets the counter to the current number of processed loci. counter, must be updatedfrom outside, since we are skipping a no call reference positions outside of the collector",
	"Method": "void setCounter(long counter){\r\n    this.counter = counter;\r\n}"
}, {
	"Path": "quickfix.mina.message.PatternMatcher.find",
	"Comment": "searches for the given pattern within a buffer,starting at the given buffer offset.",
	"Method": "long find(IoBuffer buffer,int offset){\r\n    int length;\r\n    byte first = pattern[0];\r\n    for (int limit = buffer.limit() - minLength + 1; offset < limit; offset++) {\r\n        if (buffer.get(offset) == first && (length = match(buffer, offset)) > 0) {\r\n            return (long) length << 32 | offset;\r\n        }\r\n    }\r\n    return -1L;\r\n}"
}, {
	"Path": "picard.sam.ReplaceSamHeader.doWork",
	"Comment": "do the work after command line has been parsed.runtimeexception may be thrown by this method, and are reported appropriately.",
	"Method": "int doWork(){\r\n    IOUtil.assertFileIsReadable(INPUT);\r\n    IOUtil.assertFileIsReadable(HEADER);\r\n    IOUtil.assertFileIsWritable(OUTPUT);\r\n    final SAMFileHeader replacementHeader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).getFileHeader(HEADER);\r\n    if (BamFileIoUtils.isBamFile(INPUT)) {\r\n        blockCopyReheader(replacementHeader);\r\n    } else {\r\n        standardReheader(replacementHeader);\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "prefuse.render.ImageFactory.setMaxImageDimensions",
	"Comment": "sets the maximum image dimensions of loaded images, images larger thanthese limits will be scaled to fit within bounds.",
	"Method": "void setMaxImageDimensions(int width,int height){\r\n    m_maxImageWidth = width;\r\n    m_maxImageHeight = height;\r\n}"
}, {
	"Path": "net.pms.io.BufferedOutputFileImpl.modulo",
	"Comment": "determine a modulo value that is guaranteed to be zero or positive,\tas opposed to the standard java % operator which can return a\tnegative value.",
	"Method": "int modulo(int number,int divisor){\r\n    if (number >= 0) {\r\n        return number % divisor;\r\n    }\r\n    return ((number % divisor) + divisor) % divisor;\r\n}"
}, {
	"Path": "picard.sam.markduplicates.EstimateLibraryComplexity.doWork",
	"Comment": "method that does most of the work.reads through the input bam file and extracts theread sequences of each read pair and sorts them via a sortingcollection.then traversesthe sorted reads and looks at small groups at a time to find duplicates.",
	"Method": "int doWork(){\r\n    for (final File f : INPUT) IOUtil.assertFileIsReadable(f);\r\n    log.info(\"Will store \" + MAX_RECORDS_IN_RAM + \" read pairs in memory before sorting.\");\r\n    final List<SAMReadGroupRecord> readGroups = new ArrayList<SAMReadGroupRecord>();\r\n    final SortingCollection<PairedReadSequence> sorter;\r\n    final boolean useBarcodes = (null != BARCODE_TAG || null != READ_ONE_BARCODE_TAG || null != READ_TWO_BARCODE_TAG);\r\n    if (!useBarcodes) {\r\n        sorter = SortingCollection.newInstance(PairedReadSequence.class, new PairedReadCodec(), new PairedReadComparator(), MAX_RECORDS_IN_RAM, TMP_DIR);\r\n    } else {\r\n        sorter = SortingCollection.newInstance(PairedReadSequence.class, new PairedReadWithBarcodesCodec(), new PairedReadComparator(), MAX_RECORDS_IN_RAM, TMP_DIR);\r\n    }\r\n    final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Read\");\r\n    for (final File f : INPUT) {\r\n        final Map<String, PairedReadSequence> pendingByName = new HashMap<String, PairedReadSequence>();\r\n        final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(f);\r\n        readGroups.addAll(in.getFileHeader().getReadGroups());\r\n        for (final SAMRecord rec : in) {\r\n            if (!rec.getReadPairedFlag())\r\n                continue;\r\n            if (!rec.getFirstOfPairFlag() && !rec.getSecondOfPairFlag()) {\r\n                continue;\r\n            }\r\n            if (rec.isSecondaryOrSupplementary())\r\n                continue;\r\n            PairedReadSequence prs = pendingByName.remove(rec.getReadName());\r\n            if (prs == null) {\r\n                prs = useBarcodes ? new PairedReadSequenceWithBarcodes() : new PairedReadSequence();\r\n                if (opticalDuplicateFinder.addLocationInformation(rec.getReadName(), prs)) {\r\n                    final SAMReadGroupRecord rg = rec.getReadGroup();\r\n                    if (rg != null)\r\n                        prs.setReadGroup((short) readGroups.indexOf(rg));\r\n                }\r\n                pendingByName.put(rec.getReadName(), prs);\r\n            }\r\n            final boolean passesQualityCheck = passesQualityCheck(rec.getReadBases(), rec.getBaseQualities(), MIN_IDENTICAL_BASES, MIN_MEAN_QUALITY);\r\n            prs.qualityOk = prs.qualityOk && passesQualityCheck;\r\n            final byte[] bases = rec.getReadBases();\r\n            if (rec.getReadNegativeStrandFlag())\r\n                SequenceUtil.reverseComplement(bases);\r\n            final PairedReadSequenceWithBarcodes prsWithBarcodes = (useBarcodes) ? (PairedReadSequenceWithBarcodes) prs : null;\r\n            if (rec.getFirstOfPairFlag()) {\r\n                prs.read1 = bases;\r\n                if (useBarcodes) {\r\n                    prsWithBarcodes.barcode = getBarcodeValue(rec);\r\n                    prsWithBarcodes.readOneBarcode = getReadOneBarcodeValue(rec);\r\n                }\r\n            } else {\r\n                prs.read2 = bases;\r\n                if (useBarcodes) {\r\n                    prsWithBarcodes.readTwoBarcode = getReadTwoBarcodeValue(rec);\r\n                }\r\n            }\r\n            if (prs.read1 != null && prs.read2 != null && prs.qualityOk) {\r\n                sorter.add(prs);\r\n            }\r\n            progress.record(rec);\r\n        }\r\n        CloserUtil.close(in);\r\n    }\r\n    log.info(String.format(\"Finished reading - read %d records - moving on to scanning for duplicates.\", progress.getCount()));\r\n    final PeekableIterator<PairedReadSequence> iterator = new PeekableIterator<PairedReadSequence>(sorter.iterator());\r\n    final Map<String, Histogram<Integer>> duplicationHistosByLibrary = new HashMap<String, Histogram<Integer>>();\r\n    final Map<String, Histogram<Integer>> opticalHistosByLibrary = new HashMap<String, Histogram<Integer>>();\r\n    int groupsProcessed = 0;\r\n    long lastLogTime = System.currentTimeMillis();\r\n    final int meanGroupSize = (int) (Math.max(1, (progress.getCount() / 2) / (int) pow(4, MIN_IDENTICAL_BASES * 2)));\r\n    ElcDuplicatesFinderResolver algorithmResolver = new ElcDuplicatesFinderResolver(MAX_DIFF_RATE, MAX_READ_LENGTH, MIN_IDENTICAL_BASES, useBarcodes, opticalDuplicateFinder);\r\n    while (iterator.hasNext()) {\r\n        final List<PairedReadSequence> group = getNextGroup(iterator);\r\n        if (group.size() > meanGroupSize * MAX_GROUP_RATIO) {\r\n            final PairedReadSequence prs = group.get(0);\r\n            log.warn(\"Omitting group with over \" + MAX_GROUP_RATIO + \" times the expected mean number of read pairs. \" + \"Mean=\" + meanGroupSize + \", Actual=\" + group.size() + \". Prefixes: \" + StringUtil.bytesToString(prs.read1, 0, MIN_IDENTICAL_BASES) + \" / \" + StringUtil.bytesToString(prs.read2, 0, MIN_IDENTICAL_BASES));\r\n        } else {\r\n            final Map<String, List<PairedReadSequence>> sequencesByLibrary = splitByLibrary(group, readGroups);\r\n            for (final Map.Entry<String, List<PairedReadSequence>> entry : sequencesByLibrary.entrySet()) {\r\n                final String library = entry.getKey();\r\n                final List<PairedReadSequence> seqs = entry.getValue();\r\n                Histogram<Integer> duplicationHisto = duplicationHistosByLibrary.get(library);\r\n                Histogram<Integer> opticalHisto = opticalHistosByLibrary.get(library);\r\n                if (duplicationHisto == null) {\r\n                    duplicationHisto = new Histogram(\"duplication_group_count\", library);\r\n                    opticalHisto = new Histogram(\"duplication_group_count\", \"optical_duplicates\");\r\n                    duplicationHistosByLibrary.put(library, duplicationHisto);\r\n                    opticalHistosByLibrary.put(library, opticalHisto);\r\n                }\r\n                algorithmResolver.resolveAndSearch(seqs, duplicationHisto, opticalHisto);\r\n            }\r\n            ++groupsProcessed;\r\n            if (lastLogTime < System.currentTimeMillis() - 60000) {\r\n                log.info(\"Processed \" + groupsProcessed + \" groups.\");\r\n                lastLogTime = System.currentTimeMillis();\r\n            }\r\n        }\r\n    }\r\n    iterator.close();\r\n    sorter.cleanup();\r\n    final MetricsFile<DuplicationMetrics, Integer> file = getMetricsFile();\r\n    for (final String library : duplicationHistosByLibrary.keySet()) {\r\n        final Histogram<Integer> duplicationHisto = duplicationHistosByLibrary.get(library);\r\n        final Histogram<Integer> opticalHisto = opticalHistosByLibrary.get(library);\r\n        final DuplicationMetrics metrics = new DuplicationMetrics();\r\n        metrics.LIBRARY = library;\r\n        for (final Integer bin : duplicationHisto.keySet()) {\r\n            final double duplicateGroups = duplicationHisto.get(bin).getValue();\r\n            final double opticalDuplicates = opticalHisto.get(bin) == null ? 0 : opticalHisto.get(bin).getValue();\r\n            if (duplicateGroups >= MIN_GROUP_COUNT) {\r\n                metrics.READ_PAIRS_EXAMINED += (bin * duplicateGroups);\r\n                metrics.READ_PAIR_DUPLICATES += ((bin - 1) * duplicateGroups);\r\n                metrics.READ_PAIR_OPTICAL_DUPLICATES += opticalDuplicates;\r\n            }\r\n        }\r\n        metrics.calculateDerivedFields();\r\n        file.addMetric(metrics);\r\n        file.addHistogram(duplicationHisto);\r\n    }\r\n    file.write(OUTPUT);\r\n    return 0;\r\n}"
}, {
	"Path": "prefuse.data.search.LuceneSearcher.getIndexReader",
	"Comment": "returns the lucene indexreader. see lucene documentationfor more details.",
	"Method": "IndexReader getIndexReader(){\r\n    return reader;\r\n}"
}, {
	"Path": "net.pms.util.PlayerUtil.isType",
	"Comment": "returns whether or not the supplied dlna resource matches the supplied format and format identifier",
	"Method": "boolean isType(DLNAResource resource,int matchType,Format.Identifier matchIdentifier){\r\n    boolean match = false;\r\n    if (resource != null) {\r\n        Format format = resource.getFormat();\r\n        if ((format != null) && ((format.getType() & matchType) == matchType)) {\r\n            if (matchIdentifier == null) {\r\n                match = true;\r\n            } else {\r\n                Format.Identifier identifier = format.getIdentifier();\r\n                match = identifier.equals(matchIdentifier);\r\n            }\r\n        }\r\n    }\r\n    return match;\r\n}"
}, {
	"Path": "quickfix.SessionSettings.getBool",
	"Comment": "gets a boolean value from the default section of the settings.",
	"Method": "boolean getBool(String key,boolean getBool,SessionID sessionID,String key){\r\n    try {\r\n        return BooleanConverter.convert(getString(sessionID, key));\r\n    } catch (final FieldConvertError e) {\r\n        throw new ConfigError(e);\r\n    }\r\n}"
}, {
	"Path": "prefuse.Display.setVisualization",
	"Comment": "set the visualiztion associated with this display. this displaywill render the items contained in the provided visualization. if thisdisplay is already associated with a different visualization, thedisplay unregisters itself with the previous one.",
	"Method": "void setVisualization(Visualization vis){\r\n    if (m_vis == vis) {\r\n        return;\r\n    } else if (m_vis != null) {\r\n        m_vis.removeDisplay(this);\r\n    }\r\n    m_vis = vis;\r\n    if (m_vis != null)\r\n        m_vis.addDisplay(this);\r\n}"
}, {
	"Path": "picard.sam.HitsForInsert.hasSupplementalHits",
	"Comment": "true if either the first or second of pair has supplementary alignments, otherwise false.",
	"Method": "boolean hasSupplementalHits(){\r\n    return !(this.supplementalFirstOfPairOrFragment.isEmpty() && this.supplementalSecondOfPair.isEmpty());\r\n}"
}, {
	"Path": "picard.sam.CreateSequenceDictionary.customCommandLineValidation",
	"Comment": "use reference filename to create uri to go into header if uri was not passed on cmd line.",
	"Method": "String[] customCommandLineValidation(){\r\n    if (URI == null) {\r\n        URI = \"file:\" + referenceSequence.getReferenceFile().getAbsolutePath();\r\n    }\r\n    if (OUTPUT == null) {\r\n        OUTPUT = ReferenceSequenceFileFactory.getDefaultDictionaryForReferenceSequence(referenceSequence.getReferenceFile());\r\n        logger.info(\"Output dictionary will be written in \", OUTPUT);\r\n    }\r\n    return super.customCommandLineValidation();\r\n}"
}, {
	"Path": "picard.sam.FastqToSamTest.permissiveFormatFiles",
	"Comment": "permissive fastq format, i.e. contain blank lines at various places",
	"Method": "Object[][] permissiveFormatFiles(){\r\n    return new Object[][] { { \"permissive-format/pair1.txt\", \"permissive-format/pair2.txt\", FastqQualityFormat.Standard }, { \"permissive-format/s_1_1_sequence.txt\", \"permissive-format/s_1_2_sequence.txt\", FastqQualityFormat.Illumina }, { \"permissive-format/pair1.txt\", null, FastqQualityFormat.Standard }, { \"permissive-format/pair2.txt\", null, FastqQualityFormat.Standard }, { \"permissive-format/s_1_1_sequence.txt\", null, FastqQualityFormat.Illumina }, { \"permissive-format/s_1_2_sequence.txt\", null, FastqQualityFormat.Illumina }, { \"permissive-format/s_1_sequence.txt\", null, FastqQualityFormat.Illumina } };\r\n}"
}, {
	"Path": "prefuse.activity.ActivityManager._alwaysScheduleAfter",
	"Comment": "schedules an activity to start immediately after another activity.the second activity will be scheduled to start immediately after thefirst one finishes, overwriting any previously set starttime. if thefirst activity is cancelled, the second one will not run.this functionality is provided by using an activitylistener to monitorthe first activity. the listener will persist across mulitple runs,meaning the second activity will always be evoked upon a successfulfinish of the first.this method does not otherwise effect the scheduling of the first activity.",
	"Method": "void _alwaysScheduleAfter(Activity before,Activity after){\r\n    before.addActivityListener(new ScheduleAfterActivity(after, false));\r\n}"
}, {
	"Path": "py4j.instrumented.InstrGatewayServer.createConnection",
	"Comment": "creates a server connection from a python call to the java side.",
	"Method": "Py4JServerConnection createConnection(Gateway gateway,Socket socket){\r\n    InstrGatewayConnection connection = new InstrGatewayConnection(gateway, socket, getCustomCommands(), getListeners());\r\n    connection.startConnection();\r\n    return connection;\r\n}"
}, {
	"Path": "prefuse.action.distortion.Distortion.setSizeDistorted",
	"Comment": "controls whether item sizes are distorted along with the item locations.",
	"Method": "void setSizeDistorted(boolean s){\r\n    m_distortSize = s;\r\n}"
}, {
	"Path": "py4j.GatewayConnection.startConnection",
	"Comment": "wraps the gatewayconnection in a thread and start the thread.",
	"Method": "void startConnection(){\r\n    Thread t = new Thread(this);\r\n    t.start();\r\n}"
}, {
	"Path": "prefuse.util.DataLib.ordinalArray",
	"Comment": "get a sorted array containing all column values for a given table andfield.",
	"Method": "Object[] ordinalArray(Iterator tuples,String field,Object[] ordinalArray,Iterator tuples,String field,Comparator cmp,Object[] ordinalArray,TupleSet tuples,String field,Object[] ordinalArray,TupleSet tuples,String field,Comparator cmp){\r\n    if (tuples instanceof Table) {\r\n        ColumnMetadata md = ((Table) tuples).getMetadata(field);\r\n        return md.getOrdinalArray();\r\n    } else {\r\n        return ordinalArray(tuples.tuples(), field, cmp);\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.search.LuceneSearcher.setFields",
	"Comment": "sets the indexed document fields. these fields determine whichfields are indexed as documents are added and which fields arequeried over when searches are issued.param fields the indexed document fields to use",
	"Method": "void setFields(String[] fields){\r\n    this.fields = (String[]) fields.clone();\r\n}"
}, {
	"Path": "picard.vcf.GenotypeConcordance.getVariantContextWriter",
	"Comment": "gets the variant context writer if the output vcf is to be written, otherwise empty.",
	"Method": "Optional<VariantContextWriter> getVariantContextWriter(VCFFileReader truthReader,VCFFileReader callReader){\r\n    if (OUTPUT_VCF) {\r\n        final File outputVcfFile = new File(OUTPUT + OUTPUT_VCF_FILE_EXTENSION);\r\n        final VariantContextWriterBuilder builder = new VariantContextWriterBuilder().setOutputFile(outputVcfFile).setReferenceDictionary(callReader.getFileHeader().getSequenceDictionary()).setOption(Options.ALLOW_MISSING_FIELDS_IN_HEADER).setOption(Options.INDEX_ON_THE_FLY);\r\n        final VariantContextWriter writer = builder.build();\r\n        final List<String> sampleNames = Arrays.asList(OUTPUT_VCF_CALL_SAMPLE_NAME, OUTPUT_VCF_TRUTH_SAMPLE_NAME);\r\n        final Set<VCFHeaderLine> headerLines = new HashSet();\r\n        headerLines.addAll(callReader.getFileHeader().getMetaDataInInputOrder());\r\n        headerLines.addAll(truthReader.getFileHeader().getMetaDataInInputOrder());\r\n        headerLines.add(CONTINGENCY_STATE_HEADER_LINE);\r\n        writer.writeHeader(new VCFHeader(headerLines, sampleNames));\r\n        return Optional.of(writer);\r\n    } else {\r\n        return Optional.empty();\r\n    }\r\n}"
}, {
	"Path": "com.google.gwt.sample.dynatablerf.server.ScheduleSource.of",
	"Comment": "create a schedulelocator that will read through to the given source and makecopies of any objects that are requested.",
	"Method": "ScheduleSource of(List<Schedule> schedules,ScheduleSource of,ScheduleSource backing){\r\n    return new CopyOnRead(backing);\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.addRoot",
	"Comment": "unsupported operation. spanning trees should not be edited.",
	"Method": "Node addRoot(){\r\n    throw new UnsupportedOperationException(\"Changes to tree structure not allowed for spanning trees.\");\r\n}"
}, {
	"Path": "prefuse.activity.ActivityManager._scheduleAfter",
	"Comment": "schedules an activity to start immediately after another activity.the second activity will be scheduled to start immediately after thefirst one finishes, overwriting any previously set starttime. if thefirst activity is cancelled, the second one will not run.this functionality is provided by using an activitylistener to monitorthe first activity. the listener is removed upon completion orcancellation of the first activity.this method does not effect the scheduling of the first activity.",
	"Method": "void _scheduleAfter(Activity before,Activity after){\r\n    before.addActivityListener(new ScheduleAfterActivity(after, true));\r\n}"
}, {
	"Path": "com.restfb.json.JsonValue.valueOf",
	"Comment": "returns a jsonvalue instance that represents the given boolean value.",
	"Method": "JsonValue valueOf(int value,JsonValue valueOf,long value,JsonValue valueOf,float value,JsonValue valueOf,double value,JsonValue valueOf,String string,JsonValue valueOf,boolean value){\r\n    return Json.value(value);\r\n}"
}, {
	"Path": "com.egzosn.pay.paypal.bean.order.RedirectUrls.setReturnUrl",
	"Comment": "url where the payer would be redirected to after approving the payment. required for paypal account payments.",
	"Method": "RedirectUrls setReturnUrl(String returnUrl){\r\n    this.returnUrl = returnUrl;\r\n    return this;\r\n}"
}, {
	"Path": "picard.sam.SamErrorMetric.SimpleErrorCalculator.getSuffix",
	"Comment": "the suffix that pertains to the implementation of aggregation",
	"Method": "String getSuffix(){\r\n    return \"error\";\r\n}"
}, {
	"Path": "net.pms.io.BufferedOutputFileImpl.growBuffer",
	"Comment": "try to increase the size of a memory buffer, while retaining its\tcontents. the provided new size is considered to be a request, it is\tscaled down when an outofmemory error occurs. there is no guarantee\tabout the exact length of the returned byte array, only that it is\tgreater than or equal to the original buffer size. when null is\tpassed as an argument, a fresh buffer will be allocated. copying one\tbyte array to another is a costly operation, both in memory usage and\tperformance. it is best to avoid using this method.",
	"Method": "byte[] growBuffer(byte[] buffer,int newSize){\r\n    byte[] copy;\r\n    if (buffer == null) {\r\n        buffer = new byte[0];\r\n    }\r\n    if (newSize <= buffer.length) {\r\n        return buffer;\r\n    }\r\n    try {\r\n        copy = new byte[newSize];\r\n    } catch (OutOfMemoryError e) {\r\n        if (buffer.length == 0) {\r\n            logger.error(\"Cannot initialize buffer to \" + formatter.format(newSize) + \" bytes.\", e);\r\n        } else {\r\n            logger.warn(\"Cannot grow buffer size from \" + formatter.format(buffer.length) + \" bytes to \" + formatter.format(newSize) + \" bytes.\", e);\r\n        }\r\n        long realisticSize = Runtime.getRuntime().maxMemory() * 3 / 10;\r\n        if (realisticSize < buffer.length) {\r\n            return buffer;\r\n        } else {\r\n            try {\r\n                copy = new byte[(int) realisticSize];\r\n            } catch (OutOfMemoryError e2) {\r\n                logger.error(\"Cannot grow buffer size from \" + formatter.format(buffer.length) + \" bytes to \" + formatter.format(realisticSize) + \" bytes either.\", e2);\r\n                logger.error(\"freeMemory: \" + formatter.format(Runtime.getRuntime().freeMemory()));\r\n                logger.error(\"totalMemory: \" + formatter.format(Runtime.getRuntime().totalMemory()));\r\n                logger.error(\"maxMemory: \" + formatter.format(Runtime.getRuntime().maxMemory()));\r\n                return buffer;\r\n            }\r\n        }\r\n    }\r\n    if (buffer.length == 0) {\r\n        logger.info(\"Successfully initialized buffer to \" + formatter.format(copy.length) + \" bytes.\");\r\n    } else {\r\n        try {\r\n            System.arraycopy(buffer, 0, copy, 0, buffer.length);\r\n            logger.info(\"Successfully grown buffer from \" + formatter.format(buffer.length) + \" bytes to \" + formatter.format(copy.length) + \" bytes.\");\r\n        } catch (Exception ex) {\r\n            logger.error(\"Cannot grow buffer size, error copying buffer contents.\", ex);\r\n        }\r\n    }\r\n    return copy;\r\n}"
}, {
	"Path": "prefuse.data.expression.RangePredicate.getMiddleExpression",
	"Comment": "get the middle expression being tested for inclusion in the range",
	"Method": "Expression getMiddleExpression(){\r\n    return m_middle;\r\n}"
}, {
	"Path": "prefuse.render.ShapeRenderer.getBaseSize",
	"Comment": "returns the base size, in pixels, for shapes drawn by this renderer.",
	"Method": "int getBaseSize(){\r\n    return m_baseSize;\r\n}"
}, {
	"Path": "com.egzosn.pay.paypal.bean.order.CartBase.setReferenceId",
	"Comment": "merchant identifier to the purchase unit. optional parameter",
	"Method": "CartBase setReferenceId(String referenceId){\r\n    this.referenceId = referenceId;\r\n    return this;\r\n}"
}, {
	"Path": "prefuse.Visualization.getSourceTuple",
	"Comment": "get the tuple from a backing source data set that corresponds mostclosely to the given visualitem.",
	"Method": "Tuple getSourceTuple(VisualItem item){\r\n    String group = item.getGroup();\r\n    TupleSet source = getSourceData(group);\r\n    if (source == null)\r\n        return null;\r\n    int row = item.getRow();\r\n    Table t = item.getTable();\r\n    while (t instanceof VisualTable) {\r\n        VisualTable vt = (VisualTable) t;\r\n        row = vt.getParentRow(row);\r\n        t = vt.getParentTable();\r\n    }\r\n    String cgroup = PrefuseLib.getChildGroup(group);\r\n    if (cgroup != null) {\r\n        String pgroup = PrefuseLib.getParentGroup(group);\r\n        Graph g = (Graph) getSourceData(pgroup);\r\n        if (t == g.getNodeTable()) {\r\n            return g.getNode(row);\r\n        } else {\r\n            return g.getEdge(row);\r\n        }\r\n    } else {\r\n        return t.getTuple(row);\r\n    }\r\n}"
}, {
	"Path": "net.pms.network.HTTPResource.downloadAndSendBinary",
	"Comment": "returns a byte array representation of the file given by the url. the file is downloaded and optionally stored on the filesystem.",
	"Method": "byte[] downloadAndSendBinary(String u,byte[] downloadAndSendBinary,String u,boolean saveOnDisk,File f){\r\n    URL url = new URL(u);\r\n    Authenticator.setDefault(new HTTPResourceAuthenticator());\r\n    HTTPResourceAuthenticator.addURL(url);\r\n    logger.debug(\"Retrieving \" + url.toString());\r\n    ByteArrayOutputStream bytes = new ByteArrayOutputStream();\r\n    URLConnection conn = url.openConnection();\r\n    conn.setRequestProperty(\"User-agent\", PropertiesUtil.getProjectProperties().get(\"project.name\") + \" \" + PMS.getVersion());\r\n    InputStream in = conn.getInputStream();\r\n    FileOutputStream fOUT = null;\r\n    if (saveOnDisk && f != null) {\r\n        fOUT = new FileOutputStream(f);\r\n    }\r\n    byte[] buf = new byte[4096];\r\n    int n = -1;\r\n    while ((n = in.read(buf)) > -1) {\r\n        bytes.write(buf, 0, n);\r\n        if (fOUT != null) {\r\n            fOUT.write(buf, 0, n);\r\n        }\r\n    }\r\n    in.close();\r\n    if (fOUT != null) {\r\n        fOUT.close();\r\n    }\r\n    return bytes.toByteArray();\r\n}"
}, {
	"Path": "quickfix.SLF4JLogTest.testLog4j_correctFQCN",
	"Comment": "check to make sure that if we use log4j underneath with slf4j we usethe right wrapper function so that the appropriate calling location shows upinstead of our wrapper slf4jlog class itself",
	"Method": "void testLog4j_correctFQCN(){\r\n    final MyLog4JLog myLog4j = new MyLog4JLog();\r\n    final SLF4JLog slf4jLog = new MySLF4JLog(new SessionID(\"FIX.4.2\", \"sender\", \"target\"), \"my-caller-fqcn\", myLog4j);\r\n    final String loggedText = \"TEST123\";\r\n    slf4jLog.onEvent(loggedText);\r\n    assertEquals(1, myLog4j.messages.size());\r\n    assertEquals(\"my-caller-fqcn\", myLog4j.fqcns.get(0));\r\n    assertEquals(\"TEST123\", myLog4j.messages.get(0));\r\n    slf4jLog.close();\r\n}"
}, {
	"Path": "org.quickfixj.jmx.mbean.session.SessionAdmin.doSend",
	"Comment": "helper method to be overridden by tests that handles sending out the message.",
	"Method": "void doSend(Message message,SessionID sessionID){\r\n    Session.sendToTarget(message, sessionID);\r\n}"
}, {
	"Path": "com.restfb.json.JsonValue.asBoolean",
	"Comment": "returns this json value as a boolean value, assuming that this value is either true orfalse. if this is not the case, an exception is thrown.",
	"Method": "boolean asBoolean(){\r\n    throw new UnsupportedOperationException(\"Not a boolean: \" + toString());\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getUseCache",
	"Comment": "returns true if pms should cache scanned media in its internal database,\tspeeding up later retrieval. when false is returned, pms will not use\tcache and media will have to be rescanned.",
	"Method": "boolean getUseCache(){\r\n    return getBoolean(KEY_USE_CACHE, false);\r\n}"
}, {
	"Path": "prefuse.util.ui.JPrefuseApplet.stop",
	"Comment": "automatically shuts down the activitymanager when the applet isstopped.",
	"Method": "void stop(){\r\n    ActivityManager.stopThread();\r\n}"
}, {
	"Path": "prefuse.util.display.Clip.invalidate",
	"Comment": "invalidate the clip. in this state, the clip contents have no meaning.",
	"Method": "void invalidate(){\r\n    status = INVALID;\r\n}"
}, {
	"Path": "prefuse.util.ui.JToggleGroup.getMargin",
	"Comment": "get the margin, in pixels, used at the ends of the jtogglegroup.",
	"Method": "int getMargin(){\r\n    return m_margin;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getBoolean",
	"Comment": "return the boolean value for a given configuration key. first, the\tkey is looked up in the current configuration settings. if it exists and contains\ta valid value, that value is returned. if the key contains an invalid value or\tcannot be found, the specified default value is returned.",
	"Method": "boolean getBoolean(String key,boolean def){\r\n    return configurationReader.getBoolean(key, def);\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.isMencoderFontConfig",
	"Comment": "returns whether or not mencoder should use fontconfig for displaying\tsubtitles. default is false.",
	"Method": "boolean isMencoderFontConfig(){\r\n    return getBoolean(KEY_MENCODER_FONT_CONFIG, true);\r\n}"
}, {
	"Path": "picard.analysis.artifacts.ContextAccumulator.fillZeroRecords",
	"Comment": "fills a zerocontextaccumulator by summing over the appropriate counts from a fullcontextaccumulator.",
	"Method": "void fillZeroRecords(ContextAccumulator fullContextAccumulator,int contextSize){\r\n    final String padding = StringUtil.repeatCharNTimes('N', contextSize);\r\n    for (Map.Entry<String, AlignmentAccumulator[]> fullContext : fullContextAccumulator.artifactMap.entrySet()) {\r\n        final String fullContextKey = fullContext.getKey();\r\n        final char centralBase = fullContextKey.charAt(contextSize);\r\n        final String zeroContextKey = padding + centralBase + padding;\r\n        final AlignmentAccumulator[] zeroAlignmentAccumulators = this.artifactMap.get(zeroContextKey);\r\n        final AlignmentAccumulator[] fullAlignmentAccumulators = fullContext.getValue();\r\n        for (int i = 0; i < fullAlignmentAccumulators.length; i++) {\r\n            zeroAlignmentAccumulators[i].merge(fullAlignmentAccumulators[i]);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.util.TableIterator.canGet",
	"Comment": "check if the get method for the given data field returnsvalues that are compatible with a given target type.",
	"Method": "boolean canGet(String field,Class type){\r\n    return m_table.canGet(field, type);\r\n}"
}, {
	"Path": "peergos.shared.cbor.CborDecoder.readMajorTypeExact",
	"Comment": "reads the next major type from the underlying input stream, and verifies whether it matches the given expectations.",
	"Method": "void readMajorTypeExact(int majorType,int subtype){\r\n    int st = readMajorType(majorType);\r\n    if ((st ^ subtype) != 0) {\r\n        fail(\"Unexpected subtype: %d, expected: %d!\", st, subtype);\r\n    }\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeProbabilitiesFromContaminatorSequence.addToProbs",
	"Comment": "adds a base observation with the observed quality to the evidence for this haplotypebased on the fact that the snp is part of the haplotype.",
	"Method": "void addToProbs(Snp snp,byte base,byte qual){\r\n    assertSnpPartOfHaplotype(snp);\r\n    final boolean altAllele;\r\n    if (base == snp.getAllele1()) {\r\n        this.obsAllele1++;\r\n        altAllele = false;\r\n    } else if (base == snp.getAllele2()) {\r\n        this.obsAllele2++;\r\n        altAllele = true;\r\n    } else {\r\n        this.obsAlleleOther++;\r\n        return;\r\n    }\r\n    final double pErr = QualityUtil.getErrorProbabilityFromPhredScore(qual);\r\n    for (final Genotype contGeno : Genotype.values()) {\r\n        for (final Genotype mainGeno : Genotype.values()) {\r\n            final double theta = 0.5 * ((1 - contamination) * mainGeno.v + contamination * contGeno.v);\r\n            likelihoodMap[contGeno.v][mainGeno.v] *= ((altAllele ? theta : (1 - theta)) * (1 - pErr) + (!altAllele ? theta : (1 - theta)) * pErr);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setMencoderCodecSpecificConfig",
	"Comment": "sets additional codec specific configuration options for mencoder.",
	"Method": "void setMencoderCodecSpecificConfig(String value){\r\n    configuration.setProperty(KEY_MENCODER_CODEC_SPECIFIC_SCRIPT, value);\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setAudioChannelCount",
	"Comment": "sets the number of audio channels that mencoder should use for\ttranscoding.",
	"Method": "void setAudioChannelCount(int value){\r\n    configuration.setProperty(KEY_AUDIO_CHANNEL_COUNT, value);\r\n}"
}, {
	"Path": "com.google.gwt.sample.mobilewebapp.server.domain.Task.populateDatastore",
	"Comment": "populate the datastore with some default tasks. we do this to make the appmore intuitive on first use.",
	"Method": "void populateDatastore(){\r\n    {\r\n        Task task0 = new Task();\r\n        task0.setName(\"Beat Angry Birds\");\r\n        task0.setNotes(\"This game is impossible!\");\r\n        task0.setDueDate(new Date(100, 4, 20));\r\n        task0.userId = currentUserId();\r\n        ofy().save().entity(task0);\r\n    }\r\n    {\r\n        Task task1 = new Task();\r\n        task1.setName(\"Make a million dollars\");\r\n        task1.setNotes(\"Then spend it all on Android apps\");\r\n        task1.userId = currentUserId();\r\n        ofy().save().entity(task1);\r\n    }\r\n    {\r\n        Task task2 = new Task();\r\n        task2.setName(\"Buy a dozen eggs\");\r\n        task2.setNotes(\"of the chicken variety\");\r\n        task2.userId = currentUserId();\r\n        ofy().save().entity(task2);\r\n    }\r\n    {\r\n        Task task3 = new Task();\r\n        task3.setName(\"Complete all tasks\");\r\n        task3.userId = currentUserId();\r\n        ofy().save().entity(task3);\r\n    }\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    checkboxColumn = new Column<ContactInfo, Boolean>(new CheckboxCell(true, false)) {\r\n        @Override\r\n        public Boolean getValue(ContactInfo object) {\r\n            return dataGrid.getSelectionModel().isSelected(object);\r\n        }\r\n    };\r\n    dataGrid.addColumn(checkboxColumn);\r\n    dataGrid.setColumnWidth(0, 40, Unit.PX);\r\n    SafeHtmlRenderer<String> anchorRenderer = new AbstractSafeHtmlRenderer<String>() {\r\n        @Override\r\n        public SafeHtml render(String object) {\r\n            SafeHtmlBuilder sb = new SafeHtmlBuilder();\r\n            sb.appendHtmlConstant(\"(<a href=\\\"javascript:;\\\">\").appendEscaped(object).appendHtmlConstant(\"<\/a>)\");\r\n            return sb.toSafeHtml();\r\n        }\r\n    };\r\n    viewFriendsColumn = new Column<ContactInfo, String>(new ClickableTextCell(anchorRenderer)) {\r\n        @Override\r\n        public String getValue(ContactInfo object) {\r\n            if (showingFriends.contains(object.getId())) {\r\n                return \"hide friends\";\r\n            } else {\r\n                return \"show friends\";\r\n            }\r\n        }\r\n    };\r\n    viewFriendsColumn.setFieldUpdater(new FieldUpdater<ContactInfo, String>() {\r\n        @Override\r\n        public void update(int index, ContactInfo object, String value) {\r\n            if (showingFriends.contains(object.getId())) {\r\n                showingFriends.remove(object.getId());\r\n            } else {\r\n                showingFriends.add(object.getId());\r\n            }\r\n            dataGrid.redrawRow(index);\r\n        }\r\n    });\r\n    dataGrid.addColumn(viewFriendsColumn);\r\n    dataGrid.setColumnWidth(1, 10, Unit.EM);\r\n    firstNameColumn = new Column<ContactInfo, String>(new EditTextCell()) {\r\n        @Override\r\n        public String getValue(ContactInfo object) {\r\n            return object.getFirstName();\r\n        }\r\n    };\r\n    firstNameColumn.setSortable(true);\r\n    sortHandler.setComparator(firstNameColumn, new Comparator<ContactInfo>() {\r\n        @Override\r\n        public int compare(ContactInfo o1, ContactInfo o2) {\r\n            return o1.getFirstName().compareTo(o2.getFirstName());\r\n        }\r\n    });\r\n    firstNameColumn.setFieldUpdater(new FieldUpdater<ContactInfo, String>() {\r\n        @Override\r\n        public void update(int index, ContactInfo object, String value) {\r\n            object.setFirstName(value);\r\n            ContactDatabase.get().refreshDisplays();\r\n        }\r\n    });\r\n    dataGrid.addColumn(firstNameColumn);\r\n    dataGrid.setColumnWidth(2, 20, Unit.PCT);\r\n    lastNameColumn = new Column<ContactInfo, String>(new EditTextCell()) {\r\n        @Override\r\n        public String getValue(ContactInfo object) {\r\n            return object.getLastName();\r\n        }\r\n    };\r\n    lastNameColumn.setSortable(true);\r\n    sortHandler.setComparator(lastNameColumn, new Comparator<ContactInfo>() {\r\n        @Override\r\n        public int compare(ContactInfo o1, ContactInfo o2) {\r\n            return o1.getLastName().compareTo(o2.getLastName());\r\n        }\r\n    });\r\n    lastNameColumn.setFieldUpdater(new FieldUpdater<ContactInfo, String>() {\r\n        @Override\r\n        public void update(int index, ContactInfo object, String value) {\r\n            object.setLastName(value);\r\n            ContactDatabase.get().refreshDisplays();\r\n        }\r\n    });\r\n    dataGrid.addColumn(lastNameColumn);\r\n    dataGrid.setColumnWidth(3, 20, Unit.PCT);\r\n    ageColumn = new Column<ContactInfo, Number>(new NumberCell()) {\r\n        @Override\r\n        public Number getValue(ContactInfo object) {\r\n            return object.getAge();\r\n        }\r\n    };\r\n    ageColumn.setSortable(true);\r\n    sortHandler.setComparator(ageColumn, new Comparator<ContactInfo>() {\r\n        @Override\r\n        public int compare(ContactInfo o1, ContactInfo o2) {\r\n            return o1.getAge() - o2.getAge();\r\n        }\r\n    });\r\n    dataGrid.addColumn(ageColumn);\r\n    dataGrid.setColumnWidth(4, 7, Unit.EM);\r\n    final Category[] categories = ContactDatabase.get().queryCategories();\r\n    List<String> categoryNames = new ArrayList<String>();\r\n    for (Category category : categories) {\r\n        categoryNames.add(category.getDisplayName());\r\n    }\r\n    SelectionCell categoryCell = new SelectionCell(categoryNames);\r\n    categoryColumn = new Column<ContactInfo, String>(categoryCell) {\r\n        @Override\r\n        public String getValue(ContactInfo object) {\r\n            return object.getCategory().getDisplayName();\r\n        }\r\n    };\r\n    categoryColumn.setFieldUpdater(new FieldUpdater<ContactInfo, String>() {\r\n        @Override\r\n        public void update(int index, ContactInfo object, String value) {\r\n            for (Category category : categories) {\r\n                if (category.getDisplayName().equals(value)) {\r\n                    object.setCategory(category);\r\n                }\r\n            }\r\n            ContactDatabase.get().refreshDisplays();\r\n        }\r\n    });\r\n    dataGrid.addColumn(categoryColumn);\r\n    dataGrid.setColumnWidth(5, 130, Unit.PX);\r\n    addressColumn = new Column<ContactInfo, String>(new TextCell()) {\r\n        @Override\r\n        public String getValue(ContactInfo object) {\r\n            return object.getAddress();\r\n        }\r\n    };\r\n    addressColumn.setSortable(true);\r\n    sortHandler.setComparator(addressColumn, new Comparator<ContactInfo>() {\r\n        @Override\r\n        public int compare(ContactInfo o1, ContactInfo o2) {\r\n            return o1.getAddress().compareTo(o2.getAddress());\r\n        }\r\n    });\r\n    dataGrid.addColumn(addressColumn);\r\n    dataGrid.setColumnWidth(6, 60, Unit.PCT);\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    return dataGrid.getSelectionModel().isSelected(object);\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    SafeHtmlBuilder sb = new SafeHtmlBuilder();\r\n    sb.appendHtmlConstant(\"(<a href=\\\"javascript:;\\\">\").appendEscaped(object).appendHtmlConstant(\"<\/a>)\");\r\n    return sb.toSafeHtml();\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    if (showingFriends.contains(object.getId())) {\r\n        return \"hide friends\";\r\n    } else {\r\n        return \"show friends\";\r\n    }\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    if (showingFriends.contains(object.getId())) {\r\n        showingFriends.remove(object.getId());\r\n    } else {\r\n        showingFriends.add(object.getId());\r\n    }\r\n    dataGrid.redrawRow(index);\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    return object.getFirstName();\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    return o1.getFirstName().compareTo(o2.getFirstName());\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    object.setFirstName(value);\r\n    ContactDatabase.get().refreshDisplays();\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    return object.getLastName();\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    return o1.getLastName().compareTo(o2.getLastName());\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    object.setLastName(value);\r\n    ContactDatabase.get().refreshDisplays();\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    return object.getAge();\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    return o1.getAge() - o2.getAge();\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    return object.getCategory().getDisplayName();\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    for (Category category : categories) {\r\n        if (category.getDisplayName().equals(value)) {\r\n            object.setCategory(category);\r\n        }\r\n    }\r\n    ContactDatabase.get().refreshDisplays();\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    return object.getAddress();\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.CwCustomDataGrid.initializeColumns",
	"Comment": "defines the columns in the custom table. maps the data in the contactinfofor each row into the appropriate column in the table, and defines handlersfor each column.",
	"Method": "void initializeColumns(ListHandler<ContactInfo> sortHandler){\r\n    return o1.getAddress().compareTo(o2.getAddress());\r\n}"
}, {
	"Path": "picard.vcf.GenotypeConcordance.normalizeAlleles",
	"Comment": "gets the alleles for the truth and call genotypes.in particular, this handles the case where indels can have differentreference alleles.",
	"Method": "Alleles normalizeAlleles(VariantContext truthContext,String truthSample,VariantContext callContext,String callSample,Boolean ignoreFilteredStatus){\r\n    final Genotype truthGenotype, callGenotype;\r\n    if (truthContext == null || truthContext.isMixed() || truthContext.isFiltered())\r\n        truthGenotype = null;\r\n    else\r\n        truthGenotype = truthContext.getGenotype(truthSample);\r\n    if (callContext == null || callContext.isMixed() || (!ignoreFilteredStatus && callContext.isFiltered()))\r\n        callGenotype = null;\r\n    else\r\n        callGenotype = callContext.getGenotype(callSample);\r\n    String truthRef = (truthGenotype != null) ? truthContext.getReference().getBaseString() : null;\r\n    String callRef = (callGenotype != null) ? callContext.getReference().getBaseString() : null;\r\n    String truthAllele1 = null;\r\n    String truthAllele2 = null;\r\n    if (null != truthGenotype) {\r\n        if (truthGenotype.getAlleles().size() != 2) {\r\n            throw new IllegalStateException(\"Genotype for Variant Context: \" + truthContext + \" does not have exactly 2 alleles\");\r\n        }\r\n        truthAllele1 = truthGenotype.getAllele(0).getBaseString();\r\n        truthAllele2 = truthGenotype.getAllele(1).getBaseString();\r\n    }\r\n    String callAllele1 = null;\r\n    String callAllele2 = null;\r\n    if (null != callGenotype) {\r\n        if (callGenotype.getAlleles().size() != 2) {\r\n            throw new IllegalStateException(\"Genotype for Variant Context: \" + callContext + \" does not have exactly 2 alleles\");\r\n        }\r\n        callAllele1 = callGenotype.getAllele(0).getBaseString();\r\n        callAllele2 = callGenotype.getAllele(1).getBaseString();\r\n    }\r\n    if ((truthRef != null && callRef != null) && (!truthRef.equals(callRef))) {\r\n        if (truthRef.length() < callRef.length()) {\r\n            final String suffix = getStringSuffix(callRef, truthRef, \"Ref alleles mismatch between: \" + truthContext + \" and \" + callContext);\r\n            final int insertIdx = truthRef.length();\r\n            truthAllele1 = truthAllele1.equals(Allele.NO_CALL_STRING) ? truthAllele1 : spliceOrAppendString(truthAllele1, suffix, insertIdx);\r\n            truthAllele2 = truthAllele2.equals(Allele.NO_CALL_STRING) ? truthAllele2 : spliceOrAppendString(truthAllele2, suffix, insertIdx);\r\n            truthRef = truthRef + suffix;\r\n        } else if (truthRef.length() > callRef.length()) {\r\n            final String suffix = getStringSuffix(truthRef, callRef, \"Ref alleles mismatch between: \" + truthContext + \" and \" + callContext);\r\n            final int insertIdx = callRef.length();\r\n            callAllele1 = callAllele1.equals(Allele.NO_CALL_STRING) ? callAllele1 : spliceOrAppendString(callAllele1, suffix, insertIdx);\r\n            callAllele2 = callAllele2.equals(Allele.NO_CALL_STRING) ? callAllele2 : spliceOrAppendString(callAllele2, suffix, insertIdx);\r\n            callRef = callRef + suffix;\r\n        } else {\r\n            throw new IllegalStateException(\"Ref alleles mismatch between: \" + truthContext + \" and \" + callContext);\r\n        }\r\n    }\r\n    final OrderedSet<String> allAlleles = new OrderedSet<String>();\r\n    if (truthGenotype != null || callGenotype != null) {\r\n        allAlleles.smartAdd(truthGenotype == null ? callRef : truthRef);\r\n    }\r\n    if (null != truthGenotype) {\r\n        allAlleles.smartAdd(truthAllele1);\r\n        allAlleles.smartAdd(truthAllele2);\r\n    }\r\n    if (null != callGenotype) {\r\n        if (allAlleles.indexOf(callAllele1) > 1 || allAlleles.indexOf(callAllele2) > 1) {\r\n            allAlleles.remove(2);\r\n            allAlleles.remove(1);\r\n            allAlleles.smartAdd(truthAllele2);\r\n            allAlleles.smartAdd(truthAllele1);\r\n        }\r\n        allAlleles.smartAdd(callAllele1);\r\n        allAlleles.smartAdd(callAllele2);\r\n    }\r\n    return new Alleles(allAlleles, truthAllele1, truthAllele2, callAllele1, callAllele2);\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.addRootRow",
	"Comment": "unsupported operation. spanning trees should not be edited.",
	"Method": "int addRootRow(){\r\n    throw new UnsupportedOperationException(\"Changes to tree structure not allowed for spanning trees.\");\r\n}"
}, {
	"Path": "net.pms.configuration.RendererConfigurationTest.testBogusDefault",
	"Comment": "test recognition with a forced bogus default renderer configured.",
	"Method": "void testBogusDefault(){\r\n    PmsConfiguration pmsConf = null;\r\n    try {\r\n        pmsConf = new PmsConfiguration(false);\r\n    } catch (ConfigurationException e) {\r\n    }\r\n    pmsConf.setRendererDefault(\"Bogus Renderer\");\r\n    pmsConf.setRendererForceDefault(true);\r\n    loadRendererConfigurations(pmsConf);\r\n    testHeader(\"User-Agent: AirPlayer/1.0.09 CFNetwork/485.13.9 Darwin/11.0.0\", \"Unknown renderer\");\r\n    testHeader(\"User-Agent: Unknown Renderer\", \"Unknown renderer\");\r\n    testHeader(\"X-Unknown-Header: Unknown Content\", \"Unknown renderer\");\r\n}"
}, {
	"Path": "prefuse.data.expression.BinaryExpression.getOperation",
	"Comment": "get the operation code for this expression. the meaning of thiscode is left for subclasses to determine.",
	"Method": "int getOperation(){\r\n    return m_op;\r\n}"
}, {
	"Path": "prefuse.data.util.RowManager.clear",
	"Comment": "clear the row manager status, marking all rows as available.",
	"Method": "void clear(){\r\n    m_openrows = null;\r\n    m_firstid = 0;\r\n    m_curid = -1;\r\n}"
}, {
	"Path": "prefuse.render.LabelRenderer.getImageField",
	"Comment": "get the data field for image locations. the value storedin the data field should be a url, a file within the current classpath,a file on the filesystem, or null for no image.",
	"Method": "String getImageField(){\r\n    return m_imageName;\r\n}"
}, {
	"Path": "quickfix.ApplicationExtendedFunctionalAdapter.removeCanLogOnPredicate",
	"Comment": "remove a predicate of session from the canlogon evaluation.",
	"Method": "void removeCanLogOnPredicate(Predicate<SessionID> canlogon){\r\n    canLogonPredicates.remove(canlogon);\r\n}"
}, {
	"Path": "prefuse.Display.addControlListener",
	"Comment": "adds a controllistener to receive all input events on visualitems.",
	"Method": "void addControlListener(Control cl){\r\n    m_controls.add(cl);\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setMencoderForceFps",
	"Comment": "set to true if mencoder should be forced to use the framerate that is\tparsed by ffmpeg.",
	"Method": "void setMencoderForceFps(boolean value){\r\n    configuration.setProperty(KEY_MENCODER_FORCE_FPS, value);\r\n}"
}, {
	"Path": "prefuse.Visualization.isInGroup",
	"Comment": "indicates if a given visualitem is contained in the given visualdata group.",
	"Method": "boolean isInGroup(VisualItem item,String group){\r\n    if (ALL_ITEMS.equals(group))\r\n        return true;\r\n    if (item.getGroup() == group)\r\n        return true;\r\n    TupleSet tset = getGroup(group);\r\n    return (tset == null ? false : tset.containsTuple(item));\r\n}"
}, {
	"Path": "cn.hugeterry.ployfun.core.delaunay.Triangulation.delaunayPlace",
	"Comment": "place a new site into the dt.nothing happens if the site matches an existing dt vertex.",
	"Method": "void delaunayPlace(Pnt site){\r\n    Triangle triangle = locate(site);\r\n    if (triangle == null)\r\n        throw new IllegalArgumentException(\"No containing triangle\");\r\n    if (triangle.contains(site))\r\n        return;\r\n    Set<Triangle> cavity = getCavity(site, triangle);\r\n    mostRecent = update(site, cavity);\r\n}"
}, {
	"Path": "prefuse.data.search.LuceneSearcher.setAnalyzer",
	"Comment": "sets the analyzer used to process text. see lucene documentationfor more details.",
	"Method": "void setAnalyzer(Analyzer analyzer){\r\n    this.analyzer = analyzer;\r\n}"
}, {
	"Path": "quickfix.FieldMap.getFieldOrder",
	"Comment": "returns the order of fields in the group.the returned array must not be modified.",
	"Method": "int[] getFieldOrder(){\r\n    return fieldOrder;\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.ForceDirectedLayout.setDataGroups",
	"Comment": "explicitly sets the node and edge groups to use for this layout,overriding the group setting passed to the constructor.",
	"Method": "void setDataGroups(String nodeGroup,String edgeGroup){\r\n    m_nodeGroup = nodeGroup;\r\n    m_edgeGroup = edgeGroup;\r\n}"
}, {
	"Path": "prefuse.visual.expression.GroupExpression.addParameter",
	"Comment": "attempts to add the given expression as the group expression.",
	"Method": "void addParameter(Expression e){\r\n    if (m_group == null)\r\n        m_group = e;\r\n    else\r\n        throw new IllegalStateException(\"This function takes only 1 parameter.\");\r\n}"
}, {
	"Path": "prefuse.util.ui.JRangeSlider.setHighValue",
	"Comment": "sets the high value shown by this range slider. this causes the range slider to berepainted and a changeevent to be fired.",
	"Method": "void setHighValue(int highValue){\r\n    model.setExtent(highValue - model.getValue());\r\n}"
}, {
	"Path": "net.pms.network.NetworkConfiguration.getFirstInterfaceWithAddress",
	"Comment": "returns the first interface from the list of discovered interfaces that\thas an address. if no such interface can be found or if no interfaces\twere discovered, null is returned.",
	"Method": "InterfaceAssociation getFirstInterfaceWithAddress(){\r\n    for (InterfaceAssociation ia : interfaces) {\r\n        if (ia.getAddr() != null) {\r\n            return ia;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.pms.configuration.ConfigurationReader.getLong",
	"Comment": "return the long value for a given configuration key. first, the key\tis looked up in the current configuration settings. if it exists and contains a\tvalid value, that value is returned. if the key contains an invalid value or\tcannot be found, the specified default value is returned.",
	"Method": "long getLong(String key,int def){\r\n    long value;\r\n    try {\r\n        value = configuration.getLong(key, def);\r\n    } catch (ConversionException e) {\r\n        value = def;\r\n    }\r\n    log(key, value, def);\r\n    return value;\r\n}"
}, {
	"Path": "py4j.Gateway.createProxy",
	"Comment": "creates a proxy implementing the provided interfaces with the provided class loader.\tthis method is part of the gateway instance to allow overriding or customizing per gateway instance.",
	"Method": "Object createProxy(ClassLoader classLoader,Class[] interfacesToImplement,String objectId){\r\n    return Proxy.newProxyInstance(classLoader, interfacesToImplement, createPythonProxyHandler(objectId));\r\n}"
}, {
	"Path": "prefuse.util.PrefuseLib.getEndField",
	"Comment": "for a given interpolated field name, get the name of the endfield.",
	"Method": "String getEndField(String field){\r\n    return field + \":end\";\r\n}"
}, {
	"Path": "prefuse.data.CascadedTable.setColumnProjection",
	"Comment": "sets the columnprojection determining which columns of theparent table are included in this one.",
	"Method": "void setColumnProjection(ColumnProjection colFilter){\r\n    if (m_colFilter != null) {\r\n        m_colFilter.removeProjectionListener(m_listener);\r\n    }\r\n    m_colFilter = colFilter == null ? new AcceptAllColumnProjection() : colFilter;\r\n    m_colFilter.addProjectionListener(m_listener);\r\n    filterColumns();\r\n}"
}, {
	"Path": "prefuse.data.search.LuceneSearcher.getFields",
	"Comment": "returns the indexed document fields. these fields determine whichfields are indexed as documents are added and which fields arequeried over when searches are issued.",
	"Method": "String[] getFields(){\r\n    return (String[]) fields.clone();\r\n}"
}, {
	"Path": "prefuse.data.Table.canGetBoolean",
	"Comment": "check if the given data field can return primitive booleanvalues.",
	"Method": "boolean canGetBoolean(String field){\r\n    Column col = getColumn(field);\r\n    return (col == null ? false : col.canGetBoolean());\r\n}"
}, {
	"Path": "quickfix.mina.SingleThreadedEventHandlingStrategy.blockInThread",
	"Comment": "start handling of messages by message processor thread.if thread is still alive, an attempt is made to stop it.an illegalstateexception is thrown if stopping the old threadwas not successful.this method must not be called by several threads concurrently.",
	"Method": "void blockInThread(){\r\n    if (messageProcessingThread != null && messageProcessingThread.isAlive()) {\r\n        sessionConnector.log.warn(\"Trying to stop still running {}\", MESSAGE_PROCESSOR_THREAD_NAME);\r\n        stopHandlingMessages(true);\r\n        if (messageProcessingThread.isAlive()) {\r\n            throw new IllegalStateException(\"Still running \" + MESSAGE_PROCESSOR_THREAD_NAME + \" could not be stopped!\");\r\n        }\r\n    }\r\n    startHandlingMessages();\r\n    messageProcessingThread = new ThreadAdapter(() -> {\r\n        sessionConnector.log.info(\"Started {}\", MESSAGE_PROCESSOR_THREAD_NAME);\r\n        block();\r\n        sessionConnector.log.info(\"Stopped {}\", MESSAGE_PROCESSOR_THREAD_NAME);\r\n    }, MESSAGE_PROCESSOR_THREAD_NAME, executor);\r\n    messageProcessingThread.setDaemon(true);\r\n    messageProcessingThread.start();\r\n}"
}, {
	"Path": "prefuse.util.ui.JRangeSlider.setThumbColor",
	"Comment": "set the slider thumb color. this is the part of the slider betweenthe range resize buttons.",
	"Method": "void setThumbColor(Color thumbColor){\r\n    this.thumbColor = thumbColor;\r\n}"
}, {
	"Path": "picard.vcf.GenotypeConcordanceCounts.isVar",
	"Comment": "returns true if either the truth or call state is a var.used for calculating non ref genotype concordance.",
	"Method": "boolean isVar(TruthState truthState,CallState callState){\r\n    final List<TruthState> listOfTruthStates = Arrays.asList(TruthState.HOM_VAR1, TruthState.HET_REF_VAR1, TruthState.HET_VAR1_VAR2);\r\n    final List<CallState> listOfCallStates = Arrays.asList(CallState.HET_REF_VAR1, CallState.HET_REF_VAR2, CallState.HET_REF_VAR3, CallState.HET_VAR1_VAR2, CallState.HET_VAR1_VAR3, CallState.HET_VAR3_VAR4, CallState.HOM_VAR1, CallState.HOM_VAR2, CallState.HOM_VAR3);\r\n    return listOfTruthStates.contains(truthState) || listOfCallStates.contains(callState);\r\n}"
}, {
	"Path": "net.pms.util.Version.getBuild",
	"Comment": "returns the fourth integer element of this version string,\tor 0 if a fourth integer was not defined or could not be parsed",
	"Method": "int getBuild(){\r\n    if (elements.length > 3) {\r\n        return elements[3];\r\n    } else {\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "picard.sam.AbstractAlignmentMerger.clipForOverlappingReads",
	"Comment": "checks to see whether the ends of the reads overlap and soft clips readsthem if necessary.",
	"Method": "void clipForOverlappingReads(SAMRecord read1,SAMRecord read2){\r\n    if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\r\n        if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\r\n            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\r\n            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\r\n            if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\r\n                final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\r\n                final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\r\n                if (posDiff > 0) {\r\n                    final List<CigarElement> elems = new ArrayList(pos.getCigar().getCigarElements());\r\n                    Collections.reverse(elems);\r\n                    final int clipped = lengthOfSoftClipping(elems.iterator());\r\n                    final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\r\n                    CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\r\n                    removeNmMdAndUqTags(pos);\r\n                }\r\n                if (negDiff > 0) {\r\n                    final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\r\n                    final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\r\n                    CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\r\n                    removeNmMdAndUqTags(neg);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.setFont",
	"Comment": "set the current font for the the row. the font is used as the defaulttypeface for drawing text for this item.",
	"Method": "void setFont(int row,Font font){\r\n    set(row, VisualItem.FONT, font);\r\n}"
}, {
	"Path": "prefuse.data.util.RowManager.addRow",
	"Comment": "add a new row to management. the lowest valued available rowwill be used.",
	"Method": "int addRow(){\r\n    int r;\r\n    if (m_openrows == null || m_openrows.isEmpty()) {\r\n        r = (m_firstid == 0 ? ++m_curid : --m_firstid);\r\n    } else {\r\n        int key = m_openrows.firstKey();\r\n        r = m_openrows.remove(key);\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "picard.sam.markduplicates.util.OpticalDuplicateFinder.closeEnough",
	"Comment": "simple method to test whether two physical locations are close enough to each other to be deemed optical dupes.",
	"Method": "boolean closeEnough(PhysicalLocation lhs,PhysicalLocation rhs,int distance){\r\n    return lhs != rhs && lhs.hasLocation() && rhs.hasLocation() && lhs.getReadGroup() == rhs.getReadGroup() && lhs.getTile() == rhs.getTile() && Math.abs(lhs.getX() - rhs.getX()) <= distance && Math.abs(lhs.getY() - rhs.getY()) <= distance;\r\n}"
}, {
	"Path": "prefuse.render.LabelRenderer.setHorizontalAlignment",
	"Comment": "set the horizontal alignment of this node with respect to itsx, y coordinates.",
	"Method": "void setHorizontalAlignment(int align){\r\n    m_xAlign = align;\r\n}"
}, {
	"Path": "com.restfb.BinaryAttachment.getContentType",
	"Comment": "return the given content type or try to guess from stream or file name. depending of the available data.",
	"Method": "String getContentType(){\r\n    if (contentType != null) {\r\n        return contentType;\r\n    }\r\n    if (dataStream != null) {\r\n        try {\r\n            contentType = URLConnection.guessContentTypeFromStream(dataStream);\r\n        } catch (IOException ioe) {\r\n        }\r\n    }\r\n    if (data != null) {\r\n        contentType = URLConnection.guessContentTypeFromName(filename);\r\n    }\r\n    if (contentType == null) {\r\n        contentType = \"application/octet-stream\";\r\n    }\r\n    return contentType;\r\n}"
}, {
	"Path": "prefuse.visual.AggregateTable.getAggregates",
	"Comment": "get an iterator over all aggregateitems that contain the given tuple.",
	"Method": "Iterator getAggregates(Tuple t){\r\n    int hash = getHashCode(t);\r\n    IntIterator iit = m_aggregated.getIndex(MEMBER_HASH).rows(hash);\r\n    HashSet set = new HashSet();\r\n    while (iit.hasNext()) {\r\n        int r = iit.nextInt();\r\n        set.add(getTuple(m_aggregated.getInt(r, AGGREGATE)));\r\n    }\r\n    return set.iterator();\r\n}"
}, {
	"Path": "net.pms.dlna.virtual.VirtualFolder.getInputStream",
	"Comment": "because a container cannot be streamed, this function always returns null.",
	"Method": "InputStream getInputStream(){\r\n    return null;\r\n}"
}, {
	"Path": "com.google.gwt.sample.dynatablerf.domain.Person.getVersion",
	"Comment": "the requestfactory requires an integer version property for each proxiedtype, but makes no good use of it. this requirement will be removed soon.",
	"Method": "Integer getVersion(){\r\n    return version;\r\n}"
}, {
	"Path": "prefuse.util.ui.JRangeSlider.createListener",
	"Comment": "create a listener to relay change events from the bounded range model.",
	"Method": "ChangeListener createListener(){\r\n    return new RangeSliderChangeListener();\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.ShowMorePagerPanel.getIncrementSize",
	"Comment": "get the number of rows by which the range is increased when the scrollbarreaches the bottom.",
	"Method": "int getIncrementSize(){\r\n    return incrementSize;\r\n}"
}, {
	"Path": "quickfix.Session.getExpectedTargetNum",
	"Comment": "retrieves the expected target sequence number. this method is notsynchronized.",
	"Method": "int getExpectedTargetNum(){\r\n    try {\r\n        return state.getMessageStore().getNextTargetMsgSeqNum();\r\n    } catch (final IOException e) {\r\n        getLog().onErrorEvent(\"getNextTargetMsgSeqNum failed: \" + e.getMessage());\r\n        return -1;\r\n    }\r\n}"
}, {
	"Path": "com.restfb.types.User.getDevices",
	"Comment": "the list of devices the person is using.this will return only ios and android devices",
	"Method": "List<UserDevice> getDevices(){\r\n    return unmodifiableList(devices);\r\n}"
}, {
	"Path": "prefuse.data.query.RangeQueryBinding.createVerticalRangeSlider",
	"Comment": "create a new vertical range slider for interacting with the query.",
	"Method": "JRangeSlider createVerticalRangeSlider(){\r\n    return createRangeSlider(JRangeSlider.VERTICAL, JRangeSlider.RIGHTLEFT_BOTTOMTOP);\r\n}"
}, {
	"Path": "py4j.GatewayServer.main",
	"Comment": "main method to start a local gatewayserver on a given port.\tthe listening port is printed to stdout so that clients can start\tservers on ephemeral ports.\tif authentication is enabled, the server will create an auth secret with 256 bits of entropy\tand print it to stdout after the server port. clients should then provide this secret when\tconnecting to the server. note that no second line of output is printed if authentication is\tnot enabled.",
	"Method": "void main(String[] args){\r\n    int port;\r\n    boolean dieOnBrokenPipe = false;\r\n    boolean enableAuth = false;\r\n    String usage = \"usage: [--die-on-broken-pipe] [--enable-auth] port\";\r\n    if (args.length == 0) {\r\n        System.err.println(usage);\r\n        System.exit(1);\r\n    }\r\n    for (int i = 0; i < args.length - 1; i++) {\r\n        String opt = args[i];\r\n        if (opt.equals(\"--die-on-broken-pipe\")) {\r\n            dieOnBrokenPipe = true;\r\n        } else if (opt.equals(\"--enable-auth\")) {\r\n            enableAuth = true;\r\n        } else {\r\n            System.err.println(usage);\r\n            System.exit(1);\r\n        }\r\n    }\r\n    port = Integer.parseInt(args[args.length - 1]);\r\n    String authToken = null;\r\n    if (enableAuth) {\r\n        SecureRandom rnd = new SecureRandom();\r\n        byte[] token = new byte[256 / Byte.SIZE];\r\n        rnd.nextBytes(token);\r\n        authToken = Base64.encodeToString(token, false);\r\n    }\r\n    GatewayServer gatewayServer = new GatewayServerBuilder().javaPort(port).authToken(authToken).build();\r\n    gatewayServer.start();\r\n    int listening_port = gatewayServer.getListeningPort();\r\n    System.out.println(\"\" + listening_port);\r\n    if (authToken != null) {\r\n        System.out.println(authToken);\r\n    }\r\n    if (dieOnBrokenPipe) {\r\n        try {\r\n            BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in, Charset.forName(\"UTF-8\")));\r\n            stdin.readLine();\r\n            System.exit(0);\r\n        } catch (java.io.IOException e) {\r\n            System.exit(1);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.canSetFloat",
	"Comment": "indicates if convenience set method can be called withoutan exception being thrown for the float type.",
	"Method": "boolean canSetFloat(){\r\n    return canSet(float.class);\r\n}"
}, {
	"Path": "prefuse.visual.AggregateTable.aggregatedTuples",
	"Comment": "get all visualitems within the aggregate at the given table row.",
	"Method": "Iterator aggregatedTuples(int row){\r\n    return new AggregatedIterator(row);\r\n}"
}, {
	"Path": "prefuse.action.layout.StackedAreaChart.isNormalized",
	"Comment": "indicates if the stacks are normalized, such that eachcolumn is independently scaled.",
	"Method": "boolean isNormalized(){\r\n    return m_norm;\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.addEdge",
	"Comment": "unsupported operation. spanning trees should not be edited.",
	"Method": "int addEdge(int s,int t,Edge addEdge,Node s,Node t){\r\n    throw new UnsupportedOperationException(\"Changes to graph structure not allowed for spanning trees.\");\r\n}"
}, {
	"Path": "picard.util.AdapterMarker.setNumAdaptersToKeep",
	"Comment": "after seeing the thresholdforselectingadapters number of adapters, keep up to this many of the original adapters.",
	"Method": "AdapterMarker setNumAdaptersToKeep(int numAdaptersToKeep){\r\n    if (numAdaptersToKeep <= 0) {\r\n        throw new IllegalArgumentException(String.format(\"numAdaptersToKeep should be positive: %d\", numAdaptersToKeep));\r\n    }\r\n    this.numAdaptersToKeep = numAdaptersToKeep;\r\n    return this;\r\n}"
}, {
	"Path": "cn.hugeterry.ployfun.core.delaunay.Triangle.isNeighbor",
	"Comment": "true iff triangles are neighbors. two triangles are neighbors if theyshare a facet.",
	"Method": "boolean isNeighbor(Triangle triangle){\r\n    int count = 0;\r\n    for (Pnt vertex : this) if (!triangle.contains(vertex))\r\n        count++;\r\n    return count == 1;\r\n}"
}, {
	"Path": "prefuse.data.io.sql.ConnectionFactory.getMySQLConnection",
	"Comment": "get a new database connection to a mysql database, using a defaulthandler.",
	"Method": "DatabaseDataSource getMySQLConnection(String host,String database,String user,String password,SQLDataHandler handler,DatabaseDataSource getMySQLConnection,String host,String database,String user,String password){\r\n    return getMySQLConnection(host, database, user, password, getDefaultHandler());\r\n}"
}, {
	"Path": "prefuse.data.search.KeywordSearchTupleSet.isUnindexSupported",
	"Comment": "returns false, as unindexing values is not currently supported.",
	"Method": "boolean isUnindexSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "net.pms.network.NetworkConfiguration.getNetworkInterfaceByServerName",
	"Comment": "returns the network interface for the servername configured in pms, or\tnull if no servername is configured.",
	"Method": "NetworkInterface getNetworkInterfaceByServerName(){\r\n    String hostname = PMS.getConfiguration().getServerHostname();\r\n    if (hostname != null) {\r\n        logger.trace(\"Searching network interface for \" + hostname);\r\n        return NetworkInterface.getByInetAddress(InetAddress.getByName(hostname));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "picard.util.BaitDesigner.getMaskedBaseCount",
	"Comment": "returns the total of soft or hard masked bases in the interval of bases.",
	"Method": "int getMaskedBaseCount(int getMaskedBaseCount,byte[] bases,int from,int until){\r\n    int count = 0;\r\n    for (int i = from; i < until; i++) {\r\n        final byte b = bases[i];\r\n        if (b != 'A' && b != 'C' && b != 'G' && b != 'T')\r\n            ++count;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getForcedSubtitleLanguage",
	"Comment": "returns the iso 639 language code for the subtitle language that should\tbe forced.\tcan be a blank string.",
	"Method": "String getForcedSubtitleLanguage(){\r\n    return configurationReader.getPossiblyBlankConfigurationString(KEY_FORCED_SUBTITLE_LANGUAGE, getLanguage());\r\n}"
}, {
	"Path": "picard.sam.GatherBamFiles.gatherNormally",
	"Comment": "simple implementation of a gather operations that uses samfilereaders and writers in order to concatenatemultiple bam files.",
	"Method": "void gatherNormally(List<File> inputs,File output,boolean createIndex,boolean createMd5,File referenceFasta){\r\n    final SAMFileHeader header;\r\n    {\r\n        header = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).getFileHeader(inputs.get(0));\r\n    }\r\n    final SAMFileWriter out = new SAMFileWriterFactory().setCreateIndex(createIndex).setCreateMd5File(createMd5).makeSAMOrBAMWriter(header, true, output);\r\n    for (final File f : inputs) {\r\n        log.info(\"Gathering \" + f.getAbsolutePath());\r\n        final SamReader in = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(f);\r\n        for (final SAMRecord rec : in) out.addAlignment(rec);\r\n        CloserUtil.close(in);\r\n    }\r\n    out.close();\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeMap.getAllSnps",
	"Comment": "returns an unmodifiable collection of all snps in all haplotype blocks.",
	"Method": "Set<Snp> getAllSnps(){\r\n    return Collections.unmodifiableSet(haplotypesBySnp.keySet());\r\n}"
}, {
	"Path": "prefuse.data.Graph.getEdgeSourceField",
	"Comment": "get the data field used to denote the source node in an edge table.",
	"Method": "String getEdgeSourceField(){\r\n    return m_skey;\r\n}"
}, {
	"Path": "prefuse.util.ColorMap.setColorPalette",
	"Comment": "sets the internal color palette, an int array of color values.",
	"Method": "void setColorPalette(int[] palette){\r\n    this.palette = palette;\r\n}"
}, {
	"Path": "prefuse.data.util.FilteredRowManager.getParentRow",
	"Comment": "given a row managed by this manager, return the corresponding rowin the parent table.",
	"Method": "int getParentRow(int childRow){\r\n    if (childRow >= m_childToParent.getRowCount()) {\r\n        return -1;\r\n    } else {\r\n        return m_childToParent.getInt(childRow);\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.force.ForceSimulator.getSpeedLimit",
	"Comment": "get the speed limit, or maximum velocity value allowed by thissimulator.",
	"Method": "float getSpeedLimit(){\r\n    return speedLimit;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setMencoderMaxThreads",
	"Comment": "set the maximum number of concurrent mencoder threads.\txxx currently unused.",
	"Method": "void setMencoderMaxThreads(int value){\r\n    configuration.setProperty(KEY_MENCODER_MAX_THREADS, value);\r\n}"
}, {
	"Path": "picard.vcf.filter.FilterApplyingVariantIterator.next",
	"Comment": "provides the next record from the underlying iterator after applying filter strings generatedby the set of filters in use by the iterator.",
	"Method": "VariantContext next(){\r\n    final VariantContext ctx = this.iterator.next();\r\n    final Set<String> filterStrings = new HashSet<String>();\r\n    for (final VariantFilter filter : this.filters) {\r\n        final String val = filter.filter(ctx);\r\n        if (val != null)\r\n            filterStrings.add(val);\r\n    }\r\n    final ListMap<String, String> gtFilterStrings = new ListMap<String, String>();\r\n    final Set<String> variantSamples = new HashSet<String>();\r\n    for (final Genotype gt : ctx.getGenotypes()) {\r\n        if (gt.isCalled() && !gt.isHomRef())\r\n            variantSamples.add(gt.getSampleName());\r\n        for (final GenotypeFilter filter : gtFilters) {\r\n            final String filterString = filter.filter(ctx, gt);\r\n            if (filterString != null)\r\n                gtFilterStrings.add(gt.getSampleName(), filterString);\r\n        }\r\n    }\r\n    if (!variantSamples.isEmpty() && gtFilterStrings.keySet().containsAll(variantSamples)) {\r\n        filterStrings.add(ALL_GTS_FILTERED);\r\n    }\r\n    final VariantContextBuilder builder = new VariantContextBuilder(ctx);\r\n    if (filterStrings.isEmpty()) {\r\n        builder.passFilters();\r\n    } else {\r\n        builder.filters(filterStrings);\r\n    }\r\n    builder.noGenotypes();\r\n    final List<Genotype> newGenotypes = new ArrayList<Genotype>(ctx.getNSamples());\r\n    for (final Genotype gt : ctx.getGenotypes()) {\r\n        final GenotypeBuilder gtBuilder = new GenotypeBuilder(gt);\r\n        final List<String> filters = gtFilterStrings.get(gt.getSampleName());\r\n        if (filters == null || filters.isEmpty()) {\r\n            gtBuilder.filter(PASS_FILTER);\r\n        } else {\r\n            gtBuilder.filters(filters);\r\n        }\r\n        newGenotypes.add(gtBuilder.make());\r\n    }\r\n    builder.genotypes(newGenotypes);\r\n    return builder.make();\r\n}"
}, {
	"Path": "picard.sam.markduplicates.UmiAwareDuplicateSetIterator.process",
	"Comment": "takes a duplicate set and breaks it up into possible smaller sets according to the umi,and updates nextsetsiterator to be an iterator on that set of duplicatesets.",
	"Method": "void process(DuplicateSet set){\r\n    if (nextSetsIterator.hasNext()) {\r\n        throw new PicardException(\"nextSetsIterator is expected to be empty, but already contains data.\");\r\n    }\r\n    final UmiGraph umiGraph = new UmiGraph(set, umiTag, molecularIdentifierTag, allowMissingUmis, duplexUmi);\r\n    final String library = set.getRepresentative().getReadGroup().getLibrary();\r\n    final UmiMetrics metrics = umiMetricsMap.computeIfAbsent(library, UmiMetrics::new);\r\n    final List<DuplicateSet> duplicateSets = umiGraph.joinUmisIntoDuplicateSets(maxEditDistanceToJoin);\r\n    for (final DuplicateSet ds : duplicateSets) {\r\n        final List<SAMRecord> records = ds.getRecords();\r\n        for (final SAMRecord rec : records) {\r\n            final String currentUmi = UmiUtil.getTopStrandNormalizedUmi(rec, umiTag, duplexUmi);\r\n            if (currentUmi != null) {\r\n                if (currentUmi.contains(\"N\")) {\r\n                    metrics.addUmiObservationN();\r\n                } else {\r\n                    final int umiLength = UmiUtil.getUmiLength(currentUmi);\r\n                    if (!haveWeSeenFirstRead) {\r\n                        metrics.MEAN_UMI_LENGTH = umiLength;\r\n                        haveWeSeenFirstRead = true;\r\n                    } else {\r\n                        if (metrics.MEAN_UMI_LENGTH != umiLength) {\r\n                            throw new PicardException(\"UMIs of differing lengths were found.\");\r\n                        }\r\n                    }\r\n                    final String inferredUmi = (String) rec.getTransientAttribute(UmiUtil.INFERRED_UMI_TRANSIENT_TAG);\r\n                    metrics.OBSERVED_BASE_ERRORS += StringUtil.hammingDistance(currentUmi, inferredUmi);\r\n                    observedUmiBases += umiLength;\r\n                    metrics.addUmiObservation(currentUmi, inferredUmi);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    metrics.DUPLICATE_SETS_WITH_UMI += duplicateSets.size();\r\n    metrics.DUPLICATE_SETS_IGNORING_UMI++;\r\n    nextSetsIterator = duplicateSets.iterator();\r\n}"
}, {
	"Path": "prefuse.data.tuple.TableTuple.invalidate",
	"Comment": "invalidates this tuple. called by an enclosing table when a row is deleted.",
	"Method": "void invalidate(){\r\n    m_row = -1;\r\n}"
}, {
	"Path": "picard.analysis.TheoreticalSensitivity.proportionsAboveThresholds",
	"Comment": "given l lists of lists and n thresholds, count the proportion of each list above each threshold",
	"Method": "List<ArrayList<Double>> proportionsAboveThresholds(List<ArrayList<Integer>> lists,List<Double> thresholds){\r\n    final ArrayList<ArrayList<Double>> result = new ArrayList();\r\n    for (final ArrayList<Integer> list : lists) {\r\n        final ArrayList<Double> newRow = new ArrayList(Collections.nCopies(thresholds.size(), 0.0));\r\n        Collections.sort(list);\r\n        int n = 0;\r\n        int j = 0;\r\n        while (n < thresholds.size() && j < list.size()) {\r\n            if (thresholds.get(n) > list.get(j))\r\n                j++;\r\n            else\r\n                newRow.set(n++, (double) (list.size() - j) / list.size());\r\n        }\r\n        result.add(newRow);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "quickfix.DataDictionary.isHeaderGroup",
	"Comment": "predicate for determining if a field is a header group count field",
	"Method": "boolean isHeaderGroup(int field){\r\n    return groups.containsKey(new IntStringPair(field, HEADER_ID));\r\n}"
}, {
	"Path": "net.pms.network.HTTPResource.getDefaultMimeType",
	"Comment": "returns for a given item type the default mime type associated. this is used in the http transfers\tas in the client might do different things for different mime types.",
	"Method": "String getDefaultMimeType(int type){\r\n    String mimeType = HTTPResource.UNKNOWN_VIDEO_TYPEMIME;\r\n    if (type == Format.VIDEO) {\r\n        mimeType = HTTPResource.UNKNOWN_VIDEO_TYPEMIME;\r\n    } else if (type == Format.IMAGE) {\r\n        mimeType = HTTPResource.UNKNOWN_IMAGE_TYPEMIME;\r\n    } else if (type == Format.AUDIO) {\r\n        mimeType = HTTPResource.UNKNOWN_AUDIO_TYPEMIME;\r\n    }\r\n    return mimeType;\r\n}"
}, {
	"Path": "picard.sam.BuildBamIndex.doWork",
	"Comment": "main method for the program.checks that all input files are present andreadable and that the output file can be written to.then iterates throughall the records generating a bam index, then writes the bai file.",
	"Method": "int doWork(){\r\n    try {\r\n        inputUrl = new URL(INPUT);\r\n    } catch (java.net.MalformedURLException e) {\r\n        inputFile = new File(INPUT);\r\n    }\r\n    if (OUTPUT == null) {\r\n        final String baseFileName;\r\n        if (inputUrl != null) {\r\n            final String path = inputUrl.getPath();\r\n            final int lastSlash = path.lastIndexOf('/');\r\n            baseFileName = path.substring(lastSlash + 1, path.length());\r\n        } else {\r\n            baseFileName = inputFile.getAbsolutePath();\r\n        }\r\n        if (baseFileName.endsWith(BamFileIoUtils.BAM_FILE_EXTENSION)) {\r\n            final int index = baseFileName.lastIndexOf('.');\r\n            OUTPUT = new File(baseFileName.substring(0, index) + BAMIndex.BAMIndexSuffix);\r\n        } else {\r\n            OUTPUT = new File(baseFileName + BAMIndex.BAMIndexSuffix);\r\n        }\r\n    }\r\n    IOUtil.assertFileIsWritable(OUTPUT);\r\n    final SamReader bam;\r\n    if (inputUrl != null) {\r\n        bam = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).disable(SamReaderFactory.Option.EAGERLY_DECODE).enable(SamReaderFactory.Option.INCLUDE_SOURCE_IN_RECORDS).open(SamInputResource.of(inputUrl));\r\n    } else {\r\n        IOUtil.assertFileIsReadable(inputFile);\r\n        bam = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).enable(SamReaderFactory.Option.INCLUDE_SOURCE_IN_RECORDS).open(inputFile);\r\n    }\r\n    if (bam.type() != SamReader.Type.BAM_TYPE) {\r\n        throw new SAMException(\"Input file must be bam file, not sam file.\");\r\n    }\r\n    if (!bam.getFileHeader().getSortOrder().equals(SAMFileHeader.SortOrder.coordinate)) {\r\n        throw new SAMException(\"Input bam file must be sorted by coordinate\");\r\n    }\r\n    BAMIndexer.createIndex(bam, OUTPUT);\r\n    log.info(\"Successfully wrote bam index file \" + OUTPUT);\r\n    CloserUtil.close(bam);\r\n    return 0;\r\n}"
}, {
	"Path": "picard.vcf.filter.TestFilterVcf.sorted",
	"Comment": "returns a sorted copy of the supplied set, for safer comparison.",
	"Method": "SortedSet<T> sorted(Set<T> in){\r\n    return new TreeSet(in);\r\n}"
}, {
	"Path": "com.restfb.types.User.getInvitableFriends",
	"Comment": "a list of friends that can be invited to install a facebook canvas app",
	"Method": "List<UserInvitableFriend> getInvitableFriends(){\r\n    return unmodifiableList(invitableFriends);\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.addNode",
	"Comment": "unsupported operation. spanning trees should not be edited.",
	"Method": "Node addNode(){\r\n    throw new UnsupportedOperationException(\"Changes to graph structure not allowed for spanning trees.\");\r\n}"
}, {
	"Path": "quickfix.JdbcStoreLegacyTest.initializeTableDefinitions",
	"Comment": "this will load the old table definitions with the limited session id. the jdbcstoreshould automatically adapt to the existing table definition.",
	"Method": "void initializeTableDefinitions(String sessionsTableName,String messagesTableName){\r\n    Connection connection = null;\r\n    try {\r\n        connection = getDataSource().getConnection();\r\n        JdbcTestSupport.loadSQL(connection, \"config/sql/hsqldb/messages_table.sql\", new JdbcTestSupport.HypersonicLegacyPreprocessor(messagesTableName));\r\n        JdbcTestSupport.loadSQL(connection, \"config/sql/hsqldb/sessions_table.sql\", new JdbcTestSupport.HypersonicLegacyPreprocessor(sessionsTableName));\r\n    } finally {\r\n        JdbcUtil.close(null, connection);\r\n    }\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getStringList",
	"Comment": "return a list of string values for a given configuration\tkey. first, the key is looked up in the current configuration settings. if it\texists and contains a valid value, that value is returned. if the key contains an\tinvalid value or cannot be found, a list with the specified default values is\treturned.",
	"Method": "List<String> getStringList(String key,String def){\r\n    return configurationReader.getStringList(key, def);\r\n}"
}, {
	"Path": "com.egzosn.pay.paypal.bean.order.RedirectUrls.setCancelUrl",
	"Comment": "url where the payer would be redirected to after canceling the payment. required for paypal account payments.",
	"Method": "RedirectUrls setCancelUrl(String cancelUrl){\r\n    this.cancelUrl = cancelUrl;\r\n    return this;\r\n}"
}, {
	"Path": "prefuse.data.column.ColumnMetadata.getMaximumRow",
	"Comment": "get the row index of the maximum column value. if there are multiplemaxima, only one is returned.",
	"Method": "int getMaximumRow(){\r\n    accessCheck();\r\n    if (m_max == -1 && m_dynamic) {\r\n        Index idx = m_table.getIndex(m_field);\r\n        if (idx != null) {\r\n            m_max = idx.maximum();\r\n        } else {\r\n            m_max = DataLib.max(m_table.tuples(), m_field, m_cmp).getRow();\r\n        }\r\n    }\r\n    return m_max;\r\n}"
}, {
	"Path": "com.restfb.json.JsonArray.set",
	"Comment": "replaces the element at the specified position in this array with the specified json value.",
	"Method": "JsonArray set(int index,int value,JsonArray set,int index,long value,JsonArray set,int index,float value,JsonArray set,int index,double value,JsonArray set,int index,boolean value,JsonArray set,int index,String value,JsonArray set,int index,JsonValue value){\r\n    if (value == null) {\r\n        throw new NullPointerException(\"value is null\");\r\n    }\r\n    values.set(index, value);\r\n    return this;\r\n}"
}, {
	"Path": "picard.analysis.ChimeraUtil.isChimeric",
	"Comment": "checks whether the given read is part of a chimeric pair.note that this method returns false if either end of the pair is unmapped.",
	"Method": "boolean isChimeric(SAMRecord rec,int maxInsertSize,Set<PairOrientation> expectedOrientations,boolean isChimeric,SAMRecord r1,SAMRecord r2,int maxInsertSize,Set<PairOrientation> expectedOrientations){\r\n    return isMappedPair(r1) && (Math.abs(r1.getInferredInsertSize()) > maxInsertSize || !r1.getReferenceIndex().equals(r2.getReferenceIndex()) || !matchesExpectedOrientations(r1, expectedOrientations) || r2.getAttribute(SAMTag.SA.toString()) != null);\r\n}"
}, {
	"Path": "prefuse.util.GraphicsLib.growPolygon",
	"Comment": "expand a polygon by adding the given distance along the line fromthe centroid of the polyong.",
	"Method": "void growPolygon(float pts,int len,float amt){\r\n    float[] c = centroid(pts, len);\r\n    for (int i = 0; i < len; i += 2) {\r\n        float vx = pts[i] - c[0];\r\n        float vy = pts[i + 1] - c[1];\r\n        float norm = (float) Math.sqrt(vx * vx + vy * vy);\r\n        pts[i] += amt * vx / norm;\r\n        pts[i + 1] += amt * vy / norm;\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.Table.canGetInt",
	"Comment": "check if the given data field can return primitive intvalues.",
	"Method": "boolean canGetInt(String field){\r\n    Column col = getColumn(field);\r\n    return (col == null ? false : col.canGetInt());\r\n}"
}, {
	"Path": "prefuse.Display.paintDisplay",
	"Comment": "renders the display within the given graphics context and size bounds.",
	"Method": "void paintDisplay(Graphics2D g2D,Dimension d){\r\n    synchronized (m_vis) {\r\n        synchronized (this) {\r\n            if (m_clip.isEmpty())\r\n                return;\r\n            m_screen.setClip(0, 0, d.width + 1, d.height + 1);\r\n            m_screen.transform(m_itransform);\r\n            double pixel = 1.0 + 1.0 / getScale();\r\n            if (m_damageRedraw) {\r\n                if (m_clip.isInvalid()) {\r\n                    m_clip.setClip(m_screen);\r\n                } else {\r\n                    m_clip.intersection(m_screen);\r\n                }\r\n                m_clip.expand(pixel);\r\n                prepareGraphics(g2D);\r\n                m_rclip.setFrameFromDiagonal(m_clip.getMinX(), m_clip.getMinY(), m_clip.getMaxX(), m_clip.getMaxY());\r\n                g2D.setClip(m_rclip);\r\n                m_rclip.setFrameFromDiagonal(m_clip.getMinX() - pixel, m_clip.getMinY() - pixel, m_clip.getMaxX() + pixel, m_clip.getMaxY() + pixel);\r\n            } else {\r\n                m_rclip.setFrame(m_screen.getMinX(), m_screen.getMinY(), m_screen.getWidth(), m_screen.getHeight());\r\n                m_clip.setClip(m_screen);\r\n                prepareGraphics(g2D);\r\n            }\r\n            clearRegion(g2D, m_rclip);\r\n            getItemBounds(m_rclip);\r\n            m_bounds.reset();\r\n            m_queue.clear();\r\n            Iterator items = m_vis.items(m_predicate);\r\n            for (m_visibleCount = 0; items.hasNext(); ++m_visibleCount) {\r\n                VisualItem item = (VisualItem) items.next();\r\n                Rectangle2D bounds = item.getBounds();\r\n                m_bounds.union(bounds);\r\n                if (m_clip.intersects(bounds, pixel))\r\n                    m_queue.addToRenderQueue(item);\r\n                if (item.isInteractive())\r\n                    m_queue.addToPickingQueue(item);\r\n            }\r\n            m_queue.sortRenderQueue();\r\n            for (int i = 0; i < m_queue.rsize; ++i) {\r\n                m_queue.ritems[i].render(g2D);\r\n            }\r\n            if (m_damageRedraw)\r\n                m_clip.reset();\r\n            checkItemBoundsChanged(m_rclip);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "picard.util.BasicInputParser.readNextLine",
	"Comment": "workhorse method that reads the next line from the underlying reader",
	"Method": "byte[] readNextLine(){\r\n    try {\r\n        final String line = reader.readLine();\r\n        if (nextLine != null && !isComment(nextLine.getBytes())) {\r\n            currentLineNumber = nextLineNumber;\r\n            currentLine = nextLine;\r\n        }\r\n        if (line != null) {\r\n            nextLineNumber++;\r\n            nextLine = line;\r\n            return line.getBytes();\r\n        }\r\n        if (!inputs.isEmpty()) {\r\n            advanceFile();\r\n            return readNextLine();\r\n        }\r\n        return null;\r\n    } catch (RuntimeIOException ioe) {\r\n        throw new PicardException(\"Error reading from file \" + currentFileName, ioe);\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.search.KeywordSearchTupleSet.getMatchingTuple",
	"Comment": "return the tuple matching the given lucene document, if any.",
	"Method": "Tuple getMatchingTuple(Document d){\r\n    int id = Integer.parseInt(d.get(LuceneSearcher.ID));\r\n    return (Tuple) m_map.get(id);\r\n}"
}, {
	"Path": "quickfix.BusinessRejectReasonText.getMessage",
	"Comment": "get the description string for a specified business reject reason.",
	"Method": "String getMessage(int rejectReason){\r\n    return rejectReasonText.get(rejectReason);\r\n}"
}, {
	"Path": "prefuse.action.layout.StackedAreaChart.getRangeModel",
	"Comment": "get the range model describing the range occupied by the valuestack.",
	"Method": "ValuedRangeModel getRangeModel(){\r\n    return m_model;\r\n}"
}, {
	"Path": "picard.util.ClippingUtility.findIndexOfClipSequence",
	"Comment": "finds the first index of the adaptersequence sequence in the read sequence requiring at least minmatchbases of pairwise alignment with a maximum number of errors dictated by maxerrorrate.",
	"Method": "int findIndexOfClipSequence(byte[] read,byte[] adapterSequence,int minMatch,double maxErrorRate){\r\n    if (read == null || read.length < minMatch)\r\n        return NO_MATCH;\r\n    final int minClipPosition = 0;\r\n    READ_LOOP: for (int start = read.length - minMatch; start > minClipPosition - 1; --start) {\r\n        final int length = Math.min(read.length - start, adapterSequence.length);\r\n        final int mismatchesAllowed = (int) (length * maxErrorRate);\r\n        int mismatches = 0;\r\n        for (int i = 0; i < length; ++i) {\r\n            if (!SequenceUtil.isNoCall(adapterSequence[i]) && !SequenceUtil.basesEqual(adapterSequence[i], read[start + i]) && ++mismatches > mismatchesAllowed) {\r\n                continue READ_LOOP;\r\n            }\r\n        }\r\n        return start;\r\n    }\r\n    return NO_MATCH;\r\n}"
}, {
	"Path": "net.pms.external.ExternalFactory.registerListenerClass",
	"Comment": "stores the class of an external listener in a list for later retrieval. \tthe same class will only be stored once.",
	"Method": "void registerListenerClass(Class<?> clazz){\r\n    if (!externalListenerClasses.contains(clazz)) {\r\n        externalListenerClasses.add(clazz);\r\n    }\r\n}"
}, {
	"Path": "com.google.gwt.sample.validation.client.ValidationView.sendPersonToServer",
	"Comment": "send the person from the namefield to the server and wait for a response.",
	"Method": "void sendPersonToServer(){\r\n    errorLabel.setText(\"\");\r\n    person.setName(nameField.getText());\r\n    Validator validator = Validation.buildDefaultValidatorFactory().getValidator();\r\n    Set<ConstraintViolation<Person>> violations = validator.validate(person, Default.class, ClientGroup.class);\r\n    if (!violations.isEmpty()) {\r\n        StringBuffer errorMessage = new StringBuffer();\r\n        for (ConstraintViolation<Person> constraintViolation : violations) {\r\n            if (errorMessage.length() == 0) {\r\n                errorMessage.append('\\n');\r\n            }\r\n            errorMessage.append(constraintViolation.getMessage());\r\n        }\r\n        errorLabel.setText(errorMessage.toString());\r\n        return;\r\n    }\r\n    sendButton.setEnabled(false);\r\n    textToServer.setText(person.getName());\r\n    serverResponse.setText(\"\");\r\n    greetingService.greetServer(person, new AsyncCallback<SafeHtml>() {\r\n        public void onFailure(Throwable caught) {\r\n            if (caught instanceof ConstraintViolationException) {\r\n                ConstraintViolationException violationException = (ConstraintViolationException) caught;\r\n                Set<ConstraintViolation<?>> violations = violationException.getConstraintViolations();\r\n                StringBuffer sb = new StringBuffer();\r\n                for (ConstraintViolation<?> constraintViolation : violations) {\r\n                    // \r\n                    sb.append(constraintViolation.getPropertyPath().toString()).append(// \r\n                    \":\").append(constraintViolation.getMessage()).append(\"\\n\");\r\n                }\r\n                errorLabel.setText(sb.toString());\r\n                sendButton.setEnabled(true);\r\n                sendButton.setFocus(true);\r\n                return;\r\n            }\r\n            dialogBox.setText(\"Remote Procedure Call - Failure\");\r\n            serverResponse.addStyleName(style.error());\r\n            serverResponse.setHTML(SERVER_ERROR);\r\n            dialogBox.center();\r\n            closeButton.setFocus(true);\r\n        }\r\n        public void onSuccess(SafeHtml result) {\r\n            dialogBox.setText(\"Remote Procedure Call\");\r\n            serverResponse.removeStyleName(style.error());\r\n            serverResponse.setHTML(result);\r\n            dialogBox.center();\r\n            closeButton.setFocus(true);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.google.gwt.sample.validation.client.ValidationView.sendPersonToServer",
	"Comment": "send the person from the namefield to the server and wait for a response.",
	"Method": "void sendPersonToServer(){\r\n    if (caught instanceof ConstraintViolationException) {\r\n        ConstraintViolationException violationException = (ConstraintViolationException) caught;\r\n        Set<ConstraintViolation<?>> violations = violationException.getConstraintViolations();\r\n        StringBuffer sb = new StringBuffer();\r\n        for (ConstraintViolation<?> constraintViolation : violations) {\r\n            // \r\n            sb.append(constraintViolation.getPropertyPath().toString()).append(// \r\n            \":\").append(constraintViolation.getMessage()).append(\"\\n\");\r\n        }\r\n        errorLabel.setText(sb.toString());\r\n        sendButton.setEnabled(true);\r\n        sendButton.setFocus(true);\r\n        return;\r\n    }\r\n    dialogBox.setText(\"Remote Procedure Call - Failure\");\r\n    serverResponse.addStyleName(style.error());\r\n    serverResponse.setHTML(SERVER_ERROR);\r\n    dialogBox.center();\r\n    closeButton.setFocus(true);\r\n}"
}, {
	"Path": "com.google.gwt.sample.validation.client.ValidationView.sendPersonToServer",
	"Comment": "send the person from the namefield to the server and wait for a response.",
	"Method": "void sendPersonToServer(){\r\n    dialogBox.setText(\"Remote Procedure Call\");\r\n    serverResponse.removeStyleName(style.error());\r\n    serverResponse.setHTML(result);\r\n    dialogBox.center();\r\n    closeButton.setFocus(true);\r\n}"
}, {
	"Path": "picard.analysis.TheoreticalSensitivity.isCalled",
	"Comment": "determines if a variant would be called under the particular conditions of a given total depth, alt depth,average base qualities, allele fraction of variant and log odds threshold necessary to call variant.",
	"Method": "boolean isCalled(int totalDepth,int altDepth,double sumOfAltQualities,double alleleFraction,double logOddsThreshold){\r\n    final double threshold = 10.0 * (altDepth * -Math.log10(alleleFraction) + (totalDepth - altDepth) * -Math.log10(1.0 - alleleFraction) + logOddsThreshold);\r\n    return sumOfAltQualities > threshold;\r\n}"
}, {
	"Path": "net.pms.util.Version.getMinor",
	"Comment": "returns the second integer element of this version string,\tor 0 if a second integer was not defined or could not be parsed",
	"Method": "int getMinor(){\r\n    if (elements.length > 1) {\r\n        return elements[1];\r\n    } else {\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "quickfix.MessageUtils.getMinimalMessage",
	"Comment": "tries to set msgseqnum and msgtype from a fix string to a new message.these fields are referenced on the outgoing reject message.",
	"Method": "Message getMinimalMessage(String messageString){\r\n    final Message tempMessage = new Message();\r\n    final String seqNum = getStringField(messageString, 34);\r\n    if (seqNum != null) {\r\n        tempMessage.getHeader().setString(34, seqNum);\r\n    }\r\n    final String msgType = getStringField(messageString, 35);\r\n    if (msgType != null) {\r\n        tempMessage.getHeader().setString(35, msgType);\r\n    }\r\n    return tempMessage;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getMencoderNoAssSubPos",
	"Comment": "returns the subpos parameter used for subtitling without ass.\tdefault value is 2.",
	"Method": "String getMencoderNoAssSubPos(){\r\n    return getString(KEY_MENCODER_NOASS_SUBPOS, \"2\");\r\n}"
}, {
	"Path": "prefuse.data.query.RangeQueryBinding.createComponent",
	"Comment": "create a new horizontal range slider for interacting with the query.",
	"Method": "JComponent createComponent(){\r\n    return createHorizontalRangeSlider();\r\n}"
}, {
	"Path": "prefuse.data.Table.updateRowCount",
	"Comment": "internal method that updates the row counts for local data columns.",
	"Method": "void updateRowCount(){\r\n    int maxrow = m_rows.getMaximumRow() + 1;\r\n    Iterator cols = getColumns();\r\n    while (cols.hasNext()) {\r\n        Column c = (Column) cols.next();\r\n        c.setMaximumRow(maxrow);\r\n    }\r\n}"
}, {
	"Path": "com.restfb.types.webhook.messaging.MessagingAttachment.isFallback",
	"Comment": "convenience method to check if the attachment type is fallback",
	"Method": "boolean isFallback(){\r\n    return FALLBACK.equals(type);\r\n}"
}, {
	"Path": "picard.util.AdapterMarker.tallyFoundAdapter",
	"Comment": "keep track of every time an adapter is found, until it is time to prune the list of adapters.",
	"Method": "void tallyFoundAdapter(AdapterPair foundAdapter){\r\n    if (thresholdForSelectingAdaptersToKeep < 1)\r\n        return;\r\n    synchronized (this) {\r\n        seenCounts.put(foundAdapter, seenCounts.get(foundAdapter) + 1);\r\n        numAdaptersSeen += 1;\r\n        if (numAdaptersSeen >= thresholdForSelectingAdaptersToKeep) {\r\n            final TreeMap<Integer, AdapterPair> sortedAdapters = new TreeMap<Integer, AdapterPair>(new Comparator<Integer>() {\r\n                @Override\r\n                public int compare(final Integer integer, final Integer integer2) {\r\n                    return integer2.compareTo(integer);\r\n                }\r\n            });\r\n            for (final Map.Entry<AdapterPair, Integer> entry : seenCounts.entrySet()) {\r\n                sortedAdapters.put(entry.getValue(), entry.getKey());\r\n            }\r\n            final ArrayList<AdapterPair> bestAdapters = new ArrayList<AdapterPair>(numAdaptersToKeep);\r\n            int countOfLastAdapter = Integer.MAX_VALUE;\r\n            for (final Map.Entry<Integer, AdapterPair> entry : sortedAdapters.entrySet()) {\r\n                if (bestAdapters.size() >= numAdaptersToKeep) {\r\n                    if (entry.getKey() == countOfLastAdapter) {\r\n                        bestAdapters.add(entry.getValue());\r\n                    } else {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    countOfLastAdapter = entry.getKey();\r\n                    bestAdapters.add(entry.getValue());\r\n                }\r\n            }\r\n            thresholdReached = true;\r\n            adapters.set(bestAdapters.toArray(new AdapterPair[bestAdapters.size()]));\r\n            fixAlreadySeenReads();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "picard.util.AdapterMarker.tallyFoundAdapter",
	"Comment": "keep track of every time an adapter is found, until it is time to prune the list of adapters.",
	"Method": "void tallyFoundAdapter(AdapterPair foundAdapter){\r\n    return integer2.compareTo(integer);\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeBlock.getSnpGenotype",
	"Comment": "gets the expected genotype of the provided snp given the provided haplotype of thishaplotype block.",
	"Method": "DiploidGenotype getSnpGenotype(Snp snp,DiploidHaplotype haplotype){\r\n    if (!contains(snp))\r\n        throw new IllegalArgumentException(\"Snp is not part of haplotype \" + snp);\r\n    return snp.getGenotype(haplotype);\r\n}"
}, {
	"Path": "picard.illumina.IlluminaBasecallsToSamTest.runStandardTest",
	"Comment": "this test utility takes a libraryparamsfile and generates output sam files through illuminabasecallstosam to compare againstpreloaded test data",
	"Method": "void runStandardTest(int lane,String jobName,String libraryParamsFile,int concatNColumnFields,String readStructure,File baseCallsDir,File testDataDir,Integer tile,boolean includeBcInHeader,ClusterDataToSamConverter.PopulateBarcode populateBarcode,boolean includeBarcodeQuality){\r\n    final Path outputDir = Files.createTempDirectory(jobName);\r\n    try {\r\n        final String tilePrefix = (tile != null) ? tile + \".\" : \"\";\r\n        final File libraryParams = new File(outputDir.toFile(), libraryParamsFile);\r\n        libraryParams.deleteOnExit();\r\n        final List<File> samFiles = new ArrayList();\r\n        final LineReader reader = new BufferedLineReader(new FileInputStream(new File(testDataDir, libraryParamsFile)));\r\n        final PrintWriter writer = new PrintWriter(libraryParams);\r\n        final String header = reader.readLine();\r\n        writer.println(header + \"\\tOUTPUT\");\r\n        while (true) {\r\n            final String line = reader.readLine();\r\n            if (line == null) {\r\n                break;\r\n            }\r\n            final String[] fields = line.split(\"\\t\");\r\n            final File outputSam = new File(outputDir.toFile(), StringUtil.join(\"\", Arrays.copyOfRange(fields, 0, concatNColumnFields)) + \".sam\");\r\n            outputSam.deleteOnExit();\r\n            samFiles.add(new File(outputSam.getParentFile(), tilePrefix + outputSam.getName()));\r\n            writer.println(line + \"\\t\" + outputSam);\r\n        }\r\n        writer.close();\r\n        reader.close();\r\n        List<String> args = new ArrayList();\r\n        args.add(\"BASECALLS_DIR=\" + baseCallsDir);\r\n        args.add(\"LANE=\" + lane);\r\n        args.add(\"RUN_BARCODE=HiMom\");\r\n        args.add(\"READ_STRUCTURE=\" + readStructure);\r\n        args.add(\"SEQUENCING_CENTER=BI\");\r\n        args.add(\"LIBRARY_PARAMS=\" + libraryParams);\r\n        args.add(\"INCLUDE_BC_IN_RG_TAG=\" + includeBcInHeader);\r\n        args.add(\"BARCODE_POPULATION_STRATEGY=\" + populateBarcode.name());\r\n        args.add(\"INCLUDE_BARCODE_QUALITY=\" + includeBarcodeQuality);\r\n        if (tile != null) {\r\n            args.add(\"PROCESS_SINGLE_TILE=\" + tile);\r\n        }\r\n        Assert.assertEquals(runPicardCommandLine(args), 0);\r\n        for (final File outputSam : samFiles) {\r\n            IOUtil.assertFilesEqual(outputSam, new File(testDataDir, outputSam.getName()));\r\n        }\r\n    } finally {\r\n        TestUtil.recursiveDelete(outputDir.toFile());\r\n        Files.delete(outputDir);\r\n    }\r\n}"
}, {
	"Path": "quickfix.SessionID.getSessionQualifier",
	"Comment": "session qualifier can be used to identify different sessionsfor the same target company id. session qualifiers can only me usedwith initiated sessions. they cannot be used with accepted sessions.",
	"Method": "String getSessionQualifier(){\r\n    return sessionQualifier;\r\n}"
}, {
	"Path": "picard.sam.CompareSAMs.doWork",
	"Comment": "do the work after command line has been parsed. runtimeexception may bethrown by this method, and are reported appropriately.",
	"Method": "int doWork(){\r\n    for (int i = 0; i < samFiles.size(); ++i) {\r\n        samReaders[i] = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(samFiles.get(i));\r\n    }\r\n    areEqual = compareHeaders();\r\n    areEqual = compareAlignments() && areEqual;\r\n    printReport();\r\n    if (!areEqual) {\r\n        System.out.println(\"SAM files differ.\");\r\n    } else {\r\n        System.out.println(\"SAM files match.\");\r\n    }\r\n    CloserUtil.close(samReaders);\r\n    return 0;\r\n}"
}, {
	"Path": "prefuse.data.CascadedTable.getChildRow",
	"Comment": "given a row in the parent table, return the corresponding row, if any,in this table.",
	"Method": "int getChildRow(int prow){\r\n    return ((CascadedRowManager) m_rows).getChildRow(prow);\r\n}"
}, {
	"Path": "prefuse.data.Table.remove",
	"Comment": "removes all table rows that meet the input predicate filter.",
	"Method": "void remove(Predicate filter){\r\n    for (IntIterator ii = rows(filter); ii.hasNext(); ) removeRow(ii.nextInt());\r\n}"
}, {
	"Path": "prefuse.render.LabelRenderer.getImage",
	"Comment": "get the image to include in the label for the given visualitem.",
	"Method": "Image getImage(VisualItem item){\r\n    String imageLoc = getImageLocation(item);\r\n    return (imageLoc == null ? null : m_images.getImage(imageLoc));\r\n}"
}, {
	"Path": "prefuse.data.util.SortedTupleIterator.init",
	"Comment": "initialize this iterator for the given source iterator andcomparator.",
	"Method": "void init(Iterator iter,Comparator c){\r\n    m_tuples.clear();\r\n    m_cmp = c;\r\n    while (iter.hasNext()) {\r\n        Tuple t = (Tuple) iter.next();\r\n        m_tuples.add(t);\r\n    }\r\n    Collections.sort(m_tuples, m_cmp);\r\n    m_iter = m_tuples.iterator();\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeProbabilitiesFromSequence.getTotalObs",
	"Comment": "gets the total number of observations presented at this locus.",
	"Method": "int getTotalObs(){\r\n    return obsAllele1 + obsAllele2 + obsAlleleOther;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.isMencoderUsePcmForHQAudioOnly",
	"Comment": "returns whether or not the pulse code modulation audio format should be\tused only for hq audio codecs. the default is false.",
	"Method": "boolean isMencoderUsePcmForHQAudioOnly(){\r\n    return getBoolean(KEY_MENCODER_USE_PCM_FOR_HQ_AUDIO_ONLY, false);\r\n}"
}, {
	"Path": "com.restfb.types.webhook.messaging.AccountLinkingItem.isLinked",
	"Comment": "convenience method to check the status of the account linking",
	"Method": "boolean isLinked(){\r\n    return LINKED.equals(status);\r\n}"
}, {
	"Path": "picard.analysis.CollectQualityYieldMetrics.usesNoRefReads",
	"Comment": "ensure that we get all reads regardless of alignment status.",
	"Method": "boolean usesNoRefReads(){\r\n    return true;\r\n}"
}, {
	"Path": "prefuse.util.ui.JSearchPanel.setShowResultCount",
	"Comment": "indicates if the component should show the number of search results.",
	"Method": "void setShowResultCount(boolean b){\r\n    this.m_includeHitCount = b;\r\n    initUI();\r\n    validate();\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setTsmuxerForceFps",
	"Comment": "if the framerate is not recognized correctly and the video runs too fast or too\tslow, tsmuxer can be forced to parse the fps from ffmpeg.",
	"Method": "void setTsmuxerForceFps(boolean value){\r\n    configuration.setProperty(KEY_TSMUXER_FORCEFPS, value);\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.generator.ShowcaseGenerator.isFirstPass",
	"Comment": "ensure that we only generate files once by creating a placeholder file,then looking for it on subsequent generates.",
	"Method": "boolean isFirstPass(){\r\n    String placeholder = ShowcaseConstants.DST_SOURCE + \"generated\";\r\n    try {\r\n        OutputStream outStream = context.tryCreateResource(logger, placeholder);\r\n        if (outStream == null) {\r\n            return false;\r\n        } else {\r\n            context.commitResource(logger, outStream);\r\n        }\r\n    } catch (UnableToCompleteException e) {\r\n        logger.log(TreeLogger.ERROR, \"Unable to generate\", e);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "prefuse.util.display.DisplayLib.getBounds",
	"Comment": "get a bounding rectangle of the visualitems in the input iterator.",
	"Method": "Rectangle2D getBounds(Iterator iter,double margin,Rectangle2D b,Rectangle2D getBounds,Iterator iter,double margin){\r\n    Rectangle2D b = new Rectangle2D.Double();\r\n    return getBounds(iter, margin, b);\r\n}"
}, {
	"Path": "net.pms.configuration.RendererConfigurationTest.testHeader",
	"Comment": "test one particular header line to see if it returns the correct\trenderer. set the correct renderer name to null to require\tthat nothing matches at all.",
	"Method": "void testHeader(String headerLine,String correctRendererName){\r\n    if (correctRendererName != null) {\r\n        if (headerLine != null && headerLine.toLowerCase().startsWith(\"user-agent\")) {\r\n            RendererConfiguration rc = getRendererConfigurationByUA(headerLine);\r\n            assertNotNull(\"Recognized renderer for header \\\"\" + headerLine + \"\\\"\", rc);\r\n            assertEquals(\"Expected renderer \\\"\" + correctRendererName + \"\\\", \" + \"instead renderer \\\"\" + rc.getRendererName() + \"\\\" was returned for header \\\"\" + headerLine + \"\\\"\", correctRendererName, rc.getRendererName());\r\n        } else {\r\n            RendererConfiguration rc = getRendererConfigurationByUAAHH(headerLine);\r\n            assertNotNull(\"Recognized renderer for header \\\"\" + headerLine + \"\\\"\", rc);\r\n            assertEquals(\"Expected renderer \\\"\" + correctRendererName + \"\\\" to be recognized, \" + \"instead renderer \\\"\" + rc.getRendererName() + \"\\\" was returned for header \\\"\" + headerLine + \"\\\"\", correctRendererName, rc.getRendererName());\r\n        }\r\n    } else {\r\n        if (headerLine != null && headerLine.toLowerCase().startsWith(\"user-agent\")) {\r\n            RendererConfiguration rc = getRendererConfigurationByUA(headerLine);\r\n            assertEquals(\"Expected no matching renderer to be found for header \\\"\" + headerLine + \"\\\", instead renderer \\\"\" + (rc != null ? rc.getRendererName() : \"\") + \"\\\" was recognized.\", null, rc);\r\n        } else {\r\n            RendererConfiguration rc = getRendererConfigurationByUAAHH(headerLine);\r\n            assertEquals(\"Expected no matching renderer to be found for header \\\"\" + headerLine + \"\\\", instead renderer \\\"\" + (rc != null ? rc.getRendererName() : \"\") + \"\\\" was recognized.\", null, rc);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.CascadedTable.addCascadedRow",
	"Comment": "internal method for adding a new cascaded row backed bythe given parent row.",
	"Method": "int addCascadedRow(int prow){\r\n    int r = m_rows.addRow();\r\n    ((CascadedRowManager) m_rows).put(r, prow);\r\n    updateRowCount();\r\n    fireTableEvent(r, r, TableModelEvent.ALL_COLUMNS, TableModelEvent.INSERT);\r\n    return r;\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.removeChildEdge",
	"Comment": "unsupported operation. spanning trees should not be edited.",
	"Method": "boolean removeChildEdge(Edge e,boolean removeChildEdge,int edge){\r\n    throw new UnsupportedOperationException(\"Changes to tree structure not allowed for spanning trees.\");\r\n}"
}, {
	"Path": "prefuse.data.CascadedTable.getColumnProjection",
	"Comment": "get the columnprojection determining which columns of theparent table are included in this one.",
	"Method": "ColumnProjection getColumnProjection(){\r\n    return m_colFilter;\r\n}"
}, {
	"Path": "prefuse.render.EdgeRenderer.getArrowHeadWidth",
	"Comment": "get the width of the untransformed arrow head. this is the length,in pixels, of the base of the arrow head.",
	"Method": "int getArrowHeadWidth(){\r\n    return m_arrowWidth;\r\n}"
}, {
	"Path": "net.pms.network.NetworkConfiguration.skipNetworkInterface",
	"Comment": "returns true if the name or displayname match the configured interfaces\tto skip, false otherwise.",
	"Method": "boolean skipNetworkInterface(String name,String displayName){\r\n    for (String current : skipNetworkInterfaces) {\r\n        if (current != null) {\r\n            if (name != null && name.toLowerCase().startsWith(current.toLowerCase())) {\r\n                return true;\r\n            }\r\n            if (displayName != null && displayName.toLowerCase().startsWith(current.toLowerCase())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "prefuse.util.GraphicsLib.isNonLeft",
	"Comment": "convex hull helper method for detecting a non left turn about 3 points",
	"Method": "boolean isNonLeft(int i0,int i1,int i2,int i3,double[] pts){\r\n    double l1, l2, l4, l5, l6, angle1, angle2, angle;\r\n    l1 = Math.sqrt(Math.pow(pts[i2 + 1] - pts[i1 + 1], 2) + Math.pow(pts[i2] - pts[i1], 2));\r\n    l2 = Math.sqrt(Math.pow(pts[i3 + 1] - pts[i2 + 1], 2) + Math.pow(pts[i3] - pts[i2], 2));\r\n    l4 = Math.sqrt(Math.pow(pts[i3 + 1] - pts[i0 + 1], 2) + Math.pow(pts[i3] - pts[i0], 2));\r\n    l5 = Math.sqrt(Math.pow(pts[i1 + 1] - pts[i0 + 1], 2) + Math.pow(pts[i1] - pts[i0], 2));\r\n    l6 = Math.sqrt(Math.pow(pts[i2 + 1] - pts[i0 + 1], 2) + Math.pow(pts[i2] - pts[i0], 2));\r\n    angle1 = Math.acos(((l2 * l2) + (l6 * l6) - (l4 * l4)) / (2 * l2 * l6));\r\n    angle2 = Math.acos(((l6 * l6) + (l1 * l1) - (l5 * l5)) / (2 * l6 * l1));\r\n    angle = (Math.PI - angle1) - angle2;\r\n    if (angle <= 0.0) {\r\n        return (true);\r\n    } else {\r\n        return (false);\r\n    }\r\n}"
}, {
	"Path": "picard.illumina.parser.readers.PosFileReader.unsafeNextInfo",
	"Comment": "read a line of text and parse it into two float values, create a positioninfo and return it",
	"Method": "PositionInfo unsafeNextInfo(){\r\n    final String[] strVals = this.parser.next();\r\n    if (strVals.length != 2) {\r\n        throw new PicardException(\"Pos file number of values != 2, found (\" + strVals.length + \")\" + makeExceptionMsg());\r\n    }\r\n    try {\r\n        final float xVal = Float.parseFloat(strVals[0]);\r\n        final float yVal = Float.parseFloat(strVals[1]);\r\n        if (xVal < 0 || yVal < 0) {\r\n            throw new NumberFormatException(\"X and Y pos values cannot be negative!\");\r\n        }\r\n        return new PositionInfo(xVal, yVal, getLane(), getTile());\r\n    } catch (final NumberFormatException nfe) {\r\n        throw new PicardException(\"Bad x or y value in \" + makeExceptionMsg(), nfe);\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.FontLib.getIntermediateFont",
	"Comment": "interpolate between two font instances. font sizes are interpolatedlinearly. if the interpolation fraction is under 0.5, the face andstyle of the starting font are used, otherwise the face and style ofthe second font are applied.",
	"Method": "Font getIntermediateFont(Font f1,Font f2,double frac){\r\n    String name;\r\n    int size, style;\r\n    if (frac < 0.5) {\r\n        name = f1.getName();\r\n        style = f1.getStyle();\r\n    } else {\r\n        name = f2.getName();\r\n        style = f2.getStyle();\r\n    }\r\n    size = (int) Math.round(frac * f2.getSize() + (1 - frac) * f1.getSize());\r\n    return getFont(name, style, size);\r\n}"
}, {
	"Path": "prefuse.data.Table.addConstantColumn",
	"Comment": "add a constant column to this table, which returns one constant valuefor all column rows.",
	"Method": "void addConstantColumn(String name,Class type,Object dflt){\r\n    addColumn(name, ColumnFactory.getConstantColumn(type, dflt));\r\n}"
}, {
	"Path": "com.goodiebag.pinview.Pinview.requestPinEntryFocus",
	"Comment": "requsets focus on current pin view and opens keyboard if forcekeyboard is enabled.",
	"Method": "View requestPinEntryFocus(){\r\n    int currentTag = Math.max(0, getIndexOfCurrentFocus());\r\n    EditText currentEditText = editTextList.get(currentTag);\r\n    if (currentEditText != null) {\r\n        currentEditText.requestFocus();\r\n    }\r\n    openKeyboard();\r\n    return currentEditText;\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.addChild",
	"Comment": "unsupported operation. spanning trees should not be edited.",
	"Method": "int addChild(int parent,Node addChild,Node parent){\r\n    throw new UnsupportedOperationException(\"Changes to tree structure not allowed for spanning trees.\");\r\n}"
}, {
	"Path": "prefuse.Visualization.setValue",
	"Comment": "set a data field value for all items in a given data group matching agiven filter predicate.",
	"Method": "void setValue(String group,Predicate p,String field,Object val){\r\n    Iterator items = items(group, p);\r\n    while (items.hasNext()) {\r\n        VisualItem item = (VisualItem) items.next();\r\n        item.set(field, val);\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.ui.BrowserLauncher.main",
	"Comment": "opens the url specified on the command line in the system browser.",
	"Method": "void main(String[] argv){\r\n    showDocument(argv[0]);\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeProbabilitiesFromSequence.getFractionUnexpectedAlleleObs",
	"Comment": "returns the faction of base observations that were presented that were from an allele other than the two expected ones.",
	"Method": "double getFractionUnexpectedAlleleObs(){\r\n    return obsAlleleOther / (double) (getTotalObs());\r\n}"
}, {
	"Path": "prefuse.data.query.ObjectRangeModel.setValueRange",
	"Comment": "sets the range model to the given objects. the objects areassumed to sorted in ascending order.",
	"Method": "void setValueRange(Object[] objects){\r\n    if (m_objects != null && objects.length == m_objects.length) {\r\n        boolean equal = true;\r\n        for (int i = 0; i < objects.length; ++i) {\r\n            if (objects[i] != m_objects[i]) {\r\n                equal = false;\r\n                break;\r\n            }\r\n        }\r\n        if (equal)\r\n            return;\r\n    }\r\n    m_objects = new Object[objects.length];\r\n    System.arraycopy(objects, 0, m_objects, 0, objects.length);\r\n    if (m_ordinal == null) {\r\n        m_ordinal = new HashMap();\r\n    } else {\r\n        m_ordinal.clear();\r\n    }\r\n    for (int i = 0; i < objects.length; ++i) {\r\n        m_ordinal.put(objects[i], new Integer(i));\r\n    }\r\n    setRangeProperties(0, objects.length - 1, 0, objects.length - 1, false);\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.panels.CwAbsolutePanel.repositionItem",
	"Comment": "reposition an item when the user changes the value in the top or leftposition text boxes.",
	"Method": "void repositionItem(){\r\n    String name = listBox.getValue(listBox.getSelectedIndex());\r\n    Widget item = widgetMap.get(name);\r\n    try {\r\n        int top = Integer.parseInt(topPosBox.getText());\r\n        int left = Integer.parseInt(leftPosBox.getText());\r\n        absolutePanel.setWidgetPosition(item, left, top);\r\n    } catch (NumberFormatException e) {\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.ui.JRangeSlider.getMinimum",
	"Comment": "gets the minimum possible value for either the low value or the high value.",
	"Method": "int getMinimum(){\r\n    return model.getMinimum();\r\n}"
}, {
	"Path": "net.pms.util.StringUtil.encodeXML",
	"Comment": "does basic transformations between characters and their html representation with ampersands.",
	"Method": "String encodeXML(String s){\r\n    s = s.replace(\"&\", \"&amp;\");\r\n    s = s.replace(\"<\", \"&lt;\");\r\n    s = s.replace(\">\", \"&gt;\");\r\n    s = s.replace(\"\\\"\", \"&quot;\");\r\n    s = s.replace(\"'\", \"&apos;\");\r\n    s = s.replace(\"&\", \"&amp;\");\r\n    return s;\r\n}"
}, {
	"Path": "prefuse.data.util.TableIterator.canSetDate",
	"Comment": "check if the setdate method can safely be used for thegiven data field.",
	"Method": "boolean canSetDate(String field){\r\n    return m_table.canSetDate(field);\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.ContactDatabase.addDataDisplay",
	"Comment": "add a display to the database. the current range of interest of the displaywill be populated with data.",
	"Method": "void addDataDisplay(HasData<ContactInfo> display){\r\n    dataProvider.addDataDisplay(display);\r\n}"
}, {
	"Path": "py4j.reflection.MethodInvoker.buildConverters",
	"Comment": "builds a list of converters used to convert the arguments into the parameters.",
	"Method": "int buildConverters(List<TypeConverter> converters,Class<?>[] parameters,Class<?>[] arguments){\r\n    int cost = 0;\r\n    int tempCost = -1;\r\n    int size = arguments.length;\r\n    for (int i = 0; i < size; i++) {\r\n        if (arguments[i] == null) {\r\n            if (parameters[i].isPrimitive()) {\r\n                tempCost = -1;\r\n            } else {\r\n                int distance = TypeUtil.computeDistance(Object.class, parameters[i]);\r\n                tempCost = Math.abs(MAX_DISTANCE - distance);\r\n                converters.add(TypeConverter.NO_CONVERTER);\r\n            }\r\n        } else if (parameters[i].isAssignableFrom(arguments[i])) {\r\n            tempCost = TypeUtil.computeDistance(parameters[i], arguments[i]);\r\n            converters.add(TypeConverter.NO_CONVERTER);\r\n        } else if (TypeUtil.isNumeric(parameters[i]) && TypeUtil.isNumeric(arguments[i])) {\r\n            tempCost = TypeUtil.computeNumericConversion(parameters[i], arguments[i], converters);\r\n        } else if (TypeUtil.isCharacter(parameters[i])) {\r\n            tempCost = TypeUtil.computeCharacterConversion(parameters[i], arguments[i], converters);\r\n        } else if (TypeUtil.isBoolean(parameters[i]) && TypeUtil.isBoolean(arguments[i])) {\r\n            tempCost = 0;\r\n            converters.add(TypeConverter.NO_CONVERTER);\r\n        }\r\n        if (tempCost != -1) {\r\n            cost += tempCost;\r\n            tempCost = -1;\r\n        } else {\r\n            cost = -1;\r\n            break;\r\n        }\r\n    }\r\n    return cost;\r\n}"
}, {
	"Path": "prefuse.data.Graph.setTupleManagers",
	"Comment": "set the tuple managers used to manage the node and edge tuples of thisgraph.",
	"Method": "void setTupleManagers(TupleManager ntm,TupleManager etm){\r\n    if (!Node.class.isAssignableFrom(ntm.getTupleType()))\r\n        throw new IllegalArgumentException(\"The provided node \" + \"TupleManager must generate tuples that implement \" + \"the Node interface.\");\r\n    if (!Edge.class.isAssignableFrom(etm.getTupleType()))\r\n        throw new IllegalArgumentException(\"The provided edge \" + \"TupleManager must generate tuples that implement \" + \"the Edge interface.\");\r\n    m_nodeTuples = ntm;\r\n    m_edgeTuples = etm;\r\n}"
}, {
	"Path": "picard.analysis.CollectWgsMetricsTestUtils.createTestSAM",
	"Comment": "template code for creating a custom sam file for testing. modify to suit your needs.",
	"Method": "void createTestSAM(String testSamName){\r\n    final File testDir = new File(\"testdata/picard/analysis/directed/CollectHsMetrics/\");\r\n    final File reference = new File(\"testdata/picard/quality/chrM.reference.fasta\");\r\n    final String readGroupId = \"TestReadGroup\";\r\n    final String sample = \"TestSample\";\r\n    final String platform = \"Illumina\";\r\n    final String library = \"TestLibrary\";\r\n    final int numReads = 1;\r\n    final int readLength = 10;\r\n    File samFile = File.createTempFile(testSamName, \".bam\", testDir);\r\n    final SAMRecordSetBuilder setBuilder = createTestSAMBuilder(reference, readGroupId, sample, platform, library);\r\n    setBuilder.setReadLength(readLength);\r\n    IntStream.range(0, numReads).forEach(i -> setBuilder.addPair(\"MediocreBaseQ\" + i, 0, 1, 200, false, false, readLength + \"M\", readLength + \"M\", false, true, 40));\r\n    final SAMFileWriter writer = new SAMFileWriterFactory().setCreateIndex(true).makeBAMWriter(setBuilder.getHeader(), false, samFile);\r\n    setBuilder.forEach(writer::addAlignment);\r\n    writer.close();\r\n}"
}, {
	"Path": "picard.analysis.artifacts.CollectSequencingArtifactMetricsTest.runAnalysis",
	"Comment": "run the clp using standard arguments and maybe some additional ones, then compare to the expected results.",
	"Method": "void runAnalysis(String testCase,String extraArgs){\r\n    final File actual = new File(globalTempOutputDir, testCase);\r\n    final File expected = new File(TEST_CASES, testCase);\r\n    final Map<String, String> args = new HashMap<String, String>();\r\n    args.put(\"INPUT\", TEST_SAM.getAbsolutePath());\r\n    args.put(\"OUTPUT\", actual.getAbsolutePath());\r\n    args.put(\"REFERENCE_SEQUENCE\", REFERENCE.getAbsolutePath());\r\n    args.put(\"MINIMUM_INSERT_SIZE\", \"30\");\r\n    args.put(\"MAXIMUM_INSERT_SIZE\", \"30\");\r\n    args.put(\"CONTEXT_SIZE\", \"0\");\r\n    for (final String extraArg : extraArgs) {\r\n        final String[] kv = extraArg.split(\"=\");\r\n        args.put(kv[0], kv[1]);\r\n    }\r\n    runPicardCommandLine(args);\r\n    assertAllFilesEqual(expected, actual);\r\n}"
}, {
	"Path": "prefuse.util.PrefuseLib.getStartField",
	"Comment": "for a given interpolated field name, get the name of the startfield.",
	"Method": "String getStartField(String field){\r\n    return field + \":start\";\r\n}"
}, {
	"Path": "prefuse.data.parser.ParserFactory.setDefaultFactory",
	"Comment": "sets the default parser factory. this factory will be used by defaultby all readers to parse data values.",
	"Method": "void setDefaultFactory(ParserFactory factory){\r\n    DEFAULT_FACTORY = factory;\r\n}"
}, {
	"Path": "picard.util.ClippingUtility.getReadBases",
	"Comment": "returns an array of bytes representing the bases in the read, reverse complementing them if the read is on the negative strand",
	"Method": "byte[] getReadBases(SAMRecord read){\r\n    if (!read.getReadNegativeStrandFlag()) {\r\n        return read.getReadBases();\r\n    } else {\r\n        final byte[] reverseComplementedBases = new byte[read.getReadBases().length];\r\n        System.arraycopy(read.getReadBases(), 0, reverseComplementedBases, 0, reverseComplementedBases.length);\r\n        SequenceUtil.reverseComplement(reverseComplementedBases);\r\n        return reverseComplementedBases;\r\n    }\r\n}"
}, {
	"Path": "net.pms.test.formats.FormatRecognitionTest.testPlaystationImageGifCompatibility",
	"Comment": "test the compatibility of the playstation 3 with the gif format.",
	"Method": "void testPlaystationImageGifCompatibility(){\r\n    assumeTrue(mediaInfoParserIsValid);\r\n    RendererConfiguration conf = RendererConfiguration.getRendererConfigurationByName(\"Playstation 3\");\r\n    assertNotNull(\"Renderer named \\\"Playstation 3\\\" found.\", conf);\r\n    DLNAMediaInfo info = new DLNAMediaInfo();\r\n    info.setContainer(\"gif\");\r\n    Format format = new GIF();\r\n    format.match(\"test.gif\");\r\n    assertEquals(\"PS3 is compatible with GIF\", true, conf.isCompatible(info, format));\r\n}"
}, {
	"Path": "net.pms.util.Version.isGreaterThan",
	"Comment": "returns true if this version is greater than\tthe supplied version, false otherwise",
	"Method": "boolean isGreaterThan(Version other){\r\n    return compareTo(other) > 0;\r\n}"
}, {
	"Path": "quickfix.DataDictionary.isMsgField",
	"Comment": "predicate for determining if a field is valid for a given message type.",
	"Method": "boolean isMsgField(String msgType,int field){\r\n    final Set<Integer> fields = messageFields.get(msgType);\r\n    return fields != null && fields.contains(field);\r\n}"
}, {
	"Path": "picard.metrics.MultiLevelCollector.getAllReadsCollector",
	"Comment": "get the perunitmetriccollector that collects reads for all levels",
	"Method": "PerUnitMetricCollector<METRIC_TYPE, Histogram_KEY, ARGTYPE> getAllReadsCollector(){\r\n    return allReadCollector;\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.setRoot",
	"Comment": "unsupported operation. spanning trees should not be edited.",
	"Method": "void setRoot(Node root){\r\n    throw new UnsupportedOperationException(\"Changes to tree structure not allowed for spanning trees.\");\r\n}"
}, {
	"Path": "com.restfb.DefaultFacebookClient.setFacebookExceptionGenerator",
	"Comment": "override the default facebook exception generator to provide a custom handling for the facebook error objects",
	"Method": "void setFacebookExceptionGenerator(FacebookExceptionGenerator exceptionGenerator){\r\n    graphFacebookExceptionGenerator = exceptionGenerator;\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.canGetFloat",
	"Comment": "indicates if convenience get method can be called withoutan exception being thrown for the float type.",
	"Method": "boolean canGetFloat(){\r\n    return canGet(float.class);\r\n}"
}, {
	"Path": "quickfix.DataDictionary.isRequiredField",
	"Comment": "predicate for determining if a field is required for a message type",
	"Method": "boolean isRequiredField(String msgType,int field){\r\n    final Set<Integer> fields = requiredFields.get(msgType);\r\n    return fields != null && fields.contains(field);\r\n}"
}, {
	"Path": "quickfix.ApplicationFunctionalAdapter.addOnCreateListener",
	"Comment": "add a consumer of sessionid to listen to oncreate operation.",
	"Method": "void addOnCreateListener(Consumer<SessionID> onCreateListener){\r\n    onCreateListeners.add(onCreateListener);\r\n}"
}, {
	"Path": "net.pms.logging.FrameAppender.start",
	"Comment": "checks that the required parameters are set and if everything is in\torder, activates this appender.",
	"Method": "void start(){\r\n    boolean error = true;\r\n    if (this.encoder == null) {\r\n        addStatus(new ErrorStatus(\"No encoder set for the appender named [\" + name + \"].\", this));\r\n    } else {\r\n        try {\r\n            encoder.init(outputStream);\r\n            error = false;\r\n        } catch (IOException ioe) {\r\n            addStatus(new ErrorStatus(\"Failed to initialize encoder for appender named [\" + name + \"].\", this, ioe));\r\n        }\r\n    }\r\n    if (!error) {\r\n        super.start();\r\n    }\r\n}"
}, {
	"Path": "peergos.shared.cbor.CborDecoder.expectIntegerType",
	"Comment": "reads the next major type from the underlying input stream, and verifies whether it matches the given expectation.",
	"Method": "long expectIntegerType(int ib){\r\n    int majorType = ((ib & 0xFF) >>> 5);\r\n    if ((majorType != TYPE_UNSIGNED_INTEGER) && (majorType != TYPE_NEGATIVE_INTEGER)) {\r\n        fail(\"Unexpected type: %s, expected type %s or %s!\", getName(majorType), getName(TYPE_UNSIGNED_INTEGER), getName(TYPE_NEGATIVE_INTEGER));\r\n    }\r\n    return -majorType;\r\n}"
}, {
	"Path": "quickfix.Session.manageGapFill",
	"Comment": "a gap has been request to be filled by either a resend request or on a logon message",
	"Method": "void manageGapFill(Message messageOutSync,int beginSeqNo,int endSeqNo){\r\n    final String beginString = sessionID.getBeginString();\r\n    final int expectedSenderNum = getExpectedSenderNum();\r\n    if (beginString.compareTo(FixVersions.BEGINSTRING_FIX42) >= 0 && endSeqNo == 0 || beginString.compareTo(FixVersions.BEGINSTRING_FIX42) <= 0 && endSeqNo == 999999 || endSeqNo >= expectedSenderNum) {\r\n        endSeqNo = expectedSenderNum - 1;\r\n    }\r\n    if (!persistMessages) {\r\n        endSeqNo += 1;\r\n        final int next = state.getNextSenderMsgSeqNum();\r\n        if (endSeqNo > next) {\r\n            endSeqNo = next;\r\n        }\r\n        generateSequenceReset(messageOutSync, beginSeqNo, endSeqNo);\r\n    } else {\r\n        resendMessages(messageOutSync, beginSeqNo, endSeqNo);\r\n    }\r\n    final int resendRequestMsgSeqNum = messageOutSync.getHeader().getInt(MsgSeqNum.FIELD);\r\n    if (getExpectedTargetNum() == resendRequestMsgSeqNum) {\r\n        state.incrNextTargetMsgSeqNum();\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.StringLib.formatNumber",
	"Comment": "format the given number as a string, including the given number ofdecimal places.",
	"Method": "String formatNumber(double number,int decimalPlaces){\r\n    String s = String.valueOf(number);\r\n    int idx1 = s.indexOf('.');\r\n    if (idx1 == -1) {\r\n        return s;\r\n    } else {\r\n        int idx2 = s.indexOf('E');\r\n        int dp = decimalPlaces + (idx2 >= 0 ? 0 : 1);\r\n        String t = s.substring(0, Math.min(idx1 + dp, s.length()));\r\n        if (idx2 >= 0)\r\n            t += s.substring(idx2);\r\n        return t;\r\n    }\r\n}"
}, {
	"Path": "org.pcollections.tests.IntTreePMapTest.testRandomlyAgainstJavaMap",
	"Comment": "compares the behavior of java.util.hashmap to the behavior of inttreepmap.",
	"Method": "void testRandomlyAgainstJavaMap(){\r\n    PMap<Integer, Integer> pmap = IntTreePMap.empty();\r\n    Map<Integer, Integer> map = new HashMap<Integer, Integer>();\r\n    Random r = new Random();\r\n    for (int i = 0; i < 10000; i++) {\r\n        if (pmap.size() == 0 || r.nextBoolean()) {\r\n            int k = r.nextInt(), v = r.nextInt();\r\n            assertEquals(map.containsKey(k), pmap.containsKey(k));\r\n            assertEquals(map.get(k), pmap.get(k));\r\n            map.put(k, v);\r\n            pmap = pmap.plus(k, v);\r\n        } else {\r\n            int j = r.nextInt(pmap.size());\r\n            for (Entry<Integer, Integer> e : pmap.entrySet()) {\r\n                int k = e.getKey();\r\n                assertTrue(map.containsKey(k));\r\n                assertTrue(pmap.containsKey(k));\r\n                assertEquals(map.get(k), pmap.get(k));\r\n                assertTrue(map.entrySet().contains(e));\r\n                assertTrue(pmap.entrySet().contains(e));\r\n                UtilityTest.assertEqualsAndHash(pmap, pmap.plus(k, e.getValue()));\r\n                if (j-- == 0) {\r\n                    map.remove(k);\r\n                    pmap = pmap.minus(k);\r\n                    assertFalse(pmap.entrySet().contains(e));\r\n                }\r\n            }\r\n        }\r\n        int k = r.nextInt();\r\n        assertEquals(map.containsKey(k), pmap.containsKey(k));\r\n        assertEquals(map.get(k), pmap.get(k));\r\n        map.remove(k);\r\n        pmap = pmap.minus(k);\r\n        String s = Integer.toString(k);\r\n        assertFalse(pmap.containsKey(s));\r\n        assertEquals(null, pmap.get(s));\r\n        assertFalse(pmap.entrySet().contains(s));\r\n        pmap = pmap.minus(s);\r\n        assertEquals(map.size(), pmap.size());\r\n        UtilityTest.assertEqualsAndHash(map, pmap);\r\n        UtilityTest.assertEqualsAndHash(map.entrySet(), pmap.entrySet());\r\n        UtilityTest.assertEqualsAndHash(pmap, IntTreePMap.from(pmap));\r\n        UtilityTest.assertEqualsAndHash(IntTreePMap.empty(), pmap.minusAll(pmap.keySet()));\r\n        UtilityTest.assertEqualsAndHash(pmap, pmap.plusAll(pmap));\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.Graph.getSpanningTree",
	"Comment": "returns a spanning tree rooted at the specified node. if the currentspanning tree is already rooted at the given node, it is simplyreturned. otherwise, the tree is reconstructed at the new root andmade the current spanning tree for this graph instance.spanning trees are generated using an unweighted breadth first searchover the graph structure.",
	"Method": "Tree getSpanningTree(Tree getSpanningTree,Node root){\r\n    nodeCheck(root, true);\r\n    if (m_spanning == null) {\r\n        m_spanning = new SpanningTree(this, root);\r\n    } else if (m_spanning.getRoot() != root) {\r\n        m_spanning.buildSpanningTree(root);\r\n    }\r\n    return m_spanning;\r\n}"
}, {
	"Path": "prefuse.render.EdgeRenderer.setVerticalAlignment2",
	"Comment": "set the vertical aligment of the edge mount point with the second node.",
	"Method": "void setVerticalAlignment2(int align){\r\n    m_yAlign2 = align;\r\n}"
}, {
	"Path": "quickfix.DataDictionary.isAdminMessage",
	"Comment": "predicate for determining if a message is in the admin category.",
	"Method": "boolean isAdminMessage(String msgType){\r\n    return MESSAGE_CATEGORY_ADMIN.equals(messageCategory.get(msgType));\r\n}"
}, {
	"Path": "prefuse.render.EdgeRenderer.setVerticalAlignment1",
	"Comment": "set the vertical aligment of the edge mount point with the first node.",
	"Method": "void setVerticalAlignment1(int align){\r\n    m_yAlign1 = align;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setMencoderFontConfig",
	"Comment": "sets whether or not mencoder should use fontconfig for displaying\tsubtitles.",
	"Method": "void setMencoderFontConfig(boolean value){\r\n    configuration.setProperty(KEY_MENCODER_FONT_CONFIG, value);\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeProbabilities.getMostLikelyGenotype",
	"Comment": "gets the genotype for this snp given the most likely haplotype.",
	"Method": "DiploidGenotype getMostLikelyGenotype(Snp snp){\r\n    assertSnpPartOfHaplotype(snp);\r\n    return snp.getGenotype(getMostLikelyHaplotype());\r\n}"
}, {
	"Path": "prefuse.Display.checkItemBoundsChanged",
	"Comment": "check if the item bounds has changed, and if so, fire a notification.",
	"Method": "void checkItemBoundsChanged(Rectangle2D prev){\r\n    if (m_bounds.equals(prev))\r\n        return;\r\n    if (m_bounders != null && m_bounders.size() > 0) {\r\n        Object[] lstnrs = m_bounders.getArray();\r\n        for (int i = 0; i < lstnrs.length; ++i) {\r\n            try {\r\n                ((ItemBoundsListener) lstnrs[i]).itemBoundsChanged(this);\r\n            } catch (Exception e) {\r\n                s_logger.warning(\"Exception thrown by ItemBoundsListener: \" + e + \"\\n\" + StringLib.getStackTrace(e));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "py4j.GatewayServer.turnLoggingOn",
	"Comment": "utility method to turn logging on. logging is turned off by default. log\tmessages up to info level will be logged.",
	"Method": "void turnLoggingOn(){\r\n    PY4J_LOGGER.setLevel(Level.INFO);\r\n}"
}, {
	"Path": "com.goodiebag.pinview.Pinview.generateOneEditText",
	"Comment": "takes care of styling the edittext passed in the param.tag is the index of the edittext.",
	"Method": "void generateOneEditText(EditText styleEditText,String tag){\r\n    params.setMargins(mSplitWidth / 2, mSplitWidth / 2, mSplitWidth / 2, mSplitWidth / 2);\r\n    filters[0] = new InputFilter.LengthFilter(1);\r\n    styleEditText.setFilters(filters);\r\n    styleEditText.setLayoutParams(params);\r\n    styleEditText.setGravity(Gravity.CENTER);\r\n    styleEditText.setCursorVisible(mCursorVisible);\r\n    if (!mCursorVisible) {\r\n        styleEditText.setClickable(false);\r\n        styleEditText.setHint(mHint);\r\n        styleEditText.setOnTouchListener(new OnTouchListener() {\r\n            @Override\r\n            public boolean onTouch(View view, MotionEvent motionEvent) {\r\n                mDelPressed = false;\r\n                return false;\r\n            }\r\n        });\r\n    }\r\n    styleEditText.setBackgroundResource(mPinBackground);\r\n    styleEditText.setPadding(0, 0, 0, 0);\r\n    styleEditText.setTag(tag);\r\n    styleEditText.setInputType(getKeyboardInputType());\r\n    styleEditText.addTextChangedListener(this);\r\n    styleEditText.setOnFocusChangeListener(this);\r\n    styleEditText.setOnKeyListener(this);\r\n}"
}, {
	"Path": "com.goodiebag.pinview.Pinview.generateOneEditText",
	"Comment": "takes care of styling the edittext passed in the param.tag is the index of the edittext.",
	"Method": "void generateOneEditText(EditText styleEditText,String tag){\r\n    mDelPressed = false;\r\n    return false;\r\n}"
}, {
	"Path": "io.github.benas.randombeans.EnhancedRandomBuilder.maxObjectPoolSize",
	"Comment": "set the maximum number of different objects to generate for a type.",
	"Method": "EnhancedRandomBuilder maxObjectPoolSize(int maxObjectPoolSize){\r\n    parameters.setObjectPoolSize(maxObjectPoolSize);\r\n    return this;\r\n}"
}, {
	"Path": "prefuse.util.ui.JValueSlider.getSliderValue",
	"Comment": "compute the current slider value from the current slider position",
	"Method": "Number getSliderValue(){\r\n    if (m_value instanceof Integer) {\r\n        int val = m_slider.getValue();\r\n        int min = m_min.intValue();\r\n        int max = m_max.intValue();\r\n        return new Integer(min + (val - m_smin) * (max - min) / m_srange);\r\n    } else if (m_value instanceof Long) {\r\n        int val = m_slider.getValue();\r\n        long min = m_min.longValue();\r\n        long max = m_max.longValue();\r\n        return new Long(min + (val - m_smin) * (max - min) / m_srange);\r\n    } else {\r\n        double f = (m_slider.getValue() - m_smin) / (double) m_srange;\r\n        double min = m_min.doubleValue();\r\n        double max = m_max.doubleValue();\r\n        double val = min + f * (max - min);\r\n        return (m_value instanceof Double ? (Number) new Double(val) : new Float((float) val));\r\n    }\r\n}"
}, {
	"Path": "org.quickfixj.codegenerator.GenerateMojo.setDictFile",
	"Comment": "sets the dictionary file for which code generation should be executed.",
	"Method": "void setDictFile(File dictFile){\r\n    this.dictFile = dictFile;\r\n}"
}, {
	"Path": "prefuse.data.Graph.removeNode",
	"Comment": "remove a node from the graph, also removing all incident edges.",
	"Method": "boolean removeNode(int node,boolean removeNode,Node n){\r\n    nodeCheck(n, true);\r\n    return removeNode(n.getRow());\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.isMencoderYadif",
	"Comment": "returns true if mencoder should use the deinterlace filter, false\totherwise.",
	"Method": "boolean isMencoderYadif(){\r\n    return getBoolean(KEY_MENCODER_YADIF, false);\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAMediaAudio.isWMA",
	"Comment": "returns true if this media uses the wma audio codec, false otherwise.",
	"Method": "boolean isWMA(){\r\n    return getCodecA() != null && getCodecA().startsWith(\"wm\");\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeMap.writeToFile",
	"Comment": "writes out a haplotypemap file with the contents of this map.",
	"Method": "void writeToFile(File file){\r\n    try {\r\n        final BufferedWriter out = new BufferedWriter(new OutputStreamWriter(IOUtil.openFileForWriting(file)));\r\n        final FormatUtil format = new FormatUtil();\r\n        if (this.header != null) {\r\n            final SAMTextHeaderCodec codec = new SAMTextHeaderCodec();\r\n            codec.encode(out, this.header);\r\n        }\r\n        out.write(\"#CHROMOSOME\\tPOSITION\\tNAME\\tMAJOR_ALLELE\\tMINOR_ALLELE\\tMAF\\tANCHOR_SNP\\tPANELS\");\r\n        out.newLine();\r\n        final List<HaplotypeMapFileEntry> entries = new ArrayList();\r\n        for (final HaplotypeBlock block : this.getHaplotypes()) {\r\n            String anchor = null;\r\n            final SortedSet<Snp> snps = new TreeSet(block.getSnps());\r\n            for (final Snp snp : snps) {\r\n                entries.add(new HaplotypeMapFileEntry(snp.getChrom(), snp.getPos(), snp.getName(), snp.getAllele1(), snp.getAllele2(), snp.getMaf(), anchor, snp.getFingerprintPanels()));\r\n                if (anchor == null) {\r\n                    anchor = snp.getName();\r\n                }\r\n            }\r\n        }\r\n        Collections.sort(entries);\r\n        for (final HaplotypeMapFileEntry entry : entries) {\r\n            out.write(entry.chromosome + \"\\t\");\r\n            out.write(format.format(entry.position) + \"\\t\");\r\n            out.write(entry.snpName + \"\\t\");\r\n            out.write((char) entry.majorAllele + \"\\t\");\r\n            out.write((char) entry.minorAllele + \"\\t\");\r\n            out.write(format.format(entry.minorAlleleFrequency) + \"\\t\");\r\n            if (entry.anchorSnp != null) {\r\n                out.write(entry.anchorSnp);\r\n            }\r\n            out.write(\"\\t\");\r\n            if (entry.getPanels() != null) {\r\n                out.write(entry.getPanels());\r\n            }\r\n            out.newLine();\r\n        }\r\n        out.flush();\r\n        out.close();\r\n    } catch (IOException ioe) {\r\n        throw new PicardException(\"Error writing out haplotype map to file: \" + file.getAbsolutePath(), ioe);\r\n    }\r\n}"
}, {
	"Path": "com.google.gwt.sample.core.linker.SimpleAppCacheLinker.otherCachedFiles",
	"Comment": "override this method to force the linker to also include more filesin the manifest.",
	"Method": "String[] otherCachedFiles(){\r\n    return null;\r\n}"
}, {
	"Path": "picard.util.LiftOverIntervalList.doWork",
	"Comment": "do the work after command line has been parsed. runtimeexception may bethrown by this method, and are reported appropriately.",
	"Method": "int doWork(){\r\n    IOUtil.assertFileIsReadable(INPUT);\r\n    IOUtil.assertFileIsReadable(SEQUENCE_DICTIONARY);\r\n    IOUtil.assertFileIsReadable(CHAIN);\r\n    IOUtil.assertFileIsWritable(OUTPUT);\r\n    if (REJECT != null)\r\n        IOUtil.assertFileIsWritable(REJECT);\r\n    final LiftOver liftOver = new LiftOver(CHAIN);\r\n    liftOver.setLiftOverMinMatch(MIN_LIFTOVER_PCT);\r\n    final IntervalList intervalList = IntervalList.fromFile(INPUT);\r\n    final IntervalList rejects = new IntervalList(intervalList.getHeader());\r\n    final long baseCount = intervalList.getBaseCount();\r\n    LOG.info(\"Lifting over \" + intervalList.getIntervals().size() + \" intervals, encompassing \" + baseCount + \" bases.\");\r\n    final SAMFileHeader toHeader = SamReaderFactory.makeDefault().getFileHeader(SEQUENCE_DICTIONARY);\r\n    liftOver.validateToSequences(toHeader.getSequenceDictionary());\r\n    final IntervalList toIntervals = new IntervalList(toHeader);\r\n    for (final Interval fromInterval : intervalList) {\r\n        final Interval toInterval = liftOver.liftOver(fromInterval);\r\n        if (toInterval != null) {\r\n            toIntervals.add(toInterval);\r\n        } else {\r\n            rejects.add(fromInterval);\r\n            LOG.warn(\"Liftover failed for \", fromInterval, \" (len \", fromInterval.length(), \")\");\r\n            final List<LiftOver.PartialLiftover> partials = liftOver.diagnosticLiftover(fromInterval);\r\n            for (final LiftOver.PartialLiftover partial : partials) {\r\n                LOG.info(partial);\r\n            }\r\n        }\r\n    }\r\n    toIntervals.sorted().write(OUTPUT);\r\n    if (REJECT != null) {\r\n        rejects.write(REJECT);\r\n    }\r\n    final long rejectBaseCount = rejects.getBaseCount();\r\n    LOG.info(String.format(\"Liftover Complete. \\n\" + \"%d of %d intervals failed (%g%%) to liftover, encompassing %d of %d bases (%g%%).\", rejects.getIntervals().size(), intervalList.getIntervals().size(), 100 * rejects.getIntervals().size() / (double) intervalList.getIntervals().size(), rejectBaseCount, baseCount, 100 * rejectBaseCount / (double) baseCount));\r\n    return rejects.getIntervals().isEmpty() ? 0 : 1;\r\n}"
}, {
	"Path": "picard.sam.RevertSam.customCommandLineValidation",
	"Comment": "enforce that output ordering is queryname when sanitization is turned on since it requires a queryname sort.",
	"Method": "String[] customCommandLineValidation(){\r\n    final List<String> errors = new ArrayList();\r\n    ValidationUtil.validateSanitizeSortOrder(SANITIZE, SORT_ORDER, errors);\r\n    ValidationUtil.validateOutputParams(OUTPUT_BY_READGROUP, OUTPUT, OUTPUT_MAP, errors);\r\n    if (!SANITIZE && KEEP_FIRST_DUPLICATE)\r\n        errors.add(\"KEEP_FIRST_DUPLICATE cannot be used without SANITIZE\");\r\n    if (!errors.isEmpty()) {\r\n        return errors.toArray(new String[errors.size()]);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.pms.newgui.RestrictedFileSystemView.createFileObject",
	"Comment": "returns a file object constructed from the given path string.",
	"Method": "File createFileObject(File dir,String filename,File createFileObject,String path){\r\n    File f = new File(path);\r\n    if (isFileSystemRoot(f)) {\r\n        f = createFileSystemRoot(f);\r\n    }\r\n    return f;\r\n}"
}, {
	"Path": "prefuse.data.search.KeywordSearchTupleSet.search",
	"Comment": "searches the indexed tuple fields for matching keywords, usingthe lucene search engine. matching tuples are available as themembers of this tupleset.",
	"Method": "void search(String query){\r\n    if (query == null)\r\n        query = \"\";\r\n    query = query.trim();\r\n    if (query.equals(m_query))\r\n        return;\r\n    Tuple[] rem = clearInternal();\r\n    m_query = query;\r\n    if (query.length() == 0) {\r\n        this.fireTupleEvent(null, DELETE);\r\n        return;\r\n    }\r\n    m_lucene.setReadMode(true);\r\n    try {\r\n        Hits hits = m_lucene.search(query);\r\n        for (int i = 0; i < hits.length(); i++) {\r\n            Tuple t = getMatchingTuple(hits.doc(i));\r\n            addInternal(t);\r\n        }\r\n        Tuple[] add = getTupleCount() > 0 ? toArray() : null;\r\n        fireTupleEvent(add, rem);\r\n    } catch (ParseException e) {\r\n        s_logger.warning(\"Lucene query parse exception.\\n\" + StringLib.getStackTrace(e));\r\n    } catch (IOException e) {\r\n        s_logger.warning(\"Lucene IO exception.\\n\" + StringLib.getStackTrace(e));\r\n    }\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.isThumbnailGenerationEnabled",
	"Comment": "returns true if thumbnail generation is enabled, false otherwise.",
	"Method": "boolean isThumbnailGenerationEnabled(){\r\n    return getBoolean(KEY_THUMBNAIL_GENERATION_ENABLED, true);\r\n}"
}, {
	"Path": "prefuse.util.force.ForceSimulator.clear",
	"Comment": "clear this simulator, removing all forceitem and spring instancesfor the simulator.",
	"Method": "void clear(){\r\n    items.clear();\r\n    Iterator siter = springs.iterator();\r\n    Spring.SpringFactory f = Spring.getFactory();\r\n    while (siter.hasNext()) f.reclaim((Spring) siter.next());\r\n    springs.clear();\r\n}"
}, {
	"Path": "prefuse.render.LabelRenderer.getVerticalAlignment",
	"Comment": "get the vertical alignment of this node with respect to itsx, y coordinates.",
	"Method": "int getVerticalAlignment(){\r\n    return m_yAlign;\r\n}"
}, {
	"Path": "prefuse.action.assignment.DataSizeAction.getScale",
	"Comment": "returns the scale type used for encoding size values from the data.",
	"Method": "int getScale(){\r\n    return m_scale;\r\n}"
}, {
	"Path": "com.restfb.DefaultWebRequestor.setAutocloseBinaryAttachmentStream",
	"Comment": "define if the binary attachment stream is closed automatically after sending the content to facebook",
	"Method": "void setAutocloseBinaryAttachmentStream(boolean autocloseBinaryAttachmentStream){\r\n    this.autocloseBinaryAttachmentStream = autocloseBinaryAttachmentStream;\r\n}"
}, {
	"Path": "quickfix.FieldMap.getGroupCount",
	"Comment": "returns the number of groups associated with the specified count tag.",
	"Method": "int getGroupCount(int tag){\r\n    return getGroups(tag).size();\r\n}"
}, {
	"Path": "prefuse.data.column.ExpressionColumn.isCacheValid",
	"Comment": "check if this expressioncolumn has a valid cached value at the givenrow.",
	"Method": "boolean isCacheValid(int row){\r\n    return m_valid.get(row);\r\n}"
}, {
	"Path": "prefuse.data.expression.CompositePredicate.getSubPredicate",
	"Comment": "get a predicate instance just like this one but withoutthe given predicate as a clause.",
	"Method": "Predicate getSubPredicate(Predicate p){\r\n    CompositePredicate cp = null;\r\n    try {\r\n        cp = (CompositePredicate) this.getClass().newInstance();\r\n    } catch (InstantiationException e) {\r\n    } catch (IllegalAccessException e) {\r\n    }\r\n    for (int i = 0; i < m_clauses.size(); ++i) {\r\n        Predicate pp = (Predicate) m_clauses.get(i);\r\n        if (p != pp) {\r\n            cp.add(pp);\r\n        }\r\n    }\r\n    return cp;\r\n}"
}, {
	"Path": "prefuse.data.query.ListQueryBinding.getListModel",
	"Comment": "returns a list model for creating custom dynamic query widgets.this list model acts both as a data model and a selection model,and so must be registered as both with any custom widgets.",
	"Method": "ListModel getListModel(){\r\n    return m_model;\r\n}"
}, {
	"Path": "prefuse.data.util.FilteredRowManager.remove",
	"Comment": "remove a mapping between the given managed row and the correspondingparent row.",
	"Method": "void remove(int childRow){\r\n    int parentRow = m_childToParent.getInt(childRow);\r\n    m_childToParent.setInt(-1, childRow);\r\n    m_parentToChild.remove(parentRow);\r\n}"
}, {
	"Path": "picard.vcf.GenotypeConcordanceCounts.getSensitivity",
	"Comment": "returns the sensitivity defined by the scheme across the subset of truth states.",
	"Method": "double getSensitivity(GenotypeConcordanceScheme scheme,TruthState[] truthStateArray){\r\n    double numerator = 0.0;\r\n    double denominator = 0.0;\r\n    scheme.validateScheme();\r\n    for (final TruthState truthState : truthStateArray) {\r\n        for (final CallState callState : CallState.values()) {\r\n            final TruthAndCallStates truthAndCallStates = new TruthAndCallStates(truthState, callState);\r\n            final long count = getCount(truthAndCallStates);\r\n            for (final ContingencyState contingencyState : scheme.getConcordanceStateArray(truthAndCallStates)) {\r\n                if (ContingencyState.TP == contingencyState) {\r\n                    numerator += count;\r\n                    denominator += count;\r\n                } else if (ContingencyState.FN == contingencyState) {\r\n                    denominator += count;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return (numerator / denominator);\r\n}"
}, {
	"Path": "prefuse.data.Graph.initLinkTable",
	"Comment": "initialize the link table, which holds adjacency lists for this graph.",
	"Method": "void initLinkTable(){\r\n    m_links = createLinkTable();\r\n    IntIterator edges = getEdgeTable().rows();\r\n    while (edges.hasNext()) {\r\n        updateDegrees(edges.nextInt(), 1);\r\n    }\r\n}"
}, {
	"Path": "py4j.reflection.ReflectionEngine.getPublicStaticNames",
	"Comment": "retrieve the names of all the public static fields, methods and\tclasses in the clazz",
	"Method": "String[] getPublicStaticNames(Class<?> clazz){\r\n    Set<String> names = new HashSet<String>();\r\n    names.addAll(Arrays.asList(getPublicStaticClassNames(clazz)));\r\n    names.addAll(Arrays.asList(getPublicStaticFieldNames(clazz)));\r\n    names.addAll(Arrays.asList(getPublicStaticMethodNames(clazz)));\r\n    return (String[]) names.toArray(new String[names.size()]);\r\n}"
}, {
	"Path": "prefuse.data.search.KeywordSearchTupleSet.getTupleMap",
	"Comment": "returns a copy of the mapping from lucene document ids to prefuse tuple instances.",
	"Method": "IntObjectHashMap getTupleMap(){\r\n    return (IntObjectHashMap) m_map.clone();\r\n}"
}, {
	"Path": "prefuse.data.column.ColumnMetadata.getSum",
	"Comment": "get the sum of numeric values in the column. if this columndoes not contain numeric values, this method will result in anexception being thrown.",
	"Method": "double getSum(){\r\n    accessCheck();\r\n    if (m_sum == null && m_dynamic) {\r\n        m_sum = new Double(DataLib.sum(m_table.tuples(), m_field));\r\n    }\r\n    return m_sum.doubleValue();\r\n}"
}, {
	"Path": "java.io.Writer.checkError",
	"Comment": "returns true if this writer has encountered and suppressed an error. used by printwriters as an alternative to checked\texceptions.",
	"Method": "boolean checkError(){\r\n    return false;\r\n}"
}, {
	"Path": "peergos.shared.merklebtree.TreeNode.print",
	"Comment": "print a representation of this btree to the print stream. this method is synchronous.",
	"Method": "void print(PrintStream w,int depth,ContentAddressedStorage storage){\r\n    int index = 0;\r\n    for (KeyElement e : keys) {\r\n        String tab = \"\";\r\n        for (int i = 0; i < depth; i++) tab += \"   \";\r\n        w.print(StringUtils.format(tab + \"[%d/%d] %s : %s\\n\", index++, keys.size(), e.key.toString(), new ByteArrayWrapper(e.valueHash.serialize()).toString()));\r\n        if (e.targetHash.isPresent())\r\n            TreeNode.fromCbor(storage.get(e.targetHash.get()).get().get()).print(w, depth + 1, storage);\r\n    }\r\n}"
}, {
	"Path": "picard.illumina.IlluminaBasecallsConverter.getDataTypesFromReadStructure",
	"Comment": "given a read structure return the data types that need to be parsed for this run",
	"Method": "IlluminaDataType[] getDataTypesFromReadStructure(ReadStructure readStructure,boolean demultiplex){\r\n    if (readStructure.sampleBarcodes.isEmpty() || !demultiplex) {\r\n        return DATA_TYPES_NO_BARCODE;\r\n    } else {\r\n        return DATA_TYPES_WITH_BARCODE;\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.getColumnType",
	"Comment": "returns the most specific superclass for the values in the column",
	"Method": "Class getColumnType(){\r\n    return m_columnType;\r\n}"
}, {
	"Path": "quickfix.field.converter.UtcTimestampConverter.convertToLocalDateTime",
	"Comment": "convert a timestamp string into a localdatetime object.localdatetime has up to nanosecond precision.",
	"Method": "LocalDateTime convertToLocalDateTime(String value){\r\n    verifyFormat(value);\r\n    int length = value.length();\r\n    try {\r\n        switch(length) {\r\n            case LENGTH_INCL_SECONDS:\r\n                return LocalDateTime.parse(value, FORMATTER_SECONDS);\r\n            case LENGTH_INCL_MILLIS:\r\n                return LocalDateTime.parse(value, FORMATTER_MILLIS);\r\n            case LENGTH_INCL_MICROS:\r\n                return LocalDateTime.parse(value, FORMATTER_MICROS);\r\n            case LENGTH_INCL_NANOS:\r\n            case LENGTH_INCL_PICOS:\r\n                return LocalDateTime.parse(value.substring(0, LENGTH_INCL_NANOS), FORMATTER_NANOS);\r\n            default:\r\n                throwFieldConvertError(value, TYPE);\r\n        }\r\n    } catch (DateTimeParseException e) {\r\n        throwFieldConvertError(value, TYPE);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.pms.util.KeyedComboBoxModel.setData",
	"Comment": "replaces the data in this combobox model. the number of keys must be\tequals to the number of values.",
	"Method": "void setData(Object[] keys,Object[] values){\r\n    if (values.length != keys.length) {\r\n        throw new IllegalArgumentException(\"Values and text must have the same length.\");\r\n    }\r\n    data.clear();\r\n    data.ensureCapacity(keys.length);\r\n    for (int i = 0; i < values.length; i++) {\r\n        add(keys[i], values[i]);\r\n    }\r\n    selectedItemIndex = -1;\r\n    final ListDataEvent evt = new ListDataEvent(this, ListDataEvent.CONTENTS_CHANGED, 0, data.size() - 1);\r\n    fireListDataEvent(evt);\r\n}"
}, {
	"Path": "peergos.shared.util.EfficientHashMap.valueEquals",
	"Comment": "returns whether two values are equal for the purposes of this set.",
	"Method": "boolean valueEquals(Object a,Object b){\r\n    return (a == null) ? (b == null) : a.equals(b);\r\n}"
}, {
	"Path": "py4j.CallbackClient.sendCommand",
	"Comment": "sends a command to the python side. this method is typically used by\tpython proxies to call python methods or to request the garbage\tcollection of a proxy.",
	"Method": "String sendCommand(String command,String sendCommand,String command,boolean blocking){\r\n    String returnCommand = null;\r\n    Py4JClientConnection cc = getConnectionLock();\r\n    if (cc == null) {\r\n        throw new Py4JException(\"Cannot obtain a new communication channel\");\r\n    }\r\n    try {\r\n        returnCommand = cc.sendCommand(command, blocking);\r\n    } catch (Py4JNetworkException pe) {\r\n        logger.log(Level.WARNING, \"Error while sending a command\", pe);\r\n        boolean reset = false;\r\n        if (pe.getCause() instanceof SocketTimeoutException) {\r\n            reset = true;\r\n        }\r\n        cc.shutdown(reset);\r\n        if (shouldRetrySendCommand(cc, pe)) {\r\n            returnCommand = sendCommand(command, blocking);\r\n        } else {\r\n            logger.log(Level.SEVERE, \"Error while sending a command.\", pe);\r\n            throw new Py4JException(\"Error while sending a command.\", pe);\r\n        }\r\n    } catch (Exception e) {\r\n        logger.log(Level.SEVERE, \"Critical error while sending a command\", e);\r\n        cc.shutdown();\r\n        throw new Py4JException(\"Error while sending a command.\");\r\n    }\r\n    try {\r\n        giveBackConnection(cc);\r\n    } catch (Exception e) {\r\n        logger.log(Level.SEVERE, \"Critical error while giving back connection.\", e);\r\n        throw new Py4JException(\"Error while giving back connection.\");\r\n    }\r\n    return returnCommand;\r\n}"
}, {
	"Path": "net.pms.configuration.RendererConfiguration.getRendererConfigurationByName",
	"Comment": "tries to find a matching renderer configuration based on the name of\tthe renderer. returns true if the provided name is equal to or a\tsubstring of the renderer name defined in a configuration, where case\tdoes not matter.",
	"Method": "RendererConfiguration getRendererConfigurationByName(String name){\r\n    for (RendererConfiguration conf : rendererConfs) {\r\n        if (conf.getRendererName().toLowerCase().contains(name.toLowerCase())) {\r\n            return conf;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "picard.illumina.parser.IlluminaDataProvider.seekToTile",
	"Comment": "jump so that the next record returned will be from the specified tile.",
	"Method": "void seekToTile(int oneBasedTileNumber){\r\n    for (final IlluminaParser parser : parsers) {\r\n        parser.seekToTile(oneBasedTileNumber);\r\n    }\r\n}"
}, {
	"Path": "com.restfb.types.User.getIdsForPages",
	"Comment": "businesses can claim ownership of apps and pages using business manager.this edge returns the list of ids that this user has in any of the pages owned by this business.",
	"Method": "List<UserIDForPage> getIdsForPages(){\r\n    return unmodifiableList(idsForPages);\r\n}"
}, {
	"Path": "net.paoding.rose.util.Base64.decodeFromString",
	"Comment": "decodes data from base64 notation. uses the platform default\tcharacter set to obtain bytes from given string.",
	"Method": "byte[] decodeFromString(String s){\r\n    return decode(s.getBytes());\r\n}"
}, {
	"Path": "picard.vcf.filter.TestFilterVcf.testFiltering",
	"Comment": "utility method that takes a a vcf and a set of parameters and filters the vcf.",
	"Method": "File testFiltering(File vcf,String outputExtension,double minAb,int minDp,int minGq,double maxFs){\r\n    final File out = VcfTestUtils.createTemporaryIndexedFile(\"filterVcfTest.\", outputExtension);\r\n    final FilterVcf filterer = new FilterVcf();\r\n    filterer.CREATE_INDEX = true;\r\n    filterer.INPUT = vcf;\r\n    filterer.OUTPUT = out;\r\n    filterer.MIN_AB = minAb;\r\n    filterer.MIN_DP = minDp;\r\n    filterer.MIN_GQ = minGq;\r\n    filterer.MAX_FS = maxFs;\r\n    final int retval = filterer.doWork();\r\n    if (retval != 0) {\r\n        throw new PicardException(\"Return value non-zero: \" + retval);\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "picard.illumina.IlluminaBasecallsToSam.buildSamFileWriter",
	"Comment": "build a samfilewriter that will write its contents to the output file.",
	"Method": "SAMFileWriterWrapper buildSamFileWriter(File output,String sampleAlias,String libraryName,Map<String, String> headerParameters,boolean presorted){\r\n    IOUtil.assertFileIsWritable(output);\r\n    final SAMReadGroupRecord rg = new SAMReadGroupRecord(READ_GROUP_ID);\r\n    rg.setSample(sampleAlias);\r\n    if (libraryName != null)\r\n        rg.setLibrary(libraryName);\r\n    for (final Map.Entry<String, String> tagNameToValue : headerParameters.entrySet()) {\r\n        if (tagNameToValue.getValue() != null) {\r\n            rg.setAttribute(tagNameToValue.getKey(), tagNameToValue.getValue());\r\n        }\r\n    }\r\n    final SAMFileHeader header = new SAMFileHeader();\r\n    header.setSortOrder(SAMFileHeader.SortOrder.queryname);\r\n    header.addReadGroup(rg);\r\n    return new SAMFileWriterWrapper(new SAMFileWriterFactory().makeSAMOrBAMWriter(header, presorted, output));\r\n}"
}, {
	"Path": "prefuse.render.LabelRenderer.getHorizontalAlignment",
	"Comment": "get the horizontal alignment of this node with respect to itsx, y coordinates.",
	"Method": "int getHorizontalAlignment(){\r\n    return m_xAlign;\r\n}"
}, {
	"Path": "picard.sam.markduplicates.util.OpticalDuplicateFinder.keeperOrNull",
	"Comment": "returns the keeper if it is contained within the list and has location information, otherwise null.",
	"Method": "PhysicalLocation keeperOrNull(List<? extends PhysicalLocation> list,PhysicalLocation keeper){\r\n    if (keeper != null && keeper.hasLocation()) {\r\n        for (final PhysicalLocation loc : list) {\r\n            if (loc == keeper)\r\n                return keeper;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "prefuse.action.filter.GraphDistanceFilter.reset",
	"Comment": "clears references to graph tuples.the group and visualization areretained.",
	"Method": "void reset(){\r\n    m_bfs = new BreadthFirstIterator();\r\n}"
}, {
	"Path": "picard.filter.CountingFilter.getFilteredRecords",
	"Comment": "gets the number of records that have been filtered out thus far.",
	"Method": "long getFilteredRecords(){\r\n    return this.filteredRecords;\r\n}"
}, {
	"Path": "prefuse.util.GraphLib.getClique",
	"Comment": "returns a clique of given size. a clique is a graph in which every nodeis a neighbor of every other node.",
	"Method": "Graph getClique(int n){\r\n    Graph g = new Graph();\r\n    g.getNodeTable().addColumns(LABEL_SCHEMA);\r\n    Node[] nodes = new Node[n];\r\n    for (int i = 0; i < n; ++i) {\r\n        nodes[i] = g.addNode();\r\n        nodes[i].setString(LABEL, String.valueOf(i));\r\n    }\r\n    for (int i = 0; i < n; ++i) {\r\n        for (int j = i; j < n; ++j) if (i != j)\r\n            g.addEdge(nodes[i], nodes[j]);\r\n    }\r\n    return g;\r\n}"
}, {
	"Path": "net.pms.configuration.LinuxDefaultPaths.getBinariesSearchPath",
	"Comment": "returns the path where binaries can be found. this path differs between\tthe build phase and the test phase. the path will end with a slash unless\tit is empty.",
	"Method": "String getBinariesSearchPath(){\r\n    String path = PropertiesUtil.getProjectProperties().get(\"project.binaries.dir\");\r\n    if (isNotBlank(path)) {\r\n        if (path.endsWith(\"/\")) {\r\n            return path;\r\n        } else {\r\n            return path + \"/\";\r\n        }\r\n    } else {\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "com.restfb.json.JsonObject.merge",
	"Comment": "copies all members of the specified object into this object. when the specified object contains members with namesthat also exist in this object, the existing values in this object will be replaced by the corresponding values inthe specified object.",
	"Method": "JsonObject merge(JsonObject object){\r\n    if (object == null) {\r\n        throw new NullPointerException(\"object is null\");\r\n    }\r\n    for (Member member : object) {\r\n        this.set(member.name, member.value);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.canGet",
	"Comment": "indicates if the get method can be called withoutan exception being thrown for the given type.",
	"Method": "boolean canGet(Class type){\r\n    if (type == null)\r\n        return false;\r\n    if (m_columnType.isPrimitive()) {\r\n        boolean primTypes = type.isAssignableFrom(m_columnType) || (TypeLib.isNumericType(m_columnType) && TypeLib.isNumericType(type));\r\n        return primTypes || type.isAssignableFrom(TypeLib.getWrapperType(m_columnType)) || type.isAssignableFrom(String.class);\r\n    } else {\r\n        return type.isAssignableFrom(m_columnType);\r\n    }\r\n}"
}, {
	"Path": "net.pms.util.KeyedComboBoxModel.setSelectedItem",
	"Comment": "set the selected item. the implementation of thismethod should notify\tall registered listdatalisteners that the contents have\tchanged.",
	"Method": "void setSelectedItem(Object anItem){\r\n    if (anItem == null) {\r\n        selectedItemIndex = -1;\r\n        selectedItemValue = null;\r\n    } else {\r\n        final int newSelectedItem = findElementIndex(anItem);\r\n        if (newSelectedItem == -1) {\r\n            if (isAllowOtherValue()) {\r\n                selectedItemIndex = -1;\r\n                selectedItemValue = anItem;\r\n            } else {\r\n                selectedItemIndex = -1;\r\n                selectedItemValue = null;\r\n            }\r\n        } else {\r\n            selectedItemIndex = newSelectedItem;\r\n            selectedItemValue = getElementAt(selectedItemIndex);\r\n        }\r\n    }\r\n    fireListDataEvent(new ListDataEvent(this, ListDataEvent.CONTENTS_CHANGED, -1, -1));\r\n}"
}, {
	"Path": "picard.analysis.CounterManager.newCounter",
	"Comment": "creates a new counter object and adds it to the list of managed counters.",
	"Method": "Counter newCounter(){\r\n    final Counter counter = new Counter(arrayLength);\r\n    arrays.add(counter);\r\n    return counter;\r\n}"
}, {
	"Path": "peergos.shared.scrypt.com.lambdaworks.crypto.SCryptUtil.check",
	"Comment": "compare the supplied plaintext password to a hashed password.",
	"Method": "boolean check(String passwd,String hashed){\r\n    try {\r\n        String[] parts = hashed.split(\"\\\\$\");\r\n        if (parts.length != 5 || !parts[1].equals(\"s0\")) {\r\n            throw new IllegalArgumentException(\"Invalid hashed value\");\r\n        }\r\n        long params = Long.parseLong(parts[2], 16);\r\n        byte[] salt = decode(parts[3].toCharArray());\r\n        byte[] derived0 = decode(parts[4].toCharArray());\r\n        int N = (int) Math.pow(2, params >> 16 & 0xffff);\r\n        int r = (int) params >> 8 & 0xff;\r\n        int p = (int) params & 0xff;\r\n        byte[] derived1 = SCrypt.scrypt(passwd.getBytes(\"UTF-8\"), salt, N, r, p, 32);\r\n        if (derived0.length != derived1.length)\r\n            return false;\r\n        int result = 0;\r\n        for (int i = 0; i < derived0.length; i++) {\r\n            result |= derived0[i] ^ derived1[i];\r\n        }\r\n        return result == 0;\r\n    } catch (UnsupportedEncodingException e) {\r\n        throw new IllegalStateException(\"JVM doesn't support UTF-8?\");\r\n    } catch (GeneralSecurityException e) {\r\n        throw new IllegalStateException(\"JVM doesn't support SHA1PRNG or HMAC_SHA256?\");\r\n    }\r\n}"
}, {
	"Path": "com.handsomezhou.appsearch.util.AppUtil.appCanLaunchTheMainActivity",
	"Comment": "whether app can launch the main activity.\treturn true when can launch,otherwise return false.",
	"Method": "boolean appCanLaunchTheMainActivity(Context context,String packageName){\r\n    boolean canLaunchTheMainActivity = false;\r\n    do {\r\n        if ((null == context) || TextUtils.isEmpty(packageName)) {\r\n            break;\r\n        }\r\n        PackageManager pm = context.getPackageManager();\r\n        Intent intent = pm.getLaunchIntentForPackage(packageName);\r\n        canLaunchTheMainActivity = (null == intent) ? (false) : (true);\r\n    } while (false);\r\n    return canLaunchTheMainActivity;\r\n}"
}, {
	"Path": "net.pms.util.Version.isLessThanOrEqualTo",
	"Comment": "returns true if this version is less than or equal\tto the supplied version, false otherwise",
	"Method": "boolean isLessThanOrEqualTo(Version other){\r\n    return compareTo(other) <= 0;\r\n}"
}, {
	"Path": "net.pms.network.NetworkConfiguration.getDefaultNetworkInterfaceAddress",
	"Comment": "returns the default ip address associated with the default network interface. this\tis the first network interface that does not have a parent. this should\tavoid alias interfaces being returned. if no interfaces were discovered,\tnull is returned.",
	"Method": "InterfaceAssociation getDefaultNetworkInterfaceAddress(){\r\n    logger.trace(\"default network interface address from {}\", interfaces);\r\n    InterfaceAssociation association = getFirstInterfaceWithAddress();\r\n    if (association != null) {\r\n        if (association.getParentName() != null) {\r\n            InterfaceAssociation ia = getAddressForNetworkInterfaceName(association.getParentName());\r\n            logger.trace(\"first association has parent: {} -> {}\", association, ia);\r\n            return ia;\r\n        } else {\r\n            logger.trace(\"first network interface: {}\", association);\r\n            return association;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.pms.util.Iso639.initLinks",
	"Comment": "initialize the hashmap containing languages and their codes.",
	"Method": "void initLinks(){\r\n    putCode(\"Abkhazian\", \"ab\", \"abk\", \"abk\");\r\n    putCode(\"Achinese\", null, \"ace\", \"ace\");\r\n    putCode(\"Acoli\", null, \"ach\", \"ach\");\r\n    putCode(\"Adangme\", null, \"ada\", \"ada\");\r\n    putCode(\"Afar\", \"aa\", \"aar\", \"aar\");\r\n    putCode(\"Afrihili\", null, \"afh\", \"afh\");\r\n    putCode(\"Afrikaans\", \"af\", \"afr\", \"afr\");\r\n    putCode(\"Afro-Asiatic (Other)\", null, \"afa\", \"afa\");\r\n    putCode(\"Akan\", null, \"aka\", \"aka\");\r\n    putCode(\"Akkadian\", null, \"akk\", \"akk\");\r\n    putCode(\"Albanian\", \"sq\", \"sqi\", \"alb\");\r\n    putCode(\"Aleut\", null, \"ale\", \"ale\");\r\n    putCode(\"Algonquian languages\", null, \"alg\", \"alg\");\r\n    putCode(\"Altaic (Other)\", null, \"tut\", \"tut\");\r\n    putCode(\"Amharic\", \"am\", \"amh\", \"amh\");\r\n    putCode(\"Apache languages\", null, \"apa\", \"apa\");\r\n    putCode(\"Arabic\", \"ar\", \"ara\", \"ara\");\r\n    putCode(\"Aramaic\", null, \"arc\", \"arc\");\r\n    putCode(\"Arapaho\", null, \"arp\", \"arp\");\r\n    putCode(\"Araucanian\", null, \"arn\", \"arn\");\r\n    putCode(\"Arawak\", null, \"arw\", \"arw\");\r\n    putCode(\"Armenian\", \"hy\", \"hye\", \"arm\");\r\n    putCode(\"Artificial (Other)\", null, \"art\", \"art\");\r\n    putCode(\"Assamese\", \"as\", \"asm\", \"asm\");\r\n    putCode(\"Athapascan languages\", null, \"ath\", \"ath\");\r\n    putCode(\"Australian languages\", null, \"aus\", \"aus\");\r\n    putCode(\"Austronesian (Other)\", null, \"map\", \"map\");\r\n    putCode(\"Avaric\", null, \"ava\", \"ava\");\r\n    putCode(\"Avestan\", \"ae\", \"ave\", \"ave\");\r\n    putCode(\"Awadhi\", null, \"awa\", \"awa\");\r\n    putCode(\"Aymara\", \"ay\", \"aym\", \"aym\");\r\n    putCode(\"Azerbaijani\", \"az\", \"aze\", \"aze\");\r\n    putCode(\"Balinese\", null, \"ban\", \"ban\");\r\n    putCode(\"Baltic (Other)\", null, \"bat\", \"bat\");\r\n    putCode(\"Baluchi\", null, \"bal\", \"bal\");\r\n    putCode(\"Bambara\", null, \"bam\", \"bam\");\r\n    putCode(\"Bamileke languages\", null, \"bai\", \"bai\");\r\n    putCode(\"Banda\", null, \"bad\", \"bad\");\r\n    putCode(\"Bantu (Other)\", null, \"bnt\", \"bnt\");\r\n    putCode(\"Basa\", null, \"bas\", \"bas\");\r\n    putCode(\"Bashkir\", \"ba\", \"bak\", \"bak\");\r\n    putCode(\"Basque\", \"eu\", \"eus\", \"baq\");\r\n    putCode(\"Batak (Indonesia)\", null, \"btk\", \"btk\");\r\n    putCode(\"Beja\", null, \"bej\", \"bej\");\r\n    putCode(\"Belarusian\", \"be\", \"bel\", \"bel\");\r\n    putCode(\"Bemba\", null, \"bem\", \"bem\");\r\n    putCode(\"Bengali\", \"bn\", \"ben\", \"ben\");\r\n    putCode(\"Berber (Other)\", null, \"ber\", \"ber\");\r\n    putCode(\"Bhojpuri\", null, \"bho\", \"bho\");\r\n    putCode(\"Bihari\", \"bh\", \"bih\", \"bih\");\r\n    putCode(\"Bikol\", null, \"bik\", \"bik\");\r\n    putCode(\"Bini\", null, \"bin\", \"bin\");\r\n    putCode(\"Bislama\", \"bi\", \"bis\", \"bis\");\r\n    putCode(\"Bosnian\", \"bs\", \"bos\", \"bos\");\r\n    putCode(\"Braj\", null, \"bra\", \"bra\");\r\n    putCode(\"Breton\", \"br\", \"bre\", \"bre\");\r\n    putCode(\"Buginese\", null, \"bug\", \"bug\");\r\n    putCode(\"Bulgarian\", \"bg\", \"bul\", \"bul\");\r\n    putCode(\"Buriat\", null, \"bua\", \"bua\");\r\n    putCode(\"Burmese\", \"my\", \"mya\", \"bur\");\r\n    putCode(\"Caddo\", null, \"cad\", \"cad\");\r\n    putCode(\"Carib\", null, \"car\", \"car\");\r\n    putCode(\"Catalan\", \"ca\", \"cat\", \"cat\");\r\n    putCode(\"Caucasian (Other)\", null, \"cau\", \"cau\");\r\n    putCode(\"Cebuano\", null, \"ceb\", \"ceb\");\r\n    putCode(\"Celtic (Other)\", null, \"cel\", \"cel\");\r\n    putCode(\"Central American Indian (Other)\", null, \"cai\", \"cai\");\r\n    putCode(\"Chagatai\", null, \"chg\", \"chg\");\r\n    putCode(\"Chamic languages\", null, \"cmc\", \"cmc\");\r\n    putCode(\"Chamorro\", \"ch\", \"cha\", \"cha\");\r\n    putCode(\"Chechen\", \"ce\", \"che\", \"che\");\r\n    putCode(\"Cherokee\", null, \"chr\", \"chr\");\r\n    putCode(\"Cheyenne\", null, \"chy\", \"chy\");\r\n    putCode(\"Chibcha\", null, \"chb\", \"chb\");\r\n    putCode(\"Chichewa; Nyanja\", \"ny\", \"nya\", \"nya\");\r\n    putCode(\"Chinese\", \"zh\", \"zho\", \"chi\");\r\n    putCode(\"Chinook jargon\", null, \"chn\", \"chn\");\r\n    putCode(\"Chipewyan\", null, \"chp\", \"chp\");\r\n    putCode(\"Choctaw\", null, \"cho\", \"cho\");\r\n    putCode(\"Church Slavic\", \"cu\", \"chu\", \"chu\");\r\n    putCode(\"Chuukese\", null, \"chk\", \"chk\");\r\n    putCode(\"Chuvash\", \"cv\", \"chv\", \"chv\");\r\n    putCode(\"Coptic\", null, \"cop\", \"cop\");\r\n    putCode(\"Cornish\", \"kw\", \"cor\", \"cor\");\r\n    putCode(\"Corsican\", \"co\", \"cos\", \"cos\");\r\n    putCode(\"Cree\", null, \"cre\", \"cre\");\r\n    putCode(\"Creek\", null, \"mus\", \"mus\");\r\n    putCode(\"Creoles and pidgins (Other)\", null, \"crp\", \"crp\");\r\n    putCode(\"Creoles and pidgins, English-based (Other)\", null, \"cpe\", \"cpe\");\r\n    putCode(\"Creoles and pidgins, French-based (Other)\", null, \"cpf\", \"cpf\");\r\n    putCode(\"Creoles and pidgins, Portuguese-based (Other)\", null, \"cpp\", \"cpp\");\r\n    putCode(\"Croatian\", \"hr\", \"hrv\", \"scr\");\r\n    putCode(\"Cushitic (Other)\", null, \"cus\", \"cus\");\r\n    putCode(\"Czech\", \"cs\", \"ces\", \"cze\");\r\n    putCode(\"Dakota\", null, \"dak\", \"dak\");\r\n    putCode(\"Danish\", \"da\", \"dan\", \"dan\");\r\n    putCode(\"Dayak\", null, \"day\", \"day\");\r\n    putCode(\"Delaware\", null, \"del\", \"del\");\r\n    putCode(\"Dinka\", null, \"din\", \"din\");\r\n    putCode(\"Divehi\", null, \"div\", \"div\");\r\n    putCode(\"Dogri\", null, \"doi\", \"doi\");\r\n    putCode(\"Dogrib\", null, \"dgr\", \"dgr\");\r\n    putCode(\"Dravidian (Other)\", null, \"dra\", \"dra\");\r\n    putCode(\"Duala\", null, \"dua\", \"dua\");\r\n    putCode(\"Dutch\", \"nl\", \"nld\", \"dut\");\r\n    putCode(\"Dutch, Middle (ca. 1050-1350)\", null, \"dum\", \"dum\");\r\n    putCode(\"Dyula\", null, \"dyu\", \"dyu\");\r\n    putCode(\"Dzongkha\", \"dz\", \"dzo\", \"dzo\");\r\n    putCode(\"Efik\", null, \"efi\", \"efi\");\r\n    putCode(\"Egyptian (Ancient)\", null, \"egy\", \"egy\");\r\n    putCode(\"Ekajuk\", null, \"eka\", \"eka\");\r\n    putCode(\"Elamite\", null, \"elx\", \"elx\");\r\n    putCode(\"English\", \"en\", \"eng\", \"eng\");\r\n    putCode(\"English, Middle (1100-1500)\", null, \"enm\", \"enm\");\r\n    putCode(\"English, Old (ca.450-1100)\", null, \"ang\", \"ang\");\r\n    putCode(\"Esperanto\", \"eo\", \"epo\", \"epo\");\r\n    putCode(\"Estonian\", \"et\", \"est\", \"est\");\r\n    putCode(\"Ewe\", null, \"ewe\", \"ewe\");\r\n    putCode(\"Ewondo\", null, \"ewo\", \"ewo\");\r\n    putCode(\"Fang\", null, \"fan\", \"fan\");\r\n    putCode(\"Fanti\", null, \"fat\", \"fat\");\r\n    putCode(\"Faroese\", \"fo\", \"fao\", \"fao\");\r\n    putCode(\"Fijian\", \"fj\", \"fij\", \"fij\");\r\n    putCode(\"Finnish\", \"fi\", \"fin\", \"fin\");\r\n    putCode(\"Finno-Ugrian (Other)\", null, \"fiu\", \"fiu\");\r\n    putCode(\"Fon\", null, \"fon\", \"fon\");\r\n    putCode(\"French\", \"fr\", \"fra\", \"fre\");\r\n    putCode(\"French, Middle (ca.1400-1600)\", null, \"frm\", \"frm\");\r\n    putCode(\"French, Old (842-ca.1400)\", null, \"fro\", \"fro\");\r\n    putCode(\"Frisian\", \"fy\", \"fry\", \"fry\");\r\n    putCode(\"Friulian\", null, \"fur\", \"fur\");\r\n    putCode(\"Fulah\", null, \"ful\", \"ful\");\r\n    putCode(\"Ga\", null, \"gaa\", \"gaa\");\r\n    putCode(\"Gaelic (Scots)\", \"gd\", \"gla\", \"gla\");\r\n    putCode(\"Gallegan\", \"gl\", \"glg\", \"glg\");\r\n    putCode(\"Ganda\", null, \"lug\", \"lug\");\r\n    putCode(\"Gayo\", null, \"gay\", \"gay\");\r\n    putCode(\"Gbaya\", null, \"gba\", \"gba\");\r\n    putCode(\"Geez\", null, \"gez\", \"gez\");\r\n    putCode(\"Georgian\", \"ka\", \"kat\", \"geo\");\r\n    putCode(\"German\", \"de\", \"deu\", \"ger\");\r\n    putCode(\"German, Low; Saxon, Low; Low German; Low Saxon\", null, \"nds\", \"nds\");\r\n    putCode(\"German, Middle High (ca.1050-1500)\", null, \"gmh\", \"gmh\");\r\n    putCode(\"German, Old High (ca.750-1050)\", null, \"goh\", \"goh\");\r\n    putCode(\"Germanic (Other)\", null, \"gem\", \"gem\");\r\n    putCode(\"Gilbertese\", null, \"gil\", \"gil\");\r\n    putCode(\"Gondi\", null, \"gon\", \"gon\");\r\n    putCode(\"Gorontalo\", null, \"gor\", \"gor\");\r\n    putCode(\"Gothic\", null, \"got\", \"got\");\r\n    putCode(\"Grebo\", null, \"grb\", \"grb\");\r\n    putCode(\"Greek, Ancient (to 1453)\", null, \"grc\", \"grc\");\r\n    putCode(\"Greek, Modern (1453-)\", \"el\", \"ell\", \"gre\");\r\n    putCode(\"Guarani\", \"gn\", \"grn\", \"grn\");\r\n    putCode(\"Gujarati\", \"gu\", \"guj\", \"guj\");\r\n    putCode(\"Gwich-in\", null, \"gwi\", \"gwi\");\r\n    putCode(\"Haida\", null, \"hai\", \"hai\");\r\n    putCode(\"Hausa\", \"ha\", \"hau\", \"hau\");\r\n    putCode(\"Hawaiian\", null, \"haw\", \"haw\");\r\n    putCode(\"Hebrew\", \"he\", \"heb\", \"heb\");\r\n    putCode(\"Herero\", \"hz\", \"her\", \"her\");\r\n    putCode(\"Hiligaynon\", null, \"hil\", \"hil\");\r\n    putCode(\"Himachali\", null, \"him\", \"him\");\r\n    putCode(\"Hindi\", \"hi\", \"hin\", \"hin\");\r\n    putCode(\"Hiri Motu\", \"ho\", \"hmo\", \"hmo\");\r\n    putCode(\"Hittite\", null, \"hit\", \"hit\");\r\n    putCode(\"Hmong\", null, \"hmn\", \"hmn\");\r\n    putCode(\"Hungarian\", \"hu\", \"hun\", \"hun\");\r\n    putCode(\"Hupa\", null, \"hup\", \"hup\");\r\n    putCode(\"Iban\", null, \"iba\", \"iba\");\r\n    putCode(\"Icelandic\", \"is\", \"isl\", \"ice\");\r\n    putCode(\"Igbo\", null, \"ibo\", \"ibo\");\r\n    putCode(\"Ijo\", null, \"ijo\", \"ijo\");\r\n    putCode(\"Iloko\", null, \"ilo\", \"ilo\");\r\n    putCode(\"Indic (Other)\", null, \"inc\", \"inc\");\r\n    putCode(\"Indo-European (Other)\", null, \"ine\", \"ine\");\r\n    putCode(\"Indonesian\", \"id\", \"ind\", \"ind\");\r\n    putCode(\"Interlingua (International Auxiliary Language Association)\", \"ia\", \"ina\", \"ina\");\r\n    putCode(\"Interlingue\", \"ie\", \"ile\", \"ile\");\r\n    putCode(\"Inuktitut\", \"iu\", \"iku\", \"iku\");\r\n    putCode(\"Inupiaq\", \"ik\", \"ipk\", \"ipk\");\r\n    putCode(\"Iranian (Other)\", null, \"ira\", \"ira\");\r\n    putCode(\"Irish\", \"ga\", \"gle\", \"gle\");\r\n    putCode(\"Irish, Middle (900-1200)\", null, \"mga\", \"mga\");\r\n    putCode(\"Irish, Old (to 900)\", null, \"sga\", \"sga\");\r\n    putCode(\"Iroquoian languages\", null, \"iro\", \"iro\");\r\n    putCode(\"Italian\", \"it\", \"ita\", \"ita\");\r\n    putCode(\"Japanese\", \"ja\", \"jpn\", \"jpn\");\r\n    putCode(\"Javanese\", \"jw\", \"jaw\", \"jav\");\r\n    putCode(\"Judeo-Arabic\", null, \"jrb\", \"jrb\");\r\n    putCode(\"Judeo-Persian\", null, \"jpr\", \"jpr\");\r\n    putCode(\"Kabyle\", null, \"kab\", \"kab\");\r\n    putCode(\"Kachin\", null, \"kac\", \"kac\");\r\n    putCode(\"Kalaallisut\", \"kl\", \"kal\", \"kal\");\r\n    putCode(\"Kamba\", null, \"kam\", \"kam\");\r\n    putCode(\"Kannada\", \"kn\", \"kan\", \"kan\");\r\n    putCode(\"Kanuri\", null, \"kau\", \"kau\");\r\n    putCode(\"Kara-Kalpak\", null, \"kaa\", \"kaa\");\r\n    putCode(\"Karen\", null, \"kar\", \"kar\");\r\n    putCode(\"Kashmiri\", \"ks\", \"kas\", \"kas\");\r\n    putCode(\"Kawi\", null, \"kaw\", \"kaw\");\r\n    putCode(\"Kazakh\", \"kk\", \"kaz\", \"kaz\");\r\n    putCode(\"Khasi\", null, \"kha\", \"kha\");\r\n    putCode(\"Khmer\", \"km\", \"khm\", \"khm\");\r\n    putCode(\"Khoisan (Other)\", null, \"khi\", \"khi\");\r\n    putCode(\"Khotanese\", null, \"kho\", \"kho\");\r\n    putCode(\"Kikuyu\", \"ki\", \"kik\", \"kik\");\r\n    putCode(\"Kimbundu\", null, \"kmb\", \"kmb\");\r\n    putCode(\"Kinyarwanda\", \"rw\", \"kin\", \"kin\");\r\n    putCode(\"Kirghiz\", \"ky\", \"kir\", \"kir\");\r\n    putCode(\"Komi\", \"kv\", \"kom\", \"kom\");\r\n    putCode(\"Kongo\", null, \"kon\", \"kon\");\r\n    putCode(\"Konkani\", null, \"kok\", \"kok\");\r\n    putCode(\"Korean\", \"ko\", \"kor\", \"kor\");\r\n    putCode(\"Kosraean\", null, \"kos\", \"kos\");\r\n    putCode(\"Kpelle\", null, \"kpe\", \"kpe\");\r\n    putCode(\"Kru\", null, \"kro\", \"kro\");\r\n    putCode(\"Kuanyama\", \"kj\", \"kua\", \"kua\");\r\n    putCode(\"Kumyk\", null, \"kum\", \"kum\");\r\n    putCode(\"Kurdish\", \"ku\", \"kur\", \"kur\");\r\n    putCode(\"Kurukh\", null, \"kru\", \"kru\");\r\n    putCode(\"Kutenai\", null, \"kut\", \"kut\");\r\n    putCode(\"Ladino\", null, \"lad\", \"lad\");\r\n    putCode(\"Lahnda\", null, \"lah\", \"lah\");\r\n    putCode(\"Lamba\", null, \"lam\", \"lam\");\r\n    putCode(\"Lao\", \"lo\", \"lao\", \"lao\");\r\n    putCode(\"Latin\", \"la\", \"lat\", \"lat\");\r\n    putCode(\"Latvian\", \"lv\", \"lav\", \"lav\");\r\n    putCode(\"Letzeburgesch\", \"lb\", \"ltz\", \"ltz\");\r\n    putCode(\"Lezghian\", null, \"lez\", \"lez\");\r\n    putCode(\"Lingala\", \"ln\", \"lin\", \"lin\");\r\n    putCode(\"Lithuanian\", \"lt\", \"lit\", \"lit\");\r\n    putCode(\"Low German; Low Saxon; German, Low; Saxon, Low\", null, \"nds\", \"nds\");\r\n    putCode(\"Low Saxon; Low German; Saxon, Low; German, Low\", null, \"nds\", \"nds\");\r\n    putCode(\"Lozi\", null, \"loz\", \"loz\");\r\n    putCode(\"Luba-Katanga\", null, \"lub\", \"lub\");\r\n    putCode(\"Luba-Lulua\", null, \"lua\", \"lua\");\r\n    putCode(\"Luiseno\", null, \"lui\", \"lui\");\r\n    putCode(\"Lunda\", null, \"lun\", \"lun\");\r\n    putCode(\"Luo (Kenya and Tanzania)\", null, \"luo\", \"luo\");\r\n    putCode(\"Lushai\", null, \"lus\", \"lus\");\r\n    putCode(\"Macedonian\", \"mk\", \"mkd\", \"mac\");\r\n    putCode(\"Madurese\", null, \"mad\", \"mad\");\r\n    putCode(\"Magahi\", null, \"mag\", \"mag\");\r\n    putCode(\"Maithili\", null, \"mai\", \"mai\");\r\n    putCode(\"Makasar\", null, \"mak\", \"mak\");\r\n    putCode(\"Malagasy\", \"mg\", \"mlg\", \"mlg\");\r\n    putCode(\"Malay\", \"ms\", \"msa\", \"may\");\r\n    putCode(\"Malayalam\", \"ml\", \"mal\", \"mal\");\r\n    putCode(\"Maltese\", \"mt\", \"mlt\", \"mlt\");\r\n    putCode(\"Manchu\", null, \"mnc\", \"mnc\");\r\n    putCode(\"Mandar\", null, \"mdr\", \"mdr\");\r\n    putCode(\"Mandingo\", null, \"man\", \"man\");\r\n    putCode(\"Manipuri\", null, \"mni\", \"mni\");\r\n    putCode(\"Manobo languages\", null, \"mno\", \"mno\");\r\n    putCode(\"Manx\", \"gv\", \"glv\", \"glv\");\r\n    putCode(\"Maori\", \"mi\", \"mri\", \"mao\");\r\n    putCode(\"Marathi\", \"mr\", \"mar\", \"mar\");\r\n    putCode(\"Mari\", null, \"chm\", \"chm\");\r\n    putCode(\"Marshall\", \"mh\", \"mah\", \"mah\");\r\n    putCode(\"Marwari\", null, \"mwr\", \"mwr\");\r\n    putCode(\"Masai\", null, \"mas\", \"mas\");\r\n    putCode(\"Mayan languages\", null, \"myn\", \"myn\");\r\n    putCode(\"Mende\", null, \"men\", \"men\");\r\n    putCode(\"Micmac\", null, \"mic\", \"mic\");\r\n    putCode(\"Minangkabau\", null, \"min\", \"min\");\r\n    putCode(\"Miscellaneous languages\", null, \"mis\", \"mis\");\r\n    putCode(\"Mohawk\", null, \"moh\", \"moh\");\r\n    putCode(\"Moldavian\", \"mo\", \"mol\", \"mol\");\r\n    putCode(\"Mon-Khmer (Other)\", null, \"mkh\", \"mkh\");\r\n    putCode(\"Mongo\", null, \"lol\", \"lol\");\r\n    putCode(\"Mongolian\", \"mn\", \"mon\", \"mon\");\r\n    putCode(\"Mossi\", null, \"mos\", \"mos\");\r\n    putCode(\"Munda languages\", null, \"mun\", \"mun\");\r\n    putCode(\"Nahuatl\", null, \"nah\", \"nah\");\r\n    putCode(\"Nauru\", \"na\", \"nau\", \"nau\");\r\n    putCode(\"Navajo\", \"nv\", \"nav\", \"nav\");\r\n    putCode(\"Ndebele, North\", \"nd\", \"nde\", \"nde\");\r\n    putCode(\"Ndebele, South\", \"nr\", \"nbl\", \"nbl\");\r\n    putCode(\"Ndonga\", \"ng\", \"ndo\", \"ndo\");\r\n    putCode(\"Nepali\", \"ne\", \"nep\", \"nep\");\r\n    putCode(\"Newari\", null, \"new\", \"new\");\r\n    putCode(\"Nias\", null, \"nia\", \"nia\");\r\n    putCode(\"Niger-Kordofanian (Other)\", null, \"nic\", \"nic\");\r\n    putCode(\"Nilo-Saharan (Other)\", null, \"ssa\", \"ssa\");\r\n    putCode(\"Niuean\", null, \"niu\", \"niu\");\r\n    putCode(\"Norse, Old\", null, \"non\", \"non\");\r\n    putCode(\"North American Indian(Other)\", null, \"nai\", \"nai\");\r\n    putCode(\"Northern Sami\", \"se\", \"sme\", \"sme\");\r\n    putCode(\"Norwegian\", \"no\", \"nor\", \"nor\");\r\n    putCode(\"Norwegian Bokmal\", \"nb\", \"nob\", \"nob\");\r\n    putCode(\"Norwegian Nynorsk\", \"nn\", \"nno\", \"nno\");\r\n    putCode(\"Nubian languages\", null, \"nub\", \"nub\");\r\n    putCode(\"Nyamwezi\", null, \"nym\", \"nym\");\r\n    putCode(\"Nyanja; Chichewa\", \"ny\", \"nya\", \"nya\");\r\n    putCode(\"Nyankole\", null, \"nyn\", \"nyn\");\r\n    putCode(\"Nyoro\", null, \"nyo\", \"nyo\");\r\n    putCode(\"Nzima\", null, \"nzi\", \"nzi\");\r\n    putCode(\"Occitan (post 1500); Provencal\", \"oc\", \"oci\", \"oci\");\r\n    putCode(\"Ojibwa\", null, \"oji\", \"oji\");\r\n    putCode(\"Oriya\", \"or\", \"ori\", \"ori\");\r\n    putCode(\"Oromo\", \"om\", \"orm\", \"orm\");\r\n    putCode(\"Osage\", null, \"osa\", \"osa\");\r\n    putCode(\"Ossetian; Ossetic\", \"os\", \"oss\", \"oss\");\r\n    putCode(\"Otomian languages\", null, \"oto\", \"oto\");\r\n    putCode(\"Pahlavi\", null, \"pal\", \"pal\");\r\n    putCode(\"Palauan\", null, \"pau\", \"pau\");\r\n    putCode(\"Pali\", \"pi\", \"pli\", \"pli\");\r\n    putCode(\"Pampanga\", null, \"pam\", \"pam\");\r\n    putCode(\"Pangasinan\", null, \"pag\", \"pag\");\r\n    putCode(\"Panjabi\", \"pa\", \"pan\", \"pan\");\r\n    putCode(\"Papiamento\", null, \"pap\", \"pap\");\r\n    putCode(\"Papuan (Other)\", null, \"paa\", \"paa\");\r\n    putCode(\"Persian\", \"fa\", \"fas\", \"per\");\r\n    putCode(\"Persian, Old (ca.600-400 B.C.)\", null, \"peo\", \"peo\");\r\n    putCode(\"Philippine (Other)\", null, \"phi\", \"phi\");\r\n    putCode(\"Phoenician\", null, \"phn\", \"phn\");\r\n    putCode(\"Pohnpeian\", null, \"pon\", \"pon\");\r\n    putCode(\"Polish\", \"pl\", \"pol\", \"pol\");\r\n    putCode(\"Portuguese\", \"pt\", \"por\", \"por\");\r\n    putCode(\"Prakrit languages\", null, \"pra\", \"pra\");\r\n    putCode(\"Provencal; Occitan (post 1500)\", \"oc\", \"oci\", \"oci\");\r\n    putCode(\"Provencal, Old (to 1500)\", null, \"pro\", \"pro\");\r\n    putCode(\"Pushto\", \"ps\", \"pus\", \"pus\");\r\n    putCode(\"Quechua\", \"qu\", \"que\", \"que\");\r\n    putCode(\"Raeto-Romance\", \"rm\", \"roh\", \"roh\");\r\n    putCode(\"Rajasthani\", null, \"raj\", \"raj\");\r\n    putCode(\"Rapanui\", null, \"rap\", \"rap\");\r\n    putCode(\"Rarotongan\", null, \"rar\", \"rar\");\r\n    putCode(\"Romance (Other)\", null, \"roa\", \"roa\");\r\n    putCode(\"Romanian\", \"ro\", \"ron\", \"rum\");\r\n    putCode(\"Romany\", null, \"rom\", \"rom\");\r\n    putCode(\"Rundi\", \"rn\", \"run\", \"run\");\r\n    putCode(\"Russian\", \"ru\", \"rus\", \"rus\");\r\n    putCode(\"Salishan languages\", null, \"sal\", \"sal\");\r\n    putCode(\"Samaritan Aramaic\", null, \"sam\", \"sam\");\r\n    putCode(\"Sami languages (Other)\", null, \"smi\", \"smi\");\r\n    putCode(\"Samoan\", \"sm\", \"smo\", \"smo\");\r\n    putCode(\"Sandawe\", null, \"sad\", \"sad\");\r\n    putCode(\"Sango\", \"sg\", \"sag\", \"sag\");\r\n    putCode(\"Sanskrit\", \"sa\", \"san\", \"san\");\r\n    putCode(\"Santali\", null, \"sat\", \"sat\");\r\n    putCode(\"Sardinian\", \"sc\", \"srd\", \"srd\");\r\n    putCode(\"Sasak\", null, \"sas\", \"sas\");\r\n    putCode(\"Saxon, Low; German, Low; Low Saxon; Low German\", null, \"nds\", \"nds\");\r\n    putCode(\"Scots\", null, \"sco\", \"sco\");\r\n    putCode(\"Selkup\", null, \"sel\", \"sel\");\r\n    putCode(\"Semitic (Other)\", null, \"sem\", \"sem\");\r\n    putCode(\"Serbian\", \"sr\", \"srp\", \"scc\");\r\n    putCode(\"Serer\", null, \"srr\", \"srr\");\r\n    putCode(\"Shan\", null, \"shn\", \"shn\");\r\n    putCode(\"Shona\", \"sn\", \"sna\", \"sna\");\r\n    putCode(\"Sidamo\", null, \"sid\", \"sid\");\r\n    putCode(\"Sign languages\", null, \"sgn\", \"sgn\");\r\n    putCode(\"Siksika\", null, \"bla\", \"bla\");\r\n    putCode(\"Sindhi\", \"sd\", \"snd\", \"snd\");\r\n    putCode(\"Sinhalese\", \"si\", \"sin\", \"sin\");\r\n    putCode(\"Sino-Tibetan (Other)\", null, \"sit\", \"sit\");\r\n    putCode(\"Siouan languages\", null, \"sio\", \"sio\");\r\n    putCode(\"Slave (Athapascan)\", null, \"den\", \"den\");\r\n    putCode(\"Slavic (Other)\", null, \"sla\", \"sla\");\r\n    putCode(\"Slovak\", \"sk\", \"slk\", \"slo\");\r\n    putCode(\"Slovenian\", \"sl\", \"slv\", \"slv\");\r\n    putCode(\"Sogdian\", null, \"sog\", \"sog\");\r\n    putCode(\"Somali\", \"so\", \"som\", \"som\");\r\n    putCode(\"Songhai\", null, \"son\", \"son\");\r\n    putCode(\"Soninke\", null, \"snk\", \"snk\");\r\n    putCode(\"Sorbian languages\", null, \"wen\", \"wen\");\r\n    putCode(\"Sotho, Northern\", null, \"nso\", \"nso\");\r\n    putCode(\"Sotho, Southern\", \"st\", \"sot\", \"sot\");\r\n    putCode(\"South American Indian (Other)\", null, \"sai\", \"sai\");\r\n    putCode(\"Spanish\", \"es\", \"spa\", \"spa\");\r\n    putCode(\"Sukuma\", null, \"suk\", \"suk\");\r\n    putCode(\"Sumerian\", null, \"sux\", \"sux\");\r\n    putCode(\"Sundanese\", \"su\", \"sun\", \"sun\");\r\n    putCode(\"Susu\", null, \"sus\", \"sus\");\r\n    putCode(\"Swahili\", \"sw\", \"swa\", \"swa\");\r\n    putCode(\"Swati\", \"ss\", \"ssw\", \"ssw\");\r\n    putCode(\"Swedish\", \"sv\", \"swe\", \"swe\");\r\n    putCode(\"Syriac\", null, \"syr\", \"syr\");\r\n    putCode(\"Tagalog\", \"tl\", \"tgl\", \"tgl\");\r\n    putCode(\"Tahitian\", \"ty\", \"tah\", \"tah\");\r\n    putCode(\"Tai (Other)\", null, \"tai\", \"tai\");\r\n    putCode(\"Tajik\", \"tg\", \"tgk\", \"tgk\");\r\n    putCode(\"Tamashek\", null, \"tmh\", \"tmh\");\r\n    putCode(\"Tamil\", \"ta\", \"tam\", \"tam\");\r\n    putCode(\"Tatar\", \"tt\", \"tat\", \"tat\");\r\n    putCode(\"Telugu\", \"te\", \"tel\", \"tel\");\r\n    putCode(\"Tereno\", null, \"ter\", \"ter\");\r\n    putCode(\"Tetum\", null, \"tet\", \"tet\");\r\n    putCode(\"Thai\", \"th\", \"tha\", \"tha\");\r\n    putCode(\"Tibetan\", \"bo\", \"bod\", \"tib\");\r\n    putCode(\"Tigre\", null, \"tig\", \"tig\");\r\n    putCode(\"Tigrinya\", \"ti\", \"tir\", \"tir\");\r\n    putCode(\"Timne\", null, \"tem\", \"tem\");\r\n    putCode(\"Tiv\", null, \"tiv\", \"tiv\");\r\n    putCode(\"Tlingit\", null, \"tli\", \"tli\");\r\n    putCode(\"Tok Pisin\", null, \"tpi\", \"tpi\");\r\n    putCode(\"Tokelau\", null, \"tkl\", \"tkl\");\r\n    putCode(\"Tonga (Nyasa)\", null, \"tog\", \"tog\");\r\n    putCode(\"Tonga (Tonga Islands)\", \"to\", \"ton\", \"ton\");\r\n    putCode(\"Tsimshian\", null, \"tsi\", \"tsi\");\r\n    putCode(\"Tsonga\", \"ts\", \"tso\", \"tso\");\r\n    putCode(\"Tswana\", \"tn\", \"tsn\", \"tsn\");\r\n    putCode(\"Tumbuka\", null, \"tum\", \"tum\");\r\n    putCode(\"Turkish\", \"tr\", \"tur\", \"tur\");\r\n    putCode(\"Turkish, Ottoman (1500-1928)\", null, \"ota\", \"ota\");\r\n    putCode(\"Turkmen\", \"tk\", \"tuk\", \"tuk\");\r\n    putCode(\"Tuvalu\", null, \"tvl\", \"tvl\");\r\n    putCode(\"Tuvinian\", null, \"tyv\", \"tyv\");\r\n    putCode(\"Twi\", \"tw\", \"twi\", \"twi\");\r\n    putCode(\"Ugaritic\", null, \"uga\", \"uga\");\r\n    putCode(\"Uighur\", \"ug\", \"uig\", \"uig\");\r\n    putCode(\"Ukrainian\", \"uk\", \"ukr\", \"ukr\");\r\n    putCode(\"Umbundu\", null, \"umb\", \"umb\");\r\n    putCode(\"Undetermined\", null, DLNAMediaLang.UND, DLNAMediaLang.UND);\r\n    putCode(\"Urdu\", \"ur\", \"urd\", \"urd\");\r\n    putCode(\"Uzbek\", \"uz\", \"uzb\", \"uzb\");\r\n    putCode(\"Vai\", null, \"vai\", \"vai\");\r\n    putCode(\"Venda\", null, \"ven\", \"ven\");\r\n    putCode(\"Vietnamese\", \"vi\", \"vie\", \"vie\");\r\n    putCode(\"Volapuk\", \"vo\", \"vol\", \"vol\");\r\n    putCode(\"Votic\", null, \"vot\", \"vot\");\r\n    putCode(\"Wakashan languages\", null, \"wak\", \"wak\");\r\n    putCode(\"Walamo\", null, \"wal\", \"wal\");\r\n    putCode(\"Waray\", null, \"war\", \"war\");\r\n    putCode(\"Washo\", null, \"was\", \"was\");\r\n    putCode(\"Welsh\", \"cy\", \"cym\", \"wel\");\r\n    putCode(\"Wolof\", \"wo\", \"wol\", \"wol\");\r\n    putCode(\"Xhosa\", \"xh\", \"xho\", \"xho\");\r\n    putCode(\"Yakut\", null, \"sah\", \"sah\");\r\n    putCode(\"Yao\", null, \"yao\", \"yao\");\r\n    putCode(\"Yapese\", null, \"yap\", \"yap\");\r\n    putCode(\"Yiddish\", \"yi\", \"yid\", \"yid\");\r\n    putCode(\"Yoruba\", \"yo\", \"yor\", \"yor\");\r\n    putCode(\"Yupik languages\", null, \"ypk\", \"ypk\");\r\n    putCode(\"Zande\", null, \"znd\", \"znd\");\r\n    putCode(\"Zapotec\", null, \"zap\", \"zap\");\r\n    putCode(\"Zenaga\", null, \"zen\", \"zen\");\r\n    putCode(\"Zhuang\", \"za\", \"zha\", \"zha\");\r\n    putCode(\"Zulu\", \"zu\", \"zul\", \"zul\");\r\n    putCode(\"Zuni\", null, \"zun\", \"zun\");\r\n}"
}, {
	"Path": "net.pms.configuration.RendererConfigurationTest.testKnownHeaders",
	"Comment": "test the rendererconfiguration class and the consistency of the renderer\t.conf files it reads. this is done by feeding it known headers and\tchecking whether it recognizes the correct renderer.",
	"Method": "void testKnownHeaders(){\r\n    PmsConfiguration pmsConf = null;\r\n    try {\r\n        pmsConf = new PmsConfiguration(false);\r\n    } catch (ConfigurationException e) {\r\n    }\r\n    loadRendererConfigurations(pmsConf);\r\n    Set<Entry<String, String>> set = testCases.entrySet();\r\n    Iterator<Entry<String, String>> i = set.iterator();\r\n    while (i.hasNext()) {\r\n        Entry<String, String> entry = (Entry<String, String>) i.next();\r\n        testHeader(entry.getKey(), entry.getValue());\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.MathLib.sqrtInterp",
	"Comment": "interpolates a value between a given minimum and maximum value usinga square root scale.",
	"Method": "double sqrtInterp(double val,double min,double max){\r\n    double sqrtMin = safeSqrt(min);\r\n    double denominator = (safeSqrt(max) - sqrtMin);\r\n    if (denominator == 0)\r\n        return 0;\r\n    return (safeSqrt(val) - sqrtMin) / denominator;\r\n}"
}, {
	"Path": "com.restfb.json.JsonArray.iterator",
	"Comment": "returns an iterator over the values of this array in document order. the returned iterator cannot be used to modifythis array.",
	"Method": "Iterator<JsonValue> iterator(){\r\n    final Iterator<JsonValue> iterator = values.iterator();\r\n    return new Iterator<JsonValue>() {\r\n        public boolean hasNext() {\r\n            return iterator.hasNext();\r\n        }\r\n        public JsonValue next() {\r\n            return iterator.next();\r\n        }\r\n        public void remove() {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.restfb.json.JsonArray.iterator",
	"Comment": "returns an iterator over the values of this array in document order. the returned iterator cannot be used to modifythis array.",
	"Method": "Iterator<JsonValue> iterator(){\r\n    return iterator.hasNext();\r\n}"
}, {
	"Path": "com.restfb.json.JsonArray.iterator",
	"Comment": "returns an iterator over the values of this array in document order. the returned iterator cannot be used to modifythis array.",
	"Method": "Iterator<JsonValue> iterator(){\r\n    return iterator.next();\r\n}"
}, {
	"Path": "com.restfb.json.JsonArray.iterator",
	"Comment": "returns an iterator over the values of this array in document order. the returned iterator cannot be used to modifythis array.",
	"Method": "Iterator<JsonValue> iterator(){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.pcap4j.util.ByteArrays.validateBounds",
	"Comment": "a utility method to validate arguments which indicate a part of an array.",
	"Method": "void validateBounds(byte[] arr,int offset,int len){\r\n    if (arr == null) {\r\n        throw new NullPointerException(\"arr must not be null.\");\r\n    }\r\n    if (arr.length == 0) {\r\n        throw new IllegalArgumentException(\"arr is empty.\");\r\n    }\r\n    if (len == 0) {\r\n        StringBuilder sb = new StringBuilder(100);\r\n        sb.append(\"length is zero. offset: \").append(offset).append(\", arr: \").append(toHexString(arr, \"\"));\r\n        throw new IllegalArgumentException(sb.toString());\r\n    }\r\n    if (offset < 0 || len < 0 || offset + len > arr.length) {\r\n        StringBuilder sb = new StringBuilder(100);\r\n        sb.append(\"arr.length: \").append(arr.length).append(\", offset: \").append(offset).append(\", len: \").append(len).append(\", arr: \").append(toHexString(arr, \"\"));\r\n        throw new ArrayIndexOutOfBoundsException(sb.toString());\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.ui.JRangeSlider.setMinimum",
	"Comment": "sets the minimum possible value for either the low value or the high value.",
	"Method": "void setMinimum(int minimum){\r\n    model.setMinimum(minimum);\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.lists.CwTree.createDynamicTree",
	"Comment": "create a dynamic tree that will add a random number of children to eachnode as it is clicked.",
	"Method": "Tree createDynamicTree(){\r\n    Tree dynamicTree = new Tree();\r\n    for (int i = 0; i < 5; i++) {\r\n        TreeItem item = dynamicTree.addTextItem(constants.cwTreeItem() + \" \" + i);\r\n        item.addTextItem(\"\");\r\n    }\r\n    dynamicTree.addOpenHandler(new OpenHandler<TreeItem>() {\r\n        @Override\r\n        public void onOpen(OpenEvent<TreeItem> event) {\r\n            TreeItem item = event.getTarget();\r\n            if (item.getChildCount() == 1) {\r\n                item.setState(false, false);\r\n                String itemText = item.getText();\r\n                int numChildren = Random.nextInt(5) + 2;\r\n                for (int i = 0; i < numChildren; i++) {\r\n                    TreeItem child = item.addTextItem(itemText + \".\" + i);\r\n                    child.addTextItem(\"\");\r\n                }\r\n                item.getChild(0).remove();\r\n                item.setState(true, false);\r\n            }\r\n        }\r\n    });\r\n    return dynamicTree;\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.lists.CwTree.createDynamicTree",
	"Comment": "create a dynamic tree that will add a random number of children to eachnode as it is clicked.",
	"Method": "Tree createDynamicTree(){\r\n    TreeItem item = event.getTarget();\r\n    if (item.getChildCount() == 1) {\r\n        item.setState(false, false);\r\n        String itemText = item.getText();\r\n        int numChildren = Random.nextInt(5) + 2;\r\n        for (int i = 0; i < numChildren; i++) {\r\n            TreeItem child = item.addTextItem(itemText + \".\" + i);\r\n            child.addTextItem(\"\");\r\n        }\r\n        item.getChild(0).remove();\r\n        item.setState(true, false);\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.io.DelimitedTextTableWriter.isPrintHeader",
	"Comment": "indicates if this writer will write a header row with the column names.",
	"Method": "boolean isPrintHeader(){\r\n    return m_printHeader;\r\n}"
}, {
	"Path": "prefuse.data.column.ColumnMetadata.getMean",
	"Comment": "get the mean value of numeric values in the column. if this columndoes not contain numeric values, this method will result in anexception being thrown.",
	"Method": "double getMean(){\r\n    accessCheck();\r\n    if (m_mean == null && m_dynamic) {\r\n        m_mean = new Double(DataLib.mean(m_table.tuples(), m_field));\r\n    }\r\n    return m_mean.doubleValue();\r\n}"
}, {
	"Path": "prefuse.action.assignment.DataColorAction.setDefaultColor",
	"Comment": "this operation is not supported by the datacoloraction type.calling this method will result in a thrown exception.",
	"Method": "void setDefaultColor(int color){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "prefuse.data.Graph.outEdgeRows",
	"Comment": "get an iterator over all edges that have the given node as a source.that is, edges that link out from the given source node.",
	"Method": "IntIterator outEdgeRows(int node){\r\n    return edgeRows(node, OUTEDGES);\r\n}"
}, {
	"Path": "net.pms.network.NetworkConfiguration.addAvailableAddresses",
	"Comment": "collect all of the relevant addresses for the given network interface, add\tthem to the global address map and return them.",
	"Method": "Set<InetAddress> addAvailableAddresses(NetworkInterface networkInterface){\r\n    Set<InetAddress> addrSet = new HashSet<InetAddress>();\r\n    logger.trace(\"available addresses for {} is: {}\", networkInterface.getName(), Collections.list(networkInterface.getInetAddresses()));\r\n    for (InetAddress address : Collections.list(networkInterface.getInetAddresses())) {\r\n        if (address != null) {\r\n            if (isRelevantAddress(address)) {\r\n                addrSet.add(address);\r\n            }\r\n        }\r\n    }\r\n    logger.trace(\"non loopback/ipv4 addresses: {}\", addrSet);\r\n    addressMap.put(networkInterface.getName(), addrSet);\r\n    return addrSet;\r\n}"
}, {
	"Path": "picard.sam.ViewSamTest.testHeaderVersion",
	"Comment": "confirm that viewsam retains whatever version number was in the input header.",
	"Method": "void testHeaderVersion(){\r\n    final String oldVersionHeader = \"@HD\\tVN:1.3\\tSO:unsorted\";\r\n    final File inputSam = File.createTempFile(\"ViewSamTest.input.\", \".sam\");\r\n    inputSam.deleteOnExit();\r\n    final AsciiWriter writer = new AsciiWriter(new FileOutputStream(inputSam));\r\n    writer.write(oldVersionHeader);\r\n    writer.write(\"\\n\");\r\n    writer.close();\r\n    final File viewSamOutputFile = File.createTempFile(\"ViewSamTest.output.\", \".sam\");\r\n    viewSamOutputFile.deleteOnExit();\r\n    final ViewSam viewSam = new ViewSam();\r\n    viewSam.INPUT = inputSam.getAbsolutePath();\r\n    final PrintStream viewSamPrintStream = new PrintStream(viewSamOutputFile);\r\n    Assert.assertEquals(viewSam.writeSamText(viewSamPrintStream), 0);\r\n    viewSamPrintStream.close();\r\n    final LineReader viewSamInputReader = new BufferedLineReader(new FileInputStream(viewSamOutputFile));\r\n    Assert.assertEquals(viewSamInputReader.readLine(), oldVersionHeader);\r\n}"
}, {
	"Path": "prefuse.Visualization.getVisualGroup",
	"Comment": "retrieve the visual data group of the given group name. only primaryvisual groups will be considered.",
	"Method": "TupleSet getVisualGroup(String group){\r\n    return (TupleSet) m_visual.get(group);\r\n}"
}, {
	"Path": "net.pms.util.FormLayoutUtil.flipped",
	"Comment": "returns an array of column specifications that is built from the given\tencoded column specifications by flipping each column spec and reversing\ttheir order.",
	"Method": "ColumnSpec flipped(ColumnSpec spec,ColumnSpec[] flipped,ColumnSpec[] original,ColumnSpec[] flipped,String encodedColumnSpecs){\r\n    return flipped(ColumnSpec.decodeSpecs(encodedColumnSpecs));\r\n}"
}, {
	"Path": "prefuse.data.Table.addRows",
	"Comment": "add a given number of rows to this table. all data columns will benotified and will take on the appropriate default values for theadded rows.",
	"Method": "void addRows(int nrows){\r\n    for (int i = 0; i < nrows; ++i) {\r\n        addRow();\r\n    }\r\n}"
}, {
	"Path": "prefuse.action.layout.Layout.setMargin",
	"Comment": "set the margins the layout should observe within its layout bounds.",
	"Method": "void setMargin(int top,int left,int bottom,int right){\r\n    m_insets.top = top;\r\n    m_insets.left = left;\r\n    m_insets.bottom = bottom;\r\n    m_insets.right = right;\r\n    m_margin = true;\r\n}"
}, {
	"Path": "prefuse.util.PrefuseLib.getVisualItemSchema",
	"Comment": "get an instance of the default schema used for visualitem instances.contains all the data members commonly used to model a visual element,such as x,y position, stroke, fill, and text, colors, size, font,and validated, visibility, interactive, fixed, highlight, and mousehover fields.",
	"Method": "Schema getVisualItemSchema(){\r\n    Schema s = new Schema();\r\n    s.addColumn(VisualItem.VALIDATED, boolean.class, Boolean.FALSE);\r\n    s.addColumn(VisualItem.VISIBLE, boolean.class, Boolean.TRUE);\r\n    s.addColumn(VisualItem.STARTVISIBLE, boolean.class, Boolean.FALSE);\r\n    s.addColumn(VisualItem.ENDVISIBLE, boolean.class, Boolean.TRUE);\r\n    s.addColumn(VisualItem.INTERACTIVE, boolean.class, Boolean.TRUE);\r\n    s.addColumn(VisualItem.EXPANDED, boolean.class, Boolean.TRUE);\r\n    s.addColumn(VisualItem.FIXED, boolean.class, Boolean.FALSE);\r\n    s.addColumn(VisualItem.HIGHLIGHT, boolean.class, Boolean.FALSE);\r\n    s.addColumn(VisualItem.HOVER, boolean.class, Boolean.FALSE);\r\n    s.addInterpolatedColumn(VisualItem.X, double.class);\r\n    s.addInterpolatedColumn(VisualItem.Y, double.class);\r\n    s.addColumn(VisualItem.BOUNDS, Rectangle2D.class, new Rectangle2D.Double());\r\n    Integer defStroke = new Integer(ColorLib.rgba(0, 0, 0, 0));\r\n    s.addInterpolatedColumn(VisualItem.STROKECOLOR, int.class, defStroke);\r\n    Integer defFill = new Integer(ColorLib.rgba(0, 0, 0, 0));\r\n    s.addInterpolatedColumn(VisualItem.FILLCOLOR, int.class, defFill);\r\n    Integer defTextColor = new Integer(ColorLib.rgba(0, 0, 0, 0));\r\n    s.addInterpolatedColumn(VisualItem.TEXTCOLOR, int.class, defTextColor);\r\n    s.addInterpolatedColumn(VisualItem.SIZE, double.class, new Double(1));\r\n    s.addColumn(VisualItem.SHAPE, int.class, new Integer(Constants.SHAPE_RECTANGLE));\r\n    s.addColumn(VisualItem.STROKE, Stroke.class, new BasicStroke());\r\n    Font defFont = FontLib.getFont(\"SansSerif\", Font.PLAIN, 10);\r\n    s.addInterpolatedColumn(VisualItem.FONT, Font.class, defFont);\r\n    s.addColumn(VisualItem.DOI, double.class, new Double(Double.MIN_VALUE));\r\n    return s;\r\n}"
}, {
	"Path": "SoftBody2D.SoftBody2D_DifferentialGrowth_Open.SoftBody2D_DifferentialGrowth_Open.sortParticles",
	"Comment": "save particles in a sorted list, as they are lined up in the chain",
	"Method": "void sortParticles(){\r\n    particles_sorted_count = 0;\r\n    DwParticle2D pstart = particles[0];\r\n    DwParticle2D pprev = null;\r\n    DwParticle2D pcurr = pstart;\r\n    DwParticle2D pnext = null;\r\n    while (pcurr != null && pnext != pstart) {\r\n        particles_sorted[particles_sorted_count++] = pcurr;\r\n        pnext = getNextParticle(pcurr, pprev);\r\n        pprev = pcurr;\r\n        pcurr = pnext;\r\n    }\r\n}"
}, {
	"Path": "cn.hugeterry.ployfun.core.delaunay.Pnt.vsCircumcircle",
	"Comment": "test relation between this pnt and circumcircle of a simplex.",
	"Method": "int vsCircumcircle(Pnt[] simplex){\r\n    Pnt[] matrix = new Pnt[simplex.length + 1];\r\n    for (int i = 0; i < simplex.length; i++) matrix[i] = simplex[i].extend(1, simplex[i].dot(simplex[i]));\r\n    matrix[simplex.length] = this.extend(1, this.dot(this));\r\n    double d = determinant(matrix);\r\n    int result = (d < 0) ? -1 : ((d > 0) ? +1 : 0);\r\n    if (content(simplex) < 0)\r\n        result = -result;\r\n    return result;\r\n}"
}, {
	"Path": "prefuse.action.assignment.DataSizeAction.setIs2DArea",
	"Comment": "sets if the size values set by this function represent 2d areas.that is, if the size is a 2d area or a 1d length. the size value willbe scaled appropriately to facilitate better perception of sizedifferences.",
	"Method": "void setIs2DArea(boolean isArea){\r\n    m_is2DArea = isArea;\r\n}"
}, {
	"Path": "peergos.shared.util.EfficientHashMap.keyEquals",
	"Comment": "returns whether two keys are equal for the purposes of this set.",
	"Method": "boolean keyEquals(Object a,Object b){\r\n    return (a == null) ? (b == null) : a.equals(b);\r\n}"
}, {
	"Path": "prefuse.Visualization.setVisible",
	"Comment": "sets the visbility status for all items in a given data group matchinga given filter predicate.",
	"Method": "void setVisible(String group,Predicate p,boolean value){\r\n    Iterator items = items(group, p);\r\n    while (items.hasNext()) {\r\n        VisualItem item = (VisualItem) items.next();\r\n        item.setVisible(value);\r\n    }\r\n}"
}, {
	"Path": "quickfix.field.converter.UtcTimestampConverter.convert",
	"Comment": "convert a timestamp string into a date.date has up to millisecond precision.",
	"Method": "String convert(Date d,boolean includeMilliseconds,String convert,LocalDateTime d,UtcTimestampPrecision precision,Date convert,String value){\r\n    verifyFormat(value);\r\n    long timeOffset = getTimeOffsetSeconds(value);\r\n    if (value.length() >= LENGTH_INCL_MILLIS) {\r\n        timeOffset += parseLong(value.substring(18, LENGTH_INCL_MILLIS));\r\n    }\r\n    return new Date(getMillisForDay(value) + timeOffset);\r\n}"
}, {
	"Path": "prefuse.data.query.ObjectRangeModel.getIndex",
	"Comment": "return the index for a given object, indicating its order in the range.",
	"Method": "int getIndex(Object o){\r\n    Integer idx = (Integer) m_ordinal.get(o);\r\n    return (idx == null ? -1 : idx.intValue());\r\n}"
}, {
	"Path": "prefuse.util.io.XMLWriter.comment",
	"Comment": "print a comment in the xml document. the comment will be printedaccording to the current spacing and followed by a newline.",
	"Method": "void comment(String comment){\r\n    spacing();\r\n    m_out.print(\"<!-- \");\r\n    m_out.print(comment);\r\n    m_out.print(\" -->\");\r\n    println();\r\n}"
}, {
	"Path": "py4j.GatewayServer.createConnection",
	"Comment": "creates a server connection from a python call to the java side.",
	"Method": "Py4JServerConnection createConnection(Gateway gateway,Socket socket){\r\n    GatewayConnection connection = new GatewayConnection(gateway, socket, authToken, customCommands, listeners);\r\n    connection.startConnection();\r\n    return connection;\r\n}"
}, {
	"Path": "picard.sam.markduplicates.EstimateLibraryComplexityTest.testSimpleDuplicateWithMaxReadLength",
	"Comment": "finds duplicates since the we examine only the fist ten bases.",
	"Method": "void testSimpleDuplicateWithMaxReadLength(String testName,int numDuplicates,int numReadPairsExamined){\r\n    final File input = new File(TEST_DATA_DIR, testName);\r\n    final File output = File.createTempFile(\"estimateLibraryComplexity\", \".els_metrics\");\r\n    output.deleteOnExit();\r\n    final List<String> args = new ArrayList();\r\n    args.add(\"INPUT=\" + input.getAbsolutePath());\r\n    args.add(\"OUTPUT=\" + output.getAbsolutePath());\r\n    args.add(\"MAX_DIFF_RATE=0.0\");\r\n    args.add(\"MIN_GROUP_COUNT=1\");\r\n    args.add(\"MAX_READ_LENGTH=10\");\r\n    Assert.assertEquals(runPicardCommandLine(args), 0);\r\n    examineMetricsFile(output, numDuplicates, numReadPairsExamined);\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setMencoderNoAssScale",
	"Comment": "set the subfont text scale parameter used for subtitling without ass.",
	"Method": "void setMencoderNoAssScale(String value){\r\n    configuration.setProperty(KEY_MENCODER_NOASS_SCALE, value);\r\n}"
}, {
	"Path": "picard.sam.markduplicates.MarkDuplicates.generateDuplicateIndexes",
	"Comment": "goes through the accumulated readendsformarkduplicates objects and determines which of them areto be marked as duplicates.",
	"Method": "void generateDuplicateIndexes(boolean useBarcodes,boolean indexOpticalDuplicates){\r\n    final int entryOverhead;\r\n    if (TAG_DUPLICATE_SET_MEMBERS) {\r\n        entryOverhead = 16;\r\n    } else {\r\n        entryOverhead = SortingLongCollection.SIZEOF;\r\n    }\r\n    int maxInMemory = (int) Math.min((Runtime.getRuntime().maxMemory() * 0.25) / entryOverhead, (double) (Integer.MAX_VALUE - 5));\r\n    if (indexOpticalDuplicates) {\r\n        maxInMemory /= ((entryOverhead + SortingLongCollection.SIZEOF) / entryOverhead);\r\n        this.opticalDuplicateIndexes = new SortingLongCollection(maxInMemory, TMP_DIR.toArray(new File[TMP_DIR.size()]));\r\n    }\r\n    log.info(\"Will retain up to \" + maxInMemory + \" duplicate indices before spilling to disk.\");\r\n    this.duplicateIndexes = new SortingLongCollection(maxInMemory, TMP_DIR.toArray(new File[TMP_DIR.size()]));\r\n    if (TAG_DUPLICATE_SET_MEMBERS) {\r\n        final RepresentativeReadIndexerCodec representativeIndexCodec = new RepresentativeReadIndexerCodec();\r\n        this.representativeReadIndicesForDuplicates = SortingCollection.newInstance(RepresentativeReadIndexer.class, representativeIndexCodec, Comparator.comparing(read -> read.readIndexInFile), maxInMemory, TMP_DIR);\r\n    }\r\n    ReadEndsForMarkDuplicates firstOfNextChunk = null;\r\n    final List<ReadEndsForMarkDuplicates> nextChunk = new ArrayList(200);\r\n    log.info(\"Traversing read pair information and detecting duplicates.\");\r\n    for (final ReadEndsForMarkDuplicates next : this.pairSort) {\r\n        if (firstOfNextChunk != null && areComparableForDuplicates(firstOfNextChunk, next, true, useBarcodes)) {\r\n            nextChunk.add(next);\r\n        } else {\r\n            if (nextChunk.size() > 1) {\r\n                markDuplicatePairs(nextChunk);\r\n                if (TAG_DUPLICATE_SET_MEMBERS) {\r\n                    addRepresentativeReadIndex(nextChunk);\r\n                }\r\n            }\r\n            nextChunk.clear();\r\n            nextChunk.add(next);\r\n            firstOfNextChunk = next;\r\n        }\r\n    }\r\n    if (nextChunk.size() > 1) {\r\n        markDuplicatePairs(nextChunk);\r\n        if (TAG_DUPLICATE_SET_MEMBERS) {\r\n            addRepresentativeReadIndex(nextChunk);\r\n        }\r\n    }\r\n    this.pairSort.cleanup();\r\n    this.pairSort = null;\r\n    log.info(\"Traversing fragment information and detecting duplicates.\");\r\n    boolean containsPairs = false;\r\n    boolean containsFrags = false;\r\n    firstOfNextChunk = null;\r\n    for (final ReadEndsForMarkDuplicates next : this.fragSort) {\r\n        if (firstOfNextChunk != null && areComparableForDuplicates(firstOfNextChunk, next, false, useBarcodes)) {\r\n            nextChunk.add(next);\r\n            containsPairs = containsPairs || next.isPaired();\r\n            containsFrags = containsFrags || !next.isPaired();\r\n        } else {\r\n            if (nextChunk.size() > 1 && containsFrags) {\r\n                markDuplicateFragments(nextChunk, containsPairs);\r\n            }\r\n            nextChunk.clear();\r\n            nextChunk.add(next);\r\n            firstOfNextChunk = next;\r\n            containsPairs = next.isPaired();\r\n            containsFrags = !next.isPaired();\r\n        }\r\n    }\r\n    markDuplicateFragments(nextChunk, containsPairs);\r\n    this.fragSort.cleanup();\r\n    this.fragSort = null;\r\n    log.info(\"Sorting list of duplicate records.\");\r\n    this.duplicateIndexes.doneAddingStartIteration();\r\n    if (this.opticalDuplicateIndexes != null) {\r\n        this.opticalDuplicateIndexes.doneAddingStartIteration();\r\n    }\r\n    if (TAG_DUPLICATE_SET_MEMBERS) {\r\n        this.representativeReadIndicesForDuplicates.doneAdding();\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.util.ValidEdgePredicate.getBoolean",
	"Comment": "indicates if the given tuple can be used as a valid edge forthe nodes of the backing graph.",
	"Method": "boolean getBoolean(Tuple tpl){\r\n    Node s = m_g.getNodeFromKey(tpl.getInt(m_g.getEdgeSourceField()));\r\n    Node t = m_g.getNodeFromKey(tpl.getInt(m_g.getEdgeTargetField()));\r\n    return (s != null && t != null);\r\n}"
}, {
	"Path": "prefuse.Visualization.putAction",
	"Comment": "add a data processing action to this visualization. the action will beupdated to use this visualization in its data processing.",
	"Method": "Action putAction(String name,Action action){\r\n    action.setVisualization(this);\r\n    m_actions.put(name, action);\r\n    return action;\r\n}"
}, {
	"Path": "net.pms.network.RequestHandler.filterIp",
	"Comment": "applies the ip filter to the specified internet address. returns true\tif the address is not allowed and therefore should be filtered out,\tfalse otherwise.",
	"Method": "boolean filterIp(InetAddress inetAddress){\r\n    return !PMS.getConfiguration().getIpFiltering().allowed(inetAddress);\r\n}"
}, {
	"Path": "io.github.benas.randombeans.util.ReflectionUtils.getAnnotation",
	"Comment": "looks for given annotationtype on given field or read method for field.",
	"Method": "T getAnnotation(Field field,Class<T> annotationType){\r\n    return field.getAnnotation(annotationType) == null ? getAnnotationFromReadMethod(getReadMethod(field).orElse(null), annotationType) : field.getAnnotation(annotationType);\r\n}"
}, {
	"Path": "com.restfb.json.JsonValue.readFrom",
	"Comment": "reads a json value from the given reader.characters are read in chunks and buffered internally, therefore wrapping an existing reader in an additionalbufferedreader does not improve reading performance.",
	"Method": "JsonValue readFrom(Reader reader,JsonValue readFrom,String text){\r\n    try {\r\n        return new JsonParser(text).parse();\r\n    } catch (IOException exception) {\r\n        throw new RuntimeException(exception);\r\n    }\r\n}"
}, {
	"Path": "prefuse.activity.ActivityManager._keepRunning",
	"Comment": "used by the activity loop to determine if the activitymanagerthread should keep running or exit.",
	"Method": "boolean _keepRunning(){\r\n    return m_run;\r\n}"
}, {
	"Path": "picard.illumina.parser.IlluminaDataProviderFactory.determineFormats",
	"Comment": "for all requesteddatatypes return a map of file format to set of provided data types that covers as many requesteddatatypes as possible andchooses the most preferred available formats possible",
	"Method": "Map<SupportedIlluminaFormat, Set<IlluminaDataType>> determineFormats(Set<IlluminaDataType> requestedDataTypes,IlluminaFileUtil fileUtil){\r\n    final SortedSet<IlluminaDataType> toSupport = new TreeSet(requestedDataTypes);\r\n    final Map<SupportedIlluminaFormat, Set<IlluminaDataType>> fileTypeToDataTypes = new EnumMap(SupportedIlluminaFormat.class);\r\n    final Map<IlluminaDataType, SupportedIlluminaFormat> dataTypeToFormat = new EnumMap(IlluminaDataType.class);\r\n    for (final IlluminaDataType ts : toSupport) {\r\n        final SupportedIlluminaFormat preferredFormat = findPreferredAvailableFormat(ts, fileUtil);\r\n        if (preferredFormat != null) {\r\n            dataTypeToFormat.put(ts, preferredFormat);\r\n        }\r\n    }\r\n    for (final IlluminaDataType dt : toSupport) {\r\n        final SupportedIlluminaFormat format = dataTypeToFormat.get(dt);\r\n        if (format != null) {\r\n            if (fileTypeToDataTypes.containsKey(format)) {\r\n                fileTypeToDataTypes.get(format).add(dt);\r\n            } else {\r\n                fileTypeToDataTypes.put(dataTypeToFormat.get(dt), makeSet(dt));\r\n            }\r\n        }\r\n    }\r\n    return fileTypeToDataTypes;\r\n}"
}, {
	"Path": "prefuse.util.ui.JSearchPanel.setShowBorder",
	"Comment": "indicates if the component should show a border around the text field.",
	"Method": "void setShowBorder(boolean b){\r\n    m_showBorder = b;\r\n    initUI();\r\n    validate();\r\n}"
}, {
	"Path": "java.lang.Throwable.toString",
	"Comment": "a private method to avoid polymorphic calls from constructor.",
	"Method": "String toString(String toString,String message){\r\n    String className = getClass().getName();\r\n    return message == null ? className : className + \": \" + message;\r\n}"
}, {
	"Path": "prefuse.render.LabelRenderer.setMaxImageDimensions",
	"Comment": "sets the maximum image dimensions, used to control scaling of loadedimages. this scaling is enforced immediately upon loading of the image.",
	"Method": "void setMaxImageDimensions(int width,int height){\r\n    if (m_images == null)\r\n        m_images = new ImageFactory();\r\n    m_images.setMaxImageDimensions(width, height);\r\n}"
}, {
	"Path": "net.pms.newgui.RestrictedFileSystemView.getSystemDisplayName",
	"Comment": "name of a file, directory, or folder as it would be displayed in a system file browser",
	"Method": "String getSystemDisplayName(File f){\r\n    String name = null;\r\n    if (f != null) {\r\n        if (isRoot(f)) {\r\n            name = f.getAbsolutePath();\r\n        } else {\r\n            name = f.getName();\r\n        }\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "com.restfb.json.ParseException.getColumn",
	"Comment": "returns the index of the character at which the error occurred, relative to the line. the index of the firstcharacter of a line is 0.",
	"Method": "int getColumn(){\r\n    return column;\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeProbabilities.assertSnpPartOfHaplotype",
	"Comment": "throws an exception if the passed snp is not part of this haplotype.",
	"Method": "void assertSnpPartOfHaplotype(Snp snp){\r\n    if (!this.haplotypeBlock.contains(snp)) {\r\n        throw new IllegalArgumentException(\"Snp \" + snp + \" does not belong to haplotype \" + this.haplotypeBlock);\r\n    }\r\n}"
}, {
	"Path": "com.google.gwt.sample.dynatablerf.domain.Person.findPerson",
	"Comment": "the requestfactory requires a static finder method for each proxied type.soon it should allow you to customize how instances are found.",
	"Method": "Person findPerson(String id){\r\n    return SchoolCalendarService.findPerson(id);\r\n}"
}, {
	"Path": "prefuse.util.ui.UILib.getAxis",
	"Comment": "resolve the axis type of a component, given a layout orientation",
	"Method": "int getAxis(JComponent c,int layout){\r\n    ComponentOrientation o = c.getComponentOrientation();\r\n    switch(layout) {\r\n        case BoxLayout.LINE_AXIS:\r\n            return o.isHorizontal() ? BoxLayout.X_AXIS : BoxLayout.Y_AXIS;\r\n        case BoxLayout.PAGE_AXIS:\r\n            return o.isHorizontal() ? BoxLayout.Y_AXIS : BoxLayout.X_AXIS;\r\n        default:\r\n            return layout;\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.MathLib.linearInterp",
	"Comment": "interpolates a value between a given minimum and maximum value usinga linear scale.",
	"Method": "double linearInterp(double val,double min,double max){\r\n    double denominator = (max - min);\r\n    if (denominator == 0)\r\n        return 0;\r\n    return (val - min) / denominator;\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeProbabilities.getLodMostProbableGenotype",
	"Comment": "returns the lod score between the most probable haplotype and the second most probable.",
	"Method": "double getLodMostProbableGenotype(){\r\n    final double[] probs = getPosteriorProbabilities();\r\n    double biggest = 0;\r\n    double secondBiggest = 0;\r\n    for (double prob : probs) {\r\n        if (prob > biggest) {\r\n            secondBiggest = biggest;\r\n            biggest = prob;\r\n            continue;\r\n        }\r\n        if (prob > secondBiggest) {\r\n            secondBiggest = prob;\r\n        }\r\n    }\r\n    return log10(biggest) - log10(secondBiggest);\r\n}"
}, {
	"Path": "net.pms.util.PlayerUtil.isAudio",
	"Comment": "returns whether or not the supplied dlna resource is an audio file.",
	"Method": "boolean isAudio(DLNAResource resource,boolean isAudio,DLNAResource resource,Format.Identifier identifier){\r\n    return isType(resource, Format.AUDIO, identifier);\r\n}"
}, {
	"Path": "net.pms.network.NetworkConfiguration.getDisplayNames",
	"Comment": "returns the list of user friendly name names of interfaces with their ip\taddress.",
	"Method": "List<String> getDisplayNames(){\r\n    List<String> result = new ArrayList<String>(interfaces.size());\r\n    for (InterfaceAssociation i : interfaces) {\r\n        result.add(i.getDisplayName());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "picard.illumina.parser.ReadStructure.toString",
	"Comment": "converts this object into a string using rules complementary to the single string constructor above.",
	"Method": "String toString(){\r\n    String out = \"\";\r\n    for (final ReadDescriptor rd : descriptors) {\r\n        out += rd.toString();\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "prefuse.data.util.TableIterator.canSet",
	"Comment": "check if the set method for the given data field canaccept values of a given target type.",
	"Method": "boolean canSet(String field,Class type){\r\n    return m_table.canSet(field, type);\r\n}"
}, {
	"Path": "prefuse.data.column.ColumnMetadata.dispose",
	"Comment": "dispose of this metadata, freeing any resources and unregistering anylisteners.",
	"Method": "void dispose(){\r\n    m_table.getColumn(m_field).removeColumnListener(this);\r\n}"
}, {
	"Path": "prefuse.render.LabelRenderer.getVerticalPadding",
	"Comment": "returns the amount of padding in pixels between the content and the border of this item along the vertical dimension.",
	"Method": "int getVerticalPadding(){\r\n    return m_vertBorder;\r\n}"
}, {
	"Path": "picard.sam.markduplicates.MarkDuplicatesWithMateCigarIterator.getMetrics",
	"Comment": "get the duplication metrics for the library associated with end.",
	"Method": "DuplicationMetrics getMetrics(SAMRecord record){\r\n    final String library = LibraryIdGenerator.getLibraryName(header, record);\r\n    DuplicationMetrics metrics = libraryIdGenerator.getMetricsByLibrary(library);\r\n    if (metrics == null) {\r\n        metrics = new DuplicationMetrics();\r\n        metrics.LIBRARY = library;\r\n        libraryIdGenerator.addMetricsByLibrary(library, metrics);\r\n    }\r\n    return metrics;\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.addChildEdge",
	"Comment": "unsupported operation. spanning trees should not be edited.",
	"Method": "int addChildEdge(int parent,int child,Edge addChildEdge,Node parent,Node child){\r\n    throw new UnsupportedOperationException(\"Changes to tree structure not allowed for spanning trees.\");\r\n}"
}, {
	"Path": "net.pms.encoders.MEncoderVideo.quoteArg",
	"Comment": "returns the argument string surrounded with quotes if it contains a space,\totherwise returns the string as is.",
	"Method": "String quoteArg(String arg){\r\n    if (arg == null || arg.indexOf(\" \") == -1) {\r\n        return arg;\r\n    }\r\n    StringBuilder result = new StringBuilder();\r\n    result.append(\"\\\"\").append(arg).append(\"\\\"\");\r\n    return result.toString();\r\n}"
}, {
	"Path": "prefuse.Display.getCustomToolTip",
	"Comment": "get the custom tooltip used by this display. returns null if normaltooltips are being used.",
	"Method": "JToolTip getCustomToolTip(){\r\n    return m_customToolTip;\r\n}"
}, {
	"Path": "net.paoding.rose.jade.rowmapper.BeanPropertyRowMapper.underscoreName",
	"Comment": "convert a name in camelcase to an underscored name in lower case.any upper case letters are converted to lower case with a precedingunderscore.",
	"Method": "String[] underscoreName(String camelCaseName){\r\n    StringBuilder result = new StringBuilder();\r\n    if (camelCaseName != null && camelCaseName.length() > 0) {\r\n        result.append(camelCaseName.substring(0, 1).toLowerCase());\r\n        for (int i = 1; i < camelCaseName.length(); i++) {\r\n            char ch = camelCaseName.charAt(i);\r\n            if (Character.isUpperCase(ch)) {\r\n                result.append(\"_\");\r\n                result.append(Character.toLowerCase(ch));\r\n            } else {\r\n                result.append(ch);\r\n            }\r\n        }\r\n    }\r\n    String name = result.toString();\r\n    String name2 = null;\r\n    boolean digitFound = false;\r\n    for (int i = name.length() - 1; i >= 0; i--) {\r\n        if (Character.isDigit(name.charAt(i))) {\r\n            digitFound = true;\r\n            continue;\r\n        }\r\n        if (digitFound && i < name.length() - 1 && i > 0) {\r\n            if (name2 == null) {\r\n                name2 = name;\r\n            }\r\n            name2 = name2.substring(0, i + 1) + \"_\" + name2.substring(i + 1);\r\n        }\r\n        digitFound = false;\r\n    }\r\n    return new String[] { name, name2 };\r\n}"
}, {
	"Path": "prefuse.activity.ActivityManager.alwaysScheduleAfter",
	"Comment": "schedules an activity to start immediately after another activity.the second activity will be scheduled to start immediately after thefirst one finishes, overwriting any previously set starttime. if thefirst activity is cancelled, the second one will not run.this functionality is provided by using an activitylistener to monitorthe first activity. the listener will persist across mulitple runs,meaning the second activity will always be evoked upon a successfulfinish of the first.this method does not otherwise effect the scheduling of the first activity.",
	"Method": "void alwaysScheduleAfter(Activity before,Activity after){\r\n    getInstance()._alwaysScheduleAfter(before, after);\r\n}"
}, {
	"Path": "prefuse.util.force.SpringForce.getForce",
	"Comment": "calculates the force vector acting on the items due to the given spring.",
	"Method": "void getForce(Spring s){\r\n    ForceItem item1 = s.item1;\r\n    ForceItem item2 = s.item2;\r\n    float length = (s.length < 0 ? params[SPRING_LENGTH] : s.length);\r\n    float x1 = item1.location[0], y1 = item1.location[1];\r\n    float x2 = item2.location[0], y2 = item2.location[1];\r\n    float dx = x2 - x1, dy = y2 - y1;\r\n    float r = (float) Math.sqrt(dx * dx + dy * dy);\r\n    if (r == 0.0) {\r\n        dx = ((float) Math.random() - 0.5f) / 50.0f;\r\n        dy = ((float) Math.random() - 0.5f) / 50.0f;\r\n        r = (float) Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n    float d = r - length;\r\n    float coeff = (s.coeff < 0 ? params[SPRING_COEFF] : s.coeff) * d / r;\r\n    item1.force[0] += coeff * dx;\r\n    item1.force[1] += coeff * dy;\r\n    item2.force[0] += -coeff * dx;\r\n    item2.force[1] += -coeff * dy;\r\n}"
}, {
	"Path": "com.handsomezhou.appsearch.util.ViewUtil.setHideIme",
	"Comment": "hide soft keyboard on android after clicking outside edittext",
	"Method": "void setHideIme(Activity activity,View view){\r\n    if (null == activity || null == view) {\r\n        return;\r\n    }\r\n    if (!(view instanceof EditText)) {\r\n        view.setOnTouchListener(new OnTouchListener() {\r\n            @Override\r\n            public boolean onTouch(View v, MotionEvent event) {\r\n                ViewUtil.hideSoftKeyboard(activity);\r\n                return false;\r\n            }\r\n        });\r\n    }\r\n    if (view instanceof ViewGroup) {\r\n        for (int i = 0; i < ((ViewGroup) view).getChildCount(); i++) {\r\n            View innerView = ((ViewGroup) view).getChildAt(i);\r\n            setHideIme(activity, innerView);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.handsomezhou.appsearch.util.ViewUtil.setHideIme",
	"Comment": "hide soft keyboard on android after clicking outside edittext",
	"Method": "void setHideIme(Activity activity,View view){\r\n    ViewUtil.hideSoftKeyboard(activity);\r\n    return false;\r\n}"
}, {
	"Path": "com.restfb.types.Post.getProperties",
	"Comment": "a list of properties for this post.this field is undocumented.",
	"Method": "List<Property> getProperties(){\r\n    return unmodifiableList(properties);\r\n}"
}, {
	"Path": "prefuse.util.ArrayLib.find",
	"Comment": "linearly search an array range for a given key value. assumes thatthe range begins at index 0.",
	"Method": "int find(int[] a,int key,int find,int[] a,int key,int length,int find,int[] a,int key,int begin,int end){\r\n    for (int i = begin; i < end; i++) {\r\n        if (a[i] == key) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "quickfix.Message.toXML",
	"Comment": "converts the message into a simple xml format. this format isprobably not sufficient for production use, but it more intendedfor diagnostics and debugging. this is not fixml.",
	"Method": "String toXML(String toXML,DataDictionary dataDictionary){\r\n    try {\r\n        final Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\r\n        final Element message = document.createElement(\"message\");\r\n        document.appendChild(message);\r\n        toXMLFields(message, \"header\", header, dataDictionary);\r\n        toXMLFields(message, \"body\", this, dataDictionary);\r\n        toXMLFields(message, \"trailer\", trailer, dataDictionary);\r\n        final DOMSource domSource = new DOMSource(document);\r\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n        final StreamResult streamResult = new StreamResult(out);\r\n        final TransformerFactory tf = TransformerFactory.newInstance();\r\n        final Transformer serializer = tf.newTransformer();\r\n        serializer.setOutputProperty(OutputKeys.ENCODING, \"ISO-8859-1\");\r\n        serializer.setOutputProperty(OutputKeys.INDENT, \"yes\");\r\n        serializer.transform(domSource, streamResult);\r\n        return out.toString();\r\n    } catch (final Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.PrefuseLib.getSize2D",
	"Comment": "returns a scale factor by which to scale a 2d shape to grow the area by the desired input size value. this is used to scale shapesby total pixel area, rather than scaling each dimension by thesize value itself, which grows the pixel area quadratically ratherthan linearly.",
	"Method": "double getSize2D(double size){\r\n    return Math.pow(size, SIZE_SCALE_FACTOR);\r\n}"
}, {
	"Path": "net.pms.util.Version.isGreaterThanOrEqualTo",
	"Comment": "returns true if this version is greater than or\tequal to the supplied version, false otherwise",
	"Method": "boolean isGreaterThanOrEqualTo(Version other){\r\n    return compareTo(other) >= 0;\r\n}"
}, {
	"Path": "prefuse.visual.VisualGraph.fireGraphEvent",
	"Comment": "fire a graph event. makes sure to invalidate all edges connectedto a node that has been updated.",
	"Method": "void fireGraphEvent(Table t,int first,int last,int col,int type){\r\n    if (type == EventConstants.UPDATE && col == VisualItem.IDX_VALIDATED && t == getNodeTable()) {\r\n        VisualTable nodes = (VisualTable) t;\r\n        VisualTable edges = (VisualTable) getEdgeTable();\r\n        for (int i = first; i <= last; ++i) {\r\n            if (nodes.isValidated(i))\r\n                continue;\r\n            if (i < 0) {\r\n                System.err.println(\"catch me - VisualGraph fireGraphEvent\");\r\n            }\r\n            IntIterator erows = edgeRows(i);\r\n            while (erows.hasNext()) {\r\n                int erow = erows.nextInt();\r\n                edges.setValidated(erow, false);\r\n            }\r\n        }\r\n    }\r\n    super.fireGraphEvent(t, first, last, col, type);\r\n}"
}, {
	"Path": "prefuse.Display.getPredicate",
	"Comment": "returns the filtering predicate used to control what items are drawnby this display.",
	"Method": "Predicate getPredicate(){\r\n    if (m_predicate.size() == 1) {\r\n        return BooleanLiteral.TRUE;\r\n    } else {\r\n        return m_predicate.get(0);\r\n    }\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setDisableSubtitles",
	"Comment": "set whether or not subtitles should be disabled for\tall transcoding engines.",
	"Method": "void setDisableSubtitles(boolean value){\r\n    configuration.setProperty(KEY_DISABLE_SUBTITLES, value);\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.canGetLong",
	"Comment": "indicates if convenience get method can be called withoutan exception being thrown for the long type.",
	"Method": "boolean canGetLong(){\r\n    return canGet(long.class);\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.isDiscovered",
	"Comment": "returns true when the details of this resource have already been\tinvestigated. this helps is not doing the same work twice.",
	"Method": "boolean isDiscovered(){\r\n    return discovered;\r\n}"
}, {
	"Path": "picard.pedigree.PedFile.removeIncompleteTrios",
	"Comment": "scans through the pedigrees and removes all entries that do not have both paternal and maternal ids set.",
	"Method": "PedFile removeIncompleteTrios(){\r\n    final Iterator<Map.Entry<String, PedTrio>> iterator = entrySet().iterator();\r\n    while (iterator.hasNext()) {\r\n        if (!iterator.next().getValue().hasBothParents())\r\n            iterator.remove();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.getStroke",
	"Comment": "get the current stroke used to draw lines and shape outlines for theitem at the given row.",
	"Method": "BasicStroke getStroke(int row){\r\n    return (BasicStroke) get(row, VisualItem.STROKE);\r\n}"
}, {
	"Path": "com.google.gwt.sample.dynatable.server.SchoolCalendarServiceImpl.onAfterResponseSerialized",
	"Comment": "write the serialized response out to stdout. this is a very unusual thingto do, but it allows us to create a static file version of the responsewithout deploying a servlet.",
	"Method": "void onAfterResponseSerialized(String serializedResponse){\r\n    System.out.println(serializedResponse);\r\n}"
}, {
	"Path": "prefuse.data.query.ListModel.fireDataEvent",
	"Comment": "fires a change notification in response to changes in the listmodel.",
	"Method": "void fireDataEvent(Object src,int type,int idx0,int idx1){\r\n    Object[] lstnrs = m_lstnrs.getArray();\r\n    if (lstnrs.length > 0) {\r\n        ListDataEvent e = new ListDataEvent(src, type, idx0, idx1);\r\n        for (int i = 0; i < lstnrs.length; ++i) {\r\n            ((ListDataListener) lstnrs[i]).contentsChanged(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "picard.sam.SamErrorMetric.CollectSamErrorMetrics.addLocusBases",
	"Comment": "iterate over the different records in the locus and add bases to aggregators",
	"Method": "void addLocusBases(Collection<BaseErrorAggregation> aggregatorList,SAMLocusAndReference info){\r\n    info.getRecordAndOffsets().forEach(rao -> aggregatorList.forEach(l -> l.addBase(rao, info)));\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.isAudioUsePCM",
	"Comment": "returns whether or not the pulse code modulation audio format should be\tforced. the default is false.",
	"Method": "boolean isAudioUsePCM(){\r\n    return getBoolean(KEY_AUDIO_USE_PCM, false);\r\n}"
}, {
	"Path": "prefuse.data.query.ListModel.isMultipleSelection",
	"Comment": "indicates if the listmodel currently has multiple selections.",
	"Method": "boolean isMultipleSelection(){\r\n    return getMaxSelectionIndex() - getMinSelectionIndex() > 0;\r\n}"
}, {
	"Path": "prefuse.data.parser.ParserFactory.reset",
	"Comment": "reset the candidate parser settings, making each parserequally likely.",
	"Method": "void reset(){\r\n    Arrays.fill(m_isCandidate, true);\r\n}"
}, {
	"Path": "prefuse.Visualization.visibleItems",
	"Comment": "get an iterator over all visible items in the specified group.",
	"Method": "Iterator visibleItems(Iterator visibleItems,String group){\r\n    return items(group, VisiblePredicate.TRUE);\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getAssOutline",
	"Comment": "returns the outline parameter used for ass subtitling. default value is 1.",
	"Method": "String getAssOutline(){\r\n    return getString(KEY_ASS_OUTLINE, \"1\");\r\n}"
}, {
	"Path": "net.pms.util.PlayerUtil.isWebAudio",
	"Comment": "returns whether or not the supplied dlna resource is a web audio file.",
	"Method": "boolean isWebAudio(DLNAResource resource){\r\n    return isType(resource, Format.AUDIO, Format.Identifier.WEB);\r\n}"
}, {
	"Path": "prefuse.data.util.TableIterator.canSetString",
	"Comment": "check if the setstring method can safely be used for thegiven data field.",
	"Method": "boolean canSetString(String field){\r\n    return m_table.canSetString(field);\r\n}"
}, {
	"Path": "picard.util.ScatterIntervalsByNs.segregateReference",
	"Comment": "generate an interval list that alternates between ns and acgts",
	"Method": "IntervalList segregateReference(ReferenceSequenceFile refFile,int maxNmerToMerge){\r\n    final List<Interval> preliminaryIntervals = new LinkedList();\r\n    final SAMFileHeader header = new SAMFileHeader();\r\n    header.setSequenceDictionary(refFile.getSequenceDictionary());\r\n    header.setSortOrder(SAMFileHeader.SortOrder.coordinate);\r\n    final IntervalList finalIntervals = new IntervalList(header);\r\n    for (final SAMSequenceRecord rec : refFile.getSequenceDictionary().getSequences()) {\r\n        final ReferenceSequence ref = refFile.getSequence(rec.getSequenceName());\r\n        final byte[] bytes = ref.getBases();\r\n        StringUtil.toUpperCase(bytes);\r\n        boolean nBlockIsOpen = SequenceUtil.isNoCall(bytes[0]);\r\n        int start = 0;\r\n        for (int i = 0; i < bytes.length; ++i) {\r\n            locusProgress.record(rec.getSequenceName(), i);\r\n            final boolean currentBaseIsN = SequenceUtil.isNoCall(bytes[i]);\r\n            if (nBlockIsOpen != currentBaseIsN) {\r\n                preliminaryIntervals.add(new Interval(rec.getSequenceName(), start + 1, i, false, nBlockIsOpen ? Nmer : ACGTmer));\r\n                start = i;\r\n                nBlockIsOpen = !nBlockIsOpen;\r\n            }\r\n        }\r\n        preliminaryIntervals.add(new Interval(rec.getSequenceName(), start + 1, bytes.length, false, nBlockIsOpen ? Nmer : ACGTmer));\r\n    }\r\n    while (!preliminaryIntervals.isEmpty()) {\r\n        if (preliminaryIntervals.size() >= 3 && preliminaryIntervals.get(0).getName() == ACGTmer && preliminaryIntervals.get(1).getName() == Nmer && preliminaryIntervals.get(2).getName() == ACGTmer && preliminaryIntervals.get(0).abuts(preliminaryIntervals.get(1)) && preliminaryIntervals.get(1).abuts(preliminaryIntervals.get(2)) && preliminaryIntervals.get(1).length() <= maxNmerToMerge) {\r\n            final Interval temp = new Interval(preliminaryIntervals.get(0).getContig(), preliminaryIntervals.get(0).getStart(), preliminaryIntervals.get(2).getEnd(), false, ACGTmer);\r\n            for (int i = 0; i < 3; ++i) {\r\n                preliminaryIntervals.remove(0);\r\n            }\r\n            preliminaryIntervals.add(0, temp);\r\n        } else {\r\n            final Interval remove = preliminaryIntervals.remove(0);\r\n            finalIntervals.add(remove);\r\n            intervalProgress.record(remove.getContig(), remove.getStart());\r\n        }\r\n    }\r\n    return finalIntervals;\r\n}"
}, {
	"Path": "me.vickychijwani.spectre.util.NetworkUtils.isConnected",
	"Comment": "check whether there is any network with a usable connection.",
	"Method": "boolean isConnected(Context context){\r\n    ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);\r\n    NetworkInfo activeNetworkInfo = connectivityManager.getActiveNetworkInfo();\r\n    return activeNetworkInfo != null && activeNetworkInfo.isConnected();\r\n}"
}, {
	"Path": "prefuse.data.parser.TypeInferencer.getType",
	"Comment": "get the data type for the highest ranking candidate parserstill in the running for the given column index.",
	"Method": "Class getType(int column){\r\n    return getParser(column).getType();\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.removeEdge",
	"Comment": "unsupported operation. spanning trees should not be edited.",
	"Method": "boolean removeEdge(Edge e,boolean removeEdge,int edge){\r\n    throw new UnsupportedOperationException(\"Changes to graph structure not allowed for spanning trees.\");\r\n}"
}, {
	"Path": "prefuse.util.ui.JCustomTooltip.isPersistent",
	"Comment": "indicates if the tooltip will stay persistent on the screen tosupport interaction within the tooltip component.",
	"Method": "boolean isPersistent(){\r\n    return m_persist;\r\n}"
}, {
	"Path": "com.restfb.types.User.getIdsForBusiness",
	"Comment": "businesses can claim ownership of multiple apps using business manager.this edge returns the list of ids that this user has in any of those other apps",
	"Method": "List<UserIDForApp> getIdsForBusiness(){\r\n    return unmodifiableList(idsForBusiness);\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.buildSpanningTree",
	"Comment": "build the spanning tree, starting at the given root. uses anunweighted breadth first traversal to build the spanning tree.",
	"Method": "void buildSpanningTree(Node root){\r\n    super.clearEdges();\r\n    super.setRoot(root);\r\n    LinkedList q = new LinkedList();\r\n    BitSet visit = new BitSet();\r\n    q.add(root);\r\n    visit.set(root.getRow());\r\n    Table edges = getEdgeTable();\r\n    while (!q.isEmpty()) {\r\n        Node p = (Node) q.removeFirst();\r\n        for (Iterator iter = p.edges(); iter.hasNext(); ) {\r\n            Edge e = (Edge) iter.next();\r\n            Node n = e.getAdjacentNode(p);\r\n            if (!visit.get(n.getRow())) {\r\n                q.add(n);\r\n                visit.set(n.getRow());\r\n                int er = super.addChildEdge(p.getRow(), n.getRow());\r\n                edges.setInt(er, SOURCE_EDGE, e.getRow());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.search.PrefixSearchTupleSet.search",
	"Comment": "searches the indexed tuple fields for matching string prefixes, adding the tuple instances for each search match to this tupleset.the query string is first broken up into separate terms, as determinedby the current delimiter string. a search for each term is conducted,and all matching tuples are included in the results.",
	"Method": "void search(String query){\r\n    if (query == null)\r\n        query = \"\";\r\n    if (query.equals(m_query))\r\n        return;\r\n    Tuple[] rem = clearInternal();\r\n    m_query = query;\r\n    StringTokenizer st = new StringTokenizer(m_query, m_delim);\r\n    if (!st.hasMoreTokens())\r\n        m_query = \"\";\r\n    while (st.hasMoreTokens()) prefixSearch(st.nextToken());\r\n    Tuple[] add = getTupleCount() > 0 ? toArray() : null;\r\n    fireTupleEvent(add, rem);\r\n}"
}, {
	"Path": "prefuse.data.Tree.isValidTree",
	"Comment": "check that the underlying graph structure forms a valid tree.",
	"Method": "boolean isValidTree(){\r\n    int nnodes = getNodeCount();\r\n    int nedges = getEdgeCount();\r\n    if (nnodes != nedges + 1) {\r\n        s_logger.warning(\"Node/edge counts incorrect.\");\r\n        return false;\r\n    }\r\n    int root = getRootRow();\r\n    IntIterator nodes = getNodeTable().rows();\r\n    while (nodes.hasNext()) {\r\n        int n = nodes.nextInt();\r\n        int id = getInDegree(n);\r\n        if (n == root && id > 0) {\r\n            s_logger.warning(\"Root node has a parent.\");\r\n            return false;\r\n        } else if (id > 1) {\r\n            s_logger.warning(\"Node \" + n + \" has multiple parents.\");\r\n            return false;\r\n        }\r\n    }\r\n    int[] counts = new int[] { 0, nedges };\r\n    isValidHelper(getRootRow(), counts);\r\n    if (counts[0] > nedges) {\r\n        s_logger.warning(\"The tree has non-tree edges in it.\");\r\n        return false;\r\n    }\r\n    if (counts[0] < nedges) {\r\n        s_logger.warning(\"Not all of the tree was visited. \" + \"Only \" + counts[0] + \"/\" + nedges + \" edges encountered\");\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "picard.fingerprint.HaplotypeMap.getHaplotypes",
	"Comment": "returns an unmodifiable collection of all the haplotype blocks in the map.",
	"Method": "List<HaplotypeBlock> getHaplotypes(){\r\n    return Collections.unmodifiableList(this.haplotypeBlocks);\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAMediaAudio.isLossless",
	"Comment": "returns true if this media uses a lossless audio compression codec, false otherwise.",
	"Method": "boolean isLossless(){\r\n    return getCodecA() != null && (isPCM() || getCodecA().startsWith(\"fla\") || getCodecA().equals(\"mlp\") || getCodecA().equals(\"wv\"));\r\n}"
}, {
	"Path": "net.pms.io.SizeLimitInputStream.allBytesRead",
	"Comment": "tell whether the number of bytes specified in the constructor have been\tread yet.",
	"Method": "boolean allBytesRead(){\r\n    return getBytesLeft() == 0;\r\n}"
}, {
	"Path": "picard.util.LiftoverUtils.referenceAlleleMatchesReferenceForIndel",
	"Comment": "checks whether the reference allele in the provided variant context actually matches the reference sequence",
	"Method": "boolean referenceAlleleMatchesReferenceForIndel(List<Allele> alleles,ReferenceSequence referenceSequence,int start,int end){\r\n    final String refString = StringUtil.bytesToString(referenceSequence.getBases(), start - 1, end - start + 1);\r\n    final Allele refAllele = alleles.stream().filter(Allele::isReference).findAny().orElseThrow(() -> new IllegalStateException(\"Error: no reference allele was present\"));\r\n    return (refString.equalsIgnoreCase(refAllele.getBaseString()));\r\n}"
}, {
	"Path": "net.pms.xmlwise.Xmlwise.loadXml",
	"Comment": "loads a document from file and transforms it into an xmlelement tree.",
	"Method": "XmlElement loadXml(File file,XmlElement loadXml,String filename){\r\n    return loadXml(new File(filename));\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.isStartVisible",
	"Comment": "indicates if the start visible flag is set to true. this is thevisibility value consulted for the staring value of the visibilityfield at the beginning of an animated transition.",
	"Method": "boolean isStartVisible(int row){\r\n    return getBoolean(row, VisualItem.STARTVISIBLE);\r\n}"
}, {
	"Path": "prefuse.util.MathLib.interp",
	"Comment": "interpolates a value within a range using a specified scale,returning the fractional position of the value within that scale.",
	"Method": "double interp(int scale,double val,double dist){\r\n    switch(scale) {\r\n        case Constants.LINEAR_SCALE:\r\n            return linearInterp(val, dist[0], dist[dist.length - 1]);\r\n        case Constants.LOG_SCALE:\r\n            return logInterp(val, dist[0], dist[dist.length - 1]);\r\n        case Constants.SQRT_SCALE:\r\n            return sqrtInterp(val, dist[0], dist[dist.length - 1]);\r\n        case Constants.QUANTILE_SCALE:\r\n            return quantile(val, dist);\r\n    }\r\n    throw new IllegalArgumentException(\"Unrecognized scale value: \" + scale);\r\n}"
}, {
	"Path": "net.pms.util.CoverUtil.getThumbnailFromArtistAlbum",
	"Comment": "tries to look up a thumbnail based on artist and album information from a\tgiven backend and returns the image data on success or null\tif no thumbnail could be determined.",
	"Method": "byte[] getThumbnailFromArtistAlbum(int backend,String info){\r\n    if (info.length >= 2 && StringUtils.isNotBlank(info[0]) && StringUtils.isNotBlank(info[1])) {\r\n        String artist = URLEncoder.encode(info[0], \"UTF-8\");\r\n        String album = URLEncoder.encode(info[1], \"UTF-8\");\r\n        if (covers.get(artist + album) != null) {\r\n            byte[] data = covers.get(artist + album);\r\n            if (data.length == 0) {\r\n                return null;\r\n            } else {\r\n                return data;\r\n            }\r\n        }\r\n        if (backend == AUDIO_DISCOGS) {\r\n            String url = \"http://www.discogs.com/advanced_search?artist=\" + artist + \"&release_title=\" + album + \"&btn=Search+Releases\";\r\n            byte[] data = downloadAndSendBinary(url);\r\n            if (data != null) {\r\n                try {\r\n                    String html = new String(data, \"UTF-8\");\r\n                    int firstItem = html.indexOf(\"<li style=\\\"background:\");\r\n                    if (firstItem > -1) {\r\n                        String detailUrl = html.substring(html.indexOf(\"<a href=\\\"/\", firstItem) + 10, html.indexOf(\"\\\"><em>\", firstItem));\r\n                        data = downloadAndSendBinary(\"http://www.discogs.com/\" + detailUrl);\r\n                        html = new String(data, \"UTF-8\");\r\n                        firstItem = html.indexOf(\"<a href=\\\"/viewimages?\");\r\n                        if (firstItem > -1) {\r\n                            String imageUrl = html.substring(html.indexOf(\"<img src=\\\"\", firstItem) + 10, html.indexOf(\"\\\" border\", firstItem));\r\n                            data = downloadAndSendBinary(imageUrl);\r\n                            if (data != null) {\r\n                                covers.put(artist + album, data);\r\n                            } else {\r\n                                covers.put(artist + album, new byte[0]);\r\n                            }\r\n                            return data;\r\n                        }\r\n                    }\r\n                } catch (IOException e) {\r\n                    logger.error(\"Error while retrieving cover for \" + artist + album, e);\r\n                }\r\n            }\r\n        } else if (backend == AUDIO_AMAZON) {\r\n            String url = \"http://www.amazon.com/gp/search/ref=sr_adv_m_pop/?search-alias=popular&unfiltered=1&field-keywords=&field-artist=\" + artist + \"&field-title=\" + album + \"&field-label=&field-binding=&sort=relevancerank&Adv-Srch-Music-Album-Submit.x=35&Adv-Srch-Music-Album-Submit.y=13\";\r\n            byte[] data = downloadAndSendBinary(url);\r\n            if (data != null) {\r\n                try {\r\n                    String html = new String(data, \"UTF-8\");\r\n                    int firstItem = html.indexOf(\"class=\\\"imageColumn\\\"\");\r\n                    if (firstItem > -1) {\r\n                        int imageUrlPos = html.indexOf(\"src=\\\"\", firstItem) + 5;\r\n                        String imageUrl = html.substring(imageUrlPos, html.indexOf(\"\\\" class\", imageUrlPos));\r\n                        data = downloadAndSendBinary(imageUrl);\r\n                        if (data != null) {\r\n                            covers.put(artist + album, data);\r\n                        } else {\r\n                            covers.put(artist + album, new byte[0]);\r\n                        }\r\n                        return data;\r\n                    }\r\n                } catch (IOException e) {\r\n                    logger.error(\"Error while retrieving cover for \" + artist + album, e);\r\n                }\r\n            }\r\n        }\r\n        covers.put(artist + album, new byte[0]);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "prefuse.Visualization.addTree",
	"Comment": "adds a tree to this visualization, using the given data groupname. a visual abstraction of the data will be created and registeredwith the visualization. an exception will be thrown if the group nameis already in use.",
	"Method": "VisualTree addTree(String group,Tree tree,VisualTree addTree,String group,Tree tree,Predicate filter,VisualTree addTree,String group,Tree tree,Predicate filter,Schema nodeSchema,Schema edgeSchema){\r\n    checkGroupExists(group);\r\n    String ngroup = PrefuseLib.getGroupName(group, Graph.NODES);\r\n    String egroup = PrefuseLib.getGroupName(group, Graph.EDGES);\r\n    VisualTable nt, et;\r\n    nt = addTable(ngroup, tree.getNodeTable(), filter, nodeSchema);\r\n    et = addTable(egroup, tree.getEdgeTable(), filter, edgeSchema);\r\n    VisualTree vt = new VisualTree(nt, et, tree.getNodeKeyField(), tree.getEdgeSourceField(), tree.getEdgeTargetField());\r\n    vt.setVisualization(this);\r\n    vt.setGroup(group);\r\n    addDataGroup(group, vt, tree);\r\n    TupleManager ntm = new TupleManager(nt, vt, TableNodeItem.class);\r\n    TupleManager etm = new TupleManager(et, vt, TableEdgeItem.class);\r\n    nt.setTupleManager(ntm);\r\n    et.setTupleManager(etm);\r\n    vt.setTupleManagers(ntm, etm);\r\n    return vt;\r\n}"
}, {
	"Path": "quickfix.MessageFactory.create",
	"Comment": "creates a message for a specified type, fix version, and applverid.",
	"Method": "Message create(String beginString,String msgType,Message create,String beginString,ApplVerID applVerID,String msgType,Group create,String beginString,String msgType,int correspondingFieldID){\r\n    return create(beginString, msgType);\r\n}"
}, {
	"Path": "picard.util.BaitDesigner.writeBaitFasta",
	"Comment": "writes a bait out in fasta format to an output bufferedwriter.",
	"Method": "void writeBaitFasta(BufferedWriter out,Interval i,boolean rc){\r\n    try {\r\n        final Bait bait = (Bait) i;\r\n        out.append(\">\");\r\n        out.append(bait.getName());\r\n        out.newLine();\r\n        final String sequence = getBaitSequence(bait, rc);\r\n        out.append(sequence);\r\n        out.newLine();\r\n    } catch (IOException ioe) {\r\n        throw new PicardException(\"Error writing out bait information.\", ioe);\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.SpanningTree.removeNode",
	"Comment": "unsupported operation. spanning trees should not be edited.",
	"Method": "boolean removeNode(int node,boolean removeNode,Node n){\r\n    throw new UnsupportedOperationException(\"Changes to graph structure not allowed for spanning trees.\");\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.cell.ShowMorePagerPanel.setIncrementSize",
	"Comment": "set the number of rows by which the range is increased when the scrollbarreaches the bottom.",
	"Method": "void setIncrementSize(int incrementSize){\r\n    this.incrementSize = incrementSize;\r\n}"
}, {
	"Path": "quickfix.mina.message.PatternMatcher.match",
	"Comment": "checks if the buffer contents at the given offset matches the pattern.",
	"Method": "int match(IoBuffer buffer,int offset){\r\n    if (offset + minLength > buffer.limit()) {\r\n        return -1;\r\n    }\r\n    final int startOffset = offset;\r\n    int patternOffset = 0;\r\n    for (int bufferLimit = buffer.limit(); patternOffset < pattern.length && offset < bufferLimit; patternOffset++, offset++) {\r\n        byte b = pattern[patternOffset];\r\n        if (buffer.get(offset) == b || b == '?')\r\n            continue;\r\n        if (b >= 'a' && b <= 'z') {\r\n            if (b - 'a' + 'A' != buffer.get(offset))\r\n                offset--;\r\n            continue;\r\n        }\r\n        return -1;\r\n    }\r\n    if (patternOffset != pattern.length) {\r\n        return -1;\r\n    }\r\n    return offset - startOffset;\r\n}"
}, {
	"Path": "picard.fingerprint.Fingerprint.filterSuspectSites",
	"Comment": "attempts to filter out haplotypes that may have suspect genotyping by removing haplotypes that reacha minimum confidence score yet have a significant fraction of observations from a third or fourth allele.",
	"Method": "void filterSuspectSites(){\r\n    final Iterator<Map.Entry<HaplotypeBlock, HaplotypeProbabilities>> iterator = entrySet().iterator();\r\n    while (iterator.hasNext()) {\r\n        final Map.Entry<HaplotypeBlock, HaplotypeProbabilities> entry = iterator.next();\r\n        final HaplotypeProbabilities p = entry.getValue();\r\n        if (p instanceof HaplotypeProbabilitiesFromSequence) {\r\n            final HaplotypeProbabilitiesFromSequence probs = (HaplotypeProbabilitiesFromSequence) p;\r\n            if (probs.getLodMostProbableGenotype() >= 3 && probs.getFractionUnexpectedAlleleObs() > 0.1) {\r\n                iterator.remove();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.data.io.TreeMLWriter.checkTreeMLSchema",
	"Comment": "checks if all schema types are compatible with the treeml specification.the treeml spec only allows the types int,long, float, double,boolean, string, and date.",
	"Method": "void checkTreeMLSchema(Schema s){\r\n    for (int i = 0; i < s.getColumnCount(); ++i) {\r\n        Class type = s.getColumnType(i);\r\n        if (TYPES.get(type) == null) {\r\n            throw new DataIOException(\"Data type unsupported by the \" + \"TreeML format: \" + type.getName());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "picard.sam.HitsForInsert.setPrimaryAlignment",
	"Comment": "used by primaryalignmentselectionstrategy to set all alignments to not primary, except for the one specified by the argument.if paired, and set the alignment for both ends if there is an alignment for both ends, otherwise just for the end for whichthere is an alignment at the given index.",
	"Method": "void setPrimaryAlignment(int primaryAlignmentIndex){\r\n    if (primaryAlignmentIndex < 0 || primaryAlignmentIndex >= this.numHits()) {\r\n        throw new IllegalArgumentException(\"primaryAlignmentIndex(\" + primaryAlignmentIndex + \") out of range for numHits(\" + numHits() + \")\");\r\n    }\r\n    for (int i = 0; i < this.numHits(); ++i) {\r\n        final boolean notPrimary = (i != primaryAlignmentIndex);\r\n        if (this.getFirstOfPair(i) != null) {\r\n            this.getFirstOfPair(i).setNotPrimaryAlignmentFlag(notPrimary);\r\n        }\r\n        if (this.getSecondOfPair(i) != null) {\r\n            this.getSecondOfPair(i).setNotPrimaryAlignmentFlag(notPrimary);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.ForceDirectedLayout.reset",
	"Comment": "reset the force simulation state for all nodes processedby this layout.",
	"Method": "void reset(){\r\n    Iterator iter = m_vis.visibleItems(m_nodeGroup);\r\n    while (iter.hasNext()) {\r\n        VisualItem item = (VisualItem) iter.next();\r\n        ForceItem fitem = (ForceItem) item.get(FORCEITEM);\r\n        if (fitem != null) {\r\n            fitem.location[0] = (float) item.getEndX();\r\n            fitem.location[1] = (float) item.getEndY();\r\n            fitem.force[0] = fitem.force[1] = 0;\r\n            fitem.velocity[0] = fitem.velocity[1] = 0;\r\n        }\r\n    }\r\n    m_lasttime = -1L;\r\n}"
}, {
	"Path": "prefuse.util.GraphLib.getDiamondTree",
	"Comment": "create a diamond tree, with a given branching factor ateach level, and depth levels for the two main branches.",
	"Method": "Tree getDiamondTree(int b,int d1,int d2){\r\n    Tree t = new Tree();\r\n    t.getNodeTable().addColumns(LABEL_SCHEMA);\r\n    Node r = t.addRoot();\r\n    r.setString(LABEL, \"0,0\");\r\n    Node left = t.addChild(r);\r\n    left.setString(LABEL, \"1,0\");\r\n    Node right = t.addChild(r);\r\n    right.setString(LABEL, \"1,1\");\r\n    deepHelper(t, left, b, d1 - 2, true);\r\n    deepHelper(t, right, b, d1 - 2, false);\r\n    while (left.getFirstChild() != null) left = left.getFirstChild();\r\n    while (right.getLastChild() != null) right = right.getLastChild();\r\n    deepHelper(t, left, b, d2 - 1, false);\r\n    deepHelper(t, right, b, d2 - 1, true);\r\n    return t;\r\n}"
}, {
	"Path": "picard.util.BaitDesigner.doWork",
	"Comment": "main method that coordinates the checking of inputs, designing of baits and thenthe writing out of all necessary files.",
	"Method": "int doWork(){\r\n    if (OUTPUT_DIRECTORY == null)\r\n        OUTPUT_DIRECTORY = new File(DESIGN_NAME);\r\n    IOUtil.assertFileIsReadable(TARGETS);\r\n    IOUtil.assertFileIsReadable(REFERENCE_SEQUENCE);\r\n    if (!OUTPUT_DIRECTORY.exists()) {\r\n        OUTPUT_DIRECTORY.mkdirs();\r\n    }\r\n    IOUtil.assertDirectoryIsWritable(OUTPUT_DIRECTORY);\r\n    final IntervalList targets;\r\n    final IntervalList originalTargets = IntervalList.fromFile(TARGETS);\r\n    {\r\n        final IntervalList padded = new IntervalList(originalTargets.getHeader());\r\n        final SAMSequenceDictionary dict = padded.getHeader().getSequenceDictionary();\r\n        for (final Interval i : originalTargets.getIntervals()) {\r\n            padded.add(new Interval(i.getContig(), Math.max(i.getStart() - PADDING, 1), Math.min(i.getEnd() + PADDING, dict.getSequence(i.getContig()).getSequenceLength()), i.isNegativeStrand(), i.getName()));\r\n        }\r\n        log.info(\"Starting with \" + padded.size() + \" targets.\");\r\n        padded.uniqued();\r\n        log.info(\"After uniquing \" + padded.size() + \" targets remain.\");\r\n        if (MERGE_NEARBY_TARGETS) {\r\n            final ListIterator<Interval> iterator = padded.getIntervals().listIterator();\r\n            Interval previous = iterator.next();\r\n            targets = new IntervalList(padded.getHeader());\r\n            while (iterator.hasNext()) {\r\n                final Interval next = iterator.next();\r\n                if (previous.getContig().equals(next.getContig()) && estimateBaits(previous.getStart(), previous.getEnd()) + estimateBaits(next.getStart(), next.getEnd()) >= estimateBaits(previous.getStart(), next.getEnd())) {\r\n                    previous = new Interval(previous.getContig(), previous.getStart(), Math.max(previous.getEnd(), next.getEnd()), previous.isNegativeStrand(), previous.getName());\r\n                } else {\r\n                    targets.add(previous);\r\n                    previous = next;\r\n                }\r\n            }\r\n            if (previous != null)\r\n                targets.add(previous);\r\n            log.info(\"After collapsing nearby targets \" + targets.size() + \" targets remain.\");\r\n        } else {\r\n            targets = padded;\r\n        }\r\n    }\r\n    final ReferenceSequenceFileWalker referenceWalker = new ReferenceSequenceFileWalker(REFERENCE_SEQUENCE);\r\n    SequenceUtil.assertSequenceDictionariesEqual(referenceWalker.getSequenceDictionary(), targets.getHeader().getSequenceDictionary());\r\n    int discardedBaits = 0;\r\n    final IntervalList baits = new IntervalList(targets.getHeader());\r\n    for (final Interval target : targets) {\r\n        final int sequenceIndex = targets.getHeader().getSequenceIndex(target.getContig());\r\n        final ReferenceSequence reference = referenceWalker.get(sequenceIndex);\r\n        for (final Bait bait : DESIGN_STRATEGY.design(this, target, reference)) {\r\n            if (bait.length() != BAIT_SIZE) {\r\n                throw new PicardException(\"Bait designed at wrong length: \" + bait);\r\n            }\r\n            if (bait.getMaskedBaseCount() <= REPEAT_TOLERANCE) {\r\n                baits.add(bait);\r\n                for (final byte b : bait.getBases()) {\r\n                    final byte upper = StringUtil.toUpperCase(b);\r\n                    if (upper != 'A' && upper != 'C' && upper != 'G' && upper != 'T') {\r\n                        log.warn(\"Bait contains non-synthesizable bases: \" + bait);\r\n                    }\r\n                }\r\n            } else {\r\n                log.debug(\"Discarding bait: \" + bait);\r\n                discardedBaits++;\r\n            }\r\n        }\r\n    }\r\n    calculateStatistics(targets, baits);\r\n    log.info(\"Designed and kept \" + baits.size() + \" baits, discarded \" + discardedBaits);\r\n    originalTargets.write(new File(OUTPUT_DIRECTORY, DESIGN_NAME + \".targets.interval_list\"));\r\n    baits.write(new File(OUTPUT_DIRECTORY, DESIGN_NAME + \".baits.interval_list\"));\r\n    writeParametersFile(new File(OUTPUT_DIRECTORY, DESIGN_NAME + \".design_parameters.txt\"));\r\n    writeDesignFastaFile(new File(OUTPUT_DIRECTORY, DESIGN_NAME + \".design.fasta\"), baits);\r\n    if (POOL_SIZE > 0)\r\n        writePoolFiles(OUTPUT_DIRECTORY, DESIGN_NAME, baits);\r\n    return 0;\r\n}"
}, {
	"Path": "picard.sam.DownsampleSamTest.setupBuilder",
	"Comment": "create a samfile with one tile and randomly placed reads within it.",
	"Method": "void setupBuilder(){\r\n    final int numReads = 10000;\r\n    final String flowCellBarcode = \"TESTBARCODE\";\r\n    final String separator = \":\";\r\n    final int lane = 1;\r\n    final int tile = 2203;\r\n    final Random rg = new Random(31);\r\n    setBuilder.setReadGroup(readGroupRecord);\r\n    setBuilder.setUseNmFlag(true);\r\n    for (int i = 0; i < numReads; i++) {\r\n        final String readName = flowCellBarcode + separator + lane + separator + tile + separator + i;\r\n        setBuilder.addPair(readName, 1, 1, 100);\r\n    }\r\n    tempDir = IOUtil.createTempDir(\"ds_test\", \"Downsampling\");\r\n    tempSamFile = File.createTempFile(\"DownsampleSam\", \".bam\", tempDir);\r\n    BufferedLineReader bufferedLineReader = null;\r\n    try {\r\n        bufferedLineReader = new BufferedLineReader(new FileInputStream(dict));\r\n    } catch (FileNotFoundException e) {\r\n        e.printStackTrace();\r\n    }\r\n    final SAMTextHeaderCodec codec = new SAMTextHeaderCodec();\r\n    final SAMFileHeader header = codec.decode(bufferedLineReader, dict.toString());\r\n    readGroupRecord.setSample(sample);\r\n    readGroupRecord.setPlatform(platform);\r\n    readGroupRecord.setLibrary(library);\r\n    header.setSortOrder(SAMFileHeader.SortOrder.coordinate);\r\n    header.addReadGroup(readGroupRecord);\r\n    setBuilder.setHeader(header);\r\n    final SAMFileWriter writer = new SAMFileWriterFactory().setCreateIndex(true).makeBAMWriter(header, false, tempSamFile);\r\n    for (final SAMRecord record : setBuilder) {\r\n        writer.addAlignment(record);\r\n    }\r\n    writer.close();\r\n}"
}, {
	"Path": "picard.sam.FastqToSam.createSamFileHeader",
	"Comment": "creates a simple header with the values provided on the command line.",
	"Method": "SAMFileHeader createSamFileHeader(){\r\n    final SAMReadGroupRecord rgroup = new SAMReadGroupRecord(this.READ_GROUP_NAME);\r\n    rgroup.setSample(this.SAMPLE_NAME);\r\n    if (this.LIBRARY_NAME != null)\r\n        rgroup.setLibrary(this.LIBRARY_NAME);\r\n    if (this.PLATFORM != null)\r\n        rgroup.setPlatform(this.PLATFORM);\r\n    if (this.PLATFORM_UNIT != null)\r\n        rgroup.setPlatformUnit(this.PLATFORM_UNIT);\r\n    if (this.SEQUENCING_CENTER != null)\r\n        rgroup.setSequencingCenter(SEQUENCING_CENTER);\r\n    if (this.PREDICTED_INSERT_SIZE != null)\r\n        rgroup.setPredictedMedianInsertSize(PREDICTED_INSERT_SIZE);\r\n    if (this.DESCRIPTION != null)\r\n        rgroup.setDescription(this.DESCRIPTION);\r\n    if (this.RUN_DATE != null)\r\n        rgroup.setRunDate(this.RUN_DATE);\r\n    if (this.PLATFORM_MODEL != null)\r\n        rgroup.setPlatformModel(this.PLATFORM_MODEL);\r\n    if (this.PROGRAM_GROUP != null)\r\n        rgroup.setProgramGroup(this.PROGRAM_GROUP);\r\n    final SAMFileHeader header = new SAMFileHeader();\r\n    header.addReadGroup(rgroup);\r\n    for (final String comment : COMMENT) {\r\n        header.addComment(comment);\r\n    }\r\n    header.setSortOrder(this.SORT_ORDER);\r\n    return header;\r\n}"
}, {
	"Path": "picard.sam.AbstractAlignmentMerger.removeNmMdAndUqTags",
	"Comment": "removes the nm, md, and uq tags.this is useful if we modify the read and are not able to recompute these tags,for example when no reference is available.",
	"Method": "void removeNmMdAndUqTags(SAMRecord rec){\r\n    rec.setAttribute(SAMTag.NM.name(), null);\r\n    rec.setAttribute(SAMTag.MD.name(), null);\r\n    rec.setAttribute(SAMTag.UQ.name(), null);\r\n}"
}, {
	"Path": "prefuse.data.expression.FunctionTable.hasFunction",
	"Comment": "indicates if a function of the given name is included in the functiontable.",
	"Method": "boolean hasFunction(String name){\r\n    return s_functionTable.containsKey(name);\r\n}"
}, {
	"Path": "net.pms.xmlwise.Plist.parse",
	"Comment": "parses a plist top element into a map dictionary containing all the data\tin the plist.",
	"Method": "Map<String, Object> parse(XmlElement element){\r\n    if (!\"plist\".equalsIgnoreCase(element.getName())) {\r\n        throw new XmlParseException(\"Expected plist top element, was: \" + element.getName());\r\n    }\r\n    if (element.size() != 1) {\r\n        throw new XmlParseException(\"Expected single 'dict' child element.\");\r\n    }\r\n    element.getUnique(\"dict\");\r\n    return (Map<String, Object>) parseElement(element.getUnique(\"dict\"));\r\n}"
}, {
	"Path": "prefuse.data.Graph.edges",
	"Comment": "get an iterator over all edges connected to the given node in the graph.",
	"Method": "Iterator edges(Iterator edges,Node node){\r\n    nodeCheck(node, true);\r\n    return m_edgeTuples.iterator(edgeRows(node.getRow(), UNDIRECTED));\r\n}"
}, {
	"Path": "prefuse.util.collections.CopyOnWriteArrayList.containsAll",
	"Comment": "returns true if this list contains all of the elements of thespecified collection.",
	"Method": "boolean containsAll(Collection c){\r\n    Object[] elements = getArray();\r\n    int len = elements.length;\r\n    for (Iterator itr = c.iterator(); itr.hasNext(); ) {\r\n        Object e = itr.next();\r\n        if (indexOf(e, elements, 0, len) < 0)\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.setSkipTranscode",
	"Comment": "set to true if transcoding should be skipped for this resource.",
	"Method": "void setSkipTranscode(boolean skipTranscode){\r\n    this.skipTranscode = skipTranscode;\r\n}"
}, {
	"Path": "prefuse.activity.ActivityMap.remove",
	"Comment": "removes a mapping from this activitymap. the parent map, if any,is not effected by this method.",
	"Method": "void remove(Object key){\r\n    m_map.remove(key);\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.getImageThumbnailsEnabled",
	"Comment": "returns true if pms should generate thumbnails for images. default value\tis true.",
	"Method": "boolean getImageThumbnailsEnabled(){\r\n    return getBoolean(KEY_IMAGE_THUMBNAILS_ENABLED, true);\r\n}"
}, {
	"Path": "picard.util.CircularByteBuffer.getBytesAvailableToRead",
	"Comment": "returns the number of bytes that are in the buffer at the time of the method invocation.",
	"Method": "int getBytesAvailableToRead(){\r\n    return this.bytesAvailableToRead;\r\n}"
}, {
	"Path": "prefuse.Display.zoomAbs",
	"Comment": "zooms the view provided by this display by the given scale,anchoring the zoom at the specified point in absolute coordinates.",
	"Method": "void zoomAbs(Point2D p,double scale){\r\n    ;\r\n    double zx = p.getX(), zy = p.getY();\r\n    damageReport();\r\n    m_transform.translate(zx, zy);\r\n    m_transform.scale(scale, scale);\r\n    m_transform.translate(-zx, -zy);\r\n    try {\r\n        m_itransform = m_transform.createInverse();\r\n    } catch (Exception e) {\r\n    }\r\n}"
}, {
	"Path": "quickfix.Session.setResponder",
	"Comment": "registers a responder with the session. this is used by the acceptor andinitiator implementations.",
	"Method": "void setResponder(Responder responder){\r\n    synchronized (responderLock) {\r\n        this.responder = responder;\r\n        if (responder != null) {\r\n            stateListener.onConnect();\r\n        } else {\r\n            stateListener.onDisconnect();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Base64Coder.decodeString",
	"Comment": "decodes a string from base64 format. no blanks or line breaks are allowed within the base64 encoded input data.",
	"Method": "String decodeString(String s,String decodeString,String s,boolean useUrlSafeEncoding){\r\n    return new String(decode(s.toCharArray(), useUrlSafeEncoding ? urlsafeMap.decodingMap : regularMap.decodingMap));\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.lists.CwStackLayoutPanel.createHeaderWidget",
	"Comment": "create a widget to display in the header that includes an image and sometext.",
	"Method": "Widget createHeaderWidget(String text,ImageResource image){\r\n    HorizontalPanel hPanel = new HorizontalPanel();\r\n    hPanel.setHeight(\"100%\");\r\n    hPanel.setSpacing(0);\r\n    hPanel.setVerticalAlignment(HasVerticalAlignment.ALIGN_MIDDLE);\r\n    hPanel.add(new Image(image));\r\n    HTML headerText = new HTML(text);\r\n    headerText.setStyleName(\"cw-StackPanelHeader\");\r\n    hPanel.add(headerText);\r\n    return new SimplePanel(hPanel);\r\n}"
}, {
	"Path": "picard.analysis.TheoreticalSensitivityTest.testCentralLimitTheorem",
	"Comment": "using the empirical cdf as measured by proportionsabovethresholds",
	"Method": "void testCentralLimitTheorem(){\r\n    final double[] weights = { 1.0, 1.0, 1.0 };\r\n    final TheoreticalSensitivity.RouletteWheel wheel = new TheoreticalSensitivity.RouletteWheel(weights);\r\n    final int sampleSize = 1000;\r\n    final int numSummands = 100;\r\n    final double muSingleDraw = 1.0;\r\n    final double sigmaSingleDraw = Math.sqrt(2.0 / 3.0);\r\n    final double mu = numSummands * muSingleDraw;\r\n    final double sigma = Math.sqrt(numSummands) * sigmaSingleDraw;\r\n    final List<ArrayList<Integer>> sums = wheel.sampleCumulativeSums(numSummands, sampleSize, false);\r\n    sums.subList(0, sums.size() - 1).clear();\r\n    Assert.assertEquals(sums.size(), 1);\r\n    final List<Double> thresholds = Arrays.asList(mu - sigma, mu + sigma);\r\n    final List<ArrayList<Double>> proportions = TheoreticalSensitivity.proportionsAboveThresholds(sums, thresholds);\r\n    final double empiricalProportionWithinOneSigma = proportions.get(0).get(0) - proportions.get(0).get(1);\r\n    final double theoreticalProportionWithinOneSigma = 0.682689492;\r\n    final double samplingStandardDeviationOfProportion = Math.sqrt(theoreticalProportionWithinOneSigma * (1 - theoreticalProportionWithinOneSigma) / sampleSize);\r\n    Assert.assertEquals(empiricalProportionWithinOneSigma, theoreticalProportionWithinOneSigma, 5 * samplingStandardDeviationOfProportion);\r\n}"
}, {
	"Path": "net.pms.formats.Format.setMatchedExtension",
	"Comment": "sets the extension or protocol that was matched\tfor a particular filename or url.",
	"Method": "void setMatchedExtension(String extension){\r\n    matchedExtension = extension;\r\n}"
}, {
	"Path": "prefuse.Visualization.setInteractive",
	"Comment": "sets the interactivity status for all items in a given data groupmatching a given filter predicate.",
	"Method": "void setInteractive(String group,Predicate p,boolean value){\r\n    Iterator items = items(group, p);\r\n    while (items.hasNext()) {\r\n        VisualItem item = (VisualItem) items.next();\r\n        item.setInteractive(value);\r\n    }\r\n}"
}, {
	"Path": "com.egzosn.pay.paypal.bean.order.RedirectUrls.getReturnUrl",
	"Comment": "url where the payer would be redirected to after approving the payment. required for paypal account payments.",
	"Method": "String getReturnUrl(){\r\n    return this.returnUrl;\r\n}"
}, {
	"Path": "prefuse.action.assignment.ShapeAction.setDefaultShape",
	"Comment": "sets the default shape value assigned to items. items will be assignedthe default shape if they do not match any registered rules.",
	"Method": "void setDefaultShape(int defaultShape){\r\n    m_defaultShape = defaultShape;\r\n}"
}, {
	"Path": "picard.illumina.parser.BclParserTest.eamssTestDat",
	"Comment": "for more information on eamss check bclparser and the large comment above runeamssforreadinplace",
	"Method": "Object[][] eamssTestDat(){\r\n    return new Object[][] { { new BasesAndQuals(new byte[] { A, C, G, G, T, G, G, G, G, G, G, G, G, G, A, C, T }, new byte[] { 7, 8, 33, 7, 12, 33, 16, 17, 2, 2, 32, 35, 35, 35, 2, 15, 9 }, 5) }, { new BasesAndQuals(new byte[] { A, C, G, G, T, G, G, G, G, G, G, G, G, G, A, C, T }, new byte[] { 7, 8, 2, 7, 2, 2, 16, 17, 2, 2, 32, 35, 35, 35, 2, 15, 9 }, 0) }, { new BasesAndQuals(new byte[] { A, C, G, G, T, G, G, G, G, G, G, G, G, G, A, C, T }, new byte[] { 7, 8, 2, 7, 2, 2, 16, 17, 2, 2, 32, 35, 35, 35, 33, 15, 9 }, 15) }, { new BasesAndQuals(new byte[] { A, C, C, G, C, C, G, G, G, G, G, G, G, G, G, G, T, T, A }, new byte[] { 33, 31, 29, 32, 28, 27, 30, 18, 18, 18, 18, 19, 19, 19, 33, 18, 9, 9, 19 }, 6) }, { new BasesAndQuals(new byte[] { A, C, C, G, C, C, G, G, G, G, G, G, G, G, G, G, T, T, A }, new byte[] { 33, 31, 29, 32, 28, 27, 30, 18, 18, 18, 18, 19, 19, 19, 33, 18, 33, 32, 34 }, null) }, { new BasesAndQuals(new byte[] { A, C, C, G, C, C, G, G, G, G, A, G, G, G, G, G, T, T, A }, new byte[] { 33, 31, 29, 32, 28, 27, 30, 18, 18, 18, 18, 19, 19, 19, 33, 18, 9, 9, 19 }, 6) }, { new BasesAndQuals(new byte[] { A, C, G, G, G, C, G, G, G, G, G, G, G, G, G, G, T, T, A }, new byte[] { 33, 31, 29, 32, 28, 16, 33, 18, 18, 18, 18, 19, 19, 19, 33, 18, 3, 9, 19 }, 2) }, { new BasesAndQuals(new byte[] { A, C, G, G, C, C, G, G, G, G, G, G, G, G, G, G, G, G, G }, new byte[] { 33, 31, 29, 32, 28, 16, 33, 18, 18, 18, 18, 19, 19, 19, 33, 34, 33, 33, 3 }, 6) }, { new BasesAndQuals(new byte[] { A, C, G, G, C, C, G, G, G, G, G, G, G, G, G, G, G, G, G, T, A, C, T, T, G, G, G, G, G, G, G, G, G, G, G, G, G }, new byte[] { 33, 31, 29, 32, 28, 16, 33, 18, 18, 18, 18, 19, 19, 19, 33, 34, 33, 33, 3, 33, 34, 2, 4, 8, 33, 7, 35, 15, 16, 31, 30, 38, 16, 15, 22, 29, 25 }, null) } };\r\n}"
}, {
	"Path": "com.restfb.json.JsonArray.get",
	"Comment": "returns the value of the element at the specified position in this array.",
	"Method": "JsonValue get(int index){\r\n    return values.get(index);\r\n}"
}, {
	"Path": "prefuse.data.Graph.addEdge",
	"Comment": "add an edge to the graph. both multiple edges between two nodesand edges from a node to itself are allowed.",
	"Method": "int addEdge(int s,int t,Edge addEdge,Node s,Node t){\r\n    nodeCheck(s, true);\r\n    nodeCheck(t, true);\r\n    int e = addEdge(s.getRow(), t.getRow());\r\n    return getEdge(e);\r\n}"
}, {
	"Path": "prefuse.visual.VisualTable.fireTableEvent",
	"Comment": "relay table events. ensures that updated visual items are invalidatedand that damage reports are issued for deleted items.",
	"Method": "void fireTableEvent(int row0,int row1,int col,int type){\r\n    if (type == EventConstants.UPDATE) {\r\n        if (col != VisualItem.IDX_VALIDATED) {\r\n            for (int r = row0; r <= row1; ++r) setValidated(r, false);\r\n        } else {\r\n            for (int r = row0; r <= row1; ++r) {\r\n                if (!isValidated(r)) {\r\n                    m_vis.damageReport(getItem(r), getBounds(r));\r\n                }\r\n            }\r\n        }\r\n    } else if (type == EventConstants.DELETE && col == EventConstants.ALL_COLUMNS) {\r\n        for (int r = row0; r <= row1; ++r) {\r\n            if (isVisible(r) && isValidated(r)) {\r\n                VisualItem item = (VisualItem) getTuple(r);\r\n                m_vis.damageReport(item, getBounds(r));\r\n            }\r\n        }\r\n    }\r\n    super.fireTableEvent(row0, row1, col, type);\r\n}"
}, {
	"Path": "net.pms.dlna.virtual.VirtualVideoAction.isTranscodeFolderAvailable",
	"Comment": "returns false because this virtual video action should not\tappear in the transcode folder.",
	"Method": "boolean isTranscodeFolderAvailable(){\r\n    return false;\r\n}"
}, {
	"Path": "picard.illumina.parser.FilterParser.makeTileIterator",
	"Comment": "wrap a filterfile reader in a closeable iterator and return it",
	"Method": "CloseableIterator<PfData> makeTileIterator(File iterator){\r\n    return new CloseableIterator<PfData>() {\r\n        private FilterFileReader reader = new FilterFileReader(iterator);\r\n        public void close() {\r\n            reader = null;\r\n        }\r\n        public boolean hasNext() {\r\n            return reader.hasNext();\r\n        }\r\n        public PfData next() {\r\n            final boolean nextValue = reader.next();\r\n            return new PfData() {\r\n                public boolean isPfRead() {\r\n                    return nextValue;\r\n                }\r\n            };\r\n        }\r\n        public void remove() {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "picard.illumina.parser.FilterParser.makeTileIterator",
	"Comment": "wrap a filterfile reader in a closeable iterator and return it",
	"Method": "CloseableIterator<PfData> makeTileIterator(File iterator){\r\n    reader = null;\r\n}"
}, {
	"Path": "picard.illumina.parser.FilterParser.makeTileIterator",
	"Comment": "wrap a filterfile reader in a closeable iterator and return it",
	"Method": "CloseableIterator<PfData> makeTileIterator(File iterator){\r\n    return reader.hasNext();\r\n}"
}, {
	"Path": "picard.illumina.parser.FilterParser.makeTileIterator",
	"Comment": "wrap a filterfile reader in a closeable iterator and return it",
	"Method": "CloseableIterator<PfData> makeTileIterator(File iterator){\r\n    final boolean nextValue = reader.next();\r\n    return new PfData() {\r\n        public boolean isPfRead() {\r\n            return nextValue;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "picard.illumina.parser.FilterParser.makeTileIterator",
	"Comment": "wrap a filterfile reader in a closeable iterator and return it",
	"Method": "CloseableIterator<PfData> makeTileIterator(File iterator){\r\n    return nextValue;\r\n}"
}, {
	"Path": "picard.illumina.parser.FilterParser.makeTileIterator",
	"Comment": "wrap a filterfile reader in a closeable iterator and return it",
	"Method": "CloseableIterator<PfData> makeTileIterator(File iterator){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "picard.sam.markduplicates.util.ReadEnds.getOrientationByte",
	"Comment": "returns a single byte that encodes the orientation of the two reads in a pair.",
	"Method": "byte getOrientationByte(boolean read1NegativeStrand,boolean read2NegativeStrand){\r\n    if (read1NegativeStrand) {\r\n        if (read2NegativeStrand)\r\n            return ReadEnds.RR;\r\n        else\r\n            return ReadEnds.RF;\r\n    } else {\r\n        if (read2NegativeStrand)\r\n            return ReadEnds.FR;\r\n        else\r\n            return ReadEnds.FF;\r\n    }\r\n}"
}, {
	"Path": "picard.fingerprint.FingerprintChecker.getFingerprintFromVc",
	"Comment": "adds the fingerprints found in the variant context to the map.",
	"Method": "void getFingerprintFromVc(Map<String, Fingerprint> fingerprints,VariantContext ctx){\r\n    final HaplotypeBlock h = this.haplotypes.getHaplotype(ctx.getContig(), ctx.getStart());\r\n    if (h == null)\r\n        return;\r\n    final Snp snp = this.haplotypes.getSnp(ctx.getContig(), ctx.getStart());\r\n    final VariantContext usableSnp = AlleleSubsettingUtils.subsetVCToMatchSnp(ctx, snp);\r\n    if (usableSnp == null) {\r\n        return;\r\n    }\r\n    {\r\n        boolean allelesOk = true;\r\n        for (final Allele allele : usableSnp.getAlleles()) {\r\n            final byte[] bases = allele.getBases();\r\n            if (bases.length > 1 || (bases[0] != snp.getAllele1() && bases[0] != snp.getAllele2())) {\r\n                allelesOk = false;\r\n            }\r\n        }\r\n        if (!allelesOk) {\r\n            log.warn(\"Problem with genotype file: Alleles \" + usableSnp.getAlleles() + \" do not match to alleles for SNP \" + snp + \" with alleles \" + snp.getAlleleString());\r\n            throw new IllegalArgumentException(\"Alleles do not match between database and file\");\r\n        }\r\n    }\r\n    for (final String sample : fingerprints.keySet()) {\r\n        final Fingerprint fp = fingerprints.get(sample);\r\n        final Genotype genotype = usableSnp.getGenotype(sample);\r\n        if (genotype == null) {\r\n            throw new IllegalArgumentException(\"Cannot find sample \" + sample + \" in provided file. \");\r\n        }\r\n        if (genotype.hasPL()) {\r\n            final HaplotypeProbabilitiesFromGenotypeLikelihoods hFp = new HaplotypeProbabilitiesFromGenotypeLikelihoods(h);\r\n            final int[] pls = genotype.getPL();\r\n            final int[] newPLs = new int[pls.length];\r\n            for (int i = 0; i < pls.length; i++) {\r\n                newPLs[i] = Math.min(maximalPLDifference, pls[i]);\r\n            }\r\n            hFp.addToLogLikelihoods(snp, usableSnp.getAlleles(), GenotypeLikelihoods.fromPLs(newPLs).getAsVector());\r\n            fp.add(hFp);\r\n        } else {\r\n            if (genotype.isNoCall())\r\n                continue;\r\n            if (fp.containsKey(h))\r\n                continue;\r\n            final boolean hom = genotype.isHom();\r\n            final byte allele = StringUtil.toUpperCase(genotype.getAllele(0).getBases()[0]);\r\n            final double halfError = this.genotypingErrorRate / 2;\r\n            final double accuracy = 1 - this.genotypingErrorRate;\r\n            final double[] probs = new double[] { (hom && allele == snp.getAllele1()) ? accuracy : halfError, (!hom) ? accuracy : halfError, (hom && allele == snp.getAllele2()) ? accuracy : halfError };\r\n            fp.add(new HaplotypeProbabilitiesFromGenotype(snp, h, probs[0], probs[1], probs[2]));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "picard.fingerprint.FingerprintChecker.checkFingerprints",
	"Comment": "top level method to take a set of one or more sam files and one or more genotype files and compareeach read group in each sam file to each set of fingerprint genotypes.",
	"Method": "List<FingerprintResults> checkFingerprints(List<Path> samFiles,List<Path> genotypeFiles,String specificSample,boolean ignoreReadGroups){\r\n    final List<Fingerprint> expectedFingerprints = new LinkedList();\r\n    for (final Path p : genotypeFiles) {\r\n        expectedFingerprints.addAll(loadFingerprints(p, specificSample).values());\r\n    }\r\n    if (expectedFingerprints.isEmpty()) {\r\n        throw new IllegalStateException(\"Could not find any fingerprints in: \" + genotypeFiles);\r\n    }\r\n    final List<FingerprintResults> resultsList = new ArrayList();\r\n    final IntervalList intervals = getLociToGenotype(expectedFingerprints);\r\n    for (final Path p : samFiles) {\r\n        final Map<FingerprintIdDetails, Fingerprint> fingerprintsByReadGroup = fingerprintSamFile(p, intervals);\r\n        if (ignoreReadGroups) {\r\n            final Fingerprint combinedFp = new Fingerprint(specificSample, p, null);\r\n            fingerprintsByReadGroup.values().forEach(combinedFp::merge);\r\n            final FingerprintResults results = new FingerprintResults(p, null, specificSample);\r\n            for (final Fingerprint expectedFp : expectedFingerprints) {\r\n                final MatchResults result = calculateMatchResults(combinedFp, expectedFp, 0, pLossofHet);\r\n                results.addResults(result);\r\n            }\r\n            resultsList.add(results);\r\n        } else {\r\n            for (final FingerprintIdDetails rg : fingerprintsByReadGroup.keySet()) {\r\n                final FingerprintResults results = new FingerprintResults(p, rg.platformUnit, rg.sample);\r\n                for (final Fingerprint expectedFp : expectedFingerprints) {\r\n                    final MatchResults result = calculateMatchResults(fingerprintsByReadGroup.get(rg), expectedFp, 0, pLossofHet);\r\n                    results.addResults(result);\r\n                }\r\n                resultsList.add(results);\r\n            }\r\n        }\r\n    }\r\n    return resultsList;\r\n}"
}, {
	"Path": "prefuse.data.util.FilteredRowManager.getChildRow",
	"Comment": "given a row in the parent table, return the corresponding row managedby this manager.",
	"Method": "int getChildRow(int parentRow){\r\n    int val = m_parentToChild.get(parentRow);\r\n    return (val == Integer.MIN_VALUE ? -1 : val);\r\n}"
}, {
	"Path": "net.paoding.rose.jade.context.spring.JadeComponentProvider.addExcludeFilter",
	"Comment": "add an exclude type filter to the front of the exclusionlist.",
	"Method": "void addExcludeFilter(TypeFilter excludeFilter){\r\n    this.excludeFilters.add(0, excludeFilter);\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setForcedSubtitleTags",
	"Comment": "sets the tag string that identifies the subtitle language that\tshould be forced.",
	"Method": "void setForcedSubtitleTags(String value){\r\n    configuration.setProperty(KEY_FORCED_SUBTITLE_TAGS, value);\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.setLastModified",
	"Comment": "sets the timestamp at which this resource was last modified.",
	"Method": "void setLastModified(long lastModified){\r\n    this.lastmodified = lastModified;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.setMencoderUsePcmForHQAudioOnly",
	"Comment": "sets whether or not the pulse code modulation audio format should be\tused only for hq audio codecs.",
	"Method": "void setMencoderUsePcmForHQAudioOnly(boolean value){\r\n    configuration.setProperty(KEY_MENCODER_USE_PCM_FOR_HQ_AUDIO_ONLY, value);\r\n}"
}, {
	"Path": "prefuse.data.Graph.getDegree",
	"Comment": "get the degree of a node, the number of edges for which a nodeis either the source or the target.",
	"Method": "int getDegree(int node,int getDegree,Node n){\r\n    nodeCheck(n, true);\r\n    return getDegree(n.getRow());\r\n}"
}, {
	"Path": "prefuse.render.EdgeRenderer.setHorizontalAlignment2",
	"Comment": "set the horizontal aligment of the edge mount point with the secondnode.",
	"Method": "void setHorizontalAlignment2(int align){\r\n    m_xAlign2 = align;\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.FruchtermanReingoldLayout.setMaxIterations",
	"Comment": "set the maximum number of iterations to run of this algorithm.",
	"Method": "void setMaxIterations(int maxIter){\r\n    this.maxIter = maxIter;\r\n}"
}, {
	"Path": "prefuse.render.EdgeRenderer.setHorizontalAlignment1",
	"Comment": "set the horizontal aligment of the edge mount point with the first node.",
	"Method": "void setHorizontalAlignment1(int align){\r\n    m_xAlign1 = align;\r\n}"
}, {
	"Path": "prefuse.util.force.ForceSimulator.getForces",
	"Comment": "get an array of all the force functions used in this simulator.",
	"Method": "Force[] getForces(){\r\n    Force[] rv = new Force[iflen + sflen];\r\n    System.arraycopy(iforces, 0, rv, 0, iflen);\r\n    System.arraycopy(sforces, 0, rv, iflen, sflen);\r\n    return rv;\r\n}"
}, {
	"Path": "picard.sam.CleanSamTest.testCleanSamTester",
	"Comment": "identical test case using the samfiletester to generate that sam file on the fly",
	"Method": "void testCleanSamTester(String originalCigar,String expectedCigar,int defaultChromosomeLength,int alignStart){\r\n    final CleanSamTester cleanSamTester = new CleanSamTester(expectedCigar, 100, defaultChromosomeLength);\r\n    cleanSamTester.addMappedPair(0, alignStart, alignStart, false, false, originalCigar, originalCigar, false, 50);\r\n    cleanSamTester.runTest();\r\n}"
}, {
	"Path": "prefuse.data.search.KeywordSearchTupleSet.getDocument",
	"Comment": "create a lucene document instance with the given document id and text.",
	"Method": "Document getDocument(int id,String text){\r\n    Document d = new Document();\r\n    d.add(Field.Text(LuceneSearcher.FIELD, text, m_storeTermVectors));\r\n    d.add(Field.Keyword(LuceneSearcher.ID, String.valueOf(id)));\r\n    return d;\r\n}"
}, {
	"Path": "prefuse.activity.ActivityManager.cancelActivity",
	"Comment": "cancels an activity and removes it from this manager, called byan activity when the activity needs to be cancelled.",
	"Method": "void cancelActivity(Activity a){\r\n    getInstance()._cancelActivity(a);\r\n}"
}, {
	"Path": "prefuse.data.Table.canSetLong",
	"Comment": "check if the setlong method can safely be used for thegiven data field.",
	"Method": "boolean canSetLong(String field){\r\n    Column col = getColumn(field);\r\n    return (col == null ? false : col.canSetLong());\r\n}"
}, {
	"Path": "prefuse.util.collections.CopyOnWriteArrayList.retainAll",
	"Comment": "retains only the elements in this list that are contained in thespecified collection.in other words, removes from this list all ofits elements that are not contained in the specified collection.",
	"Method": "boolean retainAll(Collection c){\r\n    Object[] elements = getArray();\r\n    int len = elements.length;\r\n    if (len != 0) {\r\n        int newlen = 0;\r\n        Object[] temp = new Object[len];\r\n        for (int i = 0; i < len; ++i) {\r\n            Object element = elements[i];\r\n            if (c.contains(element))\r\n                temp[newlen++] = element;\r\n        }\r\n        if (newlen != len) {\r\n            setArray(copyOfRange(temp, 0, newlen, Object[].class));\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "quickfix.mina.SessionConnector.isLoggedOn",
	"Comment": "check if we have at least one session and that all the sessions are logged on",
	"Method": "boolean isLoggedOn(){\r\n    if (sessions.isEmpty())\r\n        return false;\r\n    for (Session session : sessions.values()) {\r\n        if (!session.isLoggedOn())\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.removeColumnListener",
	"Comment": "removes a listener, causing it to no longer be notified of changes",
	"Method": "void removeColumnListener(ColumnListener listener){\r\n    m_listeners.remove(listener);\r\n}"
}, {
	"Path": "net.pms.util.KeyedComboBoxModel.findElementIndex",
	"Comment": "tries to find the index of element with the given key. the key must not\tbe null.",
	"Method": "int findElementIndex(Object key){\r\n    if (key == null) {\r\n        throw new NullPointerException(\"Item to find must not be null\");\r\n    }\r\n    for (int i = 0; i < data.size(); i++) {\r\n        final ComboBoxItemPair datacon = data.get(i);\r\n        if (key.equals(datacon.getValue())) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "prefuse.activity.ActivityMap.keys",
	"Comment": "returns an array consisting of all the keys associated with thismap. this does not include any mappings in the parent map.",
	"Method": "Object[] keys(){\r\n    return m_map.keySet().toArray();\r\n}"
}, {
	"Path": "prefuse.util.StrokeLib.getStroke",
	"Comment": "get a dashed stroke of the given width, cap, join, miter limit,and dashing attributes.",
	"Method": "BasicStroke getStroke(float width,BasicStroke getStroke,float width,float[] dashes,BasicStroke getStroke,float width,int cap,int join,BasicStroke getStroke,float width,int cap,int join,float miterLimit,float[] dashes,float dashPhase){\r\n    int key = getStrokeKey(width, cap, join, miterLimit, dashes, dashPhase);\r\n    BasicStroke s = null;\r\n    if ((s = (BasicStroke) strokeMap.get(key)) == null) {\r\n        s = new BasicStroke(width, cap, join, miterLimit, dashes, dashPhase);\r\n        strokeMap.put(key, s);\r\n        ++misses;\r\n    }\r\n    ++lookups;\r\n    return s;\r\n}"
}, {
	"Path": "quickfix.DataDictionary.isMsgType",
	"Comment": "predicate for determining if message type is valid for a specified fixversion.",
	"Method": "boolean isMsgType(String msgType){\r\n    return messages.contains(msgType);\r\n}"
}, {
	"Path": "picard.vcf.GenotypeConcordanceCounts.getCount",
	"Comment": "returns the count defined by the truth state set and call state set.",
	"Method": "long getCount(TruthState truthState,CallState callState,long getCount,TruthAndCallStates truthAndCallStates){\r\n    final Histogram.Bin<TruthAndCallStates> bin = this.counter.get(truthAndCallStates);\r\n    return (bin == null ? 0L : (long) bin.getValue());\r\n}"
}, {
	"Path": "prefuse.action.assignment.SizeAction.setDefaultSize",
	"Comment": "sets the default size value assigned to items. items will be assignedthe default size if they do not match any registered rules.",
	"Method": "void setDefaultSize(double defaultSize){\r\n    m_defaultSize = defaultSize;\r\n}"
}, {
	"Path": "prefuse.util.ColorMap.getMaxValue",
	"Comment": "gets the maximum value that corresponds to the lastcolor in the color map.",
	"Method": "double getMaxValue(){\r\n    return maxValue;\r\n}"
}, {
	"Path": "picard.analysis.artifacts.ConvertSequencingArtifactToOxoGTest.areMetricsEqual",
	"Comment": "compare the metrics in two files, ignoring headers and histograms.",
	"Method": "boolean areMetricsEqual(File file1,File file2,String[] columnsToCompare,boolean areMetricsEqual,MetricsFile<T, ?> metricFile1,MetricsFile<T, ?> metricFile2,String[] columnsToCompare){\r\n    if (metricFile1.getMetrics().size() != metricFile2.getMetrics().size())\r\n        return false;\r\n    if (metricFile1.getMetrics().isEmpty())\r\n        return true;\r\n    T firstMetric1 = metricFile1.getMetrics().get(0);\r\n    for (final String column : columnsToCompare) {\r\n        if (!metricFile1.getMetricsColumnLabels().contains(column))\r\n            return false;\r\n        if (!metricFile2.getMetricsColumnLabels().contains(column))\r\n            return false;\r\n        final Field f = firstMetric1.getClass().getField(column);\r\n        List<String> metric1Values = metricFile1.getMetrics().stream().map(m -> {\r\n            try {\r\n                return f.get(m).toString();\r\n            } catch (IllegalAccessException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return null;\r\n        }).collect(Collectors.toList());\r\n        List<String> metric2Values = metricFile2.getMetrics().stream().map(m -> {\r\n            try {\r\n                return f.get(m).toString();\r\n            } catch (IllegalAccessException e) {\r\n                e.printStackTrace();\r\n            }\r\n            return null;\r\n        }).collect(Collectors.toList());\r\n        if (!metric1Values.equals(metric2Values))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "quickfix.MessageUtils.parse",
	"Comment": "utility method for parsing a message. this should only be used for parsing messages fromfix versions 4.4 or earlier.",
	"Method": "Message parse(MessageFactory messageFactory,DataDictionary dataDictionary,String messageString,Message parse,Session session,String messageString){\r\n    final String beginString = getStringField(messageString, BeginString.FIELD);\r\n    final String msgType = getMessageType(messageString);\r\n    ApplVerID applVerID;\r\n    if (FixVersions.BEGINSTRING_FIXT11.equals(beginString)) {\r\n        applVerID = getApplVerID(session, messageString);\r\n    } else {\r\n        applVerID = toApplVerID(beginString);\r\n    }\r\n    final MessageFactory messageFactory = session.getMessageFactory();\r\n    final DataDictionaryProvider ddProvider = session.getDataDictionaryProvider();\r\n    final DataDictionary sessionDataDictionary = ddProvider == null ? null : ddProvider.getSessionDataDictionary(beginString);\r\n    final DataDictionary applicationDataDictionary = ddProvider == null ? null : ddProvider.getApplicationDataDictionary(applVerID);\r\n    final quickfix.Message message = messageFactory.create(beginString, applVerID, msgType);\r\n    final DataDictionary payloadDictionary = MessageUtils.isAdminMessage(msgType) ? sessionDataDictionary : applicationDataDictionary;\r\n    message.parse(messageString, sessionDataDictionary, payloadDictionary, payloadDictionary != null);\r\n    return message;\r\n}"
}, {
	"Path": "prefuse.util.ColorMap.getColorPalette",
	"Comment": "gets the internal color palette, an int array of color values.",
	"Method": "int[] getColorPalette(){\r\n    return palette;\r\n}"
}, {
	"Path": "quickfix.Session.close",
	"Comment": "closes session resources and unregisters session. this is for internaluse and should typically not be called by an user application.",
	"Method": "void close(){\r\n    closeIfCloseable(getLog());\r\n    closeIfCloseable(getStore());\r\n    unregisterSession(this.sessionID, false);\r\n}"
}, {
	"Path": "picard.analysis.CollectWgsMetrics.getSamReader",
	"Comment": "gets the samreader from which records will be examined.this will also set the header so that it is available in",
	"Method": "SamReader getSamReader(){\r\n    final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT);\r\n    this.header = in.getFileHeader();\r\n    return in;\r\n}"
}, {
	"Path": "cn.hugeterry.ployfun.core.delaunay.Graph.nodeSet",
	"Comment": "returns an unmodifiable set view of the nodes contained in this graph.the set is backed by the graph, so changes to the graph are reflected inthe set.",
	"Method": "Set<N> nodeSet(){\r\n    return theNodeSet;\r\n}"
}, {
	"Path": "prefuse.visual.AggregateTable.getAggregateSize",
	"Comment": "get the size of the aggregate represented at the given table row.returns the number of visual items contained in the aggregation.",
	"Method": "int getAggregateSize(int row){\r\n    int size = 0;\r\n    AggregatedIterator ati = new AggregatedIterator(row);\r\n    for (; ati.hasNext(); ++size, ati.next()) ;\r\n    return size;\r\n}"
}, {
	"Path": "prefuse.Visualization.getDisplayCount",
	"Comment": "get the number of displays associated with this visualization.",
	"Method": "int getDisplayCount(){\r\n    return m_displays.size();\r\n}"
}, {
	"Path": "com.restfb.json.JsonValue.asInt",
	"Comment": "returns this json value as an int value, assuming that this value represents a json number that can beinterpreted as java int. if this is not the case, an exception is thrown.to be interpreted as java int, the json number must neither contain an exponent nor a fraction part.moreover, the number must be in the integer range.",
	"Method": "int asInt(){\r\n    throw new UnsupportedOperationException(\"Not a number: \" + toString());\r\n}"
}, {
	"Path": "com.restfb.DefaultWebRequestor.isAutocloseBinaryAttachmentStream",
	"Comment": "returns if the binary attachment stream is closed automatically",
	"Method": "boolean isAutocloseBinaryAttachmentStream(){\r\n    return autocloseBinaryAttachmentStream;\r\n}"
}, {
	"Path": "prefuse.data.column.AbstractColumn.canGetDouble",
	"Comment": "indicates if convenience get method can be called withoutan exception being thrown for the double type.",
	"Method": "boolean canGetDouble(){\r\n    return canGet(double.class);\r\n}"
}, {
	"Path": "net.pms.util.Iso639.getLanguage",
	"Comment": "returns the full language name for a given iso language code. will return\tnull when the language name cannot be determined.",
	"Method": "String getLanguage(String code){\r\n    if (code == null) {\r\n        return null;\r\n    }\r\n    String lang = null;\r\n    Iterator<Entry<String, String[]>> iterator = links.entrySet().iterator();\r\n    while (iterator.hasNext()) {\r\n        Entry<String, String[]> entry = iterator.next();\r\n        for (String c : entry.getValue()) {\r\n            if (code.equalsIgnoreCase(c)) {\r\n                return entry.getKey();\r\n            }\r\n        }\r\n    }\r\n    return lang;\r\n}"
}, {
	"Path": "picard.util.AlleleSubsettingUtils.subsetAlleles",
	"Comment": "create the new genotypescontext with the subsetted pls and adsexpects allelestokeep to be in the same orderin which they are in originalalleles.",
	"Method": "VariantContext subsetAlleles(VariantContext originalVc,List<Allele> allelesToKeep,GenotypesContext subsetAlleles,GenotypesContext originalGs,List<Allele> originalAlleles,List<Allele> allelesToKeep){\r\n    nonNull(originalGs, \"original GenotypesContext must not be null.\");\r\n    nonNull(allelesToKeep, \"allelesToKeep is null.\");\r\n    nonEmpty(allelesToKeep, \"must keep at least one allele.\");\r\n    validateTrue(allelesToKeep.get(0).isReference(), \"First allele must be the reference allele.\");\r\n    validateTrue(allelesToKeep.stream().allMatch(originalAlleles::contains), \"OriginalAlleles must contain allelesToKeep.\");\r\n    int indexOfLast = -1;\r\n    for (Allele a : allelesToKeep) {\r\n        validateTrue(indexOfLast < originalAlleles.indexOf(a), \"alleles to keep must maintain the order of the original alleles.\");\r\n        indexOfLast = originalAlleles.indexOf(a);\r\n    }\r\n    final int[] allelesIndex = allelesToKeep.stream().mapToInt(originalAlleles::indexOf).toArray();\r\n    final GenotypesContext newGTs = GenotypesContext.create(originalGs.size());\r\n    int[] subsettedLikelihoodIndices = subsettedPLIndices(originalAlleles, allelesToKeep);\r\n    for (final Genotype g : originalGs) {\r\n        validateTrue(g.getPloidy() == 2, \"only implemented for ploidy 2 for now.\");\r\n        final int expectedNumLikelihoods = GenotypeLikelihoods.numLikelihoods(allelesToKeep.size(), 2);\r\n        int[] newPLs = null;\r\n        double newLog10GQ = -1;\r\n        if (g.hasLikelihoods()) {\r\n            int[] originalPLs = g.getPL();\r\n            if (originalPLs.length != expectedNumLikelihoods) {\r\n                newPLs = Arrays.stream(subsettedLikelihoodIndices).map(idx -> originalPLs[idx]).toArray();\r\n                final int minLikelihood = MathUtil.min(newPLs);\r\n                for (int i = 0; i < expectedNumLikelihoods; i++) {\r\n                    newPLs[i] = newPLs[i] - minLikelihood;\r\n                }\r\n                final int indexOfMostLikely = MathUtil.indexOfMin(newPLs);\r\n                newLog10GQ = GenotypeLikelihoods.getGQLog10FromLikelihoods(indexOfMostLikely, GenotypeLikelihoods.fromPLs(newPLs).getAsVector());\r\n            } else {\r\n                newPLs = null;\r\n            }\r\n        }\r\n        final GenotypeBuilder gb;\r\n        if (newPLs == null) {\r\n            gb = new GenotypeBuilder(g).noPL().noGQ().alleles(DIPLOID_NO_CALL);\r\n        } else {\r\n            gb = new GenotypeBuilder(g).PL(newPLs).log10PError(newLog10GQ);\r\n            final List<Integer> originalDiploidAlleles = GenotypeLikelihoods.getAlleles(MathUtil.indexOfMin(newPLs), 2);\r\n            gb.alleles(originalDiploidAlleles.stream().map(allelesToKeep::get).collect(Collectors.toList()));\r\n        }\r\n        if (g.hasAD()) {\r\n            final int[] oldAD = g.getAD();\r\n            final int[] newAD = IntStream.range(0, allelesToKeep.size()).map(n -> oldAD[allelesIndex[n]]).toArray();\r\n            gb.AD(newAD);\r\n        }\r\n        newGTs.add(gb.make());\r\n    }\r\n    return newGTs;\r\n}"
}, {
	"Path": "prefuse.data.query.RangeQueryBinding.createRangeSlider",
	"Comment": "create a new range slider for interacting with the query, using thegiven orientation and direction.",
	"Method": "JRangeSlider createRangeSlider(int orientation,int direction){\r\n    return new JRangeSlider(m_model, orientation, direction);\r\n}"
}, {
	"Path": "org.quickfixj.codegenerator.GenerateMojo.getFieldPackage",
	"Comment": "returns the default package to be used during field code generation.",
	"Method": "String getFieldPackage(){\r\n    return fieldPackage;\r\n}"
}, {
	"Path": "quickfix.JdbcUtil.getDataSource",
	"Comment": "this is typically called from a single thread, but just in case we are using an atomic loading functionto avoid the creation of two data sources simultaneously. the cache itself is thread safe.",
	"Method": "DataSource getDataSource(SessionSettings settings,SessionID sessionID,DataSource getDataSource,String jdbcDriver,String connectionURL,String user,String password,boolean cache,DataSource getDataSource,String jdbcDriver,String connectionURL,String user,String password,boolean cache,int maxConnCount,int simultaneousBuildThrottle,long maxActiveTime,int maxConnLifetime){\r\n    String key = jdbcDriver + \"#\" + connectionURL + \"#\" + user + \"#\" + password;\r\n    ProxoolDataSource ds = cache ? dataSources.get(key) : null;\r\n    if (ds == null) {\r\n        final Function<String, ProxoolDataSource> loadingFunction = dataSourceKey -> {\r\n            final ProxoolDataSource dataSource = new ProxoolDataSource(CONNECTION_POOL_ALIAS + \"-\" + dataSourceCounter.incrementAndGet());\r\n            dataSource.setDriver(jdbcDriver);\r\n            dataSource.setDriverUrl(connectionURL);\r\n            dataSource.setDelegateProperties(\"user=\" + user + \",\" + (password != null && !\"\".equals(password) ? \"password=\" + password : \"\"));\r\n            dataSource.setUser(user);\r\n            dataSource.setPassword(password);\r\n            dataSource.setMaximumActiveTime(maxActiveTime);\r\n            dataSource.setMaximumConnectionLifetime(maxConnLifetime);\r\n            dataSource.setMaximumConnectionCount(maxConnCount);\r\n            dataSource.setSimultaneousBuildThrottle(simultaneousBuildThrottle);\r\n            return dataSource;\r\n        };\r\n        ds = cache ? dataSources.computeIfAbsent(key, loadingFunction) : loadingFunction.apply(key);\r\n    }\r\n    return ds;\r\n}"
}, {
	"Path": "net.pms.configuration.PmsConfiguration.isMencoderForceFps",
	"Comment": "returns true if mencoder should be forced to use the framerate that is\tparsed by ffmpeg.",
	"Method": "boolean isMencoderForceFps(){\r\n    return getBoolean(KEY_MENCODER_FORCE_FPS, false);\r\n}"
}, {
	"Path": "quickfix.Session.setNextSenderMsgSeqNum",
	"Comment": "set the next outgoing message sequence number. this method is notsynchronized.",
	"Method": "void setNextSenderMsgSeqNum(int num){\r\n    state.getMessageStore().setNextSenderMsgSeqNum(num);\r\n}"
}, {
	"Path": "com.restfb.json.Json.value",
	"Comment": "returns a jsonvalue instance that represents the given boolean value.",
	"Method": "JsonValue value(int value,JsonValue value,long value,JsonValue value,float value,JsonValue value,double value,JsonValue value,String string,JsonValue value,boolean value){\r\n    return value ? TRUE : FALSE;\r\n}"
}, {
	"Path": "prefuse.action.layout.graph.ForceDirectedLayout.setReferrer",
	"Comment": "set the referrer item to use to set x or y coordinates that areinitialized to nan.",
	"Method": "void setReferrer(VisualItem referrer){\r\n    this.referrer = referrer;\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAMediaAudio.isTrueHD",
	"Comment": "returns true if this media uses the truehd audio codec, false otherwise.",
	"Method": "boolean isTrueHD(){\r\n    return getCodecA() != null && getCodecA().equalsIgnoreCase(\"truehd\");\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAMediaAudio.getAudioCodec",
	"Comment": "returns a standardized name for the audio codec that is used.",
	"Method": "String getAudioCodec(){\r\n    if (isAC3()) {\r\n        return \"AC3\";\r\n    } else if (isDTS()) {\r\n        return \"DTS\";\r\n    } else if (isTrueHD()) {\r\n        return \"TrueHD\";\r\n    } else if (isPCM()) {\r\n        return \"LPCM\";\r\n    } else if (getCodecA() != null && getCodecA().equals(\"vorbis\")) {\r\n        return \"OGG\";\r\n    } else if (getCodecA() != null && getCodecA().equals(FormatConfiguration.AAC)) {\r\n        return \"AAC\";\r\n    } else if (getCodecA() != null && getCodecA().equals(\"mp3\")) {\r\n        return \"MP3\";\r\n    } else if (getCodecA() != null && getCodecA().startsWith(\"wm\")) {\r\n        return \"WMA\";\r\n    } else if (getCodecA() != null && getCodecA().equals(\"mp2\")) {\r\n        return \"Mpeg Audio\";\r\n    }\r\n    return getCodecA() != null ? getCodecA() : \"-\";\r\n}"
}, {
	"Path": "picard.sam.util.Pair.hashCode",
	"Comment": "basic hashcode function.assume hashcodes of left and right arerandomly distributed and return the xor of the two.",
	"Method": "int hashCode(){\r\n    return Objects.hash(left, right);\r\n}"
}, {
	"Path": "net.pms.configuration.RendererConfigurationTest.testForcedDefault",
	"Comment": "test recognition with a forced default renderer configured.",
	"Method": "void testForcedDefault(){\r\n    PmsConfiguration pmsConf = null;\r\n    try {\r\n        pmsConf = new PmsConfiguration(false);\r\n    } catch (ConfigurationException e) {\r\n    }\r\n    pmsConf.setRendererDefault(\"PlayStation 3\");\r\n    pmsConf.setRendererForceDefault(true);\r\n    loadRendererConfigurations(pmsConf);\r\n    testHeader(\"User-Agent: AirPlayer/1.0.09 CFNetwork/485.13.9 Darwin/11.0.0\", \"PlayStation 3\");\r\n    testHeader(\"User-Agent: Unknown Renderer\", \"PlayStation 3\");\r\n    testHeader(\"X-Unknown-Header: Unknown Content\", \"PlayStation 3\");\r\n}"
}, {
	"Path": "net.pms.test.formats.FormatRecognitionTest.testPlaystationImagePngCompatibility",
	"Comment": "test the compatibility of the playstation 3 with the png format.",
	"Method": "void testPlaystationImagePngCompatibility(){\r\n    assumeTrue(mediaInfoParserIsValid);\r\n    RendererConfiguration conf = RendererConfiguration.getRendererConfigurationByName(\"Playstation 3\");\r\n    assertNotNull(\"Renderer named \\\"Playstation 3\\\" found.\", conf);\r\n    DLNAMediaInfo info = new DLNAMediaInfo();\r\n    info.setContainer(\"png\");\r\n    Format format = new PNG();\r\n    format.match(\"test.png\");\r\n    assertEquals(\"PS3 is compatible with PNG\", true, conf.isCompatible(info, format));\r\n}"
}, {
	"Path": "prefuse.util.ui.JRangeSlider.getThumbColor",
	"Comment": "get the slider thumb color. this is the part of the slider betweenthe range resize buttons.",
	"Method": "Color getThumbColor(){\r\n    return thumbColor;\r\n}"
}, {
	"Path": "org.pcap4j.core.PcapNetworkInterface.isRunning",
	"Comment": "returns if this network interface is running.this method may always return false on some environments.",
	"Method": "boolean isRunning(){\r\n    return running;\r\n}"
}, {
	"Path": "picard.sam.markduplicates.MarkDuplicatesWithMateCigarIterator.addRecordToTheOutputBuffer",
	"Comment": "adds a samrecordwithordinal to the output buffer.this does not mean that it is ready to be emitted, since it may need to beduplicate marked.",
	"Method": "void addRecordToTheOutputBuffer(SamRecordWithOrdinal samRecordWithOrdinal){\r\n    final int recordReferenceIndex = samRecordWithOrdinal.getRecord().getReferenceIndex();\r\n    if (recordReferenceIndex < referenceIndex) {\r\n        throw new PicardException(\"Records out of order: \" + recordReferenceIndex + \" < \" + referenceIndex);\r\n    } else if (referenceIndex < recordReferenceIndex) {\r\n        tryPollingTheToMarkQueue(true, null);\r\n        referenceIndex = recordReferenceIndex;\r\n    }\r\n    outputBuffer.add(samRecordWithOrdinal);\r\n}"
}, {
	"Path": "picard.vcf.GatherVcfs.assertSameSamplesAndValidOrdering",
	"Comment": "validates that all headers contain the same set of genotyped samples and that files are in order by position of first record.",
	"Method": "void assertSameSamplesAndValidOrdering(List<File> inputFiles){\r\n    final VCFHeader header = new VCFFileReader(inputFiles.get(0), false).getFileHeader();\r\n    final SAMSequenceDictionary dict = header.getSequenceDictionary();\r\n    final VariantContextComparator comparator = new VariantContextComparator(header.getSequenceDictionary());\r\n    final List<String> samples = header.getGenotypeSamples();\r\n    File lastFile = null;\r\n    VariantContext lastContext = null;\r\n    for (final File f : inputFiles) {\r\n        final VCFFileReader in = new VCFFileReader(f, false);\r\n        try {\r\n            dict.assertSameDictionary(in.getFileHeader().getSequenceDictionary());\r\n        } catch (final AssertionError e) {\r\n            log.error(\"File #1: \" + inputFiles.get(0));\r\n            log.error(\"File #2: \" + f);\r\n            throw e;\r\n        }\r\n        final List<String> theseSamples = in.getFileHeader().getGenotypeSamples();\r\n        if (!samples.equals(theseSamples)) {\r\n            final SortedSet<String> s1 = new TreeSet(samples);\r\n            final SortedSet<String> s2 = new TreeSet(theseSamples);\r\n            s1.removeAll(theseSamples);\r\n            s2.removeAll(samples);\r\n            throw new IllegalArgumentException(\"VCFs do not have identical sample lists.\" + \" Samples unique to first file: \" + s1 + \". Samples unique to \" + f.getAbsolutePath() + \": \" + s2 + \".\");\r\n        }\r\n        final CloseableIterator<VariantContext> variantIterator = in.iterator();\r\n        if (variantIterator.hasNext()) {\r\n            final VariantContext currentContext = variantIterator.next();\r\n            if (lastContext != null && comparator.compare(lastContext, currentContext) >= 0) {\r\n                throw new IllegalArgumentException(\"First record in file \" + f.getAbsolutePath() + \" is not after first record in \" + \"previous file \" + lastFile.getAbsolutePath());\r\n            }\r\n            lastContext = currentContext;\r\n            lastFile = f;\r\n        }\r\n        CloserUtil.close(in);\r\n    }\r\n}"
}, {
	"Path": "prefuse.Display.setItemSorter",
	"Comment": "set the itemsorter that determines the rendering order of thevisualitems. items are drawn in ascending order of the scores providedby the itemsorter.",
	"Method": "void setItemSorter(ItemSorter cmp){\r\n    damageReport();\r\n    m_queue.sort = cmp;\r\n}"
}, {
	"Path": "net.pms.configuration.RendererConfiguration.isDefaultVBVSize",
	"Comment": "returns whether or not to use the default dvd buffer size for this\trenderer as defined in the renderer configuration. default is false.",
	"Method": "boolean isDefaultVBVSize(){\r\n    return getBoolean(DEFAULT_VBV_BUFSIZE, false);\r\n}"
}, {
	"Path": "io.github.benas.randombeans.EnhancedRandomBuilder.scanClasspathForConcreteTypes",
	"Comment": "should the classpath be scanned for concrete types when a field with an interface or abstractclass type is encountered?deactivated by default.",
	"Method": "EnhancedRandomBuilder scanClasspathForConcreteTypes(boolean scanClasspathForConcreteTypes){\r\n    parameters.setScanClasspathForConcreteTypes(scanClasspathForConcreteTypes);\r\n    return this;\r\n}"
}, {
	"Path": "picard.sam.SamErrorMetric.OverlappingReadsErrorCalculator.getSuffix",
	"Comment": "the suffix that pertains to the implementation of aggregation",
	"Method": "String getSuffix(){\r\n    return \"overlapping_error\";\r\n}"
}, {
	"Path": "net.pms.dlna.DLNAResource.appendThumbnail",
	"Comment": "generate and append the response for the thumbnail based on the\tconfiguration of the renderer.",
	"Method": "void appendThumbnail(RendererConfiguration mediaRenderer,StringBuilder sb){\r\n    final String thumbURL = getThumbnailURL();\r\n    final boolean addThumbnailAsResElement = isFolder() || mediaRenderer.getThumbNailAsResource() || mediaRenderer.isForceJPGThumbnails();\r\n    if (isNotBlank(thumbURL)) {\r\n        if (addThumbnailAsResElement) {\r\n            openTag(sb, \"res\");\r\n            if (getThumbnailContentType().equals(PNG_TYPEMIME) && !mediaRenderer.isForceJPGThumbnails()) {\r\n                addAttribute(sb, \"protocolInfo\", \"http-get:*:image/png:DLNA.ORG_PN=PNG_TN\");\r\n            } else {\r\n                addAttribute(sb, \"protocolInfo\", \"http-get:*:image/jpeg:DLNA.ORG_PN=JPEG_TN\");\r\n            }\r\n            endTag(sb);\r\n            sb.append(thumbURL);\r\n            closeTag(sb, \"res\");\r\n        } else {\r\n            openTag(sb, \"upnp:albumArtURI\");\r\n            addAttribute(sb, \"xmlns:dlna\", \"urn:schemas-dlna-org:metadata-1-0/\");\r\n            if (getThumbnailContentType().equals(PNG_TYPEMIME)) {\r\n                addAttribute(sb, \"dlna:profileID\", \"PNG_TN\");\r\n            } else {\r\n                addAttribute(sb, \"dlna:profileID\", \"JPEG_TN\");\r\n            }\r\n            endTag(sb);\r\n            sb.append(thumbURL);\r\n            closeTag(sb, \"upnp:albumArtURI\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.utils.Base64Coder.encodeLines",
	"Comment": "encodes a byte array into base 64 format and breaks the output into lines.",
	"Method": "String encodeLines(byte[] in,String encodeLines,byte[] in,int iOff,int iLen,int lineLen,String lineSeparator,CharMap charMap,String encodeLines,byte[] in,int iOff,int iLen,int lineLen,String lineSeparator,char[] charMap){\r\n    int blockLen = (lineLen * 3) / 4;\r\n    if (blockLen <= 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    int lines = (iLen + blockLen - 1) / blockLen;\r\n    int bufLen = ((iLen + 2) / 3) * 4 + lines * lineSeparator.length();\r\n    StringBuilder buf = new StringBuilder(bufLen);\r\n    int ip = 0;\r\n    while (ip < iLen) {\r\n        int l = Math.min(iLen - ip, blockLen);\r\n        buf.append(encode(in, iOff + ip, l, charMap));\r\n        buf.append(lineSeparator);\r\n        ip += l;\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "com.google.gwt.sample.showcase.client.content.i18n.CwDateTimeFormat.updatePattern",
	"Comment": "update the selected pattern based on the pattern in the list.",
	"Method": "void updatePattern(){\r\n    switch(patternList.getSelectedIndex()) {\r\n        case 0:\r\n            activeFormat = DateTimeFormat.getFormat(PredefinedFormat.DATE_TIME_FULL);\r\n            patternBox.setText(activeFormat.getPattern());\r\n            patternBox.setEnabled(false);\r\n            break;\r\n        case 1:\r\n            activeFormat = DateTimeFormat.getFormat(PredefinedFormat.DATE_TIME_LONG);\r\n            patternBox.setText(activeFormat.getPattern());\r\n            patternBox.setEnabled(false);\r\n            break;\r\n        case 2:\r\n            activeFormat = DateTimeFormat.getFormat(PredefinedFormat.DATE_TIME_MEDIUM);\r\n            patternBox.setText(activeFormat.getPattern());\r\n            patternBox.setEnabled(false);\r\n            break;\r\n        case 3:\r\n            activeFormat = DateTimeFormat.getFormat(PredefinedFormat.DATE_TIME_SHORT);\r\n            patternBox.setText(activeFormat.getPattern());\r\n            patternBox.setEnabled(false);\r\n            break;\r\n        case 4:\r\n            activeFormat = DateTimeFormat.getFormat(PredefinedFormat.DATE_FULL);\r\n            patternBox.setText(activeFormat.getPattern());\r\n            patternBox.setEnabled(false);\r\n            break;\r\n        case 5:\r\n            activeFormat = DateTimeFormat.getFormat(PredefinedFormat.DATE_LONG);\r\n            patternBox.setText(activeFormat.getPattern());\r\n            patternBox.setEnabled(false);\r\n            break;\r\n        case 6:\r\n            activeFormat = DateTimeFormat.getFormat(PredefinedFormat.DATE_MEDIUM);\r\n            patternBox.setText(activeFormat.getPattern());\r\n            patternBox.setEnabled(false);\r\n            break;\r\n        case 7:\r\n            activeFormat = DateTimeFormat.getFormat(PredefinedFormat.DATE_SHORT);\r\n            patternBox.setText(activeFormat.getPattern());\r\n            patternBox.setEnabled(false);\r\n            break;\r\n        case 8:\r\n            activeFormat = DateTimeFormat.getFormat(PredefinedFormat.TIME_FULL);\r\n            patternBox.setText(activeFormat.getPattern());\r\n            patternBox.setEnabled(false);\r\n            break;\r\n        case 9:\r\n            activeFormat = DateTimeFormat.getFormat(PredefinedFormat.TIME_LONG);\r\n            patternBox.setText(activeFormat.getPattern());\r\n            patternBox.setEnabled(false);\r\n            break;\r\n        case 10:\r\n            activeFormat = DateTimeFormat.getFormat(PredefinedFormat.TIME_MEDIUM);\r\n            patternBox.setText(activeFormat.getPattern());\r\n            patternBox.setEnabled(false);\r\n            break;\r\n        case 11:\r\n            activeFormat = DateTimeFormat.getFormat(PredefinedFormat.TIME_SHORT);\r\n            patternBox.setText(activeFormat.getPattern());\r\n            patternBox.setEnabled(false);\r\n            break;\r\n        case 12:\r\n            patternBox.setEnabled(true);\r\n            String pattern = patternBox.getText();\r\n            try {\r\n                activeFormat = DateTimeFormat.getFormat(pattern);\r\n            } catch (IllegalArgumentException e) {\r\n                showErrorMessage(constants.cwDateTimeFormatInvalidPattern());\r\n                return;\r\n            }\r\n            break;\r\n    }\r\n    updateFormattedValue();\r\n}"
}, {
	"Path": "prefuse.data.Table.hasColumn",
	"Comment": "internal method indicating if the given data field is included as adata column.",
	"Method": "boolean hasColumn(String name){\r\n    return getColumnNumber(name) != -1;\r\n}"
}, {
	"Path": "prefuse.util.PredicateChain.getExpression",
	"Comment": "return the backing predicate chain as an expression instance.",
	"Method": "Expression getExpression(){\r\n    return m_head;\r\n}"
}, {
	"Path": "picard.sam.SamToFastqWithTags.makeTagWriters",
	"Comment": "creates fastq writers based on readgroup passed in and sequence tag groupings from command line",
	"Method": "List<FastqWriter> makeTagWriters(SAMReadGroupRecord readGroup,FastqWriterFactory factory){\r\n    String baseFilename = null;\r\n    if (readGroup != null) {\r\n        if (RG_TAG.equalsIgnoreCase(\"PU\")) {\r\n            baseFilename = readGroup.getPlatformUnit() + \"_\";\r\n        } else if (RG_TAG.equalsIgnoreCase(\"ID\")) {\r\n            baseFilename = readGroup.getReadGroupId() + \"_\";\r\n        }\r\n        if (baseFilename == null) {\r\n            throw new PicardException(\"The selected RG_TAG: \" + RG_TAG + \" is not present in the bam header.\");\r\n        }\r\n    } else {\r\n        baseFilename = \"\";\r\n    }\r\n    List<File> tagFiles = new ArrayList();\r\n    for (String tagSplit : SEQUENCE_TAG_GROUP) {\r\n        String fileName = baseFilename + tagSplit.replace(\",\", \"_\");\r\n        fileName = IOUtil.makeFileNameSafe(fileName);\r\n        fileName += COMPRESS_OUTPUTS_PER_TAG_GROUP ? \".fastq.gz\" : \".fastq\";\r\n        final File result = (OUTPUT_DIR != null) ? new File(OUTPUT_DIR, fileName) : new File(FASTQ.getParent(), fileName);\r\n        IOUtil.assertFileIsWritable(result);\r\n        tagFiles.add(result);\r\n    }\r\n    return tagFiles.stream().map(factory::newWriter).collect(Collectors.toList());\r\n}"
}, {
	"Path": "picard.vcf.ByIntervalListVariantContextIterator.advance",
	"Comment": "if the current iterator is null or exhausted, move to the next interval.",
	"Method": "void advance(){\r\n    while ((currentIterator == null || !currentIterator.hasNext()) && this.intervals.hasNext()) {\r\n        if (currentIterator != null)\r\n            currentCloseableIterator.close();\r\n        final Interval interval = this.intervals.next();\r\n        final Interval previousInterval = this.lastInterval;\r\n        this.currentCloseableIterator = this.reader.query(interval.getContig(), interval.getStart(), interval.getEnd());\r\n        this.currentIterator = this.currentCloseableIterator.stream().filter(ctx -> null == previousInterval || !overlapsInterval(ctx, previousInterval)).iterator();\r\n        this.lastInterval = interval;\r\n    }\r\n}"
}, {
	"Path": "prefuse.util.ui.JPrefuseApplet.destroy",
	"Comment": "automatically shuts down the activitymanager when the applet isdestroyed.",
	"Method": "void destroy(){\r\n    ActivityManager.stopThread();\r\n}"
}, {
	"Path": "net.pms.network.HTTPResourceAuthenticator.concatenateUserInfo",
	"Comment": "concatenate stored user and password information to the provided url.\tif this results in an invalid url, or if the original already contains\tuser information, the original is returned exactly like it was.",
	"Method": "URL concatenateUserInfo(URL url){\r\n    if (url.getUserInfo() == null && siteinfo.get(url.getHost()) != null) {\r\n        String userinfo = siteinfo.get(url.getHost());\r\n        String urlStr = url.toString();\r\n        String protocol = url.getProtocol() + \"://\";\r\n        urlStr = urlStr.replace(protocol, protocol + userinfo + \"@\");\r\n        try {\r\n            return new URL(urlStr);\r\n        } catch (MalformedURLException e) {\r\n            return url;\r\n        }\r\n    } else {\r\n        return url;\r\n    }\r\n}"
}, {
	"Path": "picard.illumina.parser.ParameterizedFileUtil.getTiles",
	"Comment": "return a list of all tiles available for this file format and run",
	"Method": "List<Integer> getTiles(){\r\n    return tiles;\r\n}"
}, {
	"Path": "prefuse.util.ui.JToggleGroup.setAxisType",
	"Comment": "set the box axis type used to orient the toggle group component.",
	"Method": "void setAxisType(int axis){\r\n    this.setLayout(new BoxLayout(this, axis));\r\n    m_axis = axis;\r\n    initUI();\r\n}"
}, {
	"Path": "me.vickychijwani.spectre.auth.LoginOrchestrator.kickOffLoginFlow",
	"Comment": "the entire login flow is specified here, from start to finish",
	"Method": "Disposable kickOffLoginFlow(String blogUrl){\r\n    return mBlogUrlValidator.validate(blogUrl).subscribeOn(Schedulers.io()).observeOn(Schedulers.io()).doOnNext(this::setState).flatMap(url -> mApiProvider.getGhostApi().getConfiguration()).flatMap(config -> this.getAuthToken(mApiProvider.getGhostApi(), config)).observeOn(AndroidSchedulers.mainThread()).subscribe(this::handleAuthToken, this::handleError);\r\n}"
}, {
	"Path": "net.pms.newgui.RestrictedFileSystemView.isFileSystemRoot",
	"Comment": "is dir the root of a tree in the file system, such as a drive or partition.",
	"Method": "boolean isFileSystemRoot(File dir){\r\n    return isRoot(dir);\r\n}"
}, {
	"Path": "prefuse.data.column.ColumnMetadata.getMinimumRow",
	"Comment": "get the row index of the minimum column value. if there are multipleminima, only one is returned.",
	"Method": "int getMinimumRow(){\r\n    accessCheck();\r\n    if (m_min == -1 && m_dynamic) {\r\n        Index idx = m_table.getIndex(m_field);\r\n        if (idx != null) {\r\n            m_min = idx.minimum();\r\n        } else {\r\n            m_min = DataLib.min(m_table.tuples(), m_field, m_cmp).getRow();\r\n        }\r\n    }\r\n    return m_min;\r\n}"
}, {
	"Path": "net.pms.util.AVCHeader.getValue",
	"Comment": "returns the integer value determined by a number of bits forming a\tbinary string at the bit counter field position.",
	"Method": "int getValue(int length){\r\n    int total = 0;\r\n    for (int i = 0; i < length; i++) {\r\n        total += getBit() << (length - i - 1);\r\n    }\r\n    return total;\r\n}"
}, {
	"Path": "picard.analysis.directed.TargetMetricsCollector.getNumBasesPassingMinimumBaseQuality",
	"Comment": "get the the number of bases in the given alignment block and record that have base quality greater or equal to the minimum",
	"Method": "int getNumBasesPassingMinimumBaseQuality(SAMRecord record,AlignmentBlock block,int minimumBaseQuality){\r\n    int basesInBlockAtMinimumQuality = 0;\r\n    final byte[] baseQualities = record.getBaseQualities();\r\n    for (int idx = block.getReadStart(); idx <= CoordMath.getEnd(block.getLength(), block.getReadStart()); idx++) {\r\n        if (minimumBaseQuality <= baseQualities[idx - 1])\r\n            basesInBlockAtMinimumQuality++;\r\n    }\r\n    return basesInBlockAtMinimumQuality;\r\n}"
}, {
	"Path": "prefuse.Visualization.invalidateAll",
	"Comment": "invalidate the bounds of all visualitems in this visualization. thiswill cause the bounds to be recomputed for all items upon the nextredraw.",
	"Method": "void invalidateAll(){\r\n    invalidate(ALL_ITEMS);\r\n}"
}, {
	"Path": "prefuse.util.collections.AbstractHashMap.chooseHighWaterMark",
	"Comment": "returns new high water mark threshold based on current capacity andmaxloadfactor.",
	"Method": "int chooseHighWaterMark(int capacity,double maxLoad){\r\n    return Math.min(capacity - 2, (int) (capacity * maxLoad));\r\n}"
}, {
	"Path": "com.restfb.types.Message.getTags",
	"Comment": "a set of tags indicating the message folder and source of the message.",
	"Method": "List<String> getTags(){\r\n    return unmodifiableList(tags);\r\n}"
}, {
	"Path": "picard.cmdline.PicardCommandLineTest.testLaunchAllCommandLineProgramsWithBarclayParser",
	"Comment": "rejected with a commandlineparserinternalexception from the barclay parser.",
	"Method": "void testLaunchAllCommandLineProgramsWithBarclayParser(){\r\n    PicardCommandLine.processAllCommandLinePrograms(Collections.singletonList(\"picard\"), (Class<CommandLineProgram> clazz, CommandLineProgramProperties clProperties) -> {\r\n        if (null != clProperties) {\r\n            try {\r\n                final Object commandLineProgram = clazz.newInstance();\r\n                try {\r\n                    new CommandLineArgumentParser(commandLineProgram);\r\n                } catch (CommandLineException.CommandLineParserInternalException e) {\r\n                    throw new RuntimeException(\"Barclay command line parser internal exception parsing class: \" + clazz.getName(), e);\r\n                }\r\n            } catch (IllegalAccessException | InstantiationException e) {\r\n                throw new RuntimeException(\"Failure instantiating command line program: \" + clazz.getName(), e);\r\n            }\r\n        }\r\n    });\r\n}"
}]