[{
	"Path": "org.restlet.service.MetadataService.getAllMetadata",
	"Comment": "returns all the metadata associated to this extension. it returns null ifthe extension was not declared.",
	"Method": "List<Metadata> getAllMetadata(String extension){\r\n    List<Metadata> result = null;\r\n    if (extension != null) {\r\n        for (MetadataExtension metadataExtension : this.mappings) {\r\n            if (extension.equals(metadataExtension.getName())) {\r\n                if (result == null) {\r\n                    result = new ArrayList<Metadata>();\r\n                }\r\n                result.add(metadataExtension.getMetadata());\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createStudentQuery",
	"Comment": "creates a query for student entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Student> createStudentQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Student.class);\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getRelativePart",
	"Comment": "returns the relative part of relative references, without the query andfragment. if the reference is absolute, then null is returned.note that no uri decoding is done by this method.",
	"Method": "String getRelativePart(String getRelativePart,boolean decode){\r\n    return decode ? decode(getRelativePart()) : getRelativePart();\r\n}"
}, {
	"Path": "org.restlet.ext.oauth.OAuthProxy.getErrorPage",
	"Comment": "return an html representation of the given exception. computes a basic html page by default.",
	"Method": "Representation getErrorPage(Exception ex){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"<html><body><pre>\");\r\n    if (ex instanceof OAuthException) {\r\n        OAuthException oex = (OAuthException) ex;\r\n        sb.append(\"OAuth2 error detected.\\n\");\r\n        sb.append(\"Error : \").append(oex.getError());\r\n        if (oex.getErrorDescription() != null) {\r\n            sb.append(\"Error description : \").append(oex.getErrorDescription());\r\n        }\r\n        if (oex.getErrorUri() != null) {\r\n            sb.append(\"<a href=\\\"\");\r\n            sb.append(oex.getErrorUri());\r\n            sb.append(\"\\\">Error Description<\/a>\");\r\n        }\r\n    } else {\r\n        sb.append(\"General error detected.\\n\");\r\n        sb.append(\"Error : \").append(ex.getMessage());\r\n    }\r\n    sb.append(\"<\/pre><\/body><\/html>\");\r\n    return new StringRepresentation(sb.toString(), MediaType.TEXT_HTML);\r\n}"
}, {
	"Path": "org.restlet.engine.application.StatusInfo.getContactEmail",
	"Comment": "returns the email address of the administrator to contact in case oferror.",
	"Method": "String getContactEmail(){\r\n    return contactEmail;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.TableMaker.makeVariableDef",
	"Comment": "creates variabledef based on the current tree node and scope",
	"Method": "VariableDef makeVariableDef(SymTabAST tree,Scope scope){\r\n    String name = tree.findFirstToken(TokenTypes.IDENT).getText();\r\n    VariableDef result = new VariableDef(name, scope, tree);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.resource.AnnotationUtils.getMethodAnnotation",
	"Comment": "returns the first annotation descriptor matching the given restletmethod.",
	"Method": "MethodAnnotationInfo getMethodAnnotation(List<AnnotationInfo> annotations,java.lang.reflect.Method javaMethod,MethodAnnotationInfo getMethodAnnotation,List<AnnotationInfo> annotations,Method restletMethod,Form query,Representation entity,MetadataService metadataService,org.restlet.service.ConverterService converterService){\r\n    if (annotations != null) {\r\n        for (AnnotationInfo annotationInfo : annotations) {\r\n            if (annotationInfo instanceof MethodAnnotationInfo) {\r\n                if (((MethodAnnotationInfo) annotationInfo).isCompatible(restletMethod, query, entity, metadataService, converterService)) {\r\n                    return (MethodAnnotationInfo) annotationInfo;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.EntityType.setBlob",
	"Comment": "indicates if this type a blob, that is to say it represents binary data.",
	"Method": "void setBlob(boolean blob){\r\n    this.blob = blob;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxb.JaxbRepresentation.getContext",
	"Comment": "returns the jaxb context, if possible from the cached contexts.",
	"Method": "JAXBContext getContext(String contextPath,JAXBContext getContext,String contextPath,ClassLoader classLoader,JAXBContext getContext){\r\n    return getContext(getContextPath(), getClassLoader());\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.WadlComponent.attach",
	"Comment": "attaches an application created from a wadl description documentavailable at a given uri.",
	"Method": "WadlApplication attach(Reference wadlRef,WadlApplication attach,Representation wadl,WadlApplication attach,String wadlUri){\r\n    return attach(new Reference(wadlUri));\r\n}"
}, {
	"Path": "org.restlet.data.ClientInfo.getPreferredEncoding",
	"Comment": "returns the preferred encoding among a list of supported ones, based onthe client preferences.",
	"Method": "Encoding getPreferredEncoding(List<Encoding> supported){\r\n    return getPreferredMetadata(supported, getAcceptedEncodings());\r\n}"
}, {
	"Path": "com.restfb.JsonMapperToJavaTest.usersGetLoggedInUser",
	"Comment": "can we successfully map the results of the auth.createtoken call?",
	"Method": "void usersGetLoggedInUser(){\r\n    Long uid = createJsonMapper().toJavaObject(jsonFromClasspath(\"api/users.getLoggedInUser\"), Long.class);\r\n    assertThat(uid).isEqualTo(1240077L);\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.ExceptionHandler.missingAnnotation",
	"Comment": "handles the given exception, catched by an invoke of a resource method ora creation if a sub resource object.",
	"Method": "RequestHandledException missingAnnotation(MissingAnnotationException exception,CallContext callContext,String logMessage){\r\n    callContext.getResponse().setStatus(org.restlet.data.Status.SERVER_ERROR_INTERNAL);\r\n    if (exception != null) {\r\n        logMessage += \": \" + exception.getMessage();\r\n    }\r\n    this.logger.log(Level.WARNING, logMessage);\r\n    throw new RequestHandledException();\r\n}"
}, {
	"Path": "org.restlet.Application.getStatusService",
	"Comment": "returns the status service. the service is enabled by default.",
	"Method": "StatusService getStatusService(){\r\n    return getServices().get(StatusService.class);\r\n}"
}, {
	"Path": "org.restlet.routing.VirtualHost.getCurrent",
	"Comment": "returns the virtual host code associated to the current thread.this variable is stored internally as a thread local variable and updatedeach time a call is routed by a virtual host.",
	"Method": "Integer getCurrent(){\r\n    return CURRENT.get();\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsClientResource.createJaxRsClient",
	"Comment": "creates a client resource that proxy calls to the given java interfaceinto restlet method calls.",
	"Method": "T createJaxRsClient(Context context,Reference reference,Class<? extends T> resourceInterface,T createJaxRsClient,String baseUri,Class<? extends T> resourceInterface){\r\n    Path pathAnnotation = resourceInterface.getAnnotation(Path.class);\r\n    if (pathAnnotation == null) {\r\n        throw new MissingAnnotationException(\"The resource interface must have the JAX-RS path annotation.\");\r\n    }\r\n    String path = pathAnnotation.value();\r\n    if (StringUtils.isNullOrEmpty(path)) {\r\n        throw new IllegalPathException(pathAnnotation, \"The path annotation must have a value.\");\r\n    }\r\n    String fullUriFromPath = baseUri;\r\n    if (fullUriFromPath.endsWith(\"/\")) {\r\n        if (path.startsWith(\"/\")) {\r\n            fullUriFromPath += path.substring(1);\r\n        } else {\r\n            fullUriFromPath += path;\r\n        }\r\n    } else {\r\n        if (path.startsWith(\"/\")) {\r\n            fullUriFromPath += path;\r\n        } else {\r\n            fullUriFromPath += \"/\" + path;\r\n        }\r\n    }\r\n    return JaxRsClientResource.createJaxRsClient(null, new Reference(fullUriFromPath), resourceInterface);\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.internal.xml.ContentReader.parseNode",
	"Comment": "returns the rdf uri of the given node represented by its namespace uri,local name, name, and attributes. it also generates the availablestatements, thanks to some shortcuts provided by the rdf xml syntax.",
	"Method": "Reference parseNode(String uri,String localName,String name,Attributes attributes){\r\n    Reference result = null;\r\n    List<String[]> arcs = new ArrayList<String[]>();\r\n    boolean found = false;\r\n    if (attributes.getIndex(\"xml:base\") != -1) {\r\n        this.base.add(new Reference(attributes.getValue(\"xml:base\")));\r\n    }\r\n    for (int i = 0; i < attributes.getLength(); i++) {\r\n        String qName = attributes.getQName(i);\r\n        if (checkRdfQName(\"about\", qName)) {\r\n            found = true;\r\n            result = resolve(attributes.getValue(i), false);\r\n        } else if (checkRdfQName(\"nodeID\", qName)) {\r\n            found = true;\r\n            result = Link.createBlankRef(attributes.getValue(i));\r\n        } else if (checkRdfQName(\"ID\", qName)) {\r\n            found = true;\r\n            result = resolve(attributes.getValue(i), true);\r\n        } else if (\"xml:lang\".equals(qName)) {\r\n            this.language.add(Language.valueOf(attributes.getValue(i)));\r\n        } else if (\"xml:base\".equals(qName)) {\r\n        } else {\r\n            if (!qName.startsWith(\"xmlns\")) {\r\n                String[] arc = { qName, attributes.getValue(i) };\r\n                arcs.add(arc);\r\n            }\r\n        }\r\n    }\r\n    if (!found) {\r\n        result = Link.createBlankRef(ContentReader.newBlankNodeId());\r\n    }\r\n    if (!checkRdfQName(\"Description\", name)) {\r\n        this.graphHandler.link(result, RdfConstants.PREDICATE_TYPE, resolve(uri, name));\r\n    }\r\n    for (String[] arc : arcs) {\r\n        this.graphHandler.link(result, resolve(null, arc[0]), getLiteral(arc[1], null, this.language.getValue()));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.utils.IntrospectionUtils.sortDefinition",
	"Comment": "sorts the sections, representations and resources alphabetically in thegiven rwadef definition",
	"Method": "void sortDefinition(Definition definition){\r\n    Collections.sort(definition.getContract().getSections(), new Comparator<Section>() {\r\n        @Override\r\n        public int compare(Section o1, Section o2) {\r\n            return o1.getName().compareTo(o2.getName());\r\n        }\r\n    });\r\n    Collections.sort(definition.getContract().getRepresentations(), new Comparator<Representation>() {\r\n        @Override\r\n        public int compare(Representation o1, Representation o2) {\r\n            return o1.getName().compareTo(o2.getName());\r\n        }\r\n    });\r\n    Collections.sort(definition.getContract().getResources(), new Comparator<Resource>() {\r\n        @Override\r\n        public int compare(Resource o1, Resource o2) {\r\n            return o1.getResourcePath().compareTo(o2.getResourcePath());\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.utils.IntrospectionUtils.sortDefinition",
	"Comment": "sorts the sections, representations and resources alphabetically in thegiven rwadef definition",
	"Method": "void sortDefinition(Definition definition){\r\n    return o1.getName().compareTo(o2.getName());\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.utils.IntrospectionUtils.sortDefinition",
	"Comment": "sorts the sections, representations and resources alphabetically in thegiven rwadef definition",
	"Method": "void sortDefinition(Definition definition){\r\n    return o1.getName().compareTo(o2.getName());\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.utils.IntrospectionUtils.sortDefinition",
	"Comment": "sorts the sections, representations and resources alphabetically in thegiven rwadef definition",
	"Method": "void sortDefinition(Definition definition){\r\n    return o1.getResourcePath().compareTo(o2.getResourcePath());\r\n}"
}, {
	"Path": "org.restlet.engine.adapter.ClientCall.getUnClosedResponseEntityStream",
	"Comment": "checks if the given input stream really contains bytes to be read. if so,returns the inputstream otherwise returns null.",
	"Method": "InputStream getUnClosedResponseEntityStream(InputStream inputStream){\r\n    InputStream result = null;\r\n    if (inputStream != null) {\r\n        try {\r\n            if (inputStream.available() > 0) {\r\n                result = inputStream;\r\n            } else {\r\n                java.io.PushbackInputStream is = new java.io.PushbackInputStream(inputStream);\r\n                int i = is.read();\r\n                if (i >= 0) {\r\n                    is.unread(i);\r\n                    result = is;\r\n                }\r\n            }\r\n        } catch (IOException ioe) {\r\n            getLogger().log(Level.FINER, \"End of response entity stream.\", ioe);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.service.StatusService.setContactEmail",
	"Comment": "sets the email address to contact in case of error. this is typicallyused when creating the status representations.",
	"Method": "void setContactEmail(String contactEmail){\r\n    this.contactEmail = contactEmail;\r\n}"
}, {
	"Path": "org.restlet.engine.adapter.Call.isConnectionBroken",
	"Comment": "returns true if the given exception is caused by a broken connection.",
	"Method": "boolean isConnectionBroken(Throwable exception){\r\n    return isBroken(exception);\r\n}"
}, {
	"Path": "org.restlet.ext.xstream.XstreamRepresentation.getXstream",
	"Comment": "returns the modifiable xstream object. useful to customize mappings.",
	"Method": "XStream getXstream(){\r\n    if (this.xstream == null) {\r\n        this.xstream = createXstream(getMediaType());\r\n        this.xstream.addPermission(NoTypePermission.NONE);\r\n        this.xstream.addPermission(NullPermission.NULL);\r\n        this.xstream.addPermission(PrimitiveTypePermission.PRIMITIVES);\r\n        this.xstream.allowTypeHierarchy(Collection.class);\r\n    }\r\n    return this.xstream;\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.JettyServerHelper.getLowResourceMonitorPeriod",
	"Comment": "low resource monitor period in milliseconds. defaults to 1000. when 0,low resource monitoring is disabled.",
	"Method": "int getLowResourceMonitorPeriod(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"lowResource.period\", \"1000\"));\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.ApiSparkService.getAgentCellId",
	"Comment": "returns the identifier of the cell configured on the apispark platformfor your application.",
	"Method": "Integer getAgentCellId(){\r\n    return agentCellId;\r\n}"
}, {
	"Path": "org.restlet.engine.component.ComponentXmlParser.parseRestlet",
	"Comment": "parse the attributes of a dom node and update the given restlet.",
	"Method": "void parseRestlet(Restlet restlet,Node restletNode){\r\n    Node item = restletNode.getAttributes().getNamedItem(\"name\");\r\n    if ((item != null) && (item.getNodeValue() != null)) {\r\n        restlet.setName(item.getNodeValue());\r\n    }\r\n    item = restletNode.getAttributes().getNamedItem(\"description\");\r\n    if ((item != null) && (item.getNodeValue() != null)) {\r\n        restlet.setDescription(item.getNodeValue());\r\n    }\r\n    item = restletNode.getAttributes().getNamedItem(\"owner\");\r\n    if ((item != null) && (item.getNodeValue() != null)) {\r\n        restlet.setOwner(item.getNodeValue());\r\n    }\r\n    item = restletNode.getAttributes().getNamedItem(\"author\");\r\n    if ((item != null) && (item.getNodeValue() != null)) {\r\n        restlet.setOwner(item.getNodeValue());\r\n    }\r\n}"
}, {
	"Path": "org.restlet.service.MetadataService.getLanguage",
	"Comment": "returns the language associated to this extension. it returns null if theextension was not declared of it is corresponds to another type ofmedatata such as a media type. if several metadata are associated to thesame extension then only the first matching metadata is returned.",
	"Method": "Language getLanguage(String extension){\r\n    return getMetadata(extension, Language.class);\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.RepresentationInfo.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    AttributesImpl attributes = new AttributesImpl();\r\n    if ((getReference() != null) && !getReference().equals(\"\")) {\r\n        attributes.addAttribute(\"\", \"href\", null, \"xs:anyURI\", \"#\" + getReference());\r\n        writer.emptyElement(APP_NAMESPACE, \"representation\", null, attributes);\r\n    } else {\r\n        if ((getIdentifier() != null) && !getIdentifier().equals(\"\")) {\r\n            attributes.addAttribute(\"\", \"id\", null, \"xs:ID\", getIdentifier());\r\n        }\r\n        if (getMediaType() != null) {\r\n            attributes.addAttribute(\"\", \"mediaType\", null, \"xs:string\", getMediaType().toString());\r\n        }\r\n        if ((getProfiles() != null) && !getProfiles().isEmpty()) {\r\n            StringBuilder builder = new StringBuilder();\r\n            for (Iterator<Reference> iterator = getProfiles().iterator(); iterator.hasNext(); ) {\r\n                Reference reference = iterator.next();\r\n                builder.append(reference.toString());\r\n                if (iterator.hasNext()) {\r\n                    builder.append(\" \");\r\n                }\r\n            }\r\n            attributes.addAttribute(\"\", \"profile\", null, \"xs:string\", builder.toString());\r\n        }\r\n        if ((getXmlElement() != null) && !getXmlElement().equals(\"\")) {\r\n            attributes.addAttribute(\"\", \"element\", null, \"xs:QName\", getXmlElement());\r\n        }\r\n        if (getDocumentations().isEmpty() && getParameters().isEmpty()) {\r\n            writer.emptyElement(APP_NAMESPACE, \"representation\", null, attributes);\r\n        } else {\r\n            writer.startElement(APP_NAMESPACE, \"representation\", null, attributes);\r\n            for (DocumentationInfo documentationInfo : getDocumentations()) {\r\n                documentationInfo.writeElement(writer);\r\n            }\r\n            for (ParameterInfo parameterInfo : getParameters()) {\r\n                parameterInfo.writeElement(writer);\r\n            }\r\n            writer.endElement(APP_NAMESPACE, \"representation\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.io.IoUtils.toCharArray",
	"Comment": "converts a byte array into a character array using the default characterset.",
	"Method": "char[] toCharArray(byte[] bytes,char[] toCharArray,byte[] bytes,String charsetName){\r\n    java.nio.ByteBuffer bb = java.nio.ByteBuffer.wrap(bytes);\r\n    java.nio.CharBuffer cb = java.nio.charset.Charset.forName(charsetName).decode(bb);\r\n    char[] r = new char[cb.remaining()];\r\n    cb.get(r);\r\n    return r;\r\n}"
}, {
	"Path": "org.restlet.engine.resource.ThrowableAnnotationInfo.isSerializable",
	"Comment": "returns the serialize indicator parsed from the annotation value.",
	"Method": "boolean isSerializable(){\r\n    return serializable;\r\n}"
}, {
	"Path": "org.restlet.engine.util.StringUtils.splitAndTrim",
	"Comment": "returns an list of trimmed token splitted with the split character.",
	"Method": "List<String> splitAndTrim(String stringToSplit,List<String> splitAndTrim,String stringToSplit,String splitCharacter){\r\n    List<String> list = new ArrayList();\r\n    StringTokenizer st = new StringTokenizer(stringToSplit, splitCharacter);\r\n    while (st.hasMoreTokens()) {\r\n        list.add(st.nextToken().trim());\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Source.getIcon",
	"Comment": "returns the image that provides iconic visual identification for a feed.",
	"Method": "Reference getIcon(){\r\n    return this.icon;\r\n}"
}, {
	"Path": "org.restlet.security.MethodAuthorizer.getAnonymousMethods",
	"Comment": "returns the modifiable list of methods authorized for anonymous users.",
	"Method": "List<Method> getAnonymousMethods(){\r\n    return anonymousMethods;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.CookieAuthenticator.setRedirectQueryName",
	"Comment": "sets the name of the query parameter containing the uri to redirect thebrowser to after login or logout.",
	"Method": "void setRedirectQueryName(String redirectQueryName){\r\n    this.redirectQueryName = redirectQueryName;\r\n}"
}, {
	"Path": "org.restlet.data.MediaType.getParameters",
	"Comment": "returns the unmodifiable list of parameters corresponding to subtypemodifiers. creates a new instance if no one has been set.",
	"Method": "Series<Parameter> getParameters(){\r\n    Series<Parameter> p = this.parameters;\r\n    if (p == null) {\r\n        synchronized (this) {\r\n            p = this.parameters;\r\n            if (p == null) {\r\n                Series<Parameter> params = null;\r\n                if (getName() != null) {\r\n                    int index = getName().indexOf(';');\r\n                    if (index != -1) {\r\n                        params = new Form(getName().substring(index + 1).trim(), ';');\r\n                    }\r\n                }\r\n                if (params == null) {\r\n                    params = new Series<Parameter>(Parameter.class);\r\n                }\r\n                this.parameters = p = (Series<Parameter>) Series.unmodifiableSeries(params);\r\n            }\r\n        }\r\n    }\r\n    return p;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.Metadata.getComplexType",
	"Comment": "returns the complecttype that corresponds to a given entity class.",
	"Method": "ComplexType getComplexType(Class<?> entityClass){\r\n    ComplexType result = null;\r\n    String className = entityClass.getName();\r\n    int index = className.lastIndexOf(\".\");\r\n    if (index != -1) {\r\n        className = className.substring(index + 1);\r\n    }\r\n    for (Iterator<Schema> iec = getSchemas().iterator(); result == null && iec.hasNext(); ) {\r\n        Schema schema = iec.next();\r\n        for (Iterator<ComplexType> ies = schema.getComplexTypes().iterator(); result == null && ies.hasNext(); ) {\r\n            ComplexType type = ies.next();\r\n            if (type.getClassName().equals(className)) {\r\n                result = type;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.util.ImmutableDate.setMinutes",
	"Comment": "as an immutabledate is immutable, this method throws anunsupportedoperationexception exception.",
	"Method": "void setMinutes(int arg0){\r\n    throw new UnsupportedOperationException(\"ImmutableDate is immutable\");\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipRequest.setOrganization",
	"Comment": "sets the name of the organization to which the sip element issuing themessage belongs.",
	"Method": "void setOrganization(String organization){\r\n    this.organization = organization;\r\n}"
}, {
	"Path": "org.restlet.resource.ServerResource.getAnnotation",
	"Comment": "returns the first annotation descriptor matching the given method.",
	"Method": "MethodAnnotationInfo getAnnotation(Method method,MethodAnnotationInfo getAnnotation,Method method,Form query,Representation entity){\r\n    if (isAnnotated()) {\r\n        return AnnotationUtils.getInstance().getMethodAnnotation(getAnnotations(), method, query, entity, getMetadataService(), getConverterService());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsRestlet.handle",
	"Comment": "handles a call by looking for the resource metod to call, call it andreturn the result.",
	"Method": "void handle(Request request,Response response){\r\n    super.handle(request, response);\r\n    ResourceObject resourceObject = null;\r\n    final Reference baseRef = request.getResourceRef().getBaseRef();\r\n    request.setRootRef(new Reference(baseRef.toString()));\r\n    try {\r\n        CallContext callContext;\r\n        callContext = new CallContext(request, response);\r\n        tlContext.set(callContext);\r\n        try {\r\n            ResObjAndMeth resObjAndMeth;\r\n            resObjAndMeth = requestMatching();\r\n            callContext.setReadOnly();\r\n            ResourceMethod resourceMethod = resObjAndMeth.resourceMethod;\r\n            resourceObject = resObjAndMeth.resourceObject;\r\n            Object result = invokeMethod(resourceMethod, resourceObject);\r\n            handleResult(result, resourceMethod);\r\n        } catch (WebApplicationException e) {\r\n            jaxRsRespToRestletResp(this.providers.convert(e), null);\r\n            return;\r\n        }\r\n    } catch (RequestHandledException e) {\r\n    } finally {\r\n        Representation entity = request.getEntity();\r\n        if (entity != null)\r\n            entity.release();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.io.IoUtils.delete",
	"Comment": "deletes an individual file or a directory. a recursive deletion can beforced as well. the garbage collector can be run once before attemptingto delete, to workaround lock issues under windows operating systems.",
	"Method": "boolean delete(java.io.File file,boolean delete,java.io.File file,boolean recursive,boolean delete,java.io.File file,boolean recursive,boolean garbageCollect){\r\n    boolean result = true;\r\n    boolean runGC = garbageCollect;\r\n    if (file.exists()) {\r\n        if (file.isDirectory()) {\r\n            java.io.File[] entries = file.listFiles();\r\n            if (entries.length > 0) {\r\n                if (recursive) {\r\n                    for (int i = 0; result && (i < entries.length); i++) {\r\n                        if (runGC) {\r\n                            System.gc();\r\n                            runGC = false;\r\n                        }\r\n                        result = delete(entries[i], true, false);\r\n                    }\r\n                } else {\r\n                    result = false;\r\n                }\r\n            }\r\n        }\r\n        if (runGC) {\r\n            System.gc();\r\n            runGC = false;\r\n        }\r\n        result = result && file.delete();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.Engine.discoverProtocols",
	"Comment": "discovers the protocol helpers and register the default helpers.",
	"Method": "void discoverProtocols(){\r\n    registerHelpers(DESCRIPTOR_PROTOCOL_PATH, getRegisteredProtocols(), null);\r\n    registerDefaultProtocols();\r\n}"
}, {
	"Path": "org.restlet.service.TunnelService.getMediaTypeParameter",
	"Comment": "returns the name of the parameter containing the accepted media type.",
	"Method": "String getMediaTypeParameter(){\r\n    return this.mediaTypeParameter;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.firewall.rule.FirewallCounterRule.isBlockingUnknownCountedValue",
	"Comment": "indicates if an unknown counted value should be blocked by default.",
	"Method": "boolean isBlockingUnknownCountedValue(){\r\n    return blockingUnknownCountedValue;\r\n}"
}, {
	"Path": "org.restlet.ext.html.FormData.getDisposition",
	"Comment": "returns the content disposition of the value representation.",
	"Method": "Disposition getDisposition(){\r\n    return getValueRepresentation() == null ? null : getValueRepresentation().getDisposition();\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.HttpClientHelper.getStopTimeout",
	"Comment": "stop timeout in milliseconds. defaults to 60000.the maximum time allowed for the service to shutdown.",
	"Method": "long getStopTimeout(){\r\n    return Long.parseLong(getHelpedParameters().getFirstValue(\"stopTimeout\", \"60000\"));\r\n}"
}, {
	"Path": "org.restlet.util.WrapperList.retainAll",
	"Comment": "removesretains only the elements in this list that are contained in thespecified collection.",
	"Method": "boolean retainAll(Collection<?> elements){\r\n    return getDelegate().retainAll(elements);\r\n}"
}, {
	"Path": "org.restlet.engine.header.ChallengeWriter.appendChallengeParameterSeparator",
	"Comment": "appends a comma as a separator if the first parameter has already beenwritten.",
	"Method": "ChallengeWriter appendChallengeParameterSeparator(){\r\n    if (isFirstChallengeParameter()) {\r\n        setFirstChallengeParameter(false);\r\n    } else {\r\n        append(\", \");\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Source.getId",
	"Comment": "returns the permanent, universally unique identifier for the entry.",
	"Method": "String getId(){\r\n    return this.id;\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.DefaultSslContextFactory.setTrustStoreProvider",
	"Comment": "sets the name of the trust store provider. the default value is that ofthe javax.net.ssl.truststoreprovider system property.",
	"Method": "void setTrustStoreProvider(String trustStoreProvider){\r\n    this.trustStoreProvider = trustStoreProvider;\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.internal.turtle.Context.resolve",
	"Comment": "resolves a qualified name according to the current context.",
	"Method": "Reference resolve(String qname){\r\n    Reference result = null;\r\n    int index = qname.indexOf(\":\");\r\n    if (index != -1) {\r\n        String prefix = qname.substring(0, index + 1);\r\n        String base = getPrefixes().get(prefix);\r\n        if (base != null) {\r\n            result = new Reference(base + qname.substring(index + 1));\r\n        } else {\r\n            org.restlet.Context.getCurrentLogger().warning(\"Error, this prefix \" + prefix + \" has not been declared!\");\r\n        }\r\n    } else {\r\n        if (getKeywords().contains(qname)) {\r\n            String base = getPrefixes().get(\":\");\r\n            if (base != null) {\r\n                result = new Reference(base + qname);\r\n            } else {\r\n                org.restlet.Context.getCurrentLogger().warning(\"Error, the empty prefix has not been declared!\");\r\n            }\r\n        } else {\r\n            result = new Reference(getBase().toString() + qname);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.oauth.TokenAuthServerResource.authenticate",
	"Comment": "checks that the given json representation is valid, accordingly to the type of token it contains.",
	"Method": "Representation authenticate(Representation input){\r\n    getLogger().fine(\"In Authenticate resource\");\r\n    if (isLocalAccessOnly()) {\r\n        String scheme = getOriginalRef().getScheme();\r\n        if (!Protocol.RIAP.getSchemeName().equals(scheme)) {\r\n            throw new ResourceException(Status.CLIENT_ERROR_BAD_REQUEST, \"Auth server only allows local resource validation\");\r\n        }\r\n    }\r\n    JSONObject call = new JsonRepresentation(input).getJsonObject();\r\n    if (!call.has(TOKEN_TYPE)) {\r\n        throw new OAuthException(OAuthError.invalid_request, \"No token_type\", null);\r\n    }\r\n    String tokenType = call.getString(TOKEN_TYPE);\r\n    final Token token;\r\n    if (tokenType.equalsIgnoreCase(OAuthServerResource.TOKEN_TYPE_BEARER)) {\r\n        token = tokens.validateToken(call.get(ACCESS_TOKEN).toString());\r\n    } else {\r\n        throw new OAuthException(OAuthError.invalid_request, \"Unsupported token_type\", null);\r\n    }\r\n    JSONObject resp = new JSONObject();\r\n    resp.put(USERNAME, ((ServerToken) token).getUsername());\r\n    resp.put(SCOPE, Scopes.toString(token.getScope()));\r\n    return new JsonRepresentation(resp);\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.SymTabAST.toString",
	"Comment": "prints the line, column and file for this node for debugging purpose",
	"Method": "String toString(){\r\n    StringBuffer resultBuffer = new StringBuffer(prefixString(true));\r\n    resultBuffer.append(\"[\" + getLineNo() + \",\" + getColumnNo() + \"]\");\r\n    resultBuffer.append(\" in \" + getFile());\r\n    return resultBuffer.toString();\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.TableMaker.createPackage",
	"Comment": "gets the package represented by the tree.the methodanalyzes the tree, constructs an appropriate package nameand fetches it from the internal package list. if the package does notexist it is created.",
	"Method": "PackageDef createPackage(SymTabAST tree){\r\n    PackageDef result = null;\r\n    if (tree.getType() == TokenTypes.DOT) {\r\n        SymTabAST leftChild = (SymTabAST) tree.getFirstChild();\r\n        SymTabAST rightChild = (SymTabAST) leftChild.getNextSibling();\r\n        PackageDef context = createPackage(leftChild);\r\n        result = getPackage(context, rightChild);\r\n    } else {\r\n        result = getPackage(symbolTable.getBaseScope(), tree);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.resource.ThrowableAnnotationInfo.equals",
	"Comment": "indicates if the current object is equal to the given object.",
	"Method": "boolean equals(Object other){\r\n    if (other == this) {\r\n        return true;\r\n    }\r\n    if (!(other instanceof ThrowableAnnotationInfo)) {\r\n        return false;\r\n    }\r\n    ThrowableAnnotationInfo that = (ThrowableAnnotationInfo) other;\r\n    return super.equals(that) && Objects.equals(getStatus(), that.getStatus());\r\n}"
}, {
	"Path": "org.restlet.ext.oauth.OAuthParameters.toReference",
	"Comment": "completes the uri with the oauth parameters as query parameters.",
	"Method": "Reference toReference(String uri,Reference toReference,Reference ref){\r\n    Reference reference = new Reference(ref);\r\n    for (Parameter param : form) {\r\n        reference.addQueryParameter(param);\r\n    }\r\n    return reference;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.CookieAuthenticator.getCredentialsCookie",
	"Comment": "returns the credentials cookie setting. it first try to find an existingcookie. if necessary, it creates a new one.",
	"Method": "CookieSetting getCredentialsCookie(Request request,Response response){\r\n    CookieSetting credentialsCookie = response.getCookieSettings().getFirst(getCookieName());\r\n    if (credentialsCookie == null) {\r\n        credentialsCookie = new CookieSetting(getCookieName(), null);\r\n        credentialsCookie.setAccessRestricted(true);\r\n        if (request.getRootRef() != null) {\r\n            String p = request.getRootRef().getPath();\r\n            credentialsCookie.setPath(p == null ? \"/\" : p);\r\n        } else {\r\n        }\r\n        response.getCookieSettings().add(credentialsCookie);\r\n    }\r\n    return credentialsCookie;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.params.ParameterList.get",
	"Comment": "returns the concrete parameter array for the current request.",
	"Method": "Object[] get(){\r\n    final Object[] args = new Object[this.parameters.length];\r\n    if (this.entityPosition >= 0) {\r\n        args[entityPosition] = this.parameters[entityPosition].getValue();\r\n    }\r\n    for (int i = 0; i < this.paramCount; i++) {\r\n        if (i != this.entityPosition) {\r\n            args[i] = this.parameters[i].getValue();\r\n        }\r\n    }\r\n    return args;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.WadlApplication.getResourceInfo",
	"Comment": "completes the data available about a given restlet instance.",
	"Method": "ResourceInfo getResourceInfo(ApplicationInfo applicationInfo,Filter filter,String path,Request request,Response response,ResourceInfo getResourceInfo,ApplicationInfo applicationInfo,Finder finder,String path,Request request,Response response,ResourceInfo getResourceInfo,ApplicationInfo applicationInfo,Restlet restlet,String path,Request request,Response response,ResourceInfo getResourceInfo,ApplicationInfo applicationInfo,Route route,String basePath,Request request,Response response){\r\n    ResourceInfo result = null;\r\n    if (route instanceof TemplateRoute) {\r\n        TemplateRoute templateRoute = (TemplateRoute) route;\r\n        String path = templateRoute.getTemplate().getPattern();\r\n        if (path.startsWith(\"/\") && basePath.endsWith(\"/\")) {\r\n            path = path.substring(1);\r\n        }\r\n        result = getResourceInfo(applicationInfo, route.getNext(), path, request, response);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.local.Entity.getVariant",
	"Comment": "returns a variant corresponding to the extensions of this entity.",
	"Method": "Variant getVariant(){\r\n    Variant result = new Variant();\r\n    updateMetadata(getName(), result, true, getMetadataService());\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.setOnResponse",
	"Comment": "sets the callback invoked on response reception. if the value is notnull, then the associated request will be executed asynchronously.",
	"Method": "void setOnResponse(Uniform onResponseCallback){\r\n    getRequest().setOnResponse(onResponseCallback);\r\n}"
}, {
	"Path": "org.restlet.resource.Resource.getChallengeRequests",
	"Comment": "returns the list of authentication requests sent by an origin server to aclient. if none is available, an empty list is returned.",
	"Method": "List<ChallengeRequest> getChallengeRequests(){\r\n    return getResponse() == null ? null : getResponse().getChallengeRequests();\r\n}"
}, {
	"Path": "org.restlet.engine.connector.HttpUrlConnectionCall.getServerAddress",
	"Comment": "returns the response address.corresponds to the ip address of the responding server.",
	"Method": "String getServerAddress(){\r\n    return getConnection().getURL().getHost();\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.connection.Connection.clear",
	"Comment": "clears the connection so it can be reused. typically invoked by aconnection pool.",
	"Method": "void clear(){\r\n    this.inboundWay.clear();\r\n    this.outboundWay.clear();\r\n    this.readableSelectionChannel = null;\r\n    this.socketChannel = null;\r\n    this.registration = null;\r\n    this.state = ConnectionState.CLOSED;\r\n    this.writableSelectionChannel = null;\r\n}"
}, {
	"Path": "org.restlet.resource.Directory.setNegotiatingContent",
	"Comment": "indicates if the best content is automatically negotiated. default valueis true.",
	"Method": "void setNegotiatingContent(boolean negotiatingContent){\r\n    this.negotiatingContent = negotiatingContent;\r\n}"
}, {
	"Path": "org.restlet.engine.application.StrictConneg.scoreMediaType",
	"Comment": "scores a media type relatively to enriched client preferences.",
	"Method": "float scoreMediaType(MediaType mediaType){\r\n    float result = -1.0F;\r\n    float current;\r\n    if (mediaType != null) {\r\n        for (Preference<MediaType> pref : getMediaTypePrefs()) {\r\n            if (pref.getMetadata().includes(mediaType, false)) {\r\n                current = pref.getQuality();\r\n            } else {\r\n                current = -1.0F;\r\n            }\r\n            if (current > result) {\r\n                result = current;\r\n            }\r\n        }\r\n    } else {\r\n        result = 0.0F;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.security.Realm.setVerifier",
	"Comment": "sets a verifier that can check the validity of the credentials associatedto a request.",
	"Method": "void setVerifier(Verifier verifier){\r\n    this.verifier = verifier;\r\n}"
}, {
	"Path": "org.restlet.ext.sip.internal.AvailabilityWriter.write",
	"Comment": "writes a list of availability instances with a comma separator.",
	"Method": "String write(Availability availability,String write,List<Availability> availabilities){\r\n    return new AvailabilityWriter().append(availabilities).toString();\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.Util.createSet",
	"Comment": "creates an modifiable set with the given object in it, and no otherobjects. if the given object is null, than an empty set will returned.",
	"Method": "Set<A> createSet(A objects){\r\n    final Set<A> set = new HashSet<A>();\r\n    final int l = objects.length;\r\n    for (int i = 0; i < l; i++) {\r\n        final A o = objects[i];\r\n        if (o != null) {\r\n            set.add(o);\r\n        }\r\n    }\r\n    return set;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.ClassFileSetCheck.setupChild",
	"Comment": "instantiates, configures and registers a check that is specifiedin the provided configuration.",
	"Method": "void setupChild(Configuration aChildConf){\r\n    final String name = aChildConf.getName();\r\n    final Object module = mModuleFactory.createModule(name);\r\n    if (!(module instanceof AbstractCheckVisitor)) {\r\n        throw new CheckstyleException(\"ClassFileSet is not allowed as a parent of \" + name);\r\n    }\r\n    final AbstractCheckVisitor c = (AbstractCheckVisitor) module;\r\n    c.contextualize(mChildContext);\r\n    c.configure(aChildConf);\r\n    c.init();\r\n    registerCheck(c);\r\n}"
}, {
	"Path": "org.restlet.representation.FileRepresentation.createFile",
	"Comment": "creates a new file by detecting if the name is a uri or a simple pathname.",
	"Method": "File createFile(String path){\r\n    if (path.startsWith(\"file://\")) {\r\n        return new LocalReference(path).getFile();\r\n    }\r\n    return new File(path);\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Link.getLength",
	"Comment": "returns the advisory length of the linked content in octets.",
	"Method": "long getLength(){\r\n    return this.length;\r\n}"
}, {
	"Path": "org.restlet.test.ext.jaxrs.core.UriInfoTest.newUriInfo",
	"Comment": "creates a new uriinfo object.you could only use one of these uriinfos at the same time !!!",
	"Method": "ThreadLocalizedUriInfo newUriInfo(Reference resourceRef,Reference rootRef){\r\n    Request request = new Request();\r\n    request.setResourceRef(resourceRef);\r\n    request.setOriginalRef(resourceRef);\r\n    request.setRootRef(rootRef);\r\n    Response response = new Response(request);\r\n    Response.setCurrent(response);\r\n    CallContext callContext = new CallContext(request, response);\r\n    ThreadLocalizedContext tlContext = new ThreadLocalizedContext();\r\n    tlContext.set(callContext);\r\n    return new ThreadLocalizedUriInfo(tlContext);\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipRequest.getMimeVersion",
	"Comment": "returns the version of the mime protocol used to construct the message.",
	"Method": "String getMimeVersion(){\r\n    return mimeVersion;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.toEdmDouble",
	"Comment": "convert the given value to the string representation of a edm doublevalue.",
	"Method": "String toEdmDouble(double value){\r\n    return doubleFormat.format(value);\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.classfile.MethodDefinition.isCompatible",
	"Comment": "determines whether a method is compatible with the method ofthis definition.",
	"Method": "boolean isCompatible(Method aMethod,boolean isCompatible,MethodDefinition aMethodDef,boolean isCompatible,String aMethodName,Type[] aArgTypes){\r\n    if (!getName().equals(aMethodName)) {\r\n        return false;\r\n    }\r\n    final Type[] methodTypes = getArgumentTypes();\r\n    if (methodTypes.length != aArgTypes.length) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < aArgTypes.length; i++) {\r\n        if (!Utils.isCompatible(aArgTypes[i], methodTypes[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.restlet.ext.jackson.JacksonRepresentation.isValidatingDtd",
	"Comment": "indicates the desire for validating this type of xml representationsagainst an xml schema if one is referenced within the contents.",
	"Method": "boolean isValidatingDtd(){\r\n    return validatingDtd;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.agent.module.AnalyticsHandler.postLogs",
	"Comment": "adds a task to the executor service to post call logs to the apisparkanalytics service.if the executor service cannot satisfy the request, the call logs arelost and an error message is logged with the reason of the failure.",
	"Method": "void postLogs(CallLogs logsToPost){\r\n    try {\r\n        executorService.execute(new AsyncCallLogsPostTask(logsToPost));\r\n    } catch (RejectedExecutionException e) {\r\n        LOGGER.severe(\"Posting \" + logsToPost.size() + \" call logs failed permanently due to \\\"\" + e.getCause().getMessage() + \"\\\".\");\r\n        errorSendLog(logsToPost);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.PathRegExp.matchesWithEmpty",
	"Comment": "checks, if this regular expression matches the given path with no finalmatching group.",
	"Method": "boolean matchesWithEmpty(RemainingPath remainingPath){\r\n    final MatchingResult matchingResult = match(remainingPath);\r\n    if (matchingResult == null) {\r\n        return false;\r\n    }\r\n    return matchingResult.getFinalCapturingGroup().isEmptyOrSlash();\r\n}"
}, {
	"Path": "org.restlet.service.EncoderService.getDefaultIgnoredMediaTypes",
	"Comment": "returns the list of default ignored media types. this can be overriddenby subclasses. by default, all archive, audio, image and video mediatypes are ignored.",
	"Method": "List<MediaType> getDefaultIgnoredMediaTypes(){\r\n    final List<MediaType> result = Arrays.<MediaType>asList(MediaType.APPLICATION_CAB, MediaType.APPLICATION_GNU_ZIP, MediaType.APPLICATION_ZIP, MediaType.APPLICATION_GNU_TAR, MediaType.APPLICATION_JAVA_ARCHIVE, MediaType.APPLICATION_STUFFIT, MediaType.APPLICATION_TAR, MediaType.AUDIO_ALL, MediaType.IMAGE_ALL, MediaType.VIDEO_ALL);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.util.WrapperResponse.getChallengeRequests",
	"Comment": "returns the list of authentication requests sent by an origin server to aclient.",
	"Method": "List<ChallengeRequest> getChallengeRequests(){\r\n    return getWrappedResponse().getChallengeRequests();\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getSegments",
	"Comment": "returns the list of segments in a hierarchical path.a new list is created for each call.note that no uri decoding is done by this method.",
	"Method": "List<String> getSegments(List<String> getSegments,boolean decode){\r\n    final List<String> result = getSegments();\r\n    if (decode) {\r\n        for (int i = 0; i < result.size(); i++) {\r\n            result.set(i, decode(result.get(i)));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.WadlServerResource.setAutoDescribing",
	"Comment": "indicates if the resource should be automatically described via wadl whenan options request is handled.",
	"Method": "void setAutoDescribing(boolean autoDescribed){\r\n    this.autoDescribing = autoDescribed;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.TableMaker.finishCreatingDefinitions",
	"Comment": "finishes up creating definitions processstarts at the base of the table",
	"Method": "void finishCreatingDefinitions(){\r\n    finishCreatingDefinition(symbolTable.getBaseScope());\r\n}"
}, {
	"Path": "org.restlet.service.StatusService.getRepresentation",
	"Comment": "returns a representation for the given status. in order to customize thedefault representation, this method can be overridden. it returns null bydefault.",
	"Method": "Representation getRepresentation(Status status,Request request,Response response){\r\n    Representation result = null;\r\n    if (converterService != null && connegService != null && metadataService != null) {\r\n        Object representationObject = null;\r\n        Throwable cause = status.getThrowable();\r\n        if (cause != null) {\r\n            org.restlet.engine.resource.ThrowableAnnotationInfo tai = org.restlet.engine.resource.AnnotationUtils.getInstance().getThrowableAnnotationInfo(cause.getClass());\r\n            if (tai != null && tai.isSerializable()) {\r\n                if (Application.getCurrent() != null && !Application.getCurrent().isDebugging()) {\r\n                    cause.setStackTrace(new StackTraceElement[] {});\r\n                    if (cause.getCause() != null) {\r\n                        Context.getCurrentLogger().log(Level.WARNING, \"The cause of the exception should be null except in debug mode\");\r\n                    }\r\n                }\r\n                representationObject = cause;\r\n            }\r\n        }\r\n        try {\r\n            if (representationObject == null) {\r\n                representationObject = new StatusInfo(status, getContactEmail(), getHomeRef().toString());\r\n            }\r\n            List<org.restlet.engine.resource.VariantInfo> variants = org.restlet.engine.converter.ConverterUtils.getVariants(representationObject.getClass(), null);\r\n            if (variants == null) {\r\n                variants = new ArrayList();\r\n            }\r\n            Variant variant = connegService.getPreferredVariant(variants, request, metadataService);\r\n            result = converterService.toRepresentation(representationObject, variant);\r\n        } catch (Exception e) {\r\n            Context.getCurrentLogger().log(Level.WARNING, \"Could not serialize throwable class \" + ((cause == null) ? null : cause.getClass()), e);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.getRetryDelay",
	"Comment": "returns the delay in milliseconds between two retry attempts. defaultvalue is 2 seconds.",
	"Method": "long getRetryDelay(){\r\n    return retryDelay;\r\n}"
}, {
	"Path": "org.restlet.engine.application.Encoder.afterHandle",
	"Comment": "allows filtering after its handling by the target restlet. does nothingby default.",
	"Method": "void afterHandle(Request request,Response response){\r\n    if (isEncodingResponse() && getEncoderService().canEncode(response.getEntity())) {\r\n        response.setEntity(encode(request.getClientInfo(), response.getEntity()));\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.servlet.ServerServlet.getContextPath",
	"Comment": "intercepter method need for subclasses such as xdbserverservlet.",
	"Method": "String getContextPath(HttpServletRequest request){\r\n    return request.getContextPath();\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.isRequestEntityBuffering",
	"Comment": "indicates if transient or unknown size response entities should bebuffered after being received. this is useful to increase the chance ofbeing able to resubmit a failed request due to network error, or toprevent chunked encoding from being used an http connector.",
	"Method": "boolean isRequestEntityBuffering(){\r\n    return requestEntityBuffering;\r\n}"
}, {
	"Path": "org.restlet.service.ConverterService.getObjectClasses",
	"Comment": "returns the list of object classes that can be converted from a givenvariant.",
	"Method": "List<Class<?>> getObjectClasses(Variant source){\r\n    List<Class<?>> result = null;\r\n    List<Class<?>> helperObjectClasses = null;\r\n    for (ConverterHelper ch : Engine.getInstance().getRegisteredConverters()) {\r\n        helperObjectClasses = ch.getObjectClasses(source);\r\n        if (helperObjectClasses != null) {\r\n            if (result == null) {\r\n                result = new ArrayList<Class<?>>();\r\n            }\r\n            result.addAll(helperObjectClasses);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.core.CallContext.getUserPrincipal",
	"Comment": "returns a java.security.principal object containing the nameof the current authenticated user. if the user has not beenauthenticated, the method returns null.",
	"Method": "Principal getUserPrincipal(){\r\n    Principal foundPrincipal = (request.getChallengeResponse() == null) ? null : request.getChallengeResponse().getPrincipal();\r\n    if (foundPrincipal != null)\r\n        return foundPrincipal;\r\n    return SecurityUtil.getSslClientCertPrincipal(this.request);\r\n}"
}, {
	"Path": "org.restlet.engine.util.StringUtils.strip",
	"Comment": "strips a delimiter character from both ends of the source string.",
	"Method": "String strip(String source,char delimiter,String strip,String source,char delimiter,boolean start,boolean end){\r\n    int beginIndex = 0;\r\n    int endIndex = source.length();\r\n    boolean stripping = true;\r\n    while (stripping && (beginIndex < endIndex)) {\r\n        if (source.charAt(beginIndex) == delimiter) {\r\n            beginIndex++;\r\n        } else {\r\n            stripping = false;\r\n        }\r\n    }\r\n    stripping = true;\r\n    while (stripping && (beginIndex < endIndex - 1)) {\r\n        if (source.charAt(endIndex - 1) == delimiter) {\r\n            endIndex--;\r\n        } else {\r\n            stripping = false;\r\n        }\r\n    }\r\n    return source.substring(beginIndex, endIndex);\r\n}"
}, {
	"Path": "org.restlet.ext.sdc.internal.SdcClientCall.getServerAddress",
	"Comment": "returns the response address.corresponds to the ip address of the responding server.",
	"Method": "String getServerAddress(){\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.swagger.v1_2.SwaggerWriter.fillApiDeclarationMainAttributes",
	"Comment": "fills swagger api declaration main attributes from restlet web apidefinition",
	"Method": "void fillApiDeclarationMainAttributes(Definition definition,ApiDeclaration apiDeclaration){\r\n    apiDeclaration.setApiVersion(definition.getVersion());\r\n    Endpoint endpoint;\r\n    if (!definition.getEndpoints().isEmpty()) {\r\n        endpoint = definition.getEndpoints().get(0);\r\n        apiDeclaration.setBasePath(endpoint.computeUrl());\r\n    } else {\r\n        endpoint = new Endpoint(\"http://example.com\");\r\n    }\r\n    AuthorizationsDeclaration authorizations = new AuthorizationsDeclaration();\r\n    if (ChallengeScheme.HTTP_BASIC.getName().equals((endpoint.getAuthenticationProtocol()))) {\r\n        authorizations.setBasicAuth(new BasicAuthorizationDeclaration());\r\n        apiDeclaration.setAuthorizations(authorizations);\r\n    } else if (ChallengeScheme.HTTP_OAUTH.getName().equals((endpoint.getAuthenticationProtocol())) || ChallengeScheme.HTTP_OAUTH_BEARER.getName().equals((endpoint.getAuthenticationProtocol())) || ChallengeScheme.HTTP_OAUTH_MAC.getName().equals((endpoint.getAuthenticationProtocol()))) {\r\n        authorizations.setOauth2(new OAuth2AuthorizationDeclaration());\r\n    }\r\n    apiDeclaration.setSwaggerVersion(SWAGGER_VERSION);\r\n    apiDeclaration.setResourcePath(\"\");\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipResponse.getErrorInfo",
	"Comment": "returns the pointer to additional information about the error response.",
	"Method": "Address getErrorInfo(){\r\n    return errorInfo;\r\n}"
}, {
	"Path": "org.restlet.resource.Directory.useAlphaComparator",
	"Comment": "sets the reference comparator based on classic alphabetical order.",
	"Method": "void useAlphaComparator(){\r\n    setComparator(new AlphabeticalComparator());\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.setRetryDelay",
	"Comment": "sets the delay in milliseconds between two retry attempts. the defaultvalue is two seconds.",
	"Method": "void setRetryDelay(long retryDelay){\r\n    this.retryDelay = retryDelay;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.toEdmSingle",
	"Comment": "convert the given value to the string representation of a edm singlevalue.",
	"Method": "String toEdmSingle(double value,String toEdmSingle,float value){\r\n    return singleFormat.format(value);\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.MethodSignature.getParameters",
	"Comment": "returns an array of the types of the arguments in the signature",
	"Method": "IClass[] getParameters(){\r\n    return _argTypes;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.provider.StringProvider.getByteArray",
	"Comment": "returns the given entity as byte array converted by the given characterset.",
	"Method": "byte[] getByteArray(CharSequence entity,String charsetName){\r\n    final String string = entity.toString();\r\n    try {\r\n        if (charsetName != null)\r\n            return string.getBytes(charsetName);\r\n    } catch (UnsupportedEncodingException e) {\r\n    }\r\n    try {\r\n        return string.getBytes(Util.JAX_RS_DEFAULT_CHARACTER_SET_AS_STRING);\r\n    } catch (UnsupportedEncodingException e1) {\r\n        return string.getBytes();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.internal.xml.ContentReader.popSubject",
	"Comment": "returns the subject at the top of the heap and removes it from the heap.",
	"Method": "Reference popSubject(){\r\n    Reference result = null;\r\n    int size = this.subjects.size();\r\n    if (size > 0) {\r\n        result = this.subjects.remove(size - 1);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.html.internal.FormReader.readEntry",
	"Comment": "reads the entries with the given name. if multiple values are found, alist is returned created.",
	"Method": "Object readEntry(String name){\r\n    FormData entry = readNextEntry();\r\n    Object result = null;\r\n    while (entry != null) {\r\n        if (entry.getName().equals(name)) {\r\n            if (result != null) {\r\n                List<Object> values = null;\r\n                if (result instanceof List) {\r\n                    values = (List<Object>) result;\r\n                } else {\r\n                    values = new ArrayList<Object>();\r\n                    values.add(result);\r\n                    result = values;\r\n                }\r\n                if (entry.getValue() == null) {\r\n                    values.add(Series.EMPTY_VALUE);\r\n                } else {\r\n                    values.add(entry.getValue());\r\n                }\r\n            } else {\r\n                if (entry.getValue() == null) {\r\n                    result = Series.EMPTY_VALUE;\r\n                } else {\r\n                    result = entry.getValue();\r\n                }\r\n            }\r\n        }\r\n        entry = readNextEntry();\r\n    }\r\n    this.stream.close();\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.javamail.TriggerResource.acceptMails",
	"Comment": "handles post requests. it retrieves a list of mails and generate requeststo target resources.",
	"Method": "void acceptMails(Representation entity){\r\n    final List<String> mailIdentifiers = getMailIdentifiers();\r\n    final List<String> mailsSuccessful = new ArrayList<String>();\r\n    final Map<String, String> mailsUnsuccessful = new HashMap<String, String>();\r\n    Representation mail;\r\n    for (final String mailIdentifier : mailIdentifiers) {\r\n        try {\r\n            mail = getMail(mailIdentifier);\r\n            if (mail != null) {\r\n                this.resolver = getResolver(mailIdentifier, mail);\r\n                callTarget(this.resolver);\r\n                deleteMail(mailIdentifier);\r\n                mailsSuccessful.add(mailIdentifier);\r\n            }\r\n        } catch (ResourceException e) {\r\n            mailsUnsuccessful.put(mailIdentifier, e.getMessage());\r\n        }\r\n    }\r\n    getResponse().setEntity(getResponseRepresentation(mailsSuccessful, mailsUnsuccessful));\r\n    getResponse().setStatus(getResponseStatus(mailsSuccessful, mailsUnsuccessful));\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.connection.Connection.isPipelining",
	"Comment": "indicates if idempotent sequences of requests can be pipelined.",
	"Method": "boolean isPipelining(){\r\n    return pipelining;\r\n}"
}, {
	"Path": "org.restlet.service.TunnelService.isExtensionsTunnel",
	"Comment": "indicates if the client preferences can be tunneled via the extensions.returns false by default.",
	"Method": "boolean isExtensionsTunnel(){\r\n    return this.extensionsTunnel;\r\n}"
}, {
	"Path": "org.restlet.engine.local.DirectoryServerResource.getVariantsReferences",
	"Comment": "returns the references of the representations of the target resourceaccording to the directory handler property",
	"Method": "ReferenceList getVariantsReferences(){\r\n    this.uniqueReference = null;\r\n    Response contextResponse = getRepresentation(this.targetUri, MediaType.TEXT_URI_LIST);\r\n    if (contextResponse.getEntity() == null) {\r\n        return new ReferenceList(0);\r\n    }\r\n    if (!MediaType.TEXT_URI_LIST.equals(contextResponse.getEntity().getMediaType())) {\r\n        this.uniqueReference = contextResponse.getEntity().getLocationRef();\r\n        return new ReferenceList(Arrays.asList(contextResponse.getEntity().getLocationRef()));\r\n    }\r\n    ReferenceList listVariants;\r\n    try {\r\n        listVariants = new ReferenceList(contextResponse.getEntity());\r\n    } catch (IOException ioe) {\r\n        getLogger().log(Level.WARNING, \"Unable to get resource variants\", ioe);\r\n        return new ReferenceList(0);\r\n    }\r\n    ReferenceList variantsReferences = new ReferenceList(0);\r\n    for (Reference variantReference : listVariants) {\r\n        String entryUri = variantReference.toString();\r\n        int lastSlashIndex = entryUri.lastIndexOf('/');\r\n        String fullEntryName = (lastSlashIndex == -1) ? entryUri : entryUri.substring(lastSlashIndex + 1);\r\n        int firstDotIndex = fullEntryName.indexOf('.');\r\n        String baseEntryName = (firstDotIndex != -1) ? fullEntryName.substring(0, firstDotIndex) : fullEntryName;\r\n        if (!baseEntryName.equals(this.baseName)) {\r\n            continue;\r\n        }\r\n        Variant variant = new Variant();\r\n        Entity.updateMetadata(fullEntryName, variant, true, getMetadataService());\r\n        if (!this.protoVariant.includes(variant)) {\r\n            continue;\r\n        }\r\n        variantsReferences.add(variantReference);\r\n        if (variant.equals(this.baseVariant)) {\r\n            this.uniqueReference = variantReference;\r\n        }\r\n    }\r\n    return variantsReferences;\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.setMaxRedirects",
	"Comment": "sets the maximum number of redirections that can be automaticallyfollowed for a single call.",
	"Method": "void setMaxRedirects(int maxRedirects){\r\n    this.maxRedirects = maxRedirects;\r\n}"
}, {
	"Path": "org.restlet.security.MemoryRealm.findGroups",
	"Comment": "finds the set of groups where a given user is a member. note thatinheritable ancestors groups are also returned.",
	"Method": "Set<Group> findGroups(User user,Set<Group> findGroups,User user,boolean inheritOnly){\r\n    Set<Group> result = new HashSet<Group>();\r\n    List<Group> stack;\r\n    for (Group group : getRootGroups()) {\r\n        stack = new ArrayList<Group>();\r\n        addGroups(user, result, group, stack, inheritOnly);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.Definition.toString",
	"Comment": "returns a string representation of the definition. this string includesthe class of the defintion and its qualified name",
	"Method": "String toString(){\r\n    return getClass().getName() + \"[\" + getQualifiedName() + \"]\";\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.ResourceMethod.invoke",
	"Comment": "invokes the method and returned the created representation for theresponse.",
	"Method": "Object invoke(ResourceObject resourceObject){\r\n    try {\r\n        return internalInvoke(resourceObject);\r\n    } catch (IllegalArgumentException e) {\r\n        throw new MethodInvokeException(\"Could not invoke \" + this.executeMethod, e);\r\n    } catch (IllegalAccessException e) {\r\n        throw new MethodInvokeException(\"Could not invoke \" + this.executeMethod, e);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.servlet.internal.ServletCall.sendResponse",
	"Comment": "sends the response back to the client. commits the status, headers andoptional entity and send them on the network.",
	"Method": "void sendResponse(Response response){\r\n    if (Status.isError(getStatusCode()) && (response.getEntity() == null)) {\r\n        try {\r\n            Header header;\r\n            for (Iterator<Header> iter = getResponseHeaders().iterator(); iter.hasNext(); ) {\r\n                header = iter.next();\r\n                if (!header.getName().equals(HeaderConstants.HEADER_CONTENT_LENGTH)) {\r\n                    getResponse().addHeader(header.getName(), header.getValue());\r\n                }\r\n            }\r\n            getResponse().sendError(getStatusCode(), getReasonPhrase());\r\n        } catch (IOException ioe) {\r\n            getLogger().log(Level.WARNING, \"Unable to set the response error status\", ioe);\r\n        }\r\n    } else {\r\n        getResponse().setStatus(getStatusCode());\r\n        Header header;\r\n        Header contentLengthHeader = null;\r\n        for (Iterator<Header> iter = getResponseHeaders().iterator(); iter.hasNext(); ) {\r\n            header = iter.next();\r\n            if (header.getName().equals(HeaderConstants.HEADER_CONTENT_LENGTH)) {\r\n                contentLengthHeader = header;\r\n            } else {\r\n                getResponse().addHeader(header.getName(), header.getValue());\r\n            }\r\n        }\r\n        if (contentLengthHeader != null) {\r\n            getResponse().addHeader(contentLengthHeader.getName(), contentLengthHeader.getValue());\r\n        }\r\n        super.sendResponse(response);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipRequest.getSipIfMatch",
	"Comment": "returns the identifier of the specific event state that the request isrefreshing.",
	"Method": "Tag getSipIfMatch(){\r\n    return sipIfMatch;\r\n}"
}, {
	"Path": "org.restlet.util.WrapperRequest.getProxyChallengeResponse",
	"Comment": "returns the authentication response sent by a client to a proxy.",
	"Method": "ChallengeResponse getProxyChallengeResponse(){\r\n    return getWrappedRequest().getProxyChallengeResponse();\r\n}"
}, {
	"Path": "org.restlet.engine.util.DateUtils.unmodifiableList",
	"Comment": "helper method to help initialize this class by providing unmodifiablelists based on arrays.",
	"Method": "List<T> unmodifiableList(T array){\r\n    return Collections.unmodifiableList(Arrays.asList(array));\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.connection.Connection.getMaxIoIdleTimeMs",
	"Comment": "returns the time for an idle io connection to wait for an operationbefore being closed.",
	"Method": "int getMaxIoIdleTimeMs(){\r\n    return maxIoIdleTimeMs;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.LinkInfo.setResourceType",
	"Comment": "sets the reference to the resource type of the linked resource.",
	"Method": "void setResourceType(Reference resourceType){\r\n    this.resourceType = resourceType;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.Transformer.getResultLanguages",
	"Comment": "returns the modifiable list of languages of the result representation.",
	"Method": "List<Language> getResultLanguages(){\r\n    List<Language> v = this.resultLanguages;\r\n    if (v == null) {\r\n        synchronized (this) {\r\n            v = this.resultLanguages;\r\n            if (v == null) {\r\n                this.resultLanguages = v = new CopyOnWriteArrayList<Language>();\r\n            }\r\n        }\r\n    }\r\n    return v;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.classfile.FieldDefinition.getWriteReferenceCount",
	"Comment": "determines the number of write, or put, references to the field.",
	"Method": "int getWriteReferenceCount(){\r\n    return mPutReferences.size();\r\n}"
}, {
	"Path": "org.restlet.engine.util.InternetDateFormat.getCalendar",
	"Comment": "gets the calendar object wrapped by this internetdateformat object.",
	"Method": "Calendar getCalendar(){\r\n    return (Calendar) cal.clone();\r\n}"
}, {
	"Path": "org.restlet.security.Group.setMemberGroups",
	"Comment": "sets the modifiable list of member groups. this method clears the currentlist and adds all entries in the parameter list.",
	"Method": "void setMemberGroups(List<Group> memberGroups){\r\n    synchronized (getMemberGroups()) {\r\n        if (memberGroups != getMemberGroups()) {\r\n            getMemberGroups().clear();\r\n            if (memberGroups != null) {\r\n                getMemberGroups().addAll(memberGroups);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.Util.getFirstElement",
	"Comment": "returns the first element of the given collection. throws an exception ifthe collection is empty.",
	"Method": "A getFirstElement(Collection<A> coll,A getFirstElement,Iterable<A> coll,A getFirstElement,List<A> list){\r\n    if (list.isEmpty()) {\r\n        throw new IndexOutOfBoundsException(\"The Collection is empty; you can't get the first element of it.\");\r\n    }\r\n    if (list instanceof LinkedList<?>) {\r\n        return ((LinkedList<A>) list).getFirst();\r\n    }\r\n    return list.get(0);\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipRequest.updateLastActivity",
	"Comment": "indicates that a new activity on this transaction has been detected.",
	"Method": "void updateLastActivity(){\r\n    setLastActivity(System.currentTimeMillis());\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.way.Way.setRegistration",
	"Comment": "sets the nio selection registration holding the link between theconnection and the way.",
	"Method": "void setRegistration(SelectionRegistration registration){\r\n    this.registration = registration;\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createJobPostingPartSpecialPayableQuery",
	"Comment": "creates a query for jobpostingpartspecialpayable entities hosted by thisservice.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.JobPostingPartSpecialPayable> createJobPostingPartSpecialPayableQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.JobPostingPartSpecialPayable.class);\r\n}"
}, {
	"Path": "org.restlet.engine.application.Decoder.afterHandle",
	"Comment": "allows filtering after its handling by the target restlet. does nothingby default.",
	"Method": "void afterHandle(Request request,Response response){\r\n    if (isDecodingResponse() && canDecode(response.getEntity())) {\r\n        response.setEntity(decode(response.getEntity()));\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.javamail.TriggerResource.isTargetEntityEnabled",
	"Comment": "indicate whether or not the target supports entity in the request.",
	"Method": "boolean isTargetEntityEnabled(){\r\n    return this.targetEntityEnabled;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.CookieAuthenticator.getLoginFormPath",
	"Comment": "returns the uri path of the html login form to use to challenge the user.",
	"Method": "String getLoginFormPath(){\r\n    return loginFormPath;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Service.getClientVersion",
	"Comment": "returns the version of the odata protocol extensions defined in everyrequest issued by this service.",
	"Method": "String getClientVersion(){\r\n    return clientVersion;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.FeedReader.startFeed",
	"Comment": "called when a new feed has been detected in the atom document.",
	"Method": "void startFeed(Feed feed){\r\n    if (this.feedReader != null) {\r\n        this.feedReader.startFeed(feed);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.data.Status.getReasonPhrase",
	"Comment": "returns the reason phrase of this status. when supported by the httpserver connector, this is returned in the first line of the httpresponse, next to to the status code.",
	"Method": "String getReasonPhrase(){\r\n    if (this.reasonPhrase != null) {\r\n        return this.reasonPhrase;\r\n    }\r\n    switch(this.code) {\r\n        case 100:\r\n            return \"Continue\";\r\n        case 101:\r\n            return \"Switching Protocols\";\r\n        case 102:\r\n            return \"Processing\";\r\n        case 110:\r\n            return \"Response is stale\";\r\n        case 111:\r\n            return \"Revalidation failed\";\r\n        case 112:\r\n            return \"Disconnected operation\";\r\n        case 113:\r\n            return \"Heuristic expiration\";\r\n        case 199:\r\n            return \"Miscellaneous warning\";\r\n        case 200:\r\n            return \"OK\";\r\n        case 201:\r\n            return \"Created\";\r\n        case 202:\r\n            return \"Accepted\";\r\n        case 203:\r\n            return \"Non-Authoritative Information\";\r\n        case 204:\r\n            return \"No Content\";\r\n        case 205:\r\n            return \"Reset Content\";\r\n        case 206:\r\n            return \"Partial Content\";\r\n        case 207:\r\n            return \"Multi-Status\";\r\n        case 214:\r\n            return \"Transformation applied\";\r\n        case 299:\r\n            return \"Miscellaneous persistent warning\";\r\n        case 300:\r\n            return \"Multiple Choices\";\r\n        case 301:\r\n            return \"Moved Permanently\";\r\n        case 302:\r\n            return \"Found\";\r\n        case 303:\r\n            return \"See Other\";\r\n        case 304:\r\n            return \"Not Modified\";\r\n        case 305:\r\n            return \"Use Proxy\";\r\n        case 307:\r\n            return \"Temporary Redirect\";\r\n        case 400:\r\n            return \"Bad Request\";\r\n        case 401:\r\n            return \"Unauthorized\";\r\n        case 402:\r\n            return \"Payment Required\";\r\n        case 403:\r\n            return \"Forbidden\";\r\n        case 404:\r\n            return \"Not Found\";\r\n        case 405:\r\n            return \"Method Not Allowed\";\r\n        case 406:\r\n            return \"Not Acceptable\";\r\n        case 407:\r\n            return \"Proxy Authentication Required\";\r\n        case 408:\r\n            return \"Request Timeout\";\r\n        case 409:\r\n            return \"Conflict\";\r\n        case 410:\r\n            return \"Gone\";\r\n        case 411:\r\n            return \"Length Required\";\r\n        case 412:\r\n            return \"Precondition Failed\";\r\n        case 413:\r\n            return \"Request Entity Too Large\";\r\n        case 414:\r\n            return \"Request URI Too Long\";\r\n        case 415:\r\n            return \"Unsupported Media Type\";\r\n        case 416:\r\n            return \"Requested Range Not Satisfiable\";\r\n        case 417:\r\n            return \"Expectation Failed\";\r\n        case 422:\r\n            return \"Unprocessable Entity\";\r\n        case 423:\r\n            return \"Locked\";\r\n        case 424:\r\n            return \"Failed Dependency\";\r\n        case 429:\r\n            return \"Too Many Requests\";\r\n        case 500:\r\n            return \"Internal Server Error\";\r\n        case 501:\r\n            return \"Not Implemented\";\r\n        case 502:\r\n            return \"Bad Gateway\";\r\n        case 503:\r\n            return \"Service Unavailable\";\r\n        case 504:\r\n            return \"Gateway Timeout\";\r\n        case 505:\r\n            return \"Version Not Supported\";\r\n        case 507:\r\n            return \"Insufficient Storage\";\r\n        case 1000:\r\n            return \"Connection Error\";\r\n        case 1001:\r\n            return \"Communication Error\";\r\n        case 1002:\r\n            return \"Internal Connector Error\";\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.FunctionImport.setEntitySet",
	"Comment": "sets the entity set returned by this function, if applicable.",
	"Method": "void setEntitySet(EntitySet entitySet){\r\n    this.entitySet = entitySet;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.ResponseInfo.setStatuses",
	"Comment": "sets the list of statuses associated with this response representation.",
	"Method": "void setStatuses(List<Status> statuses){\r\n    this.statuses = statuses;\r\n}"
}, {
	"Path": "org.restlet.service.TaskService.scheduleWithFixedDelay",
	"Comment": "creates and executes a periodic action that becomes enabled first afterthe given initial delay, and subsequently with the given delay betweenthe termination of one execution and the commencement of the next. if anyexecution of the task encounters an exception, subsequent executions aresuppressed. otherwise, the task will only terminate via cancellation ortermination of the executor.",
	"Method": "ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit){\r\n    startIfNeeded();\r\n    return getWrapped().scheduleWithFixedDelay(command, initialDelay, delay, unit);\r\n}"
}, {
	"Path": "org.restlet.ext.httpclient.HttpClientHelper.getProxyPort",
	"Comment": "returns the port of the http proxy, if specified, 3128 otherwise.",
	"Method": "int getProxyPort(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"proxyPort\", System.getProperty(\"http.proxyPort\", \"3128\")));\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.internal.JettyHandler.handle",
	"Comment": "handles a jetty call by converting it to a restlet call and giving it forprocessing to the restlet server.",
	"Method": "void handle(String target,Request request,HttpServletRequest servletRequest,HttpServletResponse servletResponse){\r\n    final HttpChannel<?> channel = HttpChannel.getCurrentHttpChannel();\r\n    final Request baseRequest = (servletRequest instanceof Request) ? (Request) servletRequest : channel.getRequest();\r\n    this.helper.handle(new JettyServerCall(this.helper.getHelped(), channel));\r\n    baseRequest.setHandled(true);\r\n}"
}, {
	"Path": "org.restlet.Connector.setProtocols",
	"Comment": "sets the list of protocols simultaneously supported. this method clearsthe current list and adds all entries in the parameter list.",
	"Method": "void setProtocols(List<Protocol> protocols){\r\n    synchronized (getProtocols()) {\r\n        if (protocols != getProtocols()) {\r\n            getProtocols().clear();\r\n            if (protocols != null) {\r\n                getProtocols().addAll(protocols);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsRestlet.getRootUris",
	"Comment": "returns a collection with all root uris attached to this jaxrsrestlet.",
	"Method": "Collection<String> getRootUris(){\r\n    List<String> uris = new ArrayList<String>();\r\n    for (RootResourceClass rrc : this.resourceClasses.roots()) uris.add(rrc.getPathRegExp().getPathTemplateEnc());\r\n    return Collections.unmodifiableCollection(uris);\r\n}"
}, {
	"Path": "org.restlet.test.ext.jaxrs.services.tests.JaxRsTestCase.options",
	"Comment": "sends an option request to the given sub path of the first root resourceclass.",
	"Method": "Response options(Response options,String subPath){\r\n    return accessServer(Method.OPTIONS, getRootResourceClassFromAppConf(), subPath, null);\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createAttachmentQuery",
	"Comment": "creates a query for attachment entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Attachment> createAttachmentQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Attachment.class);\r\n}"
}, {
	"Path": "org.restlet.Message.getOnError",
	"Comment": "returns the callback invoked when an error occurs when sending themessage.",
	"Method": "Uniform getOnError(){\r\n    return onError;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.Mapping.getContentKind",
	"Comment": "returns the content type of the value of the mapped property.",
	"Method": "String getContentKind(){\r\n    return contentKind;\r\n}"
}, {
	"Path": "org.restlet.security.MethodAuthorizer.setAnonymousMethods",
	"Comment": "sets the modifiable list of methods authorized for anonymous users. thismethod clears the current list and adds all entries in the parameterlist.",
	"Method": "void setAnonymousMethods(List<Method> anonymousMethods){\r\n    synchronized (getAnonymousMethods()) {\r\n        if (anonymousMethods != getAnonymousMethods()) {\r\n            getAnonymousMethods().clear();\r\n            if (anonymousMethods != null) {\r\n                getAnonymousMethods().addAll(anonymousMethods);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.connection.SslConnection.getSslHandshakeStatus",
	"Comment": "returns the ssl handshake status, either from the latest engine result orfrom the ssl engine.",
	"Method": "HandshakeStatus getSslHandshakeStatus(){\r\n    return (getSslEngineResult() == null) ? getSslEngine().getHandshakeStatus() : getSslEngineResult().getHandshakeStatus();\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.WadlApplication.getResourceInfos",
	"Comment": "completes the list of resourceinfo instances for the given routerinstance.",
	"Method": "List<ResourceInfo> getResourceInfos(ApplicationInfo applicationInfo,Router router,Request request,Response response){\r\n    List<ResourceInfo> result = new ArrayList<ResourceInfo>();\r\n    for (Route route : router.getRoutes()) {\r\n        ResourceInfo resourceInfo = getResourceInfo(applicationInfo, route, \"/\", request, response);\r\n        if (resourceInfo != null) {\r\n            result.add(resourceInfo);\r\n        }\r\n    }\r\n    if (router.getDefaultRoute() != null) {\r\n        ResourceInfo resourceInfo = getResourceInfo(applicationInfo, router.getDefaultRoute(), \"/\", request, response);\r\n        if (resourceInfo != null) {\r\n            result.add(resourceInfo);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.options",
	"Comment": "describes the resource using a given media type. if a success status isnot returned, then a resource exception is thrown.",
	"Method": "Representation options(T options,Class<T> resultClass,Representation options,MediaType mediaType){\r\n    return handle(Method.OPTIONS, mediaType);\r\n}"
}, {
	"Path": "org.restlet.ext.sdc.SdcClientHelper.getLatch",
	"Comment": "returns the latch that can be used to block until the connector is readyto process requests.",
	"Method": "CountDownLatch getLatch(){\r\n    return latch;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.UnusedParameterCheck.hasBody",
	"Comment": "determines whether an ast is a method definition with a body, or isa constructor definition.",
	"Method": "boolean hasBody(DetailAST aAST){\r\n    if (aAST.getType() == TokenTypes.METHOD_DEF) {\r\n        return aAST.branchContains(TokenTypes.SLIST);\r\n    } else if (aAST.getType() == TokenTypes.CTOR_DEF) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.BaseHelper.getTraceStream",
	"Comment": "returns the trace output stream to use if tracing is enabled.",
	"Method": "OutputStream getTraceStream(){\r\n    return System.out;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.introspection.application.RestletCollector.collectForFinder",
	"Comment": "completes the data available about a given finder instance.",
	"Method": "void collectForFinder(CollectInfo collectInfo,String basePath,Finder finder,ChallengeScheme scheme,List<? extends IntrospectionHelper> introspectionHelper){\r\n    if (finder instanceof Directory) {\r\n        ResourceCollector.collectResource(collectInfo, (Directory) finder, basePath, scheme, introspectionHelper);\r\n    } else {\r\n        ServerResource serverResource = finder.find(null, null);\r\n        if (serverResource != null) {\r\n            ResourceCollector.collectResource(collectInfo, serverResource, basePath, scheme, introspectionHelper);\r\n        } else {\r\n            LOGGER.fine(\"Finder has no server resource. Class \" + finder.getClass());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.Message.getDate",
	"Comment": "returns the date and time at which the message was originated.",
	"Method": "Date getDate(){\r\n    return date;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlRepresentation.setValidatingDtd",
	"Comment": "indicates the desire for validating this type of xml representationsagainst an xml schema if one is referenced within the contents.",
	"Method": "void setValidatingDtd(boolean validating){\r\n    this.validatingDtd = validating;\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.Graph.getTypeRef",
	"Comment": "returns the type reference, either the one given in the typeref parameteror if it is null, the type reference of the default link.",
	"Method": "Reference getTypeRef(Reference typeRef){\r\n    Reference result = typeRef;\r\n    if ((result == null) && (getDefaultLink() != null)) {\r\n        result = getDefaultLink().getTypeRef();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.TransformRepresentation.getTransformerHandler",
	"Comment": "returns the sax transformer handler associated to the transform sheet.",
	"Method": "TransformerHandler getTransformerHandler(){\r\n    TransformerHandler result = null;\r\n    Templates templates = getTemplates();\r\n    if (templates != null) {\r\n        try {\r\n            result = getSaxTransformerFactory().newTransformerHandler(templates);\r\n        } catch (TransformerConfigurationException tce) {\r\n            throw new IOException(\"Transformer configuration exception. \" + tce.getMessage());\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.Response.setAutoCommitting",
	"Comment": "indicates if the response should be automatically committed.",
	"Method": "void setAutoCommitting(boolean autoCommitting){\r\n    this.autoCommitting = autoCommitting;\r\n}"
}, {
	"Path": "org.restlet.service.TaskService.shutdown",
	"Comment": "initiates an orderly shutdown in which previously submitted tasks areexecuted, but no new tasks will be accepted.",
	"Method": "void shutdown(){\r\n    if (isShutdownAllowed() && (getWrapped() != null)) {\r\n        getWrapped().shutdown();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.HttpClientHelper.getMaxRedirects",
	"Comment": "the max number of http redirects that are followed. defaults to 8.",
	"Method": "int getMaxRedirects(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"maxRedirects\", \"8\"));\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getSchemeSpecificPart",
	"Comment": "returns the scheme specific part.note that no uri decoding is done by this method.",
	"Method": "String getSchemeSpecificPart(String getSchemeSpecificPart,boolean decode){\r\n    return decode ? decode(getSchemeSpecificPart()) : getSchemeSpecificPart();\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.RdfClientResource.getLiterals",
	"Comment": "returns the linked literals, based on the rdf representation exposed. thetype of links to follow can be restricted.",
	"Method": "Set<Couple<Reference, Literal>> getLiterals(Set<Literal> getLiterals,Reference typeRef){\r\n    Set<Literal> result = null;\r\n    Graph links = getLinks();\r\n    if (links != null) {\r\n        result = new HashSet<Literal>();\r\n        for (Link link : links) {\r\n            if (link.hasLiteralTarget()) {\r\n                if ((typeRef == null) || typeRef.equals(link.getTypeRef())) {\r\n                    result.add(link.getTargetAsLiteral());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.EncodeOrCheck.nameOrValue",
	"Comment": "encodes the given string, if encoding is enabled. if encoding isdisabled, the methods checks the validaty of the containing characters.",
	"Method": "String nameOrValue(Object nameOrValue,boolean encode,String nameForMessage){\r\n    if (nameOrValue == null) {\r\n        throw throwIllegalArgExc(Integer.MIN_VALUE, nameForMessage, nameOrValue, \" must not be null\");\r\n    }\r\n    CharSequence nov;\r\n    if (nameOrValue instanceof CharSequence) {\r\n        nov = (CharSequence) nameOrValue;\r\n    } else {\r\n        nov = nameOrValue.toString();\r\n    }\r\n    if (encode) {\r\n        return encodeNotBraces(nov, true, true);\r\n    }\r\n    EncodeOrCheck.checkForInvalidUriChars(nov, Integer.MIN_VALUE, nameForMessage);\r\n    return nov.toString();\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.channel.ReadableChunkingChannel.read",
	"Comment": "reads some bytes and put them into the destination buffer. the bytes comefrom the underlying channel.",
	"Method": "int read(ByteBuffer dst){\r\n    int result = 0;\r\n    boolean tryAgain = true;\r\n    while (tryAgain) {\r\n        if (this.lastChunkWritten) {\r\n            result = -1;\r\n            tryAgain = false;\r\n        } else {\r\n            int chunkStart = dst.position();\r\n            int maxChunkDataSize = dst.remaining() - this.chunkSizeLength - 4;\r\n            int chunkDataSize = 0;\r\n            if (maxChunkDataSize > 0) {\r\n                dst.position(chunkStart + this.chunkSizeLength + 2);\r\n                dst.limit(dst.position() + maxChunkDataSize);\r\n                if (Context.getCurrentLogger().isLoggable(Level.FINER)) {\r\n                    Context.getCurrentLogger().finer(\"Position in destination buffer before chunking | Limit | MaxChunkDataSize : \" + dst.position() + \" | \" + dst.limit() + \" | \" + maxChunkDataSize);\r\n                }\r\n                chunkDataSize = getWrappedChannel().read(dst);\r\n                dst.limit(dst.capacity());\r\n                if (chunkDataSize == -1) {\r\n                    this.lastChunkWritten = true;\r\n                    tryAgain = false;\r\n                    dst.position(chunkStart);\r\n                    result += fillChunkSizeString(0, dst);\r\n                    dst.put((byte) 13);\r\n                    dst.put((byte) 10);\r\n                    result += 2;\r\n                } else if (chunkDataSize > 0) {\r\n                    dst.put((byte) 13);\r\n                    dst.put((byte) 10);\r\n                    dst.position(chunkStart);\r\n                    fillChunkSizeString(chunkDataSize, dst);\r\n                    if (Context.getCurrentLogger().isLoggable(Level.FINER)) {\r\n                        Context.getCurrentLogger().finer(\"Old chunking position in destination buffer | Limit | MaxChunkDataSize | ChunkDataSize : \" + dst.position() + \" | \" + dst.limit() + \" | \" + maxChunkDataSize + \" | \" + chunkDataSize);\r\n                    }\r\n                    dst.position(dst.position() + chunkDataSize + 2);\r\n                    if (Context.getCurrentLogger().isLoggable(Level.FINER)) {\r\n                        Context.getCurrentLogger().finer(\"New chunking position in destination buffer | Limit | MaxChunkDataSize | ChunkDataSize : \" + dst.position() + \" | \" + dst.limit() + \" | \" + maxChunkDataSize + \" | \" + chunkDataSize);\r\n                    }\r\n                    result += dst.position() - chunkStart;\r\n                } else {\r\n                    dst.position(chunkStart);\r\n                }\r\n            } else {\r\n                tryAgain = false;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.BaseHelper.isDirectBuffers",
	"Comment": "indicates if direct nio buffers should be used. note that tracing must bedisabled to use direct buffers.",
	"Method": "boolean isDirectBuffers(){\r\n    return !isTracing() && Boolean.parseBoolean(getHelpedParameters().getFirstValue(\"directBuffers\", \"false\"));\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Service.invokeComplex",
	"Comment": "invokes a service operation and return the raw representation sent backby the service.",
	"Method": "Representation invokeComplex(String service,Series<Parameter> parameters){\r\n    Representation result = null;\r\n    Metadata metadata = (Metadata) getMetadata();\r\n    if (metadata != null && service != null) {\r\n        FunctionImport function = null;\r\n        for (EntityContainer container : metadata.getContainers()) {\r\n            for (FunctionImport f : container.getFunctionImports()) {\r\n                if (service.equals(f.getName())) {\r\n                    function = f;\r\n                    break;\r\n                }\r\n            }\r\n            if (function != null) {\r\n                break;\r\n            }\r\n        }\r\n        if (function != null) {\r\n            ClientResource resource = createResource(service);\r\n            resource.setMethod(function.getMethod());\r\n            if (parameters != null) {\r\n                for (org.restlet.ext.odata.internal.edm.Parameter parameter : function.getParameters()) {\r\n                    resource.getReference().addQueryParameter(parameter.getName(), TypeUtils.getLiteralForm(parameters.getFirstValue(parameter.getName()), parameter.getType()));\r\n                }\r\n            }\r\n            result = resource.handle();\r\n            this.latestRequest = resource.getRequest();\r\n            this.latestResponse = resource.getResponse();\r\n            if (resource.getStatus().isError()) {\r\n                throw new ResourceException(resource.getStatus());\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.util.CallResolver.getReferenceContent",
	"Comment": "returns the content corresponding to a reference property.",
	"Method": "String getReferenceContent(String partName,Reference reference){\r\n    if (reference == null || partName == null) {\r\n        return null;\r\n    }\r\n    switch(partName) {\r\n        case \"a\":\r\n            return reference.getAuthority();\r\n        case \"e\":\r\n            return reference.getRelativePart();\r\n        case \"f\":\r\n            return reference.getFragment();\r\n        case \"h\":\r\n            return reference.getHostIdentifier();\r\n        case \"i\":\r\n            return reference.getIdentifier();\r\n        case \"p\":\r\n            return reference.getPath();\r\n        case \"q\":\r\n            return reference.getQuery();\r\n        case \"r\":\r\n            return reference.getRemainingPart();\r\n        default:\r\n            if (partName.startsWith(\"b\")) {\r\n                return getReferenceContent(partName.substring(1), reference.getBaseRef());\r\n            } else if (partName.startsWith(\"t\")) {\r\n                return getReferenceContent(partName.substring(1), reference.getTargetRef());\r\n            } else if (partName.isEmpty()) {\r\n                return reference.toString(false, false);\r\n            }\r\n            break;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.ext.servlet.ServerServlet.getInitParameter",
	"Comment": "returns the value of a given initialization parameter, first from theservlet configuration, then from the web application context.",
	"Method": "String getInitParameter(String name,String defaultValue){\r\n    String result = getServletConfig().getInitParameter(name);\r\n    if (result == null) {\r\n        result = getServletConfig().getServletContext().getInitParameter(name);\r\n    }\r\n    if (result == null) {\r\n        result = defaultValue;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.connector.HttpClientHelper.isAllowUserInteraction",
	"Comment": "indicates if this url is being examined in a context in which it makessense to allow user interactions such as popping up an authenticationdialog.",
	"Method": "boolean isAllowUserInteraction(){\r\n    return Boolean.parseBoolean(getHelpedParameters().getFirstValue(\"allowUserInteraction\", \"false\"));\r\n}"
}, {
	"Path": "org.restlet.representation.Representation.getText",
	"Comment": "converts the representation to a string value. be careful when using thismethod as the conversion of large content to a string fully stored inmemory can result in outofmemoryerrors being thrown.",
	"Method": "String getText(){\r\n    String result = null;\r\n    if (isEmpty()) {\r\n        result = \"\";\r\n    } else if (isAvailable()) {\r\n        java.io.StringWriter sw = new java.io.StringWriter();\r\n        write(sw);\r\n        sw.flush();\r\n        result = sw.toString();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.security.Group.setInheritingRoles",
	"Comment": "indicates if the roles of the parent group should be inherited. thoseroles indirectly cover the granted or denied permissions.",
	"Method": "void setInheritingRoles(boolean inheritingRoles){\r\n    this.inheritingRoles = inheritingRoles;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.CookieAuthenticator.setSecretFormName",
	"Comment": "sets the name of the html login form field containing the secret.",
	"Method": "void setSecretFormName(String passwordInputName){\r\n    this.secretFormName = passwordInputName;\r\n}"
}, {
	"Path": "org.restlet.Application.getTunnelService",
	"Comment": "returns the tunnel service. the service is enabled by default.",
	"Method": "TunnelService getTunnelService(){\r\n    return getServices().get(TunnelService.class);\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.ApiSparkFilter.refreshApiSparkFilterIfRevisionChanged",
	"Comment": "retrieves the modules settings from the service and updates the filter.",
	"Method": "void refreshApiSparkFilterIfRevisionChanged(){\r\n    try {\r\n        ModulesSettings newModulesSettings = ModulesSettingsModule.getModulesSettings(apiSparkConfig, modulesSettings);\r\n        if (newModulesSettings != null) {\r\n            modulesSettings = newModulesSettings;\r\n            LOGGER.info(\"Updating modules settings\");\r\n            refreshApiSparkFilter();\r\n        }\r\n    } catch (Exception e) {\r\n        LOGGER.log(Level.WARNING, \"Unable to retrieve agent settings from apispark\", e);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.WrapperUtil.convertToMediaTypes",
	"Comment": "converts the given mimes to a list of mediatypes. will never returnsnull.",
	"Method": "List<MediaType> convertToMediaTypes(String[] mimes){\r\n    final List<MediaType> mediaTypes;\r\n    mediaTypes = new ArrayList<MediaType>(mimes.length);\r\n    for (String mime : mimes) {\r\n        if (mime == null) {\r\n            mediaTypes.add(MediaType.ALL);\r\n        } else {\r\n            mediaTypes.add(MediaType.valueOf(mime));\r\n        }\r\n    }\r\n    return Collections.unmodifiableList(mediaTypes);\r\n}"
}, {
	"Path": "org.restlet.engine.converter.ConverterHelper.addVariant",
	"Comment": "adds a variant to the given list. creates a new list if necessary.",
	"Method": "List<VariantInfo> addVariant(List<VariantInfo> variants,VariantInfo userVariant){\r\n    if (userVariant != null) {\r\n        if (variants == null) {\r\n            variants = new ArrayList<VariantInfo>();\r\n        }\r\n        variants.add(userVariant);\r\n    }\r\n    return variants;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.utils.CliUtils.print12",
	"Comment": "print the first string with a indentation of 1and others strings with a indentation of 2",
	"Method": "void print12(String string1,String strings){\r\n    print1(string1);\r\n    print2(strings);\r\n}"
}, {
	"Path": "org.restlet.resource.Resource.getCookieSettings",
	"Comment": "returns the modifiable series of cookie settings provided by the server.creates a new instance if no one has been set.",
	"Method": "Series<CookieSetting> getCookieSettings(){\r\n    return getResponse() == null ? null : getResponse().getCookieSettings();\r\n}"
}, {
	"Path": "org.restlet.ext.openid.OpenIdFormForwarder.handleFormRedirect",
	"Comment": "helper class to programmatically handle the openid 2.0 html formredirection. the class can be added and if needed it will intercept andperform the post on behalf of the end user. in normal operation a browserwould automatically post the form.there is no harm in having the forwarder in place even if there is nopost there then the code would be skipped.",
	"Method": "Representation handleFormRedirect(Representation input,ClientResource resource){\r\n    Representation output = input;\r\n    if (resource != null) {\r\n        for (CookieSetting cs : resource.getCookieSettings()) {\r\n            resource.getCookies().add(cs.getName(), cs.getValue());\r\n        }\r\n    }\r\n    if (MediaType.TEXT_HTML.equals(input.getMediaType()) && input.getSize() != 0) {\r\n        DomRepresentation htmlRep = new DomRepresentation(input);\r\n        Node form = htmlRep.getNode(\"//form\");\r\n        if (form != null) {\r\n            Node body = htmlRep.getNode(\"//body\");\r\n            NamedNodeMap nnm = body.getAttributes();\r\n            Node onload = nnm.getNamedItem(\"onload\");\r\n            String val = onload.getNodeValue();\r\n            if (val.endsWith(\".submit();\")) {\r\n                NamedNodeMap nnm2 = form.getAttributes();\r\n                String name = nnm2.getNamedItem(\"name\").getNodeValue();\r\n                String action = nnm2.getNamedItem(\"action\").getNodeValue();\r\n                String method = nnm2.getNamedItem(\"method\").getNodeValue();\r\n                Context.getCurrentLogger().fine(\"name = \" + name + \" action = \" + action + \" method = \" + method);\r\n                if (name != null && name.length() > 0 && action != null && action.length() > 0 && method != null && method.length() > 0 && \"post\".equalsIgnoreCase(method)) {\r\n                    Form f = new Form();\r\n                    NodeList nl = form.getChildNodes();\r\n                    for (int i = 0; i < nl.getLength(); i++) {\r\n                        Node n = nl.item(i);\r\n                        if (\"input\".equalsIgnoreCase(n.getNodeName())) {\r\n                            NamedNodeMap nnm3 = n.getAttributes();\r\n                            String key = nnm3.getNamedItem(\"name\").getNodeValue();\r\n                            String value = nnm3.getNamedItem(\"value\").getNodeValue();\r\n                            if (key != null && key.length() > 0) {\r\n                                f.add(key, value);\r\n                            }\r\n                        }\r\n                    }\r\n                    Context.getCurrentLogger().fine(\" Form size to send = \" + f.size());\r\n                    if (resource == null) {\r\n                        resource = new ClientResource(action);\r\n                    }\r\n                    resource.setReference(action);\r\n                    output = resource.post(f.getWebRepresentation());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return output;\r\n}"
}, {
	"Path": "org.restlet.ext.freemarker.TemplateFilter.setDataModel",
	"Comment": "sets the template data model common to all calls. if each call shouldhave a specific model, you should set this property to null.",
	"Method": "void setDataModel(Object dataModel){\r\n    this.dataModel = dataModel;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Feed.setLogo",
	"Comment": "sets the image that provides visual identification for a feed.",
	"Method": "void setLogo(Reference logo){\r\n    this.logo = logo;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.AbstractUriBuilder.buildFromMap",
	"Comment": "build a uri, any uri template parameters will be replaced by the value inthe supplied map. the build method does not change the stateof the uribuilder and it may be called multiple times on thesame builder instance.",
	"Method": "URI buildFromMap(Map<String, ? extends Object> values,URI buildFromMap,Map<String, ? extends Object> values,boolean encode){\r\n    final Template template = new Template(toStringWithCheck(false));\r\n    return buildUri(template.format(new Resolver<String>() {\r\n        @Override\r\n        public String resolve(String variableName) {\r\n            final Object varValue = values.get(variableName);\r\n            if (varValue == null) {\r\n                throw new IllegalArgumentException(\"The value Map must contain a value for all given Templet variables. The value for variable \" + variableName + \" is missing\");\r\n            }\r\n            return EncodeOrCheck.all(varValue.toString(), encode);\r\n        }\r\n    }));\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.AbstractUriBuilder.buildFromMap",
	"Comment": "build a uri, any uri template parameters will be replaced by the value inthe supplied map. the build method does not change the stateof the uribuilder and it may be called multiple times on thesame builder instance.",
	"Method": "URI buildFromMap(Map<String, ? extends Object> values,URI buildFromMap,Map<String, ? extends Object> values,boolean encode){\r\n    final Object varValue = values.get(variableName);\r\n    if (varValue == null) {\r\n        throw new IllegalArgumentException(\"The value Map must contain a value for all given Templet variables. The value for variable \" + variableName + \" is missing\");\r\n    }\r\n    return EncodeOrCheck.all(varValue.toString(), encode);\r\n}"
}, {
	"Path": "org.restlet.ext.xml.DomRepresentation.isIndenting",
	"Comment": "indicates if the xml serialization should be indented. false by default.",
	"Method": "boolean isIndenting(){\r\n    return indenting;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.Resolver.resolveNumFloat",
	"Comment": "returns the classdef type of the float primitive type.this may need to be amended, based on the java language spec, to returna double if the literal is larger than a float can hold.",
	"Method": "IClass resolveNumFloat(SymTabAST expression,Scope location,IClass context){\r\n    return PrimitiveClasses.DOUBLE;\r\n}"
}, {
	"Path": "org.restlet.util.RouteList.subList",
	"Comment": "returns a view of the portion of this list between the specifiedfromindex, inclusive, and toindex, exclusive.",
	"Method": "RouteList subList(int fromIndex,int toIndex){\r\n    return new RouteList(getDelegate().subList(fromIndex, toIndex));\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.MethodSignature.toString",
	"Comment": "returns a string representation of this object.includes informationabout the types of the arguments in the signature",
	"Method": "String toString(){\r\n    StringBuffer result = new StringBuffer(\"(\");\r\n    for (int i = 0; i < _argTypes.length; i++) {\r\n        result.append(_argTypes[i] != null ? _argTypes[i].getName() : \"[null]\");\r\n        if (i < (_argTypes.length - 1)) {\r\n            result.append(\", \");\r\n        }\r\n    }\r\n    result.append(\")\");\r\n    return result.toString();\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.reflect.ReflectUtils.buildTypeName",
	"Comment": "generates the name of the given type into the given stringbuilder.",
	"Method": "void buildTypeName(java.lang.reflect.Type type,StringBuilder sb){\r\n    if (type instanceof Class<?>) {\r\n        if (((Class<?>) type).isArray()) {\r\n            buildTypeName(((Class<?>) type).getComponentType(), sb);\r\n            sb.append(\"[]\");\r\n        } else {\r\n            sb.append(((Class<?>) type).getName());\r\n        }\r\n    } else if (type instanceof GenericArrayType) {\r\n        buildTypeName(((GenericArrayType) type).getGenericComponentType(), sb);\r\n        sb.append(\"[]\");\r\n    } else if (type instanceof ParameterizedType) {\r\n        ParameterizedType t = (ParameterizedType) type;\r\n        buildTypeName(t.getRawType(), sb);\r\n        sb.append(\"<\");\r\n        if (t.getActualTypeArguments().length >= 1) {\r\n            buildTypeName(t.getActualTypeArguments()[0], sb);\r\n            for (int i = 1; i < t.getActualTypeArguments().length; i++) {\r\n                sb.append(\", \");\r\n                buildTypeName(t.getActualTypeArguments()[i], sb);\r\n            }\r\n        }\r\n        sb.append(\">\");\r\n    } else {\r\n        sb.append(type.toString());\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.atom.FeedReader.startEntry",
	"Comment": "called when a new entry has been detected in the atom document.",
	"Method": "void startEntry(Entry entry){\r\n    if (this.feedReader != null) {\r\n        this.feedReader.startEntry(entry);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.service.MetadataService.getCharacterSet",
	"Comment": "returns the character set associated to this extension. it returns nullif the extension was not declared of it is corresponds to another type ofmedatata such as a media type. if several metadata are associated to thesame extension then only the first matching metadata is returned.",
	"Method": "CharacterSet getCharacterSet(String extension){\r\n    return getMetadata(extension, CharacterSet.class);\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Service.getValueRef",
	"Comment": "returns the reference of the binary representation of the given entity,if this is a media resource. it returns null otherwise.",
	"Method": "Reference getValueRef(Object entity){\r\n    if (entity != null) {\r\n        Metadata metadata = (Metadata) getMetadata();\r\n        EntityType type = metadata.getEntityType(entity.getClass());\r\n        if (type.isBlob() && type.getBlobValueRefProperty() != null) {\r\n            try {\r\n                return (Reference) ReflectUtils.invokeGetter(entity, type.getBlobValueRefProperty().getName());\r\n            } catch (Exception e) {\r\n                getLogger().warning(\"Cannot get the value of the property \" + type.getBlobValueRefProperty().getName() + \" on \" + entity);\r\n            }\r\n        } else {\r\n            getLogger().warning(\"This entity is not a media resource \" + entity);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.DigestAuthenticator.getMaxServerNonceAge",
	"Comment": "returns the number of milliseconds between each mandatory nonce refresh.",
	"Method": "long getMaxServerNonceAge(){\r\n    return this.maxServerNonceAge;\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.delete",
	"Comment": "deletes the target resource and all its representations. if a successstatus is not returned, then a resource exception is thrown.",
	"Method": "Representation delete(T delete,Class<T> resultClass,Representation delete,MediaType mediaType){\r\n    return handle(Method.DELETE, mediaType);\r\n}"
}, {
	"Path": "org.restlet.engine.util.InternetDateFormat.getTime",
	"Comment": "gets the value of this internetdateformat object as millisecond timevalue.",
	"Method": "long getTime(){\r\n    return cal.getTimeInMillis();\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.Link.getSource",
	"Comment": "returns the source which can be either a reference or a link or a graphor null. this maps with the concept of subject in rdf terminology.",
	"Method": "Object getSource(){\r\n    return this.source;\r\n}"
}, {
	"Path": "org.restlet.ext.json.JsonRepresentation.getJsonObject",
	"Comment": "gets the wrapped json object or converts the wrapped representation ifneeded.",
	"Method": "JSONObject getJsonObject(){\r\n    if (this.jsonValue != null) {\r\n        return (JSONObject) this.jsonValue;\r\n    }\r\n    return new JSONObject(getJsonText());\r\n}"
}, {
	"Path": "org.restlet.ext.servlet.ServletUtils.getRequest",
	"Comment": "returns the servlet request that was used to generate the given restletrequest.",
	"Method": "HttpServletRequest getRequest(Request request){\r\n    HttpServletRequest result = null;\r\n    if (request instanceof HttpRequest) {\r\n        Call call = ((HttpRequest) request).getHttpCall();\r\n        if (call instanceof ServletCall) {\r\n            result = ((ServletCall) call).getRequest();\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.javamail.JavaMailClientHelper.isDebug",
	"Comment": "indicates if the connector should generate javamail debug messages.",
	"Method": "boolean isDebug(){\r\n    return Boolean.parseBoolean(getHelpedParameters().getFirstValue(\"debug\", \"false\"));\r\n}"
}, {
	"Path": "org.restlet.service.TunnelService.setPreferencesTunnel",
	"Comment": "indicates if the client preferences can be tunneled via the queryparameters.",
	"Method": "void setPreferencesTunnel(boolean preferencesTunnel){\r\n    this.preferencesTunnel = preferencesTunnel;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.ExceptionHandler.runtimeExecption",
	"Comment": "handles the given exception, catched by an invoke of a resource method ora creation if a sub resource object.",
	"Method": "RequestHandledException runtimeExecption(RuntimeException exception,AbstractMethodWrapper jaxRsMethod,CallContext callContext,String logMessage){\r\n    callContext.getResponse().setStatus(org.restlet.data.Status.SERVER_ERROR_INTERNAL);\r\n    if (jaxRsMethod != null) {\r\n        logMessage = jaxRsMethod + \": \" + logMessage;\r\n    }\r\n    this.logger.log(Level.WARNING, jaxRsMethod + \": \" + logMessage, exception);\r\n    throw new RequestHandledException();\r\n}"
}, {
	"Path": "org.restlet.service.TaskService.isDaemon",
	"Comment": "indicates whether the threads are created as daemon threads.",
	"Method": "boolean isDaemon(){\r\n    return daemon;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.EntityContainer.isDefaultEntityContainer",
	"Comment": "return true if this container is the default one for a wcf data service.",
	"Method": "boolean isDefaultEntityContainer(){\r\n    return defaultEntityContainer;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.GrammarsInfo.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    if (getDocumentations().isEmpty() && getIncludes().isEmpty()) {\r\n        writer.emptyElement(APP_NAMESPACE, \"grammars\");\r\n    } else {\r\n        writer.startElement(APP_NAMESPACE, \"grammars\");\r\n        for (final DocumentationInfo documentationInfo : getDocumentations()) {\r\n            documentationInfo.writeElement(writer);\r\n        }\r\n        for (final IncludeInfo includeInfo : getIncludes()) {\r\n            includeInfo.writeElement(writer);\r\n        }\r\n        writer.endElement(APP_NAMESPACE, \"grammars\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.controller.Controller.run",
	"Comment": "listens on the given server socket for incoming connections.",
	"Method": "void run(){\r\n    try {\r\n        doInit();\r\n        setRunning(true);\r\n        long sleepTime = getHelper().getControllerSleepTimeMs();\r\n        boolean hasWorkerThreads = getHelper().hasWorkerThreads();\r\n        boolean isWorkerServiceOverloaded;\r\n        while (isRunning()) {\r\n            try {\r\n                if (hasWorkerThreads) {\r\n                    isWorkerServiceOverloaded = getHelper().isWorkerServiceOverloaded();\r\n                    if (isOverloaded() && !isWorkerServiceOverloaded) {\r\n                        setOverloaded(false);\r\n                        getHelper().getLogger().info(\"Connector overload ended. Accepting new work again\");\r\n                        getHelper().traceWorkerService();\r\n                    } else if (isWorkerServiceOverloaded) {\r\n                        setOverloaded(true);\r\n                        getHelper().getLogger().info(\"Connector overload detected. Stop accepting new work\");\r\n                        getHelper().traceWorkerService();\r\n                    }\r\n                }\r\n                doRun(sleepTime);\r\n            } catch (Throwable ex) {\r\n                this.helper.getLogger().log(Level.WARNING, \"Unexpected error while controlling connector\", ex);\r\n                shutdown();\r\n            }\r\n        }\r\n    } catch (Throwable e) {\r\n        this.helper.getLogger().log(Level.WARNING, \"Unexpected error while controlling connector\", e);\r\n        shutdown();\r\n    } finally {\r\n        doRelease();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.resource.Resource.getChallengeResponse",
	"Comment": "returns the authentication response sent by a client to an origin server.",
	"Method": "ChallengeResponse getChallengeResponse(){\r\n    return getRequest() == null ? null : getRequest().getChallengeResponse();\r\n}"
}, {
	"Path": "org.restlet.engine.header.PreferenceReader.readQuality",
	"Comment": "parses a quality value.if the quality is invalid, an illegalargumentexception is thrown.",
	"Method": "float readQuality(String quality){\r\n    try {\r\n        float result = Float.valueOf(quality);\r\n        if (PreferenceWriter.isValidQuality(result)) {\r\n            return result;\r\n        }\r\n        throw new IllegalArgumentException(\"Invalid quality value detected. Value must be between 0 and 1.\");\r\n    } catch (NumberFormatException nfe) {\r\n        throw new IllegalArgumentException(\"Invalid quality value detected. Value must be between 0 and 1.\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.Component.stopHelper",
	"Comment": "stops the internal helper allowing incoming requests to be served.",
	"Method": "void stopHelper(){\r\n    if (getHelper() != null) {\r\n        getHelper().stop();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.getFullClassName",
	"Comment": "returns a correct full class name from the given name. especially, itensures that the first character of each sub package is in lower case.",
	"Method": "String getFullClassName(String name){\r\n    StringBuilder builder = new StringBuilder();\r\n    int index = name.lastIndexOf(\".\");\r\n    if (index > -1) {\r\n        builder.append(getPackageName(ReflectUtils.normalize(name.substring(0, index))));\r\n        builder.append(name.substring(index));\r\n    } else {\r\n        builder.append(name);\r\n    }\r\n    return builder.toString();\r\n}"
}, {
	"Path": "org.restlet.routing.TemplateRoute.setMatchingMode",
	"Comment": "sets the matching mode to use on the template when parsing a formattedreference.",
	"Method": "void setMatchingMode(int matchingMode){\r\n    getTemplate().setMatchingMode(matchingMode);\r\n}"
}, {
	"Path": "org.restlet.util.Series.removeFirst",
	"Comment": "removes from this list the first entry whose name equals the specifiedname ignoring the case or not.",
	"Method": "boolean removeFirst(String name,boolean removeFirst,String name,boolean ignoreCase){\r\n    boolean changed = false;\r\n    NamedValue<String> param = null;\r\n    for (final Iterator<T> iter = iterator(); iter.hasNext() && !changed; ) {\r\n        param = iter.next();\r\n        if (equals(param.getName(), name, ignoreCase)) {\r\n            iter.remove();\r\n            changed = true;\r\n        }\r\n    }\r\n    return changed;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.MetadataReader.chooseAttributeName",
	"Comment": "pick up the first method name among a given list of proposed names.returns null if the proposed values are already in the given entity type.",
	"Method": "String chooseAttributeName(EntityType type,String[] values){\r\n    String result = null;\r\n    int index = 0;\r\n    for (int i = 0; i < type.getProperties().size() && (index < values.length); i++) {\r\n        Property property = type.getProperties().get(i);\r\n        if (values[index].equals(property.getName())) {\r\n            index++;\r\n        }\r\n    }\r\n    for (int i = 0; i < type.getAssociations().size() && (index < values.length); i++) {\r\n        NavigationProperty property = type.getAssociations().get(i);\r\n        if (values[index].equals(property.getName())) {\r\n            index++;\r\n        }\r\n    }\r\n    if (index != values.length) {\r\n        result = values[index];\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.channel.ReadableChunkedChannel.getRemainingChunkSize",
	"Comment": "returns the remaining chunk size that should be read from the sourcechannel.",
	"Method": "int getRemainingChunkSize(){\r\n    return remainingChunkSize;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.WadlServerResource.getPreferredWadlVariant",
	"Comment": "returns the preferred wadl variant according to the client preferencesspecified in the request.",
	"Method": "Variant getPreferredWadlVariant(){\r\n    return getConnegService().getPreferredVariant(getWadlVariants(), getRequest(), getMetadataService());\r\n}"
}, {
	"Path": "org.restlet.engine.local.DirectoryServerResource.getRepresentationsComparator",
	"Comment": "allows to sort the list of representations set by the resource.",
	"Method": "Comparator<Representation> getRepresentationsComparator(){\r\n    Comparator<Representation> identifiersComparator = new Comparator<Representation>() {\r\n        public int compare(Representation rep0, Representation rep1) {\r\n            boolean bRep0Null = (rep0.getLocationRef() == null);\r\n            boolean bRep1Null = (rep1.getLocationRef() == null);\r\n            if (bRep0Null && bRep1Null) {\r\n                return 0;\r\n            }\r\n            if (bRep0Null) {\r\n                return -1;\r\n            }\r\n            if (bRep1Null) {\r\n                return 1;\r\n            }\r\n            return rep0.getLocationRef().getLastSegment().compareTo(rep1.getLocationRef().getLastSegment());\r\n        }\r\n    };\r\n    return identifiersComparator;\r\n}"
}, {
	"Path": "org.restlet.engine.local.DirectoryServerResource.getRepresentationsComparator",
	"Comment": "allows to sort the list of representations set by the resource.",
	"Method": "Comparator<Representation> getRepresentationsComparator(){\r\n    boolean bRep0Null = (rep0.getLocationRef() == null);\r\n    boolean bRep1Null = (rep1.getLocationRef() == null);\r\n    if (bRep0Null && bRep1Null) {\r\n        return 0;\r\n    }\r\n    if (bRep0Null) {\r\n        return -1;\r\n    }\r\n    if (bRep1Null) {\r\n        return 1;\r\n    }\r\n    return rep0.getLocationRef().getLastSegment().compareTo(rep1.getLocationRef().getLastSegment());\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.way.Way.onMessageCompleted",
	"Comment": "callback method invoked when the current message has been completelyreceived or sent.",
	"Method": "void onMessageCompleted(boolean endDetected){\r\n    if (getLogger().isLoggable(Level.FINEST)) {\r\n        if (this instanceof OutboundWay) {\r\n            getLogger().log(Level.FINEST, \"OutboundWay#onCompleted: \" + endDetected);\r\n        } else {\r\n            getLogger().log(Level.FINEST, \"InboundWay#onCompleted: \" + endDetected);\r\n        }\r\n    }\r\n    setIoState(IoState.IDLE);\r\n    setMessageState(MessageState.IDLE);\r\n    setMessage(null);\r\n    setHeaders(null);\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.connection.SslConnection.initSslEngine",
	"Comment": "initializes the ssl engine with the current ssl context and socketaddress.",
	"Method": "void initSslEngine(){\r\n    getSslEngine().beginHandshake();\r\n}"
}, {
	"Path": "org.restlet.routing.Router.setDefaultMatchingQuery",
	"Comment": "sets the default setting for whether the routing should be done on uriswith or without taking into account query string. by default, it is setto false.",
	"Method": "void setDefaultMatchingQuery(boolean defaultMatchingQuery){\r\n    this.defaultMatchingQuery = defaultMatchingQuery;\r\n}"
}, {
	"Path": "org.restlet.ext.servlet.ServerServlet.isDefaultComponent",
	"Comment": "indicates if the component hosted by this servlet is the default one orone provided by the user.",
	"Method": "boolean isDefaultComponent(){\r\n    Client client = createWarClient(new Context(), getServletConfig());\r\n    Response response = client.handle(new Request(Method.GET, \"war:///WEB-INF/restlet.xml\"));\r\n    if (response.getStatus().isSuccess() && response.isEntityAvailable()) {\r\n        return false;\r\n    }\r\n    String componentAttributeName = getInitParameter(COMPONENT_KEY, null);\r\n    if (componentAttributeName != null) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.restlet.data.Reference.isSubDelimiter",
	"Comment": "indicates if the given character is an uri subcomponent delimitercharacter.",
	"Method": "boolean isSubDelimiter(int character){\r\n    return (character == '!') || (character == '$') || (character == '&') || (character == '\\'') || (character == '(') || (character == ')') || (character == '*') || (character == '+') || (character == ',') || (character == ';') || (character == '=');\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsRestlet.getRootResourceClasses",
	"Comment": "returns an unmodifiable set with the attached root resource classes.",
	"Method": "Set<Class<?>> getRootResourceClasses(){\r\n    Set<Class<?>> rrcs = new HashSet<Class<?>>();\r\n    for (RootResourceClass rootResourceClass : this.resourceClasses.roots()) rrcs.add(rootResourceClass.getJaxRsClass());\r\n    return Collections.unmodifiableSet(rrcs);\r\n}"
}, {
	"Path": "org.restlet.engine.util.FormReader.readParameters",
	"Comment": "reads the parameters whose name is a key in the given map. if a matchingparameter is found, its value is put in the map. if multiple values arefound, a list is created and set in the map.",
	"Method": "void readParameters(Map<String, Object> parameters){\r\n    if (this.stream != null) {\r\n        Parameter param = readNextParameter();\r\n        Object currentValue = null;\r\n        while (param != null) {\r\n            if (parameters.containsKey(param.getName())) {\r\n                currentValue = parameters.get(param.getName());\r\n                if (currentValue != null) {\r\n                    List<Object> values = null;\r\n                    if (currentValue instanceof List) {\r\n                        values = (List<Object>) currentValue;\r\n                    } else {\r\n                        values = new ArrayList<Object>();\r\n                        values.add(currentValue);\r\n                        parameters.put(param.getName(), values);\r\n                    }\r\n                    if (param.getValue() == null) {\r\n                        values.add(Series.EMPTY_VALUE);\r\n                    } else {\r\n                        values.add(param.getValue());\r\n                    }\r\n                } else {\r\n                    if (param.getValue() == null) {\r\n                        parameters.put(param.getName(), Series.EMPTY_VALUE);\r\n                    } else {\r\n                        parameters.put(param.getName(), param.getValue());\r\n                    }\r\n                }\r\n            }\r\n            param = readNextParameter();\r\n        }\r\n        this.stream.close();\r\n    }\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.ASTUtil.constructPackage",
	"Comment": "returns the package name in the hierarchy represented by the symtabast.",
	"Method": "String constructPackage(SymTabAST tree){\r\n    String fullName = constructDottedName(tree);\r\n    return fullName.substring(0, fullName.lastIndexOf(\".\"));\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.TableMaker.finishCreatingChildren",
	"Comment": "iterates through all the definitions in thescope finishes creating each scope.",
	"Method": "void finishCreatingChildren(Scope scope){\r\n    Enumeration definitions = scope.getDefinitions();\r\n    while (definitions.hasMoreElements()) {\r\n        Definition child = (Definition) (definitions.nextElement());\r\n        finishCreatingDefinition(child);\r\n    }\r\n}"
}, {
	"Path": "com.restfb.types.webhook.messaging.PolicyEnforcementItem.isUnblock",
	"Comment": "convenience method to check the action of the policy enforcement",
	"Method": "boolean isUnblock(){\r\n    return UNBLOCK.equals(action);\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.DefaultSslContextFactory.getSelectedCipherSuites",
	"Comment": "returns the selected cipher suites. the selection is the subset ofsupported suites that are both in the enable suites and out of thedisabled suites.",
	"Method": "String[] getSelectedCipherSuites(String[] supportedCipherSuites){\r\n    Set<String> resultSet = new HashSet<String>();\r\n    if (supportedCipherSuites != null) {\r\n        for (String supportedCipherSuite : supportedCipherSuites) {\r\n            if (((getEnabledCipherSuites() == null) || Arrays.asList(getEnabledCipherSuites()).contains(supportedCipherSuite)) && ((getDisabledCipherSuites() == null) || !Arrays.asList(getDisabledCipherSuites()).contains(supportedCipherSuite))) {\r\n                resultSet.add(supportedCipherSuite);\r\n            }\r\n        }\r\n    }\r\n    String[] result = new String[resultSet.size()];\r\n    return resultSet.toArray(result);\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.connection.SslConnection.onWrap",
	"Comment": "callback invoked when the ssl handshake requires wrapping.",
	"Method": "void onWrap(){\r\n    getInboundWay().setIoState(IoState.IDLE);\r\n    if (getOutboundWay().getIoState() == IoState.IDLE) {\r\n        getOutboundWay().setIoState(IoState.READY);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.httpclient.internal.HttpIdleConnectionReaper.waitForReaperStart",
	"Comment": "tells the reaper thread the maximum time to wait before starting.",
	"Method": "void waitForReaperStart(long millis){\r\n    reaperThread.waitForStart(millis);\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.isResponseEntityBuffering",
	"Comment": "indicates if transient or unknown size response entities should bebuffered after being received. this is useful to be able tosystematically reuse and process a response entity several times afterretrieval.",
	"Method": "boolean isResponseEntityBuffering(){\r\n    return responseEntityBuffering;\r\n}"
}, {
	"Path": "org.restlet.security.SecretVerifier.createUser",
	"Comment": "called back to create a new user when valid credentials are provided.",
	"Method": "User createUser(String identifier,Request request,Response response){\r\n    return new User(identifier);\r\n}"
}, {
	"Path": "org.restlet.engine.util.Base64.decode",
	"Comment": "decodes a base64 string into bytes. newline characters found at blockboundaries will be ignored.",
	"Method": "byte[] decode(char[] chars,byte[] decode,String encodedString){\r\n    return decode(encodedString.toCharArray());\r\n}"
}, {
	"Path": "com.restfb.FacebookClientTest.oauthExceptionWithErrorSubcode",
	"Comment": "do we correctly handle the case where fb returns an oauthexception with an error code and subcode?",
	"Method": "void oauthExceptionWithErrorSubcode(){\r\n    FacebookClient facebookClient = facebookClientWithResponse(new Response(403, \"{\\\"error\\\":{\\\"message\\\":\\\"App Not Installed\\\",\\\"type\\\":\\\"OAuthException\\\",\\\"code\\\":190,\\\"error_subcode\\\":458}}\"));\r\n    try {\r\n        facebookClient.fetchObject(\"me\", User.class);\r\n        failBecauseExceptionWasNotThrown(FacebookOAuthException.class);\r\n    } catch (FacebookOAuthException e) {\r\n        assertThat(e.getErrorMessage()).isEqualTo(\"App Not Installed\");\r\n        assertThat(e.getErrorType()).isEqualTo(\"OAuthException\");\r\n        assertThat(e.getErrorCode()).isEqualTo(190);\r\n        assertThat(e.getErrorSubcode()).isEqualTo(458);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.util.StringUtils.getAsciiBytes",
	"Comment": "encodes the given string into a sequence of bytes using the asciicharacter set.",
	"Method": "byte[] getAsciiBytes(String string){\r\n    if (string != null) {\r\n        try {\r\n            return string.getBytes(\"US-ASCII\");\r\n        } catch (Exception e) {\r\n            return null;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.resource.ServerResource.setAnnotated",
	"Comment": "indicates if annotations are supported. the default value is true.",
	"Method": "void setAnnotated(boolean annotated){\r\n    this.annotated = annotated;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxb.JaxbConverter.isCompatible",
	"Comment": "indicates if the given variant is compatible with the media typessupported by this converter.",
	"Method": "boolean isCompatible(MediaType mediaType,boolean isCompatible,Variant variant){\r\n    return (variant != null) && (VARIANT_APPLICATION_ALL_XML.isCompatible(variant) || VARIANT_APPLICATION_XML.isCompatible(variant) || VARIANT_TEXT_XML.isCompatible(variant));\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.addQueryParameters",
	"Comment": "adds several parameters to the query component. the name and value areautomatically encoded if necessary.",
	"Method": "Reference addQueryParameters(Iterable<Parameter> parameters){\r\n    return getReference().addQueryParameters(parameters);\r\n}"
}, {
	"Path": "org.restlet.data.ClientInfo.getPreferredMetadata",
	"Comment": "returns the preferred metadata taking into account both metadatasupported by the server and client preferences.",
	"Method": "T getPreferredMetadata(List<T> supported,List<Preference<T>> preferences){\r\n    T result = null;\r\n    float maxQuality = 0;\r\n    if (supported != null) {\r\n        for (Preference<T> pref : preferences) {\r\n            for (T metadata : supported) {\r\n                if (pref.getMetadata().isCompatible(metadata) && (pref.getQuality() > maxQuality)) {\r\n                    result = metadata;\r\n                    maxQuality = pref.getQuality();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.routing.Router.attach",
	"Comment": "attaches a target restlet to this router based on a given uri pattern. anew route will be added routing to the target when calls with a urimatching the pattern will be received.",
	"Method": "TemplateRoute attach(Restlet target,TemplateRoute attach,Restlet target,int matchingMode,TemplateRoute attach,String pathTemplate,Class<? extends ServerResource> targetClass,TemplateRoute attach,String pathTemplate,Class<? extends ServerResource> targetClass,int matchingMode,TemplateRoute attach,String pathTemplate,Restlet target,TemplateRoute attach,String pathTemplate,Restlet target,int matchingMode){\r\n    TemplateRoute result = createRoute(pathTemplate, target, matchingMode);\r\n    getRoutes().add(result);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.resource.ClientInvocationHandler.invoke",
	"Comment": "effectively invokes a java method on the given proxy object.",
	"Method": "Object invoke(Object proxy,java.lang.reflect.Method javaMethod,Object[] args){\r\n    Object result = null;\r\n    if (javaMethod.equals(Object.class.getMethod(\"toString\"))) {\r\n        result = \"ClientProxy for resource: \" + clientResource;\r\n    } else if (javaMethod.equals(ClientProxy.class.getMethod(\"getClientResource\"))) {\r\n        result = clientResource;\r\n    } else {\r\n        MethodAnnotationInfo annotationInfo = getAnnotationUtils().getMethodAnnotation(getAnnotations(), javaMethod);\r\n        if (annotationInfo != null) {\r\n            Representation requestEntity = null;\r\n            if ((args != null) && args.length > 0) {\r\n                for (int i = 0; i < args.length; i++) {\r\n                    Object o = args[i];\r\n                    if (o == null) {\r\n                        requestEntity = null;\r\n                    } else if (Result.class.isAssignableFrom(o.getClass())) {\r\n                        final Result rCallback = (Result) o;\r\n                        Type[] genericParameterTypes = javaMethod.getGenericParameterTypes();\r\n                        Type genericParameterType = genericParameterTypes[i];\r\n                        ParameterizedType parameterizedType = (genericParameterType instanceof java.lang.reflect.ParameterizedType) ? (java.lang.reflect.ParameterizedType) genericParameterType : null;\r\n                        final Class<?> actualType = (parameterizedType != null && parameterizedType.getActualTypeArguments()[0] instanceof Class<?>) ? (Class<?>) parameterizedType.getActualTypeArguments()[0] : null;\r\n                        Uniform callback = new Uniform() {\r\n                            @SuppressWarnings(\"unchecked\")\r\n                            public void handle(Request request, Response response) {\r\n                                if (response.getStatus().isError()) {\r\n                                    rCallback.onFailure(new ResourceException(response.getStatus()));\r\n                                } else {\r\n                                    if (actualType != null) {\r\n                                        Object result = null;\r\n                                        boolean serializationError = false;\r\n                                        try {\r\n                                            result = getClientResource().toObject(response.getEntity(), actualType);\r\n                                        } catch (Exception e) {\r\n                                            serializationError = true;\r\n                                            rCallback.onFailure(new ResourceException(e));\r\n                                        }\r\n                                        if (!serializationError) {\r\n                                            rCallback.onSuccess(result);\r\n                                        }\r\n                                    } else {\r\n                                        rCallback.onSuccess(null);\r\n                                    }\r\n                                }\r\n                            }\r\n                        };\r\n                        getClientResource().setOnResponse(callback);\r\n                    } else {\r\n                        requestEntity = getClientResource().toRepresentation(o);\r\n                    }\r\n                }\r\n            }\r\n            Request request = getRequest(javaMethod, args);\r\n            request.setMethod(annotationInfo.getRestletMethod());\r\n            String query = annotationInfo.getQuery();\r\n            if (query != null) {\r\n                Form queryParams = new Form(annotationInfo.getQuery());\r\n                request.getResourceRef().addQueryParameters(queryParams);\r\n            }\r\n            request.setEntity(requestEntity);\r\n            if ((request.getClientInfo().getAcceptedCharacterSets().isEmpty()) && (request.getClientInfo().getAcceptedEncodings().isEmpty()) && (request.getClientInfo().getAcceptedLanguages().isEmpty()) && (request.getClientInfo().getAcceptedMediaTypes().isEmpty())) {\r\n                List<Variant> responseVariants = annotationInfo.getResponseVariants(getClientResource().getMetadataService(), getClientResource().getConverterService());\r\n                if (responseVariants != null) {\r\n                    request.setClientInfo(new ClientInfo(responseVariants));\r\n                }\r\n            }\r\n            Response response = getClientResource().handleOutbound(request);\r\n            if (getClientResource().getOnResponse() == null) {\r\n                if ((response != null) && response.getStatus().isError()) {\r\n                    ThrowableAnnotationInfo tai = getAnnotationUtils().getThrowableAnnotationInfo(javaMethod, response.getStatus().getCode());\r\n                    if (tai != null) {\r\n                        Class<?> throwableClazz = tai.getJavaClass();\r\n                        Throwable t = null;\r\n                        if (tai.isSerializable() && response.isEntityAvailable()) {\r\n                            t = (Throwable) getClientResource().toObject(response.getEntity(), throwableClazz);\r\n                        } else {\r\n                            try {\r\n                                t = (Throwable) throwableClazz.newInstance();\r\n                            } catch (Exception e) {\r\n                                Context.getCurrentLogger().log(Level.FINE, \"Unable to instantiate the client-side exception using the default constructor.\");\r\n                            }\r\n                            if (response.isEntityAvailable()) {\r\n                                StatusInfo si = getClientResource().toObject(response.getEntity(), StatusInfo.class);\r\n                                if (si != null) {\r\n                                    response.setStatus(new Status(si.getCode(), si.getReasonPhrase(), si.getDescription()));\r\n                                }\r\n                            }\r\n                        }\r\n                        if (t != null) {\r\n                            throw t;\r\n                        }\r\n                    }\r\n                    getClientResource().doError(response.getStatus());\r\n                } else if (!annotationInfo.getJavaOutputType().equals(void.class)) {\r\n                    result = getClientResource().toObject((response == null ? null : response.getEntity()), annotationInfo.getJavaOutputType());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.resource.ClientInvocationHandler.invoke",
	"Comment": "effectively invokes a java method on the given proxy object.",
	"Method": "Object invoke(Object proxy,java.lang.reflect.Method javaMethod,Object[] args){\r\n    if (response.getStatus().isError()) {\r\n        rCallback.onFailure(new ResourceException(response.getStatus()));\r\n    } else {\r\n        if (actualType != null) {\r\n            Object result = null;\r\n            boolean serializationError = false;\r\n            try {\r\n                result = getClientResource().toObject(response.getEntity(), actualType);\r\n            } catch (Exception e) {\r\n                serializationError = true;\r\n                rCallback.onFailure(new ResourceException(e));\r\n            }\r\n            if (!serializationError) {\r\n                rCallback.onSuccess(result);\r\n            }\r\n        } else {\r\n            rCallback.onSuccess(null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Service.getMetadata",
	"Comment": "returns the metadata document related to the current service.",
	"Method": "Object getMetadata(){\r\n    if (metadata == null) {\r\n        ClientResource resource = createResource(\"$metadata\");\r\n        try {\r\n            getLogger().log(Level.INFO, \"Get the metadata for \" + getServiceRef() + \" at \" + resource.getReference());\r\n            Representation rep = resource.get(MediaType.APPLICATION_XML);\r\n            this.metadata = new Metadata(rep, resource.getReference());\r\n        } catch (ResourceException e) {\r\n            getLogger().log(Level.SEVERE, \"Can't get the metadata for \" + getServiceRef() + \" (response's status: \" + resource.getStatus() + \")\");\r\n        } catch (Exception e) {\r\n            getLogger().log(Level.SEVERE, \"Can't get the metadata for \" + getServiceRef(), e);\r\n        } finally {\r\n            this.latestRequest = resource.getRequest();\r\n            this.latestResponse = resource.getResponse();\r\n        }\r\n    }\r\n    return metadata;\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.getParent",
	"Comment": "wraps the parent client resource to proxy calls to the given javainterface into restlet method calls. the parent resource is defined inthe sense of hierarchical uris. if the resource uri is not hierarchical,then an exception is thrown.",
	"Method": "ClientResource getParent(T getParent,Class<? extends T> resourceInterface){\r\n    T result = null;\r\n    ClientResource parentResource = getParent();\r\n    if (parentResource != null) {\r\n        result = parentResource.wrap(resourceInterface);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createNationalityQuery",
	"Comment": "creates a query for nationality entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Nationality> createNationalityQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Nationality.class);\r\n}"
}, {
	"Path": "org.restlet.engine.application.StrictConneg.scoreEncodings",
	"Comment": "scores encodings relatively to enriched client preferences.",
	"Method": "float scoreEncodings(List<Encoding> encodings){\r\n    return scoreMetadata(encodings, getEncodingPrefs());\r\n}"
}, {
	"Path": "org.restlet.ext.servlet.ServerServlet.getLocalPort",
	"Comment": "intercepter method need for subclasses such as xdbserverservlet.",
	"Method": "int getLocalPort(HttpServletRequest request){\r\n    return request.getLocalPort();\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.Util.notEndsWith",
	"Comment": "checks, if the given charsequence ends with the given character.",
	"Method": "boolean notEndsWith(CharSequence charSequence,char character){\r\n    if (charSequence == null)\r\n        return true;\r\n    if (charSequence.length() == 0)\r\n        return true;\r\n    return charSequence.charAt(charSequence.length() - 1) != character;\r\n}"
}, {
	"Path": "org.restlet.example.firstResource.FirstResourceApplication.createInboundRoot",
	"Comment": "creates a root restlet that will receive all incoming calls.",
	"Method": "Restlet createInboundRoot(){\r\n    Router router = new Router(getContext());\r\n    router.attach(\"/items\", ItemsResource.class);\r\n    router.attach(\"/items/{itemName}\", ItemResource.class);\r\n    return router;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.OptionInfo.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    final AttributesImpl attributes = new AttributesImpl();\r\n    if ((getValue() != null) && !getValue().equals(\"\")) {\r\n        attributes.addAttribute(\"\", \"id\", null, \"xs:string\", getValue());\r\n    }\r\n    if (getDocumentations().isEmpty()) {\r\n        writer.emptyElement(APP_NAMESPACE, \"option\", null, attributes);\r\n    } else {\r\n        writer.startElement(APP_NAMESPACE, \"option\", null, attributes);\r\n        for (final DocumentationInfo documentationInfo : getDocumentations()) {\r\n            documentationInfo.writeElement(writer);\r\n        }\r\n        writer.endElement(APP_NAMESPACE, \"option\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.service.MetadataService.getAllMediaTypeExtensionNames",
	"Comment": "return the ordered list of extension names mapped to media types.",
	"Method": "List<String> getAllMediaTypeExtensionNames(){\r\n    List<String> result = new ArrayList<String>();\r\n    for (MetadataExtension mapping : this.mappings) {\r\n        if ((mapping.getMetadata() instanceof MediaType) && !result.contains(mapping.getName())) {\r\n            result.add(mapping.getName());\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.channel.WritableTraceChannel.write",
	"Comment": "writes the available byte from the wrapped channel to the destinationbuffer while writing them to the console.",
	"Method": "int write(ByteBuffer src){\r\n    int oldPos = src.position();\r\n    int off = src.arrayOffset() + oldPos;\r\n    int result = getWrappedChannel().write(src);\r\n    int newPos = src.position();\r\n    if ((result > 0) && (newPos > oldPos)) {\r\n        System.out.write(src.array(), off, newPos - oldPos);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlRepresentation.getNodes",
	"Comment": "evaluates an xpath expression as a dom nodelist. if the evaluation fails,null will be returned.",
	"Method": "NodeList getNodes(String expression){\r\n    final org.w3c.dom.NodeList nodes = (org.w3c.dom.NodeList) internalEval(expression, javax.xml.xpath.XPathConstants.NODESET);\r\n    return (nodes == null) ? null : new NodeList(nodes);\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Generator.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    final AttributesImpl attributes = new AttributesImpl();\r\n    if ((getUri() != null) && (getUri().toString() != null)) {\r\n        attributes.addAttribute(\"\", \"uri\", null, \"atomURI\", getUri().toString());\r\n    }\r\n    if (getVersion() != null) {\r\n        attributes.addAttribute(\"\", \"version\", null, \"text\", getVersion());\r\n    }\r\n    if (getName() != null) {\r\n        writer.dataElement(ATOM_NAMESPACE, \"generator\", null, attributes, getName());\r\n    } else {\r\n        writer.emptyElement(ATOM_NAMESPACE, \"generator\", null, attributes);\r\n    }\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.checks.AbstractReferenceCheck.equalScope",
	"Comment": "tests whether the scope of a field or method is compatiblewith the scope of this check. references for compatiblefields or methods should be checked.",
	"Method": "boolean equalScope(FieldOrMethod aFieldOrMethod){\r\n    if (aFieldOrMethod.isPrivate()) {\r\n        return (mScope == Scope.PRIVATE);\r\n    } else if (aFieldOrMethod.isProtected()) {\r\n        return (mScope == Scope.PROTECTED);\r\n    } else if (aFieldOrMethod.isPublic()) {\r\n        return (mScope == Scope.PUBLIC);\r\n    } else {\r\n        return (mScope == Scope.PACKAGE);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jackson.JacksonRepresentation.createObjectReader",
	"Comment": "creates a jackson object reader based on a mapper. has a special handlingfor csv media types.",
	"Method": "ObjectReader createObjectReader(){\r\n    ObjectReader result = null;\r\n    if (MediaType.TEXT_CSV.isCompatible(getMediaType())) {\r\n        CsvMapper csvMapper = (CsvMapper) getObjectMapper();\r\n        CsvSchema csvSchema = createCsvSchema(csvMapper);\r\n        result = csvMapper.reader(getObjectClass()).with(csvSchema);\r\n    } else {\r\n        result = getObjectMapper().reader(getObjectClass());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.connection.SslConnection.onUnwrap",
	"Comment": "callback invoked when the ssl handshake requires unwrapping.",
	"Method": "void onUnwrap(){\r\n    getOutboundWay().setIoState(IoState.IDLE);\r\n    if (getInboundWay().getIoState() != IoState.PROCESSING) {\r\n        getInboundWay().setIoState(IoState.READY);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.adapter.ClientCall.getLocalAddress",
	"Comment": "returns the local ip address or 127.0.0.1 if the resolution fails.",
	"Method": "String getLocalAddress(){\r\n    try {\r\n        return java.net.InetAddress.getLocalHost().getHostAddress();\r\n    } catch (java.net.UnknownHostException e) {\r\n        return \"127.0.0.1\";\r\n    }\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createInvitationQuery",
	"Comment": "creates a query for invitation entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Invitation> createInvitationQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Invitation.class);\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.swagger.v1_2.SwaggerReader.translate",
	"Comment": "translates a swagger resource listing to a restlet definition.",
	"Method": "Definition translate(ApiDeclaration apiDeclaration,String sectionName,Definition translate,ResourceListing listing,Map<String, ApiDeclaration> apiDeclarations,Definition translate,ResourceListing listing){\r\n    Definition definition = new Definition();\r\n    fillMainAttributes(definition, listing, null);\r\n    Contract contract = definition.getContract();\r\n    fillSections(contract, listing);\r\n    LOGGER.log(Level.FINE, \"Main attributes successfully retrieved from Swagger resource listing.\");\r\n    return definition;\r\n}"
}, {
	"Path": "org.restlet.data.Reference.addQueryParameter",
	"Comment": "adds a parameter to the query component. the name and value areautomatically url encoded if necessary.",
	"Method": "Reference addQueryParameter(Parameter parameter,Reference addQueryParameter,String name,String value){\r\n    String query = getQuery();\r\n    if (query == null) {\r\n        if (value == null) {\r\n            setQuery(encode(name));\r\n        } else {\r\n            setQuery(encode(name) + '=' + encode(value));\r\n        }\r\n    } else {\r\n        if (value == null) {\r\n            setQuery(query + '&' + encode(name));\r\n        } else {\r\n            setQuery(query + '&' + encode(name) + '=' + encode(value));\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.restlet.data.Reference.isUnreserved",
	"Comment": "indicates if the given character is an unreserved uri character.",
	"Method": "boolean isUnreserved(int character){\r\n    return isAlpha(character) || isDigit(character) || (character == '-') || (character == '.') || (character == '_') || (character == '~');\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.wrap",
	"Comment": "wraps the client resource to proxy calls to the given java interface intorestlet method calls.",
	"Method": "T wrap(Class<? extends T> resourceInterface,T wrap,Class<? extends T> resourceInterface,ClassLoader classLoader){\r\n    T result = null;\r\n    java.lang.reflect.InvocationHandler h = new org.restlet.engine.resource.ClientInvocationHandler<T>(this, resourceInterface);\r\n    result = (T) java.lang.reflect.Proxy.newProxyInstance(classLoader, new Class<?>[] { ClientProxy.class, resourceInterface }, h);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.util.WrapperResponse.setChallengeRequests",
	"Comment": "sets the list of authentication requests sent by an origin server to aclient.",
	"Method": "void setChallengeRequests(List<ChallengeRequest> requests){\r\n    getWrappedResponse().setChallengeRequests(requests);\r\n}"
}, {
	"Path": "org.restlet.util.WrapperResponse.getProxyChallengeRequests",
	"Comment": "returns the list of authentication requests sent by a proxy to a client.",
	"Method": "List<ChallengeRequest> getProxyChallengeRequests(){\r\n    return getWrappedResponse().getProxyChallengeRequests();\r\n}"
}, {
	"Path": "org.restlet.Component.startHelper",
	"Comment": "starts the internal helper allowing incoming requests to be served.",
	"Method": "void startHelper(){\r\n    if (getHelper() != null) {\r\n        getHelper().start();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.DigestAuthenticator.setMaxServerNonceAge",
	"Comment": "sets the number of milliseconds between each mandatory nonce refresh.",
	"Method": "void setMaxServerNonceAge(long maxServerNonceAge){\r\n    this.maxServerNonceAge = maxServerNonceAge;\r\n}"
}, {
	"Path": "org.restlet.service.MetadataService.getMetadata",
	"Comment": "returns the metadata associated to this extension. it returns null if theextension was not declared or is not of the target metadata type.",
	"Method": "Metadata getMetadata(String extension,T getMetadata,String extension,Class<T> metadataType){\r\n    Metadata metadata = getMetadata(extension);\r\n    if (metadata != null && metadataType.isAssignableFrom(metadata.getClass())) {\r\n        return metadataType.cast(metadata);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.security.ChallengeAuthenticator.setRechallenging",
	"Comment": "indicates if a new challenge should be sent when invalid credentials arereceived.",
	"Method": "void setRechallenging(boolean rechallenging){\r\n    this.rechallenging = rechallenging;\r\n}"
}, {
	"Path": "org.restlet.engine.util.InternetDateFormat.parse",
	"Comment": "our private parse utility that parses the string, clears the calendar,and then sets the fields.",
	"Method": "void parse(String s,Calendar cal,Date parse,String source,Date parse,String source,ParsePosition pos){\r\n    return parseDate(source);\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.ReferenceVisitor.addFieldScope",
	"Comment": "includes a scope in the scope for checking field references.",
	"Method": "void addFieldScope(Scope aScope){\r\n    mFieldScopes.add(aScope);\r\n}"
}, {
	"Path": "org.restlet.test.ext.jaxrs.core.UriBuilderImplTest.assertEqualUriBuilder",
	"Comment": "note, that the actual value is at the beginning, because of theexpectedpathsegents must be the last parameter.",
	"Method": "void assertEqualUriBuilder(String expectedScheme,String expectedUserInfo,String expectedHost,String expectedPort,String expectedPath,String expectedQuery,UriBuilder actualUriBuilder,boolean compareResult){\r\n    if (actualUriBuilder.getClass().getPackage().getName().startsWith(\"org.restlet.ext.jaxrs\")) {\r\n        assertEquals(expectedScheme, getScheme(actualUriBuilder));\r\n        assertEquals(expectedUserInfo, getUserInfo(actualUriBuilder));\r\n        assertEquals(expectedHost, getHost(actualUriBuilder));\r\n        assertEquals(expectedPort, getPort(actualUriBuilder));\r\n        final String actPath = getPath(actualUriBuilder);\r\n        try {\r\n            assertEquals(expectedPath, actPath);\r\n        } catch (junit.framework.ComparisonFailure cf) {\r\n            if (expectedPath == null)\r\n                assertEquals(\"\", actPath);\r\n        }\r\n        CharSequence actualQuery = getQuery(actualUriBuilder);\r\n        if (actualQuery != null) {\r\n            actualQuery = actualQuery.toString();\r\n        }\r\n        assertEquals(expectedQuery, actualQuery);\r\n    }\r\n    if (compareResult) {\r\n        UriBuilder expectedUriBuilder = RuntimeDelegate.getInstance().createUriBuilder();\r\n        if (expectedScheme != null) {\r\n            expectedUriBuilder.scheme(expectedScheme);\r\n        }\r\n        if (expectedUserInfo != null) {\r\n            expectedUriBuilder.userInfo(expectedUserInfo);\r\n        }\r\n        if (expectedHost != null) {\r\n            expectedUriBuilder.host(expectedHost);\r\n        }\r\n        if (expectedUriBuilder instanceof UriBuilderImpl) {\r\n            ((UriBuilderImpl) expectedUriBuilder).port(expectedPort);\r\n        } else if (expectedUriBuilder instanceof ExtendedUriBuilder) {\r\n            ((ExtendedUriBuilder) expectedUriBuilder).port(expectedPort);\r\n        } else {\r\n            if (expectedPort == null || expectedPort.equals(\"\")) {\r\n                expectedUriBuilder.port(-1);\r\n            } else {\r\n                try {\r\n                    int portInt = Integer.valueOf(expectedPort);\r\n                } catch (NumberFormatException e) {\r\n                    System.out.println(\"Sorry, could not do this test with an expected port \\\"\" + expectedPort + \"\\\" and an UriBuilder of type \" + expectedUriBuilder.getClass());\r\n                }\r\n            }\r\n        }\r\n        expectedUriBuilder.path(expectedPath);\r\n        if (expectedQuery != null) {\r\n            expectedUriBuilder.replaceQuery(expectedQuery);\r\n        }\r\n        String expectedURI = expectedUriBuilder.build().toString();\r\n        String atualURI = actualUriBuilder.build().toString();\r\n        assertEquals(expectedURI, atualURI);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.ApiSparkService.setAgentCellId",
	"Comment": "sets the identifier of the cell configured on the apispark platform foryour application.",
	"Method": "void setAgentCellId(Integer agentCellId){\r\n    this.agentCellId = agentCellId;\r\n}"
}, {
	"Path": "org.restlet.data.ClientInfo.getPreferredPatch",
	"Comment": "returns the preferred patch among a list of supported ones, based on theclient preferences.",
	"Method": "MediaType getPreferredPatch(List<MediaType> supported){\r\n    return getPreferredMetadata(supported, getAcceptedPatches());\r\n}"
}, {
	"Path": "org.restlet.ext.xml.TransformRepresentation.getXmlFilter",
	"Comment": "returns the sax xml filter applying the transform sheet to its input.",
	"Method": "XMLFilter getXmlFilter(){\r\n    XMLFilter result = null;\r\n    final Templates templates = getTemplates();\r\n    if (templates != null) {\r\n        try {\r\n            result = getSaxTransformerFactory().newXMLFilter(templates);\r\n        } catch (TransformerConfigurationException tce) {\r\n            throw new IOException(\"Transformer configuration exception. \" + tce.getMessage());\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createLocationQuery",
	"Comment": "creates a query for location entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Location> createLocationQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Location.class);\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createAddressQuery",
	"Comment": "creates a query for address entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Address> createAddressQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Address.class);\r\n}"
}, {
	"Path": "org.restlet.service.ConnectorService.setClientProtocols",
	"Comment": "sets the modifiable list of required client protocols. this method clearsthe current list and adds all entries in the parameter list.",
	"Method": "void setClientProtocols(List<Protocol> clientProtocols){\r\n    synchronized (getClientProtocols()) {\r\n        if (clientProtocols != getClientProtocols()) {\r\n            getClientProtocols().clear();\r\n            if (clientProtocols != null) {\r\n                getClientProtocols().addAll(clientProtocols);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.checks.AbstractReferenceCheck.ignore",
	"Comment": "determines whether a class name, and field or method should be ignored.",
	"Method": "boolean ignore(String aClassName,FieldOrMethod aFieldOrMethod){\r\n    final String fieldOrMethodName = aFieldOrMethod.getName();\r\n    return (!equalScope(aFieldOrMethod) || mIgnoreClassNameRegexp.matcher(aClassName).matches() || mIgnoreNameRegexp.matcher(fieldOrMethodName).matches());\r\n}"
}, {
	"Path": "org.restlet.test.ext.jaxrs.services.tests.Issue594Test.testGetRoot",
	"Comment": "this tests, if a sub resource class of a sub resource class of a rootresource class is accessable.",
	"Method": "void testGetRoot(){\r\n    final Response response = get();\r\n    sysOutEntityIfError(response);\r\n    assertEquals(Status.SUCCESS_OK, response.getStatus());\r\n    final Representation entity = response.getEntity();\r\n    assertEqualMediaType(MediaType.TEXT_PLAIN, entity.getMediaType());\r\n    assertEquals(\"root\", entity.getText());\r\n}"
}, {
	"Path": "org.restlet.engine.local.Entity.updateMetadata",
	"Comment": "updates some variant metadata based on a given entry name withextensions.",
	"Method": "void updateMetadata(String entryName,Variant variant,boolean applyDefault,MetadataService metadataService){\r\n    if (variant != null) {\r\n        String[] tokens = entryName.split(\"\\\\.\");\r\n        Metadata current;\r\n        for (int j = 1; j < tokens.length; j++) {\r\n            current = metadataService.getMetadata(tokens[j]);\r\n            if (current != null) {\r\n                if (current instanceof MediaType) {\r\n                    variant.setMediaType((MediaType) current);\r\n                } else if (current instanceof CharacterSet) {\r\n                    variant.setCharacterSet((CharacterSet) current);\r\n                } else if (current instanceof Encoding) {\r\n                    boolean found = false;\r\n                    for (int i = 0; !found && i < variant.getEncodings().size(); i++) {\r\n                        found = current.includes(variant.getEncodings().get(i));\r\n                    }\r\n                    if (!found) {\r\n                        variant.getEncodings().add((Encoding) current);\r\n                    }\r\n                } else if (current instanceof Language) {\r\n                    boolean found = false;\r\n                    for (int i = 0; !found && i < variant.getLanguages().size(); i++) {\r\n                        found = current.includes(variant.getLanguages().get(i));\r\n                    }\r\n                    if (!found) {\r\n                        variant.getLanguages().add((Language) current);\r\n                    }\r\n                }\r\n            }\r\n            final int dashIndex = tokens[j].indexOf('-');\r\n            if (dashIndex != -1) {\r\n                final String primaryPart = tokens[j].substring(0, dashIndex);\r\n                current = metadataService.getMetadata(primaryPart);\r\n                if (current instanceof Language) {\r\n                    variant.getLanguages().add((Language) current);\r\n                }\r\n            }\r\n        }\r\n        if (applyDefault) {\r\n            if (variant.getLanguages().isEmpty()) {\r\n                final Language defaultLanguage = metadataService.getDefaultLanguage();\r\n                if ((defaultLanguage != null) && !defaultLanguage.equals(Language.ALL)) {\r\n                    variant.getLanguages().add(defaultLanguage);\r\n                }\r\n            }\r\n            if (variant.getMediaType() == null) {\r\n                final MediaType defaultMediaType = metadataService.getDefaultMediaType();\r\n                if ((defaultMediaType != null) && !defaultMediaType.equals(MediaType.ALL)) {\r\n                    variant.setMediaType(defaultMediaType);\r\n                }\r\n            }\r\n            if (variant.getEncodings().isEmpty()) {\r\n                final Encoding defaultEncoding = metadataService.getDefaultEncoding();\r\n                if ((defaultEncoding != null) && !defaultEncoding.equals(Encoding.ALL) && !defaultEncoding.equals(Encoding.IDENTITY)) {\r\n                    variant.getEncodings().add(defaultEncoding);\r\n                }\r\n            }\r\n            if (variant.getCharacterSet() == null) {\r\n                final CharacterSet defaultCharacterSet = metadataService.getDefaultCharacterSet();\r\n                if ((defaultCharacterSet != null) && !defaultCharacterSet.equals(CharacterSet.ALL)) {\r\n                    variant.setCharacterSet(defaultCharacterSet);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.classfile.FieldDefinition.getReadReferenceCount",
	"Comment": "determines the number of read, or get, references to the field.",
	"Method": "int getReadReferenceCount(){\r\n    return mGetReferences.size();\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.ExceptionHandler.instantiateExecption",
	"Comment": "handles the given exception, catched by an invoke of a resource method ora creation if a sub resource object.",
	"Method": "RequestHandledException instantiateExecption(InstantiateException exception,CallContext callContext,String logMessage){\r\n    callContext.getResponse().setStatus(org.restlet.data.Status.SERVER_ERROR_INTERNAL);\r\n    this.logger.log(Level.WARNING, logMessage, exception.getCause());\r\n    throw new RequestHandledException();\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.FirewallConfig.addIpAddressesWhiteList",
	"Comment": "adds a rule that restricts access to the given set of ip addresses.",
	"Method": "void addIpAddressesWhiteList(List<String> whiteList){\r\n    add(new FirewallIpFilteringRule(whiteList, true));\r\n}"
}, {
	"Path": "org.restlet.engine.resource.MethodAnnotationInfo.getVariants",
	"Comment": "returns the list of representation variants associated to a givenannotation value, corresponding to either an input or output entity.",
	"Method": "List<Variant> getVariants(MetadataService metadataService,String annotationValue){\r\n    List<Variant> result = null;\r\n    if (annotationValue != null) {\r\n        StringTokenizer stValue = new StringTokenizer(annotationValue, \"\\\\|\");\r\n        while (stValue.hasMoreTokens()) {\r\n            String variantValue = stValue.nextToken().trim();\r\n            Variant variant = null;\r\n            List<MediaType> mediaTypes = null;\r\n            List<Language> languages = null;\r\n            CharacterSet characterSet = null;\r\n            StringTokenizer stExtension = new StringTokenizer(variantValue, \"\\\\+\");\r\n            while (stExtension.hasMoreTokens()) {\r\n                String extension = stExtension.nextToken().trim();\r\n                if (extension == null) {\r\n                    continue;\r\n                }\r\n                List<Metadata> metadataList = metadataService.getAllMetadata(extension);\r\n                if (metadataList != null) {\r\n                    for (Metadata metadata : metadataList) {\r\n                        if (metadata instanceof MediaType) {\r\n                            if (mediaTypes == null) {\r\n                                mediaTypes = new ArrayList<MediaType>();\r\n                            }\r\n                            mediaTypes.add((MediaType) metadata);\r\n                        } else if (metadata instanceof Language) {\r\n                            if (languages == null) {\r\n                                languages = new ArrayList<Language>();\r\n                            }\r\n                            languages.add((Language) metadata);\r\n                        } else if (metadata instanceof CharacterSet) {\r\n                            if (characterSet == null) {\r\n                                characterSet = (CharacterSet) metadata;\r\n                            } else {\r\n                                Context.getCurrentLogger().warning(\"A representation variant can have only one character set. Please check your annotation value.\");\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (mediaTypes != null) {\r\n                for (MediaType mediaType : mediaTypes) {\r\n                    if ((result == null) || (!result.contains(mediaType))) {\r\n                        if (result == null) {\r\n                            result = new ArrayList<Variant>();\r\n                        }\r\n                        variant = new Variant(mediaType);\r\n                        if (languages != null) {\r\n                            variant.getLanguages().addAll(languages);\r\n                        }\r\n                        if (characterSet != null) {\r\n                            variant.setCharacterSet(characterSet);\r\n                        }\r\n                        result.add(variant);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.util.Series.getValuesMap",
	"Comment": "returns a map of name, value pairs. the order of the map keys isrespected based on the series order. when a name has multiple values,only the first one is put in the map.",
	"Method": "Map<String, String> getValuesMap(){\r\n    Map<String, String> result = new LinkedHashMap<String, String>();\r\n    for (NamedValue<String> param : this) {\r\n        if (!result.containsKey(param.getName())) {\r\n            result.put(param.getName(), param.getValue());\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.ASTManager.removeCheck",
	"Comment": "removes a check and its check nodes. clears all managed elements iflast check removed.",
	"Method": "void removeCheck(AbstractUsageCheck aCheck){\r\n    mCheckNodes.remove(aCheck);\r\n    if (mCheckNodes.isEmpty()) {\r\n        clear();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.application.DecodeRepresentation.getDecodedStream",
	"Comment": "returns a decoded stream for a given encoding and coded stream.",
	"Method": "InputStream getDecodedStream(Encoding encoding,InputStream encodedStream){\r\n    InputStream result = null;\r\n    if (encodedStream != null) {\r\n        if (encoding.equals(Encoding.GZIP)) {\r\n            result = new GZIPInputStream(encodedStream);\r\n        } else if (encoding.equals(Encoding.DEFLATE)) {\r\n            result = new InflaterInputStream(encodedStream);\r\n        } else if (encoding.equals(Encoding.DEFLATE_NOWRAP)) {\r\n            result = new InflaterInputStream(encodedStream, new Inflater(true));\r\n        } else if (encoding.equals(Encoding.ZIP)) {\r\n            @SuppressWarnings(\"resource\")\r\n            final ZipInputStream stream = new ZipInputStream(encodedStream);\r\n            if (stream.getNextEntry() != null) {\r\n                result = stream;\r\n            }\r\n        } else if (encoding.equals(Encoding.IDENTITY)) {\r\n            throw new IOException(\"Decoder unecessary for identity decoding\");\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.Request.toString",
	"Comment": "displays a synthesis of the request like an http request line.",
	"Method": "String toString(){\r\n    return ((getMethod() == null) ? \"\" : getMethod().toString()) + \" \" + ((getResourceRef() == null) ? \"\" : getResourceRef().toString()) + \" \" + ((getProtocol() == null) ? \"\" : (getProtocol().getName() + ((getProtocol().getVersion() == null) ? \"\" : \"/\" + getProtocol().getVersion())));\r\n}"
}, {
	"Path": "org.restlet.ext.jackson.JacksonRepresentation.getObjectWriter",
	"Comment": "returns the modifiable jackson object writer. useful to customizeserialization.",
	"Method": "ObjectWriter getObjectWriter(){\r\n    if (this.objectWriter == null) {\r\n        this.objectWriter = createObjectWriter();\r\n    }\r\n    return this.objectWriter;\r\n}"
}, {
	"Path": "org.restlet.ext.jibx.JibxRepresentation.write",
	"Comment": "marshals the document and writes the representation to a stream ofcharacters.",
	"Method": "void write(Writer writer){\r\n    try {\r\n        IBindingFactory jibxBFact = JibxRepresentation.getBindingFactory(this.bindingName, this.bindingClass);\r\n        IMarshallingContext mctx = jibxBFact.createMarshallingContext();\r\n        mctx.setOutput(writer);\r\n        ((IMarshallable) getObject()).marshal(mctx);\r\n    } catch (JiBXException e) {\r\n        throw new IOException(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.application.StatusInfo.getUri",
	"Comment": "returns the uri of the specification describing the status.",
	"Method": "String getUri(){\r\n    return this.uri;\r\n}"
}, {
	"Path": "org.restlet.example.book.restlet.ch02.sec5.sub2.RootServerResource.get",
	"Comment": "handle the http get method by returning a simple textual representation.",
	"Method": "Representation get(){\r\n    System.out.println(\"The GET method of root resource was invoked.\");\r\n    return new StringRepresentation(\"This is the root resource\");\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.provider.SingletonProvider.isWriteable",
	"Comment": "checks, if the given class could be written by this messagebodywriter.",
	"Method": "boolean isWriteable(Class<?> type,Type genericType,Annotation[] annotations,javax.ws.rs.core.MediaType mediaType){\r\n    try {\r\n        return this.getJaxRsWriter().isWriteable(type, genericType, annotations, mediaType);\r\n    } catch (NullPointerException e) {\r\n        if (genericType == null || annotations == null) {\r\n            return false;\r\n        }\r\n        throw e;\r\n    } catch (IllegalArgumentException e) {\r\n        if (genericType == null || annotations == null) {\r\n            return false;\r\n        }\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Query.addParameters",
	"Comment": "creates a new query with the query parameter set in the uri generatedby the returned query.",
	"Method": "Query<T> addParameters(Series<Parameter> params){\r\n    Query<T> result = new Query<T>(this.getService(), this.getSubpath(), (Class<T>) this.entityClass);\r\n    StringBuilder builder = new StringBuilder();\r\n    if (params != null) {\r\n        for (int i = 0; i < params.size(); i++) {\r\n            Parameter param = params.get(i);\r\n            if (i == 0) {\r\n                builder.append(param.getName());\r\n                builder.append(\"=\");\r\n                builder.append(param.getValue());\r\n            }\r\n        }\r\n    }\r\n    if (getQuery() == null || \"\".equals(getQuery())) {\r\n        result.setQuery(builder.toString());\r\n    } else {\r\n        result.setQuery(getQuery() + \"&\" + builder.toString());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.io.IoUtils.getWriter",
	"Comment": "returns a writer to the given output stream, using the given characterset for encoding to bytes.",
	"Method": "Writer getWriter(OutputStream outputStream,CharacterSet characterSet){\r\n    Writer result = null;\r\n    if (characterSet != null) {\r\n        result = new OutputStreamWriter(outputStream, characterSet.toCharset());\r\n    } else {\r\n        result = new OutputStreamWriter(outputStream, CharacterSet.ISO_8859_1.toCharset());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.representation.Representation.setListener",
	"Comment": "sets a listener for nio read events. if the listener is null, it clearany existing listener.",
	"Method": "void setListener(org.restlet.util.ReadingListener readingListener){\r\n    try {\r\n        org.restlet.util.SelectionRegistration sr = getRegistration();\r\n        if ((readingListener == null)) {\r\n            sr.setNoInterest();\r\n        } else {\r\n            sr.setReadInterest();\r\n        }\r\n        sr.setSelectionListener(readingListener);\r\n    } catch (IOException ioe) {\r\n        Context.getCurrentLogger().log(Level.WARNING, \"Unable to register the reading listener\", ioe);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.resource.Resource.getOriginalRef",
	"Comment": "returns the original reference as requested by the client. note that thisproperty is not used during request routing.",
	"Method": "Reference getOriginalRef(){\r\n    return getRequest() == null ? null : getRequest().getOriginalRef();\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.connection.SslConnection.handleSslHandshake",
	"Comment": "handles the ssl handshake states based on the last result received.",
	"Method": "void handleSslHandshake(){\r\n    HandshakeStatus hs = getSslHandshakeStatus();\r\n    if (getLogger().isLoggable(Level.FINER)) {\r\n        getLogger().log(Level.FINER, \"Handling SSL handshake: \" + hs);\r\n    }\r\n    if (isHandshaking && hs == HandshakeStatus.NOT_HANDSHAKING) {\r\n        hs = HandshakeStatus.FINISHED;\r\n        if (getLogger().isLoggable(Level.FINER)) {\r\n            getLogger().log(Level.FINER, \"SSLEngine went directly from handshaking to NOT_HANDSHAKING, \" + \"treating as FINISHED.\");\r\n        }\r\n    }\r\n    if (hs != HandshakeStatus.NOT_HANDSHAKING) {\r\n        isHandshaking = true;\r\n        switch(hs) {\r\n            case FINISHED:\r\n                onFinished();\r\n                break;\r\n            case NEED_TASK:\r\n                onNeedTask();\r\n                break;\r\n            case NEED_UNWRAP:\r\n                onUnwrap();\r\n                break;\r\n            case NEED_WRAP:\r\n                onWrap();\r\n                break;\r\n            case NOT_HANDSHAKING:\r\n                break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.adapter.HttpServerHelper.handle",
	"Comment": "handles the connector call. the default behavior is to create an restcall and delegate it to the attached restlet.",
	"Method": "void handle(ServerCall httpCall){\r\n    try {\r\n        HttpRequest request = getAdapter().toRequest(httpCall);\r\n        HttpResponse response = new HttpResponse(httpCall, request);\r\n        handle(request, response);\r\n        getAdapter().commit(response);\r\n    } catch (Exception e) {\r\n        getLogger().log(Level.WARNING, \"Error while handling an HTTP server call\", e);\r\n    } finally {\r\n        Engine.clearThreadLocalVariables();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.setRetryOnError",
	"Comment": "indicates if idempotent requests should be retried on error.",
	"Method": "void setRetryOnError(boolean retryOnError){\r\n    this.retryOnError = retryOnError;\r\n}"
}, {
	"Path": "org.restlet.ext.httpclient.HttpClientHelper.getRetryHandler",
	"Comment": "returns the class name of the retry handler to use instead of http clientdefault behavior. the given class name must implement theorg.apache.commons.httpclient.httpmethodretryhandler interface and have adefault constructor.",
	"Method": "String getRetryHandler(){\r\n    return getHelpedParameters().getFirstValue(\"retryHandler\", null);\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.channel.ReadableBufferedChannel.read",
	"Comment": "reads some bytes and put them into the destination buffer. the bytes comefrom the underlying channel.",
	"Method": "int read(ByteBuffer targetBuffer){\r\n    return getBuffer().process(this, 0, targetBuffer);\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.RequestInfo.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    if (getDocumentations().isEmpty() && getParameters().isEmpty() && getRepresentations().isEmpty()) {\r\n        writer.emptyElement(APP_NAMESPACE, \"request\");\r\n    } else {\r\n        writer.startElement(APP_NAMESPACE, \"request\");\r\n        for (final DocumentationInfo documentationInfo : getDocumentations()) {\r\n            documentationInfo.writeElement(writer);\r\n        }\r\n        for (final ParameterInfo parameterInfo : getParameters()) {\r\n            parameterInfo.writeElement(writer);\r\n        }\r\n        for (final RepresentationInfo representationInfo : getRepresentations()) {\r\n            representationInfo.writeElement(writer);\r\n        }\r\n        writer.endElement(APP_NAMESPACE, \"request\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.ODataType.compareTo",
	"Comment": "compares this object with the specified object for order. the comparisonis based on the computed full class name",
	"Method": "int compareTo(ODataType o){\r\n    if (o == null) {\r\n        return 1;\r\n    }\r\n    int result = 0;\r\n    String s1 = getFullClassName();\r\n    String s2 = o.getFullClassName();\r\n    if (s1 != null) {\r\n        result = s1.compareTo(s2);\r\n    } else if (s2 != null) {\r\n        result = -1 * s2.compareTo(s1);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.buffer.Buffer.remaining",
	"Comment": "returns the number of bytes that can be read or written in the bytebuffer.",
	"Method": "int remaining(){\r\n    return getBytes().remaining();\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipClientResource.bye",
	"Comment": "indicates to the server that the user agent wishes to release the call.",
	"Method": "Representation bye(){\r\n    return handle(SipMethod.BYE);\r\n}"
}, {
	"Path": "org.restlet.Application.getDecoderService",
	"Comment": "returns the decoder service. the service is enabled by default.",
	"Method": "DecoderService getDecoderService(){\r\n    return getServices().get(DecoderService.class);\r\n}"
}, {
	"Path": "org.restlet.service.Service.createInboundFilter",
	"Comment": "create the filter that should be invoked for incoming calls.",
	"Method": "org.restlet.routing.Filter createInboundFilter(org.restlet.Context context){\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.Application.createInboundRoot",
	"Comment": "creates a inbound root restlet that will receive all incoming calls. ingeneral, instances of router, filter or finder classes will be used asinitial application restlet. the default implementation returns null bydefault. this method is intended to be overridden by subclasses.",
	"Method": "Restlet createInboundRoot(){\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.util.WrapperRequest.getAccessControlRequestMethod",
	"Comment": "returns the access control request method of the target resource.",
	"Method": "Method getAccessControlRequestMethod(){\r\n    return wrappedRequest.getAccessControlRequestMethod();\r\n}"
}, {
	"Path": "org.restlet.engine.header.CookieWriter.getCookies",
	"Comment": "gets the cookies whose name is a key in the given map. if a matchingcookie is found, its value is put in the map.",
	"Method": "void getCookies(List<Cookie> source,Map<String, Cookie> destination){\r\n    Cookie cookie;\r\n    for (final Iterator<Cookie> iter = source.iterator(); iter.hasNext(); ) {\r\n        cookie = iter.next();\r\n        if (destination.containsKey(cookie.getName())) {\r\n            destination.put(cookie.getName(), cookie);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createActivitySectorQuery",
	"Comment": "creates a query for activitysector entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.ActivitySector> createActivitySectorQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.ActivitySector.class);\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.core.VariantListBuilderImpl.build",
	"Comment": "build a list of representation variants from the current state of thebuilder. after this method is called the builder is reset to an emptystate.",
	"Method": "List<Variant> build(){\r\n    if (Util.isNotEmpty(this.encodings) || Util.isNotEmpty(this.languages) || Util.isNotEmpty(this.mediaTypes)) {\r\n        buildVariants();\r\n    }\r\n    List<Variant> variants = this.variants;\r\n    this.variants = null;\r\n    return variants;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.Util.toString",
	"Comment": "concatenate the members of the set to a string, separated with the givendelimiter.",
	"Method": "String toString(Collection<?> collection,String delimiter){\r\n    if ((collection == null) || collection.isEmpty()) {\r\n        return \"\";\r\n    }\r\n    final Iterator<?> iterator = collection.iterator();\r\n    if (collection.size() == 1) {\r\n        return String.valueOf(iterator.next());\r\n    }\r\n    final StringBuilder stb = new StringBuilder();\r\n    stb.append(iterator.next());\r\n    while (iterator.hasNext()) {\r\n        final Object object = iterator.next();\r\n        stb.append(delimiter);\r\n        stb.append(object);\r\n    }\r\n    return stb.toString();\r\n}"
}, {
	"Path": "org.restlet.service.StatusService.isOverwriting",
	"Comment": "indicates if an existing entity should be overwritten. false by default.",
	"Method": "boolean isOverwriting(){\r\n    return this.overwriting;\r\n}"
}, {
	"Path": "org.restlet.util.WrapperRequest.getProtocol",
	"Comment": "returns the protocol by first returning the baseref.schemeprotocolproperty if it is set, or the resourceref.schemeprotocol propertyotherwise.",
	"Method": "Protocol getProtocol(){\r\n    return getWrappedRequest().getProtocol();\r\n}"
}, {
	"Path": "org.restlet.engine.resource.MethodAnnotationInfo.getRequestVariants",
	"Comment": "returns a list of request variants based on the annotation value.",
	"Method": "List<Variant> getRequestVariants(MetadataService metadataService,org.restlet.service.ConverterService converterService){\r\n    List<Variant> result = null;\r\n    Class<?>[] classes = getJavaInputTypes();\r\n    if (classes != null && classes.length >= 1) {\r\n        result = getVariants(metadataService, getInput());\r\n        if (result == null) {\r\n            Class<?> inputClass = classes[0];\r\n            if (inputClass != null) {\r\n                result = (List<Variant>) converterService.getVariants(inputClass, null);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.exceptions.ConvertParameterException.object",
	"Comment": "throws a message, that the given string value could not be converted to aprimitive.",
	"Method": "ConvertParameterException object(Class<?> paramType,Object unparseableValue,Throwable cause){\r\n    throw new ConvertParameterException(\"Could not convert \" + unparseableValue + \" to a \" + paramType.getName(), cause);\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.toEdm",
	"Comment": "converts a value to the string representation of the target wcf type.",
	"Method": "String toEdm(Object value,Type type){\r\n    String adoNetType = type.getName();\r\n    if (value == null || adoNetType == null) {\r\n        return null;\r\n    }\r\n    String result = null;\r\n    if (adoNetType.endsWith(\"Binary\")) {\r\n        if ((byte[].class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmBinary((byte[]) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Boolean\")) {\r\n        if ((Boolean.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmBoolean((Boolean) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"DateTime\")) {\r\n        if ((Date.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmDateTime((Date) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"DateTimeOffset\")) {\r\n        if ((Date.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmDateTime((Date) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Time\")) {\r\n        if ((Long.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmTime((Long) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Decimal\")) {\r\n        if ((Double.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmDecimal((Double) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Single\")) {\r\n        if ((Float.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmSingle((Float) value);\r\n        } else if ((Double.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmSingle((Double) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Double\")) {\r\n        if ((Double.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmDouble((Double) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Guid\")) {\r\n        result = value.toString();\r\n    } else if (adoNetType.endsWith(\"Int16\")) {\r\n        if ((Short.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmInt16((Short) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Int32\")) {\r\n        if ((Integer.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmInt32((Integer) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Int64\")) {\r\n        if ((Long.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmInt64((Long) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Byte\")) {\r\n        if ((Byte.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmByte((Byte) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"String\")) {\r\n        result = value.toString();\r\n    }\r\n    if (result == null) {\r\n        result = value.toString();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.oauth.AccessTokenServerResource.getParameter",
	"Comment": "return the value of the given parameter, and throws an oauthexception in case the parameter is not set.",
	"Method": "String getParameter(Form parameters,String key){\r\n    String value = parameters.getFirstValue(key);\r\n    if (StringUtils.isNullOrEmpty(value)) {\r\n        throw new OAuthException(OAuthError.invalid_request, \"The following parameter is missing: \" + key, null);\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.restlet.engine.internal.Activator.stop",
	"Comment": "stops the osgi bundle by unregistering the engine with the bundle of therestlet api.",
	"Method": "void stop(BundleContext context){\r\n    org.restlet.engine.Engine.clear();\r\n}"
}, {
	"Path": "org.restlet.util.WrapperResponse.getLocationRef",
	"Comment": "returns the reference that the client should follow for redirections orresource creations.",
	"Method": "Reference getLocationRef(){\r\n    return getWrappedResponse().getLocationRef();\r\n}"
}, {
	"Path": "org.restlet.ext.openid.OpenIdVerifier.setDefaultProvider",
	"Comment": "sets the default provider. will also set usedefaultprovider to true.",
	"Method": "void setDefaultProvider(String provider){\r\n    this.defaultProvider = provider;\r\n    this.useDefault = true;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.ClientConnectionHelper.createSocketChannel",
	"Comment": "creates the socket channel that will be used to send the request and getthe response.",
	"Method": "SocketChannel createSocketChannel(boolean secure,InetSocketAddress socketAddress,SocketChannel createSocketChannel,boolean secure,String hostDomain,int hostPort){\r\n    return createSocketChannel(secure, new InetSocketAddress(hostDomain, hostPort));\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.Mapping.getValueNodePath",
	"Comment": "returns the name of the attribute that stores the value to set, ifpertinent, and null otherwise.",
	"Method": "String getValueNodePath(){\r\n    return (isAttributeValue()) ? valuePath.substring(0, valuePath.lastIndexOf(\"/\")) : valuePath;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.MethodSignature.isCompatibleWith",
	"Comment": "whether this method signature is compatible with the signature of theargument.that is to say, each type for this signature are subclasses,subinterfaces, or implement the interface for each corresponding typein the argument signature.",
	"Method": "boolean isCompatibleWith(ISignature signature){\r\n    boolean result = true;\r\n    IClass[] comparedArgTypes = signature.getParameters();\r\n    if (_argTypes.length != comparedArgTypes.length) {\r\n        result = false;\r\n    } else {\r\n        for (int i = 0; i < _argTypes.length; i++) {\r\n            if ((_argTypes[i] != null) && !_argTypes[i].isCompatibleWith(comparedArgTypes[i])) {\r\n                result = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.internal.turtle.RdfTurtleReader.generateLinks",
	"Comment": "loops over the given list of lexical units and generates the adequatcalls to link methods.",
	"Method": "void generateLinks(List<LexicalUnit> lexicalUnits){\r\n    Object currentSubject = null;\r\n    Reference currentPredicate = null;\r\n    Object currentObject = null;\r\n    int nbTokens = 0;\r\n    boolean swapSubjectObject = false;\r\n    for (int i = 0; i < lexicalUnits.size(); i++) {\r\n        LexicalUnit lexicalUnit = lexicalUnits.get(i);\r\n        nbTokens++;\r\n        switch(nbTokens) {\r\n            case 1:\r\n                if (\",\".equals(lexicalUnit.getValue())) {\r\n                    nbTokens++;\r\n                } else if (!\";\".equals(lexicalUnit.getValue())) {\r\n                    currentSubject = lexicalUnit.resolve();\r\n                }\r\n                break;\r\n            case 2:\r\n                if (\"is\".equalsIgnoreCase(lexicalUnit.getValue())) {\r\n                    nbTokens--;\r\n                    swapSubjectObject = true;\r\n                } else if (\"has\".equalsIgnoreCase(lexicalUnit.getValue())) {\r\n                    nbTokens--;\r\n                } else if (\"a\".equalsIgnoreCase(lexicalUnit.getValue())) {\r\n                    currentPredicate = RdfConstants.PREDICATE_TYPE;\r\n                } else if (\"!\".equalsIgnoreCase(lexicalUnit.getValue())) {\r\n                    currentObject = new BlankNodeToken(newBlankNodeId()).resolve();\r\n                    currentPredicate = getPredicate(lexicalUnits.get(++i));\r\n                    this.link(currentSubject, currentPredicate, currentObject);\r\n                    currentSubject = currentObject;\r\n                    nbTokens = 1;\r\n                } else if (\"^\".equalsIgnoreCase(lexicalUnit.getValue())) {\r\n                    currentObject = currentSubject;\r\n                    currentPredicate = getPredicate(lexicalUnits.get(++i));\r\n                    currentSubject = new BlankNodeToken(newBlankNodeId()).resolve();\r\n                    this.link(currentSubject, currentPredicate, currentObject);\r\n                    nbTokens = 1;\r\n                } else {\r\n                    currentPredicate = getPredicate(lexicalUnit);\r\n                }\r\n                break;\r\n            case 3:\r\n                if (\"of\".equalsIgnoreCase(lexicalUnit.getValue())) {\r\n                    nbTokens--;\r\n                } else {\r\n                    if (swapSubjectObject) {\r\n                        this.link(lexicalUnit.resolve(), currentPredicate, currentSubject);\r\n                    } else {\r\n                        currentObject = lexicalUnit.resolve();\r\n                        this.link(currentSubject, currentPredicate, currentObject);\r\n                    }\r\n                    nbTokens = 0;\r\n                    swapSubjectObject = false;\r\n                }\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.raml.RamlApplication.attachRamlDocumentationRestlet",
	"Comment": "defines the route on which the raml definition will be provided.",
	"Method": "void attachRamlDocumentationRestlet(Router router,String ramlPath,Restlet ramlRestlet){\r\n    router.attach(ramlPath, ramlRestlet);\r\n    documented = true;\r\n}"
}, {
	"Path": "org.restlet.engine.util.ImmutableDate.setYear",
	"Comment": "as an immutabledate is immutable, this method throws anunsupportedoperationexception exception.",
	"Method": "void setYear(int arg0){\r\n    throw new UnsupportedOperationException(\"ImmutableDate is immutable\");\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.JettyServerHelper.getConnectorStopTimeout",
	"Comment": "connector stop timeout in milliseconds. defaults to 30000.the maximum time allowed for the service to shutdown.",
	"Method": "int getConnectorStopTimeout(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"connector.stopTimeout\", \"30000\"));\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.ResourceClass.getAllowedMethods",
	"Comment": "returns the allowed methods on the remainingpart. this method is used fora options request, if no special java method in the root resource classwas found for the given remainingpart.",
	"Method": "Set<org.restlet.data.Method> getAllowedMethods(RemainingPath remainingPath){\r\n    Set<org.restlet.data.Method> allowedMethods = this.allowedMethods.get(remainingPath);\r\n    if (allowedMethods != null) {\r\n        return allowedMethods;\r\n    }\r\n    allowedMethods = new HashSet<org.restlet.data.Method>(6);\r\n    for (final ResourceMethod rm : getMethodsForPath(remainingPath)) {\r\n        allowedMethods.add(rm.getHttpMethod());\r\n    }\r\n    if (!allowedMethods.isEmpty()) {\r\n        if (allowedMethods.contains(org.restlet.data.Method.GET)) {\r\n            allowedMethods.add(org.restlet.data.Method.HEAD);\r\n        }\r\n    }\r\n    final Set<org.restlet.data.Method> unmodifiable = Collections.unmodifiableSet(allowedMethods);\r\n    this.allowedMethods.put(remainingPath, unmodifiable);\r\n    return unmodifiable;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.getPackageName",
	"Comment": "returns a correct package name from the given name. especially, itensures that the first character of each sub package is in lower case.",
	"Method": "String getPackageName(Schema schema,String getPackageName,String name){\r\n    StringBuilder builder = new StringBuilder();\r\n    String[] tab = name.split(\"\\\\.\");\r\n    for (int i = 0; i < tab.length; i++) {\r\n        String string = tab[i];\r\n        if (i > 0) {\r\n            builder.append(\".\");\r\n        }\r\n        builder.append(string.toLowerCase());\r\n    }\r\n    return builder.toString();\r\n}"
}, {
	"Path": "org.restlet.ext.sip.OptionTag.valueOf",
	"Comment": "returns the option tag associated to a name. if an existing constantexists then it is returned, otherwise a new instance is created.",
	"Method": "OptionTag valueOf(String name){\r\n    OptionTag result = null;\r\n    if ((name != null) && !name.equals(\"\")) {\r\n        result = getOptionTags().get(name);\r\n        if (result == null) {\r\n            result = new OptionTag(name);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.adapter.ClientCall.getResponseEntity",
	"Comment": "returns the response entity if available. note that no metadata isassociated by default, you have to manually set them from your headers.",
	"Method": "Representation getResponseEntity(Response response){\r\n    Representation result = null;\r\n    long size = UNKNOWN_SIZE;\r\n    Series<Header> responseHeaders = getResponseHeaders();\r\n    String transferEncoding = responseHeaders.getFirstValue(HeaderConstants.HEADER_TRANSFER_ENCODING, true);\r\n    if ((transferEncoding != null) && !IDENTITY.getName().equalsIgnoreCase(transferEncoding)) {\r\n        size = UNKNOWN_SIZE;\r\n    } else {\r\n        size = getContentLength();\r\n    }\r\n    if (!getMethod().equals(Method.HEAD.getName()) && !response.getStatus().isInformational() && !response.getStatus().equals(REDIRECTION_NOT_MODIFIED) && !response.getStatus().equals(SUCCESS_NO_CONTENT) && !response.getStatus().equals(SUCCESS_RESET_CONTENT)) {\r\n        InputStream stream = getUnClosedResponseEntityStream(getResponseEntityStream(size));\r\n        java.nio.channels.ReadableByteChannel channel = getResponseEntityChannel(size);\r\n        if (stream != null) {\r\n            result = getRepresentation(stream);\r\n        } else if (channel != null) {\r\n            result = getRepresentation(channel);\r\n        }\r\n    }\r\n    if (result != null) {\r\n        result.setSize(size);\r\n        if (size == UNKNOWN_SIZE) {\r\n            getLogger().fine(\"The length of the message body is unknown. The entity must be handled carefully and consumed entirely in order to surely release the connection.\");\r\n        }\r\n    }\r\n    result = HeaderUtils.extractEntityHeaders(responseHeaders, result);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Entry.setId",
	"Comment": "sets the permanent, universally unique identifier for the entry.",
	"Method": "void setId(String id){\r\n    this.id = id;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.WadlApplication.attachToComponent",
	"Comment": "attaches the application to the given component if the application has awadl base reference. the application will be attached to an existingvirtual host if possible, otherwise a new one will be created.",
	"Method": "VirtualHost attachToComponent(Component component){\r\n    VirtualHost result = null;\r\n    if (getBaseRef() != null) {\r\n        result = getVirtualHost(component);\r\n        attachToHost(result);\r\n        addConnectors(component);\r\n    } else {\r\n        getLogger().warning(\"The WADL application has no base reference defined. Unable to guess the virtual host.\");\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.SecurityUtil.isSslClientCertAuth",
	"Comment": "checks, if the given request was authenticated by a ssl clientcertificate.",
	"Method": "boolean isSslClientCertAuth(Request request){\r\n    return getSslClientCerts(request) != null;\r\n}"
}, {
	"Path": "org.restlet.engine.application.Decoder.decode",
	"Comment": "decodes a given representation if its encodings are supported by nre.",
	"Method": "Representation decode(Representation representation){\r\n    Representation result = representation;\r\n    boolean supported = true;\r\n    boolean identityEncodings = true;\r\n    for (final Iterator<Encoding> iter = representation.getEncodings().iterator(); supported && iter.hasNext(); ) {\r\n        final Encoding encoding = iter.next();\r\n        supported = DecodeRepresentation.getSupportedEncodings().contains(encoding);\r\n        identityEncodings &= encoding.equals(Encoding.IDENTITY);\r\n    }\r\n    if (supported && !identityEncodings) {\r\n        result = new DecodeRepresentation(representation);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Collection.postMember",
	"Comment": "posts a member to the collection resulting in the creation of a newresource.",
	"Method": "Reference postMember(Representation member){\r\n    final Request request = new Request(Method.POST, getHref(), member);\r\n    final Response response = getWorkspace().getService().getClientDispatcher().handle(request);\r\n    if (response.getStatus().equals(Status.SUCCESS_CREATED)) {\r\n        return response.getLocationRef();\r\n    }\r\n    throw new Exception(\"Couldn't post the member representation. Status returned: \" + response.getStatus());\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.WadlApplication.wadlRepresent",
	"Comment": "represents the resource as a wadl description for the given variant.",
	"Method": "Representation wadlRepresent(Request request,Response response,Representation wadlRepresent,Variant variant,Request request,Response response){\r\n    Representation result = null;\r\n    if (variant != null) {\r\n        ApplicationInfo applicationInfo = getApplicationInfo(request, response);\r\n        DocumentationInfo doc = null;\r\n        if ((getName() != null) && !\"\".equals(getName())) {\r\n            if (applicationInfo.getDocumentations().isEmpty()) {\r\n                doc = new DocumentationInfo();\r\n                applicationInfo.getDocumentations().add(doc);\r\n            } else {\r\n                doc = applicationInfo.getDocumentations().get(0);\r\n            }\r\n            doc.setTitle(getName());\r\n        }\r\n        if ((doc != null) && (getDescription() != null) && !\"\".equals(getDescription())) {\r\n            doc.setTextContent(getDescription());\r\n        }\r\n        if (MediaType.APPLICATION_WADL.equals(variant.getMediaType())) {\r\n            result = createWadlRepresentation(applicationInfo);\r\n        } else if (MediaType.TEXT_HTML.equals(variant.getMediaType())) {\r\n            result = createHtmlRepresentation(applicationInfo);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.swagger.v1_2.SwaggerWriter.fillResourceListingMainAttributes",
	"Comment": "fills swagger resource listing main attributes from restlet web apidefinition",
	"Method": "void fillResourceListingMainAttributes(Definition definition,ResourceListing listing){\r\n    listing.setApiVersion(definition.getVersion());\r\n    listing.setInfo(new ApiInfo());\r\n    listing.setSwaggerVersion(SWAGGER_VERSION);\r\n    if (definition.getContact() != null) {\r\n        listing.getInfo().setContact(definition.getContact().getEmail());\r\n    }\r\n    if (definition.getLicense() != null) {\r\n        listing.getInfo().setLicense(definition.getLicense().getName());\r\n        listing.getInfo().setLicenseUrl(definition.getLicense().getUrl());\r\n    }\r\n    if (definition.getContract() != null) {\r\n        listing.getInfo().setTitle(definition.getContract().getName());\r\n        listing.getInfo().setDescription(definition.getContract().getDescription());\r\n    }\r\n    if (!definition.getEndpoints().isEmpty()) {\r\n        String authenticationProtocol = definition.getEndpoints().get(0).getAuthenticationProtocol();\r\n        if (authenticationProtocol != null) {\r\n            AuthorizationsDeclaration authorizations = new AuthorizationsDeclaration();\r\n            if (ChallengeScheme.HTTP_BASIC.getName().equals(authenticationProtocol)) {\r\n                authorizations.setBasicAuth(new BasicAuthorizationDeclaration());\r\n                listing.setAuthorizations(authorizations);\r\n            } else if (ChallengeScheme.HTTP_OAUTH.getName().equals(authenticationProtocol) || ChallengeScheme.HTTP_OAUTH_BEARER.getName().equals(authenticationProtocol) || ChallengeScheme.HTTP_OAUTH_MAC.getName().equals(authenticationProtocol)) {\r\n                authorizations.setOauth2(new OAuth2AuthorizationDeclaration());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.raml.RamlTranslator.getResource",
	"Comment": "returns the list of resources nested under a given resource.",
	"Method": "List<Resource> getResource(String resourceName,org.raml.model.Resource resource,List<PathVariable> rootPathVariables){\r\n    List<Resource> rwadResources = new ArrayList();\r\n    Resource rwadResource = new Resource();\r\n    rwadResource.setDescription(resource.getDescription());\r\n    rwadResource.setName(resourceName);\r\n    rwadResource.setResourcePath(resource.getUri());\r\n    rwadResource.setPathVariables(getPathVariables(resource));\r\n    rwadResource.getPathVariables().addAll(rootPathVariables);\r\n    for (Entry<ActionType, Action> entry : resource.getActions().entrySet()) {\r\n        Action action = entry.getValue();\r\n        Operation operation = new Operation();\r\n        operation.setDescription(action.getDescription());\r\n        operation.setMethod(entry.getKey().name().toString());\r\n    }\r\n    rwadResources.add(rwadResource);\r\n    for (Entry<String, org.raml.model.Resource> entry : resource.getResources().entrySet()) {\r\n        rwadResources.addAll(getResource(ConversionUtils.processResourceName(entry.getValue().getUri()), entry.getValue(), rootPathVariables));\r\n    }\r\n    return rwadResources;\r\n}"
}, {
	"Path": "org.restlet.Context.getParameters",
	"Comment": "returns the modifiable series of parameters. a parameter is a paircomposed of a name and a value and is typically used for configurationpurpose, like java properties. note that multiple parameters with thesame name can be declared and accessed.",
	"Method": "Series<Parameter> getParameters(){\r\n    return this.parameters;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.raml.RamlUtils.getParamType",
	"Comment": "returns the raml parameter type given a java primitive type.",
	"Method": "ParamType getParamType(String type){\r\n    String t = (type != null) ? type.toLowerCase() : null;\r\n    if (integerTypesList.contains(t)) {\r\n        return ParamType.INTEGER;\r\n    } else if (numericTypesList.contains(t)) {\r\n        return ParamType.NUMBER;\r\n    } else if (\"boolean\".equals(t)) {\r\n        return ParamType.BOOLEAN;\r\n    } else if (\"date\".equals(t)) {\r\n        return ParamType.DATE;\r\n    }\r\n    return ParamType.STRING;\r\n}"
}, {
	"Path": "org.restlet.service.TunnelService.setLanguageParameter",
	"Comment": "sets the name of the parameter containing the accepted language.",
	"Method": "void setLanguageParameter(String parameterName){\r\n    this.languageParameter = parameterName;\r\n}"
}, {
	"Path": "org.restlet.security.Realm.setParameters",
	"Comment": "sets the modifiable series of parameters. this method clears the currentseries and adds all entries in the parameter series.",
	"Method": "void setParameters(Series<Parameter> parameters){\r\n    synchronized (getParameters()) {\r\n        if (parameters != getParameters()) {\r\n            getParameters().clear();\r\n            if (parameters != null) {\r\n                getParameters().addAll(parameters);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlWriter.writeAttributes",
	"Comment": "write out an attribute list, escaping values. the names will haveprefixes added to them.",
	"Method": "void writeAttributes(Attributes atts){\r\n    final int len = atts.getLength();\r\n    for (int i = 0; i < len; i++) {\r\n        if (\"xmlns\".equals(atts.getQName(i))) {\r\n            forceNSDecl(atts.getValue(i));\r\n        } else if (atts.getQName(i) != null && atts.getQName(i).startsWith(\"xmlns\")) {\r\n            forceNSDecl(atts.getValue(i), atts.getLocalName(i));\r\n        } else {\r\n            final char[] ch = atts.getValue(i).toCharArray();\r\n            write(' ');\r\n            writeName(atts.getURI(i), atts.getLocalName(i), atts.getQName(i), false);\r\n            write(\"=\\\"\");\r\n            writeEsc(ch, 0, ch.length, true);\r\n            write('\"');\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.internal.AwsVerifier.setMaxRequestAge",
	"Comment": "sets the maximum age of a request, in milliseconds, before it isconsidered stale.a negative or zero value indicates no age restriction. the default valueis 15 minutes.",
	"Method": "void setMaxRequestAge(long value){\r\n    if (value < 0)\r\n        value = 0;\r\n    this.maxRequestAge = value;\r\n}"
}, {
	"Path": "org.restlet.service.MetadataService.getAllCharacterSets",
	"Comment": "returns all the character sets associated to this extension. it returnsnull if the extension was not declared.",
	"Method": "List<CharacterSet> getAllCharacterSets(String extension){\r\n    List<CharacterSet> result = null;\r\n    if (extension != null) {\r\n        for (MetadataExtension metadataExtension : this.mappings) {\r\n            if (extension.equals(metadataExtension.getName()) && (metadataExtension.getMetadata() instanceof CharacterSet)) {\r\n                if (result == null) {\r\n                    result = new ArrayList<CharacterSet>();\r\n                }\r\n                result.add(metadataExtension.getCharacterSet());\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.service.TaskService.shutdownNow",
	"Comment": "attempts to stop all actively executing tasks, halts the processing ofwaiting tasks, and returns a list of the tasks that were awaitingexecution.",
	"Method": "List<Runnable> shutdownNow(){\r\n    return isShutdownAllowed() && (getWrapped() != null) ? getWrapped().shutdownNow() : Collections.<Runnable>emptyList();\r\n}"
}, {
	"Path": "org.restlet.ext.osgi.BaseApplicationProvider.doCreateApplication",
	"Comment": "called to construct the actual application instance. extenders willgenerally override this method.",
	"Method": "Application doCreateApplication(Context context){\r\n    Application app = new Application();\r\n    app.setContext(context);\r\n    return app;\r\n}"
}, {
	"Path": "org.restlet.engine.application.RangeRepresentation.setRange",
	"Comment": "sets the range specific to this wrapper. this will not affect the wrappedrepresentation.",
	"Method": "void setRange(Range range){\r\n    this.range = range;\r\n}"
}, {
	"Path": "org.restlet.service.TunnelService.getLanguageParameter",
	"Comment": "returns the name of the parameter containing the accepted language.",
	"Method": "String getLanguageParameter(){\r\n    return this.languageParameter;\r\n}"
}, {
	"Path": "org.restlet.engine.header.HeaderUtils.isComma",
	"Comment": "indicates if the given character is a comma, the character used as headervalue separator.",
	"Method": "boolean isComma(int character){\r\n    return (character == ',');\r\n}"
}, {
	"Path": "org.restlet.engine.application.StrictConneg.scoreAnnotation",
	"Comment": "scores the annotation descriptor. by default, it assess the quality ofthe query parameters with the uri query constraint defined in theannotation value if any.",
	"Method": "float scoreAnnotation(MethodAnnotationInfo annotation){\r\n    if (annotation == null) {\r\n        return 0.0F;\r\n    }\r\n    float score = doScoreAnnotation(annotation);\r\n    if (Context.getCurrentLogger().isLoggable(Level.FINE)) {\r\n        Context.getCurrentLogger().fine(\"Score of annotation \\\"\" + annotation + \"\\\"= \" + score);\r\n    }\r\n    return score;\r\n}"
}, {
	"Path": "org.restlet.ext.jackson.JacksonRepresentation.isExpandingEntityRefs",
	"Comment": "indicates if the parser will expand entity reference nodes. by defaultthe value of this is set to true.",
	"Method": "boolean isExpandingEntityRefs(){\r\n    return expandingEntityRefs;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.params.ParameterList.getAnno",
	"Comment": "returns the given annotation, if it is available in the given array ofannotations.",
	"Method": "A getAnno(Annotation[] annotations,Class<A> annoType){\r\n    for (final Annotation annot : annotations) {\r\n        final Class<? extends Annotation> annotationType = annot.annotationType();\r\n        if (annotationType.equals(annoType)) {\r\n            return (A) annot;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.ext.servlet.ServerServlet.getServer",
	"Comment": "returns the associated http server handling calls. it creates a new oneif none exists.",
	"Method": "HttpServerHelper getServer(HttpServletRequest request){\r\n    HttpServerHelper result = this.helper;\r\n    if (result == null) {\r\n        synchronized (this) {\r\n            result = this.helper;\r\n            if (result == null) {\r\n                final String serverAttributeName = getInitParameter(NAME_SERVER_ATTRIBUTE, NAME_SERVER_ATTRIBUTE_DEFAULT + \".\" + getServletName());\r\n                result = (HttpServerHelper) getServletContext().getAttribute(serverAttributeName);\r\n                if (result == null) {\r\n                    result = createServer(request);\r\n                    getServletContext().setAttribute(serverAttributeName, result);\r\n                }\r\n                this.helper = result;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.Application.getEncoderService",
	"Comment": "returns the encoder service. the service is disabled by default.",
	"Method": "EncoderService getEncoderService(){\r\n    return getServices().get(EncoderService.class);\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.RdfRepresentation.parse",
	"Comment": "parses the inner rdf representation. the given graph handler is invokedeach time a link is detected.",
	"Method": "void parse(GraphHandler graphHandler){\r\n    if (rdfRepresentation != null) {\r\n        if (MediaType.TEXT_RDF_N3.equals(rdfRepresentation.getMediaType())) {\r\n            new RdfN3Reader(rdfRepresentation, graphHandler).parse();\r\n        } else if (MediaType.TEXT_XML.equals(rdfRepresentation.getMediaType())) {\r\n            new RdfXmlReader(rdfRepresentation, graphHandler).parse();\r\n        } else if (MediaType.APPLICATION_ALL_XML.includes(rdfRepresentation.getMediaType())) {\r\n            new RdfXmlReader(rdfRepresentation, graphHandler).parse();\r\n        } else if (MediaType.TEXT_PLAIN.equals(rdfRepresentation.getMediaType())) {\r\n            new RdfNTriplesReader(rdfRepresentation, graphHandler).parse();\r\n        } else if (MediaType.TEXT_RDF_NTRIPLES.equals(rdfRepresentation.getMediaType())) {\r\n            new RdfNTriplesReader(rdfRepresentation, graphHandler).parse();\r\n        } else if (MediaType.TEXT_TURTLE.equals(rdfRepresentation.getMediaType())) {\r\n            new RdfTurtleReader(rdfRepresentation, graphHandler).parse();\r\n        } else if (MediaType.valueOf(\"text/rdf+n3\").equals(rdfRepresentation.getMediaType())) {\r\n            new RdfN3Reader(rdfRepresentation, graphHandler).parse();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipResponse.setOrganization",
	"Comment": "sets the name of the organization to which the sip element issuing themessage belongs.",
	"Method": "void setOrganization(String organization){\r\n    this.organization = organization;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Feed.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    writer.startElement(ATOM_NAMESPACE, \"feed\");\r\n    if (getAuthors() != null) {\r\n        for (final Person person : getAuthors()) {\r\n            person.writeElement(writer, \"author\");\r\n        }\r\n    }\r\n    if (getCategories() != null) {\r\n        for (final Category category : getCategories()) {\r\n            category.writeElement(writer);\r\n        }\r\n    }\r\n    if (getContributors() != null) {\r\n        for (final Person person : getContributors()) {\r\n            person.writeElement(writer, \"contributor\");\r\n        }\r\n    }\r\n    if (getGenerator() != null) {\r\n        getGenerator().writeElement(writer);\r\n    }\r\n    if (getIcon() != null) {\r\n        writer.dataElement(ATOM_NAMESPACE, \"icon\", getIcon().toString());\r\n    }\r\n    if (getId() != null) {\r\n        writer.dataElement(ATOM_NAMESPACE, \"id\", null, new AttributesImpl(), getId());\r\n    }\r\n    if (getLinks() != null) {\r\n        for (final Link link : getLinks()) {\r\n            link.writeElement(writer);\r\n        }\r\n    }\r\n    if ((getLogo() != null) && (getLogo().toString() != null)) {\r\n        writer.dataElement(ATOM_NAMESPACE, \"logo\", getLogo().toString());\r\n    }\r\n    if (getRights() != null) {\r\n        getRights().writeElement(writer, \"rights\");\r\n    }\r\n    if (getSubtitle() != null) {\r\n        getSubtitle().writeElement(writer, \"subtitle\");\r\n    }\r\n    if (getTitle() != null) {\r\n        getTitle().writeElement(writer, \"title\");\r\n    }\r\n    if (getUpdated() != null) {\r\n        Text.writeElement(writer, getUpdated(), ATOM_NAMESPACE, \"updated\");\r\n    }\r\n    if (getEntries() != null) {\r\n        for (final Entry entry : getEntries()) {\r\n            entry.writeElement(writer);\r\n        }\r\n    }\r\n    writer.endElement(ATOM_NAMESPACE, \"feed\");\r\n}"
}, {
	"Path": "org.restlet.resource.ServerResource.setAutoCommitting",
	"Comment": "indicates if the response should be automatically committed.",
	"Method": "void setAutoCommitting(boolean autoCommitting){\r\n    getResponse().setAutoCommitting(autoCommitting);\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.EntityType.getBlobValueRefProperty",
	"Comment": "returns the name of the entity property that stores the blob reference.",
	"Method": "Property getBlobValueRefProperty(){\r\n    return blobValueRefProperty;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlWriter.startDocument",
	"Comment": "write the xml declaration at the beginning of the document. pass theevent on down the filter chain for further processing.",
	"Method": "void startDocument(){\r\n    reset();\r\n    write(\"<?xml version=\\\"1.0\\\" standalone='yes'?>\\n\");\r\n    super.startDocument();\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.getChild",
	"Comment": "wraps the child client resource to proxy calls to the given javainterface into restlet method calls. the child resource is defined in thesense of hierarchical uris. if the resource uri is not hierarchical, thenan exception is thrown.",
	"Method": "ClientResource getChild(Reference relativeRef,T getChild,Reference relativeRef,Class<? extends T> resourceInterface,ClientResource getChild,String relativeUri,T getChild,String relativeUri,Class<? extends T> resourceInterface){\r\n    return getChild(new Reference(relativeUri), resourceInterface);\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.Graph.getSourceAsReference",
	"Comment": "returns the source reference, either the one given in the sourcerefparameter or if it is null, the source reference of the default link.",
	"Method": "Reference getSourceAsReference(Reference sourceRef){\r\n    Reference result = sourceRef;\r\n    if ((result == null) && (getDefaultLink() != null)) {\r\n        result = getDefaultLink().getSourceAsReference();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.test.ext.jaxrs.services.path.IllegalPathService2.getPlainText",
	"Comment": "this method is only available, that the class has something that it cando.",
	"Method": "String getPlainText(){\r\n    return \"\";\r\n}"
}, {
	"Path": "org.restlet.resource.ServerResource.setNegotiated",
	"Comment": "indicates if content negotiation of response entities is enabled. thedefault value is true.",
	"Method": "void setNegotiated(boolean negotiateContent){\r\n    this.negotiated = negotiateContent;\r\n}"
}, {
	"Path": "org.restlet.representation.Representation.getRegistration",
	"Comment": "returns the nio registration of the related channel with its selector.you can modify this registration to be called back when some readablecontent is available. note that the listener will keep being called backuntil you suspend or cancel the registration returned by this method.",
	"Method": "org.restlet.util.SelectionRegistration getRegistration(){\r\n    if (isSelectable()) {\r\n        return ((org.restlet.engine.io.SelectionChannel) getChannel()).getRegistration();\r\n    }\r\n    throw new IllegalStateException(\"The representation isn't selectable\");\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getTargetRef",
	"Comment": "returns the target reference. this method resolves relative referencesagainst the base reference then normalize them.",
	"Method": "Reference getTargetRef(){\r\n    Reference result = null;\r\n    if (isRelative() && (this.baseRef != null)) {\r\n        Reference baseReference = null;\r\n        if (this.baseRef.isAbsolute()) {\r\n            baseReference = this.baseRef;\r\n        } else {\r\n            baseReference = this.baseRef.getTargetRef();\r\n        }\r\n        if (baseReference.isRelative()) {\r\n            throw new IllegalArgumentException(\"The base reference must have an absolute hierarchical path component\");\r\n        }\r\n        String authority = getAuthority();\r\n        String path = getPath();\r\n        String query = getQuery();\r\n        String fragment = getFragment();\r\n        result = new Reference();\r\n        result.setScheme(baseReference.getScheme());\r\n        if (authority != null) {\r\n            result.setAuthority(authority);\r\n            result.setPath(path);\r\n            result.setQuery(query);\r\n        } else {\r\n            result.setAuthority(baseReference.getAuthority());\r\n            if ((path == null) || (path.equals(\"\"))) {\r\n                result.setPath(baseReference.getPath());\r\n                if (query != null) {\r\n                    result.setQuery(query);\r\n                } else {\r\n                    result.setQuery(baseReference.getQuery());\r\n                }\r\n            } else {\r\n                if (path.startsWith(\"/\")) {\r\n                    result.setPath(path);\r\n                } else {\r\n                    final String basePath = baseReference.getPath();\r\n                    String mergedPath = null;\r\n                    if ((baseReference.getAuthority() != null) && ((basePath == null) || (basePath.equals(\"\")))) {\r\n                        mergedPath = \"/\" + path;\r\n                    } else {\r\n                        final int lastSlash = basePath.lastIndexOf('/');\r\n                        if (lastSlash == -1) {\r\n                            mergedPath = path;\r\n                        } else {\r\n                            mergedPath = basePath.substring(0, lastSlash + 1) + path;\r\n                        }\r\n                    }\r\n                    result.setPath(mergedPath);\r\n                }\r\n                result.setQuery(query);\r\n            }\r\n        }\r\n        result.setFragment(fragment);\r\n    } else if (isRelative()) {\r\n        throw new IllegalArgumentException(\"Relative references are only usable when a base reference is set.\");\r\n    } else {\r\n        result = new Reference(this.internalRef);\r\n    }\r\n    result.normalize();\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.example.ext.jaxrs.employees.EmployeeMgr.createNewStaffNo",
	"Comment": "creates and return a staff number to be used for a new employee tocreate.",
	"Method": "int createNewStaffNo(){\r\n    int newStaffNo = 3456;\r\n    for (; ; ) {\r\n        if (!exists(newStaffNo)) {\r\n            return newStaffNo;\r\n        }\r\n        newStaffNo++;\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.Type.getClassName",
	"Comment": "returns the name of the corresponding java class or scalar type.",
	"Method": "String getClassName(){\r\n    return TypeUtils.toJavaTypeName(getName());\r\n}"
}, {
	"Path": "org.restlet.engine.application.StrictConneg.scoreVariant",
	"Comment": "scores a variant relatively to enriched client preferences. the languagehas a weight of 4, the media type 3, the character set 2 and the encoding1.",
	"Method": "float scoreVariant(Variant variant){\r\n    float result = -1.0F;\r\n    float languageScore = scoreLanguages(variant.getLanguages());\r\n    if (languageScore != -1.0F) {\r\n        float mediaTypeScore = scoreMediaType(variant.getMediaType());\r\n        if (mediaTypeScore != -1.0F) {\r\n            float characterSetScore = scoreCharacterSet(variant.getCharacterSet());\r\n            if (characterSetScore != -1.0F) {\r\n                float encodingScore = scoreEncodings(variant.getEncodings());\r\n                if (encodingScore != -1.0F) {\r\n                    if (variant instanceof VariantInfo) {\r\n                        float annotationScore = scoreAnnotation(((VariantInfo) variant).getAnnotationInfo());\r\n                        result = ((languageScore * 4.0F) + (mediaTypeScore * 3.0F) + (characterSetScore * 2.0F) + (encodingScore * 1.0F) + (annotationScore * 2.0F)) / 12.0F;\r\n                        result = result * ((VariantInfo) variant).getInputScore();\r\n                    } else {\r\n                        result = ((languageScore * 4.0F) + (mediaTypeScore * 3.0F) + (characterSetScore * 2.0F) + (encodingScore * 1.0F)) / 10.0F;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (Context.getCurrentLogger().isLoggable(Level.FINE)) {\r\n        Context.getCurrentLogger().fine(\"Total score of variant \\\"\" + variant + \"\\\"= \" + result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.util.WrapperRequest.setAccessControlRequestHeaders",
	"Comment": "sets the access control request headers of the target resource.",
	"Method": "void setAccessControlRequestHeaders(Set<String> accessControlRequestHeaders){\r\n    super.setAccessControlRequestHeaders(accessControlRequestHeaders);\r\n}"
}, {
	"Path": "org.restlet.ext.osgi.BaseDirectoryProvider.createDirectory",
	"Comment": "creates the restlet directory instance using the rooturi, indexname,deeplyaccessible, modifiable, and negotiatingcontent service properties",
	"Method": "Directory createDirectory(Context context){\r\n    Directory directory = new Directory(context, rootUri);\r\n    directory.setIndexName(indexName);\r\n    directory.setDeeplyAccessible(deeplyAccessible);\r\n    directory.setModifiable(modifiable);\r\n    directory.setNegotiatingContent(negotiatingContent);\r\n    return directory;\r\n}"
}, {
	"Path": "org.restlet.data.ClientInfo.getPreferredMediaType",
	"Comment": "returns the preferred media type among a list of supported ones, based onthe client preferences.",
	"Method": "MediaType getPreferredMediaType(List<MediaType> supported){\r\n    return getPreferredMetadata(supported, getAcceptedMediaTypes());\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipResponse.setErrorInfo",
	"Comment": "sets the pointer to additional information about the error response.",
	"Method": "void setErrorInfo(Address errorInfo){\r\n    this.errorInfo = errorInfo;\r\n}"
}, {
	"Path": "org.restlet.data.ChallengeScheme.valueOf",
	"Comment": "returns the challenge scheme associated to a scheme name. if an existingconstant exists then it is returned, otherwise a new instance is created.",
	"Method": "ChallengeScheme valueOf(String name){\r\n    if (name == null) {\r\n        throw new IllegalArgumentException(\"ChallengeScheme.valueOf(name) name must not be null\");\r\n    }\r\n    ChallengeScheme result = SCHEMES.get(name.toLowerCase());\r\n    if (result == null) {\r\n        result = new ChallengeScheme(name, null, null);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.connector.FtpClientHelper.isAllowUserInteraction",
	"Comment": "indicates if this url is being examined in a context in which it makessense to allow user interactions such as popping up an authenticationdialog.",
	"Method": "boolean isAllowUserInteraction(){\r\n    return Boolean.parseBoolean(getHelpedParameters().getFirstValue(\"allowUserInteraction\", \"false\"));\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.connection.Connection.setPipelining",
	"Comment": "indicates if idempotent sequences of requests can be pipelined.",
	"Method": "void setPipelining(boolean pipelining){\r\n    this.pipelining = pipelining;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Service.setClientVersion",
	"Comment": "sets the version of the odata protocol extensions defined in everyrequest issued by this service.",
	"Method": "void setClientVersion(String clientVersion){\r\n    this.clientVersion = clientVersion;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.way.OutboundWay.shouldBeChunked",
	"Comment": "indicates if the entity should be chunked because its length is unknown.",
	"Method": "boolean shouldBeChunked(Representation entity){\r\n    return (entity != null) && (entity.getAvailableSize() == Representation.UNKNOWN_SIZE);\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Service.setLink",
	"Comment": "sets the association between the source and the target entity via thegiven property name. if target is set to null, the call represents adelete link operation.",
	"Method": "void setLink(Object source,String sourceProperty,Object target){\r\n    if (getMetadata() == null || source == null) {\r\n        return;\r\n    }\r\n    if (target != null) {\r\n        Metadata metadata = (Metadata) getMetadata();\r\n        ClientResource resource = createResource(metadata.getSubpath(source) + \"/$links/\" + sourceProperty);\r\n        try {\r\n            StringBuilder sb = new StringBuilder(\"<uri xmlns=\\\"\");\r\n            sb.append(WCF_DATASERVICES_NAMESPACE);\r\n            sb.append(\"\\\">\");\r\n            sb.append(getServiceRef().toString());\r\n            sb.append(metadata.getSubpath(target));\r\n            sb.append(\"<\/uri>\");\r\n            StringRepresentation r = new StringRepresentation(sb.toString(), MediaType.APPLICATION_XML);\r\n            resource.put(r);\r\n        } catch (ResourceException re) {\r\n            throw new ResourceException(re.getStatus(), \"Can't set entity to this entity set \" + resource.getReference());\r\n        } finally {\r\n            this.latestRequest = resource.getRequest();\r\n            this.latestResponse = resource.getResponse();\r\n        }\r\n    } else {\r\n        ReflectUtils.invokeSetter(source, sourceProperty, null);\r\n        updateEntity(source);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.Converter.toFormEncoded",
	"Comment": "converts the given query string to a form, but do not decode the data.",
	"Method": "Form toFormEncoded(String queryString){\r\n    final Form form = new Form();\r\n    FormUtils.parse(form, queryString, null, false, '&');\r\n    return form;\r\n}"
}, {
	"Path": "org.restlet.data.ChallengeResponse.getIdentifier",
	"Comment": "returns the user identifier, such as a login name or an access key.",
	"Method": "String getIdentifier(){\r\n    return this.identifier;\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.getMaxRedirects",
	"Comment": "returns the maximum number of redirections that can be automaticallyfollowed for a single call. default value is 10.",
	"Method": "int getMaxRedirects(){\r\n    return maxRedirects;\r\n}"
}, {
	"Path": "org.restlet.engine.Engine.loadClass",
	"Comment": "returns the class object for the given name using the engine classloader.",
	"Method": "Class<?> loadClass(String className){\r\n    return getInstance().getClassLoader().loadClass(className);\r\n}"
}, {
	"Path": "org.restlet.ext.atom.internal.EntryContentReader.initiateInlineMixedContent",
	"Comment": "initiates the parsing of a mixed content part of the current document.",
	"Method": "void initiateInlineMixedContent(){\r\n    this.contentDepth = 0;\r\n    StringWriter sw = new StringWriter();\r\n    currentContentWriter = new XmlWriter(sw);\r\n    for (String prefix : this.prefixMappings.keySet()) {\r\n        currentContentWriter.forceNSDecl(this.prefixMappings.get(prefix), prefix);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.data.Language.valueOf",
	"Comment": "returns the language associated to a name. if an existing constant existsthen it is returned, otherwise a new instance is created.",
	"Method": "Language valueOf(String name){\r\n    Language result = null;\r\n    if ((name != null) && !name.equals(\"\")) {\r\n        if (name.equalsIgnoreCase(ALL.getName())) {\r\n            result = ALL;\r\n        } else if (name.equalsIgnoreCase(ENGLISH.getName())) {\r\n            result = ENGLISH;\r\n        } else if (name.equalsIgnoreCase(ENGLISH_US.getName())) {\r\n            result = ENGLISH_US;\r\n        } else if (name.equalsIgnoreCase(FRENCH.getName())) {\r\n            result = FRENCH;\r\n        } else if (name.equalsIgnoreCase(FRENCH_FRANCE.getName())) {\r\n            result = FRENCH_FRANCE;\r\n        } else if (name.equalsIgnoreCase(SPANISH.getName())) {\r\n            result = SPANISH;\r\n        } else {\r\n            result = new Language(name);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.util.Series.equals",
	"Comment": "tests the equality of two string, potentially null, which a casesensitivity flag.",
	"Method": "boolean equals(String value1,String value2,boolean ignoreCase){\r\n    boolean result = (value1 == value2);\r\n    if (!result) {\r\n        if ((value1 != null) && (value2 != null)) {\r\n            if (ignoreCase) {\r\n                result = value1.equalsIgnoreCase(value2);\r\n            } else {\r\n                result = value1.equals(value2);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.WrappedRequestForHttpHeaders.getHeaders",
	"Comment": "gets the restlet headers. if the restlet headers are not available, butthe restlet response, the headers are copied from the response headers.if both is not available, null is returned.",
	"Method": "Series<Header> getHeaders(){\r\n    if ((this.headers == null) && (this.restletResponse != null)) {\r\n        this.headers = Util.copyResponseHeaders(this.restletResponse);\r\n        this.restletResponse = null;\r\n    }\r\n    return this.headers;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Service.addLink",
	"Comment": "adds an association between the source and the target entity via thegiven property name.",
	"Method": "void addLink(Object source,String sourceProperty,Object target){\r\n    if (getMetadata() == null || source == null) {\r\n        return;\r\n    }\r\n    if (target != null) {\r\n        addEntity(getSubpath(source, sourceProperty), target);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsApplication.setObjectFactory",
	"Comment": "sets the objectfactory for root resource class and providerinstantiation.",
	"Method": "void setObjectFactory(ObjectFactory objectFactory){\r\n    this.jaxRsRestlet.setObjectFactory(objectFactory);\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.DefaultSslContextFactory.setKeyStoreProvider",
	"Comment": "sets the name of the keystore provider. the default value is that of thejavax.net.ssl.keystoreprovider system property.",
	"Method": "void setKeyStoreProvider(String keyStoreProvider){\r\n    this.keyStoreProvider = keyStoreProvider;\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createJobPostingQuery",
	"Comment": "creates a query for jobposting entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.JobPosting> createJobPostingQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.JobPosting.class);\r\n}"
}, {
	"Path": "org.restlet.data.AuthenticationInfo.getNextServerNonce",
	"Comment": "returns the next server nonce. this is the nonce the server wishes theclient to use for a future authentication response",
	"Method": "String getNextServerNonce(){\r\n    return this.nextServerNonce;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.WadlApplication.canDescribe",
	"Comment": "indicates if the application and all its resources can be described usingwadl.",
	"Method": "boolean canDescribe(String remainingPart,Request request,Response response){\r\n    return isAutoDescribing() && Method.OPTIONS.equals(request.getMethod()) && (response.getStatus().isClientError() || !response.isEntityAvailable()) && (\"/\".equals(remainingPart) || \"\".equals(remainingPart));\r\n}"
}, {
	"Path": "org.restlet.data.Status.toString",
	"Comment": "returns the reason phrase of the status followed by its http code.",
	"Method": "String toString(){\r\n    return getReasonPhrase() + \" (\" + this.code + \")\" + ((getDescription() == null) ? \"\" : \" - \" + getDescription());\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createMultilingualQuery",
	"Comment": "creates a query for multilingual entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Multilingual> createMultilingualQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Multilingual.class);\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createFinancialSourceQuery",
	"Comment": "creates a query for financialsource entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.FinancialSource> createFinancialSourceQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.FinancialSource.class);\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createProfessorQuery",
	"Comment": "creates a query for professor entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Professor> createProfessorQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Professor.class);\r\n}"
}, {
	"Path": "org.restlet.representation.DigesterRepresentation.getComputedDigest",
	"Comment": "returns the current computed digest value of the representation. usermust be aware that, if the representation has not been entirely read orwritten, the computed digest value may not be accurate.",
	"Method": "Digest getComputedDigest(){\r\n    return new Digest(this.algorithm, computedDigest.digest());\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Entry.setUpdated",
	"Comment": "sets the most recent moment when the entry was modified in a significantway.",
	"Method": "void setUpdated(Date updated){\r\n    this.updated = DateUtils.unmodifiable(updated);\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.RdfRepresentation.createBuilder",
	"Comment": "returns an instance of a graph handler used when parsing the inner rdfrepresentation.",
	"Method": "GraphHandler createBuilder(Graph graph){\r\n    return new GraphBuilder(this.graph);\r\n}"
}, {
	"Path": "org.restlet.service.TunnelService.allowClient",
	"Comment": "indicates if the request from a given client can be tunneled. the defaultimplementation always return true. this could be customize to restrictthe usage of the tunnel service.",
	"Method": "boolean allowClient(ClientInfo client){\r\n    return true;\r\n}"
}, {
	"Path": "org.restlet.resource.ServerResource.getVariants",
	"Comment": "returns a modifiable list of exposed variants for the given method. youcan declare variants manually by updating the result list , by overridingthis method. by default, the variants will be provided based on annotatedmethods.",
	"Method": "List<Variant> getVariants(List<Variant> getVariants,Method method){\r\n    List<Variant> result = this.variants;\r\n    if (result == null) {\r\n        result = new ArrayList<Variant>();\r\n        if (isAnnotated() && hasAnnotations()) {\r\n            List<Variant> annoVariants = null;\r\n            method = (Method.HEAD.equals(method)) ? Method.GET : method;\r\n            for (AnnotationInfo annotationInfo : getAnnotations()) {\r\n                try {\r\n                    if (annotationInfo instanceof MethodAnnotationInfo) {\r\n                        MethodAnnotationInfo methodAnnotationInfo = (MethodAnnotationInfo) annotationInfo;\r\n                        if (methodAnnotationInfo.isCompatible(method, getQuery(), getRequestEntity(), getMetadataService(), getConverterService())) {\r\n                            annoVariants = methodAnnotationInfo.getResponseVariants(getMetadataService(), getConverterService());\r\n                            if (annoVariants != null) {\r\n                                float score = 0.5f;\r\n                                if ((getRequest().getEntity() != null) && getRequest().getEntity().isAvailable()) {\r\n                                    MediaType emt = getRequest().getEntity().getMediaType();\r\n                                    List<MediaType> amts = getMetadataService().getAllMediaTypes(methodAnnotationInfo.getInput());\r\n                                    if (amts != null) {\r\n                                        for (MediaType amt : amts) {\r\n                                            if (amt.equals(emt)) {\r\n                                                score = 1.0f;\r\n                                            } else if (amt.includes(emt)) {\r\n                                                score = Math.max(0.8f, score);\r\n                                            } else if (amt.isCompatible(emt)) {\r\n                                                score = Math.max(0.6f, score);\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                for (Variant v : annoVariants) {\r\n                                    VariantInfo vi = new VariantInfo(v, methodAnnotationInfo);\r\n                                    vi.setInputScore(score);\r\n                                    result.add(vi);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } catch (IOException e) {\r\n                    getLogger().log(Level.FINE, \"Unable to get variants from annotation\", e);\r\n                }\r\n            }\r\n        }\r\n        this.variants = result;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.internal.AwsUtils.getHmacSha256Signature",
	"Comment": "returns the aws authentication compatible signature for the given stringto sign and secret.",
	"Method": "String getHmacSha256Signature(String stringToSign,char[] secret){\r\n    return Base64.encode(DigestUtils.toHMacSha256(stringToSign, IoUtils.toByteArray(secret)), false);\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getExtensionsAsArray",
	"Comment": "returns the extensions as an array or null if no extension is found.",
	"Method": "String[] getExtensionsAsArray(){\r\n    String[] result = null;\r\n    final String extensions = getExtensions();\r\n    if (extensions != null) {\r\n        result = extensions.split(\"\\\\.\");\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.data.ClientInfo.getPreferredCharacterSet",
	"Comment": "returns the preferred character set among a list of supported ones, basedon the client preferences.",
	"Method": "CharacterSet getPreferredCharacterSet(List<CharacterSet> supported){\r\n    return getPreferredMetadata(supported, getAcceptedCharacterSets());\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsRestlet.getNoRootResClHandler",
	"Comment": "returns the restlet that is called, if no root resource class could befound. you could remove a given restlet by set null here.if no restlet is given here, status 404 will be returned.",
	"Method": "Restlet getNoRootResClHandler(){\r\n    return excHandler.getNoRootResClHandler();\r\n}"
}, {
	"Path": "org.restlet.Connector.getProtocols",
	"Comment": "returns the modifiable list of protocols simultaneously supported.",
	"Method": "List<Protocol> getProtocols(){\r\n    return this.protocols;\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.JettyServerHelper.getSpdyVersion",
	"Comment": "spdy max version. defaults to 0.can be 0, 2, or 3. if 0, spdy is not used.",
	"Method": "int getSpdyVersion(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"spdy.version\", \"0\"));\r\n}"
}, {
	"Path": "org.restlet.data.ClientInfo.setAgentAttributes",
	"Comment": "sets a list of attributes taken from the name of the user agent.",
	"Method": "void setAgentAttributes(Map<String, String> agentAttributes){\r\n    synchronized (this) {\r\n        Map<String, String> aa = getAgentAttributes();\r\n        aa.clear();\r\n        aa.putAll(agentAttributes);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.gwt.ObjectRepresentation.getObject",
	"Comment": "the wrapped object. triggers the deserialization if necessary.",
	"Method": "T getObject(){\r\n    if ((this.object == null) && (getText() != null)) {\r\n        try {\r\n            ServerSerializationStreamReader objectReader = new ServerSerializationStreamReader(Engine.getInstance().getClassLoader(), new SimpleSerializationPolicyProvider());\r\n            String encodedString = getText();\r\n            if (encodedString.indexOf('|') == -1) {\r\n                encodedString = AbstractSerializationStream.SERIALIZATION_STREAM_VERSION + \"|1|0|0|0|\" + getText() + '|';\r\n            }\r\n            objectReader.prepareToRead(encodedString);\r\n            this.object = (T) objectReader.deserializeValue(this.targetClass);\r\n        } catch (Exception e) {\r\n            this.object = null;\r\n            IOException ioe = new IOException(\"Couldn't read the GWT object representation: \" + e.getMessage());\r\n            ioe.initCause(e);\r\n            throw ioe;\r\n        }\r\n    }\r\n    return object;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.reflect.ReflectUtils.getEntryClass",
	"Comment": "returns the java class of a set of entries contained inside a feed.",
	"Method": "Class<?> getEntryClass(Feed feed){\r\n    Class<?> result = null;\r\n    if (feed != null && feed.getEntries() != null && !feed.getEntries().isEmpty()) {\r\n        for (Entry entry : feed.getEntries()) {\r\n            if (entry.getCategories() != null && !entry.getCategories().isEmpty()) {\r\n                Category category = entry.getCategories().get(0);\r\n                try {\r\n                    result = Class.forName(TypeUtils.getFullClassName(category.getTerm()));\r\n                    break;\r\n                } catch (ClassNotFoundException e) {\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.service.TunnelService.isPreferencesTunnel",
	"Comment": "indicates if the client preferences can be tunneled via the queryparameters or via file extensions. returns true by default.",
	"Method": "boolean isPreferencesTunnel(){\r\n    return this.preferencesTunnel;\r\n}"
}, {
	"Path": "org.restlet.data.Method.valueOf",
	"Comment": "returns the method associated to a given method name. if an existingconstant exists then it is returned, otherwise a new instance is created.",
	"Method": "Method valueOf(String name){\r\n    Method result = null;\r\n    if ((name != null) && !name.equals(\"\")) {\r\n        result = Method._methods.get(name.toLowerCase());\r\n        if (result == null) {\r\n            result = new Method(name);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.Util.isEmpty",
	"Comment": "tests, if the given array is empty or null. will not throw anullpointerexception.",
	"Method": "boolean isEmpty(List<?> list,boolean isEmpty,Object[] array){\r\n    if ((array == null) || (array.length == 0)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.restlet.data.CharacterSet.valueOf",
	"Comment": "returns the character set associated to a name. if an existing constantexists then it is returned, otherwise a new instance is created.",
	"Method": "CharacterSet valueOf(String name){\r\n    CharacterSet result = null;\r\n    name = getIanaName(name);\r\n    if ((name != null) && !name.equals(\"\")) {\r\n        if (name.equalsIgnoreCase(ALL.getName())) {\r\n            result = ALL;\r\n        } else if (name.equalsIgnoreCase(ISO_8859_1.getName())) {\r\n            result = ISO_8859_1;\r\n        } else if (name.equalsIgnoreCase(US_ASCII.getName())) {\r\n            result = US_ASCII;\r\n        } else if (name.equalsIgnoreCase(UTF_8.getName())) {\r\n            result = UTF_8;\r\n        } else if (name.equalsIgnoreCase(UTF_16.getName())) {\r\n            result = UTF_16;\r\n        } else if (name.equalsIgnoreCase(WINDOWS_1252.getName())) {\r\n            result = WINDOWS_1252;\r\n        } else if (name.equalsIgnoreCase(MACINTOSH.getName())) {\r\n            result = MACINTOSH;\r\n        } else {\r\n            result = new CharacterSet(name);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.data.ChallengeResponse.setIdentifier",
	"Comment": "sets the user identifier, such as a login name or an access key.",
	"Method": "void setIdentifier(String identifier){\r\n    this.identifier = identifier;\r\n}"
}, {
	"Path": "org.restlet.ext.jackson.JacksonRepresentation.getObjectReader",
	"Comment": "returns the modifiable jackson object reader. useful to customizedeserialization.",
	"Method": "ObjectReader getObjectReader(){\r\n    if (this.objectReader == null) {\r\n        this.objectReader = createObjectReader();\r\n    }\r\n    return this.objectReader;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsRestlet.setObjectFactory",
	"Comment": "sets the objectfactory for root resource class and providerinstantiation.",
	"Method": "void setObjectFactory(ObjectFactory objectFactory){\r\n    this.objectFactory = objectFactory;\r\n    this.providers.setObjectFactory(objectFactory);\r\n}"
}, {
	"Path": "org.restlet.engine.application.TunnelFilter.processQuery",
	"Comment": "updates the request method and client preferences based on queryparameters. the matched parameters are removed from the query.",
	"Method": "boolean processQuery(Request request){\r\n    TunnelService tunnelService = getTunnelService();\r\n    boolean queryModified = false;\r\n    Reference resourceRef = request.getResourceRef();\r\n    if (resourceRef.hasQuery()) {\r\n        Form query = resourceRef.getQueryAsForm(CharacterSet.UTF_8);\r\n        Method method = request.getMethod();\r\n        if (tunnelService.isMethodTunnel()) {\r\n            String methodName = query.getFirstValue(tunnelService.getMethodParameter());\r\n            Method tunnelledMethod = Method.valueOf(methodName);\r\n            if (tunnelledMethod != null && (Method.POST.equals(method) || Method.OPTIONS.equals(tunnelledMethod))) {\r\n                request.setMethod(tunnelledMethod);\r\n                query.removeFirst(tunnelService.getMethodParameter());\r\n                queryModified = true;\r\n            }\r\n        }\r\n        if (tunnelService.isPreferencesTunnel()) {\r\n            String charSetParameter = tunnelService.getCharacterSetParameter();\r\n            String encodingParameter = tunnelService.getEncodingParameter();\r\n            String languageParameter = tunnelService.getLanguageParameter();\r\n            String mediaTypeParameter = tunnelService.getMediaTypeParameter();\r\n            String acceptedCharSet = query.getFirstValue(charSetParameter);\r\n            String acceptedEncoding = query.getFirstValue(encodingParameter);\r\n            String acceptedLanguage = query.getFirstValue(languageParameter);\r\n            String acceptedMediaType = query.getFirstValue(mediaTypeParameter);\r\n            ClientInfo clientInfo = request.getClientInfo();\r\n            Metadata metadata = getMetadata(acceptedCharSet);\r\n            if ((metadata == null) && (acceptedCharSet != null)) {\r\n                metadata = CharacterSet.valueOf(acceptedCharSet);\r\n            }\r\n            if (metadata instanceof CharacterSet) {\r\n                updateMetadata(clientInfo, metadata);\r\n                query.removeFirst(charSetParameter);\r\n                queryModified = true;\r\n            }\r\n            metadata = getMetadata(acceptedEncoding);\r\n            if ((metadata == null) && (acceptedEncoding != null)) {\r\n                metadata = Encoding.valueOf(acceptedEncoding);\r\n            }\r\n            if (metadata instanceof Encoding) {\r\n                updateMetadata(clientInfo, metadata);\r\n                query.removeFirst(encodingParameter);\r\n                queryModified = true;\r\n            }\r\n            metadata = getMetadata(acceptedLanguage);\r\n            if ((metadata == null) && (acceptedLanguage != null)) {\r\n                metadata = Language.valueOf(acceptedLanguage);\r\n            }\r\n            if (metadata instanceof Language) {\r\n                updateMetadata(clientInfo, metadata);\r\n                query.removeFirst(languageParameter);\r\n                queryModified = true;\r\n            }\r\n            metadata = getMetadata(acceptedMediaType);\r\n            if ((metadata == null) && (acceptedMediaType != null)) {\r\n                metadata = MediaType.valueOf(acceptedMediaType);\r\n            }\r\n            if (metadata instanceof MediaType) {\r\n                updateMetadata(clientInfo, metadata);\r\n                query.removeFirst(mediaTypeParameter);\r\n                queryModified = true;\r\n            }\r\n        }\r\n        if (queryModified) {\r\n            request.getResourceRef().setQuery(query.getQueryString(CharacterSet.UTF_8));\r\n        }\r\n    }\r\n    return queryModified;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.Util.getPathTemplateWithoutRegExps",
	"Comment": "returns the path from the annotation. it will be encoded if necessary. ifit should not be encoded, this method checks, if all characters arevalid.",
	"Method": "String getPathTemplateWithoutRegExps(Class<?> resource,String getPathTemplateWithoutRegExps,Method method,String getPathTemplateWithoutRegExps,Path path,String getPathTemplateWithoutRegExps,String pathTemplate,Path pathForExcMess){\r\n    final StringBuilder stb = new StringBuilder();\r\n    final int l = pathTemplate.length();\r\n    for (int i = 0; i < l; i++) {\r\n        final char c = pathTemplate.charAt(i);\r\n        if (c == '{') {\r\n            i = processTemplVarname(pathTemplate, i, stb, pathForExcMess);\r\n        } else if (c == '%') {\r\n            try {\r\n                EncodeOrCheck.processPercent(i, true, pathTemplate, stb);\r\n            } catch (IllegalArgumentException e) {\r\n                throw new IllegalPathException(pathForExcMess, e);\r\n            }\r\n        } else if (c == '}') {\r\n            throw new IllegalPathException(pathForExcMess, \"'}' is only allowed as \" + \"end of a variable name in \\\"\" + pathTemplate + \"\\\"\");\r\n        } else if (c == ';') {\r\n            throw new IllegalPathException(pathForExcMess, \"A semicolon is not allowed in a path\");\r\n        } else if (c == '/') {\r\n            stb.append(c);\r\n        } else {\r\n            EncodeOrCheck.encode(c, stb);\r\n        }\r\n    }\r\n    return stb.toString();\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Entry.getId",
	"Comment": "returns the permanent, universally unique identifier for the entry.",
	"Method": "String getId(){\r\n    return this.id;\r\n}"
}, {
	"Path": "org.restlet.ext.sip.internal.SipClientHelper.getRequests",
	"Comment": "returns the map of managed transactions represented by their initialrequest.",
	"Method": "Map<String, SipRequest> getRequests(){\r\n    return requests;\r\n}"
}, {
	"Path": "org.restlet.ext.sip.Availability.getComment",
	"Comment": "returns additional information about the time of callback.",
	"Method": "String getComment(){\r\n    return comment;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsApplication.getRootResources",
	"Comment": "returns an unmodifiable set with the attached root resource classes.",
	"Method": "Collection<Class<?>> getRootResources(){\r\n    return this.jaxRsRestlet.getRootResourceClasses();\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsRestlet.instantiateRrc",
	"Comment": "instantiates the root resource class and handles thrown exceptions.",
	"Method": "ResourceObject instantiateRrc(RootResourceClass rrc){\r\n    ResourceObject o;\r\n    try {\r\n        o = rrc.getInstance(this.objectFactory);\r\n    } catch (WebApplicationException e) {\r\n        throw e;\r\n    } catch (RuntimeException e) {\r\n        throw excHandler.runtimeExecption(e, null, tlContext.get(), \"Could not create new instance of root resource class\");\r\n    } catch (InstantiateException e) {\r\n        throw excHandler.instantiateExecption(e, tlContext.get(), \"Could not create new instance of root resource class\");\r\n    } catch (InvocationTargetException e) {\r\n        throw handleInvocationTargetExc(e);\r\n    }\r\n    return o;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.SymbolTable.definePackage",
	"Comment": "adds packagedef to its parent scope and stores thepackagedef in packages",
	"Method": "void definePackage(PackageDef pkg,Scope parent){\r\n    parent.addDefinition(pkg);\r\n    packages.put(pkg.getQualifiedName(), pkg);\r\n}"
}, {
	"Path": "org.restlet.resource.Directory.setListingAllowed",
	"Comment": "indicates if the display of directory listings is allowed when no indexfile is found.",
	"Method": "void setListingAllowed(boolean listingAllowed){\r\n    this.listingAllowed = listingAllowed;\r\n}"
}, {
	"Path": "org.restlet.test.ext.jaxrs.services.path.IllegalPathService1.getPlainText",
	"Comment": "this method is only available, that the class has something that it cando.",
	"Method": "String getPlainText(){\r\n    return \"\";\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsRestlet.handleInvocationTargetExc",
	"Comment": "handles the given exception, catched by an invoke of a resource method ora creation if a sub resource object.",
	"Method": "RequestHandledException handleInvocationTargetExc(InvocationTargetException ite){\r\n    Throwable cause = ite.getCause();\r\n    if (cause instanceof ResourceException) {\r\n        Status status = ((ResourceException) cause).getStatus();\r\n        Response restletResponse = tlContext.get().getResponse();\r\n        restletResponse.setStatus(status);\r\n    } else {\r\n        javax.ws.rs.core.Response jaxRsResp = this.providers.convert(cause);\r\n        jaxRsRespToRestletResp(jaxRsResp, null);\r\n    }\r\n    throw new RequestHandledException();\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipResponse.getRecordedRoutes",
	"Comment": "returns the list of routes completed by proxies to force future requeststo go through the proxy.",
	"Method": "List<Address> getRecordedRoutes(){\r\n    List<Address> rr = this.recordedRoutes;\r\n    if (rr == null) {\r\n        synchronized (this) {\r\n            rr = this.recordedRoutes;\r\n            if (rr == null) {\r\n                this.recordedRoutes = rr = new CopyOnWriteArrayList<Address>();\r\n            }\r\n        }\r\n    }\r\n    return rr;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.Resolver.resolveExpression",
	"Comment": "resolves java expressions, returning the type to which the expressionevalutes.if this is the reference creation phase, any references found during resolution are created andresolved.",
	"Method": "IClass resolveExpression(SymTabAST expression,Scope location,IClass context,boolean referencePhase){\r\n    IClass result = null;\r\n    try {\r\n        switch(expression.getType()) {\r\n            case TokenTypes.TYPECAST:\r\n                result = resolveTypecast(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.EXPR:\r\n            case TokenTypes.LITERAL_RETURN:\r\n                if (expression.getFirstChild() != null) {\r\n                    result = resolveExpression((SymTabAST) expression.getFirstChild(), location, context, referencePhase);\r\n                } else {\r\n                }\r\n                break;\r\n            case TokenTypes.ELIST:\r\n                SymTabAST child = (SymTabAST) (expression.getFirstChild());\r\n                while (child != null) {\r\n                    if (child.getType() != TokenTypes.COMMA) {\r\n                        resolveExpression(child, location, context, referencePhase);\r\n                    }\r\n                    child = (SymTabAST) (child.getNextSibling());\r\n                }\r\n                break;\r\n            case TokenTypes.IDENT:\r\n                result = resolveIdent(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.TYPE:\r\n                result = resolveType(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.METHOD_CALL:\r\n                result = resolveMethod(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.LITERAL_THIS:\r\n                result = resolveLiteralThis(expression, location, context);\r\n                break;\r\n            case TokenTypes.LITERAL_SUPER:\r\n                result = resolveLiteralSuper(expression, location, context);\r\n                break;\r\n            case TokenTypes.DOT:\r\n                result = resolveDottedName(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.LITERAL_NEW:\r\n            case TokenTypes.CTOR_CALL:\r\n            case TokenTypes.SUPER_CTOR_CALL:\r\n                result = resolveNew(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.LITERAL_BOOLEAN:\r\n            case TokenTypes.LITERAL_DOUBLE:\r\n            case TokenTypes.LITERAL_FLOAT:\r\n            case TokenTypes.LITERAL_LONG:\r\n            case TokenTypes.LITERAL_INT:\r\n            case TokenTypes.LITERAL_SHORT:\r\n            case TokenTypes.LITERAL_BYTE:\r\n            case TokenTypes.LITERAL_CHAR:\r\n                result = resolvePrimitiveType(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.NUM_INT:\r\n            case TokenTypes.NUM_LONG:\r\n                result = resolveNumInt(expression, location, context);\r\n                break;\r\n            case TokenTypes.NUM_FLOAT:\r\n            case TokenTypes.NUM_DOUBLE:\r\n                result = resolveNumFloat(expression, location, context);\r\n                break;\r\n            case TokenTypes.STRING_LITERAL:\r\n                result = resolveStringLiteral(expression, location, context);\r\n                break;\r\n            case TokenTypes.CHAR_LITERAL:\r\n                result = resolveCharLiteral(expression, location, context);\r\n                break;\r\n            case TokenTypes.ASSIGN:\r\n            case TokenTypes.PLUS_ASSIGN:\r\n            case TokenTypes.MINUS_ASSIGN:\r\n            case TokenTypes.STAR_ASSIGN:\r\n            case TokenTypes.DIV_ASSIGN:\r\n            case TokenTypes.MOD_ASSIGN:\r\n            case TokenTypes.SR_ASSIGN:\r\n            case TokenTypes.BSR_ASSIGN:\r\n            case TokenTypes.SL_ASSIGN:\r\n            case TokenTypes.BAND_ASSIGN:\r\n            case TokenTypes.BXOR_ASSIGN:\r\n            case TokenTypes.BOR_ASSIGN:\r\n                resolveAssignment(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.LOR:\r\n            case TokenTypes.LAND:\r\n            case TokenTypes.NOT_EQUAL:\r\n            case TokenTypes.EQUAL:\r\n            case TokenTypes.LT:\r\n            case TokenTypes.GT:\r\n            case TokenTypes.LE:\r\n            case TokenTypes.GE:\r\n                result = resolveBooleanExpression(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.LITERAL_INSTANCEOF:\r\n                result = resolveInstanceOf(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.LITERAL_TRUE:\r\n            case TokenTypes.LITERAL_FALSE:\r\n                result = resolveBooleanLiteral(expression, location, context);\r\n                break;\r\n            case TokenTypes.LNOT:\r\n                result = resolveBooleanUnary(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.INC:\r\n            case TokenTypes.POST_INC:\r\n            case TokenTypes.DEC:\r\n            case TokenTypes.POST_DEC:\r\n            case TokenTypes.UNARY_PLUS:\r\n            case TokenTypes.UNARY_MINUS:\r\n                result = resolveUnaryExpression(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.PLUS:\r\n            case TokenTypes.MINUS:\r\n            case TokenTypes.DIV:\r\n            case TokenTypes.STAR:\r\n            case TokenTypes.BAND:\r\n            case TokenTypes.BOR:\r\n            case TokenTypes.BXOR:\r\n            case TokenTypes.MOD:\r\n                result = resolveArithmeticExpression(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.LITERAL_BREAK:\r\n            case TokenTypes.LITERAL_CONTINUE:\r\n                resolveGoto(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.LPAREN:\r\n                result = resolveExpression((SymTabAST) (expression.getNextSibling()), location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.INDEX_OP:\r\n                result = resolveArrayAccess(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.LITERAL_NULL:\r\n                result = new NullClass();\r\n                break;\r\n            case TokenTypes.QUESTION:\r\n                result = resolveQuestion(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.LITERAL_CLASS:\r\n                result = resolveLiteralClass();\r\n                break;\r\n            case TokenTypes.ARRAY_INIT:\r\n                resolveArrayInitializer(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.LITERAL_THROW:\r\n                resolveThrowExpression(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.SL:\r\n            case TokenTypes.SR:\r\n            case TokenTypes.BSR:\r\n                result = resolveShiftOperator(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.BNOT:\r\n                resolveBitwiseNot(expression, location, context, referencePhase);\r\n                break;\r\n            case TokenTypes.LITERAL_ASSERT:\r\n                break;\r\n            case TokenTypes.RPAREN:\r\n            case TokenTypes.EMPTY_STAT:\r\n            case TokenTypes.VARIABLE_DEF:\r\n            case TokenTypes.METHOD_DEF:\r\n            case TokenTypes.CLASS_DEF:\r\n            case TokenTypes.LITERAL_FOR:\r\n            case TokenTypes.LITERAL_WHILE:\r\n            case TokenTypes.LITERAL_IF:\r\n            case TokenTypes.LITERAL_VOID:\r\n            case TokenTypes.LITERAL_DO:\r\n            case TokenTypes.LITERAL_SWITCH:\r\n            case TokenTypes.LITERAL_STATIC:\r\n            case TokenTypes.LITERAL_TRANSIENT:\r\n            case TokenTypes.LITERAL_NATIVE:\r\n            case TokenTypes.LITERAL_SYNCHRONIZED:\r\n            case TokenTypes.LITERAL_VOLATILE:\r\n            case TokenTypes.LITERAL_TRY:\r\n            case TokenTypes.LITERAL_CATCH:\r\n            case TokenTypes.LITERAL_FINALLY:\r\n            case TokenTypes.LABELED_STAT:\r\n            case TokenTypes.LCURLY:\r\n            case TokenTypes.RCURLY:\r\n            case TokenTypes.SLIST:\r\n            case TokenTypes.SEMI:\r\n            case TokenTypes.COMMA:\r\n            case TokenTypes.ARRAY_DECLARATOR:\r\n                break;\r\n            default:\r\n                if (mInitialized) {\r\n                    final Log log = mLogFactory.getInstance(this.getClass());\r\n                    log.error(\"Unhandled expression type: \" + expression.getType());\r\n                }\r\n                break;\r\n        }\r\n    } catch (Exception e) {\r\n        result = new UnknownClass(expression.getText(), expression);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.freemarker.TemplateFilter.getDataModel",
	"Comment": "returns the template data model common to all calls. if each call shouldhave a specific model, you should set this property to null.",
	"Method": "Object getDataModel(){\r\n    return dataModel;\r\n}"
}, {
	"Path": "org.restlet.service.LogService.setResponseLogFormat",
	"Comment": "sets the format to use when logging responses. the default format matchesthe one of iis 6.",
	"Method": "void setResponseLogFormat(String responseLogFormat){\r\n    this.responseLogFormat = responseLogFormat;\r\n}"
}, {
	"Path": "org.restlet.data.RecipientInfo.setComment",
	"Comment": "sets the optional comment, typically the software agent name.",
	"Method": "void setComment(String comment){\r\n    this.comment = comment;\r\n}"
}, {
	"Path": "org.restlet.ext.html.internal.FormUtils.isEntryFound",
	"Comment": "indicates if the searched entry is specified in the given media range.",
	"Method": "boolean isEntryFound(FormData searchedEntry,MediaType mediaRange){\r\n    boolean result = false;\r\n    for (Iterator<? extends NamedValue<String>> iter = mediaRange.getParameters().iterator(); !result && iter.hasNext(); ) {\r\n        result = searchedEntry.equals(iter.next());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Feed.getIcon",
	"Comment": "returns the image that provides iconic visual identification for a feed.",
	"Method": "Reference getIcon(){\r\n    return this.icon;\r\n}"
}, {
	"Path": "org.restlet.data.Encoding.valueOf",
	"Comment": "returns the encoding associated to a name. if an existing constant existsthen it is returned, otherwise a new instance is created.",
	"Method": "Encoding valueOf(String name){\r\n    Encoding result = null;\r\n    if ((name != null) && !name.equals(\"\")) {\r\n        if (name.equalsIgnoreCase(ALL.getName())) {\r\n            result = ALL;\r\n        } else if (name.equalsIgnoreCase(GZIP.getName())) {\r\n            result = GZIP;\r\n        } else if (name.equalsIgnoreCase(ZIP.getName())) {\r\n            result = ZIP;\r\n        } else if (name.equalsIgnoreCase(COMPRESS.getName())) {\r\n            result = COMPRESS;\r\n        } else if (name.equalsIgnoreCase(DEFLATE.getName())) {\r\n            result = DEFLATE;\r\n        } else if (name.equalsIgnoreCase(DEFLATE_NOWRAP.getName())) {\r\n            result = DEFLATE_NOWRAP;\r\n        } else if (name.equalsIgnoreCase(IDENTITY.getName())) {\r\n            result = IDENTITY;\r\n        } else if (name.equalsIgnoreCase(FREEMARKER.getName())) {\r\n            result = FREEMARKER;\r\n        } else if (name.equalsIgnoreCase(VELOCITY.getName())) {\r\n            result = VELOCITY;\r\n        } else {\r\n            result = new Encoding(name);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.raml.RamlTranslator.getExampleFromPayLoad",
	"Comment": "returns an example in provided media type of the entity in the givenpayload.",
	"Method": "String getExampleFromPayLoad(PayLoad payLoad,Map<String, Map<String, Object>> representationSamples,String mediaType){\r\n    Object sample = (Types.isPrimitiveType(payLoad.getType())) ? SampleUtils.getPropertyDefaultExampleValue(payLoad.getType(), \"value\") : representationSamples.get(payLoad.getType());\r\n    if (payLoad.isArray()) {\r\n        sample = Arrays.asList(sample);\r\n    }\r\n    return SampleUtils.convertSampleAccordingToMediaType(sample, mediaType, payLoad.getType());\r\n}"
}, {
	"Path": "org.restlet.engine.header.HeaderReader.readQuotedString",
	"Comment": "reads the next quoted string. the first character must be a double quote.",
	"Method": "String readQuotedString(){\r\n    String result = null;\r\n    int next = read();\r\n    if (isDoubleQuote(next)) {\r\n        StringBuilder buffer = new StringBuilder();\r\n        while (result == null) {\r\n            next = read();\r\n            if (isQuotedText(next)) {\r\n                buffer.append((char) next);\r\n            } else if (isQuoteCharacter(next)) {\r\n                buffer.append((char) read());\r\n            } else if (isDoubleQuote(next)) {\r\n                result = buffer.toString();\r\n            } else if (next == -1) {\r\n                throw new IOException(\"Unexpected end of quoted string. Please check your value\");\r\n            } else {\r\n                throw new IOException(\"Invalid character \\\"\" + next + \"\\\" detected in quoted string. Please check your value\");\r\n            }\r\n        }\r\n    } else {\r\n        throw new IOException(\"A quoted string must start with a double quote\");\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createLanguageQuery",
	"Comment": "creates a query for language entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Language> createLanguageQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Language.class);\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.ScopeIndex.findScope",
	"Comment": "returns the most specific scope to which the specifiedoccurence belongs from the specified vectorof scopes.",
	"Method": "Scope findScope(Vector scopeList,Occurrence occ){\r\n    int i = 0;\r\n    Scope bestSoFar = (Scope) scopeList.elementAt(i);\r\n    while (!bestSoFar.getTreeNode().getSpan().contains(occ.getLine(), occ.getColumn())) {\r\n        i++;\r\n        bestSoFar = (Scope) scopeList.elementAt(i);\r\n    }\r\n    for (; i < scopeList.size(); i++) {\r\n        Scope currentScope = (Scope) scopeList.elementAt(i);\r\n        if (currentScope.getTreeNode().getSpan().contains(occ.getLine(), occ.getColumn())) {\r\n            if (bestSoFar.getTreeNode().getSpan().contains(currentScope.getTreeNode().getSpan())) {\r\n                bestSoFar = currentScope;\r\n            }\r\n        }\r\n    }\r\n    return bestSoFar;\r\n}"
}, {
	"Path": "org.restlet.representation.Variant.includes",
	"Comment": "indicates if the current variant includes the given variant.",
	"Method": "boolean includes(Variant other){\r\n    boolean result = other != null;\r\n    if (result) {\r\n        result = (getCharacterSet() == null) || getCharacterSet().includes(other.getCharacterSet());\r\n    }\r\n    if (result) {\r\n        result = (getMediaType() == null) || getMediaType().includes(other.getMediaType());\r\n    }\r\n    if (result) {\r\n        result = (getLanguages().isEmpty()) || getLanguages().contains(Language.ALL) || getLanguages().containsAll(other.getLanguages());\r\n    }\r\n    if (result) {\r\n        result = (getEncodings().isEmpty()) || getEncodings().contains(Encoding.ALL) || getEncodings().containsAll(other.getEncodings());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.Transformer.getTransformSheet",
	"Comment": "returns the xslt transform sheet to apply to message entities.",
	"Method": "Representation getTransformSheet(){\r\n    return this.transformSheet;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.ApiSparkService.getAgentCellVersion",
	"Comment": "returns the identifier of the cell version configured on the apisparkplatform for your application.",
	"Method": "Integer getAgentCellVersion(){\r\n    return agentCellVersion;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.core.ResponseBuilderImpl.cookie",
	"Comment": "add cookies to the responsebuilder. if more than one cookie with the sameis supplied, later ones overwrite earlier ones.",
	"Method": "ResponseBuilder cookie(NewCookie cookies){\r\n    final Map<String, NewCookie> newCookies = getNewCookies();\r\n    for (final NewCookie cookie : cookies) {\r\n        if (cookie != null) {\r\n            newCookies.put(cookie.getName(), cookie);\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.restlet.data.CookieSetting.isSecure",
	"Comment": "indicates if cookie should only be transmitted by secure means.",
	"Method": "boolean isSecure(){\r\n    return this.secure;\r\n}"
}, {
	"Path": "org.restlet.test.ext.jaxrs.services.tests.JaxRsTestCase.accessServer",
	"Comment": "sends a request to the given sub path of the given root resource with thegiven http method and the given acceptable media type.",
	"Method": "Response accessServer(Method httpMethod,Response accessServer,Method httpMethod,Class<?> klasse,Collection acceptedMediaTypes,Response accessServer,Method httpMethod,Class<?> klasse,String subPath,Collection accMediaTypes,ChallengeResponse challengeResponse,Response accessServer,Method httpMethod,Class<?> klasse,String subPath,Conditions conditions,ClientInfo clientInfo,Response accessServer,Method httpMethod,Class<?> klasse,String subPath,MediaType accMediaType){\r\n    Collection<MediaType> mediaTypes = null;\r\n    if (accMediaType != null) {\r\n        mediaTypes = Collections.singleton(accMediaType);\r\n    }\r\n    return accessServer(httpMethod, klasse, subPath, mediaTypes, null);\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipRequest.getOrganization",
	"Comment": "returns the name of the organization to which the sip element issuing themessage belongs.",
	"Method": "String getOrganization(){\r\n    return organization;\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipResponse.setRecordedRoutes",
	"Comment": "sets the list of routes completed by proxies to force future requests togo through the proxy.",
	"Method": "void setRecordedRoutes(List<Address> recordedRoutes){\r\n    this.recordedRoutes = recordedRoutes;\r\n}"
}, {
	"Path": "org.restlet.engine.io.IoUtils.getStream",
	"Comment": "returns an output stream based on a given writable byte channel.",
	"Method": "java.io.OutputStream getStream(java.io.Writer writer,CharacterSet characterSet,InputStream getStream,ReadableByteChannel readableChannel,InputStream getStream,Reader reader,CharacterSet characterSet,InputStream getStream,Representation representation,OutputStream getStream,WritableByteChannel writableChannel){\r\n    OutputStream result = null;\r\n    if (writableChannel != null) {\r\n        result = isBlocking(writableChannel) ? Channels.newOutputStream(writableChannel) : new NbChannelOutputStream(writableChannel);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.controller.ConnectionController.controlConnection",
	"Comment": "controls a given connection for messages to read or write. close inactiveconnections, select ready connections or register interest in niooperations.",
	"Method": "void controlConnection(Connection<?> conn){\r\n    if (getHelper().getLogger().isLoggable(Level.FINEST)) {\r\n        getHelper().getLogger().log(Level.FINEST, \"Connection status: \" + conn);\r\n    }\r\n    if (conn.getState() == ConnectionState.CLOSED) {\r\n        getHelper().getConnections().remove(conn);\r\n        getHelper().checkin(conn);\r\n    } else if ((conn.getState() == ConnectionState.CLOSING) && conn.isEmpty()) {\r\n        conn.close(false);\r\n    } else if (conn.hasTimedOut()) {\r\n        conn.onTimeOut();\r\n    } else if (conn.updateState()) {\r\n        getUpdatedRegistrations().add(conn.getRegistration());\r\n    } else if (conn.isReady()) {\r\n        conn.onSelected(conn.getRegistration());\r\n    }\r\n}"
}, {
	"Path": "org.restlet.Application.isDebugging",
	"Comment": "indicates if the debugging mode is enabled. true by default.",
	"Method": "boolean isDebugging(){\r\n    return debugging;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.swagger.v2_0.SwaggerTypes.toDefinitionType",
	"Comment": "returns the rwadef type corresponding to the given swagger property.",
	"Method": "String toDefinitionType(Property property){\r\n    if (property instanceof RefProperty) {\r\n        RefProperty refProperty = (RefProperty) property;\r\n        return refProperty.getSimpleRef();\r\n    } else if (property instanceof ArrayProperty) {\r\n        ArrayProperty arrayProperty = (ArrayProperty) property;\r\n        return toDefinitionType(arrayProperty.getItems());\r\n    }\r\n    SwaggerTypeFormat swaggerTypeFormat = new SwaggerTypeFormat(property.getType(), property.getFormat());\r\n    return SwaggerTypes.toDefinitionPrimitiveType(swaggerTypeFormat);\r\n}"
}, {
	"Path": "org.restlet.service.StatusService.getContactEmail",
	"Comment": "returns the email address to contact in case of error. this is typicallyused when creating the status representations.",
	"Method": "String getContactEmail(){\r\n    return this.contactEmail;\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.Graph.getSourceAsGraph",
	"Comment": "returns the source reference, either the one given in the sourcerefparameter or if it is null, the source reference of the default link.",
	"Method": "Graph getSourceAsGraph(Graph sourceGraph){\r\n    Graph result = sourceGraph;\r\n    if ((result == null) && (getDefaultLink() != null)) {\r\n        result = getDefaultLink().getSourceAsGraph();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.resource.Resource.getConditions",
	"Comment": "returns the modifiable conditions applying to this request. creates a newinstance if no one has been set.",
	"Method": "Conditions getConditions(){\r\n    return getRequest() == null ? null : getRequest().getConditions();\r\n}"
}, {
	"Path": "com.restfb.JsonMapperToJavaTest.authCreateToken",
	"Comment": "can we successfully map the results of the auth.createtoken call?",
	"Method": "void authCreateToken(){\r\n    String token = createJsonMapper().toJavaObject(jsonFromClasspath(\"api/auth.createToken\"), String.class);\r\n    assertThat(token).isEqualTo(\"3e4a22bb2f5ed75114b0fc9995ea85f1\");\r\n}"
}, {
	"Path": "org.restlet.util.WrapperRequest.setAccessControlRequestMethod",
	"Comment": "sets the access control request method of the target resource.",
	"Method": "void setAccessControlRequestMethod(Method accessControlRequestMethod){\r\n    super.setAccessControlRequestMethod(accessControlRequestMethod);\r\n}"
}, {
	"Path": "org.restlet.data.RecipientInfo.getComment",
	"Comment": "returns the optional comment, typically the software agent name.",
	"Method": "String getComment(){\r\n    return comment;\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.DefaultSslContextFactory.setKeyStoreType",
	"Comment": "sets the keystore type of the keystore. the default value is that of thejavax.net.ssl.keystoretype system property.",
	"Method": "void setKeyStoreType(String keyStoreType){\r\n    this.keyStoreType = keyStoreType;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.internal.HttpDigestHelper.isNonceValid",
	"Comment": "checks whether the specified nonce is valid with respect to the specifiedsecretkey, and further confirms that the nonce was generated less thanlifespanmillis milliseconds ago",
	"Method": "boolean isNonceValid(String nonce,String secretKey,long lifespan){\r\n    try {\r\n        String decodedNonce = new String(Base64.decode(nonce));\r\n        long nonceTimeMS = Long.parseLong(decodedNonce.substring(0, decodedNonce.indexOf(':')));\r\n        if (decodedNonce.equals(nonceTimeMS + \":\" + DigestUtils.toMd5(nonceTimeMS + \":\" + secretKey))) {\r\n            return lifespan > (System.currentTimeMillis() - nonceTimeMS);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new Exception(\"Error detected parsing nonce: \" + e);\r\n    }\r\n    throw new Exception(\"The nonce does not match secretKey\");\r\n}"
}, {
	"Path": "org.restlet.ext.spring.SpringBeanRouter.setFindingInAncestors",
	"Comment": "sets if bean names will be searched for higher up in the beanfactoryhierarchy.",
	"Method": "void setFindingInAncestors(boolean findingInAncestors){\r\n    this.findingInAncestors = findingInAncestors;\r\n}"
}, {
	"Path": "org.restlet.util.SelectionRegistration.isCanceling",
	"Comment": "indicates if a canceling of the registration has been requested.",
	"Method": "boolean isCanceling(){\r\n    return this.canceling;\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.patch",
	"Comment": "patches a resource with the given representation as delta state. if asuccess status is not returned, then a resource exception is thrown.",
	"Method": "Representation patch(Object entity,T patch,Object entity,Class<T> resultClass,Representation patch,Object entity,MediaType mediaType,Representation patch,Representation entity){\r\n    return handle(Method.PATCH, entity);\r\n}"
}, {
	"Path": "org.restlet.engine.header.HeaderReader.readHeader",
	"Comment": "read a header. return null if the last header was already read.",
	"Method": "Header readHeader(CharSequence header,Header readHeader,InputStream is,StringBuilder sb){\r\n    Header result = null;\r\n    int next = is.read();\r\n    if (isCarriageReturn(next)) {\r\n        next = is.read();\r\n        if (!isLineFeed(next)) {\r\n            throw new IOException(\"Invalid end of headers. Line feed missing after the carriage return.\");\r\n        }\r\n    } else {\r\n        result = new Header();\r\n        while ((next != -1) && (next != ':')) {\r\n            sb.append((char) next);\r\n            next = is.read();\r\n        }\r\n        if (next == -1) {\r\n            throw new IOException(\"Unable to parse the header name. End of stream reached too early.\");\r\n        }\r\n        result.setName(sb.toString());\r\n        sb.delete(0, sb.length());\r\n        next = is.read();\r\n        while (isSpace(next)) {\r\n            next = is.read();\r\n        }\r\n        while ((next != -1) && (!isCarriageReturn(next))) {\r\n            sb.append((char) next);\r\n            next = is.read();\r\n        }\r\n        if (next == -1) {\r\n            throw new IOException(\"Unable to parse the header value. End of stream reached too early.\");\r\n        }\r\n        next = is.read();\r\n        if (isLineFeed(next)) {\r\n            result.setValue(sb.toString());\r\n            sb.delete(0, sb.length());\r\n        } else {\r\n            throw new IOException(\"Unable to parse the HTTP header value. The carriage return must be followed by a line feed.\");\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.header.ProductReader.read",
	"Comment": "parses the given user agent string to a list of product instances.",
	"Method": "List<Product> read(String userAgent){\r\n    final List<Product> result = new ArrayList<Product>();\r\n    if (userAgent != null) {\r\n        String token = null;\r\n        String version = null;\r\n        String comment = null;\r\n        final char[] tab = userAgent.trim().toCharArray();\r\n        StringBuilder tokenBuilder = new StringBuilder();\r\n        StringBuilder versionBuilder = null;\r\n        StringBuilder commentBuilder = null;\r\n        int index = 0;\r\n        boolean insideToken = true;\r\n        boolean insideVersion = false;\r\n        boolean insideComment = false;\r\n        for (index = 0; index < tab.length; index++) {\r\n            final char c = tab[index];\r\n            if (insideToken) {\r\n                if (HeaderUtils.isTokenChar(c) || (c == ' ')) {\r\n                    tokenBuilder.append(c);\r\n                } else {\r\n                    token = tokenBuilder.toString().trim();\r\n                    insideToken = false;\r\n                    if (c == '/') {\r\n                        insideVersion = true;\r\n                        versionBuilder = new StringBuilder();\r\n                    } else if (c == '(') {\r\n                        insideComment = true;\r\n                        commentBuilder = new StringBuilder();\r\n                    }\r\n                }\r\n            } else {\r\n                if (insideVersion) {\r\n                    if (c != ' ') {\r\n                        versionBuilder.append(c);\r\n                    } else {\r\n                        insideVersion = false;\r\n                        version = versionBuilder.toString();\r\n                    }\r\n                } else {\r\n                    if (c == '(') {\r\n                        insideComment = true;\r\n                        commentBuilder = new StringBuilder();\r\n                    } else {\r\n                        if (insideComment) {\r\n                            if (c == ')') {\r\n                                insideComment = false;\r\n                                comment = commentBuilder.toString();\r\n                                result.add(new Product(token, version, comment));\r\n                                insideToken = true;\r\n                                tokenBuilder = new StringBuilder();\r\n                            } else {\r\n                                commentBuilder.append(c);\r\n                            }\r\n                        } else {\r\n                            result.add(new Product(token, version, null));\r\n                            insideToken = true;\r\n                            tokenBuilder = new StringBuilder();\r\n                            tokenBuilder.append(c);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (insideComment) {\r\n            comment = commentBuilder.toString();\r\n            result.add(new Product(token, version, comment));\r\n        } else {\r\n            if (insideVersion) {\r\n                version = versionBuilder.toString();\r\n                result.add(new Product(token, version, null));\r\n            } else {\r\n                if (insideToken && (tokenBuilder.length() > 0)) {\r\n                    token = tokenBuilder.toString();\r\n                    result.add(new Product(token, null, null));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.Engine.clearThreadLocalVariables",
	"Comment": "clears the thread local variables set by the restlet api and engine.",
	"Method": "void clearThreadLocalVariables(){\r\n    Response.setCurrent(null);\r\n    Context.setCurrent(null);\r\n    org.restlet.routing.VirtualHost.setCurrent(null);\r\n    org.restlet.Application.setCurrent(null);\r\n}"
}, {
	"Path": "org.restlet.ext.httpclient.HttpClientHelper.getMaxConnectionsPerHost",
	"Comment": "returns the maximum number of connections that will be created for anyparticular host.",
	"Method": "int getMaxConnectionsPerHost(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"maxConnectionsPerHost\", \"10\"));\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.raml.RamlUtils.getParentResource",
	"Comment": "gets the parent resource of a resource given its path and the list ofpaths available on the api.",
	"Method": "Resource getParentResource(List<String> paths,String resourcePath,Raml raml){\r\n    List<String> parentPaths = new ArrayList<String>();\r\n    parentPaths.addAll(paths);\r\n    parentPaths.add(resourcePath);\r\n    Collections.sort(parentPaths);\r\n    int index = parentPaths.indexOf(resourcePath);\r\n    if (index != 0) {\r\n        String parentPath = parentPaths.get(index - 1);\r\n        if (resourcePath.startsWith(parentPath)) {\r\n            return getResourceByCompletePath(raml, parentPath);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.Request.getOnResponse",
	"Comment": "returns the callback invoked on response reception. if the value is notnull, then the associated request will be executed asynchronously.",
	"Method": "Uniform getOnResponse(){\r\n    return onResponse;\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createRegistrationQuery",
	"Comment": "creates a query for registration entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Registration> createRegistrationQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Registration.class);\r\n}"
}, {
	"Path": "org.restlet.ext.spring.SpringContext.getPropertyConfigRefs",
	"Comment": "returns the modifiable list of configuration uris for beans definitionsvia property representations.",
	"Method": "List<String> getPropertyConfigRefs(){\r\n    List<String> p = this.propertyConfigRefs;\r\n    if (p == null) {\r\n        synchronized (this) {\r\n            p = this.propertyConfigRefs;\r\n            if (p == null) {\r\n                this.propertyConfigRefs = p = new ArrayList<String>();\r\n            }\r\n        }\r\n    }\r\n    return p;\r\n}"
}, {
	"Path": "org.restlet.ext.sdc.internal.SdcServerConnection.readHandshake",
	"Comment": "reads the sdc initial handshake message from the socket input stream.",
	"Method": "boolean readHandshake(){\r\n    boolean result = true;\r\n    byte[] hsm = (\"v5.0 \" + FrameReceiver.class.getPackage().getImplementationVersion() + \"\\n\").getBytes();\r\n    int c;\r\n    for (int i = 0; result && (i < hsm.length); i++) {\r\n        c = getInputStream().read();\r\n        result = (c == hsm[i]);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.service.MetadataService.getAllLanguages",
	"Comment": "returns all the languages associated to this extension. it returns nullif the extension was not declared.",
	"Method": "List<Language> getAllLanguages(String extension){\r\n    List<Language> result = null;\r\n    if (extension != null) {\r\n        for (MetadataExtension metadataExtension : this.mappings) {\r\n            if (extension.equals(metadataExtension.getName()) && (metadataExtension.getMetadata() instanceof Language)) {\r\n                if (result == null) {\r\n                    result = new ArrayList<Language>();\r\n                }\r\n                result.add(metadataExtension.getLanguage());\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.data.Reference.isGenericDelimiter",
	"Comment": "indicates if the given character is a generic uri component delimitercharacter.",
	"Method": "boolean isGenericDelimiter(int character){\r\n    return (character == ':') || (character == '/') || (character == '?') || (character == '#') || (character == '[') || (character == ']') || (character == '@');\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.Resolver.resolveArithmeticExpression",
	"Comment": "resolves an arithmetic expression.returns the scope forthe type to which the expression resolves.any references found duringresolution are created and resolved.",
	"Method": "IClass resolveArithmeticExpression(SymTabAST expression,Scope location,IClass context,boolean referencePhase){\r\n    IClass result = null;\r\n    SymTabAST leftChild = findLeftChild(expression);\r\n    IClass leftType = (resolveExpression(leftChild, location, context, referencePhase));\r\n    SymTabAST rightChild = findRightSibling(leftChild);\r\n    IClass rightType = (resolveExpression(rightChild, location, context, referencePhase));\r\n    result = binaryResultType(leftType, rightType);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.security.MethodAuthorizer.getAuthenticatedMethods",
	"Comment": "returns the modifiable list of methods authorized for authenticatedusers.",
	"Method": "List<Method> getAuthenticatedMethods(){\r\n    return authenticatedMethods;\r\n}"
}, {
	"Path": "org.restlet.example.book.restlet.ch02.sec5.sub2.RootServerResource.options",
	"Comment": "handle the http options method by illustrating the impact of throwing anexception.",
	"Method": "Representation options(){\r\n    System.out.println(\"The OPTIONS method of root resource was invoked.\");\r\n    throw new RuntimeException(\"Not yet implemented\");\r\n}"
}, {
	"Path": "org.restlet.routing.Router.getDefaultRoute",
	"Comment": "returns the default route to test if no other one was available afterretrying the maximum number of attempts.",
	"Method": "Route getDefaultRoute(){\r\n    return this.defaultRoute;\r\n}"
}, {
	"Path": "org.restlet.engine.application.TunnelFilter.updateMetadata",
	"Comment": "updates the client info with the given metadata. it clears existingpreferences for the same type of metadata if necessary.",
	"Method": "void updateMetadata(ClientInfo clientInfo,Metadata metadata){\r\n    if (metadata != null) {\r\n        if (metadata instanceof CharacterSet) {\r\n            clientInfo.getAcceptedCharacterSets().clear();\r\n            clientInfo.getAcceptedCharacterSets().add(new Preference<CharacterSet>((CharacterSet) metadata));\r\n        } else if (metadata instanceof Encoding) {\r\n            clientInfo.getAcceptedEncodings().clear();\r\n            clientInfo.getAcceptedEncodings().add(new Preference<Encoding>((Encoding) metadata));\r\n        } else if (metadata instanceof Language) {\r\n            clientInfo.getAcceptedLanguages().clear();\r\n            clientInfo.getAcceptedLanguages().add(new Preference<Language>((Language) metadata));\r\n        } else if (metadata instanceof MediaType) {\r\n            clientInfo.getAcceptedMediaTypes().clear();\r\n            clientInfo.getAcceptedMediaTypes().add(new Preference<MediaType>((MediaType) metadata));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.util.WrapperList.remove",
	"Comment": "removes the first occurrence in this list of the specified element.",
	"Method": "E remove(int index,boolean remove,Object element){\r\n    return getDelegate().remove(element);\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.provider.WebAppExcMapper.giveOtherVariant",
	"Comment": "creates an entity with a list of links to the accepted variants.",
	"Method": "Response giveOtherVariant(Collection<Variant> acceptedVariants,Response response){\r\n    if ((acceptedVariants != null) && acceptedVariants.isEmpty()) {\r\n        acceptedVariants = null;\r\n    }\r\n    final ResponseBuilder rb = Response.fromResponse(response);\r\n    final StringBuilder stb = new StringBuilder();\r\n    stb.append(\"The given resource variant is not supported.\");\r\n    if (acceptedVariants != null) {\r\n        stb.append(\"Please use one of the following:\\n\");\r\n        stb.append(\"\\n\");\r\n        for (final Variant variant : acceptedVariants) {\r\n            stb.append(\"* \");\r\n            stb.append(variant);\r\n            stb.append(\"\\n\");\r\n        }\r\n    }\r\n    rb.entity(stb);\r\n    rb.type(MediaType.TEXT_PLAIN_TYPE);\r\n    return rb.build();\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.ResponseInfo.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    AttributesImpl attributes = new AttributesImpl();\r\n    if ((getStatuses() != null) && !getStatuses().isEmpty()) {\r\n        StringBuilder builder = new StringBuilder();\r\n        for (Iterator<Status> iterator = getStatuses().iterator(); iterator.hasNext(); ) {\r\n            Status status = iterator.next();\r\n            builder.append(status.getCode());\r\n            if (iterator.hasNext()) {\r\n                builder.append(\" \");\r\n            }\r\n        }\r\n        attributes.addAttribute(\"\", \"status\", null, \"xs:string\", builder.toString());\r\n    }\r\n    if (getDocumentations().isEmpty() && getParameters().isEmpty() && getRepresentations().isEmpty()) {\r\n        writer.emptyElement(APP_NAMESPACE, \"response\", null, attributes);\r\n    } else {\r\n        writer.startElement(APP_NAMESPACE, \"response\", null, attributes);\r\n        for (DocumentationInfo documentationInfo : getDocumentations()) {\r\n            documentationInfo.writeElement(writer);\r\n        }\r\n        for (ParameterInfo parameterInfo : getParameters()) {\r\n            parameterInfo.writeElement(writer);\r\n        }\r\n        for (RepresentationInfo representationInfo : getRepresentations()) {\r\n            representationInfo.writeElement(writer);\r\n        }\r\n        writer.endElement(APP_NAMESPACE, \"response\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.util.WrapperMap.values",
	"Comment": "returns a collection view of the values contained in this map.",
	"Method": "Collection<V> values(){\r\n    return getDelegate().values();\r\n}"
}, {
	"Path": "org.restlet.util.WrapperResponse.setProxyChallengeRequests",
	"Comment": "sets the list of authentication requests sent by a proxy to a client.",
	"Method": "void setProxyChallengeRequests(List<ChallengeRequest> requests){\r\n    getWrappedResponse().setProxyChallengeRequests(requests);\r\n}"
}, {
	"Path": "org.restlet.engine.util.FormUtils.getParameter",
	"Comment": "reads the parameters with the given name.if multiple values are found, a list is returned created.",
	"Method": "Object getParameter(Representation form,String name,Object getParameter,String query,String name,CharacterSet characterSet,char separator,boolean decode){\r\n    return new FormReader(query, characterSet, separator, decode).readParameter(name);\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Service.loadProperty",
	"Comment": "updates the given entity object with the value of the specified property.",
	"Method": "void loadProperty(Object entity,String propertyName){\r\n    if (getMetadata() == null || entity == null) {\r\n        return;\r\n    }\r\n    Metadata metadata = (Metadata) getMetadata();\r\n    EntityType type = metadata.getEntityType(entity.getClass());\r\n    AssociationEnd association = metadata.getAssociation(type, propertyName);\r\n    if (association != null) {\r\n        EntityType propertyEntityType = association.getType();\r\n        try {\r\n            Class<?> propertyClass = ReflectUtils.getSimpleClass(entity, propertyName);\r\n            if (propertyClass == null) {\r\n                propertyClass = TypeUtils.getJavaClass(propertyEntityType);\r\n            }\r\n            Iterator<?> iterator = createQuery(getSubpath(entity, propertyName), propertyClass).iterator();\r\n            ReflectUtils.setProperty(entity, propertyName, association.isToMany(), iterator, propertyClass);\r\n        } catch (Exception e) {\r\n            getLogger().log(Level.WARNING, \"Can't set the property \" + propertyName + \" of \" + entity.getClass() + \" for the service\" + getServiceRef(), e);\r\n        }\r\n    } else {\r\n        ClientResource resource = createResource(getSubpath(entity, propertyName));\r\n        try {\r\n            Representation rep = resource.get();\r\n            try {\r\n                String value = getSimpleValue(rep, propertyName);\r\n                Property property = metadata.getProperty(entity, propertyName);\r\n                ReflectUtils.setProperty(entity, property, value);\r\n            } catch (Exception e) {\r\n                getLogger().log(Level.WARNING, \"Can't set the property \" + propertyName + \" of \" + entity.getClass() + \" for the service\" + getServiceRef(), e);\r\n            }\r\n        } catch (ResourceException e) {\r\n            getLogger().log(Level.WARNING, \"Can't get the following resource \" + resource.getReference() + \" for the service\" + getServiceRef(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.resource.ServerResource.isInRole",
	"Comment": "indicates if the authenticated client user associated to the currentrequest is in the given role name.",
	"Method": "boolean isInRole(String roleName){\r\n    return getClientInfo().getRoles().contains(getRole(roleName));\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.AwsAuthenticator.setWrappedVerifier",
	"Comment": "sets the secret verifier that will be wrapped by the real verifiersupporting all the http aws verifications.",
	"Method": "void setWrappedVerifier(LocalVerifier verifier){\r\n    getVerifier().setWrappedVerifier(verifier);\r\n}"
}, {
	"Path": "org.restlet.ext.oauth.internal.AuthSession.setAttribute",
	"Comment": "store attribute for internal use. the value must be normalized.",
	"Method": "void setAttribute(String name,Object value){\r\n    if (value == null) {\r\n        removeAttribute(name);\r\n    } else {\r\n        attribs.put(name, value);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.Request.setOnResponse",
	"Comment": "sets the callback invoked on response reception. if the value is notnull, then the associated request will be executed asynchronously.",
	"Method": "void setOnResponse(Uniform onResponseCallback){\r\n    this.onResponse = onResponseCallback;\r\n}"
}, {
	"Path": "org.restlet.data.Reference.setAuthority",
	"Comment": "sets the authority component for hierarchical identifiers.",
	"Method": "void setAuthority(String authority){\r\n    final String oldPart = isRelative() ? getRelativePart() : getSchemeSpecificPart();\r\n    String newPart;\r\n    final String newAuthority = (authority == null) ? \"\" : \"//\" + authority;\r\n    if (oldPart == null) {\r\n        newPart = newAuthority;\r\n    } else if (oldPart.startsWith(\"//\")) {\r\n        int index = oldPart.indexOf('/', 2);\r\n        if (index != -1) {\r\n            newPart = newAuthority + oldPart.substring(index);\r\n        } else {\r\n            index = oldPart.indexOf('?');\r\n            if (index != -1) {\r\n                newPart = newAuthority + oldPart.substring(index);\r\n            } else {\r\n                newPart = newAuthority;\r\n            }\r\n        }\r\n    } else {\r\n        newPart = newAuthority + oldPart;\r\n    }\r\n    if (isAbsolute()) {\r\n        setSchemeSpecificPart(newPart);\r\n    } else {\r\n        setRelativePart(newPart);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.log.LogFilter.beforeHandle",
	"Comment": "allows filtering before processing by the next restlet. saves the starttime.",
	"Method": "int beforeHandle(Request request,Response response){\r\n    request.getAttributes().put(\"org.restlet.startTime\", System.currentTimeMillis());\r\n    request.setLoggable(this.logService.isLoggable(request));\r\n    if (request.isLoggable() && this.logLogger.isLoggable(Level.FINE)) {\r\n        this.logLogger.fine(\"Processing request to: \\\"\" + ((request.getResourceRef() == null) ? \"Unknown URI\" : request.getResourceRef().getTargetRef().toString()) + \"\\\"\");\r\n    }\r\n    return CONTINUE;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.core.MultivaluedMapImpl.add",
	"Comment": "add a value to the current list of values for the supplied key.",
	"Method": "void add(K key,V value){\r\n    List<V> list = get(key);\r\n    if (list == null) {\r\n        list = new LinkedList<V>();\r\n        put(key, list);\r\n    }\r\n    list.add(value);\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Service.setMaxClientVersion",
	"Comment": "sets the maximum version of the odata protocol extensions the client canaccept in a response.",
	"Method": "void setMaxClientVersion(String maxClientVersion){\r\n    this.maxClientVersion = maxClientVersion;\r\n}"
}, {
	"Path": "org.restlet.resource.Directory.getIndexVariants",
	"Comment": "returns the variant representations of a directory index. this method canbe subclassed in order to provide alternative representations.by default it returns a simple html document and a textual uri list asvariants. note that a new instance of the list is created for each call.",
	"Method": "List<Variant> getIndexVariants(ReferenceList indexContent){\r\n    final List<Variant> result = new ArrayList<Variant>();\r\n    result.add(new Variant(MediaType.TEXT_HTML));\r\n    result.add(new Variant(MediaType.TEXT_URI_LIST));\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.log.LogFilter.afterHandle",
	"Comment": "allows filtering after processing by the next restlet. logs the call.",
	"Method": "void afterHandle(Request request,Response response){\r\n    try {\r\n        if (request.isLoggable() && this.logLogger.isLoggable(Level.INFO)) {\r\n            long startTime = (Long) request.getAttributes().get(\"org.restlet.startTime\");\r\n            int duration = (int) (System.currentTimeMillis() - startTime);\r\n            this.logLogger.log(Level.INFO, this.logService.getResponseLogMessage(response, duration));\r\n        }\r\n    } catch (Throwable e) {\r\n        getLogger().log(Level.SEVERE, \"Cannot log call\", e);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.routing.TemplateRoute.isMatchingQuery",
	"Comment": "indicates whether the query part should be taken into account whenmatching a reference with the template.",
	"Method": "boolean isMatchingQuery(){\r\n    return this.matchingQuery;\r\n}"
}, {
	"Path": "org.restlet.ext.xdb.internal.ChunkedInputStream.canRead",
	"Comment": "indicates if the source stream can be read and prepare it if necessary.",
	"Method": "boolean canRead(){\r\n    boolean result = false;\r\n    initialize();\r\n    if (!this.endReached) {\r\n        if (!chunkAvailable()) {\r\n            initializeChunk();\r\n        }\r\n        result = !this.endReached;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getHierarchicalPart",
	"Comment": "returns the hierarchical part which is equivalent to the scheme specificpart less the query component.note that no uri decoding is done by this method.",
	"Method": "String getHierarchicalPart(String getHierarchicalPart,boolean decode){\r\n    return decode ? decode(getHierarchicalPart()) : getHierarchicalPart();\r\n}"
}, {
	"Path": "org.restlet.security.Group.isInheritingRoles",
	"Comment": "indicates if the roles of the parent group should be inherited. thoseroles indirectly cover the granted or denied permissions.",
	"Method": "boolean isInheritingRoles(){\r\n    return inheritingRoles;\r\n}"
}, {
	"Path": "org.restlet.example.ext.rdf.foaf.resources.BaseResource.getTemplateRepresentation",
	"Comment": "returns a templated representation dedicated to html content.",
	"Method": "Representation getTemplateRepresentation(String templateName,Map<String, Object> dataModel,MediaType mediaType){\r\n    return new TemplateRepresentation(templateName, getFmcConfiguration(), dataModel, mediaType);\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipRequest.isHandled",
	"Comment": "indicates that the request has been handled, typically after receiving afinal response.",
	"Method": "boolean isHandled(){\r\n    return handled;\r\n}"
}, {
	"Path": "org.restlet.engine.application.StrictConneg.scoreLanguages",
	"Comment": "scores languages relatively to enriched client preferences.",
	"Method": "float scoreLanguages(List<Language> languages){\r\n    return scoreMetadata(languages, getLanguagePrefs());\r\n}"
}, {
	"Path": "org.restlet.resource.Directory.setModifiable",
	"Comment": "indicates if modifications to local resources are allowed.",
	"Method": "void setModifiable(boolean modifiable){\r\n    this.modifiable = modifiable;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.ASTManager.isEmptyDetailsMap",
	"Comment": "determines whether the map from detailsasts to symtabasts is empty.",
	"Method": "boolean isEmptyDetailsMap(){\r\n    return mMap.isEmpty();\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.setResponseEntityBuffering",
	"Comment": "indicates if transient or unknown size response entities should bebuffered after being received. this is useful to be able tosystematically reuse and process a response entity several times afterretrieval.",
	"Method": "void setResponseEntityBuffering(boolean responseEntityBuffering){\r\n    this.responseEntityBuffering = responseEntityBuffering;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.AwsAuthenticator.setMaxRequestAge",
	"Comment": "sets the maximum age of a request, in milliseconds, before it isconsidered stale.a negative or zero value indicates no age restriction. the default valueis 15 minutes.",
	"Method": "void setMaxRequestAge(long value){\r\n    getVerifier().setMaxRequestAge(value);\r\n}"
}, {
	"Path": "org.restlet.ext.raml.RamlSpecificationRestlet.getRamlVersion",
	"Comment": "returns the version of raml used to generate this documentation.",
	"Method": "String getRamlVersion(){\r\n    return ramlVersion;\r\n}"
}, {
	"Path": "org.restlet.ext.xdb.internal.ChunkedOutputStream.close",
	"Comment": "closes this output stream for writing but does not close the wrappedstream.",
	"Method": "void close(){\r\n    if (!this.closed) {\r\n        writeChunk();\r\n        writeFinalChunk();\r\n        super.close();\r\n        this.closed = true;\r\n        this.destination.flush();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.Server.getActualPort",
	"Comment": "returns the actual server port after it has started. if an ephemeral portis used it will be returned, otherwise the fixed port will be provided.",
	"Method": "int getActualPort(){\r\n    return (getPort() == 0) ? getEphemeralPort() : getPort();\r\n}"
}, {
	"Path": "org.restlet.representation.Representation.hasKnownSize",
	"Comment": "indicates if the size of representation is known. it basically means thatits size 0 or superior.",
	"Method": "boolean hasKnownSize(){\r\n    return getSize() >= 0;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.ASTUtil.constructClass",
	"Comment": "returns the top class name in the hierarchy represented by the symtabast.",
	"Method": "String constructClass(SymTabAST tree){\r\n    String fullName = constructDottedName(tree);\r\n    return fullName.substring(fullName.lastIndexOf(\".\") + 1, fullName.length());\r\n}"
}, {
	"Path": "org.restlet.ext.jackson.JacksonRepresentation.createCsvSchema",
	"Comment": "creates a jackson csv schema based on a mapper and the current objectclass.",
	"Method": "CsvSchema createCsvSchema(CsvMapper csvMapper){\r\n    return csvMapper.schemaFor(getObjectClass());\r\n}"
}, {
	"Path": "org.restlet.data.Reference.setLastSegment",
	"Comment": "sets the last segment of the path. if no path is available, then itcreates one and adds a slash in front of the given last segmetn. note that no uri decoding is done by this method.",
	"Method": "void setLastSegment(String lastSegment){\r\n    String path = getPath();\r\n    if (path != null) {\r\n        int lastSlashIndex = path.lastIndexOf('/');\r\n        if (lastSlashIndex != -1) {\r\n            setPath(path.substring(0, lastSlashIndex + 1) + lastSegment);\r\n            return;\r\n        }\r\n    }\r\n    setPath('/' + lastSegment);\r\n}"
}, {
	"Path": "org.restlet.ext.jaxb.JaxbRepresentation.setXIncludeAware",
	"Comment": "indicates the desire for processing xinclude if found in thistype of xml representations. by default the value of this is set tofalse.",
	"Method": "void setXIncludeAware(boolean includeAware){\r\n    xIncludeAware = includeAware;\r\n}"
}, {
	"Path": "org.restlet.ext.servlet.ServletUtils.getResponse",
	"Comment": "returns the servlet response that was used to generate the given restletresponse.",
	"Method": "HttpServletResponse getResponse(Response response){\r\n    HttpServletResponse result = null;\r\n    if (response instanceof HttpResponse) {\r\n        Call call = ((HttpResponse) response).getHttpCall();\r\n        if (call instanceof ServletCall) {\r\n            result = ((ServletCall) call).getResponse();\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.service.MetadataService.getAllLanguageExtensionNames",
	"Comment": "return the ordered list of extension names mapped to languages.",
	"Method": "List<String> getAllLanguageExtensionNames(){\r\n    List<String> result = new ArrayList<String>();\r\n    for (MetadataExtension mapping : this.mappings) {\r\n        if ((mapping.getMetadata() instanceof Language) && !result.contains(mapping.getName())) {\r\n            result.add(mapping.getName());\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.data.Reference.encodeInvalidCharacters",
	"Comment": "checks if all characters are valid and encodes invalid characters ifnecessary.",
	"Method": "String encodeInvalidCharacters(String uriRef){\r\n    String result = uriRef;\r\n    if (uriRef != null) {\r\n        boolean valid = true;\r\n        for (int i = 0; valid && (i < uriRef.length()); i++) {\r\n            if (!isValid(uriRef.charAt(i))) {\r\n                valid = false;\r\n                Context.getCurrentLogger().fine(\"Invalid character detected in URI reference at index '\" + i + \"': \\\"\" + uriRef.charAt(i) + \"\\\". It will be automatically encoded.\");\r\n            } else if ((uriRef.charAt(i) == '%') && (i > uriRef.length() - 2)) {\r\n                valid = false;\r\n                Context.getCurrentLogger().fine(\"Invalid percent encoding detected in URI reference at index '\" + i + \"': \\\"\" + uriRef.charAt(i) + \"\\\". It will be automatically encoded.\");\r\n            }\r\n        }\r\n        if (!valid) {\r\n            StringBuilder sb = new StringBuilder();\r\n            for (int i = 0; (i < uriRef.length()); i++) {\r\n                if (isValid(uriRef.charAt(i))) {\r\n                    if ((uriRef.charAt(i) == '%') && (i > uriRef.length() - 2)) {\r\n                        sb.append(\"%\");\r\n                    } else {\r\n                        sb.append(uriRef.charAt(i));\r\n                    }\r\n                } else {\r\n                    sb.append(encode(String.valueOf(uriRef.charAt(i))));\r\n                }\r\n            }\r\n            result = sb.toString();\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.connector.NetServerHelper.getMaxThreadIdleTimeMs",
	"Comment": "returns the time for an idle thread to wait for an operation before beingcollected.",
	"Method": "int getMaxThreadIdleTimeMs(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"maxThreadIdleTimeMs\", \"300000\"));\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.AwsAuthenticator.getWrappedVerifier",
	"Comment": "returns the secret verifier that will be wrapped by the real verifiersupporting all the http aws verifications.",
	"Method": "LocalVerifier getWrappedVerifier(){\r\n    return getVerifier().getWrappedVerifier();\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.core.CallContext.getBaseUri",
	"Comment": "get the base uri of the application. uris of resource beans are allrelative to this base uri.",
	"Method": "URI getBaseUri(){\r\n    try {\r\n        return new URI(getBaseUriStr());\r\n    } catch (URISyntaxException e) {\r\n        throw wrapUriSyntaxExc(e, unexpectedLogger, \"Could not create URI\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.spring.SpringComponent.setClient",
	"Comment": "adds a client to the list of connectors. the value can be either aprotocol name, a protocol instance or a client instance.",
	"Method": "void setClient(Object clientInfo){\r\n    final List<Object> clients = new ArrayList<Object>();\r\n    clients.add(clientInfo);\r\n    setClientsList(clients);\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.swagger.v2_0.SwaggerTypes.toDefinitionPrimitiveType",
	"Comment": "converts swagger primitive types to java types. to be used only for query parameters,headers and path variables.",
	"Method": "String toDefinitionPrimitiveType(SwaggerTypeFormat dataType){\r\n    if (\"string\".equals(dataType.getType())) {\r\n        if (\"date\".equals(dataType.getFormat())) {\r\n            return \"date\";\r\n        } else if (\"byte\".equals(dataType.getFormat())) {\r\n            return \"byte\";\r\n        } else {\r\n            return \"string\";\r\n        }\r\n    } else if (\"integer\".equals(dataType.getType())) {\r\n        if (\"int64\".equals(dataType.getFormat())) {\r\n            return \"long\";\r\n        } else {\r\n            return \"integer\";\r\n        }\r\n    } else if (\"number\".equals(dataType.getType())) {\r\n        if (\"float\".equals(dataType.getFormat())) {\r\n            return \"Float\";\r\n        } else {\r\n            return \"double\";\r\n        }\r\n    } else if (\"boolean\".equals(dataType.getType())) {\r\n        return \"boolean\";\r\n    } else {\r\n        if (\"array\".equals(dataType.getType())) {\r\n            return dataType.getItems().getType();\r\n        }\r\n        return dataType.getType();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.test.engine.connector.ChunkedEncodingPutTestCase.createChunkedRepresentation",
	"Comment": "returns a stringrepresentation which size depends on the given argument.",
	"Method": "Representation createChunkedRepresentation(int size){\r\n    StringBuilder builder = new StringBuilder();\r\n    for (int i = 0; i < size; i++) {\r\n        builder.append(\"a\");\r\n    }\r\n    Representation rep = new StringRepresentation(builder.toString(), MediaType.TEXT_PLAIN);\r\n    rep.setSize(Representation.UNKNOWN_SIZE);\r\n    return rep;\r\n}"
}, {
	"Path": "org.restlet.ext.jackson.JacksonRepresentation.setExpandingEntityRefs",
	"Comment": "indicates if the parser will expand entity reference nodes. by defaultthe value of this is set to true.",
	"Method": "void setExpandingEntityRefs(boolean expandEntityRefs){\r\n    this.expandingEntityRefs = expandEntityRefs;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.Mapping.getValueAttributeName",
	"Comment": "returns the name of the attribute that stores the value to set, ifpertinent, and null otherwise.",
	"Method": "String getValueAttributeName(){\r\n    String result = null;\r\n    if (isAttributeValue()) {\r\n        int index = valuePath.lastIndexOf(\"/\");\r\n        result = valuePath.substring(index + 2, valuePath.length());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.data.MediaType.valueOf",
	"Comment": "returns the media type associated to a name. if an existing constantexists then it is returned, otherwise a new instance is created.",
	"Method": "MediaType valueOf(String name){\r\n    MediaType result = null;\r\n    if (!StringUtils.isNullOrEmpty(name)) {\r\n        result = getTypes().get(name);\r\n        if (result == null) {\r\n            result = new MediaType(name);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.swagger.v2_0.Swagger2Reader.fillRwadefQueryParameter",
	"Comment": "fills the given rwadef query parameter information from the given swagger query parameter.",
	"Method": "void fillRwadefQueryParameter(org.restlet.ext.apispark.internal.model.QueryParameter queryParameter,QueryParameter swaggerQueryParameter){\r\n    queryParameter.setAllowMultiple(true);\r\n    queryParameter.setDefaultValue(swaggerQueryParameter.getDefaultValue());\r\n    queryParameter.setDescription(swaggerQueryParameter.getDescription());\r\n    queryParameter.setEnumeration(swaggerQueryParameter.getEnum());\r\n    queryParameter.setName(swaggerQueryParameter.getName());\r\n    queryParameter.setRequired(swaggerQueryParameter.getRequired());\r\n    queryParameter.setSeparator(SwaggerUtils.getSeparator(swaggerQueryParameter.getCollectionFormat()));\r\n    SwaggerTypeFormat swaggerTypeFormat = new SwaggerTypeFormat(swaggerQueryParameter.getType(), swaggerQueryParameter.getFormat(), swaggerQueryParameter.getItems());\r\n    queryParameter.setType(SwaggerTypes.toDefinitionPrimitiveType(swaggerTypeFormat));\r\n}"
}, {
	"Path": "org.restlet.ext.atom.EntryReader.startContent",
	"Comment": "called when a new content element has been detected in the atom document.",
	"Method": "void startContent(Content content){\r\n    if (this.entryReader != null) {\r\n        this.entryReader.startContent(content);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.HttpClientHelper.getConnectTimeout",
	"Comment": "the max time in milliseconds a connection can take to connect todestinations. defaults to 15000.",
	"Method": "long getConnectTimeout(){\r\n    return Long.parseLong(getHelpedParameters().getFirstValue(\"connectTimeout\", \"15000\"));\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.ParameterInfo.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    final AttributesImpl attributes = new AttributesImpl();\r\n    if ((getDefaultValue() != null) && !getDefaultValue().equals(\"\")) {\r\n        attributes.addAttribute(\"\", \"default\", null, \"xs:string\", getDefaultValue());\r\n    }\r\n    if ((getFixed() != null) && !getFixed().equals(\"\")) {\r\n        attributes.addAttribute(\"\", \"fixed\", null, \"xs:string\", getFixed());\r\n    }\r\n    if ((getIdentifier() != null) && !getIdentifier().equals(\"\")) {\r\n        attributes.addAttribute(\"\", \"id\", null, \"xs:ID\", getIdentifier());\r\n    }\r\n    if ((getPath() != null) && !getPath().equals(\"\")) {\r\n        attributes.addAttribute(\"\", \"path\", null, \"xs:string\", getPath());\r\n    }\r\n    if (getStyle() != null) {\r\n        attributes.addAttribute(\"\", \"style\", null, \"xs:string\", getStyle().toString());\r\n    }\r\n    if ((getName() != null) && !getName().equals(\"\")) {\r\n        attributes.addAttribute(\"\", \"name\", null, \"xs:NMTOKEN\", getName());\r\n    }\r\n    if ((getType() != null) && !getType().equals(\"\")) {\r\n        attributes.addAttribute(\"\", \"type\", null, \"xs:QName\", getType());\r\n    }\r\n    if (isRepeating()) {\r\n        attributes.addAttribute(\"\", \"repeating\", null, \"xs:boolean\", \"true\");\r\n    }\r\n    if (isRequired()) {\r\n        attributes.addAttribute(\"\", \"required\", null, \"xs:boolean\", \"true\");\r\n    }\r\n    if ((getLink() == null) && getDocumentations().isEmpty() && getOptions().isEmpty()) {\r\n        writer.emptyElement(APP_NAMESPACE, \"param\", null, attributes);\r\n    } else {\r\n        writer.startElement(APP_NAMESPACE, \"param\", null, attributes);\r\n        if (getLink() != null) {\r\n            getLink().writeElement(writer);\r\n        }\r\n        for (final DocumentationInfo documentationInfo : getDocumentations()) {\r\n            documentationInfo.writeElement(writer);\r\n        }\r\n        for (final OptionInfo optionInfo : getOptions()) {\r\n            optionInfo.writeElement(writer);\r\n        }\r\n        writer.endElement(APP_NAMESPACE, \"param\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.fromEdm",
	"Comment": "converts the string representation of the target wcf type to itscorresponding value.",
	"Method": "Object fromEdm(String value,String adoNetType){\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    Object result = null;\r\n    try {\r\n        if (adoNetType.endsWith(\"Binary\")) {\r\n            result = Base64.decode(value);\r\n        } else if (adoNetType.endsWith(\"Boolean\")) {\r\n            result = Boolean.valueOf(value);\r\n        } else if (adoNetType.endsWith(\"DateTime\")) {\r\n            result = DateUtils.parse(value, dateTimeFormats);\r\n        } else if (adoNetType.endsWith(\"DateTimeOffset\")) {\r\n            result = DateUtils.parse(value, dateTimeFormats);\r\n        } else if (adoNetType.endsWith(\"Time\")) {\r\n            result = timeFormat.parseObject(value);\r\n        } else if (adoNetType.endsWith(\"Decimal\")) {\r\n            result = decimalFormat.parseObject(value);\r\n        } else if (adoNetType.endsWith(\"Single\")) {\r\n            result = singleFormat.parseObject(value);\r\n        } else if (adoNetType.endsWith(\"Double\")) {\r\n            result = doubleFormat.parseObject(value);\r\n        } else if (adoNetType.endsWith(\"Guid\")) {\r\n            result = value;\r\n        } else if (adoNetType.endsWith(\"Int16\")) {\r\n            result = Short.valueOf(value);\r\n        } else if (adoNetType.endsWith(\"Int32\")) {\r\n            result = Integer.valueOf(value);\r\n        } else if (adoNetType.endsWith(\"Int64\")) {\r\n            result = Long.valueOf(value);\r\n        } else if (adoNetType.endsWith(\"Byte\")) {\r\n            result = Byte.valueOf(value);\r\n        } else if (adoNetType.endsWith(\"String\")) {\r\n            result = value;\r\n        }\r\n    } catch (Exception e) {\r\n        Context.getCurrentLogger().warning(\"Cannot convert \" + value + \" from this EDM type \" + adoNetType);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.routing.Router.getDefaultMatchingQuery",
	"Comment": "returns the default setting for whether the routing should be done onuris with or without taking into account query string. by default, itreturns false.",
	"Method": "boolean getDefaultMatchingQuery(){\r\n    return this.defaultMatchingQuery;\r\n}"
}, {
	"Path": "org.restlet.engine.util.ImmutableDate.setMonth",
	"Comment": "as an immutabledate is immutable, this method throws anunsupportedoperationexception exception.",
	"Method": "void setMonth(int arg0){\r\n    throw new UnsupportedOperationException(\"ImmutableDate is immutable\");\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createDepartmentQuery",
	"Comment": "creates a query for department entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Department> createDepartmentQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Department.class);\r\n}"
}, {
	"Path": "org.restlet.routing.TemplateRoute.setMatchingQuery",
	"Comment": "sets whether the matching should be done on the uri with or without querystring.",
	"Method": "void setMatchingQuery(boolean matchingQuery){\r\n    this.matchingQuery = matchingQuery;\r\n}"
}, {
	"Path": "org.restlet.engine.Engine.discoverAuthenticators",
	"Comment": "discovers the authenticator helpers and register the default helpers.",
	"Method": "void discoverAuthenticators(){\r\n    registerHelpers(DESCRIPTOR_AUTHENTICATOR_PATH, getRegisteredAuthenticators(), null);\r\n    registerDefaultAuthentications();\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getUserInfo",
	"Comment": "returns the user info component for server based hierarchicalidentifiers.note that no uri decoding is done by this method.",
	"Method": "String getUserInfo(String getUserInfo,boolean decode){\r\n    return decode ? decode(getUserInfo()) : getUserInfo();\r\n}"
}, {
	"Path": "org.restlet.util.WrapperList.removeAll",
	"Comment": "removes from this list all the elements that are contained in thespecified collection.",
	"Method": "boolean removeAll(Collection<?> elements){\r\n    return getDelegate().removeAll(elements);\r\n}"
}, {
	"Path": "org.restlet.security.MethodAuthorizer.authorize",
	"Comment": "authorizes the request only if its method is one of the authorizedmethods.",
	"Method": "boolean authorize(Request request,Response response){\r\n    boolean authorized = false;\r\n    if (request.getClientInfo().isAuthenticated()) {\r\n        for (Method authenticatedMethod : getAuthenticatedMethods()) {\r\n            authorized = authorized || request.getMethod().equals(authenticatedMethod);\r\n        }\r\n    } else {\r\n        for (Method authorizedMethod : getAnonymousMethods()) {\r\n            authorized = authorized || request.getMethod().equals(authorizedMethod);\r\n        }\r\n    }\r\n    return authorized;\r\n}"
}, {
	"Path": "org.restlet.ext.swagger.JaxRsApplicationSwagger2SpecificationRestlet.getSwagger",
	"Comment": "returns the representation of the whole resource listing of theapplication.",
	"Method": "Representation getSwagger(){\r\n    Swagger swagger = Swagger2Writer.getSwagger(getDefinition());\r\n    swagger.setSwagger(swaggerVersion);\r\n    JacksonRepresentation<Swagger> swaggerJacksonRepresentation = new JacksonRepresentation(swagger);\r\n    ObjectMapper objectMapper = swaggerJacksonRepresentation.getObjectMapper();\r\n    objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\r\n    return swaggerJacksonRepresentation;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.BaseHelper.getOutboundBufferSize",
	"Comment": "returns the size of the content buffer for sending responses.",
	"Method": "int getOutboundBufferSize(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"outboundBufferSize\", Integer.toString(32 * 1024)));\r\n}"
}, {
	"Path": "org.restlet.service.TaskService.getCorePoolSize",
	"Comment": "returns the core pool size defining the maximum number of threads.",
	"Method": "int getCorePoolSize(){\r\n    return corePoolSize;\r\n}"
}, {
	"Path": "org.restlet.service.TunnelService.isMethodTunnel",
	"Comment": "indicates if the method name can be tunneled. returns true by default.",
	"Method": "boolean isMethodTunnel(){\r\n    return this.methodTunnel;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.raml.RamlTranslator.getRepresentationByName",
	"Comment": "returns the representation given its name from the given list ofrepresentations.",
	"Method": "Representation getRepresentationByName(List<Representation> representations,String name){\r\n    if (name != null) {\r\n        for (Representation repr : representations) {\r\n            if (name.equals(repr.getName())) {\r\n                return repr;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.engine.local.DirectoryServerResource.preventUpperDirectoryAccess",
	"Comment": "prevent the client from accessing resources in upper directories",
	"Method": "void preventUpperDirectoryAccess(){\r\n    String targetUriPath = new Reference(Reference.decode(targetUri)).normalize().toString();\r\n    if (!targetUriPath.startsWith(directory.getRootRef().toString())) {\r\n        throw new ResourceException(Status.CLIENT_ERROR_FORBIDDEN);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.security.MapVerifier.setLocalSecrets",
	"Comment": "sets the modifiable map of local secrets. this method clears the currentmap and puts all entries in the parameter map.",
	"Method": "void setLocalSecrets(Map<String, char[]> localSecrets){\r\n    synchronized (getLocalSecrets()) {\r\n        if (localSecrets != getLocalSecrets()) {\r\n            getLocalSecrets().clear();\r\n            if (localSecrets != null) {\r\n                getLocalSecrets().putAll(localSecrets);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getPath",
	"Comment": "returns the optionnally decoded path component. if not path is availableit returns null.",
	"Method": "String getPath(String getPath,boolean decode){\r\n    return decode ? decode(getPath()) : getPath();\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.core.CallContext.isSecure",
	"Comment": "returns a boolean indicating whether this request was made using a securechannel, such as https.",
	"Method": "boolean isSecure(){\r\n    return this.request.isConfidential();\r\n}"
}, {
	"Path": "org.restlet.engine.connector.HttpClientHelper.isUseCaches",
	"Comment": "indicates if the protocol is allowed to use caching whenever it can.",
	"Method": "boolean isUseCaches(){\r\n    return Boolean.parseBoolean(getHelpedParameters().getFirstValue(\"useCaches\", \"false\"));\r\n}"
}, {
	"Path": "org.restlet.service.TunnelService.setEncodingParameter",
	"Comment": "sets the name of the parameter containing the accepted encoding.",
	"Method": "void setEncodingParameter(String parameterName){\r\n    this.encodingParameter = parameterName;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.swagger.v1_2.SwaggerWriter.fillResourceListingApis",
	"Comment": "fills swagger resource listing main attributes from restlet web apidefinition",
	"Method": "void fillResourceListingApis(Definition definition,ResourceListing listing){\r\n    Contract contract = definition.getContract();\r\n    boolean allResources = contract.getSections().isEmpty();\r\n    List<String> addedApis = new ArrayList();\r\n    if (definition.getContract() != null && contract.getResources() != null) {\r\n        listing.setApis(new ArrayList<ResourceListingApi>());\r\n        for (Resource resource : contract.getResources()) {\r\n            if (allResources) {\r\n                ResourceListingApi rd = new ResourceListingApi();\r\n                rd.setDescription(resource.getDescription());\r\n                rd.setPath(ReflectUtils.getFirstSegment(resource.getResourcePath()));\r\n                if (!addedApis.contains(rd.getPath())) {\r\n                    addedApis.add(rd.getPath());\r\n                    listing.getApis().add(rd);\r\n                }\r\n            } else {\r\n                for (String sectionName : resource.getSections()) {\r\n                    Section section = contract.getSection(sectionName);\r\n                    ResourceListingApi rd = new ResourceListingApi();\r\n                    rd.setDescription(section.getDescription());\r\n                    rd.setPath(\"/\" + sectionName);\r\n                    if (!addedApis.contains(rd.getPath())) {\r\n                        addedApis.add(rd.getPath());\r\n                        listing.getApis().add(rd);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Collections.sort(listing.getApis(), new Comparator<ResourceListingApi>() {\r\n        @Override\r\n        public int compare(ResourceListingApi o1, ResourceListingApi o2) {\r\n            return o1.getPath().compareTo(o2.getPath());\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.swagger.v1_2.SwaggerWriter.fillResourceListingApis",
	"Comment": "fills swagger resource listing main attributes from restlet web apidefinition",
	"Method": "void fillResourceListingApis(Definition definition,ResourceListing listing){\r\n    return o1.getPath().compareTo(o2.getPath());\r\n}"
}, {
	"Path": "org.restlet.service.MetadataService.getAllEncodingExtensionNames",
	"Comment": "return the ordered list of extension names mapped to encodings.",
	"Method": "List<String> getAllEncodingExtensionNames(){\r\n    List<String> result = new ArrayList<String>();\r\n    for (MetadataExtension mapping : this.mappings) {\r\n        if ((mapping.getMetadata() instanceof Encoding) && !result.contains(mapping.getName())) {\r\n            result.add(mapping.getName());\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.emf.EmfRepresentation.getLineWidth",
	"Comment": "returns the maximum number of characters per line. defaults to 80.",
	"Method": "int getLineWidth(){\r\n    return lineWidth;\r\n}"
}, {
	"Path": "org.restlet.data.Reference.isParent",
	"Comment": "indicates if the reference is a parent of the hierarchical childreference.",
	"Method": "boolean isParent(Reference childRef){\r\n    boolean result = false;\r\n    if ((childRef != null) && (childRef.isHierarchical())) {\r\n        result = childRef.toString(false, false).startsWith(toString(false, false));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlRepresentation.isXIncludeAware",
	"Comment": "indicates the desire for processing xinclude if found in thistype of xml representations. by default the value of this is set tofalse.",
	"Method": "boolean isXIncludeAware(){\r\n    return xIncludeAware;\r\n}"
}, {
	"Path": "org.restlet.ext.emf.EmfConverter.isCompatible",
	"Comment": "indicates if the given variant is compatible with the media typessupported by this converter.",
	"Method": "boolean isCompatible(Variant variant){\r\n    return (variant != null) && (VARIANT_APPLICATION_ALL_XML.isCompatible(variant) || VARIANT_APPLICATION_XML.isCompatible(variant) || VARIANT_APPLICATION_XMI.isCompatible(variant) || VARIANT_APPLICATION_ECORE.isCompatible(variant) || VARIANT_TEXT_HTML.isCompatible(variant) || VARIANT_TEXT_XML.isCompatible(variant));\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Entry.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    writer.startElement(ATOM_NAMESPACE, \"entry\");\r\n    if (getAuthors() != null) {\r\n        for (final Person person : getAuthors()) {\r\n            person.writeElement(writer, \"author\");\r\n        }\r\n    }\r\n    if (getCategories() != null) {\r\n        for (final Category category : getCategories()) {\r\n            category.writeElement(writer);\r\n        }\r\n    }\r\n    if (getContent() != null) {\r\n        getContent().writeElement(writer);\r\n    }\r\n    if (getContributors() != null) {\r\n        for (final Person person : getContributors()) {\r\n            person.writeElement(writer, \"contributor\");\r\n        }\r\n    }\r\n    if (getId() != null) {\r\n        writer.dataElement(ATOM_NAMESPACE, \"id\", getId());\r\n    }\r\n    if (getLinks() != null) {\r\n        for (final Link link : getLinks()) {\r\n            link.writeElement(writer);\r\n        }\r\n    }\r\n    if (getPublished() != null) {\r\n        Text.writeElement(writer, getPublished(), ATOM_NAMESPACE, \"published\");\r\n    }\r\n    if (getRights() != null) {\r\n        getRights().writeElement(writer, \"rights\");\r\n    }\r\n    if (getSource() != null) {\r\n        getSource().writeElement(writer);\r\n    }\r\n    if (getSummary() != null) {\r\n        writer.dataElement(ATOM_NAMESPACE, \"summary\", getSummary());\r\n    }\r\n    if (getTitle() != null) {\r\n        getTitle().writeElement(writer, \"title\");\r\n    }\r\n    if (getUpdated() != null) {\r\n        Text.writeElement(writer, getUpdated(), ATOM_NAMESPACE, \"updated\");\r\n    }\r\n    writeInlineContent(writer);\r\n    writer.endElement(ATOM_NAMESPACE, \"entry\");\r\n}"
}, {
	"Path": "org.restlet.engine.header.PreferenceReader.extractQuality",
	"Comment": "extract the quality value. if the value is not found, 1 is returned.",
	"Method": "float extractQuality(Series<Parameter> parameters){\r\n    float result = 1F;\r\n    boolean found = false;\r\n    if (parameters != null) {\r\n        Parameter param = null;\r\n        for (final Iterator<Parameter> iter = parameters.iterator(); !found && iter.hasNext(); ) {\r\n            param = iter.next();\r\n            if (param.getName().equals(\"q\")) {\r\n                result = readQuality(param.getValue());\r\n                found = true;\r\n                iter.remove();\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.ConnectionHelper.checkout",
	"Comment": "checks out a connection associated to the given socket from the pool.",
	"Method": "Connection<T> checkout(SocketChannel socketChannel,ConnectionController controller,InetSocketAddress socketAddress){\r\n    Connection<T> result = null;\r\n    if (isPooledConnection()) {\r\n        result = getConnectionPool().checkout();\r\n        result.reuse(socketChannel, controller, socketAddress);\r\n    } else {\r\n        result = createConnection(socketChannel, controller, socketAddress);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.TransformRepresentation.getSaxSource",
	"Comment": "returns the sax source associated to the source representation.",
	"Method": "SAXSource getSaxSource(){\r\n    return toSaxSource(getSourceRepresentation());\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.Metadata.getAssociation",
	"Comment": "returns the association object that corresponds to the given property ofthe given entity type.",
	"Method": "AssociationEnd getAssociation(EntityType type,String propertyName){\r\n    AssociationEnd result = null;\r\n    for (NavigationProperty association : type.getAssociations()) {\r\n        if (association.getNormalizedName().equals(propertyName)) {\r\n            result = association.getToRole();\r\n            break;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.BaseHelper.isWorkerServiceOverloaded",
	"Comment": "indicates if the worker service is busy. this state is detected bychecking if the number of active task running is superior or equal to themaximum pool size.",
	"Method": "boolean isWorkerServiceOverloaded(){\r\n    return (getWorkerService() != null) && getWorkerService().getActiveCount() >= getLowThreads();\r\n}"
}, {
	"Path": "org.restlet.engine.header.ContentType.readCharacterSet",
	"Comment": "parses the given content type header and returns the character set.",
	"Method": "CharacterSet readCharacterSet(String contentType){\r\n    return new ContentType(contentType).getCharacterSet();\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.classfile.MethodDefinition.hasReference",
	"Comment": "determine whether this method definition has a reference from a class ora superclass.",
	"Method": "boolean hasReference(JavaClass aJavaClass){\r\n    final Iterator it = getReferences().iterator();\r\n    while (it.hasNext()) {\r\n        final InvokeReference invokeRef = (InvokeReference) it.next();\r\n        final String invokeClassName = invokeRef.getClassName();\r\n        if (Repository.instanceOf(aJavaClass, invokeClassName)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.Transformer.getResultCharacterSet",
	"Comment": "returns the character set of the result representation. the default valueis null.",
	"Method": "CharacterSet getResultCharacterSet(){\r\n    return this.resultCharacterSet;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.controller.ConnectionController.onWokeup",
	"Comment": "invoked when one of the connections needs to wake up the controller.",
	"Method": "void onWokeup(SelectionRegistration selectionRegistration){\r\n    wakeup();\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getParentRef",
	"Comment": "returns the parent reference of a hierarchical reference. the last slashof the path will be considered as the end of the parent path.",
	"Method": "Reference getParentRef(){\r\n    Reference result = null;\r\n    if (isHierarchical()) {\r\n        String parentRef = null;\r\n        String path = getPath();\r\n        if (!path.equals(\"/\") && !path.equals(\"\")) {\r\n            if (path.endsWith(\"/\")) {\r\n                path = path.substring(0, path.length() - 1);\r\n            }\r\n            if (isAbsolute()) {\r\n                parentRef = getHostIdentifier() + path.substring(0, path.lastIndexOf('/') + 1);\r\n            } else {\r\n                parentRef = path.substring(0, path.lastIndexOf('/') + 1);\r\n            }\r\n        } else {\r\n            parentRef = this.internalRef;\r\n        }\r\n        result = new Reference(parentRef);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.DomRepresentation.getDocument",
	"Comment": "returns the wrapped dom document. if no document is defined yet, itattempts to parse the xml representation eventually given at constructiontime. otherwise, it just creates a new document.",
	"Method": "Document getDocument(){\r\n    if (this.document == null) {\r\n        if (this.xmlRepresentation != null) {\r\n            try {\r\n                this.document = getDocumentBuilder().parse(getInputSource());\r\n            } catch (SAXException se) {\r\n                throw new IOException(\"Couldn't read the XML representation. \" + se.getMessage());\r\n            }\r\n        } else {\r\n            this.document = getDocumentBuilder().newDocument();\r\n        }\r\n    }\r\n    return this.document;\r\n}"
}, {
	"Path": "org.restlet.Context.getDefaultVerifier",
	"Comment": "returns a verifier that can check the validity of the credentialsassociated to a request.",
	"Method": "org.restlet.security.Verifier getDefaultVerifier(){\r\n    return this.defaultVerifier;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.introspection.helper.SwaggerAnnotationIntrospectionHelper.getAnnotation",
	"Comment": "look for expected annotation on the class and its interfaces",
	"Method": "T getAnnotation(Class<?> resourceClass,Class<T> annotationClass){\r\n    T annotation = resourceClass.getAnnotation(annotationClass);\r\n    if (annotation == null) {\r\n        for (Class<?> i : resourceClass.getInterfaces()) {\r\n            annotation = i.getAnnotation(annotationClass);\r\n            if (annotation != null) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return annotation;\r\n}"
}, {
	"Path": "org.restlet.test.ext.jaxrs.services.tests.CarTest.testEngine",
	"Comment": "this tests, if a sub resource class of a sub resource class of a rootresource class is accessable.",
	"Method": "void testEngine(){\r\n    final Response response = get(\"4711/engine\");\r\n    sysOutEntityIfError(response);\r\n    assertEquals(Status.SUCCESS_OK, response.getStatus());\r\n    final Representation entity = response.getEntity();\r\n    assertEqualMediaType(MediaType.TEXT_PLAIN, entity.getMediaType());\r\n    assertEquals(EngineResource.getPlainRepr(4711), entity.getText());\r\n}"
}, {
	"Path": "org.restlet.routing.VirtualHost.setCurrent",
	"Comment": "sets the virtual host code associated with the current thread.",
	"Method": "void setCurrent(Integer code){\r\n    CURRENT.set(code);\r\n}"
}, {
	"Path": "org.restlet.ext.sdc.internal.SdcClientCall.getRequestEntityStream",
	"Comment": "returns the request entity stream convertible to a byte array.",
	"Method": "OutputStream getRequestEntityStream(){\r\n    return requestEntityStream;\r\n}"
}, {
	"Path": "org.restlet.engine.component.HostRoute.beforeHandle",
	"Comment": "allows filtering before processing by the next restlet. set the basereference.",
	"Method": "int beforeHandle(Request request,Response response){\r\n    if (request.getHostRef() == null) {\r\n        request.getResourceRef().setBaseRef(request.getResourceRef().getHostIdentifier());\r\n    } else {\r\n        request.getResourceRef().setBaseRef(request.getHostRef());\r\n    }\r\n    if (request.isLoggable() && getLogger().isLoggable(Level.FINE)) {\r\n        getLogger().fine(\"Base URI: \\\"\" + request.getResourceRef().getBaseRef() + \"\\\". Remaining part: \\\"\" + request.getResourceRef().getRemainingPart() + \"\\\"\");\r\n    }\r\n    return CONTINUE;\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.DefaultSslContextFactory.createSslContext",
	"Comment": "creates a configured and initialized sslcontext from the values set viathe various setters of this class. if keystorepath,keystoreprovider, keystoretype are allnull, the sslcontext will be initialized with anull array of keymanagers. similarly, iftruststorepath, truststoreprovider,truststoretype are all null, anull array of trustmanagers will be used.",
	"Method": "javax.net.ssl.SSLContext createSslContext(){\r\n    javax.net.ssl.SSLContext result = null;\r\n    javax.net.ssl.KeyManagerFactory kmf = null;\r\n    if ((this.keyStorePath != null) || (this.keyStoreProvider != null) || (this.keyStoreType != null)) {\r\n        KeyStore keyStore = (this.keyStoreProvider != null) ? KeyStore.getInstance((this.keyStoreType != null) ? this.keyStoreType : KeyStore.getDefaultType(), this.keyStoreProvider) : KeyStore.getInstance((this.keyStoreType != null) ? this.keyStoreType : KeyStore.getDefaultType());\r\n        FileInputStream keyStoreInputStream = null;\r\n        try {\r\n            keyStoreInputStream = ((this.keyStorePath != null) && (!\"NONE\".equals(this.keyStorePath))) ? new FileInputStream(this.keyStorePath) : null;\r\n            keyStore.load(keyStoreInputStream, this.keyStorePassword);\r\n        } finally {\r\n            if (keyStoreInputStream != null) {\r\n                keyStoreInputStream.close();\r\n            }\r\n        }\r\n        kmf = javax.net.ssl.KeyManagerFactory.getInstance(this.keyManagerAlgorithm);\r\n        kmf.init(keyStore, this.keyStoreKeyPassword);\r\n    }\r\n    javax.net.ssl.TrustManagerFactory tmf = null;\r\n    if ((this.trustStorePath != null) || (this.trustStoreProvider != null) || (this.trustStoreType != null)) {\r\n        KeyStore trustStore = (this.trustStoreProvider != null) ? KeyStore.getInstance((this.trustStoreType != null) ? this.trustStoreType : KeyStore.getDefaultType(), this.trustStoreProvider) : KeyStore.getInstance((this.trustStoreType != null) ? this.trustStoreType : KeyStore.getDefaultType());\r\n        FileInputStream trustStoreInputStream = null;\r\n        try {\r\n            trustStoreInputStream = ((this.trustStorePath != null) && (!\"NONE\".equals(this.trustStorePath))) ? new FileInputStream(this.trustStorePath) : null;\r\n            trustStore.load(trustStoreInputStream, this.trustStorePassword);\r\n        } finally {\r\n            if (trustStoreInputStream != null) {\r\n                trustStoreInputStream.close();\r\n            }\r\n        }\r\n        tmf = javax.net.ssl.TrustManagerFactory.getInstance(this.trustManagerAlgorithm);\r\n        tmf.init(trustStore);\r\n    }\r\n    javax.net.ssl.SSLContext sslContext = javax.net.ssl.SSLContext.getInstance(this.protocol);\r\n    SecureRandom sr = null;\r\n    if (this.secureRandomAlgorithm != null) {\r\n        sr = SecureRandom.getInstance(this.secureRandomAlgorithm);\r\n    }\r\n    sslContext.init(kmf != null ? kmf.getKeyManagers() : null, tmf != null ? tmf.getTrustManagers() : null, sr);\r\n    result = createWrapper(sslContext);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jibx.JibxConverter.isCompatible",
	"Comment": "indicates if the given variant is compatible with the media typessupported by this converter.",
	"Method": "boolean isCompatible(MediaType mediaType,boolean isCompatible,Variant variant){\r\n    return (variant != null) && (VARIANT_APPLICATION_ALL_XML.isCompatible(variant) || VARIANT_APPLICATION_XML.isCompatible(variant) || VARIANT_TEXT_XML.isCompatible(variant));\r\n}"
}, {
	"Path": "org.restlet.engine.local.FileClientHelper.updateFileExtension",
	"Comment": "complete the given file name with the extension corresponding to thegiven metadata.",
	"Method": "void updateFileExtension(StringBuilder fileName,Metadata metadata){\r\n    boolean defaultMetadata = true;\r\n    if (getMetadataService() != null) {\r\n        if (metadata instanceof Language) {\r\n            Language language = (Language) metadata;\r\n            defaultMetadata = language.equals(getMetadataService().getDefaultLanguage());\r\n        } else if (metadata instanceof MediaType) {\r\n            MediaType mediaType = (MediaType) metadata;\r\n            defaultMetadata = mediaType.equals(getMetadataService().getDefaultMediaType());\r\n        } else if (metadata instanceof CharacterSet) {\r\n            CharacterSet characterSet = (CharacterSet) metadata;\r\n            defaultMetadata = characterSet.equals(getMetadataService().getDefaultCharacterSet());\r\n        } else if (metadata instanceof Encoding) {\r\n            Encoding encoding = (Encoding) metadata;\r\n            defaultMetadata = encoding.equals(getMetadataService().getDefaultEncoding());\r\n        }\r\n    }\r\n    if (!defaultMetadata) {\r\n        String extension = getMetadataService().getExtension(metadata);\r\n        if (extension != null) {\r\n            fileName.append(\".\" + extension);\r\n        } else {\r\n            if (metadata.getParent() != null) {\r\n                updateFileExtension(fileName, metadata.getParent());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.Definition.getQualifiedName",
	"Comment": "returns the fully qualifed name of this defintion.the name ofthe parentscope and all of its parents are considered when constructingthis name.",
	"Method": "String getQualifiedName(){\r\n    String nameToUse = _name;\r\n    String result;\r\n    if (_name == null) {\r\n        nameToUse = \"~NO NAME~\";\r\n    }\r\n    if (getParentScope() != null && !(getParentScope() instanceof BaseScope)) {\r\n        result = getParentScope().getQualifiedName() + \".\" + nameToUse;\r\n    } else {\r\n        result = nameToUse;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.data.ChallengeResponse.setSecretAlgorithm",
	"Comment": "sets the digest algorithm name optionally applied on the user secret.",
	"Method": "void setSecretAlgorithm(String secretDigestAlgorithm){\r\n    this.secretAlgorithm = secretDigestAlgorithm;\r\n}"
}, {
	"Path": "org.restlet.engine.application.Decoder.beforeHandle",
	"Comment": "allows filtering before its handling by the target restlet. does nothingby default.",
	"Method": "int beforeHandle(Request request,Response response){\r\n    if (isDecodingRequest() && canDecode(request.getEntity())) {\r\n        request.setEntity(decode(request.getEntity()));\r\n    }\r\n    return CONTINUE;\r\n}"
}, {
	"Path": "org.restlet.util.ServerList.add",
	"Comment": "adds a new server connector in the map supporting the given protocol onthe specified ip address and port.",
	"Method": "Server add(Protocol protocol,Server add,Protocol protocol,int port,Server add,Protocol protocol,String address,int port,boolean add,Server server){\r\n    if (server.getContext() == null) {\r\n        server.setContext(getContext().createChildContext());\r\n    }\r\n    server.setNext(getNext());\r\n    return super.add(server);\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.Util.getOnlyMetadataName",
	"Comment": "returns the name of the only element of the list of the given metadata.returns null, if the list is empty or null.",
	"Method": "String getOnlyMetadataName(List<? extends Metadata> metadatas){\r\n    final Metadata metadata = getOnlyElement(metadatas);\r\n    if (metadata == null) {\r\n        return null;\r\n    }\r\n    return metadata.getName();\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.handleInbound",
	"Comment": "handles the inbound call. note that only synchronous calls are processed.",
	"Method": "Representation handleInbound(Response response){\r\n    if (response == null) {\r\n        return null;\r\n    }\r\n    if (response.getRequest().isSynchronous()) {\r\n        if (response.getStatus().isError()) {\r\n            doError(response.getStatus());\r\n            return null;\r\n        }\r\n        return response.getEntity();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Service.getValueEditRef",
	"Comment": "returns the reference used to edit the binary representation of the givenentity, if this is a media resource. it returns null otherwise.",
	"Method": "Reference getValueEditRef(Object entity){\r\n    if (entity != null) {\r\n        Metadata metadata = (Metadata) getMetadata();\r\n        EntityType type = metadata.getEntityType(entity.getClass());\r\n        if (type.isBlob() && type.getBlobValueEditRefProperty() != null) {\r\n            try {\r\n                return (Reference) ReflectUtils.invokeGetter(entity, type.getBlobValueEditRefProperty().getName());\r\n            } catch (Exception e) {\r\n                getLogger().warning(\"Cannot get the value of the property \" + type.getBlobValueEditRefProperty().getName() + \" on \" + entity);\r\n            }\r\n        } else {\r\n            getLogger().warning(\"This entity is not a media resource \" + entity);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.data.Reference.setHostPort",
	"Comment": "sets the optional port number for server based hierarchical identifiers.",
	"Method": "void setHostPort(Integer port){\r\n    final String authority = getAuthority();\r\n    if (authority != null) {\r\n        int indexUI = authority.indexOf('@');\r\n        int indexIPV6 = authority.indexOf(']');\r\n        int index = authority.indexOf(':', (indexIPV6 == -1) ? indexUI : indexIPV6);\r\n        String newPort = (port == null) ? \"\" : \":\" + port;\r\n        if (index != -1) {\r\n            setAuthority(authority.substring(0, index) + newPort);\r\n        } else {\r\n            setAuthority(authority + newPort);\r\n        }\r\n    } else {\r\n        throw new IllegalArgumentException(\"No authority defined, please define a host name first\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.converter.ConverterUtils.getVariants",
	"Comment": "returns the list of variants that can be converted from a given objectclass.",
	"Method": "List<VariantInfo> getVariants(Class<?> sourceClass,Variant targetVariant){\r\n    List<VariantInfo> result = null;\r\n    for (ConverterHelper ch : Engine.getInstance().getRegisteredConverters()) {\r\n        if (ch != null) {\r\n            try {\r\n                result = ch.addVariants(sourceClass, targetVariant, result);\r\n            } catch (IOException e) {\r\n                Context.getCurrentLogger().log(Level.FINE, \"Unable get the variants of the \" + ch + \" converter helper.\", e);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.CookieAuthenticator.isLoggingIn",
	"Comment": "indicates if the request is an attempt to log in and should beintercepted.",
	"Method": "boolean isLoggingIn(Request request,Response response){\r\n    return isInterceptingLogin() && getLoginPath().equals(request.getResourceRef().getRemainingPart(false, false)) && Method.POST.equals(request.getMethod());\r\n}"
}, {
	"Path": "org.restlet.ext.oauth.OAuthException.setErrorUri",
	"Comment": "sets the uri of the resource that gives more details about the error.",
	"Method": "void setErrorUri(String errorUri){\r\n    this.errorUri = errorUri;\r\n}"
}, {
	"Path": "org.restlet.engine.adapter.Call.setServerAddress",
	"Comment": "sets the response address.corresponds to the ip address of the responding server.",
	"Method": "void setServerAddress(String responseAddress){\r\n    this.serverAddress = responseAddress;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlRepresentation.getNode",
	"Comment": "evaluates an xpath expression as a dom node. if the evaluation fails,null will be returned.",
	"Method": "Node getNode(String expression){\r\n    return (Node) internalEval(expression, javax.xml.xpath.XPathConstants.NODE);\r\n}"
}, {
	"Path": "org.restlet.data.Status.getUri",
	"Comment": "returns the uri of the specification describing the status.",
	"Method": "String getUri(){\r\n    if (this.uri != null) {\r\n        return this.uri;\r\n    }\r\n    switch(this.code) {\r\n        case 100:\r\n            return BASE_HTTP + \"#sec10.1.1\";\r\n        case 101:\r\n            return BASE_HTTP + \"#sec10.1.2\";\r\n        case 102:\r\n            return BASE_WEBDAV + \"#STATUS_102\";\r\n        case 110:\r\n        case 111:\r\n        case 112:\r\n        case 113:\r\n        case 199:\r\n        case 214:\r\n        case 299:\r\n            return \"http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.46\";\r\n        case 200:\r\n            return BASE_HTTP + \"#sec10.2.1\";\r\n        case 201:\r\n            return BASE_HTTP + \"#sec10.2.2\";\r\n        case 202:\r\n            return BASE_HTTP + \"#sec10.2.3\";\r\n        case 203:\r\n            return BASE_HTTP + \"#sec10.2.4\";\r\n        case 204:\r\n            return BASE_HTTP + \"#sec10.2.5\";\r\n        case 205:\r\n            return BASE_HTTP + \"#sec10.2.6\";\r\n        case 206:\r\n            return BASE_HTTP + \"#sec10.2.7\";\r\n        case 207:\r\n            return BASE_WEBDAV + \"#STATUS_207\";\r\n        case 300:\r\n            return BASE_HTTP + \"#sec10.3.1\";\r\n        case 301:\r\n            return BASE_HTTP + \"#sec10.3.2\";\r\n        case 302:\r\n            return BASE_HTTP + \"#sec10.3.3\";\r\n        case 303:\r\n            return BASE_HTTP + \"#sec10.3.4\";\r\n        case 304:\r\n            return BASE_HTTP + \"#sec10.3.5\";\r\n        case 305:\r\n            return BASE_HTTP + \"#sec10.3.6\";\r\n        case 307:\r\n            return BASE_HTTP + \"#sec10.3.8\";\r\n        case 400:\r\n            return BASE_HTTP + \"#sec10.4.1\";\r\n        case 401:\r\n            return BASE_HTTP + \"#sec10.4.2\";\r\n        case 402:\r\n            return BASE_HTTP + \"#sec10.4.3\";\r\n        case 403:\r\n            return BASE_HTTP + \"#sec10.4.4\";\r\n        case 404:\r\n            return BASE_HTTP + \"#sec10.4.5\";\r\n        case 405:\r\n            return BASE_HTTP + \"#sec10.4.6\";\r\n        case 406:\r\n            return BASE_HTTP + \"#sec10.4.7\";\r\n        case 407:\r\n            return BASE_HTTP + \"#sec10.4.8\";\r\n        case 408:\r\n            return BASE_HTTP + \"#sec10.4.9\";\r\n        case 409:\r\n            return BASE_HTTP + \"#sec10.4.10\";\r\n        case 410:\r\n            return BASE_HTTP + \"#sec10.4.11\";\r\n        case 411:\r\n            return BASE_HTTP + \"#sec10.4.12\";\r\n        case 412:\r\n            return BASE_HTTP + \"#sec10.4.13\";\r\n        case 413:\r\n            return BASE_HTTP + \"#sec10.4.14\";\r\n        case 414:\r\n            return BASE_HTTP + \"#sec10.4.15\";\r\n        case 415:\r\n            return BASE_HTTP + \"#sec10.4.16\";\r\n        case 416:\r\n            return BASE_HTTP + \"#sec10.4.17\";\r\n        case 417:\r\n            return BASE_HTTP + \"#sec10.4.18\";\r\n        case 422:\r\n            return BASE_WEBDAV + \"#STATUS_422\";\r\n        case 423:\r\n            return BASE_WEBDAV + \"#STATUS_423\";\r\n        case 424:\r\n            return BASE_WEBDAV + \"#STATUS_424\";\r\n        case 429:\r\n            return BASE_ADDED_HTTP + \"#section-4\";\r\n        case 500:\r\n            return BASE_HTTP + \"#sec10.5.1\";\r\n        case 501:\r\n            return BASE_HTTP + \"#sec10.5.2\";\r\n        case 502:\r\n            return BASE_HTTP + \"#sec10.5.3\";\r\n        case 503:\r\n            return BASE_HTTP + \"#sec10.5.4\";\r\n        case 504:\r\n            return BASE_HTTP + \"#sec10.5.5\";\r\n        case 505:\r\n            return BASE_HTTP + \"#sec10.5.6\";\r\n        case 507:\r\n            return BASE_WEBDAV + \"#STATUS_507\";\r\n        case 1000:\r\n            return BASE_RESTLET + \"org/restlet/data/Status.html#CONNECTOR_ERROR_CONNECTION\";\r\n        case 1001:\r\n            return BASE_RESTLET + \"org/restlet/data/Status.html#CONNECTOR_ERROR_COMMUNICATION\";\r\n        case 1002:\r\n            return BASE_RESTLET + \"org/restlet/data/Status.html#CONNECTOR_ERROR_INTERNAL\";\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.buffer.Buffer.isEmpty",
	"Comment": "indicates if the buffer is empty in either filling or draining state.",
	"Method": "boolean isEmpty(){\r\n    return isFilling() ? (capacity() == remaining()) : !hasRemaining();\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.ResourceClass.getMethodFromClass",
	"Comment": "looks for the method with the same signature as the given method in thegiven class.",
	"Method": "Method getMethodFromClass(Class<?> clazz,Method subClassMethod){\r\n    if (clazz == null) {\r\n        return null;\r\n    }\r\n    final String methodName = subClassMethod.getName();\r\n    final Class<?>[] parameterTypes = subClassMethod.getParameterTypes();\r\n    try {\r\n        return clazz.getMethod(methodName, parameterTypes);\r\n    } catch (NoSuchMethodException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.restlet.util.Series.subList",
	"Comment": "returns a list of all the values associated to the parameter name.",
	"Method": "Series<T> subList(int fromIndex,int toIndex,Series<T> subList,String name,Series<T> subList,String name,boolean ignoreCase){\r\n    Series<T> result = new Series<T>(this.entryClass);\r\n    for (T param : this) {\r\n        if (equals(param.getName(), name, ignoreCase)) {\r\n            result.add(param);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsRestlet.getNoResourceClHandler",
	"Comment": "returns the restlet that is called, if no resource class could be found.",
	"Method": "Restlet getNoResourceClHandler(){\r\n    return excHandler.getNoResourceClHandler();\r\n}"
}, {
	"Path": "org.restlet.engine.header.ContentType.readMediaType",
	"Comment": "parses the given content type header and returns the media type.",
	"Method": "MediaType readMediaType(String contentType){\r\n    return new ContentType(contentType).getMediaType();\r\n}"
}, {
	"Path": "org.restlet.routing.Redirector.handle",
	"Comment": "handles a call by redirecting using the selected redirection mode.",
	"Method": "void handle(Request request,Response response){\r\n    Reference targetRef = getTargetRef(request, response);\r\n    switch(this.mode) {\r\n        case MODE_CLIENT_PERMANENT:\r\n            if (request.isLoggable()) {\r\n                getLogger().log(Level.FINE, \"Permanently redirecting client to: \" + targetRef);\r\n            }\r\n            response.redirectPermanent(targetRef);\r\n            break;\r\n        case MODE_CLIENT_FOUND:\r\n            if (request.isLoggable()) {\r\n                getLogger().log(Level.FINE, \"Redirecting client to found location: \" + targetRef);\r\n            }\r\n            response.setLocationRef(targetRef);\r\n            response.setStatus(Status.REDIRECTION_FOUND);\r\n            break;\r\n        case MODE_CLIENT_SEE_OTHER:\r\n            if (request.isLoggable()) {\r\n                getLogger().log(Level.FINE, \"Redirecting client to another location: \" + targetRef);\r\n            }\r\n            response.redirectSeeOther(targetRef);\r\n            break;\r\n        case MODE_CLIENT_TEMPORARY:\r\n            if (request.isLoggable()) {\r\n                getLogger().log(Level.FINE, \"Temporarily redirecting client to: \" + targetRef);\r\n            }\r\n            response.redirectTemporary(targetRef);\r\n            break;\r\n        case MODE_SERVER_OUTBOUND:\r\n            if (request.isLoggable()) {\r\n                getLogger().log(Level.FINE, \"Redirecting via client dispatcher to: \" + targetRef);\r\n            }\r\n            outboundServerRedirect(targetRef, request, response);\r\n            break;\r\n        case MODE_SERVER_INBOUND:\r\n            if (request.isLoggable()) {\r\n                getLogger().log(Level.FINE, \"Redirecting via server dispatcher to: \" + targetRef);\r\n            }\r\n            inboundServerRedirect(targetRef, request, response);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.restlet.security.MemoryRealm.findRoles",
	"Comment": "finds the roles mapped to a given user, for a specific application.",
	"Method": "Set<Role> findRoles(Application application,Group userGroup,Set<Role> findRoles,Application application,Set<Group> userGroups,Set<Role> findRoles,Application application,User user,Set<Role> findRoles,Group userGroup,Set<Role> findRoles,Set<Group> userGroups,Set<Role> findRoles,User user){\r\n    Set<Role> result = new HashSet<Role>();\r\n    Object source;\r\n    for (RoleMapping mapping : getRoleMappings()) {\r\n        source = mapping.getSource();\r\n        if ((user != null) && user.equals(source)) {\r\n            result.add(mapping.getTarget());\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.internal.xml.RdfXmlWriter.getPrefix",
	"Comment": "returns the prefix of the qualified name representing the givenreference.",
	"Method": "String getPrefix(Reference ref){\r\n    String result = null;\r\n    if (ref.hasFragment()) {\r\n        result = ref.getFragment();\r\n    } else {\r\n        result = ref.getLastSegment();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.webdav.WebDavMethod.valueOf",
	"Comment": "returns the method associated to a given method name. if an existingconstant exists then it is returned, otherwise a new instance is created.",
	"Method": "Method valueOf(String name){\r\n    Method result = null;\r\n    if ((name != null) && !name.equals(\"\")) {\r\n        if (name.equalsIgnoreCase(PROPFIND.getName())) {\r\n            result = PROPFIND;\r\n        } else if (name.equalsIgnoreCase(PROPPATCH.getName())) {\r\n            result = PROPPATCH;\r\n        } else if (name.equalsIgnoreCase(MKCOL.getName())) {\r\n            result = MKCOL;\r\n        } else if (name.equalsIgnoreCase(COPY.getName())) {\r\n            result = COPY;\r\n        } else if (name.equalsIgnoreCase(MOVE.getName())) {\r\n            result = MOVE;\r\n        } else if (name.equalsIgnoreCase(LOCK.getName())) {\r\n            result = LOCK;\r\n        } else if (name.equalsIgnoreCase(UNLOCK.getName())) {\r\n            result = UNLOCK;\r\n        } else {\r\n            result = new Method(name);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.resource.ServerResource.doHandle",
	"Comment": "effectively handles a call with content negotiation of the responseentity using an annotated method.",
	"Method": "Representation doHandle(Representation doHandle,MethodAnnotationInfo annotationInfo,Variant variant,Representation doHandle,Method method,Form query,Representation entity,Representation doHandle,Variant variant){\r\n    Representation result = null;\r\n    Method method = getMethod();\r\n    if (method == null) {\r\n        setStatus(Status.CLIENT_ERROR_BAD_REQUEST, \"No method specified\");\r\n    } else {\r\n        if (method.equals(Method.PUT)) {\r\n            result = put(getRequestEntity(), variant);\r\n        } else if (method.equals(Method.PATCH)) {\r\n            result = patch(getRequestEntity(), variant);\r\n        } else if (isExisting()) {\r\n            if (method.equals(Method.GET)) {\r\n                if (variant instanceof Representation) {\r\n                    result = (Representation) variant;\r\n                } else {\r\n                    result = get(variant);\r\n                }\r\n            } else if (method.equals(Method.POST)) {\r\n                result = post(getRequestEntity(), variant);\r\n            } else if (method.equals(Method.DELETE)) {\r\n                result = delete(variant);\r\n            } else if (method.equals(Method.HEAD)) {\r\n                if (variant instanceof Representation) {\r\n                    result = (Representation) variant;\r\n                } else {\r\n                    result = head(variant);\r\n                }\r\n            } else if (method.equals(Method.OPTIONS)) {\r\n                if (variant instanceof Representation) {\r\n                    result = (Representation) variant;\r\n                } else {\r\n                    result = options(variant);\r\n                }\r\n            } else if (variant instanceof VariantInfo) {\r\n                result = doHandle(((VariantInfo) variant).getAnnotationInfo(), variant);\r\n            } else {\r\n                doError(Status.CLIENT_ERROR_METHOD_NOT_ALLOWED);\r\n            }\r\n        } else {\r\n            doError(Status.CLIENT_ERROR_NOT_FOUND);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.ResourceInfo.createApplication",
	"Comment": "creates an application descriptor that wraps this resource descriptor.the title of the resource, that is to say the title of its firstdocumentation tag is transfered to the title of the first documentationtag of the main application tag.",
	"Method": "ApplicationInfo createApplication(){\r\n    ApplicationInfo result = new ApplicationInfo();\r\n    if (!getDocumentations().isEmpty()) {\r\n        String titleResource = getDocumentations().get(0).getTitle();\r\n        if (titleResource != null && !\"\".equals(titleResource)) {\r\n            DocumentationInfo doc = null;\r\n            if (result.getDocumentations().isEmpty()) {\r\n                doc = new DocumentationInfo();\r\n                result.getDocumentations().add(doc);\r\n            } else {\r\n                doc = result.getDocumentations().get(0);\r\n            }\r\n            doc.setTitle(titleResource);\r\n        }\r\n    }\r\n    ResourcesInfo resources = new ResourcesInfo();\r\n    result.setResources(resources);\r\n    resources.getResources().add(this);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.controller.ConnectionController.register",
	"Comment": "registers a selection listener with the underlying selector for the givenoperations and returns the registration created.",
	"Method": "SelectionRegistration register(SelectableChannel selectableChannel,int interestOperations,SelectionListener listener){\r\n    SelectionRegistration result = new SelectionRegistration(selectableChannel, interestOperations, listener, this);\r\n    getNewRegistrations().add(result);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.data.AuthenticationInfo.setNextServerNonce",
	"Comment": "sets the next server nonce. this is the nonce the server wishes theclient to use for a future authentication response",
	"Method": "void setNextServerNonce(String nextNonce){\r\n    this.nextServerNonce = nextNonce;\r\n}"
}, {
	"Path": "org.restlet.ext.sdc.internal.SdcServerConnection.dispatch",
	"Comment": "asynchronously process the response frames received from the sdc agent.",
	"Method": "void dispatch(FrameInfo frameInfo){\r\n    try {\r\n        if (frameInfo.getType() == Type.FETCH_REQUEST) {\r\n            FetchReply fetchReply = FetchReply.parseFrom(frameInfo.getPayload());\r\n            if (getLogger().isLoggable(Level.FINE)) {\r\n                getLogger().log(Level.FINE, \"SDC response received: \" + fetchReply.toString());\r\n            }\r\n            SdcClientCall call = getCalls().get(fetchReply.getId());\r\n            if (call != null) {\r\n                call.setFetchReply(fetchReply);\r\n                call.getLatch().countDown();\r\n            } else if (getLogger().isLoggable(Level.WARNING)) {\r\n                getLogger().log(Level.WARNING, \"Unable to find the SDC request associated to the received response\");\r\n            }\r\n        } else if (frameInfo.getType() == FrameInfo.Type.REGISTRATION) {\r\n            RegistrationRequestV4 registrationRequest = RegistrationRequestV4.parseFrom(frameInfo.getPayload());\r\n            if (getLogger().isLoggable(Level.FINE)) {\r\n                getLogger().log(Level.FINE, \"SDC tunnel registration received: \" + registrationRequest);\r\n            }\r\n            RegistrationResponseV4 registrationResponse = RegistrationResponseV4.newBuilder().setResult(com.google.dataconnector.protocol.proto.SdcFrame.RegistrationResponseV4.ResultCode.OK).setServerSuppliedConf(ServerSuppliedConf.newBuilder().setHealthCheckTimeout(5000).setHealthCheckWakeUpInterval(5000).build()).build();\r\n            getFrameSender().sendFrame(FrameInfo.Type.REGISTRATION, registrationResponse.toByteString());\r\n        } else if (frameInfo.getType() == Type.HEALTH_CHECK) {\r\n            HealthCheckInfo healthCheckResponse = HealthCheckInfo.newBuilder().setSource(Source.SERVER).setTimeStamp(System.currentTimeMillis()).setType(com.google.dataconnector.protocol.proto.SdcFrame.HealthCheckInfo.Type.RESPONSE).build();\r\n            if (getLogger().isLoggable(Level.FINE)) {\r\n                getLogger().log(Level.FINE, \"SDC health check received: \" + healthCheckResponse);\r\n            }\r\n            getFrameSender().sendFrame(Type.HEALTH_CHECK, healthCheckResponse.toByteString());\r\n        } else if (getLogger().isLoggable(Level.FINE)) {\r\n            getLogger().log(Level.FINE, \"Unexpected SDC frame received: \" + frameInfo);\r\n        }\r\n    } catch (InvalidProtocolBufferException e) {\r\n        getLogger().log(Level.WARNING, \"Invalid SDC frame received\", e);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlRepresentation.getBoolean",
	"Comment": "evaluates an xpath expression as a boolean. if the evaluation fails, nullwill be returned.",
	"Method": "Boolean getBoolean(String expression){\r\n    return (Boolean) internalEval(expression, javax.xml.xpath.XPathConstants.BOOLEAN);\r\n}"
}, {
	"Path": "org.restlet.engine.local.FileClientHelper.checkMetadataConsistency",
	"Comment": "checks that the uri and the representation are compatible. the whole setof metadata of the representation must be included in the set of those ofthe uri",
	"Method": "boolean checkMetadataConsistency(String fileName,Representation representation){\r\n    if (representation != null) {\r\n        Variant var = new Variant();\r\n        Entity.updateMetadata(fileName, var, false, getMetadataService());\r\n        if (!var.getLanguages().isEmpty() && !representation.getLanguages().isEmpty() && !var.getLanguages().containsAll(representation.getLanguages())) {\r\n            return false;\r\n        }\r\n        if ((var.getMediaType() != null) && (representation.getMediaType() != null) && !(var.getMediaType().includes(representation.getMediaType()))) {\r\n            return false;\r\n        }\r\n        if (!var.getEncodings().isEmpty() && !representation.getEncodings().isEmpty() && !var.getEncodings().containsAll(representation.getEncodings())) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.restlet.routing.Router.getRoutes",
	"Comment": "returns the modifiable list of routes. creates a new instance if no onehas been set.",
	"Method": "RouteList getRoutes(){\r\n    return this.routes;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.FunctionImport.isReturningEntityType",
	"Comment": "returns true if the result of the invocation of the service is an entitytype.",
	"Method": "boolean isReturningEntityType(){\r\n    return getReturnType() != null && getReturnType().toLowerCase().startsWith(\"edm.\");\r\n}"
}, {
	"Path": "org.restlet.data.ClientInfo.getAgentAttributes",
	"Comment": "returns a list of attributes taken from the name of the user agent.",
	"Method": "Map<String, String> getAgentAttributes(){\r\n    if (this.agentAttributes == null) {\r\n        this.agentAttributes = new ConcurrentHashMap<String, String>();\r\n        Map<String, Object> map = new ConcurrentHashMap<String, Object>();\r\n        org.restlet.routing.Template template = null;\r\n        org.restlet.routing.Variable agentName = new org.restlet.routing.Variable(org.restlet.routing.Variable.TYPE_TOKEN);\r\n        org.restlet.routing.Variable agentVersion = new org.restlet.routing.Variable(org.restlet.routing.Variable.TYPE_TOKEN);\r\n        org.restlet.routing.Variable agentComment = new org.restlet.routing.Variable(org.restlet.routing.Variable.TYPE_COMMENT);\r\n        org.restlet.routing.Variable agentCommentAttribute = new org.restlet.routing.Variable(org.restlet.routing.Variable.TYPE_COMMENT_ATTRIBUTE);\r\n        org.restlet.routing.Variable facultativeData = new org.restlet.routing.Variable(org.restlet.routing.Variable.TYPE_ALL, null, false, false);\r\n        if (ClientInfo.getUserAgentTemplates() != null) {\r\n            for (String string : ClientInfo.getUserAgentTemplates()) {\r\n                template = new org.restlet.routing.Template(string, org.restlet.routing.Template.MODE_EQUALS);\r\n                template.getVariables().put(\"agentName\", agentName);\r\n                template.getVariables().put(\"agentVersion\", agentVersion);\r\n                template.getVariables().put(\"agentComment\", agentComment);\r\n                template.getVariables().put(\"agentOs\", agentCommentAttribute);\r\n                template.getVariables().put(\"commentAttribute\", agentCommentAttribute);\r\n                template.getVariables().put(\"facultativeData\", facultativeData);\r\n                if (template.parse(getAgent(), map) > -1) {\r\n                    for (String key : map.keySet()) {\r\n                        this.agentAttributes.put(key, (String) map.get(key));\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return this.agentAttributes;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.provider.PerRequestProviderWrapper.instantiateAndInitialize",
	"Comment": "instantiates the provider class, initializes the instance and returns itunwrapped.",
	"Method": "Object instantiateAndInitialize(){\r\n    Object jaxRsProvider;\r\n    try {\r\n        jaxRsProvider = createInstance();\r\n    } catch (IllegalConstrParamTypeException e) {\r\n        throw new ImplementationException(\"The provider could not be instantiated, but this could not be here\", e);\r\n    } catch (IllegalPathParamTypeException e) {\r\n        throw new ImplementationException(\"The provider could not be instantiated, but this could not be here\", e);\r\n    } catch (IllegalArgumentException e) {\r\n        throw new ImplementationException(\"The provider could not be instantiated, but this could not be here\", e);\r\n    } catch (WebApplicationException e) {\r\n        throw new ImplementationException(\"The provider could not be instantiated, but this could not be here\", e);\r\n    } catch (MissingAnnotationException e) {\r\n        throw new ImplementationException(\"The provider could not be instantiated, but this could not be here\", e);\r\n    } catch (MissingConstructorException e) {\r\n        throw new ImplementationException(\"The provider could not be instantiated, but this could not be here\", e);\r\n    } catch (InvocationTargetException e) {\r\n        throw new ImplementationException(\"The provider could not be instantiated, but this could not be here\", e);\r\n    } catch (InstantiateException e) {\r\n        throw new ImplementationException(\"The provider could not be instantiated, but this could not be here\", e);\r\n    }\r\n    try {\r\n        initProvider(jaxRsProvider, tlContext, allProviders, extensionBackwardMapping);\r\n    } catch (IllegalFieldTypeException e) {\r\n        logger.log(Level.WARNING, \"The provider \" + this.getClassName() + \" could not be initialized and so it could not be used\", e);\r\n        throw new ProviderNotInitializableException();\r\n    } catch (IllegalBeanSetterTypeException e) {\r\n        logger.log(Level.WARNING, \"The provider \" + this.getClassName() + \" could not be initialized and so it could not be used\", e);\r\n        throw new ProviderNotInitializableException();\r\n    } catch (InjectException e) {\r\n        logger.log(Level.WARNING, \"The provider \" + this.getClassName() + \" could not be initialized and so it could not be used\", e);\r\n        throw new ProviderNotInitializableException();\r\n    } catch (InvocationTargetException e) {\r\n        logger.log(Level.WARNING, \"The provider \" + this.getClassName() + \" could not be initialized and so it could not be used\", e);\r\n        throw new ProviderNotInitializableException();\r\n    }\r\n    return jaxRsProvider;\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.DefaultSslContextFactory.setSecureRandomAlgorithm",
	"Comment": "sets the securerandom algorithm. the default value is null, inwhich case the default securerandom would be used.",
	"Method": "void setSecureRandomAlgorithm(String secureRandomAlgorithm){\r\n    this.secureRandomAlgorithm = secureRandomAlgorithm;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlRepresentation.getNamespaces",
	"Comment": "returns the map of namespaces. namespace prefixes are keys and urireferences are values.",
	"Method": "Map<String, String> getNamespaces(){\r\n    if (this.namespaces == null) {\r\n        this.namespaces = new HashMap<String, String>();\r\n    }\r\n    return this.namespaces;\r\n}"
}, {
	"Path": "org.restlet.representation.StringRepresentation.updateSize",
	"Comment": "updates the expected size according to the current string value.",
	"Method": "void updateSize(){\r\n    if (getText() != null) {\r\n        try {\r\n            if (getCharacterSet() != null) {\r\n                setSize(getText().getBytes(getCharacterSet().getName()).length);\r\n            } else {\r\n                setSize(getText().getBytes().length);\r\n            }\r\n        } catch (UnsupportedEncodingException e) {\r\n            Context.getCurrentLogger().log(Level.WARNING, \"Unable to update size\", e);\r\n            setSize(UNKNOWN_SIZE);\r\n        }\r\n    } else {\r\n        setSize(UNKNOWN_SIZE);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.osgi.BaseRouterProvider.bindDefaultRouterProvider",
	"Comment": "called by osgi ds to inject the default router provider service",
	"Method": "void bindDefaultRouterProvider(RouterProvider routerProvider){\r\n    defaultRestletProvider = routerProvider;\r\n    if (router != null)\r\n        router.attachDefault(routerProvider.getInboundRoot(router.getContext()));\r\n}"
}, {
	"Path": "org.restlet.Component.setClients",
	"Comment": "sets the modifiable list of client connectors. this method clears thecurrent list and adds all entries in the parameter list.",
	"Method": "void setClients(ClientList clients){\r\n    synchronized (getClients()) {\r\n        if (clients != getClients()) {\r\n            getClients().clear();\r\n            if (clients != null) {\r\n                getClients().addAll(clients);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.FunctionImport.isReturningComplexType",
	"Comment": "returns true if the result of the invocation of the service is a complextype.",
	"Method": "boolean isReturningComplexType(){\r\n    return getReturnTypeAsComplexType() != null;\r\n}"
}, {
	"Path": "org.restlet.resource.Directory.getIndexRepresentation",
	"Comment": "returns an actual index representation for a given variant.",
	"Method": "Representation getIndexRepresentation(Variant variant,ReferenceList indexContent){\r\n    Representation result = null;\r\n    if (variant.getMediaType().equals(MediaType.TEXT_HTML)) {\r\n        result = indexContent.getWebRepresentation();\r\n    } else if (variant.getMediaType().equals(MediaType.TEXT_URI_LIST)) {\r\n        result = indexContent.getTextRepresentation();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.Property.isConcurrent",
	"Comment": "returns true if this property should be used for optimistic concurrencychecks.",
	"Method": "boolean isConcurrent(){\r\n    return concurrent;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.DigestUtils.toSha1",
	"Comment": "returns the sha1 digest of target string. target is decoded to bytesusing the named charset.",
	"Method": "String toSha1(String target,String toSha1,String target,String charsetName){\r\n    try {\r\n        return Base64.encode(MessageDigest.getInstance(\"SHA1\").digest(target.getBytes(charsetName)), false);\r\n    } catch (NoSuchAlgorithmException nsae) {\r\n        throw new RuntimeException(\"No SHA1 algorithm, unable to compute SHA1\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getRelativeRef",
	"Comment": "returns the current reference relatively to a base reference. this methodshould only be invoked for absolute references, otherwise anillegalargumentexception will be raised.",
	"Method": "Reference getRelativeRef(Reference getRelativeRef,Reference base){\r\n    Reference result = null;\r\n    if (base == null) {\r\n        result = this;\r\n    } else if (!isAbsolute() || !isHierarchical()) {\r\n        throw new IllegalArgumentException(\"The reference must have an absolute hierarchical path component\");\r\n    } else if (!base.isAbsolute() || !base.isHierarchical()) {\r\n        throw new IllegalArgumentException(\"The base reference must have an absolute hierarchical path component\");\r\n    } else if (!getHostIdentifier().equals(base.getHostIdentifier())) {\r\n        result = this;\r\n    } else {\r\n        final String localPath = getPath();\r\n        final String basePath = base.getPath();\r\n        String relativePath = null;\r\n        if ((basePath == null) || (localPath == null)) {\r\n            relativePath = localPath;\r\n        } else {\r\n            boolean diffFound = false;\r\n            int lastSlashIndex = -1;\r\n            int i = 0;\r\n            char current;\r\n            while (!diffFound && (i < localPath.length()) && (i < basePath.length())) {\r\n                current = localPath.charAt(i);\r\n                if (current != basePath.charAt(i)) {\r\n                    diffFound = true;\r\n                } else {\r\n                    if (current == '/') {\r\n                        lastSlashIndex = i;\r\n                    }\r\n                    i++;\r\n                }\r\n            }\r\n            if (!diffFound) {\r\n                if (localPath.length() == basePath.length()) {\r\n                    relativePath = \".\";\r\n                } else if (i == localPath.length()) {\r\n                    if (basePath.charAt(i) == '/') {\r\n                        if ((i + 1) == basePath.length()) {\r\n                            relativePath = \".\";\r\n                        } else {\r\n                            final StringBuilder sb = new StringBuilder();\r\n                            int segments = 0;\r\n                            for (int j = basePath.indexOf('/', i); j != -1; j = basePath.indexOf('/', j + 1)) segments++;\r\n                            for (int j = 0; j < segments; j++) sb.append(\"../\");\r\n                            int lastLocalSlash = localPath.lastIndexOf('/');\r\n                            sb.append(localPath.substring(lastLocalSlash + 1));\r\n                            relativePath = sb.toString();\r\n                        }\r\n                    } else {\r\n                        final StringBuilder sb = new StringBuilder();\r\n                        int segments = 0;\r\n                        for (int j = basePath.indexOf('/', i); j != -1; j = basePath.indexOf('/', j + 1)) segments++;\r\n                        for (int j = 0; j < segments; j++) if (j > 0)\r\n                            sb.append(\"/..\");\r\n                        else\r\n                            sb.append(\"..\");\r\n                        relativePath = sb.toString();\r\n                        if (relativePath.equals(\"\")) {\r\n                            relativePath = \".\";\r\n                        }\r\n                    }\r\n                } else if (i == basePath.length()) {\r\n                    if (localPath.charAt(i) == '/') {\r\n                        if ((i + 1) == localPath.length()) {\r\n                            relativePath = \".\";\r\n                        } else {\r\n                            relativePath = localPath.substring(i + 1);\r\n                        }\r\n                    } else {\r\n                        if (lastSlashIndex == (i - 1)) {\r\n                            relativePath = localPath.substring(i);\r\n                        } else {\r\n                            relativePath = \"..\" + localPath.substring(lastSlashIndex);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                final StringBuilder sb = new StringBuilder();\r\n                int segments = 0;\r\n                for (int j = basePath.indexOf('/', i); j != -1; j = basePath.indexOf('/', j + 1)) segments++;\r\n                for (int j = 0; j < segments; j++) sb.append(\"../\");\r\n                sb.append(localPath.substring(lastSlashIndex + 1));\r\n                relativePath = sb.toString();\r\n            }\r\n        }\r\n        result = new Reference();\r\n        final String query = getQuery();\r\n        final String fragment = getFragment();\r\n        boolean modified = false;\r\n        if ((query != null) && (!query.equals(base.getQuery()))) {\r\n            result.setQuery(query);\r\n            modified = true;\r\n        }\r\n        if ((fragment != null) && (!fragment.equals(base.getFragment()))) {\r\n            result.setFragment(fragment);\r\n            modified = true;\r\n        }\r\n        if (!modified || !\".\".equals(relativePath)) {\r\n            result.setPath(relativePath);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.service.TaskService.setDaemon",
	"Comment": "indicates whether or not the threads are daemon threads. true by default.",
	"Method": "void setDaemon(boolean daemon){\r\n    this.daemon = daemon;\r\n}"
}, {
	"Path": "org.restlet.ext.sip.Priority.valueOf",
	"Comment": "returns the priority associated to a value. if an existing constantexists then it is returned, otherwise a new instance is created.",
	"Method": "Priority valueOf(String value){\r\n    Priority result = null;\r\n    if ((value != null) && !value.equals(\"\")) {\r\n        result = getPriorities().get(value);\r\n        if (result == null) {\r\n            result = new Priority(value);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.swagger.v2_0.Swagger2Writer.getSwagger",
	"Comment": "translates a restlet web api definition to a swagger definition",
	"Method": "Swagger getSwagger(Definition definition){\r\n    Swagger swagger = new Swagger();\r\n    swagger.setSwagger(SWAGGER_VERSION);\r\n    fillSwaggerMainAttributes(definition, swagger);\r\n    fillSwaggerAuthentication(definition, swagger);\r\n    fillSwaggerInfo(definition, swagger);\r\n    fillTags(definition.getContract(), swagger);\r\n    fillPaths(definition, swagger);\r\n    fillDefinitions(definition, swagger);\r\n    return swagger;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.internal.AwsUtils.getHmacSha1Signature",
	"Comment": "returns the aws authentication compatible signature for the given stringto sign and secret.",
	"Method": "String getHmacSha1Signature(String stringToSign,char[] secret){\r\n    return Base64.encode(DigestUtils.toHMacSha1(stringToSign, IoUtils.toByteArray(secret)), false);\r\n}"
}, {
	"Path": "org.restlet.ext.xml.TransformRepresentation.getOutputProperties",
	"Comment": "returns the modifiable map of jaxp transformer output properties.",
	"Method": "Map<String, String> getOutputProperties(){\r\n    return this.outputProperties;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.FunctionImport.isReturningCollection",
	"Comment": "returns true if the result of the invocation of the service is acollection.",
	"Method": "boolean isReturningCollection(){\r\n    return getReturnType() != null && getReturnType().toLowerCase().startsWith(\"collection(\");\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.ResourceTypeInfo.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    final AttributesImpl attributes = new AttributesImpl();\r\n    if ((getIdentifier() != null) && !getIdentifier().equals(\"\")) {\r\n        attributes.addAttribute(\"\", \"id\", null, \"xs:ID\", getIdentifier());\r\n    }\r\n    if (getDocumentations().isEmpty() && getMethods().isEmpty() && getParameters().isEmpty()) {\r\n        writer.emptyElement(APP_NAMESPACE, \"resource_type\", null, attributes);\r\n    } else {\r\n        writer.startElement(APP_NAMESPACE, \"resource_type\", null, attributes);\r\n        for (final DocumentationInfo documentationInfo : getDocumentations()) {\r\n            documentationInfo.writeElement(writer);\r\n        }\r\n        for (final MethodInfo methodInfo : getMethods()) {\r\n            methodInfo.writeElement(writer);\r\n        }\r\n        for (final ParameterInfo parameterInfo : getParameters()) {\r\n            parameterInfo.writeElement(writer);\r\n        }\r\n        writer.endElement(APP_NAMESPACE, \"resource_type\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipMethod.valueOf",
	"Comment": "returns the method associated to a given method name. if an existingconstant exists then it is returned, otherwise a new instance is created.",
	"Method": "Method valueOf(String name){\r\n    Method result = null;\r\n    if ((name != null) && !name.equals(\"\")) {\r\n        if (name.equalsIgnoreCase(ACK.getName())) {\r\n            result = ACK;\r\n        } else if (name.equalsIgnoreCase(BYE.getName())) {\r\n            result = BYE;\r\n        } else if (name.equalsIgnoreCase(CANCEL.getName())) {\r\n            result = CANCEL;\r\n        } else if (name.equalsIgnoreCase(INFO.getName())) {\r\n            result = INFO;\r\n        } else if (name.equalsIgnoreCase(INVITE.getName())) {\r\n            result = INVITE;\r\n        } else if (name.equalsIgnoreCase(NOTIFY.getName())) {\r\n            result = NOTIFY;\r\n        } else if (name.equalsIgnoreCase(OPTIONS.getName())) {\r\n            result = OPTIONS;\r\n        } else if (name.equalsIgnoreCase(PUBLISH.getName())) {\r\n            result = PUBLISH;\r\n        } else if (name.equalsIgnoreCase(REFER.getName())) {\r\n            result = REFER;\r\n        } else if (name.equalsIgnoreCase(REGISTER.getName())) {\r\n            result = REGISTER;\r\n        } else if (name.equalsIgnoreCase(SUBSCRIBE.getName())) {\r\n            result = SUBSCRIBE;\r\n        } else {\r\n            result = new Method(name);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.javamail.TriggerResource.getTargetMethod",
	"Comment": "returns the target method according to a list of properties.",
	"Method": "Method getTargetMethod(Method getTargetMethod,Resolver<String> resolver){\r\n    Method method = Method.valueOf(resolver.resolve(\"method\"));\r\n    if (method == null) {\r\n        method = getTargetMethod();\r\n    }\r\n    return method;\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.Link.getSourceAsGraph",
	"Comment": "returns the source graph. supports rdf reification or n3 formulae.",
	"Method": "Graph getSourceAsGraph(){\r\n    return hasGraphSource() ? (Graph) getSource() : null;\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipRequest.setSipIfMatch",
	"Comment": "sets the identifier of the specific event state that the request isrefreshing.",
	"Method": "void setSipIfMatch(Tag sipIfMatch){\r\n    this.sipIfMatch = sipIfMatch;\r\n}"
}, {
	"Path": "org.restlet.ext.spring.SpringComponent.setServersList",
	"Comment": "sets the list of servers, either as protocol names, protocol instances orserver instances.",
	"Method": "void setServersList(List<Object> serversInfo){\r\n    for (final Object serverInfo : serversInfo) {\r\n        if (serverInfo instanceof String) {\r\n            getServers().add(Protocol.valueOf((String) serverInfo));\r\n        } else if (serverInfo instanceof Protocol) {\r\n            getServers().add((Protocol) serverInfo);\r\n        } else if (serverInfo instanceof Server) {\r\n            getServers().add((Server) serverInfo);\r\n        } else {\r\n            getLogger().warning(\"Unknown object found in the servers list. Only instances of String, org.restlet.data.Protocol and org.restlet.Server are allowed.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.data.ChallengeResponse.getSecretAlgorithm",
	"Comment": "returns the digest algorithm name optionally applied on the user secret.",
	"Method": "String getSecretAlgorithm(){\r\n    return secretAlgorithm;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.ExtendedUriBuilder.fromResource",
	"Comment": "create a new instance representing a relative uri initialized from a rootresource class.",
	"Method": "ExtendedUriBuilder fromResource(Class<?> resource){\r\n    ExtendedUriBuilder b = newInstance();\r\n    b.path(resource);\r\n    return b;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.MethodInfo.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    final AttributesImpl attributes = new AttributesImpl();\r\n    if ((getIdentifier() != null) && !getIdentifier().equals(\"\")) {\r\n        attributes.addAttribute(\"\", \"id\", null, \"xs:ID\", getIdentifier());\r\n    }\r\n    if ((getName() != null) && (getName().toString() != null)) {\r\n        attributes.addAttribute(\"\", \"name\", null, \"xs:NMTOKEN\", getName().toString());\r\n    }\r\n    if ((getTargetRef() != null) && (getTargetRef().toString() != null)) {\r\n        attributes.addAttribute(\"\", \"href\", null, \"xs:anyURI\", getTargetRef().toString());\r\n    }\r\n    if (getDocumentations().isEmpty() && (getRequest() == null) && (getResponses().isEmpty())) {\r\n        writer.emptyElement(APP_NAMESPACE, \"method\", null, attributes);\r\n    } else {\r\n        writer.startElement(APP_NAMESPACE, \"method\", null, attributes);\r\n        for (final DocumentationInfo documentationInfo : getDocumentations()) {\r\n            documentationInfo.writeElement(writer);\r\n        }\r\n        if (getRequest() != null) {\r\n            getRequest().writeElement(writer);\r\n        }\r\n        if (!getResponses().isEmpty()) {\r\n            for (ResponseInfo response : getResponses()) {\r\n                response.writeElement(writer);\r\n            }\r\n        }\r\n        writer.endElement(APP_NAMESPACE, \"method\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.service.TaskService.awaitTermination",
	"Comment": "blocks until all tasks have completed execution after a shutdown request,or the timeout occurs, or the current thread is interrupted, whicheverhappens first.",
	"Method": "boolean awaitTermination(long timeout,TimeUnit unit){\r\n    startIfNeeded();\r\n    return getWrapped().awaitTermination(timeout, unit);\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.channel.ReadableSslChannel.onDrain",
	"Comment": "drains the byte buffer. by default, it decrypts the ssl data and copiesas many byte as possible to the target buffer, with no modification.",
	"Method": "int onDrain(Buffer buffer,int maxDrained,Object args){\r\n    ByteBuffer applicationBuffer = (ByteBuffer) args[0];\r\n    int initialSize = buffer.remaining();\r\n    SSLEngineResult sslResult = getConnection().getSslEngine().unwrap(buffer.getBytes(), applicationBuffer);\r\n    getConnection().setSslResult(sslResult);\r\n    return initialSize - buffer.remaining();\r\n}"
}, {
	"Path": "org.restlet.test.ext.apispark.ApiSparkServiceTestCase.testAgent_Analytics_Broken",
	"Comment": "tests that the agent calls the analytics service when buffer reaches maxsize",
	"Method": "void testAgent_Analytics_Broken(){\r\n    MockModulesSettingsServerResource.MODULES_SETTINGS.setAnalyticsModuleEnabled(true);\r\n    MockAnalyticsServerResource.BROKEN = true;\r\n    ApiSparkService apiSparkService = getAgentService();\r\n    apiSparkService.setAgentAnalyticsBufferSize(1);\r\n    startApiSparkService(apiSparkService, true);\r\n    assertEquals(0, MockAnalyticsServerResource.GET_ANALYTICS_COUNT);\r\n    assertEquals(0, MockAnalyticsServerResource.GET_CALLLOG_COUNT);\r\n    callAgent(\"/test\", VALID_USERNAME, VALID_PASSWORD);\r\n    Thread.sleep(1500);\r\n    assertTrue(\"expected count >= 2, current count: \" + MockAnalyticsServerResource.GET_ANALYTICS_COUNT, MockAnalyticsServerResource.GET_ANALYTICS_COUNT >= 2);\r\n    assertEquals(0, MockAnalyticsServerResource.GET_CALLLOG_COUNT);\r\n}"
}, {
	"Path": "org.restlet.service.MetadataService.getAllCharacterSetExtensionNames",
	"Comment": "return the ordered list of extension names mapped to character set.",
	"Method": "List<String> getAllCharacterSetExtensionNames(){\r\n    List<String> result = new ArrayList<String>();\r\n    for (MetadataExtension mapping : this.mappings) {\r\n        if ((mapping.getMetadata() instanceof CharacterSet) && !result.contains(mapping.getName())) {\r\n            result.add(mapping.getName());\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jackson.JacksonRepresentation.createObjectWriter",
	"Comment": "creates a jackson object writer based on a mapper. has a special handlingfor csv media types.",
	"Method": "ObjectWriter createObjectWriter(){\r\n    ObjectWriter result = null;\r\n    if (MediaType.TEXT_CSV.isCompatible(getMediaType())) {\r\n        CsvMapper csvMapper = (CsvMapper) getObjectMapper();\r\n        CsvSchema csvSchema = createCsvSchema(csvMapper);\r\n        result = csvMapper.writer(csvSchema);\r\n    } else {\r\n        result = getObjectMapper().writerWithType(getObjectClass());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.JettyServerHelper.getConnectorAcceptQueueSize",
	"Comment": "connector accept queue size. defaults to 0.also known as accept backlog.",
	"Method": "int getConnectorAcceptQueueSize(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"connector.acceptQueueSize\", \"0\"));\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createInsuranceContractQuery",
	"Comment": "creates a query for insurancecontract entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.InsuranceContract> createInsuranceContractQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.InsuranceContract.class);\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.ExceptionHandler.getNoResourceClHandler",
	"Comment": "returns the restlet that is called, if no resource class could be found.",
	"Method": "Restlet getNoResourceClHandler(){\r\n    return noResourceClHandler;\r\n}"
}, {
	"Path": "org.restlet.routing.Redirector.getLocation",
	"Comment": "computes the new location of the given reference, after applying theredirection template. returns null in case it cannot compute the newreference.",
	"Method": "String getLocation(Reference locationRef,Request request){\r\n    Reference resourceRef = request.getResourceRef();\r\n    Reference baseRef = resourceRef.getBaseRef();\r\n    Template rt = new Template(this.targetTemplate);\r\n    rt.setLogger(getLogger());\r\n    int matched = rt.parse(locationRef.toString(), request);\r\n    if (matched > 0) {\r\n        String remainingPart = (String) request.getAttributes().get(\"rr\");\r\n        if (remainingPart != null) {\r\n            return baseRef.toString() + remainingPart;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.data.Reference.addQueryParameters",
	"Comment": "adds several parameters to the query component. the name and value areautomatically url encoded if necessary.",
	"Method": "Reference addQueryParameters(Iterable<Parameter> parameters){\r\n    for (Parameter param : parameters) {\r\n        addQueryParameter(param);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.restlet.util.Series.set",
	"Comment": "replaces the value of the first parameter with the given name and removesall other parameters with the same name.",
	"Method": "T set(String name,String value,T set,String name,String value,boolean ignoreCase){\r\n    T result = null;\r\n    T param = null;\r\n    boolean found = false;\r\n    for (final Iterator<T> iter = iterator(); iter.hasNext(); ) {\r\n        param = iter.next();\r\n        if (equals(param.getName(), name, ignoreCase)) {\r\n            if (found) {\r\n                iter.remove();\r\n            } else {\r\n                found = true;\r\n                param.setValue(value);\r\n                result = param;\r\n            }\r\n        }\r\n    }\r\n    if (!found) {\r\n        add(name, value);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.usage.InputUnusedLocal.method2",
	"Comment": "tests that neither type nor typecast are considered to be a reference",
	"Method": "void method2(){\r\n    int java;\r\n    java.io.File file = (java.io.File) null;\r\n    if (file != null) {\r\n    }\r\n}"
}, {
	"Path": "org.restlet.resource.Resource.getProxyChallengeRequests",
	"Comment": "returns the list of proxy authentication requests sent by an originserver to a client. if none is available, an empty list is returned.",
	"Method": "List<ChallengeRequest> getProxyChallengeRequests(){\r\n    return getResponse() == null ? null : getResponse().getProxyChallengeRequests();\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipResponse.getOrganization",
	"Comment": "returns the name of the organization to which the sip element issuing themessage belongs.",
	"Method": "String getOrganization(){\r\n    return organization;\r\n}"
}, {
	"Path": "org.restlet.engine.util.Pool.checkout",
	"Comment": "checks out an object from the pool. creates a new one if the pool isempty.",
	"Method": "T checkout(){\r\n    T result;\r\n    if ((result = this.store.poll()) == null) {\r\n        result = createObject();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.security.RoleAuthorizer.authorize",
	"Comment": "authorizes the request only if its subject is in one of the authorizedroles and in none of the forbidden ones.",
	"Method": "boolean authorize(Request request,Response response){\r\n    boolean authorized = false;\r\n    boolean forbidden = false;\r\n    if (getAuthorizedRoles().isEmpty()) {\r\n        authorized = true;\r\n    } else {\r\n        for (Role authorizedRole : getAuthorizedRoles()) {\r\n            authorized = authorized || request.getClientInfo().getRoles().contains(authorizedRole);\r\n        }\r\n    }\r\n    for (Role forbiddenRole : getForbiddenRoles()) {\r\n        forbidden = forbidden || request.getClientInfo().getRoles().contains(forbiddenRole);\r\n    }\r\n    return authorized && !forbidden;\r\n}"
}, {
	"Path": "org.restlet.test.ext.jaxrs.services.tests.JsonTest.testGetPersonXml",
	"Comment": "this test using jaxb, but shows that you can serialize objects by jaxband by json.",
	"Method": "void testGetPersonXml(MediaType xmlMediaType){\r\n    final Response response = get(\"person?firstname=Angela&lastname=Merkel\", xmlMediaType);\r\n    sysOutEntityIfError(response);\r\n    assertEquals(Status.SUCCESS_OK, response.getStatus());\r\n    final JaxbRepresentation<Person> jaxbReprs = new JaxbRepresentation<Person>(response.getEntity(), Person.class);\r\n    final Person person = jaxbReprs.getObject();\r\n    assertEquals(\"Angela\", person.getFirstname());\r\n    assertEquals(\"Merkel\", person.getLastname());\r\n}"
}, {
	"Path": "org.restlet.ext.emf.EmfRepresentation.getObject",
	"Comment": "returns the wrapped object either parsed from the representation or to beformatted.",
	"Method": "T getObject(){\r\n    T result = null;\r\n    if (this.object != null) {\r\n        result = this.object;\r\n    } else if (this.representation != null) {\r\n        Resource emfResource = createEmfResource(this.representation.getMediaType());\r\n        emfResource.load(this.representation.getStream(), getLoadOptions());\r\n        result = (T) emfResource.getContents().get(0);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.createRequest",
	"Comment": "creates a new request by cloning the one wrapped by this class.",
	"Method": "Request createRequest(){\r\n    return new Request(getRequest());\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.ScopeIndex.lookup",
	"Comment": "returns the most specific scope to which the specifiedoccurence belongs.",
	"Method": "Scope lookup(Occurrence occ){\r\n    String key = occ.getFile().getAbsolutePath();\r\n    Vector scopeList = getFileVector(key);\r\n    Scope result = findScope(scopeList, occ);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.application.StrictConneg.scoreCharacterSet",
	"Comment": "scores a character set relatively to enriched client preferences.",
	"Method": "float scoreCharacterSet(CharacterSet characterSet){\r\n    return scoreMetadata(characterSet, getCharacterSetPrefs());\r\n}"
}, {
	"Path": "org.restlet.ext.atom.FeedReader.endFeed",
	"Comment": "called at the end of the xml block that defines the given feed.",
	"Method": "void endFeed(Feed feed){\r\n    if (this.feedReader != null) {\r\n        this.feedReader.endFeed(feed);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.service.TunnelService.setUserAgentTunnel",
	"Comment": "indicates if the client preferences can be tunneled according to the useragent.",
	"Method": "void setUserAgentTunnel(boolean userAgentTunnel){\r\n    this.userAgentTunnel = userAgentTunnel;\r\n}"
}, {
	"Path": "org.restlet.ext.servlet.internal.ServletCall.getServerAddress",
	"Comment": "returns the response address.corresponds to the ip address of the responding server.",
	"Method": "String getServerAddress(){\r\n    return getRequest().getLocalAddr();\r\n}"
}, {
	"Path": "org.restlet.data.Tag.getName",
	"Comment": "returns the name, corresponding to an http opaque tag value.",
	"Method": "String getName(){\r\n    return this.name;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Source.setIcon",
	"Comment": "sets the image that provides iconic visual identification for a feed.",
	"Method": "void setIcon(Reference icon){\r\n    this.icon = icon;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.EntryReader.endContent",
	"Comment": "called at the end of the xml block that defines the given contentelement. by default, it relays the event to the extra handler.",
	"Method": "void endContent(Content content){\r\n    if (this.entryReader != null) {\r\n        this.entryReader.endContent(content);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.getOnResponse",
	"Comment": "returns the callback invoked on response reception. if the value is notnull, then the associated request will be executed asynchronously.",
	"Method": "Uniform getOnResponse(){\r\n    return getRequest().getOnResponse();\r\n}"
}, {
	"Path": "org.restlet.engine.resource.AnnotationUtils.getAnnotations",
	"Comment": "returns the annotation descriptors for the given resource class.",
	"Method": "List<AnnotationInfo> getAnnotations(Class<?> clazz,List<AnnotationInfo> getAnnotations,Class<?> clazz,java.lang.reflect.Method javaMethod){\r\n    return addMethodAnnotationDescriptors(null, clazz, clazz, javaMethod);\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Entry.getUpdated",
	"Comment": "returns the most recent moment when the entry was modified in asignificant way.",
	"Method": "Date getUpdated(){\r\n    return this.updated;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.Transformer.canTransform",
	"Comment": "indicates if the filter can transform the given message entity. bydefault, it always returns true.",
	"Method": "boolean canTransform(Representation representation){\r\n    return true;\r\n}"
}, {
	"Path": "org.restlet.example.ext.rdf.foaf.resources.ContactResource.storeContact",
	"Comment": "update the underlying contact according to the given representation.",
	"Method": "void storeContact(Representation entity){\r\n    final Form form = new Form(entity);\r\n    this.contact.setFirstName(form.getFirstValue(\"firstName\"));\r\n    this.contact.setLastName(form.getFirstValue(\"lastName\"));\r\n    this.contact.setImage(form.getFirstValue(\"image\"));\r\n    this.contact.setNickname(form.getFirstValue(\"nickname\"));\r\n    this.contact.setFoafUri(form.getFirstValue(\"foafUri\"));\r\n    getObjectsFacade().updateContact(this.user, this.contact);\r\n    getResponse().redirectSeeOther(getRequest().getResourceRef());\r\n}"
}, {
	"Path": "org.restlet.engine.io.InputStreamChannel.isBlocking",
	"Comment": "true if the underlying input stream is able to indicate available bytesupfront.",
	"Method": "boolean isBlocking(){\r\n    return this.blocking;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.Util.startsWith",
	"Comment": "checks, if the given charsequence starts with the given character.",
	"Method": "boolean startsWith(CharSequence charSequence,char character){\r\n    if (charSequence == null)\r\n        return false;\r\n    if (charSequence.length() == 0)\r\n        return false;\r\n    return charSequence.charAt(0) == character;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.FeedReader.endContent",
	"Comment": "called at the end of the xml block that defines the given contentelement. by default, it relays the event to the extra handler.",
	"Method": "void endContent(Content content){\r\n    if (this.feedReader != null) {\r\n        this.feedReader.endContent(content);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.header.HeaderReader.readValue",
	"Comment": "read the next value. there can be multiple values for a single header.returns null by default.",
	"Method": "V readValue(){\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.service.MetadataService.getAllMediaTypes",
	"Comment": "returns all the media types associated to this extension. it returns nullif the extension was not declared.",
	"Method": "List<MediaType> getAllMediaTypes(String extension){\r\n    List<MediaType> result = null;\r\n    if (extension != null) {\r\n        for (MetadataExtension metadataExtension : this.mappings) {\r\n            if (extension.equals(metadataExtension.getName()) && (metadataExtension.getMetadata() instanceof MediaType)) {\r\n                if (result == null) {\r\n                    result = new ArrayList<MediaType>();\r\n                }\r\n                result.add(metadataExtension.getMediaType());\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Link.setHrefLang",
	"Comment": "sets the language of the resource pointed to by the href attribute.",
	"Method": "void setHrefLang(Language hrefLang){\r\n    this.hrefLang = hrefLang;\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.JettyServerHelper.getThreadPoolIdleTimeout",
	"Comment": "thread pool idle timeout in milliseconds. defaults to 60000.threads that are idle for longer than this period may be stopped.",
	"Method": "int getThreadPoolIdleTimeout(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"threadPool.idleTimeout\", \"60000\"));\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.DefaultSslContextFactory.init",
	"Comment": "sets the following options according to parameters that may have been setup directly in the httpsclienthelper or httpsserverhelper parameters. seeclass javadocs for the list of parameters supported.",
	"Method": "void init(Series<Parameter> helperParameters){\r\n    String[] disabledCipherSuitesArray = helperParameters.getValuesArray(\"disabledCipherSuites\");\r\n    Set<String> disabledCipherSuites = new HashSet<String>();\r\n    for (String disabledCipherSuiteSeries : disabledCipherSuitesArray) {\r\n        for (String disabledCipherSuite : disabledCipherSuiteSeries.split(\" \")) {\r\n            disabledCipherSuites.add(disabledCipherSuite);\r\n        }\r\n    }\r\n    if (disabledCipherSuites.size() > 0) {\r\n        disabledCipherSuitesArray = new String[disabledCipherSuites.size()];\r\n        disabledCipherSuites.toArray(disabledCipherSuitesArray);\r\n        setDisabledCipherSuites(disabledCipherSuitesArray);\r\n    } else {\r\n        setDisabledCipherSuites(null);\r\n    }\r\n    String[] disabledProtocolsArray = helperParameters.getValuesArray(\"disabledProtocols\");\r\n    Set<String> disabledProtocols = new HashSet<String>();\r\n    for (String disabledProtocolsSeries : disabledProtocolsArray) {\r\n        for (String disabledProtocol : disabledProtocolsSeries.split(\" \")) {\r\n            disabledProtocols.add(disabledProtocol);\r\n        }\r\n    }\r\n    if (disabledProtocols.size() > 0) {\r\n        disabledProtocolsArray = new String[disabledProtocols.size()];\r\n        disabledProtocols.toArray(disabledProtocolsArray);\r\n        setDisabledProtocols(disabledProtocolsArray);\r\n    } else {\r\n        setDisabledProtocols(null);\r\n    }\r\n    String[] enabledCipherSuitesArray = helperParameters.getValuesArray(\"enabledCipherSuites\");\r\n    Set<String> enabledCipherSuites = new HashSet<String>();\r\n    for (String enabledCipherSuiteSeries : enabledCipherSuitesArray) {\r\n        for (String enabledCipherSuite : enabledCipherSuiteSeries.split(\" \")) {\r\n            enabledCipherSuites.add(enabledCipherSuite);\r\n        }\r\n    }\r\n    if (enabledCipherSuites.size() > 0) {\r\n        enabledCipherSuitesArray = new String[enabledCipherSuites.size()];\r\n        enabledCipherSuites.toArray(enabledCipherSuitesArray);\r\n        setEnabledCipherSuites(enabledCipherSuitesArray);\r\n    } else {\r\n        setEnabledCipherSuites(null);\r\n    }\r\n    String[] enabledProtocolsArray = helperParameters.getValuesArray(\"enabledProtocols\");\r\n    Set<String> enabledProtocols = new HashSet<String>();\r\n    for (String enabledProtocolSeries : enabledProtocolsArray) {\r\n        for (String enabledProtocol : enabledProtocolSeries.split(\" \")) {\r\n            enabledProtocols.add(enabledProtocol);\r\n        }\r\n    }\r\n    if (enabledProtocols.size() > 0) {\r\n        enabledProtocolsArray = new String[enabledProtocols.size()];\r\n        enabledProtocols.toArray(enabledProtocolsArray);\r\n        setEnabledProtocols(enabledProtocolsArray);\r\n    } else {\r\n        setEnabledProtocols(null);\r\n    }\r\n    setKeyManagerAlgorithm(helperParameters.getFirstValue(\"keyManagerAlgorithm\", true, System.getProperty(\"ssl.KeyManagerFactory.algorithm\", \"SunX509\")));\r\n    setKeyStorePassword(helperParameters.getFirstValue(\"keyStorePassword\", true, System.getProperty(\"javax.net.ssl.keyStorePassword\", \"\")));\r\n    setKeyStoreKeyPassword(helperParameters.getFirstValue(\"keyPassword\", true, System.getProperty(\"javax.net.ssl.keyPassword\")));\r\n    if (this.keyStoreKeyPassword == null) {\r\n        this.keyStoreKeyPassword = this.keyStorePassword;\r\n    }\r\n    setKeyStorePath(helperParameters.getFirstValue(\"keyStorePath\", true, System.getProperty(\"javax.net.ssl.keyStore\")));\r\n    setKeyStoreType(helperParameters.getFirstValue(\"keyStoreType\", true, System.getProperty(\"javax.net.ssl.keyStoreType\")));\r\n    setNeedClientAuthentication(Boolean.parseBoolean(helperParameters.getFirstValue(\"needClientAuthentication\", true, \"false\")));\r\n    setProtocol(helperParameters.getFirstValue(\"protocol\", true, \"TLS\"));\r\n    setSecureRandomAlgorithm(helperParameters.getFirstValue(\"secureRandomAlgorithm\", true));\r\n    setTrustManagerAlgorithm(helperParameters.getFirstValue(\"trustManagerAlgorithm\", true, System.getProperty(\"ssl.TrustManagerFactory.algorithm\", \"SunX509\")));\r\n    setTrustStorePassword(helperParameters.getFirstValue(\"trustStorePassword\", true, System.getProperty(\"javax.net.ssl.trustStorePassword\")));\r\n    setTrustStorePath(helperParameters.getFirstValue(\"trustStorePath\", true, System.getProperty(\"javax.net.ssl.trustStore\")));\r\n    setTrustStoreType(helperParameters.getFirstValue(\"trustStoreType\", true, System.getProperty(\"javax.net.ssl.trustStoreType\")));\r\n    setWantClientAuthentication(Boolean.parseBoolean(helperParameters.getFirstValue(\"wantClientAuthentication\", true, \"false\")));\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.AbstractUriBuilder.replacePath",
	"Comment": "replaces the current path with the given path. this method checks, ifthere is an extension in, if needed by this class.",
	"Method": "UriBuilder replacePath(CharSequence newPath,UriBuilder replacePath,String newPath){\r\n    return replacePath((CharSequence) newPath);\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.toEdmKey",
	"Comment": "converts a value to the string representation of the target wcf type whenused a key in the uris.",
	"Method": "String toEdmKey(Object value,Type type){\r\n    String adoNetType = type.getName();\r\n    if (value == null || adoNetType == null) {\r\n        return null;\r\n    }\r\n    String result = null;\r\n    if (adoNetType.endsWith(\"Binary\")) {\r\n        if ((byte[].class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmBinary((byte[]) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Boolean\")) {\r\n        if ((Boolean.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmBoolean((Boolean) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"DateTime\")) {\r\n        if ((Date.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmDateTime((Date) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"DateTimeOffset\")) {\r\n        if ((Date.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmDateTime((Date) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Time\")) {\r\n        if ((Long.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmTime((Long) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Decimal\")) {\r\n        if ((Double.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmDecimal((Double) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Single\")) {\r\n        if ((Float.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmSingle((Float) value);\r\n        } else if ((Double.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmSingle((Double) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Double\")) {\r\n        if ((Double.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmDouble((Double) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Guid\")) {\r\n        result = value.toString();\r\n    } else if (adoNetType.endsWith(\"Int16\")) {\r\n        if ((Short.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmInt16((Short) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Int32\")) {\r\n        if ((Integer.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmInt32((Integer) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Int64\")) {\r\n        if ((Long.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmInt64((Long) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"Byte\")) {\r\n        if ((Byte.class).isAssignableFrom(value.getClass())) {\r\n            result = toEdmByte((Byte) value);\r\n        }\r\n    } else if (adoNetType.endsWith(\"String\")) {\r\n        result = \"'\" + value.toString() + \"'\";\r\n    }\r\n    if (result == null) {\r\n        result = value.toString();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.service.TaskService.setCorePoolSize",
	"Comment": "sets the core pool size defining the maximum number of threads.",
	"Method": "void setCorePoolSize(int corePoolSize){\r\n    this.corePoolSize = corePoolSize;\r\n}"
}, {
	"Path": "org.restlet.ext.gae.GaeEnroler.enrole",
	"Comment": "adds admin role object if user is an administrator according to googleapp engine userservice.",
	"Method": "void enrole(ClientInfo info){\r\n    if (UserServiceFactory.getUserService().isUserAdmin() && getAdminRole() != null) {\r\n        info.getRoles().add(getAdminRole());\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.nio.BaseHelper.getInboundMessages",
	"Comment": "returns the queue of inbound messages pending for handling.",
	"Method": "Queue<Response> getInboundMessages(){\r\n    return inboundMessages;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxb.JaxbRepresentation.isFragment",
	"Comment": "indicates whether or not document level events will be generated by themarshaller.",
	"Method": "boolean isFragment(){\r\n    return fragment;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.ParameterInfo.setRepeating",
	"Comment": "indicates whether the parameter is single valued or may have multiplevalues.",
	"Method": "void setRepeating(boolean repeating){\r\n    this.repeating = repeating;\r\n}"
}, {
	"Path": "org.restlet.representation.Variant.equals",
	"Comment": "indicates if the current variant is equal to the given variant.",
	"Method": "boolean equals(Object other){\r\n    if (other == this) {\r\n        return true;\r\n    }\r\n    if (!(other instanceof Variant)) {\r\n        return false;\r\n    }\r\n    Variant that = (Variant) other;\r\n    return Objects.equals(getCharacterSet(), that.getCharacterSet()) && Objects.equals(getMediaType(), that.getMediaType()) && getLanguages().equals(that.getLanguages()) && getEncodings().equals(that.getEncodings()) && Objects.equals(getLocationRef(), that.getLocationRef());\r\n}"
}, {
	"Path": "org.restlet.engine.RestletHelper.getAttributes",
	"Comment": "returns the map of attributes exchanged between the api and the enginevia this helper.",
	"Method": "Map<String, Object> getAttributes(){\r\n    return this.attributes;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Query.getSubpath",
	"Comment": "returns the path of the targeted entity relatively to the data serviceuri.",
	"Method": "String getSubpath(){\r\n    return subpath;\r\n}"
}, {
	"Path": "org.restlet.ext.simple.SimpleServerHelper.getDefaultThreads",
	"Comment": "returns the default number of polling threads for a handler object.",
	"Method": "int getDefaultThreads(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"defaultThreads\", \"5\"));\r\n}"
}, {
	"Path": "org.restlet.engine.converter.ConverterHelper.addVariants",
	"Comment": "returns the list of variants that can be converted from a given objectclass.",
	"Method": "List<VariantInfo> addVariants(Class<?> sourceClass,Variant targetVariant,List<VariantInfo> variants){\r\n    List<VariantInfo> helperVariants = getVariants(sourceClass);\r\n    if (helperVariants != null) {\r\n        for (VariantInfo helperVariant : helperVariants) {\r\n            if (targetVariant == null) {\r\n                variants = addVariant(variants, helperVariant);\r\n            } else if (helperVariant.includes(targetVariant)) {\r\n                variants = addVariant(variants, new VariantInfo(targetVariant.getMediaType()));\r\n            } else if (targetVariant.includes(helperVariant)) {\r\n                variants = addVariant(variants, helperVariant);\r\n            }\r\n        }\r\n    }\r\n    return variants;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.channel.WritableBufferedChannel.write",
	"Comment": "reads some bytes and put them into the destination buffer. the bytes comefrom the underlying channel.",
	"Method": "int write(ByteBuffer sourceBuffer){\r\n    return getBuffer().process(this, 0, sourceBuffer);\r\n}"
}, {
	"Path": "org.restlet.engine.resource.VariantInfo.setInputScore",
	"Comment": "sets the affinity between this variant and an incoming representation.",
	"Method": "void setInputScore(float inputScore){\r\n    this.inputScore = inputScore;\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.getRetryAttempts",
	"Comment": "returns the number of retry attempts before reporting an error. defaultvalue is 2.",
	"Method": "int getRetryAttempts(){\r\n    return retryAttempts;\r\n}"
}, {
	"Path": "org.restlet.resource.ServerResource.isAnnotated",
	"Comment": "indicates if annotations are supported. the default value is true.",
	"Method": "boolean isAnnotated(){\r\n    return annotated;\r\n}"
}, {
	"Path": "org.restlet.ext.javamail.JavaMailClientHelper.createRepresentation",
	"Comment": "creates an xml representation based on a list of javamail messages.",
	"Method": "Representation createRepresentation(Message message,Representation createRepresentation,Message[] messages,POP3Folder inbox){\r\n    return new MessagesRepresentation(messages, inbox);\r\n}"
}, {
	"Path": "org.restlet.ext.xml.TransformRepresentation.getParameters",
	"Comment": "returns the modifiable map of jaxp transformer parameters.",
	"Method": "Map<String, Object> getParameters(){\r\n    return this.parameters;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.ConnectionHelper.getMaxTotalConnections",
	"Comment": "returns the maximum number of concurrent connections allowed. by default,it is unbounded.",
	"Method": "int getMaxTotalConnections(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"maxTotalConnections\", \"-1\"));\r\n}"
}, {
	"Path": "org.restlet.routing.Router.setMaxAttempts",
	"Comment": "sets the maximum number of attempts if no attachment could be matched onthe first attempt. this is useful when the attachment scoring is dynamicand therefore could change on a retry.",
	"Method": "void setMaxAttempts(int maxAttempts){\r\n    this.maxAttempts = maxAttempts;\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.HttpClientHelper.getResponseBufferSize",
	"Comment": "the size in bytes of the buffer used to read responses. defaults to16384.",
	"Method": "int getResponseBufferSize(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"responseBufferSize\", \"16384\"));\r\n}"
}, {
	"Path": "org.restlet.resource.Directory.getComparator",
	"Comment": "returns the reference comparator used to sort index pages. the defaultimplementation used a friendly alphanum sorting.",
	"Method": "Comparator<Reference> getComparator(){\r\n    return this.comparator;\r\n}"
}, {
	"Path": "org.restlet.ext.sdc.internal.SdcServerConnection.getKey",
	"Comment": "returns the authorization key composed of the email address and thepassword separated by a colon character.",
	"Method": "String getKey(){\r\n    return key;\r\n}"
}, {
	"Path": "org.restlet.engine.header.HeaderWriter.appendComment",
	"Comment": "appends a string as an http comment, surrounded by parenthesis and withquoted pairs if needed.",
	"Method": "HeaderWriter<V> appendComment(String content){\r\n    append('(');\r\n    char c;\r\n    for (int i = 0; i < content.length(); i++) {\r\n        c = content.charAt(i);\r\n        if (HeaderUtils.isCommentText(c)) {\r\n            append(c);\r\n        } else {\r\n            appendQuotedPair(c);\r\n        }\r\n    }\r\n    return append(')');\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.Property.setConcurrent",
	"Comment": "indicates if this property should be used for optimistic concurrencychecks.",
	"Method": "void setConcurrent(boolean concurrent){\r\n    this.concurrent = concurrent;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.Resolver.resolveDottedName",
	"Comment": "resolves any dotted reference, returning the scopeidentified by the reference.",
	"Method": "IClass resolveDottedName(SymTabAST tree,Scope location,IClass context,boolean referencePhase){\r\n    IClass result = null;\r\n    IClass localContext = context;\r\n    String name = null;\r\n    DotIterator it = new DotIterator(tree);\r\n    while (it.hasNext()) {\r\n        SymTabAST node = it.nextNode();\r\n        if (node.getType() != TokenTypes.COMMA) {\r\n            localContext = resolveExpression(node, location, localContext, referencePhase);\r\n            if (localContext == null) {\r\n                node.setMeaningfulness(false);\r\n                name = node.getText();\r\n                while (localContext == null && it.hasNext()) {\r\n                    SymTabAST next = it.nextNode();\r\n                    name = name + \".\" + next.getText();\r\n                    localContext = location.getClassDefinition(name);\r\n                    if (localContext != null && referencePhase) {\r\n                        next.setDefinition(localContext, location, referencePhase);\r\n                    } else {\r\n                        next.setMeaningfulness(false);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (localContext != null) {\r\n        result = localContext;\r\n    } else {\r\n        result = new UnknownClass(name, tree);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlRepresentation.setIgnoringComments",
	"Comment": "indicates if the parser will ignore comments. by default the value ofthis is set to false.",
	"Method": "void setIgnoringComments(boolean ignoringComments){\r\n    this.ignoringComments = ignoringComments;\r\n}"
}, {
	"Path": "org.restlet.security.Realm.getEnroler",
	"Comment": "returns an enroler that can add the user roles based on user principals.",
	"Method": "Enroler getEnroler(){\r\n    return enroler;\r\n}"
}, {
	"Path": "org.restlet.ext.simple.internal.SimpleServer.process",
	"Comment": "pass in the connection socket and add the engine to the pipelineattributes.",
	"Method": "void process(Socket socket){\r\n    Map<String, Object> map = socket.getAttributes();\r\n    SSLEngine engine = socket.getEngine();\r\n    SocketChannel channel = socket.getChannel();\r\n    map.put(PROPERTY_ENGINE, engine);\r\n    map.put(PROPERTY_SOCKET, channel);\r\n    server.process(socket);\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.DefaultSslContextFactory.setKeyStorePath",
	"Comment": "sets the path to the keystore file. the default value is that of thejavax.net.ssl.keystore system property.",
	"Method": "void setKeyStorePath(String keyStorePath){\r\n    this.keyStorePath = keyStorePath;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.BaseHelper.control",
	"Comment": "controls the helper for inbound or outbound messages to handle.",
	"Method": "boolean control(){\r\n    boolean result = false;\r\n    int size;\r\n    size = getInboundMessages().size();\r\n    for (int i = 0; i < size; i++) {\r\n        handleInbound(getInboundMessages().poll());\r\n    }\r\n    size = getOutboundMessages().size();\r\n    for (int i = 0; i < size; i++) {\r\n        handleOutbound(getOutboundMessages().poll());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.security.RoleAuthorizer.setForbiddenRoles",
	"Comment": "sets the modifiable list of forbidden roles. this method clears thecurrent list and adds all entries in the parameter list.",
	"Method": "void setForbiddenRoles(List<Role> forbiddenRoles){\r\n    synchronized (getForbiddenRoles()) {\r\n        if (forbiddenRoles != getForbiddenRoles()) {\r\n            getForbiddenRoles().clear();\r\n            if (forbiddenRoles != null) {\r\n                getForbiddenRoles().addAll(forbiddenRoles);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.core.ThreadLocalizedExtendedUriInfo.getBaseUriBuilder",
	"Comment": "get the base uri of the application in the form of a uribuilder. it alsoincludes the extension of the current request.",
	"Method": "ExtendedUriBuilder getBaseUriBuilder(){\r\n    return getCallContext().getBaseUriBuilderExtended();\r\n}"
}, {
	"Path": "org.restlet.Application.setRoles",
	"Comment": "sets the modifiable list of roles. this method clears the current listand adds all entries in the parameter list.",
	"Method": "void setRoles(List<Role> roles){\r\n    synchronized (getRoles()) {\r\n        if (roles != getRoles()) {\r\n            getRoles().clear();\r\n            if (roles != null) {\r\n                getRoles().addAll(roles);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.data.Method.isSafe",
	"Comment": "indicates if it should have the significance of taking an action otherthan retrieval.",
	"Method": "boolean isSafe(){\r\n    return safe;\r\n}"
}, {
	"Path": "org.restlet.engine.Engine.findHelper",
	"Comment": "finds the authenticator helper supporting the given scheme.",
	"Method": "org.restlet.engine.converter.ConverterHelper findHelper(org.restlet.engine.security.AuthenticatorHelper findHelper,ChallengeScheme challengeScheme,boolean clientSide,boolean serverSide){\r\n    org.restlet.engine.security.AuthenticatorHelper result = null;\r\n    List<org.restlet.engine.security.AuthenticatorHelper> helpers = getRegisteredAuthenticators();\r\n    org.restlet.engine.security.AuthenticatorHelper current;\r\n    for (int i = 0; (result == null) && (i < helpers.size()); i++) {\r\n        current = helpers.get(i);\r\n        if (current.getChallengeScheme().equals(challengeScheme) && ((clientSide && current.isClientSide()) || !clientSide) && ((serverSide && current.isServerSide()) || !serverSide)) {\r\n            result = helpers.get(i);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Service.getValue",
	"Comment": "returns the binary representation of the given media resource. if theentity is not a media resource, it returns null.",
	"Method": "Representation getValue(Object entity,Representation getValue,Object entity,List<Preference<MediaType>> acceptedMediaTypes,Representation getValue,Object entity,MediaType mediaType){\r\n    Reference ref = getValueRef(entity);\r\n    if (ref != null) {\r\n        ClientResource cr = createResource(ref);\r\n        return cr.get(mediaType);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.engine.io.InputStreamChannel.isOpen",
	"Comment": "indicates if the channel and its underlying stream are open.",
	"Method": "boolean isOpen(){\r\n    return this.open;\r\n}"
}, {
	"Path": "org.restlet.ext.httpclient.HttpClientHelper.getStopIdleTimeout",
	"Comment": "returns the minimum idle time, in milliseconds, for connections to beclosed when stopping the connector.",
	"Method": "int getStopIdleTimeout(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"stopIdleTimeout\", \"60000\"));\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.Util.notStartsWith",
	"Comment": "checks, if the given charsequence starts with the given character.",
	"Method": "boolean notStartsWith(CharSequence charSequence,char character){\r\n    if (charSequence == null)\r\n        return true;\r\n    if (charSequence.length() == 0)\r\n        return true;\r\n    return charSequence.charAt(0) != character;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.provider.JaxbProvider.setExpandingEntityRefs",
	"Comment": "indicates if the parser will expand entity reference nodes. by defaultthe value of this is set to true.",
	"Method": "void setExpandingEntityRefs(boolean expandEntityRefs){\r\n    this.expandingEntityRefs = expandEntityRefs;\r\n}"
}, {
	"Path": "org.restlet.engine.local.ZipClientHelper.handleLocal",
	"Comment": "handles a call for a local entity. by default, only get and head methodsare implemented.",
	"Method": "void handleLocal(Request request,Response response,String decodedPath){\r\n    int spi = decodedPath.indexOf(\"!/\");\r\n    String fileUri;\r\n    String entryName;\r\n    if (spi != -1) {\r\n        fileUri = decodedPath.substring(0, spi);\r\n        entryName = decodedPath.substring(spi + 2);\r\n    } else {\r\n        fileUri = decodedPath;\r\n        entryName = \"\";\r\n    }\r\n    LocalReference fileRef = new LocalReference(fileUri);\r\n    if (Protocol.FILE.equals(fileRef.getSchemeProtocol())) {\r\n        final File file = fileRef.getFile();\r\n        if (Method.GET.equals(request.getMethod()) || Method.HEAD.equals(request.getMethod())) {\r\n            handleGet(request, response, file, entryName, getMetadataService());\r\n        } else if (Method.PUT.equals(request.getMethod())) {\r\n            handlePut(request, response, file, entryName);\r\n        } else {\r\n            response.setStatus(Status.CLIENT_ERROR_METHOD_NOT_ALLOWED);\r\n            response.getAllowedMethods().add(Method.GET);\r\n            response.getAllowedMethods().add(Method.HEAD);\r\n            response.getAllowedMethods().add(Method.PUT);\r\n        }\r\n    } else {\r\n        response.setStatus(Status.SERVER_ERROR_NOT_IMPLEMENTED, \"Only works on local files.\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.util.ImmutableDate.setSeconds",
	"Comment": "as an immutabledate is immutable, this method throws anunsupportedoperationexception exception.",
	"Method": "void setSeconds(int arg0){\r\n    throw new UnsupportedOperationException(\"ImmutableDate is immutable\");\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.controller.ConnectionController.updateKeys",
	"Comment": "updates all the selection registrations for new interest or cancellation.",
	"Method": "void updateKeys(){\r\n    SelectionRegistration updatedRegistration = getUpdatedRegistrations().poll();\r\n    while (updatedRegistration != null) {\r\n        if (getHelper().getLogger().isLoggable(Level.FINER)) {\r\n            getHelper().getLogger().log(Level.FINER, \"Updating NIO interest with selector: \" + updatedRegistration);\r\n        }\r\n        updatedRegistration.update();\r\n        updatedRegistration = getUpdatedRegistrations().poll();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.xdb.internal.ChunkedInputStream.close",
	"Comment": "closes this input stream but do not close the underlying stream.",
	"Method": "void close(){\r\n    super.close();\r\n    this.initialized = true;\r\n    onEndReached();\r\n}"
}, {
	"Path": "org.restlet.ext.httpclient.HttpClientHelper.getIdleTimeout",
	"Comment": "returns the time in ms beyond which idle connections are eligible forreaping. the default value is 60000 ms.",
	"Method": "long getIdleTimeout(){\r\n    return Long.parseLong(getHelpedParameters().getFirstValue(\"idleTimeout\", \"60000\"));\r\n}"
}, {
	"Path": "org.restlet.engine.application.ApplicationHelper.handle",
	"Comment": "in addition to the default behavior, it saves the current applicationinstance into the current thread.",
	"Method": "void handle(Request request,Response response){\r\n    Application current = Application.getCurrent();\r\n    Application.setCurrent(getHelped());\r\n    try {\r\n        super.handle(request, response);\r\n    } finally {\r\n        Application.setCurrent(current);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.Context.setDefaultEnroler",
	"Comment": "sets an enroler that can add the user roles based on authenticated userprincipals.",
	"Method": "void setDefaultEnroler(org.restlet.security.Enroler enroler){\r\n    this.defaultEnroler = enroler;\r\n}"
}, {
	"Path": "org.restlet.data.ChallengeMessage.getOpaque",
	"Comment": "returns an opaque string of data which should be returned by the clientunchanged.",
	"Method": "String getOpaque(){\r\n    return opaque;\r\n}"
}, {
	"Path": "com.restfb.types.webhook.messaging.PolicyEnforcementItem.isBlock",
	"Comment": "convenience method to check the action of the policy enforcement",
	"Method": "boolean isBlock(){\r\n    return BLOCK.equals(action);\r\n}"
}, {
	"Path": "org.restlet.test.ext.jaxrs.services.tests.JaxRsTestCase.createPrefColl",
	"Comment": "creates a singleton collection with the given mediatype as preference.",
	"Method": "Collection<Preference<MediaType>> createPrefColl(MediaType accMediaType,float mediaTypeQuality){\r\n    if (accMediaType == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    return Collections.singleton(new Preference<MediaType>(accMediaType, mediaTypeQuality));\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.MetadataReader.discoverMapping",
	"Comment": "explores the given attributes in order to get a declared propertymapping.",
	"Method": "void discoverMapping(EntityType type,Property property,Metadata metadata,Attributes attributes){\r\n    String contentKind = null;\r\n    String nsPrefix = null;\r\n    String nsUri = null;\r\n    String propertyPath = null;\r\n    String valuePath = null;\r\n    boolean keepInContent = true;\r\n    contentKind = attributes.getValue(Service.WCF_DATASERVICES_METADATA_NAMESPACE, \"FC_ContentKind\");\r\n    if (contentKind == null) {\r\n        contentKind = \"text\";\r\n    }\r\n    nsPrefix = attributes.getValue(Service.WCF_DATASERVICES_METADATA_NAMESPACE, \"FC_NsPrefix\");\r\n    nsUri = attributes.getValue(Service.WCF_DATASERVICES_METADATA_NAMESPACE, \"FC_NsUri\");\r\n    String str = attributes.getValue(Service.WCF_DATASERVICES_METADATA_NAMESPACE, \"FC_KeepInContent\");\r\n    if (str != null) {\r\n        keepInContent = Boolean.parseBoolean(str);\r\n    }\r\n    if (property == null) {\r\n        propertyPath = attributes.getValue(Service.WCF_DATASERVICES_METADATA_NAMESPACE, \"FC_SourcePath\");\r\n    } else {\r\n        propertyPath = property.getName();\r\n    }\r\n    valuePath = attributes.getValue(Service.WCF_DATASERVICES_METADATA_NAMESPACE, \"FC_TargetPath\");\r\n    if (propertyPath != null && valuePath != null && !keepInContent) {\r\n        if ((nsUri == null && nsPrefix == null) || (nsUri != null && nsPrefix != null)) {\r\n            metadata.getMappings().add(new Mapping(type, nsPrefix, nsUri, propertyPath, valuePath, contentKind));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.Context.getDefaultEnroler",
	"Comment": "returns an enroler that can add the user roles based on authenticateduser principals.",
	"Method": "org.restlet.security.Enroler getDefaultEnroler(){\r\n    return defaultEnroler;\r\n}"
}, {
	"Path": "com.restfb.testutils.AssertJson.assertEquals",
	"Comment": "tests to json objects as strings for equality.all primitive json entities are checked viathe provides equals method. primitive json entities are boolean, strings, float, ints and so on.arrays need to be in the same order because we convert them into arraylists and therefore itis important that the order is the sameobjects need the same keys, but the order may be different and is not checked.",
	"Method": "void assertEquals(String expected,String actual){\r\n    JsonValue expectedJson = null;\r\n    JsonValue actualJson = null;\r\n    if (expected instanceof String) {\r\n        expectedJson = Json.parse((String) expected);\r\n    }\r\n    if (actual instanceof String) {\r\n        actualJson = Json.parse((String) actual);\r\n    }\r\n    failIfNotEquals(null, expectedJson, actualJson);\r\n}"
}, {
	"Path": "org.restlet.ext.html.FormDataSet.createMultipartMediaType",
	"Comment": "creates the media type of a multipart form which must include the usedboundary.",
	"Method": "MediaType createMultipartMediaType(String boundary){\r\n    Series<Parameter> params = new Series<Parameter>(Parameter.class);\r\n    params.add(\"boundary\", boundary);\r\n    MediaType result = new MediaType(MediaType.MULTIPART_FORM_DATA.getName(), params);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.CookieAuthenticator.setCookieName",
	"Comment": "sets the cookie name to use for the authentication credentials.",
	"Method": "void setCookieName(String cookieName){\r\n    this.cookieName = cookieName;\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipRequest.setHandled",
	"Comment": "indicates that the request has been handled, typically after receiving afinal response.",
	"Method": "void setHandled(boolean handled){\r\n    this.handled = handled;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.Util.equals",
	"Comment": "check if the given objects are equal. can deal with null references. ifboth elements are null, than the result is true.",
	"Method": "boolean equals(Object object1,Object object2){\r\n    if (object1 == null) {\r\n        return object2 == null;\r\n    }\r\n    return object1.equals(object2);\r\n}"
}, {
	"Path": "org.restlet.ext.osgi.BaseRouterProvider.bindDefaultResourceProvider",
	"Comment": "called by osgi ds to inject the default resource provider service",
	"Method": "void bindDefaultResourceProvider(ResourceProvider resourceProvider){\r\n    defaultRestletProvider = resourceProvider;\r\n    if (router != null)\r\n        router.attachDefault(resourceProvider.getInboundRoot(router.getContext()));\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipClientResource.refer",
	"Comment": "indicates that the target recipient should contact a third party usingthe contact information provided in the request.",
	"Method": "void refer(){\r\n    handle(SipMethod.REFER);\r\n}"
}, {
	"Path": "org.restlet.engine.converter.StatusInfoHtmlConverter.isCompatible",
	"Comment": "indicates if the given variant is compatible with the media typessupported by this converter.",
	"Method": "boolean isCompatible(Variant variant){\r\n    return (variant != null) && (VARIANT_TEXT_HTML.isCompatible(variant) || VARIANT_APPLICATION_XHTML.isCompatible(variant));\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Link.getHrefLang",
	"Comment": "returns the language of the resource pointed to by the href attribute.",
	"Method": "Language getHrefLang(){\r\n    return this.hrefLang;\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.cafecustofeeds.CafeCustoFeedsService.createContactQuery",
	"Comment": "creates a query for contact entities hosted by this service.",
	"Method": "Query<Contact> createContactQuery(String subpath){\r\n    return createQuery(subpath, Contact.class);\r\n}"
}, {
	"Path": "org.restlet.ext.oauth.AccessTokenServerResource.responseTokenRepresentation",
	"Comment": "generates a json document with valid token. the format of the json document is according to 5.1. successfulresponse.",
	"Method": "Representation responseTokenRepresentation(Token token,String[] requestedScope){\r\n    JSONObject response = new JSONObject();\r\n    response.put(TOKEN_TYPE, token.getTokenType());\r\n    response.put(ACCESS_TOKEN, token.getAccessToken());\r\n    response.put(EXPIRES_IN, token.getExpirePeriod());\r\n    String refreshToken = token.getRefreshToken();\r\n    if (!StringUtils.isNullOrEmpty(refreshToken)) {\r\n        response.put(REFRESH_TOKEN, refreshToken);\r\n    }\r\n    String[] scope = token.getScope();\r\n    if (requestedScope == null || !Scopes.isIdentical(scope, requestedScope)) {\r\n        response.put(SCOPE, Scopes.toString(scope));\r\n    }\r\n    addCacheDirective(getResponse(), CacheDirective.noStore());\r\n    getResponse().getHeaders().add(HeaderConstants.HEADER_PRAGMA, \"no-cache\");\r\n    return new JsonRepresentation(response);\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipRequest.getPriority",
	"Comment": "returns the urgency of the request as perceived by the client.",
	"Method": "Priority getPriority(){\r\n    return priority;\r\n}"
}, {
	"Path": "org.restlet.util.WrapperList.iterator",
	"Comment": "returns an iterator over the elements in this list in proper sequence.",
	"Method": "Iterator<E> iterator(){\r\n    return getDelegate().iterator();\r\n}"
}, {
	"Path": "org.restlet.Component.getHosts",
	"Comment": "returns the modifiable list of virtual hosts. note that the order ofvirtual hosts in this list will be used to check the first one thatmatches.",
	"Method": "List<VirtualHost> getHosts(){\r\n    return this.hosts;\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.HttpClientHelper.getRequestBufferSize",
	"Comment": "the size in bytes of the buffer used to write requests. defaults to 4096.",
	"Method": "int getRequestBufferSize(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"requestBufferSize\", \"4096\"));\r\n}"
}, {
	"Path": "org.restlet.data.Conditions.getStatus",
	"Comment": "returns the conditional status of a variant using a given method.",
	"Method": "Status getStatus(Method method,boolean entityExists,Tag tag,Date modificationDate,Status getStatus,Method method,RepresentationInfo representationInfo){\r\n    return getStatus(method, representationInfo != null, (representationInfo == null) ? null : representationInfo.getTag(), (representationInfo == null) ? null : representationInfo.getModificationDate());\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Service.getSimpleValue",
	"Comment": "extracts a string value from the representation of a property or afunction, or a service operation, when this representation wraps an edmsimple type.",
	"Method": "String getSimpleValue(Representation representation,String tagName){\r\n    String result = null;\r\n    if (representation == null) {\r\n        return result;\r\n    }\r\n    if (MediaType.APPLICATION_ALL_XML.isCompatible(representation.getMediaType()) || MediaType.TEXT_XML.isCompatible(representation.getMediaType())) {\r\n        DomRepresentation xmlRep = new DomRepresentation(representation);\r\n        Node node = xmlRep.getNode(\"//\" + tagName);\r\n        if (node != null) {\r\n            result = node.getTextContent();\r\n        }\r\n    } else {\r\n        result = representation.getText();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.data.RecipientInfo.getProtocol",
	"Comment": "returns the protocol used to communicate with the recipient.",
	"Method": "Protocol getProtocol(){\r\n    return protocol;\r\n}"
}, {
	"Path": "org.restlet.routing.Template.appendClass",
	"Comment": "appends to a pattern a repeating group of a given content based on aclass of characters.",
	"Method": "void appendClass(StringBuilder pattern,String content,boolean required){\r\n    pattern.append(\"(\");\r\n    if (content.equals(\".\")) {\r\n        pattern.append(content);\r\n    } else {\r\n        pattern.append(\"[\").append(content).append(']');\r\n    }\r\n    if (required) {\r\n        pattern.append(\"+\");\r\n    } else {\r\n        pattern.append(\"*\");\r\n    }\r\n    pattern.append(\")\");\r\n}"
}, {
	"Path": "org.restlet.example.book.restlet.ch09.client.MailList.setListener",
	"Comment": "sets the listener that will be notified when an item is selected.",
	"Method": "void setListener(Listener listener){\r\n    this.listener = listener;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.EncodeOrCheck.checkForInvalidUriChars",
	"Comment": "checks, if the string contains characters that are reserved in uris.",
	"Method": "void checkForInvalidUriChars(CharSequence uriPart,int indexForErrMessage,String errMessName){\r\n    final int l = uriPart.length();\r\n    boolean inVar = false;\r\n    for (int i = 0; i < l; i++) {\r\n        final char c = uriPart.charAt(i);\r\n        if (inVar) {\r\n            if (c == '}') {\r\n                inVar = false;\r\n            }\r\n            continue;\r\n        }\r\n        switch(c) {\r\n            case '{':\r\n                inVar = true;\r\n                continue;\r\n            case ':':\r\n            case '/':\r\n            case '?':\r\n            case '#':\r\n            case '[':\r\n            case ']':\r\n            case '@':\r\n            case '!':\r\n            case '$':\r\n            case '&':\r\n            case '\\'':\r\n            case '(':\r\n            case ')':\r\n            case '*':\r\n            case '+':\r\n            case ',':\r\n            case ';':\r\n            case '=':\r\n                throw throwIllegalArgExc(indexForErrMessage, errMessName, uriPart, \" contains at least one reservec character: \" + c + \". They must be encoded.\");\r\n        }\r\n        if ((c == ' ') || (c < 32) || (c >= 127)) {\r\n            throw throwIllegalArgExc(indexForErrMessage, errMessName, uriPart, \" contains at least one illegal character: \" + c + \". They must be encoded.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.application.DecodeRepresentation.getText",
	"Comment": "converts the representation to a string value. be careful when using thismethod as the conversion of large content to a string fully stored inmemory can result in outofmemoryerrors being thrown.",
	"Method": "String getText(){\r\n    if (isDecoding()) {\r\n        return IoUtils.toString(getStream(), getCharacterSet());\r\n    } else {\r\n        return getWrappedRepresentation().getText();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.swagger.v1_2.SwaggerReader.validate",
	"Comment": "indicates if the given resource listing and list of api declarationsmatch.",
	"Method": "void validate(ResourceListing resourceListing,Map<String, ApiDeclaration> apiDeclarations){\r\n    int rlSize = resourceListing.getApis().size();\r\n    int adSize = apiDeclarations.size();\r\n    if (rlSize < adSize) {\r\n        throw new TranslationException(\"file\", \"Some API declarations are not mapped in your resource listing\");\r\n    } else if (rlSize > adSize) {\r\n        throw new TranslationException(\"file\", \"Some API declarations are missing\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.buffer.Buffer.compact",
	"Comment": "compacts the bytes to be drained at the beginning of the buffer.",
	"Method": "void compact(){\r\n    if (isDraining()) {\r\n        getBytes().compact();\r\n        getBytes().flip();\r\n    } else {\r\n        flip();\r\n        compact();\r\n        flip();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.test.ext.jaxrs.services.tests.JaxRsTestCase.createReference",
	"Comment": "creates an reference that access the localhost with the jaxrstesterprotocol and the jaxrstester port. it uses the path of the givenjaxrsclass",
	"Method": "Reference createReference(Class<?> jaxRsClass,String subPath,Reference createReference,String subPath,Reference createReference,String path,String subPath){\r\n    final Reference reference = createBaseRef();\r\n    reference.setBaseRef(createBaseRef());\r\n    if (!path.startsWith(\"/\")) {\r\n        path = \"/\" + path;\r\n    }\r\n    if (subPath != null) {\r\n        if (subPath.startsWith(\";\")) {\r\n            path += subPath;\r\n        } else if (subPath.length() > 0) {\r\n            if (path.endsWith(\"/\") || subPath.startsWith(\"/\")) {\r\n                path += subPath;\r\n            } else {\r\n                path += \"/\" + subPath;\r\n            }\r\n        }\r\n    }\r\n    reference.setPath(path);\r\n    return reference;\r\n}"
}, {
	"Path": "org.restlet.Application.getConverterService",
	"Comment": "returns the converter service. the service is enabled by default.",
	"Method": "ConverterService getConverterService(){\r\n    return getServices().get(ConverterService.class);\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsApplication.getObjectFactory",
	"Comment": "returns the objectfactory for root resource class and providerinstantiation, if given.",
	"Method": "ObjectFactory getObjectFactory(){\r\n    return this.jaxRsRestlet.getObjectFactory();\r\n}"
}, {
	"Path": "org.restlet.ext.html.internal.FormReader.readEntries",
	"Comment": "reads the entries whose name is a key in the given map. if a matchingentry is found, its value is put in the map. if multiple values arefound, a list is created and set in the map.",
	"Method": "void readEntries(Map<String, Object> entries){\r\n    FormData entry = readNextEntry();\r\n    Object currentValue = null;\r\n    while (entry != null) {\r\n        if (entries.containsKey(entry.getName())) {\r\n            currentValue = entries.get(entry.getName());\r\n            if (currentValue != null) {\r\n                List<Object> values = null;\r\n                if (currentValue instanceof List) {\r\n                    values = (List<Object>) currentValue;\r\n                } else {\r\n                    values = new ArrayList<Object>();\r\n                    values.add(currentValue);\r\n                    entries.put(entry.getName(), values);\r\n                }\r\n                if (entry.getValue() == null) {\r\n                    values.add(Series.EMPTY_VALUE);\r\n                } else {\r\n                    values.add(entry.getValue());\r\n                }\r\n            } else {\r\n                if (entry.getValue() == null) {\r\n                    entries.put(entry.getName(), Series.EMPTY_VALUE);\r\n                } else {\r\n                    entries.put(entry.getName(), entry.getValue());\r\n                }\r\n            }\r\n        }\r\n        entry = readNextEntry();\r\n    }\r\n    this.stream.close();\r\n}"
}, {
	"Path": "org.restlet.engine.header.HeaderReader.readComment",
	"Comment": "reads the next comment. the first character must be a parenthesis.",
	"Method": "String readComment(){\r\n    String result = null;\r\n    int next = read();\r\n    if (next == '(') {\r\n        StringBuilder buffer = new StringBuilder();\r\n        while (result == null) {\r\n            next = read();\r\n            if (isCommentText(next)) {\r\n                buffer.append((char) next);\r\n            } else if (isQuoteCharacter(next)) {\r\n                buffer.append((char) read());\r\n            } else if (next == '(') {\r\n                buffer.append('(').append(readComment()).append(')');\r\n            } else if (next == ')') {\r\n                result = buffer.toString();\r\n            } else if (next == -1) {\r\n                throw new IOException(\"Unexpected end of comment. Please check your value\");\r\n            } else {\r\n                throw new IOException(\"Invalid character \\\"\" + next + \"\\\" detected in comment. Please check your value\");\r\n            }\r\n        }\r\n    } else {\r\n        throw new IOException(\"A comment must start with a parenthesis\");\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.ReferenceVisitor.addMethodScope",
	"Comment": "includes a scope in the scope for checking method references.",
	"Method": "void addMethodScope(Scope aScope){\r\n    mMethodScopes.add(aScope);\r\n}"
}, {
	"Path": "org.restlet.ext.jsslutils.JsslutilsSslContextFactory.getSslContextFactory",
	"Comment": "returns the wrapped sslcontextfactory with which this instance was built.",
	"Method": "SSLContextFactory getSslContextFactory(){\r\n    return this.sslContextFactory;\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.DefaultSslContextFactory.setTrustStoreType",
	"Comment": "sets the keystore type of the trust store. the default value is that ofthe javax.net.ssl.truststoretype system property.",
	"Method": "void setTrustStoreType(String trustStoreType){\r\n    this.trustStoreType = trustStoreType;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Source.getSubtitle",
	"Comment": "returns the short summary, abstract, or excerpt of an entry.",
	"Method": "Text getSubtitle(){\r\n    return this.subtitle;\r\n}"
}, {
	"Path": "org.restlet.ext.swagger.Swagger2SpecificationRestlet.getSwagger",
	"Comment": "returns the representation of the whole resource listing of theapplication.",
	"Method": "Representation getSwagger(){\r\n    Swagger swagger = Swagger2Writer.getSwagger(getDefinition());\r\n    swagger.setSwagger(swaggerVersion);\r\n    JacksonRepresentation<Swagger> swaggerJacksonRepresentation = new JacksonRepresentation(swagger);\r\n    ObjectMapper objectMapper = swaggerJacksonRepresentation.getObjectMapper();\r\n    objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);\r\n    return swaggerJacksonRepresentation;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.EntryReader.startEntry",
	"Comment": "called when a new entry has been detected in the atom document.",
	"Method": "void startEntry(Entry entry){\r\n    if (this.entryReader != null) {\r\n        this.entryReader.startEntry(entry);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createTelephoneQuery",
	"Comment": "creates a query for telephone entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Telephone> createTelephoneQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Telephone.class);\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Entry.getRights",
	"Comment": "returns the information about rights held in and over an entry.",
	"Method": "Text getRights(){\r\n    return this.rights;\r\n}"
}, {
	"Path": "org.restlet.test.ext.apispark.conversion.swagger.v2_0.Swagger2TestCase.assertBothNull",
	"Comment": "asserts that the given objects are both null. returns true if it is the case, false otherwise.fails if one is null and not the other.",
	"Method": "boolean assertBothNull(Object savedObject,Object translatedObject){\r\n    if (savedObject == null || translatedObject == null) {\r\n        assertNull(savedObject);\r\n        assertNull(translatedObject);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.restlet.engine.resource.MethodAnnotationInfo.getResponseVariants",
	"Comment": "returns a list of response variants based on the annotation value.",
	"Method": "List<Variant> getResponseVariants(MetadataService metadataService,org.restlet.service.ConverterService converterService){\r\n    List<Variant> result = null;\r\n    if ((getJavaOutputType() != null) && (getJavaOutputType() != void.class) && (getJavaOutputType() != Void.class)) {\r\n        result = getVariants(metadataService, getOutput());\r\n        if (result == null) {\r\n            result = (List<Variant>) converterService.getVariants(getJavaOutputType(), null);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.Resolver.resolveIdent",
	"Comment": "resolves an ident node of an ast, creating the appropriate reference andreturning the scope of the identifer.",
	"Method": "IClass resolveIdent(SymTabAST ident,Scope location,IClass context,boolean referencePhase){\r\n    IClass result = null;\r\n    IDefinition def = null;\r\n    String name = ident.getText();\r\n    if (context != null) {\r\n        def = context.getVariableDefinition(name);\r\n    } else {\r\n        def = location.getVariableDefinition(name);\r\n    }\r\n    if (def != null) {\r\n        result = ((IVariable) def).getType();\r\n    } else {\r\n        if (context != null) {\r\n            result = context.getClassDefinition(name);\r\n        } else {\r\n            result = location.getClassDefinition(name);\r\n        }\r\n        def = result;\r\n    }\r\n    if (def != null) {\r\n        ident.setDefinition(def, location, referencePhase);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.retry",
	"Comment": "effectively retries a failed client call. by default, it sleeps beforethe retry attempt and increments the number of retries.",
	"Method": "void retry(Request request,Response response,List<Reference> references,int retryAttempt,Uniform next){\r\n    getLogger().log(Level.INFO, \"A recoverable error was detected (\" + response.getStatus().getCode() + \"), attempting again in \" + getRetryDelay() + \" ms.\");\r\n    if (getRetryDelay() > 0) {\r\n        try {\r\n            Thread.sleep(getRetryDelay());\r\n        } catch (InterruptedException e) {\r\n            getLogger().log(Level.FINE, \"Retry delay sleep was interrupted\", e);\r\n            Thread.currentThread().interrupt();\r\n        }\r\n    }\r\n    handle(request, response, references, ++retryAttempt, next);\r\n}"
}, {
	"Path": "org.restlet.engine.connector.HttpClientHelper.isFollowRedirects",
	"Comment": "indicates if the protocol will automatically follow redirects.",
	"Method": "boolean isFollowRedirects(){\r\n    return Boolean.parseBoolean(getHelpedParameters().getFirstValue(\"followRedirects\", \"false\"));\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.params.IntoRrcInjector.init",
	"Comment": "initiates the fields to cache the fields that needs injection.",
	"Method": "void init(Class<?> jaxRsClass,ThreadLocalizedContext tlContext,boolean lcEnc){\r\n    do {\r\n        for (final Field field : jaxRsClass.getDeclaredFields()) {\r\n            if (field.isAnnotationPresent(PathParam.class)) {\r\n                add(field, newPathParamGetter(field, tlContext, lcEnc));\r\n            } else if (field.isAnnotationPresent(CookieParam.class)) {\r\n                add(field, newCookieParamGetter(field, tlContext, lcEnc));\r\n            } else if (field.isAnnotationPresent(HeaderParam.class)) {\r\n                add(field, newHeaderParamGetter(field, tlContext, lcEnc));\r\n            } else if (field.isAnnotationPresent(MatrixParam.class)) {\r\n                add(field, newMatrixParamGetter(field, tlContext, lcEnc));\r\n            } else if (field.isAnnotationPresent(QueryParam.class)) {\r\n                add(field, newQueryParamGetter(field, tlContext, lcEnc));\r\n            }\r\n        }\r\n        for (final Method method : jaxRsClass.getDeclaredMethods()) {\r\n            if (isBeanSetter(method, PathParam.class)) {\r\n                add(method, newPathParamGetter(method, tlContext, lcEnc));\r\n            } else if (isBeanSetter(method, CookieParam.class)) {\r\n                add(method, newCookieParamGetter(method, tlContext, lcEnc));\r\n            } else if (isBeanSetter(method, HeaderParam.class)) {\r\n                add(method, newHeaderParamGetter(method, tlContext, lcEnc));\r\n            } else if (isBeanSetter(method, MatrixParam.class)) {\r\n                add(method, newMatrixParamGetter(method, tlContext, lcEnc));\r\n            } else if (isBeanSetter(method, QueryParam.class)) {\r\n                add(method, newQueryParamGetter(method, tlContext, lcEnc));\r\n            }\r\n        }\r\n        jaxRsClass = jaxRsClass.getSuperclass();\r\n    } while (jaxRsClass != null);\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.getNext",
	"Comment": "returns the next restlet. by default, it is the client dispatcher if acontext is available.",
	"Method": "Uniform getNext(){\r\n    Uniform result = this.next;\r\n    if (result == null) {\r\n        synchronized (this) {\r\n            if (result == null) {\r\n                result = createNext();\r\n                if (result != null) {\r\n                    setNext(result);\r\n                    this.nextCreated = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.AwsAuthenticator.getMaxRequestAge",
	"Comment": "returns the maximum age of a request, in milliseconds, before it isconsidered stale.a negative or zero value indicates no age restriction. the default valueis 15 minutes.",
	"Method": "long getMaxRequestAge(){\r\n    return getVerifier().getMaxRequestAge();\r\n}"
}, {
	"Path": "org.restlet.Application.getMetadataService",
	"Comment": "returns the metadata service. the service is enabled by default.",
	"Method": "MetadataService getMetadataService(){\r\n    return getServices().get(MetadataService.class);\r\n}"
}, {
	"Path": "org.restlet.service.Service.createOutboundFilter",
	"Comment": "create the filter that should be invoked for outgoing calls.",
	"Method": "org.restlet.routing.Filter createOutboundFilter(org.restlet.Context context){\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getHostPort",
	"Comment": "returns the optional port number for server based hierarchicalidentifiers.",
	"Method": "int getHostPort(){\r\n    int result = -1;\r\n    final String authority = getAuthority();\r\n    if (authority != null) {\r\n        int indexUI = authority.indexOf('@');\r\n        int indexIPV6 = authority.indexOf(']');\r\n        int index = authority.indexOf(':', (indexIPV6 == -1) ? indexUI : indexIPV6);\r\n        if (index != -1) {\r\n            try {\r\n                result = Integer.parseInt(authority.substring(index + 1));\r\n            } catch (NumberFormatException nfe) {\r\n                Context.getCurrentLogger().log(Level.WARNING, \"Can't parse hostPort : [hostRef,requestUri]=[\" + getBaseRef() + \",\" + this.internalRef + \"]\");\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.header.HeaderUtils.addHeader",
	"Comment": "adds a header to the given list. checks for exceptions and logs them.",
	"Method": "void addHeader(String headerName,String headerValue,Series<Header> headers){\r\n    if (headerName != null && !isNullOrEmpty(headerValue)) {\r\n        try {\r\n            headers.add(headerName, headerValue);\r\n        } catch (Throwable t) {\r\n            Context.getCurrentLogger().log(Level.WARNING, \"Unable to format the \" + headerName + \" header\", t);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.resource.Directory.isListingAllowed",
	"Comment": "indicates if the display of directory listings is allowed when no indexfile is found.",
	"Method": "boolean isListingAllowed(){\r\n    return this.listingAllowed;\r\n}"
}, {
	"Path": "org.restlet.ext.openid.OpenIdVerifier.addRequiredAttribute",
	"Comment": "adds an optional user attribute to retrieve during authentication",
	"Method": "void addRequiredAttribute(AttributeExchange attributeName){\r\n    this.requiredAttributes.add(attributeName);\r\n}"
}, {
	"Path": "org.restlet.engine.util.FormUtils.isParameterFound",
	"Comment": "indicates if the searched parameter is specified in the given mediarange.",
	"Method": "boolean isParameterFound(Parameter searchedParam,MediaType mediaRange){\r\n    boolean result = false;\r\n    for (Iterator<Parameter> iter = mediaRange.getParameters().iterator(); !result && iter.hasNext(); ) {\r\n        result = searchedParam.equals(iter.next());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.example.book.restlet.ch09.server.MailServerApplication.createInboundRoot",
	"Comment": "creates a root router to dispatch call to server resources.",
	"Method": "Restlet createInboundRoot(){\r\n    Router router = new Router(getContext());\r\n    router.attach(\"/\", RootServerResource.class);\r\n    router.attach(\"/accounts/\", AccountsServerResource.class);\r\n    router.attach(\"/accounts/{accountId}\", AccountServerResource.class);\r\n    router.attach(\"/accounts/{accountId}/mails/\", MailsServerResource.class);\r\n    router.attach(\"/accounts/{accountId}/mails/{mailId}\", MailServerResource.class);\r\n    router.attach(\"/accounts/{accountId}/contacts/\", ContactsServerResource.class);\r\n    router.attach(\"/accounts/{accountId}/contacts/{contactId}\", ContactServerResource.class);\r\n    return router;\r\n}"
}, {
	"Path": "org.restlet.ext.jdbc.JdbcResult.release",
	"Comment": "release the statement connection. to call when result navigation is done.",
	"Method": "void release(){\r\n    this.statement.getConnection().close();\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.JettyServerHelper.getThreadPoolStopTimeout",
	"Comment": "thread pool stop timeout in milliseconds. defaults to 5000.the maximum time allowed for the service to shutdown.",
	"Method": "long getThreadPoolStopTimeout(){\r\n    return Long.parseLong(getHelpedParameters().getFirstValue(\"threadPool.stopTimeout\", \"5000\"));\r\n}"
}, {
	"Path": "org.restlet.util.WrapperRequest.getAccessControlRequestHeaders",
	"Comment": "returns the access control request headers of the target resource.",
	"Method": "Set<String> getAccessControlRequestHeaders(){\r\n    return wrappedRequest.getAccessControlRequestHeaders();\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.EntityType.setBlobValueRefProperty",
	"Comment": "sets the name of the entity property that stores the blob reference.",
	"Method": "void setBlobValueRefProperty(Property blobValueRefProperty){\r\n    this.blobValueRefProperty = blobValueRefProperty;\r\n}"
}, {
	"Path": "org.restlet.data.Reference.normalize",
	"Comment": "normalizes the reference. useful before comparison between references orwhen building a target reference from a base and a relative references.",
	"Method": "Reference normalize(){\r\n    StringBuilder output = new StringBuilder();\r\n    StringBuilder input = new StringBuilder();\r\n    String path = getPath();\r\n    if (path != null) {\r\n        input.append(path);\r\n    }\r\n    while (input.length() > 0) {\r\n        if ((input.length() >= 3) && input.substring(0, 3).equals(\"../\")) {\r\n            input.delete(0, 3);\r\n        } else if ((input.length() >= 2) && input.substring(0, 2).equals(\"./\")) {\r\n            input.delete(0, 2);\r\n        } else if ((input.length() >= 3) && input.substring(0, 3).equals(\"/./\")) {\r\n            input.delete(0, 2);\r\n        } else if ((input.length() == 2) && input.substring(0, 2).equals(\"/.\")) {\r\n            input.delete(1, 2);\r\n        } else if ((input.length() >= 4) && input.substring(0, 4).equals(\"/../\")) {\r\n            input.delete(0, 3);\r\n            removeLastSegment(output);\r\n        } else if ((input.length() == 3) && input.substring(0, 3).equals(\"/..\")) {\r\n            input.delete(1, 3);\r\n            removeLastSegment(output);\r\n        } else if ((input.length() == 1) && input.substring(0, 1).equals(\".\")) {\r\n            input.delete(0, 1);\r\n        } else if ((input.length() == 2) && input.substring(0, 2).equals(\"..\")) {\r\n            input.delete(0, 2);\r\n        } else {\r\n            int max = -1;\r\n            for (int i = 1; (max == -1) && (i < input.length()); i++) {\r\n                if (input.charAt(i) == '/') {\r\n                    max = i;\r\n                }\r\n            }\r\n            if (max != -1) {\r\n                output.append(input.substring(0, max));\r\n                input.delete(0, max);\r\n            } else {\r\n                output.append(input);\r\n                input.delete(0, input.length());\r\n            }\r\n        }\r\n    }\r\n    setPath(output.toString());\r\n    setScheme(getScheme());\r\n    setHostDomain(getHostDomain());\r\n    final int hostPort = getHostPort();\r\n    if (hostPort != -1) {\r\n        final int defaultPort = Protocol.valueOf(getScheme()).getDefaultPort();\r\n        if (hostPort == defaultPort) {\r\n            setHostPort(null);\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Feed.setIcon",
	"Comment": "sets the image that provides iconic visual identification for a feed.",
	"Method": "void setIcon(Reference icon){\r\n    this.icon = icon;\r\n}"
}, {
	"Path": "org.restlet.security.Realm.setEnroler",
	"Comment": "sets an enroler that can add the user roles based on user principals.",
	"Method": "void setEnroler(Enroler enroler){\r\n    this.enroler = enroler;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.core.CallContext.getPath",
	"Comment": "get the path of the current request relative to the base uri as a string.",
	"Method": "String getPath(String getPath,boolean decode){\r\n    final String path = this.referenceOriginal.getRelativeRef().toString(true, true);\r\n    if (!decode) {\r\n        return path;\r\n    }\r\n    return Reference.decode(path);\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createAuthenticatedUserQuery",
	"Comment": "creates a query for authenticateduser entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.AuthenticatedUser> createAuthenticatedUserQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.AuthenticatedUser.class);\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.AbstractUriBuilder.replaceQuery",
	"Comment": "set the uri query string. this method will overwrite any existing queryparameters.",
	"Method": "UriBuilder replaceQuery(String query){\r\n    if ((query == null) || (query.length() == 0)) {\r\n        this.query = null;\r\n    } else {\r\n        this.query = EncodeOrCheck.fullQuery(query, true);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.restlet.util.Series.copyTo",
	"Comment": "copies the parameters whose name is a key in the given map.if a matching parameter is found, its value is put in the map.if multiple values are found, a list is created and set in the map.",
	"Method": "void copyTo(Map<String, Object> params){\r\n    NamedValue<String> param;\r\n    Object currentValue = null;\r\n    for (Iterator<T> iter = iterator(); iter.hasNext(); ) {\r\n        param = iter.next();\r\n        if (params.containsKey(param.getName())) {\r\n            currentValue = params.get(param.getName());\r\n            if (currentValue != null) {\r\n                List<Object> values = null;\r\n                if (currentValue instanceof List) {\r\n                    values = (List<Object>) currentValue;\r\n                } else {\r\n                    values = new ArrayList<Object>();\r\n                    values.add(currentValue);\r\n                    params.put(param.getName(), values);\r\n                }\r\n                if (param.getValue() == null) {\r\n                    values.add(Series.EMPTY_VALUE);\r\n                } else {\r\n                    values.add(param.getValue());\r\n                }\r\n            } else {\r\n                if (param.getValue() == null) {\r\n                    params.put(param.getName(), Series.EMPTY_VALUE);\r\n                } else {\r\n                    params.put(param.getName(), param.getValue());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.way.Way.hasIoInterest",
	"Comment": "indicates if we want to be selected for io processing when the socketrelated socket is prepared.",
	"Method": "boolean hasIoInterest(){\r\n    return getIoState() != IoState.READY;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.Mapping.getValuePath",
	"Comment": "returns the path of the xml element of the feed that stores the value toset.",
	"Method": "String getValuePath(){\r\n    return valuePath;\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createReportTypeQuery",
	"Comment": "creates a query for reporttype entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.ReportType> createReportTypeQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.ReportType.class);\r\n}"
}, {
	"Path": "org.restlet.ext.jaxb.JaxbRepresentation.isValidatingDtd",
	"Comment": "indicates the desire for validating this type of xml representationsagainst an xml schema if one is referenced within the contents.",
	"Method": "boolean isValidatingDtd(){\r\n    return validatingDtd;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.way.Way.getLoadScore",
	"Comment": "returns a score representing the way load and that could be compared withother ways of the same parent connection.",
	"Method": "int getLoadScore(){\r\n    return (getMessage() == null) ? 0 : 1;\r\n}"
}, {
	"Path": "org.restlet.ext.emf.EmfRepresentation.setUsingEncodedAttributeStyle",
	"Comment": "indicates if emf references should be written as uri anchors.",
	"Method": "void setUsingEncodedAttributeStyle(boolean usingEncodedAttributeStyle){\r\n    this.usingEncodedAttributeStyle = usingEncodedAttributeStyle;\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipStatus.valueOf",
	"Comment": "returns the status associated to a code. if an existing constant existsthen it is returned, otherwise a new instance is created.",
	"Method": "Status valueOf(int code){\r\n    Status result = null;\r\n    switch(code) {\r\n        case 100:\r\n            result = INFO_TRYING;\r\n            break;\r\n        case 180:\r\n            result = INFO_RINGING;\r\n            break;\r\n        case 181:\r\n            result = INFO_CALL_IS_BEING_FORWARDED;\r\n            break;\r\n        case 182:\r\n            result = INFO_QUEUED;\r\n            break;\r\n        case 183:\r\n            result = INFO_SESSION_PROGRESS;\r\n            break;\r\n        case 200:\r\n            result = SUCCESS_OK;\r\n            break;\r\n        case 300:\r\n            result = REDIRECTION_MULTIPLE_CHOICES;\r\n            break;\r\n        case 301:\r\n            result = REDIRECTION_MOVED_PERMANENTLY;\r\n            break;\r\n        case 302:\r\n            result = REDIRECTION_MOVED_TEMPORARILY;\r\n            break;\r\n        case 305:\r\n            result = REDIRECTION_USE_PROXY;\r\n            break;\r\n        case 380:\r\n            result = REDIRECTION_ALTERNATIVE_SERVICE;\r\n            break;\r\n        case 400:\r\n            result = CLIENT_ERROR_BAD_REQUEST;\r\n            break;\r\n        case 401:\r\n            result = CLIENT_ERROR_UNAUTHORIZED;\r\n            break;\r\n        case 402:\r\n            result = CLIENT_ERROR_PAYMENT_REQUIRED;\r\n            break;\r\n        case 403:\r\n            result = CLIENT_ERROR_FORBIDDEN;\r\n            break;\r\n        case 404:\r\n            result = CLIENT_ERROR_NOT_FOUND;\r\n            break;\r\n        case 405:\r\n            result = CLIENT_ERROR_METHOD_NOT_ALLOWED;\r\n            break;\r\n        case 406:\r\n            result = CLIENT_ERROR_NOT_ACCEPTABLE;\r\n            break;\r\n        case 407:\r\n            result = CLIENT_ERROR_PROXY_AUTHENTIFICATION_REQUIRED;\r\n            break;\r\n        case 408:\r\n            result = CLIENT_ERROR_REQUEST_TIMEOUT;\r\n            break;\r\n        case 410:\r\n            result = CLIENT_ERROR_GONE;\r\n            break;\r\n        case 413:\r\n            result = CLIENT_ERROR_REQUEST_ENTITY_TOO_LARGE;\r\n            break;\r\n        case 414:\r\n            result = CLIENT_ERROR_REQUEST_URI_TOO_LONG;\r\n            break;\r\n        case 415:\r\n            result = CLIENT_ERROR_UNSUPPORTED_MEDIA_TYPE;\r\n            break;\r\n        case 416:\r\n            result = CLIENT_ERROR_UNSUPPORTED_URI_SCHEME;\r\n            break;\r\n        case 420:\r\n            result = CLIENT_ERROR_BAD_EXTENSION;\r\n            break;\r\n        case 421:\r\n            result = CLIENT_ERROR_EXTENSION_REQUIRED;\r\n            break;\r\n        case 423:\r\n            result = CLIENT_ERROR_INTERVAL_TOO_BRIEF;\r\n            break;\r\n        case 480:\r\n            result = CLIENT_ERROR_TEMPORARILY_UNAVAILABLE;\r\n            break;\r\n        case 481:\r\n            result = CLIENT_ERROR_CALL_DOESNT_EXIST;\r\n            break;\r\n        case 482:\r\n            result = CLIENT_ERROR_LOOP_DETECTED;\r\n            break;\r\n        case 483:\r\n            result = CLIENT_ERROR_TOO_MANY_HOPS;\r\n            break;\r\n        case 484:\r\n            result = CLIENT_ERROR_ADDRESS_INCOMPLETE;\r\n            break;\r\n        case 485:\r\n            result = CLIENT_ERROR_AMBIGUOUS;\r\n            break;\r\n        case 486:\r\n            result = CLIENT_ERROR_BUSY_HERE;\r\n            break;\r\n        case 487:\r\n            result = CLIENT_ERROR_REQUEST_TERMINATED;\r\n            break;\r\n        case 488:\r\n            result = CLIENT_ERROR_NOT_ACCEPTABLE_HERE;\r\n            break;\r\n        case 491:\r\n            result = CLIENT_ERROR_REQUEST_PENDING;\r\n            break;\r\n        case 493:\r\n            result = CLIENT_ERROR_REQUEST_UNDECIPHERABLE;\r\n            break;\r\n        case 500:\r\n            result = SERVER_ERROR_INTERNAL;\r\n            break;\r\n        case 501:\r\n            result = SERVER_ERROR_NOT_IMPLEMENTED;\r\n            break;\r\n        case 502:\r\n            result = SERVER_ERROR_BAD_GATEWAY;\r\n            break;\r\n        case 503:\r\n            result = SERVER_ERROR_SERVICE_UNAVAILABLE;\r\n            break;\r\n        case 504:\r\n            result = SERVER_ERROR_SERVER_TIMEOUT;\r\n            break;\r\n        case 505:\r\n            result = SERVER_ERROR_VERSION_NOT_SUPPORTED;\r\n            break;\r\n        case 513:\r\n            result = SERVER_ERROR_MESSAGE_TOO_LARGE;\r\n            break;\r\n        case 600:\r\n            result = GLOBAL_ERROR_BUSY_EVERYWHERE;\r\n            break;\r\n        case 603:\r\n            result = GLOBAL_ERROR_DECLINE;\r\n            break;\r\n        case 604:\r\n            result = GLOBAL_ERROR_DOESNT_EXIST_ANYWHERE;\r\n            break;\r\n        case 606:\r\n            result = GLOBAL_ERROR_NOT_ACCEPTABLE;\r\n            break;\r\n        default:\r\n            result = Status.valueOf(code);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.internal.turtle.StringToken.isMultiLines",
	"Comment": "returns true if this string of characters contains at least one newlinecharacter.",
	"Method": "boolean isMultiLines(){\r\n    return multiLines;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.classfile.JavaClassDefinition.hasReference",
	"Comment": "determines whether there is reference to a given method in this javaclassdefinition or a definition in a superclass.",
	"Method": "boolean hasReference(MethodDefinition aMethodDef,ReferenceDAO aReferenceDAO){\r\n    final String methodName = aMethodDef.getName();\r\n    final Type[] argTypes = aMethodDef.getArgumentTypes();\r\n    JavaClass currentJavaClass = getJavaClass();\r\n    while (currentJavaClass != null) {\r\n        final JavaClassDefinition javaClassDef = aReferenceDAO.findJavaClassDef(currentJavaClass);\r\n        if (javaClassDef != null) {\r\n            final MethodDefinition methodDef = javaClassDef.findNarrowestMethod(getJavaClass().getClassName(), methodName, argTypes);\r\n            if ((methodDef != null) && (methodDef.hasReference(getJavaClass()))) {\r\n                return true;\r\n            }\r\n        }\r\n        currentJavaClass = currentJavaClass.getSuperClass();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.classfile.Utils.inScope",
	"Comment": "determines whether the declared scope of a field or method is ina set of scopes.",
	"Method": "boolean inScope(FieldOrMethod aFieldOrMethod,Set aScopes){\r\n    if (aFieldOrMethod.isPrivate()) {\r\n        return (aScopes.contains(Scope.PRIVATE));\r\n    } else if (aFieldOrMethod.isProtected()) {\r\n        return (aScopes.contains(Scope.PROTECTED));\r\n    } else if (aFieldOrMethod.isPublic()) {\r\n        return (aScopes.contains(Scope.PUBLIC));\r\n    } else {\r\n        return (aScopes.contains(Scope.PACKAGE));\r\n    }\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.setRetryAttempts",
	"Comment": "sets the number of retry attempts before reporting an error.",
	"Method": "void setRetryAttempts(int retryAttempts){\r\n    this.retryAttempts = retryAttempts;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.agent.module.AnalyticsHandler.addCallLogToBuffer",
	"Comment": "generates a calllog for the request and adds it to the buffer.",
	"Method": "void addCallLogToBuffer(Request request,Response response,int duration,long startTime){\r\n    CallLog callLog = new CallLog();\r\n    callLog.setDate(new Date(startTime));\r\n    callLog.setDuration(duration);\r\n    callLog.setMethod(request.getMethod().getName());\r\n    callLog.setPath(request.getResourceRef().getPath());\r\n    callLog.setRemoteIp(request.getClientInfo().getUpstreamAddress());\r\n    callLog.setStatusCode(response.getStatus().getCode());\r\n    callLog.setUserAgent(request.getClientInfo().getAgent());\r\n    callLog.setUserToken((request.getClientInfo().getUser() == null) ? \"\" : request.getClientInfo().getUser().getIdentifier());\r\n    callLogs.add(callLog);\r\n    if (callLogs.size() >= bufferSize) {\r\n        flushLogs();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.application.Encoder.encode",
	"Comment": "encodes a given representation if an encoding is supported by the client.",
	"Method": "Representation encode(ClientInfo client,Representation representation){\r\n    Representation result = representation;\r\n    Encoding bestEncoding = getBestEncoding(client);\r\n    if (bestEncoding != null) {\r\n        result = new EncodeRepresentation(bestEncoding, representation);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Source.getUpdated",
	"Comment": "returns the most recent moment when the entry was modified in asignificant way.",
	"Method": "Date getUpdated(){\r\n    return this.updated;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.provider.JaxRsProviders.initAll",
	"Comment": "init all providers. if an error for one provider occurs, this provider isignored and the next provider initialized.",
	"Method": "void initAll(){\r\n    for (final ProviderWrapper provider : new ArrayList<ProviderWrapper>(this.all)) {\r\n        try {\r\n            provider.initAtAppStartUp(tlContext, this, extensionBackwardMapping);\r\n        } catch (InjectException e) {\r\n            localLogger.log(Level.WARNING, \"The provider \" + provider.getClassName() + \" could not be used\", e);\r\n            this.remove(provider);\r\n        } catch (IllegalTypeException e) {\r\n            localLogger.log(Level.WARNING, \"The provider \" + provider.getClassName() + \" could not be used\", e);\r\n            this.remove(provider);\r\n        } catch (InvocationTargetException e) {\r\n            localLogger.log(Level.WARNING, \"The provider \" + provider.getClassName() + \" could not be used\", e.getCause());\r\n            this.remove(provider);\r\n        } catch (SecurityException e) {\r\n            localLogger.log(Level.WARNING, \"The provider \" + provider.getClassName() + \" could not be used\", e.getCause());\r\n            this.remove(provider);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.connection.Connection.getWritableSelectionChannel",
	"Comment": "returns the underlying socket channel as a writable selection channel.",
	"Method": "WritableSelectionChannel getWritableSelectionChannel(){\r\n    return writableSelectionChannel;\r\n}"
}, {
	"Path": "org.restlet.service.TunnelService.setQueryTunnel",
	"Comment": "indicates if the method and client preferences can be tunneled via queryparameters.",
	"Method": "void setQueryTunnel(boolean queryTunnel){\r\n    this.queryTunnel = queryTunnel;\r\n}"
}, {
	"Path": "com.restfb.JsonMapperToJavaTest.emptyArray",
	"Comment": "can we successfully map the case where facebook sends us an empty array instead of an empty string?",
	"Method": "void emptyArray(){\r\n    BasicUser user = createJsonMapper().toJavaObject(jsonFromClasspath(\"empty-array-as-string\"), BasicUser.class);\r\n    assertThat(user.name).isEqualTo(\"\");\r\n}"
}, {
	"Path": "org.restlet.engine.component.ComponentXmlParser.parseRouter",
	"Comment": "parse the attributes of a dom node and update the given router.",
	"Method": "void parseRouter(Router router,Node routerNode){\r\n    parseRestlet(router, routerNode);\r\n    Node item = routerNode.getAttributes().getNamedItem(\"defaultMatchingMode\");\r\n    if (item != null) {\r\n        router.setDefaultMatchingMode(getInt(item, getComponent().getInternalRouter().getDefaultMatchingMode()));\r\n    }\r\n    item = routerNode.getAttributes().getNamedItem(\"defaultMatchingQuery\");\r\n    if (item != null) {\r\n        router.setDefaultMatchingQuery(getBoolean(item, getComponent().getInternalRouter().getDefaultMatchingQuery()));\r\n    }\r\n    item = routerNode.getAttributes().getNamedItem(\"maxAttempts\");\r\n    if (item != null) {\r\n        router.setMaxAttempts(getInt(item, getComponent().getInternalRouter().getMaxAttempts()));\r\n    }\r\n    item = routerNode.getAttributes().getNamedItem(\"routingMode\");\r\n    if (item != null) {\r\n        router.setRoutingMode(getInt(item, getComponent().getInternalRouter().getRoutingMode()));\r\n    }\r\n    item = routerNode.getAttributes().getNamedItem(\"requiredScore\");\r\n    if (item != null) {\r\n        router.setRequiredScore(getFloat(item, getComponent().getInternalRouter().getRequiredScore()));\r\n    }\r\n    item = routerNode.getAttributes().getNamedItem(\"retryDelay\");\r\n    if (item != null) {\r\n        router.setRetryDelay(getLong(item, getComponent().getInternalRouter().getRetryDelay()));\r\n    }\r\n    setAttach(router, routerNode);\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.CookieAuthenticator.setIdentifierFormName",
	"Comment": "sets the name of the html login form field containing the identifier.",
	"Method": "void setIdentifierFormName(String loginInputName){\r\n    this.identifierFormName = loginInputName;\r\n}"
}, {
	"Path": "org.restlet.util.WrapperList.set",
	"Comment": "replaces the element at the specified position in this list with thespecified element.",
	"Method": "E set(int index,E element){\r\n    return getDelegate().set(index, element);\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.swagger.v1_2.SwaggerWriter.getResourcelisting",
	"Comment": "translates a restlet web api definition to a swagger resource listing.",
	"Method": "ResourceListing getResourcelisting(Definition definition){\r\n    ResourceListing result = new ResourceListing();\r\n    fillResourceListingMainAttributes(definition, result);\r\n    fillResourceListingApis(definition, result);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.put",
	"Comment": "creates or updates a resource with the given representation as new stateto be stored. if a success status is not returned, then a resourceexception is thrown.",
	"Method": "Representation put(Object entity,T put,Object entity,Class<T> resultClass,Representation put,Object entity,MediaType mediaType,Representation put,Representation entity){\r\n    return handle(Method.PUT, entity);\r\n}"
}, {
	"Path": "org.restlet.util.WrapperMap.containsKey",
	"Comment": "returns true if this map contains a mapping for the specified key.",
	"Method": "boolean containsKey(Object key){\r\n    return getDelegate().containsKey(key);\r\n}"
}, {
	"Path": "org.restlet.engine.util.ImmutableDate.setTime",
	"Comment": "as an immutabledate is immutable, this method throws anunsupportedoperationexception exception.",
	"Method": "void setTime(long arg0){\r\n    if (Edition.CURRENT == Edition.ANDROID) {\r\n        super.setTime(arg0);\r\n    } else {\r\n        throw new UnsupportedOperationException(\"ImmutableDate is immutable\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.data.ChallengeRequest.setStale",
	"Comment": "indicates if the previous request from the client was stale.",
	"Method": "void setStale(boolean stale){\r\n    this.stale = stale;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.Metadata.getProperty",
	"Comment": "returns the edm type of the given property of the given entity.",
	"Method": "Property getProperty(Object entity,String propertyName){\r\n    Property result = null;\r\n    if (entity != null) {\r\n        EntityType et = getEntityType(entity.getClass());\r\n        if (et != null) {\r\n            for (Property property : et.getProperties()) {\r\n                if (property.getName().equals(propertyName) || property.getNormalizedName().equals(propertyName)) {\r\n                    result = property;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            ComplexType ct = getComplexType(entity.getClass());\r\n            if (ct != null) {\r\n                for (Property property : ct.getProperties()) {\r\n                    if (property.getName().equals(propertyName) || property.getNormalizedName().equals(propertyName)) {\r\n                        result = property;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.connector.FtpClientHelper.getReadTimeout",
	"Comment": "returns the read timeout value. a timeout of zero is interpreted as aninfinite timeout.",
	"Method": "int getReadTimeout(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"readTimeout\", \"60000\"));\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.ResourceClass.getMethodsForPath",
	"Comment": "return all resource methods for the given path, ignoring http method,consumed or produced mimes and so on.",
	"Method": "Collection<ResourceMethod> getMethodsForPath(RemainingPath remainingPath){\r\n    final List<ResourceMethod> resourceMethods = new ArrayList<ResourceMethod>();\r\n    for (final ResourceMethod method : this.resourceMethods) {\r\n        final PathRegExp methodPath = method.getPathRegExp();\r\n        if (remainingPath.isEmptyOrSlash()) {\r\n            if (methodPath.isEmptyOrSlash()) {\r\n                resourceMethods.add(method);\r\n            }\r\n        } else {\r\n            if (methodPath.matchesWithEmpty(remainingPath)) {\r\n                resourceMethods.add(method);\r\n            }\r\n        }\r\n    }\r\n    return resourceMethods;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.core.ThreadLocalizedExtendedUriInfo.getRequestUriBuilder",
	"Comment": "get the absolute request uri in the form of a uribuilder. it alsoincludes the extension of the current request.",
	"Method": "ExtendedUriBuilder getRequestUriBuilder(){\r\n    return getCallContext().getRequestUriBuilderExtended();\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.toEdmDecimal",
	"Comment": "convert the given value to the string representation of a edm decimalvalue.",
	"Method": "String toEdmDecimal(double value){\r\n    return decimalFormat.format(value);\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsRestlet.getNoResMethodHandler",
	"Comment": "returns the restlet that is called, if no resource method class could befound.",
	"Method": "Restlet getNoResMethodHandler(){\r\n    return excHandler.getNoResMethodHandler();\r\n}"
}, {
	"Path": "org.restlet.ext.xml.TransformRepresentation.getTransformSheet",
	"Comment": "returns the xslt transform sheet to apply to the source representation.",
	"Method": "Representation getTransformSheet(){\r\n    return this.transformSheet;\r\n}"
}, {
	"Path": "org.restlet.ext.jackson.JacksonRepresentation.getObject",
	"Comment": "returns the wrapped object, deserializing the representation with jacksonif necessary.",
	"Method": "T getObject(){\r\n    T result = null;\r\n    if (this.object != null) {\r\n        result = this.object;\r\n    } else if (this.representation != null) {\r\n        result = getObjectReader().readValue(this.representation.getStream());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.Message.setAttributes",
	"Comment": "sets the modifiable map of attributes. this method clears the current mapand puts all entries in the parameter map.",
	"Method": "void setAttributes(Map<String, Object> attributes){\r\n    synchronized (getAttributes()) {\r\n        if (attributes != getAttributes()) {\r\n            getAttributes().clear();\r\n            if (attributes != null) {\r\n                getAttributes().putAll(attributes);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.util.RouteList.getNext",
	"Comment": "returns a next route match in a round robin mode for a given call.",
	"Method": "Route getNext(Request request,Response response,float requiredScore){\r\n    if (!isEmpty()) {\r\n        for (final int initialIndex = this.lastIndex++; initialIndex != this.lastIndex; this.lastIndex++) {\r\n            if (this.lastIndex >= size()) {\r\n                this.lastIndex = 0;\r\n            }\r\n            final Route route = get(this.lastIndex);\r\n            if (route.score(request, response) >= requiredScore) {\r\n                return route;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.TableMaker.finishCreatingDefinition",
	"Comment": "begins at the base of the table and starts finishing definition creation.",
	"Method": "void finishCreatingDefinition(Definition def){\r\n    if (def instanceof AnonymousInnerClass) {\r\n        AnonymousInnerClass innerClass = (AnonymousInnerClass) def;\r\n        innerClass.finishMakingDefinition();\r\n    } else if (def instanceof ClassDef) {\r\n        new ClassFinisher(def).finish();\r\n    } else if (def instanceof VariableDef) {\r\n        new VariableFinisher(def).finish();\r\n    } else if (def instanceof DefaultConstructor) {\r\n    } else if (def instanceof MethodDef) {\r\n        new MethodFinisher(def).finish();\r\n    } else if (def instanceof BlockDef) {\r\n        SymTabAST firstChild = (SymTabAST) def.getTreeNode().getFirstChild();\r\n        if (firstChild.getType() == TokenTypes.LPAREN) {\r\n            firstChild = (SymTabAST) firstChild.getNextSibling();\r\n        }\r\n        if (firstChild.getType() == TokenTypes.PARAMETER_DEF) {\r\n            new CatchFinisher((BlockDef) def).finish();\r\n        }\r\n    }\r\n    if (def instanceof Scope) {\r\n        finishCreatingChildren((Scope) def);\r\n    }\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.MethodDef.hasSameSignature",
	"Comment": "whether this method has the same signature as the given signature.",
	"Method": "boolean hasSameSignature(ISignature signature){\r\n    return getSignature().equals(signature);\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.post",
	"Comment": "posts a representation. if a success status is not returned, then aresource exception is thrown.",
	"Method": "Representation post(Object entity,T post,Object entity,Class<T> resultClass,Representation post,Object entity,MediaType mediaType,Representation post,Representation entity){\r\n    return handle(Method.POST, entity);\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.provider.SingletonProvider.writeTo",
	"Comment": "write a type to an http response. the response header map is mutable butany changes must be made before writing to the output stream since theheaders will be flushed prior to writing the response body.",
	"Method": "void writeTo(Object object,Class<?> type,Type genericType,Annotation[] annotations,MediaType mediaType,MultivaluedMap<String, Object> httpHeaders,OutputStream entityStream){\r\n    this.getJaxRsWriter().writeTo(object, type, genericType, annotations, Converter.toJaxRsMediaType(mediaType), httpHeaders, entityStream);\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.params.ReprEntityGetter.create",
	"Comment": "creates an entitygetter for the given values, or null, if it is notavailable.",
	"Method": "ParamGetter create(Class<?> representationType,Type convToGen,Logger logger){\r\n    if (representationType.equals(Representation.class)) {\r\n        return new DirectReprEntityGetter();\r\n    }\r\n    try {\r\n        return new ReprOnlyEntityGetter(representationType.getConstructor(Representation.class));\r\n    } catch (SecurityException e) {\r\n        logger.warning(\"The constructor \" + representationType + \"(Representation) is not accessable.\");\r\n    } catch (NoSuchMethodException e) {\r\n    }\r\n    if (!(convToGen instanceof ParameterizedType)) {\r\n        return null;\r\n    }\r\n    final ParameterizedType pType = (ParameterizedType) convToGen;\r\n    final Type[] typeArgs = pType.getActualTypeArguments();\r\n    if (typeArgs.length != 1) {\r\n        return null;\r\n    }\r\n    final Type typeArg = typeArgs[0];\r\n    if (!(typeArg instanceof Class<?>)) {\r\n        return null;\r\n    }\r\n    final Class<?> genClass = (Class<?>) typeArg;\r\n    try {\r\n        return new ReprClassEntityGetter(representationType.getConstructor(Representation.class, Class.class), genClass);\r\n    } catch (SecurityException e) {\r\n        logger.warning(\"The constructor \" + representationType + \"(Representation) is not accessable.\");\r\n    } catch (NoSuchMethodException e) {\r\n    }\r\n    try {\r\n        return new ClassReprEntityGetter(genClass, representationType.getConstructor(Class.class, Representation.class));\r\n    } catch (SecurityException e) {\r\n        logger.warning(\"The constructor \" + representationType + \"(Representation) is not accessable.\");\r\n        return null;\r\n    } catch (NoSuchMethodException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.UnusedParameterCheck.setIgnoreCatch",
	"Comment": "control whether unused catch clause parameters are flagged.",
	"Method": "void setIgnoreCatch(boolean aIgnoreCatch){\r\n    mIgnoreCatch = aIgnoreCatch;\r\n}"
}, {
	"Path": "org.restlet.representation.DigesterRepresentation.exhaust",
	"Comment": "exhausts the content of the representation by reading it and silentlydiscarding anything read.",
	"Method": "long exhaust(){\r\n    long result = -1L;\r\n    if (isAvailable()) {\r\n        result = IoUtils.exhaust(getStream());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.javamail.TriggerResource.getTargetEntity",
	"Comment": "returns the entity sent to the target. by default, it sends the mailmessage.",
	"Method": "Representation getTargetEntity(Resolver<String> resolver){\r\n    return new StringRepresentation(resolver.resolve(\"message\"));\r\n}"
}, {
	"Path": "org.restlet.Message.setOnError",
	"Comment": "sets the callback invoked when an error occurs when sending the message.",
	"Method": "void setOnError(Uniform onError){\r\n    this.onError = onError;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.ScopeIndex.getFileVector",
	"Comment": "returns the vector containing the scopes relatedto the specified filename.",
	"Method": "Vector getFileVector(String fileName){\r\n    Vector result = (Vector) indexOfFiles.get(fileName);\r\n    if (result == null) {\r\n        result = new Vector();\r\n        indexOfFiles.put(fileName, result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipClientResource.notify",
	"Comment": "informs subscribers of changes in state to which the subscriber has asubscription.",
	"Method": "Representation notify(Representation representation){\r\n    return handle(SipMethod.NOTIFY, representation);\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipClientResource.invite",
	"Comment": "indicates that the user or service is being invited to participate in asession.",
	"Method": "Representation invite(Representation invite,Representation representation){\r\n    return handle(SipMethod.INVITE, representation);\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Link.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    AttributesImpl attributes = new AttributesImpl();\r\n    if ((getHref() != null) && (getHref().toString() != null)) {\r\n        attributes.addAttribute(\"\", \"href\", null, \"atomURI\", getHref().toString());\r\n    }\r\n    if ((getHrefLang() != null) && (getHrefLang().toString() != null)) {\r\n        attributes.addAttribute(\"\", \"hreflang\", null, \"atomLanguageTag\", getHrefLang().toString());\r\n    }\r\n    if (getLength() > 0) {\r\n        attributes.addAttribute(\"\", \"length\", null, \"text\", Long.toString(getLength()));\r\n    }\r\n    attributes.addAttribute(\"\", \"rel\", null, \"text\", Relation.toString(getRel()));\r\n    if (getTitle() != null) {\r\n        attributes.addAttribute(\"\", \"title\", null, \"text\", getTitle());\r\n    }\r\n    if (getType() != null) {\r\n        attributes.addAttribute(\"\", \"type\", null, \"atomMediaType\", getType().toString());\r\n    }\r\n    if (getContent() != null) {\r\n        writer.startElement(ATOM_NAMESPACE, \"link\", null, attributes);\r\n        getContent().writeElement(writer);\r\n        writer.endElement(ATOM_NAMESPACE, \"link\");\r\n    } else {\r\n        writer.emptyElement(ATOM_NAMESPACE, \"link\", null, attributes);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.data.ChallengeMessage.setOpaque",
	"Comment": "sets an opaque string of data which should be returned by the clientunchanged.",
	"Method": "void setOpaque(String opaque){\r\n    this.opaque = opaque;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.ExceptionHandler.getNoRootResClHandler",
	"Comment": "returns the restlet that is called, if no root resource class could befound.",
	"Method": "Restlet getNoRootResClHandler(){\r\n    return noRootResClHandler;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.Transformer.getResultEncodings",
	"Comment": "returns the modifiable list of encodings of the result representation.",
	"Method": "List<Encoding> getResultEncodings(){\r\n    List<Encoding> re = this.resultEncodings;\r\n    if (re == null) {\r\n        synchronized (this) {\r\n            re = this.resultEncodings;\r\n            if (re == null) {\r\n                this.resultEncodings = re = new CopyOnWriteArrayList<Encoding>();\r\n            }\r\n        }\r\n    }\r\n    return re;\r\n}"
}, {
	"Path": "org.restlet.util.ServiceList.setContext",
	"Comment": "sets the context. by default, it also updates the context of alreadyregistered services.",
	"Method": "void setContext(Context context){\r\n    this.context = context;\r\n    for (Service service : this) {\r\n        service.setContext(context);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.util.WrapperList.toArray",
	"Comment": "returns an array containing all of the elements in this list in propersequence.",
	"Method": "Object[] toArray(T[] toArray,T[] a){\r\n    return getDelegate().toArray(a);\r\n}"
}, {
	"Path": "org.restlet.resource.Resource.getProtocol",
	"Comment": "returns the protocol by first returning the resourceref.schemeprotocolproperty if it is set, or the baseref.schemeprotocol property otherwise.",
	"Method": "Protocol getProtocol(){\r\n    return getRequest() == null ? null : getRequest().getProtocol();\r\n}"
}, {
	"Path": "org.restlet.util.ClientList.add",
	"Comment": "adds a new client connector in the map supporting the given protocol.",
	"Method": "boolean add(Client client,Client add,Protocol protocol){\r\n    final Client result = new Client(protocol);\r\n    result.setContext(getContext().createChildContext());\r\n    add(result);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.test.ext.xml.TransformerTestCase.parallelTestTransform",
	"Comment": "this was removed from the automatically tested method because it is tooconsuming.",
	"Method": "void parallelTestTransform(){\r\n    Component comp = new Component();\r\n    final TransformRepresentation tr = new TransformRepresentation(comp.getContext(), this.source, this.xslt);\r\n    final FailureTracker tracker = new FailureTracker();\r\n    final int testVolume = 5000;\r\n    final Thread[] parallelTransform = new Thread[testVolume];\r\n    for (int i = 0; i < parallelTransform.length; i++) {\r\n        final int index = i;\r\n        parallelTransform[i] = new Thread() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    final ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n                    tr.write(out);\r\n                    final String result = out.toString();\r\n                    assertEquals(TransformerTestCase.this.output, result);\r\n                    out.close();\r\n                } catch (Throwable e) {\r\n                    tracker.trackFailure(\"Exception during write in thread \", index, e);\r\n                }\r\n            }\r\n        };\r\n    }\r\n    for (final Thread pt : parallelTransform) {\r\n        pt.start();\r\n    }\r\n    tracker.report();\r\n}"
}, {
	"Path": "org.restlet.test.ext.xml.TransformerTestCase.parallelTestTransform",
	"Comment": "this was removed from the automatically tested method because it is tooconsuming.",
	"Method": "void parallelTestTransform(){\r\n    try {\r\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n        tr.write(out);\r\n        final String result = out.toString();\r\n        assertEquals(TransformerTestCase.this.output, result);\r\n        out.close();\r\n    } catch (Throwable e) {\r\n        tracker.trackFailure(\"Exception during write in thread \", index, e);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.swagger.JaxRsApplicationSwaggerSpecificationRestlet.getResourceListing",
	"Comment": "returns the representation of the whole resource listing of theapplication.",
	"Method": "Representation getResourceListing(){\r\n    ResourceListing resourcelisting = SwaggerWriter.getResourcelisting(getDefinition());\r\n    resourcelisting.setSwaggerVersion(swaggerVersion);\r\n    return new JacksonRepresentation(resourcelisting);\r\n}"
}, {
	"Path": "org.restlet.data.ReferenceList.subList",
	"Comment": "returns a view of the portion of this list between the specifiedfromindex, inclusive, and toindex, exclusive.",
	"Method": "ReferenceList subList(int fromIndex,int toIndex){\r\n    return new ReferenceList(getDelegate().subList(fromIndex, toIndex));\r\n}"
}, {
	"Path": "org.restlet.ext.atom.FeedReader.startContent",
	"Comment": "called when a new content element has been detected in the atom document.",
	"Method": "void startContent(Content content){\r\n    if (this.feedReader != null) {\r\n        this.feedReader.startContent(content);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createCompanyPersonQuery",
	"Comment": "creates a query for companyperson entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.CompanyPerson> createCompanyPersonQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.CompanyPerson.class);\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.Resolver.findLeftChild",
	"Comment": "finds the left child of a binary operator, skipping parentheses.",
	"Method": "SymTabAST findLeftChild(SymTabAST aExpression){\r\n    SymTabAST leftChild = (SymTabAST) (aExpression.getFirstChild());\r\n    while (leftChild.getType() == TokenTypes.LPAREN) {\r\n        leftChild = (SymTabAST) leftChild.getNextSibling();\r\n    }\r\n    return leftChild;\r\n}"
}, {
	"Path": "org.restlet.Response.toString",
	"Comment": "displays a synthesis of the response like an http status line.",
	"Method": "String toString(){\r\n    return ((getRequest() == null) ? \"?\" : getRequest().getProtocol()) + \" - \" + getStatus();\r\n}"
}, {
	"Path": "org.restlet.engine.converter.StatusInfoHtmlConverter.toHtml",
	"Comment": "returns a representation for the given status.in order to customize the default representation, this method can beoverridden.",
	"Method": "Representation toHtml(StatusInfo status){\r\n    final StringBuilder sb = new StringBuilder();\r\n    sb.append(\"<html>\\n\");\r\n    sb.append(\"<head>\\n\");\r\n    sb.append(\"   <title>Status page<\/title>\\n\");\r\n    sb.append(\"<\/head>\\n\");\r\n    sb.append(\"<body style=\\\"font-family: sans-serif;\\\">\\n\");\r\n    sb.append(\"<p style=\\\"font-size: 1.2em;font-weight: bold;margin: 1em 0px;\\\">\");\r\n    sb.append(StringUtils.htmlEscape(getStatusLabel(status)));\r\n    sb.append(\"<\/p>\\n\");\r\n    if (status.getDescription() != null) {\r\n        sb.append(\"<p>\");\r\n        sb.append(StringUtils.htmlEscape(status.getDescription()));\r\n        sb.append(\"<\/p>\\n\");\r\n    }\r\n    sb.append(\"<p>You can get technical details <a href=\\\"\");\r\n    sb.append(status.getUri());\r\n    sb.append(\"\\\">here<\/a>.<br>\\n\");\r\n    if (status.getContactEmail() != null) {\r\n        sb.append(\"For further assistance, you can contact the <a href=\\\"mailto:\");\r\n        sb.append(status.getContactEmail());\r\n        sb.append(\"\\\">administrator<\/a>.<br>\\n\");\r\n    }\r\n    if (status.getHomeRef() != null) {\r\n        sb.append(\"Please continue your visit at our <a href=\\\"\");\r\n        sb.append(status.getHomeRef());\r\n        sb.append(\"\\\">home page<\/a>.\\n\");\r\n    }\r\n    sb.append(\"<\/p>\\n\");\r\n    sb.append(\"<\/body>\\n\");\r\n    sb.append(\"<\/html>\\n\");\r\n    return new StringRepresentation(sb.toString(), MediaType.TEXT_HTML);\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.ResourceInfo.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    final AttributesImpl attributes = new AttributesImpl();\r\n    if ((getIdentifier() != null) && !getIdentifier().equals(\"\")) {\r\n        attributes.addAttribute(\"\", \"id\", null, \"xs:ID\", getIdentifier());\r\n    }\r\n    if ((getPath() != null) && !getPath().equals(\"\")) {\r\n        attributes.addAttribute(\"\", \"path\", null, \"xs:string\", getPath());\r\n    }\r\n    if (getQueryType() != null) {\r\n        attributes.addAttribute(\"\", \"queryType\", null, \"xs:string\", getQueryType().getMainType());\r\n    }\r\n    if ((getType() != null) && !getType().isEmpty()) {\r\n        final StringBuilder builder = new StringBuilder();\r\n        for (final Iterator<Reference> iterator = getType().iterator(); iterator.hasNext(); ) {\r\n            final Reference reference = iterator.next();\r\n            builder.append(reference.toString());\r\n            if (iterator.hasNext()) {\r\n                builder.append(\" \");\r\n            }\r\n        }\r\n        attributes.addAttribute(\"\", \"type\", null, \"xs:string\", builder.toString());\r\n    }\r\n    if (getChildResources().isEmpty() && getDocumentations().isEmpty() && getMethods().isEmpty() && getParameters().isEmpty()) {\r\n        writer.emptyElement(APP_NAMESPACE, \"resource\", null, attributes);\r\n    } else {\r\n        writer.startElement(APP_NAMESPACE, \"resource\", null, attributes);\r\n        for (final ResourceInfo resourceInfo : getChildResources()) {\r\n            resourceInfo.writeElement(writer);\r\n        }\r\n        for (final DocumentationInfo documentationInfo : getDocumentations()) {\r\n            documentationInfo.writeElement(writer);\r\n        }\r\n        for (final ParameterInfo parameterInfo : getParameters()) {\r\n            parameterInfo.writeElement(writer);\r\n        }\r\n        for (final MethodInfo methodInfo : getMethods()) {\r\n            methodInfo.writeElement(writer);\r\n        }\r\n        writer.endElement(APP_NAMESPACE, \"resource\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createCompanyQuery",
	"Comment": "creates a query for company entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Company> createCompanyQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Company.class);\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.DefaultSslContext.createContextSpi",
	"Comment": "creates a ssl context spi capable or setting additional properties on thecreated ssl engines and socket factories.",
	"Method": "WrapperSslContextSpi createContextSpi(DefaultSslContextFactory contextFactory,SSLContext wrappedContext){\r\n    return new WrapperSslContextSpi(contextFactory, wrappedContext);\r\n}"
}, {
	"Path": "org.restlet.ext.gson.GsonRepresentation.getObject",
	"Comment": "returns the wrapped object, deserializing the representation with gson ifnecessary.",
	"Method": "T getObject(){\r\n    T result = null;\r\n    if (this.object != null) {\r\n        result = this.object;\r\n    } else if (this.jsonRepresentation != null) {\r\n        Gson gson = getBuilder().create();\r\n        result = gson.fromJson(new JsonReader(jsonRepresentation.getReader()), this.objectClass);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.resource.Resource.setQueryValue",
	"Comment": "sets the query value for the named parameter. if no query is defined, itcreates one. if the same parameter exists, it replaces it altogether.",
	"Method": "void setQueryValue(String name,String value){\r\n    Form query = getQuery();\r\n    if (query == null) {\r\n        query = new Form();\r\n    }\r\n    query.set(name, value);\r\n    try {\r\n        getReference().setQuery(query.encode());\r\n    } catch (IOException e) {\r\n        getLogger().fine(\"Unable to set the query value\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.Response.abort",
	"Comment": "ask the connector to abort the related network connection, for exampleimmediately closing the socket.",
	"Method": "void abort(){\r\n    getRequest().abort();\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.WrapperSslContextSpi.initEngine",
	"Comment": "initializes the ssl engine with additional parameters from the sslcontext factory.",
	"Method": "void initEngine(SSLEngine sslEngine){\r\n    if (getContextFactory().isNeedClientAuthentication()) {\r\n        sslEngine.setNeedClientAuth(true);\r\n    } else if (getContextFactory().isWantClientAuthentication()) {\r\n        sslEngine.setWantClientAuth(true);\r\n    }\r\n    if ((getContextFactory().getEnabledCipherSuites() != null) || (getContextFactory().getDisabledCipherSuites() != null)) {\r\n        sslEngine.setEnabledCipherSuites(getContextFactory().getSelectedCipherSuites(sslEngine.getSupportedCipherSuites()));\r\n    }\r\n    if ((getContextFactory().getEnabledProtocols() != null) || (getContextFactory().getDisabledProtocols() != null)) {\r\n        sslEngine.setEnabledProtocols(getContextFactory().getSelectedSslProtocols(sslEngine.getSupportedProtocols()));\r\n    }\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getAuthority",
	"Comment": "returns the authority component for hierarchical identifiers. includesthe user info, host name and the host port number.note that no uri decoding is done by this method.",
	"Method": "String getAuthority(String getAuthority,boolean decode){\r\n    return decode ? decode(getAuthority()) : getAuthority();\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.Type.getPackageName",
	"Comment": "returns the class name of the corresponding java class. returns null fora scalar type.",
	"Method": "String getPackageName(){\r\n    String result = null;\r\n    if (getName().endsWith(\"DateTime\")) {\r\n        result = \"java.util\";\r\n    } else if (getName().endsWith(\"DateTimeOffset\")) {\r\n        result = \"java.util\";\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.internal.xml.ContentReader.popState",
	"Comment": "returns the state at the top of the heap and removes it from the heap.",
	"Method": "ContentReader.State popState(){\r\n    ContentReader.State result = null;\r\n    int size = this.states.size();\r\n    if (size > 0) {\r\n        result = this.states.remove(size - 1);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.agent.AgentUtils.buildResourcePath",
	"Comment": "builds the path of the client resource to communicate with the apisparkconnector cell.",
	"Method": "String buildResourcePath(ApiSparkConfig apiSparkConfig,String resourcePath){\r\n    StringBuilder sb = new StringBuilder(apiSparkConfig.getAgentServiceUrl());\r\n    if (!apiSparkConfig.getAgentServiceUrl().endsWith(\"/\")) {\r\n        sb.append(\"/\");\r\n    }\r\n    sb.append(\"agent\");\r\n    sb.append(\"/cells/\");\r\n    sb.append(apiSparkConfig.getAgentCellId());\r\n    sb.append(\"/versions/\");\r\n    sb.append(apiSparkConfig.getAgentCellVersion());\r\n    if (resourcePath != null) {\r\n        if (!resourcePath.startsWith(\"/\")) {\r\n            sb.append(\"/\");\r\n        }\r\n        sb.append(resourcePath);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Entry.setPublished",
	"Comment": "sets the moment associated with an event early in the life cycle of theentry.",
	"Method": "void setPublished(Date published){\r\n    this.published = DateUtils.unmodifiable(published);\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.Util.indexOfBetween",
	"Comment": "returns the index of the first occurrence of the given character betweenthe given indexes.",
	"Method": "int indexOfBetween(CharSequence charSequence,char c,int beginIndex,int endIndex){\r\n    if (beginIndex < 0) {\r\n        beginIndex = 0;\r\n    }\r\n    if (endIndex < 0) {\r\n        endIndex = 0;\r\n    }\r\n    for (int i = beginIndex; i < endIndex; i++) {\r\n        char csc = charSequence.charAt(i);\r\n        if (csc == c) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.restlet.ext.json.JsonRepresentation.getJsonArray",
	"Comment": "gets the wrapped json array or converts the wrapped representation ifneeded.",
	"Method": "JSONArray getJsonArray(){\r\n    if (this.jsonValue != null) {\r\n        return (JSONArray) this.jsonValue;\r\n    }\r\n    return new JSONArray(getJsonText());\r\n}"
}, {
	"Path": "com.restfb.JsonMapperToJavaTest.emptyStringAsObject",
	"Comment": "check if a empty string is not mapped and a exception with the correct message is thrown instead",
	"Method": "void emptyStringAsObject(){\r\n    try {\r\n        createJsonMapper().toJavaObject(\"\", String.class);\r\n        failBecauseExceptionWasNotThrown(FacebookJsonMappingException.class);\r\n    } catch (FacebookJsonMappingException fe) {\r\n        assertThat(fe.getMessage()).startsWith(\"JSON is an empty string\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.resource.Resource.getQueryValue",
	"Comment": "returns the first value of the query parameter given its name ifexisting, or null.",
	"Method": "String getQueryValue(String name){\r\n    String result = null;\r\n    Form query = getQuery();\r\n    if (query != null) {\r\n        result = query.getFirstValue(name);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.provider.JaxbProvider.isXIncludeAware",
	"Comment": "indicates the desire for processing xinclude if found in thistype of xml representations. by default the value of this is set tofalse.",
	"Method": "boolean isXIncludeAware(){\r\n    return xIncludeAware;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.IncludeInfo.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    final AttributesImpl attributes = new AttributesImpl();\r\n    if ((getTargetRef() != null) && (getTargetRef().toString() != null)) {\r\n        attributes.addAttribute(\"\", \"href\", null, \"xs:anyURI\", getTargetRef().toString());\r\n    }\r\n    if (getDocumentations().isEmpty()) {\r\n        writer.emptyElement(APP_NAMESPACE, \"include\", null, attributes);\r\n    } else {\r\n        writer.startElement(APP_NAMESPACE, \"include\", null, attributes);\r\n        for (final DocumentationInfo documentationInfo : getDocumentations()) {\r\n            documentationInfo.writeElement(writer);\r\n        }\r\n        writer.endElement(APP_NAMESPACE, \"include\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.util.Series.getFirstValue",
	"Comment": "returns the value of the first parameter found with the given name.",
	"Method": "String getFirstValue(String name,String getFirstValue,String name,boolean ignoreCase,String getFirstValue,String name,boolean ignoreCase,String defaultValue,String getFirstValue,String name,String defaultValue){\r\n    return getFirstValue(name, false, defaultValue);\r\n}"
}, {
	"Path": "org.restlet.security.Group.setMemberUsers",
	"Comment": "sets the modifiable list of member user references. this method clearsthe current list and adds all entries in the parameter list.",
	"Method": "void setMemberUsers(List<User> memberUsers){\r\n    synchronized (getMemberUsers()) {\r\n        if (memberUsers != getMemberUsers()) {\r\n            getMemberUsers().clear();\r\n            if (memberUsers != null) {\r\n                getMemberUsers().addAll(memberUsers);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.resource.VariantInfo.equals",
	"Comment": "indicates if the current variant is equal to the given variant.",
	"Method": "boolean equals(Object other){\r\n    if (other == this) {\r\n        return true;\r\n    }\r\n    if (!(other instanceof VariantInfo)) {\r\n        return false;\r\n    }\r\n    VariantInfo that = (VariantInfo) other;\r\n    return super.equals(that) && Objects.equals(getAnnotationInfo(), that.getAnnotationInfo());\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.ClassFileSetCheck.registerVisitors",
	"Comment": "registers all the visitors for iobjectsetvisitor visits, and fortree walk visits.",
	"Method": "void registerVisitors(){\r\n    mObjectSetVisitors.addAll(mAllChecks);\r\n    final Iterator it = mAllChecks.iterator();\r\n    while (it.hasNext()) {\r\n        final AbstractCheckVisitor check = (AbstractCheckVisitor) it.next();\r\n        final IDeepVisitor visitor = check.getVisitor();\r\n        mObjectSetVisitors.add(visitor);\r\n        mTreeVisitors.add(visitor);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.representation.Representation.isEmpty",
	"Comment": "indicates if the representation is empty. it basically means that itssize is 0.",
	"Method": "boolean isEmpty(){\r\n    return getSize() == 0;\r\n}"
}, {
	"Path": "org.restlet.routing.Router.handle",
	"Comment": "handles a call by invoking the next restlet if it is available.",
	"Method": "void handle(Request request,Response response){\r\n    super.handle(request, response);\r\n    Restlet next = getNext(request, response);\r\n    if (next != null) {\r\n        doHandle(next, request, response);\r\n    } else {\r\n        response.setStatus(Status.CLIENT_ERROR_NOT_FOUND);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.CookieAuthenticator.getEncryptSecretKey",
	"Comment": "returns the secret key for the algorithm used to encrypt the log infocookie value.",
	"Method": "byte[] getEncryptSecretKey(){\r\n    return encryptSecretKey;\r\n}"
}, {
	"Path": "org.restlet.test.ext.jaxrs.server.RestletServerTestCase.setServerWrapperFactory",
	"Comment": "sets the default serverwrapper. should be called before setup.",
	"Method": "void setServerWrapperFactory(ServerWrapperFactory swf){\r\n    if (swf == null) {\r\n        throw new IllegalArgumentException(\"null is an illegal ServerWrapperFactory\");\r\n    }\r\n    serverWrapperFactory = swf;\r\n}"
}, {
	"Path": "org.restlet.service.MetadataService.getDefaultCharacterSet",
	"Comment": "returns the default character set for textual representations.",
	"Method": "CharacterSet getDefaultCharacterSet(){\r\n    return this.defaultCharacterSet;\r\n}"
}, {
	"Path": "org.restlet.resource.Resource.getLocationRef",
	"Comment": "returns the reference that the client should follow for redirections orresource creations.",
	"Method": "Reference getLocationRef(){\r\n    return getResponse() == null ? null : getResponse().getLocationRef();\r\n}"
}, {
	"Path": "org.restlet.data.MediaType.equals",
	"Comment": "test the equality of two media types, with the possibility to ignore theparameters.",
	"Method": "boolean equals(Object obj,boolean equals,Object obj,boolean ignoreParameters){\r\n    boolean result = (obj == this);\r\n    if (!result) {\r\n        if (obj instanceof MediaType) {\r\n            final MediaType that = (MediaType) obj;\r\n            if (getMainType().equals(that.getMainType()) && getSubType().equals(that.getSubType())) {\r\n                result = ignoreParameters || getParameters().equals(that.getParameters());\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Entry.getSummary",
	"Comment": "returns the short summary, abstract, or excerpt of the entry.",
	"Method": "String getSummary(){\r\n    return this.summary;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxb.JaxbRepresentation.getNamespacePrefixMapper",
	"Comment": "returns the optional namespace prefix mapper for marshalling.",
	"Method": "NamespacePrefixMapper getNamespacePrefixMapper(){\r\n    return namespacePrefixMapper;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.introspection.application.RestletCollector.collectForRouter",
	"Comment": "completes the list of resourceinfo instances for the given routerinstance.",
	"Method": "void collectForRouter(CollectInfo collectInfo,String basePath,Router router,ChallengeScheme scheme,List<? extends IntrospectionHelper> introspectionHelper){\r\n    for (Route route : router.getRoutes()) {\r\n        collectForRoute(collectInfo, basePath, route, scheme, introspectionHelper);\r\n    }\r\n    if (router.getDefaultRoute() != null) {\r\n        collectForRoute(collectInfo, basePath, router.getDefaultRoute(), scheme, introspectionHelper);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.util.WrapperList.addAll",
	"Comment": "inserts all of the elements in the specified collection into this list atthe specified position.",
	"Method": "boolean addAll(Collection<? extends E> elements,boolean addAll,int index,Collection<? extends E> elements){\r\n    return getDelegate().addAll(index, elements);\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.JettyServerHelper.getLowResourceMonitorStopTimeout",
	"Comment": "low resource monitor stop timeout in milliseconds. defaults to 30000.the maximum time allowed for the service to shutdown.",
	"Method": "long getLowResourceMonitorStopTimeout(){\r\n    return Long.parseLong(getHelpedParameters().getFirstValue(\"lowResource.stopTimeout\", \"30000\"));\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.channel.ReadableSizedSelectionChannel.getAvailableSize",
	"Comment": "returns the remaining size that should be read from the source channel.",
	"Method": "long getAvailableSize(){\r\n    return availableSize;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.ServerConnectionHelper.createServerSocketChannel",
	"Comment": "create a server socket channel and bind it to the given address",
	"Method": "ServerSocketChannel createServerSocketChannel(){\r\n    ServerSocketChannel result = ServerSocketChannel.open();\r\n    ServerSocket socket = result.socket();\r\n    socket.setReceiveBufferSize(getSocketReceiveBufferSize());\r\n    socket.setReuseAddress(isSocketReuseAddress());\r\n    socket.setSoTimeout(getMaxIoIdleTimeMs());\r\n    socket.bind(createSocketAddress());\r\n    result.configureBlocking(false);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.internal.xml.ContentReader.resolve",
	"Comment": "returns the absolute reference of a parsed element according to its uri,qualified name. in case the base uri is null or empty, then an attempt ismade to look for the mapped uri according to the qname.",
	"Method": "Reference resolve(String value,boolean fragment,Reference resolve,String uri,String qName){\r\n    Reference result = null;\r\n    int index = qName.indexOf(\":\");\r\n    String prefix = null;\r\n    String localName = null;\r\n    if (index != -1) {\r\n        prefix = qName.substring(0, index);\r\n        localName = qName.substring(index + 1);\r\n    } else {\r\n        localName = qName;\r\n        prefix = \"\";\r\n    }\r\n    if (uri != null && !\"\".equals(uri)) {\r\n        if (!uri.endsWith(\"#\") && !uri.endsWith(\"/\")) {\r\n            result = new Reference(uri + \"/\" + localName);\r\n        } else {\r\n            result = new Reference(uri + localName);\r\n        }\r\n    } else {\r\n        String baseUri = this.prefixes.get(prefix);\r\n        if (baseUri != null) {\r\n            result = new Reference(baseUri + localName);\r\n        }\r\n    }\r\n    return (result == null) ? null : result.getTargetRef();\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlRepresentation.isIgnoringComments",
	"Comment": "indicates if the parser will ignore comments. by default the value ofthis is set to false.",
	"Method": "boolean isIgnoringComments(){\r\n    return ignoringComments;\r\n}"
}, {
	"Path": "org.restlet.engine.util.ImmutableDate.setDate",
	"Comment": "as an immutabledate is immutable, this method throws anunsupportedoperationexception exception.",
	"Method": "void setDate(int arg0){\r\n    throw new UnsupportedOperationException(\"ImmutableDate is immutable\");\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getSchemeProtocol",
	"Comment": "returns the protocol associated with the scheme component.",
	"Method": "Protocol getSchemeProtocol(){\r\n    return Protocol.valueOf(getScheme());\r\n}"
}, {
	"Path": "org.restlet.ext.jaxb.JaxbRepresentation.isXIncludeAware",
	"Comment": "indicates the desire for processing xinclude if found in thistype of xml representations. by default the value of this is set tofalse.",
	"Method": "boolean isXIncludeAware(){\r\n    return xIncludeAware;\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createCategoryQuery",
	"Comment": "creates a query for category entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Category> createCategoryQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Category.class);\r\n}"
}, {
	"Path": "org.restlet.engine.application.RangeRepresentation.getRange",
	"Comment": "returns the range specific to this wrapper. the wrapped representationmust not have a range set itself.",
	"Method": "Range getRange(){\r\n    return this.range;\r\n}"
}, {
	"Path": "org.restlet.engine.application.Encoder.beforeHandle",
	"Comment": "allows filtering before its handling by the target restlet. does nothingby default.",
	"Method": "int beforeHandle(Request request,Response response){\r\n    if (isEncodingRequest() && getEncoderService().canEncode(request.getEntity())) {\r\n        request.setEntity(encode(request.getClientInfo(), request.getEntity()));\r\n    }\r\n    return CONTINUE;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.channel.ReadableSizedChannel.getAvailableSize",
	"Comment": "returns the remaining size that should be read from the source channel.",
	"Method": "long getAvailableSize(){\r\n    return availableSize;\r\n}"
}, {
	"Path": "org.restlet.representation.Representation.getDisposition",
	"Comment": "returns the disposition characteristics of the representation.",
	"Method": "Disposition getDisposition(){\r\n    return disposition;\r\n}"
}, {
	"Path": "org.restlet.engine.io.IoUtils.isBlocking",
	"Comment": "indicates if the channel is in blocking mode. it returns false when thechannel is selectable and configured to be non blocking.",
	"Method": "boolean isBlocking(Channel channel){\r\n    boolean result = true;\r\n    if (channel instanceof SelectableChannel) {\r\n        SelectableChannel selectableChannel = (SelectableChannel) channel;\r\n        result = selectableChannel.isBlocking();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.freemarker.ContextTemplateLoader.findTemplateSource",
	"Comment": "finds the object that acts as the source of the template with the givenname.",
	"Method": "Object findTemplateSource(String name){\r\n    String fullUri;\r\n    if (getBaseUri().endsWith(\"/\")) {\r\n        fullUri = getBaseUri() + name;\r\n    } else {\r\n        fullUri = getBaseUri() + \"/\" + name;\r\n    }\r\n    return (getContext() == null) ? null : getContext().getClientDispatcher().handle(new Request(Method.GET, fullUri)).getEntity();\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.internal.AwsVerifier.getMaxRequestAge",
	"Comment": "returns the maximum age of a request, in milliseconds, before it isconsidered stale.a negative or zero value indicates no age restriction. the default valueis 15 minutes.",
	"Method": "long getMaxRequestAge(){\r\n    return this.maxRequestAge;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxb.JaxbRepresentation.isFormattedOutput",
	"Comment": "indicates if the resulting xml data should be formatted with line breaksand indentation. defaults to false.",
	"Method": "boolean isFormattedOutput(){\r\n    return this.formattedOutput;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.agent.module.AnalyticsHandler.flushLogs",
	"Comment": "creates a new thread that asynchronously posts call logs to apispark",
	"Method": "void flushLogs(){\r\n    if (callLogs.isEmpty()) {\r\n        return;\r\n    }\r\n    CallLogs logsToPost;\r\n    synchronized (callLogs) {\r\n        if (callLogs.isEmpty()) {\r\n            return;\r\n        }\r\n        logsToPost = new CallLogs(callLogs.size());\r\n        logsToPost.addAll(callLogs);\r\n        callLogs.clear();\r\n    }\r\n    postLogs(logsToPost);\r\n}"
}, {
	"Path": "org.restlet.ext.sdc.internal.SdcServerConnection.sendRequest",
	"Comment": "effectively send the requests using the sdc frame protocol. it alsostores the call in the map to be later be able to associate it with itsresponse.",
	"Method": "void sendRequest(SdcClientCall call){\r\n    getCalls().put(call.getFetchRequest().getId(), call);\r\n    getFrameSender().sendFrame(FrameInfo.Type.FETCH_REQUEST, call.getFetchRequest().toByteString());\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.PathRegExp.match",
	"Comment": "checks if this regular expression matches the given remaining path.",
	"Method": "MatchingResult match(RemainingPath remainingPath){\r\n    String givenPath = remainingPath.getWithoutParams();\r\n    Matcher matcher = pattern.matcher(givenPath);\r\n    if (!matcher.matches()) {\r\n        return null;\r\n    }\r\n    final Map<String, String> templateVars = new HashMap<String, String>();\r\n    for (int i = 1; i < matcher.groupCount(); i++) {\r\n        templateVars.put(this.varNames.get(i - 1), matcher.group(i));\r\n    }\r\n    String finalCapturingGroup = matcher.group(matcher.groupCount());\r\n    int matchedChars = givenPath.length() - finalCapturingGroup.length();\r\n    if ((matchedChars > 0) && (givenPath.charAt(matchedChars - 1) == '/')) {\r\n        matchedChars--;\r\n    }\r\n    final String matchedPart = givenPath.substring(0, matchedChars);\r\n    return new MatchingResult(matchedPart, templateVars, finalCapturingGroup);\r\n}"
}, {
	"Path": "org.restlet.data.Reference.setSegments",
	"Comment": "sets the segments of a hierarchical path.a new absolute path will replace any existing one.",
	"Method": "void setSegments(List<String> segments){\r\n    final StringBuilder sb = new StringBuilder();\r\n    for (final String segment : segments) {\r\n        sb.append('/').append(segment);\r\n    }\r\n    setPath(sb.toString());\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.WadlServerResource.isAutoDescribing",
	"Comment": "indicates if the resource should be automatically described via wadl whenan options request is handled.",
	"Method": "boolean isAutoDescribing(){\r\n    return this.autoDescribing;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Service.deleteLink",
	"Comment": "removes the association between a source entity and a target entity viathe given property name.",
	"Method": "void deleteLink(Object source,String sourceProperty,Object target){\r\n    if (getMetadata() == null) {\r\n        return;\r\n    }\r\n    deleteEntity(getSubpath(source, sourceProperty, target));\r\n}"
}, {
	"Path": "org.restlet.ext.xml.DomRepresentation.createTransformer",
	"Comment": "creates a new jaxp transformer object that will be used to serialize thisdom. this method may be overridden in order to set custom properties onthe transformer.",
	"Method": "javax.xml.transform.Transformer createTransformer(){\r\n    try {\r\n        javax.xml.transform.Transformer transformer = javax.xml.transform.TransformerFactory.newInstance().newTransformer();\r\n        transformer.setOutputProperty(javax.xml.transform.OutputKeys.METHOD, \"xml\");\r\n        transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, isIndenting() ? \"yes\" : \"no\");\r\n        if (getCharacterSet() != null) {\r\n            transformer.setOutputProperty(javax.xml.transform.OutputKeys.ENCODING, getCharacterSet().getName());\r\n        } else {\r\n            transformer.setOutputProperty(javax.xml.transform.OutputKeys.ENCODING, CharacterSet.ISO_8859_1.getName());\r\n        }\r\n        DocumentType docType = getDocument().getDoctype();\r\n        if (docType != null) {\r\n            if (docType.getSystemId() != null) {\r\n                transformer.setOutputProperty(javax.xml.transform.OutputKeys.DOCTYPE_SYSTEM, getDocument().getDoctype().getSystemId());\r\n            }\r\n            if (docType.getPublicId() != null) {\r\n                transformer.setOutputProperty(javax.xml.transform.OutputKeys.DOCTYPE_PUBLIC, getDocument().getDoctype().getPublicId());\r\n            }\r\n        }\r\n        return transformer;\r\n    } catch (javax.xml.transform.TransformerConfigurationException tce) {\r\n        throw new IOException(\"Couldn't write the XML representation: \" + tce.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Source.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    writer.startElement(ATOM_NAMESPACE, \"source\");\r\n    if (getAuthors() != null) {\r\n        for (final Person person : getAuthors()) {\r\n            person.writeElement(writer, \"author\");\r\n        }\r\n    }\r\n    if (getCategories() != null) {\r\n        for (final Category category : getCategories()) {\r\n            category.writeElement(writer);\r\n        }\r\n    }\r\n    if (getContributors() != null) {\r\n        for (final Person person : getContributors()) {\r\n            person.writeElement(writer, \"contributor\");\r\n        }\r\n    }\r\n    if (getGenerator() != null) {\r\n        getGenerator().writeElement(writer);\r\n    }\r\n    if ((getIcon() != null) && (getIcon().toString() != null)) {\r\n        writer.dataElement(ATOM_NAMESPACE, \"icon\", getIcon().toString());\r\n    }\r\n    if (getId() != null) {\r\n        writer.dataElement(ATOM_NAMESPACE, \"id\", getId());\r\n    }\r\n    if (getLinks() != null) {\r\n        for (final Link link : getLinks()) {\r\n            link.writeElement(writer);\r\n        }\r\n    }\r\n    if ((getLogo() != null) && (getLogo().toString() != null)) {\r\n        writer.dataElement(ATOM_NAMESPACE, \"logo\", getLogo().toString());\r\n    }\r\n    if (getRights() != null) {\r\n        getRights().writeElement(writer, \"rights\");\r\n    }\r\n    if (getSubtitle() != null) {\r\n        getSubtitle().writeElement(writer, \"subtitle\");\r\n    }\r\n    if (getTitle() != null) {\r\n        getTitle().writeElement(writer, \"title\");\r\n    }\r\n    if (getUpdated() != null) {\r\n        Text.writeElement(writer, getUpdated(), ATOM_NAMESPACE, \"updated\");\r\n    }\r\n    writer.endElement(ATOM_NAMESPACE, \"source\");\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.way.InboundWay.onHeadersCompleted",
	"Comment": "callback invoked when a message has been received. note that only thestart line and the headers must have been received, not the optionalbody.",
	"Method": "void onHeadersCompleted(){\r\n    if (getLogger().isLoggable(Level.FINER)) {\r\n        getLogger().finer(\"Inbound message start line and headers received\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.representation.FileRepresentation.isAutoDeleting",
	"Comment": "indicates if this file should be automatically deleted on release of therepresentation.",
	"Method": "boolean isAutoDeleting(){\r\n    return autoDeleting;\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createPermissionQuery",
	"Comment": "creates a query for permission entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Permission> createPermissionQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Permission.class);\r\n}"
}, {
	"Path": "org.restlet.service.ConverterService.updatePreferences",
	"Comment": "updates the media type preferences with available conversion capabilitiesfor the given entity class.",
	"Method": "void updatePreferences(List<Preference<MediaType>> preferences,Class<?> entity){\r\n    for (ConverterHelper ch : Engine.getInstance().getRegisteredConverters()) {\r\n        ch.updatePreferences(preferences, entity);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.utils.CliUtils.printSentences",
	"Comment": "formats a list of strings by lines of columnsize characters maximum, and displaysit to the console.",
	"Method": "void printSentences(int indent,String strings){\r\n    for (String string : strings) {\r\n        printSentence(indent, string);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.freemarker.TemplateRepresentation.getTemplate",
	"Comment": "returns a freemarker template from its name and a configuration.",
	"Method": "Template getTemplate(Configuration config,Representation templateRepresentation,Template getTemplate,Configuration config,String templateName,Template getTemplate){\r\n    return template;\r\n}"
}, {
	"Path": "org.restlet.engine.local.Entity.getExtensions",
	"Comment": "returns the list of known extensions taken from a given variant.",
	"Method": "Collection<String> getExtensions(String name,MetadataService metadataService,Collection<String> getExtensions,Variant variant,MetadataService metadataService,Collection<String> getExtensions){\r\n    return getExtensions(getName(), getMetadataService());\r\n}"
}, {
	"Path": "org.restlet.routing.Redirector.rewriteLocation",
	"Comment": "rewrite the location of the response, and the location of the entity, ifany.",
	"Method": "void rewriteLocation(Request request,Response response){\r\n    if (response.getLocationRef() != null) {\r\n        Reference locationRef = response.getLocationRef();\r\n        String newLocation = getLocation(locationRef, request);\r\n        if (newLocation != null) {\r\n            response.setLocationRef(newLocation);\r\n        }\r\n    }\r\n    if (response.getEntity() != null && response.getEntity().getLocationRef() != null) {\r\n        Reference locationRef = response.getEntity().getLocationRef();\r\n        String newLocation = getLocation(locationRef, request);\r\n        if (newLocation != null) {\r\n            response.getEntity().setLocationRef(newLocation);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.channel.ReadableChunkingChannel.fillChunkSizeString",
	"Comment": "returns an hexadecimal chunk size string with a constant length, addingthe necessary number of leading zeroes.",
	"Method": "int fillChunkSizeString(int chunkDataSize,ByteBuffer targetBuffer){\r\n    int result = 0;\r\n    String chunkDataSizeString = Integer.toHexString(chunkDataSize);\r\n    result = chunkDataSizeString.length();\r\n    for (int i = chunkDataSizeString.length(); i < this.chunkSizeLength; i++) {\r\n        targetBuffer.put((byte) 48);\r\n        result++;\r\n    }\r\n    targetBuffer.put(StringUtils.getAsciiBytes(chunkDataSizeString));\r\n    targetBuffer.put((byte) 13);\r\n    targetBuffer.put((byte) 10);\r\n    result += 2;\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.ResourceInfo.setQueryType",
	"Comment": "sets the media type for the query component of the resource uri.",
	"Method": "void setQueryType(MediaType queryType){\r\n    this.queryType = queryType;\r\n}"
}, {
	"Path": "org.restlet.engine.Engine.discoverConnectors",
	"Comment": "discovers the server and client connectors and register the defaultconnectors.",
	"Method": "void discoverConnectors(){\r\n    registerHelpers(DESCRIPTOR_CLIENT_PATH, getRegisteredClients(), Client.class);\r\n    registerHelpers(DESCRIPTOR_SERVER_PATH, getRegisteredServers(), org.restlet.Server.class);\r\n    registerDefaultConnectors();\r\n}"
}, {
	"Path": "org.restlet.engine.resource.AnnotationUtils.addThrowableAnnotationDescriptors",
	"Comment": "computes the annotation descriptors for the given java method.",
	"Method": "List<AnnotationInfo> addThrowableAnnotationDescriptors(List<AnnotationInfo> descriptors,Class<?> clazz,Class<?> initialClass){\r\n    List<AnnotationInfo> result = descriptors;\r\n    Annotation annotation = clazz.getAnnotation(org.restlet.resource.Status.class);\r\n    if (annotation != null) {\r\n        Status status = (Status) annotation;\r\n        result.add(new ThrowableAnnotationInfo(initialClass, status.value(), status.serialize()));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.swagger.v2_0.SwaggerUtils.toString",
	"Comment": "safe tostring method, returns null if the object is null, calls its tostring otherwise.avoids npes.",
	"Method": "String toString(Object object){\r\n    return object == null ? null : object.toString();\r\n}"
}, {
	"Path": "org.restlet.ext.swagger.SwaggerSpecificationRestlet.getResourceListing",
	"Comment": "returns the representation of the whole resource listing of theapplication.",
	"Method": "Representation getResourceListing(){\r\n    ResourceListing resourcelisting = SwaggerWriter.getResourcelisting(getDefinition());\r\n    resourcelisting.setSwaggerVersion(swaggerVersion);\r\n    return new JacksonRepresentation(resourcelisting);\r\n}"
}, {
	"Path": "org.restlet.security.Realm.getVerifier",
	"Comment": "returns a verifier that can check the validity of the credentialsassociated to a request.",
	"Method": "Verifier getVerifier(){\r\n    return this.verifier;\r\n}"
}, {
	"Path": "org.restlet.data.Reference.isReserved",
	"Comment": "indicates if the given character is a reserved uri character.",
	"Method": "boolean isReserved(int character){\r\n    return isGenericDelimiter(character) || isSubDelimiter(character);\r\n}"
}, {
	"Path": "org.restlet.engine.adapter.Call.isBroken",
	"Comment": "returns true if the given exception is caused by a broken connection.",
	"Method": "boolean isBroken(Throwable exception){\r\n    boolean result = false;\r\n    if (exception instanceof IOException) {\r\n        String exceptionName = exception.getClass().getName();\r\n        result = (exceptionName.endsWith(\"ClientAbortException\") || exceptionName.endsWith(\"jetty.io.EofException\"));\r\n    }\r\n    if (!result) {\r\n        String exceptionMessage = exception.getMessage();\r\n        if (exceptionMessage != null) {\r\n            result = (exceptionMessage.indexOf(\"Broken pipe\") != -1) || (exceptionMessage.equals(\"An existing connection must have been closed by the remote party.\") || (exceptionMessage.equals(\"An open connection has been abandonned by your network stack.\")));\r\n        }\r\n    }\r\n    if (!result && exception.getCause() != null) {\r\n        result = isBroken(exception.getCause());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.component.ComponentXmlParser.attach",
	"Comment": "creates a new route on a router according to a target class name and auri pattern.",
	"Method": "TemplateRoute attach(Router router,String targetClassName,String uriPattern,boolean defaultRoute){\r\n    TemplateRoute route = null;\r\n    if (targetClassName != null) {\r\n        try {\r\n            final Class<?> targetClass = Engine.loadClass(targetClassName);\r\n            if (ServerResource.class.isAssignableFrom(targetClass)) {\r\n                final Class<? extends ServerResource> resourceClass = (Class<? extends ServerResource>) targetClass;\r\n                if ((uriPattern != null) && !defaultRoute) {\r\n                    route = router.attach(uriPattern, resourceClass);\r\n                } else {\r\n                    route = router.attachDefault(resourceClass);\r\n                }\r\n            } else {\r\n                Restlet target = null;\r\n                try {\r\n                    target = (Restlet) targetClass.getConstructor(Context.class).newInstance(getComponent().getContext().createChildContext());\r\n                } catch (NoSuchMethodException e) {\r\n                    getLogger().log(Level.FINE, \"Couldn't invoke the constructor of the target class. Please check this class has a constructor with a single parameter of type Context. The empty constructor and the context setter will be used instead: \" + targetClassName, e);\r\n                    target = (Restlet) targetClass.getConstructor().newInstance();\r\n                    target.setContext(getComponent().getContext().createChildContext());\r\n                }\r\n                if (target != null) {\r\n                    if ((uriPattern != null) && !defaultRoute) {\r\n                        route = router.attach(uriPattern, target);\r\n                    } else {\r\n                        route = router.attachDefault(target);\r\n                    }\r\n                }\r\n            }\r\n        } catch (ClassNotFoundException e) {\r\n            getLogger().log(Level.WARNING, \"Couldn't find the target class. Please check that your classpath includes \" + targetClassName, e);\r\n        } catch (InstantiationException e) {\r\n            getLogger().log(Level.WARNING, \"Couldn't instantiate the target class. Please check this class has an empty constructor \" + targetClassName, e);\r\n        } catch (IllegalAccessException e) {\r\n            getLogger().log(Level.WARNING, \"Couldn't instantiate the target class. Please check that you have to proper access rights to \" + targetClassName, e);\r\n        } catch (NoSuchMethodException e) {\r\n            getLogger().log(Level.WARNING, \"Couldn't invoke the constructor of the target class. Please check this class has a constructor with a single parameter of Context \" + targetClassName, e);\r\n        } catch (InvocationTargetException e) {\r\n            getLogger().log(Level.WARNING, \"Couldn't instantiate the target class. An exception was thrown while creating \" + targetClassName, e);\r\n        }\r\n    }\r\n    return route;\r\n}"
}, {
	"Path": "org.restlet.engine.io.IoUtils.getText",
	"Comment": "converts the representation to a string value. be careful when using thismethod as the conversion of large content to a string fully stored inmemory can result in outofmemoryerrors being thrown.",
	"Method": "String getText(Representation representation){\r\n    String result = null;\r\n    if (representation.isAvailable()) {\r\n        if (representation.getSize() == 0) {\r\n            result = \"\";\r\n        } else {\r\n            java.io.StringWriter sw = new java.io.StringWriter();\r\n            representation.write(sw);\r\n            sw.flush();\r\n            result = sw.toString();\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Content.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    final AttributesImpl attributes = new AttributesImpl();\r\n    String strContent = null;\r\n    if (getInlineContent() != null) {\r\n        final MediaType mediaType = getInlineContent().getMediaType();\r\n        String type = null;\r\n        if ((mediaType != null) && (mediaType.getSubType() != null)) {\r\n            if (mediaType.getSubType().contains(\"xhtml\")) {\r\n                type = \"xhtml\";\r\n            } else if (mediaType.getSubType().contains(\"html\")) {\r\n                type = \"html\";\r\n            } else {\r\n                type = mediaType.getName();\r\n            }\r\n        }\r\n        if (type == null) {\r\n            type = \"text\";\r\n        }\r\n        attributes.addAttribute(\"\", \"type\", null, \"text\", type);\r\n        try {\r\n            strContent = getInlineContent().getText();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    } else {\r\n        if ((getExternalType() != null) && (getExternalType().toString() != null)) {\r\n            attributes.addAttribute(\"\", \"type\", null, \"atomMediaType\", getExternalType().toString());\r\n        }\r\n        if ((getExternalRef() != null) && (getExternalRef().toString() != null)) {\r\n            attributes.addAttribute(\"\", \"src\", null, \"atomURI\", getExternalRef().toString());\r\n        }\r\n    }\r\n    if (strContent == null) {\r\n        writer.emptyElement(ATOM_NAMESPACE, \"content\", null, attributes);\r\n    } else {\r\n        if (isToEncode()) {\r\n            writer.dataElement(ATOM_NAMESPACE, \"content\", null, attributes, strContent);\r\n        } else {\r\n            writer.startElement(ATOM_NAMESPACE, \"content\", null, attributes);\r\n            try {\r\n                writer.getWriter().write(strContent);\r\n            } catch (IOException e) {\r\n                throw new SAXException(e);\r\n            }\r\n            writer.endElement(ATOM_NAMESPACE, \"content\", null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.toEdmBoolean",
	"Comment": "convert the given value to the string representation of a edm booleanvalue.",
	"Method": "String toEdmBoolean(boolean value){\r\n    return Boolean.toString(value);\r\n}"
}, {
	"Path": "org.restlet.routing.Router.attachDefault",
	"Comment": "attaches a restlet to this router as the default target to invoke when noroute matches. it actually sets a default route that scores all calls to1.0.",
	"Method": "TemplateRoute attachDefault(Class<? extends ServerResource> defaultTargetClass,TemplateRoute attachDefault,Restlet defaultTarget){\r\n    TemplateRoute result = createRoute(\"\", defaultTarget);\r\n    result.setMatchingMode(Template.MODE_STARTS_WITH);\r\n    setDefaultRoute(result);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.core.MultivaluedMapImpl.clone",
	"Comment": "creates a clone of this map. the contained values are not cloned.",
	"Method": "MultivaluedMapImpl<K, V> clone(){\r\n    return new MultivaluedMapImpl<K, V>(this);\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.RdfClientResource.getLinked",
	"Comment": "returns the linked resources, based on the rdf representation exposed.the type of links to follow can be restricted.",
	"Method": "Set<RdfClientResource> getLinked(Set<RdfClientResource> getLinked,Collection<Reference> typeRefs,Set<RdfClientResource> getLinked,Reference typeRef){\r\n    return getLinked(Collections.singleton(typeRef));\r\n}"
}, {
	"Path": "org.restlet.ext.json.JsonRepresentation.getJsonText",
	"Comment": "returns the json text for the wrapped json object or representation.",
	"Method": "String getJsonText(){\r\n    String result = null;\r\n    if (this.jsonValue != null) {\r\n        if (this.jsonValue instanceof JSONArray) {\r\n            JSONArray jsonArray = (JSONArray) this.jsonValue;\r\n            if (isIndenting()) {\r\n                result = jsonArray.toString(getIndentingSize());\r\n            } else {\r\n                result = jsonArray.toString();\r\n            }\r\n        } else if (this.jsonValue instanceof JSONObject) {\r\n            JSONObject jsonObject = (JSONObject) this.jsonValue;\r\n            if (isIndenting()) {\r\n                result = jsonObject.toString(getIndentingSize());\r\n            } else {\r\n                result = jsonObject.toString();\r\n            }\r\n        } else if (this.jsonValue instanceof JSONStringer) {\r\n            JSONStringer jsonStringer = (JSONStringer) this.jsonValue;\r\n            result = jsonStringer.toString();\r\n        } else if (this.jsonValue instanceof JSONTokener) {\r\n            JSONTokener jsonTokener = (JSONTokener) this.jsonValue;\r\n            result = jsonTokener.toString();\r\n        }\r\n    } else if (this.jsonRepresentation != null) {\r\n        try {\r\n            result = this.jsonRepresentation.getText();\r\n        } catch (IOException e) {\r\n            throw new JSONException(e);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.connection.Connection.onActivity",
	"Comment": "notifies the connection that a new activity has been detected and that itshould be kept alive.",
	"Method": "void onActivity(){\r\n    this.lastActivity = System.currentTimeMillis();\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlWriter.processingInstruction",
	"Comment": "write a processing instruction. pass the event on down the filter chainfor further processing.",
	"Method": "void processingInstruction(String target,String data){\r\n    write(\"<?\");\r\n    write(target);\r\n    write(' ');\r\n    write(data);\r\n    write(\"?>\");\r\n    if (this.elementLevel < 1) {\r\n        write('\\n');\r\n    }\r\n    super.processingInstruction(target, data);\r\n}"
}, {
	"Path": "org.restlet.resource.ServerResource.getRole",
	"Comment": "retrieves an existing role or creates a new one if needed based on itsname. note that a null description will be set if the role has to becreated.",
	"Method": "Role getRole(String name){\r\n    return Role.get(getApplication(), name);\r\n}"
}, {
	"Path": "org.restlet.service.EncoderService.getMinimumSize",
	"Comment": "returns the minimum size a representation must have before compression isdone.",
	"Method": "long getMinimumSize(){\r\n    return this.mininumSize;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.introspection.jaxrs.JaxRsIntrospector.scanResources",
	"Comment": "returns a apispark description of the current application. by default,this method discovers all the resources attached to this application. itcan be overridden to add documentation, list of representations, etc.",
	"Method": "void scanResources(CollectInfo collectInfo,List<Class> resources,List<? extends IntrospectionHelper> introspectionHelper){\r\n    for (Class<?> clazz : resources) {\r\n        scanClazz(collectInfo, clazz, introspectionHelper);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createFacultyUserQuery",
	"Comment": "creates a query for facultyuser entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.FacultyUser> createFacultyUserQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.FacultyUser.class);\r\n}"
}, {
	"Path": "org.restlet.resource.ServerResource.isNegotiated",
	"Comment": "indicates if content negotiation of response entities is enabled. thedefault value is true.",
	"Method": "boolean isNegotiated(){\r\n    return this.negotiated;\r\n}"
}, {
	"Path": "org.restlet.Application.start",
	"Comment": "starts the application, all the enabled associated services then theinbound and outbound roots.",
	"Method": "void start(){\r\n    if (isStopped()) {\r\n        if (isDebugging()) {\r\n            getLogger().log(Level.INFO, \"Starting \" + getClass().getName() + \" application in debug mode\");\r\n        } else {\r\n            getLogger().log(Level.INFO, \"Starting \" + getClass().getName() + \" application\");\r\n        }\r\n        if (getHelper() != null) {\r\n            getHelper().start();\r\n        }\r\n        getServices().start();\r\n        if (getInboundRoot() != null) {\r\n            getInboundRoot().start();\r\n        }\r\n        if (getOutboundRoot() != null) {\r\n            getOutboundRoot().start();\r\n        }\r\n        super.start();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.Engine.configureLog",
	"Comment": "updates the global log configuration of the jvm programmatically.",
	"Method": "void configureLog(){\r\n    if ((System.getProperty(\"java.util.logging.config.file\") == null) && (System.getProperty(\"java.util.logging.config.class\") == null)) {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"handlers=\").append(java.util.logging.ConsoleHandler.class.getCanonicalName()).append('\\n');\r\n        if (getLogLevel() != null) {\r\n            sb.append(\".level=\").append(getLogLevel().getName()).append('\\n');\r\n        }\r\n        if (getRestletLogLevel() != null) {\r\n            sb.append(\"org.restlet.level=\").append(getRestletLogLevel().getName()).append('\\n');\r\n        }\r\n        if (getLogFormatter() != null) {\r\n            String handler = java.util.logging.ConsoleHandler.class.getCanonicalName();\r\n            sb.append(handler).append(\".formatter=\").append(getLogFormatter().getCanonicalName()).append(\"\\n\");\r\n            if (getLogLevel() != null) {\r\n                sb.append(handler).append(\".level=\").append(getLogLevel().getName()).append(\"\\n\");\r\n            }\r\n        }\r\n        try {\r\n            LogManager.getLogManager().readConfiguration(new ByteArrayInputStream(sb.toString().getBytes()));\r\n        } catch (Throwable t) {\r\n            t.printStackTrace();\r\n        }\r\n    }\r\n    logConfigured = true;\r\n}"
}, {
	"Path": "org.restlet.ext.httpclient.HttpClientHelper.isFollowRedirects",
	"Comment": "indicates if the protocol will automatically follow redirects.",
	"Method": "boolean isFollowRedirects(){\r\n    return Boolean.parseBoolean(getHelpedParameters().getFirstValue(\"followRedirects\", \"false\"));\r\n}"
}, {
	"Path": "org.restlet.service.TunnelService.setExtensionsTunnel",
	"Comment": "indicates if the client preferences can be tunneled via the extensions.",
	"Method": "void setExtensionsTunnel(boolean extensionTunnel){\r\n    this.extensionsTunnel = extensionTunnel;\r\n}"
}, {
	"Path": "org.restlet.ext.httpclient.HttpClientHelper.createClientConnectionManager",
	"Comment": "creates the connection manager. by default, it creates a thread safeconnection manager.",
	"Method": "ClientConnectionManager createClientConnectionManager(HttpParams params,SchemeRegistry schemeRegistry){\r\n    return new ThreadSafeClientConnManager(params, schemeRegistry);\r\n}"
}, {
	"Path": "org.restlet.engine.resource.MethodAnnotationInfo.equals",
	"Comment": "indicates if the current object is equal to the given object.",
	"Method": "boolean equals(Object other){\r\n    if (other == this) {\r\n        return true;\r\n    }\r\n    if (!(other instanceof MethodAnnotationInfo)) {\r\n        return false;\r\n    }\r\n    MethodAnnotationInfo that = (MethodAnnotationInfo) other;\r\n    return super.equals(that) && Objects.equals(getRestletMethod(), that.getRestletMethod());\r\n}"
}, {
	"Path": "org.restlet.ext.html.FormData.getValueRepresentation",
	"Comment": "returns the value of the associated form control, either textual orbinary.",
	"Method": "Representation getValueRepresentation(){\r\n    return valueRepresentation;\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.Link.getTarget",
	"Comment": "returns the target which can be either a literal or a reference or isnull. this maps with the concept of object in rdf terminology.",
	"Method": "Object getTarget(){\r\n    return this.target;\r\n}"
}, {
	"Path": "org.restlet.engine.adapter.ServerCall.getCertificates",
	"Comment": "returns the chain of client ssl certificates, if available andaccessible.",
	"Method": "List<Certificate> getCertificates(){\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.ext.openid.OpenIdVerifier.verify",
	"Comment": "verifies a request. the verifier will be called twice to verify a requestsince verification is done remotely using callbacks. also sets the userobject.",
	"Method": "int verify(Request request,Response response){\r\n    Form params = request.getResourceRef().getQueryAsForm();\r\n    if (rp.hasReturnTo(request)) {\r\n        Context.getCurrentLogger().info(\"handling return\");\r\n        Map<AttributeExchange, String> axResp = new HashMap<AttributeExchange, String>();\r\n        try {\r\n            Identifier identifier = rp.verify(axResp, request, true);\r\n            if (identifier != null && identifier.getIdentifier() != null) {\r\n                User u = new User(identifier.getIdentifier());\r\n                if (axResp.size() > 0) {\r\n                    for (Map.Entry<AttributeExchange, String> entry : axResp.entrySet()) {\r\n                        OpenIdUser.setValueFromAX(entry.getKey(), entry.getValue(), u);\r\n                    }\r\n                }\r\n                request.getClientInfo().setUser(u);\r\n                return RESULT_VALID;\r\n            } else\r\n                return RESULT_INVALID;\r\n        } catch (Exception e) {\r\n            Reference ref = new Reference(request.getResourceRef().getHostIdentifier() + request.getResourceRef().getPath());\r\n            Context.getCurrentLogger().info(\"Generating XRDS Response\");\r\n            if (params.getFirst(\"sessionId\") != null) {\r\n                ref.addQueryParameter(\"sessionId\", params.getFirstValue(\"sessionId\"));\r\n                ref.addQueryParameter(\"return\", \"true\");\r\n            }\r\n            try {\r\n                Representation rep = XRDS.returnToXrds(ref.toString());\r\n                response.setEntity(rep);\r\n                return RESULT_MISSING;\r\n            } catch (Exception e1) {\r\n                e.printStackTrace();\r\n                return RESULT_UNKNOWN;\r\n            }\r\n        }\r\n    } else {\r\n        String target = this.getTarget(params, request);\r\n        Reference ref = new Reference(request.getResourceRef().getHostIdentifier() + request.getResourceRef().getPath());\r\n        Context.getCurrentLogger().info(\"generating a authentication request\");\r\n        try {\r\n            rp.authRequest(target, true, true, ref.toString(), optionalAttributes, requiredAttributes, request, response);\r\n            return RESULT_MISSING;\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return RESULT_INVALID;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.ASTManager.addToCompleteTree",
	"Comment": "adds a file and a detailast to the root symtabast tree. normally, thedetailast will be the parse tree for the file.",
	"Method": "void addToCompleteTree(File aFile,AST aAST){\r\n    final SymTabAST fileNode = SymTabASTFactory.create(0, aFile.getAbsolutePath());\r\n    fileNode.setFile(aFile);\r\n    mCompleteTree.addChild(fileNode);\r\n    fileNode.setParent(mCompleteTree);\r\n    final SymTabAST child = SymTabASTFactory.create(aAST);\r\n    child.setFile(aFile);\r\n    fileNode.addChild(child);\r\n    child.setParent(fileNode);\r\n    fileNode.finishDefinition(aFile, mCompleteTree);\r\n}"
}, {
	"Path": "org.restlet.routing.Variable.encode",
	"Comment": "according to the type of the variable, encodes the value given inparameters.",
	"Method": "String encode(String value){\r\n    switch(this.type) {\r\n        case Variable.TYPE_URI_ALL:\r\n            return Reference.encode(value);\r\n        case Variable.TYPE_URI_UNRESERVED:\r\n            return Reference.encode(value);\r\n        case Variable.TYPE_URI_FRAGMENT:\r\n            return Reference.encode(value);\r\n        case Variable.TYPE_URI_PATH:\r\n            return Reference.encode(value);\r\n        case Variable.TYPE_URI_QUERY:\r\n            return Reference.encode(value);\r\n        case Variable.TYPE_URI_SEGMENT:\r\n            return Reference.encode(value);\r\n        default:\r\n            return value;\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.util.SystemUtils.isWindows",
	"Comment": "indicates if the current operating system is in the windows family.",
	"Method": "boolean isWindows(){\r\n    return System.getProperty(\"os.name\").toLowerCase().indexOf(\"win\") >= 0;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.ApiSparkService.getAgentPassword",
	"Comment": "returns the password used to connect to the apispark platform.",
	"Method": "String getAgentPassword(){\r\n    return new String(agentPassword);\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.buffer.Buffer.hasRemaining",
	"Comment": "indicates if the buffer has remaining bytes to be read or written.",
	"Method": "boolean hasRemaining(){\r\n    return getBytes().hasRemaining();\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.exceptions.ConvertRepresentationException.object",
	"Comment": "throws a message, that the given string value could not be converted to aprimitive.",
	"Method": "ConvertRepresentationException object(Class<?> paramType,Object unparseableValue,Throwable cause){\r\n    throw new ConvertRepresentationException(\"Could not convert \" + unparseableValue + \" to a \" + paramType.getName(), cause);\r\n}"
}, {
	"Path": "org.restlet.engine.resource.AnnotationUtils.getThrowableAnnotationInfo",
	"Comment": "returns the status annotation descriptor if present or null.",
	"Method": "ThrowableAnnotationInfo getThrowableAnnotationInfo(Class<?> clazz,ThrowableAnnotationInfo getThrowableAnnotationInfo,java.lang.reflect.Method javaMethod,int errorCode){\r\n    for (Class<?> clazz : javaMethod.getExceptionTypes()) {\r\n        ThrowableAnnotationInfo tai = getThrowableAnnotationInfo(clazz);\r\n        if (tai != null && tai.getStatus().getCode() == errorCode) {\r\n            return tai;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.ext.xstream.XstreamRepresentation.getObject",
	"Comment": "returns the wrapped object, deserializing the representation with xstreamif necessary.",
	"Method": "T getObject(){\r\n    T result = null;\r\n    if (this.object != null) {\r\n        getXstream().processAnnotations(this.object.getClass());\r\n        result = this.object;\r\n    } else if (this.representation != null) {\r\n        if (this.targetClass != null) {\r\n            getXstream().processAnnotations(this.targetClass);\r\n        }\r\n        try {\r\n            result = (T) getXstream().fromXML(this.representation.getStream());\r\n        } catch (ForbiddenClassException fce) {\r\n            throw new IllegalArgumentException(\"SECURITY WARNING: The usage of XstreamRepresentation when \" + \"deserializing representations from unstrusted \" + \"sources can lead to malicious attacks. As pointed \" + \"here (http://xstream.codehaus.org/security.html), \" + \"it is possible to force the JVM to execute unwanted \" + \"Java code described inside the representation.\" + \"Thus, the support of such format has been \" + \"restricted by default to basic data types such as \" + \"primitive types, subclasses of the java.util.Collection \" + \"class (cf http://xstream.codehaus.org/security.html#framework). \" + \"You can override this behavior by setting your own XStream facade \" + \"object (see XStreamRepresentation#setXStream method).\", fce);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.service.ConnectorService.getClientProtocols",
	"Comment": "returns the modifiable list of required client protocols. you need toupdate this list if you need the parent component to provide additionalclient connectors.",
	"Method": "List<Protocol> getClientProtocols(){\r\n    return this.clientProtocols;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxb.JaxbRepresentation.setExpandingEntityRefs",
	"Comment": "indicates if the parser will expand entity reference nodes. by defaultthe value of this is set to true.",
	"Method": "void setExpandingEntityRefs(boolean expandEntityRefs){\r\n    this.expandingEntityRefs = expandEntityRefs;\r\n}"
}, {
	"Path": "org.restlet.service.ConverterService.getVariants",
	"Comment": "returns the list of variants that can be converted from a given objectclass.",
	"Method": "List<? extends Variant> getVariants(Class<?> source,Variant target){\r\n    return ConverterUtils.getVariants(source, target);\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.WrapperUtil.checkParameterAnnotation",
	"Comment": "checks, if the annotations are valid for a runtime environment handledconstructor.",
	"Method": "boolean checkParameterAnnotation(Annotation[] parameterAnnotations,Class<?> parameterType){\r\n    if (parameterAnnotations.length == 0) {\r\n        return false;\r\n    }\r\n    for (final Annotation annotation : parameterAnnotations) {\r\n        final Class<? extends Annotation> annotationType = annotation.annotationType();\r\n        if (annotationType.equals(HeaderParam.class)) {\r\n            continue;\r\n        } else if (annotationType.equals(PathParam.class)) {\r\n            continue;\r\n        } else if (annotationType.equals(Context.class)) {\r\n            if (parameterType.equals(UriInfo.class)) {\r\n                continue;\r\n            }\r\n            if (parameterType.equals(Request.class)) {\r\n                continue;\r\n            }\r\n            if (parameterType.equals(HttpHeaders.class)) {\r\n                continue;\r\n            }\r\n            if (parameterType.equals(SecurityContext.class)) {\r\n                continue;\r\n            }\r\n            return false;\r\n        } else if (annotationType.equals(MatrixParam.class)) {\r\n            continue;\r\n        } else if (annotationType.equals(QueryParam.class)) {\r\n            continue;\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.ConnectionHelper.isSocketKeepAlive",
	"Comment": "indicates if a tcp connection should be automatically kept alive after 2hours of inactivity.",
	"Method": "boolean isSocketKeepAlive(){\r\n    return Boolean.parseBoolean(getHelpedParameters().getFirstValue(\"socketKeepAlive\", \"true\"));\r\n}"
}, {
	"Path": "org.restlet.ext.emf.EmfRepresentation.createEmfXmlResource",
	"Comment": "creates and configure an emf resource. not to be confused with a restletresource.",
	"Method": "XMLResource createEmfXmlResource(MediaType mediaType){\r\n    XMLResource result = null;\r\n    if (MediaType.APPLICATION_ECORE.isCompatible(getMediaType())) {\r\n        result = new EMOFResourceImpl();\r\n    } else if (MediaType.APPLICATION_XMI.isCompatible(getMediaType())) {\r\n        result = new XMIResourceImpl();\r\n    } else {\r\n        result = new XMLResourceImpl();\r\n    }\r\n    if (getCharacterSet() != null) {\r\n        result.setEncoding(getCharacterSet().getName());\r\n    } else {\r\n        result.setEncoding(CharacterSet.UTF_8.getName());\r\n    }\r\n    result.getDefaultLoadOptions().put(XMLResource.OPTION_EXTENDED_META_DATA, Boolean.TRUE);\r\n    result.getDefaultLoadOptions().put(XMLResource.OPTION_USE_LEXICAL_HANDLER, Boolean.TRUE);\r\n    result.getDefaultLoadOptions().put(XMLResource.OPTION_USE_ENCODED_ATTRIBUTE_STYLE, Boolean.TRUE);\r\n    result.getDefaultSaveOptions().put(XMLResource.OPTION_EXTENDED_META_DATA, Boolean.TRUE);\r\n    result.getDefaultSaveOptions().put(XMLResource.OPTION_LINE_WIDTH, getLineWidth());\r\n    result.getDefaultSaveOptions().put(XMLResource.OPTION_USE_ENCODED_ATTRIBUTE_STYLE, isUsingEncodedAttributeStyle());\r\n    result.getDefaultSaveOptions().put(XMLResource.OPTION_SCHEMA_LOCATION, Boolean.TRUE);\r\n    XMLOptions xmlOptions = new XMLOptionsImpl();\r\n    xmlOptions.setProcessAnyXML(true);\r\n    xmlOptions.setProcessSchemaLocations(true);\r\n    result.getDefaultLoadOptions().put(XMLResource.OPTION_XML_OPTIONS, xmlOptions);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.resource.ServerResource.abort",
	"Comment": "ask the connector to abort the related network connection, for exampleimmediately closing the socket.",
	"Method": "void abort(){\r\n    getResponse().abort();\r\n}"
}, {
	"Path": "org.restlet.util.Series.getValues",
	"Comment": "returns the parameter values with a given name. if multiple parameterswith the same name are found, all values are concatenated and separatedby the given separator.",
	"Method": "String getValues(String name,String getValues,String name,String separator,boolean ignoreCase){\r\n    String result = null;\r\n    StringBuilder sb = null;\r\n    for (final T param : this) {\r\n        if ((ignoreCase && param.getName().equalsIgnoreCase(name)) || param.getName().equals(name)) {\r\n            if (sb == null) {\r\n                if (result == null) {\r\n                    result = param.getValue();\r\n                } else {\r\n                    sb = new StringBuilder();\r\n                    sb.append(result).append(separator).append(param.getValue());\r\n                }\r\n            } else {\r\n                sb.append(separator).append(param.getValue());\r\n            }\r\n        }\r\n    }\r\n    if (sb != null) {\r\n        result = sb.toString();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipRequest.getRoutes",
	"Comment": "returns the set of proxies used to force routing for a request.",
	"Method": "List<Address> getRoutes(){\r\n    List<Address> r = this.routes;\r\n    if (r == null) {\r\n        synchronized (this) {\r\n            r = this.routes;\r\n            if (r == null) {\r\n                this.routes = r = new CopyOnWriteArrayList<Address>();\r\n            }\r\n        }\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.params.ContextInjector.init",
	"Comment": "initiates the fields to cache the fields that needs injection.",
	"Method": "void init(Class<?> jaxRsClass,ThreadLocalizedContext tlContext,Providers allProviders,ExtensionBackwardMapping extensionBackwardMapping){\r\n    do {\r\n        try {\r\n            for (final Field field : jaxRsClass.getDeclaredFields()) {\r\n                if (field.isAnnotationPresent(Context.class)) {\r\n                    InjectionAim aim = new FieldWrapper(field);\r\n                    Class<?> declaringClass = field.getType();\r\n                    Injector injector = getInjector(declaringClass, aim, tlContext, allProviders, extensionBackwardMapping);\r\n                    this.injEverSameAims.add(injector);\r\n                }\r\n            }\r\n        } catch (SecurityException e) {\r\n            throw e;\r\n        } catch (IllegalTypeException e) {\r\n            throw new IllegalFieldTypeException(e);\r\n        }\r\n        try {\r\n            for (final Method method : jaxRsClass.getDeclaredMethods()) {\r\n                if (isBeanSetter(method, Context.class)) {\r\n                    BeanSetter aim = new BeanSetter(method);\r\n                    Class<?> paramClass = method.getParameterTypes()[0];\r\n                    Injector injector = getInjector(paramClass, aim, tlContext, allProviders, extensionBackwardMapping);\r\n                    this.injEverSameAims.add(injector);\r\n                }\r\n            }\r\n        } catch (SecurityException e) {\r\n            throw e;\r\n        } catch (IllegalTypeException e) {\r\n            throw new IllegalBeanSetterTypeException(e);\r\n        }\r\n        jaxRsClass = jaxRsClass.getSuperclass();\r\n    } while (jaxRsClass != null);\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.raml.RamlTranslator.getRaml",
	"Comment": "retrieves the raml api declaration corresponding to a category of thegiven restlet web api definition.",
	"Method": "Raml getRaml(Definition definition){\r\n    Raml raml = new Raml();\r\n    ObjectMapper m = new ObjectMapper();\r\n    if (definition.getVersion() != null) {\r\n        raml.setVersion(definition.getVersion());\r\n    }\r\n    Contract contract = definition.getContract();\r\n    Map<String, Map<String, Object>> representationSamples = getSamples(contract);\r\n    Endpoint endpoint = null;\r\n    if (!definition.getEndpoints().isEmpty()) {\r\n        endpoint = definition.getEndpoints().get(0);\r\n        raml.setBaseUri(endpoint.computeUrl());\r\n    } else {\r\n        raml.setBaseUri(\"http://example.com/v1\");\r\n    }\r\n    raml.setSecuritySchemes(getSecuritySchemes(endpoint));\r\n    raml.setTitle(contract.getName());\r\n    raml.setResources(new LinkedHashMap<String, org.raml.model.Resource>());\r\n    fillResources(raml.getResources(), m, contract, representationSamples);\r\n    raml.setSchemas(new ArrayList<Map<String, String>>());\r\n    Map<String, String> schemas = new LinkedHashMap();\r\n    raml.getSchemas().add(schemas);\r\n    for (Representation representation : contract.getRepresentations()) {\r\n        if (RamlUtils.isPrimitiveType(representation.getName())) {\r\n            continue;\r\n        }\r\n        try {\r\n            RamlUtils.fillSchemas(representation, schemas, m);\r\n        } catch (JsonProcessingException e) {\r\n            LOGGER.log(Level.WARNING, \"Error when putting mime type schema for representation: \" + representation.getName(), e);\r\n        }\r\n    }\r\n    return raml;\r\n}"
}, {
	"Path": "org.restlet.test.data.ReferenceTestCase.testRef4",
	"Comment": "test the behaviour of several getters upon a reference object.",
	"Method": "void testRef4(Reference reference,String scheme,String authority,String path,String remainingPart,String toString,String targetRef,String query,String relativePart){\r\n    assertEquals(reference.getScheme(), scheme);\r\n    assertEquals(reference.getAuthority(), authority);\r\n    assertEquals(reference.getPath(), path);\r\n    assertEquals(reference.getRemainingPart(), remainingPart);\r\n    assertEquals(reference.toString(), toString);\r\n    assertEquals(reference.getTargetRef().toString(), targetRef);\r\n    assertEquals(reference.getQuery(), query);\r\n    assertEquals(reference.getRelativePart(), relativePart);\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.ResourceInfo.getPath",
	"Comment": "returns the uri template for the identifier of the resource.",
	"Method": "String getPath(){\r\n    return this.path;\r\n}"
}, {
	"Path": "com.restfb.JsonMapperToJavaTest.friendsGet",
	"Comment": "can we successfully map the results of the friends.get call?",
	"Method": "void friendsGet(){\r\n    List<Long> friendUids = createJsonMapper().toJavaList(jsonFromClasspath(\"api/friends.get\"), Long.class);\r\n    assertThat(friendUids).hasSize(2);\r\n    assertThat(friendUids).containsExactly(222333L, 1240079L);\r\n}"
}, {
	"Path": "org.restlet.ext.javamail.JavaMailClientHelper.createMessage",
	"Comment": "creates a javamail message by parsing an xml representation.",
	"Method": "Message createMessage(Representation xmlMessage,Session session){\r\n    final String representationMessageClassName = getRepresentationMessageClass();\r\n    if (representationMessageClassName == null) {\r\n        return new RepresentationMessage(xmlMessage, session);\r\n    }\r\n    try {\r\n        final Class<? extends RepresentationMessage> representationMessageClass = (Class<? extends RepresentationMessage>) Class.forName(representationMessageClassName);\r\n        return representationMessageClass.getConstructor(Representation.class, Session.class).newInstance(xmlMessage, session);\r\n    } catch (Exception e) {\r\n        getLogger().log(Level.SEVERE, \"Unable to create a new instance of \" + representationMessageClassName, e);\r\n        return new RepresentationMessage(xmlMessage, session);\r\n    }\r\n}"
}, {
	"Path": "com.restfb.JsonMapperToJavaTest.emptyStringAsList",
	"Comment": "check if a empty string is not mapped and a exception with the correct message is thrown instead",
	"Method": "void emptyStringAsList(){\r\n    try {\r\n        createJsonMapper().toJavaList(\"\", HashMap.class);\r\n        failBecauseExceptionWasNotThrown(FacebookJsonMappingException.class);\r\n    } catch (FacebookJsonMappingException fe) {\r\n        assertThat(fe.getMessage()).startsWith(\"JSON is an empty string\");\r\n    }\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.checks.AbstractReferenceCheck.setIgnoreName",
	"Comment": "set the ignore name format to the specified regular expression.",
	"Method": "void setIgnoreName(String aFormat){\r\n    try {\r\n        mIgnoreNameRegexp = Utils.getPattern(aFormat);\r\n    } catch (PatternSyntaxException e) {\r\n        throw new ConversionException(\"unable to parse \" + aFormat, e);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.JettyServerHelper.getLowResourceMonitorIdleTimeout",
	"Comment": "low resource monitor idle timeout in milliseconds. defaults to 1000.applied to endpoints when in the low resources state.",
	"Method": "int getLowResourceMonitorIdleTimeout(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"lowResource.idleTimeout\", \"1000\"));\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.ASTUtil.constructDottedName",
	"Comment": "builds the dotted name string representation of the object contained withinthe symtabast.",
	"Method": "String constructDottedName(SymTabAST tree){\r\n    String result;\r\n    if (tree.getType() == TokenTypes.DOT) {\r\n        SymTabAST left = (SymTabAST) tree.getFirstChild();\r\n        SymTabAST right = (SymTabAST) left.getNextSibling();\r\n        result = constructDottedName(left) + \".\" + constructDottedName(right);\r\n    } else if (tree.getType() == TokenTypes.ARRAY_DECLARATOR) {\r\n        StringBuffer buf = new StringBuffer();\r\n        SymTabAST left = (SymTabAST) tree.getFirstChild();\r\n        SymTabAST right = (SymTabAST) left.getNextSibling();\r\n        buf.append(constructDottedName(left));\r\n        if (right != null) {\r\n            buf.append(\".\");\r\n            buf.append(constructDottedName(right));\r\n        }\r\n        buf.append(\" []\");\r\n        result = buf.toString();\r\n    } else if (tree.getType() == TokenTypes.METHOD_CALL) {\r\n        result = constructDottedName((SymTabAST) tree.getFirstChild()) + \"()\";\r\n    } else {\r\n        result = tree.getText();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.service.TaskService.schedule",
	"Comment": "creates and executes a scheduledfuture that becomes enabled after thegiven delay.",
	"Method": "ScheduledFuture<V> schedule(Callable<V> callable,long delay,TimeUnit unit,ScheduledFuture<?> schedule,Runnable command,long delay,TimeUnit unit){\r\n    startIfNeeded();\r\n    return getWrapped().schedule(command, delay, unit);\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.ApplicationInfo.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    updateNamespaces(getNamespaces());\r\n    for (String key : getNamespaces().keySet()) {\r\n        writer.forceNSDecl(key, getNamespaces().get(key));\r\n    }\r\n    writer.startElement(APP_NAMESPACE, \"application\");\r\n    for (final DocumentationInfo documentationInfo : getDocumentations()) {\r\n        documentationInfo.writeElement(writer);\r\n    }\r\n    if (getGrammars() != null) {\r\n        getGrammars().writeElement(writer);\r\n    }\r\n    for (final MethodInfo methodInfo : getMethods()) {\r\n        methodInfo.writeElement(writer);\r\n    }\r\n    for (final RepresentationInfo representationInfo : getRepresentations()) {\r\n        representationInfo.writeElement(writer);\r\n    }\r\n    if (getResources() != null) {\r\n        getResources().writeElement(writer);\r\n    }\r\n    for (final ResourceTypeInfo resourceTypeInfo : getResourceTypes()) {\r\n        resourceTypeInfo.writeElement(writer);\r\n    }\r\n    writer.endElement(APP_NAMESPACE, \"application\");\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.CookieAuthenticator.setEncryptSecretKey",
	"Comment": "sets the secret key for the algorithm used to encrypt the log info cookievalue.",
	"Method": "void setEncryptSecretKey(byte[] secretKey){\r\n    this.encryptSecretKey = secretKey;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.util.NioUtils.waitForState",
	"Comment": "waits for the given channel to be ready for a specific operation.",
	"Method": "void waitForState(SelectableChannel selectableChannel,int operations){\r\n    if (selectableChannel != null) {\r\n        Selector selector = null;\r\n        SelectionKey selectionKey = null;\r\n        int selected = 0;\r\n        try {\r\n            selector = SelectorFactory.getSelector();\r\n            while (selected == 0) {\r\n                selectionKey = selectableChannel.register(selector, operations);\r\n                selected = selector.select(IoUtils.TIMEOUT_MS);\r\n            }\r\n        } finally {\r\n            IoUtils.release(selector, selectionKey);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.atom.EntryReader.startLink",
	"Comment": "called when a new link has been detected in the atom document.",
	"Method": "void startLink(Link link){\r\n    if (this.entryReader != null) {\r\n        this.entryReader.startLink(link);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.routing.Template.quote",
	"Comment": "quotes special characters that could be taken for special regexcharacters.",
	"Method": "String quote(char character){\r\n    switch(character) {\r\n        case '[':\r\n            return \"\\\\[\";\r\n        case ']':\r\n            return \"\\\\]\";\r\n        case '.':\r\n            return \"\\\\.\";\r\n        case '\\\\':\r\n            return \"\\\\\\\\\";\r\n        case '$':\r\n            return \"\\\\$\";\r\n        case '^':\r\n            return \"\\\\^\";\r\n        case '?':\r\n            return \"\\\\?\";\r\n        case '*':\r\n            return \"\\\\*\";\r\n        case '|':\r\n            return \"\\\\|\";\r\n        case '(':\r\n            return \"\\\\(\";\r\n        case ')':\r\n            return \"\\\\)\";\r\n        case ':':\r\n            return \"\\\\:\";\r\n        case '-':\r\n            return \"\\\\-\";\r\n        case '!':\r\n            return \"\\\\!\";\r\n        case '<':\r\n            return \"\\\\<\";\r\n        case '>':\r\n            return \"\\\\>\";\r\n        default:\r\n            return Character.toString(character);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.DigestAuthenticator.getHashedSecret",
	"Comment": "return the hashed secret. by default, it knows how to hash http digestsecrets, specified as a1 in section 3.2.2.2 of rfc2617, or null if theidentifier has no corresponding secret.",
	"Method": "String getHashedSecret(String identifier,char[] secret){\r\n    if (ChallengeScheme.HTTP_DIGEST.equals(getScheme())) {\r\n        return DigestUtils.toHttpDigest(identifier, secret, getRealm());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.ext.spring.SpringResource.getInputStream",
	"Comment": "this implementation throws illegalstateexception if attempting to readthe underlying stream multiple times.",
	"Method": "InputStream getInputStream(){\r\n    if (this.read && this.representation.isTransient()) {\r\n        throw new IllegalStateException(\"Representation has already been read and is transient.\");\r\n    }\r\n    this.read = true;\r\n    return this.representation.getStream();\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipRequest.hasTimedOut",
	"Comment": "indicates if the transaction has timed out due to lack of activity.",
	"Method": "boolean hasTimedOut(){\r\n    return (System.currentTimeMillis() - this.lastActivity) >= getMaxIdleTimeMs();\r\n}"
}, {
	"Path": "org.restlet.resource.Directory.getRootRef",
	"Comment": "returns the root uri from which the relative resource uris will be lookedup.",
	"Method": "Reference getRootRef(){\r\n    return this.rootRef;\r\n}"
}, {
	"Path": "org.restlet.engine.util.FormReader.readParameter",
	"Comment": "reads the parameters with the given name. if multiple values are found, alist is returned created.",
	"Method": "Object readParameter(String name){\r\n    Object result = null;\r\n    if (this.stream != null) {\r\n        Parameter param = readNextParameter();\r\n        while (param != null) {\r\n            if (param.getName().equals(name)) {\r\n                if (result != null) {\r\n                    List<Object> values = null;\r\n                    if (result instanceof List) {\r\n                        values = (List<Object>) result;\r\n                    } else {\r\n                        values = new ArrayList<Object>();\r\n                        values.add(result);\r\n                        result = values;\r\n                    }\r\n                    if (param.getValue() == null) {\r\n                        values.add(Series.EMPTY_VALUE);\r\n                    } else {\r\n                        values.add(param.getValue());\r\n                    }\r\n                } else {\r\n                    if (param.getValue() == null) {\r\n                        result = Series.EMPTY_VALUE;\r\n                    } else {\r\n                        result = param.getValue();\r\n                    }\r\n                }\r\n            }\r\n            param = readNextParameter();\r\n        }\r\n        this.stream.close();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.UnusedParameterCheck.isLocal",
	"Comment": "checks if a given method is local, i.e. either static or private.",
	"Method": "boolean isLocal(DetailAST aAST){\r\n    if (aAST.getType() == TokenTypes.METHOD_DEF) {\r\n        final DetailAST modifiers = aAST.findFirstToken(TokenTypes.MODIFIERS);\r\n        return (modifiers == null) || modifiers.branchContains(TokenTypes.LITERAL_STATIC) || modifiers.branchContains(TokenTypes.LITERAL_PRIVATE);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.restlet.example.ext.jaxrs.employees.EmployeeMgr.getSmall",
	"Comment": "returns a little amount of information about the employee with the givenstaff number.",
	"Method": "SmallEmployee getSmall(int staffNo){\r\n    final Employee employee = getFull(staffNo);\r\n    return createSmall(employee);\r\n}"
}, {
	"Path": "org.restlet.ext.javamail.JavaMailClientHelper.getRepresentationMessageClass",
	"Comment": "returns the full name of the class used for generating javamail messageinstances from an xml representation and a javamail session.",
	"Method": "String getRepresentationMessageClass(){\r\n    return getHelpedParameters().getFirstValue(\"representationMessageClass\");\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.ResourcesInfo.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    final AttributesImpl attributes = new AttributesImpl();\r\n    if (getBaseRef() != null) {\r\n        attributes.addAttribute(\"\", \"base\", null, \"xs:anyURI\", getBaseRef().toString());\r\n    }\r\n    if (getDocumentations().isEmpty() && getResources().isEmpty()) {\r\n        writer.emptyElement(APP_NAMESPACE, \"resources\", null, attributes);\r\n    } else {\r\n        writer.startElement(APP_NAMESPACE, \"resources\", null, attributes);\r\n        for (final DocumentationInfo documentationInfo : getDocumentations()) {\r\n            documentationInfo.writeElement(writer);\r\n        }\r\n        for (final ResourceInfo resourceInfo : getResources()) {\r\n            resourceInfo.writeElement(writer);\r\n        }\r\n        writer.endElement(APP_NAMESPACE, \"resources\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlWriter.init",
	"Comment": "internal initialization method.all of the public constructors invoke this method.",
	"Method": "void init(Writer writer){\r\n    setOutput(writer);\r\n    this.nsSupport = new NamespaceSupport();\r\n    this.prefixTable = new ConcurrentHashMap<String, String>();\r\n    this.forcedDeclTable = new ConcurrentHashMap<String, Boolean>();\r\n    this.doneDeclTable = new ConcurrentHashMap<String, String>();\r\n}"
}, {
	"Path": "org.restlet.ext.httpclient.HttpClientHelper.getIdleCheckInterval",
	"Comment": "time in milliseconds between two checks for idle and expired connections.the check happens only if this property is set to a value greater than 0.",
	"Method": "long getIdleCheckInterval(){\r\n    return Long.parseLong(getHelpedParameters().getFirstValue(\"idleCheckInterval\", \"0\"));\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.internal.xml.ContentReader.checkRdfQName",
	"Comment": "returns true if the given qualified name is in the rdf namespace and isequal to the given local name.",
	"Method": "boolean checkRdfQName(String localName,String qName){\r\n    boolean result = qName.equals(\"rdf:\" + localName);\r\n    if (!result) {\r\n        int index = qName.indexOf(\":\");\r\n        result = rdfDefaultNamespace && (index == -1) && localName.equals(qName);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.util.WrapperList.containsAll",
	"Comment": "returns true if this list contains all of the elements of the specifiedcollection.",
	"Method": "boolean containsAll(Collection<?> elements){\r\n    return getDelegate().containsAll(elements);\r\n}"
}, {
	"Path": "org.restlet.routing.Extractor.extractFromQuery",
	"Comment": "extracts an attribute from the query string of the resource reference.",
	"Method": "void extractFromQuery(String attribute,String parameter,boolean first){\r\n    getQueryExtracts().add(new ExtractInfo(attribute, parameter, first));\r\n}"
}, {
	"Path": "org.restlet.Component.main",
	"Comment": "used as bootstrap for configuring and running a component in commandline. just provide as first and unique parameter the uri to the xml file.note that relative paths are accepted.",
	"Method": "void main(String[] args){\r\n    try {\r\n        if ((args == null) || (args.length != 1)) {\r\n            System.err.println(\"Can't launch the component. Requires the path to an XML configuration file.\\n\");\r\n        } else {\r\n            URI currentDirURI = (new File(\".\")).toURI();\r\n            URI confURI = currentDirURI.resolve(args[0]);\r\n            new Component(confURI.toString()).start();\r\n        }\r\n    } catch (Exception e) {\r\n        System.err.println(\"Can't launch the component.\\nAn unexpected exception occurred:\");\r\n        e.printStackTrace(System.err);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.freemarker.internal.ResolverHashModel.get",
	"Comment": "returns a scalar model based on the value returned by the resolveraccording to the key.",
	"Method": "TemplateModel get(String key){\r\n    Object value = this.resolver.resolve(key);\r\n    if (value == null) {\r\n        return null;\r\n    } else if (value instanceof TemplateModel) {\r\n        return (TemplateModel) value;\r\n    }\r\n    return new ScalarModel(value);\r\n}"
}, {
	"Path": "org.restlet.ext.openid.OpenIdVerifier.setUseDefaultProvider",
	"Comment": "indicates if the defaultprovider must be used in case none is provided inthe request.",
	"Method": "void setUseDefaultProvider(boolean useDefault){\r\n    this.useDefault = useDefault;\r\n}"
}, {
	"Path": "org.restlet.data.Status.checkReasonPhrase",
	"Comment": "check if the provided reason phrase of the status contains forbiddencharacters such as cr and lf. an illegalargumentexception is thrown inthis case.",
	"Method": "String checkReasonPhrase(String reasonPhrase){\r\n    if (reasonPhrase != null) {\r\n        if (reasonPhrase.contains(\"\\n\") || reasonPhrase.contains(\"\\r\")) {\r\n            throw new IllegalArgumentException(\"Reason phrase of the status must not contain CR or LF characters.\");\r\n        }\r\n    }\r\n    return reasonPhrase;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.getJavaClass",
	"Comment": "returns the java class that corresponds to the given type according tothe naming rules. it looks for the schema namespace name taken as thepackage name, then the name of this entity type is the class name.",
	"Method": "Class<?> getJavaClass(EntityType type){\r\n    Class<?> result = null;\r\n    String fullClassName = getPackageName(type.getSchema()) + \".\" + type.getClassName();\r\n    try {\r\n        result = Class.forName(fullClassName);\r\n    } catch (ClassNotFoundException e) {\r\n        Context.getCurrentLogger().warning(\"Can't find the following class in the class loader: \" + fullClassName);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.internal.xml.ScopedProperty.decrDepth",
	"Comment": "decrements the depth of the current value, and remove it if necessary.",
	"Method": "void decrDepth(){\r\n    if (this.size > 0) {\r\n        this.depths[size - 1]--;\r\n        if (this.depths[size - 1] < 0) {\r\n            this.size--;\r\n            this.values.remove(size);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Feed.getId",
	"Comment": "returns the permanent, universally unique identifier for the feed.",
	"Method": "String getId(){\r\n    return this.id;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.Metadata.getKeyValue",
	"Comment": "returns the value of the key of the given entity that should be used inall uris.",
	"Method": "String getKeyValue(EntityType type,Object entity,String getKeyValue,Object entity){\r\n    String result = null;\r\n    if (entity != null) {\r\n        result = getKeyValue(getEntityType(entity.getClass()), entity);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.resource.ServerResource.setExisting",
	"Comment": "indicates if the identified resource exists. the default value is true.",
	"Method": "void setExisting(boolean exists){\r\n    this.existing = exists;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.Transformer.transform",
	"Comment": "transforms a source xml representation by applying an xslt transformsheet to it.",
	"Method": "Representation transform(Representation source){\r\n    final Representation result = new TransformRepresentation(getContext(), source, getTransformSheet());\r\n    if (this.resultLanguages != null) {\r\n        result.getLanguages().addAll(getResultLanguages());\r\n    }\r\n    result.setCharacterSet(getResultCharacterSet());\r\n    if (this.resultEncodings != null) {\r\n        result.getEncodings().addAll(getResultEncodings());\r\n    }\r\n    result.setMediaType(getResultMediaType());\r\n    return result;\r\n}"
}, {
	"Path": "com.restfb.FacebookClientTest.oauthExceptionWithoutErrorCode",
	"Comment": "do we correctly handle the case where fb returns an oauthexception without an error code?",
	"Method": "void oauthExceptionWithoutErrorCode(){\r\n    FacebookClient facebookClient = facebookClientWithResponse(new Response(403, \"{\\\"error\\\":{\\\"message\\\":\\\"(#210) User not visible\\\",\\\"type\\\":\\\"OAuthException\\\"}}\"));\r\n    try {\r\n        facebookClient.fetchObject(\"me\", User.class);\r\n        failBecauseExceptionWasNotThrown(FacebookOAuthException.class);\r\n    } catch (FacebookOAuthException e) {\r\n        assertThat(e.getErrorMessage()).isEqualTo(\"(#210) User not visible\");\r\n        assertThat(e.getErrorType()).isEqualTo(\"OAuthException\");\r\n        assertThat(e.getErrorCode()).isNull();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.Context.setAttributes",
	"Comment": "sets the modifiable map of attributes. this method clears the current mapand puts all entries in the parameter map.",
	"Method": "void setAttributes(Map<String, Object> attributes){\r\n    synchronized (getAttributes()) {\r\n        if (attributes != getAttributes()) {\r\n            getAttributes().clear();\r\n            if (attributes != null) {\r\n                getAttributes().putAll(attributes);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.restfb.types.webhook.messaging.MessagingPayload.isLike",
	"Comment": "the user may send a like and this method can be used to discover the three know versions of the sticker",
	"Method": "boolean isLike(){\r\n    return \"369239263222822\".equals(stickerId) || \"369239343222814\".equals(stickerId) || \"369239383222810\".equals(stickerId);\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Source.setId",
	"Comment": "sets the permanent, universally unique identifier for the entry.",
	"Method": "void setId(String id){\r\n    this.id = id;\r\n}"
}, {
	"Path": "org.restlet.data.Protocol.valueOf",
	"Comment": "creates the protocol associated to a uri scheme name. if an existingconstant exists then it is returned, otherwise a new instance is created.",
	"Method": "Protocol valueOf(String name,Protocol valueOf,String name,String version){\r\n    Protocol result = valueOf(name);\r\n    if (!version.equals(result.getVersion())) {\r\n        result = new Protocol(result.getSchemeName(), result.getName(), result.getTechnicalName(), result.getDescription(), result.getDefaultPort(), result.isConfidential(), version);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.provider.JaxbProvider.isExpandingEntityRefs",
	"Comment": "indicates if the parser will expand entity reference nodes. by defaultthe value of this is set to true.",
	"Method": "boolean isExpandingEntityRefs(){\r\n    return expandingEntityRefs;\r\n}"
}, {
	"Path": "org.restlet.engine.header.PreferenceWriter.appendQuality",
	"Comment": "formats a quality value.if the quality is invalid, an illegalargumentexception is thrown.",
	"Method": "PreferenceWriter appendQuality(float quality){\r\n    if (!isValidQuality(quality)) {\r\n        throw new IllegalArgumentException(\"Invalid quality value detected. Value must be between 0 and 1.\");\r\n    }\r\n    java.text.NumberFormat formatter = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);\r\n    formatter.setMaximumFractionDigits(2);\r\n    append(formatter.format(quality));\r\n    return this;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.FunctionImport.getEntitySet",
	"Comment": "returns the entity set returned by this function, if applicable.",
	"Method": "EntitySet getEntitySet(){\r\n    return entitySet;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.FeedReader.startLink",
	"Comment": "called when a new link has been detected in the atom document.",
	"Method": "void startLink(Link link){\r\n    if (this.feedReader != null) {\r\n        this.feedReader.startLink(link);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.io.NbChannelInputStream.readChannel",
	"Comment": "reads the available bytes from the channel into the byte buffer.",
	"Method": "int readChannel(){\r\n    int result = 0;\r\n    this.byteBuffer.clear();\r\n    result = this.channel.read(this.byteBuffer);\r\n    if (result > 0) {\r\n        if (Context.getCurrentLogger().isLoggable(Level.FINE)) {\r\n            Context.getCurrentLogger().log(Level.FINE, \"NbChannelInputStream#readChannel : \" + result + \" bytes read\");\r\n        }\r\n        this.byteBuffer.flip();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.classfile.JavaClassDefinition.findNarrowestMethod",
	"Comment": "finds the narrowest method that is compatible with a method.an invocation of the given method can be resolved as an invocationof the narrowest method.",
	"Method": "MethodDefinition findNarrowestMethod(String aClassName,String aMethodName,Type[] aArgTypes){\r\n    MethodDefinition result = null;\r\n    final String javaClassName = mJavaClass.getClassName();\r\n    if (Repository.instanceOf(aClassName, javaClassName)) {\r\n        for (int i = 0; i < mMethodDefs.length; i++) {\r\n            if (mMethodDefs[i].isCompatible(aMethodName, aArgTypes)) {\r\n                if (result == null) {\r\n                    result = mMethodDefs[i];\r\n                } else if (result.isCompatible(mMethodDefs[i])) {\r\n                    result = mMethodDefs[i];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.resource.VariantInfo.getInputScore",
	"Comment": "returns the affinity between this variant and an incoming representation.",
	"Method": "float getInputScore(){\r\n    return inputScore;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.provider.JaxbProvider.setXIncludeAware",
	"Comment": "indicates the desire for processing xinclude if found in thistype of xml representations. by default the value of this is set tofalse.",
	"Method": "void setXIncludeAware(boolean includeAware){\r\n    xIncludeAware = includeAware;\r\n}"
}, {
	"Path": "org.restlet.example.ext.rdf.foaf.resources.UserResource.storeUser",
	"Comment": "update the underlying user according to the given representation.",
	"Method": "void storeUser(Representation entity){\r\n    Form form = new Form(entity);\r\n    this.user.setFirstName(form.getFirstValue(\"firstName\"));\r\n    this.user.setLastName(form.getFirstValue(\"lastName\"));\r\n    this.user.setImage(form.getFirstValue(\"image\"));\r\n    getObjectsFacade().updateUser(this.user);\r\n    getResponse().redirectSeeOther(getRequest().getResourceRef());\r\n}"
}, {
	"Path": "org.restlet.ext.nio.ConnectionHelper.isPooledConnection",
	"Comment": "indicates if the connection objects should be pooled to saveinstantiation time.",
	"Method": "boolean isPooledConnection(){\r\n    return Boolean.parseBoolean(getHelpedParameters().getFirstValue(\"pooledConnections\", \"true\"));\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getQuery",
	"Comment": "returns the optional query component for hierarchical identifiers.note that no uri decoding is done by this method.",
	"Method": "String getQuery(String getQuery,boolean decode){\r\n    return decode ? decode(getQuery()) : getQuery();\r\n}"
}, {
	"Path": "org.restlet.test.ext.jaxrs.services.tests.JaxRsTestCase.getWithHeaders",
	"Comment": "sends a request to the given sub path of the first root resource classwith the given headers.",
	"Method": "Response getWithHeaders(String subPath,Collection<Header> headers){\r\n    return accessServer(Method.GET, createReference(getRootResourceClassFromAppConf(), subPath), null, null, null, null, null, headers);\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.internal.JettyServerCall.isConfidential",
	"Comment": "indicates if the request was made using a confidential mean.",
	"Method": "boolean isConfidential(){\r\n    return getChannel().getRequest().isSecure();\r\n}"
}, {
	"Path": "org.restlet.ext.openid.OpenIdVerifier.addOptionalAttribute",
	"Comment": "adds required user attribute to retrieve during authentication.",
	"Method": "void addOptionalAttribute(AttributeExchange attributeName){\r\n    this.optionalAttributes.add(attributeName);\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.AssociationSetEnd.getRole",
	"Comment": "returns the role of this entity relatively to this association.",
	"Method": "String getRole(){\r\n    return role;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.DigestVerifier.setWrappedAlgorithm",
	"Comment": "sets the digest algorithm of secrets returned by the wrapped verifier.the secrets from the wrapped verifier are the ones used by the verifierto compare those sent by clients when attempting to authenticate.",
	"Method": "void setWrappedAlgorithm(String wrappedAlgorithm){\r\n    this.wrappedAlgorithm = wrappedAlgorithm;\r\n}"
}, {
	"Path": "org.restlet.routing.Router.redirectPermanent",
	"Comment": "attaches a permanent redirection to this router based on a given uripattern. the client is expected to reuse the same method for the newrequest.",
	"Method": "TemplateRoute redirectPermanent(String pathTemplate,String targetUri){\r\n    return attach(pathTemplate, new Redirector(getContext(), targetUri, Redirector.MODE_CLIENT_PERMANENT));\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsRestlet.getObjectFactory",
	"Comment": "returns the objectfactory for root resource class and providerinstantiation, if given.",
	"Method": "ObjectFactory getObjectFactory(){\r\n    return this.objectFactory;\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.DefaultSslContextFactory.isWantClientAuthentication",
	"Comment": "indicates if we would like client certificate authentication.",
	"Method": "boolean isWantClientAuthentication(){\r\n    return wantClientAuthentication;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.WadlApplication.attachResource",
	"Comment": "attaches a resource, as specified in a wadl document, to a specifiedrouter, then recursively attaches its child resources.",
	"Method": "void attachResource(ResourceInfo currentResource,ResourceInfo parentResource,Router router){\r\n    String uriPattern = currentResource.getPath();\r\n    if (parentResource != null) {\r\n        String parentUriPattern = parentResource.getPath();\r\n        if ((parentUriPattern.endsWith(\"/\") == false) && (uriPattern.startsWith(\"/\") == false)) {\r\n            parentUriPattern += \"/\";\r\n        }\r\n        uriPattern = parentUriPattern + uriPattern;\r\n        currentResource.setPath(uriPattern);\r\n    } else if (!uriPattern.startsWith(\"/\")) {\r\n        uriPattern = \"/\" + uriPattern;\r\n        currentResource.setPath(uriPattern);\r\n    }\r\n    Finder finder = createFinder(router, uriPattern, currentResource);\r\n    if (finder != null) {\r\n        router.attach(uriPattern, finder);\r\n    }\r\n    for (ResourceInfo childResource : currentResource.getChildResources()) {\r\n        attachResource(childResource, currentResource, router);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.test.ext.jaxrs.util.TestUtils.sleep",
	"Comment": "sleeps 100 seconds. will not throw an interruptedexception",
	"Method": "void sleep(){\r\n    try {\r\n        Thread.sleep(100);\r\n    } catch (InterruptedException e) {\r\n    }\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.UnknownClass.getMethodDefinition",
	"Comment": "gets the method associated with the given name and signature",
	"Method": "IMethod getMethodDefinition(String name,ISignature signature){\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Feed.getEntries",
	"Comment": "returns the individual entries, acting as a components for associatedmetadata and data.",
	"Method": "List<Entry> getEntries(){\r\n    List<Entry> e = this.entries;\r\n    if (e == null) {\r\n        synchronized (this) {\r\n            e = this.entries;\r\n            if (e == null) {\r\n                this.entries = e = new ArrayList<Entry>();\r\n            }\r\n        }\r\n    }\r\n    return e;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.ODataType.getImportedTypes",
	"Comment": "returns the set of imported entity types. by default, returns an emptyset.",
	"Method": "Set<ODataType> getImportedTypes(){\r\n    return new TreeSet<ODataType>();\r\n}"
}, {
	"Path": "org.restlet.ext.nio.BaseHelper.getControllerSleepTimeMs",
	"Comment": "returns the time for the controller thread to sleep between each control.",
	"Method": "int getControllerSleepTimeMs(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"controllerSleepTimeMs\", \"60000\"));\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.JavaClassWalker.walk",
	"Comment": "traverses a javaclass parse tree and accepts all registeredvisitors.",
	"Method": "void walk(JavaClass aJavaClass){\r\n    DescendingVisitor visitor = new DescendingVisitor(aJavaClass, mVisitor);\r\n    aJavaClass.accept(visitor);\r\n}"
}, {
	"Path": "org.restlet.data.Reference.setHostDomain",
	"Comment": "sets the host domain component for server based hierarchical identifiers.",
	"Method": "void setHostDomain(String domain){\r\n    final String authority = getAuthority();\r\n    if (authority == null) {\r\n        setAuthority(domain);\r\n    } else {\r\n        if (domain == null) {\r\n            domain = \"\";\r\n        } else {\r\n            domain = domain.toLowerCase();\r\n        }\r\n        int indexUI = authority.indexOf('@');\r\n        int indexIPV6 = authority.indexOf(']');\r\n        int indexP = authority.indexOf(':', (indexIPV6 == -1) ? indexUI : indexIPV6);\r\n        if (indexUI != -1) {\r\n            if (indexP != -1) {\r\n                setAuthority(authority.substring(0, indexUI + 1) + domain + authority.substring(indexP));\r\n            } else {\r\n                setAuthority(authority.substring(0, indexUI + 1) + domain);\r\n            }\r\n        } else {\r\n            if (indexP != -1) {\r\n                setAuthority(domain + authority.substring(indexP));\r\n            } else {\r\n                setAuthority(domain);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.routing.Template.getMatchingMode",
	"Comment": "returns the matching mode to use when parsing a formatted reference.",
	"Method": "int getMatchingMode(){\r\n    return this.matchingMode;\r\n}"
}, {
	"Path": "org.restlet.test.ext.jaxrs.server.RestletServerTestCase.runServerAfterStart",
	"Comment": "this methods shows information about the started server after startingit.you may override this method to do what ever you want",
	"Method": "void runServerAfterStart(){\r\n    System.out.print(\"server is accessable via http://localhost:\");\r\n    System.out.println(getServerPort());\r\n}"
}, {
	"Path": "org.restlet.ext.httpclient.internal.HttpMethodCall.getServerAddress",
	"Comment": "returns the response address.corresponds to the ip address of the responding server.",
	"Method": "String getServerAddress(){\r\n    return getHttpRequest().getURI().getHost();\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsRestlet.setNoRootResClHandler",
	"Comment": "sets the restlet that is called, if no root resource class could befound. you could remove a given restlet by set null here.if no restlet is given here, status 404 will be returned.",
	"Method": "void setNoRootResClHandler(Restlet noRootResClHandler){\r\n    excHandler.setNoRootResClHandler(noRootResClHandler);\r\n}"
}, {
	"Path": "org.restlet.engine.header.HeaderReader.mark",
	"Comment": "marks the current position in this reader. a subsequent call to thereset method repositions this reader at the last markedposition.",
	"Method": "void mark(){\r\n    mark = index;\r\n}"
}, {
	"Path": "org.restlet.service.EncoderService.setMinimumSize",
	"Comment": "sets the minimum size a representation must have before compression isdone.",
	"Method": "void setMinimumSize(long mininumSize){\r\n    this.mininumSize = mininumSize;\r\n}"
}, {
	"Path": "org.restlet.service.TaskService.isTerminated",
	"Comment": "returns true if all tasks have completed following shut down. note thatisterminated is never true unless either shutdown or shutdownnow wascalled first.",
	"Method": "boolean isTerminated(){\r\n    return (getWrapped() == null) || getWrapped().isTerminated();\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.EntryContentHandler.popState",
	"Comment": "returns the state at the top of the heap and removes it from the heap.",
	"Method": "State popState(){\r\n    State result = null;\r\n    int size = this.states.size();\r\n    if (size > 0) {\r\n        result = this.states.remove(size - 1);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jackson.JacksonConverter.isCompatible",
	"Comment": "indicates if the given variant is compatible with the media typessupported by this converter.",
	"Method": "boolean isCompatible(Variant variant){\r\n    return (variant != null) && (VARIANT_JSON.isCompatible(variant) || VARIANT_JSON_SMILE.isCompatible(variant) || VARIANT_APPLICATION_XML.isCompatible(variant) || VARIANT_TEXT_XML.isCompatible(variant) || VARIANT_APPLICATION_YAML.isCompatible(variant) || VARIANT_TEXT_YAML.isCompatible(variant) || VARIANT_TEXT_CSV.isCompatible(variant));\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipResponse.getMimeVersion",
	"Comment": "returns the version of the mime protocol used to construct the message.",
	"Method": "String getMimeVersion(){\r\n    return mimeVersion;\r\n}"
}, {
	"Path": "org.restlet.data.Method.getUri",
	"Comment": "returns the uri of the specification describing the method.",
	"Method": "String getUri(){\r\n    return this.uri;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.introspection.application.ApplicationIntrospector.getDefinition",
	"Comment": "returns a apispark description of the current application. by default,this method discovers all the resources attached to this application. itcan be overridden to add documentation, list of representations, etc.",
	"Method": "Definition getDefinition(Application application,Definition getDefinition,Application application,Reference baseRef,Component component,boolean useSectionNamingPackageStrategy){\r\n    List<IntrospectionHelper> introspectionHelpers = IntrospectionUtils.getIntrospectionHelpers();\r\n    if (introspectionHelpers == null) {\r\n        introspectionHelpers = new ArrayList();\r\n    }\r\n    Definition definition = new Definition();\r\n    Contract contract = new Contract();\r\n    contract.setDescription(StringUtils.nullToEmpty(application.getDescription()));\r\n    if (application.toString().equals(application.getName())) {\r\n        LOGGER.log(Level.WARNING, \"Please provide a name to your application by overriding its method getName. Used \" + application.getClass().getSimpleName() + \" by default.\");\r\n        contract.setName(application.getClass().getSimpleName());\r\n    } else {\r\n        contract.setName(application.getName());\r\n    }\r\n    CollectInfo collectInfo = new CollectInfo();\r\n    collectInfo.setUseSectionNamingPackageStrategy(useSectionNamingPackageStrategy);\r\n    if (application instanceof DocumentedApplication) {\r\n        DocumentedApplication documentedApplication = (DocumentedApplication) application;\r\n        if (documentedApplication.getSections() != null) {\r\n            collectInfo.setSections(documentedApplication.getSections());\r\n        }\r\n    }\r\n    definition.setContract(contract);\r\n    RestletCollector.collect(collectInfo, \"\", application.getInboundRoot(), null, introspectionHelpers);\r\n    contract.setResources(collectInfo.getResources());\r\n    contract.setRepresentations(collectInfo.getRepresentations());\r\n    contract.setSections(collectInfo.getSections());\r\n    addEnpoints(application, baseRef, component, definition, contract, collectInfo);\r\n    sortDefinition(definition);\r\n    updateRepresentationsSectionsFromResources(definition);\r\n    for (IntrospectionHelper helper : introspectionHelpers) {\r\n        helper.processDefinition(definition, application.getClass());\r\n    }\r\n    return definition;\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.DefaultSslContextFactory.isNeedClientAuthentication",
	"Comment": "indicates if we require client certificate authentication.",
	"Method": "boolean isNeedClientAuthentication(){\r\n    return needClientAuthentication;\r\n}"
}, {
	"Path": "org.restlet.resource.Directory.setRootRef",
	"Comment": "sets the root uri from which the relative resource uris will be lookepup.",
	"Method": "void setRootRef(Reference rootRef){\r\n    this.rootRef = rootRef;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.BaseHelper.getInboundBufferSize",
	"Comment": "returns the size of the content buffer for receiving messages.",
	"Method": "int getInboundBufferSize(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"inboundBufferSize\", Integer.toString(16 * 1024)));\r\n}"
}, {
	"Path": "org.restlet.service.TunnelService.isHeadersTunnel",
	"Comment": "indicates if the method can be tunneled via the header. returns true bydefault.",
	"Method": "boolean isHeadersTunnel(){\r\n    return headersTunnel;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.channel.ReadableChunkedChannel.setRemainingChunkSize",
	"Comment": "sets the remaining chunk size that should be read from the sourcechannel.",
	"Method": "void setRemainingChunkSize(int remainingChunkSize){\r\n    this.remainingChunkSize = remainingChunkSize;\r\n}"
}, {
	"Path": "org.restlet.engine.adapter.ServerCall.shouldResponseBeChunked",
	"Comment": "indicates if the response should be chunked because its length isunknown.",
	"Method": "boolean shouldResponseBeChunked(Response response){\r\n    return (response.getEntity() != null) && !response.getEntity().hasKnownSize();\r\n}"
}, {
	"Path": "org.restlet.data.Reference.isEquivalentTo",
	"Comment": "returns true if both reference are equivalent, meaning that they resolveto the same target reference.",
	"Method": "boolean isEquivalentTo(Reference ref){\r\n    return getTargetRef().equals(ref.getTargetRef());\r\n}"
}, {
	"Path": "org.restlet.engine.io.IoUtils.toString",
	"Comment": "converts an input stream to a string using the specified character setfor decoding the input stream. once read, the input stream is closed.",
	"Method": "String toString(InputStream inputStream,String toString,InputStream inputStream,CharacterSet characterSet,String toString,Reader reader){\r\n    String result = null;\r\n    if (reader != null) {\r\n        try {\r\n            StringBuilder sb = new StringBuilder();\r\n            BufferedReader br = (reader instanceof BufferedReader) ? (BufferedReader) reader : new BufferedReader(reader, BUFFER_SIZE);\r\n            char[] buffer = new char[2048];\r\n            int charsRead = br.read(buffer);\r\n            while (charsRead != -1) {\r\n                sb.append(buffer, 0, charsRead);\r\n                charsRead = br.read(buffer);\r\n            }\r\n            br.close();\r\n            result = sb.toString();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.cafe.CafeService.createContactQuery",
	"Comment": "creates a query for contact entities hosted by this service.",
	"Method": "Query<Contact> createContactQuery(String subpath){\r\n    return createQuery(subpath, Contact.class);\r\n}"
}, {
	"Path": "org.restlet.engine.header.RangeReader.read",
	"Comment": "parse the range header and returns the list of corresponding rangeobjects.",
	"Method": "List<Range> read(String rangeHeader){\r\n    List<Range> result = new ArrayList<Range>();\r\n    String prefix = \"bytes=\";\r\n    if (rangeHeader != null && rangeHeader.startsWith(prefix)) {\r\n        rangeHeader = rangeHeader.substring(prefix.length());\r\n        String[] array = rangeHeader.split(\",\");\r\n        for (int i = 0; i < array.length; i++) {\r\n            String value = array[i].trim();\r\n            long index = 0;\r\n            long length = 0;\r\n            if (value.startsWith(\"-\")) {\r\n                index = Range.INDEX_LAST;\r\n                length = Long.parseLong(value.substring(1));\r\n            } else if (value.endsWith(\"-\")) {\r\n                index = Long.parseLong(value.substring(0, value.length() - 1));\r\n                length = Range.SIZE_MAX;\r\n            } else {\r\n                String[] tab = value.split(\"-\");\r\n                if (tab.length == 2) {\r\n                    index = Long.parseLong(tab[0]);\r\n                    length = Long.parseLong(tab[1]) - index + 1;\r\n                }\r\n            }\r\n            result.add(new Range(index, length));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.internal.Activator.start",
	"Comment": "starts the osgi bundle by registering the engine with the bundle of therestlet api.",
	"Method": "void start(BundleContext context){\r\n    org.restlet.engine.Engine.register(false);\r\n    for (final Bundle bundle : context.getBundles()) {\r\n        registerHelpers(bundle);\r\n    }\r\n    context.addBundleListener(new BundleListener() {\r\n        public void bundleChanged(BundleEvent event) {\r\n            switch(event.getType()) {\r\n                case BundleEvent.INSTALLED:\r\n                    registerHelpers(event.getBundle());\r\n                    break;\r\n                case BundleEvent.UNINSTALLED:\r\n                    break;\r\n            }\r\n        }\r\n    });\r\n    Engine.getInstance().registerDefaultConnectors();\r\n    Engine.getInstance().registerDefaultAuthentications();\r\n    Engine.getInstance().registerDefaultConverters();\r\n}"
}, {
	"Path": "org.restlet.engine.internal.Activator.start",
	"Comment": "starts the osgi bundle by registering the engine with the bundle of therestlet api.",
	"Method": "void start(BundleContext context){\r\n    switch(event.getType()) {\r\n        case BundleEvent.INSTALLED:\r\n            registerHelpers(event.getBundle());\r\n            break;\r\n        case BundleEvent.UNINSTALLED:\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.restlet.util.WrapperRequest.getChallengeResponse",
	"Comment": "returns the authentication response sent by a client to an origin server.",
	"Method": "ChallengeResponse getChallengeResponse(){\r\n    return getWrappedRequest().getChallengeResponse();\r\n}"
}, {
	"Path": "org.restlet.ext.servlet.internal.ServletCall.isConfidential",
	"Comment": "indicates if the request was made using a confidential mean.",
	"Method": "boolean isConfidential(){\r\n    return getRequest().isSecure();\r\n}"
}, {
	"Path": "org.restlet.ext.spring.SpringComponent.setClientsList",
	"Comment": "sets the list of clients, either as protocol names, protocol instances orclient instances.",
	"Method": "void setClientsList(List<Object> clients){\r\n    for (final Object client : clients) {\r\n        if (client instanceof String) {\r\n            getClients().add(Protocol.valueOf((String) client));\r\n        } else if (client instanceof Protocol) {\r\n            getClients().add((Protocol) client);\r\n        } else if (client instanceof Client) {\r\n            getClients().add((Client) client);\r\n        } else {\r\n            getLogger().warning(\"Unknown object found in the clients list. Only instances of String, org.restlet.data.Protocol and org.restlet.Client are allowed.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.ExtendedUriBuilder.fromPath",
	"Comment": "create a new instance representing a relative uri initialized from a uripath.",
	"Method": "ExtendedUriBuilder fromPath(String path){\r\n    ExtendedUriBuilder b = newInstance();\r\n    b.replacePath(path);\r\n    return b;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.connection.Connection.getReadableSelectionChannel",
	"Comment": "returns the underlying socket channel as a readable selection channel.",
	"Method": "ReadableSelectionChannel getReadableSelectionChannel(){\r\n    return readableSelectionChannel;\r\n}"
}, {
	"Path": "org.restlet.test.engine.HeaderTestCase.testValues",
	"Comment": "test that the parsing of a header returns the given array of values.",
	"Method": "void testValues(String header,String[] values){\r\n    HeaderReader<Object> hr = new HeaderReader<Object>(header);\r\n    String value = hr.readRawValue();\r\n    int index = 0;\r\n    while (value != null) {\r\n        assertEquals(value, values[index]);\r\n        index++;\r\n        value = hr.readRawValue();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.service.ConnegService.setStrict",
	"Comment": "indicates if the conneg algorithm should strictly respect clientpreferences or be more flexible.",
	"Method": "void setStrict(boolean strict){\r\n    this.strict = strict;\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.setEntityBuffering",
	"Comment": "indicates if transient entities should be buffered after being receivedor before being sent.",
	"Method": "void setEntityBuffering(boolean entityBuffering){\r\n    setRequestEntityBuffering(entityBuffering);\r\n    setResponseEntityBuffering(entityBuffering);\r\n}"
}, {
	"Path": "org.restlet.ext.spring.SpringBeanRouter.isAvailableUri",
	"Comment": "indicates if the attachments contain a mapping for the given uri.",
	"Method": "boolean isAvailableUri(String name){\r\n    return name.startsWith(\"/\") && (getAttachments() == null || !getAttachments().containsKey(name));\r\n}"
}, {
	"Path": "org.restlet.service.ConverterService.createPatch",
	"Comment": "creates a patch representation by calculating a diff between initial andmodified representations.",
	"Method": "Representation createPatch(Representation initial,Representation modified){\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.service.TunnelService.setMediaTypeParameter",
	"Comment": "sets the name of the parameter containing the accepted media type.",
	"Method": "void setMediaTypeParameter(String parameterName){\r\n    this.mediaTypeParameter = parameterName;\r\n}"
}, {
	"Path": "org.restlet.util.WrapperRequest.setChallengeResponse",
	"Comment": "sets the authentication response sent by a client to an origin server.",
	"Method": "void setChallengeResponse(ChallengeResponse response){\r\n    getWrappedRequest().setChallengeResponse(response);\r\n}"
}, {
	"Path": "org.restlet.ext.raml.RamlSpecificationRestlet.setRamlVersion",
	"Comment": "sets the version of raml used to generate this documentation.",
	"Method": "void setRamlVersion(String ramlVersion){\r\n    this.ramlVersion = ramlVersion;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Service.getSubpath",
	"Comment": "according to the metadata of the service, returns the relative path ofthe given target entity linked to the source entity via the sourceproperty.",
	"Method": "String getSubpath(Object entity,String getSubpath,Object entity,String propertyName,String getSubpath,Object source,String sourceProperty,Object target){\r\n    return ((Metadata) getMetadata()).getSubpath(source, sourceProperty, target);\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.TableMaker.makeClass",
	"Comment": "creates classdef for the current class node and add it to thesymbol table",
	"Method": "void makeClass(String name,SymTabAST tree){\r\n    ClassDef def = new ClassDef(name, symbolTable.getCurrentScope(), tree);\r\n    def.addUnprocessedImports(imports);\r\n    symbolTable.defineClass(def);\r\n    symbolTable.pushScope(def);\r\n}"
}, {
	"Path": "org.restlet.engine.io.IoUtils.toByteArray",
	"Comment": "converts a char array into a byte array using the provided character set.",
	"Method": "byte[] toByteArray(char[] chars,byte[] toByteArray,char[] chars,String charsetName){\r\n    java.nio.CharBuffer cb = java.nio.CharBuffer.wrap(chars);\r\n    java.nio.ByteBuffer bb = java.nio.charset.Charset.forName(charsetName).encode(cb);\r\n    byte[] r = new byte[bb.remaining()];\r\n    bb.get(r);\r\n    return r;\r\n}"
}, {
	"Path": "org.restlet.engine.header.HeaderReader.createParameter",
	"Comment": "creates a new parameter with a null value. can be overridden.",
	"Method": "Parameter createParameter(String name,Parameter createParameter,String name,String value){\r\n    return new Parameter(name, value);\r\n}"
}, {
	"Path": "org.restlet.engine.header.HeaderWriter.appendExtension",
	"Comment": "appends an extension. if the value is not a token, then it is quoted.",
	"Method": "HeaderWriter<V> appendExtension(NamedValue<String> extension,HeaderWriter<V> appendExtension,String name,String value){\r\n    if ((name != null) && (name.length() > 0)) {\r\n        append(name);\r\n        if ((value != null) && (value.length() > 0)) {\r\n            append(\"=\");\r\n            if (HeaderUtils.isToken(value)) {\r\n                append(value);\r\n            } else {\r\n                appendQuotedString(value);\r\n            }\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.restlet.ext.sdc.internal.SdcServerConnection.setKey",
	"Comment": "sets the authorization key composed of the email address and the passwordseparated by a colon character.",
	"Method": "void setKey(String key){\r\n    this.key = key;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.MetadataReader.popState",
	"Comment": "drops the current state from the stack and returns it. this state becomesthe former current state.",
	"Method": "State popState(){\r\n    return this.states.remove(0);\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.AbstractUriBuilder.port",
	"Comment": "set the uri port. only integers or a variable template is allowed",
	"Method": "UriBuilder port(int port,UriBuilder port,String port){\r\n    if (port == null) {\r\n        this.port = null;\r\n    } else if (port.startsWith(\"{\") && port.endsWith(\"}\")) {\r\n        this.port = port;\r\n    } else {\r\n        this.port(Integer.parseInt(port));\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.restlet.engine.adapter.ServerCall.getSslSessionId",
	"Comment": "returns the ssl session id, in hexadecimal encoding, if available andaccessible.",
	"Method": "String getSslSessionId(){\r\n    byte[] byteArray = getSslSessionIdBytes();\r\n    if (byteArray != null) {\r\n        return IoUtils.toHexString(byteArray);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.restlet.service.LogService.getLoggableTemplate",
	"Comment": "returns the uri template of loggable resource references. returns null bydefault, meaning the all requests are loggable, independant of theirtarget resource uri reference.",
	"Method": "Template getLoggableTemplate(){\r\n    return loggableTemplate;\r\n}"
}, {
	"Path": "org.restlet.ext.jackson.JacksonRepresentation.getObjectMapper",
	"Comment": "returns the modifiable jackson object mapper. useful to customizemappings.",
	"Method": "ObjectMapper getObjectMapper(){\r\n    if (this.objectMapper == null) {\r\n        this.objectMapper = createObjectMapper();\r\n    }\r\n    return this.objectMapper;\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.JettyServerHelper.getLowResourceMonitorMaxConnections",
	"Comment": "low resource monitor max connections. defaults to 0. when 0, the check isdisabled.",
	"Method": "int getLowResourceMonitorMaxConnections(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"lowResource.maxConnections\", \"0\"));\r\n}"
}, {
	"Path": "org.restlet.Context.createChildContext",
	"Comment": "creates a protected child context. this is especially useful for newapplication attached to their parent component, to ensure their isolationfrom the other applications. by default it creates a new context instancewith empty or null properties, except the client and server dispatchersthat are wrapped for isolation purpose.",
	"Method": "Context createChildContext(){\r\n    return new org.restlet.engine.util.ChildContext(this);\r\n}"
}, {
	"Path": "org.restlet.Component.setHosts",
	"Comment": "sets the modifiable list of virtual hosts. note that the order of virtualhosts in this list will be used to check the first one that matches. thismethod clears the current list and adds all entries in the parameterlist.",
	"Method": "void setHosts(List<VirtualHost> hosts){\r\n    synchronized (getHosts()) {\r\n        if (hosts != getHosts()) {\r\n            getHosts().clear();\r\n            if (hosts != null) {\r\n                getHosts().addAll(hosts);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.component.ComponentXmlParser.getProtocol",
	"Comment": "returns a protocol by its scheme. if the latter is unknown, instantiate anew protocol object.",
	"Method": "Protocol getProtocol(String scheme){\r\n    Protocol protocol = Protocol.valueOf(scheme);\r\n    if (protocol == null) {\r\n        protocol = new Protocol(scheme);\r\n    }\r\n    return protocol;\r\n}"
}, {
	"Path": "org.restlet.engine.component.HostRoute.matches",
	"Comment": "matches a formatted string against a regex pattern, in a case insensitivemanner.",
	"Method": "boolean matches(String regex,String formattedString){\r\n    return Pattern.compile(regex, Pattern.CASE_INSENSITIVE).matcher(formattedString).matches();\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.Resolver.resolveNumInt",
	"Comment": "returns the classdef of the int primitive type.this mayneed to be amended, based on the java language spec, to return a longif the literal is larger than an int can hold.",
	"Method": "IClass resolveNumInt(SymTabAST expression,Scope location,IClass context){\r\n    return PrimitiveClasses.INT;\r\n}"
}, {
	"Path": "org.restlet.engine.application.StatusFilter.isOverwriting",
	"Comment": "indicates if existing representations should be overwritten.",
	"Method": "boolean isOverwriting(){\r\n    return overwriting;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.channel.TraceChannel.getTraceStream",
	"Comment": "returns the trace output stream to use if tracing is enabled.",
	"Method": "OutputStream getTraceStream(){\r\n    return this.traceStream;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Relation.toString",
	"Comment": "return a string object representing the specified relation.",
	"Method": "String toString(Relation rel,String toString){\r\n    return name;\r\n}"
}, {
	"Path": "org.restlet.Message.getEntityAsText",
	"Comment": "returns the entity as text. this method can be called several times andwill always return the same text. note that if the entity is large thismethod can result in important memory consumption.",
	"Method": "String getEntityAsText(){\r\n    if (this.entityText == null) {\r\n        try {\r\n            this.entityText = (getEntity() == null) ? null : getEntity().getText();\r\n        } catch (java.io.IOException e) {\r\n            Context.getCurrentLogger().log(java.util.logging.Level.FINE, \"Unable to get the entity text.\", e);\r\n        }\r\n    }\r\n    return this.entityText;\r\n}"
}, {
	"Path": "org.restlet.ext.spring.SpringContext.getXmlConfigRefs",
	"Comment": "returns the modifiable list of configuration uris for beans definitionsvia xml representations.",
	"Method": "List<String> getXmlConfigRefs(){\r\n    List<String> x = this.xmlConfigRefs;\r\n    if (x == null) {\r\n        synchronized (this) {\r\n            x = this.xmlConfigRefs;\r\n            if (x == null) {\r\n                this.xmlConfigRefs = x = new ArrayList<String>();\r\n            }\r\n        }\r\n    }\r\n    return x;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlRepresentation.getTextContent",
	"Comment": "returns the text content of a given node and its descendants.",
	"Method": "String getTextContent(Node node){\r\n    StringBuilder sb = new StringBuilder();\r\n    appendTextContent(node, sb);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.AssociationEnd.isToMany",
	"Comment": "returns true if the cardinality says that this is a one to many or manyto many relation.",
	"Method": "boolean isToMany(){\r\n    return \"*\".equals(getMultiplicity());\r\n}"
}, {
	"Path": "org.restlet.ext.oauth.OAuthException.getErrorUri",
	"Comment": "returns the uri of the resource that gives more details about the error.",
	"Method": "String getErrorUri(){\r\n    return errorUri;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlRepresentation.isValidatingDtd",
	"Comment": "indicates the desire for validating this type of xml representationsagainst an xml schema if one is referenced within the contents.",
	"Method": "boolean isValidatingDtd(){\r\n    return validatingDtd;\r\n}"
}, {
	"Path": "org.restlet.data.ClientInfo.getPreferredLanguage",
	"Comment": "returns the preferred language among a list of supported ones, based onthe client preferences.",
	"Method": "Language getPreferredLanguage(List<Language> supported){\r\n    return getPreferredMetadata(supported, getAcceptedLanguages());\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.LinkInfo.getResourceType",
	"Comment": "returns the reference to the resource type of the linked resource.",
	"Method": "Reference getResourceType(){\r\n    return this.resourceType;\r\n}"
}, {
	"Path": "org.restlet.ext.oauth.OAuthProxy.createTokenRequest",
	"Comment": "returns the set of oauth parameters used to generate the uri of the token request.",
	"Method": "OAuthParameters createTokenRequest(String code){\r\n    OAuthParameters parameters = new OAuthParameters().grantType(GrantType.authorization_code).code(code);\r\n    if (redirectURI != null) {\r\n        parameters.redirectURI(redirectURI);\r\n    }\r\n    return parameters;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.checks.AbstractReferenceCheck.setIgnoreClassName",
	"Comment": "set the ignore class name to the specified regular expression.",
	"Method": "void setIgnoreClassName(String aFormat){\r\n    try {\r\n        mIgnoreClassNameRegexp = Utils.getPattern(aFormat);\r\n    } catch (PatternSyntaxException e) {\r\n        throw new ConversionException(\"unable to parse \" + aFormat, e);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.swagger.v2_0.Swagger2Writer.newPropertyForType",
	"Comment": "get new property for swagger 2.0 for the primitive type of rwadef.",
	"Method": "com.wordnik.swagger.models.properties.Property newPropertyForType(String type){\r\n    switch(type.toLowerCase()) {\r\n        case \"string\":\r\n            return new StringProperty();\r\n        case \"byte\":\r\n            return new ByteProperty();\r\n        case \"short\":\r\n            return new ShortProperty();\r\n        case \"integer\":\r\n            return new IntegerProperty();\r\n        case \"long\":\r\n            return new LongProperty();\r\n        case \"float\":\r\n            return new FloatProperty();\r\n        case \"double\":\r\n            return new DoubleProperty();\r\n        case \"date\":\r\n            return new DateProperty();\r\n        case \"boolean\":\r\n            return new BooleanProperty();\r\n    }\r\n    return new RefProperty().asDefault(type);\r\n}"
}, {
	"Path": "org.restlet.ext.spring.SpringResource.hashCode",
	"Comment": "this implementation returns the hash code of the underlying inputstream.",
	"Method": "int hashCode(){\r\n    return SystemUtils.hashCode(this.representation);\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.MethodDef.hasCompatibleSignature",
	"Comment": "whether this method has a signature compatible with the given signature.",
	"Method": "boolean hasCompatibleSignature(ISignature signature){\r\n    return signature.isCompatibleWith(getSignature());\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipRequest.getRequires",
	"Comment": "returns the sensitive features that the server must support.",
	"Method": "List<OptionTag> getRequires(){\r\n    List<OptionTag> r = this.requires;\r\n    if (r == null) {\r\n        synchronized (this) {\r\n            r = this.requires;\r\n            if (r == null) {\r\n                this.requires = r = new CopyOnWriteArrayList<OptionTag>();\r\n            }\r\n        }\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxb.JaxbRepresentation.setNamespacePrefixMapper",
	"Comment": "sets the optional namespace prefix mapper for marshalling.",
	"Method": "void setNamespacePrefixMapper(NamespacePrefixMapper namespacePrefixMapper){\r\n    this.namespacePrefixMapper = namespacePrefixMapper;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.ExceptionHandler.setNoRootResClHandler",
	"Comment": "sets the restlet that is called, if no root resource class could befound.",
	"Method": "void setNoRootResClHandler(Restlet noRootResClHandler){\r\n    this.noRootResClHandler = noRootResClHandler;\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getFragment",
	"Comment": "returns the fragment identifier.note that no uri decoding is done by this method.",
	"Method": "String getFragment(String getFragment,boolean decode){\r\n    return decode ? decode(getFragment()) : getFragment();\r\n}"
}, {
	"Path": "org.restlet.test.HeaderTestCase.getWithParams",
	"Comment": "handle a new request built according to the parameters and return theresponse object.",
	"Method": "Response getWithParams(Header additionalHeaders){\r\n    Request request = new Request(Method.GET, \"http://localhost:\" + TEST_PORT);\r\n    Series<Header> headers = getHttpHeaders(request);\r\n    for (Header header : additionalHeaders) {\r\n        headers.add(header);\r\n    }\r\n    Response result = client.handle(request);\r\n    return result;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.TableMaker.getTable",
	"Comment": "returns the symboltable that has been constructed bythis tablemaker",
	"Method": "SymbolTable getTable(){\r\n    if (symbolTable == null) {\r\n        symbolTable = new SymbolTable(_tree);\r\n        createDefinitions();\r\n        resolveReferences();\r\n    }\r\n    return symbolTable;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Feed.setUpdated",
	"Comment": "sets the most recent moment when the feed was modified in a significantway.",
	"Method": "void setUpdated(Date updated){\r\n    this.updated = DateUtils.unmodifiable(updated);\r\n}"
}, {
	"Path": "org.restlet.ext.spring.SpringBeanRouter.setAttachments",
	"Comment": "sets an explicit mapping of uri templates to bean ids to use in additionto the usual bean name mapping behavior. if a uri template appears inboth this mapping and as a bean name, the bean it is mapped to here isthe one that will be used.",
	"Method": "void setAttachments(Map<String, String> attachments){\r\n    this.attachments = attachments;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.DigestVerifier.getWrappedAlgorithm",
	"Comment": "returns the digest algorithm of secrets returned by the wrapped verifier.the secrets from the wrapped verifier are the ones used by the verifierto compare those sent by clients when attempting to authenticate.",
	"Method": "String getWrappedAlgorithm(){\r\n    return wrappedAlgorithm;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.channel.ReadableSizedSelectionChannel.setAvailableSize",
	"Comment": "sets the remaining size that should be read from the source channel.",
	"Method": "void setAvailableSize(long availableSize){\r\n    this.availableSize = availableSize;\r\n    setEndReached(this.availableSize == 0);\r\n}"
}, {
	"Path": "org.restlet.engine.local.ZipClientHelper.writeEntityStream",
	"Comment": "writes an entity to a given zip output stream with a given zip entryname.",
	"Method": "boolean writeEntityStream(Representation entity,ZipOutputStream out,String entryName){\r\n    if (entity != null && !entryName.endsWith(\"/\")) {\r\n        ZipEntry entry = new ZipEntry(entryName);\r\n        if (entity.getModificationDate() != null)\r\n            entry.setTime(entity.getModificationDate().getTime());\r\n        else {\r\n            entry.setTime(System.currentTimeMillis());\r\n        }\r\n        out.putNextEntry(entry);\r\n        IoUtils.copy(new BufferedInputStream(entity.getStream()), out);\r\n        out.closeEntry();\r\n        return true;\r\n    }\r\n    out.putNextEntry(new ZipEntry(entryName));\r\n    out.closeEntry();\r\n    return false;\r\n}"
}, {
	"Path": "org.restlet.ext.osgi.BaseApplicationProvider.activate",
	"Comment": "called by osgi ds to activate the service after the router provider hasbeen bound",
	"Method": "void activate(ComponentContext context){\r\n    @SuppressWarnings(\"unchecked\")\r\n    Dictionary<String, Object> properties = context.getProperties();\r\n    alias = (String) properties.get(\"alias\");\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.AbstractUriBuilder.queryParam",
	"Comment": "append a query parameter to the existing set of query parameters. ifmultiple values are supplied the parameter will be added once per value.",
	"Method": "UriBuilder queryParam(String name,Object values){\r\n    if (values == null) {\r\n        throw new IllegalArgumentException(\"The values must not be null\");\r\n    }\r\n    CharSequence ncs;\r\n    ncs = EncodeOrCheck.nameOrValue(name, true, \"query parameter name\");\r\n    final List<String> valuesStr = new ArrayList<String>();\r\n    for (final Object value : values) {\r\n        final String vcs = EncodeOrCheck.nameOrValue(value, true, \"query parameter value\");\r\n        valuesStr.add(vcs);\r\n    }\r\n    final Iterator<String> valueIter = valuesStr.iterator();\r\n    StringBuilder query;\r\n    if (this.query == null) {\r\n        query = new StringBuilder();\r\n        this.query = query;\r\n    } else if (this.query instanceof StringBuilder) {\r\n        query = (StringBuilder) this.query;\r\n        query.append('&');\r\n    } else {\r\n        query = new StringBuilder(this.query.toString());\r\n        query.append('&');\r\n    }\r\n    query.append(ncs);\r\n    query.append('=');\r\n    query.append(valueIter.next());\r\n    while (valueIter.hasNext()) {\r\n        query.append('&');\r\n        query.append(ncs);\r\n        query.append('=');\r\n        query.append(valueIter.next());\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.restlet.engine.application.TunnelFilter.getheaderReplacers",
	"Comment": "returns the list of new header values. each of them describe also a setof conditions required to set the new value. this method is used only toinitialize the headerreplacers field.",
	"Method": "List<HeaderReplacer> getheaderReplacers(URL userAgentPropertiesUrl,String oldHeaderName,String newHeaderName){\r\n    List<HeaderReplacer> headerReplacers = new ArrayList<HeaderReplacer>();\r\n    if (userAgentPropertiesUrl != null) {\r\n        BufferedReader reader;\r\n        try {\r\n            reader = new BufferedReader(new InputStreamReader(userAgentPropertiesUrl.openStream(), CharacterSet.UTF_8.getName()), IoUtils.BUFFER_SIZE);\r\n            HeaderReplacer.Builder headerReplacerBuilder = new HeaderReplacer.Builder();\r\n            try {\r\n                String line = reader.readLine();\r\n                for (; line != null; line = reader.readLine()) {\r\n                    if (!line.startsWith(\"#\")) {\r\n                        final String[] keyValue = line.split(\":\");\r\n                        if (keyValue.length == 2) {\r\n                            final String key = keyValue[0].trim();\r\n                            final String value = keyValue[1].trim();\r\n                            if (oldHeaderName.equalsIgnoreCase(key)) {\r\n                                headerReplacerBuilder.setOldValue((\"\".equals(value)) ? null : value);\r\n                            } else if (newHeaderName.equalsIgnoreCase(key)) {\r\n                                headerReplacerBuilder.setNewValue(value);\r\n                                headerReplacers.add(headerReplacerBuilder.build());\r\n                                headerReplacerBuilder = new HeaderReplacer.Builder();\r\n                            } else {\r\n                                headerReplacerBuilder.putAgentAttribute(key, value);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } finally {\r\n                reader.close();\r\n            }\r\n        } catch (IOException e) {\r\n            getContext().getLogger().warning(\"Cannot read '\" + userAgentPropertiesUrl.toString() + \"' due to: \" + e.getMessage());\r\n        }\r\n    }\r\n    return headerReplacers;\r\n}"
}, {
	"Path": "org.restlet.resource.Directory.isNegotiatingContent",
	"Comment": "indicates if the best content is automatically negotiated. default valueis true.",
	"Method": "boolean isNegotiatingContent(){\r\n    return this.negotiatingContent;\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.DefaultSslContextFactory.setEnabledProtocols",
	"Comment": "sets the standard name of the protocols to use when creating the sslsockets or engines.",
	"Method": "void setEnabledProtocols(String[] enabledProtocols){\r\n    this.enabledProtocols = enabledProtocols;\r\n}"
}, {
	"Path": "org.restlet.engine.resource.AnnotationUtils.addAnnotations",
	"Comment": "computes the annotation descriptors for the given class or interface.",
	"Method": "List<AnnotationInfo> addAnnotations(List<AnnotationInfo> descriptors,Class<?> clazz,Class<?> initialClass){\r\n    List<AnnotationInfo> result = descriptors;\r\n    if (clazz != null && !ServerResource.class.equals(clazz)) {\r\n        if (result == null) {\r\n            result = new CopyOnWriteArrayList<AnnotationInfo>();\r\n        }\r\n        addThrowableAnnotationDescriptors(result, clazz, initialClass);\r\n        if (clazz.isInterface()) {\r\n            for (java.lang.reflect.Method javaMethod : clazz.getMethods()) {\r\n                addMethodAnnotationDescriptors(result, clazz, initialClass, javaMethod);\r\n            }\r\n        } else {\r\n            for (java.lang.reflect.Method javaMethod : clazz.getDeclaredMethods()) {\r\n                addMethodAnnotationDescriptors(result, clazz, initialClass, javaMethod);\r\n            }\r\n        }\r\n        Class<?>[] interfaces = clazz.getInterfaces();\r\n        if (interfaces != null) {\r\n            for (Class<?> interfaceClass : interfaces) {\r\n                result = addAnnotations(result, interfaceClass, initialClass);\r\n            }\r\n        }\r\n        addAnnotations(result, clazz.getSuperclass(), initialClass);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.toEdmInt32",
	"Comment": "convert the given value to the string representation of a edm int32value.",
	"Method": "String toEdmInt32(int value){\r\n    return Integer.toString(value);\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.DefaultSslContextFactory.setNeedClientAuthentication",
	"Comment": "indicates if we require client certificate authentication. the defaultvalue is false.",
	"Method": "void setNeedClientAuthentication(boolean needClientAuthentication){\r\n    this.needClientAuthentication = needClientAuthentication;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.ConnectionHelper.isPersistingConnections",
	"Comment": "indicates if persistent connections should be used if possible.",
	"Method": "boolean isPersistingConnections(){\r\n    return Boolean.parseBoolean(getHelpedParameters().getFirstValue(\"persistingConnections\", \"true\"));\r\n}"
}, {
	"Path": "org.restlet.data.Reference.setUserInfo",
	"Comment": "sets the user info component for server based hierarchical identifiers.",
	"Method": "void setUserInfo(String userInfo){\r\n    final String authority = getAuthority();\r\n    if (authority != null) {\r\n        final int index = authority.indexOf('@');\r\n        final String newUserInfo = (userInfo == null) ? \"\" : userInfo + '@';\r\n        if (index != -1) {\r\n            setAuthority(newUserInfo + authority.substring(index + 1));\r\n        } else {\r\n            setAuthority(newUserInfo + authority);\r\n        }\r\n    } else {\r\n        throw new IllegalArgumentException(\"No authority defined, please define a host name first\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.JettyServerHelper.getHttpOutputBufferSize",
	"Comment": "http output buffer size in bytes. defaults to 321024.a larger buffer can improve performance by allowing a content producer to run without blocking, however largerbuffers consume more memory and may induce some latency before a client starts processing the content.",
	"Method": "int getHttpOutputBufferSize(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"http.outputBufferSize\", \"32768\"));\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Source.getRights",
	"Comment": "returns the information about rights held in and over an entry.",
	"Method": "Text getRights(){\r\n    return this.rights;\r\n}"
}, {
	"Path": "com.restfb.SpecialCommentHandlingTest.onlyCountTest",
	"Comment": "can we handle comments that are objects with only a count and no data?",
	"Method": "void onlyCountTest(){\r\n    Post post = createJsonMapper().toJavaObject(jsonFromClasspath(\"post-with-comment-count-only\"), Post.class);\r\n    assertThat(post.getComments().getTotalCount()).isEqualTo(3);\r\n}"
}, {
	"Path": "org.restlet.engine.adapter.ClientAdapter.readResponseHeaders",
	"Comment": "reads the response headers of a handled http client call to update theoriginal uniform call.",
	"Method": "void readResponseHeaders(ClientCall httpCall,Response response){\r\n    try {\r\n        Series<Header> responseHeaders = httpCall.getResponseHeaders();\r\n        response.getAttributes().put(HeaderConstants.ATTRIBUTE_HEADERS, responseHeaders);\r\n        HeaderUtils.copyResponseTransportHeaders(responseHeaders, response);\r\n    } catch (Exception e) {\r\n        getLogger().log(Level.FINE, \"An error occurred during the processing of the HTTP response.\", e);\r\n        response.setStatus(Status.CONNECTOR_ERROR_INTERNAL, e);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jaxb.internal.Unmarshaller.unmarshal",
	"Comment": "unmarshal xml data from the specified reader and return the resultingjava content tree.",
	"Method": "Object unmarshal(JaxbRepresentation<?> jaxbRep,Object unmarshal,JaxbRepresentation<?> jaxbRep,InputStream stream,Object unmarshal,JaxbRepresentation<?> jaxbRep,Reader reader){\r\n    SAXSource ss = null;\r\n    try {\r\n        SAXParserFactory spf = SAXParserFactory.newInstance();\r\n        spf.setNamespaceAware(true);\r\n        spf.setValidating(jaxbRep.isValidatingDtd());\r\n        spf.setXIncludeAware(jaxbRep.isXIncludeAware());\r\n        spf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, jaxbRep.isSecureProcessing());\r\n        spf.setFeature(\"http://xml.org/sax/features/external-general-entities\", jaxbRep.isExpandingEntityRefs());\r\n        spf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", jaxbRep.isExpandingEntityRefs());\r\n        XMLReader xmlReader = spf.newSAXParser().getXMLReader();\r\n        ss = new SAXSource(xmlReader, new InputSource(reader));\r\n    } catch (Exception e) {\r\n        throw new JAXBException(\"Unable to create customized SAX source\", e);\r\n    }\r\n    getUnmarshaller().setEventHandler(jaxbRep.getValidationEventHandler());\r\n    return getUnmarshaller().unmarshal(ss);\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.MethodSignature.equals",
	"Comment": "compares two objects for equality.if the compared object is amethodsignature and the argtypes match, they are thesame",
	"Method": "boolean equals(Object o){\r\n    boolean result = false;\r\n    if (o instanceof MethodSignature) {\r\n        MethodSignature signature = (MethodSignature) o;\r\n        result = java.util.Arrays.equals(getParameters(), signature.getParameters());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.util.Base64.encode",
	"Comment": "encodes an entire chars array into a base64 string, with optionalnewlines after every 76 characters.",
	"Method": "String encode(byte[] bytes,boolean newlines,String encode,byte[] bytes,int off,int len,boolean newlines,String encode,char[] chars,boolean newlines,String encode,char[] chars,String charset,boolean newlines){\r\n    return encode(IoUtils.toByteArray(chars, charset), newlines);\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipRequest.setMimeVersion",
	"Comment": "sets the version of the mime protocol used to construct the message.",
	"Method": "void setMimeVersion(String mimeVersion){\r\n    this.mimeVersion = mimeVersion;\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.setNext",
	"Comment": "sets the next handler such as a restlet or a filter.in addition, this method will set the context of the next restlet if itis null by passing a reference to its own context.",
	"Method": "void setNext(org.restlet.Uniform next){\r\n    if (next instanceof Restlet) {\r\n        Restlet nextRestlet = (Restlet) next;\r\n        if (nextRestlet.getContext() == null) {\r\n            nextRestlet.setContext(getContext());\r\n        }\r\n    }\r\n    this.next = next;\r\n    this.nextCreated = false;\r\n}"
}, {
	"Path": "org.restlet.Request.getConditions",
	"Comment": "returns the modifiable conditions applying to this request. creates a newinstance if no one has been set.",
	"Method": "Conditions getConditions(){\r\n    Conditions c = this.conditions;\r\n    if (c == null) {\r\n        synchronized (this) {\r\n            c = this.conditions;\r\n            if (c == null) {\r\n                this.conditions = c = new Conditions();\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "org.restlet.ext.json.JsonRepresentation.getJsonTokener",
	"Comment": "gets the wrapped json tokener or converts the wrapped representation ifneeded.",
	"Method": "JSONTokener getJsonTokener(){\r\n    if (this.jsonValue != null) {\r\n        return (JSONTokener) this.jsonValue;\r\n    }\r\n    return new JSONTokener(getJsonText());\r\n}"
}, {
	"Path": "org.restlet.util.WrapperMap.containsValue",
	"Comment": "returns true if this map maps one or more keys to the specified value.",
	"Method": "boolean containsValue(Object value){\r\n    return getDelegate().containsValue(value);\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createPaymentQuery",
	"Comment": "creates a query for payment entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Payment> createPaymentQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Payment.class);\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.toEdmTime",
	"Comment": "convert the given value to the string representation of a edm time value.",
	"Method": "String toEdmTime(long value){\r\n    return timeFormat.format(value);\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.Literal.isTyped",
	"Comment": "indicates if the literal is types. typed literals have a value and adatatype reference.",
	"Method": "boolean isTyped(){\r\n    return (getValue() != null) && (getDatatypeRef() != null);\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.DigestUtils.toHttpDigest",
	"Comment": "return the http digest hashed secret. it concatenates the identifier,realm and secret, separated by a comma and digest them using md5.",
	"Method": "String toHttpDigest(String identifier,char[] secret,String realm){\r\n    if (secret != null) {\r\n        return toMd5(identifier + \":\" + realm + \":\" + new String(secret));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.toEdmInt16",
	"Comment": "convert the given value to the string representation of a edm int16value.",
	"Method": "String toEdmInt16(short value){\r\n    return Short.toString(value);\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createRequirementQuery",
	"Comment": "creates a query for requirement entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Requirement> createRequirementQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Requirement.class);\r\n}"
}, {
	"Path": "org.restlet.data.Preference.getParameters",
	"Comment": "returns the modifiable list of parameters. creates a new instance if noone has been set.",
	"Method": "Series<Parameter> getParameters(){\r\n    Series<Parameter> p = this.parameters;\r\n    if (p == null) {\r\n        synchronized (this) {\r\n            p = this.parameters;\r\n            if (p == null) {\r\n                this.parameters = p = new Series<Parameter>(Parameter.class);\r\n            }\r\n        }\r\n    }\r\n    return p;\r\n}"
}, {
	"Path": "org.restlet.engine.resource.AnnotationUtils.addMethodAnnotationDescriptors",
	"Comment": "computes the annotation descriptors for the given java method.",
	"Method": "List<AnnotationInfo> addMethodAnnotationDescriptors(List<AnnotationInfo> descriptors,Class<?> clazz,Class<?> initialClass,java.lang.reflect.Method javaMethod){\r\n    List<AnnotationInfo> result = descriptors;\r\n    for (Annotation annotation : javaMethod.getAnnotations()) {\r\n        Annotation methodAnnotation = annotation.annotationType().getAnnotation(org.restlet.engine.connector.Method.class);\r\n        Method restletMethod = getRestletMethod(annotation, methodAnnotation);\r\n        if (restletMethod != null) {\r\n            if (result == null) {\r\n                result = new CopyOnWriteArrayList<AnnotationInfo>();\r\n            }\r\n            try {\r\n                java.lang.reflect.Method valueMethod = annotation.getClass().getDeclaredMethod(\"value\");\r\n                String value = (String) valueMethod.invoke(annotation);\r\n                result.add(new MethodAnnotationInfo(initialClass, restletMethod, javaMethod, value));\r\n            } catch (Exception exception) {\r\n                Context.getCurrentLogger().info(\"Cannot get value of Restlet annotation: \" + annotation + \" due to \" + exception.getMessage());\r\n            }\r\n        }\r\n    }\r\n    for (Class<?> exceptionClass : javaMethod.getExceptionTypes()) {\r\n        for (Annotation annotation : exceptionClass.getAnnotations()) {\r\n            org.restlet.resource.Status statusAnnotation = annotation.annotationType().getAnnotation(org.restlet.resource.Status.class);\r\n            if (statusAnnotation != null) {\r\n                int code = statusAnnotation.value();\r\n                boolean serializable = statusAnnotation.serialize();\r\n                if (result == null) {\r\n                    result = new CopyOnWriteArrayList<AnnotationInfo>();\r\n                }\r\n                result.add(new ThrowableAnnotationInfo(initialClass, code, serializable));\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.DigestAuthenticator.setDomainRefs",
	"Comment": "sets the uri references that define the protection domains for the digestauthentication.",
	"Method": "void setDomainRefs(List<Reference> domainRefs){\r\n    this.domainRefs = domainRefs;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxb.JaxbRepresentation.setValidatingDtd",
	"Comment": "indicates the desire for validating this type of xml representationsagainst an xml schema if one is referenced within the contents.",
	"Method": "void setValidatingDtd(boolean validating){\r\n    this.validatingDtd = validating;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.exceptions.ConvertParameterException.primitive",
	"Comment": "throws a message, that the given string value could not be converted to aprimitive.",
	"Method": "ConvertParameterException primitive(Class<?> paramType,String unparseableValue,Throwable cause){\r\n    throw new ConvertParameterException(\"Could not convert the String \\\"\" + unparseableValue + \"\\\" to a \" + paramType, cause);\r\n}"
}, {
	"Path": "org.restlet.Component.setInternalRouter",
	"Comment": "sets the private internal router were restlets like applications can beattached.",
	"Method": "void setInternalRouter(Router internalRouter){\r\n    this.internalRouter = internalRouter;\r\n}"
}, {
	"Path": "org.restlet.engine.header.HeaderReader.readActualNamedValue",
	"Comment": "reads a parameter value which is either a token or a quoted string.",
	"Method": "String readActualNamedValue(){\r\n    String result = null;\r\n    skipSpaces();\r\n    int nextChar = peek();\r\n    if (isDoubleQuote(nextChar)) {\r\n        result = readQuotedString();\r\n    } else if (isTokenChar(nextChar)) {\r\n        result = readToken();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.core.CallContext.selectVariant",
	"Comment": "select the representation variant that best matches the request. moreexplicit variants are chosen ahead of less explicit ones. a vary headeris computed from the supplied list and automatically added to theresponse.",
	"Method": "Variant selectVariant(List<Variant> variants){\r\n    if ((variants == null) || variants.isEmpty()) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    List<org.restlet.representation.Variant> restletVariants = Converter.toRestletVariants(variants);\r\n    ConnegService connegService = null;\r\n    MetadataService metadataService = null;\r\n    org.restlet.Application app = org.restlet.Application.getCurrent();\r\n    if (app == null) {\r\n        connegService = new org.restlet.service.ConnegService();\r\n        metadataService = new MetadataService();\r\n    } else {\r\n        connegService = app.getConnegService();\r\n        metadataService = app.getMetadataService();\r\n    }\r\n    org.restlet.representation.Variant bestRestlVar = connegService.getPreferredVariant(restletVariants, this.request, metadataService);\r\n    Variant bestVariant = Converter.toJaxRsVariant(bestRestlVar);\r\n    Set<Dimension> dimensions = this.response.getDimensions();\r\n    if (bestRestlVar.getCharacterSet() != null) {\r\n        dimensions.add(Dimension.CHARACTER_SET);\r\n    }\r\n    if (bestRestlVar.getEncodings() != null) {\r\n        dimensions.add(Dimension.ENCODING);\r\n    }\r\n    if (bestRestlVar.getLanguages() != null) {\r\n        dimensions.add(Dimension.LANGUAGE);\r\n    }\r\n    if (bestRestlVar.getMediaType() != null) {\r\n        dimensions.add(Dimension.MEDIA_TYPE);\r\n    }\r\n    return bestVariant;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.ClientConnectionHelper.getBestConnection",
	"Comment": "tries to reuse an existing connection for the given request, or creates anew one. it may return null if the maximum number of connections per hostor in general is reached.",
	"Method": "Connection<Client> getBestConnection(Request request){\r\n    Connection<Client> result = null;\r\n    int hostConnectionCount = 0;\r\n    int bestScore = Integer.MAX_VALUE;\r\n    boolean foundConn = false;\r\n    InetSocketAddress socketAddress = getSocketAddress(request);\r\n    if (socketAddress == null) {\r\n        getLogger().log(Level.WARNING, \"Unable to create a socket address related to the request.\");\r\n    } else {\r\n        for (Iterator<Connection<Client>> iterator = getConnections().iterator(); !foundConn && iterator.hasNext(); ) {\r\n            Connection<Client> currConn = iterator.next();\r\n            if (socketAddress.equals(currConn.getSocketAddress())) {\r\n                if (currConn.isAvailable()) {\r\n                    result = currConn;\r\n                    foundConn = true;\r\n                } else if (currConn.getState().compareTo(ConnectionState.OPEN) <= 0) {\r\n                    int currScore = currConn.getLoadScore();\r\n                    if (bestScore > currScore) {\r\n                        bestScore = currScore;\r\n                        result = currConn;\r\n                    }\r\n                    hostConnectionCount++;\r\n                }\r\n            }\r\n        }\r\n        if (foundConn) {\r\n            getLogger().log(Level.FINE, \"Reusing an existing client connection to: \" + socketAddress);\r\n        } else if ((getMaxTotalConnections() != -1) && (getConnections().size() >= getMaxTotalConnections())) {\r\n            if (result == null) {\r\n                getLogger().log(Level.WARNING, \"Unable to create a new connection. Maximum total number of connections reached!\");\r\n            } else {\r\n                getLogger().log(Level.FINE, \"Enqueue Request to an existing client connection to: \" + socketAddress);\r\n            }\r\n        } else if ((getMaxConnectionsPerHost() != -1) && (hostConnectionCount >= getMaxConnectionsPerHost())) {\r\n            if (result == null) {\r\n                getLogger().log(Level.WARNING, \"Unable to create a new connection. Maximum number of connections reached for host: \" + socketAddress);\r\n            } else {\r\n                getLogger().log(Level.FINE, \"Enqueue Request to an existing client connection to: \" + socketAddress);\r\n            }\r\n        } else {\r\n            if (getLogger().isLoggable(Level.FINE)) {\r\n                getLogger().log(Level.FINE, \"Creating a new client connection to: \" + socketAddress);\r\n            }\r\n            result = checkout(createSocketChannel(request.isConfidential(), socketAddress), getController(), socketAddress);\r\n            getConnections().add(result);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.application.StatusInfo.setContactEmail",
	"Comment": "sets the email address of the administrator to contact in case of error.",
	"Method": "void setContactEmail(String email){\r\n    this.contactEmail = email;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.EntityType.isBlob",
	"Comment": "returns true if this type a blob, that is to say it represents binarydata.",
	"Method": "boolean isBlob(){\r\n    return blob;\r\n}"
}, {
	"Path": "org.restlet.engine.resource.MethodAnnotationInfo.isCompatibleRequestEntity",
	"Comment": "indicates if the given request entity is compatible with the annotatedmethod described.",
	"Method": "boolean isCompatibleRequestEntity(Representation requestEntity,MetadataService metadataService,org.restlet.service.ConverterService converterService){\r\n    boolean result = true;\r\n    if ((requestEntity != null) && requestEntity.isAvailable()) {\r\n        List<Variant> requestVariants = getRequestVariants(metadataService, converterService);\r\n        if ((requestVariants != null) && !requestVariants.isEmpty()) {\r\n            result = false;\r\n            for (int i = 0; (!result) && (i < requestVariants.size()); i++) {\r\n                result = (requestVariants.get(i).isCompatible(requestEntity));\r\n            }\r\n        } else {\r\n            result = false;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.httpclient.HttpClientHelper.getSocketTimeout",
	"Comment": "returns the socket timeout value. a timeout of zero is interpreted as aninfinite timeout. defaults to 60000.",
	"Method": "int getSocketTimeout(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"socketTimeout\", \"60000\"));\r\n}"
}, {
	"Path": "org.restlet.service.LogService.isDebugging",
	"Comment": "indicates if the debugging mode is enabled. false by default.",
	"Method": "boolean isDebugging(){\r\n    return debugging;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.MatchingResult.getFinalCapturingGroup",
	"Comment": "returns the final capturing group. starts ever with a slash.",
	"Method": "RemainingPath getFinalCapturingGroup(){\r\n    return this.finalCapturingGroup;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Entry.getPublished",
	"Comment": "returns the moment associated with an event early in the life cycle ofthe entry.",
	"Method": "Date getPublished(){\r\n    return this.published;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.way.OutboundWay.onHeadersCompleted",
	"Comment": "callback invoked when a message has been sent. note that only the startline and the headers must have been sent, not the optional body.",
	"Method": "void onHeadersCompleted(){\r\n    if (getLogger().isLoggable(Level.FINER)) {\r\n        getLogger().finer(\"Outbound message start line and headers sent\");\r\n    }\r\n    if (getActualMessage().isEntityAvailable()) {\r\n        ConnectorService connectorService = ConnectorHelper.getConnectorService();\r\n        if (connectorService != null) {\r\n            connectorService.afterSend(getActualMessage().getEntity());\r\n        }\r\n        setMessageState(MessageState.BODY);\r\n        ReadableByteChannel rbc = getActualMessage().getEntity().getChannel();\r\n        if (rbc instanceof FileChannel) {\r\n            setEntityChannelType(EntityType.TRANSFERABLE);\r\n        } else if (rbc instanceof BlockableChannel) {\r\n            BlockableChannel bc = (BlockableChannel) rbc;\r\n            if (bc.isBlocking()) {\r\n                setEntityChannelType(EntityType.BLOCKING);\r\n            } else {\r\n                setEntityChannelType(EntityType.NON_BLOCKING);\r\n            }\r\n        } else if (rbc instanceof SelectableChannel) {\r\n            SelectableChannel sc = (SelectableChannel) rbc;\r\n            if (sc.isBlocking()) {\r\n                setEntityChannelType(EntityType.BLOCKING);\r\n            } else {\r\n                setEntityChannelType(EntityType.NON_BLOCKING);\r\n            }\r\n        } else {\r\n            setEntityChannelType(EntityType.BLOCKING);\r\n        }\r\n        if (getActualMessage().getEntity().getAvailableSize() == Representation.UNKNOWN_SIZE) {\r\n            setEntityChannel(new ReadableChunkingChannel(rbc, getBuffer().capacity()));\r\n        } else {\r\n            setEntityChannel(new ReadableSizedChannel(rbc, getActualMessage().getEntity().getAvailableSize()));\r\n        }\r\n    } else {\r\n        setMessageState(MessageState.END);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.AbstractMethodWrapper.internalInvoke",
	"Comment": "invokes the method and returned the created representation for theresponse.",
	"Method": "Object internalInvoke(ResourceObject resourceObject){\r\n    final Object[] args = this.parameters.get();\r\n    final Object jaxRsResourceObj = resourceObject.getJaxRsResourceObject();\r\n    return this.executeMethod.invoke(jaxRsResourceObj, args);\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.CookieAuthenticator.isLoggingOut",
	"Comment": "indicates if the request is an attempt to log out and should beintercepted.",
	"Method": "boolean isLoggingOut(Request request,Response response){\r\n    return isInterceptingLogout() && getLogoutPath().equals(request.getResourceRef().getRemainingPart(false, false)) && (Method.GET.equals(request.getMethod()) || Method.POST.equals(request.getMethod()));\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.toEdmDateTime",
	"Comment": "convert the given value to the string representation of a edm datetimevalue.",
	"Method": "String toEdmDateTime(Date value){\r\n    return DateUtils.format(value, dateTimeFormats.get(0));\r\n}"
}, {
	"Path": "org.restlet.engine.resource.MethodAnnotationInfo.isCompatible",
	"Comment": "indicates if the annotated method described is compatible with the givenparameters.",
	"Method": "boolean isCompatible(Method restletMethod,Form queryParams,Representation requestEntity,MetadataService metadataService,org.restlet.service.ConverterService converterService){\r\n    boolean result = true;\r\n    if (getQuery() != null) {\r\n        Form requiredParams = new Form(getQuery());\r\n        for (Iterator<Parameter> iter = requiredParams.iterator(); iter.hasNext() && result; ) {\r\n            result = queryParams.contains(iter.next());\r\n        }\r\n    }\r\n    if (result) {\r\n        result = getRestletMethod().equals(restletMethod);\r\n    }\r\n    if (result) {\r\n        result = isCompatibleRequestEntity(requestEntity, metadataService, converterService);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.routing.TemplateRoute.getMatchingMode",
	"Comment": "returns the matching mode to use on the template when parsing a formattedreference.",
	"Method": "int getMatchingMode(){\r\n    return getTemplate().getMatchingMode();\r\n}"
}, {
	"Path": "org.restlet.example.firstSteps.FirstStepsApplication.createInboundRoot",
	"Comment": "creates a root restlet that will receive all incoming calls.",
	"Method": "Restlet createInboundRoot(){\r\n    Router router = new Router(getContext());\r\n    router.attachDefault(HelloWorldResource.class);\r\n    return router;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.way.Way.onSelected",
	"Comment": "callback method invoked when the way has been selected for io operationsit registered interest in.",
	"Method": "void onSelected(SelectionRegistration selectionRegistration){\r\n    try {\r\n        if (getMessage() != null) {\r\n            Response.setCurrent(getMessage());\r\n            Application.setCurrent((Application) getMessage().getAttributes().get(\"org.restlet.application\"));\r\n            Context.setCurrent((Context) getMessage().getAttributes().get(\"org.restlet.context\"));\r\n            VirtualHost.setCurrent((Integer) getMessage().getAttributes().get(\"org.restlet.virtualHost\"));\r\n        }\r\n        if (getIoState() != IoState.READY) {\r\n            setIoState(IoState.PROCESSING);\r\n        }\r\n        if (getLogger().isLoggable(Level.FINER)) {\r\n            if (this instanceof InboundWay) {\r\n                getLogger().log(Level.FINER, \"Processing IO for inbound way: \" + this);\r\n            } else {\r\n                getLogger().log(Level.FINER, \"Processing IO for outbound way: \" + this);\r\n            }\r\n        }\r\n        int drained = processIoBuffer();\r\n        if ((drained == -1) && (getConnection().getState() == ConnectionState.CLOSING)) {\r\n            getBuffer().clear();\r\n        } else if ((getIoState() == IoState.PROCESSING)) {\r\n            onPostProcessing();\r\n        }\r\n    } catch (Exception e) {\r\n        getConnection().onError(\"Error while processing a connection\", e, Status.CONNECTOR_ERROR_COMMUNICATION);\r\n    }\r\n    if (this instanceof InboundWay) {\r\n        getLogger().log(Level.FINER, \"Inbound way selected. Done for : \" + this);\r\n    } else {\r\n        getLogger().log(Level.FINER, \"Outbound way selected. Done for : \" + this);\r\n    }\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.Resolver.binaryResultType",
	"Comment": "returns the classdef for the type to which arithmeticexpressions evaluate.",
	"Method": "IClass binaryResultType(IClass a,IClass b){\r\n    IClass result = null;\r\n    IClass string = new ExternalClass(java.lang.String.class);\r\n    if (a.equals(string) || b.equals(string)) {\r\n        result = string;\r\n    } else if (a.equals(PrimitiveClasses.BOOLEAN)) {\r\n        result = PrimitiveClasses.BOOLEAN;\r\n    } else {\r\n        result = PrimitiveClasses.binaryPromote(a, b);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.Application.getConnectorService",
	"Comment": "returns the connector service. the service is enabled by default.",
	"Method": "ConnectorService getConnectorService(){\r\n    return getServices().get(ConnectorService.class);\r\n}"
}, {
	"Path": "org.restlet.example.book.restlet.ch09.client.Mail.onModuleLoad",
	"Comment": "this method constructs the application user interface by instantiatingcontrols and hooking up event handler.",
	"Method": "void onModuleLoad(){\r\n    GWT.<GlobalResources>create(GlobalResources.class).css().ensureInjected();\r\n    DockLayoutPanel outer = binder.createAndBindUi(this);\r\n    Window.enableScrolling(false);\r\n    Window.setMargin(\"0px\");\r\n    Element topElem = outer.getWidgetContainerElement(topPanel);\r\n    topElem.getStyle().setZIndex(2);\r\n    topElem.getStyle().setOverflow(Overflow.VISIBLE);\r\n    mailList.setListener(new MailList.Listener() {\r\n        public void onItemSelected(MailItem item) {\r\n            mailDetail.setItem(item);\r\n        }\r\n    });\r\n    RootLayoutPanel root = RootLayoutPanel.get();\r\n    root.add(outer);\r\n}"
}, {
	"Path": "org.restlet.example.book.restlet.ch09.client.Mail.onModuleLoad",
	"Comment": "this method constructs the application user interface by instantiatingcontrols and hooking up event handler.",
	"Method": "void onModuleLoad(){\r\n    mailDetail.setItem(item);\r\n}"
}, {
	"Path": "org.restlet.ext.emf.EmfRepresentation.isUsingEncodedAttributeStyle",
	"Comment": "indicates if emf references should be written as uri anchors.",
	"Method": "boolean isUsingEncodedAttributeStyle(){\r\n    return usingEncodedAttributeStyle;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.FeedReader.endLink",
	"Comment": "called at the end of the xml block that defines the given link.",
	"Method": "void endLink(Link link){\r\n    if (this.feedReader != null) {\r\n        this.feedReader.endLink(link);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.service.ConverterService.toRepresentation",
	"Comment": "converts a regular java object into a representation. the converter willuse the preferred variant of the selected converter.",
	"Method": "Representation toRepresentation(Object source,Representation toRepresentation,Object source,MediaType target,Representation toRepresentation,Object source,Variant target,Representation toRepresentation,Object source,Variant target,Resource resource){\r\n    Representation result = null;\r\n    boolean loggable = (resource == null) || resource.isLoggable();\r\n    ConverterHelper ch = ConverterUtils.getBestHelper(source, target, resource);\r\n    if (ch != null) {\r\n        if (loggable && Context.getCurrentLogger().isLoggable(Level.FINE)) {\r\n            Context.getCurrentLogger().fine(\"Converter selected for \" + source.getClass().getSimpleName() + \": \" + ch.getClass().getSimpleName());\r\n        }\r\n        if (target == null) {\r\n            List<VariantInfo> variants = ch.getVariants(source.getClass());\r\n            if ((variants != null) && !variants.isEmpty()) {\r\n                if (resource != null) {\r\n                    target = resource.getConnegService().getPreferredVariant(variants, resource.getRequest(), resource.getMetadataService());\r\n                } else {\r\n                    target = variants.get(0);\r\n                }\r\n            }\r\n        }\r\n        if (target == null) {\r\n            target = new Variant();\r\n        }\r\n        result = ch.toRepresentation(source, target, resource);\r\n        if (result != null) {\r\n            if (result.getCharacterSet() == null) {\r\n                result.setCharacterSet(target.getCharacterSet());\r\n            }\r\n            if ((result.getMediaType() == null) || !result.getMediaType().isConcrete()) {\r\n                if ((target.getMediaType() != null) && target.getMediaType().isConcrete()) {\r\n                    result.setMediaType(target.getMediaType());\r\n                } else if (resource != null) {\r\n                    result.setMediaType(resource.getMetadataService().getDefaultMediaType());\r\n                } else {\r\n                    result.setMediaType(MediaType.APPLICATION_OCTET_STREAM);\r\n                }\r\n            }\r\n            if (result.getEncodings().isEmpty()) {\r\n                result.getEncodings().addAll(target.getEncodings());\r\n            }\r\n            if (result.getLanguages().isEmpty()) {\r\n                result.getLanguages().addAll(target.getLanguages());\r\n            }\r\n        }\r\n    } else {\r\n        if (loggable) {\r\n            Context.getCurrentLogger().warning(\"Unable to find a converter for this object : \" + source);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.swagger.v2_0.SwaggerUtils.getInputPayload",
	"Comment": "returns the input payload of the given operation if there is one. null otherwise.",
	"Method": "BodyParameter getInputPayload(Operation operation){\r\n    for (Parameter parameter : operation.getParameters()) {\r\n        if (parameter instanceof BodyParameter) {\r\n            return (BodyParameter) parameter;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.resource.ClientResource.setRequestEntityBuffering",
	"Comment": "indicates if transient or unknown size response entities should bebuffered after being received. this is useful to increase the chance ofbeing able to resubmit a failed request due to network error, or toprevent chunked encoding from being used an http connector.",
	"Method": "void setRequestEntityBuffering(boolean requestEntityBuffering){\r\n    this.requestEntityBuffering = requestEntityBuffering;\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.Link.getTypeRef",
	"Comment": "returns the type reference. this maps with the concept of predicate inrdf terminology.",
	"Method": "Reference getTypeRef(){\r\n    return this.typeRef;\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.Link.setTypeRef",
	"Comment": "sets the type reference. this maps with the concept of predicate in rdfterminology.",
	"Method": "void setTypeRef(Reference typeRef){\r\n    this.typeRef = typeRef;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.TableMaker.makeElseBlock",
	"Comment": "defines an anonymous block to enclose the scope of an else block",
	"Method": "void makeElseBlock(SymTabAST tree){\r\n    if (tree.getType() == TokenTypes.SLIST) {\r\n        BlockDef block = makeBlock(tree);\r\n        symbolTable.pushScope(block);\r\n        walkTree(tree, false);\r\n        symbolTable.popScope();\r\n    } else {\r\n        walkTree(tree, false);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.LinkInfo.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    final AttributesImpl attributes = new AttributesImpl();\r\n    if ((getRelationship() != null) && !getRelationship().equals(\"\")) {\r\n        attributes.addAttribute(\"\", \"rel\", null, \"xs:token\", getRelationship());\r\n    }\r\n    if ((getReverseRelationship() != null) && !getReverseRelationship().equals(\"\")) {\r\n        attributes.addAttribute(\"\", \"rev\", null, \"xs:token\", getReverseRelationship());\r\n    }\r\n    if ((getResourceType() != null) && (getResourceType().toString() != null)) {\r\n        attributes.addAttribute(\"\", \"resource_type\", null, \"xs:anyURI\", getResourceType().toString());\r\n    }\r\n    if (getDocumentations().isEmpty()) {\r\n        writer.emptyElement(APP_NAMESPACE, \"link\", null, attributes);\r\n    } else {\r\n        writer.startElement(APP_NAMESPACE, \"link\", null, attributes);\r\n        for (final DocumentationInfo documentationInfo : getDocumentations()) {\r\n            documentationInfo.writeElement(writer);\r\n        }\r\n        writer.endElement(APP_NAMESPACE, \"link\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlWriter.endDocument",
	"Comment": "write a newline at the end of the document. pass the event on down thefilter chain for further processing.",
	"Method": "void endDocument(){\r\n    write('\\n');\r\n    super.endDocument();\r\n    try {\r\n        flush();\r\n    } catch (IOException e) {\r\n        throw new SAXException(e);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.Literal.isPlain",
	"Comment": "indicates if the literal is plain. plain literals have a value and anoptional language tag.",
	"Method": "boolean isPlain(){\r\n    return (getValue() != null) && (getDatatypeRef() == null);\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.RdfConverter.isCompatible",
	"Comment": "indicates if the given variant is compatible with the media typessupported by this converter.",
	"Method": "boolean isCompatible(Variant variant){\r\n    return (variant != null) && (VARIANT_RDF_N3.isCompatible(variant) || VARIANT_RDF_NTRIPLES.isCompatible(variant) || VARIANT_RDF_TURTLE.isCompatible(variant) || VARIANT_RDF_XML.isCompatible(variant));\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.ApplicationInfo.setNamespaces",
	"Comment": "sets the map of namespaces used in the wadl document. the key is the uriof the namespace and the value, the prefix.",
	"Method": "void setNamespaces(Map<String, String> namespaces){\r\n    this.namespaces = namespaces;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlRepresentation.getNumber",
	"Comment": "evaluates an xpath expression as a number. if the evaluation fails, nullwill be returned.",
	"Method": "Double getNumber(String expression){\r\n    return (Double) internalEval(expression, javax.xml.xpath.XPathConstants.NUMBER);\r\n}"
}, {
	"Path": "com.restfb.FacebookClientTest.oauthExceptionWithErrorCode",
	"Comment": "do we correctly handle the case where fb returns an oauthexception with an error code?",
	"Method": "void oauthExceptionWithErrorCode(){\r\n    FacebookClient facebookClient = facebookClientWithResponse(new Response(403, \"{\\\"error\\\":{\\\"message\\\":\\\"(#210) User not visible\\\",\\\"type\\\":\\\"OAuthException\\\",\\\"code\\\":210}}\"));\r\n    try {\r\n        facebookClient.fetchObject(\"me\", User.class);\r\n        failBecauseExceptionWasNotThrown(FacebookOAuthException.class);\r\n    } catch (FacebookOAuthException e) {\r\n        assertThat(e.getErrorMessage()).isEqualTo(\"(#210) User not visible\");\r\n        assertThat(e.getErrorType()).isEqualTo(\"OAuthException\");\r\n        assertThat(e.getErrorCode()).isEqualTo(210);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.Request.abort",
	"Comment": "ask the connector to attempt to abort the related network connection, forexample immediately closing the socket.",
	"Method": "boolean abort(){\r\n    return false;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.Util.getOnlyElement",
	"Comment": "returns the only element of the list, or null, if the list is null orempty.",
	"Method": "A getOnlyElement(Collection<A> list){\r\n    if (list == null) {\r\n        return null;\r\n    }\r\n    if (list.isEmpty()) {\r\n        return null;\r\n    }\r\n    if (list.size() > 1) {\r\n        throw new IllegalArgumentException(\"The list must have exactly one element\");\r\n    }\r\n    if (list instanceof List<?>) {\r\n        return ((List<A>) list).get(0);\r\n    }\r\n    return list.iterator().next();\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Query.addParameter",
	"Comment": "creates a new query with the query parameter set in the uri generatedby the returned query.",
	"Method": "Query<T> addParameter(String name,String value){\r\n    Query<T> result = new Query<T>(this.getService(), this.getSubpath(), (Class<T>) this.entityClass);\r\n    if (getQuery() == null || \"\".equals(getQuery())) {\r\n        result.setQuery(name + \"=\" + value);\r\n    } else {\r\n        result.setQuery(getQuery() + \"&\" + name + \"=\" + value);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.ExceptionHandler.methodInvokeException",
	"Comment": "handles the given exception, catched by an invoke of a resource method ora creation if a sub resource object.",
	"Method": "RequestHandledException methodInvokeException(MethodInvokeException exception,CallContext callContext,String logMessage){\r\n    callContext.getResponse().setStatus(org.restlet.data.Status.SERVER_ERROR_INTERNAL);\r\n    this.logger.log(Level.WARNING, logMessage, exception.getCause());\r\n    throw new RequestHandledException();\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.internal.AwsUtils.getQuerySignature",
	"Comment": "returns the aws simpledb authentication compatible signature for thegiven request and secret.",
	"Method": "String getQuerySignature(Method method,Reference resourceRef,List<Parameter> params,char[] secret){\r\n    return getHmacSha256Signature(getQueryStringToSign(method, resourceRef, params), secret);\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.WadlApplication.attachToHost",
	"Comment": "attaches the application to the given host using the wadl base reference.",
	"Method": "void attachToHost(VirtualHost host){\r\n    if (getBaseRef() != null) {\r\n        final String path = getBaseRef().getPath();\r\n        if (path == null) {\r\n            host.attach(\"\", this);\r\n        } else {\r\n            host.attach(path, this);\r\n        }\r\n    } else {\r\n        getLogger().warning(\"The WADL application has no base reference defined. Unable to guess the virtual host.\");\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipClientResource.create",
	"Comment": "creates a client resource that proxy calls to the given java interfaceinto restlet method calls.",
	"Method": "T create(Context context,Reference reference,Class<? extends T> resourceInterface,T create,Reference reference,Class<? extends T> resourceInterface,T create,String uri,Class<? extends T> resourceInterface){\r\n    return create(null, new Reference(uri), resourceInterface);\r\n}"
}, {
	"Path": "org.restlet.ext.servlet.ServerServlet.getApplication",
	"Comment": "returns the application. it creates a new one if none exists.",
	"Method": "Application getApplication(){\r\n    Application result = this.application;\r\n    if (result == null) {\r\n        synchronized (this) {\r\n            result = this.application;\r\n            if (result == null) {\r\n                if (isDefaultComponent()) {\r\n                    String applicationAttributeName = getInitParameter(NAME_APPLICATION_ATTRIBUTE, NAME_APPLICATION_ATTRIBUTE_DEFAULT + \".\" + getServletName());\r\n                    result = (Application) getServletContext().getAttribute(applicationAttributeName);\r\n                    if (result == null) {\r\n                        result = createApplication(getComponent().getContext());\r\n                        init(result);\r\n                        getServletContext().setAttribute(applicationAttributeName, result);\r\n                    }\r\n                    this.application = result;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.Application.getConnegService",
	"Comment": "returns the content negotiation service. the service is enabled bydefault.",
	"Method": "ConnegService getConnegService(){\r\n    return getServices().get(ConnegService.class);\r\n}"
}, {
	"Path": "org.restlet.ext.xml.TransformRepresentation.getTemplates",
	"Comment": "returns the templates to be used and reused. if no one exists, it createsa new one based on the transformsheet representation and on the uriresolver.",
	"Method": "Templates getTemplates(){\r\n    if (this.templates == null) {\r\n        if (getTransformSheet() != null) {\r\n            try {\r\n                final StreamSource transformSource = new StreamSource(getTransformSheet().getStream());\r\n                if (getTransformSheet().getLocationRef() != null) {\r\n                    transformSource.setSystemId(getTransformSheet().getLocationRef().getTargetRef().toString());\r\n                }\r\n                final TransformerFactory transformerFactory = TransformerFactory.newInstance();\r\n                if (getUriResolver() != null) {\r\n                    transformerFactory.setURIResolver(getUriResolver());\r\n                }\r\n                this.templates = transformerFactory.newTemplates(transformSource);\r\n            } catch (TransformerConfigurationException tce) {\r\n                throw new IOException(\"Transformer configuration exception. \" + tce.getMessage());\r\n            }\r\n        }\r\n    }\r\n    return this.templates;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.util.Util.createList",
	"Comment": "creates an modifiable list with the given object in it, and no otherobjects. if the given object is null, than an empty list will returned",
	"Method": "List<A> createList(A objects){\r\n    final List<A> list = new ArrayList<A>();\r\n    final int l = objects.length;\r\n    for (int i = 0; i < l; i++) {\r\n        final A o = objects[i];\r\n        if (o != null) {\r\n            list.add(o);\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.core.CallContext.evaluatePreconditions",
	"Comment": "evaluate request preconditions based on the passed in value.",
	"Method": "ResponseBuilder evaluatePreconditions(ResponseBuilder evaluatePreconditions,Date lastModified,ResponseBuilder evaluatePreconditions,Date lastModified,EntityTag entityTag,ResponseBuilder evaluatePreconditions,EntityTag entityTag){\r\n    if (entityTag == null) {\r\n        throw new IllegalArgumentException(\"The entity tag must not be null\");\r\n    }\r\n    return evaluatePreconditionsInternal(null, entityTag);\r\n}"
}, {
	"Path": "org.restlet.ext.javamail.TriggerResource.setTargetEntityEnabled",
	"Comment": "indicate whether or not the target supports entity in the request.",
	"Method": "void setTargetEntityEnabled(boolean targetEntityEnabled){\r\n    this.targetEntityEnabled = targetEntityEnabled;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Feed.setId",
	"Comment": "sets the permanent, universally unique identifier for the feed.",
	"Method": "void setId(String id){\r\n    this.id = id;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.firewall.rule.FirewallCounterRule.afterHandle",
	"Comment": "by default, it decrements the counter associated to the request.",
	"Method": "void afterHandle(Request request,Response response){\r\n    this.decrement(request);\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.AssociationEnd.getRole",
	"Comment": "returns the role of this entity relatively to this association.",
	"Method": "String getRole(){\r\n    return role;\r\n}"
}, {
	"Path": "org.restlet.engine.io.IoUtils.getChannel",
	"Comment": "returns a writable byte channel based on a given output stream.",
	"Method": "ReadableByteChannel getChannel(InputStream inputStream,WritableByteChannel getChannel,OutputStream outputStream,ReadableByteChannel getChannel,Representation representation){\r\n    ReadableByteChannel result = null;\r\n    if (Edition.CURRENT != Edition.GAE) {\r\n        final java.nio.channels.Pipe pipe = java.nio.channels.Pipe.open();\r\n        Runnable task = new Runnable() {\r\n            public void run() {\r\n                WritableByteChannel wbc = null;\r\n                try {\r\n                    wbc = pipe.sink();\r\n                    representation.write(wbc);\r\n                } catch (IOException ioe) {\r\n                    Context.getCurrentLogger().log(Level.WARNING, \"Error while writing to the piped channel.\", ioe);\r\n                } finally {\r\n                    if (wbc != null)\r\n                        try {\r\n                            wbc.close();\r\n                        } catch (IOException e) {\r\n                            Context.getCurrentLogger().log(Level.WARNING, \"Error while closing to the piped channel.\", e);\r\n                        }\r\n                }\r\n            }\r\n        };\r\n        org.restlet.Context context = org.restlet.Context.getCurrent();\r\n        if (context != null && context.getExecutorService() != null) {\r\n            context.getExecutorService().execute(task);\r\n        } else {\r\n            Engine.createThreadWithLocalVariables(task, \"Restlet-IoUtils\").start();\r\n        }\r\n        result = pipe.source();\r\n    } else {\r\n        Context.getCurrentLogger().log(Level.WARNING, \"The GAE edition is unable to return a channel for a representation given its write(WritableByteChannel) method.\");\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.io.IoUtils.getChannel",
	"Comment": "returns a writable byte channel based on a given output stream.",
	"Method": "ReadableByteChannel getChannel(InputStream inputStream,WritableByteChannel getChannel,OutputStream outputStream,ReadableByteChannel getChannel,Representation representation){\r\n    WritableByteChannel wbc = null;\r\n    try {\r\n        wbc = pipe.sink();\r\n        representation.write(wbc);\r\n    } catch (IOException ioe) {\r\n        Context.getCurrentLogger().log(Level.WARNING, \"Error while writing to the piped channel.\", ioe);\r\n    } finally {\r\n        if (wbc != null)\r\n            try {\r\n                wbc.close();\r\n            } catch (IOException e) {\r\n                Context.getCurrentLogger().log(Level.WARNING, \"Error while closing to the piped channel.\", e);\r\n            }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.representation.FileRepresentation.setAutoDeleting",
	"Comment": "indicates if this file should be automatically deleted on release of therepresentation.",
	"Method": "void setAutoDeleting(boolean autoDeleting){\r\n    this.autoDeleting = autoDeleting;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.toEdmBinary",
	"Comment": "convert the given value to the string representation of a edm binaryvalue.",
	"Method": "String toEdmBinary(byte[] value){\r\n    return Base64.encode(value, false);\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.DefaultSslContextFactory.setTrustStorePath",
	"Comment": "sets the path to the trust store keystore. the default value is that ofthe javax.net.ssl.truststore system property.",
	"Method": "void setTrustStorePath(String trustStorePath){\r\n    this.trustStorePath = trustStorePath;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.connection.Connection.isAvailable",
	"Comment": "indicates if the connection is available to handle new messages.",
	"Method": "boolean isAvailable(){\r\n    return isPersistent() && getState().equals(ConnectionState.OPEN) && isEmpty() && getInboundWay().isAvailable() && getOutboundWay().isAvailable();\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createJobPartQuery",
	"Comment": "creates a query for jobpart entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.JobPart> createJobPartQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.JobPart.class);\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.swagger.v2_0.Swagger2Writer.fillSwaggerMainAttributes",
	"Comment": "fills swagger main attributes from restlet web api definition",
	"Method": "void fillSwaggerMainAttributes(Definition definition,Swagger swagger){\r\n    if (definition.getEndpoints() != null && !definition.getEndpoints().isEmpty()) {\r\n        Endpoint endpoint = definition.getEndpoints().get(0);\r\n        swagger.setHost(endpoint.getDomain() + (endpoint.getPort() == null ? \"\" : (\":\" + endpoint.getPort())));\r\n        swagger.setBasePath(endpoint.getBasePath());\r\n        swagger.setSchemes(Arrays.asList(Scheme.forValue(endpoint.getProtocol())));\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.spring.SpringBeanRouter.isFindingInAncestors",
	"Comment": "returns true if bean names will be searched for higher up in thebeanfactory hierarchy. default is true.",
	"Method": "boolean isFindingInAncestors(){\r\n    return this.findingInAncestors;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.DigestVerifier.setAlgorithm",
	"Comment": "sets the digest algorithm of provided secrets. provided secrets are theones sent by clients when attempting to authenticate.",
	"Method": "void setAlgorithm(String algorithm){\r\n    this.algorithm = algorithm;\r\n}"
}, {
	"Path": "com.restfb.SpecialCommentHandlingTest.normalTest",
	"Comment": "can we handle comments that are objects with only a count and no data?",
	"Method": "void normalTest(){\r\n    Post post = createJsonMapper().toJavaObject(jsonFromClasspath(\"post-with-normal-comments\"), Post.class);\r\n    assertThat(post.getComments().getData()).hasSize(1);\r\n}"
}, {
	"Path": "org.restlet.engine.component.ComponentXmlParser.attachWithDescriptor",
	"Comment": "creates a new route on a router according to a target descriptor and auri pattern.",
	"Method": "TemplateRoute attachWithDescriptor(Router router,String targetDescriptor,String uriPattern,boolean defaultRoute){\r\n    TemplateRoute route = null;\r\n    String targetClassName = null;\r\n    try {\r\n        targetClassName = \"org.restlet.ext.wadl.WadlApplication\";\r\n        final Class<?> targetClass = Engine.loadClass(targetClassName);\r\n        final Response response = getComponent().getContext().getClientDispatcher().handle(new Request(Method.GET, targetDescriptor));\r\n        if (response.getStatus().isSuccess() && response.isEntityAvailable()) {\r\n            final Representation representation = response.getEntity();\r\n            final Application target = (Application) targetClass.getConstructor(Context.class, Representation.class).newInstance(getComponent().getContext().createChildContext(), representation);\r\n            if (target != null) {\r\n                if ((uriPattern != null) && !defaultRoute) {\r\n                    route = router.attach(uriPattern, target);\r\n                } else {\r\n                    route = router.attachDefault(target);\r\n                }\r\n            }\r\n        } else {\r\n            getLogger().log(Level.WARNING, \"The target descriptor has not been found or is not available, or no client supporting the URI's protocol has been defined on this component. \" + targetDescriptor);\r\n        }\r\n    } catch (ClassNotFoundException e) {\r\n        getLogger().log(Level.WARNING, \"Couldn't find the target class. Please check that your classpath includes \" + targetClassName, e);\r\n    } catch (InstantiationException e) {\r\n        getLogger().log(Level.WARNING, \"Couldn't instantiate the target class. Please check this class has an empty constructor \" + targetClassName, e);\r\n    } catch (IllegalAccessException e) {\r\n        getLogger().log(Level.WARNING, \"Couldn't instantiate the target class. Please check that you have to proper access rights to \" + targetClassName, e);\r\n    } catch (NoSuchMethodException e) {\r\n        getLogger().log(Level.WARNING, \"Couldn't invoke the constructor of the target class. Please check this class has a constructor with a single parameter of Context \" + targetClassName, e);\r\n    } catch (InvocationTargetException e) {\r\n        getLogger().log(Level.WARNING, \"Couldn't instantiate the target class. An exception was thrown while creating \" + targetClassName, e);\r\n    }\r\n    return route;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsClientResource.wrap",
	"Comment": "wraps the client resource to proxy calls to the given java interface intorestlet method calls.",
	"Method": "T wrap(Class<? extends T> resourceInterface){\r\n    T result = null;\r\n    java.lang.reflect.InvocationHandler h = new org.restlet.ext.jaxrs.internal.client.JaxRsClientInvocationHandler<T>(this, resourceInterface);\r\n    result = (T) java.lang.reflect.Proxy.newProxyInstance(org.restlet.engine.Engine.getInstance().getClassLoader(), new Class<?>[] { ClientProxy.class, resourceInterface }, h);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.util.Series.getValuesArray",
	"Comment": "returns an array of all the values associated to the given parametername.",
	"Method": "String[] getValuesArray(String name,String[] getValuesArray,String name,boolean ignoreCase,String[] getValuesArray,String name,boolean ignoreCase,String defaultValue,String[] getValuesArray,String name,String defaultValue){\r\n    return getValuesArray(name, false, defaultValue);\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.Resolver.findRightSibling",
	"Comment": "finds the right sibling of the left child of a binary operator,skipping parentheses.",
	"Method": "SymTabAST findRightSibling(SymTabAST aLeftChild){\r\n    SymTabAST rightChild = (SymTabAST) (aLeftChild.getNextSibling());\r\n    while ((rightChild != null) && (rightChild.getType() == TokenTypes.RPAREN)) {\r\n        rightChild = (SymTabAST) rightChild.getNextSibling();\r\n    }\r\n    return rightChild;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Collection.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    final AttributesImpl attributes = new AttributesImpl();\r\n    if ((getHref() != null) && (getHref().toString() != null)) {\r\n        attributes.addAttribute(\"\", \"href\", null, \"atomURI\", getHref().toString());\r\n    }\r\n    writer.startElement(APP_NAMESPACE, \"collection\", null, attributes);\r\n    if (getTitle() != null) {\r\n        writer.dataElement(ATOM_NAMESPACE, \"title\", getTitle());\r\n    }\r\n    if (getAccept() != null) {\r\n        StringBuilder sb = new StringBuilder();\r\n        for (MediaType mediaType : getAccept()) {\r\n            if (sb.length() > 0) {\r\n                sb.append(\", \");\r\n            }\r\n            sb.append(mediaType.toString());\r\n        }\r\n        writer.dataElement(APP_NAMESPACE, \"accept\", sb.toString());\r\n    }\r\n    try {\r\n        if (getCategories() != null) {\r\n            getCategories().writeElement(writer);\r\n        }\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n    writer.endElement(APP_NAMESPACE, \"collection\");\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlRepresentation.isExpandingEntityRefs",
	"Comment": "indicates if the parser will expand entity reference nodes. by defaultthe value of this is set to true.",
	"Method": "boolean isExpandingEntityRefs(){\r\n    return expandingEntityRefs;\r\n}"
}, {
	"Path": "org.restlet.engine.header.HeaderReader.reset",
	"Comment": "repositions this stream to the position at the time the markmethod was last called on this input stream.",
	"Method": "void reset(){\r\n    index = mark;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.provider.AbstractProviderWrapper.supportsRead",
	"Comment": "checks, if this messagebodyreader supports the given mediatype.",
	"Method": "boolean supportsRead(Class<?> entityClass,Type genericType,boolean supportsRead,MediaType mediaType){\r\n    boolean result = false;\r\n    for (int i = 0; !result && i < getConsumedMimes().size(); i++) {\r\n        result = getConsumedMimes().get(i).isCompatible(mediaType) || (mediaType == null);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.connection.SslConnection.onFinished",
	"Comment": "notifies that the ssl handshake is finished. application data can now beexchanged.",
	"Method": "void onFinished(){\r\n    isHandshaking = false;\r\n    if (isClientSide()) {\r\n        getInboundWay().setIoState(IoState.IDLE);\r\n        getOutboundWay().setIoState(IoState.INTEREST);\r\n    } else {\r\n        getInboundWay().setIoState(IoState.INTEREST);\r\n        getOutboundWay().setIoState(IoState.IDLE);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.routing.Template.getVariableRegex",
	"Comment": "returns the regex pattern string corresponding to a variable.",
	"Method": "String getVariableRegex(Variable variable){\r\n    String result = null;\r\n    if (variable.isFixed()) {\r\n        result = \"(\" + Pattern.quote(variable.getDefaultValue()) + \")\";\r\n    } else {\r\n        final String ALL = \".\";\r\n        final String ALPHA = \"a-zA-Z\";\r\n        final String DIGIT = \"\\\\d\";\r\n        final String ALPHA_DIGIT = ALPHA + DIGIT;\r\n        final String HEXA = DIGIT + \"ABCDEFabcdef\";\r\n        final String URI_UNRESERVED = ALPHA_DIGIT + \"\\\\-\\\\.\\\\_\\\\~\";\r\n        final String URI_GEN_DELIMS = \"\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@\";\r\n        final String URI_SUB_DELIMS = \"\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=\";\r\n        final String URI_RESERVED = URI_GEN_DELIMS + URI_SUB_DELIMS;\r\n        final String WORD = \"\\\\w\";\r\n        final String CRLF = \"\\\\r\\\\n\";\r\n        final String CTL = \"\\\\p{Cntrl}\";\r\n        final String LWS = CRLF + \"\\\\ \\\\t\";\r\n        final String SEPARATOR = \"\\\\(\\\\)\\\\<\\\\>\\\\@\\\\,\\\\;\\\\:\\\\[\\\\]\\\"\\\\/\\\\\\\\?\\\\=\\\\{\\\\}\\\\ \\\\t\";\r\n        final String TOKEN = \"[^\" + SEPARATOR + \"]\";\r\n        final String COMMENT = \"[^\" + CTL + \"]\" + \"[^\\\\(\\\\)]\" + LWS;\r\n        final String COMMENT_ATTRIBUTE = \"[^\\\\;\\\\(\\\\)]\";\r\n        final String PCT_ENCODED = \"\\\\%[\" + HEXA + \"][\" + HEXA + \"]\";\r\n        final String PCHAR = \"[\" + URI_UNRESERVED + URI_SUB_DELIMS + \"\\\\:\\\\@]|(?:\" + PCT_ENCODED + \")\";\r\n        final String QUERY = PCHAR + \"|\\\\/|\\\\?\";\r\n        final String FRAGMENT = QUERY;\r\n        final String URI_PATH = PCHAR + \"|\\\\/\";\r\n        final String URI_ALL = \"[\" + URI_RESERVED + URI_UNRESERVED + \"]|(?:\" + PCT_ENCODED + \")\";\r\n        final String QUERY_PARAM_DELIMS = \"\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\";\r\n        final String QUERY_PARAM_CHAR = \"[\" + URI_UNRESERVED + QUERY_PARAM_DELIMS + \"\\\\:\\\\@]|(?:\" + PCT_ENCODED + \")\";\r\n        final String QUERY_PARAM = QUERY_PARAM_CHAR + \"|\\\\/|\\\\?\";\r\n        final StringBuilder coreRegex = new StringBuilder();\r\n        switch(variable.getType()) {\r\n            case Variable.TYPE_ALL:\r\n                appendClass(coreRegex, ALL, variable.isRequired());\r\n                break;\r\n            case Variable.TYPE_ALPHA:\r\n                appendClass(coreRegex, ALPHA, variable.isRequired());\r\n                break;\r\n            case Variable.TYPE_DIGIT:\r\n                appendClass(coreRegex, DIGIT, variable.isRequired());\r\n                break;\r\n            case Variable.TYPE_ALPHA_DIGIT:\r\n                appendClass(coreRegex, ALPHA_DIGIT, variable.isRequired());\r\n                break;\r\n            case Variable.TYPE_URI_ALL:\r\n                appendGroup(coreRegex, URI_ALL, variable.isRequired());\r\n                break;\r\n            case Variable.TYPE_URI_UNRESERVED:\r\n                appendClass(coreRegex, URI_UNRESERVED, variable.isRequired());\r\n                break;\r\n            case Variable.TYPE_WORD:\r\n                appendClass(coreRegex, WORD, variable.isRequired());\r\n                break;\r\n            case Variable.TYPE_URI_FRAGMENT:\r\n                appendGroup(coreRegex, FRAGMENT, variable.isRequired());\r\n                break;\r\n            case Variable.TYPE_URI_PATH:\r\n                appendGroup(coreRegex, URI_PATH, variable.isRequired());\r\n                break;\r\n            case Variable.TYPE_URI_QUERY:\r\n                appendGroup(coreRegex, QUERY, variable.isRequired());\r\n                break;\r\n            case Variable.TYPE_URI_QUERY_PARAM:\r\n                appendGroup(coreRegex, QUERY_PARAM, variable.isRequired());\r\n                break;\r\n            case Variable.TYPE_URI_SEGMENT:\r\n                appendGroup(coreRegex, PCHAR, variable.isRequired());\r\n                break;\r\n            case Variable.TYPE_TOKEN:\r\n                appendClass(coreRegex, TOKEN, variable.isRequired());\r\n                break;\r\n            case Variable.TYPE_COMMENT:\r\n                appendClass(coreRegex, COMMENT, variable.isRequired());\r\n                break;\r\n            case Variable.TYPE_COMMENT_ATTRIBUTE:\r\n                appendClass(coreRegex, COMMENT_ATTRIBUTE, variable.isRequired());\r\n                break;\r\n        }\r\n        result = coreRegex.toString();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.ClientConnectionHelper.getProxyPort",
	"Comment": "returns the port of the http proxy, if specified, 3128 otherwise.",
	"Method": "int getProxyPort(){\r\n    String proxyPort = getHelpedParameters().getFirstValue(\"proxyPort\", System.getProperty(\"http.proxyPort\"));\r\n    if (proxyPort == null) {\r\n        proxyPort = \"3128\";\r\n    }\r\n    return Integer.parseInt(proxyPort);\r\n}"
}, {
	"Path": "org.restlet.engine.util.ImmutableDate.setHours",
	"Comment": "as an immutabledate is immutable, this method throws anunsupportedoperationexception exception.",
	"Method": "void setHours(int arg0){\r\n    throw new UnsupportedOperationException(\"ImmutableDate is immutable\");\r\n}"
}, {
	"Path": "org.restlet.ext.sdc.internal.SdcClientCall.getLatch",
	"Comment": "returns the latch that efficiently blocks the calling thread while thecall is tunneled.",
	"Method": "CountDownLatch getLatch(){\r\n    return latch;\r\n}"
}, {
	"Path": "org.restlet.data.CookieSetting.setSecure",
	"Comment": "indicates if cookie should only be transmitted by secure means.",
	"Method": "void setSecure(boolean secure){\r\n    this.secure = secure;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlWriter.forceNSDecls",
	"Comment": "force all namespaces to be declared. this method is used on the rootelement to ensure that the predeclared namespaces all appear.",
	"Method": "void forceNSDecls(){\r\n    for (final String prefix : this.forcedDeclTable.keySet()) {\r\n        doPrefix(prefix, null, true);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jaxb.JaxbRepresentation.setFormattedOutput",
	"Comment": "indicates if the resulting xml data should be formatted with line breaksand indentation.",
	"Method": "void setFormattedOutput(boolean formattedOutput){\r\n    this.formattedOutput = formattedOutput;\r\n}"
}, {
	"Path": "org.restlet.engine.adapter.ServerCall.sendResponse",
	"Comment": "sends the response back to the client. commits the status, headers andoptional entity and send them over the network. the defaultimplementation only writes the response entity on the response stream orchannel. subclasses will probably also copy the response headers andstatus.",
	"Method": "void sendResponse(Response response){\r\n    if (response != null) {\r\n        Representation responseEntity = response.getEntity();\r\n        ConnectorService connectorService = ConnectorHelper.getConnectorService();\r\n        if (connectorService != null) {\r\n            connectorService.beforeSend(responseEntity);\r\n        }\r\n        OutputStream responseEntityStream = null;\r\n        try {\r\n            writeResponseHead(response);\r\n            if (responseEntity != null) {\r\n                responseEntityStream = getResponseEntityStream();\r\n                writeResponseBody(responseEntity, responseEntityStream);\r\n            }\r\n        } finally {\r\n            if (responseEntityStream != null) {\r\n                try {\r\n                    responseEntityStream.flush();\r\n                    responseEntityStream.close();\r\n                } catch (IOException ioe) {\r\n                    getLogger().log(Level.FINE, \"Exception while flushing and closing the entity stream.\", ioe);\r\n                }\r\n            }\r\n            if (responseEntity != null) {\r\n                responseEntity.release();\r\n            }\r\n            if (connectorService != null) {\r\n                connectorService.afterSend(responseEntity);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.service.MetadataService.getEncoding",
	"Comment": "returns the encoding associated to this extension. it returns null if theextension was not declared of it is corresponds to another type ofmedatata such as a media type. if several metadata are associated to thesame extension then only the first matching metadata is returned.",
	"Method": "Encoding getEncoding(String extension){\r\n    return getMetadata(extension, Encoding.class);\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.Graph.getTargetAsReference",
	"Comment": "returns the target reference, either the one given in the targetrefparameter or if it is null, the target reference of the default link.",
	"Method": "Reference getTargetAsReference(Reference targetRef){\r\n    Reference result = targetRef;\r\n    if ((result == null) && (getDefaultLink() != null)) {\r\n        result = getDefaultLink().getTargetAsReference();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.FirewallConfig.addIpAddressesBlackList",
	"Comment": "adds a rule that forbids access to the given set of ip addresses.",
	"Method": "void addIpAddressesBlackList(List<String> blackList){\r\n    add(new FirewallIpFilteringRule(blackList, false));\r\n}"
}, {
	"Path": "org.restlet.security.RoleAuthorizer.setAuthorizedRoles",
	"Comment": "sets the modifiable list of authorized roles. this method clears thecurrent list and adds all entries in the parameter list.",
	"Method": "void setAuthorizedRoles(List<Role> authorizedRoles){\r\n    synchronized (getAuthorizedRoles()) {\r\n        if (authorizedRoles != getAuthorizedRoles()) {\r\n            getAuthorizedRoles().clear();\r\n            if (authorizedRoles != null) {\r\n                getAuthorizedRoles().addAll(authorizedRoles);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.converter.ConverterUtils.getBestHelper",
	"Comment": "returns the best converter helper matching the given parameters.",
	"Method": "ConverterHelper getBestHelper(Object source,Variant target,Resource resource,ConverterHelper getBestHelper,Representation source,Class<T> target,Resource resource){\r\n    ConverterHelper result = null;\r\n    float bestScore = -1.0F;\r\n    float currentScore;\r\n    for (ConverterHelper ch : Engine.getInstance().getRegisteredConverters()) {\r\n        if (ch != null) {\r\n            currentScore = ch.score(source, target, resource);\r\n            if (currentScore > bestScore) {\r\n                bestScore = currentScore;\r\n                result = ch;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.ConnectionHelper.addOutboundMessage",
	"Comment": "add the outbound message to the queue and wake up the io controller.",
	"Method": "void addOutboundMessage(Response response){\r\n    if (Application.getCurrent() != null) {\r\n        response.getAttributes().put(\"org.restlet.application\", Application.getCurrent());\r\n    }\r\n    if (Context.getCurrent() != null) {\r\n        response.getAttributes().put(\"org.restlet.context\", Context.getCurrent());\r\n    }\r\n    if (VirtualHost.getCurrent() != null) {\r\n        response.getAttributes().put(\"org.restlet.virtualHost\", VirtualHost.getCurrent());\r\n    }\r\n    getOutboundMessages().add(response);\r\n    getController().wakeup();\r\n}"
}, {
	"Path": "org.restlet.ext.xdb.internal.ChunkedInputStream.chunkAvailable",
	"Comment": "indicates if a chunk is available or false if a new one needs to beinitialized.",
	"Method": "boolean chunkAvailable(){\r\n    return this.position < this.chunkSize;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.ClassFileSetCheck.extractJavaClasses",
	"Comment": "extracts the javaclasses from .class, .zip, and .jar files.",
	"Method": "Set extractJavaClasses(File[] aFiles,Set extractJavaClasses,File aFile){\r\n    final Set result = new HashSet();\r\n    final String fileName = aFile.getPath();\r\n    if (fileName.endsWith(\".jar\") || fileName.endsWith(\".zip\")) {\r\n        final ZipFile zipFile = new ZipFile(fileName);\r\n        final Enumeration entries = zipFile.entries();\r\n        while (entries.hasMoreElements()) {\r\n            final ZipEntry entry = (ZipEntry) entries.nextElement();\r\n            final String entryName = entry.getName();\r\n            if (entryName.endsWith(\".class\")) {\r\n                final InputStream in = zipFile.getInputStream(entry);\r\n                final JavaClass javaClass = new ClassParser(in, entryName).parse();\r\n                result.add(javaClass);\r\n            }\r\n        }\r\n    } else {\r\n        final JavaClass javaClass = new ClassParser(fileName).parse();\r\n        result.add(javaClass);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.resource.ServerResource.isConditional",
	"Comment": "indicates if conditional handling is enabled. the default value is true.",
	"Method": "boolean isConditional(){\r\n    return conditional;\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipResponse.setMimeVersion",
	"Comment": "sets the version of the mime protocol used to construct the message.",
	"Method": "void setMimeVersion(String mimeVersion){\r\n    this.mimeVersion = mimeVersion;\r\n}"
}, {
	"Path": "org.restlet.data.ClientInfo.getFrom",
	"Comment": "returns the email address of the human user controlling the user agent.default value is null.",
	"Method": "String getFrom(){\r\n    return from;\r\n}"
}, {
	"Path": "org.restlet.engine.adapter.ServerCall.writeResponseBody",
	"Comment": "effectively writes the response body. the entity to write is guaranteedto be non null. attempts to write the entity on the response channel orresponse stream by default.",
	"Method": "void writeResponseBody(Representation entity,OutputStream responseEntityStream){\r\n    if (responseEntityStream != null) {\r\n        entity.write(responseEntityStream);\r\n        responseEntityStream.flush();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.engine.util.InternetDateFormat.valueOf",
	"Comment": "creates a new internetdateformat object from the specified millisecondtime value using the specified time zone.",
	"Method": "InternetDateFormat valueOf(Date date,InternetDateFormat valueOf,Date date,TimeZone zone,InternetDateFormat valueOf,long time,InternetDateFormat valueOf,long time,TimeZone zone,InternetDateFormat valueOf,String s){\r\n    return new InternetDateFormat(s);\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.TableMaker.getPackage",
	"Comment": "gets the package determined by the tree and parent package def.the method analyzes the tree and parent scope and retrieves theappropriate package definition from the internal package list.if the package does not exist it is created.",
	"Method": "PackageDef getPackage(Scope parent,SymTabAST tree,ExternalPackage getPackage,String packageName){\r\n    String name = tree.getText();\r\n    PackageDef result = null;\r\n    if (!(parent instanceof BaseScope)) {\r\n        result = symbolTable.getPackage(parent.getQualifiedName() + \".\" + name);\r\n    } else {\r\n        result = symbolTable.getPackage(name);\r\n    }\r\n    if (result == null) {\r\n        result = new PackageDef(tree.getText(), parent, tree);\r\n        symbolTable.definePackage(result, parent);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.internal.xml.ContentReader.getLiteral",
	"Comment": "returns a literal object according to the given parameters.",
	"Method": "Literal getLiteral(String value,String datatype,Language language){\r\n    Literal literal = new Literal(value);\r\n    if (datatype != null) {\r\n        literal.setDatatypeRef(new Reference(datatype));\r\n    }\r\n    if (language != null) {\r\n        literal.setLanguage(language);\r\n    }\r\n    return literal;\r\n}"
}, {
	"Path": "org.restlet.security.ConfidentialAuthorizer.authorize",
	"Comment": "authorizes the request only if its method is one of the authorizedmethods.",
	"Method": "boolean authorize(Request request,Response response){\r\n    return request.isConfidential();\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.ApiSparkService.setAgentCellVersion",
	"Comment": "sets the identifier of the cell version configured on the apisparkplatform for your application.",
	"Method": "void setAgentCellVersion(Integer agentCellVersion){\r\n    this.agentCellVersion = agentCellVersion;\r\n}"
}, {
	"Path": "org.restlet.test.data.ReferenceTestCase.testParentRef",
	"Comment": "test the computation of parent references, for absolute and relativeuris.",
	"Method": "void testParentRef(){\r\n    Reference baseRef = new Reference(\"http://test.com/foo/bar\");\r\n    Reference parentRef = baseRef.getParentRef();\r\n    assertEquals(\"http://test.com/foo/\", parentRef.toString());\r\n    baseRef = new Reference(\"/foo/bar\");\r\n    parentRef = baseRef.getParentRef();\r\n    assertEquals(\"/foo/\", parentRef.toString());\r\n}"
}, {
	"Path": "org.restlet.Component.setRealms",
	"Comment": "sets the list of realms. this method clears the current list and adds allentries in the parameter list.",
	"Method": "void setRealms(List<Realm> realms){\r\n    synchronized (getRealms()) {\r\n        if (realms != getRealms()) {\r\n            getRealms().clear();\r\n            if (realms != null) {\r\n                getRealms().addAll(realms);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.conversion.raml.RamlUtils.validate",
	"Comment": "indicates if the given raml definition is valid according to ramlspecifications.",
	"Method": "List<ValidationResult> validate(String location){\r\n    return RamlValidationService.createDefault().validate(location);\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.Introspector.main",
	"Comment": "main class, invokes this class without argument to get help instructions.",
	"Method": "void main(String[] args){\r\n    try {\r\n        process(args);\r\n    } catch (Exception e) {\r\n        LOGGER.log(Level.SEVERE, \"Introspection error\", e);\r\n        System.exit(1);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.util.Series.unmodifiableSeries",
	"Comment": "returns an unmodifiable view of the specified series. attempts to call amodification method will throw an unsupportedoperationexception.",
	"Method": "Series<? extends NamedValue> unmodifiableSeries(Series<? extends NamedValue> series){\r\n    return new Series(series.entryClass, java.util.Collections.unmodifiableList(series.getDelegate()));\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.provider.WebAppExcMapper.requestOtherVariants",
	"Comment": "creates an entity with a list of links to the supported variants.",
	"Method": "Response requestOtherVariants(Collection<Variant> supportedVariants,Response response){\r\n    if ((supportedVariants != null) && supportedVariants.isEmpty()) {\r\n        supportedVariants = null;\r\n    }\r\n    final ResponseBuilder rb = Response.fromResponse(response);\r\n    boolean xhtml = false;\r\n    boolean html = this.httpHeaders.getAcceptableMediaTypes().contains(MediaType.TEXT_HTML_TYPE);\r\n    if (!html) {\r\n        xhtml = this.httpHeaders.getAcceptableMediaTypes().contains(MediaType.APPLICATION_XHTML_XML_TYPE);\r\n        html = xhtml;\r\n    }\r\n    final StringBuilder stb = new StringBuilder();\r\n    if (html) {\r\n        stb.append(\"<html><head>\\n\");\r\n        stb.append(\"<title>The requested variant is not available<\/title>\");\r\n        stb.append(\"\\n<\/head>\\n<body>\\n<p>\\n\");\r\n    }\r\n    stb.append(\"The requested variant is not available.\");\r\n    if (supportedVariants != null) {\r\n        stb.append(\" Try one of the following:\\n\");\r\n        if (html) {\r\n            stb.append(\"<\/p><ul>\");\r\n        }\r\n        stb.append(\"\\n\");\r\n        for (final Variant variant : supportedVariants) {\r\n            final ExtendedUriBuilder uriBuilder = this.uriInfo.getRequestUriBuilder();\r\n            final boolean added = addExtensions(uriBuilder, variant);\r\n            if (!added) {\r\n                continue;\r\n            }\r\n            final String uri = uriBuilder.build().toString();\r\n            if (html) {\r\n                stb.append(\"<li><a href=\\\"\");\r\n            } else {\r\n                stb.append(\"* \");\r\n            }\r\n            stb.append(uri);\r\n            if (html) {\r\n                stb.append(\"\\\">\");\r\n                stb.append(uri);\r\n                stb.append(\"<\/a><\/li>\");\r\n            }\r\n            stb.append(\"\\n\");\r\n        }\r\n        if (html) {\r\n            stb.append(\"<\/ul>\");\r\n        }\r\n    }\r\n    if (html) {\r\n        stb.append(\"<\/body><\/html>\");\r\n    }\r\n    rb.entity(stb);\r\n    if (xhtml) {\r\n        rb.type(MediaType.APPLICATION_XHTML_XML_TYPE);\r\n    } else if (html) {\r\n        rb.type(MediaType.TEXT_HTML_TYPE);\r\n    } else {\r\n        rb.type(MediaType.TEXT_PLAIN_TYPE);\r\n    }\r\n    return rb.build();\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.DigestAuthenticator.setWrappedAlgorithm",
	"Comment": "sets the digest algorithm of secrets returned by the wrapped verifier.the secrets from the wrapped verifier are the ones used by the verifierto compare those sent by clients when attempting to authenticate.",
	"Method": "void setWrappedAlgorithm(String wrappedAlgorithm){\r\n    getVerifier().setWrappedAlgorithm(wrappedAlgorithm);\r\n}"
}, {
	"Path": "org.restlet.engine.local.FileClientHelper.checkExtensionsConsistency",
	"Comment": "check that all extensions of the file correspond to a known metadata.",
	"Method": "boolean checkExtensionsConsistency(File file){\r\n    boolean knownExtension = true;\r\n    Collection<String> set = Entity.getExtensions(file.getName(), getMetadataService());\r\n    Iterator<String> iterator = set.iterator();\r\n    while (iterator.hasNext() && knownExtension) {\r\n        knownExtension = getMetadataService().getMetadata(iterator.next()) != null;\r\n    }\r\n    return knownExtension;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.channel.ReadableTraceChannel.read",
	"Comment": "reads the available byte from the wrapped channel to the destinationbuffer while writing them to the console.",
	"Method": "int read(ByteBuffer dst){\r\n    int off = dst.arrayOffset() + dst.position();\r\n    int oldPos = dst.position();\r\n    int result = getWrappedChannel().read(dst);\r\n    int newPos = dst.position();\r\n    if (newPos > oldPos) {\r\n        System.out.write(dst.array(), off, newPos - oldPos);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Service.invokeSimple",
	"Comment": "invokes a service operation and return the string value sent back by theservice.",
	"Method": "String invokeSimple(String service,Series<Parameter> parameters){\r\n    return getSimpleValue(invokeComplex(service, parameters), service);\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.Resolver.resolveParameters",
	"Comment": "resolves the types found in a method call. any references foundin the process are created.returns a methodsignature forthe types of the parameters.",
	"Method": "MethodSignature resolveParameters(SymTabAST elist,Scope location,IClass context,boolean referencePhase){\r\n    Vector parameters = new Vector();\r\n    SymTabAST expr = (SymTabAST) (elist.getFirstChild());\r\n    while (expr != null) {\r\n        if (expr.getType() != TokenTypes.COMMA) {\r\n            IClass parameter = resolveExpression((SymTabAST) (expr.getFirstChild()), location, context, referencePhase);\r\n            parameters.add(parameter);\r\n        }\r\n        expr = (SymTabAST) (expr.getNextSibling());\r\n    }\r\n    return new MethodSignature(parameters);\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.introspection.util.Types.convertPrimitiveType",
	"Comment": "returns simple type name for primitive type or full name otherwise",
	"Method": "String convertPrimitiveType(Class<?> type){\r\n    String primitiveName = primitiveTypesByClass.get(type);\r\n    if (primitiveName != null) {\r\n        return primitiveName;\r\n    }\r\n    if (CharSequence.class.isAssignableFrom(type)) {\r\n        return \"string\";\r\n    }\r\n    if (Date.class.isAssignableFrom(type)) {\r\n        return \"date\";\r\n    }\r\n    if (Representation.class.isAssignableFrom(type) || File.class.isAssignableFrom(type)) {\r\n        return \"file\";\r\n    }\r\n    return type.getSimpleName();\r\n}"
}, {
	"Path": "org.restlet.data.ChallengeResponse.getServerNounceCountAsHex",
	"Comment": "returns the server nonce count as an hexadecimal string of eightcharacters.",
	"Method": "String getServerNounceCountAsHex(){\r\n    return org.restlet.engine.security.AuthenticatorUtils.formatNonceCount(getServerNounceCount());\r\n}"
}, {
	"Path": "org.restlet.ext.html.internal.FormUtils.getEntry",
	"Comment": "reads the entries with the given name.if multiple values are found, a list is returned created.",
	"Method": "Object getEntry(Representation form,String name,Object getEntry,String query,String name,CharacterSet characterSet,char separator){\r\n    return new FormReader(query, characterSet, separator).readEntry(name);\r\n}"
}, {
	"Path": "org.restlet.routing.Router.getMaxAttempts",
	"Comment": "returns the maximum number of attempts if no attachment could be matchedon the first attempt. this is useful when the attachment scoring isdynamic and therefore could change on a retry. the default value is setto 1.",
	"Method": "int getMaxAttempts(){\r\n    return this.maxAttempts;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Query.guessType",
	"Comment": "tries to deduce the type of the query based on the analysis of the targeturi, and returns it.",
	"Method": "int guessType(String targetUri){\r\n    String uri = targetUri;\r\n    int index = targetUri.indexOf(\"?\");\r\n    if (index != -1) {\r\n        uri = uri.substring(0, index);\r\n    }\r\n    int type = TYPE_UNKNOWN;\r\n    String entitySet = \"{service}.svc/{entitySet}\";\r\n    String entity = entitySet + \"({keyPredicate})\";\r\n    Template t = new Template(entity, Template.MODE_EQUALS);\r\n    t.getVariables().put(\"entitySet\", new Variable(Variable.TYPE_ALL, \"\", true, false));\r\n    t.getVariables().put(\"keyPredicate\", new Variable(Variable.TYPE_ALL, \"\", true, false));\r\n    if (t.match(uri) != -1) {\r\n        return TYPE_ENTITY;\r\n    }\r\n    t.setPattern(entitySet);\r\n    if (t.match(uri) != -1) {\r\n        return TYPE_ENTITY_SET;\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "org.restlet.engine.application.StatusFilter.setOverwriting",
	"Comment": "indicates if existing representations should be overwritten.",
	"Method": "void setOverwriting(boolean overwriting){\r\n    this.overwriting = overwriting;\r\n}"
}, {
	"Path": "org.restlet.engine.io.InputStreamChannel.read",
	"Comment": "reads bytes from the underlying stream to the target buffer.",
	"Method": "int read(ByteBuffer target,int read,ByteBuffer target,int readLength){\r\n    int result = 0;\r\n    if (target.hasArray()) {\r\n        byte[] byteArray = target.array();\r\n        result = getInputStream().read(byteArray, target.position(), Math.min(readLength, target.remaining()));\r\n        if (result > 0) {\r\n            target.position(target.position() + result);\r\n        }\r\n    } else {\r\n        if (this.buffer.length < IoUtils.BUFFER_SIZE) {\r\n            this.buffer = new byte[IoUtils.BUFFER_SIZE];\r\n        }\r\n        result = getInputStream().read(this.buffer, 0, Math.min(Math.min(readLength, IoUtils.BUFFER_SIZE), target.remaining()));\r\n        if (result > 0) {\r\n            target.put(buffer, 0, result);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.RdfRepresentation.createWriter",
	"Comment": "returns an instance of a graph handler used when writing the inner set oflinks.",
	"Method": "GraphHandler createWriter(MediaType mediaType,Writer writer){\r\n    if (MediaType.TEXT_RDF_N3.equals(getMediaType())) {\r\n        return new RdfN3Writer(writer);\r\n    } else if (MediaType.TEXT_XML.equals(getMediaType())) {\r\n        return new RdfXmlWriter(writer);\r\n    } else if (MediaType.APPLICATION_ALL_XML.includes(getMediaType())) {\r\n        return new RdfXmlWriter(writer);\r\n    } else if (MediaType.TEXT_PLAIN.equals(getMediaType())) {\r\n        return new RdfNTriplesWriter(writer);\r\n    } else if (MediaType.TEXT_RDF_NTRIPLES.equals(getMediaType())) {\r\n        return new RdfNTriplesWriter(writer);\r\n    } else if (MediaType.TEXT_TURTLE.equals(getMediaType())) {\r\n        return new RdfTurtleWriter(writer);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.representation.Variant.isCompatible",
	"Comment": "indicates if the current variant is compatible with the given variant.",
	"Method": "boolean isCompatible(Variant other){\r\n    return (other != null) && (includes(other) || other.includes(this));\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Workspace.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    writer.startElement(APP_NAMESPACE, \"workspace\");\r\n    if (getTitle() != null) {\r\n        writer.dataElement(ATOM_NAMESPACE, \"title\", getTitle());\r\n    }\r\n    for (final Collection collection : getCollections()) {\r\n        collection.writeElement(writer);\r\n    }\r\n    writer.endElement(APP_NAMESPACE, \"workspace\");\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.internal.JettyServerCall.getServerAddress",
	"Comment": "returns the response address.corresponds to the ip address of the responding server.",
	"Method": "String getServerAddress(){\r\n    return getChannel().getRequest().getLocalAddr();\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.ResponseInfo.getStatuses",
	"Comment": "returns the list of statuses associated with this responserepresentation.",
	"Method": "List<Status> getStatuses(){\r\n    List<Status> s = this.statuses;\r\n    if (s == null) {\r\n        synchronized (this) {\r\n            s = this.statuses;\r\n            if (s == null) {\r\n                this.statuses = s = new ArrayList<Status>();\r\n            }\r\n        }\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.provider.SingletonProvider.isReadable",
	"Comment": "checks, if this messagebodyreader could read the given type.",
	"Method": "boolean isReadable(Class<?> type,Type genericType,Annotation[] annotations,javax.ws.rs.core.MediaType mediaType){\r\n    try {\r\n        return this.getJaxRsReader().isReadable(type, genericType, annotations, mediaType);\r\n    } catch (NullPointerException e) {\r\n        if (genericType == null || annotations == null) {\r\n            return false;\r\n        }\r\n        throw e;\r\n    } catch (IllegalArgumentException e) {\r\n        if (genericType == null || annotations == null) {\r\n            return false;\r\n        }\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Source.setLogo",
	"Comment": "sets the image that provides visual identification for a feed.",
	"Method": "void setLogo(Reference logo){\r\n    this.logo = logo;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.Resolver.handleVariable",
	"Comment": "processes a variable definition and resolves references in it",
	"Method": "void handleVariable(VariableDef variable){\r\n    SymTabAST node = variable.getTreeNode();\r\n    Scope location = variable.getParentScope();\r\n    SymTabAST nameNode = node.findFirstToken(TokenTypes.IDENT);\r\n    nameNode.setDefinition(variable, location, true);\r\n    SymTabAST typeNode = node.findFirstToken(TokenTypes.TYPE);\r\n    resolveType(typeNode, location, null, true);\r\n    SymTabAST assignmentNode = node.findFirstToken(TokenTypes.ASSIGN);\r\n    if (assignmentNode != null) {\r\n        resolveExpression((SymTabAST) (assignmentNode.getFirstChild()), variable.getParentScope(), null, true);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.Context.setParameters",
	"Comment": "sets the modifiable series of parameters. this method clears the currentseries and adds all entries in the parameter series.",
	"Method": "void setParameters(Series<Parameter> parameters){\r\n    synchronized (getParameters()) {\r\n        if (parameters != getParameters()) {\r\n            getParameters().clear();\r\n            if (parameters != null) {\r\n                getParameters().addAll(parameters);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.toEdmByte",
	"Comment": "convert the given value to the string representation of a edm byte value.",
	"Method": "String toEdmByte(byte value){\r\n    return Byte.toString(value);\r\n}"
}, {
	"Path": "org.restlet.ext.spring.SpringComponent.setServer",
	"Comment": "adds a server to the list of connectors. the value can be either aprotocol name, a protocol instance or a server instance.",
	"Method": "void setServer(Object serverInfo){\r\n    final List<Object> servers = new ArrayList<Object>();\r\n    servers.add(serverInfo);\r\n    setServersList(servers);\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getRemainingPart",
	"Comment": "returns the optionally decoded remaining part with or without the querypart of the reference.",
	"Method": "String getRemainingPart(String getRemainingPart,boolean decode,String getRemainingPart,boolean decode,boolean query){\r\n    String result = null;\r\n    final String all = toString(query, false);\r\n    if (getBaseRef() != null) {\r\n        final String base = getBaseRef().toString(query, false);\r\n        if ((base != null) && all.startsWith(base)) {\r\n            result = all.substring(base.length());\r\n        }\r\n    } else {\r\n        result = all;\r\n    }\r\n    return decode ? decode(result) : result;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxb.JaxbRepresentation.setFragment",
	"Comment": "indicates whether or not document level events will be generated by themarshaller.",
	"Method": "void setFragment(boolean fragment){\r\n    this.fragment = fragment;\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.DigestVerifier.getAlgorithm",
	"Comment": "returns the digest algorithm of provided secrets. provided secrets arethe ones sent by clients when attempting to authenticate.",
	"Method": "String getAlgorithm(){\r\n    return algorithm;\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getIdentifier",
	"Comment": "returns the optionnally decoded absolute resource identifier.",
	"Method": "String getIdentifier(String getIdentifier,boolean decode){\r\n    return decode ? decode(getIdentifier()) : getIdentifier();\r\n}"
}, {
	"Path": "org.restlet.ext.sip.internal.ContactInfoWriter.appendQuality",
	"Comment": "formats a quality value.if the quality is invalid, an illegalargumentexception is thrown.",
	"Method": "ContactInfoWriter appendQuality(float quality){\r\n    if (!PreferenceWriter.isValidQuality(quality)) {\r\n        throw new IllegalArgumentException(\"Invalid quality value detected. Value must be between 0 and 1.\");\r\n    }\r\n    java.text.NumberFormat formatter = java.text.NumberFormat.getNumberInstance(java.util.Locale.US);\r\n    formatter.setMaximumFractionDigits(2);\r\n    append(formatter.format(quality));\r\n    return this;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Query.iterator",
	"Comment": "returns an iterator over a set of elements of type t. it returns null ifthe query does not retrieve elements.",
	"Method": "Iterator<T> iterator(){\r\n    Iterator<T> result = null;\r\n    try {\r\n        execute();\r\n        result = entities.iterator();\r\n        setNextPage(null);\r\n        for (Link link : getFeed().getLinks()) {\r\n            if (Relation.NEXT.equals(link.getRel())) {\r\n                setNextPage(link.getHref());\r\n                break;\r\n            }\r\n        }\r\n        if (getNextPage() != null) {\r\n            result = new EntryIterator<T>(this.service, result, getNextPage(), entityClass);\r\n        }\r\n    } catch (Exception e) {\r\n        getLogger().log(Level.WARNING, \"Can't parse the content of \" + createTargetUri(), e);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.resource.AnnotationInfo.equals",
	"Comment": "indicates if the current variant is equal to the given object.",
	"Method": "boolean equals(Object other){\r\n    if (other == this) {\r\n        return true;\r\n    }\r\n    if (!(other instanceof AnnotationInfo)) {\r\n        return false;\r\n    }\r\n    AnnotationInfo that = (AnnotationInfo) other;\r\n    return Objects.equals(getJavaMethod(), that.getJavaMethod()) && Objects.equals(getJavaClass(), that.getJavaClass()) && Objects.equals(getAnnotationValue(), that.getAnnotationValue());\r\n}"
}, {
	"Path": "org.restlet.ext.nio.BaseHelper.getMaxThreadIdleTimeMs",
	"Comment": "returns the time for an idle thread to wait for an operation before beingcollected.",
	"Method": "int getMaxThreadIdleTimeMs(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"maxThreadIdleTimeMs\", \"300000\"));\r\n}"
}, {
	"Path": "org.restlet.ext.jetty.HttpClientHelper.getAddressResolutionTimeout",
	"Comment": "the timeout in milliseconds for the dns resolution of host addresses.defaults to 15000.",
	"Method": "long getAddressResolutionTimeout(){\r\n    return Long.parseLong(getHelpedParameters().getFirstValue(\"addressResolutionTimeout\", \"15000\"));\r\n}"
}, {
	"Path": "org.restlet.ext.raml.RamlSpecificationRestlet.getRaml",
	"Comment": "returns the representation of the whole resource listing of theapplication.",
	"Method": "Representation getRaml(){\r\n    return new StringRepresentation(new RamlEmitter().dump(RamlTranslator.getRaml(getDefinition())), MediaType.TEXT_PLAIN);\r\n}"
}, {
	"Path": "org.restlet.engine.application.StrictConneg.scoreMetadata",
	"Comment": "scores a metadata relatively to enriched client preferences.",
	"Method": "float scoreMetadata(List<T> metadataList,List<Preference<T>> prefs,float scoreMetadata,T metadata,List<Preference<T>> prefs){\r\n    float result = -1.0F;\r\n    float current;\r\n    if (metadata != null) {\r\n        for (Preference<? extends Metadata> pref : prefs) {\r\n            if (pref.getMetadata().includes(metadata)) {\r\n                current = pref.getQuality();\r\n            } else {\r\n                current = -1.0F;\r\n            }\r\n            if (current > result) {\r\n                result = current;\r\n            }\r\n        }\r\n    } else {\r\n        result = 0.0F;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.Graph.getTargetAsLiteral",
	"Comment": "returns the target literal, either the one given in the targetlitparameter or if it is null, the target literal of the default link.",
	"Method": "Literal getTargetAsLiteral(Literal targetLit){\r\n    Literal result = targetLit;\r\n    if ((result == null) && (getDefaultLink() != null)) {\r\n        result = getDefaultLink().getTargetAsLiteral();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.adapter.Call.isKeepAlive",
	"Comment": "indicates if both the client and the server want a persistent connection.",
	"Method": "boolean isKeepAlive(){\r\n    return isClientKeepAlive() && isServerKeepAlive();\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.QueryEngine.getReferences",
	"Comment": "gets a collection of references determined by a symbol and location",
	"Method": "Iterator getReferences(String name,Occurrence location,Iterator getReferences,Occurrence location){\r\n    Iterator result = null;\r\n    SymTabAST node = getWordNodeAtOccurrence(location);\r\n    if (node != null && node.getDefinition() != null) {\r\n        result = node.getDefinition().getReferences();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.data.ChallengeRequest.setDomainRefs",
	"Comment": "sets the uri references that define the protection domains for the digestauthentication.",
	"Method": "void setDomainRefs(List<Reference> domainRefs){\r\n    this.domainRefs = domainRefs;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.connection.Connection.isPersistent",
	"Comment": "indicates if the connection should be persisted across calls.",
	"Method": "boolean isPersistent(){\r\n    return persistent;\r\n}"
}, {
	"Path": "org.restlet.engine.adapter.Call.getClientAddress",
	"Comment": "returns the client address.corresponds to the ip address of the requesting client.",
	"Method": "String getClientAddress(){\r\n    return this.clientAddress;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Service.getMaxClientVersion",
	"Comment": "returns the maximum version of the odata protocol extensions the clientcan accept in a response.",
	"Method": "String getMaxClientVersion(){\r\n    return maxClientVersion;\r\n}"
}, {
	"Path": "org.restlet.data.Status.valueOf",
	"Comment": "returns the status associated to a code. if an existing constant existsthen it is returned, otherwise a new instance is created.",
	"Method": "Status valueOf(int code){\r\n    switch(code) {\r\n        case 100:\r\n            return INFO_CONTINUE;\r\n        case 101:\r\n            return INFO_SWITCHING_PROTOCOL;\r\n        case 102:\r\n            return INFO_PROCESSING;\r\n        case 110:\r\n            return INFO_STALE_RESPONSE;\r\n        case 111:\r\n            return INFO_REVALIDATION_FAILED;\r\n        case 112:\r\n            return INFO_DISCONNECTED_OPERATION;\r\n        case 113:\r\n            return INFO_HEURISTIC_EXPIRATION;\r\n        case 199:\r\n            return INFO_MISC_WARNING;\r\n        case 200:\r\n            return SUCCESS_OK;\r\n        case 201:\r\n            return SUCCESS_CREATED;\r\n        case 202:\r\n            return SUCCESS_ACCEPTED;\r\n        case 203:\r\n            return SUCCESS_NON_AUTHORITATIVE;\r\n        case 204:\r\n            return SUCCESS_NO_CONTENT;\r\n        case 205:\r\n            return SUCCESS_RESET_CONTENT;\r\n        case 206:\r\n            return SUCCESS_PARTIAL_CONTENT;\r\n        case 207:\r\n            return SUCCESS_MULTI_STATUS;\r\n        case 214:\r\n            return SUCCESS_TRANSFORMATION_APPLIED;\r\n        case 299:\r\n            return SUCCESS_MISC_PERSISTENT_WARNING;\r\n        case 300:\r\n            return REDIRECTION_MULTIPLE_CHOICES;\r\n        case 301:\r\n            return REDIRECTION_PERMANENT;\r\n        case 302:\r\n            return REDIRECTION_FOUND;\r\n        case 303:\r\n            return REDIRECTION_SEE_OTHER;\r\n        case 304:\r\n            return REDIRECTION_NOT_MODIFIED;\r\n        case 305:\r\n            return REDIRECTION_USE_PROXY;\r\n        case 307:\r\n            return REDIRECTION_TEMPORARY;\r\n        case 400:\r\n            return CLIENT_ERROR_BAD_REQUEST;\r\n        case 401:\r\n            return CLIENT_ERROR_UNAUTHORIZED;\r\n        case 402:\r\n            return CLIENT_ERROR_PAYMENT_REQUIRED;\r\n        case 403:\r\n            return CLIENT_ERROR_FORBIDDEN;\r\n        case 404:\r\n            return CLIENT_ERROR_NOT_FOUND;\r\n        case 405:\r\n            return CLIENT_ERROR_METHOD_NOT_ALLOWED;\r\n        case 406:\r\n            return CLIENT_ERROR_NOT_ACCEPTABLE;\r\n        case 407:\r\n            return CLIENT_ERROR_PROXY_AUTHENTIFICATION_REQUIRED;\r\n        case 408:\r\n            return CLIENT_ERROR_REQUEST_TIMEOUT;\r\n        case 409:\r\n            return CLIENT_ERROR_CONFLICT;\r\n        case 410:\r\n            return CLIENT_ERROR_GONE;\r\n        case 411:\r\n            return CLIENT_ERROR_LENGTH_REQUIRED;\r\n        case 412:\r\n            return CLIENT_ERROR_PRECONDITION_FAILED;\r\n        case 413:\r\n            return CLIENT_ERROR_REQUEST_ENTITY_TOO_LARGE;\r\n        case 414:\r\n            return CLIENT_ERROR_REQUEST_URI_TOO_LONG;\r\n        case 415:\r\n            return CLIENT_ERROR_UNSUPPORTED_MEDIA_TYPE;\r\n        case 416:\r\n            return CLIENT_ERROR_REQUESTED_RANGE_NOT_SATISFIABLE;\r\n        case 417:\r\n            return CLIENT_ERROR_EXPECTATION_FAILED;\r\n        case 422:\r\n            return CLIENT_ERROR_UNPROCESSABLE_ENTITY;\r\n        case 423:\r\n            return CLIENT_ERROR_LOCKED;\r\n        case 424:\r\n            return CLIENT_ERROR_FAILED_DEPENDENCY;\r\n        case 429:\r\n            return CLIENT_ERROR_TOO_MANY_REQUESTS;\r\n        case 500:\r\n            return SERVER_ERROR_INTERNAL;\r\n        case 501:\r\n            return SERVER_ERROR_NOT_IMPLEMENTED;\r\n        case 502:\r\n            return SERVER_ERROR_BAD_GATEWAY;\r\n        case 503:\r\n            return SERVER_ERROR_SERVICE_UNAVAILABLE;\r\n        case 504:\r\n            return SERVER_ERROR_GATEWAY_TIMEOUT;\r\n        case 505:\r\n            return SERVER_ERROR_VERSION_NOT_SUPPORTED;\r\n        case 507:\r\n            return SERVER_ERROR_INSUFFICIENT_STORAGE;\r\n        case 1000:\r\n            return CONNECTOR_ERROR_CONNECTION;\r\n        case 1001:\r\n            return CONNECTOR_ERROR_COMMUNICATION;\r\n        case 1002:\r\n            return CONNECTOR_ERROR_INTERNAL;\r\n        default:\r\n            return new Status(code);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Feed.getRights",
	"Comment": "returns the information about rights held in and over an feed.",
	"Method": "Text getRights(){\r\n    return this.rights;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Feed.getUpdated",
	"Comment": "returns the most recent moment when the entry was modified in asignificant way.",
	"Method": "Date getUpdated(){\r\n    return this.updated;\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getScheme",
	"Comment": "returns the scheme component.note that no uri decoding is done by this method.",
	"Method": "String getScheme(String getScheme,boolean decode){\r\n    return decode ? decode(getScheme()) : getScheme();\r\n}"
}, {
	"Path": "org.restlet.engine.converter.ConverterHelper.getVariants",
	"Comment": "returns the list of variants that can be converted from a given objectclass by a specific converter helper.",
	"Method": "List<VariantInfo> getVariants(Class<?> source,List<VariantInfo> getVariants,Class<?> sourceClass,Variant targetVariant){\r\n    return addVariants(sourceClass, targetVariant, null);\r\n}"
}, {
	"Path": "org.restlet.ext.xdb.internal.XdbServletCall.sendResponse",
	"Comment": "sends the response back to the client. commits the status, headers andoptional entity and send them on the network.",
	"Method": "void sendResponse(Response response){\r\n    Header header;\r\n    for (Iterator<Header> iter = getResponseHeaders().iterator(); iter.hasNext(); ) {\r\n        header = iter.next();\r\n        getResponse().addHeader(header.getName(), header.getValue());\r\n    }\r\n    if (Status.isError(getStatusCode()) && (response == null)) {\r\n        try {\r\n            getResponse().sendError(getStatusCode(), getReasonPhrase());\r\n        } catch (IOException ioe) {\r\n            getLogger().log(Level.WARNING, \"Unable to set the response error status\", ioe);\r\n        }\r\n    } else {\r\n        getResponse().setStatus(getStatusCode());\r\n        super.sendResponse(response);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.CookieAuthenticator.setEncryptAlgorithm",
	"Comment": "sets the name of the algorithm used to encrypt the log info cookie value.",
	"Method": "void setEncryptAlgorithm(String secretAlgorithm){\r\n    this.encryptAlgorithm = secretAlgorithm;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxb.JaxbRepresentation.isExpandingEntityRefs",
	"Comment": "indicates if the parser will expand entity reference nodes. by defaultthe value of this is set to true.",
	"Method": "boolean isExpandingEntityRefs(){\r\n    return expandingEntityRefs;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.BaseHelper.getThrottleTimeMs",
	"Comment": "returns the time to wait between socket write operations in milliseconds.can prevent tcp buffer overflows.",
	"Method": "int getThrottleTimeMs(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"throttleTimeMs\", \"0\"));\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipRequest.setRecordedRoutes",
	"Comment": "sets the list of routes completed by proxies to force future requests togo through the proxy.",
	"Method": "void setRecordedRoutes(List<Address> recordedRoutes){\r\n    this.recordedRoutes = recordedRoutes;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.EntityContainer.setDefaultEntityContainer",
	"Comment": "indicates if this container is the default one for a wcf data service.",
	"Method": "void setDefaultEntityContainer(boolean defaultEntityContainer){\r\n    this.defaultEntityContainer = defaultEntityContainer;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Source.getLogo",
	"Comment": "returns the image that provides visual identification for a feed.",
	"Method": "Reference getLogo(){\r\n    return this.logo;\r\n}"
}, {
	"Path": "org.restlet.engine.Engine.createThreadWithLocalVariables",
	"Comment": "creates a new standalone thread with local restlet thread variableproperly set.",
	"Method": "Thread createThreadWithLocalVariables(Runnable runnable,String name){\r\n    final org.restlet.Application currentApplication = org.restlet.Application.getCurrent();\r\n    final Context currentContext = Context.getCurrent();\r\n    final Integer currentVirtualHost = org.restlet.routing.VirtualHost.getCurrent();\r\n    final Response currentResponse = Response.getCurrent();\r\n    Runnable r = new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            Response.setCurrent(currentResponse);\r\n            Context.setCurrent(currentContext);\r\n            org.restlet.routing.VirtualHost.setCurrent(currentVirtualHost);\r\n            org.restlet.Application.setCurrent(currentApplication);\r\n            try {\r\n                runnable.run();\r\n            } finally {\r\n                Engine.clearThreadLocalVariables();\r\n            }\r\n        }\r\n    };\r\n    return new Thread(r, name);\r\n}"
}, {
	"Path": "org.restlet.engine.Engine.createThreadWithLocalVariables",
	"Comment": "creates a new standalone thread with local restlet thread variableproperly set.",
	"Method": "Thread createThreadWithLocalVariables(Runnable runnable,String name){\r\n    Response.setCurrent(currentResponse);\r\n    Context.setCurrent(currentContext);\r\n    org.restlet.routing.VirtualHost.setCurrent(currentVirtualHost);\r\n    org.restlet.Application.setCurrent(currentApplication);\r\n    try {\r\n        runnable.run();\r\n    } finally {\r\n        Engine.clearThreadLocalVariables();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.javamail.TriggerResource.getTargetRef",
	"Comment": "returns the reference of the target according to the a list ofproperties.",
	"Method": "Reference getTargetRef(Resolver<String> resolver){\r\n    final Template targetTemplate = new Template(getTargetUri());\r\n    Reference result = new Reference(targetTemplate.format(resolver));\r\n    if (result.isRelative()) {\r\n        result.setBaseRef(getMailboxUri());\r\n        result = result.getTargetRef();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.javamail.TriggerResource.getMailRef",
	"Comment": "returns the reference of a mail according to its identifier.",
	"Method": "Reference getMailRef(String identifier){\r\n    final Template mailTemplate = new Template(getMailUriTemplate());\r\n    Reference result = new Reference(mailTemplate.format(new MailResolver(identifier)));\r\n    if (result.isRelative()) {\r\n        result.setBaseRef(getMailboxUri());\r\n        result = result.getTargetRef();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.Application.stop",
	"Comment": "stops the application, the inbound and outbound roots then all theenabled associated services. finally, it clears the internal cache ofannotations.",
	"Method": "void stop(){\r\n    if (isStarted()) {\r\n        super.stop();\r\n        if (getOutboundRoot() != null) {\r\n            getOutboundRoot().stop();\r\n        }\r\n        if (getInboundRoot() != null) {\r\n            getInboundRoot().stop();\r\n        }\r\n        getServices().stop();\r\n        if (getHelper() != null) {\r\n            getHelper().stop();\r\n        }\r\n        AnnotationUtils.getInstance().clearCache();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlRepresentation.internalEval",
	"Comment": "evaluates an xpath expression and returns the result as in the givenreturn type.",
	"Method": "Object internalEval(String expression,javax.xml.namespace.QName returnType){\r\n    try {\r\n        Object result = null;\r\n        XPath xpath = XPathFactory.newInstance().newXPath();\r\n        xpath.setNamespaceContext(this);\r\n        Document xmlDocument = getDocument();\r\n        if (xmlDocument != null) {\r\n            result = xpath.evaluate(expression, xmlDocument, returnType);\r\n        } else {\r\n            throw new Exception(\"Unable to obtain a DOM document for the XML representation. \" + \"XPath evaluation cancelled.\");\r\n        }\r\n        return result;\r\n    } catch (RuntimeException e) {\r\n        throw e;\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.bcel.generic.Utils.isCompatible",
	"Comment": "tests whether one type is compatible with another for methodinvocation conversion. this includes assignment conversion,except the implicit narrowing of integer constants.jls section 5.2",
	"Method": "boolean isCompatible(Type aSubType,Type aSuperType){\r\n    boolean result = false;\r\n    if (aSubType.equals(aSuperType)) {\r\n        result = true;\r\n    } else if ((aSubType instanceof ReferenceType) && (aSuperType instanceof ReferenceType)) {\r\n        final ReferenceType aSubRefType = (ReferenceType) aSubType;\r\n        result = aSubRefType.isAssignmentCompatibleWith(aSuperType);\r\n    } else if (aSubType.equals(Type.BYTE)) {\r\n        result = aSuperType.equals(Type.SHORT) || aSuperType.equals(Type.INT) || aSuperType.equals(Type.LONG) || aSuperType.equals(Type.FLOAT) || aSuperType.equals(Type.DOUBLE);\r\n    } else if (aSubType.equals(Type.SHORT)) {\r\n        result = aSuperType.equals(Type.INT) || aSuperType.equals(Type.LONG) || aSuperType.equals(Type.FLOAT) || aSuperType.equals(Type.DOUBLE);\r\n    } else if (aSubType.equals(Type.INT)) {\r\n        result = aSuperType.equals(Type.LONG) || aSuperType.equals(Type.FLOAT) || aSuperType.equals(Type.DOUBLE);\r\n    } else if (aSubType.equals(Type.LONG)) {\r\n        result = aSuperType.equals(Type.FLOAT) || aSuperType.equals(Type.DOUBLE);\r\n    } else if (aSubType.equals(Type.DOUBLE)) {\r\n        result = aSuperType.equals(Type.DOUBLE);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createJobPartSpecialPayableQuery",
	"Comment": "creates a query for jobpartspecialpayable entities hosted by thisservice.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.JobPartSpecialPayable> createJobPartSpecialPayableQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.JobPartSpecialPayable.class);\r\n}"
}, {
	"Path": "org.restlet.data.Reference.getHostDomain",
	"Comment": "returns the optionnally decoded host domain name component.",
	"Method": "String getHostDomain(String getHostDomain,boolean decode){\r\n    return decode ? decode(getHostDomain()) : getHostDomain();\r\n}"
}, {
	"Path": "org.restlet.resource.Resource.getMatrixValue",
	"Comment": "returns the first value of the matrix parameter given its name ifexisting, or null.",
	"Method": "String getMatrixValue(String name){\r\n    String result = null;\r\n    Form matrix = getMatrix();\r\n    if (matrix != null) {\r\n        result = matrix.getFirstValue(name);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.channel.ReadableSizedChannel.setAvailableSize",
	"Comment": "sets the remaining size that should be read from the source channel.",
	"Method": "void setAvailableSize(long availableSize){\r\n    this.availableSize = availableSize;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.Metadata.getEntityType",
	"Comment": "returns the entitytype that corresponds to a given entity class.",
	"Method": "EntityType getEntityType(Class<?> entityClass){\r\n    EntityType result = null;\r\n    String className = entityClass.getName();\r\n    int index = className.lastIndexOf(\".\");\r\n    if (index != -1) {\r\n        className = className.substring(index + 1);\r\n    }\r\n    for (Iterator<EntityContainer> iec = getContainers().iterator(); result == null && iec.hasNext(); ) {\r\n        EntityContainer entityContainer = iec.next();\r\n        for (Iterator<EntitySet> ies = entityContainer.getEntities().iterator(); result == null && ies.hasNext(); ) {\r\n            EntitySet entitySet = ies.next();\r\n            EntityType type = entitySet.getType();\r\n            if (type.getClassName().equals(className)) {\r\n                result = type;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlWriter.ignorableWhitespace",
	"Comment": "write ignorable whitespace. pass the event on down the filter chain forfurther processing.",
	"Method": "void ignorableWhitespace(char ch,int start,int length){\r\n    writeEsc(ch, start, length, false);\r\n    super.ignorableWhitespace(ch, start, length);\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.JaxRsApplication.setApplications",
	"Comment": "adds the given applications to the available applications.",
	"Method": "void setApplications(Collection<javax.ws.rs.core.Application> apps){\r\n    for (Application app : apps) {\r\n        add(app);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.crypto.CookieAuthenticator.setLoginFormPath",
	"Comment": "sets the uri path of the html login form to use to challenge the user.",
	"Method": "void setLoginFormPath(String loginFormPath){\r\n    this.loginFormPath = loginFormPath;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlRepresentation.setXIncludeAware",
	"Comment": "indicates the desire for processing xinclude if found in thistype of xml representations. by default the value of this is set tofalse.",
	"Method": "void setXIncludeAware(boolean includeAware){\r\n    xIncludeAware = includeAware;\r\n}"
}, {
	"Path": "org.restlet.ext.nio.internal.way.Way.onClosed",
	"Comment": "callback method invoked when the parent connection is ready to be closed.",
	"Method": "void onClosed(){\r\n    setIoState(IoState.IDLE);\r\n    setMessageState(MessageState.IDLE);\r\n    setMessage(null);\r\n    setHeaders(null);\r\n    getBuffer().clear();\r\n}"
}, {
	"Path": "org.restlet.engine.connector.HttpClientHelper.getReadTimeout",
	"Comment": "returns the read timeout value. a timeout of zero is interpreted as aninfinite timeout. defaults to 60000.",
	"Method": "int getReadTimeout(){\r\n    return Integer.parseInt(getHelpedParameters().getFirstValue(\"readTimeout\", \"60000\"));\r\n}"
}, {
	"Path": "org.restlet.service.ConnegService.isStrict",
	"Comment": "indicates if the conneg algorithm should strictly respect clientpreferences or be more flexible. value is false by default.",
	"Method": "boolean isStrict(){\r\n    return strict;\r\n}"
}, {
	"Path": "org.restlet.engine.header.HeaderUtils.extractEntityHeaders",
	"Comment": "extracts entity headers and updates a given representation or create anempty one when at least one entity header is present.",
	"Method": "Representation extractEntityHeaders(Iterable<Header> headers,Representation representation){\r\n    Representation result = (representation == null) ? new EmptyRepresentation() : representation;\r\n    boolean entityHeaderFound = false;\r\n    if (headers != null) {\r\n        for (Header header : headers) {\r\n            if (HEADER_CONTENT_TYPE.equalsIgnoreCase(header.getName())) {\r\n                ContentType contentType = new ContentType(header.getValue());\r\n                result.setMediaType(contentType.getMediaType());\r\n                if ((result.getCharacterSet() == null) || (contentType.getCharacterSet() != null)) {\r\n                    result.setCharacterSet(contentType.getCharacterSet());\r\n                }\r\n                entityHeaderFound = true;\r\n            } else if (HEADER_CONTENT_LENGTH.equalsIgnoreCase(header.getName())) {\r\n                entityHeaderFound = true;\r\n            } else if (HEADER_EXPIRES.equalsIgnoreCase(header.getName())) {\r\n                result.setExpirationDate(HeaderReader.readDate(header.getValue(), false));\r\n                entityHeaderFound = true;\r\n            } else if (HEADER_CONTENT_ENCODING.equalsIgnoreCase(header.getName())) {\r\n                new EncodingReader(header.getValue()).addValues(result.getEncodings());\r\n                entityHeaderFound = true;\r\n            } else if (HEADER_CONTENT_LANGUAGE.equalsIgnoreCase(header.getName())) {\r\n                new LanguageReader(header.getValue()).addValues(result.getLanguages());\r\n                entityHeaderFound = true;\r\n            } else if (HEADER_LAST_MODIFIED.equalsIgnoreCase(header.getName())) {\r\n                result.setModificationDate(HeaderReader.readDate(header.getValue(), false));\r\n                entityHeaderFound = true;\r\n            } else if (HEADER_ETAG.equalsIgnoreCase(header.getName())) {\r\n                result.setTag(Tag.parse(header.getValue()));\r\n                entityHeaderFound = true;\r\n            } else if (HEADER_CONTENT_LOCATION.equalsIgnoreCase(header.getName())) {\r\n                result.setLocationRef(header.getValue());\r\n                entityHeaderFound = true;\r\n            } else if (HEADER_CONTENT_DISPOSITION.equalsIgnoreCase(header.getName())) {\r\n                try {\r\n                    result.setDisposition(new DispositionReader(header.getValue()).readValue());\r\n                    entityHeaderFound = true;\r\n                } catch (IOException ioe) {\r\n                    Context.getCurrentLogger().log(Level.WARNING, \"Error during Content-Disposition header parsing. Header: \" + header.getValue(), ioe);\r\n                }\r\n            } else if (HEADER_CONTENT_RANGE.equalsIgnoreCase(header.getName())) {\r\n                org.restlet.engine.header.RangeReader.update(header.getValue(), result);\r\n                entityHeaderFound = true;\r\n            } else if (HEADER_CONTENT_MD5.equalsIgnoreCase(header.getName())) {\r\n                String base64hash = header.getValue();\r\n                if (base64hash.length() == 22) {\r\n                    base64hash += \"==\";\r\n                }\r\n                result.setDigest(new org.restlet.data.Digest(org.restlet.data.Digest.ALGORITHM_MD5, org.restlet.engine.util.Base64.decode(base64hash)));\r\n                entityHeaderFound = true;\r\n            }\r\n        }\r\n    }\r\n    if ((representation == null) && !entityHeaderFound) {\r\n        result = null;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.TransformRepresentation.release",
	"Comment": "releases the source and transform sheet representations, the transformerand the uri resolver.",
	"Method": "void release(){\r\n    if (this.sourceRepresentation != null) {\r\n        this.sourceRepresentation.release();\r\n        this.sourceRepresentation = null;\r\n    }\r\n    if (this.templates != null) {\r\n        this.templates = null;\r\n    }\r\n    if (this.transformSheet != null) {\r\n        this.transformSheet.release();\r\n        this.transformSheet = null;\r\n    }\r\n    if (this.uriResolver != null) {\r\n        this.uriResolver = null;\r\n    }\r\n    super.release();\r\n}"
}, {
	"Path": "org.restlet.security.Role.setChildRoles",
	"Comment": "sets the modifiable list of child roles. this method clears the currentlist and adds all entries in the parameter list.",
	"Method": "void setChildRoles(List<Role> childRoles){\r\n    synchronized (getChildRoles()) {\r\n        if (childRoles != getChildRoles()) {\r\n            getChildRoles().clear();\r\n            if (childRoles != null) {\r\n                getChildRoles().addAll(childRoles);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.data.ChallengeMessage.getParameters",
	"Comment": "returns the modifiable series of scheme parameters. creates a newinstance if no one has been set.",
	"Method": "Series<Parameter> getParameters(){\r\n    if (this.parameters == null) {\r\n        this.parameters = new Series<Parameter>(Parameter.class);\r\n    }\r\n    return this.parameters;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.ResourceInfo.getQueryType",
	"Comment": "returns the media type for the query component of the resource uri.",
	"Method": "MediaType getQueryType(){\r\n    return this.queryType;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.XmlRepresentation.appendTextContent",
	"Comment": "appends the text content of a given node and its descendants to the givenbuffer.",
	"Method": "void appendTextContent(Node node,StringBuilder sb){\r\n    switch(node.getNodeType()) {\r\n        case Node.TEXT_NODE:\r\n            sb.append(node.getNodeValue());\r\n            break;\r\n        case Node.CDATA_SECTION_NODE:\r\n            sb.append(node.getNodeValue());\r\n            break;\r\n        case Node.COMMENT_NODE:\r\n            sb.append(node.getNodeValue());\r\n            break;\r\n        case Node.PROCESSING_INSTRUCTION_NODE:\r\n            sb.append(node.getNodeValue());\r\n            break;\r\n        case Node.ENTITY_REFERENCE_NODE:\r\n            if (node.getNodeName().startsWith(\"#\")) {\r\n                int ch = Integer.parseInt(node.getNodeName().substring(1));\r\n                sb.append((char) ch);\r\n            }\r\n            break;\r\n        case Node.ELEMENT_NODE:\r\n            for (int i = 0; i < node.getChildNodes().getLength(); i++) {\r\n                appendTextContent(node.getChildNodes().item(i), sb);\r\n            }\r\n            break;\r\n        case Node.ATTRIBUTE_NODE:\r\n            for (int i = 0; i < node.getChildNodes().getLength(); i++) {\r\n                appendTextContent(node.getChildNodes().item(i), sb);\r\n            }\r\n            break;\r\n        case Node.ENTITY_NODE:\r\n            for (int i = 0; i < node.getChildNodes().getLength(); i++) {\r\n                appendTextContent(node.getChildNodes().item(i), sb);\r\n            }\r\n            break;\r\n        case Node.DOCUMENT_FRAGMENT_NODE:\r\n            for (int i = 0; i < node.getChildNodes().getLength(); i++) {\r\n                appendTextContent(node.getChildNodes().item(i), sb);\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.provider.JaxbProvider.isValidatingDtd",
	"Comment": "indicates the desire for validating this type of xml representationsagainst an xml schema if one is referenced within the contents.",
	"Method": "boolean isValidatingDtd(){\r\n    return validatingDtd;\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.RepresentationInfo.getProfiles",
	"Comment": "returns the list of locations of one or more meta data profiles.",
	"Method": "List<Reference> getProfiles(){\r\n    List<Reference> p = this.profiles;\r\n    if (p == null) {\r\n        synchronized (this) {\r\n            p = this.profiles;\r\n            if (p == null) {\r\n                this.profiles = p = new ArrayList<Reference>();\r\n            }\r\n        }\r\n    }\r\n    return p;\r\n}"
}, {
	"Path": "org.restlet.engine.header.PreferenceReader.extractMediaParams",
	"Comment": "extract the media parameters. only leave as the quality parameter iffound. modifies the parameters list.",
	"Method": "Series<Parameter> extractMediaParams(Series<Parameter> parameters){\r\n    Series<Parameter> result = null;\r\n    boolean qualityFound = false;\r\n    Parameter param = null;\r\n    if (parameters != null) {\r\n        result = new Series<Parameter>(Parameter.class);\r\n        for (final Iterator<Parameter> iter = parameters.iterator(); !qualityFound && iter.hasNext(); ) {\r\n            param = iter.next();\r\n            if (param.getName().equals(\"q\")) {\r\n                qualityFound = true;\r\n            } else {\r\n                iter.remove();\r\n                result.add(param);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.javamail.JavaMailClientHelper.isStartTls",
	"Comment": "indicates if the smtp protocol should attempt to start a tls tunnel.",
	"Method": "boolean isStartTls(){\r\n    return Boolean.parseBoolean(getHelpedParameters().getFirstValue(\"startTls\", \"false\"));\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipRequest.getRecordedRoutes",
	"Comment": "returns the list of routes completed by proxies to force future requeststo go through the proxy.",
	"Method": "List<Address> getRecordedRoutes(){\r\n    List<Address> rr = this.recordedRoutes;\r\n    if (rr == null) {\r\n        synchronized (this) {\r\n            rr = this.recordedRoutes;\r\n            if (rr == null) {\r\n                this.recordedRoutes = rr = new CopyOnWriteArrayList<Address>();\r\n            }\r\n        }\r\n    }\r\n    return rr;\r\n}"
}, {
	"Path": "org.restlet.ext.oauth.OAuthServerResource.responseErrorRepresentation",
	"Comment": "returns the representation of the given error. the format of the jsondocument is according to 5.2. error response.",
	"Method": "Representation responseErrorRepresentation(OAuthException ex){\r\n    try {\r\n        return new JsonRepresentation(ex.createErrorDocument());\r\n    } catch (JSONException e) {\r\n        StringRepresentation r = new StringRepresentation(\"{\\\"error\\\":\\\"server_error\\\",\\\"error_description:\\\":\\\"\" + e.getLocalizedMessage() + \"\\\"}\");\r\n        r.setMediaType(MediaType.APPLICATION_JSON);\r\n        return r;\r\n    }\r\n}"
}, {
	"Path": "org.restlet.security.Role.get",
	"Comment": "finds an existing role or creates a new one if needed. note that a nulldescription will be set if the role has to be created.",
	"Method": "Role get(Application application,String name,Role get,Application application,String name,String description){\r\n    Role role = (application == null) ? null : application.getRole(name);\r\n    return (role == null) ? new Role(application, name, description) : role;\r\n}"
}, {
	"Path": "org.restlet.resource.Resource.toRepresentation",
	"Comment": "converts an object into a representation based on client preferences.",
	"Method": "Representation toRepresentation(Object source,Representation toRepresentation,Object source,MediaType target,Representation toRepresentation,Object source,Variant target){\r\n    Representation result = null;\r\n    if (source != null) {\r\n        org.restlet.service.ConverterService cs = getConverterService();\r\n        result = cs.toRepresentation(source, target, this);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.xml.DomRepresentation.release",
	"Comment": "releases the wrapped dom document and the source xml representation ifthey have been defined.",
	"Method": "void release(){\r\n    setDocument(null);\r\n    if (this.xmlRepresentation != null) {\r\n        this.xmlRepresentation.release();\r\n    }\r\n    super.release();\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createDivisionQuery",
	"Comment": "creates a query for division entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.Division> createDivisionQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.Division.class);\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.Metadata.getEntitySetSubpath",
	"Comment": "returns the subpath of the entityset of the given entity type.",
	"Method": "String getEntitySetSubpath(EntityType entityType){\r\n    String result = null;\r\n    if (entityType == null) {\r\n        return result;\r\n    }\r\n    for (EntityContainer entityContainer : getContainers()) {\r\n        for (EntitySet entitySet : entityContainer.getEntities()) {\r\n            EntityType type = entitySet.getType();\r\n            if (type.equals(entityType)) {\r\n                result = \"/\" + entitySet.getName();\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.ResourceMethod.isAcceptedMediaTypeSupported",
	"Comment": "check if this method supports the media type to produce for a request.",
	"Method": "boolean isAcceptedMediaTypeSupported(SortedMetadata<MediaType> accMediaTypess){\r\n    if ((accMediaTypess == null) || accMediaTypess.isEmpty()) {\r\n        return true;\r\n    }\r\n    final List<MediaType> prodMimes = getProducedMimes();\r\n    if (prodMimes.isEmpty()) {\r\n        return true;\r\n    }\r\n    for (final MediaType producedMediaType : prodMimes) {\r\n        for (final MediaType accMediaType : accMediaTypess) {\r\n            if (accMediaType.isCompatible(producedMediaType)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.restlet.ext.jackson.JacksonRepresentation.createObjectMapper",
	"Comment": "creates a jackson object mapper based on a media type. it supports json,json smile, xml, yaml and csv.",
	"Method": "ObjectMapper createObjectMapper(){\r\n    ObjectMapper result = null;\r\n    if (MediaType.APPLICATION_JSON.isCompatible(getMediaType())) {\r\n        JsonFactory jsonFactory = new JsonFactory();\r\n        jsonFactory.configure(Feature.AUTO_CLOSE_TARGET, false);\r\n        result = new ObjectMapper(jsonFactory);\r\n    } else if (MediaType.APPLICATION_JSON_SMILE.isCompatible(getMediaType())) {\r\n        SmileFactory smileFactory = new SmileFactory();\r\n        smileFactory.configure(Feature.AUTO_CLOSE_TARGET, false);\r\n        result = new ObjectMapper(smileFactory);\r\n    } else if (MediaType.APPLICATION_XML.isCompatible(getMediaType()) || MediaType.TEXT_XML.isCompatible(getMediaType())) {\r\n        javax.xml.stream.XMLInputFactory xif = XmlFactoryProvider.newInputFactory();\r\n        xif.setProperty(javax.xml.stream.XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, isExpandingEntityRefs());\r\n        xif.setProperty(javax.xml.stream.XMLInputFactory.SUPPORT_DTD, isExpandingEntityRefs());\r\n        xif.setProperty(javax.xml.stream.XMLInputFactory.IS_VALIDATING, isValidatingDtd());\r\n        javax.xml.stream.XMLOutputFactory xof = XmlFactoryProvider.newOutputFactory();\r\n        XmlFactory xmlFactory = new XmlFactory(xif, xof);\r\n        xmlFactory.configure(Feature.AUTO_CLOSE_TARGET, false);\r\n        result = new XmlMapper(xmlFactory);\r\n    } else if (MediaType.APPLICATION_YAML.isCompatible(getMediaType()) || MediaType.TEXT_YAML.isCompatible(getMediaType())) {\r\n        YAMLFactory yamlFactory = new YAMLFactory();\r\n        yamlFactory.configure(Feature.AUTO_CLOSE_TARGET, false);\r\n        result = new ObjectMapper(yamlFactory);\r\n    } else if (MediaType.TEXT_CSV.isCompatible(getMediaType())) {\r\n        CsvFactory csvFactory = new CsvFactory();\r\n        csvFactory.configure(Feature.AUTO_CLOSE_TARGET, false);\r\n        result = new CsvMapper(csvFactory);\r\n    } else {\r\n        JsonFactory jsonFactory = new JsonFactory();\r\n        jsonFactory.configure(Feature.AUTO_CLOSE_TARGET, false);\r\n        result = new ObjectMapper(jsonFactory);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Person.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer,String localName){\r\n    writer.startElement(ATOM_NAMESPACE, localName);\r\n    if (getEmail() != null) {\r\n        writer.dataElement(ATOM_NAMESPACE, \"email\", getEmail());\r\n    }\r\n    if (getName() != null) {\r\n        writer.dataElement(ATOM_NAMESPACE, \"name\", getName());\r\n    }\r\n    if ((getUri() != null) && (getUri().toString() != null)) {\r\n        writer.dataElement(ATOM_NAMESPACE, \"uri\", getUri().toString());\r\n    }\r\n    writer.endElement(ATOM_NAMESPACE, localName);\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Source.setUpdated",
	"Comment": "sets the most recent moment when the entry was modified in a significantway.",
	"Method": "void setUpdated(Date updated){\r\n    this.updated = DateUtils.unmodifiable(updated);\r\n}"
}, {
	"Path": "com.google.gwt.emul.java.io.BufferedReader.read",
	"Comment": "returns the next character, either the saved one or the next one from thesource reader.",
	"Method": "int read(int read,char[] cbuf,int off,int len){\r\n    return source.read(cbuf, off, len);\r\n}"
}, {
	"Path": "org.restlet.ext.oauth.AccessTokenClientResource.requestToken",
	"Comment": "returns the oauth token by requesting the remote authorization server.",
	"Method": "Token requestToken(OAuthParameters parameters){\r\n    if (authenticationScheme == null) {\r\n        setupBodyClientCredentials(parameters);\r\n    } else {\r\n        setChallengeResponse(authenticationScheme, clientId, clientSecret);\r\n    }\r\n    Representation input = parameters.toRepresentation();\r\n    accept(MediaType.APPLICATION_JSON);\r\n    JSONObject result = new JsonRepresentation(post(input)).getJsonObject();\r\n    if (result.has(ERROR)) {\r\n        throw OAuthException.toOAuthException(result);\r\n    }\r\n    TokenResponse token = TokenResponse.parseResponse(result);\r\n    if (token.scope == null) {\r\n        token.scope = Scopes.parseScope(parameters.toForm().getFirstValue(SCOPE));\r\n    }\r\n    return token;\r\n}"
}, {
	"Path": "org.restlet.security.CertificateAuthenticator.getPrincipals",
	"Comment": "extracts the principal of the subject to use from a chain of certificate.by default, this is the x500principal of the subject subject of the firstcertificate in the chain.",
	"Method": "List<Principal> getPrincipals(List<Certificate> certificateChain){\r\n    ArrayList<Principal> principals = null;\r\n    if ((certificateChain != null) && (certificateChain.size() > 0)) {\r\n        Certificate userCert = certificateChain.get(0);\r\n        if (userCert instanceof X509Certificate) {\r\n            principals = new ArrayList<Principal>();\r\n            principals.add(((X509Certificate) userCert).getSubjectX500Principal());\r\n        }\r\n        return principals;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.sip.SipRequest.getLastActivity",
	"Comment": "returns the date of last activity on this transaction object.",
	"Method": "long getLastActivity(){\r\n    return lastActivity;\r\n}"
}, {
	"Path": "org.restlet.util.SelectionRegistration.setInterestOperations",
	"Comment": "sets the io operations interest. note that it also clears the readyoperations.",
	"Method": "boolean setInterestOperations(int interest){\r\n    boolean result = false;\r\n    if (this.interestOperations != interest) {\r\n        this.interestOperations = interest;\r\n        result = true;\r\n    }\r\n    setReadyOperations(0);\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jackson.JacksonRepresentation.setValidatingDtd",
	"Comment": "indicates the desire for validating this type of xml representationsagainst an xml schema if one is referenced within the contents.",
	"Method": "void setValidatingDtd(boolean validating){\r\n    this.validatingDtd = validating;\r\n}"
}, {
	"Path": "com.puppycrawl.tools.checkstyle.checks.usage.transmogrify.ExternalSignature.isCompatibleWith",
	"Comment": "whether this method signature is compatible with the signature of theargument.that is to say, each type for this signature are subclasses,subinterfaces, or implement the interface for each corresponding typein the argument signature.",
	"Method": "boolean isCompatibleWith(ISignature signature){\r\n    boolean result = true;\r\n    if (_parameters.length == signature.getParameters().length) {\r\n        for (int i = 0; i < _parameters.length; i++) {\r\n            if (!getParameters()[i].isCompatibleWith(signature.getParameters()[i])) {\r\n                result = false;\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        result = false;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.Query.createTargetUri",
	"Comment": "returns the complete target uri reference for this query. it is composedof the data service base uri, the subpath and the query string.",
	"Method": "String createTargetUri(){\r\n    String service = getService().getServiceRef().toString();\r\n    StringBuilder result = new StringBuilder();\r\n    String subpath = (getSubpath() == null) ? \"\" : getSubpath();\r\n    Reference ref = new Reference(subpath);\r\n    if (ref.isAbsolute()) {\r\n        result = new StringBuilder(subpath);\r\n    } else {\r\n        result = new StringBuilder(service);\r\n        if (service.endsWith(\"/\")) {\r\n            if (subpath.startsWith(\"/\")) {\r\n                result.append(subpath.substring(1));\r\n            } else {\r\n                result.append(subpath);\r\n            }\r\n        } else {\r\n            if (subpath.startsWith(\"/\")) {\r\n                result.append(subpath);\r\n            } else {\r\n                result.append(\"/\").append(subpath);\r\n            }\r\n        }\r\n    }\r\n    if (getQuery() != null) {\r\n        result.append(\"?\").append(getQuery());\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "org.restlet.routing.Template.format",
	"Comment": "creates a formatted string based on the given variable resolver.",
	"Method": "String format(Map<String, ?> values,String format,Request request,Response response,String format,Resolver<?> resolver){\r\n    final StringBuilder result = new StringBuilder();\r\n    StringBuilder varBuffer = null;\r\n    char next;\r\n    boolean inVariable = false;\r\n    final int patternLength = getPattern().length();\r\n    for (int i = 0; i < patternLength; i++) {\r\n        next = getPattern().charAt(i);\r\n        if (inVariable) {\r\n            if (Reference.isUnreserved(next)) {\r\n                varBuffer.append(next);\r\n            } else if (next == '}') {\r\n                if (varBuffer.length() == 0) {\r\n                    getLogger().warning(\"Empty pattern variables are not allowed : \" + this.regexPattern);\r\n                } else {\r\n                    final String varName = varBuffer.toString();\r\n                    Object varValue = resolver.resolve(varName);\r\n                    Variable var = getVariables().get(varName);\r\n                    if (varValue == null) {\r\n                        if (var == null) {\r\n                            var = getDefaultVariable();\r\n                        }\r\n                        if (var != null) {\r\n                            varValue = var.getDefaultValue();\r\n                        }\r\n                    }\r\n                    String varValueString = (varValue == null) ? null : varValue.toString();\r\n                    if (this.encodingVariables) {\r\n                        if (var != null) {\r\n                            result.append(var.encode(varValueString));\r\n                        } else {\r\n                            result.append(Reference.encode(varValueString));\r\n                        }\r\n                    } else {\r\n                        if ((var != null) && var.isEncodingOnFormat()) {\r\n                            result.append(Reference.encode(varValueString));\r\n                        } else {\r\n                            result.append(varValueString);\r\n                        }\r\n                    }\r\n                    varBuffer = new StringBuilder();\r\n                }\r\n                inVariable = false;\r\n            } else {\r\n                getLogger().warning(\"An invalid character was detected inside a pattern variable : \" + this.regexPattern);\r\n            }\r\n        } else {\r\n            if (next == '{') {\r\n                inVariable = true;\r\n                varBuffer = new StringBuilder();\r\n            } else if (next == '}') {\r\n                getLogger().warning(\"An invalid character was detected inside a pattern variable : \" + this.regexPattern);\r\n            } else {\r\n                result.append(next);\r\n            }\r\n        }\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "org.restlet.engine.application.TunnelFilter.getAcceptReplacers",
	"Comment": "returns the list of new accept header values. each of them describe alsoa set of conditions required to set the new value. this method is usedonly to initialize the headerreplacers field.",
	"Method": "List<HeaderReplacer> getAcceptReplacers(){\r\n    return getheaderReplacers(Engine.getResource(\"org/restlet/service/accept.properties\"), \"acceptOld\", \"acceptNew\");\r\n}"
}, {
	"Path": "org.restlet.engine.util.InternetDateFormat.getDate",
	"Comment": "gets the value of this internetdateformat object as a date object.",
	"Method": "Date getDate(){\r\n    return cal.getTime();\r\n}"
}, {
	"Path": "org.restlet.ext.httpclient.internal.HttpIdleConnectionReaper.waitForReaperStop",
	"Comment": "tells the reaper thread the maximum time to wait before stopping.",
	"Method": "void waitForReaperStop(long millis){\r\n    reaperThread.waitForStop(millis);\r\n}"
}, {
	"Path": "org.restlet.ext.nio.ConnectionHelper.isSocketOobInline",
	"Comment": "indicates if urgent tcp data received on the socket will be receivedthrough the socket input stream.",
	"Method": "boolean isSocketOobInline(){\r\n    return Boolean.parseBoolean(getHelpedParameters().getFirstValue(\"socketOobInline\", \"false\"));\r\n}"
}, {
	"Path": "org.restlet.security.MemoryRealm.setRootGroups",
	"Comment": "sets the modifiable list of root groups. this method clears the currentlist and adds all entries in the parameter list.",
	"Method": "void setRootGroups(List<Group> rootGroups){\r\n    synchronized (getRootGroups()) {\r\n        if (rootGroups != getRootGroups()) {\r\n            getRootGroups().clear();\r\n            if (rootGroups != null) {\r\n                getRootGroups().addAll(rootGroups);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.data.ChallengeRequest.isStale",
	"Comment": "indicates if the previous request from the client was stale.",
	"Method": "boolean isStale(){\r\n    return stale;\r\n}"
}, {
	"Path": "org.restlet.engine.io.IoUtils.getReader",
	"Comment": "returns a reader from a writer representation.internally, it uses awriter thread and a pipe stream.",
	"Method": "Reader getReader(InputStream stream,CharacterSet characterSet,Reader getReader,org.restlet.representation.WriterRepresentation representation){\r\n    Reader result = null;\r\n    final java.io.PipedWriter pipedWriter = new java.io.PipedWriter();\r\n    java.io.PipedReader pipedReader = new java.io.PipedReader(pipedWriter);\r\n    Runnable task = new org.restlet.engine.util.ContextualRunnable() {\r\n        public void run() {\r\n            try {\r\n                representation.write(pipedWriter);\r\n                pipedWriter.flush();\r\n            } catch (IOException ioe) {\r\n                Context.getCurrentLogger().log(Level.WARNING, \"Error while writing to the piped reader.\", ioe);\r\n            } finally {\r\n                try {\r\n                    pipedWriter.close();\r\n                } catch (IOException ioe2) {\r\n                    Context.getCurrentLogger().log(Level.WARNING, \"Error while closing the pipe.\", ioe2);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    org.restlet.Context context = org.restlet.Context.getCurrent();\r\n    if (context != null && context.getExecutorService() != null) {\r\n        context.getExecutorService().execute(task);\r\n    } else {\r\n        Engine.createThreadWithLocalVariables(task, \"Restlet-IoUtils\").start();\r\n    }\r\n    result = pipedReader;\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.io.IoUtils.getReader",
	"Comment": "returns a reader from a writer representation.internally, it uses awriter thread and a pipe stream.",
	"Method": "Reader getReader(InputStream stream,CharacterSet characterSet,Reader getReader,org.restlet.representation.WriterRepresentation representation){\r\n    try {\r\n        representation.write(pipedWriter);\r\n        pipedWriter.flush();\r\n    } catch (IOException ioe) {\r\n        Context.getCurrentLogger().log(Level.WARNING, \"Error while writing to the piped reader.\", ioe);\r\n    } finally {\r\n        try {\r\n            pipedWriter.close();\r\n        } catch (IOException ioe2) {\r\n            Context.getCurrentLogger().log(Level.WARNING, \"Error while closing the pipe.\", ioe2);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.WadlApplication.getPreferredWadlVariant",
	"Comment": "returns the preferred wadl variant according to the client preferencesspecified in the request.",
	"Method": "Variant getPreferredWadlVariant(Request request){\r\n    return getConnegService().getPreferredVariant(getWadlVariants(), request, getMetadataService());\r\n}"
}, {
	"Path": "org.restlet.ext.nio.BaseHelper.getOutboundMessages",
	"Comment": "returns the queue of outbound messages pending for handling.",
	"Method": "Queue<Response> getOutboundMessages(){\r\n    return outboundMessages;\r\n}"
}, {
	"Path": "org.restlet.ext.atom.EntryReader.endLink",
	"Comment": "called at the end of the xml block that defines the given link.",
	"Method": "void endLink(Link link){\r\n    if (this.entryReader != null) {\r\n        this.entryReader.endLink(link);\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.atom.Category.writeElement",
	"Comment": "writes the current object as an xml element using the given sax writer.",
	"Method": "void writeElement(XmlWriter writer){\r\n    final AttributesImpl attributes = new AttributesImpl();\r\n    if (getLabel() != null) {\r\n        attributes.addAttribute(\"\", \"label\", null, \"text\", getLabel());\r\n    }\r\n    if ((getScheme() != null) && (getScheme().toString() != null)) {\r\n        attributes.addAttribute(\"\", \"scheme\", null, \"atomURI\", getScheme().toString());\r\n    }\r\n    if (getTerm() != null) {\r\n        attributes.addAttribute(\"\", \"term\", null, \"text\", getTerm());\r\n    }\r\n    writer.emptyElement(ATOM_NAMESPACE, \"category\", null, attributes);\r\n}"
}, {
	"Path": "org.restlet.test.ext.odata.deepexpand.ContainerService.createUniversityQuery",
	"Comment": "creates a query for university entities hosted by this service.",
	"Method": "Query<org.restlet.test.ext.odata.deepexpand.model.University> createUniversityQuery(String subpath){\r\n    return createQuery(subpath, org.restlet.test.ext.odata.deepexpand.model.University.class);\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.edm.TypeUtils.toJavaTypeName",
	"Comment": "returns the name of the corresponding java class or scalar type.",
	"Method": "String toJavaTypeName(String edmTypeName){\r\n    String result = \"Object\";\r\n    if (edmTypeName.endsWith(\"Binary\")) {\r\n        result = \"byte[]\";\r\n    } else if (edmTypeName.endsWith(\"Boolean\")) {\r\n        result = \"boolean\";\r\n    } else if (edmTypeName.endsWith(\"DateTime\")) {\r\n        result = \"Date\";\r\n    } else if (edmTypeName.endsWith(\"DateTimeOffset\")) {\r\n        result = \"Date\";\r\n    } else if (edmTypeName.endsWith(\"Time\")) {\r\n        result = \"long\";\r\n    } else if (edmTypeName.endsWith(\"Decimal\")) {\r\n        result = \"double\";\r\n    } else if (edmTypeName.endsWith(\"Single\")) {\r\n        result = \"double\";\r\n    } else if (edmTypeName.endsWith(\"Double\")) {\r\n        result = \"double\";\r\n    } else if (edmTypeName.endsWith(\"Guid\")) {\r\n        result = \"String\";\r\n    } else if (edmTypeName.endsWith(\"Int16\")) {\r\n        result = \"short\";\r\n    } else if (edmTypeName.endsWith(\"Int32\")) {\r\n        result = \"int\";\r\n    } else if (edmTypeName.endsWith(\"Int64\")) {\r\n        result = \"long\";\r\n    } else if (edmTypeName.endsWith(\"Byte\")) {\r\n        result = \"byte\";\r\n    } else if (edmTypeName.endsWith(\"String\")) {\r\n        result = \"String\";\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.ext.jaas.JaasVerifier.createCallbackHandler",
	"Comment": "creates a callback handler for the given parameters. by default itreturns one handler that handles name and password jaas callbacks.",
	"Method": "CallbackHandler createCallbackHandler(Request request,Response response){\r\n    return new ChallengeCallbackHandler(request, response);\r\n}"
}, {
	"Path": "org.restlet.ext.wadl.WadlServerResource.describeParameters",
	"Comment": "returns the description of the parameters of this resource. returns nullby default.",
	"Method": "List<ParameterInfo> describeParameters(){\r\n    return null;\r\n}"
}, {
	"Path": "org.restlet.ext.odata.internal.reflect.ReflectUtils.invokeGetter",
	"Comment": "returns the value of a property on an entity based on its name.",
	"Method": "Object invokeGetter(Object entity,String propertyName){\r\n    Object result = null;\r\n    if (propertyName != null && entity != null) {\r\n        propertyName = propertyName.replaceAll(\"/\", \".\");\r\n        Object o = entity;\r\n        String pty = propertyName;\r\n        int index = propertyName.indexOf(\".\");\r\n        if (index != -1) {\r\n            o = invokeGetter(entity, propertyName.substring(0, index));\r\n            pty = propertyName.substring(index + 1);\r\n            result = invokeGetter(o, pty);\r\n        } else {\r\n            String getterName = null;\r\n            char firstLetter = propertyName.charAt(0);\r\n            if (Character.isLowerCase(firstLetter)) {\r\n                getterName = \"get\" + Character.toUpperCase(firstLetter) + pty.substring(1);\r\n            } else {\r\n                getterName = \"get\" + pty;\r\n            }\r\n            Method getter = null;\r\n            Method method;\r\n            for (int i = 0; (getter == null) && (i < entity.getClass().getDeclaredMethods().length); i++) {\r\n                method = entity.getClass().getDeclaredMethods()[i];\r\n                if (method.getName().equals(getterName)) {\r\n                    getter = method;\r\n                }\r\n            }\r\n            if (getter != null) {\r\n                result = getter.invoke(o);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.restlet.engine.ssl.DefaultSslContextFactory.setWantClientAuthentication",
	"Comment": "indicates if we would like client certificate authentication. the defaultvalue is false.",
	"Method": "void setWantClientAuthentication(boolean wantClientAuthentication){\r\n    this.wantClientAuthentication = wantClientAuthentication;\r\n}"
}, {
	"Path": "org.restlet.ext.jaxrs.internal.wrappers.WrapperUtil.isBeanSetter",
	"Comment": "checks, if the given method is a bean setter and annotated with the givenannotation. if it is a bean setter, the accessible attribute of is setthe method is set to true.",
	"Method": "boolean isBeanSetter(Method method,Class<? extends Annotation> annotationClass){\r\n    if (method.isAnnotationPresent(annotationClass) && method.getName().startsWith(\"set\") && (method.getParameterTypes().length == 1)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.restlet.engine.header.HeaderUtils.isQuoteCharacter",
	"Comment": "indicates if the given character marks the start of a quoted pair.",
	"Method": "boolean isQuoteCharacter(int character){\r\n    return (character == '\\\\');\r\n}"
}, {
	"Path": "org.restlet.ext.xdb.internal.ChunkedOutputStream.writeChunk",
	"Comment": "write a chunk, starting with its size in hexadecimal, followed by crlfand the actual content.",
	"Method": "void writeChunk(){\r\n    if (this.bytesWritten > 0) {\r\n        this.destination.write(StringUtils.getAsciiBytes(Integer.toHexString(this.bytesWritten)));\r\n        HeaderUtils.writeCRLF(this.destination);\r\n        this.destination.write(this.buffer, 0, this.bytesWritten);\r\n        HeaderUtils.writeCRLF(this.destination);\r\n        reset();\r\n    }\r\n}"
}, {
	"Path": "org.restlet.ext.rdf.internal.ntriples.RdfNTriplesReader.getParsingMessage",
	"Comment": "returns a message describing the current state of the parsing process.",
	"Method": "String getParsingMessage(String getParsingMessage,char[] buffer,int startTokenIndex,int scoutIndex){\r\n    StringBuilder sb = new StringBuilder(\"Parsing data [\");\r\n    sb.append(startTokenIndex);\r\n    sb.append(\",\");\r\n    sb.append(scoutIndex);\r\n    sb.append(\"] near \");\r\n    if (startTokenIndex < 25) {\r\n        sb.append(buffer, buffer.length - 30, 28);\r\n        sb.append(buffer, 0, 25);\r\n    } else if (startTokenIndex > (buffer.length - 25)) {\r\n        sb.append(buffer, buffer.length - 30, 28);\r\n        sb.append(buffer, 0, 20);\r\n    } else {\r\n        sb.append(buffer, startTokenIndex - 25, 50);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.restlet.util.WrapperRequest.setProxyChallengeResponse",
	"Comment": "sets the authentication response sent by a client to a proxy.",
	"Method": "void setProxyChallengeResponse(ChallengeResponse response){\r\n    getWrappedRequest().setProxyChallengeResponse(response);\r\n}"
}, {
	"Path": "org.restlet.ext.apispark.internal.agent.AgentUtils.getClientResource",
	"Comment": "returns a client resource configured to communicate with the apisparkconnector cell.",
	"Method": "T getClientResource(ApiSparkConfig apiSparkConfig,ModulesSettings modulesSettings,Class<T> resourceClass,String resourcePath){\r\n    ClientResource clientResource = new ClientResource(buildResourcePath(apiSparkConfig, resourcePath));\r\n    clientResource.accept(MediaType.APPLICATION_JSON);\r\n    clientResource.setChallengeResponse(ChallengeScheme.HTTP_BASIC, apiSparkConfig.getAgentLogin(), apiSparkConfig.getAgentPassword());\r\n    Series<Header> headers = clientResource.getRequest().getHeaders();\r\n    headers.add(AgentConstants.REQUEST_HEADER_CONNECTOR_AGENT_VERSION, AgentConstants.AGENT_VERSION);\r\n    if (modulesSettings != null) {\r\n        headers.add(AgentConstants.REQUEST_HEADER_CONNECTOR_CELL_REVISION, modulesSettings.getCellRevision());\r\n    }\r\n    return clientResource.wrap(resourceClass, AgentUtils.class.getClassLoader());\r\n}"
}, {
	"Path": "org.restlet.engine.converter.ConverterHelper.addObjectClass",
	"Comment": "adds an object class to the given list. creates a new list if necessary.",
	"Method": "List<Class<?>> addObjectClass(List<Class<?>> objectClasses,Class<?> objectClass){\r\n    if (objectClasses == null) {\r\n        objectClasses = new ArrayList<Class<?>>();\r\n    }\r\n    objectClasses.add(objectClass);\r\n    return objectClasses;\r\n}"
}]