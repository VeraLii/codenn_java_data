[{
	"Path": "com.sun.enterprise.security.cli.DeletePasswordAlias.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        domainPasswordAliasStore.remove(aliasName);\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n        reportFailure(report, ex);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowPlayer.enterBed",
	"Comment": "this player enters the specified bed and is marked as sleeping.",
	"Method": "void enterBed(GlowBlock block){\r\n    checkNotNull(block, \"Bed block cannot be null\");\r\n    Preconditions.checkState(bed == null, \"Player already in bed\");\r\n    GlowBlock head = BlockBed.getHead(block);\r\n    GlowBlock foot = BlockBed.getFoot(block);\r\n    if (EventFactory.getInstance().callEvent(new PlayerBedEnterEvent(this, head)).isCancelled()) {\r\n        return;\r\n    }\r\n    BlockBed.setOccupied(head, foot, true);\r\n    bed = head;\r\n    sleeping = true;\r\n    setRawLocation(head.getLocation(), false);\r\n    getSession().send(new UseBedMessage(SELF_ID, head.getX(), head.getY(), head.getZ()));\r\n    UseBedMessage msg = new UseBedMessage(getEntityId(), head.getX(), head.getY(), head.getZ());\r\n    world.getRawPlayers().stream().filter(p -> p != this && p.canSeeEntity(this)).forEach(p -> p.getSession().send(msg));\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.chooseServerAlias",
	"Comment": "choose the server alias that will be used to select the servercertificate for ssl server auth.",
	"Method": "String chooseServerAlias(String keyType,Principal[] issuers,Socket socket){\r\n    String serverAlias = null;\r\n    if (this.alias != null) {\r\n        serverAlias = this.alias;\r\n    } else {\r\n        serverAlias = mgr.chooseServerAlias(keyType, issuers, socket);\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"Choosing server alias :{0}\", serverAlias);\r\n    }\r\n    return serverAlias;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreatePasswordAlias.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        if (domainPasswordAliasStore.containsKey(aliasName)) {\r\n            report.setMessage(localStrings.getLocalString(\"create.password.alias.alreadyexists\", \"Password alias with the specified name already exists. \" + \"Please use the update-password-alias command to change it\", aliasName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n        domainPasswordAliasStore.put(aliasName, aliasPassword.toCharArray());\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n        report.setMessage(localStrings.getLocalString(\"create.password.alias.fail\", \"Creation of Password Alias {0} failed\", aliasName) + \"  \" + ex.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(ex);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "net.glowstone.generator.biomegrid.BiomeVariationMapLayer.mergeValues",
	"Comment": "generates a rectangle using the previous layer and the variation layer.",
	"Method": "int[] mergeValues(int x,int z,int sizeX,int sizeZ){\r\n    int gridX = x - 1;\r\n    int gridZ = z - 1;\r\n    int gridSizeX = sizeX + 2;\r\n    int gridSizeZ = sizeZ + 2;\r\n    int[] values = belowLayer.generateValues(gridX, gridZ, gridSizeX, gridSizeZ);\r\n    int[] variationValues = variationLayer.generateValues(gridX, gridZ, gridSizeX, gridSizeZ);\r\n    int[] finalValues = new int[sizeX * sizeZ];\r\n    for (int i = 0; i < sizeZ; i++) {\r\n        for (int j = 0; j < sizeX; j++) {\r\n            setCoordsSeed(x + j, z + i);\r\n            int centerValue = values[j + 1 + (i + 1) * gridSizeX];\r\n            int variationValue = variationValues[j + 1 + (i + 1) * gridSizeX];\r\n            if (centerValue != 0 && variationValue == 3 && centerValue < 128) {\r\n                finalValues[j + i * sizeX] = GlowBiome.getBiome(centerValue + 128) != null ? centerValue + 128 : centerValue;\r\n            } else if (variationValue == 2 || nextInt(3) == 0) {\r\n                int val = centerValue;\r\n                if (VARIATIONS.containsKey(centerValue)) {\r\n                    val = VARIATIONS.get(centerValue)[nextInt(VARIATIONS.get(centerValue).length)];\r\n                } else if (centerValue == GlowBiome.getId(DEEP_OCEAN) && nextInt(3) == 0) {\r\n                    val = ISLANDS[nextInt(ISLANDS.length)];\r\n                }\r\n                if (variationValue == 2 && val != centerValue) {\r\n                    val = GlowBiome.getBiome(val + 128) != null ? val + 128 : centerValue;\r\n                }\r\n                if (val != centerValue) {\r\n                    int count = 0;\r\n                    if (values[j + 1 + i * gridSizeX] == centerValue) {\r\n                        count++;\r\n                    }\r\n                    if (values[j + 1 + (i + 2) * gridSizeX] == centerValue) {\r\n                        count++;\r\n                    }\r\n                    if (values[j + (i + 1) * gridSizeX] == centerValue) {\r\n                        count++;\r\n                    }\r\n                    if (values[j + 2 + (i + 1) * gridSizeX] == centerValue) {\r\n                        count++;\r\n                    }\r\n                    finalValues[j + i * sizeX] = count < 3 ? centerValue : val;\r\n                } else {\r\n                    finalValues[j + i * sizeX] = val;\r\n                }\r\n            } else {\r\n                finalValues[j + i * sizeX] = centerValue;\r\n            }\r\n        }\r\n    }\r\n    return finalValues;\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.getAttributeResolvers",
	"Comment": "determines the current list of attributeresolver instances,in execution order.",
	"Method": "List<AzAttributeResolver> getAttributeResolvers(){\r\n    return new ArrayList<AzAttributeResolver>(attributeResolvers);\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.Dom.skipFromXml",
	"Comment": "this method should be invoked if this dom should not be persistedto the domain.xml file.",
	"Method": "void skipFromXml(){\r\n    writeToXml = false;\r\n}"
}, {
	"Path": "net.glowstone.block.blocktype.BlockRedstone.calculateConnections",
	"Comment": "calculates the block data value for a redstone wire block, based on the adjacent blocks, sothat appropriate connections are formed.",
	"Method": "List<BlockFace> calculateConnections(GlowBlock block){\r\n    List<BlockFace> value = new ArrayList();\r\n    List<BlockFace> connections = new ArrayList();\r\n    value.add(BlockFace.DOWN);\r\n    for (BlockFace face : SIDES) {\r\n        GlowBlock target = block.getRelative(face);\r\n        switch(target.getType()) {\r\n            case DIODE_BLOCK_ON:\r\n            case DIODE_BLOCK_OFF:\r\n                Diode diode = (Diode) target.getState().getData();\r\n                if (face == diode.getFacing() || face == diode.getFacing().getOppositeFace()) {\r\n                    connections.add(face);\r\n                }\r\n                break;\r\n            case REDSTONE_BLOCK:\r\n            case REDSTONE_TORCH_ON:\r\n            case REDSTONE_TORCH_OFF:\r\n            case REDSTONE_WIRE:\r\n            case WOOD_BUTTON:\r\n            case STONE_BUTTON:\r\n            case LEVER:\r\n            case OBSERVER:\r\n                connections.add(face);\r\n                break;\r\n            default:\r\n                if (target.getType().isSolid() && !block.getRelative(BlockFace.UP).getType().isSolid() && target.getRelative(BlockFace.UP).getType() == Material.REDSTONE_WIRE) {\r\n                    connections.add(face);\r\n                } else if (!target.getType().isSolid() && target.getRelative(BlockFace.DOWN).getType() == Material.REDSTONE_WIRE) {\r\n                    connections.add(face);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    if (connections.isEmpty()) {\r\n        value.addAll(Arrays.asList(SIDES));\r\n    } else {\r\n        value.addAll(connections);\r\n        if (connections.size() == 1) {\r\n            value.add(connections.get(0).getOppositeFace());\r\n        }\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "net.glowstone.block.GlowBlock.applyPhysics",
	"Comment": "notify this block and its surrounding blocks that this block has changed type and data.",
	"Method": "void applyPhysics(Material oldType,int newTypeId,byte oldData,byte newData){\r\n    ItemTable itemTable = ItemTable.instance();\r\n    Material newType = Material.getMaterial(newTypeId);\r\n    for (int y = -1; y <= 1; y++) {\r\n        for (BlockFace face : LAYER) {\r\n            if (y == 0 && face == BlockFace.SELF) {\r\n                continue;\r\n            }\r\n            GlowBlock notify = getRelative(face.getModX(), face.getModY() + y, face.getModZ());\r\n            BlockFace blockFace;\r\n            if (y == 0) {\r\n                blockFace = face.getOppositeFace();\r\n            } else if (y == -1 && face == BlockFace.SELF) {\r\n                blockFace = BlockFace.UP;\r\n            } else if (y == 1 && face == BlockFace.SELF) {\r\n                blockFace = BlockFace.DOWN;\r\n            } else {\r\n                blockFace = null;\r\n            }\r\n            BlockType notifyType = itemTable.getBlock(notify.getType());\r\n            if (notifyType != null) {\r\n                notifyType.onNearBlockChanged(notify, blockFace, this, oldType, oldData, newType, newData);\r\n            }\r\n        }\r\n    }\r\n    BlockType type = itemTable.getBlock(oldType);\r\n    if (type != null) {\r\n        type.onBlockChanged(this, oldType, oldData, newType, newData);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.inventory.WindowClickLogic.isPickupAction",
	"Comment": "check if a given inventoryaction involves taking items from the slot.",
	"Method": "boolean isPickupAction(InventoryAction action){\r\n    switch(action) {\r\n        case PICKUP_ALL:\r\n        case PICKUP_HALF:\r\n        case PICKUP_ONE:\r\n        case PICKUP_SOME:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.common.ServerLoginCallbackHandler.handle",
	"Comment": "this is the callback method called when authentication data isrequired. it either pops up a dialog box to request authenticationdata or use text input.",
	"Method": "void handle(Callback[] callbacks){\r\n    for (int i = 0; i < callbacks.length; i++) {\r\n        if (callbacks[i] instanceof NameCallback) {\r\n            NameCallback nme = (NameCallback) callbacks[i];\r\n            nme.setName(username);\r\n        } else if (callbacks[i] instanceof PasswordCallback) {\r\n            PasswordCallback pswd = (PasswordCallback) callbacks[i];\r\n            pswd.setPassword(password);\r\n        } else if (callbacks[i] instanceof CertificateRealm.AppContextCallback) {\r\n            ((CertificateRealm.AppContextCallback) callbacks[i]).setModuleID(moduleID);\r\n        } else if (GP_CB.equals(callbacks[i].getClass().getName())) {\r\n            processGroupPrincipal(callbacks[i]);\r\n        } else {\r\n            throw new UnsupportedCallbackException(callbacks[i]);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.generator.biomegrid.BiomeVariationMapLayer.generateRandomValues",
	"Comment": "generates a rectangle, replacing all the positive values in the previous layer with randomvalues from 2 to 31 while leaving zero and negative values unchanged.",
	"Method": "int[] generateRandomValues(int x,int z,int sizeX,int sizeZ){\r\n    int[] values = belowLayer.generateValues(x, z, sizeX, sizeZ);\r\n    int[] finalValues = new int[sizeX * sizeZ];\r\n    for (int i = 0; i < sizeZ; i++) {\r\n        for (int j = 0; j < sizeX; j++) {\r\n            int val = values[j + i * sizeX];\r\n            if (val > 0) {\r\n                setCoordsSeed(x + j, z + i);\r\n                val = nextInt(30) + 2;\r\n            }\r\n            finalValues[j + i * sizeX] = val;\r\n        }\r\n    }\r\n    return finalValues;\r\n}"
}, {
	"Path": "org.glassfish.osgi.cli.interactive.LocalOSGiShellCommand.validate",
	"Comment": "the validate method validates that the type and quantity ofparameters and operands matches the requirements for thiscommand.the validate method supplies missing options fromthe environment.",
	"Method": "void validate(){\r\n    if (printPromptOpt != null) {\r\n        printPrompt = printPromptOpt.booleanValue();\r\n    } else {\r\n        printPrompt = programOpts.isInteractive();\r\n    }\r\n    echo = programOpts.isEcho();\r\n}"
}, {
	"Path": "org.glassfish.resourcebase.resources.listener.ResourceManager.getResourceDeployer",
	"Comment": "given a resource instance, appropriate deployer will be provided",
	"Method": "ResourceDeployer getResourceDeployer(Object resource){\r\n    return resourceManagerFactoryProvider.get().getResourceDeployer(resource);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.unsetClientSecurityContext",
	"Comment": "unsets the current appclient security context on the threadlocal storage",
	"Method": "void unsetClientSecurityContext(){\r\n    ClientSecurityContext.setCurrent(null);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.UsernamePasswordStore.reset",
	"Comment": "clears the username and password, that might have been previously stored,either globally or locally to each thread.",
	"Method": "void reset(){\r\n    if (isPerThreadAuth) {\r\n        localUpc.set(null);\r\n    } else {\r\n        synchronized (UsernamePasswordStore.class) {\r\n            sharedUpc = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.ConfigSupport.proxyType",
	"Comment": "returns the type of configuration object this config proxy represents.",
	"Method": "Class<T> proxyType(T element){\r\n    ConfigView bean = getImpl(element);\r\n    return bean.getProxyType();\r\n}"
}, {
	"Path": "net.glowstone.util.Position.getIntPitch",
	"Comment": "gets an integer approximation of the pitch between 0 and 255.",
	"Method": "int getIntPitch(Location loc){\r\n    return (int) (loc.getPitch() % 360 / 360 * 256);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.common.PasswordCredential.equals",
	"Comment": "compare two instances of the credential and return true if they arethe same and false otherwise.",
	"Method": "boolean equals(Object o){\r\n    if (o instanceof PasswordCredential) {\r\n        PasswordCredential pc = (PasswordCredential) o;\r\n        if (pc.getUser().equals(username) && Arrays.equals(pc.getPassword(), password) && pc.getRealm().equals(realm)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.BaseRealm.getAuthenticationHandler",
	"Comment": "returns an authenticationhandler object which can be used to authenticate within this realm.this method return null always, since authenticationhandlersare generally not supported by ias realms. subclass can overrideif necessary.",
	"Method": "AuthenticationHandler getAuthenticationHandler(){\r\n    _logger.warning(\"iasrealm.noauth\");\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.UsernamePasswordStore.resetThreadLocalOnly",
	"Comment": "clears the username and password only is they were stored locallyto each thread",
	"Method": "void resetThreadLocalOnly(){\r\n    if (isPerThreadAuth) {\r\n        localUpc.set(null);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.util.mojangson.Mojangson.parseShort",
	"Comment": "parses a short value from a mojangson string as an nbt shorttag.",
	"Method": "ShortTag parseShort(String mojangson){\r\n    Character lastChar = mojangson.charAt(mojangson.length() - 1);\r\n    if (lastChar.toString().toLowerCase().charAt(0) == MojangsonToken.SHORT_SUFFIX.getSymbol()) {\r\n        mojangson = mojangson.substring(0, mojangson.length() - 1);\r\n    }\r\n    try {\r\n        return new ShortTag(Short.valueOf(mojangson));\r\n    } catch (NumberFormatException nfe) {\r\n        throw new MojangsonParseException(\"\\'\" + mojangson + \"\\'\", MojangsonParseException.ParseExceptionReason.INVALID_FORMAT_NUM);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.getReasonInitializationFailed",
	"Comment": "determines the reason why the service failed to initialize.",
	"Method": "String getReasonInitializationFailed(){\r\n    return reasonInitFailed;\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.isNumeric",
	"Comment": "test whether the subtag with the given key is of a numeric type.",
	"Method": "boolean isNumeric(String key){\r\n    return is(key, NumericTag.class);\r\n}"
}, {
	"Path": "net.glowstone.block.blocktype.BlockType.setPlaceSound",
	"Comment": "sets the sound that will be played when a player places the block.",
	"Method": "void setPlaceSound(Sound sound){\r\n    placeSound = new SoundInfo(sound, 1F, 0.75F);\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowEntity.pulse",
	"Comment": "called every game cycle. subclasses should implement this to implement periodic functionalitye.g. mob ai.",
	"Method": "void pulse(){\r\n    ticksLived++;\r\n    if (!getLocation().getChunk().isLoaded()) {\r\n        return;\r\n    }\r\n    if (fireTicks > 0) {\r\n        --fireTicks;\r\n    }\r\n    metadata.setBit(MetadataIndex.STATUS, StatusFlags.ON_FIRE, fireTicks > 0);\r\n    if (ticksLived % (30 * 20) == 0) {\r\n        if (!(this instanceof GlowItemFrame || this instanceof GlowPainting)) {\r\n            teleported = true;\r\n        }\r\n    }\r\n    if (this instanceof GlowLivingEntity && !isDead() && ((GlowLivingEntity) this).hasAI() && this.getLocation().getChunk().isLoaded()) {\r\n        GlowLivingEntity entity = (GlowLivingEntity) this;\r\n        entity.getTaskManager().pulse();\r\n    }\r\n    followLead();\r\n    pulsePhysics();\r\n    if (hasMoved()) {\r\n        Block currentBlock = location.getBlock();\r\n        if (currentBlock.getType() == Material.ENDER_PORTAL) {\r\n            EventFactory.getInstance().callEvent(new EntityPortalEnterEvent(this, currentBlock.getLocation()));\r\n            if (server.getAllowEnd()) {\r\n                Location previousLocation = location.clone();\r\n                boolean success;\r\n                if (getWorld().getEnvironment() == Environment.THE_END) {\r\n                    success = teleportToSpawn();\r\n                } else {\r\n                    success = teleportToEnd();\r\n                }\r\n                if (success) {\r\n                    EntityPortalExitEvent e = EventFactory.getInstance().callEvent(new EntityPortalExitEvent(this, previousLocation, location.clone(), velocity.clone(), new Vector()));\r\n                    if (!e.getAfter().equals(velocity)) {\r\n                        setVelocity(e.getAfter());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (leashHolderUniqueId != null && ticksLived < 2) {\r\n        Optional<GlowEntity> any = world.getEntityManager().getAll().stream().filter(e -> leashHolderUniqueId.equals(e.getUniqueId())).findAny();\r\n        if (!any.isPresent()) {\r\n            world.dropItemNaturally(location, new ItemStack(Material.LEASH));\r\n        }\r\n        setLeashHolder(any.orElse(null));\r\n        leashHolderUniqueId = null;\r\n    }\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.ConfigBean.getOptionalFeature",
	"Comment": "returns an optional feature of the configbean. optional features are implementedby other objects and attached to this instance. attached features can be queriedusing the getoptionalfeature method giving the type of the requestion optionalfeature.",
	"Method": "T getOptionalFeature(Class<T> featureType){\r\n    if (optionalFeatures.containsKey(featureType)) {\r\n        return (T) optionalFeatures.get(featureType).getConfiguration();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.glowstone.scheduler.WorldScheduler.getWorlds",
	"Comment": "returns an immutable list of the currently scheduled worlds.",
	"Method": "List<GlowWorld> getWorlds(){\r\n    Builder<GlowWorld> ret = ImmutableList.builder();\r\n    for (WorldEntry entry : worlds) {\r\n        ret.add(entry.world);\r\n    }\r\n    return ret.build();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.loginPrincipal",
	"Comment": "this method is used for logging in a run as principal. it createsa jaas subject whose credential is to type gssupname.this is used primarily for runas",
	"Method": "void loginPrincipal(String username,String realmName){\r\n    if (realmName == null || realmName.length() == 0) {\r\n        realmName = Realm.getDefaultRealm();\r\n    }\r\n    final Subject s = new Subject();\r\n    final org.glassfish.security.common.PrincipalImpl p = new org.glassfish.security.common.PrincipalImpl(username);\r\n    final GSSUPName name = new GSSUPName(username, realmName);\r\n    AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n        public java.lang.Object run() {\r\n            s.getPrincipals().add(p);\r\n            s.getPublicCredentials().add(name);\r\n            return null;\r\n        }\r\n    });\r\n    try {\r\n        Realm realm = Realm.getInstance(realmName);\r\n        Enumeration en = realm.getGroupNames(username);\r\n        Set<Principal> principalSet = s.getPrincipals();\r\n        while (en.hasMoreElements()) {\r\n            principalSet.add(new Group((String) en.nextElement()));\r\n        }\r\n    } catch (InvalidOperationException ex) {\r\n        _logger.log(Level.WARNING, SecurityLoggerInfo.invalidOperationForRealmError, new Object[] { username, realmName, ex.toString() });\r\n    } catch (NoSuchUserException ex) {\r\n        _logger.log(Level.WARNING, SecurityLoggerInfo.noSuchUserInRealmError, new Object[] { username, realmName, ex.toString() });\r\n    } catch (NoSuchRealmException ex) {\r\n        LoginException lex = new LoginException(ex.toString());\r\n        lex.initCause(ex);\r\n        throw lex;\r\n    }\r\n    setSecurityContext(username, s, realmName);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.loginPrincipal",
	"Comment": "this method is used for logging in a run as principal. it createsa jaas subject whose credential is to type gssupname.this is used primarily for runas",
	"Method": "void loginPrincipal(String username,String realmName){\r\n    s.getPrincipals().add(p);\r\n    s.getPublicCredentials().add(name);\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.PasswordLoginModule.authenticateUser",
	"Comment": "older implementations can implement authenticate. while new implementationcalls authenticateuser",
	"Method": "void authenticateUser(){\r\n    authenticate();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.postClientAuth",
	"Comment": "extract the relevant username and realm information from thesubject and sets the correct state in the security context. therelevant information is set into the thread local storage fromwhich then is extracted to send over the wire.",
	"Method": "void postClientAuth(Subject subject,Class<?> clazz){\r\n    final Class<?> clas = clazz;\r\n    final Subject fs = subject;\r\n    Set credset = (Set) AppservAccessController.doPrivileged(new PrivilegedAction<Set>() {\r\n        public Set run() {\r\n            if (_logger.isLoggable(Level.FINEST)) {\r\n                _logger.log(Level.FINEST, \"LCD post login subject :{0}\", fs);\r\n            }\r\n            return fs.getPrivateCredentials(clas);\r\n        }\r\n    });\r\n    final Iterator iter = credset.iterator();\r\n    while (iter.hasNext()) {\r\n        Object obj = null;\r\n        try {\r\n            obj = AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n                public java.lang.Object run() {\r\n                    return iter.next();\r\n                }\r\n            });\r\n        } catch (Exception e) {\r\n            _logger.log(Level.SEVERE, SecurityLoggerInfo.securityAccessControllerActionError, e);\r\n        }\r\n        if (obj instanceof PasswordCredential) {\r\n            PasswordCredential p = (PasswordCredential) obj;\r\n            String user = p.getUser();\r\n            if (_logger.isLoggable(Level.FINEST)) {\r\n                String realm = p.getRealm();\r\n                _logger.log(Level.FINEST, \"In LCD user-pass login:{0} realm :{1}\", new Object[] { user, realm });\r\n            }\r\n            setClientSecurityContext(user, fs);\r\n            return;\r\n        } else if (obj instanceof X509CertificateCredential) {\r\n            X509CertificateCredential p = (X509CertificateCredential) obj;\r\n            String user = p.getAlias();\r\n            if (_logger.isLoggable(Level.FINEST)) {\r\n                String realm = p.getRealm();\r\n                _logger.log(Level.FINEST, \"In LCD cert-login::{0} realm :{1}\", new Object[] { user, realm });\r\n            }\r\n            setClientSecurityContext(user, fs);\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.postClientAuth",
	"Comment": "extract the relevant username and realm information from thesubject and sets the correct state in the security context. therelevant information is set into the thread local storage fromwhich then is extracted to send over the wire.",
	"Method": "void postClientAuth(Subject subject,Class<?> clazz){\r\n    if (_logger.isLoggable(Level.FINEST)) {\r\n        _logger.log(Level.FINEST, \"LCD post login subject :{0}\", fs);\r\n    }\r\n    return fs.getPrivateCredentials(clas);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.postClientAuth",
	"Comment": "extract the relevant username and realm information from thesubject and sets the correct state in the security context. therelevant information is set into the thread local storage fromwhich then is extracted to send over the wire.",
	"Method": "void postClientAuth(Subject subject,Class<?> clazz){\r\n    return iter.next();\r\n}"
}, {
	"Path": "net.glowstone.generator.structures.util.StructureBoundingBox.isVectorInside",
	"Comment": "checks whether the given point is inside a block that intersects this box.",
	"Method": "boolean isVectorInside(Vector vec){\r\n    return vec.getBlockX() >= min.getBlockX() && vec.getBlockX() <= max.getBlockX() && vec.getBlockY() >= min.getBlockY() && vec.getBlockY() <= max.getBlockY() && vec.getBlockZ() >= min.getBlockZ() && vec.getBlockZ() <= max.getBlockZ();\r\n}"
}, {
	"Path": "net.glowstone.util.mojangson.Mojangson.parseByte",
	"Comment": "parses a byte value from a mojangson string as an nbt bytetag.",
	"Method": "ByteTag parseByte(String mojangson){\r\n    Character lastChar = mojangson.charAt(mojangson.length() - 1);\r\n    if (lastChar.toString().toLowerCase().charAt(0) == BYTE_SUFFIX.getSymbol()) {\r\n        mojangson = mojangson.substring(0, mojangson.length() - 1);\r\n    }\r\n    try {\r\n        return new ByteTag(Byte.valueOf(mojangson));\r\n    } catch (NumberFormatException nfe) {\r\n        throw new MojangsonParseException(\"\\'\" + mojangson + \"\\'\", MojangsonParseException.ParseExceptionReason.INVALID_FORMAT_NUM);\r\n    }\r\n}"
}, {
	"Path": "org.jvnet.tiger_types.GenericArrayTypeImpl.getGenericComponentType",
	"Comment": "returnsa type object representing the component typeof this array.",
	"Method": "Type getGenericComponentType(){\r\n    return genericComponentType;\r\n}"
}, {
	"Path": "net.glowstone.block.blocktype.BlockType.placeBlock",
	"Comment": "called when a block is placed to calculate what the block will become.",
	"Method": "void placeBlock(GlowPlayer player,GlowBlockState state,BlockFace face,ItemStack holding,Vector clickedLoc){\r\n    state.setType(holding.getType());\r\n    state.setData(holding.getData());\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.file.FileRealm.authenticate",
	"Comment": "authenticates a user.this method is invoked by the fileloginmodule in order toauthenticate a user in the file realm. the authentication decisionis kept within the realm class implementation in order to keepthe password cache in a single location with no public accessors,to simplify future improvements.",
	"Method": "String[] authenticate(String user,char[] password){\r\n    String[] groups = helper.authenticate(user, password);\r\n    if (groups != null) {\r\n        groups = addAssignGroups(groups);\r\n    }\r\n    return groups;\r\n}"
}, {
	"Path": "com.iplanet.ias.security.auth.login.PasswordLoginModule.authenticateUser",
	"Comment": "authenticateuser calls authenticate which is implemented by the implementationof this subclass",
	"Method": "void authenticateUser(){\r\n    AuthenticationStatus as = authenticate();\r\n    if (as.getStatus() == as.AUTH_SUCCESS)\r\n        return;\r\n    else {\r\n        throw new LoginException();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.security.services.commands.LDAPAdminAccessConfigurator.deleteRealm",
	"Comment": "delete and create a new realm to replace it in a single transaction",
	"Method": "void deleteRealm(SecurityService w_ss,StringBuilder sb){\r\n    AuthRealm oldAdminRealm = getAdminRealm(w_ss);\r\n    w_ss.getAuthRealm().remove(oldAdminRealm);\r\n    appendNL(sb, \"...\");\r\n}"
}, {
	"Path": "net.glowstone.util.UuidUtils.toFlatString",
	"Comment": "converts a uuid to a hexadecimal string without hyphens.this method uses the fastuuid library for faster serialization in java 8.",
	"Method": "String toFlatString(UUID uuid){\r\n    return toString(uuid).replace(\"-\", \"\");\r\n}"
}, {
	"Path": "org.glassfish.extras.osgicontainer.OSGiSniffer.supportsArchiveType",
	"Comment": "this api is used to help determine if the sniffer should recognizethe current archive.if the sniffer does not support the archive type associated withthe current deployment, the sniffer should not recognize the archive.",
	"Method": "boolean supportsArchiveType(ArchiveType archiveType){\r\n    if (archiveType.toString().equals(osgiArchiveType.toString())) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.glowstone.util.bans.UuidListFile.remove",
	"Comment": "if the given player is on this list, removes that player and saves the change to disk.",
	"Method": "void remove(GlowPlayerProfile profile){\r\n    UUID playerUuid = profile.getId();\r\n    entriesByUuid.remove(playerUuid);\r\n    Iterator<BaseEntry> iter = entries.iterator();\r\n    boolean modified = false;\r\n    while (iter.hasNext()) {\r\n        if (((Entry) iter.next()).uuid.equals(playerUuid)) {\r\n            iter.remove();\r\n            modified = true;\r\n        }\r\n    }\r\n    if (modified) {\r\n        save();\r\n    }\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.test.ConfigTest.runTestsInOrder",
	"Comment": "this test is an unfortunate reaction to the fact that jdk 7 does not run thetests above in order, and that the fact that the ordering seems to be importantto the passing of the above tests",
	"Method": "void runTestsInOrder(){\r\n    lookupAllInjectors();\r\n    lookupInjectorByName();\r\n    testLookupOfInjectorAndCheckIfActive();\r\n    lookupInjectorByFilter();\r\n    parseDomainXml();\r\n    lookupConnectorServiceAndEnsureNotActive();\r\n    getConnectorServiceAndCheckIfActive();\r\n    testConfig();\r\n    testDefaultValuesFromConfig();\r\n    testDom();\r\n    testHabitatFromDom();\r\n    testDomTx();\r\n    testDomTxReadOnlyAttributes();\r\n    testGetImplAndAddListener();\r\n    testGetConfigBean();\r\n    testGenericContainerInjector();\r\n    testLongDataType();\r\n    testIntDataType();\r\n    testConfigurationPopulator();\r\n    testSingletonProxy();\r\n}"
}, {
	"Path": "net.glowstone.util.ReflectionProcessor.invokeMethod",
	"Comment": "returns the returned value of an invoked method in a contextual object.",
	"Method": "Object invokeMethod(Object context,String name,String parameters){\r\n    try {\r\n        ArrayList<Object> params = new ArrayList();\r\n        for (String parameter : parameters) {\r\n            Object result = new ReflectionProcessor(parameter, this.context).process();\r\n            if (result != null) {\r\n                params.add(result);\r\n            }\r\n        }\r\n        Class[] classes = new Class[params.size()];\r\n        for (int i = 0; i < params.size(); i++) {\r\n            Object param = params.get(i);\r\n            classes[i] = param.getClass();\r\n        }\r\n        Class clazz = context.getClass();\r\n        if (context instanceof Class) {\r\n            clazz = (Class) context;\r\n        }\r\n        Method method = getMethod(name, clazz, classes);\r\n        if (!method.isAccessible()) {\r\n            method.setAccessible(true);\r\n        }\r\n        return method.invoke(context, params.toArray(new Object[params.size()]));\r\n    } catch (ReflectiveOperationException e) {\r\n        e.printStackTrace();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.glowstone.constants.ItemIds.getBlock",
	"Comment": "get the material corresponding to the specified block identifier.",
	"Method": "Material getBlock(String name){\r\n    if (!blocks.containsKey(name)) {\r\n        return null;\r\n    }\r\n    return Material.getMaterial(blocks.get(name));\r\n}"
}, {
	"Path": "net.glowstone.net.query.QueryServer.verifyChallengeToken",
	"Comment": "verify that the request is using the correct challenge token.",
	"Method": "boolean verifyChallengeToken(InetSocketAddress address,int token){\r\n    return Objects.equals(challengeTokens.get(address), token);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.JarSigner.getExistingSignatureFile",
	"Comment": "if jar is signed, return existing signature file, else return null.",
	"Method": "byte[] getExistingSignatureFile(JarFile jf){\r\n    Enumeration<JarEntry> entries = jf.entries();\r\n    JarEntry je = null;\r\n    while (entries.hasMoreElements()) {\r\n        JarEntry cje = entries.nextElement();\r\n        if (cje.getName().startsWith(\"META-INF/\") && cje.getName().endsWith(\".SF\")) {\r\n            je = cje;\r\n            break;\r\n        }\r\n    }\r\n    return readJarEntry(jf, je);\r\n}"
}, {
	"Path": "net.glowstone.inventory.GlowInventory.initialize",
	"Comment": "initializes some key components of this inventory.this should be called in the constructor.",
	"Method": "void initialize(List<GlowInventorySlot> slots,Set<HumanEntity> viewers,InventoryHolder owner,InventoryType type,String title){\r\n    this.slots = slots;\r\n    this.viewers = viewers;\r\n    this.holder = owner;\r\n    this.type = type;\r\n    this.title = title;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.Realm.init",
	"Comment": "initialize a realm with some properties.this can be usedwhen instantiating realms from their descriptions.thismethod may only be called a single time.",
	"Method": "void init(Properties props){\r\n    String groupList = props.getProperty(PARAM_GROUPS);\r\n    if (groupList != null && groupList.length() > 0) {\r\n        this.setProperty(PARAM_GROUPS, groupList);\r\n        assignGroups = new ArrayList<String>();\r\n        StringTokenizer st = new StringTokenizer(groupList, GROUPS_SEP);\r\n        while (st.hasMoreTokens()) {\r\n            String grp = (String) st.nextToken();\r\n            if (!assignGroups.contains(grp)) {\r\n                assignGroups.add(grp);\r\n            }\r\n        }\r\n    }\r\n    String groupMapping = props.getProperty(PARAM_GROUP_MAPPING);\r\n    if (groupMapping != null) {\r\n        groupMapper = new GroupMapper();\r\n        groupMapper.parse(groupMapping);\r\n    }\r\n    String defaultDigestAlgo = null;\r\n    if (_getRealmsManager() != null) {\r\n        defaultDigestAlgo = _getRealmsManager().getDefaultDigestAlgorithm();\r\n    }\r\n    this.defaultDigestAlgorithm = (defaultDigestAlgo == null) ? DEFAULT_DEF_DIG_ALGO_VAL : defaultDigestAlgo;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.ldap.LDAPRealm.getGroupNames",
	"Comment": "returns the name of all the groups that this user belongs to.note that this information is only known after the user haslogged in. this is called from web path role verification, thoughit should not be.",
	"Method": "Enumeration getGroupNames(String username){\r\n    Vector v = (Vector) groupCache.get(username);\r\n    if (v == null) {\r\n        List<String> searchedGrps = getGroups(username);\r\n        if (searchedGrps != null) {\r\n            return Collections.enumeration(searchedGrps);\r\n        }\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"No groups available for: \" + username);\r\n        }\r\n        return emptyVector.elements();\r\n    } else {\r\n        if (groupMapper != null) {\r\n            Vector ret = new Vector();\r\n            ret.addAll(v);\r\n            ArrayList<String> result = new ArrayList<String>();\r\n            for (Object o : v) {\r\n                String grp = (String) o;\r\n                ArrayList<String> tmp = this.getMappedGroupNames(grp);\r\n                result.addAll(tmp);\r\n            }\r\n            ret.addAll(result);\r\n            return ret.elements();\r\n        } else {\r\n            return v.elements();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.util.TextMessage.decode",
	"Comment": "decode a chat message from its textual json representation if possible.",
	"Method": "TextMessage decode(String json){\r\n    JSONParser parser = new JSONParser();\r\n    try {\r\n        Object o = parser.parse(json);\r\n        if (o instanceof JSONObject) {\r\n            return new TextMessage((JSONObject) o);\r\n        } else {\r\n            return new TextMessage(o.toString());\r\n        }\r\n    } catch (ParseException e) {\r\n        return new TextMessage(json);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.unsetSecurityContext",
	"Comment": "set the current security context on the thread local storage to null.",
	"Method": "void unsetSecurityContext(){\r\n    SecurityContext.setCurrent((SecurityContext) null);\r\n}"
}, {
	"Path": "net.glowstone.generator.objects.TerrainObject.killPlantAbove",
	"Comment": "removes the grass, shrub, flower or mushroom directly above the given block, if present. doesnot drop an item.",
	"Method": "boolean killPlantAbove(Block block){\r\n    Block blockAbove = block.getRelative(BlockFace.UP);\r\n    Material mat = blockAbove.getType();\r\n    if (PLANT_TYPES.contains(mat)) {\r\n        if (mat == Material.DOUBLE_PLANT) {\r\n            MaterialData dataAbove = blockAbove.getState().getData();\r\n            if (dataAbove instanceof DoublePlant && ((DoublePlant) dataAbove).getSpecies() == DoublePlantSpecies.PLANT_APEX) {\r\n                blockAbove.getRelative(BlockFace.UP).setType(Material.AIR);\r\n            }\r\n        }\r\n        blockAbove.setType(Material.AIR);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.doX500Login",
	"Comment": "a special case login for x500name credentials.this is invoked for certificate login because the containersextract the x.500 name from the x.509 certificate before callinginto this class.",
	"Method": "void doX500Login(Subject s,String appModuleID){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"Processing X.500 name login.\");\r\n    }\r\n    String user = null;\r\n    String realm_name = null;\r\n    try {\r\n        X500Name x500name = (X500Name) getPublicCredentials(s, X500Name.class);\r\n        user = x500name.getName();\r\n        Realm realm = Realm.getInstance(CertificateRealm.AUTH_TYPE);\r\n        if (realm instanceof CertificateRealm) {\r\n            CertificateRealm certRealm = (CertificateRealm) realm;\r\n            String jaasCtx = certRealm.getJAASContext();\r\n            if (jaasCtx != null) {\r\n                LoginContext lg = new LoginContext(jaasCtx, s, new ServerLoginCallbackHandler(user, null, appModuleID));\r\n                lg.login();\r\n            }\r\n            certRealm.authenticate(s, x500name);\r\n            realm_name = CertificateRealm.AUTH_TYPE;\r\n            if (getAuditManager().isAuditOn()) {\r\n                getAuditManager().authentication(user, realm_name, true);\r\n            }\r\n        } else {\r\n            _logger.warning(SecurityLoggerInfo.certLoginBadRealmError);\r\n            realm_name = realm.getName();\r\n            setSecurityContext(user, s, realm_name);\r\n        }\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.fine(\"X.500 name login succeeded for : \" + user);\r\n        }\r\n    } catch (LoginException le) {\r\n        if (getAuditManager().isAuditOn()) {\r\n            getAuditManager().authentication(user, realm_name, false);\r\n        }\r\n        throw le;\r\n    } catch (Exception ex) {\r\n        throw (LoginException) new LoginException(ex.toString()).initCause(ex);\r\n    }\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.ConfigSupport.defaultPropertyValue",
	"Comment": "kind of insane, just to get the proper return type for my properties.",
	"Method": "List<String> defaultPropertyValue(){\r\n    return null;\r\n}"
}, {
	"Path": "net.glowstone.util.mojangson.Mojangson.parseInt",
	"Comment": "parses an integer value from a mojangson string as an nbt inttag.",
	"Method": "IntTag parseInt(String mojangson){\r\n    try {\r\n        return new IntTag(Integer.valueOf(mojangson));\r\n    } catch (NumberFormatException nfe) {\r\n        throw new MojangsonParseException(\"\\'\" + mojangson + \"\\'\", MojangsonParseException.ParseExceptionReason.INVALID_FORMAT_NUM);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.constants.AttackDamage.getMeleeDurabilityLoss",
	"Comment": "gets the durability loss of the supplied type for a successful hit.",
	"Method": "short getMeleeDurabilityLoss(Material material){\r\n    if (material == null) {\r\n        return 0;\r\n    }\r\n    switch(material) {\r\n        case WOOD_AXE:\r\n        case GOLD_AXE:\r\n        case STONE_AXE:\r\n        case DIAMOND_AXE:\r\n        case WOOD_PICKAXE:\r\n        case GOLD_PICKAXE:\r\n        case IRON_PICKAXE:\r\n        case DIAMOND_PICKAXE:\r\n        case WOOD_SPADE:\r\n        case GOLD_SPADE:\r\n        case IRON_SPADE:\r\n        case DIAMOND_SPADE:\r\n            return 2;\r\n        case WOOD_SWORD:\r\n        case GOLD_SWORD:\r\n        case IRON_SWORD:\r\n        case DIAMOND_SWORD:\r\n            return 1;\r\n        default:\r\n            return 0;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.AuthenticationServiceImpl.getLoginModuleControlFlag",
	"Comment": "convert the string setting to the jaas loginmodulecontrolflag.\tan unknown or null flag value is treated as loginmodulecontrolflag.required.",
	"Method": "LoginModuleControlFlag getLoginModuleControlFlag(String controlFlag){\r\n    LoginModuleControlFlag flag = LoginModuleControlFlag.REQUIRED;\r\n    if (controlFlag != null) {\r\n        if (\"required\".equalsIgnoreCase(controlFlag))\r\n            return flag;\r\n        if (\"sufficient\".equalsIgnoreCase(controlFlag))\r\n            flag = LoginModuleControlFlag.SUFFICIENT;\r\n        else if (\"optional\".equalsIgnoreCase(controlFlag))\r\n            flag = LoginModuleControlFlag.OPTIONAL;\r\n        else if (\"requisite\".equalsIgnoreCase(controlFlag))\r\n            flag = LoginModuleControlFlag.REQUISITE;\r\n    }\r\n    return flag;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginCallbackHandler.getCancelStatus",
	"Comment": "check whether the authentication was cancelled by the user.",
	"Method": "boolean getCancelStatus(){\r\n    boolean cancelled = cancelStatus.get();\r\n    cancelStatus.set(false);\r\n    return cancelled;\r\n}"
}, {
	"Path": "net.glowstone.inventory.crafting.PlayerRecipeMonitor.write",
	"Comment": "populates a recipebook compound subtag and adds it to the given tag.",
	"Method": "void write(CompoundTag playerData){\r\n    CompoundTag recipeBook = new CompoundTag();\r\n    recipeBook.putBool(\"isFilteringCraftable\", filterCraftable);\r\n    recipeBook.putBool(\"isGuiOpen\", bookOpen);\r\n    recipeBook.putStringList(\"recipes\", new ArrayList(recipes));\r\n    recipeBook.putStringList(\"toBeDisplayed\", new ArrayList(toBeDisplayed));\r\n    playerData.putCompound(\"recipeBook\", recipeBook);\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.removeAllAttributeResolvers",
	"Comment": "removes all attributeresolver instances from the currentinternal list of attributeresolver instances.",
	"Method": "boolean removeAllAttributeResolvers(){\r\n    synchronized (attributeResolvers) {\r\n        if (attributeResolvers.isEmpty()) {\r\n            return false;\r\n        } else {\r\n            attributeResolvers.clear();\r\n            return true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowPlayer.spawnAt",
	"Comment": "spawn the player at the given location after they have already joined.used for changing worlds and respawning after death.",
	"Method": "void spawnAt(Location location){\r\n    GlowWorld oldWorld;\r\n    worldLock.writeLock().lock();\r\n    try {\r\n        oldWorld = world;\r\n        world.getEntityManager().unregister(this);\r\n        world = (GlowWorld) location.getWorld();\r\n        world.getEntityManager().register(this);\r\n        updateBossBars();\r\n    } finally {\r\n        worldLock.writeLock().unlock();\r\n    }\r\n    knownChunks.clear();\r\n    chunkLock.clear();\r\n    chunkLock = world.newChunkLock(getName());\r\n    String type = world.getWorldType().getName().toLowerCase();\r\n    session.send(new RespawnMessage(world.getEnvironment().getId(), world.getDifficulty().getValue(), getGameMode().getValue(), type));\r\n    setRawLocation(location, false);\r\n    session.send(new PositionRotationMessage(location));\r\n    teleportedTo = location.clone();\r\n    setCompassTarget(world.getSpawnLocation());\r\n    streamBlocks();\r\n    sendWeather();\r\n    sendRainDensity();\r\n    sendSkyDarkness();\r\n    sendTime();\r\n    updateInventory();\r\n    if (oldWorld != world) {\r\n        session.send(((GlowWorldBorder) world.getWorldBorder()).createMessage());\r\n        EventFactory.getInstance().callEvent(new PlayerChangedWorldEvent(this, oldWorld));\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.GlowWorld.getTickableBlockEntityCount",
	"Comment": "returns the number of tickable block entities in loaded chunkmanager.",
	"Method": "int getTickableBlockEntityCount(){\r\n    int length = 0;\r\n    for (GlowChunk chunk : getChunkManager().getLoadedChunks()) {\r\n        length += chunk.getBlockEntities().length;\r\n    }\r\n    return length;\r\n}"
}, {
	"Path": "net.glowstone.entity.EntityIdManager.allocate",
	"Comment": "allocates the id for an entity. this method performs synchronization as it might be accessedby multiple world threads simultaneously.",
	"Method": "int allocate(GlowEntity entity){\r\n    if (entity.entityId != 0) {\r\n        throw new IllegalStateException(\"Entity already has an id assigned.\");\r\n    }\r\n    int startedAt = lastId;\r\n    for (int id = lastId + 1; id != startedAt; ++id) {\r\n        if (id == -1 || id == 0) {\r\n            continue;\r\n        }\r\n        if (usedIds.add(id)) {\r\n            entity.entityId = id;\r\n            lastId = id;\r\n            return id;\r\n        }\r\n    }\r\n    throw new IllegalStateException(\"No free entity ids\");\r\n}"
}, {
	"Path": "net.glowstone.io.structure.StructureStore.load",
	"Comment": "load structure data of the appropriate type from the given compound tag.",
	"Method": "void load(T structure,CompoundTag compound){\r\n    compound.readIntArray(\"BB\", bb -> {\r\n        if (bb.length == 6) {\r\n            StructureBoundingBox boundingBox = new StructureBoundingBox(new Vector(bb[0], bb[1], bb[2]), new Vector(bb[3], bb[4], bb[5]));\r\n            structure.setBoundingBox(boundingBox);\r\n        }\r\n    });\r\n    compound.iterateCompoundList(\"Children\", tag -> structure.addPiece(StructurePieceStorage.loadStructurePiece(tag)));\r\n}"
}, {
	"Path": "net.glowstone.constants.GlowSound.getVanillaSound",
	"Comment": "returns a vanilla minecraft sound with the given id, or null if none exists.",
	"Method": "Sound getVanillaSound(String id){\r\n    return VANILLA_SOUNDS.get(id);\r\n}"
}, {
	"Path": "net.glowstone.util.InventoryUtil.damageItem",
	"Comment": "inflicts damage to an item. unbreaking enchantment is applied if present.",
	"Method": "ItemStack damageItem(GlowPlayer player,ItemStack holding){\r\n    if (player != null && player.getGameMode() == GameMode.CREATIVE) {\r\n        return holding;\r\n    }\r\n    int durability = holding.getEnchantmentLevel(Enchantment.DURABILITY);\r\n    if (durability > 0 && ThreadLocalRandom.current().nextDouble() < 1 / (durability + 1)) {\r\n        return holding;\r\n    }\r\n    holding.setDurability((short) (holding.getDurability() + 1));\r\n    if (holding.getDurability() == holding.getType().getMaxDurability() + 1) {\r\n        if (player != null) {\r\n            EventFactory.getInstance().callEvent(new PlayerItemBreakEvent(player, holding));\r\n        }\r\n        return createEmptyStack();\r\n    }\r\n    return holding;\r\n}"
}, {
	"Path": "net.glowstone.entity.monster.GlowShulker.setAttachment",
	"Comment": "sets the point where this shulker is attached, or null to detach the shulker.",
	"Method": "void setAttachment(Location attachment){\r\n    this.attachment = attachment;\r\n    if (attachment != null) {\r\n        this.metadata.set(MetadataIndex.SHULKER_ATTACHMENT_POSITION, new BlockVector(attachment.toVector()));\r\n    } else {\r\n        this.metadata.set(MetadataIndex.SHULKER_ATTACHMENT_POSITION, null);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.block.blocktype.BlockBed.isWithinDistance",
	"Comment": "checks whether the entity is within the specified distance from the block.",
	"Method": "boolean isWithinDistance(Entity entity,Block block,int x,int y,int z){\r\n    Location loc = entity.getLocation();\r\n    return Math.abs(loc.getX() - block.getX()) <= x && Math.abs(loc.getY() - block.getY()) <= y && Math.abs(loc.getZ() - block.getZ()) <= z;\r\n}"
}, {
	"Path": "net.glowstone.util.mojangson.Mojangson.parseString",
	"Comment": "parses an string value from a mojangson string as an nbt stringtag.",
	"Method": "StringTag parseString(String mojangson){\r\n    Character lastChar = mojangson.charAt(mojangson.length() - 1);\r\n    Character firstChar = mojangson.charAt(0);\r\n    if (firstChar == STRING_QUOTES.getSymbol() && lastChar == STRING_QUOTES.getSymbol()) {\r\n        return new StringTag(mojangson.substring(1, mojangson.length() - 1));\r\n    } else {\r\n        return new StringTag(mojangson);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.admin.cli.SecureAdminHelperImpl.isAnyAdminUserWithoutPassword",
	"Comment": "returns whether at least one admin user has an empty password.",
	"Method": "boolean isAnyAdminUserWithoutPassword(){\r\n    final FileRealm adminRealm = adminRealm();\r\n    if (adminRealm == null) {\r\n        return false;\r\n    }\r\n    for (final Enumeration<String> e = adminRealm.getUserNames(); e.hasMoreElements(); ) {\r\n        final String username = e.nextElement();\r\n        final String[] groupNames = adminRealm.authenticate(username, emptyPassword);\r\n        if (groupNames != null) {\r\n            for (String groupName : groupNames) {\r\n                if (DOMAIN_ADMIN_GROUP_NAME.equals(groupName)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.glowstone.util.ReflectionProcessor.getMethodParams",
	"Comment": "gets the parameters inside a method parentheses enclosure.",
	"Method": "String[] getMethodParams(String section){\r\n    int level = 0;\r\n    boolean inString = false;\r\n    String current = \"\";\r\n    List<String> parameters = new ArrayList();\r\n    char[] charArray = section.toCharArray();\r\n    for (int i = 0; i < charArray.length; i++) {\r\n        char c = charArray[i];\r\n        if (c == '(' && !inString) {\r\n            level++;\r\n            if (level > 1) {\r\n                current += c;\r\n            }\r\n            continue;\r\n        }\r\n        if (c == ')' && !inString) {\r\n            level--;\r\n            if (level == 0) {\r\n                parameters.add(current);\r\n                current = \"\";\r\n            } else {\r\n                current += c;\r\n            }\r\n            continue;\r\n        }\r\n        if (level == 1 && c == ',' && !inString) {\r\n            parameters.add(current);\r\n            current = \"\";\r\n            continue;\r\n        }\r\n        if (!inString && c == ' ') {\r\n            continue;\r\n        }\r\n        if (c == '\\\"' && section.charAt(i - 1) != '\\\\') {\r\n            inString = !inString;\r\n        }\r\n        if (level > 0) {\r\n            current += c;\r\n        }\r\n    }\r\n    return parameters.toArray(new String[parameters.size()]);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.doClientLogin",
	"Comment": "perform login on the client side.it just simulates the login on the client side.the method uses the callback handlers and generates correctcredential information that will be later sent to the server",
	"Method": "Subject doClientLogin(int type,javax.security.auth.callback.CallbackHandler jaasHandler){\r\n    final javax.security.auth.callback.CallbackHandler handler = jaasHandler;\r\n    final Subject subject = new Subject();\r\n    if (type == SecurityConstants.USERNAME_PASSWORD) {\r\n        AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n            public java.lang.Object run() {\r\n                try {\r\n                    LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n                    lg.login();\r\n                } catch (javax.security.auth.login.LoginException e) {\r\n                    throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        postClientAuth(subject, PasswordCredential.class);\r\n        return subject;\r\n    } else if (type == SecurityConstants.CERTIFICATE) {\r\n        AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n            public java.lang.Object run() {\r\n                try {\r\n                    LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_CERTIFICATE, subject, handler);\r\n                    lg.login();\r\n                } catch (javax.security.auth.login.LoginException e) {\r\n                    throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        postClientAuth(subject, X509CertificateCredential.class);\r\n        return subject;\r\n    } else if (type == SecurityConstants.ALL) {\r\n        AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n            public java.lang.Object run() {\r\n                try {\r\n                    LoginContext lgup = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n                    LoginContext lgc = new LoginContext(SecurityConstants.CLIENT_JAAS_CERTIFICATE, subject, handler);\r\n                    lgup.login();\r\n                    postClientAuth(subject, PasswordCredential.class);\r\n                    lgc.login();\r\n                    postClientAuth(subject, X509CertificateCredential.class);\r\n                } catch (javax.security.auth.login.LoginException e) {\r\n                    throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        return subject;\r\n    } else {\r\n        AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n            public java.lang.Object run() {\r\n                try {\r\n                    LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n                    lg.login();\r\n                    postClientAuth(subject, PasswordCredential.class);\r\n                } catch (javax.security.auth.login.LoginException e) {\r\n                    throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        return subject;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.doClientLogin",
	"Comment": "perform login on the client side.it just simulates the login on the client side.the method uses the callback handlers and generates correctcredential information that will be later sent to the server",
	"Method": "Subject doClientLogin(int type,javax.security.auth.callback.CallbackHandler jaasHandler){\r\n    try {\r\n        LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n        lg.login();\r\n    } catch (javax.security.auth.login.LoginException e) {\r\n        throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.doClientLogin",
	"Comment": "perform login on the client side.it just simulates the login on the client side.the method uses the callback handlers and generates correctcredential information that will be later sent to the server",
	"Method": "Subject doClientLogin(int type,javax.security.auth.callback.CallbackHandler jaasHandler){\r\n    try {\r\n        LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_CERTIFICATE, subject, handler);\r\n        lg.login();\r\n    } catch (javax.security.auth.login.LoginException e) {\r\n        throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.doClientLogin",
	"Comment": "perform login on the client side.it just simulates the login on the client side.the method uses the callback handlers and generates correctcredential information that will be later sent to the server",
	"Method": "Subject doClientLogin(int type,javax.security.auth.callback.CallbackHandler jaasHandler){\r\n    try {\r\n        LoginContext lgup = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n        LoginContext lgc = new LoginContext(SecurityConstants.CLIENT_JAAS_CERTIFICATE, subject, handler);\r\n        lgup.login();\r\n        postClientAuth(subject, PasswordCredential.class);\r\n        lgc.login();\r\n        postClientAuth(subject, X509CertificateCredential.class);\r\n    } catch (javax.security.auth.login.LoginException e) {\r\n        throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.doClientLogin",
	"Comment": "perform login on the client side.it just simulates the login on the client side.the method uses the callback handlers and generates correctcredential information that will be later sent to the server",
	"Method": "Subject doClientLogin(int type,javax.security.auth.callback.CallbackHandler jaasHandler){\r\n    try {\r\n        LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n        lg.login();\r\n        postClientAuth(subject, PasswordCredential.class);\r\n    } catch (javax.security.auth.login.LoginException e) {\r\n        throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.glowstone.entity.physics.BoundingBox.fromPositionAndSize",
	"Comment": "creates a bounding box given its minimum corner and its size.",
	"Method": "BoundingBox fromPositionAndSize(Vector pos,Vector size){\r\n    BoundingBox box = new BoundingBox();\r\n    box.minCorner.copy(pos);\r\n    box.maxCorner.copy(pos.clone().add(size));\r\n    return box;\r\n}"
}, {
	"Path": "net.glowstone.util.GlowHelpMap.loadConfig",
	"Comment": "reads the general topics from help.yml and adds them to the help index.",
	"Method": "void loadConfig(ConfigurationSection config){\r\n    ConfigurationSection general = config.getConfigurationSection(\"general-topics\");\r\n    if (general != null) {\r\n        for (String key : general.getKeys(false)) {\r\n            ConfigurationSection topic = general.getConfigurationSection(key);\r\n            if (topic != null) {\r\n                String shortText = topic.getString(\"shortText\", \"\");\r\n                String fullText = topic.getString(\"fullText\", \"\");\r\n                if (!shortText.isEmpty()) {\r\n                    if (fullText.isEmpty()) {\r\n                        fullText = shortText;\r\n                    } else {\r\n                        fullText = shortText + \"\\n\" + ChatColor.RESET + fullText;\r\n                    }\r\n                }\r\n                addTopic(new GeneralHelpTopic(key, color(shortText), color(fullText), topic.getString(\"permission\", null)));\r\n            }\r\n        }\r\n    }\r\n    ConfigurationSection index = config.getConfigurationSection(\"index-topics\");\r\n    if (index != null) {\r\n        for (String key : index.getKeys(false)) {\r\n            ConfigurationSection topic = index.getConfigurationSection(key);\r\n            if (topic != null) {\r\n                String shortText = color(topic.getString(\"shortText\", \"\"));\r\n                String preamble = color(topic.getString(\"preamble\", null));\r\n                String permission = topic.getString(\"permission\", null);\r\n                HelpTopic helpTopic = new LazyIndexTopic(key, shortText, permission, topic.getStringList(\"commands\"), preamble);\r\n                if (key.equals(\"Default\")) {\r\n                    defaultTopic = helpTopic;\r\n                } else {\r\n                    addTopic(helpTopic);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    ignoredPlugins.addAll(config.getStringList(\"ignore-plugins\"));\r\n    commandsInIndex = config.getBoolean(\"command-topics-in-master-index\", true);\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.readBooleanNegated",
	"Comment": "applies the given function to a byte subtag if it is present, converting it to boolean andnegating it first.",
	"Method": "boolean readBooleanNegated(String key,Consumer<? super Boolean> consumer){\r\n    return readTag(key, ByteTag.class, byteVal -> consumer.accept(byteVal == 0));\r\n}"
}, {
	"Path": "net.glowstone.GlowServer.getAllowClientMods",
	"Comment": "gets whether the server allows client mods.this rule is not actually enforced, and is simply exposed to clients as a warning.",
	"Method": "boolean getAllowClientMods(){\r\n    return config.getBoolean(Key.ALLOW_CLIENT_MODS);\r\n}"
}, {
	"Path": "net.glowstone.inventory.GlowInventory.getRawSlots",
	"Comment": "gets the number of slots in this inventory according to the protocol.some inventories have 0 slots in the protocol, despite having slots.",
	"Method": "int getRawSlots(){\r\n    return getSize();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.BaseRealm.getUserNames",
	"Comment": "returns names of all the users in this particular realm.this method always throws a badrealmexception since by defaultthis operation is not supported. subclasses which support thismethod can override.",
	"Method": "Enumeration getUserNames(){\r\n    String msg = sm.getString(\"iasrealm.notsupported\");\r\n    throw new BadRealmException(msg);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.UpdateFileUser.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    String fileRealmClassName = fileAuthRealm.getClassname();\r\n    if (fileRealmClassName != null && !fileRealmClassName.equals(\"com.sun.enterprise.security.auth.realm.file.FileRealm\")) {\r\n        report.setMessage(localStrings.getLocalString(\"update.file.user.realmnotsupported\", \"Configured file realm {0} is not supported.\", fileRealmClassName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    String keyFile = null;\r\n    for (Property fileProp : fileAuthRealm.getProperty()) {\r\n        if (fileProp.getName().equals(\"file\"))\r\n            keyFile = fileProp.getValue();\r\n    }\r\n    if (keyFile == null) {\r\n        report.setMessage(localStrings.getLocalString(\"update.file.user.keyfilenotfound\", \"There is no physical file associated with file realm {0}\", authRealmName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    boolean exists = (new File(keyFile)).exists();\r\n    if (!exists) {\r\n        report.setMessage(localStrings.getLocalString(\"file.realm.keyfilenonexistent\", \"The specified physical file {0} associated with the file realm {1} does not exist.\", new Object[] { keyFile, authRealmName }));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    String password = userpassword;\r\n    if (password == null && groups == null) {\r\n        report.setMessage(localStrings.getLocalString(\"update.file.user.keyfilenotreadable\", \"None of password or groups have been specified for update,\" + \"Password for user {0} has to be specified\" + \"through AS_ADMIN_USERPASSWORD property in the file specified \" + \"in --passwordfile option\", userName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (password != null) {\r\n        secureAdmin = domain.getSecureAdmin();\r\n        if ((SecureAdmin.Util.isEnabled(secureAdmin)) && (adminService.getAuthRealmName().equals(authRealmName))) {\r\n            if ((password.isEmpty())) {\r\n                report.setMessage(localStrings.getLocalString(\"null_empty_password\", \"The admin user password is empty\"));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    FileRealm fr = null;\r\n    try {\r\n        realmsManager.createRealms(config);\r\n        fr = (FileRealm) realmsManager.getFromLoadedRealms(config.getName(), authRealmName);\r\n        if (fr == null) {\r\n            throw new NoSuchRealmException(authRealmName);\r\n        }\r\n    } catch (NoSuchRealmException e) {\r\n        report.setMessage(localStrings.getLocalString(\"update.file.user.realmnotsupported\", \"Configured file realm {0} does not exist.\", authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    try {\r\n        CreateFileUser.handleAdminGroup(authRealmName, groups);\r\n        String[] groups1 = (groups == null) ? null : groups.toArray(new String[groups.size()]);\r\n        fr.updateUser(userName, userName, password, groups1);\r\n        fr.persist();\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"update.file.user.userupdatefailed\", \"Updating user {0} in file realm {1} failed\", userName, authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.block.blocktype.BlockType.getOppositeBlockFace",
	"Comment": "gets the blockface opposite of the direction the location is facing. usually used to set theway container blocks face when being placed.",
	"Method": "BlockFace getOppositeBlockFace(Location location,boolean inverted){\r\n    double rot = location.getYaw() % 360;\r\n    if (inverted) {\r\n        double pitch = location.getPitch();\r\n        if (pitch < -67.5D) {\r\n            return BlockFace.DOWN;\r\n        } else if (pitch > 67.5D) {\r\n            return BlockFace.UP;\r\n        }\r\n    }\r\n    if (rot < 0) {\r\n        rot += 360.0;\r\n    }\r\n    if (0 <= rot && rot < 45) {\r\n        return BlockFace.NORTH;\r\n    } else if (45 <= rot && rot < 135) {\r\n        return BlockFace.EAST;\r\n    } else if (135 <= rot && rot < 225) {\r\n        return BlockFace.SOUTH;\r\n    } else if (225 <= rot && rot < 315) {\r\n        return BlockFace.WEST;\r\n    } else if (315 <= rot && rot < 360.0) {\r\n        return BlockFace.NORTH;\r\n    } else {\r\n        return BlockFace.EAST;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.solaris.SolarisRealm.setGroupNames",
	"Comment": "set group membership info for a user.see bugs 4646133,4646270 on why this is here.",
	"Method": "void setGroupNames(String username,String[] groups){\r\n    Vector v = null;\r\n    if (groups == null) {\r\n        v = emptyVector;\r\n    } else {\r\n        v = new Vector(groups.length + 1);\r\n        for (int i = 0; i < groups.length; i++) {\r\n            v.add(groups[i]);\r\n        }\r\n    }\r\n    synchronized (this) {\r\n        groupCache.put(username, v);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.block.blocktype.BlockType.canOverride",
	"Comment": "called to check if this block can be overridden by a block place which would occur inside it.",
	"Method": "boolean canOverride(GlowBlock block,BlockFace face,ItemStack holding){\r\n    return block.isLiquid();\r\n}"
}, {
	"Path": "net.glowstone.GlowServer.shouldPreventProxy",
	"Comment": "gets whether the server should prevent player proxy connections.",
	"Method": "boolean shouldPreventProxy(){\r\n    return config.getBoolean(Key.PREVENT_PROXY);\r\n}"
}, {
	"Path": "org.glassfish.grizzly.config.SSLConfigurator.configureSSL",
	"Comment": "configures the ssl properties on the given pecoyoteconnector from the ssl config of the given http listener.",
	"Method": "SSLContext configureSSL(){\r\n    SSLContext newSslContext;\r\n    final List<String> tmpSSLArtifactsList = new LinkedList<String>();\r\n    try {\r\n        newSslContext = initializeSSLContext();\r\n        if (ssl != null) {\r\n            if (Boolean.parseBoolean(ssl.getSsl2Enabled())) {\r\n                tmpSSLArtifactsList.add(\"SSLv2\");\r\n            }\r\n            if (Boolean.parseBoolean(ssl.getSsl3Enabled())) {\r\n                tmpSSLArtifactsList.add(\"SSLv3\");\r\n            }\r\n            if (Boolean.parseBoolean(ssl.getTlsEnabled())) {\r\n                tmpSSLArtifactsList.add(\"TLSv1\");\r\n            }\r\n            if (Boolean.parseBoolean(ssl.getTls11Enabled())) {\r\n                tmpSSLArtifactsList.add(\"TLSv1.1\");\r\n            }\r\n            if (Boolean.parseBoolean(ssl.getTls12Enabled())) {\r\n                tmpSSLArtifactsList.add(\"TLSv1.2\");\r\n            }\r\n            if (Boolean.parseBoolean(ssl.getSsl3Enabled()) || Boolean.parseBoolean(ssl.getTlsEnabled())) {\r\n                tmpSSLArtifactsList.add(\"SSLv2Hello\");\r\n            }\r\n            if (tmpSSLArtifactsList.isEmpty()) {\r\n                logEmptyWarning(ssl, \"WEB0307: All SSL protocol variants disabled for network-listener {0},\" + \" using SSL implementation specific defaults\");\r\n            } else {\r\n                final String[] protocols = new String[tmpSSLArtifactsList.size()];\r\n                tmpSSLArtifactsList.toArray(protocols);\r\n                enabledProtocols = protocols;\r\n            }\r\n            tmpSSLArtifactsList.clear();\r\n            final String ssl3Ciphers = ssl.getSsl3TlsCiphers();\r\n            if (ssl3Ciphers != null && ssl3Ciphers.length() > 0) {\r\n                final String[] ssl3CiphersArray = ssl3Ciphers.split(\",\");\r\n                for (final String cipher : ssl3CiphersArray) {\r\n                    tmpSSLArtifactsList.add(cipher.trim());\r\n                }\r\n            }\r\n            final String ssl2Ciphers = ssl.getSsl2Ciphers();\r\n            if (ssl2Ciphers != null && ssl2Ciphers.length() > 0) {\r\n                final String[] ssl2CiphersArray = ssl2Ciphers.split(\",\");\r\n                for (final String cipher : ssl2CiphersArray) {\r\n                    tmpSSLArtifactsList.add(cipher.trim());\r\n                }\r\n            }\r\n            final String[] ciphers = getJSSECiphers(tmpSSLArtifactsList);\r\n            if (ciphers == null || ciphers.length == 0) {\r\n                logEmptyWarning(ssl, \"WEB0308: All SSL cipher suites disabled for network-listener(s) {0}.\" + \"  Using SSL implementation specific defaults\");\r\n            } else {\r\n                enabledCipherSuites = ciphers;\r\n            }\r\n        }\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.log(Level.FINE, \"Enabled secure protocols={0}\" + \"\" + \" ciphers={1}\", new Object[] { Arrays.toString(enabledProtocols), Arrays.toString(enabledCipherSuites) });\r\n        }\r\n        return newSslContext;\r\n    } catch (Exception e) {\r\n        if (LOGGER.isLoggable(Level.WARNING)) {\r\n            LOGGER.log(Level.WARNING, LogMessages.WARNING_GRIZZLY_CONFIG_SSL_GENERAL_CONFIG_ERROR(), e);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.solaris.SolarisRealm.getGroupNames",
	"Comment": "returns the name of all the groups that this user belongs to.this is called from web path role verification, thoughit should not be.",
	"Method": "Enumeration getGroupNames(String username){\r\n    Vector v = (Vector) groupCache.get(username);\r\n    if (v == null) {\r\n        v = loadGroupNames(username);\r\n    }\r\n    return v.elements();\r\n}"
}, {
	"Path": "net.glowstone.generator.structures.util.StructureBuilder.fillWithRandomMaterial",
	"Comment": "sets a box of blocks to have random types, chosen independently.",
	"Method": "void fillWithRandomMaterial(Vector min,Vector max,Random random,Map<StructureMaterial, Integer> materials){\r\n    for (int y = min.getBlockY(); y <= max.getBlockY(); y++) {\r\n        for (int x = min.getBlockX(); x <= max.getBlockX(); x++) {\r\n            for (int z = min.getBlockZ(); z <= max.getBlockZ(); z++) {\r\n                StructureMaterial material = getRandomMaterial(random, materials);\r\n                setBlock(new Vector(x, y, z), material.getType(), material.getData());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.GlowServer.keepSpawnLoaded",
	"Comment": "get whether worlds should keep their spawns loaded by default.",
	"Method": "boolean keepSpawnLoaded(){\r\n    return config.getBoolean(Key.PERSIST_SPAWN);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.file.FileRealm.getRealmFileNames",
	"Comment": "return a list of the file names used by all file realmsdefined for the specified config.",
	"Method": "List<String> getRealmFileNames(Config config){\r\n    List<String> files = new ArrayList<String>();\r\n    SecurityService securityService = config.getSecurityService();\r\n    for (AuthRealm authRealm : securityService.getAuthRealm()) {\r\n        String fileRealmClassName = authRealm.getClassname();\r\n        if (fileRealmClassName == null || !fileRealmClassName.equals(FileRealm.class.getName()))\r\n            continue;\r\n        String file = authRealm.getPropertyValue(\"file\");\r\n        if (file == null)\r\n            continue;\r\n        if (file.contains(\"$\")) {\r\n            file = RelativePathResolver.resolvePath(file);\r\n        }\r\n        files.add(file);\r\n    }\r\n    return files;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.JarSigner.appendLine",
	"Comment": "process a long manifest line and add continuation if required",
	"Method": "StringBuilder appendLine(StringBuilder sb,StringBuilder line){\r\n    int begin = 0;\r\n    for (int end = 70; line.length() - begin > 70; end += 69) {\r\n        sb.append(line.subSequence(begin, end)).append(\"\\r\\n \");\r\n        begin = end;\r\n    }\r\n    return sb.append(line.subSequence(begin, line.length())).append(\"\\r\\n\");\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowAgeable.computeGrowthAmount",
	"Comment": "computes the growth amount using a specific material for the current ageable creature.always returns 0 for an adult or if the material is not food for the creature.",
	"Method": "int computeGrowthAmount(Material material){\r\n    return 0;\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.provider.internal.ConfigThreadContext.captureACCandRun",
	"Comment": "performs a runnable action while managing the callers accesscontrolcontext in thread local storage",
	"Method": "void captureACCandRun(Runnable runnable){\r\n    ConfigThreadContext ts = tlc.get();\r\n    if (null != ts && null != ts.acc) {\r\n        runnable.run();\r\n        return;\r\n    }\r\n    boolean created = (null == ts);\r\n    if (created) {\r\n        ts = new ConfigThreadContext();\r\n        tlc.set(ts);\r\n    }\r\n    ts.acc = AccessController.getContext();\r\n    try {\r\n        runnable.run();\r\n    } finally {\r\n        ts.acc = null;\r\n        if (created) {\r\n            tlc.set(null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.util.mojangson.Mojangson.parseTag",
	"Comment": "detects the tag type of the mojangson string, and parses it. convenience method for otherparse methods.this method will fall back to an inttag if it could not find an appropriate tag type, andto string if the value could not be parsed as an integer either.",
	"Method": "Tag parseTag(String mojangson){\r\n    if (mojangson.startsWith(String.valueOf(STRING_QUOTES.getSymbol())) && mojangson.endsWith(String.valueOf(STRING_QUOTES.getSymbol()))) {\r\n        return parseString(mojangson);\r\n    }\r\n    if (mojangson.endsWith(String.valueOf(BYTE_SUFFIX.getSymbol()))) {\r\n        return parseByte(mojangson);\r\n    }\r\n    if (mojangson.endsWith(String.valueOf(DOUBLE_SUFFIX.getSymbol()))) {\r\n        return parseDouble(mojangson);\r\n    }\r\n    if (mojangson.endsWith(String.valueOf(LONG_SUFFIX.getSymbol()))) {\r\n        return parseLong(mojangson);\r\n    }\r\n    if (mojangson.endsWith(String.valueOf(FLOAT_SUFFIX.getSymbol()))) {\r\n        return parseFloat(mojangson);\r\n    }\r\n    if (mojangson.endsWith(String.valueOf(SHORT_SUFFIX.getSymbol()))) {\r\n        return parseShort(mojangson);\r\n    }\r\n    if (mojangson.startsWith(String.valueOf(ARRAY_START.getSymbol())) && mojangson.endsWith(String.valueOf(ARRAY_END.getSymbol()))) {\r\n        return parseArray(mojangson);\r\n    }\r\n    if (mojangson.startsWith(String.valueOf(COMPOUND_START.getSymbol())) && mojangson.endsWith(String.valueOf(COMPOUND_END.getSymbol()))) {\r\n        return parseCompound(mojangson);\r\n    }\r\n    try {\r\n        return parseInt(mojangson);\r\n    } catch (MojangsonParseException e) {\r\n        try {\r\n            return parseLong(mojangson);\r\n        } catch (MojangsonParseException e1) {\r\n            try {\r\n                return parseDouble(mojangson);\r\n            } catch (MojangsonParseException e2) {\r\n                switch(mojangson) {\r\n                    case \"true\":\r\n                        return new ByteTag((byte) 1);\r\n                    case \"false\":\r\n                        return new ByteTag((byte) 0);\r\n                    default:\r\n                        return parseString(mojangson);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AzAttributesImpl.getName",
	"Comment": "determines a name to denote this collection of attributes.for example, this name may be used to qualify attributes by collectiontype in xacml.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.readFloatList",
	"Comment": "applies the given function to a list subtag if it is present and its contents are floattags.",
	"Method": "boolean readFloatList(String key,Consumer<? super List<Float>> consumer){\r\n    return readList(key, TagType.FLOAT, consumer);\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowTntPrimed.setIgnitedByExplosion",
	"Comment": "sets whether this tnt was ignited by an explosion or not. this is not tracked, but affectsthe fuse length.",
	"Method": "void setIgnitedByExplosion(boolean ignitedByExplosion){\r\n    if (ignitedByExplosion) {\r\n        fuseTicks = ThreadLocalRandom.current().nextInt(10, 31);\r\n    } else {\r\n        fuseTicks = 80;\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.io.entity.EntityStore.load",
	"Comment": "load data into an existing entity of the appropriate type from the given compound tag.",
	"Method": "void load(T entity,CompoundTag tag){\r\n    tag.readDoubleList(\"Motion\", list -> entity.setVelocity(NbtSerialization.listToVector(list)));\r\n    tag.readFloat(\"FallDistance\", entity::setFallDistance);\r\n    tag.readShort(\"Fire\", entity::setFireTicks);\r\n    tag.readBoolean(\"OnGround\", entity::setOnGround);\r\n    tag.readBooleanNegated(\"NoGravity\", entity::setGravity);\r\n    tag.readBoolean(\"Silent\", entity::setSilent);\r\n    tag.readBoolean(\"Glowing\", entity::setGlowing);\r\n    tag.readBoolean(\"Invulnerable\", entity::setInvulnerable);\r\n    tag.readStringList(\"Tags\", list -> {\r\n        entity.getCustomTags().clear();\r\n        entity.getCustomTags().addAll(list);\r\n    });\r\n    tag.readInt(\"PortalCooldown\", entity::setPortalCooldown);\r\n    Optional.ofNullable(tag.tryGetUuid(\"UUIDMost\", \"UUIDLeast\").orElseGet(() -> tag.tryGetString(\"UUID\").map(UuidUtils::fromString).orElse(null))).ifPresent(entity::setUniqueId);\r\n    tag.iterateCompoundList(\"Passengers\", entityTag -> {\r\n        Entity passenger = loadPassenger(entity, entityTag);\r\n        if (passenger != null) {\r\n            entity.addPassenger(passenger);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "net.glowstone.entity.meta.MetadataMap.getOptPosition",
	"Comment": "gets the optional position value for the given metadataindex.",
	"Method": "BlockVector getOptPosition(MetadataIndex index){\r\n    return get(index, MetadataType.OPTPOSITION, null);\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.Dom.writeToXml",
	"Comment": "this method should be invoked if this dom needs to be persisted todomain.xml file",
	"Method": "void writeToXml(){\r\n    writeToXml = true;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.file.FileRealmUser.getAttribute",
	"Comment": "return the requested attribute for the user.not really needed.",
	"Method": "Object getAttribute(String key){\r\n    return attributes.get(key);\r\n}"
}, {
	"Path": "net.glowstone.util.OpenCompute.getLocalSize",
	"Comment": "calculates the number of local work units per work group, applying a specified maximum.",
	"Method": "int getLocalSize(int getLocalSize,int max){\r\n    return Math.min(device.getMaxWorkGroupSize(), max);\r\n}"
}, {
	"Path": "net.glowstone.entity.ai.EntityDirector.getEntityMobStateTask",
	"Comment": "returns all registered task names for the given entity and mob state.",
	"Method": "Collection<String> getEntityMobStateTask(EntityType entity,MobState state){\r\n    Map<MobState, List<String>> tasks = mobStates.get(entity);\r\n    if (tasks != null && tasks.containsKey(state)) {\r\n        return tasks.get(state);\r\n    }\r\n    return new ArrayList();\r\n}"
}, {
	"Path": "net.glowstone.util.SoundUtil.playSoundAtLocationExcept",
	"Comment": "plays a sound with a random pitch, but excludes specified players from hearing it.",
	"Method": "void playSoundAtLocationExcept(Location location,Sound sound,float volume,float pitch,GlowPlayer exclude){\r\n    checkNotNull(location);\r\n    checkNotNull(sound);\r\n    checkNotNull(exclude);\r\n    Set<GlowPlayer> excludeSet = Sets.newHashSet(exclude);\r\n    GlowWorld world = (GlowWorld) location.getWorld();\r\n    double radiusSquared = volume * volume * 256;\r\n    world.getRawPlayers().stream().filter(player -> player.getLocation().distanceSquared(location) <= radiusSquared && !excludeSet.contains(player)).forEach(player -> player.playSound(location, sound, volume, pitch));\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.Transaction.enroll",
	"Comment": "enroll a configuration object in a transaction and returns a writeable view of it",
	"Method": "T enroll(T source){\r\n    T configBeanProxy = ConfigSupport.revealProxy(source);\r\n    ConfigView sourceBean = (ConfigView) Proxy.getInvocationHandler(configBeanProxy);\r\n    WriteableView writeableView = ConfigSupport.getWriteableView(configBeanProxy, (ConfigBean) sourceBean.getMasterView());\r\n    if (!writeableView.join(this)) {\r\n        throw new TransactionFailure(\"Cannot join transaction : \" + sourceBean.getProxyType());\r\n    }\r\n    return (T) writeableView.getProxy(sourceBean.getProxyType());\r\n}"
}, {
	"Path": "net.glowstone.GlowServer.setPort",
	"Comment": "sets the port that the query server will expose.this does not change the port the server will run on.",
	"Method": "void setPort(int port){\r\n    this.port = port;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.ldap.LDAPRealm.setGroupNames",
	"Comment": "set group membership info for a user.see bugs 4646133,4646270 on why this is here.",
	"Method": "void setGroupNames(String username,String[] groups){\r\n    Vector v = new Vector(groups.length);\r\n    for (int i = 0; i < groups.length; i++) {\r\n        v.add(groups[i]);\r\n    }\r\n    groupCache.put(username, v);\r\n}"
}, {
	"Path": "net.glowstone.GlowServer.getPlayerDataService",
	"Comment": "returns the player data service attached to the first world.",
	"Method": "PlayerDataService getPlayerDataService(){\r\n    return worlds.getWorlds().get(0).getStorage().getPlayerDataService();\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.WriteableView.canCommit",
	"Comment": "returns true of this transaction can be committed on this object",
	"Method": "boolean canCommit(Transaction t){\r\n    if (!isDeleted) {\r\n        Set constraintViolations = beanValidator.validate(this.getProxy(this.getProxyType()));\r\n        try {\r\n            handleValidationException(constraintViolations);\r\n        } catch (ConstraintViolationException constraintViolationException) {\r\n            throw new TransactionFailure(constraintViolationException.getMessage(), constraintViolationException);\r\n        }\r\n    }\r\n    return currentTx == t;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.ListFileUser.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    String fileRealmClassName = fileAuthRealm.getClassname();\r\n    if (fileRealmClassName != null && !fileRealmClassName.equals(\"com.sun.enterprise.security.auth.realm.file.FileRealm\")) {\r\n        report.setMessage(localStrings.getLocalString(\"list.file.user.realmnotsupported\", \"Configured file realm {0} is not supported.\", fileRealmClassName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    String keyFile = null;\r\n    for (Property fileProp : fileAuthRealm.getProperty()) {\r\n        if (fileProp.getName().equals(\"file\"))\r\n            keyFile = fileProp.getValue();\r\n    }\r\n    if (keyFile == null) {\r\n        report.setMessage(localStrings.getLocalString(\"list.file.user.keyfilenotfound\", \"There is no physical file associated with this file realm {0} \", authRealmName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    boolean exists = (new File(keyFile)).exists();\r\n    if (!exists) {\r\n        report.setMessage(localStrings.getLocalString(\"file.realm.keyfilenonexistent\", \"The specified physical file {0} associated with the file realm {1} does not exist.\", new Object[] { keyFile, authRealmName }));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    FileRealm fr = null;\r\n    try {\r\n        realmsManager.createRealms(config);\r\n        CreateFileUser.refreshRealm(config.getName(), authRealmName);\r\n        fr = (FileRealm) realmsManager.getFromLoadedRealms(config.getName(), authRealmName);\r\n        if (fr == null) {\r\n            throw new NoSuchRealmException(authRealmName);\r\n        }\r\n    } catch (NoSuchRealmException e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.file.user.realmnotsupported\", \"Configured file realm {0} is not supported.\", authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    try {\r\n        Enumeration users = fr.getUserNames();\r\n        List userList = new ArrayList();\r\n        while (users.hasMoreElements()) {\r\n            final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n            String userName = (String) users.nextElement();\r\n            part.setMessage(userName);\r\n            Map userMap = new HashMap();\r\n            userMap.put(\"name\", userName);\r\n            try {\r\n                userMap.put(\"groups\", Collections.list(fr.getGroupNames(userName)));\r\n            } catch (NoSuchUserException ex) {\r\n            }\r\n            userList.add(userMap);\r\n        }\r\n        Properties extraProperties = new Properties();\r\n        extraProperties.put(\"users\", userList);\r\n        report.setExtraProperties(extraProperties);\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (BadRealmException e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.file.user.realmcorrupted\", \"Configured file realm {0} is corrupted.\", authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.chunk.ChunkSection.fromIdArray",
	"Comment": "creates a new unlit chunk section containing the given types.",
	"Method": "ChunkSection fromIdArray(short[] types,ChunkSection fromIdArray,byte[] types){\r\n    if (types.length != ARRAY_SIZE) {\r\n        throw new IllegalArgumentException(\"Types array length was not \" + ARRAY_SIZE + \": \" + types.length);\r\n    }\r\n    char[] charTypes = new char[ARRAY_SIZE];\r\n    for (int i = 0; i < ARRAY_SIZE; i++) {\r\n        charTypes[i] = (char) (types[i] << 4);\r\n    }\r\n    return new ChunkSection(charTypes);\r\n}"
}, {
	"Path": "net.glowstone.util.Position.hasRotated",
	"Comment": "gets whether there has been a rotation change between the two locations.",
	"Method": "boolean hasRotated(Location first,Location second){\r\n    return first.getPitch() != second.getPitch() || first.getYaw() != second.getYaw();\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.ConfigModel.getElement",
	"Comment": "returns the property model for an element associated with this modelor null of the element name is not known,",
	"Method": "Property getElement(String elementName){\r\n    return elements.get(elementName);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.JarSigner.getZipEntry",
	"Comment": "get the zipentry for the given jarentry. added in order to suppress thecompressedsize field as it was causing errors",
	"Method": "ZipEntry getZipEntry(JarEntry je){\r\n    ZipEntry ze = new ZipEntry(je.getName());\r\n    ze.setComment(je.getComment());\r\n    ze.setCrc(je.getCrc());\r\n    ze.setExtra(je.getExtra());\r\n    ze.setMethod(je.getMethod());\r\n    ze.setSize(je.getSize());\r\n    ze.setTime(je.getTime());\r\n    return ze;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.BaseAuditModule.init",
	"Comment": "method is invoked at server startup, during auditmodule initialization.if method returns without any exception then s1as assumes that the moduleis ready to serve any requests.",
	"Method": "void init(Properties props){\r\n    this.props = props;\r\n}"
}, {
	"Path": "org.glassfish.nucleus.admin.rest.RestTestBase.getEntityValues",
	"Comment": "this method will parse the provided xml document and return a map of the attributes and values on the rootelement",
	"Method": "Map<String, String> getEntityValues(Response response){\r\n    Map<String, String> map = new HashMap<String, String>();\r\n    String xml = response.readEntity(String.class);\r\n    Map responseMap = MarshallingUtils.buildMapFromDocument(xml);\r\n    Object obj = responseMap.get(\"extraProperties\");\r\n    if (obj != null) {\r\n        return (Map) ((Map) obj).get(\"entity\");\r\n    } else {\r\n        return map;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.nucleus.admin.OSGiCommandsTest.osgiCmdSession",
	"Comment": "tests functionality of session handling of osgi command.it creates sessions, lists them, executes commands against each session and finally stops them.",
	"Method": "void osgiCmdSession(){\r\n    Set<String> sessions = new HashSet<String>();\r\n    for (int i = 0; i < 3; ++i) {\r\n        sessions.add(newCmdSession());\r\n    }\r\n    final Set<String> actual = listCmdSessions();\r\n    assertEquals(\"listed sessions do not match with created sessions\", sessions, actual);\r\n    for (String sessionId : sessions) {\r\n        runCmd(\"osgi\", \"--session\", \"execute\", \"--session-id\", sessionId, \"var=\" + sessionId);\r\n    }\r\n    for (String sessionId : sessions) {\r\n        String value = runCmd(\"osgi\", \"--session\", \"execute\", \"--session-id\", sessionId, \"echo $var\").get(0);\r\n        assertEquals(sessionId, value);\r\n    }\r\n    for (String sessionId : sessions) {\r\n        runCmd(\"osgi\", \"--session\", \"stop\", \"--session-id\", sessionId);\r\n    }\r\n    sessions = listCmdSessions();\r\n    assertTrue(\"Not all sessions closed properly: \" + sessions, sessions.isEmpty());\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowLivingEntity.getAmbientSound",
	"Comment": "get the ambient sound this entity makes randomly, or null for silence.",
	"Method": "Sound getAmbientSound(){\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.grizzly.config.Utils.newInstance",
	"Comment": "load or create an object with the specific service name and class name.",
	"Method": "E newInstance(ServiceLocator habitat,Class<E> clazz,String name,String realClassName,E newInstance,ServiceLocator habitat,Class<E> clazz,String name,String realClassName,Class<?>[] argTypes,Object[] args,Object newInstance,String classname,Object newInstance,String classname,Class<?>[] argTypes,Object[] args){\r\n    final Class<?> clazz = loadClass(classname);\r\n    final Constructor c = clazz.getConstructor(argTypes);\r\n    assert (c != null);\r\n    return c.newInstance(args);\r\n}"
}, {
	"Path": "net.glowstone.chunk.ChunkManager.loadChunk",
	"Comment": "call the chunkioservice to load a chunk, optionally generating the chunk.",
	"Method": "boolean loadChunk(int x,int z,boolean generate,boolean loadChunk,GlowChunk chunk,boolean generate){\r\n    try {\r\n        if (service.read(chunk)) {\r\n            EventFactory.getInstance().callEvent(new ChunkLoadEvent(chunk, false));\r\n            return true;\r\n        }\r\n    } catch (IOException e) {\r\n        ConsoleMessages.Error.Chunk.LOAD_FAILED.log(e, chunk.getX(), chunk.getZ());\r\n        chunk.unload(false, false);\r\n    }\r\n    if (!generate || world.getServer().isGenerationDisabled()) {\r\n        return false;\r\n    }\r\n    try {\r\n        generateChunk(chunk, chunk.getX(), chunk.getZ());\r\n    } catch (Throwable ex) {\r\n        ConsoleMessages.Error.Chunk.GEN_FAILED.log(ex, chunk.getX(), chunk.getZ());\r\n        return false;\r\n    }\r\n    EventFactory.getInstance().callEvent(new ChunkLoadEvent(chunk, true));\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.audit.BaseAuditManager.loadAuditModule",
	"Comment": "this method return auditmodule with given classname and properties.",
	"Method": "BaseAuditModule loadAuditModule(String classname,Properties props){\r\n    BaseAuditModule auditModule;\r\n    ClassLoader loader = Thread.currentThread().getContextClassLoader();\r\n    Class am = Class.forName(classname, true, loader);\r\n    Object obj = am.newInstance();\r\n    auditModule = (BaseAuditModule) obj;\r\n    auditModule.init(props);\r\n    return auditModule;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.impl.SecuritySupportImpl.getTokenNames",
	"Comment": "this method returns an array of token names in order corresponding toarray of keystores.",
	"Method": "String[] getTokenNames(){\r\n    return tokenNames.toArray(new String[tokenNames.size()]);\r\n}"
}, {
	"Path": "net.glowstone.advancement.GlowAdvancement.encode",
	"Comment": "writes a notification of earning this advancement to a byte buffer.",
	"Method": "ByteBuf encode(ByteBuf buf){\r\n    buf.writeBoolean(parent != null);\r\n    if (parent != null) {\r\n        ByteBufUtils.writeUTF8(buf, parent.getKey().toString());\r\n    }\r\n    buf.writeBoolean(display != null);\r\n    if (display != null) {\r\n        display.encode(buf);\r\n    }\r\n    ByteBufUtils.writeVarInt(buf, criteriaIds.size());\r\n    for (String criteriaId : criteriaIds) {\r\n        ByteBufUtils.writeUTF8(buf, criteriaId);\r\n    }\r\n    ByteBufUtils.writeVarInt(buf, requirements.size());\r\n    for (List<String> requirement : requirements) {\r\n        ByteBufUtils.writeVarInt(buf, requirement.size());\r\n        for (String criterion : requirement) {\r\n            ByteBufUtils.writeUTF8(buf, criterion);\r\n        }\r\n    }\r\n    return buf;\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.AuthenticationServiceFactory.getAuthenticationServiceConfiguration",
	"Comment": "helper function to obtain the authentication service configuration from the domain.",
	"Method": "org.glassfish.security.services.config.AuthenticationService getAuthenticationServiceConfiguration(Domain domain){\r\n    org.glassfish.security.services.config.AuthenticationService atnConfiguration = ServiceFactory.getSecurityServiceConfiguration(domain, org.glassfish.security.services.config.AuthenticationService.class);\r\n    return atnConfiguration;\r\n}"
}, {
	"Path": "net.glowstone.util.Position.hasMoved",
	"Comment": "gets whether there has been a position change between the two locations.",
	"Method": "boolean hasMoved(Location first,Location second){\r\n    return first.getX() != second.getX() || first.getY() != second.getY() || first.getZ() != second.getZ();\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.ConfigBean.copy",
	"Comment": "returns a copy of itself providing the parent for the new copy.",
	"Method": "T copy(T parent){\r\n    return (T) new ConfigBean(this, parent);\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowPlayer.findSafeSpawnLocation",
	"Comment": "find a a location obove or below the specified location, which is on ground.the returned location will be at the center of the block, x and y wise.",
	"Method": "Location findSafeSpawnLocation(Location spawn){\r\n    World world = spawn.getWorld();\r\n    int blockX = spawn.getBlockX();\r\n    int blockY = spawn.getBlockY();\r\n    int blockZ = spawn.getBlockZ();\r\n    int highestY = world.getHighestBlockYAt(blockX, blockZ);\r\n    int y = blockY;\r\n    boolean wasPreviousSafe = false;\r\n    for (; y <= highestY; y++) {\r\n        Material type = world.getBlockAt(blockX, y, blockZ).getType();\r\n        boolean safe = Material.AIR.equals(type);\r\n        if (wasPreviousSafe && safe) {\r\n            y--;\r\n            break;\r\n        }\r\n        wasPreviousSafe = safe;\r\n    }\r\n    return new Location(world, blockX + 0.5, y, blockZ + 0.5);\r\n}"
}, {
	"Path": "net.glowstone.util.bans.UuidListFile.add",
	"Comment": "if the given player is not already on this list, adds that player and saves the change todisk.",
	"Method": "void add(OfflinePlayer player){\r\n    UUID playerUuid = player.getUniqueId();\r\n    if (!containsUuid(playerUuid)) {\r\n        Entry newEntry = new Entry(playerUuid, player.getName());\r\n        entries.add(newEntry);\r\n        entriesByUuid.put(playerUuid, newEntry);\r\n        save();\r\n    }\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.ConfigSupport.sortAndDispatch",
	"Comment": "sort events and dispatch the changes. there will be only one notification of eventper event type, per object, meaning that if an object has had 3 attributes changes, thechanged interface implementation will get notified only once.",
	"Method": "UnprocessedChangeEvents sortAndDispatch(PropertyChangeEvent[] events,Changed target,Logger logger){\r\n    if (logger == null)\r\n        throw new IllegalArgumentException();\r\n    List<UnprocessedChangeEvent> unprocessed = new ArrayList<UnprocessedChangeEvent>();\r\n    List<Dom> added = new ArrayList<Dom>();\r\n    List<Dom> changed = new ArrayList<Dom>();\r\n    for (PropertyChangeEvent event : events) {\r\n        if (event.getOldValue() == null && event.getNewValue() instanceof ConfigBeanProxy) {\r\n            try {\r\n                final ConfigBeanProxy proxy = ConfigBeanProxy.class.cast(event.getNewValue());\r\n                added.add(Dom.unwrap(proxy));\r\n                final NotProcessed nc = target.changed(Changed.TYPE.ADD, proxyType(proxy), proxy);\r\n                if (nc != null) {\r\n                    unprocessed.add(new UnprocessedChangeEvent(event, nc.getReason()));\r\n                }\r\n            } catch (Exception e) {\r\n                logger.log(Level.SEVERE, \"Exception while processing config bean changes : \", e);\r\n            }\r\n        }\r\n    }\r\n    for (PropertyChangeEvent event : events) {\r\n        try {\r\n            Dom eventSource = Dom.unwrap((ConfigBeanProxy) event.getSource());\r\n            if (added.contains(eventSource)) {\r\n                continue;\r\n            }\r\n            ConfigBeanProxy proxy = null;\r\n            if (event.getNewValue() == null) {\r\n                try {\r\n                    proxy = ConfigBeanProxy.class.cast(event.getOldValue());\r\n                } catch (ClassCastException e) {\r\n                }\r\n                if (proxy != null) {\r\n                    final NotProcessed nc = target.changed(Changed.TYPE.REMOVE, proxyType(proxy), proxy);\r\n                    if (nc != null) {\r\n                        unprocessed.add(new UnprocessedChangeEvent(event, nc.getReason()));\r\n                    }\r\n                    continue;\r\n                }\r\n            }\r\n            if (!changed.contains(eventSource)) {\r\n                proxy = ConfigBeanProxy.class.cast(event.getSource());\r\n                changed.add(eventSource);\r\n                final NotProcessed nc = target.changed(Changed.TYPE.CHANGE, proxyType(proxy), proxy);\r\n                if (nc != null) {\r\n                    unprocessed.add(new UnprocessedChangeEvent(event, nc.getReason()));\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            logger.log(Level.SEVERE, \"Exception while processing config bean changes : \", e);\r\n        }\r\n    }\r\n    return new UnprocessedChangeEvents(unprocessed);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.GUIErrorDialog.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    okButton = new javax.swing.JButton();\r\n    errorLbl = new javax.swing.JLabel();\r\n    okButton.setAlignmentX(CENTER_ALIGNMENT);\r\n    errorLbl.setAlignmentX(CENTER_ALIGNMENT);\r\n    getContentPane().setLayout(new javax.swing.BoxLayout(getContentPane(), BoxLayout.Y_AXIS));\r\n    addWindowListener(new java.awt.event.WindowAdapter() {\r\n        public void windowClosing(java.awt.event.WindowEvent evt) {\r\n            closeDialog(evt);\r\n        }\r\n    });\r\n    okButton.setActionCommand(\"okButton\");\r\n    okButton.setText(\"OK\");\r\n    okButton.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            dispose();\r\n        }\r\n    });\r\n    super.addWindowListener(new WindowAdapter() {\r\n        public void windowClosing(WindowEvent we) {\r\n            dispose();\r\n        }\r\n    });\r\n    errorLbl.setText(\"Error : \" + message);\r\n    getContentPane().add(errorLbl);\r\n    getContentPane().add(okButton);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.GUIErrorDialog.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    closeDialog(evt);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.GUIErrorDialog.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    dispose();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.GUIErrorDialog.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    dispose();\r\n}"
}, {
	"Path": "net.glowstone.inventory.GlowInventoryView.checkSlot",
	"Comment": "verify that the given slot is within the bounds of this inventory view.",
	"Method": "void checkSlot(int slot){\r\n    if (slot == OUTSIDE) {\r\n        return;\r\n    }\r\n    int size = countSlots();\r\n    if (slot < 0 || slot >= size) {\r\n        throw new IllegalArgumentException(\"Slot out of range [0,\" + size + \"): \" + slot);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.io.structure.StructurePieceStorage.createStructurePiece",
	"Comment": "helper method to call structurepiecestore methods for type safety.",
	"Method": "T createStructurePiece(StructurePieceStore<T> store,CompoundTag compound){\r\n    T structurePiece = store.createStructurePiece();\r\n    store.load(structurePiece, compound);\r\n    return structurePiece;\r\n}"
}, {
	"Path": "org.glassfish.grizzly.config.ssl.JSSESocketFactory.initServerSocket",
	"Comment": "configures the given ssl server socket with the requested cipher suites, protocol versions, and need for clientauthentication",
	"Method": "void initServerSocket(ServerSocket ssocket){\r\n    if (!(ssocket instanceof SSLServerSocket)) {\r\n        throw new IllegalArgumentException(\"The ServerSocket has to be SSLServerSocket\");\r\n    }\r\n    SSLServerSocket socket = (SSLServerSocket) ssocket;\r\n    if (attributes.get(\"ciphers\") != null) {\r\n        socket.setEnabledCipherSuites(enabledCiphers);\r\n    }\r\n    String requestedProtocols = (String) attributes.get(\"protocols\");\r\n    setEnabledProtocols(socket, getEnabledProtocols(socket, requestedProtocols));\r\n    if (clientAuthNeed) {\r\n        socket.setNeedClientAuth(clientAuthNeed);\r\n    } else {\r\n        socket.setWantClientAuth(clientAuthWant);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowLivingEntity.determinePlayer",
	"Comment": "determines the player who did the damage from source of damage.",
	"Method": "Player determinePlayer(Entity source){\r\n    if (source instanceof GlowTntPrimed) {\r\n        return (Player) ((GlowTntPrimed) source).getSource();\r\n    }\r\n    if (source instanceof GlowPlayer) {\r\n        return (Player) source;\r\n    }\r\n    if (source instanceof GlowWolf) {\r\n        return (Player) ((GlowWolf) source).getOwner();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.makeAzAction",
	"Comment": "convert an action, expressed as a string, into a typed attributes collection.",
	"Method": "AzAction makeAzAction(String action){\r\n    AzAction aza = new AzActionImpl(action);\r\n    return aza;\r\n}"
}, {
	"Path": "org.glassfish.tests.utils.NucleusTestUtils.nadminWithOutput",
	"Comment": "runs the command with the args givenreturns the precious output strings for further processing.",
	"Method": "NadminReturn nadminWithOutput(String args,NadminReturn nadminWithOutput,int timeout,String args){\r\n    File cmd = new File(nucleusRoot, isWindows() ? \"bin/nadmin.bat\" : \"bin/nadmin\");\r\n    if (!cmd.canExecute()) {\r\n        cmd = new File(nucleusRoot, isWindows() ? \"bin/asadmin.bat\" : \"bin/asadmin\");\r\n        if (!cmd.canExecute()) {\r\n            cmd = new File(nucleusRoot, isWindows() ? \"bin/padmin.bat\" : \"bin/padmin\");\r\n        }\r\n    }\r\n    return cmdWithOutput(cmd, timeout, args);\r\n}"
}, {
	"Path": "net.glowstone.util.GameRuleManager.getString",
	"Comment": "gets the game rule value as a string. if the value does not exist, then this will returnnull.",
	"Method": "String getString(String rule){\r\n    if (isGameRule(rule)) {\r\n        return gameRules.get(rule);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.isAuthorized",
	"Comment": "determine whether the given subject is authorized to access the given resource,specified by a uri.",
	"Method": "boolean isAuthorized(Subject subject,URI resource,boolean isAuthorized,Subject subject,URI resource,String action){\r\n    checkServiceAvailability();\r\n    if (null == subject) {\r\n        throw new IllegalArgumentException(localStrings.getLocalString(\"service.subject_null\", \"The supplied Subject is null.\"));\r\n    }\r\n    if (null == resource) {\r\n        throw new IllegalArgumentException(localStrings.getLocalString(\"service.resource_null\", \"The supplied Resource is null.\"));\r\n    }\r\n    AzSubject azSubject = makeAzSubject(subject);\r\n    AzResource azResource = makeAzResource(resource);\r\n    AzAction azAction = makeAzAction(action);\r\n    AzResult azResult = getAuthorizationDecision(azSubject, azResource, azAction);\r\n    boolean result = AzResult.Status.OK.equals(azResult.getStatus()) && AzResult.Decision.PERMIT.equals(azResult.getDecision());\r\n    return result;\r\n}"
}, {
	"Path": "net.glowstone.entity.passive.GlowTameable.setSitting",
	"Comment": "sets if this animal is sitting. will remove any path that the animalwas following beforehand.",
	"Method": "void setSitting(boolean isSitting){\r\n    metadata.setBit(META_STATUS, TameableFlags.IS_SITTING, isSitting);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginCallbackHandler.handle",
	"Comment": "this is the callback method called when authentication data isrequired. it either pops up a dialog box to request authenticationdata or use text input.",
	"Method": "void handle(Callback[] callbacks){\r\n    if (isGUI) {\r\n        String user = localStrings.getLocalString(\"login.user\", \"user\");\r\n        new GUILoginDialog(user, callbacks);\r\n        for (int i = 0; i < callbacks.length; i++) {\r\n            if (callbacks[i] instanceof NameCallback) {\r\n                cancelStatus.set(((NameCallback) callbacks[i]).getName() == null);\r\n                break;\r\n            }\r\n        }\r\n    } else {\r\n        new TextLoginDialog(callbacks);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.setAttributeResolvers",
	"Comment": "replaces the internal list of attributeresolver instanceswith the given list. if multiple equivalent instances exist in the given list,only the first such instance will be inserted.",
	"Method": "void setAttributeResolvers(List<AzAttributeResolver> resolverList){\r\n    if (null == resolverList) {\r\n        throw new IllegalArgumentException(localStrings.getLocalString(\"service.resolver_null\", \"The supplied Attribute Resolver is null.\"));\r\n    }\r\n    synchronized (attributeResolvers) {\r\n        attributeResolvers.clear();\r\n        for (AzAttributeResolver ar : resolverList) {\r\n            if ((null != ar) && !attributeResolvers.contains(ar)) {\r\n                attributeResolvers.add(ar);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.block.GlowBlock.breakNaturally",
	"Comment": "break the block naturally, randomly dropping only some of the drops.",
	"Method": "boolean breakNaturally(float yield,boolean breakNaturally,float yield,Collection<ItemStack> drops,boolean breakNaturally,boolean breakNaturally,ItemStack tool){\r\n    Collection<ItemStack> drops = getDrops(tool);\r\n    if (!drops.isEmpty()) {\r\n        return breakNaturally(1.0f, drops);\r\n    } else {\r\n        return setTypeId(Material.AIR.getId());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.factory.SecurityManagerFactory.addManagerToApp",
	"Comment": "in id2smmap, maps manager toctxid and name, and in app2idmap, includes ctxid in values mapped to appname.",
	"Method": "void addManagerToApp(Map<String, Map<String, T>> iD2sMmap,Map<String, ArrayList<String>> app2iDmap,String ctxId,String name,String appName,T manager){\r\n    synchronized (iD2sMmap) {\r\n        Map<String, T> managerMap = iD2sMmap.get(ctxId);\r\n        if (managerMap == null) {\r\n            managerMap = new HashMap<String, T>();\r\n            iD2sMmap.put(ctxId, managerMap);\r\n        }\r\n        managerMap.put(name, manager);\r\n    }\r\n    synchronized (app2iDmap) {\r\n        ArrayList<String> ctxList = app2iDmap.get(appName);\r\n        if (ctxList == null) {\r\n            ctxList = new ArrayList<String>();\r\n            app2iDmap.put(appName, ctxList);\r\n        }\r\n        if (!ctxList.contains(ctxId)) {\r\n            ctxList.add(ctxId);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.admin.cli.EnableSecureAdminCommand.ensureSecureAdminPrincipalForAlias",
	"Comment": "makes sure there is a secureadminprincipal entry for the specifiedalias.if not, one is added in the context of the currenttransaction.",
	"Method": "void ensureSecureAdminPrincipalForAlias(String alias,SecureAdmin secureAdmin_w){\r\n    SecureAdminPrincipal p = getSecureAdminPrincipalForAlias(alias, secureAdmin_w);\r\n    if (p != null) {\r\n        return;\r\n    }\r\n    try {\r\n        final String dn = secureAdminHelper.getDN(alias, true);\r\n        p = secureAdmin_w.createChild(SecureAdminPrincipal.class);\r\n        p.setDn(dn);\r\n        secureAdmin_w.getSecureAdminPrincipal().add(p);\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.chunk.ChunkSection.index",
	"Comment": "calculate the index into internal arrays for the given coordinates.",
	"Method": "int index(int x,int y,int z){\r\n    if (x < 0 || z < 0 || x >= GlowChunk.WIDTH || z >= GlowChunk.HEIGHT) {\r\n        throw new IndexOutOfBoundsException(\"Coords (x=\" + x + \",z=\" + z + \") out of section bounds\");\r\n    }\r\n    return (y & 0xf) << 8 | z << 4 | x;\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.readShort",
	"Comment": "applies the given function to an integer subtag if it is present.",
	"Method": "boolean readShort(String key,ShortConsumer consumer){\r\n    if (isShort(key)) {\r\n        consumer.accept(getShort(key));\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.postClientAuth",
	"Comment": "extract the relevant username and realm information from thesubject and sets the correct state in the security context. therelevant information is set into the thread local storage fromwhich then is extracted to send over the wire.",
	"Method": "void postClientAuth(Subject subject,Class<?> clazz){\r\n    final Class<?> clas = clazz;\r\n    final Subject fs = subject;\r\n    Set credset = (Set) AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n        public java.lang.Object run() {\r\n            if (_logger.isLoggable(Level.FINEST)) {\r\n                _logger.log(Level.FINEST, \"LCD post login subject :\" + fs);\r\n            }\r\n            return fs.getPrivateCredentials(clas);\r\n        }\r\n    });\r\n    final Iterator iter = credset.iterator();\r\n    while (iter.hasNext()) {\r\n        Object obj = null;\r\n        try {\r\n            obj = AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n                public java.lang.Object run() {\r\n                    return iter.next();\r\n                }\r\n            });\r\n        } catch (Exception e) {\r\n            _logger.log(Level.SEVERE, SecurityLoggerInfo.securityAccessControllerActionError, e);\r\n        }\r\n        if (obj instanceof PasswordCredential) {\r\n            PasswordCredential p = (PasswordCredential) obj;\r\n            String user = p.getUser();\r\n            if (_logger.isLoggable(Level.FINEST)) {\r\n                String realm = p.getRealm();\r\n                _logger.log(Level.FINEST, \"In LCD user-pass login:\" + user + \" realm :\" + realm);\r\n            }\r\n            setClientSecurityContext(user, fs);\r\n            return;\r\n        } else if (obj instanceof X509CertificateCredential) {\r\n            X509CertificateCredential p = (X509CertificateCredential) obj;\r\n            String user = p.getAlias();\r\n            if (_logger.isLoggable(Level.FINEST)) {\r\n                String realm = p.getRealm();\r\n                _logger.log(Level.FINEST, \"In LCD cert-login::\" + user + \" realm :\" + realm);\r\n            }\r\n            setClientSecurityContext(user, fs);\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.postClientAuth",
	"Comment": "extract the relevant username and realm information from thesubject and sets the correct state in the security context. therelevant information is set into the thread local storage fromwhich then is extracted to send over the wire.",
	"Method": "void postClientAuth(Subject subject,Class<?> clazz){\r\n    if (_logger.isLoggable(Level.FINEST)) {\r\n        _logger.log(Level.FINEST, \"LCD post login subject :\" + fs);\r\n    }\r\n    return fs.getPrivateCredentials(clas);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.postClientAuth",
	"Comment": "extract the relevant username and realm information from thesubject and sets the correct state in the security context. therelevant information is set into the thread local storage fromwhich then is extracted to send over the wire.",
	"Method": "void postClientAuth(Subject subject,Class<?> clazz){\r\n    return iter.next();\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.RoleMappingServiceImpl.findOrCreateDeploymentContext",
	"Comment": "find an existing roledeploymentcontext, or create a new one if one does not\talready exist for the specified application context.",
	"Method": "RoleMappingService.RoleDeploymentContext findOrCreateDeploymentContext(String appContext){\r\n    checkServiceAvailability();\r\n    return provider.findOrCreateDeploymentContext(appContext);\r\n}"
}, {
	"Path": "net.glowstone.chunk.ChunkSection.writeToNbt",
	"Comment": "writes this chunk section to a nbt compound. note that the y coordinate is not written.",
	"Method": "void writeToNbt(CompoundTag sectionTag){\r\n    char[] types = this.getTypes();\r\n    byte[] rawTypes = new byte[ChunkSection.ARRAY_SIZE];\r\n    NibbleArray extTypes = null;\r\n    NibbleArray data = new NibbleArray(ChunkSection.ARRAY_SIZE);\r\n    for (int j = 0; j < ChunkSection.ARRAY_SIZE; j++) {\r\n        char type = types[j];\r\n        rawTypes[j] = (byte) (type >> 4 & 0xFF);\r\n        byte extType = (byte) (type >> 12);\r\n        if (extType > 0) {\r\n            if (extTypes == null) {\r\n                extTypes = new NibbleArray(ChunkSection.ARRAY_SIZE);\r\n            }\r\n            extTypes.set(j, extType);\r\n        }\r\n        data.set(j, (byte) (type & 0xF));\r\n    }\r\n    sectionTag.putByteArray(\"Blocks\", rawTypes);\r\n    if (extTypes != null) {\r\n        sectionTag.putByteArray(\"Add\", extTypes.getRawData());\r\n    }\r\n    sectionTag.putByteArray(\"Data\", data.getRawData());\r\n    sectionTag.putByteArray(\"BlockLight\", blockLight.getRawData());\r\n    sectionTag.putByteArray(\"SkyLight\", skyLight.getRawData());\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.Dom.parent",
	"Comment": "if this dom is a child of another dom, the parent pointer.otherwise null.",
	"Method": "Dom parent(){\r\n    return parent;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.ChangeAdminPassword.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    String fileRealmClassName = fileAuthRealm.getClassname();\r\n    if (fileRealmClassName != null && !fileRealmClassName.equals(\"com.sun.enterprise.security.auth.realm.file.FileRealm\")) {\r\n        report.setMessage(localStrings.getLocalString(\"change.admin.password.adminrealmnotsupported\", \"Configured admin realm is not supported.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    String keyFile = null;\r\n    for (Property fileProp : fileAuthRealm.getProperty()) {\r\n        if (fileProp.getName().equals(\"file\"))\r\n            keyFile = fileProp.getValue();\r\n    }\r\n    if (keyFile == null) {\r\n        report.setMessage(localStrings.getLocalString(\"change.admin.password.keyfilenotfound\", \"There is no physical file associated with admin realm\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    FileRealm fr = null;\r\n    try {\r\n        realmsManager.createRealms(config);\r\n        fr = (FileRealm) realmsManager.getFromLoadedRealms(config.getName(), fileAuthRealm.getName());\r\n        if (fr == null) {\r\n            throw new NoSuchRealmException(fileAuthRealm.getName());\r\n        }\r\n    } catch (NoSuchRealmException e) {\r\n        report.setMessage(localStrings.getLocalString(\"change.admin.password.realmnotsupported\", \"Configured admin realm does not exist.\") + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    try {\r\n        Enumeration en = fr.getGroupNames(userName);\r\n        int size = 0;\r\n        while (en.hasMoreElements()) {\r\n            size++;\r\n            en.nextElement();\r\n        }\r\n        String[] groups = new String[size];\r\n        en = fr.getGroupNames(userName);\r\n        for (int i = 0; i < size; i++) {\r\n            groups[i] = (String) en.nextElement();\r\n        }\r\n        fr.updateUser(userName, userName, newpassword.toCharArray(), groups);\r\n        fr.persist();\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"change.admin.password.userupdatefailed\", \"Password change failed for user named {0}\", userName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.inventory.GlowItemFactory.toGlowMeta",
	"Comment": "throw a descriptive error if the given itemmeta does not belong to this factory.",
	"Method": "GlowMetaItem toGlowMeta(ItemMeta meta){\r\n    if (meta instanceof GlowMetaItem) {\r\n        return (GlowMetaItem) meta;\r\n    }\r\n    throw new IllegalArgumentException(\"Item meta \" + meta + \" was not created by GlowItemFactory\");\r\n}"
}, {
	"Path": "net.glowstone.io.nbt.NbtSerialization.writeItem",
	"Comment": "write an item stack to an nbt tag.null stacks produce an empty tag, and if slot is negative it is omitted from the result.",
	"Method": "CompoundTag writeItem(ItemStack stack,int slot){\r\n    CompoundTag tag = new CompoundTag();\r\n    if (stack == null || stack.getType() == Material.AIR) {\r\n        return tag;\r\n    }\r\n    tag.putString(\"id\", ItemIds.getName(stack.getType()));\r\n    tag.putShort(\"Damage\", stack.getDurability());\r\n    tag.putByte(\"Count\", stack.getAmount());\r\n    tag.putByte(\"Slot\", slot);\r\n    CompoundTag meta = GlowItemFactory.instance().writeNbt(stack.getItemMeta());\r\n    if (meta != null) {\r\n        tag.putCompound(\"tag\", meta);\r\n    }\r\n    return tag;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.ldap.LDAPRealm.getLdapBindProps",
	"Comment": "get binding properties defined in server.xml for ldap server.",
	"Method": "Properties getLdapBindProps(){\r\n    return (Properties) ldapBindProps.clone();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.getClientAliases",
	"Comment": "return all the available client aliases for the specified key type.",
	"Method": "String[] getClientAliases(String keyType,Principal[] issuers){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"Getting client aliases\");\r\n    }\r\n    return mgr.getClientAliases(keyType, issuers);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.common.PasswordCredential.hashCode",
	"Comment": "return the hashcode computed from the password and realm name.",
	"Method": "int hashCode(){\r\n    return username.hashCode() + Arrays.hashCode(password) + realm.hashCode();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.audit.BaseAuditManager.addAuditModule",
	"Comment": "add the given audit module to the list of loaded audit module.adding the same name twice will override previous one.",
	"Method": "BaseAuditModule addAuditModule(String name,String classname,Properties props){\r\n    removeAuditModule(name);\r\n    BaseAuditModule am = loadAuditModule(classname, props);\r\n    moduleToNameMap.put(am, name);\r\n    nameToModuleMap.put(name, am);\r\n    instances = copyAndAdd(instances, am);\r\n    if (isAuditModuleOfParameterizedType(am)) {\r\n        typedModules = copyAndAdd(typedModules, (T) am);\r\n    }\r\n    return am;\r\n}"
}, {
	"Path": "net.glowstone.inventory.GlowMetaPotion.dataFromString",
	"Comment": "converts a potion id string to the potiondata of this item meta.",
	"Method": "PotionData dataFromString(String string){\r\n    PotionType type;\r\n    boolean extended = false;\r\n    boolean upgraded = false;\r\n    if (string.startsWith(\"minecraft:\")) {\r\n        string = string.replace(\"minecraft:\", \"\");\r\n    }\r\n    if (string.startsWith(\"long_\")) {\r\n        string = string.replace(\"long_\", \"\");\r\n        extended = true;\r\n    } else if (string.startsWith(\"strong_\")) {\r\n        string = string.replace(\"strong_\", \"\");\r\n        upgraded = true;\r\n    }\r\n    type = PotionTypeTable.fromName(string);\r\n    return new PotionData(type, extended, upgraded);\r\n}"
}, {
	"Path": "org.glassfish.osgi.cli.interactive.LocalOSGiShellCommand.executeCommands",
	"Comment": "read commands from the specified bufferedreaderand execute them.if printprompt is set, prompt first.",
	"Method": "int executeCommands(ConsoleReader reader){\r\n    String line = null;\r\n    int rc = 0;\r\n    programOpts.toEnvironment(env);\r\n    String sessionId = startSession();\r\n    try {\r\n        for (; ; ) {\r\n            if (printPrompt) {\r\n                line = reader.readLine(shellType + \"$ \");\r\n            } else {\r\n                line = reader.readLine();\r\n            }\r\n            if (line == null) {\r\n                if (printPrompt) {\r\n                    System.out.println();\r\n                }\r\n                break;\r\n            }\r\n            if (line.trim().startsWith(\"#\")) {\r\n                continue;\r\n            }\r\n            String[] args = null;\r\n            try {\r\n                args = getArgs(line);\r\n            } catch (ArgumentTokenizer.ArgumentException ex) {\r\n                logger.info(ex.getMessage());\r\n                continue;\r\n            }\r\n            if (args.length == 0) {\r\n                continue;\r\n            }\r\n            String command = args[0];\r\n            if (command.trim().length() == 0) {\r\n                continue;\r\n            }\r\n            if (command.equals(\"exit\") || command.equals(\"quit\")) {\r\n                break;\r\n            }\r\n            ProgramOptions po = null;\r\n            try {\r\n                po = new ProgramOptions(env);\r\n                po.setClassPath(programOpts.getClassPath());\r\n                po.setClassName(programOpts.getClassName());\r\n                atomicReplace(locator, po);\r\n                args = prepareArguments(sessionId, args);\r\n                args = enhanceForTarget(args);\r\n                String output = cmd.executeAndReturnOutput(args).trim();\r\n                if (output != null && output.length() > 0) {\r\n                    logger.info(output);\r\n                }\r\n            } catch (CommandValidationException cve) {\r\n                logger.severe(cve.getMessage());\r\n                logger.severe(cmd.getUsage());\r\n                rc = ERROR;\r\n            } catch (InvalidCommandException ice) {\r\n                logger.severe(ice.getMessage());\r\n            } catch (CommandException ce) {\r\n                logger.severe(ce.getMessage());\r\n                rc = ERROR;\r\n            } finally {\r\n                atomicReplace(locator, programOpts);\r\n            }\r\n            CLIUtil.writeCommandToDebugLog(name, env, args, rc);\r\n        }\r\n    } finally {\r\n        rc = stopSession(sessionId);\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.BaseRealm.getGroupNames",
	"Comment": "returns names of all the groups in this particular realm.this method always throws a badrealmexception since by defaultthis operation is not supported. subclasses which support thismethod can override.",
	"Method": "Enumeration getGroupNames(){\r\n    String msg = sm.getString(\"iasrealm.notsupported\");\r\n    throw new BadRealmException(msg);\r\n}"
}, {
	"Path": "net.glowstone.util.GameRuleManager.getBoolean",
	"Comment": "gets the game rule value as a boolean. if the value cannot be parsed or does not exist, thenthis will return false.",
	"Method": "boolean getBoolean(String rule){\r\n    if (isGameRule(rule)) {\r\n        String value = getString(rule);\r\n        if (value != null) {\r\n            return Boolean.parseBoolean(value);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.glowstone.util.RectangularRegion.moveTo",
	"Comment": "creates a new region at the given corner with the same dimensions as this region.",
	"Method": "RectangularRegion moveTo(Location lowCorner){\r\n    return new RectangularRegion(lowCorner, new Location(lowCorner.getWorld(), lowCorner.getBlockX() + widthX, lowCorner.getBlockY() + widthY, lowCorner.getBlockZ() + widthZ));\r\n}"
}, {
	"Path": "net.glowstone.inventory.EquipmentMonitor.updateItem",
	"Comment": "update the given slot with the current value from the inventory.",
	"Method": "void updateItem(int slot){\r\n    ItemStack source = getItem(slot);\r\n    slots[slot] = source == null ? null : source.clone();\r\n}"
}, {
	"Path": "net.glowstone.inventory.crafting.CraftingManager.getLayers",
	"Comment": "get the amount of layers in the crafting matrix. this assumes all minecraft recipes have anitem stack of 1 for all items in the recipe.",
	"Method": "int getLayers(ItemStack items){\r\n    int layers = 0;\r\n    for (ItemStack item : items) {\r\n        if (!InventoryUtil.isEmpty(item) && (item.getAmount() < layers || layers == 0)) {\r\n            layers = item.getAmount();\r\n        }\r\n    }\r\n    return layers;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.doCertificateLogin",
	"Comment": "a special case login for handling x509certificatecredential.this does not get triggered based on current ri code. see x500login.",
	"Method": "void doCertificateLogin(Subject s){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"Processing X509 certificate login.\");\r\n    }\r\n    String realm = CertificateRealm.AUTH_TYPE;\r\n    String user = null;\r\n    try {\r\n        Object obj = getPublicCredentials(s, X509CertificateCredential.class);\r\n        X509CertificateCredential xp = (X509CertificateCredential) obj;\r\n        user = xp.getAlias();\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Set security context as user: \" + user);\r\n        }\r\n        setSecurityContext(user, s, realm);\r\n        if (getAuditManager().isAuditOn()) {\r\n            getAuditManager().authentication(user, realm, true);\r\n        }\r\n    } catch (LoginException le) {\r\n        if (getAuditManager().isAuditOn()) {\r\n            getAuditManager().authentication(user, realm, false);\r\n        }\r\n        throw le;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.AuthenticationServiceImpl.setupPasswordCredential",
	"Comment": "a passwordcredential object is needed when using the existing realm loginmodules.\tunless the callbackhandler is from the authenticationservice obtain the name\tand password from the supplied jaas callbackhandler directly. establishing the\tpasswordcredential in the subject is determined by service configuration.",
	"Method": "void setupPasswordCredential(Subject subject,CallbackHandler callbackHandler){\r\n    String username = null;\r\n    char[] password = null;\r\n    if (callbackHandler instanceof AuthenticationCallbackHandler) {\r\n        username = ((AuthenticationCallbackHandler) callbackHandler).getUsername();\r\n        password = ((AuthenticationCallbackHandler) callbackHandler).getPassword();\r\n    } else {\r\n        Callback[] callbacks = new Callback[2];\r\n        callbacks[0] = new NameCallback(\"username: \");\r\n        callbacks[1] = new PasswordCallback(\"password: \", false);\r\n        try {\r\n            callbackHandler.handle(callbacks);\r\n            username = ((NameCallback) callbacks[0]).getName();\r\n            password = ((PasswordCallback) callbacks[1]).getPassword();\r\n        } catch (IOException ioe) {\r\n            throw (LoginException) new LoginException(\"AuthenticationService unable to create PasswordCredential: \" + ioe.getMessage()).initCause(ioe);\r\n        } catch (UnsupportedCallbackException uce) {\r\n            throw (LoginException) new LoginException(\"AuthenticationService unable to create PasswordCredential: \" + uce.getMessage()).initCause(uce);\r\n        }\r\n    }\r\n    final Subject s = subject;\r\n    final PasswordCredential pc = new PasswordCredential(username, password, realmName);\r\n    AppservAccessController.doPrivileged(new PrivilegedAction<Object>() {\r\n        public Object run() {\r\n            s.getPrivateCredentials().add(pc);\r\n            return null;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.AuthenticationServiceImpl.setupPasswordCredential",
	"Comment": "a passwordcredential object is needed when using the existing realm loginmodules.\tunless the callbackhandler is from the authenticationservice obtain the name\tand password from the supplied jaas callbackhandler directly. establishing the\tpasswordcredential in the subject is determined by service configuration.",
	"Method": "void setupPasswordCredential(Subject subject,CallbackHandler callbackHandler){\r\n    s.getPrivateCredentials().add(pc);\r\n    return null;\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowPlayer.initLocation",
	"Comment": "read the location from a playerreader for entity initialization.will fall back to a reasonable default rather than returning null.",
	"Method": "Location initLocation(GlowSession session,PlayerReader reader){\r\n    if (reader.hasPlayedBefore()) {\r\n        Location loc = reader.getLocation();\r\n        if (loc != null) {\r\n            return loc;\r\n        }\r\n    }\r\n    return findSafeSpawnLocation(session.getServer().getWorlds().get(0).getSpawnLocation());\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.getCompoundList",
	"Comment": "returns the value of a list subtag with compoundtag elements.",
	"Method": "List<CompoundTag> getCompoundList(String key){\r\n    return (List<CompoundTag>) getTagList(key, TagType.COMPOUND);\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowEntity.setLeashHolderUniqueId",
	"Comment": "set the unique id of this entities leash holder. only useful during load of the entity.",
	"Method": "void setLeashHolderUniqueId(UUID uniqueId){\r\n    if (ticksLived > 1 || isLeashed()) {\r\n        return;\r\n    }\r\n    this.leashHolderUniqueId = uniqueId;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.impl.SecuritySupportImpl.getTrustStores",
	"Comment": "this method returns an array of truststores containing certificates.",
	"Method": "KeyStore[] getTrustStores(){\r\n    return trustStores.toArray(new KeyStore[trustStores.size()]);\r\n}"
}, {
	"Path": "org.glassfish.grizzly.config.ssl.JSSEKeyManager.getCertificateChain",
	"Comment": "returns the certificate chain associated with the given alias.",
	"Method": "X509Certificate[] getCertificateChain(String alias){\r\n    return delegate.getCertificateChain(alias);\r\n}"
}, {
	"Path": "net.glowstone.GlowServer.getResourcePackHash",
	"Comment": "get the resource pack hash for this server, or the empty string if not set.",
	"Method": "String getResourcePackHash(){\r\n    return config.getString(Key.RESOURCE_PACK_HASH);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.common.ClientSecurityContext.getCallerPrincipal",
	"Comment": "this method returns the caller principal. this information may be redundant since the same information can be inferred by inspecting the credentials of the caller.",
	"Method": "Principal getCallerPrincipal(){\r\n    return initiator;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.ClientCertificateLoginModule.login",
	"Comment": "authenticate the user by prompting for a username and password.",
	"Method": "boolean login(){\r\n    if (callbackHandler == null) {\r\n        throw new LoginException(\"Error: no CallbackHandler available \" + \"to garner authentication information from the user\");\r\n    }\r\n    try {\r\n        String[] as = new String[ks.size()];\r\n        String[] aliasString = new String[ks.size()];\r\n        Enumeration aliases = ks.aliases();\r\n        for (int i = 0; i < ks.size(); i++) {\r\n            aliasString[i] = (String) aliases.nextElement();\r\n            as[i] = ((X509Certificate) ks.getCertificate(aliasString[i])).getSubjectDN().getName();\r\n        }\r\n        Callback[] callbacks = new Callback[1];\r\n        callbacks[0] = new ChoiceCallback(localStrings.getLocalString(\"login.certificate\", \"Choose from list of certificates: \"), as, 0, false);\r\n        callbackHandler.handle(callbacks);\r\n        int[] idx = ((ChoiceCallback) callbacks[0]).getSelectedIndexes();\r\n        if (idx == null) {\r\n            throw new LoginException(\"No certificate selected!\");\r\n        } else if (idx[0] == -1) {\r\n            throw new LoginException(\"Incorrect keystore password\");\r\n        }\r\n        if (debug) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"\\t\\t[ClientCertificateLoginModule] \" + \"user entered certificate: \");\r\n                for (int i = 0; i < idx.length; i++) {\r\n                    _logger.log(Level.FINE, aliasString[idx[i]]);\r\n                }\r\n            }\r\n        }\r\n        this.alias = aliasString[idx[0]];\r\n        certificate = (X509Certificate) ks.getCertificate(alias);\r\n        if (debug) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"\\t\\t[ClientCertificateLoginModule] \" + \"authentication succeeded\");\r\n            }\r\n        }\r\n        succeeded = true;\r\n        return true;\r\n    } catch (java.io.IOException ioe) {\r\n        throw new LoginException(ioe.toString());\r\n    } catch (UnsupportedCallbackException uce) {\r\n        throw new LoginException(\"Error: \" + uce.getCallback().toString() + \" not available to garner authentication information \" + \"from the user\");\r\n    } catch (Exception e) {\r\n        throw new LoginException(e.toString());\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.constants.GlowPotionEffect.getEffect",
	"Comment": "get a glowpotioneffect from a potioneffecttype if possible.",
	"Method": "GlowPotionEffect getEffect(PotionEffectType type){\r\n    if (type instanceof GlowPotionEffect) {\r\n        return (GlowPotionEffect) type;\r\n    } else if (type instanceof PotionEffectTypeWrapper) {\r\n        return getEffect(getById(type.getId()));\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.constants.ItemIds.getItem",
	"Comment": "get the material corresponding to the specified item identifier.",
	"Method": "Material getItem(String name){\r\n    if (!items.containsKey(name)) {\r\n        return null;\r\n    }\r\n    return Material.getMaterial(items.get(name));\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.ListMessageSecurityProvider.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    secService.getMessageSecurityConfig();\r\n    report.getTopMessagePart().setMessage(localStrings.getLocalString(\"list.message.security.provider.success\", \"list-message-security-providers successful\"));\r\n    report.getTopMessagePart().setChildrenType(\"\");\r\n    for (MessageSecurityConfig msc : secService.getMessageSecurityConfig()) {\r\n        if (authLayer == null) {\r\n            for (ProviderConfig pc : msc.getProviderConfig()) {\r\n                ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n                part.setMessage(pc.getProviderId());\r\n            }\r\n        } else {\r\n            if (msc.getAuthLayer().equals(authLayer)) {\r\n                for (ProviderConfig pc : msc.getProviderConfig()) {\r\n                    ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n                    part.setMessage(pc.getProviderId());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.GlowServer.getCompressionThreshold",
	"Comment": "get the threshold to use for network compression defined in the config.",
	"Method": "int getCompressionThreshold(){\r\n    return config.getInt(Key.COMPRESSION_THRESHOLD);\r\n}"
}, {
	"Path": "net.glowstone.GlowWorld.playEffectExceptTo",
	"Comment": "plays an effect to all but one player within a given radius around a location.",
	"Method": "void playEffectExceptTo(Location location,Effect effect,int data,int radius,Player exclude){\r\n    checkNotNull(location);\r\n    checkNotNull(effect);\r\n    checkNotNull(exclude);\r\n    int radiusSquared = radius * radius;\r\n    getRawPlayers().stream().filter(player -> !player.equals(exclude) && player.getLocation().distanceSquared(location) <= radiusSquared).forEach(player -> player.playEffect(location, effect, data));\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.DeleteMessageSecurityProvider.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    ActionReport report = context.getActionReport();\r\n    List<ProviderConfig> pcs = msgSecCfg.getProviderConfig();\r\n    for (ProviderConfig pc : pcs) {\r\n        if (pc.getProviderId().equals(providerId)) {\r\n            thePC = pc;\r\n            try {\r\n                ConfigSupport.apply(new SingleConfigCode<MessageSecurityConfig>() {\r\n                    public Object run(MessageSecurityConfig param) throws PropertyVetoException, TransactionFailure {\r\n                        if ((param.getDefaultProvider() != null) && param.getDefaultProvider().equals(thePC.getProviderId())) {\r\n                            param.setDefaultProvider(null);\r\n                        }\r\n                        if ((param.getDefaultClientProvider() != null) && param.getDefaultClientProvider().equals(thePC.getProviderId())) {\r\n                            param.setDefaultClientProvider(null);\r\n                        }\r\n                        param.getProviderConfig().remove(thePC);\r\n                        return null;\r\n                    }\r\n                }, msgSecCfg);\r\n            } catch (TransactionFailure e) {\r\n                e.printStackTrace();\r\n                report.setMessage(localStrings.getLocalString(\"delete.message.security.provider.fail\", \"Deletion of message security provider named {0} failed\", providerId));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                report.setFailureCause(e);\r\n                return;\r\n            }\r\n            report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.DeleteMessageSecurityProvider.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    if ((param.getDefaultProvider() != null) && param.getDefaultProvider().equals(thePC.getProviderId())) {\r\n        param.setDefaultProvider(null);\r\n    }\r\n    if ((param.getDefaultClientProvider() != null) && param.getDefaultClientProvider().equals(thePC.getProviderId())) {\r\n        param.setDefaultClientProvider(null);\r\n    }\r\n    param.getProviderConfig().remove(thePC);\r\n    return null;\r\n}"
}, {
	"Path": "net.glowstone.scoreboard.GlowScoreboard.getForCriteria",
	"Comment": "get the internal set of objectives corresponding to a given criteria.",
	"Method": "Set<GlowObjective> getForCriteria(String criteria){\r\n    Set<GlowObjective> result = criteriaMap.computeIfAbsent(criteria, k -> new HashSet());\r\n    return result;\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.readByteArray",
	"Comment": "applies the given function to a byte array subtag if it is present.",
	"Method": "boolean readByteArray(String key,Consumer<? super byte[]> consumer){\r\n    return readTag(key, ByteArrayTag.class, consumer);\r\n}"
}, {
	"Path": "net.glowstone.inventory.GlowInventory.handleShiftClick",
	"Comment": "handle a shift click in this inventory by the specified player.the default implementation distributes items from the right to the left and from thebottom to the top.",
	"Method": "void handleShiftClick(GlowPlayer player,InventoryView view,int clickedSlot,ItemStack clickedItem){\r\n    clickedItem = player.getInventory().tryToFillSlots(clickedItem, 8, -1, 35, 8);\r\n    view.setItem(clickedSlot, clickedItem);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.common.X509CertificateCredential.hashCode",
	"Comment": "return the hashcode computed from the certificate, realm and alias.",
	"Method": "int hashCode(){\r\n    return Arrays.hashCode(certChain) + realm.hashCode() + ((alias != null) ? alias.hashCode() : 0);\r\n}"
}, {
	"Path": "net.glowstone.util.VariableValueArray.calculateNeededBits",
	"Comment": "calculates the number of bits that would be needed to store the given value.",
	"Method": "int calculateNeededBits(int number){\r\n    int count = 0;\r\n    do {\r\n        count++;\r\n        number >>>= 1;\r\n    } while (number != 0);\r\n    return count;\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowEntity.isWithinDistance",
	"Comment": "checks if this entity is within the visible radius of a location.",
	"Method": "boolean isWithinDistance(GlowEntity other,boolean isWithinDistance,Location loc){\r\n    double dx = Math.abs(location.getX() - loc.getX());\r\n    double dz = Math.abs(location.getZ() - loc.getZ());\r\n    return loc.getWorld() == getWorld() && dx <= server.getViewDistance() * GlowChunk.WIDTH && dz <= server.getViewDistance() * GlowChunk.HEIGHT;\r\n}"
}, {
	"Path": "net.glowstone.util.mojangson.Mojangson.parseLong",
	"Comment": "parses a long value from a mojangson string as an nbt longtag.",
	"Method": "LongTag parseLong(String mojangson){\r\n    Character lastChar = mojangson.charAt(mojangson.length() - 1);\r\n    if (lastChar.toString().toLowerCase().charAt(0) == MojangsonToken.LONG_SUFFIX.getSymbol()) {\r\n        mojangson = mojangson.substring(0, mojangson.length() - 1);\r\n    }\r\n    try {\r\n        return new LongTag(Long.valueOf(mojangson));\r\n    } catch (NumberFormatException nfe) {\r\n        throw new MojangsonParseException(\"\\'\" + mojangson + \"\\'\", MojangsonParseException.ParseExceptionReason.INVALID_FORMAT_NUM);\r\n    }\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.ConfigModel.getAttributeNames",
	"Comment": "returns the set of possible attributes names on this configuration model.",
	"Method": "Set<String> getAttributeNames(){\r\n    return Collections.unmodifiableSet(attributes.keySet());\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.readIntArray",
	"Comment": "applies the given function to an integer array subtag if it is present.",
	"Method": "boolean readIntArray(String key,Consumer<? super int[]> consumer){\r\n    return readTag(key, IntArrayTag.class, consumer);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.JarSigner.retrieveManifest",
	"Comment": "retrieve manifest from jar, create a default template if none exists.",
	"Method": "Manifest retrieveManifest(JarFile jf){\r\n    Manifest manifest = jf.getManifest();\r\n    if (manifest == null) {\r\n        manifest = new Manifest();\r\n        Attributes mainAttributes = manifest.getMainAttributes();\r\n        mainAttributes.putValue(Attributes.Name.MANIFEST_VERSION.toString(), \"1.0\");\r\n        mainAttributes.putValue(\"Created-By\", System.getProperty(\"java.version\") + \" (\" + System.getProperty(\"java.vendor\") + \")\");\r\n    }\r\n    Map<String, Attributes> entriesMap = manifest.getEntries();\r\n    for (Iterator<String> entries = entriesMap.keySet().iterator(); entries.hasNext(); ) {\r\n        if (jf.getJarEntry(entries.next()) == null) {\r\n            entries.remove();\r\n        }\r\n    }\r\n    return manifest;\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.initialize",
	"Comment": "initialize the security service instance with the specific security service configuration.",
	"Method": "void initialize(SecurityConfiguration securityServiceConfiguration){\r\n    if (InitializationState.NOT_INITIALIZED != initialized) {\r\n        return;\r\n    }\r\n    try {\r\n        if (!(securityServiceConfiguration instanceof org.glassfish.security.services.config.AuthorizationService)) {\r\n            throw new IllegalStateException(localStrings.getLocalString(\"service.atz.not_config\", \"The Authorization service is not configured in the domain configuration file.\"));\r\n        }\r\n        atzSvCfg = (org.glassfish.security.services.config.AuthorizationService) securityServiceConfiguration;\r\n        List<SecurityProvider> providersConfig = atzSvCfg.getSecurityProviders();\r\n        if ((providersConfig == null) || ((atzPrvConfig = providersConfig.get(0)) == null)) {\r\n            throw new IllegalStateException(localStrings.getLocalString(\"service.atz.no_prov_config\", \"No provider configured for the Authorization service in the domain configuration file.\"));\r\n        }\r\n        final String providerName = atzPrvConfig.getName();\r\n        if (isDebug()) {\r\n            logger.log(DEBUG_LEVEL, \"Attempting to get Authorization provider \\\"{0}\\\".\", providerName);\r\n        }\r\n        provider = AccessController.doPrivileged(new PrivilegedLookup<AuthorizationProvider>(serviceLocator, AuthorizationProvider.class, providerName));\r\n        if (provider == null) {\r\n            throw new IllegalStateException(localStrings.getLocalString(\"service.atz.not_provider\", \"Authorization Provider {0} not found.\", providerName));\r\n        }\r\n        provider.initialize(atzPrvConfig);\r\n        initialized = InitializationState.SUCCESS_INIT;\r\n        reasonInitFailed = null;\r\n        logger.log(Level.INFO, ATZSVC_INITIALIZED);\r\n    } catch (Exception e) {\r\n        String eMsg = e.getMessage();\r\n        String eClass = e.getClass().getName();\r\n        reasonInitFailed = localStrings.getLocalString(\"service.atz.init_failed\", \"Authorization Service initialization failed, exception {0}, message {1}\", eClass, eMsg);\r\n        logger.log(Level.WARNING, ATZSVC_INIT_FAILED, new Object[] { eClass, eMsg });\r\n        throw new RuntimeException(reasonInitFailed, e);\r\n    } finally {\r\n        if (InitializationState.SUCCESS_INIT != initialized) {\r\n            initialized = InitializationState.FAILED_INIT;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.GlowServer.main",
	"Comment": "creates a new server on tcp port 25565 and starts listening for connections.",
	"Method": "void main(String args){\r\n    try {\r\n        GlowServer server = createFromArguments(args);\r\n        if (server == null) {\r\n            return;\r\n        }\r\n        if (generateConfigOnly) {\r\n            ConsoleMessages.Info.CONFIG_ONLY_DONE.log();\r\n            return;\r\n        }\r\n        server.run();\r\n    } catch (SecurityException e) {\r\n        ConsoleMessages.Error.CLASSPATH.log(e);\r\n    } catch (Throwable t) {\r\n        ConsoleMessages.Error.STARTUP.log(t);\r\n        System.exit(1);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.block.blocktype.BlockType.warnMaterialData",
	"Comment": "display the warning for finding the wrong materialdata subclass.",
	"Method": "void warnMaterialData(Class<?> clazz,MaterialData data){\r\n    ConsoleMessages.Warn.Block.WRONG_MATERIAL_DATA.log(getMaterial(), getClass().getSimpleName(), clazz.getSimpleName(), data);\r\n}"
}, {
	"Path": "net.glowstone.constants.GlowParticle.getExtData",
	"Comment": "convert an object to an extdata array if possible for a particle.",
	"Method": "int[] getExtData(Effect particle,MaterialData material,int[] getExtData,Particle particle,Object object){\r\n    if (particle.getDataType() == Void.class) {\r\n        return EMPTY;\r\n    }\r\n    if (particle.getDataType() == MaterialData.class) {\r\n        if (object == null) {\r\n            return ONE_EMPTY;\r\n        }\r\n        MaterialData material = (MaterialData) object;\r\n        return new int[] { material.getItemTypeId() + (material.getData() << 12) };\r\n    }\r\n    if (particle.getDataType() == ItemStack.class) {\r\n        if (object == null) {\r\n            return TWO_EMPTY;\r\n        }\r\n        ItemStack item = (ItemStack) object;\r\n        return new int[] { item.getTypeId(), item.getDurability() };\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowLivingEntity.getAmbientDelay",
	"Comment": "get the minimal delay until the entity can produce an ambient sound.",
	"Method": "int getAmbientDelay(){\r\n    return 80;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.SecurityContext.getCallerPrincipal",
	"Comment": "this method returns the caller principal. this information may be redundant since the same information can be inferred by inspecting the credentials of the caller.",
	"Method": "Principal getCallerPrincipal(){\r\n    return this == defaultSecurityContext ? getDefaultCallerPrincipal() : initiator;\r\n}"
}, {
	"Path": "net.glowstone.util.NibbleArray.snapshot",
	"Comment": "take a snapshot of this nibblearray which will not reflect changes.",
	"Method": "NibbleArray snapshot(){\r\n    return new NibbleArray(rawData.clone());\r\n}"
}, {
	"Path": "org.glassfish.osgi.cli.remote.RemoteCommandSession.getId",
	"Comment": "get the identifier for this session, which is a uuid of type 4.",
	"Method": "String getId(){\r\n    return id;\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.readString",
	"Comment": "applies the given function to a string subtag if it is present.",
	"Method": "boolean readString(String key,Consumer<? super String> consumer){\r\n    return readTag(key, StringTag.class, consumer);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.audit.BaseAuditManager.loadAuditModules",
	"Comment": "this method initializes baseauditmanager which load audit modules andaudit enabled flag",
	"Method": "void loadAuditModules(){\r\n    try {\r\n        SecurityService securityBean = serverContext.getDefaultServices().getService(SecurityService.class, ServerEnvironment.DEFAULT_INSTANCE_NAME);\r\n        assert (securityBean != null);\r\n        boolean auditFlag = Boolean.parseBoolean(securityBean.getAuditEnabled());\r\n        setAuditOn(auditFlag);\r\n        List<com.sun.enterprise.config.serverbeans.AuditModule> am = securityBean.getAuditModule();\r\n        for (com.sun.enterprise.config.serverbeans.AuditModule it : am) {\r\n            try {\r\n                String name = it.getName();\r\n                String classname = it.getClassname();\r\n                Properties p = new Properties();\r\n                p.setProperty(NAME, name);\r\n                p.setProperty(CLASSNAME, classname);\r\n                List<Property> ep = it.getProperty();\r\n                for (Property prop : ep) {\r\n                    p.setProperty(prop.getName(), prop.getValue());\r\n                }\r\n                BaseAuditModule auditModule = loadAuditModule(classname, p);\r\n                instances.add(auditModule);\r\n                moduleToNameMap.put(auditModule, name);\r\n                nameToModuleMap.put(name, auditModule);\r\n                if (isAuditModuleOfParameterizedType(auditModule)) {\r\n                    typedModules.add((T) auditModule);\r\n                }\r\n            } catch (Exception ex) {\r\n                String msg = _localStrings.getLocalString(\"auditmgr.loaderror\", \"Audit: Cannot load AuditModule = {0}\", new Object[] { it.getName() });\r\n                _logger.log(Level.WARNING, msg, ex);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        String msg = _localStrings.getLocalString(\"auditmgr.badinit\", \"Audit: Cannot load Audit Module Initialization information. AuditModules will not be loaded.\");\r\n        _logger.log(Level.WARNING, msg, e);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.chunk.ChunkSection.snapshot",
	"Comment": "take a snapshot of this section which will not reflect future changes.",
	"Method": "ChunkSection snapshot(){\r\n    return new ChunkSection(data.clone(), palette == null ? null : new IntArrayList(palette), skyLight.snapshot(), blockLight.snapshot());\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.getManagerFromToken",
	"Comment": "find the corresponding x509keymanager associated to token in alias.it returns null if there is n",
	"Method": "X509KeyManager getManagerFromToken(String tokenAlias){\r\n    X509KeyManager keyMgr = null;\r\n    int ind = -1;\r\n    if (supportTokenAlias && tokenAlias != null && (ind = tokenAlias.indexOf(':')) != -1) {\r\n        String tokenName = alias.substring(0, ind);\r\n        keyMgr = tokenName2MgrMap.get(tokenName);\r\n    }\r\n    return keyMgr;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.SSLUtils.isKeyAvailable",
	"Comment": "this method checks whether a private key is available or not.",
	"Method": "boolean isKeyAvailable(){\r\n    return hasKey;\r\n}"
}, {
	"Path": "net.glowstone.chunk.ChunkManager.acquireLock",
	"Comment": "indicates that a chunk should be locked. a chunk may be locked multiple times, and will onlybe unloaded when all instances of a lock has been released.",
	"Method": "void acquireLock(Key key){\r\n    lockSet.add(key);\r\n}"
}, {
	"Path": "net.glowstone.io.nbt.NbtSerialization.readWorld",
	"Comment": "attempt to resolve a world based on the contents of a compound tag.",
	"Method": "World readWorld(GlowServer server,CompoundTag compound){\r\n    World world = compound.tryGetUuid(\"WorldUUIDMost\", \"WorldUUIDLeast\").map(server::getWorld).orElseGet(() -> compound.tryGetString(\"World\").map(server::getWorld).orElse(null));\r\n    if (world == null) {\r\n        world = compound.tryGetInt(\"Dimension\").map(World.Environment::getEnvironment).flatMap(env -> server.getWorlds().stream().filter(serverWorld -> env == serverWorld.getEnvironment()).findFirst()).orElse(null);\r\n    }\r\n    return world;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.ClientCertificateLoginModule.logout",
	"Comment": "logout the user. this method removes the principalimplthat was added by the commit method.",
	"Method": "boolean logout(){\r\n    ssl = null;\r\n    sslUtils.setAppclientSsl(ssl);\r\n    subject.getPrincipals().remove(userPrincipal);\r\n    succeeded = false;\r\n    commitSucceeded = false;\r\n    alias = null;\r\n    userPrincipal = null;\r\n    return true;\r\n}"
}, {
	"Path": "net.glowstone.net.ProxyData.getProfile",
	"Comment": "get a spoofed profile to use. returns null if the proxy did not send a username as part ofthe payload.",
	"Method": "GlowPlayerProfile getProfile(String name,GlowPlayerProfile getProfile){\r\n    if (name == null) {\r\n        return null;\r\n    }\r\n    return new GlowPlayerProfile(name, uuid, properties, true);\r\n}"
}, {
	"Path": "net.glowstone.generator.structures.util.StructureBuilder.createRandomItemsContainer",
	"Comment": "sets the given block to a container and fills it with random items.",
	"Method": "boolean createRandomItemsContainer(Vector pos,Random random,RandomItemsContent content,DirectionalContainer container,int maxStacks){\r\n    Vector vec = translate(pos);\r\n    if (boundingBox.isVectorInside(vec)) {\r\n        BlockState state = world.getBlockAt(vec.getBlockX(), vec.getBlockY(), vec.getBlockZ()).getState();\r\n        delegate.backupBlockState(state.getBlock());\r\n        state.setType(container.getItemType());\r\n        state.setData(container);\r\n        state.update(true);\r\n        return content.fillContainer(random, state, maxStacks);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.glowstone.generator.structures.util.StructureBoundingBox.expandTo",
	"Comment": "changes this bounding box to the bounding box of the union of itself and another boundingbox.",
	"Method": "void expandTo(StructureBoundingBox boundingBox){\r\n    min = new Vector(Math.min(min.getBlockX(), boundingBox.getMin().getBlockX()), Math.min(min.getBlockY(), boundingBox.getMin().getBlockY()), Math.min(min.getBlockZ(), boundingBox.getMin().getBlockZ()));\r\n    max = new Vector(Math.max(max.getBlockX(), boundingBox.getMax().getBlockX()), Math.max(max.getBlockY(), boundingBox.getMax().getBlockY()), Math.max(max.getBlockZ(), boundingBox.getMax().getBlockZ()));\r\n}"
}, {
	"Path": "net.glowstone.scheduler.GlowScheduler.syncIfNeeded",
	"Comment": "runs a task on the primary thread, and blocks waiting for it to finish.",
	"Method": "T syncIfNeeded(Callable<T> task){\r\n    if (isPrimaryThread()) {\r\n        return task.call();\r\n    } else {\r\n        return callSyncMethod(null, task).get();\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.readFloat",
	"Comment": "applies the given function to a float subtag if it is present.",
	"Method": "boolean readFloat(String key,FloatConsumer consumer){\r\n    if (isFloat(key)) {\r\n        consumer.accept(getFloat(key));\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.glowstone.io.entity.EntityStorage.create",
	"Comment": "creates an entity of the given glowstone class, by deserializing an empty tag.",
	"Method": "T create(Class<T> clazz,Location location){\r\n    return (T) find(clazz, clazz.getSimpleName()).createEntity(location, EMPTY_TAG);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.DeleteFileUser.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    String fileRealmClassName = fileAuthRealm.getClassname();\r\n    if (fileRealmClassName != null && !fileRealmClassName.equals(\"com.sun.enterprise.security.auth.realm.file.FileRealm\")) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.file.user.realmnotsupported\", \"Configured file realm {0} is not supported.\", fileRealmClassName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    String keyFile = null;\r\n    for (Property fileProp : fileAuthRealm.getProperty()) {\r\n        if (fileProp.getName().equals(\"file\"))\r\n            keyFile = fileProp.getValue();\r\n    }\r\n    final String kFile = keyFile;\r\n    if (keyFile == null) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.file.user.keyfilenotfound\", \"There is no physical file associated with this file realm {0} \", authRealmName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    boolean exists = (new File(kFile)).exists();\r\n    if (!exists) {\r\n        report.setMessage(localStrings.getLocalString(\"file.realm.keyfilenonexistent\", \"The specified physical file {0} associated with the file realm {1} does not exist.\", new Object[] { kFile, authRealmName }));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<SecurityService>() {\r\n            public Object run(SecurityService param) throws PropertyVetoException, TransactionFailure {\r\n                try {\r\n                    realmsManager.createRealms(config);\r\n                    final FileRealm fr = (FileRealm) realmsManager.getFromLoadedRealms(config.getName(), authRealmName);\r\n                    fr.removeUser(userName);\r\n                    fr.persist();\r\n                    CreateFileUser.refreshRealm(config.getName(), authRealmName);\r\n                    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n                } catch (NoSuchUserException e) {\r\n                    report.setMessage(localStrings.getLocalString(\"delete.file.user.usernotfound\", \"There is no such existing user {0} in the file realm {1}.\", userName, authRealmName) + \"  \" + e.getLocalizedMessage());\r\n                    report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                    report.setFailureCause(e);\r\n                } catch (BadRealmException e) {\r\n                    report.setMessage(localStrings.getLocalString(\"delete.file.user.realmcorrupted\", \"Configured file realm {0} is corrupted.\", authRealmName) + \"  \" + e.getLocalizedMessage());\r\n                    report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                    report.setFailureCause(e);\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                    report.setMessage(localStrings.getLocalString(\"delete.file.user.userdeletefailed\", \"Removing User {0} from file realm {1} failed\", userName, authRealmName) + \"  \" + e.getLocalizedMessage());\r\n                    report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                    report.setFailureCause(e);\r\n                }\r\n                return null;\r\n            }\r\n        }, securityService);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.file.user.userdeletefailed\", \"Removing User {0} from file realm {1} failed\", userName, authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.DeleteFileUser.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    try {\r\n        realmsManager.createRealms(config);\r\n        final FileRealm fr = (FileRealm) realmsManager.getFromLoadedRealms(config.getName(), authRealmName);\r\n        fr.removeUser(userName);\r\n        fr.persist();\r\n        CreateFileUser.refreshRealm(config.getName(), authRealmName);\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (NoSuchUserException e) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.file.user.usernotfound\", \"There is no such existing user {0} in the file realm {1}.\", userName, authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    } catch (BadRealmException e) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.file.user.realmcorrupted\", \"Configured file realm {0} is corrupted.\", authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        report.setMessage(localStrings.getLocalString(\"delete.file.user.userdeletefailed\", \"Removing User {0} from file realm {1} failed\", userName, authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.glowstone.block.blocktype.BlockNeedsAttached.canAttachTo",
	"Comment": "called to determine if the target block can be attached towhen right clicking it.",
	"Method": "boolean canAttachTo(GlowBlock block,BlockFace against){\r\n    return !(ItemTable.instance().getBlock(block.getRelative(against.getOppositeFace()).getType()) instanceof BlockNeedsAttached);\r\n}"
}, {
	"Path": "net.glowstone.inventory.GlowInventory.setTitle",
	"Comment": "set the custom title of this inventory or reset it to the default.",
	"Method": "void setTitle(String title){\r\n    if (title == null) {\r\n        this.title = type.getDefaultTitle();\r\n    } else {\r\n        this.title = title;\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.readInt",
	"Comment": "applies the given function to an integer subtag if it is present.",
	"Method": "boolean readInt(String key,IntConsumer consumer){\r\n    if (isInt(key)) {\r\n        consumer.accept(getInt(key));\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.glowstone.util.UuidUtils.toString",
	"Comment": "converts a uuid to a hexadecimal string with hyphens.this method uses the fastuuid library for faster serialization in java 8.",
	"Method": "String toString(UUID uuid){\r\n    return FastUUID.toString(uuid);\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.Dom.copy",
	"Comment": "returns a copy of itself providing the parent for the new copy.",
	"Method": "T copy(T parent){\r\n    return (T) new Dom(this, parent);\r\n}"
}, {
	"Path": "org.glassfish.resourcebase.resources.listener.ResourceManager.addListenerToResource",
	"Comment": "add listener to a generic resourceused in the case of create asadmin command when listeners have tobe added to the specific resource",
	"Method": "void addListenerToResource(Object instance){\r\n    ObservableBean bean = null;\r\n    if (instance instanceof Resource) {\r\n        bean = (ObservableBean) ConfigSupport.getImpl((ConfigBeanProxy) instance);\r\n        bean.addListener(this);\r\n    } else if (instance instanceof ResourceRef) {\r\n        bean = (ObservableBean) ConfigSupport.getImpl((ConfigBeanProxy) instance);\r\n        bean.addListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.util.TextMessage.asPlaintext",
	"Comment": "attempt to convert the message to its plaintext representation.",
	"Method": "String asPlaintext(){\r\n    if (object.containsKey(\"text\")) {\r\n        Object obj = object.get(\"text\");\r\n        if (obj instanceof String) {\r\n            return (String) obj;\r\n        }\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "com.sun.enterprise.security.BaseRealm.getUser",
	"Comment": "returns the information recorded about a particular named user.this method always throws a badrealmexception since by defaultthis operation is not supported. subclasses which support thismethod can override.",
	"Method": "User getUser(String name){\r\n    String msg = sm.getString(\"iasrealm.notsupported\");\r\n    throw new BadRealmException(msg);\r\n}"
}, {
	"Path": "net.glowstone.chunk.ChunkManager.releaseLock",
	"Comment": "releases one instance of a chunk lock. a chunk may be locked multiple times, and will only beunloaded when all instances of a lock has been released.",
	"Method": "void releaseLock(Key key){\r\n    lockSet.remove(key);\r\n}"
}, {
	"Path": "org.glassfish.resourcebase.resources.api.ResourceProxy.getResourceDeployer",
	"Comment": "given a resource instance, appropriate deployer will be provided",
	"Method": "org.glassfish.resourcebase.resources.api.ResourceDeployer getResourceDeployer(Object resource){\r\n    return resourceManagerFactoryProvider.get().getResourceDeployer(resource);\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.ConfigSupport._deleteChild",
	"Comment": "unprotected child deletion, caller must start a transaction before calling thismethod.",
	"Method": "void _deleteChild(ConfigBean parent,WriteableView writeableParent,ConfigBean child){\r\n    final Class<? extends ConfigBeanProxy> childType = child.getProxyType();\r\n    ConfigBeanProxy childProxy = child.getProxy(childType);\r\n    Class parentProxyType = parent.getProxyType();\r\n    ConfigModel.Property element = null;\r\n    for (ConfigModel.Property e : parent.model.elements.values()) {\r\n        if (!(e instanceof ConfigModel.Node)) {\r\n            continue;\r\n        }\r\n        ConfigModel elementModel = ((ConfigModel.Node) e).model;\r\n        try {\r\n            final Class<?> targetClass = parent.model.classLoaderHolder.loadClass(elementModel.targetTypeName);\r\n            if (targetClass.isAssignableFrom(childType)) {\r\n                element = e;\r\n                break;\r\n            }\r\n        } catch (Exception ex) {\r\n        }\r\n    }\r\n    if (element != null) {\r\n        if (element.isCollection()) {\r\n            for (Method m : parentProxyType.getMethods()) {\r\n                final Class returnType = m.getReturnType();\r\n                if (Collection.class.isAssignableFrom(returnType) && (m.getParameterTypes().length == 0)) {\r\n                    if (!(m.getGenericReturnType() instanceof ParameterizedType))\r\n                        throw new IllegalArgumentException(\"List needs to be parameterized\");\r\n                    final Class itemType = Types.erasure(Types.getTypeArgument(m.getGenericReturnType(), 0));\r\n                    if (itemType.isAssignableFrom(childType)) {\r\n                        List list = null;\r\n                        try {\r\n                            list = (List) m.invoke(writeableParent.getProxy(writeableParent.<ConfigBeanProxy>getProxyType()), null);\r\n                        } catch (IllegalAccessException e) {\r\n                            throw new TransactionFailure(\"Exception while adding to the parent\", e);\r\n                        } catch (InvocationTargetException e) {\r\n                            throw new TransactionFailure(\"Exception while adding to the parent\", e);\r\n                        }\r\n                        if (list != null) {\r\n                            list.remove(childProxy);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            writeableParent.setter(element, null, childType);\r\n        }\r\n    } else {\r\n        throw new TransactionFailure(\"Parent \" + parent.getProxyType() + \" does not have a child of type \" + childType);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.file.FileRealm.getUser",
	"Comment": "returns the information recorded about a particular named user.",
	"Method": "User getUser(String name){\r\n    FileRealmHelper.User u = helper.getUser(name);\r\n    if (u == null) {\r\n        String msg = sm.getString(\"filerealm.nouser\", name);\r\n        throw new NoSuchUserException(msg);\r\n    }\r\n    return new FileRealmUser(u, null);\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.readStringList",
	"Comment": "applies the given function to a list subtag if it is present and its contents are stringtags.",
	"Method": "boolean readStringList(String key,Consumer<? super List<String>> consumer){\r\n    return readList(key, TagType.STRING, consumer);\r\n}"
}, {
	"Path": "net.glowstone.entity.AttributeManager.getPropertyValue",
	"Comment": "returns the base value of the given property with all modifiers applied.",
	"Method": "double getPropertyValue(Key key){\r\n    Property property = properties.get(key.toString());\r\n    return property == null ? key.getDef() : property.getValue();\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.postConstruct",
	"Comment": "called when the instance has been created and the component isabout to be place into commission.the component has been injected with any dependency andwill be placed into commission by the subsystem.hk2 will catch all unchecked exceptions,and will consequently cause the backing inhabitant to be released.",
	"Method": "void postConstruct(){\r\n    org.glassfish.security.services.config.AuthorizationService atzConfiguration = ServiceFactory.getSecurityServiceConfiguration(domain, org.glassfish.security.services.config.AuthorizationService.class);\r\n    initialize(atzConfiguration);\r\n}"
}, {
	"Path": "net.glowstone.scoreboard.GlowScoreboard.getScoresForName",
	"Comment": "get the internal set of scores corresponding to a given entry.",
	"Method": "Set<GlowScore> getScoresForName(String entry){\r\n    Set<GlowScore> result = scoreMap.computeIfAbsent(entry, k -> new HashSet());\r\n    return result;\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.readDoubleList",
	"Comment": "applies the given function to a list subtag if it is present and its contents are doubletags.",
	"Method": "boolean readDoubleList(String key,Consumer<? super List<Double>> consumer){\r\n    return readList(key, TagType.DOUBLE, consumer);\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.ConfigBean.addInterceptor",
	"Comment": "add a new configbeaninterceptor to this configbean instance. the inteceptor willbe called each time a attribute of this bean is accessed.",
	"Method": "void addInterceptor(Class<?> interceptorType,ConfigBeanInterceptor interceptor){\r\n    optionalFeatures.put(interceptorType, interceptor);\r\n}"
}, {
	"Path": "net.glowstone.block.entity.BlockEntity.getState",
	"Comment": "create a new blockstate which will correspond to this block entity.",
	"Method": "GlowBlockState getState(){\r\n    return null;\r\n}"
}, {
	"Path": "net.glowstone.util.VariableValueArray.increaseBitsPerValueTo",
	"Comment": "creates a new variablevaluearray with the contents of this one, and the given bits pervalue.",
	"Method": "VariableValueArray increaseBitsPerValueTo(int newBitsPerValue){\r\n    if (newBitsPerValue < this.bitsPerValue) {\r\n        throw new IllegalArgumentException(\"Cannot decrease bits per value!  (was \" + this.bitsPerValue + \", new size \" + newBitsPerValue + \")\");\r\n    } else if (newBitsPerValue == this.bitsPerValue) {\r\n        throw new IllegalArgumentException(\"Cannot resize to the same size!  (size was \" + newBitsPerValue + \")\");\r\n    }\r\n    VariableValueArray returned = new VariableValueArray(newBitsPerValue, this.capacity);\r\n    for (int i = 0; i < this.capacity; i++) {\r\n        returned.set(i, this.get(i));\r\n    }\r\n    return returned;\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowPlayer.updateUserListEntries",
	"Comment": "send a userlistitemmessage to every player that can see this player.",
	"Method": "void updateUserListEntries(UserListItemMessage updateMessage){\r\n    server.getRawOnlinePlayers().stream().filter(player -> player.canSee(this)).forEach(player -> player.getSession().send(updateMessage));\r\n}"
}, {
	"Path": "net.glowstone.util.GlowHelpMap.initializeCommands",
	"Comment": "processes all the commands registered in the server and creates help topics for them.",
	"Method": "void initializeCommands(){\r\n    if (ignoredPlugins.contains(\"All\")) {\r\n        return;\r\n    }\r\n    Collection<Command> commands = server.getCommandMap().getCommands();\r\n    outer: for (Command command : commands) {\r\n        if (commandInIgnoredPlugin(command)) {\r\n            continue;\r\n        }\r\n        for (Entry<Class, HelpTopicFactory<Command>> entry : topicFactoryMap.entrySet()) {\r\n            if (((Class<?>) entry.getKey()).isAssignableFrom(command.getClass())) {\r\n                HelpTopic t = entry.getValue().createTopic(command);\r\n                if (t != null) {\r\n                    addCommandTopic(t);\r\n                }\r\n                continue outer;\r\n            }\r\n            if (command instanceof PluginCommand && ((Class<?>) entry.getKey()).isAssignableFrom(((PluginCommand) command).getExecutor().getClass())) {\r\n                HelpTopic t = entry.getValue().createTopic(command);\r\n                if (t != null) {\r\n                    addCommandTopic(t);\r\n                }\r\n                continue outer;\r\n            }\r\n        }\r\n        addCommandTopic(new GenericCommandHelpTopic(command));\r\n    }\r\n    Set<HelpTopic> aliases = new TreeSet(TOPIC_COMPARE);\r\n    for (Command command : commands) {\r\n        if (commandInIgnoredPlugin(command)) {\r\n            continue;\r\n        }\r\n        HelpTopic original = getHelpTopic(\"/\" + command.getLabel());\r\n        if (original != null) {\r\n            for (String alias : command.getAliases()) {\r\n                HelpTopic aliasTopic = new AliasTopic(\"/\" + alias, original);\r\n                if (!helpTopics.containsKey(aliasTopic.getName())) {\r\n                    aliases.add(aliasTopic);\r\n                    addPrivateTopic(aliasTopic);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (!aliases.isEmpty()) {\r\n        addTopic(new IndexHelpTopic(\"Aliases\", \"Lists command aliases\", null, aliases, null));\r\n    }\r\n    Map<String, Set<HelpTopic>> pluginIndexes = new HashMap();\r\n    for (Command command : commands) {\r\n        String pluginName = getCommandPluginName(command);\r\n        if (pluginName != null) {\r\n            HelpTopic topic = getHelpTopic(\"/\" + command.getLabel());\r\n            if (topic != null) {\r\n                if (!pluginIndexes.containsKey(pluginName)) {\r\n                    pluginIndexes.put(pluginName, new TreeSet(TOPIC_COMPARE));\r\n                }\r\n                pluginIndexes.get(pluginName).add(topic);\r\n            }\r\n        }\r\n    }\r\n    for (Entry<String, Set<HelpTopic>> entry : pluginIndexes.entrySet()) {\r\n        String key = entry.getKey();\r\n        addTopic(new IndexHelpTopic(key, \"All commands for \" + key, null, entry.getValue(), \"Below is a list of all \" + key + \" commands:\"));\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.entity.meta.ClientSettings.showCommands",
	"Comment": "get whether command output should be shown based on chat flags.",
	"Method": "boolean showCommands(){\r\n    return chatFlags != CHAT_HIDDEN;\r\n}"
}, {
	"Path": "net.glowstone.entity.EntityManager.move",
	"Comment": "notes that an entity has moved from one location to another for physics and storage purposes.",
	"Method": "void move(GlowEntity entity,Location newLocation){\r\n    Chunk prevChunk = entity.location.getChunk();\r\n    Chunk newChunk = newLocation.getChunk();\r\n    if (prevChunk != newChunk) {\r\n        ((GlowChunk) prevChunk).getRawEntities().remove(entity);\r\n        ((GlowChunk) newChunk).getRawEntities().add(entity);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.doClientLogin",
	"Comment": "perform login on the client side.it just simulates the login on the client side.the method uses the callback handlers and generates correctcredential information that will be later sent to the server",
	"Method": "Subject doClientLogin(int type,javax.security.auth.callback.CallbackHandler jaasHandler){\r\n    final javax.security.auth.callback.CallbackHandler handler = jaasHandler;\r\n    final Subject subject = new Subject();\r\n    if (type == SecurityConstants.USERNAME_PASSWORD) {\r\n        AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n            public java.lang.Object run() {\r\n                try {\r\n                    LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n                    lg.login();\r\n                } catch (javax.security.auth.login.LoginException e) {\r\n                    throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        postClientAuth(subject, PasswordCredential.class);\r\n        return subject;\r\n    } else if (type == SecurityConstants.CERTIFICATE) {\r\n        AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n            public java.lang.Object run() {\r\n                try {\r\n                    LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_CERTIFICATE, subject, handler);\r\n                    lg.login();\r\n                } catch (javax.security.auth.login.LoginException e) {\r\n                    throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        postClientAuth(subject, X509CertificateCredential.class);\r\n        return subject;\r\n    } else if (type == SecurityConstants.ALL) {\r\n        AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n            public java.lang.Object run() {\r\n                try {\r\n                    LoginContext lgup = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n                    LoginContext lgc = new LoginContext(SecurityConstants.CLIENT_JAAS_CERTIFICATE, subject, handler);\r\n                    lgup.login();\r\n                    postClientAuth(subject, PasswordCredential.class);\r\n                    lgc.login();\r\n                    postClientAuth(subject, X509CertificateCredential.class);\r\n                } catch (javax.security.auth.login.LoginException e) {\r\n                    throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        return subject;\r\n    } else {\r\n        AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n            public java.lang.Object run() {\r\n                try {\r\n                    LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n                    lg.login();\r\n                    postClientAuth(subject, PasswordCredential.class);\r\n                } catch (javax.security.auth.login.LoginException e) {\r\n                    throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n        return subject;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.doClientLogin",
	"Comment": "perform login on the client side.it just simulates the login on the client side.the method uses the callback handlers and generates correctcredential information that will be later sent to the server",
	"Method": "Subject doClientLogin(int type,javax.security.auth.callback.CallbackHandler jaasHandler){\r\n    try {\r\n        LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n        lg.login();\r\n    } catch (javax.security.auth.login.LoginException e) {\r\n        throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.doClientLogin",
	"Comment": "perform login on the client side.it just simulates the login on the client side.the method uses the callback handlers and generates correctcredential information that will be later sent to the server",
	"Method": "Subject doClientLogin(int type,javax.security.auth.callback.CallbackHandler jaasHandler){\r\n    try {\r\n        LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_CERTIFICATE, subject, handler);\r\n        lg.login();\r\n    } catch (javax.security.auth.login.LoginException e) {\r\n        throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.doClientLogin",
	"Comment": "perform login on the client side.it just simulates the login on the client side.the method uses the callback handlers and generates correctcredential information that will be later sent to the server",
	"Method": "Subject doClientLogin(int type,javax.security.auth.callback.CallbackHandler jaasHandler){\r\n    try {\r\n        LoginContext lgup = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n        LoginContext lgc = new LoginContext(SecurityConstants.CLIENT_JAAS_CERTIFICATE, subject, handler);\r\n        lgup.login();\r\n        postClientAuth(subject, PasswordCredential.class);\r\n        lgc.login();\r\n        postClientAuth(subject, X509CertificateCredential.class);\r\n    } catch (javax.security.auth.login.LoginException e) {\r\n        throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.doClientLogin",
	"Comment": "perform login on the client side.it just simulates the login on the client side.the method uses the callback handlers and generates correctcredential information that will be later sent to the server",
	"Method": "Subject doClientLogin(int type,javax.security.auth.callback.CallbackHandler jaasHandler){\r\n    try {\r\n        LoginContext lg = new LoginContext(SecurityConstants.CLIENT_JAAS_PASSWORD, subject, handler);\r\n        lg.login();\r\n        postClientAuth(subject, PasswordCredential.class);\r\n    } catch (javax.security.auth.login.LoginException e) {\r\n        throw (LoginException) new LoginException(e.toString()).initCause(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.tryGetUuid",
	"Comment": "returns a uuid extracted from the given pair of long subtags, if they both exist.",
	"Method": "Optional<UUID> tryGetUuid(String keyMost,String keyLeast){\r\n    if (isLong(keyMost) && isLong(keyLeast)) {\r\n        return Optional.of(new UUID(getLong(keyMost), getLong(keyLeast)));\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "org.glassfish.grizzly.config.HttpRedirectTest.tryAlias",
	"Comment": "check the localhost aliases, cause server might return not localhost, but 127.0.0.1",
	"Method": "boolean tryAlias(String expectedLocation,String line){\r\n    final InetAddress[] ias = InetAddress.getAllByName(\"localhost\");\r\n    if (ias != null) {\r\n        for (InetAddress ia : ias) {\r\n            String byHost = ia.getHostName();\r\n            String byAddr = ia.getHostAddress();\r\n            String alias1 = expectedLocation.replace(\"localhost\", byHost).toLowerCase();\r\n            if (alias1.equals(line)) {\r\n                return true;\r\n            }\r\n            String alias2 = expectedLocation.replace(\"localhost\", byAddr).toLowerCase();\r\n            if (alias2.equals(line)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.glowstone.block.entity.state.GlowDispenser.getDispenseBehavior",
	"Comment": "returns the dispense behavior that will dispense this type of item.",
	"Method": "DispenseBehavior getDispenseBehavior(Material itemType){\r\n    return getDispenseBehaviorRegistry().getBehavior(itemType);\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowLivingEntity.launchProjectile",
	"Comment": "throws and returns a projectile, initializing its velocity.",
	"Method": "T launchProjectile(Class<? extends T> type,T launchProjectile,Class<? extends T> type,Vector vector,T launchProjectile,Class<? extends T> type,Vector vector,float offset,float speed,T launchProjectile,Class<? extends T> type,Location location,Vector originalVector,float pitchOffset,float velocity,T launchProjectile,Class<? extends T> type,Location location,double x,double y,double z,float speed){\r\n    double magnitude = Math.sqrt(x * x + y * y + z * z);\r\n    if (magnitude > 0) {\r\n        x += (x * (speed - magnitude)) / magnitude;\r\n        y += (y * (speed - magnitude)) / magnitude;\r\n        z += (z * (speed - magnitude)) / magnitude;\r\n    }\r\n    location.add(location.getDirection());\r\n    location.setPitch(0);\r\n    location.setYaw(0);\r\n    T projectile = ((GlowWorld) location.getWorld()).spawn(location, type);\r\n    ProjectileLaunchEvent launchEvent = EventFactory.getInstance().callEvent(new ProjectileLaunchEvent(projectile));\r\n    if (launchEvent.isCancelled()) {\r\n        projectile.remove();\r\n    }\r\n    projectile.setVelocity(new Vector(x, y, z));\r\n    ((GlowProjectile) projectile).setRawLocation(location);\r\n    return projectile;\r\n}"
}, {
	"Path": "net.glowstone.GlowServer.getGenerator",
	"Comment": "gets the default chunkgenerator for the given environment and type.",
	"Method": "ChunkGenerator getGenerator(String name,Environment environment,WorldType type){\r\n    ConfigurationSection worlds = config.getWorlds();\r\n    if (worlds != null) {\r\n        String genName = worlds.getString(name + \".generator\", null);\r\n        ChunkGenerator generator = WorldCreator.getGeneratorForName(name, genName, getConsoleSender());\r\n        if (generator != null) {\r\n            return generator;\r\n        }\r\n    }\r\n    if (environment == Environment.NETHER) {\r\n        return new NetherGenerator();\r\n    } else if (environment == Environment.THE_END) {\r\n        return new TheEndGenerator();\r\n    } else {\r\n        if (type == WorldType.FLAT) {\r\n            return new SuperflatGenerator();\r\n        } else {\r\n            return new OverworldGenerator();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.impl.SecuritySupportImpl.getKeyStores",
	"Comment": "this method returns an array of keystores containing keys andcertificates.",
	"Method": "KeyStore[] getKeyStores(){\r\n    return keyStores.toArray(new KeyStore[keyStores.size()]);\r\n}"
}, {
	"Path": "net.glowstone.entity.EntityRegistry.getEntity",
	"Comment": "gets the implementation class for the given entity interface class.",
	"Method": "Class<? extends GlowEntity> getEntity(EntityType type,Class<? extends GlowEntity> getEntity,Class<? extends Entity> clazz){\r\n    if (GlowEntity.class.isAssignableFrom(clazz)) {\r\n        return (Class<? extends GlowEntity>) clazz;\r\n    }\r\n    return ENTITIES.get(clazz);\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowEntity.shouldSave",
	"Comment": "checks whether this entity should be saved as part of the world.",
	"Method": "boolean shouldSave(){\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.UpdatePasswordAlias.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        if (!domainPasswordAliasStore.containsKey(aliasName)) {\r\n            report.setMessage(localStrings.getLocalString(\"update.password.alias.notfound\", \"Password alias for the alias {0} does not exist.\", aliasName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n        domainPasswordAliasStore.put(aliasName, aliasPassword.toCharArray());\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n        report.setMessage(localStrings.getLocalString(\"update.password.alias.fail\", \"Update of Password Alias {0} failed\", aliasName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(ex);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    report.setMessage(localStrings.getLocalString(\"update.password.alias.success\", \"Encrypted password for the alias {0} updated successfully\", aliasName));\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.setSecurityContext",
	"Comment": "this method sets the security context on the current thread local storage",
	"Method": "void setSecurityContext(String userName,Subject subject,String realm){\r\n    SecurityContext securityContext = new SecurityContext(userName, subject, realm);\r\n    SecurityContext.setCurrent(securityContext);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.DeleteAuthRealm.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    ActionReport report = context.getActionReport();\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<SecurityService>() {\r\n            public Object run(SecurityService param) throws PropertyVetoException, TransactionFailure {\r\n                param.getAuthRealm().remove(authRealm);\r\n                SecurityConfigListener.authRealmDeleted(authRealm);\r\n                return null;\r\n            }\r\n        }, securityService);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.auth.realm.fail\", \"Deletion of Authrealm {0} failed\", authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.DeleteAuthRealm.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    param.getAuthRealm().remove(authRealm);\r\n    SecurityConfigListener.authRealmDeleted(authRealm);\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.tests.utils.NucleusTestUtils.getURL",
	"Comment": "this methods opens a connection to the given url andreturns the string that is returned from that url.thisis useful for simple servlet retrieval",
	"Method": "String getURL(String urlstr){\r\n    StringWriter ow = null;\r\n    BufferedReader ir = null;\r\n    try {\r\n        URL u = new URL(urlstr);\r\n        URLConnection urlc = u.openConnection();\r\n        ir = new BufferedReader(new InputStreamReader(urlc.getInputStream(), \"ISO-8859-1\"));\r\n        try {\r\n            ow = new StringWriter();\r\n            String line;\r\n            while ((line = ir.readLine()) != null) {\r\n                ow.write(line);\r\n                ow.write(\"\\n\");\r\n            }\r\n            return ow.getBuffer().toString();\r\n        } finally {\r\n            if (ow != null) {\r\n                ow.close();\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        System.out.println(\"unable to fetch URL:\" + urlstr + \", reason: \" + ex.getMessage());\r\n        return \"\";\r\n    } finally {\r\n        if (ir != null) {\r\n            try {\r\n                ir.close();\r\n            } catch (IOException ex) {\r\n                Logger.getLogger(NucleusTestUtils.class.getName()).log(Level.SEVERE, null, ex);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.ConfigSupport.getAttributesNames",
	"Comment": "returns the list of attributes names by the passed configbean",
	"Method": "String[] getAttributesNames(ConfigBean bean){\r\n    return xmlNames(bean.model.attributes.values());\r\n}"
}, {
	"Path": "net.glowstone.command.minecraft.TitleCommand.convertJson",
	"Comment": "converts a valid json chat component to a basic colored string. this does not parsecomponents like hover or click events. this returns null on parse failure.",
	"Method": "String convertJson(Map<String, Object> json){\r\n    if (json == null || !json.containsKey(\"text\") && !(json.get(\"text\") instanceof String)) {\r\n        return null;\r\n    }\r\n    ChatColor color = ChatColor.WHITE;\r\n    List<ChatColor> style = new ArrayList();\r\n    for (Object key : json.keySet()) {\r\n        if (!(key instanceof String)) {\r\n            continue;\r\n        }\r\n        String keyString = (String) key;\r\n        if (keyString.equalsIgnoreCase(\"color\")) {\r\n            if (!(json.get(\"color\") instanceof String)) {\r\n                return null;\r\n            }\r\n            color = toColor((String) json.get(keyString));\r\n        } else if (!keyString.equalsIgnoreCase(\"text\")) {\r\n            if (toColor(keyString) == null) {\r\n                return null;\r\n            }\r\n            style.add(toColor(keyString));\r\n        }\r\n    }\r\n    style.add(color);\r\n    String text = (String) json.get(\"text\");\r\n    for (ChatColor c : style) {\r\n        text = c + text;\r\n    }\r\n    return text;\r\n}"
}, {
	"Path": "net.glowstone.inventory.GlowMetaItem.isApplicable",
	"Comment": "check whether this itemmeta can be applied to the given material.",
	"Method": "boolean isApplicable(Material material){\r\n    return material != Material.AIR;\r\n}"
}, {
	"Path": "net.glowstone.entity.objects.GlowPainting.refresh",
	"Comment": "refreshes the painting for nearby clients.this will first destroy, and then spawn the painting again using its current art andfacing value.",
	"Method": "void refresh(){\r\n    DestroyEntitiesMessage destroyMessage = new DestroyEntitiesMessage(Collections.singletonList(this.getEntityId()));\r\n    List<Message> spawnMessages = this.createSpawnMessage();\r\n    Message[] messages = new Message[] { destroyMessage, spawnMessages.get(0) };\r\n    getWorld().getRawPlayers().stream().filter(p -> p.canSeeEntity(this)).forEach(p -> p.getSession().sendAll(messages));\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.file.FileRealm.hasAuthenticatableUser",
	"Comment": "test whether their is a user in the filerealm that has a password that has been set, i.e., something other than the resetkey.",
	"Method": "boolean hasAuthenticatableUser(){\r\n    return helper.hasAuthenticatableUser();\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowEntity.remove",
	"Comment": "destroys this entity by removing it from the world and marking it as not being active.",
	"Method": "void remove(){\r\n    removed = true;\r\n    active = false;\r\n    boundingBox = null;\r\n    world.getEntityManager().unregister(this);\r\n    server.getEntityIdManager().deallocate(this);\r\n    this.setPassenger(null);\r\n    leaveVehicle();\r\n    ImmutableList.copyOf(this.leashedEntities).forEach(e -> unleash(e, UnleashReason.HOLDER_GONE));\r\n    if (isLeashed()) {\r\n        unleash(this, UnleashReason.HOLDER_GONE);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.chunk.ChunkManager.performSave",
	"Comment": "performs the save for the given chunk using the storage provider.",
	"Method": "boolean performSave(GlowChunk chunk){\r\n    if (chunk.isLoaded()) {\r\n        try {\r\n            service.write(chunk);\r\n            return true;\r\n        } catch (IOException ex) {\r\n            ConsoleMessages.Error.Chunk.SAVE_FAILED.log(ex, chunk);\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.AuthorizationServiceImpl.makeAzResource",
	"Comment": "convert a resource, expressed as a uri, into a typed attributes collection.query parameters in the given uri are appended to thisazresource instance attributes collection.",
	"Method": "AzResource makeAzResource(URI resource){\r\n    AzResource azr = new AzResourceImpl(resource);\r\n    return azr;\r\n}"
}, {
	"Path": "net.glowstone.GlowServer.reload",
	"Comment": "reloads the server, refreshing settings and plugin information.",
	"Method": "void reload(){\r\n    try {\r\n        loadConfig();\r\n        opsList.load();\r\n        whitelist.load();\r\n        nameBans.load();\r\n        ipBans.load();\r\n        craftingManager.resetRecipes();\r\n        loadPlugins();\r\n        enablePlugins(PluginLoadOrder.STARTUP);\r\n        enablePlugins(PluginLoadOrder.POSTWORLD);\r\n    } catch (Exception ex) {\r\n        ConsoleMessages.Error.RELOAD.log(ex);\r\n    }\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.Dom.isEmpty",
	"Comment": "returns true if this element is emptymeaning all their attributes have default values and it hasno descendants.",
	"Method": "boolean isEmpty(boolean isEmpty,boolean isEmpty,boolean isEmpty){\r\n    Map<String, String> attributesToWrite = attributesToWrite();\r\n    if (!attributesToWrite.isEmpty()) {\r\n        return false;\r\n    }\r\n    return children.isEmpty();\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.ServiceFactory.getSecurityServiceConfiguration",
	"Comment": "get the security service configuration for the specified service type.\tattempt to obtain the service configuration marked as default\totherwise use the first configured service instance.",
	"Method": "T getSecurityServiceConfiguration(Domain domain,Class<T> type){\r\n    T config = null;\r\n    SecurityConfigurations secConfigs = domain.getExtensionByType(SecurityConfigurations.class);\r\n    if (secConfigs != null) {\r\n        config = secConfigs.getDefaultSecurityServiceByType(type);\r\n        if (config == null) {\r\n            List<T> configs = secConfigs.getSecurityServicesByType(type);\r\n            if (!configs.isEmpty())\r\n                config = configs.get(0);\r\n        }\r\n    }\r\n    return config;\r\n}"
}, {
	"Path": "net.glowstone.GlowServer.getClassicWater",
	"Comment": "whether the server uses the classic water flowing algorithm.",
	"Method": "boolean getClassicWater(){\r\n    return config.getBoolean(Key.WATER_CLASSIC);\r\n}"
}, {
	"Path": "net.glowstone.util.TextMessage.encode",
	"Comment": "encode this chat message to its textual json representation.",
	"Method": "String encode(){\r\n    return object.toJSONString();\r\n}"
}, {
	"Path": "org.glassfish.extras.osgicontainer.OSGiArchiveHandler.requiresAnnotationScanning",
	"Comment": "returns whether this archive requires annotation scanning.",
	"Method": "boolean requiresAnnotationScanning(ReadableArchive archive){\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.ClientPasswordLoginModule.logout",
	"Comment": "logout the user. this method removes the principalimplthat was added by the commit method.",
	"Method": "boolean logout(){\r\n    subject.getPrincipals().remove(userPrincipal);\r\n    succeeded = commitSucceeded;\r\n    username = null;\r\n    if (password != null) {\r\n        for (int i = 0; i < password.length; i++) {\r\n            password[i] = ' ';\r\n        }\r\n        password = null;\r\n    }\r\n    userPrincipal = null;\r\n    return true;\r\n}"
}, {
	"Path": "net.glowstone.io.structure.StructurePieceStore.save",
	"Comment": "save information about this structure piece to the given tag.",
	"Method": "void save(T structurePiece,CompoundTag compound){\r\n    compound.putInt(\"GD\", structurePiece.getUnknownGd());\r\n    compound.putInt(\"O\", structurePiece.getNumericOrientation());\r\n    StructureBoundingBox boundingBox = structurePiece.getBoundingBox();\r\n    int[] bb = new int[6];\r\n    bb[0] = boundingBox.getMin().getBlockX();\r\n    bb[1] = boundingBox.getMin().getBlockY();\r\n    bb[2] = boundingBox.getMin().getBlockZ();\r\n    bb[3] = boundingBox.getMax().getBlockX();\r\n    bb[4] = boundingBox.getMax().getBlockY();\r\n    bb[5] = boundingBox.getMax().getBlockZ();\r\n    compound.putIntArray(\"BB\", bb);\r\n}"
}, {
	"Path": "net.glowstone.io.structure.StructureStorage.createStructure",
	"Comment": "helper method to call structurestore methods for type safety.",
	"Method": "T createStructure(GlowWorld world,int chunkX,int chunkZ,StructureStore<T> store,CompoundTag compound){\r\n    T structure = store.createStructure(world, chunkX, chunkZ);\r\n    store.load(structure, compound);\r\n    return structure;\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.mergeInto",
	"Comment": "merges the contents of this compound into the supplied compound.",
	"Method": "void mergeInto(CompoundTag other,boolean overwrite){\r\n    for (String key : value.keySet()) {\r\n        if (!overwrite && other.containsKey(key)) {\r\n            continue;\r\n        }\r\n        other.put(key, value.get(key));\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowLivingEntity.canTakeDamage",
	"Comment": "get whether this entity should take damage from the specified source.usually used to check environmental sources such as drowning.",
	"Method": "boolean canTakeDamage(DamageCause damageCause){\r\n    return true;\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.AuthenticationServiceImpl.initialize",
	"Comment": "initialize the authentication service configuration.\tcreate the jaas configuration using the specified loginmodule configurations",
	"Method": "void initialize(SecurityConfiguration securityServiceConfiguration){\r\n    config = (org.glassfish.security.services.config.AuthenticationService) securityServiceConfiguration;\r\n    if (config == null)\r\n        return;\r\n    name = config.getName();\r\n    usePasswordCredential = config.getUsePasswordCredential();\r\n    List<SecurityProvider> providers = config.getSecurityProviders();\r\n    if (providers != null) {\r\n        ArrayList<AppConfigurationEntry> lmEntries = new ArrayList<AppConfigurationEntry>();\r\n        for (SecurityProvider provider : providers) {\r\n            if (\"LoginModule\".equalsIgnoreCase(provider.getType())) {\r\n                List<SecurityProviderConfig> providerConfig = provider.getSecurityProviderConfig();\r\n                if ((providerConfig != null) && (!providerConfig.isEmpty())) {\r\n                    LoginModuleConfig lmConfig = (LoginModuleConfig) providerConfig.get(0);\r\n                    Map<String, ?> lmOptions = lmConfig.getModuleOptions();\r\n                    lmEntries.add(new AppConfigurationEntry(lmConfig.getModuleClass(), getLoginModuleControlFlag(lmConfig.getControlFlag()), lmOptions));\r\n                    if (usePasswordCredential && (realmName == null)) {\r\n                        String authRealm = (String) lmOptions.get(\"auth-realm\");\r\n                        if ((authRealm != null) && (!authRealm.isEmpty()))\r\n                            realmName = authRealm;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!lmEntries.isEmpty())\r\n            configuration = new AuthenticationJaasConfiguration(name, lmEntries);\r\n    }\r\n    if (usePasswordCredential && (realmName != null)) {\r\n        RealmsManager realmsManager = locator.getService(RealmsManager.class);\r\n        realmsManager.createRealms();\r\n    }\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.ConfigPopulatorException.getLocation",
	"Comment": "indicates the source position of the configuration filewhere the problem happened.",
	"Method": "Location getLocation(){\r\n    return location;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.common.X509CertificateCredential.equals",
	"Comment": "compare two instances of the credential and return true if they arethe same and false otherwise.",
	"Method": "boolean equals(Object o){\r\n    if (o instanceof X509CertificateCredential) {\r\n        X509CertificateCredential pc = (X509CertificateCredential) o;\r\n        if (pc.getRealm().equals(realm) && pc.getAlias().equals(alias)) {\r\n            X509Certificate[] certs = pc.getX509CertificateChain();\r\n            for (int i = 0; i < certs.length; i++) {\r\n                if (!certs[i].equals(certChain[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.chooseClientAlias",
	"Comment": "choose the client alias that will be used to select the clientcertificate for ssl client auth.",
	"Method": "String chooseClientAlias(String[] keyType,Principal[] issuers,Socket socket){\r\n    String clientAlias = null;\r\n    if (this.alias == null) {\r\n        if (Util.getInstance().isNotServerOrACC()) {\r\n            clientAlias = mgr.chooseClientAlias(keyType, issuers, socket);\r\n        } else {\r\n            if (Util.getInstance().isACC()) {\r\n                ClientSecurityContext ctx = ClientSecurityContext.getCurrent();\r\n                Subject s = ctx.getSubject();\r\n                if (s == null) {\r\n                    doClientLogin(SecurityConstants.CERTIFICATE, Util.getInstance().getCallbackHandler());\r\n                    s = ctx.getSubject();\r\n                }\r\n                Iterator itr = s.getPrivateCredentials().iterator();\r\n                while (itr.hasNext()) {\r\n                    Object o = itr.next();\r\n                    if (o instanceof X509CertificateCredential) {\r\n                        X509CertificateCredential crt = (X509CertificateCredential) o;\r\n                        clientAlias = crt.getAlias();\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        clientAlias = this.alias;\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"Choose client Alias :{0}\", clientAlias);\r\n    }\r\n    return clientAlias;\r\n}"
}, {
	"Path": "net.glowstone.chunk.ChunkSection.loadTypeArray",
	"Comment": "loads the contents of this chunk section from the given type array, initializing thepalette.",
	"Method": "void loadTypeArray(char[] types){\r\n    if (types.length != ARRAY_SIZE) {\r\n        throw new IllegalArgumentException(\"Types array length was not \" + ARRAY_SIZE + \": \" + types.length);\r\n    }\r\n    this.count = 0;\r\n    this.palette = new IntArrayList();\r\n    for (char type : types) {\r\n        if (type != 0) {\r\n            count++;\r\n        }\r\n        if (!palette.contains(type)) {\r\n            palette.add(type);\r\n        }\r\n    }\r\n    int bitsPerBlock = VariableValueArray.calculateNeededBits(palette.size());\r\n    if (bitsPerBlock < 4) {\r\n        bitsPerBlock = 4;\r\n    } else if (bitsPerBlock > 8) {\r\n        palette = null;\r\n        bitsPerBlock = GLOBAL_PALETTE_BITS_PER_BLOCK;\r\n    }\r\n    this.data = new VariableValueArray(bitsPerBlock, ARRAY_SIZE);\r\n    for (int i = 0; i < ARRAY_SIZE; i++) {\r\n        if (palette != null) {\r\n            data.set(i, palette.indexOf(types[i]));\r\n        } else {\r\n            data.set(i, types[i]);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.util.loot.LootingManager.generate",
	"Comment": "returns items and experience that the given entity drops when killed.",
	"Method": "LootData generate(GlowLivingEntity entity){\r\n    if (!entities.containsKey(entity.getType())) {\r\n        return new LootData(InventoryUtil.NO_ITEMS_COLLECTION, 0);\r\n    }\r\n    EntityLootTable table = entities.get(entity.getType());\r\n    Set<ItemStack> items = new HashSet();\r\n    for (LootItem lootItem : table.getItems()) {\r\n        DefaultLootItem defaultItem = lootItem.getDefaultItem();\r\n        int count = defaultItem.getCount().generate(ThreadLocalRandom.current(), entity);\r\n        int data = 0;\r\n        if (defaultItem.getData().isPresent()) {\r\n            data = defaultItem.getData().get().generate(ThreadLocalRandom.current());\r\n        } else if (defaultItem.getReflectiveData().isPresent()) {\r\n            data = ((Number) defaultItem.getReflectiveData().get().process(entity)).intValue();\r\n        }\r\n        String name = defaultItem.getType().generate(ThreadLocalRandom.current());\r\n        if (name == null) {\r\n            name = \"\";\r\n        }\r\n        name = name.toUpperCase();\r\n        ConditionalLootItem[] conditions = lootItem.getConditionalItems();\r\n        for (ConditionalLootItem condition : conditions) {\r\n            if (LootingUtil.conditionValue(entity, condition.getCondition())) {\r\n                if (condition.getCount().isPresent()) {\r\n                    count = condition.getCount().get().generate(ThreadLocalRandom.current(), entity);\r\n                }\r\n                if (condition.getType().isPresent()) {\r\n                    name = condition.getType().get().generate(ThreadLocalRandom.current());\r\n                    if (name == null) {\r\n                        name = \"\";\r\n                    }\r\n                    name = name.toUpperCase();\r\n                }\r\n                if (condition.getData().isPresent()) {\r\n                    data = condition.getData().get().generate(ThreadLocalRandom.current());\r\n                } else if (condition.getReflectiveData().isPresent()) {\r\n                    data = ((Number) condition.getReflectiveData().get().process(entity)).intValue();\r\n                }\r\n            }\r\n        }\r\n        Material material = Material.getMaterial(name);\r\n        if (material != null && count > 0) {\r\n            items.add(new ItemStack(material, count, (byte) data));\r\n        }\r\n    }\r\n    int experience = table.getExperience().generate(ThreadLocalRandom.current(), entity);\r\n    return new LootData(items, experience);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreateAuthRealm.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<SecurityService>() {\r\n            public Object run(SecurityService param) throws PropertyVetoException, TransactionFailure {\r\n                AuthRealm newAuthRealm = param.createChild(AuthRealm.class);\r\n                populateAuthRealmElement(newAuthRealm);\r\n                param.getAuthRealm().add(newAuthRealm);\r\n                SecurityConfigListener.authRealmCreated(config, newAuthRealm);\r\n                return newAuthRealm;\r\n            }\r\n        }, securityService);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(localStrings.getLocalString(\"create.auth.realm.fail\", \"Creation of Authrealm {0} failed\", authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreateAuthRealm.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    AuthRealm newAuthRealm = param.createChild(AuthRealm.class);\r\n    populateAuthRealmElement(newAuthRealm);\r\n    param.getAuthRealm().add(newAuthRealm);\r\n    SecurityConfigListener.authRealmCreated(config, newAuthRealm);\r\n    return newAuthRealm;\r\n}"
}, {
	"Path": "net.glowstone.util.GameRuleManager.getInt",
	"Comment": "gets the game rule value as an integer. if the value cannot be parsed or does not exist thenthe default will be returned.",
	"Method": "int getInt(String key,int getInt,String rule,int def){\r\n    if (isGameRule(rule)) {\r\n        String value = getString(rule);\r\n        try {\r\n            return Integer.parseInt(value);\r\n        } catch (NumberFormatException ignored) {\r\n        }\r\n    }\r\n    return def;\r\n}"
}, {
	"Path": "net.glowstone.command.CommandUtils.getWorld",
	"Comment": "returns the world that the given command sender is referring to when not specifying one.",
	"Method": "GlowWorld getWorld(CommandSender sender){\r\n    if (sender instanceof ConsoleCommandSender) {\r\n        return getDefaultWorld();\r\n    } else if (sender instanceof Entity) {\r\n        return (GlowWorld) ((Entity) sender).getWorld();\r\n    } else if (sender instanceof BlockCommandSender) {\r\n        return (GlowWorld) ((BlockCommandSender) sender).getBlock().getWorld();\r\n    }\r\n    return getDefaultWorld();\r\n}"
}, {
	"Path": "net.glowstone.inventory.WindowClickLogic.getAction",
	"Comment": "determine the inventoryaction to be performed for a window click based on the click type,slot type, and items involved.",
	"Method": "InventoryAction getAction(ClickType clickType,SlotType slot,ItemStack cursor,ItemStack slotItem){\r\n    boolean outside = slot == SlotType.OUTSIDE;\r\n    switch(clickType) {\r\n        case LEFT:\r\n            if (InventoryUtil.isEmpty(cursor)) {\r\n                if (outside || InventoryUtil.isEmpty(slotItem)) {\r\n                    return InventoryAction.NOTHING;\r\n                }\r\n                return InventoryAction.PICKUP_ALL;\r\n            }\r\n            if (outside) {\r\n                return InventoryAction.DROP_ALL_CURSOR;\r\n            }\r\n            if (slot == SlotType.ARMOR) {\r\n                return InventoryAction.PLACE_ONE;\r\n            }\r\n            if (InventoryUtil.isEmpty(slotItem)) {\r\n                return InventoryAction.PLACE_ALL;\r\n            }\r\n            if (slotItem.isSimilar(cursor)) {\r\n                int transfer = Math.min(cursor.getAmount(), slotItem.getType().getMaxStackSize() - slotItem.getAmount());\r\n                if (transfer == 0) {\r\n                    return InventoryAction.NOTHING;\r\n                } else if (transfer == 1) {\r\n                    return InventoryAction.PLACE_ONE;\r\n                } else if (transfer == cursor.getAmount()) {\r\n                    return InventoryAction.PLACE_ALL;\r\n                } else {\r\n                    return InventoryAction.PLACE_SOME;\r\n                }\r\n            }\r\n            return InventoryAction.SWAP_WITH_CURSOR;\r\n        case RIGHT:\r\n            if (InventoryUtil.isEmpty(cursor)) {\r\n                if (outside || InventoryUtil.isEmpty(slotItem)) {\r\n                    return InventoryAction.NOTHING;\r\n                }\r\n                return InventoryAction.PICKUP_HALF;\r\n            }\r\n            if (outside) {\r\n                return InventoryAction.DROP_ONE_CURSOR;\r\n            }\r\n            if (InventoryUtil.isEmpty(slotItem)) {\r\n                return InventoryAction.PLACE_ONE;\r\n            }\r\n            if (cursor.isSimilar(slotItem)) {\r\n                if (slotItem.getAmount() + 1 <= slotItem.getType().getMaxStackSize()) {\r\n                    return InventoryAction.PLACE_ONE;\r\n                }\r\n                return InventoryAction.NOTHING;\r\n            }\r\n            return InventoryAction.SWAP_WITH_CURSOR;\r\n        case SHIFT_LEFT:\r\n        case SHIFT_RIGHT:\r\n            if (InventoryUtil.isEmpty(slotItem)) {\r\n                return InventoryAction.NOTHING;\r\n            }\r\n            return InventoryAction.MOVE_TO_OTHER_INVENTORY;\r\n        case WINDOW_BORDER_LEFT:\r\n        case WINDOW_BORDER_RIGHT:\r\n            return InventoryAction.NOTHING;\r\n        case MIDDLE:\r\n            if (InventoryUtil.isEmpty(slotItem)) {\r\n                return InventoryAction.NOTHING;\r\n            }\r\n            return InventoryAction.CLONE_STACK;\r\n        case NUMBER_KEY:\r\n            return InventoryAction.HOTBAR_SWAP;\r\n        case DOUBLE_CLICK:\r\n            if (InventoryUtil.isEmpty(cursor)) {\r\n                return InventoryAction.NOTHING;\r\n            }\r\n            return InventoryAction.COLLECT_TO_CURSOR;\r\n        case DROP:\r\n            if (InventoryUtil.isEmpty(slotItem)) {\r\n                return InventoryAction.NOTHING;\r\n            }\r\n            return InventoryAction.DROP_ONE_SLOT;\r\n        case CONTROL_DROP:\r\n            if (InventoryUtil.isEmpty(slotItem)) {\r\n                return InventoryAction.NOTHING;\r\n            }\r\n            return InventoryAction.DROP_ALL_SLOT;\r\n        case CREATIVE:\r\n            return InventoryAction.UNKNOWN;\r\n        case UNKNOWN:\r\n        default:\r\n            return InventoryAction.UNKNOWN;\r\n    }\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.ConfigModel.getLeafElementNames",
	"Comment": "returns the list of all the leaf attribute names on this model",
	"Method": "Set<String> getLeafElementNames(){\r\n    final Set<String> results = new HashSet<String>();\r\n    for (Map.Entry<String, Property> prop : elements.entrySet()) {\r\n        if (prop.getValue().isLeaf()) {\r\n            results.add(prop.getKey());\r\n        }\r\n    }\r\n    return Collections.unmodifiableSet(results);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.ldap.LDAPRealm.userSearch",
	"Comment": "do anonymous search for the user. should be unique if exists.",
	"Method": "String userSearch(DirContext ctx,String baseDN,String filter){\r\n    if (_logger.isLoggable(Level.FINEST)) {\r\n        _logger.log(Level.FINE, \"search: baseDN: \" + baseDN + \"  filter: \" + filter);\r\n    }\r\n    String foundDN = null;\r\n    NamingEnumeration namingEnum = null;\r\n    SearchControls ctls = new SearchControls();\r\n    ctls.setReturningAttributes(_dnOnly);\r\n    ctls.setSearchScope(SearchControls.SUBTREE_SCOPE);\r\n    ctls.setCountLimit(1);\r\n    try {\r\n        namingEnum = ctx.search(baseDN, filter, ctls);\r\n        if (namingEnum.hasMore()) {\r\n            SearchResult res = (SearchResult) namingEnum.next();\r\n            StringBuffer sb = new StringBuffer();\r\n            CompositeName compDN = new CompositeName(res.getName());\r\n            String ldapDN = compDN.get(0);\r\n            sb.append(ldapDN);\r\n            if (res.isRelative()) {\r\n                sb.append(\",\");\r\n                sb.append(baseDN);\r\n            }\r\n            foundDN = sb.toString();\r\n            if (_logger.isLoggable(Level.FINEST)) {\r\n                _logger.log(Level.FINE, \"Found user DN: \" + foundDN);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        _logger.log(Level.WARNING, \"ldaprealm.searcherror\", filter);\r\n        _logger.log(Level.WARNING, \"security.exception\", e);\r\n    } finally {\r\n        if (namingEnum != null) {\r\n            try {\r\n                namingEnum.close();\r\n            } catch (Exception ex) {\r\n            }\r\n        }\r\n    }\r\n    return foundDN;\r\n}"
}, {
	"Path": "net.glowstone.io.json.JsonPlayerStatisticIoService.writeStatistics",
	"Comment": "writes the statistics of the player into its statistics file.",
	"Method": "void writeStatistics(GlowPlayer player){\r\n    File file = getPlayerFile(player.getUniqueId());\r\n    StatisticMap map = player.getStatisticMap();\r\n    JSONObject json = new JSONObject(map.getValues());\r\n    try {\r\n        FileWriter writer = new FileWriter(file, false);\r\n        writer.write(json.toJSONString());\r\n        writer.close();\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.putList",
	"Comment": "adds or replaces a list subtag, converting the list entries to tags.",
	"Method": "void putList(String key,TagType type,List<V> value,Function<? super V, ? extends Tag> tagCreator){\r\n    List<Tag> result = new ArrayList(value.size());\r\n    for (V item : value) {\r\n        result.add(tagCreator.apply(item));\r\n    }\r\n    put(key, new ListTag(type, result));\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.solaris.SolarisRealm.init",
	"Comment": "initialize a realm with some properties.this can be usedwhen instantiating realms from their descriptions.thismethod may only be called a single time.",
	"Method": "void init(Properties props){\r\n    super.init(props);\r\n    String jaasCtx = props.getProperty(IASRealm.JAAS_CONTEXT_PARAM);\r\n    if (jaasCtx == null) {\r\n        if (_logger.isLoggable(Level.WARNING)) {\r\n            _logger.warning(\"realmconfig.noctx\");\r\n        }\r\n        String msg = sm.getString(\"solarisrealm.nojaas\");\r\n        throw new BadRealmException(msg);\r\n    }\r\n    this.setProperty(IASRealm.JAAS_CONTEXT_PARAM, jaasCtx);\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"SolarisRealm : \" + IASRealm.JAAS_CONTEXT_PARAM + \"=\" + jaasCtx);\r\n    }\r\n    groupCache = new HashMap();\r\n    emptyVector = new Vector();\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowEntity.teleportToSpawn",
	"Comment": "teleport this entity to the spawn point of the main world. this is used to teleport out ofthe end.",
	"Method": "boolean teleportToSpawn(){\r\n    Location target = server.getWorlds().get(0).getSpawnLocation();\r\n    EntityPortalEvent event = EventFactory.getInstance().callEvent(new EntityPortalEvent(this, location.clone(), target, null));\r\n    if (event.isCancelled()) {\r\n        return false;\r\n    }\r\n    target = event.getTo();\r\n    teleport(target);\r\n    return true;\r\n}"
}, {
	"Path": "net.glowstone.constants.ItemIds.getKeyName",
	"Comment": "get the key segment of the string identifier for a specified material.",
	"Method": "String getKeyName(Material mat){\r\n    String[] segments = getName(mat).split(\":\");\r\n    return segments[segments.length - 1];\r\n}"
}, {
	"Path": "net.glowstone.chunk.ChunkManager.getChunk",
	"Comment": "gets a chunk object representing the specified coordinates, which might not yet be loaded.",
	"Method": "GlowChunk getChunk(int x,int z){\r\n    Key key = GlowChunk.Key.of(x, z);\r\n    if (chunks.containsKey(key)) {\r\n        return chunks.get(key);\r\n    } else {\r\n        GlowChunk chunk = new GlowChunk(world, x, z);\r\n        chunks.put(key, chunk);\r\n        return chunk;\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.constants.ItemIds.sanitize",
	"Comment": "convert an itemstack which may have a type that is unrepresentable as an item to one thatdoes, or to an empty stack if this is not possible.",
	"Method": "ItemStack sanitize(ItemStack stack){\r\n    if (InventoryUtil.isEmpty(stack) || stack.getType() == null) {\r\n        return InventoryUtil.createEmptyStack();\r\n    }\r\n    Material item = getItem(getName(stack.getType()));\r\n    if (item == null) {\r\n        return null;\r\n    }\r\n    if (item != stack.getType()) {\r\n        stack = stack.clone();\r\n        stack.setType(item);\r\n    }\r\n    return stack;\r\n}"
}, {
	"Path": "net.glowstone.util.mojangson.Mojangson.parseDouble",
	"Comment": "parses a double value from a mojangson string as an nbt doubletag.",
	"Method": "DoubleTag parseDouble(String mojangson){\r\n    Character lastChar = mojangson.charAt(mojangson.length() - 1);\r\n    if (lastChar.toString().toLowerCase().charAt(0) == MojangsonToken.DOUBLE_SUFFIX.getSymbol()) {\r\n        mojangson = mojangson.substring(0, mojangson.length() - 1);\r\n    }\r\n    try {\r\n        return new DoubleTag(Double.valueOf(mojangson));\r\n    } catch (NumberFormatException nfe) {\r\n        throw new MojangsonParseException(\"\\'\" + mojangson + \"\\'\", MojangsonParseException.ParseExceptionReason.INVALID_FORMAT_NUM);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.util.IASSecurityException.getMessage",
	"Comment": "returns a description of this exception. if a root cause was includedduring construction, its message is also included.",
	"Method": "String getMessage(){\r\n    StringBuffer sb = new StringBuffer();\r\n    sb.append(super.getMessage());\r\n    Throwable cause = getCause();\r\n    if (!noMsg && cause != null) {\r\n        sb.append(\" [Cause: \");\r\n        sb.append(cause.toString());\r\n        sb.append(\"] \");\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.ListAuditModule.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    report.getTopMessagePart().setChildrenType(\"audit-module\");\r\n    for (AuditModule am : securityService.getAuditModule()) {\r\n        ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n        part.setMessage(am.getName());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.SSLUtils.getMergedTrustStore",
	"Comment": "this api is for temporary purpose.it will be removed once jsr 196is updated.",
	"Method": "KeyStore getMergedTrustStore(){\r\n    return mergedTrustStore;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreateFileUser.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    String fileRealmClassName = fileAuthRealm.getClassname();\r\n    if (fileRealmClassName != null && !fileRealmClassName.equals(\"com.sun.enterprise.security.auth.realm.file.FileRealm\")) {\r\n        report.setMessage(localStrings.getLocalString(\"create.file.user.realmnotsupported\", \"Configured file realm {0} is not supported.\", fileRealmClassName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    String keyFile = null;\r\n    for (Property fileProp : fileAuthRealm.getProperty()) {\r\n        if (fileProp.getName().equals(\"file\"))\r\n            keyFile = fileProp.getValue();\r\n    }\r\n    final String kf = keyFile;\r\n    if (keyFile == null) {\r\n        report.setMessage(localStrings.getLocalString(\"create.file.user.keyfilenotfound\", \"There is no physical file associated with this file realm {0} \", authRealmName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    boolean exists = (new File(kf)).exists();\r\n    if (!exists) {\r\n        report.setMessage(localStrings.getLocalString(\"file.realm.keyfilenonexistent\", \"The specified physical file {0} associated with the file realm {1} does not exist.\", new Object[] { kf, authRealmName }));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    final String password = userpassword;\r\n    if (password == null) {\r\n        report.setMessage(localStrings.getLocalString(\"create.file.user.keyfilenotreadable\", \"Password for user {0} \" + \"has to be specified in --userpassword option or supplied \" + \"through AS_ADMIN_USERPASSWORD property in the file specified \" + \"in --passwordfile option\", userName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    secureAdmin = domain.getSecureAdmin();\r\n    if ((SecureAdmin.Util.isEnabled(secureAdmin)) && (authRealmName.equals(adminService.getAuthRealmName()))) {\r\n        if (password.isEmpty()) {\r\n            report.setMessage(localStrings.getLocalString(\"null_empty_password\", \"The admin user password is null or empty\"));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<SecurityService>() {\r\n            public Object run(SecurityService param) throws PropertyVetoException, TransactionFailure {\r\n                try {\r\n                    realmsManager.createRealms(config);\r\n                    refreshRealm(config.getName(), authRealmName);\r\n                    final FileRealm fr = (FileRealm) realmsManager.getFromLoadedRealms(config.getName(), authRealmName);\r\n                    CreateFileUser.handleAdminGroup(authRealmName, groups);\r\n                    String[] groups1 = groups.toArray(new String[groups.size()]);\r\n                    try {\r\n                        fr.addUser(userName, password.toCharArray(), groups1);\r\n                    } catch (BadRealmException br) {\r\n                        if (se != null && se.isDas()) {\r\n                            throw new BadRealmException(br);\r\n                        }\r\n                    }\r\n                    fr.persist();\r\n                    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n                } catch (Exception e) {\r\n                    String localalizedErrorMsg = (e.getLocalizedMessage() == null) ? \"\" : e.getLocalizedMessage();\r\n                    report.setMessage(localStrings.getLocalString(\"create.file.user.useraddfailed\", \"Adding User {0} to the file realm {1} failed\", userName, authRealmName) + \"  \" + localalizedErrorMsg);\r\n                    report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                    report.setFailureCause(e);\r\n                }\r\n                return null;\r\n            }\r\n        }, securityService);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"create.file.user.useraddfailed\", \"Adding User {0} to the file realm {1} failed\", userName, authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreateFileUser.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    try {\r\n        realmsManager.createRealms(config);\r\n        refreshRealm(config.getName(), authRealmName);\r\n        final FileRealm fr = (FileRealm) realmsManager.getFromLoadedRealms(config.getName(), authRealmName);\r\n        CreateFileUser.handleAdminGroup(authRealmName, groups);\r\n        String[] groups1 = groups.toArray(new String[groups.size()]);\r\n        try {\r\n            fr.addUser(userName, password.toCharArray(), groups1);\r\n        } catch (BadRealmException br) {\r\n            if (se != null && se.isDas()) {\r\n                throw new BadRealmException(br);\r\n            }\r\n        }\r\n        fr.persist();\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (Exception e) {\r\n        String localalizedErrorMsg = (e.getLocalizedMessage() == null) ? \"\" : e.getLocalizedMessage();\r\n        report.setMessage(localStrings.getLocalString(\"create.file.user.useraddfailed\", \"Adding User {0} to the file realm {1} failed\", userName, authRealmName) + \"  \" + localalizedErrorMsg);\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.glowstone.GlowServer.setIp",
	"Comment": "sets the ip address that the query server will expose.this does not change the ip address the server will run on.",
	"Method": "void setIp(String ip){\r\n    this.ip = ip;\r\n}"
}, {
	"Path": "org.glassfish.osgi.cli.remote.RemoteCommandSession.attach",
	"Comment": "attached the specified streams to the delegate of this instance andreturns the modified delegate.",
	"Method": "CommandSession attach(InputStream in,PrintStream out,PrintStream err){\r\n    set(this.delegate, \"in\", in);\r\n    set(this.delegate, \"out\", out);\r\n    set(this.delegate, \"err\", err);\r\n    ReadableByteChannel inCh = Channels.newChannel(in);\r\n    WritableByteChannel outCh = Channels.newChannel(out);\r\n    WritableByteChannel errCh = out == err ? outCh : Channels.newChannel(err);\r\n    set(this.delegate, \"channels\", new Channel[] { inCh, outCh, errCh });\r\n    return this.delegate;\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.readUuid",
	"Comment": "applies the given function to a uuid extracted from the given pair of long subtags, if theyboth exist.",
	"Method": "boolean readUuid(String keyMost,String keyLeast,Consumer<? super UUID> consumer){\r\n    if (isLong(keyMost) && isLong(keyLeast)) {\r\n        consumer.accept(new UUID(getLong(keyMost), getLong(keyLeast)));\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.glowstone.generator.objects.trees.GenericTree.replaceIfAirOrLeaves",
	"Comment": "replaces the block at a location with the given new one, if it is air or leaves.",
	"Method": "void replaceIfAirOrLeaves(int x,int y,int z,Material newMaterial,int data,World world){\r\n    Material oldMaterial = blockTypeAt(x, y, z, world);\r\n    if (oldMaterial == Material.AIR || oldMaterial == Material.LEAVES) {\r\n        delegate.setTypeAndRawData(world, x, y, z, newMaterial, data);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.admin.cli.SecureAdminHelperImpl.validateInternalUsernameAndPasswordAlias",
	"Comment": "makes sure the username is a valid admin username and that the passwordalias is defined.this method does not make sure that the passwordassociated with the username and the password associated with the password alias are the same.",
	"Method": "void validateInternalUsernameAndPasswordAlias(String username,String passwordAlias){\r\n    try {\r\n        validateUser(username);\r\n        validatePasswordAlias(passwordAlias);\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(Strings.get(\"errVal\"), ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.Realm._getInstance",
	"Comment": "this is a private method for getting realm instance.if realm does not exist, then it will not return null rather thanthrow exception.",
	"Method": "Realm _getInstance(String name,Realm _getInstance,String configName,String name){\r\n    RealmsManager mgr = getRealmsManager();\r\n    if (mgr != null) {\r\n        return mgr._getInstance(configName, name);\r\n    } else {\r\n        throw new RuntimeException(\"Unable to locate RealmsManager Service\");\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.entity.passive.GlowFishingHook.reelIn",
	"Comment": "removes this fishing hook. drops loot and xp if a player is fishing.",
	"Method": "void reelIn(){\r\n    if (location.getBlock().getType() == Material.WATER) {\r\n        ProjectileSource shooter = getShooter();\r\n        if (shooter instanceof Player) {\r\n            PlayerFishEvent fishEvent = new PlayerFishEvent((Player) shooter, this, null, CAUGHT_FISH);\r\n            fishEvent.setExpToDrop(ThreadLocalRandom.current().nextInt(1, 7));\r\n            fishEvent = EventFactory.getInstance().callEvent(fishEvent);\r\n            if (!fishEvent.isCancelled()) {\r\n                world.dropItemNaturally(((Player) getShooter()).getLocation(), getRewardItem());\r\n                ((Player) getShooter()).giveExp(fishEvent.getExpToDrop());\r\n            }\r\n        }\r\n    }\r\n    remove();\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowEntity.reset",
	"Comment": "resets the previous location and other properties to their current value.",
	"Method": "void reset(){\r\n    Position.copyLocation(location, previousLocation);\r\n    metadata.resetChanges();\r\n    teleported = false;\r\n    velocityChanged = false;\r\n    leashHolderChanged = false;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.ldap.LDAPRealm.init",
	"Comment": "initialize a realm with some properties.this can be usedwhen instantiating realms from their descriptions.thismethod may only be called a single time.",
	"Method": "void init(Properties props){\r\n    super.init(props);\r\n    String url = props.getProperty(PARAM_DIRURL);\r\n    String dn = props.getProperty(PARAM_USERDN);\r\n    String jaasCtx = props.getProperty(IASRealm.JAAS_CONTEXT_PARAM);\r\n    if (url == null || dn == null || jaasCtx == null) {\r\n        String msg = sm.getString(\"ldaprealm.badconfig\", url, dn, jaasCtx);\r\n        throw new BadRealmException(msg);\r\n    }\r\n    this.setProperty(PARAM_DIRURL, url);\r\n    ldapBindProps.setProperty(Context.PROVIDER_URL, url);\r\n    this.setProperty(PARAM_USERDN, dn);\r\n    this.setProperty(IASRealm.JAAS_CONTEXT_PARAM, jaasCtx);\r\n    String mode = props.getProperty(PARAM_MODE, MODE_DEFAULT);\r\n    if (!MODE_DEFAULT.equals(mode)) {\r\n        String msg = sm.getString(\"ldaprealm.badmode\", mode);\r\n        throw new BadRealmException(msg);\r\n    }\r\n    this.setProperty(PARAM_MODE, mode);\r\n    String ctxF = props.getProperty(PARAM_JNDICF, JNDICF_DEFAULT);\r\n    this.setProperty(PARAM_JNDICF, ctxF);\r\n    ldapBindProps.setProperty(Context.INITIAL_CONTEXT_FACTORY, ctxF);\r\n    String searchFilter = props.getProperty(PARAM_SEARCH_FILTER, SEARCH_FILTER_DEFAULT);\r\n    this.setProperty(PARAM_SEARCH_FILTER, searchFilter);\r\n    String grpDN = props.getProperty(PARAM_GRPDN, dn);\r\n    this.setProperty(PARAM_GRPDN, grpDN);\r\n    String grpSearchFilter = props.getProperty(PARAM_GRP_SEARCH_FILTER, GRP_SEARCH_FILTER_DEFAULT);\r\n    this.setProperty(PARAM_GRP_SEARCH_FILTER, grpSearchFilter);\r\n    String dynGrpSearchFilter = props.getProperty(PARAM_DYNAMIC_GRP_FILTER, SEARCH_FILTER_DEFAULT);\r\n    this.setProperty(PARAM_DYNAMIC_GRP_FILTER, dynGrpSearchFilter);\r\n    String grpTarget = props.getProperty(PARAM_GRP_TARGET, GRP_TARGET_DEFAULT);\r\n    this.setProperty(PARAM_GRP_TARGET, grpTarget);\r\n    String dynGrpTarget = props.getProperty(PARAM_DYNAMIC_GRP_TARGET, DYNAMIC_GRP_TARGET_DEFAULT);\r\n    this.setProperty(PARAM_DYNAMIC_GRP_TARGET, dynGrpTarget);\r\n    String objectFactory = props.getProperty(DYNAMIC_GROUP_FACTORY_OBJECT_PROPERTY, DYNAMIC_GROUP_OBJECT_FACTORY);\r\n    this.setProperty(DYNAMIC_GROUP_FACTORY_OBJECT_PROPERTY, objectFactory);\r\n    ldapBindProps.setProperty(DYNAMIC_GROUP_FACTORY_OBJECT_PROPERTY, objectFactory);\r\n    String stateFactory = props.getProperty(DYNAMIC_GROUP_STATE_FACTORY_PROPERTY, DYNAMIC_GROUP_STATE_FACTORY);\r\n    this.setProperty(DYNAMIC_GROUP_STATE_FACTORY_PROPERTY, stateFactory);\r\n    ldapBindProps.setProperty(DYNAMIC_GROUP_STATE_FACTORY_PROPERTY, stateFactory);\r\n    String bindDN = props.getProperty(PARAM_BINDDN);\r\n    if (bindDN != null) {\r\n        this.setProperty(PARAM_BINDDN, bindDN);\r\n        ldapBindProps.setProperty(Context.SECURITY_PRINCIPAL, bindDN);\r\n    }\r\n    String bindPWD = props.getProperty(PARAM_BINDPWD);\r\n    if (bindPWD != null) {\r\n        try {\r\n            bindPWD = RelativePathResolver.getRealPasswordFromAlias(bindPWD);\r\n        } catch (Exception ex) {\r\n            _logger.log(Level.WARNING, \"ldaprealm.pwd.dealiasing.failed\", ex);\r\n        }\r\n        this.setProperty(PARAM_BINDPWD, bindPWD);\r\n        ldapBindProps.setProperty(Context.SECURITY_CREDENTIALS, bindPWD);\r\n    }\r\n    Enumeration penum = props.propertyNames();\r\n    while (penum.hasMoreElements()) {\r\n        String propName = (String) penum.nextElement();\r\n        if (propName.startsWith(\"java.naming.\") || propName.startsWith(\"javax.security.\") || propName.startsWith(\"com.sun.jndi.ldap.\")) {\r\n            ldapBindProps.setProperty(propName, props.getProperty(propName));\r\n        } else if (propName.startsWith(SUN_JNDI_POOL_) && !SUN_JNDI_POOL_MAXSIZE.equals(propName)) {\r\n            if (System.getProperty(propName) == null) {\r\n                System.setProperty(propName, props.getProperty(propName));\r\n            }\r\n        }\r\n    }\r\n    String poolSize = Integer.getInteger(PARAM_POOLSIZE, POOLSIZE_DEFAULT).toString();\r\n    String sunPoolSizeStr = props.getProperty(SUN_JNDI_POOL_MAXSIZE, poolSize);\r\n    try {\r\n        sunPoolSizeStr = Integer.valueOf(sunPoolSizeStr).toString();\r\n    } catch (Exception ex) {\r\n        sunPoolSizeStr = poolSize;\r\n    }\r\n    if (System.getProperty(SUN_JNDI_POOL_MAXSIZE) == null) {\r\n        System.setProperty(SUN_JNDI_POOL_MAXSIZE, sunPoolSizeStr);\r\n    }\r\n    this.setProperty(PARAM_POOLSIZE, sunPoolSizeStr);\r\n    String usePool = props.getProperty(SUN_JNDI_POOL, \"true\");\r\n    ldapBindProps.setProperty(SUN_JNDI_POOL, usePool);\r\n    if (url.startsWith(LDAPS_URL)) {\r\n        ldapBindProps.setProperty(LDAP_SOCKET_FACTORY, DEFAULT_SSL_LDAP_SOCKET_FACTORY);\r\n        if (System.getProperty(SUN_JNDI_POOL_PROTOCOL) == null) {\r\n            System.setProperty(SUN_JNDI_POOL_PROTOCOL, DEFAULT_POOL_PROTOCOL);\r\n        }\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"LDAPRealm : Using custom socket factory for SSL with pooling\");\r\n        }\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        Properties tempProps = (Properties) ldapBindProps.clone();\r\n        tempProps.remove(Context.SECURITY_CREDENTIALS);\r\n        _logger.log(Level.FINE, \"LDAPRealm : \" + tempProps);\r\n    }\r\n    groupCache = new HashMap();\r\n    emptyVector = new Vector();\r\n}"
}, {
	"Path": "net.glowstone.util.mojangson.Mojangson.parseCompound",
	"Comment": "parses a compound from a mojangson string as an nbt compoundtag.",
	"Method": "CompoundTag parseCompound(String mojangson){\r\n    final int parseCompoundStart = 0;\r\n    final int parseCompoundPairKey = 1;\r\n    final int parseCompoundPairValue = 2;\r\n    int context = parseCompoundStart;\r\n    String tmpkey = \"\";\r\n    String tmpval = \"\";\r\n    // The scope level of the compound, this allows coherent nested arrays and\r\n    int scope = 0;\r\n    boolean inString = false;\r\n    CompoundTag tag = new CompoundTag();\r\n    for (int index = 0; index < mojangson.length(); index++) {\r\n        Character character = mojangson.charAt(index);\r\n        if (character == STRING_QUOTES.getSymbol()) {\r\n            inString = !inString;\r\n        }\r\n        if (character == WHITE_SPACE.getSymbol()) {\r\n            if (!inString) {\r\n                continue;\r\n            }\r\n        }\r\n        if ((character == COMPOUND_START.getSymbol() || character == ARRAY_START.getSymbol()) && !inString) {\r\n            scope++;\r\n        }\r\n        if ((character == COMPOUND_END.getSymbol() || character == ARRAY_END.getSymbol()) && !inString) {\r\n            scope--;\r\n        }\r\n        if (context == parseCompoundStart) {\r\n            if (character != COMPOUND_START.getSymbol()) {\r\n                throw new MojangsonParseException(\"Index: \" + index + \", symbol: \\'\" + character + \"\\'\", MojangsonParseException.ParseExceptionReason.UNEXPECTED_SYMBOL);\r\n            }\r\n            context++;\r\n            continue;\r\n        }\r\n        if (context == parseCompoundPairKey) {\r\n            if (character == ELEMENT_PAIR_SEPERATOR.getSymbol() && scope <= 1) {\r\n                context++;\r\n                continue;\r\n            }\r\n            tmpkey += character;\r\n            continue;\r\n        }\r\n        if (context == parseCompoundPairValue) {\r\n            if ((character == ELEMENT_SEPERATOR.getSymbol() || character == COMPOUND_END.getSymbol()) && scope <= 1 && !inString) {\r\n                context = parseCompoundPairKey;\r\n                tag.getValue().put(tmpkey, parseTag(tmpval));\r\n                tmpkey = tmpval = \"\";\r\n                continue;\r\n            }\r\n            tmpval += character;\r\n        }\r\n    }\r\n    return tag;\r\n}"
}, {
	"Path": "net.glowstone.block.blocktype.BlockBed.setOccupied",
	"Comment": "helper method for set whether the specified bed blocks are occupied.",
	"Method": "void setOccupied(GlowBlock head,GlowBlock foot,boolean occupied){\r\n    byte headData = head.getData();\r\n    byte footData = foot.getData();\r\n    head.setData((byte) (occupied ? headData | 0x4 : headData & ~0x4));\r\n    foot.setData((byte) (occupied ? footData | 0x4 : footData & ~0x4));\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowEntity.getGravityAccel",
	"Comment": "returns the change in velocity per physics tick due to gravity.",
	"Method": "Vector getGravityAccel(){\r\n    if (this.gravity) {\r\n        return this.gravityAccel;\r\n    } else {\r\n        return GlowEntity.zeroG;\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.entity.objects.GlowLeashHitch.isAllowedLeashHolder",
	"Comment": "checks if an entity of the specified type is allowed to be a leash holder.",
	"Method": "boolean isAllowedLeashHolder(EntityType type){\r\n    return !(EntityType.ENDER_DRAGON.equals(type) || EntityType.WITHER.equals(type) || EntityType.PLAYER.equals(type) || EntityType.BAT.equals(type));\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowAnimal.getBreedingFoods",
	"Comment": "returns an immutable set containing the breeding foods for the current animal.",
	"Method": "Set<Material> getBreedingFoods(){\r\n    return DEFAULT_BREEDING_FOODS;\r\n}"
}, {
	"Path": "net.glowstone.inventory.GlowEntityEquipment.getItem",
	"Comment": "returns the itemstack found in the slot at the given equipmentslot.",
	"Method": "ItemStack getItem(EquipmentSlot slot){\r\n    Entry slotEntry = getSlotEntry(slot);\r\n    ItemStack stack = slotEntry != null ? slotEntry.item : null;\r\n    return InventoryUtil.itemOrEmpty(stack);\r\n}"
}, {
	"Path": "net.glowstone.block.blocktype.BlockType.canTickRandomly",
	"Comment": "called to check if this block can perform random tick updates.",
	"Method": "boolean canTickRandomly(){\r\n    return false;\r\n}"
}, {
	"Path": "net.glowstone.block.entity.ChestEntity.removeViewer",
	"Comment": "decrements the count of viewing players, and plays the chest closing sound if nobody else isholding the chest open.",
	"Method": "void removeViewer(){\r\n    viewers--;\r\n    if (viewers == 0) {\r\n        updateInRange();\r\n        SoundUtil.playSoundPitchRange(block.getLocation(), Sound.BLOCK_CHEST_CLOSE, 0.5F, 0.9F, 0.1F);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowEntity.teleportToEnd",
	"Comment": "teleport this entity to the end. if no end world is loaded this does nothing.",
	"Method": "boolean teleportToEnd(){\r\n    if (!server.getAllowEnd()) {\r\n        return false;\r\n    }\r\n    Location target = null;\r\n    for (World world : server.getWorlds()) {\r\n        if (world.getEnvironment() == Environment.THE_END) {\r\n            target = world.getSpawnLocation();\r\n            break;\r\n        }\r\n    }\r\n    if (target == null) {\r\n        return false;\r\n    }\r\n    EntityPortalEvent event = EventFactory.getInstance().callEvent(new EntityPortalEvent(this, location.clone(), target, null));\r\n    if (event.isCancelled()) {\r\n        return false;\r\n    }\r\n    target = event.getTo();\r\n    teleport(target);\r\n    return true;\r\n}"
}, {
	"Path": "net.glowstone.entity.meta.profile.ProfileCache.getUuidCached",
	"Comment": "look up the uuid for a given username, but only in the cache and not on the mojang server.",
	"Method": "UUID getUuidCached(String playerName){\r\n    return uuidCache.get(playerName);\r\n}"
}, {
	"Path": "net.glowstone.inventory.WindowClickLogic.isPlaceAction",
	"Comment": "check if a given inventoryaction involves placing items into the slot.",
	"Method": "boolean isPlaceAction(InventoryAction action){\r\n    switch(action) {\r\n        case SWAP_WITH_CURSOR:\r\n        case PLACE_ONE:\r\n        case PLACE_ALL:\r\n        case PLACE_SOME:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.constants.GlowEnchantment.getWeight",
	"Comment": "the rarity of the enchantment, kept for compatibility with bukkit.",
	"Method": "int getWeight(){\r\n    return getRarity().getWeight();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.setClientSecurityContext",
	"Comment": "sets the security context on the appclient side.it sets the relevant information into the tls",
	"Method": "void setClientSecurityContext(String username,Subject subject){\r\n    ClientSecurityContext securityContext = new ClientSecurityContext(username, subject);\r\n    ClientSecurityContext.setCurrent(securityContext);\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.matches",
	"Comment": "checks to see if this tag is a strict, deep submap of the given compoundtag.",
	"Method": "boolean matches(CompoundTag other){\r\n    for (Entry<String, Tag> entry : value.entrySet()) {\r\n        if (!other.value.containsKey(entry.getKey())) {\r\n            return false;\r\n        }\r\n        Tag value = entry.getValue();\r\n        Tag otherValue = other.value.get(entry.getKey());\r\n        if ((value == null && otherValue != null) || (value != null && otherValue == null)) {\r\n            return false;\r\n        }\r\n        if (value != null) {\r\n            if (value.getClass() != otherValue.getClass()) {\r\n                return false;\r\n            }\r\n            if (value instanceof CompoundTag) {\r\n                if (!((CompoundTag) value).matches((CompoundTag) otherValue)) {\r\n                    return false;\r\n                }\r\n            } else if (value instanceof IntArrayTag) {\r\n                if (!Arrays.equals(((IntArrayTag) value).getValue(), ((IntArrayTag) otherValue).getValue())) {\r\n                    return false;\r\n                }\r\n            } else if (value instanceof ByteArrayTag) {\r\n                if (!Arrays.equals(((ByteArrayTag) value).getValue(), ((ByteArrayTag) otherValue).getValue())) {\r\n                    return false;\r\n                }\r\n            } else if (!value.equals(otherValue)) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.file.FileRealm.init",
	"Comment": "initialize a realm with some properties.this can be usedwhen instantiating realms from their descriptions.thismethod is invoked from realm during initialization.",
	"Method": "void init(Properties props){\r\n    super.init(props);\r\n    String file = props.getProperty(PARAM_KEYFILE);\r\n    if (file == null) {\r\n        String msg = sm.getString(\"filerealm.nofile\");\r\n        throw new BadRealmException(msg);\r\n    }\r\n    if (file.contains(\"$\")) {\r\n        file = RelativePathResolver.resolvePath(file);\r\n    }\r\n    this.setProperty(PARAM_KEYFILE, file);\r\n    String jaasCtx = props.getProperty(IASRealm.JAAS_CONTEXT_PARAM);\r\n    if (jaasCtx == null) {\r\n        String msg = sm.getString(\"filerealm.nomodule\");\r\n        throw new BadRealmException(msg);\r\n    }\r\n    this.setProperty(IASRealm.JAAS_CONTEXT_PARAM, jaasCtx);\r\n    _logger.log(Level.FINE, \"FileRealm : \" + PARAM_KEYFILE + \"={0}\", file);\r\n    _logger.log(Level.FINE, \"FileRealm : \" + IASRealm.JAAS_CONTEXT_PARAM + \"={0}\", jaasCtx);\r\n    try {\r\n        if (Util.isEmbeddedServer()) {\r\n            String embeddedFilePath = Util.writeConfigFileToTempDir(file).getAbsolutePath();\r\n            file = embeddedFilePath;\r\n        }\r\n        helper = new FileRealmHelper(file);\r\n    } catch (IOException ioe) {\r\n        String msg = sm.getString(\"filerealm.noaccess\", ioe.toString());\r\n        throw new BadRealmException(msg);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.block.blocktype.BlockDispenser.getDispensePosition",
	"Comment": "returns the position where an item will emerge from the dispenser.",
	"Method": "Vector getDispensePosition(GlowBlock block){\r\n    BlockFace facing = getFacing(block);\r\n    double x = block.getX() + 0.7 * facing.getModX();\r\n    double y = block.getY() + 0.7 * facing.getModY();\r\n    double z = block.getZ() + 0.7 * facing.getModZ();\r\n    return new Vector(x, y, z);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.certificate.CertificateRealm.init",
	"Comment": "initialize a realm with some properties.this can be usedwhen instantiating realms from their descriptions.thismethod is invoked from realm during initialization.",
	"Method": "void init(Properties props){\r\n    super.init(props);\r\n    String[] groups = addAssignGroups(null);\r\n    if (groups != null && groups.length > 0) {\r\n        for (String gp : groups) {\r\n            defaultGroups.add(gp);\r\n        }\r\n    }\r\n    String jaasCtx = props.getProperty(IASRealm.JAAS_CONTEXT_PARAM);\r\n    if (jaasCtx != null) {\r\n        this.setProperty(IASRealm.JAAS_CONTEXT_PARAM, jaasCtx);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ssl.J2EEKeyManager.getServerAliases",
	"Comment": "return all the available server aliases for the specified key type.",
	"Method": "String[] getServerAliases(String keyType,Principal[] issuers){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"Getting server aliases\");\r\n    }\r\n    return mgr.getServerAliases(keyType, issuers);\r\n}"
}, {
	"Path": "net.glowstone.block.blocktype.BlockType.getMinedDrops",
	"Comment": "get the items that would be dropped if the block was successfully mined. this is used f.e. tocalculate tnt drops.",
	"Method": "Collection<ItemStack> getMinedDrops(GlowBlock block){\r\n    return getDrops(block, null);\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.ConfigurationException.getLocation",
	"Comment": "indicates the source position of the configuration filewhere the problem happened.",
	"Method": "Location getLocation(){\r\n    return location;\r\n}"
}, {
	"Path": "org.glassfish.tests.utils.NucleusTestUtils.matchString",
	"Comment": "returns true if string b contains string a.returns true if both strings are null.returns false if only one of the strings is null.",
	"Method": "boolean matchString(String a,String b){\r\n    if ((a == null) && (b == null))\r\n        return true;\r\n    if (a == null)\r\n        return false;\r\n    if (b == null)\r\n        return false;\r\n    return b.indexOf(a) != -1;\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowPlayer.getUserListEntry",
	"Comment": "get a userlistitemmessage entry representing adding this player.",
	"Method": "Entry getUserListEntry(){\r\n    TextMessage displayName = null;\r\n    if (playerListName != null && !playerListName.isEmpty()) {\r\n        displayName = new TextMessage(playerListName);\r\n    }\r\n    return UserListItemMessage.add(getProfile(), getGameMode().getValue(), 0, displayName);\r\n}"
}, {
	"Path": "net.glowstone.entity.EntityManager.getEntitiesInside",
	"Comment": "returns all entities that are inside or partly inside the given bounding box, with optionallyone exception.",
	"Method": "List<Entity> getEntitiesInside(BoundingBox searchBox,GlowEntity except){\r\n    return entities.values().stream().filter(entity -> entity != except && entity.intersects(searchBox)).collect(Collectors.toCollection(LinkedList::new));\r\n}"
}, {
	"Path": "net.glowstone.util.InventoryUtil.itemOrEmpty",
	"Comment": "converts the itemstack to an empty itemstack if the given itemstack is null.",
	"Method": "ItemStack itemOrEmpty(ItemStack stack){\r\n    return stack == null ? createEmptyStack() : stack;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.AuthenticationStatusImpl.getPrincipalName",
	"Comment": "this method returns the string representation of the principalthat was authenticated.",
	"Method": "String getPrincipalName(){\r\n    return principalName;\r\n}"
}, {
	"Path": "net.glowstone.chunk.ChunkManager.forcePopulation",
	"Comment": "force a chunk to be populated by loading the chunks in an area around it. used when streamingchunks to players so that they do not have to watch chunks being populated.",
	"Method": "void forcePopulation(int x,int z){\r\n    try {\r\n        populateChunk(x, z, true);\r\n    } catch (Throwable ex) {\r\n        ConsoleMessages.Error.Chunk.POP_FAILED.log(ex, x, z);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.block.blocktype.BlockBed.isValidSpawn",
	"Comment": "returns whether a player can spawn within a block of specified material.",
	"Method": "boolean isValidSpawn(Material material){\r\n    switch(material) {\r\n        case AIR:\r\n        case SAPLING:\r\n        case POWERED_RAIL:\r\n        case DETECTOR_RAIL:\r\n        case LONG_GRASS:\r\n        case DEAD_BUSH:\r\n        case YELLOW_FLOWER:\r\n        case RED_ROSE:\r\n        case BROWN_MUSHROOM:\r\n        case RED_MUSHROOM:\r\n        case TORCH:\r\n        case REDSTONE_WIRE:\r\n        case CROPS:\r\n        case RAILS:\r\n        case LEVER:\r\n        case REDSTONE_TORCH_OFF:\r\n        case REDSTONE_TORCH_ON:\r\n        case STONE_BUTTON:\r\n        case SNOW:\r\n        case SUGAR_CANE_BLOCK:\r\n        case DIODE_BLOCK_OFF:\r\n        case DIODE_BLOCK_ON:\r\n        case VINE:\r\n        case TRIPWIRE_HOOK:\r\n        case TRIPWIRE:\r\n        case FLOWER_POT:\r\n        case WOOD_BUTTON:\r\n        case SKULL:\r\n        case GOLD_PLATE:\r\n        case IRON_PLATE:\r\n        case REDSTONE_COMPARATOR_OFF:\r\n        case REDSTONE_COMPARATOR_ON:\r\n        case ACTIVATOR_RAIL:\r\n        case CARPET:\r\n        case DOUBLE_PLANT:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.io.nbt.NbtSerialization.listToVector",
	"Comment": "create a vector from a list of doubles.if the list is invalid, a zero vector is returned.",
	"Method": "Vector listToVector(List<Double> list){\r\n    if (list.size() == 3) {\r\n        return new Vector(list.get(0), list.get(1), list.get(2));\r\n    }\r\n    return new Vector(0, 0, 0);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.ListPasswordAlias.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        final Iterator<String> it = domainPasswordAliasStore.keys();\r\n        if (!it.hasNext()) {\r\n            report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n            report.setMessage(localStrings.getLocalString(\"list.password.alias.nothingtolist\", \"Nothing to list\"));\r\n        }\r\n        while (it.hasNext()) {\r\n            ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n            part.setMessage(it.next());\r\n        }\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n        report.setMessage(localStrings.getLocalString(\"list.password.alias.fail\", \"Listing of Password Alias failed\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(ex);\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.osgi.cli.remote.RemoteCommandSession.detach",
	"Comment": "detaches all previously attached streams and hence, ensures that thereare no stale references left.",
	"Method": "void detach(){\r\n    set(this.delegate, \"in\", null);\r\n    set(this.delegate, \"out\", null);\r\n    set(this.delegate, \"err\", null);\r\n}"
}, {
	"Path": "net.glowstone.chunk.GlowChunk.automaticHeightMap",
	"Comment": "automatically fill the height map after chunks have been initialized.",
	"Method": "void automaticHeightMap(){\r\n    int sy = sections.length - 1;\r\n    for (; sy >= 0; --sy) {\r\n        if (sections[sy] != null) {\r\n            break;\r\n        }\r\n    }\r\n    int y = (sy + 1) << 4;\r\n    for (int x = 0; x < WIDTH; ++x) {\r\n        for (int z = 0; z < HEIGHT; ++z) {\r\n            heightMap[z * WIDTH + x] = (byte) lowerHeightMap(x, y, z);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.ListFileGroup.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        FileRealm fr = getFileRealm(securityService, fileAuthRealm, report);\r\n        if (fr == null) {\r\n            return;\r\n        }\r\n        Enumeration groups = null;\r\n        if (fileUserName != null) {\r\n            fr.getUser(fileUserName);\r\n            groups = fr.getGroupNames(fileUserName);\r\n        } else {\r\n            groups = fr.getGroupNames();\r\n        }\r\n        report.getTopMessagePart().setMessage(localStrings.getLocalString(\"list.file.group.success\", \"list-file-groups successful\"));\r\n        report.getTopMessagePart().setChildrenType(\"file-group\");\r\n        while (groups.hasMoreElements()) {\r\n            final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n            part.setMessage((String) groups.nextElement());\r\n        }\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (BadRealmException e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.file.group.realmcorrupted\", \"Configured file realm {0} is corrupted.\", authRealmName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    } catch (NoSuchUserException e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.file.group.usernotfound\", \"Specified file user {0} not found.\", fileUserName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.extras.osgicontainer.OSGiArchiveHandler.expandJar",
	"Comment": "populates a writable archive by reading the input jarinputstream.it closes both the input and output at the end.",
	"Method": "void expandJar(JarInputStream jis,WritableArchive target){\r\n    try {\r\n        JarEntry je;\r\n        while ((je = jis.getNextJarEntry()) != null) {\r\n            OutputStream os = null;\r\n            try {\r\n                if (je.isDirectory()) {\r\n                    logger.logp(Level.FINER, \"OSGiArchiveHandler\", \"expandJar\", \"Skipping jar entry = {0} since this is of directiry type\", new Object[] { je });\r\n                    continue;\r\n                }\r\n                final String entryName = je.getName();\r\n                final long entrySize = je.getSize();\r\n                logger.logp(Level.FINER, \"OSGiArchiveHandler\", \"expandJar\", \"Writing jar entry name = {0}, size = {1}\", new Object[] { entryName, entrySize });\r\n                os = target.putNextEntry(entryName);\r\n                FileUtils.copy(jis, os, entrySize < 0 ? 0 : entrySize);\r\n            } finally {\r\n                if (os != null) {\r\n                    target.closeEntry();\r\n                }\r\n                jis.closeEntry();\r\n            }\r\n        }\r\n        Manifest m = jis.getManifest();\r\n        if (m != null) {\r\n            logger.logp(Level.FINER, \"OSGiArchiveHandler\", \"expandJar\", \"Writing manifest entry\");\r\n            OutputStream os = null;\r\n            try {\r\n                os = target.putNextEntry(JarFile.MANIFEST_NAME);\r\n                m.write(os);\r\n            } finally {\r\n                if (os != null) {\r\n                    target.closeEntry();\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        if (jis != null)\r\n            jis.close();\r\n        target.close();\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.io.json.JsonPlayerStatisticIoService.readStatistics",
	"Comment": "reads the stats of a player from its statistics file and writes the values to thestatisticmap.",
	"Method": "void readStatistics(GlowPlayer player){\r\n    File statsFile = getPlayerFile(player.getUniqueId());\r\n    player.getStatisticMap().getValues().clear();\r\n    if (statsFile.exists()) {\r\n        try {\r\n            JSONParser parser = new JSONParser();\r\n            JSONObject json = (JSONObject) parser.parse(new FileReader(statsFile));\r\n            for (Object obj : json.entrySet()) {\r\n                Map.Entry<String, Object> entry = (Map.Entry<String, Object>) obj;\r\n                Long longValue = null;\r\n                if (entry.getValue() instanceof Long) {\r\n                    longValue = (Long) entry.getValue();\r\n                } else if (entry.getValue() instanceof JSONObject) {\r\n                    JSONObject object = (JSONObject) entry.getValue();\r\n                    if (object.containsKey(\"value\")) {\r\n                        longValue = (Long) object.get(\"value\");\r\n                    }\r\n                } else {\r\n                    ConsoleMessages.Warn.Io.JSON_STAT_UNKNOWN.log(entry.getKey(), entry.getValue(), entry.getValue().getClass().getSimpleName());\r\n                }\r\n                if (longValue != null) {\r\n                    player.getStatisticMap().getValues().put(entry.getKey(), longValue.intValue());\r\n                }\r\n            }\r\n        } catch (ParseException | IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.jmacLogin",
	"Comment": "performs login for jmac security. the difference between thismethod and others is that it just verifies whether the login will succeedin the given realm.it does not set the result of the authentication in the appserver runtimeenvironmenta silent return from this method means that the given user succeeding inauthenticating with the given password in the given realm",
	"Method": "Subject jmacLogin(Subject subject,String username,char[] password,String realmName,Subject jmacLogin,Subject subject,X500Principal x500Principal,Subject jmacLogin,Subject subject,String identityAssertion,String realm){\r\n    if (subject == null) {\r\n        subject = new Subject();\r\n    }\r\n    final Subject fs = subject;\r\n    String userName = identityAssertion;\r\n    try {\r\n        if (realm == null || \"\".equals(realm)) {\r\n            realm = Realm.getDefaultRealm();\r\n        }\r\n        Realm realmInst = Realm.getInstance(realm);\r\n        final Enumeration groups = realmInst.getGroupNames(userName);\r\n        if (groups != null && groups.hasMoreElements()) {\r\n            AppservAccessController.doPrivileged(new PrivilegedAction() {\r\n                public java.lang.Object run() {\r\n                    while (groups.hasMoreElements()) {\r\n                        String grp = (String) groups.nextElement();\r\n                        fs.getPrincipals().add(new Group(grp));\r\n                    }\r\n                    return fs;\r\n                }\r\n            });\r\n        }\r\n    } catch (Exception ex) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Exception when trying to populate groups for CallerPrincipal \" + identityAssertion, ex);\r\n        }\r\n    }\r\n    return subject;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.jmacLogin",
	"Comment": "performs login for jmac security. the difference between thismethod and others is that it just verifies whether the login will succeedin the given realm.it does not set the result of the authentication in the appserver runtimeenvironmenta silent return from this method means that the given user succeeding inauthenticating with the given password in the given realm",
	"Method": "Subject jmacLogin(Subject subject,String username,char[] password,String realmName,Subject jmacLogin,Subject subject,X500Principal x500Principal,Subject jmacLogin,Subject subject,String identityAssertion,String realm){\r\n    while (groups.hasMoreElements()) {\r\n        String grp = (String) groups.nextElement();\r\n        fs.getPrincipals().add(new Group(grp));\r\n    }\r\n    return fs;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.DeleteAuditModule.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    ActionReport report = context.getActionReport();\r\n    try {\r\n        if (auditModule == null) {\r\n            report.setMessage(localStrings.getLocalString(\"delete.audit.module.notfound\", \"Specified Audit Module {0} not found\", auditModuleName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n        ConfigSupport.apply(new SingleConfigCode<SecurityService>() {\r\n            public Object run(SecurityService param) throws PropertyVetoException, TransactionFailure {\r\n                param.getAuditModule().remove(auditModule);\r\n                return null;\r\n            }\r\n        }, securityService);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.audit.module.fail\", \"Deletion of Audit Module {0} failed\", auditModuleName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.DeleteAuditModule.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    param.getAuditModule().remove(auditModule);\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.Realm.addAssignGroups",
	"Comment": "add assign groups to given vector of groups.to be used by getgroupnames.",
	"Method": "String[] addAssignGroups(String[] grps){\r\n    String[] resultGroups = grps;\r\n    if (assignGroups != null && assignGroups.size() > 0) {\r\n        List<String> groupList = new ArrayList<String>();\r\n        if (grps != null && grps.length > 0) {\r\n            for (String grp : grps) {\r\n                groupList.add(grp);\r\n            }\r\n        }\r\n        for (String agrp : assignGroups) {\r\n            if (!groupList.contains(agrp)) {\r\n                groupList.add(agrp);\r\n            }\r\n        }\r\n        resultGroups = groupList.toArray(new String[groupList.size()]);\r\n    }\r\n    return resultGroups;\r\n}"
}, {
	"Path": "net.glowstone.block.blocktype.BlockRedstoneTorch.getAttachedBlockFace",
	"Comment": "calculates the face on which a redstone torch is attached to the adjacent block.",
	"Method": "BlockFace getAttachedBlockFace(GlowBlock block){\r\n    MaterialData data = block.getState().getData();\r\n    if (data instanceof SimpleAttachableMaterialData) {\r\n        return ((SimpleAttachableMaterialData) data).getAttachedFace();\r\n    } else {\r\n        return BlockFace.DOWN;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreateMessageSecurityProvider.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    List<MessageSecurityConfig> mscs = secService.getMessageSecurityConfig();\r\n    MessageSecurityConfig msgSecCfg = null;\r\n    for (MessageSecurityConfig msc : mscs) {\r\n        if (msc.getAuthLayer().equals(authLayer)) {\r\n            msgSecCfg = msc;\r\n        }\r\n    }\r\n    if (msgSecCfg != null) {\r\n        List<ProviderConfig> pcs = msgSecCfg.getProviderConfig();\r\n        for (ProviderConfig pc : pcs) {\r\n            if (pc.getProviderId().equals(providerId)) {\r\n                report.setMessage(localStrings.getLocalString(\"create.message.security.provider.duplicatefound\", \"Message security provider named {0} exists. \" + \"Cannot add duplicate.\", providerId));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n        try {\r\n            ConfigSupport.apply(new SingleConfigCode<MessageSecurityConfig>() {\r\n                public Object run(MessageSecurityConfig param) throws PropertyVetoException, TransactionFailure {\r\n                    ProviderConfig newPC = param.createChild(ProviderConfig.class);\r\n                    populateProviderConfigElement(newPC);\r\n                    param.getProviderConfig().add(newPC);\r\n                    if (isDefaultProvider) {\r\n                        if (providerType.equals(SERVER) || providerType.equals(CLIENT_SERVER))\r\n                            param.setDefaultProvider(providerId);\r\n                        if (providerType.equals(CLIENT) || providerType.equals(CLIENT_SERVER))\r\n                            param.setDefaultClientProvider(providerId);\r\n                    }\r\n                    return newPC;\r\n                }\r\n            }, msgSecCfg);\r\n        } catch (TransactionFailure e) {\r\n            report.setMessage(localStrings.getLocalString(\"create.message.security.provider.fail\", \"Creation of message security provider named {0} failed\", providerId));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            report.setFailureCause(e);\r\n            return;\r\n        }\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n        report.setMessage(localStrings.getLocalString(\"create.message.security.provider.success\", \"Creation of message security provider named {0} completed \" + \"successfully\", providerId));\r\n    } else {\r\n        try {\r\n            ConfigSupport.apply(new SingleConfigCode<SecurityService>() {\r\n                public Object run(SecurityService param) throws PropertyVetoException, TransactionFailure {\r\n                    MessageSecurityConfig newMSC = param.createChild(MessageSecurityConfig.class);\r\n                    newMSC.setAuthLayer(authLayer);\r\n                    param.getMessageSecurityConfig().add(newMSC);\r\n                    ProviderConfig newPC = newMSC.createChild(ProviderConfig.class);\r\n                    populateProviderConfigElement(newPC);\r\n                    newMSC.getProviderConfig().add(newPC);\r\n                    if (isDefaultProvider) {\r\n                        if (providerType.equals(SERVER) || providerType.equals(CLIENT_SERVER))\r\n                            newMSC.setDefaultProvider(providerId);\r\n                        if (providerType.equals(CLIENT) || providerType.equals(CLIENT_SERVER))\r\n                            newMSC.setDefaultClientProvider(providerId);\r\n                    }\r\n                    return newMSC;\r\n                }\r\n            }, secService);\r\n        } catch (TransactionFailure e) {\r\n            report.setMessage(localStrings.getLocalString(\"create.message.security.provider.fail\", \"Creation of message security provider named {0} failed\", providerId));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            report.setFailureCause(e);\r\n            return;\r\n        }\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreateMessageSecurityProvider.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    ProviderConfig newPC = param.createChild(ProviderConfig.class);\r\n    populateProviderConfigElement(newPC);\r\n    param.getProviderConfig().add(newPC);\r\n    if (isDefaultProvider) {\r\n        if (providerType.equals(SERVER) || providerType.equals(CLIENT_SERVER))\r\n            param.setDefaultProvider(providerId);\r\n        if (providerType.equals(CLIENT) || providerType.equals(CLIENT_SERVER))\r\n            param.setDefaultClientProvider(providerId);\r\n    }\r\n    return newPC;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreateMessageSecurityProvider.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    MessageSecurityConfig newMSC = param.createChild(MessageSecurityConfig.class);\r\n    newMSC.setAuthLayer(authLayer);\r\n    param.getMessageSecurityConfig().add(newMSC);\r\n    ProviderConfig newPC = newMSC.createChild(ProviderConfig.class);\r\n    populateProviderConfigElement(newPC);\r\n    newMSC.getProviderConfig().add(newPC);\r\n    if (isDefaultProvider) {\r\n        if (providerType.equals(SERVER) || providerType.equals(CLIENT_SERVER))\r\n            newMSC.setDefaultProvider(providerId);\r\n        if (providerType.equals(CLIENT) || providerType.equals(CLIENT_SERVER))\r\n            newMSC.setDefaultClientProvider(providerId);\r\n    }\r\n    return newMSC;\r\n}"
}, {
	"Path": "net.glowstone.block.blocktype.BlockPiston.setType",
	"Comment": "update block server side without sending block change packets",
	"Method": "void setType(Block block,int type,int data){\r\n    World world = block.getWorld();\r\n    int x = block.getX();\r\n    int y = block.getY();\r\n    int z = block.getZ();\r\n    GlowChunk chunk = (GlowChunk) world.getChunkAt(block);\r\n    chunk.setType(x & 0xf, z & 0xf, y, type);\r\n    chunk.setMetaData(x & 0xf, z & 0xf, y, data);\r\n}"
}, {
	"Path": "net.glowstone.GlowWorld.newChunkLock",
	"Comment": "get a new chunk lock object a player or other party can use to keep chunkmanager loaded.",
	"Method": "ChunkLock newChunkLock(String desc){\r\n    return new ChunkLock(chunkManager, name + \": \" + desc);\r\n}"
}, {
	"Path": "net.glowstone.util.InventoryUtil.consumeHeldItem",
	"Comment": "consumes 1 copy of the given item, which must be held by the given player, unless that playeris in creative mode.",
	"Method": "void consumeHeldItem(HumanEntity player,ItemStack item){\r\n    if (player.getGameMode() == GameMode.CREATIVE) {\r\n        return;\r\n    }\r\n    if (item.getAmount() > 1) {\r\n        item.setAmount(item.getAmount() - 1);\r\n    } else {\r\n        player.getInventory().clear(player.getInventory().getHeldItemSlot());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.apt.ServiceAnnotationProcessor.process",
	"Comment": "annotation processor entry point, we are using a visitor pattern the visitonly the class declaration.",
	"Method": "boolean process(Set<? extends TypeElement> annotations,RoundEnvironment roundEnv){\r\n    ListClassVisitor listClassVisitor = new ListClassVisitor();\r\n    Collection<TypeElement> classes = new ArrayList<TypeElement>();\r\n    filterClasses(classes, roundEnv.getRootElements());\r\n    for (TypeElement typeDecl : classes) typeDecl.accept(listClassVisitor, null);\r\n    for (ServiceFileInfo info : serviceFiles.values()) {\r\n        if (info.isDirty()) {\r\n            if (debug) {\r\n                printNote(\"Creating META-INF/services \" + info.getServiceName() + \" file\");\r\n            }\r\n            PrintWriter writer = new PrintWriter(info.getWriter());\r\n            for (String implementor : info.getImplementors()) {\r\n                if (debug) {\r\n                    printNote(\" Implementor \" + implementor);\r\n                }\r\n                writer.println(implementor);\r\n            }\r\n            writer.close();\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.BaseCertificateLoginModule.getAppName",
	"Comment": "get the application name. this may be useful when a single loginmodule has to handlemultiple applications that use certificates.",
	"Method": "String getAppName(){\r\n    return appName;\r\n}"
}, {
	"Path": "net.glowstone.io.entity.EntityStorage.find",
	"Comment": "finds a store by entity class, throwing an exception if not found.",
	"Method": "EntityStore<?> find(Class<? extends GlowEntity> clazz,String type){\r\n    EntityStore<?> store = classTable.get(clazz);\r\n    if (store == null) {\r\n        throw new IllegalArgumentException(\"Unknown entity type to \" + type + \": \" + clazz);\r\n    }\r\n    return store;\r\n}"
}, {
	"Path": "net.glowstone.GlowWorld.getNearbyEntities",
	"Comment": "returns a list of entities within a bounding box centered around a location.some implementations may impose artificial restrictions on the size of the search boundingbox.",
	"Method": "Collection<Entity> getNearbyEntities(Location location,double x,double y,double z){\r\n    Vector minCorner = new Vector(location.getX() - x, location.getY() - y, location.getZ() - z);\r\n    Vector maxCorner = new Vector(location.getX() + x, location.getY() + y, location.getZ() + z);\r\n    BoundingBox searchBox = BoundingBox.fromCorners(minCorner, maxCorner);\r\n    GlowEntity except = null;\r\n    return entityManager.getEntitiesInside(searchBox, except);\r\n}"
}, {
	"Path": "net.glowstone.block.blocktype.BlockEnderPortalFrame.isCompletedPortal",
	"Comment": "check whether there is a completed portal with the specified center.",
	"Method": "boolean isCompletedPortal(GlowBlock center){\r\n    for (int i = 0; i < 4; i++) {\r\n        for (int j = -1; j <= 1; j++) {\r\n            GlowBlock block = center.getRelative(SIDES[i], 2).getRelative(SIDES[(i + 1) % 4], j);\r\n            if (block.getType() != Material.ENDER_PORTAL_FRAME || (block.getData() & 0x4) == 0) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.glowstone.io.structure.StructurePieceStore.load",
	"Comment": "load structure piece data of the appropriate type from the given compound tag.",
	"Method": "void load(T structurePiece,CompoundTag compound){\r\n    compound.readInt(\"GD\", structurePiece::setUnknownGd);\r\n    compound.readInt(\"O\", structurePiece::setNumericOrientation);\r\n    compound.readIntArray(\"BB\", bb -> {\r\n        if (bb.length == 6) {\r\n            StructureBoundingBox boundingBox = new StructureBoundingBox(new Vector(bb[0], bb[1], bb[2]), new Vector(bb[3], bb[4], bb[5]));\r\n            structurePiece.setBoundingBox(boundingBox);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "net.glowstone.GlowServer.getStorageProviderFactory",
	"Comment": "gets the current storage provider factory, or null if none has been set by a plugin and theserver has not started yet. the storage provider factory will be used to initialize storagefor each world.",
	"Method": "WorldStorageProviderFactory getStorageProviderFactory(){\r\n    return storageProviderFactory;\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowPlayer.stopHidingDisconnectedPlayer",
	"Comment": "called when a player hidden to this player disconnects. this is necessary so the player isvisible again after they reconnected.",
	"Method": "void stopHidingDisconnectedPlayer(Player player){\r\n    hiddenEntities.remove(player.getUniqueId());\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.file.FileRealmUser.getAttributeNames",
	"Comment": "return the names of the supported attributes for this user.not really needed.",
	"Method": "Enumeration getAttributeNames(){\r\n    return attributes.keys();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.SolarisLoginModule.authenticate",
	"Comment": "perform solaris authentication. delegates to solarisrealm.",
	"Method": "void authenticate(){\r\n    if (!(_currentRealm instanceof SolarisRealm)) {\r\n        String msg = sm.getString(\"solarislm.badrealm\");\r\n        throw new LoginException(msg);\r\n    }\r\n    SolarisRealm solarisRealm = (SolarisRealm) _currentRealm;\r\n    if ((_username == null) || (_username.length() == 0)) {\r\n        String msg = sm.getString(\"solarislm.nulluser\");\r\n        throw new LoginException(msg);\r\n    }\r\n    String[] grpList = solarisRealm.authenticate(_username, getPasswordChar());\r\n    if (grpList == null) {\r\n        String msg = sm.getString(\"solarislm.loginfail\", _username);\r\n        throw new LoginException(msg);\r\n    }\r\n    if (_logger.isLoggable(Level.FINEST)) {\r\n        _logger.finest(\"Solaris login succeeded for: \" + _username);\r\n    }\r\n    commitAuthentication(_username, getPasswordChar(), _currentRealm, grpList);\r\n}"
}, {
	"Path": "net.glowstone.entity.GlowPlayer.addMoveExhaustion",
	"Comment": "add the exhaustion for sprinting from the given location to the current location, if thisplayer is sprinting.",
	"Method": "void addMoveExhaustion(Location move){\r\n    if (shouldCalculateExhaustion() && !teleported && isSprinting()) {\r\n        double distanceSquared = location.distanceSquared(move);\r\n        if (distanceSquared > 0) {\r\n            double distance = Math.sqrt(distanceSquared);\r\n            addExhaustion((float) (0.1f * distance));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.security.services.api.authentication.AbstractInternalSystemAdministrator.createSubject",
	"Comment": "creates a subject using the impersonate method on the authenticationservice.",
	"Method": "Subject createSubject(){\r\n    Subject s;\r\n    try {\r\n        s = authService.impersonate(getInternalUsername(), new String[] { getAdminGroupName() }, null, true);\r\n        return s;\r\n    } catch (LoginException ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.WriteableView.join",
	"Comment": "enter a new transaction, this method should return false if this objectis already enlisted in another transaction, or cannot be enlisted withthe passed transaction. if the object returns true, the objectis enlisted in the passed transaction and cannot be enlisted in anothertransaction until either commit or abort has been issued.",
	"Method": "boolean join(Transaction t){\r\n    if (currentTx == null) {\r\n        currentTx = t;\r\n        t.addParticipant(this);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.ListAuthRealm.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    for (AuthRealm authRealm : securityService.getAuthRealm()) {\r\n        ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n        part.setMessage(authRealm.getName());\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "net.glowstone.entity.physics.BoundingBox.getSize",
	"Comment": "returns the displacement of the maximum corner from the minimum corner.",
	"Method": "Vector getSize(){\r\n    return maxCorner.clone().subtract(minCorner);\r\n}"
}, {
	"Path": "net.glowstone.GlowWorld.getBlockEntityCount",
	"Comment": "returns the number of block entities in loaded chunkmanager.",
	"Method": "int getBlockEntityCount(){\r\n    int length = 0;\r\n    for (GlowChunk chunk : getChunkManager().getLoadedChunks()) {\r\n        length += chunk.getBlockEntities().length;\r\n    }\r\n    return length;\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.InjectionResolver.isOptional",
	"Comment": "returns true if the resolution of this injection identified by thepassed annotation instance is optional",
	"Method": "boolean isOptional(AnnotatedElement annotated,U annotation){\r\n    return false;\r\n}"
}, {
	"Path": "net.glowstone.entity.MetadataIndexTest.testNoOverlap",
	"Comment": "tests that no two metadataindex entries can overlap on a single entity. will not catch failure for entities without any metadata keys defined.",
	"Method": "void testNoOverlap(){\r\n    HashMap<Class<?>, HashMap<Integer, MetadataIndex>> map = new HashMap();\r\n    for (MetadataIndex index : MetadataIndex.values()) {\r\n        Class<?> clazz = index.getAppliesTo();\r\n        if (clazz == null) {\r\n            continue;\r\n        }\r\n        if (index == MetadataIndex.ARMORSTAND_LEFT_LEG_POSITION) {\r\n            continue;\r\n        }\r\n        map.entrySet().stream().filter(entry -> entry.getKey().isAssignableFrom(clazz)).filter(entry -> entry.getValue().containsKey(index.getIndex())).forEach(entry -> fail(\"Index \" + index + \"(\" + clazz.getSimpleName() + \") conflicts with \" + entry.getValue().get(index.getIndex()) + \"(\" + entry.getKey().getSimpleName() + \")\"));\r\n        HashMap<Integer, MetadataIndex> classMap = map.computeIfAbsent(index.getAppliesTo(), k -> new HashMap());\r\n        classMap.put(index.getIndex(), index);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.SecurityContext.init",
	"Comment": "initialize the securitycontext and handle the unauthenticated principal case",
	"Method": "SecurityContext init(){\r\n    SecurityContext sc = currentSecCtx.get();\r\n    if (sc == null) {\r\n        sc = defaultSecurityContext;\r\n    }\r\n    return sc;\r\n}"
}, {
	"Path": "net.glowstone.chunk.ChunkSection.fromStateArray",
	"Comment": "creates a new unlit chunk section containing the given types.",
	"Method": "ChunkSection fromStateArray(short[] types){\r\n    if (types.length != ARRAY_SIZE) {\r\n        throw new IllegalArgumentException(\"Types array length was not \" + ARRAY_SIZE + \": \" + types.length);\r\n    }\r\n    char[] charTypes = new char[ARRAY_SIZE];\r\n    for (int i = 0; i < ARRAY_SIZE; i++) {\r\n        charTypes[i] = (char) (types[i]);\r\n    }\r\n    return new ChunkSection(charTypes);\r\n}"
}, {
	"Path": "net.glowstone.generator.objects.OreType.getRandomHeight",
	"Comment": "generates a random height at which a vein of this ore can spawn.",
	"Method": "int getRandomHeight(Random random){\r\n    return getMinY() == getMaxY() ? random.nextInt(getMinY()) + random.nextInt(getMinY()) : random.nextInt(getMaxY() - getMinY()) + getMinY();\r\n}"
}, {
	"Path": "net.glowstone.chunk.ChunkManager.isChunkInUse",
	"Comment": "check whether a chunk has locks on it preventing it from being unloaded.",
	"Method": "boolean isChunkInUse(int x,int z){\r\n    Key key = GlowChunk.Key.of(x, z);\r\n    return lockSet.contains(key);\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.readBoolean",
	"Comment": "applies the given function to a byte subtag if it is present, converting it to boolean first.",
	"Method": "boolean readBoolean(String key,Consumer<? super Boolean> consumer){\r\n    return readTag(key, ByteTag.class, byteVal -> consumer.accept(byteVal != 0));\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.setClientSecurityContext",
	"Comment": "sets the security context on the appclient side.it sets the relevant information into the tls",
	"Method": "void setClientSecurityContext(String username,Subject subject){\r\n    ClientSecurityContext securityContext = new ClientSecurityContext(username, subject);\r\n    ClientSecurityContext.setCurrent(securityContext);\r\n}"
}, {
	"Path": "net.glowstone.inventory.WindowClickLogic.getClickType",
	"Comment": "determine the clicktype of a window click message based on the raw mode, button, and slotvalues if possible.",
	"Method": "ClickType getClickType(int mode,int button,int slot){\r\n    switch(mode) {\r\n        case 0:\r\n            if (button == 0) {\r\n                return slot == -1 ? ClickType.WINDOW_BORDER_LEFT : ClickType.LEFT;\r\n            } else if (button == 1) {\r\n                return slot == -1 ? ClickType.WINDOW_BORDER_RIGHT : ClickType.RIGHT;\r\n            }\r\n            break;\r\n        case 1:\r\n            if (button == 0) {\r\n                return ClickType.SHIFT_LEFT;\r\n            } else if (button == 1) {\r\n                return ClickType.SHIFT_RIGHT;\r\n            }\r\n            break;\r\n        case 2:\r\n            return ClickType.NUMBER_KEY;\r\n        case 3:\r\n            if (button == 2) {\r\n                return ClickType.MIDDLE;\r\n            }\r\n            break;\r\n        case 4:\r\n            if (button == 0) {\r\n                return ClickType.DROP;\r\n            } else if (button == 1) {\r\n                return ClickType.CONTROL_DROP;\r\n            }\r\n            break;\r\n        case 5:\r\n            break;\r\n        case 6:\r\n            return ClickType.DOUBLE_CLICK;\r\n        default:\r\n            return ClickType.UNKNOWN;\r\n    }\r\n    return ClickType.UNKNOWN;\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.readList",
	"Comment": "applies the given function to a list subtag if it is present, converting it to a list ofvalues first.",
	"Method": "boolean readList(String key,TagType type,Consumer<? super List<T>> consumer){\r\n    if (isList(key, type)) {\r\n        consumer.accept(getList(key, type));\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.ClientPasswordLoginModule.login",
	"Comment": "authenticate the user by prompting for a username and password.",
	"Method": "boolean login(){\r\n    if (callbackHandler == null) {\r\n        String failure = localStrings.getLocalString(\"login.nocallback\", \"Error: no CallbackHandler available to garner authentication information from the user\");\r\n        throw new LoginException(failure);\r\n    }\r\n    String uname = UsernamePasswordStore.getUsername();\r\n    char[] pswd = UsernamePasswordStore.getPassword();\r\n    boolean doSet = false;\r\n    if (uname == null) {\r\n        uname = System.getProperty(LOGIN_NAME);\r\n        doSet = true;\r\n    }\r\n    if (pswd == null) {\r\n        if (System.getProperty(LOGIN_PASSWORD) != null) {\r\n            pswd = System.getProperty(LOGIN_PASSWORD).toCharArray();\r\n        }\r\n        doSet = true;\r\n    }\r\n    if (doSet) {\r\n        UsernamePasswordStore.set(uname, pswd);\r\n    }\r\n    if (uname != null && pswd != null) {\r\n        username = uname;\r\n        int length = pswd.length;\r\n        password = new char[length];\r\n        System.arraycopy(pswd, 0, password, 0, length);\r\n    } else {\r\n        Callback[] callbacks = new Callback[2];\r\n        NameCallback nameCB = new NameCallback(localStrings.getLocalString(\"login.username\", \"ClientPasswordModule username\"));\r\n        String defaultUname = System.getProperty(\"user.name\");\r\n        if (defaultUname != null) {\r\n            nameCB = new NameCallback(localStrings.getLocalString(\"login.username\", \"ClientPasswordModule username\"), defaultUname);\r\n        }\r\n        callbacks[0] = nameCB;\r\n        callbacks[1] = new PasswordCallback(localStrings.getLocalString(\"login.password\", \"ClientPasswordModule password: \"), false);\r\n        try {\r\n            callbackHandler.handle(callbacks);\r\n            username = ((NameCallback) callbacks[0]).getName();\r\n            if (username == null) {\r\n                String fail = localStrings.getLocalString(\"login.nousername\", \"No user specified\");\r\n                throw new LoginException(fail);\r\n            }\r\n            char[] tmpPassword = ((PasswordCallback) callbacks[1]).getPassword();\r\n            if (tmpPassword == null) {\r\n                tmpPassword = new char[0];\r\n            }\r\n            password = new char[tmpPassword.length];\r\n            System.arraycopy(tmpPassword, 0, password, 0, tmpPassword.length);\r\n            ((PasswordCallback) callbacks[1]).clearPassword();\r\n        } catch (java.io.IOException ioe) {\r\n            throw new LoginException(ioe.toString());\r\n        } catch (UnsupportedCallbackException uce) {\r\n            String nocallback = localStrings.getLocalString(\"login.callback\", \"Error: Callback not available to garner authentication information from user(CallbackName):\");\r\n            throw new LoginException(nocallback + uce.getCallback().toString());\r\n        }\r\n    }\r\n    _logger.log(Level.FINEST, \"\\t\\t[ClientPasswordLoginModule] \" + \"authentication succeeded\");\r\n    succeeded = true;\r\n    return true;\r\n}"
}, {
	"Path": "org.glassfish.security.services.impl.authorization.RoleMappingServiceImpl.initialize",
	"Comment": "initialize the role mapping service with the configured role mapping provider.",
	"Method": "void initialize(SecurityConfiguration securityServiceConfiguration){\r\n    if (InitializationState.NOT_INITIALIZED != initialized) {\r\n        return;\r\n    }\r\n    try {\r\n        config = (org.glassfish.security.services.config.RoleMappingService) securityServiceConfiguration;\r\n        if (config != null) {\r\n            List<SecurityProvider> providersConfig = config.getSecurityProviders();\r\n            SecurityProvider roleProviderConfig = null;\r\n            if (providersConfig != null)\r\n                roleProviderConfig = providersConfig.get(0);\r\n            if (roleProviderConfig != null) {\r\n                String providerName = roleProviderConfig.getName();\r\n                if (isDebug()) {\r\n                    logger.log(DEBUG_LEVEL, \"Attempting to get Role Mapping Provider \\\"{0}\\\".\", providerName);\r\n                }\r\n                provider = AccessController.doPrivileged(new PrivilegedLookup<RoleMappingProvider>(serviceLocator, RoleMappingProvider.class, providerName));\r\n                if (provider == null) {\r\n                    throw new IllegalStateException(localStrings.getLocalString(\"service.role.not_provider\", \"Role Mapping Provider {0} not found.\", providerName));\r\n                }\r\n                provider.initialize(roleProviderConfig);\r\n                initialized = InitializationState.SUCCESS_INIT;\r\n                reasonInitFailed = null;\r\n                logger.log(Level.INFO, ROLEMAPSVC_INITIALIZED);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        String eMsg = e.getMessage();\r\n        String eClass = e.getClass().getName();\r\n        reasonInitFailed = localStrings.getLocalString(\"service.role.init_failed\", \"Role Mapping Service initialization failed, exception {0}, message {1}\", eClass, eMsg);\r\n        logger.log(Level.WARNING, ROLEMAPSVC_INIT_FAILED, new Object[] { eClass, eMsg });\r\n        throw new RuntimeException(reasonInitFailed, e);\r\n    } finally {\r\n        if (InitializationState.SUCCESS_INIT != initialized) {\r\n            initialized = InitializationState.FAILED_INIT;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.util.BlockStateDelegate.setTypeAndData",
	"Comment": "sets a block type and materialdata, and add it to the blockstate list.",
	"Method": "void setTypeAndData(World world,int x,int y,int z,Material type,MaterialData data){\r\n    GlowBlockState state = (GlowBlockState) world.getBlockAt(x, y, z).getState();\r\n    state.setType(type);\r\n    state.setData(data);\r\n    blockStateMap.put(world.getBlockAt(x, y, z).getLocation(), state);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.BasePasswordLoginModule.commitUserAuthentication",
	"Comment": "this is a convenience method which can be used by subclassesnote that this method is called after the authenticationhas succeeded. if authentication failed do not call this method.global instance field succeeded is set to true by this method.",
	"Method": "void commitUserAuthentication(String[] groups){\r\n    String[] groupsListCopy = (groups == null) ? null : Arrays.copyOf(groups, groups.length);\r\n    _groupsList = groupsListCopy;\r\n    _succeeded = true;\r\n}"
}, {
	"Path": "net.glowstone.io.anvil.RegionFile.getSizeDelta",
	"Comment": "returns how much the region file has grown since this function was last called.",
	"Method": "int getSizeDelta(){\r\n    return sizeDelta.getAndSet(0);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.login.LoginContextDriver.logout",
	"Comment": "this method logs out the user by clearing the security context.",
	"Method": "void logout(){\r\n    unsetSecurityContext();\r\n}"
}, {
	"Path": "org.glassfish.grizzly.config.ssl.JSSESupport.getKeySize",
	"Comment": "copied from org.apache.catalina.valves.certificatevalve",
	"Method": "Integer getKeySize(){\r\n    SSLSupport.CipherData[] c_aux = ciphers;\r\n    if (session == null)\r\n        return null;\r\n    Integer keySize = (Integer) session.getValue(KEY_SIZE_KEY);\r\n    if (keySize == null) {\r\n        int size = 0;\r\n        String cipherSuite = session.getCipherSuite();\r\n        for (int i = 0; i < c_aux.length; i++) {\r\n            if (cipherSuite.indexOf(c_aux[i].phrase) >= 0) {\r\n                size = c_aux[i].keySize;\r\n                break;\r\n            }\r\n        }\r\n        keySize = size;\r\n        session.putValue(KEY_SIZE_KEY, keySize);\r\n    }\r\n    return keySize;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreateAuditModule.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    List<AuditModule> ams = securityService.getAuditModule();\r\n    for (AuditModule am : ams) {\r\n        if (am.getName().equals(auditModuleName)) {\r\n            report.setMessage(localStrings.getLocalString(\"create.audit.module.duplicatefound\", \"AuditModule named {0} exists. \" + \"Cannot add duplicate AuditModule.\", auditModuleName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<SecurityService>() {\r\n            public Object run(SecurityService param) throws PropertyVetoException, TransactionFailure {\r\n                AuditModule newAuditModule = param.createChild(AuditModule.class);\r\n                populateAuditModuleElement(newAuditModule);\r\n                param.getAuditModule().add(newAuditModule);\r\n                return newAuditModule;\r\n            }\r\n        }, securityService);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(localStrings.getLocalString(\"create.audit.module.fail\", \"Creation of AuditModule {0} failed\", auditModuleName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.cli.CreateAuditModule.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    AuditModule newAuditModule = param.createChild(AuditModule.class);\r\n    populateAuditModuleElement(newAuditModule);\r\n    param.getAuditModule().add(newAuditModule);\r\n    return newAuditModule;\r\n}"
}, {
	"Path": "net.glowstone.util.NibbleArray.setRawData",
	"Comment": "copies into the raw bytes of this nibble array from the given source.",
	"Method": "void setRawData(byte source){\r\n    checkArgument(source.length == rawData.length, \"expected byte array of length \" + rawData.length + \", not \" + source.length);\r\n    System.arraycopy(source, 0, rawData, 0, source.length);\r\n}"
}, {
	"Path": "net.glowstone.constants.GlowParticle.isLongDistance",
	"Comment": "determine whether a particle type is considered long distance, meaning it has a highervisible range than normal.",
	"Method": "boolean isLongDistance(Effect particle,boolean isLongDistance,Particle particle){\r\n    switch(particle) {\r\n        case EXPLOSION_NORMAL:\r\n        case EXPLOSION_LARGE:\r\n        case EXPLOSION_HUGE:\r\n        case MOB_APPEARANCE:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.util.mojangson.Mojangson.parseFloat",
	"Comment": "parses a float value from a mojangson string as an nbt floattag.",
	"Method": "FloatTag parseFloat(String mojangson){\r\n    Character lastChar = mojangson.charAt(mojangson.length() - 1);\r\n    if (lastChar.toString().toLowerCase().charAt(0) == MojangsonToken.FLOAT_SUFFIX.getSymbol()) {\r\n        mojangson = mojangson.substring(0, mojangson.length() - 1);\r\n    }\r\n    try {\r\n        return new FloatTag(Float.valueOf(mojangson));\r\n    } catch (NumberFormatException nfe) {\r\n        throw new MojangsonParseException(\"\\'\" + mojangson + \"\\'\", MojangsonParseException.ParseExceptionReason.INVALID_FORMAT_NUM);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.util.nbt.CompoundTag.readDouble",
	"Comment": "applies the given function to a double subtag if it is present.",
	"Method": "boolean readDouble(String key,DoubleConsumer consumer){\r\n    if (isDouble(key)) {\r\n        consumer.accept(getDouble(key));\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.glowstone.chunk.GlowChunk.getEntity",
	"Comment": "attempt to get the block entity located at the given coordinates.",
	"Method": "BlockEntity getEntity(int x,int y,int z){\r\n    if (y >= DEPTH || y < 0) {\r\n        return null;\r\n    }\r\n    load();\r\n    return blockEntities.get(coordinateToIndex(x, z, y));\r\n}"
}, {
	"Path": "org.glassfish.resourcebase.resources.listener.ResourceManager.removeListenerForResource",
	"Comment": "remove listener from a resourceused in the case of delete asadmin command",
	"Method": "void removeListenerForResource(Object instance){\r\n    ObservableBean bean = null;\r\n    if (instance instanceof Resource) {\r\n        bean = (ObservableBean) ConfigSupport.getImpl((ConfigBeanProxy) instance);\r\n        bean.removeListener(this);\r\n    } else if (instance instanceof ResourceRef) {\r\n        bean = (ObservableBean) ConfigSupport.getImpl((ConfigBeanProxy) instance);\r\n        bean.removeListener(this);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.GlowWorldBorder.pulse",
	"Comment": "pulses the world border for each tick.attempts to call this method more than once per tick will be ignored.",
	"Method": "void pulse(){\r\n    if (lastWorldTick >= world.getFullTime()) {\r\n        return;\r\n    }\r\n    lastWorldTick = world.getFullTime();\r\n    if (step != 0) {\r\n        size += step;\r\n        if (Math.abs(size - sizeLerpTarget) < 1) {\r\n            size = sizeLerpTarget;\r\n            sizeLerpTime = 0;\r\n            step = 0;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.io.nbt.NbtSerialization.readItem",
	"Comment": "read an item stack in from an nbt tag.returns null if no item exists.",
	"Method": "ItemStack readItem(CompoundTag tag){\r\n    final Material[] material = { null };\r\n    if ((!tag.readString(\"id\", id -> material[0] = ItemIds.getItem(id)) && !tag.readShort(\"id\", id -> material[0] = Material.getMaterial(id))) || material[0] == null || material[0] == Material.AIR) {\r\n        return null;\r\n    }\r\n    final byte[] count = { 0 };\r\n    tag.readByte(\"Count\", x -> count[0] = x);\r\n    if (count[0] == 0) {\r\n        return null;\r\n    }\r\n    final short[] damage = { 0 };\r\n    tag.readShort(\"Damage\", x -> damage[0] = x);\r\n    ItemStack stack = new ItemStack(material[0], count[0], damage[0]);\r\n    tag.readCompound(\"tag\", subtag -> stack.setItemMeta(GlowItemFactory.instance().readNbt(material[0], subtag)));\r\n    return stack;\r\n}"
}, {
	"Path": "net.glowstone.util.Position.getDirection",
	"Comment": "gets the byte rotation for an intercardinal blockface, where north is 0.",
	"Method": "BlockFace getDirection(byte rotation,byte getDirection,BlockFace rotation){\r\n    return (byte) ROTATIONS.indexOf(rotation);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.AuthenticationStatusImpl.getRealmName",
	"Comment": "this method returns the name of realm where the authentication wasperformed.",
	"Method": "String getRealmName(){\r\n    return realmName;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.BasePasswordLoginModule.setUsername",
	"Comment": "used for setting the username obtained from the container internally, tobe made available to the custom login module implementation",
	"Method": "void setUsername(String username){\r\n    this._username = username;\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.ConfigSupport._apply",
	"Comment": "executes some logic on some config beans protected by a transaction.",
	"Method": "Object _apply(ConfigCode code,ConfigBeanProxy objects){\r\n    WriteableView[] views = new WriteableView[objects.length];\r\n    ConfigBeanProxy[] proxies = new ConfigBeanProxy[objects.length];\r\n    for (int i = 0; i < objects.length; i++) {\r\n        proxies[i] = getWriteableView(objects[i]);\r\n        views[i] = (WriteableView) Proxy.getInvocationHandler(proxies[i]);\r\n    }\r\n    Transaction t = new Transaction();\r\n    for (WriteableView view : views) {\r\n        if (!view.join(t)) {\r\n            t.rollback();\r\n            throw new TransactionFailure(\"Cannot enlist \" + view.getMasterView().getProxyType() + \" in transaction\", null);\r\n        }\r\n    }\r\n    try {\r\n        final Object toReturn = code.run(proxies);\r\n        try {\r\n            t.commit();\r\n            if (toReturn instanceof WriteableView) {\r\n                return ((WriteableView) toReturn).getMasterView();\r\n            } else {\r\n                return toReturn;\r\n            }\r\n        } catch (RetryableException e) {\r\n            System.out.println(\"Retryable...\");\r\n            t.rollback();\r\n            return null;\r\n        } catch (TransactionFailure e) {\r\n            t.rollback();\r\n            throw e;\r\n        }\r\n    } catch (java.lang.reflect.UndeclaredThrowableException e) {\r\n        t.rollback();\r\n        Throwable throwable = e.getCause();\r\n        if (throwable instanceof PropertyVetoException)\r\n            throw new TransactionFailure(throwable.toString(), throwable);\r\n        throw new TransactionFailure(e.toString(), e);\r\n    } catch (TransactionFailure e) {\r\n        t.rollback();\r\n        throw e;\r\n    } catch (Exception e) {\r\n        t.rollback();\r\n        throw new TransactionFailure(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "net.glowstone.constants.GlowEnchantment.isTreasure",
	"Comment": "treasure enchantments can only be obtained from chest loot, fishing, or trading for enchantedbooks.",
	"Method": "boolean isTreasure(){\r\n    return impl.treasure;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.Realm.instantiate",
	"Comment": "instantiate a realm with the given name and properties using theclass name given. this method is used by ias and not ri.",
	"Method": "Realm instantiate(String name,String className,Properties props,Realm instantiate,String name,String className,Properties props,String configName,Realm instantiate,String realmName,File f){\r\n    if (!f.exists() || !f.isFile()) {\r\n        throw new FileNotFoundException();\r\n    }\r\n    if (_getInstance(realmName) != null) {\r\n        throw new BadRealmException(localStrings.getLocalString(\"realm.already_exists\", \"This Realm already exists.\"));\r\n    }\r\n    InputStream in = null;\r\n    Properties props = new Properties();\r\n    try {\r\n        in = new FileInputStream(f);\r\n        props.load(in);\r\n        String classname = props.getProperty(\"classname\");\r\n        assert (classname != null);\r\n        return doInstantiate(realmName, classname, props);\r\n    } catch (IOException e) {\r\n        throw new BadRealmException(e.toString());\r\n    } finally {\r\n        if (in != null) {\r\n            try {\r\n                in.close();\r\n            } catch (Exception ex) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.jvnet.hk2.config.Dom.attributesToWrite",
	"Comment": "returns the map of attributes names and values for attributes whichvalue is neither null or the default value. these attributes areconsidered having a non default value and must be written out.",
	"Method": "Map<String, String> attributesToWrite(){\r\n    Map<String, String> attributesToWrite = new HashMap<String, String>();\r\n    Map<String, String> localAttr = new HashMap<String, String>(attributes);\r\n    for (Map.Entry<String, String> a : localAttr.entrySet()) {\r\n        ConfigModel.AttributeLeaf am = model.attributes.get(a.getKey());\r\n        String dv = am.getDefaultValue();\r\n        if (dv == null || !dv.equals(a.getValue())) {\r\n            attributesToWrite.put(a.getKey(), a.getValue());\r\n        }\r\n    }\r\n    return attributesToWrite;\r\n}"
}]