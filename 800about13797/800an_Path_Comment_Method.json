[{
	"Path": "org.gnucash.android.model.ScheduledAction.getAdvanceNotifyDays",
	"Comment": "returns the number of days in advance to notify of scheduled transactionsthis flag is currently unused in the app. it is only included here for compatibility with gnucash desktop xml",
	"Method": "int getAdvanceNotifyDays(){\r\n    return mAdvanceNotifyDays;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.setDefaultTransferAccountSelection",
	"Comment": "selects the account with id parentaccountid in the default transfer account spinner",
	"Method": "void setDefaultTransferAccountSelection(long defaultTransferAccountId,boolean enableTransferAccount){\r\n    if (defaultTransferAccountId > 0) {\r\n        mDefaultTransferAccountCheckBox.setChecked(enableTransferAccount);\r\n        mDefaultTransferAccountSpinner.setEnabled(enableTransferAccount);\r\n    } else\r\n        return;\r\n    for (int pos = 0; pos < mDefaultTransferAccountCursorAdapter.getCount(); pos++) {\r\n        if (mDefaultTransferAccountCursorAdapter.getItemId(pos) == defaultTransferAccountId) {\r\n            mDefaultTransferAccountSpinner.setSelection(pos);\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.setExecutionCount",
	"Comment": "sets the number of times this scheduled action has been executed",
	"Method": "void setExecutionCount(int executionCount){\r\n    mExecutionCount = executionCount;\r\n}"
}, {
	"Path": "net.glowstone.inventory.PlayerInventoryTest.checkArmorContents",
	"Comment": "check that the armor contents match the test armor contents.",
	"Method": "void checkArmorContents(){\r\n    assertThat(\"Mismatch in armor contents\", inventory.getArmorContents(), is(TEST_ARMOR));\r\n    assertThat(\"Mismatch in boots slot\", inventory.getBoots(), is(TEST_BOOTS));\r\n    assertThat(\"Mismatch in leggings slot\", inventory.getLeggings(), is(TEST_LEGGINGS));\r\n    assertThat(\"Mismatch in chestplate slot\", inventory.getChestplate(), is(TEST_CHESTPLATE));\r\n    assertThat(\"Mismatch in helmet slot\", inventory.getHelmet(), is(TEST_HELMET));\r\n}"
}, {
	"Path": "ca.uhn.fhir.context.FhirContext.getRestfulClientFactory",
	"Comment": "get the restful client factory. if no factory has been set, this will be initialized with\ta new apacherestfulclientfactory.",
	"Method": "IRestfulClientFactory getRestfulClientFactory(){\r\n    if (myRestfulClientFactory == null) {\r\n        try {\r\n            myRestfulClientFactory = (IRestfulClientFactory) ReflectionUtil.newInstance(Class.forName(\"ca.uhn.fhir.rest.client.apache.ApacheRestfulClientFactory\"), FhirContext.class, this);\r\n        } catch (ClassNotFoundException e) {\r\n            throw new ConfigurationException(\"hapi-fhir-client does not appear to be on the classpath\");\r\n        }\r\n    }\r\n    return myRestfulClientFactory;\r\n}"
}, {
	"Path": "ca.uhn.fhir.model.api.Include.getParamName",
	"Comment": "returns the portion of the value after the first colon but before the second colon",
	"Method": "String getParamName(){\r\n    int firstColon = myValue.indexOf(':');\r\n    if (firstColon == -1 || firstColon == myValue.length() - 1) {\r\n        return null;\r\n    }\r\n    int secondColon = myValue.indexOf(':', firstColon + 1);\r\n    if (secondColon != -1) {\r\n        return myValue.substring(firstColon + 1, secondColon);\r\n    }\r\n    return myValue.substring(firstColon + 1);\r\n}"
}, {
	"Path": "org.gnucash.android.app.GnuCashApplication.startScheduledActionExecutionService",
	"Comment": "starts the service for scheduled events and schedules an alarm to call the service twice daily.if the alarm already exists, this method does nothing. if not, the alarm will be createdhence, there is no harm in calling the method repeatedly",
	"Method": "void startScheduledActionExecutionService(Context context){\r\n    Intent alarmIntent = new Intent(context, PeriodicJobReceiver.class);\r\n    alarmIntent.setAction(PeriodicJobReceiver.ACTION_SCHEDULED_ACTIONS);\r\n    PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, alarmIntent, PendingIntent.FLAG_NO_CREATE);\r\n    if (pendingIntent != null)\r\n        return;\r\n    else\r\n        pendingIntent = PendingIntent.getBroadcast(context, 0, alarmIntent, 0);\r\n    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\r\n    alarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + AlarmManager.INTERVAL_FIFTEEN_MINUTES, AlarmManager.INTERVAL_HOUR, pendingIntent);\r\n    ScheduledActionService.enqueueWork(context);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.util.CursorRecyclerAdapter.convertToString",
	"Comment": "converts the cursor into a charsequence. subclasses should override thismethod to convert their results. the default implementation returns anempty string for null values or the default string representation ofthe value.",
	"Method": "CharSequence convertToString(Cursor cursor,CharSequence convertToString,Cursor cursor){\r\n    return cursor == null ? \"\" : cursor.toString();\r\n}"
}, {
	"Path": "org.gnucash.android.ui.util.CursorRecyclerAdapter.getFilterQueryProvider",
	"Comment": "returns the query filter provider used for filtering. when theprovider is null, no filtering occurs.",
	"Method": "FilterQueryProvider getFilterQueryProvider(){\r\n    return mFilterQueryProvider;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.export.ExportFormFragment.setExportUriText",
	"Comment": "display the file path of the file where the export will be saved",
	"Method": "void setExportUriText(String filepath){\r\n    if (filepath == null) {\r\n        mTargetUriTextView.setVisibility(View.GONE);\r\n        mTargetUriTextView.setText(\"\");\r\n    } else {\r\n        mTargetUriTextView.setText(filepath);\r\n        mTargetUriTextView.setVisibility(View.VISIBLE);\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.ui.report.ReportsActivity.updateGroupingOnFragments",
	"Comment": "updates the report grouping interval on all attached fragments which are listening",
	"Method": "void updateGroupingOnFragments(){\r\n    List<Fragment> fragments = getSupportFragmentManager().getFragments();\r\n    for (Fragment fragment : fragments) {\r\n        if (fragment instanceof ReportOptionsListener) {\r\n            ((ReportOptionsListener) fragment).onGroupingUpdated(mReportGroupInterval);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.getExecutionCount",
	"Comment": "returns how many times this scheduled action has already been executed",
	"Method": "int getExecutionCount(){\r\n    return mExecutionCount;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Split.setQuantity",
	"Comment": "sets the quantity value of the split.the quantity is in the currency of the owning account.it will be stored unsigned.",
	"Method": "void setQuantity(Money quantity){\r\n    this.mQuantity = quantity.abs();\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.getPeriod",
	"Comment": "returns the period of this scheduled action in milliseconds.",
	"Method": "long getPeriod(){\r\n    return mRecurrence.getPeriod();\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.SplitsDbAdapter.getTransactionID",
	"Comment": "returns the database record id for the specified transaction uid",
	"Method": "long getTransactionID(String transactionUID){\r\n    Cursor c = mDb.query(TransactionEntry.TABLE_NAME, new String[] { TransactionEntry._ID }, TransactionEntry.COLUMN_UID + \"=?\", new String[] { transactionUID }, null, null, null);\r\n    try {\r\n        if (c.moveToFirst()) {\r\n            return c.getLong(0);\r\n        } else {\r\n            throw new IllegalArgumentException(\"transaction \" + transactionUID + \" does not exist\");\r\n        }\r\n    } finally {\r\n        c.close();\r\n    }\r\n}"
}, {
	"Path": "ca.uhn.fhir.context.BaseRuntimeChildDatatypeDefinition.getBoundEnumType",
	"Comment": "if this child has a bound type, this method will return the enum type that\tit is bound to. otherwise, will return null.",
	"Method": "Class<? extends Enum<?>> getBoundEnumType(){\r\n    return null;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.fetchAllScheduledTransactions",
	"Comment": "fetches all recurring transactions from the database.recurring transactions are the transaction templates which have an entry in the scheduled events table",
	"Method": "Cursor fetchAllScheduledTransactions(){\r\n    SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();\r\n    queryBuilder.setTables(TransactionEntry.TABLE_NAME + \" INNER JOIN \" + ScheduledActionEntry.TABLE_NAME + \" ON \" + TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_UID + \" = \" + ScheduledActionEntry.TABLE_NAME + \".\" + ScheduledActionEntry.COLUMN_ACTION_UID);\r\n    String[] projectionIn = new String[] { TransactionEntry.TABLE_NAME + \".*\", ScheduledActionEntry.TABLE_NAME + \".\" + ScheduledActionEntry.COLUMN_UID + \" AS \" + \"origin_scheduled_action_uid\" };\r\n    String sortOrder = TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_DESCRIPTION + \" ASC\";\r\n    return queryBuilder.query(mDb, projectionIn, null, null, null, null, sortOrder);\r\n}"
}, {
	"Path": "com.google.api.client.findbugs.BetaDetector.createBugInstance",
	"Comment": "returns a new bug instance with source line and class information.",
	"Method": "BugInstance createBugInstance(String type){\r\n    return new BugInstance(this, type, NORMAL_PRIORITY).addClassAndMethod(this).addSourceLine(this);\r\n}"
}, {
	"Path": "org.gnucash.android.model.Money.isNegative",
	"Comment": "returns true if the amount held by this money object is negative",
	"Method": "boolean isNegative(){\r\n    return mAmount.compareTo(BigDecimal.ZERO) == -1;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.export.ExportFormFragment.onActivityResult",
	"Comment": "callback for when the activity chooser dialog is completed",
	"Method": "void onActivityResult(int requestCode,int resultCode,Intent data){\r\n    switch(requestCode) {\r\n        case BackupPreferenceFragment.REQUEST_RESOLVE_CONNECTION:\r\n            if (resultCode == Activity.RESULT_OK) {\r\n                BackupPreferenceFragment.mGoogleApiClient.connect();\r\n            }\r\n            break;\r\n        case REQUEST_EXPORT_FILE:\r\n            if (resultCode == Activity.RESULT_OK) {\r\n                if (data != null) {\r\n                    mExportUri = data.getData();\r\n                }\r\n                final int takeFlags = data.getFlags() & (Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\r\n                getActivity().getContentResolver().takePersistableUriPermission(mExportUri, takeFlags);\r\n                mTargetUriTextView.setText(mExportUri.toString());\r\n                if (mExportStarted)\r\n                    startExport();\r\n            }\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.db.MigrationHelper.importCommodities",
	"Comment": "imports commodities into the database from xml resource file",
	"Method": "void importCommodities(SQLiteDatabase db){\r\n    SAXParserFactory spf = SAXParserFactory.newInstance();\r\n    SAXParser sp = spf.newSAXParser();\r\n    XMLReader xr = sp.getXMLReader();\r\n    InputStream commoditiesInputStream = GnuCashApplication.getAppContext().getResources().openRawResource(R.raw.iso_4217_currencies);\r\n    BufferedInputStream bos = new BufferedInputStream(commoditiesInputStream);\r\n    CommoditiesXmlHandler handler = new CommoditiesXmlHandler(db);\r\n    xr.setContentHandler(handler);\r\n    xr.parse(new InputSource(bos));\r\n}"
}, {
	"Path": "org.gnucash.android.model.Money.negate",
	"Comment": "returns a new money object whose amount is the negated value of this object amount.\tthe original money object remains unchanged.",
	"Method": "Money negate(){\r\n    return new Money(mAmount.negate(), mCommodity);\r\n}"
}, {
	"Path": "ca.uhn.fhir.util.BundleUtil.toListOfResourcesOfType",
	"Comment": "extract all of the resources of a given type from a given bundle",
	"Method": "List<T> toListOfResourcesOfType(FhirContext theContext,IBaseBundle theBundle,Class<T> theTypeToInclude){\r\n    List<T> retVal = new ArrayList();\r\n    RuntimeResourceDefinition def = theContext.getResourceDefinition(theBundle);\r\n    BaseRuntimeChildDefinition entryChild = def.getChildByName(\"entry\");\r\n    List<IBase> entries = entryChild.getAccessor().getValues(theBundle);\r\n    BaseRuntimeElementCompositeDefinition<?> entryChildElem = (BaseRuntimeElementCompositeDefinition<?>) entryChild.getChildByName(\"entry\");\r\n    BaseRuntimeChildDefinition resourceChild = entryChildElem.getChildByName(\"resource\");\r\n    for (IBase nextEntry : entries) {\r\n        for (IBase next : resourceChild.getAccessor().getValues(nextEntry)) {\r\n            if (theTypeToInclude != null && !theTypeToInclude.isAssignableFrom(next.getClass())) {\r\n                continue;\r\n            }\r\n            retVal.add((T) next);\r\n        }\r\n    }\r\n    return retVal;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Book.setActive",
	"Comment": "sets this book as the currently active one in the application",
	"Method": "void setActive(boolean active){\r\n    mActive = active;\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.model.RecurrenceTest.testRecurrenceCountComputation",
	"Comment": "when the end date of a recurrence is set, we should be able to correctly get the number of occurrences",
	"Method": "void testRecurrenceCountComputation(){\r\n    Recurrence recurrence = new Recurrence(PeriodType.MONTH);\r\n    DateTime start = new DateTime(2015, 10, 5, 0, 0);\r\n    recurrence.setPeriodStart(new Timestamp(start.getMillis()));\r\n    DateTime end = new DateTime(2016, 8, 5, 0, 0);\r\n    recurrence.setPeriodEnd(new Timestamp(end.getMillis()));\r\n    assertThat(recurrence.getCount()).isEqualTo(10);\r\n    DateTime startTime = new DateTime(2016, 6, 6, 9, 0);\r\n    DateTime endTime = new DateTime(2016, 8, 29, 10, 0);\r\n    PeriodType biWeekly = PeriodType.WEEK;\r\n    recurrence = new Recurrence(biWeekly);\r\n    recurrence.setMultiplier(2);\r\n    recurrence.setPeriodStart(new Timestamp(startTime.getMillis()));\r\n    recurrence.setPeriodEnd(new Timestamp(endTime.getMillis()));\r\n    assertThat(recurrence.getCount()).isEqualTo(7);\r\n}"
}, {
	"Path": "ca.uhn.fhir.rest.param.DateRangeParam.setLowerBoundInclusive",
	"Comment": "sets the lower bound to be greaterthan or equal to the given date",
	"Method": "DateRangeParam setLowerBoundInclusive(Date theLowerBound){\r\n    validateAndSet(new DateParam(ParamPrefixEnum.GREATERTHAN_OR_EQUALS, theLowerBound), myUpperBound);\r\n    return this;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.TransactionDetailActivity.removeSplitItemViews",
	"Comment": "remove the split item views from the transaction detail prior to refreshing them",
	"Method": "void removeSplitItemViews(){\r\n    mDetailTableLayout.removeViews(0, mDetailTableLayout.getChildCount() - mDetailTableRows);\r\n    mDebitBalance.setText(\"\");\r\n    mCreditBalance.setText(\"\");\r\n}"
}, {
	"Path": "ca.uhn.fhir.rest.server.exceptions.BaseServerResponseException.setResponseBody",
	"Comment": "this method is currently only called internally by hapi, it should not be called by user code.",
	"Method": "void setResponseBody(String theResponseBody){\r\n    myResponseBody = theResponseBody;\r\n}"
}, {
	"Path": "com.google.api.client.http.ExponentialBackOffPolicy.getRandomizationFactor",
	"Comment": "returns the randomization factor to use for creating a range around the retry interval.a randomization factor of 0.5 results in a random period ranging between 50% below and 50«ove the retry interval.",
	"Method": "double getRandomizationFactor(double getRandomizationFactor){\r\n    return exponentialBackOff.getRandomizationFactor();\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.DatabaseAdapter.getCommodityUID",
	"Comment": "returns the commodity guid for the given iso 4217 currency code",
	"Method": "String getCommodityUID(String currencyCode){\r\n    String where = DatabaseSchema.CommodityEntry.COLUMN_MNEMONIC + \"= ?\";\r\n    String[] whereArgs = new String[] { currencyCode };\r\n    Cursor cursor = mDb.query(DatabaseSchema.CommodityEntry.TABLE_NAME, new String[] { DatabaseSchema.CommodityEntry.COLUMN_UID }, where, whereArgs, null, null, null);\r\n    try {\r\n        if (cursor.moveToNext()) {\r\n            return cursor.getString(cursor.getColumnIndexOrThrow(DatabaseSchema.CommodityEntry.COLUMN_UID));\r\n        } else {\r\n            throw new IllegalArgumentException(\"Currency code not found in commodities\");\r\n        }\r\n    } finally {\r\n        cursor.close();\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.ui.util.widget.CalculatorEditText.setCalculatorKeysLayout",
	"Comment": "sets the xml resource describing the layout of the calculator keys",
	"Method": "void setCalculatorKeysLayout(int calculatorKeysLayout){\r\n    this.mCalculatorKeysLayout = calculatorKeysLayout;\r\n    bindListeners(mCalculatorKeyboardView);\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.getExportableAccounts",
	"Comment": "returns a list of accounts which have transactions that have not been exported yet",
	"Method": "List<Account> getExportableAccounts(Timestamp lastExportTimeStamp){\r\n    LinkedList<Account> accountsList = new LinkedList();\r\n    Cursor cursor = mDb.query(TransactionEntry.TABLE_NAME + \" , \" + SplitEntry.TABLE_NAME + \" ON \" + TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_UID + \" = \" + SplitEntry.TABLE_NAME + \".\" + SplitEntry.COLUMN_TRANSACTION_UID + \" , \" + AccountEntry.TABLE_NAME + \" ON \" + AccountEntry.TABLE_NAME + \".\" + AccountEntry.COLUMN_UID + \" = \" + SplitEntry.TABLE_NAME + \".\" + SplitEntry.COLUMN_ACCOUNT_UID, new String[] { AccountEntry.TABLE_NAME + \".*\" }, TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_MODIFIED_AT + \" > ?\", new String[] { TimestampHelper.getUtcStringFromTimestamp(lastExportTimeStamp) }, AccountEntry.TABLE_NAME + \".\" + AccountEntry.COLUMN_UID, null, null);\r\n    try {\r\n        while (cursor.moveToNext()) {\r\n            accountsList.add(buildModelInstance(cursor));\r\n        }\r\n    } finally {\r\n        cursor.close();\r\n    }\r\n    return accountsList;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.getTimestamp",
	"Comment": "returns the earliest or latest timestamp of transactions for a specific account type and currency",
	"Method": "long getTimestamp(String mod,AccountType type,String currencyCode){\r\n    String sql = \"SELECT \" + mod + \"(\" + TransactionEntry.COLUMN_TIMESTAMP + \")\" + \" FROM \" + TransactionEntry.TABLE_NAME + \" INNER JOIN \" + SplitEntry.TABLE_NAME + \" ON \" + SplitEntry.TABLE_NAME + \".\" + SplitEntry.COLUMN_TRANSACTION_UID + \" = \" + TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_UID + \" INNER JOIN \" + AccountEntry.TABLE_NAME + \" ON \" + AccountEntry.TABLE_NAME + \".\" + AccountEntry.COLUMN_UID + \" = \" + SplitEntry.TABLE_NAME + \".\" + SplitEntry.COLUMN_ACCOUNT_UID + \" WHERE \" + AccountEntry.TABLE_NAME + \".\" + AccountEntry.COLUMN_TYPE + \" = ? AND \" + TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_CURRENCY + \" = ? AND \" + TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_TEMPLATE + \" = 0\";\r\n    Cursor cursor = mDb.rawQuery(sql, new String[] { type.name(), currencyCode });\r\n    long timestamp = 0;\r\n    if (cursor != null) {\r\n        if (cursor.moveToFirst()) {\r\n            timestamp = cursor.getLong(0);\r\n        }\r\n        cursor.close();\r\n    }\r\n    return timestamp;\r\n}"
}, {
	"Path": "com.google.api.client.http.GenericUrl.getFirst",
	"Comment": "returns the first query parameter value for the given query parameter name.",
	"Method": "Object getFirst(String name){\r\n    Object value = get(name);\r\n    if (value instanceof Collection<?>) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Collection<Object> collectionValue = (Collection<Object>) value;\r\n        Iterator<Object> iterator = collectionValue.iterator();\r\n        return iterator.hasNext() ? iterator.next() : null;\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.getOrCreateOpeningBalanceAccountUID",
	"Comment": "returns the unique id of the opening balance account or creates one if necessary",
	"Method": "String getOrCreateOpeningBalanceAccountUID(){\r\n    String openingBalanceAccountName = getOpeningBalanceAccountFullName();\r\n    String uid = findAccountUidByFullName(openingBalanceAccountName);\r\n    if (uid == null) {\r\n        uid = createAccountHierarchy(openingBalanceAccountName, AccountType.EQUITY);\r\n    }\r\n    return uid;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Recurrence.getPeriod",
	"Comment": "returns an approximate period for this recurrencethe period is approximate because months do not all have the same number of days,but that is assumed",
	"Method": "long getPeriod(){\r\n    long baseMillis = 0;\r\n    switch(mPeriodType) {\r\n        case HOUR:\r\n            baseMillis = RecurrenceParser.HOUR_MILLIS;\r\n            break;\r\n        case DAY:\r\n            baseMillis = RecurrenceParser.DAY_MILLIS;\r\n            break;\r\n        case WEEK:\r\n            baseMillis = RecurrenceParser.WEEK_MILLIS;\r\n            break;\r\n        case MONTH:\r\n            baseMillis = RecurrenceParser.MONTH_MILLIS;\r\n            break;\r\n        case YEAR:\r\n            baseMillis = RecurrenceParser.YEAR_MILLIS;\r\n            break;\r\n    }\r\n    return mMultiplier * baseMillis;\r\n}"
}, {
	"Path": "ca.uhn.fhir.narrative.BaseThymeleafNarrativeGenerator.setIgnoreMissingTemplates",
	"Comment": "if set to true, will return an empty narrative block for any profiles where no template is available",
	"Method": "void setIgnoreMissingTemplates(boolean theIgnoreMissingTemplates){\r\n    myIgnoreMissingTemplates = theIgnoreMissingTemplates;\r\n}"
}, {
	"Path": "com.google.api.client.http.GenericUrl.addQueryParams",
	"Comment": "adds query parameters from the provided entryset into the buffer.",
	"Method": "void addQueryParams(Set<Entry<String, Object>> entrySet,StringBuilder buf){\r\n    boolean first = true;\r\n    for (Map.Entry<String, Object> nameValueEntry : entrySet) {\r\n        Object value = nameValueEntry.getValue();\r\n        if (value != null) {\r\n            String name = CharEscapers.escapeUriQuery(nameValueEntry.getKey());\r\n            if (value instanceof Collection<?>) {\r\n                Collection<?> collectionValue = (Collection<?>) value;\r\n                for (Object repeatedValue : collectionValue) {\r\n                    first = appendParam(first, buf, name, repeatedValue);\r\n                }\r\n            } else {\r\n                first = appendParam(first, buf, name, value);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.services.AbstractGoogleClientRequest.getUriTemplate",
	"Comment": "returns the uri template for the path relative to the base url.",
	"Method": "String getUriTemplate(){\r\n    return uriTemplate;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Split.getFormattedAmount",
	"Comment": "splits are saved as absolute values to the database, with no negative numbers.the type of movement the split causes to the balance of an account determinesits sign, and that depends on the split type and the account type",
	"Method": "Money getFormattedAmount(Money amount,String accountUID,TransactionType splitType){\r\n    boolean isDebitAccount = AccountsDbAdapter.getInstance().getAccountType(accountUID).hasDebitNormalBalance();\r\n    Money absAmount = amount.abs();\r\n    boolean isDebitSplit = splitType == TransactionType.DEBIT;\r\n    if (isDebitAccount) {\r\n        if (isDebitSplit) {\r\n            return absAmount;\r\n        } else {\r\n            return absAmount.negate();\r\n        }\r\n    } else {\r\n        if (isDebitSplit) {\r\n            return absAmount.negate();\r\n        } else {\r\n            return absAmount;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.setParentAccountSelection",
	"Comment": "selects the account with id parentaccountid in the parent accounts spinner",
	"Method": "void setParentAccountSelection(long parentAccountId){\r\n    if (parentAccountId <= 0 || parentAccountId == mRootAccountId) {\r\n        return;\r\n    }\r\n    for (int pos = 0; pos < mParentAccountCursorAdapter.getCount(); pos++) {\r\n        if (mParentAccountCursorAdapter.getItemId(pos) == parentAccountId) {\r\n            mParentCheckBox.setChecked(true);\r\n            mParentAccountSpinner.setEnabled(true);\r\n            mParentAccountSpinner.setSelection(pos, true);\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.service.ScheduledActionServiceTest.setTransactionInDbModifiedTimestamp",
	"Comment": "sets the transaction modified timestamp directly in the database.",
	"Method": "void setTransactionInDbModifiedTimestamp(String transactionUID,Timestamp timestamp){\r\n    ContentValues values = new ContentValues();\r\n    values.put(DatabaseSchema.TransactionEntry.COLUMN_MODIFIED_AT, TimestampHelper.getUtcStringFromTimestamp(timestamp));\r\n    mTransactionsDbAdapter.updateTransaction(values, \"uid = ?\", new String[] { transactionUID });\r\n}"
}, {
	"Path": "io.grpc.examples.GreeterGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "GreeterStub newStub(io.grpc.Channel channel){\r\n    return new GreeterStub(channel);\r\n}"
}, {
	"Path": "com.google.api.client.util.ExponentialBackOff.getRandomizationFactor",
	"Comment": "returns the randomization factor to use for creating a range around the retry interval.a randomization factor of 0.5 results in a random period ranging between 50% below and 50«ove the retry interval.",
	"Method": "double getRandomizationFactor(double getRandomizationFactor){\r\n    return randomizationFactor;\r\n}"
}, {
	"Path": "com.google.api.client.util.Types.resolveTypeVariable",
	"Comment": "resolves the actual type of the given type variable that comes from a field type based on thegiven context list.in case the type variable can be resolved partially, it will return the partially resolved typevariable.",
	"Method": "Type resolveTypeVariable(List<Type> context,TypeVariable<?> typeVariable){\r\n    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\r\n    if (genericDeclaration instanceof Class<?>) {\r\n        Class<?> rawGenericDeclaration = (Class<?>) genericDeclaration;\r\n        int contextIndex = context.size();\r\n        ParameterizedType parameterizedType = null;\r\n        while (parameterizedType == null && --contextIndex >= 0) {\r\n            parameterizedType = getSuperParameterizedType(context.get(contextIndex), rawGenericDeclaration);\r\n        }\r\n        if (parameterizedType != null) {\r\n            TypeVariable<?>[] typeParameters = genericDeclaration.getTypeParameters();\r\n            int index = 0;\r\n            for (; index < typeParameters.length; index++) {\r\n                TypeVariable<?> typeParameter = typeParameters[index];\r\n                if (typeParameter.equals(typeVariable)) {\r\n                    break;\r\n                }\r\n            }\r\n            Type result = parameterizedType.getActualTypeArguments()[index];\r\n            if (result instanceof TypeVariable<?>) {\r\n                Type resolve = resolveTypeVariable(context, (TypeVariable<?>) result);\r\n                if (resolve != null) {\r\n                    return resolve;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.gnucash.android.db.MigrationHelper.upgradeDbToVersion14",
	"Comment": "upgrade the database to version 14this migration actually does not change anything in the databaseit moves the backup files to a new backup location which does not require sd card write permission",
	"Method": "int upgradeDbToVersion14(SQLiteDatabase db){\r\n    Log.i(DatabaseHelper.LOG_TAG, \"Upgrading database to version 14\");\r\n    int oldDbVersion = 13;\r\n    File backupFolder = new File(Exporter.BASE_FOLDER_PATH);\r\n    backupFolder.mkdir();\r\n    new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            File srcDir = new File(Exporter.LEGACY_BASE_FOLDER_PATH);\r\n            File dstDir = new File(Exporter.BASE_FOLDER_PATH);\r\n            try {\r\n                moveDirectory(srcDir, dstDir);\r\n                File readmeFile = new File(Exporter.LEGACY_BASE_FOLDER_PATH, \"README.txt\");\r\n                FileWriter writer = null;\r\n                writer = new FileWriter(readmeFile);\r\n                writer.write(\"Backup files have been moved to \" + dstDir.getPath() + \"\\nYou can now delete this folder\");\r\n                writer.flush();\r\n            } catch (IOException | IllegalArgumentException ex) {\r\n                ex.printStackTrace();\r\n                String msg = String.format(\"Error moving files from %s to %s\", srcDir.getPath(), dstDir.getPath());\r\n                Log.e(LOG_TAG, msg);\r\n                Crashlytics.log(msg);\r\n                Crashlytics.logException(ex);\r\n            }\r\n        }\r\n    }).start();\r\n    return 14;\r\n}"
}, {
	"Path": "org.gnucash.android.db.MigrationHelper.upgradeDbToVersion14",
	"Comment": "upgrade the database to version 14this migration actually does not change anything in the databaseit moves the backup files to a new backup location which does not require sd card write permission",
	"Method": "int upgradeDbToVersion14(SQLiteDatabase db){\r\n    File srcDir = new File(Exporter.LEGACY_BASE_FOLDER_PATH);\r\n    File dstDir = new File(Exporter.BASE_FOLDER_PATH);\r\n    try {\r\n        moveDirectory(srcDir, dstDir);\r\n        File readmeFile = new File(Exporter.LEGACY_BASE_FOLDER_PATH, \"README.txt\");\r\n        FileWriter writer = null;\r\n        writer = new FileWriter(readmeFile);\r\n        writer.write(\"Backup files have been moved to \" + dstDir.getPath() + \"\\nYou can now delete this folder\");\r\n        writer.flush();\r\n    } catch (IOException | IllegalArgumentException ex) {\r\n        ex.printStackTrace();\r\n        String msg = String.format(\"Error moving files from %s to %s\", srcDir.getPath(), dstDir.getPath());\r\n        Log.e(LOG_TAG, msg);\r\n        Crashlytics.log(msg);\r\n        Crashlytics.logException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.db.MigrationHelper.upgradeDbToVersion10",
	"Comment": "upgrades the database to version 10this method converts all saved scheduled export parameters to the new format using thetimestamp of last export",
	"Method": "int upgradeDbToVersion10(SQLiteDatabase db){\r\n    Log.i(DatabaseHelper.LOG_TAG, \"Upgrading database to version 9\");\r\n    int oldVersion = 9;\r\n    db.beginTransaction();\r\n    try {\r\n        Cursor cursor = db.query(ScheduledActionEntry.TABLE_NAME, new String[] { ScheduledActionEntry.COLUMN_UID, ScheduledActionEntry.COLUMN_TAG }, ScheduledActionEntry.COLUMN_TYPE + \" = ?\", new String[] { ScheduledAction.ActionType.BACKUP.name() }, null, null, null);\r\n        ContentValues contentValues = new ContentValues();\r\n        while (cursor.moveToNext()) {\r\n            String paramString = cursor.getString(cursor.getColumnIndexOrThrow(ScheduledActionEntry.COLUMN_TAG));\r\n            String[] tokens = paramString.split(\";\");\r\n            ExportParams params = new ExportParams(ExportFormat.valueOf(tokens[0]));\r\n            params.setExportTarget(ExportParams.ExportTarget.valueOf(tokens[1]));\r\n            params.setDeleteTransactionsAfterExport(Boolean.parseBoolean(tokens[3]));\r\n            boolean exportAll = Boolean.parseBoolean(tokens[2]);\r\n            if (exportAll) {\r\n                params.setExportStartTime(TimestampHelper.getTimestampFromEpochZero());\r\n            } else {\r\n                Timestamp timestamp = PreferencesHelper.getLastExportTime();\r\n                params.setExportStartTime(timestamp);\r\n            }\r\n            String uid = cursor.getString(cursor.getColumnIndexOrThrow(ScheduledActionEntry.COLUMN_UID));\r\n            contentValues.clear();\r\n            contentValues.put(ScheduledActionEntry.COLUMN_UID, uid);\r\n            contentValues.put(ScheduledActionEntry.COLUMN_TAG, params.toCsv());\r\n            db.insert(ScheduledActionEntry.TABLE_NAME, null, contentValues);\r\n        }\r\n        cursor.close();\r\n        db.setTransactionSuccessful();\r\n        oldVersion = 10;\r\n    } finally {\r\n        db.endTransaction();\r\n    }\r\n    return oldVersion;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.ScheduledActionsListFragment.getInstance",
	"Comment": "returns a new instance of the fragment for displayed the scheduled action",
	"Method": "Fragment getInstance(ScheduledAction.ActionType actionType){\r\n    ScheduledActionsListFragment fragment = new ScheduledActionsListFragment();\r\n    fragment.mActionType = actionType;\r\n    return fragment;\r\n}"
}, {
	"Path": "org.gnucash.android.db.MigrationHelper.upgradeDbToVersion11",
	"Comment": "upgrade database to version 11migrate scheduled backups and update export parameters to the new format",
	"Method": "int upgradeDbToVersion11(SQLiteDatabase db){\r\n    Log.i(DatabaseHelper.LOG_TAG, \"Upgrading database to version 9\");\r\n    int oldVersion = 10;\r\n    db.beginTransaction();\r\n    try {\r\n        Cursor cursor = db.query(ScheduledActionEntry.TABLE_NAME, null, ScheduledActionEntry.COLUMN_TYPE + \"= ?\", new String[] { ScheduledAction.ActionType.BACKUP.name() }, null, null, null);\r\n        Map<String, String> uidToTagMap = new HashMap();\r\n        while (cursor.moveToNext()) {\r\n            String uid = cursor.getString(cursor.getColumnIndexOrThrow(ScheduledActionEntry.COLUMN_UID));\r\n            String tag = cursor.getString(cursor.getColumnIndexOrThrow(ScheduledActionEntry.COLUMN_TAG));\r\n            String[] tokens = tag.split(\";\");\r\n            try {\r\n                Timestamp timestamp = TimestampHelper.getTimestampFromUtcString(tokens[2]);\r\n            } catch (IllegalArgumentException ex) {\r\n                tokens[2] = TimestampHelper.getUtcStringFromTimestamp(PreferencesHelper.getLastExportTime());\r\n            } finally {\r\n                tag = TextUtils.join(\";\", tokens);\r\n            }\r\n            uidToTagMap.put(uid, tag);\r\n        }\r\n        cursor.close();\r\n        ContentValues contentValues = new ContentValues();\r\n        for (Map.Entry<String, String> entry : uidToTagMap.entrySet()) {\r\n            contentValues.clear();\r\n            contentValues.put(ScheduledActionEntry.COLUMN_TAG, entry.getValue());\r\n            db.update(ScheduledActionEntry.TABLE_NAME, contentValues, ScheduledActionEntry.COLUMN_UID + \" = ?\", new String[] { entry.getKey() });\r\n        }\r\n        db.setTransactionSuccessful();\r\n        oldVersion = 11;\r\n    } finally {\r\n        db.endTransaction();\r\n    }\r\n    return oldVersion;\r\n}"
}, {
	"Path": "org.gnucash.android.export.xml.GncXmlExporter.exportTemplateAccounts",
	"Comment": "exports template accountstemplate accounts are just dummy accounts created for use with template transactions",
	"Method": "void exportTemplateAccounts(XmlSerializer xmlSerializer,Collection<Account> accountList){\r\n    for (Account account : accountList) {\r\n        xmlSerializer.startTag(null, GncXmlHelper.TAG_ACCOUNT);\r\n        xmlSerializer.attribute(null, GncXmlHelper.ATTR_KEY_VERSION, GncXmlHelper.BOOK_VERSION);\r\n        xmlSerializer.startTag(null, GncXmlHelper.TAG_ACCT_NAME);\r\n        xmlSerializer.text(account.getName());\r\n        xmlSerializer.endTag(null, GncXmlHelper.TAG_ACCT_NAME);\r\n        xmlSerializer.startTag(null, GncXmlHelper.TAG_ACCT_ID);\r\n        xmlSerializer.attribute(null, GncXmlHelper.ATTR_KEY_TYPE, GncXmlHelper.ATTR_VALUE_GUID);\r\n        xmlSerializer.text(account.getUID());\r\n        xmlSerializer.endTag(null, GncXmlHelper.TAG_ACCT_ID);\r\n        xmlSerializer.startTag(null, GncXmlHelper.TAG_ACCT_TYPE);\r\n        xmlSerializer.text(account.getAccountType().name());\r\n        xmlSerializer.endTag(null, GncXmlHelper.TAG_ACCT_TYPE);\r\n        xmlSerializer.startTag(null, GncXmlHelper.TAG_ACCT_COMMODITY);\r\n        xmlSerializer.startTag(null, GncXmlHelper.TAG_COMMODITY_SPACE);\r\n        xmlSerializer.text(\"template\");\r\n        xmlSerializer.endTag(null, GncXmlHelper.TAG_COMMODITY_SPACE);\r\n        xmlSerializer.startTag(null, GncXmlHelper.TAG_COMMODITY_ID);\r\n        String acctCurrencyCode = \"template\";\r\n        xmlSerializer.text(acctCurrencyCode);\r\n        xmlSerializer.endTag(null, GncXmlHelper.TAG_COMMODITY_ID);\r\n        xmlSerializer.endTag(null, GncXmlHelper.TAG_ACCT_COMMODITY);\r\n        xmlSerializer.startTag(null, GncXmlHelper.TAG_COMMODITY_SCU);\r\n        xmlSerializer.text(\"1\");\r\n        xmlSerializer.endTag(null, GncXmlHelper.TAG_COMMODITY_SCU);\r\n        if (account.getAccountType() != AccountType.ROOT && mRootTemplateAccount != null) {\r\n            xmlSerializer.startTag(null, GncXmlHelper.TAG_PARENT_UID);\r\n            xmlSerializer.attribute(null, GncXmlHelper.ATTR_KEY_TYPE, GncXmlHelper.ATTR_VALUE_GUID);\r\n            xmlSerializer.text(mRootTemplateAccount.getUID());\r\n            xmlSerializer.endTag(null, GncXmlHelper.TAG_PARENT_UID);\r\n        }\r\n        xmlSerializer.endTag(null, GncXmlHelper.TAG_ACCOUNT);\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.http.HttpHeaders.toStringValue",
	"Comment": "returns the string header value for the given header value as an object.",
	"Method": "String toStringValue(Object headerValue){\r\n    return headerValue instanceof Enum<?> ? FieldInfo.of((Enum<?>) headerValue).getName() : headerValue.toString();\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.model.ScheduledActionTest.testComputingNextScheduledExecution",
	"Comment": "checks that scheduled actions accurately compute the next run time based on the start dateand the last time the action was run",
	"Method": "void testComputingNextScheduledExecution(){\r\n    ScheduledAction scheduledAction = new ScheduledAction(ScheduledAction.ActionType.TRANSACTION);\r\n    PeriodType periodType = PeriodType.MONTH;\r\n    Recurrence recurrence = new Recurrence(periodType);\r\n    recurrence.setMultiplier(2);\r\n    DateTime startDate = new DateTime(2015, 8, 15, 12, 0);\r\n    recurrence.setPeriodStart(new Timestamp(startDate.getMillis()));\r\n    scheduledAction.setRecurrence(recurrence);\r\n    assertThat(scheduledAction.computeNextCountBasedScheduledExecutionTime()).isEqualTo(startDate.getMillis());\r\n    scheduledAction.setExecutionCount(3);\r\n    DateTime expectedTime = new DateTime(2016, 2, 15, 12, 0);\r\n    assertThat(scheduledAction.computeNextCountBasedScheduledExecutionTime()).isEqualTo(expectedTime.getMillis());\r\n}"
}, {
	"Path": "org.gnucash.android.ui.report.piechart.PieChartFragment.getEmptyData",
	"Comment": "returns a data object that represents situation when no user data available",
	"Method": "PieData getEmptyData(){\r\n    PieDataSet dataSet = new PieDataSet(null, getResources().getString(R.string.label_chart_no_data));\r\n    dataSet.addEntry(new Entry(1, 0));\r\n    dataSet.setColor(NO_DATA_COLOR);\r\n    dataSet.setDrawValues(false);\r\n    return new PieData(Collections.singletonList(\"\"), dataSet);\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.computeNextTimeBasedScheduledExecutionTime",
	"Comment": "computes the next time that this scheduled action is supposed to beexecuted based on the time of the last run.this method does not consider the end time, or number of times it should be run.it only considers when the next execution would theoretically be due.",
	"Method": "long computeNextTimeBasedScheduledExecutionTime(){\r\n    return computeNextScheduledExecutionTimeStartingAt(getLastRunTime());\r\n}"
}, {
	"Path": "org.gnucash.android.model.Book.isActive",
	"Comment": "check if this book is the currently active book in the appan active book is one whose data is currently displayed in the ui",
	"Method": "boolean isActive(){\r\n    return mActive;\r\n}"
}, {
	"Path": "com.google.api.client.util.SecurityUtils.verify",
	"Comment": "verifies the signature of signed content based on a certificate chain.",
	"Method": "boolean verify(Signature signatureAlgorithm,PublicKey publicKey,byte[] signatureBytes,byte[] contentBytes,X509Certificate verify,Signature signatureAlgorithm,X509TrustManager trustManager,List<String> certChainBase64,byte[] signatureBytes,byte[] contentBytes){\r\n    CertificateFactory certificateFactory;\r\n    try {\r\n        certificateFactory = getX509CertificateFactory();\r\n    } catch (CertificateException e) {\r\n        return null;\r\n    }\r\n    X509Certificate[] certificates = new X509Certificate[certChainBase64.size()];\r\n    int currentCert = 0;\r\n    for (String certBase64 : certChainBase64) {\r\n        byte[] certDer = Base64.decodeBase64(certBase64);\r\n        ByteArrayInputStream bis = new ByteArrayInputStream(certDer);\r\n        try {\r\n            Certificate cert = certificateFactory.generateCertificate(bis);\r\n            if (!(cert instanceof X509Certificate)) {\r\n                return null;\r\n            }\r\n            certificates[currentCert++] = (X509Certificate) cert;\r\n        } catch (CertificateException e) {\r\n            return null;\r\n        }\r\n    }\r\n    try {\r\n        trustManager.checkServerTrusted(certificates, \"RSA\");\r\n    } catch (CertificateException e) {\r\n        return null;\r\n    }\r\n    PublicKey pubKey = certificates[0].getPublicKey();\r\n    if (verify(signatureAlgorithm, pubKey, signatureBytes, contentBytes)) {\r\n        return certificates[0];\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "ca.uhn.fhir.model.primitive.InstantDt.withCurrentTime",
	"Comment": "factory method which creates a new instantdt with millisecond precision and initializes it with the\tcurrent time and the system local timezone.",
	"Method": "InstantDt withCurrentTime(){\r\n    return new InstantDt(new Date(), TemporalPrecisionEnum.MILLI, TimeZone.getDefault());\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.TransactionDetailActivity.bindViews",
	"Comment": "reads the transaction information from the database and binds it to the views",
	"Method": "void bindViews(){\r\n    TransactionsDbAdapter transactionsDbAdapter = TransactionsDbAdapter.getInstance();\r\n    Transaction transaction = transactionsDbAdapter.getRecord(mTransactionUID);\r\n    mTransactionDescription.setText(transaction.getDescription());\r\n    mTransactionAccount.setText(getString(R.string.label_inside_account_with_name, AccountsDbAdapter.getInstance().getAccountFullName(mAccountUID)));\r\n    AccountsDbAdapter accountsDbAdapter = AccountsDbAdapter.getInstance();\r\n    Money accountBalance = accountsDbAdapter.getAccountBalance(mAccountUID, -1, transaction.getTimeMillis());\r\n    TextView balanceTextView = accountBalance.isNegative() ? mDebitBalance : mCreditBalance;\r\n    TransactionsActivity.displayBalance(balanceTextView, accountBalance);\r\n    mDetailTableRows = mDetailTableLayout.getChildCount();\r\n    boolean useDoubleEntry = GnuCashApplication.isDoubleEntryEnabled();\r\n    LayoutInflater inflater = LayoutInflater.from(this);\r\n    int index = 0;\r\n    for (Split split : transaction.getSplits()) {\r\n        if (!useDoubleEntry && split.getAccountUID().equals(accountsDbAdapter.getImbalanceAccountUID(split.getValue().getCommodity()))) {\r\n            continue;\r\n        }\r\n        View view = inflater.inflate(R.layout.item_split_amount_info, mDetailTableLayout, false);\r\n        SplitAmountViewHolder viewHolder = new SplitAmountViewHolder(view, split);\r\n        mDetailTableLayout.addView(viewHolder.itemView, index++);\r\n    }\r\n    Date trnDate = new Date(transaction.getTimeMillis());\r\n    String timeAndDate = DateFormat.getDateInstance(DateFormat.FULL).format(trnDate);\r\n    mTimeAndDate.setText(timeAndDate);\r\n    if (transaction.getScheduledActionUID() != null) {\r\n        ScheduledAction scheduledAction = ScheduledActionDbAdapter.getInstance().getRecord(transaction.getScheduledActionUID());\r\n        mRecurrence.setText(scheduledAction.getRepeatString());\r\n        findViewById(R.id.row_trn_recurrence).setVisibility(View.VISIBLE);\r\n    } else {\r\n        findViewById(R.id.row_trn_recurrence).setVisibility(View.GONE);\r\n    }\r\n    if (transaction.getNote() != null && !transaction.getNote().isEmpty()) {\r\n        mNotes.setText(transaction.getNote());\r\n        findViewById(R.id.row_trn_notes).setVisibility(View.VISIBLE);\r\n    } else {\r\n        findViewById(R.id.row_trn_notes).setVisibility(View.GONE);\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.json.JsonParser.parseMap",
	"Comment": "parse a json object from the given json parser into the given destination map, optionally usingthe given parser customizer.",
	"Method": "void parseMap(Field fieldContext,Map<String, Object> destinationMap,Type valueType,ArrayList<Type> context,CustomizeJsonParser customizeParser){\r\n    JsonToken curToken = startParsingObjectOrArray();\r\n    while (curToken == JsonToken.FIELD_NAME) {\r\n        String key = getText();\r\n        nextToken();\r\n        if (customizeParser != null && customizeParser.stopAt(destinationMap, key)) {\r\n            return;\r\n        }\r\n        Object value = parseValue(fieldContext, valueType, context, destinationMap, customizeParser, true);\r\n        destinationMap.put(key, value);\r\n        curToken = nextToken();\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.batch.BatchUnparsedResponse.getFakeResponse",
	"Comment": "create a fake http response object populated with the partcontent and the statuscode.",
	"Method": "HttpResponse getFakeResponse(int statusCode,InputStream partContent,List<String> headerNames,List<String> headerValues){\r\n    HttpRequest request = new FakeResponseHttpTransport(statusCode, partContent, headerNames, headerValues).createRequestFactory().buildPostRequest(new GenericUrl(\"http://google.com/\"), null);\r\n    request.setLoggingEnabled(false);\r\n    request.setThrowExceptionOnExecuteError(false);\r\n    return request.execute();\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.BudgetsDbAdapter.fetchBudgetsForAccount",
	"Comment": "fetch all budgets which have an amount specified for the account",
	"Method": "Cursor fetchBudgetsForAccount(String accountUID){\r\n    SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();\r\n    queryBuilder.setTables(BudgetEntry.TABLE_NAME + \",\" + BudgetAmountEntry.TABLE_NAME + \" ON \" + BudgetEntry.TABLE_NAME + \".\" + BudgetEntry.COLUMN_UID + \" = \" + BudgetAmountEntry.TABLE_NAME + \".\" + BudgetAmountEntry.COLUMN_BUDGET_UID);\r\n    queryBuilder.setDistinct(true);\r\n    String[] projectionIn = new String[] { BudgetEntry.TABLE_NAME + \".*\" };\r\n    String selection = BudgetAmountEntry.TABLE_NAME + \".\" + BudgetAmountEntry.COLUMN_ACCOUNT_UID + \" = ?\";\r\n    String[] selectionArgs = new String[] { accountUID };\r\n    String sortOrder = BudgetEntry.TABLE_NAME + \".\" + BudgetEntry.COLUMN_NAME + \" ASC\";\r\n    return queryBuilder.query(mDb, projectionIn, selection, selectionArgs, null, null, sortOrder);\r\n}"
}, {
	"Path": "example.RestfulObservationResourceProvider.getResourceType",
	"Comment": "the getresourcetype method comes from iresourceprovider, and must\tbe overridden to indicate what type of resource this provider\tsupplies.",
	"Method": "Class<Patient> getResourceType(){\r\n    return Patient.class;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.TransactionFormFragment.setSplitList",
	"Comment": "called by the split editor fragment to notify of finished editing",
	"Method": "void setSplitList(List<Split> splitList){\r\n    mSplitsList = splitList;\r\n    Money balance = Transaction.computeBalance(mAccountUID, mSplitsList);\r\n    mAmountEditText.setValue(balance.asBigDecimal());\r\n    mTransactionTypeSwitch.setChecked(balance.isNegative());\r\n}"
}, {
	"Path": "org.gnucash.android.model.Account.setDefaultTransferAccountUID",
	"Comment": "set the unique id of account which is the default transfer target",
	"Method": "void setDefaultTransferAccountUID(String defaultTransferAccountUID){\r\n    this.mDefaultTransferAccountUID = defaultTransferAccountUID;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.BooksDbAdapter.getInstance",
	"Comment": "return the application instance of the books database adapter",
	"Method": "BooksDbAdapter getInstance(){\r\n    return GnuCashApplication.getBooksDbAdapter();\r\n}"
}, {
	"Path": "org.gnucash.android.export.csv.CsvWriter.writeEndToken",
	"Comment": "writes a token to the csv file and appends end of line to it.the tokennot contain the csv separator. if the separator is found in the token, thenthe token will be escaped as specified by rfc 4180",
	"Method": "void writeEndToken(String token){\r\n    if (token != null && !token.isEmpty()) {\r\n        write(escape(token));\r\n    }\r\n    this.newLine();\r\n}"
}, {
	"Path": "org.gnucash.android.test.ui.PieChartReportTest.addTransactionForPreviousMonth",
	"Comment": "add a transactions for the previous month for testing pie chart",
	"Method": "void addTransactionForPreviousMonth(int minusMonths){\r\n    Transaction transaction = new Transaction(TRANSACTION2_NAME);\r\n    transaction.setTime(new LocalDateTime().minusMonths(minusMonths).toDate().getTime());\r\n    Split split = new Split(new Money(BigDecimal.valueOf(TRANSACTION2_AMOUNT), CURRENCY), BOOKS_EXPENSE_ACCOUNT_UID);\r\n    split.setType(TransactionType.DEBIT);\r\n    transaction.addSplit(split);\r\n    transaction.addSplit(split.createPair(CASH_IN_WALLET_ASSET_ACCOUNT_UID));\r\n    mTransactionsDbAdapter.addRecord(transaction, DatabaseAdapter.UpdateMethod.insert);\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.computeNextCountBasedScheduledExecutionTime",
	"Comment": "computes the next time that this scheduled action is supposed to beexecuted based on the execution count.this method does not consider the end time, or number of times it should be run.it only considers when the next execution would theoretically be due.",
	"Method": "long computeNextCountBasedScheduledExecutionTime(){\r\n    return computeNextScheduledExecutionTimeStartingAt(getTimeOfLastSchedule());\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.DatabaseAdapter.extractBaseModelAttributes",
	"Comment": "extracts the attributes of the base model and adds them to the contentvalues object provided",
	"Method": "ContentValues extractBaseModelAttributes(ContentValues contentValues,Model model){\r\n    contentValues.put(CommonColumns.COLUMN_UID, model.getUID());\r\n    contentValues.put(CommonColumns.COLUMN_CREATED_AT, TimestampHelper.getUtcStringFromTimestamp(model.getCreatedTimestamp()));\r\n    return contentValues;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.report.ReportsOverviewFragment.getEmptyData",
	"Comment": "returns a data object that represents situation when no user data available",
	"Method": "PieData getEmptyData(){\r\n    PieDataSet dataSet = new PieDataSet(null, getResources().getString(R.string.label_chart_no_data));\r\n    dataSet.addEntry(new Entry(1, 0));\r\n    dataSet.setColor(PieChartFragment.NO_DATA_COLOR);\r\n    dataSet.setDrawValues(false);\r\n    return new PieData(Collections.singletonList(\"\"), dataSet);\r\n}"
}, {
	"Path": "com.google.api.client.util.Data.isNull",
	"Comment": "returns whether the given object is the magic object that represents the null value of itsclass.",
	"Method": "boolean isNull(Object object){\r\n    return object != null && object == NULL_CACHE.get(object.getClass());\r\n}"
}, {
	"Path": "org.gnucash.android.ui.settings.BackupPreferenceFragment.onPreferenceChange",
	"Comment": "listens for changes to the preference and sets the preference summary to the new value",
	"Method": "boolean onPreferenceChange(Preference preference,Object newValue){\r\n    preference.setSummary(newValue.toString());\r\n    if (preference.getKey().equals(getString(R.string.key_default_currency))) {\r\n        GnuCashApplication.setDefaultCurrencyCode(newValue.toString());\r\n    }\r\n    if (preference.getKey().equals(getString(R.string.key_default_export_email))) {\r\n        String emailSetting = newValue.toString();\r\n        if (emailSetting == null || emailSetting.trim().isEmpty()) {\r\n            preference.setSummary(R.string.summary_default_export_email);\r\n        }\r\n    }\r\n    if (preference.getKey().equals(getString(R.string.key_default_export_format))) {\r\n        String exportFormat = newValue.toString();\r\n        if (exportFormat == null || exportFormat.trim().isEmpty()) {\r\n            preference.setSummary(R.string.summary_default_export_format);\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.google.api.client.util.ByteStreams.limit",
	"Comment": "wraps an input stream, limiting the number of bytes which can be read.",
	"Method": "InputStream limit(InputStream in,long limit){\r\n    return new LimitedInputStream(in, limit);\r\n}"
}, {
	"Path": "ca.uhn.fhir.rest.server.exceptions.BaseServerResponseException.setOperationOutcome",
	"Comment": "sets the baseoperationoutcome resource associated with this exception. in server implementations, this is the operartionoutcome resource to include with the http response. in client\timplementations you should not call this method.",
	"Method": "void setOperationOutcome(IBaseOperationOutcome theBaseOperationOutcome){\r\n    myBaseOperationOutcome = theBaseOperationOutcome;\r\n}"
}, {
	"Path": "ca.uhn.fhir.rest.param.ParameterUtil.parseQueryParams",
	"Comment": "this is a utility method intended provided to help the jpa module.",
	"Method": "IQueryParameterAnd<?> parseQueryParams(FhirContext theContext,RestSearchParameterTypeEnum paramType,String theUnqualifiedParamName,List<QualifiedParamList> theParameters,IQueryParameterAnd<?> parseQueryParams,FhirContext theContext,RuntimeSearchParam theParamDef,String theUnqualifiedParamName,List<QualifiedParamList> theParameters){\r\n    RestSearchParameterTypeEnum paramType = theParamDef.getParamType();\r\n    return parseQueryParams(theContext, paramType, theUnqualifiedParamName, theParameters);\r\n}"
}, {
	"Path": "com.google.api.client.http.MultipartContent.setContentParts",
	"Comment": "sets the http content parts of the http multipart request, where each part is assumed to haveno http headers and no encoding.overriding is only supported for the purpose of calling the super implementation and changingthe return type, but nothing else.",
	"Method": "MultipartContent setContentParts(Collection<? extends HttpContent> contentParts){\r\n    this.parts = new ArrayList<Part>(contentParts.size());\r\n    for (HttpContent contentPart : contentParts) {\r\n        addPart(new Part(contentPart));\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.util.Utils.getDefaultJsonFactory",
	"Comment": "returns a cached default implementation of the jsonfactory interface.",
	"Method": "JsonFactory getDefaultJsonFactory(){\r\n    return JsonFactoryInstanceHolder.INSTANCE;\r\n}"
}, {
	"Path": "com.google.api.client.extensions.android.AndroidUtils.isMinimumSdkLevel",
	"Comment": "returns whether the sdk version is the given level or higher.",
	"Method": "boolean isMinimumSdkLevel(int minimumSdkLevel){\r\n    return Build.VERSION.SDK_INT >= minimumSdkLevel;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.initializeViewsWithAccount",
	"Comment": "initialize view with the properties of account.this is applicable when editing an account",
	"Method": "void initializeViewsWithAccount(Account account){\r\n    if (account == null)\r\n        throw new IllegalArgumentException(\"Account cannot be null\");\r\n    loadParentAccountList(account.getAccountType());\r\n    mParentAccountUID = account.getParentUID();\r\n    if (mParentAccountUID == null) {\r\n        mParentAccountUID = mRootAccountUID;\r\n    }\r\n    if (mParentAccountUID != null) {\r\n        setParentAccountSelection(mAccountsDbAdapter.getID(mParentAccountUID));\r\n    }\r\n    String currencyCode = account.getCommodity().getCurrencyCode();\r\n    setSelectedCurrency(currencyCode);\r\n    if (mAccountsDbAdapter.getTransactionMaxSplitNum(mAccount.getUID()) > 1) {\r\n        mCurrencySpinner.setEnabled(false);\r\n    }\r\n    mNameEditText.setText(account.getName());\r\n    mNameEditText.setSelection(mNameEditText.getText().length());\r\n    mDescriptionEditText.setText(account.getDescription());\r\n    if (mUseDoubleEntry) {\r\n        if (account.getDefaultTransferAccountUID() != null) {\r\n            long doubleDefaultAccountId = mAccountsDbAdapter.getID(account.getDefaultTransferAccountUID());\r\n            setDefaultTransferAccountSelection(doubleDefaultAccountId, true);\r\n        } else {\r\n            String currentAccountUID = account.getParentUID();\r\n            String rootAccountUID = mAccountsDbAdapter.getOrCreateGnuCashRootAccountUID();\r\n            while (!currentAccountUID.equals(rootAccountUID)) {\r\n                long defaultTransferAccountID = mAccountsDbAdapter.getDefaultTransferAccountID(mAccountsDbAdapter.getID(currentAccountUID));\r\n                if (defaultTransferAccountID > 0) {\r\n                    setDefaultTransferAccountSelection(defaultTransferAccountID, false);\r\n                    break;\r\n                }\r\n                currentAccountUID = mAccountsDbAdapter.getParentAccountUID(currentAccountUID);\r\n            }\r\n        }\r\n    }\r\n    mPlaceholderCheckBox.setChecked(account.isPlaceholderAccount());\r\n    mSelectedColor = account.getColor();\r\n    mColorSquare.setBackgroundColor(account.getColor());\r\n    setAccountTypeSelection(account.getAccountType());\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.DatabaseAdapter.getRecordsCount",
	"Comment": "returns the number of records in the database table backed by this adapter",
	"Method": "long getRecordsCount(){\r\n    String sql = \"SELECT COUNT(*) FROM \" + mTableName;\r\n    SQLiteStatement statement = mDb.compileStatement(sql);\r\n    return statement.simpleQueryForLong();\r\n}"
}, {
	"Path": "ca.uhn.fhir.rest.param.ParameterUtil.escape",
	"Comment": "escapes a string according to the rules for parameter escaping specified in the fhir specification escaping\tsection",
	"Method": "String escape(String theValue){\r\n    if (theValue == null) {\r\n        return null;\r\n    }\r\n    StringBuilder b = new StringBuilder();\r\n    for (int i = 0; i < theValue.length(); i++) {\r\n        char next = theValue.charAt(i);\r\n        switch(next) {\r\n            case '$':\r\n            case ',':\r\n            case '|':\r\n            case '\\\\':\r\n                b.append('\\\\');\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        b.append(next);\r\n    }\r\n    return b.toString();\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.ScheduledActionsListFragment.refreshList",
	"Comment": "reload the list of transactions and recompute account balances",
	"Method": "void refreshList(){\r\n    getLoaderManager().restartLoader(0, null, this);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.TransactionFormFragment.splitEditorUsed",
	"Comment": "checks whether the split editor has been used for editing this transaction.the split editor is considered to have been used if the transaction type switch is not visible",
	"Method": "boolean splitEditorUsed(){\r\n    return mTransactionTypeSwitch.getVisibility() != View.VISIBLE;\r\n}"
}, {
	"Path": "com.google.api.client.util.PemReader.readFirstSectionAndClose",
	"Comment": "reads the first section in the pem file, optionally based on a title to look for, and thencloses the reader.",
	"Method": "Section readFirstSectionAndClose(Reader reader,Section readFirstSectionAndClose,Reader reader,String titleToLookFor){\r\n    PemReader pemReader = new PemReader(reader);\r\n    try {\r\n        return pemReader.readNextSection(titleToLookFor);\r\n    } finally {\r\n        pemReader.close();\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.ui.colorpicker.ColorStateDrawable.getPressedColor",
	"Comment": "given a particular color, adjusts its value by a multiplier.",
	"Method": "int getPressedColor(int color){\r\n    float[] hsv = new float[3];\r\n    Color.colorToHSV(color, hsv);\r\n    hsv[2] = hsv[2] * PRESSED_STATE_MULTIPLIER;\r\n    return Color.HSVToColor(hsv);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.loadDefaultTransferAccountList",
	"Comment": "initializes the default transfer account spinner with eligible accounts",
	"Method": "void loadDefaultTransferAccountList(){\r\n    // when creating a new account mAccountUID is null, so don't use whereArgs\r\n    String condition = DatabaseSchema.AccountEntry.COLUMN_UID + \" != '\" + mAccountUID + \"' \" + \" AND \" + DatabaseSchema.AccountEntry.COLUMN_PLACEHOLDER + \"=0\" + \" AND \" + DatabaseSchema.AccountEntry.COLUMN_HIDDEN + \"=0\" + \" AND \" + DatabaseSchema.AccountEntry.COLUMN_TYPE + \" != ?\";\r\n    Cursor defaultTransferAccountCursor = mAccountsDbAdapter.fetchAccountsOrderedByFullName(condition, new String[] { AccountType.ROOT.name() });\r\n    if (mDefaultTransferAccountSpinner.getCount() <= 0) {\r\n        setDefaultTransferAccountInputsVisible(false);\r\n    }\r\n    mDefaultTransferAccountCursorAdapter = new QualifiedAccountNameCursorAdapter(getActivity(), defaultTransferAccountCursor);\r\n    mDefaultTransferAccountSpinner.setAdapter(mDefaultTransferAccountCursorAdapter);\r\n}"
}, {
	"Path": "com.google.api.client.testing.util.TestableByteArrayOutputStream.getBuffer",
	"Comment": "returns the written buffer value as a modifiable byte array.",
	"Method": "byte[] getBuffer(){\r\n    return buf;\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.services.AbstractGoogleClientRequest.buildHttpRequest",
	"Comment": "create a request suitable for use against this service.subclasses may override by calling the super implementation.",
	"Method": "HttpRequest buildHttpRequest(HttpRequest buildHttpRequest,boolean usingHead){\r\n    Preconditions.checkArgument(uploader == null);\r\n    Preconditions.checkArgument(!usingHead || requestMethod.equals(HttpMethods.GET));\r\n    String requestMethodToUse = usingHead ? HttpMethods.HEAD : requestMethod;\r\n    final HttpRequest httpRequest = getAbstractGoogleClient().getRequestFactory().buildRequest(requestMethodToUse, buildHttpRequestUrl(), httpContent);\r\n    new MethodOverride().intercept(httpRequest);\r\n    httpRequest.setParser(getAbstractGoogleClient().getObjectParser());\r\n    if (httpContent == null && (requestMethod.equals(HttpMethods.POST) || requestMethod.equals(HttpMethods.PUT) || requestMethod.equals(HttpMethods.PATCH))) {\r\n        httpRequest.setContent(new EmptyContent());\r\n    }\r\n    httpRequest.getHeaders().putAll(requestHeaders);\r\n    if (!disableGZipContent) {\r\n        httpRequest.setEncoding(new GZipEncoding());\r\n    }\r\n    final HttpResponseInterceptor responseInterceptor = httpRequest.getResponseInterceptor();\r\n    httpRequest.setResponseInterceptor(new HttpResponseInterceptor() {\r\n        public void interceptResponse(HttpResponse response) throws IOException {\r\n            if (responseInterceptor != null) {\r\n                responseInterceptor.interceptResponse(response);\r\n            }\r\n            if (!response.isSuccessStatusCode() && httpRequest.getThrowExceptionOnExecuteError()) {\r\n                throw newExceptionOnError(response);\r\n            }\r\n        }\r\n    });\r\n    return httpRequest;\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.services.AbstractGoogleClientRequest.buildHttpRequest",
	"Comment": "create a request suitable for use against this service.subclasses may override by calling the super implementation.",
	"Method": "HttpRequest buildHttpRequest(HttpRequest buildHttpRequest,boolean usingHead){\r\n    if (responseInterceptor != null) {\r\n        responseInterceptor.interceptResponse(response);\r\n    }\r\n    if (!response.isSuccessStatusCode() && httpRequest.getThrowExceptionOnExecuteError()) {\r\n        throw newExceptionOnError(response);\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.xml.Xml.parseNamespacesForElement",
	"Comment": "parses the namespaces declared on the current element into the namespace dictionary.",
	"Method": "void parseNamespacesForElement(XmlPullParser parser,XmlNamespaceDictionary namespaceDictionary){\r\n    int eventType = parser.getEventType();\r\n    Preconditions.checkState(eventType == XmlPullParser.START_TAG, \"expected start of XML element, but got something else (event type %s)\", eventType);\r\n    int depth = parser.getDepth();\r\n    int nsStart = parser.getNamespaceCount(depth - 1);\r\n    int nsEnd = parser.getNamespaceCount(depth);\r\n    for (int i = nsStart; i < nsEnd; i++) {\r\n        String namespace = parser.getNamespaceUri(i);\r\n        if (namespaceDictionary.getAliasForUri(namespace) == null) {\r\n            String prefix = parser.getNamespacePrefix(i);\r\n            String originalAlias = prefix == null ? \"\" : prefix;\r\n            String alias = originalAlias;\r\n            int suffix = 1;\r\n            while (namespaceDictionary.getUriForAlias(alias) != null) {\r\n                suffix++;\r\n                alias = originalAlias + suffix;\r\n            }\r\n            namespaceDictionary.set(alias, namespace);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.notifications.NotificationUtils.randomUuidString",
	"Comment": "returns a new random uuid string to be used as a notification channel id.",
	"Method": "String randomUuidString(){\r\n    return UUID.randomUUID().toString();\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.media.MediaHttpUploader.executeUploadInitiation",
	"Comment": "this method sends a post request with empty content to get the unique upload url.",
	"Method": "HttpResponse executeUploadInitiation(GenericUrl initiationRequestUrl){\r\n    updateStateAndNotifyListener(UploadState.INITIATION_STARTED);\r\n    initiationRequestUrl.put(\"uploadType\", \"resumable\");\r\n    HttpContent content = metadata == null ? new EmptyContent() : metadata;\r\n    HttpRequest request = requestFactory.buildRequest(initiationRequestMethod, initiationRequestUrl, content);\r\n    initiationHeaders.set(CONTENT_TYPE_HEADER, mediaContent.getType());\r\n    if (isMediaLengthKnown()) {\r\n        initiationHeaders.set(CONTENT_LENGTH_HEADER, getMediaContentLength());\r\n    }\r\n    request.getHeaders().putAll(initiationHeaders);\r\n    HttpResponse response = executeCurrentRequest(request);\r\n    boolean notificationCompleted = false;\r\n    try {\r\n        updateStateAndNotifyListener(UploadState.INITIATION_COMPLETE);\r\n        notificationCompleted = true;\r\n    } finally {\r\n        if (!notificationCompleted) {\r\n            response.disconnect();\r\n        }\r\n    }\r\n    return response;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountsActivity.createDefaultAccounts",
	"Comment": "creates default accounts with the specified currency code.if the currency parameter is null, then locale currency will be used if available",
	"Method": "void createDefaultAccounts(String currencyCode,Activity activity){\r\n    TaskDelegate delegate = null;\r\n    if (currencyCode != null) {\r\n        delegate = new TaskDelegate() {\r\n            @Override\r\n            public void onTaskComplete() {\r\n                AccountsDbAdapter.getInstance().updateAllAccounts(DatabaseSchema.AccountEntry.COLUMN_CURRENCY, currencyCode);\r\n                GnuCashApplication.setDefaultCurrencyCode(currencyCode);\r\n            }\r\n        };\r\n    }\r\n    Uri uri = Uri.parse(\"android.resource://\" + BuildConfig.APPLICATION_ID + \"/\" + R.raw.default_accounts);\r\n    new ImportAsyncTask(activity, delegate).execute(uri);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountsActivity.createDefaultAccounts",
	"Comment": "creates default accounts with the specified currency code.if the currency parameter is null, then locale currency will be used if available",
	"Method": "void createDefaultAccounts(String currencyCode,Activity activity){\r\n    AccountsDbAdapter.getInstance().updateAllAccounts(DatabaseSchema.AccountEntry.COLUMN_CURRENCY, currencyCode);\r\n    GnuCashApplication.setDefaultCurrencyCode(currencyCode);\r\n}"
}, {
	"Path": "com.google.api.client.http.HttpHeaders.getHeaderStringValues",
	"Comment": "returns an unmodifiable list of the header string values for the given header name.",
	"Method": "List<String> getHeaderStringValues(String name){\r\n    Object value = get(name.toLowerCase(Locale.US));\r\n    if (value == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    Class<? extends Object> valueClass = value.getClass();\r\n    if (value instanceof Iterable<?> || valueClass.isArray()) {\r\n        List<String> values = new ArrayList<String>();\r\n        for (Object repeatedValue : Types.iterableOf(value)) {\r\n            values.add(toStringValue(repeatedValue));\r\n        }\r\n        return Collections.unmodifiableList(values);\r\n    }\r\n    return Collections.singletonList(toStringValue(value));\r\n}"
}, {
	"Path": "org.gnucash.android.ui.report.ReportsActivity.loadFragment",
	"Comment": "load the provided fragment into the view replacing the previous one",
	"Method": "void loadFragment(BaseReportFragment fragment){\r\n    FragmentManager fragmentManager = getSupportFragmentManager();\r\n    FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\r\n    fragmentTransaction.replace(R.id.fragment_container, fragment);\r\n    fragmentTransaction.commit();\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.service.ScheduledActionServiceTest.recurringTransactions_shouldHaveScheduledActionUID",
	"Comment": "test that only scheduled actions with action uids are processed",
	"Method": "void recurringTransactions_shouldHaveScheduledActionUID(){\r\n    ScheduledAction scheduledAction = new ScheduledAction(ScheduledAction.ActionType.TRANSACTION);\r\n    DateTime startTime = new DateTime(2016, 7, 4, 12, 0);\r\n    scheduledAction.setStartTime(startTime.getMillis());\r\n    scheduledAction.setRecurrence(PeriodType.MONTH, 1);\r\n    TransactionsDbAdapter transactionsDbAdapter = TransactionsDbAdapter.getInstance();\r\n    assertThat(transactionsDbAdapter.getRecordsCount()).isZero();\r\n    List<ScheduledAction> actions = new ArrayList();\r\n    actions.add(scheduledAction);\r\n    ScheduledActionService.processScheduledActions(actions, mDb);\r\n    assertThat(transactionsDbAdapter.getRecordsCount()).isZero();\r\n}"
}, {
	"Path": "ca.uhn.fhir.jpa.demo.FhirServerConfig.daoConfig",
	"Comment": "configure fhir properties around the the jpa server via this bean",
	"Method": "DaoConfig daoConfig(){\r\n    DaoConfig retVal = new DaoConfig();\r\n    retVal.setSubscriptionEnabled(true);\r\n    retVal.setSubscriptionPollDelay(5000);\r\n    retVal.setSubscriptionPurgeInactiveAfterMillis(DateUtils.MILLIS_PER_HOUR);\r\n    retVal.setAllowMultipleDelete(true);\r\n    return retVal;\r\n}"
}, {
	"Path": "org.gnucash.android.export.csv.CsvWriter.writeToken",
	"Comment": "writes a csv token and the separator to the underlying output stream.the tokennot contain the csv separator. if the separator is found in the token, thenthe token will be escaped as specified by rfc 4180",
	"Method": "void writeToken(String token){\r\n    if (token == null || token.isEmpty()) {\r\n        write(separator);\r\n    } else {\r\n        token = escape(token);\r\n        write(token + separator);\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.ui.util.widget.CalculatorEditText.getCalculatorKeysLayout",
	"Comment": "returns the xml resource id describing the calculator keys layout",
	"Method": "int getCalculatorKeysLayout(){\r\n    return mCalculatorKeysLayout;\r\n}"
}, {
	"Path": "com.google.api.client.util.Base64.encodeBase64",
	"Comment": "encodes binary data using the base64 algorithm but does not chunk the output.",
	"Method": "byte[] encodeBase64(byte[] binaryData){\r\n    return org.apache.commons.codec.binary.Base64.encodeBase64(binaryData);\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.getSubAccountCount",
	"Comment": "returns the number of accounts for which the account with id accoundid is a first level parent",
	"Method": "int getSubAccountCount(String accountUID){\r\n    String queryCount = \"SELECT COUNT(*) FROM \" + AccountEntry.TABLE_NAME + \" WHERE \" + AccountEntry.COLUMN_PARENT_ACCOUNT_UID + \" = ?\";\r\n    Cursor cursor = mDb.rawQuery(queryCount, new String[] { accountUID });\r\n    cursor.moveToFirst();\r\n    int count = cursor.getInt(0);\r\n    cursor.close();\r\n    return count;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Account.setHidden",
	"Comment": "toggles the hidden property of the account.hidden accounts are not visible in the ui",
	"Method": "void setHidden(boolean hidden){\r\n    this.mIsHidden = hidden;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Money.withCurrency",
	"Comment": "returns a new money object the currency specified by currency \tand the same value as this one. no value exchange between the currencies is performed.",
	"Method": "Money withCurrency(Commodity commodity){\r\n    return new Money(mAmount, commodity);\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.isFavoriteAccount",
	"Comment": "returns true if the account is a favorite account, false otherwise",
	"Method": "boolean isFavoriteAccount(String accountUID){\r\n    String isFavorite = getAttribute(accountUID, AccountEntry.COLUMN_FAVORITE);\r\n    return Integer.parseInt(isFavorite) == 1;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.getTimestampOfLatestTransaction",
	"Comment": "returns a timestamp of the latest transaction for a specified account type and currency",
	"Method": "long getTimestampOfLatestTransaction(AccountType type,String currencyCode){\r\n    return getTimestamp(\"MAX\", type, currencyCode);\r\n}"
}, {
	"Path": "com.google.api.client.util.ArrayMap.set",
	"Comment": "sets the value at the given index, overriding any existing value mapping.",
	"Method": "V set(int index,K key,V value,V set,int index,V value){\r\n    int size = this.size;\r\n    if (index < 0 || index >= size) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    int valueDataIndex = 1 + (index << 1);\r\n    V result = valueAtDataIndex(valueDataIndex);\r\n    this.data[valueDataIndex] = value;\r\n    return result;\r\n}"
}, {
	"Path": "net.glowstone.TestUtils.checkInventory",
	"Comment": "asserts that exactly the expected number of items matching a predicate are in the giveninventory, summed across all stacks.",
	"Method": "void checkInventory(Inventory inventory,int expectedMatches,Predicate<ItemStack> filter){\r\n    int matches = 0;\r\n    for (ItemStack item : inventory.getContents()) {\r\n        if (item != null && filter.test(item)) {\r\n            matches += item.getAmount();\r\n        }\r\n    }\r\n    assertEquals(String.format(\"Expected exactly %d items but found %d, matching {%s}\", expectedMatches, matches, filter), expectedMatches, matches);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.loadParentAccountList",
	"Comment": "loads the list of possible accounts which can be set as a parent account and initializes the spinner.the allowed parent accounts depends on the account type",
	"Method": "void loadParentAccountList(AccountType accountType){\r\n    String condition = DatabaseSchema.SplitEntry.COLUMN_TYPE + \" IN (\" + getAllowedParentAccountTypes(accountType) + \") AND \" + DatabaseSchema.AccountEntry.COLUMN_HIDDEN + \"!=1 \";\r\n    if (mAccount != null) {\r\n        mDescendantAccountUIDs = mAccountsDbAdapter.getDescendantAccountUIDs(mAccount.getUID(), null, null);\r\n        String rootAccountUID = mAccountsDbAdapter.getOrCreateGnuCashRootAccountUID();\r\n        List<String> descendantAccountUIDs = new ArrayList(mDescendantAccountUIDs);\r\n        if (rootAccountUID != null)\r\n            descendantAccountUIDs.add(rootAccountUID);\r\n        condition += \" AND (\" + DatabaseSchema.AccountEntry.COLUMN_UID + \" NOT IN ( '\" + TextUtils.join(\"','\", descendantAccountUIDs) + \"','\" + mAccountUID + \"' ) )\";\r\n    }\r\n    if (mParentAccountCursor != null)\r\n        mParentAccountCursor.close();\r\n    mParentAccountCursor = mAccountsDbAdapter.fetchAccountsOrderedByFullName(condition, null);\r\n    final View view = getView();\r\n    assert view != null;\r\n    if (mParentAccountCursor.getCount() <= 0) {\r\n        mParentCheckBox.setChecked(false);\r\n        view.findViewById(R.id.layout_parent_account).setVisibility(View.GONE);\r\n        view.findViewById(R.id.label_parent_account).setVisibility(View.GONE);\r\n    } else {\r\n        view.findViewById(R.id.layout_parent_account).setVisibility(View.VISIBLE);\r\n        view.findViewById(R.id.label_parent_account).setVisibility(View.VISIBLE);\r\n    }\r\n    mParentAccountCursorAdapter = new QualifiedAccountNameCursorAdapter(getActivity(), mParentAccountCursor);\r\n    mParentAccountSpinner.setAdapter(mParentAccountCursorAdapter);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.common.FormActivity.showFormFragment",
	"Comment": "loads the fragment into the fragment container, replacing whatever was there before",
	"Method": "void showFormFragment(Fragment fragment){\r\n    FragmentManager fragmentManager = getSupportFragmentManager();\r\n    FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\r\n    fragmentTransaction.add(R.id.fragment_container, fragment);\r\n    fragmentTransaction.commit();\r\n}"
}, {
	"Path": "org.gnucash.android.ui.common.FormActivity.getCurrentAccountUID",
	"Comment": "return the guid of the account for which the form is displayed.if the form is a transaction form, the transaction is created within that account. if it isan account form, then the guid is the parent account",
	"Method": "String getCurrentAccountUID(){\r\n    return mAccountUID;\r\n}"
}, {
	"Path": "ca.uhn.fhir.context.FhirContext.setParserOptions",
	"Comment": "sets the parser options object which will be used to supply default\toptions to newly created parsers",
	"Method": "void setParserOptions(ParserOptions theParserOptions){\r\n    Validate.notNull(theParserOptions, \"theParserOptions must not be null\");\r\n    myParserOptions = theParserOptions;\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.getTemplateAccountUID",
	"Comment": "return the template account guid for this scheduled actionthis method generates one if none was set",
	"Method": "String getTemplateAccountUID(){\r\n    if (mTemplateAccountUID == null)\r\n        return mTemplateAccountUID = generateUID();\r\n    else\r\n        return mTemplateAccountUID;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.fetchAccounts",
	"Comment": "returns a cursor set of accounts which fulfill whereand ordered by orderby",
	"Method": "Cursor fetchAccounts(String where,String[] whereArgs,String orderBy){\r\n    if (orderBy == null) {\r\n        orderBy = AccountEntry.COLUMN_NAME + \" ASC\";\r\n    }\r\n    Log.v(LOG_TAG, \"Fetching all accounts from db where \" + where + \" order by \" + orderBy);\r\n    return mDb.query(AccountEntry.TABLE_NAME, null, where, whereArgs, null, null, orderBy);\r\n}"
}, {
	"Path": "org.gnucash.android.export.ExportAsyncTask.moveExportToSDCard",
	"Comment": "moves the exported files from the internal storage where they are generated toexternal storage, which is accessible to the user.",
	"Method": "List<String> moveExportToSDCard(){\r\n    Log.i(TAG, \"Moving exported file to external storage\");\r\n    new File(Exporter.getExportFolderPath(mExporter.mBookUID));\r\n    List<String> dstFiles = new ArrayList();\r\n    for (String src : mExportedFiles) {\r\n        String dst = Exporter.getExportFolderPath(mExporter.mBookUID) + stripPathPart(src);\r\n        try {\r\n            org.gnucash.android.util.FileUtils.moveFile(src, dst);\r\n            dstFiles.add(dst);\r\n        } catch (IOException e) {\r\n            throw new Exporter.ExporterException(mExportParams, e);\r\n        }\r\n    }\r\n    return dstFiles;\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.services.AbstractGoogleClientRequest.initializeMediaUpload",
	"Comment": "initializes the media http uploader based on the media content.",
	"Method": "void initializeMediaUpload(AbstractInputStreamContent mediaContent){\r\n    HttpRequestFactory requestFactory = abstractGoogleClient.getRequestFactory();\r\n    this.uploader = new MediaHttpUploader(mediaContent, requestFactory.getTransport(), requestFactory.getInitializer());\r\n    this.uploader.setInitiationRequestMethod(requestMethod);\r\n    if (httpContent != null) {\r\n        this.uploader.setMetadata(httpContent);\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.json.webtoken.JsonWebToken.getPayload",
	"Comment": "returns the payload.overriding is only supported for the purpose of calling the super implementation and changingthe return type, but nothing else.",
	"Method": "Payload getPayload(){\r\n    return payload;\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.shouldAutoCreate",
	"Comment": "returns flag if transactions should be automatically created or notthis flag is currently unused in the app. it is only included here for compatibility with gnucash desktop xml",
	"Method": "boolean shouldAutoCreate(){\r\n    return mAutoCreate;\r\n}"
}, {
	"Path": "org.gnucash.android.export.Exporter.sanitizeFilename",
	"Comment": "strings a string of any characters not allowed in a file name.all unallowed characters are replaced with an underscore",
	"Method": "String sanitizeFilename(String inputName){\r\n    return inputName.replaceAll(\"[^a-zA-Z0-9-_\\\\.]\", \"_\");\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.media.MediaHttpDownloader.updateStateAndNotifyListener",
	"Comment": "sets the download state and notifies the progress listener.",
	"Method": "void updateStateAndNotifyListener(DownloadState downloadState){\r\n    this.downloadState = downloadState;\r\n    if (progressListener != null) {\r\n        progressListener.progressChanged(this);\r\n    }\r\n}"
}, {
	"Path": "io.grpc.examples.CalculatorGrpc.newStub",
	"Comment": "creates a new async stub that supports all call types for the service",
	"Method": "CalculatorStub newStub(io.grpc.Channel channel){\r\n    return new CalculatorStub(channel);\r\n}"
}, {
	"Path": "org.gnucash.android.model.Transaction.addSplit",
	"Comment": "add a split to the transaction.sets the split uid and currency to that of this transaction",
	"Method": "void addSplit(Split split){\r\n    split.setTransactionUID(getUID());\r\n    mSplitList.add(split);\r\n}"
}, {
	"Path": "ca.uhn.fhir.model.primitive.IdDt.getIdPartAsBigDecimal",
	"Comment": "returns the unqualified portion of this id as a big decimal, or null if the value is null",
	"Method": "BigDecimal getIdPartAsBigDecimal(){\r\n    String val = getIdPart();\r\n    if (isBlank(val)) {\r\n        return null;\r\n    }\r\n    return new BigDecimal(val);\r\n}"
}, {
	"Path": "ca.uhn.fhir.rest.server.exceptions.BaseServerResponseException.getResponseBody",
	"Comment": "in a restful client, this method will be populated with the body of the http respone if one was provided by the server, or null otherwise.\tin a restful server, this method is currently ignored.",
	"Method": "String getResponseBody(){\r\n    return myResponseBody;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Account.isHidden",
	"Comment": "returns the hidden property of this account.hidden accounts are not visible in the ui",
	"Method": "boolean isHidden(){\r\n    return mIsHidden;\r\n}"
}, {
	"Path": "ca.uhn.fhir.jpa.demo.FhirServerConfigDstu2.responseHighlighterInterceptor",
	"Comment": "this interceptor adds some pretty syntax highlighting in responses when a browser is detected",
	"Method": "IServerInterceptor responseHighlighterInterceptor(){\r\n    return FhirServerConfigCommon.getResponseHighlighterInterceptor();\r\n}"
}, {
	"Path": "org.gnucash.android.ui.homescreen.WidgetConfigurationActivity.removeWidgetConfiguration",
	"Comment": "remove the configuration for a widget. primarily this should be called when a widget is\tdestroyed.",
	"Method": "void removeWidgetConfiguration(Context context,int appWidgetId){\r\n    context.getSharedPreferences(\"widget:\" + appWidgetId, MODE_PRIVATE).edit().clear().apply();\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.getCommoditiesInUse",
	"Comment": "returns the list of commodities in use in the database.this is not the same as the list of all available commodities.",
	"Method": "List<Commodity> getCommoditiesInUse(){\r\n    Cursor cursor = mDb.query(true, AccountEntry.TABLE_NAME, new String[] { AccountEntry.COLUMN_CURRENCY }, null, null, null, null, null, null);\r\n    List<Commodity> commodityList = new ArrayList();\r\n    try {\r\n        while (cursor.moveToNext()) {\r\n            String currencyCode = cursor.getString(cursor.getColumnIndexOrThrow(AccountEntry.COLUMN_CURRENCY));\r\n            commodityList.add(mCommoditiesDbAdapter.getCommodity(currencyCode));\r\n        }\r\n    } finally {\r\n        cursor.close();\r\n    }\r\n    return commodityList;\r\n}"
}, {
	"Path": "com.google.api.client.http.HttpRequestFactory.buildRequest",
	"Comment": "builds a request for the given http method, url, and content.",
	"Method": "HttpRequest buildRequest(String requestMethod,GenericUrl url,HttpContent content){\r\n    HttpRequest request = transport.buildRequest();\r\n    if (initializer != null) {\r\n        initializer.initialize(request);\r\n    }\r\n    request.setRequestMethod(requestMethod);\r\n    if (url != null) {\r\n        request.setUrl(url);\r\n    }\r\n    if (content != null) {\r\n        request.setContent(content);\r\n    }\r\n    return request;\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.setAdvanceNotifyDays",
	"Comment": "set number of days in advance to notify of scheduled transactionsthis flag is currently unused in the app. it is only included here for compatibility with gnucash desktop xml",
	"Method": "void setAdvanceNotifyDays(int advanceNotifyDays){\r\n    this.mAdvanceNotifyDays = advanceNotifyDays;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Commodity.getInstance",
	"Comment": "returns an instance of commodity for the specified currencycode",
	"Method": "Commodity getInstance(String currencyCode){\r\n    switch(currencyCode) {\r\n        case \"USD\":\r\n            return USD;\r\n        case \"EUR\":\r\n            return EUR;\r\n        case \"GBP\":\r\n            return GBP;\r\n        case \"CHF\":\r\n            return CHF;\r\n        case \"JPY\":\r\n            return JPY;\r\n        case \"AUD\":\r\n            return AUD;\r\n        case \"CAD\":\r\n            return CAD;\r\n        default:\r\n            return CommoditiesDbAdapter.getInstance().getCommodity(currencyCode);\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.ui.util.widget.CalculatorEditText.setCommodity",
	"Comment": "sets the commodity to use for calculationsthe commodity determines the number of decimal places used",
	"Method": "void setCommodity(Commodity commodity){\r\n    this.mCommodity = commodity;\r\n}"
}, {
	"Path": "org.gnucash.android.db.DatabaseCursorLoader.onReleaseResources",
	"Comment": "helper function to take care of releasing resources associatedwith an actively loaded data set.",
	"Method": "void onReleaseResources(Cursor c){\r\n    if (c != null)\r\n        c.close();\r\n}"
}, {
	"Path": "org.gnucash.android.ui.homescreen.WidgetConfigurationActivity.loadOldPreferences",
	"Comment": "load obsolete preferences for a widget, if they exist, and save them using the new widget\tconfiguration format.",
	"Method": "void loadOldPreferences(Context context,int appWidgetId){\r\n    SharedPreferences preferences = PreferenceActivity.getActiveBookSharedPreferences();\r\n    String accountUID = preferences.getString(UxArgument.SELECTED_ACCOUNT_UID + appWidgetId, null);\r\n    if (accountUID != null) {\r\n        String bookUID = BooksDbAdapter.getInstance().getActiveBookUID();\r\n        boolean hideAccountBalance = preferences.getBoolean(UxArgument.HIDE_ACCOUNT_BALANCE_IN_WIDGET + appWidgetId, false);\r\n        configureWidget(context, appWidgetId, bookUID, accountUID, hideAccountBalance);\r\n        preferences.edit().remove(UxArgument.SELECTED_ACCOUNT_UID + appWidgetId).remove(UxArgument.HIDE_ACCOUNT_BALANCE_IN_WIDGET + appWidgetId).apply();\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.model.Account.setPlaceHolderFlag",
	"Comment": "sets the placeholder flag for this account.placeholder accounts cannot have transactions",
	"Method": "void setPlaceHolderFlag(boolean isPlaceholder){\r\n    mIsPlaceholderAccount = isPlaceholder;\r\n}"
}, {
	"Path": "com.google.api.client.http.MultipartContent.setParts",
	"Comment": "sets the parts of the http multipart request.overriding is only supported for the purpose of calling the super implementation and changingthe return type, but nothing else.",
	"Method": "MultipartContent setParts(Collection<Part> parts){\r\n    this.parts = new ArrayList<Part>(parts);\r\n    return this;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.bulkAddRecords",
	"Comment": "adds an several transactions to the database.if a transaction already exists in the database with the same unique id,then the record will just be updated instead. recurrence transactions will notbe inserted, instead schedule transaction would be called. if an exceptionoccurs, no transaction would be inserted.",
	"Method": "long bulkAddRecords(List<Transaction> transactionList,UpdateMethod updateMethod){\r\n    long start = System.nanoTime();\r\n    long rowInserted = super.bulkAddRecords(transactionList, updateMethod);\r\n    long end = System.nanoTime();\r\n    Log.d(getClass().getSimpleName(), String.format(\"bulk add transaction time %d \", end - start));\r\n    List<Split> splitList = new ArrayList(transactionList.size() * 3);\r\n    for (Transaction transaction : transactionList) {\r\n        splitList.addAll(transaction.getSplits());\r\n    }\r\n    if (rowInserted != 0 && !splitList.isEmpty()) {\r\n        try {\r\n            start = System.nanoTime();\r\n            long nSplits = mSplitsDbAdapter.bulkAddRecords(splitList, updateMethod);\r\n            Log.d(LOG_TAG, String.format(\"%d splits inserted in %d ns\", nSplits, System.nanoTime() - start));\r\n        } finally {\r\n            SQLiteStatement deleteEmptyTransaction = mDb.compileStatement(\"DELETE FROM \" + TransactionEntry.TABLE_NAME + \" WHERE NOT EXISTS ( SELECT * FROM \" + SplitEntry.TABLE_NAME + \" WHERE \" + TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_UID + \" = \" + SplitEntry.TABLE_NAME + \".\" + SplitEntry.COLUMN_TRANSACTION_UID + \" ) \");\r\n            deleteEmptyTransaction.execute();\r\n        }\r\n    }\r\n    return rowInserted;\r\n}"
}, {
	"Path": "ca.uhn.fhir.model.primitive.IdDt.setId",
	"Comment": "copies the value from the given iddt to this iddt. it is generally not neccesary to use this method but it is provided for consistency with the rest of the api.",
	"Method": "void setId(IdDt theId){\r\n    setValue(theId.getValue());\r\n}"
}, {
	"Path": "ca.uhn.fhir.narrative.BaseThymeleafNarrativeGenerator.isIgnoreMissingTemplates",
	"Comment": "if set to true, will return an empty narrative block for any profiles where no template is available",
	"Method": "boolean isIgnoreMissingTemplates(){\r\n    return myIgnoreMissingTemplates;\r\n}"
}, {
	"Path": "ca.uhn.fhir.rest.param.DateRangeParam.setUpperBoundInclusive",
	"Comment": "sets the upper bound to be greaterthan or equal to the given date",
	"Method": "DateRangeParam setUpperBoundInclusive(Date theUpperBound){\r\n    validateAndSet(myLowerBound, new DateParam(ParamPrefixEnum.LESSTHAN_OR_EQUALS, theUpperBound));\r\n    return this;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.addRecord",
	"Comment": "adds an account to the database. \tif an account already exists in the database with the same guid, it is replaced.",
	"Method": "void addRecord(Account account,UpdateMethod updateMethod){\r\n    Log.d(LOG_TAG, \"Replace account to db\");\r\n    List<Transaction> templateTransactions = mTransactionsAdapter.getScheduledTransactionsForAccount(account.getUID());\r\n    super.addRecord(account, updateMethod);\r\n    String accountUID = account.getUID();\r\n    if (account.getAccountType() != AccountType.ROOT) {\r\n        updateRecord(accountUID, AccountEntry.COLUMN_FULL_NAME, getFullyQualifiedAccountName(accountUID));\r\n        for (Transaction t : account.getTransactions()) {\r\n            t.setCommodity(account.getCommodity());\r\n            mTransactionsAdapter.addRecord(t, updateMethod);\r\n        }\r\n        for (Transaction transaction : templateTransactions) {\r\n            mTransactionsAdapter.addRecord(transaction, UpdateMethod.update);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.getActionType",
	"Comment": "returns the type of action to be performed by this scheduled action",
	"Method": "ActionType getActionType(){\r\n    return mActionType;\r\n}"
}, {
	"Path": "example.RestfulPatientResourceProvider.getResourceType",
	"Comment": "the getresourcetype method comes from iresourceprovider, and must\tbe overridden to indicate what type of resource this provider\tsupplies.",
	"Method": "Class<Patient> getResourceType(){\r\n    return Patient.class;\r\n}"
}, {
	"Path": "com.google.api.client.http.HttpHeaders.getFirstHeaderStringValue",
	"Comment": "returns the first header string value for the given header name.",
	"Method": "String getFirstHeaderStringValue(String name){\r\n    Object value = get(name.toLowerCase(Locale.US));\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    Class<? extends Object> valueClass = value.getClass();\r\n    if (value instanceof Iterable<?> || valueClass.isArray()) {\r\n        for (Object repeatedValue : Types.iterableOf(value)) {\r\n            return toStringValue(repeatedValue);\r\n        }\r\n    }\r\n    return toStringValue(value);\r\n}"
}, {
	"Path": "com.google.api.client.xml.GenericXmlTest.testParseAnyGenericType",
	"Comment": "the purpose of this test is map a generic xml to an element inside a dedicated element.",
	"Method": "void testParseAnyGenericType(){\r\n    AnyGenericType xml = new AnyGenericType();\r\n    XmlPullParser parser = Xml.createParser();\r\n    parser.setInput(new StringReader(ANY_GENERIC_TYPE_XML));\r\n    XmlNamespaceDictionary namespaceDictionary = new XmlNamespaceDictionary();\r\n    Xml.parseElement(parser, xml, namespaceDictionary, null);\r\n    assertTrue(xml.attr instanceof String);\r\n    Collection<GenericXml> repList = (Collection<GenericXml>) xml.elem.get(\"rep\");\r\n    assertEquals(2, repList.size());\r\n    Collection<GenericXml> repValue = (Collection<GenericXml>) xml.elem.get(\"value\");\r\n    assertEquals(1, repValue.size());\r\n    assertEquals(\"@attr\", ((Map.Entry) repList.toArray(new ArrayMap[] {})[0].entrySet().toArray(new Map.Entry[] {})[0]).getKey());\r\n    assertEquals(\"param1\", ((Map.Entry) repList.toArray(new ArrayMap[] {})[0].entrySet().toArray(new Map.Entry[] {})[0]).getValue());\r\n    assertEquals(\"text()\", ((Map.Entry) repList.toArray(new ArrayMap[] {})[0].entrySet().toArray(new Map.Entry[] {})[1]).getKey());\r\n    assertEquals(\"rep1\", ((Map.Entry) repList.toArray(new ArrayMap[] {})[0].entrySet().toArray(new Map.Entry[] {})[1]).getValue());\r\n    assertEquals(\"@attr\", ((Map.Entry) repList.toArray(new ArrayMap[] {})[1].entrySet().toArray(new Map.Entry[] {})[0]).getKey());\r\n    assertEquals(\"param2\", ((Map.Entry) repList.toArray(new ArrayMap[] {})[1].entrySet().toArray(new Map.Entry[] {})[0]).getValue());\r\n    assertEquals(\"text()\", ((Map.Entry) repList.toArray(new ArrayMap[] {})[1].entrySet().toArray(new Map.Entry[] {})[1]).getKey());\r\n    assertEquals(\"rep2\", ((Map.Entry) repList.toArray(new ArrayMap[] {})[1].entrySet().toArray(new Map.Entry[] {})[1]).getValue());\r\n    assertEquals(\"text()\", ((Map.Entry) repValue.toArray(new ArrayMap[] {})[0].entrySet().toArray(new Map.Entry[] {})[0]).getKey());\r\n    assertEquals(\"content\", ((Map.Entry) repValue.toArray(new ArrayMap[] {})[0].entrySet().toArray(new Map.Entry[] {})[0]).getValue());\r\n    XmlSerializer serializer = Xml.createSerializer();\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    serializer.setOutput(out, \"UTF-8\");\r\n    namespaceDictionary.serialize(serializer, \"any\", xml);\r\n    assertEquals(ANY_GENERIC_TYPE_XML, out.toString());\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.fetchAllTransactionsForAccount",
	"Comment": "returns a cursor to a set of all transactions which have a split belonging to the accound with unique id\taccountuid.",
	"Method": "Cursor fetchAllTransactionsForAccount(String accountUID){\r\n    SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();\r\n    queryBuilder.setTables(TransactionEntry.TABLE_NAME + \" INNER JOIN \" + SplitEntry.TABLE_NAME + \" ON \" + TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_UID + \" = \" + SplitEntry.TABLE_NAME + \".\" + SplitEntry.COLUMN_TRANSACTION_UID);\r\n    queryBuilder.setDistinct(true);\r\n    String[] projectionIn = new String[] { TransactionEntry.TABLE_NAME + \".*\" };\r\n    String selection = SplitEntry.TABLE_NAME + \".\" + SplitEntry.COLUMN_ACCOUNT_UID + \" = ?\" + \" AND \" + TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_TEMPLATE + \" = 0\";\r\n    String[] selectionArgs = new String[] { accountUID };\r\n    String sortOrder = TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_TIMESTAMP + \" DESC\";\r\n    return queryBuilder.query(mDb, projectionIn, selection, selectionArgs, null, null, sortOrder);\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.util.Utils.getDefaultTransport",
	"Comment": "returns a cached default implementation of the httptransport interface.",
	"Method": "HttpTransport getDefaultTransport(){\r\n    return TransportInstanceHolder.INSTANCE;\r\n}"
}, {
	"Path": "example.CompleteExampleClient.main",
	"Comment": "the main method here will directly call an open fhir server and retrieve a list of resources matching a given criteria, then load a linked resource.",
	"Method": "void main(String[] args){\r\n    FhirContext ctx = FhirContext.forDstu2();\r\n    String serverBase = \"http://fhir.healthintersections.com.au/open\";\r\n    ClientInterface client = ctx.newRestfulClient(ClientInterface.class, serverBase);\r\n    List<Patient> patients = client.findPatientsForMrn(new IdentifierDt(\"urn:oid:1.2.36.146.595.217.0.1\", \"12345\"));\r\n    System.out.println(\"Found \" + patients.size() + \" patients\");\r\n    Patient patient = patients.get(0);\r\n    System.out.println(\"Patient Last Name: \" + patient.getName().get(0).getFamily().get(0).getValue());\r\n    ResourceReferenceDt managingRef = patient.getManagingOrganization();\r\n    Organization org = (Organization) managingRef.loadResource(client);\r\n    System.out.println(org.getName());\r\n}"
}, {
	"Path": "com.google.api.client.testing.http.MockLowLevelHttpResponse.setHeaderNames",
	"Comment": "sets the list of header names of http response.default value is an empty list.",
	"Method": "MockLowLevelHttpResponse setHeaderNames(List<String> headerNames){\r\n    this.headerNames = Preconditions.checkNotNull(headerNames);\r\n    return this;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Transaction.shouldDecreaseBalance",
	"Comment": "returns true if the transaction type represents a decrease for the account balance for the accounttype, false otherwise",
	"Method": "boolean shouldDecreaseBalance(AccountType accountType,TransactionType transactionType){\r\n    if (accountType.hasDebitNormalBalance()) {\r\n        return transactionType == TransactionType.CREDIT;\r\n    } else\r\n        return transactionType == TransactionType.DEBIT;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.isPlaceholderAccount",
	"Comment": "returns true if the account with unique id accountuid is a placeholder account.",
	"Method": "boolean isPlaceholderAccount(String accountUID){\r\n    String isPlaceholder = getAttribute(accountUID, AccountEntry.COLUMN_PLACEHOLDER);\r\n    return Integer.parseInt(isPlaceholder) == 1;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Money.getZeroInstance",
	"Comment": "returns a money instance initialized to the local currency and value 0",
	"Method": "Money getZeroInstance(){\r\n    if (sDefaultZero == null) {\r\n        sDefaultZero = new Money(BigDecimal.ZERO, Commodity.DEFAULT_COMMODITY);\r\n    }\r\n    return sDefaultZero;\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.computeNextScheduledExecutionTimeStartingAt",
	"Comment": "computes the next time that this scheduled action is supposed to beexecuted starting at starttime.this method does not consider the end time, or number of times it should be run.it only considers when the next execution would theoretically be due.",
	"Method": "long computeNextScheduledExecutionTimeStartingAt(long startTime){\r\n    if (startTime <= 0) {\r\n        return mStartDate;\r\n    }\r\n    int multiplier = mRecurrence.getMultiplier();\r\n    LocalDateTime nextScheduledExecution = LocalDateTime.fromDateFields(new Date(startTime));\r\n    switch(mRecurrence.getPeriodType()) {\r\n        case HOUR:\r\n            nextScheduledExecution = nextScheduledExecution.plusHours(multiplier);\r\n            break;\r\n        case DAY:\r\n            nextScheduledExecution = nextScheduledExecution.plusDays(multiplier);\r\n            break;\r\n        case WEEK:\r\n            nextScheduledExecution = computeNextWeeklyExecutionStartingAt(nextScheduledExecution);\r\n            break;\r\n        case MONTH:\r\n            nextScheduledExecution = nextScheduledExecution.plusMonths(multiplier);\r\n            break;\r\n        case YEAR:\r\n            nextScheduledExecution = nextScheduledExecution.plusYears(multiplier);\r\n            break;\r\n    }\r\n    return nextScheduledExecution.toDate().getTime();\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.getNumCurrencies",
	"Comment": "return the number of currencies used in the transaction.for example if there are different splits with different currencies",
	"Method": "int getNumCurrencies(String transactionUID){\r\n    Cursor cursor = mDb.query(\"trans_extra_info\", new String[] { \"trans_currency_count\" }, \"trans_acct_t_uid=?\", new String[] { transactionUID }, null, null, null);\r\n    int numCurrencies = 0;\r\n    try {\r\n        if (cursor.moveToFirst()) {\r\n            numCurrencies = cursor.getInt(0);\r\n        }\r\n    } finally {\r\n        cursor.close();\r\n    }\r\n    return numCurrencies;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.fetchScheduledTransactionsForAccount",
	"Comment": "returns a cursor to all scheduled transactions which have at least one split in the accountthis is basically a set of all template transactions for this account",
	"Method": "Cursor fetchScheduledTransactionsForAccount(String accountUID){\r\n    SQLiteQueryBuilder queryBuilder = new SQLiteQueryBuilder();\r\n    queryBuilder.setTables(TransactionEntry.TABLE_NAME + \" INNER JOIN \" + SplitEntry.TABLE_NAME + \" ON \" + TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_UID + \" = \" + SplitEntry.TABLE_NAME + \".\" + SplitEntry.COLUMN_TRANSACTION_UID);\r\n    queryBuilder.setDistinct(true);\r\n    String[] projectionIn = new String[] { TransactionEntry.TABLE_NAME + \".*\" };\r\n    String selection = SplitEntry.TABLE_NAME + \".\" + SplitEntry.COLUMN_ACCOUNT_UID + \" = ?\" + \" AND \" + TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_TEMPLATE + \" = 1\";\r\n    String[] selectionArgs = new String[] { accountUID };\r\n    String sortOrder = TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_TIMESTAMP + \" DESC\";\r\n    return queryBuilder.query(mDb, projectionIn, selection, selectionArgs, null, null, sortOrder);\r\n}"
}, {
	"Path": "ca.uhn.fhir.context.FhirContext.getElementDefinition",
	"Comment": "returns the scanned runtime model for the given type. this is an advanced feature which is generally only needed\tfor extending the core library.\tnote that this method is case insensitive!",
	"Method": "BaseRuntimeElementDefinition<?> getElementDefinition(Class<? extends IBase> theElementType,BaseRuntimeElementDefinition<?> getElementDefinition,String theElementName){\r\n    validateInitialized();\r\n    return myNameToElementDefinition.get(theElementName.toLowerCase());\r\n}"
}, {
	"Path": "com.google.api.client.testing.util.LogRecordingHandler.messages",
	"Comment": "returns a new instance of a list of published record messages.",
	"Method": "List<String> messages(){\r\n    List<String> result = Lists.newArrayList();\r\n    for (LogRecord record : records) {\r\n        result.add(record.getMessage());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.ScheduledActionsListFragment.finishEditMode",
	"Comment": "finishes the edit mode in the transactions list.edit mode is started when at least one transaction is selected",
	"Method": "void finishEditMode(){\r\n    mInEditMode = false;\r\n    uncheckAllItems();\r\n    mActionMode = null;\r\n}"
}, {
	"Path": "ca.uhn.fhir.rest.server.exceptions.BaseServerResponseException.hasResponseHeaders",
	"Comment": "does the exception have any headers which should be added to the outgoing response?",
	"Method": "boolean hasResponseHeaders(){\r\n    return myResponseHeaders != null && myResponseHeaders.isEmpty() == false;\r\n}"
}, {
	"Path": "org.gnucash.android.app.GnuCashApplication.initializeDatabaseAdapters",
	"Comment": "initialize database adapter singletons for use in the applicationthis method should be called every time a new book is opened",
	"Method": "void initializeDatabaseAdapters(){\r\n    if (mDbHelper != null) {\r\n        mDbHelper.getReadableDatabase().close();\r\n    }\r\n    try {\r\n        mDbHelper = new DatabaseHelper(getAppContext(), mBooksDbAdapter.getActiveBookUID());\r\n    } catch (BooksDbAdapter.NoActiveBookFoundException e) {\r\n        mBooksDbAdapter.fixBooksDatabase();\r\n        mDbHelper = new DatabaseHelper(getAppContext(), mBooksDbAdapter.getActiveBookUID());\r\n    }\r\n    SQLiteDatabase mainDb;\r\n    try {\r\n        mainDb = mDbHelper.getWritableDatabase();\r\n    } catch (SQLException e) {\r\n        Crashlytics.logException(e);\r\n        Log.e(\"GnuCashApplication\", \"Error getting database: \" + e.getMessage());\r\n        mainDb = mDbHelper.getReadableDatabase();\r\n    }\r\n    mSplitsDbAdapter = new SplitsDbAdapter(mainDb);\r\n    mTransactionsDbAdapter = new TransactionsDbAdapter(mainDb, mSplitsDbAdapter);\r\n    mAccountsDbAdapter = new AccountsDbAdapter(mainDb, mTransactionsDbAdapter);\r\n    mRecurrenceDbAdapter = new RecurrenceDbAdapter(mainDb);\r\n    mScheduledActionDbAdapter = new ScheduledActionDbAdapter(mainDb, mRecurrenceDbAdapter);\r\n    mPricesDbAdapter = new PricesDbAdapter(mainDb);\r\n    mCommoditiesDbAdapter = new CommoditiesDbAdapter(mainDb);\r\n    mBudgetAmountsDbAdapter = new BudgetAmountsDbAdapter(mainDb);\r\n    mBudgetsDbAdapter = new BudgetsDbAdapter(mainDb, mBudgetAmountsDbAdapter, mRecurrenceDbAdapter);\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.getImbalanceAccountName",
	"Comment": "returns the imbalance account where to store transactions which are not double entry.",
	"Method": "String getImbalanceAccountName(Commodity commodity){\r\n    return getImbalanceAccountPrefix() + commodity.getCurrencyCode();\r\n}"
}, {
	"Path": "org.gnucash.android.test.ui.OwnCloudExportTest.OwnCloudCredentials",
	"Comment": "it might fail if it takes too long to connect to the server or if there is no network",
	"Method": "void OwnCloudCredentials(){\r\n    Assume.assumeTrue(hasActiveInternetConnection());\r\n    onView(withId(R.id.drawer_layout)).perform(DrawerActions.open());\r\n    onView(withId(R.id.nav_view)).perform(swipeUp());\r\n    onView(withText(R.string.title_settings)).perform(click());\r\n    onView(withText(R.string.header_backup_and_export_settings)).perform(click());\r\n    onView(withText(R.string.title_owncloud_sync_preference)).perform(click());\r\n    onView(withId(R.id.owncloud_hostname)).check(matches(isDisplayed()));\r\n    onView(withId(R.id.owncloud_hostname)).perform(clearText()).perform(typeText(OC_SERVER), closeSoftKeyboard());\r\n    onView(withId(R.id.owncloud_username)).perform(clearText()).perform(typeText(OC_USERNAME), closeSoftKeyboard());\r\n    onView(withId(R.id.owncloud_password)).perform(clearText()).perform(typeText(OC_PASSWORD), closeSoftKeyboard());\r\n    onView(withId(R.id.owncloud_dir)).perform(clearText()).perform(typeText(OC_DIR), closeSoftKeyboard());\r\n    onView(withId(R.id.btn_save)).perform(click());\r\n    sleep(5000);\r\n    onView(withId(R.id.btn_save)).perform(click());\r\n    assertEquals(mPrefs.getString(mAccountsActivity.getString(R.string.key_owncloud_server), null), OC_SERVER);\r\n    assertEquals(mPrefs.getString(mAccountsActivity.getString(R.string.key_owncloud_username), null), OC_USERNAME);\r\n    assertEquals(mPrefs.getString(mAccountsActivity.getString(R.string.key_owncloud_password), null), OC_PASSWORD);\r\n    assertEquals(mPrefs.getString(mAccountsActivity.getString(R.string.key_owncloud_dir), null), OC_DIR);\r\n    assertTrue(mPrefs.getBoolean(mAccountsActivity.getString(R.string.key_owncloud_sync), false));\r\n}"
}, {
	"Path": "org.gnucash.android.util.BackupManager.backupAllBooks",
	"Comment": "perform an automatic backup of all books in the database.this method is run every time the service is executed",
	"Method": "void backupAllBooks(){\r\n    BooksDbAdapter booksDbAdapter = BooksDbAdapter.getInstance();\r\n    List<String> bookUIDs = booksDbAdapter.getAllBookUIDs();\r\n    Context context = GnuCashApplication.getAppContext();\r\n    for (String bookUID : bookUIDs) {\r\n        String backupFile = getBookBackupFileUri(bookUID);\r\n        if (backupFile == null) {\r\n            backupBook(bookUID);\r\n            continue;\r\n        }\r\n        try (BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(context.getContentResolver().openOutputStream(Uri.parse(backupFile)))) {\r\n            GZIPOutputStream gzipOutputStream = new GZIPOutputStream(bufferedOutputStream);\r\n            OutputStreamWriter writer = new OutputStreamWriter(gzipOutputStream);\r\n            ExportParams params = new ExportParams(ExportFormat.XML);\r\n            new GncXmlExporter(params).generateExport(writer);\r\n            writer.close();\r\n        } catch (IOException ex) {\r\n            Log.e(LOG_TAG, \"Auto backup failed for book \" + bookUID);\r\n            ex.printStackTrace();\r\n            Crashlytics.logException(ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.util.ExponentialBackOff.getMaxIntervalMillis",
	"Comment": "returns the maximum value of the back off period in milliseconds. once the current intervalreaches this value it stops increasing.",
	"Method": "int getMaxIntervalMillis(int getMaxIntervalMillis){\r\n    return maxIntervalMillis;\r\n}"
}, {
	"Path": "org.gnucash.android.export.ofx.OfxHelper.getOfxFormattedTime",
	"Comment": "returns a formatted string representation of time in milliseconds",
	"Method": "String getOfxFormattedTime(long milliseconds){\r\n    Date date = new Date(milliseconds);\r\n    String dateString = OFX_DATE_FORMATTER.format(date);\r\n    TimeZone tz = Calendar.getInstance().getTimeZone();\r\n    int offset = tz.getRawOffset();\r\n    int hours = (int) ((offset / (1000 * 60 * 60)) % 24);\r\n    String sign = offset > 0 ? \"+\" : \"\";\r\n    return dateString + \"[\" + sign + hours + \":\" + tz.getDisplayName(false, TimeZone.SHORT, Locale.getDefault()) + \"]\";\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.TransactionsActivity.setTitleIndicatorColor",
	"Comment": "sets the color for the viewpager title indicator to match the account color",
	"Method": "void setTitleIndicatorColor(){\r\n    int iColor = AccountsDbAdapter.getActiveAccountColorResource(mAccountUID);\r\n    mTabLayout.setBackgroundColor(iColor);\r\n    if (getSupportActionBar() != null)\r\n        getSupportActionBar().setBackgroundDrawable(new ColorDrawable(iColor));\r\n    if (Build.VERSION.SDK_INT > 20)\r\n        getWindow().setStatusBarColor(GnuCashApplication.darken(iColor));\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.notifications.StoredChannel.getNotificationCallback",
	"Comment": "returns the notification callback called when a notification is received for this subscription.",
	"Method": "UnparsedNotificationCallback getNotificationCallback(){\r\n    lock.lock();\r\n    try {\r\n        return notificationCallback;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.getParentAccountUID",
	"Comment": "returns theunique id of the parent account of the account with unique id uid\tif the account has no parent, null is returned",
	"Method": "String getParentAccountUID(String uid){\r\n    Cursor cursor = mDb.query(AccountEntry.TABLE_NAME, new String[] { AccountEntry.COLUMN_PARENT_ACCOUNT_UID }, AccountEntry.COLUMN_UID + \" = ?\", new String[] { uid }, null, null, null, null);\r\n    try {\r\n        if (cursor.moveToFirst()) {\r\n            Log.d(LOG_TAG, \"Found parent account UID, returning value\");\r\n            return cursor.getString(cursor.getColumnIndexOrThrow(AccountEntry.COLUMN_PARENT_ACCOUNT_UID));\r\n        } else {\r\n            return null;\r\n        }\r\n    } finally {\r\n        cursor.close();\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.ui.report.linechart.CashFlowLineChartFragment.getEntryList",
	"Comment": "returns entries which represent a user data of the specified account type",
	"Method": "List<Entry> getEntryList(AccountType accountType){\r\n    List<String> accountUIDList = new ArrayList();\r\n    for (Account account : mAccountsDbAdapter.getSimpleAccountList()) {\r\n        if (account.getAccountType() == accountType && !account.isPlaceholderAccount() && account.getCommodity().equals(mCommodity)) {\r\n            accountUIDList.add(account.getUID());\r\n        }\r\n    }\r\n    LocalDateTime earliest;\r\n    LocalDateTime latest;\r\n    if (mReportPeriodStart == -1 && mReportPeriodEnd == -1) {\r\n        earliest = new LocalDateTime(mEarliestTimestampsMap.get(accountType));\r\n        latest = new LocalDateTime(mLatestTimestampsMap.get(accountType));\r\n    } else {\r\n        earliest = new LocalDateTime(mReportPeriodStart);\r\n        latest = new LocalDateTime(mReportPeriodEnd);\r\n    }\r\n    Log.d(TAG, \"Earliest \" + accountType + \" date \" + earliest.toString(\"dd MM yyyy\"));\r\n    Log.d(TAG, \"Latest \" + accountType + \" date \" + latest.toString(\"dd MM yyyy\"));\r\n    int xAxisOffset = getDateDiff(new LocalDateTime(mEarliestTransactionTimestamp), earliest);\r\n    int count = getDateDiff(earliest, latest);\r\n    List<Entry> values = new ArrayList(count + 1);\r\n    for (int i = 0; i <= count; i++) {\r\n        long start = 0;\r\n        long end = 0;\r\n        switch(mGroupInterval) {\r\n            case QUARTER:\r\n                int quarter = getQuarter(earliest);\r\n                start = earliest.withMonthOfYear(quarter * 3 - 2).dayOfMonth().withMinimumValue().millisOfDay().withMinimumValue().toDate().getTime();\r\n                end = earliest.withMonthOfYear(quarter * 3).dayOfMonth().withMaximumValue().millisOfDay().withMaximumValue().toDate().getTime();\r\n                earliest = earliest.plusMonths(3);\r\n                break;\r\n            case MONTH:\r\n                start = earliest.dayOfMonth().withMinimumValue().millisOfDay().withMinimumValue().toDate().getTime();\r\n                end = earliest.dayOfMonth().withMaximumValue().millisOfDay().withMaximumValue().toDate().getTime();\r\n                earliest = earliest.plusMonths(1);\r\n                break;\r\n            case YEAR:\r\n                start = earliest.dayOfYear().withMinimumValue().millisOfDay().withMinimumValue().toDate().getTime();\r\n                end = earliest.dayOfYear().withMaximumValue().millisOfDay().withMaximumValue().toDate().getTime();\r\n                earliest = earliest.plusYears(1);\r\n                break;\r\n        }\r\n        float balance = (float) mAccountsDbAdapter.getAccountsBalance(accountUIDList, start, end).asDouble();\r\n        values.add(new Entry(balance, i + xAxisOffset));\r\n        Log.d(TAG, accountType + earliest.toString(\" MMM yyyy\") + \", balance = \" + balance);\r\n    }\r\n    return values;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.addRecord",
	"Comment": "adds an transaction to the database. \tif a transaction already exists in the database with the same unique id, \tthen the record will just be updated instead",
	"Method": "void addRecord(Transaction transaction,UpdateMethod updateMethod){\r\n    Log.d(LOG_TAG, \"Adding transaction to the db via \" + updateMethod.name());\r\n    mDb.beginTransaction();\r\n    try {\r\n        Split imbalanceSplit = transaction.createAutoBalanceSplit();\r\n        if (imbalanceSplit != null) {\r\n            String imbalanceAccountUID = new AccountsDbAdapter(mDb, this).getOrCreateImbalanceAccountUID(transaction.getCommodity());\r\n            imbalanceSplit.setAccountUID(imbalanceAccountUID);\r\n        }\r\n        super.addRecord(transaction, updateMethod);\r\n        Log.d(LOG_TAG, \"Adding splits for transaction\");\r\n        ArrayList<String> splitUIDs = new ArrayList(transaction.getSplits().size());\r\n        for (Split split : transaction.getSplits()) {\r\n            Log.d(LOG_TAG, \"Replace transaction split in db\");\r\n            if (imbalanceSplit == split) {\r\n                mSplitsDbAdapter.addRecord(split, UpdateMethod.insert);\r\n            } else {\r\n                mSplitsDbAdapter.addRecord(split, updateMethod);\r\n            }\r\n            splitUIDs.add(split.getUID());\r\n        }\r\n        Log.d(LOG_TAG, transaction.getSplits().size() + \" splits added\");\r\n        long deleted = mDb.delete(SplitEntry.TABLE_NAME, SplitEntry.COLUMN_TRANSACTION_UID + \" = ? AND \" + SplitEntry.COLUMN_UID + \" NOT IN ('\" + TextUtils.join(\"' , '\", splitUIDs) + \"')\", new String[] { transaction.getUID() });\r\n        Log.d(LOG_TAG, deleted + \" splits deleted\");\r\n        mDb.setTransactionSuccessful();\r\n    } catch (SQLException sqlEx) {\r\n        Log.e(LOG_TAG, sqlEx.getMessage());\r\n        Crashlytics.logException(sqlEx);\r\n    } finally {\r\n        mDb.endTransaction();\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.ui.util.widget.CalculatorEditText.getCalculatorKeyboard",
	"Comment": "returns the calculator keyboard instantiated by this edittext",
	"Method": "CalculatorKeyboard getCalculatorKeyboard(){\r\n    return mCalculatorKeyboard;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.fetchAccountsOrderedByFavoriteAndFullName",
	"Comment": "returns a cursor set of accounts which fulfill wherethis method returns the favorite accounts first, sorted by name, and then the other accounts,sorted by name.",
	"Method": "Cursor fetchAccountsOrderedByFavoriteAndFullName(String where,String[] whereArgs){\r\n    Log.v(LOG_TAG, \"Fetching all accounts from db where \" + where + \" order by Favorite then Name\");\r\n    return mDb.query(AccountEntry.TABLE_NAME, null, where, whereArgs, null, null, AccountEntry.COLUMN_FAVORITE + \" DESC, \" + AccountEntry.COLUMN_FULL_NAME + \" ASC\");\r\n}"
}, {
	"Path": "com.google.api.client.json.JsonObjectParser.getWrapperKeys",
	"Comment": "returns the unmodifiable set of wrapper keys for the json content.",
	"Method": "Set<String> getWrapperKeys(Collection<String> getWrapperKeys){\r\n    return Collections.unmodifiableSet(wrapperKeys);\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.db.AccountsDbAdapterTest.shouldCreateAccountHierarchy",
	"Comment": "test creating an account hierarchy by specifying fully qualified name",
	"Method": "void shouldCreateAccountHierarchy(){\r\n    String uid = mAccountsDbAdapter.createAccountHierarchy(\"Assets:Current Assets:Cash in Wallet\", AccountType.ASSET);\r\n    List<Account> accounts = mAccountsDbAdapter.getAllRecords();\r\n    assertThat(accounts).hasSize(3);\r\n    assertThat(accounts).extracting(\"mUID\").contains(uid);\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.model.SplitTest.shouldCreateInversePair",
	"Comment": "tests that a split pair has the inverse transaction type as the origin split.everything else should be the same",
	"Method": "void shouldCreateInversePair(){\r\n    Split split = new Split(new Money(\"2\", \"USD\"), \"dummy\");\r\n    split.setType(TransactionType.CREDIT);\r\n    split.setTransactionUID(\"random-trx\");\r\n    Split pair = split.createPair(\"test\");\r\n    assertThat(pair.getType()).isEqualTo(TransactionType.DEBIT);\r\n    assertThat(pair.getValue()).isEqualTo(split.getValue());\r\n    assertThat(pair.getMemo()).isEqualTo(split.getMemo());\r\n    assertThat(pair.getTransactionUID()).isEqualTo(split.getTransactionUID());\r\n}"
}, {
	"Path": "org.gnucash.android.ui.util.RecurrenceParser.parseEndTime",
	"Comment": "parses the end time from an eventrecurrence object and sets it to the scheduledevent.the end time is specified in the dialog either by number of occurrences or a date.",
	"Method": "void parseEndTime(EventRecurrence eventRecurrence,Recurrence recurrence){\r\n    if (eventRecurrence.until != null && eventRecurrence.until.length() > 0) {\r\n        Time endTime = new Time();\r\n        endTime.parse(eventRecurrence.until);\r\n        recurrence.setPeriodEnd(new Timestamp(endTime.toMillis(false)));\r\n    } else if (eventRecurrence.count > 0) {\r\n        recurrence.setPeriodEnd(eventRecurrence.count);\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.export.Exporter.getExportTime",
	"Comment": "parses the name of an export file and returns the date of export",
	"Method": "long getExportTime(String filename){\r\n    String[] tokens = filename.split(\"_\");\r\n    long timeMillis = 0;\r\n    if (tokens.length < 2) {\r\n        return timeMillis;\r\n    }\r\n    try {\r\n        Date date = EXPORT_FILENAME_DATE_FORMAT.parse(tokens[0] + \"_\" + tokens[1]);\r\n        timeMillis = date.getTime();\r\n    } catch (ParseException e) {\r\n        Log.e(\"Exporter\", \"Error parsing time from file name: \" + e.getMessage());\r\n        Crashlytics.logException(e);\r\n    }\r\n    return timeMillis;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.getAllOpeningBalanceTransactions",
	"Comment": "updates all opening balances to the current account balances",
	"Method": "List<Transaction> getAllOpeningBalanceTransactions(){\r\n    Cursor cursor = fetchAccounts(null, null, null);\r\n    List<Transaction> openingTransactions = new ArrayList();\r\n    try {\r\n        SplitsDbAdapter splitsDbAdapter = mTransactionsAdapter.getSplitDbAdapter();\r\n        while (cursor.moveToNext()) {\r\n            long id = cursor.getLong(cursor.getColumnIndexOrThrow(AccountEntry._ID));\r\n            String accountUID = getUID(id);\r\n            String currencyCode = getCurrencyCode(accountUID);\r\n            ArrayList<String> accountList = new ArrayList();\r\n            accountList.add(accountUID);\r\n            Money balance = splitsDbAdapter.computeSplitBalance(accountList, currencyCode, getAccountType(accountUID).hasDebitNormalBalance());\r\n            if (balance.asBigDecimal().compareTo(new BigDecimal(0)) == 0)\r\n                continue;\r\n            Transaction transaction = new Transaction(GnuCashApplication.getAppContext().getString(R.string.account_name_opening_balances));\r\n            transaction.setNote(getAccountName(accountUID));\r\n            transaction.setCommodity(Commodity.getInstance(currencyCode));\r\n            TransactionType transactionType = Transaction.getTypeForBalance(getAccountType(accountUID), balance.isNegative());\r\n            Split split = new Split(balance, accountUID);\r\n            split.setType(transactionType);\r\n            transaction.addSplit(split);\r\n            transaction.addSplit(split.createPair(getOrCreateOpeningBalanceAccountUID()));\r\n            transaction.setExported(true);\r\n            openingTransactions.add(transaction);\r\n        }\r\n    } finally {\r\n        cursor.close();\r\n    }\r\n    return openingTransactions;\r\n}"
}, {
	"Path": "com.google.api.client.xml.XmlTest.testWithEndElementNested",
	"Comment": "negative test with that start with a end element tag nested in an started element.",
	"Method": "void testWithEndElementNested(){\r\n    SimpleTypeString xml = new SimpleTypeString();\r\n    XmlPullParser parser = Xml.createParser();\r\n    parser.setInput(new StringReader(START_WITH_END_ELEMENT_NESTED));\r\n    XmlNamespaceDictionary namespaceDictionary = new XmlNamespaceDictionary().set(\"\", \"\");\r\n    try {\r\n        Xml.parseElement(parser, xml, namespaceDictionary, null);\r\n        fail();\r\n    } catch (final Exception e) {\r\n        assertEquals(\"end tag name <\/p> must match start tag name <any> from line 1 (position:\" + \" START_TAG seen ...<any xmlns=\\\"\\\"><\/p>... @1:39)\", e.getMessage().trim());\r\n    }\r\n}"
}, {
	"Path": "ca.uhn.fhir.context.BaseRuntimeElementDefinition.sealAndInitialize",
	"Comment": "invoked prior to use to perform any initialization and make object\tmutable.",
	"Method": "void sealAndInitialize(FhirContext theContext,Map<Class<? extends IBase>, BaseRuntimeElementDefinition<?>> theClassToElementDefinitions){\r\n    for (BaseRuntimeChildDefinition next : myExtensions) {\r\n        next.sealAndInitialize(theContext, theClassToElementDefinitions);\r\n    }\r\n    for (RuntimeChildDeclaredExtensionDefinition next : myExtensions) {\r\n        String extUrl = next.getExtensionUrl();\r\n        if (myUrlToExtension.containsKey(extUrl)) {\r\n            throw new ConfigurationException(\"Duplicate extension URL[\" + extUrl + \"] in Element[\" + getName() + \"]\");\r\n        }\r\n        myUrlToExtension.put(extUrl, next);\r\n        if (next.isModifier()) {\r\n            myExtensionsModifier.add(next);\r\n        } else {\r\n            myExtensionsNonModifier.add(next);\r\n        }\r\n    }\r\n    myExtensions = Collections.unmodifiableList(myExtensions);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.budget.BudgetsActivity.getBudgetProgressColor",
	"Comment": "returns a color between red and green depending on the value parameter",
	"Method": "int getBudgetProgressColor(double value){\r\n    return GnuCashApplication.darken(android.graphics.Color.HSVToColor(new float[] { (float) value * 120f, 1f, 1f }));\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.media.MediaHttpUploader.buildContentChunk",
	"Comment": "sets the http media content chunk and the required headers that should be used in the uploadrequest.",
	"Method": "ContentChunk buildContentChunk(){\r\n    int blockSize;\r\n    if (isMediaLengthKnown()) {\r\n        blockSize = (int) Math.min(chunkSize, getMediaContentLength() - totalBytesServerReceived);\r\n    } else {\r\n        blockSize = chunkSize;\r\n    }\r\n    AbstractInputStreamContent contentChunk;\r\n    int actualBlockSize = blockSize;\r\n    if (isMediaLengthKnown()) {\r\n        contentInputStream.mark(blockSize);\r\n        InputStream limitInputStream = ByteStreams.limit(contentInputStream, blockSize);\r\n        contentChunk = new InputStreamContent(mediaContent.getType(), limitInputStream).setRetrySupported(true).setLength(blockSize).setCloseInputStream(false);\r\n        mediaContentLengthStr = String.valueOf(getMediaContentLength());\r\n    } else {\r\n        int actualBytesRead;\r\n        int bytesAllowedToRead;\r\n        int copyBytes = 0;\r\n        if (currentRequestContentBuffer == null) {\r\n            bytesAllowedToRead = cachedByte == null ? blockSize + 1 : blockSize;\r\n            currentRequestContentBuffer = new byte[blockSize + 1];\r\n            if (cachedByte != null) {\r\n                currentRequestContentBuffer[0] = cachedByte;\r\n            }\r\n        } else {\r\n            copyBytes = (int) (totalBytesClientSent - totalBytesServerReceived);\r\n            System.arraycopy(currentRequestContentBuffer, currentChunkLength - copyBytes, currentRequestContentBuffer, 0, copyBytes);\r\n            if (cachedByte != null) {\r\n                currentRequestContentBuffer[copyBytes] = cachedByte;\r\n            }\r\n            bytesAllowedToRead = blockSize - copyBytes;\r\n        }\r\n        actualBytesRead = ByteStreams.read(contentInputStream, currentRequestContentBuffer, blockSize + 1 - bytesAllowedToRead, bytesAllowedToRead);\r\n        if (actualBytesRead < bytesAllowedToRead) {\r\n            actualBlockSize = copyBytes + Math.max(0, actualBytesRead);\r\n            if (cachedByte != null) {\r\n                actualBlockSize++;\r\n                cachedByte = null;\r\n            }\r\n            if (mediaContentLengthStr.equals(\"*\")) {\r\n                mediaContentLengthStr = String.valueOf(totalBytesServerReceived + actualBlockSize);\r\n            }\r\n        } else {\r\n            cachedByte = currentRequestContentBuffer[blockSize];\r\n        }\r\n        contentChunk = new ByteArrayContent(mediaContent.getType(), currentRequestContentBuffer, 0, actualBlockSize);\r\n        totalBytesClientSent = totalBytesServerReceived + actualBlockSize;\r\n    }\r\n    currentChunkLength = actualBlockSize;\r\n    String contentRange;\r\n    if (actualBlockSize == 0) {\r\n        contentRange = \"bytes */\" + mediaContentLengthStr;\r\n    } else {\r\n        contentRange = \"bytes \" + totalBytesServerReceived + \"-\" + (totalBytesServerReceived + actualBlockSize - 1) + \"/\" + mediaContentLengthStr;\r\n    }\r\n    return new ContentChunk(contentChunk, contentRange);\r\n}"
}, {
	"Path": "com.google.api.client.http.xml.atom.AtomFeedParser.create",
	"Comment": "parses the given http response using the given feed class and entry class.",
	"Method": "AtomFeedParser<T, E> create(HttpResponse response,XmlNamespaceDictionary namespaceDictionary,Class<T> feedClass,Class<E> entryClass){\r\n    InputStream content = response.getContent();\r\n    try {\r\n        Atom.checkContentType(response.getContentType());\r\n        XmlPullParser parser = Xml.createParser();\r\n        parser.setInput(content, null);\r\n        AtomFeedParser<T, E> result = new AtomFeedParser<T, E>(namespaceDictionary, parser, content, feedClass, entryClass);\r\n        content = null;\r\n        return result;\r\n    } finally {\r\n        if (content != null) {\r\n            content.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.export.ExportParams.setDeleteTransactionsAfterExport",
	"Comment": "set flag to delete transactions after exporting is complete",
	"Method": "void setDeleteTransactionsAfterExport(boolean deleteTransactions){\r\n    this.mDeleteTransactionsAfterExport = deleteTransactions;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.TransactionFormFragment.updateTransferAccountsList",
	"Comment": "updates the list of possible transfer accounts.only accounts with the same currency can be transferred to",
	"Method": "void updateTransferAccountsList(){\r\n    String conditions = \"(\" + DatabaseSchema.AccountEntry.COLUMN_UID + \" != ?\" + \" AND \" + DatabaseSchema.AccountEntry.COLUMN_TYPE + \" != ?\" + \" AND \" + DatabaseSchema.AccountEntry.COLUMN_PLACEHOLDER + \" = 0\" + \")\";\r\n    if (mCursor != null) {\r\n        mCursor.close();\r\n    }\r\n    mCursor = mAccountsDbAdapter.fetchAccountsOrderedByFavoriteAndFullName(conditions, new String[] { mAccountUID, AccountType.ROOT.name() });\r\n    mAccountCursorAdapter = new QualifiedAccountNameCursorAdapter(getActivity(), mCursor);\r\n    mTransferAccountSpinner.setAdapter(mAccountCursorAdapter);\r\n}"
}, {
	"Path": "org.gnucash.android.model.Account.getParentUID",
	"Comment": "returns the unique account identifier of the parent account",
	"Method": "String getParentUID(){\r\n    return mParentAccountUID;\r\n}"
}, {
	"Path": "org.gnucash.android.service.ScheduledActionService.executeScheduledEvent",
	"Comment": "executes a scheduled event according to the specified parameters",
	"Method": "void executeScheduledEvent(ScheduledAction scheduledAction,SQLiteDatabase db){\r\n    Log.i(LOG_TAG, \"Executing scheduled action: \" + scheduledAction.toString());\r\n    int executionCount = 0;\r\n    switch(scheduledAction.getActionType()) {\r\n        case TRANSACTION:\r\n            executionCount += executeTransactions(scheduledAction, db);\r\n            break;\r\n        case BACKUP:\r\n            executionCount += executeBackup(scheduledAction, db);\r\n            break;\r\n    }\r\n    if (executionCount > 0) {\r\n        scheduledAction.setLastRun(System.currentTimeMillis());\r\n        scheduledAction.setExecutionCount(scheduledAction.getExecutionCount() + executionCount);\r\n        ContentValues contentValues = new ContentValues();\r\n        contentValues.put(DatabaseSchema.ScheduledActionEntry.COLUMN_LAST_RUN, scheduledAction.getLastRunTime());\r\n        contentValues.put(DatabaseSchema.ScheduledActionEntry.COLUMN_EXECUTION_COUNT, scheduledAction.getExecutionCount());\r\n        db.update(DatabaseSchema.ScheduledActionEntry.TABLE_NAME, contentValues, DatabaseSchema.ScheduledActionEntry.COLUMN_UID + \"=?\", new String[] { scheduledAction.getUID() });\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.db.BudgetsDbAdapterTest.testBulkAddBudgets",
	"Comment": "test that when bulk adding budgets, all the associated budgetamounts and recurrences are saved",
	"Method": "void testBulkAddBudgets(){\r\n    assertThat(mBudgetsDbAdapter.getRecordsCount()).isZero();\r\n    assertThat(mBudgetAmountsDbAdapter.getRecordsCount()).isZero();\r\n    assertThat(mRecurrenceDbAdapter.getRecordsCount()).isZero();\r\n    List<Budget> budgets = bulkCreateBudgets();\r\n    mBudgetsDbAdapter.bulkAddRecords(budgets);\r\n    assertThat(mBudgetsDbAdapter.getRecordsCount()).isEqualTo(2);\r\n    assertThat(mBudgetAmountsDbAdapter.getRecordsCount()).isEqualTo(3);\r\n    assertThat(mRecurrenceDbAdapter.getRecordsCount()).isEqualTo(2);\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.GoogleUtils.getCertificateTrustStore",
	"Comment": "returns the key store for trusted root certificates to use for google apis.value is cached, so subsequent access is fast.",
	"Method": "KeyStore getCertificateTrustStore(){\r\n    if (certTrustStore == null) {\r\n        certTrustStore = SecurityUtils.getJavaKeyStore();\r\n        InputStream keyStoreStream = GoogleUtils.class.getResourceAsStream(\"google.jks\");\r\n        SecurityUtils.loadKeyStore(certTrustStore, keyStoreStream, \"notasecret\");\r\n    }\r\n    return certTrustStore;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.util.widget.CalculatorEditText.init",
	"Comment": "overloaded constructorreads any attributes which are specified in xml and applies them",
	"Method": "void init(Context context,AttributeSet attrs){\r\n    this.mContext = context;\r\n    TypedArray a = context.getTheme().obtainStyledAttributes(attrs, R.styleable.CalculatorEditText, 0, 0);\r\n    try {\r\n        mCalculatorKeysLayout = a.getResourceId(R.styleable.CalculatorEditText_keyboardKeysLayout, R.xml.calculator_keyboard);\r\n    } finally {\r\n        a.recycle();\r\n    }\r\n    addTextChangedListener(new TextWatcher() {\r\n        @Override\r\n        public void beforeTextChanged(CharSequence s, int start, int count, int after) {\r\n        }\r\n        @Override\r\n        public void onTextChanged(CharSequence s, int start, int before, int count) {\r\n        }\r\n        @Override\r\n        public void afterTextChanged(Editable s) {\r\n            isContentModified = true;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.gnucash.android.ui.util.widget.CalculatorEditText.init",
	"Comment": "overloaded constructorreads any attributes which are specified in xml and applies them",
	"Method": "void init(Context context,AttributeSet attrs){\r\n}"
}, {
	"Path": "org.gnucash.android.ui.util.widget.CalculatorEditText.init",
	"Comment": "overloaded constructorreads any attributes which are specified in xml and applies them",
	"Method": "void init(Context context,AttributeSet attrs){\r\n}"
}, {
	"Path": "org.gnucash.android.ui.util.widget.CalculatorEditText.init",
	"Comment": "overloaded constructorreads any attributes which are specified in xml and applies them",
	"Method": "void init(Context context,AttributeSet attrs){\r\n    isContentModified = true;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.DeleteAccountDialogFragment.newInstance",
	"Comment": "creates new instance of the delete confirmation dialog and provides parameters for it",
	"Method": "DeleteAccountDialogFragment newInstance(String accountUID){\r\n    DeleteAccountDialogFragment fragment = new DeleteAccountDialogFragment();\r\n    fragment.mOriginAccountUID = accountUID;\r\n    fragment.mSubAccountCount = AccountsDbAdapter.getInstance().getSubAccountCount(accountUID);\r\n    fragment.mTransactionCount = TransactionsDbAdapter.getInstance().getTransactionsCount(accountUID);\r\n    return fragment;\r\n}"
}, {
	"Path": "com.google.api.client.http.GenericUrl.getAll",
	"Comment": "returns all query parameter values for the given query parameter name.",
	"Method": "Collection<Object> getAll(String name){\r\n    Object value = get(name);\r\n    if (value == null) {\r\n        return Collections.emptySet();\r\n    }\r\n    if (value instanceof Collection<?>) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Collection<Object> collectionValue = (Collection<Object>) value;\r\n        return Collections.unmodifiableCollection(collectionValue);\r\n    }\r\n    return Collections.singleton(value);\r\n}"
}, {
	"Path": "com.google.api.client.xml.atom.AbstractAtomFeedParser.parseFeed",
	"Comment": "parse the feed and return a new parsed instance of the feed type. this method can be skipped ifall you want are the items.",
	"Method": "T parseFeed(){\r\n    boolean close = true;\r\n    try {\r\n        this.feedParsed = true;\r\n        T result = Types.newInstance(feedClass);\r\n        Xml.parseElement(parser, result, namespaceDictionary, Atom.StopAtAtomEntry.INSTANCE);\r\n        close = false;\r\n        return result;\r\n    } finally {\r\n        if (close) {\r\n            close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.model.BudgetAmount.setAmount",
	"Comment": "sets the amount for the budgetthe absolute value of the amount is used",
	"Method": "void setAmount(Money amount){\r\n    this.mAmount = amount.abs();\r\n}"
}, {
	"Path": "org.gnucash.android.model.Commodity.getMnemonic",
	"Comment": "returns the mnemonic, or currency code for iso4217 currencies",
	"Method": "String getMnemonic(){\r\n    return mMnemonic;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.fetchAccountsOrderedByFullName",
	"Comment": "returns a cursor set of accounts which fulfill wherethis method returns the accounts list sorted by the full account name",
	"Method": "Cursor fetchAccountsOrderedByFullName(String where,String[] whereArgs){\r\n    Log.v(LOG_TAG, \"Fetching all accounts from db where \" + where);\r\n    return mDb.query(AccountEntry.TABLE_NAME, null, where, whereArgs, null, null, AccountEntry.COLUMN_FULL_NAME + \" ASC\");\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.db.BooksDbAdapterTest.deletingBook_shouldDeleteDbFile",
	"Comment": "test that deleting a book record also deletes the book database",
	"Method": "void deletingBook_shouldDeleteDbFile(){\r\n    String bookUID = createNewBookWithDefaultAccounts();\r\n    File dbPath = GnuCashApplication.getAppContext().getDatabasePath(bookUID);\r\n    assertThat(dbPath).exists();\r\n    BooksDbAdapter booksDbAdapter = BooksDbAdapter.getInstance();\r\n    assertThat(booksDbAdapter.getRecord(bookUID)).isNotNull();\r\n    long booksCount = booksDbAdapter.getRecordsCount();\r\n    booksDbAdapter.deleteBook(bookUID);\r\n    assertThat(dbPath).doesNotExist();\r\n    assertThat(booksDbAdapter.getRecordsCount()).isEqualTo(booksCount - 1);\r\n}"
}, {
	"Path": "ca.uhn.fhir.jpa.demo.FhirServerConfigCommon.getDaoConfig",
	"Comment": "configure fhir properties around the the jpa server via this bean",
	"Method": "DaoConfig getDaoConfig(){\r\n    DaoConfig daoConfig = new DaoConfig();\r\n    daoConfig.setSubscriptionEnabled(true);\r\n    daoConfig.setSubscriptionPollDelay(5000);\r\n    daoConfig.setSubscriptionPurgeInactiveAfterMillis(DateUtils.MILLIS_PER_HOUR);\r\n    daoConfig.setAllowMultipleDelete(true);\r\n    return daoConfig;\r\n}"
}, {
	"Path": "org.gnucash.android.util.PreferencesHelper.getLastExportTime",
	"Comment": "get the time for the last export operation of a specific book.",
	"Method": "Timestamp getLastExportTime(Timestamp getLastExportTime,String bookUID){\r\n    final String utcString = GnuCashApplication.getAppContext().getSharedPreferences(bookUID, Context.MODE_PRIVATE).getString(PREFERENCE_LAST_EXPORT_TIME_KEY, TimestampHelper.getUtcStringFromTimestamp(TimestampHelper.getTimestampFromEpochZero()));\r\n    Log.d(LOG_TAG, \"Retrieving '\" + utcString + \"' as lastExportTime from Android Preferences.\");\r\n    return TimestampHelper.getTimestampFromUtcString(utcString);\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.services.AbstractGoogleClientRequest.buildHttpRequestUsingHead",
	"Comment": "create a request suitable for use against this service, but using head instead of get.only supported when the original request method is get.subclasses may override by calling the super implementation.",
	"Method": "HttpRequest buildHttpRequestUsingHead(){\r\n    return buildHttpRequest(true);\r\n}"
}, {
	"Path": "ca.uhn.fhir.rest.server.exceptions.BaseServerResponseException.getResponseHeaders",
	"Comment": "returns a map containing any headers which should be added to the outgoing\tresponse. this methos creates the map if none exists, so it will never\treturn null",
	"Method": "Map<String, List<String>> getResponseHeaders(){\r\n    if (myResponseHeaders == null) {\r\n        myResponseHeaders = new HashMap<String, List<String>>();\r\n    }\r\n    return myResponseHeaders;\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.getRecurrence",
	"Comment": "return guid of recurrence pattern for this scheduled action",
	"Method": "Recurrence getRecurrence(){\r\n    return mRecurrence;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Account.getFullName",
	"Comment": "returns the full name of this account.the full name is the full account hierarchy name",
	"Method": "String getFullName(){\r\n    return mFullName;\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.json.GoogleJsonError.parse",
	"Comment": "parses the given error http response using the given json factory.",
	"Method": "GoogleJsonError parse(JsonFactory jsonFactory,HttpResponse response){\r\n    JsonObjectParser jsonObjectParser = new JsonObjectParser.Builder(jsonFactory).setWrapperKeys(Collections.singleton(\"error\")).build();\r\n    return jsonObjectParser.parseAndClose(response.getContent(), response.getContentCharset(), GoogleJsonError.class);\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.db.AccountsDbAdapterTest.initAdapters",
	"Comment": "initialize database adapters for a specific book.this method should be called everytime a new book is loaded into the database",
	"Method": "void initAdapters(String bookUID){\r\n    if (bookUID == null) {\r\n        mSplitsDbAdapter = SplitsDbAdapter.getInstance();\r\n        mTransactionsDbAdapter = TransactionsDbAdapter.getInstance();\r\n        mAccountsDbAdapter = AccountsDbAdapter.getInstance();\r\n        mCommoditiesDbAdapter = CommoditiesDbAdapter.getInstance();\r\n    } else {\r\n        DatabaseHelper databaseHelper = new DatabaseHelper(GnuCashApplication.getAppContext(), bookUID);\r\n        SQLiteDatabase db = databaseHelper.getWritableDatabase();\r\n        mSplitsDbAdapter = new SplitsDbAdapter(db);\r\n        mTransactionsDbAdapter = new TransactionsDbAdapter(db, mSplitsDbAdapter);\r\n        mAccountsDbAdapter = new AccountsDbAdapter(db, mTransactionsDbAdapter);\r\n        mCommoditiesDbAdapter = new CommoditiesDbAdapter(db);\r\n        BooksDbAdapter.getInstance().setActive(bookUID);\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.setAutoCreate",
	"Comment": "set flag for automatically creating transaction based on this scheduled actionthis flag is currently unused in the app. it is only included here for compatibility with gnucash desktop xml",
	"Method": "void setAutoCreate(boolean autoCreate){\r\n    this.mAutoCreate = autoCreate;\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.db.BooksDbAdapterTest.testGeneratedDisplayNames_shouldBeUnique",
	"Comment": "test that book names never conflict and that the ordinal attached to the book name isincreased irrespective of the order in which books are added to and deleted from the db",
	"Method": "void testGeneratedDisplayNames_shouldBeUnique(){\r\n    Book book1 = new Book(BaseModel.generateUID());\r\n    Book book2 = new Book(BaseModel.generateUID());\r\n    Book book3 = new Book(BaseModel.generateUID());\r\n    mBooksDbAdapter.addRecord(book1);\r\n    mBooksDbAdapter.addRecord(book2);\r\n    mBooksDbAdapter.addRecord(book3);\r\n    assertThat(mBooksDbAdapter.getRecordsCount()).isEqualTo(3L);\r\n    mBooksDbAdapter.deleteRecord(book2.getUID());\r\n    assertThat(mBooksDbAdapter.getRecordsCount()).isEqualTo(2L);\r\n    String generatedName = mBooksDbAdapter.generateDefaultBookName();\r\n    assertThat(generatedName).isNotEqualTo(book3.getDisplayName());\r\n    assertThat(generatedName).isEqualTo(\"Book 4\");\r\n}"
}, {
	"Path": "org.gnucash.android.ui.report.sheet.BalanceSheetFragment.loadAccountViews",
	"Comment": "loads rows for the individual accounts and adds them to the report",
	"Method": "void loadAccountViews(List<AccountType> accountTypes,TableLayout tableLayout){\r\n    LayoutInflater inflater = LayoutInflater.from(getActivity());\r\n    Cursor cursor = mAccountsDbAdapter.fetchAccounts(DatabaseSchema.AccountEntry.COLUMN_TYPE + \" IN ( '\" + TextUtils.join(\"' , '\", accountTypes) + \"' ) AND \" + DatabaseSchema.AccountEntry.COLUMN_PLACEHOLDER + \" = 0\", null, DatabaseSchema.AccountEntry.COLUMN_FULL_NAME + \" ASC\");\r\n    while (cursor.moveToNext()) {\r\n        String accountUID = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseSchema.AccountEntry.COLUMN_UID));\r\n        String name = cursor.getString(cursor.getColumnIndexOrThrow(DatabaseSchema.AccountEntry.COLUMN_NAME));\r\n        Money balance = mAccountsDbAdapter.getAccountBalance(accountUID);\r\n        View view = inflater.inflate(R.layout.row_balance_sheet, tableLayout, false);\r\n        ((TextView) view.findViewById(R.id.account_name)).setText(name);\r\n        TextView balanceTextView = (TextView) view.findViewById(R.id.account_balance);\r\n        TransactionsActivity.displayBalance(balanceTextView, balance);\r\n        tableLayout.addView(view);\r\n    }\r\n    View totalView = inflater.inflate(R.layout.row_balance_sheet, tableLayout, false);\r\n    TableLayout.LayoutParams layoutParams = (TableLayout.LayoutParams) totalView.getLayoutParams();\r\n    layoutParams.setMargins(layoutParams.leftMargin, 20, layoutParams.rightMargin, layoutParams.bottomMargin);\r\n    totalView.setLayoutParams(layoutParams);\r\n    TextView accountName = (TextView) totalView.findViewById(R.id.account_name);\r\n    accountName.setTextSize(16);\r\n    accountName.setText(R.string.label_balance_sheet_total);\r\n    TextView accountBalance = (TextView) totalView.findViewById(R.id.account_balance);\r\n    accountBalance.setTextSize(16);\r\n    accountBalance.setTypeface(null, Typeface.BOLD);\r\n    TransactionsActivity.displayBalance(accountBalance, mAccountsDbAdapter.getAccountBalance(accountTypes, -1, System.currentTimeMillis()));\r\n    tableLayout.addView(totalView);\r\n}"
}, {
	"Path": "ca.uhn.fhir.jpa.cds.example.CdsExampleTests.PatientMeasureTest",
	"Comment": "testing individual measure\t\tthis test patient satisfies all the group population criteria for this measure.",
	"Method": "void PatientMeasureTest(){\r\n    putResource(\"patient-measure-test-bundle.json\", \"\");\r\n    Parameters inParams = new Parameters();\r\n    inParams.addParameter().setName(\"patient\").setValue(new StringType(\"Patient/Patient-6529\"));\r\n    inParams.addParameter().setName(\"periodStart\").setValue(new DateType(\"2003-01-01\"));\r\n    inParams.addParameter().setName(\"periodEnd\").setValue(new DateType(\"2003-12-31\"));\r\n    Parameters outParams = ourClient.operation().onInstance(new IdDt(\"Measure\", \"measure-asf\")).named(\"$evaluate-measure\").withParameters(inParams).useHttpGet().execute();\r\n    List<Parameters.ParametersParameterComponent> response = outParams.getParameter();\r\n    Assert.assertTrue(!response.isEmpty());\r\n    Parameters.ParametersParameterComponent component = response.get(0);\r\n    Assert.assertTrue(component.getResource() instanceof MeasureReport);\r\n    MeasureReport report = (MeasureReport) component.getResource();\r\n    for (MeasureReport.MeasureReportGroupComponent group : report.getGroup()) {\r\n        for (MeasureReport.MeasureReportGroupPopulationComponent population : group.getPopulation()) {\r\n            Assert.assertTrue(population.getCount() > 0);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.BudgetAmountsDbAdapter.getBudgetAmountSum",
	"Comment": "returns the sum of the budget amounts for a particular account",
	"Method": "Money getBudgetAmountSum(String accountUID){\r\n    List<BudgetAmount> budgetAmounts = getBudgetAmounts(accountUID);\r\n    Money sum = Money.createZeroInstance(getAccountCurrencyCode(accountUID));\r\n    for (BudgetAmount budgetAmount : budgetAmounts) {\r\n        sum = sum.add(budgetAmount.getAmount());\r\n    }\r\n    return sum;\r\n}"
}, {
	"Path": "com.google.api.client.testing.http.MockLowLevelHttpResponse.getHeaderValues",
	"Comment": "returns the list of header values of http response.default value is an empty list.",
	"Method": "List<String> getHeaderValues(){\r\n    return headerValues;\r\n}"
}, {
	"Path": "org.gnucash.android.export.Exporter.buildExportFilename",
	"Comment": "builds a file name based on the current time stamp for the exported file",
	"Method": "String buildExportFilename(ExportFormat format,String bookName){\r\n    return EXPORT_FILENAME_DATE_FORMAT.format(new Date(System.currentTimeMillis())) + \"_gnucash_export_\" + sanitizeFilename(bookName) + (format == ExportFormat.CSVA ? \"_accounts\" : \"\") + (format == ExportFormat.CSVT ? \"_transactions\" : \"\") + format.getExtension();\r\n}"
}, {
	"Path": "org.gnucash.android.ui.settings.BackupPreferenceFragment.toggleOwnCloudPreference",
	"Comment": "toggles the checkbox of the owncloud sync preference if an owncloud account is linked",
	"Method": "void toggleOwnCloudPreference(Preference pref){\r\n    SharedPreferences mPrefs = getActivity().getSharedPreferences(getString(R.string.owncloud_pref), Context.MODE_PRIVATE);\r\n    ((CheckBoxPreference) pref).setChecked(mPrefs.getBoolean(getString(R.string.owncloud_sync), false));\r\n}"
}, {
	"Path": "com.google.api.client.xml.XmlTest.testFailMappingOfDataType",
	"Comment": "negative test that maps a string to an integer and causes an exception.",
	"Method": "void testFailMappingOfDataType(){\r\n    SimpleTypeNumeric xml = new SimpleTypeNumeric();\r\n    XmlPullParser parser = Xml.createParser();\r\n    parser.setInput(new StringReader(SIMPLE_XML));\r\n    XmlNamespaceDictionary namespaceDictionary = new XmlNamespaceDictionary().set(\"\", \"\");\r\n    try {\r\n        Xml.parseElement(parser, xml, namespaceDictionary, null);\r\n        fail();\r\n    } catch (final Exception e) {\r\n        assertEquals(\"For input string: \\\"test\\\"\", e.getMessage().trim());\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.model.Money.formattedString",
	"Comment": "returns a string representation of the money object formatted according to \tthe locale and includes the currency symbol. \tthe output precision is limited to the number of fractional digits supported by the currency",
	"Method": "String formattedString(Locale locale,String formattedString){\r\n    return formattedString(Locale.getDefault());\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.loadAccountTypesList",
	"Comment": "loads the list of account types into the account type selector spinner",
	"Method": "void loadAccountTypesList(){\r\n    String[] accountTypes = getResources().getStringArray(R.array.account_type_entry_values);\r\n    ArrayAdapter<String> accountTypesAdapter = new ArrayAdapter(getActivity(), android.R.layout.simple_list_item_1, accountTypes);\r\n    accountTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\r\n    mAccountTypeSpinner.setAdapter(accountTypesAdapter);\r\n}"
}, {
	"Path": "ca.uhn.fhir.jpa.demo.FhirServerConfig.responseHighlighterInterceptor",
	"Comment": "this interceptor adds some pretty syntax highlighting in responses when a browser is detected",
	"Method": "IServerInterceptor responseHighlighterInterceptor(){\r\n    ResponseHighlighterInterceptor retVal = new ResponseHighlighterInterceptor();\r\n    return retVal;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.settings.dialog.OwnCloudDialogFragment.newInstance",
	"Comment": "use this factory method to create a new instance ofthis fragment using the provided parameters.",
	"Method": "OwnCloudDialogFragment newInstance(Preference pref){\r\n    OwnCloudDialogFragment fragment = new OwnCloudDialogFragment();\r\n    ocCheckBox = pref == null ? null : (CheckBoxPreference) pref;\r\n    return fragment;\r\n}"
}, {
	"Path": "ca.uhn.fhir.context.FhirContext.hasDefaultTypeForProfile",
	"Comment": "returns true if any default types for specific profiles have been defined\twithin this context.",
	"Method": "boolean hasDefaultTypeForProfile(){\r\n    validateInitialized();\r\n    return !myDefaultTypeForProfile.isEmpty();\r\n}"
}, {
	"Path": "org.gnucash.android.ui.report.ReportsActivity.updateDateRangeOnFragment",
	"Comment": "updates the reporting time range for all listening fragments",
	"Method": "void updateDateRangeOnFragment(){\r\n    List<Fragment> fragments = getSupportFragmentManager().getFragments();\r\n    for (Fragment fragment : fragments) {\r\n        if (fragment instanceof ReportOptionsListener) {\r\n            ((ReportOptionsListener) fragment).onTimeRangeUpdated(mReportPeriodStart, mReportPeriodEnd);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "ca.uhn.fhir.jpa.demo.FhirServerConfigDstu2.loggingInterceptor",
	"Comment": "do some fancy logging to create a nice access log that has details about each incoming request.",
	"Method": "IServerInterceptor loggingInterceptor(){\r\n    return FhirServerConfigCommon.loggingInterceptor();\r\n}"
}, {
	"Path": "org.gnucash.android.export.ExportParams.shouldDeleteTransactionsAfterExport",
	"Comment": "returns flag whether transactions should be deleted after export",
	"Method": "boolean shouldDeleteTransactionsAfterExport(){\r\n    return mDeleteTransactionsAfterExport;\r\n}"
}, {
	"Path": "com.google.api.client.util.Base64.encodeBase64String",
	"Comment": "encodes binary data using the base64 algorithm but does not chunk the output.",
	"Method": "String encodeBase64String(byte[] binaryData){\r\n    return org.apache.commons.codec.binary.Base64.encodeBase64String(binaryData);\r\n}"
}, {
	"Path": "com.google.api.client.http.HttpResponseException.computeMessageBuffer",
	"Comment": "returns an exception message string builder to use for the given http response.",
	"Method": "StringBuilder computeMessageBuffer(HttpResponse response){\r\n    StringBuilder builder = new StringBuilder();\r\n    int statusCode = response.getStatusCode();\r\n    if (statusCode != 0) {\r\n        builder.append(statusCode);\r\n    }\r\n    String statusMessage = response.getStatusMessage();\r\n    if (statusMessage != null) {\r\n        if (statusCode != 0) {\r\n            builder.append(' ');\r\n        }\r\n        builder.append(statusMessage);\r\n    }\r\n    return builder;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Split.isPairOf",
	"Comment": "checks is this other is a pair split of this.two splits are considered a pair if they have the same amount andopposite split types",
	"Method": "boolean isPairOf(Split other){\r\n    return mValue.equals(other.mValue) && mSplitType.invert().equals(other.mSplitType);\r\n}"
}, {
	"Path": "org.gnucash.android.model.Money.subtract",
	"Comment": "returns a new money object whose value is the difference of the values of \tthis object and subtrahend.\tthis object is the minuend and the parameter is the subtrahend",
	"Method": "Money subtract(Money subtrahend){\r\n    if (!mCommodity.equals(subtrahend.mCommodity))\r\n        throw new CurrencyMismatchException();\r\n    BigDecimal bigD = mAmount.subtract(subtrahend.mAmount);\r\n    return new Money(bigD, mCommodity);\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.media.MediaHttpUploader.executeCurrentRequest",
	"Comment": "executes the current request with some common code that includes exponential backoff and gzipencoding.",
	"Method": "HttpResponse executeCurrentRequest(HttpRequest request){\r\n    if (!disableGZipContent && !(request.getContent() instanceof EmptyContent)) {\r\n        request.setEncoding(new GZipEncoding());\r\n    }\r\n    HttpResponse response = executeCurrentRequestWithoutGZip(request);\r\n    return response;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Account.setTransactions",
	"Comment": "sets a list of transactions for this account.overrides any previous transactions with those in the list.the account uid and currency of the transactions will be set to the unique idand currency of the account respectively",
	"Method": "void setTransactions(List<Transaction> transactionsList){\r\n    this.mTransactionsList = transactionsList;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.settings.BackupPreferenceFragment.restoreBackup",
	"Comment": "opens a dialog for a user to select a backup to restore and then restores the backup",
	"Method": "void restoreBackup(){\r\n    Log.i(\"Settings\", \"Opening GnuCash XML backups for restore\");\r\n    final String bookUID = BooksDbAdapter.getInstance().getActiveBookUID();\r\n    final String defaultBackupFile = BackupManager.getBookBackupFileUri(bookUID);\r\n    if (defaultBackupFile != null) {\r\n        android.support.v7.app.AlertDialog.Builder builder = new android.support.v7.app.AlertDialog.Builder(getActivity()).setTitle(R.string.title_confirm_restore_backup).setMessage(R.string.msg_confirm_restore_backup_into_new_book).setNegativeButton(R.string.btn_cancel, new DialogInterface.OnClickListener() {\r\n            @Override\r\n            public void onClick(DialogInterface dialog, int which) {\r\n                dialog.dismiss();\r\n            }\r\n        }).setPositiveButton(R.string.btn_restore, new DialogInterface.OnClickListener() {\r\n            @Override\r\n            public void onClick(DialogInterface dialogInterface, int i) {\r\n                new ImportAsyncTask(getActivity()).execute(Uri.parse(defaultBackupFile));\r\n            }\r\n        });\r\n        builder.create().show();\r\n        return;\r\n    }\r\n    if (BackupManager.getBackupList(bookUID).isEmpty()) {\r\n        android.support.v7.app.AlertDialog.Builder builder = new android.support.v7.app.AlertDialog.Builder(getActivity()).setTitle(R.string.title_no_backups_found).setMessage(R.string.msg_no_backups_to_restore_from).setNegativeButton(R.string.label_dismiss, new DialogInterface.OnClickListener() {\r\n            @Override\r\n            public void onClick(DialogInterface dialog, int which) {\r\n                dialog.dismiss();\r\n            }\r\n        });\r\n        builder.create().show();\r\n        return;\r\n    }\r\n    final ArrayAdapter<String> arrayAdapter = new ArrayAdapter(getActivity(), android.R.layout.select_dialog_singlechoice);\r\n    final DateFormat dateFormatter = SimpleDateFormat.getDateTimeInstance();\r\n    for (File backupFile : BackupManager.getBackupList(bookUID)) {\r\n        long time = Exporter.getExportTime(backupFile.getName());\r\n        if (time > 0)\r\n            arrayAdapter.add(dateFormatter.format(new Date(time)));\r\n        else\r\n            arrayAdapter.add(backupFile.getName());\r\n    }\r\n    AlertDialog.Builder restoreDialogBuilder = new AlertDialog.Builder(getActivity());\r\n    restoreDialogBuilder.setTitle(R.string.title_select_backup_to_restore);\r\n    restoreDialogBuilder.setNegativeButton(R.string.alert_dialog_cancel, new DialogInterface.OnClickListener() {\r\n        @Override\r\n        public void onClick(DialogInterface dialog, int which) {\r\n            dialog.dismiss();\r\n        }\r\n    });\r\n    restoreDialogBuilder.setAdapter(arrayAdapter, new DialogInterface.OnClickListener() {\r\n        @Override\r\n        public void onClick(DialogInterface dialog, int which) {\r\n            File backupFile = BackupManager.getBackupList(bookUID).get(which);\r\n            new ImportAsyncTask(getActivity()).execute(Uri.fromFile(backupFile));\r\n        }\r\n    });\r\n    restoreDialogBuilder.create().show();\r\n}"
}, {
	"Path": "org.gnucash.android.ui.settings.BackupPreferenceFragment.restoreBackup",
	"Comment": "opens a dialog for a user to select a backup to restore and then restores the backup",
	"Method": "void restoreBackup(){\r\n    dialog.dismiss();\r\n}"
}, {
	"Path": "org.gnucash.android.ui.settings.BackupPreferenceFragment.restoreBackup",
	"Comment": "opens a dialog for a user to select a backup to restore and then restores the backup",
	"Method": "void restoreBackup(){\r\n    new ImportAsyncTask(getActivity()).execute(Uri.parse(defaultBackupFile));\r\n}"
}, {
	"Path": "org.gnucash.android.ui.settings.BackupPreferenceFragment.restoreBackup",
	"Comment": "opens a dialog for a user to select a backup to restore and then restores the backup",
	"Method": "void restoreBackup(){\r\n    dialog.dismiss();\r\n}"
}, {
	"Path": "org.gnucash.android.ui.settings.BackupPreferenceFragment.restoreBackup",
	"Comment": "opens a dialog for a user to select a backup to restore and then restores the backup",
	"Method": "void restoreBackup(){\r\n    dialog.dismiss();\r\n}"
}, {
	"Path": "org.gnucash.android.ui.settings.BackupPreferenceFragment.restoreBackup",
	"Comment": "opens a dialog for a user to select a backup to restore and then restores the backup",
	"Method": "void restoreBackup(){\r\n    File backupFile = BackupManager.getBackupList(bookUID).get(which);\r\n    new ImportAsyncTask(getActivity()).execute(Uri.fromFile(backupFile));\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.DatabaseAdapter.getAttribute",
	"Comment": "returns an attribute from a specific column in the database for a specific record.the attribute is returned as a string which can then be converted to another type ifthe caller was expecting something other type",
	"Method": "String getAttribute(String recordUID,String columnName,String getAttribute,String tableName,String recordUID,String columnName){\r\n    Cursor cursor = mDb.query(tableName, new String[] { columnName }, AccountEntry.COLUMN_UID + \" = ?\", new String[] { recordUID }, null, null, null);\r\n    try {\r\n        if (cursor.moveToFirst())\r\n            return cursor.getString(cursor.getColumnIndexOrThrow(columnName));\r\n        else {\r\n            throw new IllegalArgumentException(String.format(\"Record with GUID %s does not exist in the db\", recordUID));\r\n        }\r\n    } finally {\r\n        cursor.close();\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.fetchTopLevelAccounts",
	"Comment": "returns the top level accounts i.e. accounts with no parent or with the gnucash root account as parent",
	"Method": "Cursor fetchTopLevelAccounts(){\r\n    return fetchAccounts(\"(\" + AccountEntry.COLUMN_PARENT_ACCOUNT_UID + \" IS NULL OR \" + AccountEntry.COLUMN_PARENT_ACCOUNT_UID + \" = ?) AND \" + AccountEntry.COLUMN_HIDDEN + \" = 0 AND \" + AccountEntry.COLUMN_TYPE + \" != ?\", new String[] { getOrCreateGnuCashRootAccountUID(), AccountType.ROOT.name() }, AccountEntry.COLUMN_NAME + \" ASC\");\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.buildModelInstance",
	"Comment": "builds an account instance with the provided cursor and loads its corresponding transactions.",
	"Method": "Account buildModelInstance(Cursor c){\r\n    Account account = buildSimpleAccountInstance(c);\r\n    account.setTransactions(mTransactionsAdapter.getAllTransactionsForAccount(account.getUID()));\r\n    return account;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.fetchAllRecordsOrderedByFullName",
	"Comment": "returns a cursor to all account records in the database ordered by full name.gnucash root accounts and hidden accounts will not be included in the result set.",
	"Method": "Cursor fetchAllRecordsOrderedByFullName(){\r\n    Log.v(LOG_TAG, \"Fetching all accounts from db\");\r\n    String selection = AccountEntry.COLUMN_HIDDEN + \" = 0 AND \" + AccountEntry.COLUMN_TYPE + \" != ?\";\r\n    return mDb.query(AccountEntry.TABLE_NAME, null, selection, new String[] { AccountType.ROOT.name() }, null, null, AccountEntry.COLUMN_FULL_NAME + \" ASC\");\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.getScheduledTransactionsForAccount",
	"Comment": "returns a list of all scheduled transactions in the database",
	"Method": "List<Transaction> getScheduledTransactionsForAccount(String accountUID){\r\n    Cursor cursor = fetchScheduledTransactionsForAccount(accountUID);\r\n    List<Transaction> scheduledTransactions = new ArrayList();\r\n    try {\r\n        while (cursor.moveToNext()) {\r\n            scheduledTransactions.add(buildModelInstance(cursor));\r\n        }\r\n        return scheduledTransactions;\r\n    } finally {\r\n        cursor.close();\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.getBalance",
	"Comment": "returns the transaction balance for the transaction for the specified account.we consider only those splits which belong to this account",
	"Method": "Money getBalance(String transactionUID,String accountUID){\r\n    List<Split> splitList = mSplitsDbAdapter.getSplitsForTransactionInAccount(transactionUID, accountUID);\r\n    return Transaction.computeBalance(accountUID, splitList);\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.service.ScheduledActionServiceTest.exceededExecutionCounts_shouldNotRun",
	"Comment": "transactions whose execution count has reached or exceeded the planned execution count",
	"Method": "void exceededExecutionCounts_shouldNotRun(){\r\n    ScheduledAction scheduledAction = new ScheduledAction(ScheduledAction.ActionType.TRANSACTION);\r\n    scheduledAction.setActionUID(mActionUID);\r\n    scheduledAction.setStartTime(new DateTime(2015, 5, 31, 14, 0).getMillis());\r\n    scheduledAction.setEnabled(true);\r\n    scheduledAction.setRecurrence(new Recurrence(PeriodType.WEEK));\r\n    scheduledAction.setTotalPlannedExecutionCount(4);\r\n    scheduledAction.setExecutionCount(4);\r\n    List<ScheduledAction> actions = new ArrayList();\r\n    actions.add(scheduledAction);\r\n    TransactionsDbAdapter trxnAdapter = TransactionsDbAdapter.getInstance();\r\n    assertThat(trxnAdapter.getRecordsCount()).isZero();\r\n    ScheduledActionService.processScheduledActions(actions, mDb);\r\n    assertThat(trxnAdapter.getRecordsCount()).isZero();\r\n}"
}, {
	"Path": "com.google.api.client.xml.XmlNamespaceDictionary.getNamespaceAliasForUriErrorOnUnknown",
	"Comment": "returns the namespace alias to use for a given namespace uri, throwing an exception if thenamespace uri can be found in this dictionary.",
	"Method": "String getNamespaceAliasForUriErrorOnUnknown(String namespaceUri){\r\n    String result = getAliasForUri(namespaceUri);\r\n    Preconditions.checkArgument(result != null, \"invalid XML: no alias declared for namesapce <%s>; \" + \"work-around by setting XML namepace directly by calling the set method of %s\", namespaceUri, XmlNamespaceDictionary.class.getName());\r\n    return result;\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.setAdvanceCreateDays",
	"Comment": "set number of days in advance to create the transactionthis flag is currently unused in the app. it is only included here for compatibility with gnucash desktop xml",
	"Method": "void setAdvanceCreateDays(int advanceCreateDays){\r\n    this.mAdvanceCreateDays = advanceCreateDays;\r\n}"
}, {
	"Path": "com.google.api.client.testing.util.TestableByteArrayInputStream.getBuffer",
	"Comment": "returns the written buffer value as a modifiable byte array.",
	"Method": "byte[] getBuffer(){\r\n    return buf;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.settings.PreferenceActivity.loadFragment",
	"Comment": "load the provided fragment into the right pane, replacing the previous one",
	"Method": "void loadFragment(Fragment fragment){\r\n    FragmentManager fragmentManager = getSupportFragmentManager();\r\n    FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\r\n    fragmentTransaction.replace(R.id.fragment_container, fragment);\r\n    fragmentTransaction.commit();\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.extensions.appengine.auth.oauth2.AppIdentityCredential.getAppIdentityService",
	"Comment": "gets the app identity service that provides the access token.",
	"Method": "AppIdentityService getAppIdentityService(AppIdentityService getAppIdentityService){\r\n    return appIdentityService;\r\n}"
}, {
	"Path": "org.gnucash.android.model.BaseModel.getCreatedTimestamp",
	"Comment": "returns the timestamp when this model entry was created in the database",
	"Method": "Timestamp getCreatedTimestamp(){\r\n    return mCreatedTimestamp;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.SplitsDbAdapter.fetchSplits",
	"Comment": "fetches a collection of splits for a given condition and sorted by sortorder",
	"Method": "Cursor fetchSplits(String where,String[] whereArgs,String sortOrder){\r\n    return mDb.query(SplitEntry.TABLE_NAME, null, where, whereArgs, null, null, sortOrder);\r\n}"
}, {
	"Path": "org.gnucash.android.db.DatabaseHelper.createDatabaseTables",
	"Comment": "creates the tables in the database and import default commodities into the database",
	"Method": "void createDatabaseTables(SQLiteDatabase db){\r\n    Log.i(LOG_TAG, \"Creating database tables\");\r\n    db.execSQL(ACCOUNTS_TABLE_CREATE);\r\n    db.execSQL(TRANSACTIONS_TABLE_CREATE);\r\n    db.execSQL(SPLITS_TABLE_CREATE);\r\n    db.execSQL(SCHEDULED_ACTIONS_TABLE_CREATE);\r\n    db.execSQL(COMMODITIES_TABLE_CREATE);\r\n    db.execSQL(PRICES_TABLE_CREATE);\r\n    db.execSQL(RECURRENCE_TABLE_CREATE);\r\n    db.execSQL(BUDGETS_TABLE_CREATE);\r\n    db.execSQL(BUDGET_AMOUNTS_TABLE_CREATE);\r\n    String createAccountUidIndex = \"CREATE UNIQUE INDEX '\" + AccountEntry.INDEX_UID + \"' ON \" + AccountEntry.TABLE_NAME + \"(\" + AccountEntry.COLUMN_UID + \")\";\r\n    String createTransactionUidIndex = \"CREATE UNIQUE INDEX '\" + TransactionEntry.INDEX_UID + \"' ON \" + TransactionEntry.TABLE_NAME + \"(\" + TransactionEntry.COLUMN_UID + \")\";\r\n    String createSplitUidIndex = \"CREATE UNIQUE INDEX '\" + SplitEntry.INDEX_UID + \"' ON \" + SplitEntry.TABLE_NAME + \"(\" + SplitEntry.COLUMN_UID + \")\";\r\n    String createScheduledEventUidIndex = \"CREATE UNIQUE INDEX '\" + ScheduledActionEntry.INDEX_UID + \"' ON \" + ScheduledActionEntry.TABLE_NAME + \"(\" + ScheduledActionEntry.COLUMN_UID + \")\";\r\n    String createCommodityUidIndex = \"CREATE UNIQUE INDEX '\" + CommodityEntry.INDEX_UID + \"' ON \" + CommodityEntry.TABLE_NAME + \"(\" + CommodityEntry.COLUMN_UID + \")\";\r\n    String createPriceUidIndex = \"CREATE UNIQUE INDEX '\" + PriceEntry.INDEX_UID + \"' ON \" + PriceEntry.TABLE_NAME + \"(\" + PriceEntry.COLUMN_UID + \")\";\r\n    String createBudgetUidIndex = \"CREATE UNIQUE INDEX '\" + BudgetEntry.INDEX_UID + \"' ON \" + BudgetEntry.TABLE_NAME + \"(\" + BudgetEntry.COLUMN_UID + \")\";\r\n    String createBudgetAmountUidIndex = \"CREATE UNIQUE INDEX '\" + BudgetAmountEntry.INDEX_UID + \"' ON \" + BudgetAmountEntry.TABLE_NAME + \"(\" + BudgetAmountEntry.COLUMN_UID + \")\";\r\n    String createRecurrenceUidIndex = \"CREATE UNIQUE INDEX '\" + RecurrenceEntry.INDEX_UID + \"' ON \" + RecurrenceEntry.TABLE_NAME + \"(\" + RecurrenceEntry.COLUMN_UID + \")\";\r\n    db.execSQL(createAccountUidIndex);\r\n    db.execSQL(createTransactionUidIndex);\r\n    db.execSQL(createSplitUidIndex);\r\n    db.execSQL(createScheduledEventUidIndex);\r\n    db.execSQL(createCommodityUidIndex);\r\n    db.execSQL(createPriceUidIndex);\r\n    db.execSQL(createBudgetUidIndex);\r\n    db.execSQL(createRecurrenceUidIndex);\r\n    db.execSQL(createBudgetAmountUidIndex);\r\n    try {\r\n        MigrationHelper.importCommodities(db);\r\n    } catch (SAXException | ParserConfigurationException | IOException e) {\r\n        Log.e(LOG_TAG, \"Error loading currencies into the database\");\r\n        e.printStackTrace();\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.xml.Xml.parseAttributeOrTextContent",
	"Comment": "parses the string value of an attribute value or text content.",
	"Method": "void parseAttributeOrTextContent(String stringValue,Field field,Type valueType,List<Type> context,Object destination,GenericXml genericXml,Map<String, Object> destinationMap,String name){\r\n    if (field != null || genericXml != null || destinationMap != null) {\r\n        valueType = field == null ? valueType : field.getGenericType();\r\n        Object value = parseValue(valueType, context, stringValue);\r\n        setValue(value, field, destination, genericXml, destinationMap, name);\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.getAllTransactionsForAccount",
	"Comment": "returns list of all transactions for account with uid accountuid",
	"Method": "List<Transaction> getAllTransactionsForAccount(String accountUID){\r\n    Cursor c = fetchAllTransactionsForAccount(accountUID);\r\n    ArrayList<Transaction> transactionsList = new ArrayList();\r\n    try {\r\n        while (c.moveToNext()) {\r\n            transactionsList.add(buildModelInstance(c));\r\n        }\r\n    } finally {\r\n        c.close();\r\n    }\r\n    return transactionsList;\r\n}"
}, {
	"Path": "org.gnucash.android.export.ExportAsyncTask.moveExportToUri",
	"Comment": "move the exported files to a specified uri.this uri could be a storage access framework file",
	"Method": "void moveExportToUri(){\r\n    Uri exportUri = Uri.parse(mExportParams.getExportLocation());\r\n    if (exportUri == null) {\r\n        Log.w(TAG, \"No URI found for export destination\");\r\n        return;\r\n    }\r\n    if (mExportedFiles.size() > 0) {\r\n        try {\r\n            OutputStream outputStream = mContext.getContentResolver().openOutputStream(exportUri);\r\n            org.gnucash.android.util.FileUtils.moveFile(mExportedFiles.get(0), outputStream);\r\n        } catch (IOException ex) {\r\n            throw new Exporter.ExporterException(mExportParams, \"Error when moving file to URI\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.media.MediaHttpUploader.getDisableGZipContent",
	"Comment": "returns whether to disable gzip compression of http content.",
	"Method": "boolean getDisableGZipContent(){\r\n    return disableGZipContent;\r\n}"
}, {
	"Path": "com.google.api.client.testing.http.MockLowLevelHttpRequest.getContentAsString",
	"Comment": "returns http content as a string, taking care of any encodings of the content if necessary.returns an empty string if there is no http content.",
	"Method": "String getContentAsString(){\r\n    if (getStreamingContent() == null) {\r\n        return \"\";\r\n    }\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    getStreamingContent().writeTo(out);\r\n    String contentEncoding = getContentEncoding();\r\n    if (contentEncoding != null && contentEncoding.contains(\"gzip\")) {\r\n        InputStream contentInputStream = new GZIPInputStream(new ByteArrayInputStream(out.toByteArray()));\r\n        out = new ByteArrayOutputStream();\r\n        IOUtils.copy(contentInputStream, out);\r\n    }\r\n    String contentType = getContentType();\r\n    HttpMediaType mediaType = contentType != null ? new HttpMediaType(contentType) : null;\r\n    Charset charset = mediaType == null || mediaType.getCharsetParameter() == null ? Charsets.ISO_8859_1 : mediaType.getCharsetParameter();\r\n    return out.toString(charset.name());\r\n}"
}, {
	"Path": "ca.uhn.fhir.context.FhirContext.getResourceDefinitionsWithExplicitId",
	"Comment": "returns the scanned runtime models. this is an advanced feature which is generally only needed for extending the\tcore library.",
	"Method": "Collection<RuntimeResourceDefinition> getResourceDefinitionsWithExplicitId(){\r\n    validateInitialized();\r\n    return myIdToResourceDefinition.values();\r\n}"
}, {
	"Path": "org.gnucash.android.model.BaseModel.generateUID",
	"Comment": "method for generating the global unique id for the model object",
	"Method": "String generateUID(){\r\n    return UUID.randomUUID().toString().replaceAll(\"-\", \"\");\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.model.ScheduledActionTest.weeklyActionsWithMultiplier_shouldBeDueOnTheDayOfWeekSet",
	"Comment": "weekly actions scheduled with multiplier should skip intermediateweeks and be due in the specified day of the week.",
	"Method": "void weeklyActionsWithMultiplier_shouldBeDueOnTheDayOfWeekSet(){\r\n    ScheduledAction scheduledAction = new ScheduledAction(ScheduledAction.ActionType.BACKUP);\r\n    Recurrence recurrence = new Recurrence(PeriodType.WEEK);\r\n    recurrence.setMultiplier(2);\r\n    recurrence.setByDays(Collections.singletonList(Calendar.WEDNESDAY));\r\n    scheduledAction.setRecurrence(recurrence);\r\n    scheduledAction.setStartTime(new DateTime(2016, 6, 6, 9, 0).getMillis());\r\n    scheduledAction.setLastRun(new DateTime(2017, 4, 12, 9, 0).getMillis());\r\n    long expectedNextDueDate = new DateTime(2017, 4, 26, 9, 0).getMillis();\r\n    assertThat(scheduledAction.computeNextTimeBasedScheduledExecutionTime()).isEqualTo(expectedNextDueDate);\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.service.ScheduledActionServiceTest.scheduledBackups_shouldIncludeTransactionsAfterTheLastRun",
	"Comment": "tests that an scheduled backup includes transactions added or modifiedafter the last run.",
	"Method": "void scheduledBackups_shouldIncludeTransactionsAfterTheLastRun(){\r\n    ScheduledAction scheduledBackup = new ScheduledAction(ScheduledAction.ActionType.BACKUP);\r\n    scheduledBackup.setStartTime(LocalDateTime.now().minusDays(15).toDate().getTime());\r\n    scheduledBackup.setLastRun(LocalDateTime.now().minusDays(8).toDate().getTime());\r\n    long previousLastRun = scheduledBackup.getLastRunTime();\r\n    scheduledBackup.setExecutionCount(1);\r\n    Recurrence recurrence = new Recurrence(PeriodType.WEEK);\r\n    recurrence.setMultiplier(1);\r\n    recurrence.setByDays(Collections.singletonList(Calendar.FRIDAY));\r\n    scheduledBackup.setRecurrence(recurrence);\r\n    ExportParams backupParams = new ExportParams(ExportFormat.QIF);\r\n    backupParams.setExportTarget(ExportParams.ExportTarget.SD_CARD);\r\n    backupParams.setExportStartTime(new Timestamp(scheduledBackup.getStartTime()));\r\n    scheduledBackup.setTag(backupParams.toCsv());\r\n    Transaction transaction = new Transaction(\"Orient palace\");\r\n    Split split = new Split(new Money(\"10\", Commodity.DEFAULT_COMMODITY.getCurrencyCode()), mBaseAccount.getUID());\r\n    split.setType(TransactionType.DEBIT);\r\n    transaction.addSplit(split);\r\n    transaction.addSplit(split.createPair(mTransferAccount.getUID()));\r\n    mTransactionsDbAdapter.addRecord(transaction);\r\n    File backupFolder = new File(Exporter.getExportFolderPath(BooksDbAdapter.getInstance().getActiveBookUID()));\r\n    assertThat(backupFolder).exists();\r\n    assertThat(backupFolder.listFiles()).isEmpty();\r\n    List<ScheduledAction> actions = new ArrayList();\r\n    actions.add(scheduledBackup);\r\n    ScheduledActionService.processScheduledActions(actions, mDb);\r\n    assertThat(scheduledBackup.getExecutionCount()).isEqualTo(2);\r\n    assertThat(scheduledBackup.getLastRunTime()).isGreaterThan(previousLastRun);\r\n    assertThat(backupFolder.listFiles()).hasSize(1);\r\n    assertThat(backupFolder.listFiles()[0].getName()).endsWith(\".qif\");\r\n}"
}, {
	"Path": "org.gnucash.android.export.ExportAsyncTask.doInBackground",
	"Comment": "generates the appropriate exported transactions file for the given parameters",
	"Method": "Boolean doInBackground(ExportParams params){\r\n    mExportParams = params[0];\r\n    mExporter = getExporter();\r\n    try {\r\n        mExportedFiles = mExporter.generateExport();\r\n    } catch (final Exception e) {\r\n        Log.e(TAG, \"Error exporting: \" + e.getMessage());\r\n        Crashlytics.logException(e);\r\n        e.printStackTrace();\r\n        if (mContext instanceof Activity) {\r\n            ((Activity) mContext).runOnUiThread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    Toast.makeText(mContext, mContext.getString(R.string.toast_export_error, mExportParams.getExportFormat().name()) + \"\\n\" + e.getMessage(), Toast.LENGTH_SHORT).show();\r\n                }\r\n            });\r\n        }\r\n        return false;\r\n    }\r\n    if (mExportedFiles.isEmpty())\r\n        return false;\r\n    try {\r\n        moveToTarget();\r\n    } catch (Exporter.ExporterException e) {\r\n        Crashlytics.log(Log.ERROR, TAG, \"Error sending exported files to target: \" + e.getMessage());\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.gnucash.android.export.ExportAsyncTask.doInBackground",
	"Comment": "generates the appropriate exported transactions file for the given parameters",
	"Method": "Boolean doInBackground(ExportParams params){\r\n    Toast.makeText(mContext, mContext.getString(R.string.toast_export_error, mExportParams.getExportFormat().name()) + \"\\n\" + e.getMessage(), Toast.LENGTH_SHORT).show();\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.extensions.android.gms.auth.GoogleAccountCredential.newChooseAccountIntent",
	"Comment": "returns an intent to show the user to select a google account, or create a new one if there arenone on the device yet.must be run from the main ui thread.",
	"Method": "Intent newChooseAccountIntent(){\r\n    return AccountPicker.newChooseAccountIntent(selectedAccount, null, new String[] { GoogleAccountManager.ACCOUNT_TYPE }, true, null, null, null, null);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.report.barchart.StackedBarChartFragment.getData",
	"Comment": "returns a data object that represents a user data of the specified account types",
	"Method": "BarData getData(){\r\n    List<BarEntry> values = new ArrayList();\r\n    List<String> labels = new ArrayList();\r\n    List<Integer> colors = new ArrayList();\r\n    Map<String, Integer> accountToColorMap = new LinkedHashMap();\r\n    List<String> xValues = new ArrayList();\r\n    LocalDateTime tmpDate = new LocalDateTime(getStartDate(mAccountType).toDate().getTime());\r\n    int count = getDateDiff(new LocalDateTime(getStartDate(mAccountType).toDate().getTime()), new LocalDateTime(getEndDate(mAccountType).toDate().getTime()));\r\n    for (int i = 0; i <= count; i++) {\r\n        long start = 0;\r\n        long end = 0;\r\n        switch(mGroupInterval) {\r\n            case MONTH:\r\n                start = tmpDate.dayOfMonth().withMinimumValue().millisOfDay().withMinimumValue().toDate().getTime();\r\n                end = tmpDate.dayOfMonth().withMaximumValue().millisOfDay().withMaximumValue().toDate().getTime();\r\n                xValues.add(tmpDate.toString(X_AXIS_MONTH_PATTERN));\r\n                tmpDate = tmpDate.plusMonths(1);\r\n                break;\r\n            case QUARTER:\r\n                int quarter = getQuarter(tmpDate);\r\n                start = tmpDate.withMonthOfYear(quarter * 3 - 2).dayOfMonth().withMinimumValue().millisOfDay().withMinimumValue().toDate().getTime();\r\n                end = tmpDate.withMonthOfYear(quarter * 3).dayOfMonth().withMaximumValue().millisOfDay().withMaximumValue().toDate().getTime();\r\n                xValues.add(String.format(X_AXIS_QUARTER_PATTERN, quarter, tmpDate.toString(\" YY\")));\r\n                tmpDate = tmpDate.plusMonths(3);\r\n                break;\r\n            case YEAR:\r\n                start = tmpDate.dayOfYear().withMinimumValue().millisOfDay().withMinimumValue().toDate().getTime();\r\n                end = tmpDate.dayOfYear().withMaximumValue().millisOfDay().withMaximumValue().toDate().getTime();\r\n                xValues.add(tmpDate.toString(X_AXIS_YEAR_PATTERN));\r\n                tmpDate = tmpDate.plusYears(1);\r\n                break;\r\n        }\r\n        List<Float> stack = new ArrayList();\r\n        for (Account account : mAccountsDbAdapter.getSimpleAccountList()) {\r\n            if (account.getAccountType() == mAccountType && !account.isPlaceholderAccount() && account.getCommodity().equals(mCommodity)) {\r\n                double balance = mAccountsDbAdapter.getAccountsBalance(Collections.singletonList(account.getUID()), start, end).asDouble();\r\n                if (balance != 0) {\r\n                    stack.add((float) balance);\r\n                    String accountName = account.getName();\r\n                    while (labels.contains(accountName)) {\r\n                        if (!accountToColorMap.containsKey(account.getUID())) {\r\n                            for (String label : labels) {\r\n                                if (label.equals(accountName)) {\r\n                                    accountName += \" \";\r\n                                }\r\n                            }\r\n                        } else {\r\n                            break;\r\n                        }\r\n                    }\r\n                    labels.add(accountName);\r\n                    if (!accountToColorMap.containsKey(account.getUID())) {\r\n                        Integer color;\r\n                        if (mUseAccountColor) {\r\n                            color = (account.getColor() != Account.DEFAULT_COLOR) ? account.getColor() : COLORS[accountToColorMap.size() % COLORS.length];\r\n                        } else {\r\n                            color = COLORS[accountToColorMap.size() % COLORS.length];\r\n                        }\r\n                        accountToColorMap.put(account.getUID(), color);\r\n                    }\r\n                    colors.add(accountToColorMap.get(account.getUID()));\r\n                    Log.d(TAG, mAccountType + tmpDate.toString(\" MMMM yyyy \") + account.getName() + \" = \" + stack.get(stack.size() - 1));\r\n                }\r\n            }\r\n        }\r\n        String stackLabels = labels.subList(labels.size() - stack.size(), labels.size()).toString();\r\n        values.add(new BarEntry(floatListToArray(stack), i, stackLabels));\r\n    }\r\n    BarDataSet set = new BarDataSet(values, \"\");\r\n    set.setDrawValues(false);\r\n    set.setStackLabels(labels.toArray(new String[labels.size()]));\r\n    set.setColors(colors);\r\n    if (set.getYValueSum() == 0) {\r\n        mChartDataPresent = false;\r\n        return getEmptyData();\r\n    }\r\n    mChartDataPresent = true;\r\n    return new BarData(xValues, set);\r\n}"
}, {
	"Path": "org.gnucash.android.model.Budget.getCompactedBudgetAmounts",
	"Comment": "returns the list of budget amounts where only one budgetamount is present if the amount of the budget amountis the same for all periods in the budget.budgetamounts with different amounts per period are still return separatelythis method is used during import because gnucash desktop saves one budgetamount per period for the whole budgeting period.while this can be easily displayed in a table form on the desktop, it is not feasible in the android app.so we display only one budgetamount if it covers all periods in the budgeting period",
	"Method": "List<BudgetAmount> getCompactedBudgetAmounts(){\r\n    Map<String, List<BigDecimal>> accountAmountMap = new HashMap();\r\n    for (BudgetAmount budgetAmount : mBudgetAmounts) {\r\n        String accountUID = budgetAmount.getAccountUID();\r\n        BigDecimal amount = budgetAmount.getAmount().asBigDecimal();\r\n        if (accountAmountMap.containsKey(accountUID)) {\r\n            accountAmountMap.get(accountUID).add(amount);\r\n        } else {\r\n            List<BigDecimal> amounts = new ArrayList();\r\n            amounts.add(amount);\r\n            accountAmountMap.put(accountUID, amounts);\r\n        }\r\n    }\r\n    List<BudgetAmount> compactBudgetAmounts = new ArrayList();\r\n    for (Map.Entry<String, List<BigDecimal>> entry : accountAmountMap.entrySet()) {\r\n        List<BigDecimal> amounts = entry.getValue();\r\n        BigDecimal first = amounts.get(0);\r\n        boolean allSame = true;\r\n        for (BigDecimal bigDecimal : amounts) {\r\n            allSame &= bigDecimal.equals(first);\r\n        }\r\n        if (allSame) {\r\n            if (amounts.size() == 1) {\r\n                for (BudgetAmount bgtAmount : mBudgetAmounts) {\r\n                    if (bgtAmount.getAccountUID().equals(entry.getKey())) {\r\n                        compactBudgetAmounts.add(bgtAmount);\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                BudgetAmount bgtAmount = new BudgetAmount(getUID(), entry.getKey());\r\n                bgtAmount.setAmount(new Money(first, Commodity.DEFAULT_COMMODITY));\r\n                bgtAmount.setPeriodNum(-1);\r\n                compactBudgetAmounts.add(bgtAmount);\r\n            }\r\n        } else {\r\n            for (BudgetAmount bgtAmount : mBudgetAmounts) {\r\n                if (bgtAmount.getAccountUID().equals(entry.getKey())) {\r\n                    compactBudgetAmounts.add(bgtAmount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return compactBudgetAmounts;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.TransactionsActivity.displayBalance",
	"Comment": "display the balance of a transaction in a text view and format the text color to match the sign of the amount",
	"Method": "void displayBalance(TextView balanceTextView,Money balance){\r\n    balanceTextView.setText(balance.formattedString());\r\n    Context context = GnuCashApplication.getAppContext();\r\n    int fontColor = balance.isNegative() ? context.getResources().getColor(R.color.debit_red) : context.getResources().getColor(R.color.credit_green);\r\n    if (balance.asBigDecimal().compareTo(BigDecimal.ZERO) == 0)\r\n        fontColor = context.getResources().getColor(android.R.color.black);\r\n    balanceTextView.setTextColor(fontColor);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.SplitEditorFragment.canSave",
	"Comment": "check if all the split amounts have valid values that can be saved",
	"Method": "boolean canSave(){\r\n    for (View splitView : mSplitItemViewList) {\r\n        SplitViewHolder viewHolder = (SplitViewHolder) splitView.getTag();\r\n        viewHolder.splitAmountEditText.evaluate();\r\n        if (viewHolder.splitAmountEditText.getError() != null) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.buildModelInstance",
	"Comment": "builds a transaction instance with the provided cursor.\tthe cursor should already be pointing to the transaction record in the database",
	"Method": "Transaction buildModelInstance(Cursor c){\r\n    String name = c.getString(c.getColumnIndexOrThrow(TransactionEntry.COLUMN_DESCRIPTION));\r\n    Transaction transaction = new Transaction(name);\r\n    populateBaseModelAttributes(c, transaction);\r\n    transaction.setTime(c.getLong(c.getColumnIndexOrThrow(TransactionEntry.COLUMN_TIMESTAMP)));\r\n    transaction.setNote(c.getString(c.getColumnIndexOrThrow(TransactionEntry.COLUMN_NOTES)));\r\n    transaction.setExported(c.getInt(c.getColumnIndexOrThrow(TransactionEntry.COLUMN_EXPORTED)) == 1);\r\n    transaction.setTemplate(c.getInt(c.getColumnIndexOrThrow(TransactionEntry.COLUMN_TEMPLATE)) == 1);\r\n    String currencyCode = c.getString(c.getColumnIndexOrThrow(TransactionEntry.COLUMN_CURRENCY));\r\n    transaction.setCommodity(mCommoditiesDbAdapter.getCommodity(currencyCode));\r\n    transaction.setScheduledActionUID(c.getString(c.getColumnIndexOrThrow(TransactionEntry.COLUMN_SCHEDX_ACTION_UID)));\r\n    long transactionID = c.getLong(c.getColumnIndexOrThrow(TransactionEntry._ID));\r\n    transaction.setSplits(mSplitsDbAdapter.getSplitsForTransaction(transactionID));\r\n    return transaction;\r\n}"
}, {
	"Path": "org.gnucash.android.export.ofx.OfxExporter.generateOfx",
	"Comment": "converts all expenses into ofx xml format and adds them to the xml document",
	"Method": "void generateOfx(Document doc,Element parent){\r\n    Element transactionUid = doc.createElement(OfxHelper.TAG_TRANSACTION_UID);\r\n    transactionUid.appendChild(doc.createTextNode(OfxHelper.UNSOLICITED_TRANSACTION_ID));\r\n    Element statementTransactionResponse = doc.createElement(OfxHelper.TAG_STATEMENT_TRANSACTION_RESPONSE);\r\n    statementTransactionResponse.appendChild(transactionUid);\r\n    Element bankmsgs = doc.createElement(OfxHelper.TAG_BANK_MESSAGES_V1);\r\n    bankmsgs.appendChild(statementTransactionResponse);\r\n    parent.appendChild(bankmsgs);\r\n    AccountsDbAdapter accountsDbAdapter = mAccountsDbAdapter;\r\n    for (Account account : mAccountsList) {\r\n        if (account.getTransactionCount() == 0)\r\n            continue;\r\n        if (!GnuCashApplication.isDoubleEntryEnabled() && account.getName().contains(mContext.getString(R.string.imbalance_account_name)))\r\n            continue;\r\n        account.toOfx(doc, statementTransactionResponse, mExportParams.getExportStartTime());\r\n        accountsDbAdapter.markAsExported(account.getUID());\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.model.Commodity.getSmallestFraction",
	"Comment": "returns the smallest fraction supported by the commodity as a power of 10.i.e. for commodities with no fractions, 1 is returned, for commodities with 2 fractions, 100 is returned",
	"Method": "int getSmallestFraction(){\r\n    return mSmallestFraction;\r\n}"
}, {
	"Path": "com.google.api.client.util.Types.isAssignableToOrFrom",
	"Comment": "returns whether a class is either assignable to or from another class.",
	"Method": "boolean isAssignableToOrFrom(Class<?> classToCheck,Class<?> anotherClass){\r\n    return classToCheck.isAssignableFrom(anotherClass) || anotherClass.isAssignableFrom(classToCheck);\r\n}"
}, {
	"Path": "com.google.api.client.util.FieldInfo.getValue",
	"Comment": "returns the value of the field in the given object instance using reflection.",
	"Method": "Object getValue(Object obj){\r\n    return getFieldValue(field, obj);\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.getTotalPlannedExecutionCount",
	"Comment": "returns the total number of planned occurrences of this scheduled action.",
	"Method": "int getTotalPlannedExecutionCount(){\r\n    return mTotalFrequency;\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.batch.BatchRequest.size",
	"Comment": "returns the number of queued requests in this batch request.",
	"Method": "int size(){\r\n    return requestInfos.size();\r\n}"
}, {
	"Path": "ca.uhn.fhir.model.primitive.DateTimeDt.withCurrentTime",
	"Comment": "returns a new instance of datetimedt with the current system time and second precision and the system local time",
	"Method": "DateTimeDt withCurrentTime(){\r\n    return new DateTimeDt(new Date(), TemporalPrecisionEnum.SECOND, TimeZone.getDefault());\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.getTimestampOfEarliestTransaction",
	"Comment": "returns a timestamp of the earliest transaction for a specified account type and currency",
	"Method": "long getTimestampOfEarliestTransaction(AccountType type,String currencyCode){\r\n    return getTimestamp(\"MIN\", type, currencyCode);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.TransactionFormFragment.initializeViewsWithTransaction",
	"Comment": "initialize views in the fragment with information from a transaction.\tthis method is called if the fragment is used for editing a transaction",
	"Method": "void initializeViewsWithTransaction(){\r\n    mDescriptionEditText.setText(mTransaction.getDescription());\r\n    mDescriptionEditText.setSelection(mDescriptionEditText.getText().length());\r\n    mTransactionTypeSwitch.setAccountType(mAccountType);\r\n    mTransactionTypeSwitch.setChecked(mTransaction.getBalance(mAccountUID).isNegative());\r\n    if (!mAmountEditText.isInputModified()) {\r\n        mAmountEditText.setValue(mTransaction.getBalance(mAccountUID).asBigDecimal());\r\n    }\r\n    mCurrencyTextView.setText(mTransaction.getCommodity().getSymbol());\r\n    mNotesEditText.setText(mTransaction.getNote());\r\n    mDateTextView.setText(DATE_FORMATTER.format(mTransaction.getTimeMillis()));\r\n    mTimeTextView.setText(TIME_FORMATTER.format(mTransaction.getTimeMillis()));\r\n    Calendar cal = GregorianCalendar.getInstance();\r\n    cal.setTimeInMillis(mTransaction.getTimeMillis());\r\n    mDate = mTime = cal;\r\n    mSplitsList = new ArrayList(mTransaction.getSplits());\r\n    toggleAmountInputEntryMode(mSplitsList.size() <= 2);\r\n    if (mSplitsList.size() == 2) {\r\n        for (Split split : mSplitsList) {\r\n            if (split.getAccountUID().equals(mAccountUID)) {\r\n                if (!split.getQuantity().getCommodity().equals(mTransaction.getCommodity())) {\r\n                    mSplitQuantity = split.getQuantity();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (mSplitsList.size() == 2 && mSplitsList.get(0).isPairOf(mSplitsList.get(1))) {\r\n        for (Split split : mTransaction.getSplits()) {\r\n            if (mUseDoubleEntry && !split.getAccountUID().equals(mAccountUID)) {\r\n                setSelectedTransferAccount(mAccountsDbAdapter.getID(split.getAccountUID()));\r\n            }\r\n        }\r\n    } else {\r\n        setDoubleEntryViewsVisibility(View.GONE);\r\n    }\r\n    String currencyCode = mTransactionsDbAdapter.getAccountCurrencyCode(mAccountUID);\r\n    Commodity accountCommodity = Commodity.getInstance(currencyCode);\r\n    mCurrencyTextView.setText(accountCommodity.getSymbol());\r\n    Commodity commodity = Commodity.getInstance(currencyCode);\r\n    mAmountEditText.setCommodity(commodity);\r\n    mSaveTemplateCheckbox.setChecked(mTransaction.isTemplate());\r\n    String scheduledActionUID = getArguments().getString(UxArgument.SCHEDULED_ACTION_UID);\r\n    if (scheduledActionUID != null && !scheduledActionUID.isEmpty()) {\r\n        ScheduledAction scheduledAction = ScheduledActionDbAdapter.getInstance().getRecord(scheduledActionUID);\r\n        mRecurrenceRule = scheduledAction.getRuleString();\r\n        mEventRecurrence.parse(mRecurrenceRule);\r\n        mRecurrenceTextView.setText(scheduledAction.getRepeatString());\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.http.HttpTransport.createRequestFactory",
	"Comment": "returns a new instance of an http request factory based on this http transport with the givenhttp request initializer.",
	"Method": "HttpRequestFactory createRequestFactory(HttpRequestFactory createRequestFactory,HttpRequestInitializer initializer){\r\n    return new HttpRequestFactory(this, initializer);\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.BooksDbAdapter.getBookDatabases",
	"Comment": "returns a list of database names corresponding to book databases.",
	"Method": "List<String> getBookDatabases(){\r\n    List<String> bookDatabases = new ArrayList();\r\n    for (String database : GnuCashApplication.getAppContext().databaseList()) {\r\n        if (isBookDatabase(database)) {\r\n            bookDatabases.add(database);\r\n        }\r\n    }\r\n    return bookDatabases;\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.setEnabled",
	"Comment": "toggles the enabled state of the scheduled actiondisabled scheduled actions will not be executed",
	"Method": "void setEnabled(boolean enabled){\r\n    this.mIsEnabled = enabled;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.SplitEditorFragment.newInstance",
	"Comment": "create and return a new instance of the fragment with the appropriate paramenters",
	"Method": "SplitEditorFragment newInstance(Bundle args){\r\n    SplitEditorFragment fragment = new SplitEditorFragment();\r\n    fragment.setArguments(args);\r\n    return fragment;\r\n}"
}, {
	"Path": "com.google.api.client.util.PemReader.readNextSection",
	"Comment": "reads the next section in the pem file, optionally based on a title to look for.",
	"Method": "Section readNextSection(Section readNextSection,String titleToLookFor){\r\n    String title = null;\r\n    StringBuilder keyBuilder = null;\r\n    while (true) {\r\n        String line = reader.readLine();\r\n        if (line == null) {\r\n            Preconditions.checkArgument(title == null, \"missing end tag (%s)\", title);\r\n            return null;\r\n        }\r\n        if (keyBuilder == null) {\r\n            Matcher m = BEGIN_PATTERN.matcher(line);\r\n            if (m.matches()) {\r\n                String curTitle = m.group(1);\r\n                if (titleToLookFor == null || curTitle.equals(titleToLookFor)) {\r\n                    keyBuilder = new StringBuilder();\r\n                    title = curTitle;\r\n                }\r\n            }\r\n        } else {\r\n            Matcher m = END_PATTERN.matcher(line);\r\n            if (m.matches()) {\r\n                String endTitle = m.group(1);\r\n                Preconditions.checkArgument(endTitle.equals(title), \"end tag (%s) doesn't match begin tag (%s)\", endTitle, title);\r\n                return new Section(title, Base64.decodeBase64(keyBuilder.toString()));\r\n            }\r\n            keyBuilder.append(line);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.ui.budget.BudgetsActivity.onCreateBudgetClick",
	"Comment": "callback when create budget floating action button is clicked",
	"Method": "void onCreateBudgetClick(View view){\r\n    Intent addAccountIntent = new Intent(BudgetsActivity.this, FormActivity.class);\r\n    addAccountIntent.setAction(Intent.ACTION_INSERT_OR_EDIT);\r\n    addAccountIntent.putExtra(UxArgument.FORM_TYPE, FormActivity.FormType.BUDGET.name());\r\n    startActivityForResult(addAccountIntent, REQUEST_CREATE_BUDGET);\r\n}"
}, {
	"Path": "com.google.api.client.util.FieldInfo.getFieldValue",
	"Comment": "returns the value of the given field in the given object instance using reflection.",
	"Method": "Object getFieldValue(Field field,Object obj){\r\n    try {\r\n        return field.get(obj);\r\n    } catch (IllegalAccessException e) {\r\n        throw new IllegalArgumentException(e);\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.TransactionFormFragment.finish",
	"Comment": "finishes the fragment appropriately.\tdepends on how the fragment was loaded, it might have a backstack or not",
	"Method": "void finish(int resultCode){\r\n    if (getActivity().getSupportFragmentManager().getBackStackEntryCount() == 0) {\r\n        getActivity().setResult(resultCode);\r\n        getActivity().finish();\r\n    } else {\r\n        getActivity().getSupportFragmentManager().popBackStack();\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.notifications.AbstractNotification.setChannelId",
	"Comment": "sets the notification channel uuid provided by the client in the watch request.overriding is only supported for the purpose of calling the super implementation and changingthe return type, but nothing else.",
	"Method": "AbstractNotification setChannelId(String channelId){\r\n    this.channelId = Preconditions.checkNotNull(channelId);\r\n    return this;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Transaction.setTemplate",
	"Comment": "sets flag indicating whether this transaction is a template or not",
	"Method": "void setTemplate(boolean isTemplate){\r\n    mIsTemplate = isTemplate;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Split.getQuantity",
	"Comment": "returns the quantity amount of the split.the quantity is in the currency of the account to which the split is associated",
	"Method": "Money getQuantity(){\r\n    return mQuantity;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Money.getDenominator",
	"Comment": "returns the gnucash amount format denominator for this amount\tthe denominator is 10 raised to the power of number of fractional digits in the currency",
	"Method": "long getDenominator(){\r\n    int scale = getScale();\r\n    return BigDecimal.ONE.scaleByPowerOfTen(scale).longValueExact();\r\n}"
}, {
	"Path": "org.gnucash.android.ui.settings.BackupPreferenceFragment.toggleDropboxSync",
	"Comment": "toggles the authorization state of a dropbox account.\tif a link exists, it is removed else dropbox authorization is started",
	"Method": "void toggleDropboxSync(){\r\n    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getActivity());\r\n    String accessToken = prefs.getString(getString(R.string.key_dropbox_access_token), null);\r\n    if (accessToken == null) {\r\n        Auth.startOAuth2Authentication(getActivity(), getString(R.string.dropbox_app_key));\r\n    } else {\r\n        prefs.edit().remove(getString(R.string.key_dropbox_access_token)).apply();\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.model.Account.getDefaultTransferAccountUID",
	"Comment": "return the unique id of accounts to which to default transfer transactions to",
	"Method": "String getDefaultTransferAccountUID(){\r\n    return mDefaultTransferAccountUID;\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.db.AccountsDbAdapterTest.shouldCreateDefaultRootAccount",
	"Comment": "tests that a root account will always be created in the system",
	"Method": "void shouldCreateDefaultRootAccount(){\r\n    Account account = new Account(\"Some account\");\r\n    mAccountsDbAdapter.addRecord(account);\r\n    assertThat(mAccountsDbAdapter.getRecordsCount()).isEqualTo(2L);\r\n    List<Account> accounts = mAccountsDbAdapter.getSimpleAccountList();\r\n    assertThat(accounts).extracting(\"mAccountType\").contains(AccountType.ROOT);\r\n    String rootAccountUID = mAccountsDbAdapter.getOrCreateGnuCashRootAccountUID();\r\n    assertThat(rootAccountUID).isEqualTo(accounts.get(1).getParentUID());\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.deleteTransactionsWithNoSplits",
	"Comment": "deletes all transactions which have no splits associated with them",
	"Method": "int deleteTransactionsWithNoSplits(){\r\n    return mDb.delete(TransactionEntry.TABLE_NAME, \"NOT EXISTS ( SELECT * FROM \" + SplitEntry.TABLE_NAME + \" WHERE \" + TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_UID + \" = \" + SplitEntry.TABLE_NAME + \".\" + SplitEntry.COLUMN_TRANSACTION_UID + \" ) \", null);\r\n}"
}, {
	"Path": "com.google.api.client.http.MultipartContent.addPart",
	"Comment": "adds an http multipart part.overriding is only supported for the purpose of calling the super implementation and changingthe return type, but nothing else.",
	"Method": "MultipartContent addPart(Part part){\r\n    parts.add(Preconditions.checkNotNull(part));\r\n    return this;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Money.divide",
	"Comment": "returns a new money object whose value is the quotient of the division of this objects \tvalue by the factor divisor",
	"Method": "Money divide(Money divisor,Money divide,int divisor){\r\n    Money moneyDiv = new Money(new BigDecimal(divisor), mCommodity);\r\n    return divide(moneyDiv);\r\n}"
}, {
	"Path": "org.gnucash.android.model.Transaction.createIntent",
	"Comment": "creates an intent with arguments from the transaction.this intent can be broadcast to create a new transaction",
	"Method": "Intent createIntent(Transaction transaction){\r\n    Intent intent = new Intent(Intent.ACTION_INSERT);\r\n    intent.setType(Transaction.MIME_TYPE);\r\n    intent.putExtra(Intent.EXTRA_TITLE, transaction.getDescription());\r\n    intent.putExtra(Intent.EXTRA_TEXT, transaction.getNote());\r\n    intent.putExtra(Account.EXTRA_CURRENCY_CODE, transaction.getCurrencyCode());\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    for (Split split : transaction.getSplits()) {\r\n        stringBuilder.append(split.toCsv()).append(\"\\n\");\r\n    }\r\n    intent.putExtra(Transaction.EXTRA_SPLITS, stringBuilder.toString());\r\n    return intent;\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.extensions.android.gms.auth.GoogleAccountCredential.getToken",
	"Comment": "returns an oauth 2.0 access token.must be run from a background thread, not the main ui thread.",
	"Method": "String getToken(){\r\n    if (backOff != null) {\r\n        backOff.reset();\r\n    }\r\n    while (true) {\r\n        try {\r\n            return GoogleAuthUtil.getToken(context, accountName, scope);\r\n        } catch (IOException e) {\r\n            try {\r\n                if (backOff == null || !BackOffUtils.next(sleeper, backOff)) {\r\n                    throw e;\r\n                }\r\n            } catch (InterruptedException e2) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.services.CommonGoogleClientRequestInitializer.initialize",
	"Comment": "subclasses should call super implementation in order to set the key and userip.",
	"Method": "void initialize(AbstractGoogleClientRequest<?> request){\r\n    if (key != null) {\r\n        request.put(\"key\", key);\r\n    }\r\n    if (userIp != null) {\r\n        request.put(\"userIp\", userIp);\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.SplitsDbAdapter.getTransactionUID",
	"Comment": "returns the unique id of a transaction given the database record id of same",
	"Method": "String getTransactionUID(long transactionId){\r\n    Cursor cursor = mDb.query(TransactionEntry.TABLE_NAME, new String[] { TransactionEntry.COLUMN_UID }, TransactionEntry._ID + \" = \" + transactionId, null, null, null, null);\r\n    try {\r\n        if (cursor.moveToFirst()) {\r\n            return cursor.getString(cursor.getColumnIndexOrThrow(TransactionEntry.COLUMN_UID));\r\n        } else {\r\n            throw new IllegalArgumentException(\"transaction \" + transactionId + \" does not exist\");\r\n        }\r\n    } finally {\r\n        cursor.close();\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.db.AccountsDbAdapterTest.shouldBeAlphabeticallySortedByDefault",
	"Comment": "test that the list of accounts is always returned sorted alphabetically",
	"Method": "void shouldBeAlphabeticallySortedByDefault(){\r\n    Account first = new Account(ALPHA_ACCOUNT_NAME);\r\n    Account second = new Account(BRAVO_ACCOUNT_NAME);\r\n    mAccountsDbAdapter.addRecord(second);\r\n    mAccountsDbAdapter.addRecord(first);\r\n    List<Account> accountsList = mAccountsDbAdapter.getAllRecords();\r\n    assertEquals(2, accountsList.size());\r\n    assertThat(accountsList).contains(first, Index.atIndex(0));\r\n    assertThat(accountsList).contains(second, Index.atIndex(1));\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.ScheduledActionsListFragment.openTransactionForEdit",
	"Comment": "opens the transaction editor to enable editing of the transaction",
	"Method": "void openTransactionForEdit(String accountUID,String transactionUID,String scheduledActionUid){\r\n    Intent createTransactionIntent = new Intent(getActivity(), FormActivity.class);\r\n    createTransactionIntent.setAction(Intent.ACTION_INSERT_OR_EDIT);\r\n    createTransactionIntent.putExtra(UxArgument.FORM_TYPE, FormActivity.FormType.TRANSACTION.name());\r\n    createTransactionIntent.putExtra(UxArgument.SELECTED_ACCOUNT_UID, accountUID);\r\n    createTransactionIntent.putExtra(UxArgument.SELECTED_TRANSACTION_UID, transactionUID);\r\n    createTransactionIntent.putExtra(UxArgument.SCHEDULED_ACTION_UID, scheduledActionUid);\r\n    startActivity(createTransactionIntent);\r\n}"
}, {
	"Path": "org.gnucash.android.export.qif.QifHelper.getQifHeader",
	"Comment": "returns the qif header for the transaction based on the account type.by default, the qif cash header is used",
	"Method": "String getQifHeader(AccountType accountType,String getQifHeader,String accountType){\r\n    return getQifHeader(AccountType.valueOf(accountType));\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.getSplitCount",
	"Comment": "returns the number of splits for the transaction in the database",
	"Method": "long getSplitCount(String transactionUID){\r\n    if (transactionUID == null)\r\n        return 0;\r\n    String sql = \"SELECT COUNT(*) FROM \" + SplitEntry.TABLE_NAME + \" WHERE \" + SplitEntry.COLUMN_TRANSACTION_UID + \"= '\" + transactionUID + \"'\";\r\n    SQLiteStatement statement = mDb.compileStatement(sql);\r\n    return statement.simpleQueryForLong();\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.getAccountColorOptions",
	"Comment": "returns an array of colors used for accounts.the array returned has the actual color values and not the resource id.",
	"Method": "int[] getAccountColorOptions(){\r\n    Resources res = getResources();\r\n    TypedArray colorTypedArray = res.obtainTypedArray(R.array.account_colors);\r\n    int[] colorOptions = new int[colorTypedArray.length()];\r\n    for (int i = 0; i < colorTypedArray.length(); i++) {\r\n        int color = colorTypedArray.getColor(i, ContextCompat.getColor(getContext(), R.color.title_green));\r\n        colorOptions[i] = color;\r\n    }\r\n    colorTypedArray.recycle();\r\n    return colorOptions;\r\n}"
}, {
	"Path": "org.gnucash.android.app.GnuCashApplication.isDoubleEntryEnabled",
	"Comment": "returns true if double entry is enabled in the app settings, false otherwise.if the value is not set, the default value can be specified in the parameters.",
	"Method": "boolean isDoubleEntryEnabled(){\r\n    SharedPreferences sharedPrefs = PreferenceActivity.getActiveBookSharedPreferences();\r\n    return sharedPrefs.getBoolean(context.getString(R.string.key_use_double_entry), true);\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.importer.GncXmlHandlerTest.importingScheduledAction_shouldSetByDays",
	"Comment": "tests that importing a weekly scheduled action sets the days of theweek of the recursion.",
	"Method": "void importingScheduledAction_shouldSetByDays(){\r\n    String bookUID = importGnuCashXml(\"importingScheduledAction_shouldSetByDays.xml\");\r\n    setUpDbAdapters(bookUID);\r\n    ScheduledAction scheduledTransaction = mScheduledActionDbAdapter.getRecord(\"b5a13acb5a9459ebed10d06b75bbad10\");\r\n    assertThat(scheduledTransaction.getRecurrence().getByDays().size()).isGreaterThanOrEqualTo(1);\r\n    int dayOfWeekFromByDays = scheduledTransaction.getRecurrence().getByDays().get(0);\r\n    Date startTime = new Date(scheduledTransaction.getStartTime());\r\n    Calendar calendar = Calendar.getInstance();\r\n    calendar.setTime(startTime);\r\n    int dayOfWeekFromStartTime = calendar.get(Calendar.DAY_OF_WEEK);\r\n    assertThat(dayOfWeekFromByDays).isEqualTo(dayOfWeekFromStartTime);\r\n}"
}, {
	"Path": "org.gnucash.android.app.GnuCashApplication.shouldSaveOpeningBalances",
	"Comment": "returns true if setting is enabled to save opening balances after deleting transactions,false otherwise.",
	"Method": "boolean shouldSaveOpeningBalances(boolean defaultValue){\r\n    SharedPreferences sharedPrefs = PreferenceActivity.getActiveBookSharedPreferences();\r\n    return sharedPrefs.getBoolean(context.getString(R.string.key_save_opening_balances), defaultValue);\r\n}"
}, {
	"Path": "org.gnucash.android.export.ExportParams.getExportStartTime",
	"Comment": "return date from which to start exporting transactionstransactions created or modified after this timestamp will be exported",
	"Method": "Timestamp getExportStartTime(){\r\n    return mExportStartTime;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.SplitsDbAdapter.fetchSplitsForTransaction",
	"Comment": "returns a cursor to a dataset of splits belonging to a specific transaction",
	"Method": "Cursor fetchSplitsForTransaction(String transactionUID){\r\n    Log.v(LOG_TAG, \"Fetching all splits for transaction UID \" + transactionUID);\r\n    return mDb.query(SplitEntry.TABLE_NAME, null, SplitEntry.COLUMN_TRANSACTION_UID + \" = ?\", new String[] { transactionUID }, null, null, null);\r\n}"
}, {
	"Path": "org.gnucash.android.model.Money.multiply",
	"Comment": "returns a new money object whose value is the product of this object\tand the factor multiplier",
	"Method": "Money multiply(Money money,Money multiply,int multiplier,Money multiply,BigDecimal multiplier){\r\n    return new Money(mAmount.multiply(multiplier), mCommodity);\r\n}"
}, {
	"Path": "org.gnucash.android.test.ui.PieChartReportTest.addTransactionForCurrentMonth",
	"Comment": "add a transaction for the current month in order to test the report view",
	"Method": "void addTransactionForCurrentMonth(){\r\n    Transaction transaction = new Transaction(TRANSACTION_NAME);\r\n    transaction.setTime(System.currentTimeMillis());\r\n    Split split = new Split(new Money(BigDecimal.valueOf(TRANSACTION_AMOUNT), CURRENCY), DINING_EXPENSE_ACCOUNT_UID);\r\n    split.setType(TransactionType.DEBIT);\r\n    transaction.addSplit(split);\r\n    transaction.addSplit(split.createPair(CASH_IN_WALLET_ASSET_ACCOUNT_UID));\r\n    mTransactionsDbAdapter.addRecord(transaction, DatabaseAdapter.UpdateMethod.insert);\r\n}"
}, {
	"Path": "org.gnucash.android.model.Book.setRootAccountUID",
	"Comment": "sets the guid of the root account of this book.each book has only one root account",
	"Method": "void setRootAccountUID(String rootAccountUID){\r\n    mRootAccountUID = rootAccountUID;\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.setTag",
	"Comment": "sets the tag of the schedules action.the tag saves additional information about the scheduled action,e.g. such as export parameters for scheduled backups",
	"Method": "void setTag(String tag){\r\n    this.mTag = tag;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.budget.BudgetFormFragment.extractBudgetAmounts",
	"Comment": "extracts the budget amounts from the formif the budget amount was input using the simple form, then read the values.else return the values gotten from the budgetamounteditor",
	"Method": "ArrayList<BudgetAmount> extractBudgetAmounts(){\r\n    BigDecimal value = mBudgetAmountInput.getValue();\r\n    if (value == null)\r\n        return mBudgetAmounts;\r\n    if (mBudgetAmounts.isEmpty()) {\r\n        ArrayList<BudgetAmount> budgetAmounts = new ArrayList();\r\n        Money amount = new Money(value, Commodity.DEFAULT_COMMODITY);\r\n        String accountUID = mAccountsDbAdapter.getUID(mBudgetAccountSpinner.getSelectedItemId());\r\n        BudgetAmount budgetAmount = new BudgetAmount(amount, accountUID);\r\n        budgetAmounts.add(budgetAmount);\r\n        return budgetAmounts;\r\n    } else {\r\n        return mBudgetAmounts;\r\n    }\r\n}"
}, {
	"Path": "ca.uhn.fhir.context.RuntimeResourceDefinition.getBaseDefinition",
	"Comment": "if this definition refers to a class which extends another resource definition type, this\tmethod will return the definition of the topmost resource. for example, if this definition\trefers to mypatient2, which extends mypatient, which in turn extends patient, this method\twill return the resource definition for patient.\tif the definition has no parent, returns this",
	"Method": "RuntimeResourceDefinition getBaseDefinition(){\r\n    validateSealed();\r\n    if (myBaseDefinition == null) {\r\n        myBaseDefinition = myContext.getResourceDefinition(myBaseType);\r\n    }\r\n    return myBaseDefinition;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.BudgetsDbAdapter.getAccountSum",
	"Comment": "returns the sum of the account balances for all accounts in a budget for a specified time periodthis represents the total amount spent within the account of this budget in a given period",
	"Method": "Money getAccountSum(String budgetUID,long periodStart,long periodEnd){\r\n    List<BudgetAmount> budgetAmounts = mBudgetAmountsDbAdapter.getBudgetAmountsForBudget(budgetUID);\r\n    List<String> accountUIDs = new ArrayList();\r\n    for (BudgetAmount budgetAmount : budgetAmounts) {\r\n        accountUIDs.add(budgetAmount.getAccountUID());\r\n    }\r\n    return new AccountsDbAdapter(mDb).getAccountsBalance(accountUIDs, periodStart, periodEnd);\r\n}"
}, {
	"Path": "ca.uhn.fhir.model.base.composite.BaseResourceReferenceDt.loadResource",
	"Comment": "returns the referenced resource, fetching it if it has not already been loaded. this method invokes the\thttp client to retrieve the resource unless it has already been loaded, or was a contained resource in which case\tit is simply returned.",
	"Method": "IBaseResource loadResource(IRestfulClient theClient){\r\n    if (myResource != null) {\r\n        return myResource;\r\n    }\r\n    IdDt resourceId = getReference();\r\n    if (resourceId == null || isBlank(resourceId.getValue())) {\r\n        throw new IllegalStateException(\"Reference has no resource ID defined\");\r\n    }\r\n    if (isBlank(resourceId.getBaseUrl()) || isBlank(resourceId.getResourceType())) {\r\n        throw new IllegalStateException(\"Reference is not complete (must be in the form [baseUrl]/[resource type]/[resource ID]) - Reference is: \" + resourceId.getValue());\r\n    }\r\n    String resourceUrl = resourceId.getValue();\r\n    ourLog.debug(\"Loading resource at URL: {}\", resourceUrl);\r\n    RuntimeResourceDefinition definition = theClient.getFhirContext().getResourceDefinition(resourceId.getResourceType());\r\n    Class<? extends IBaseResource> resourceType = definition.getImplementingClass();\r\n    myResource = theClient.fetchResourceFromUrl(resourceType, resourceUrl);\r\n    myResource.setId(resourceUrl);\r\n    return myResource;\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.notifications.AbstractNotification.getChannelId",
	"Comment": "returns the notification channel uuid provided by the client in the watch request.",
	"Method": "String getChannelId(){\r\n    return channelId;\r\n}"
}, {
	"Path": "ca.uhn.fhir.context.FhirContext.getResourceDefinition",
	"Comment": "returns the scanned runtime model for the given type. this is an advanced feature which is generally only needed\tfor extending the core library.\tnote that this method is case insensitive!",
	"Method": "RuntimeResourceDefinition getResourceDefinition(Class<? extends IBaseResource> theResourceType,RuntimeResourceDefinition getResourceDefinition,FhirVersionEnum theVersion,String theResourceName,RuntimeResourceDefinition getResourceDefinition,IBaseResource theResource,RuntimeResourceDefinition getResourceDefinition,String theResourceName){\r\n    validateInitialized();\r\n    Validate.notBlank(theResourceName, \"theResourceName must not be blank\");\r\n    String resourceName = theResourceName.toLowerCase();\r\n    RuntimeResourceDefinition retVal = myNameToResourceDefinition.get(resourceName);\r\n    if (retVal == null) {\r\n        Class<? extends IBaseResource> clazz = myNameToResourceType.get(resourceName.toLowerCase());\r\n        if (clazz == null) {\r\n            throw new DataFormatException(createUnknownResourceNameError(theResourceName, myVersion.getVersion()));\r\n        }\r\n        if (IBaseResource.class.isAssignableFrom(clazz)) {\r\n            retVal = scanResourceType(clazz);\r\n        }\r\n    }\r\n    return retVal;\r\n}"
}, {
	"Path": "ca.uhn.fhir.context.FhirContext.getResourceDefinitionById",
	"Comment": "returns the scanned runtime model for the given type. this is an advanced feature which is generally only needed\tfor extending the core library.",
	"Method": "RuntimeResourceDefinition getResourceDefinitionById(String theId){\r\n    validateInitialized();\r\n    return myIdToResourceDefinition.get(theId);\r\n}"
}, {
	"Path": "org.gnucash.android.service.ScheduledActionService.processScheduledActions",
	"Comment": "made public static for testing. do not call these methods directly",
	"Method": "void processScheduledActions(List<ScheduledAction> scheduledActions,SQLiteDatabase db){\r\n    for (ScheduledAction scheduledAction : scheduledActions) {\r\n        long now = System.currentTimeMillis();\r\n        int totalPlannedExecutions = scheduledAction.getTotalPlannedExecutionCount();\r\n        int executionCount = scheduledAction.getExecutionCount();\r\n        if (scheduledAction.getStartTime() > now || !scheduledAction.isEnabled() || (totalPlannedExecutions > 0 && executionCount >= totalPlannedExecutions)) {\r\n            Log.i(LOG_TAG, \"Skipping scheduled action: \" + scheduledAction.toString());\r\n            continue;\r\n        }\r\n        executeScheduledEvent(scheduledAction, db);\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.app.GnuCashApplication.setUpUserVoice",
	"Comment": "sets up uservoice.allows users to contact with us and access help topics.",
	"Method": "void setUpUserVoice(){\r\n    Config config = new Config(\"gnucash.uservoice.com\");\r\n    config.setTopicId(107400);\r\n    config.setForumId(320493);\r\n    config.putUserTrait(\"app_version_name\", BuildConfig.VERSION_NAME);\r\n    config.putUserTrait(\"app_version_code\", BuildConfig.VERSION_CODE);\r\n    config.putUserTrait(\"android_version\", Build.VERSION.RELEASE);\r\n    UserVoice.init(config, this);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.getEnteredName",
	"Comment": "retrieves the name of the account which has been entered in the edittext",
	"Method": "String getEnteredName(){\r\n    return mNameEditText.getText().toString().trim();\r\n}"
}, {
	"Path": "org.gnucash.android.ui.util.widget.TransactionTypeSwitch.addOnCheckedChangeListener",
	"Comment": "add listeners to be notified when the checked status changes",
	"Method": "void addOnCheckedChangeListener(OnCheckedChangeListener checkedChangeListener){\r\n    mOnCheckedChangeListeners.add(checkedChangeListener);\r\n}"
}, {
	"Path": "org.gnucash.android.export.Exporter.getExportCacheFilePath",
	"Comment": "returns the path to the file where the exporter should save the export during generationthis path is a temporary cache file whose file extension matches the export format.this file is deleted every time a new export is started",
	"Method": "String getExportCacheFilePath(){\r\n    if (mExportCacheFilePath == null) {\r\n        String cachePath = mCacheDir.getAbsolutePath();\r\n        if (!cachePath.endsWith(\"/\"))\r\n            cachePath += \"/\";\r\n        String bookName = BooksDbAdapter.getInstance().getAttribute(mBookUID, DatabaseSchema.BookEntry.COLUMN_DISPLAY_NAME);\r\n        mExportCacheFilePath = cachePath + buildExportFilename(mExportParams.getExportFormat(), bookName);\r\n    }\r\n    return mExportCacheFilePath;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.getAccountBalance",
	"Comment": "returns the account balance for all accounts types specified",
	"Method": "Money getAccountBalance(String accountUID,Money getAccountBalance,String accountUID,long startTimestamp,long endTimestamp,Money getAccountBalance,AccountType accountType,long startTimestamp,long endTimestamp,Money getAccountBalance,List<AccountType> accountTypes,long start,long end){\r\n    Money balance = Money.createZeroInstance(GnuCashApplication.getDefaultCurrencyCode());\r\n    for (AccountType accountType : accountTypes) {\r\n        balance = balance.add(getAccountBalance(accountType, start, end));\r\n    }\r\n    return balance;\r\n}"
}, {
	"Path": "ca.uhn.fhir.model.primitive.IdDt.withVersion",
	"Comment": "creates a new instance of this id which is identical, but refers to the specific version of this resource id noted by theversion.",
	"Method": "IdDt withVersion(String theVersion){\r\n    if (isBlank(theVersion)) {\r\n        return toVersionless();\r\n    }\r\n    if (isLocal() || isUrn()) {\r\n        return new IdDt(getValueAsString());\r\n    }\r\n    String existingValue = getValue();\r\n    int i = existingValue.indexOf(Constants.PARAM_HISTORY);\r\n    String value;\r\n    if (i > 1) {\r\n        value = existingValue.substring(0, i - 1);\r\n    } else {\r\n        value = existingValue;\r\n    }\r\n    return new IdDt(value + '/' + Constants.PARAM_HISTORY + '/' + theVersion);\r\n}"
}, {
	"Path": "com.google.api.client.json.CustomizeJsonParser.stopAt",
	"Comment": "returns whether to stop parsing at the given key of the given context object.",
	"Method": "boolean stopAt(Object context,String key){\r\n    return false;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Book.getDisplayName",
	"Comment": "returns a name for the bookthis is the user readable string which is used in ui unlike the root account guid whichis used for uniquely identifying each book",
	"Method": "String getDisplayName(){\r\n    return mDisplayName;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.homescreen.WidgetConfigurationActivity.updateWidget",
	"Comment": "updates the widget with id appwidgetid with information from the \taccount with record id accountidif the account has been deleted, then a notice is posted in the widget",
	"Method": "void updateWidget(Context context,int appWidgetId){\r\n    Log.i(\"WidgetConfiguration\", \"Updating widget: \" + appWidgetId);\r\n    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);\r\n    loadOldPreferences(context, appWidgetId);\r\n    SharedPreferences preferences = context.getSharedPreferences(\"widget:\" + appWidgetId, MODE_PRIVATE);\r\n    String bookUID = preferences.getString(UxArgument.BOOK_UID, null);\r\n    String accountUID = preferences.getString(UxArgument.SELECTED_ACCOUNT_UID, null);\r\n    boolean hideAccountBalance = preferences.getBoolean(UxArgument.HIDE_ACCOUNT_BALANCE_IN_WIDGET, false);\r\n    if (bookUID == null || accountUID == null) {\r\n        return;\r\n    }\r\n    AccountsDbAdapter accountsDbAdapter = new AccountsDbAdapter(BookDbHelper.getDatabase(bookUID));\r\n    final Account account;\r\n    try {\r\n        account = accountsDbAdapter.getRecord(accountUID);\r\n    } catch (IllegalArgumentException e) {\r\n        Log.i(\"WidgetConfiguration\", \"Account not found, resetting widget \" + appWidgetId);\r\n        RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.widget_4x1);\r\n        views.setTextViewText(R.id.account_name, context.getString(R.string.toast_account_deleted));\r\n        views.setTextViewText(R.id.transactions_summary, \"\");\r\n        PendingIntent pendingIntent = PendingIntent.getActivity(context, 0, new Intent(context, AccountsActivity.class), 0);\r\n        views.setOnClickPendingIntent(R.id.widget_layout, pendingIntent);\r\n        views.setOnClickPendingIntent(R.id.btn_new_transaction, pendingIntent);\r\n        appWidgetManager.updateAppWidget(appWidgetId, views);\r\n        Editor editor = PreferenceActivity.getActiveBookSharedPreferences().edit();\r\n        editor.remove(UxArgument.SELECTED_ACCOUNT_UID + appWidgetId);\r\n        editor.apply();\r\n        return;\r\n    }\r\n    final RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.widget_4x1);\r\n    views.setTextViewText(R.id.account_name, account.getName());\r\n    Money accountBalance = accountsDbAdapter.getAccountBalance(accountUID, -1, System.currentTimeMillis());\r\n    if (hideAccountBalance) {\r\n        views.setViewVisibility(R.id.transactions_summary, View.GONE);\r\n    } else {\r\n        views.setTextViewText(R.id.transactions_summary, accountBalance.formattedString(Locale.getDefault()));\r\n        int color = accountBalance.isNegative() ? R.color.debit_red : R.color.credit_green;\r\n        views.setTextColor(R.id.transactions_summary, ContextCompat.getColor(context, color));\r\n    }\r\n    Intent accountViewIntent = new Intent(context, TransactionsActivity.class);\r\n    accountViewIntent.setAction(Intent.ACTION_VIEW);\r\n    accountViewIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);\r\n    accountViewIntent.putExtra(UxArgument.SELECTED_ACCOUNT_UID, accountUID);\r\n    accountViewIntent.putExtra(UxArgument.BOOK_UID, bookUID);\r\n    PendingIntent accountPendingIntent = PendingIntent.getActivity(context, appWidgetId, accountViewIntent, 0);\r\n    views.setOnClickPendingIntent(R.id.widget_layout, accountPendingIntent);\r\n    if (accountsDbAdapter.isPlaceholderAccount(accountUID)) {\r\n        views.setOnClickPendingIntent(R.id.btn_view_account, accountPendingIntent);\r\n        views.setViewVisibility(R.id.btn_new_transaction, View.GONE);\r\n    } else {\r\n        Intent newTransactionIntent = new Intent(context, FormActivity.class);\r\n        newTransactionIntent.setAction(Intent.ACTION_INSERT_OR_EDIT);\r\n        newTransactionIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\r\n        newTransactionIntent.putExtra(UxArgument.FORM_TYPE, FormActivity.FormType.TRANSACTION.name());\r\n        newTransactionIntent.putExtra(UxArgument.BOOK_UID, bookUID);\r\n        newTransactionIntent.putExtra(UxArgument.SELECTED_ACCOUNT_UID, accountUID);\r\n        PendingIntent pendingIntent = PendingIntent.getActivity(context, appWidgetId, newTransactionIntent, 0);\r\n        views.setOnClickPendingIntent(R.id.btn_new_transaction, pendingIntent);\r\n        views.setViewVisibility(R.id.btn_view_account, View.GONE);\r\n    }\r\n    appWidgetManager.updateAppWidget(appWidgetId, views);\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.db.SplitsDbAdapterTest.shouldHaveAccountInDatabase",
	"Comment": "adding a split where the account does not exist in the database should generate an exception",
	"Method": "void shouldHaveAccountInDatabase(){\r\n    Transaction transaction = new Transaction(\"\");\r\n    mTransactionsDbAdapter.addRecord(transaction);\r\n    Split split = new Split(Money.getZeroInstance(), \"non-existent\");\r\n    split.setTransactionUID(transaction.getUID());\r\n    mSplitsDbAdapter.addRecord(split);\r\n}"
}, {
	"Path": "org.gnucash.android.model.Transaction.isExported",
	"Comment": "returns true if the transaction has been exported, false otherwise",
	"Method": "boolean isExported(){\r\n    return mIsExported;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.report.ReportsActivity.updateAccountTypeOnFragments",
	"Comment": "updates the account type for all attached fragments which are listening",
	"Method": "void updateAccountTypeOnFragments(){\r\n    List<Fragment> fragments = getSupportFragmentManager().getFragments();\r\n    for (Fragment fragment : fragments) {\r\n        if (fragment instanceof ReportOptionsListener) {\r\n            ((ReportOptionsListener) fragment).onAccountTypeUpdated(mAccountType);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.xml.atom.MultiKindFeedParser.create",
	"Comment": "parses the given http response using the given feed class and entry classes.",
	"Method": "MultiKindFeedParser<T> create(HttpResponse response,XmlNamespaceDictionary namespaceDictionary,Class<T> feedClass,Class<E> entryClasses){\r\n    InputStream content = response.getContent();\r\n    try {\r\n        Atom.checkContentType(response.getContentType());\r\n        XmlPullParser parser = Xml.createParser();\r\n        parser.setInput(content, null);\r\n        MultiKindFeedParser<T> result = new MultiKindFeedParser<T>(namespaceDictionary, parser, content, feedClass);\r\n        result.setEntryClasses(entryClasses);\r\n        return result;\r\n    } finally {\r\n        content.close();\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.dialog.BulkMoveDialogFragment.onCreateView",
	"Comment": "creates the view and retrieves references to the dialog elements",
	"Method": "View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){\r\n    View v = inflater.inflate(R.layout.dialog_bulk_move, container, false);\r\n    mDestinationAccountSpinner = (Spinner) v.findViewById(R.id.accounts_list_spinner);\r\n    mOkButton = (Button) v.findViewById(R.id.btn_save);\r\n    mOkButton.setText(R.string.btn_move);\r\n    mCancelButton = (Button) v.findViewById(R.id.btn_cancel);\r\n    return v;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.settings.BackupPreferenceFragment.toggleDropboxPreference",
	"Comment": "toggles the checkbox of the dropbox sync preference if a dropbox account is linked",
	"Method": "void toggleDropboxPreference(Preference pref){\r\n    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(getActivity());\r\n    String accessToken = prefs.getString(getString(R.string.key_dropbox_access_token), null);\r\n    ((CheckBoxPreference) pref).setChecked(accessToken != null);\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.services.AbstractGoogleClientRequest.getDisableGZipContent",
	"Comment": "returns whether to disable gzip compression of http content.",
	"Method": "boolean getDisableGZipContent(){\r\n    return disableGZipContent;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.ScheduledActionsListFragment.setActionModeTitle",
	"Comment": "sets the title of the context actionbar when in action mode.it sets the number highlighted items",
	"Method": "void setActionModeTitle(){\r\n    int count = getListView().getCheckedItemIds().length;\r\n    if (count > 0) {\r\n        mActionMode.setTitle(getResources().getString(R.string.title_selected, count));\r\n    }\r\n}"
}, {
	"Path": "example.RequestCounterInterceptor.incomingRequestPreProcessed",
	"Comment": "override the incomingrequestpreprocessed method, which is called for each incoming request before any processing is done",
	"Method": "boolean incomingRequestPreProcessed(HttpServletRequest theRequest,HttpServletResponse theResponse){\r\n    myRequestCount++;\r\n    return true;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.setDefaultTransferAccountInputsVisible",
	"Comment": "toggles the visibility of the default transfer account input fields.this field is irrelevant for users who do not use double accounting",
	"Method": "void setDefaultTransferAccountInputsVisible(boolean visible){\r\n    final int visibility = visible ? View.VISIBLE : View.GONE;\r\n    final View view = getView();\r\n    assert view != null;\r\n    view.findViewById(R.id.layout_default_transfer_account).setVisibility(visibility);\r\n    view.findViewById(R.id.label_default_transfer_account).setVisibility(visibility);\r\n}"
}, {
	"Path": "com.google.api.client.util.ExponentialBackOff.getMultiplier",
	"Comment": "returns the value to multiply the current interval with for each retry attempt.",
	"Method": "double getMultiplier(double getMultiplier){\r\n    return multiplier;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.dialog.TransferFundsDialogFragment.transferFunds",
	"Comment": "converts the currency amount with the given exchange rate and saves the price to the db",
	"Method": "void transferFunds(){\r\n    Price price = null;\r\n    String originCommodityUID = mOriginAmount.getCommodity().getUID();\r\n    String targetCommodityUID = mTargetCommodity.getUID();\r\n    if (mExchangeRateRadioButton.isChecked()) {\r\n        BigDecimal rate;\r\n        try {\r\n            rate = AmountParser.parse(mExchangeRateInput.getText().toString());\r\n        } catch (ParseException e) {\r\n            mExchangeRateInputLayout.setError(getString(R.string.error_invalid_exchange_rate));\r\n            return;\r\n        }\r\n        price = new Price(originCommodityUID, targetCommodityUID, rate);\r\n        mConvertedAmount = mOriginAmount.multiply(rate).withCurrency(mTargetCommodity);\r\n    }\r\n    if (mConvertedAmountRadioButton.isChecked()) {\r\n        BigDecimal amount;\r\n        try {\r\n            amount = AmountParser.parse(mConvertedAmountInput.getText().toString());\r\n        } catch (ParseException e) {\r\n            mConvertedAmountInputLayout.setError(getString(R.string.error_invalid_amount));\r\n            return;\r\n        }\r\n        mConvertedAmount = new Money(amount, mTargetCommodity);\r\n        price = new Price(originCommodityUID, targetCommodityUID);\r\n        price.setValueNum(mConvertedAmount.getNumerator() * mOriginAmount.getDenominator());\r\n        price.setValueDenom(mOriginAmount.getNumerator() * mConvertedAmount.getDenominator());\r\n    }\r\n    price.setSource(Price.SOURCE_USER);\r\n    PricesDbAdapter.getInstance().addRecord(price);\r\n    if (mOnTransferFundsListener != null)\r\n        mOnTransferFundsListener.transferComplete(mConvertedAmount);\r\n    dismiss();\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.services.AbstractGoogleClient.getSuppressRequiredParameterChecks",
	"Comment": "returns whether discovery required parameter checks should be suppressed.",
	"Method": "boolean getSuppressRequiredParameterChecks(boolean getSuppressRequiredParameterChecks){\r\n    return suppressRequiredParameterChecks;\r\n}"
}, {
	"Path": "org.gnucash.android.app.GnuCashApplication.darken",
	"Comment": "returns darker version of specified color.use for theming the status bar color when setting the color of the actionbar",
	"Method": "int darken(int color){\r\n    float[] hsv = new float[3];\r\n    Color.colorToHSV(color, hsv);\r\n    hsv[2] *= 0.8f;\r\n    return Color.HSVToColor(hsv);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.util.widget.CalculatorEditText.evaluate",
	"Comment": "evaluates the arithmetic expression in the edittext and sets the text property",
	"Method": "String evaluate(){\r\n    String amountString = getCleanString();\r\n    if (amountString.isEmpty())\r\n        return amountString;\r\n    ExpressionBuilder expressionBuilder = new ExpressionBuilder(amountString);\r\n    Expression expression;\r\n    try {\r\n        expression = expressionBuilder.build();\r\n    } catch (RuntimeException e) {\r\n        setError(getContext().getString(R.string.label_error_invalid_expression));\r\n        String msg = \"Invalid expression: \" + amountString;\r\n        Log.e(this.getClass().getSimpleName(), msg);\r\n        Crashlytics.log(msg);\r\n        return \"\";\r\n    }\r\n    if (expression != null && expression.validate().isValid()) {\r\n        BigDecimal result = new BigDecimal(expression.evaluate());\r\n        setValue(result);\r\n    } else {\r\n        setError(getContext().getString(R.string.label_error_invalid_expression));\r\n        Log.w(VIEW_LOG_TAG, \"Expression is null or invalid: \" + expression);\r\n    }\r\n    return getText().toString();\r\n}"
}, {
	"Path": "ca.uhn.fhir.narrative.BaseThymeleafNarrativeGenerator.isIgnoreFailures",
	"Comment": "if set to true, which is the default, if any failure occurs during narrative generation the\tgenerator will suppress any generated exceptions, and simply return a default narrative indicating that no\tnarrative is available.",
	"Method": "boolean isIgnoreFailures(){\r\n    return myIgnoreFailures;\r\n}"
}, {
	"Path": "com.google.api.client.util.ByteStreams.copy",
	"Comment": "copies all bytes from the input stream to the output stream. does not close or flush eitherstream.",
	"Method": "long copy(InputStream from,OutputStream to){\r\n    Preconditions.checkNotNull(from);\r\n    Preconditions.checkNotNull(to);\r\n    byte[] buf = new byte[BUF_SIZE];\r\n    long total = 0;\r\n    while (true) {\r\n        int r = from.read(buf);\r\n        if (r == -1) {\r\n            break;\r\n        }\r\n        to.write(buf, 0, r);\r\n        total += r;\r\n    }\r\n    return total;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Account.isPlaceholderAccount",
	"Comment": "returns true if this account is a placeholder account, false otherwise.",
	"Method": "boolean isPlaceholderAccount(){\r\n    return mIsPlaceholderAccount;\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.db.BooksDbAdapterTest.testGeneratedDisplayName",
	"Comment": "test that the generated display name has an ordinal greater than the number ofbook records in the database",
	"Method": "void testGeneratedDisplayName(){\r\n    Book book1 = new Book(BaseModel.generateUID());\r\n    Book book2 = new Book(BaseModel.generateUID());\r\n    mBooksDbAdapter.addRecord(book1);\r\n    mBooksDbAdapter.addRecord(book2);\r\n    assertThat(mBooksDbAdapter.generateDefaultBookName()).isEqualTo(\"Book 3\");\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.getAdvanceCreateDays",
	"Comment": "returns number of days in advance to create the transactionthis flag is currently unused in the app. it is only included here for compatibility with gnucash desktop xml",
	"Method": "int getAdvanceCreateDays(){\r\n    return mAdvanceCreateDays;\r\n}"
}, {
	"Path": "com.google.api.client.http.HttpHeaders.getAsList",
	"Comment": "returns the list value to use for the given parameter passed to the setter method.",
	"Method": "List<T> getAsList(T passedValue){\r\n    if (passedValue == null) {\r\n        return null;\r\n    }\r\n    List<T> result = new ArrayList<T>();\r\n    result.add(passedValue);\r\n    return result;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.util.widget.TransactionTypeSwitch.setChecked",
	"Comment": "toggles the button checked based on the movement caused by the transaction type for the specified account",
	"Method": "void setChecked(TransactionType transactionType){\r\n    setChecked(Transaction.shouldDecreaseBalance(mAccountType, transactionType));\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.setAutoNotify",
	"Comment": "sets whether to notify the user that scheduled transactions have been createdthis flag is currently unused in the app. it is only included here for compatibility with gnucash desktop xml",
	"Method": "void setAutoNotify(boolean autoNotify){\r\n    this.mAutoNotify = autoNotify;\r\n}"
}, {
	"Path": "com.google.api.client.http.ExponentialBackOffPolicy.getMaxIntervalMillis",
	"Comment": "returns the maximum value of the back off period in milliseconds. once the current intervalreaches this value it stops increasing.",
	"Method": "int getMaxIntervalMillis(int getMaxIntervalMillis){\r\n    return exponentialBackOff.getMaxIntervalMillis();\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.BooksDbAdapter.recoverBookRecords",
	"Comment": "restores the records in the book database.does so by looking for database files from books.",
	"Method": "void recoverBookRecords(){\r\n    for (String dbName : getBookDatabases()) {\r\n        Book book = new Book(getRootAccountUID(dbName));\r\n        book.setUID(dbName);\r\n        book.setDisplayName(generateDefaultBookName());\r\n        addRecord(book);\r\n        Log.w(LOG_TAG, \"Recovered book record: \" + book.getUID());\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.db.SplitsDbAdapterTest.shouldHaveTransactionInDatabase",
	"Comment": "adding a split where the account does not exist in the database should generate an exception",
	"Method": "void shouldHaveTransactionInDatabase(){\r\n    Transaction transaction = new Transaction(\"\");\r\n    Split split = new Split(Money.getZeroInstance(), mAccount.getUID());\r\n    split.setTransactionUID(transaction.getUID());\r\n    mSplitsDbAdapter.addRecord(split);\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.services.AbstractGoogleClientRequest.execute",
	"Comment": "sends the metadata request to the server and returns the parsed metadata response.subclasses may override by calling the super implementation.",
	"Method": "T execute(){\r\n    return executeUnparsed().parseAs(responseClass);\r\n}"
}, {
	"Path": "ca.uhn.fhir.jpa.demo.FhirServerConfigDstu2.daoConfig",
	"Comment": "configure fhir properties around the the jpa server via this bean",
	"Method": "DaoConfig daoConfig(){\r\n    return FhirServerConfigCommon.getDaoConfig();\r\n}"
}, {
	"Path": "org.gnucash.android.model.Transaction.setUID",
	"Comment": "set the guid of the transactionif the transaction has splits, their transactionguid will be updated as well",
	"Method": "void setUID(String uid){\r\n    super.setUID(uid);\r\n    for (Split split : mSplitList) {\r\n        split.setTransactionUID(uid);\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.test.ui.AccountsActivityTest.first",
	"Comment": "matcher to select the first of multiple views which are matched in the ui",
	"Method": "Matcher<View> first(Matcher<View> expected){\r\n    return new TypeSafeMatcher<View>() {\r\n        private boolean first = false;\r\n        @Override\r\n        protected boolean matchesSafely(View item) {\r\n            if (expected.matches(item) && !first) {\r\n                return first = true;\r\n            }\r\n            return false;\r\n        }\r\n        @Override\r\n        public void describeTo(Description description) {\r\n            description.appendText(\"Matcher.first( \" + expected.toString() + \" )\");\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.gnucash.android.test.ui.AccountsActivityTest.first",
	"Comment": "matcher to select the first of multiple views which are matched in the ui",
	"Method": "Matcher<View> first(Matcher<View> expected){\r\n    if (expected.matches(item) && !first) {\r\n        return first = true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.gnucash.android.test.ui.AccountsActivityTest.first",
	"Comment": "matcher to select the first of multiple views which are matched in the ui",
	"Method": "Matcher<View> first(Matcher<View> expected){\r\n    description.appendText(\"Matcher.first( \" + expected.toString() + \" )\");\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.TransactionFormFragment.saveNewTransaction",
	"Comment": "collects information from the fragment views and uses it to create\tand save a transaction",
	"Method": "void saveNewTransaction(){\r\n    mAmountEditText.getCalculatorKeyboard().hideCustomKeyboard();\r\n    if (isMultiCurrencyTransaction() && !splitEditorUsed() && !mCurrencyConversionDone) {\r\n        onSaveAttempt = true;\r\n        startTransferFunds();\r\n        return;\r\n    }\r\n    Transaction transaction = extractTransactionFromView();\r\n    if (mEditMode) {\r\n        transaction.setUID(mTransaction.getUID());\r\n    }\r\n    mTransaction = transaction;\r\n    mAccountsDbAdapter.beginTransaction();\r\n    try {\r\n        mTransactionsDbAdapter.addRecord(mTransaction, DatabaseAdapter.UpdateMethod.replace);\r\n        if (mSaveTemplateCheckbox.isChecked()) {\r\n            if (!mEditMode) {\r\n                Transaction templateTransaction = new Transaction(mTransaction, true);\r\n                templateTransaction.setTemplate(true);\r\n                mTransactionsDbAdapter.addRecord(templateTransaction, DatabaseAdapter.UpdateMethod.replace);\r\n                scheduleRecurringTransaction(templateTransaction.getUID());\r\n            } else\r\n                scheduleRecurringTransaction(mTransaction.getUID());\r\n        } else {\r\n            String scheduledActionUID = getArguments().getString(UxArgument.SCHEDULED_ACTION_UID);\r\n            if (scheduledActionUID != null) {\r\n                ScheduledActionDbAdapter.getInstance().deleteRecord(scheduledActionUID);\r\n            }\r\n        }\r\n        mAccountsDbAdapter.setTransactionSuccessful();\r\n    } finally {\r\n        mAccountsDbAdapter.endTransaction();\r\n    }\r\n    WidgetConfigurationActivity.updateAllWidgets(getActivity().getApplicationContext());\r\n    finish(Activity.RESULT_OK);\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.CommoditiesDbAdapter.fetchAllRecords",
	"Comment": "fetches all commodities in the database sorted in the specified order",
	"Method": "Cursor fetchAllRecords(Cursor fetchAllRecords,String orderBy){\r\n    return mDb.query(mTableName, null, null, null, null, null, orderBy);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.finishFragment",
	"Comment": "finishes the fragment appropriately.\tdepends on how the fragment was loaded, it might have a backstack or not",
	"Method": "void finishFragment(){\r\n    InputMethodManager imm = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE);\r\n    imm.hideSoftInputFromWindow(mNameEditText.getWindowToken(), 0);\r\n    final String action = getActivity().getIntent().getAction();\r\n    if (action != null && action.equals(Intent.ACTION_INSERT_OR_EDIT)) {\r\n        getActivity().setResult(Activity.RESULT_OK);\r\n        getActivity().finish();\r\n    } else {\r\n        getActivity().getSupportFragmentManager().popBackStack();\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.SplitsDbAdapter.addRecord",
	"Comment": "adds a split to the database.the transactions belonging to the split are marked as exported",
	"Method": "void addRecord(Split split,UpdateMethod updateMethod){\r\n    Log.d(LOG_TAG, \"Replace transaction split in db\");\r\n    super.addRecord(split, updateMethod);\r\n    long transactionId = getTransactionID(split.getTransactionUID());\r\n    updateRecord(TransactionEntry.TABLE_NAME, transactionId, TransactionEntry.COLUMN_EXPORTED, String.valueOf(0));\r\n    updateRecord(TransactionEntry.TABLE_NAME, transactionId, TransactionEntry.COLUMN_MODIFIED_AT, TimestampHelper.getUtcStringFromTimestamp(TimestampHelper.getTimestampFromNow()));\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.fetchAllRecords",
	"Comment": "returns a cursor to all account records in the database.gnucash root accounts and hidden accounts will not be included in the result set",
	"Method": "Cursor fetchAllRecords(){\r\n    Log.v(LOG_TAG, \"Fetching all accounts from db\");\r\n    String selection = AccountEntry.COLUMN_HIDDEN + \" = 0 AND \" + AccountEntry.COLUMN_TYPE + \" != ?\";\r\n    return mDb.query(AccountEntry.TABLE_NAME, null, selection, new String[] { AccountType.ROOT.name() }, null, null, AccountEntry.COLUMN_NAME + \" ASC\");\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.RecurrenceDbAdapter.byDaysToString",
	"Comment": "converts a list of days of week as calendar constants to an string forstoring in the database.",
	"Method": "String byDaysToString(List<Integer> byDays){\r\n    StringBuilder builder = new StringBuilder();\r\n    for (int day : byDays) {\r\n        switch(day) {\r\n            case Calendar.MONDAY:\r\n                builder.append(\"MO\");\r\n                break;\r\n            case Calendar.TUESDAY:\r\n                builder.append(\"TU\");\r\n                break;\r\n            case Calendar.WEDNESDAY:\r\n                builder.append(\"WE\");\r\n                break;\r\n            case Calendar.THURSDAY:\r\n                builder.append(\"TH\");\r\n                break;\r\n            case Calendar.FRIDAY:\r\n                builder.append(\"FR\");\r\n                break;\r\n            case Calendar.SATURDAY:\r\n                builder.append(\"SA\");\r\n                break;\r\n            case Calendar.SUNDAY:\r\n                builder.append(\"SU\");\r\n                break;\r\n            default:\r\n                throw new RuntimeException(\"bad day of week: \" + day);\r\n        }\r\n        builder.append(\",\");\r\n    }\r\n    builder.deleteCharAt(builder.length() - 1);\r\n    return builder.toString();\r\n}"
}, {
	"Path": "org.gnucash.android.db.MigrationHelper.upgradeDbToVersion6",
	"Comment": "upgrades the database from version 5 to version 6.this migration adds support for fully qualified account names and updates existing accounts.",
	"Method": "int upgradeDbToVersion6(SQLiteDatabase db){\r\n    int oldVersion = 5;\r\n    String addFullAccountNameQuery = \" ALTER TABLE \" + AccountEntry.TABLE_NAME + \" ADD COLUMN \" + AccountEntry.COLUMN_FULL_NAME + \" varchar(255) \";\r\n    db.execSQL(addFullAccountNameQuery);\r\n    Cursor cursor = db.query(AccountEntry.TABLE_NAME, new String[] { AccountEntry._ID, AccountEntry.COLUMN_UID }, null, null, null, null, null);\r\n    while (cursor != null && cursor.moveToNext()) {\r\n        String uid = cursor.getString(cursor.getColumnIndexOrThrow(AccountEntry.COLUMN_UID));\r\n        String fullName = getFullyQualifiedAccountName(db, uid);\r\n        if (fullName == null)\r\n            continue;\r\n        ContentValues contentValues = new ContentValues();\r\n        contentValues.put(AccountEntry.COLUMN_FULL_NAME, fullName);\r\n        long id = cursor.getLong(cursor.getColumnIndexOrThrow(AccountEntry._ID));\r\n        db.update(AccountEntry.TABLE_NAME, contentValues, AccountEntry._ID + \" = \" + id, null);\r\n    }\r\n    if (cursor != null) {\r\n        cursor.close();\r\n    }\r\n    oldVersion = 6;\r\n    return oldVersion;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.getDefaultTransferAccountID",
	"Comment": "returns the default transfer account record id for the account with uid accountuid",
	"Method": "long getDefaultTransferAccountID(long accountID){\r\n    Cursor cursor = mDb.query(AccountEntry.TABLE_NAME, new String[] { AccountEntry.COLUMN_DEFAULT_TRANSFER_ACCOUNT_UID }, AccountEntry._ID + \" = \" + accountID, null, null, null, null);\r\n    try {\r\n        if (cursor.moveToNext()) {\r\n            String uid = cursor.getString(cursor.getColumnIndexOrThrow(AccountEntry.COLUMN_DEFAULT_TRANSFER_ACCOUNT_UID));\r\n            if (uid == null)\r\n                return 0;\r\n            else\r\n                return getID(uid);\r\n        } else {\r\n            return 0;\r\n        }\r\n    } finally {\r\n        cursor.close();\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.db.MigrationHelper.upgradeDbToVersion5",
	"Comment": "upgrades the database from version 4 to 5adds favorites column to accounts",
	"Method": "int upgradeDbToVersion5(SQLiteDatabase db){\r\n    int oldVersion;\r\n    String addAccountFavorite = \" ALTER TABLE \" + AccountEntry.TABLE_NAME + \" ADD COLUMN \" + AccountEntry.COLUMN_FAVORITE + \" tinyint default 0\";\r\n    db.execSQL(addAccountFavorite);\r\n    oldVersion = 5;\r\n    return oldVersion;\r\n}"
}, {
	"Path": "com.google.api.client.json.webtoken.JsonWebSignature.getSignedContentBytes",
	"Comment": "returns the modifiable array of bytes of the signature content.",
	"Method": "byte[] getSignedContentBytes(){\r\n    return signedContentBytes;\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.getActionUID",
	"Comment": "returns the guid of the action covered by this scheduled action",
	"Method": "String getActionUID(){\r\n    return mActionUID;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.report.linechart.CashFlowLineChartFragment.getData",
	"Comment": "returns a data object that represents a user data of the specified account types",
	"Method": "LineData getData(List<AccountType> accountTypeList){\r\n    Log.w(TAG, \"getData\");\r\n    calculateEarliestAndLatestTimestamps(accountTypeList);\r\n    LocalDate startDate;\r\n    LocalDate endDate;\r\n    if (mReportPeriodStart == -1 && mReportPeriodEnd == -1) {\r\n        startDate = new LocalDate(mEarliestTransactionTimestamp).withDayOfMonth(1);\r\n        endDate = new LocalDate(mLatestTransactionTimestamp).withDayOfMonth(1);\r\n    } else {\r\n        startDate = new LocalDate(mReportPeriodStart).withDayOfMonth(1);\r\n        endDate = new LocalDate(mReportPeriodEnd).withDayOfMonth(1);\r\n    }\r\n    int count = getDateDiff(new LocalDateTime(startDate.toDate().getTime()), new LocalDateTime(endDate.toDate().getTime()));\r\n    Log.d(TAG, \"X-axis count\" + count);\r\n    List<String> xValues = new ArrayList();\r\n    for (int i = 0; i <= count; i++) {\r\n        switch(mGroupInterval) {\r\n            case MONTH:\r\n                xValues.add(startDate.toString(X_AXIS_PATTERN));\r\n                Log.d(TAG, \"X-axis \" + startDate.toString(\"MM yy\"));\r\n                startDate = startDate.plusMonths(1);\r\n                break;\r\n            case QUARTER:\r\n                int quarter = getQuarter(new LocalDateTime(startDate.toDate().getTime()));\r\n                xValues.add(\"Q\" + quarter + startDate.toString(\" yy\"));\r\n                Log.d(TAG, \"X-axis \" + \"Q\" + quarter + startDate.toString(\" MM yy\"));\r\n                startDate = startDate.plusMonths(3);\r\n                break;\r\n            case YEAR:\r\n                xValues.add(startDate.toString(\"yyyy\"));\r\n                Log.d(TAG, \"X-axis \" + startDate.toString(\"yyyy\"));\r\n                startDate = startDate.plusYears(1);\r\n                break;\r\n        }\r\n    }\r\n    List<LineDataSet> dataSets = new ArrayList();\r\n    for (AccountType accountType : accountTypeList) {\r\n        LineDataSet set = new LineDataSet(getEntryList(accountType), accountType.toString());\r\n        set.setDrawFilled(true);\r\n        set.setLineWidth(2);\r\n        set.setColor(COLORS[dataSets.size()]);\r\n        set.setFillColor(FILL_COLORS[dataSets.size()]);\r\n        dataSets.add(set);\r\n    }\r\n    LineData lineData = new LineData(xValues, dataSets);\r\n    if (lineData.getYValueSum() == 0) {\r\n        mChartDataPresent = false;\r\n        return getEmptyData();\r\n    }\r\n    return lineData;\r\n}"
}, {
	"Path": "com.google.api.client.json.JsonFactory.createJsonObjectParser",
	"Comment": "creates an object parser which uses this factory to parse json data.",
	"Method": "JsonObjectParser createJsonObjectParser(){\r\n    return new JsonObjectParser(this);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.settings.BackupPreferenceFragment.toggleGoogleDrivePreference",
	"Comment": "toggles the checkbox of the googledrive sync preference if a google drive account is linked",
	"Method": "void toggleGoogleDrivePreference(Preference pref){\r\n    SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(getActivity());\r\n    String appFolderId = sharedPreferences.getString(getString(R.string.key_google_drive_app_folder_id), null);\r\n    ((CheckBoxPreference) pref).setChecked(appFolderId != null);\r\n}"
}, {
	"Path": "com.google.api.client.util.ArrayMap.ensureCapacity",
	"Comment": "ensures that the capacity of the internal arrays is at least a given capacity.",
	"Method": "void ensureCapacity(int minCapacity){\r\n    if (minCapacity < 0) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    Object[] data = this.data;\r\n    int minDataCapacity = minCapacity << 1;\r\n    int oldDataCapacity = data == null ? 0 : data.length;\r\n    if (minDataCapacity > oldDataCapacity) {\r\n        int newDataCapacity = oldDataCapacity / 2 * 3 + 1;\r\n        if (newDataCapacity % 2 != 0) {\r\n            newDataCapacity++;\r\n        }\r\n        if (newDataCapacity < minDataCapacity) {\r\n            newDataCapacity = minDataCapacity;\r\n        }\r\n        setDataCapacity(newDataCapacity);\r\n    }\r\n}"
}, {
	"Path": "embedded.FhirRestfulServlet.initialize",
	"Comment": "this method is called automatically when the servlet is initializing.",
	"Method": "void initialize(){\r\n    final List<IResourceProvider> providers = new ArrayList<IResourceProvider>();\r\n    providers.add(new SomeResourceProvider());\r\n    setResourceProviders(providers);\r\n    registerInterceptor(new ResponseHighlighterInterceptor());\r\n}"
}, {
	"Path": "com.google.api.client.http.HttpRequest.isCurlLoggingEnabled",
	"Comment": "returns whether logging in form of curl commands is enabled for this request.",
	"Method": "boolean isCurlLoggingEnabled(){\r\n    return curlLoggingEnabled;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.report.linechart.CashFlowLineChartFragment.getEmptyData",
	"Comment": "returns a data object that represents situation when no user data available",
	"Method": "LineData getEmptyData(){\r\n    List<String> xValues = new ArrayList();\r\n    List<Entry> yValues = new ArrayList();\r\n    for (int i = 0; i < NO_DATA_BAR_COUNTS; i++) {\r\n        xValues.add(\"\");\r\n        yValues.add(new Entry(i % 2 == 0 ? 5f : 4.5f, i));\r\n    }\r\n    LineDataSet set = new LineDataSet(yValues, getResources().getString(R.string.label_chart_no_data));\r\n    set.setDrawFilled(true);\r\n    set.setDrawValues(false);\r\n    set.setColor(NO_DATA_COLOR);\r\n    set.setFillColor(NO_DATA_COLOR);\r\n    return new LineData(xValues, Collections.singletonList(set));\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.fetchRecentAccounts",
	"Comment": "returns a cursor to accounts which have recently had transactions added to them",
	"Method": "Cursor fetchRecentAccounts(int numberOfRecent){\r\n    return // groupby\r\n    mDb.query(// groupby\r\n    TransactionEntry.TABLE_NAME + \" LEFT OUTER JOIN \" + SplitEntry.TABLE_NAME + \" ON \" + TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_UID + \" = \" + SplitEntry.TABLE_NAME + \".\" + SplitEntry.COLUMN_TRANSACTION_UID + \" , \" + AccountEntry.TABLE_NAME + \" ON \" + SplitEntry.TABLE_NAME + \".\" + SplitEntry.COLUMN_ACCOUNT_UID + \" = \" + AccountEntry.TABLE_NAME + \".\" + AccountEntry.COLUMN_UID, // groupby\r\n    new String[] { AccountEntry.TABLE_NAME + \".*\" }, // groupby\r\n    AccountEntry.COLUMN_HIDDEN + \" = 0\", null, SplitEntry.TABLE_NAME + \".\" + SplitEntry.COLUMN_ACCOUNT_UID, null, \"MAX ( \" + TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_TIMESTAMP + \" ) DESC\", Integer.toString(numberOfRecent));\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.convertCalendarDayOfWeekToJoda",
	"Comment": "converts a java.util.calendar day of the week constant to theorg.joda.time.datetimeconstants equivalent.",
	"Method": "int convertCalendarDayOfWeekToJoda(int calendarDayOfWeek){\r\n    Calendar cal = Calendar.getInstance();\r\n    cal.set(Calendar.DAY_OF_WEEK, calendarDayOfWeek);\r\n    return LocalDateTime.fromCalendarFields(cal).getDayOfWeek();\r\n}"
}, {
	"Path": "ca.uhn.fhir.narrative.BaseThymeleafNarrativeGenerator.setIgnoreFailures",
	"Comment": "if set to true, which is the default, if any failure occurs during narrative generation the\tgenerator will suppress any generated exceptions, and simply return a default narrative indicating that no\tnarrative is available.",
	"Method": "void setIgnoreFailures(boolean theIgnoreFailures){\r\n    myIgnoreFailures = theIgnoreFailures;\r\n}"
}, {
	"Path": "com.google.api.client.util.ClassInfo.of",
	"Comment": "returns the class information for the given underlying class.",
	"Method": "ClassInfo of(Class<?> underlyingClass,ClassInfo of,Class<?> underlyingClass,boolean ignoreCase){\r\n    if (underlyingClass == null) {\r\n        return null;\r\n    }\r\n    final Map<Class<?>, ClassInfo> cache = ignoreCase ? CACHE_IGNORE_CASE : CACHE;\r\n    ClassInfo classInfo;\r\n    synchronized (cache) {\r\n        classInfo = cache.get(underlyingClass);\r\n        if (classInfo == null) {\r\n            classInfo = new ClassInfo(underlyingClass, ignoreCase);\r\n            cache.put(underlyingClass, classInfo);\r\n        }\r\n    }\r\n    return classInfo;\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.db.SplitsDbAdapterTest.addingSplitShouldUnsetExportedFlagOfTransaction",
	"Comment": "when a split is added or modified to a transaction, we should set the",
	"Method": "void addingSplitShouldUnsetExportedFlagOfTransaction(){\r\n    Transaction transaction = new Transaction(\"\");\r\n    transaction.setExported(true);\r\n    mTransactionsDbAdapter.addRecord(transaction);\r\n    assertThat(transaction.isExported()).isTrue();\r\n    Split split = new Split(Money.getZeroInstance(), mAccount.getUID());\r\n    split.setTransactionUID(transaction.getUID());\r\n    mSplitsDbAdapter.addRecord(split);\r\n    String isExported = mTransactionsDbAdapter.getAttribute(transaction.getUID(), DatabaseSchema.TransactionEntry.COLUMN_EXPORTED);\r\n    assertThat(Boolean.parseBoolean(isExported)).isFalse();\r\n}"
}, {
	"Path": "org.gnucash.android.model.Account.convertToOfxAccountType",
	"Comment": "maps the accounttype to the corresponding account type.accounttype have corresponding values to gnucash desktop",
	"Method": "OfxAccountType convertToOfxAccountType(AccountType accountType){\r\n    switch(accountType) {\r\n        case CREDIT:\r\n        case LIABILITY:\r\n            return OfxAccountType.CREDITLINE;\r\n        case CASH:\r\n        case INCOME:\r\n        case EXPENSE:\r\n        case PAYABLE:\r\n        case RECEIVABLE:\r\n            return OfxAccountType.CHECKING;\r\n        case BANK:\r\n        case ASSET:\r\n            return OfxAccountType.SAVINGS;\r\n        case MUTUAL:\r\n        case STOCK:\r\n        case EQUITY:\r\n        case CURRENCY:\r\n            return OfxAccountType.MONEYMRKT;\r\n        default:\r\n            return OfxAccountType.CHECKING;\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.util.RecursiveMoveFiles.copy",
	"Comment": "copy file from one location to another.does not support copying of directories",
	"Method": "boolean copy(File src,File dst){\r\n    FileChannel inChannel = new FileInputStream(src).getChannel();\r\n    FileChannel outChannel = new FileOutputStream(dst).getChannel();\r\n    try {\r\n        long bytesCopied = inChannel.transferTo(0, inChannel.size(), outChannel);\r\n        return bytesCopied >= src.length();\r\n    } finally {\r\n        if (inChannel != null)\r\n            inChannel.close();\r\n        outChannel.close();\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.util.Preconditions.checkNotNull",
	"Comment": "ensures that an object reference passed as a parameter to the calling method is not null.",
	"Method": "T checkNotNull(T reference,T checkNotNull,T reference,Object errorMessage,T checkNotNull,T reference,String errorMessageTemplate,Object errorMessageArgs){\r\n    return com.google.common.base.Preconditions.checkNotNull(reference, errorMessageTemplate, errorMessageArgs);\r\n}"
}, {
	"Path": "org.gnucash.android.model.Money.asBigDecimal",
	"Comment": "returns the amount represented by this money object\tthe scale and rounding mode of the returned value are set to that of this money object",
	"Method": "BigDecimal asBigDecimal(){\r\n    return mAmount.setScale(mCommodity.getSmallestFractionDigits(), RoundingMode.HALF_EVEN);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.onCreateView",
	"Comment": "inflates the dialog view and retrieves references to the dialog elements",
	"Method": "View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){\r\n    View view = inflater.inflate(R.layout.fragment_account_form, container, false);\r\n    ButterKnife.bind(this, view);\r\n    mNameEditText.addTextChangedListener(new TextWatcher() {\r\n        @Override\r\n        public void beforeTextChanged(CharSequence s, int start, int count, int after) {\r\n        }\r\n        @Override\r\n        public void onTextChanged(CharSequence s, int start, int before, int count) {\r\n        }\r\n        @Override\r\n        public void afterTextChanged(Editable s) {\r\n            if (s.toString().length() > 0) {\r\n                mTextInputLayout.setErrorEnabled(false);\r\n            }\r\n        }\r\n    });\r\n    mAccountTypeSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\r\n        @Override\r\n        public void onItemSelected(AdapterView<?> parentView, View selectedItemView, int position, long id) {\r\n            loadParentAccountList(getSelectedAccountType());\r\n            if (mParentAccountUID != null)\r\n                setParentAccountSelection(mAccountsDbAdapter.getID(mParentAccountUID));\r\n        }\r\n        @Override\r\n        public void onNothingSelected(AdapterView<?> adapterView) {\r\n        }\r\n    });\r\n    mParentAccountSpinner.setEnabled(false);\r\n    mParentCheckBox.setOnCheckedChangeListener(new OnCheckedChangeListener() {\r\n        @Override\r\n        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {\r\n            mParentAccountSpinner.setEnabled(isChecked);\r\n        }\r\n    });\r\n    mDefaultTransferAccountSpinner.setEnabled(false);\r\n    mDefaultTransferAccountCheckBox.setOnCheckedChangeListener(new OnCheckedChangeListener() {\r\n        @Override\r\n        public void onCheckedChanged(CompoundButton compoundButton, boolean isChecked) {\r\n            mDefaultTransferAccountSpinner.setEnabled(isChecked);\r\n        }\r\n    });\r\n    mColorSquare.setOnClickListener(new View.OnClickListener() {\r\n        @Override\r\n        public void onClick(View view) {\r\n            showColorPickerDialog();\r\n        }\r\n    });\r\n    return view;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.onCreateView",
	"Comment": "inflates the dialog view and retrieves references to the dialog elements",
	"Method": "View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.onCreateView",
	"Comment": "inflates the dialog view and retrieves references to the dialog elements",
	"Method": "View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.onCreateView",
	"Comment": "inflates the dialog view and retrieves references to the dialog elements",
	"Method": "View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){\r\n    if (s.toString().length() > 0) {\r\n        mTextInputLayout.setErrorEnabled(false);\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.onCreateView",
	"Comment": "inflates the dialog view and retrieves references to the dialog elements",
	"Method": "View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){\r\n    loadParentAccountList(getSelectedAccountType());\r\n    if (mParentAccountUID != null)\r\n        setParentAccountSelection(mAccountsDbAdapter.getID(mParentAccountUID));\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.onCreateView",
	"Comment": "inflates the dialog view and retrieves references to the dialog elements",
	"Method": "View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.onCreateView",
	"Comment": "inflates the dialog view and retrieves references to the dialog elements",
	"Method": "View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){\r\n    mParentAccountSpinner.setEnabled(isChecked);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.onCreateView",
	"Comment": "inflates the dialog view and retrieves references to the dialog elements",
	"Method": "View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){\r\n    mDefaultTransferAccountSpinner.setEnabled(isChecked);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.account.AccountFormFragment.onCreateView",
	"Comment": "inflates the dialog view and retrieves references to the dialog elements",
	"Method": "View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){\r\n    showColorPickerDialog();\r\n}"
}, {
	"Path": "com.google.api.client.util.SslUtils.initSslContext",
	"Comment": "initializes the ssl context to the trust managers supplied by the trust manager factory for thegiven trust store.",
	"Method": "SSLContext initSslContext(SSLContext sslContext,KeyStore trustStore,TrustManagerFactory trustManagerFactory){\r\n    trustManagerFactory.init(trustStore);\r\n    sslContext.init(null, trustManagerFactory.getTrustManagers(), null);\r\n    return sslContext;\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.model.TransactionTest.addingSplitsShouldSetTransactionUID",
	"Comment": "adding a split to a transaction should set the transaction uid of the split to the guid of the transaction",
	"Method": "void addingSplitsShouldSetTransactionUID(){\r\n    Transaction transaction = new Transaction(\"\");\r\n    assertThat(transaction.getCurrencyCode()).isEqualTo(Commodity.DEFAULT_COMMODITY.getCurrencyCode());\r\n    Split split = new Split(Money.getZeroInstance(), \"test-account\");\r\n    assertThat(split.getTransactionUID()).isEmpty();\r\n    transaction.addSplit(split);\r\n    assertThat(split.getTransactionUID()).isEqualTo(transaction.getUID());\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.service.ScheduledActionServiceTest.missedScheduledTransactions_shouldBeGenerated",
	"Comment": "test that normal scheduled transactions would lead to new transaction entries",
	"Method": "void missedScheduledTransactions_shouldBeGenerated(){\r\n    ScheduledAction scheduledAction = new ScheduledAction(ScheduledAction.ActionType.TRANSACTION);\r\n    DateTime startTime = new DateTime(2016, 6, 6, 9, 0);\r\n    scheduledAction.setStartTime(startTime.getMillis());\r\n    DateTime endTime = new DateTime(2016, 9, 12, 8, 0);\r\n    scheduledAction.setEndTime(endTime.getMillis());\r\n    scheduledAction.setActionUID(mActionUID);\r\n    Recurrence recurrence = new Recurrence(PeriodType.WEEK);\r\n    recurrence.setMultiplier(2);\r\n    recurrence.setByDays(Collections.singletonList(Calendar.MONDAY));\r\n    scheduledAction.setRecurrence(recurrence);\r\n    ScheduledActionDbAdapter.getInstance().addRecord(scheduledAction, DatabaseAdapter.UpdateMethod.insert);\r\n    TransactionsDbAdapter transactionsDbAdapter = TransactionsDbAdapter.getInstance();\r\n    assertThat(transactionsDbAdapter.getRecordsCount()).isZero();\r\n    List<ScheduledAction> actions = new ArrayList();\r\n    actions.add(scheduledAction);\r\n    ScheduledActionService.processScheduledActions(actions, mDb);\r\n    assertThat(transactionsDbAdapter.getRecordsCount()).isEqualTo(7);\r\n}"
}, {
	"Path": "ca.uhn.fhir.jpa.demo.FhirServerConfigCommon.loggingInterceptor",
	"Comment": "do some fancy logging to create a nice access log that has details about each incoming request.",
	"Method": "IServerInterceptor loggingInterceptor(){\r\n    LoggingInterceptor retVal = new LoggingInterceptor();\r\n    retVal.setLoggerName(\"fhirtest.access\");\r\n    retVal.setMessageFormat(\"Path[${servletPath}] Source[${requestHeader.x-forwarded-for}] Operation[${operationType} ${operationName} ${idOrResourceName}] UA[${requestHeader.user-agent}] Params[${requestParameters}] ResponseEncoding[${responseEncodingNoDefault}]\");\r\n    retVal.setLogExceptions(true);\r\n    retVal.setErrorMessageFormat(\"ERROR - ${requestVerb} ${requestUrl}\");\r\n    return retVal;\r\n}"
}, {
	"Path": "org.gnucash.android.model.BaseModel.getModifiedTimestamp",
	"Comment": "returns the timestamp when the model record in the database was last modified.",
	"Method": "Timestamp getModifiedTimestamp(){\r\n    return mModifiedTimestamp;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.updateAllAccounts",
	"Comment": "this feature goes through all the rows in the accounts and changes value for columnkey to newvaluethe newvalue parameter is taken as string since sqlite typically stores everything as text.this method affects all rows, exercise caution when using it",
	"Method": "int updateAllAccounts(String columnKey,String newValue){\r\n    ContentValues contentValues = new ContentValues();\r\n    if (newValue == null) {\r\n        contentValues.putNull(columnKey);\r\n    } else {\r\n        contentValues.put(columnKey, newValue);\r\n    }\r\n    return mDb.update(AccountEntry.TABLE_NAME, contentValues, null, null);\r\n}"
}, {
	"Path": "org.gnucash.android.test.unit.model.ScheduledActionTest.multiDayOfWeekWeeklyActions_shouldBeDueOnEachDayOfWeekSet",
	"Comment": "weekly actions scheduled to run on multiple days of the week should be duein each of them in the same week.for an action scheduled on mondays and thursdays, we test that, ifthe last run was on monday, the next should be due on the thursdayof the same week instead of the following week.",
	"Method": "void multiDayOfWeekWeeklyActions_shouldBeDueOnEachDayOfWeekSet(){\r\n    ScheduledAction scheduledAction = new ScheduledAction(ScheduledAction.ActionType.BACKUP);\r\n    Recurrence recurrence = new Recurrence(PeriodType.WEEK);\r\n    recurrence.setByDays(Arrays.asList(Calendar.MONDAY, Calendar.THURSDAY));\r\n    scheduledAction.setRecurrence(recurrence);\r\n    scheduledAction.setStartTime(new DateTime(2016, 6, 6, 9, 0).getMillis());\r\n    scheduledAction.setLastRun(new DateTime(2017, 4, 17, 9, 0).getMillis());\r\n    long expectedNextDueDate = new DateTime(2017, 4, 20, 9, 0).getMillis();\r\n    assertThat(scheduledAction.computeNextTimeBasedScheduledExecutionTime()).isEqualTo(expectedNextDueDate);\r\n}"
}, {
	"Path": "ca.uhn.fhir.jpa.demo.FhirServerConfig.loggingInterceptor",
	"Comment": "do some fancy logging to create a nice access log that has details about each incoming request.",
	"Method": "IServerInterceptor loggingInterceptor(){\r\n    LoggingInterceptor retVal = new LoggingInterceptor();\r\n    retVal.setLoggerName(\"fhirtest.access\");\r\n    retVal.setMessageFormat(\"Path[${servletPath}] Source[${requestHeader.x-forwarded-for}] Operation[${operationType} ${operationName} ${idOrResourceName}] UA[${requestHeader.user-agent}] Params[${requestParameters}] ResponseEncoding[${responseEncodingNoDefault}]\");\r\n    retVal.setLogExceptions(true);\r\n    retVal.setErrorMessageFormat(\"ERROR - ${requestVerb} ${requestUrl}\");\r\n    return retVal;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Money.createZeroInstance",
	"Comment": "creates a new money instance with 0 amount and the currencycode",
	"Method": "Money createZeroInstance(String currencyCode){\r\n    Commodity commodity = Commodity.getInstance(currencyCode);\r\n    return new Money(BigDecimal.ZERO, commodity);\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.media.MediaHttpUploader.executeCurrentRequestWithoutGZip",
	"Comment": "executes the current request with some minimal common code.",
	"Method": "HttpResponse executeCurrentRequestWithoutGZip(HttpRequest request){\r\n    new MethodOverride().intercept(request);\r\n    request.setThrowExceptionOnExecuteError(false);\r\n    HttpResponse response = request.execute();\r\n    return response;\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.services.AbstractGoogleClientRequest.getRequestHeaders",
	"Comment": "returns the http headers used for the google client request.",
	"Method": "HttpHeaders getRequestHeaders(){\r\n    return requestHeaders;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.util.widget.CalculatorEditText.getValue",
	"Comment": "returns the value of the amount in the edit text or null if the field is empty.performs an evaluation of the expression first",
	"Method": "BigDecimal getValue(){\r\n    evaluate();\r\n    try {\r\n        return AmountParser.parse(getText().toString());\r\n    } catch (ParseException e) {\r\n        String msg = \"Error parsing amount string \" + getText() + \" from CalculatorEditText\";\r\n        Log.i(getClass().getSimpleName(), msg, e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.model.Transaction.initDefaults",
	"Comment": "initializes the different fields to their default values.",
	"Method": "void initDefaults(){\r\n    setCommodity(Commodity.DEFAULT_COMMODITY);\r\n    this.mTimestamp = System.currentTimeMillis();\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.notifications.AbstractNotification.setResourceId",
	"Comment": "sets the opaque id for the watched resource that is stable across api versions.overriding is only supported for the purpose of calling the super implementation and changingthe return type, but nothing else.",
	"Method": "AbstractNotification setResourceId(String resourceId){\r\n    this.resourceId = Preconditions.checkNotNull(resourceId);\r\n    return this;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.CommoditiesDbAdapter.getCommodity",
	"Comment": "returns the commodity associated with the iso4217 currency code",
	"Method": "Commodity getCommodity(String currencyCode){\r\n    Cursor cursor = fetchAllRecords(CommodityEntry.COLUMN_MNEMONIC + \"=?\", new String[] { currencyCode }, null);\r\n    Commodity commodity = null;\r\n    if (cursor.moveToNext()) {\r\n        commodity = buildModelInstance(cursor);\r\n    } else {\r\n        String msg = \"Commodity not found in the database: \" + currencyCode;\r\n        Log.e(LOG_TAG, msg);\r\n        Crashlytics.log(msg);\r\n    }\r\n    cursor.close();\r\n    return commodity;\r\n}"
}, {
	"Path": "ca.uhn.fhir.context.FhirContext.getResourceNames",
	"Comment": "returns an unmodifiable set containing all resource names known to this\tcontext",
	"Method": "Set<String> getResourceNames(){\r\n    Set<String> resourceNames = new HashSet();\r\n    if (myNameToResourceDefinition.isEmpty()) {\r\n        Properties props = new Properties();\r\n        try {\r\n            props.load(myVersion.getFhirVersionPropertiesFile());\r\n        } catch (IOException theE) {\r\n            throw new ConfigurationException(\"Failed to load version properties file\");\r\n        }\r\n        Enumeration<?> propNames = props.propertyNames();\r\n        while (propNames.hasMoreElements()) {\r\n            String next = (String) propNames.nextElement();\r\n            if (next.startsWith(\"resource.\")) {\r\n                resourceNames.add(next.substring(\"resource.\".length()).trim());\r\n            }\r\n        }\r\n    }\r\n    for (RuntimeResourceDefinition next : myNameToResourceDefinition.values()) {\r\n        resourceNames.add(next.getName());\r\n    }\r\n    return Collections.unmodifiableSet(resourceNames);\r\n}"
}, {
	"Path": "com.google.api.client.http.HttpHeaders.getFirstHeaderValue",
	"Comment": "returns the first header value based on the given internal list value.",
	"Method": "T getFirstHeaderValue(List<T> internalValue){\r\n    return internalValue == null ? null : internalValue.get(0);\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.AccountsDbAdapter.getAccountName",
	"Comment": "returns the simple name of the account with unique id accountuid.",
	"Method": "String getAccountName(String accountUID){\r\n    return getAttribute(accountUID, AccountEntry.COLUMN_NAME);\r\n}"
}, {
	"Path": "org.gnucash.android.model.Transaction.setSplits",
	"Comment": "sets the splits for this transactionall the splits in the list will have their transaction uid set to this transaction",
	"Method": "void setSplits(List<Split> splitList){\r\n    mSplitList = splitList;\r\n    for (Split split : splitList) {\r\n        split.setTransactionUID(getUID());\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.ui.util.widget.CalculatorKeyboard.showCustomKeyboard",
	"Comment": "make the calculatorkeyboard visible, and hide the system keyboard for view v.",
	"Method": "void showCustomKeyboard(View v){\r\n    if (v != null)\r\n        ((InputMethodManager) mContext.getSystemService(Activity.INPUT_METHOD_SERVICE)).hideSoftInputFromWindow(v.getWindowToken(), 0);\r\n    mKeyboardView.setVisibility(View.VISIBLE);\r\n    mKeyboardView.setEnabled(true);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.TransactionFormFragment.initTransactionNameAutocomplete",
	"Comment": "initializes the transaction name field for autocompletion with existing transaction names in the database",
	"Method": "void initTransactionNameAutocomplete(){\r\n    final int[] to = new int[] { R.id.primary_text };\r\n    final String[] from = new String[] { DatabaseSchema.TransactionEntry.COLUMN_DESCRIPTION };\r\n    SimpleCursorAdapter adapter = new DropDownCursorAdapter(getActivity(), R.layout.dropdown_item_2lines, null, from, to);\r\n    adapter.setCursorToStringConverter(new SimpleCursorAdapter.CursorToStringConverter() {\r\n        @Override\r\n        public CharSequence convertToString(Cursor cursor) {\r\n            final int colIndex = cursor.getColumnIndexOrThrow(DatabaseSchema.TransactionEntry.COLUMN_DESCRIPTION);\r\n            return cursor.getString(colIndex);\r\n        }\r\n    });\r\n    adapter.setFilterQueryProvider(new FilterQueryProvider() {\r\n        @Override\r\n        public Cursor runQuery(CharSequence name) {\r\n            return mTransactionsDbAdapter.fetchTransactionSuggestions(name == null ? \"\" : name.toString(), mAccountUID);\r\n        }\r\n    });\r\n    mDescriptionEditText.setOnItemClickListener(new AdapterView.OnItemClickListener() {\r\n        @Override\r\n        public void onItemClick(AdapterView<?> adapterView, View view, int position, long id) {\r\n            mTransaction = new Transaction(mTransactionsDbAdapter.getRecord(id), true);\r\n            mTransaction.setTime(System.currentTimeMillis());\r\n            boolean amountEntered = mAmountEditText.isInputModified();\r\n            initializeViewsWithTransaction();\r\n            List<Split> splitList = mTransaction.getSplits();\r\n            boolean isSplitPair = splitList.size() == 2 && splitList.get(0).isPairOf(splitList.get(1));\r\n            if (isSplitPair) {\r\n                mSplitsList.clear();\r\n                if (!amountEntered)\r\n                    mAmountEditText.setValue(splitList.get(0).getValue().asBigDecimal());\r\n            } else {\r\n                if (amountEntered) {\r\n                    mSplitsList.clear();\r\n                    setDoubleEntryViewsVisibility(View.VISIBLE);\r\n                } else {\r\n                    if (mUseDoubleEntry) {\r\n                        setDoubleEntryViewsVisibility(View.GONE);\r\n                    }\r\n                }\r\n            }\r\n            mTransaction = null;\r\n        }\r\n    });\r\n    mDescriptionEditText.setAdapter(adapter);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.TransactionFormFragment.initTransactionNameAutocomplete",
	"Comment": "initializes the transaction name field for autocompletion with existing transaction names in the database",
	"Method": "void initTransactionNameAutocomplete(){\r\n    final int colIndex = cursor.getColumnIndexOrThrow(DatabaseSchema.TransactionEntry.COLUMN_DESCRIPTION);\r\n    return cursor.getString(colIndex);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.TransactionFormFragment.initTransactionNameAutocomplete",
	"Comment": "initializes the transaction name field for autocompletion with existing transaction names in the database",
	"Method": "void initTransactionNameAutocomplete(){\r\n    return mTransactionsDbAdapter.fetchTransactionSuggestions(name == null ? \"\" : name.toString(), mAccountUID);\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.TransactionFormFragment.initTransactionNameAutocomplete",
	"Comment": "initializes the transaction name field for autocompletion with existing transaction names in the database",
	"Method": "void initTransactionNameAutocomplete(){\r\n    mTransaction = new Transaction(mTransactionsDbAdapter.getRecord(id), true);\r\n    mTransaction.setTime(System.currentTimeMillis());\r\n    boolean amountEntered = mAmountEditText.isInputModified();\r\n    initializeViewsWithTransaction();\r\n    List<Split> splitList = mTransaction.getSplits();\r\n    boolean isSplitPair = splitList.size() == 2 && splitList.get(0).isPairOf(splitList.get(1));\r\n    if (isSplitPair) {\r\n        mSplitsList.clear();\r\n        if (!amountEntered)\r\n            mAmountEditText.setValue(splitList.get(0).getValue().asBigDecimal());\r\n    } else {\r\n        if (amountEntered) {\r\n            mSplitsList.clear();\r\n            setDoubleEntryViewsVisibility(View.VISIBLE);\r\n        } else {\r\n            if (mUseDoubleEntry) {\r\n                setDoubleEntryViewsVisibility(View.GONE);\r\n            }\r\n        }\r\n    }\r\n    mTransaction = null;\r\n}"
}, {
	"Path": "com.google.api.client.util.IOUtils.deserialize",
	"Comment": "deserializes the given input stream into to a newly allocated object, and close the inputstream.",
	"Method": "S deserialize(byte[] bytes,S deserialize,InputStream inputStream){\r\n    try {\r\n        return (S) new ObjectInputStream(inputStream).readObject();\r\n    } catch (ClassNotFoundException exception) {\r\n        IOException ioe = new IOException(\"Failed to deserialize object\");\r\n        ioe.initCause(exception);\r\n        throw ioe;\r\n    } finally {\r\n        inputStream.close();\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.xml.XmlTest.testParseOfNestedNs",
	"Comment": "the purpose of this test is to map nested elements with a namespace attribute.",
	"Method": "void testParseOfNestedNs(){\r\n    XmlPullParser parser = Xml.createParser();\r\n    parser.setInput(new StringReader(NESTED_NS));\r\n    XmlNamespaceDictionary namespaceDictionary = new XmlNamespaceDictionary();\r\n    GenericXml xml = new GenericXml();\r\n    Xml.parseElement(parser, xml, namespaceDictionary, null);\r\n    XmlSerializer serializer = Xml.createSerializer();\r\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\r\n    serializer.setOutput(out, \"UTF-8\");\r\n    namespaceDictionary.serialize(serializer, \"any\", xml);\r\n    assertEquals(NESTED_NS_SERIALIZED, out.toString());\r\n}"
}, {
	"Path": "ca.uhn.fhir.jpa.demo.FhirServerConfigCommon.getResponseHighlighterInterceptor",
	"Comment": "this interceptor adds some pretty syntax highlighting in responses when a browser is detected",
	"Method": "IServerInterceptor getResponseHighlighterInterceptor(){\r\n    ResponseHighlighterInterceptor retVal = new ResponseHighlighterInterceptor();\r\n    return retVal;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Split.createPair",
	"Comment": "creates a split which is a pair of this instance.a pair split has all the same attributes except that the splittype is inverted and it belongsto another account.",
	"Method": "Split createPair(String accountUID){\r\n    Split pair = new Split(mValue, accountUID);\r\n    pair.setType(mSplitType.invert());\r\n    pair.setMemo(mMemo);\r\n    pair.setTransactionUID(mTransactionUID);\r\n    pair.setQuantity(mQuantity);\r\n    return pair;\r\n}"
}, {
	"Path": "org.gnucash.android.export.ExportAsyncTask.moveToTarget",
	"Comment": "moves the generated export files to the target specified by the user",
	"Method": "void moveToTarget(){\r\n    switch(mExportParams.getExportTarget()) {\r\n        case SHARING:\r\n            shareFiles(mExportedFiles);\r\n            break;\r\n        case DROPBOX:\r\n            moveExportToDropbox();\r\n            break;\r\n        case GOOGLE_DRIVE:\r\n            moveExportToGoogleDrive();\r\n            break;\r\n        case OWNCLOUD:\r\n            moveExportToOwnCloud();\r\n            break;\r\n        case SD_CARD:\r\n            moveExportToSDCard();\r\n            break;\r\n        case URI:\r\n            moveExportToUri();\r\n            break;\r\n        default:\r\n            throw new Exporter.ExporterException(mExportParams, \"Invalid target\");\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.util.Types.newInstance",
	"Comment": "creates a new instance of the given class by invoking its default constructor.the given class must be public and must have a public default constructor, and must not be anarray or an interface or be abstract. if an enclosing class, it must be static.",
	"Method": "T newInstance(Class<T> clazz){\r\n    try {\r\n        return clazz.newInstance();\r\n    } catch (IllegalAccessException e) {\r\n        throw handleExceptionForNewInstance(e, clazz);\r\n    } catch (InstantiationException e) {\r\n        throw handleExceptionForNewInstance(e, clazz);\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.notifications.AbstractNotification.getResourceId",
	"Comment": "returns the opaque id for the watched resource that is stable across api versions.",
	"Method": "String getResourceId(){\r\n    return resourceId;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.budget.BudgetFormFragment.canSave",
	"Comment": "checks that this budget can be savedalso sets the appropriate error messages on the relevant viewsfor a budget to be saved, it needs to have a name, an amount and a schedule",
	"Method": "boolean canSave(){\r\n    if (mEventRecurrence.until != null && mEventRecurrence.until.length() > 0 || mEventRecurrence.count <= 0) {\r\n        Toast.makeText(getActivity(), \"Set a number periods in the recurrence dialog to save the budget\", Toast.LENGTH_SHORT).show();\r\n        return false;\r\n    }\r\n    mBudgetAmounts = extractBudgetAmounts();\r\n    String budgetName = mBudgetNameInput.getText().toString();\r\n    boolean canSave = mRecurrenceRule != null && !budgetName.isEmpty() && !mBudgetAmounts.isEmpty();\r\n    if (!canSave) {\r\n        if (budgetName.isEmpty()) {\r\n            mNameTextInputLayout.setError(\"A name is required\");\r\n            mNameTextInputLayout.setErrorEnabled(true);\r\n        } else {\r\n            mNameTextInputLayout.setErrorEnabled(false);\r\n        }\r\n        if (mBudgetAmounts.isEmpty()) {\r\n            mBudgetAmountInput.setError(\"Enter an amount for the budget\");\r\n            Toast.makeText(getActivity(), \"Add budget amounts in order to save the budget\", Toast.LENGTH_SHORT).show();\r\n        }\r\n        if (mRecurrenceRule == null) {\r\n            Toast.makeText(getActivity(), \"Set a repeat pattern to create a budget!\", Toast.LENGTH_SHORT).show();\r\n        }\r\n    }\r\n    return canSave;\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.shouldAutoNotify",
	"Comment": "check if user will be notified of creation of scheduled transactionsthis flag is currently unused in the app. it is only included here for compatibility with gnucash desktop xml",
	"Method": "boolean shouldAutoNotify(){\r\n    return mAutoNotify;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.getRecordsCount",
	"Comment": "returns the number of transactions in the database which fulfill the conditions",
	"Method": "long getRecordsCount(long getRecordsCount,String where,String[] whereArgs){\r\n    Cursor cursor = mDb.query(true, TransactionEntry.TABLE_NAME + \" , trans_extra_info ON \" + TransactionEntry.TABLE_NAME + \".\" + TransactionEntry.COLUMN_UID + \" = trans_extra_info.trans_acct_t_uid\", new String[] { \"COUNT(*)\" }, where, whereArgs, null, null, null, null);\r\n    try {\r\n        cursor.moveToFirst();\r\n        return cursor.getLong(0);\r\n    } finally {\r\n        cursor.close();\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.SplitsDbAdapter.fetchSplitsForTransactionAndAccount",
	"Comment": "returns a cursor to splits for a given transaction and account",
	"Method": "Cursor fetchSplitsForTransactionAndAccount(String transactionUID,String accountUID){\r\n    if (transactionUID == null || accountUID == null)\r\n        return null;\r\n    Log.v(LOG_TAG, \"Fetching all splits for transaction ID \" + transactionUID + \"and account ID \" + accountUID);\r\n    return mDb.query(SplitEntry.TABLE_NAME, null, SplitEntry.COLUMN_TRANSACTION_UID + \" = ? AND \" + SplitEntry.COLUMN_ACCOUNT_UID + \" = ?\", new String[] { transactionUID, accountUID }, null, null, SplitEntry.COLUMN_VALUE_NUM + \" ASC\");\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.getTag",
	"Comment": "returns the tag of this scheduled actionthe tag saves additional information about the scheduled action,e.g. such as export parameters for scheduled backups",
	"Method": "String getTag(){\r\n    return mTag;\r\n}"
}, {
	"Path": "com.google.api.client.util.SecurityUtils.loadPrivateKeyFromKeyStore",
	"Comment": "retrieves a private key from the specified key store stream and specified key store.",
	"Method": "PrivateKey loadPrivateKeyFromKeyStore(KeyStore keyStore,InputStream keyStream,String storePass,String alias,String keyPass){\r\n    loadKeyStore(keyStore, keyStream, storePass);\r\n    return getPrivateKey(keyStore, alias, keyPass);\r\n}"
}, {
	"Path": "ca.uhn.fhir.rest.server.exceptions.BaseServerResponseException.getResponseMimeType",
	"Comment": "in a restful client, this method will be populated with the http status code that was returned with the http response.\tin a restful server, this method is currently ignored.",
	"Method": "String getResponseMimeType(){\r\n    return myResponseMimeType;\r\n}"
}, {
	"Path": "ca.uhn.fhir.rest.server.exceptions.BaseServerResponseException.setResponseMimeType",
	"Comment": "this method is currently only called internally by hapi, it should not be called by user code.",
	"Method": "void setResponseMimeType(String theResponseMimeType){\r\n    myResponseMimeType = theResponseMimeType;\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.notifications.StoredChannel.store",
	"Comment": "stores this notification channel in the given notification channel data store.it is important that this method be called before the watch http request is made in case thenotification is received before the watch http response is received.",
	"Method": "StoredChannel store(DataStoreFactory dataStoreFactory,StoredChannel store,DataStore<StoredChannel> dataStore){\r\n    lock.lock();\r\n    try {\r\n        dataStore.set(getId(), this);\r\n        return this;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.http.apache.ApacheHttpTransport.shutdown",
	"Comment": "shuts down the connection manager and releases allocated resources. this includes closing allconnections, whether they are currently used or not.",
	"Method": "void shutdown(){\r\n    httpClient.getConnectionManager().shutdown();\r\n}"
}, {
	"Path": "ca.uhn.fhir.rest.server.exceptions.BaseServerResponseException.getStatusCode",
	"Comment": "returns the http status code corresponding to this problem",
	"Method": "int getStatusCode(){\r\n    return myStatusCode;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.transaction.SplitEditorFragment.initArgs",
	"Comment": "extracts arguments passed to the view and initializes necessary adapters and cursors",
	"Method": "void initArgs(){\r\n    mAccountsDbAdapter = AccountsDbAdapter.getInstance();\r\n    Bundle args = getArguments();\r\n    mAccountUID = ((FormActivity) getActivity()).getCurrentAccountUID();\r\n    mBaseAmount = new BigDecimal(args.getString(UxArgument.AMOUNT_STRING));\r\n    String conditions = \"(\" + DatabaseSchema.AccountEntry.COLUMN_HIDDEN + \" = 0 AND \" + DatabaseSchema.AccountEntry.COLUMN_PLACEHOLDER + \" = 0\" + \")\";\r\n    mCursor = mAccountsDbAdapter.fetchAccountsOrderedByFullName(conditions, null);\r\n    mCommodity = CommoditiesDbAdapter.getInstance().getCommodity(mAccountsDbAdapter.getCurrencyCode(mAccountUID));\r\n}"
}, {
	"Path": "org.gnucash.android.export.ExportAsyncTask.shareFiles",
	"Comment": "starts an intent chooser to allow the user to select an activity to receivethe exported files.",
	"Method": "void shareFiles(List<String> paths){\r\n    Intent shareIntent = new Intent(Intent.ACTION_SEND_MULTIPLE);\r\n    shareIntent.setType(\"text/xml\");\r\n    ArrayList<Uri> exportFiles = convertFilePathsToUris(paths);\r\n    shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, exportFiles);\r\n    shareIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\r\n    shareIntent.putExtra(Intent.EXTRA_SUBJECT, mContext.getString(R.string.title_export_email, mExportParams.getExportFormat().name()));\r\n    String defaultEmail = PreferenceManager.getDefaultSharedPreferences(mContext).getString(mContext.getString(R.string.key_default_export_email), null);\r\n    if (defaultEmail != null && defaultEmail.trim().length() > 0)\r\n        shareIntent.putExtra(Intent.EXTRA_EMAIL, new String[] { defaultEmail });\r\n    SimpleDateFormat formatter = (SimpleDateFormat) SimpleDateFormat.getDateTimeInstance();\r\n    String extraText = mContext.getString(R.string.description_export_email) + \" \" + formatter.format(new Date(System.currentTimeMillis()));\r\n    shareIntent.putExtra(Intent.EXTRA_TEXT, extraText);\r\n    if (mContext instanceof Activity) {\r\n        List<ResolveInfo> activities = mContext.getPackageManager().queryIntentActivities(shareIntent, 0);\r\n        if (activities != null && !activities.isEmpty()) {\r\n            mContext.startActivity(Intent.createChooser(shareIntent, mContext.getString(R.string.title_select_export_destination)));\r\n        } else {\r\n            Toast.makeText(mContext, R.string.toast_no_compatible_apps_to_receive_export, Toast.LENGTH_LONG).show();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.gnucash.android.ui.report.barchart.StackedBarChartFragment.getEmptyData",
	"Comment": "returns a data object that represents situation when no user data available",
	"Method": "BarData getEmptyData(){\r\n    List<String> xValues = new ArrayList();\r\n    List<BarEntry> yValues = new ArrayList();\r\n    for (int i = 0; i < NO_DATA_BAR_COUNTS; i++) {\r\n        xValues.add(\"\");\r\n        yValues.add(new BarEntry(i + 1, i));\r\n    }\r\n    BarDataSet set = new BarDataSet(yValues, getResources().getString(R.string.label_chart_no_data));\r\n    set.setDrawValues(false);\r\n    set.setColor(NO_DATA_COLOR);\r\n    return new BarData(xValues, set);\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.media.MediaHttpDownloader.getNumBytesDownloaded",
	"Comment": "gets the total number of bytes downloaded by this downloader.",
	"Method": "long getNumBytesDownloaded(){\r\n    return bytesDownloaded;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Book.getSourceUri",
	"Comment": "return the uri of the xml file from which the book was imported.in api level 16 and above, this is the uri from the storage access framework which willbe used for synchronization of the book",
	"Method": "Uri getSourceUri(){\r\n    return mSourceUri;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Budget.getStartofCurrentPeriod",
	"Comment": "returns the timestamp of the start of current period of the budget",
	"Method": "long getStartofCurrentPeriod(){\r\n    LocalDateTime localDate = new LocalDateTime();\r\n    int interval = mRecurrence.getMultiplier();\r\n    switch(mRecurrence.getPeriodType()) {\r\n        case HOUR:\r\n            localDate = localDate.millisOfDay().withMinimumValue().plusHours(interval);\r\n            break;\r\n        case DAY:\r\n            localDate = localDate.millisOfDay().withMinimumValue().plusDays(interval);\r\n            break;\r\n        case WEEK:\r\n            localDate = localDate.dayOfWeek().withMinimumValue().minusDays(interval);\r\n            break;\r\n        case MONTH:\r\n            localDate = localDate.dayOfMonth().withMinimumValue().minusMonths(interval);\r\n            break;\r\n        case YEAR:\r\n            localDate = localDate.dayOfYear().withMinimumValue().minusYears(interval);\r\n            break;\r\n    }\r\n    return localDate.toDate().getTime();\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.SplitsDbAdapter.getSplitsForTransactionInAccount",
	"Comment": "fetch splits for a given transaction within a specific account",
	"Method": "List<Split> getSplitsForTransactionInAccount(String transactionUID,String accountUID){\r\n    Cursor cursor = fetchSplitsForTransactionAndAccount(transactionUID, accountUID);\r\n    List<Split> splitList = new ArrayList<Split>();\r\n    if (cursor != null) {\r\n        while (cursor.moveToNext()) {\r\n            splitList.add(buildModelInstance(cursor));\r\n        }\r\n        cursor.close();\r\n    }\r\n    return splitList;\r\n}"
}, {
	"Path": "com.google.api.client.json.webtoken.JsonWebToken.getHeader",
	"Comment": "returns the header.overriding is only supported for the purpose of calling the super implementation and changingthe return type, but nothing else.",
	"Method": "Header getHeader(){\r\n    return header;\r\n}"
}, {
	"Path": "org.gnucash.android.model.ScheduledAction.getLastRunTime",
	"Comment": "returns the timestamp of the last execution of this scheduled actionthis is not necessarily the time when the scheduled action was due, only when it was actually last executed.",
	"Method": "long getLastRunTime(){\r\n    return mLastRun;\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.ScheduledActionDbAdapter.getActionInstanceCount",
	"Comment": "returns the number of instances of the action which have been created from this scheduled action",
	"Method": "long getActionInstanceCount(String scheduledActionUID){\r\n    String sql = \"SELECT COUNT(*) FROM \" + DatabaseSchema.TransactionEntry.TABLE_NAME + \" WHERE \" + DatabaseSchema.TransactionEntry.COLUMN_SCHEDX_ACTION_UID + \"=?\";\r\n    SQLiteStatement statement = mDb.compileStatement(sql);\r\n    statement.bindString(1, scheduledActionUID);\r\n    return statement.simpleQueryForLong();\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.moveTransaction",
	"Comment": "assigns transaction with id rowid to account with id accountid",
	"Method": "int moveTransaction(String transactionUID,String srcAccountUID,String dstAccountUID){\r\n    Log.i(LOG_TAG, \"Moving transaction ID \" + transactionUID + \" splits from \" + srcAccountUID + \" to account \" + dstAccountUID);\r\n    List<Split> splits = mSplitsDbAdapter.getSplitsForTransactionInAccount(transactionUID, srcAccountUID);\r\n    for (Split split : splits) {\r\n        split.setAccountUID(dstAccountUID);\r\n    }\r\n    mSplitsDbAdapter.bulkAddRecords(splits, UpdateMethod.update);\r\n    return splits.size();\r\n}"
}, {
	"Path": "org.gnucash.android.db.adapter.TransactionsDbAdapter.getTemplateTransactionsCount",
	"Comment": "returns the number of template transactions in the database",
	"Method": "long getTemplateTransactionsCount(){\r\n    String sql = \"SELECT COUNT(*) FROM \" + TransactionEntry.TABLE_NAME + \" WHERE \" + TransactionEntry.COLUMN_TEMPLATE + \"=1\";\r\n    SQLiteStatement statement = mDb.compileStatement(sql);\r\n    return statement.simpleQueryForLong();\r\n}"
}, {
	"Path": "com.google.api.client.http.ExponentialBackOffPolicy.reset",
	"Comment": "sets the interval back to the initial retry interval and restarts the timer.",
	"Method": "void reset(){\r\n    exponentialBackOff.reset();\r\n}"
}, {
	"Path": "com.google.api.client.util.ArrayMap.put",
	"Comment": "sets the value for the given key, overriding any existing value.",
	"Method": "V put(K key,V value){\r\n    int index = getIndexOfKey(key);\r\n    if (index == -1) {\r\n        index = this.size;\r\n    }\r\n    return set(index, key, value);\r\n}"
}, {
	"Path": "com.google.api.client.http.ExponentialBackOffPolicy.isBackOffRequired",
	"Comment": "determines if back off is required based on the specified status code.the idea is that the servers are only temporarily unavailable, and they should not beoverwhelmed when they are trying to get back up.the default implementation requires back off for 500 and 503 status codes. subclasses mayoverride if different status codes are required.",
	"Method": "boolean isBackOffRequired(int statusCode){\r\n    switch(statusCode) {\r\n        case HttpStatusCodes.STATUS_CODE_SERVER_ERROR:\r\n        case HttpStatusCodes.STATUS_CODE_SERVICE_UNAVAILABLE:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.googleapis.auth.oauth2.GoogleClientSecrets.getDetails",
	"Comment": "returns the details for either installed or web applications.",
	"Method": "Details getDetails(){\r\n    Preconditions.checkArgument((web == null) != (installed == null));\r\n    return web == null ? installed : web;\r\n}"
}, {
	"Path": "org.gnucash.android.model.Book.setSourceUri",
	"Comment": "set the uri of the xml source for the bookthis uri will be used for sync where applicable",
	"Method": "void setSourceUri(Uri uri){\r\n    this.mSourceUri = uri;\r\n}"
}, {
	"Path": "org.gnucash.android.ui.settings.dialog.DoubleConfirmationDialog.onNegativeButton",
	"Comment": "called when the negative button is pressed.by default it just dismisses the dialog.",
	"Method": "void onNegativeButton(){\r\n    getDialog().dismiss();\r\n}"
}, {
	"Path": "ca.uhn.fhir.context.FhirContext.getParserOptions",
	"Comment": "returns the parser options object which will be used to supply default\toptions to newly created parsers",
	"Method": "ParserOptions getParserOptions(){\r\n    return myParserOptions;\r\n}"
}]