[{
	"Path": "com.impetus.client.cassandra.index.InvertedIndexHandlerBase.searchAndAddToResults",
	"Comment": "searches into inverted index based on expression and addssearch result to searchresults",
	"Method": "void searchAndAddToResults(EntityMetadata m,String persistenceUnit,ConsistencyLevel consistencyLevel,String columnFamilyName,List<SearchResult> searchResults,IndexExpression expression,boolean isRowKeyQuery){\r\n    SearchResult searchResult = new SearchResult();\r\n    byte[] superColumnName = expression.getValue();\r\n    String superColumnNameStr = null;\r\n    String rowKey = null;\r\n    try {\r\n        rowKey = ByteBufferUtil.string(ByteBuffer.wrap(expression.getColumn_name()), Charset.forName(Constants.CHARSET_UTF8));\r\n        superColumnNameStr = new String(expression.getValue(), Charset.forName(Constants.CHARSET_UTF8));\r\n    } catch (CharacterCodingException e) {\r\n        log.error(\"Error while retrieving records {}, Caused by:\", e);\r\n        throw new PersistenceException(e);\r\n    }\r\n    Object pk = PropertyAccessorHelper.getObject(m.getIdAttribute().getJavaType(), superColumnName);\r\n    IndexOperator condition = expression.getOp();\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"RowKey: {} ; Super column Name: {} on condition.\", rowKey, superColumnNameStr, condition);\r\n    }\r\n    if (isRowKeyQuery && (rowKey.equals(m.getIdAttribute().getName()) || rowKey.equals(((DefaultSingularAttribute) m.getIdAttribute()).getJPAColumnName()))) {\r\n        if (searchResults.isEmpty()) {\r\n            searchResult.setPrimaryKey(pk);\r\n            searchResults.add(searchResult);\r\n        } else {\r\n            SearchResult existing = searchResults.get(0);\r\n            if (existing.getPrimaryKey() != null && existing.getPrimaryKey().equals(superColumnNameStr)) {\r\n                searchResults.add(searchResult);\r\n            } else {\r\n                searchResults.remove(0);\r\n            }\r\n        }\r\n    } else {\r\n        List<SuperColumn> thriftSuperColumns = new ArrayList<SuperColumn>();\r\n        switch(condition) {\r\n            case EQ:\r\n                SuperColumn thriftSuperColumn = getSuperColumnForRow(consistencyLevel, columnFamilyName, rowKey, superColumnName, persistenceUnit);\r\n                if (thriftSuperColumn != null)\r\n                    thriftSuperColumns.add(thriftSuperColumn);\r\n                break;\r\n            case GT:\r\n                searchSuperColumnsInRange(columnFamilyName, consistencyLevel, persistenceUnit, rowKey, superColumnName, thriftSuperColumns, superColumnName, new byte[0]);\r\n                break;\r\n            case LT:\r\n                searchSuperColumnsInRange(columnFamilyName, consistencyLevel, persistenceUnit, rowKey, superColumnName, thriftSuperColumns, new byte[0], superColumnName);\r\n                break;\r\n            case GTE:\r\n                searchSuperColumnsInRange(columnFamilyName, consistencyLevel, persistenceUnit, rowKey, superColumnName, thriftSuperColumns, superColumnName, new byte[0]);\r\n                break;\r\n            case LTE:\r\n                searchSuperColumnsInRange(columnFamilyName, consistencyLevel, persistenceUnit, rowKey, superColumnName, thriftSuperColumns, new byte[0], superColumnName);\r\n                break;\r\n            default:\r\n                throw new QueryHandlerException(condition + \" comparison operator not supported currently for Cassandra Inverted Index.\");\r\n        }\r\n        for (SuperColumn thriftSuperColumn : thriftSuperColumns) {\r\n            for (Column column : thriftSuperColumn.getColumns()) {\r\n                byte[] columnName = column.getName();\r\n                searchResult.setPrimaryKey(PropertyAccessorHelper.getObject(m.getIdAttribute().getJavaType(), columnName));\r\n                byte[] columnValue = column.getValue();\r\n                String ecValue = UTF8Type.instance.compose(ByteBuffer.wrap(columnValue));\r\n                if (ecValue != null && !\"\".equals(ecValue.trim())) {\r\n                    searchResult.setEmbeddedColumnName(rowKey.substring(0, rowKey.indexOf(Constants.INDEX_TABLE_ROW_KEY_DELIMITER)));\r\n                    searchResult.addEmbeddedColumnValue(ecValue);\r\n                }\r\n            }\r\n            if (searchResults.isEmpty()) {\r\n                searchResults.add(searchResult);\r\n            } else {\r\n                SearchResult existing = searchResults.get(0);\r\n                if (existing.getPrimaryKey() != null && existing.getPrimaryKey().equals(searchResult.getPrimaryKey())) {\r\n                    searchResults.add(searchResult);\r\n                } else {\r\n                    searchResults.remove(0);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.json.JSONArray.length",
	"Comment": "get the number of elements in the jsonarray, included nulls.",
	"Method": "int length(){\r\n    return this.myArrayList.size();\r\n}"
}, {
	"Path": "org.lenskit.util.keys.Long2DoubleSortedArrayMap.subMap",
	"Comment": "return a subset of this map containing only the keys that appear in another set.",
	"Method": "Long2DoubleSortedArrayMap subMap(long from,long to,Long2DoubleSortedArrayMap subMap,LongSet toKeep){\r\n    if (toKeep == keySet()) {\r\n        return this;\r\n    }\r\n    if (toKeep instanceof LongSortedArraySet) {\r\n        return fastSubMap((LongSortedArraySet) toKeep);\r\n    } else {\r\n        return slowSubMap(toKeep);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.latke.plugin.PluginManager.load",
	"Comment": "loads a plugin by the specified plugin directory and put it into the specified holder.",
	"Method": "void load(AbstractPlugin load,String pluginDirPath,Map<String, HashSet<AbstractPlugin>> holder){\r\n    final Properties props = new Properties();\r\n    final ServletContext servletContext = AbstractServletListener.getServletContext();\r\n    String plugin = StringUtils.substringAfter(pluginDirPath, \"/plugins\");\r\n    plugin = plugin.replace(\"/\", \"\");\r\n    final File file = Latkes.getWebFile(\"/plugins/\" + plugin + \"/plugin.properties\");\r\n    props.load(new FileInputStream(file));\r\n    final URL defaultClassesFileDirURL = servletContext.getResource(\"/plugins/\" + plugin + \"classes\");\r\n    URL classesFileDirURL = null;\r\n    try {\r\n        classesFileDirURL = servletContext.getResource(props.getProperty(\"classesDirPath\"));\r\n    } catch (final MalformedURLException e) {\r\n        LOGGER.log(Level.ERROR, \"Reads [\" + props.getProperty(\"classesDirPath\") + \"] failed\", e);\r\n    }\r\n    final URLClassLoader classLoader = new URLClassLoader(new URL[] { defaultClassesFileDirURL, classesFileDirURL }, PluginManager.class.getClassLoader());\r\n    classLoaders.add(classLoader);\r\n    String pluginClassName = props.getProperty(Plugin.PLUGIN_CLASS);\r\n    if (StringUtils.isBlank(pluginClassName)) {\r\n        pluginClassName = NotInteractivePlugin.class.getName();\r\n    }\r\n    final String rendererId = props.getProperty(Plugin.PLUGIN_RENDERER_ID);\r\n    if (StringUtils.isBlank(rendererId)) {\r\n        LOGGER.log(Level.WARN, \"no renderer defined by this plugin[\" + plugin + \"]ï¼Œthis plugin will be ignore!\");\r\n        return null;\r\n    }\r\n    final Class<?> pluginClass = classLoader.loadClass(pluginClassName);\r\n    LOGGER.log(Level.TRACE, \"Loading plugin class[name={0}]\", pluginClassName);\r\n    final AbstractPlugin ret = (AbstractPlugin) pluginClass.newInstance();\r\n    ret.setRendererId(rendererId);\r\n    setPluginProps(plugin, ret, props);\r\n    registerEventListeners(props, classLoader, ret);\r\n    register(ret, holder);\r\n    ret.changeStatus();\r\n    return ret;\r\n}"
}, {
	"Path": "com.impetus.kundera.metadata.processor.TableProcessor.addRelationIntoMetadata",
	"Comment": "adds relationship info into metadata for a given fieldrelationfield.",
	"Method": "void addRelationIntoMetadata(Class<?> entityClass,Field relationField,EntityMetadata metadata){\r\n    RelationMetadataProcessor relProcessor = null;\r\n    try {\r\n        relProcessor = RelationMetadataProcessorFactory.getRelationMetadataProcessor(relationField, kunderaMetadata);\r\n        this.factory.validate(relationField, new RelationAttributeRule());\r\n        relProcessor = RelationMetadataProcessorFactory.getRelationMetadataProcessor(relationField, kunderaMetadata);\r\n        if (relProcessor != null) {\r\n            relProcessor.addRelationIntoMetadata(relationField, metadata);\r\n        }\r\n    } catch (PersistenceException pe) {\r\n        throw new MetamodelLoaderException(\"Error with relationship in @Entity(\" + entityClass + \".\" + relationField.getName() + \"), reason: \" + pe);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.latke.util.Paginator.paginate",
	"Comment": "paginates with the specified current page number, page size, page count and window size.",
	"Method": "List<Integer> paginate(int currentPageNum,int pageSize,int pageCount,int windowSize){\r\n    List<Integer> ret;\r\n    if (pageCount < windowSize) {\r\n        ret = new ArrayList(pageCount);\r\n        for (int i = 0; i < pageCount; i++) {\r\n            ret.add(i, i + 1);\r\n        }\r\n    } else {\r\n        ret = new ArrayList(windowSize);\r\n        int first = currentPageNum + 1 - windowSize / 2;\r\n        first = first < 1 ? 1 : first;\r\n        first = first + windowSize > pageCount ? pageCount - windowSize + 1 : first;\r\n        for (int i = 0; i < windowSize; i++) {\r\n            ret.add(i, first + i);\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.fishercoder.solutions._417.pacificAtlantic",
	"Comment": "one typical trick to work on 2d grid problems is to go through the border and put proper ones into a queue if using bfs.",
	"Method": "List<int[]> pacificAtlantic(int[][] matrix){\r\n    List<int[]> result = new ArrayList();\r\n    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\r\n        return result;\r\n    }\r\n    int m = matrix.length;\r\n    int n = matrix[0].length;\r\n    boolean[][] pacific = new boolean[m][n];\r\n    boolean[][] atlantic = new boolean[m][n];\r\n    for (int i = 0; i < m; i++) {\r\n        dfs(matrix, pacific, Integer.MIN_VALUE, i, 0);\r\n        dfs(matrix, atlantic, Integer.MIN_VALUE, i, n - 1);\r\n    }\r\n    for (int i = 0; i < n; i++) {\r\n        dfs(matrix, pacific, Integer.MIN_VALUE, 0, i);\r\n        dfs(matrix, atlantic, Integer.MIN_VALUE, m - 1, i);\r\n    }\r\n    for (int i = 0; i < m; i++) {\r\n        for (int j = 0; j < n; j++) {\r\n            if (pacific[i][j] && atlantic[i][j]) {\r\n                result.add(new int[] { i, j });\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.google.android.apps.muzei.render.GLTextureView.getRenderMode",
	"Comment": "get the current rendering mode. may be calledfrom any thread. must not be called before a renderer has been set.",
	"Method": "int getRenderMode(int getRenderMode){\r\n    return mGLThread.getRenderMode();\r\n}"
}, {
	"Path": "com.impetus.kundera.utils.DeepEquals.compareOrdered",
	"Comment": "compare two collections that must be same length and in same order.",
	"Method": "boolean compareOrdered(DualKey dualKey,LinkedList<DualKey> stack,Collection visited){\r\n    Collection col1 = (Collection) dualKey._key1;\r\n    Collection col2 = (Collection) dualKey._key2;\r\n    if (ProxyHelper.isProxyCollection(col1) || ProxyHelper.isProxyCollection(col2)) {\r\n        return false;\r\n    }\r\n    if (col1.size() != col2.size()) {\r\n        return false;\r\n    }\r\n    Iterator i1 = col1.iterator();\r\n    Iterator i2 = col2.iterator();\r\n    while (i1.hasNext()) {\r\n        DualKey dk = new DualKey(i1.next(), i2.next());\r\n        if (!visited.contains(dk)) {\r\n            stack.addFirst(dk);\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.b3log.latke.servlet.RequestContext.param",
	"Comment": "gets a parameter specified by the given name from request body form or query string.",
	"Method": "String param(String name){\r\n    return request.getParameter(name);\r\n}"
}, {
	"Path": "org.json.XML.stringToValue",
	"Comment": "the one in jsonobject. changes made here should be reflected there.",
	"Method": "Object stringToValue(String string){\r\n    if (string.equals(\"\")) {\r\n        return string;\r\n    }\r\n    if (string.equalsIgnoreCase(\"true\")) {\r\n        return Boolean.TRUE;\r\n    }\r\n    if (string.equalsIgnoreCase(\"false\")) {\r\n        return Boolean.FALSE;\r\n    }\r\n    if (string.equalsIgnoreCase(\"null\")) {\r\n        return JSONObject.NULL;\r\n    }\r\n    char initial = string.charAt(0);\r\n    if ((initial >= '0' && initial <= '9') || initial == '-') {\r\n        try {\r\n            if (string.indexOf('.') > -1 || string.indexOf('e') > -1 || string.indexOf('E') > -1 || \"-0\".equals(string)) {\r\n                Double d = Double.valueOf(string);\r\n                if (!d.isInfinite() && !d.isNaN()) {\r\n                    return d;\r\n                }\r\n            } else {\r\n                Long myLong = Long.valueOf(string);\r\n                if (string.equals(myLong.toString())) {\r\n                    if (myLong.longValue() == myLong.intValue()) {\r\n                        return Integer.valueOf(myLong.intValue());\r\n                    }\r\n                    return myLong;\r\n                }\r\n            }\r\n        } catch (Exception ignore) {\r\n        }\r\n    }\r\n    return string;\r\n}"
}, {
	"Path": "org.lenskit.util.collections.TopNLong2DoubleAccumulator.findInitialSize",
	"Comment": "find a good initial size to minimize the overhead when up to n items are added to alist.",
	"Method": "int findInitialSize(int maxSize){\r\n    int best = 10;\r\n    int overhead = maxSize;\r\n    for (int i = 10; i <= 25; i++) {\r\n        int cap = i;\r\n        while (cap < maxSize) {\r\n            cap *= 2;\r\n        }\r\n        int ovh = maxSize - cap;\r\n        if (ovh < overhead) {\r\n            overhead = ovh;\r\n            best = i;\r\n        }\r\n    }\r\n    return best;\r\n}"
}, {
	"Path": "org.jupiter.serialization.proto.io.NioBufInput.readEnum",
	"Comment": "read an enum field value from the internal buffer. caller is responsible for converting the numeric value to anactual enum.",
	"Method": "int readEnum(){\r\n    checkIfPackedField();\r\n    return readRawVarInt32();\r\n}"
}, {
	"Path": "com.cuieney.progress.musicplayer.RemoteSource.fetchJSONFromUrl",
	"Comment": "download a json file from a server, parse the content and return the jsonobject.",
	"Method": "JSONObject fetchJSONFromUrl(String urlString){\r\n    BufferedReader reader = null;\r\n    try {\r\n        URLConnection urlConnection = new URL(urlString).openConnection();\r\n        reader = new BufferedReader(new InputStreamReader(urlConnection.getInputStream(), \"iso-8859-1\"));\r\n        StringBuilder sb = new StringBuilder();\r\n        String line;\r\n        while ((line = reader.readLine()) != null) {\r\n            sb.append(line);\r\n        }\r\n        return new JSONObject(sb.toString());\r\n    } catch (JSONException e) {\r\n        throw e;\r\n    } catch (Exception e) {\r\n        return null;\r\n    } finally {\r\n        if (reader != null) {\r\n            try {\r\n                reader.close();\r\n            } catch (IOException e) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.loader.PersistenceXMLLoader.validateDocumentAgainstSchema",
	"Comment": "validates an xml object graph against its schema. therefore it reads theversion from the root tag and tries to load the related xsd file from theclasspath.",
	"Method": "void validateDocumentAgainstSchema(Document xmlRootNode){\r\n    final Element rootElement = xmlRootNode.getDocumentElement();\r\n    final String version = rootElement.getAttribute(\"version\");\r\n    String schemaFileName = \"persistence_\" + version.replace(\".\", \"_\") + \".xsd\";\r\n    try {\r\n        final List validationErrors = new ArrayList();\r\n        final String schemaLanguage = XMLConstants.W3C_XML_SCHEMA_NS_URI;\r\n        final StreamSource streamSource = new StreamSource(getStreamFromClasspath(schemaFileName));\r\n        final Schema schemaDefinition = SchemaFactory.newInstance(schemaLanguage).newSchema(streamSource);\r\n        final Validator schemaValidator = schemaDefinition.newValidator();\r\n        schemaValidator.setErrorHandler(new ErrorLogger(\"XML InputStream\", validationErrors));\r\n        schemaValidator.validate(new DOMSource(xmlRootNode));\r\n        if (!validationErrors.isEmpty()) {\r\n            final String exceptionText = \"persistence.xml is not conform against the supported schema definitions.\";\r\n            throw new InvalidConfigurationException(exceptionText);\r\n        }\r\n    } catch (SAXException e) {\r\n        final String exceptionText = \"Error validating persistence.xml against schema defintion, caused by: \";\r\n        throw new InvalidConfigurationException(exceptionText, e);\r\n    } catch (IOException e) {\r\n        final String exceptionText = \"Error opening xsd schema file. The given persistence.xml descriptor version \" + version + \" might not be supported yet.\";\r\n        throw new InvalidConfigurationException(exceptionText, e);\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.resources.JPAQueryResource.executeDeleteJPAQuery",
	"Comment": "handler for delete method requests for this resource retrieves records from datasource for a given update jpaquery",
	"Method": "Response executeDeleteJPAQuery(HttpHeaders headers,UriInfo info,String parameters){\r\n    String jpaQuery = info.getPathParameters().getFirst(\"jpaQuery\");\r\n    String params = info.getRequestUri().getQuery();\r\n    String sessionToken = headers.getRequestHeader(Constants.SESSION_TOKEN_HEADER_NAME).get(0);\r\n    sessionToken = sessionToken.replaceAll(\"^\\\"|\\\"$\", \"\");\r\n    String mediaType = headers != null && headers.getRequestHeaders().containsKey(\"Content-type\") ? headers.getRequestHeader(\"Content-type\").get(0) : MediaType.APPLICATION_JSON;\r\n    mediaType = mediaType.equalsIgnoreCase(MediaType.APPLICATION_XML) ? MediaType.APPLICATION_XML : MediaType.APPLICATION_JSON;\r\n    if (log.isDebugEnabled())\r\n        log.debug(\"GET: sessionToken:\" + sessionToken + \", jpaQuery:\" + jpaQuery + \", Media Type:\" + mediaType);\r\n    if (!EntityUtils.isValidQuery(jpaQuery, HttpMethod.DELETE)) {\r\n        log.error(\"Incorrect HTTP method POST for query:\" + jpaQuery);\r\n        return Response.noContent().build();\r\n    }\r\n    int result = executeWrite(jpaQuery, params, sessionToken, parameters, mediaType);\r\n    if (log.isDebugEnabled())\r\n        log.debug(\"GET: Result for JPA Query: \" + result);\r\n    if (result < 0) {\r\n        return Response.noContent().build();\r\n    }\r\n    return Response.ok(result, mediaType).build();\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.AbstractEntityReader.handleAssociation",
	"Comment": "recursively fetches associated entities for a given entity",
	"Method": "Object handleAssociation(Object entity,Map<String, Object> relationsMap,EntityMetadata m,PersistenceDelegator pd,boolean lazilyloaded,Map<Object, Object> relationStack){\r\n    for (Relation relation : m.getRelations()) {\r\n        if (relation != null) {\r\n            ForeignKey relationType = relation.getType();\r\n            Object relationalObject = PropertyAccessorHelper.getObject(entity, relation.getProperty());\r\n            if (KunderaCoreUtils.isEmptyOrNull(relationalObject) || ProxyHelper.isProxyOrCollection(relationalObject)) {\r\n                onRelation(entity, relationsMap, m, pd, relation, relationType, lazilyloaded, relationStack);\r\n            } else if (!ProxyHelper.isProxyOrCollection(relationalObject) && Map.class.isAssignableFrom(relationalObject.getClass())) {\r\n                Map relationalMap = (Map) relationalObject;\r\n                for (Map.Entry entry : (Set<Map.Entry>) relationalMap.entrySet()) {\r\n                    Object entityObject = entry.getValue();\r\n                    if (entityObject != null) {\r\n                        EntityMetadata metadata = KunderaMetadataManager.getEntityMetadata(kunderaMetadata, entityObject.getClass());\r\n                        PersistenceCacheManager.addEntityToPersistenceCache(entityObject, pd, PropertyAccessorHelper.getId(entityObject, metadata));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return entity;\r\n}"
}, {
	"Path": "com.impetus.kundera.configure.SchemaConfiguration.getSchemaProperty",
	"Comment": "getkunderaproperty method return auto schema generation property for givepersistence unit.",
	"Method": "String getSchemaProperty(String persistenceUnit,Map<String, Object> externalProperties){\r\n    PersistenceUnitMetadata persistenceUnitMetadata = kunderaMetadata.getApplicationMetadata().getPersistenceUnitMetadata(persistenceUnit);\r\n    String autoDdlOption = externalProperties != null ? (String) externalProperties.get(PersistenceProperties.KUNDERA_DDL_AUTO_PREPARE) : null;\r\n    if (autoDdlOption == null) {\r\n        autoDdlOption = persistenceUnitMetadata != null ? persistenceUnitMetadata.getProperty(PersistenceProperties.KUNDERA_DDL_AUTO_PREPARE) : null;\r\n    }\r\n    return autoDdlOption;\r\n}"
}, {
	"Path": "org.json.JSONWriter.endObject",
	"Comment": "end an object. this method most be called to balance calls toobject.",
	"Method": "JSONWriter endObject(){\r\n    return this.end('k', '}');\r\n}"
}, {
	"Path": "org.lenskit.data.entities.EntityDefaults.getCommonAttributes",
	"Comment": "get the set of attributes that can typically be associated with this entity type.",
	"Method": "Set<TypedName<?>> getCommonAttributes(){\r\n    return ImmutableSet.copyOf(attributes.values());\r\n}"
}, {
	"Path": "com.impetus.kundera.configure.schema.IndexInfo.equals",
	"Comment": "equals method compare two object of columninfo on the basis of theirname.",
	"Method": "boolean equals(Object columnName){\r\n    return columnName != null ? this.columnName.equals(columnName.toString()) : false;\r\n}"
}, {
	"Path": "com.asha.vrlib.MD360Program.build",
	"Comment": "build the program1. create a program handle2. compileshader3. link program4. get attribute handle && uniform handle",
	"Method": "void build(Context context){\r\n    final String vertexShader = getVertexShader(context);\r\n    final String fragmentShader = getFragmentShader(context);\r\n    final int vertexShaderHandle = compileShader(GLES20.GL_VERTEX_SHADER, vertexShader);\r\n    final int fragmentShaderHandle = compileShader(GLES20.GL_FRAGMENT_SHADER, fragmentShader);\r\n    mProgramHandle = createAndLinkProgram(vertexShaderHandle, fragmentShaderHandle, new String[] { \"a_Position\", \"a_TexCoordinate\" });\r\n    mMVPMatrixHandle = GLES20.glGetUniformLocation(mProgramHandle, \"u_MVPMatrix\");\r\n    mMVMatrixHandle = GLES20.glGetUniformLocation(mProgramHandle, \"u_MVMatrix\");\r\n    mTextureUniformHandle = GLES20.glGetUniformLocation(mProgramHandle, \"u_Texture\");\r\n    mPositionHandle = GLES20.glGetAttribLocation(mProgramHandle, \"a_Position\");\r\n    mTextureCoordinateHandle = GLES20.glGetAttribLocation(mProgramHandle, \"a_TexCoordinate\");\r\n    mSTMatrixHandle = GLES20.glGetUniformLocation(mProgramHandle, \"u_STMatrix\");\r\n    mUseTextureTransformHandle = GLES20.glGetUniformLocation(mProgramHandle, \"u_UseSTM\");\r\n}"
}, {
	"Path": "org.json.JSONArray.optString",
	"Comment": "get the optional string associated with an index. the defaultvalue isreturned if the key is not found.",
	"Method": "String optString(int index,String optString,int index,String defaultValue){\r\n    Object object = this.opt(index);\r\n    return JSONObject.NULL.equals(object) ? defaultValue : object.toString();\r\n}"
}, {
	"Path": "org.lenskit.data.entities.EntityDefaults.getDefaultColumns",
	"Comment": "get the default columns for an entity type.these are used as defaults when reading entitiesof this type from a columnar storage format.",
	"Method": "List<TypedName<?>> getDefaultColumns(){\r\n    return defaultColumns;\r\n}"
}, {
	"Path": "com.impetus.kundera.metadata.model.ApplicationMetadata.addQueryToCollection",
	"Comment": "adds parameterised query with given name into collection. throwsexception if duplicate name is provided.",
	"Method": "void addQueryToCollection(String queryName,String query,boolean isNativeQuery,Class clazz){\r\n    if (namedNativeQueries == null) {\r\n        namedNativeQueries = new ConcurrentHashMap<String, QueryWrapper>();\r\n    }\r\n    if (!namedNativeQueries.containsKey(queryName)) {\r\n        namedNativeQueries.put(queryName, new QueryWrapper(queryName, query, isNativeQuery, clazz));\r\n    } else if (queryName != null && !getQuery(queryName).equals(query)) {\r\n        logger.error(\"Duplicate named/native query with name:\" + queryName + \"found! Already there is a query with same name:\" + namedNativeQueries.get(queryName));\r\n        throw new ApplicationLoaderException(\"Duplicate named/native query with name:\" + queryName + \"found! Already there is a query with same name:\" + namedNativeQueries.get(queryName));\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.resources.SessionResource.flush",
	"Comment": "handler for get method requests for this resource generates session token\tand returns, creates and puts em into repository",
	"Method": "Response flush(String sessionToken,HttpHeaders headers){\r\n    if (log.isDebugEnabled())\r\n        log.debug(\"PUT: Session Token:\" + sessionToken);\r\n    String mediaType = headers != null && headers.getRequestHeaders().containsKey(\"Content-type\") ? headers.getRequestHeader(\"Content-type\").get(0) : MediaType.APPLICATION_JSON;\r\n    mediaType = mediaType.equalsIgnoreCase(MediaType.APPLICATION_XML) ? MediaType.APPLICATION_XML : MediaType.APPLICATION_JSON;\r\n    EntityManager em = EMRepository.INSTANCE.getEM(sessionToken);\r\n    if (em == null) {\r\n        if (log.isDebugEnabled())\r\n            log.warn(\"PUT: Session Token:\" + sessionToken + \" doesn't exist and hence can't be deleted\");\r\n        return Response.serverError().build();\r\n    }\r\n    try {\r\n        em.flush();\r\n    } catch (Exception e) {\r\n        log.error(\"PUT: Failed: \" + e.getMessage());\r\n        Response.serverError().build();\r\n    }\r\n    return Response.ok(new String(ResponseCode.PUT_ST_SUCCESS), mediaType).build();\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.schemamanager.CassandraSchemaManager.addColumnToTable",
	"Comment": "adds column to table if not exists previously i.e. alter table.",
	"Method": "void addColumnToTable(TableInfo tableInfo,ColumnInfo column){\r\n    CQLTranslator translator = new CQLTranslator();\r\n    StringBuilder addColumnQuery = new StringBuilder(\"ALTER TABLE \");\r\n    translator.ensureCase(addColumnQuery, tableInfo.getTableName(), false);\r\n    addColumnQuery.append(\" ADD \");\r\n    translator.ensureCase(addColumnQuery, column.getColumnName(), false);\r\n    addColumnQuery.append(\" \" + translator.getCQLType(CassandraValidationClassMapper.getValidationClass(column.getType(), isCql3Enabled(tableInfo))));\r\n    try {\r\n        KunderaCoreUtils.printQuery(addColumnQuery.toString(), showQuery);\r\n        cassandra_client.execute_cql3_query(ByteBuffer.wrap(addColumnQuery.toString().getBytes()), Compression.NONE, ConsistencyLevel.ONE);\r\n    } catch (InvalidRequestException ireforAddColumn) {\r\n        StringBuilder ireforAddColumnbBuilder = new StringBuilder(\"Invalid column name \");\r\n        ireforAddColumnbBuilder.append(column.getColumnName() + \" because it conflicts with an existing column\");\r\n        if (ireforAddColumn.getWhy() != null && ireforAddColumn.getWhy().equals(ireforAddColumnbBuilder.toString())) {\r\n        } else {\r\n            log.error(\"Error occurred while altering column type of  table {}, Caused by: .\", tableInfo.getTableName(), ireforAddColumn);\r\n            throw new SchemaGenerationException(\"Error occurred while adding column into table \" + tableInfo.getTableName(), ireforAddColumn, \"Cassandra\", databaseName);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.validation.rules.AttributeConstraintRule.validateMinValue",
	"Comment": "checks whether a given value is greater than given min value or not",
	"Method": "boolean validateMinValue(Object validationObject,Annotation annotate){\r\n    if (checkNullObject(validationObject)) {\r\n        return true;\r\n    }\r\n    Long minValue = ((Min) annotate).value();\r\n    if (checkvalidDigitTypes(validationObject.getClass())) {\r\n        if ((NumberUtils.toLong(toString(validationObject))) < minValue) {\r\n            throwValidationException(((Min) annotate).message());\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.jupiter.serialization.proto.io.UnsafeNioBufInput.readTag",
	"Comment": "attempt to read a field tag, returning zero if we have reached eof. protocol message parsers use this to readtags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.",
	"Method": "int readTag(){\r\n    if (!nioBuffer.hasRemaining()) {\r\n        lastTag = 0;\r\n        return 0;\r\n    }\r\n    final int tag = readRawVarInt32();\r\n    if (tag >>> TAG_TYPE_BITS == 0) {\r\n        throw ProtocolException.invalidTag();\r\n    }\r\n    lastTag = tag;\r\n    return tag;\r\n}"
}, {
	"Path": "com.jvmtop.openjdk.tools.MemoryPoolStat.getLastGcEndTime",
	"Comment": "returns the end time of the most recent gc onthe memory pool for this statistics in milliseconds.return 0 if no gc occurs.",
	"Method": "long getLastGcEndTime(){\r\n    return lastGcEndTime;\r\n}"
}, {
	"Path": "com.impetus.kundera.classreading.ClasspathReader.findResourcesByClasspath",
	"Comment": "uses the java.class.path system property to obtain a list of urls thatrepresent the classpath",
	"Method": "URL[] findResourcesByClasspath(){\r\n    List<URL> list = new ArrayList<URL>();\r\n    String classpath = System.getProperty(\"java.class.path\");\r\n    StringTokenizer tokenizer = new StringTokenizer(classpath, File.pathSeparator);\r\n    while (tokenizer.hasMoreTokens()) {\r\n        String path = tokenizer.nextToken();\r\n        File fp = new File(path);\r\n        if (!fp.exists())\r\n            throw new ResourceReadingException(\"File in java.class.path does not exist: \" + fp);\r\n        try {\r\n            list.add(fp.toURL());\r\n        } catch (MalformedURLException e) {\r\n            throw new ResourceReadingException(e);\r\n        }\r\n    }\r\n    return list.toArray(new URL[list.size()]);\r\n}"
}, {
	"Path": "org.lenskit.data.ratings.PackedRatingMatrix.dispose",
	"Comment": "dispose of the internal memory in the packed rating matrix.it is not necessary to call this method, but it ispresent to free extra memory references early.",
	"Method": "void dispose(){\r\n    data = null;\r\n    userIndexLists = null;\r\n}"
}, {
	"Path": "com.impetus.kundera.property.PropertyAccessorHelper.getGenericClass",
	"Comment": "retrieves generic class from a collection field that has only oneargument.",
	"Method": "Class<?> getGenericClass(Field collectionField){\r\n    Class<?> genericClass = null;\r\n    if (collectionField == null) {\r\n        return genericClass;\r\n    }\r\n    if (isCollection(collectionField.getType())) {\r\n        Type[] parameters = ReflectUtils.getTypeArguments(collectionField);\r\n        if (parameters != null) {\r\n            if (parameters.length == 1) {\r\n                genericClass = toClass(parameters[0]);\r\n            } else {\r\n                throw new PropertyAccessException(\"Can't determine generic class from a field that has more than one parameters.\");\r\n            }\r\n        }\r\n    }\r\n    if (collectionField.getType().isAssignableFrom(Map.class)) {\r\n        java.lang.reflect.Type[] arguments = ((ParameterizedType) collectionField.getGenericType()).getActualTypeArguments();\r\n        if (arguments != null && arguments.length > 1) {\r\n            genericClass = getTypedClass(arguments[1]);\r\n        }\r\n    }\r\n    return genericClass != null ? genericClass : collectionField.getType();\r\n}"
}, {
	"Path": "com.impetus.kundera.cache.ElementCollectionCacheManager.getInstance",
	"Comment": "gets the single instance of elementcollectioncachemanager.",
	"Method": "ElementCollectionCacheManager getInstance(){\r\n    if (instance == null) {\r\n        instance = new ElementCollectionCacheManager();\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.config.CassandraPropertySetterTest.testPartialOverridingOfPUProperties",
	"Comment": "tests emf properties set partially from external map and persistence.xml",
	"Method": "void testPartialOverridingOfPUProperties(){\r\n    Map<String, Object> puMap = new HashMap<String, Object>();\r\n    puMap.put(\"kundera.keyspace\", \"KunderaKeyspace\");\r\n    puMap.put(\"kundera.port\", \"9160\");\r\n    puMap.put(\"kundera.client.lookup.class\", \"com.impetus.client.cassandra.thrift.ThriftClientFactory\");\r\n    puMap.put(CassandraConstants.CQL_VERSION, CassandraConstants.CQL_VERSION_3_0);\r\n    emf = Persistence.createEntityManagerFactory(\"partialPropertyOverridePU\", puMap);\r\n    em = emf.createEntityManager();\r\n    HostConfiguration hostConfig = new CassandraHostConfiguration(puMap, CassandraPropertyReader.csmd, \"partialPropertyOverridePU\", ((EntityManagerFactoryImpl) emf).getKunderaMetadataInstance());\r\n    Assert.assertEquals(hostConfig.getHosts().get(0).getHost(), \"localhost\");\r\n    Assert.assertEquals(hostConfig.getHosts().get(0).getPort(), 9160);\r\n}"
}, {
	"Path": "org.json.JSONArray.similar",
	"Comment": "determine if two jsonarrays are similar.they must contain similar sequences.",
	"Method": "boolean similar(Object other){\r\n    if (!(other instanceof JSONArray)) {\r\n        return false;\r\n    }\r\n    int len = this.length();\r\n    if (len != ((JSONArray) other).length()) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < len; i += 1) {\r\n        Object valueThis = this.myArrayList.get(i);\r\n        Object valueOther = ((JSONArray) other).myArrayList.get(i);\r\n        if (valueThis == valueOther) {\r\n            continue;\r\n        }\r\n        if (valueThis == null) {\r\n            return false;\r\n        }\r\n        if (valueThis instanceof JSONObject) {\r\n            if (!((JSONObject) valueThis).similar(valueOther)) {\r\n                return false;\r\n            }\r\n        } else if (valueThis instanceof JSONArray) {\r\n            if (!((JSONArray) valueThis).similar(valueOther)) {\r\n                return false;\r\n            }\r\n        } else if (!valueThis.equals(valueOther)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.b3log.latke.event.AbstractEventQueue.addListener",
	"Comment": "adds the specified listener to the set of listeners for this object,provided that it is not the same as some listener already in the set.",
	"Method": "void addListener(AbstractEventListener<?> listener){\r\n    if (null == listener) {\r\n        throw new NullPointerException();\r\n    }\r\n    final String eventType = listener.getEventType();\r\n    if (null == eventType) {\r\n        throw new NullPointerException();\r\n    }\r\n    List<AbstractEventListener<?>> listenerList = listeners.get(eventType);\r\n    if (null == listenerList) {\r\n        listenerList = new ArrayList();\r\n        listeners.put(eventType, listenerList);\r\n    }\r\n    listenerList.add(listener);\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.EntityManagerFactoryImpl.getPersistenceUnitUtil",
	"Comment": "return interface providing access to utility methods for the persistenceunit.",
	"Method": "PersistenceUnitUtil getPersistenceUnitUtil(){\r\n    if (!isOpen()) {\r\n        throw new IllegalStateException(\"Entity manager factory has been closed.\");\r\n    }\r\n    return this.util;\r\n}"
}, {
	"Path": "org.b3log.latke.util.Strings.toLines",
	"Comment": "converts the specified string into a string list line by line.",
	"Method": "List<String> toLines(String string){\r\n    if (null == string) {\r\n        return null;\r\n    }\r\n    final List<String> ret = new ArrayList();\r\n    try (final BufferedReader bufferedReader = new BufferedReader(new StringReader(string))) {\r\n        String line = bufferedReader.readLine();\r\n        while (null != line) {\r\n            ret.add(line);\r\n            line = bufferedReader.readLine();\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.jupiter.transport.channel.CopyOnWriteGroupList.addIfAbsent",
	"Comment": "a version of addifabsent using the strong hint that givenrecent snapshot does not contain o.",
	"Method": "boolean addIfAbsent(JChannelGroup o,boolean addIfAbsent,JChannelGroup o,JChannelGroup[] snapshot){\r\n    final ReentrantLock lock = this.lock;\r\n    lock.lock();\r\n    try {\r\n        JChannelGroup[] current = tabAt0(array);\r\n        int len = current.length;\r\n        if (snapshot != current) {\r\n            int common = Math.min(snapshot.length, len);\r\n            for (int i = 0; i < common; i++) {\r\n                if (current[i] != snapshot[i] && eq(o, current[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (indexOf(o, current, common, len) >= 0) {\r\n                return false;\r\n            }\r\n        }\r\n        JChannelGroup[] newElements = Arrays.copyOf(current, len + 1);\r\n        newElements[len] = o;\r\n        setArray(newElements, null);\r\n        parent.incrementRefCount(o);\r\n        return true;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.b3log.latke.plugin.AbstractPlugin.getViewContent",
	"Comment": "gets view content of a plugin. the content is processed with thespecified data model by template engine.",
	"Method": "String getViewContent(Map<String, Object> dataModel){\r\n    if (null == configuration) {\r\n        initTemplateEngineCfg();\r\n    }\r\n    try {\r\n        final Template template = configuration.getTemplate(\"plugin.ftl\");\r\n        final StringWriter sw = new StringWriter();\r\n        template.process(dataModel, sw);\r\n        return sw.toString();\r\n    } catch (final Exception e) {\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "com.impetus.client.hbase.schemamanager.HBaseSchemaManager.create",
	"Comment": "create method creates schema and table for the list of tableinfos.",
	"Method": "void create(List<TableInfo> tableInfos){\r\n    createOrUpdateSchema(false);\r\n}"
}, {
	"Path": "org.cuieney.videolife.ui.widget.IjkVideoView.setOnCompletionListener",
	"Comment": "register a callback to be invoked when the end of a media filehas been reached during playback.",
	"Method": "void setOnCompletionListener(IMediaPlayer.OnCompletionListener l){\r\n    mOnCompletionListener = l;\r\n}"
}, {
	"Path": "org.lenskit.util.io.ObjectStreams.makeList",
	"Comment": "read an object stream into a list, closing when it is finished.",
	"Method": "List<T> makeList(ObjectStream<? extends T> objectStream){\r\n    List<T> result = null;\r\n    try {\r\n        if (objectStream instanceof IteratorObjectStream) {\r\n            result = ((IteratorObjectStream) objectStream).getList();\r\n        }\r\n        if (result == null) {\r\n            ImmutableList.Builder<T> builder = ImmutableList.builder();\r\n            builder.addAll(objectStream);\r\n            result = builder.build();\r\n        }\r\n    } finally {\r\n        objectStream.close();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.roundPositive",
	"Comment": "returns the closest integer to the specified float. this method will only properly round floats that are positive.",
	"Method": "int roundPositive(float value){\r\n    return (int) (value + 0.5f);\r\n}"
}, {
	"Path": "com.impetus.kundera.graph.GraphGenerator.generateGraph",
	"Comment": "generate entity graph and returns after assigning headnode. n",
	"Method": "ObjectGraph generateGraph(E entity,PersistenceDelegator delegator,ObjectGraph generateGraph,E entity,PersistenceDelegator delegator,NodeState state){\r\n    this.builder.assign(this);\r\n    Node node = generate(entity, delegator, delegator.getPersistenceCache(), state);\r\n    this.builder.assignHeadNode(node);\r\n    return this.builder.getGraph();\r\n}"
}, {
	"Path": "org.json.CDL.rowToJSONArray",
	"Comment": "produce a jsonarray of strings from a row of comma delimited values.",
	"Method": "JSONArray rowToJSONArray(JSONTokener x){\r\n    JSONArray ja = new JSONArray();\r\n    for (; ; ) {\r\n        String value = getValue(x);\r\n        char c = x.next();\r\n        if (value == null || (ja.length() == 0 && value.length() == 0 && c != ',')) {\r\n            return null;\r\n        }\r\n        ja.put(value);\r\n        for (; ; ) {\r\n            if (c == ',') {\r\n                break;\r\n            }\r\n            if (c != ' ') {\r\n                if (c == '\\n' || c == '\\r' || c == 0) {\r\n                    return ja;\r\n                }\r\n                throw x.syntaxError(\"Bad character '\" + c + \"' (\" + (int) c + \").\");\r\n            }\r\n            c = x.next();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.asha.vrlib.model.MDQuaternion.getRollRad",
	"Comment": "get the roll euler angle in radians, which is the rotation around the z axis. requires that this quaternion is normalized.",
	"Method": "float getRollRad(){\r\n    float w = q[0];\r\n    float x = q[1];\r\n    float y = q[2];\r\n    float z = q[3];\r\n    final int pole = getGimbalPole();\r\n    return pole == 0 ? MathUtils.atan2(2f * (w * z + y * x), 1f - 2f * (x * x + z * z)) : (float) pole * 2f * MathUtils.atan2(y, w);\r\n}"
}, {
	"Path": "net.openhft.collections.research.SimpleVanillaShortShortMultiMap.indexToPos",
	"Comment": "separate method because it is too easy to forget to cast to longbefore shifting.",
	"Method": "long indexToPos(int index,long indexToPos,long index){\r\n    return index << ENTRY_SIZE_SHIFT;\r\n}"
}, {
	"Path": "org.lenskit.data.ratings.RatingBuilder.copy",
	"Comment": "construct a new rating builder that is a copy of a particular rating.",
	"Method": "RatingBuilder copy(Rating r){\r\n    return r.copyBuilder();\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.schemamanager.CassandraSchemaManager.isColumnPresent",
	"Comment": "isinedexespresent method return whether indexes present or not onparticular column.",
	"Method": "boolean isColumnPresent(ColumnInfo columnInfo,ColumnDef columnDef,boolean isCql3Enabled){\r\n    return (new String(columnDef.getName(), Constants.ENCODING).equals(columnInfo.getColumnName()));\r\n}"
}, {
	"Path": "org.json.JSONObject.accumulate",
	"Comment": "accumulate values under a key. it is similar to the put method exceptthat if there is already an object stored under the key then a jsonarrayis stored under the key to hold all of the accumulated values. if thereis already a jsonarray, then the new value is appended to it. incontrast, the put method replaces the previous value.if only one value is accumulated that is not a jsonarray, then the resultwill be the same as using put. but if multiple values are accumulated,then the result will be like append.",
	"Method": "JSONObject accumulate(String key,Object value){\r\n    testValidity(value);\r\n    Object object = this.opt(key);\r\n    if (object == null) {\r\n        this.put(key, value instanceof JSONArray ? new JSONArray().put(value) : value);\r\n    } else if (object instanceof JSONArray) {\r\n        ((JSONArray) object).put(value);\r\n    } else {\r\n        this.put(key, new JSONArray().put(object).put(value));\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.resources.CRUDResource.find",
	"Comment": "handler for get method requests for this resource finds an entity from datastore",
	"Method": "Response find(String sessionToken,String entityClassName,String id,HttpHeaders headers){\r\n    sessionToken = sessionToken.replaceAll(\"^\\\"|\\\"$\", \"\");\r\n    String mediaType = headers != null && headers.getRequestHeaders().containsKey(\"Content-type\") ? headers.getRequestHeader(\"Content-type\").get(0) : MediaType.APPLICATION_JSON;\r\n    mediaType = mediaType.equalsIgnoreCase(MediaType.APPLICATION_XML) ? MediaType.APPLICATION_XML : MediaType.APPLICATION_JSON;\r\n    log.debug(\"GET: sessionToken:\" + sessionToken);\r\n    log.debug(\"GET: entityClass:\" + entityClassName);\r\n    log.debug(\"GET: ID:\" + id);\r\n    Object entity = null;\r\n    Class<?> entityClass;\r\n    EntityMetadata entityMetadata = null;\r\n    try {\r\n        EntityManager em = EMRepository.INSTANCE.getEM(sessionToken);\r\n        entityClass = EntityUtils.getEntityClass(entityClassName, em);\r\n        entityMetadata = EntityUtils.getEntityMetaData(entityClass.getSimpleName(), em);\r\n        log.debug(\"GET: entityClass\" + entityClass);\r\n        MetamodelImpl metaModel = (MetamodelImpl) em.getEntityManagerFactory().getMetamodel();\r\n        EmbeddableType keyObj = null;\r\n        Object key = null;\r\n        id = java.net.URLDecoder.decode(id, \"UTF-8\");\r\n        if (metaModel.isEmbeddable(entityMetadata.getIdAttribute().getBindableJavaType())) {\r\n            keyObj = metaModel.embeddable(entityMetadata.getIdAttribute().getBindableJavaType());\r\n            key = JAXBUtils.toObject(id, keyObj.getJavaType(), mediaType);\r\n        } else {\r\n            ObjectMapper mapper = new ObjectMapper();\r\n            key = mapper.convertValue(id, entityMetadata.getIdAttribute().getBindableJavaType());\r\n        }\r\n        entity = em.find(entityClass, key);\r\n    } catch (Exception e) {\r\n        log.error(e.getMessage());\r\n        return Response.serverError().build();\r\n    }\r\n    log.debug(\"GET: \" + entity);\r\n    if (entity == null) {\r\n        return Response.noContent().build();\r\n    }\r\n    String output = JAXBUtils.toString(entity, mediaType);\r\n    if (mediaType.equalsIgnoreCase(MediaType.APPLICATION_JSON)) {\r\n        return Response.ok(ResponseBuilder.buildOutput(entityClass, entityMetadata, output), mediaType).build();\r\n    } else {\r\n        return Response.ok(output.toString(), mediaType).build();\r\n    }\r\n}"
}, {
	"Path": "org.b3log.latke.repository.jdbc.util.JdbcUtil.executeSql",
	"Comment": "executes the specified sql with the specified params and connection...",
	"Method": "boolean executeSql(String sql,Connection connection,boolean isDebug,boolean executeSql,String sql,List<Object> paramList,Connection connection,boolean isDebug){\r\n    if (isDebug || LOGGER.isTraceEnabled()) {\r\n        LOGGER.log(Level.INFO, \"Executing SQL [\" + sql + \"]\");\r\n    }\r\n    final PreparedStatement preparedStatement = connection.prepareStatement(sql);\r\n    for (int i = 1; i <= paramList.size(); i++) {\r\n        preparedStatement.setObject(i, paramList.get(i - 1));\r\n    }\r\n    final boolean isSuccess = preparedStatement.execute();\r\n    preparedStatement.close();\r\n    return isSuccess;\r\n}"
}, {
	"Path": "com.jvmtop.openjdk.tools.ProxyClient.getMBeans",
	"Comment": "returns a map of mbeans with objectname as the key and mbeaninfo valueof a given domain.if domain is null, all mbeansare returned.if no mbean found, an empty map is returned.",
	"Method": "Map<ObjectName, MBeanInfo> getMBeans(String domain){\r\n    ObjectName name = null;\r\n    if (domain != null) {\r\n        try {\r\n            name = new ObjectName(domain + \":*\");\r\n        } catch (MalformedObjectNameException e) {\r\n            assert (false);\r\n        }\r\n    }\r\n    Set mbeans = server.queryNames(name, null);\r\n    Map<ObjectName, MBeanInfo> result = new HashMap<ObjectName, MBeanInfo>(mbeans.size());\r\n    Iterator iterator = mbeans.iterator();\r\n    while (iterator.hasNext()) {\r\n        Object object = iterator.next();\r\n        if (object instanceof ObjectName) {\r\n            ObjectName o = (ObjectName) object;\r\n            try {\r\n                MBeanInfo info = server.getMBeanInfo(o);\r\n                result.put(o, info);\r\n            } catch (IntrospectionException e) {\r\n            } catch (InstanceNotFoundException e) {\r\n            } catch (ReflectionException e) {\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.b3log.latke.repository.Repositories.getRepositoryKeysDef",
	"Comment": "gets the keys definition of an repository specified by the given repository name.",
	"Method": "JSONArray getRepositoryKeysDef(String repositoryName){\r\n    if (StringUtils.isBlank(repositoryName)) {\r\n        return null;\r\n    }\r\n    if (null == repositoriesDescription) {\r\n        return null;\r\n    }\r\n    final JSONArray repositories = repositoriesDescription.optJSONArray(\"repositories\");\r\n    for (int i = 0; i < repositories.length(); i++) {\r\n        final JSONObject repository = repositories.optJSONObject(i);\r\n        if (repositoryName.equals(repository.optString(\"name\"))) {\r\n            return repository.optJSONArray(\"keys\");\r\n        }\r\n    }\r\n    throw new RuntimeException(\"Not found the repository [name=\" + repositoryName + \"] definition, please define it in repositories.json\");\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.converters.CollectionConverter.toString",
	"Comment": "converts a collection of genericclass objects to stringrepresentation",
	"Method": "String toString(Collection<?> input,Class<?> genericClass,String mediaType){\r\n    if (MediaType.APPLICATION_XML.equals(mediaType)) {\r\n        StringBuilder sb = new StringBuilder(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\").append(\"<\").append(genericClass.getSimpleName().toLowerCase()).append(\"s>\");\r\n        for (Object obj : input) {\r\n            if (obj != null) {\r\n                String s = JAXBUtils.toString(obj, mediaType);\r\n                if (s.startsWith(\"<?xml\")) {\r\n                    s = s.substring(s.indexOf(\">\") + 1, s.length());\r\n                }\r\n                sb.append(s);\r\n            }\r\n        }\r\n        sb.append(\"<\").append(genericClass.getSimpleName().toLowerCase()).append(\"s>\");\r\n        return sb.toString();\r\n    } else if (MediaType.APPLICATION_JSON.equals(mediaType)) {\r\n        int i = 0;\r\n        StringBuilder sb = new StringBuilder(\"[\");\r\n        for (Object obj : input) {\r\n            if (obj != null) {\r\n                String s = JAXBUtils.toString(obj, mediaType);\r\n                i++;\r\n                sb.append(s);\r\n                if (i < input.size()) {\r\n                    sb.append(\",\");\r\n                }\r\n            }\r\n        }\r\n        sb.append(\"]\");\r\n        return sb.toString();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.isEqual",
	"Comment": "returns true if a is nearly equal to b. the function uses the default floating error tolerance.",
	"Method": "boolean isEqual(float a,float b,boolean isEqual,float a,float b,float tolerance){\r\n    return Math.abs(a - b) <= tolerance;\r\n}"
}, {
	"Path": "org.json.JSONArray.toJSONObject",
	"Comment": "produce a jsonobject by combining a jsonarray of names with the values ofthis jsonarray.",
	"Method": "JSONObject toJSONObject(JSONArray names){\r\n    if (names == null || names.isEmpty() || this.isEmpty()) {\r\n        return null;\r\n    }\r\n    JSONObject jo = new JSONObject(names.length());\r\n    for (int i = 0; i < names.length(); i += 1) {\r\n        jo.put(names.getString(i), this.opt(i));\r\n    }\r\n    return jo;\r\n}"
}, {
	"Path": "com.impetus.kundera.tests.entities.PersonDetailAnnotationPolyglotTest.test",
	"Comment": "test method for testing asscoiation between mongodb and cassandra",
	"Method": "void test(){\r\n    emf = Persistence.createEntityManagerFactory(\"addMongoNoAnnotateTest,secIdxAddCassandraNoAnnotateTest\");\r\n    em = emf.createEntityManager();\r\n    AddressMongoNoAnnotation address = new AddressMongoNoAnnotation();\r\n    address.setAddressId(\"1\");\r\n    address.setStreet(\"sector 20, G Block\");\r\n    UserCassandraNoAnnotation user = new UserCassandraNoAnnotation();\r\n    user.setPersonId(1);\r\n    user.setAddress(address);\r\n    user.setPersonName(\"Kuldeep\");\r\n    em.persist(user);\r\n    em.clear();\r\n    List<UserCassandraNoAnnotation> result = em.createQuery(\"Select u from UserCassandraNoAnnotation u\").getResultList();\r\n    Assert.assertNotNull(result);\r\n    Assert.assertEquals(1, result.size());\r\n    Assert.assertNotNull(result.get(0).getAddress());\r\n    Assert.assertEquals(\"sector 20, G Block\", result.get(0).getAddress().getStreet());\r\n    Assert.assertEquals(\"Kuldeep\", result.get(0).getPersonName());\r\n    em.close();\r\n    emf.close();\r\n}"
}, {
	"Path": "org.json.JSONArray.optInt",
	"Comment": "get the optional int value associated with an index. the defaultvalue isreturned if there is no value for the index, or if the value is not anumber and cannot be converted to a number.",
	"Method": "int optInt(int index,int optInt,int index,int defaultValue){\r\n    final Number val = this.optNumber(index, null);\r\n    if (val == null) {\r\n        return defaultValue;\r\n    }\r\n    return val.intValue();\r\n}"
}, {
	"Path": "org.b3log.latke.util.Templates.hasExpression",
	"Comment": "determines whether exists a variable specified by the given expressionin the specified template.",
	"Method": "boolean hasExpression(Template template,String expression,boolean hasExpression,Template template,String expression,TemplateElement templateElement){\r\n    final String canonicalForm = templateElement.getCanonicalForm();\r\n    if (canonicalForm.startsWith(expression)) {\r\n        LOGGER.log(Level.TRACE, \"Template has expression[nodeName={0}, expression={1}]\", new Object[] { templateElement.getNodeName(), expression });\r\n        return true;\r\n    }\r\n    final Enumeration<TemplateElement> children = templateElement.children();\r\n    while (children.hasMoreElements()) {\r\n        final TemplateElement nextElement = children.nextElement();\r\n        if (hasExpression(template, expression, nextElement)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.resources.SessionResource.clear",
	"Comment": "handler for post method requests for this resource clears em",
	"Method": "Response clear(String sessionToken,HttpHeaders headers){\r\n    if (log.isDebugEnabled())\r\n        log.debug(\"PUT: Session Token:\" + sessionToken);\r\n    String mediaType = headers != null && headers.getRequestHeaders().containsKey(\"Content-type\") ? headers.getRequestHeader(\"Content-type\").get(0) : MediaType.APPLICATION_JSON;\r\n    mediaType = mediaType.equalsIgnoreCase(MediaType.APPLICATION_XML) ? MediaType.APPLICATION_XML : MediaType.APPLICATION_JSON;\r\n    EntityManager em = EMRepository.INSTANCE.getEM(sessionToken);\r\n    if (em == null) {\r\n        if (log.isDebugEnabled())\r\n            log.warn(\"PUT: Session Token:\" + sessionToken + \" doesn't exist and hence can't be cleared\");\r\n        return Response.serverError().build();\r\n    }\r\n    try {\r\n        em.clear();\r\n    } catch (Exception e) {\r\n        log.error(\"PUT: Failed: \" + e.getMessage());\r\n        Response.serverError().build();\r\n    }\r\n    return Response.ok(new String(ResponseCode.CLEAR_ST_SUCCESS), mediaType).build();\r\n}"
}, {
	"Path": "com.google.android.apps.muzei.render.GLTextureView.onDetachedFromWindow",
	"Comment": "this method is used as part of the view class and is not normallycalled or subclassed by clients of glsurfaceview.must not be called before a renderer has been set.",
	"Method": "void onDetachedFromWindow(){\r\n    if (LOG_ATTACH_DETACH) {\r\n        Log.d(TAG, \"onDetachedFromWindow\");\r\n    }\r\n    if (mGLThread != null) {\r\n        mGLThread.requestExitAndWait();\r\n    }\r\n    mDetached = true;\r\n    super.onDetachedFromWindow();\r\n}"
}, {
	"Path": "org.b3log.latke.servlet.renderer.AbstractFreeMarkerRenderer.genHTML",
	"Comment": "processes the specified freemarker template with the specified request, data model.",
	"Method": "String genHTML(HttpServletRequest request,Map<String, Object> dataModel,Template template){\r\n    final StringWriter stringWriter = new StringWriter();\r\n    template.setOutputEncoding(\"UTF-8\");\r\n    template.process(dataModel, stringWriter);\r\n    final StringBuilder pageContentBuilder = new StringBuilder(stringWriter.toString());\r\n    final long endimeMillis = System.currentTimeMillis();\r\n    final String dateString = DateFormatUtils.format(endimeMillis, \"yyyy/MM/dd HH:mm:ss\");\r\n    final long startTimeMillis = (Long) request.getAttribute(Keys.HttpRequest.START_TIME_MILLIS);\r\n    final String msg = String.format(\"\\n<!-- Generated by Latke (https://github.com/b3log/latke) in %1$dms, %2$s -->\", endimeMillis - startTimeMillis, dateString);\r\n    pageContentBuilder.append(msg);\r\n    return pageContentBuilder.toString();\r\n}"
}, {
	"Path": "org.lenskit.inject.NodeProcessors.instantiate",
	"Comment": "create a node processor that will instantiate nodes.it will return nodes whose satisfactionshave been replaced with instance satisfactions containing the instance.",
	"Method": "NodeProcessor instantiate(NodeProcessor instantiate,NodeInstantiator inst){\r\n    return new InstantiatingNodeProcessor(inst);\r\n}"
}, {
	"Path": "com.impetus.client.hbase.HBaseClient.findByRange",
	"Comment": "handles find by range query for given start and end row key range values.",
	"Method": "List<E> findByRange(Class<E> entityClass,EntityMetadata metadata,byte[] startRow,byte[] endRow,String[] columns,Filter f,Queue filterClausequeue){\r\n    EntityMetadata entityMetadata = KunderaMetadataManager.getEntityMetadata(kunderaMetadata, entityClass);\r\n    String tableName = entityMetadata.getSchema();\r\n    List results = new ArrayList();\r\n    FilterList filter = new FilterList();\r\n    if (f != null) {\r\n        filter.addFilter(f);\r\n    }\r\n    if (isFindKeyOnly(metadata, columns)) {\r\n        columns = null;\r\n        filter.addFilter(new KeyOnlyFilter());\r\n    }\r\n    try {\r\n        MetamodelImpl metaModel = (MetamodelImpl) kunderaMetadata.getApplicationMetadata().getMetamodel(entityMetadata.getPersistenceUnit());\r\n        EntityType entityType = metaModel.entity(entityClass);\r\n        List<AbstractManagedType> subManagedType = ((AbstractManagedType) entityType).getSubManagedType();\r\n        if (!subManagedType.isEmpty()) {\r\n            for (AbstractManagedType subEntity : subManagedType) {\r\n                EntityMetadata subEntityMetadata = KunderaMetadataManager.getEntityMetadata(kunderaMetadata, subEntity.getJavaType());\r\n                List found = handler.readDataByRange(tableName, subEntityMetadata.getEntityClazz(), subEntityMetadata, startRow, endRow, columns, filter);\r\n                results.addAll(found);\r\n            }\r\n        } else {\r\n            results = handler.readDataByRange(tableName, entityClass, metadata, startRow, endRow, columns, filter);\r\n        }\r\n        if (showQuery && filterClausequeue.size() > 0) {\r\n            KunderaCoreUtils.printQueryWithFilterClause(filterClausequeue, entityMetadata.getTableName());\r\n        }\r\n    } catch (IOException ioex) {\r\n        log.error(\"Error during find by range, Caused by: .\", ioex);\r\n        throw new KunderaException(ioex);\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "com.asha.vrlib.model.MDQuaternion.getYaw",
	"Comment": "get the yaw euler angle in degrees, which is the rotation around the y axis. requires that this quaternion is normalized.",
	"Method": "float getYaw(){\r\n    return getYawRad() * MathUtils.radiansToDegrees;\r\n}"
}, {
	"Path": "com.impetus.kundera.metadata.MetadataUtils.isBasicElementCollectionField",
	"Comment": "checks whether a given field is element collection field of basic type",
	"Method": "boolean isBasicElementCollectionField(Field collectionField){\r\n    if (!Collection.class.isAssignableFrom(collectionField.getType()) && !Map.class.isAssignableFrom(collectionField.getType())) {\r\n        return false;\r\n    }\r\n    List<Class<?>> genericClasses = PropertyAccessorHelper.getGenericClasses(collectionField);\r\n    for (Class genericClass : genericClasses) {\r\n        if (genericClass.getAnnotation(Embeddable.class) != null) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.cuieney.videolife.ui.widget.IjkVideoView.setOnPreparedListener",
	"Comment": "register a callback to be invoked when the media fileis loaded and ready to go.",
	"Method": "void setOnPreparedListener(IMediaPlayer.OnPreparedListener l){\r\n    mOnPreparedListener = l;\r\n}"
}, {
	"Path": "org.lenskit.util.collections.LongUtils.keyValueComparator",
	"Comment": "create a comparator that compares long keys by associated double values.",
	"Method": "LongComparator keyValueComparator(Long2DoubleFunction vals){\r\n    return new AbstractLongComparator() {\r\n        @Override\r\n        public int compare(long k1, long k2) {\r\n            double v1 = vals.containsKey(k1) ? vals.get(k1) : Double.NaN;\r\n            double v2 = vals.containsKey(k2) ? vals.get(k2) : Double.NaN;\r\n            return Doubles.compare(v1, v2);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.lenskit.util.collections.LongUtils.keyValueComparator",
	"Comment": "create a comparator that compares long keys by associated double values.",
	"Method": "LongComparator keyValueComparator(Long2DoubleFunction vals){\r\n    double v1 = vals.containsKey(k1) ? vals.get(k1) : Double.NaN;\r\n    double v2 = vals.containsKey(k2) ? vals.get(k2) : Double.NaN;\r\n    return Doubles.compare(v1, v2);\r\n}"
}, {
	"Path": "org.lenskit.rerank.AbstractScoringGreedyRerankStrategy.satisfiesConstraint",
	"Comment": "tests if adding the candidate item to the list of recommended items would satisfy a constraint.the default implementation returns true, effectively disabling the constraint by default.",
	"Method": "boolean satisfiesConstraint(long userId,int n,List<? extends Result> items,Result candidate){\r\n    return true;\r\n}"
}, {
	"Path": "com.impetus.kundera.utils.KunderaCoreUtils.populateEmbeddedIdFields",
	"Comment": "recursively populate all the fields present in partition key",
	"Method": "void populateEmbeddedIdFields(Set<Attribute> embeddedAttributes,MetamodelImpl metaModel,Set<String> embeddedIdFields){\r\n    for (Attribute attribute : embeddedAttributes) {\r\n        if (!ReflectUtils.isTransientOrStatic((Field) attribute.getJavaMember())) {\r\n            if (metaModel.isEmbeddable(attribute.getJavaType())) {\r\n                EmbeddableType embeddable = metaModel.embeddable(attribute.getJavaType());\r\n                populateEmbeddedIdFieldsUtil(embeddable.getAttributes(), metaModel, embeddedIdFields);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.CoreTestUtilities.getDelegator",
	"Comment": "returns persistence delegator instance for provided entity manager instance.",
	"Method": "PersistenceDelegator getDelegator(EntityManager em){\r\n    Field pdField = em.getClass().getDeclaredField(\"persistenceDelegator\");\r\n    if (!pdField.isAccessible()) {\r\n        pdField.setAccessible(true);\r\n    }\r\n    PersistenceDelegator delegator = (PersistenceDelegator) pdField.get(em);\r\n    return delegator;\r\n}"
}, {
	"Path": "com.impetus.client.neo4j.Neo4JClientFactory.createPoolOrConnection",
	"Comment": "create neo4j embedded graph db instance, that acts as a neo4j connectionrepository for neo4j if a neo4j specfic client properties file isspecified in persistence.xml, it initializes db instance with thoseproperties. other db instance is initialized with default properties.",
	"Method": "Object createPoolOrConnection(){\r\n    if (log.isInfoEnabled())\r\n        log.info(\"Initializing Neo4J database connection...\");\r\n    PersistenceUnitMetadata puMetadata = kunderaMetadata.getApplicationMetadata().getPersistenceUnitMetadata(getPersistenceUnit());\r\n    Properties props = puMetadata.getProperties();\r\n    String datastoreFilePath = null;\r\n    if (externalProperties != null) {\r\n        datastoreFilePath = (String) externalProperties.get(PersistenceProperties.KUNDERA_DATASTORE_FILE_PATH);\r\n    }\r\n    if (StringUtils.isBlank(datastoreFilePath)) {\r\n        datastoreFilePath = (String) props.get(PersistenceProperties.KUNDERA_DATASTORE_FILE_PATH);\r\n    }\r\n    if (StringUtils.isBlank(datastoreFilePath)) {\r\n        throw new PersistenceUnitConfigurationException(\"For Neo4J, it's mandatory to specify kundera.datastore.file.path property in persistence.xml\");\r\n    }\r\n    Neo4JSchemaMetadata nsmd = Neo4JPropertyReader.nsmd;\r\n    ClientProperties cp = nsmd != null ? nsmd.getClientProperties() : null;\r\n    GraphDatabaseService graphDb = (GraphDatabaseService) getConnectionPoolOrConnection();\r\n    if (cp != null && graphDb == null) {\r\n        DataStore dataStore = nsmd != null ? nsmd.getDataStore() : null;\r\n        Properties properties = dataStore != null && dataStore.getConnection() != null ? dataStore.getConnection().getProperties() : null;\r\n        if (properties != null) {\r\n            Map<String, String> config = new HashMap<String, String>((Map) properties);\r\n            GraphDatabaseBuilder builder = new GraphDatabaseFactory().newEmbeddedDatabaseBuilder(datastoreFilePath);\r\n            builder.setConfig(config);\r\n            graphDb = builder.newGraphDatabase();\r\n        }\r\n    }\r\n    if (graphDb == null) {\r\n        graphDb = new GraphDatabaseFactory().newEmbeddedDatabase(datastoreFilePath);\r\n    }\r\n    return graphDb;\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.ExternalPropertyLoaderTest.test",
	"Comment": "junit to verify, if emf has been successfully loaded and user object hasbeen persisted.",
	"Method": "void test(){\r\n    EntityManager em = emf.createEntityManager();\r\n    User user = new User();\r\n    user.setFirstName(\"John\");\r\n    user.setLastName(\"Smith\");\r\n    user.setCity(\"London\");\r\n    em.persist(user);\r\n    em.clear();\r\n    User found = em.find(User.class, user.getUserId());\r\n    Assert.assertNotNull(found);\r\n    Assert.assertEquals(user.getCity(), found.getCity());\r\n    em.close();\r\n}"
}, {
	"Path": "com.jvmtop.openjdk.tools.ProxyClient.getDomains",
	"Comment": "returns the list of domains in which any mbean iscurrently registered.",
	"Method": "String[] getDomains(){\r\n    return server.getDomains();\r\n}"
}, {
	"Path": "org.cuieney.videolife.ui.widget.IjkVideoView.setOnErrorListener",
	"Comment": "register a callback to be invoked when an error occursduring playback or setup.if no listener is specified,or if the listener returned false, videoview will informthe user of any errors.",
	"Method": "void setOnErrorListener(IMediaPlayer.OnErrorListener l){\r\n    mOnErrorListener = l;\r\n}"
}, {
	"Path": "org.lenskit.results.AbstractResult.startEquality",
	"Comment": "create an equality builder, populated with the id and score.subclasses can use this as a starting point forchecking equality.",
	"Method": "EqualsBuilder startEquality(Result r,EqualsBuilder startEquality,Result r1,Result r2){\r\n    return new EqualsBuilder().append(r1.getId(), r2.getId()).append(r1.getScore(), r2.getScore());\r\n}"
}, {
	"Path": "org.lenskit.LenskitInfo.includesRevision",
	"Comment": "query whether this version of lenskit includes a particular revision.",
	"Method": "boolean includesRevision(String revision){\r\n    return getRevisions().contains(revision);\r\n}"
}, {
	"Path": "com.impetus.client.hbase.schemamanager.HBaseSchemaManager.validate",
	"Comment": "validate method validate schema and table for the list of tableinfos.",
	"Method": "void validate(List<TableInfo> tableInfos){\r\n    try {\r\n        if (isNamespaceAvailable(databaseName)) {\r\n            for (TableInfo tableInfo : tableInfos) {\r\n                if (tableInfo != null) {\r\n                    HTableDescriptor hTableDescriptor = admin.getTableDescriptor((databaseName + \":\" + tableInfo.getTableName()).getBytes());\r\n                    boolean columnFamilyFound = false;\r\n                    Boolean f = false;\r\n                    for (HColumnDescriptor columnDescriptor : hTableDescriptor.getColumnFamilies()) {\r\n                        if (!columnFamilyFound && columnDescriptor.getNameAsString().equalsIgnoreCase(tableInfo.getTableName())) {\r\n                            columnFamilyFound = true;\r\n                        }\r\n                        for (CollectionColumnInfo cci : tableInfo.getCollectionColumnMetadatas()) {\r\n                            if (columnDescriptor.getNameAsString().equalsIgnoreCase(cci.getCollectionColumnName())) {\r\n                                f = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!(columnFamilyFound || f)) {\r\n                            throw new SchemaGenerationException(\"column \" + tableInfo.getTableName() + \" does not exist in table \" + databaseName + \"\", \"Hbase\", databaseName, tableInfo.getTableName());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            throw new SchemaGenerationException(\"Namespace\" + databaseName + \"does not exist\", \"HBase\", databaseName);\r\n        }\r\n    } catch (TableNotFoundException tnfex) {\r\n        throw new SchemaGenerationException(\"table \" + databaseName + \" does not exist \", tnfex, \"Hbase\");\r\n    } catch (IOException ioe) {\r\n        logger.error(\"Either check for network connection or table isn't in enabled state, Caused by:\", ioe);\r\n        throw new SchemaGenerationException(ioe, \"Hbase\");\r\n    }\r\n}"
}, {
	"Path": "com.impetus.client.redis.RedisClient.fetch",
	"Comment": "retrieves entity instance of given class,row key and specific fields.",
	"Method": "Object fetch(Class clazz,Object key,Object connection,byte[][] fields){\r\n    Object result = null;\r\n    EntityMetadata entityMetadata = KunderaMetadataManager.getEntityMetadata(kunderaMetadata, clazz);\r\n    MetamodelImpl metaModel = (MetamodelImpl) kunderaMetadata.getApplicationMetadata().getMetamodel(entityMetadata.getPersistenceUnit());\r\n    String rowKey = null;\r\n    if (metaModel.isEmbeddable(entityMetadata.getIdAttribute().getBindableJavaType())) {\r\n        if (key instanceof String && ((String) key).indexOf(COMPOSITE_KEY_SEPERATOR) > 0) {\r\n            rowKey = (String) key;\r\n        } else {\r\n            rowKey = KunderaCoreUtils.prepareCompositeKey(entityMetadata, key);\r\n        }\r\n    } else {\r\n        ObjectAccessor accessor = new ObjectAccessor();\r\n        rowKey = accessor.toString(key);\r\n    }\r\n    String hashKey = getHashKey(entityMetadata.getTableName(), rowKey);\r\n    KunderaCoreUtils.printQuery(\"Fetch data from \" + entityMetadata.getTableName() + \" for PK \" + rowKey, showQuery);\r\n    try {\r\n        Map<byte[], byte[]> columns = new HashMap<byte[], byte[]>();\r\n        if (fields != null) {\r\n            List<byte[]> fieldValues = null;\r\n            if (resource != null && resource.isActive()) {\r\n                Response response = ((Transaction) connection).hmget(getEncodedBytes(hashKey), fields);\r\n                ((RedisTransaction) resource).onExecute(((Transaction) connection));\r\n                fieldValues = (List<byte[]>) response.get();\r\n                connection = getConnection();\r\n            } else {\r\n                fieldValues = ((Jedis) connection).hmget(getEncodedBytes(hashKey), fields);\r\n            }\r\n            if (fieldValues != null && !fieldValues.isEmpty()) {\r\n                for (int i = 0; i < fields.length; i++) {\r\n                    if (fieldValues.get(i) != null) {\r\n                        columns.put(fields[i], fieldValues.get(i));\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            columns = getColumns(connection, hashKey, columns);\r\n        }\r\n        result = unwrap(entityMetadata, columns, key);\r\n    } catch (JedisConnectionException jedex) {\r\n        return null;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.PersistenceDelegator.findById",
	"Comment": "find object based on primary key either form persistence cache or fromdatabase",
	"Method": "E findById(Class<E> entityClass,Object primaryKey){\r\n    E e = find(entityClass, primaryKey);\r\n    if (e == null) {\r\n        return null;\r\n    }\r\n    return (E) (e);\r\n}"
}, {
	"Path": "com.asha.vrlib.model.MDQuaternion.getPitchRad",
	"Comment": "get the pitch euler angle in radians, which is the rotation around the x axis. requires that this quaternion is normalized.",
	"Method": "float getPitchRad(){\r\n    float w = q[0];\r\n    float x = q[1];\r\n    float y = q[2];\r\n    float z = q[3];\r\n    final int pole = getGimbalPole();\r\n    return pole == 0 ? (float) Math.asin(MathUtils.clamp(2f * (w * x - z * y), -1f, 1f)) : (float) pole * MathUtils.PI * 0.5f;\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.PersistenceDelegator.refresh",
	"Comment": "refresh the state of the instance from the database, overwriting changesmade to the entity, if any.",
	"Method": "void refresh(Object entity){\r\n    if (contains(entity)) {\r\n        MainCache mainCache = (MainCache) getPersistenceCache().getMainCache();\r\n        Node node = mainCache.getNodeFromCache(entity, getMetadata(entity.getClass()), this);\r\n        try {\r\n            lock.readLock().lock();\r\n            node.setPersistenceDelegator(this);\r\n            node.refresh();\r\n        } finally {\r\n            lock.readLock().unlock();\r\n        }\r\n    } else {\r\n        throw new IllegalArgumentException(\"This is not a valid or managed entity, can't be refreshed\");\r\n    }\r\n}"
}, {
	"Path": "org.b3log.latke.repository.jdbc.JdbcTransaction.setProgrammatic",
	"Comment": "sets this transaction is programmatic with the specified flag.",
	"Method": "void setProgrammatic(boolean isProgrammatic){\r\n    this.isProgrammatic = isProgrammatic;\r\n}"
}, {
	"Path": "org.b3log.latke.servlet.renderer.AbstractFreeMarkerRenderer.doRender",
	"Comment": "processes the specified freemarker template with the specified request, data model and response.puts the page response contents into cache with the key getting from request attribute specified by page cachekey.",
	"Method": "void doRender(String html,HttpServletRequest request,HttpServletResponse response){\r\n    PrintWriter writer;\r\n    try {\r\n        writer = response.getWriter();\r\n    } catch (final Exception e) {\r\n        writer = new PrintWriter(response.getOutputStream());\r\n    }\r\n    try {\r\n        if (response.isCommitted()) {\r\n            writer.flush();\r\n            writer.close();\r\n            return;\r\n        }\r\n        writer.write(html);\r\n        writer.flush();\r\n        writer.close();\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Writes pipe failed: \" + e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.ycsb.runner.YCSBRunner.performDelete",
	"Comment": "if multiple clients are running, clear data for first time but only incase of load.",
	"Method": "boolean performDelete(int counter){\r\n    if (runType.equals(\"load\")) {\r\n        return counter == 1;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.impetus.kundera.tests.entities.PersonDetailAnnotationPolyglotTest.testRDBMSPolyglot",
	"Comment": "test method for testing polyglot between rdbms and cassandra",
	"Method": "void testRDBMSPolyglot(){\r\n    emf = Persistence.createEntityManagerFactory(\"cassandraAddressNoAnnotate,rdbmsNoAnnotateTest\");\r\n    em = emf.createEntityManager();\r\n    PersonRDBMSPolyglot person = new PersonRDBMSPolyglot();\r\n    person.setPersonId(\"p1\");\r\n    AddressCassandra address = new AddressCassandra();\r\n    address.setAddressId(\"addr_1\");\r\n    address.setStreet(\"Street\");\r\n    person.setAddress(address);\r\n    em.persist(person);\r\n    PersonRDBMSPolyglot found = em.find(PersonRDBMSPolyglot.class, \"p1\");\r\n    Assert.assertNotNull(found);\r\n    Assert.assertEquals(\"p1\", found.getPersonId());\r\n    em.close();\r\n    emf.close();\r\n}"
}, {
	"Path": "org.b3log.latke.util.Locales.hasLocale",
	"Comment": "determines whether the server has the specified locale configuration or not.",
	"Method": "boolean hasLocale(Locale locale){\r\n    try {\r\n        ResourceBundle.getBundle(Keys.LANGUAGE, locale);\r\n        return true;\r\n    } catch (final MissingResourceException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.LenskitRecommenderEngineLoader.readGraph",
	"Comment": "read a graph from an object input stream. broken out to localize the necessary warningsuppression.",
	"Method": "DAGNode<Component, Dependency> readGraph(ObjectInput in){\r\n    return (DAGNode) in.readObject();\r\n}"
}, {
	"Path": "com.impetus.kundera.index.LuceneIndexer.updateOrCreateIndexCollectionTypeEmbeddedObject",
	"Comment": "update or create indexes when embedded object is of collection type",
	"Method": "Document updateOrCreateIndexCollectionTypeEmbeddedObject(EntityMetadata metadata,MetamodelImpl metaModel,Object entity,String parentId,Class<?> clazz,boolean isUpdate,Document document,Object embeddedObject,Object rowKey,String attributeName,EmbeddableType embeddableAttribute){\r\n    ElementCollectionCacheManager ecCacheHandler = ElementCollectionCacheManager.getInstance();\r\n    if (ecCacheHandler.isCacheEmpty()) {\r\n        int count = 0;\r\n        for (Object obj : (Collection<?>) embeddedObject) {\r\n            String elementCollectionObjectName = attributeName + Constants.EMBEDDED_COLUMN_NAME_DELIMITER + count;\r\n            document = prepareDocumentForSuperColumn(metadata, entity, elementCollectionObjectName, parentId, clazz);\r\n            createSuperColumnDocument(metadata, entity, document, obj, embeddableAttribute, metaModel);\r\n            if (isUpdate) {\r\n                updateDocument(parentId, document, null);\r\n            } else {\r\n                indexDocument(metadata, document);\r\n            }\r\n            count++;\r\n        }\r\n    } else {\r\n        int lastEmbeddedObjectCount = ecCacheHandler.getLastElementCollectionObjectCount(rowKey);\r\n        for (Object obj : (Collection<?>) embeddedObject) {\r\n            document = indexCollectionObject(metadata, entity, parentId, clazz, isUpdate, rowKey, attributeName, embeddableAttribute, ecCacheHandler, lastEmbeddedObjectCount, obj, metaModel);\r\n        }\r\n    }\r\n    return document;\r\n}"
}, {
	"Path": "org.b3log.latke.Latkes.setStaticServerHost",
	"Comment": "sets static server host with the specified static server host.",
	"Method": "void setStaticServerHost(String staticServerHost){\r\n    Latkes.staticServerHost = staticServerHost;\r\n}"
}, {
	"Path": "org.json.JSONWriter.endArray",
	"Comment": "end an array. this method most be called to balance calls toarray.",
	"Method": "JSONWriter endArray(){\r\n    return this.end('a', ']');\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.query.ResultIterator.checkOnEmptyResult",
	"Comment": "check if result list is null or empty. returns true, if it is not emptyor null.",
	"Method": "boolean checkOnEmptyResult(){\r\n    return results != null && !results.isEmpty();\r\n}"
}, {
	"Path": "org.jupiter.serialization.proto.io.UnsafeNioBufInput.skipMessage",
	"Comment": "reads and discards an entire message. this will read either until eof or until an endgroup tag, whichever comesfirst.",
	"Method": "void skipMessage(){\r\n    while (true) {\r\n        final int tag = readTag();\r\n        if (tag == 0 || !skipField(tag)) {\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.b3log.latke.Latkes.setLocalProps",
	"Comment": "sets local.props with the specified props. this method is useful when you want to override behaviours of the default properties.",
	"Method": "void setLocalProps(Properties props){\r\n    Latkes.localProps = props;\r\n}"
}, {
	"Path": "org.lenskit.LenskitConfiguration.buildGraph",
	"Comment": "get a mockup of the full recommender graph. this fully resolves the graph so thatit can be analyzed, but does not create any objects.",
	"Method": "DAGNode<Component, Dependency> buildGraph(){\r\n    RecommenderGraphBuilder rgb = new RecommenderGraphBuilder();\r\n    rgb.addBindings(bindings);\r\n    rgb.addRoots(roots);\r\n    try {\r\n        return rgb.buildGraph();\r\n    } catch (ResolutionException e) {\r\n        throw new RecommenderConfigurationException(\"Cannot resolve configuration graph\", e);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.latke.plugin.AbstractPlugin.handleLangs",
	"Comment": "processes languages. retrieves language labels with default locale, then sets them into the specified data model.",
	"Method": "void handleLangs(Map<String, Object> dataModel){\r\n    final Locale locale = Latkes.getLocale();\r\n    final String language = locale.getLanguage();\r\n    final String country = locale.getCountry();\r\n    final String variant = locale.getVariant();\r\n    final StringBuilder keyBuilder = new StringBuilder(language);\r\n    if (StringUtils.isNotBlank(country)) {\r\n        keyBuilder.append(\"_\").append(country);\r\n    }\r\n    if (StringUtils.isNotBlank(variant)) {\r\n        keyBuilder.append(\"_\").append(variant);\r\n    }\r\n    final String localKey = keyBuilder.toString();\r\n    final Properties props = langs.get(localKey);\r\n    if (null == props) {\r\n        return;\r\n    }\r\n    final Set<Object> keySet = props.keySet();\r\n    for (final Object key : keySet) {\r\n        dataModel.put((String) key, props.getProperty((String) key));\r\n    }\r\n}"
}, {
	"Path": "com.jvmtop.openjdk.tools.MemoryPoolStat.getLastGcStartTime",
	"Comment": "returns the start time of the most recent gc onthe memory pool for this statistics in milliseconds.return 0 if no gc occurs.",
	"Method": "long getLastGcStartTime(){\r\n    return lastGcStartTime;\r\n}"
}, {
	"Path": "org.json.CDL.toJSONArray",
	"Comment": "produce a jsonarray of jsonobjects from a comma delimited text stringusing a supplied jsonarray as the source of element names.",
	"Method": "JSONArray toJSONArray(String string,JSONArray toJSONArray,JSONTokener x,JSONArray toJSONArray,JSONArray names,String string,JSONArray toJSONArray,JSONArray names,JSONTokener x){\r\n    if (names == null || names.length() == 0) {\r\n        return null;\r\n    }\r\n    JSONArray ja = new JSONArray();\r\n    for (; ; ) {\r\n        JSONObject jo = rowToJSONObject(names, x);\r\n        if (jo == null) {\r\n            break;\r\n        }\r\n        ja.put(jo);\r\n    }\r\n    if (ja.length() == 0) {\r\n        return null;\r\n    }\r\n    return ja;\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.resources.JPAQueryResource.executeUpdateJPAQuery",
	"Comment": "handler for put method requests for this resource retrieves records from datasource for a given update jpa query",
	"Method": "Response executeUpdateJPAQuery(HttpHeaders headers,UriInfo info,String parameters){\r\n    String jpaQuery = info.getPathParameters().getFirst(\"jpaQuery\");\r\n    String params = info.getRequestUri().getQuery();\r\n    String sessionToken = headers.getRequestHeader(Constants.SESSION_TOKEN_HEADER_NAME).get(0);\r\n    sessionToken = sessionToken.replaceAll(\"^\\\"|\\\"$\", \"\");\r\n    String mediaType = headers != null && headers.getRequestHeaders().containsKey(\"Content-type\") ? headers.getRequestHeader(\"Content-type\").get(0) : MediaType.APPLICATION_JSON;\r\n    mediaType = mediaType.equalsIgnoreCase(MediaType.APPLICATION_XML) ? MediaType.APPLICATION_XML : MediaType.APPLICATION_JSON;\r\n    if (log.isDebugEnabled())\r\n        log.debug(\"GET: sessionToken:\" + sessionToken + \", jpaQuery:\" + jpaQuery + \", Media Type:\" + mediaType);\r\n    if (!EntityUtils.isValidQuery(jpaQuery, HttpMethod.PUT)) {\r\n        log.error(\"Incorrect HTTP method POST for query:\" + jpaQuery);\r\n        return Response.noContent().build();\r\n    }\r\n    int result = executeWrite(jpaQuery, params, sessionToken, parameters, mediaType);\r\n    if (log.isDebugEnabled())\r\n        log.debug(\"GET: Result for JPA Query: \" + result);\r\n    if (result < 0) {\r\n        return Response.noContent().build();\r\n    }\r\n    return Response.ok(result, mediaType).build();\r\n}"
}, {
	"Path": "org.json.JSONArray.optLong",
	"Comment": "get the optional long value associated with an index. the defaultvalue isreturned if there is no value for the index, or if the value is not anumber and cannot be converted to a number.",
	"Method": "long optLong(int index,long optLong,int index,long defaultValue){\r\n    final Number val = this.optNumber(index, null);\r\n    if (val == null) {\r\n        return defaultValue;\r\n    }\r\n    return val.longValue();\r\n}"
}, {
	"Path": "org.lenskit.util.keys.HashKeyIndex.create",
	"Comment": "construct a new indexer.it maps each long key to its position in the list, and then be ready for more keys.",
	"Method": "HashKeyIndex create(HashKeyIndex create,LongList keys){\r\n    HashKeyIndex idx = create();\r\n    LongIterator iter = keys.iterator();\r\n    while (iter.hasNext()) {\r\n        idx.internId(iter.nextLong());\r\n    }\r\n    return idx;\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.AbstractEntityReader.onParseRelation",
	"Comment": "invokes parserelations for relation entity and set relational entitywithin entity",
	"Method": "void onParseRelation(Object entity,PersistenceDelegator pd,EntityMetadata targetEntityMetadata,Object relationEntity,Relation relation,boolean lazilyloaded,Map<Object, Object> relationStack){\r\n    parseRelations(entity, getEntity(relationEntity), getPersistedRelations(relationEntity), pd, targetEntityMetadata, lazilyloaded, relationStack);\r\n    setRelationToEntity(entity, relationEntity, relation);\r\n}"
}, {
	"Path": "org.jupiter.transport.netty.handler.IdleStateChecker.getReaderIdleTimeInMillis",
	"Comment": "return the readeridletime that was given when instance this class in milliseconds.",
	"Method": "long getReaderIdleTimeInMillis(){\r\n    return readerIdleTimeMillis;\r\n}"
}, {
	"Path": "org.lenskit.data.ratings.InteractionStatistics.create",
	"Comment": "construct a new interaction statistics object that counts ratings.",
	"Method": "InteractionStatistics create(DataAccessObject dao,EntityType type,InteractionStatistics create,DataAccessObject dao){\r\n    return create(dao, CommonTypes.RATING);\r\n}"
}, {
	"Path": "org.json.JSONArray.optJSONObject",
	"Comment": "get the optional jsonobject associated with an index. null is returned ifthe key is not found, or null if the index has no value, or if the valueis not a jsonobject.",
	"Method": "JSONObject optJSONObject(int index){\r\n    Object o = this.opt(index);\r\n    return o instanceof JSONObject ? (JSONObject) o : null;\r\n}"
}, {
	"Path": "com.fishercoder.solutions._99999RandomQuestions.method",
	"Comment": "this below small code snippet checks whether a given number is a prime number or not",
	"Method": "boolean method(int n){\r\n    if (n < 2) {\r\n        return false;\r\n    }\r\n    for (int i = 2; i < n; i++) {\r\n        if (n % i == 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.impetus.kundera.metadata.model.type.AbstractManagedType.onValidateAttributeConstraints",
	"Comment": "sets the validation constraint present field if an attribute has aconstraint present.",
	"Method": "void onValidateAttributeConstraints(Field field){\r\n    if (!this.hasValidationConstraints && MetadataUtils.onCheckValidationConstraints(field)) {\r\n        this.hasValidationConstraints = true;\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.LenskitRecommenderEngineBuilder.rewriteExcludedComponents",
	"Comment": "remove configuration that should be excluded from engine graphs, particularly the dao.",
	"Method": "DAGNode<Component, Dependency> rewriteExcludedComponents(DAGNode<Component, Dependency> graph,DataAccessObject dao){\r\n    RecommenderGraphBuilder rewriteBuilder = new RecommenderGraphBuilder();\r\n    boolean rewrite = false;\r\n    for (Pair<LenskitConfiguration, ModelDisposition> cfg : configurations) {\r\n        switch(cfg.getRight()) {\r\n            case EXCLUDED:\r\n                rewriteBuilder.addBindings(cfg.getLeft().getBindings());\r\n                rewriteBuilder.addRoots(cfg.getLeft().getRoots());\r\n                rewrite = true;\r\n                break;\r\n        }\r\n    }\r\n    if (dao != null) {\r\n        LenskitConfiguration cfg = new LenskitConfiguration();\r\n        cfg.addComponent(dao);\r\n        rewriteBuilder.addBindings(cfg.getBindings());\r\n        rewrite = true;\r\n    }\r\n    if (rewrite) {\r\n        logger.debug(\"rewriting graph\");\r\n        DependencySolver rewriter = rewriteBuilder.buildDependencyUnsolver();\r\n        try {\r\n            graph = rewriter.rewrite(graph);\r\n        } catch (ResolutionException e) {\r\n            throw new RecommenderConfigurationException(\"Resolution error while rewriting graph\", e);\r\n        }\r\n    }\r\n    return graph;\r\n}"
}, {
	"Path": "com.impetus.kundera.metadata.MetadataUtils.onCheckEmbeddableAttribute",
	"Comment": "returns true if an entity contains embedded attributeenabled",
	"Method": "boolean onCheckEmbeddableAttribute(Field attribute){\r\n    return attribute.isAnnotationPresent(Embedded.class);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.lerpAngle",
	"Comment": "linearly interpolates between two angles in radians. takes into account that angles wrap at two pi and always takes thedirection with the smallest delta angle.",
	"Method": "float lerpAngle(float fromRadians,float toRadians,float progress){\r\n    float delta = ((toRadians - fromRadians + PI2 + PI) % PI2) - PI;\r\n    return (fromRadians + delta * progress + PI2) % PI2;\r\n}"
}, {
	"Path": "com.impetus.client.hbase.query.ResultIterator.checkOnFetchSize",
	"Comment": "check on fetch size. returns true, if count on fetched rows is less thanfetch size.",
	"Method": "boolean checkOnFetchSize(){\r\n    if (count++ < fetchSize) {\r\n        return true;\r\n    }\r\n    count = 0;\r\n    scrollComplete = true;\r\n    return false;\r\n}"
}, {
	"Path": "org.b3log.latke.repository.Query.setCurrentPageNum",
	"Comment": "sets the current page number with the specified current page number.",
	"Method": "Query setCurrentPageNum(int currentPageNum){\r\n    this.currentPageNum = currentPageNum;\r\n    return this;\r\n}"
}, {
	"Path": "org.cuieney.videolife.ui.widget.IjkVideoView.setOnInfoListener",
	"Comment": "register a callback to be invoked when an informational eventoccurs during playback or setup.",
	"Method": "void setOnInfoListener(IMediaPlayer.OnInfoListener l){\r\n    mOnInfoListener = l;\r\n}"
}, {
	"Path": "com.impetus.kundera.client.cassandra.dsdriver.DSClientExternalPropertyTest.withAllPropertyTest",
	"Comment": "test to check external xml properties in case ofroundrobinpolicy,exponentialreconnectionpolicy,fallthroughretrypolicywith basedelayms,maxdelayms available in the external xml file",
	"Method": "void withAllPropertyTest(){\r\n    emf = Persistence.createEntityManagerFactory(_PU, propertyMap);\r\n    DSClientFactory ds = new DSClientFactory();\r\n    final String RRP = RoundRobinPolicy.class.getName();\r\n    final String ERP = ExponentialReconnectionPolicy.class.getName();\r\n    final String DCRP = CustomRetry.class.getName();\r\n    Properties connectionProperties = initialize(ds);\r\n    ds.initialize(propertyMap);\r\n    Object conn = ds.createPoolOrConnection();\r\n    Cluster cluster = (Cluster) conn;\r\n    HostDistance distance = HostDistance.LOCAL;\r\n    Configuration configuration = cluster.getConfiguration();\r\n    Assert.assertEquals(configuration.getSocketOptions().getReadTimeoutMillis(), 110000);\r\n    Assert.assertEquals(configuration.getSocketOptions().getKeepAlive().booleanValue(), false);\r\n    Assert.assertEquals(configuration.getSocketOptions().getReceiveBufferSize().intValue(), 12);\r\n    Assert.assertEquals(configuration.getSocketOptions().getReuseAddress().booleanValue(), true);\r\n    Assert.assertEquals(configuration.getSocketOptions().getSendBufferSize().intValue(), 11);\r\n    Assert.assertEquals(configuration.getSocketOptions().getSoLinger().intValue(), 10);\r\n    Assert.assertEquals(configuration.getSocketOptions().getTcpNoDelay().booleanValue(), true);\r\n    Assert.assertEquals(configuration.getPoolingOptions().getCoreConnectionsPerHost(distance), 5);\r\n    Assert.assertEquals(configuration.getPoolingOptions().getMaxConnectionsPerHost(distance), 12);\r\n    Assert.assertEquals(configuration.getPoolingOptions().getMaxRequestsPerConnection(distance), 128);\r\n    Assert.assertEquals(configuration.getPolicies().getLoadBalancingPolicy().getClass().getName(), RRP);\r\n    Assert.assertEquals(configuration.getPolicies().getReconnectionPolicy().getClass().getName(), ERP);\r\n    Assert.assertEquals(configuration.getPolicies().getRetryPolicy().getClass().getName(), DCRP);\r\n    Assert.assertEquals(connectionProperties.getProperty(\"baseDelayMs\"), \"11000\");\r\n    Assert.assertEquals(connectionProperties.getProperty(\"maxDelayMs\"), \"13000\");\r\n    emf.close();\r\n}"
}, {
	"Path": "com.impetus.client.es.ESNestedQueryTest.matchPerson",
	"Comment": "match person to verify each field of both persones objects are same.",
	"Method": "void matchPerson(PersonES resultPerson,PersonES person){\r\n    Assert.assertNotNull(resultPerson);\r\n    Assert.assertEquals(person.getPersonId(), resultPerson.getPersonId());\r\n    Assert.assertEquals(person.getPersonName(), resultPerson.getPersonName());\r\n    Assert.assertEquals(person.getAge(), resultPerson.getAge());\r\n    Assert.assertEquals(person.getSalary(), resultPerson.getSalary());\r\n}"
}, {
	"Path": "org.json.JSONArray.optBigInteger",
	"Comment": "get the optional biginteger value associated with an index. the defaultvalue is returned if there is no value for the index, or if the value is not a number and cannot be converted to a number.",
	"Method": "BigInteger optBigInteger(int index,BigInteger defaultValue){\r\n    Object val = this.opt(index);\r\n    return JSONObject.objectToBigInteger(val, defaultValue);\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.EntityManagerFactoryImpl.getCriteriaBuilder",
	"Comment": "return an instance of criteriabuilder for the creation of criteriaqueryobjects.",
	"Method": "CriteriaBuilder getCriteriaBuilder(){\r\n    if (isOpen()) {\r\n        return new KunderaCriteriaBuilder(this);\r\n    }\r\n    throw new IllegalStateException(\"Entity manager factory has been closed.\");\r\n}"
}, {
	"Path": "org.lenskit.basic.TopNItemBasedItemRecommender.getDefaultExcludes",
	"Comment": "get the default exclude set for a item in the global recommendation.the base implementation returns the input set.",
	"Method": "LongSet getDefaultExcludes(LongSet items){\r\n    return items;\r\n}"
}, {
	"Path": "org.lenskit.data.dao.file.DelimitedColumnEntityFormat.setBaseId",
	"Comment": "set the base entity id for this source.if an entity column is not defined, then the line number willbe added to this value to obtain a synthetic id.",
	"Method": "void setBaseId(long base){\r\n    baseId = base;\r\n}"
}, {
	"Path": "com.impetus.client.mongodb.DocumentObjectMapper.getDocumentListFromCollection",
	"Comment": "creates a mongodb document list from a given java collection. columns inthe document correspond columns provided as list.",
	"Method": "BasicDBObject[] getDocumentListFromCollection(Metamodel metaModel,Collection coll,Set<Attribute> columns,String tableName){\r\n    BasicDBObject[] dBObjects = new BasicDBObject[coll.size()];\r\n    int count = 0;\r\n    for (Object o : coll) {\r\n        dBObjects[count] = (BasicDBObject) getDocumentFromObject(metaModel, o, columns, tableName).values().toArray()[0];\r\n        count++;\r\n    }\r\n    return dBObjects;\r\n}"
}, {
	"Path": "com.impetus.kundera.metadata.MetadataUtils.useSecondryIndex",
	"Comment": "returns true, if use of secondry index is available, else false.",
	"Method": "boolean useSecondryIndex(ClientMetadata clientMetadata){\r\n    return clientMetadata != null ? clientMetadata.isUseSecondryIndex() : false;\r\n}"
}, {
	"Path": "org.b3log.latke.plugin.AbstractPlugin.setDir",
	"Comment": "sets the directory name of this plugin with the specified directory. initializes template engine configuration.",
	"Method": "void setDir(String dirName){\r\n    this.dirName = dirName;\r\n    initTemplateEngineCfg();\r\n}"
}, {
	"Path": "com.impetus.kundera.validation.rules.AttributeConstraintRule.validateMaxDecimal",
	"Comment": "checks whether a given value is a valid maximum decimal digit when compared to given value or not",
	"Method": "boolean validateMaxDecimal(Object validationObject,Annotation annotate){\r\n    if (validationObject != null) {\r\n        try {\r\n            if (checkvalidDeciDigitTypes(validationObject.getClass())) {\r\n                BigDecimal maxValue = NumberUtils.createBigDecimal(((DecimalMax) annotate).value());\r\n                BigDecimal actualValue = NumberUtils.createBigDecimal(toString(validationObject));\r\n                int res = actualValue.compareTo(maxValue);\r\n                if (res > 0) {\r\n                    throwValidationException(((DecimalMax) annotate).message());\r\n                }\r\n            }\r\n        } catch (NumberFormatException nfe) {\r\n            throw new RuleValidationException(nfe.getMessage());\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.impetus.kundera.tests.entities.PersonDetailTestAnnotation.testTableNoSchemaAnnotation",
	"Comment": "test method for testing entity classes with no schema definition",
	"Method": "void testTableNoSchemaAnnotation(){\r\n    PersonDetailNoSchema p = new PersonDetailNoSchema();\r\n    p.setPersonId(\"1\");\r\n    p.setFirstName(\"Chhavi\");\r\n    p.setLastName(\"Gangwal\");\r\n    em.persist(p);\r\n    em.clear();\r\n    PersonDetailNoSchema found = em.find(PersonDetailNoSchema.class, \"1\");\r\n    Assert.assertNotNull(found);\r\n    Assert.assertEquals(\"1\", found.getPersonId());\r\n    Assert.assertEquals(\"Chhavi\", found.getFirstName());\r\n    Assert.assertEquals(\"Gangwal\", found.getLastName());\r\n}"
}, {
	"Path": "com.impetus.kundera.tests.entities.PersonDetailTestAnnotation.testNoTableAnnotation",
	"Comment": "test method for testing entity class with no table name annotation",
	"Method": "void testNoTableAnnotation(){\r\n    PersonDetailNoTable p = new PersonDetailNoTable();\r\n    p.setPersonId(\"1\");\r\n    p.setFirstName(\"Chhavi\");\r\n    p.setLastName(\"Gangwal\");\r\n    em.persist(p);\r\n    em.clear();\r\n    PersonDetailNoTable found = em.find(PersonDetailNoTable.class, \"1\");\r\n    Assert.assertNotNull(found);\r\n    Assert.assertEquals(\"1\", found.getPersonId());\r\n    Assert.assertEquals(\"Chhavi\", found.getFirstName());\r\n    Assert.assertEquals(\"Gangwal\", found.getLastName());\r\n}"
}, {
	"Path": "org.cuieney.videolife.di.HttpLoggingInterceptor.isPlaintext",
	"Comment": "returns true if the body in question probably contains human readable text. uses a small sampleof code points to detect unicode control characters commonly used in binary file signatures.",
	"Method": "boolean isPlaintext(Buffer buffer){\r\n    try {\r\n        Buffer prefix = new Buffer();\r\n        long byteCount = buffer.size() < 64 ? buffer.size() : 64;\r\n        buffer.copyTo(prefix, 0, byteCount);\r\n        for (int i = 0; i < 16; i++) {\r\n            if (prefix.exhausted()) {\r\n                break;\r\n            }\r\n            int codePoint = prefix.readUtf8CodePoint();\r\n            if (Character.isISOControl(codePoint) && !Character.isWhitespace(codePoint)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    } catch (EOFException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.blockchain.ethereum.BlockchainImporter.importBlocks",
	"Comment": "import all blocks from startblocknumber to endblocknumber",
	"Method": "void importBlocks(BigInteger startBlockNumber,BigInteger endBlockNumber){\r\n    client.saveBlocks(startBlockNumber, endBlockNumber);\r\n}"
}, {
	"Path": "com.impetus.client.mongodb.schemamanager.MongoDBSchemaManager.create",
	"Comment": "create method creates schema and table for the list of tableinfos.",
	"Method": "void create(List<TableInfo> tableInfos){\r\n    for (TableInfo tableInfo : tableInfos) {\r\n        DBObject options = setCollectionProperties(tableInfo);\r\n        DB db = mongo.getDB(databaseName);\r\n        if (tableInfo.getLobColumnInfo().isEmpty()) {\r\n            if (db.collectionExists(tableInfo.getTableName())) {\r\n                db.getCollection(tableInfo.getTableName()).drop();\r\n                KunderaCoreUtils.printQuery(\"Drop existing collection: \" + tableInfo.getTableName(), showQuery);\r\n            }\r\n            DBCollection collection = db.createCollection(tableInfo.getTableName(), options);\r\n            KunderaCoreUtils.printQuery(\"Create collection: \" + tableInfo.getTableName(), showQuery);\r\n            boolean isCappedCollection = isCappedCollection(tableInfo);\r\n            if (!isCappedCollection) {\r\n                createIndexes(tableInfo, collection);\r\n            }\r\n        } else {\r\n            checkMultipleLobs(tableInfo);\r\n            if (db.collectionExists(tableInfo.getTableName() + MongoDBUtils.FILES)) {\r\n                db.getCollection(tableInfo.getTableName() + MongoDBUtils.FILES).drop();\r\n                KunderaCoreUtils.printQuery(\"Drop existing Grid FS Metadata collection: \" + tableInfo.getTableName() + MongoDBUtils.FILES, showQuery);\r\n            }\r\n            if (db.collectionExists(tableInfo.getTableName() + MongoDBUtils.CHUNKS)) {\r\n                db.getCollection(tableInfo.getTableName() + MongoDBUtils.CHUNKS).drop();\r\n                KunderaCoreUtils.printQuery(\"Drop existing Grid FS data collection: \" + tableInfo.getTableName() + MongoDBUtils.CHUNKS, showQuery);\r\n            }\r\n            coll = db.createCollection(tableInfo.getTableName() + MongoDBUtils.FILES, options);\r\n            createUniqueIndexGFS(coll, tableInfo.getIdColumnName());\r\n            KunderaCoreUtils.printQuery(\"Create collection: \" + tableInfo.getTableName() + MongoDBUtils.FILES, showQuery);\r\n            db.createCollection(tableInfo.getTableName() + MongoDBUtils.CHUNKS, options);\r\n            KunderaCoreUtils.printQuery(\"Create collection: \" + tableInfo.getTableName() + MongoDBUtils.CHUNKS, showQuery);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.fishercoder.solutions._663.checkEqualTree",
	"Comment": "the idea is that we use a map to store the sum of each node, then in the end,we check if any node has a sum that is exactly half of total sum.",
	"Method": "boolean checkEqualTree(TreeNode root){\r\n    Map<TreeNode, Integer> map = new HashMap();\r\n    int totalSum = sumForEachNode(root, map);\r\n    if (totalSum % 2 != 0 || map.size() < 2) {\r\n        return false;\r\n    }\r\n    for (TreeNode key : map.keySet()) {\r\n        if (map.get(key) == totalSum / 2) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.b3log.latke.servlet.renderer.JsonRenderer.setJSONObject",
	"Comment": "sets the json object to render with the specified json object.",
	"Method": "void setJSONObject(JSONObject jsonObject){\r\n    this.jsonObject = jsonObject;\r\n}"
}, {
	"Path": "org.lenskit.util.io.LKFileUtils.openInput",
	"Comment": "open a reader with automatic compression and the default character set.",
	"Method": "Reader openInput(File file,Charset charset,CompressionMode compression,Reader openInput,File file,CompressionMode compression,Reader openInput,File file){\r\n    return openInput(file, Charset.defaultCharset(), CompressionMode.AUTO);\r\n}"
}, {
	"Path": "com.google.android.apps.muzei.render.GLTextureView.setPreserveEGLContextOnPause",
	"Comment": "control whether the egl context is preserved when the glsurfaceview is paused andresumed.if set to true, then the egl context may be preserved when the glsurfaceview is paused.whether the egl context is actually preserved or not depends upon whether theandroid device that the program is running on can support an arbitrary number of eglcontexts or not. devices that can only support a limited number of egl contexts mustrelease theegl context in order to allow multiple applications to share the gpu.if set to false, the egl context will be released when the glsurfaceview is paused,and recreated when the glsurfaceview is resumed.the default is false.",
	"Method": "void setPreserveEGLContextOnPause(boolean preserveOnPause){\r\n    mPreserveEGLContextOnPause = preserveOnPause;\r\n}"
}, {
	"Path": "com.jvmtop.monitor.VMInfo.createDeadVM",
	"Comment": "creates a dead vminfo, representing a jvm in a given statewhich cannot be attached or other monitoring issues occurred.",
	"Method": "VMInfo createDeadVM(int vmid,LocalVirtualMachine localVm,VMInfo createDeadVM,int vmid,LocalVirtualMachine localVm,VMInfoState state){\r\n    VMInfo vmInfo = new VMInfo();\r\n    vmInfo.state_ = state;\r\n    vmInfo.localVm_ = localVm;\r\n    return vmInfo;\r\n}"
}, {
	"Path": "org.lenskit.data.ratings.Rating.copyBuilder",
	"Comment": "create a new rating builder that will build a copy of this rating.",
	"Method": "RatingBuilder copyBuilder(){\r\n    RatingBuilder rb = new RatingBuilder();\r\n    rb.setUserId(user).setItemId(item).setTimestamp(getTimestamp());\r\n    double v = getValue();\r\n    if (!Double.isNaN(v)) {\r\n        rb.setRating(v);\r\n    }\r\n    return rb;\r\n}"
}, {
	"Path": "com.jvmtop.openjdk.tools.MemoryPoolStat.getAfterGcUsage",
	"Comment": "returns the memory usage after the most recent gc finished.null if no gc occurs.",
	"Method": "MemoryUsage getAfterGcUsage(){\r\n    return beforeGcUsage;\r\n}"
}, {
	"Path": "org.jupiter.transport.netty.NettyAcceptor.createWriteBufferWaterMark",
	"Comment": "create a writebufferwatermark is used to set low water mark and high water mark for the write buffer.",
	"Method": "WriteBufferWaterMark createWriteBufferWaterMark(int bufLowWaterMark,int bufHighWaterMark){\r\n    WriteBufferWaterMark waterMark;\r\n    if (bufLowWaterMark >= 0 && bufHighWaterMark > 0) {\r\n        waterMark = new WriteBufferWaterMark(bufLowWaterMark, bufHighWaterMark);\r\n    } else {\r\n        waterMark = new WriteBufferWaterMark(512 * 1024, 1024 * 1024);\r\n    }\r\n    return waterMark;\r\n}"
}, {
	"Path": "org.json.JSONTokener.back",
	"Comment": "back up one character. this provides a sort of lookahead capability,so that you can test for a digit or letter before attempting to parsethe next number or identifier.",
	"Method": "void back(){\r\n    if (this.usePrevious || this.index <= 0) {\r\n        throw new JSONException(\"Stepping back two steps is not supported\");\r\n    }\r\n    this.decrementIndexes();\r\n    this.usePrevious = true;\r\n    this.eof = false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.lerp",
	"Comment": "linearly interpolates between fromvalue to tovalue on progress position.",
	"Method": "float lerp(float fromValue,float toValue,float progress){\r\n    return fromValue + (toValue - fromValue) * progress;\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.resources.TransactionResource.begin",
	"Comment": "handler for get method requests for this resource begins a fresh\ttransaction for given session",
	"Method": "String begin(String sessionToken){\r\n    if (log.isDebugEnabled())\r\n        log.debug(\"GET: Session Token:\" + sessionToken);\r\n    EntityManager em = EMRepository.INSTANCE.getEM(sessionToken);\r\n    if (em == null) {\r\n        if (log.isDebugEnabled())\r\n            log.warn(\"GET: Session Token:\" + sessionToken + \" doesn't exist and transaction failed to begin\");\r\n        return ResponseCode.GET_TX_FAILED;\r\n    }\r\n    try {\r\n        em.getTransaction().begin();\r\n    } catch (Exception e) {\r\n        log.error(\"GET: Failed: \" + e.getMessage());\r\n        return ResponseCode.GET_TX_FAILED;\r\n    }\r\n    return ResponseCode.GET_TX_SUCCESS;\r\n}"
}, {
	"Path": "org.json.JSONObject.toJSONArray",
	"Comment": "produce a jsonarray containing the values of the members of thisjsonobject.",
	"Method": "JSONArray toJSONArray(JSONArray names){\r\n    if (names == null || names.isEmpty()) {\r\n        return null;\r\n    }\r\n    JSONArray ja = new JSONArray();\r\n    for (int i = 0; i < names.length(); i += 1) {\r\n        ja.put(this.opt(names.getString(i)));\r\n    }\r\n    return ja;\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.schemamanager.CassandraDataTranslator.decompose",
	"Comment": "calls decompose function of respective data type of object.",
	"Method": "Object decompose(Class<?> dataTypeClazz,Object dataValue,boolean isCql3Enabled,Object decompose,Class<?> dataTypeClazz,Object dataValue,List<Class<?>> mapGenericClassses,boolean isCql3Enabled,Object decompose,Class<?> dataTypeClazz,Object dataValue,Class<?> mapGenericClassses,boolean isCql3Enabled,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Class<?> genericClass,Object decompose,Object value,List<Class<?>> mapGenericClasses,Object decompose,Object value,Class clazz,Class<?> genericClass,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz,Object decompose,Object value,Class clazz){\r\n    if (isCql3Enabled || (!isCql3Enabled && dataValue != null)) {\r\n        switch(getCassandraDataTypeClass(dataTypeClazz)) {\r\n            case LIST:\r\n                return ListTypeBuilder.decompose(dataValue, dataTypeClazz, mapGenericClassses);\r\n            case SET:\r\n                return SetTypeBuilder.decompose(dataValue, dataTypeClazz, mapGenericClassses);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.json.JSONObject.optString",
	"Comment": "get an optional string associated with a key. it returns the defaultvalueif there is no such key.",
	"Method": "String optString(String key,String optString,String key,String defaultValue){\r\n    Object object = this.opt(key);\r\n    return NULL.equals(object) ? defaultValue : object.toString();\r\n}"
}, {
	"Path": "org.json.JSONML.toString",
	"Comment": "reverse the jsonml transformation, making an xml text from a jsonarray.",
	"Method": "String toString(JSONArray ja,String toString,JSONObject jo){\r\n    StringBuilder sb = new StringBuilder();\r\n    int i;\r\n    JSONArray ja;\r\n    int length;\r\n    Object object;\r\n    String tagName;\r\n    Object value;\r\n    tagName = jo.optString(\"tagName\");\r\n    if (tagName == null) {\r\n        return XML.escape(jo.toString());\r\n    }\r\n    XML.noSpace(tagName);\r\n    tagName = XML.escape(tagName);\r\n    sb.append('<');\r\n    sb.append(tagName);\r\n    for (final String key : jo.keySet()) {\r\n        if (!\"tagName\".equals(key) && !\"childNodes\".equals(key)) {\r\n            XML.noSpace(key);\r\n            value = jo.opt(key);\r\n            if (value != null) {\r\n                sb.append(' ');\r\n                sb.append(XML.escape(key));\r\n                sb.append('=');\r\n                sb.append('\"');\r\n                sb.append(XML.escape(value.toString()));\r\n                sb.append('\"');\r\n            }\r\n        }\r\n    }\r\n    ja = jo.optJSONArray(\"childNodes\");\r\n    if (ja == null) {\r\n        sb.append('/');\r\n        sb.append('>');\r\n    } else {\r\n        sb.append('>');\r\n        length = ja.length();\r\n        for (i = 0; i < length; i += 1) {\r\n            object = ja.get(i);\r\n            if (object != null) {\r\n                if (object instanceof String) {\r\n                    sb.append(XML.escape(object.toString()));\r\n                } else if (object instanceof JSONObject) {\r\n                    sb.append(toString((JSONObject) object));\r\n                } else if (object instanceof JSONArray) {\r\n                    sb.append(toString((JSONArray) object));\r\n                } else {\r\n                    sb.append(object.toString());\r\n                }\r\n            }\r\n        }\r\n        sb.append('<');\r\n        sb.append('/');\r\n        sb.append(tagName);\r\n        sb.append('>');\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.lenskit.data.store.EntityCollection.getSortKeys",
	"Comment": "get the sort keys, if this collection stores attributes in sorted order.",
	"Method": "List<SortKey> getSortKeys(){\r\n    return ImmutableList.of();\r\n}"
}, {
	"Path": "org.json.Property.toJSONObject",
	"Comment": "converts a property file object into a jsonobject. the property file object is a table of name value pairs.",
	"Method": "JSONObject toJSONObject(java.util.Properties properties){\r\n    JSONObject jo = new JSONObject();\r\n    if (properties != null && !properties.isEmpty()) {\r\n        Enumeration<?> enumProperties = properties.propertyNames();\r\n        while (enumProperties.hasMoreElements()) {\r\n            String name = (String) enumProperties.nextElement();\r\n            jo.put(name, properties.getProperty(name));\r\n        }\r\n    }\r\n    return jo;\r\n}"
}, {
	"Path": "org.b3log.latke.plugin.PluginManager.registerEventListeners",
	"Comment": "registers event listeners with the specified plugin properties, class loader and plugin.",
	"Method": "void registerEventListeners(Properties props,URLClassLoader classLoader,AbstractPlugin plugin){\r\n    final String eventListenerClasses = props.getProperty(Plugin.PLUGIN_EVENT_LISTENER_CLASSES);\r\n    final String[] eventListenerClassArray = eventListenerClasses.split(\",\");\r\n    for (final String eventListenerClassName : eventListenerClassArray) {\r\n        if (StringUtils.isBlank(eventListenerClassName)) {\r\n            LOGGER.log(Level.INFO, \"No event listener to load for plugin[name={0}]\", plugin.getName());\r\n            return;\r\n        }\r\n        LOGGER.log(Level.DEBUG, \"Loading event listener[className={0}]\", eventListenerClassName);\r\n        final Class<?> eventListenerClass = classLoader.loadClass(eventListenerClassName);\r\n        final AbstractEventListener<?> eventListener = (AbstractEventListener) eventListenerClass.newInstance();\r\n        plugin.addEventListener(eventListener);\r\n        LOGGER.log(Level.DEBUG, \"Registered event listener[class={0}, eventType={1}] for plugin[name={2}]\", eventListener.getClass(), eventListener.getEventType(), plugin.getName());\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.util.io.LKFileUtils.byteSource",
	"Comment": "create a file byte source, automatically decompressing based on file name.",
	"Method": "ByteSource byteSource(File file,ByteSource byteSource,File file,CompressionMode compression,ByteSource byteSource,URL url,CompressionMode compression){\r\n    CompressionMode effectiveMode = compression.getEffectiveCompressionMode(url.getPath());\r\n    ByteSource source = Resources.asByteSource(url);\r\n    if (!effectiveMode.equals(CompressionMode.NONE)) {\r\n        source = new CompressedByteSource(source, effectiveMode.getCompressorName());\r\n    }\r\n    return source;\r\n}"
}, {
	"Path": "org.b3log.latke.util.AntPathMatcher.toStringArray",
	"Comment": "copy the given collection into a string array.the collection must contain string elements only.",
	"Method": "String[] toStringArray(Collection collection){\r\n    if (null == collection) {\r\n        return null;\r\n    }\r\n    return (String[]) collection.toArray(new String[collection.size()]);\r\n}"
}, {
	"Path": "org.json.XML.parse",
	"Comment": "scan the content following the named tag, attaching it to the context.",
	"Method": "boolean parse(XMLTokener x,JSONObject context,String name,boolean keepStrings){\r\n    char c;\r\n    int i;\r\n    JSONObject jsonobject = null;\r\n    String string;\r\n    String tagName;\r\n    Object token;\r\n    token = x.nextToken();\r\n    if (token == BANG) {\r\n        c = x.next();\r\n        if (c == '-') {\r\n            if (x.next() == '-') {\r\n                x.skipPast(\"-->\");\r\n                return false;\r\n            }\r\n            x.back();\r\n        } else if (c == '[') {\r\n            token = x.nextToken();\r\n            if (\"CDATA\".equals(token)) {\r\n                if (x.next() == '[') {\r\n                    string = x.nextCDATA();\r\n                    if (string.length() > 0) {\r\n                        context.accumulate(\"content\", string);\r\n                    }\r\n                    return false;\r\n                }\r\n            }\r\n            throw x.syntaxError(\"Expected 'CDATA['\");\r\n        }\r\n        i = 1;\r\n        do {\r\n            token = x.nextMeta();\r\n            if (token == null) {\r\n                throw x.syntaxError(\"Missing '>' after '<!'.\");\r\n            } else if (token == LT) {\r\n                i += 1;\r\n            } else if (token == GT) {\r\n                i -= 1;\r\n            }\r\n        } while (i > 0);\r\n        return false;\r\n    } else if (token == QUEST) {\r\n        x.skipPast(\"?>\");\r\n        return false;\r\n    } else if (token == SLASH) {\r\n        token = x.nextToken();\r\n        if (name == null) {\r\n            throw x.syntaxError(\"Mismatched close tag \" + token);\r\n        }\r\n        if (!token.equals(name)) {\r\n            throw x.syntaxError(\"Mismatched \" + name + \" and \" + token);\r\n        }\r\n        if (x.nextToken() != GT) {\r\n            throw x.syntaxError(\"Misshaped close tag\");\r\n        }\r\n        return true;\r\n    } else if (token instanceof Character) {\r\n        throw x.syntaxError(\"Misshaped tag\");\r\n    } else {\r\n        tagName = (String) token;\r\n        token = null;\r\n        jsonobject = new JSONObject();\r\n        for (; ; ) {\r\n            if (token == null) {\r\n                token = x.nextToken();\r\n            }\r\n            if (token instanceof String) {\r\n                string = (String) token;\r\n                token = x.nextToken();\r\n                if (token == EQ) {\r\n                    token = x.nextToken();\r\n                    if (!(token instanceof String)) {\r\n                        throw x.syntaxError(\"Missing value\");\r\n                    }\r\n                    jsonobject.accumulate(string, keepStrings ? ((String) token) : stringToValue((String) token));\r\n                    token = null;\r\n                } else {\r\n                    jsonobject.accumulate(string, \"\");\r\n                }\r\n            } else if (token == SLASH) {\r\n                if (x.nextToken() != GT) {\r\n                    throw x.syntaxError(\"Misshaped tag\");\r\n                }\r\n                if (jsonobject.length() > 0) {\r\n                    context.accumulate(tagName, jsonobject);\r\n                } else {\r\n                    context.accumulate(tagName, \"\");\r\n                }\r\n                return false;\r\n            } else if (token == GT) {\r\n                for (; ; ) {\r\n                    token = x.nextContent();\r\n                    if (token == null) {\r\n                        if (tagName != null) {\r\n                            throw x.syntaxError(\"Unclosed tag \" + tagName);\r\n                        }\r\n                        return false;\r\n                    } else if (token instanceof String) {\r\n                        string = (String) token;\r\n                        if (string.length() > 0) {\r\n                            jsonobject.accumulate(\"content\", keepStrings ? string : stringToValue(string));\r\n                        }\r\n                    } else if (token == LT) {\r\n                        if (parse(x, jsonobject, tagName, keepStrings)) {\r\n                            if (jsonobject.length() == 0) {\r\n                                context.accumulate(tagName, \"\");\r\n                            } else if (jsonobject.length() == 1 && jsonobject.opt(\"content\") != null) {\r\n                                context.accumulate(tagName, jsonobject.opt(\"content\"));\r\n                            } else {\r\n                                context.accumulate(tagName, jsonobject);\r\n                            }\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                throw x.syntaxError(\"Misshaped tag\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.metadata.MetadataUtils.containsBasicElementCollectionField",
	"Comment": "checks whether an entity with given metadata contains a collection field",
	"Method": "boolean containsBasicElementCollectionField(EntityMetadata m,KunderaMetadata kunderaMetadata){\r\n    Metamodel metaModel = kunderaMetadata.getApplicationMetadata().getMetamodel(m.getPersistenceUnit());\r\n    EntityType entityType = metaModel.entity(m.getEntityClazz());\r\n    Iterator<Attribute> iter = entityType.getAttributes().iterator();\r\n    while (iter.hasNext()) {\r\n        Attribute attr = iter.next();\r\n        if (attr.isCollection() && !attr.isAssociation() && isBasicElementCollectionField((Field) attr.getJavaMember())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.resources.MetadataResource.getSchemaList",
	"Comment": "handler for get requests. returns schema list and related metadata for the given list of persistence units.",
	"Method": "Response getSchemaList(String sessionToken,String persistenceUnits,HttpHeaders headers){\r\n    if (log.isDebugEnabled())\r\n        log.debug(\"GET: Persistence Units:\" + persistenceUnits);\r\n    sessionToken = sessionToken.replaceAll(\"^\\\"|\\\"$\", \"\");\r\n    EntityManager em = EMRepository.INSTANCE.getEM(sessionToken);\r\n    StringTokenizer st = new StringTokenizer(persistenceUnits, \",\");\r\n    EntityManagerFactoryImpl emfImpl = (EntityManagerFactoryImpl) em.getEntityManagerFactory();\r\n    SchemaMetadata schemaMetadata = new SchemaMetadata();\r\n    String mediaType = headers != null && headers.getRequestHeaders().containsKey(\"Content-type\") ? headers.getRequestHeader(\"Content-type\").get(0) : MediaType.APPLICATION_JSON;\r\n    mediaType = mediaType.equalsIgnoreCase(MediaType.APPLICATION_XML) ? MediaType.APPLICATION_XML : MediaType.APPLICATION_JSON;\r\n    while (st.hasMoreTokens()) {\r\n        String persistenceUnit = st.nextToken();\r\n        PersistenceUnitMetadata puMetadata = emfImpl.getKunderaMetadataInstance().getApplicationMetadata().getPersistenceUnitMetadata(persistenceUnit);\r\n        String schemaStr = puMetadata.getProperty(\"kundera.keyspace\");\r\n        if (schemaStr != null) {\r\n            Schema schema = new Schema();\r\n            schema.setSchemaName(schemaStr);\r\n            MetamodelImpl metamodel = (MetamodelImpl) em.getEntityManagerFactory().getMetamodel();\r\n            Map<String, EntityMetadata> metamodelMap = metamodel.getEntityMetadataMap();\r\n            for (String clazz : metamodelMap.keySet()) {\r\n                EntityMetadata m = metamodelMap.get(clazz);\r\n                Table table = new Table();\r\n                table.setEntityClassName(clazz);\r\n                table.setTableName(m.getTableName());\r\n                table.setSimpleEntityClassName(m.getEntityClazz().getSimpleName());\r\n                schema.addTable(table);\r\n            }\r\n            schemaMetadata.addSchema(schema);\r\n        }\r\n    }\r\n    if (schemaMetadata.getSchemaList().isEmpty()) {\r\n        if (log.isDebugEnabled())\r\n            log.warn(\"GET: getSchemaList: Can't find Schema for PUs \" + persistenceUnits);\r\n        return Response.noContent().build();\r\n    } else {\r\n        if (mediaType.equalsIgnoreCase(MediaType.APPLICATION_JSON)) {\r\n            ObjectMapper mapper = new ObjectMapper();\r\n            String output = null;\r\n            try {\r\n                output = mapper.writeValueAsString(schemaMetadata);\r\n            } catch (JsonGenerationException e) {\r\n                log.error(e.getMessage());\r\n            } catch (JsonMappingException e) {\r\n                log.error(e.getMessage());\r\n            } catch (IOException e) {\r\n                log.error(e.getMessage());\r\n            }\r\n            return Response.ok(ResponseBuilder.buildOutput(output, \"'\"), mediaType).build();\r\n        } else {\r\n            return Response.ok(schemaMetadata, mediaType).build();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.basic.FallbackResult.isFromPrimary",
	"Comment": "query whether this result came from the primary or the baseline item scorer.",
	"Method": "boolean isFromPrimary(){\r\n    return fromPrimary;\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.schemamanager.CassandraSchemaManager.isMetadataSame",
	"Comment": "is metadata same method returns true if columndef and columninfo havesame metadata.",
	"Method": "boolean isMetadataSame(ColumnDef columnDef,ColumnInfo columnInfo,boolean isCql3Enabled,boolean isCounterColumnType){\r\n    return isIndexPresent(columnInfo, columnDef, isCql3Enabled, isCounterColumnType);\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.floorPositive",
	"Comment": "returns the largest integer less than or equal to the specified float. this method will only properly floor floats that arepositive. note this method simply casts the float to int.",
	"Method": "int floorPositive(float value){\r\n    return (int) value;\r\n}"
}, {
	"Path": "com.impetus.client.neo4j.GraphEntityMapper.serializeIdAttributeValue",
	"Comment": "prepares id column value for embedded ids by combining its attributes",
	"Method": "String serializeIdAttributeValue(EntityMetadata m,MetamodelImpl metaModel,Object id){\r\n    if (!metaModel.isEmbeddable(m.getIdAttribute().getBindableJavaType())) {\r\n        return null;\r\n    }\r\n    Class<?> embeddableClass = m.getIdAttribute().getBindableJavaType();\r\n    String idUniqueValue = \"\";\r\n    for (Field embeddedField : embeddableClass.getDeclaredFields()) {\r\n        if (!ReflectUtils.isTransientOrStatic(embeddedField)) {\r\n            Object value = PropertyAccessorHelper.getObject(id, embeddedField);\r\n            if (value != null && !StringUtils.isEmpty(value.toString()))\r\n                idUniqueValue = idUniqueValue + value + COMPOSITE_KEY_SEPARATOR;\r\n        }\r\n    }\r\n    if (idUniqueValue.endsWith(COMPOSITE_KEY_SEPARATOR))\r\n        idUniqueValue = idUniqueValue.substring(0, idUniqueValue.length() - COMPOSITE_KEY_SEPARATOR.length());\r\n    return idUniqueValue;\r\n}"
}, {
	"Path": "org.b3log.latke.servlet.RequestContext.setHeader",
	"Comment": "sets a header specified by the given name and value to the response.",
	"Method": "void setHeader(String name,String value){\r\n    response.setHeader(name, value);\r\n}"
}, {
	"Path": "org.b3log.latke.repository.jdbc.JdbcRepository.getNeedUpdateJsonObject",
	"Comment": "compares the specified old json object and the new json object, returns diff object for updating.",
	"Method": "JSONObject getNeedUpdateJsonObject(JSONObject oldJsonObject,JSONObject jsonObject){\r\n    if (null == oldJsonObject) {\r\n        return jsonObject;\r\n    }\r\n    final JSONObject ret = new JSONObject();\r\n    final Iterator<String> keys = jsonObject.keys();\r\n    String key;\r\n    while (keys.hasNext()) {\r\n        key = keys.next();\r\n        if (null == jsonObject.get(key) && null == oldJsonObject.get(key)) {\r\n            ret.put(key, jsonObject.get(key));\r\n        } else if (!jsonObject.optString(key).equals(oldJsonObject.optString(key))) {\r\n            ret.put(key, jsonObject.get(key));\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.json.JSONArray.put",
	"Comment": "put or replace an object value in the jsonarray. if the index is greaterthan the length of the jsonarray, then null elements will be added asnecessary to pad it out.",
	"Method": "JSONArray put(boolean value,JSONArray put,Collection<?> value,JSONArray put,double value,JSONArray put,float value,JSONArray put,int value,JSONArray put,long value,JSONArray put,Map<?, ?> value,JSONArray put,Object value,JSONArray put,int index,boolean value,JSONArray put,int index,Collection<?> value,JSONArray put,int index,double value,JSONArray put,int index,float value,JSONArray put,int index,int value,JSONArray put,int index,long value,JSONArray put,int index,Map<?, ?> value,JSONArray put,int index,Object value){\r\n    if (index < 0) {\r\n        throw new JSONException(\"JSONArray[\" + index + \"] not found.\");\r\n    }\r\n    if (index < this.length()) {\r\n        JSONObject.testValidity(value);\r\n        this.myArrayList.set(index, value);\r\n        return this;\r\n    }\r\n    if (index == this.length()) {\r\n        return this.put(value);\r\n    }\r\n    this.myArrayList.ensureCapacity(index + 1);\r\n    while (index != this.length()) {\r\n        this.myArrayList.add(JSONObject.NULL);\r\n    }\r\n    return this.put(value);\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.resources.SessionResource.deleteSession",
	"Comment": "handler for delete method requests for this resource closes em and\tremoves session token alongwith from repository",
	"Method": "Response deleteSession(String sessionToken,HttpHeaders headers){\r\n    if (log.isDebugEnabled())\r\n        log.debug(\"DELETE: Session Token:\" + sessionToken);\r\n    String mediaType = headers != null && headers.getRequestHeaders().containsKey(\"Content-type\") ? headers.getRequestHeader(\"Content-type\").get(0) : MediaType.APPLICATION_JSON;\r\n    mediaType = mediaType.equalsIgnoreCase(MediaType.APPLICATION_XML) ? MediaType.APPLICATION_XML : MediaType.APPLICATION_JSON;\r\n    EntityManager em = EMRepository.INSTANCE.getEM(sessionToken);\r\n    if (em == null) {\r\n        if (log.isDebugEnabled())\r\n            log.warn(\"DELETE: Session Token:\" + sessionToken + \" doesn't exist and hence can't be deleted\");\r\n        Response.serverError().build();\r\n    }\r\n    EMRepository.INSTANCE.removeEm(sessionToken);\r\n    return Response.ok(new String(ResponseCode.DELETE_ST_SUCCESS), mediaType).build();\r\n}"
}, {
	"Path": "com.impetus.client.mongodb.config.MongoDBShowQueryTest.testShowQuerySetInPropertyMap",
	"Comment": "testing kunera.show.query property when it is enabled at external properties level",
	"Method": "void testShowQuerySetInPropertyMap(){\r\n    puProperties.put(\"kundera.show.query\", \"true\");\r\n    emf = Persistence.createEntityManagerFactory(SHOW_QUERY_DISABLED_PU, puProperties);\r\n    em = emf.createEntityManager();\r\n    try {\r\n        int i = 0;\r\n        String[] expectedQuery = new String[4];\r\n        String actualQuery = null;\r\n        BufferedReader br = null;\r\n        File file = new File(\"showQuery.log\");\r\n        PrintStream printStream;\r\n        printStream = new PrintStream(new FileOutputStream(file));\r\n        System.setOut(printStream);\r\n        Query q = em.createQuery(\"Select p.personName from UserInformation p where p.personId = 2\");\r\n        q.getResultList();\r\n        expectedQuery[0] = \"Find document: { \\\"_id\\\" : \\\"2\\\"}\";\r\n        System.setOut(printStream);\r\n        q = em.createQuery(\"Select p.personName from UserInformation p where p.personId < 3\");\r\n        q.getResultList();\r\n        expectedQuery[1] = \"Find document: { \\\"_id\\\" : { \\\"$lt\\\" : \\\"3\\\"}}\";\r\n        System.setOut(printStream);\r\n        q = em.createQuery(\"Select p.personName from UserInformation p where p.personId >= 1 and p.personId < 3\");\r\n        q.getResultList();\r\n        expectedQuery[2] = \"Find document: { \\\"_id\\\" : { \\\"$gte\\\" : \\\"1\\\" , \\\"$lt\\\" : \\\"3\\\"}}\";\r\n        System.setOut(printStream);\r\n        q = em.createQuery(\"Select p.personName from UserInformation p where p.personId = 1 and p.personName = vivek and p.age >=10 and p.age <= 20\");\r\n        q.getResultList();\r\n        expectedQuery[3] = \"Find document: { \\\"_id\\\" : \\\"1\\\" , \\\"PERSON_NAME\\\" : \\\"vivek\\\" , \\\"AGE\\\" : { \\\"$gte\\\" : 10 , \\\"$lte\\\" : 20}}\";\r\n        System.setOut(printStream);\r\n        br = new BufferedReader(new FileReader(\"showQuery.log\"));\r\n        actualQuery = br.readLine();\r\n        if (actualQuery == null)\r\n            fail(\"failed as file is empty\");\r\n        while (actualQuery != null) {\r\n            Assert.assertEquals(expectedQuery[i++], actualQuery);\r\n            actualQuery = br.readLine();\r\n        }\r\n        em.close();\r\n        emf.close();\r\n    } catch (Exception e) {\r\n        logger.info(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.util.keys.FrozenHashKeyIndex.create",
	"Comment": "construct a new key index.it maps each long key to its position in the list.",
	"Method": "FrozenHashKeyIndex create(LongList keys,FrozenHashKeyIndex create,LongCollection keys){\r\n    if (keys instanceof LongList) {\r\n        return create((LongList) keys);\r\n    } else {\r\n        HashKeyIndex index = new HashKeyIndex();\r\n        LongIterator iter = keys.iterator();\r\n        while (iter.hasNext()) {\r\n            index.internId(iter.nextLong());\r\n        }\r\n        return index.frozenCopy();\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.ceilPositive",
	"Comment": "returns the smallest integer greater than or equal to the specified float. this method will only properly ceil floats thatare positive.",
	"Method": "int ceilPositive(float value){\r\n    return (int) (value + CEIL);\r\n}"
}, {
	"Path": "org.lenskit.util.keys.Long2DoubleSortedArrayMap.getValueByIndex",
	"Comment": "get a value by its position in the map. used for optimizing certain operations.",
	"Method": "double getValueByIndex(int i){\r\n    return values[i + keys.getLowerBound()];\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.PersistenceDelegator.contains",
	"Comment": "check if the instance is a managed entity instance belonging to thecurrent persistence context.",
	"Method": "boolean contains(Object entity){\r\n    Node node = getPersistenceCache().getMainCache().getNodeFromCache(entity, getMetadata(entity.getClass()), this);\r\n    return node != null && node.isInState(ManagedState.class);\r\n}"
}, {
	"Path": "com.impetus.kundera.metadata.model.EntityMetadata.addRelationName",
	"Comment": "method to add specific relation name for given relational field.",
	"Method": "void addRelationName(Relation rField){\r\n    if (rField != null && !rField.isRelatedViaJoinTable()) {\r\n        String relationName = getJoinColumnName(rField.getProperty());\r\n        if (rField.getProperty().isAnnotationPresent(PrimaryKeyJoinColumn.class)) {\r\n            relationName = this.getIdAttribute().getName();\r\n        }\r\n        addToRelationNameCollection(relationName);\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.utils.DeepEquals.compareUnordered",
	"Comment": "deeply compare the two sets referenced by dualkey. this method attemptsto quickly determine inequality by length, then hash, and finally does adeepequals on each element if the two sets passed by the prior tests.",
	"Method": "boolean compareUnordered(Collection col1,Collection col2,Set visited){\r\n    if (ProxyHelper.isProxyCollection(col1) || ProxyHelper.isProxyCollection(col2)) {\r\n        return false;\r\n    }\r\n    if (col1.size() != col2.size()) {\r\n        return false;\r\n    }\r\n    int h1 = deepHashCode(col1);\r\n    int h2 = deepHashCode(col2);\r\n    if (h1 != h2) {\r\n        return false;\r\n    }\r\n    List copy = new ArrayList(col2);\r\n    for (Object element1 : col1) {\r\n        int len = copy.size();\r\n        for (int i = 0; i < len; i++) {\r\n            if (deepEquals(element1, copy.get(i), visited)) {\r\n                copy.remove(i);\r\n                break;\r\n            }\r\n        }\r\n        if (len == copy.size()) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.b3log.latke.util.UriTemplates.resolve",
	"Comment": "resolves the specified uri with the specified uri template.",
	"Method": "Map<String, String> resolve(String uri,String uriTemplate){\r\n    final String[] parts = URLs.decode(uri).split(\"/\");\r\n    final String[] templateParts = uriTemplate.split(\"/\");\r\n    if (parts.length != templateParts.length) {\r\n        return null;\r\n    }\r\n    final Map<String, String> ret = new HashMap();\r\n    for (int i = 0; i < parts.length; i++) {\r\n        final String part = parts[i];\r\n        final String templatePart = templateParts[i];\r\n        if (part.equals(templatePart)) {\r\n            continue;\r\n        }\r\n        String name = StringUtils.substringBetween(templatePart, \"{\", \"}\");\r\n        if (StringUtils.isBlank(name)) {\r\n            return null;\r\n        }\r\n        final String templatePartTmp = StringUtils.replace(templatePart, \"{\" + name + \"}\", \"\");\r\n        final String arg = StringUtils.replace(part, templatePartTmp, \"\");\r\n        ret.put(name, arg);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.EntityManagerFactoryImpl.getMetamodel",
	"Comment": "return an instance of metamodel interface for access to the metamodel ofthe persistence unit.",
	"Method": "Metamodel getMetamodel(){\r\n    if (isOpen()) {\r\n        MetamodelImpl metamodel = null;\r\n        for (String pu : persistenceUnits) {\r\n            metamodel = (MetamodelImpl) kunderaMetadata.getApplicationMetadata().getMetamodel(pu);\r\n            if (metamodel != null) {\r\n                return metamodel;\r\n            }\r\n        }\r\n    }\r\n    throw new IllegalStateException(\"Entity manager factory has been closed.\");\r\n}"
}, {
	"Path": "org.b3log.latke.ioc.Bean.resolveCurrentclassFieldDependencies",
	"Comment": "resolves current class field dependencies for the specified reference.",
	"Method": "void resolveCurrentclassFieldDependencies(Object reference){\r\n    for (final FieldInjectionPoint injectionPoint : fieldInjectionPoints) {\r\n        final Object injection = beanManager.getInjectableReference(injectionPoint);\r\n        final Field field = injectionPoint.getAnnotated().getJavaMember();\r\n        try {\r\n            final Field declaredField = proxyClass.getDeclaredField(field.getName());\r\n            if (declaredField.isAnnotationPresent(Inject.class)) {\r\n                try {\r\n                    declaredField.set(reference, injection);\r\n                } catch (final Exception e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n        } catch (final NoSuchFieldException ex) {\r\n            try {\r\n                field.set(reference, injection);\r\n            } catch (final Exception e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.impetus.client.mongodb.MongoDBClient.loadData",
	"Comment": "loads columns from multiple rows restricting results to conditions storedin filterclausequeue.",
	"Method": "List<E> loadData(EntityMetadata entityMetadata,BasicDBObject mongoQuery,List<String> relationNames,BasicDBObject orderBy,int maxResult,int firstResult,boolean isCountQuery,BasicDBObject keys,String results){\r\n    MetamodelImpl metaModel = (MetamodelImpl) kunderaMetadata.getApplicationMetadata().getMetamodel(entityMetadata.getPersistenceUnit());\r\n    AbstractManagedType managedType = (AbstractManagedType) metaModel.entity(entityMetadata.getEntityClazz());\r\n    boolean hasLob = managedType.hasLobAttribute();\r\n    return (List<E>) (!hasLob ? loadQueryData(entityMetadata, mongoQuery, orderBy, maxResult, firstResult, isCountQuery, keys, results) : loadQueryDataGFS(entityMetadata, mongoQuery, orderBy, maxResult, firstResult, isCountQuery));\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.PersistenceDelegator.find",
	"Comment": "todo is it possible to pass all primary keys directly to database client.",
	"Method": "E find(Class<E> entityClass,Object primaryKey,List<E> find,Class<E> entityClass,Object primaryKeys,List<E> find,Class<E> entityClass,Map<String, String> embeddedColumnMap){\r\n    EntityMetadata entityMetadata = getMetadata(entityClass);\r\n    List<E> entities = new ArrayList<E>();\r\n    entities = getClient(entityMetadata).find(entityClass, embeddedColumnMap);\r\n    return entities;\r\n}"
}, {
	"Path": "com.impetus.client.mongodb.query.MongoDBQuery.createRegex",
	"Comment": "generates the regular expression for matching string for like operator.",
	"Method": "String createRegex(String value,boolean ignoreCase){\r\n    if (value == null) {\r\n        throw new IllegalArgumentException(\"String cannot be null\");\r\n    }\r\n    int len = value.length();\r\n    if (len == 0) {\r\n        return \"\";\r\n    }\r\n    StringBuilder sb = new StringBuilder(len * 2);\r\n    if (ignoreCase) {\r\n        sb.append(\"(?i)\");\r\n    }\r\n    sb.append(\"^\");\r\n    for (int i = 0; i < len; i++) {\r\n        char c = value.charAt(i);\r\n        if (\"[](){}.*+?$^|#\\\\\".indexOf(c) != -1) {\r\n            sb.append(\"\\\\\");\r\n        }\r\n        sb.append(c);\r\n    }\r\n    sb.append(\"$\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.jupiter.transport.netty.handler.IdleStateChecker.getAllIdleTimeInMillis",
	"Comment": "return the allidletime that was given when instance this class in milliseconds.",
	"Method": "long getAllIdleTimeInMillis(){\r\n    return allIdleTimeMillis;\r\n}"
}, {
	"Path": "com.fishercoder.solutions._600.findIntegers",
	"Comment": "brute force is definitely correct, but too time consuming and resulted in tle.",
	"Method": "int findIntegers(int num,int findIntegers,int num){\r\n    int answer = 0;\r\n    for (int i = 0; i <= num; i++) {\r\n        if (hasConsecutiveOnes(i)) {\r\n            answer++;\r\n        }\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "org.b3log.latke.util.Strings.containsIgnoreCase",
	"Comment": "determines whether the specified strings contains the specified string, ignoring case considerations.",
	"Method": "boolean containsIgnoreCase(String string,String[] strings){\r\n    if (null == strings) {\r\n        return false;\r\n    }\r\n    return Arrays.stream(strings).anyMatch(str -> StringUtils.equalsIgnoreCase(string, str));\r\n}"
}, {
	"Path": "org.lenskit.util.ClassDirectory.getPackages",
	"Comment": "get the packages that contain a class with the specified name.",
	"Method": "Set<String> getPackages(String name){\r\n    return directory.get(name);\r\n}"
}, {
	"Path": "org.jupiter.transport.netty.NativeSupport.isNativeKQueueAvailable",
	"Comment": "the native socket transport for bsd systems such as macos using jni.",
	"Method": "boolean isNativeKQueueAvailable(){\r\n    return KQueue.isAvailable();\r\n}"
}, {
	"Path": "com.fishercoder.solutions._390.lastRemaining_brute_force_TLE",
	"Comment": "i tried brute force, all producing the correct output, but got tle by oj.",
	"Method": "int lastRemaining_brute_force_TLE(int n){\r\n    List<Integer> list = new ArrayList();\r\n    for (int i = 0; i < n; i++) {\r\n        list.add(i + 1);\r\n    }\r\n    boolean forward = true;\r\n    while (list.size() > 1) {\r\n        int size = list.size() / 2;\r\n        if (list.size() == 1) {\r\n            return list.get(0);\r\n        }\r\n        if (forward) {\r\n            if (list.size() == 1) {\r\n                return list.get(0);\r\n            }\r\n            for (int i = 0; i <= size && i < list.size(); i++) {\r\n                list.remove(i);\r\n            }\r\n            forward = false;\r\n        } else {\r\n            if (list.size() == 1) {\r\n                return list.get(0);\r\n            }\r\n            for (int i = list.size() - 1, count = 0; i >= 0 && count <= size; count++) {\r\n                list.remove(i);\r\n                i -= 2;\r\n            }\r\n            forward = true;\r\n        }\r\n    }\r\n    return list.get(0);\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.schemamanager.CassandraSchemaManager.update",
	"Comment": "update method update schema and table for the list of tableinfos.",
	"Method": "void update(List<TableInfo> tableInfos){\r\n    try {\r\n        createOrUpdateKeyspace(tableInfos);\r\n    } catch (Exception ex) {\r\n        log.error(\"Error occurred while creating {}, Caused by: .\", databaseName, ex);\r\n        throw new SchemaGenerationException(ex);\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.resources.ApplicationResource.closeApplication",
	"Comment": "handler for delete method requests for this resource closes emf and\tremoves application token along with from repository",
	"Method": "Response closeApplication(String applicationToken,HttpHeaders headers){\r\n    String mediaType = headers != null && headers.getRequestHeaders().containsKey(\"Content-type\") ? headers.getRequestHeader(\"Content-type\").get(0) : MediaType.APPLICATION_JSON;\r\n    mediaType = mediaType.equalsIgnoreCase(MediaType.APPLICATION_XML) ? MediaType.APPLICATION_XML : MediaType.APPLICATION_JSON;\r\n    if (log.isDebugEnabled())\r\n        log.debug(\"DELETE: Application Token:\" + applicationToken);\r\n    EntityManagerFactory emf = EMFRepository.INSTANCE.getEMF(applicationToken);\r\n    if (emf == null) {\r\n        log.warn(\"DELETE: Application Token:\" + applicationToken + \" doesn't exist and hence can't be closed\");\r\n        return Response.serverError().build();\r\n    }\r\n    EMFRepository.INSTANCE.removeEMF(applicationToken);\r\n    return Response.ok(new String(ResponseCode.DELETE_AT_SUCCESS), mediaType).build();\r\n}"
}, {
	"Path": "org.b3log.latke.service.LangPropsService.getAll",
	"Comment": "gets all language properties as a map by the specified locale.",
	"Method": "Map<String, String> getAll(Locale locale){\r\n    Map<String, String> ret = LANGS.get(locale);\r\n    if (null == ret) {\r\n        ret = new HashMap();\r\n        ResourceBundle langBundle;\r\n        try {\r\n            langBundle = ResourceBundle.getBundle(Keys.LANGUAGE, locale);\r\n        } catch (final MissingResourceException e) {\r\n            LOGGER.log(Level.WARN, \"{0}, using default locale[{1}] instead\", new Object[] { e.getMessage(), Latkes.getLocale() });\r\n            try {\r\n                langBundle = ResourceBundle.getBundle(Keys.LANGUAGE, Latkes.getLocale());\r\n            } catch (final MissingResourceException ex) {\r\n                LOGGER.log(Level.WARN, \"{0}, using default lang.properties instead\", new Object[] { e.getMessage() });\r\n                langBundle = ResourceBundle.getBundle(Keys.LANGUAGE);\r\n            }\r\n        }\r\n        final Enumeration<String> keys = langBundle.getKeys();\r\n        while (keys.hasMoreElements()) {\r\n            final String key = keys.nextElement();\r\n            final String value = replaceVars(langBundle.getString(key));\r\n            ret.put(key, value);\r\n        }\r\n        LANGS.put(locale, ret);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.lerpAngleDeg",
	"Comment": "linearly interpolates between two angles in degrees. takes into account that angles wrap at 360 degrees and always takesthe direction with the smallest delta angle.",
	"Method": "float lerpAngleDeg(float fromDegrees,float toDegrees,float progress){\r\n    float delta = ((toDegrees - fromDegrees + 360 + 180) % 360) - 180;\r\n    return (fromDegrees + delta * progress + 360) % 360;\r\n}"
}, {
	"Path": "org.b3log.latke.Latkes.setStaticResourceVersion",
	"Comment": "sets static resource version with the specified static resource version.",
	"Method": "void setStaticResourceVersion(String staticResourceVersion){\r\n    Latkes.staticResourceVersion = staticResourceVersion;\r\n}"
}, {
	"Path": "com.impetus.kundera.metadata.MetadataUtils.onCheckValidationConstraints",
	"Comment": "returns true if an entity contains attributes with validation constraintsenabled",
	"Method": "boolean onCheckValidationConstraints(Field attribute){\r\n    return attribute.isAnnotationPresent(AssertFalse.class) || attribute.isAnnotationPresent(AssertTrue.class) || attribute.isAnnotationPresent(DecimalMax.class) || attribute.isAnnotationPresent(DecimalMin.class) || attribute.isAnnotationPresent(Digits.class) || attribute.isAnnotationPresent(Future.class) || attribute.isAnnotationPresent(Max.class) || attribute.isAnnotationPresent(Min.class) || attribute.isAnnotationPresent(NotNull.class) || attribute.isAnnotationPresent(Null.class) || attribute.isAnnotationPresent(Past.class) || attribute.isAnnotationPresent(Pattern.class) || attribute.isAnnotationPresent(Size.class);\r\n}"
}, {
	"Path": "org.lenskit.data.ratings.Ratings.userRatingVector",
	"Comment": "construct a rating vector that contains the ratings provided for eachitem. if all ratings in ratings are by the same user, thenthis will be a valid user rating vector.",
	"Method": "Long2DoubleMap userRatingVector(Collection<Rating> ratings,Long2DoubleMap userRatingVector,ObjectStream<? extends Rating> ratings){\r\n    return extractVector(ratings.iterator(), IdExtractor.ITEM, -1);\r\n}"
}, {
	"Path": "com.jvmtop.view.AbstractConsoleView.join",
	"Comment": "joins the given list of strings using the given delimiter delim",
	"Method": "String join(List<String> list,String delim){\r\n    StringBuilder sb = new StringBuilder();\r\n    String loopDelim = \"\";\r\n    for (String s : list) {\r\n        sb.append(loopDelim);\r\n        sb.append(s);\r\n        loopDelim = delim;\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.PersistenceDelegator.detach",
	"Comment": "remove the given entity from the persistence context, causing a managedentity to become detached.",
	"Method": "void detach(Object entity){\r\n    Node node = getPersistenceCache().getMainCache().getNodeFromCache(entity, getMetadata(entity.getClass()), this);\r\n    if (node != null) {\r\n        node.detach();\r\n    }\r\n}"
}, {
	"Path": "org.json.JSONPointer.toURIFragment",
	"Comment": "returns a string representing the jsonpointer path value using urifragment identifier representation",
	"Method": "String toURIFragment(){\r\n    try {\r\n        StringBuilder rval = new StringBuilder(\"#\");\r\n        for (String token : this.refTokens) {\r\n            rval.append('/').append(URLEncoder.encode(token, ENCODING));\r\n        }\r\n        return rval.toString();\r\n    } catch (UnsupportedEncodingException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.client.ClientResolver.instantiateClientFactory",
	"Comment": "creates new instance of client factory for given persistence unit.",
	"Method": "ClientFactory instantiateClientFactory(String persistenceUnit,Map<String, Object> puProperties,KunderaMetadata kunderaMetadata){\r\n    ClientFactory clientFactory = null;\r\n    logger.info(\"Initializing client factory for: \" + persistenceUnit);\r\n    PersistenceUnitMetadata persistenceUnitMetadata = kunderaMetadata.getApplicationMetadata().getPersistenceUnitMetadata(persistenceUnit);\r\n    String kunderaClientFactory = puProperties != null ? (String) puProperties.get(PersistenceProperties.KUNDERA_CLIENT_FACTORY) : null;\r\n    if (kunderaClientFactory == null) {\r\n        kunderaClientFactory = persistenceUnitMetadata.getProperties().getProperty(PersistenceProperties.KUNDERA_CLIENT_FACTORY);\r\n    }\r\n    if (kunderaClientFactory == null) {\r\n        throw new ClientResolverException(\"<kundera.client.lookup.class> is missing from persistence.xml, please provide specific client factory. e.g., <property name=\\\"kundera.client.lookup.class\\\" value=\\\"com.impetus.client.cassandra.pelops.PelopsClientFactory\\\" />\");\r\n    }\r\n    try {\r\n        clientFactory = (ClientFactory) Class.forName(kunderaClientFactory).newInstance();\r\n        Method m = GenericClientFactory.class.getDeclaredMethod(\"setPersistenceUnit\", String.class);\r\n        if (!m.isAccessible()) {\r\n            m.setAccessible(true);\r\n        }\r\n        m.invoke(clientFactory, persistenceUnit);\r\n        m = GenericClientFactory.class.getDeclaredMethod(\"setExternalProperties\", Map.class);\r\n        if (!m.isAccessible()) {\r\n            m.setAccessible(true);\r\n        }\r\n        m.invoke(clientFactory, puProperties);\r\n        m = GenericClientFactory.class.getDeclaredMethod(\"setKunderaMetadata\", KunderaMetadata.class);\r\n        if (!m.isAccessible()) {\r\n            m.setAccessible(true);\r\n        }\r\n        m.invoke(clientFactory, kunderaMetadata);\r\n    } catch (InstantiationException e) {\r\n        onError(e);\r\n    } catch (IllegalAccessException e) {\r\n        onError(e);\r\n    } catch (ClassNotFoundException e) {\r\n        onError(e);\r\n    } catch (SecurityException e) {\r\n        onError(e);\r\n    } catch (NoSuchMethodException e) {\r\n        onError(e);\r\n    } catch (IllegalArgumentException e) {\r\n        onError(e);\r\n    } catch (InvocationTargetException e) {\r\n        onError(e);\r\n    }\r\n    if (clientFactory == null) {\r\n        logger.error(\"Client Factory Not Configured For Specified Client Type : \");\r\n        throw new ClientResolverException(\"Client Factory Not Configured For Specified Client Type.\");\r\n    }\r\n    logger.info(\"Finishing factory initialization\");\r\n    return clientFactory;\r\n}"
}, {
	"Path": "org.b3log.latke.repository.jdbc.util.JdbcRepositories.getKeys",
	"Comment": "gets keys of the repository specified by the given repository name.",
	"Method": "List<FieldDefinition> getKeys(String repositoryName){\r\n    final List<RepositoryDefinition> repositoryDefs = getRepositoryDefinitions();\r\n    for (final RepositoryDefinition repositoryDefinition : repositoryDefs) {\r\n        if (StringUtils.equals(repositoryName, repositoryDefinition.getName())) {\r\n            return repositoryDefinition.getKeys();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.jupiter.transport.netty.handler.IdleStateChecker.getWriterIdleTimeInMillis",
	"Comment": "return the writeridletime that was given when instance this class in milliseconds.",
	"Method": "long getWriterIdleTimeInMillis(){\r\n    return writerIdleTimeMillis;\r\n}"
}, {
	"Path": "org.b3log.latke.servlet.handler.RouteHandler.route",
	"Comment": "routes the request specified by the given uri pattern, context handler meta, request uri and http method.",
	"Method": "MatchResult route(String uriPattern,String requestURI,String method,ContextHandlerMeta contextHandlerMeta){\r\n    final Map<String, String> resolveResult = UriTemplates.resolve(requestURI, uriPattern);\r\n    if (null == resolveResult) {\r\n        return null;\r\n    }\r\n    final MatchResult ret = new MatchResult(contextHandlerMeta, requestURI, method, uriPattern);\r\n    ret.setPathVars(resolveResult);\r\n    return ret;\r\n}"
}, {
	"Path": "com.impetus.kundera.query.QueryImpl.getEntityMetadata",
	"Comment": "returns entity metadata, in case of native query mapped class is presentwithin application metadata.",
	"Method": "EntityMetadata getEntityMetadata(){\r\n    return kunderaQuery.getEntityMetadata();\r\n}"
}, {
	"Path": "com.impetus.kundera.metadata.model.MetamodelImpl.getEmbeddables",
	"Comment": "custom implementation to offer map of embeddables available for givenentitytype.",
	"Method": "Set<EmbeddableType<?>> getEmbeddables(Map<String, EmbeddableType> getEmbeddables,Class clazz){\r\n    Map<String, EmbeddableType> embeddableAttibutes = new HashMap<String, EmbeddableType>();\r\n    if (entityTypes != null) {\r\n        EntityType entity = entityTypes.get(clazz);\r\n        Iterator<Attribute> iter = entity.getAttributes().iterator();\r\n        while (iter.hasNext()) {\r\n            Attribute attribute = iter.next();\r\n            if (isEmbeddable(((AbstractAttribute) attribute).getBindableJavaType())) {\r\n                embeddableAttibutes.put(attribute.getName(), embeddable(((AbstractAttribute) attribute).getBindableJavaType()));\r\n            }\r\n        }\r\n    }\r\n    return embeddableAttibutes;\r\n}"
}, {
	"Path": "org.json.CDL.rowToJSONObject",
	"Comment": "produce a jsonobject from a row of comma delimited text, using aparallel jsonarray of strings to provides the names of the elements.",
	"Method": "JSONObject rowToJSONObject(JSONArray names,JSONTokener x){\r\n    JSONArray ja = rowToJSONArray(x);\r\n    return ja != null ? ja.toJSONObject(names) : null;\r\n}"
}, {
	"Path": "org.json.JSONObject.append",
	"Comment": "append values to the array under a key. if the key does not exist in thejsonobject, then the key is put in the jsonobject with its value being ajsonarray containing the value parameter. if the key was alreadyassociated with a jsonarray, then the value parameter is appended to it.",
	"Method": "JSONObject append(String key,Object value){\r\n    testValidity(value);\r\n    Object object = this.opt(key);\r\n    if (object == null) {\r\n        this.put(key, new JSONArray().put(value));\r\n    } else if (object instanceof JSONArray) {\r\n        this.put(key, ((JSONArray) object).put(value));\r\n    } else {\r\n        throw new JSONException(\"JSONObject[\" + key + \"] is not a JSONArray.\");\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.impetus.kundera.client.cassandra.dsdriver.DSClientUtilities.assign",
	"Comment": "assign value to provided entity instance else return value of mapped javatype.",
	"Method": "Object assign(Row row,Object entity,EntityMetadata metadata,Name dataType,EntityType entityType,String columnName,Field member,MetamodelImpl metamodel){\r\n    String fieldName = null;\r\n    if (metadata != null) {\r\n        if (columnName.equals(((AbstractAttribute) metadata.getIdAttribute()).getJPAColumnName())) {\r\n            entity = KunderaCoreUtils.initialize(metadata, entity, null);\r\n            fieldName = metadata.getIdAttribute().getName();\r\n            member = (Field) metadata.getIdAttribute().getJavaMember();\r\n        } else if (metadata.getRelationNames() == null || !metadata.getRelationNames().contains(columnName)) {\r\n            fieldName = metadata.getFieldName(columnName);\r\n            if (fieldName != null && entityType != null) {\r\n                entity = KunderaCoreUtils.initialize(metadata, entity, null);\r\n                member = (Field) entityType.getAttribute(fieldName).getJavaMember();\r\n            }\r\n        }\r\n    }\r\n    Object retVal = null;\r\n    if (row.isNull(columnName)) {\r\n        return entity;\r\n    }\r\n    switch(dataType) {\r\n        case BLOB:\r\n        case CUSTOM:\r\n            retVal = row.getBytes(columnName);\r\n            if (member != null && retVal != null && entity != null) {\r\n                PropertyAccessorHelper.set(entity, member, ((ByteBuffer) retVal).array());\r\n            }\r\n            break;\r\n        case BOOLEAN:\r\n            retVal = row.getBool(columnName);\r\n            setFieldValue(entity, member, retVal);\r\n            break;\r\n        case BIGINT:\r\n        case COUNTER:\r\n            retVal = row.getLong(columnName);\r\n            setFieldValue(entity, member, retVal);\r\n            break;\r\n        case DECIMAL:\r\n            retVal = row.getDecimal(columnName);\r\n            setFieldValue(entity, member, retVal);\r\n            break;\r\n        case DOUBLE:\r\n            retVal = row.getDouble(columnName);\r\n            setFieldValue(entity, member, retVal);\r\n            break;\r\n        case FLOAT:\r\n            retVal = row.getFloat(columnName);\r\n            setFieldValue(entity, member, retVal);\r\n            break;\r\n        case INET:\r\n            retVal = row.getInet(columnName);\r\n            setFieldValue(entity, member, retVal);\r\n            break;\r\n        case INT:\r\n            retVal = row.getInt(columnName);\r\n            retVal = setIntValue(member, retVal);\r\n            setFieldValue(entity, member, retVal);\r\n            break;\r\n        case ASCII:\r\n        case TEXT:\r\n        case VARCHAR:\r\n            retVal = row.getString(columnName);\r\n            retVal = setTextValue(entity, member, retVal);\r\n            setFieldValue(entity, member, retVal);\r\n            break;\r\n        case TIMESTAMP:\r\n            retVal = row.getTimestamp(columnName);\r\n            if (retVal != null && member != null)\r\n                retVal = CassandraDataTranslator.decompose(member.getType(), ByteBufferUtil.bytes(((Date) retVal).getTime()).array(), true);\r\n            setFieldValue(entity, member, retVal);\r\n            break;\r\n        case VARINT:\r\n            retVal = row.getVarint(columnName);\r\n            setFieldValue(entity, member, retVal);\r\n            break;\r\n        case UUID:\r\n        case TIMEUUID:\r\n            retVal = row.getUUID(columnName);\r\n            setFieldValue(entity, member, retVal);\r\n            break;\r\n        case LIST:\r\n            Class listAttributeTypeClass = PropertyAccessorHelper.getGenericClass(member);\r\n            Class listClazz = null;\r\n            boolean isElementCollectionList = false;\r\n            if (listAttributeTypeClass.isAssignableFrom(byte[].class)) {\r\n                listClazz = ByteBuffer.class;\r\n            } else if (listAttributeTypeClass.isAnnotationPresent(Embeddable.class)) {\r\n                isElementCollectionList = true;\r\n                listClazz = UDTValue.class;\r\n            } else {\r\n                listClazz = listAttributeTypeClass;\r\n            }\r\n            retVal = row.getList(columnName, listClazz);\r\n            Collection resultList = new ArrayList();\r\n            if (isElementCollectionList) {\r\n                Iterator collectionItems = ((Collection) retVal).iterator();\r\n                while (collectionItems.hasNext()) {\r\n                    resultList.add(setUDTValue(entity, listAttributeTypeClass, (UDTValue) collectionItems.next(), metamodel));\r\n                }\r\n            }\r\n            if (retVal != null && !((List) retVal).isEmpty() && !isElementCollectionList) {\r\n                if (listAttributeTypeClass.isAssignableFrom(byte[].class)) {\r\n                    setFieldValue(entity, member, CassandraDataTranslator.marshalCollection(BytesType.class, (Collection) retVal, listAttributeTypeClass, ArrayList.class));\r\n                } else {\r\n                    Iterator collectionItems = ((Collection) retVal).iterator();\r\n                    while (collectionItems.hasNext()) {\r\n                        resultList.add(collectionItems.next());\r\n                    }\r\n                    setFieldValue(entity, member, resultList);\r\n                }\r\n            } else if (retVal != null && !((Collection) retVal).isEmpty()) {\r\n                setFieldValue(entity, member, resultList);\r\n            }\r\n            break;\r\n        case SET:\r\n            Class setAttributeTypeClass = PropertyAccessorHelper.getGenericClass(member);\r\n            Class setClazz = null;\r\n            boolean isElementCollectionSet = false;\r\n            if (setAttributeTypeClass.isAssignableFrom(byte[].class)) {\r\n                setClazz = ByteBuffer.class;\r\n            } else if (setAttributeTypeClass.isAnnotationPresent(Embeddable.class)) {\r\n                isElementCollectionSet = true;\r\n                setClazz = UDTValue.class;\r\n            } else {\r\n                setClazz = setAttributeTypeClass;\r\n            }\r\n            retVal = row.getSet(columnName, setClazz);\r\n            Collection resultSet = new HashSet();\r\n            if (isElementCollectionSet) {\r\n                Iterator collectionItems = ((Collection) retVal).iterator();\r\n                while (collectionItems.hasNext()) {\r\n                    resultSet.add(setUDTValue(entity, setAttributeTypeClass, (UDTValue) collectionItems.next(), metamodel));\r\n                }\r\n            }\r\n            if (retVal != null && !((Set) retVal).isEmpty() && !isElementCollectionSet) {\r\n                if (setAttributeTypeClass.isAssignableFrom(byte[].class)) {\r\n                    setFieldValue(entity, member, CassandraDataTranslator.marshalCollection(BytesType.class, (Collection) retVal, setAttributeTypeClass, HashSet.class));\r\n                } else {\r\n                    Iterator collectionItems = ((Collection) retVal).iterator();\r\n                    while (collectionItems.hasNext()) {\r\n                        resultSet.add(collectionItems.next());\r\n                    }\r\n                    setFieldValue(entity, member, resultSet);\r\n                }\r\n            } else if (retVal != null && !((Collection) retVal).isEmpty()) {\r\n                setFieldValue(entity, member, resultSet);\r\n            }\r\n            break;\r\n        case MAP:\r\n            List<Class<?>> mapGenericClasses = PropertyAccessorHelper.getGenericClasses(member);\r\n            if (mapGenericClasses.isEmpty()) {\r\n                break;\r\n            }\r\n            Class keyClass = CassandraValidationClassMapper.getValidationClassInstance(mapGenericClasses.get(0), true);\r\n            Class valueClass = CassandraValidationClassMapper.getValidationClassInstance(mapGenericClasses.get(1), true);\r\n            Class mapValueClazz = null;\r\n            boolean isElementCollectionMap = false;\r\n            if (mapGenericClasses.get(1).isAssignableFrom(byte[].class)) {\r\n                mapValueClazz = ByteBuffer.class;\r\n            } else if (mapGenericClasses.get(1).isAnnotationPresent(Embeddable.class)) {\r\n                isElementCollectionMap = true;\r\n                mapValueClazz = UDTValue.class;\r\n            } else {\r\n                mapValueClazz = mapGenericClasses.get(1);\r\n            }\r\n            retVal = row.getMap(columnName, mapGenericClasses.get(0).isAssignableFrom(byte[].class) ? ByteBuffer.class : mapGenericClasses.get(0), mapValueClazz);\r\n            Map resultMap = new HashMap();\r\n            if (isElementCollectionMap) {\r\n                Iterator keys = ((Map) retVal).keySet().iterator();\r\n                while (keys.hasNext()) {\r\n                    Object keyValue = keys.next();\r\n                    resultMap.put(keyValue, setUDTValue(entity, mapGenericClasses.get(1), (UDTValue) ((Map) retVal).get(keyValue), metamodel));\r\n                }\r\n            }\r\n            boolean isByteBuffer = mapGenericClasses.get(0).isAssignableFrom(byte[].class) || mapGenericClasses.get(1).isAssignableFrom(byte[].class);\r\n            if (retVal != null && !((Map) retVal).isEmpty() && !isElementCollectionMap) {\r\n                if (isByteBuffer) {\r\n                    setFieldValue(entity, member, CassandraDataTranslator.marshalMap(mapGenericClasses, keyClass, valueClass, (Map) retVal));\r\n                } else {\r\n                    Iterator keys = ((Map) retVal).keySet().iterator();\r\n                    while (keys.hasNext()) {\r\n                        Object keyValue = keys.next();\r\n                        resultMap.put(keyValue, ((Map) retVal).get(keyValue));\r\n                    }\r\n                    setFieldValue(entity, member, resultMap);\r\n                }\r\n            } else if (retVal != null && !((Map) retVal).isEmpty()) {\r\n                setFieldValue(entity, member, resultMap);\r\n            }\r\n            break;\r\n        case UDT:\r\n            retVal = row.getUDTValue(columnName);\r\n            setFieldValue(entity, member, retVal != null ? setUDTValue(entity, member.getType(), (UDTValue) retVal, metamodel) : null);\r\n            break;\r\n    }\r\n    return entity != null ? entity : retVal;\r\n}"
}, {
	"Path": "org.b3log.latke.util.Times.isSameDay",
	"Comment": "determines whether the specified date1 is the same day with the specified date2.",
	"Method": "boolean isSameDay(Date date1,Date date2){\r\n    final Calendar cal1 = Calendar.getInstance();\r\n    cal1.setTime(date1);\r\n    final Calendar cal2 = Calendar.getInstance();\r\n    cal2.setTime(date2);\r\n    return cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE);\r\n}"
}, {
	"Path": "org.b3log.latke.util.Stopwatchs.getRecentRunning",
	"Comment": "gets the recent running stopwatch with the specified parent stopwatch.",
	"Method": "Stopwatch getRecentRunning(Stopwatch parent){\r\n    if (null == parent) {\r\n        return null;\r\n    }\r\n    final List<Stopwatch> leaves = parent.getLeaves();\r\n    if (leaves.isEmpty()) {\r\n        if (parent.isRunning()) {\r\n            return parent;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    for (int i = leaves.size() - 1; i > -1; i--) {\r\n        final Stopwatch leaf = leaves.get(i);\r\n        if (leaf.isRunning()) {\r\n            return getRecentRunning(leaf);\r\n        } else {\r\n            continue;\r\n        }\r\n    }\r\n    return parent;\r\n}"
}, {
	"Path": "com.asha.vrlib.model.MDQuaternion.getRoll",
	"Comment": "get the roll euler angle in degrees, which is the rotation around the z axis. requires that this quaternion is normalized.",
	"Method": "float getRoll(){\r\n    return getRollRad() * MathUtils.radiansToDegrees;\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.resources.CRUDResource.update",
	"Comment": "handler for put method requests for this resource updates an entity into datastore",
	"Method": "Response update(String sessionToken,String entityClassName,String input,HttpHeaders headers){\r\n    sessionToken = sessionToken.replaceAll(\"^\\\"|\\\"$\", \"\");\r\n    input = input.replaceAll(\"^\\\"|\\\"$\", \"\");\r\n    log.debug(\"PUT: sessionToken:\" + sessionToken);\r\n    log.debug(\"PUT: entityClassName:\" + entityClassName);\r\n    String mediaType = headers != null && headers.getRequestHeaders().containsKey(\"Content-type\") ? headers.getRequestHeader(\"Content-type\").get(0) : MediaType.APPLICATION_JSON;\r\n    mediaType = mediaType.equalsIgnoreCase(MediaType.APPLICATION_XML) ? MediaType.APPLICATION_XML : MediaType.APPLICATION_JSON;\r\n    log.debug(\"POST: Media Type:\" + mediaType);\r\n    Object output;\r\n    Class<?> entityClass;\r\n    Object entity;\r\n    EntityMetadata entityMetadata = null;\r\n    try {\r\n        EntityManager em = EMRepository.INSTANCE.getEM(sessionToken);\r\n        entityClass = EntityUtils.getEntityClass(entityClassName, em);\r\n        log.debug(\"PUT: entityClass: \" + entityClass);\r\n        entityMetadata = EntityUtils.getEntityMetaData(entityClass.getSimpleName(), em);\r\n        entity = JAXBUtils.toObject(input, entityClass, mediaType);\r\n        output = em.merge(entity);\r\n    } catch (Exception e) {\r\n        log.error(e.getMessage());\r\n        return Response.serverError().build();\r\n    }\r\n    if (output == null) {\r\n        return Response.notModified().build();\r\n    }\r\n    output = JAXBUtils.toString(output, mediaType);\r\n    if (mediaType.equalsIgnoreCase(MediaType.APPLICATION_JSON)) {\r\n        return Response.ok(ResponseBuilder.buildOutput(entityClass, entityMetadata, output), mediaType).build();\r\n    } else {\r\n        return Response.ok(output.toString(), mediaType).build();\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.util.describe.Descriptions.hashWriter",
	"Comment": "create a description writer for a particular hash function.",
	"Method": "HashDescriptionWriter hashWriter(HashFunction func){\r\n    return new HashDescriptionWriter(func.newHasher());\r\n}"
}, {
	"Path": "com.uber.profiling.util.SparkUtils.probeAppId",
	"Comment": "try to get application id by match regex in class path or system property",
	"Method": "String probeAppId(String appIdRegex){\r\n    String appId = System.getProperty(\"spark.app.id\");\r\n    if (appId == null || appId.isEmpty()) {\r\n        String classPath = ProcessUtils.getJvmClassPath();\r\n        List<String> appIdCandidates = StringUtils.extractByRegex(classPath, appIdRegex);\r\n        if (!appIdCandidates.isEmpty()) {\r\n            appId = appIdCandidates.get(0);\r\n        }\r\n    }\r\n    if (appId == null || appId.isEmpty()) {\r\n        for (String entry : ProcessUtils.getJvmInputArguments()) {\r\n            List<String> appIdCandidates = StringUtils.extractByRegex(entry, appIdRegex);\r\n            if (!appIdCandidates.isEmpty()) {\r\n                appId = appIdCandidates.get(0);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return appId;\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.index.CassandraIndexHelper.isInvertedIndexingApplicable",
	"Comment": "checks whether inverted indexing is applicable for a given entity whosemetadata is passed as parameter",
	"Method": "boolean isInvertedIndexingApplicable(EntityMetadata m,boolean useSecondryIndex){\r\n    boolean invertedIndexingApplicable = useSecondryIndex && CassandraPropertyReader.csmd.isInvertedIndexingEnabled(m.getSchema()) && m.getType().isSuperColumnFamilyMetadata() && !m.isCounterColumnType();\r\n    return invertedIndexingApplicable;\r\n}"
}, {
	"Path": "com.koloboke.collect.impl.hash.HashConfigWrapper.minCapacity",
	"Comment": "computes hash table capacity for the given size and max load of this config.",
	"Method": "int minCapacity(int size,long minCapacity,long size){\r\n    return maxLoadInverse.scaleUpper(size);\r\n}"
}, {
	"Path": "com.google.android.apps.muzei.render.GLTextureView.on",
	"Comment": "this method is part of the surfaceholder.callback interface, and isnot normally called or subclassed by clients of glsurfaceview.",
	"Method": "void on(SurfaceHolder holder){\r\n    mGLThread.surfaceCreated();\r\n}"
}, {
	"Path": "org.lenskit.util.keys.KeyedObjectMapBuilder.containsKey",
	"Comment": "query whether an object with the specified key has been added.",
	"Method": "boolean containsKey(long key){\r\n    return posMap.containsKey(key);\r\n}"
}, {
	"Path": "com.impetus.client.mongodb.schemamanager.MongoDBSchemaManager.validate",
	"Comment": "validate method validate schema and table for the list of tableinfos.",
	"Method": "void validate(List<TableInfo> tableInfos){\r\n    db = mongo.getDB(databaseName);\r\n    if (db == null) {\r\n        logger.error(\"Database \" + databaseName + \"does not exist\");\r\n        throw new SchemaGenerationException(\"database \" + databaseName + \"does not exist\", \"mongoDb\", databaseName);\r\n    } else {\r\n        for (TableInfo tableInfo : tableInfos) {\r\n            if (tableInfo.getLobColumnInfo().isEmpty()) {\r\n                if (!db.collectionExists(tableInfo.getTableName())) {\r\n                    logger.error(\"Collection \" + tableInfo.getTableName() + \"does not exist in db \" + db.getName());\r\n                    throw new SchemaGenerationException(\"Collection \" + tableInfo.getTableName() + \" does not exist in db \" + db.getName(), \"mongoDb\", databaseName, tableInfo.getTableName());\r\n                }\r\n            } else {\r\n                checkMultipleLobs(tableInfo);\r\n                if (!db.collectionExists(tableInfo.getTableName() + MongoDBUtils.FILES)) {\r\n                    logger.error(\"Collection \" + tableInfo.getTableName() + MongoDBUtils.FILES + \"does not exist in db \" + db.getName());\r\n                    throw new SchemaGenerationException(\"Collection \" + tableInfo.getTableName() + \" does not exist in db \" + db.getName(), \"mongoDb\", databaseName, tableInfo.getTableName());\r\n                }\r\n                if (!db.collectionExists(tableInfo.getTableName() + MongoDBUtils.CHUNKS)) {\r\n                    logger.error(\"Collection \" + tableInfo.getTableName() + MongoDBUtils.CHUNKS + \"does not exist in db \" + db.getName());\r\n                    throw new SchemaGenerationException(\"Collection \" + tableInfo.getTableName() + \" does not exist in db \" + db.getName(), \"mongoDb\", databaseName, tableInfo.getTableName());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.query.ResultIterator.appendWhereClauseWithScroll",
	"Comment": "appends where claues and prepare for next fetch. method to be called incase cql3 enabled.",
	"Method": "String appendWhereClauseWithScroll(String parsedQuery){\r\n    String queryWithoutLimit = parsedQuery.replaceAll(parsedQuery.substring(parsedQuery.lastIndexOf(CQLTranslator.LIMIT), parsedQuery.length()), \"\");\r\n    CQLTranslator translator = new CQLTranslator();\r\n    final String tokenCondition = prepareNext(translator, queryWithoutLimit);\r\n    StringBuilder builder = new StringBuilder(queryWithoutLimit);\r\n    if (tokenCondition != null) {\r\n        if (query.getKunderaQuery().getFilterClauseQueue().isEmpty()) {\r\n            builder.append(CQLTranslator.ADD_WHERE_CLAUSE);\r\n        } else {\r\n            builder.append(CQLTranslator.AND_CLAUSE);\r\n        }\r\n        builder.append(tokenCondition);\r\n    }\r\n    String replaceQuery = replaceAndAppendLimit(builder.toString());\r\n    builder.replace(0, builder.toString().length(), replaceQuery);\r\n    translator.buildFilteringClause(builder);\r\n    return checkOnEmptyResult() && tokenCondition == null ? null : builder.toString();\r\n}"
}, {
	"Path": "com.impetus.kundera.tests.entities.PersonDetailAnnotationPolyglotTest.testAnnotateforCassToMongo",
	"Comment": "test method for testing polyglot between mongodb and cassandra",
	"Method": "void testAnnotateforCassToMongo(){\r\n    Map propertyMap = new HashMap();\r\n    propertyMap.put(PersistenceProperties.KUNDERA_DDL_AUTO_PREPARE, \"create-drop\");\r\n    EntityManagerFactory emfCass = Persistence.createEntityManagerFactory(\"noAnnotationAddCassandra\", propertyMap);\r\n    EntityManager emCass = emfCass.createEntityManager();\r\n    PersonDetailClassMap p = new PersonDetailClassMap();\r\n    p.setPersonId(\"1\");\r\n    p.setFirstName(\"Chhavi\");\r\n    p.setLastName(\"Gangwal\");\r\n    emCass.persist(p);\r\n    emCass.clear();\r\n    PersonDetailClassMap found = emCass.find(PersonDetailClassMap.class, \"1\");\r\n    Assert.assertNotNull(found);\r\n    Assert.assertEquals(\"1\", found.getPersonId());\r\n    Assert.assertEquals(\"Chhavi\", found.getFirstName());\r\n    Assert.assertEquals(\"Gangwal\", found.getLastName());\r\n    emCass.close();\r\n    emfCass.close();\r\n    EntityManagerFactory emfMongo = Persistence.createEntityManagerFactory(\"noAnnotationAddMongo\", propertyMap);\r\n    EntityManager emMongo = emfMongo.createEntityManager();\r\n    emMongo.persist(found);\r\n    PersonDetailClassMap foundMongo = emMongo.find(PersonDetailClassMap.class, \"1\");\r\n    Assert.assertNotNull(foundMongo);\r\n    Assert.assertEquals(\"1\", foundMongo.getPersonId());\r\n    Assert.assertEquals(\"Chhavi\", foundMongo.getFirstName());\r\n    Assert.assertEquals(\"Gangwal\", foundMongo.getLastName());\r\n    emMongo.close();\r\n    emfMongo.close();\r\n}"
}, {
	"Path": "org.jupiter.transport.netty.NettyConnector.createWriteBufferWaterMark",
	"Comment": "create a writebufferwatermark is used to set low water mark and high water mark for the write buffer.",
	"Method": "WriteBufferWaterMark createWriteBufferWaterMark(int bufLowWaterMark,int bufHighWaterMark){\r\n    WriteBufferWaterMark waterMark;\r\n    if (bufLowWaterMark >= 0 && bufHighWaterMark > 0) {\r\n        waterMark = new WriteBufferWaterMark(bufLowWaterMark, bufHighWaterMark);\r\n    } else {\r\n        waterMark = new WriteBufferWaterMark(512 * 1024, 1024 * 1024);\r\n    }\r\n    return waterMark;\r\n}"
}, {
	"Path": "org.lenskit.util.io.ObjectStreams.concat",
	"Comment": "concatenate object streams.each object stream is closed as closed as it is consumed.",
	"Method": "ObjectStream<T> concat(Iterable<? extends ObjectStream<? extends T>> streams,ObjectStream<T> concat,ObjectStream<? extends T> objectStreams){\r\n    return concat(Arrays.asList(objectStreams));\r\n}"
}, {
	"Path": "org.b3log.latke.repository.Repositories.getRepositoryDef",
	"Comment": "gets the repository definition of an repository specified by the given repository name.",
	"Method": "JSONObject getRepositoryDef(String repositoryName){\r\n    if (StringUtils.isBlank(repositoryName)) {\r\n        return null;\r\n    }\r\n    if (null == repositoriesDescription) {\r\n        return null;\r\n    }\r\n    final JSONArray repositories = repositoriesDescription.optJSONArray(\"repositories\");\r\n    for (int i = 0; i < repositories.length(); i++) {\r\n        final JSONObject repository = repositories.optJSONObject(i);\r\n        if (repositoryName.equals(repository.optString(\"name\"))) {\r\n            return repository;\r\n        }\r\n    }\r\n    throw new RuntimeException(\"Not found the repository [name=\" + repositoryName + \"] definition, please define it in repositories.json\");\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.CassandraClientBase.createUpdateQueryForCounter",
	"Comment": "return update query string for given entity intended for counter column family.",
	"Method": "List<String> createUpdateQueryForCounter(EntityMetadata entityMetadata,Object entity,Cassandra.Client cassandra_client,List<RelationHolder> rlHolders){\r\n    Map<String, String> builders = new HashMap<String, String>();\r\n    CQLTranslator translator = new CQLTranslator();\r\n    Object rowId = PropertyAccessorHelper.getId(entity, entityMetadata);\r\n    MetamodelImpl metaModel = (MetamodelImpl) kunderaMetadata.getApplicationMetadata().getMetamodel(entityMetadata.getPersistenceUnit());\r\n    EntityType entityType = metaModel.entity(entityMetadata.getEntityClazz());\r\n    Set<Attribute> attributes = entityType.getAttributes();\r\n    for (Attribute attrib : attributes) {\r\n        if (!entityMetadata.getIdAttribute().getName().equals(attrib.getName()) && !metaModel.isEmbeddable(attrib.getJavaType()) && !attrib.isAssociation()) {\r\n            String tableName = ((AbstractAttribute) attrib).getTableName() != null ? ((AbstractAttribute) attrib).getTableName() : entityMetadata.getTableName();\r\n            String queryString = builders.get(tableName);\r\n            StringBuilder builder;\r\n            if (queryString == null) {\r\n                builder = new StringBuilder();\r\n            } else {\r\n                builder = new StringBuilder(queryString);\r\n            }\r\n            translator.buildSetClauseForCounters(builder, ((AbstractAttribute) attrib).getJPAColumnName(), PropertyAccessorHelper.getObject(entity, attrib.getName()));\r\n            builders.put(tableName, builder.toString());\r\n        }\r\n    }\r\n    for (RelationHolder rl : rlHolders) {\r\n        translator.buildSetClauseForCounters(new StringBuilder(builders.get(entityMetadata.getTableName())), rl.getRelationName(), rl.getRelationValue());\r\n    }\r\n    for (String tableName : builders.keySet()) {\r\n        StringBuilder builder = new StringBuilder(builders.get(tableName));\r\n        String update_Query = translator.UPDATE_QUERY;\r\n        update_Query = StringUtils.replace(update_Query, CQLTranslator.COLUMN_FAMILY, translator.ensureCase(new StringBuilder(), tableName, false).toString());\r\n        builder.delete(builder.lastIndexOf(CQLTranslator.COMMA_STR), builder.length());\r\n        builder.append(CQLTranslator.ADD_WHERE_CLAUSE);\r\n        onWhereClause(entityMetadata, rowId, translator, builder, metaModel, entityMetadata.getIdAttribute());\r\n        builder.delete(builder.lastIndexOf(CQLTranslator.AND_CLAUSE), builder.length());\r\n        StringBuilder queryBuilder = new StringBuilder(update_Query);\r\n        queryBuilder.append(CQLTranslator.ADD_SET_CLAUSE);\r\n        queryBuilder.append(builder);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Returning update query {}.\", queryBuilder.toString());\r\n        }\r\n        builders.put(tableName, queryBuilder.toString());\r\n    }\r\n    return new ArrayList(builders.values());\r\n}"
}, {
	"Path": "org.lenskit.data.ratings.Ratings.itemRatingVector",
	"Comment": "construct a rating vector that contains the ratings provided by each user.if all ratings in ratings are for the same item, then thiswill be a valid item rating vector.if multiple ratings are by the sameuser, the one with the highest timestamp is retained.if two ratingsby the same user have identical timestamps, then the one that occurs lastwhen the collection is iterated is retained.",
	"Method": "Long2DoubleMap itemRatingVector(Collection<? extends Rating> ratings){\r\n    return extractVector(ratings.iterator(), IdExtractor.USER, ratings.size());\r\n}"
}, {
	"Path": "org.jupiter.serialization.proto.io.VarInts.computeRawVarInt64Size",
	"Comment": "compute the number of bytes that would be needed to encode a varint.",
	"Method": "int computeRawVarInt64Size(long value){\r\n    if ((value & (~0L << 7)) == 0L) {\r\n        return 1;\r\n    }\r\n    if (value < 0L) {\r\n        return 10;\r\n    }\r\n    int n = 2;\r\n    if ((value & (~0L << 35)) != 0L) {\r\n        n += 4;\r\n        value >>>= 28;\r\n    }\r\n    if ((value & (~0L << 21)) != 0L) {\r\n        n += 2;\r\n        value >>>= 14;\r\n    }\r\n    if ((value & (~0L << 14)) != 0L) {\r\n        n += 1;\r\n    }\r\n    return n;\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.thrift.CQLTranslator.appendColumnValue",
	"Comment": "appends column value with parametrised builder object. returns true ifvalue is present.",
	"Method": "boolean appendColumnValue(StringBuilder builder,Object valueObj,Field column){\r\n    Object value = PropertyAccessorHelper.getObject(valueObj, column);\r\n    boolean isPresent = false;\r\n    isPresent = appendValue(builder, column.getType(), value, isPresent, false);\r\n    return isPresent;\r\n}"
}, {
	"Path": "com.impetus.client.mongodb.DocumentObjectMapper.getObjectFromDocument",
	"Comment": "creates an instance of clazz and populates fields fetchedfrom mongodb document object. field names are determined fromcolumns",
	"Method": "Object getObjectFromDocument(Metamodel metamodel,BasicDBObject documentObj,Set<Attribute> columns,Object obj){\r\n    for (Attribute column : columns) {\r\n        if (((MetamodelImpl) metamodel).isEmbeddable(((AbstractAttribute) column).getBindableJavaType())) {\r\n            DefaultMongoDBDataHandler handler = new DefaultMongoDBDataHandler();\r\n            handler.onViaEmbeddable(column, obj, metamodel, documentObj);\r\n        } else {\r\n            setFieldValue(documentObj, obj, column, false);\r\n        }\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "com.asha.vrlib.model.MDQuaternion.getPitch",
	"Comment": "get the pitch euler angle in degrees, which is the rotation around the x axis. requires that this quaternion is normalized.",
	"Method": "float getPitch(){\r\n    return getPitchRad() * MathUtils.radiansToDegrees;\r\n}"
}, {
	"Path": "org.lenskit.util.io.StagedWrite.getStagingFile",
	"Comment": "get the working file for this staging file.code doing staged file writes should write tothis file.",
	"Method": "Path getStagingFile(){\r\n    return stagingFile;\r\n}"
}, {
	"Path": "com.impetus.client.neo4j.Neo4JClient.checkActiveTransaction",
	"Comment": "checks whether there is an active transaction within this client batchoperations are run without any transaction boundary hence this check isnot applicable for them all modifying neo4j operations must be executedwithin a transaction.",
	"Method": "void checkActiveTransaction(){\r\n    if (batchSize == 0 && (resource == null || !resource.isActive())) {\r\n        throw new NotInTransactionException(\"All Modifying Neo4J operations must be executed within a transaction\");\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.data.dao.EntityQuery.getFilterFields",
	"Comment": "get the field filters. the results should only include entities matchingqueries.",
	"Method": "List<Attribute<?>> getFilterFields(){\r\n    return filterFields;\r\n}"
}, {
	"Path": "com.uber.profiling.util.AgentLogger.logShutdownMessage",
	"Comment": "handle log specially when shutdown, since we should not depend on other kafka to log these messages",
	"Method": "void logShutdownMessage(String msg){\r\n    String log = System.currentTimeMillis() + \" \" + prefix + msg;\r\n    System.out.println(log);\r\n    System.err.println(log);\r\n}"
}, {
	"Path": "org.b3log.latke.ioc.setup.SetupUnitTest.afterTest",
	"Comment": "this method will be run after the test. shutdown latke ioc container.",
	"Method": "void afterTest(){\r\n    System.out.println(\"afterTest SetupUnitTest\");\r\n    BeanManager.close();\r\n}"
}, {
	"Path": "org.lenskit.util.collections.LongUtils.hasNCommonItems",
	"Comment": "check if two sets have at least a given number of common items.",
	"Method": "boolean hasNCommonItems(LongSortedSet a,LongSortedSet b,int n){\r\n    Preconditions.checkArgument(n >= 0, \"common item count must be nonnegative\");\r\n    return n == 0 || countCommonItems(a, b, n) >= n;\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.schemamanager.CassandraSchemaManager.isIndexPresent",
	"Comment": "isinedexespresent method return whether indexes present or not onparticular column.",
	"Method": "boolean isIndexPresent(ColumnInfo columnInfo,ColumnDef columnDef,boolean isCql3Enabled,boolean isCounterColumnType){\r\n    return (isValidationClassSame(columnInfo, columnDef, isCql3Enabled, isCounterColumnType) && (columnDef.isSetIndex_type() == columnInfo.isIndexable() || (columnDef.isSetIndex_type())));\r\n}"
}, {
	"Path": "org.lenskit.basic.PrecomputedItemScorer.newBuilder",
	"Comment": "construct a new builder for precomputed item scorers.this is useful for building itemscorers for mocks.",
	"Method": "Builder newBuilder(){\r\n    return new Builder();\r\n}"
}, {
	"Path": "org.lenskit.data.ratings.PackedRatingDataBuilder.build",
	"Comment": "build the packed rating data. this first moves records from the end to fillany released but not reused slots.",
	"Method": "PackedRatingData build(){\r\n    repack();\r\n    trim();\r\n    return internalBuild();\r\n}"
}, {
	"Path": "com.fishercoder.solutions._342.isPowerOfFour_bit_manipulation",
	"Comment": "thus, doing and with 0x55555 will check if the only one bit is located on the odd position, thus ruling out those that are power of 2 but not power of 4",
	"Method": "boolean isPowerOfFour_bit_manipulation(int num){\r\n    return (num > 0 && 1073741824 % num == 0 && (num & 0x55555555) != 0);\r\n}"
}, {
	"Path": "com.fishercoder.solutions._419.countBattleships",
	"Comment": "my original solution, actually modified the input. i just undo it at the end.",
	"Method": "int countBattleships(char[][] board){\r\n    if (board == null || board.length == 0) {\r\n        return 0;\r\n    }\r\n    int result = 0;\r\n    int m = board.length;\r\n    int n = board[0].length;\r\n    for (int i = 0; i < m; i++) {\r\n        for (int j = 0; j < n; j++) {\r\n            if (board[i][j] == 'X') {\r\n                result++;\r\n                dfs(board, i, j, m, n);\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < m; i++) {\r\n        for (int j = 0; j < n; j++) {\r\n            if (board[i][j] == '#') {\r\n                board[i][j] = 'X';\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.jupiter.serialization.proto.io.UnsafeNioBufInput.readEnum",
	"Comment": "read an enum field value from the internal buffer. caller is responsible for converting the numeric value to anactual enum.",
	"Method": "int readEnum(){\r\n    checkIfPackedField();\r\n    return readRawVarInt32();\r\n}"
}, {
	"Path": "com.impetus.kundera.metadata.MetadataBuilder.belongsToPersistenceUnit",
	"Comment": "if parameterised metadata is not for intended persistence unit, assign itto null.",
	"Method": "EntityMetadata belongsToPersistenceUnit(EntityMetadata metadata){\r\n    PersistenceUnitMetadata puMetadata = kunderaMetadata.getApplicationMetadata().getPersistenceUnitMetadata(persistenceUnit);\r\n    String keyspace = puProperties != null ? (String) puProperties.get(PersistenceProperties.KUNDERA_KEYSPACE) : null;\r\n    keyspace = keyspace == null ? puMetadata.getProperty(PersistenceProperties.KUNDERA_KEYSPACE) : keyspace;\r\n    if (metadata.getPersistenceUnit() != null && !metadata.getPersistenceUnit().equals(persistenceUnit) || (keyspace != null && metadata.getSchema() != null && !metadata.getSchema().equals(keyspace))) {\r\n        metadata = null;\r\n    } else {\r\n        applyMetadataChanges(metadata);\r\n    }\r\n    return metadata;\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.EntityManagerFactoryImpl.isOpen",
	"Comment": "indicates whether the factory is open. returns true until the factory hasbeen closed.",
	"Method": "boolean isOpen(){\r\n    return !closed;\r\n}"
}, {
	"Path": "org.json.JSONObject.isNull",
	"Comment": "determine if the value associated with the key is null or if there is novalue.",
	"Method": "boolean isNull(String key){\r\n    return JSONObject.NULL.equals(this.opt(key));\r\n}"
}, {
	"Path": "org.json.JSONWriter.key",
	"Comment": "append a key. the key will be associated with the next value. in anobject, every value must be preceded by a key.",
	"Method": "JSONWriter key(String string){\r\n    if (string == null) {\r\n        throw new JSONException(\"Null key.\");\r\n    }\r\n    if (this.mode == 'k') {\r\n        try {\r\n            JSONObject topObject = this.stack[this.top - 1];\r\n            if (topObject.has(string)) {\r\n                throw new JSONException(\"Duplicate key \\\"\" + string + \"\\\"\");\r\n            }\r\n            topObject.put(string, true);\r\n            if (this.comma) {\r\n                this.writer.append(',');\r\n            }\r\n            this.writer.append(JSONObject.quote(string));\r\n            this.writer.append(':');\r\n            this.comma = false;\r\n            this.mode = 'o';\r\n            return this;\r\n        } catch (IOException e) {\r\n            throw new JSONException(e);\r\n        }\r\n    }\r\n    throw new JSONException(\"Misplaced key.\");\r\n}"
}, {
	"Path": "com.jvmtop.monitor.VMInfo.attachToVM",
	"Comment": "creates a new vminfo which is attached to a given localvirtualmachine",
	"Method": "VMInfo attachToVM(LocalVirtualMachine localvm,int vmid){\r\n    try {\r\n        ProxyClient proxyClient = ProxyClient.getProxyClient(localvm);\r\n        proxyClient.connect();\r\n        if (proxyClient.getConnectionState() == ConnectionState.DISCONNECTED) {\r\n            Logger.getLogger(\"jvmtop\").log(Level.FINE, \"connection refused (PID=\" + vmid + \")\");\r\n            return createDeadVM(vmid, localvm);\r\n        }\r\n        return new VMInfo(proxyClient, localvm, vmid + \"\");\r\n    } catch (ConnectException rmiE) {\r\n        if (rmiE.getMessage().contains(\"refused\")) {\r\n            Logger.getLogger(\"jvmtop\").log(Level.FINE, \"connection refused (PID=\" + vmid + \")\", rmiE);\r\n            return createDeadVM(vmid, localvm, VMInfoState.CONNECTION_REFUSED);\r\n        }\r\n        rmiE.printStackTrace(System.err);\r\n    } catch (IOException e) {\r\n        if ((e.getCause() != null && e.getCause() instanceof AttachNotSupportedException) || e.getMessage().contains(\"Permission denied\")) {\r\n            Logger.getLogger(\"jvmtop\").log(Level.FINE, \"could not attach (PID=\" + vmid + \")\", e);\r\n            return createDeadVM(vmid, localvm, VMInfoState.CONNECTION_REFUSED);\r\n        }\r\n        e.printStackTrace(System.err);\r\n    } catch (Exception e) {\r\n        Logger.getLogger(\"jvmtop\").log(Level.WARNING, \"could not attach (PID=\" + vmid + \")\", e);\r\n    }\r\n    return createDeadVM(vmid, localvm);\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.schemamanager.CassandraSchemaManager.validate",
	"Comment": "validate method validate schema and table for the list of tableinfos.",
	"Method": "void validate(List<TableInfo> tableInfos){\r\n    try {\r\n        KsDef ksDef = cassandra_client.describe_keyspace(databaseName);\r\n        onValidateTables(tableInfos, ksDef);\r\n    } catch (Exception ex) {\r\n        log.error(\"Error occurred while validating {}, Caused by: .\", databaseName, ex);\r\n        throw new SchemaGenerationException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.json.CDL.rowToString",
	"Comment": "produce a comma delimited text row from a jsonarray. values containingthe comma character will be quoted. troublesome characters may beremoved.",
	"Method": "String rowToString(JSONArray ja){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 0; i < ja.length(); i += 1) {\r\n        if (i > 0) {\r\n            sb.append(',');\r\n        }\r\n        Object object = ja.opt(i);\r\n        if (object != null) {\r\n            String string = object.toString();\r\n            if (string.length() > 0 && (string.indexOf(',') >= 0 || string.indexOf('\\n') >= 0 || string.indexOf('\\r') >= 0 || string.indexOf(0) >= 0 || string.charAt(0) == '\"')) {\r\n                sb.append('\"');\r\n                int length = string.length();\r\n                for (int j = 0; j < length; j += 1) {\r\n                    char c = string.charAt(j);\r\n                    if (c >= ' ' && c != '\"') {\r\n                        sb.append(c);\r\n                    }\r\n                }\r\n                sb.append('\"');\r\n            } else {\r\n                sb.append(string);\r\n            }\r\n        }\r\n    }\r\n    sb.append('\\n');\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.impetus.kvapps.runner.UserBroker.addUser",
	"Comment": "returns the contents of an excel row in the form of a string array.",
	"Method": "User addUser(Set<User> users,User addUser,String userName){\r\n    User user = new User();\r\n    PersonalDetail personalDetail = new PersonalDetail(userName, userName + \"Password\", \"Single\");\r\n    user.setUserId(userName);\r\n    user.setEmailId(userName + \"@\" + userName + \".com\");\r\n    user.setFirstName(userName);\r\n    user.setLastName(userName);\r\n    user.setTweets(new HashSet<Tweets>());\r\n    user.setPersonalDetail(personalDetail);\r\n    return user;\r\n}"
}, {
	"Path": "com.impetus.kundera.configure.schema.ColumnInfo.equals",
	"Comment": "equals method compare two object of columninfo on the basis of theirname.",
	"Method": "boolean equals(Object obj){\r\n    return obj != null && obj instanceof ColumnInfo && ((ColumnInfo) obj).columnName != null ? this.columnName != null && this.columnName.equals(((ColumnInfo) obj).columnName) : false;\r\n}"
}, {
	"Path": "com.impetus.kundera.graph.ObjectGraphUtils.onAutoGenerateId",
	"Comment": "validates and set id, in case not set and intended for auto generation.",
	"Method": "boolean onAutoGenerateId(Field idField,Object idValue){\r\n    if (idField.isAnnotationPresent(GeneratedValue.class)) {\r\n        return !isIdSet(idValue, idField);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.impetus.kundera.property.accessor.DateAccessor.getFormattedObect",
	"Comment": "just to verify with supported types of date pattern. get date from givenbelow formats",
	"Method": "String getFormattedObect(String date){\r\n    return date != null ? getDateByPattern(date).toString() : null;\r\n}"
}, {
	"Path": "org.b3log.latke.util.Stopwatchs.getTimingStat",
	"Comment": "gets the current timing statistics.if a task is not ended, the outputs will be minus for percentage and elapsed, the absolute value of the elapsedfiled is the start time.",
	"Method": "String getTimingStat(){\r\n    final Stopwatch root = STOPWATCH.get();\r\n    if (null == root) {\r\n        return \"No stopwatch\";\r\n    }\r\n    final StringBuilder stringBuilder = new StringBuilder();\r\n    root.appendTimingStat(1, stringBuilder);\r\n    return stringBuilder.toString();\r\n}"
}, {
	"Path": "com.google.android.apps.muzei.render.GLTextureView.onAttachedToWindow",
	"Comment": "this method is used as part of the view class and is not normallycalled or subclassed by clients of glsurfaceview.",
	"Method": "void onAttachedToWindow(){\r\n    super.onAttachedToWindow();\r\n    if (LOG_ATTACH_DETACH) {\r\n        Log.d(TAG, \"onAttachedToWindow reattach =\" + mDetached);\r\n    }\r\n    if (mDetached && (mRenderer != null)) {\r\n        int renderMode = RENDERMODE_CONTINUOUSLY;\r\n        if (mGLThread != null) {\r\n            renderMode = mGLThread.getRenderMode();\r\n        }\r\n        mGLThread = new GLThread(mThisWeakRef);\r\n        if (renderMode != RENDERMODE_CONTINUOUSLY) {\r\n            mGLThread.setRenderMode(renderMode);\r\n        }\r\n        mGLThread.start();\r\n    }\r\n    mDetached = false;\r\n}"
}, {
	"Path": "com.impetus.kundera.validation.rules.AttributeConstraintRule.validateMaxValue",
	"Comment": "checks whether a given value is lesser than given max value or not",
	"Method": "boolean validateMaxValue(Object validationObject,Annotation annotate){\r\n    if (checkNullObject(validationObject)) {\r\n        return true;\r\n    }\r\n    Long maxValue = ((Max) annotate).value();\r\n    if (checkvalidDigitTypes(validationObject.getClass())) {\r\n        if ((NumberUtils.toLong(toString(validationObject))) > maxValue) {\r\n            throwValidationException(((Max) annotate).message());\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.b3log.latke.ioc.SingletonContext.getReference",
	"Comment": "gets reference of the specified bean and creational context.",
	"Method": "T getReference(Bean<T> bean){\r\n    T ret = (T) beanReferences.get(bean);\r\n    if (null != ret) {\r\n        return ret;\r\n    }\r\n    ret = bean.create();\r\n    if (null != ret) {\r\n        beanReferences.put(bean, ret);\r\n        return ret;\r\n    }\r\n    throw new RuntimeException(\"Can't create reference for bean [\" + bean + \"]\");\r\n}"
}, {
	"Path": "org.json.JSONObject.optLong",
	"Comment": "get an optional long value associated with a key, or the default if thereis no such key or if the value is not a number. if the value is a string,an attempt will be made to evaluate it as a number.",
	"Method": "long optLong(String key,long optLong,String key,long defaultValue){\r\n    final Number val = this.optNumber(key, null);\r\n    if (val == null) {\r\n        return defaultValue;\r\n    }\r\n    return val.longValue();\r\n}"
}, {
	"Path": "org.lenskit.util.io.ObjectStreams.of",
	"Comment": "create an object stream over a fixed set of elements. this is mostly useful for testing.",
	"Method": "ObjectStream<T> of(T contents){\r\n    return wrap(Arrays.asList(contents));\r\n}"
}, {
	"Path": "org.json.JSONObject.keys",
	"Comment": "get an enumeration of the keys of the jsonobject. modifying this key set will alsomodify the jsonobject. use with caution.",
	"Method": "Iterator<String> keys(){\r\n    return this.keySet().iterator();\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.CassandraClientBase.isCql3Enabled",
	"Comment": "returns true in case of, composite id and if cql3 opted and not a embedded entity.",
	"Method": "boolean isCql3Enabled(EntityMetadata metadata,boolean isCql3Enabled){\r\n    return isCql3Enabled(null);\r\n}"
}, {
	"Path": "org.lenskit.rerank.AbstractScoringGreedyRerankStrategy.computeNumToInspect",
	"Comment": "a method to compute how many of the items in the list to inspect before returning the best item found so far.the default implementation searches the whole list. override this method if you want to only search some prefixof the ranking order for an optimal item.",
	"Method": "int computeNumToInspect(int numRequested,int numSelected,int numCandidates){\r\n    return numCandidates;\r\n}"
}, {
	"Path": "com.fishercoder.solutions._381.remove",
	"Comment": "removes a value from the collection. returns true if the collection contained the specified element.",
	"Method": "boolean remove(int val){\r\n    boolean contains;\r\n    if (reverseMap.containsValue(val)) {\r\n        contains = true;\r\n        if (forwardMap.containsKey(val)) {\r\n            int i = forwardMap.get(val);\r\n            forwardMap.remove(val);\r\n            reverseMap.remove(i);\r\n        } else {\r\n            reverseMap.values().remove(val);\r\n        }\r\n    } else {\r\n        contains = false;\r\n    }\r\n    return contains;\r\n}"
}, {
	"Path": "org.jupiter.serialization.proto.io.NioBufInput.readTag",
	"Comment": "attempt to read a field tag, returning zero if we have reached eof. protocol message parsers use this to readtags, since a protocol message may legally end wherever a tag occurs, and zero is not a valid tag number.",
	"Method": "int readTag(){\r\n    if (!nioBuffer.hasRemaining()) {\r\n        lastTag = 0;\r\n        return 0;\r\n    }\r\n    final int tag = readRawVarInt32();\r\n    if (tag >>> TAG_TYPE_BITS == 0) {\r\n        throw ProtocolException.invalidTag();\r\n    }\r\n    lastTag = tag;\r\n    return tag;\r\n}"
}, {
	"Path": "com.koloboke.collect.hash.HashConfig.withMaxLoad",
	"Comment": "returns a copy of this hash config with the max load set to the given value.max load allows to limit the minimum performance of hash tables,because too dense hash tables operate slowly.",
	"Method": "HashConfig withMaxLoad(double maxLoad){\r\n    return create(getMinLoad(), getTargetLoad(), maxLoad, getGrowthFactor(), getShrinkCondition());\r\n}"
}, {
	"Path": "com.impetus.kundera.metadata.MetadataUtils.getMappedName",
	"Comment": "returns mapped relational name, in case of bi directional mapping, itwill return back pkey name of associated entity.",
	"Method": "String getMappedName(EntityMetadata parentMetadata,Relation relation,KunderaMetadata kunderaMetadata){\r\n    if (relation != null) {\r\n        String joinColumn = relation.getJoinColumnName(kunderaMetadata);\r\n        if (joinColumn == null) {\r\n            Class clazz = relation.getTargetEntity();\r\n            EntityMetadata metadata = KunderaMetadataManager.getEntityMetadata(kunderaMetadata, clazz);\r\n            joinColumn = relation.getType().equals(ForeignKey.ONE_TO_MANY) ? ((AbstractAttribute) parentMetadata.getIdAttribute()).getJPAColumnName() : ((AbstractAttribute) metadata.getIdAttribute()).getJPAColumnName();\r\n        }\r\n        return joinColumn;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.nextPowerOfTwo",
	"Comment": "returns the next power of two. returns the specified value if the value is already a power of two.",
	"Method": "int nextPowerOfTwo(int value){\r\n    if (value == 0)\r\n        return 1;\r\n    value--;\r\n    value |= value >> 1;\r\n    value |= value >> 2;\r\n    value |= value >> 4;\r\n    value |= value >> 8;\r\n    value |= value >> 16;\r\n    return value + 1;\r\n}"
}, {
	"Path": "org.b3log.latke.util.Dates.currentDatetime",
	"Comment": "gets current date time string with the specified date formatter.",
	"Method": "String currentDatetime(DateFormat dateFormat){\r\n    return dateFormat.format(System.currentTimeMillis());\r\n}"
}, {
	"Path": "org.lenskit.data.dao.EntityCollectionDAOBuilder.addEntityLayout",
	"Comment": "set a layout for an entity type.a layout limits the possible attributes of entities of that type, but canresult in more efficient storage.",
	"Method": "EntityCollectionDAOBuilder addEntityLayout(EntityType et,AttributeSet attributes,EntityCollectionDAOBuilder addEntityLayout,EntityType et,AttributeSet attributes,Class<? extends EntityBuilder> ebc){\r\n    if (entitySets.containsKey(et)) {\r\n        throw new IllegalStateException(\"layout or entities already added for \" + et);\r\n    }\r\n    EntityCollectionBuilder ecb = EntityCollection.newBuilder(et, attributes, ebc);\r\n    for (TypedName<?> name : defaultIndexes) {\r\n        ecb.addIndex(name);\r\n    }\r\n    entitySets.put(et, ecb);\r\n    return this;\r\n}"
}, {
	"Path": "com.impetus.kundera.configure.SchemaConfiguration.getOrderByColumn",
	"Comment": "getorderbycolumn method return order by value of the column",
	"Method": "String getOrderByColumn(String[] orderByColumns,Attribute column){\r\n    if (orderByColumns != null) {\r\n        for (String orderColumn : orderByColumns) {\r\n            String[] orderValue = orderColumn.split(\"\\\\s\");\r\n            String orderColumnName = orderValue[0].substring(orderValue[0].lastIndexOf('.') + 1);\r\n            String orderColumnValue = orderValue[1];\r\n            if (orderColumnName.equals(((AbstractAttribute) column).getName()) || orderColumnName.equals(((AbstractAttribute) column).getJPAColumnName())) {\r\n                return orderColumnValue;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.EntityManagerFactoryImpl.close",
	"Comment": "close the factory, releasing any resources that it holds. after a factoryinstance has been closed, all methods invoked on it will throw theillegalstateexception, except for isopen, which will return false. oncean entitymanagerfactory has been closed, all its entity managers areconsidered to be in the closed state.",
	"Method": "void close(){\r\n    if (isOpen()) {\r\n        closed = true;\r\n        if (cacheProvider != null) {\r\n            cacheProvider.shutdown();\r\n        }\r\n        for (String pu : persistenceUnits) {\r\n            ((ClientLifeCycleManager) clientFactories.get(pu)).destroy();\r\n        }\r\n        this.persistenceUnits = null;\r\n        this.properties = null;\r\n        clientFactories.clear();\r\n        clientFactories = new ConcurrentHashMap<String, ClientFactory>();\r\n    } else {\r\n        throw new IllegalStateException(\"Entity manager factory has been closed\");\r\n    }\r\n}"
}, {
	"Path": "org.b3log.latke.repository.Query.addProjection",
	"Comment": "adds a projection with the specified property name and value type.",
	"Method": "Query addProjection(String propertyName,Class<?> valueType){\r\n    projections.add(new Projection(propertyName, valueType));\r\n    return this;\r\n}"
}, {
	"Path": "com.impetus.kundera.configure.schema.TableInfo.equals",
	"Comment": "equals method compare two object of tableinfo on the basis of their name",
	"Method": "boolean equals(Object obj){\r\n    return obj != null && obj instanceof TableInfo && ((TableInfo) obj).tableName != null ? this.tableName != null && this.tableName.equals(((TableInfo) obj).tableName) : false;\r\n}"
}, {
	"Path": "com.impetus.client.mongodb.MongoDBClient.findByRelation",
	"Comment": "method to find entity for given association name and association value.",
	"Method": "List<Object> findByRelation(String colName,Object colValue,Class entityClazz){\r\n    EntityMetadata m = KunderaMetadataManager.getEntityMetadata(kunderaMetadata, entityClazz);\r\n    DBCollection dbCollection = mongoDb.getCollection(m.getTableName());\r\n    BasicDBObject query = new BasicDBObject();\r\n    query.put(colName, MongoDBUtils.populateValue(colValue, colValue.getClass()));\r\n    KunderaCoreUtils.printQuery(\"Find by relation:\" + query, showQuery);\r\n    DBCursor cursor = dbCollection.find(query);\r\n    DBObject fetchedDocument = null;\r\n    List<Object> results = new ArrayList<Object>();\r\n    while (cursor.hasNext()) {\r\n        fetchedDocument = cursor.next();\r\n        populateEntity(m, results, fetchedDocument);\r\n    }\r\n    return results.isEmpty() ? null : results;\r\n}"
}, {
	"Path": "com.impetus.kundera.PersistenceUtilHelper.getMethod",
	"Comment": "returns the method with the specified name or null if itdoes not exist.",
	"Method": "Method getMethod(Class<?> clazz,String methodName){\r\n    try {\r\n        char[] string = methodName.toCharArray();\r\n        string[0] = Character.toUpperCase(string[0]);\r\n        methodName = new String(string);\r\n        try {\r\n            return clazz.getDeclaredMethod(\"get\" + methodName);\r\n        } catch (NoSuchMethodException e) {\r\n            return clazz.getDeclaredMethod(\"is\" + methodName);\r\n        }\r\n    } catch (NoSuchMethodException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.LenskitRecommenderEngine.build",
	"Comment": "build a lenskit recommender engine from a configuration.the resulting recommender isindependent of any subsequent modifications to the configuration.",
	"Method": "LenskitRecommenderEngine build(LenskitConfiguration config,LenskitRecommenderEngine build,LenskitConfiguration config,DataAccessObject dao){\r\n    return newBuilder().addConfiguration(config).build(dao);\r\n}"
}, {
	"Path": "org.json.XML.noSpace",
	"Comment": "throw an exception if the string contains whitespace. whitespace is notallowed in tagnames and attributes.",
	"Method": "void noSpace(String string){\r\n    int i, length = string.length();\r\n    if (length == 0) {\r\n        throw new JSONException(\"Empty string.\");\r\n    }\r\n    for (i = 0; i < length; i += 1) {\r\n        if (Character.isWhitespace(string.charAt(i))) {\r\n            throw new JSONException(\"'\" + string + \"' contains a space character.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.b3log.latke.util.StaticResources.isStatic",
	"Comment": "determines whether the client requests a static resource with the specified request.",
	"Method": "boolean isStatic(HttpServletRequest request){\r\n    final boolean requestStaticResourceChecked = null == request.getAttribute(Keys.HttpRequest.REQUEST_STATIC_RESOURCE_CHECKED) ? false : (Boolean) request.getAttribute(Keys.HttpRequest.REQUEST_STATIC_RESOURCE_CHECKED);\r\n    if (requestStaticResourceChecked) {\r\n        return (Boolean) request.getAttribute(Keys.HttpRequest.IS_REQUEST_STATIC_RESOURCE);\r\n    }\r\n    if (!inited) {\r\n        init();\r\n    }\r\n    request.setAttribute(Keys.HttpRequest.REQUEST_STATIC_RESOURCE_CHECKED, true);\r\n    request.setAttribute(Keys.HttpRequest.IS_REQUEST_STATIC_RESOURCE, false);\r\n    final String requestURI = request.getRequestURI();\r\n    for (final String pattern : STATIC_RESOURCE_PATHS) {\r\n        if (AntPathMatcher.match(Latkes.getContextPath() + pattern, requestURI)) {\r\n            request.setAttribute(Keys.HttpRequest.IS_REQUEST_STATIC_RESOURCE, true);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.lenskit.data.entities.Entities.copyBuilder",
	"Comment": "create a new entity builder that is initialized with a copy of an entity.",
	"Method": "EntityBuilder copyBuilder(Entity e){\r\n    EntityBuilder eb = newBuilder(e.getType(), e.getId());\r\n    for (TypedName a : e.getTypedAttributeNames()) {\r\n        eb.setAttribute(a, e.get(a));\r\n    }\r\n    return eb;\r\n}"
}, {
	"Path": "org.b3log.latke.repository.Repositories.setRepositoriesWritable",
	"Comment": "sets all repositories whether is writable with the specified flag.",
	"Method": "void setRepositoriesWritable(boolean writable){\r\n    for (final Map.Entry<String, Repository> entry : REPOS_HOLDER.entrySet()) {\r\n        final String repositoryName = entry.getKey();\r\n        final Repository repository = entry.getValue();\r\n        repository.setWritable(writable);\r\n        LOGGER.log(Level.INFO, \"Sets repository[name={0}] writable[{1}]\", new Object[] { repositoryName, writable });\r\n    }\r\n    repositoryiesWritable = writable;\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.resources.CRUDResource.delete",
	"Comment": "handler for delete method requests for this resource deletes an entity from datastore",
	"Method": "Response delete(String sessionToken,String entityClassName,String id,HttpHeaders headers){\r\n    sessionToken = sessionToken.replaceAll(\"^\\\"|\\\"$\", \"\");\r\n    String mediaType = headers != null && headers.getRequestHeaders().containsKey(\"Content-type\") ? headers.getRequestHeader(\"Content-type\").get(0) : MediaType.APPLICATION_JSON;\r\n    mediaType = mediaType.equalsIgnoreCase(MediaType.APPLICATION_XML) ? MediaType.APPLICATION_XML : MediaType.APPLICATION_JSON;\r\n    log.debug(\"DELETE: sessionToken:\" + sessionToken);\r\n    log.debug(\"DELETE: entityClass Name:\" + entityClassName);\r\n    log.debug(\"DELETE: ID:\" + id);\r\n    try {\r\n        EntityManager em = EMRepository.INSTANCE.getEM(sessionToken);\r\n        Class<?> entityClass = EntityUtils.getEntityClass(entityClassName, em);\r\n        log.debug(\"DELETE: entityClass\" + entityClass);\r\n        EntityMetadata entityMetadata = EntityUtils.getEntityMetaData(entityClass.getSimpleName(), em);\r\n        MetamodelImpl metaModel = (MetamodelImpl) em.getEntityManagerFactory().getMetamodel();\r\n        EmbeddableType keyObj = null;\r\n        Object key = null;\r\n        id = java.net.URLDecoder.decode(id, \"UTF-8\");\r\n        if (metaModel.isEmbeddable(entityMetadata.getIdAttribute().getBindableJavaType())) {\r\n            keyObj = metaModel.embeddable(entityMetadata.getIdAttribute().getBindableJavaType());\r\n            key = JAXBUtils.toObject(id, keyObj.getJavaType(), mediaType);\r\n        } else {\r\n            ObjectMapper mapper = new ObjectMapper();\r\n            key = mapper.convertValue(id, entityMetadata.getIdAttribute().getBindableJavaType());\r\n        }\r\n        Object entity = em.find(entityClass, key);\r\n        em.remove(entity);\r\n    } catch (Exception e) {\r\n        log.error(e.getMessage());\r\n        return Response.serverError().build();\r\n    }\r\n    return Response.ok(new String(\"Deleted Successfully\"), mediaType).build();\r\n}"
}, {
	"Path": "org.cuieney.videolife.common.utils.Utils.isNetworkAvailableAndNotWifi",
	"Comment": "check the network is available and not wifi,maybe 2g or 3g dataconnection.",
	"Method": "boolean isNetworkAvailableAndNotWifi(Context context){\r\n    return isNetworkAvailable(context) && !isWifiActive(context);\r\n}"
}, {
	"Path": "com.impetus.kundera.configure.schema.EmbeddedColumnInfo.equals",
	"Comment": "equals method compare two object of embeddedcolumninfo on the basis oftheir name.",
	"Method": "boolean equals(Object obj){\r\n    return obj != null && obj instanceof EmbeddedColumnInfo && ((EmbeddedColumnInfo) obj).embeddedColumnName != null ? this.embeddedColumnName != null && this.embeddedColumnName.equals(((EmbeddedColumnInfo) obj).embeddedColumnName) : false;\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.converters.CollectionConverter.toCollection",
	"Comment": "converts a string representation to collection ofgenericclass objects",
	"Method": "Collection toCollection(String input,Class<?> collectionClass,Class<?> genericClass,String mediaType){\r\n    try {\r\n        if (MediaType.APPLICATION_XML.equals(mediaType)) {\r\n            Collection c = (Collection) collectionClass.newInstance();\r\n            if (input.startsWith(\"<?xml\")) {\r\n                input = input.substring(input.indexOf(\">\") + 1, input.length());\r\n            }\r\n            input = input.replaceAll(\"<\" + genericClass.getSimpleName().toLowerCase() + \"s>\", \"\");\r\n            while (!input.equals(\"\")) {\r\n                int i = input.indexOf(\"<\/\" + genericClass.getSimpleName().toLowerCase() + \">\");\r\n                String s = input.substring(0, i + 3 + genericClass.getSimpleName().length());\r\n                input = input.substring(i + 3 + genericClass.getSimpleName().length(), input.length());\r\n                Object o = JAXBUtils.toObject(StreamUtils.toInputStream(s), genericClass, mediaType);\r\n                c.add(o);\r\n            }\r\n            return c;\r\n        } else if (MediaType.APPLICATION_JSON.equals(mediaType)) {\r\n            return JAXBUtils.mapper.readValue(input, JAXBUtils.mapper.getTypeFactory().constructCollectionType((Class<? extends Collection>) collectionClass, genericClass));\r\n        }\r\n        return null;\r\n    } catch (InstantiationException e) {\r\n        log.error(\"Error during translation, Caused by:\" + e.getMessage() + \", returning null\");\r\n        return null;\r\n    } catch (IllegalAccessException e) {\r\n        log.error(\"Error during translation, Caused by:\" + e.getMessage() + \", returning null\");\r\n        return null;\r\n    } catch (JsonParseException e) {\r\n        log.error(\"Error during translation, Caused by:\" + e.getMessage() + \", returning null\");\r\n        return null;\r\n    } catch (JsonMappingException e) {\r\n        log.error(\"Error during translation, Caused by:\" + e.getMessage() + \", returning null\");\r\n        return null;\r\n    } catch (IOException e) {\r\n        log.error(\"Error during translation, Caused by:\" + e.getMessage() + \", returning null\");\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.resources.MetadataResource.getEntityModel",
	"Comment": "handler for get requests. returns schema list and related metadata for the given list of persistence units.",
	"Method": "Response getEntityModel(String sessionToken,String entityClassName,HttpHeaders headers){\r\n    Class<?> entityClass;\r\n    String mediaType = headers != null && headers.getRequestHeaders().containsKey(\"Content-type\") ? headers.getRequestHeader(\"Content-type\").get(0) : MediaType.APPLICATION_JSON;\r\n    mediaType = mediaType.equalsIgnoreCase(MediaType.APPLICATION_XML) ? MediaType.APPLICATION_XML : MediaType.APPLICATION_JSON;\r\n    if (log.isDebugEnabled())\r\n        log.debug(\"GET: Persistence Units:\" + entityClassName);\r\n    sessionToken = sessionToken.replaceAll(\"^\\\"|\\\"$\", \"\");\r\n    try {\r\n        EntityManager em = EMRepository.INSTANCE.getEM(sessionToken);\r\n        entityClass = EntityUtils.getEntityClass(entityClassName, em);\r\n        String output = JAXBUtils.getSchema(entityClass, mediaType);\r\n        return Response.ok(ResponseBuilder.buildOutput(output, \"'\"), mediaType).build();\r\n    } catch (Exception e) {\r\n        log.error(e.getMessage());\r\n        return Response.serverError().build();\r\n    }\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.query.CassandraEntityReader.getRowKeyValue",
	"Comment": "returns list of row keys. first element will be min value and second willbe major value.",
	"Method": "Map<String, byte[]> getRowKeyValue(List<IndexExpression> expressions,String primaryKeyName){\r\n    Map<String, byte[]> rowKeys = new HashMap<String, byte[]>();\r\n    List<IndexExpression> rowExpressions = new ArrayList<IndexExpression>();\r\n    if (expressions != null) {\r\n        for (IndexExpression e : expressions) {\r\n            if (primaryKeyName.equals(new String(e.getColumn_name()))) {\r\n                IndexOperator operator = e.op;\r\n                if (operator.equals(IndexOperator.LTE) || operator.equals(IndexOperator.LT)) {\r\n                    rowKeys.put(MAX_, e.getValue());\r\n                    rowExpressions.add(e);\r\n                } else if (operator.equals(IndexOperator.GTE) || operator.equals(IndexOperator.GT)) {\r\n                    rowKeys.put(MIN_, e.getValue());\r\n                    rowExpressions.add(e);\r\n                } else if (operator.equals(IndexOperator.EQ)) {\r\n                    rowKeys.put(MAX_, e.getValue());\r\n                    rowKeys.put(MIN_, e.getValue());\r\n                    rowExpressions.add(e);\r\n                }\r\n            }\r\n        }\r\n        expressions.removeAll(rowExpressions);\r\n    }\r\n    return rowKeys;\r\n}"
}, {
	"Path": "com.koloboke.collect.testing.AbstractCursorTester.internalExecuteAndCompare",
	"Comment": "apply this method to both cursors and return normally only if bothproduce the same response.",
	"Method": "void internalExecuteAndCompare(Cursor reference,C target,CursorOperation method){\r\n    Object referenceReturnValue = null;\r\n    Set<Class<? extends RuntimeException>> possibleExceptionClasses = null;\r\n    Object targetReturnValue = null;\r\n    RuntimeException targetException = null;\r\n    try {\r\n        targetReturnValue = method.execute(target);\r\n    } catch (RuntimeException e) {\r\n        targetException = e;\r\n    }\r\n    try {\r\n        if (method == MOVE_NEXT_METHOD && targetException == null && knownOrder == CursorKnownOrder.UNKNOWN_ORDER) {\r\n            try {\r\n                ((MultiExceptionCursor) reference).promoteToNext(current(target));\r\n            } catch (IllegalStateException e) {\r\n            }\r\n        }\r\n        if (method == FOR_EACH_FORWARD_METHOD && targetException == null && knownOrder == CursorKnownOrder.UNKNOWN_ORDER) {\r\n            List<E> elements = (List<E>) targetReturnValue;\r\n            Lists.reverse(elements).forEach(((MultiExceptionCursor) reference)::promoteToNext);\r\n        }\r\n        referenceReturnValue = method.execute(reference);\r\n        if (referenceReturnValue instanceof Set)\r\n            possibleExceptionClasses = (Set<Class<? extends RuntimeException>>) referenceReturnValue;\r\n    } catch (UnknownElementException e) {\r\n        Util.fail(e, e.getMessage());\r\n    }\r\n    if (possibleExceptionClasses == null) {\r\n        if (targetException != null) {\r\n            Util.fail(targetException, \"Target threw exception when reference did not\");\r\n        }\r\n        assertEquals(referenceReturnValue, targetReturnValue);\r\n        return;\r\n    }\r\n    if (targetException == null) {\r\n        fail(\"Target failed to throw one of \" + possibleExceptionClasses);\r\n    }\r\n    assertPermitted(possibleExceptionClasses, targetException);\r\n}"
}, {
	"Path": "com.impetus.client.oraclenosql.OracleNosqlShowQueryTest.testShowQueryPropertySetInPropertyMap",
	"Comment": "testing kunera.show.query property when it is enabled at external properties level",
	"Method": "void testShowQueryPropertySetInPropertyMap(){\r\n    puProperties.put(\"kundera.show.query\", \"true\");\r\n    emf = Persistence.createEntityManagerFactory(SHOW_QUERY_DISABLED_PU, puProperties);\r\n    em = emf.createEntityManager();\r\n    try {\r\n        int i = 0;\r\n        String[] expectedQuery = new String[3];\r\n        String actualQuery = null;\r\n        BufferedReader br = null;\r\n        File file = new File(\"showQuery.log\");\r\n        PrintStream printStream;\r\n        printStream = new PrintStream(new FileOutputStream(file));\r\n        System.setOut(printStream);\r\n        Query findQuery = em.createQuery(\"Select p from UserInformation p where p.id=\\\"PK_1\\\"\");\r\n        findQuery.getResultList();\r\n        expectedQuery[0] = \"Fetch data from UserInformation for PK PK_1\";\r\n        System.setOut(printStream);\r\n        findQuery = em.createQuery(\"Select p from UserInformation p where p.id=\\\"Shahid\\\"\");\r\n        findQuery.getResultList();\r\n        expectedQuery[1] = \"Fetch data from UserInformation for PK Shahid\";\r\n        System.setOut(printStream);\r\n        br = new BufferedReader(new FileReader(\"showQuery.log\"));\r\n        actualQuery = br.readLine();\r\n        if (actualQuery == null)\r\n            fail(\"failed as file is empty\");\r\n        while (actualQuery != null) {\r\n            Assert.assertEquals(expectedQuery[i++], actualQuery);\r\n            actualQuery = br.readLine();\r\n        }\r\n    } catch (Exception e) {\r\n        logger.info(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.json.JSONTokener.skipTo",
	"Comment": "skip characters until the next character is the requested character.if the requested character is not found, no characters are skipped.",
	"Method": "char skipTo(char to){\r\n    char c;\r\n    try {\r\n        long startIndex = this.index;\r\n        long startCharacter = this.character;\r\n        long startLine = this.line;\r\n        this.reader.mark(1000000);\r\n        do {\r\n            c = this.next();\r\n            if (c == 0) {\r\n                this.reader.reset();\r\n                this.index = startIndex;\r\n                this.character = startCharacter;\r\n                this.line = startLine;\r\n                return 0;\r\n            }\r\n        } while (c != to);\r\n        this.reader.mark(1);\r\n    } catch (IOException exception) {\r\n        throw new JSONException(exception);\r\n    }\r\n    this.back();\r\n    return c;\r\n}"
}, {
	"Path": "com.impetus.kundera.query.KunderaQuery.isBound",
	"Comment": "parameter is bound if it holds any value, else will return false.",
	"Method": "boolean isBound(Parameter param){\r\n    return getClauseValue(param) != null;\r\n}"
}, {
	"Path": "org.lenskit.LenskitRecommenderEngineLoader.loadInternal",
	"Comment": "load a recommender engine from an input stream.it transparently decompresses the streamand handles the classloader nastiness.",
	"Method": "LenskitRecommenderEngine loadInternal(InputStream stream){\r\n    logger.debug(\"using classloader {}\", classLoader);\r\n    DAGNode<Component, Dependency> graph;\r\n    ObjectInputStream in = new CustomClassLoaderObjectInputStream(LKFileUtils.transparentlyDecompress(stream), classLoader);\r\n    try {\r\n        ClassLoaderContext ctx = null;\r\n        if (classLoader != null) {\r\n            ctx = ClassLoaders.pushContext(classLoader);\r\n        }\r\n        try {\r\n            graph = readGraph(in);\r\n        } finally {\r\n            if (ctx != null) {\r\n                ctx.pop();\r\n            }\r\n        }\r\n    } catch (ClassNotFoundException e) {\r\n        throw new RecommenderConfigurationException(e);\r\n    } finally {\r\n        in.close();\r\n    }\r\n    if (!configurations.isEmpty()) {\r\n        logger.info(\"rewriting with {} configurations\", configurations.size());\r\n        RecommenderGraphBuilder rgb = new RecommenderGraphBuilder();\r\n        for (LenskitConfiguration config : configurations) {\r\n            rgb.addBindings(config.getBindings());\r\n        }\r\n        DependencySolver solver = rgb.buildDependencySolver();\r\n        try {\r\n            graph = solver.rewrite(graph);\r\n        } catch (ResolutionException e) {\r\n            throw new RecommenderConfigurationException(\"resolution error occured while rewriting recommender\", e);\r\n        }\r\n    }\r\n    boolean instantiable = true;\r\n    switch(validationMode) {\r\n        case IMMEDIATE:\r\n            GraphtUtils.checkForPlaceholders(graph, logger);\r\n            break;\r\n        case DEFERRED:\r\n            instantiable = GraphtUtils.getPlaceholderNodes(graph).isEmpty();\r\n            break;\r\n        case NONE:\r\n            break;\r\n    }\r\n    return new LenskitRecommenderEngine(graph, instantiable);\r\n}"
}, {
	"Path": "com.koloboke.collect.impl.hash.HashConfigWrapper.maxCapacity",
	"Comment": "computes hash table capacity for the given size and min load of this config.",
	"Method": "int maxCapacity(int size,long maxCapacity,long size){\r\n    return minLoadInverse.scaleUpper(size);\r\n}"
}, {
	"Path": "com.impetus.kundera.metadata.model.PersistenceUnitMetadata.getClient",
	"Comment": "gets the client. in case client is not configure, it throwsillegalargumentexception.",
	"Method": "String getClient(){\r\n    String client = null;\r\n    if (this.properties != null) {\r\n        client = (String) this.properties.get(PersistenceProperties.KUNDERA_CLIENT_FACTORY);\r\n    }\r\n    if (client == null) {\r\n        log.error(\"kundera.client property is missing for persistence unit:\" + persistenceUnitName);\r\n        throw new IllegalArgumentException(\"kundera.client property is missing for persistence unit:\" + persistenceUnitName);\r\n    }\r\n    return client;\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.query.ResultIterator.checkOnFetchSize",
	"Comment": "check on fetch size. returns true, if count on fetched rows is less thanfetch size.",
	"Method": "boolean checkOnFetchSize(){\r\n    if (count++ < fetchSize) {\r\n        return true;\r\n    }\r\n    count = 0;\r\n    scrollComplete = true;\r\n    return false;\r\n}"
}, {
	"Path": "org.lenskit.data.dao.EntityQuery.matches",
	"Comment": "determine whether this query matches the specified entity.",
	"Method": "boolean matches(Entity entity){\r\n    if (!entity.getType().equals(entityType)) {\r\n        return false;\r\n    }\r\n    for (Attribute<?> attr : filterFields) {\r\n        Object val = entity.maybeGet(attr.getTypedName());\r\n        if (!attr.getValue().equals(val)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.json.JSONObject.optInt",
	"Comment": "get an optional int value associated with a key, or the default if thereis no such key or if the value is not a number. if the value is a string,an attempt will be made to evaluate it as a number.",
	"Method": "int optInt(String key,int optInt,String key,int defaultValue){\r\n    final Number val = this.optNumber(key, null);\r\n    if (val == null) {\r\n        return defaultValue;\r\n    }\r\n    return val.intValue();\r\n}"
}, {
	"Path": "org.lenskit.data.entities.Entities.projection",
	"Comment": "create a projection function that maps entities to a new view.",
	"Method": "Function<Entity, E> projection(Class<E> viewClass){\r\n    if (viewClass.equals(Entity.class)) {\r\n        return (Function) Functions.identity();\r\n    } else {\r\n        return n -> project(n, viewClass);\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.EntityManagerFactoryImpl.configureClientFactories",
	"Comment": "initialize and load clientfactory for all persistenceunit with externalproperties.",
	"Method": "void configureClientFactories(){\r\n    ClientMetadataBuilder builder = new ClientMetadataBuilder(getProperties(), kunderaMetadata, getPersistenceUnits());\r\n    builder.buildClientFactoryMetadata(clientFactories, kunderaMetadata);\r\n}"
}, {
	"Path": "org.b3log.latke.repository.Query.addSort",
	"Comment": "adds sort for the specified property with the specified direction.",
	"Method": "Query addSort(String propertyName,SortDirection sortDirection){\r\n    sorts.put(propertyName, sortDirection);\r\n    return this;\r\n}"
}, {
	"Path": "org.lenskit.data.entities.EntityBuilder.reset",
	"Comment": "reset this entity builder, clearing all propertiesthe entity type.",
	"Method": "EntityBuilder reset(){\r\n    idSet = false;\r\n    return this;\r\n}"
}, {
	"Path": "com.impetus.client.mongodb.schemamanager.MongoDBSchemaManager.update",
	"Comment": "update method update schema and table for the list of tableinfos",
	"Method": "void update(List<TableInfo> tableInfos){\r\n    for (TableInfo tableInfo : tableInfos) {\r\n        DBObject options = setCollectionProperties(tableInfo);\r\n        DB db = mongo.getDB(databaseName);\r\n        DBCollection collection = null;\r\n        if (tableInfo.getLobColumnInfo().isEmpty()) {\r\n            if (!db.collectionExists(tableInfo.getTableName())) {\r\n                collection = db.createCollection(tableInfo.getTableName(), options);\r\n                KunderaCoreUtils.printQuery(\"Create collection: \" + tableInfo.getTableName(), showQuery);\r\n            }\r\n            collection = collection != null ? collection : db.getCollection(tableInfo.getTableName());\r\n            boolean isCappedCollection = isCappedCollection(tableInfo);\r\n            if (!isCappedCollection) {\r\n                createIndexes(tableInfo, collection);\r\n            }\r\n        } else {\r\n            checkMultipleLobs(tableInfo);\r\n            if (!db.collectionExists(tableInfo.getTableName() + MongoDBUtils.FILES)) {\r\n                coll = db.createCollection(tableInfo.getTableName() + MongoDBUtils.FILES, options);\r\n                createUniqueIndexGFS(coll, tableInfo.getIdColumnName());\r\n                KunderaCoreUtils.printQuery(\"Create collection: \" + tableInfo.getTableName() + MongoDBUtils.FILES, showQuery);\r\n            }\r\n            if (!db.collectionExists(tableInfo.getTableName() + MongoDBUtils.CHUNKS)) {\r\n                db.createCollection(tableInfo.getTableName() + MongoDBUtils.CHUNKS, options);\r\n                KunderaCoreUtils.printQuery(\"Create collection: \" + tableInfo.getTableName() + MongoDBUtils.CHUNKS, showQuery);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.utils.KunderaCoreUtils.isCompletePartitionKeyPresentInQuery",
	"Comment": "cheking whether all the fields of partition key are present in the jpaquery",
	"Method": "void isCompletePartitionKeyPresentInQuery(Queue filterQueue,MetamodelImpl metaModel,EntityMetadata metadata){\r\n    Set<String> partitionKeyFields = new HashSet<String>();\r\n    populateEmbeddedIdFields(metaModel.embeddable(metadata.getIdAttribute().getBindableJavaType()).getAttributes(), metaModel, partitionKeyFields);\r\n    Set<String> queryAttributes = new HashSet<String>();\r\n    for (Object object : filterQueue) {\r\n        if (object instanceof FilterClause) {\r\n            FilterClause filter = (FilterClause) object;\r\n            String property = filter.getProperty();\r\n            String[] filterAttr = property.split(\"\\\\.\");\r\n            for (String s : filterAttr) {\r\n                queryAttributes.add(s);\r\n            }\r\n        }\r\n    }\r\n    if (!queryAttributes.containsAll(partitionKeyFields)) {\r\n        throw new QueryHandlerException(\"Incomplete partition key fields in query\");\r\n    }\r\n}"
}, {
	"Path": "org.b3log.latke.util.Crypts.signHmacSHA1",
	"Comment": "signs the specified source string using the specified secret.",
	"Method": "String signHmacSHA1(String source,String secret){\r\n    try {\r\n        final Mac mac = Mac.getInstance(\"HmacSHA1\");\r\n        mac.init(new SecretKeySpec(secret.getBytes(\"UTF-8\"), \"HmacSHA1\"));\r\n        final byte[] signData = mac.doFinal(source.getBytes(\"UTF-8\"));\r\n        return new String(Base64.encodeBase64(signData), \"UTF-8\");\r\n    } catch (final Exception e) {\r\n        throw new RuntimeException(\"HMAC-SHA1 sign failed\", e);\r\n    }\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.schemamanager.CassandraSchemaManager.onValidateTables",
	"Comment": "check for tables method check the existence of schema and table.",
	"Method": "void onValidateTables(List<TableInfo> tableInfos,KsDef ksDef){\r\n    cassandra_client.set_keyspace(ksDef.getName());\r\n    for (TableInfo tableInfo : tableInfos) {\r\n        if (isCql3Enabled(tableInfo) && !tableInfo.getType().equals(Type.SUPER_COLUMN_FAMILY.name())) {\r\n            CqlMetadata metadata = new CqlMetadata();\r\n            Map<ByteBuffer, String> name_types = new HashMap<ByteBuffer, String>();\r\n            Map<ByteBuffer, String> value_types = new HashMap<ByteBuffer, String>();\r\n            List<ColumnInfo> columnInfos = tableInfo.getColumnMetadatas();\r\n            List<EmbeddedColumnInfo> compositeColumns = tableInfo.getEmbeddedColumnMetadatas();\r\n            if (compositeColumns != null && !compositeColumns.isEmpty()) {\r\n                EmbeddableType embeddableType = compositeColumns.get(0).getEmbeddable();\r\n                for (ColumnInfo columnInfo : compositeColumns.get(0).getColumns()) {\r\n                    name_types.put(ByteBufferUtil.bytes(columnInfo.getColumnName()), UTF8Type.class.getSimpleName());\r\n                    value_types.put(ByteBufferUtil.bytes(columnInfo.getColumnName()), CassandraValidationClassMapper.getValidationClassInstance(columnInfo.getType(), true).getName());\r\n                }\r\n            } else {\r\n                name_types.put(ByteBufferUtil.bytes(tableInfo.getIdColumnName()), UTF8Type.class.getSimpleName());\r\n                value_types.put(ByteBufferUtil.bytes(tableInfo.getIdColumnName()), CassandraValidationClassMapper.getValidationClassInstance(tableInfo.getTableIdType(), true).getName());\r\n            }\r\n            for (ColumnInfo info : columnInfos) {\r\n                name_types.put(ByteBufferUtil.bytes(info.getColumnName()), UTF8Type.class.getSimpleName());\r\n                value_types.put(ByteBufferUtil.bytes(info.getColumnName()), CassandraValidationClassMapper.getValidationClassInstance(info.getType(), true).getName());\r\n            }\r\n            for (CollectionColumnInfo info : tableInfo.getCollectionColumnMetadatas()) {\r\n                name_types.put(ByteBufferUtil.bytes(info.getCollectionColumnName()), UTF8Type.class.getSimpleName());\r\n                value_types.put(ByteBufferUtil.bytes(info.getCollectionColumnName()), CassandraValidationClassMapper.getValueTypeName(info.getType(), info.getGenericClasses(), true));\r\n            }\r\n            metadata.setDefault_name_type(UTF8Type.class.getSimpleName());\r\n            metadata.setDefault_value_type(UTF8Type.class.getSimpleName());\r\n            metadata.setName_types(name_types);\r\n            metadata.setValue_types(value_types);\r\n            CQLTranslator translator = new CQLTranslator();\r\n            final String describeTable = \"select * from \";\r\n            StringBuilder builder = new StringBuilder(describeTable);\r\n            translator.ensureCase(builder, tableInfo.getTableName(), false);\r\n            builder.append(\"LIMIT 1\");\r\n            cassandra_client.set_cql_version(CassandraConstants.CQL_VERSION_3_0);\r\n            CqlResult cqlResult = cassandra_client.execute_cql3_query(ByteBufferUtil.bytes(builder.toString()), Compression.NONE, ConsistencyLevel.ONE);\r\n            KunderaCoreUtils.printQuery(builder.toString(), showQuery);\r\n            CqlMetadata originalMetadata = cqlResult.getSchema();\r\n            int compareResult = originalMetadata.compareTo(metadata);\r\n            if (compareResult > 0) {\r\n                onLog(tableInfo, metadata, value_types, originalMetadata);\r\n                throw new SchemaGenerationException(\"Schema mismatch!, validation failed. see above table for mismatch\");\r\n            }\r\n        } else {\r\n            onValidateTable(ksDef, tableInfo);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.koloboke.collect.impl.hash.HashConfigWrapper.targetCapacity",
	"Comment": "computes hash table capacity for the given size and target load of this config.",
	"Method": "int targetCapacity(int size,long targetCapacity,long size){\r\n    return targetLoadInverse.scaleUpper(size);\r\n}"
}, {
	"Path": "org.lenskit.bias.LiveUserItemBiasModel.getUserBiases",
	"Comment": "return an empty map.this may make this bias model unsuitable in some applications.",
	"Method": "Long2DoubleMap getUserBiases(LongSet users,Long2DoubleMap getUserBiases){\r\n    return Long2DoubleMaps.EMPTY_MAP;\r\n}"
}, {
	"Path": "com.impetus.kundera.client.cassandra.dsdriver.DSClient.populateSecondaryTableData",
	"Comment": "populates data form secondary tables of entity for given row key.",
	"Method": "void populateSecondaryTableData(Object rowId,Object entity,MetamodelImpl metaModel,EntityMetadata metadata){\r\n    AbstractManagedType managedType = (AbstractManagedType) metaModel.entity(metadata.getEntityClazz());\r\n    List<String> secondaryTables = ((DefaultEntityAnnotationProcessor) managedType.getEntityAnnotation()).getSecondaryTablesName();\r\n    for (String tableName : secondaryTables) {\r\n        StringBuilder builder = createSelectQuery(rowId, metadata, tableName);\r\n        ResultSet rSet = this.execute(builder.toString(), null);\r\n        Iterator<Row> rowIter = rSet.iterator();\r\n        Row row = rowIter.next();\r\n        ColumnDefinitions columnDefs = row.getColumnDefinitions();\r\n        Iterator<Definition> columnDefIter = columnDefs.iterator();\r\n        entity = iteratorColumns(metadata, metaModel, metaModel.entity(metadata.getEntityClazz()), new HashMap<String, Object>(), entity, row, columnDefIter);\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.util.collections.SortedListAccumulator.decreasing",
	"Comment": "create a new sorted list accumulator that sorts in decreasing order.",
	"Method": "SortedListAccumulator<T> decreasing(int n,SortedListAccumulator<T> decreasing,int n,Comparator<? super T> comp){\r\n    if (n < 0) {\r\n        return new Unlimited<T>(Ordering.from(comp));\r\n    } else {\r\n        return new TopN<T>(n, Ordering.from(comp));\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.AbstractEntityReader.setRelationToEntity",
	"Comment": "after successfully parsing set relational entity object within entityobject.",
	"Method": "void setRelationToEntity(Object entity,Object relationEntity,Relation relation){\r\n    if (relation.getTargetEntity().isAssignableFrom(getEntity(relationEntity).getClass())) {\r\n        if (relation.isUnary()) {\r\n            PropertyAccessorHelper.set(entity, relation.getProperty(), getEntity(relationEntity));\r\n        } else {\r\n            Object associationObject = PropertyAccessorHelper.getObject(entity, relation.getProperty());\r\n            if (associationObject == null || ProxyHelper.isProxyOrCollection(associationObject)) {\r\n                associationObject = PropertyAccessorHelper.getCollectionInstance(relation.getProperty());\r\n                PropertyAccessorHelper.set(entity, relation.getProperty(), associationObject);\r\n            }\r\n            ((Collection) associationObject).add(getEntity(relationEntity));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.proxy.cglib.CglibLazyInitializer.getImplementation",
	"Comment": "return the underlying persistent object, initializing if necessary.",
	"Method": "Object getImplementation(){\r\n    initialize();\r\n    return target;\r\n}"
}, {
	"Path": "org.lenskit.cli.commands.Graph.makeNewGraph",
	"Comment": "build a configured recommender graph from the specified configurations.",
	"Method": "DAGNode<Component, Dependency> makeNewGraph(Context ctx){\r\n    RecommenderGraphBuilder rgb = new RecommenderGraphBuilder();\r\n    rgb.addConfiguration(makeDataConfig(ctx));\r\n    for (LenskitConfiguration config : ctx.environment.loadConfigurations(ctx.getConfigFiles())) {\r\n        rgb.addConfiguration(config);\r\n    }\r\n    try {\r\n        return rgb.buildGraph();\r\n    } catch (ResolutionException e) {\r\n        throw new RecommenderConfigurationException(\"Cannot configure recommender\", e);\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.validation.rules.AttributeConstraintRule.validateMinDecimal",
	"Comment": "checks whether a given value is a valid minimum decimal digit when compared to given value or not",
	"Method": "boolean validateMinDecimal(Object validationObject,Annotation annotate){\r\n    if (validationObject != null) {\r\n        try {\r\n            if (checkvalidDeciDigitTypes(validationObject.getClass())) {\r\n                BigDecimal minValue = NumberUtils.createBigDecimal(((DecimalMin) annotate).value());\r\n                BigDecimal actualValue = NumberUtils.createBigDecimal(toString(validationObject));\r\n                int res = actualValue.compareTo(minValue);\r\n                if (res < 0) {\r\n                    throwValidationException(((DecimalMin) annotate).message());\r\n                }\r\n            }\r\n        } catch (NumberFormatException nfe) {\r\n            throw new RuleValidationException(nfe.getMessage());\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.impetus.client.mongodb.DocumentObjectMapper.setFieldValue",
	"Comment": "setter for column value, by default converted from string value, in caseof map it is automatically converted into map using basicdbobject.",
	"Method": "void setFieldValue(DBObject document,Object entityObject,Attribute column,boolean isLob){\r\n    Object value = null;\r\n    if (document != null) {\r\n        value = isLob ? ((DBObject) document.get(\"metadata\")).get(((AbstractAttribute) column).getJPAColumnName()) : document.get(((AbstractAttribute) column).getJPAColumnName());\r\n    }\r\n    if (value != null) {\r\n        Class javaType = column.getJavaType();\r\n        try {\r\n            switch(AttributeType.getType(javaType)) {\r\n                case MAP:\r\n                    PropertyAccessorHelper.set(entityObject, (Field) column.getJavaMember(), ((BasicDBObject) value).toMap());\r\n                    break;\r\n                case SET:\r\n                    List collectionValues = Arrays.asList(((BasicDBList) value).toArray());\r\n                    PropertyAccessorHelper.set(entityObject, (Field) column.getJavaMember(), new HashSet(collectionValues));\r\n                    break;\r\n                case LIST:\r\n                    PropertyAccessorHelper.set(entityObject, (Field) column.getJavaMember(), Arrays.asList(((BasicDBList) value).toArray()));\r\n                    break;\r\n                case POINT:\r\n                    BasicDBList list = (BasicDBList) value;\r\n                    Object xObj = list.get(0);\r\n                    Object yObj = list.get(1);\r\n                    if (xObj != null && yObj != null) {\r\n                        try {\r\n                            double x = Double.parseDouble(xObj.toString());\r\n                            double y = Double.parseDouble(yObj.toString());\r\n                            Point point = new Point(x, y);\r\n                            PropertyAccessorHelper.set(entityObject, (Field) column.getJavaMember(), point);\r\n                        } catch (NumberFormatException e) {\r\n                            log.error(\"Error while reading geolocation data for column {} ; Reason - possible corrupt data, Caused by : .\", column, e);\r\n                            throw new EntityReaderException(\"Error while reading geolocation data for column \" + column + \"; Reason - possible corrupt data.\", e);\r\n                        }\r\n                    }\r\n                    break;\r\n                case ENUM:\r\n                    EnumAccessor accessor = new EnumAccessor();\r\n                    value = accessor.fromString(javaType, value.toString());\r\n                    PropertyAccessorHelper.set(entityObject, (Field) column.getJavaMember(), value);\r\n                    break;\r\n                case PRIMITIVE:\r\n                    value = MongoDBUtils.populateValue(value, value.getClass());\r\n                    value = MongoDBUtils.getTranslatedObject(value, value.getClass(), javaType);\r\n                    PropertyAccessorHelper.set(entityObject, (Field) column.getJavaMember(), value);\r\n                    break;\r\n            }\r\n        } catch (PropertyAccessException paex) {\r\n            log.error(\"Error while setting column {} value, caused by : .\", ((AbstractAttribute) column).getJPAColumnName(), paex);\r\n            throw new PersistenceException(paex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.impetus.client.rdbms.HibernateUtils.getObjectFromDocument",
	"Comment": "creates an instance of clazz and populates fields fetchedfrom mongodb document object. field names are determined fromcolumns",
	"Method": "Object getObjectFromDocument(Metamodel metamodel,Map<String, Object> documentObj,Set<Attribute> columns,Object obj){\r\n    for (Attribute column : columns) {\r\n        Object value = documentObj.get(((AbstractAttribute) column).getJPAColumnName());\r\n        if (((MetamodelImpl) metamodel).isEmbeddable(((AbstractAttribute) column).getBindableJavaType())) {\r\n            onViaEmbeddable(column, obj, metamodel, (Map<String, Object>) value);\r\n        } else {\r\n            setFieldValue(obj, value, column);\r\n        }\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.EntityManagerImpl.merge",
	"Comment": "merge the state of the given entity into the current persistence context.",
	"Method": "E merge(E e){\r\n    checkClosed();\r\n    checkTransactionNeeded();\r\n    try {\r\n        return getPersistenceDelegator().merge(e);\r\n    } catch (Exception ex) {\r\n        doRollback();\r\n        throw new KunderaException(ex);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.math.MathUtils.randomBoolean",
	"Comment": "returns true if a random value between 0 and 1 is less than the specified value.",
	"Method": "boolean randomBoolean(boolean randomBoolean,float chance){\r\n    return MathUtils.random() < chance;\r\n}"
}, {
	"Path": "com.impetus.client.neo4j.GraphEntityMapper.toNeo4JProperty",
	"Comment": "converts a given field value to an object that is neo4j compatible",
	"Method": "Object toNeo4JProperty(Object source){\r\n    if (source instanceof BigDecimal || source instanceof BigInteger) {\r\n        return source.toString();\r\n    } else if ((source instanceof Calendar) || (source instanceof GregorianCalendar)) {\r\n        return PropertyAccessorHelper.fromSourceToTargetClass(String.class, Date.class, ((Calendar) source).getTime());\r\n    }\r\n    if (source instanceof Date) {\r\n        Class<?> sourceClass = source.getClass();\r\n        return PropertyAccessorHelper.fromSourceToTargetClass(String.class, sourceClass, source);\r\n    }\r\n    return source;\r\n}"
}, {
	"Path": "org.lenskit.data.store.AttrStoreBuilder.tempBuild",
	"Comment": "build a temp version of the attribute store.it does not perform compacting cleanups.",
	"Method": "AttrStore tempBuild(){\r\n    return new AttrStore(shards, size);\r\n}"
}, {
	"Path": "com.impetus.kundera.validation.rules.EntityFieldAnnotationRule.onSuperClass",
	"Comment": "checks whether the defined class is a validone with an id field presenteither in class itself or its superclass",
	"Method": "void onSuperClass(Class<?> clazz,List<Field> keys){\r\n    Class<?> superClass = clazz.getSuperclass();\r\n    if (superClass != null && (superClass.isAnnotationPresent(MappedSuperclass.class) || superClass.isAnnotationPresent(Entity.class))) {\r\n        while (superClass != null && (superClass.isAnnotationPresent(MappedSuperclass.class) || superClass.isAnnotationPresent(Entity.class))) {\r\n            for (Field field : superClass.getDeclaredFields()) {\r\n                onIdField(field, superClass);\r\n                if (field.isAnnotationPresent(Id.class)) {\r\n                    keys.add(field);\r\n                    if (field.isAnnotationPresent(GeneratedValue.class)) {\r\n                        validateGeneratedValueAnnotation(superClass, field);\r\n                    }\r\n                } else if (field.isAnnotationPresent(EmbeddedId.class)) {\r\n                    keys.add(field);\r\n                }\r\n            }\r\n            if (keys.size() > 0) {\r\n                onEntityKey(keys, superClass);\r\n                break;\r\n            }\r\n            superClass = superClass.getSuperclass();\r\n        }\r\n    }\r\n    onEntityKey(keys, clazz);\r\n}"
}, {
	"Path": "com.impetus.client.crud.CassandraNativeFunctionsTest.prepareDataWithCompositePartitionAndClusteringKeys",
	"Comment": "prepare data with composite partition and clustering keys.",
	"Method": "void prepareDataWithCompositePartitionAndClusteringKeys(){\r\n    String useNativeSql = \"USE \" + \"\\\"KunderaExamples\\\"\";\r\n    Query q = entityManager.createNativeQuery(useNativeSql);\r\n    q.executeUpdate();\r\n    String qry = \"create table kundera (k_part_one text, k_part_two int, \" + \"k_clust_one text, k_clust_two int, k_clust_three text, data text, \" + \"PRIMARY KEY((k_part_one,k_part_two), k_clust_one, k_clust_two, k_clust_three))\";\r\n    q = entityManager.createNativeQuery(qry);\r\n    q.executeUpdate();\r\n    qry = \"insert into kundera (k_part_one, k_part_two, k_clust_one, k_clust_two, k_clust_three, data)\" + \"VALUES ('kar', 13, 'cluster11', 21, 'cluster31', 'some random data')\";\r\n    q = entityManager.createNativeQuery(qry);\r\n    q.executeUpdate();\r\n    qry = \"insert into kundera (k_part_one, k_part_two, k_clust_one, k_clust_two, k_clust_three, data)\" + \"VALUES ('dev', 7, 'cluster12', 22, 'cluster32', 'some more random data')\";\r\n    q = entityManager.createNativeQuery(qry);\r\n    q.executeUpdate();\r\n    qry = \"insert into kundera (k_part_one, k_part_two, k_clust_one, k_clust_two, k_clust_three, data)\" + \"VALUES ('pg', 9, 'cluster13', 23, 'cluster33', 'random data')\";\r\n    q = entityManager.createNativeQuery(qry);\r\n    q.executeUpdate();\r\n}"
}, {
	"Path": "org.json.JSONObject.optJSONArray",
	"Comment": "get an optional jsonarray associated with a key. it returns null if thereis no such key, or if its value is not a jsonarray.",
	"Method": "JSONArray optJSONArray(String key){\r\n    Object o = this.opt(key);\r\n    return o instanceof JSONArray ? (JSONArray) o : null;\r\n}"
}, {
	"Path": "org.lenskit.data.store.EntityCollectionBuilder.add",
	"Comment": "add an entity to the collection.if an entity with the specified id already exists,it is replaced.",
	"Method": "EntityCollectionBuilder add(Entity e,EntityCollectionBuilder add,Entity e,boolean replace){\r\n    return add(e, true);\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.AbstractEntityReader.fetchRelations",
	"Comment": "based on relation type, method invokes database to fetch relationentities.",
	"Method": "List fetchRelations(Relation relation,EntityMetadata metadata,PersistenceDelegator pd,Object entityId,Object relationValue,EntityMetadata targetEntityMetadata){\r\n    List relationalEntities = new ArrayList();\r\n    if ((relationValue != null && relation.isUnary()) || (relation.isJoinedByPrimaryKey())) {\r\n        Object relationEntity = pd.getClient(targetEntityMetadata).find(relation.getTargetEntity(), relationValue != null ? relationValue : entityId);\r\n        if (relationEntity != null) {\r\n            relationalEntities.add(relationEntity);\r\n        }\r\n    } else if (!relation.isUnary()) {\r\n        Client associatedClient = pd.getClient(targetEntityMetadata);\r\n        if (!MetadataUtils.useSecondryIndex(((ClientBase) associatedClient).getClientMetadata()) && MetadataUtils.indexSearchEnabled(targetEntityMetadata.getPersistenceUnit(), kunderaMetadata)) {\r\n            relationalEntities = getAssociationBuilder().getAssociatedEntitiesFromIndex(relation.getProperty().getDeclaringClass(), entityId, targetEntityMetadata.getEntityClazz(), associatedClient);\r\n        } else {\r\n            relationalEntities = associatedClient.findByRelation(relation.getJoinColumnName(kunderaMetadata), entityId, relation.getTargetEntity());\r\n        }\r\n    }\r\n    return relationalEntities;\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.AbstractEntityReader.recursivelyFindEntities",
	"Comment": "recursively fetches associated entities for a given entity",
	"Method": "Object recursivelyFindEntities(Object entity,Map<String, Object> relationsMap,EntityMetadata m,PersistenceDelegator pd,boolean lazilyLoaded,Map<Object, Object> relationStack){\r\n    return handleAssociation(entity, relationsMap, m, pd, lazilyLoaded, relationStack);\r\n}"
}, {
	"Path": "org.b3log.latke.util.Reflections.getAnnotations",
	"Comment": "gets annotations match the needed annotation type from the specified annotation.",
	"Method": "Set<Annotation> getAnnotations(Annotation[] annotations,Class<? extends Annotation> neededAnnotationType){\r\n    final Set<Annotation> ret = new HashSet();\r\n    for (final Annotation annotation : annotations) {\r\n        annotation.annotationType().getAnnotations();\r\n        final Annotation[] metaAnnotations = annotation.annotationType().getAnnotations();\r\n        for (final Annotation metaAnnotation : metaAnnotations) {\r\n            if (metaAnnotation.annotationType().equals(neededAnnotationType)) {\r\n                ret.add(annotation);\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.impetus.kundera.query.KunderaQuery.isAliasOnly",
	"Comment": "method to check if required result is to get complete entity or a select scalar value.",
	"Method": "boolean isAliasOnly(){\r\n    return result != null && (result[0].indexOf(\".\") == -1);\r\n}"
}, {
	"Path": "org.json.Cookie.unescape",
	"Comment": "convert %hh sequences to single characters, andconvert plus to space.",
	"Method": "String unescape(String string){\r\n    int length = string.length();\r\n    StringBuilder sb = new StringBuilder(length);\r\n    for (int i = 0; i < length; ++i) {\r\n        char c = string.charAt(i);\r\n        if (c == '+') {\r\n            c = ' ';\r\n        } else if (c == '%' && i + 2 < length) {\r\n            int d = JSONTokener.dehexchar(string.charAt(i + 1));\r\n            int e = JSONTokener.dehexchar(string.charAt(i + 2));\r\n            if (d >= 0 && e >= 0) {\r\n                c = (char) (d * 16 + e);\r\n                i += 2;\r\n            }\r\n        }\r\n        sb.append(c);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.json.JSONObject.keySet",
	"Comment": "get a set of keys of the jsonobject. modifying this key set will also modify thejsonobject. use with caution.",
	"Method": "Set<String> keySet(){\r\n    return this.map.keySet();\r\n}"
}, {
	"Path": "com.impetus.kundera.metadata.MetadataUtils.defaultTransactionSupported",
	"Comment": "if client specific to parameterized persistence unit does not supporttransaction, return true else will return false.",
	"Method": "boolean defaultTransactionSupported(String persistenceUnit,KunderaMetadata kunderaMetadata){\r\n    PersistenceUnitMetadata puMetadata = KunderaMetadataManager.getPersistenceUnitMetadata(kunderaMetadata, persistenceUnit);\r\n    String txResource = puMetadata.getProperty(PersistenceProperties.KUNDERA_TRANSACTION_RESOURCE);\r\n    if (txResource == null) {\r\n        return true;\r\n    } else if (txResource.isEmpty()) {\r\n        throw new IllegalArgumentException(\"Property \" + PersistenceProperties.KUNDERA_TRANSACTION_RESOURCE + \" is blank\");\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.asha.vrlib.model.MDQuaternion.getYawRad",
	"Comment": "get the yaw euler angle in radians, which is the rotation around the y axis. requires that this quaternion is normalized.",
	"Method": "float getYawRad(){\r\n    float w = q[0];\r\n    float x = q[1];\r\n    float y = q[2];\r\n    float z = q[3];\r\n    return getGimbalPole() == 0 ? MathUtils.atan2(2f * (y * w + x * z), 1f - 2f * (y * y + x * x)) : 0f;\r\n}"
}, {
	"Path": "org.b3log.latke.util.Strings.isEmail",
	"Comment": "checks whether the specified string is a valid email address.",
	"Method": "boolean isEmail(String string){\r\n    if (StringUtils.isBlank(string)) {\r\n        return false;\r\n    }\r\n    if (MAX_EMAIL_LENGTH < string.length()) {\r\n        return false;\r\n    }\r\n    final String[] parts = string.split(\"@\");\r\n    if (2 != parts.length) {\r\n        return false;\r\n    }\r\n    final String local = parts[0];\r\n    if (MAX_EMAIL_LENGTH_LOCAL < local.length()) {\r\n        return false;\r\n    }\r\n    final String domain = parts[1];\r\n    if (MAX_EMAIL_LENGTH_DOMAIN < domain.length()) {\r\n        return false;\r\n    }\r\n    return EMAIL_PATTERN.matcher(string).matches();\r\n}"
}, {
	"Path": "org.b3log.latke.util.Callstacks.isCaller",
	"Comment": "checks the current method is whether invoked by a caller specified by the given class name and method name.",
	"Method": "boolean isCaller(String className,String methodName){\r\n    final Throwable throwable = new Throwable();\r\n    final StackTraceElement[] stackElements = throwable.getStackTrace();\r\n    if (null == stackElements) {\r\n        LOGGER.log(Level.WARN, \"Empty call stack\");\r\n        return false;\r\n    }\r\n    final boolean matchAllMethod = \"*\".equals(methodName);\r\n    for (int i = 1; i < stackElements.length; i++) {\r\n        if (stackElements[i].getClassName().equals(className)) {\r\n            return matchAllMethod ? true : stackElements[i].getMethodName().equals(methodName);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.b3log.latke.logging.Logger.isLoggable",
	"Comment": "checks if a message of the given level would actually be logged by this logger.",
	"Method": "boolean isLoggable(Level level){\r\n    switch(level) {\r\n        case TRACE:\r\n            return isTraceEnabled();\r\n        case DEBUG:\r\n            return isDebugEnabled();\r\n        case INFO:\r\n            return isInfoEnabled();\r\n        case WARN:\r\n            return isWarnEnabled();\r\n        case ERROR:\r\n            return isErrorEnabled();\r\n        default:\r\n            throw new IllegalStateException(\"Logging level [\" + level + \"] is invalid\");\r\n    }\r\n}"
}, {
	"Path": "com.impetus.kundera.loader.PersistenceXMLLoader.getDocument",
	"Comment": "reads the persistence xml content into an object graph and validates itagainst the related xsd schema.",
	"Method": "Document getDocument(URL pathToPersistenceXml){\r\n    InputStream is = null;\r\n    Document xmlRootNode = null;\r\n    try {\r\n        if (pathToPersistenceXml != null) {\r\n            URLConnection conn = pathToPersistenceXml.openConnection();\r\n            conn.setUseCaches(false);\r\n            is = conn.getInputStream();\r\n        }\r\n        if (is == null) {\r\n            throw new IOException(\"Failed to obtain InputStream from url: \" + pathToPersistenceXml);\r\n        }\r\n        xmlRootNode = parseDocument(is);\r\n        validateDocumentAgainstSchema(xmlRootNode);\r\n    } catch (IOException e) {\r\n        throw new InvalidConfigurationException(e);\r\n    } finally {\r\n        if (is != null) {\r\n            try {\r\n                is.close();\r\n            } catch (IOException ex) {\r\n                log.warn(\"Input stream could not be closed after parsing persistence.xml, caused by: {}\", ex);\r\n            }\r\n        }\r\n    }\r\n    return xmlRootNode;\r\n}"
}, {
	"Path": "org.b3log.latke.event.AbstractEventQueue.deleteListeners",
	"Comment": "clears the listener list so that this object no longer has any listeners..",
	"Method": "void deleteListeners(){\r\n    listeners.clear();\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.schemamanager.CassandraSchemaManager.isValidationClassSame",
	"Comment": "isinedexespresent method return whether indexes present or not onparticular column.",
	"Method": "boolean isValidationClassSame(ColumnInfo columnInfo,ColumnDef columnDef,boolean isCql3Enabled,boolean isCounterColumnType){\r\n    return (isColumnPresent(columnInfo, columnDef, isCql3Enabled) && columnDef.getValidation_class().endsWith(isCounterColumnType ? CounterColumnType.class.getSimpleName() : CassandraValidationClassMapper.getValidationClass(columnInfo.getType(), isCql3Enabled)));\r\n}"
}, {
	"Path": "org.lenskit.inject.NodeProcessors.simulateInstantiation",
	"Comment": "create a node processor that will simulate instantiating nodes.",
	"Method": "NodeProcessor simulateInstantiation(){\r\n    return new SimulationNodeProcessor();\r\n}"
}, {
	"Path": "org.lenskit.LenskitRecommenderEngineBuilder.buildRecommender",
	"Comment": "build the recommender directly, skipping an engine.this does not separate the recommender fromthe dao, it just directly builds it.",
	"Method": "LenskitRecommender buildRecommender(DataAccessObject dao){\r\n    DAGNode<Component, Dependency> graph = buildRecommenderGraph(dao);\r\n    graph = instantiateGraph(graph);\r\n    return new LenskitRecommender(graph);\r\n}"
}, {
	"Path": "org.lenskit.results.AbstractResult.startHashCode",
	"Comment": "create an equality builder, populated with the id and score.subclasses can use this as a starting point forchecking equality.",
	"Method": "HashCodeBuilder startHashCode(HashCodeBuilder startHashCode,Result r){\r\n    return new HashCodeBuilder().append(r.getId()).append(r.getScore());\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.resources.CRUDResource.insert",
	"Comment": "handler for post method requests for this resource inserts an entity into datastore",
	"Method": "Response insert(String sessionToken,String entityClassName,String input,HttpHeaders headers){\r\n    String mediaType = headers != null && headers.getRequestHeaders().containsKey(\"Content-type\") ? headers.getRequestHeader(\"Content-type\").get(0) : MediaType.APPLICATION_JSON;\r\n    mediaType = mediaType.equalsIgnoreCase(MediaType.APPLICATION_XML) ? MediaType.APPLICATION_XML : MediaType.APPLICATION_JSON;\r\n    sessionToken = sessionToken.replaceAll(\"^\\\"|\\\"$\", \"\");\r\n    input = input.replaceAll(\"^\\\"|\\\"$\", \"\");\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"POST: SessionToken: \" + sessionToken);\r\n        log.debug(\"POST: entityClass: \" + entityClassName);\r\n    }\r\n    try {\r\n        EntityManager em = EMRepository.INSTANCE.getEM(sessionToken);\r\n        Class<?> entityClass = EntityUtils.getEntityClass(entityClassName, em);\r\n        if (log.isDebugEnabled())\r\n            log.debug(\"POST: entityClass\" + entityClass);\r\n        if (log.isDebugEnabled())\r\n            log.debug(\"POST: Media Type:\" + mediaType);\r\n        log.debug(\"Entity Data\" + input);\r\n        Object entity = JAXBUtils.toObject(input, entityClass, mediaType);\r\n        log.debug(\"Entity Data\" + entity);\r\n        em.persist(entity);\r\n    } catch (Exception e) {\r\n        log.error(e.getMessage());\r\n        return Response.serverError().build();\r\n    }\r\n    return Response.ok(\"Record persisted\", mediaType).build();\r\n}"
}, {
	"Path": "org.json.JSONTokener.next",
	"Comment": "consume the next character, and check that it matches a specifiedcharacter.",
	"Method": "char next(char next,char c,String next,int n){\r\n    if (n == 0) {\r\n        return \"\";\r\n    }\r\n    char[] chars = new char[n];\r\n    int pos = 0;\r\n    while (pos < n) {\r\n        chars[pos] = this.next();\r\n        if (this.end()) {\r\n            throw this.syntaxError(\"Substring bounds error\");\r\n        }\r\n        pos += 1;\r\n    }\r\n    return new String(chars);\r\n}"
}, {
	"Path": "org.lenskit.results.ResultAccumulator.finish",
	"Comment": "finish accumulating and return the accumulated results.when this method is called, the accumulator is reset and can be used to accumulate a fresh set of results.",
	"Method": "ResultList finish(){\r\n    return Results.newResultList(accum.finish());\r\n}"
}, {
	"Path": "org.json.CDL.getValue",
	"Comment": "get the next value. the value can be wrapped in quotes. the value canbe empty.",
	"Method": "String getValue(JSONTokener x){\r\n    char c;\r\n    char q;\r\n    StringBuffer sb;\r\n    do {\r\n        c = x.next();\r\n    } while (c == ' ' || c == '\\t');\r\n    switch(c) {\r\n        case 0:\r\n            return null;\r\n        case '\"':\r\n        case '\\'':\r\n            q = c;\r\n            sb = new StringBuffer();\r\n            for (; ; ) {\r\n                c = x.next();\r\n                if (c == q) {\r\n                    char nextC = x.next();\r\n                    if (nextC != '\\\"') {\r\n                        if (nextC > 0) {\r\n                            x.back();\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                if (c == 0 || c == '\\n' || c == '\\r') {\r\n                    throw x.syntaxError(\"Missing close quote '\" + q + \"'.\");\r\n                }\r\n                sb.append(c);\r\n            }\r\n            return sb.toString();\r\n        case ',':\r\n            x.back();\r\n            return \"\";\r\n        default:\r\n            x.back();\r\n            return x.nextTo(',');\r\n    }\r\n}"
}, {
	"Path": "org.b3log.latke.servlet.RequestContext.addHeader",
	"Comment": "adds a header specified by the given name and value to the response.",
	"Method": "void addHeader(String name,String value){\r\n    response.addHeader(name, value);\r\n}"
}, {
	"Path": "org.b3log.latke.util.Stopwatchs.getElapsed",
	"Comment": "gets elapsed time from the specified parent stopwatch with the specified task title.",
	"Method": "long getElapsed(String taskTitle){\r\n    final long currentTimeMillis = System.currentTimeMillis();\r\n    if (StringUtils.isBlank(taskTitle)) {\r\n        return -1;\r\n    }\r\n    final Stopwatch root = STOPWATCH.get();\r\n    if (null == root) {\r\n        return -1;\r\n    }\r\n    final Stopwatch stopwatch = get(root, taskTitle);\r\n    if (null == stopwatch) {\r\n        return -1;\r\n    }\r\n    if (stopwatch.isEnded()) {\r\n        return stopwatch.getElapsedTime();\r\n    }\r\n    return currentTimeMillis - stopwatch.getStartTime();\r\n}"
}, {
	"Path": "com.impetus.client.mongodb.DocumentObjectMapper.getCollectionFromDocumentList",
	"Comment": "creates a collection of embeddedobjectclass instanceswherein each element is java object representation of mongodb documentobject contained in documentlist. field names are determinedfrom columns.",
	"Method": "Collection<?> getCollectionFromDocumentList(Metamodel metamodel,BasicDBList documentList,Class embeddedCollectionClass,Class embeddedObjectClass,Set<Attribute> columns){\r\n    Collection<Object> embeddedCollection = null;\r\n    if (embeddedCollectionClass.equals(Set.class)) {\r\n        embeddedCollection = new HashSet<Object>();\r\n    } else if (embeddedCollectionClass.equals(List.class)) {\r\n        embeddedCollection = new ArrayList<Object>();\r\n    } else {\r\n        throw new PersistenceException(\"Invalid collection class \" + embeddedCollectionClass + \"; only Set and List allowed\");\r\n    }\r\n    for (Object dbObj : documentList) {\r\n        try {\r\n            Object obj = embeddedObjectClass.newInstance();\r\n            embeddedCollection.add(getObjectFromDocument(metamodel, (BasicDBObject) dbObj, columns, obj));\r\n        } catch (InstantiationException e) {\r\n            throw new PersistenceException(e);\r\n        } catch (IllegalAccessException e) {\r\n            throw new PersistenceException(e);\r\n        }\r\n    }\r\n    return embeddedCollection;\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.EntityManagerImpl.contains",
	"Comment": "check if the instance is a managed entity instance belonging to thecurrent persistence context.",
	"Method": "boolean contains(Object entity){\r\n    checkClosed();\r\n    return getPersistenceDelegator().contains(entity);\r\n}"
}, {
	"Path": "org.lenskit.LenskitRecommenderEngine.isInstantiable",
	"Comment": "query whether this engine is instantiable.instantiable recommenders have all theirplaceholders removed and are ready to instantiate.",
	"Method": "boolean isInstantiable(){\r\n    return instantiable;\r\n}"
}, {
	"Path": "org.b3log.latke.util.Reflections.getMethodVariableNames",
	"Comment": "get method variable names of the specified class, target method name and parameter types.",
	"Method": "String[] getMethodVariableNames(Class<?> clazz,String targetMethodName,Class<?>[] types){\r\n    CtClass cc;\r\n    CtMethod cm = null;\r\n    try {\r\n        if (null == CLASS_POOL.find(clazz.getName())) {\r\n            CLASS_POOL.insertClassPath(new ClassClassPath(clazz));\r\n        }\r\n        cc = CLASS_POOL.get(clazz.getName());\r\n        final CtClass[] ptypes = new CtClass[types.length];\r\n        for (int i = 0; i < ptypes.length; i++) {\r\n            ptypes[i] = CLASS_POOL.get(types[i].getName());\r\n        }\r\n        cm = cc.getDeclaredMethod(targetMethodName, ptypes);\r\n    } catch (final NotFoundException e) {\r\n        LOGGER.log(Level.ERROR, \"Get method variable names failed\", e);\r\n    }\r\n    if (null == cm) {\r\n        return new String[types.length];\r\n    }\r\n    final MethodInfo methodInfo = cm.getMethodInfo();\r\n    final CodeAttribute codeAttribute = methodInfo.getCodeAttribute();\r\n    final LocalVariableAttribute attr = (LocalVariableAttribute) codeAttribute.getAttribute(LocalVariableAttribute.tag);\r\n    String[] variableNames = new String[0];\r\n    try {\r\n        variableNames = new String[cm.getParameterTypes().length];\r\n    } catch (final NotFoundException e) {\r\n        LOGGER.log(Level.ERROR, \"Get method variable names failed\", e);\r\n    }\r\n    int j = -1;\r\n    String variableName = null;\r\n    Boolean ifkill = false;\r\n    while (!\"this\".equals(variableName)) {\r\n        j++;\r\n        variableName = attr.variableName(j);\r\n        if (j > 99) {\r\n            LOGGER.log(Level.WARN, \"Maybe resolve to VariableNames error [class=\" + clazz.getName() + \", targetMethodName=\" + targetMethodName + ']');\r\n            ifkill = true;\r\n            break;\r\n        }\r\n    }\r\n    if (!ifkill) {\r\n        for (int i = 0; i < variableNames.length; i++) {\r\n            variableNames[i] = attr.variableName(++j);\r\n        }\r\n    }\r\n    return variableNames;\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.resources.TransactionResource.commit",
	"Comment": "handler for post method requests for this resource commits transaction\tfor the given session",
	"Method": "String commit(String sessionToken){\r\n    if (log.isDebugEnabled())\r\n        log.debug(\"POST: Session Token:\" + sessionToken);\r\n    EntityManager em = EMRepository.INSTANCE.getEM(sessionToken);\r\n    if (em == null) {\r\n        if (log.isDebugEnabled())\r\n            log.warn(\"POST: Session Token:\" + sessionToken + \" doesn't exist and transaction could not be commited\");\r\n        return ResponseCode.POST_TX_FAILED;\r\n    }\r\n    try {\r\n        em.getTransaction().commit();\r\n    } catch (Exception e) {\r\n        log.error(\"POST: Failed: \" + e.getMessage());\r\n        return ResponseCode.POST_TX_FAILED;\r\n    }\r\n    return ResponseCode.POST_TX_SUCCESS;\r\n}"
}, {
	"Path": "org.lenskit.basic.TopNItemRecommender.getDefaultExcludes",
	"Comment": "get the default exclude set for a user.the base implementation getsall the items they have interacted with.",
	"Method": "LongSet getDefaultExcludes(long user){\r\n    return dao.query(CommonTypes.RATING).withAttribute(CommonAttributes.USER_ID, user).valueSet(CommonAttributes.ITEM_ID);\r\n}"
}, {
	"Path": "org.lenskit.rerank.AbstractFilteringGreedyRerankStrategy.computeNumToInspect",
	"Comment": "a method to compute how many of the items in the list to inspect before returning the best item found so far.the default implementation searches the whole list. override this method if you want to only search some prefixof the ranking order for an optimal item.",
	"Method": "int computeNumToInspect(int numRequested,int numSelected,int numCandidates){\r\n    return numCandidates;\r\n}"
}, {
	"Path": "org.json.JSONTokener.nextString",
	"Comment": "return the characters up to the next close quote character.backslash processing is done. the formal json format does notallow strings in single quotes, but an implementation is allowed toaccept them.",
	"Method": "String nextString(char quote){\r\n    char c;\r\n    StringBuilder sb = new StringBuilder();\r\n    for (; ; ) {\r\n        c = this.next();\r\n        switch(c) {\r\n            case 0:\r\n            case '\\n':\r\n            case '\\r':\r\n                throw this.syntaxError(\"Unterminated string\");\r\n            case '\\\\':\r\n                c = this.next();\r\n                switch(c) {\r\n                    case 'b':\r\n                        sb.append('\\b');\r\n                        break;\r\n                    case 't':\r\n                        sb.append('\\t');\r\n                        break;\r\n                    case 'n':\r\n                        sb.append('\\n');\r\n                        break;\r\n                    case 'f':\r\n                        sb.append('\\f');\r\n                        break;\r\n                    case 'r':\r\n                        sb.append('\\r');\r\n                        break;\r\n                    case 'u':\r\n                        try {\r\n                            sb.append((char) Integer.parseInt(this.next(4), 16));\r\n                        } catch (NumberFormatException e) {\r\n                            throw this.syntaxError(\"Illegal escape.\", e);\r\n                        }\r\n                        break;\r\n                    case '\"':\r\n                    case '\\'':\r\n                    case '\\\\':\r\n                    case '/':\r\n                        sb.append(c);\r\n                        break;\r\n                    default:\r\n                        throw this.syntaxError(\"Illegal escape.\");\r\n                }\r\n                break;\r\n            default:\r\n                if (c == quote) {\r\n                    return sb.toString();\r\n                }\r\n                sb.append(c);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.b3log.latke.Latkes.setStaticServerScheme",
	"Comment": "sets static server scheme with the specified static server scheme.",
	"Method": "void setStaticServerScheme(String staticServerScheme){\r\n    Latkes.staticServerScheme = staticServerScheme;\r\n}"
}, {
	"Path": "org.json.JSONObject.optDouble",
	"Comment": "get an optional double associated with a key, or the defaultvalue ifthere is no such key or if its value is not a number. if the value is astring, an attempt will be made to evaluate it as a number.",
	"Method": "double optDouble(String key,double optDouble,String key,double defaultValue){\r\n    Number val = this.optNumber(key);\r\n    if (val == null) {\r\n        return defaultValue;\r\n    }\r\n    final double doubleValue = val.doubleValue();\r\n    return doubleValue;\r\n}"
}, {
	"Path": "com.impetus.kundera.blockchain.ethereum.KunderaWeb3jClient.getBlockNumberWithRawData",
	"Comment": "gets the block number with raw data.it is used for logging purpose",
	"Method": "String getBlockNumberWithRawData(String blockNumberRaw){\r\n    return Numeric.decodeQuantity(blockNumberRaw) + \"(\" + blockNumberRaw + \")\";\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.schemamanager.CassandraSchemaManager.getColumnMetadata",
	"Comment": "getcolumnmetadata use for getting column metadata for specificcolumninfo.",
	"Method": "ColumnDef getColumnMetadata(ColumnInfo columnInfo,TableInfo tableInfo){\r\n    ColumnDef columnDef = new ColumnDef();\r\n    columnDef.setName(columnInfo.getColumnName().getBytes());\r\n    columnDef.setValidation_class(CassandraValidationClassMapper.getValidationClass(columnInfo.getType(), isCql3Enabled(tableInfo)));\r\n    if (columnInfo.isIndexable()) {\r\n        IndexInfo indexInfo = tableInfo.getColumnToBeIndexed(columnInfo.getColumnName());\r\n        columnDef.setIndex_type(CassandraIndexHelper.getIndexType(indexInfo.getIndexType()));\r\n    }\r\n    return columnDef;\r\n}"
}, {
	"Path": "com.uber.profiling.reporters.FileOutputReporter.setDirectory",
	"Comment": "the output directory can only be set at mose once. setting it again will throw exception.",
	"Method": "void setDirectory(String directory){\r\n    synchronized (this) {\r\n        if (this.directory == null || this.directory.isEmpty()) {\r\n            Path path = Paths.get(directory);\r\n            try {\r\n                if (!Files.exists(path)) {\r\n                    Files.createDirectory(path);\r\n                }\r\n            } catch (IOException e) {\r\n                throw new RuntimeException(\"Failed to create directory: \" + path, e);\r\n            }\r\n            this.directory = directory;\r\n        } else {\r\n            throw new RuntimeException(String.format(\"Cannot set directory to %s because it is already has value %s\", directory, this.directory));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.asha.vrlib.model.MDQuaternion.setFromAxis",
	"Comment": "sets the quaternion components from the given axis and angle around that axis.",
	"Method": "void setFromAxis(float x,float y,float z,float degrees){\r\n    setFromAxisRad(x, y, z, degrees * MathUtils.degreesToRadians);\r\n}"
}, {
	"Path": "org.json.JSONArray.optFloat",
	"Comment": "get the optional float value associated with an index. the defaultvalueis returned if there is no value for the index, or if the value is not anumber and cannot be converted to a number.",
	"Method": "float optFloat(int index,float optFloat,int index,float defaultValue){\r\n    final Number val = this.optNumber(index, null);\r\n    if (val == null) {\r\n        return defaultValue;\r\n    }\r\n    final float floatValue = val.floatValue();\r\n    return floatValue;\r\n}"
}, {
	"Path": "org.b3log.latke.util.Times.isSameMonth",
	"Comment": "determines whether the specified date1 is the same month with the specified date2.",
	"Method": "boolean isSameMonth(Date date1,Date date2){\r\n    final Calendar cal1 = Calendar.getInstance();\r\n    cal1.setTime(date1);\r\n    final Calendar cal2 = Calendar.getInstance();\r\n    cal2.setTime(date2);\r\n    return cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH);\r\n}"
}, {
	"Path": "com.fishercoder.solutions._381.insert",
	"Comment": "inserts a value to the collection. returns true if the collection did not already contain the specified element.",
	"Method": "boolean insert(int val){\r\n    boolean contains;\r\n    if (reverseMap.containsValue(val)) {\r\n        contains = true;\r\n    } else {\r\n        contains = false;\r\n    }\r\n    forwardMap.put(val, index);\r\n    reverseMap.put(index, val);\r\n    index++;\r\n    return contains;\r\n}"
}, {
	"Path": "com.impetus.client.hbase.schemamanager.HBaseSchemaManager.getTableMetaData",
	"Comment": "get table metadata method returns the htabledescriptor of table for giventableinfo",
	"Method": "HTableDescriptor getTableMetaData(List<TableInfo> tableInfos){\r\n    HTableDescriptor tableDescriptor = new HTableDescriptor(databaseName);\r\n    Properties tableProperties = null;\r\n    schemas = HBasePropertyReader.hsmd.getDataStore() != null ? HBasePropertyReader.hsmd.getDataStore().getSchemas() : null;\r\n    if (schemas != null && !schemas.isEmpty()) {\r\n        for (Schema s : schemas) {\r\n            if (s.getName() != null && s.getName().equalsIgnoreCase(databaseName)) {\r\n                tableProperties = s.getSchemaProperties();\r\n                tables = s.getTables();\r\n            }\r\n        }\r\n    }\r\n    for (TableInfo tableInfo : tableInfos) {\r\n        if (tableInfo != null) {\r\n            HColumnDescriptor hColumnDescriptor = getColumnDescriptor(tableInfo);\r\n            tableDescriptor.addFamily(hColumnDescriptor);\r\n        }\r\n    }\r\n    if (tableProperties != null) {\r\n        for (Object o : tableProperties.keySet()) {\r\n            tableDescriptor.setValue(Bytes.toBytes(o.toString()), Bytes.toBytes(tableProperties.get(o).toString()));\r\n        }\r\n    }\r\n    return tableDescriptor;\r\n}"
}, {
	"Path": "org.b3log.latke.util.Strings.contains",
	"Comment": "determines whether the specified strings contains the specified string.",
	"Method": "boolean contains(String string,String[] strings){\r\n    if (null == strings) {\r\n        return false;\r\n    }\r\n    return Arrays.stream(strings).anyMatch(str -> StringUtils.equals(string, str));\r\n}"
}, {
	"Path": "org.json.JSONArray.optDouble",
	"Comment": "get the optional double value associated with an index. the defaultvalueis returned if there is no value for the index, or if the value is not anumber and cannot be converted to a number.",
	"Method": "double optDouble(int index,double optDouble,int index,double defaultValue){\r\n    final Number val = this.optNumber(index, null);\r\n    if (val == null) {\r\n        return defaultValue;\r\n    }\r\n    final double doubleValue = val.doubleValue();\r\n    return doubleValue;\r\n}"
}, {
	"Path": "com.impetus.kundera.property.PropertyAccessorHelper.getGenericClasses",
	"Comment": "retrieves generic class from a collection field that has only oneargument.",
	"Method": "List<Class<?>> getGenericClasses(Field collectionField){\r\n    List<Class<?>> genericClasses = new ArrayList<Class<?>>();\r\n    if (collectionField == null) {\r\n        return genericClasses;\r\n    }\r\n    Type[] parameters = ReflectUtils.getTypeArguments(collectionField);\r\n    if (parameters != null) {\r\n        for (Type parameter : parameters) {\r\n            genericClasses.add(toClass(parameter));\r\n        }\r\n    }\r\n    return genericClasses;\r\n}"
}, {
	"Path": "com.impetus.client.neo4j.GraphEntityMapper.deserializeIdAttributeValue",
	"Comment": "prepares embedded id field from value prepared viaserializeidattributevalue method.",
	"Method": "Object deserializeIdAttributeValue(EntityMetadata m,String idValue){\r\n    if (idValue == null) {\r\n        return null;\r\n    }\r\n    Class<?> embeddableClass = m.getIdAttribute().getBindableJavaType();\r\n    Object embeddedObject = embeddedObject = KunderaCoreUtils.createNewInstance(embeddableClass);\r\n    List<String> tokens = new ArrayList<String>();\r\n    StringTokenizer st = new StringTokenizer((String) idValue, COMPOSITE_KEY_SEPARATOR);\r\n    while (st.hasMoreTokens()) {\r\n        tokens.add((String) st.nextElement());\r\n    }\r\n    int count = 0;\r\n    for (Field embeddedField : embeddableClass.getDeclaredFields()) {\r\n        if (!ReflectUtils.isTransientOrStatic(embeddedField)) {\r\n            if (count < tokens.size()) {\r\n                String value = tokens.get(count++);\r\n                PropertyAccessorHelper.set(embeddedObject, embeddedField, value);\r\n            }\r\n        }\r\n    }\r\n    return embeddedObject;\r\n}"
}, {
	"Path": "com.jvmtop.openjdk.tools.MemoryPoolStat.getBeforeGcUsage",
	"Comment": "returns the memory usage before the most recent gc started.null if no gc occurs.",
	"Method": "MemoryUsage getBeforeGcUsage(){\r\n    return beforeGcUsage;\r\n}"
}, {
	"Path": "com.impetus.client.crud.PersonCassandraTTLTest.testTTLonCQL3_0",
	"Comment": "tests whether ttl provided while inserting records are correctly gettingapplied using cql 3 common ttl value for entire row is used",
	"Method": "void testTTLonCQL3_0(){\r\n    propertyMap = new HashMap();\r\n    propertyMap.put(PersistenceProperties.KUNDERA_DDL_AUTO_PREPARE, \"create\");\r\n    propertyMap.put(CassandraConstants.CQL_VERSION, CassandraConstants.CQL_VERSION_3_0);\r\n    emf = Persistence.createEntityManagerFactory(SEC_IDX_CASSANDRA_TEST, propertyMap);\r\n    em = emf.createEntityManager();\r\n    Map<String, Integer> ttlValues = new HashMap<String, Integer>();\r\n    ttlValues.put(\"PERSONCASSANDRA\", new Integer(5));\r\n    em.setProperty(\"ttl.per.request\", true);\r\n    em.setProperty(\"ttl.values\", ttlValues);\r\n    Object p1 = prepareData(\"1\", 10);\r\n    em.persist(p1);\r\n    em.clear();\r\n    CassandraCli.client.set_keyspace(\"KunderaExamples\");\r\n    CqlResult cqlResult = CassandraCli.client.execute_cql3_query(ByteBuffer.wrap(\"Select ttl(\\\"PERSON_NAME\\\"), ttl(\\\"AGE\\\") from \\\"PERSONCASSANDRA\\\" where \\\"personId\\\" = '1'\".getBytes()), Compression.NONE, ConsistencyLevel.ONE);\r\n    List<CqlRow> cqlRows = cqlResult.getRows();\r\n    CqlRow cqlRow = cqlRows.get(0);\r\n    boolean personNameFound = false;\r\n    boolean ageFound = false;\r\n    for (Column column : cqlRow.getColumns()) {\r\n        String columnName = new String(column.getName(), Constants.ENCODING);\r\n        if (columnName.equals(\"ttl(PERSON_NAME)\")) {\r\n            Assert.assertEquals(5, ByteBufferUtil.toInt(ByteBuffer.wrap(column.getValue())));\r\n            personNameFound = true;\r\n        } else if (columnName.equals(\"ttl(AGE)\")) {\r\n            Assert.assertEquals(5, ByteBufferUtil.toInt(ByteBuffer.wrap(column.getValue())));\r\n            ageFound = true;\r\n        }\r\n    }\r\n    Assert.assertTrue(personNameFound && ageFound);\r\n    Thread.sleep(5000);\r\n    cqlResult = CassandraCli.client.execute_cql3_query(ByteBuffer.wrap(\"Select ttl(\\\"PERSON_NAME\\\"), ttl(\\\"AGE\\\") from \\\"PERSONCASSANDRA\\\" where \\\"personId\\\" = '1'\".getBytes()), Compression.NONE, ConsistencyLevel.ONE);\r\n    cqlRows = cqlResult.getRows();\r\n    try {\r\n        cqlRow = cqlRows.get(0);\r\n        Assert.fail(\"PERSON_NAME and AGE column not deleted even though a TTL of 5 seconds was specified while writing to cassandra.\");\r\n    } catch (IndexOutOfBoundsException ioobe) {\r\n        Assert.assertTrue(cqlRows.isEmpty());\r\n    }\r\n    Object p2 = prepareData(\"2\", 10);\r\n    em.persist(p2);\r\n    em.clear();\r\n    ttlValues = new HashMap<String, Integer>();\r\n    ttlValues.put(\"PERSONCASSANDRA\", new Integer(10));\r\n    em.setProperty(\"ttl.per.request\", true);\r\n    em.setProperty(\"ttl.values\", ttlValues);\r\n    Query q = em.createQuery(\"update PersonCassandra p set p.personName='''KK MISHRA''' where p.personId=2\");\r\n    q.executeUpdate();\r\n    cqlResult = CassandraCli.client.execute_cql3_query(ByteBuffer.wrap(\"Select ttl(\\\"PERSON_NAME\\\"), ttl(\\\"AGE\\\") from \\\"PERSONCASSANDRA\\\" where \\\"personId\\\" = '2'\".getBytes()), Compression.NONE, ConsistencyLevel.ONE);\r\n    cqlRows = cqlResult.getRows();\r\n    cqlRow = cqlRows.get(0);\r\n    personNameFound = false;\r\n    ageFound = false;\r\n    for (Column column : cqlRow.getColumns()) {\r\n        String columnName = new String(column.getName(), Constants.ENCODING);\r\n        if (columnName.equals(\"ttl(PERSON_NAME)\")) {\r\n            Assert.assertEquals(10, ByteBufferUtil.toInt(ByteBuffer.wrap(column.getValue())));\r\n            personNameFound = true;\r\n        } else if (columnName.equals(\"ttl(AGE)\")) {\r\n            Assert.assertEquals(null, column.getValue());\r\n            ageFound = true;\r\n        }\r\n    }\r\n    Assert.assertTrue(personNameFound && ageFound);\r\n    Thread.sleep(10000);\r\n    cqlResult = CassandraCli.client.execute_cql3_query(ByteBuffer.wrap(\"Select ttl(\\\"PERSON_NAME\\\"), ttl(\\\"AGE\\\") from \\\"PERSONCASSANDRA\\\" where \\\"personId\\\" = '2'\".getBytes()), Compression.NONE, ConsistencyLevel.ONE);\r\n    cqlRows = cqlResult.getRows();\r\n    cqlRow = cqlRows.get(0);\r\n    for (Column column : cqlRow.getColumns()) {\r\n        String columnName = new String(column.getName(), Constants.ENCODING);\r\n        if (columnName.equals(\"ttl(PERSON_NAME)\")) {\r\n            Assert.assertEquals(null, null);\r\n            personNameFound = true;\r\n        } else if (columnName.equals(\"ttl(AGE)\")) {\r\n            Assert.assertEquals(null, column.getValue());\r\n            ageFound = true;\r\n        }\r\n        if (columnName.equals(\"PERSON_NAME\")) {\r\n            Assert.fail(\"PERSON_NAME column not deleted even though a TTL of 10 seconds was specified while writing to cassandra.\");\r\n        }\r\n    }\r\n    ttlValues = new HashMap<String, Integer>();\r\n    ttlValues.put(\"PERSONCASSANDRA\", new Integer(10));\r\n    em.setProperty(\"ttl.per.session\", true);\r\n    em.setProperty(\"ttl.values\", ttlValues);\r\n    Object p3 = prepareData(\"3\", 10);\r\n    em.persist(p3);\r\n    em.clear();\r\n    cqlResult = CassandraCli.client.execute_cql3_query(ByteBuffer.wrap(\"Select ttl(\\\"PERSON_NAME\\\"), ttl(\\\"AGE\\\") from \\\"PERSONCASSANDRA\\\" where \\\"personId\\\" = '3'\".getBytes()), Compression.NONE, ConsistencyLevel.ONE);\r\n    cqlRows = cqlResult.getRows();\r\n    cqlRow = cqlRows.get(0);\r\n    personNameFound = false;\r\n    ageFound = false;\r\n    for (Column column : cqlRow.getColumns()) {\r\n        String columnName = new String(column.getName(), Constants.ENCODING);\r\n        if (columnName.equals(\"ttl(PERSON_NAME)\")) {\r\n            Assert.assertEquals(10, ByteBufferUtil.toInt(ByteBuffer.wrap(column.getValue())));\r\n            personNameFound = true;\r\n        } else if (columnName.equals(\"ttl(AGE)\")) {\r\n            Assert.assertEquals(10, ByteBufferUtil.toInt(ByteBuffer.wrap(column.getValue())));\r\n            ageFound = true;\r\n        }\r\n    }\r\n    Assert.assertTrue(personNameFound && ageFound);\r\n    Thread.sleep(10000);\r\n    cqlResult = CassandraCli.client.execute_cql3_query(ByteBuffer.wrap(\"Select ttl(\\\"PERSON_NAME\\\"), ttl(\\\"AGE\\\") from \\\"PERSONCASSANDRA\\\" where \\\"personId\\\" = '3'\".getBytes()), Compression.NONE, ConsistencyLevel.ONE);\r\n    cqlRows = cqlResult.getRows();\r\n    try {\r\n        cqlRow = cqlRows.get(0);\r\n        Assert.fail(\"PERSON_NAME and AGE column not deleted even though a TTL of 5 seconds was specified while writing to cassandra.\");\r\n    } catch (IndexOutOfBoundsException ioobe) {\r\n        Assert.assertTrue(cqlRows.isEmpty());\r\n    }\r\n    Object p4 = prepareData(\"4\", 10);\r\n    ttlValues = new HashMap<String, Integer>();\r\n    ttlValues.put(\"PERSONCASSANDRA\", new Integer(10));\r\n    em.setProperty(\"ttl.per.session\", true);\r\n    em.setProperty(\"ttl.values\", ttlValues);\r\n    em.persist(p4);\r\n    em.clear();\r\n    cqlResult = CassandraCli.client.execute_cql3_query(ByteBuffer.wrap(\"Select ttl(\\\"PERSON_NAME\\\"), ttl(\\\"AGE\\\") from \\\"PERSONCASSANDRA\\\" where \\\"personId\\\" = '4'\".getBytes()), Compression.NONE, ConsistencyLevel.ONE);\r\n    cqlRows = cqlResult.getRows();\r\n    cqlRow = cqlRows.get(0);\r\n    personNameFound = false;\r\n    ageFound = false;\r\n    for (Column column : cqlRow.getColumns()) {\r\n        String columnName = new String(column.getName(), Constants.ENCODING);\r\n        if (columnName.equals(\"ttl(PERSON_NAME)\")) {\r\n            Assert.assertEquals(10, ByteBufferUtil.toInt(ByteBuffer.wrap(column.getValue())));\r\n            personNameFound = true;\r\n        } else if (columnName.equals(\"ttl(AGE)\")) {\r\n            Assert.assertEquals(10, ByteBufferUtil.toInt(ByteBuffer.wrap(column.getValue())));\r\n            ageFound = true;\r\n        }\r\n    }\r\n    Assert.assertTrue(personNameFound && ageFound);\r\n    Thread.sleep(10000);\r\n    cqlResult = CassandraCli.client.execute_cql3_query(ByteBuffer.wrap(\"Select ttl(\\\"PERSON_NAME\\\"), ttl(\\\"AGE\\\") from \\\"PERSONCASSANDRA\\\" where \\\"personId\\\" = '4'\".getBytes()), Compression.NONE, ConsistencyLevel.ONE);\r\n    cqlRows = cqlResult.getRows();\r\n    try {\r\n        cqlRow = cqlRows.get(0);\r\n        Assert.fail(\"PERSON_NAME and AGE column not deleted even though a TTL of 5 seconds was specified while writing to cassandra.\");\r\n    } catch (IndexOutOfBoundsException ioobe) {\r\n        Assert.assertTrue(cqlRows.isEmpty());\r\n    }\r\n    String deleteQuery = \"DELETE from PersonCassandra\";\r\n    q = em.createQuery(deleteQuery);\r\n    Assert.assertEquals(1, q.executeUpdate());\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.pelops.PelopsUtils.getAuthenticationRequest",
	"Comment": "if username and password provided, method prepares forauthenticationrequest.",
	"Method": "SimpleConnectionAuthenticator getAuthenticationRequest(String userName,String password){\r\n    SimpleConnectionAuthenticator authenticator = null;\r\n    if (userName != null || password != null) {\r\n        authenticator = new SimpleConnectionAuthenticator(userName, password);\r\n    }\r\n    return authenticator;\r\n}"
}, {
	"Path": "com.impetus.kundera.configure.SchemaConfiguration.getJoinColumn",
	"Comment": "getjoincolumn method return columninfo for the join column",
	"Method": "ColumnInfo getJoinColumn(TableInfo tableInfo,String joinColumnName,Class columnType){\r\n    ColumnInfo columnInfo = new ColumnInfo();\r\n    columnInfo.setColumnName(joinColumnName);\r\n    columnInfo.setIndexable(true);\r\n    IndexInfo indexInfo = new IndexInfo(joinColumnName);\r\n    tableInfo.addToIndexedColumnList(indexInfo);\r\n    columnInfo.setType(columnType);\r\n    return columnInfo;\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.CassandraClientBase.createIndexesOnColumns",
	"Comment": "creates secondary indexes on columns if not already created.",
	"Method": "void createIndexesOnColumns(EntityMetadata m,String tableName,List<Column> columns,Class columnType){\r\n    Object pooledConnection = null;\r\n    try {\r\n        Cassandra.Client api = null;\r\n        pooledConnection = getConnection();\r\n        api = (org.apache.cassandra.thrift.Cassandra.Client) getConnection(pooledConnection);\r\n        KsDef ksDef = api.describe_keyspace(m.getSchema());\r\n        List<CfDef> cfDefs = ksDef.getCf_defs();\r\n        CfDef columnFamilyDefToUpdate = null;\r\n        boolean isUpdatable = false;\r\n        for (CfDef cfDef : cfDefs) {\r\n            if (cfDef.getName().equals(tableName)) {\r\n                columnFamilyDefToUpdate = cfDef;\r\n                break;\r\n            }\r\n        }\r\n        if (columnFamilyDefToUpdate == null) {\r\n            log.error(\"Join table {} not available.\", tableName);\r\n            throw new PersistenceException(\"table\" + tableName + \" not found!\");\r\n        }\r\n        List<ColumnDef> columnMetadataList = columnFamilyDefToUpdate.getColumn_metadata();\r\n        List<String> indexList = new ArrayList<String>();\r\n        if (columnMetadataList != null) {\r\n            for (ColumnDef columnDef : columnMetadataList) {\r\n                indexList.add(new StringAccessor().fromBytes(String.class, columnDef.getName()));\r\n            }\r\n        }\r\n        for (Column column : columns) {\r\n            ColumnDef columnDef = new ColumnDef();\r\n            columnDef.setName(column.getName());\r\n            columnDef.setValidation_class(CassandraValidationClassMapper.getValidationClass(columnType, false));\r\n            columnDef.setIndex_type(IndexType.KEYS);\r\n            if (!indexList.contains(new StringAccessor().fromBytes(String.class, column.getName()))) {\r\n                isUpdatable = true;\r\n                columnFamilyDefToUpdate.addToColumn_metadata(columnDef);\r\n            }\r\n        }\r\n        if (isUpdatable) {\r\n            columnFamilyDefToUpdate.setKey_validation_class(CassandraValidationClassMapper.getValidationClass(m.getIdAttribute().getJavaType(), isCql3Enabled(m)));\r\n            api.system_update_column_family(columnFamilyDefToUpdate);\r\n        }\r\n    } catch (Exception e) {\r\n        log.warn(\"Could not create secondary index on column family {}, Caused by: . \", tableName, e);\r\n    } finally {\r\n        releaseConnection(pooledConnection);\r\n    }\r\n}"
}, {
	"Path": "org.json.HTTPTokener.nextToken",
	"Comment": "get the next token or string. this is used in parsing http headers.",
	"Method": "String nextToken(){\r\n    char c;\r\n    char q;\r\n    StringBuilder sb = new StringBuilder();\r\n    do {\r\n        c = next();\r\n    } while (Character.isWhitespace(c));\r\n    if (c == '\"' || c == '\\'') {\r\n        q = c;\r\n        for (; ; ) {\r\n            c = next();\r\n            if (c < ' ') {\r\n                throw syntaxError(\"Unterminated string.\");\r\n            }\r\n            if (c == q) {\r\n                return sb.toString();\r\n            }\r\n            sb.append(c);\r\n        }\r\n    }\r\n    for (; ; ) {\r\n        if (c == 0 || Character.isWhitespace(c)) {\r\n            return sb.toString();\r\n        }\r\n        sb.append(c);\r\n        c = next();\r\n    }\r\n}"
}, {
	"Path": "com.koloboke.collect.impl.hash.HashConfigWrapper.grow",
	"Comment": "computes grown hash table capacity for the given capacityand growth factor of this config.",
	"Method": "int grow(int capacity,long grow,long capacity){\r\n    return growthFactor.scaleLower(capacity);\r\n}"
}, {
	"Path": "org.lenskit.util.keys.Long2DoubleSortedArrayMap.getKeyByIndex",
	"Comment": "get a key by its position in the map. used for optimizing certain operations.",
	"Method": "long getKeyByIndex(int i){\r\n    return keys.getKey(i + keys.getLowerBound());\r\n}"
}, {
	"Path": "org.b3log.latke.Latkes.setStaticServerPort",
	"Comment": "sets static server port with the specified static server port.",
	"Method": "void setStaticServerPort(String staticServerPort){\r\n    Latkes.staticServerPort = staticServerPort;\r\n}"
}, {
	"Path": "org.json.JSONTokener.incrementIndexes",
	"Comment": "increments the internal indexes according to the previous characterread and the character passed as the current character.",
	"Method": "void incrementIndexes(int c){\r\n    if (c > 0) {\r\n        this.index++;\r\n        if (c == '\\r') {\r\n            this.line++;\r\n            this.characterPreviousLine = this.character;\r\n            this.character = 0;\r\n        } else if (c == '\\n') {\r\n            if (this.previous != '\\r') {\r\n                this.line++;\r\n                this.characterPreviousLine = this.character;\r\n            }\r\n            this.character = 0;\r\n        } else {\r\n            this.character++;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.b3log.latke.ioc.Bean.resolveSuperclassFieldDependencies",
	"Comment": "resolves super class field dependencies for the specified reference.",
	"Method": "void resolveSuperclassFieldDependencies(Object reference,Class<?> clazz){\r\n    if (clazz.equals(Object.class)) {\r\n        return;\r\n    }\r\n    final Class<?> superclass = clazz.getSuperclass();\r\n    resolveSuperclassFieldDependencies(reference, superclass);\r\n    if (Modifier.isAbstract(clazz.getModifiers()) || Modifier.isInterface(clazz.getModifiers())) {\r\n        return;\r\n    }\r\n    final Bean<?> bean = beanManager.getBean(clazz);\r\n    final Set<FieldInjectionPoint> injectionPoints = bean.fieldInjectionPoints;\r\n    for (final FieldInjectionPoint injectionPoint : injectionPoints) {\r\n        final Object injection = beanManager.getInjectableReference(injectionPoint);\r\n        final Field field = injectionPoint.getAnnotated().getJavaMember();\r\n        try {\r\n            final Field declaredField = proxyClass.getDeclaredField(field.getName());\r\n            if (!Reflections.matchInheritance(declaredField, field)) {\r\n                try {\r\n                    field.set(reference, injection);\r\n                } catch (final Exception e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            }\r\n        } catch (final NoSuchFieldException ex) {\r\n            throw new RuntimeException(ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.json.XMLTokener.nextMeta",
	"Comment": "returns the next xml meta token. this is used for skipping over andstructures.",
	"Method": "Object nextMeta(){\r\n    char c;\r\n    char q;\r\n    do {\r\n        c = next();\r\n    } while (Character.isWhitespace(c));\r\n    switch(c) {\r\n        case 0:\r\n            throw syntaxError(\"Misshaped meta tag\");\r\n        case '<':\r\n            return XML.LT;\r\n        case '>':\r\n            return XML.GT;\r\n        case '/':\r\n            return XML.SLASH;\r\n        case '=':\r\n            return XML.EQ;\r\n        case '!':\r\n            return XML.BANG;\r\n        case '?':\r\n            return XML.QUEST;\r\n        case '\"':\r\n        case '\\'':\r\n            q = c;\r\n            for (; ; ) {\r\n                c = next();\r\n                if (c == 0) {\r\n                    throw syntaxError(\"Unterminated string\");\r\n                }\r\n                if (c == q) {\r\n                    return Boolean.TRUE;\r\n                }\r\n            }\r\n        default:\r\n            for (; ; ) {\r\n                c = next();\r\n                if (Character.isWhitespace(c)) {\r\n                    return Boolean.TRUE;\r\n                }\r\n                switch(c) {\r\n                    case 0:\r\n                    case '<':\r\n                    case '>':\r\n                    case '/':\r\n                    case '=':\r\n                    case '!':\r\n                    case '?':\r\n                    case '\"':\r\n                    case '\\'':\r\n                        back();\r\n                        return Boolean.TRUE;\r\n                }\r\n            }\r\n    }\r\n}"
}, {
	"Path": "org.json.JSONObject.optFloat",
	"Comment": "get the optional double value associated with an index. the defaultvalueis returned if there is no value for the index, or if the value is not anumber and cannot be converted to a number.",
	"Method": "float optFloat(String key,float optFloat,String key,float defaultValue){\r\n    Number val = this.optNumber(key);\r\n    if (val == null) {\r\n        return defaultValue;\r\n    }\r\n    final float floatValue = val.floatValue();\r\n    return floatValue;\r\n}"
}, {
	"Path": "org.jupiter.serialization.proto.io.NioBufInput.skipMessage",
	"Comment": "reads and discards an entire message. this will read either until eof or until an endgroup tag, whichever comesfirst.",
	"Method": "void skipMessage(){\r\n    while (true) {\r\n        final int tag = readTag();\r\n        if (tag == 0 || !skipField(tag)) {\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.impetus.client.es.PersonESTest.matchPerson",
	"Comment": "match person to verify each field of both persones objects are same.",
	"Method": "void matchPerson(PersonES resultPerson,PersonES person){\r\n    Assert.assertNotNull(resultPerson);\r\n    Assert.assertEquals(person.getPersonId(), resultPerson.getPersonId());\r\n    Assert.assertEquals(person.getPersonName(), resultPerson.getPersonName());\r\n    Assert.assertEquals(person.getAge(), resultPerson.getAge());\r\n    Assert.assertEquals(person.getSalary(), resultPerson.getSalary());\r\n}"
}, {
	"Path": "org.json.JSONObject.optJSONObject",
	"Comment": "get an optional jsonobject associated with a key. it returns null ifthere is no such key, or if its value is not a jsonobject.",
	"Method": "JSONObject optJSONObject(String key){\r\n    Object object = this.opt(key);\r\n    return object instanceof JSONObject ? (JSONObject) object : null;\r\n}"
}, {
	"Path": "org.json.JSONObject.optBigInteger",
	"Comment": "get an optional biginteger associated with a key, or the defaultvalue ifthere is no such key or if its value is not a number. if the value is astring, an attempt will be made to evaluate it as a number.",
	"Method": "BigInteger optBigInteger(String key,BigInteger defaultValue){\r\n    Object val = this.opt(key);\r\n    return objectToBigInteger(val, defaultValue);\r\n}"
}, {
	"Path": "org.json.JSONObject.populateMap",
	"Comment": "populates the internal map of the jsonobject with the bean properties. thebean can not be recursive.",
	"Method": "void populateMap(Object bean){\r\n    Class<?> klass = bean.getClass();\r\n    boolean includeSuperClass = klass.getClassLoader() != null;\r\n    Method[] methods = includeSuperClass ? klass.getMethods() : klass.getDeclaredMethods();\r\n    for (final Method method : methods) {\r\n        final int modifiers = method.getModifiers();\r\n        if (Modifier.isPublic(modifiers) && !Modifier.isStatic(modifiers) && method.getParameterTypes().length == 0 && !method.isBridge() && method.getReturnType() != Void.TYPE && isValidMethodName(method.getName())) {\r\n            final String key = getKeyNameFromMethod(method);\r\n            if (key != null && !key.isEmpty()) {\r\n                try {\r\n                    final Object result = method.invoke(bean);\r\n                    if (result != null) {\r\n                        this.map.put(key, wrap(result));\r\n                        if (result instanceof Closeable) {\r\n                            try {\r\n                                ((Closeable) result).close();\r\n                            } catch (IOException ignore) {\r\n                            }\r\n                        }\r\n                    }\r\n                } catch (IllegalAccessException ignore) {\r\n                } catch (IllegalArgumentException ignore) {\r\n                } catch (InvocationTargetException ignore) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.impetus.client.rdbms.HibernateUtils.getCollectionFromDocumentList",
	"Comment": "creates a collection of embeddedobjectclass instanceswherein each element is java object representation of mongodb documentobject contained in documentlist. field names are determinedfrom columns.",
	"Method": "Collection<?> getCollectionFromDocumentList(Metamodel metamodel,List<Map<String, Object>> documentList,Class embeddedCollectionClass,Class embeddedObjectClass,Set<Attribute> columns){\r\n    Collection<Object> embeddedCollection = null;\r\n    if (embeddedCollectionClass.equals(Set.class)) {\r\n        embeddedCollection = new HashSet<Object>();\r\n    } else if (embeddedCollectionClass.equals(List.class)) {\r\n        embeddedCollection = new ArrayList<Object>();\r\n    } else {\r\n        throw new PersistenceException(\"Invalid collection class \" + embeddedCollectionClass + \"; only Set and List allowed\");\r\n    }\r\n    for (Map<String, Object> dbObj : documentList) {\r\n        try {\r\n            Object obj = embeddedObjectClass.newInstance();\r\n            embeddedCollection.add(getObjectFromDocument(metamodel, dbObj, columns, obj));\r\n        } catch (InstantiationException e) {\r\n            throw new PersistenceException(e);\r\n        } catch (IllegalAccessException e) {\r\n            throw new PersistenceException(e);\r\n        }\r\n    }\r\n    return embeddedCollection;\r\n}"
}, {
	"Path": "org.b3log.latke.util.Execs.exec",
	"Comment": "executes the specified commands with the specified timeout.",
	"Method": "String exec(String cmd,long timeout,String exec,String[] cmds,long timeout){\r\n    try {\r\n        final Process process = new ProcessBuilder(cmds).redirectErrorStream(true).start();\r\n        final StringWriter writer = new StringWriter();\r\n        new Thread(() -> {\r\n            try {\r\n                IOUtils.copy(process.getInputStream(), writer, \"UTF-8\");\r\n            } catch (final Exception e) {\r\n                LOGGER.log(Level.ERROR, \"Reads input stream failed: \" + e.getMessage());\r\n            }\r\n        }).start();\r\n        if (!process.waitFor(timeout, TimeUnit.MILLISECONDS)) {\r\n            LOGGER.log(Level.WARN, \"Executes commands [\" + Arrays.toString(cmds) + \"] timeout\");\r\n            process.destroy();\r\n        }\r\n        return writer.toString();\r\n    } catch (final Exception e) {\r\n        LOGGER.log(Level.ERROR, \"Executes commands [\" + Arrays.toString(cmds) + \"] failed\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.json.CDL.toString",
	"Comment": "produce a comma delimited text from a jsonarray of jsonobjects usinga provided list of names. the list of names is not included in theoutput.",
	"Method": "String toString(JSONArray ja,String toString,JSONArray names,JSONArray ja){\r\n    if (names == null || names.length() == 0) {\r\n        return null;\r\n    }\r\n    StringBuffer sb = new StringBuffer();\r\n    for (int i = 0; i < ja.length(); i += 1) {\r\n        JSONObject jo = ja.optJSONObject(i);\r\n        if (jo != null) {\r\n            sb.append(rowToString(jo.toJSONArray(names)));\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.json.JSONObject.increment",
	"Comment": "increment a property of a jsonobject. if there is no such property,create one with a value of 1. if there is such a property, and if it isan integer, long, double, or float, then add one to it.",
	"Method": "JSONObject increment(String key){\r\n    Object value = this.opt(key);\r\n    if (value == null) {\r\n        this.put(key, 1);\r\n    } else if (value instanceof BigInteger) {\r\n        this.put(key, ((BigInteger) value).add(BigInteger.ONE));\r\n    } else if (value instanceof BigDecimal) {\r\n        this.put(key, ((BigDecimal) value).add(BigDecimal.ONE));\r\n    } else if (value instanceof Integer) {\r\n        this.put(key, ((Integer) value).intValue() + 1);\r\n    } else if (value instanceof Long) {\r\n        this.put(key, ((Long) value).longValue() + 1L);\r\n    } else if (value instanceof Double) {\r\n        this.put(key, ((Double) value).doubleValue() + 1.0d);\r\n    } else if (value instanceof Float) {\r\n        this.put(key, ((Float) value).floatValue() + 1.0f);\r\n    } else {\r\n        throw new JSONException(\"Unable to increment [\" + quote(key) + \"].\");\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.impetus.kundera.persistence.EntityManagerImpl.getProperties",
	"Comment": "get the properties and hints and associated values that are in effect forthe entity manager. changing the contents of the map does not change theconfiguration in effect.",
	"Method": "Map<String, Object> getProperties(){\r\n    checkClosed();\r\n    return this.properties;\r\n}"
}, {
	"Path": "org.json.JSONObject.names",
	"Comment": "produce a jsonarray containing the names of the elements of thisjsonobject.",
	"Method": "JSONArray names(){\r\n    if (this.map.isEmpty()) {\r\n        return null;\r\n    }\r\n    return new JSONArray(this.map.keySet());\r\n}"
}, {
	"Path": "org.lenskit.util.io.StagedWrite.openOutputStream",
	"Comment": "open an output stream for the staging file.this method cannot be called multiple times.",
	"Method": "OutputStream openOutputStream(){\r\n    if (committed) {\r\n        throw new IllegalStateException(\"staged write already committed\");\r\n    } else if (opened) {\r\n        throw new IllegalStateException(\"staged write already opened\");\r\n    }\r\n    OutputStream stream = Files.newOutputStream(stagingFile, StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.CREATE_NEW);\r\n    opened = true;\r\n    return stream;\r\n}"
}, {
	"Path": "com.asha.vrlib.model.MDQuaternion.setFromAxisRad",
	"Comment": "sets the quaternion components from the given axis and angle around that axis.",
	"Method": "void setFromAxisRad(float x,float y,float z,float radians){\r\n    float d = MDVector3D.len(x, y, z);\r\n    if (d == 0f) {\r\n        idt();\r\n        return;\r\n    }\r\n    d = 1f / d;\r\n    float l_ang = radians < 0 ? MathUtils.PI2 - (-radians % MathUtils.PI2) : radians % MathUtils.PI2;\r\n    float l_sin = (float) Math.sin(l_ang / 2);\r\n    float l_cos = (float) Math.cos(l_ang / 2);\r\n    this.set(l_cos, d * x * l_sin, d * y * l_sin, d * z * l_sin);\r\n    this.nor();\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.query.ResultIterator.onCheckRelation",
	"Comment": "on check relation event, invokes populate entities and set relationalentities, in case relations are present.",
	"Method": "void onCheckRelation(){\r\n    try {\r\n        results = populateEntities(entityMetadata, client);\r\n        if (entityMetadata.isRelationViaJoinTable() || (entityMetadata.getRelationNames() != null && !(entityMetadata.getRelationNames().isEmpty()))) {\r\n            query.setRelationalEntities(results, client, entityMetadata);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new PersistenceException(\"Error while scrolling over results, Caused by :.\", e);\r\n    }\r\n}"
}, {
	"Path": "org.b3log.latke.Latkes.setLakteProps",
	"Comment": "sets latke.props with the specified props. this method is useful when you want to override behaviours of the default properties.",
	"Method": "void setLakteProps(Properties props){\r\n    Latkes.latkeProps = props;\r\n}"
}, {
	"Path": "org.lenskit.data.dao.file.TextEntitySource.toJSON",
	"Comment": "construct a json representation of this entity source, suitable for serialization to e.g. yaml.",
	"Method": "JsonNode toJSON(URI base){\r\n    Path basePath = null;\r\n    if (base != null) {\r\n        try {\r\n            basePath = Paths.get(base).getParent();\r\n        } catch (FileSystemNotFoundException ex) {\r\n        }\r\n    }\r\n    JsonNodeFactory nf = JsonNodeFactory.instance;\r\n    ObjectNode object = nf.objectNode();\r\n    object.put(\"type\", \"textfile\");\r\n    Path path = getFile();\r\n    if (basePath != null) {\r\n        path = basePath.relativize(path);\r\n    }\r\n    object.put(\"file\", path.toString().replace(File.separatorChar, '/'));\r\n    object.setAll(format.toJSON());\r\n    return object;\r\n}"
}, {
	"Path": "com.impetus.kundera.rest.resources.TransactionResource.rollback",
	"Comment": "handler for delete method requests for this resource rolls back\ttransaction for the given session",
	"Method": "String rollback(String sessionToken){\r\n    if (log.isDebugEnabled())\r\n        log.debug(\"DELETE: Session Token:\" + sessionToken);\r\n    EntityManager em = EMRepository.INSTANCE.getEM(sessionToken);\r\n    if (em == null) {\r\n        if (log.isDebugEnabled())\r\n            log.warn(\"DELETE: Session Token:\" + sessionToken + \" doesn't exist and transaction could not be rolled back\");\r\n        return ResponseCode.DELETE_TX_FAILED;\r\n    }\r\n    try {\r\n        em.getTransaction().rollback();\r\n    } catch (Exception e) {\r\n        log.error(\"DELETE: Failed: \" + e.getMessage());\r\n        return ResponseCode.DELETE_TX_FAILED;\r\n    }\r\n    return ResponseCode.DELETE_TX_SUCCESS;\r\n}"
}, {
	"Path": "com.impetus.client.cassandra.CassandraClientBase.deleteRecordFromCounterColumnFamily",
	"Comment": "deletes record for given primary key from counter column family.",
	"Method": "void deleteRecordFromCounterColumnFamily(Object pKey,String tableName,EntityMetadata metadata,ConsistencyLevel consistencyLevel){\r\n    ColumnPath path = new ColumnPath(tableName);\r\n    Cassandra.Client conn = null;\r\n    Object pooledConnection = null;\r\n    try {\r\n        pooledConnection = getConnection();\r\n        conn = (org.apache.cassandra.thrift.Cassandra.Client) getConnection(pooledConnection);\r\n        if (log.isInfoEnabled()) {\r\n            log.info(\"Removing data for counter column family {}.\", tableName);\r\n        }\r\n        conn.remove_counter((CassandraUtilities.toBytes(pKey, metadata.getIdAttribute().getJavaType())), path, consistencyLevel);\r\n    } catch (Exception e) {\r\n        log.error(\"Error during executing delete, Caused by: .\", e);\r\n        throw new PersistenceException(e);\r\n    } finally {\r\n        releaseConnection(pooledConnection);\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.data.dao.EntityQueryBuilder.copy",
	"Comment": "create a new entity query builder that is a copy of this one. future additions to either will not affect theother.",
	"Method": "EntityQueryBuilder copy(){\r\n    EntityQueryBuilder eqb = new EntityQueryBuilder(entityType);\r\n    eqb.addFilterFields(filter.build());\r\n    eqb.addSortKeys(sortKey.build());\r\n    return eqb;\r\n}"
}, {
	"Path": "com.impetus.client.mongodb.query.MongoDBQuery.createLikeRegex",
	"Comment": "create regular expression equivalent to any like operator string matchfunction.",
	"Method": "String createLikeRegex(String expr,boolean ignoreCase){\r\n    String regex = createRegex(expr, ignoreCase);\r\n    regex = regex.replace(\"_\", \".\").replace(\"%\", \".*?\");\r\n    return regex;\r\n}"
}, {
	"Path": "org.b3log.latke.servlet.AbstractServletListener.contextDestroyed",
	"Comment": "destroys the context, unregisters remote javascript services.",
	"Method": "void contextDestroyed(ServletContextEvent servletContextEvent){\r\n    LOGGER.info(\"Destroying the context....\");\r\n    Latkes.shutdown();\r\n}"
}, {
	"Path": "com.impetus.client.hbase.schemamanager.HBaseSchemaManager.update",
	"Comment": "update method update schema and table for the list of tableinfos",
	"Method": "void update(List<TableInfo> tableInfos){\r\n    createOrUpdateSchema(true);\r\n}"
}, {
	"Path": "com.impetus.client.mongodb.DocumentObjectMapper.getDocumentFromObject",
	"Comment": "creates a mongodb document object wrt a given java object. columns in thedocument correspond columns provided as list.",
	"Method": "Map<String, DBObject> getDocumentFromObject(Metamodel metaModel,Object obj,Set<Attribute> columns,String tableName){\r\n    Map<String, DBObject> embeddedObjects = new HashMap<String, DBObject>();\r\n    for (Attribute column : columns) {\r\n        String collectionName = ((AbstractAttribute) column).getTableName() != null ? ((AbstractAttribute) column).getTableName() : tableName;\r\n        DBObject dbObject = embeddedObjects.get(collectionName);\r\n        if (dbObject == null) {\r\n            dbObject = new BasicDBObject();\r\n            embeddedObjects.put(collectionName, dbObject);\r\n        }\r\n        if (((MetamodelImpl) metaModel).isEmbeddable(((AbstractAttribute) column).getBindableJavaType())) {\r\n            DefaultMongoDBDataHandler handler = new DefaultMongoDBDataHandler();\r\n            handler.onEmbeddable(column, obj, metaModel, dbObject, collectionName);\r\n        } else {\r\n            extractFieldValue(obj, dbObject, column);\r\n        }\r\n    }\r\n    return embeddedObjects;\r\n}"
}, {
	"Path": "org.b3log.latke.ioc.BeanManager.start",
	"Comment": "starts the application with the specified bean class and bean modules.",
	"Method": "void start(Collection<Class<?>> classes){\r\n    LOGGER.log(Level.DEBUG, \"Initializing Latke IoC container\");\r\n    final Configurator configurator = getInstance().getConfigurator();\r\n    if (null != classes && !classes.isEmpty()) {\r\n        configurator.createBeans(classes);\r\n    }\r\n    LOGGER.log(Level.DEBUG, \"Initialized Latke IoC container\");\r\n}"
}, {
	"Path": "org.lenskit.util.io.LKFileUtils.basename",
	"Comment": "get the basename of a file path, possibly without extension.",
	"Method": "String basename(String path,boolean keepExt){\r\n    int idx = path.lastIndexOf(File.separatorChar);\r\n    int idxUnix = path.lastIndexOf('/');\r\n    if (idxUnix > idx) {\r\n        idx = idxUnix;\r\n    }\r\n    String name = idx >= 0 ? path.substring(idx + 1) : path;\r\n    if (!keepExt) {\r\n        int eidx = name.lastIndexOf('.');\r\n        if (eidx > 0) {\r\n            name = name.substring(0, eidx);\r\n        }\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "org.b3log.latke.repository.Repository.getList",
	"Comment": "gets json objects by the specified query. calling this interface just returns result object list, no pagination info.",
	"Method": "List<JSONObject> getList(Query query){\r\n    final JSONObject result = get(query);\r\n    return CollectionUtils.jsonArrayToList(result.optJSONArray(Keys.RESULTS));\r\n}"
}, {
	"Path": "org.lenskit.LenskitConfiguration.clearRoots",
	"Comment": "clear the set of roots, removing all configured and default roots.this is almostnever desired in production, but is useful for testing.",
	"Method": "void clearRoots(){\r\n    roots.clear();\r\n}"
}]