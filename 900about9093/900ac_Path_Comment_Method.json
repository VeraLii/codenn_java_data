[{
	"Path": "mage.game.combat.CombatGroup.getDamageValueFromPermanent",
	"Comment": "there are effects that let creatures assigns combat damage equal to itstoughness rather than its power. so this method takes this into accountto get the value of damage a creature will assign",
	"Method": "int getDamageValueFromPermanent(Permanent permanent,Game game){\r\n    if (game.getCombat().useToughnessForDamage(permanent, game)) {\r\n        return permanent.getToughness().getValue();\r\n    } else {\r\n        return permanent.getPower().getValue();\r\n    }\r\n}"
}, {
	"Path": "com.networknt.service.SingletonServiceFactory.handleSingletonList",
	"Comment": "for each singleton definition, create object for the interface with the implementation class,and push it into the service map with key and implemented object.",
	"Method": "void handleSingletonList(String key,List<Object> value){\r\n    List<String> interfaceClasses = new ArrayList();\r\n    if (key.contains(\",\")) {\r\n        String[] interfaces = key.split(\",\");\r\n        interfaceClasses.addAll(Arrays.asList(interfaces));\r\n    } else {\r\n        interfaceClasses.add(key);\r\n    }\r\n    if (value != null && value.size() == 1) {\r\n        handleSingleImpl(interfaceClasses, value);\r\n    } else {\r\n        handleMultipleImpl(interfaceClasses, value);\r\n    }\r\n}"
}, {
	"Path": "com.networknt.handler.Handler.getNext",
	"Comment": "returns the instance of the next handler, rather then calling handlerequest\ton it.",
	"Method": "HttpHandler getNext(HttpServerExchange httpServerExchange,HttpHandler getNext,HttpServerExchange httpServerExchange,HttpHandler next){\r\n    if (next != null) {\r\n        return next;\r\n    }\r\n    return getNext(httpServerExchange);\r\n}"
}, {
	"Path": "com.networknt.utility.NioUtils.toByteArray",
	"Comment": "reads and returns the rest of the given input stream as a byte array.caller is responsible for closing the given input stream.",
	"Method": "byte[] toByteArray(InputStream is){\r\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\r\n    try {\r\n        byte[] b = new byte[BUFFER_SIZE];\r\n        int n = 0;\r\n        while ((n = is.read(b)) != -1) {\r\n            output.write(b, 0, n);\r\n        }\r\n        return output.toByteArray();\r\n    } finally {\r\n        output.close();\r\n    }\r\n}"
}, {
	"Path": "com.networknt.utility.ConcurrentHashSet.clear",
	"Comment": "removes all of the elements from this set. the set will be empty after this call returns.",
	"Method": "void clear(){\r\n    map.clear();\r\n}"
}, {
	"Path": "mage.player.ai.ComputerPlayer2.createSimulation",
	"Comment": "copies game and replaces all players in copy with simulated players",
	"Method": "Game createSimulation(Game game){\r\n    Game sim = game.copy();\r\n    for (Player copyPlayer : sim.getState().getPlayers().values()) {\r\n        Player origPlayer = game.getState().getPlayers().get(copyPlayer.getId()).copy();\r\n        SimulatedPlayer newPlayer = new SimulatedPlayer(copyPlayer.getId(), copyPlayer.getId().equals(playerId), maxDepth);\r\n        newPlayer.restore(origPlayer);\r\n        sim.getState().getPlayers().put(copyPlayer.getId(), newPlayer);\r\n    }\r\n    sim.setSimulation(true);\r\n    return sim;\r\n}"
}, {
	"Path": "org.lenskit.eval.crossfold.CrossfoldMethods.partitionEntities",
	"Comment": "create a crossfold method that partitions ratings into disjoint partitions.",
	"Method": "CrossfoldMethod partitionEntities(){\r\n    return new EntityPartitionCrossfoldMethod();\r\n}"
}, {
	"Path": "com.networknt.consul.ConsulHeartbeatManager.isSwitcherChange",
	"Comment": "check heart beat switcher status, if switcher is changed, then change lastheartbeatswitcherstatus\tto the latest status.",
	"Method": "boolean isSwitcherChange(boolean switcherStatus){\r\n    boolean ret = false;\r\n    if (switcherStatus != lastHeartBeatSwitcherStatus) {\r\n        ret = true;\r\n        lastHeartBeatSwitcherStatus = switcherStatus;\r\n        logger.info(\"heartbeat switcher change to \" + switcherStatus);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.whispersystems.libsignal.groups.GroupSessionBuilder.process",
	"Comment": "construct a group session for receiving messages from senderkeyname.",
	"Method": "void process(SenderKeyName senderKeyName,SenderKeyDistributionMessage senderKeyDistributionMessage){\r\n    synchronized (GroupCipher.LOCK) {\r\n        SenderKeyRecord senderKeyRecord = senderKeyStore.loadSenderKey(senderKeyName);\r\n        senderKeyRecord.addSenderKeyState(senderKeyDistributionMessage.getId(), senderKeyDistributionMessage.getIteration(), senderKeyDistributionMessage.getChainKey(), senderKeyDistributionMessage.getSignatureKey());\r\n        senderKeyStore.storeSenderKey(senderKeyName, senderKeyRecord);\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.classic.corpus.RandomUtil.gaussianAsPositiveInt",
	"Comment": "approximate a gaussian distrib with only positive integer values",
	"Method": "int gaussianAsPositiveInt(Random random,int average,int stdDeviation){\r\n    if (average < 1) {\r\n        throw new IllegalArgumentException(\"The average must not be smaller than 1.\");\r\n    }\r\n    if (stdDeviation < 1) {\r\n        throw new IllegalArgumentException(\"The stdDeviation must not be smaller than 1.\");\r\n    }\r\n    double d = random.nextGaussian() * stdDeviation + average;\r\n    int result = 1;\r\n    if (d > 1.0) {\r\n        result = (int) Math.round(d);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.networknt.url.QueryString.addString",
	"Comment": "adds one or multiple string values.adding a single null value has no effect.when adding multiple values, null values are convertedto blank strings.",
	"Method": "void addString(String key,String values){\r\n    if (values == null || Array.getLength(values) == 0) {\r\n        return;\r\n    }\r\n    List<String> list = parameters.get(key);\r\n    if (list == null) {\r\n        list = new ArrayList();\r\n    }\r\n    list.addAll(Arrays.asList(values));\r\n    parameters.put(key, list);\r\n}"
}, {
	"Path": "com.networknt.resource.PathResourceConfigHandlerTest.testPublicIndex",
	"Comment": "when an exact resource is accessed, then it will be returned immediately.",
	"Method": "void testPublicIndex(){\r\n    final Http2Client client = Http2Client.getInstance();\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    final ClientConnection connection;\r\n    try {\r\n        connection = client.connect(new URI(\"http://localhost:8080\"), Http2Client.WORKER, Http2Client.BUFFER_POOL, OptionMap.EMPTY).get();\r\n    } catch (Exception e) {\r\n        throw new ClientException(e);\r\n    }\r\n    final AtomicReference<ClientResponse> reference = new AtomicReference();\r\n    try {\r\n        ClientRequest request = new ClientRequest().setPath(\"/view/index.html\").setMethod(Methods.GET);\r\n        request.getRequestHeaders().put(Headers.HOST, \"localhost\");\r\n        connection.sendRequest(request, client.createClientCallback(reference, latch));\r\n        latch.await();\r\n    } catch (Exception e) {\r\n        logger.error(\"Exception: \", e);\r\n        throw new ClientException(e);\r\n    } finally {\r\n        IoUtils.safeClose(connection);\r\n    }\r\n    int statusCode = reference.get().getResponseCode();\r\n    String body = reference.get().getAttachment(Http2Client.RESPONSE_BODY);\r\n    Assert.assertEquals(200, statusCode);\r\n    if (statusCode == 200) {\r\n        Assert.assertTrue(body.contains(\"This is just a test\"));\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.graph.GraphDumper.setRoot",
	"Comment": "set the root node for this dumper. this must be called before any other methods.",
	"Method": "String setRoot(DAGNode<Component, Dependency> root){\r\n    if (!nodeTargets.isEmpty()) {\r\n        throw new IllegalStateException(\"root node already specificied\");\r\n    }\r\n    nodeIds.put(root, ROOT_ID);\r\n    nodeTargets.put(ROOT_ID, ROOT_ID);\r\n    writer.putNode(NodeBuilder.create(ROOT_ID).setLabel(\"root\").setShape(\"box\").add(\"style\", \"rounded\").build());\r\n    return ROOT_ID;\r\n}"
}, {
	"Path": "mage.client.deck.generator.DeckGeneratorPool.cardFitsChosenColors",
	"Comment": "checks if the mana symbols in the card all match the allowed colors for this pool.",
	"Method": "boolean cardFitsChosenColors(Card card){\r\n    for (String symbol : card.getManaCost().getSymbols()) {\r\n        boolean found = false;\r\n        symbol = symbol.replace(\"{\", \"\").replace(\"}\", \"\");\r\n        if (isColoredManaSymbol(symbol)) {\r\n            for (ColoredManaSymbol allowed : allowedColors) {\r\n                if (symbol.contains(allowed.toString())) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                return false;\r\n            }\r\n        }\r\n        if (symbol.equals(\"C\") && !colorlessAllowed) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.lenskit.util.monitor.TrackedJob.getReportingInterval",
	"Comment": "get the reporting interval for firing progress update messages.",
	"Method": "int getReportingInterval(){\r\n    return reportingInterval;\r\n}"
}, {
	"Path": "ch.qos.logback.core.util.StatusPrinter.printIfErrorsOccured",
	"Comment": "print the contents of the context statuses, but only if they containerrors.",
	"Method": "void printIfErrorsOccured(Context context){\r\n    if (context == null) {\r\n        throw new IllegalArgumentException(\"Context argument cannot be null\");\r\n    }\r\n    StatusManager sm = context.getStatusManager();\r\n    if (sm == null) {\r\n        ps.println(\"WARN: Context named \\\"\" + context.getName() + \"\\\" has no status manager\");\r\n    } else {\r\n        StatusUtil statusUtil = new StatusUtil(context);\r\n        if (statusUtil.getHighestLevel(0) == ErrorStatus.ERROR) {\r\n            print(sm);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.ssl.SSLParametersConfiguration.includedStrings",
	"Comment": "applies include and exclude patterns to an array of default string valuesto produce an array of strings included by the patterns.",
	"Method": "String[] includedStrings(String[] defaults,String included,String excluded){\r\n    List<String> values = new ArrayList<String>(defaults.length);\r\n    values.addAll(Arrays.asList(defaults));\r\n    if (included != null) {\r\n        StringCollectionUtil.retainMatching(values, stringToArray(included));\r\n    }\r\n    if (excluded != null) {\r\n        StringCollectionUtil.removeMatching(values, stringToArray(excluded));\r\n    }\r\n    return values.toArray(new String[values.size()]);\r\n}"
}, {
	"Path": "ch.qos.logback.core.android.SystemPropertiesProxy.setClassLoader",
	"Comment": "sets the classloader to lookup the class for android.os.systemproperties",
	"Method": "void setClassLoader(ClassLoader cl){\r\n    if (cl == null)\r\n        cl = this.getClass().getClassLoader();\r\n    SystemProperties = cl.loadClass(\"android.os.SystemProperties\");\r\n    getString = SystemProperties.getMethod(\"get\", new Class[] { String.class, String.class });\r\n    getBoolean = SystemProperties.getMethod(\"getBoolean\", new Class[] { String.class, boolean.class });\r\n}"
}, {
	"Path": "com.networknt.handler.Handler.start",
	"Comment": "on the first step of the request, match the request against the configured\tpaths. if the match is successful, store the chain id within the exchange.\totherwise return false.",
	"Method": "boolean start(HttpServerExchange httpServerExchange){\r\n    PathTemplateMatcher<String> pathTemplateMatcher = methodToMatcherMap.get(httpServerExchange.getRequestMethod());\r\n    if (pathTemplateMatcher != null) {\r\n        PathTemplateMatcher.PathMatchResult<String> result = pathTemplateMatcher.match(httpServerExchange.getRequestPath());\r\n        if (result != null) {\r\n            httpServerExchange.putAttachment(ATTACHMENT_KEY, new io.undertow.util.PathTemplateMatch(result.getMatchedTemplate(), result.getParameters()));\r\n            for (Map.Entry<String, String> entry : result.getParameters().entrySet()) {\r\n                httpServerExchange.addQueryParam(entry.getKey(), entry.getValue());\r\n            }\r\n            String id = result.getValue();\r\n            httpServerExchange.putAttachment(CHAIN_ID, id);\r\n            httpServerExchange.putAttachment(CHAIN_SEQ, 0);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "mage.abilities.costs.OptionalAdditionalCostImpl.getCastSuffixMessage",
	"Comment": "returns a text suffix for the game log, that can be added to the castmessage.",
	"Method": "String getCastSuffixMessage(int position){\r\n    StringBuilder sb = new StringBuilder();\r\n    if (isActivated() && (!isRepeatable() || getActivateCount() > 0)) {\r\n        sb.append(position > 0 ? \" and \" : \"\").append(\" with \");\r\n        if (isRepeatable()) {\r\n            sb.append(getActivateCount()).append(getActivateCount() > 1 ? \" times \" : \" time \");\r\n        }\r\n        sb.append(name);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "ch.qos.logback.core.spi.AppenderAttachableImpl.detachAndStopAllAppenders",
	"Comment": "remove and processpriortoremoval all previously attached appenders.",
	"Method": "void detachAndStopAllAppenders(){\r\n    for (Appender<E> a : appenderList) {\r\n        a.stop();\r\n    }\r\n    appenderList.clear();\r\n}"
}, {
	"Path": "mage.player.ai.utils.RateCard.readRatingSetList",
	"Comment": "reads the list of sets that have ratings csv filespopulates the setswithratingstobeloaded",
	"Method": "void readRatingSetList(){\r\n    try {\r\n        if (setsWithRatingsToBeLoaded == null) {\r\n            setsWithRatingsToBeLoaded = new LinkedList();\r\n            InputStream is = RateCard.class.getResourceAsStream(RATINGS_SET_LIST);\r\n            Scanner scanner = new Scanner(is);\r\n            while (scanner.hasNextLine()) {\r\n                String line = scanner.nextLine();\r\n                if (!line.substring(0, 1).equals(\"#\")) {\r\n                    setsWithRatingsToBeLoaded.add(line);\r\n                }\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        log.info(\"failed to read ratings set list file: \" + RATINGS_SET_LIST);\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.eval.crossfold.Crossfolder.execute",
	"Comment": "run the crossfold command. write the partition files to the disk by reading in the source file.",
	"Method": "void execute(){\r\n    logger.info(\"ensuring output directory {} exists\", outputDir);\r\n    Files.createDirectories(outputDir);\r\n    logger.info(\"making sure item list is available\");\r\n    JsonNode itemDataInfo = writeItemFile(source);\r\n    logger.info(\"writing train-test split files\");\r\n    createTTFiles(source);\r\n    logger.info(\"writing manifests and specs\");\r\n    Map<String, Object> metadata = new HashMap();\r\n    for (EntitySource src : source.getSourcesForType(entityType)) {\r\n        metadata.putAll(src.getMetadata());\r\n    }\r\n    writeManifests(source, metadata, itemDataInfo);\r\n    executed = true;\r\n}"
}, {
	"Path": "com.networknt.resource.ResourceHelpers.addProvidersToPathHandler",
	"Comment": "helper to add given pathresourceproviders to a pathhandler.",
	"Method": "void addProvidersToPathHandler(PathResourceProvider[] pathResourceProviders,PathHandler pathHandler){\r\n    if (pathResourceProviders != null && pathResourceProviders.length > 0) {\r\n        for (PathResourceProvider pathResourceProvider : pathResourceProviders) {\r\n            if (pathResourceProvider.isPrefixPath()) {\r\n                pathHandler.addPrefixPath(pathResourceProvider.getPath(), new ResourceHandler(pathResourceProvider.getResourceManager()));\r\n            } else {\r\n                pathHandler.addExactPath(pathResourceProvider.getPath(), new ResourceHandler(pathResourceProvider.getResourceManager()));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mage.client.components.ColorPane.setExtBackgroundColor",
	"Comment": "this method solves the known issue with nimbus laf backgroundtransparency and background color.",
	"Method": "void setExtBackgroundColor(Color color){\r\n    setBackground(new Color(0, 0, 0, 0));\r\n    JPanel jPanel = new JPanel();\r\n    jPanel.setBackground(color);\r\n    setLayout(new BorderLayout());\r\n    add(jPanel);\r\n}"
}, {
	"Path": "org.lenskit.predict.KnownRatingRatingPredictorTest.testPredictForMissingUser",
	"Comment": "test method that tests predicting for a user not in the data set",
	"Method": "void testPredictForMissingUser(){\r\n    KnownRatingRatingPredictor pred = new KnownRatingRatingPredictor(dao);\r\n    Map<Long, Double> results = pred.predict(5, LongUtils.packedSet(1L, 2L));\r\n    assertThat(results.size(), equalTo(0));\r\n}"
}, {
	"Path": "io.dropwizard.metrics.LongAdderImpl.reset",
	"Comment": "resets variables maintaining the sum to zero.this method may be a useful alternative tocreating a new adder, but is only effective if there are no concurrent updates.because thismethod is intrinsically racy, it should only be used when it is known that no threads areconcurrently updating.",
	"Method": "void reset(){\r\n    internalReset(0L);\r\n}"
}, {
	"Path": "com.networknt.utility.Util.getUUID",
	"Comment": "generate uuid across the entire app and it is used for correlationid.",
	"Method": "String getUUID(){\r\n    UUID id = UUID.randomUUID();\r\n    ByteBuffer bb = ByteBuffer.wrap(new byte[16]);\r\n    bb.putLong(id.getMostSignificantBits());\r\n    bb.putLong(id.getLeastSignificantBits());\r\n    return Base64.encodeBase64URLSafeString(bb.array());\r\n}"
}, {
	"Path": "mage.abilities.effects.ContinuousEffectsList.addEffect",
	"Comment": "adds an effect and its connected ability to the list. for each effectwill be stored, which abilities are connected to the effect. so an effectcan be connected to multiple abilities.",
	"Method": "void addEffect(T effect,Ability source){\r\n    if (effectAbilityMap.containsKey(effect.getId())) {\r\n        Set<Ability> set = effectAbilityMap.get(effect.getId());\r\n        for (Ability ability : set) {\r\n            if (ability.getId().equals(source.getId()) && ability.getSourceId().equals(source.getSourceId())) {\r\n                return;\r\n            }\r\n        }\r\n        set.add(source);\r\n        return;\r\n    }\r\n    Set<Ability> set = new HashSet();\r\n    set.add(source);\r\n    this.effectAbilityMap.put(effect.getId(), set);\r\n    this.add(effect);\r\n}"
}, {
	"Path": "mage.players.ManaPool.payX",
	"Comment": "remove all mana from pool that applies and that matches filter",
	"Method": "int payX(Ability ability,Game game,int payX,Ability ability,Game game,FilterMana filter){\r\n    if (filter == null) {\r\n        return payX(ability, game);\r\n    }\r\n    int total = 0;\r\n    Iterator<ManaPoolItem> it = manaItems.iterator();\r\n    while (it.hasNext()) {\r\n        ManaPoolItem item = it.next();\r\n        if (item.isConditional()) {\r\n            ConditionalMana c = item.getConditionalMana();\r\n            if (c.apply(ability, game, c.getManaProducerId(), null)) {\r\n                int count = c.count(filter);\r\n                if (count > 0) {\r\n                    total += count;\r\n                    c.removeAll(filter);\r\n                    if (c.count() == 0) {\r\n                        it.remove();\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (filter.isBlack()) {\r\n                total += item.getBlack();\r\n                item.removeBlack();\r\n            }\r\n            if (filter.isBlue()) {\r\n                total += item.getBlue();\r\n                item.removeBlue();\r\n            }\r\n            if (filter.isWhite()) {\r\n                total += item.getWhite();\r\n                item.removeWhite();\r\n            }\r\n            if (filter.isRed()) {\r\n                total += item.getRed();\r\n                item.removeRed();\r\n            }\r\n            if (filter.isGreen()) {\r\n                total += item.getGreen();\r\n                item.removeGreen();\r\n            }\r\n            if (filter.isGeneric()) {\r\n                total += item.getColorless();\r\n                item.removeColorless();\r\n            }\r\n            if (item.count() == 0) {\r\n                it.remove();\r\n            }\r\n        }\r\n    }\r\n    return total;\r\n}"
}, {
	"Path": "com.networknt.handler.Handler.splitClassAndName",
	"Comment": "to support multiple instances of the same class, support a naming",
	"Method": "Tuple<String, Class> splitClassAndName(String classLabel){\r\n    String[] stringNameSplit = classLabel.split(\"@\");\r\n    if (stringNameSplit.length == 1) {\r\n        try {\r\n            return new Tuple(classLabel, Class.forName(classLabel));\r\n        } catch (ClassNotFoundException e) {\r\n            throw new RuntimeException(\"Configured class: \" + classLabel + \" has not been found\");\r\n        }\r\n    } else if (stringNameSplit.length > 1) {\r\n        try {\r\n            return new Tuple(stringNameSplit[1], Class.forName(stringNameSplit[0]));\r\n        } catch (ClassNotFoundException e) {\r\n            throw new RuntimeException(\"Configured class: \" + stringNameSplit[0] + \" has not been found. Declared label was: \" + stringNameSplit[1]);\r\n        }\r\n    }\r\n    throw new RuntimeException(\"Invalid format provided for class label: \" + classLabel);\r\n}"
}, {
	"Path": "org.whispersystems.libsignal.util.KeyHelper.generateIdentityKeyPair",
	"Comment": "generate an identity key pair.clients should only do this once,at install time.",
	"Method": "IdentityKeyPair generateIdentityKeyPair(){\r\n    ECKeyPair keyPair = Curve.generateKeyPair();\r\n    IdentityKey publicKey = new IdentityKey(keyPair.getPublicKey());\r\n    return new IdentityKeyPair(publicKey, keyPair.getPrivateKey());\r\n}"
}, {
	"Path": "ch.qos.logback.classic.util.ContextSelectorStaticBinder.dynamicalContextSelector",
	"Comment": "instantiate the context selector class designated by the user. the selectormust have a constructor taking a loggercontext instance as an argument.",
	"Method": "ContextSelector dynamicalContextSelector(LoggerContext defaultLoggerContext,String contextSelectorStr){\r\n    Class<?> contextSelectorClass = Loader.loadClass(contextSelectorStr);\r\n    Constructor cons = contextSelectorClass.getConstructor(new Class[] { LoggerContext.class });\r\n    return (ContextSelector) cons.newInstance(defaultLoggerContext);\r\n}"
}, {
	"Path": "mage.client.dialog.NewTableDialog.checkMatchOptions",
	"Comment": "checks about not valid game option combinations and shows an errormessage",
	"Method": "boolean checkMatchOptions(MatchOptions options){\r\n    switch(options.getDeckType()) {\r\n        case \"Variant Magic - Commander\":\r\n        case \"Variant Magic - Duel Commander\":\r\n        case \"Variant Magic - MTGO 1v1 Commander\":\r\n            if (!options.getGameType().startsWith(\"Commander\")) {\r\n                JOptionPane.showMessageDialog(MageFrame.getDesktop(), \"Deck type Commander needs also a Commander game type\", \"Error\", JOptionPane.ERROR_MESSAGE);\r\n                return false;\r\n            }\r\n            break;\r\n        case \"Variant Magic - Brawl\":\r\n        case \"Variant Magic - Duel Brawl\":\r\n            if (!options.getGameType().startsWith(\"Brawl\")) {\r\n                JOptionPane.showMessageDialog(MageFrame.getDesktop(), \"Deck type Brawl needs also a Brawl game type\", \"Error\", JOptionPane.ERROR_MESSAGE);\r\n                return false;\r\n            }\r\n            break;\r\n        case \"Variant Magic - Tiny Leaders\":\r\n            if (!options.getGameType().startsWith(\"Tiny Leaders\")) {\r\n                JOptionPane.showMessageDialog(MageFrame.getDesktop(), \"Deck type Tiny Leaders needs also a Tiny Leaders game type\", \"Error\", JOptionPane.ERROR_MESSAGE);\r\n                return false;\r\n            }\r\n            break;\r\n        case \"Variant Magic - Momir Basic\":\r\n            if (!options.getGameType().startsWith(\"Momir Basic\")) {\r\n                JOptionPane.showMessageDialog(MageFrame.getDesktop(), \"Deck type Momir Basic needs also a Momir Basic game type\", \"Error\", JOptionPane.ERROR_MESSAGE);\r\n                return false;\r\n            }\r\n            break;\r\n    }\r\n    switch(options.getGameType()) {\r\n        case \"Commander Two Player Duel\":\r\n        case \"Commander Free For All\":\r\n            if (!options.getDeckType().equals(\"Variant Magic - Commander\") && !options.getDeckType().equals(\"Variant Magic - Duel Commander\") && !options.getDeckType().equals(\"Variant Magic - MTGO 1v1 Commander\")) {\r\n                JOptionPane.showMessageDialog(MageFrame.getDesktop(), \"Deck type Commander needs also a Commander game type\", \"Error\", JOptionPane.ERROR_MESSAGE);\r\n                return false;\r\n            }\r\n            break;\r\n        case \"Brawl Two Player Duel\":\r\n        case \"Brawl Free For All\":\r\n            if (!options.getDeckType().equals(\"Variant Magic - Brawl\") && !options.getDeckType().equals(\"Variant Magic - Duel Brawl\")) {\r\n                JOptionPane.showMessageDialog(MageFrame.getDesktop(), \"Deck type Brawl needs also a Brawl game type\", \"Error\", JOptionPane.ERROR_MESSAGE);\r\n                return false;\r\n            }\r\n            break;\r\n        case \"Tiny Leaders Two Player Duel\":\r\n            if (!options.getDeckType().equals(\"Variant Magic - Tiny Leaders\")) {\r\n                JOptionPane.showMessageDialog(MageFrame.getDesktop(), \"Deck type Tiny Leaders needs also a Tiny Leaders game type\", \"Error\", JOptionPane.ERROR_MESSAGE);\r\n                return false;\r\n            }\r\n            break;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.lenskit.eval.traintest.SimpleEvaluator.execute",
	"Comment": "if this is called more than once it will call of these commands again and most likely throw an exception.",
	"Method": "Table execute(){\r\n    for (Crossfolder cf : crossfolders) {\r\n        try {\r\n            cf.execute();\r\n        } catch (IOException e) {\r\n            throw new UncheckedIOException(e);\r\n        }\r\n        experiment.addDataSets(cf.getDataSets());\r\n    }\r\n    return experiment.execute();\r\n}"
}, {
	"Path": "com.networknt.balance.RoundRobinLoadBalance.select",
	"Comment": "round robin requestkey is not used as it should be null, the url willbe selected from the list base on an instance idx so every url has thesame priority.",
	"Method": "URL select(List<URL> urls,String requestKey){\r\n    URL url = null;\r\n    if (urls.size() > 1) {\r\n        url = doSelect(urls);\r\n    } else if (urls.size() == 1) {\r\n        url = urls.get(0);\r\n    }\r\n    return url;\r\n}"
}, {
	"Path": "mage.abilities.effects.ContinuousRuleModifyingEffectImpl.checksEventType",
	"Comment": "an early check for the event types this effect applies to. this check wasadded to speed up event handling. once all existingcontinuousrulemodifiyingeffects have implemented this method, the methodshould be changed to abstract here or removed.",
	"Method": "boolean checksEventType(GameEvent event,Game game){\r\n    return true;\r\n}"
}, {
	"Path": "mage.client.components.layout.RelativeLayout.adjustLargest",
	"Comment": "largest component using relative sizing gets all the space. when multiple components are the same size, the last one found is used.",
	"Method": "void adjustLargest(int[] relativeSpace,int spaceRemaining){\r\n    int largest = 0;\r\n    int largestSpace = 0;\r\n    for (int i = 0; i < relativeSpace.length; i++) {\r\n        int space = relativeSpace[i];\r\n        if (space > 0 && largestSpace < space) {\r\n            largestSpace = space;\r\n            largest = i;\r\n        }\r\n    }\r\n    relativeSpace[largest] += spaceRemaining;\r\n}"
}, {
	"Path": "org.lenskit.util.keys.SortedKeyIndex.findUpperBound",
	"Comment": "get the upper bound, the first index whose key is greater than the specified key.",
	"Method": "int findUpperBound(long key){\r\n    int index = tryGetIndex(key);\r\n    if (index >= 0) {\r\n        return index + 1;\r\n    } else {\r\n        return -index - 1;\r\n    }\r\n}"
}, {
	"Path": "org.mage.plugins.card.images.ImageCache.getFaceImage",
	"Comment": "returns the image appropriate to display the card in the picture panel",
	"Method": "BufferedImage getFaceImage(String key,BufferedImage getFaceImage,CardView card,int width,int height){\r\n    String key = getFaceKey(card, card.getName(), card.getExpansionSetCode());\r\n    BufferedImage original = getFaceImage(key);\r\n    if (original == null) {\r\n        LOGGER.debug(key + \" (faceimage) not found\");\r\n        return null;\r\n    }\r\n    return original;\r\n}"
}, {
	"Path": "org.lenskit.mf.funksvd.FunkSVDTrainingUpdater.getUpdateCount",
	"Comment": "get the number of updates this updater has prepared since the last reset.",
	"Method": "int getUpdateCount(){\r\n    return n;\r\n}"
}, {
	"Path": "mage.Mana.getDifferentColors",
	"Comment": "returns the total count of mana colors that have at least one.",
	"Method": "int getDifferentColors(){\r\n    int count = 0;\r\n    if (blue > 0) {\r\n        count++;\r\n    }\r\n    if (black > 0) {\r\n        count++;\r\n    }\r\n    if (green > 0) {\r\n        count++;\r\n    }\r\n    if (white > 0) {\r\n        count++;\r\n    }\r\n    if (red > 0) {\r\n        count++;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "ch.qos.logback.core.OutputStreamAppender.stop",
	"Comment": "stop this appender instance. the underlying stream or writer is alsoclosed.stopped appenders cannot be reused.",
	"Method": "void stop(){\r\n    lock.lock();\r\n    try {\r\n        closeOutputStream();\r\n        super.stop();\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "mage.cards.Sets.generateRandomCardPool",
	"Comment": "generates card pool of cardscount cards that have manacost of allowedcolors.",
	"Method": "List<Card> generateRandomCardPool(int cardsCount,List<ColoredManaSymbol> allowedColors,List<Card> generateRandomCardPool,int cardsCount,List<ColoredManaSymbol> allowedColors,boolean onlyBasicLands){\r\n    CardCriteria criteria = new CardCriteria();\r\n    if (onlyBasicLands) {\r\n        criteria.rarities(Rarity.LAND);\r\n        criteria.colorless(true);\r\n    } else {\r\n        criteria.notTypes(CardType.LAND);\r\n        criteria.white(false);\r\n        criteria.blue(false);\r\n        criteria.black(false);\r\n        criteria.red(false);\r\n        criteria.green(false);\r\n        criteria.colorless(false);\r\n    }\r\n    FilterMana manaNeed = new FilterMana();\r\n    for (ColoredManaSymbol color : allowedColors) {\r\n        switch(color) {\r\n            case W:\r\n                manaNeed.setWhite(true);\r\n                criteria.white(true);\r\n                break;\r\n            case U:\r\n                manaNeed.setBlue(true);\r\n                criteria.blue(true);\r\n                break;\r\n            case B:\r\n                manaNeed.setBlack(true);\r\n                criteria.black(true);\r\n                break;\r\n            case R:\r\n                manaNeed.setRed(true);\r\n                criteria.red(true);\r\n                break;\r\n            case G:\r\n                manaNeed.setGreen(true);\r\n                criteria.green(true);\r\n                break;\r\n        }\r\n    }\r\n    List<CardInfo> cards = CardRepository.instance.findCards(criteria);\r\n    int count = 0;\r\n    int tries = 0;\r\n    List<Card> cardPool = new ArrayList();\r\n    while (count < cardsCount) {\r\n        CardInfo cardInfo = cards.get(RandomUtil.nextInt(cards.size()));\r\n        Card card = cardInfo != null ? cardInfo.getCard() : null;\r\n        if (card != null) {\r\n            FilterMana manaCard = card.getColorIdentity();\r\n            boolean cardManaOK = true;\r\n            if (onlyBasicLands) {\r\n                Assert.assertEquals(\"only basic lands allow, but found \" + card.getName(), 1, card.getMana().size());\r\n                for (Mana manaLand : card.getMana()) {\r\n                    if (manaLand.getWhite() > 0 && !manaNeed.isWhite()) {\r\n                        cardManaOK = false;\r\n                    }\r\n                    if (manaLand.getBlue() > 0 && !manaNeed.isBlue()) {\r\n                        cardManaOK = false;\r\n                    }\r\n                    if (manaLand.getBlack() > 0 && !manaNeed.isBlack()) {\r\n                        cardManaOK = false;\r\n                    }\r\n                    if (manaLand.getRed() > 0 && !manaNeed.isRed()) {\r\n                        cardManaOK = false;\r\n                    }\r\n                    if (manaLand.getGreen() > 0 && !manaNeed.isGreen()) {\r\n                        cardManaOK = false;\r\n                    }\r\n                    if (manaLand.getColorless() > 0) {\r\n                        cardManaOK = false;\r\n                    }\r\n                }\r\n            } else {\r\n                if (manaCard.isWhite() && !manaNeed.isWhite()) {\r\n                    cardManaOK = false;\r\n                }\r\n                if (manaCard.isBlue() && !manaNeed.isBlue()) {\r\n                    cardManaOK = false;\r\n                }\r\n                if (manaCard.isBlack() && !manaNeed.isBlack()) {\r\n                    cardManaOK = false;\r\n                }\r\n                if (manaCard.isRed() && !manaNeed.isRed()) {\r\n                    cardManaOK = false;\r\n                }\r\n                if (manaCard.isGreen() && !manaNeed.isGreen()) {\r\n                    cardManaOK = false;\r\n                }\r\n            }\r\n            if (cardManaOK) {\r\n                cardPool.add(card);\r\n                count++;\r\n            }\r\n        }\r\n        tries++;\r\n        if (tries > 4096) {\r\n            throw new IllegalStateException(\"Not enough cards for chosen colors to generate deck: \" + allowedColors);\r\n        }\r\n    }\r\n    return cardPool;\r\n}"
}, {
	"Path": "com.networknt.service.SingletonServiceFactory.getBeans",
	"Comment": "get a list of cached singleton objects from service map by interface class. if thereis only one object in the servicemap, then construct the list with this only object.",
	"Method": "T[] getBeans(Class<T> interfaceClass){\r\n    Object object = serviceMap.get(interfaceClass.getName());\r\n    if (object == null)\r\n        return null;\r\n    if (object instanceof Object[]) {\r\n        return (T[]) object;\r\n    } else {\r\n        Object array = Array.newInstance(interfaceClass, 1);\r\n        Array.set(array, 0, object);\r\n        return (T[]) array;\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.util.Loader.getClassLoaderOfObject",
	"Comment": "get the class loader of the object passed as argument. return the systemclass loader if appropriate.",
	"Method": "ClassLoader getClassLoaderOfObject(Object o){\r\n    if (o == null) {\r\n        throw new NullPointerException(\"Argument cannot be null\");\r\n    }\r\n    return getClassLoaderOfClass(o.getClass());\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.ssl.SSLParametersConfiguration.setNeedClientAuth",
	"Comment": "sets a flag indicating whether client authentication is required.",
	"Method": "void setNeedClientAuth(Boolean needClientAuth){\r\n    this.needClientAuth = needClientAuth;\r\n}"
}, {
	"Path": "mage.server.util.SystemUtil.swapWithAnyCard",
	"Comment": "swap cards between specified card from library and any hand card.",
	"Method": "void swapWithAnyCard(Game game,Player player,Card card,Zone zone){\r\n    game.getExile().getPermanentExile().add(card);\r\n    game.setZone(card.getId(), Zone.EXILED);\r\n    switch(zone) {\r\n        case BATTLEFIELD:\r\n            card.putOntoBattlefield(game, Zone.EXILED, null, player.getId());\r\n            break;\r\n        case LIBRARY:\r\n            card.setZone(Zone.LIBRARY, game);\r\n            game.getExile().getPermanentExile().remove(card);\r\n            player.getLibrary().putOnTop(card, game);\r\n            break;\r\n        default:\r\n            card.moveToZone(zone, null, game, false);\r\n    }\r\n    logger.info(\"Added card to player's \" + zone.toString() + \": \" + card.getName() + \", player = \" + player.getName());\r\n}"
}, {
	"Path": "mage.watchers.common.PlayerDamagedBySourceWatcher.hasSourceDoneDamage",
	"Comment": "checks if the current object with sourceid has damaged the player during the current turn.the zonechangecounter will be taken into account.",
	"Method": "boolean hasSourceDoneDamage(UUID sourceId,Game game){\r\n    return damageSourceIds.contains(CardUtil.getCardZoneString(null, sourceId, game));\r\n}"
}, {
	"Path": "mage.Mana.setColorless",
	"Comment": "sets the total colorless mana. can not be negative. negative values willbe logged and set to 0.",
	"Method": "void setColorless(int colorless){\r\n    this.colorless = notNegative(colorless, \"Colorless\");\r\n}"
}, {
	"Path": "org.lenskit.util.monitor.TrackedJob.getExpectedSteps",
	"Comment": "get the estimated number of steps.this doesinclude children.",
	"Method": "int getExpectedSteps(){\r\n    return expectedSteps;\r\n}"
}, {
	"Path": "com.networknt.handler.Handler.initMapDefinedHandler",
	"Comment": "helper method for generating the instance of a handler from its map\tdefinition in config. ie. no mapped values for setters, or list of\tconstructor fields.",
	"Method": "void initMapDefinedHandler(Map<String, Object> handler){\r\n    for (Map.Entry<String, Object> entry : handler.entrySet()) {\r\n        Tuple<String, Class> namedClass = splitClassAndName(entry.getKey());\r\n        if (entry.getValue() instanceof Map) {\r\n            HttpHandler httpHandler;\r\n            try {\r\n                httpHandler = (HttpHandler) ServiceUtil.constructByNamedParams(namedClass.second, (Map) entry.getValue());\r\n            } catch (Exception e) {\r\n                throw new RuntimeException(\"Could not construct a handler with values provided as a map: \" + namedClass.second);\r\n            }\r\n            registerMiddlewareHandler(httpHandler);\r\n            handlers.put(namedClass.first, httpHandler);\r\n            handlerListById.put(namedClass.first, Collections.singletonList(httpHandler));\r\n        } else if (entry.getValue() instanceof List) {\r\n            HttpHandler httpHandler;\r\n            try {\r\n                httpHandler = (HttpHandler) ServiceUtil.constructByParameterizedConstructor(namedClass.second, (List) entry.getValue());\r\n            } catch (Exception e) {\r\n                throw new RuntimeException(\"Could not construct a handler with values provided as a list: \" + namedClass.second);\r\n            }\r\n            registerMiddlewareHandler(httpHandler);\r\n            handlers.put(namedClass.first, httpHandler);\r\n            handlerListById.put(namedClass.first, Collections.singletonList(httpHandler));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mage.game.GameImpl.fireSelectTargetTriggeredAbilityEvent",
	"Comment": "only used from human players to select order triggered abilities go tothe stack.",
	"Method": "void fireSelectTargetTriggeredAbilityEvent(UUID playerId,String message,List<TriggeredAbility> abilities){\r\n    playerQueryEventSource.target(playerId, message, abilities);\r\n}"
}, {
	"Path": "ch.qos.logback.core.html.HTMLLayoutBase.setPattern",
	"Comment": "set the conversionpattern option. this is the string which controlsformatting and consists of a mix of literal content and conversionspecifiers.",
	"Method": "void setPattern(String conversionPattern){\r\n    pattern = conversionPattern;\r\n}"
}, {
	"Path": "io.dropwizard.metrics.WeightedSnapshot.getMean",
	"Comment": "returns the weighted arithmetic mean of the values in the snapshot.",
	"Method": "double getMean(){\r\n    if (values.length == 0) {\r\n        return 0;\r\n    }\r\n    double sum = 0;\r\n    for (int i = 0; i < values.length; i++) {\r\n        sum += values[i] * normWeights[i];\r\n    }\r\n    return sum;\r\n}"
}, {
	"Path": "ch.qos.logback.core.FileAppender.setFile",
	"Comment": "the file property takes a string value which should be the name ofthe file to append to.",
	"Method": "void setFile(String file){\r\n    if (file == null) {\r\n        fileName = null;\r\n    } else {\r\n        fileName = file.trim();\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.joran.action.AbstractEventEvaluatorAction.begin",
	"Comment": "instantiates an evaluator of the given class and sets its name.",
	"Method": "void begin(InterpretationContext ec,String name,Attributes attributes){\r\n    inError = false;\r\n    evaluator = null;\r\n    String className = attributes.getValue(CLASS_ATTRIBUTE);\r\n    if (OptionHelper.isEmpty(className)) {\r\n        className = defaultClassName();\r\n        addInfo(\"Assuming default evaluator class [\" + className + \"]\");\r\n    }\r\n    if (OptionHelper.isEmpty(className)) {\r\n        className = defaultClassName();\r\n        inError = true;\r\n        addError(\"Mandatory \\\"\" + CLASS_ATTRIBUTE + \"\\\" attribute not set for <evaluator>\");\r\n        return;\r\n    }\r\n    String evaluatorName = attributes.getValue(Action.NAME_ATTRIBUTE);\r\n    if (OptionHelper.isEmpty(evaluatorName)) {\r\n        inError = true;\r\n        addError(\"Mandatory \\\"\" + NAME_ATTRIBUTE + \"\\\" attribute not set for <evaluator>\");\r\n        return;\r\n    }\r\n    try {\r\n        evaluator = (EventEvaluator<?>) OptionHelper.instantiateByClassName(className, ch.qos.logback.core.boolex.EventEvaluator.class, context);\r\n        evaluator.setContext(this.context);\r\n        evaluator.setName(evaluatorName);\r\n        ec.pushObject(evaluator);\r\n        addInfo(\"Adding evaluator named [\" + evaluatorName + \"] to the object stack\");\r\n    } catch (Exception oops) {\r\n        inError = true;\r\n        addError(\"Could not create evaluator of type \" + className + \"].\", oops);\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.SyslogAppenderBase.facilityStringToint",
	"Comment": "returns the integer value corresponding to the named syslog facility.",
	"Method": "int facilityStringToint(String facilityStr){\r\n    if (\"KERN\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_KERN;\r\n    } else if (\"USER\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_USER;\r\n    } else if (\"MAIL\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_MAIL;\r\n    } else if (\"DAEMON\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_DAEMON;\r\n    } else if (\"AUTH\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_AUTH;\r\n    } else if (\"SYSLOG\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_SYSLOG;\r\n    } else if (\"LPR\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_LPR;\r\n    } else if (\"NEWS\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_NEWS;\r\n    } else if (\"UUCP\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_UUCP;\r\n    } else if (\"CRON\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_CRON;\r\n    } else if (\"AUTHPRIV\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_AUTHPRIV;\r\n    } else if (\"FTP\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_FTP;\r\n    } else if (\"NTP\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_NTP;\r\n    } else if (\"AUDIT\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_AUDIT;\r\n    } else if (\"ALERT\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_ALERT;\r\n    } else if (\"CLOCK\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_CLOCK;\r\n    } else if (\"LOCAL0\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_LOCAL0;\r\n    } else if (\"LOCAL1\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_LOCAL1;\r\n    } else if (\"LOCAL2\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_LOCAL2;\r\n    } else if (\"LOCAL3\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_LOCAL3;\r\n    } else if (\"LOCAL4\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_LOCAL4;\r\n    } else if (\"LOCAL5\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_LOCAL5;\r\n    } else if (\"LOCAL6\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_LOCAL6;\r\n    } else if (\"LOCAL7\".equalsIgnoreCase(facilityStr)) {\r\n        return SyslogConstants.LOG_LOCAL7;\r\n    } else {\r\n        throw new IllegalArgumentException(facilityStr + \" is not a valid syslog facility string\");\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.server.AbstractServerSocketAppender.getBacklog",
	"Comment": "gets the listener queue depth.this represents the number of connected clients whose connectionshave not yet been accepted.",
	"Method": "int getBacklog(){\r\n    return backlog;\r\n}"
}, {
	"Path": "com.networknt.header.HeaderHandler.handleRequest",
	"Comment": "check iterate the configuration on both request and response section and updateheaders accordingly.",
	"Method": "void handleRequest(HttpServerExchange exchange){\r\n    Map<String, Object> requestHeaderMap = (Map<String, Object>) config.get(REQUEST);\r\n    if (requestHeaderMap != null) {\r\n        List<String> requestHeaderRemove = (List<String>) requestHeaderMap.get(REMOVE);\r\n        if (requestHeaderRemove != null) {\r\n            requestHeaderRemove.forEach(s -> exchange.getRequestHeaders().remove(s));\r\n        }\r\n        Map<String, String> requestHeaderUpdate = (Map<String, String>) requestHeaderMap.get(UPDATE);\r\n        if (requestHeaderUpdate != null) {\r\n            requestHeaderUpdate.forEach((k, v) -> exchange.getRequestHeaders().put(new HttpString(k), v));\r\n        }\r\n    }\r\n    Map<String, Object> responseHeaderMap = (Map<String, Object>) config.get(RESPONSE);\r\n    if (responseHeaderMap != null) {\r\n        List<String> responseHeaderRemove = (List<String>) responseHeaderMap.get(REMOVE);\r\n        if (responseHeaderRemove != null) {\r\n            responseHeaderRemove.forEach(s -> exchange.getResponseHeaders().remove(s));\r\n        }\r\n        Map<String, String> responseHeaderUpdate = (Map<String, String>) responseHeaderMap.get(UPDATE);\r\n        if (responseHeaderUpdate != null) {\r\n            responseHeaderUpdate.forEach((k, v) -> exchange.getResponseHeaders().put(new HttpString(k), v));\r\n        }\r\n    }\r\n    Handler.next(exchange, next);\r\n}"
}, {
	"Path": "com.networknt.utility.ConcurrentHashSet.iterator",
	"Comment": "returns an iterator over the elements in this set. the elements are returned in no particularorder.",
	"Method": "Iterator<E> iterator(){\r\n    return map.keySet().iterator();\r\n}"
}, {
	"Path": "com.networknt.registry.URLImpl.getIdentity",
	"Comment": "return service identity, if two urls have the same identity, then same service",
	"Method": "String getIdentity(){\r\n    return protocol + Constants.PROTOCOL_SEPARATOR + host + \":\" + port + \"/\" + getParameter(URLParamType.group.getName(), URLParamType.group.getValue()) + \"/\" + getPath() + \"/\" + getParameter(URLParamType.version.getName(), URLParamType.version.getValue()) + \"/\" + getParameter(URLParamType.nodeType.getName(), URLParamType.nodeType.getValue());\r\n}"
}, {
	"Path": "mage.client.util.layout.impl.OldCardLayoutStrategy.getVerticalCul",
	"Comment": "the root permanent is col 0. an attachment attached to the root is col 1. and an attachement attached to the first attachment is col 2. etc.",
	"Method": "int getVerticalCul(PermanentView permanentView,BattlefieldPanel battlefieldPanel){\r\n    int cul = 0;\r\n    if (permanentView.isAttachedTo()) {\r\n        PermanentView attachedToPermanent = battlefieldPanel.getBattlefield().get(permanentView.getAttachedTo());\r\n        if (attachedToPermanent != null) {\r\n            cul = getVerticalCul(attachedToPermanent, battlefieldPanel);\r\n        }\r\n        cul++;\r\n    }\r\n    return cul;\r\n}"
}, {
	"Path": "mage.client.deck.generator.DeckGeneratorPool.landProducesChosenColors",
	"Comment": "returns if this land will produce the chosen colors for this pool.",
	"Method": "boolean landProducesChosenColors(Card card){\r\n    List<Ability> landAbilities = card.getAbilities();\r\n    int count = 0;\r\n    for (Ability ability : landAbilities) {\r\n        String abilityString = ability.getRule();\r\n        for (ColoredManaSymbol symbol : allowedColors) {\r\n            if (landTapsForAllowedColor(abilityString, symbol.toString())) {\r\n                count++;\r\n            }\r\n        }\r\n        if (count > 1) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "mage.game.Game.getOpponents",
	"Comment": "returns a set of opponents in range for the given playerid this returnalso a player, that has dies this turn.",
	"Method": "Set<UUID> getOpponents(UUID playerId){\r\n    Player player = getPlayer(playerId);\r\n    return player.getInRange().stream().filter(opponentId -> !opponentId.equals(playerId)).collect(Collectors.toSet());\r\n}"
}, {
	"Path": "ch.qos.logback.core.pattern.DynamicConverter.getFirstOption",
	"Comment": "return the first option passed to this component. the returned value may benull if there are no options.",
	"Method": "String getFirstOption(){\r\n    if (optionList == null || optionList.size() == 0) {\r\n        return null;\r\n    } else {\r\n        return optionList.get(0);\r\n    }\r\n}"
}, {
	"Path": "mage.client.components.layout.RelativeLayout.getLayoutAlignmentX",
	"Comment": "returns the alignment along the x axis. use center alignment.",
	"Method": "float getLayoutAlignmentX(Container parent){\r\n    return 0.5f;\r\n}"
}, {
	"Path": "mage.client.components.layout.RelativeLayout.getLayoutAlignmentY",
	"Comment": "returns the alignment along the y axis. use center alignment.",
	"Method": "float getLayoutAlignmentY(Container parent){\r\n    return 0.5f;\r\n}"
}, {
	"Path": "mage.abilities.effects.common.continuous.GainAbilityTargetEffect.setDurationToPhase",
	"Comment": "used to set a duration to the next durationphasestep of the firstcontroller of the effect.",
	"Method": "void setDurationToPhase(PhaseStep phaseStep){\r\n    durationPhaseStep = phaseStep;\r\n}"
}, {
	"Path": "com.networknt.url.QueryString.applyOnURL",
	"Comment": "apply this url querystring on the given url. if a query string alreadyexists, it is replaced by this one.",
	"Method": "String applyOnURL(String url,URL applyOnURL,URL url){\r\n    if (url == null) {\r\n        return url;\r\n    }\r\n    try {\r\n        return new URL(applyOnURL(url.toString()));\r\n    } catch (MalformedURLException e) {\r\n        throw new RuntimeException(\"Cannot applyl query string to: \" + url, e);\r\n    }\r\n}"
}, {
	"Path": "mage.util.FastByteArrayOutputStream.getInputStream",
	"Comment": "returns a bytearrayinputstream for reading back the written data",
	"Method": "InputStream getInputStream(){\r\n    return new FastByteArrayInputStream(buf, size);\r\n}"
}, {
	"Path": "org.lenskit.eval.crossfold.CrossfoldMethods.partitionItems",
	"Comment": "create a crossfold method that splits items into disjoint partitions.",
	"Method": "CrossfoldMethod partitionItems(HistoryPartitionMethod part){\r\n    return new GroupedCrossfoldMethod(CommonTypes.ITEM, CommonAttributes.ITEM_ID, GroupEntitySplitter.partition(), SortOrder.RANDOM, part);\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.SyslogAppenderBase.setPort",
	"Comment": "the port number on the syslog server to connect to. normally, you would notwant to change the default value, that is 514.",
	"Method": "void setPort(int port){\r\n    this.port = port;\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.ssl.SSLParametersConfiguration.isWantClientAuth",
	"Comment": "gets a flag indicating whether client authentication is desired.",
	"Method": "Boolean isWantClientAuth(){\r\n    return wantClientAuth;\r\n}"
}, {
	"Path": "mage.abilities.Modes.getKey",
	"Comment": "creates the key the selected modes are saved with to the state values",
	"Method": "String getKey(Ability source,Game game,UUID modeId){\r\n    return source.getSourceId().toString() + game.getState().getZoneChangeCounter(source.getSourceId()) + modeId.toString();\r\n}"
}, {
	"Path": "ch.qos.logback.core.spi.FilterAttachableImpl.getFilterChainDecision",
	"Comment": "loop through the filters in the list. as soon as a filter decides onaccept or deny, then that value is returned. if all of the filters returnneutral, then neutral is returned.",
	"Method": "FilterReply getFilterChainDecision(E event){\r\n    final Filter<E>[] filterArrray = filterList.asTypedArray();\r\n    final int len = filterArrray.length;\r\n    for (int i = 0; i < len; i++) {\r\n        final FilterReply r = filterArrray[i].decide(event);\r\n        if (r == FilterReply.DENY || r == FilterReply.ACCEPT) {\r\n            return r;\r\n        }\r\n    }\r\n    return FilterReply.NEUTRAL;\r\n}"
}, {
	"Path": "mage.game.combat.Combat.isCreatureDoingARequiredBlock",
	"Comment": "checks if a possible creature for a block is already doing anotherrequired block",
	"Method": "String isCreatureDoingARequiredBlock(UUID possibleBlockerId,UUID toBeBlockedCreatureId,Map<UUID, Set<UUID>> mustBeBlockedByAtLeastX,Game game){\r\n    Permanent possibleBlocker = game.getPermanent(possibleBlockerId);\r\n    if (possibleBlocker != null) {\r\n        if (possibleBlocker.getBlocking() == 0) {\r\n            return possibleBlocker.getIdName() + \" does not block, but could block creatures with requirement to be blocked.\";\r\n        }\r\n        Set<UUID> forcingAttackers = creatureMustBlockAttackers.get(possibleBlockerId);\r\n        if (forcingAttackers == null) {\r\n            if (possibleBlocker.getBlocking() > 0) {\r\n                CombatGroup combatGroupOfPossibleBlocker = findGroupOfBlocker(possibleBlockerId);\r\n                if (combatGroupOfPossibleBlocker != null) {\r\n                    for (UUID blockedAttackerId : combatGroupOfPossibleBlocker.getAttackers()) {\r\n                        if (mustBeBlockedByAtLeastX.containsKey(blockedAttackerId)) {\r\n                            if (combatGroupOfPossibleBlocker.getBlockers().size() == 1) {\r\n                                Set<UUID> blockedSet = mustBeBlockedByAtLeastX.get(blockedAttackerId);\r\n                                Set<UUID> toBlockSet = mustBeBlockedByAtLeastX.get(toBeBlockedCreatureId);\r\n                                if (toBlockSet == null) {\r\n                                    return null;\r\n                                } else if (toBlockSet.containsAll(blockedSet)) {\r\n                                    return null;\r\n                                }\r\n                            }\r\n                            Permanent blockedAttacker = game.getPermanent(blockedAttackerId);\r\n                            return possibleBlocker.getIdName() + \" blocks with other creatures \" + blockedAttacker.getIdName() + \", which has to be blocked by only one creature. \";\r\n                        }\r\n                        Permanent blockedAttacker = game.getPermanent(blockedAttackerId);\r\n                        return possibleBlocker.getIdName() + \" blocks \" + blockedAttacker.getIdName() + \", which not has to be blocked as a requirement.\";\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "mage.abilities.effects.common.ManaEffect.checkToFirePossibleEvents",
	"Comment": "only used for mana effects that decide which kind of mana is producedduring resolution of the effect.",
	"Method": "void checkToFirePossibleEvents(Mana mana,Game game,Ability source){\r\n    if (source.getAbilityType() == AbilityType.MANA) {\r\n        for (Cost cost : source.getCosts()) {\r\n            if (cost instanceof TapSourceCost) {\r\n                ManaEvent event = new ManaEvent(GameEvent.EventType.TAPPED_FOR_MANA, source.getSourceId(), source.getSourceId(), source.getControllerId(), mana);\r\n                if (!game.replaceEvent(event)) {\r\n                    game.fireEvent(event);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.networknt.handler.Handler.getHandlersFromExecList",
	"Comment": "converts the list of chains and handlers to a flat list of handlers. if a\tchain is named the same as a handler, the chain is resolved first.",
	"Method": "List<HttpHandler> getHandlersFromExecList(List<String> execs){\r\n    List<HttpHandler> handlersFromExecList = new ArrayList();\r\n    if (execs != null) {\r\n        for (String exec : execs) {\r\n            List<HttpHandler> handlerList = handlerListById.get(exec);\r\n            if (handlerList == null)\r\n                throw new RuntimeException(\"Unknown handler or chain: \" + exec);\r\n            for (HttpHandler handler : handlerList) {\r\n                if (handler instanceof MiddlewareHandler) {\r\n                    if (((MiddlewareHandler) handler).isEnabled()) {\r\n                        handlersFromExecList.add(handler);\r\n                    }\r\n                } else {\r\n                    handlersFromExecList.add(handler);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return handlersFromExecList;\r\n}"
}, {
	"Path": "org.lenskit.util.MoreArrays.deduplicate",
	"Comment": "remove duplicate elements in the backing store. the array should besorted.",
	"Method": "int deduplicate(long[] data,int start,int end,int deduplicate,int[] data,int start,int end){\r\n    if (start == end) {\r\n        return end;\r\n    }\r\n    int pos = start + 1;\r\n    for (int i = pos; i < end; i++) {\r\n        if (data[i] != data[i - 1]) {\r\n            if (i != pos) {\r\n                data[pos] = data[i];\r\n            }\r\n            pos++;\r\n        }\r\n    }\r\n    return pos;\r\n}"
}, {
	"Path": "com.networknt.registry.URLImpl.toFullStr",
	"Comment": "todo there is a trailing &, use string join instead stringbuilder.",
	"Method": "String toFullStr(){\r\n    StringBuilder builder = new StringBuilder();\r\n    builder.append(getUri()).append(\"?\");\r\n    for (Map.Entry<String, String> entry : parameters.entrySet()) {\r\n        String name = entry.getKey();\r\n        String value = entry.getValue();\r\n        builder.append(name).append(\"=\").append(value).append(\"&\");\r\n    }\r\n    return builder.toString();\r\n}"
}, {
	"Path": "ch.qos.logback.classic.spi.CallerDataTest.testDeferredProcessing",
	"Comment": "this test verifies that in case caller data cannot beextracted, callerdata.extract does not throw an exception",
	"Method": "void testDeferredProcessing(){\r\n    StackTraceElement[] cda = CallerData.extract(new Throwable(), \"com.inexistent.foo\", 10, null);\r\n    assertNotNull(cda);\r\n    assertEquals(0, cda.length);\r\n}"
}, {
	"Path": "org.lenskit.eval.traintest.predict.NDCGPredictMetric.computeDCG",
	"Comment": "compute the dcg of a list of items with respect to a value vector.",
	"Method": "double computeDCG(long[] items,Long2DoubleFunction values){\r\n    double gain = 0;\r\n    int rank = 0;\r\n    for (long item : items) {\r\n        final double v = values.get(item);\r\n        rank++;\r\n        gain += v * discount.discount(rank);\r\n    }\r\n    return gain;\r\n}"
}, {
	"Path": "ch.qos.logback.core.FileAppender.setPrudent",
	"Comment": "when prudent is set to true, file appenders from multiple jvms can safelywrite to the same file.",
	"Method": "void setPrudent(boolean prudent){\r\n    this.prudent = prudent;\r\n}"
}, {
	"Path": "com.networknt.security.JwtIssuer.getJwt",
	"Comment": "a static method that generate jwt token from jwt claims object",
	"Method": "String getJwt(JwtClaims claims){\r\n    String jwt;\r\n    RSAPrivateKey privateKey = (RSAPrivateKey) getPrivateKey(jwtConfig.getKey().getFilename(), (String) secretConfig.get(JWT_PRIVATE_KEY_PASSWORD), jwtConfig.getKey().getKeyName());\r\n    JsonWebSignature jws = new JsonWebSignature();\r\n    jws.setPayload(claims.toJson());\r\n    jws.setKey(privateKey);\r\n    String provider_id = \"\";\r\n    if (jwtConfig.getProviderId() != null) {\r\n        provider_id = jwtConfig.getProviderId();\r\n        if (provider_id.length() == 1) {\r\n            provider_id = \"0\" + provider_id;\r\n        } else if (provider_id.length() > 2) {\r\n            logger.error(\"provider_id defined in the security.yml file is invalid; the length should be 2\");\r\n            provider_id = provider_id.substring(0, 2);\r\n        }\r\n    }\r\n    jws.setKeyIdHeaderValue(provider_id + jwtConfig.getKey().getKid());\r\n    jws.setAlgorithmHeaderValue(AlgorithmIdentifiers.RSA_USING_SHA256);\r\n    jwt = jws.getCompactSerialization();\r\n    return jwt;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.android.SQLiteAppender.secondarySubAppend",
	"Comment": "updates an existing row of an event with the secondary details of the event.this includes mdc properties and any exception information.",
	"Method": "void secondarySubAppend(ILoggingEvent event,long eventId){\r\n    Map<String, String> mergedMap = mergePropertyMaps(event);\r\n    insertProperties(mergedMap, eventId);\r\n    if (event.getThrowableProxy() != null) {\r\n        insertThrowable(event.getThrowableProxy(), eventId);\r\n    }\r\n}"
}, {
	"Path": "mage.player.ai.simulators.CombatGroupSimulator.evaluateCombat",
	"Comment": "returns 3 attacker survives blockers destroyedreturns 2 both destroyedreturns 1 both survivereturns 0 attacker destroyed blockers survive",
	"Method": "int evaluateCombat(){\r\n    int survivingBlockers = 0;\r\n    for (CreatureSimulator blocker : blockers) {\r\n        if (blocker.damage < blocker.toughness)\r\n            survivingBlockers++;\r\n    }\r\n    if (attacker.isDead()) {\r\n        if (survivingBlockers > 0) {\r\n            return 0;\r\n        }\r\n        return 2;\r\n    } else {\r\n        if (survivingBlockers > 0) {\r\n            return 1;\r\n        }\r\n        return 3;\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.joran.action.ext.IncAction.end",
	"Comment": "once the children elements are also parsed, now is the time to activatethe appender options.",
	"Method": "void end(InterpretationContext ec,String name){\r\n    endCount++;\r\n}"
}, {
	"Path": "mage.players.Library.getCards",
	"Comment": "returns the cards of the library in a list ordered from top to buttom",
	"Method": "List<Card> getCards(Game game){\r\n    return library.stream().map(game::getCard).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.mage.card.arcane.ModernCardRenderer.layoutRules",
	"Comment": "figure out if a given text size will work for laying out the rules in acard textbox",
	"Method": "RuleLayout layoutRules(Graphics2D g,List<TextboxRule> rules,int w,int h,int fontSize){\r\n    Font font = new Font(\"Arial\", Font.PLAIN, fontSize);\r\n    Font fontItalic = new Font(\"Arial\", Font.ITALIC, fontSize);\r\n    List<AttributedString> attributedRules = new ArrayList();\r\n    boolean fits = true;\r\n    int remaining = h;\r\n    for (TextboxRule rule : rules) {\r\n        AttributedString attributed = rule.generateAttributedString(font, fontItalic);\r\n        attributedRules.add(attributed);\r\n        remaining -= drawSingleRule(g, attributed, rule, 0, 0, w, remaining, false);\r\n        if (remaining < 0) {\r\n            fits = false;\r\n            break;\r\n        }\r\n    }\r\n    RuleLayout layout = new RuleLayout();\r\n    layout.attributedRules = attributedRules;\r\n    layout.remainingHeight = remaining;\r\n    layout.fits = fits;\r\n    layout.font = font;\r\n    layout.fontItalic = fontItalic;\r\n    return layout;\r\n}"
}, {
	"Path": "mage.abilities.Modes.addSelectedMode",
	"Comment": "adds a mode as selected. if the mode is already selected, it copies themode and adds it to the duplicate modes",
	"Method": "void addSelectedMode(UUID modeId){\r\n    if (selectedModes.contains(modeId) && eachModeMoreThanOnce) {\r\n        Mode duplicateMode = get(modeId).copy();\r\n        duplicateMode.setRandomId();\r\n        modeId = duplicateMode.getId();\r\n        duplicateModes.put(modeId, duplicateMode);\r\n    }\r\n    this.selectedModes.add(modeId);\r\n}"
}, {
	"Path": "org.lenskit.eval.traintest.TrainTestExperiment.getShareModelComponents",
	"Comment": "query whether this experiment will cache and share components.",
	"Method": "boolean getShareModelComponents(){\r\n    return shareModelComponents;\r\n}"
}, {
	"Path": "ch.qos.logback.core.rolling.SizeBasedRollingTest.activeFileNameNotSet",
	"Comment": "test whether fixedwindowrollingpolicy throws an exception when theactivefilename is not set.",
	"Method": "void activeFileNameNotSet(){\r\n    sizeBasedTriggeringPolicy.setMaxFileSize(new FileSize(100));\r\n    sizeBasedTriggeringPolicy.start();\r\n    fwrp.setFileNamePattern(CoreTestConstants.OUTPUT_DIR_PREFIX + \"sizeBased-test1.%i\");\r\n    fwrp.start();\r\n}"
}, {
	"Path": "org.lenskit.eval.traintest.AlgorithmInstanceBuilder.extend",
	"Comment": "create a new builder that inherits from this builder.changes to the returned builder will not affect thisbuilder, but subsequent changes to this builder will affect the inherited builder.",
	"Method": "AlgorithmInstanceBuilder extend(){\r\n    AlgorithmInstanceBuilder aib = new AlgorithmInstanceBuilder(this);\r\n    return aib;\r\n}"
}, {
	"Path": "mage.filters.MageBufferedImageOp.getRGB",
	"Comment": "gets argb pixels from image. solves the performanceissue of bufferedimage.getrgb method.",
	"Method": "int[] getRGB(BufferedImage image,int x,int y,int width,int height,int[] pixels){\r\n    int type = image.getType();\r\n    if (type == BufferedImage.TYPE_INT_ARGB || type == BufferedImage.TYPE_INT_RGB) {\r\n        return (int[]) image.getRaster().getDataElements(x, y, width, height, pixels);\r\n    }\r\n    return image.getRGB(x, y, width, height, pixels, 0, width);\r\n}"
}, {
	"Path": "ch.qos.logback.core.html.HTMLLayoutBase.getEffectiveConverterMap",
	"Comment": "returns a map where the default converter map is merged with the mapcontained in the context.",
	"Method": "Map<String, String> getEffectiveConverterMap(){\r\n    Map<String, String> effectiveMap = new HashMap<String, String>();\r\n    Map<String, String> defaultMap = getDefaultConverterMap();\r\n    if (defaultMap != null) {\r\n        effectiveMap.putAll(defaultMap);\r\n    }\r\n    Context context = getContext();\r\n    if (context != null) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Map<String, String> contextMap = (Map<String, String>) context.getObject(CoreConstants.PATTERN_RULE_REGISTRY);\r\n        if (contextMap != null) {\r\n            effectiveMap.putAll(contextMap);\r\n        }\r\n    }\r\n    return effectiveMap;\r\n}"
}, {
	"Path": "ch.qos.logback.core.joran.action.AppenderAction.end",
	"Comment": "once the children elements are also parsed, now is the time to activate theappender options.",
	"Method": "void end(InterpretationContext ec,String name){\r\n    if (inError) {\r\n        return;\r\n    }\r\n    if (appender instanceof LifeCycle) {\r\n        ((LifeCycle) appender).start();\r\n    }\r\n    Object o = ec.peekObject();\r\n    if (o != appender) {\r\n        addWarn(\"The object at the of the stack is not the appender named [\" + appender.getName() + \"] pushed earlier.\");\r\n    } else {\r\n        ec.popObject();\r\n    }\r\n}"
}, {
	"Path": "mage.cards.ExpansionSet.addDoubleFace",
	"Comment": "add double faced card for innistrad boosterrarity near as the normal distribution",
	"Method": "void addDoubleFace(List<Card> booster){\r\n    for (int i = 0; i < numBoosterDoubleFaced; i++) {\r\n        CardCriteria criteria = new CardCriteria();\r\n        criteria.setCodes(this.code).doubleFaced(true);\r\n        if (RandomUtil.nextInt(15) < 10) {\r\n            criteria.rarities(Rarity.COMMON);\r\n        } else if (RandomUtil.nextInt(5) < 4) {\r\n            criteria.rarities(Rarity.UNCOMMON);\r\n        } else if (RandomUtil.nextInt(8) < 7) {\r\n            criteria.rarities(Rarity.RARE);\r\n        } else {\r\n            criteria.rarities(Rarity.MYTHIC);\r\n        }\r\n        List<CardInfo> doubleFacedCards = CardRepository.instance.findCards(criteria);\r\n        addToBooster(booster, doubleFacedCards);\r\n    }\r\n}"
}, {
	"Path": "mage.client.deck.generator.DeckGeneratorPool.getBasicLandName",
	"Comment": "returns the card name that represents the basic land for this color.",
	"Method": "String getBasicLandName(String symbolString){\r\n    switch(symbolString) {\r\n        case \"B\":\r\n            return \"Swamp\";\r\n        case \"G\":\r\n            return \"Forest\";\r\n        case \"R\":\r\n            return \"Mountain\";\r\n        case \"U\":\r\n            return \"Island\";\r\n        case \"W\":\r\n            return \"Plains\";\r\n        default:\r\n            return \"\";\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.util.EnvUtil.isAndroidOS",
	"Comment": "heuristically determines whether the current os is android",
	"Method": "boolean isAndroidOS(){\r\n    String osname = OptionHelper.getSystemProperty(\"os.name\");\r\n    String root = OptionHelper.getEnv(\"ANDROID_ROOT\");\r\n    String data = OptionHelper.getEnv(\"ANDROID_DATA\");\r\n    return osname != null && osname.contains(\"Linux\") && root != null && root.contains(\"/system\") && data != null && data.contains(\"/data\");\r\n}"
}, {
	"Path": "mage.filters.MageBufferedImageOp.setRGB",
	"Comment": "sets argb pixels in image. solves the performanceissue of bufferedimage.setrgb method.",
	"Method": "void setRGB(BufferedImage image,int x,int y,int width,int height,int[] pixels){\r\n    int type = image.getType();\r\n    if (type == BufferedImage.TYPE_INT_ARGB || type == BufferedImage.TYPE_INT_RGB) {\r\n        image.getRaster().setDataElements(x, y, width, height, pixels);\r\n    } else {\r\n        image.setRGB(x, y, width, height, pixels, 0, width);\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.android.SystemPropertiesProxy.get",
	"Comment": "get the value for the given key in the android system properties",
	"Method": "String get(String key,String def){\r\n    if (SystemProperties == null || getString == null)\r\n        return null;\r\n    String ret = null;\r\n    try {\r\n        ret = (String) getString.invoke(SystemProperties, new Object[] { key, def });\r\n    } catch (IllegalArgumentException e) {\r\n        throw e;\r\n    } catch (Exception e) {\r\n    }\r\n    if (ret == null || ret.length() == 0) {\r\n        ret = def;\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.lenskit.util.math.Scalars.isZero",
	"Comment": "check whether a value is zero, using a configurable epsilon.",
	"Method": "boolean isZero(double val,boolean isZero,double val,double epsilon){\r\n    return Math.abs(val) < epsilon;\r\n}"
}, {
	"Path": "org.lenskit.config.BindingDSL.within",
	"Comment": "enclose a block of configuration in a context.the block is invoked with a delegate thatadds bindings within the specified context.",
	"Method": "LenskitConfigContext within(Class<?> type,LenskitConfigContext within,Class<?> type,Closure<?> block,LenskitConfigContext within,Class<? extends Annotation> qualifier,Class<?> type,LenskitConfigContext within,Class<? extends Annotation> qualifier,Class<?> type,Closure<?> block,LenskitConfigContext within,Annotation qualifier,Class<?> type,LenskitConfigContext within,Annotation qualifier,Class<?> type,Closure<?> block){\r\n    return configure(within(qualifier, type), block);\r\n}"
}, {
	"Path": "io.dropwizard.metrics.UnsafeStriped64.getUnsafe",
	"Comment": "returns a sun.misc.unsafe.suitable for use in a 3rd party package. replace with a simplecall to unsafe.getunsafe when integrating into a jdk.",
	"Method": "sun.misc.Unsafe getUnsafe(){\r\n    try {\r\n        return sun.misc.Unsafe.getUnsafe();\r\n    } catch (SecurityException ignored) {\r\n    }\r\n    try {\r\n        return java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {\r\n            @Override\r\n            public sun.misc.Unsafe run() throws Exception {\r\n                Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\r\n                for (java.lang.reflect.Field f : k.getDeclaredFields()) {\r\n                    f.setAccessible(true);\r\n                    Object x = f.get(null);\r\n                    if (k.isInstance(x))\r\n                        return k.cast(x);\r\n                }\r\n                throw new NoSuchFieldError(\"the Unsafe\");\r\n            }\r\n        });\r\n    } catch (java.security.PrivilegedActionException e) {\r\n        throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\r\n    }\r\n}"
}, {
	"Path": "io.dropwizard.metrics.UnsafeStriped64.getUnsafe",
	"Comment": "returns a sun.misc.unsafe.suitable for use in a 3rd party package. replace with a simplecall to unsafe.getunsafe when integrating into a jdk.",
	"Method": "sun.misc.Unsafe getUnsafe(){\r\n    Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\r\n    for (java.lang.reflect.Field f : k.getDeclaredFields()) {\r\n        f.setAccessible(true);\r\n        Object x = f.get(null);\r\n        if (k.isInstance(x))\r\n            return k.cast(x);\r\n    }\r\n    throw new NoSuchFieldError(\"the Unsafe\");\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.SyslogAppenderBase.setCharset",
	"Comment": "the charset to use when encoding messages into byte sequences.",
	"Method": "void setCharset(Charset charset){\r\n    this.charset = charset;\r\n}"
}, {
	"Path": "org.lenskit.util.table.writer.AbstractTableWriter.checkRowWidth",
	"Comment": "check the width of a row to see if it is too wide.this formats the exceptionwith a helpful error message.",
	"Method": "void checkRowWidth(int width){\r\n    if (width != getLayout().getColumnCount()) {\r\n        String msg = String.format(\"incorrect row size (got %d of %d expected columns)\", width, getLayout().getColumnCount());\r\n        throw new IllegalArgumentException(msg);\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.SyslogAppenderBase.setSyslogHost",
	"Comment": "the sysloghost option is the name of the the syslog host where logoutput should go.warning if the sysloghost is not set, then this appender will fail.",
	"Method": "void setSyslogHost(String syslogHost){\r\n    this.syslogHost = syslogHost;\r\n}"
}, {
	"Path": "mage.client.game.GamePanel.deactivated",
	"Comment": "called if the game frame is deactivated because the tabled the deck editor or other frames go to foreground",
	"Method": "void deactivated(){\r\n    for (CardInfoWindowDialog exileDialog : exiles.values()) {\r\n        exileDialog.hideDialog();\r\n    }\r\n    for (CardInfoWindowDialog graveyardDialog : graveyardWindows.values()) {\r\n        graveyardDialog.hideDialog();\r\n    }\r\n    for (CardInfoWindowDialog revealDialog : revealed.values()) {\r\n        revealDialog.hideDialog();\r\n    }\r\n    for (CardInfoWindowDialog lookedAtDialog : lookedAt.values()) {\r\n        lookedAtDialog.hideDialog();\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.pattern.Converter.write",
	"Comment": "in its simplest incarnation, a convert simply appends the data extracted fromthe event to the buffer passed as parameter.",
	"Method": "void write(StringBuilder buf,E event){\r\n    buf.append(convert(event));\r\n}"
}, {
	"Path": "ch.qos.logback.classic.util.LogbackMDCAdapterTest.nearSimultaneousPutsShouldNotCauseConcurrentModificationException",
	"Comment": "this test used to fail without synchronization code in logbackmdcadapter",
	"Method": "void nearSimultaneousPutsShouldNotCauseConcurrentModificationException(){\r\n    for (int i = 0; i < 2048; i++) {\r\n        mdcAdapter.put(\"k\" + i, \"v\" + i);\r\n    }\r\n    ChildThread childThread = new ChildThread(mdcAdapter, null, null) {\r\n        @Override\r\n        public void run() {\r\n            for (int i = 0; i < 16; i++) {\r\n                mdcAdapter.put(\"ck\" + i, \"cv\" + i);\r\n                Thread.yield();\r\n            }\r\n            successful = true;\r\n        }\r\n    };\r\n    childThread.start();\r\n    Thread.sleep(1);\r\n    for (int i = 0; i < 16; i++) {\r\n        mdcAdapter.put(\"K\" + i, \"V\" + i);\r\n    }\r\n    childThread.join();\r\n    assertTrue(childThread.successful);\r\n}"
}, {
	"Path": "ch.qos.logback.classic.util.LogbackMDCAdapterTest.nearSimultaneousPutsShouldNotCauseConcurrentModificationException",
	"Comment": "this test used to fail without synchronization code in logbackmdcadapter",
	"Method": "void nearSimultaneousPutsShouldNotCauseConcurrentModificationException(){\r\n    for (int i = 0; i < 16; i++) {\r\n        mdcAdapter.put(\"ck\" + i, \"cv\" + i);\r\n        Thread.yield();\r\n    }\r\n    successful = true;\r\n}"
}, {
	"Path": "org.lenskit.predict.KnownRatingRatingPredictorTest.testPredictForRatingByGivenUser",
	"Comment": "test method that tests predicting for a user in the data set,only with items they have rated.",
	"Method": "void testPredictForRatingByGivenUser(){\r\n    KnownRatingRatingPredictor pred = new KnownRatingRatingPredictor(dao);\r\n    Map<Long, Double> results = pred.predict(14, LongUtils.packedSet(1, 3, 5));\r\n    assertThat(results.size(), equalTo(3));\r\n    assertThat(results.get(1L), equalTo(5.0));\r\n    assertThat(results.get(3L), equalTo(3.0));\r\n    assertThat(results.get(5L), equalTo(0.2));\r\n}"
}, {
	"Path": "org.lenskit.util.keys.LongSortedArraySetTest.testSetSimple",
	"Comment": "run a battery of tests on a standard set. used to test a variety ofconstruction scenarios with less code duplication.",
	"Method": "void testSetSimple(LongSortedSet set){\r\n    assertFalse(set.isEmpty());\r\n    assertEquals(3, set.size());\r\n    assertEquals(2, set.firstLong());\r\n    assertEquals(6, set.lastLong());\r\n    assertEquals(Long.valueOf(2), set.first());\r\n    assertEquals(Long.valueOf(6), set.last());\r\n    assertTrue(set.contains(2));\r\n    assertTrue(set.contains(5));\r\n    assertTrue(set.contains(6));\r\n    assertFalse(set.contains(0));\r\n    assertFalse(set.contains(42));\r\n    assertFalse(set.iterator().hasPrevious());\r\n    long[] items = LongIterators.unwrap(set.iterator());\r\n    assertEquals(2, items[0]);\r\n    assertEquals(5, items[1]);\r\n    assertEquals(6, items[2]);\r\n}"
}, {
	"Path": "ch.qos.logback.classic.spi.CallerData.isInFrameworkSpaceList",
	"Comment": "is currentclass present in the list of packages considered part of the logging framework?",
	"Method": "boolean isInFrameworkSpaceList(String currentClass,List<String> frameworkPackageList){\r\n    if (frameworkPackageList == null)\r\n        return false;\r\n    for (String s : frameworkPackageList) {\r\n        if (currentClass.startsWith(s))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "mage.client.chat.ChatPanelSeparated.receiveMessage",
	"Comment": "display message in the chat. use different colors for timestamp, usernameand message.",
	"Method": "void receiveMessage(String username,String message,Date time,ChatMessage.MessageType messageType,ChatMessage.MessageColor color){\r\n    switch(messageType) {\r\n        case TALK:\r\n        case WHISPER_TO:\r\n        case WHISPER_FROM:\r\n        case USER_INFO:\r\n            super.receiveMessage(username, message, time, messageType, color);\r\n            return;\r\n    }\r\n    StringBuilder text = new StringBuilder();\r\n    if (time != null) {\r\n        text.append(getColoredText(TIMESTAMP_COLOR, timeFormatter.format(time) + \": \"));\r\n    }\r\n    String userColor;\r\n    String textColor;\r\n    String userSeparator = \" \";\r\n    switch(messageType) {\r\n        case STATUS:\r\n            textColor = STATUS_COLOR;\r\n            userColor = STATUS_COLOR;\r\n            break;\r\n        case USER_INFO:\r\n            textColor = USER_INFO_COLOR;\r\n            userColor = USER_INFO_COLOR;\r\n            break;\r\n        default:\r\n            if (parentChatRef != null) {\r\n                userColor = SessionHandler.getUserName().equals(username) ? MY_COLOR : OPPONENT_COLOR;\r\n            } else {\r\n                userColor = SessionHandler.getUserName().equals(username) ? MY_COLOR : OPPONENT_COLOR;\r\n            }\r\n            textColor = MESSAGE_COLOR;\r\n            userSeparator = \": \";\r\n    }\r\n    if (color == ChatMessage.MessageColor.ORANGE) {\r\n        textColor = \"Orange\";\r\n    }\r\n    if (color == ChatMessage.MessageColor.YELLOW) {\r\n        textColor = \"Yellow\";\r\n    }\r\n    if (username != null && !username.isEmpty()) {\r\n        text.append(getColoredText(userColor, username + userSeparator));\r\n    }\r\n    text.append(getColoredText(textColor, ManaSymbols.replaceSymbolsWithHTML(message, ManaSymbols.Type.CHAT)));\r\n    this.systemMessagesPane.append(text.toString());\r\n}"
}, {
	"Path": "mage.client.components.layout.RelativeLayout.adjustForRounding",
	"Comment": "because of rounding, all the space has not been allocated override this method to create a custom rounding policy",
	"Method": "void adjustForRounding(int[] relativeSpace,int spaceRemaining){\r\n    switch(roundingPolicy) {\r\n        case DO_NOTHING:\r\n            break;\r\n        case FIRST:\r\n            adjustFirst(relativeSpace, spaceRemaining);\r\n            break;\r\n        case LAST:\r\n            adjustLast(relativeSpace, spaceRemaining);\r\n            break;\r\n        case LARGEST:\r\n            adjustLargest(relativeSpace, spaceRemaining);\r\n            break;\r\n        case EQUAL:\r\n            adjustEqual(relativeSpace, spaceRemaining);\r\n            break;\r\n        default:\r\n            adjustLargest(relativeSpace, spaceRemaining);\r\n    }\r\n}"
}, {
	"Path": "org.mage.plugins.card.images.ImageCache.getFaceKey",
	"Comment": "returns the map key for a card, without any suffixes for the image size.",
	"Method": "String getFaceKey(CardView card,String name,String set){\r\n    return name + '#' + set + \"####\";\r\n}"
}, {
	"Path": "mage.util.CircularList.getPrevious",
	"Comment": "returns the previous element in the list. will loop around to the end ofthe list if the current element is the first.",
	"Method": "E getPrevious(){\r\n    return list.get(decrementPointer());\r\n}"
}, {
	"Path": "org.lenskit.eval.traintest.TrainTestExperiment.getContinueAfterError",
	"Comment": "query whether this task will continue in the face of an error.",
	"Method": "boolean getContinueAfterError(){\r\n    return continueAfterError;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.Logger.readResolve",
	"Comment": "after serialization, the logger instance does not know its loggercontext.the best we can do here, is to return a logger with the same namereturned by org.slf4j.loggerfactory.",
	"Method": "Object readResolve(){\r\n    return LoggerFactory.getLogger(getName());\r\n}"
}, {
	"Path": "org.lenskit.LenskitConfigurationTest.testSetFile",
	"Comment": "test that we can bind a file parameter to a string and have it work.",
	"Method": "void testSetFile(){\r\n    LenskitConfiguration config = new LenskitConfiguration();\r\n    config.clearRoots();\r\n    RecommenderGraphBuilder rgb = new RecommenderGraphBuilder();\r\n    rgb.addConfiguration(config);\r\n    try (Injector inj = new StaticInjector(rgb.buildGraph())) {\r\n    }\r\n}"
}, {
	"Path": "mage.player.ai.utils.RateCard.rateCard",
	"Comment": "get absolute score of the card.depends on type, manacost, rating.if allowedcolors is null then the rating is retrieved from the cache",
	"Method": "int rateCard(Card card,List<ColoredManaSymbol> allowedColors){\r\n    if (allowedColors == null && rated.containsKey(card.getName())) {\r\n        int rate = rated.get(card.getName());\r\n        return rate;\r\n    }\r\n    int type;\r\n    if (card.isPlaneswalker()) {\r\n        type = 15;\r\n    } else if (card.isCreature()) {\r\n        type = 10;\r\n    } else if (card.getSubtype(null).contains(SubType.EQUIPMENT)) {\r\n        type = 8;\r\n    } else if (card.getSubtype(null).contains(SubType.AURA)) {\r\n        type = 5;\r\n    } else if (card.isInstant()) {\r\n        type = 7;\r\n    } else {\r\n        type = 6;\r\n    }\r\n    int score = getCardRating(card) + 2 * type + getManaCostScore(card, allowedColors) + 40 * isRemoval(card);\r\n    if (allowedColors == null)\r\n        rated.put(card.getName(), score);\r\n    return score;\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.server.ServerSocketAppenderBase.setBacklog",
	"Comment": "sets the listener queue depth.this represents the number of connected clients whose connectionshave not yet been accepted.",
	"Method": "void setBacklog(Integer backlog){\r\n    this.backlog = backlog;\r\n}"
}, {
	"Path": "ch.qos.logback.core.rolling.RollingFileAppender.subAppend",
	"Comment": "this method differentiates rollingfileappender from its super class.",
	"Method": "void subAppend(E event){\r\n    synchronized (triggeringPolicy) {\r\n        if (triggeringPolicy.isTriggeringEvent(currentlyActiveFile, event)) {\r\n            rollover();\r\n        }\r\n    }\r\n    super.subAppend(event);\r\n}"
}, {
	"Path": "mage.game.combat.Combat.getDefendingPlayerId",
	"Comment": "returns the playerid of the player that is attacked by given attackingcreature",
	"Method": "UUID getDefendingPlayerId(UUID attackingCreatureId,Game game){\r\n    UUID defenderId = null;\r\n    for (CombatGroup group : groups) {\r\n        if (group.getAttackers().contains(attackingCreatureId)) {\r\n            defenderId = group.getDefenderId();\r\n            if (group.defenderIsPlaneswalker) {\r\n                Permanent permanent = game.getPermanentOrLKIBattlefield(defenderId);\r\n                if (permanent != null) {\r\n                    defenderId = permanent.getControllerId();\r\n                } else {\r\n                    defenderId = null;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return defenderId;\r\n}"
}, {
	"Path": "org.lenskit.predict.KnownRatingRatingPredictorTest.testPredictForOnlyRatedItems",
	"Comment": "test method that tests predicting for a user in the data set,returning the rating of item for given user only.",
	"Method": "void testPredictForOnlyRatedItems(){\r\n    KnownRatingRatingPredictor pred = new KnownRatingRatingPredictor(dao);\r\n    Map<Long, Double> results = pred.predict(15, LongUtils.packedSet(5, 7, 1));\r\n    assertThat(results.get(5L), equalTo(1.0));\r\n    assertThat(results.get(7L), equalTo(3.0));\r\n    assertThat(results.keySet(), not(hasItem(1L)));\r\n}"
}, {
	"Path": "ch.qos.logback.core.util.Loader.getClassLoaderAsPrivileged",
	"Comment": "returns the class loader of clazz in an access privileged section.",
	"Method": "ClassLoader getClassLoaderAsPrivileged(Class<?> clazz){\r\n    if (!HAS_GET_CLASS_LOADER_PERMISSION)\r\n        return null;\r\n    else\r\n        return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\r\n            public ClassLoader run() {\r\n                return clazz.getClassLoader();\r\n            }\r\n        });\r\n}"
}, {
	"Path": "ch.qos.logback.core.util.Loader.getClassLoaderAsPrivileged",
	"Comment": "returns the class loader of clazz in an access privileged section.",
	"Method": "ClassLoader getClassLoaderAsPrivileged(Class<?> clazz){\r\n    return clazz.getClassLoader();\r\n}"
}, {
	"Path": "ch.qos.logback.core.util.Loader.loadClass",
	"Comment": "if running under jdk 1.2 load the specified class using thethread contextclassloader if that fails tryclass.forname. under jdk 1.1 only class.forname is used.",
	"Method": "Class<?> loadClass(String clazz,Context context,Class<?> loadClass,String clazz){\r\n    if (ignoreTCL) {\r\n        return Class.forName(clazz);\r\n    } else {\r\n        try {\r\n            return getTCL().loadClass(clazz);\r\n        } catch (Throwable e) {\r\n            return Class.forName(clazz);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.spi.AppenderAttachableImpl.iteratorForAppenders",
	"Comment": "get all attached appenders as an enumeration. if there are no attachedappenders null is returned.",
	"Method": "Iterator<Appender<E>> iteratorForAppenders(){\r\n    return appenderList.iterator();\r\n}"
}, {
	"Path": "com.networknt.utility.NioUtils.toString",
	"Comment": "reads and returns the rest of the given input stream as a string.caller is responsible for closing the given input stream.",
	"Method": "String toString(InputStream is){\r\n    return new String(toByteArray(is), StandardCharsets.UTF_8);\r\n}"
}, {
	"Path": "mage.abilities.effects.RequirementEffect.playerMustBeAttackedIfAble",
	"Comment": "player related check the player returned or controlled planeswalker mustbe attacked with at least one attacker",
	"Method": "UUID playerMustBeAttackedIfAble(Ability source,Game game){\r\n    return null;\r\n}"
}, {
	"Path": "org.lenskit.eval.traintest.AlgorithmInstance.getAttributes",
	"Comment": "get the attributes of this algorithm.these attributes are used to distinguish between similar algorithms,e.g. different configurations of the same basic algorithm.",
	"Method": "Map<String, Object> getAttributes(){\r\n    return attributes;\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.SMTPAppenderBase.setSmtpPort",
	"Comment": "the port where the smtp server is running. default value is 25.",
	"Method": "void setSmtpPort(int port){\r\n    this.smtpPort = port;\r\n}"
}, {
	"Path": "ch.qos.logback.core.util.StatusListenerConfigHelper.addOnConsoleListenerInstance",
	"Comment": "this utility method adds a new onconsolestatuslistener to the contextpassed as parameter.",
	"Method": "void addOnConsoleListenerInstance(Context context,OnConsoleStatusListener onConsoleStatusListener){\r\n    onConsoleStatusListener.setContext(context);\r\n    boolean effectivelyAdded = context.getStatusManager().add(onConsoleStatusListener);\r\n    if (effectivelyAdded) {\r\n        onConsoleStatusListener.start();\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.eval.traintest.recommend.TopNNDCGMetric.computeDCG",
	"Comment": "compute the dcg of a list of items with respect to a value vector.",
	"Method": "double computeDCG(List<Long> items,Long2DoubleFunction values){\r\n    double gain = 0;\r\n    int rank = 0;\r\n    for (long item : items) {\r\n        final double v = values.get(item);\r\n        rank++;\r\n        gain += v * discount.discount(rank);\r\n    }\r\n    return gain;\r\n}"
}, {
	"Path": "mage.Mana.setGreen",
	"Comment": "sets the total green mana. can not be negative. negative values will belogged and set to 0.",
	"Method": "void setGreen(int green){\r\n    this.green = notNegative(green, \"Green\");\r\n}"
}, {
	"Path": "mage.abilities.keyword.SuspendAbility.addSuspendTemporaryToCard",
	"Comment": "adds suspend to a card that does not have it regularly e.g. epochrasiteor added by jhoira of the ghitu",
	"Method": "void addSuspendTemporaryToCard(Card card,Ability source,Game game){\r\n    SuspendAbility ability = new SuspendAbility(0, null, card, false);\r\n    ability.setSourceId(card.getId());\r\n    ability.setControllerId(card.getOwnerId());\r\n    game.getState().addOtherAbility(card, ability);\r\n    SuspendBeginningOfUpkeepInterveningIfTriggeredAbility ability1 = new SuspendBeginningOfUpkeepInterveningIfTriggeredAbility();\r\n    ability1.setSourceId(card.getId());\r\n    ability1.setControllerId(card.getOwnerId());\r\n    game.getState().addOtherAbility(card, ability1);\r\n    game.getState().addAbility(ability1, source.getSourceId(), card);\r\n    SuspendPlayCardAbility ability2 = new SuspendPlayCardAbility();\r\n    ability2.setSourceId(card.getId());\r\n    ability2.setControllerId(card.getOwnerId());\r\n    game.getState().addOtherAbility(card, ability2);\r\n    game.getState().addAbility(ability2, source.getSourceId(), card);\r\n}"
}, {
	"Path": "io.dropwizard.metrics.MetricRegistry.getTimers",
	"Comment": "returns a map of all the timers in the registry and their names which match the given filter.",
	"Method": "SortedMap<MetricName, Timer> getTimers(SortedMap<MetricName, Timer> getTimers,MetricFilter filter){\r\n    return getMetrics(Timer.class, filter);\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.SMTPAppenderBase.checkEntryConditions",
	"Comment": "this method determines if there is a sense in attempting to append.it checks whether there is a set output target and also if there is a setlayout. if these checks fail, then the boolean value false isreturned.",
	"Method": "boolean checkEntryConditions(){\r\n    if (!this.started) {\r\n        addError(\"Attempting to append to a non-started appender: \" + this.getName());\r\n        return false;\r\n    }\r\n    if (this.eventEvaluator == null) {\r\n        addError(\"No EventEvaluator is set for appender [\" + name + \"].\");\r\n        return false;\r\n    }\r\n    if (this.layout == null) {\r\n        addError(\"No layout set for appender named [\" + name + \"]. For more information, please visit http://logback.qos.ch/codes.html#smtp_no_layout\");\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "ch.qos.logback.core.helpers.CyclicBuffer.get",
	"Comment": "get the ith oldest event currently in the buffer. if iis outside the range 0 to the number of elements currently in the buffer,then null is returned.",
	"Method": "E get(int i,E get){\r\n    E r = null;\r\n    if (numElems > 0) {\r\n        numElems--;\r\n        r = ea[first];\r\n        ea[first] = null;\r\n        if (++first == maxSize)\r\n            first = 0;\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "org.lenskit.util.keys.SortedKeyIndex.containsKey",
	"Comment": "query whether this set contains the specified key in its domain.",
	"Method": "boolean containsKey(long key){\r\n    int idx = tryGetIndex(key);\r\n    return idx >= lowerBound && idx < upperBound;\r\n}"
}, {
	"Path": "ch.qos.logback.core.util.Loader.getResourceBySelfClassLoader",
	"Comment": "attempt to find a resource by using the classloader that loaded this class,namely loader.class.",
	"Method": "URL getResourceBySelfClassLoader(String resource){\r\n    return getResource(resource, getClassLoaderOfClass(Loader.class));\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.server.ConcurrentServerRunner.addClient",
	"Comment": "adds a client to the collection of those being tracked by the server.",
	"Method": "void addClient(T client){\r\n    clientsLock.lock();\r\n    try {\r\n        clients.add(client);\r\n    } finally {\r\n        clientsLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "io.dropwizard.metrics.Snapshot.get999thPercentile",
	"Comment": "returns the value at the 99.9th percentile in the distribution.",
	"Method": "double get999thPercentile(){\r\n    return getValue(0.999);\r\n}"
}, {
	"Path": "org.lenskit.config.ConfigurationLoader.loadScript",
	"Comment": "load a lenskit configuration script.this method is for internal use that needs to override how configurationscripts are loaded.",
	"Method": "LenskitConfigScript loadScript(GroovyCodeSource source,URI base,LenskitConfigScript loadScript,File file,LenskitConfigScript loadScript,URL url,LenskitConfigScript loadScript,String source){\r\n    Preconditions.checkNotNull(source, \"Configuration source text\");\r\n    return loadScript(new GroovyCodeSource(source, \"LKConfig\" + (++scriptNumber), GroovyShell.DEFAULT_CODE_BASE), null);\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.server.ConcurrentServerRunner.copyClients",
	"Comment": "creates a copy of the collection of all clients that are presentlybeing tracked by the server.",
	"Method": "Collection<T> copyClients(){\r\n    clientsLock.lock();\r\n    try {\r\n        Collection<T> copy = new ArrayList<T>(clients);\r\n        return copy;\r\n    } finally {\r\n        clientsLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "mage.client.deck.generator.DeckGeneratorPool.getCardCount",
	"Comment": "returns how many of this card is in the pool.if there are none in the pool it will initalise the card count.",
	"Method": "int getCardCount(String cardName){\r\n    Object cC = cardCounts.get((cardName));\r\n    if (cC == null)\r\n        cardCounts.put(cardName, 0);\r\n    return cardCounts.get((cardName));\r\n}"
}, {
	"Path": "ch.qos.logback.core.pattern.PatternLayoutBase.getEffectiveConverterMap",
	"Comment": "returns a map where the default converter map is merged with the mapcontained in the context.",
	"Method": "Map<String, String> getEffectiveConverterMap(){\r\n    Map<String, String> effectiveMap = new HashMap<String, String>();\r\n    Map<String, String> defaultMap = getDefaultConverterMap();\r\n    if (defaultMap != null) {\r\n        effectiveMap.putAll(defaultMap);\r\n    }\r\n    Context context = getContext();\r\n    if (context != null) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Map<String, String> contextMap = (Map<String, String>) context.getObject(CoreConstants.PATTERN_RULE_REGISTRY);\r\n        if (contextMap != null) {\r\n            effectiveMap.putAll(contextMap);\r\n        }\r\n    }\r\n    effectiveMap.putAll(instanceConverterMap);\r\n    return effectiveMap;\r\n}"
}, {
	"Path": "org.lenskit.gradle.LenskitExtension.getThreadCount",
	"Comment": "the maximum number of threads lenskit should use.defaults to 0, which instructs lenskit to use all availablethreads.",
	"Method": "Property<Integer> getThreadCount(){\r\n    return threadCount;\r\n}"
}, {
	"Path": "mage.player.human.HumanPlayer.selectDefender",
	"Comment": "selects a defender for an attacker and adds the attacker to combat",
	"Method": "boolean selectDefender(Set<UUID> defenders,UUID attackerId,Game game){\r\n    boolean forcedToAttack = false;\r\n    Set<UUID> possibleDefender = game.getCombat().getCreaturesForcedToAttack().get(attackerId);\r\n    if (possibleDefender != null) {\r\n        forcedToAttack = true;\r\n    }\r\n    if (possibleDefender == null || possibleDefender.isEmpty()) {\r\n        possibleDefender = defenders;\r\n    }\r\n    if (possibleDefender.size() == 1) {\r\n        declareAttacker(attackerId, possibleDefender.iterator().next(), game, true);\r\n        return true;\r\n    } else {\r\n        TargetDefender target = new TargetDefender(possibleDefender, attackerId);\r\n        target.setNotTarget(true);\r\n        if (forcedToAttack) {\r\n            StringBuilder sb = new StringBuilder(target.getTargetName());\r\n            Permanent attacker = game.getPermanent(attackerId);\r\n            if (attacker != null) {\r\n                sb.append(\" (\").append(attacker.getName()).append(')');\r\n                target.setTargetName(sb.toString());\r\n            }\r\n        }\r\n        if (chooseTarget(Outcome.Damage, target, null, game)) {\r\n            UUID defenderId = response.getUUID();\r\n            for (Player player : game.getPlayers().values()) {\r\n                if (player.getId().equals(response.getUUID())) {\r\n                    defenderId = player.getId();\r\n                    break;\r\n                }\r\n            }\r\n            declareAttacker(attackerId, defenderId, game, true);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.dropwizard.metrics.MetricRegistry.getMeters",
	"Comment": "returns a map of all the meters in the registry and their names which match the given filter.",
	"Method": "SortedMap<MetricName, Meter> getMeters(SortedMap<MetricName, Meter> getMeters,MetricFilter filter){\r\n    return getMetrics(Meter.class, filter);\r\n}"
}, {
	"Path": "org.lenskit.util.BinarySearchTest.testRandomSearchesFindFirst",
	"Comment": "use random lists to test that we always find thematching element.",
	"Method": "void testRandomSearchesFindFirst(){\r\n    for (List<String> keys : someNonEmptyLists(strings())) {\r\n        Collections.sort(keys);\r\n        int toDup = integers(0, keys.size() - 1).next();\r\n        int ndups = integers(0, 10).next();\r\n        String dupKey = keys.get(toDup);\r\n        for (int i = 0; i < ndups; i++) {\r\n            keys.add(toDup, dupKey);\r\n        }\r\n        BinarySearch search = BinarySearch.forList(dupKey, keys);\r\n        int rv = search.search(0, keys.size());\r\n        assertThat(rv, greaterThanOrEqualTo(0));\r\n        assertThat(search.search(0, keys.size()), lessThanOrEqualTo(Collections.binarySearch(keys, dupKey)));\r\n        assertThat(keys.get(rv), equalTo(dupKey));\r\n        if (rv > 0) {\r\n            assertThat(keys.get(rv - 1), lessThan(dupKey));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mage.deck.HistoricalType2.validate",
	"Comment": "overridden validate function. changes the standard sets, then uses theregular validation function to test validity.",
	"Method": "boolean validate(Deck deck){\r\n    Map<String, String> leastInvalid = null;\r\n    boolean valid = false;\r\n    Map<String, Integer> counts = new HashMap();\r\n    countCards(counts, deck.getCards());\r\n    countCards(counts, deck.getSideboard());\r\n    if (counts.containsKey(\"Stoneforge Mystic\") && counts.containsKey(\"Batterskull\")) {\r\n        return false;\r\n    }\r\n    for (String[] sets : standards) {\r\n        invalid.clear();\r\n        setCodes = new ArrayList(Arrays.asList(sets));\r\n        if (super.validate(deck)) {\r\n            valid = true;\r\n            break;\r\n        }\r\n        if (leastInvalid == null) {\r\n            leastInvalid = new HashMap(this.getInvalid());\r\n            continue;\r\n        }\r\n        if (leastInvalid.size() > this.getInvalid().size()) {\r\n            leastInvalid = new HashMap(this.getInvalid());\r\n        }\r\n    }\r\n    GregorianCalendar start = new GregorianCalendar(2006, Calendar.SEPTEMBER, 1);\r\n    GregorianCalendar end = new GregorianCalendar(2008, Calendar.SEPTEMBER, 1);\r\n    GregorianCalendar current = new GregorianCalendar();\r\n    while (end.before(current) && !valid) {\r\n        setCodes.clear();\r\n        invalid.clear();\r\n        start.set(Calendar.YEAR, start.get(Calendar.YEAR) + 1);\r\n        end.set(Calendar.YEAR, start.get(Calendar.YEAR) + 2);\r\n        for (ExpansionSet set : Sets.getInstance().values()) {\r\n            if (set.getReleaseDate().after(start.getTime()) && set.getReleaseDate().before(end.getTime()) && (set.getSetType() == SetType.CORE || set.getSetType() == SetType.EXPANSION)) {\r\n                setCodes.add(set.getCode());\r\n            }\r\n        }\r\n        if (super.validate(deck)) {\r\n            invalid.clear();\r\n            valid = true;\r\n            break;\r\n        }\r\n        if (leastInvalid == null) {\r\n            leastInvalid = new HashMap(this.getInvalid());\r\n        } else if (leastInvalid.size() > this.getInvalid().size()) {\r\n            leastInvalid = new HashMap(this.getInvalid());\r\n        }\r\n    }\r\n    if (!valid) {\r\n        this.invalid = new HashMap(leastInvalid);\r\n    }\r\n    return valid;\r\n}"
}, {
	"Path": "org.lenskit.knn.item.model.ItemItemBuildContextTest.testAllItemsData",
	"Comment": "test itemitembuildcontext when all items have rating data.",
	"Method": "void testAllItemsData(){\r\n    SortedKeyIndex items = SortedKeyIndex.create(1, 2, 3, 4);\r\n    long[] userIds = { 101, 102, 103, 104 };\r\n    SortedKeyIndex idx = SortedKeyIndex.create(userIds);\r\n    double[] ratings1 = { 4.0, 3.0, 2.5, 2.0 };\r\n    double[] ratings2 = { 3.0, 2.5, 4.0, 1.0 };\r\n    double[] ratings3 = { 5.0, 3.5, 0.5, 1.0 };\r\n    double[] ratings4 = { 4.5, 3.0, 3.5, 1.5 };\r\n    Long2DoubleSortedArrayMap v1 = Long2DoubleSortedArrayMap.wrap(idx, ratings1);\r\n    Long2DoubleSortedArrayMap v2 = Long2DoubleSortedArrayMap.wrap(idx, ratings2);\r\n    Long2DoubleSortedArrayMap v3 = Long2DoubleSortedArrayMap.wrap(idx, ratings3);\r\n    Long2DoubleSortedArrayMap v4 = Long2DoubleSortedArrayMap.wrap(idx, ratings4);\r\n    Long2DoubleSortedArrayMap[] ratings = { v1, v2, v3, v4 };\r\n    ItemItemBuildContext context = new ItemItemBuildContext(items, ratings, new Long2ObjectOpenHashMap<LongSortedSet>());\r\n    testRatingIntegrity(items, ratings, context);\r\n}"
}, {
	"Path": "org.lenskit.mf.funksvd.TrainingEstimator.update",
	"Comment": "update the current estimates with trained values for a new feature.",
	"Method": "void update(RealVector ufvs,RealVector ifvs){\r\n    for (RatingMatrixEntry r : ratings) {\r\n        int idx = r.getIndex();\r\n        double est = estimates[idx];\r\n        est += ufvs.getEntry(r.getUserIndex()) * ifvs.getEntry(r.getItemIndex());\r\n        if (domain != null) {\r\n            est = domain.clampValue(est);\r\n        }\r\n        estimates[idx] = est;\r\n    }\r\n}"
}, {
	"Path": "org.whispersystems.libsignal.util.guava.Preconditions.checkNotNull",
	"Comment": "ensures that an object reference passed as a parameter to the callingmethod is not null.",
	"Method": "T checkNotNull(T reference,T checkNotNull,T reference,Object errorMessage,T checkNotNull,T reference,String errorMessageTemplate,Object errorMessageArgs){\r\n    if (reference == null) {\r\n        throw new NullPointerException(format(errorMessageTemplate, errorMessageArgs));\r\n    }\r\n    return reference;\r\n}"
}, {
	"Path": "org.lenskit.predict.ordrec.OrdRecModel.getProbDistribution",
	"Comment": "get the probability distribution according to score and thresholds",
	"Method": "void getProbDistribution(double score,RealVector vec){\r\n    double pre = getProbLE(score, 0);\r\n    vec.setEntry(0, pre);\r\n    for (int i = 1; i < getLevelCount(); i++) {\r\n        double pro = getProbLE(score, i);\r\n        vec.setEntry(i, pro - pre);\r\n        pre = pro;\r\n    }\r\n}"
}, {
	"Path": "mage.cards.SplitCard.getSharedAbilities",
	"Comment": "currently only gets the fuse spellability if there is one, but generallygets any abilities on a split card as a whole, and not on either halfindividually.",
	"Method": "Abilities<Ability> getSharedAbilities(){\r\n    return super.getAbilities();\r\n}"
}, {
	"Path": "ch.qos.logback.core.joran.GenericConfigurator.registerSafeConfiguration",
	"Comment": "register the current event list in the interpreter as a safeconfiguration point.",
	"Method": "void registerSafeConfiguration(List<SaxEvent> eventList){\r\n    context.putObject(SAFE_JORAN_CONFIGURATION, eventList);\r\n}"
}, {
	"Path": "ch.qos.logback.core.joran.action.DefinePropertyAction.end",
	"Comment": "now property definer is initialized by all properties and we can putproperty value to context",
	"Method": "void end(InterpretationContext ec,String name){\r\n    if (inError) {\r\n        return;\r\n    }\r\n    Object o = ec.peekObject();\r\n    if (o != definer) {\r\n        addWarn(\"The object at the of the stack is not the property definer for property named [\" + propertyName + \"] pushed earlier.\");\r\n    } else {\r\n        addInfo(\"Popping property definer for property named [\" + propertyName + \"] from the object stack\");\r\n        ec.popObject();\r\n        String propertyValue = definer.getPropertyValue();\r\n        if (propertyValue != null) {\r\n            ActionUtil.setProperty(ec, propertyName, propertyValue, scope);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.classic.net.server.ServerSocketReceiver.setBacklog",
	"Comment": "sets the listener queue depth.this represents the number of connected clients whose connectionshave not yet been accepted.",
	"Method": "void setBacklog(int backlog){\r\n    this.backlog = backlog;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.net.server.ServerSocketReceiver.getServerSocketFactory",
	"Comment": "gets the server socket factory.subclasses may override to provide a custom factory.",
	"Method": "ServerSocketFactory getServerSocketFactory(){\r\n    return ServerSocketFactory.getDefault();\r\n}"
}, {
	"Path": "mage.client.cards.CardsList.setDeckEditorMode",
	"Comment": "if you use the deck ediot to build a free deck, numbers can be set directly in deck and sideboard",
	"Method": "void setDeckEditorMode(DeckEditorMode mode){\r\n    if (mode == DeckEditorMode.FREE_BUILDING) {\r\n        mainModel.setNumberEditable(true);\r\n        TableColumnModel tcm = mainTable.getColumnModel();\r\n        TableColumn tc = tcm.getColumn(0);\r\n        tc.setMaxWidth(55);\r\n        tc.setMinWidth(55);\r\n        tc.setPreferredWidth(55);\r\n        tc.setCellEditor(new TableSpinnerEditor(this));\r\n    }\r\n}"
}, {
	"Path": "mage.player.ai.util.CombatUtil.canBeBlocked",
	"Comment": "checks that attacker can be blocked by any blocker from the list.",
	"Method": "boolean canBeBlocked(Game game,Permanent attacker,List<Permanent> blockersList){\r\n    for (Permanent blocker : blockersList) {\r\n        if (blocker.canBlock(attacker.getId(), game)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.dropwizard.metrics.UniformSnapshot.getStdDev",
	"Comment": "returns the standard deviation of the values in the snapshot.",
	"Method": "double getStdDev(){\r\n    if (values.length <= 1) {\r\n        return 0;\r\n    }\r\n    final double mean = getMean();\r\n    double sum = 0;\r\n    for (long value : values) {\r\n        final double diff = value - mean;\r\n        sum += diff * diff;\r\n    }\r\n    final double variance = sum / (values.length - 1);\r\n    return Math.sqrt(variance);\r\n}"
}, {
	"Path": "io.dropwizard.metrics.EWMA.fifteenMinuteEWMA",
	"Comment": "creates a new ewma which is equivalent to the unix fifteen minute load average and whichexpects to be ticked every 5 seconds.",
	"Method": "EWMA fifteenMinuteEWMA(){\r\n    return new EWMA(M15_ALPHA, INTERVAL, TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "ch.qos.logback.classic.AsyncAppender.isDiscardable",
	"Comment": "events of level trace, debug and info are deemed to be discardable.",
	"Method": "boolean isDiscardable(ILoggingEvent event){\r\n    Level level = event.getLevel();\r\n    return level.toInt() <= Level.INFO_INT;\r\n}"
}, {
	"Path": "ch.qos.logback.core.encoder.LayoutWrappingEncoder.setParent",
	"Comment": "this method allows rollingpolicy implementations to be aware of theircontaining appender.",
	"Method": "void setParent(Appender<?> parent){\r\n    this.parent = parent;\r\n}"
}, {
	"Path": "mage.game.GameState.getPlayerList",
	"Comment": "returns a list of all active players of the game, setting the playerid tothe current player of the list.",
	"Method": "PlayerList getPlayerList(PlayerList getPlayerList,UUID playerId){\r\n    PlayerList newPlayerList = new PlayerList();\r\n    for (Player player : players.values()) {\r\n        if (!player.hasLeft() && !player.hasLost()) {\r\n            newPlayerList.add(player.getId());\r\n        }\r\n    }\r\n    newPlayerList.setCurrent(playerId);\r\n    return newPlayerList;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.net.SMTPAppender.subAppend",
	"Comment": "perform smtpappender specific appending actions, mainly adding the event toa cyclic buffer.",
	"Method": "void subAppend(CyclicBuffer<ILoggingEvent> cb,ILoggingEvent event){\r\n    if (includeCallerData) {\r\n        event.getCallerData();\r\n    }\r\n    event.prepareForDeferredProcessing();\r\n    cb.add(event);\r\n}"
}, {
	"Path": "mage.game.GameImpl.checkInfiniteLoop",
	"Comment": "this checks if the stack gets filled iterated, without ever getting emptyif the defined number of iterations with not more than 4 differentsourceids for the removed stack objects is reached, the players in rangeof the stackobject get asked to confirm a draw. if they do, allconfirming players get set to a draw.",
	"Method": "void checkInfiniteLoop(UUID removedStackObjectSourceId){\r\n    if (stackObjectsCheck.contains(removedStackObjectSourceId) && getStack().size() >= lastNumberOfAbilitiesOnTheStack) {\r\n        List<Integer> newLastPlayersLifes = new ArrayList();\r\n        for (Player player : this.getPlayers().values()) {\r\n            newLastPlayersLifes.add(player.getLife());\r\n        }\r\n        if (lastPlayersLifes != null && lastPlayersLifes.size() == newLastPlayersLifes.size()) {\r\n            for (int i = 0; i < newLastPlayersLifes.size(); i++) {\r\n                if (newLastPlayersLifes.get(i) < lastPlayersLifes.get(i)) {\r\n                    lastPlayersLifes = null;\r\n                    infiniteLoopCounter = 0;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            lastPlayersLifes = newLastPlayersLifes;\r\n        }\r\n        infiniteLoopCounter++;\r\n        if (infiniteLoopCounter > 15) {\r\n            Player controller = getPlayer(getControllerId(removedStackObjectSourceId));\r\n            if (controller != null) {\r\n                for (UUID playerId : getState().getPlayersInRange(controller.getId(), this)) {\r\n                    Player player = getPlayer(playerId);\r\n                    if (!player.chooseUse(Outcome.Detriment, \"Draw game because of infinite looping?\", null, this)) {\r\n                        informPlayers(controller.getLogName() + \" has NOT confirmed that the game is a draw because of infinite looping.\");\r\n                        infiniteLoopCounter = 0;\r\n                        return;\r\n                    }\r\n                    informPlayers(controller.getLogName() + \" has confirmed that the game is a draw because of infinite looping.\");\r\n                }\r\n                for (UUID playerId : getState().getPlayersInRange(controller.getId(), this)) {\r\n                    Player player = getPlayer(playerId);\r\n                    if (player != null) {\r\n                        player.drew(this);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        stackObjectsCheck.add(removedStackObjectSourceId);\r\n        if (stackObjectsCheck.size() > 4) {\r\n            stackObjectsCheck.removeFirst();\r\n        }\r\n    }\r\n    lastNumberOfAbilitiesOnTheStack = getStack().size();\r\n}"
}, {
	"Path": "mage.abilities.costs.AlternativeCost2Impl.getCastSuffixMessage",
	"Comment": "returns a text suffix for the game log, that can be added to the castmessage.",
	"Method": "String getCastSuffixMessage(int position){\r\n    StringBuilder sb = new StringBuilder(position > 0 ? \" and \" : \"\").append(\" with \");\r\n    sb.append(name);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "ch.qos.logback.classic.boolex.OnErrorEvaluator.evaluate",
	"Comment": "return true if event passed as parameter has level error or higher, returnsfalse otherwise.",
	"Method": "boolean evaluate(ILoggingEvent event){\r\n    return event.getLevel().levelInt >= Level.ERROR_INT;\r\n}"
}, {
	"Path": "mage.Mana.setAny",
	"Comment": "sets the total any mana. can not be negative. negative values will belogged and set to 0.",
	"Method": "void setAny(int any){\r\n    this.any = notNegative(any, \"Any\");\r\n}"
}, {
	"Path": "com.networknt.service.SingletonServiceFactory.setBean",
	"Comment": "this is a testing api that you can manipulate servicemap by inject an objectinto it programmatically. it is not recommended to use it for the normal codebut just for test cases in order to simulate certain scenarios.",
	"Method": "void setBean(String className,Object object){\r\n    serviceMap.put(className, object);\r\n}"
}, {
	"Path": "ch.qos.logback.core.status.OnPrintStreamStatusListenerBase.start",
	"Comment": "invoking the start method can cause the instance to print status messages created less thanvalue of retrospectivethresold.",
	"Method": "void start(){\r\n    isStarted = true;\r\n    if (retrospectiveThresold > 0) {\r\n        retrospectivePrint();\r\n    }\r\n}"
}, {
	"Path": "mage.client.dialog.NewTournamentDialog.saveTournamentSettingsToPrefs",
	"Comment": "save the settings to java prefs to reload it next time the dialog will becreated",
	"Method": "void saveTournamentSettingsToPrefs(TournamentOptions tOptions){\r\n    String versionStr = \"\";\r\n    if (currentSettingVersion == 1) {\r\n        versionStr = \"1\";\r\n    } else if (currentSettingVersion == 2) {\r\n        versionStr = \"2\";\r\n    }\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_NAME + versionStr, tOptions.getName());\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_PASSWORD + versionStr, tOptions.getPassword());\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_TIME_LIMIT + versionStr, Integer.toString(tOptions.getMatchOptions().getPriorityTime()));\r\n    if (this.spnConstructTime.isVisible()) {\r\n        PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_CONSTR_TIME + versionStr, Integer.toString(tOptions.getLimitedOptions().getConstructionTime()));\r\n    }\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_TYPE + versionStr, tOptions.getTournamentType());\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_NUMBER_OF_FREE_MULLIGANS + versionStr, Integer.toString(tOptions.getMatchOptions().getFreeMulligans()));\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_NUMBER_OF_WINS + versionStr, Integer.toString(tOptions.getMatchOptions().getWinsNeeded()));\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_QUIT_RATIO + versionStr, Integer.toString(tOptions.getQuitRatio()));\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_MINIMUM_RATING + versionStr, Integer.toString(tOptions.getMinimumRating()));\r\n    if (tOptions.getTournamentType().startsWith(\"Sealed\")) {\r\n        PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_PACKS_SEALED + versionStr, tOptions.getLimitedOptions().getSetCodes().toString());\r\n        PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_PLAYERS_SEALED + versionStr, Integer.toString(tOptions.getPlayerTypes().size()));\r\n    }\r\n    if (tOptions.getTournamentType().startsWith(\"Booster\")) {\r\n        DraftOptions draftOptions = (DraftOptions) tOptions.getLimitedOptions();\r\n        if (draftOptions != null) {\r\n            PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_PACKS_DRAFT + versionStr, draftOptions.getSetCodes().toString());\r\n            PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_PLAYERS_DRAFT + versionStr, Integer.toString(tOptions.getPlayerTypes().size()));\r\n            PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_DRAFT_TIMING + versionStr, draftOptions.getTiming().name());\r\n        }\r\n        String deckFile = this.player1Panel.getDeckFile();\r\n        if (deckFile != null && !deckFile.isEmpty()) {\r\n            PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_DECK_FILE + versionStr, deckFile);\r\n        }\r\n        if (tOptions.getLimitedOptions().getIsRandom()) {\r\n            StringBuilder packlist = new StringBuilder();\r\n            for (String pack : this.randomPackSelector.getSelectedPacks()) {\r\n                packlist.append(pack);\r\n                packlist.append(';');\r\n            }\r\n            PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_PACKS_RANDOM_DRAFT + versionStr, packlist.toString());\r\n        }\r\n    }\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_ALLOW_SPECTATORS + versionStr, (tOptions.isWatchingAllowed() ? \"Yes\" : \"No\"));\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_PLANE_CHASE + versionStr, (tOptions.isPlaneChase() ? \"Yes\" : \"No\"));\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_ALLOW_ROLLBACKS + versionStr, (tOptions.getMatchOptions().isRollbackTurnsAllowed() ? \"Yes\" : \"No\"));\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TOURNAMENT_RATED + versionStr, (tOptions.getMatchOptions().isRated() ? \"Yes\" : \"No\"));\r\n}"
}, {
	"Path": "org.lenskit.eval.crossfold.Crossfolder.setWriteTimestamps",
	"Comment": "configure whether to include timestamps in the output file.",
	"Method": "Crossfolder setWriteTimestamps(boolean pack){\r\n    writeTimestamps = pack;\r\n    return this;\r\n}"
}, {
	"Path": "mage.player.ai.util.CombatUtil.getPossibleBlockers",
	"Comment": "determines what blockers from the list can block the attacker",
	"Method": "List<Permanent> getPossibleBlockers(Game game,Permanent attacker,List<Permanent> blockersList){\r\n    List<Permanent> canBlock = new ArrayList();\r\n    for (Permanent blocker : blockersList) {\r\n        if (blocker.canBlock(attacker.getId(), game)) {\r\n            canBlock.add(blocker);\r\n        }\r\n    }\r\n    return canBlock;\r\n}"
}, {
	"Path": "com.networknt.resource.PathResourceConfigHandlerTest.testPublicFolder",
	"Comment": "when a direct is accessed, we are expecting a redirect to one of the defaultwelcome file.",
	"Method": "void testPublicFolder(){\r\n    final Http2Client client = Http2Client.getInstance();\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    final ClientConnection connection;\r\n    try {\r\n        connection = client.connect(new URI(\"http://localhost:8080\"), Http2Client.WORKER, Http2Client.BUFFER_POOL, OptionMap.EMPTY).get();\r\n    } catch (Exception e) {\r\n        throw new ClientException(e);\r\n    }\r\n    final AtomicReference<ClientResponse> reference = new AtomicReference();\r\n    try {\r\n        ClientRequest request = new ClientRequest().setPath(\"/view/index.html\").setMethod(Methods.GET);\r\n        request.getRequestHeaders().put(Headers.HOST, \"localhost\");\r\n        connection.sendRequest(request, client.createClientCallback(reference, latch));\r\n        latch.await();\r\n    } catch (Exception e) {\r\n        logger.error(\"Exception: \", e);\r\n        throw new ClientException(e);\r\n    } finally {\r\n        IoUtils.safeClose(connection);\r\n    }\r\n    int statusCode = reference.get().getResponseCode();\r\n    Assert.assertEquals(302, statusCode);\r\n}"
}, {
	"Path": "mage.server.TableController.closeTable",
	"Comment": "tables of normal matches or tournament sub tables are no longer needed,if the match ends.",
	"Method": "void closeTable(){\r\n    this.matchEnd();\r\n    table.closeTable();\r\n}"
}, {
	"Path": "ch.qos.logback.core.android.AndroidContextUtil.getDatabaseDirectoryPath",
	"Comment": "returns the absolute path to the directory on the androidfilesystem where databases are stored for the current application.",
	"Method": "String getDatabaseDirectoryPath(){\r\n    return this.context != null && this.context.getDatabasePath(\"x\") != null ? this.context.getDatabasePath(\"x\").getParent() : \"\";\r\n}"
}, {
	"Path": "ch.qos.logback.core.joran.action.AbstractEventEvaluatorAction.end",
	"Comment": "once the children elements are also parsed, now is the time to activate theevaluator options.",
	"Method": "void end(InterpretationContext ec,String e){\r\n    if (inError) {\r\n        return;\r\n    }\r\n    if (evaluator instanceof LifeCycle) {\r\n        ((LifeCycle) evaluator).start();\r\n        addInfo(\"Starting evaluator named [\" + evaluator.getName() + \"]\");\r\n    }\r\n    Object o = ec.peekObject();\r\n    if (o != evaluator) {\r\n        addWarn(\"The object on the top the of the stack is not the evaluator pushed earlier.\");\r\n    } else {\r\n        ec.popObject();\r\n        try {\r\n            Map<String, EventEvaluator<?>> evaluatorMap = (Map<String, EventEvaluator<?>>) context.getObject(CoreConstants.EVALUATOR_MAP);\r\n            if (evaluatorMap == null) {\r\n                addError(\"Could not find EvaluatorMap\");\r\n            } else {\r\n                evaluatorMap.put(evaluator.getName(), evaluator);\r\n            }\r\n        } catch (Exception ex) {\r\n            addError(\"Could not set evaluator named [\" + evaluator + \"].\", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.dropwizard.metrics.InstrumentedExecutors.newScheduledThreadPool",
	"Comment": "creates an instrumented thread pool that can schedule commands to run after agiven delay, or to execute periodically.",
	"Method": "InstrumentedScheduledExecutorService newScheduledThreadPool(int corePoolSize,MetricRegistry registry,String name,InstrumentedScheduledExecutorService newScheduledThreadPool,int corePoolSize,MetricRegistry registry,InstrumentedScheduledExecutorService newScheduledThreadPool,int corePoolSize,ThreadFactory threadFactory,MetricRegistry registry,String name,InstrumentedScheduledExecutorService newScheduledThreadPool,int corePoolSize,ThreadFactory threadFactory,MetricRegistry registry){\r\n    return new InstrumentedScheduledExecutorService(Executors.newScheduledThreadPool(corePoolSize, threadFactory), registry);\r\n}"
}, {
	"Path": "mage.client.deck.generator.DeckGeneratorPool.calculateSpellColorPercentages",
	"Comment": "calculates the percentage of colored mana symbols over all spell cards in the deck.used to balance the generation of basic lands so the amount of lands matches thecards mana costs.",
	"Method": "Map<String, Double> calculateSpellColorPercentages(){\r\n    final Map<String, Integer> colorCount = new HashMap();\r\n    for (final ColoredManaSymbol color : ColoredManaSymbol.values()) {\r\n        colorCount.put(color.toString(), 0);\r\n    }\r\n    int totalCount = 0;\r\n    List<Card> fixedSpells = getFixedSpells();\r\n    for (Card spell : fixedSpells) {\r\n        for (String symbol : spell.getManaCost().getSymbols()) {\r\n            symbol = symbol.replace(\"{\", \"\").replace(\"}\", \"\");\r\n            if (isColoredManaSymbol(symbol)) {\r\n                for (ColoredManaSymbol allowed : allowedColors) {\r\n                    if (symbol.contains(allowed.toString())) {\r\n                        int cnt = colorCount.get(allowed.toString());\r\n                        colorCount.put(allowed.toString(), cnt + 1);\r\n                        totalCount++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    final Map<String, Double> percentages = new HashMap();\r\n    for (Map.Entry<String, Integer> singleCount : colorCount.entrySet()) {\r\n        String color = singleCount.getKey();\r\n        int count = singleCount.getValue();\r\n        double percentage = (count / (double) totalCount) * 100;\r\n        percentages.put(color, percentage);\r\n    }\r\n    return percentages;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.util.LogbackMDCAdapterTest.noCopyOnInheritenceTest",
	"Comment": "test that logbackmdcadapter does not copy its hashmap when a childthread inherits it.",
	"Method": "void noCopyOnInheritenceTest(){\r\n    CountDownLatch countDownLatch = new CountDownLatch(1);\r\n    String firstKey = \"x\" + diff;\r\n    String secondKey = \"o\" + diff;\r\n    mdcAdapter.put(firstKey, firstKey + A_SUFFIX);\r\n    ChildThread childThread = new ChildThread(mdcAdapter, firstKey, secondKey, countDownLatch);\r\n    childThread.start();\r\n    countDownLatch.await();\r\n    mdcAdapter.put(firstKey, firstKey + B_SUFFIX);\r\n    childThread.join();\r\n    assertNull(mdcAdapter.get(secondKey));\r\n    assertTrue(childThread.successful);\r\n    Map<String, String> parentHM = getMapFromMDCAdapter(mdcAdapter);\r\n    assertTrue(parentHM != childThread.childHM);\r\n    HashMap<String, String> parentHMWitness = new HashMap<String, String>();\r\n    parentHMWitness.put(firstKey, firstKey + B_SUFFIX);\r\n    assertEquals(parentHMWitness, parentHM);\r\n    HashMap<String, String> childHMWitness = new HashMap<String, String>();\r\n    childHMWitness.put(secondKey, secondKey + A_SUFFIX);\r\n    assertEquals(childHMWitness, childThread.childHM);\r\n}"
}, {
	"Path": "mage.ObjectColor.getOneColoredManaSymbol",
	"Comment": "returns a coloredmanasymbol of a color included if multicolor only onesymbol is returned",
	"Method": "ColoredManaSymbol getOneColoredManaSymbol(){\r\n    if (isMulticolored()) {\r\n        throw new IllegalStateException(\"Founded multicolored object, but it's must call with single mana color.\");\r\n    }\r\n    if (isBlack()) {\r\n        return ColoredManaSymbol.B;\r\n    }\r\n    if (isRed()) {\r\n        return ColoredManaSymbol.R;\r\n    }\r\n    if (isBlue()) {\r\n        return ColoredManaSymbol.U;\r\n    }\r\n    if (isGreen()) {\r\n        return ColoredManaSymbol.G;\r\n    }\r\n    if (isWhite()) {\r\n        return ColoredManaSymbol.W;\r\n    }\r\n    if (isGold()) {\r\n        return ColoredManaSymbol.O;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "mage.server.tournament.TournamentController.isTournamentStillValid",
	"Comment": "check tournaments that are not already finished, if they are in a stillvalid state",
	"Method": "boolean isTournamentStillValid(TableState tableState){\r\n    int activePlayers = 0;\r\n    for (Entry<UUID, UUID> entry : userPlayerMap.entrySet()) {\r\n        TournamentPlayer tournamentPlayer = tournament.getPlayer(entry.getValue());\r\n        if (tournamentPlayer != null) {\r\n            if (!tournamentPlayer.hasQuit()) {\r\n                if (tournamentPlayer.getPlayer().isHuman()) {\r\n                    Optional<User> user = UserManager.instance.getUser(entry.getKey());\r\n                    if (!user.isPresent()) {\r\n                        logger.debug(\"Tournament user is missing but player active -> start quit - tournamentId: \" + tournament.getId() + \" state: \" + tableState.toString());\r\n                        quit(entry.getKey());\r\n                    } else {\r\n                        activePlayers++;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            logger.debug(\"Tournament player is missing - tournamentId: \" + tournament.getId() + \" state: \" + tableState.toString());\r\n        }\r\n    }\r\n    for (TournamentPlayer tournamentPlayer : tournament.getPlayers()) {\r\n        if (!tournamentPlayer.getPlayer().isHuman()) {\r\n            if (!tournamentPlayer.hasQuit()) {\r\n                activePlayers++;\r\n            }\r\n        }\r\n    }\r\n    if (activePlayers < 2 && tableState != TableState.WAITING) {\r\n        logger.debug(\"Tournament has less than 2 active players - tournamentId: \" + tournament.getId() + \" state: \" + tableState.toString());\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.networknt.client.Http2Client.addAuthTokenTrace",
	"Comment": "add authorization code grant token the caller app gets from oauth2 server and add traceabilityidthis is the method called from client like web server that want to have traceabilityid pass through.",
	"Method": "void addAuthTokenTrace(ClientRequest request,String token,String traceabilityId){\r\n    if (token != null && !token.startsWith(\"Bearer \")) {\r\n        if (token.toUpperCase().startsWith(\"BEARER \")) {\r\n            token = \"Bearer \" + token.substring(7);\r\n        } else {\r\n            token = \"Bearer \" + token;\r\n        }\r\n    }\r\n    request.getRequestHeaders().put(Headers.AUTHORIZATION, token);\r\n    request.getRequestHeaders().put(HttpStringConstants.TRACEABILITY_ID, traceabilityId);\r\n}"
}, {
	"Path": "org.mage.plugins.card.images.ImageCache.tryGetImage",
	"Comment": "returns the image appropriate to display for a card in a picture panel,but only it was already loaded. that is, the call is immediate and willnot block on file io.",
	"Method": "BufferedImage tryGetImage(String key,BufferedImage tryGetImage,CardView card,int width,int height){\r\n    if (Constants.THUMBNAIL_SIZE_FULL.width + 10 > width) {\r\n        return tryGetThumbnail(card);\r\n    }\r\n    String key = getKey(card, card.getName(), Integer.toString(width));\r\n    BufferedImage original = tryGetImage(key);\r\n    if (original == null) {\r\n        LOGGER.debug(key + \" not found\");\r\n        return null;\r\n    }\r\n    double scale = Math.min((double) width / original.getWidth(), (double) height / original.getHeight());\r\n    if (scale >= 1) {\r\n        return original;\r\n    }\r\n    return TransformedImageCache.getResizedImage(original, (int) (original.getWidth() * scale), (int) (original.getHeight() * scale));\r\n}"
}, {
	"Path": "com.networknt.utility.NetUtils.getLocalAddress",
	"Comment": "1. check if you already have ip2. get ip from hostname3. get ip from socket4. get ip from network interface",
	"Method": "InetAddress getLocalAddress(InetAddress getLocalAddress,Map<String, Integer> destHostPorts){\r\n    if (LOCAL_ADDRESS != null) {\r\n        return LOCAL_ADDRESS;\r\n    }\r\n    InetAddress localAddress = getLocalAddressByHostname();\r\n    if (!isValidAddress(localAddress)) {\r\n        localAddress = getLocalAddressBySocket(destHostPorts);\r\n    }\r\n    if (!isValidAddress(localAddress)) {\r\n        localAddress = getLocalAddressByNetworkInterface();\r\n    }\r\n    if (isValidAddress(localAddress)) {\r\n        LOCAL_ADDRESS = localAddress;\r\n    }\r\n    return localAddress;\r\n}"
}, {
	"Path": "ch.qos.logback.core.util.Loader.getTCL",
	"Comment": "get the thread context loader which is a jdk 1.2 feature. if we are runningunder jdk 1.1 or anything else goes wrong the method returnsnull.",
	"Method": "ClassLoader getTCL(){\r\n    return Thread.currentThread().getContextClassLoader();\r\n}"
}, {
	"Path": "org.lenskit.predict.ordrec.OrdRecRatingPredictor.trainModel",
	"Comment": "the train function of ordrec. get all parameters after learning process.",
	"Method": "void trainModel(OrdRecModel model,Long2DoubleMap ratings,Map<Long, Double> scores){\r\n    RealVector beta = model.getBeta();\r\n    RealVector deltaBeta = new ArrayRealVector(beta.getDimension());\r\n    double dt1;\r\n    for (int j = 0; j < iterationCount; j++) {\r\n        for (Long2DoubleMap.Entry rating : Vectors.fastEntries(ratings)) {\r\n            long iid = rating.getLongKey();\r\n            double score = scores.get(iid);\r\n            int r = quantizer.index(rating.getDoubleValue());\r\n            double probEqualR = model.getProbEQ(score, r);\r\n            double probLessR = model.getProbLE(score, r);\r\n            double probLessR_1 = model.getProbLE(score, r - 1);\r\n            double t1 = model.getT1();\r\n            dt1 = learningRate / probEqualR * (probLessR * (1 - probLessR) * dBeta(r, 0, t1) - probLessR_1 * (1 - probLessR_1) * dBeta(r - 1, 0, t1) - regTerm * t1);\r\n            double dbetaK;\r\n            for (int k = 0; k < beta.getDimension(); k++) {\r\n                dbetaK = learningRate / probEqualR * (probLessR * (1 - probLessR) * dBeta(r, k + 1, beta.getEntry(k)) - probLessR_1 * (1 - probLessR_1) * dBeta(r - 1, k + 1, beta.getEntry(k)) - regTerm * beta.getEntry(k));\r\n                deltaBeta.setEntry(k, dbetaK);\r\n            }\r\n            model.update(dt1, deltaBeta);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.classic.turbo.DynamicThresholdFilter.getOnLower",
	"Comment": "get the filterreply when the effective level is lower than the level ofcurrent logging request",
	"Method": "FilterReply getOnLower(){\r\n    return onLower;\r\n}"
}, {
	"Path": "ch.qos.logback.core.pattern.DynamicConverter.start",
	"Comment": "components that depend on options passed during configuration can overridethis method in order to make appropriate use of those options. for simplercomponents, the trivial implementation found in this abstract class will besufficient.",
	"Method": "void start(){\r\n    started = true;\r\n}"
}, {
	"Path": "io.dropwizard.metrics.UnsafeLongAdderImpl.reset",
	"Comment": "resets variables maintaining the sum to zero.this method may be a useful alternative tocreating a new adder, but is only effective if there are no concurrent updates.because thismethod is intrinsically racy, it should only be used when it is known that no threads areconcurrently updating.",
	"Method": "void reset(){\r\n    internalReset(0L);\r\n}"
}, {
	"Path": "ch.qos.logback.core.joran.GenericConfigurator.recallSafeConfiguration",
	"Comment": "recall the event list previously registered as a safe point.",
	"Method": "List<SaxEvent> recallSafeConfiguration(){\r\n    return (List<SaxEvent>) context.getObject(SAFE_JORAN_CONFIGURATION);\r\n}"
}, {
	"Path": "ch.qos.logback.classic.pattern.DateConverterTest.convert",
	"Comment": "gets the output of a dateconverter, configured with the given settings",
	"Method": "String convert(long timestamp,String options){\r\n    DateConverter converter = getDateConverter(options);\r\n    converter.start();\r\n    return converter.convert(makeLoggingEvent(timestamp));\r\n}"
}, {
	"Path": "ch.qos.logback.core.pattern.util.AsIsEscapeUtil.escape",
	"Comment": "do not perform any character escaping.note that this method assumes that it is called after the escape characterhas been consumed.",
	"Method": "void escape(String escapeChars,StringBuffer buf,char next,int pointer){\r\n    buf.append(\"\\\\\");\r\n    buf.append(next);\r\n}"
}, {
	"Path": "mage.util.ManaUtil.tryToAutoSelectAManaColor",
	"Comment": "for human players this is called before a player is asked to select amana color to pay a specific cost. if the choice obvious, the color isauto picked by this method without bothering the human player",
	"Method": "boolean tryToAutoSelectAManaColor(Choice choice,ManaCost unpaid){\r\n    String colorToAutoPay = null;\r\n    if (unpaid.containsColor(ColoredManaSymbol.W) && choice.getChoices().contains(\"White\")) {\r\n        colorToAutoPay = \"White\";\r\n    }\r\n    if (unpaid.containsColor(ColoredManaSymbol.R) && choice.getChoices().contains(\"Red\")) {\r\n        if (colorToAutoPay != null) {\r\n            return false;\r\n        }\r\n        colorToAutoPay = \"Red\";\r\n    }\r\n    if (unpaid.containsColor(ColoredManaSymbol.G) && choice.getChoices().contains(\"Green\")) {\r\n        if (colorToAutoPay != null) {\r\n            return false;\r\n        }\r\n        colorToAutoPay = \"Green\";\r\n    }\r\n    if (unpaid.containsColor(ColoredManaSymbol.U) && choice.getChoices().contains(\"Blue\")) {\r\n        if (colorToAutoPay != null) {\r\n            return false;\r\n        }\r\n        colorToAutoPay = \"Blue\";\r\n    }\r\n    if (unpaid.containsColor(ColoredManaSymbol.B) && choice.getChoices().contains(\"Black\")) {\r\n        if (colorToAutoPay != null) {\r\n            return false;\r\n        }\r\n        colorToAutoPay = \"Black\";\r\n    }\r\n    if (unpaid.getMana().getDifferentColors() == 0) {\r\n        colorToAutoPay = choice.getChoices().iterator().next();\r\n    }\r\n    if (colorToAutoPay != null) {\r\n        choice.setChoice(colorToAutoPay);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.turbo.ReconfigureOnChangeTest.installFilter",
	"Comment": "tests whether configurationaction is installing reconfigureonchangefilter",
	"Method": "void installFilter(){\r\n    File file = new File(SCAN1_FILE_AS_STR);\r\n    configure(file);\r\n    List<File> fileList = getConfigurationFileList(loggerContext);\r\n    assertThatListContainsFile(fileList, file);\r\n    assertThatFirstFilterIsROCF();\r\n    StatusPrinter.print(loggerContext);\r\n}"
}, {
	"Path": "org.lenskit.knn.user.UserUserItemScorer.findNeighbors",
	"Comment": "find the neighbors for a user with respect to a collection of items.for each item, the neighborhoodsize users closest to theprovided user are returned.",
	"Method": "Long2ObjectMap<List<Neighbor>> findNeighbors(long user,LongSet items){\r\n    Preconditions.checkNotNull(user, \"user profile\");\r\n    Preconditions.checkNotNull(user, \"item set\");\r\n    Long2ObjectOpenHashMap<SortedListAccumulator<Neighbor>> heaps = new Long2ObjectOpenHashMap(items.size());\r\n    for (LongIterator iter = items.iterator(); iter.hasNext(); ) {\r\n        long item = iter.nextLong();\r\n        heaps.put(item, SortedListAccumulator.decreasing(neighborhoodSize, Neighbor.SIMILARITY_COMPARATOR));\r\n    }\r\n    for (Neighbor nbr : neighborFinder.getCandidateNeighbors(user, items)) {\r\n        for (Long2DoubleMap.Entry e : Vectors.fastEntries(nbr.vector)) {\r\n            final long item = e.getLongKey();\r\n            SortedListAccumulator<Neighbor> heap = heaps.get(item);\r\n            if (heap != null) {\r\n                heap.add(nbr);\r\n            }\r\n        }\r\n    }\r\n    Long2ObjectMap<List<Neighbor>> neighbors = new Long2ObjectOpenHashMap();\r\n    Iterator<Long2ObjectMap.Entry<SortedListAccumulator<Neighbor>>> hiter = heaps.long2ObjectEntrySet().fastIterator();\r\n    while (hiter.hasNext()) {\r\n        Long2ObjectMap.Entry<SortedListAccumulator<Neighbor>> me = hiter.next();\r\n        neighbors.put(me.getLongKey(), me.getValue().finish());\r\n    }\r\n    return neighbors;\r\n}"
}, {
	"Path": "com.networknt.client.Http2Client.addCcTokenTrace",
	"Comment": "add client credentials token cached in the client for standalone applicationthis is the method called from standalone application like enterprise scheduler for batch jobsor mobile apps.",
	"Method": "void addCcTokenTrace(ClientRequest request,String traceabilityId){\r\n    checkCCTokenExpired();\r\n    request.getRequestHeaders().put(Headers.AUTHORIZATION, \"Bearer \" + jwt);\r\n    request.getRequestHeaders().put(HttpStringConstants.TRACEABILITY_ID, traceabilityId);\r\n}"
}, {
	"Path": "io.dropwizard.metrics.EWMA.oneMinuteEWMA",
	"Comment": "creates a new ewma which is equivalent to the unix one minute load average and which expectsto be ticked every 5 seconds.",
	"Method": "EWMA oneMinuteEWMA(){\r\n    return new EWMA(M1_ALPHA, INTERVAL, TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "ch.qos.logback.classic.spi.LoggingEvent.getThrowableProxy",
	"Comment": "returns the throwable information contained within this event. may benull if there is no such information.",
	"Method": "IThrowableProxy getThrowableProxy(){\r\n    return throwableProxy;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.pattern.DateConverterTest.formatDate",
	"Comment": "gets a string representation of the test date formatted with the prespecified test pattern",
	"Method": "String formatDate(String timeZone){\r\n    return formatDateWithPattern(_date, DATETIME_PATTERN, timeZone);\r\n}"
}, {
	"Path": "mage.abilities.effects.RestrictionEffect.canBeBlockedCheckAfter",
	"Comment": "called for all attackers after all blocking decisions are made",
	"Method": "boolean canBeBlockedCheckAfter(Permanent attacker,Ability source,Game game){\r\n    return true;\r\n}"
}, {
	"Path": "com.networknt.service.ServiceUtil.constructByNamedParams",
	"Comment": "build an object out of a given class and a map for field names to values.",
	"Method": "Object constructByNamedParams(Class clazz,Map params){\r\n    Object obj = clazz.newInstance();\r\n    Method[] allMethods = clazz.getMethods();\r\n    for (Method method : allMethods) {\r\n        if (method.getName().startsWith(\"set\")) {\r\n            Object[] o = new Object[1];\r\n            String propertyName = Introspector.decapitalize(method.getName().substring(3));\r\n            if (params.containsKey(propertyName)) {\r\n                o[0] = params.get(propertyName);\r\n                method.invoke(obj, o);\r\n            }\r\n        }\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "org.lenskit.eval.crossfold.CrossfoldMethods.partitionUsers",
	"Comment": "create a crossfold method that splits users into disjoint partitions.",
	"Method": "CrossfoldMethod partitionUsers(SortOrder order,HistoryPartitionMethod part){\r\n    return new GroupedCrossfoldMethod(CommonTypes.USER, CommonAttributes.USER_ID, GroupEntitySplitter.partition(), order, part);\r\n}"
}, {
	"Path": "mage.client.util.Format.getDuration",
	"Comment": "converts seconds to a string with hours, minutes and seconds",
	"Method": "String getDuration(Date fromDate,Date toDate,String getDuration,long seconds){\r\n    StringBuilder sb = new StringBuilder();\r\n    long h = seconds / 3600;\r\n    seconds = seconds % 3600;\r\n    long m = seconds / 60;\r\n    long s = seconds % 60;\r\n    sb.append(h).append(':');\r\n    if (m < 10) {\r\n        sb.append('0');\r\n    }\r\n    sb.append(m).append(':');\r\n    if (s < 10) {\r\n        sb.append('0');\r\n    }\r\n    sb.append(s);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "ch.qos.logback.core.OutputStreamAppender.subAppend",
	"Comment": "actual writing occurs here.most subclasses of writerappender will need to override thismethod.",
	"Method": "void subAppend(E event){\r\n    if (!isStarted()) {\r\n        return;\r\n    }\r\n    try {\r\n        if (event instanceof DeferredProcessingAware) {\r\n            ((DeferredProcessingAware) event).prepareForDeferredProcessing();\r\n        }\r\n        byte[] byteArray = this.encoder.encode(event);\r\n        writeBytes(byteArray);\r\n    } catch (IOException ioe) {\r\n        this.started = false;\r\n        addStatus(new ErrorStatus(\"IO failure in appender\", this, ioe));\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.OutputStreamAppender.start",
	"Comment": "checks that requires parameters are set and if everything is in order,activates this appender.",
	"Method": "void start(){\r\n    int errors = 0;\r\n    if (this.encoder == null) {\r\n        addStatus(new ErrorStatus(\"No encoder set for the appender named \\\"\" + name + \"\\\".\", this));\r\n        errors++;\r\n    }\r\n    if (this.outputStream == null) {\r\n        addStatus(new ErrorStatus(\"No output stream set for the appender named \\\"\" + name + \"\\\".\", this));\r\n        errors++;\r\n    }\r\n    if (errors == 0) {\r\n        super.start();\r\n    }\r\n}"
}, {
	"Path": "mage.actions.score.ArtificialScoringSystem.getLoseGameScore",
	"Comment": "lose score is lowered in function of the turn and phase when it occurs.encourages ai to win as fast as possible.",
	"Method": "int getLoseGameScore(Game game){\r\n    if (game.getStep() == null) {\r\n        return 0;\r\n    }\r\n    return ScoringConstants.LOSE_GAME_SCORE + game.getTurnNum() * 2500 + game.getStep().getType().getIndex() * 200;\r\n}"
}, {
	"Path": "mage.util.FastByteArrayOutputStream.verifyBufferSize",
	"Comment": "ensures that we have a large enough buffer for the given size.",
	"Method": "void verifyBufferSize(int sz){\r\n    if (sz > buf.length) {\r\n        byte[] old = buf;\r\n        buf = new byte[Math.max(sz, 2 * buf.length)];\r\n        System.arraycopy(old, 0, buf, 0, old.length);\r\n        old = null;\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.util.math.MutualInformationAccumulatorTest.testUniformFullMI2",
	"Comment": "several data points, uniform distribution, consistent but not same.",
	"Method": "void testUniformFullMI2(){\r\n    for (int i = 0; i < 24; i++) {\r\n        accum.count(i % 4, 3 - (i + 2) % 4);\r\n    }\r\n    assertThat(accum.getV1Entropy(), closeTo(2));\r\n    assertThat(accum.getV2Entropy(), closeTo(2));\r\n    assertThat(accum.getMutualInformation(), closeTo(2));\r\n}"
}, {
	"Path": "org.lenskit.eval.traintest.TrainTestExperiment.getParallelTasks",
	"Comment": "get the number of evaluation tasks to permit to run in parallel.reducing this can be useful for reducingthe memory use of lenskit.",
	"Method": "int getParallelTasks(){\r\n    return parallelTasks;\r\n}"
}, {
	"Path": "com.networknt.url.HttpURL.toAbsolute",
	"Comment": "converts a relative url to an absolute one, based on the suppliedbase url. the base url is assumed to be a valid url. behavioris unexpected when base url is invalid.",
	"Method": "String toAbsolute(String baseURL,String relativeURL){\r\n    String relURL = relativeURL;\r\n    if (relURL.startsWith(\"//\")) {\r\n        return StringUtils.substringBefore(baseURL, \"//\") + \"//\" + StringUtils.substringAfter(relURL, \"//\");\r\n    }\r\n    if (relURL.startsWith(\"/\")) {\r\n        return getRoot(baseURL) + relURL;\r\n    }\r\n    if (relURL.startsWith(\"?\") || relURL.startsWith(\"#\")) {\r\n        return baseURL.replaceFirst(\"(.*?)([\\\\?\\\\#])(.*)\", \"$1\") + relURL;\r\n    }\r\n    if (!relURL.contains(\"://\")) {\r\n        String base = baseURL.replaceFirst(\"(.*?)([\\\\?\\\\#])(.*)\", \"$1\");\r\n        if (StringUtils.countMatches(base, '/') > 2) {\r\n            base = base.replaceFirst(\"(.*/)(.*)\", \"$1\");\r\n        }\r\n        if (base.endsWith(\"/\")) {\r\n            relURL = base + relURL;\r\n        } else {\r\n            relURL = base + \"/\" + relURL;\r\n        }\r\n    }\r\n    return relURL;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.net.SimpleSocketServer.signalAlmostReadiness",
	"Comment": "signal another thread that we have established a connectionthis is useful for testing purposes.",
	"Method": "void signalAlmostReadiness(){\r\n    if (latch != null && latch.getCount() != 0) {\r\n        latch.countDown();\r\n    }\r\n}"
}, {
	"Path": "mage.abilities.effects.ContinuousEffectImpl.isTemporary",
	"Comment": "returns the status if the effect is temporary added to thecontinuouseffects",
	"Method": "boolean isTemporary(){\r\n    return temporary;\r\n}"
}, {
	"Path": "mage.client.components.layout.RelativeLayout.setBorderGap",
	"Comment": "sets the initial gap. this gap is used before the leading componentand after the trailing component. the default is set to the gap.",
	"Method": "void setBorderGap(int borderGap){\r\n    this.borderGap = borderGap < 0 ? 0 : borderGap;\r\n}"
}, {
	"Path": "ch.qos.logback.core.util.Loader.getClassLoaderOfClass",
	"Comment": "return the class loader which loaded the class passed as argument. returnthe system class loader if appropriate.",
	"Method": "ClassLoader getClassLoaderOfClass(Class<?> clazz){\r\n    ClassLoader cl = clazz.getClassLoader();\r\n    if (cl == null) {\r\n        return ClassLoader.getSystemClassLoader();\r\n    } else {\r\n        return cl;\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.classic.turbo.DynamicThresholdFilter.getOnHigherOrEqual",
	"Comment": "get the filterreply when the effective level is higher or equal to thelevel of current logging request",
	"Method": "FilterReply getOnHigherOrEqual(){\r\n    return onHigherOrEqual;\r\n}"
}, {
	"Path": "mage.abilities.mana.ActivatedManaAbilityImpl.definesMana",
	"Comment": "used to check if the ability itself defines mana types it can produce.",
	"Method": "boolean definesMana(Game game){\r\n    return !getNetMana(game).isEmpty();\r\n}"
}, {
	"Path": "com.networknt.service.SingletonServiceFactory.handleSingletonClass",
	"Comment": "for each singleton definition, create object with the initializer class and method,and push it into the service map with the key of the class name.",
	"Method": "void handleSingletonClass(String key,String value){\r\n    Object object = handleValue(value);\r\n    if (key.contains(\",\")) {\r\n        String[] interfaces = key.split(\",\");\r\n        for (String anInterface : interfaces) {\r\n            serviceMap.put(anInterface, object);\r\n        }\r\n    } else {\r\n        serviceMap.put(key, object);\r\n    }\r\n}"
}, {
	"Path": "io.dropwizard.metrics.Snapshot.get98thPercentile",
	"Comment": "returns the value at the 98th percentile in the distribution.",
	"Method": "double get98thPercentile(){\r\n    return getValue(0.98);\r\n}"
}, {
	"Path": "io.dropwizard.metrics.Snapshot.get99thPercentile",
	"Comment": "returns the value at the 99th percentile in the distribution.",
	"Method": "double get99thPercentile(){\r\n    return getValue(0.99);\r\n}"
}, {
	"Path": "mage.player.ai.SimulatedPlayer2.filterAbilities",
	"Comment": "if suggested abilities exist, return only those from playables",
	"Method": "List<Ability> filterAbilities(Game game,List<Ability> playables,List<String> suggested){\r\n    if (playables.isEmpty()) {\r\n        return playables;\r\n    }\r\n    if (suggested == null || suggested.isEmpty()) {\r\n        return playables;\r\n    }\r\n    List<Ability> filtered = new ArrayList();\r\n    for (Ability ability : playables) {\r\n        Card card = game.getCard(ability.getSourceId());\r\n        for (String s : suggested) {\r\n            if (s.equals(card.getName())) {\r\n                logger.debug(\"matched: \" + s);\r\n                forced = true;\r\n                filtered.add(ability);\r\n            }\r\n        }\r\n    }\r\n    if (!filtered.isEmpty()) {\r\n        return filtered;\r\n    }\r\n    return playables;\r\n}"
}, {
	"Path": "org.lenskit.gradle.LenskitExtension.getLogFileLevel",
	"Comment": "the log level to use for log files.default is unset, resulting in the same level being applied to the consoleand the log file.",
	"Method": "Property<String> getLogFileLevel(){\r\n    return logFileLevel;\r\n}"
}, {
	"Path": "com.networknt.consul.ConsulRegistry.updateServiceCache",
	"Comment": "update service cache of the servicename.update local cache when service list changed,if need notify, notify service",
	"Method": "void updateServiceCache(String serviceName,ConcurrentHashMap<String, List<URL>> serviceUrls,boolean needNotify){\r\n    if (serviceUrls != null && !serviceUrls.isEmpty()) {\r\n        List<URL> urls = serviceCache.get(serviceName);\r\n        if (urls == null) {\r\n            if (logger.isDebugEnabled()) {\r\n                try {\r\n                    logger.debug(\"serviceUrls = \" + Config.getInstance().getMapper().writeValueAsString(serviceUrls));\r\n                } catch (Exception e) {\r\n                }\r\n            }\r\n            serviceCache.put(serviceName, serviceUrls.get(serviceName));\r\n        }\r\n        for (Map.Entry<String, List<URL>> entry : serviceUrls.entrySet()) {\r\n            boolean change = true;\r\n            if (urls != null) {\r\n                List<URL> newUrls = entry.getValue();\r\n                if (newUrls == null || newUrls.isEmpty() || ConsulUtils.isSame(newUrls, urls)) {\r\n                    change = false;\r\n                } else {\r\n                    serviceCache.put(serviceName, newUrls);\r\n                }\r\n            }\r\n            if (change && needNotify) {\r\n                notifyExecutor.execute(new NotifyService(entry.getKey(), entry.getValue()));\r\n                logger.info(\"light service notify-service: \" + entry.getKey());\r\n                StringBuilder sb = new StringBuilder();\r\n                for (URL url : entry.getValue()) {\r\n                    sb.append(url.getUri()).append(\";\");\r\n                }\r\n                logger.info(\"consul notify urls:\" + sb.toString());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.networknt.consul.ConsulUtils.isSame",
	"Comment": "check if two lists have the same urls. if any list is empty, return false",
	"Method": "boolean isSame(List<URL> urls1,List<URL> urls2){\r\n    if (urls1 == null || urls2 == null) {\r\n        return false;\r\n    }\r\n    if (urls1.size() != urls2.size()) {\r\n        return false;\r\n    }\r\n    return urls1.containsAll(urls2);\r\n}"
}, {
	"Path": "io.dropwizard.metrics.MetricName.tagged",
	"Comment": "add tags to a metric name and return the newly created metricname.",
	"Method": "MetricName tagged(Map<String, String> add,MetricName tagged,String pairs){\r\n    if (pairs == null) {\r\n        return this;\r\n    }\r\n    if (pairs.length % 2 != 0) {\r\n        throw new IllegalArgumentException(\"Argument count must be even\");\r\n    }\r\n    final Map<String, String> add = new HashMap();\r\n    for (int i = 0; i < pairs.length; i += 2) {\r\n        add.put(pairs[i], pairs[i + 1]);\r\n    }\r\n    return tagged(add);\r\n}"
}, {
	"Path": "ch.qos.logback.core.joran.action.ShutdownHookAction.end",
	"Comment": "once the children elements are also parsed, now is the time to activate theshutdown hook options.",
	"Method": "void end(InterpretationContext ic,String name){\r\n    if (inError) {\r\n        return;\r\n    }\r\n    Object o = ic.peekObject();\r\n    if (o != hook) {\r\n        addWarn(\"The object at the of the stack is not the hook pushed earlier.\");\r\n    } else {\r\n        ic.popObject();\r\n        Thread hookThread = new Thread(hook, \"Logback shutdown hook [\" + context.getName() + \"]\");\r\n        addInfo(\"Registering shutdown hook with JVM runtime\");\r\n        context.putObject(CoreConstants.SHUTDOWN_HOOK_THREAD, hookThread);\r\n        Runtime.getRuntime().addShutdownHook(hookThread);\r\n    }\r\n}"
}, {
	"Path": "mage.player.ai.MCTSNode.createSimulation",
	"Comment": "copies game and replaces all players in copy with simulated playersshuffles each players library so that there is no knowledge of its order",
	"Method": "Game createSimulation(Game game,UUID playerId){\r\n    Game sim = game.copy();\r\n    for (Player copyPlayer : sim.getState().getPlayers().values()) {\r\n        Player origPlayer = game.getState().getPlayers().get(copyPlayer.getId()).copy();\r\n        SimulatedPlayerMCTS newPlayer = new SimulatedPlayerMCTS(copyPlayer.getId(), true);\r\n        newPlayer.restore(origPlayer);\r\n        sim.getState().getPlayers().put(copyPlayer.getId(), newPlayer);\r\n    }\r\n    randomizePlayers(sim, playerId);\r\n    sim.setSimulation(true);\r\n    return sim;\r\n}"
}, {
	"Path": "org.lenskit.util.math.Vectors.euclideanNorm",
	"Comment": "compute the euclidean norm of the values of the map. this is the square root of the sum of squares.",
	"Method": "double euclideanNorm(Long2DoubleMap v){\r\n    return Math.sqrt(sumOfSquares(v));\r\n}"
}, {
	"Path": "org.lenskit.eval.crossfold.Crossfolder.setName",
	"Comment": "set a name for this crossfolder.it will be used to generate the names of individual data sets, for example.",
	"Method": "Crossfolder setName(String n){\r\n    name = n;\r\n    return this;\r\n}"
}, {
	"Path": "io.dropwizard.metrics.Snapshot.get95thPercentile",
	"Comment": "returns the value at the 95th percentile in the distribution.",
	"Method": "double get95thPercentile(){\r\n    return getValue(0.95);\r\n}"
}, {
	"Path": "ch.qos.logback.core.joran.action.IncludeAction.createRecorder",
	"Comment": "creates a sax event recorder based on given parameters. subclassesshould override this as necessary.",
	"Method": "SaxEventRecorder createRecorder(InputStream in,URL url){\r\n    return new SaxEventRecorder(getContext());\r\n}"
}, {
	"Path": "mage.game.permanent.PermanentImpl.reset",
	"Comment": "called before each applyeffects or if after a permanent was copied forthe copied object",
	"Method": "void reset(Game game){\r\n    this.resetControl();\r\n    this.maxBlocks = 1;\r\n    this.minBlockedBy = 1;\r\n    this.maxBlockedBy = 0;\r\n    this.copy = false;\r\n    for (TextPart textPart : textParts) {\r\n        textPart.reset();\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.classic.util.LogbackMDCAdapterTest.LOGBACK_442",
	"Comment": "test that copyoninheritthreadlocal does not barf when themdc hashmap is null",
	"Method": "void LOGBACK_442(){\r\n    Map<String, String> parentHM = getMapFromMDCAdapter(mdcAdapter);\r\n    assertNull(parentHM);\r\n    ChildThreadForMDCAdapter childThread = new ChildThreadForMDCAdapter(mdcAdapter);\r\n    childThread.start();\r\n    childThread.join();\r\n    assertTrue(childThread.successul);\r\n    assertNull(childThread.childHM);\r\n}"
}, {
	"Path": "com.networknt.handler.config.PathChain.validate",
	"Comment": "validate the settings and raise exception on error.the origin is used to help locate problems.",
	"Method": "void validate(String origin){\r\n    List<String> problems = new ArrayList();\r\n    if (source == null) {\r\n        if (path == null) {\r\n            problems.add(\"You must specify either path or source\");\r\n        } else if (method == null) {\r\n            problems.add(\"You must specify method along with path: \" + path);\r\n        }\r\n    } else {\r\n        if (path != null) {\r\n            problems.add(\"Conflicting source: \" + source + \" and path: \" + path);\r\n        }\r\n        if (method != null) {\r\n            problems.add(\"Conflicting source: \" + source + \" and method: \" + method);\r\n        }\r\n    }\r\n    if (method != null && !NetUtils.METHODS.contains(method.toUpperCase())) {\r\n        problems.add(\"Invalid HTTP method: \" + method);\r\n    }\r\n    if (!problems.isEmpty()) {\r\n        throw new RuntimeException(\"Bad paths element in \" + origin + \" [ \" + String.join(\" | \", problems) + \" ]\");\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.eval.traintest.AlgorithmInstanceBuilder.setAttribute",
	"Comment": "set an attribute for this algorithm instance. used for distinguishing similarinstances in an algorithm family.",
	"Method": "AlgorithmInstanceBuilder setAttribute(String attr,Object value){\r\n    Preconditions.checkNotNull(attr, \"attribute names cannot be null\");\r\n    Preconditions.checkNotNull(value, \"attribute values cannot be null\");\r\n    attributes.put(attr, value);\r\n    return this;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.HLoggerContext.exists",
	"Comment": "check if the named logger exists in the hierarchy. if so returnits reference, otherwise returns null.",
	"Method": "HLogger exists(String name){\r\n    int i = 0;\r\n    HLogger HLogger = root;\r\n    HLogger childHLogger = null;\r\n    String childName;\r\n    while (true) {\r\n        int h = name.indexOf('.', i);\r\n        if (h == -1) {\r\n            childName = name.substring(i);\r\n        } else {\r\n            childName = name.substring(i, h);\r\n        }\r\n        i = h + 1;\r\n        synchronized (HLogger) {\r\n            childHLogger = HLogger.getChildBySuffix(childName);\r\n            if (childHLogger == null) {\r\n                return null;\r\n            }\r\n        }\r\n        HLogger = childHLogger;\r\n        if (h == -1) {\r\n            if (childHLogger.getName().equals(name)) {\r\n                return childHLogger;\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mage.abilities.effects.common.ManaEffect.getMana",
	"Comment": "creates the mana the effect can produce or if that already has happenedreturns the mana the effect has created during its process of resolving",
	"Method": "Mana getMana(Game game,Ability source){\r\n    if (createdMana == null) {\r\n        return createdMana = produceMana(false, game, source);\r\n    }\r\n    return createdMana;\r\n}"
}, {
	"Path": "mage.deck.SuperType2.validate",
	"Comment": "overridden validate function. changes the standard sets, then uses theregular validation function to test validity.",
	"Method": "boolean validate(Deck deck){\r\n    Map<String, String> leastInvalid = null;\r\n    boolean valid = false;\r\n    Map<String, Integer> counts = new HashMap();\r\n    countCards(counts, deck.getCards());\r\n    countCards(counts, deck.getSideboard());\r\n    if (counts.containsKey(\"Stoneforge Mystic\") && counts.containsKey(\"Batterskull\")) {\r\n        return false;\r\n    }\r\n    for (String[] sets : standards) {\r\n        invalid.clear();\r\n        setCodes = new ArrayList(Arrays.asList(sets));\r\n        if (setCodes.contains(\"MRD\") || setCodes.contains(\"SOM\")) {\r\n            banned.add(\"Darksteel Citadel\");\r\n        } else {\r\n            banned.remove(\"Darksteel Citadel\");\r\n        }\r\n        if (super.validate(deck)) {\r\n            valid = true;\r\n            break;\r\n        }\r\n        if (leastInvalid == null) {\r\n            leastInvalid = new HashMap(this.getInvalid());\r\n            continue;\r\n        }\r\n        if (leastInvalid.size() > this.getInvalid().size()) {\r\n            leastInvalid = new HashMap(this.getInvalid());\r\n        }\r\n    }\r\n    GregorianCalendar start = new GregorianCalendar(2006, Calendar.SEPTEMBER, 1);\r\n    GregorianCalendar end = new GregorianCalendar(2008, Calendar.SEPTEMBER, 1);\r\n    GregorianCalendar current = new GregorianCalendar();\r\n    while (end.before(current) && !valid) {\r\n        setCodes.clear();\r\n        invalid.clear();\r\n        start.set(Calendar.YEAR, start.get(Calendar.YEAR) + 1);\r\n        end.set(Calendar.YEAR, start.get(Calendar.YEAR) + 2);\r\n        for (ExpansionSet set : Sets.getInstance().values()) {\r\n            if (set.getReleaseDate().after(start.getTime()) && set.getReleaseDate().before(end.getTime()) && (set.getSetType() == SetType.CORE || set.getSetType() == SetType.EXPANSION)) {\r\n                setCodes.add(set.getCode());\r\n            }\r\n        }\r\n        if (setCodes.contains(\"MRD\") || setCodes.contains(\"SOM\")) {\r\n            banned.add(\"Darksteel Citadel\");\r\n        } else {\r\n            banned.remove(\"Darksteel Citadel\");\r\n        }\r\n        if (super.validate(deck)) {\r\n            invalid.clear();\r\n            valid = true;\r\n            break;\r\n        }\r\n        if (leastInvalid == null) {\r\n            leastInvalid = new HashMap(this.getInvalid());\r\n        } else if (leastInvalid.size() > this.getInvalid().size()) {\r\n            leastInvalid = new HashMap(this.getInvalid());\r\n        }\r\n    }\r\n    if (!valid) {\r\n        this.invalid = new HashMap(leastInvalid);\r\n    }\r\n    return valid;\r\n}"
}, {
	"Path": "mage.utils.CompressUtil.decompress",
	"Comment": "decompress data, but only if it was compressed previously return originalobject otherwise.",
	"Method": "Object decompress(Object data){\r\n    if (!(data instanceof ZippedObject)) {\r\n        return data;\r\n    }\r\n    return ((ZippedObject) data).unzip();\r\n}"
}, {
	"Path": "com.networknt.security.JwtHelper.readCertificate",
	"Comment": "read certificate from a file and convert it into x509certificate object",
	"Method": "X509Certificate readCertificate(String filename){\r\n    InputStream inStream = null;\r\n    X509Certificate cert = null;\r\n    try {\r\n        inStream = Config.getInstance().getInputStreamFromFile(filename);\r\n        if (inStream != null) {\r\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\r\n            cert = (X509Certificate) cf.generateCertificate(inStream);\r\n        } else {\r\n            logger.info(\"Certificate \" + Encode.forJava(filename) + \" not found.\");\r\n        }\r\n    } catch (Exception e) {\r\n        logger.error(\"Exception: \", e);\r\n    } finally {\r\n        if (inStream != null) {\r\n            try {\r\n                inStream.close();\r\n            } catch (IOException ioe) {\r\n                logger.error(\"Exception: \", ioe);\r\n            }\r\n        }\r\n    }\r\n    return cert;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.LoggerContext.exists",
	"Comment": "check if the named logger exists in the hierarchy. if so return itsreference, otherwise returns null.",
	"Method": "Logger exists(String name){\r\n    return (Logger) loggerCache.get(name);\r\n}"
}, {
	"Path": "mage.player.ai.ComputerPlayer6.createSimulation",
	"Comment": "copies game and replaces all players in copy with simulated players",
	"Method": "Game createSimulation(Game game){\r\n    Game sim = game.copy();\r\n    sim.setSimulation(true);\r\n    for (Player copyPlayer : sim.getState().getPlayers().values()) {\r\n        Player origPlayer = game.getState().getPlayers().get(copyPlayer.getId()).copy();\r\n        if (!suggested.isEmpty()) {\r\n            logger.debug(origPlayer.getName() + \" suggested: \" + suggested);\r\n        }\r\n        SimulatedPlayer2 newPlayer = new SimulatedPlayer2(copyPlayer.getId(), copyPlayer.getId().equals(playerId), suggested);\r\n        newPlayer.restore(origPlayer);\r\n        sim.getState().getPlayers().put(copyPlayer.getId(), newPlayer);\r\n    }\r\n    return sim;\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.ssl.SSLContextFactoryBean.locationFromSystemProperty",
	"Comment": "constructs a resource location from a jsse system property.",
	"Method": "String locationFromSystemProperty(String name){\r\n    String location = System.getProperty(name);\r\n    if (location != null && !location.startsWith(\"file:\")) {\r\n        location = \"file:\" + location;\r\n    }\r\n    return location;\r\n}"
}, {
	"Path": "mage.util.CircularList.checkPointer",
	"Comment": "this method should only be called from a locked method thus it is notnecessary to lock from this method",
	"Method": "int checkPointer(){\r\n    if (index > list.size()) {\r\n        index = list.size() - 1;\r\n    } else if (index < 0) {\r\n        index = 0;\r\n    }\r\n    return index;\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.ssl.SSLParametersConfiguration.isNeedClientAuth",
	"Comment": "gets a flag indicating whether client authentication is required.",
	"Method": "Boolean isNeedClientAuth(){\r\n    return needClientAuth;\r\n}"
}, {
	"Path": "mage.game.combat.CombatGroup.defenderAssignsCombatDamage",
	"Comment": "decides damage distribution for blocking creatures with banding or ifdefending player controls the defensive formation enchantment.",
	"Method": "boolean defenderAssignsCombatDamage(Game game){\r\n    for (UUID blockerId : blockers) {\r\n        Permanent blocker = game.getPermanent(blockerId);\r\n        if (blocker != null) {\r\n            if (hasBanding(blocker)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    if (appliesBandsWithOther(blockers, game)) {\r\n        return true;\r\n    }\r\n    for (Permanent defensiveFormation : game.getBattlefield().getAllActivePermanents(defendingPlayerId)) {\r\n        if (defensiveFormation.getAbilities().containsKey(ControllerAssignCombatDamageToBlockersAbility.getInstance().getId())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "mage.client.deck.generator.DeckGenerator.getRandomColors",
	"Comment": "if the user has selected random colors, pick them randomly for the user.",
	"Method": "String getRandomColors(String selectedColors){\r\n    List<Character> availableColors = new ArrayList();\r\n    for (ColoredManaSymbol cms : ColoredManaSymbol.values()) {\r\n        availableColors.add(cms.toString().charAt(0));\r\n    }\r\n    StringBuilder generatedColors = new StringBuilder();\r\n    int randomColors = 0;\r\n    for (int i = 0; i < selectedColors.length(); i++) {\r\n        char currentColor = selectedColors.charAt(i);\r\n        if (currentColor != 'X') {\r\n            generatedColors.append(currentColor);\r\n            availableColors.remove(new Character(currentColor));\r\n        } else {\r\n            randomColors++;\r\n        }\r\n    }\r\n    for (int i = 0; i < randomColors && !availableColors.isEmpty(); i++) {\r\n        int index = RandomUtil.nextInt(availableColors.size());\r\n        generatedColors.append(availableColors.remove(index));\r\n    }\r\n    return generatedColors.toString();\r\n}"
}, {
	"Path": "com.networknt.resource.ResourceHelpers.getPredicatedHandlers",
	"Comment": "helper for retrieving all predicatedhandlers from the given list of predicatedhandlersproviders.",
	"Method": "List<PredicatedHandler> getPredicatedHandlers(PredicatedHandlersProvider[] predicatedHandlersProviders){\r\n    List<PredicatedHandler> predicatedHandlers = new ArrayList();\r\n    if (predicatedHandlersProviders != null && predicatedHandlersProviders.length > 0) {\r\n        for (PredicatedHandlersProvider predicatedHandlersProvider : predicatedHandlersProviders) {\r\n            predicatedHandlers.addAll(predicatedHandlersProvider.getPredicatedHandlers());\r\n        }\r\n    }\r\n    return predicatedHandlers;\r\n}"
}, {
	"Path": "mage.client.components.layout.RelativeLayout.allocateRelativeSpace",
	"Comment": "allocate the space available to each component using relative sizing",
	"Method": "int[] allocateRelativeSpace(Container parent,int spaceAvailable,float relativeTotal){\r\n    int spaceUsed = 0;\r\n    int components = parent.getComponentCount();\r\n    int[] relativeSpace = new int[components];\r\n    for (int i = 0; i < components; i++) {\r\n        relativeSpace[i] = 0;\r\n        if (relativeTotal > 0 && spaceAvailable > 0) {\r\n            Component component = parent.getComponent(i);\r\n            Float constraint = constraints.get(component);\r\n            if (constraint != null) {\r\n                int space = (int) (spaceAvailable * constraint / relativeTotal);\r\n                relativeSpace[i] = space;\r\n                spaceUsed += space;\r\n            }\r\n        }\r\n    }\r\n    int spaceRemaining = spaceAvailable - spaceUsed;\r\n    if (relativeTotal > 0 && spaceRemaining > 0) {\r\n        adjustForRounding(relativeSpace, spaceRemaining);\r\n    }\r\n    return relativeSpace;\r\n}"
}, {
	"Path": "org.lenskit.knn.item.model.ItemItemBuildContextTest.testSomeItemsData",
	"Comment": "test itemitembuildcontext when some items have rating data.",
	"Method": "void testSomeItemsData(){\r\n    SortedKeyIndex items = SortedKeyIndex.create(1, 2, 3, 4);\r\n    long[] userIds = { 101, 102, 103, 104 };\r\n    SortedKeyIndex idx = SortedKeyIndex.create(userIds);\r\n    double[] ratings1 = { 4.0, 3.0, 2.5, 2.0 };\r\n    double[] ratings4 = { 4.5, 3.0, 3.5, 1.5 };\r\n    Long2DoubleSortedArrayMap v1 = Long2DoubleSortedArrayMap.wrap(idx, ratings1);\r\n    Long2DoubleSortedArrayMap v4 = Long2DoubleSortedArrayMap.wrap(idx, ratings4);\r\n    Long2DoubleSortedMap[] ratingMap = { v1, Long2DoubleSortedMaps.EMPTY_MAP, Long2DoubleSortedMaps.EMPTY_MAP, Long2DoubleSortedMaps.EMPTY_MAP, v4 };\r\n    ItemItemBuildContext context = new ItemItemBuildContext(items, ratingMap, new Long2ObjectOpenHashMap<LongSortedSet>());\r\n    testRatingIntegrity(items, ratingMap, context);\r\n}"
}, {
	"Path": "io.dropwizard.metrics.MetricRegistry.getGauges",
	"Comment": "returns a map of all the gauges in the registry and their names which match the given filter.",
	"Method": "SortedMap<MetricName, Gauge> getGauges(SortedMap<MetricName, Gauge> getGauges,MetricFilter filter){\r\n    return getMetrics(Gauge.class, filter);\r\n}"
}, {
	"Path": "ch.qos.logback.classic.android.SQLiteAppender.setDbNameResolver",
	"Comment": "sets the database name resolver, used to customize the names of the table namesand columns in the database.",
	"Method": "void setDbNameResolver(DBNameResolver dbNameResolver){\r\n    this.dbNameResolver = dbNameResolver;\r\n}"
}, {
	"Path": "io.dropwizard.metrics.WeightedSnapshot.getStdDev",
	"Comment": "returns the weighted standard deviation of the values in the snapshot.",
	"Method": "double getStdDev(){\r\n    if (values.length <= 1) {\r\n        return 0;\r\n    }\r\n    final double mean = getMean();\r\n    double variance = 0;\r\n    for (int i = 0; i < values.length; i++) {\r\n        final double diff = values[i] - mean;\r\n        variance += normWeights[i] * diff * diff;\r\n    }\r\n    return Math.sqrt(variance);\r\n}"
}, {
	"Path": "ch.qos.logback.classic.spi.CallerData.extract",
	"Comment": "extract caller data information as an array based on a throwable passed asparameter",
	"Method": "StackTraceElement[] extract(Throwable t,String fqnOfInvokingClass,int maxDepth,List<String> frameworkPackageList){\r\n    if (t == null) {\r\n        return null;\r\n    }\r\n    StackTraceElement[] steArray = t.getStackTrace();\r\n    StackTraceElement[] callerDataArray;\r\n    int found = LINE_NA;\r\n    for (int i = 0; i < steArray.length; i++) {\r\n        if (isInFrameworkSpace(steArray[i].getClassName(), fqnOfInvokingClass, frameworkPackageList)) {\r\n            found = i + 1;\r\n        } else {\r\n            if (found != LINE_NA) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (found == LINE_NA) {\r\n        return EMPTY_CALLER_DATA_ARRAY;\r\n    }\r\n    int availableDepth = steArray.length - found;\r\n    int desiredDepth = maxDepth < (availableDepth) ? maxDepth : availableDepth;\r\n    callerDataArray = new StackTraceElement[desiredDepth];\r\n    for (int i = 0; i < desiredDepth; i++) {\r\n        callerDataArray[i] = steArray[found + i];\r\n    }\r\n    return callerDataArray;\r\n}"
}, {
	"Path": "mage.client.components.layout.RelativeLayout.getBorderGap",
	"Comment": "gets the initial gap. this gap is used before the leading componentand after the trailing component.",
	"Method": "int getBorderGap(){\r\n    return borderGap;\r\n}"
}, {
	"Path": "mage.abilities.effects.common.ManaEffect.getNetMana",
	"Comment": "returns the currently available max mana variations the effect canproduce",
	"Method": "List<Mana> getNetMana(Game game,Ability source){\r\n    List<Mana> netMana = new ArrayList();\r\n    Mana mana = produceMana(true, game, source);\r\n    if (mana != null) {\r\n        netMana.add(mana);\r\n    }\r\n    return netMana;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.spi.LoggerContextAwareBase.setLoggerContext",
	"Comment": "set the owning context. the owning context cannot be set more thanonce.",
	"Method": "void setLoggerContext(LoggerContext context){\r\n    super.setContext(context);\r\n}"
}, {
	"Path": "ch.qos.logback.core.joran.spi.Interpreter.lookupImplicitAction",
	"Comment": "check if any implicit actions are applicable. as soon as an applicableaction is found, it is returned. thus, the returned list will have at mostone element.",
	"Method": "List<Action> lookupImplicitAction(ElementPath elementPath,Attributes attributes,InterpretationContext ec){\r\n    int len = implicitActions.size();\r\n    for (int i = 0; i < len; i++) {\r\n        ImplicitAction ia = (ImplicitAction) implicitActions.get(i);\r\n        if (ia.isApplicable(elementPath, attributes, ec)) {\r\n            List<Action> actionList = new ArrayList<Action>(1);\r\n            actionList.add(ia);\r\n            return actionList;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.networknt.utility.CodeVerifierUtil.generateRandomCodeVerifier",
	"Comment": "generates a random code verifier string using the provided entropy source and the specifiednumber of bytes of entropy.",
	"Method": "String generateRandomCodeVerifier(String generateRandomCodeVerifier,SecureRandom entropySource,int entropyBytes){\r\n    byte[] randomBytes = new byte[entropyBytes];\r\n    entropySource.nextBytes(randomBytes);\r\n    return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);\r\n}"
}, {
	"Path": "io.dropwizard.metrics.EWMA.fiveMinuteEWMA",
	"Comment": "creates a new ewma which is equivalent to the unix five minute load average and which expectsto be ticked every 5 seconds.",
	"Method": "EWMA fiveMinuteEWMA(){\r\n    return new EWMA(M5_ALPHA, INTERVAL, TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "ch.qos.logback.classic.spi.TurboFilterList.getTurboFilterChainDecision",
	"Comment": "loop through the filters in the chain. as soon as a filter decides onaccept or deny, then that value is returned. if all of the filters returnneutral, then neutral is returned.",
	"Method": "FilterReply getTurboFilterChainDecision(Marker marker,Logger logger,Level level,String format,Object[] params,Throwable t){\r\n    final int size = size();\r\n    if (size == 1) {\r\n        try {\r\n            TurboFilter tf = get(0);\r\n            return tf.decide(marker, logger, level, format, params, t);\r\n        } catch (IndexOutOfBoundsException iobe) {\r\n            return FilterReply.NEUTRAL;\r\n        }\r\n    }\r\n    Object[] tfa = toArray();\r\n    final int len = tfa.length;\r\n    for (int i = 0; i < len; i++) {\r\n        final TurboFilter tf = (TurboFilter) tfa[i];\r\n        final FilterReply r = tf.decide(marker, logger, level, format, params, t);\r\n        if (r == FilterReply.DENY || r == FilterReply.ACCEPT) {\r\n            return r;\r\n        }\r\n    }\r\n    return FilterReply.NEUTRAL;\r\n}"
}, {
	"Path": "org.lenskit.knn.item.ItemItemRecommenderTest.testItemScorerNoRating",
	"Comment": "check that we score items but do not provide scores for itemsthe user has previously rated.user 5 has rated only item 8previously.",
	"Method": "void testItemScorerNoRating(){\r\n    long[] items = { 7, 8 };\r\n    ItemItemScorer scorer = session.get(ItemItemScorer.class);\r\n    assertThat(scorer, notNullValue());\r\n    Map<Long, Double> scores = scorer.score(5, LongArrayList.wrap(items));\r\n    assertThat(scores, notNullValue());\r\n    assertThat(scores.size(), equalTo(1));\r\n    assertThat(scores.get(7L), not(notANumber()));\r\n    assertThat(scores.containsKey(8L), equalTo(false));\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.ssl.SSLParametersConfiguration.enabledCipherSuites",
	"Comment": "gets the set of enabled cipher suites based on the configuration.",
	"Method": "String[] enabledCipherSuites(String[] supportedCipherSuites,String[] defaultCipherSuites){\r\n    if (enabledCipherSuites == null) {\r\n        if (OptionHelper.isEmpty(getIncludedCipherSuites()) && OptionHelper.isEmpty(getExcludedCipherSuites())) {\r\n            enabledCipherSuites = Arrays.copyOf(defaultCipherSuites, defaultCipherSuites.length);\r\n        } else {\r\n            enabledCipherSuites = includedStrings(supportedCipherSuites, getIncludedCipherSuites(), getExcludedCipherSuites());\r\n        }\r\n        for (String cipherSuite : enabledCipherSuites) {\r\n            addInfo(\"enabled cipher suite: \" + cipherSuite);\r\n        }\r\n    }\r\n    return enabledCipherSuites;\r\n}"
}, {
	"Path": "mage.players.PlayerImpl.getOtherUseableActivatedAbilities",
	"Comment": "adds special abilities that are given to non permanents by continuous effects",
	"Method": "void getOtherUseableActivatedAbilities(MageObject object,Zone zone,Game game,Map<UUID, ActivatedAbility> useable){\r\n    Abilities<ActivatedAbility> otherAbilities = game.getState().getActivatedOtherAbilities(object.getId(), zone);\r\n    if (otherAbilities != null) {\r\n        boolean canUse = !(object instanceof Permanent) || ((Permanent) object).canUseActivatedAbilities(game);\r\n        for (ActivatedAbility ability : otherAbilities) {\r\n            if (canUse || ability.getAbilityType() == AbilityType.SPECIAL_ACTION) {\r\n                Card card = game.getCard(ability.getSourceId());\r\n                if (card.isSplitCard() && ability instanceof FlashbackAbility) {\r\n                    FlashbackAbility flashbackAbility;\r\n                    if (card.isInstant()) {\r\n                        flashbackAbility = new FlashbackAbility(((SplitCard) card).getLeftHalfCard().getManaCost(), TimingRule.INSTANT);\r\n                    } else {\r\n                        flashbackAbility = new FlashbackAbility(((SplitCard) card).getLeftHalfCard().getManaCost(), TimingRule.SORCERY);\r\n                    }\r\n                    flashbackAbility.setSourceId(card.getId());\r\n                    flashbackAbility.setControllerId(card.getOwnerId());\r\n                    flashbackAbility.setSpellAbilityType(SpellAbilityType.SPLIT_LEFT);\r\n                    flashbackAbility.setAbilityName(((SplitCard) card).getLeftHalfCard().getName());\r\n                    if (flashbackAbility.canActivate(playerId, game).canActivate()) {\r\n                        useable.put(flashbackAbility.getId(), flashbackAbility);\r\n                    }\r\n                    if (card.isInstant()) {\r\n                        flashbackAbility = new FlashbackAbility(((SplitCard) card).getRightHalfCard().getManaCost(), TimingRule.INSTANT);\r\n                    } else {\r\n                        flashbackAbility = new FlashbackAbility(((SplitCard) card).getRightHalfCard().getManaCost(), TimingRule.SORCERY);\r\n                    }\r\n                    flashbackAbility.setSourceId(card.getId());\r\n                    flashbackAbility.setControllerId(card.getOwnerId());\r\n                    flashbackAbility.setSpellAbilityType(SpellAbilityType.SPLIT_RIGHT);\r\n                    flashbackAbility.setAbilityName(((SplitCard) card).getRightHalfCard().getName());\r\n                    if (flashbackAbility.canActivate(playerId, game).canActivate()) {\r\n                        useable.put(flashbackAbility.getId(), flashbackAbility);\r\n                    }\r\n                } else {\r\n                    useable.put(ability.getId(), ability);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.eval.traintest.recommend.ItemSelector.nullSelector",
	"Comment": "get an item selector that returns null.when used as the set of candidate items, this will select the defaultcandidate set.",
	"Method": "ItemSelector nullSelector(){\r\n    return new NullItemSelector();\r\n}"
}, {
	"Path": "ch.qos.logback.classic.LoggerContext.resetTurboFilterList",
	"Comment": "first processpriortoremoval all registered turbo filters and then clear the registrationlist.",
	"Method": "void resetTurboFilterList(){\r\n    for (TurboFilter tf : turboFilterList) {\r\n        tf.stop();\r\n    }\r\n    turboFilterList.clear();\r\n}"
}, {
	"Path": "com.networknt.client.Http2Client.populateHeader",
	"Comment": "support api to api calls with scope token. the token is the original token from consumer andthe client credentials token of caller api is added from cache. authtoken, correlationid andtraceabilityid are passed in as strings.this method is used in api to api call",
	"Method": "void populateHeader(ClientRequest request,String authToken,String correlationId,String traceabilityId){\r\n    if (traceabilityId != null) {\r\n        addAuthTokenTrace(request, authToken, traceabilityId);\r\n    } else {\r\n        addAuthToken(request, authToken);\r\n    }\r\n    request.getRequestHeaders().put(HttpStringConstants.CORRELATION_ID, correlationId);\r\n    checkCCTokenExpired();\r\n    request.getRequestHeaders().put(HttpStringConstants.SCOPE_TOKEN, \"Bearer \" + jwt);\r\n}"
}, {
	"Path": "ch.qos.logback.core.joran.spi.InterpretationContext.getProperty",
	"Comment": "if a key is found in propertiesmap then return it. otherwise, delegate tothe context.",
	"Method": "String getProperty(String key){\r\n    String v = propertiesMap.get(key);\r\n    if (v != null) {\r\n        return v;\r\n    } else {\r\n        return context.getProperty(key);\r\n    }\r\n}"
}, {
	"Path": "mage.view.CardView.getTargets",
	"Comment": "returns uuids for targets. can be null if there is no target selected.",
	"Method": "List<UUID> getTargets(){\r\n    return targets;\r\n}"
}, {
	"Path": "ch.qos.logback.core.joran.action.ActionUtil.stringToScope",
	"Comment": "convert a string into a scope. scope.local is returned by default.",
	"Method": "Scope stringToScope(String scopeStr){\r\n    if (Scope.SYSTEM.toString().equalsIgnoreCase(scopeStr))\r\n        return Scope.SYSTEM;\r\n    if (Scope.CONTEXT.toString().equalsIgnoreCase(scopeStr))\r\n        return Scope.CONTEXT;\r\n    return Scope.LOCAL;\r\n}"
}, {
	"Path": "mage.client.dialog.NewTableDialog.saveGameSettingsToPrefs",
	"Comment": "save the settings to java prefs to reload it next time the dialog will becreated",
	"Method": "void saveGameSettingsToPrefs(MatchOptions options,String deckFile){\r\n    String versionStr = \"\";\r\n    if (currentSettingVersion == 1) {\r\n        versionStr = \"1\";\r\n    } else if (currentSettingVersion == 2) {\r\n        versionStr = \"2\";\r\n    }\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_NAME + versionStr, options.getName());\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_PASSWORD + versionStr, options.getPassword());\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_DECK_TYPE + versionStr, options.getDeckType());\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_TIME_LIMIT + versionStr, Integer.toString(options.getPriorityTime()));\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_GAME_TYPE + versionStr, options.getGameType());\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_NUMBER_OF_WINS + versionStr, Integer.toString(options.getWinsNeeded()));\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_ROLLBACK_TURNS_ALLOWED + versionStr, options.isRollbackTurnsAllowed() ? \"Yes\" : \"No\");\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_RATED + versionStr, options.isRated() ? \"Yes\" : \"No\");\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_NUMBER_OF_FREE_MULLIGANS + versionStr, Integer.toString(options.getFreeMulligans()));\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_DECK_FILE + versionStr, deckFile);\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_NUMBER_PLAYERS + versionStr, spnNumPlayers.getValue().toString());\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_RANGE + versionStr, Integer.toString(options.getRange().getRange()));\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_ATTACK_OPTION + versionStr, options.getAttackOption().toString());\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_SKILL_LEVEL + versionStr, options.getSkillLevel().toString());\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_SPECTATORS_ALLOWED + versionStr, options.isSpectatorsAllowed() ? \"Yes\" : \"No\");\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_PLANECHASE + versionStr, options.isPlaneChase() ? \"Yes\" : \"No\");\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_QUIT_RATIO + versionStr, Integer.toString(options.getQuitRatio()));\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_MINIMUM_RATING + versionStr, Integer.toString(options.getMinimumRating()));\r\n    StringBuilder playerTypesString = new StringBuilder();\r\n    for (Object player : players) {\r\n        if (playerTypesString.length() > 0) {\r\n            playerTypesString.append(',');\r\n        }\r\n        TablePlayerPanel tpp = (TablePlayerPanel) player;\r\n        playerTypesString.append(tpp.getPlayerType());\r\n    }\r\n    PreferencesDialog.saveValue(PreferencesDialog.KEY_NEW_TABLE_PLAYER_TYPES + versionStr, playerTypesString.toString());\r\n}"
}, {
	"Path": "ch.qos.logback.core.FileAppender.rawFileProperty",
	"Comment": "this method is used by derived classes to obtain the raw file property.regular users should not be calling this method. note that rollingfilepolicybaserequires public getter for this property.",
	"Method": "String rawFileProperty(){\r\n    return fileName;\r\n}"
}, {
	"Path": "org.whispersystems.libsignal.util.KeyHelper.generateRegistrationId",
	"Comment": "generate a registration id.clients should only do this once,at install time.",
	"Method": "int generateRegistrationId(boolean extendedRange){\r\n    try {\r\n        SecureRandom secureRandom = SecureRandom.getInstance(\"SHA1PRNG\");\r\n        if (extendedRange)\r\n            return secureRandom.nextInt(Integer.MAX_VALUE - 1) + 1;\r\n        else\r\n            return secureRandom.nextInt(16380) + 1;\r\n    } catch (NoSuchAlgorithmException e) {\r\n        throw new AssertionError(e);\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.util.TypeUtils.listElementType",
	"Comment": "extract the element type from a type token representing a list.",
	"Method": "TypeToken<T> listElementType(TypeToken<? extends List<T>> token){\r\n    Type t = token.getType();\r\n    Preconditions.checkArgument(t instanceof ParameterizedType, \"list type not resolved\");\r\n    ParameterizedType pt = (ParameterizedType) t;\r\n    Type[] args = pt.getActualTypeArguments();\r\n    assert args.length == 1;\r\n    return (TypeToken<T>) TypeToken.of(args[0]);\r\n}"
}, {
	"Path": "com.networknt.security.JwtHelper.verifyJwt",
	"Comment": "verify jwt token format and signature. if ignoreexpiry is true, skip expiry verification, otherwiseverify the expiry before signature verification.in most cases, we need to verify the expiry of the jwt token. the only time we need to ignore expiryverification is in spa middleware handlers which need to verify csrf token in jwt against the csrftoken in the request header to renew the expired token.",
	"Method": "JwtClaims verifyJwt(String jwt,boolean ignoreExpiry){\r\n    JwtClaims claims;\r\n    if (Boolean.TRUE.equals(enableJwtCache)) {\r\n        claims = cache.getIfPresent(jwt);\r\n        if (claims != null) {\r\n            if (!ignoreExpiry) {\r\n                try {\r\n                    if ((NumericDate.now().getValue() - secondsOfAllowedClockSkew) >= claims.getExpirationTime().getValue()) {\r\n                        logger.info(\"Cached jwt token is expired!\");\r\n                        throw new ExpiredTokenException(\"Token is expired\");\r\n                    }\r\n                } catch (MalformedClaimException e) {\r\n                    logger.error(\"MalformedClaimException:\", e);\r\n                }\r\n            }\r\n            return claims;\r\n        }\r\n    }\r\n    JwtConsumer consumer = new JwtConsumerBuilder().setSkipAllValidators().setDisableRequireSignature().setSkipSignatureVerification().build();\r\n    JwtContext jwtContext = consumer.process(jwt);\r\n    claims = jwtContext.getJwtClaims();\r\n    JsonWebStructure structure = jwtContext.getJoseObjects().get(0);\r\n    String kid = structure.getKeyIdHeaderValue();\r\n    if (!ignoreExpiry) {\r\n        try {\r\n            if ((NumericDate.now().getValue() - secondsOfAllowedClockSkew) >= claims.getExpirationTime().getValue()) {\r\n                logger.info(\"jwt token is expired!\");\r\n                throw new ExpiredTokenException(\"Token is expired\");\r\n            }\r\n        } catch (MalformedClaimException e) {\r\n            logger.error(\"MalformedClaimException:\", e);\r\n            throw new InvalidJwtException(\"MalformedClaimException\", new ErrorCodeValidator.Error(ErrorCodes.MALFORMED_CLAIM, \"Invalid ExpirationTime Format\"), e, jwtContext);\r\n        }\r\n    }\r\n    X509Certificate certificate = certMap == null ? null : certMap.get(kid);\r\n    if (certificate == null) {\r\n        certificate = getCertFromOauth(kid);\r\n        if (certMap == null)\r\n            certMap = new HashMap();\r\n        certMap.put(kid, certificate);\r\n    }\r\n    X509VerificationKeyResolver x509VerificationKeyResolver = new X509VerificationKeyResolver(certificate);\r\n    x509VerificationKeyResolver.setTryAllOnNoThumbHeader(true);\r\n    consumer = // use seconds of 10 years to skip expiration validation as we need skip it in some cases.\r\n    new JwtConsumerBuilder().setRequireExpirationTime().setAllowedClockSkewInSeconds(315360000).setSkipDefaultAudienceValidation().setVerificationKeyResolver(x509VerificationKeyResolver).build();\r\n    jwtContext = consumer.process(jwt);\r\n    claims = jwtContext.getJwtClaims();\r\n    if (Boolean.TRUE.equals(enableJwtCache)) {\r\n        cache.put(jwt, claims);\r\n    }\r\n    return claims;\r\n}"
}, {
	"Path": "org.lenskit.eval.traintest.AlgorithmInstanceBuilder.getConfigurations",
	"Comment": "get the list of configurations that comprise this instance.",
	"Method": "List<LenskitConfiguration> getConfigurations(){\r\n    List<LenskitConfiguration> list;\r\n    if (parent != null) {\r\n        list = parent.getConfigurations();\r\n    } else {\r\n        list = new LinkedList();\r\n    }\r\n    list.add(config);\r\n    return list;\r\n}"
}, {
	"Path": "mage.view.CardView.getOriginalName",
	"Comment": "stores the name of the original name, to provide it for a flipped ortransformed or copying card",
	"Method": "String getOriginalName(){\r\n    return originalName;\r\n}"
}, {
	"Path": "mage.game.combat.CombatGroup.attackerAssignsCombatDamage",
	"Comment": "decides damage distribution for attacking banding creatures.",
	"Method": "boolean attackerAssignsCombatDamage(Game game){\r\n    for (UUID attackerId : attackers) {\r\n        Permanent attacker = game.getPermanent(attackerId);\r\n        if (attacker != null) {\r\n            if (hasBanding(attacker)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    if (appliesBandsWithOther(attackers, game)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.ssl.SSLContextFactoryBean.keyStoreFromSystemProperties",
	"Comment": "constructs a key store factory bean using jsse system properties.",
	"Method": "KeyStoreFactoryBean keyStoreFromSystemProperties(String property){\r\n    if (System.getProperty(property) == null)\r\n        return null;\r\n    KeyStoreFactoryBean keyStore = new KeyStoreFactoryBean();\r\n    keyStore.setLocation(locationFromSystemProperty(property));\r\n    keyStore.setProvider(System.getProperty(property + \"Provider\"));\r\n    keyStore.setPassword(System.getProperty(property + \"Password\"));\r\n    keyStore.setType(System.getProperty(property + \"Type\"));\r\n    return keyStore;\r\n}"
}, {
	"Path": "ch.qos.logback.core.util.LocationUtil.urlForResource",
	"Comment": "converts a string describing the location of a resource into a url object.",
	"Method": "URL urlForResource(String location){\r\n    if (location == null) {\r\n        throw new NullPointerException(\"location is required\");\r\n    }\r\n    URL url = null;\r\n    if (!location.matches(SCHEME_PATTERN)) {\r\n        url = Loader.getResourceBySelfClassLoader(location);\r\n    } else if (location.startsWith(CLASSPATH_SCHEME)) {\r\n        String path = location.substring(CLASSPATH_SCHEME.length());\r\n        if (path.startsWith(\"/\")) {\r\n            path = path.substring(1);\r\n        }\r\n        if (path.length() == 0) {\r\n            throw new MalformedURLException(\"path is required\");\r\n        }\r\n        url = Loader.getResourceBySelfClassLoader(path);\r\n    } else {\r\n        url = new URL(location);\r\n    }\r\n    if (url == null) {\r\n        throw new FileNotFoundException(location);\r\n    }\r\n    return url;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.util.ContextSelectorStaticBinder.init",
	"Comment": "for internal use. this method is intended for use bystaticloggerbinder.",
	"Method": "void init(LoggerContext defaultLoggerContext,Object key){\r\n    if (this.key == null) {\r\n        this.key = key;\r\n    } else if (this.key != key) {\r\n        throw new IllegalAccessException(\"Only certain classes can access this method.\");\r\n    }\r\n    String contextSelectorStr = OptionHelper.getSystemProperty(ClassicConstants.LOGBACK_CONTEXT_SELECTOR);\r\n    if (contextSelectorStr == null) {\r\n        contextSelector = new DefaultContextSelector(defaultLoggerContext);\r\n    } else if (contextSelectorStr.equals(\"JNDI\")) {\r\n        throw new RuntimeException(\"JNDI not supported\");\r\n    } else {\r\n        contextSelector = dynamicalContextSelector(defaultLoggerContext, contextSelectorStr);\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.AsyncAppenderBase.getNumberOfElementsInQueue",
	"Comment": "returns the number of elements currently in the blocking queue.",
	"Method": "int getNumberOfElementsInQueue(){\r\n    return blockingQueue.size();\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.server.AbstractServerSocketAppender.setBacklog",
	"Comment": "sets the listener queue depth.this represents the number of connected clients whose connectionshave not yet been accepted.",
	"Method": "void setBacklog(int backlog){\r\n    this.backlog = backlog;\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.AbstractSocketAppender.setRemoteHost",
	"Comment": "the remotehost property takes the name of of the host where a corresponding server is running.",
	"Method": "void setRemoteHost(String host){\r\n    remoteHost = host;\r\n}"
}, {
	"Path": "mage.Mana.setWhite",
	"Comment": "sets the total white mana. can not be negative. negative values will belogged and set to 0.",
	"Method": "void setWhite(int white){\r\n    this.white = notNegative(white, \"White\");\r\n}"
}, {
	"Path": "mage.client.components.layout.RelativeLayout.adjustEqual",
	"Comment": "each component using relative sizing gets 1 more pixel until all the space is used, starting with the first.",
	"Method": "void adjustEqual(int[] relativeSpace,int spaceRemaining){\r\n    int pixelsLeft = spaceRemaining;\r\n    for (int i = 0; i < relativeSpace.length; i++) {\r\n        if (relativeSpace[i] > 0) {\r\n            relativeSpace[i]++;\r\n            pixelsLeft--;\r\n            if (pixelsLeft == 0) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mage.client.plugins.adapters.MageActionCallback.enlargeCard",
	"Comment": "show the big card image on mouse position while hovering over a card",
	"Method": "void enlargeCard(EnlargeMode showAlternative){\r\n    if (enlargedWindowState == EnlargedWindowState.CLOSED) {\r\n        this.enlargeMode = showAlternative;\r\n        CardView cardView = null;\r\n        if (popupData != null) {\r\n            cardView = popupData.card;\r\n        }\r\n        if (this.popupTextWindowOpen) {\r\n            hideTooltipPopup();\r\n        }\r\n        if (cardView != null) {\r\n            if (cardView.isToRotate()) {\r\n                enlargedWindowState = EnlargedWindowState.ROTATED;\r\n            } else {\r\n                enlargedWindowState = EnlargedWindowState.NORMAL;\r\n            }\r\n            displayEnlargedCard(cardView, popupData);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.eval.crossfold.CrossfoldMethods.sampleUsers",
	"Comment": "create a crossfold method that splits users into disjoint samples.",
	"Method": "CrossfoldMethod sampleUsers(SortOrder order,HistoryPartitionMethod part,int size){\r\n    return new GroupedCrossfoldMethod(CommonTypes.USER, CommonAttributes.USER_ID, GroupEntitySplitter.disjointSample(size), order, part);\r\n}"
}, {
	"Path": "mage.abilities.effects.ContinuousEffectImpl.discard",
	"Comment": "sets the discarded state of the effect. so it will be removed on nextcheck.",
	"Method": "void discard(){\r\n    this.used = true;\r\n    this.discarded = true;\r\n}"
}, {
	"Path": "mage.player.ai.ComputerPlayerMCTS.createMCTSGame",
	"Comment": "copies game and replaces all players in copy with mcts playersshuffles each players library so that there is no knowledge of its orderswaps all other players hands with random cards from the library so thatthere is no knowledge of what cards are in opponents handsthe most knowledge that is known is what cards are in an opponents deck",
	"Method": "Game createMCTSGame(Game game){\r\n    Game mcts = game.copy();\r\n    for (Player copyPlayer : mcts.getState().getPlayers().values()) {\r\n        Player origPlayer = game.getState().getPlayers().get(copyPlayer.getId());\r\n        MCTSPlayer newPlayer = new MCTSPlayer(copyPlayer.getId());\r\n        newPlayer.restore(origPlayer);\r\n        if (!newPlayer.getId().equals(playerId)) {\r\n            int handSize = newPlayer.getHand().size();\r\n            newPlayer.getLibrary().addAll(newPlayer.getHand().getCards(mcts), mcts);\r\n            newPlayer.getHand().clear();\r\n            newPlayer.getLibrary().shuffle();\r\n            for (int i = 0; i < handSize; i++) {\r\n                Card card = newPlayer.getLibrary().removeFromTop(mcts);\r\n                card.setZone(Zone.HAND, mcts);\r\n                newPlayer.getHand().add(card);\r\n            }\r\n        } else {\r\n            newPlayer.getLibrary().shuffle();\r\n        }\r\n        mcts.getState().getPlayers().put(copyPlayer.getId(), newPlayer);\r\n    }\r\n    mcts.setSimulation(true);\r\n    mcts.resume();\r\n    return mcts;\r\n}"
}, {
	"Path": "mage.client.components.layout.RelativeLayout.isFill",
	"Comment": "gets the fill property for the component size on the opposite edge.",
	"Method": "boolean isFill(){\r\n    return fill;\r\n}"
}, {
	"Path": "ch.qos.logback.core.rolling.RollingFileAppender.rollover",
	"Comment": "implemented by delegating most of the rollover work to a rolling policy.",
	"Method": "void rollover(){\r\n    lock.lock();\r\n    try {\r\n        this.closeOutputStream();\r\n        attemptRollover();\r\n        attemptOpenFile();\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n}"
}, {
	"Path": "mage.Mana.setBlack",
	"Comment": "sets the total black mana. can not be negative. negative values will belogged and set to 0.",
	"Method": "void setBlack(int black){\r\n    this.black = notNegative(black, \"Black\");\r\n}"
}, {
	"Path": "com.networknt.monad.Result.fold",
	"Comment": "use this method if you want to reduce your result to some type r. for example at theend of the flow, you could convert it to two different client responses depending onthe insides.",
	"Method": "R fold(Function<? super T, ? extends R> successFunction,Function<Failure<R>, ? extends R> failureFunction){\r\n    return isSuccess() ? successFunction.apply(getResult()) : failureFunction.apply((Failure<R>) this);\r\n}"
}, {
	"Path": "org.lenskit.eval.temporal.TemporalEvaluator.setAlgorithm",
	"Comment": "an algorithm instance constructed with a name and lenskit configuration",
	"Method": "TemporalEvaluator setAlgorithm(AlgorithmInstance algo,TemporalEvaluator setAlgorithm,String name,LenskitConfiguration config){\r\n    algorithm = new AlgorithmInstance(name, config);\r\n    return this;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.net.server.ServerSocketReceiver.getBacklog",
	"Comment": "gets the listener queue depth.this represents the number of connected clients whose connectionshave not yet been accepted.",
	"Method": "int getBacklog(){\r\n    return backlog;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.spi.LoggingEvent.getCallerData",
	"Comment": "get the caller information for this logging event. if caller information isnull at the time of its invocation, this method extracts locationinformation. the collected information is cached for future use.note that after serialization it is impossible to correctly extract callerinformation.",
	"Method": "StackTraceElement[] getCallerData(){\r\n    if (callerDataArray == null) {\r\n        callerDataArray = CallerData.extract(new Throwable(), fqnOfLoggerClass, loggerContext.getMaxCallerDataDepth(), loggerContext.getFrameworkPackages());\r\n    }\r\n    return callerDataArray;\r\n}"
}, {
	"Path": "org.lenskit.eval.traintest.TrainTestExperiment.getPredictionTask",
	"Comment": "convenience method to get the prediction task for the experiment.if there is not yet a prediction task, thenone is added.",
	"Method": "PredictEvalTask getPredictionTask(){\r\n    List<PredictEvalTask> taskList = FluentIterable.from(tasks).filter(PredictEvalTask.class).toList();\r\n    if (taskList.isEmpty()) {\r\n        PredictEvalTask task = new PredictEvalTask();\r\n        addTask(task);\r\n        return task;\r\n    } else {\r\n        if (taskList.size() > 1) {\r\n            logger.warn(\"multiple prediction tasks configured\");\r\n        }\r\n        return taskList.get(0);\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.util.ExecutorServiceUtil.newExecutorService",
	"Comment": "creates an executor service suitable for use by logback components.",
	"Method": "ExecutorService newExecutorService(){\r\n    return new ThreadPoolExecutor(CoreConstants.CORE_POOL_SIZE, CoreConstants.MAX_POOL_SIZE, 0L, TimeUnit.MILLISECONDS, new SynchronousQueue<Runnable>(), THREAD_FACTORY);\r\n}"
}, {
	"Path": "mage.client.cards.DragCardGrid.sortIntoGrid",
	"Comment": "add a card to the cardgrid, in the position that the current sortdictates",
	"Method": "void sortIntoGrid(CardView newCard){\r\n    if (cardGrid.isEmpty()) {\r\n        cardGrid.add(0, new ArrayList());\r\n        maxStackSize.add(0, 0);\r\n    }\r\n    ArrayList<ArrayList<CardView>> targetRow;\r\n    if (separateCreatures && !newCard.isCreature()) {\r\n        if (cardGrid.size() < 2) {\r\n            cardGrid.add(1, new ArrayList());\r\n            maxStackSize.add(1, 0);\r\n            for (int i = 0; i < cardGrid.get(0).size(); ++i) {\r\n                cardGrid.get(1).add(new ArrayList());\r\n            }\r\n        }\r\n        targetRow = cardGrid.get(1);\r\n    } else {\r\n        targetRow = cardGrid.get(0);\r\n    }\r\n    boolean didInsert = false;\r\n    for (int currentColumn = 0; currentColumn < cardGrid.get(0).size(); ++currentColumn) {\r\n        CardView cardInColumn = null;\r\n        for (ArrayList<ArrayList<CardView>> gridRow : cardGrid) {\r\n            for (CardView card : gridRow.get(currentColumn)) {\r\n                cardInColumn = card;\r\n                break;\r\n            }\r\n        }\r\n        if (cardInColumn == null) {\r\n            LOGGER.error(\"Empty column! \" + currentColumn);\r\n        } else {\r\n            int res = cardSort.getComparator().compare(newCard, cardInColumn);\r\n            if (res <= 0) {\r\n                if (res < 0) {\r\n                    for (int rowIndex = 0; rowIndex < cardGrid.size(); ++rowIndex) {\r\n                        cardGrid.get(rowIndex).add(currentColumn, new ArrayList());\r\n                    }\r\n                }\r\n                targetRow.get(currentColumn).add(newCard);\r\n                didInsert = true;\r\n                break;\r\n            } else {\r\n            }\r\n        }\r\n    }\r\n    if (!didInsert) {\r\n        for (int rowIndex = 0; rowIndex < cardGrid.size(); ++rowIndex) {\r\n            cardGrid.get(rowIndex).add(new ArrayList());\r\n        }\r\n        targetRow.get(targetRow.size() - 1).add(newCard);\r\n    }\r\n}"
}, {
	"Path": "org.mage.card.arcane.CardRenderer.drawOverlays",
	"Comment": "draw summoning sickness overlay, and possibly other overlays",
	"Method": "void drawOverlays(Graphics2D g){\r\n    if (cardView.isCreature() && cardView instanceof PermanentView) {\r\n        if (((PermanentView) cardView).hasSummoningSickness()) {\r\n            int x1 = (int) (0.2 * cardWidth);\r\n            int x2 = (int) (0.8 * cardWidth);\r\n            int y1 = (int) (0.2 * cardHeight);\r\n            int y2 = (int) (0.8 * cardHeight);\r\n            int[] xPoints = { x1, x2, x1, x2 };\r\n            int[] yPoints = { y1, y1, y2, y2 };\r\n            g.setColor(new Color(255, 255, 255, 200));\r\n            g.setStroke(new BasicStroke(7));\r\n            g.drawPolygon(xPoints, yPoints, 4);\r\n            g.setColor(new Color(0, 0, 0, 200));\r\n            g.setStroke(new BasicStroke(5));\r\n            g.drawPolygon(xPoints, yPoints, 4);\r\n            g.setStroke(new BasicStroke(1));\r\n            int[] xPoints2 = { x1, x2, cardWidth / 2 };\r\n            int[] yPoints2 = { y1, y1, cardHeight / 2 };\r\n            g.setColor(new Color(0, 0, 0, 100));\r\n            g.fillPolygon(xPoints2, yPoints2, 3);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mage.client.components.layout.RelativeLayout.preferredLayoutSize",
	"Comment": "determines the preferred size of the container argument using this column layout.the preferred width of acolumn layout is the largest preferred width of each column in the container, plus the horizontal padding timesthe number of columns minus one, plus the left and right insets of the target container.the preferred heightof a column layout is the largest preferred height of each row in the container, plus the vertical padding timesthe number of rows minus one, plus the top and bottom insets of the target container.",
	"Method": "Dimension preferredLayoutSize(Container parent){\r\n    synchronized (parent.getTreeLock()) {\r\n        return getLayoutSize(parent, PREFERRED);\r\n    }\r\n}"
}, {
	"Path": "io.dropwizard.metrics.Snapshot.get75thPercentile",
	"Comment": "returns the value at the 75th percentile in the distribution.",
	"Method": "double get75thPercentile(){\r\n    return getValue(0.75);\r\n}"
}, {
	"Path": "org.whispersystems.libsignal.util.KeyHelper.generatePreKeys",
	"Comment": "generate a list of prekeys.clients should do this at install time, andsubsequently any time the list of prekeys stored on the server runs low.prekey ids are shorts, so they will eventually be repeated.clients shouldstore prekeys in a circular buffer, so that they are repeated as infrequentlyas possible.",
	"Method": "List<PreKeyRecord> generatePreKeys(int start,int count){\r\n    List<PreKeyRecord> results = new LinkedList();\r\n    start--;\r\n    for (int i = 0; i < count; i++) {\r\n        results.add(new PreKeyRecord(((start + i) % (Medium.MAX_VALUE - 1)) + 1, Curve.generateKeyPair()));\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "com.networknt.handler.Handler.startDefaultHandlers",
	"Comment": "if there is no matching path, the orchestrationhandler is going to try to start the defaulthandlers.\tif there are default handlers defined, store the chain id within the exchange.\totherwise return false.",
	"Method": "boolean startDefaultHandlers(HttpServerExchange httpServerExchange){\r\n    if (defaultHandlers != null && defaultHandlers.size() > 0) {\r\n        httpServerExchange.putAttachment(CHAIN_ID, \"defaultHandlers\");\r\n        httpServerExchange.putAttachment(CHAIN_SEQ, 0);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.networknt.resource.ResourceHelpers.isResourcePath",
	"Comment": "helper to check if a given requestpath could resolve to a pathresourceprovider.",
	"Method": "boolean isResourcePath(String requestPath,PathResourceProvider[] pathResourceProviders){\r\n    boolean isResourcePath = false;\r\n    if (pathResourceProviders != null && pathResourceProviders.length > 0) {\r\n        for (PathResourceProvider pathResourceProvider : pathResourceProviders) {\r\n            if ((pathResourceProvider.isPrefixPath() && requestPath.startsWith(pathResourceProvider.getPath())) || !pathResourceProvider.isPrefixPath() && requestPath.equals(pathResourceProvider.getPath())) {\r\n                isResourcePath = true;\r\n            }\r\n        }\r\n    }\r\n    return isResourcePath;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.android.LogcatAppender.start",
	"Comment": "checks that required parameters are set, and if everything is in order,activates this appender.",
	"Method": "void start(){\r\n    if ((this.encoder == null) || (this.encoder.getLayout() == null)) {\r\n        addError(\"No layout set for the appender named [\" + name + \"].\");\r\n        return;\r\n    }\r\n    if (this.tagEncoder != null) {\r\n        final Layout<?> layout = this.tagEncoder.getLayout();\r\n        if (layout == null) {\r\n            addError(\"No tag layout set for the appender named [\" + name + \"].\");\r\n            return;\r\n        }\r\n        if (layout instanceof PatternLayout) {\r\n            String pattern = this.tagEncoder.getPattern();\r\n            if (!pattern.contains(\"%nopex\")) {\r\n                this.tagEncoder.stop();\r\n                this.tagEncoder.setPattern(pattern + \"%nopex\");\r\n                this.tagEncoder.start();\r\n            }\r\n            PatternLayout tagLayout = (PatternLayout) layout;\r\n            tagLayout.setPostCompileProcessor(null);\r\n        }\r\n    }\r\n    super.start();\r\n}"
}, {
	"Path": "ch.qos.logback.classic.util.LevelToSyslogSeverity.convert",
	"Comment": "convert a level to equivalent syslog severity. only levels for printingmethods i.e trace, debug, warn, info and error are converted.",
	"Method": "int convert(ILoggingEvent event){\r\n    Level level = event.getLevel();\r\n    switch(level.levelInt) {\r\n        case Level.ERROR_INT:\r\n            return SyslogConstants.ERROR_SEVERITY;\r\n        case Level.WARN_INT:\r\n            return SyslogConstants.WARNING_SEVERITY;\r\n        case Level.INFO_INT:\r\n            return SyslogConstants.INFO_SEVERITY;\r\n        case Level.DEBUG_INT:\r\n        case Level.TRACE_INT:\r\n            return SyslogConstants.DEBUG_SEVERITY;\r\n        default:\r\n            throw new IllegalArgumentException(\"Level \" + level + \" is not a valid level for a printing method\");\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.rolling.helper.RenameUtil.rename",
	"Comment": "a relatively robust file renaming method which in case of failure due tosrc and target being on different volumes, falls back ontorenaming by copying.",
	"Method": "void rename(String src,String target){\r\n    if (src.equals(target)) {\r\n        addWarn(\"Source and target files are the same [\" + src + \"]. Skipping.\");\r\n        return;\r\n    }\r\n    File srcFile = new File(src);\r\n    if (srcFile.exists()) {\r\n        File targetFile = new File(target);\r\n        createMissingTargetDirsIfNecessary(targetFile);\r\n        addInfo(\"Renaming file [\" + srcFile + \"] to [\" + targetFile + \"]\");\r\n        boolean result = srcFile.renameTo(targetFile);\r\n        if (!result) {\r\n            addWarn(\"Failed to rename file [\" + srcFile + \"] as [\" + targetFile + \"].\");\r\n            Boolean areOnDifferentVolumes = areOnDifferentVolumes(srcFile, targetFile);\r\n            if (Boolean.TRUE.equals(areOnDifferentVolumes)) {\r\n                addWarn(\"Detected different file systems for source [\" + src + \"] and target [\" + target + \"]. Attempting rename by copying.\");\r\n                renameByCopying(src, target);\r\n                return;\r\n            } else {\r\n                addWarn(\"Please consider leaving the [file] option of \" + RollingFileAppender.class.getSimpleName() + \" empty.\");\r\n                addWarn(\"See also \" + RENAMING_ERROR_URL);\r\n            }\r\n        }\r\n    } else {\r\n        throw new RolloverFailure(\"File [\" + src + \"] does not exist.\");\r\n    }\r\n}"
}, {
	"Path": "mage.ObjectColor.intersection",
	"Comment": "returns a new color which contains the intersection of the colors of thisobjectcolor and the other objectcolor.",
	"Method": "ObjectColor intersection(ObjectColor other){\r\n    ObjectColor newColor = new ObjectColor();\r\n    newColor.white = white && other.white;\r\n    newColor.blue = blue && other.blue;\r\n    newColor.black = black && other.black;\r\n    newColor.red = red && other.red;\r\n    newColor.green = green && other.green;\r\n    newColor.gold = gold && other.gold;\r\n    return newColor;\r\n}"
}, {
	"Path": "com.networknt.consul.ConsulService.toString",
	"Comment": "construct a register json payload. note that deregister internal minimum is 1m.",
	"Method": "String toString(){\r\n    String s = tags.stream().map(Object::toString).collect(Collectors.joining(\"\\\",\\\"\"));\r\n    return \"{\\\"ID\\\":\\\"\" + id + \"\\\",\\\"Name\\\":\\\"\" + name + \"\\\",\\\"Tags\\\":[\\\"\" + s + \"\\\"],\\\"Address\\\":\\\"\" + address + \"\\\",\\\"Port\\\":\" + port + String.format(checkString, id, address, port, name);\r\n}"
}, {
	"Path": "ch.qos.logback.classic.android.SQLiteAppender.computeReferenceMask",
	"Comment": "computes the reference mask for a logging event, includingflags to indicate whether mdc properties or exception infois available for the event.",
	"Method": "short computeReferenceMask(ILoggingEvent event){\r\n    short mask = 0;\r\n    int mdcPropSize = 0;\r\n    if (event.getMDCPropertyMap() != null) {\r\n        mdcPropSize = event.getMDCPropertyMap().keySet().size();\r\n    }\r\n    int contextPropSize = 0;\r\n    if (event.getLoggerContextVO().getPropertyMap() != null) {\r\n        contextPropSize = event.getLoggerContextVO().getPropertyMap().size();\r\n    }\r\n    if (mdcPropSize > 0 || contextPropSize > 0) {\r\n        mask = PROPERTIES_EXIST;\r\n    }\r\n    if (event.getThrowableProxy() != null) {\r\n        mask |= EXCEPTION_EXISTS;\r\n    }\r\n    return mask;\r\n}"
}, {
	"Path": "com.networknt.cluster.LightCluster.serviceToUrl",
	"Comment": "implement servicetourl with client side service discovery.",
	"Method": "String serviceToUrl(String protocol,String serviceName,String tag,String requestKey){\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"protocol = \" + protocol + \" serviceName = \" + serviceName);\r\n    List<URL> urls = serviceMap.get(serviceName);\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"cached serviceName \" + serviceName + \" urls = \" + urls);\r\n    if (urls == null) {\r\n        URL subscribeUrl = URLImpl.valueOf(\"light://localhost/\" + serviceName);\r\n        if (tag != null) {\r\n            subscribeUrl.addParameter(Constants.TAG_ENVIRONMENT, tag);\r\n        }\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"subscribeUrl = \" + subscribeUrl);\r\n        if (!subscribedSet.contains(subscribeUrl)) {\r\n            registry.subscribe(subscribeUrl, new ClusterNotifyListener());\r\n            subscribedSet.add(subscribeUrl);\r\n        }\r\n        urls = registry.discover(subscribeUrl);\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"discovered urls = \" + urls);\r\n    }\r\n    URL url = loadBalance.select(urls, requestKey);\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"final url after load balance = \" + url);\r\n    return protocol + \"://\" + url.getHost() + \":\" + url.getPort();\r\n}"
}, {
	"Path": "ch.qos.logback.classic.pattern.EnsureExceptionHandling.chainHandlesThrowable",
	"Comment": "this method computes whether a chain of converters handles exceptions ornot.",
	"Method": "boolean chainHandlesThrowable(Converter<ILoggingEvent> head){\r\n    Converter<ILoggingEvent> c = head;\r\n    while (c != null) {\r\n        if (c instanceof ThrowableHandlingConverter) {\r\n            return true;\r\n        }\r\n        c = c.getNext();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "ch.qos.logback.core.joran.spi.InterpretationContext.addSubstitutionProperty",
	"Comment": "add a property to the properties of this execution context. if the propertyexists already, it is overwritten.",
	"Method": "void addSubstitutionProperty(String key,String value){\r\n    if (key == null || value == null) {\r\n        return;\r\n    }\r\n    value = value.trim();\r\n    propertiesMap.put(key, value);\r\n}"
}, {
	"Path": "mage.abilities.Modes.getModeId",
	"Comment": "returns the mode by index. for modal spells with eachmodemorethanonce,the index returns the n selected mode",
	"Method": "UUID getModeId(int index){\r\n    int idx = 0;\r\n    if (eachModeMoreThanOnce) {\r\n        for (UUID modeId : this.selectedModes) {\r\n            idx++;\r\n            if (idx == index) {\r\n                return modeId;\r\n            }\r\n        }\r\n    } else {\r\n        for (Mode mode : this.values()) {\r\n            idx++;\r\n            if (idx == index) {\r\n                return mode.getId();\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.ssl.SSLParametersConfiguration.setWantClientAuth",
	"Comment": "sets a flag indicating whether client authentication is desired.",
	"Method": "void setWantClientAuth(Boolean wantClientAuth){\r\n    this.wantClientAuth = wantClientAuth;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.sift.ContextBasedDiscriminator.setDefaultValue",
	"Comment": "the default context name in case the context name is not set for thecurrent logging event.",
	"Method": "void setDefaultValue(String defaultValue){\r\n    this.defaultValue = defaultValue;\r\n}"
}, {
	"Path": "org.mage.plugins.card.images.ImageCache.getImage",
	"Comment": "returns the image appropriate to display the card in the picture panel",
	"Method": "BufferedImage getImage(String key,BufferedImage getImage,CardView card,int width,int height){\r\n    if (Constants.THUMBNAIL_SIZE_FULL.width + 10 > width) {\r\n        return getThumbnail(card);\r\n    }\r\n    String key = getKey(card, card.getName(), Integer.toString(width));\r\n    BufferedImage original = getImage(key);\r\n    if (original == null) {\r\n        LOGGER.debug(key + \" not found\");\r\n        return null;\r\n    }\r\n    double scale = Math.min((double) width / original.getWidth(), (double) height / original.getHeight());\r\n    if (scale >= 1) {\r\n        return original;\r\n    }\r\n    return TransformedImageCache.getResizedImage(original, (int) (original.getWidth() * scale), (int) (original.getHeight() * scale));\r\n}"
}, {
	"Path": "com.networknt.mask.Mask.maskString",
	"Comment": "mask the input string with a list of patterns indexed by key in string section in mask.jsonthis is usually used to mask header values, query parameters and uri parameters",
	"Method": "String maskString(String input,String key){\r\n    String output = input;\r\n    Map<String, Object> stringConfig = (Map<String, Object>) config.get(MASK_TYPE_STRING);\r\n    if (stringConfig != null) {\r\n        Map<String, Object> keyConfig = (Map<String, Object>) stringConfig.get(key);\r\n        if (keyConfig != null) {\r\n            Set<String> patterns = keyConfig.keySet();\r\n            for (String pattern : patterns) {\r\n                output = output.replaceAll(pattern, (String) keyConfig.get(pattern));\r\n            }\r\n        }\r\n    }\r\n    return output;\r\n}"
}, {
	"Path": "mage.player.ai.ma.optimizers.impl.LevelUpOptimizer.filter",
	"Comment": "check that ability is level up ability, then compare the current counters of level type to maximum.",
	"Method": "void filter(Game game,List<Ability> actions){\r\n    for (Ability ability : actions) {\r\n        if (ability instanceof LevelUpAbility) {\r\n            Permanent permanent = game.getPermanent(ability.getSourceId());\r\n            if (permanent instanceof PermanentCard) {\r\n                PermanentCard leveler = (PermanentCard) permanent;\r\n                if (permanent.getCounters(game).getCount(CounterType.LEVEL) >= leveler.getMaxLevelCounters()) {\r\n                    removeAbility(ability);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.FileAppender.getLazy",
	"Comment": "gets the enable status of lazy initialization of the file outputstream",
	"Method": "boolean getLazy(){\r\n    return lazyInit;\r\n}"
}, {
	"Path": "ch.qos.logback.core.rolling.TimeBasedRollingPolicy.setCleanHistoryOnStart",
	"Comment": "should archive removal be attempted on application start up? default is false.",
	"Method": "void setCleanHistoryOnStart(boolean cleanHistoryOnStart){\r\n    this.cleanHistoryOnStart = cleanHistoryOnStart;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.control.ScenarioMaker.makeTypeAScenario",
	"Comment": "makes a scenario with len logger creations. logger names are generatedindependently such that the overwhelming majority of logger names will beunrelated to each other. each logger creation may be followed with arandomly generated set levelint action on that logger.",
	"Method": "Scenario makeTypeAScenario(int len){\r\n    Scenario scenario = new Scenario();\r\n    ;\r\n    for (int i = 0; i < len; i++) {\r\n        String loggerName = ScenarioRandomUtil.randomLoggerName(AVERAGE_LOGGER_DEPTH, LOGGER_DEPT_DEV);\r\n        scenario.add(new CreateLogger(loggerName));\r\n    }\r\n    return scenario;\r\n}"
}, {
	"Path": "io.dropwizard.metrics.EWMA.tick",
	"Comment": "mark the passage of time and decay the current rate accordingly.",
	"Method": "void tick(){\r\n    final long count = uncounted.sumThenReset();\r\n    final double instantRate = count / interval;\r\n    if (initialized) {\r\n        rate += (alpha * (instantRate - rate));\r\n    } else {\r\n        rate = instantRate;\r\n        initialized = true;\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.spi.AppenderAttachableImpl.detachAppender",
	"Comment": "remove the appender with the name passed as parameter form the list ofappenders.",
	"Method": "boolean detachAppender(Appender<E> appender,boolean detachAppender,String name){\r\n    if (name == null) {\r\n        return false;\r\n    }\r\n    boolean removed = false;\r\n    for (Appender<E> a : appenderList) {\r\n        if (name.equals((a).getName())) {\r\n            removed = appenderList.remove(a);\r\n            break;\r\n        }\r\n    }\r\n    return removed;\r\n}"
}, {
	"Path": "org.lenskit.eval.traintest.TrainTestExperiment.setContinueAfterError",
	"Comment": "configure whether the experiment will continue after an error.",
	"Method": "void setContinueAfterError(boolean c){\r\n    continueAfterError = c;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.net.SyslogAppender.getSeverityForEvent",
	"Comment": "convert a level to equivalent syslog severity. only levels for printingmethods i.e debug, warn, info and error are converted.",
	"Method": "int getSeverityForEvent(Object eventObject){\r\n    ILoggingEvent event = (ILoggingEvent) eventObject;\r\n    return LevelToSyslogSeverity.convert(event);\r\n}"
}, {
	"Path": "mage.players.Library.getFromBottom",
	"Comment": "returns the bottommost card of the library without removing it",
	"Method": "Card getFromBottom(Game game){\r\n    return game.getCard(library.pollLast());\r\n}"
}, {
	"Path": "mage.client.deck.generator.DeckGeneratorPool.landTapsForAllowedColor",
	"Comment": "returns if this land taps for the given color.basic string matching to check the ability adds one of the chosen mana when tapped.",
	"Method": "boolean landTapsForAllowedColor(String ability,String symbol){\r\n    return ability.matches(\".*Add \\\\{\" + symbol + \"\\\\}.\");\r\n}"
}, {
	"Path": "mage.cards.ExpansionSet.getNumberOfSpecialCommons",
	"Comment": "can be overwritten if sometimes special cards will be generated insteadof common slots",
	"Method": "int getNumberOfSpecialCommons(){\r\n    return 0;\r\n}"
}, {
	"Path": "com.networknt.url.HttpURL.getLastPathSegment",
	"Comment": "gets the last url path segment without the query string.if there are segment to return,an empty string will be returned instead.",
	"Method": "String getLastPathSegment(){\r\n    if (StringUtils.isBlank(path)) {\r\n        return StringUtils.EMPTY;\r\n    }\r\n    String segment = path;\r\n    segment = StringUtils.substringAfterLast(segment, \"/\");\r\n    return segment;\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.SyslogAppenderBase.getCharset",
	"Comment": "returns the charset used to encode string messages into byte sequences when writing tosyslog.",
	"Method": "Charset getCharset(){\r\n    return charset;\r\n}"
}, {
	"Path": "com.networknt.url.HttpURL.toString",
	"Comment": "returns a string representation of this url, properly encoded.",
	"Method": "String toString(){\r\n    StringBuilder b = new StringBuilder();\r\n    if (StringUtils.isNotBlank(protocol)) {\r\n        b.append(protocol);\r\n        b.append(\"://\");\r\n    }\r\n    if (StringUtils.isNotBlank(host)) {\r\n        b.append(host);\r\n    }\r\n    if (!isPortDefault() && port != -1) {\r\n        b.append(':');\r\n        b.append(port);\r\n    }\r\n    if (StringUtils.isNotBlank(path)) {\r\n        if (b.length() > 0 && !path.startsWith(\"/\")) {\r\n            b.append('/');\r\n        }\r\n        b.append(encodePath(path));\r\n    }\r\n    if (queryString != null && !queryString.isEmpty()) {\r\n        b.append(queryString.toString());\r\n    }\r\n    if (fragment != null) {\r\n        b.append(\"#\");\r\n        b.append(encodePath(fragment));\r\n    }\r\n    return b.toString();\r\n}"
}, {
	"Path": "ch.qos.logback.core.joran.action.PropertyAction.begin",
	"Comment": "set a new property for the execution context by name, value pair, or addsall the properties found in the given file.",
	"Method": "void begin(InterpretationContext ec,String localName,Attributes attributes){\r\n    if (\"substitutionProperty\".equals(localName)) {\r\n        addWarn(\"[substitutionProperty] element has been deprecated. Please use the [property] element instead.\");\r\n    }\r\n    String name = attributes.getValue(NAME_ATTRIBUTE);\r\n    String value = attributes.getValue(VALUE_ATTRIBUTE);\r\n    String scopeStr = attributes.getValue(SCOPE_ATTRIBUTE);\r\n    Scope scope = ActionUtil.stringToScope(scopeStr);\r\n    if (checkFileAttributeSanity(attributes)) {\r\n        String file = attributes.getValue(FILE_ATTRIBUTE);\r\n        file = ec.subst(file);\r\n        try {\r\n            FileInputStream istream = new FileInputStream(file);\r\n            loadAndSetProperties(ec, istream, scope);\r\n        } catch (FileNotFoundException e) {\r\n            addError(\"Could not find properties file [\" + file + \"].\");\r\n        } catch (IOException e1) {\r\n            addError(\"Could not read properties file [\" + file + \"].\", e1);\r\n        }\r\n    } else if (checkResourceAttributeSanity(attributes)) {\r\n        String resource = attributes.getValue(RESOURCE_ATTRIBUTE);\r\n        resource = ec.subst(resource);\r\n        URL resourceURL = Loader.getResourceBySelfClassLoader(resource);\r\n        if (resourceURL == null) {\r\n            addError(\"Could not find resource [\" + resource + \"].\");\r\n        } else {\r\n            try {\r\n                InputStream istream = resourceURL.openStream();\r\n                loadAndSetProperties(ec, istream, scope);\r\n            } catch (IOException e) {\r\n                addError(\"Could not read resource file [\" + resource + \"].\", e);\r\n            }\r\n        }\r\n    } else if (checkValueNameAttributesSanity(attributes)) {\r\n        value = RegularEscapeUtil.basicEscape(value);\r\n        value = value.trim();\r\n        value = ec.subst(value);\r\n        ActionUtil.setProperty(ec, name, value, scope);\r\n    } else {\r\n        addError(INVALID_ATTRIBUTES);\r\n    }\r\n}"
}, {
	"Path": "mage.game.permanent.Battlefield.fireControlChangeEvents",
	"Comment": "since control could change several times during applyevents we only wantto fire control changed events after all control change effects have beenapplied",
	"Method": "boolean fireControlChangeEvents(Game game){\r\n    boolean controlChanged = false;\r\n    for (Permanent perm : field.values()) {\r\n        if (perm.isPhasedIn()) {\r\n            controlChanged |= perm.checkControlChanged(game);\r\n        }\r\n    }\r\n    return controlChanged;\r\n}"
}, {
	"Path": "mage.client.deck.generator.DeckGenerator.generateBasicLands",
	"Comment": "returns a map of colored mana symbol to basic land cards of that color.",
	"Method": "Map<String, List<CardInfo>> generateBasicLands(List<String> setsToUse){\r\n    Set<String> landSets = TournamentUtil.getLandSetCodeForDeckSets(setsToUse);\r\n    CardCriteria criteria = new CardCriteria();\r\n    if (!landSets.isEmpty()) {\r\n        criteria.setCodes(landSets.toArray(new String[landSets.size()]));\r\n    }\r\n    Map<String, List<CardInfo>> basicLandMap = new HashMap();\r\n    for (ColoredManaSymbol c : ColoredManaSymbol.values()) {\r\n        String landName = DeckGeneratorPool.getBasicLandName(c.toString());\r\n        criteria.rarities(Rarity.LAND).name(landName);\r\n        List<CardInfo> cards = CardRepository.instance.findCards(criteria);\r\n        if (cards.isEmpty()) {\r\n            criteria.setCodes(\"ORI\");\r\n            cards = CardRepository.instance.findCards(criteria);\r\n        }\r\n        basicLandMap.put(landName, cards);\r\n    }\r\n    return basicLandMap;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.Level.toLevel",
	"Comment": "convert the string passed as argument to a level. if the conversion fails,then this method returns the value of defaultlevel.",
	"Method": "Level toLevel(String sArg,Level toLevel,int val,Level toLevel,int val,Level defaultLevel,Level toLevel,String sArg,Level defaultLevel){\r\n    if (sArg == null) {\r\n        return defaultLevel;\r\n    }\r\n    final String in = sArg.trim();\r\n    if (in.equalsIgnoreCase(\"ALL\")) {\r\n        return Level.ALL;\r\n    }\r\n    if (in.equalsIgnoreCase(\"TRACE\")) {\r\n        return Level.TRACE;\r\n    }\r\n    if (in.equalsIgnoreCase(\"DEBUG\")) {\r\n        return Level.DEBUG;\r\n    }\r\n    if (in.equalsIgnoreCase(\"INFO\")) {\r\n        return Level.INFO;\r\n    }\r\n    if (in.equalsIgnoreCase(\"WARN\")) {\r\n        return Level.WARN;\r\n    }\r\n    if (in.equalsIgnoreCase(\"ERROR\")) {\r\n        return Level.ERROR;\r\n    }\r\n    if (in.equalsIgnoreCase(\"OFF\")) {\r\n        return Level.OFF;\r\n    }\r\n    return defaultLevel;\r\n}"
}, {
	"Path": "ch.qos.logback.core.spi.AbstractComponentTracker.getFromEitherMap",
	"Comment": "get an entry from the livemap, if not found search the lingerersmap.",
	"Method": "Entry<C> getFromEitherMap(String key){\r\n    Entry<C> entry = liveMap.get(key);\r\n    if (entry != null)\r\n        return entry;\r\n    else {\r\n        return lingerersMap.get(key);\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.BasicStatusManager.add",
	"Comment": "this implementation does not allow duplicate installations of onconsolestatuslistener",
	"Method": "void add(Status newStatus,boolean add,StatusListener listener){\r\n    synchronized (statusListenerListLock) {\r\n        if (listener instanceof OnConsoleStatusListener) {\r\n            boolean alreadyPresent = checkForPresence(statusListenerList, listener.getClass());\r\n            if (alreadyPresent) {\r\n                return false;\r\n            }\r\n        }\r\n        statusListenerList.add(listener);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "ch.qos.logback.core.pattern.parser.Parser.compile",
	"Comment": "when the parsing step is done, the node list can be transformed into aconverter chain.",
	"Method": "Converter<E> compile(Node top,Map<String, String> converterMap){\r\n    Compiler<E> compiler = new Compiler<E>(top, converterMap);\r\n    compiler.setContext(context);\r\n    return compiler.compile();\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.server.ServerSocketAppenderBase.getBacklog",
	"Comment": "gets the listener queue depth.this represents the number of connected clients whose connectionshave not yet been accepted.",
	"Method": "Integer getBacklog(){\r\n    return backlog;\r\n}"
}, {
	"Path": "org.lenskit.knn.item.ItemItemGlobalRecommenderTest.testGlobalItemScorerNoRating",
	"Comment": "check that we score items but do not provide scores for itemsthe user has previously rated.",
	"Method": "void testGlobalItemScorerNoRating(){\r\n    long[] queryItems = { 1, 10 };\r\n    long[] items = { 5, 10 };\r\n    ItemItemItemBasedItemScorer scorer = session.get(ItemItemItemBasedItemScorer.class);\r\n    assertThat(scorer, notNullValue());\r\n    ResultMap scores = scorer.scoreRelatedItemsWithDetails(LongArrayList.wrap(queryItems), LongArrayList.wrap(items));\r\n    assertThat(scores, notNullValue());\r\n    assertThat(scores.size(), equalTo(2));\r\n    Result r5 = scores.get(5);\r\n    assertThat(r5, notNullValue());\r\n    assertThat(r5.getScore(), not(notANumber()));\r\n}"
}, {
	"Path": "mage.Mana.setGeneric",
	"Comment": "sets the total generic mana. can not be negative. negative values will belogged and set to 0.",
	"Method": "void setGeneric(int generic){\r\n    this.generic = notNegative(generic, \"Generic\");\r\n}"
}, {
	"Path": "mage.client.chat.LocalCommands.handleLocalCommands",
	"Comment": "handler for commands that do not require server interaction, i.e settings etc",
	"Method": "boolean handleLocalCommands(UUID chatId,String text){\r\n    final StringTokenizer st = new StringTokenizer(text.trim());\r\n    final int tokens = st.countTokens();\r\n    if (tokens == 0) {\r\n        return false;\r\n    }\r\n    final String serverAddress = SessionHandler.getSession().getServerHostname().orElseGet(() -> \"\");\r\n    Optional<String> response = Optional.empty();\r\n    switch(st.nextToken()) {\r\n        case \"/ignore\":\r\n        case \"\\\\ignore\":\r\n            final String ignoreTarget = tokens > 1 ? st.nextToken() : \"\";\r\n            response = Optional.of(IgnoreList.ignore(serverAddress, ignoreTarget));\r\n            break;\r\n        case \"/unignore\":\r\n        case \"\\\%unignore\":\r\n            final String unignoreTarget = tokens > 1 ? st.nextToken() : \"\";\r\n            response = Optional.of(IgnoreList.unignore(serverAddress, unignoreTarget));\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    if (response.isPresent()) {\r\n        displayLocalCommandResponse(chatId, response.get());\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.lenskit.util.monitor.TrackedJob.setReportingInterval",
	"Comment": "set the reporting interval for firing progress update messages.",
	"Method": "void setReportingInterval(int iv){\r\n    reportingInterval = iv;\r\n}"
}, {
	"Path": "mage.abilities.costs.OptionalAdditionalCostImpl.activate",
	"Comment": "if the player intends to pay the cost, the cost will be activated",
	"Method": "void activate(){\r\n    activated = true;\r\n    ++activatedCounter;\r\n}"
}, {
	"Path": "org.lenskit.eval.crossfold.CrossfoldMethods.sampleEntities",
	"Comment": "create a crossfold method that creates disjoint samples of entities into disjoint partitions.",
	"Method": "CrossfoldMethod sampleEntities(int size){\r\n    return new EntitySampleCrossfoldMethod(size);\r\n}"
}, {
	"Path": "org.lenskit.eval.traintest.AlgorithmInstance.getName",
	"Comment": "get the name of this algorithm.this returns a short name which isused to identify the algorithm or instance.",
	"Method": "String getName(){\r\n    return algoName;\r\n}"
}, {
	"Path": "mage.player.ai.ComputerPlayer2.checkForUselessAction",
	"Comment": "resolve current ability on the stack if there is one, thencheck if current game state is the same as the previous, if so thenaction has no effect and is not useful",
	"Method": "boolean checkForUselessAction(Game sim,SimulationNode node,Ability action,UUID playerId){\r\n    int currentVal = 0;\r\n    int prevVal = 0;\r\n    if (action instanceof PassAbility)\r\n        return false;\r\n    SimulationNode test = node.getParent();\r\n    if (test == null)\r\n        return false;\r\n    if (action.isUsesStack()) {\r\n        Game testSim = sim.copy();\r\n        StackObject ability = testSim.getStack().pop();\r\n        ability.resolve(testSim);\r\n        testSim.applyEffects();\r\n        currentVal = GameStateEvaluator.evaluate(playerId, testSim, true);\r\n    } else {\r\n        currentVal = GameStateEvaluator.evaluate(playerId, sim, true);\r\n    }\r\n    prevVal = GameStateEvaluator.evaluate(playerId, test.getGame(), true);\r\n    return currentVal == prevVal;\r\n}"
}, {
	"Path": "com.networknt.client.Http2Client.addCcToken",
	"Comment": "add client credentials token cached in the client for standalone applicationthis is the method called from standalone application like enterprise scheduler for batch jobsor mobile apps.",
	"Method": "void addCcToken(ClientRequest request){\r\n    checkCCTokenExpired();\r\n    request.getRequestHeaders().put(Headers.AUTHORIZATION, \"Bearer \" + jwt);\r\n}"
}, {
	"Path": "org.lenskit.util.keys.DynamicSortedKeyIndexTest.makeDataPoints",
	"Comment": "method to compute the data points. split out so that errors it throws get reported.",
	"Method": "void makeDataPoints(){\r\n    KeyData[] data = new KeyData[10];\r\n    Generator<Long> intGen = longs(Integer.MIN_VALUE, Integer.MAX_VALUE);\r\n    Generator<Long> longGen = longs(Integer.MAX_VALUE + 1L, Long.MAX_VALUE);\r\n    for (int i = 0; i < 10; i++) {\r\n        Generator<List<Long>> listGen;\r\n        if (i % 2 == 0) {\r\n            listGen = sortedLists(uniqueValues(intGen), 25, 25);\r\n        } else {\r\n            listGen = sortedLists(uniqueValues(longGen), 25, 25);\r\n        }\r\n        List<Long> nums = listGen.next();\r\n        data[i] = new KeyData(nums);\r\n    }\r\n    DATA_POINTS = data;\r\n}"
}, {
	"Path": "mage.abilities.costs.OptionalAdditionalCostImpl.getText",
	"Comment": "returns the complete text for the addional cost or if onlycost is trueonly the pure text fore the included native cost",
	"Method": "String getText(boolean onlyCost){\r\n    if (onlyCost) {\r\n        return getText();\r\n    } else {\r\n        return name + delimiter + getText();\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.server.ConcurrentServerRunner.removeClient",
	"Comment": "removes a client from the collection of those being tracked by the server.",
	"Method": "void removeClient(T client){\r\n    clientsLock.lock();\r\n    try {\r\n        clients.remove(client);\r\n    } finally {\r\n        clientsLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "mage.abilities.AbilityImpl.handlePhyrexianManaCosts",
	"Comment": "601.2b if a cost that will be paid as the spell is being cast includesphyrexian mana symbols, the player announces whether he or she intends topay 2 life or the corresponding colored mana cost for each of thosesymbols.",
	"Method": "void handlePhyrexianManaCosts(Game game,UUID sourceId,Player controller){\r\n    Iterator<ManaCost> costIterator = manaCostsToPay.iterator();\r\n    while (costIterator.hasNext()) {\r\n        ManaCost cost = costIterator.next();\r\n        if (cost instanceof PhyrexianManaCost) {\r\n            PhyrexianManaCost phyrexianManaCost = (PhyrexianManaCost) cost;\r\n            PayLifeCost payLifeCost = new PayLifeCost(2);\r\n            if (payLifeCost.canPay(this, sourceId, controller.getId(), game) && controller.chooseUse(Outcome.LoseLife, \"Pay 2 life instead of \" + phyrexianManaCost.getBaseText() + '?', this, game)) {\r\n                costIterator.remove();\r\n                costs.add(payLifeCost);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.dropwizard.metrics.InstrumentedExecutors.newCachedThreadPool",
	"Comment": "creates an instrumented thread pool that creates new threads as needed, butwill reuse previously constructed threads when they areavailable, and uses the providedthreadfactory to create new threads when needed.",
	"Method": "InstrumentedExecutorService newCachedThreadPool(MetricRegistry registry,String name,InstrumentedExecutorService newCachedThreadPool,MetricRegistry registry,InstrumentedExecutorService newCachedThreadPool,ThreadFactory threadFactory,MetricRegistry registry,String name,InstrumentedExecutorService newCachedThreadPool,ThreadFactory threadFactory,MetricRegistry registry){\r\n    return new InstrumentedExecutorService(Executors.newCachedThreadPool(threadFactory), registry);\r\n}"
}, {
	"Path": "ch.qos.logback.classic.HLogger.removeAppender",
	"Comment": "remove the appender passed as parameter form the list of appenders.",
	"Method": "void removeAppender(Appender<ILoggingEvent> appender){\r\n    if ((appender != null) && (appenderList != null)) {\r\n        appenderList.remove(appender);\r\n    }\r\n}"
}, {
	"Path": "mage.ObjectColor.union",
	"Comment": "returns a new color which contains all of the colors of this objectcolorin addition to all of the colors of the other objectcolor.",
	"Method": "ObjectColor union(ObjectColor other){\r\n    ObjectColor newColor = new ObjectColor();\r\n    newColor.white = white || other.white;\r\n    newColor.blue = blue || other.blue;\r\n    newColor.black = black || other.black;\r\n    newColor.red = red || other.red;\r\n    newColor.green = green || other.green;\r\n    newColor.gold = gold || other.gold;\r\n    return newColor;\r\n}"
}, {
	"Path": "org.mage.plugins.card.images.ImageCache.getKey",
	"Comment": "returns the map key for a card, without any suffixes for the image size.",
	"Method": "String getKey(CardView card,String name,String suffix){\r\n    return name + '#' + card.getExpansionSetCode() + '#' + card.getType() + '#' + card.getCardNumber() + '#' + (card.getTokenSetCode() == null ? \"\" : card.getTokenSetCode()) + suffix + (card.getUsesVariousArt() ? \"#usesVariousArt\" : \"\") + (card.getTokenDescriptor() != null ? '#' + card.getTokenDescriptor() : \"#\");\r\n}"
}, {
	"Path": "mage.player.ai.utils.RateCard.readRatings",
	"Comment": "reads ratings from resources and loads them into ratings map",
	"Method": "void readRatings(String expCode){\r\n    if (ratings == null) {\r\n        ratings = new HashMap();\r\n    }\r\n    if (setsWithRatingsToBeLoaded.contains(expCode)) {\r\n        log.info(\"reading draftbot ratings for the set\" + expCode);\r\n        readFromFile(RATINGS_DIR + expCode + \".csv\");\r\n        setsWithRatingsToBeLoaded.remove(expCode);\r\n    }\r\n}"
}, {
	"Path": "io.dropwizard.metrics.MetricName.resolve",
	"Comment": "build the metricname that is this with another path appended to it.the new metricname inherits the tags of this one.",
	"Method": "MetricName resolve(String p){\r\n    final String next;\r\n    if (p != null && !p.isEmpty()) {\r\n        if (key != null && !key.isEmpty()) {\r\n            next = key + SEPARATOR + p;\r\n        } else {\r\n            next = p;\r\n        }\r\n    } else {\r\n        next = this.key;\r\n    }\r\n    return new MetricName(next, tags);\r\n}"
}, {
	"Path": "org.lenskit.util.keys.SortedKeyIndex.create",
	"Comment": "create a key set with some keys.all keys are initially active.",
	"Method": "SortedKeyIndex create(long keys){\r\n    return fromCollection(LongArrayList.wrap(keys));\r\n}"
}, {
	"Path": "ch.qos.logback.core.FileAppenderResilience_AS_ROOT_Test.runLoopFSScript",
	"Comment": "it needs to be unix, with sudo privileges granted to the script",
	"Method": "Process runLoopFSScript(LoopFSCommand cmd){\r\n    if (!isConformingHost()) {\r\n        return null;\r\n    }\r\n    ProcessBuilder pb = new ProcessBuilder();\r\n    pb.command(\"/usr/bin/sudo\", PATH_LOOPFS_SCRIPT, cmd.toString());\r\n    return pb.start();\r\n}"
}, {
	"Path": "org.lenskit.eval.traintest.DataSet.getRuntimeData",
	"Comment": "get the runtime data set. this is the data that should be available when the recommender is run,but not when its model is trained.",
	"Method": "StaticDataSource getRuntimeData(){\r\n    return runtimeData;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.turbo.ReconfigurePerf.scan1",
	"Comment": "tests whether configurationaction is installing reconfigureonchangefilter",
	"Method": "void scan1(){\r\n    File file = new File(CONF_FILE_AS_STR);\r\n    configure(file);\r\n    System.out.println(\"Running scan1()\");\r\n    doRun();\r\n}"
}, {
	"Path": "ch.qos.logback.classic.turbo.ReconfigureOnChangeFilter.updateMaskIfNecessary",
	"Comment": "update the mask so as to execute change detection code about once every 100 to 8000 milliseconds.",
	"Method": "void updateMaskIfNecessary(long now){\r\n    final long timeElapsedSinceLastMaskUpdateCheck = now - lastMaskCheck;\r\n    lastMaskCheck = now;\r\n    if (timeElapsedSinceLastMaskUpdateCheck < MASK_INCREASE_THRESHOLD && (mask < MAX_MASK)) {\r\n        mask = (mask << 1) | 1;\r\n    } else if (timeElapsedSinceLastMaskUpdateCheck > MASK_DECREASE_THRESHOLD) {\r\n        mask = mask >>> 2;\r\n    }\r\n}"
}, {
	"Path": "org.lenskit.eval.temporal.TemporalEvaluator.execute",
	"Comment": "during the evaluation, it will replay the ratings, try to predict each one, andwrite the prediction, tarmse and the rating to the output file",
	"Method": "void execute(){\r\n    loadInputs();\r\n    LenskitRecommenderEngine lre = null;\r\n    Recommender recommender = null;\r\n    try (TableWriter tableWriter = openOutput();\r\n        SequenceWriter extWriter = openExtendedOutput()) {\r\n        List<Rating> ratings = dataSource.query(Rating.class).orderBy(CommonAttributes.TIMESTAMP).get();\r\n        DataAccessObject limitedDao = StaticDataSource.fromList(Collections.<Entity>emptyList()).get();\r\n        long limitTimestamp = 0;\r\n        double sse = 0;\r\n        int n = 0;\r\n        long buildTime = 0L;\r\n        int buildsCount = 0;\r\n        int ratingsSinceLastBuild = 0;\r\n        ListIterator<Rating> riter = ratings.listIterator();\r\n        while (riter.hasNext()) {\r\n            int ridx = riter.nextIndex();\r\n            Rating r = riter.next();\r\n            Map<String, Object> json = new HashMap();\r\n            json.put(\"userId\", r.getUserId());\r\n            json.put(\"itemId\", r.getItemId());\r\n            json.put(\"timestamp\", r.getTimestamp());\r\n            json.put(\"rating\", r.getValue());\r\n            if (recommender == null || (r.getTimestamp() > 0 && limitTimestamp < r.getTimestamp())) {\r\n                limitedDao = StaticDataSource.fromList(ratings.subList(0, ridx)).get();\r\n                if ((r.getTimestamp() - buildTime >= rebuildPeriod) || lre == null) {\r\n                    buildTime = r.getTimestamp();\r\n                    buildsCount++;\r\n                    logger.info(\"building model {} at time {}, {} ratings since last build\", buildsCount, buildTime, ratingsSinceLastBuild);\r\n                    Stopwatch timer = Stopwatch.createStarted();\r\n                    lre = LenskitRecommenderEngine.newBuilder().addConfiguration(algorithm.getConfigurations().get(0)).build(limitedDao);\r\n                    timer.stop();\r\n                    logger.info(\"built model {} in {}\", buildsCount, timer);\r\n                    ratingsSinceLastBuild = 0;\r\n                }\r\n                if (recommender != null) {\r\n                    recommender.close();\r\n                }\r\n                recommender = lre.createRecommender(limitedDao);\r\n            }\r\n            ratingsSinceLastBuild += 1;\r\n            json.put(\"modelAge\", r.getTimestamp() - buildTime);\r\n            Double predict = null;\r\n            RatingPredictor predictor = recommender.getRatingPredictor();\r\n            Result predictionResult = null;\r\n            if (predictor != null) {\r\n                predictionResult = predictor.predict(r.getUserId(), r.getItemId());\r\n            }\r\n            if (predictionResult != null) {\r\n                predict = predictionResult.getScore();\r\n                logger.debug(\"predicted {} for rating {}\", predict, r);\r\n                json.put(\"prediction\", predict);\r\n            } else {\r\n                json.put(\"prediction\", null);\r\n            }\r\n            double rmse = 0.0;\r\n            if (predict != null && !Double.isNaN(predict)) {\r\n                double err = predict - r.getValue();\r\n                sse += err * err;\r\n                n++;\r\n                rmse = sqrt(sse / n);\r\n            }\r\n            Integer rank = null;\r\n            ItemRecommender irec = recommender.getItemRecommender();\r\n            if (irec != null) {\r\n                rank = getRecommendationRank(limitedDao, r, json, irec);\r\n            }\r\n            tableWriter.writeRow(r.getUserId(), r.getItemId(), r.getValue(), r.getTimestamp(), predict, rmse, r.getTimestamp() - buildTime, rank, buildsCount);\r\n            if (extWriter != null) {\r\n                extWriter.write(json);\r\n            }\r\n        }\r\n    } finally {\r\n        if (recommender != null) {\r\n            recommender.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.classic.corpus.Corpus.dump",
	"Comment": "dump the events passed as argument into the file named targetfile.",
	"Method": "void dump(ILoggingEvent[] eventArray,String targetFile){\r\n    FileWriter fw = new FileWriter(targetFile);\r\n    for (ILoggingEvent e : eventArray) {\r\n        fw.write(e.toString());\r\n        fw.append(CoreConstants.LINE_SEPARATOR);\r\n        if (e.getThrowableProxy() != null) {\r\n            IThrowableProxy tp = e.getThrowableProxy();\r\n            fw.write(ThrowableProxyUtil.asString(tp));\r\n        }\r\n    }\r\n    fw.flush();\r\n    fw.close();\r\n}"
}, {
	"Path": "mage.player.ai.MCTSNode.randomizePlayers",
	"Comment": "shuffles each players library so that there is no knowledge of its orderswaps all other players hands with random cards from the library so thatthere is no knowledge of what cards are in opponents hands",
	"Method": "void randomizePlayers(Game game,UUID playerId){\r\n    for (Player player : game.getState().getPlayers().values()) {\r\n        if (!player.getId().equals(playerId)) {\r\n            int handSize = player.getHand().size();\r\n            player.getLibrary().addAll(player.getHand().getCards(game), game);\r\n            player.getHand().clear();\r\n            player.getLibrary().shuffle();\r\n            for (int i = 0; i < handSize; i++) {\r\n                Card card = player.getLibrary().removeFromTop(game);\r\n                card.setZone(Zone.HAND, game);\r\n                player.getHand().add(card);\r\n            }\r\n        } else {\r\n            player.getLibrary().shuffle();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.classic.sift.ContextBasedDiscriminator.getDiscriminatingValue",
	"Comment": "return the name of the current context name as found in the logging event.",
	"Method": "String getDiscriminatingValue(ILoggingEvent event){\r\n    String contextName = event.getLoggerContextVO().getName();\r\n    if (contextName == null) {\r\n        return defaultValue;\r\n    } else {\r\n        return contextName;\r\n    }\r\n}"
}, {
	"Path": "mage.game.GameState.removeTriggersOfSourceId",
	"Comment": "removes triggered abilities that belong to sourceid this is used if atoken leaves the battlefield",
	"Method": "void removeTriggersOfSourceId(UUID sourceId){\r\n    triggers.removeAbilitiesOfSource(sourceId);\r\n}"
}, {
	"Path": "mage.Mana.setRed",
	"Comment": "sets the total red mana. can not be negative. negative values will belogged and set to 0.",
	"Method": "void setRed(int red){\r\n    this.red = notNegative(red, \"Red\");\r\n}"
}, {
	"Path": "mage.util.DateFormat.getDuration",
	"Comment": "converts seconds to a string with hours, minutes and seconds",
	"Method": "String getDuration(Date fromDate,Date toDate,String getDuration,long seconds){\r\n    StringBuilder sb = new StringBuilder();\r\n    long h = seconds / 3600;\r\n    seconds = seconds % 3600;\r\n    long m = seconds / 60;\r\n    long s = seconds % 60;\r\n    sb.append(h).append(':');\r\n    if (m < 10) {\r\n        sb.append('0');\r\n    }\r\n    sb.append(m).append(':');\r\n    if (s < 10) {\r\n        sb.append('0');\r\n    }\r\n    sb.append(s);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "mage.Mana.setBlue",
	"Comment": "sets the total blue mana. can not be negative. negative values will belogged and set to 0.",
	"Method": "void setBlue(int blue){\r\n    this.blue = notNegative(blue, \"Blue\");\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.SyslogAppenderBase.getLazy",
	"Comment": "gets the enable status of lazy initialization of the syslog outputstream",
	"Method": "boolean getLazy(){\r\n    return lazyInit;\r\n}"
}, {
	"Path": "com.networknt.url.HttpURL.getRoot",
	"Comment": "gets the root of this httpurl. that is the left part of a url up toand including the host name. a null or empty string returnsa null document root.",
	"Method": "String getRoot(String getRoot,String url){\r\n    if (StringUtils.isBlank(url)) {\r\n        return null;\r\n    }\r\n    return RegExUtils.replacePattern(url, \"(.*?://.*?)([/?#].*)\", \"$1\");\r\n}"
}, {
	"Path": "org.lenskit.predict.ordrec.OrdRecRatingPredictorTest.testOrdRecPrediction2",
	"Comment": "this test is to test the basic performance of ordrecratingpredictor,the rating value is 1, 2, 3. the score for rating 1 is around 1, for rating 2is around 2, for rating 3 is around 3. so for the ordrec predictor, given a specificscore value, and test if it can return a matched rating.",
	"Method": "void testOrdRecPrediction2(){\r\n    ItemScorer scorer = PrecomputedItemScorer.newBuilder().addScore(42, 1, 2).addScore(42, 2, 1).addScore(42, 3, 3).addScore(42, 4, 3).addScore(42, 5, 1).addScore(42, 6, 2).addScore(42, 7, 2).addScore(42, 8, 3).addScore(42, 9, 1).addScore(42, 10, 1.1).addScore(42, 11, 1.9).addScore(42, 12, 3.1).build();\r\n    OrdRecRatingPredictor ordrec = new OrdRecRatingPredictor(scorer, dao, qtz);\r\n    ResultMap preds = ordrec.predictWithDetails(42, LongUtils.packedSet(10, 11, 12));\r\n    assertThat(preds.getScore(10), equalTo(1.0));\r\n    assertThat(preds.getScore(11), equalTo(2.0));\r\n    assertThat(preds.getScore(12), equalTo(3.0));\r\n}"
}, {
	"Path": "org.lenskit.util.math.Vectors.dotProduct",
	"Comment": "compute the dot product of two maps. this method assumes any value missing in one map is 0, so it is the dotproduct of the values of common keys.",
	"Method": "double dotProduct(Long2DoubleMap v1,Long2DoubleMap v2,double dotProduct,Long2DoubleSortedArrayMap v1,Long2DoubleSortedArrayMap v2){\r\n    double result;\r\n    result = 0;\r\n    final int sz1 = v1.size();\r\n    final int sz2 = v2.size();\r\n    int i1 = 0, i2 = 0;\r\n    while (i1 < sz1 && i2 < sz2) {\r\n        final long k1 = v1.getKeyByIndex(i1);\r\n        final long k2 = v2.getKeyByIndex(i2);\r\n        if (k1 < k2) {\r\n            i1++;\r\n        } else if (k2 < k1) {\r\n            i2++;\r\n        } else {\r\n            result += v1.getValueByIndex(i1) * v2.getValueByIndex(i2);\r\n            i1++;\r\n            i2++;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.lenskit.predict.ordrec.OrdRecRatingPredictorTest.testOrdRecPrediction3",
	"Comment": "this test is to test the basic performance of ordrecratingpredictor,the rating value is 1, 2, 3. the score for rating 1 is around 0.2, for rating 2is around 1, for rating 3 is around 1.8. so for the ordrec predictor, given a specificscore value, and test if it can return a matched rating.",
	"Method": "void testOrdRecPrediction3(){\r\n    ItemScorer scorer = PrecomputedItemScorer.newBuilder().addScore(42, 1, 1).addScore(42, 2, 0.2).addScore(42, 3, 1.8).addScore(42, 4, 1.8).addScore(42, 5, 0.2).addScore(42, 6, 1).addScore(42, 7, 1).addScore(42, 8, 1.8).addScore(42, 9, 0.2).addScore(42, 10, 0.21).addScore(42, 11, 1.01).addScore(42, 12, 1.75).build();\r\n    OrdRecRatingPredictor ordrec = new OrdRecRatingPredictor(scorer, dao, qtz);\r\n    ResultMap preds = ordrec.predictWithDetails(42, LongUtils.packedSet(10, 11, 12));\r\n    assertThat(preds.getScore(10), equalTo(1.0));\r\n    assertThat(preds.getScore(11), equalTo(2.0));\r\n    assertThat(preds.getScore(12), equalTo(3.0));\r\n}"
}, {
	"Path": "mage.game.combat.Combat.checkBlockRestrictionsAfter",
	"Comment": "checks the canbeblockedcheckafter restrictioneffect is the block stillvalid after all block decisions are done",
	"Method": "boolean checkBlockRestrictionsAfter(Player player,Player controller,Game game){\r\n    for (UUID blockingCreatureId : this.getBlockers()) {\r\n        Permanent blockingCreature = game.getPermanent(blockingCreatureId);\r\n        if (blockingCreature != null) {\r\n            for (Map.Entry<RestrictionEffect, Set<Ability>> entry : game.getContinuousEffects().getApplicableRestrictionEffects(blockingCreature, game).entrySet()) {\r\n                RestrictionEffect effect = entry.getKey();\r\n                for (Ability ability : entry.getValue()) {\r\n                    if (!effect.canBlockCheckAfter(ability, game)) {\r\n                        if (controller.isHuman()) {\r\n                            game.informPlayer(controller, blockingCreature.getLogName() + \" can't block this way.\");\r\n                            return false;\r\n                        } else {\r\n                            removeBlocker(blockingCreatureId, game);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (UUID attackingCreatureId : this.getAttackers()) {\r\n        Permanent attackingCreature = game.getPermanent(attackingCreatureId);\r\n        if (attackingCreature != null) {\r\n            for (Map.Entry<RestrictionEffect, Set<Ability>> entry : game.getContinuousEffects().getApplicableRestrictionEffects(attackingCreature, game).entrySet()) {\r\n                RestrictionEffect effect = entry.getKey();\r\n                for (Ability ability : entry.getValue()) {\r\n                    if (!effect.canBeBlockedCheckAfter(attackingCreature, ability, game)) {\r\n                        if (controller.isHuman()) {\r\n                            game.informPlayer(controller, attackingCreature.getLogName() + \" can't be blocked this way.\");\r\n                            return false;\r\n                        } else {\r\n                            for (CombatGroup combatGroup : this.getGroups()) {\r\n                                if (combatGroup.getAttackers().contains(attackingCreatureId)) {\r\n                                    for (UUID blockerId : combatGroup.getBlockers()) {\r\n                                        removeBlocker(blockerId, game);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.lenskit.predict.ordrec.OrdRecRatingPredictorTest.testOrdRecPrediction1",
	"Comment": "this test is to test the basic performance of ordrecratingpredictor,the rating value is 1, 2, 3. the score for rating 1 is around 2, for rating 2is around 5, for rating 8 is around 3. so for the ordrec predictor, given a specificscore value, and test if it can return a matched rating.",
	"Method": "void testOrdRecPrediction1(){\r\n    ItemScorer scorer = PrecomputedItemScorer.newBuilder().addScore(42, 1, 5).addScore(42, 2, 2).addScore(42, 3, 8).addScore(42, 4, 8.2).addScore(42, 5, 2.1).addScore(42, 6, 4.9).addScore(42, 7, 5).addScore(42, 8, 8).addScore(42, 9, 2).addScore(42, 10, 1.9).addScore(42, 11, 4.8).addScore(42, 12, 8.2).build();\r\n    OrdRecRatingPredictor ordrec = new OrdRecRatingPredictor(scorer, dao, qtz);\r\n    ResultMap preds = ordrec.predictWithDetails(42, LongUtils.packedSet(10, 11, 12));\r\n    assertThat(preds.getScore(10), equalTo(1.0));\r\n    assertThat(preds.getScore(11), equalTo(2.0));\r\n    assertThat(preds.getScore(12), equalTo(3.0));\r\n}"
}, {
	"Path": "com.networknt.utility.NioUtils.unzip",
	"Comment": "unzips the specified zip file to the specified destination directory.replaces any files in the destination, if they already exist.",
	"Method": "void unzip(String zipFilename,String destDirname){\r\n    final Path destDir = Paths.get(destDirname);\r\n    if (Files.notExists(destDir)) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(destDir + \" does not exist. Creating...\");\r\n        Files.createDirectories(destDir);\r\n    }\r\n    try (FileSystem zipFileSystem = createZipFileSystem(zipFilename, false)) {\r\n        final Path root = zipFileSystem.getPath(\"/\");\r\n        Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\r\n            @Override\r\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\r\n                final Path destFile = Paths.get(destDir.toString(), file.toString());\r\n                if (logger.isDebugEnabled())\r\n                    logger.debug(\"Extracting file %s to %s\", file, destFile);\r\n                Files.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\r\n                return FileVisitResult.CONTINUE;\r\n            }\r\n            @Override\r\n            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\r\n                final Path dirToCreate = Paths.get(destDir.toString(), dir.toString());\r\n                if (Files.notExists(dirToCreate)) {\r\n                    if (logger.isDebugEnabled())\r\n                        logger.debug(\"Creating directory %s\", dirToCreate);\r\n                    Files.createDirectory(dirToCreate);\r\n                }\r\n                return FileVisitResult.CONTINUE;\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.networknt.utility.NioUtils.unzip",
	"Comment": "unzips the specified zip file to the specified destination directory.replaces any files in the destination, if they already exist.",
	"Method": "void unzip(String zipFilename,String destDirname){\r\n    final Path destFile = Paths.get(destDir.toString(), file.toString());\r\n    if (logger.isDebugEnabled())\r\n        logger.debug(\"Extracting file %s to %s\", file, destFile);\r\n    Files.copy(file, destFile, StandardCopyOption.REPLACE_EXISTING);\r\n    return FileVisitResult.CONTINUE;\r\n}"
}, {
	"Path": "com.networknt.utility.NioUtils.unzip",
	"Comment": "unzips the specified zip file to the specified destination directory.replaces any files in the destination, if they already exist.",
	"Method": "void unzip(String zipFilename,String destDirname){\r\n    final Path dirToCreate = Paths.get(destDir.toString(), dir.toString());\r\n    if (Files.notExists(dirToCreate)) {\r\n        if (logger.isDebugEnabled())\r\n            logger.debug(\"Creating directory %s\", dirToCreate);\r\n        Files.createDirectory(dirToCreate);\r\n    }\r\n    return FileVisitResult.CONTINUE;\r\n}"
}, {
	"Path": "ch.qos.logback.core.spi.AppenderAttachableImpl.isAttached",
	"Comment": "returns true if the specified appender is in the list ofattached appenders, false otherwise.",
	"Method": "boolean isAttached(Appender<E> appender){\r\n    if (appender == null) {\r\n        return false;\r\n    }\r\n    for (Appender<E> a : appenderList) {\r\n        if (a == appender)\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "mage.abilities.mana.TriggeredManaAbility.definesMana",
	"Comment": "used to check if the ability itself defines mana types it can produce.",
	"Method": "boolean definesMana(Game game){\r\n    return !netMana.isEmpty();\r\n}"
}, {
	"Path": "mage.filter.predicate.Predicates.checkNotNull",
	"Comment": "ensures that an object reference passed as a parameter to the calling method is not null.",
	"Method": "T checkNotNull(T reference){\r\n    if (reference == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    return reference;\r\n}"
}, {
	"Path": "mage.abilities.costs.AlternativeCost2Impl.getText",
	"Comment": "returns the complete text for the addional cost or if onlycost is trueonly the pure text for the included native cost",
	"Method": "String getText(boolean onlyCost){\r\n    if (onlyCost) {\r\n        return getText();\r\n    } else {\r\n        return (name != null ? name : \"\") + (delimiter != null ? delimiter : \"\") + getText();\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.LifeCycleManager.reset",
	"Comment": "resets this manager.all registered components are stopped and removed from the manager.",
	"Method": "void reset(){\r\n    for (LifeCycle component : components) {\r\n        if (component.isStarted()) {\r\n            component.stop();\r\n        }\r\n    }\r\n    components.clear();\r\n}"
}, {
	"Path": "mage.util.CircularList.getNext",
	"Comment": "returns the next element in the list. will loop around to the beginningof the list if the current element is the last.",
	"Method": "E getNext(){\r\n    return list.get(incrementPointer());\r\n}"
}, {
	"Path": "mage.game.GameImpl.rememberLKI",
	"Comment": "remembers object state to be used as last known information.",
	"Method": "void rememberLKI(UUID objectId,Zone zone,MageObject object){\r\n    if (object instanceof Permanent || object instanceof StackObject) {\r\n        MageObject copy = object.copy();\r\n        Map<UUID, MageObject> lkiMap = lki.get(zone);\r\n        if (lkiMap != null) {\r\n            lkiMap.put(objectId, copy);\r\n        } else {\r\n            HashMap<UUID, MageObject> newMap = new HashMap();\r\n            newMap.put(objectId, copy);\r\n            lki.put(zone, newMap);\r\n        }\r\n        Set<UUID> idSet = shortLivingLKI.computeIfAbsent(zone, k -> new HashSet());\r\n        idSet.add(objectId);\r\n        if (object instanceof Permanent) {\r\n            Map<Integer, MageObject> lkiExtendedMap = lkiExtended.get(objectId);\r\n            if (lkiExtendedMap != null) {\r\n                lkiExtendedMap.put(object.getZoneChangeCounter(this), copy);\r\n            } else {\r\n                lkiExtendedMap = new HashMap();\r\n                lkiExtendedMap.put(object.getZoneChangeCounter(this), copy);\r\n                lkiExtended.put(objectId, lkiExtendedMap);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mage.server.game.GameController.createPlayerTimer",
	"Comment": "we create a timer that will run every 250 ms individually for a playerdecreasing his internal game counter. later on this counter is used toget time left to play the whole match.what we also do here is passing action to prioritytimer that is theaction that will be executed once game timer is over.",
	"Method": "PriorityTimer createPlayerTimer(UUID playerId,int count){\r\n    final UUID initPlayerId = playerId;\r\n    long delayMs = 250L;\r\n    Action executeOnNoTimeLeft = () -> {\r\n        game.timerTimeout(initPlayerId);\r\n        logger.debug(\"Player has no time left to end the match: \" + initPlayerId + \". Conceding.\");\r\n    };\r\n    PriorityTimer timer = new PriorityTimer(count, delayMs, executeOnNoTimeLeft);\r\n    timer.init(game.getId());\r\n    timers.put(playerId, timer);\r\n    return timer;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.sift.MDCBasedDiscriminator.getDiscriminatingValue",
	"Comment": "return the value associated with an mdc entry designated by the keyproperty. if that value is null, then return the value assigned to thedefaultvalue property.",
	"Method": "String getDiscriminatingValue(ILoggingEvent event){\r\n    Map<String, String> mdcMap = event.getMDCPropertyMap();\r\n    if (mdcMap == null) {\r\n        return defaultValue;\r\n    }\r\n    String mdcValue = mdcMap.get(key);\r\n    if (mdcValue == null) {\r\n        return defaultValue;\r\n    } else {\r\n        return mdcValue;\r\n    }\r\n}"
}, {
	"Path": "io.dropwizard.metrics.MetricRegistry.getCounters",
	"Comment": "returns a map of all the counters in the registry and their names which match the givenfilter.",
	"Method": "SortedMap<MetricName, Counter> getCounters(SortedMap<MetricName, Counter> getCounters,MetricFilter filter){\r\n    return getMetrics(Counter.class, filter);\r\n}"
}, {
	"Path": "ch.qos.logback.core.hook.DefaultShutdownHook.setDelay",
	"Comment": "the duration to wait before shutting down the currentlogback context.",
	"Method": "void setDelay(Duration delay){\r\n    this.delay = delay;\r\n}"
}, {
	"Path": "mage.game.GameImpl.getPlayerList",
	"Comment": "return a list of all players ignoring the range of visible players",
	"Method": "PlayerList getPlayerList(){\r\n    return state.getPlayerList();\r\n}"
}, {
	"Path": "ch.qos.logback.core.status.StatusUtil.contextHasStatusListener",
	"Comment": "returns true if the statusmanager associated with the context passedas parameter has one or more statuslistener instances registered. returnsfalse otherwise.",
	"Method": "boolean contextHasStatusListener(Context context){\r\n    StatusManager sm = context.getStatusManager();\r\n    if (sm == null)\r\n        return false;\r\n    List<StatusListener> listeners = sm.getCopyOfStatusListenerList();\r\n    if (listeners == null || listeners.size() == 0)\r\n        return false;\r\n    else\r\n        return true;\r\n}"
}, {
	"Path": "org.lenskit.config.ConfigHelpers.load",
	"Comment": "load a lenskit configuration from a groovy closure.this is useful for using the groovydsl in unit tests.",
	"Method": "LenskitConfiguration load(Closure<?> block,LenskitConfiguration load,String script,LenskitConfiguration load,File script,LenskitConfiguration load,URL script){\r\n    return new ConfigurationLoader().load(script);\r\n}"
}, {
	"Path": "ch.qos.logback.core.rolling.helper.RenameUtil.areOnDifferentVolumes",
	"Comment": "attempts tp determine whether both files are on different volumes. returns true if we could determine thatthe files are on different volumes. returns false otherwise or if an error occurred while doing the check.",
	"Method": "Boolean areOnDifferentVolumes(File srcFile,File targetFile){\r\n    if (!EnvUtil.isJDK7OrHigher()) {\r\n        return false;\r\n    }\r\n    File parentOfTarget = targetFile.getAbsoluteFile().getParentFile();\r\n    if (parentOfTarget == null) {\r\n        addWarn(\"Parent of target file [\" + targetFile + \"] is null\");\r\n        return null;\r\n    }\r\n    if (!parentOfTarget.exists()) {\r\n        addWarn(\"Parent of target file [\" + targetFile + \"] does not exist\");\r\n        return null;\r\n    }\r\n    try {\r\n        boolean onSameFileStore = FileStoreUtil.areOnSameFileStore(srcFile, parentOfTarget);\r\n        return !onSameFileStore;\r\n    } catch (RolloverFailure rf) {\r\n        addWarn(\"Error while checking file store equality\", rf);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "ch.qos.logback.core.net.DefaultSocketConnector.call",
	"Comment": "loops until the desired connection is established and returns the resulting connector.",
	"Method": "Socket call(){\r\n    useDefaultsForMissingFields();\r\n    Socket socket = createSocket();\r\n    while (socket == null && !Thread.currentThread().isInterrupted()) {\r\n        Thread.sleep(delayStrategy.nextDelay());\r\n        socket = createSocket();\r\n    }\r\n    return socket;\r\n}"
}, {
	"Path": "ch.qos.logback.classic.Logger.detachAppender",
	"Comment": "remove the appender passed as parameter form the list of appenders.",
	"Method": "boolean detachAppender(String name,boolean detachAppender,Appender<ILoggingEvent> appender){\r\n    if (aai == null) {\r\n        return false;\r\n    }\r\n    return aai.detachAppender(appender);\r\n}"
}, {
	"Path": "ch.qos.logback.core.sift.SiftingAppenderBase.setAppenderFactory",
	"Comment": "this setter is intended to be invoked by siftaction. customers have no reason to invokethis method directly.",
	"Method": "void setAppenderFactory(AppenderFactory<E> appenderFactory){\r\n    this.appenderFactory = appenderFactory;\r\n}"
}]