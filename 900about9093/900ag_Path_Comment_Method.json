[{
	"Path": "org.mage.test.cards.watchers.DiesExiledTest.testKumanoMasterYamabushi",
	"Comment": "test that when creature damaged by kumano, master yamabushi dies it is exiled",
	"Method": "void testKumanoMasterYamabushi(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Kumano, Master Yamabushi\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Sejiri Merfolk\");\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"{1}{R}: {source} deals 1 damage to \", \"Sejiri Merfolk\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerB, \"Sejiri Merfolk\", 0);\r\n    assertExileCount(\"Sejiri Merfolk\", 1);\r\n}"
}, {
	"Path": "cc.mallet.types.RankedFeatureVector.setReverseRankOrder",
	"Comment": "added by limin yao, rank the elements ascendingly, the smaller is in the front",
	"Method": "void setReverseRankOrder(int extent,boolean reset){\r\n    int sortExtent;\r\n    sortExtent = (extent >= values.length) ? values.length - 1 : extent;\r\n    if (sortedTo == SORTINIT || reset) {\r\n        this.rankOrder = new int[values.length];\r\n        for (int i = 0; i < rankOrder.length; i++) {\r\n            rankOrder[i] = i;\r\n            assert (!Double.isNaN(values[i]));\r\n        }\r\n    }\r\n    for (int i = sortedTo + 1; i <= sortExtent; i++) {\r\n        double min = values[rankOrder[i]];\r\n        int minIndex = i;\r\n        for (int j = i + 1; j < rankOrder.length; j++) {\r\n            if (values[rankOrder[j]] < min) {\r\n                min = values[rankOrder[j]];\r\n                minIndex = j;\r\n            }\r\n        }\r\n        int r = rankOrder[minIndex];\r\n        rankOrder[minIndex] = rankOrder[i];\r\n        rankOrder[i] = r;\r\n        sortedTo = i;\r\n    }\r\n}"
}, {
	"Path": "cc.mallet.classify.MaxEntOptimizableByLabelLikelihood.setGaussianPriorVariance",
	"Comment": "sets a parameter to prevent overtraining.a smaller variance for the prior\tmeans that feature weights are expected to hover closer to 0, so extra\tevidence is required to set a higher weight.",
	"Method": "MaxEntOptimizableByLabelLikelihood setGaussianPriorVariance(double gaussianPriorVariance){\r\n    this.usingGaussianPrior = true;\r\n    this.usingHyperbolicPrior = false;\r\n    this.gaussianPriorVariance = gaussianPriorVariance;\r\n    return this;\r\n}"
}, {
	"Path": "cc.mallet.util.DBInstanceStore.byteArrayToIntArray",
	"Comment": "convert an array of bytes to an array of integers by copying the bits directly. based on code at java2s.com.",
	"Method": "int[] byteArrayToIntArray(byte[] src){\r\n    int dstLength = src.length >>> 2;\r\n    int[] dst = new int[dstLength];\r\n    for (int i = 0; i < dstLength; i++) {\r\n        int j = i << 2;\r\n        int x = 0;\r\n        x += (src[j++] & 0xff) << 0;\r\n        x += (src[j++] & 0xff) << 8;\r\n        x += (src[j++] & 0xff) << 16;\r\n        x += (src[j++] & 0xff) << 24;\r\n        dst[i] = x;\r\n    }\r\n    return dst;\r\n}"
}, {
	"Path": "cc.mallet.fst.Transducer.transduce",
	"Comment": "converts the given sequence into another sequence according to this transducer.\t for exmaple, probabilistic transducer may do something like viterbi here.\t subclasses of transducer may specify that they only accept special kinds of sequence.",
	"Method": "Instance transduce(Instance instance,Sequence transduce,Sequence input){\r\n    return maxLatticeFactory.newMaxLattice(this, (Sequence) input).bestOutputSequence();\r\n}"
}, {
	"Path": "cc.mallet.types.FeatureSelection.createFromRegex",
	"Comment": "creates a featureselection that includes only those features whose names match a given regex.a static factory method.",
	"Method": "FeatureSelection createFromRegex(Alphabet dictionary,Pattern regex){\r\n    BitSet included = new BitSet(dictionary.size());\r\n    for (int i = 0; i < dictionary.size(); i++) {\r\n        String feature = (String) dictionary.lookupObject(i);\r\n        if (regex.matcher(feature).matches()) {\r\n            included.set(i);\r\n        }\r\n    }\r\n    return new FeatureSelection(dictionary, included);\r\n}"
}, {
	"Path": "org.mage.test.cards.facedown.ObscuringAetherTest.testTurnFaceDown",
	"Comment": "test that cards exiled using ghastly conscription return face down",
	"Method": "void testTurnFaceDown(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 3);\r\n    addCard(Zone.HAND, playerA, \"Obscuring Aether\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Obscuring Aether\");\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"{1}{G}: Turn\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertHandCount(playerA, \"Obscuring Aether\", 0);\r\n    assertGraveyardCount(playerA, \"Obscuring Aether\", 0);\r\n    assertPermanentCount(playerA, EmptyNames.FACE_DOWN_CREATURE.toString(), 1);\r\n    assertPowerToughness(playerA, EmptyNames.FACE_DOWN_CREATURE.toString(), 2, 2);\r\n}"
}, {
	"Path": "cc.mallet.types.BiNormalSeparation.calculateWeights",
	"Comment": "calculates feature weights for features in the given instance list.",
	"Method": "double[] calculateWeights(InstanceList instanceList){\r\n    int numFeatures = instanceList.getAlphabet().size();\r\n    double[] weights = new double[numFeatures];\r\n    double[] truePositives = new double[numFeatures];\r\n    double[] falsePositives = new double[numFeatures];\r\n    double numPos = 0;\r\n    double numNeg = 0;\r\n    Label posLabel = null;\r\n    for (Instance instance : instanceList) {\r\n        if (posLabel == null)\r\n            posLabel = (Label) instance.getTarget();\r\n        boolean isPos = false;\r\n        if (posLabel.equals(instance.getTarget())) {\r\n            isPos = true;\r\n            numPos++;\r\n        } else {\r\n            numNeg++;\r\n        }\r\n        FeatureVector fv = (FeatureVector) instance.getData();\r\n        for (int index : fv.getIndices()) {\r\n            if (isPos)\r\n                truePositives[index]++;\r\n            else\r\n                falsePositives[index]++;\r\n        }\r\n    }\r\n    for (int i = 0; i < numFeatures; i++) {\r\n        double tpr = 0.5;\r\n        if (numPos > 0) {\r\n            tpr = Math.max(Math.min(BNS_MAX_RATE, truePositives[i] / numPos), BNS_MIN_RATE);\r\n        }\r\n        double fpr = 0.5;\r\n        if (numNeg > 0) {\r\n            fpr = Math.max(Math.min(BNS_MAX_RATE, falsePositives[i] / numNeg), BNS_MIN_RATE);\r\n        }\r\n        weights[i] = Math.abs(StatFunctions.qnorm(tpr, false) - StatFunctions.qnorm(fpr, false));\r\n    }\r\n    return weights;\r\n}"
}, {
	"Path": "cc.mallet.fst.CRFOptimizableByBatchLabelLikelihood.getBatchValue",
	"Comment": "returns the log probability of a batch of training sequence labels and the prior over\tparameters, if last batch then incorporate the prior on parameters as well.",
	"Method": "double getBatchValue(int batchIndex,int[] batchAssignments){\r\n    assert (batchIndex < this.numBatches) : \"Incorrect batch index: \" + batchIndex + \", range(0, \" + this.numBatches + \")\";\r\n    assert (batchAssignments.length == 2 && batchAssignments[0] <= batchAssignments[1]) : \"Invalid batch assignments: \" + Arrays.toString(batchAssignments);\r\n    double value = getExpectationValue(batchIndex, batchAssignments);\r\n    if (batchIndex == numBatches - 1) {\r\n        if (usingHyperbolicPrior)\r\n            value += crf.parameters.hyberbolicPrior(hyperbolicPriorSlope, hyperbolicPriorSharpness);\r\n        else\r\n            value += crf.parameters.gaussianPrior(gaussianPriorVariance);\r\n    }\r\n    assert (!(Double.isNaN(value) || Double.isInfinite(value))) : \"Label likelihood is NaN/Infinite, batchIndex: \" + batchIndex + \"batchAssignments: \" + Arrays.toString(batchAssignments);\r\n    cachedValue[batchIndex] = value;\r\n    return value;\r\n}"
}, {
	"Path": "cc.mallet.types.SparseVector.arrayCopyInto",
	"Comment": "copy the contents of this vector into an array starting at a particular location.",
	"Method": "int arrayCopyInto(double[] array,int startingArrayLocation){\r\n    System.arraycopy(values, 0, array, startingArrayLocation, values.length);\r\n    return startingArrayLocation + values.length;\r\n}"
}, {
	"Path": "org.mage.test.cards.watchers.BoseijuTest.testCanCounter",
	"Comment": "test that instants and soceries can be countered when boseiju mana is not used",
	"Method": "void testCanCounter(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 6);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Boseiju, Who Shelters All\");\r\n    addCard(Zone.HAND, playerA, \"Mental Note\");\r\n    addCard(Zone.HAND, playerA, \"Counterspell\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Mental Note\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Counterspell\", \"Mental Note\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    this.assertHandCount(playerA, 0);\r\n    this.assertGraveyardCount(playerA, 2);\r\n}"
}, {
	"Path": "cc.mallet.share.upenn.MaxEntShell.test",
	"Comment": "test a maxent classifier. the data representation is the same as\tfor training.",
	"Method": "double test(Classifier classifier,String[][] features,String[] labels,double test,Classifier classifier,Iterator<Instance> data){\r\n    InstanceList testList = new InstanceList(classifier.getInstancePipe());\r\n    testList.addThruPipe(data);\r\n    logger.info(\"# test instances = \" + testList.size());\r\n    double accuracy = classifier.getAccuracy(testList);\r\n    return accuracy;\r\n}"
}, {
	"Path": "org.mage.test.multiplayer.CreepingDreadTest.basicTest",
	"Comment": "discard creature and all opponents who discard creature lose 3 life",
	"Method": "void basicTest(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Creeping Dread\");\r\n    addCard(Zone.HAND, playerA, \"Merfolk Looter\");\r\n    addCard(Zone.HAND, playerB, \"Hill Giant\");\r\n    addCard(Zone.HAND, playerC, \"Elite Vanguard\");\r\n    addCard(Zone.HAND, playerD, \"Bone Saw\");\r\n    setChoice(playerA, \"Merfolk Looter\");\r\n    setChoice(playerB, \"Hill Giant\");\r\n    setChoice(playerC, \"Elite Vanguard\");\r\n    setChoice(playerD, \"Bone Saw\");\r\n    setStopAt(1, PhaseStep.DRAW);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Merfolk Looter\", 1);\r\n    assertGraveyardCount(playerB, \"Hill Giant\", 1);\r\n    assertGraveyardCount(playerC, \"Elite Vanguard\", 1);\r\n    assertGraveyardCount(playerD, \"Bone Saw\", 1);\r\n    assertLife(playerA, 40);\r\n    assertLife(playerB, 37);\r\n    assertLife(playerC, 37);\r\n    assertLife(playerD, 40);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.add.AddAbilitiesToNonPermanentsTest.testSearchForCardWithFlashInLibrary",
	"Comment": "with teferi, mage of zhalfir on the battlefield it has to be possible to search for a god of storms in the deck by using mystical teachings.",
	"Method": "void testSearchForCardWithFlashInLibrary(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Teferi, Mage of Zhalfir\");\r\n    addCard(Zone.HAND, playerA, \"Mystical Teachings\");\r\n    addCard(Zone.LIBRARY, playerA, \"Keranos, God of Storms\");\r\n    addCard(Zone.LIBRARY, playerA, \"Plains\", 3);\r\n    skipInitShuffling();\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Mystical Teachings\");\r\n    addTarget(playerA, \"Keranos, God of Storms\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerA, \"Mystical Teachings\", 1);\r\n    assertHandCount(playerA, \"Keranos, God of Storms\", 1);\r\n}"
}, {
	"Path": "org.mage.test.multiplayer.CreepingDreadTest.twoTypesTest",
	"Comment": "discard artifact creature and all opponents who discard either an artifact or creature lose 3 life",
	"Method": "void twoTypesTest(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Creeping Dread\");\r\n    addCard(Zone.HAND, playerA, \"Bronze Sable\");\r\n    addCard(Zone.HAND, playerB, \"Hill Giant\");\r\n    addCard(Zone.HAND, playerC, \"Swamp\");\r\n    addCard(Zone.HAND, playerD, \"Bone Saw\");\r\n    setChoice(playerA, \"Bronze Sable\");\r\n    setChoice(playerB, \"Hill Giant\");\r\n    setChoice(playerC, \"Swamp\");\r\n    setChoice(playerD, \"Bone Saw\");\r\n    setStopAt(1, PhaseStep.DRAW);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Bronze Sable\", 1);\r\n    assertGraveyardCount(playerB, \"Hill Giant\", 1);\r\n    assertGraveyardCount(playerC, \"Swamp\", 1);\r\n    assertGraveyardCount(playerD, \"Bone Saw\", 1);\r\n    assertLife(playerA, 40);\r\n    assertLife(playerB, 37);\r\n    assertLife(playerC, 40);\r\n    assertLife(playerD, 37);\r\n}"
}, {
	"Path": "cc.mallet.fst.confidence.ConfidenceCorrectorEvaluator.containsErrorInUncorrectedSegments",
	"Comment": "returns true if predsequence contains errors outside of correctedsegment.",
	"Method": "boolean containsErrorInUncorrectedSegments(Sequence trueSequence,Sequence predSequence,Sequence correctedSequence,Segment correctedSegment){\r\n    for (int i = 0; i < trueSequence.size(); i++) {\r\n        if (correctedSegment.indexInSegment(i)) {\r\n            if (!correctedSequence.get(i).equals(trueSequence.get(i))) {\r\n                System.err.println(\"\\nTruth: \");\r\n                for (int j = 0; j < trueSequence.size(); j++) System.err.print(trueSequence.get(j) + \" \");\r\n                System.err.println(\"\\nPredicted: \");\r\n                for (int j = 0; j < trueSequence.size(); j++) System.err.print(predSequence.get(j) + \" \");\r\n                System.err.println(\"\\nCorrected: \");\r\n                for (int j = 0; j < trueSequence.size(); j++) System.err.print(correctedSequence.get(j) + \" \");\r\n                throw new IllegalStateException(\"Corrected sequence does not have correct labels for corrected segment: \" + correctedSegment);\r\n            }\r\n        } else {\r\n            if (!predSequence.get(i).equals(trueSequence.get(i)))\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.FlashbackTest.testSnapcasterMageSpellWithAlternateCost",
	"Comment": "i can play force of will with flashback paying his alternative mana cost.the ruling say no to it, because we only can choose one alternative costto a spell, and the flashback cost is already an alternative cost.",
	"Method": "void testSnapcasterMageSpellWithAlternateCost(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 1);\r\n    addCard(Zone.HAND, playerA, \"Snapcaster Mage\", 2);\r\n    addCard(Zone.GRAVEYARD, playerA, \"Force of Will\");\r\n    addCard(Zone.HAND, playerB, \"Lightning Bolt\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mountain\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Snapcaster Mage\");\r\n    addTarget(playerA, \"Force of Will\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerB, \"Lightning Bolt\", \"Snapcaster Mage\");\r\n    activateAbility(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Flashback\", null, \"Lightning Bolt\");\r\n    addTarget(playerA, \"Lightning Bolt\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Snapcaster Mage\", 0);\r\n    assertGraveyardCount(playerA, \"Snapcaster Mage\", 1);\r\n    assertGraveyardCount(playerA, \"Force of Will\", 1);\r\n    assertGraveyardCount(playerB, \"Lightning Bolt\", 1);\r\n    assertLife(playerA, 20);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.oneshot.counterspell.CounterbalanceTest.testCommand",
	"Comment": "test that x mana costs from spells are taken into account to calculate the converted mana costsof stack objects",
	"Method": "void testCommand(){\r\n    addCard(Zone.HAND, playerA, \"Death Grasp\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Counterbalance\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    addCard(Zone.LIBRARY, playerB, \"Desert Twister\");\r\n    skipInitShuffling();\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Death Grasp\", \"targetPlayer=PlayerB\");\r\n    setChoice(playerA, \"X=4\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerA, \"Death Grasp\", 1);\r\n    assertGraveyardCount(playerA, 1);\r\n    assertGraveyardCount(playerB, 0);\r\n}"
}, {
	"Path": "cc.mallet.classify.AdaBoostTrainer.train",
	"Comment": "boosting method that resamples instances using their weights",
	"Method": "AdaBoost train(InstanceList trainingList){\r\n    FeatureSelection selectedFeatures = trainingList.getFeatureSelection();\r\n    if (selectedFeatures != null)\r\n        throw new UnsupportedOperationException(\"FeatureSelection not yet implemented.\");\r\n    java.util.Random random = new java.util.Random();\r\n    double w = 1.0 / trainingList.size();\r\n    InstanceList trainingInsts = new InstanceList(trainingList.getPipe(), trainingList.size());\r\n    for (int i = 0; i < trainingList.size(); i++) trainingInsts.add(trainingList.get(i), w);\r\n    boolean[] correct = new boolean[trainingInsts.size()];\r\n    int numClasses = trainingInsts.getTargetAlphabet().size();\r\n    if (numClasses != 2)\r\n        logger.info(\"AdaBoostTrainer.train: WARNING: more than two classes\");\r\n    Classifier[] weakLearners = new Classifier[numRounds];\r\n    double[] alphas = new double[numRounds];\r\n    InstanceList roundTrainingInsts = new InstanceList(trainingInsts.getPipe());\r\n    for (int round = 0; round < numRounds; round++) {\r\n        logger.info(\"===========  AdaBoostTrainer round \" + (round + 1) + \" begin\");\r\n        int resamplingIterations = 0;\r\n        double err;\r\n        do {\r\n            err = 0;\r\n            roundTrainingInsts = trainingInsts.sampleWithInstanceWeights(random);\r\n            weakLearners[round] = weakLearner.train(roundTrainingInsts);\r\n            for (int i = 0; i < trainingInsts.size(); i++) {\r\n                Instance inst = trainingInsts.get(i);\r\n                if (weakLearners[round].classify(inst).bestLabelIsCorrect())\r\n                    correct[i] = true;\r\n                else {\r\n                    correct[i] = false;\r\n                    err += trainingInsts.getInstanceWeight(i);\r\n                }\r\n            }\r\n            resamplingIterations++;\r\n        } while (Maths.almostEquals(err, 0) && resamplingIterations < MAX_NUM_RESAMPLING_ITERATIONS);\r\n        if (Maths.almostEquals(err, 0) || err > 0.5) {\r\n            logger.info(\"AdaBoostTrainer stopped at \" + (round + 1) + \" / \" + numRounds + \" rounds: numClasses=\" + numClasses + \" error=\" + err);\r\n            int numClassifiersToUse = (round == 0) ? 1 : round;\r\n            if (round == 0)\r\n                alphas[0] = 1;\r\n            double[] betas = new double[numClassifiersToUse];\r\n            Classifier[] weakClassifiers = new Classifier[numClassifiersToUse];\r\n            System.arraycopy(alphas, 0, betas, 0, numClassifiersToUse);\r\n            System.arraycopy(weakLearners, 0, weakClassifiers, 0, numClassifiersToUse);\r\n            for (int i = 0; i < betas.length; i++) logger.info(\"AdaBoostTrainer weight[weakLearner[\" + i + \"]]=\" + betas[i]);\r\n            return new AdaBoost(roundTrainingInsts.getPipe(), weakClassifiers, betas);\r\n        }\r\n        alphas[round] = Math.log((1 - err) / err);\r\n        double reweightFactor = err / (1 - err);\r\n        double sum = 0;\r\n        for (int i = 0; i < trainingInsts.size(); i++) {\r\n            w = trainingInsts.getInstanceWeight(i);\r\n            if (correct[i])\r\n                w *= reweightFactor;\r\n            trainingInsts.setInstanceWeight(i, w);\r\n            sum += w;\r\n        }\r\n        for (int i = 0; i < trainingInsts.size(); i++) {\r\n            trainingInsts.setInstanceWeight(i, trainingInsts.getInstanceWeight(i) / sum);\r\n        }\r\n        logger.info(\"===========  AdaBoostTrainer round \" + (round + 1) + \" finished, weak classifier training error = \" + err);\r\n    }\r\n    for (int i = 0; i < alphas.length; i++) logger.info(\"AdaBoostTrainer weight[weakLearner[\" + i + \"]]=\" + alphas[i]);\r\n    this.classifier = new AdaBoost(roundTrainingInsts.getPipe(), weakLearners, alphas);\r\n    return classifier;\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.TuvasaTheSunlitTest.testWithStriveSpell",
	"Comment": "playing more than one enchantment spell in a single turn does not draw more than 1 additional card.",
	"Method": "void testWithStriveSpell(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Tuvasa the Sunlit\", 1);\r\n    addCard(Zone.HAND, playerA, \"Burgeoning\", 1);\r\n    addCard(Zone.HAND, playerA, \"Ajani's Welcome\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Burgeoning\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Ajani's Welcome\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertHandCount(playerA, 1);\r\n}"
}, {
	"Path": "cc.mallet.cluster.GreedyAgglomerative.reset",
	"Comment": "reset convergence to false so a new round of clustering can begin.",
	"Method": "void reset(){\r\n    converged = false;\r\n    scoreCache = null;\r\n    evaluator.reset();\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.state.PhyrexianDevourerTest.testBoostChecked",
	"Comment": "check that phyrexian devourer is sacrifriced as soon as the counters areadded",
	"Method": "void testBoostChecked(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Phyrexian Devourer\");\r\n    addCard(Zone.LIBRARY, playerA, \"Phyrexian Devourer\");\r\n    skipInitShuffling();\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\");\r\n    attack(2, playerB, \"Silvercoat Lion\");\r\n    block(2, playerA, \"Phyrexian Devourer\", \"Silvercoat Lion\");\r\n    activateAbility(2, PhaseStep.DECLARE_BLOCKERS, playerA, \"Exile the top card of your library\");\r\n    setStopAt(2, PhaseStep.POSTCOMBAT_MAIN);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Phyrexian Devourer\", 1);\r\n    assertExileCount(\"Phyrexian Devourer\", 1);\r\n    assertPermanentCount(playerB, \"Silvercoat Lion\", 1);\r\n}"
}, {
	"Path": "cc.mallet.cluster.Clustering.getClusters",
	"Comment": "returns an array of instance lists corresponding to clusters.",
	"Method": "InstanceList[] getClusters(){\r\n    InstanceList[] clusters = new InstanceList[numLabels];\r\n    for (int c = 0; c < numLabels; c++) clusters[c] = getCluster(c);\r\n    return clusters;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.SuspendTest.testDelay",
	"Comment": "tests that a spell countered with delay goes to exile with 3 timecounters and can be cast after the 3 counters are removed",
	"Method": "void testDelay(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 2);\r\n    addCard(Zone.HAND, playerA, \"Silvercoat Lion\", 1);\r\n    addCard(Zone.HAND, playerB, \"Delay\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Silvercoat Lion\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Delay\", \"Silvercoat Lion\");\r\n    setChoice(playerA, \"Silvercoat Lion\");\r\n    setStopAt(7, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerB, \"Delay\", 1);\r\n    assertPermanentCount(playerA, \"Silvercoat Lion\", 1);\r\n}"
}, {
	"Path": "cc.mallet.optimize.StochasticMetaAscent.computeHessianProduct",
	"Comment": "compute finite difference approximation of the hessian product",
	"Method": "void computeHessianProduct(Optimizable.ByBatchGradient maxable,double[] parameters,int batchIndex,int[] batchAssignments,double[] currentGradient,double[] vector,double[] result){\r\n    int numParameters = maxable.getNumParameters();\r\n    double eps = 1.0e-6;\r\n    double[] epsGradient = new double[numParameters];\r\n    double[] oldParameters = new double[numParameters];\r\n    System.arraycopy(parameters, 0, oldParameters, 0, numParameters);\r\n    MatrixOps.plusEquals(parameters, vector, eps);\r\n    maxable.setParameters(parameters);\r\n    maxable.getBatchValueGradient(epsGradient, batchIndex, batchAssignments);\r\n    maxable.setParameters(oldParameters);\r\n    for (int index = 0; index < result.length; index++) {\r\n        result[index] = (-epsGradient[index] - currentGradient[index]) / eps;\r\n    }\r\n}"
}, {
	"Path": "org.mage.test.cards.single.avr.CavernOfSoulsTest.testUseWithConversionInPlay",
	"Comment": "cavern of souls can produce any colour of mana with its second abilitywhen contamination is in play.",
	"Method": "void testUseWithConversionInPlay(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 3);\r\n    addCard(Zone.HAND, playerA, \"Cavern of Souls\");\r\n    addCard(Zone.HAND, playerA, \"Desert Drake\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Contamination\", 1);\r\n    playLand(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Cavern of Souls\");\r\n    setChoice(playerA, \"Drake\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Desert Drake\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Cavern of Souls\", 1);\r\n    assertPermanentCount(playerA, \"Desert Drake\", 0);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.MorphTest.testExileFaceDownCreature",
	"Comment": "check if a face down morph creature gets exiled, it will be face up inexile zone.",
	"Method": "void testExileFaceDownCreature(){\r\n    addCard(Zone.HAND, playerA, \"Birchlore Rangers\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 3);\r\n    addCard(Zone.HAND, playerB, \"Swords to Plowshares\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Birchlore Rangers\");\r\n    setChoice(playerA, \"Yes\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Swords to Plowshares\", \"\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 22);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerB, \"Swords to Plowshares\", 1);\r\n    assertExileCount(\"Birchlore Rangers\", 1);\r\n    for (Card card : currentGame.getExile().getAllCards(currentGame)) {\r\n        if (card.getName().equals(\"Birchlore Rangers\")) {\r\n            Assert.assertEquals(\"Birchlore Rangers has to be face up in exile\", false, card.isFaceDown(currentGame));\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mage.test.cards.copy.FlameshadowConjuringTest.testWurmcoilEngine",
	"Comment": "i created a token copy of wurmcoil engine and sacrificed it. this gave me4 tokens",
	"Method": "void testWurmcoilEngine(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 7);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Flameshadow Conjuring\", 1);\r\n    addCard(Zone.HAND, playerA, \"Wurmcoil Engine\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 3);\r\n    addCard(Zone.HAND, playerB, \"Kill Shot\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Wurmcoil Engine\");\r\n    setChoice(playerA, \"Yes\");\r\n    attack(1, playerA, \"Wurmcoil Engine\");\r\n    castSpell(1, PhaseStep.END_COMBAT, playerB, \"Kill Shot\", \"Wurmcoil Engine\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertGraveyardCount(playerB, \"Kill Shot\", 1);\r\n    assertPermanentCount(playerA, \"Wurmcoil Engine\", 1);\r\n    assertLife(playerB, 14);\r\n    assertLife(playerA, 26);\r\n    assertPermanentCount(playerA, \"Wurm\", 2);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.RenownTest.testRenownGoneAfterZoneChange",
	"Comment": "test renown is gone after zone changetest renown is gone after zone change",
	"Method": "void testRenownGoneAfterZoneChange(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 6);\r\n    addCard(Zone.HAND, playerA, \"Rhox Maulers\");\r\n    addCard(Zone.HAND, playerA, \"Cloudshift\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Rhox Maulers\");\r\n    castSpell(5, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Cloudshift\", \"Rhox Maulers\");\r\n    attack(3, playerA, \"Rhox Maulers\");\r\n    attack(5, playerA, \"Rhox Maulers\");\r\n    attack(7, playerA, \"Rhox Maulers\");\r\n    setStopAt(7, PhaseStep.POSTCOMBAT_MAIN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 6);\r\n    assertPowerToughness(playerA, \"Rhox Maulers\", 6, 6);\r\n    Permanent rhoxMaulers = getPermanent(\"Rhox Maulers\", playerA);\r\n    Assert.assertEquals(\"may not be renown\", true, rhoxMaulers.isRenowned());\r\n}"
}, {
	"Path": "org.mage.test.cards.copy.ArtisanOfFormsTest.testCopyTriggeredByPopulate",
	"Comment": "targeting a artisan of forms triggers it heroic ability. so it can copy atarget creature. if populate spell later resolves, it should copy thecreature that artisan of forms copies, not the artisan itself.",
	"Method": "void testCopyTriggeredByPopulate(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Artisan of Forms\");\r\n    addCard(Zone.HAND, playerA, \"Cackling Counterpart\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 3);\r\n    addCard(Zone.HAND, playerA, \"Eyes in the Skies\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Cackling Counterpart\", \"Artisan of Forms\");\r\n    addTarget(playerA, \"Silvercoat Lion\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Eyes in the Skies\");\r\n    addTarget(playerA, \"Silvercoat Lion\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerA, \"Cackling Counterpart\", 1);\r\n    assertPermanentCount(playerA, \"Artisan of Forms\", 0);\r\n    assertPermanentCount(playerB, \"Silvercoat Lion\", 1);\r\n    assertPermanentCount(playerA, \"Bird\", 1);\r\n    assertPermanentCount(playerA, \"Silvercoat Lion\", 3);\r\n    for (Permanent permanent : currentGame.getBattlefield().getAllActivePermanents(playerA.getId())) {\r\n        if (permanent.getName().equals(\"Silvercoat Lion\")) {\r\n            Assert.assertEquals(\"Creature has to have Cast + Heroic ability\", 2, permanent.getAbilities().size());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.equipped.ScytheOfTheWretchedTest.testEquipDied",
	"Comment": "test that the creature that died returns to battlefield under yourcontrol if the previous equiped creature does die after equipment isremoved",
	"Method": "void testEquipDied(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Oreskos Swiftclaw\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Scythe of the Wretched\");\r\n    activateAbility(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Equip {4}\", \"Silvercoat Lion\");\r\n    attack(2, playerB, \"Silvercoat Lion\");\r\n    block(2, playerA, \"Oreskos Swiftclaw\", \"Silvercoat Lion\");\r\n    setStopAt(2, PhaseStep.POSTCOMBAT_MAIN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerA, \"Oreskos Swiftclaw\", 0);\r\n    assertPermanentCount(playerB, \"Oreskos Swiftclaw\", 1);\r\n    assertPowerToughness(playerB, \"Oreskos Swiftclaw\", 5, 3);\r\n    assertGraveyardCount(playerB, \"Silvercoat Lion\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.oneshot.counterspell.DisruptingShoalTest.testWithBlueCardsInHand",
	"Comment": "test that disrupting shoal can be played with alternate casting costs andthe x value is equal to the cmc of the exiled blue card",
	"Method": "void testWithBlueCardsInHand(){\r\n    addCard(Zone.HAND, playerA, \"Pillarfield Ox\");\r\n    addCard(Zone.HAND, playerA, \"Spell Snare\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 4);\r\n    addCard(Zone.HAND, playerB, \"Disrupting Shoal\");\r\n    addCard(Zone.HAND, playerB, \"Mistfire Adept\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Pillarfield Ox\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Disrupting Shoal\", \"Pillarfield Ox\", \"Pillarfield Ox\");\r\n    playerB.addChoice(\"Yes\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Spell Snare\", \"Disrupting Shoal\", \"Disrupting Shoal\");\r\n    setStopAt(1, PhaseStep.CLEANUP);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerB, \"Disrupting Shoal\", 1);\r\n    assertExileCount(playerB, 1);\r\n    assertHandCount(playerB, \"Mistfire Adept\", 1);\r\n    assertHandCount(playerA, \"Spell Snare\", 1);\r\n    assertGraveyardCount(playerA, \"Pillarfield Ox\", 1);\r\n}"
}, {
	"Path": "org.mage.test.serverside.base.impl.CardTestPlayerAPIImpl.getCardList",
	"Comment": "returns card list container for specified game zone and player.",
	"Method": "List<Card> getCardList(Zone gameZone,TestPlayer player){\r\n    switch(gameZone) {\r\n        case HAND:\r\n            return getHandCards(player);\r\n        case GRAVEYARD:\r\n            return getGraveCards(player);\r\n        case LIBRARY:\r\n            return getLibraryCards(player);\r\n        default:\r\n            break;\r\n    }\r\n    throw new AssertionError(\"Zone is not supported by test framework: \" + gameZone);\r\n}"
}, {
	"Path": "cc.mallet.fst.CRFTrainerByThreadedLabelLikelihood.setAddNoFactors",
	"Comment": "use this method to specify whether or not factors\tare added to the crf by this trainer.if you have\talready setup the factors in your crf, you may\tnot want the trainer to add additional factors.",
	"Method": "void setAddNoFactors(boolean flag){\r\n    this.useNoWeights = flag;\r\n}"
}, {
	"Path": "cc.mallet.types.PagedInstanceList.shuffleArray",
	"Comment": "shuffles elements of an array, taken from collections.shuffle",
	"Method": "void shuffleArray(java.util.Random r,int[] a){\r\n    int size = a.length;\r\n    for (int i = size - 1; i > 0; i--) {\r\n        int swap = r.nextInt(i + 1);\r\n        int tmp = a[i];\r\n        a[i] = a[swap];\r\n        a[swap] = tmp;\r\n    }\r\n}"
}, {
	"Path": "cc.mallet.classify.MaxEntTrainer.setL1Weight",
	"Comment": "use an l1 prior. larger values mean parameters will be closer to 0.\tnote that this setting overrides any gaussian prior.",
	"Method": "MaxEntTrainer setL1Weight(double l1Weight){\r\n    this.l1Weight = l1Weight;\r\n    return this;\r\n}"
}, {
	"Path": "cc.mallet.share.upenn.ner.ListMember.countTokens",
	"Comment": "this method must count tokens the same way as the main tokenizer does!",
	"Method": "int countTokens(String s){\r\n    StringTokenizer wordst = new StringTokenizer(s, \"~`!@#$%^&*()_-+={[}]|\\\\:;\\\"',<.>?/ \\t\\n\\r\", true);\r\n    return wordst.countTokens();\r\n}"
}, {
	"Path": "cc.mallet.topics.ParallelTopicModel.getTopicProbabilities",
	"Comment": "get the smoothed distribution over topics for a topic sequence, which may be from the training set or from a new instance with topicsassigned by an inferencer.",
	"Method": "double[] getTopicProbabilities(int instanceID,double[] getTopicProbabilities,LabelSequence topics){\r\n    double[] topicDistribution = new double[numTopics];\r\n    for (int position = 0; position < topics.getLength(); position++) {\r\n        topicDistribution[topics.getIndexAtPosition(position)]++;\r\n    }\r\n    double sum = 0.0;\r\n    for (int topic = 0; topic < numTopics; topic++) {\r\n        topicDistribution[topic] += alpha[topic];\r\n        sum += topicDistribution[topic];\r\n    }\r\n    for (int topic = 0; topic < numTopics; topic++) {\r\n        topicDistribution[topic] /= sum;\r\n    }\r\n    return topicDistribution;\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.DoublingSeasonTest.testDoubleTokens",
	"Comment": "tests that 2 saproling tokens are created instead of one if doublingseason is on the battlefield.",
	"Method": "void testDoubleTokens(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Doubling Season\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 4);\r\n    addCard(Zone.HAND, playerA, \"Pallid Mycoderm\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Pallid Mycoderm\");\r\n    activateAbility(5, PhaseStep.PRECOMBAT_MAIN, playerA, \"Remove three spore counters from {this}: Create a 1/1 green Saproling creature token.\");\r\n    setStopAt(5, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerA, \"Saproling\", 2);\r\n    assertCounterCount(\"Pallid Mycoderm\", CounterType.SPORE, 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.dies.BrainMaggotTest.testCardFromHandWillBeExiled",
	"Comment": "when brain maggot enters the battlefield, target opponent reveals his orher hand and you choose a nonland card from it. exile that card untilbrain maggot leaves the battlefield.",
	"Method": "void testCardFromHandWillBeExiled(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 2);\r\n    addCard(Zone.HAND, playerA, \"Brain Maggot\", 2);\r\n    addCard(Zone.HAND, playerB, \"Bloodflow Connoisseur\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Brain Maggot\");\r\n    addTarget(playerA, playerB);\r\n    setChoice(playerA, \"Bloodflow Connoisseur\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertAllCommandsUsed();\r\n    assertPermanentCount(playerA, \"Brain Maggot\", 1);\r\n    assertExileCount(\"Bloodflow Connoisseur\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.DryadMilitantTest.testDiesByDamage",
	"Comment": "tests if dryad militant dies by damage spell, thespell gets exiled",
	"Method": "void testDiesByDamage(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 1);\r\n    addCard(Zone.HAND, playerA, \"Lightning Bolt\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Dryad Militant\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Lightning Bolt\", \"Dryad Militant\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerB, 20);\r\n    assertExileCount(\"Lightning Bolt\", 1);\r\n}"
}, {
	"Path": "org.mage.test.commander.FFA3.PrimordialTest.DiluvianPrimordialTest",
	"Comment": "diluvian primordial etb trigger never happened in a 3 player ffacommander game. he just resolved, no etb trigger occurred.",
	"Method": "void DiluvianPrimordialTest(){\r\n    addCard(Zone.HAND, playerA, \"Diluvian Primordial\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 7);\r\n    addCard(Zone.GRAVEYARD, playerB, \"Lightning Bolt\");\r\n    addCard(Zone.GRAVEYARD, playerC, \"Lightning Bolt\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Diluvian Primordial\");\r\n    addTarget(playerA, \"Lightning Bolt\");\r\n    addTarget(playerA, \"Lightning Bolt\");\r\n    addTarget(playerA, playerB);\r\n    addTarget(playerA, playerC);\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Diluvian Primordial\", 1);\r\n    assertExileCount(\"Lightning Bolt\", 2);\r\n    assertLife(playerA, 40);\r\n    assertLife(playerB, 37);\r\n    assertLife(playerC, 37);\r\n}"
}, {
	"Path": "cc.mallet.optimize.tests.TestOptimizable.setNumComponents",
	"Comment": "sets the number of gradient components that will be checked.\tif negative, all will be checked.",
	"Method": "void setNumComponents(int n){\r\n    numComponents = n;\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.SkullbriarTest.testHumilityAndSkullbriarCloudshift",
	"Comment": "skullbriar should not retain counters when humility is on the field.",
	"Method": "void testHumilityAndSkullbriarCloudshift(){\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Skullbriar, the Walking Grave\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Humility\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Forest\");\r\n    addCard(Zone.HAND, playerB, \"Battlegrowth\");\r\n    addCard(Zone.HAND, playerB, \"Cloudshift\");\r\n    castSpell(1, PhaseStep.UPKEEP, playerB, \"Battlegrowth\", \"Skullbriar, the Walking Grave\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Cloudshift\", \"Skullbriar, the Walking Grave\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertCounterCount(\"Skullbriar, the Walking Grave\", CounterType.P1P1, 0);\r\n}"
}, {
	"Path": "org.mage.test.utils.ManaUtilTest.testManaAvailEnough",
	"Comment": "checks if the given available mana is enough to pay a given mana cost",
	"Method": "void testManaAvailEnough(String manaCostsToPay,int availablyAny,String available,boolean expected){\r\n    ManaCost unpaid = new ManaCostsImpl(manaCostsToPay);\r\n    ManaCost costAvailable = new ManaCostsImpl(available);\r\n    Mana manaAvailable = costAvailable.getMana();\r\n    manaAvailable.setAny(availablyAny);\r\n    if (expected) {\r\n        Assert.assertTrue(\"The available Mana \" + costAvailable.getText() + \" should be enough to pay the costs \" + unpaid.getText(), unpaid.getMana().enough(manaAvailable));\r\n    } else {\r\n        Assert.assertFalse(\"The available Mana \" + costAvailable.getText() + \" shouldn't be enough to pay the costs \" + unpaid.getText(), unpaid.getMana().enough(manaAvailable));\r\n    }\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.redirect.HarmsWayRedirectDamageTest.testRedirectTwoDamage",
	"Comment": "tests that 2 of 3 damage is redirected while 1 damage is still dealt tooriginal target",
	"Method": "void testRedirectTwoDamage(){\r\n    addCard(Zone.HAND, playerA, \"Lightning Bolt\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\");\r\n    addCard(Zone.HAND, playerB, \"Harm's Way\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Lightning Bolt\", playerB);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Harm's Way\", playerA);\r\n    setChoice(playerB, \"Lightning Bolt\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Lightning Bolt\", 1);\r\n    assertGraveyardCount(playerB, \"Harm's Way\", 1);\r\n    assertLife(playerA, 18);\r\n    assertLife(playerB, 19);\r\n}"
}, {
	"Path": "org.mage.test.combat.AttackPlaneswalkerTest.testAttackPlaneswalkerWithHexproof",
	"Comment": "tests that giving a planeswalker hexproof does not prevent opponent fromattacking it",
	"Method": "void testAttackPlaneswalkerWithHexproof(){\r\n    addCard(Zone.HAND, playerA, \"Simic Charm\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Kiora, the Crashing Wave\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Giant Tortoise\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerA, \"Simic Charm\");\r\n    setModeChoice(playerA, \"2\");\r\n    attack(2, playerB, \"Giant Tortoise\", \"Kiora, the Crashing Wave\");\r\n    setStopAt(2, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerA, \"Kiora, the Crashing Wave\", 1);\r\n    assertPermanentCount(playerB, \"Giant Tortoise\", 1);\r\n    assertCounterCount(\"Kiora, the Crashing Wave\", CounterType.LOYALTY, 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.copy.PhyrexianMetamorphTest.testHarmonicSliverNative1",
	"Comment": "if a harmonic sliver enters the battlefield the controller has to destroyone artifact or enchantment",
	"Method": "void testHarmonicSliverNative1(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 2);\r\n    addCard(Zone.HAND, playerA, \"Harmonic Sliver\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Alloy Myr\", 2);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Harmonic Sliver\");\r\n    setStopAt(1, PhaseStep.END_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Harmonic Sliver\", 1);\r\n    assertGraveyardCount(playerB, \"Alloy Myr\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.copy.PhyrexianMetamorphTest.testHarmonicSliverNative2",
	"Comment": "if a harmonic sliver enters the battlefield and there is already one onthe battlefield the controller has to destroy two artifacts orenchantments",
	"Method": "void testHarmonicSliverNative2(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 2);\r\n    addCard(Zone.HAND, playerA, \"Harmonic Sliver\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Alloy Myr\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Kitesail\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Harmonic Sliver\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Harmonic Sliver\");\r\n    addTarget(playerA, \"Alloy Myr\");\r\n    addTarget(playerA, \"Kitesail\");\r\n    setStopAt(1, PhaseStep.END_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Harmonic Sliver\", 1);\r\n    assertGraveyardCount(playerB, \"Alloy Myr\", 1);\r\n    assertGraveyardCount(playerB, \"Kitesail\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.other.NecromancyTest.testBlockWithNecromancyCreature",
	"Comment": "i was playing a legendary cube, flashed in a necromancy to block and whenthe creature i reanimated died the game bugged out and i lost.",
	"Method": "void testBlockWithNecromancyCreature(){\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 3);\r\n    addCard(Zone.HAND, playerA, \"Necromancy\");\r\n    addCard(Zone.GRAVEYARD, playerA, \"Silvercoat Lion\");\r\n    attack(2, playerB, \"Silvercoat Lion\");\r\n    castSpell(2, PhaseStep.DECLARE_ATTACKERS, playerA, \"Necromancy\");\r\n    block(2, playerA, \"Silvercoat Lion\", \"Silvercoat Lion\");\r\n    setStopAt(3, PhaseStep.END_TURN);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Necromancy\", 1);\r\n    assertGraveyardCount(playerA, \"Silvercoat Lion\", 1);\r\n    assertGraveyardCount(playerB, \"Silvercoat Lion\", 1);\r\n}"
}, {
	"Path": "cc.mallet.pipe.Pipe.instancesFrom",
	"Comment": "a convenience method that will pull all instances from source through this pipe, and return the results as an array.",
	"Method": "Instance[] instancesFrom(Iterator<Instance> source,Instance[] instancesFrom,Instance inst){\r\n    return instancesFrom(new SingleInstanceIterator(inst));\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.StormTest.testStormAndPyromancerAscension",
	"Comment": "i provide a game log fo the issue with storm mentioned earlier. i guesspyromancer ascension is a culprit.",
	"Method": "void testStormAndPyromancerAscension(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 5);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Pyromancer Ascension\", 1);\r\n    addCard(Zone.LIBRARY, playerA, \"Grapeshot\", 2);\r\n    skipInitShuffling();\r\n    addCard(Zone.HAND, playerA, \"Sleight of Hand\");\r\n    addCard(Zone.HAND, playerA, \"Shock\", 3);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Sleight of Hand\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Shock\", playerB);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Shock\", \"targetPlayer=PlayerB\", \"Shock\", StackClause.WHILE_NOT_ON_STACK);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Shock\", \"targetPlayer=PlayerB\", \"Shock\", StackClause.WHILE_NOT_ON_STACK);\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Grapeshot\", playerB);\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Shock\", 3);\r\n    assertGraveyardCount(playerA, \"Grapeshot\", 1);\r\n    assertCounterCount(\"Pyromancer Ascension\", CounterType.QUEST, 2);\r\n    assertLife(playerB, 8);\r\n}"
}, {
	"Path": "org.mage.test.cards.single.UrzasIncubatorTest.testEldraziCostReductionWastesRequirement",
	"Comment": "test to make sure incubator only reduces generic cost. cards withrequirementstill require specific colorless mana to cast.",
	"Method": "void testEldraziCostReductionWastesRequirement(){\r\n    addCard(Zone.HAND, playerA, \"Urza's Incubator\", 1);\r\n    addCard(Zone.HAND, playerA, \"Thought-Knot Seer\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 5);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Urza's Incubator\");\r\n    setChoice(playerA, \"Eldrazi\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Thought-Knot Seer\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Urza's Incubator\", 1);\r\n    assertPermanentCount(playerA, \"Thought-Knot Seer\", 0);\r\n}"
}, {
	"Path": "org.mage.test.AI.basic.TargetsAreChosenTest.testFrostBreath2",
	"Comment": "target only opponent creatures also if more targets are possible",
	"Method": "void testFrostBreath2(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 3);\r\n    addCard(Zone.HAND, playerA, \"Frost Breath\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Pillarfield Ox\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Juggernaut\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Composite Golem\", 1);\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Frost Breath\", 1);\r\n    assertTapped(\"Pillarfield Ox\", true);\r\n    assertTapped(\"Juggernaut\", false);\r\n    assertTapped(\"Composite Golem\", false);\r\n}"
}, {
	"Path": "cc.mallet.classify.AdaBoostM2.classify",
	"Comment": "classify the given instance using only the firstnumweakclassifierstouse classifierstrained during boosting",
	"Method": "Classification classify(Instance inst,Classification classify,Instance inst,int numWeakClassifiersToUse){\r\n    if (numWeakClassifiersToUse <= 0 || numWeakClassifiersToUse > weakClassifiers.length)\r\n        throw new IllegalArgumentException(\"number of weak learners to use out of range:\" + numWeakClassifiersToUse);\r\n    FeatureVector fv = (FeatureVector) inst.getData();\r\n    assert (instancePipe == null || fv.getAlphabet() == this.instancePipe.getDataAlphabet());\r\n    int numClasses = getLabelAlphabet().size();\r\n    double[] scores = new double[numClasses];\r\n    int bestIndex;\r\n    double sum = 0;\r\n    for (int round = 0; round < numWeakClassifiersToUse; round++) {\r\n        bestIndex = weakClassifiers[round].classify(inst).getLabeling().getBestIndex();\r\n        scores[bestIndex] += alphas[round];\r\n        sum += scores[bestIndex];\r\n    }\r\n    for (int i = 0; i < scores.length; i++) scores[i] /= sum;\r\n    return new Classification(inst, this, new LabelVector(getLabelAlphabet(), scores));\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.FlashbackTest.testConflagrate",
	"Comment": "conflagrate flashback no longer works. requires mana payment but neverallows target selection before resolving.",
	"Method": "void testConflagrate(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 7);\r\n    addCard(Zone.HAND, playerA, \"Conflagrate\", 1);\r\n    addCard(Zone.HAND, playerA, \"Forest\", 4);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Conflagrate\");\r\n    setChoice(playerA, \"X=2\");\r\n    activateAbility(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Flashback\");\r\n    setChoice(playerA, \"X=4\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 14);\r\n    assertExileCount(\"Conflagrate\", 1);\r\n}"
}, {
	"Path": "org.mage.test.player.TestPlayer.checkLegalMovesThisTurn",
	"Comment": "iterates through each player on the current turn and asserts if they can attack or block legally this turn",
	"Method": "void checkLegalMovesThisTurn(Game game){\r\n    if (initialTurns < game.getPlayers().size()) {\r\n        initialTurns++;\r\n        return;\r\n    }\r\n    int turnNum = game.getTurnNum();\r\n    for (UUID playerID : game.getPlayers().keySet()) {\r\n        Player player = game.getPlayer(playerID);\r\n        if (player instanceof TestPlayer) {\r\n            for (PlayerAction playerAction : ((TestPlayer) player).getActions()) {\r\n                String action = playerAction.getAction();\r\n                boolean currentPlayersTurn = playerID.equals(getId());\r\n                String playerName = player.getName();\r\n                int actionTurnNum = playerAction.getTurnNum();\r\n                if (turnNum == actionTurnNum) {\r\n                    if (action.startsWith(\"attack:\") && !currentPlayersTurn) {\r\n                        throw new UnsupportedOperationException(playerName + \" can't attack on turn \" + turnNum + \" as it is not their turn\");\r\n                    }\r\n                    if (action.startsWith(\"block:\") && currentPlayersTurn) {\r\n                        throw new UnsupportedOperationException(playerName + \" can't block on turn \" + turnNum + \" as it is their turn\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.SpellCastTriggerTest.testHarnessTheStormThirdTurn",
	"Comment": "i had cast dance with devils the turn before. on this turn i was castingread the bones. the enchantment should not have triggered and if it didit should have asked me to cast read the bones.",
	"Method": "void testHarnessTheStormThirdTurn(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Harness the Storm\", 1);\r\n    addCard(Zone.HAND, playerA, \"Dance with Devils\", 1);\r\n    addCard(Zone.HAND, playerA, \"Read the Bones\", 1);\r\n    addCard(Zone.GRAVEYARD, playerA, \"Read the Bones\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 4);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Dance with Devils\");\r\n    castSpell(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"Read the Bones\");\r\n    setStopAt(3, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Dance with Devils\", 1);\r\n    assertPermanentCount(playerA, \"Devil\", 2);\r\n    assertGraveyardCount(playerA, \"Read the Bones\", 2);\r\n    assertHandCount(playerA, 5);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.SoulbondKeywordTest.testPairOnEntersBattlefield",
	"Comment": "tests pair on another creature without soulbond entering battlefield",
	"Method": "void testPairOnEntersBattlefield(){\r\n    addCard(Zone.HAND, playerA, \"Elite Vanguard\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Trusted Forcemage\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Elite Vanguard\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Trusted Forcemage\", 1);\r\n    assertPowerToughness(playerA, \"Trusted Forcemage\", 3, 3);\r\n    assertPowerToughness(playerA, \"Elite Vanguard\", 3, 2);\r\n}"
}, {
	"Path": "org.mage.test.utils.ManaUtilTest.testManaIncrease",
	"Comment": "mana.enough is used to check if a spell can be cast with an given amountof avalable mana",
	"Method": "void testManaIncrease(){\r\n    testManaReduction(\"{G}{G}\", \"{G}\", \"{G}\");\r\n    testManaReduction(\"{1}{G}{G}\", \"{G}\", \"{1}{G}\");\r\n    testManaReduction(\"{B}{B}\", \"{B}\", \"{B}\");\r\n    testManaReduction(\"{1}{B}{B}\", \"{B}\", \"{1}{B}\");\r\n    testManaReduction(\"{W}{W}\", \"{W}\", \"{W}\");\r\n    testManaReduction(\"{1}{W}{W}\", \"{W}\", \"{1}{W}\");\r\n    testManaReduction(\"{U}{U}\", \"{U}\", \"{U}\");\r\n    testManaReduction(\"{1}{U}{U}\", \"{U}\", \"{1}{U}\");\r\n    testManaReduction(\"{R}{R}\", \"{R}\", \"{R}\");\r\n    testManaReduction(\"{1}{R}{R}\", \"{R}\", \"{1}{R}\");\r\n    testManaReduction(\"{R}{G}{B}{U}{W}\", \"{R}{G}{B}{U}{W}\", \"{0}\");\r\n    testManaReduction(\"{2/B}{2/B}{2/B}\", \"{B}{B}\", \"{2/B}\");\r\n    testManaReduction(\"{2/B}{2/B}{2/B}\", \"{B}{B}{B}\", \"{0}\");\r\n    testManaReduction(\"{2/W}{2/W}{2/W}\", \"{W}{W}\", \"{2/W}\");\r\n    testManaReduction(\"{2/W}{2/W}{2/W}\", \"{W}{W}{W}\", \"{0}\");\r\n    testManaReduction(\"{G/B}{G/B}{G/B}\", \"{B}{G}{B}\", \"{0}\");\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.prevent.MalignusNoPreventDamageTest.testBlockAnotherWithProRed",
	"Comment": "tests that blocking red creature by creature by pro red will prevent damage",
	"Method": "void testBlockAnotherWithProRed(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Vedalken Outlander\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Ogre Resister\");\r\n    attack(2, playerB, \"Ogre Resister\");\r\n    block(2, playerA, \"Vedalken Outlander\", \"Ogre Resister\");\r\n    setStopAt(2, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerB, \"Ogre Resister\", 1);\r\n    assertPermanentCount(playerA, \"Vedalken Outlander\", 1);\r\n}"
}, {
	"Path": "cc.mallet.topics.HierarchicalLDA.propagateTopicWeight",
	"Comment": "propagate a topic weight to a node and all its children.\t\tweight is assumed to be a log.",
	"Method": "void propagateTopicWeight(ObjectDoubleHashMap<NCRPNode> nodeWeights,NCRPNode node,double weight){\r\n    if (!nodeWeights.containsKey(node)) {\r\n        return;\r\n    }\r\n    for (NCRPNode child : node.children) {\r\n        propagateTopicWeight(nodeWeights, child, weight);\r\n    }\r\n    nodeWeights.addTo(node, weight);\r\n}"
}, {
	"Path": "cc.mallet.classify.MaxEntOptimizableByLabelLikelihood.getValueGradientCalls",
	"Comment": "counts how many times this trainer has computed the gradient of the \tlog probability of training labels.",
	"Method": "int getValueGradientCalls(){\r\n    return numGetValueGradientCalls;\r\n}"
}, {
	"Path": "cc.mallet.util.Randoms.nextExp",
	"Comment": "return a random double drawn from an exponential distribution with mean beta and variance beta^2.",
	"Method": "double nextExp(double nextExp,double beta,double nextExp,double beta,double lambda){\r\n    return nextGamma(1, beta, lambda);\r\n}"
}, {
	"Path": "cc.mallet.types.tests.TestSerializable.cloneViaSerialization",
	"Comment": "clones a given object by serializing it to a byte array and reading it back. this is useful for testing serialization methods.",
	"Method": "Object cloneViaSerialization(Serializable obj){\r\n    ByteArrayOutputStream boas = new ByteArrayOutputStream();\r\n    ObjectOutputStream oos = new ObjectOutputStream(boas);\r\n    oos.writeObject(obj);\r\n    ByteArrayInputStream bias = new ByteArrayInputStream(boas.toByteArray());\r\n    ObjectInputStream ois = new ObjectInputStream(bias);\r\n    return ois.readObject();\r\n}"
}, {
	"Path": "org.mage.test.combat.AttackBlockRestrictionsTest.testBowerPassageDestroyed",
	"Comment": "tests restriction effect going away after card is destroyed",
	"Method": "void testBowerPassageDestroyed(){\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Bower Passage\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Elite Vanguard\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Arbor Elf\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Assault Griffin\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Angelic Wall\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Air Elemental\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Llanowar Elves\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 2);\r\n    addCard(Zone.HAND, playerA, \"Naturalize\");\r\n    attack(2, playerB, \"Elite Vanguard\");\r\n    block(2, playerA, \"Angelic Wall\", \"Elite Vanguard\");\r\n    attack(2, playerB, \"Arbor Elf\");\r\n    block(2, playerA, \"Llanowar Elves\", \"Arbor Elf\");\r\n    attack(2, playerB, \"Assault Griffin\");\r\n    block(2, playerA, \"Air Elemental\", \"Assault Griffin\");\r\n    castSpell(2, PhaseStep.DECLARE_ATTACKERS, playerA, \"Naturalize\", \"Bower Passage\");\r\n    setStopAt(2, PhaseStep.END_TURN);\r\n    execute();\r\n    assertPermanentCount(playerB, \"Bower Passage\", 0);\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n}"
}, {
	"Path": "cc.mallet.types.InstanceList.getTargetAlphabet",
	"Comment": "returns the alphabet mapping target output labels tointegers.",
	"Method": "Alphabet getTargetAlphabet(){\r\n    if (targetAlphabet == null && pipe != null) {\r\n        targetAlphabet = pipe.getTargetAlphabet();\r\n    }\r\n    assert (pipe == null || pipe.getTargetAlphabet() == null || pipe.getTargetAlphabet() == targetAlphabet);\r\n    return targetAlphabet;\r\n}"
}, {
	"Path": "cc.mallet.types.SparseVector.getDimensions",
	"Comment": "xxx what do we return for the length?it could be higher than this index.",
	"Method": "int getDimensions(int[] sizes){\r\n    if (indices == null) {\r\n        sizes[0] = values.length;\r\n    } else {\r\n        sizes[0] = indices[indices.length - 1];\r\n    }\r\n    return 1;\r\n}"
}, {
	"Path": "cc.mallet.classify.MaxEntGETrainer.setMaxIterations",
	"Comment": "specifies the maximum number of iterations to run during a single callto train or trainwithfeatureinduction.",
	"Method": "void setMaxIterations(int iter){\r\n    maxIterations = iter;\r\n}"
}, {
	"Path": "cc.mallet.pipe.StringIterator.nextParagraph",
	"Comment": "instead of iterating on characters or sentences, iterate on paragraphs.",
	"Method": "String nextParagraph(){\r\n    char prevChar = '\\n';\r\n    StringBuilder builder = new StringBuilder();\r\n    while (hasNext()) {\r\n        char c = next();\r\n        if ((c == '\\n' || c == '\\r') && (prevChar == '\\n' || prevChar == '\\r')) {\r\n            return builder.toString().trim();\r\n        }\r\n        prevChar = c;\r\n        builder.append(c);\r\n    }\r\n    return builder.toString().trim();\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.dies.ThragtuskTest.testPhyrexianMetamorph",
	"Comment": "test if a thragtusk is copied by a phyrexianmetamorph that both triggerscorrect work",
	"Method": "void testPhyrexianMetamorph(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 4);\r\n    addCard(Zone.HAND, playerA, \"Phyrexian Metamorph\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Swamp\", 6);\r\n    addCard(Zone.HAND, playerB, \"Public Execution\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Thragtusk\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Phyrexian Metamorph\");\r\n    setChoice(playerA, \"Yes\");\r\n    setChoice(playerA, \"Thragtusk\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerB, \"Public Execution\", \"Thragtusk\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertPermanentCount(playerB, \"Thragtusk\", 1);\r\n    assertGraveyardCount(playerA, \"Phyrexian Metamorph\", 1);\r\n    assertGraveyardCount(playerB, \"Public Execution\", 1);\r\n    assertLife(playerA, 23);\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerA, \"Beast\", 1);\r\n}"
}, {
	"Path": "cc.mallet.topics.PolylingualTopicModel.initializeHistograms",
	"Comment": "gather statistics on the size of documents \t and create histograms for use in dirichlet hyperparameter\t optimization.",
	"Method": "void initializeHistograms(){\r\n    int maxTokens = 0;\r\n    int totalTokens = 0;\r\n    for (int doc = 0; doc < data.size(); doc++) {\r\n        int length = 0;\r\n        for (LabelSequence sequence : data.get(doc).topicSequences) {\r\n            length += sequence.getLength();\r\n        }\r\n        if (length > maxTokens) {\r\n            maxTokens = length;\r\n        }\r\n        totalTokens += length;\r\n    }\r\n    System.err.println(\"max tokens: \" + maxTokens);\r\n    System.err.println(\"total tokens: \" + totalTokens);\r\n    docLengthCounts = new int[maxTokens + 1];\r\n    topicDocCounts = new int[numTopics][maxTokens + 1];\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.oneshot.counterspell.ForceOfWillTest.testWithBlueCardsInHand",
	"Comment": "test that force of will can be played with alternate casting costs",
	"Method": "void testWithBlueCardsInHand(){\r\n    addCard(Zone.HAND, playerA, \"Thoughtseize\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 1);\r\n    addCard(Zone.HAND, playerB, \"Force of Will\");\r\n    addCard(Zone.HAND, playerB, \"Remand\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Thoughtseize\", playerB);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Force of Will\", \"Thoughtseize\");\r\n    playerB.addChoice(\"Yes\");\r\n    setStopAt(1, PhaseStep.CLEANUP);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 19);\r\n    assertHandCount(playerA, 0);\r\n    assertGraveyardCount(playerA, 1);\r\n    assertHandCount(playerB, 1);\r\n    assertGraveyardCount(playerB, 1);\r\n    assertExileCount(\"Remand\", 1);\r\n}"
}, {
	"Path": "cc.mallet.share.upenn.MaxEntShell.classify",
	"Comment": "compute the maxent classifications for unlabeled instances given\tby an iterator.",
	"Method": "Classification classify(Classifier classifier,String[] features,Classification[] classify,Classifier classifier,String[][] features,Classification[] classify,Classifier classifier,Iterator<Instance> data){\r\n    InstanceList unlabeledList = new InstanceList(classifier.getInstancePipe());\r\n    unlabeledList.addThruPipe(data);\r\n    logger.info(\"# unlabeled instances = \" + unlabeledList.size());\r\n    List classifications = classifier.classify(unlabeledList);\r\n    return (Classification[]) classifications.toArray(new Classification[] {});\r\n}"
}, {
	"Path": "cc.mallet.topics.ParallelTopicModel.setSaveState",
	"Comment": "define how often and where to save a text representation of the current state. files are gzipped.",
	"Method": "void setSaveState(int interval,String filename){\r\n    this.saveStateInterval = interval;\r\n    this.stateFilename = filename;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.equipped.ScytheOfTheWretchedTest.testEquipDiedInCombat",
	"Comment": "test that the creature that died returns to battlefield under yourcontrol if the previous equiped creature does die already in combat",
	"Method": "void testEquipDiedInCombat(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Serra Angel\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Scythe of the Wretched\");\r\n    activateAbility(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Equip {4}\", \"Silvercoat Lion\");\r\n    attack(2, playerB, \"Silvercoat Lion\");\r\n    block(2, playerA, \"Serra Angel\", \"Silvercoat Lion\");\r\n    setStopAt(2, PhaseStep.POSTCOMBAT_MAIN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerA, \"Serra Angel\", 0);\r\n    assertPermanentCount(playerB, \"Serra Angel\", 1);\r\n    assertPowerToughness(playerB, \"Serra Angel\", 6, 6);\r\n    assertGraveyardCount(playerB, \"Silvercoat Lion\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.CascadeTest.testHaveToPayAdditionalCosts",
	"Comment": "tooth and nail off a cascade is bugged. it let me pay the entwine costfor free even though i had no mana open and the entwine is an additionalcost.",
	"Method": "void testHaveToPayAdditionalCosts(){\r\n    playerA.getLibrary().clear();\r\n    addCard(Zone.LIBRARY, playerA, \"Promise of Power\", 1);\r\n    addCard(Zone.LIBRARY, playerA, \"Mountain\", 5);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 3);\r\n    addCard(Zone.HAND, playerA, \"Enlisted Wurm\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Enlisted Wurm\");\r\n    setChoice(playerA, \"Yes\");\r\n    setChoice(playerA, \"No\");\r\n    setModeChoice(playerA, \"1\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 15);\r\n    assertHandCount(playerA, 5);\r\n    assertPermanentCount(playerA, \"Demon\", 0);\r\n    assertPermanentCount(playerA, \"Enlisted Wurm\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.single.soi.PrizedAmalgamTest.testOpponentReturnsCreatureFromYourGrave",
	"Comment": "test opponent returning a card from your graveyard to battlefield.",
	"Method": "void testOpponentReturnsCreatureFromYourGrave(){\r\n    addCard(Zone.HAND, playerA, \"Necromantic Summons\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 5);\r\n    addCard(Zone.GRAVEYARD, playerB, \"Merfolk Looter\", 1);\r\n    addCard(Zone.GRAVEYARD, playerB, \"Prized Amalgam\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Necromantic Summons\", \"Merfolk Looter\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Merfolk Looter\", 1);\r\n    assertPermanentCount(playerB, \"Prized Amalgam\", 1);\r\n    assertGraveyardCount(playerB, \"Prized Amalgam\", 0);\r\n    assertTapped(\"Prized Amalgam\", true);\r\n}"
}, {
	"Path": "org.mage.test.cards.copy.PhantasmalImageTest.testLeavesTheBattlefieldTriggeredAbilities",
	"Comment": "phantasmal image is not regestering leave the battlefield triggers,persist and undying triggers",
	"Method": "void testLeavesTheBattlefieldTriggeredAbilities(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Thalakos Seer\");\r\n    addCard(Zone.HAND, playerA, \"Public Execution\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 6);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    addCard(Zone.HAND, playerB, \"Phantasmal Image\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Phantasmal Image\");\r\n    setChoice(playerB, \"Thalakos Seer\");\r\n    castSpell(2, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Public Execution\", \"Thalakos Seer\");\r\n    setStopAt(2, PhaseStep.END_TURN);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Public Execution\", 1);\r\n    assertLife(playerB, 20);\r\n    assertLife(playerA, 20);\r\n    assertPermanentCount(playerA, \"Thalakos Seer\", 1);\r\n    assertGraveyardCount(playerB, \"Phantasmal Image\", 1);\r\n    assertHandCount(playerB, 2);\r\n}"
}, {
	"Path": "cc.mallet.classify.FeatureConstraintUtil.readConstraintsFromFile",
	"Comment": "reads feature constraints from a file, whether they are storedusing strings or indices.",
	"Method": "HashMap<Integer, double[]> readConstraintsFromFile(String filename,InstanceList data){\r\n    if (testConstraintsFileIndexBased(filename)) {\r\n        return readConstraintsFromFileIndex(filename, data);\r\n    }\r\n    return readConstraintsFromFileString(filename, data);\r\n}"
}, {
	"Path": "cc.mallet.pipe.StringIterator.moveToEndOfLine",
	"Comment": "moves the current position to the first character that is part of a newline.",
	"Method": "void moveToEndOfLine(){\r\n    char c = peek();\r\n    while (c != '\\r' && c != '\\n' && !isEndOfText()) {\r\n        moveAhead();\r\n        c = peek();\r\n    }\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.TransformTest.testTransformArchangelAvacyn",
	"Comment": "archangel avacyn still transforms after being bounced by an eldrazidisplacer with her trigger on the stack.",
	"Method": "void testTransformArchangelAvacyn(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Archangel Avacyn\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Silvercoat Lion\");\r\n    addCard(Zone.HAND, playerA, \"Lightning Bolt\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Eldrazi Displacer\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Wastes\", 3);\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerA, \"Lightning Bolt\", \"Silvercoat Lion\");\r\n    activateAbility(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"{2}{C}\", \"Archangel Avacyn\", \"Whenever a non-Angel creature you control dies\");\r\n    setStopAt(3, PhaseStep.PRECOMBAT_MAIN);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Lightning Bolt\", 1);\r\n    assertGraveyardCount(playerA, \"Silvercoat Lion\", 1);\r\n    assertPermanentCount(playerB, \"Eldrazi Displacer\", 1);\r\n    assertPermanentCount(playerA, \"Avacyn, the Purifier\", 0);\r\n    assertPermanentCount(playerA, \"Archangel Avacyn\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.single.MisdirectionTest.test_ChangePublicExecution2",
	"Comment": "check to change target permanent creature not legal to to a creature the your opponent controls",
	"Method": "void test_ChangePublicExecution2(){\r\n    addCard(Zone.HAND, playerA, \"Public Execution\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 6);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Keeper of the Lens\", 1);\r\n    addCard(Zone.HAND, playerB, \"Misdirection\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Pillarfield Ox\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Custodian of the Trove\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 5);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Public Execution\", \"Custodian of the Trove\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Misdirection\", \"Public Execution\", \"Public Execution\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertAllCommandsUsed();\r\n    assertGraveyardCount(playerA, \"Public Execution\", 1);\r\n    assertGraveyardCount(playerB, \"Misdirection\", 1);\r\n    assertPermanentCount(playerA, \"Keeper of the Lens\", 1);\r\n    assertPermanentCount(playerB, \"Pillarfield Ox\", 1);\r\n    assertPowerToughness(playerB, \"Pillarfield Ox\", 0, 4);\r\n    assertGraveyardCount(playerB, \"Custodian of the Trove\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.DoublingSeasonTest.testDoubleSporeCounter",
	"Comment": "tests that instead of one spore counter there were two spore countersadded to pallid mycoderm if doubling season is on the battlefield.",
	"Method": "void testDoubleSporeCounter(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Doubling Season\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 4);\r\n    addCard(Zone.HAND, playerA, \"Pallid Mycoderm\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Pallid Mycoderm\");\r\n    setStopAt(3, PhaseStep.PRECOMBAT_MAIN);\r\n    execute();\r\n    assertCounterCount(\"Pallid Mycoderm\", CounterType.SPORE, 2);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.equipped.BatterskullTest.testEquippedToGerm",
	"Comment": "tests that batterskull gets attached to the germ creature token",
	"Method": "void testEquippedToGerm(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 5);\r\n    addCard(Zone.HAND, playerA, \"Batterskull\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Batterskull\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertHandCount(playerA, 0);\r\n    assertPermanentCount(playerA, \"Batterskull\", 1);\r\n    assertPermanentCount(playerA, \"Germ\", 1);\r\n    assertPowerToughness(playerA, \"Germ\", 4, 4);\r\n}"
}, {
	"Path": "org.mage.test.cards.control.GontiLordOfLuxuryEffectTest.testPlaneswalkerCanBeCastLaterFromHand",
	"Comment": "an opponent used a gonti against me, and took my ob nixilis reignited. helater played it, and i killed my ob nixilis. then later, using seasonspast, i got ob nixilis back in my hand. however, the ob nixilis was nowuncastable. has anyone else encountered this?",
	"Method": "void testPlaneswalkerCanBeCastLaterFromHand(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 9);\r\n    addCard(Zone.HAND, playerA, \"Gonti, Lord of Luxury\", 1);\r\n    addCard(Zone.LIBRARY, playerB, \"Ob Nixilis Reignited\");\r\n    skipInitShuffling();\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Swamp\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Forest\", 3);\r\n    addCard(Zone.HAND, playerB, \"Seasons Past\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Dross Crocodile\", 2);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Gonti, Lord of Luxury\");\r\n    addTarget(playerA, playerB);\r\n    setChoice(playerA, \"Ob Nixilis Reignited\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Ob Nixilis Reignited\");\r\n    activateAbility(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"-3:\", \"Dross Crocodile\");\r\n    attack(2, playerB, \"Dross Crocodile\", \"Ob Nixilis Reignited\");\r\n    castSpell(2, PhaseStep.POSTCOMBAT_MAIN, playerB, \"Seasons Past\");\r\n    setChoice(playerB, \"Ob Nixilis Reignited\");\r\n    castSpell(4, PhaseStep.PRECOMBAT_MAIN, playerB, \"Ob Nixilis Reignited\");\r\n    setStopAt(4, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Gonti, Lord of Luxury\", 1);\r\n    assertPermanentCount(playerB, \"Dross Crocodile\", 1);\r\n    assertGraveyardCount(playerB, \"Dross Crocodile\", 1);\r\n    assertGraveyardCount(playerB, \"Seasons Past\", 0);\r\n    assertHandCount(playerB, \"Ob Nixilis Reignited\", 0);\r\n    assertPermanentCount(playerB, \"Ob Nixilis Reignited\", 1);\r\n}"
}, {
	"Path": "cc.mallet.pipe.AddClassifierTokenPredictions.convert",
	"Comment": "converts each instance containing a featurevectorsequence to multiple instances, \teach containing an augmentablefeaturevector as data.",
	"Method": "InstanceList convert(InstanceList ilist,Noop alphabetsPipe,InstanceList convert,Instance inst,Noop alphabetsPipe){\r\n    InstanceList ret = new InstanceList(alphabetsPipe);\r\n    Object obj = inst.getData();\r\n    assert (obj instanceof FeatureVectorSequence);\r\n    FeatureVectorSequence fvs = (FeatureVectorSequence) obj;\r\n    LabelSequence ls = (LabelSequence) inst.getTarget();\r\n    assert (fvs.size() == ls.size());\r\n    Object instName = (inst.getName() == null ? \"NONAME\" : inst.getName());\r\n    for (int j = 0; j < fvs.size(); j++) {\r\n        FeatureVector fv = fvs.getFeatureVector(j);\r\n        int[] indices = fv.getIndices();\r\n        FeatureVector data = new AugmentableFeatureVector(alphabetsPipe.getDataAlphabet(), indices, fv.getValues(), indices.length);\r\n        Labeling target = ls.getLabelAtPosition(j);\r\n        String name = instName.toString() + \"_@_POS_\" + (j + 1);\r\n        Object source = inst.getSource();\r\n        Instance toAdd = alphabetsPipe.pipe(new Instance(data, target, name, source));\r\n        ret.add(toAdd);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "cc.mallet.fst.CRFTrainerByValueGradients.train",
	"Comment": "trains a crf until convergence or specified number of iterations, whichever is earlier.\talso creates an optimizable crf and an optmizer if required.",
	"Method": "boolean train(InstanceList trainingSet,int numIterations,boolean train,InstanceList training,int numIterationsPerProportion,double[] trainingProportions){\r\n    int trainingIteration = 0;\r\n    assert (trainingProportions.length > 0);\r\n    boolean converged = false;\r\n    for (int i = 0; i < trainingProportions.length; i++) {\r\n        assert (trainingProportions[i] <= 1.0);\r\n        logger.info(\"Training on \" + trainingProportions[i] + \"% of the data this round.\");\r\n        if (trainingProportions[i] == 1.0)\r\n            converged = this.train(training, numIterationsPerProportion);\r\n        else\r\n            converged = this.train(training.split(new Random(1), new double[] { trainingProportions[i], 1 - trainingProportions[i] })[0], numIterationsPerProportion);\r\n        trainingIteration += numIterationsPerProportion;\r\n    }\r\n    return converged;\r\n}"
}, {
	"Path": "cc.mallet.classify.BalancedWinnowTrainer.train",
	"Comment": "trains the classifier on the instance list, updating \tclass weight vectors as appropriate",
	"Method": "BalancedWinnow train(InstanceList trainingList){\r\n    FeatureSelection selectedFeatures = trainingList.getFeatureSelection();\r\n    if (selectedFeatures != null)\r\n        throw new UnsupportedOperationException(\"FeatureSelection not yet implemented.\");\r\n    double epsilon = m_epsilon;\r\n    Alphabet dict = (Alphabet) trainingList.getDataAlphabet();\r\n    int numLabels = trainingList.getTargetAlphabet().size();\r\n    int numFeats = dict.size();\r\n    m_weights = new double[numLabels][numFeats + 1];\r\n    for (int i = 0; i < numLabels; i++) Arrays.fill(m_weights[i], 1.0);\r\n    double[] results = new double[numLabels];\r\n    for (int iter = 0; iter < m_maxIterations; iter++) {\r\n        for (int ii = 0; ii < trainingList.size(); ii++) {\r\n            Instance inst = trainingList.get(ii);\r\n            Labeling labeling = inst.getLabeling();\r\n            FeatureVector fv = (FeatureVector) inst.getData();\r\n            int fvisize = fv.numLocations();\r\n            int correctIndex = labeling.getBestIndex();\r\n            Arrays.fill(results, 0);\r\n            for (int lpos = 0; lpos < numLabels; lpos++) {\r\n                for (int fvi = 0; fvi < fvisize; fvi++) {\r\n                    int fi = fv.indexAtLocation(fvi);\r\n                    double vi = fv.valueAtLocation(fvi);\r\n                    results[lpos] += vi * m_weights[lpos][fi];\r\n                }\r\n                results[lpos] += m_weights[lpos][numFeats];\r\n            }\r\n            int predictedIndex = 0;\r\n            int secondHighestIndex = 0;\r\n            double max = Double.MIN_VALUE;\r\n            double secondMax = Double.MIN_VALUE;\r\n            for (int i = 0; i < numLabels; i++) {\r\n                if (results[i] > max) {\r\n                    secondMax = max;\r\n                    max = results[i];\r\n                    secondHighestIndex = predictedIndex;\r\n                    predictedIndex = i;\r\n                } else if (results[i] > secondMax) {\r\n                    secondMax = results[i];\r\n                    secondHighestIndex = i;\r\n                }\r\n            }\r\n            if (predictedIndex != correctIndex) {\r\n                for (int fvi = 0; fvi < fvisize; fvi++) {\r\n                    int fi = fv.indexAtLocation(fvi);\r\n                    m_weights[predictedIndex][fi] *= (1 - epsilon);\r\n                    m_weights[correctIndex][fi] *= (1 + epsilon);\r\n                }\r\n                m_weights[predictedIndex][numFeats] *= (1 - epsilon);\r\n                m_weights[correctIndex][numFeats] *= (1 + epsilon);\r\n            } else if (max / secondMax - 1 < m_delta) {\r\n                for (int fvi = 0; fvi < fvisize; fvi++) {\r\n                    int fi = fv.indexAtLocation(fvi);\r\n                    m_weights[secondHighestIndex][fi] *= (1 - epsilon);\r\n                    m_weights[correctIndex][fi] *= (1 + epsilon);\r\n                }\r\n                m_weights[secondHighestIndex][numFeats] *= (1 - epsilon);\r\n                m_weights[correctIndex][numFeats] *= (1 + epsilon);\r\n            }\r\n        }\r\n        epsilon *= (1 - m_coolingRate);\r\n    }\r\n    this.classifier = new BalancedWinnow(trainingList.getPipe(), m_weights);\r\n    return classifier;\r\n}"
}, {
	"Path": "cc.mallet.types.InstanceList.getDataAlphabet",
	"Comment": "returns the alphabet mapping features of the data tointegers.",
	"Method": "Alphabet getDataAlphabet(){\r\n    if (dataAlphabet == null && pipe != null) {\r\n        dataAlphabet = pipe.getDataAlphabet();\r\n    }\r\n    assert (pipe == null || pipe.getDataAlphabet() == null || pipe.getDataAlphabet() == dataAlphabet);\r\n    return dataAlphabet;\r\n}"
}, {
	"Path": "org.mage.test.cards.single.bfz.BrutalExpulsionTest.testPlaneswalkerExile",
	"Comment": "brutal expulsion targeting gideon, ally of zendikar. gideon has 3loyalty. brutal expulsion resolves, leaves 1 loyalty. i attack gideon for1 with a scion token, gideon dies. instead of going to graveyard,expulsion sends gideon to exile. however, in game gideon went tograveyard.",
	"Method": "void testPlaneswalkerExile(){\r\n    addCard(Zone.HAND, playerA, \"Brutal Expulsion\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 3);\r\n    addCard(Zone.HAND, playerA, \"Shock\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Gideon, Ally of Zendikar\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Brutal Expulsion\", \"mode=2Gideon, Ally of Zendikar\");\r\n    setModeChoice(playerA, \"2\");\r\n    setModeChoice(playerA, null);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Shock\", \"Gideon, Ally of Zendikar\");\r\n    setStopAt(1, PhaseStep.END_COMBAT);\r\n    execute();\r\n    assertHandCount(playerA, 0);\r\n    assertPermanentCount(playerA, \"Shock\", 0);\r\n    assertPermanentCount(playerB, \"Gideon, Ally of Zendikar\", 0);\r\n    assertExileCount(\"Gideon, Ally of Zendikar\", 1);\r\n}"
}, {
	"Path": "cc.mallet.types.PagedInstanceList.split",
	"Comment": "shuffles the elements of this list among several smallerlists. overrides instancelist.split to add instances in originalorder, to prevent thrashing.",
	"Method": "InstanceList[] split(java.util.Random r,double[] proportions){\r\n    InstanceList[] ret = new InstanceList[proportions.length];\r\n    double[] maxind = proportions.clone();\r\n    int size = size();\r\n    int[] shuffled = new int[size];\r\n    int[] splits = new int[size];\r\n    for (int i = 0; i < size; i++) {\r\n        shuffled[i] = i;\r\n    }\r\n    shuffleArray(r, shuffled);\r\n    MatrixOps.normalize(maxind);\r\n    for (int i = 0; i < maxind.length; i++) {\r\n        ret[i] = this.cloneEmpty();\r\n        if (i > 0)\r\n            maxind[i] += maxind[i - 1];\r\n    }\r\n    for (int i = 0; i < maxind.length; i++) {\r\n        maxind[i] = Math.rint(maxind[i] * size);\r\n    }\r\n    for (int i = 0, j = 0; i < size; i++) {\r\n        while (i >= maxind[j] && j < ret.length) j++;\r\n        splits[shuffled[i]] = j;\r\n    }\r\n    for (int i = 0; i < size; i++) {\r\n        ret[splits[i]].add(this.get(i));\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.MorphTest.testDiesTriggeredDoesNotTriggerIfFaceDown",
	"Comment": "check that a diestriggeredability of a creature does not trigger if thecreature dies face down",
	"Method": "void testDiesTriggeredDoesNotTriggerIfFaceDown(){\r\n    addCard(Zone.HAND, playerA, \"Ashcloud Phoenix\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 3);\r\n    addCard(Zone.HAND, playerB, \"Lightning Bolt\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mountain\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Ashcloud Phoenix\");\r\n    setChoice(playerA, \"Yes\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Lightning Bolt\", EmptyNames.FACE_DOWN_CREATURE.toString());\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerB, \"Lightning Bolt\", 1);\r\n    assertGraveyardCount(playerA, \"Ashcloud Phoenix\", 1);\r\n    for (Card card : playerA.getGraveyard().getCards(currentGame)) {\r\n        if (card.getName().equals(\"Ashcloud Phoenix\")) {\r\n            Assert.assertEquals(\"Ashcloud Phoenix has to be face up in graveyard\", false, card.isFaceDown(currentGame));\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.MorphTest.testDiesTriggeredDoesNotTriggerInCombatIfFaceDown",
	"Comment": "check that a diestriggeredability of a creature does not trigger if thecreature dies face down in combat",
	"Method": "void testDiesTriggeredDoesNotTriggerInCombatIfFaceDown(){\r\n    addCard(Zone.HAND, playerA, \"Ashcloud Phoenix\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mirri, Cat Warrior\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Ashcloud Phoenix\");\r\n    setChoice(playerA, \"Yes\");\r\n    attack(2, playerB, \"Mirri, Cat Warrior\");\r\n    block(2, playerA, EmptyNames.FACE_DOWN_CREATURE.toString(), \"Mirri, Cat Warrior\");\r\n    setStopAt(2, PhaseStep.POSTCOMBAT_MAIN);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Ashcloud Phoenix\", 1);\r\n    for (Card card : playerA.getGraveyard().getCards(currentGame)) {\r\n        if (card.getName().equals(\"Ashcloud Phoenix\")) {\r\n            Assert.assertEquals(\"Ashcloud Phoenix has to be face up in graveyard\", false, card.isFaceDown(currentGame));\r\n            break;\r\n        }\r\n    }\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.JourneyToNowhereTest.testTargetGetsExiledAndDoesNeverReturnAndJourneyPlayedAgain",
	"Comment": "journey is played and targets the creature as it enters the battlefield. the journey will be returned to hand before the ability resolves. the journey will be played again targeting another creature. the journey will be disenchanted later, so only the second creature has to return to battlefield.",
	"Method": "void testTargetGetsExiledAndDoesNeverReturnAndJourneyPlayedAgain(){\r\n    addCard(Zone.HAND, playerA, \"Journey to Nowhere\");\r\n    addCard(Zone.HAND, playerA, \"Boomerang\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 4);\r\n    addCard(Zone.HAND, playerB, \"Disenchant\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Pillarfield Ox\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 2);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Journey to Nowhere\");\r\n    addTarget(playerA, \"Silvercoat Lion\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Boomerang\", \"Journey to Nowhere\", \"Journey to Nowhere\", StackClause.WHILE_NOT_ON_STACK);\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Journey to Nowhere\");\r\n    addTarget(playerA, \"Pillarfield Ox\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Disenchant\", \"Journey to Nowhere\");\r\n    setStopAt(2, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Boomerang\", 1);\r\n    assertGraveyardCount(playerA, \"Journey to Nowhere\", 1);\r\n    assertGraveyardCount(playerB, \"Disenchant\", 1);\r\n    assertPermanentCount(playerB, \"Pillarfield Ox\", 1);\r\n    assertPermanentCount(playerB, \"Silvercoat Lion\", 0);\r\n    assertExileCount(\"Silvercoat Lion\", 1);\r\n}"
}, {
	"Path": "cc.mallet.classify.MCMaxEntTrainer.getValueGradientCalls",
	"Comment": "counts how many times this trainer has computed the gradient of thelog probability of training labels.",
	"Method": "int getValueGradientCalls(){\r\n    return numGetValueGradientCalls;\r\n}"
}, {
	"Path": "cc.mallet.classify.MaxEnt.classify",
	"Comment": "modified by limin yao, using temperature classification score",
	"Method": "Classification classify(Instance instance){\r\n    int numClasses = getLabelAlphabet().size();\r\n    double[] scores = new double[numClasses];\r\n    getClassificationScores(instance, scores);\r\n    return new Classification(instance, this, new LabelVector(getLabelAlphabet(), scores));\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.SuspendTest.testCostManipulation",
	"Comment": "suppression field incorrectly makes suspend cards cost 2 more to suspend.it made my rift bolt cost 2r to suspend instead of r",
	"Method": "void testCostManipulation(){\r\n    addCard(Zone.HAND, playerA, \"Rift Bolt\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Suppression Field\", 1);\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Suspend\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertHandCount(playerA, \"Rift Bolt\", 0);\r\n}"
}, {
	"Path": "org.mage.test.cards.continuous.WonderTest.testCardWithAllConditionsMet",
	"Comment": "tests creatures for flying gained from wonder ability when all conditionswere met",
	"Method": "void testCardWithAllConditionsMet(){\r\n    addCard(Zone.GRAVEYARD, playerA, \"Wonder\");\r\n    addCard(Zone.GRAVEYARD, playerA, \"Runeclaw Bear\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Elite Vanguard\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Corpse Traders\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Llanowar Elves\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertAbility(playerA, \"Elite Vanguard\", FlyingAbility.getInstance(), true);\r\n    assertAbility(playerA, \"Corpse Traders\", FlyingAbility.getInstance(), true);\r\n    assertAbility(playerB, \"Llanowar Elves\", FlyingAbility.getInstance(), false);\r\n    for (Card card : playerA.getGraveyard().getCards(currentGame)) {\r\n        if (card.getName().equals(\"Runeclaw Bear\")) {\r\n            Assert.assertFalse(card.getAbilities().contains(FlyingAbility.getInstance()));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "cc.mallet.classify.MostFrequentClassAssignmentTrainer.train",
	"Comment": "create a mostfrequent classifier from a set of training data.",
	"Method": "MostFrequentClassifier train(InstanceList trainingSet){\r\n    if (trainingSet != null) {\r\n        if (this.instancePipe == null)\r\n            this.instancePipe = trainingSet.getPipe();\r\n        else if (this.instancePipe != trainingSet.getPipe())\r\n            throw new IllegalArgumentException(\"Training set pipe does not match that of NaiveBayesTrainer.\");\r\n        this.dataAlphabet = this.instancePipe.getDataAlphabet();\r\n        this.targetAlphabet = this.instancePipe.getTargetAlphabet();\r\n    }\r\n    this.classifier = new MostFrequentClassifier(this.instancePipe);\r\n    for (Instance instance : trainingSet) {\r\n        if (dataAlphabet == null) {\r\n            this.dataAlphabet = instance.getDataAlphabet();\r\n            this.targetAlphabet = instance.getTargetAlphabet();\r\n        } else if (!Alphabet.alphabetsMatch(instance, this))\r\n            throw new IllegalArgumentException(\"Training set alphabets do not match those of NaiveBayesTrainer.\");\r\n        Label label = (Label) instance.getTarget();\r\n        this.classifier.addTargetLabel(label);\r\n    }\r\n    return this.classifier;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.KickerTest.testKickerCondition",
	"Comment": "check that kicker condition does also work for kicker cards with multiplekicker options",
	"Method": "void testKickerCondition(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 2);\r\n    addCard(Zone.HAND, playerA, \"Sunscape Battlemage\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Birds of Paradise\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 1);\r\n    addCard(Zone.HAND, playerB, \"Ertai's Trickery\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Sunscape Battlemage\");\r\n    addTarget(playerA, \"Birds of Paradise\");\r\n    setChoice(playerA, \"Yes\");\r\n    setChoice(playerA, \"Yes\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Ertai's Trickery\", \"Sunscape Battlemage\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerB, \"Birds of Paradise\", 1);\r\n    assertGraveyardCount(playerB, \"Ertai's Trickery\", 1);\r\n    assertGraveyardCount(playerA, \"Sunscape Battlemage\", 1);\r\n}"
}, {
	"Path": "cc.mallet.pipe.SerialPipes.pipes",
	"Comment": "allows access to the underlying collection of pipes.use with caution.",
	"Method": "ArrayList<Pipe> pipes(){\r\n    return pipes;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.SoulbondKeywordTest.testPairOnAnimatedLand",
	"Comment": "tests that it is possible to animate land and pair it on next comingsoulbond creature",
	"Method": "void testPairOnAnimatedLand(){\r\n    addCard(Zone.HAND, playerA, \"Trusted Forcemage\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Blinkmoth Nexus\", 1);\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"{1}: \");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Trusted Forcemage\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPowerToughness(playerA, \"Trusted Forcemage\", 3, 3);\r\n    assertPowerToughness(playerA, \"Blinkmoth Nexus\", 2, 2);\r\n}"
}, {
	"Path": "cc.mallet.topics.HierarchicalLDA.setProgressDisplay",
	"Comment": "this parameter determines whether the sampler outputs \tshows progress by outputting a character after every iteration.",
	"Method": "void setProgressDisplay(boolean showProgress){\r\n    this.showProgress = showProgress;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.oneshot.counter.AddingCountersToPermanentsTest.testFairgroundsTrumpeter",
	"Comment": "fairgrounds trumpeter does not get a counter at the end of turn whenwoodland wanderer enters the battlefield",
	"Method": "void testFairgroundsTrumpeter(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 7);\r\n    addCard(Zone.HAND, playerA, \"Fairgrounds Trumpeter\", 1);\r\n    addCard(Zone.HAND, playerA, \"Woodland Wanderer\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Woodland Wanderer\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Fairgrounds Trumpeter\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertPowerToughness(playerA, \"Woodland Wanderer\", 3, 3);\r\n    assertPowerToughness(playerA, \"Fairgrounds Trumpeter\", 3, 3);\r\n}"
}, {
	"Path": "org.mage.test.utils.ManaUtilTest.testManaEnough",
	"Comment": "mana.enough is used to check if a spell can be cast with an given amountof avalable mana",
	"Method": "void testManaEnough(){\r\n    testManaAvailEnough(\"{G}\", 1, \"\", true);\r\n    testManaAvailEnough(\"{G}\", 0, \"{G}\", true);\r\n    testManaAvailEnough(\"{R}\", 0, \"{G}\", false);\r\n    testManaAvailEnough(\"{B}\", 0, \"{G}\", false);\r\n    testManaAvailEnough(\"{U}\", 0, \"{G}\", false);\r\n    testManaAvailEnough(\"{W}\", 0, \"{G}\", false);\r\n    testManaAvailEnough(\"{R}\", 1, \"\", true);\r\n    testManaAvailEnough(\"{R}\", 0, \"{R}\", true);\r\n    testManaAvailEnough(\"{G}\", 0, \"{R}\", false);\r\n    testManaAvailEnough(\"{B}\", 0, \"{R}\", false);\r\n    testManaAvailEnough(\"{U}\", 0, \"{R}\", false);\r\n    testManaAvailEnough(\"{W}\", 0, \"{R}\", false);\r\n    testManaAvailEnough(\"{U}{B}{W}{G}{R}\", 4, \"{R}\", true);\r\n    testManaAvailEnough(\"{U}{B}{W}{G}{R}\", 3, \"{R}{B}\", true);\r\n    testManaAvailEnough(\"{U}{U}{U}{G}{G}{2}\", 2, \"{U}{U}{G}{R}{B}\", true);\r\n    testManaAvailEnough(\"{2}{U}{U}\", 0, \"{U}{U}{U}{U}\", true);\r\n    testManaAvailEnough(\"{2}{U}{U}\", 0, \"{4}\", false);\r\n    testManaAvailEnough(\"{2}{U}{U}\", 0, \"{B}{B}{4}\", false);\r\n    testManaAvailEnough(\"{G}\", 0, \"{G/W}\", true);\r\n    testManaAvailEnough(\"{G}{W}\", 0, \"{G/W}{G/W}\", true);\r\n    testManaAvailEnough(\"{W}{W}\", 0, \"{G/W}{G/W}\", true);\r\n    testManaAvailEnough(\"{G}{G}\", 0, \"{G/W}{G/W}\", true);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.other.NecromancyTest.testNecromancyFlashSacrifice",
	"Comment": "check if necromancy is sacrificed if cast as instant and if thereanimated creature will be sacrificed.",
	"Method": "void testNecromancyFlashSacrifice(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 3);\r\n    addCard(Zone.HAND, playerA, \"Necromancy\");\r\n    addCard(Zone.GRAVEYARD, playerA, \"Craw Wurm\");\r\n    castSpell(1, PhaseStep.UPKEEP, playerA, \"Necromancy\");\r\n    setStopAt(2, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Craw Wurm\", 0);\r\n    assertPermanentCount(playerA, \"Necromancy\", 0);\r\n    assertGraveyardCount(playerA, \"Craw Wurm\", 1);\r\n    assertGraveyardCount(playerA, \"Necromancy\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.copy.PhantasmalImageTest.testCopyAsEntersBattlefieldAbility2",
	"Comment": "tests that copy effect will copy asentersbattlefieldability and willchoose another color. both lurebound scarecrow cards should stay onbattlefield.",
	"Method": "void testCopyAsEntersBattlefieldAbility2(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 5);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Llanowar Elves\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Raging Goblin\");\r\n    addCard(Zone.HAND, playerA, \"Phantasmal Image\");\r\n    addCard(Zone.HAND, playerA, \"Lurebound Scarecrow\");\r\n    setChoice(playerA, \"Green\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Lurebound Scarecrow\");\r\n    setChoice(playerA, \"Red\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Phantasmal Image\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Lurebound Scarecrow\", 2);\r\n}"
}, {
	"Path": "cc.mallet.fst.Transducer.averageTokenAccuracy",
	"Comment": "runs inference across all the instances and returns the average token\taccuracy.",
	"Method": "double averageTokenAccuracy(InstanceList ilist){\r\n    double accuracy = 0;\r\n    for (int i = 0; i < ilist.size(); i++) {\r\n        Instance instance = ilist.get(i);\r\n        Sequence input = (Sequence) instance.getData();\r\n        Sequence output = (Sequence) instance.getTarget();\r\n        assert (input.size() == output.size());\r\n        Sequence predicted = maxLatticeFactory.newMaxLattice(this, input).bestOutputSequence();\r\n        double pathAccuracy = Sequences.elementwiseAccuracy(output, predicted);\r\n        accuracy += pathAccuracy;\r\n        logger.fine(\"Transducer path accuracy = \" + pathAccuracy);\r\n    }\r\n    return accuracy / ilist.size();\r\n}"
}, {
	"Path": "cc.mallet.types.DenseVector.arrayCopyInto",
	"Comment": "copy the contents of this vector into an array starting at a particularindex.",
	"Method": "int arrayCopyInto(double[] array,int startingArrayIndex){\r\n    System.arraycopy(values, 0, array, startingArrayIndex, values.length);\r\n    return startingArrayIndex + values.length;\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.ZoneChangeReplacementTest.testCounterAndMoveToLibrary",
	"Comment": "test that a countered spell of a card that goes always to library backinstead of into the graveyard.",
	"Method": "void testCounterAndMoveToLibrary(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 7);\r\n    addCard(Zone.HAND, playerA, \"Legacy Weapon\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    addCard(Zone.HAND, playerB, \"Mana Drain\");\r\n    addCard(Zone.HAND, playerB, \"Legacy Weapon\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Legacy Weapon\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Mana Drain\", \"Legacy Weapon\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Legacy Weapon\");\r\n    setStopAt(2, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertHandCount(playerA, \"Legacy Weapon\", 0);\r\n    assertPermanentCount(playerA, \"Legacy Weapon\", 0);\r\n    assertGraveyardCount(playerA, \"Legacy Weapon\", 0);\r\n    assertGraveyardCount(playerB, \"Mana Drain\", 1);\r\n    assertPermanentCount(playerB, \"Legacy Weapon\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.other.SoulfireGrandMasterTest.testSoulfireLeft",
	"Comment": "test that if soulfire grand master has left the battlefield spell has nolonger lifelink",
	"Method": "void testSoulfireLeft(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 1);\r\n    addCard(Zone.HAND, playerA, \"Lightning Bolt\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Soulfire Grand Master\", 1);\r\n    addCard(Zone.HAND, playerB, \"Lightning Bolt\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mountain\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Lightning Bolt\", playerB);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Lightning Bolt\", \"Soulfire Grand Master\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Lightning Bolt\", 1);\r\n    assertGraveyardCount(playerB, \"Lightning Bolt\", 1);\r\n    assertGraveyardCount(playerA, \"Soulfire Grand Master\", 1);\r\n    assertLife(playerB, 17);\r\n    assertLife(playerA, 20);\r\n}"
}, {
	"Path": "org.mage.test.cards.continuous.PsychicIntrusionTest.testCastFromExile",
	"Comment": "tests that exiled card can be cast from exile the next turn with any mana",
	"Method": "void testCastFromExile(){\r\n    addCard(Zone.HAND, playerA, \"Psychic Intrusion\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 3);\r\n    addCard(Zone.HAND, playerB, \"Elspeth, Sun's Champion\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Psychic Intrusion\", playerB);\r\n    addTarget(playerA, \"Elspeth, Sun's Champion\");\r\n    castSpell(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"Elspeth, Sun's Champion\");\r\n    setStopAt(3, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Psychic Intrusion\", 1);\r\n    assertHandCount(playerB, \"Elspeth, Sun's Champion\", 0);\r\n    assertPermanentCount(playerA, \"Elspeth, Sun's Champion\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.entersBattlefield.EntersTheBattlefieldTappedTest.testTappedFromHand",
	"Comment": "creatures that enter the battlefield tapped, like dread wanderer, if youbring them back from graveyard to the battlefield they enter untapped!!",
	"Method": "void testTappedFromHand(){\r\n    addCard(Zone.HAND, playerA, \"Dread Wanderer\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Dread Wanderer\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Dread Wanderer\", 1);\r\n    assertTapped(\"Dread Wanderer\", true);\r\n}"
}, {
	"Path": "cc.mallet.classify.Trial.getRecall",
	"Comment": "calculate the recall for a particular target index from an\tarray list of classifications",
	"Method": "double getRecall(Object labelEntry,double getRecall,Labeling label,double getRecall,int labelIndex){\r\n    int numCorrect = 0;\r\n    int numInstances = 0;\r\n    int trueLabel, classLabel;\r\n    for (int i = 0; i < this.size(); i++) {\r\n        trueLabel = this.get(i).getInstance().getLabeling().getBestIndex();\r\n        classLabel = this.get(i).getLabeling().getBestIndex();\r\n        if (trueLabel == labelIndex) {\r\n            numInstances++;\r\n            if (classLabel == labelIndex)\r\n                numCorrect++;\r\n        }\r\n    }\r\n    if (numInstances == 0) {\r\n        logger.warning(\"No examples with true label \" + classifier.getLabelAlphabet().lookupLabel(labelIndex) + \"!\");\r\n        assert (numCorrect == 0);\r\n        return 1;\r\n    }\r\n    return ((double) numCorrect / (double) numInstances);\r\n}"
}, {
	"Path": "cc.mallet.types.SparseMatrixn.numLocations",
	"Comment": "access by index into sparse array, efficient for sparse and dense matrices",
	"Method": "int numLocations(){\r\n    return values.numLocations();\r\n}"
}, {
	"Path": "cc.mallet.util.Randoms.nextPoisson",
	"Comment": "return random integer from poission with parameter lambda.\tthe mean of this distribution is lambda.the variance is lambda.",
	"Method": "int nextPoisson(double lambda,int nextPoisson){\r\n    return nextPoisson(1);\r\n}"
}, {
	"Path": "org.mage.test.cards.cost.additional.PhyrexianPurgeTest.counteredSpellStillPaysFullCost",
	"Comment": "target two creatures, spell is countered. still pays 6 life.",
	"Method": "void counteredSpellStillPaysFullCost(){\r\n    String pPurge = \"Phyrexian Purge\";\r\n    addCard(Zone.HAND, playerA, pPurge);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 2);\r\n    addCard(Zone.HAND, playerB, \"Counterspell\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Memnite\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Hill Giant\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, pPurge);\r\n    addTarget(playerA, \"Memnite^Hill Giant\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Counterspell\", pPurge);\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, pPurge, 1);\r\n    assertGraveyardCount(playerB, \"Counterspell\", 1);\r\n    assertPermanentCount(playerB, \"Memnite\", 1);\r\n    assertPermanentCount(playerB, \"Hill Giant\", 1);\r\n    assertLife(playerA, 14);\r\n}"
}, {
	"Path": "cc.mallet.fst.semi_supervised.CRFTrainerByEntropyRegularization.train",
	"Comment": "performs crf training with label likelihood and entropy regularization.\tthe crf is first trained with label likelihood only.this parameter \tsetting is used as a starting point for the combined optimization.",
	"Method": "boolean train(InstanceList trainingSet,int numIterations,boolean train,InstanceList labeled,InstanceList unlabeled,int numIterations){\r\n    if (iteration == 0) {\r\n        CRFOptimizableByLabelLikelihood likelihood = new CRFOptimizableByLabelLikelihood(crf, labeled);\r\n        likelihood.setGaussianPriorVariance(gaussianPriorVariance);\r\n        this.bfgs = new LimitedMemoryBFGS(likelihood);\r\n        logger.info(\"CRF about to train with \" + numIterations + \" iterations\");\r\n        for (int i = 0; i < numIterations; i++) {\r\n            try {\r\n                converged = bfgs.optimize(1);\r\n                iteration++;\r\n                logger.info(\"CRF finished one iteration of maximizer, i=\" + i);\r\n                runEvaluators();\r\n            } catch (IllegalArgumentException e) {\r\n                e.printStackTrace();\r\n                logger.info(\"Catching exception; saying converged.\");\r\n                converged = true;\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n                logger.info(\"Catching exception; saying converged.\");\r\n                converged = true;\r\n            }\r\n            if (converged) {\r\n                logger.info(\"CRF training has converged, i=\" + i);\r\n                break;\r\n            }\r\n        }\r\n        iteration = 0;\r\n    }\r\n    CRFOptimizableByLabelLikelihood likelihood = new CRFOptimizableByLabelLikelihood(crf, labeled);\r\n    likelihood.setGaussianPriorVariance(gaussianPriorVariance);\r\n    CRFOptimizableByEntropyRegularization regularization = new CRFOptimizableByEntropyRegularization(crf, unlabeled);\r\n    regularization.setScalingFactor(this.entRegScalingFactor);\r\n    CRFOptimizableByGradientValues regLikelihood = new CRFOptimizableByGradientValues(crf, new Optimizable.ByGradientValue[] { likelihood, regularization });\r\n    this.bfgs = new LimitedMemoryBFGS(regLikelihood);\r\n    converged = false;\r\n    logger.info(\"CRF about to train with \" + numIterations + \" iterations\");\r\n    for (int reset = 0; reset < DEFAULT_NUM_RESETS + 1; reset++) {\r\n        for (int i = 0; i < numIterations; i++) {\r\n            try {\r\n                converged = bfgs.optimize(1);\r\n                iteration++;\r\n                logger.info(\"CRF finished one iteration of maximizer, i=\" + i);\r\n                runEvaluators();\r\n            } catch (IllegalArgumentException e) {\r\n                e.printStackTrace();\r\n                logger.info(\"Catching exception; saying converged.\");\r\n                converged = true;\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n                logger.info(\"Catching exception; saying converged.\");\r\n                converged = true;\r\n            }\r\n            if (converged) {\r\n                logger.info(\"CRF training has converged, i=\" + i);\r\n                break;\r\n            }\r\n        }\r\n        this.bfgs.reset();\r\n    }\r\n    return converged;\r\n}"
}, {
	"Path": "org.mage.test.cards.control.ExchangeControlTest.testExchangeAnCopyEffect",
	"Comment": "an control exchanged creature gets an copy effect from an creature withan activated ability to the by exchange controlled creature. check thatthe activated ability is controlled by the new controller of the copytarget.",
	"Method": "void testExchangeAnCopyEffect(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 6);\r\n    addCard(Zone.HAND, playerA, \"Gilded Drake\");\r\n    addCard(Zone.HAND, playerA, \"Polymorphous Rush\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Manta Riders\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Gilded Drake\");\r\n    addTarget(playerA, \"Silvercoat Lion\");\r\n    castSpell(1, PhaseStep.BEGIN_COMBAT, playerA, \"Polymorphous Rush\", \"Silvercoat Lion\");\r\n    addTarget(playerA, \"Manta Riders\");\r\n    activateAbility(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"{U}: {this} gains flying until end of turn.\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerB, \"Gilded Drake\", 1);\r\n    assertGraveyardCount(playerA, \"Polymorphous Rush\", 1);\r\n    assertPermanentCount(playerB, \"Silvercoat Lion\", 0);\r\n    assertPermanentCount(playerA, \"Silvercoat Lion\", 0);\r\n    assertPermanentCount(playerB, \"Manta Riders\", 1);\r\n    assertPermanentCount(playerA, \"Manta Riders\", 1);\r\n    Permanent controlledMantas = getPermanent(\"Manta Riders\", playerA.getId());\r\n    Assert.assertTrue(\"Manta Riders should have flying ability\", controlledMantas.getAbilities().contains(FlyingAbility.getInstance()));\r\n}"
}, {
	"Path": "cc.mallet.fst.semi_supervised.CRFOptimizableByEntropyRegularization.computeExpectations",
	"Comment": "resets, computes and fills expectations from all instances, also updatingthe entropy value. analogous to crfoptimizablebylabellikelihood.getexpectationvalue.",
	"Method": "void computeExpectations(){\r\n    expectations.zero();\r\n    for (int ii = 0; ii < data.size(); ii++) {\r\n        FeatureVectorSequence input = (FeatureVectorSequence) data.get(ii).getData();\r\n        SumLattice lattice = new SumLatticeDefault(crf, input, true);\r\n        EntropyLattice entropyLattice = new EntropyLattice(input, lattice.getGammas(), lattice.getXis(), crf, incrementor, scalingFactor);\r\n        cachedValue += entropyLattice.getEntropy();\r\n    }\r\n}"
}, {
	"Path": "cc.mallet.topics.DMRTopicModel.getInferencer",
	"Comment": "return a tool for estimating topic distributions for new documents",
	"Method": "DMRInferencer getInferencer(){\r\n    return new DMRInferencer(typeTopicCounts, tokensPerTopic, dmrParameters, alphabet, beta, betaSum);\r\n}"
}, {
	"Path": "cc.mallet.util.DBInstanceStore.intArrayToByteArray",
	"Comment": "convert an array of integers to an array of bytes by copying the bits of each int to four bytes. based on code at java2s.com.",
	"Method": "byte[] intArrayToByteArray(int[] src){\r\n    int srcLength = src.length;\r\n    byte[] dst = new byte[srcLength << 2];\r\n    for (int i = 0; i < srcLength; i++) {\r\n        int x = src[i];\r\n        int j = i << 2;\r\n        dst[j++] = (byte) ((x >>> 0) & 0xff);\r\n        dst[j++] = (byte) ((x >>> 8) & 0xff);\r\n        dst[j++] = (byte) ((x >>> 16) & 0xff);\r\n        dst[j++] = (byte) ((x >>> 24) & 0xff);\r\n    }\r\n    return dst;\r\n}"
}, {
	"Path": "cc.mallet.util.FileUtils.readObject",
	"Comment": "reads a serialized object, which may or may not be zipped.guesses from the file name whether to decompress or not.",
	"Method": "Object readObject(File f){\r\n    String fname = f.getName();\r\n    if (fname.endsWith(\".gz\")) {\r\n        return readGzippedObject(f);\r\n    } else {\r\n        return readUnzippedObject(f);\r\n    }\r\n}"
}, {
	"Path": "org.mage.test.cards.watchers.UnscytheKillerOfKingsTest.testDamagedCreatureDies",
	"Comment": "test that when creature damaged by equipped creature dies a zombie token is created",
	"Method": "void testDamagedCreatureDies(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Unscythe, Killer of Kings\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Prodigal Pyromancer\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Sejiri Merfolk\");\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Equip\", \"Prodigal Pyromancer\");\r\n    activateAbility(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"{T}: {source} deals 1 damage to \", \"Sejiri Merfolk\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertPermanentCount(playerB, \"Sejiri Merfolk\", 0);\r\n    assertPermanentCount(playerA, \"Zombie\", 1);\r\n    assertExileCount(\"Sejiri Merfolk\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.mana.NykthosShrineToNyxTest.testDoubleUseWithKruphix",
	"Comment": "use nykthos together with kruphix, god of horizons to save mana as colorless mana",
	"Method": "void testDoubleUseWithKruphix(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Nykthos, Shrine to Nyx\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Kiora's Follower\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Kalonian Tusker\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Kruphix, God of Horizons\", 1);\r\n    activateManaAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"{2}, {T}: Choose a color. Add an amount of mana of that color equal to your devotion to that color.\");\r\n    setChoice(playerA, \"Green\");\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"{T}: Untap another target permanent.\", \"Nykthos, Shrine to Nyx\");\r\n    activateManaAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"{2}, {T}: Choose a color. Add an amount of mana of that color equal to your devotion to that color.\");\r\n    setChoice(playerA, \"Green\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    Assert.assertEquals(\"amount of colorless mana\", 10, playerA.getManaPool().getColorless());\r\n    assertPowerToughness(playerA, \"Kruphix, God of Horizons\", 4, 7);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.DashTest.testDashedCreatureDiesInCombat",
	"Comment": "also dash returns creatures to your hand at end of turn even if they diedthat turn.",
	"Method": "void testDashedCreatureDiesInCombat(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 2);\r\n    addCard(Zone.HAND, playerA, \"Screamreach Brawler\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Geist of the Moors\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Screamreach Brawler\");\r\n    setChoice(playerA, \"Yes\");\r\n    attack(1, playerA, \"Screamreach Brawler\");\r\n    block(1, playerB, \"Geist of the Moors\", \"Screamreach Brawler\");\r\n    setStopAt(2, PhaseStep.UNTAP);\r\n    execute();\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerA, \"Screamreach Brawler\", 0);\r\n    assertHandCount(playerA, \"Screamreach Brawler\", 0);\r\n    assertGraveyardCount(playerA, \"Screamreach Brawler\", 1);\r\n    assertGraveyardCount(playerB, \"Geist of the Moors\", 1);\r\n}"
}, {
	"Path": "cc.mallet.pipe.StringIterator.peek",
	"Comment": "returns the character beyond the current position, or a null character if the specifiedposition is at the end of the document.",
	"Method": "char peek(int ahead,char peek){\r\n    return peek(0);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.HideawayTest.testMosswortBridge",
	"Comment": "in commander, an opponent cast ulamog, the ceaseless hunger off ofmosswort bridge. after it resolved, another opponent exile ulamog with aquarantine field. ulamog was shown as exile face down, as it had beenfrom the mosswort bridge.",
	"Method": "void testMosswortBridge(){\r\n    addCard(Zone.HAND, playerA, \"Mosswort Bridge\");\r\n    addCard(Zone.LIBRARY, playerA, \"Ulamog, the Ceaseless Hunger\");\r\n    skipInitShuffling();\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Dross Crocodile\", 2);\r\n    playLand(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Mosswort Bridge\");\r\n    setChoice(playerA, \"Ulamog, the Ceaseless Hunger\");\r\n    activateAbility(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"{G},\");\r\n    addTarget(playerA, \"Dross Crocodile^Dross Crocodile\");\r\n    setStopAt(3, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertExileCount(\"Dross Crocodile\", 2);\r\n    assertPermanentCount(playerA, \"Mosswort Bridge\", 1);\r\n    assertExileCount(playerA, 2);\r\n    assertExileCount(\"Ulamog, the Ceaseless Hunger\", 0);\r\n    assertPermanentCount(playerA, \"Ulamog, the Ceaseless Hunger\", 1);\r\n    assertTapped(\"Mosswort Bridge\", true);\r\n    Permanent permanent = getPermanent(\"Ulamog, the Ceaseless Hunger\", playerA);\r\n    Card card = currentGame.getCard(permanent.getId());\r\n    Assert.assertFalse(\"Previous exiled card may be no longer face down\", card.isFaceDown(currentGame));\r\n}"
}, {
	"Path": "org.mage.test.cards.copy.DeceiverOfFormTest.testCopyEndsEndOfTurn",
	"Comment": "when creatures copy the revealed creature, they do not return to theiroriginal state at the end of turn",
	"Method": "void testCopyEndsEndOfTurn(){\r\n    addCard(Zone.LIBRARY, playerA, \"Affa Protector\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Deceiver of Form\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Silvercoat Lion\", 3);\r\n    attack(1, playerA, \"Deceiver of Form\");\r\n    attack(1, playerA, \"Affa Protector\");\r\n    attack(1, playerA, \"Affa Protector\");\r\n    attack(1, playerA, \"Affa Protector\");\r\n    skipInitShuffling();\r\n    setStopAt(2, PhaseStep.PRECOMBAT_MAIN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Deceiver of Form\", 1);\r\n    assertPermanentCount(playerA, \"Silvercoat Lion\", 3);\r\n    assertPowerToughness(playerA, \"Silvercoat Lion\", 2, 2, Filter.ComparisonScope.All);\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 9);\r\n}"
}, {
	"Path": "cc.mallet.types.DenseMatrix.dotProduct",
	"Comment": "xxx perhaps make a special efficient case for binary vectors",
	"Method": "double dotProduct(ConstantMatrix m){\r\n    double ret = 0;\r\n    if (m instanceof DenseMatrix) {\r\n        assert (m.singleSize() == values.length);\r\n        for (int i = 0; i < values.length; i++) ret += values[i] * ((DenseMatrix) m).values[i];\r\n    } else {\r\n        for (int i = m.numLocations() - 1; i >= 0; i--) if (m.indexAtLocation(i) < values.length)\r\n            ret += values[m.indexAtLocation(i)] * m.valueAtLocation(i);\r\n        else {\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.MetalcraftTest.testMetalcraftFromBlinkmoth",
	"Comment": "rusted relic or blinkmoth nexus is bugged\teither relic does not see blinkmoth as an artifact or it does not turn into one when it should.",
	"Method": "void testMetalcraftFromBlinkmoth(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Darksteel Citadel\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Rusted Relic\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Blinkmoth Nexus\", 1);\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"{1}: Until end of turn {this} becomes \");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPowerToughness(playerA, \"Blinkmoth Nexus\", 1, 1);\r\n    assertPowerToughness(playerA, \"Rusted Relic\", 5, 5);\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.EntersTheBattlefieldTriggerTest.testReanimateHarmonicSliver",
	"Comment": "just had a game with harmonic sliver being reanimated or blinked, butnever triggered. only when cast from hand.",
	"Method": "void testReanimateHarmonicSliver(){\r\n    addCard(Zone.GRAVEYARD, playerA, \"Harmonic Sliver\");\r\n    addCard(Zone.HAND, playerA, \"Reanimate\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Juggernaut\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Reanimate\", \"Harmonic Sliver\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Harmonic Sliver\", 1);\r\n    assertGraveyardCount(playerA, \"Reanimate\", 1);\r\n    assertGraveyardCount(playerB, \"Juggernaut\", 1);\r\n    assertLife(playerA, 17);\r\n}"
}, {
	"Path": "cc.mallet.classify.Trial.getPrecision",
	"Comment": "calculate the precision for a particular target index from an \tarray list of classifications",
	"Method": "double getPrecision(Object labelEntry,double getPrecision,Labeling label,double getPrecision,int index){\r\n    int numCorrect = 0;\r\n    int numInstances = 0;\r\n    int trueLabel, classLabel;\r\n    for (int i = 0; i < this.size(); i++) {\r\n        trueLabel = this.get(i).getInstance().getLabeling().getBestIndex();\r\n        classLabel = this.get(i).getLabeling().getBestIndex();\r\n        if (classLabel == index) {\r\n            numInstances++;\r\n            if (trueLabel == index)\r\n                numCorrect++;\r\n        }\r\n    }\r\n    if (numInstances == 0) {\r\n        logger.warning(\"No examples with predicted label \" + classifier.getLabelAlphabet().lookupLabel(index) + \"!\");\r\n        assert (numCorrect == 0);\r\n        return 1;\r\n    }\r\n    return ((double) numCorrect / (double) numInstances);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.EmbalmTest.testCreatureETBAfterEmbalm",
	"Comment": "tests that creature after using embalm will be able to use etb effect from original card",
	"Method": "void testCreatureETBAfterEmbalm(){\r\n    String aSanctions = \"Angel of Sanctions\";\r\n    String yOx = \"Yoked Ox\";\r\n    String wKnight = \"White Knight\";\r\n    String dBlade = \"Doom Blade\";\r\n    addCard(Zone.HAND, playerA, aSanctions);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 11);\r\n    addCard(Zone.HAND, playerB, dBlade);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Swamp\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerB, yOx);\r\n    addCard(Zone.BATTLEFIELD, playerB, wKnight);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, aSanctions);\r\n    addTarget(playerA, yOx);\r\n    castSpell(1, PhaseStep.BEGIN_COMBAT, playerB, dBlade);\r\n    addTarget(playerB, aSanctions);\r\n    activateAbility(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Embalm\");\r\n    addTarget(playerA, wKnight);\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertHandCount(playerB, 0);\r\n    assertPermanentCount(playerA, aSanctions, 1);\r\n    assertPermanentCount(playerB, yOx, 1);\r\n    assertPermanentCount(playerB, wKnight, 0);\r\n    assertGraveyardCount(playerA, aSanctions, 0);\r\n}"
}, {
	"Path": "org.mage.test.combat.AttackPlaneswalkerTest.testAttackPlaneswalkerTriggers",
	"Comment": "tests that attacking a planeswalker triggers and resolves silent skimmercorrectly",
	"Method": "void testAttackPlaneswalkerTriggers(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Kiora, the Crashing Wave\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silent Skimmer\");\r\n    attack(2, playerB, \"Silent Skimmer\", \"Kiora, the Crashing Wave\");\r\n    setStopAt(2, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 18);\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerA, \"Kiora, the Crashing Wave\", 1);\r\n    assertPermanentCount(playerB, \"Silent Skimmer\", 1);\r\n    assertCounterCount(\"Kiora, the Crashing Wave\", CounterType.LOYALTY, 2);\r\n}"
}, {
	"Path": "cc.mallet.types.InstanceList.split",
	"Comment": "shuffles the elements of this list among several smaller lists.",
	"Method": "InstanceList[] split(java.util.Random r,double[] proportions,InstanceList[] split,double[] proportions){\r\n    return split(new java.util.Random(System.currentTimeMillis()), proportions);\r\n}"
}, {
	"Path": "org.mage.test.cards.watchers.DiesExiledTest.testKumanosBlessing",
	"Comment": "test that when creature damaged by enchanted creature dies it is exiled",
	"Method": "void testKumanosBlessing(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 3);\r\n    addCard(Zone.HAND, playerA, \"Kumano's Blessing\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Prodigal Pyromancer\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Sejiri Merfolk\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Kumano's Blessing\", \"Prodigal Pyromancer\");\r\n    activateAbility(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"{T}: {source} deals 1 damage to\", \"Sejiri Merfolk\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertPermanentCount(playerB, \"Sejiri Merfolk\", 0);\r\n    assertExileCount(\"Sejiri Merfolk\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.lose.LoseAbilityTest.testMultiGainVsLoseAbility",
	"Comment": "tests that first gaining multiple copies of ability and then losing it will results in flying not existence",
	"Method": "void testMultiGainVsLoseAbility(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Air Elemental\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 10);\r\n    addCard(Zone.HAND, playerA, \"Grounded\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 10);\r\n    addCard(Zone.HAND, playerA, \"Drake Umbra\", 2);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Drake Umbra\", \"Air Elemental\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Drake Umbra\", \"Air Elemental\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Grounded\", \"Air Elemental\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    Permanent airElemental = getPermanent(\"Air Elemental\", playerA.getId());\r\n    Assert.assertNotNull(airElemental);\r\n    Assert.assertEquals(3, airElemental.getAttachments().size());\r\n    Assert.assertFalse(airElemental.getAbilities().contains(FlyingAbility.getInstance()));\r\n}"
}, {
	"Path": "cc.mallet.classify.AdaBoostM2.getNumWeakClassifiers",
	"Comment": "get the number of weak classifiers in this ensemble classifier",
	"Method": "int getNumWeakClassifiers(){\r\n    return alphas.length;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.UndyingTest.testUndyingMikaeusTheUnhallowed",
	"Comment": "tests that the undying granted by mikaeus, the unhallowed works",
	"Method": "void testUndyingMikaeusTheUnhallowed(){\r\n    addCard(Zone.HAND, playerA, \"Lightning Bolt\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mikaeus, the Unhallowed\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Silvercoat Lion\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Lightning Bolt\", \"Silvercoat Lion\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Lightning Bolt\", 1);\r\n    assertPermanentCount(playerA, \"Silvercoat Lion\", 1);\r\n    assertPermanentCount(playerA, \"Mikaeus, the Unhallowed\", 1);\r\n    assertCounterCount(playerA, \"Silvercoat Lion\", CounterType.P1P1, 1);\r\n    assertPowerToughness(playerA, \"Silvercoat Lion\", 4, 4);\r\n}"
}, {
	"Path": "cc.mallet.pipe.StringIterator.isInArray",
	"Comment": "determines if the specified character exists in the specified character array.",
	"Method": "boolean isInArray(char c,char[] chars){\r\n    for (int i = 0; i < chars.length; i++) {\r\n        if (chars[i] == c) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.mage.test.cards.single.ogw.RealitySmasherTest.testSimpleKillSpellChooseNotToDiscard",
	"Comment": "cannot figure out how to setup any of these tests to work with reality smashers triggered ability",
	"Method": "void testSimpleKillSpellChooseNotToDiscard(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Reality Smasher\");\r\n    addCard(Zone.HAND, playerB, \"Doom Blade\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Swamp\", 2);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Doom Blade\");\r\n    addTarget(playerB, \"Reality Smasher\");\r\n    setChoice(playerB, \"No\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerB, \"Doom Blade\", 1);\r\n    assertPermanentCount(playerA, \"Reality Smasher\", 1);\r\n}"
}, {
	"Path": "cc.mallet.util.FileUtils.writeGzippedObject",
	"Comment": "writes a serialized version of obj to a given file, compressing it using gzip.",
	"Method": "void writeGzippedObject(File f,Serializable obj){\r\n    try {\r\n        ObjectOutputStream oos = new ObjectOutputStream(new BufferedOutputStream(new GZIPOutputStream(new FileOutputStream(f))));\r\n        oos.writeObject(obj);\r\n        oos.close();\r\n    } catch (IOException e) {\r\n        System.err.println(\"Exception writing file \" + f + \": \" + e);\r\n    }\r\n}"
}, {
	"Path": "org.mage.test.cards.control.ExchangeControlTest.testSimpleExchange",
	"Comment": "tests switching controls for two creatures on different sides",
	"Method": "void testSimpleExchange(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 5);\r\n    addCard(Zone.HAND, playerA, \"Switcheroo\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Llanowar Elves\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Elite Vanguard\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Switcheroo\", \"Llanowar Elves^Elite Vanguard\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Elite Vanguard\", 1);\r\n    assertPermanentCount(playerB, \"Llanowar Elves\", 1);\r\n}"
}, {
	"Path": "cc.mallet.cluster.util.ClusterUtils.mergeClusters",
	"Comment": "relabels the clustering to reflect merging clusters i and\tj. relabels all of instances with label j to label i.",
	"Method": "Clustering mergeClusters(Clustering clustering,int labeli,int labelj){\r\n    if (labeli == labelj)\r\n        return clustering;\r\n    InstanceList instances = clustering.getInstances();\r\n    for (int i = 0; i < instances.size(); i++) {\r\n        int idx = clustering.getLabel(i);\r\n        if (idx == labelj)\r\n            clustering.setLabel(i, labeli);\r\n    }\r\n    clustering.setNumLabels(clustering.getNumClusters() - 1);\r\n    for (int i = 0; i < instances.size(); i++) {\r\n        int idx = clustering.getLabel(i);\r\n        if (idx > labelj)\r\n            clustering.setLabel(i, idx - 1);\r\n    }\r\n    return clustering;\r\n}"
}, {
	"Path": "org.mage.test.cards.enchantments.EnchantingGraveyardCardsTest.testSpellwaeverVoluteAndSorcery",
	"Comment": "test that a card in the graveyard can be enchanted and the enchanted cardswitches to a new one",
	"Method": "void testSpellwaeverVoluteAndSorcery(){\r\n    addCard(Zone.HAND, playerA, SPELLWEAVER_VOLUTE, 1);\r\n    addCard(Zone.HAND, playerA, \"Cloak of Feathers\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Silvercoat Lion\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 6);\r\n    addCard(Zone.GRAVEYARD, playerA, \"Aerial Volley\", 1);\r\n    addCard(Zone.GRAVEYARD, playerB, \"Lightning Bolt\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, SPELLWEAVER_VOLUTE, LIGHTNING_BOLT);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Cloak of Feathers\", \"Silvercoat Lion\");\r\n    setChoice(playerA, \"Yes\");\r\n    addTarget(playerA, playerB);\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 17);\r\n    assertHandCount(playerA, 1);\r\n    assertGraveyardCount(playerA, \"Cloak of Feathers\", 1);\r\n    assertPermanentCount(playerA, SPELLWEAVER_VOLUTE, 1);\r\n    assertGraveyardCount(playerA, \"Aerial Volley\", 1);\r\n    assertExileCount(playerB, LIGHTNING_BOLT, 1);\r\n    assertAbility(playerA, \"Silvercoat Lion\", FlyingAbility.getInstance(), true);\r\n    Permanent spellweaver = getPermanent(SPELLWEAVER_VOLUTE);\r\n    Card attachedToCard = null;\r\n    if (spellweaver != null) {\r\n        attachedToCard = playerA.getGraveyard().get(spellweaver.getAttachedTo(), currentGame);\r\n    }\r\n    Assert.assertTrue(SPELLWEAVER_VOLUTE + \" has to be attached to Aerial Volley in graveyard\", attachedToCard != null && attachedToCard.getName().equals(\"Aerial Volley\"));\r\n    assertHandCount(playerA, 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.enters.BanisherPriestTest.testReturningTargetDoesNotTriggerDieEventOfBanisherPriest",
	"Comment": "check that the returning target did not trigger the dies event ofthe dying banisher priest",
	"Method": "void testReturningTargetDoesNotTriggerDieEventOfBanisherPriest(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mountain\", 2);\r\n    addCard(Zone.HAND, playerA, \"Banisher Priest\");\r\n    addCard(Zone.HAND, playerB, \"Incinerate\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Rockslide Elemental\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Banisher Priest\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerB, \"Incinerate\", \"Banisher Priest\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerB, \"Rockslide Elemental\", 1);\r\n    assertPermanentCount(playerA, \"Banisher Priest\", 0);\r\n    assertPowerToughness(playerB, \"Rockslide Elemental\", 1, 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.other.SoulfireGrandMasterTest.testSoulfireStokeTheFlames",
	"Comment": "i activated the ability of soulfire grand master, it resolved, then icast stoke the flames on whisperwood elemental, my opponenet sacrificedthe elemental, so stoke didnt resolve, but i still got the life fromlifelink.",
	"Method": "void testSoulfireStokeTheFlames(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 8);\r\n    addCard(Zone.HAND, playerA, \"Stoke the Flames\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Soulfire Grand Master\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Whisperwood Elemental\", 1);\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"{2}{U/R}{U/R}:\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Stoke the Flames\", \"Whisperwood Elemental\");\r\n    activateAbility(1, PhaseStep.POSTCOMBAT_MAIN, playerB, \"Sacrifice {this}\", null, \"{this} deals 4 damage\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Stoke the Flames\", 1);\r\n    assertGraveyardCount(playerB, \"Whisperwood Elemental\", 1);\r\n    assertLife(playerB, 20);\r\n    assertLife(playerA, 20);\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.OblivionRingTest.testExilePlaneswalker",
	"Comment": "tests that when oblivion ring gets destroyed planeswalker returns withnew counters and can be used second time at the same turn",
	"Method": "void testExilePlaneswalker(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 5);\r\n    addCard(Zone.HAND, playerA, \"Oblivion Ring\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Jace Beleren\");\r\n    addCard(Zone.HAND, playerA, \"Revoke Existence\");\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"-1: Target player draws a card\", playerA);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Oblivion Ring\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Revoke Existence\", \"Oblivion Ring\");\r\n    activateAbility(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"-1: Target player draws a card\", playerA);\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertExileCount(\"Oblivion Ring\", 1);\r\n    assertGraveyardCount(playerA, \"Revoke Existence\", 1);\r\n    assertPermanentCount(playerA, \"Oblivion Ring\", 0);\r\n    assertGraveyardCount(playerA, \"Jace Beleren\", 0);\r\n    assertPermanentCount(playerA, \"Jace Beleren\", 1);\r\n    assertHandCount(playerA, 2);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.MorphTest.testMorphedRemovesAttributesCreature",
	"Comment": "test that morph creature do not trigger abilities with their face upattributes",
	"Method": "void testMorphedRemovesAttributesCreature(){\r\n    addCard(Zone.HAND, playerA, \"Ponyback Brigade\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Soldier of the Pantheon\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Ponyback Brigade\");\r\n    setChoice(playerA, \"Yes\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerA, EmptyNames.FACE_DOWN_CREATURE.toString(), 1);\r\n    assertPermanentCount(playerB, \"Soldier of the Pantheon\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.mana.VorinclexVoiceOfHungerTest.testVorinclexVoiceofHungerRiverOfTearsManaMultiplier",
	"Comment": "vorinclex, voice of hunger is not mana doubling river of tears.",
	"Method": "void testVorinclexVoiceofHungerRiverOfTearsManaMultiplier(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Upwelling\", 1);\r\n    addCard(Zone.HAND, playerA, \"River of Tears\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Vorinclex, Voice of Hunger\", 1);\r\n    playLand(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"River of Tears\");\r\n    activateManaAbility(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"{T}: Add {U}\");\r\n    setStopAt(3, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertManaPool(playerA, ManaType.BLUE, 2);\r\n}"
}, {
	"Path": "cc.mallet.pipe.SimpleTaggerSentence2TokenSequence.parseSentence",
	"Comment": "parses a string representing a sequence of rows of tokens into anarray of arrays of tokens.",
	"Method": "String[][] parseSentence(String sentence){\r\n    String[] lines = sentence.split(\"\\n\");\r\n    String[][] tokens = new String[lines.length][];\r\n    for (int i = 0; i < lines.length; i++) tokens[i] = lines[i].split(\"\\\\s\");\r\n    return tokens;\r\n}"
}, {
	"Path": "cc.mallet.util.Randoms.nextGaussian",
	"Comment": "return a random double drawn from a gaussian distribution with mean m and variance s2.",
	"Method": "double nextGaussian(double nextGaussian,double m,double s2){\r\n    return nextGaussian() * Math.sqrt(s2) + m;\r\n}"
}, {
	"Path": "org.mage.test.cards.copy.FeldonOfTheThirdPathTest.testETBEffect",
	"Comment": "checking that enters the battlefield abilities of the copied creaturecard works.",
	"Method": "void testETBEffect(){\r\n    addCard(Zone.GRAVEYARD, playerA, \"Highway Robber\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Feldon of the Third Path\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 3);\r\n    activateAbility(2, PhaseStep.PRECOMBAT_MAIN, playerA, \"{2}{R}, {T}: Create a token that's a copy of target creature card in your graveyard, except it's an artifact in addition to its other types. It gains haste. Sacrifice it at the beginning of the next end step.\", \"Highway Robber\");\r\n    setStopAt(2, PhaseStep.POSTCOMBAT_MAIN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Highway Robber\", 1);\r\n    assertPermanentCount(playerA, \"Feldon of the Third Path\", 1);\r\n    assertLife(playerA, 22);\r\n    assertLife(playerB, 18);\r\n}"
}, {
	"Path": "cc.mallet.classify.AdaBoost.classify",
	"Comment": "classify the given instance using only the firstnumweakclassifierstouse classifierstrained during boosting",
	"Method": "Classification classify(Instance inst,Classification classify,Instance inst,int numWeakClassifiersToUse){\r\n    if (numWeakClassifiersToUse <= 0 || numWeakClassifiersToUse > weakClassifiers.length)\r\n        throw new IllegalArgumentException(\"number of weak learners to use out of range:\" + numWeakClassifiersToUse);\r\n    FeatureVector fv = (FeatureVector) inst.getData();\r\n    assert (instancePipe == null || fv.getAlphabet() == this.instancePipe.getDataAlphabet());\r\n    int numClasses = getLabelAlphabet().size();\r\n    double[] scores = new double[numClasses];\r\n    int bestIndex;\r\n    double sum = 0;\r\n    for (int round = 0; round < numWeakClassifiersToUse; round++) {\r\n        bestIndex = weakClassifiers[round].classify(inst).getLabeling().getBestIndex();\r\n        scores[bestIndex] += alphas[round];\r\n        sum += scores[bestIndex];\r\n    }\r\n    for (int i = 0; i < scores.length; i++) scores[i] /= sum;\r\n    return new Classification(inst, this, new LabelVector(getLabelAlphabet(), scores));\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.equipped.ScytheOfTheWretchedTest.testEquipAlive",
	"Comment": "test that the creature that died returns to battlefield under yourcontrol if the previous equipped creature does not die",
	"Method": "void testEquipAlive(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Soulmender\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Scythe of the Wretched\");\r\n    activateAbility(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Equip {4}\", \"Silvercoat Lion\");\r\n    attack(2, playerB, \"Silvercoat Lion\");\r\n    block(2, playerA, \"Soulmender\", \"Silvercoat Lion\");\r\n    setStopAt(2, PhaseStep.POSTCOMBAT_MAIN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerA, \"Soulmender\", 0);\r\n    assertPermanentCount(playerB, \"Soulmender\", 1);\r\n    assertPowerToughness(playerB, \"Soulmender\", 3, 3);\r\n    assertPowerToughness(playerB, \"Silvercoat Lion\", 2, 2);\r\n    Permanent silvercoatLion = getPermanent(\"Silvercoat Lion\", playerB.getId());\r\n    Assert.assertTrue(\"Silvercoat Lion may not have any attachments\", silvercoatLion.getAttachments().isEmpty());\r\n}"
}, {
	"Path": "org.mage.test.cards.control.GainControlTargetEffectTest.testSkyfireKirinStealCreatureSameCMC",
	"Comment": "skyfire kirin should steal be able to steal creatures with same cmc.",
	"Method": "void testSkyfireKirinStealCreatureSameCMC(){\r\n    String sKirin = \"Skyfire Kirin\";\r\n    String oGorger = \"Ore Gorger\";\r\n    String aLight = \"Angel of Light\";\r\n    addCard(Zone.BATTLEFIELD, playerA, sKirin);\r\n    addCard(Zone.HAND, playerA, oGorger);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 5);\r\n    addCard(Zone.BATTLEFIELD, playerB, aLight);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, oGorger);\r\n    setChoice(playerA, \"Yes\");\r\n    addTarget(playerA, aLight);\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, oGorger, 1);\r\n    assertPermanentCount(playerA, aLight, 1);\r\n    assertPermanentCount(playerB, aLight, 0);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.oneshot.sacrifice.MorticianBeetleTest.testSacrifice",
	"Comment": "checks that creature with protection black can still be sacrificed",
	"Method": "void testSacrifice(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 4);\r\n    addCard(Zone.HAND, playerA, \"Cruel Edict\");\r\n    addCard(Zone.HAND, playerA, \"Geth's Verdict\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mortician Beetle\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Savannah Lions\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Sigiled Paladin\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Cruel Edict\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Geth's Verdict\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerB, 0);\r\n    assertPowerToughness(playerA, \"Mortician Beetle\", 3, 3);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.lose.LoseAbilityTest.testLoseVsGainAbility",
	"Comment": "tests that first losing ability and then gaining it will results in flying existence",
	"Method": "void testLoseVsGainAbility(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Air Elemental\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 2);\r\n    addCard(Zone.HAND, playerA, \"Grounded\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 6);\r\n    addCard(Zone.HAND, playerA, \"Drake Umbra\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Grounded\", \"Air Elemental\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Drake Umbra\", \"Air Elemental\");\r\n    setStopAt(2, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    Permanent airElemental = getPermanent(\"Air Elemental\", playerA.getId());\r\n    Assert.assertNotNull(airElemental);\r\n    Assert.assertTrue(airElemental.getAttachments().size() == 2);\r\n    Assert.assertTrue(airElemental.getAbilities().contains(FlyingAbility.getInstance()));\r\n}"
}, {
	"Path": "org.mage.test.cards.control.ItThatBetraysTest.testExileItThatBetraysEffectEnchantment",
	"Comment": "i just sacrificed a spreading seas to an attacking it that betrays, andit returned the spreading seas under my control. it made me choose a landto enchant, and i drew a card.",
	"Method": "void testExileItThatBetraysEffectEnchantment(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Silvercoat Lion\", 1);\r\n    addCard(Zone.HAND, playerA, \"Spreading Seas\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"It That Betrays\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mountain\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Spreading Seas\", \"Mountain\");\r\n    attack(2, playerB, \"It That Betrays\");\r\n    setChoice(playerA, \"Spreading Seas\");\r\n    setChoice(playerA, \"Silvercoat Lion\");\r\n    setStopAt(2, PhaseStep.POSTCOMBAT_MAIN);\r\n    execute();\r\n    assertLife(playerA, 9);\r\n    assertLife(playerB, 20);\r\n    assertHandCount(playerA, \"Spreading Seas\", 0);\r\n    assertPermanentCount(playerB, \"Silvercoat Lion\", 1);\r\n    assertPermanentCount(playerA, \"Spreading Seas\", 0);\r\n    assertGraveyardCount(playerA, \"Spreading Seas\", 0);\r\n    assertPermanentCount(playerB, \"Spreading Seas\", 1);\r\n}"
}, {
	"Path": "org.mage.test.AI.basic.TargetsAreChosenTest.testRackAndRuin",
	"Comment": "check that the ai selects a target from the own artifacts and also anartifact from the opponent artficats",
	"Method": "void testRackAndRuin(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 3);\r\n    addCard(Zone.HAND, playerA, \"Rack and Ruin\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mox Emerald\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Juggernaut\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Rack and Ruin\", 1);\r\n    assertGraveyardCount(playerA, \"Mox Emerald\", 1);\r\n    assertGraveyardCount(playerB, \"Juggernaut\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.single.ChronozoaTest.testDuplicationEffect",
	"Comment": "test that the tokens are put to battlefield if the last time counter is removed",
	"Method": "void testDuplicationEffect(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 4);\r\n    addCard(Zone.HAND, playerA, \"Chronozoa\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Chronozoa\");\r\n    setStopAt(9, PhaseStep.PRECOMBAT_MAIN);\r\n    execute();\r\n    assertGraveyardCount(playerA, 1);\r\n    final List<Permanent> creatures = currentGame.getBattlefield().getAllActivePermanents(CardType.CREATURE);\r\n    Assert.assertEquals(2, creatures.size());\r\n    for (final Permanent creature : creatures) {\r\n        Assert.assertEquals(\"Chronozoa\", creature.getName());\r\n        Assert.assertEquals(\"Chronozoa has to be a token\", true, creature instanceof PermanentToken);\r\n        final Counters counters = creature.getCounters(currentGame);\r\n        Assert.assertEquals(1, counters.size());\r\n        for (final Counter counter : counters.values()) {\r\n            Assert.assertEquals(CounterType.TIME.getName(), counter.getName());\r\n            Assert.assertEquals(2, counter.getCount());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mage.test.cards.continuous.DependentEffectsTest.testLandsAreDestroyed",
	"Comment": "opalescence plus enchanted evening are still not wiping any lands.",
	"Method": "void testLandsAreDestroyed(){\r\n    addCard(Zone.HAND, playerA, \"Opalescence\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 9);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"War Horn\", 1);\r\n    addCard(Zone.HAND, playerA, \"Enchanted Evening\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 2);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Opalescence\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Enchanted Evening\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPowerToughness(playerA, \"Enchanted Evening\", 5, 5);\r\n    assertPowerToughness(playerA, \"War Horn\", 3, 3);\r\n    assertPermanentCount(playerA, \"Island\", 0);\r\n    assertPermanentCount(playerB, \"Plains\", 0);\r\n}"
}, {
	"Path": "cc.mallet.classify.MaxEntOptimizableByLabelDistribution.getValueGradientCalls",
	"Comment": "counts how many times this trainer has computed the gradient of the \tlog probability of training labels.",
	"Method": "int getValueGradientCalls(){\r\n    return numGetValueGradientCalls;\r\n}"
}, {
	"Path": "cc.mallet.classify.AdaBoost.getNumWeakClassifiers",
	"Comment": "get the number of weak classifiers in this ensemble classifier",
	"Method": "int getNumWeakClassifiers(){\r\n    return alphas.length;\r\n}"
}, {
	"Path": "cc.mallet.extract.Field.isValue",
	"Comment": "returns true if filler is an exact match to one of the values of this field.",
	"Method": "boolean isValue(String filler,boolean isValue,String filler,FieldComparator comper){\r\n    for (Iterator it = values.iterator(); it.hasNext(); ) {\r\n        String s = (String) it.next();\r\n        if (comper.matches(filler, s))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.BestowTest.bestowEnchantmentBecomesCreature",
	"Comment": "test that the bestow enchantment becomes a creature if the enchantedcreature dies",
	"Method": "void bestowEnchantmentBecomesCreature(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Silvercoat Lion\");\r\n    addCard(Zone.HAND, playerA, \"Hopeful Eidolon\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mountain\", 1);\r\n    addCard(Zone.HAND, playerB, \"Lightning Bolt\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Hopeful Eidolon using bestow\", \"Silvercoat Lion\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerB, \"Lightning Bolt\", \"Silvercoat Lion\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerA, \"Silvercoat Lion\", 0);\r\n    assertPermanentCount(playerA, \"Hopeful Eidolon\", 1);\r\n    assertPowerToughness(playerA, \"Hopeful Eidolon\", 1, 1);\r\n    Permanent hopefulEidolon = getPermanent(\"Hopeful Eidolon\", playerA);\r\n    Assert.assertTrue(\"Hopeful Eidolon has to be a creature but is not\", hopefulEidolon.isCreature());\r\n    Assert.assertTrue(\"Hopeful Eidolon has to be an enchantment but is not\", hopefulEidolon.isEnchantment());\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.OblivionRingTest.testFirstTriggeredAbility",
	"Comment": "when oblivion ring enters the battlefield, exile another target nonlandpermanent.",
	"Method": "void testFirstTriggeredAbility(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 3);\r\n    addCard(Zone.HAND, playerA, \"Oblivion Ring\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Craw Wurm\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Oblivion Ring\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerA, \"Oblivion Ring\", 1);\r\n    assertPermanentCount(playerB, \"Craw Wurm\", 0);\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.OblivionRingTest.testReturningHangarbackWalker",
	"Comment": "oblivion ring leaves from battlefield effect brings hangarback walkerback with counters. but with rules it should come back with no counters",
	"Method": "void testReturningHangarbackWalker(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 4);\r\n    addCard(Zone.HAND, playerA, \"Hangarback Walker\");\r\n    addCard(Zone.HAND, playerA, \"Naturalize\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 3);\r\n    addCard(Zone.HAND, playerB, \"Oblivion Ring\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Hangarback Walker\");\r\n    setChoice(playerA, \"X=2\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Oblivion Ring\");\r\n    castSpell(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"Naturalize\", \"Oblivion Ring\");\r\n    setStopAt(3, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerB, \"Oblivion Ring\", 0);\r\n    assertGraveyardCount(playerB, \"Oblivion Ring\", 1);\r\n    assertPermanentCount(playerA, \"Hangarback Walker\", 0);\r\n    assertGraveyardCount(playerA, \"Hangarback Walker\", 1);\r\n}"
}, {
	"Path": "cc.mallet.classify.MaxEntTrainer.getOptimizer",
	"Comment": "this method is called by the train method. \tthis is the main entry point for the optimizable and optimizer\tcompontents.",
	"Method": "Optimizer getOptimizer(Optimizer getOptimizer,InstanceList trainingSet){\r\n    if (trainingSet != this.trainingSet || optimizable == null) {\r\n        getOptimizable(trainingSet);\r\n        optimizer = null;\r\n    }\r\n    if (optimizer == null) {\r\n        optimizer = new LimitedMemoryBFGS(optimizable);\r\n    }\r\n    return optimizer;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.SoulbondKeywordTest.testChangeControllerAndGettingBack",
	"Comment": "tests soulbond effect disabling when soulbond creature changes itscontroller and then returns back. effect should not be restored.",
	"Method": "void testChangeControllerAndGettingBack(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Elite Vanguard\");\r\n    addCard(Zone.HAND, playerA, \"Trusted Forcemage\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 3);\r\n    addCard(Zone.HAND, playerB, \"Act of Treason\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mountain\", 3);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Trusted Forcemage\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Act of Treason\", \"Trusted Forcemage\");\r\n    setStopAt(3, PhaseStep.PRECOMBAT_MAIN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Trusted Forcemage\", 1);\r\n    assertPowerToughness(playerA, \"Trusted Forcemage\", 2, 2);\r\n    assertPermanentCount(playerA, \"Elite Vanguard\", 1);\r\n    assertPowerToughness(playerA, \"Elite Vanguard\", 2, 1);\r\n}"
}, {
	"Path": "cc.mallet.util.CommandOption.wasInvoked",
	"Comment": "return true is this commandoption was matched by one of the processed arguments.",
	"Method": "boolean wasInvoked(){\r\n    return invoked;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.equipped.HeavyArbalestTest.testUntapsLater",
	"Comment": "tests that creature with heavy arbalest will use it and untap later after equip is equipped to another creature",
	"Method": "void testUntapsLater(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 8);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Heavy Arbalest\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Elite Vanguard\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Llanowar Elves\");\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Equip {4}\", \"Elite Vanguard\");\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"{T}: {source} deals 2 damage\", playerB);\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Equip {4}\", \"Llanowar Elves\");\r\n    setStopAt(5, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 18);\r\n    Permanent eliteVanguard = getPermanent(\"Elite Vanguard\", playerA.getId());\r\n    Assert.assertTrue(eliteVanguard.getAttachments().isEmpty());\r\n    Assert.assertFalse(eliteVanguard.isTapped());\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.flicker.CloudshiftTest.testReturnOfOwnerIsAnotherPlayer",
	"Comment": "test that if a creature returns from cloudshift it returns under thecontrol of the controller of cloudshift.",
	"Method": "void testReturnOfOwnerIsAnotherPlayer(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 3);\r\n    addCard(Zone.HAND, playerA, \"Act of Treason\");\r\n    addCard(Zone.HAND, playerA, \"Cloudshift\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Act of Treason\", \"Silvercoat Lion\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Cloudshift\", \"Silvercoat Lion\");\r\n    setStopAt(2, PhaseStep.PRECOMBAT_MAIN);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Cloudshift\", 1);\r\n    assertGraveyardCount(playerA, \"Act of Treason\", 1);\r\n    assertPermanentCount(playerA, \"Silvercoat Lion\", 1);\r\n    assertPermanentCount(playerB, \"Silvercoat Lion\", 0);\r\n}"
}, {
	"Path": "cc.mallet.classify.RankMaxEnt.getClassificationScoresForTies",
	"Comment": "used by rankmaxenttrainer to calculate the value when the labeling contains ties. does not include scores of tied elements in normalization.",
	"Method": "void getClassificationScoresForTies(Instance instance,double[] scores,int[] bestLabels){\r\n    getClassificationScores(instance, scores);\r\n    for (int i = 1; i < bestLabels.length; i++) scores[bestLabels[i]] = 0.0;\r\n    double sum = 0.0;\r\n    for (int li = 0; li < scores.length; li++) sum += scores[li];\r\n    for (int li = 0; li < scores.length; li++) scores[li] /= sum;\r\n}"
}, {
	"Path": "org.mage.test.cards.enchantments.EnchantingGraveyardCardsTest.testSpellwaeverVoluteAndReturnToHand",
	"Comment": "test that a card in the graveyard can be enchanted and if the enchantmentreturns to hand, the enchanting ends",
	"Method": "void testSpellwaeverVoluteAndReturnToHand(){\r\n    addCard(Zone.HAND, playerA, SPELLWEAVER_VOLUTE, 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 5);\r\n    addCard(Zone.GRAVEYARD, playerB, \"Lightning Bolt\", 1);\r\n    addCard(Zone.HAND, playerB, \"Boomerang\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, SPELLWEAVER_VOLUTE, LIGHTNING_BOLT);\r\n    castSpell(1, PhaseStep.BEGIN_COMBAT, playerB, \"Boomerang\", SPELLWEAVER_VOLUTE);\r\n    setStopAt(1, PhaseStep.POSTCOMBAT_MAIN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertHandCount(playerA, SPELLWEAVER_VOLUTE, 1);\r\n    assertGraveyardCount(playerB, \"Boomerang\", 1);\r\n    assertPermanentCount(playerA, SPELLWEAVER_VOLUTE, 0);\r\n    for (Card card : playerB.getGraveyard().getCards(currentGame)) {\r\n        if (card.getName().equals(LIGHTNING_BOLT)) {\r\n            Assert.assertTrue(LIGHTNING_BOLT + \" may not have any attachments\", card.getAttachments().isEmpty());\r\n        }\r\n    }\r\n    assertHandCount(playerA, 1);\r\n}"
}, {
	"Path": "cc.mallet.types.CrossValidationIterator.clear",
	"Comment": "calls clear on each fold. it is recommended that this be always be calledwhen the iterator is no longer needed so that implementations ofinstancelist such as pagedinstancelist can clean up any temporary datathey may have outside the jvm.",
	"Method": "void clear(){\r\n    for (InstanceList list : this.folds) {\r\n        list.clear();\r\n    }\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.state.SynodCenturionTest.testAlone",
	"Comment": "check that synod centurion gets sacrificed if no other artifacts are on the battlefield",
	"Method": "void testAlone(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 6);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Demon's Horn\");\r\n    addCard(Zone.HAND, playerA, \"Shatter\");\r\n    addCard(Zone.HAND, playerA, \"Synod Centurion\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Synod Centurion\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Shatter\", \"Demon's Horn\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Demon's Horn\", 1);\r\n    assertGraveyardCount(playerA, \"Shatter\", 1);\r\n    assertGraveyardCount(playerA, \"Synod Centurion\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.cost.additional.PhyrexianPurgeTest.bouncedCreatureStillPaysFullCost",
	"Comment": "target two creatures, one of them bounced before resolution. still pay 6 life.",
	"Method": "void bouncedCreatureStillPaysFullCost(){\r\n    String pPurge = \"Phyrexian Purge\";\r\n    addCard(Zone.HAND, playerA, pPurge);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 2);\r\n    addCard(Zone.HAND, playerB, \"Unsummon\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Memnite\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Hill Giant\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, pPurge);\r\n    addTarget(playerA, \"Memnite^Hill Giant\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Unsummon\", \"Hill Giant\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, pPurge, 1);\r\n    assertGraveyardCount(playerB, \"Unsummon\", 1);\r\n    assertGraveyardCount(playerB, \"Memnite\", 1);\r\n    assertHandCount(playerB, \"Hill Giant\", 1);\r\n    assertLife(playerA, 14);\r\n}"
}, {
	"Path": "cc.mallet.types.Alphabet.toString",
	"Comment": "return string representation of all alphabet entries, eachseparated by a newline.",
	"Method": "String toString(){\r\n    lock.readLock().lock();\r\n    try {\r\n        StringBuilder sb = new StringBuilder();\r\n        for (int i = 0; i < entries.size(); i++) {\r\n            sb.append(entries.get(i).toString());\r\n            sb.append('\\n');\r\n        }\r\n        return sb.toString();\r\n    } finally {\r\n        lock.readLock().unlock();\r\n    }\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.MistcutterHydraTest.testHydraReturnsAfterCounterWithZeroCounters",
	"Comment": "test that a apocalypse hydra countered returns with 0 counters to battlefield ifput to battlefield with beacon of unrest",
	"Method": "void testHydraReturnsAfterCounterWithZeroCounters(){\r\n    addCard(Zone.HAND, playerA, \"Apocalypse Hydra\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 1);\r\n    addCard(Zone.HAND, playerA, \"Beacon of Unrest\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 3);\r\n    addCard(Zone.HAND, playerB, \"Counterspell\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Apocalypse Hydra\");\r\n    setChoice(playerA, \"X=3\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Counterspell\", \"Apocalypse Hydra\");\r\n    castSpell(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"Beacon of Unrest\", \"Apocalypse Hydra\");\r\n    setStopAt(3, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerB, \"Counterspell\", 1);\r\n    assertHandCount(playerA, \"Beacon of Unrest\", 0);\r\n    assertPermanentCount(playerA, \"Apocalypse Hydra\", 0);\r\n    assertGraveyardCount(playerA, \"Apocalypse Hydra\", 1);\r\n}"
}, {
	"Path": "cc.mallet.types.InstanceList.splitInTwoByModulo",
	"Comment": "returns a pair of new lists such that the first list in the pair containsevery mth element of this list, starting with the first.the second list contains all remaining elements.",
	"Method": "InstanceList[] splitInTwoByModulo(int m){\r\n    InstanceList[] ret = new InstanceList[2];\r\n    ret[0] = this.cloneEmpty();\r\n    ret[1] = this.cloneEmpty();\r\n    for (int i = 0; i < this.size(); i++) {\r\n        if (i % m == 0)\r\n            ret[0].add(this.get(i));\r\n        else\r\n            ret[1].add(this.get(i));\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.MistcutterHydraTest.testHydraReturnsWithZeroCounters",
	"Comment": "test that a mistcutter hydra exiled with banishing light returns with 0 counters on it",
	"Method": "void testHydraReturnsWithZeroCounters(){\r\n    addCard(Zone.HAND, playerA, \"Banishing Light\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 3);\r\n    addCard(Zone.HAND, playerB, \"Mistcutter Hydra\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Forest\", 2);\r\n    addCard(Zone.HAND, playerB, \"Disenchant\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 2);\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Mistcutter Hydra\");\r\n    setChoice(playerB, \"X=3\");\r\n    castSpell(3, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Banishing Light\");\r\n    setChoice(playerA, \"Mistcutter Hydra\");\r\n    castSpell(4, PhaseStep.PRECOMBAT_MAIN, playerB, \"Disenchant\", \"Banishing Light\");\r\n    setStopAt(4, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerA, \"Banishing Light\", 1);\r\n    assertGraveyardCount(playerB, \"Disenchant\", 1);\r\n    assertGraveyardCount(playerB, \"Mistcutter Hydra\", 1);\r\n    assertPermanentCount(playerB, \"Mistcutter Hydra\", 0);\r\n}"
}, {
	"Path": "org.mage.test.serverside.base.impl.CardTestAPIImpl.getCardList",
	"Comment": "returns card list containter for specified game zone and player.",
	"Method": "List<Card> getCardList(Zone gameZone,Player player){\r\n    if (player.equals(playerA)) {\r\n        if (gameZone == Zone.HAND) {\r\n            return handCardsA;\r\n        } else if (gameZone == Zone.GRAVEYARD) {\r\n            return graveyardCardsA;\r\n        } else if (gameZone == Zone.LIBRARY) {\r\n            return libraryCardsA;\r\n        }\r\n    } else if (player.equals(playerB)) {\r\n        if (gameZone == Zone.HAND) {\r\n            return handCardsB;\r\n        } else if (gameZone == Zone.GRAVEYARD) {\r\n            return graveyardCardsB;\r\n        } else if (gameZone == Zone.LIBRARY) {\r\n            return libraryCardsB;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.mage.test.cards.facedown.GhastlyConscriptionTest.testGhastlyConscription",
	"Comment": "test that cards exiled using ghastly conscription return face down",
	"Method": "void testGhastlyConscription(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 7);\r\n    addCard(Zone.HAND, playerA, \"Ghastly Conscription\");\r\n    addCard(Zone.GRAVEYARD, playerA, \"Ashcloud Phoenix\");\r\n    addCard(Zone.GRAVEYARD, playerA, \"Goblin Roughrider\");\r\n    addCard(Zone.GRAVEYARD, playerA, \"Island\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Ghastly Conscription\", playerA);\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerA, 2);\r\n    assertPermanentCount(playerA, EmptyNames.FACE_DOWN_CREATURE.toString(), 2);\r\n}"
}, {
	"Path": "org.mage.test.AI.basic.TargetsAreChosenTest.testRackAndRuin2",
	"Comment": "check that the ai does not cast rack and ruin if it would destroy theonly creature on the battlefield owned by the ai",
	"Method": "void testRackAndRuin2(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 3);\r\n    addCard(Zone.HAND, playerA, \"Rack and Ruin\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mox Emerald\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Juggernaut\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Rack and Ruin\", 0);\r\n}"
}, {
	"Path": "cc.mallet.extract.TransducerExtractionConfidenceEstimator.getSegmentBoundaries",
	"Comment": "convert the indices of a labeledspan into indices for a tokenization.",
	"Method": "int[] getSegmentBoundaries(Tokenization tokens,LabeledSpan labeledSpan){\r\n    int startCharIndex = labeledSpan.getStartIdx();\r\n    int endCharIndex = labeledSpan.getEndIdx() - 1;\r\n    int[] ret = new int[] { -1, -1 };\r\n    for (int i = 0; i < tokens.size(); i++) {\r\n        int charIndex = tokens.getSpan(i).getStartIdx();\r\n        if (charIndex <= endCharIndex && charIndex >= startCharIndex) {\r\n            if (ret[0] == -1) {\r\n                ret[0] = i;\r\n                ret[1] = i;\r\n            } else\r\n                ret[1] = i;\r\n        }\r\n    }\r\n    if (ret[0] == -1 || ret[1] == -1)\r\n        throw new IllegalArgumentException(\"Unable to find segment boundaries from span \" + labeledSpan);\r\n    return ret;\r\n}"
}, {
	"Path": "org.mage.test.AI.basic.TargetsAreChosenTest.testRackAndRuin3",
	"Comment": "check that the ai does cast rack and ruin if it would destroy two targetsof the opponent",
	"Method": "void testRackAndRuin3(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 3);\r\n    addCard(Zone.HAND, playerA, \"Rack and Ruin\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mox Emerald\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Juggernaut\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Composite Golem\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mox Emerald\", 1);\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Rack and Ruin\", 1);\r\n    assertGraveyardCount(playerB, \"Mox Emerald\", 2);\r\n}"
}, {
	"Path": "cc.mallet.fst.semi_supervised.tui.SimpleTaggerWithConstraints.trainGE",
	"Comment": "create and train a crf model from the given training data,optionally testing it on the given test data.",
	"Method": "CRF trainGE(InstanceList training,InstanceList testing,ArrayList<GEConstraint> constraints,CRF crf,TransducerEvaluator eval,int iterations,double var,int resets){\r\n    logger.info(\"Training on \" + training.size() + \" instances\");\r\n    if (testing != null)\r\n        logger.info(\"Testing on \" + testing.size() + \" instances\");\r\n    assert (numThreads.value > 0);\r\n    CRFTrainerByGE trainer = new CRFTrainerByGE(crf, constraints, numThreads.value);\r\n    if (eval != null)\r\n        trainer.addEvaluator(eval);\r\n    trainer.setGaussianPriorVariance(var);\r\n    trainer.setNumResets(resets);\r\n    trainer.train(training, iterations);\r\n    return crf;\r\n}"
}, {
	"Path": "cc.mallet.pipe.StringIterator.reset",
	"Comment": "sets the current document and resets the current position to the start of it.",
	"Method": "void reset(String text){\r\n    if (text == null) {\r\n        throw new NullPointerException(\"\\\"text\\\" should not be null\");\r\n    }\r\n    text_ = text;\r\n    position_ = 0;\r\n}"
}, {
	"Path": "cc.mallet.types.SparseMatrixn.getIndices",
	"Comment": "returns an array of all the present indices.callers must not modify the return value.",
	"Method": "int[] getIndices(){\r\n    return values.getIndices();\r\n}"
}, {
	"Path": "org.mage.test.cards.single.MisdirectionTest.test_ChangePublicExecution",
	"Comment": "check to change target permanent creature legal to to a creature the opponent of the spell controller controls",
	"Method": "void test_ChangePublicExecution(){\r\n    addCard(Zone.HAND, playerA, \"Public Execution\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 6);\r\n    addCard(Zone.HAND, playerB, \"Misdirection\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Pillarfield Ox\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Custodian of the Trove\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 5);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Public Execution\", \"Pillarfield Ox\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Misdirection\", \"Public Execution\", \"Public Execution\");\r\n    addTarget(playerB, \"Custodian of the Trove\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertAllCommandsUsed();\r\n    assertGraveyardCount(playerA, \"Public Execution\", 1);\r\n    assertGraveyardCount(playerB, \"Misdirection\", 1);\r\n    assertGraveyardCount(playerB, \"Custodian of the Trove\", 1);\r\n    assertPermanentCount(playerB, \"Pillarfield Ox\", 1);\r\n    assertPowerToughness(playerB, \"Pillarfield Ox\", 0, 4);\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.SacredGroundTest.testWithSurgicalExtraction",
	"Comment": "i was playing against sacred ground. i molten rained oponents land andresponded sacred ground trigger by exiling it with surgical extraction.then after that resolved, sacred ground ability put the land from exileonto the battfield! fix this, please",
	"Method": "void testWithSurgicalExtraction(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 2);\r\n    addCard(Zone.HAND, playerA, \"Molten Rain\");\r\n    addCard(Zone.HAND, playerA, \"Surgical Extraction\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Caves of Koilos\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Sacred Ground\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Molten Rain\", \"Caves of Koilos\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Surgical Extraction\", \"Caves of Koilos\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Molten Rain\", 1);\r\n    assertGraveyardCount(playerA, \"Surgical Extraction\", 1);\r\n    assertExileCount(\"Caves of Koilos\", 1);\r\n    assertLife(playerA, 18);\r\n    assertLife(playerB, 18);\r\n}"
}, {
	"Path": "org.mage.test.multiplayer.PlayerLeftGameRangeAllTest.TestThaliaHereticCatharContinuousEffectEndsIfPlayerConcedes",
	"Comment": "in an edh game, a player controlling thalia left the game and the abilitystill lasted for the rest of the game. gamelog if it helps.",
	"Method": "void TestThaliaHereticCatharContinuousEffectEndsIfPlayerConcedes(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 3);\r\n    addCard(Zone.HAND, playerA, \"Thalia, Heretic Cathar\");\r\n    addCard(Zone.HAND, playerD, \"Juggernaut\");\r\n    addCard(Zone.BATTLEFIELD, playerD, \"Plains\", 4);\r\n    addCard(Zone.HAND, playerC, \"Pillarfield Ox\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerC, \"Plains\", 4);\r\n    addCard(Zone.HAND, playerB, \"Silvercoat Lion\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 2);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Thalia, Heretic Cathar\");\r\n    concede(2, PhaseStep.PRECOMBAT_MAIN, playerA);\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerD, \"Juggernaut\");\r\n    castSpell(3, PhaseStep.PRECOMBAT_MAIN, playerC, \"Pillarfield Ox\");\r\n    castSpell(4, PhaseStep.PRECOMBAT_MAIN, playerB, \"Silvercoat Lion\");\r\n    setStopAt(4, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    Assert.assertFalse(\"Player D is no longer in the game\", playerA.isInGame());\r\n    assertLife(playerA, 2);\r\n    assertPermanentCount(playerD, \"Juggernaut\", 1);\r\n    assertPermanentCount(playerC, \"Pillarfield Ox\", 1);\r\n    assertPermanentCount(playerB, \"Silvercoat Lion\", 1);\r\n    assertTapped(\"Pillarfield Ox\", false);\r\n    assertTapped(\"Silvercoat Lion\", false);\r\n    assertTapped(\"Juggernaut\", false);\r\n}"
}, {
	"Path": "cc.mallet.fst.CRFCacheStaleIndicator.isGradientStale",
	"Comment": "returns true if the gradient is stale, also updates the cachegradientstamp.",
	"Method": "boolean isGradientStale(){\r\n    if (crf.weightsValueChangeStamp != cachedGradientChangeStamp) {\r\n        cachedGradientChangeStamp = crf.weightsValueChangeStamp;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "cc.mallet.topics.ParallelTopicModel.getProbEstimator",
	"Comment": "return a tool for evaluating the marginal probability of new documentsunder this model",
	"Method": "MarginalProbEstimator getProbEstimator(){\r\n    return new MarginalProbEstimator(numTopics, alpha, alphaSum, beta, typeTopicCounts, tokensPerTopic);\r\n}"
}, {
	"Path": "cc.mallet.classify.MaxEntTrainer.setNumIterations",
	"Comment": "is that a bug?if so, should the default numiterations be higher?",
	"Method": "MaxEntTrainer setNumIterations(int i){\r\n    numIterations = i;\r\n    return this;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.SoulbondKeywordTest.testPairOnPostAnimatedLand",
	"Comment": "tests no effect whether land was animated after soulbond creature hasentered the battlefield",
	"Method": "void testPairOnPostAnimatedLand(){\r\n    addCard(Zone.HAND, playerA, \"Trusted Forcemage\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Blinkmoth Nexus\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Trusted Forcemage\");\r\n    activateAbility(1, PhaseStep.BEGIN_COMBAT, playerA, \"{1}: \");\r\n    setStopAt(1, PhaseStep.DECLARE_ATTACKERS);\r\n    execute();\r\n    assertPowerToughness(playerA, \"Trusted Forcemage\", 2, 2);\r\n    assertPowerToughness(playerA, \"Blinkmoth Nexus\", 1, 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.copy.LazavDimirMastermindTest.testCopyCreatureExiled",
	"Comment": "tests if lazav remains a copy of the creature after it is exiled",
	"Method": "void testCopyCreatureExiled(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Lazav, Dimir Mastermind\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Codex Shredder\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 2);\r\n    addCard(Zone.HAND, playerA, \"Rest in Peace\", 1);\r\n    addCard(Zone.LIBRARY, playerB, \"Assault Griffin\", 5);\r\n    skipInitShuffling();\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"{T}: Target player puts the top card of their library into their graveyard.\", playerB);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Rest in Peace\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Lazav, Dimir Mastermind\", 1);\r\n    assertPowerToughness(playerA, \"Lazav, Dimir Mastermind\", 3, 2);\r\n    Permanent lazav = getPermanent(\"Lazav, Dimir Mastermind\", playerA.getId());\r\n    Assert.assertTrue(lazav.getSubtype(currentGame).contains(SubType.GRIFFIN));\r\n    Assert.assertTrue(\"Lazav, Dimir Mastermind must have flying\", lazav.getAbilities().contains(FlyingAbility.getInstance()));\r\n}"
}, {
	"Path": "org.mage.test.cards.copy.ArtisanOfFormsTest.testCopyTriggeredByCracklingCounterpart",
	"Comment": "targeting a artisan of forms triggers it heroic ability. so it can copy atarget creature. if cackling counterpart later resolves, it should copythe creature that artisan of forms copies, not the artisan itself.",
	"Method": "void testCopyTriggeredByCracklingCounterpart(){\r\n    addCard(Zone.HAND, playerA, \"Artisan of Forms\");\r\n    addCard(Zone.HAND, playerA, \"Cackling Counterpart\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 5);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Artisan of Forms\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Cackling Counterpart\", \"Artisan of Forms\");\r\n    addTarget(playerA, \"Silvercoat Lion\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerA, \"Cackling Counterpart\", 1);\r\n    assertPermanentCount(playerA, \"Artisan of Forms\", 0);\r\n    assertPermanentCount(playerB, \"Silvercoat Lion\", 1);\r\n    assertPermanentCount(playerA, \"Silvercoat Lion\", 2);\r\n    for (Permanent permanent : currentGame.getBattlefield().getAllActivePermanents(playerA.getId())) {\r\n        if (permanent.getName().equals(\"Silvercoat Lion\")) {\r\n            Assert.assertEquals(\"Creature has to have Cast + Heroic ability\", 2, permanent.getAbilities().size());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "cc.mallet.classify.MaxEntOptimizableByLabelDistribution.getValue",
	"Comment": "return the log probability of the training label distributions",
	"Method": "double getValue(){\r\n    if (cachedValueStale) {\r\n        numGetValueCalls++;\r\n        cachedValue = 0;\r\n        cachedGradientStale = true;\r\n        MatrixOps.setAll(cachedGradient, 0.0);\r\n        double[] scores = new double[trainingList.getTargetAlphabet().size()];\r\n        double value = 0.0;\r\n        Iterator<Instance> iter = trainingList.iterator();\r\n        int ii = 0;\r\n        while (iter.hasNext()) {\r\n            ii++;\r\n            Instance instance = iter.next();\r\n            double instanceWeight = trainingList.getInstanceWeight(instance);\r\n            Labeling labeling = instance.getLabeling();\r\n            if (labeling == null)\r\n                continue;\r\n            this.theClassifier.getClassificationScores(instance, scores);\r\n            FeatureVector fv = (FeatureVector) instance.getData();\r\n            value = 0.0;\r\n            for (int pos = 0; pos < labeling.numLocations(); pos++) {\r\n                int ll = labeling.indexAtLocation(pos);\r\n                if (scores[ll] == 0 && labeling.valueAtLocation(pos) > 0) {\r\n                    logger.warning(\"Instance \" + instance.getSource() + \" has infinite value; skipping value and gradient\");\r\n                    cachedValue = Double.NEGATIVE_INFINITY;\r\n                    cachedValueStale = false;\r\n                    return cachedValue;\r\n                } else if (labeling.valueAtLocation(pos) != 0) {\r\n                    value -= (instanceWeight * labeling.valueAtLocation(pos) * Math.log(scores[ll]));\r\n                }\r\n            }\r\n            if (Double.isNaN(value)) {\r\n                logger.fine(\"MaxEntOptimizableByLabelDistribution: Instance \" + instance.getName() + \"has NaN value.\");\r\n            }\r\n            if (Double.isInfinite(value)) {\r\n                logger.warning(\"Instance \" + instance.getSource() + \" has infinite value; skipping value and gradient\");\r\n                cachedValue -= value;\r\n                cachedValueStale = false;\r\n                return -value;\r\n            }\r\n            cachedValue += value;\r\n            for (int si = 0; si < scores.length; si++) {\r\n                if (scores[si] == 0)\r\n                    continue;\r\n                assert (!Double.isInfinite(scores[si]));\r\n                MatrixOps.rowPlusEquals(cachedGradient, numFeatures, si, fv, -instanceWeight * scores[si]);\r\n                cachedGradient[numFeatures * si + defaultFeatureIndex] += (-instanceWeight * scores[si]);\r\n            }\r\n        }\r\n        double prior = 0;\r\n        for (int li = 0; li < numLabels; li++) {\r\n            for (int fi = 0; fi < numFeatures; fi++) {\r\n                double param = parameters[li * numFeatures + fi];\r\n                prior += param * param / (2 * gaussianPriorVariance);\r\n            }\r\n        }\r\n        double oValue = cachedValue;\r\n        cachedValue += prior;\r\n        cachedValue *= -1.0;\r\n        cachedValueStale = false;\r\n        progressLogger.info(\"Value (labelProb=\" + (-oValue) + \" prior=\" + (-prior) + \") loglikelihood = \" + cachedValue);\r\n    }\r\n    return cachedValue;\r\n}"
}, {
	"Path": "cc.mallet.fst.CRFOptimizableByLabelLikelihood.getValue",
	"Comment": "returns the log probability of the training sequence labels and the prior over parameters.",
	"Method": "double getValue(){\r\n    if (crf.weightsValueChangeStamp != cachedValueWeightsStamp) {\r\n        cachedValueWeightsStamp = crf.weightsValueChangeStamp;\r\n        long startingTime = System.currentTimeMillis();\r\n        cachedValue = getExpectationValue();\r\n        if (usingHyperbolicPrior)\r\n            cachedValue += crf.parameters.hyberbolicPrior(hyperbolicPriorSlope, hyperbolicPriorSharpness);\r\n        else\r\n            cachedValue += crf.parameters.gaussianPrior(gaussianPriorVariance);\r\n        assert (!(Double.isNaN(cachedValue) || Double.isInfinite(cachedValue))) : \"Label likelihood is NaN/Infinite\";\r\n        logger.info(\"getValue() (loglikelihood, optimizable by label likelihood) = \" + cachedValue);\r\n        long endingTime = System.currentTimeMillis();\r\n        logger.fine(\"Inference milliseconds = \" + (endingTime - startingTime));\r\n    }\r\n    return cachedValue;\r\n}"
}, {
	"Path": "cc.mallet.types.AugmentableFeatureVector.removeDuplicates",
	"Comment": "note that this method relies on the indices being sorted first",
	"Method": "void removeDuplicates(int numDuplicates){\r\n    if (indices == null)\r\n        return;\r\n    if (numDuplicates == 0)\r\n        for (int i = 1; i < size; i++) if (indices[i - 1] == indices[i])\r\n            numDuplicates++;\r\n    if (numDuplicates == 0)\r\n        return;\r\n    assert (indices.length - numDuplicates > 0) : \"size=\" + size + \" indices.length=\" + indices.length + \" numDuplicates=\" + numDuplicates;\r\n    int[] newIndices = new int[size - numDuplicates];\r\n    double[] newValues = values == null ? null : new double[size - numDuplicates];\r\n    newIndices[0] = indices[0];\r\n    assert (indices.length >= size);\r\n    for (int i = 0, j = 0; i < size - 1; i++) {\r\n        if (indices[i] == indices[i + 1]) {\r\n            if (values != null)\r\n                newValues[j] += values[i];\r\n        } else {\r\n            newIndices[j] = indices[i];\r\n            if (values != null)\r\n                newValues[j] += values[i];\r\n            j++;\r\n        }\r\n        if (i == size - 2) {\r\n            if (values != null)\r\n                newValues[j] += values[i + 1];\r\n            newIndices[j] = indices[i + 1];\r\n        }\r\n    }\r\n    this.indices = newIndices;\r\n    this.values = newValues;\r\n    this.size -= numDuplicates;\r\n    this.maxSortedIndex = size - 1;\r\n}"
}, {
	"Path": "cc.mallet.types.InstanceList.getPipe",
	"Comment": "returns the pipe through which each added instance is passed,which may be null.",
	"Method": "Pipe getPipe(){\r\n    return pipe;\r\n}"
}, {
	"Path": "cc.mallet.share.upenn.MaxEntShell.train",
	"Comment": "train a maxent classifier. each row of features\trepresents the features of a training instance. the label for\tthat instance is in the corresponding position of\tlabels.",
	"Method": "Classifier train(String[][] features,String[] labels,double var,File save,Classifier train,Iterator<Instance> data,double var,File save){\r\n    Alphabet features = new Alphabet();\r\n    LabelAlphabet labels = new LabelAlphabet();\r\n    Pipe instancePipe = new SerialPipes(new Pipe[] { new Target2Label(labels), new TokenSequence2FeatureSequence(features), new FeatureSequence2FeatureVector() });\r\n    InstanceList trainingList = new InstanceList(instancePipe);\r\n    trainingList.addThruPipe(data);\r\n    logger.info(\"# features = \" + features.size());\r\n    logger.info(\"# labels = \" + labels.size());\r\n    logger.info(\"# training instances = \" + trainingList.size());\r\n    ClassifierTrainer trainer = new MaxEntTrainer(var);\r\n    Classifier classifier = trainer.train(trainingList);\r\n    logger.info(\"The training accuracy is \" + classifier.getAccuracy(trainingList));\r\n    features.stopGrowth();\r\n    if (save != null) {\r\n        ObjectOutputStream s = new ObjectOutputStream(new FileOutputStream(save));\r\n        s.writeObject(classifier);\r\n        s.close();\r\n    }\r\n    return classifier;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.ManifestTest.testETBTriggeredAbilities",
	"Comment": "tests that etb triggered abilities did not trigger for manifested cards",
	"Method": "void testETBTriggeredAbilities(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 2);\r\n    addCard(Zone.HAND, playerA, \"Soul Summons\");\r\n    addCard(Zone.LIBRARY, playerA, \"Tranquil Cove\");\r\n    skipInitShuffling();\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Soul Summons\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertAllCommandsUsed();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerA, EmptyNames.FACE_DOWN_CREATURE.toString(), 1);\r\n    assertPowerToughness(playerA, EmptyNames.FACE_DOWN_CREATURE.toString(), 2, 2);\r\n    assertTapped(EmptyNames.FACE_DOWN_CREATURE.toString(), false);\r\n}"
}, {
	"Path": "cc.mallet.classify.MaxEntTrainer.setGaussianPriorVariance",
	"Comment": "sets a parameter to prevent overtraining.a smaller variance for the prior\tmeans that feature weights are expected to hover closer to 0, so extra\tevidence is required to set a higher weight.",
	"Method": "MaxEntTrainer setGaussianPriorVariance(double gaussianPriorVariance){\r\n    this.gaussianPriorVariance = gaussianPriorVariance;\r\n    return this;\r\n}"
}, {
	"Path": "cc.mallet.util.Randoms.nextGamma",
	"Comment": "return a random double drawn from a gamma distribution with mean alphabeta and variance alpha",
	"Method": "double nextGamma(double nextGamma,double alpha,double nextGamma,double alpha,double beta,double nextGamma,double alpha,double beta,double lambda){\r\n    double gamma = 0;\r\n    if (alpha <= 0 || beta <= 0) {\r\n        throw new IllegalArgumentException(\"alpha and beta must be strictly positive.\");\r\n    }\r\n    if (alpha < 1) {\r\n        double b, p;\r\n        boolean flag = false;\r\n        b = 1 + alpha * ONE_OVER_E;\r\n        while (!flag) {\r\n            p = b * nextUniform();\r\n            if (p > 1) {\r\n                gamma = -Math.log((b - p) / alpha);\r\n                if (nextUniform() <= Math.pow(gamma, alpha - 1)) {\r\n                    flag = true;\r\n                }\r\n            } else {\r\n                gamma = Math.pow(p, 1.0 / alpha);\r\n                if (nextUniform() <= Math.exp(-gamma)) {\r\n                    flag = true;\r\n                }\r\n            }\r\n        }\r\n    } else if (alpha == 1) {\r\n        gamma = -Math.log(nextUniform());\r\n    } else {\r\n        double b = alpha - 1;\r\n        double c = 3 * alpha - 0.75;\r\n        double u, v;\r\n        double w, y, z;\r\n        boolean accept = false;\r\n        while (!accept) {\r\n            u = nextUniform();\r\n            v = nextUniform();\r\n            w = u * (1 - u);\r\n            y = Math.sqrt(c / w) * (u - 0.5);\r\n            gamma = b + y;\r\n            if (gamma >= 0.0) {\r\n                z = 64 * w * w * w * v * v;\r\n                accept = z <= 1.0 - ((2 * y * y) / gamma);\r\n                if (!accept) {\r\n                    accept = (Math.log(z) <= 2 * (b * Math.log(gamma / b) - y));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return beta * gamma + lambda;\r\n}"
}, {
	"Path": "cc.mallet.classify.AdaBoostM2Trainer.train",
	"Comment": "boosting method that resamples instances using their weights",
	"Method": "AdaBoostM2 train(InstanceList trainingList){\r\n    FeatureSelection selectedFeatures = trainingList.getFeatureSelection();\r\n    if (selectedFeatures != null)\r\n        throw new UnsupportedOperationException(\"FeatureSelection not yet implemented.\");\r\n    int numClasses = trainingList.getTargetAlphabet().size();\r\n    int numInstances = trainingList.size();\r\n    InstanceList trainingInsts = new InstanceList(trainingList.getPipe());\r\n    double[] weights = new double[numInstances * (numClasses - 1)];\r\n    double w = 1.0 / weights.length;\r\n    Arrays.fill(weights, w);\r\n    int[] classIndices = new int[weights.length];\r\n    int numAdded = 0;\r\n    for (int i = 0; i < numInstances; i++) {\r\n        Instance inst = trainingList.get(i);\r\n        int trueClassIndex = inst.getLabeling().getBestIndex();\r\n        for (int j = 0; j < numClasses; j++) {\r\n            if (j != trueClassIndex) {\r\n                trainingInsts.add(inst, 1);\r\n                classIndices[numAdded] = j;\r\n                numAdded++;\r\n            }\r\n        }\r\n    }\r\n    java.util.Random random = new java.util.Random();\r\n    Classifier[] weakLearners = new Classifier[numRounds];\r\n    double[] classifierWeights = new double[numRounds];\r\n    double[] exponents = new double[weights.length];\r\n    int[] instIndices = new int[weights.length];\r\n    for (int i = 0; i < instIndices.length; i++) instIndices[i] = i;\r\n    for (int round = 0; round < numRounds; round++) {\r\n        logger.info(\"===========  AdaBoostM2Trainer round \" + (round + 1) + \" begin\");\r\n        double epsilon;\r\n        InstanceList roundTrainingInsts = new InstanceList(trainingInsts.getPipe());\r\n        int resamplingIterations = 0;\r\n        do {\r\n            epsilon = 0;\r\n            int[] sampleIndices = sampleWithWeights(instIndices, weights, random);\r\n            roundTrainingInsts = new InstanceList(trainingInsts.getPipe(), sampleIndices.length);\r\n            for (int i = 0; i < sampleIndices.length; i++) {\r\n                Instance inst = trainingInsts.get(sampleIndices[i]);\r\n                roundTrainingInsts.add(inst, 1);\r\n            }\r\n            weakLearners[round] = weakLearner.train(roundTrainingInsts);\r\n            for (int i = 0; i < trainingInsts.size(); i++) {\r\n                Instance inst = trainingInsts.get(i);\r\n                Classification c = weakLearners[round].classify(inst);\r\n                double htCorrect = c.valueOfCorrectLabel();\r\n                double htWrong = c.getLabeling().value(classIndices[i]);\r\n                epsilon += weights[i] * (1 - htCorrect + htWrong);\r\n                exponents[i] = 1 + htCorrect - htWrong;\r\n            }\r\n            epsilon *= 0.5;\r\n            resamplingIterations++;\r\n        } while (Maths.almostEquals(epsilon, 0) && resamplingIterations < MAX_NUM_RESAMPLING_ITERATIONS);\r\n        if (Maths.almostEquals(epsilon, 0)) {\r\n            logger.info(\"AdaBoostM2Trainer stopped at \" + (round + 1) + \" / \" + numRounds + \" pseudo-loss=\" + epsilon);\r\n            int numClassifiersToUse = (round == 0) ? 1 : round;\r\n            if (round == 0)\r\n                classifierWeights[0] = 1;\r\n            double[] classifierWeights2 = new double[numClassifiersToUse];\r\n            Classifier[] weakLearners2 = new Classifier[numClassifiersToUse];\r\n            System.arraycopy(classifierWeights, 0, classifierWeights2, 0, numClassifiersToUse);\r\n            System.arraycopy(weakLearners, 0, weakLearners2, 0, numClassifiersToUse);\r\n            for (int i = 0; i < classifierWeights2.length; i++) {\r\n                logger.info(\"AdaBoostM2Trainer weight[weakLearner[\" + i + \"]]=\" + classifierWeights2[i]);\r\n            }\r\n            return new AdaBoostM2(trainingInsts.getPipe(), weakLearners2, classifierWeights2);\r\n        }\r\n        double beta = epsilon / (1 - epsilon);\r\n        classifierWeights[round] = Math.log(1.0 / beta);\r\n        double sum = 0;\r\n        for (int i = 0; i < weights.length; i++) {\r\n            weights[i] *= Math.pow(beta, 0.5 * exponents[i]);\r\n            sum += weights[i];\r\n        }\r\n        MatrixOps.timesEquals(weights, 1.0 / sum);\r\n        logger.info(\"===========  AdaBoostM2Trainer round \" + (round + 1) + \" finished, pseudo-loss = \" + epsilon);\r\n    }\r\n    for (int i = 0; i < classifierWeights.length; i++) logger.info(\"AdaBoostM2Trainer weight[weakLearner[\" + i + \"]]=\" + classifierWeights[i]);\r\n    this.classifier = new AdaBoostM2(trainingInsts.getPipe(), weakLearners, classifierWeights);\r\n    return classifier;\r\n}"
}, {
	"Path": "cc.mallet.util.Randoms.asJavaRandom",
	"Comment": "wrap this instance as a java random, so it can be passed to legacy methods.all methods of the returned java.util.random object will affect the state ofthis object, as well.",
	"Method": "java.util.Random asJavaRandom(){\r\n    return new java.util.Random() {\r\n        protected int next(int bits) {\r\n            return cc.mallet.util.Randoms.this.next(bits);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "cc.mallet.util.Randoms.asJavaRandom",
	"Comment": "wrap this instance as a java random, so it can be passed to legacy methods.all methods of the returned java.util.random object will affect the state ofthis object, as well.",
	"Method": "java.util.Random asJavaRandom(){\r\n    return cc.mallet.util.Randoms.this.next(bits);\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.MephidrossVampireTest.testMultiTriggers",
	"Comment": "checks if only one triggered ability is handleded in the pool",
	"Method": "void testMultiTriggers(){\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mephidross Vampire\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Ornithopter\");\r\n    attack(2, playerB, \"Mephidross Vampire\");\r\n    block(2, playerA, \"Ornithopter\", \"Mephidross Vampire\");\r\n    setStopAt(2, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerB, \"Mephidross Vampire\", 1);\r\n    assertPowerToughness(playerB, \"Mephidross Vampire\", 4, 5);\r\n    Assert.assertEquals(\"There should only be one triggered ability in the list of triggers of the State\", 1, currentGame.getState().getTriggers().size());\r\n}"
}, {
	"Path": "cc.mallet.classify.MaxEntOptimizableByLabelDistribution.getValueCalls",
	"Comment": "counts how many times this trainer has computed the \tlog probability of training labels.",
	"Method": "int getValueCalls(){\r\n    return numGetValueCalls;\r\n}"
}, {
	"Path": "org.mage.test.multiplayer.CreepingDreadTest.noMatchesTest",
	"Comment": "discard enchantment and no opponents discard an enchantment, so no one loses life",
	"Method": "void noMatchesTest(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Creeping Dread\");\r\n    addCard(Zone.HAND, playerA, \"Moat\");\r\n    addCard(Zone.HAND, playerB, \"Hill Giant\");\r\n    addCard(Zone.HAND, playerC, \"Swamp\");\r\n    addCard(Zone.HAND, playerD, \"Bone Saw\");\r\n    setChoice(playerA, \"Moat\");\r\n    setChoice(playerB, \"Hill Giant\");\r\n    setChoice(playerC, \"Swamp\");\r\n    setChoice(playerD, \"Bone Saw\");\r\n    setStopAt(1, PhaseStep.DRAW);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Moat\", 1);\r\n    assertGraveyardCount(playerB, \"Hill Giant\", 1);\r\n    assertGraveyardCount(playerC, \"Swamp\", 1);\r\n    assertGraveyardCount(playerD, \"Bone Saw\", 1);\r\n    assertLife(playerA, 40);\r\n    assertLife(playerB, 40);\r\n    assertLife(playerC, 40);\r\n    assertLife(playerD, 40);\r\n}"
}, {
	"Path": "cc.mallet.extract.CRFExtractor.slicePipes",
	"Comment": "transfer some pipes from the feature pipe to the tokenization pipe.\t the feature pipe must be a serialpipes.this will destructively modify the crf object of the extractor.\tthis is useful if you have a crf hat has been trained from a single pipe, which you need to split up\t int feature and tokenization pipes",
	"Method": "void slicePipes(int num){\r\n    Pipe fpipe = getFeaturePipe();\r\n    if (!(fpipe instanceof SerialPipes))\r\n        throw new IllegalArgumentException(\"slicePipes: FeaturePipe must be a SerialPipes.\");\r\n    SerialPipes sp = (SerialPipes) fpipe;\r\n    ArrayList pipes = new ArrayList();\r\n    for (int i = 0; i < num; i++) {\r\n        pipes.add(sp.getPipe(0));\r\n    }\r\n    throw new UnsupportedOperationException(\"Not yet implemented...\");\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.MeldTest.testMeld3",
	"Comment": "check that if the exiled parts return brisela is created again",
	"Method": "void testMeld3(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 7);\r\n    addCard(Zone.HAND, playerA, \"Bruna, the Fading Light\");\r\n    addCard(Zone.HAND, playerA, \"Gisela, the Broken Blade\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    addCard(Zone.HAND, playerB, \"Silvercoat Lion\", 2);\r\n    addCard(Zone.HAND, playerB, \"Vanish into Memory\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Bruna, the Fading Light\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Silvercoat Lion\");\r\n    castSpell(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"Gisela, the Broken Blade\");\r\n    castSpell(4, PhaseStep.PRECOMBAT_MAIN, playerB, \"Vanish into Memory\", \"Brisela, Voice of Nightmares\");\r\n    castSpell(4, PhaseStep.PRECOMBAT_MAIN, playerB, \"Silvercoat Lion\");\r\n    setStopAt(8, PhaseStep.UPKEEP);\r\n    execute();\r\n    assertExileCount(\"Bruna, the Fading Light\", 0);\r\n    assertExileCount(\"Gisela, the Broken Blade\", 0);\r\n    assertPermanentCount(playerA, \"Brisela, Voice of Nightmares\", 1);\r\n    assertGraveyardCount(playerB, \"Vanish into Memory\", 1);\r\n    assertPermanentCount(playerB, \"Silvercoat Lion\", 2);\r\n    assertHandCount(playerB, 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.activated.ReturnToHandTest.VeilbornGhoulTest2",
	"Comment": "return from graveyard to hand if you play a non swamp land but urborg,tomb of yawgmoth is in play",
	"Method": "void VeilbornGhoulTest2(){\r\n    addCard(Zone.GRAVEYARD, playerA, \"Veilborn Ghoul\");\r\n    addCard(Zone.HAND, playerA, \"Flood Plain\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Urborg, Tomb of Yawgmoth\", 1);\r\n    playLand(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Flood Plain\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Flood Plain\", 1);\r\n    assertHandCount(playerA, \"Veilborn Ghoul\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.other.AuratouchedMageTest.testAuratouchedMageNotOnBattlefield",
	"Comment": "if someone knows the way to elegantly handle the test mechanism in regards to no valid targets, please modify.the test works fine in practice.",
	"Method": "void testAuratouchedMageNotOnBattlefield(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 7);\r\n    addCard(Zone.HAND, playerA, \"Auratouched Mage\");\r\n    addCard(Zone.HAND, playerA, \"Swords to Plowshares\");\r\n    addCard(Zone.LIBRARY, playerA, \"Brainwash\");\r\n    addCard(Zone.LIBRARY, playerA, \"Animate Wall\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Auratouched Mage\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Swords to Plowshares\", \"Auratouched Mage\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Auratouched Mage\", 0);\r\n    assertPermanentCount(playerA, \"Brainwash\", 0);\r\n    assertHandCount(playerA, \"Brainwash\", 1);\r\n    assertLibraryCount(playerA, \"Animate Wall\", 1);\r\n}"
}, {
	"Path": "cc.mallet.topics.DMROptimizable.getValue",
	"Comment": "the log probability of the observed count vectors given the features.",
	"Method": "double getValue(){\r\n    if (!cachedValueStale) {\r\n        return cachedValue;\r\n    }\r\n    numGetValueCalls++;\r\n    cachedValue = 0;\r\n    double[] scores = new double[trainingList.getTargetAlphabet().size()];\r\n    double value = 0.0;\r\n    int instanceIndex = 0;\r\n    for (Instance instance : trainingList) {\r\n        FeatureVector multinomialValues = (FeatureVector) instance.getTarget();\r\n        if (multinomialValues == null) {\r\n            continue;\r\n        }\r\n        this.classifier.getUnnormalizedClassificationScores(instance, scores);\r\n        double sumScores = 0.0;\r\n        for (int i = 0; i < scores.length; i++) {\r\n            scores[i] = Math.exp(scores[i]);\r\n            sumScores += scores[i];\r\n        }\r\n        FeatureVector features = (FeatureVector) instance.getData();\r\n        double totalLength = 0;\r\n        for (int i = 0; i < multinomialValues.numLocations(); i++) {\r\n            int label = multinomialValues.indexAtLocation(i);\r\n            double count = multinomialValues.valueAtLocation(i);\r\n            value += (Dirichlet.logGammaStirling(scores[label] + count) - Dirichlet.logGammaStirling(scores[label]));\r\n            totalLength += count;\r\n        }\r\n        value -= (Dirichlet.logGammaStirling(sumScores + totalLength) - Dirichlet.logGammaStirling(sumScores));\r\n        if (Double.isNaN(value)) {\r\n            logger.fine(\"DCMMaxEntTrainer: Instance \" + instance.getName() + \"has NaN value.\");\r\n            for (int label : multinomialValues.getIndices()) {\r\n                logger.fine(\"log(scores)= \" + Math.log(scores[label]) + \" scores = \" + scores[label]);\r\n            }\r\n        }\r\n        if (Double.isInfinite(value)) {\r\n            logger.warning(\"Instance \" + instance.getSource() + \" has infinite value; skipping value and gradient\");\r\n            cachedValue -= value;\r\n            cachedValueStale = false;\r\n            return -value;\r\n        }\r\n        cachedValue += value;\r\n        instanceIndex++;\r\n    }\r\n    double prior = 0;\r\n    for (int label = 0; label < numLabels; label++) {\r\n        for (int feature = 0; feature < numFeatures - 1; feature++) {\r\n            double param = parameters[label * numFeatures + feature];\r\n            prior -= (param - gaussianPriorMean) * (param - gaussianPriorMean) / (2 * gaussianPriorVariance);\r\n        }\r\n        double param = parameters[label * numFeatures + defaultFeatureIndex];\r\n        prior -= (param - gaussianPriorMean) * (param - gaussianPriorMean) / (2 * defaultFeatureGaussianPriorVariance);\r\n    }\r\n    double labelProbability = cachedValue;\r\n    cachedValue += prior;\r\n    cachedValueStale = false;\r\n    progressLogger.info(\"Value (likelihood=\" + formatter.format(labelProbability) + \" prior=\" + formatter.format(prior) + \") = \" + formatter.format(cachedValue));\r\n    return cachedValue;\r\n}"
}, {
	"Path": "cc.mallet.types.PagedInstanceList.serializePage",
	"Comment": "serialize a page without metadata. this attempts to serialize theminimum amount needed to restore the page, leaving out redundant datasuch as pipes and dictionaries.",
	"Method": "void serializePage(ObjectOutputStream out,InstanceList page){\r\n    out.writeInt(page.size());\r\n    for (Instance inst : page) {\r\n        serializeObject(out, inst.getData());\r\n        serializeObject(out, inst.getTarget());\r\n        out.writeObject(inst.getName());\r\n        out.writeObject(inst.getSource());\r\n        if (this.instWeights != null) {\r\n            Double weight = this.instWeights.get(inst);\r\n            if (weight != null) {\r\n                out.writeDouble(this.instWeights.get(inst));\r\n            } else {\r\n                out.writeDouble(1.0);\r\n            }\r\n        } else {\r\n            out.writeDouble(1.0);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.other.SoulfireGrandMasterTest.testActivatedAbility",
	"Comment": "test damage of activated ability of a permanent does not gain lifelink",
	"Method": "void testActivatedAbility(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 3);\r\n    addCard(Zone.HAND, playerA, \"Lightning Bolt\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Soulfire Grand Master\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Rod of Ruin\", 1);\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"{3}, {T}\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Soulfire Grand Master\", 1);\r\n    assertPermanentCount(playerA, \"Rod of Ruin\", 1);\r\n    assertLife(playerB, 19);\r\n    assertLife(playerA, 20);\r\n}"
}, {
	"Path": "cc.mallet.fst.CRFTrainerByLabelLikelihood.setAddNoFactors",
	"Comment": "use this method to specify whether or not factors\tare added to the crf by this trainer.if you have\talready setup the factors in your crf, you may\tnot want the trainer to add additional factors.",
	"Method": "void setAddNoFactors(boolean flag){\r\n    this.useNoWeights = flag;\r\n}"
}, {
	"Path": "cc.mallet.topics.RTopicModel.addInstance",
	"Comment": "this is a helper method that simplifies class casting from rjava.",
	"Method": "void addInstance(InstanceList instances,String id,String text){\r\n    instances.addThruPipe(new Instance(text, null, id, null));\r\n}"
}, {
	"Path": "org.mage.test.serverside.base.impl.CardTestPlayerAPIImpl.assertTappedCount",
	"Comment": "assert whether x permanents of the same name are tapped or not.",
	"Method": "void assertTappedCount(String cardName,boolean tapped,int count){\r\n    int tappedAmount = 0;\r\n    Permanent found = null;\r\n    for (Permanent permanent : currentGame.getBattlefield().getAllActivePermanents()) {\r\n        if (permanent.getName().equals(cardName)) {\r\n            if (permanent.isTapped() == tapped) {\r\n                tappedAmount++;\r\n            }\r\n            found = permanent;\r\n        }\r\n    }\r\n    Assert.assertNotNull(\"There is no such permanent on the battlefield, cardName=\" + cardName, found);\r\n    Assert.assertEquals(\"(Battlefield) \" + count + \" permanents (\" + cardName + \") are not \" + ((tapped) ? \"\" : \"un\") + \"tapped.\", count, tappedAmount);\r\n}"
}, {
	"Path": "org.mage.test.rollback.DemonicPactTest.testModeAfterRollback",
	"Comment": "the rollback to the start of the turn does not correctly reset the already selected choices from demonic pact. they are not available again.",
	"Method": "void testModeAfterRollback(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 4);\r\n    addCard(Zone.HAND, playerA, \"Demonic Pact\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Demonic Pact\");\r\n    setModeChoice(playerA, \"1\");\r\n    addTarget(playerA, playerB);\r\n    rollbackTurns(3, PhaseStep.PRECOMBAT_MAIN, playerA, 0);\r\n    setStopAt(3, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertHandCount(playerA, 1);\r\n    assertHandCount(playerB, 1);\r\n    assertLife(playerA, 24);\r\n    assertLife(playerB, 16);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.other.AuratouchedMageTest.testAuratouchedMageEffectHasMadeIntoTypeArtifact",
	"Comment": "if someone knows the way to elegantly handle the test mechanism in regards to no valid targets, please modify.the test works fine in practice.",
	"Method": "void testAuratouchedMageEffectHasMadeIntoTypeArtifact(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 7);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 7);\r\n    addCard(Zone.HAND, playerA, \"Auratouched Mage\");\r\n    addCard(Zone.HAND, playerA, \"Argent Mutation\");\r\n    addCard(Zone.LIBRARY, playerA, \"Relic Ward\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Auratouched Mage\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Argent Mutation\", \"Auratouched Mage\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Auratouched Mage\", 1);\r\n    assertPermanentCount(playerA, \"Relic Ward\", 1);\r\n}"
}, {
	"Path": "cc.mallet.fst.SimpleTagger.train",
	"Comment": "create and train a crf model from the given training data,\toptionally testing it on the given test data.",
	"Method": "CRF train(InstanceList training,InstanceList testing,TransducerEvaluator eval,int[] orders,String defaultLabel,String forbidden,String allowed,boolean connected,int iterations,double var,CRF crf){\r\n    Pattern forbiddenPat = Pattern.compile(forbidden);\r\n    Pattern allowedPat = Pattern.compile(allowed);\r\n    if (crf == null) {\r\n        crf = new CRF(training.getPipe(), (Pipe) null);\r\n        String startName = crf.addOrderNStates(training, orders, null, defaultLabel, forbiddenPat, allowedPat, connected);\r\n        for (int i = 0; i < crf.numStates(); i++) crf.getState(i).setInitialWeight(Transducer.IMPOSSIBLE_WEIGHT);\r\n        crf.getState(startName).setInitialWeight(0.0);\r\n    }\r\n    logger.info(\"Training on \" + training.size() + \" instances\");\r\n    if (testing != null) {\r\n        logger.info(\"Testing on \" + testing.size() + \" instances\");\r\n    }\r\n    assert (numThreads.value > 0);\r\n    if (numThreads.value > 1) {\r\n        CRFTrainerByThreadedLabelLikelihood crft = new CRFTrainerByThreadedLabelLikelihood(crf, numThreads.value);\r\n        crft.setGaussianPriorVariance(var);\r\n        if (weightsOption.value.equals(\"dense\")) {\r\n            crft.setUseSparseWeights(false);\r\n            crft.setUseSomeUnsupportedTrick(false);\r\n        } else if (weightsOption.value.equals(\"some-dense\")) {\r\n            crft.setUseSparseWeights(true);\r\n            crft.setUseSomeUnsupportedTrick(true);\r\n        } else if (weightsOption.value.equals(\"sparse\")) {\r\n            crft.setUseSparseWeights(true);\r\n            crft.setUseSomeUnsupportedTrick(false);\r\n        } else {\r\n            throw new RuntimeException(\"Unknown weights option: \" + weightsOption.value);\r\n        }\r\n        if (featureInductionOption.value) {\r\n            throw new IllegalArgumentException(\"Multi-threaded feature induction is not yet supported.\");\r\n        } else {\r\n            boolean converged;\r\n            for (int i = 1; i <= iterations; i++) {\r\n                converged = crft.train(training, 1);\r\n                if (i % 1 == 0 && eval != null) {\r\n                    eval.evaluate(crft);\r\n                }\r\n                if (viterbiOutputOption.value && i % 10 == 0) {\r\n                    new ViterbiWriter(\"\", new InstanceList[] { training, testing }, new String[] { \"training\", \"testing\" }).evaluate(crft);\r\n                }\r\n                if (converged) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        crft.shutdown();\r\n    } else {\r\n        CRFTrainerByLabelLikelihood crft = new CRFTrainerByLabelLikelihood(crf);\r\n        crft.setGaussianPriorVariance(var);\r\n        if (weightsOption.value.equals(\"dense\")) {\r\n            crft.setUseSparseWeights(false);\r\n            crft.setUseSomeUnsupportedTrick(false);\r\n        } else if (weightsOption.value.equals(\"some-dense\")) {\r\n            crft.setUseSparseWeights(true);\r\n            crft.setUseSomeUnsupportedTrick(true);\r\n        } else if (weightsOption.value.equals(\"sparse\")) {\r\n            crft.setUseSparseWeights(true);\r\n            crft.setUseSomeUnsupportedTrick(false);\r\n        } else {\r\n            throw new RuntimeException(\"Unknown weights option: \" + weightsOption.value);\r\n        }\r\n        if (featureInductionOption.value) {\r\n            crft.trainWithFeatureInduction(training, null, testing, eval, iterations, 10, 20, 500, 0.5, false, null);\r\n        } else {\r\n            boolean converged;\r\n            for (int i = 1; i <= iterations; i++) {\r\n                converged = crft.train(training, 1);\r\n                if (i % 1 == 0 && eval != null) {\r\n                    eval.evaluate(crft);\r\n                }\r\n                if (viterbiOutputOption.value && i % 10 == 0) {\r\n                    new ViterbiWriter(\"\", new InstanceList[] { training, testing }, new String[] { \"training\", \"testing\" }).evaluate(crft);\r\n                }\r\n                if (converged) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return crf;\r\n}"
}, {
	"Path": "cc.mallet.pipe.StringIterator.movePast",
	"Comment": "moves to the next occurrence of any character that is not one of the specified characters.",
	"Method": "void movePast(char[] chars){\r\n    while (isInArray(peek(), chars) && !isEndOfText()) {\r\n        moveAhead();\r\n    }\r\n}"
}, {
	"Path": "cc.mallet.fst.TransducerTrainer.train",
	"Comment": "train the transducer associated with this transducertrainer.\tyou should be able to call this method with different trainingset objects.\twhether this causes the transducertrainer to combine both trainingsets or\tto view the second as a new alternative is at the discretion of the particular\ttransducertrainer subclass involved.",
	"Method": "boolean train(InstanceList trainingSet,boolean train,InstanceList trainingSet,int numIterations){\r\n    return train(trainingSet, Integer.MAX_VALUE);\r\n}"
}, {
	"Path": "org.mage.test.cards.single.HomicidalSeclusionTest.testNoSingleCard",
	"Comment": "tests that there will be no effect when there is more than one creature",
	"Method": "void testNoSingleCard(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Homicidal Seclusion\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Air Elemental\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Horned Turtle\", 1);\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertPowerToughness(playerA, \"Air Elemental\", 4, 4, Filter.ComparisonScope.All);\r\n    assertPowerToughness(playerA, \"Horned Turtle\", 1, 4, Filter.ComparisonScope.All);\r\n}"
}, {
	"Path": "cc.mallet.classify.RandomClassifier.classify",
	"Comment": "classify an instance using random selection based on the trained data.",
	"Method": "Classification classify(Instance instance){\r\n    int max = this.labels.size() - 1;\r\n    Random random = new Random();\r\n    int rndIndex = random.nextInt(max + 1);\r\n    Label randomLabel = this.labels.get(rndIndex);\r\n    Classification randomClassification = new Classification(instance, this, randomLabel);\r\n    return randomClassification;\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.ZoneChangeReplacementTest.testWhipOfErebos",
	"Comment": "test that a returned creature of whip of erebos got exiled if it isdestroyed by a spell",
	"Method": "void testWhipOfErebos(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 2);\r\n    addCard(Zone.HAND, playerA, \"Terror\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Whip of Erebos\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Swamp\", 4);\r\n    addCard(Zone.GRAVEYARD, playerB, \"Silvercoat Lion\");\r\n    activateAbility(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"{2}{B}{B}, {T}: Return target creature\", \"Silvercoat Lion\");\r\n    castSpell(2, PhaseStep.BEGIN_COMBAT, playerA, \"Terror\", \"Silvercoat Lion\");\r\n    setStopAt(2, PhaseStep.END_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerA, \"Terror\", 1);\r\n    assertExileCount(\"Silvercoat Lion\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.equipped.ScytheOfTheWretchedTest.testEquipDiedInCombat2",
	"Comment": "test that the creature that died returns to battlefield under yourcontrol if the previous equiped creature does die already in combat andthe equipment was destroyed meanwhile",
	"Method": "void testEquipDiedInCombat2(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Serra Angel\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 2);\r\n    addCard(Zone.HAND, playerA, \"Disenchant\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Scythe of the Wretched\");\r\n    activateAbility(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Equip {4}\", \"Silvercoat Lion\");\r\n    attack(2, playerB, \"Silvercoat Lion\");\r\n    block(2, playerA, \"Serra Angel\", \"Silvercoat Lion\");\r\n    castSpell(2, PhaseStep.COMBAT_DAMAGE, playerA, \"Disenchant\", \"Scythe of the Wretched\", \"Whenever a creature dealt damage\");\r\n    setStopAt(2, PhaseStep.POSTCOMBAT_MAIN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerA, \"Disenchant\", 1);\r\n    assertGraveyardCount(playerB, \"Scythe of the Wretched\", 1);\r\n    assertPermanentCount(playerA, \"Serra Angel\", 0);\r\n    assertPermanentCount(playerB, \"Serra Angel\", 1);\r\n    assertPowerToughness(playerB, \"Serra Angel\", 4, 4);\r\n    assertGraveyardCount(playerB, \"Silvercoat Lion\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.ZadaHedronGrinderTest.testWithStriveSpell",
	"Comment": "playing zada edh, strive cards such as rouse the mob do not copy whentargeting only zada.",
	"Method": "void testWithStriveSpell(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Zada, Hedron Grinder\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Silvercoat Lion\", 1);\r\n    addCard(Zone.HAND, playerA, \"Rouse the Mob\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Rouse the Mob\", \"Zada, Hedron Grinder\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerA, \"Rouse the Mob\", 1);\r\n    assertPowerToughness(playerA, \"Zada, Hedron Grinder\", 5, 3);\r\n    assertAbility(playerA, \"Zada, Hedron Grinder\", TrampleAbility.getInstance(), true);\r\n    assertPowerToughness(playerA, \"Silvercoat Lion\", 4, 2);\r\n    assertAbility(playerA, \"Silvercoat Lion\", TrampleAbility.getInstance(), true);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.SoulbondKeywordTest.testCreatureTypeLoss",
	"Comment": "tests that creature type loss leads to soulbond effect disabling",
	"Method": "void testCreatureTypeLoss(){\r\n    addCard(Zone.HAND, playerA, \"Trusted Forcemage\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Blinkmoth Nexus\", 1);\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"{1}: \");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Trusted Forcemage\");\r\n    setStopAt(2, PhaseStep.PRECOMBAT_MAIN);\r\n    execute();\r\n    assertPowerToughness(playerA, \"Trusted Forcemage\", 2, 2);\r\n}"
}, {
	"Path": "org.mage.test.combat.AttackBlockRestrictionsTest.testMustAttackButCannotAttackAlone",
	"Comment": "mogg flunkies cannot attack alone. cards like goblin assault force all goblins to attack each turn.mogg flunkies should not be able to attack.",
	"Method": "void testMustAttackButCannotAttackAlone(){\r\n    String flunkies = \"Mogg Flunkies\";\r\n    String gAssault = \"Goblin Assault\";\r\n    addCard(Zone.BATTLEFIELD, playerA, flunkies);\r\n    addCard(Zone.BATTLEFIELD, playerB, gAssault);\r\n    setStopAt(3, PhaseStep.POSTCOMBAT_MAIN);\r\n    execute();\r\n    assertTapped(flunkies, false);\r\n    assertLife(playerB, 20);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.PhasingTest.TestAbilitiesOfPhasedOutAreNotApplied",
	"Comment": "test that abilities of phased out cards do not trigger or apply theireffects",
	"Method": "void TestAbilitiesOfPhasedOutAreNotApplied(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 3);\r\n    addCard(Zone.HAND, playerA, \"Teferi's Realm\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Crusade\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Teferi's Realm\");\r\n    setChoice(playerB, \"Non-Aura enchantment\");\r\n    setStopAt(2, PhaseStep.PRECOMBAT_MAIN);\r\n    execute();\r\n    assertPermanentCount(playerB, \"Crusade\", 0);\r\n    assertPermanentCount(playerB, \"Silvercoat Lion\", 1);\r\n    assertPowerToughness(playerB, \"Silvercoat Lion\", 2, 2);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.enters.BanisherPriestTest.testBanisherPriestToken",
	"Comment": "check if banisher priest is removed from graveyard with seance andthe target creature exiled with the token returns to the game, whenthe token is exiled.",
	"Method": "void testBanisherPriestToken(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Silvercoat Lion\");\r\n    addCard(Zone.GRAVEYARD, playerB, \"Banisher Priest\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Seance\");\r\n    playerB.addChoice(\"Banisher Priest\");\r\n    playerB.addChoice(\"Silvercoat Lion\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertExileCount(\"Banisher Priest\", 1);\r\n    assertPermanentCount(playerB, \"Banisher Priest\", 0);\r\n    assertPermanentCount(playerA, \"Silvercoat Lion\", 1);\r\n}"
}, {
	"Path": "cc.mallet.types.PagedInstanceList.add",
	"Comment": "appends the instance to this list. note that since memory forthe instance has already been allocated, no check is made tocatch outofmemoryerror.",
	"Method": "boolean add(Instance instance){\r\n    InstanceList page;\r\n    if (this.size % this.instancesPerPage == 0) {\r\n        int pageId = this.size / this.instancesPerPage;\r\n        int bin = pageId % this.inMemoryPages.length;\r\n        swapOut(this.inMemoryPageIds[bin]);\r\n        page = new InstanceList(this.noopPipe);\r\n        this.inMemoryPageIds[bin] = pageId;\r\n        this.inMemoryPages[bin] = page;\r\n    } else {\r\n        page = getPageForIndex(this.size, true);\r\n    }\r\n    boolean ret = page.add(instance);\r\n    if (ret) {\r\n        this.size++;\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.mage.test.multiplayer.PlayerLeftGameRangeAllTest.TestThaliaHereticCatharContinuousEffectEndsIfPlayerDies",
	"Comment": "in an edh game, a player controlling thalia left the game and the abilitystill lasted for the rest of the game. gamelog if it helps.",
	"Method": "void TestThaliaHereticCatharContinuousEffectEndsIfPlayerDies(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 3);\r\n    addCard(Zone.HAND, playerA, \"Thalia, Heretic Cathar\");\r\n    addCard(Zone.HAND, playerD, \"Lightning Bolt\");\r\n    addCard(Zone.BATTLEFIELD, playerD, \"Mountain\", 1);\r\n    addCard(Zone.HAND, playerC, \"Pillarfield Ox\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerC, \"Plains\", 4);\r\n    addCard(Zone.HAND, playerB, \"Silvercoat Lion\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 2);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Thalia, Heretic Cathar\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerD, \"Lightning Bolt\", playerA);\r\n    castSpell(3, PhaseStep.PRECOMBAT_MAIN, playerC, \"Pillarfield Ox\");\r\n    castSpell(4, PhaseStep.PRECOMBAT_MAIN, playerB, \"Silvercoat Lion\");\r\n    setStopAt(4, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerD, \"Lightning Bolt\", 1);\r\n    assertLife(playerA, -1);\r\n    Assert.assertFalse(\"Player D is no longer in the game\", playerA.isInGame());\r\n    assertPermanentCount(playerC, \"Pillarfield Ox\", 1);\r\n    assertPermanentCount(playerB, \"Silvercoat Lion\", 1);\r\n    assertTapped(\"Pillarfield Ox\", false);\r\n    assertTapped(\"Silvercoat Lion\", false);\r\n}"
}, {
	"Path": "org.mage.test.utils.ManaUtilTest.testManaReduction",
	"Comment": "checks if a given mana reduction left the expected amount of mana costs",
	"Method": "void testManaReduction(String manaCostsToPay,String manaToReduce,String restMana){\r\n    SpellAbility spellAbility = new SpellAbility(new ManaCostsImpl(manaCostsToPay), \"Test\");\r\n    CardUtil.adjustCost(spellAbility, new ManaCostsImpl(manaToReduce), true);\r\n    Assert.assertTrue(\"The mana cost to pay \" + manaCostsToPay + \" reduced by \" + manaToReduce + \" should left \" + restMana + \" but the rest was \" + spellAbility.getManaCostsToPay().getText(), spellAbility.getManaCostsToPay().getText().equals(restMana));\r\n}"
}, {
	"Path": "org.mage.test.cards.single.roe.CastThroughTimeTest.testCastWithDoubleRebound",
	"Comment": "tests rebound from two cast through time instancesshould have no effect for second copy",
	"Method": "void testCastWithDoubleRebound(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Cast Through Time\", 2);\r\n    addCard(Zone.HAND, playerA, \"Lightning Bolt\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Lightning Bolt\", playerB);\r\n    setStopAt(3, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerB, 14);\r\n}"
}, {
	"Path": "org.mage.test.AI.basic.PreventRepeatedActionsTest.testBasaltMonolith",
	"Comment": "if the ai on a local server gets control of a basalt monolith it willinfinite loop taping for three mana and then using the mana to untap lol.seeing the computer durdle troll is quite the hillarious thing",
	"Method": "void testBasaltMonolith(){\r\n    addCard(Zone.HAND, playerA, \"Phyrexian Vault\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Basalt Monolith\", 1, true);\r\n    setStopAt(5, PhaseStep.END_TURN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Phyrexian Vault\", 1);\r\n    assertTapped(\"Basalt Monolith\", true);\r\n    assertTappedCount(\"Plains\", false, 3);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.FlashbackTest.testFlashbackReturnToHandAndCastAgain",
	"Comment": "i cast runic repetition targeting a silent departure in exile, andafterwards i cast the silent departure from my hand. when it resolves, itgoes back to exile instead of ending up in my graveyard. looks like aproblem with runic repetition?",
	"Method": "void testFlashbackReturnToHandAndCastAgain(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Silvercoat Lion\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 9);\r\n    addCard(Zone.GRAVEYARD, playerA, \"Silent Departure\", 1);\r\n    addCard(Zone.HAND, playerA, \"Runic Repetition\", 1);\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Flashback\");\r\n    addTarget(playerA, \"Silvercoat Lion\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Runic Repetition\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Silent Departure\", \"Silvercoat Lion\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertHandCount(playerA, \"Silvercoat Lion\", 2);\r\n    assertExileCount(\"Silent Departure\", 0);\r\n    assertGraveyardCount(playerA, \"Silent Departure\", 1);\r\n    assertGraveyardCount(playerA, \"Runic Repetition\", 1);\r\n}"
}, {
	"Path": "org.mage.test.rollback.ExtraTurnTest.testThatRollbackWorksCorrectlyWithExtraTurn",
	"Comment": "test that rollback works correctly when extra turn is taken during an opponent turn.",
	"Method": "void testThatRollbackWorksCorrectlyWithExtraTurn(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 3);\r\n    addCard(Zone.HAND, playerA, \"Quicken\");\r\n    addCard(Zone.HAND, playerA, \"Time Walk\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerA, \"Quicken\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerA, \"Time Walk\");\r\n    rollbackTurns(3, PhaseStep.PRECOMBAT_MAIN, playerA, 0);\r\n    setStopAt(4, PhaseStep.PRECOMBAT_MAIN);\r\n    execute();\r\n    assertActivePlayer(playerA);\r\n}"
}, {
	"Path": "org.mage.test.cards.control.PutIntoPlayEffectsTest.testLordOfTheVoid2",
	"Comment": "test also if the oracle was in play before by the owner of the oracle",
	"Method": "void testLordOfTheVoid2(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Oracle of Mul Daya\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Lord of the Void\");\r\n    addCard(Zone.HAND, playerB, \"Griptide\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Griptide\", \"Oracle of Mul Daya\");\r\n    attack(2, playerB, \"Lord of the Void\");\r\n    setChoice(playerB, \"Oracle of Mul Daya\");\r\n    setStopAt(2, PhaseStep.POSTCOMBAT_MAIN);\r\n    execute();\r\n    assertLife(playerA, 13);\r\n    assertPermanentCount(playerB, \"Oracle of Mul Daya\", 1);\r\n    Assert.assertTrue(\"Top card of the library of player B should be revealed.\", playerB.isTopCardRevealed());\r\n    Assert.assertFalse(\"Top card of the library of player A should not be revealed.\", playerA.isTopCardRevealed());\r\n}"
}, {
	"Path": "org.mage.test.cards.single.avr.CavernOfSoulsTest.testCastWithColorlessManaCanBeCountered",
	"Comment": "return to the ranks cannot be countered if mana produced by cavern ofsouls was used to pay x. can be bug also for all other spells with x intheir cost, not sure.",
	"Method": "void testCastWithColorlessManaCanBeCountered(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 2);\r\n    addCard(Zone.HAND, playerA, \"Cavern of Souls\");\r\n    addCard(Zone.HAND, playerA, \"Return to the Ranks\");\r\n    addCard(Zone.GRAVEYARD, playerA, \"Silvercoat Lion\");\r\n    addCard(Zone.HAND, playerB, \"Counterspell\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    playLand(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Cavern of Souls\");\r\n    setChoice(playerA, \"Drake\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Return to the Ranks\", \"Silvercoat Lion\");\r\n    setChoice(playerA, \"X=1\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Counterspell\", \"Return to the Ranks\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Return to the Ranks\", 1);\r\n    assertGraveyardCount(playerB, \"Counterspell\", 1);\r\n    assertGraveyardCount(playerA, \"Silvercoat Lion\", 1);\r\n    assertPermanentCount(playerA, \"Silvercoat Lion\", 0);\r\n}"
}, {
	"Path": "org.mage.test.cards.conditional.twofaced.TwoFacedCardEffectsTest.testTransformedDOesNotTriggerFrontsideAbilities",
	"Comment": "tests that triggered abilities of the frontside do not trigger if the card is transformed",
	"Method": "void testTransformedDOesNotTriggerFrontsideAbilities(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Loyal Cathar\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mountain\", 1);\r\n    addCard(Zone.HAND, playerB, \"Lightning Bolt\", 2);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Lightning Bolt\", \"Loyal Cathar\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Lightning Bolt\", \"Unhallowed Cathar\");\r\n    setStopAt(3, PhaseStep.PRECOMBAT_MAIN);\r\n    execute();\r\n    assertGraveyardCount(playerB, \"Lightning Bolt\", 2);\r\n    assertPermanentCount(playerA, \"Unhallowed Cathar\", 0);\r\n    assertGraveyardCount(playerA, \"Loyal Cathar\", 1);\r\n}"
}, {
	"Path": "org.mage.test.sba.PlaneswalkerRuleTest.testDestroySamePlaneswalkers",
	"Comment": "check two copies of the same planeswalker played from the same player that one must be sacrificed",
	"Method": "void testDestroySamePlaneswalkers(){\r\n    addCard(Zone.HAND, playerA, \"Jace, Memory Adept\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 5);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Jace, Memory Adept\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Jace, Memory Adept\");\r\n    setStopAt(1, PhaseStep.END_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Jace, Memory Adept\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.SoulbondKeywordTest.testReturnBack",
	"Comment": "tests effect also disappeared when creature is returned back to owner",
	"Method": "void testReturnBack(){\r\n    addCard(Zone.HAND, playerA, \"Trusted Forcemage\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 3);\r\n    addCard(Zone.HAND, playerB, \"Act of Treason\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mountain\", 3);\r\n    addCard(Zone.HAND, playerB, \"Elite Vanguard\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 3);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Trusted Forcemage\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Act of Treason\", \"Trusted Forcemage\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Elite Vanguard\");\r\n    setStopAt(3, PhaseStep.PRECOMBAT_MAIN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Trusted Forcemage\", 1);\r\n    assertPowerToughness(playerA, \"Trusted Forcemage\", 2, 2);\r\n    assertPowerToughness(playerB, \"Elite Vanguard\", 2, 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.copy.PhantasmalImageTest.testCopiedSteelHellkite",
	"Comment": "i attack with a phantasmal image of steel hellkite. it deals damage. iactivate it for zero. a.i. has chalice of the void set to one counter.the chalice should be destroyed i think as in play it has a convertedmana cost of zero but it is not.",
	"Method": "void testCopiedSteelHellkite(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Steel Hellkite\");\r\n    addCard(Zone.HAND, playerA, \"Chalice of the Void\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    addCard(Zone.HAND, playerB, \"Phantasmal Image\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Chalice of the Void\");\r\n    setChoice(playerA, \"X=0\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Phantasmal Image\");\r\n    setChoice(playerB, \"Steel Hellkite\");\r\n    attack(4, playerB, \"Steel Hellkite\");\r\n    activateAbility(4, PhaseStep.POSTCOMBAT_MAIN, playerB, \"{X}: Destroy each nonland permanent with converted mana cost X whose controller was dealt combat damage by {this} this turn. Activate this ability only once each turn.\");\r\n    setChoice(playerB, \"X=0\");\r\n    setStopAt(4, PhaseStep.END_TURN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Steel Hellkite\", 1);\r\n    assertPermanentCount(playerB, \"Steel Hellkite\", 1);\r\n    assertLife(playerB, 20);\r\n    assertLife(playerA, 15);\r\n    assertPermanentCount(playerA, \"Chalice of the Void\", 0);\r\n    assertGraveyardCount(playerA, \"Chalice of the Void\", 1);\r\n}"
}, {
	"Path": "cc.mallet.classify.evaluate.AccuracyCoverage.createAccuracyArray",
	"Comment": "creates array of accuracy values for coverage\tat each step as defined by numbuckets.",
	"Method": "void createAccuracyArray(){\r\n    for (int i = 0; i < numBuckets; i++) {\r\n        accuracyValues[i] = accuracyAtCoverage(step * (double) (i + 1) / 100.0);\r\n    }\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.PillarOfFlameTest.testTriggeringExileItInstead",
	"Comment": "tests when cast pillar of flame targeting creature it goes to exile ifdying later",
	"Method": "void testTriggeringExileItInstead(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Lightning Mauler\");\r\n    addCard(Zone.HAND, playerA, \"Pillar of Flame\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Warmind Infantry\");\r\n    castSpell(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"Pillar of Flame\", \"Warmind Infantry\");\r\n    attack(3, playerA, \"Lightning Mauler\");\r\n    block(3, playerB, \"Warmind Infantry\", \"Lightning Mauler\");\r\n    setStopAt(3, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertPermanentCount(playerA, \"Lightning Mauler\", 0);\r\n    assertGraveyardCount(playerA, 2);\r\n    assertPermanentCount(playerB, \"Warmind Infantry\", 0);\r\n    assertGraveyardCount(playerB, 0);\r\n}"
}, {
	"Path": "cc.mallet.fst.CRFTrainerByStochasticGradient.setLearningRateByLikelihood",
	"Comment": "automatically sets the learning rate to one that would be good",
	"Method": "void setLearningRateByLikelihood(InstanceList trainingSample){\r\n    int numIterations = 5;\r\n    double bestLearningRate = Double.NEGATIVE_INFINITY;\r\n    double bestLikelihoodChange = Double.NEGATIVE_INFINITY;\r\n    double currLearningRate = 5e-11;\r\n    while (currLearningRate < 1) {\r\n        currLearningRate *= 2;\r\n        crf.parameters.zero();\r\n        double beforeLikelihood = computeLikelihood(trainingSample);\r\n        double likelihoodChange = trainSample(trainingSample, numIterations, currLearningRate) - beforeLikelihood;\r\n        System.out.println(\"likelihood change = \" + likelihoodChange + \" for learningrate=\" + currLearningRate);\r\n        if (likelihoodChange > bestLikelihoodChange) {\r\n            bestLikelihoodChange = likelihoodChange;\r\n            bestLearningRate = currLearningRate;\r\n        }\r\n    }\r\n    crf.parameters.zero();\r\n    bestLearningRate /= 2;\r\n    System.out.println(\"Setting learning rate to \" + bestLearningRate);\r\n    setLearningRate(bestLearningRate);\r\n}"
}, {
	"Path": "cc.mallet.fst.semi_supervised.tui.SimpleTaggerWithConstraints.trainPR",
	"Comment": "create and train a crf model from the given training data,optionally testing it on the given test data.",
	"Method": "CRF trainPR(InstanceList training,InstanceList testing,ArrayList<PRConstraint> constraints,CRF crf,TransducerEvaluator eval,int iterations,double var){\r\n    logger.info(\"Training on \" + training.size() + \" instances\");\r\n    if (testing != null)\r\n        logger.info(\"Testing on \" + testing.size() + \" instances\");\r\n    assert (numThreads.value > 0);\r\n    CRFTrainerByPR trainer = new CRFTrainerByPR(crf, constraints, numThreads.value);\r\n    trainer.addEvaluator(eval);\r\n    trainer.setPGaussianPriorVariance(var);\r\n    trainer.train(training, iterations, iterations);\r\n    return crf;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.SoulbondKeywordTest.testChangeControllerForSoulbondCreature",
	"Comment": "tests soulbond effect disabling whenever soulbond creature changes itscontroller",
	"Method": "void testChangeControllerForSoulbondCreature(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Elite Vanguard\");\r\n    addCard(Zone.HAND, playerA, \"Trusted Forcemage\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 3);\r\n    addCard(Zone.HAND, playerB, \"Act of Treason\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mountain\", 3);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Trusted Forcemage\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Act of Treason\", \"Trusted Forcemage\");\r\n    setStopAt(2, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Trusted Forcemage\", 0);\r\n    assertPermanentCount(playerA, \"Elite Vanguard\", 1);\r\n    assertPowerToughness(playerA, \"Elite Vanguard\", 2, 1);\r\n    assertPermanentCount(playerB, \"Trusted Forcemage\", 1);\r\n    assertPowerToughness(playerB, \"Trusted Forcemage\", 2, 2);\r\n}"
}, {
	"Path": "org.mage.test.cards.continuous.InfestTest.testMassBoostEffectLocked",
	"Comment": "tests creatures for flying gained from wonder ability when all conditions were met",
	"Method": "void testMassBoostEffectLocked(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Elite Vanguard\", 2);\r\n    addCard(Zone.HAND, playerA, \"Infest\");\r\n    addCard(Zone.HAND, playerA, \"Grizzly Bears\");\r\n    addCard(Zone.HAND, playerA, \"Grizzly Bears\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Infest\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Grizzly Bears\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Grizzly Bears\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertHandCount(playerA, 0);\r\n    assertPermanentCount(playerA, \"Elite Vanguard\", 0);\r\n    assertGraveyardCount(playerA, \"Elite Vanguard\", 2);\r\n    assertPermanentCount(playerA, \"Grizzly Bears\", 2);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.DredgeTest.testDredgeWithSidisiBroodTyrant",
	"Comment": "had a sidisi, brood tyrant in play and dredge a stinkweed imp hitting 3 creatures.and sidisi triggered 3 times instead of just one.",
	"Method": "void testDredgeWithSidisiBroodTyrant(){\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Sidisi, Brood Tyrant\");\r\n    addCard(Zone.GRAVEYARD, playerB, \"Stinkweed Imp\");\r\n    addCard(Zone.LIBRARY, playerB, \"Silvercoat Lion\", 5);\r\n    skipInitShuffling();\r\n    setChoice(playerB, \"Yes\");\r\n    setStopAt(2, PhaseStep.PRECOMBAT_MAIN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertHandCount(playerB, \"Stinkweed Imp\", 1);\r\n    assertGraveyardCount(playerB, \"Silvercoat Lion\", 5);\r\n    assertPermanentCount(playerB, \"Zombie\", 1);\r\n}"
}, {
	"Path": "cc.mallet.extract.CRFExtractor.setFeaturePipe",
	"Comment": "xxx this method is inherent dangerous!!! should check that pipe.alphabet equals crf.alphabet",
	"Method": "void setFeaturePipe(Pipe featurePipe){\r\n    this.featurePipe = featurePipe;\r\n}"
}, {
	"Path": "cc.mallet.pipe.FeatureDocFreqPipe.addPrunedWordsToStoplist",
	"Comment": "add all pruned words to the internal stoplist of a simpletokenizer.",
	"Method": "void addPrunedWordsToStoplist(SimpleTokenizer tokenizer,double docFrequencyCutoff){\r\n    Alphabet currentAlphabet = getDataAlphabet();\r\n    for (int feature = 0; feature < currentAlphabet.size(); feature++) {\r\n        if ((double) counter.get(feature) / numInstances > docFrequencyCutoff) {\r\n            tokenizer.stop((String) currentAlphabet.lookupObject(feature));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "cc.mallet.types.PagedInstanceList.set",
	"Comment": "replaces the instance at positionindex with a new one. note that this is the onlysanctioned way of changing an instance.",
	"Method": "Instance set(int index,Instance instance){\r\n    InstanceList page = getPageForIndex(index, true);\r\n    return page.set(index % this.instancesPerPage, instance);\r\n}"
}, {
	"Path": "org.mage.test.cards.control.GainControlTargetEffectTest.testDonateSteelGolem",
	"Comment": "steel golem, once donated to another player does not disable their ability to play creature cards.",
	"Method": "void testDonateSteelGolem(){\r\n    addCard(Zone.HAND, playerA, \"Steel Golem\", 1);\r\n    addCard(Zone.HAND, playerA, \"Donate\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 6);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 2);\r\n    addCard(Zone.HAND, playerB, \"Silvercoat Lion\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Steel Golem\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Donate\", playerB);\r\n    addTarget(playerA, \"Steel Golem\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Silvercoat Lion\");\r\n    setStopAt(2, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Donate\", 1);\r\n    assertPermanentCount(playerA, \"Steel Golem\", 0);\r\n    assertPermanentCount(playerB, \"Steel Golem\", 1);\r\n    assertPermanentCount(playerB, \"Silvercoat Lion\", 0);\r\n    assertHandCount(playerB, \"Silvercoat Lion\", 1);\r\n}"
}, {
	"Path": "cc.mallet.types.Dirichlet.learnParametersWithMoments",
	"Comment": "estimate a dirichlet with the moment matching method\t \t described by ronning.",
	"Method": "long learnParametersWithMoments(Object[] observations){\r\n    long start = System.currentTimeMillis();\r\n    int i, bin;\r\n    int[] observationLengths = new int[observations.length];\r\n    double[] variances = new double[partition.length];\r\n    Arrays.fill(partition, 0.0);\r\n    Arrays.fill(observationLengths, 0);\r\n    Arrays.fill(variances, 0.0);\r\n    for (i = 0; i < observations.length; i++) {\r\n        int[] observation = (int[]) observations[i];\r\n        for (bin = 0; bin < partition.length; bin++) {\r\n            observationLengths[i] += observation[bin];\r\n        }\r\n        for (bin = 0; bin < partition.length; bin++) {\r\n            partition[bin] += (double) observation[bin] / observationLengths[i];\r\n        }\r\n    }\r\n    for (bin = 0; bin < partition.length; bin++) {\r\n        partition[bin] /= observations.length;\r\n    }\r\n    double difference;\r\n    for (i = 0; i < observations.length; i++) {\r\n        int[] observation = (int[]) observations[i];\r\n        for (bin = 0; bin < partition.length; bin++) {\r\n            difference = ((double) observation[bin] / observationLengths[i]) - partition[bin];\r\n            variances[bin] += difference * difference;\r\n        }\r\n    }\r\n    for (bin = 0; bin < partition.length; bin++) {\r\n        variances[bin] /= observations.length - 1;\r\n    }\r\n    double sum = 0.0;\r\n    for (bin = 0; bin < partition.length; bin++) {\r\n        if (partition[bin] == 0) {\r\n            continue;\r\n        }\r\n        sum += Math.log((partition[bin] * (1 - partition[bin]) / variances[bin]) - 1);\r\n    }\r\n    magnitude = Math.exp(sum / (partition.length - 1));\r\n    return System.currentTimeMillis() - start;\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.EntersTheBattlefieldTriggerTest.testWildPair",
	"Comment": "test that the cast from hand condition works for target permanent",
	"Method": "void testWildPair(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Wild Pair\");\r\n    addCard(Zone.HAND, playerA, \"Silvercoat Lion\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 2);\r\n    setChoice(playerA, \"Silvercoat Lion\");\r\n    addCard(Zone.LIBRARY, playerA, \"Silvercoat Lion\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Silvercoat Lion\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Silvercoat Lion\", 2);\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.SpellskiteTest.testSpellskite2",
	"Comment": "my opponent cast cryptic command tapping all of my creatures and bouncinga blade splicer token i had. i activated a spellskite but got an errorstating that spellskite is not a legal target.",
	"Method": "void testSpellskite2(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 4);\r\n    addCard(Zone.HAND, playerA, \"Cryptic Command\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Spellskite\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 1);\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerA, \"Cryptic Command\", \"mode=2Silvercoat Lion\");\r\n    setModeChoice(playerA, \"2\");\r\n    setModeChoice(playerA, \"3\");\r\n    activateAbility(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"{U/P}: Change a target of target spell or ability to {this}.\", \"Cryptic Command\");\r\n    setStopAt(2, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertAllCommandsUsed();\r\n    assertGraveyardCount(playerA, \"Cryptic Command\", 1);\r\n    assertHandCount(playerB, \"Spellskite\", 1);\r\n    assertPermanentCount(playerB, \"Silvercoat Lion\", 1);\r\n    assertTapped(\"Silvercoat Lion\", true);\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 18);\r\n}"
}, {
	"Path": "cc.mallet.cluster.neighbor_evaluator.MedoidEvaluator.getCentroid",
	"Comment": "a bettter strategy would use caching to incrimentally determine the centroid",
	"Method": "int getCentroid(int[] indices,Clustering original){\r\n    if (indices.length < 2)\r\n        return 0;\r\n    double centDist = Double.NEGATIVE_INFINITY;\r\n    int centIdx = -1;\r\n    double[] scores = new double[indices.length];\r\n    for (int i = 0; i < indices.length; i++) {\r\n        double acc = 0;\r\n        for (int k = 0; k < indices.length; k++) {\r\n            if (i == k)\r\n                break;\r\n            AgglomerativeNeighbor pwn = new AgglomerativeNeighbor(original, original, indices[i], indices[k]);\r\n            double score = getScore(pwn);\r\n            acc += score;\r\n        }\r\n        acc /= (indices.length - 1);\r\n        scores[i] = acc;\r\n    }\r\n    for (int i = 0; i < scores.length; i++) {\r\n        if (scores[i] > centDist) {\r\n            centDist = scores[i];\r\n            centIdx = i;\r\n        }\r\n    }\r\n    return centIdx;\r\n}"
}, {
	"Path": "cc.mallet.types.MultiInstanceList.getOffsetIndex",
	"Comment": "gets the index into the offsets array for the given element index",
	"Method": "int getOffsetIndex(int index){\r\n    int i = Arrays.binarySearch(this.offsets, index);\r\n    if (i < 0) {\r\n        i = (-i) - 2;\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "cc.mallet.types.SparseVector.removeDuplicates",
	"Comment": "argument zero is special value meaning that this function should count them.",
	"Method": "void removeDuplicates(int numDuplicates){\r\n    if (numDuplicates == 0) {\r\n        for (int i = 1; i < indices.length; i++) {\r\n            if (indices[i - 1] == indices[i]) {\r\n                numDuplicates++;\r\n            }\r\n        }\r\n    }\r\n    if (numDuplicates == 0) {\r\n        return;\r\n    }\r\n    int[] newIndices = new int[indices.length - numDuplicates];\r\n    double[] newValues = values == null ? null : new double[indices.length - numDuplicates];\r\n    newIndices[0] = indices[0];\r\n    if (values != null) {\r\n        newValues[0] = values[0];\r\n    }\r\n    for (int i = 1, j = 1; i < indices.length; i++) {\r\n        if (indices[i] == indices[i - 1]) {\r\n            if (newValues != null) {\r\n                newValues[j - 1] += values[i];\r\n            }\r\n        } else {\r\n            newIndices[j] = indices[i];\r\n            if (values != null) {\r\n                newValues[j] = values[i];\r\n            }\r\n            j++;\r\n        }\r\n    }\r\n    this.indices = newIndices;\r\n    this.values = newValues;\r\n}"
}, {
	"Path": "org.mage.test.AI.basic.CastCreaturesTest.testSimpleCast2",
	"Comment": "this test fails sometimes, probably because two plains are tapped for thefirst creature",
	"Method": "void testSimpleCast2(){\r\n    addCard(Zone.HAND, playerA, \"Silvercoat Lion\");\r\n    addCard(Zone.HAND, playerA, \"Silvercoat Lion\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 2);\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertTappedCount(\"Plains\", true, 2);\r\n    assertTappedCount(\"Mountain\", true, 2);\r\n    assertPermanentCount(playerA, \"Silvercoat Lion\", 2);\r\n}"
}, {
	"Path": "cc.mallet.pipe.FeatureCountPipe.addPrunedWordsToStoplist",
	"Comment": "add all pruned words to the internal stoplist of a simpletokenizer.",
	"Method": "void addPrunedWordsToStoplist(SimpleTokenizer tokenizer,int minimumCount){\r\n    Alphabet currentAlphabet = getDataAlphabet();\r\n    for (int feature = 0; feature < currentAlphabet.size(); feature++) {\r\n        if (counter.get(feature) < minimumCount) {\r\n            tokenizer.stop((String) currentAlphabet.lookupObject(feature));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.SpliceOnArcaneTest.testSpliceThroughTheBreach",
	"Comment": "test that it works to cast through the breach by slicing it on an arcanespell",
	"Method": "void testSpliceThroughTheBreach(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 5);\r\n    addCard(Zone.HAND, playerA, \"Lava Spike\", 1);\r\n    addCard(Zone.HAND, playerA, \"Through the Breach\", 1);\r\n    addCard(Zone.HAND, playerA, \"Silvercoat Lion\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Lava Spike\", playerB);\r\n    setChoice(playerA, \"Yes\");\r\n    addTarget(playerA, \"Through the Breach\");\r\n    addTarget(playerA, \"Silvercoat Lion\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 17);\r\n    assertGraveyardCount(playerA, \"Lava Spike\", 1);\r\n    assertHandCount(playerA, \"Through the Breach\", 1);\r\n    assertPermanentCount(playerA, \"Silvercoat Lion\", 1);\r\n    assertAbility(playerA, \"Silvercoat Lion\", HasteAbility.getInstance(), true);\r\n    Assert.assertEquals(\"All available mana has to be used\", 0, playerA.getManaAvailable(currentGame).size());\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.enters.ValakutTheMoltenPinnacleTest.sixEnterWithScapeshiftDamageToPlayerB",
	"Comment": "sacrifice any number of lands. search your library for that many land cards, put them onto the battlefield tapped, then shuffle your library.",
	"Method": "void sixEnterWithScapeshiftDamageToPlayerB(){\r\n    addCard(Zone.LIBRARY, playerA, \"Mountain\", 6);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Valakut, the Molten Pinnacle\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 6);\r\n    addCard(Zone.HAND, playerA, \"Scapeshift\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Scapeshift\");\r\n    addTarget(playerA, \"Forest^Forest^Forest^Forest^Forest^Forest\");\r\n    setStopAt(3, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Valakut, the Molten Pinnacle\", 1);\r\n    assertGraveyardCount(playerA, \"Forest\", 6);\r\n    assertPermanentCount(playerA, \"Mountain\", 6);\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 2);\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.DamageEffectsTest.testDamageIsDoubledWithLifelink",
	"Comment": "just encountered another bug. with wurmcoil engine out and with agratuitous violence on the field, i only gained 6 life on blocking ratherthan 12 life.",
	"Method": "void testDamageIsDoubledWithLifelink(){\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Ob Nixilis, the Fallen\");\r\n    addCard(Zone.HAND, playerB, \"Mountain\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Wurmcoil Engine\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Gratuitous Violence\");\r\n    playLand(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Mountain\");\r\n    setChoice(playerB, \"Yes\");\r\n    addTarget(playerB, playerA);\r\n    attack(2, playerB, \"Ob Nixilis, the Fallen\");\r\n    block(2, playerA, \"Wurmcoil Engine\", \"Ob Nixilis, the Fallen\");\r\n    setStopAt(2, PhaseStep.POSTCOMBAT_MAIN);\r\n    execute();\r\n    assertGraveyardCount(playerB, \"Ob Nixilis, the Fallen\", 1);\r\n    assertGraveyardCount(playerA, \"Wurmcoil Engine\", 1);\r\n    assertPermanentCount(playerA, \"Wurm\", 2);\r\n    assertLife(playerB, 20);\r\n    assertLife(playerA, 29);\r\n}"
}, {
	"Path": "cc.mallet.fst.semi_supervised.pr.ConstraintsOptimizableByPR.getValue",
	"Comment": "returns the log probability of the training sequence labels and the prior\tover parameters.",
	"Method": "double getValue(){\r\n    if (cacheStale) {\r\n        cachedValue = getExpectationValue();\r\n        model.getValueGradient(cachedGradient);\r\n        cacheStale = false;\r\n        logger.info(\"getValue (auxiliary distribution) = \" + cachedValue);\r\n    }\r\n    return cachedValue;\r\n}"
}, {
	"Path": "cc.mallet.pipe.StringIterator.movePastWhitespace",
	"Comment": "moves the current position to the next character that is not whitespace.",
	"Method": "void movePastWhitespace(){\r\n    while (Character.isWhitespace(peek()) && !isEndOfText()) {\r\n        moveAhead();\r\n    }\r\n}"
}, {
	"Path": "cc.mallet.types.InstanceList.setPipe",
	"Comment": "change the default pipe associated with instancelist.this method is very dangerous and should only be used in extreme circumstances!!",
	"Method": "void setPipe(Pipe p){\r\n    assert (Alphabet.alphabetsMatch(this, p));\r\n    pipe = p;\r\n}"
}, {
	"Path": "cc.mallet.pipe.StringIterator.isEndOfText",
	"Comment": "indicates if the current position is at the end of the current document.",
	"Method": "boolean isEndOfText(){\r\n    return position_ >= text_.length();\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.ManifestTest.testManifestAura",
	"Comment": "but it made me choose a target for gains, then enchanted the card to that creature.",
	"Method": "void testManifestAura(){\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Swamp\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Qarsi High Priest\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\", 1);\r\n    addCard(Zone.LIBRARY, playerB, \"Illusory Gains\", 1);\r\n    addCard(Zone.LIBRARY, playerB, \"Mountain\", 1);\r\n    skipInitShuffling();\r\n    activateAbility(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"{1}{B}, {T}, Sacrifice another creature\");\r\n    setChoice(playerB, \"Silvercoat Lion\");\r\n    setStopAt(2, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertAllCommandsUsed();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerB, \"Illusory Gains\", 0);\r\n    assertGraveyardCount(playerB, \"Silvercoat Lion\", 1);\r\n    assertPermanentCount(playerB, EmptyNames.FACE_DOWN_CREATURE.toString(), 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.flip.ReplayBeforeFlippedCardsTest.testHanweirMilitiaCaptainReturned",
	"Comment": "return a flipped hanweir militia captain to its owners hand and whenreplayed it still haspower and toughness.",
	"Method": "void testHanweirMilitiaCaptainReturned(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 2);\r\n    addCard(Zone.HAND, playerA, \"Hanweir Militia Captain\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Silvercoat Lion\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    addCard(Zone.HAND, playerB, \"Just the Wind\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Hanweir Militia Captain\");\r\n    castSpell(3, PhaseStep.DRAW, playerB, \"Just the Wind\", \"Westvale Cult Leader\");\r\n    castSpell(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"Hanweir Militia Captain\");\r\n    setStopAt(3, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerB, \"Just the Wind\", 1);\r\n    assertPermanentCount(playerA, \"Hanweir Militia Captain\", 1);\r\n    assertPowerToughness(playerA, \"Hanweir Militia Captain\", 2, 2);\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.prevent.DeflectingPalmTest.testPreventDamageFromSpell",
	"Comment": "tests if a damage spell is selected as source the damage is prevented andis dealt to the controller of the damage spell",
	"Method": "void testPreventDamageFromSpell(){\r\n    addCard(Zone.HAND, playerA, \"Lightning Bolt\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\");\r\n    addCard(Zone.HAND, playerB, \"Deflecting Palm\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mountain\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Lightning Bolt\", playerB);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Deflecting Palm\", null, \"Lightning Bolt\");\r\n    setChoice(playerB, \"Lightning Bolt\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 17);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerA, \"Lightning Bolt\", 1);\r\n    assertGraveyardCount(playerB, \"Deflecting Palm\", 1);\r\n}"
}, {
	"Path": "cc.mallet.fst.CRFOptimizableByBatchLabelLikelihood.getExpectationValue",
	"Comment": "computes log probability of a batch of training data, fill in corresponding\texpectations as well",
	"Method": "double getExpectationValue(int batchIndex,int[] batchAssignments){\r\n    CRF.Factors batchExpectations = expectations.get(batchIndex);\r\n    batchExpectations.zero();\r\n    int numInfLabeledWeight = 0;\r\n    int numInfUnlabeledWeight = 0;\r\n    int numInfWeight = 0;\r\n    double value = 0;\r\n    double unlabeledWeight, labeledWeight, weight;\r\n    for (int ii = batchAssignments[0]; ii < batchAssignments[1]; ii++) {\r\n        Instance instance = trainingSet.get(ii);\r\n        double instanceWeight = trainingSet.getInstanceWeight(instance);\r\n        FeatureVectorSequence input = (FeatureVectorSequence) instance.getData();\r\n        FeatureSequence output = (FeatureSequence) instance.getTarget();\r\n        labeledWeight = new SumLatticeDefault(this.crf, input, output, null).getTotalWeight();\r\n        if (Double.isInfinite(labeledWeight)) {\r\n            ++numInfLabeledWeight;\r\n        }\r\n        Transducer.Incrementor incrementor = instanceWeight == 1.0 ? batchExpectations.new Incrementor() : batchExpectations.new WeightedIncrementor(instanceWeight);\r\n        unlabeledWeight = new SumLatticeDefault(this.crf, input, null, incrementor).getTotalWeight();\r\n        if (Double.isInfinite(unlabeledWeight)) {\r\n            ++numInfUnlabeledWeight;\r\n        }\r\n        weight = labeledWeight - unlabeledWeight;\r\n        if (Double.isInfinite(weight)) {\r\n            ++numInfWeight;\r\n        } else {\r\n            value += weight * instanceWeight;\r\n        }\r\n    }\r\n    batchExpectations.assertNotNaNOrInfinite();\r\n    if (numInfLabeledWeight > 0 || numInfUnlabeledWeight > 0 || numInfWeight > 0) {\r\n        logger.warning(\"Batch: \" + batchIndex + \", Number of instances with:\\n\" + \"\\t -infinite labeled weight: \" + numInfLabeledWeight + \"\\n\" + \"\\t -infinite unlabeled weight: \" + numInfUnlabeledWeight + \"\\n\" + \"\\t -infinite weight: \" + numInfWeight);\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.mage.test.serverside.base.impl.CardTestPlayerAPIImpl.setStopAt",
	"Comment": "define turn number and step to stop the game on. the game stops afterexecuting the step",
	"Method": "void setStopAt(int turn,PhaseStep step){\r\n    stopOnTurn = turn == -1 ? null : turn;\r\n    stopAtStep = step;\r\n}"
}, {
	"Path": "cc.mallet.pipe.CharSequenceReplaceHtmlEntities.replace",
	"Comment": "replace all the html entities in string with their corresponding unicode characters.",
	"Method": "String replace(String string){\r\n    if (string == null) {\r\n        return null;\r\n    }\r\n    string = string.replace(HTML_AMP, \"&\");\r\n    Set<String> digits = new HashSet();\r\n    Matcher digitsMatcher = PATTERN_HTML_ENTITY_DIGIT.matcher(string);\r\n    while (digitsMatcher.find()) {\r\n        digits.add(digitsMatcher.group());\r\n    }\r\n    if (digits.size() > 0) {\r\n        for (String digit : digits) {\r\n            int codePoint = Integer.valueOf(digit.substring(2, digit.length() - 1));\r\n            string = string.replace(digit, Character.toString((char) codePoint));\r\n        }\r\n    }\r\n    Set<String> alphas = new HashSet();\r\n    Matcher alphasMatcher = PATTERN_HTML_ENTITY_ALPHA.matcher(string);\r\n    while (alphasMatcher.find()) {\r\n        alphas.add(alphasMatcher.group());\r\n    }\r\n    if (alphas.size() > 0) {\r\n        for (String alpha : alphas) {\r\n            String name = alpha.substring(1, alpha.length() - 1);\r\n            string = string.replace(alpha, Character.toString((char) NAME_2_CODE_POINT.get(name).intValue()));\r\n        }\r\n    }\r\n    return string;\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.KarmicJusticeTest.testMultiplePermanentsDestroyedTriggeredAbility",
	"Comment": "karmic justice should triggers for each destroyed permanent",
	"Method": "void testMultiplePermanentsDestroyedTriggeredAbility(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"First Response\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Karmic Justice\");\r\n    addCard(Zone.HAND, playerB, \"Planar Cleansing\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mountain\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Swamp\", 1);\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Planar Cleansing\");\r\n    setChoice(playerA, \"Yes\");\r\n    addTarget(playerA, \"Plains\");\r\n    setChoice(playerA, \"Yes\");\r\n    addTarget(playerA, \"Swamp\");\r\n    setChoice(playerA, \"Yes\");\r\n    addTarget(playerA, \"Mountain\");\r\n    setStopAt(2, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerB, \"Planar Cleansing\", 1);\r\n    assertGraveyardCount(playerA, \"Karmic Justice\", 1);\r\n    assertGraveyardCount(playerA, \"First Response\", 2);\r\n    assertGraveyardCount(playerB, \"Mountain\", 1);\r\n    assertGraveyardCount(playerB, \"Swamp\", 1);\r\n    assertGraveyardCount(playerB, \"Plains\", 1);\r\n}"
}, {
	"Path": "cc.mallet.fst.CRFCacheStaleIndicator.isValueStale",
	"Comment": "returns true if the value is stale, also updates the cachevaluestamp.",
	"Method": "boolean isValueStale(){\r\n    if (crf.weightsValueChangeStamp != cachedValueChangeStamp) {\r\n        cachedValueChangeStamp = crf.weightsValueChangeStamp;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.redirect.ShamenEnKorTest.testFirstAbilityNonCombatDamage",
	"Comment": "tests that 2 of 3 damage is redirected while 1 damage is still dealt tooriginal target",
	"Method": "void testFirstAbilityNonCombatDamage(){\r\n    addCard(Zone.HAND, playerA, \"Lightning Bolt\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Shaman en-Kor\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Lightning Bolt\", \"Shaman en-Kor\");\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"{0}: The next 1 damage\", \"Silvercoat Lion\", \"Lightning Bolt\");\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"{0}: The next 1 damage\", \"Silvercoat Lion\", \"Lightning Bolt\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Lightning Bolt\", 1);\r\n    assertPermanentCount(playerB, \"Shaman en-Kor\", 1);\r\n    assertGraveyardCount(playerB, \"Silvercoat Lion\", 1);\r\n}"
}, {
	"Path": "cc.mallet.fst.tests.TestCRF.testDenseFeatureSelection",
	"Comment": "tests that setweightsdimensiondensely respects featureselections",
	"Method": "void testDenseFeatureSelection(){\r\n    Pipe p = makeSpacePredictionPipe();\r\n    InstanceList instances = new InstanceList(p);\r\n    instances.addThruPipe(new ArrayIterator(data));\r\n    CRF crf1 = new CRF(p, null);\r\n    crf1.addOrderNStates(instances, new int[] { 0 }, null, \"start\", null, null, true);\r\n    CRFTrainerByLabelLikelihood crft1 = new CRFTrainerByLabelLikelihood(crf1);\r\n    crft1.setUseSparseWeights(false);\r\n    crft1.train(instances, 1);\r\n    int nParams1 = crft1.getOptimizableCRF(instances).getNumParameters();\r\n    CRF crf2 = new CRF(p, null);\r\n    crf2.addOrderNStates(instances, new int[] { 0, 1 }, new boolean[] { false, true }, \"start\", null, null, true);\r\n    CRFTrainerByLabelLikelihood crft2 = new CRFTrainerByLabelLikelihood(crf2);\r\n    crft2.setUseSparseWeights(false);\r\n    crft2.train(instances, 1);\r\n    int nParams2 = crft2.getOptimizableCRF(instances).getNumParameters();\r\n    assertEquals(nParams2, nParams1 + 4);\r\n}"
}, {
	"Path": "org.mage.test.cards.rules.CantDrawTest.testCardsNotDrawnFromLibraryEffect",
	"Comment": "leovold, emissary of trest does not stop sylvan library from drawingextra cards.",
	"Method": "void testCardsNotDrawnFromLibraryEffect(){\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Leovold, Emissary of Trest\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Sylvan Library\", 1);\r\n    setStopAt(3, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, 0);\r\n    assertHandCount(playerA, 1);\r\n    assertLife(playerA, 16);\r\n}"
}, {
	"Path": "cc.mallet.pipe.Pipe.isTargetProcessing",
	"Comment": "return true iff this pipe expects and processes information inthe target slot.",
	"Method": "boolean isTargetProcessing(){\r\n    return targetProcessing;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.flicker.CloudshiftTest.testSpellFizzle",
	"Comment": "tests that casting cloudshift makes targeting spell fizzlingcloudshift exile target creature you control, then return that card tothe battlefield under your control.",
	"Method": "void testSpellFizzle(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Elite Vanguard\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\");\r\n    addCard(Zone.HAND, playerA, \"Cloudshift\");\r\n    addCard(Zone.HAND, playerA, \"Lightning Bolt\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Lightning Bolt\", \"Elite Vanguard\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Cloudshift\", \"Elite Vanguard\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Elite Vanguard\", 1);\r\n}"
}, {
	"Path": "org.mage.test.game.ends.GameIsADrawTest.GameDrawByInfiniteLoopNot",
	"Comment": "check that a simple triggered ability does not trigger the infinite looprequest to players",
	"Method": "void GameDrawByInfiniteLoopNot(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 43);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Angelic Chorus\", 1);\r\n    addCard(Zone.HAND, playerA, \"Entreat the Angels\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Entreat the Angels\");\r\n    setChoice(playerA, \"X=20\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Angel\", 20);\r\n    Assert.assertFalse(\"Game should not have ended.\", currentGame.hasEnded());\r\n    assertLife(playerA, 100);\r\n    Assert.assertFalse(\"No infinite loop detected, game has be no draw.\", currentGame.isADraw());\r\n}"
}, {
	"Path": "cc.mallet.topics.ParallelTopicModel.getInferencer",
	"Comment": "return a tool for estimating topic distributions for new documents",
	"Method": "TopicInferencer getInferencer(){\r\n    return new TopicInferencer(typeTopicCounts, tokensPerTopic, data.get(0).instance.getDataAlphabet(), alpha, beta, betaSum);\r\n}"
}, {
	"Path": "cc.mallet.classify.tui.Vectors2Info.printFeature",
	"Comment": "helper for printinstancelist. prints a single feature within an instance",
	"Method": "void printFeature(Object o,int fvi,double featureValue,String formatString){\r\n    char c1 = formatString.charAt(2);\r\n    if (c1 == 'w') {\r\n        System.out.print(\"  \" + o);\r\n    } else if (c1 == 'n') {\r\n        System.out.print(\"  \" + fvi);\r\n    } else if (c1 == 'c') {\r\n        System.out.print(\"  \" + o + \":\" + fvi);\r\n    } else if (c1 == 'e') {\r\n    }\r\n    char c2 = formatString.charAt(1);\r\n    if (c2 == 'i') {\r\n        System.out.print(\" \" + ((int) (featureValue + .5)));\r\n    } else if (c2 == 'b') {\r\n        System.out.print(\" \" + ((featureValue > 0.5) ? \"1\" : \"0\"));\r\n    }\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.lose.LoseAbilityByEquipmentTest.testGainVsLoseByEquipmentAbility",
	"Comment": "tests that gaining flying by and after that losing flying by eqipments results in not have flying",
	"Method": "void testGainVsLoseByEquipmentAbility(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Silvercoat Lion\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 4);\r\n    addCard(Zone.HAND, playerA, \"Magebane Armor\");\r\n    addCard(Zone.HAND, playerA, \"Cobbled Wings\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Magebane Armor\");\r\n    castSpell(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"Cobbled Wings\");\r\n    activateAbility(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"Equip {1}\", \"Silvercoat Lion\");\r\n    activateAbility(3, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Equip {2}\", \"Silvercoat Lion\");\r\n    setStopAt(3, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    Permanent silvercoatLion = getPermanent(\"Silvercoat Lion\", playerA.getId());\r\n    Assert.assertNotNull(silvercoatLion);\r\n    Assert.assertEquals(\"Silvercoat Lion equipments\", 2, silvercoatLion.getAttachments().size());\r\n    Assert.assertEquals(\"Silvercoat Lion power\", 4, silvercoatLion.getPower().getValue());\r\n    Assert.assertEquals(\"Silvercoat Lion toughness\", 6, silvercoatLion.getToughness().getValue());\r\n    Assert.assertFalse(\"Silvercoat Lion has flying but shouldn't have\", silvercoatLion.getAbilities().contains(FlyingAbility.getInstance()));\r\n}"
}, {
	"Path": "org.mage.test.cards.control.GainControlTargetEffectTest.testPermanentControlEffect",
	"Comment": "checks if control has changed and the controlled creature has haste",
	"Method": "void testPermanentControlEffect(){\r\n    addCard(Zone.HAND, playerA, \"Smelt-Ward Gatekeepers\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Boros Guildgate\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Smelt-Ward Gatekeepers\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Silvercoat Lion\", 1);\r\n    assertAbility(playerA, \"Silvercoat Lion\", HasteAbility.getInstance(), true);\r\n}"
}, {
	"Path": "org.mage.test.cards.watchers.HallOfTheBanditLordTest.testGainsHaste",
	"Comment": "test that a creature cast using hall of the bandit lord mana gains haste",
	"Method": "void testGainsHaste(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Hall of the Bandit Lord\");\r\n    addCard(Zone.HAND, playerA, \"Goblin Roughrider\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Goblin Roughrider\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    this.assertAbility(playerA, \"Goblin Roughrider\", HasteAbility.getInstance(), true);\r\n}"
}, {
	"Path": "cc.mallet.classify.MCMaxEntTrainer.setNumIterations",
	"Comment": "is that a bug?if so, should the default numiterations be higher?",
	"Method": "MCMaxEntTrainer setNumIterations(int i){\r\n    numIterations = i;\r\n    return this;\r\n}"
}, {
	"Path": "cc.mallet.classify.NaiveBayesTrainer.getFeatureMultinomialEstimator",
	"Comment": "get the multinomialestimator instance used to specify the type of estimator for features.",
	"Method": "Multinomial.Estimator getFeatureMultinomialEstimator(){\r\n    return featureEstimator;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.oneshot.counterspell.CrypticCommandTest.testCommand",
	"Comment": "test that if command has only one target and that targets is not valid onresolution, cryptic command fizzeles the player does not draw a card",
	"Method": "void testCommand(){\r\n    addCard(Zone.HAND, playerA, \"Thoughtseize\");\r\n    addCard(Zone.HAND, playerA, \"Remand\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 2);\r\n    addCard(Zone.HAND, playerB, \"Cryptic Command\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 4);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Thoughtseize\", playerB);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Cryptic Command\", \"Thoughtseize\");\r\n    setModeChoice(playerB, \"1\");\r\n    setModeChoice(playerB, \"4\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Remand\", \"Thoughtseize\", \"Cast Cryptic Command\");\r\n    setStopAt(1, PhaseStep.CLEANUP);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerA, \"Remand\", 1);\r\n    assertGraveyardCount(playerA, 1);\r\n    assertGraveyardCount(playerB, \"Cryptic Command\", 1);\r\n    assertGraveyardCount(playerB, 1);\r\n    assertHandCount(playerA, 2);\r\n    assertHandCount(playerB, 0);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.abilitywords.DomainTest.testCollapsingBorders",
	"Comment": "collapsing borders correctly does the 3 damage to each player at thebeginning of their upkeeps. however, it does not add any life for eachtype of basic land the player has on the field.",
	"Method": "void testCollapsingBorders(){\r\n    addCard(Zone.HAND, playerA, \"Collapsing Borders\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mountain\", 3);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Collapsing Borders\");\r\n    setStopAt(3, PhaseStep.PRECOMBAT_MAIN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Collapsing Borders\", 1);\r\n    assertLife(playerA, 21);\r\n    assertLife(playerB, 18);\r\n}"
}, {
	"Path": "org.mage.test.cards.control.PutIntoPlayEffectsTest.testLordOfTheVoid",
	"Comment": "checks if cards put into play with lord of the void triggered abilityare correctly controlled by the controller of lord of the voide.g. the top card of the library of the current controller of oracle of mul daya is revealed",
	"Method": "void testLordOfTheVoid(){\r\n    skipInitShuffling();\r\n    addCard(Zone.LIBRARY, playerA, \"Oracle of Mul Daya\", 4);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Lord of the Void\");\r\n    attack(2, playerB, \"Lord of the Void\");\r\n    setChoice(playerB, \"Oracle of Mul Daya\");\r\n    setStopAt(2, PhaseStep.POSTCOMBAT_MAIN);\r\n    execute();\r\n    assertLife(playerA, 13);\r\n    assertPermanentCount(playerB, \"Oracle of Mul Daya\", 1);\r\n    Assert.assertFalse(\"Top card of the library of player A should not be reveled.\", playerA.isTopCardRevealed());\r\n    Assert.assertTrue(\"Top card of the library of player B should be reveled.\", playerB.isTopCardRevealed());\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.SpellskiteTest.testDisabledEffectOnChangeZone",
	"Comment": "tests that wild defiance triggers for spellskite if spell target ischanged to spellskite",
	"Method": "void testDisabledEffectOnChangeZone(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Wild Defiance\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Spellskite\", 1);\r\n    addCard(Zone.HAND, playerA, \"Lightning Bolt\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Lightning Bolt\", playerB);\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"{U/P}: Change a target of target spell or ability to {this}.\", \"Lightning Bolt\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertAllCommandsUsed();\r\n    assertGraveyardCount(playerA, \"Lightning Bolt\", 1);\r\n    assertPermanentCount(playerA, \"Spellskite\", 1);\r\n    assertLife(playerA, 18);\r\n    assertLife(playerB, 20);\r\n    assertPowerToughness(playerA, \"Spellskite\", 3, 7);\r\n}"
}, {
	"Path": "cc.mallet.pipe.iterator.PipeInputIterator.getWeight",
	"Comment": "weights may also come from other raw input sources for instances in pipes.",
	"Method": "double getWeight(){\r\n    return 1.0;\r\n}"
}, {
	"Path": "cc.mallet.fst.semi_supervised.CRFOptimizableByGE.shutdown",
	"Comment": "should be called after training is complete to shutdown all threads.",
	"Method": "void shutdown(){\r\n    if (executor == null)\r\n        return;\r\n    executor.shutdown();\r\n    try {\r\n        executor.awaitTermination(30, TimeUnit.SECONDS);\r\n    } catch (InterruptedException e) {\r\n        e.printStackTrace();\r\n    }\r\n    assert (executor.shutdownNow().size() == 0) : \"All tasks didn't finish\";\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.other.SoulfireGrandMasterTest.testSearingBlood1",
	"Comment": "test with searing blood if the delayed triggered ability triggers, it hasto give life from lifelink because the source is still searing blood",
	"Method": "void testSearingBlood1(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 2);\r\n    addCard(Zone.HAND, playerA, \"Searing Blood\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Soulfire Grand Master\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Searing Blood\", \"Silvercoat Lion\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Soulfire Grand Master\", 1);\r\n    assertGraveyardCount(playerA, \"Searing Blood\", 1);\r\n    assertGraveyardCount(playerB, \"Silvercoat Lion\", 1);\r\n    assertLife(playerB, 17);\r\n    assertLife(playerA, 25);\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.DrawTriggeredTest.TwoConsecratedSphinxDifferentPlayers",
	"Comment": "two consecrated sphinxes do not work properly, only gives one playeradditional draw",
	"Method": "void TwoConsecratedSphinxDifferentPlayers(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Consecrated Sphinx\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Consecrated Sphinx\", 1);\r\n    setChoice(playerA, \"Yes\");\r\n    setChoice(playerA, \"No\");\r\n    setChoice(playerA, \"No\");\r\n    setChoice(playerB, \"Yes\");\r\n    setChoice(playerB, \"No\");\r\n    setStopAt(2, PhaseStep.PRECOMBAT_MAIN);\r\n    execute();\r\n    assertHandCount(playerB, 3);\r\n    assertHandCount(playerA, 2);\r\n}"
}, {
	"Path": "cc.mallet.fst.confidence.ConstrainedViterbiTransducerCorrector.getLeastConfidentSegments",
	"Comment": "returns the least confident segments from each sequence in the\t\t previous call to correctleastconfidentsegments",
	"Method": "ArrayList getLeastConfidentSegments(ArrayList getLeastConfidentSegments,InstanceList ilist,Object[] startTags,Object[] continueTags){\r\n    ArrayList ret = new ArrayList();\r\n    for (int i = 0; i < ilist.size(); i++) {\r\n        Segment[] orderedSegments = confidenceEstimator.rankSegmentsByConfidence(ilist.get(i), startTags, continueTags);\r\n        ret.add(orderedSegments[0]);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "cc.mallet.types.ROCData.getPositivePercent",
	"Comment": "gets the estimated percentage of training events that exceed thethreshold.",
	"Method": "double getPositivePercent(Label label,double threshold){\r\n    final int[] counts = getCounts(label, threshold);\r\n    final int positive = counts[TRUE_POSITIVE] + counts[FALSE_POSITIVE];\r\n    return ((double) positive / (double) (positive + counts[FALSE_NEGATIVE] + counts[TRUE_NEGATIVE])) * 100.0;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.TransformTest.testNoSpellsCastLastTurnTransformDoesNotTriggerTurn1",
	"Comment": "cards that transform if no spells cast last turn should not transform ifthe cards were added on turn 1. this would happen with tests and cheattesting.",
	"Method": "void testNoSpellsCastLastTurnTransformDoesNotTriggerTurn1(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Hinterland Logger\");\r\n    setStopAt(1, PhaseStep.PRECOMBAT_MAIN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Hinterland Logger\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.watchers.DiesExiledTest.testFrostwielder",
	"Comment": "test that when creature damaged by frostwielder dies it is exiled",
	"Method": "void testFrostwielder(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Frostwielder\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Sejiri Merfolk\");\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"{T}: {source} deals 1 damage to \", \"Sejiri Merfolk\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerB, \"Sejiri Merfolk\", 0);\r\n    assertExileCount(\"Sejiri Merfolk\", 1);\r\n}"
}, {
	"Path": "cc.mallet.classify.NaiveBayesTrainer.getPriorMultinomialEstimator",
	"Comment": "get the multinomialestimator instance used to specify the type of estimator for priors.",
	"Method": "Multinomial.Estimator getPriorMultinomialEstimator(){\r\n    return priorEstimator;\r\n}"
}, {
	"Path": "cc.mallet.extract.CRFExtractor.extract",
	"Comment": "assumes instance.source contains the tokenization object.",
	"Method": "Extraction extract(Object o,Extraction extract,Tokenization spans,Extraction extract,InstanceList ilist,Extraction extract,Iterator<Instance> source){\r\n    Extraction extraction = new Extraction(this, getTargetAlphabet());\r\n    InstanceList tokedList = new InstanceList(tokenizationPipe);\r\n    tokedList.addThruPipe(source);\r\n    InstanceList pipedList = new InstanceList(getFeaturePipe());\r\n    pipedList.addThruPipe(tokedList.iterator());\r\n    Iterator<Instance> it1 = tokedList.iterator();\r\n    Iterator<Instance> it2 = pipedList.iterator();\r\n    while (it1.hasNext()) {\r\n        Instance toked = it1.next();\r\n        Instance piped = it2.next();\r\n        Tokenization tok = (Tokenization) toked.getData();\r\n        String name = piped.getName().toString();\r\n        Sequence input = (Sequence) piped.getData();\r\n        Sequence target = (Sequence) piped.getTarget();\r\n        Sequence output = crf.transduce(input);\r\n        DocumentExtraction docseq = new DocumentExtraction(name, getTargetAlphabet(), tok, output, target, backgroundTag, filter);\r\n        extraction.addDocumentExtraction(docseq);\r\n    }\r\n    return extraction;\r\n}"
}, {
	"Path": "cc.mallet.classify.MCMaxEntTrainer.setGaussianPriorVariance",
	"Comment": "sets a parameter to prevent overtraining.a smaller variance for the priormeans that feature weights are expected to hover closer to 0, so extraevidence is required to set a higher weight.",
	"Method": "MCMaxEntTrainer setGaussianPriorVariance(double gaussianPriorVariance){\r\n    this.usingHyperbolicPrior = false;\r\n    this.gaussianPriorVariance = gaussianPriorVariance;\r\n    return this;\r\n}"
}, {
	"Path": "org.mage.test.cards.copy.PhantasmalImageTest.testCopyBecomesTargetTriggeredAbility",
	"Comment": "tests copying creature with becomestargettriggeredability",
	"Method": "void testCopyBecomesTargetTriggeredAbility(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 4);\r\n    addCard(Zone.HAND, playerA, \"Phantasmal Image\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Illusionary Servant\");\r\n    setChoice(playerA, \"Illusionary Servant\");\r\n    setChoice(playerA, \"Illusionary Servant-M10\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Phantasmal Image\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Phantasmal Image\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerA, 0);\r\n    assertPermanentCount(playerA, \"Illusionary Servant\", 3);\r\n}"
}, {
	"Path": "cc.mallet.fst.ThreadedOptimizable.createTasks",
	"Comment": "creates tasks to be executed in parallel, each task looks at a batch of\tdata.",
	"Method": "void createTasks(){\r\n    int numBatches = optimizable.getNumBatches();\r\n    valueTasks = new ArrayList<Callable<Double>>(numBatches);\r\n    gradientTasks = new ArrayList<Callable<Boolean>>(numBatches);\r\n    int numBatchInstances = trainingSet.size() / numBatches;\r\n    int start = -1, end = -1;\r\n    for (int i = 0; i < numBatches; ++i) {\r\n        if (i == 0) {\r\n            start = 0;\r\n            end = start + numBatchInstances;\r\n        } else if (i == numBatches - 1) {\r\n            start = end;\r\n            end = trainingSet.size();\r\n        } else {\r\n            start = end;\r\n            end = start + numBatchInstances;\r\n        }\r\n        valueTasks.add(new ValueHandler(i, new int[] { start, end }));\r\n        gradientTasks.add(new GradientHandler(i, new int[] { start, end }));\r\n    }\r\n}"
}, {
	"Path": "cc.mallet.types.Dirichlet.dirichletMultinomialLikelihoodRatio",
	"Comment": "what is the probability that these two observations were drawn from\t \tthe same multinomial with symmetric dirichlet prior alpha, relative \t \tto the probability that they were drawn from different multinomials\t \tboth drawn from this dirichlet?",
	"Method": "double dirichletMultinomialLikelihoodRatio(IntIntHashMap countsX,IntIntHashMap countsY,double alpha,double alphaSum,double dirichletMultinomialLikelihoodRatio,int[] countsX,int[] countsY,double alpha,double alphaSum,double dirichletMultinomialLikelihoodRatio,int[] countsX,int[] countsY){\r\n    if (countsX.length != countsY.length || countsX.length != partition.length) {\r\n        throw new IllegalArgumentException(\"both arrays and the Dirichlet prior must contain the same number of dimensions\");\r\n    }\r\n    double logLikelihood = 0.0;\r\n    double alpha;\r\n    int totalX = 0;\r\n    int totalY = 0;\r\n    int x, y;\r\n    for (int key = 0; key < countsX.length; key++) {\r\n        x = countsX[key];\r\n        y = countsY[key];\r\n        totalX += x;\r\n        totalY += y;\r\n        alpha = partition[key] * magnitude;\r\n        logLikelihood += logGamma(alpha) + logGamma(alpha + x + y) - logGamma(alpha + x) - logGamma(alpha + y);\r\n    }\r\n    logLikelihood += logGamma(magnitude + totalX) + logGamma(magnitude + totalY) - logGamma(magnitude) - logGamma(magnitude + totalX + totalY);\r\n    return logLikelihood;\r\n}"
}, {
	"Path": "cc.mallet.topics.ParallelTopicModel.initializeHistograms",
	"Comment": "gather statistics on the size of documentsand create histograms for use in dirichlet hyperparameter optimization.",
	"Method": "void initializeHistograms(){\r\n    int maxTokens = 0;\r\n    totalTokens = 0;\r\n    int seqLen;\r\n    for (int doc = 0; doc < data.size(); doc++) {\r\n        FeatureSequence fs = (FeatureSequence) data.get(doc).instance.getData();\r\n        seqLen = fs.getLength();\r\n        if (seqLen > maxTokens)\r\n            maxTokens = seqLen;\r\n        totalTokens += seqLen;\r\n    }\r\n    logger.info(\"max tokens: \" + maxTokens);\r\n    logger.info(\"total tokens: \" + totalTokens);\r\n    docLengthCounts = new int[maxTokens + 1];\r\n    topicDocCounts = new int[numTopics][maxTokens + 1];\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.oneshot.counterspell.EndrekSahrMasterBreederTest.testTokenAlsoIfCountered",
	"Comment": "test that tokens are created also if the spell that triggers endreks ability is countered",
	"Method": "void testTokenAlsoIfCountered(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Endrek Sahr, Master Breeder\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 2);\r\n    addCard(Zone.HAND, playerA, \"Silvercoat Lion\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    addCard(Zone.HAND, playerB, \"Counterspell\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Silvercoat Lion\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Counterspell\", \"Silvercoat Lion\", \"Silvercoat Lion\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerA, \"Silvercoat Lion\", 1);\r\n    assertGraveyardCount(playerB, \"Counterspell\", 1);\r\n    assertPermanentCount(playerA, \"Thrull\", 2);\r\n}"
}, {
	"Path": "cc.mallet.classify.NaiveBayes.classify",
	"Comment": "classify an instance using naivebayes according to the trained data. the alphabet of the featurevector of the instance must match thealphabe of the pipe used to train the classifier.",
	"Method": "Classification classify(Instance instance){\r\n    int numClasses = getLabelAlphabet().size();\r\n    double[] scores = new double[numClasses];\r\n    FeatureVector fv = (FeatureVector) instance.getData();\r\n    assert (instancePipe == null || fv.getAlphabet() == instancePipe.getDataAlphabet());\r\n    int fvisize = fv.numLocations();\r\n    prior.addLogProbabilities(scores);\r\n    for (int fvi = 0; fvi < fvisize; fvi++) {\r\n        int fi = fv.indexAtLocation(fvi);\r\n        for (int ci = 0; ci < numClasses; ci++) {\r\n            if (ci >= p.length || fi >= p[ci].size())\r\n                continue;\r\n            scores[ci] += fv.valueAtLocation(fvi) * p[ci].logProbability(fi);\r\n        }\r\n    }\r\n    double maxScore = Double.NEGATIVE_INFINITY;\r\n    for (int ci = 0; ci < numClasses; ci++) if (scores[ci] > maxScore)\r\n        maxScore = scores[ci];\r\n    for (int ci = 0; ci < numClasses; ci++) scores[ci] -= maxScore;\r\n    double sum = 0;\r\n    for (int ci = 0; ci < numClasses; ci++) sum += (scores[ci] = Math.exp(scores[ci]));\r\n    for (int ci = 0; ci < numClasses; ci++) scores[ci] /= sum;\r\n    return new Classification(instance, this, new LabelVector(getLabelAlphabet(), scores));\r\n}"
}, {
	"Path": "org.mage.test.cards.prevention.PreventAttachedEffectTest.testDamageToPlayerPrevented",
	"Comment": "kaervek the merciless still deals damage with the triggered ability whenenchanted with temporal isolation.",
	"Method": "void testDamageToPlayerPrevented(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Kaervek the Merciless\");\r\n    addCard(Zone.HAND, playerA, \"Temporal Isolation\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 2);\r\n    addCard(Zone.HAND, playerB, \"Silvercoat Lion\", 1);\r\n    addCard(Zone.HAND, playerB, \"Pillarfield Ox\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 6);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Temporal Isolation\", \"Kaervek the Merciless\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Silvercoat Lion\");\r\n    addTarget(playerA, playerB);\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Pillarfield Ox\");\r\n    addTarget(playerA, \"Silvercoat Lion\");\r\n    setStopAt(2, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Kaervek the Merciless\", 1);\r\n    assertPermanentCount(playerA, \"Temporal Isolation\", 1);\r\n    assertPermanentCount(playerB, \"Silvercoat Lion\", 1);\r\n    assertPermanentCount(playerB, \"Pillarfield Ox\", 1);\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n}"
}, {
	"Path": "org.mage.test.cards.copy.MirrorworksTest.TestCopyWithoutLand",
	"Comment": "if you play mox diamond, with mirrorworks in play, and create a tokencopy, and you have no lands in hand, the mox will enter the battlefieldas usual instead of the graveyard.",
	"Method": "void TestCopyWithoutLand(){\r\n    addCard(Zone.HAND, playerA, \"Mountain\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 2);\r\n    addCard(Zone.HAND, playerA, \"Mox Diamond\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mirrorworks\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Mox Diamond\");\r\n    setChoice(playerA, \"Yes\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Mox Diamond\", 1);\r\n    assertTappedCount(\"Island\", true, 2);\r\n    assertGraveyardCount(playerA, \"Mountain\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.KickerTest.testKickerGoneForRecast",
	"Comment": "if a creature is cast with kicker, dies, and is then returned to playfrom graveyard, it still behaves like it were kicked. i noticed thiswhile testing some newly implemented cards, but it can be reproduced forexample by zombifying a gatekeeper of malakir.",
	"Method": "void testKickerGoneForRecast(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 5);\r\n    addCard(Zone.HAND, playerA, \"Gatekeeper of Malakir\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Birds of Paradise\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    addCard(Zone.HAND, playerB, \"Boomerang\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Gatekeeper of Malakir\");\r\n    addTarget(playerA, playerB);\r\n    setChoice(playerA, \"Yes\");\r\n    castSpell(1, PhaseStep.BEGIN_COMBAT, playerB, \"Boomerang\", \"Gatekeeper of Malakir\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Gatekeeper of Malakir\");\r\n    setChoice(playerA, \"No\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertGraveyardCount(playerB, \"Boomerang\", 1);\r\n    assertGraveyardCount(playerB, \"Birds of Paradise\", 1);\r\n    assertPermanentCount(playerB, \"Birds of Paradise\", 1);\r\n    assertPermanentCount(playerA, \"Gatekeeper of Malakir\", 1);\r\n}"
}, {
	"Path": "cc.mallet.fst.CRFOptimizableByLabelLikelihood.getNumParameters",
	"Comment": "todo move these implementations into crf.java, and put here stubs that call them!",
	"Method": "int getNumParameters(){\r\n    return crf.parameters.getNumFactors();\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.MorphTest.testCloneFaceUpMorphEffect",
	"Comment": "clone a morph creature that was cast face down and meanwhile was turnedface up",
	"Method": "void testCloneFaceUpMorphEffect(){\r\n    addCard(Zone.HAND, playerA, \"Sagu Mauler\");\r\n    addCard(Zone.HAND, playerA, \"Clone\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 3);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Sagu Mauler\");\r\n    setChoice(playerA, \"Yes\");\r\n    activateAbility(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"{3}{G}{U}: Turn this face-down permanent face up.\");\r\n    castSpell(5, PhaseStep.PRECOMBAT_MAIN, playerA, \"Clone\");\r\n    setChoice(playerA, \"Sagu Mauler\");\r\n    setStopAt(5, PhaseStep.END_COMBAT);\r\n    execute();\r\n    assertLife(playerB, 20);\r\n    assertHandCount(playerA, \"Sagu Mauler\", 0);\r\n    assertHandCount(playerA, \"Clone\", 0);\r\n    assertPermanentCount(playerA, \"Sagu Mauler\", 2);\r\n    assertPowerToughness(playerA, \"Sagu Mauler\", 6, 6, Filter.ComparisonScope.Any);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.other.SoulfireGrandMasterTest.testSearinBlood2",
	"Comment": "test with searing blood if the delayed triggered ability triggers, it hasto give life from lifelink because the source is still searing blood",
	"Method": "void testSearinBlood2(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 3);\r\n    addCard(Zone.HAND, playerA, \"Searing Blood\");\r\n    addCard(Zone.HAND, playerA, \"Lightning Bolt\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Soulfire Grand Master\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Pillarfield Ox\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Searing Blood\", \"Pillarfield Ox\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Lightning Bolt\", \"Pillarfield Ox\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Soulfire Grand Master\", 1);\r\n    assertGraveyardCount(playerA, \"Searing Blood\", 1);\r\n    assertGraveyardCount(playerA, \"Lightning Bolt\", 1);\r\n    assertGraveyardCount(playerB, \"Pillarfield Ox\", 1);\r\n    assertLife(playerB, 17);\r\n    assertLife(playerA, 28);\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.HallowedMoonlightTest.testRallyTheAncestors",
	"Comment": "i cast rally the ancestors with many creatures in my graveyard. opponentresponds with hallowed moonlight. after rally the ancestors resolves, thecreature cards in my graveyard remain in my graveyard, but are also addedto the exile zone.",
	"Method": "void testRallyTheAncestors(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 2);\r\n    addCard(Zone.HAND, playerA, \"Hallowed Moonlight\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 6);\r\n    addCard(Zone.HAND, playerB, \"Rally the Ancestors\");\r\n    addCard(Zone.GRAVEYARD, playerB, \"Pillarfield Ox\");\r\n    addCard(Zone.GRAVEYARD, playerB, \"Silvercoat Lion\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Rally the Ancestors\");\r\n    setChoice(playerB, \"X=4\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerA, \"Hallowed Moonlight\", NO_TARGET, \"Rally the Ancestors\");\r\n    setStopAt(2, PhaseStep.END_TURN);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Hallowed Moonlight\", 1);\r\n    assertExileCount(\"Rally the Ancestors\", 1);\r\n    assertExileCount(\"Pillarfield Ox\", 1);\r\n    assertExileCount(\"Silvercoat Lion\", 1);\r\n}"
}, {
	"Path": "cc.mallet.types.Dirichlet.digamma",
	"Comment": "calculate digamma using an asymptotic expansion involvingbernoulli numbers.",
	"Method": "double digamma(double z){\r\n    double psi = 0;\r\n    if (z < DIGAMMA_SMALL) {\r\n        psi = EULER_MASCHERONI - (1 / z);\r\n        return psi;\r\n    }\r\n    while (z < DIGAMMA_LARGE) {\r\n        psi -= 1 / z;\r\n        z++;\r\n    }\r\n    double invZ = 1 / z;\r\n    double invZSquared = invZ * invZ;\r\n    psi += Math.log(z) - .5 * invZ - invZSquared * (DIGAMMA_COEF_1 - invZSquared * (DIGAMMA_COEF_2 - invZSquared * (DIGAMMA_COEF_3 - invZSquared * (DIGAMMA_COEF_4 - invZSquared * (DIGAMMA_COEF_5 - invZSquared * (DIGAMMA_COEF_6 - invZSquared * DIGAMMA_COEF_7))))));\r\n    return psi;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.StormTest.testStormAndFlashback",
	"Comment": "i provide a game log fo the issue with storm mentioned earlier. i guesspyromancer ascension is a culprit.",
	"Method": "void testStormAndFlashback(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 8);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 1);\r\n    addCard(Zone.HAND, playerA, \"Geistflame\", 2);\r\n    addCard(Zone.LIBRARY, playerA, \"Grapeshot\", 2);\r\n    skipInitShuffling();\r\n    addCard(Zone.HAND, playerA, \"Sleight of Hand\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Sleight of Hand\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Geistflame\", playerB);\r\n    activateAbility(1, PhaseStep.BEGIN_COMBAT, playerA, \"Flashback {3}{R}\");\r\n    addTarget(playerA, playerB);\r\n    castSpell(1, PhaseStep.END_COMBAT, playerA, \"Geistflame\", playerB);\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Grapeshot\", playerB);\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertExileCount(\"Geistflame\", 1);\r\n    assertGraveyardCount(playerA, \"Geistflame\", 1);\r\n    assertGraveyardCount(playerA, \"Grapeshot\", 1);\r\n    assertLife(playerB, 12);\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.PillarOfFlameTest.testNotTriggeringExileItInstead",
	"Comment": "tests when cast pillar of flame targeting opponent there is no influenceon dying creature of opponent",
	"Method": "void testNotTriggeringExileItInstead(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Lightning Mauler\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Rakdos Cackler\");\r\n    addCard(Zone.HAND, playerA, \"Pillar of Flame\");\r\n    addCard(Zone.HAND, playerA, \"Stonewright\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Dutiful Thrull\");\r\n    castSpell(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"Pillar of Flame\", playerB);\r\n    castSpell(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"Stonewright\");\r\n    attack(3, playerA, \"Rakdos Cackler\");\r\n    attack(3, playerA, \"Lightning Mauler\");\r\n    block(3, playerB, \"Dutiful Thrull\", \"Lightning Mauler\");\r\n    setStopAt(3, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 16);\r\n    assertPermanentCount(playerA, \"Rakdos Cackler\", 1);\r\n    assertPermanentCount(playerA, \"Lightning Mauler\", 0);\r\n    assertPermanentCount(playerA, \"Stonewright\", 1);\r\n    assertGraveyardCount(playerA, 2);\r\n    assertGraveyardCount(playerB, 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.single.soi.ErdwalIlluminatorTest.investigateFirstTimeTriggers",
	"Comment": "whenever you investigate for the first time each turn, investigate an additional time.",
	"Method": "void investigateFirstTimeTriggers(){\r\n    addCard(Zone.HAND, playerA, \"Thraben Inspector\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Erdwal Illuminator\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 2);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Thraben Inspector\");\r\n    setStopAt(2, PhaseStep.POSTCOMBAT_MAIN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Clue\", 2);\r\n}"
}, {
	"Path": "org.mage.test.cards.mana.ReflectingPoolTest.testWithExoticOrchard",
	"Comment": "reflecting pool does not see what mana exotic orchard can produce",
	"Method": "void testWithExoticOrchard(){\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mountain\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Reflecting Pool\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Exotic Orchard\", 1);\r\n    setStopAt(1, PhaseStep.PRECOMBAT_MAIN);\r\n    execute();\r\n    ManaOptions options = playerA.getAvailableManaTest(currentGame);\r\n    Assert.assertEquals(\"Player should be able to create 2 red mana\", \"{R}{R}\", options.get(0).toString());\r\n}"
}, {
	"Path": "org.mage.test.multiplayer.PrimordialTest.DiluvianPrimordialTest",
	"Comment": "diluvian primordial etb trigger never happened in a 3 player ffacommander game. he just resolved, no etb trigger occurred.",
	"Method": "void DiluvianPrimordialTest(){\r\n    addCard(Zone.HAND, playerA, \"Diluvian Primordial\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 7);\r\n    addCard(Zone.GRAVEYARD, playerB, \"Lightning Bolt\");\r\n    addCard(Zone.GRAVEYARD, playerC, \"Lightning Bolt\");\r\n    addCard(Zone.GRAVEYARD, playerD, \"Lightning Bolt\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Diluvian Primordial\");\r\n    addTarget(playerA, \"Lightning Bolt\");\r\n    addTarget(playerA, \"Lightning Bolt\");\r\n    addTarget(playerA, playerB);\r\n    addTarget(playerA, playerD);\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Diluvian Primordial\", 1);\r\n    assertGraveyardCount(playerC, \"Lightning Bolt\", 1);\r\n    assertExileCount(\"Lightning Bolt\", 2);\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 17);\r\n    assertLife(playerC, 20);\r\n    assertLife(playerD, 17);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.EmergeTest.testCastWithEmerge",
	"Comment": "wretched gryff is bugged. i could not use its emerge ability. clicking onthe card did not give me the interaction menu.",
	"Method": "void testCastWithEmerge(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 4);\r\n    addCard(Zone.HAND, playerA, \"Wretched Gryff\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Silvercoat Lion\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Wretched Gryff with emerge\");\r\n    setChoice(playerA, \"Silvercoat Lion\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Silvercoat Lion\", 1);\r\n    assertPermanentCount(playerA, \"Wretched Gryff\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.single.DaybreakCoronetTest.testTargetGetsIllegal",
	"Comment": "if daybreak coronet is already attached to a permanent andthe other aura is destroyed. the target for daybreak coronetgets illegal and the daybreak coronet has to go to graveyard.",
	"Method": "void testTargetGetsIllegal(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Silvercoat Lion\");\r\n    addCard(Zone.HAND, playerA, \"Holy Strength\");\r\n    addCard(Zone.HAND, playerA, \"Daybreak Coronet\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\", 1);\r\n    addCard(Zone.HAND, playerB, \"Demystify\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Holy Strength\", \"Silvercoat Lion\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Daybreak Coronet\", \"Silvercoat Lion\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerB, \"Demystify\", \"Holy Strength\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertGraveyardCount(playerA, \"Holy Strength\", 1);\r\n    assertGraveyardCount(playerB, \"Demystify\", 1);\r\n    assertPermanentCount(playerA, \"Daybreak Coronet\", 0);\r\n    assertGraveyardCount(playerA, \"Daybreak Coronet\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.cost.custom.SerraAvengerTest.testCard",
	"Comment": "try to cast serra avenger on 1st, 2nd, 3rd and 4th turns.it should success only on 4th one.",
	"Method": "void testCard(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 2);\r\n    addCard(Zone.HAND, playerA, \"Serra Avenger\", 4);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Serra Avenger\");\r\n    castSpell(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"Serra Avenger\");\r\n    castSpell(5, PhaseStep.PRECOMBAT_MAIN, playerA, \"Serra Avenger\");\r\n    castSpell(7, PhaseStep.PRECOMBAT_MAIN, playerA, \"Serra Avenger\");\r\n    setStopAt(7, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Serra Avenger\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.single.ogw.RealitySmasherTest.testTargettedByPyromancerGoggleCopy",
	"Comment": "cannot figure out how to setup any of these tests to work with reality smashers triggered ability",
	"Method": "void testTargettedByPyromancerGoggleCopy(){\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Reality Smasher\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Pyromancer's Goggles\");\r\n    addCard(Zone.HAND, playerA, \"Lightning Bolt\");\r\n    addCard(Zone.HAND, playerA, \"Swamp\", 2);\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"{T}:\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Lightning Bolt\");\r\n    addTarget(playerA, \"Reality Smasher\");\r\n    setChoice(playerA, \"Yes\");\r\n    setChoice(playerA, \"Swamp\");\r\n    setChoice(playerA, \"No\");\r\n    setChoice(playerA, \"Yes\");\r\n    setChoice(playerA, \"Swamp\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Lightning Bolt\", 1);\r\n    assertGraveyardCount(playerA, \"Swamp\", 2);\r\n    assertGraveyardCount(playerB, \"Reality Smasher\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.replacement.SkullbriarTest.testSkullbriarCloudshift",
	"Comment": "skullbriar retains counters even when humility is on the field.",
	"Method": "void testSkullbriarCloudshift(){\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Skullbriar, the Walking Grave\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Plains\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Forest\");\r\n    addCard(Zone.HAND, playerB, \"Battlegrowth\");\r\n    addCard(Zone.HAND, playerB, \"Cloudshift\");\r\n    castSpell(1, PhaseStep.UPKEEP, playerB, \"Battlegrowth\", \"Skullbriar, the Walking Grave\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Cloudshift\", \"Skullbriar, the Walking Grave\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertCounterCount(\"Skullbriar, the Walking Grave\", CounterType.P1P1, 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.MorphTest.testCastMorphCreatureWithoutMorph",
	"Comment": "tests if a creature with morph is cast normal, it behaves as normalcreature",
	"Method": "void testCastMorphCreatureWithoutMorph(){\r\n    addCard(Zone.HAND, playerA, \"Pine Walker\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 5);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Pine Walker\");\r\n    setChoice(playerA, \"No\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Pine Walker\", 1);\r\n    assertPowerToughness(playerA, \"Pine Walker\", 5, 5);\r\n}"
}, {
	"Path": "cc.mallet.pipe.FeatureCountPipe.getPrunedAlphabet",
	"Comment": "returns a new alphabet that contains only features at or abovethe specified limit.",
	"Method": "Alphabet getPrunedAlphabet(int minimumCount){\r\n    Alphabet currentAlphabet = getDataAlphabet();\r\n    Alphabet prunedAlphabet = new Alphabet();\r\n    for (int feature = 0; feature < currentAlphabet.size(); feature++) {\r\n        if (counter.get(feature) >= minimumCount) {\r\n            prunedAlphabet.lookupIndex(currentAlphabet.lookupObject(feature));\r\n        }\r\n    }\r\n    prunedAlphabet.stopGrowth();\r\n    return prunedAlphabet;\r\n}"
}, {
	"Path": "cc.mallet.topics.PolylingualTopicModel.getInferencer",
	"Comment": "return a tool for estimating topic distributions for new documents",
	"Method": "TopicInferencer getInferencer(int language){\r\n    return new TopicInferencer(languageTypeTopicCounts[language], languageTokensPerTopic[language], alphabets[language], alpha, betas[language], betaSums[language]);\r\n}"
}, {
	"Path": "cc.mallet.pipe.iterator.DBInstanceIterator.byteArrayToIntArray",
	"Comment": "convert an array of bytes to an array of integers by copying the bits directly. based on code at java2s.com.",
	"Method": "int[] byteArrayToIntArray(byte[] src){\r\n    int dstLength = src.length >>> 2;\r\n    int[] dst = new int[dstLength];\r\n    for (int i = 0; i < dstLength; i++) {\r\n        int j = i << 2;\r\n        int x = 0;\r\n        x += (src[j++] & 0xff) << 0;\r\n        x += (src[j++] & 0xff) << 8;\r\n        x += (src[j++] & 0xff) << 16;\r\n        x += (src[j++] & 0xff) << 24;\r\n        dst[i] = x;\r\n    }\r\n    return dst;\r\n}"
}, {
	"Path": "org.mage.test.cards.enchantments.AnimateDeadTest.testAnimateAndSacrificeTarget",
	"Comment": "animate dead is incorrectly not entering the graveyard when the animatedtarget is sacrificed.",
	"Method": "void testAnimateAndSacrificeTarget(){\r\n    addCard(Zone.HAND, playerB, \"Cruel Edict\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Swamp\", 2);\r\n    addCard(Zone.GRAVEYARD, playerB, \"Silvercoat Lion\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Swamp\", 2);\r\n    addCard(Zone.HAND, playerA, \"Animate Dead\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Animate Dead\", \"Silvercoat Lion\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Cruel Edict\", playerA);\r\n    setStopAt(2, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerB, \"Cruel Edict\", 1);\r\n    assertGraveyardCount(playerB, \"Silvercoat Lion\", 1);\r\n    assertGraveyardCount(playerA, \"Animate Dead\", 1);\r\n}"
}, {
	"Path": "org.mage.test.combat.AttackBlockRestrictionsTest.testFlyingVsNonFlying2",
	"Comment": "reproduced bug in combat blocking related to singleton classes",
	"Method": "void testFlyingVsNonFlying2(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 2);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Savannah Lions\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Azure Drake\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Aven Squire\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Llanowar Elves\");\r\n    addCard(Zone.HAND, playerA, \"Turn to Frog\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Walking Corpse\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Llanowar Elves\");\r\n    castSpell(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"Turn to Frog\", \"Aven Squire\");\r\n    attack(3, playerA, \"Llanowar Elves\");\r\n    attack(3, playerA, \"Azure Drake\");\r\n    attack(3, playerA, \"Aven Squire\");\r\n    attack(3, playerA, \"Savannah Lions\");\r\n    block(3, playerB, \"Llanowar Elves\", \"Azure Drake\");\r\n    block(3, playerB, \"Walking Corpse\", \"Aven Squire\");\r\n    setStopAt(3, PhaseStep.END_TURN);\r\n    execute();\r\n    assertLife(playerB, 15);\r\n    assertLife(playerA, 20);\r\n    assertPermanentCount(playerB, \"Aven Squire\", 0);\r\n    assertPermanentCount(playerB, \"Walking Corpse\", 1);\r\n    assertPermanentCount(playerB, \"Llanowar Elves\", 1);\r\n}"
}, {
	"Path": "cc.mallet.classify.MaxEntOptimizableByLabelDistribution.setGaussianPriorVariance",
	"Comment": "sets a parameter to prevent overtraining.a smaller variance for the prior\tmeans that feature weights are expected to hover closer to 0, so extra\tevidence is required to set a higher weight.",
	"Method": "MaxEntOptimizableByLabelDistribution setGaussianPriorVariance(double gaussianPriorVariance){\r\n    this.gaussianPriorVariance = gaussianPriorVariance;\r\n    return this;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.oneshot.damage.RuneflareTrapTest.testDamageFromInstantToPlayer",
	"Comment": "runeflare trap counts the starting hand as card draw for the purpose ofenabling its alternative casting cost, which allows for a turn 1 cast for1 red mana dealing up to 7 damage.",
	"Method": "void testDamageFromInstantToPlayer(){\r\n    addCard(Zone.HAND, playerB, \"Runeflare Trap\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Mountain\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Runeflare Trap\", playerA);\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 20);\r\n    assertHandCount(playerB, \"Runeflare Trap\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.triggers.UlamogTheInfiniteGyreTest.testDisabledEffectOnChangeZone",
	"Comment": "tests if ulamog, the infinite gyre is countered its triggered abilityresolves anyway",
	"Method": "void testDisabledEffectOnChangeZone(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 11);\r\n    addCard(Zone.HAND, playerA, \"Ulamog, the Infinite Gyre\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    addCard(Zone.HAND, playerB, \"Counterspell\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Ulamog, the Infinite Gyre\");\r\n    addTarget(playerA, \"Island\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerB, \"Counterspell\", \"Ulamog, the Infinite Gyre\", \"Ulamog, the Infinite Gyre\");\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertHandCount(playerA, \"Ulamog, the Infinite Gyre\", 0);\r\n    assertPermanentCount(playerA, \"Ulamog, the Infinite Gyre\", 0);\r\n    assertGraveyardCount(playerB, \"Counterspell\", 1);\r\n    assertPermanentCount(playerB, \"Island\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.copy.LazavDimirMastermindTest.testRatsHaveDeathtouch",
	"Comment": "tests copy card with static abilitiy gaining ability to other permanents",
	"Method": "void testRatsHaveDeathtouch(){\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Lazav, Dimir Mastermind\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Gutter Skulk\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Codex Shredder\", 1);\r\n    addCard(Zone.LIBRARY, playerB, \"Ogre Slumlord\", 5);\r\n    skipInitShuffling();\r\n    activateAbility(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"{T}: Target player puts the top card of their library into their graveyard.\", playerB);\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Lazav, Dimir Mastermind\", 1);\r\n    assertPowerToughness(playerA, \"Lazav, Dimir Mastermind\", 3, 3);\r\n    Permanent lazav = getPermanent(\"Lazav, Dimir Mastermind\", playerA.getId());\r\n    Assert.assertTrue(lazav.getSubtype(currentGame).contains(SubType.OGRE));\r\n    Assert.assertTrue(lazav.getSubtype(currentGame).contains(SubType.ROGUE));\r\n    Permanent gutterSkulk = getPermanent(\"Gutter Skulk\", playerA.getId());\r\n    Assert.assertTrue(\"Gutter Skulk should have deathtouch but hasn't\", gutterSkulk.getAbilities().contains(DeathtouchAbility.getInstance()));\r\n}"
}, {
	"Path": "org.mage.test.cards.mana.ReflectingPoolTest.testTriggeredManaAbility",
	"Comment": "reflecting pool does not count crumbling vestige as a source of all manacolors",
	"Method": "void testTriggeredManaAbility(){\r\n    addCard(Zone.HAND, playerA, \"Lightning Bolt\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Reflecting Pool\", 1);\r\n    addCard(Zone.HAND, playerA, \"Crumbling Vestige\", 1);\r\n    playLand(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Crumbling Vestige\");\r\n    setChoice(playerA, \"Red\");\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Lightning Bolt\", playerB);\r\n    setStopAt(1, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Crumbling Vestige\", 1);\r\n    assertGraveyardCount(playerA, \"Lightning Bolt\", 1);\r\n    assertLife(playerA, 20);\r\n    assertLife(playerB, 17);\r\n}"
}, {
	"Path": "cc.mallet.types.SparseVector.arrayCopyFrom",
	"Comment": "copy values from an array starting at a particular location into thisvector. the array must have at least as many values beyond the starting location as there are in the vector.",
	"Method": "void arrayCopyFrom(double[] a,int arrayCopyFrom,double[] a,int startingArrayLocation){\r\n    System.arraycopy(a, startingArrayLocation, values, 0, values.length);\r\n    return startingArrayLocation + values.length;\r\n}"
}, {
	"Path": "org.mage.test.cards.abilities.keywords.SoulbondKeywordTest.testRebondOnNextCreature",
	"Comment": "tests that after loosing first pair it is possible to pair creature withanother one",
	"Method": "void testRebondOnNextCreature(){\r\n    addCard(Zone.HAND, playerA, \"Phantasmal Bear\");\r\n    addCard(Zone.HAND, playerA, \"Trusted Forcemage\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Elite Vanguard\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Forest\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Mountain\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Plains\", 3);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 3);\r\n    addCard(Zone.HAND, playerA, \"Lightning Bolt\", 1);\r\n    castSpell(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Trusted Forcemage\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Lightning Bolt\", \"Elite Vanguard\");\r\n    castSpell(1, PhaseStep.POSTCOMBAT_MAIN, playerA, \"Phantasmal Bear\");\r\n    setStopAt(1, PhaseStep.END_TURN);\r\n    execute();\r\n    assertPermanentCount(playerA, \"Elite Vanguard\", 0);\r\n    assertPermanentCount(playerA, \"Phantasmal Bear\", 1);\r\n    assertPowerToughness(playerA, \"Trusted Forcemage\", 3, 3);\r\n    assertPowerToughness(playerA, \"Phantasmal Bear\", 3, 3);\r\n}"
}, {
	"Path": "org.mage.test.cards.requirement.BlockRequirementTest.testJoragaInvocationTest",
	"Comment": "joraga invocation is bugged big time. he cast it with 2 creatures out. ionly had one untapped creature. blocked one of his, hit done, errormessage popped up saying the other one needed to be blocked in aninfinite loop. had to shut down the program via task manager.",
	"Method": "void testJoragaInvocationTest(){\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Forest\", 6);\r\n    addCard(Zone.HAND, playerB, \"Joraga Invocation\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Pillarfield Ox\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Bog Wraith\");\r\n    castSpell(2, PhaseStep.PRECOMBAT_MAIN, playerB, \"Joraga Invocation\");\r\n    attack(2, playerB, \"Silvercoat Lion\");\r\n    attack(2, playerB, \"Pillarfield Ox\");\r\n    block(2, playerA, \"Bog Wraith\", \"Pillarfield Ox\");\r\n    setStopAt(2, PhaseStep.POSTCOMBAT_MAIN);\r\n    execute();\r\n    assertLife(playerA, 15);\r\n    assertGraveyardCount(playerB, \"Joraga Invocation\", 1);\r\n    assertPowerToughness(playerB, \"Silvercoat Lion\", 5, 5);\r\n    assertPowerToughness(playerB, \"Pillarfield Ox\", 5, 7);\r\n    assertGraveyardCount(playerA, \"Bog Wraith\", 1);\r\n}"
}, {
	"Path": "org.mage.test.cards.rules.DontUntapTest.testTritonTactics",
	"Comment": "test that the attackers blocked by creatures boosted withtriton tactics do not untap in their controllers next untap step",
	"Method": "void testTritonTactics(){\r\n    addCard(Zone.HAND, playerA, \"Triton Tactics\");\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Island\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerA, \"Soulmender\", 1);\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Silvercoat Lion\", 1);\r\n    activateAbility(4, PhaseStep.POSTCOMBAT_MAIN, playerA, \"{T}: You gain 1 life\");\r\n    attack(4, playerB, \"Silvercoat Lion\");\r\n    castSpell(4, PhaseStep.DECLARE_ATTACKERS, playerA, \"Triton Tactics\", \"Soulmender\");\r\n    block(4, playerA, \"Soulmender\", \"Silvercoat Lion\");\r\n    setStopAt(6, PhaseStep.DRAW);\r\n    execute();\r\n    assertGraveyardCount(playerA, \"Triton Tactics\", 1);\r\n    assertPowerToughness(playerA, \"Soulmender\", 1, 1);\r\n    assertPowerToughness(playerB, \"Silvercoat Lion\", 2, 2);\r\n    assertTapped(\"Silvercoat Lion\", true);\r\n    assertLife(playerA, 21);\r\n    assertLife(playerB, 20);\r\n}"
}, {
	"Path": "org.mage.test.cards.single.avr.CavernOfSoulsTest.testConditionlManaWorksIfCavernIsReplayed",
	"Comment": "tests conditional mana from cavern in pool will still work if cavern gotback to hand and is played again with other creature type",
	"Method": "void testConditionlManaWorksIfCavernIsReplayed(){\r\n    addCard(Zone.HAND, playerA, \"Cavern of Souls\");\r\n    addCard(Zone.HAND, playerA, \"Gladecover Scout\");\r\n    addCard(Zone.HAND, playerB, \"Boomerang\");\r\n    addCard(Zone.BATTLEFIELD, playerB, \"Island\", 2);\r\n    playLand(1, PhaseStep.PRECOMBAT_MAIN, playerA, \"Cavern of Souls\");\r\n    setChoice(playerA, \"Elf\");\r\n    activateManaAbility(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"{T}: Add 1 mana of any one color. Spend this mana only to cast a creature spell of the chosen type, and that spell can't be countered.\");\r\n    setChoice(playerA, \"Green\");\r\n    castSpell(3, PhaseStep.PRECOMBAT_MAIN, playerB, \"Boomerang\", \"Cavern of Souls\");\r\n    playLand(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"Cavern of Souls\");\r\n    setChoice(playerA, \"Horror\");\r\n    castSpell(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"Gladecover Scout\");\r\n    activateManaAbility(3, PhaseStep.PRECOMBAT_MAIN, playerA, \"{T}: Add 1 mana of any one color. Spend this mana only to cast a creature spell of the chosen type, and that spell can't be countered.\");\r\n    setChoice(playerA, \"Black\");\r\n    setStopAt(3, PhaseStep.BEGIN_COMBAT);\r\n    execute();\r\n    assertGraveyardCount(playerB, \"Boomerang\", 1);\r\n    assertPermanentCount(playerA, \"Cavern of Souls\", 1);\r\n    assertPermanentCount(playerA, \"Gladecover Scout\", 1);\r\n}"
}]