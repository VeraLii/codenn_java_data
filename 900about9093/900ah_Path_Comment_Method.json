[{
	"Path": "net.engio.mbassy.subscription.Subscription.contains",
	"Comment": "check whether this subscriptions manages the given listener instance.",
	"Method": "boolean contains(Object listener){\r\n    return listeners.contains(listener);\r\n}"
}, {
	"Path": "com.oath.micro.server.couchbase.base.CouchbaseManifestComparator.withKey",
	"Comment": "create a new manifestcomparator with the same distributed map connectionthat targets a different key",
	"Method": "CouchbaseManifestComparator<R> withKey(String key){\r\n    return new CouchbaseManifestComparator(key, connection);\r\n}"
}, {
	"Path": "com.oath.micro.server.events.LabelledEvents.finish",
	"Comment": "marks the end of a query identified by the provided correlationid",
	"Method": "void finish(T query,long correlationId,EventBus bus,String labels,RemoveLabelledQuery<T> finish,T query,long correlationId,String label){\r\n    return new RemoveLabelledQuery(RequestData.builder().query(query).correlationId(correlationId).type(label).build());\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.U.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "U appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "net.engio.mbassy.subscription.SubscriptionContext.getHandler",
	"Comment": "get the meta data that specifies the characteristics of the message handlerthat is associated with this context",
	"Method": "MessageHandler getHandler(){\r\n    return handler;\r\n}"
}, {
	"Path": "mondrian.olap.IdBatchResolver.resolveInParentGroupings",
	"Comment": "loops through the sortedset of ids, attempting to load sets of children of parent ids. the loop below assumes the the sortedset is ordered by segment size from smallest to largest, such that parent identifiers will occur before their children.",
	"Method": "Map<QueryPart, QueryPart> resolveInParentGroupings(SortedSet<Id> identifiers){\r\n    final Map<QueryPart, QueryPart> resolvedIdentifiers = new HashMap<QueryPart, QueryPart>();\r\n    while (identifiers.size() > 0) {\r\n        Id parent = identifiers.first();\r\n        identifiers.remove(parent);\r\n        if (!supportedIdentifier(parent)) {\r\n            continue;\r\n        }\r\n        Exp exp = (Exp) resolvedIdentifiers.get(parent);\r\n        if (exp == null) {\r\n            exp = lookupExp(parent);\r\n        }\r\n        Member parentMember = getMemberFromExp(exp);\r\n        if (!supportedMember(parentMember)) {\r\n            continue;\r\n        }\r\n        resolvedIdentifiers.put(parent, (QueryPart) exp);\r\n        batchResolveChildren(parent, parentMember, identifiers, resolvedIdentifiers);\r\n    }\r\n    return resolvedIdentifiers;\r\n}"
}, {
	"Path": "mondrian.spi.impl.JdbcDialectImpl.generateInlineGeneric",
	"Comment": "generic algorithm to generate inline values list,using an optional from clause, specified by the caller of thismethod, appropriate to the dialect of sql.",
	"Method": "String generateInlineGeneric(List<String> columnNames,List<String> columnTypes,List<String[]> valueList,String fromClause,boolean cast){\r\n    final StringBuilder buf = new StringBuilder();\r\n    int columnCount = columnNames.size();\r\n    assert columnTypes.size() == columnCount;\r\n    Integer[] maxLengths = new Integer[columnCount];\r\n    if (cast) {\r\n        for (int i = 0; i < columnTypes.size(); i++) {\r\n            String columnType = columnTypes.get(i);\r\n            Datatype datatype = Datatype.valueOf(columnType);\r\n            if (datatype == Datatype.String) {\r\n                int maxLen = -1;\r\n                for (String[] strings : valueList) {\r\n                    if (strings[i] != null && strings[i].length() > maxLen) {\r\n                        maxLen = strings[i].length();\r\n                    }\r\n                }\r\n                maxLengths[i] = maxLen;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < valueList.size(); i++) {\r\n        if (i > 0) {\r\n            buf.append(\" union all \");\r\n        }\r\n        String[] values = valueList.get(i);\r\n        buf.append(\"select \");\r\n        for (int j = 0; j < values.length; j++) {\r\n            String value = values[j];\r\n            if (j > 0) {\r\n                buf.append(\", \");\r\n            }\r\n            final String columnType = columnTypes.get(j);\r\n            final String columnName = columnNames.get(j);\r\n            Datatype datatype = Datatype.valueOf(columnType);\r\n            final Integer maxLength = maxLengths[j];\r\n            if (maxLength != null) {\r\n                buf.append(\"CAST(\");\r\n                quote(buf, value, datatype);\r\n                buf.append(\" AS VARCHAR(\").append(maxLength).append(\"))\");\r\n            } else {\r\n                quote(buf, value, datatype);\r\n            }\r\n            if (allowsAs()) {\r\n                buf.append(\" as \");\r\n            } else {\r\n                buf.append(' ');\r\n            }\r\n            quoteIdentifier(columnName, buf);\r\n        }\r\n        if (fromClause != null) {\r\n            buf.append(fromClause);\r\n        }\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.isSchemaValid",
	"Comment": "validates that the schema can be parsed and loaded,showing a warning message if any errors are encountered.",
	"Method": "boolean isSchemaValid(MondrianGuiDef.Schema schema){\r\n    try {\r\n        StringWriter writer = new StringWriter();\r\n        XMLOutput xmlOutput = new XMLOutput(writer);\r\n        schema.displayXML(xmlOutput);\r\n        Parser xmlParser = XOMUtil.createDefaultParser();\r\n        Reader reader = new StringReader(writer.getBuffer().toString());\r\n        new MondrianGuiDef.Schema(xmlParser.parse(reader));\r\n    } catch (XOMException e) {\r\n        JOptionPane.showMessageDialog(this, getResourceConverter().getFormattedString(\"workbench.save.invalid.schema\", \"Please correct the following error before saving:\", e.getLocalizedMessage()), getResourceConverter().getFormattedString(\"workbench.save.invalid.schema.title\", \"Cannot Save\"), JOptionPane.WARNING_MESSAGE);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "mondrian.spi.SegmentHeader.getConstrainedColumns",
	"Comment": "returns a list of constrained columns which define this segmentheader. the caller should consider this list immutable.",
	"Method": "List<SegmentColumn> getConstrainedColumns(){\r\n    return constrainedColumns;\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.ui.imagezoom.ImageViewTouchBase.getProperBaseMatrix",
	"Comment": "setup the base matrix so that the image is centered and scaled properly.",
	"Method": "void getProperBaseMatrix(RotateBitmap bitmap,Matrix matrix){\r\n    float viewWidth = getWidth();\r\n    float viewHeight = getHeight();\r\n    float w = bitmap.getWidth();\r\n    float h = bitmap.getHeight();\r\n    matrix.reset();\r\n    float widthScale = Math.min(viewWidth / w, MAX_ZOOM);\r\n    float heightScale = Math.min(viewHeight / h, MAX_ZOOM);\r\n    float scale = Math.min(widthScale, heightScale);\r\n    matrix.postConcat(bitmap.getRotateMatrix());\r\n    matrix.postScale(scale, scale);\r\n    matrix.postTranslate((viewWidth - w * scale) / MAX_ZOOM, (viewHeight - h * scale) / MAX_ZOOM);\r\n}"
}, {
	"Path": "mondrian.rolap.RolapUtil.makeRolapStarKey",
	"Comment": "generates rolap star key based on the factusing fact alias and sql filter dataif this one is present in the fact",
	"Method": "List<String> makeRolapStarKey(MondrianDef.Relation fact,List<String> makeRolapStarKey,String factTableName){\r\n    return Collections.unmodifiableList(Arrays.asList(factTableName));\r\n}"
}, {
	"Path": "com.oath.micro.server.s3.data.S3Reader.getAsString",
	"Comment": "read data from defined s3 bucket with provided key to a string",
	"Method": "Try<String, Throwable> getAsString(String key){\r\n    return Try.withCatch(() -> ReactiveSeq.fromStream(new BufferedReader(new InputStreamReader(readUtils.getInputStream(bucket, key))).lines()).join(\"\\n\"));\r\n}"
}, {
	"Path": "mondrian.olap.Query.removeFormula",
	"Comment": "remove a formula from the query. if failifusedinquery istrue, checks and throws an error if formula is used somewhere in thequery.",
	"Method": "void removeFormula(String uniqueName,boolean failIfUsedInQuery){\r\n    Formula formula = findFormula(uniqueName);\r\n    if (failIfUsedInQuery && formula != null) {\r\n        OlapElement mdxElement = formula.getElement();\r\n        Walker walker = new Walker(this);\r\n        while (walker.hasMoreElements()) {\r\n            Object queryElement = walker.nextElement();\r\n            if (!queryElement.equals(mdxElement)) {\r\n                continue;\r\n            }\r\n            String formulaType = formula.isMember() ? MondrianResource.instance().CalculatedMember.str() : MondrianResource.instance().CalculatedSet.str();\r\n            int i = 0;\r\n            Object parent = walker.getAncestor(i);\r\n            Object grandParent = walker.getAncestor(i + 1);\r\n            while ((parent != null) && (grandParent != null)) {\r\n                if (grandParent instanceof Query) {\r\n                    if (parent instanceof Axis) {\r\n                        throw MondrianResource.instance().MdxCalculatedFormulaUsedOnAxis.ex(formulaType, uniqueName, ((QueryAxis) parent).getAxisName());\r\n                    } else if (parent instanceof Formula) {\r\n                        String parentFormulaType = ((Formula) parent).isMember() ? MondrianResource.instance().CalculatedMember.str() : MondrianResource.instance().CalculatedSet.str();\r\n                        throw MondrianResource.instance().MdxCalculatedFormulaUsedInFormula.ex(formulaType, uniqueName, parentFormulaType, ((Formula) parent).getUniqueName());\r\n                    } else {\r\n                        throw MondrianResource.instance().MdxCalculatedFormulaUsedOnSlicer.ex(formulaType, uniqueName);\r\n                    }\r\n                }\r\n                ++i;\r\n                parent = walker.getAncestor(i);\r\n                grandParent = walker.getAncestor(i + 1);\r\n            }\r\n            throw MondrianResource.instance().MdxCalculatedFormulaUsedInQuery.ex(formulaType, uniqueName, Util.unparse(this));\r\n        }\r\n    }\r\n    List<Formula> formulaList = new ArrayList<Formula>();\r\n    for (Formula formula1 : formulas) {\r\n        if (!formula1.getUniqueName().equalsIgnoreCase(uniqueName)) {\r\n            formulaList.add(formula1);\r\n        }\r\n    }\r\n    this.formulas = formulaList.toArray(new Formula[formulaList.size()]);\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AggregationOnDistinctCountMeasuresTest.testMondrian906",
	"Comment": "this test makes sure that the aggregatefundef will not optimize a tupleslist when the rollup policy is set to something else than full, as itresults in wrong data for a distinct count operation when using roles tonarrow down the members access.",
	"Method": "void testMondrian906(){\r\n    final TestContext context = TestContext.instance().create(null, null, null, null, null, \"<Role name=\\\"Role1\\\">\\n\" + \"  <SchemaGrant access=\\\"all\\\">\\n\" + \"    <CubeGrant cube=\\\"Sales\\\" access=\\\"all\\\">\\n\" + \"      <HierarchyGrant hierarchy=\\\"[Customers]\\\" access=\\\"custom\\\" rollupPolicy=\\\"partial\\\">\\n\" + \"        <MemberGrant member=\\\"[Customers].[USA].[OR]\\\" access=\\\"all\\\"/>\\n\" + \"        <MemberGrant member=\\\"[Customers].[USA].[WA]\\\" access=\\\"all\\\"/>\\n\" + \"      <\/HierarchyGrant>\\n\" + \"    <\/CubeGrant>\\n\" + \"  <\/SchemaGrant>\\n\" + \"<\/Role>\\n\");\r\n    final String mdx = \"select {[Customers].[USA], [Customers].[USA].[OR], [Customers].[USA].[WA]} on columns, {[Measures].[Customer Count]} on rows from [Sales]\";\r\n    context.withRole(\"Role1\").assertQueryReturns(mdx, \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Customers].[USA]}\\n\" + \"{[Customers].[USA].[OR]}\\n\" + \"{[Customers].[USA].[WA]}\\n\" + \"Axis #2:\\n\" + \"{[Measures].[Customer Count]}\\n\" + \"Row #0: 2,865\\n\" + \"Row #0: 1,037\\n\" + \"Row #0: 1,828\\n\");\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Tr.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Tr appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.test.BasicQueryTest._testLookupCube",
	"Comment": "basically, the lookupcube function can evaluate a single mdx statementagainst a cube other than the cube currently indicated by query contextto retrieve a single string or numeric result.for example, the budget cube in the foodmart 2000 database containsbudget information that can be displayed by store. the sales cube in thefoodmart 2000 database contains sales information that can be displayedby store. since no virtual cube exists in the foodmart 2000 database thatjoins the sales and budget cubes together, comparing the two sets offigures would be difficult at best.note in many situations a virtual cube can be used to integratedata from multiple cubes, which will often provide a simpler and moreefficient solution than the lookupcube function. this example uses thelookupcube function for purposes of illustration.the following mdx query, however, uses the lookupcube function toretrieve unit sales information for each store from the sales cube,presenting it side by side with the budget information from the budgetcube.",
	"Method": "void _testLookupCube(){\r\n    assertQueryReturns(\"WITH MEMBER Measures.[Store Unit Sales] AS \\n\" + \" 'LookupCube(\\\"Sales\\\", \\\"(\\\" + MemberToStr(Store.CurrentMember) + \\\", Measures.[Unit Sales])\\\")'\\n\" + \"SELECT\\n\" + \" {Measures.Amount, Measures.[Store Unit Sales]} ON COLUMNS,\\n\" + \" Store.CA.CHILDREN ON ROWS\\n\" + \"FROM Budget\", \"\");\r\n}"
}, {
	"Path": "mondrian.test.ParameterTest.testDerivedParameter",
	"Comment": "tests a parameter derived from another parameter. ok as long as it isnot cyclic.",
	"Method": "void testDerivedParameter(){\r\n    assertExprReturns(\"Parameter(\\\"X\\\", NUMERIC, Parameter(\\\"Y\\\", NUMERIC, 1) + 2)\", \"3\");\r\n}"
}, {
	"Path": "mondrian.test.PropertiesTest.testPropertiesMDX",
	"Comment": "tests the ability of mdx parser to pass requested member propertiesto result object.",
	"Method": "void testPropertiesMDX(){\r\n    Result result = executeQuery(\"SELECT {[Customers].[All Customers].[USA].[CA]} DIMENSION PROPERTIES \\n\" + \" CATALOG_NAME, SCHEMA_NAME, CUBE_NAME, DIMENSION_UNIQUE_NAME, \\n\" + \" HIERARCHY_UNIQUE_NAME, LEVEL_UNIQUE_NAME, LEVEL_NUMBER, MEMBER_UNIQUE_NAME, \\n\" + \" MEMBER_NAME, MEMBER_TYPE, MEMBER_GUID, MEMBER_CAPTION, MEMBER_ORDINAL, CHILDREN_CARDINALITY,\\n\" + \" PARENT_LEVEL, PARENT_UNIQUE_NAME, PARENT_COUNT, DESCRIPTION ON COLUMNS\\n\" + \"FROM [Sales]\");\r\n    QueryAxis[] axes = result.getQuery().getAxes();\r\n    Id[] axesProperties = axes[0].getDimensionProperties();\r\n    String[] props = { \"CATALOG_NAME\", \"SCHEMA_NAME\", \"CUBE_NAME\", \"DIMENSION_UNIQUE_NAME\", \"HIERARCHY_UNIQUE_NAME\", \"LEVEL_UNIQUE_NAME\", \"LEVEL_NUMBER\", \"MEMBER_UNIQUE_NAME\", \"MEMBER_NAME\", \"MEMBER_TYPE\", \"MEMBER_GUID\", \"MEMBER_CAPTION\", \"MEMBER_ORDINAL\", \"CHILDREN_CARDINALITY\", \"PARENT_LEVEL\", \"PARENT_UNIQUE_NAME\", \"PARENT_COUNT\", \"DESCRIPTION\" };\r\n    assertEquals(axesProperties.length, props.length);\r\n    int i = 0;\r\n    for (String prop : props) {\r\n        assertEquals(prop, axesProperties[i++].toString());\r\n    }\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.setMinConn",
	"Comment": "sets the minimum number of spare connections to maintain in our available pool.",
	"Method": "void setMinConn(int minConn){\r\n    this.minConn = minConn;\r\n}"
}, {
	"Path": "org.springframework.extensions.jcr.support.JcrDaoSupport.setTemplate",
	"Comment": "set the jcrtemplate for this dao explicitly, as an alternative to\tspecifying a sessionfactory.",
	"Method": "void setTemplate(JcrTemplate jcrTemplate){\r\n    this.template = jcrTemplate;\r\n}"
}, {
	"Path": "mondrian.olap.UnionRoleImpl.max",
	"Comment": "returns the larger of two enum values. useful if the enums are sortedso that more permissive values come after less permissive values.",
	"Method": "T max(T t1,T t2){\r\n    if (t1.ordinal() > t2.ordinal()) {\r\n        return t1;\r\n    } else {\r\n        return t2;\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.NativeSetEvaluationTest.testLoopDetection",
	"Comment": "test evaluation loop detection still works after changes tomake it more permissable.",
	"Method": "void testLoopDetection(){\r\n    propSaver.set(propSaver.properties.LevelPreCacheThreshold, 0);\r\n    if (!MondrianProperties.instance().EnableNativeTopCount.get()) {\r\n        return;\r\n    }\r\n    final String mdx = \"WITH\\n\" + \"  SET CJ AS NonEmptyCrossJoin([Store Type].[Store Type].Members, {[Measures].[Unit Sales]})\\n\" + \"  SET TC AS 'TopCount([Store Type].[Store Type].Members, 10, [Measures].[Unit Sales])'\\n\" + \"  SET TIME_DEP AS 'Generate(CJ, {[Time].[Time].CurrentMember})' \\n\" + \"  MEMBER [Time].[Time].[Slicer] as Aggregate(TIME_DEP)\\n\" + \"\\n\" + \"  SELECT NON EMPTY [Measures].[Unit Sales] on 0,\\n\" + \"    TC ON 1 \\n\" + \"  FROM [Sales] where [Time].[Slicer]\\n\";\r\n    assertQueryThrows(mdx, \"evaluating itself\");\r\n}"
}, {
	"Path": "mondrian.test.UdfTest.testUdfScriptBadLanguage",
	"Comment": "unit test that ensures that a udf has either a script or a classname.",
	"Method": "void testUdfScriptBadLanguage(){\r\n    TestContext tc = udfTestContext(\"<UserDefinedFunction name='StringMult'>\\n\" + \" <Script language='bad'>bar<\/Script>\\n\" + \"<\/UserDefinedFunction>\");\r\n    tc.assertQueryThrows(\"select from [Sales]\", \"Invalid script language 'bad'\");\r\n}"
}, {
	"Path": "mondrian.rolap.SqlConstraintUtils.constrainLevel2",
	"Comment": "generates a sql expression constraining a level by some value",
	"Method": "String constrainLevel2(SqlQuery query,MondrianDef.Expression exp,Dialect.Datatype datatype,Comparable columnValue){\r\n    String columnString = exp.getExpression(query);\r\n    if (columnValue == RolapUtil.sqlNullValue) {\r\n        return columnString + \" is \" + RolapUtil.sqlNullLiteral;\r\n    } else {\r\n        final StringBuilder buf = new StringBuilder();\r\n        buf.append(columnString);\r\n        buf.append(\" = \");\r\n        query.getDialect().quote(buf, columnValue, datatype);\r\n        return buf.toString();\r\n    }\r\n}"
}, {
	"Path": "com.meetup.memcached.MemcachedClient.statsCacheDump",
	"Comment": "retrieves items cachedump for all servers.\treturns a map keyed on the servername.\tthe value is another map which contains cachedump stats\twith the cachekey as key and byte size and unix timestamp as value.",
	"Method": "Map statsCacheDump(int slabNumber,int limit,Map statsCacheDump,String[] servers,int slabNumber,int limit){\r\n    return stats(servers, String.format(\"stats cachedump %d %d\\r\\n\", slabNumber, limit), ITEM);\r\n}"
}, {
	"Path": "mondrian.test.loader.DBLoader.close",
	"Comment": "releases resources.call this method when the load process is finished and the connectionis no longer going to be used.",
	"Method": "void close(){\r\n    if (connection != null) {\r\n        Util.close(null, null, connection);\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.SqlTupleReader.savePartialResult",
	"Comment": "retrieves the current members fetched from the targets executedthrough sql and form tuples, adding them to partialresult",
	"Method": "void savePartialResult(List<List<RolapMember>> partialResult){\r\n    List<RolapMember> row = new ArrayList<RolapMember>();\r\n    for (TargetBase target : targets) {\r\n        if (target.srcMembers == null) {\r\n            row.add(target.getCurrMember());\r\n        }\r\n    }\r\n    partialResult.add(row);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Pre.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Pre appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.ResultLoader.savePartialResult",
	"Comment": "retrieves the current members fetched from the targets executedthrough sql and form tuples, adding them to partialresult",
	"Method": "void savePartialResult(List<List<RolapMember>> partialResult){\r\n    List<RolapMember> row = new ArrayList<RolapMember>();\r\n    for (TargetBase target : targets) {\r\n        if (target.getSrcMembers() == null) {\r\n            row.add(target.getCurrMember());\r\n        }\r\n    }\r\n    partialResult.add(row);\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentBuilder.createDataset",
	"Comment": "creates a segmentdataset that contains the cacheddata and is initialized to be used with the supplied segment.",
	"Method": "SegmentDataset createDataset(SegmentBody body,SegmentAxis[] axes){\r\n    final SegmentDataset dataSet;\r\n    if (body instanceof DenseDoubleSegmentBody) {\r\n        dataSet = new DenseDoubleSegmentDataset(axes, (double[]) body.getValueArray(), body.getNullValueIndicators());\r\n    } else if (body instanceof DenseIntSegmentBody) {\r\n        dataSet = new DenseIntSegmentDataset(axes, (int[]) body.getValueArray(), body.getNullValueIndicators());\r\n    } else if (body instanceof DenseObjectSegmentBody) {\r\n        dataSet = new DenseObjectSegmentDataset(axes, (Object[]) body.getValueArray());\r\n    } else if (body instanceof SparseSegmentBody) {\r\n        dataSet = new SparseSegmentDataset(body.getValueMap());\r\n    } else {\r\n        throw Util.newInternal(\"Unknown segment body type: \" + body.getClass() + \": \" + body);\r\n    }\r\n    return dataSet;\r\n}"
}, {
	"Path": "mondrian.gui.JdbcTreeModel.addTreeModelListener",
	"Comment": "adds a listener for the treemodeleventposted after the tree changes.",
	"Method": "void addTreeModelListener(TreeModelListener l){\r\n    treeModelListeners.add(l);\r\n}"
}, {
	"Path": "mondrian.rolap.SqlMemberSourceTest.getAllLevelMock",
	"Comment": "below there are mocked levels in store hierarchy of store dimension according to the default test foodmart schema",
	"Method": "RolapLevel getAllLevelMock(){\r\n    RolapLevel rlLevelMock = mock(RolapLevel.class);\r\n    return rlLevelMock;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDebug.dump",
	"Comment": "dumps detailed information about all databases used by the process.",
	"Method": "void dump(Printer printer,String[] args){\r\n    boolean verbose = false;\r\n    for (String arg : args) {\r\n        if (arg.equals(\"-v\")) {\r\n            verbose = true;\r\n        }\r\n    }\r\n    SQLiteDatabase.dumpAll(printer, verbose);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.updateMDXCatalogList",
	"Comment": "inform all opened mdx query windows about the list of opened schema files",
	"Method": "void updateMDXCatalogList(){\r\n    Iterator<JInternalFrame> it = mdxWindows.iterator();\r\n    while (it.hasNext()) {\r\n        JInternalFrame elem = it.next();\r\n        QueryPanel qp = (QueryPanel) elem.getContentPane().getComponent(0);\r\n        qp.setSchemaWindowMap(schemaWindowMap);\r\n    }\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.widget.LinearListView.setDividerThickness",
	"Comment": "set the divider thickness size in pixel. that means setting the dividerheight if the layout has an horizontal orientation and setting thedivider width otherwise.",
	"Method": "void setDividerThickness(int thickness){\r\n    if (getOrientation() == VERTICAL) {\r\n        mDividerHeight = thickness;\r\n    } else {\r\n        mDividerWidth = thickness;\r\n    }\r\n    requestLayout();\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.H4.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "H4 appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentBuilderTest.makeSegmentMap",
	"Comment": "creates a rough segment map for testing purposes, containingthe array of column names passed in, with numvalspercol dummyvalues placed per column.populates the cells in the body withnumpopulatedcells dummy values placed in the first n places of thevalues array.",
	"Method": "Map<SegmentHeader, SegmentBody> makeSegmentMap(String[] colNames,String[][] colVals,int numValsPerCol,int numPopulatedCells,boolean wildcardCols,boolean[] nullAxisFlags){\r\n    if (colVals == null) {\r\n        colVals = dummyColumnValues(colNames.length, numValsPerCol);\r\n    }\r\n    Pair<SegmentHeader, SegmentBody> headerBody = makeDummyHeaderBodyPair(colNames, colVals, numPopulatedCells, wildcardCols, nullAxisFlags);\r\n    Map<SegmentHeader, SegmentBody> map = new HashMap<SegmentHeader, SegmentBody>();\r\n    map.put(headerBody.left, headerBody.right);\r\n    return map;\r\n}"
}, {
	"Path": "mondrian.test.loader.MondrianFoodMartLoader.afterTable",
	"Comment": "called after the last row of a table has been read into the batch.",
	"Method": "void afterTable(String table,int tableRowCount){\r\n    if (table == null) {\r\n        return;\r\n    }\r\n    if (!infobrightLoad) {\r\n        LOGGER.info(\"Table \" + table + \": loaded \" + tableRowCount + \" rows.\");\r\n        return;\r\n    }\r\n    fileOutput.close();\r\n    LOGGER.info(\"Infobright bulk load: Table \" + table + \": loaded \" + tableRowCount + \" rows.\");\r\n    final String sql = \"LOAD DATA INFILE '\" + file.getAbsolutePath().replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\") + \"' INTO TABLE \" + (schema != null ? schema + \".\" : \"\") + table + \" FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '\\\"'\" + \" ESCAPED BY '\\\\\\\\'\";\r\n    Statement statement = null;\r\n    try {\r\n        statement = connection.createStatement();\r\n        statement.executeUpdate(sql);\r\n    } catch (SQLException e) {\r\n        throw new RuntimeException(\"Error while executing statement: \" + sql, e);\r\n    } finally {\r\n        if (statement != null) {\r\n            try {\r\n                statement.close();\r\n            } catch (SQLException e) {\r\n            }\r\n        }\r\n    }\r\n    fileOutput = new FileWriter(file);\r\n}"
}, {
	"Path": "org.jfaster.mango.parser.JJTParserState.rootNode",
	"Comment": "returns the root node of the ast.it only makes sense to call this after a successful parse.",
	"Method": "Node rootNode(){\r\n    return nodes.get(0);\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.clearHostFromPool",
	"Comment": "closes and removes all sockets from specified pool for host. \tthis method is not threadsafe, so be careful when using!\tinternal utility method.",
	"Method": "void clearHostFromPool(Map<String, Map<SockIO, Long>> pool,String host){\r\n    if (pool.containsKey(host)) {\r\n        Map<SockIO, Long> sockets = pool.get(host);\r\n        if (sockets != null && sockets.size() > 0) {\r\n            for (Iterator<SockIO> i = sockets.keySet().iterator(); i.hasNext(); ) {\r\n                SockIO socket = i.next();\r\n                try {\r\n                    socket.trueClose();\r\n                } catch (IOException ioe) {\r\n                    log.error(\"++++ failed to close socket: \" + ioe.getMessage());\r\n                }\r\n                i.remove();\r\n                socket = null;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.core.util.MercatorProjection.tileXToLongitudeWithScaleFactor",
	"Comment": "converts a tile x number at a certain scale to a longitude coordinate.",
	"Method": "double tileXToLongitudeWithScaleFactor(long tileX,double scaleFactor){\r\n    return pixelXToLongitudeWithScaleFactor(tileX * DUMMY_TILE_SIZE, scaleFactor, DUMMY_TILE_SIZE);\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.adapter.FragmentPagerAdapter.getItemId",
	"Comment": "return a unique identifier for the item at the given position.the default implementation returns the given position. subclasses shouldoverride this method if the positions of items can change.",
	"Method": "long getItemId(int position){\r\n    return position;\r\n}"
}, {
	"Path": "mondrian.rolap.FastBatchingCellReaderTest.testSuperSetAndNotAllValues",
	"Comment": "tests that can batch for batch with super set of constraintcolumn bit key and not all values for additional condition.",
	"Method": "void testSuperSetAndNotAllValues(){\r\n    final BatchLoader fbcr = createFbcr(null, salesCube);\r\n    BatchLoader.Batch aggregationBatch = createBatch(fbcr, new String[] { tableTime, tableProductClass, tableProductClass }, new String[] { fieldYear, fieldProductFamily, fieldProductDepartment }, new String[][] { fieldValuesYear, fieldValuesProductFamily, fieldValueProductDepartment }, cubeNameSales, measureUnitSales);\r\n    BatchLoader.Batch detailedBatch = createBatch(fbcr, new String[] { tableTime, tableProductClass, tableProductClass, tableCustomer }, new String[] { fieldYear, fieldProductFamily, fieldProductDepartment, fieldGender }, new String[][] { fieldValuesYear, fieldValuesProductFamily, fieldValueProductDepartment, new String[] { \"M\" } }, cubeNameSales, measureUnitSales);\r\n    assertFalse(detailedBatch.canBatch(aggregationBatch));\r\n    assertFalse(aggregationBatch.canBatch(detailedBatch));\r\n}"
}, {
	"Path": "mondrian.gui.validate.ValidationUtils.validateColumn",
	"Comment": "validates a column, and returns an error message if it is invalid.",
	"Method": "String validateColumn(String column,String fieldName,Messages messages,MondrianGuiDef.Level level,JdbcValidator jdbcValidator,MondrianGuiDef.Cube cube,MondrianGuiDef.Hierarchy parentHierarchy){\r\n    if (!isEmpty(column)) {\r\n        if (jdbcValidator.isInitialized()) {\r\n            String table = level.table;\r\n            if (!isEmpty(table) && parentHierarchy != null && parentHierarchy.relation instanceof MondrianGuiDef.Join) {\r\n                TreeSet<String> joinTables = new TreeSet<String>();\r\n                SchemaExplorer.getTableNamesForJoin(parentHierarchy.relation, joinTables);\r\n                if (!joinTables.contains(table)) {\r\n                    return messages.getString(\"schemaTreeCellRenderer.wrongTableValue\", \"Table value does not correspond to any join\");\r\n                }\r\n            }\r\n            if (!isEmpty(table) && parentHierarchy != null && parentHierarchy.relation instanceof MondrianGuiDef.Table) {\r\n                final MondrianGuiDef.Table parentTable = (MondrianGuiDef.Table) parentHierarchy.relation;\r\n                MondrianGuiDef.Table theTable = parentTable;\r\n                String compareTo = (theTable.alias != null && theTable.alias.trim().length() > 0) ? theTable.alias : theTable.name;\r\n                if (!table.equals(compareTo)) {\r\n                    return messages.getString(\"schemaTreeCellRenderer.tableDoesNotMatch\", \"Table value does not correspond to Hierarchy Relation\");\r\n                }\r\n            }\r\n            if (!isEmpty(table) && parentHierarchy != null && parentHierarchy.relation instanceof MondrianGuiDef.View) {\r\n                return messages.getString(\"schemaTreeCellRenderer.noTableForView\", \"Table for column cannot be set in View\");\r\n            }\r\n            if (isEmpty(table)) {\r\n                if (parentHierarchy != null) {\r\n                    if (parentHierarchy.relation == null && cube != null) {\r\n                        if (!jdbcValidator.isColExists(((MondrianGuiDef.Table) cube.fact).schema, ((MondrianGuiDef.Table) cube.fact).name, column)) {\r\n                            return messages.getFormattedString(\"schemaTreeCellRenderer.degenDimensionColumnDoesNotExist.alert\", \"Degenerate dimension validation check - Column {0} does not exist in fact table\", column);\r\n                        }\r\n                    } else if (parentHierarchy.relation instanceof MondrianGuiDef.Table) {\r\n                        final MondrianGuiDef.Table parentTable = (MondrianGuiDef.Table) parentHierarchy.relation;\r\n                        if (!jdbcValidator.isColExists(parentTable.schema, parentTable.name, column)) {\r\n                            return messages.getFormattedString(\"schemaTreeCellRenderer.columnInTableDoesNotExist.alert\", \"Column {0} defined in field {1} does not exist in table {2}\", isEmpty(column.trim()) ? \"' '\" : column, fieldName, parentTable.name);\r\n                        }\r\n                    } else if (parentHierarchy.relation instanceof MondrianGuiDef.Join) {\r\n                        return messages.getString(\"schemaTreeCellRenderer.tableMustBeSet.alert\", \"Table must be set\");\r\n                    }\r\n                }\r\n            } else {\r\n                String schema = null;\r\n                if (parentHierarchy != null && parentHierarchy.relation instanceof MondrianGuiDef.Join) {\r\n                    String[] schemaAndTable = SchemaExplorer.getTableNameForAlias(parentHierarchy.relation, table);\r\n                    schema = schemaAndTable[0];\r\n                    table = schemaAndTable[1];\r\n                }\r\n                if (!jdbcValidator.isColExists(schema, table, column)) {\r\n                    return messages.getFormattedString(\"schemaTreeCellRenderer.columnInTableDoesNotExist.alert\", \"Column {0} defined in field {1} does not exist in table {2}\", isEmpty(column.trim()) ? \"' '\" : column, fieldName, table);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Tfoot.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Tfoot appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.setAliveCheck",
	"Comment": "sets the alivecheck flag for the pool.\twhen true, this will attempt to talk to the server on\tevery connection checkout to make sure the connection is\tstill valid.this adds extra network chatter and thus is\tdefaulted off.may be useful if you want to ensure you do\tnot have any problems talking to the server on a dead connection.",
	"Method": "void setAliveCheck(boolean aliveCheck){\r\n    this.aliveCheck = aliveCheck;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Form.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Form appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.olap.Query.addMeasuresMembers",
	"Comment": "keeps track of references to members of the measures dimension",
	"Method": "void addMeasuresMembers(OlapElement olapElement){\r\n    if (olapElement instanceof Member) {\r\n        Member member = (Member) olapElement;\r\n        if (member.isMeasure()) {\r\n            measuresMembers.add(member);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.shutDown",
	"Comment": "shuts down the pool.\tcleanly closes all sockets.\tstops the maint thread.\tnulls out all internal maps",
	"Method": "void shutDown(){\r\n    synchronized (this) {\r\n        if (log.isDebugEnabled())\r\n            log.debug(\"++++ SockIOPool shutting down...\");\r\n        if (maintThread != null && maintThread.isRunning()) {\r\n            stopMaintThread();\r\n            while (maintThread.isRunning()) {\r\n                if (log.isDebugEnabled())\r\n                    log.debug(\"++++ waiting for main thread to finish run +++\");\r\n                try {\r\n                    Thread.sleep(500);\r\n                } catch (Exception ex) {\r\n                }\r\n            }\r\n        }\r\n        if (log.isDebugEnabled())\r\n            log.debug(\"++++ closing all internal pools.\");\r\n        closePool(availPool);\r\n        closePool(busyPool);\r\n        availPool = null;\r\n        busyPool = null;\r\n        buckets = null;\r\n        consistentBuckets = null;\r\n        hostDeadDur = null;\r\n        hostDead = null;\r\n        maintThread = null;\r\n        initialized = false;\r\n        if (log.isDebugEnabled())\r\n            log.debug(\"++++ SockIOPool finished shutting down.\");\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.RolapEvaluator.expandsBefore",
	"Comment": "returns whether a given calculation expands before another.a calculation expands before another if its solve order is higher,or if its solve order is the same and its dimension ordinal is lower.",
	"Method": "boolean expandsBefore(RolapCalculation calc1,RolapCalculation calc2){\r\n    final int solveOrder1 = calc1.getSolveOrder();\r\n    final int solveOrder2 = calc2.getSolveOrder();\r\n    if (solveOrder1 > solveOrder2) {\r\n        return true;\r\n    } else {\r\n        return solveOrder1 == solveOrder2 && calc1.getHierarchyOrdinal() < calc2.getHierarchyOrdinal();\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.FoodMartTestCase.assertBooleanExprReturns",
	"Comment": "executes an expression which yields a boolean result, and asserts thatthe result is the expected one.",
	"Method": "void assertBooleanExprReturns(String expression,boolean expected){\r\n    final String iifExpression = \"Iif (\" + expression + \",\\\"true\\\",\\\"false\\\")\";\r\n    final String actual = executeExpr(iifExpression);\r\n    final String expectedString = expected ? \"true\" : \"false\";\r\n    assertEquals(expectedString, actual);\r\n}"
}, {
	"Path": "mondrian.olap.ParserTest.testMemberOnAxis",
	"Comment": "if an axis expression is a member, implicitly convert it to a set.",
	"Method": "void testMemberOnAxis(){\r\n    assertParseQuery(\"select [Measures].[Sales Count] on 0, non empty [Store].[Store State].members on 1 from [Sales]\", \"select [Measures].[Sales Count] ON COLUMNS,\\n\" + \"  NON EMPTY [Store].[Store State].members ON ROWS\\n\" + \"from [Sales]\\n\");\r\n}"
}, {
	"Path": "mondrian.olap.CubeBase.lookupDimension",
	"Comment": "looks up a dimension in this cube based on a component of its name.",
	"Method": "Dimension lookupDimension(Id.Segment s){\r\n    if (!(s instanceof Id.NameSegment)) {\r\n        return null;\r\n    }\r\n    final Id.NameSegment nameSegment = (Id.NameSegment) s;\r\n    for (Dimension dimension : dimensions) {\r\n        if (Util.equalName(dimension.getName(), nameSegment.name)) {\r\n            return dimension;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.test.DiffRepository.update",
	"Comment": "creates a new document with a given resource.this method is synchronized, in case two threads are runningtest cases of this test at the same time.",
	"Method": "void update(String testCaseName,String resourceName,String value){\r\n    Element testCaseElement = getTestCaseElement(root, testCaseName);\r\n    if (testCaseElement == null) {\r\n        testCaseElement = doc.createElement(TestCaseTag);\r\n        testCaseElement.setAttribute(TestCaseNameAttr, testCaseName);\r\n        root.appendChild(testCaseElement);\r\n    }\r\n    Element resourceElement = getResourceElement(testCaseElement, resourceName);\r\n    if (resourceElement == null) {\r\n        resourceElement = doc.createElement(ResourceTag);\r\n        resourceElement.setAttribute(ResourceNameAttr, resourceName);\r\n        testCaseElement.appendChild(resourceElement);\r\n    } else {\r\n        removeAllChildren(resourceElement);\r\n    }\r\n    resourceElement.appendChild(doc.createCDATASection(value));\r\n    flushDoc();\r\n}"
}, {
	"Path": "mondrian.xmla.Rowset.setProperty",
	"Comment": "sets a property for this rowset. called by the constructor for eachsupplied property.a derived class should override this method and intercept eachproperty it supports. any property it does not support, it should forwardto the base class method, which will probably throw an error.",
	"Method": "void setProperty(PropertyDefinition propertyDef,String value){\r\n    switch(propertyDef) {\r\n        case Format:\r\n            break;\r\n        case DataSourceInfo:\r\n            break;\r\n        case Catalog:\r\n            break;\r\n        case LocaleIdentifier:\r\n            Locale locale = XmlaUtil.convertToLocale(value);\r\n            if (locale != null) {\r\n                extraProperties.put(XmlaHandler.JDBC_LOCALE, locale.toString());\r\n            }\r\n            return;\r\n        default:\r\n            LOGGER.warn(\"Warning: Rowset '\" + rowsetDefinition.name() + \"' does not support property '\" + propertyDef.name() + \"' (value is '\" + value + \"')\");\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.StringUtils.toStringArray",
	"Comment": "copy the given enumeration into a string array. the enumeration mustcontain string elements only.",
	"Method": "String[] toStringArray(Collection<String> collection,String[] toStringArray,Enumeration<String> enumeration){\r\n    if (enumeration == null) {\r\n        return null;\r\n    }\r\n    List<String> list = Collections.list(enumeration);\r\n    return list.toArray(new String[list.size()]);\r\n}"
}, {
	"Path": "mondrian.test.BasicQueryTest.testSolveOrderAmbiguous2",
	"Comment": "in the second test, the answer should be 2 because product comes beforepromotions in the foodmart.xml schema.",
	"Method": "void testSolveOrderAmbiguous2(){\r\n    assertQueryReturns(\"WITH\\n\" + \"   MEMBER [Promotions].[Calc] AS '1'\\n\" + \"   MEMBER [Product].[Calc] AS '2'\\n\" + \"SELECT\\n\" + \"   { [Promotions].[Calc] } ON COLUMNS,\\n\" + \"   { [Product].[Calc] } ON ROWS\\n\" + \"FROM Sales\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Promotions].[Calc]}\\n\" + \"Axis #2:\\n\" + \"{[Product].[Calc]}\\n\" + \"Row #0: 2\\n\");\r\n}"
}, {
	"Path": "mondrian.olap.Util.appendArrays",
	"Comment": "concatenates one or more arrays.resulting array has same element type as first array. each arrays maybe empty, but must not be null.",
	"Method": "T[] appendArrays(T[] a0,T[] as){\r\n    int n = a0.length;\r\n    for (T[] a : as) {\r\n        n += a.length;\r\n    }\r\n    T[] copy = Util.copyOf(a0, n);\r\n    n = a0.length;\r\n    for (T[] a : as) {\r\n        System.arraycopy(a, 0, copy, n, a.length);\r\n        n += a.length;\r\n    }\r\n    return copy;\r\n}"
}, {
	"Path": "mondrian.olap.Util.convertStackToString",
	"Comment": "converts an error into an array of strings, the most recent error first.",
	"Method": "String[] convertStackToString(Throwable e){\r\n    List<String> list = new ArrayList<String>();\r\n    while (e != null) {\r\n        String sMsg = getErrorMessage(e);\r\n        list.add(sMsg);\r\n        e = e.getCause();\r\n    }\r\n    return list.toArray(new String[list.size()]);\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunctionTest.testMultiplyBug774807",
	"Comment": "bug 774807 caused expressions to be mistaken for the crossjoinoperator.",
	"Method": "void testMultiplyBug774807(){\r\n    final String desiredResult = \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Store].[All Stores]}\\n\" + \"Axis #2:\\n\" + \"{[Measures].[Store Sales]}\\n\" + \"{[Measures].[A]}\\n\" + \"Row #0: 565,238.13\\n\" + \"Row #1: 319,494,143,605.90\\n\";\r\n    assertQueryReturns(\"WITH MEMBER [Measures].[A] AS\\n\" + \" '([Measures].[Store Sales] * [Measures].[Store Sales])'\\n\" + \"SELECT {[Store]} ON COLUMNS,\\n\" + \" {[Measures].[Store Sales], [Measures].[A]} ON ROWS\\n\" + \"FROM Sales\", desiredResult);\r\n    assertQueryReturns(\"WITH MEMBER [Measures].[A] AS\\n\" + \" '[Measures].[Store Sales] * [Measures].[Store Sales]'\\n\" + \"SELECT {[Store]} ON COLUMNS,\\n\" + \" {[Measures].[Store Sales], [Measures].[A]} ON ROWS\\n\" + \"FROM Sales\", desiredResult);\r\n    assertQueryReturns(\"WITH MEMBER [Measures].[A] AS\\n\" + \" '[Measures].[Store Sales] * [Measures].[Store Sales] + 0'\\n\" + \"SELECT {[Store]} ON COLUMNS,\\n\" + \" {[Measures].[Store Sales], [Measures].[A]} ON ROWS\\n\" + \"FROM Sales\", desiredResult);\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testExpandLowMaxConstraints",
	"Comment": "verify that a low value for maxconstraints disables native evaluation,even when expandnonnative is true.",
	"Method": "void testExpandLowMaxConstraints(){\r\n    propSaver.set(MondrianProperties.instance().MaxConstraints, 2);\r\n    propSaver.set(MondrianProperties.instance().ExpandNonNative, true);\r\n    checkNotNative(12, \"select NonEmptyCrossJoin(\" + \"    Filter([Store Type].Children, [Measures].[Unit Sales] > 10000), \" + \"    [Product].Children) on columns \" + \"from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Store Type].[Deluxe Supermarket], [Product].[Drink]}\\n\" + \"{[Store Type].[Deluxe Supermarket], [Product].[Food]}\\n\" + \"{[Store Type].[Deluxe Supermarket], [Product].[Non-Consumable]}\\n\" + \"{[Store Type].[Gourmet Supermarket], [Product].[Drink]}\\n\" + \"{[Store Type].[Gourmet Supermarket], [Product].[Food]}\\n\" + \"{[Store Type].[Gourmet Supermarket], [Product].[Non-Consumable]}\\n\" + \"{[Store Type].[Mid-Size Grocery], [Product].[Drink]}\\n\" + \"{[Store Type].[Mid-Size Grocery], [Product].[Food]}\\n\" + \"{[Store Type].[Mid-Size Grocery], [Product].[Non-Consumable]}\\n\" + \"{[Store Type].[Supermarket], [Product].[Drink]}\\n\" + \"{[Store Type].[Supermarket], [Product].[Food]}\\n\" + \"{[Store Type].[Supermarket], [Product].[Non-Consumable]}\\n\" + \"Row #0: 6,827\\n\" + \"Row #0: 55,358\\n\" + \"Row #0: 14,652\\n\" + \"Row #0: 1,945\\n\" + \"Row #0: 15,438\\n\" + \"Row #0: 3,950\\n\" + \"Row #0: 1,159\\n\" + \"Row #0: 8,192\\n\" + \"Row #0: 2,140\\n\" + \"Row #0: 14,092\\n\" + \"Row #0: 108,188\\n\" + \"Row #0: 28,275\\n\");\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Map.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Map appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "org.mapsforge.map.datastore.MapDataStore.extractLocalized",
	"Comment": "extracts substring of preferred language from multilingual string usingthe preferredlanguage setting.",
	"Method": "String extractLocalized(String s){\r\n    return MapDataStore.extract(s, preferredLanguage);\r\n}"
}, {
	"Path": "mondrian.rolap.SqlStatement.execute",
	"Comment": "executes the current statement, and handles any sqlexception.",
	"Method": "void execute(){\r\n    assert state == State.FRESH : \"cannot re-execute\";\r\n    state = State.ACTIVE;\r\n    Counters.SQL_STATEMENT_EXECUTE_COUNT.incrementAndGet();\r\n    Counters.SQL_STATEMENT_EXECUTING_IDS.add(id);\r\n    String status = \"failed\";\r\n    Statement statement = null;\r\n    try {\r\n        locus.execution.checkCancelOrTimeout();\r\n        this.jdbcConnection = dataSource.getConnection();\r\n        querySemaphore.acquire();\r\n        haveSemaphore = true;\r\n        if (RolapUtil.SQL_LOGGER.isDebugEnabled()) {\r\n            StringBuilder sqllog = new StringBuilder();\r\n            sqllog.append(id).append(\": \").append(locus.component).append(\": executing sql [\");\r\n            if (sql.indexOf('\\n') >= 0) {\r\n                sqllog.append(\"\\n\");\r\n            }\r\n            sqllog.append(sql);\r\n            sqllog.append(']');\r\n            RolapUtil.SQL_LOGGER.debug(sqllog.toString());\r\n        }\r\n        RolapUtil.ExecuteQueryHook hook = RolapUtil.getHook();\r\n        if (hook != null) {\r\n            hook.onExecuteQuery(sql);\r\n        }\r\n        locus.execution.checkCancelOrTimeout();\r\n        startTimeNanos = System.nanoTime();\r\n        startTimeMillis = System.currentTimeMillis();\r\n        if (resultSetType < 0 || resultSetConcurrency < 0) {\r\n            statement = jdbcConnection.createStatement();\r\n        } else {\r\n            statement = jdbcConnection.createStatement(resultSetType, resultSetConcurrency);\r\n        }\r\n        if (maxRows > 0) {\r\n            statement.setMaxRows(maxRows);\r\n        }\r\n        if (getPurpose() != Purpose.CELL_SEGMENT) {\r\n            locus.execution.registerStatement(locus, statement);\r\n        } else {\r\n            if (callback != null) {\r\n                callback.apply(statement);\r\n            }\r\n        }\r\n        locus.getServer().getMonitor().sendEvent(new SqlStatementStartEvent(startTimeMillis, id, locus, sql, getPurpose(), getCellRequestCount()));\r\n        this.resultSet = statement.executeQuery(sql);\r\n        this.state = State.ACTIVE;\r\n        if (firstRowOrdinal > 0) {\r\n            if (resultSetType == ResultSet.TYPE_FORWARD_ONLY) {\r\n                for (int i = 0; i < firstRowOrdinal; ++i) {\r\n                    if (!this.resultSet.next()) {\r\n                        this.state = State.DONE;\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                if (!this.resultSet.absolute(firstRowOrdinal)) {\r\n                    this.state = State.DONE;\r\n                }\r\n            }\r\n        }\r\n        long timeMillis = System.currentTimeMillis();\r\n        long timeNanos = System.nanoTime();\r\n        final long executeNanos = timeNanos - startTimeNanos;\r\n        final long executeMillis = executeNanos / 1000000;\r\n        Util.addDatabaseTime(executeMillis);\r\n        status = \", exec \" + executeMillis + \" ms\";\r\n        locus.getServer().getMonitor().sendEvent(new SqlStatementExecuteEvent(timeMillis, id, locus, sql, getPurpose(), executeNanos));\r\n        accessors.clear();\r\n        for (Type type : guessTypes()) {\r\n            accessors.add(createAccessor(accessors.size(), type));\r\n        }\r\n    } catch (Throwable e) {\r\n        status = \", failed (\" + e + \")\";\r\n        Util.close(null, statement, null);\r\n        throw handle(e);\r\n    } finally {\r\n        RolapUtil.SQL_LOGGER.debug(id + \": \" + status);\r\n        if (RolapUtil.LOGGER.isDebugEnabled()) {\r\n            RolapUtil.LOGGER.debug(locus.component + \": executing sql [\" + sql + \"]\" + status);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.TestAggregationManager.testHierarchyInFactTable",
	"Comment": "if a hierarchy lives in the fact table, we should not generate a join.",
	"Method": "void testHierarchyInFactTable(){\r\n    CellRequest request = createRequest(\"Store\", \"[Measures].[Store Sqft]\", \"store\", \"store_type\", \"Supermarket\");\r\n    String accessMysqlSql = \"select `store`.`store_type` as `c0`,\" + \" sum(`store`.`store_sqft`) as `m0` \" + \"from `store` as `store` \" + \"where `store`.`store_type` = 'Supermarket' \" + \"group by `store`.`store_type`\";\r\n    String derbySql = \"select \" + \"\\\"store\\\".\\\"store_type\\\" as \\\"c0\\\", \" + \"sum(\\\"store\\\".\\\"store_sqft\\\") as \\\"m0\\\" \" + \"from \" + \"\\\"store\\\" as \\\"store\\\" \" + \"where \" + \"\\\"store\\\".\\\"store_type\\\" = 'Supermarket' \" + \"group by \\\"store\\\".\\\"store_type\\\"\";\r\n    SqlPattern[] patterns = { new SqlPattern(ACCESS_MYSQL, accessMysqlSql, 26), new SqlPattern(Dialect.DatabaseProduct.DERBY, derbySql, derbySql) };\r\n    assertRequestSql(new CellRequest[] { request }, patterns);\r\n}"
}, {
	"Path": "mondrian.rolap.TestAggregationManager.testCollapsedChildren",
	"Comment": "this test verifies the collapsed children code in sqlmembersource",
	"Method": "void testCollapsedChildren(){\r\n    if (!(MondrianProperties.instance().UseAggregates.get() && MondrianProperties.instance().ReadAggregates.get())) {\r\n        return;\r\n    }\r\n    if (!(MondrianProperties.instance().EnableNativeCrossJoin.get())) {\r\n        return;\r\n    }\r\n    TestContext.instance().flushSchemaCache();\r\n    SqlPattern[] patterns = { new SqlPattern(ACCESS_MYSQL, \"select \" + \"`agg_g_ms_pcat_sales_fact_1997`.`gender` as `c0` \" + \"from `agg_g_ms_pcat_sales_fact_1997` \" + \"as `agg_g_ms_pcat_sales_fact_1997` \" + \"group by \" + \"`agg_g_ms_pcat_sales_fact_1997`.`gender`\" + \" order by ISNULL(`agg_g_ms_pcat_sales_fact_1997`.`gender`) ASC, `agg_g_ms_pcat_sales_fact_1997`.`gender` ASC\", null) };\r\n    String query = \"select non empty [Gender].Children on columns\\n\" + \"from [Sales]\";\r\n    assertQuerySqlOrNot(getTestContext(), query, patterns, false, false, false);\r\n    assertQueryReturns(query, \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Gender].[F]}\\n\" + \"{[Gender].[M]}\\n\" + \"Row #0: 131,558\\n\" + \"Row #0: 135,215\\n\");\r\n}"
}, {
	"Path": "mondrian.rolap.RolapMemberBaseTest.testShouldUsePropertyFormatterWhenPropertyValuesAreRequested",
	"Comment": "given rolap member with properties.when the property formatted value is requested,then property formatter should be used to return the value.",
	"Method": "void testShouldUsePropertyFormatterWhenPropertyValuesAreRequested(){\r\n    RolapProperty property1 = mock(RolapProperty.class);\r\n    RolapProperty property2 = mock(RolapProperty.class);\r\n    when(property1.getName()).thenReturn(PROPERTY_NAME_1);\r\n    when(property2.getName()).thenReturn(PROPERTY_NAME_2);\r\n    when(property1.getFormatter()).thenReturn(propertyFormatter);\r\n    RolapProperty[] properties = { property1, property2 };\r\n    when(level.getProperties()).thenReturn(properties);\r\n    when(propertyFormatter.formatProperty(any(Member.class), anyString(), eq(PROPERTY_VALUE_TO_FORMAT))).thenReturn(FORMATTED_PROPERTY_VALUE);\r\n    rolapMemberBase.setProperty(PROPERTY_NAME_1, PROPERTY_VALUE_TO_FORMAT);\r\n    rolapMemberBase.setProperty(PROPERTY_NAME_2, PROPERTY_VALUE_TO_FORMAT);\r\n    String formatted1 = rolapMemberBase.getPropertyFormattedValue(PROPERTY_NAME_1);\r\n    String formatted2 = rolapMemberBase.getPropertyFormattedValue(PROPERTY_NAME_2);\r\n    String formatted3 = rolapMemberBase.getPropertyFormattedValue(PROPERTY_NAME_3);\r\n    assertEquals(FORMATTED_PROPERTY_VALUE, formatted1);\r\n    assertEquals(PROPERTY_VALUE_TO_FORMAT, formatted2);\r\n    assertEquals(null, formatted3);\r\n}"
}, {
	"Path": "mondrian.tui.MockServletContext.getMimeType",
	"Comment": "returns the mime type of the specified file, or null if the mime type isnot known.",
	"Method": "String getMimeType(String s){\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.olap.Util.dbTimeMillis",
	"Comment": "returns the cumulative amount of time spent accessing the database.",
	"Method": "long dbTimeMillis(){\r\n    return databaseMillis;\r\n}"
}, {
	"Path": "org.mapsforge.map.datastore.MultiMapDataStore.getDataTimestamp",
	"Comment": "returns the timestamp of the data used to render a specific tile.if the tile uses data from multiple data stores, the most recent timestamp is returned.",
	"Method": "long getDataTimestamp(Tile tile){\r\n    switch(this.dataPolicy) {\r\n        case RETURN_FIRST:\r\n            for (MapDataStore mdb : mapDatabases) {\r\n                if (mdb.supportsTile(tile)) {\r\n                    return mdb.getDataTimestamp(tile);\r\n                }\r\n            }\r\n            return 0;\r\n        case RETURN_ALL:\r\n        case DEDUPLICATE:\r\n            long result = 0;\r\n            for (MapDataStore mdb : mapDatabases) {\r\n                if (mdb.supportsTile(tile)) {\r\n                    result = Math.max(result, mdb.getDataTimestamp(tile));\r\n                }\r\n            }\r\n            return result;\r\n    }\r\n    throw new IllegalStateException(\"Invalid data policy for multi map database\");\r\n}"
}, {
	"Path": "mondrian.olap.fun.vba.Vba.computeDelta",
	"Comment": "computes the difference in milliseconds between two instants, thathave not more than 24 hours difference",
	"Method": "int computeDelta(Calendar after,Calendar before){\r\n    int hAfter = after.get(Calendar.HOUR_OF_DAY);\r\n    int hBefore = before.get(Calendar.HOUR_OF_DAY);\r\n    if (after.get(Calendar.DATE) > before.get(Calendar.DATE)) {\r\n        hAfter += 24;\r\n    }\r\n    long result = (1000L * 60 * 60) * (hAfter - hBefore);\r\n    result += (1000L * 60) * (after.get(Calendar.MINUTE) - before.get(Calendar.MINUTE));\r\n    result += 1000L * (after.get(Calendar.SECOND) - before.get(Calendar.SECOND));\r\n    result += after.get(Calendar.MILLISECOND) - before.get(Calendar.MILLISECOND);\r\n    assert (result <= MILLIS_IN_A_DAY);\r\n    return (int) result;\r\n}"
}, {
	"Path": "org.mapsforge.core.model.LineSegment.subSegment",
	"Comment": "linesegment that starts at offset from start and runs for length towards end point",
	"Method": "LineSegment subSegment(double offset,double length){\r\n    Point subSegmentStart = pointAlongLineSegment(offset);\r\n    Point subSegmentEnd = pointAlongLineSegment(offset + length);\r\n    return new LineSegment(subSegmentStart, subSegmentEnd);\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getCookies",
	"Comment": "returns an array containing all of the cookie objects the client sentwith this request.",
	"Method": "Cookie[] getCookies(){\r\n    return cookies.toArray(new Cookie[cookies.size()]);\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.ui.widget.StaggeredGridView.setItemMargin",
	"Comment": "set the margin between items in pixels. this margin is appliedboth vertically and horizontally.",
	"Method": "void setItemMargin(int marginPixels){\r\n    final boolean needsPopulate = marginPixels != mItemMargin;\r\n    mItemMargin = marginPixels;\r\n    if (needsPopulate) {\r\n        populate(false);\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.TestCalculatedMembers.testEarlierCalcMember",
	"Comment": "if there are multiple calc members with the same name, the first ischosen, even if it is not the best match.",
	"Method": "void testEarlierCalcMember(){\r\n    if (!MondrianProperties.instance().SsasCompatibleNaming.get()) {\r\n        return;\r\n    }\r\n    assertQueryReturns(\"with\\n\" + \" member [Time].[Time].[1997].[Q1].[1999] as 1\\n\" + \" member [Time].[Time].[1997].[Q1].[1998] as 2\\n\" + \" member [Time].[Time].[1997].[Q2].[1998] as 3\\n\" + \" member [Time].[Time].[1997].[1998] as 4\\n\" + \" select [Time].[Time].[1998] on 0\\n\" + \" from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Time].[1997].[Q1].[1998]}\\n\" + \"Row #0: 2\\n\");\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.Recognizer.aggUsageMatchesHierarchyUsage",
	"Comment": "returns true if aggusage matches the relation andcolumn name of hiearchyusage & levelcolumnname.adjusts aggusage column name based on usageprefix, if present.",
	"Method": "boolean aggUsageMatchesHierarchyUsage(JdbcSchema.Table.Column.Usage aggUsage,HierarchyUsage hierarchyUsage,String levelColumnName){\r\n    MondrianDef.Relation rel = hierarchyUsage.getJoinTable();\r\n    JdbcSchema.Table.Column aggColumn = aggUsage.getColumn();\r\n    String aggColumnName = aggColumn.column.name;\r\n    String usagePrefix = hierarchyUsage.getUsagePrefix() == null ? \"\" : hierarchyUsage.getUsagePrefix();\r\n    if (usagePrefix.length() > 0 && !usagePrefix.equals(aggColumnName.substring(0, usagePrefix.length()))) {\r\n        throw new MondrianException(\"usagePrefix attribute \" + usagePrefix + \" was specified for \" + hierarchyUsage.getHierarchyName() + \", but found agg column without prefix:  \" + aggColumnName);\r\n    }\r\n    String aggColumnWithoutPrefix = aggColumnName.substring(usagePrefix.length());\r\n    return aggUsage.relation.equals(rel) && aggColumnWithoutPrefix.equalsIgnoreCase(levelColumnName);\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getParameterValues",
	"Comment": "returns an array of string objects containing all of the values the givenrequest parameter has, or null if the parameter does not exist.",
	"Method": "String[] getParameterValues(String name){\r\n    return parameters.get(name);\r\n}"
}, {
	"Path": "mondrian.test.BasicQueryTest.testFormatInheritanceUseSecondIfFirstHasNoFormat",
	"Comment": "test format inheritance to pickup format from second measure when thefirst does not have one.",
	"Method": "void testFormatInheritanceUseSecondIfFirstHasNoFormat(){\r\n    assertQueryReturns(\"with member measures.foo as 'measures.bar+measures.blah'\" + \" member measures.bar as '10'\" + \" member measures.blah as '20',format_string='$##.###.00' \" + \"select from sales where measures.foo\", \"Axis #0:\\n\" + \"{[Measures].[foo]}\\n\" + \"$30.00\");\r\n}"
}, {
	"Path": "mondrian.util.AbstractMemoryMonitor.usagePercentage",
	"Comment": "returns how much memory is currently being used as a percentage.",
	"Method": "int usagePercentage(){\r\n    return convertThresholdToPercentage(getUsedMemory());\r\n}"
}, {
	"Path": "mondrian.rolap.RolapConnectionPool.getPool",
	"Comment": "gets or creates a connection pool for a particular connectspecification.",
	"Method": "ObjectPool getPool(Object key,ConnectionFactory connectionFactory){\r\n    ObjectPool connectionPool = mapConnectKeyToPool.get(key);\r\n    if (connectionPool == null) {\r\n        connectionPool = new GenericObjectPool(null, 50, GenericObjectPool.WHEN_EXHAUSTED_BLOCK, 3000, 10, false, false, 60000, 5, 30000, true);\r\n        AbandonedConfig abandonedConfig = new AbandonedConfig();\r\n        abandonedConfig.setRemoveAbandoned(true);\r\n        abandonedConfig.setRemoveAbandonedTimeout(300);\r\n        abandonedConfig.setLogAbandoned(true);\r\n        PoolableConnectionFactory poolableConnectionFactory = new PoolableConnectionFactory(connectionFactory, connectionPool, null, null, false, true, abandonedConfig);\r\n        Util.discard(poolableConnectionFactory);\r\n        mapConnectKeyToPool.put(key, connectionPool);\r\n    }\r\n    return connectionPool;\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getScheme",
	"Comment": "returns the name of the scheme used to make this request, for example,http, https, or ftp.",
	"Method": "String getScheme(){\r\n    return schema;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCube.shouldIgnoreUnrelatedDimensions",
	"Comment": "this method tells us if unrelated dimensions to measures fromthe input base cube should be pushed to default member or notduring aggregation.",
	"Method": "boolean shouldIgnoreUnrelatedDimensions(String baseCubeName){\r\n    return cubeUsages != null && cubeUsages.shouldIgnoreUnrelatedDimensions(baseCubeName);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Button.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Button appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.calc.impl.ConstantCalc.constantDimension",
	"Comment": "creates an expression which evaluates to a given dimension.",
	"Method": "Calc constantDimension(Dimension dimension){\r\n    return new ConstantCalc(DimensionType.forDimension(dimension), dimension);\r\n}"
}, {
	"Path": "org.mapsforge.core.model.BoundingBox.getPositionRelativeToTile",
	"Comment": "computes the coordinates of this bounding box relative to a tile.",
	"Method": "Rectangle getPositionRelativeToTile(Tile tile){\r\n    Point upperLeft = MercatorProjection.getPixelRelativeToTile(new LatLong(this.maxLatitude, minLongitude), tile);\r\n    Point lowerRight = MercatorProjection.getPixelRelativeToTile(new LatLong(this.minLatitude, maxLongitude), tile);\r\n    return new Rectangle(upperLeft.x, upperLeft.y, lowerRight.x, lowerRight.y);\r\n}"
}, {
	"Path": "org.mapsforge.core.model.Tag.compareTo",
	"Comment": "compares this tag to the specified tag.the tag comparison is based on a comparison of key and value in that order.",
	"Method": "int compareTo(Tag tag){\r\n    int keyResult = this.key.compareTo(tag.key);\r\n    if (keyResult != 0) {\r\n        return keyResult;\r\n    }\r\n    return this.value.compareTo(tag.value);\r\n}"
}, {
	"Path": "mondrian.test.ParameterTest.testAssignSetParameter",
	"Comment": "positive and negative tests assigning values to a parameter whose type isa set of members.",
	"Method": "void testAssignSetParameter(){\r\n    final String para = \"Parameter(\\\"x\\\", [Customers], {[Customers].[USA], [Customers].[USA].[CA]})\";\r\n    assertAssignParameter(para, true, \"8\", \"MDX object '8' not found in cube 'Sales'\");\r\n    assertAssignParameter(para, true, \"foobar\", \"MDX object 'foobar' not found in cube 'Sales'\");\r\n    assertAssignParameter(para, true, 8, \"Invalid value '8' for parameter 'x', type SetType<MemberType<hierarchy=[Customers]>\");\r\n    assertAssignParameter(para, true, -8.56, \"Invalid value '-8.56' for parameter 'x', type SetType<MemberType<hierarchy=[Customers]>\");\r\n    assertAssignParameter(para, true, new BigDecimal(\"12.345\"), \"Invalid value '12.345' for parameter 'x', type SetType<MemberType<hierarchy=[Customers]>\");\r\n    assertAssignParameter(para, true, new Date(), \"' for parameter 'x', type SetType<MemberType<hierarchy=[Customers]>\");\r\n    assertAssignParameter(para, true, new Timestamp(new Date().getTime()), \"' for parameter 'x', type SetType<MemberType<hierarchy=[Customers]>\");\r\n    assertAssignParameter(para, true, new Time(new Date().getTime()), \"' for parameter 'x', type SetType<MemberType<hierarchy=[Customers]>\");\r\n    assertAssignParameter(para, true, \"{[Customers].[USA], [Customers].[All Customers].[Canada].[BC]}\", null);\r\n    assertAssignParameter(para, true, \"[Customers].[USA], [Customers].[All Customers].[Canada].[BC]\", null);\r\n    assertAssignParameter(para, true, \"[Customers] . [USA] , [Customers].[Canada].[BC],[Customers].[Mexico]\", null);\r\n    assertAssignParameter(para, true, \"{[Customers].[USA], [Customers].[Canada].[BC].[Bear City]}\", \"MDX object '[Customers].[Canada].[BC].[Bear City]' not found in cube 'Sales'\");\r\n    List<Member> list;\r\n    SchemaReader sr = TestContext.instance().getConnection().parseQuery(\"select from [Sales]\").getSchemaReader(true).withLocus();\r\n    list = Collections.emptyList();\r\n    assertAssignParameter(para, true, list, null);\r\n    assertAssignParameter(para, true, \"\", null);\r\n    assertAssignParameter(para, true, \"{}\", null);\r\n    assertAssignParameter(para, true, \" { } \", null);\r\n    assertAssignParameter(para, true, null, \"Invalid value 'null' for parameter 'x', type SetType<MemberType<hierarchy=[Customers]>>\");\r\n    list = Arrays.asList(sr.getMemberByUniqueName(Id.Segment.toList(\"Customers\", \"Mexico\"), true), sr.getMemberByUniqueName(Id.Segment.toList(\"Time\", \"1997\", \"Q2\", \"5\"), true));\r\n    assertAssignParameter(para, true, list, \"Invalid value '[Time].[1997].[Q2].[5]' for parameter 'x', \" + \"type MemberType<hierarchy=[Customers]>\");\r\n    assertAssignParameter(para, true, \"{[Customers].[Mexico], [Time].[1997].[Q2].[5]}\", \"Invalid value '[Time].[1997].[Q2].[5]' for parameter 'x', \" + \"type MemberType<hierarchy=[Customers]>\");\r\n    list = Arrays.asList(sr.getMemberByUniqueName(Id.Segment.toList(\"Customers\", \"Mexico\"), true), sr.getMemberByUniqueName(Id.Segment.toList(\"Customers\", \"Canada\"), true));\r\n    assertAssignParameter(para, true, list, null);\r\n    list = Arrays.asList(sr.getMemberByUniqueName(Id.Segment.toList(\"Customers\", \"USA\", \"CA\"), true), sr.getMemberByUniqueName(Id.Segment.toList(\"Customers\", \"Mexico\"), true));\r\n    assertAssignParameter(\"Parameter(\\\"x\\\", [Customers].[State Province], {[Customers].[USA].[CA]})\", true, list, \"Invalid value '[Customers].[Mexico]' for parameter \" + \"'x', type MemberType<level=[Customers].[State Province]>\");\r\n    assertAssignParameter(\"Parameter(\\\"x\\\", [Customers].[State Province], {[Customers].[USA].[CA]})\", true, \"{[Customers].[USA].[CA], [Customers].[Mexico]}\", \"Invalid value '[Customers].[Mexico]' for parameter \" + \"'x', type MemberType<level=[Customers].[State Province]>\");\r\n    list = Arrays.asList(sr.getMemberByUniqueName(Id.Segment.toList(\"Customers\", \"USA\", \"CA\"), true), null, sr.getMemberByUniqueName(Id.Segment.toList(\"Customers\", \"USA\", \"OR\"), true));\r\n    assertAssignParameter(\"Parameter(\\\"x\\\", [Customers].[State Province], {[Customers].[USA].[CA]})\", true, list, null);\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.util.PolyLabel.get",
	"Comment": "returns pole of inaccessibility, the most distant internal point from the polygon outline.",
	"Method": "Point get(Geometry geometry){\r\n    Polygon polygon;\r\n    if (geometry instanceof LineString) {\r\n        polygon = geometry.getFactory().createPolygon(geometry.getCoordinates());\r\n    } else if (geometry instanceof MultiPolygon) {\r\n        Geometry widestGeometry = geometry.getGeometryN(0);\r\n        for (int i = 1; i < geometry.getNumGeometries(); i++) {\r\n            if (geometry.getGeometryN(i).getEnvelopeInternal().getWidth() > widestGeometry.getEnvelopeInternal().getWidth()) {\r\n                widestGeometry = geometry.getGeometryN(i);\r\n            }\r\n        }\r\n        polygon = (Polygon) widestGeometry;\r\n    } else if (geometry instanceof Polygon) {\r\n        polygon = (Polygon) geometry;\r\n    } else {\r\n        LOGGER.warning(\"Failed to get label for geometry: \" + geometry);\r\n        return geometry.getCentroid();\r\n    }\r\n    polygon = (Polygon) polygon.clone();\r\n    polygon.apply(new CoordinateFilter() {\r\n        @Override\r\n        public void filter(Coordinate c) {\r\n            c.x = longitudeToX(c.x);\r\n            c.y = latitudeToY(c.y);\r\n        }\r\n    });\r\n    polygon.geometryChanged();\r\n    Envelope envelope = polygon.getEnvelopeInternal();\r\n    double width = envelope.getWidth();\r\n    double height = envelope.getHeight();\r\n    double cellSize = Math.min(width, height);\r\n    double h = cellSize / 2;\r\n    PriorityQueue<Cell> cellQueue = new PriorityQueue(1, new MaxComparator());\r\n    for (double x = envelope.getMinX(); x < envelope.getMaxX(); x += cellSize) {\r\n        for (double y = envelope.getMinY(); y < envelope.getMaxY(); y += cellSize) {\r\n            cellQueue.add(new Cell(x + h, y + h, h, polygon));\r\n        }\r\n    }\r\n    Cell bestCell = getCentroidCell(polygon);\r\n    Cell bboxCell = new Cell(envelope.centre().x, envelope.centre().y, 0, polygon);\r\n    if (bboxCell.d > bestCell.d)\r\n        bestCell = bboxCell;\r\n    while (!cellQueue.isEmpty()) {\r\n        Cell cell = cellQueue.remove();\r\n        if (cell.d > bestCell.d)\r\n            bestCell = cell;\r\n        if (cell.max - bestCell.d <= PRECISION)\r\n            continue;\r\n        h = cell.h / 2;\r\n        cellQueue.add(new Cell(cell.x - h, cell.y - h, h, polygon));\r\n        cellQueue.add(new Cell(cell.x + h, cell.y - h, h, polygon));\r\n        cellQueue.add(new Cell(cell.x - h, cell.y + h, h, polygon));\r\n        cellQueue.add(new Cell(cell.x + h, cell.y + h, h, polygon));\r\n    }\r\n    return geometry.getFactory().createPoint(new Coordinate(toLongitude(bestCell.x), toLatitude(bestCell.y)));\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.util.PolyLabel.get",
	"Comment": "returns pole of inaccessibility, the most distant internal point from the polygon outline.",
	"Method": "Point get(Geometry geometry){\r\n    c.x = longitudeToX(c.x);\r\n    c.y = latitudeToY(c.y);\r\n}"
}, {
	"Path": "mondrian.olap.MondrianPropertiesBase.load",
	"Comment": "tries to load properties from a url. does not fail, just prints successor failure to log.",
	"Method": "void load(PropertySource source){\r\n    try {\r\n        load(source.openStream());\r\n        if (populateCount == 0) {\r\n            LOGGER.info(\"Mondrian: properties loaded from '\" + source.getDescription() + \"'\");\r\n        }\r\n    } catch (IOException e) {\r\n        LOGGER.error(\"Mondrian: error while loading properties \" + \"from '\" + source.getDescription() + \"' (\" + e + \")\");\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.samples.android.dummy.ManyDummyContent.loadXmlFromNetwork",
	"Comment": "uploads xml from nominatim.openstreetmap.org, parses it, andcreate dummyitems from it",
	"Method": "List<DummyItem> loadXmlFromNetwork(String urlString){\r\n    String jString;\r\n    List<Entry> entries = null;\r\n    List<DummyItem> rtnArray = new ArrayList<DummyItem>();\r\n    BufferedReader streamReader = null;\r\n    try {\r\n        streamReader = new BufferedReader(downloadUrl(urlString));\r\n        StringBuilder responseStrBuilder = new StringBuilder();\r\n        String inputStr;\r\n        while ((inputStr = streamReader.readLine()) != null) responseStrBuilder.append(inputStr);\r\n        jString = responseStrBuilder.toString();\r\n        if (jString == null) {\r\n            Log.e(SamplesApplication.TAG, \"Nominatim Webpage: request failed for \" + urlString);\r\n            return new ArrayList<DummyItem>(0);\r\n        }\r\n        JSONArray jPlaceIds = new JSONArray(jString);\r\n        int n = jPlaceIds.length();\r\n        entries = new ArrayList<Entry>(n);\r\n        for (int i = 0; i < n; i++) {\r\n            JSONObject jPlace = jPlaceIds.getJSONObject(i);\r\n            Entry poi = new // jPlace.getString(\"place_rank\"),\r\n            Entry(// jPlace.getString(\"place_rank\"),\r\n            jPlace.optLong(\"place_id\"), // jPlace.getString(\"place_rank\"),\r\n            jPlace.getString(\"osm_type\"), jPlace.getString(\"osm_id\"), jPlace.getString(\"boundingbox\"), jPlace.getString(\"lat\"), jPlace.getString(\"lon\"), jPlace.getString(\"display_name\"), jPlace.getString(\"class\"), jPlace.getString(\"type\"), jPlace.getString(\"importance\"));\r\n            entries.add(poi);\r\n        }\r\n    } catch (JSONException e) {\r\n        e.printStackTrace();\r\n        return null;\r\n    } finally {\r\n        if (streamReader != null) {\r\n            streamReader.close();\r\n        }\r\n    }\r\n    for (Entry entry : entries) {\r\n        rtnArray.add(new DummyItem(entry.mOsm_id, entry.mDisplay_name.split(\",\")[0], new LatLong(Double.parseDouble(entry.mLat), Double.parseDouble(entry.mLon)), entry.mDisplay_name));\r\n    }\r\n    return rtnArray;\r\n}"
}, {
	"Path": "mondrian.gui.JdbcMetaData.getAllColumns",
	"Comment": "gets all columns of given table in schema.column string is formatted.",
	"Method": "List<String> getAllColumns(String schemaName,String tableName,List<String> getAllColumns,String sname,String tableName){\r\n    List<String> allcols = new ArrayList<String>();\r\n    if (tableName == null) {\r\n        List<String> allTables = getAllTables(schemaName);\r\n        for (int i = 0; i < allTables.size(); i++) {\r\n            String tab = allTables.get(i);\r\n            List<String> cols;\r\n            if (tab.indexOf(LEVEL_SEPARATOR) == -1) {\r\n                cols = getAllColumns(schemaName, tab);\r\n            } else {\r\n                String[] names = tab.split(LEVEL_SEPARATOR);\r\n                cols = getAllColumns(names[0], names[1]);\r\n            }\r\n            for (int j = 0; j < cols.size(); j++) {\r\n                String col = cols.get(j);\r\n                allcols.add(tab + LEVEL_SEPARATOR + col);\r\n            }\r\n        }\r\n        return allcols;\r\n    } else {\r\n        if (!db.hasColumns(schemaName, tableName)) {\r\n            setColumns(schemaName, tableName);\r\n        }\r\n        return db.getAllColumns(schemaName, tableName);\r\n    }\r\n}"
}, {
	"Path": "com.oath.micro.server.s3.data.S3Utils.delete",
	"Comment": "method delete all objects from bucketname in groups by 1000elements",
	"Method": "void delete(String bucketName,List<KeyVersion> objects){\r\n    ReactiveSeq.fromList(objects).grouped(1000).forEach(l -> {\r\n        DeleteObjectsRequest req = new DeleteObjectsRequest(bucketName);\r\n        req.setKeys(l.toList());\r\n        client.deleteObjects(req);\r\n    });\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Var.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Var appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "org.mapsforge.map.android.util.MapViewerTemplate.createSharedPreferences",
	"Comment": "creates the shared preferences that are being used to store map view data overactivity restarts.",
	"Method": "void createSharedPreferences(){\r\n    this.preferencesFacade = new AndroidPreferences(this.getSharedPreferences(getPersistableId(), MODE_PRIVATE));\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getRequestDispatcher",
	"Comment": "returns a requestdispatcher object that acts as a wrapper for theresource located at the given path.",
	"Method": "RequestDispatcher getRequestDispatcher(String path){\r\n    RequestDispatcher dispatcher = requestDispatchers.get(path);\r\n    if (dispatcher == null) {\r\n        dispatcher = new MockRequestDispatcher();\r\n        setRequestDispatcher(path, dispatcher);\r\n    }\r\n    return dispatcher;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteSession.executeForLastInsertedRowId",
	"Comment": "executes a statement that returns the row id of the last row insertedby the statement.use for insert sql statements.",
	"Method": "long executeForLastInsertedRowId(String sql,Object[] bindArgs,int connectionFlags,CancellationSignal cancellationSignal){\r\n    if (sql == null) {\r\n        throw new IllegalArgumentException(\"sql must not be null.\");\r\n    }\r\n    if (executeSpecial(sql, bindArgs, connectionFlags, cancellationSignal)) {\r\n        return 0;\r\n    }\r\n    acquireConnection(sql, connectionFlags, cancellationSignal);\r\n    try {\r\n        return // might throw\r\n        mConnection.executeForLastInsertedRowId(// might throw\r\n        sql, bindArgs, cancellationSignal);\r\n    } finally {\r\n        releaseConnection();\r\n    }\r\n}"
}, {
	"Path": "mondrian.gui.JdbcMetaData.setPKey",
	"Comment": "gets the primary key name for a given table name.this key may be acomposite key made of multiple columns.",
	"Method": "void setPKey(DbTable dbt){\r\n    ResultSet rs = null;\r\n    try {\r\n        rs = md.getPrimaryKeys(null, dbt.schemaName, dbt.name);\r\n        if (rs.next()) {\r\n            dbt.pk = rs.getString(\"column_name\");\r\n        }\r\n    } catch (Exception e) {\r\n        LOGGER.error(\"setPKey\", e);\r\n    } finally {\r\n        try {\r\n            rs.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Noscript.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Noscript appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "org.mapsforge.map.rendertheme.RenderContext.otherTile",
	"Comment": "just a way of generating a hash key for a tile if only the rendererjob is known.",
	"Method": "RendererJob otherTile(Tile tile){\r\n    return new RendererJob(tile, this.rendererJob.mapDataStore, this.rendererJob.renderThemeFuture, this.rendererJob.displayModel, this.rendererJob.textScale, this.rendererJob.hasAlpha, this.rendererJob.labelsOnly);\r\n}"
}, {
	"Path": "org.mapsforge.map.reader.MapFile.closeFileChannel",
	"Comment": "closes the map file channel and destroys all internal caches.has no effect if no map file channel is currently opened.",
	"Method": "void closeFileChannel(){\r\n    try {\r\n        if (this.databaseIndexCache != null) {\r\n            this.databaseIndexCache.destroy();\r\n        }\r\n        if (this.inputChannel != null) {\r\n            this.inputChannel.close();\r\n        }\r\n    } catch (Exception e) {\r\n        LOGGER.log(Level.SEVERE, e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Optgroup.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Optgroup appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "org.mapsforge.map.layer.labels.TileBasedLabelStore.requiresTile",
	"Comment": "returns if a tile is in the current tile set and no data is stored for this tile.",
	"Method": "boolean requiresTile(Tile tile){\r\n    return this.lastVisibleTileSet.contains(tile) && !this.containsKey(tile);\r\n}"
}, {
	"Path": "mondrian.olap.RoleImpl.createAllAccess",
	"Comment": "creates an element which represents all access to a hierarchy.",
	"Method": "HierarchyAccess createAllAccess(Hierarchy hierarchy){\r\n    return new HierarchyAccessImpl(Util.createRootRole(hierarchy.getDimension().getSchema()), hierarchy, Access.ALL, null, null, Role.RollupPolicy.FULL);\r\n}"
}, {
	"Path": "mondrian.rolap.SqlConstraintUtils.generateMultiValueIsNullExprs",
	"Comment": "generates an expression that is an or of is null expressions, oneper level in a rolapmember.",
	"Method": "String generateMultiValueIsNullExprs(SqlQuery sqlQuery,RolapCube baseCube,RolapMember member,RolapLevel fromLevel,AggStar aggStar){\r\n    final StringBuilder conditionBuf = new StringBuilder();\r\n    conditionBuf.append(\"(\");\r\n    boolean isFirstLevelInMultiple = true;\r\n    for (RolapMember m = member; m != null; m = m.getParentMember()) {\r\n        if (m.isAll()) {\r\n            continue;\r\n        }\r\n        String columnString = getColumnString(sqlQuery, aggStar, m.getLevel(), baseCube);\r\n        if (!isFirstLevelInMultiple) {\r\n            conditionBuf.append(\" or \");\r\n        } else {\r\n            isFirstLevelInMultiple = false;\r\n        }\r\n        conditionBuf.append(columnString);\r\n        conditionBuf.append(\" is null\");\r\n        if (m.getLevel() == fromLevel) {\r\n            break;\r\n        }\r\n    }\r\n    conditionBuf.append(\")\");\r\n    return conditionBuf.toString();\r\n}"
}, {
	"Path": "com.haibao.store.myapplication.common.ActivityPageManager.getInstance",
	"Comment": "get the appmanager instance, the appmanager is singleton.",
	"Method": "ActivityPageManager getInstance(){\r\n    if (instance == null) {\r\n        instance = new ActivityPageManager();\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "mondrian.rolap.SqlTupleReader.chooseAggStar",
	"Comment": "obtains the aggstar instance which corresponds to an aggregate tablewhich can be used to support the member constraint.",
	"Method": "AggStar chooseAggStar(TupleConstraint constraint,Evaluator evaluator,RolapCube baseCube){\r\n    if (!MondrianProperties.instance().UseAggregates.get()) {\r\n        return null;\r\n    }\r\n    if (evaluator == null || !constraint.supportsAggTables()) {\r\n        return null;\r\n    }\r\n    if (baseCube == null) {\r\n        baseCube = (RolapCube) evaluator.getCube();\r\n    }\r\n    if (baseCube.isVirtual()) {\r\n        return null;\r\n    }\r\n    RolapStar star = baseCube.getStar();\r\n    final int starColumnCount = star.getColumnCount();\r\n    BitKey measureBitKey = BitKey.Factory.makeBitKey(starColumnCount);\r\n    BitKey levelBitKey = BitKey.Factory.makeBitKey(starColumnCount);\r\n    final Member[] members = SqlConstraintUtils.expandSupportedCalculatedMembers(Arrays.asList(evaluator.getNonAllMembers()), evaluator).getMembersArray();\r\n    if (!(members[0] instanceof RolapBaseCubeMeasure)) {\r\n        return null;\r\n    }\r\n    RolapBaseCubeMeasure measure = (RolapBaseCubeMeasure) members[0];\r\n    int bitPosition = ((RolapStar.Measure) measure.getStarMeasure()).getBitPosition();\r\n    final CellRequest request = RolapAggregationManager.makeRequest(members);\r\n    if (request == null) {\r\n        return null;\r\n    }\r\n    RolapStar.Column[] columns = request.getConstrainedColumns();\r\n    for (RolapStar.Column column1 : columns) {\r\n        levelBitKey.set(column1.getBitPosition());\r\n    }\r\n    for (TargetBase target : targets) {\r\n        RolapLevel level = target.level;\r\n        if (!level.isAll()) {\r\n            RolapStar.Column column = ((RolapCubeLevel) level).getBaseStarKeyColumn(baseCube);\r\n            if (column != null) {\r\n                levelBitKey.set(column.getBitPosition());\r\n            }\r\n        }\r\n    }\r\n    RolapUtil.constraintBitkeyForLimitedMembers(evaluator, evaluator.getMembers(), baseCube, levelBitKey);\r\n    measureBitKey.set(bitPosition);\r\n    if (constraint instanceof RolapNativeCrossJoin.NonEmptyCrossJoinConstraint) {\r\n        RolapNativeCrossJoin.NonEmptyCrossJoinConstraint necj = (RolapNativeCrossJoin.NonEmptyCrossJoinConstraint) constraint;\r\n        for (CrossJoinArg arg : necj.args) {\r\n            if (arg instanceof DescendantsCrossJoinArg || arg instanceof MemberListCrossJoinArg) {\r\n                final RolapLevel level = arg.getLevel();\r\n                if (level != null && !level.isAll()) {\r\n                    RolapStar.Column column = ((RolapCubeLevel) level).getBaseStarKeyColumn(baseCube);\r\n                    if (column == null) {\r\n                        continue;\r\n                    }\r\n                    levelBitKey.set(column.getBitPosition());\r\n                }\r\n            }\r\n        }\r\n    } else if (constraint instanceof RolapNativeFilter.FilterConstraint) {\r\n        for (Member slicer : ((RolapEvaluator) evaluator).getSlicerMembers()) {\r\n            final Level level = slicer.getLevel();\r\n            if (level != null && !level.isAll()) {\r\n                final RolapStar.Column column = ((RolapCubeLevel) level).getBaseStarKeyColumn(baseCube);\r\n                levelBitKey.set(column.getBitPosition());\r\n            }\r\n        }\r\n    }\r\n    return AggregationManager.findAgg(star, levelBitKey, measureBitKey, new boolean[] { false });\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.resolveFunArgs",
	"Comment": "validates the arguments to a function and resolves the function.",
	"Method": "FunDef resolveFunArgs(Validator validator,FunDef funDef,Exp[] args,Exp[] newArgs,String name,Syntax syntax){\r\n    for (int i = 0; i < args.length; i++) {\r\n        newArgs[i] = validator.validate(args[i], false);\r\n    }\r\n    if (funDef == null || validator.alwaysResolveFunDef()) {\r\n        funDef = validator.getDef(newArgs, name, syntax);\r\n    }\r\n    checkNativeCompatible(validator, funDef, newArgs);\r\n    return funDef;\r\n}"
}, {
	"Path": "mondrian.rolap.SqlConstraintUtils.addSlicedMemberToMap",
	"Comment": "adds the slicer member and all parent members to mapofslicermemberscapturing the sliced members associated with an expression.",
	"Method": "void addSlicedMemberToMap(Map<MondrianDef.Expression, Set<RolapMember>> mapOfSlicerMembers,Member slicerMember){\r\n    if (slicerMember == null || slicerMember.isAll() || slicerMember.isNull()) {\r\n        return;\r\n    }\r\n    assert slicerMember instanceof RolapMember;\r\n    MondrianDef.Expression expression = ((RolapLevel) slicerMember.getLevel()).getKeyExp();\r\n    if (!mapOfSlicerMembers.containsKey(expression)) {\r\n        mapOfSlicerMembers.put(expression, new LinkedHashSet<RolapMember>());\r\n    }\r\n    mapOfSlicerMembers.get(expression).add((RolapMember) slicerMember);\r\n    addSlicedMemberToMap(mapOfSlicerMembers, slicerMember.getParentMember());\r\n}"
}, {
	"Path": "mondrian.test.TestContext.withSchema",
	"Comment": "creates a testcontext which contains the given schema text.",
	"Method": "TestContext withSchema(String schema){\r\n    final Util.PropertyList properties = getConnectionProperties().clone();\r\n    properties.put(RolapConnectionProperties.CatalogContent.name(), schema);\r\n    return withProperties(properties);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Font.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Font appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "org.mapsforge.map.rendertheme.rule.RenderTheme.scaleStrokeWidth",
	"Comment": "scales the stroke width of this rendertheme by the given factor for a given zoom level",
	"Method": "void scaleStrokeWidth(float scaleFactor,byte zoomLevel){\r\n    if (!strokeScales.containsKey(zoomLevel) || scaleFactor != strokeScales.get(zoomLevel)) {\r\n        for (int i = 0, n = this.rulesList.size(); i < n; ++i) {\r\n            Rule rule = this.rulesList.get(i);\r\n            if (rule.zoomMin <= zoomLevel && rule.zoomMax >= zoomLevel) {\r\n                rule.scaleStrokeWidth(scaleFactor * this.baseStrokeWidth, zoomLevel);\r\n            }\r\n        }\r\n        strokeScales.put(zoomLevel, scaleFactor);\r\n    }\r\n}"
}, {
	"Path": "mondrian.util.ObjectPool.contains",
	"Comment": "returns true it the object is already in the objectpool and falseotherwise.",
	"Method": "boolean contains(T key){\r\n    int i = indexOfInsertion(key);\r\n    return (i < 0);\r\n}"
}, {
	"Path": "org.mapsforge.map.layer.renderer.GeometryUtils.calculateCenterOfBoundingBox",
	"Comment": "calculates the center of the minimum bounding rectangle for the given coordinates.",
	"Method": "Point calculateCenterOfBoundingBox(Point[] coordinates){\r\n    double pointXMin = coordinates[0].x;\r\n    double pointXMax = coordinates[0].x;\r\n    double pointYMin = coordinates[0].y;\r\n    double pointYMax = coordinates[0].y;\r\n    for (Point immutablePoint : coordinates) {\r\n        if (immutablePoint.x < pointXMin) {\r\n            pointXMin = immutablePoint.x;\r\n        } else if (immutablePoint.x > pointXMax) {\r\n            pointXMax = immutablePoint.x;\r\n        }\r\n        if (immutablePoint.y < pointYMin) {\r\n            pointYMin = immutablePoint.y;\r\n        } else if (immutablePoint.y > pointYMax) {\r\n            pointYMax = immutablePoint.y;\r\n        }\r\n    }\r\n    return new Point((pointXMin + pointXMax) / 2, (pointYMax + pointYMin) / 2);\r\n}"
}, {
	"Path": "mondrian.test.FoodMartTestCase.getTestContext",
	"Comment": "returns the test context. override this method if you wish to use adifferent source for your foodmart connection.",
	"Method": "TestContext getTestContext(){\r\n    return TestContext.instance();\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletResponse.containsHeader",
	"Comment": "returns a boolean indicating whether the named response header hasalready been set.",
	"Method": "boolean containsHeader(String name){\r\n    return headers.containsKey(name);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Script.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Script appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "org.jfaster.mango.parser.SimpleCharStream.adjustBeginLineColumn",
	"Comment": "method to adjust line and column numbers for the start of a token.",
	"Method": "void adjustBeginLineColumn(int newLine,int newCol){\r\n    int start = tokenBegin;\r\n    int len;\r\n    if (bufpos >= tokenBegin) {\r\n        len = bufpos - tokenBegin + inBuf + 1;\r\n    } else {\r\n        len = bufsize - tokenBegin + bufpos + 1 + inBuf;\r\n    }\r\n    int i = 0, j = 0, k = 0;\r\n    int nextColDiff = 0, columnDiff = 0;\r\n    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize]) {\r\n        bufline[j] = newLine;\r\n        nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];\r\n        bufcolumn[j] = newCol + columnDiff;\r\n        columnDiff = nextColDiff;\r\n        i++;\r\n    }\r\n    if (i < len) {\r\n        bufline[j] = newLine++;\r\n        bufcolumn[j] = newCol + columnDiff;\r\n        while (i++ < len) {\r\n            if (bufline[j = start % bufsize] != bufline[++start % bufsize])\r\n                bufline[j] = newLine++;\r\n            else\r\n                bufline[j] = newLine;\r\n        }\r\n    }\r\n    line = bufline[j];\r\n    column = bufcolumn[j];\r\n}"
}, {
	"Path": "mondrian.tui.MockServletContext.getServerInfo",
	"Comment": "returns the name and version of the servlet container on which theservlet is running.",
	"Method": "String getServerInfo(){\r\n    return null;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Link.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Link appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteProgram.bindAllArgsAsStrings",
	"Comment": "given an array of string bindargs, this method binds all of them in one single call.",
	"Method": "void bindAllArgsAsStrings(String[] bindArgs){\r\n    if (bindArgs != null) {\r\n        for (int i = bindArgs.length; i != 0; i--) {\r\n            bindString(i, bindArgs[i - 1]);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunTableImpl.makeResolverKey",
	"Comment": "creates a key to look up an operator in the resolver map. the keyconsists of the uppercase function name and the syntax.",
	"Method": "Pair<String, Syntax> makeResolverKey(String name,Syntax syntax){\r\n    return new Pair<String, Syntax>(name.toUpperCase(), syntax);\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunctionTest.assertExprCompilesTo",
	"Comment": "compiles a scalar expression, and asserts that the program looks asexpected.",
	"Method": "void assertExprCompilesTo(String expr,String expectedCalc){\r\n    final String actualCalc = getTestContext().compileExpression(expr, true);\r\n    final int expDeps = MondrianProperties.instance().TestExpDependencies.get();\r\n    if (expDeps > 0) {\r\n        return;\r\n    }\r\n    TestContext.assertStubbedEqualsVerbose(expectedCalc, actualCalc);\r\n}"
}, {
	"Path": "mondrian.rolap.RolapUtil.locusSchemaReader",
	"Comment": "wraps a schema reader in a proxy so that each call to schema readerhas a locus for profiling purposes.",
	"Method": "SchemaReader locusSchemaReader(RolapConnection connection,SchemaReader schemaReader){\r\n    final Statement statement = connection.getInternalStatement();\r\n    final Execution execution = new Execution(statement, 0);\r\n    final Locus locus = new Locus(execution, \"Schema reader\", null);\r\n    return (SchemaReader) Proxy.newProxyInstance(SchemaReader.class.getClassLoader(), new Class[] { SchemaReader.class }, new InvocationHandler() {\r\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n            Locus.push(locus);\r\n            try {\r\n                return method.invoke(schemaReader, args);\r\n            } catch (InvocationTargetException e) {\r\n                throw e.getCause();\r\n            } finally {\r\n                Locus.pop(locus);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "mondrian.rolap.RolapUtil.locusSchemaReader",
	"Comment": "wraps a schema reader in a proxy so that each call to schema readerhas a locus for profiling purposes.",
	"Method": "SchemaReader locusSchemaReader(RolapConnection connection,SchemaReader schemaReader){\r\n    Locus.push(locus);\r\n    try {\r\n        return method.invoke(schemaReader, args);\r\n    } catch (InvocationTargetException e) {\r\n        throw e.getCause();\r\n    } finally {\r\n        Locus.pop(locus);\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AbstractQuerySpec.isOrdered",
	"Comment": "whether to add an order by clause to make results deterministic.necessary if query returns more than one row and results are forhuman consumption.",
	"Method": "boolean isOrdered(){\r\n    return false;\r\n}"
}, {
	"Path": "mondrian.rolap.sql.CrossJoinArgFactory.checkFilterPredicateInIs",
	"Comment": "check whether the predicate is an in or is predicate and can benatively evaluated.",
	"Method": "CrossJoinArg[] checkFilterPredicateInIs(RolapEvaluator evaluator,ResolvedFunCall predicateCall,boolean exclude){\r\n    final boolean useIs;\r\n    if (predicateCall.getFunName().equals(\"IS\")) {\r\n        useIs = true;\r\n    } else if (predicateCall.getFunName().equals(\"IN\")) {\r\n        useIs = false;\r\n    } else {\r\n        return null;\r\n    }\r\n    Exp[] predArgs = predicateCall.getArgs();\r\n    if (predArgs.length != 2) {\r\n        return null;\r\n    }\r\n    if (!(predArgs[0] instanceof ResolvedFunCall)) {\r\n        return null;\r\n    }\r\n    ResolvedFunCall predFirstArgCall = (ResolvedFunCall) predArgs[0];\r\n    if (predFirstArgCall.getFunDef().getName().equals(\"Ancestor\")) {\r\n        Exp[] ancestorArgs = predFirstArgCall.getArgs();\r\n        if (!(ancestorArgs[0] instanceof ResolvedFunCall)) {\r\n            return null;\r\n        }\r\n        predFirstArgCall = (ResolvedFunCall) ancestorArgs[0];\r\n    }\r\n    FunDef predFirstArgFun = predFirstArgCall.getFunDef();\r\n    if (!predFirstArgFun.getName().equals(\"CurrentMember\")) {\r\n        return null;\r\n    }\r\n    Exp currentMemberArg = predFirstArgCall.getArg(0);\r\n    Type currentMemberArgType = currentMemberArg.getType();\r\n    if (!(currentMemberArgType instanceof mondrian.olap.type.DimensionType || currentMemberArgType instanceof HierarchyType)) {\r\n        return null;\r\n    }\r\n    Exp predSecondArg = predArgs[1];\r\n    Exp[] predSecondArgList;\r\n    FunDef predSecondArgFun;\r\n    CrossJoinArg[] predCJArgs;\r\n    if (useIs) {\r\n        if (!(predSecondArg instanceof MemberExpr)) {\r\n            return null;\r\n        }\r\n        predSecondArgFun = null;\r\n        predSecondArgList = new Exp[] { predSecondArg };\r\n    } else {\r\n        if (predSecondArg instanceof NamedSetExpr) {\r\n            NamedSet namedSet = ((NamedSetExpr) predSecondArg).getNamedSet();\r\n            predSecondArg = namedSet.getExp();\r\n        }\r\n        if (!(predSecondArg instanceof ResolvedFunCall)) {\r\n            return null;\r\n        }\r\n        ResolvedFunCall predSecondArgCall = (ResolvedFunCall) predSecondArg;\r\n        predSecondArgFun = predSecondArgCall.getFunDef();\r\n        predSecondArgList = predSecondArgCall.getArgs();\r\n    }\r\n    predCJArgs = checkEnumeration(evaluator, predSecondArgFun, predSecondArgList, exclude);\r\n    return predCJArgs;\r\n}"
}, {
	"Path": "org.mapsforge.core.model.LatLong.getLongitudeE6",
	"Comment": "returns the longitude value in microdegrees of this coordinate.",
	"Method": "int getLongitudeE6(){\r\n    return LatLongUtils.degreesToMicrodegrees(this.longitude);\r\n}"
}, {
	"Path": "mondrian.test.CompoundSlicerTest.testEmptySetSlicerReturnsNull",
	"Comment": "tests that if the slicer contains zero members, all cells are null.",
	"Method": "void testEmptySetSlicerReturnsNull(){\r\n    assertQueryReturns(\"select [Measures].[Unit Sales] on 0,\\n\" + \"[Product].Children on 1\\n\" + \"from [Sales]\\n\" + \"where {}\", \"Axis #0:\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Product].[Drink]}\\n\" + \"{[Product].[Food]}\\n\" + \"{[Product].[Non-Consumable]}\\n\" + \"Row #0: \\n\" + \"Row #1: \\n\" + \"Row #2: \\n\");\r\n}"
}, {
	"Path": "mondrian.tui.MockServletContext.getMajorVersion",
	"Comment": "returns the major version of the java servlet api that this servletcontainer supports.",
	"Method": "int getMajorVersion(){\r\n    return this.majorVersion;\r\n}"
}, {
	"Path": "mondrian.rolap.TestAggregationManager.testNoNullPtrInCellRequest",
	"Comment": "this test case tests for a null pointer that was being throwninside of cellrequest.",
	"Method": "void testNoNullPtrInCellRequest(){\r\n    TestContext testContext = TestContext.instance().createSubstitutingCube(\"Sales\", \"<Dimension name=\\\"Store2\\\" foreignKey=\\\"store_id\\\">\\n\" + \"  <Hierarchy hasAll=\\\"true\\\" primaryKey=\\\"store_id\\\" allMemberName=\\\"All Stores\\\">\" + \"    <Table name=\\\"store\\\"/>\\n\" + \"    <Level name=\\\"Store Country\\\" column=\\\"store_country\\\" uniqueMembers=\\\"true\\\"/>\\n\" + \"    <Level name=\\\"Store State\\\"   column=\\\"store_state\\\"   uniqueMembers=\\\"true\\\"/>\\n\" + \"    <Level name=\\\"Store City\\\"    column=\\\"store_city\\\"    uniqueMembers=\\\"false\\\"/>\\n\" + \"    <Level name=\\\"Store Type\\\"    column=\\\"store_type\\\"    uniqueMembers=\\\"false\\\"/>\\n\" + \"    <Level name=\\\"Store Name\\\"    column=\\\"store_name\\\"    uniqueMembers=\\\"true\\\"/>\\n\" + \"  <\/Hierarchy>\\n\" + \"<\/Dimension>\");\r\n    testContext.assertQueryReturns(\"select {[Measures].[Unit Sales]} on columns, \" + \"Filter ({ \" + \"[Store2].[All Stores].[USA].[CA].[Beverly Hills], \" + \"[Store2].[All Stores].[USA].[CA].[Beverly Hills].[Gourmet Supermarket] \" + \"},[Measures].[Unit Sales] > 0) on rows \" + \"from [Sales] \" + \"where [Store Type].[Store Type].[Small Grocery]\", \"Axis #0:\\n\" + \"{[Store Type].[Small Grocery]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\");\r\n}"
}, {
	"Path": "org.mapsforge.map.layer.renderer.WayDecorator.renderText",
	"Comment": "finds the segments of a line along which a name can be drawn and then adds waytextcontainersto the list of drawable items.",
	"Method": "void renderText(Tile upperLeft,Tile lowerRight,String text,Display display,int priority,float dy,Paint fill,Paint stroke,boolean repeat,float repeatGap,float repeatStart,boolean rotate,Point[][] coordinates,List<MapElementContainer> currentLabels){\r\n    int wayNameWidth = (stroke == null) ? fill.getTextWidth(text) + (int) repeatStart : stroke.getTextWidth(text) + (int) repeatStart;\r\n    double textHeight = (stroke == null) ? fill.getTextHeight(text) : stroke.getTextHeight(text);\r\n    final Rectangle tileBoundary = Tile.getBoundaryAbsolute(upperLeft, lowerRight);\r\n    int skipPixels = 0;\r\n    Point[] c;\r\n    if (dy == 0f) {\r\n        c = coordinates[0];\r\n    } else {\r\n        c = RendererUtils.parallelPath(coordinates[0], dy);\r\n    }\r\n    for (int i = 1; i < c.length; ++i) {\r\n        LineSegment currentSegment = new LineSegment(c[i - 1], c[i]);\r\n        double currentLength = currentSegment.length();\r\n        skipPixels -= currentLength;\r\n        if (skipPixels > 0) {\r\n            continue;\r\n        }\r\n        if (currentLength < wayNameWidth) {\r\n            continue;\r\n        }\r\n        LineSegment drawableSegment = currentSegment.clipToRectangle(tileBoundary);\r\n        if (drawableSegment == null) {\r\n            continue;\r\n        }\r\n        double segmentLengthInPixel = drawableSegment.length();\r\n        if (segmentLengthInPixel < wayNameWidth) {\r\n            continue;\r\n        }\r\n        double offset = (segmentLengthInPixel - wayNameWidth) / 2d;\r\n        LineSegment actuallyUsedSegment = drawableSegment.subSegment(offset + repeatStart / 2, wayNameWidth - repeatStart);\r\n        if (actuallyUsedSegment.start.x <= actuallyUsedSegment.end.x) {\r\n            currentLabels.add(new WayTextContainer(actuallyUsedSegment.start, actuallyUsedSegment.end, display, priority, text, fill, stroke, textHeight));\r\n        } else {\r\n            currentLabels.add(new WayTextContainer(actuallyUsedSegment.end, actuallyUsedSegment.start, display, priority, text, fill, stroke, textHeight));\r\n        }\r\n        if (!repeat) {\r\n            break;\r\n        }\r\n        skipPixels = (int) repeatGap;\r\n    }\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.isDbLockedByOtherThreads",
	"Comment": "always returns false.there is no longer the concept of a database lock, so this method always returns false.",
	"Method": "boolean isDbLockedByOtherThreads(){\r\n    return false;\r\n}"
}, {
	"Path": "mondrian.olap.MemberBase.getExpression",
	"Comment": "returns the expression by which this member is calculated. the expressionis not null if and only if the member is not calculated.",
	"Method": "Exp getExpression(){\r\n    return null;\r\n}"
}, {
	"Path": "org.mapsforge.map.model.DisplayModel.getDefaultUserScaleFactor",
	"Comment": "get the default scale factor for all newly created displaymodels.",
	"Method": "float getDefaultUserScaleFactor(){\r\n    return defaultUserScaleFactor;\r\n}"
}, {
	"Path": "mondrian.test.TestContext.compileExpression",
	"Comment": "compiles a scalar expression in the context of the default cube.",
	"Method": "String compileExpression(String expression,boolean scalar){\r\n    String cubeName = getDefaultCubeName();\r\n    if (cubeName.indexOf(' ') >= 0) {\r\n        cubeName = Util.quoteMdxIdentifier(cubeName);\r\n    }\r\n    final String queryString;\r\n    if (scalar) {\r\n        queryString = \"with member [Measures].[Foo] as \" + Util.singleQuoteString(expression) + \" select {[Measures].[Foo]} on columns from \" + cubeName;\r\n    } else {\r\n        queryString = \"SELECT {\" + expression + \"} ON COLUMNS FROM \" + cubeName;\r\n    }\r\n    Connection connection = getConnection();\r\n    Query query = connection.parseQuery(queryString);\r\n    final Exp exp;\r\n    if (scalar) {\r\n        exp = query.getFormulas()[0].getExpression();\r\n    } else {\r\n        exp = query.getAxes()[0].getSet();\r\n    }\r\n    final Calc calc = query.compileExpression(exp, scalar, null);\r\n    final StringWriter sw = new StringWriter();\r\n    final PrintWriter pw = new PrintWriter(sw);\r\n    final CalcWriter calcWriter = new CalcWriter(pw, false);\r\n    calc.accept(calcWriter);\r\n    pw.flush();\r\n    return sw.toString();\r\n}"
}, {
	"Path": "mondrian.olap.Util.canCast",
	"Comment": "returns whether it is safe to cast a collection to a collection with agiven element type.",
	"Method": "boolean canCast(Collection<?> collection,Class<T> clazz){\r\n    for (Object o : collection) {\r\n        if (o != null && !clazz.isInstance(o)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.widget.IcsLinearLayout.setShowDividers",
	"Comment": "set how dividers should be shown between items in this layout",
	"Method": "void setShowDividers(int showDividers){\r\n    if (showDividers != mShowDividers) {\r\n        requestLayout();\r\n        invalidate();\r\n    }\r\n    mShowDividers = showDividers;\r\n}"
}, {
	"Path": "org.mapsforge.map.android.util.AndroidUtil.setMapScaleBar",
	"Comment": "sets the scale bar on a map view with implicit arguments.if no distance unit adapters aresupplied, there will be no scalebar, with only a primary adapter supplied, the mode willbe single, with two adapters supplied, the mode will be dual.",
	"Method": "void setMapScaleBar(MapView mapView,DistanceUnitAdapter primaryDistanceUnitAdapter,DistanceUnitAdapter secondaryDistanceUnitAdapter){\r\n    if (null == primaryDistanceUnitAdapter && null == secondaryDistanceUnitAdapter) {\r\n        mapView.setMapScaleBar(null);\r\n    } else {\r\n        MapScaleBar scaleBar = mapView.getMapScaleBar();\r\n        if (scaleBar == null) {\r\n            scaleBar = new DefaultMapScaleBar(mapView.getModel().mapViewPosition, mapView.getModel().mapViewDimension, AndroidGraphicFactory.INSTANCE, mapView.getModel().displayModel);\r\n            mapView.setMapScaleBar(scaleBar);\r\n        }\r\n        if (scaleBar instanceof DefaultMapScaleBar) {\r\n            if (null != secondaryDistanceUnitAdapter) {\r\n                ((DefaultMapScaleBar) scaleBar).setScaleBarMode(DefaultMapScaleBar.ScaleBarMode.BOTH);\r\n                ((DefaultMapScaleBar) scaleBar).setSecondaryDistanceUnitAdapter(secondaryDistanceUnitAdapter);\r\n            } else {\r\n                ((DefaultMapScaleBar) scaleBar).setScaleBarMode(DefaultMapScaleBar.ScaleBarMode.SINGLE);\r\n            }\r\n        }\r\n        scaleBar.setDistanceUnitAdapter(primaryDistanceUnitAdapter);\r\n    }\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getHeader",
	"Comment": "returns the value of the specified request header as a string.",
	"Method": "String getHeader(String name){\r\n    List<String> headerList = headers.get(name);\r\n    return ((headerList == null) || (headerList.size() == 0)) ? null : headerList.get(0);\r\n}"
}, {
	"Path": "mondrian.test.SteelWheelsPerformanceTest.getTestContext",
	"Comment": "returns the test context. override this method if you wish to use adifferent source for your foodmart connection.",
	"Method": "TestContext getTestContext(){\r\n    return SteelWheelsTestCase.createContext(TestContext.instance(), null);\r\n}"
}, {
	"Path": "mondrian.test.NativeSetEvaluationTest.assertQuerySql",
	"Comment": "checks that a given mdx query results in a particular sql statementbeing generated.",
	"Method": "void assertQuerySql(String mdxQuery,SqlPattern[] patterns){\r\n    assertQuerySqlOrNot(getTestContext(), mdxQuery, patterns, false, true, true);\r\n}"
}, {
	"Path": "org.msgpack.core.MessagePacker.packByte",
	"Comment": "writes an integer value.this method writes an integer using the smallest format from the int format family.",
	"Method": "MessagePacker packByte(byte b){\r\n    if (b < -(1 << 5)) {\r\n        writeByteAndByte(INT8, b);\r\n    } else {\r\n        writeByte(b);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.mapsforge.map.android.graphics.AndroidGraphicFactory.getBytesPerPixel",
	"Comment": "return the byte usage per pixel of a bitmap based on its configuration.",
	"Method": "int getBytesPerPixel(Config config){\r\n    if (config == Config.ARGB_8888) {\r\n        return 4;\r\n    } else if (config == Config.RGB_565) {\r\n        return 2;\r\n    } else if (config == Config.ARGB_4444) {\r\n        return 2;\r\n    } else if (config == Config.ALPHA_8) {\r\n        return 1;\r\n    }\r\n    return 1;\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.setInitConn",
	"Comment": "sets the initial number of connections per server in the available pool.",
	"Method": "void setInitConn(int initConn){\r\n    this.initConn = initConn;\r\n}"
}, {
	"Path": "org.mapsforge.map.awt.graphics.AwtPaint.setBitmapShaderShift",
	"Comment": "shifts the bitmap pattern so that it will always start at a multiple ofitself for any tile the pattern is used. this ensures that regardless ofsize of the pattern it tiles correctly.",
	"Method": "void setBitmapShaderShift(Point origin){\r\n    if (this.texturePaint != null) {\r\n        int relativeDx = ((int) -origin.x) % this.shaderWidth;\r\n        int relativeDy = ((int) -origin.y) % this.shaderHeight;\r\n        Rectangle rectangle = new Rectangle(relativeDx, relativeDy, this.shaderWidth, this.shaderHeight);\r\n        this.texturePaint = new TexturePaint(this.texturePaint.getImage(), rectangle);\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCube.setMeasuresHierarchyMemberReader",
	"Comment": "makes sure that the schemareader cache is invalidated.problems can occur if the measure hierarchy member reader is outof sync with the cache.",
	"Method": "void setMeasuresHierarchyMemberReader(MemberReader memberReader){\r\n    this.measuresHierarchy.setMemberReader(memberReader);\r\n    this.schemaReader = null;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapNamedSetEvaluator.ensureList",
	"Comment": "evaluates and saves the value of this named set, if it has not beenevaluated already.",
	"Method": "void ensureList(Evaluator evaluator){\r\n    if (list != null) {\r\n        if (list == DUMMY_LIST) {\r\n            recursionCount++;\r\n            if (RECURSION_TOLERANCE > 0 && recursionCount > RECURSION_TOLERANCE) {\r\n                throw rrer.result.slicerEvaluator.newEvalException(null, \"Illegal attempt to reference value of named set '\" + namedSet.getName() + \"' while evaluating itself\");\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    if (RolapResult.LOGGER.isDebugEnabled()) {\r\n        RolapResult.LOGGER.debug(\"Named set \" + namedSet.getName() + \": starting evaluation\");\r\n    }\r\n    list = DUMMY_LIST;\r\n    try {\r\n        final Calc calc = rrer.getCompiled(namedSet.getExp(), false, ResultStyle.ITERABLE);\r\n        TupleIterable iterable = (TupleIterable) rrer.result.evaluateExp(calc, rrer.result.slicerEvaluator, evaluator);\r\n        final TupleList rawList;\r\n        if (iterable instanceof TupleList) {\r\n            rawList = (TupleList) iterable;\r\n        } else {\r\n            rawList = TupleCollections.createList(iterable.getArity());\r\n            TupleCursor cursor = iterable.tupleCursor();\r\n            while (cursor.forward()) {\r\n                rawList.addCurrent(cursor);\r\n            }\r\n        }\r\n        if (RolapResult.LOGGER.isDebugEnabled()) {\r\n            RolapResult.LOGGER.debug(generateDebugMessage(calc, rawList));\r\n        }\r\n        this.list = rawList.withPositionCallback(this);\r\n    } finally {\r\n        if (this.list == DUMMY_LIST) {\r\n            this.list = null;\r\n        }\r\n        recursionCount = 0;\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.ExplicitRecognizer.getFactCountMatcher",
	"Comment": "get the matcher to be used to match the column which is the fact countcolumn.",
	"Method": "Recognizer.Matcher getFactCountMatcher(){\r\n    return getTableDef().getFactCountMatcher();\r\n}"
}, {
	"Path": "app.rest.client.com.oath.micro.server.RestClientTest.testCRUDSpring",
	"Comment": "more complex with spring rest template based nioresttemplate",
	"Method": "void testCRUDSpring(){\r\n    assertThat(rest.getForEntity(new URI(\"http://localhost:8080/rest-app/rest/get\"), List.class).get().getBody().get(0), is(\"ok\"));\r\n    assertThat(rest.postForEntity(\"http://localhost:8080/rest-app/rest/post\", new HttpEntity(ImmutableMap.of(1, \"hello\")), ImmutableSet.class).get().getBody(), is(ImmutableSet.of(\"hello\")));\r\n    assertThat(rest.put(\"http://localhost:8080/rest-app/rest/put\", new HttpEntity(ImmutableMap.of(1, \"hello\")), ImmutableSet.class).get(), is(nullValue()));\r\n    assertThat(rest.delete(\"http://localhost:8080/rest-app/rest/delete\").get(), is(nullValue()));\r\n}"
}, {
	"Path": "mondrian.test.TestContext.substituteSchema",
	"Comment": "returns a the xml of the foodmart schema, adding dimension definitionsto the definition of a given cube.",
	"Method": "String substituteSchema(String rawSchema,String cubeName,String dimensionDefs,String measureDefs,String memberDefs,String namedSetDefs,String defaultMeasure){\r\n    String s = rawSchema;\r\n    int h = s.indexOf(\"<Cube name=\\\"\" + cubeName + \"\\\"\");\r\n    int end;\r\n    if (h < 0) {\r\n        h = s.indexOf(\"<Cube name='\" + cubeName + \"'\");\r\n    }\r\n    if (h < 0) {\r\n        h = s.indexOf(\"<VirtualCube name=\\\"\" + cubeName + \"\\\"\");\r\n        if (h < 0) {\r\n            h = s.indexOf(\"<VirtualCube name='\" + cubeName + \"'\");\r\n        }\r\n        if (h < 0) {\r\n            throw new RuntimeException(\"cube '\" + cubeName + \"' not found\");\r\n        } else {\r\n            end = s.indexOf(\"<\/VirtualCube\", h);\r\n        }\r\n    } else {\r\n        end = s.indexOf(\"<\/Cube>\", h);\r\n    }\r\n    if (dimensionDefs != null) {\r\n        int i = s.indexOf(\"<Dimension \", h);\r\n        s = s.substring(0, i) + dimensionDefs + s.substring(i);\r\n    }\r\n    if (measureDefs != null) {\r\n        int i = s.indexOf(\"<Measure\", h);\r\n        if (i < 0 || i > end) {\r\n            i = end;\r\n        }\r\n        s = s.substring(0, i) + measureDefs + s.substring(i);\r\n        if (i == end) {\r\n            i = s.indexOf(\"<VirtualCubeMeasure\", h);\r\n            if (i < 0 || i > end) {\r\n                i = end;\r\n            }\r\n            s = s.substring(0, i) + measureDefs + s.substring(i);\r\n        }\r\n    }\r\n    if (memberDefs != null) {\r\n        int i = s.indexOf(\"<CalculatedMember\", h);\r\n        if (i < 0 || i > end) {\r\n            i = end;\r\n        }\r\n        s = s.substring(0, i) + memberDefs + s.substring(i);\r\n    }\r\n    if (namedSetDefs != null) {\r\n        int i = s.indexOf(\"<NamedSet\", h);\r\n        if (i < 0 || i > end) {\r\n            i = end;\r\n        }\r\n        s = s.substring(0, i) + namedSetDefs + s.substring(i);\r\n    }\r\n    if (defaultMeasure != null) {\r\n        s = s.replaceFirst(\"(\" + cubeName + \".*)defaultMeasure=\\\"[^\\\"]*\\\"\", \"$1defaultMeasure=\\\"\" + defaultMeasure + \"\\\"\");\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentLoader.loadDataToDataSets",
	"Comment": "loads data to the datasets. if the grouping sets is used,dataset is fetched from groupingdatasetmap using grouping bit keys ofthe row data. if grouping sets is not used, data is loaded on tonongroupingdatasets.",
	"Method": "void loadDataToDataSets(GroupingSetsList groupingSetsList,RowList rows,Map<BitKey, GroupingSetsList.Cohort> groupingDataSetMap){\r\n    int arity = groupingSetsList.getDefaultColumns().length;\r\n    SegmentAxis[] axes = groupingSetsList.getDefaultAxes();\r\n    int segmentLength = groupingSetsList.getDefaultSegments().size();\r\n    final List<SqlStatement.Type> types = rows.getTypes();\r\n    final boolean useGroupingSet = groupingSetsList.useGroupingSets();\r\n    for (rows.first(); rows.next(); ) {\r\n        final BitKey groupingBitKey;\r\n        final GroupingSetsList.Cohort cohort;\r\n        if (useGroupingSet) {\r\n            groupingBitKey = (BitKey) rows.getObject(groupingSetsList.getGroupingBitKeyIndex());\r\n            cohort = groupingDataSetMap.get(groupingBitKey);\r\n        } else {\r\n            groupingBitKey = null;\r\n            cohort = groupingDataSetMap.get(BitKey.EMPTY);\r\n        }\r\n        final int[] pos = cohort.pos;\r\n        for (int j = 0, k = 0; j < arity; j++) {\r\n            final SqlStatement.Type type = types.get(j);\r\n            switch(type) {\r\n                case OBJECT:\r\n                case STRING:\r\n                case INT:\r\n                case LONG:\r\n                case DOUBLE:\r\n                    Object o = rows.getObject(j);\r\n                    if (useGroupingSet && (o == null || o == RolapUtil.sqlNullValue) && groupingBitKey.get(groupingSetsList.findGroupingFunctionIndex(j))) {\r\n                        continue;\r\n                    }\r\n                    SegmentAxis axis = axes[j];\r\n                    if (o == null) {\r\n                        o = RolapUtil.sqlNullValue;\r\n                    }\r\n                    int offset = axis.getOffset((Comparable) o);\r\n                    pos[k++] = offset;\r\n                    break;\r\n                default:\r\n                    throw Util.unexpected(type);\r\n            }\r\n        }\r\n        for (int j = 0; j < segmentLength; j++) {\r\n            cohort.segmentDatasetList.get(j).populateFrom(pos, rows, arity + j);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.loader.DBLoader.quoteId",
	"Comment": "quote the given sql identifier suitable for the output dbms.",
	"Method": "String quoteId(String name){\r\n    return this.dialect.quoteIdentifier(name);\r\n}"
}, {
	"Path": "mondrian.test.AccessControlTest.testRollupPolicyGreatGrandchildInvisible",
	"Comment": "tests where all children are visible but a grandchild is not.",
	"Method": "void testRollupPolicyGreatGrandchildInvisible(){\r\n    rollupPolicyGreatGrandchildInvisible(Role.RollupPolicy.FULL, \"266,773\", \"74,748\");\r\n    rollupPolicyGreatGrandchildInvisible(Role.RollupPolicy.PARTIAL, \"266,767\", \"74,742\");\r\n    rollupPolicyGreatGrandchildInvisible(Role.RollupPolicy.HIDDEN, \"\", \"\");\r\n}"
}, {
	"Path": "mondrian.test.SchemaTest.testDimensionsShareTableSameForeignKeys",
	"Comment": "tests two dimensions using same table with same foreign keyone table uses an alias.",
	"Method": "void testDimensionsShareTableSameForeignKeys(){\r\n    TestContext testContext = TestContext.instance().createSubstitutingCube(\"Sales\", \"<Dimension name=\\\"Yearly Income2\\\" foreignKey=\\\"customer_id\\\">\\n\" + \"  <Hierarchy hasAll=\\\"true\\\" primaryKey=\\\"customer_id\\\">\\n\" + \"    <Table name=\\\"customer\\\" alias=\\\"customerx\\\" />\\n\" + \"    <Level name=\\\"Yearly Income\\\" column=\\\"yearly_income\\\" uniqueMembers=\\\"true\\\"/>\\n\" + \"  <\/Hierarchy>\\n\" + \"<\/Dimension>\");\r\n    testContext.assertQueryReturns(\"select {[Yearly Income].[$10K - $30K]} on columns,\" + \"{[Yearly Income2].[$150K +]} on rows from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Yearly Income].[$10K - $30K]}\\n\" + \"Axis #2:\\n\" + \"{[Yearly Income2].[$150K +]}\\n\" + \"Row #0: \\n\");\r\n    testContext.assertQueryReturns(\"select NON EMPTY {[Measures].[Unit Sales]} ON COLUMNS,\\n\" + \"NON EMPTY Crossjoin({[Yearly Income].[All Yearly Incomes].Children},\\n\" + \"                     [Yearly Income2].[All Yearly Income2s].Children) ON ROWS\\n\" + \"from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Yearly Income].[$10K - $30K], [Yearly Income2].[$10K - $30K]}\\n\" + \"{[Yearly Income].[$110K - $130K], [Yearly Income2].[$110K - $130K]}\\n\" + \"{[Yearly Income].[$130K - $150K], [Yearly Income2].[$130K - $150K]}\\n\" + \"{[Yearly Income].[$150K +], [Yearly Income2].[$150K +]}\\n\" + \"{[Yearly Income].[$30K - $50K], [Yearly Income2].[$30K - $50K]}\\n\" + \"{[Yearly Income].[$50K - $70K], [Yearly Income2].[$50K - $70K]}\\n\" + \"{[Yearly Income].[$70K - $90K], [Yearly Income2].[$70K - $90K]}\\n\" + \"{[Yearly Income].[$90K - $110K], [Yearly Income2].[$90K - $110K]}\\n\" + \"Row #0: 57,950\\n\" + \"Row #1: 11,561\\n\" + \"Row #2: 14,392\\n\" + \"Row #3: 5,629\\n\" + \"Row #4: 87,310\\n\" + \"Row #5: 44,967\\n\" + \"Row #6: 33,045\\n\" + \"Row #7: 11,919\\n\");\r\n}"
}, {
	"Path": "org.msgpack.core.buffer.MessageBuffer.newMessageBuffer",
	"Comment": "creates a new messagebuffer instance backed by a java heap array",
	"Method": "MessageBuffer newMessageBuffer(byte[] arr,int off,int len,MessageBuffer newMessageBuffer,ByteBuffer bb){\r\n    checkNotNull(bb);\r\n    if (mbBBConstructor != null) {\r\n        return newInstance(mbBBConstructor, bb);\r\n    }\r\n    return new MessageBuffer(bb);\r\n}"
}, {
	"Path": "mondrian.rolap.RolapEvaluator.getSlicerMembers",
	"Comment": "return the list of slicer members in the current evaluator context.",
	"Method": "List<Member> getSlicerMembers(){\r\n    return slicerMembers;\r\n}"
}, {
	"Path": "mondrian.util.ObjectFactory.getClassName",
	"Comment": "returns the name of a class to use to create an object.the default implementation returns null but derivedclasses can return a class name.this method is the primary mechanism for supporting unit testing.a derived class can have, as an example, this method returnthe value of a threadlocal. for testing itreturn a class name while for normal use it returns null.",
	"Method": "String getClassName(String getClassName,Properties props){\r\n    final StringProperty stringProp = getStringProperty();\r\n    final String className = stringProp.get();\r\n    return (className != null) ? className : (props == null) ? null : props.getProperty(stringProp.getPath());\r\n}"
}, {
	"Path": "mondrian.gui.JdbcTreeModel.getRoot",
	"Comment": "returns the root of the tree.returns nullonly if the tree has no nodes.",
	"Method": "Object getRoot(){\r\n    return root;\r\n}"
}, {
	"Path": "mondrian.util.SlotFuture.put",
	"Comment": "writes a value into the slot, indicating that the task has completedsuccessfully.",
	"Method": "void put(V value){\r\n    stateLock.writeLock().lock();\r\n    try {\r\n        if (done) {\r\n            final String message = \"Future is already done (cancelled=\" + cancelled + \", value=\" + this.value + \", throwable=\" + throwable + \")\";\r\n            LOG.error(message);\r\n            throw new IllegalArgumentException(message);\r\n        }\r\n        this.value = value;\r\n        this.done = true;\r\n    } finally {\r\n        stateLock.writeLock().unlock();\r\n    }\r\n    dataGate.countDown();\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlTest.assertCacheStateEquals",
	"Comment": "asserts that a cache state string is equal to an expected cache state,after segment ids have been masked out.",
	"Method": "void assertCacheStateEquals(String tag,String expected,String actual){\r\n    String expected2 = expected.replaceAll(\"Segment #[0-9]+\", \"Segment ##\");\r\n    String actual2 = actual.replaceAll(\"Segment #[0-9]+\", \"Segment ##\");\r\n    actual2 = actual2.replaceAll(\"(?m)^Checksum:.*(?:\\\\r?\\\\n)?\", \"\");\r\n    actual2 = actual2.replaceAll(\"(?m)^ID:.*(?:\\\\r?\\\\n)?\", \"\");\r\n    getDiffRepos().assertEquals(tag, expected2, actual2);\r\n}"
}, {
	"Path": "mondrian.test.PerformanceTest.testBigResultsWithBigSchemaPerforms",
	"Comment": "tests performance of a larger schema with a large number of result cells.runs in 186 seconds without nonallpositions array in rolapevaluator.runs in 14 seconds when rolapevaluator.getproperty uses getnonallmembers.the performance boost gets more significant as the schema size grows.",
	"Method": "void testBigResultsWithBigSchemaPerforms(){\r\n    if (!LOGGER.isDebugEnabled()) {\r\n        return;\r\n    }\r\n    TestContext testContext = TestContext.instance().createSubstitutingCube(\"Sales\", TestContext.repeatString(1000, \"<Dimension name=\\\"Gender%d \\\" foreignKey=\\\"customer_id\\\">\" + \"  <Hierarchy hasAll=\\\"true\\\" allMemberName=\\\"All Gender\\\" primaryKey=\\\"customer_id\\\">\" + \"    <Table name=\\\"customer\\\"/>\" + \"    <Level name=\\\"Gender\\\" column=\\\"gender\\\" uniqueMembers=\\\"true\\\"/>\" + \"  <\/Hierarchy>\" + \"<\/Dimension>\"), null);\r\n    String mdx = \"with \" + \" member [Measures].[one] as '1'\" + \" member [Measures].[two] as '2'\" + \" member [Measures].[three] as '3'\" + \" member [Measures].[four] as '4'\" + \" member [Measures].[five] as '5'\" + \" select \" + \"{[Measures].[one],[Measures].[two],[Measures].[three],[Measures].[four],[Measures].[five]}\" + \" on 0, \" + \"Crossjoin([Customers].[name].members,[Store].[Store Name].members)\" + \" on 1 from sales\";\r\n    long start = System.currentTimeMillis();\r\n    testContext.executeQuery(mdx);\r\n    printDuration(\"testBigResultsWithBigSchemaPerforms\", start);\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletResponse.getCharacterEncoding",
	"Comment": "returns the name of the charset used for the mime body sent in thisresponse.",
	"Method": "String getCharacterEncoding(){\r\n    return charEncoding;\r\n}"
}, {
	"Path": "mondrian.olap.fun.vba.Excel.mod",
	"Comment": "the mod function. not technically in the excel package, but this seemedlike a good place to put it, since excel has a mod function.",
	"Method": "double mod(Object first,Object second){\r\n    double iFirst;\r\n    if (!(first instanceof Number)) {\r\n        throw new InvalidArgumentException(\"Invalid parameter. \" + \"first parameter \" + first + \" of Mod function must be of type number\");\r\n    } else {\r\n        iFirst = ((Number) first).doubleValue();\r\n    }\r\n    double iSecond;\r\n    if (!(second instanceof Number)) {\r\n        throw new InvalidArgumentException(\"Invalid parameter. \" + \"second parameter \" + second + \" of Mod function must be of type number\");\r\n    } else {\r\n        iSecond = ((Number) second).doubleValue();\r\n    }\r\n    if (iSecond == 0) {\r\n        throw new ArithmeticException(\"/ by zero\");\r\n    }\r\n    return iFirst - iSecond * Vba.intNative(iFirst / iSecond);\r\n}"
}, {
	"Path": "mondrian.tui.MockServletContext.getResource",
	"Comment": "returns a url to the resource that is mapped to a specified path.",
	"Method": "URL getResource(String name){\r\n    if (!resources.containsKey(name)) {\r\n        addResource(name, new URL(\"file://\" + name));\r\n    }\r\n    return resources.get(name);\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getServerName",
	"Comment": "returns the host name of the server that received the request.",
	"Method": "String getServerName(){\r\n    return serverName;\r\n}"
}, {
	"Path": "org.msgpack.core.Preconditions.checkNotNull",
	"Comment": "ensures that an object reference passed as a parameter to the callingmethod is not null.",
	"Method": "T checkNotNull(T reference,T checkNotNull,T reference,Object errorMessage,T checkNotNull,T reference,String errorMessageTemplate,Object errorMessageArgs){\r\n    if (reference == null) {\r\n        throw new NullPointerException(format(errorMessageTemplate, errorMessageArgs));\r\n    }\r\n    return reference;\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getPathInfo",
	"Comment": "returns any extra path information associated with the url the clientsent when it made this request.",
	"Method": "String getPathInfo(){\r\n    return pathInfo;\r\n}"
}, {
	"Path": "mondrian.test.UdfTest.testUdfToString",
	"Comment": "test case for the problem where a string expression gave aclasscastexception because it was evaluating to a member, whereas themember should have been evaluated to a scalar.",
	"Method": "void testUdfToString(){\r\n    TestContext tc = udfTestContext(\"<UserDefinedFunction name=\\\"StringMult\\\" className=\\\"\" + StringMultUdf.class.getName() + \"\\\"/>\\n\");\r\n    tc.assertQueryReturns(\"with member [Measures].[ABC] as StringMult(1, 'A')\\n\" + \"member [Measures].[Unit Sales Formatted] as\\n\" + \"  [Measures].[Unit Sales],\\n\" + \"  FORMAT_STRING = '#,###|color=' ||\\n\" + \"      Iif([Measures].[ABC] = 'A', 'red', 'green')\\n\" + \"select [Measures].[Unit Sales Formatted] on 0\\n\" + \"from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales Formatted]}\\n\" + \"Row #0: 266,773|color=red\\n\");\r\n}"
}, {
	"Path": "mondrian.util.Bug.olap4jUpgrade",
	"Comment": "if you want to tag a piece of code in mondrian that needs to be changedwhen we upgrade to a future version of olap4j, reference this function.it will always return false.",
	"Method": "boolean olap4jUpgrade(String reason){\r\n    return false;\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.getInitConn",
	"Comment": "returns the current setting for the initial number of connections per server in\tthe available pool.",
	"Method": "int getInitConn(){\r\n    return this.initConn;\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentLoaderTest.testLoadWithWithNullInRollupColumn",
	"Comment": "tests load with mock results for loading summary and detailedsegments with null in rollup column.",
	"Method": "void testLoadWithWithNullInRollupColumn(){\r\n    GroupingSet groupableSetsInfo = getGroupingSetRollupOnGender();\r\n    GroupingSet groupingSetsInfo = getDefaultGroupingSet();\r\n    ArrayList<GroupingSet> groupingSets = new ArrayList<GroupingSet>();\r\n    groupingSets.add(groupingSetsInfo);\r\n    groupingSets.add(groupableSetsInfo);\r\n    SegmentLoader loader = new SegmentLoader(cacheMgr) {\r\n        SqlStatement createExecuteSql(int cellRequestCount, GroupingSetsList groupingSetsList, List<StarPredicate> compoundPredicateList) {\r\n            return new MockSqlStatement(cellRequestCount, groupingSetsList, getDataWithNullInRollupColumn(true));\r\n        }\r\n    };\r\n    final List<Future<Map<Segment, SegmentWithData>>> segmentFutures = new ArrayList<Future<Map<Segment, SegmentWithData>>>();\r\n    loader.load(0, groupingSets, null, segmentFutures);\r\n    SegmentWithData detailedSegment = getFor(segmentFutures, groupingSets.get(0).getSegments().get(0));\r\n    assertEquals(3, detailedSegment.getCellCount());\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentLoaderTest.testLoadWithWithNullInRollupColumn",
	"Comment": "tests load with mock results for loading summary and detailedsegments with null in rollup column.",
	"Method": "void testLoadWithWithNullInRollupColumn(){\r\n    return new MockSqlStatement(cellRequestCount, groupingSetsList, getDataWithNullInRollupColumn(true));\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentCacheManager.externalSegmentCreated",
	"Comment": "tells the cache that a segment is newly available in an external cache.",
	"Method": "void externalSegmentCreated(SegmentHeader header,MondrianServer server){\r\n    if (MondrianProperties.instance().DisableCaching.get()) {\r\n        return;\r\n    }\r\n    ACTOR.event(handler, new ExternalSegmentCreatedEvent(System.currentTimeMillis(), server.getMonitor(), server.getId(), 0, 0, 0, this, header));\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Textarea.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Textarea appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.util.ObjectFactory.removeContext",
	"Comment": "gets the current override values in the opaque context object andclears those values within the factory.this is used in testing.",
	"Method": "Object removeContext(){\r\n    return null;\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.DrawerView.hasOnFixedItemClickListener",
	"Comment": "gets whether the drawer view has a fixed item click listener set to it",
	"Method": "boolean hasOnFixedItemClickListener(){\r\n    return mOnFixedItemClickListener != null;\r\n}"
}, {
	"Path": "mondrian.test.NativeSetEvaluationTest.testAggTCNoExplicitMeasure",
	"Comment": "aggregate with default measure and topcount without measure argument.",
	"Method": "void testAggTCNoExplicitMeasure(){\r\n    propSaver.set(propSaver.properties.GenerateFormattedSql, true);\r\n    final String mdx = \"WITH\\n\" + \"  SET TC AS 'TopCount([Product].[Drink].[Alcoholic Beverages].Children, 3)'\\n\" + \"  MEMBER [Store Type].[Store Type].[Slicer] as Aggregate([Store Type].[Store Type].Members)\\n\" + \"\\n\" + \"  SELECT NON EMPTY [Measures].[Unit Sales] on 0,\\n\" + \"    TC ON 1 \\n\" + \"  FROM [Sales] WHERE [Store Type].[Slicer]\\n\";\r\n    assertQueryReturns(mdx, \"Axis #0:\\n\" + \"{[Store Type].[Slicer]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Product].[Drink].[Alcoholic Beverages].[Beer and Wine]}\\n\" + \"Row #0: 6,838\\n\");\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteConnection.dumpUnsafe",
	"Comment": "dumps debugging information about this connection, in the case where thecaller might not actually own the connection.this function is written so that it may be called by a thread that does notown the connection.we need to be very careful because the connection state isnot synchronized.at worst, the method may return stale or slightly wrong data, howeverit should not crash.this is ok as it is only used for diagnostic purposes.",
	"Method": "void dumpUnsafe(Printer printer,boolean verbose){\r\n    printer.println(\"Connection #\" + mConnectionId + \":\");\r\n    if (verbose) {\r\n        printer.println(\"  connectionPtr: 0x\" + Long.toHexString(mConnectionPtr));\r\n    }\r\n    printer.println(\"  isPrimaryConnection: \" + mIsPrimaryConnection);\r\n    printer.println(\"  onlyAllowReadOnlyOperations: \" + mOnlyAllowReadOnlyOperations);\r\n    mRecentOperations.dump(printer, verbose);\r\n    if (verbose) {\r\n        mPreparedStatementCache.dump(printer);\r\n    }\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.DrawerActivity.hasOnFixedItemClickListener",
	"Comment": "gets whether the drawer has a fixed item click listener set to it",
	"Method": "boolean hasOnFixedItemClickListener(){\r\n    return mOnFixedItemClickListener != null;\r\n}"
}, {
	"Path": "org.springframework.extensions.jcr.support.ServiceSessionHolderProviderManager.getProviders",
	"Comment": "loads the service providers using the discovery mechanism.",
	"Method": "List<SessionHolderProvider> getProviders(){\r\n    final ServiceLoader<SessionHolderProvider> serviceLoader = ServiceLoader.load(SessionHolderProvider.class, Thread.currentThread().getContextClassLoader());\r\n    List<SessionHolderProvider> providers = new ArrayList<SessionHolderProvider>();\r\n    Iterator<SessionHolderProvider> sessionHolderProviderIterator = serviceLoader.iterator();\r\n    while (sessionHolderProviderIterator.hasNext()) {\r\n        providers.add(sessionHolderProviderIterator.next());\r\n    }\r\n    return Collections.unmodifiableList(providers);\r\n}"
}, {
	"Path": "mondrian.test.CompoundSlicerTest.testSlicerContainsNullMember",
	"Comment": "slicer that is a member expression that evaluates to null.ssas 2005 allows this, and returns null cells.",
	"Method": "void testSlicerContainsNullMember(){\r\n    assertQueryReturns(\"select [Measures].[Unit Sales] on 0,\\n\" + \"[Gender].Members on 1\\n\" + \"from [Sales]\\n\" + \"where [Product].Parent\", \"Axis #0:\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[All Gender]}\\n\" + \"{[Gender].[F]}\\n\" + \"{[Gender].[M]}\\n\" + \"Row #0: \\n\" + \"Row #1: \\n\" + \"Row #2: \\n\");\r\n}"
}, {
	"Path": "mondrian.olap.IdBatchResolver.collectChildrenNameSegments",
	"Comment": "filters the children list to those that contain identifierswe think we can batch resolve, then transforms the id listto the corresponding namesegment.",
	"Method": "List<Id.NameSegment> collectChildrenNameSegments(Member parentMember,List<Id> children){\r\n    filter(children, new Predicate() {\r\n        public boolean evaluate(Object theId) {\r\n            Id id = (Id) theId;\r\n            return !Util.matches(parentMember, id.getSegments()) && supportedIdentifier(id);\r\n        }\r\n    });\r\n    return new ArrayList(CollectionUtils.collect(children, new Transformer() {\r\n        public Object transform(Object theId) {\r\n            Id id = (Id) theId;\r\n            return getLastSegment(id);\r\n        }\r\n    }));\r\n}"
}, {
	"Path": "mondrian.olap.IdBatchResolver.collectChildrenNameSegments",
	"Comment": "filters the children list to those that contain identifierswe think we can batch resolve, then transforms the id listto the corresponding namesegment.",
	"Method": "List<Id.NameSegment> collectChildrenNameSegments(Member parentMember,List<Id> children){\r\n    Id id = (Id) theId;\r\n    return !Util.matches(parentMember, id.getSegments()) && supportedIdentifier(id);\r\n}"
}, {
	"Path": "mondrian.olap.IdBatchResolver.collectChildrenNameSegments",
	"Comment": "filters the children list to those that contain identifierswe think we can batch resolve, then transforms the id listto the corresponding namesegment.",
	"Method": "List<Id.NameSegment> collectChildrenNameSegments(Member parentMember,List<Id> children){\r\n    Id id = (Id) theId;\r\n    return getLastSegment(id);\r\n}"
}, {
	"Path": "org.mapsforge.core.util.LatLongUtils.distance",
	"Comment": "calculate the euclidean distance between two latlongs in degrees using the pythagoreantheorem.",
	"Method": "double distance(LatLong latLong1,LatLong latLong2){\r\n    return Math.hypot(latLong1.longitude - latLong2.longitude, latLong1.latitude - latLong2.latitude);\r\n}"
}, {
	"Path": "mondrian.test.ParameterTest.testSchemaPropContext",
	"Comment": "tests that a schema property fails if it references dimensions whichare not available.",
	"Method": "void testSchemaPropContext(){\r\n    final TestContext tc = TestContext.instance().create(\"<Parameter name=\\\"Customer Current Member\\\" type=\\\"Member\\\" defaultValue=\\\"[Customers].DefaultMember.Children.Item(2) \\\" />\", null, null, null, null, null);\r\n    tc.assertQueryReturns(\"with member [Measures].[Foo] as ' ParamRef(\\\"Customer Current Member\\\").Name '\\n\" + \"select {[Measures].[Foo]} on columns\\n\" + \"from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Foo]}\\n\" + \"Row #0: USA\\n\");\r\n    tc.assertQueryThrows(\"with member [Measures].[Foo] as ' ParamRef(\\\"Customer Current Member\\\").Name '\\n\" + \"select {[Measures].[Foo]} on columns\\n\" + \"from [Warehouse]\", \"MDX object '[Customers]' not found in cube 'Warehouse'\");\r\n}"
}, {
	"Path": "mondrian.olap4j.MondrianOlap4jStatement.executeOlapQueryInternal",
	"Comment": "executes a parsed query, closing any previously open cellset.",
	"Method": "CellSet executeOlapQueryInternal(Query query,MondrianOlap4jCellSetMetaData cellSetMetaData){\r\n    synchronized (this) {\r\n        if (openCellSet != null) {\r\n            final MondrianOlap4jCellSet cs = openCellSet;\r\n            openCellSet = null;\r\n            try {\r\n                cs.close();\r\n            } catch (Exception e) {\r\n                throw olap4jConnection.helper.createException(null, \"Error while closing previous CellSet\", e);\r\n            }\r\n        }\r\n        if (olap4jConnection.preferList) {\r\n            query.setResultStyle(ResultStyle.LIST);\r\n        }\r\n        this.query = query;\r\n        openCellSet = olap4jConnection.factory.newCellSet(this);\r\n    }\r\n    try {\r\n        openCellSet.execute();\r\n    } catch (QueryCanceledException e) {\r\n        throw olap4jConnection.helper.createException(\"Query canceled\", e);\r\n    } catch (QueryTimeoutException e) {\r\n        throw olap4jConnection.helper.createException(e.getMessage(), e);\r\n    } catch (MondrianException e) {\r\n        throw olap4jConnection.helper.createException(\"mondrian gave exception while executing query\", e);\r\n    }\r\n    return openCellSet;\r\n}"
}, {
	"Path": "com.oath.micro.server.s3.manifest.comparator.S3ManifestComparator.withKey",
	"Comment": "create a new manifestcomparator with the same distributed map connectionthat targets a different key",
	"Method": "S3ManifestComparator<R> withKey(String key){\r\n    return new S3ManifestComparator(key, reader, writer, deleter, stringWriter);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Area.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Area appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentLoader.createExecuteSql",
	"Comment": "creates and executes a sql statement to retrieve the set of cellsspecified by a groupingsetslist.this method may be overridden in tests.",
	"Method": "SqlStatement createExecuteSql(int cellRequestCount,GroupingSetsList groupingSetsList,List<StarPredicate> compoundPredicateList){\r\n    RolapStar star = groupingSetsList.getStar();\r\n    Pair<String, List<SqlStatement.Type>> pair = AggregationManager.generateSql(groupingSetsList, compoundPredicateList);\r\n    final Locus locus = new SqlStatement.StatementLocus(Locus.peek().execution, \"Segment.load\", \"Error while loading segment\", SqlStatementEvent.Purpose.CELL_SEGMENT, cellRequestCount);\r\n    final Util.Functor1<Void, Statement> callbackWithCaching = new Util.Functor1<Void, Statement>() {\r\n        public Void apply(final Statement stmt) {\r\n            cacheMgr.execute(new SegmentCacheManager.Command<Void>() {\r\n                public Void call() throws Exception {\r\n                    boolean atLeastOneActive = false;\r\n                    for (Segment seg : groupingSetsList.getDefaultSegments()) {\r\n                        final SegmentCacheIndex index = cacheMgr.getIndexRegistry().getIndex(seg.star);\r\n                        if (index.contains(seg.getHeader())) {\r\n                            index.linkSqlStatement(seg.getHeader(), stmt);\r\n                            atLeastOneActive = true;\r\n                        }\r\n                        if (!atLeastOneActive) {\r\n                            throw new AbortException();\r\n                        }\r\n                    }\r\n                    return null;\r\n                }\r\n                public Locus getLocus() {\r\n                    return locus;\r\n                }\r\n            });\r\n            return null;\r\n        }\r\n    };\r\n    final Util.Functor1<Void, Statement> callbackNoCaching = new Util.Functor1<Void, Statement>() {\r\n        public Void apply(final Statement stmt) {\r\n            locus.execution.registerStatement(locus, stmt);\r\n            return null;\r\n        }\r\n    };\r\n    try {\r\n        return // cache the segments or not.\r\n        RolapUtil.executeQuery(// cache the segments or not.\r\n        star.getDataSource(), // cache the segments or not.\r\n        pair.left, // cache the segments or not.\r\n        pair.right, // cache the segments or not.\r\n        0, // cache the segments or not.\r\n        0, // cache the segments or not.\r\n        locus, // cache the segments or not.\r\n        -1, -1, MondrianProperties.instance().DisableCaching.get() ? callbackNoCaching : callbackWithCaching);\r\n    } catch (Throwable t) {\r\n        if (Util.getMatchingCause(t, AbortException.class) != null) {\r\n            return null;\r\n        } else {\r\n            throw new MondrianException(\"Failed to load segment form SQL\", t);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentLoader.createExecuteSql",
	"Comment": "creates and executes a sql statement to retrieve the set of cellsspecified by a groupingsetslist.this method may be overridden in tests.",
	"Method": "SqlStatement createExecuteSql(int cellRequestCount,GroupingSetsList groupingSetsList,List<StarPredicate> compoundPredicateList){\r\n    cacheMgr.execute(new SegmentCacheManager.Command<Void>() {\r\n        public Void call() throws Exception {\r\n            boolean atLeastOneActive = false;\r\n            for (Segment seg : groupingSetsList.getDefaultSegments()) {\r\n                final SegmentCacheIndex index = cacheMgr.getIndexRegistry().getIndex(seg.star);\r\n                if (index.contains(seg.getHeader())) {\r\n                    index.linkSqlStatement(seg.getHeader(), stmt);\r\n                    atLeastOneActive = true;\r\n                }\r\n                if (!atLeastOneActive) {\r\n                    throw new AbortException();\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        public Locus getLocus() {\r\n            return locus;\r\n        }\r\n    });\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentLoader.createExecuteSql",
	"Comment": "creates and executes a sql statement to retrieve the set of cellsspecified by a groupingsetslist.this method may be overridden in tests.",
	"Method": "SqlStatement createExecuteSql(int cellRequestCount,GroupingSetsList groupingSetsList,List<StarPredicate> compoundPredicateList){\r\n    boolean atLeastOneActive = false;\r\n    for (Segment seg : groupingSetsList.getDefaultSegments()) {\r\n        final SegmentCacheIndex index = cacheMgr.getIndexRegistry().getIndex(seg.star);\r\n        if (index.contains(seg.getHeader())) {\r\n            index.linkSqlStatement(seg.getHeader(), stmt);\r\n            atLeastOneActive = true;\r\n        }\r\n        if (!atLeastOneActive) {\r\n            throw new AbortException();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentLoader.createExecuteSql",
	"Comment": "creates and executes a sql statement to retrieve the set of cellsspecified by a groupingsetslist.this method may be overridden in tests.",
	"Method": "SqlStatement createExecuteSql(int cellRequestCount,GroupingSetsList groupingSetsList,List<StarPredicate> compoundPredicateList){\r\n    return locus;\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentLoader.createExecuteSql",
	"Comment": "creates and executes a sql statement to retrieve the set of cellsspecified by a groupingsetslist.this method may be overridden in tests.",
	"Method": "SqlStatement createExecuteSql(int cellRequestCount,GroupingSetsList groupingSetsList,List<StarPredicate> compoundPredicateList){\r\n    locus.execution.registerStatement(locus, stmt);\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentBuilder.rollup",
	"Comment": "given a collection of segments, all of the same dimensionality, rolls upto create a segment with reduced dimensionality.",
	"Method": "Pair<SegmentHeader, SegmentBody> rollup(Map<SegmentHeader, SegmentBody> map,Set<String> keepColumns,BitKey targetBitkey,Aggregator rollupAggregator,Datatype datatype){\r\n    class AxisInfo {\r\n        SegmentColumn column;\r\n        SortedSet<Comparable> requestedValues;\r\n        SortedSet<Comparable> valueSet;\r\n        Comparable[] values;\r\n        boolean hasNull;\r\n        int src;\r\n        boolean lostPredicate;\r\n    }\r\n    assert allHeadersHaveSameDimensionality(map.keySet());\r\n    List<Map.Entry<SegmentHeader, SegmentBody>> segments = UnmodifiableArrayList.of(map.entrySet());\r\n    final SegmentHeader firstHeader = segments.get(0).getKey();\r\n    final List<AxisInfo> axes = new ArrayList<AxisInfo>(keepColumns.size());\r\n    int z = 0, j = 0;\r\n    List<SegmentColumn> firstHeaderConstrainedColumns = firstHeader.getConstrainedColumns();\r\n    for (SegmentColumn column : firstHeaderConstrainedColumns) {\r\n        if (keepColumns.contains(column.columnExpression)) {\r\n            final AxisInfo axisInfo = new AxisInfo();\r\n            axes.add(axisInfo);\r\n            axisInfo.src = j;\r\n            axisInfo.column = column;\r\n            axisInfo.requestedValues = column.values;\r\n        }\r\n        j++;\r\n    }\r\n    for (Map.Entry<SegmentHeader, SegmentBody> entry : segments) {\r\n        final SegmentHeader header = entry.getKey();\r\n        for (AxisInfo axis : axes) {\r\n            final SortedSet<Comparable> values = entry.getValue().getAxisValueSets()[axis.src];\r\n            final SegmentColumn headerColumn = header.getConstrainedColumn(axis.column.columnExpression);\r\n            final boolean hasNull = entry.getValue().getNullAxisFlags()[axis.src];\r\n            final SortedSet<Comparable> requestedValues = headerColumn.getValues();\r\n            if (axis.valueSet == null) {\r\n                axis.valueSet = new TreeSet<Comparable>(values);\r\n                axis.hasNull = hasNull;\r\n                axis.requestedValues = requestedValues;\r\n            } else {\r\n                final SortedSet<Comparable> filteredValues;\r\n                final boolean filteredHasNull;\r\n                if (axis.requestedValues == null && requestedValues == null) {\r\n                    filteredValues = axis.valueSet;\r\n                    filteredValues.addAll(new TreeSet<Comparable>(values));\r\n                    filteredHasNull = hasNull || axis.hasNull;\r\n                } else if (axis.requestedValues == null) {\r\n                    filteredValues = values;\r\n                    filteredHasNull = hasNull;\r\n                    axis.column = headerColumn;\r\n                } else if (requestedValues == null) {\r\n                    filteredValues = axis.requestedValues;\r\n                    filteredHasNull = axis.hasNull;\r\n                } else {\r\n                    filteredValues = Util.intersect(requestedValues, axis.requestedValues);\r\n                    filteredHasNull = false;\r\n                }\r\n                axis.valueSet = filteredValues;\r\n                axis.hasNull = axis.hasNull || filteredHasNull;\r\n                if (!Util.equals(axis.requestedValues, requestedValues)) {\r\n                    if (axis.requestedValues == null) {\r\n                        axis.requestedValues = requestedValues;\r\n                    } else if (requestedValues != null) {\r\n                        axis.lostPredicate = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (AxisInfo axis : axes) {\r\n        axis.values = axis.valueSet.toArray(new Comparable[axis.valueSet.size()]);\r\n    }\r\n    final Map<CellKey, List<Object>> cellValues = new HashMap<CellKey, List<Object>>();\r\n    List<List<Comparable>> addedIntersections = new ArrayList<List<Comparable>>();\r\n    for (Map.Entry<SegmentHeader, SegmentBody> entry : map.entrySet()) {\r\n        final int[] pos = new int[axes.size()];\r\n        final Comparable[][] valueArrays = new Comparable[firstHeaderConstrainedColumns.size()][];\r\n        final SegmentBody body = entry.getValue();\r\n        z = 0;\r\n        for (SortedSet<Comparable> set : body.getAxisValueSets()) {\r\n            valueArrays[z] = keepColumns.contains(firstHeaderConstrainedColumns.get(z).columnExpression) ? set.toArray(new Comparable[set.size()]) : null;\r\n            ++z;\r\n        }\r\n        Map<CellKey, Object> v = body.getValueMap();\r\n        entryLoop: for (Map.Entry<CellKey, Object> vEntry : v.entrySet()) {\r\n            z = 0;\r\n            for (int i = 0; i < vEntry.getKey().size(); i++) {\r\n                final Comparable[] valueArray = valueArrays[i];\r\n                if (valueArray == null) {\r\n                    continue;\r\n                }\r\n                final int ordinal = vEntry.getKey().getOrdinals()[i];\r\n                final int targetOrdinal;\r\n                if (axes.get(z).hasNull && ordinal == valueArray.length) {\r\n                    targetOrdinal = axes.get(z).valueSet.size();\r\n                } else {\r\n                    final Comparable value = valueArray[ordinal];\r\n                    if (value == null) {\r\n                        targetOrdinal = axes.get(z).valueSet.size();\r\n                    } else {\r\n                        targetOrdinal = Util.binarySearch(axes.get(z).values, 0, axes.get(z).values.length, value);\r\n                    }\r\n                }\r\n                if (targetOrdinal >= 0) {\r\n                    pos[z++] = targetOrdinal;\r\n                } else {\r\n                    continue entryLoop;\r\n                }\r\n            }\r\n            final CellKey ck = CellKey.Generator.newCellKey(pos);\r\n            if (!cellValues.containsKey(ck)) {\r\n                cellValues.put(ck, new ArrayList<Object>());\r\n            }\r\n            List<Comparable> colValues = getColumnValsAtCellKey(body, vEntry.getKey());\r\n            if (!addedIntersections.contains(colValues)) {\r\n                cellValues.get(ck).add(vEntry.getValue());\r\n                addedIntersections.add(colValues);\r\n            }\r\n        }\r\n    }\r\n    final List<Pair<SortedSet<Comparable>, Boolean>> axisList = new ArrayList<Pair<SortedSet<Comparable>, Boolean>>();\r\n    BigInteger bigValueCount = BigInteger.ONE;\r\n    for (AxisInfo axis : axes) {\r\n        axisList.add(Pair.of(axis.valueSet, axis.hasNull));\r\n        int size = axis.values.length;\r\n        bigValueCount = bigValueCount.multiply(BigInteger.valueOf(axis.hasNull ? size + 1 : size));\r\n    }\r\n    final boolean sparse = bigValueCount.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) > 0 || SegmentLoader.useSparse(bigValueCount.doubleValue(), cellValues.size());\r\n    final int[] axisMultipliers = computeAxisMultipliers(axisList);\r\n    final SegmentBody body;\r\n    if (cellValues.size() == 0) {\r\n        body = new DenseObjectSegmentBody(new Object[0], axisList);\r\n    } else if (sparse) {\r\n        final Map<CellKey, Object> data = new HashMap<CellKey, Object>();\r\n        for (Entry<CellKey, List<Object>> entry : cellValues.entrySet()) {\r\n            data.put(CellKey.Generator.newCellKey(entry.getKey().getOrdinals()), rollupAggregator.aggregate(entry.getValue(), datatype));\r\n        }\r\n        body = new SparseSegmentBody(data, axisList);\r\n    } else {\r\n        final BitSet nullValues;\r\n        final int valueCount = bigValueCount.intValue();\r\n        switch(datatype) {\r\n            case Integer:\r\n                final int[] ints = new int[valueCount];\r\n                nullValues = Util.bitSetBetween(0, valueCount);\r\n                for (Entry<CellKey, List<Object>> entry : cellValues.entrySet()) {\r\n                    final int offset = CellKey.Generator.getOffset(entry.getKey().getOrdinals(), axisMultipliers);\r\n                    final Object value = rollupAggregator.aggregate(entry.getValue(), datatype);\r\n                    if (value != null) {\r\n                        ints[offset] = (Integer) value;\r\n                        nullValues.clear(offset);\r\n                    }\r\n                }\r\n                body = new DenseIntSegmentBody(nullValues, ints, axisList);\r\n                break;\r\n            case Numeric:\r\n                final double[] doubles = new double[valueCount];\r\n                nullValues = Util.bitSetBetween(0, valueCount);\r\n                for (Entry<CellKey, List<Object>> entry : cellValues.entrySet()) {\r\n                    final int offset = CellKey.Generator.getOffset(entry.getKey().getOrdinals(), axisMultipliers);\r\n                    final Object value = rollupAggregator.aggregate(entry.getValue(), datatype);\r\n                    if (value != null) {\r\n                        doubles[offset] = (Double) value;\r\n                        nullValues.clear(offset);\r\n                    }\r\n                }\r\n                body = new DenseDoubleSegmentBody(nullValues, doubles, axisList);\r\n                break;\r\n            default:\r\n                final Object[] objects = new Object[valueCount];\r\n                for (Entry<CellKey, List<Object>> entry : cellValues.entrySet()) {\r\n                    final int offset = CellKey.Generator.getOffset(entry.getKey().getOrdinals(), axisMultipliers);\r\n                    objects[offset] = rollupAggregator.aggregate(entry.getValue(), datatype);\r\n                }\r\n                body = new DenseObjectSegmentBody(objects, axisList);\r\n        }\r\n    }\r\n    final List<SegmentColumn> constrainedColumns = new ArrayList<SegmentColumn>();\r\n    for (int i = 0; i < axes.size(); i++) {\r\n        AxisInfo axisInfo = axes.get(i);\r\n        constrainedColumns.add(new SegmentColumn(axisInfo.column.getColumnExpression(), axisInfo.column.getValueCount(), axisInfo.lostPredicate ? axisList.get(i).left : axisInfo.column.values));\r\n    }\r\n    final SegmentHeader header = new SegmentHeader(firstHeader.schemaName, firstHeader.schemaChecksum, firstHeader.cubeName, firstHeader.measureName, constrainedColumns, firstHeader.compoundPredicates, firstHeader.rolapStarFactTableName, targetBitkey, Collections.<SegmentColumn>emptyList());\r\n    if (LOGGER.isDebugEnabled()) {\r\n        StringBuilder builder = new StringBuilder();\r\n        builder.append(\"Rolling up segments with parameters: \\n\");\r\n        builder.append(\"keepColumns=\" + keepColumns + \"\\n\");\r\n        builder.append(\"aggregator=\" + rollupAggregator + \"\\n\");\r\n        builder.append(\"datatype=\" + datatype + \"\\n\");\r\n        for (Map.Entry<SegmentHeader, SegmentBody> segment : segments) {\r\n            builder.append(segment.getKey() + \"\\n\");\r\n        }\r\n        builder.append(\"AxisInfos constructed:\");\r\n        for (AxisInfo axis : axes) {\r\n            SortedSet<Comparable> colVals = axis.column.getValues();\r\n            builder.append(String.format(\"column.columnExpression=%s\\n\" + \"column.valueCount=%s\\n\" + \"column.values=%s\\n\" + \"requestedValues=%s\\n\" + \"valueSet=%s\\n\" + \"values=%s\\n\" + \"hasNull=%b\\n\" + \"src=%d\\n\" + \"lostPredicate=%b\\n\", axis.column.columnExpression, axis.column.getValueCount(), Arrays.toString(colVals == null ? null : colVals.toArray()), axis.requestedValues, axis.valueSet, Arrays.asList(axis.values), axis.hasNull, axis.src, axis.lostPredicate));\r\n        }\r\n        builder.append(\"Resulted in Segment:  \\n\");\r\n        builder.append(header);\r\n        builder.append(body.toString());\r\n        LOGGER.debug(builder.toString());\r\n    }\r\n    return Pair.of(header, body);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Dd.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Dd appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getHeaders",
	"Comment": "returns all the values of the specified request header as an enumeration of string objects.",
	"Method": "Enumeration getHeaders(String name){\r\n    List<String> headerList = headers.get(name);\r\n    return (headerList == null) ? null : Collections.enumeration(headerList);\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCube.createCalcMembersAndNamedSets",
	"Comment": "adds a collection of calculated members and named sets to this cube.the members and sets can refer to each other.",
	"Method": "void createCalcMembersAndNamedSets(List<MondrianDef.CalculatedMember> xmlCalcMembers,List<MondrianDef.NamedSet> xmlNamedSets,List<RolapMember> memberList,List<Formula> formulaList,RolapCube cube,boolean errOnDups){\r\n    final Query queryExp = resolveCalcMembers(xmlCalcMembers, xmlNamedSets, cube, errOnDups);\r\n    if (queryExp == null) {\r\n        return;\r\n    }\r\n    Util.assertTrue(queryExp.getFormulas().length == xmlCalcMembers.size() + xmlNamedSets.size());\r\n    for (int i = 0; i < xmlCalcMembers.size(); i++) {\r\n        postCalcMember(xmlCalcMembers, i, queryExp, memberList);\r\n    }\r\n    for (int i = 0; i < xmlNamedSets.size(); i++) {\r\n        postNamedSet(xmlNamedSets, xmlCalcMembers.size(), i, queryExp, formulaList);\r\n    }\r\n}"
}, {
	"Path": "mondrian.olap.NameResolver.nullify",
	"Comment": "converts an element to the required type, converting if possible,returning null if it is not of the required type and cannot be converted.",
	"Method": "OlapElement nullify(int category,OlapElement element){\r\n    switch(category) {\r\n        case Category.Unknown:\r\n            return element;\r\n        case Category.Member:\r\n            return element instanceof Member ? element : null;\r\n        case Category.Level:\r\n            return element instanceof Level ? element : null;\r\n        case Category.Hierarchy:\r\n            if (element instanceof Hierarchy) {\r\n                return element;\r\n            } else if (element instanceof Dimension) {\r\n                final Dimension dimension = (Dimension) element;\r\n                final Hierarchy[] hierarchies = dimension.getHierarchies();\r\n                if (hierarchies.length == 1) {\r\n                    return hierarchies[0];\r\n                }\r\n                return null;\r\n            } else {\r\n                return null;\r\n            }\r\n        case Category.Dimension:\r\n            return element instanceof Dimension ? element : null;\r\n        case Category.Set:\r\n            return element instanceof NamedSet ? element : null;\r\n        default:\r\n            throw Util.newInternal(\"unexpected: \" + category);\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.core.util.MercatorProjection.tileYToLatitude",
	"Comment": "converts a tile y number at a certain zoom level to a latitude coordinate.",
	"Method": "double tileYToLatitude(long tileY,byte zoomLevel){\r\n    return pixelYToLatitude(tileY * DUMMY_TILE_SIZE, getMapSize(zoomLevel, DUMMY_TILE_SIZE));\r\n}"
}, {
	"Path": "mondrian.rolap.SqlTupleReader.isGroupByNeeded",
	"Comment": "determines whether the group by clause is required, based on theschema definitions of the hierarchy and level properties.the group by clause may only be eliminated if the level identified bythe uniquekeylevelname exists, the query is at a depth to include it,and all properties in the included levels are functionally dependent ontheir level values.",
	"Method": "boolean isGroupByNeeded(RolapHierarchy hierarchy,RolapLevel[] levels,int levelDepth){\r\n    boolean needsGroupBy = false;\r\n    if (hierarchy.getUniqueKeyLevelName() == null) {\r\n        needsGroupBy = true;\r\n    } else {\r\n        boolean foundUniqueKeyLevelName = false;\r\n        for (int i = 0; i <= levelDepth; i++) {\r\n            RolapLevel lvl = levels[i];\r\n            if (!(lvl.isAll())) {\r\n                if (hierarchy.getUniqueKeyLevelName().equals(lvl.getName())) {\r\n                    foundUniqueKeyLevelName = true;\r\n                }\r\n                for (RolapProperty p : lvl.getProperties()) {\r\n                    if (!p.dependsOnLevelValue()) {\r\n                        needsGroupBy = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (needsGroupBy) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (!foundUniqueKeyLevelName) {\r\n            needsGroupBy = true;\r\n        }\r\n    }\r\n    return needsGroupBy;\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.StringUtils.replace",
	"Comment": "replace all occurences of a substring within a string with anotherstring.",
	"Method": "String replace(String inString,String oldPattern,String newPattern){\r\n    if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {\r\n        return inString;\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    int pos = 0;\r\n    int index = inString.indexOf(oldPattern);\r\n    int patLen = oldPattern.length();\r\n    while (index >= 0) {\r\n        sb.append(inString.substring(pos, index));\r\n        sb.append(newPattern);\r\n        pos = index + patLen;\r\n        index = inString.indexOf(oldPattern, pos);\r\n    }\r\n    sb.append(inString.substring(pos));\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.ui.widget.StaggeredGridView.shouldShowSelector",
	"Comment": "indicates whether this view is in a state where the selector should be drawn. this willhappen if we have focus but are not in touch mode, or we are in the middle of displayingthe pressed state for an item.",
	"Method": "boolean shouldShowSelector(){\r\n    return (hasFocus() && !isInTouchMode()) || touchModeDrawsInPressedState();\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.ui.widget.StaggeredGridView.setOnItemLongClickListener",
	"Comment": "register a callback to be invoked when an item in this adapterview hasbeen clicked and held",
	"Method": "void setOnItemLongClickListener(OnItemLongClickListener listener){\r\n    if (!isLongClickable()) {\r\n        setLongClickable(true);\r\n    }\r\n    mOnItemLongClickListener = listener;\r\n}"
}, {
	"Path": "mondrian.test.TestContext.assertExprReturns",
	"Comment": "executes an expression and asserts that it returns a given result.",
	"Method": "void assertExprReturns(String expression,String expected){\r\n    final Cell cell = executeExprRaw(expression);\r\n    if (expected == null) {\r\n        expected = \"\";\r\n    }\r\n    assertEqualsVerbose(expected, cell.getFormattedValue());\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Ins.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Ins appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.test.DrillThroughTest.assertCanDrillThrough",
	"Comment": "asserts that a cell based on the given measure expression has a givendrillability.",
	"Method": "void assertCanDrillThrough(boolean canDrillThrough,String cubeName,String expr){\r\n    Result result = executeQuery(\"WITH MEMBER [Measures].[Foo] AS '\" + expr + \"'\\n\" + \"SELECT {[Measures].[Foo]} on columns,\\n\" + \" {[Product].Children} on rows\\n\" + \"from [\" + cubeName + \"]\");\r\n    final Cell cell = result.getCell(new int[] { 0, 0 });\r\n    assertEquals(canDrillThrough, cell.canDrillThrough());\r\n    final String sql = cell.getDrillThroughSQL(false);\r\n    if (canDrillThrough) {\r\n        assertNotNull(sql);\r\n    } else {\r\n        assertNull(sql);\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.core.util.MercatorProjection.getPixelRelative",
	"Comment": "calculates the absolute pixel position for a map size and tile size relative to origin",
	"Method": "Point getPixelRelative(LatLong latLong,long mapSize,double x,double y,Point getPixelRelative,LatLong latLong,long mapSize,Point origin){\r\n    return getPixelRelative(latLong, mapSize, origin.x, origin.y);\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCube.findBaseCubeLevel",
	"Comment": "locates the base cube level for a particular virtual level.if not found, return null. this may be converted to a map lookupor cached in some way in the future to increase performancewith cubes that have large numbers of hierarchies and levels",
	"Method": "RolapCubeLevel findBaseCubeLevel(RolapLevel level){\r\n    if (virtualToBaseMap.containsKey(level)) {\r\n        return virtualToBaseMap.get(level);\r\n    }\r\n    String levelDimName = level.getDimension().getName();\r\n    String levelHierName = level.getHierarchy().getName();\r\n    boolean isClosure = false;\r\n    String closDimName = null;\r\n    String closHierName = null;\r\n    if (levelDimName.endsWith(\"$Closure\")) {\r\n        isClosure = true;\r\n        closDimName = levelDimName.substring(0, levelDimName.length() - 8);\r\n        closHierName = levelHierName.substring(0, levelHierName.length() - 8);\r\n    }\r\n    for (Dimension dimension : getDimensions()) {\r\n        final String dimensionName = dimension.getName();\r\n        if (dimensionName.equals(levelDimName) || (isClosure && dimensionName.equals(closDimName))) {\r\n            for (Hierarchy hier : dimension.getHierarchies()) {\r\n                final String hierarchyName = hier.getName();\r\n                if (hierarchyName.equals(levelHierName) || (isClosure && hierarchyName.equals(closHierName))) {\r\n                    if (isClosure) {\r\n                        final RolapCubeLevel baseLevel = ((RolapCubeLevel) hier.getLevels()[1]).getClosedPeer();\r\n                        virtualToBaseMap.put(level, baseLevel);\r\n                        return baseLevel;\r\n                    }\r\n                    for (Level lvl : hier.getLevels()) {\r\n                        if (lvl.getName().equals(level.getName())) {\r\n                            final RolapCubeLevel baseLevel = (RolapCubeLevel) lvl;\r\n                            virtualToBaseMap.put(level, baseLevel);\r\n                            return baseLevel;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.rolap.SqlTupleReader.addTargetGroupsToKey",
	"Comment": "adds target group info to cachekey if split targetgroups are needed for this query.",
	"Method": "void addTargetGroupsToKey(List<Object> cacheKey){\r\n    List<List<TargetBase>> targetGroups = groupTargets(targets, constraint.getEvaluator().getQuery());\r\n    if (targetGroups.size() > 1) {\r\n        cacheKey.add(targetsToLevels(targetGroups));\r\n    }\r\n}"
}, {
	"Path": "mondrian.server.Execution.registerStatement",
	"Comment": "this method is typically called by sqlstatement at construction time.it ties all statement objects to a particular execution instanceso that we can audit, monitor and gracefully cancel an execution.",
	"Method": "void registerStatement(Locus locus,java.sql.Statement statement){\r\n    synchronized (sqlStateLock) {\r\n        synchronized (stateLock) {\r\n            if (state == State.FRESH) {\r\n                start();\r\n            }\r\n            if (state == State.RUNNING) {\r\n                this.statements.put(locus, statement);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.util.UnionIterator.moveToNext",
	"Comment": "moves to the next iterator that has at least one element.called after finishing an iterator, or at the start.",
	"Method": "void moveToNext(){\r\n    do {\r\n        if (iterableIterator.hasNext()) {\r\n            iterator = iterableIterator.next().iterator();\r\n        } else {\r\n            iterator = Collections.<T>emptyList().iterator();\r\n            break;\r\n        }\r\n    } while (!iterator.hasNext());\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.getThreadDefaultConnectionFlags",
	"Comment": "gets default connection flags that are appropriate for this thread, taking intoaccount whether the thread is acting on behalf of the ui.",
	"Method": "int getThreadDefaultConnectionFlags(boolean readOnly){\r\n    int flags = readOnly ? SQLiteConnectionPool.CONNECTION_FLAG_READ_ONLY : SQLiteConnectionPool.CONNECTION_FLAG_PRIMARY_CONNECTION_AFFINITY;\r\n    if (isMainThread()) {\r\n        flags |= SQLiteConnectionPool.CONNECTION_FLAG_INTERACTIVE;\r\n    }\r\n    return flags;\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.removeCalculatedMembers",
	"Comment": "removes every tuple from a list which is calculated.the list must not be null, and must consist only of members.",
	"Method": "List<Member> removeCalculatedMembers(List<Member> memberList,TupleList removeCalculatedMembers,TupleList memberList){\r\n    if (memberList.getArity() == 1) {\r\n        return new UnaryTupleList(removeCalculatedMembers(memberList.slice(0)));\r\n    } else {\r\n        final TupleList clone = memberList.cloneList(memberList.size());\r\n        outer: for (List<Member> members : memberList) {\r\n            for (Member member : members) {\r\n                if (member.isCalculated() && !member.isParentChildPhysicalMember()) {\r\n                    continue outer;\r\n                }\r\n            }\r\n            clone.add(members);\r\n        }\r\n        return clone;\r\n    }\r\n}"
}, {
	"Path": "cc.mallet.util.VectorStats.variance",
	"Comment": "returns unbiased variance of instances having the given mean.",
	"Method": "SparseVector variance(InstanceList instances,boolean unbiased,SparseVector variance,InstanceList instances,SparseVector mean,boolean unbiased,SparseVector variance,InstanceList instances,SparseVector variance,InstanceList instances,SparseVector mean){\r\n    return variance(instances, mean, true);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Thead.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Thead appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.RolapStarTest.testTwoColumnsWithDifferentNamesNotEquals",
	"Comment": "below there are tests for mondrian.rolap.rolapstar.columncomparator",
	"Method": "void testTwoColumnsWithDifferentNamesNotEquals(){\r\n    RolapStar.ColumnComparator colComparator = RolapStar.ColumnComparator.instance;\r\n    Column column1 = getColumnMock(\"Column1\", \"Table1\");\r\n    Column column2 = getColumnMock(\"Column2\", \"Table1\");\r\n    assertNotSame(column1, column2);\r\n    assertEquals(-1, colComparator.compare(column1, column2));\r\n}"
}, {
	"Path": "mondrian.test.DialectTest.testForceNullCollation",
	"Comment": "tests that the dialect can generate a valid query to sort ascending anddescending, with null values appearing last in both cases.",
	"Method": "void testForceNullCollation(){\r\n    checkForceNullCollation(true, true);\r\n    checkForceNullCollation(false, true);\r\n    checkForceNullCollation(true, false);\r\n    checkForceNullCollation(false, false);\r\n}"
}, {
	"Path": "com.meetup.memcached.Logger.log",
	"Comment": "logs mesg to std out and prints stack trace if exception passed in",
	"Method": "void log(String mesg,Throwable ex){\r\n    System.out.println(name + \" \" + new Date() + \" - \" + mesg);\r\n    if (ex != null)\r\n        ex.printStackTrace(System.out);\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.checkNativeCompatible",
	"Comment": "functions that dynamically return one or more members of the measuresdimension prevent us from using native evaluation.",
	"Method": "void checkNativeCompatible(Validator validator,FunDef funDef,Exp[] args){\r\n    Query query = validator.getQuery();\r\n    if (!(funDef instanceof SetFunDef) && !(funDef instanceof ParenthesesFunDef) && query != null && query.nativeCrossJoinVirtualCube()) {\r\n        int[] paramCategories = funDef.getParameterCategories();\r\n        if (paramCategories.length > 0) {\r\n            final int cat0 = paramCategories[0];\r\n            final Exp arg0 = args[0];\r\n            switch(cat0) {\r\n                case Category.Dimension:\r\n                case Category.Hierarchy:\r\n                    if (arg0 instanceof DimensionExpr && ((DimensionExpr) arg0).getDimension().isMeasures() && !(funDef instanceof HierarchyCurrentMemberFunDef)) {\r\n                        query.setVirtualCubeNonNativeCrossJoin();\r\n                    }\r\n                    break;\r\n                case Category.Member:\r\n                    if (arg0 instanceof MemberExpr && ((MemberExpr) arg0).getMember().isMeasure() && isMemberOrSet(funDef.getReturnCategory())) {\r\n                        query.setVirtualCubeNonNativeCrossJoin();\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.RolapUtil.constraintBitkeyForLimitedMembers",
	"Comment": "modifies a bitkey so that it includes the proper bitsfor members in an array which should be consideredas a limited rollup member.",
	"Method": "void constraintBitkeyForLimitedMembers(Evaluator evaluator,Member[] members,RolapCube cube,BitKey levelBitKey){\r\n    for (Member curMember : members) {\r\n        if (curMember instanceof LimitedRollupMember) {\r\n            final int savepoint = evaluator.savepoint();\r\n            try {\r\n                evaluator.setNonEmpty(false);\r\n                List<Member> lowestMembers = ((RolapHierarchy) curMember.getHierarchy()).getLowestMembersForAccess(evaluator, ((LimitedRollupMember) curMember).hierarchyAccess, FunUtil.getNonEmptyMemberChildrenWithDetails(evaluator, curMember));\r\n                assert lowestMembers.size() > 0;\r\n                Member lowMember = lowestMembers.get(0);\r\n                while (true) {\r\n                    RolapStar.Column curColumn = ((RolapCubeLevel) lowMember.getLevel()).getBaseStarKeyColumn(cube);\r\n                    if (curColumn != null) {\r\n                        levelBitKey.set(curColumn.getBitPosition());\r\n                    }\r\n                    if (!((RolapCubeLevel) lowMember.getLevel()).isUnique()) {\r\n                        lowMember = lowMember.getParentMember();\r\n                        if (lowMember.isAll()) {\r\n                            break;\r\n                        }\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            } finally {\r\n                evaluator.restore(savepoint);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.TestContext.toString",
	"Comment": "converts a set of positions into a string. useful if you want to checkthat an axis has the results you expected.",
	"Method": "String toString(Result result,String toString,CellSet cellSet,String toString,List<Position> positions){\r\n    StringBuilder buf = new StringBuilder();\r\n    int i = 0;\r\n    for (Position position : positions) {\r\n        if (i > 0) {\r\n            buf.append(nl);\r\n        }\r\n        if (position.size() != 1) {\r\n            buf.append(\"{\");\r\n        }\r\n        for (int j = 0; j < position.size(); j++) {\r\n            Member member = position.get(j);\r\n            if (j > 0) {\r\n                buf.append(\", \");\r\n            }\r\n            buf.append(member.getUniqueName());\r\n        }\r\n        if (position.size() != 1) {\r\n            buf.append(\"}\");\r\n        }\r\n        i++;\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteSession.executeForBlobFileDescriptor",
	"Comment": "executes a statement that returns a single blob result as afile descriptor to a shared memory region.",
	"Method": "ParcelFileDescriptor executeForBlobFileDescriptor(String sql,Object[] bindArgs,int connectionFlags,CancellationSignal cancellationSignal){\r\n    if (sql == null) {\r\n        throw new IllegalArgumentException(\"sql must not be null.\");\r\n    }\r\n    if (executeSpecial(sql, bindArgs, connectionFlags, cancellationSignal)) {\r\n        return null;\r\n    }\r\n    acquireConnection(sql, connectionFlags, cancellationSignal);\r\n    try {\r\n        return // might throw\r\n        mConnection.executeForBlobFileDescriptor(// might throw\r\n        sql, bindArgs, cancellationSignal);\r\n    } finally {\r\n        releaseConnection();\r\n    }\r\n}"
}, {
	"Path": "mondrian.gui.JdbcMetaData.getAllTables",
	"Comment": "returns all tables in given schema minus the given table name.",
	"Method": "List<String> getAllTables(String schemaName,List<String> getAllTables,String schemaName,String minusTable,List<String> getAllTables,String sname,List<String> getAllTables,String sname,boolean factOnly){\r\n    if (minusTable == null) {\r\n        return getAllTables(schemaName);\r\n    } else {\r\n        List<String> allTablesMinusOne = new ArrayList<String>();\r\n        for (String s : getAllTables(schemaName)) {\r\n            if (s.endsWith(minusTable)) {\r\n                if ((schemaName == null) || s.startsWith(schemaName)) {\r\n                    continue;\r\n                }\r\n            }\r\n            allTablesMinusOne.add(s);\r\n        }\r\n        return allTablesMinusOne;\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.Recognizer.checkFactColumns",
	"Comment": "make sure that the aggregate table has one fact count column and that itstype is numeric and find measure fact columns",
	"Method": "void checkFactColumns(){\r\n    msgRecorder.pushContextName(\"Recognizer.checkFactCount\");\r\n    try {\r\n        Matcher factCountMatcher = getFactCountMatcher();\r\n        JdbcSchema.Table.Column factColumn = null;\r\n        int nosOfFactCounts = 0;\r\n        for (JdbcSchema.Table.Column aggColumn : aggTable.getColumns()) {\r\n            if (aggColumn.hasUsage(JdbcSchema.UsageType.IGNORE)) {\r\n                continue;\r\n            }\r\n            if (factCountMatcher.matches(aggColumn.getName())) {\r\n                if (aggColumn.getDatatype().isNumeric()) {\r\n                    makeFactCount(aggColumn);\r\n                    nosOfFactCounts++;\r\n                    factColumn = aggColumn;\r\n                } else {\r\n                    String msg = mres.NonNumericFactCountColumn.str(aggTable.getName(), dbFactTable.getName(), aggColumn.getName(), aggColumn.getTypeName());\r\n                    msgRecorder.reportError(msg);\r\n                    returnValue = false;\r\n                }\r\n            }\r\n        }\r\n        if (nosOfFactCounts == 0) {\r\n            String msg = mres.NoFactCountColumns.str(aggTable.getName(), dbFactTable.getName());\r\n            msgRecorder.reportError(msg);\r\n            returnValue = false;\r\n        } else if (nosOfFactCounts > 1) {\r\n            String msg = mres.TooManyFactCountColumns.str(aggTable.getName(), dbFactTable.getName(), nosOfFactCounts);\r\n            msgRecorder.reportError(msg);\r\n            returnValue = false;\r\n        } else {\r\n            Matcher measureFactCountMatcher = getMeasureFactCountMatcher();\r\n            for (JdbcSchema.Table.Column aggColumn : aggTable.getColumns()) {\r\n                if (!aggColumn.hasUsage() && measureFactCountMatcher.matches(aggColumn.getName())) {\r\n                    makeMeasureFactCount(aggColumn);\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        msgRecorder.popContextName();\r\n    }\r\n}"
}, {
	"Path": "mondrian.olap.Query.getBaseCubes",
	"Comment": "return the set of base cubes associated with the virtual cube referencedin this query",
	"Method": "List<RolapCube> getBaseCubes(){\r\n    return baseCubes;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteSession.hasNestedTransaction",
	"Comment": "returns true if the session has a nested transaction in progress.",
	"Method": "boolean hasNestedTransaction(){\r\n    return mTransactionStack != null && mTransactionStack.mParent != null;\r\n}"
}, {
	"Path": "mondrian.olap.UtilTestCase.p",
	"Comment": "checks that connectstring contains a property calledname, whose value is value.",
	"Method": "void p(String connectString,String name,String expectedValue){\r\n    Util.PropertyList list = Util.parseConnectString(connectString);\r\n    String value = list.get(name);\r\n    assertEquals(expectedValue, value);\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.DrawerView.hasOnProfileClickListener",
	"Comment": "gets whether the drawer has a profile click listener set to it",
	"Method": "boolean hasOnProfileClickListener(){\r\n    return onProfileClickListener != null;\r\n}"
}, {
	"Path": "mondrian.test.TestContext.databaseIsValid",
	"Comment": "tests whether the database is valid. allows tests that depend on optionaldatabases to figure out whether to proceed.",
	"Method": "boolean databaseIsValid(){\r\n    try {\r\n        Connection connection = getConnection();\r\n        String cubeName = getDefaultCubeName();\r\n        if (cubeName.indexOf(' ') >= 0) {\r\n            cubeName = Util.quoteMdxIdentifier(cubeName);\r\n        }\r\n        Query query = connection.parseQuery(\"select from \" + cubeName);\r\n        Result result = connection.execute(query);\r\n        Util.discard(result);\r\n        connection.close();\r\n        return true;\r\n    } catch (RuntimeException e) {\r\n        Util.discard(e);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.AggStar.lookupLevel",
	"Comment": "get the level at the given bit position or return null.note that there is no check that the bit position is within the range ofthe array of columns.nor is there a check that the column type at that position is a level.",
	"Method": "AggStar.Table.Level lookupLevel(int bitPos){\r\n    AggStar.Table.Column column = lookupColumn(bitPos);\r\n    return (column instanceof AggStar.FactTable.Level) ? (AggStar.FactTable.Level) column : null;\r\n}"
}, {
	"Path": "net.engio.mbassy.listener.MetadataReader.getFilter",
	"Comment": "retrieve all instances of filters associated with the given subscription",
	"Method": "IMessageFilter[] getFilter(Method method,Handler subscription){\r\n    Filter[] filterDefinitions = collectFilters(method, subscription);\r\n    if (filterDefinitions.length == 0) {\r\n        return null;\r\n    }\r\n    IMessageFilter[] filters = new IMessageFilter[filterDefinitions.length];\r\n    int i = 0;\r\n    for (Filter filterDef : filterDefinitions) {\r\n        IMessageFilter filter = filterCache.get(filterDef.value());\r\n        if (filter == null) {\r\n            try {\r\n                filter = filterDef.value().newInstance();\r\n                filterCache.put(filterDef.value(), filter);\r\n            } catch (Exception e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n        filters[i] = filter;\r\n        i++;\r\n    }\r\n    return filters;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.endTransaction",
	"Comment": "end a transaction. see begintransaction for notes about how to use this and when transactionsare committed and rolled back.",
	"Method": "void endTransaction(){\r\n    acquireReference();\r\n    try {\r\n        getThreadSession().endTransaction(null);\r\n    } finally {\r\n        releaseReference();\r\n    }\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDebug.getDatabaseInfo",
	"Comment": "return all pager and database stats for the current process.",
	"Method": "PagerStats getDatabaseInfo(){\r\n    PagerStats stats = new PagerStats();\r\n    nativeGetPagerStats(stats);\r\n    stats.dbStats = SQLiteDatabase.getDbStats();\r\n    return stats;\r\n}"
}, {
	"Path": "mondrian.test.DrillThroughTest.testDrillThroughMeasureExp",
	"Comment": "tests that proper sql is being generated for a measure specifiedas an expression.",
	"Method": "void testDrillThroughMeasureExp(){\r\n    Result result = executeQuery(\"SELECT {[Measures].[Promotion Sales]} on columns,\\n\" + \" {[Product].Children} on rows\\n\" + \"from Sales\");\r\n    String sql = result.getCell(new int[] { 0, 0 }).getDrillThroughSQL(false);\r\n    String expectedSql = \"select\" + \" `time_by_day`.`the_year` as `Year`,\" + \" `product_class`.`product_family` as `Product Family`,\" + \" (case when `sales_fact_1997`.`promotion_id` = 0 then 0\" + \" else `sales_fact_1997`.`store_sales` end)\" + \" as `Promotion Sales` \" + \"from `time_by_day` =as= `time_by_day`,\" + \" `sales_fact_1997` =as= `sales_fact_1997`,\" + \" `product_class` =as= `product_class`,\" + \" `product` =as= `product` \" + \"where `sales_fact_1997`.`time_id` = `time_by_day`.`time_id`\" + \" and `time_by_day`.`the_year` = 1997\" + \" and `sales_fact_1997`.`product_id` = `product`.`product_id`\" + \" and `product`.`product_class_id` = `product_class`.`product_class_id`\" + \" and `product_class`.`product_family` = 'Drink' \" + (TestContext.instance().getDialect().requiresOrderByAlias() ? \"order by `Year` ASC, `Product Family` ASC\" : \"order by `time_by_day`.`the_year` ASC, `product_class`.`product_family` ASC\");\r\n    final Cube cube = result.getQuery().getCube();\r\n    RolapStar star = ((RolapCube) cube).getStar();\r\n    Dialect dialect = star.getSqlQueryDialect();\r\n    final String caseStmt = \" \\\\(case when `sales_fact_1997`.`promotion_id` = 0 then 0\" + \" else `sales_fact_1997`.`store_sales` end\\\\)\";\r\n    switch(dialect.getDatabaseProduct()) {\r\n        case ACCESS:\r\n            expectedSql = expectedSql.replaceAll(caseStmt, \" Iif(`sales_fact_1997`.`promotion_id` = 0, 0,\" + \" `sales_fact_1997`.`store_sales`)\");\r\n            break;\r\n        case INFOBRIGHT:\r\n            expectedSql = expectedSql.replaceAll(caseStmt, \" `sales_fact_1997`.`store_sales`\");\r\n            break;\r\n    }\r\n    getTestContext().assertSqlEquals(expectedSql, sql, 7978);\r\n}"
}, {
	"Path": "org.mapsforge.core.util.WorkingSetCache.setWorkingSet",
	"Comment": "sets the current working set, ensuring that elements in this working setwill not be ejected in the near future.",
	"Method": "void setWorkingSet(Set<K> workingSet){\r\n    synchronized (workingSet) {\r\n        for (K key : workingSet) {\r\n            this.get(key);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Sub.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Sub appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Td.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Td appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "com.meetup.memcached.MemcachedClient.set",
	"Comment": "stores data to cache.\tif data does not already exist for this key on the server, or if the key is being\tdeleted, the specified value will not be stored.\tthe server will automatically delete the value when the expiration time has been reached.\t\tif compression is enabled, and the data is longer than the compression threshold\tthe data will be stored in compressed form.\t\tas of the current release, all objects stored will use java serialization.",
	"Method": "boolean set(String key,Object value,boolean set,String key,Object value,Integer hashCode,boolean set,String key,Object value,Date expiry,boolean set,String key,Object value,Date expiry,Integer hashCode,boolean set,String cmdname,String key,Object value,Date expiry,Integer hashCode,boolean asString){\r\n    if (cmdname == null || cmdname.trim().equals(\"\") || key == null) {\r\n        log.error(\"key is null or cmd is null/empty for set()\");\r\n        return false;\r\n    }\r\n    try {\r\n        key = sanitizeKey(key);\r\n    } catch (UnsupportedEncodingException e) {\r\n        if (errorHandler != null)\r\n            errorHandler.handleErrorOnSet(this, e, key);\r\n        log.error(\"failed to sanitize your key!\", e);\r\n        return false;\r\n    }\r\n    if (value == null) {\r\n        log.error(\"trying to store a null value to cache\");\r\n        return false;\r\n    }\r\n    SockIOPool.SockIO sock = pool.getSock(key, hashCode);\r\n    if (sock == null) {\r\n        if (errorHandler != null)\r\n            errorHandler.handleErrorOnSet(this, new IOException(\"no socket to server available\"), key);\r\n        return false;\r\n    }\r\n    if (expiry == null)\r\n        expiry = new Date(0);\r\n    int flags = 0;\r\n    byte[] val;\r\n    if (NativeHandler.isHandled(value)) {\r\n        if (asString) {\r\n            try {\r\n                if (log.isInfoEnabled())\r\n                    log.info(\"++++ storing data as a string for key: \" + key + \" for class: \" + value.getClass().getName());\r\n                val = value.toString().getBytes(defaultEncoding);\r\n            } catch (UnsupportedEncodingException ue) {\r\n                if (errorHandler != null)\r\n                    errorHandler.handleErrorOnSet(this, ue, key);\r\n                log.error(\"invalid encoding type used: \" + defaultEncoding, ue);\r\n                sock.close();\r\n                sock = null;\r\n                return false;\r\n            }\r\n        } else {\r\n            try {\r\n                if (log.isInfoEnabled())\r\n                    log.info(\"Storing with native handler...\");\r\n                flags |= NativeHandler.getMarkerFlag(value);\r\n                val = NativeHandler.encode(value);\r\n            } catch (Exception e) {\r\n                if (errorHandler != null)\r\n                    errorHandler.handleErrorOnSet(this, e, key);\r\n                log.error(\"Failed to native handle obj\", e);\r\n                sock.close();\r\n                sock = null;\r\n                return false;\r\n            }\r\n        }\r\n    } else {\r\n        try {\r\n            if (log.isInfoEnabled())\r\n                log.info(\"++++ serializing for key: \" + key + \" for class: \" + value.getClass().getName());\r\n            ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n            (new ObjectOutputStream(bos)).writeObject(value);\r\n            val = bos.toByteArray();\r\n            flags |= F_SERIALIZED;\r\n        } catch (IOException e) {\r\n            if (errorHandler != null)\r\n                errorHandler.handleErrorOnSet(this, e, key);\r\n            log.error(\"failed to serialize obj\", e);\r\n            log.error(value.toString());\r\n            sock.close();\r\n            sock = null;\r\n            return false;\r\n        }\r\n    }\r\n    if (compressEnable && val.length > compressThreshold) {\r\n        try {\r\n            if (log.isInfoEnabled()) {\r\n                log.info(\"++++ trying to compress data\");\r\n                log.info(\"++++ size prior to compression: \" + val.length);\r\n            }\r\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(val.length);\r\n            GZIPOutputStream gos = new GZIPOutputStream(bos);\r\n            gos.write(val, 0, val.length);\r\n            gos.finish();\r\n            gos.close();\r\n            val = bos.toByteArray();\r\n            flags |= F_COMPRESSED;\r\n            if (log.isInfoEnabled())\r\n                log.info(\"++++ compression succeeded, size after: \" + val.length);\r\n        } catch (IOException e) {\r\n            if (errorHandler != null)\r\n                errorHandler.handleErrorOnSet(this, e, key);\r\n            log.error(\"IOException while compressing stream: \" + e.getMessage());\r\n            log.error(\"storing data uncompressed\");\r\n        }\r\n    }\r\n    try {\r\n        String cmd = String.format(\"%s %s %d %d %d\\r\\n\", cmdname, key, flags, (expiry.getTime() / 1000), val.length);\r\n        sock.write(cmd.getBytes());\r\n        sock.write(val);\r\n        sock.write(\"\\r\\n\".getBytes());\r\n        sock.flush();\r\n        String line = sock.readLine();\r\n        if (log.isInfoEnabled())\r\n            log.info(\"++++ memcache cmd (result code): \" + cmd + \" (\" + line + \")\");\r\n        if (STORED.equals(line)) {\r\n            if (log.isInfoEnabled())\r\n                log.info(\"++++ data successfully stored for key: \" + key);\r\n            sock.close();\r\n            sock = null;\r\n            return true;\r\n        } else if (NOTSTORED.equals(line)) {\r\n            if (log.isInfoEnabled())\r\n                log.info(\"++++ data not stored in cache for key: \" + key);\r\n        } else {\r\n            log.error(\"++++ error storing data in cache for key: \" + key + \" -- length: \" + val.length);\r\n            log.error(\"++++ server response: \" + line);\r\n        }\r\n    } catch (IOException e) {\r\n        if (errorHandler != null)\r\n            errorHandler.handleErrorOnSet(this, e, key);\r\n        log.error(\"++++ exception thrown while writing bytes to server on set\");\r\n        log.error(e.getMessage(), e);\r\n        try {\r\n            sock.trueClose();\r\n        } catch (IOException ioe) {\r\n            log.error(\"++++ failed to close socket : \" + sock.toString());\r\n        }\r\n        sock = null;\r\n    }\r\n    if (sock != null) {\r\n        sock.close();\r\n        sock = null;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.msgpack.core.MessagePacker.packBigInteger",
	"Comment": "writes an integer value.this method writes an integer using the smallest format from the int format family.",
	"Method": "MessagePacker packBigInteger(BigInteger bi){\r\n    if (bi.bitLength() <= 63) {\r\n        packLong(bi.longValue());\r\n    } else if (bi.bitLength() == 64 && bi.signum() == 1) {\r\n        writeByteAndLong(UINT64, bi.longValue());\r\n    } else {\r\n        throw new IllegalArgumentException(\"MessagePack cannot serialize BigInteger larger than 2^64-1\");\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "mondrian.rolap.FilterTest.testNotInFilterKeepNullMember",
	"Comment": "test that if null member is not explicitly excluded, then the nativefilter sql should not filter out null members.",
	"Method": "void testNotInFilterKeepNullMember(){\r\n    propSaver.set(MondrianProperties.instance().ExpandNonNative, false);\r\n    propSaver.set(MondrianProperties.instance().EnableNativeFilter, true);\r\n    boolean requestFreshConnection = true;\r\n    String query = \"With \" + \"Set [*NATIVE_CJ_SET] as 'NonEmptyCrossJoin([*BASE_MEMBERS_Customers],[*BASE_MEMBERS_SQFT])' \" + \"Set [*BASE_MEMBERS_Customers] as 'Filter([Customers].[Country].Members, [Customers].CurrentMember In {[Customers].[All Customers].[USA]})' \" + \"Set [*BASE_MEMBERS_SQFT] as 'Filter([Store Size in SQFT].[Store Sqft].Members, [Store Size in SQFT].currentMember not in {[Store Size in SQFT].[All Store Size in SQFTs].[39696]})' \" + \"Set [*CJ_ROW_AXIS] as 'Generate([*NATIVE_CJ_SET], {([Customers].currentMember,[Store Size in SQFT].currentMember)})' \" + \"Set [*ORDERED_CJ_ROW_AXIS] as 'Order([*CJ_ROW_AXIS], [Store Size in SQFT].currentmember.OrderKey, BASC)' \" + \"Select \" + \"{[Measures].[Customer Count]} on columns, \" + \"Non Empty [*ORDERED_CJ_ROW_AXIS] on rows \" + \"From [Sales]\";\r\n    String result = \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Customer Count]}\\n\" + \"Axis #2:\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[#null]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[20319]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[21215]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[22478]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[23598]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[23688]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[27694]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[28206]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[30268]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[33858]}\\n\" + \"Row #0: 1,153\\n\" + \"Row #1: 563\\n\" + \"Row #2: 906\\n\" + \"Row #3: 296\\n\" + \"Row #4: 1,147\\n\" + \"Row #5: 1,059\\n\" + \"Row #6: 474\\n\" + \"Row #7: 190\\n\" + \"Row #8: 84\\n\" + \"Row #9: 278\\n\";\r\n    checkNative(0, 10, query, result, requestFreshConnection);\r\n}"
}, {
	"Path": "mondrian.test.TestContext.getSchema",
	"Comment": "returns a the xml of the current schema with added parameters and cubedefinitions.",
	"Method": "String getSchema(String parameterDefs,String cubeDefs,String virtualCubeDefs,String namedSetDefs,String udfDefs,String roleDefs){\r\n    String s = getRawFoodMartSchema();\r\n    if (parameterDefs != null) {\r\n        int i = s.indexOf(\"<Dimension name=\\\"Store\\\">\");\r\n        s = s.substring(0, i) + parameterDefs + s.substring(i);\r\n    }\r\n    if (cubeDefs != null) {\r\n        int i = s.indexOf(\"<Cube name=\\\"Sales\\\" defaultMeasure=\\\"Unit Sales\\\">\");\r\n        s = s.substring(0, i) + cubeDefs + s.substring(i);\r\n    }\r\n    if (virtualCubeDefs != null) {\r\n        int i = s.indexOf(\"<VirtualCube name=\\\"Warehouse and Sales\\\" \" + \"defaultMeasure=\\\"Store Sales\\\">\");\r\n        s = s.substring(0, i) + virtualCubeDefs + s.substring(i);\r\n    }\r\n    if (namedSetDefs != null) {\r\n        int i = s.indexOf(\"<Role\");\r\n        if (i < 0) {\r\n            i = s.indexOf(\"<\/Schema>\");\r\n        }\r\n        s = s.substring(0, i) + namedSetDefs + s.substring(i);\r\n    }\r\n    if (roleDefs != null) {\r\n        int i = s.indexOf(\"<UserDefinedFunction\");\r\n        if (i < 0) {\r\n            i = s.indexOf(\"<\/Schema>\");\r\n        }\r\n        s = s.substring(0, i) + roleDefs + s.substring(i);\r\n    }\r\n    if (udfDefs != null) {\r\n        int i = s.indexOf(\"<\/Schema>\");\r\n        s = s.substring(0, i) + udfDefs + s.substring(i);\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "mondrian.spi.SegmentHeader.getUniqueID",
	"Comment": "returns a unique identifier for this header. the identifiercan be used for storage and will be the same across segmentswhich have the same schema name, cube name, measure name,and for each constrained column, the same column name, table name,and predicate values.",
	"Method": "ByteString getUniqueID(){\r\n    if (this.uniqueID == null) {\r\n        StringBuilder hashSB = new StringBuilder();\r\n        hashSB.append(this.schemaName);\r\n        hashSB.append(this.schemaChecksum);\r\n        hashSB.append(this.cubeName);\r\n        hashSB.append(this.measureName);\r\n        for (SegmentColumn c : getSortedColumns()) {\r\n            hashSB.append(c.columnExpression);\r\n            if (c.values != null) {\r\n                for (Object value : c.values) {\r\n                    hashSB.append(String.valueOf(value));\r\n                }\r\n            }\r\n        }\r\n        for (SegmentColumn c : getSortedRegions()) {\r\n            hashSB.append(c.columnExpression);\r\n            if (c.values != null) {\r\n                for (Object value : c.values) {\r\n                    hashSB.append(String.valueOf(value));\r\n                }\r\n            }\r\n        }\r\n        for (String c : compoundPredicates) {\r\n            hashSB.append(c);\r\n        }\r\n        this.uniqueID = new ByteString(Util.digestSha256(hashSB.toString()));\r\n    }\r\n    return uniqueID;\r\n}"
}, {
	"Path": "mondrian.test.TestContext.assertAxisThrows",
	"Comment": "executes a query with a given expression on an axis, and asserts that itthrows an error which matches a particular pattern. the expression isevaulated against the default cube.",
	"Method": "void assertAxisThrows(String expression,String pattern){\r\n    Throwable throwable = null;\r\n    Connection connection = getConnection();\r\n    try {\r\n        final String cubeName = getDefaultCubeName();\r\n        final String queryString = \"select {\" + expression + \"} on columns from \" + cubeName;\r\n        Query query = connection.parseQuery(queryString);\r\n        connection.execute(query);\r\n    } catch (Throwable e) {\r\n        throwable = e;\r\n    }\r\n    checkThrowable(throwable, pattern);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Q.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Q appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AggregationKey.equal",
	"Comment": "returns whether two lists of compound predicates are equal.",
	"Method": "boolean equal(List<StarPredicate> list1,List<StarPredicate> list2){\r\n    if (list1 == null) {\r\n        return list2 == null;\r\n    }\r\n    if (list2 == null) {\r\n        return false;\r\n    }\r\n    final int size = list1.size();\r\n    if (size != list2.size()) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < size; i++) {\r\n        StarPredicate pred1 = list1.get(i);\r\n        StarPredicate pred2 = list2.get(i);\r\n        if (!pred1.equalConstraint(pred2)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Th.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Th appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentBuilderTest.runRollupTest",
	"Comment": "loads the cache with the results of the queriesin cachepopulatingqueries, and then attempts to rollup allcached segments based on the keepcolumns array, checkingagainst expectedheader.rolls up loading segmentin both forward and reverse order and verifiessame results both ways.",
	"Method": "Pair<SegmentHeader, SegmentBody> runRollupTest(String[] cachePopulatingQueries,String[] keepColumns,String expectedHeader){\r\n    propSaver.set(MondrianProperties.instance().OptimizePredicates, false);\r\n    TestContext context = loadCacheWithQueries(cachePopulatingQueries);\r\n    Map<SegmentHeader, SegmentBody> map = getReversibleTestMap(context, Order.FORWARD);\r\n    Set<String> keepColumnsSet = new HashSet<String>();\r\n    keepColumnsSet.addAll(Arrays.asList(keepColumns));\r\n    Pair<SegmentHeader, SegmentBody> rolledForward = // use a dummy\r\n    SegmentBuilder.rollup(// use a dummy\r\n    map, keepColumnsSet, BitKey.Factory.makeBitKey(new BitSet()), RolapAggregator.Sum, Dialect.Datatype.Numeric);\r\n    context = loadCacheWithQueries(cachePopulatingQueries);\r\n    map = getReversibleTestMap(context, Order.REVERSE);\r\n    Pair<SegmentHeader, SegmentBody> rolledReverse = SegmentBuilder.rollup(map, keepColumnsSet, BitKey.Factory.makeBitKey(new BitSet()), RolapAggregator.Sum, Dialect.Datatype.Numeric);\r\n    assertEquals(expectedHeader, removeJdkDependentStrings(rolledForward.getKey().toString()));\r\n    assertEquals(rolledForward.getKey(), rolledReverse.getKey());\r\n    assertEquals(rolledForward.getValue().getValueMap().size(), rolledReverse.getValue().getValueMap().size());\r\n    propSaver.reset();\r\n    return rolledForward;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.deleteDatabase",
	"Comment": "deletes a database including its journal file and other auxiliary filesthat may have been created by the database engine.",
	"Method": "boolean deleteDatabase(File file){\r\n    if (file == null) {\r\n        throw new IllegalArgumentException(\"file must not be null\");\r\n    }\r\n    boolean deleted = false;\r\n    deleted |= file.delete();\r\n    deleted |= new File(file.getPath() + \"-journal\").delete();\r\n    deleted |= new File(file.getPath() + \"-shm\").delete();\r\n    deleted |= new File(file.getPath() + \"-wal\").delete();\r\n    File dir = file.getParentFile();\r\n    if (dir != null) {\r\n        final String prefix = file.getName() + \"-mj\";\r\n        File[] files = dir.listFiles(new FileFilter() {\r\n            @Override\r\n            public boolean accept(File candidate) {\r\n                return candidate.getName().startsWith(prefix);\r\n            }\r\n        });\r\n        if (files != null) {\r\n            for (File masterJournal : files) {\r\n                deleted |= masterJournal.delete();\r\n            }\r\n        }\r\n    }\r\n    return deleted;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.deleteDatabase",
	"Comment": "deletes a database including its journal file and other auxiliary filesthat may have been created by the database engine.",
	"Method": "boolean deleteDatabase(File file){\r\n    return candidate.getName().startsWith(prefix);\r\n}"
}, {
	"Path": "mondrian.spi.impl.JdbcDialectFactory.acceptsConnection",
	"Comment": "returns whether this dialect is suitable for the given connection.",
	"Method": "boolean acceptsConnection(Connection connection){\r\n    try {\r\n        final DatabaseMetaData metaData = connection.getMetaData();\r\n        final String productName = metaData.getDatabaseProductName();\r\n        final String productVersion = metaData.getDatabaseProductVersion();\r\n        final Dialect.DatabaseProduct product = JdbcDialectImpl.getProduct(productName, productVersion);\r\n        return product == this.databaseProduct;\r\n    } catch (SQLException e) {\r\n        throw Util.newError(e, \"Error while instantiating dialect\");\r\n    }\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Frame.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Frame appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.olap.Query.compileExpression",
	"Comment": "compiles an expression, using a cached compiled expression if available.",
	"Method": "Calc compileExpression(Exp exp,boolean scalar,ResultStyle resultStyle){\r\n    statement.setQuery(this);\r\n    Evaluator evaluator = RolapEvaluator.create(statement);\r\n    final Validator validator = createValidator();\r\n    List<ResultStyle> resultStyleList;\r\n    resultStyleList = Collections.singletonList(resultStyle != null ? resultStyle : this.resultStyle);\r\n    final ExpCompiler compiler = createCompiler(evaluator, validator, resultStyleList);\r\n    if (scalar) {\r\n        return compiler.compileScalar(exp, false);\r\n    } else {\r\n        return compiler.compile(exp);\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.core.model.LatLong.getLatitudeE6",
	"Comment": "returns the latitude value in microdegrees of this coordinate.",
	"Method": "int getLatitudeE6(){\r\n    return LatLongUtils.degreesToMicrodegrees(this.latitude);\r\n}"
}, {
	"Path": "mondrian.tui.MockServletContext.getAttributeNames",
	"Comment": "returns an enumeration containing the attribute names available withinthis servlet context.",
	"Method": "Enumeration getAttributeNames(){\r\n    return Collections.enumeration(this.attributes.keySet());\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.StringHelper.generateRsaPrivateKey",
	"Comment": "generates a rsa private key with given modulus and private exponent",
	"Method": "PrivateKey generateRsaPrivateKey(BigInteger modulus,BigInteger privateExponent){\r\n    try {\r\n        return KeyFactory.getInstance(\"RSA\").generatePrivate(new RSAPrivateKeySpec(modulus, privateExponent));\r\n    } catch (Exception e) {\r\n        if (AppContext.DEBUG)\r\n            e.printStackTrace();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.olap.Util.lookupHierarchyLevel",
	"Comment": "finds a named level in this hierarchy. returns null if there is nosuch level.",
	"Method": "Level lookupHierarchyLevel(Hierarchy hierarchy,String s){\r\n    final Level[] levels = hierarchy.getLevels();\r\n    for (Level level : levels) {\r\n        if (level.getName().equalsIgnoreCase(s)) {\r\n            return level;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testExpandNestedNonNativeInputs",
	"Comment": "verify that evaluation is native for expressions with nested non nativeinputs that preduce memberlist results.",
	"Method": "void testExpandNestedNonNativeInputs(){\r\n    propSaver.set(MondrianProperties.instance().ExpandNonNative, true);\r\n    propSaver.set(MondrianProperties.instance().EnableNativeCrossJoin, true);\r\n    boolean requestFreshConnection = true;\r\n    checkNative(0, 6, \"select \" + \"NonEmptyCrossJoin(\" + \"  NonEmptyCrossJoin([Gender].Children, [Store].Children), \" + \"  [Product].Children) on columns \" + \"from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Gender].[F], [Store].[USA], [Product].[Drink]}\\n\" + \"{[Gender].[F], [Store].[USA], [Product].[Food]}\\n\" + \"{[Gender].[F], [Store].[USA], [Product].[Non-Consumable]}\\n\" + \"{[Gender].[M], [Store].[USA], [Product].[Drink]}\\n\" + \"{[Gender].[M], [Store].[USA], [Product].[Food]}\\n\" + \"{[Gender].[M], [Store].[USA], [Product].[Non-Consumable]}\\n\" + \"Row #0: 12,202\\n\" + \"Row #0: 94,814\\n\" + \"Row #0: 24,542\\n\" + \"Row #0: 12,395\\n\" + \"Row #0: 97,126\\n\" + \"Row #0: 25,694\\n\", requestFreshConnection);\r\n}"
}, {
	"Path": "org.jfaster.mango.parser.JJTParserState.popNode",
	"Comment": "returns the node on the top of the stack, and remove it from the stack.",
	"Method": "Node popNode(){\r\n    if (--sp < mk) {\r\n        mk = marks.remove(marks.size() - 1);\r\n    }\r\n    return nodes.remove(nodes.size() - 1);\r\n}"
}, {
	"Path": "mondrian.test.loader.MondrianFoodMartLoader.quoteId",
	"Comment": "quote the given sql identifier suitable for the given dbms type,with schema.",
	"Method": "String quoteId(String name,String quoteId,Dialect dialect,String name,String quoteId,String schemaName,String name,String quoteId,Dialect dialect,String schemaName,String name){\r\n    return dialect.quoteIdentifier(schemaName, name);\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.quickaction.QuickAction.show",
	"Comment": "show quickaction popup. popup is automatically positioned, on top orbottom of anchor view.",
	"Method": "void show(View anchor){\r\n    preShow();\r\n    int[] location = new int[2];\r\n    anchor.getLocationOnScreen(location);\r\n    Rect anchorRect = new Rect(location[0], location[1], location[0] + anchor.getWidth(), location[1] + anchor.getHeight());\r\n    mRootView.measure(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);\r\n    if (rootWidth == 0) {\r\n        rootWidth = mRootView.getMeasuredWidth();\r\n    }\r\n    int xPos, yPos;\r\n    xPos = anchorRect.left;\r\n    yPos = anchorRect.bottom;\r\n    mWindow.setAnimationStyle(R.style.Animations_Move);\r\n    mWindow.showAtLocation(anchor, Gravity.NO_GRAVITY, xPos, yPos);\r\n}"
}, {
	"Path": "org.jfaster.mango.parser.JJTParserState.nodeCreated",
	"Comment": "determines whether the current node was actually closed and pushed.this should only be called in the final user action of a node scope.",
	"Method": "boolean nodeCreated(){\r\n    return node_created;\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.quartile",
	"Comment": "returns the member which lies upon a particular quartile according to agiven expression.",
	"Method": "double quartile(Evaluator evaluator,TupleList members,Calc exp,int range){\r\n    assert range >= 1 && range <= 3;\r\n    SetWrapper sw = evaluateSet(evaluator, members, exp);\r\n    if (sw.errorCount > 0) {\r\n        return Double.NaN;\r\n    } else if (sw.v.size() == 0) {\r\n        return DoubleNull;\r\n    }\r\n    double[] asArray = new double[sw.v.size()];\r\n    for (int i = 0; i < asArray.length; i++) {\r\n        asArray[i] = ((Double) sw.v.get(i)).doubleValue();\r\n    }\r\n    Arrays.sort(asArray);\r\n    double dm = 0.25 * asArray.length * range;\r\n    int median = (int) Math.floor(dm);\r\n    return dm == median && median < asArray.length - 1 ? (asArray[median] + asArray[median + 1]) / 2 : asArray[median];\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteGlobal.getDefaultSyncMode",
	"Comment": "gets the default database synchronization mode when wal is not in use.",
	"Method": "String getDefaultSyncMode(){\r\n    return \"normal\";\r\n}"
}, {
	"Path": "mondrian.spi.SegmentHeader.canConstrain",
	"Comment": "checks if this header can be constrained by a given region.it will return false if the region covers one of the axis inits entirety.it will return false if the region sits outside of the boundsof this header. this means that when performing a flush operation,the header must be scrapped altogether.",
	"Method": "boolean canConstrain(SegmentColumn[] region){\r\n    boolean atLeastOnePresent = false;\r\n    for (SegmentColumn ccToFlush : region) {\r\n        SegmentColumn ccActual = getConstrainedColumn(ccToFlush.columnExpression);\r\n        if (ccActual != null) {\r\n            final SegmentColumn ccActualExcl = getExcludedRegion(ccToFlush.columnExpression);\r\n            if (ccToFlush.values == null || (ccActualExcl != null && ccActualExcl.values != null && ccActualExcl.merge(ccToFlush).values == null)) {\r\n                return false;\r\n            }\r\n            if (ccActual.values != null && ccActual.values.equals(ccToFlush.values)) {\r\n                return false;\r\n            }\r\n            atLeastOnePresent = true;\r\n        }\r\n    }\r\n    return atLeastOnePresent;\r\n}"
}, {
	"Path": "mondrian.olap.EnumeratedValues.makeImmutable",
	"Comment": "freezes the enumeration, preventing it from being further modified.",
	"Method": "void makeImmutable(){\r\n    ordinalToValueMap = new Value[1 + max - min];\r\n    for (Value value : valuesByName.values()) {\r\n        final int index = value.getOrdinal() - min;\r\n        if (ordinalToValueMap[index] != null) {\r\n            throw Util.newInternal(\"Enumeration has more than one value with ordinal \" + value.getOrdinal());\r\n        }\r\n        ordinalToValueMap[index] = value;\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCube.nonJoiningDimensions",
	"Comment": "finds out non joining dimensions for this cube.useful for finding out non joining dimensions for a stored measure froma base cube.",
	"Method": "Set<Dimension> nonJoiningDimensions(Member[] tuple,Set<Dimension> nonJoiningDimensions,Set<Dimension> otherDims){\r\n    Dimension[] baseCubeDimensions = getDimensions();\r\n    Set<String> baseCubeDimNames = new HashSet<String>();\r\n    for (Dimension baseCubeDimension : baseCubeDimensions) {\r\n        baseCubeDimNames.add(baseCubeDimension.getUniqueName());\r\n    }\r\n    Set<Dimension> nonJoiningDimensions = new HashSet<Dimension>();\r\n    for (Dimension otherDim : otherDims) {\r\n        if (!baseCubeDimNames.contains(otherDim.getUniqueName())) {\r\n            nonJoiningDimensions.add(otherDim);\r\n        }\r\n    }\r\n    return nonJoiningDimensions;\r\n}"
}, {
	"Path": "mondrian.test.TestCalculatedMembers.testCalculatedMemberInCubeWithSpace",
	"Comment": "tests a calculated member with spaces in its name against a virtualcube with spaces in its name.",
	"Method": "void testCalculatedMemberInCubeWithSpace(){\r\n    TestContext testContext = TestContext.instance().createSubstitutingCube(\"Warehouse and Sales\", null, \"<CalculatedMember name='Profit With Spaces'\" + \"  dimension='Measures'\" + \"  formula='[Measures].[Store Sales]-[Measures].[Store Cost]'/>\").withCube(\"Warehouse and Sales\");\r\n    Cell s = testContext.executeExprRaw(\"[Measures].[Profit With Spaces]\");\r\n    Assert.assertEquals(\"339,610.90\", s.getFormattedValue());\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteConnection.collectDbStats",
	"Comment": "collects statistics about database connection memory usage.",
	"Method": "void collectDbStats(ArrayList<DbStats> dbStatsList){\r\n    int lookaside = nativeGetDbLookaside(mConnectionPtr);\r\n    long pageCount = 0;\r\n    long pageSize = 0;\r\n    try {\r\n        pageCount = executeForLong(\"PRAGMA page_count;\", null, null);\r\n        pageSize = executeForLong(\"PRAGMA page_size;\", null, null);\r\n    } catch (SQLiteException ex) {\r\n    }\r\n    dbStatsList.add(getMainDbStatsUnsafe(lookaside, pageCount, pageSize));\r\n    CursorWindow window = new CursorWindow(\"collectDbStats\");\r\n    try {\r\n        executeForCursorWindow(\"PRAGMA database_list;\", null, window, 0, 0, false, null);\r\n        for (int i = 1; i < window.getNumRows(); i++) {\r\n            String name = window.getString(i, 1);\r\n            String path = window.getString(i, 2);\r\n            pageCount = 0;\r\n            pageSize = 0;\r\n            try {\r\n                pageCount = executeForLong(\"PRAGMA \" + name + \".page_count;\", null, null);\r\n                pageSize = executeForLong(\"PRAGMA \" + name + \".page_size;\", null, null);\r\n            } catch (SQLiteException ex) {\r\n            }\r\n            String label = \"  (attached) \" + name;\r\n            if (!path.isEmpty()) {\r\n                label += \": \" + path;\r\n            }\r\n            dbStatsList.add(new DbStats(label, pageCount, pageSize, 0, 0, 0, 0));\r\n        }\r\n    } catch (SQLiteException ex) {\r\n    } finally {\r\n        window.close();\r\n    }\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Colgroup.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Colgroup appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.needUpgrade",
	"Comment": "returns true if the new version code is greater than the current database version.",
	"Method": "boolean needUpgrade(int newVersion){\r\n    return newVersion > getVersion();\r\n}"
}, {
	"Path": "mondrian.rolap.BitKeyTest.testBadSize",
	"Comment": "test that negative size throws illegalargumentexception.",
	"Method": "void testBadSize(){\r\n    int size = -1;\r\n    boolean gotException = false;\r\n    BitKey bitKey = null;\r\n    try {\r\n        bitKey = BitKey.Factory.makeBitKey(size);\r\n        Util.discard(bitKey);\r\n    } catch (IllegalArgumentException e) {\r\n        gotException = true;\r\n    }\r\n    assertTrue(\"BitKey negative size \" + size, (gotException));\r\n    size = -10;\r\n    gotException = false;\r\n    try {\r\n        bitKey = BitKey.Factory.makeBitKey(size);\r\n    } catch (IllegalArgumentException e) {\r\n        gotException = true;\r\n    }\r\n    assertTrue(\"BitKey negative size \" + size, (gotException));\r\n}"
}, {
	"Path": "mondrian.olap.Query.setAxisShowEmptyCells",
	"Comment": "finds axis by index and sets flag to show empty cells on that axis.",
	"Method": "void setAxisShowEmptyCells(int axis,boolean showEmpty){\r\n    if (axis >= axes.length) {\r\n        throw MondrianResource.instance().MdxAxisShowSubtotalsNotSupported.ex(axis);\r\n    }\r\n    axes[axis].setNonEmpty(!showEmpty);\r\n}"
}, {
	"Path": "mondrian.olap.fun.vba.Vba.computeDiffInDays",
	"Comment": "this function tries to emulate the behaviour of datediff functionfrom vba. see a table of its resultshere.",
	"Method": "int computeDiffInDays(Calendar cal1,Calendar cal2){\r\n    boolean inverse;\r\n    if (cal2.getTimeInMillis() >= cal1.getTimeInMillis()) {\r\n        inverse = false;\r\n    } else {\r\n        inverse = true;\r\n        Calendar tmp = cal1;\r\n        cal1 = cal2;\r\n        cal2 = tmp;\r\n    }\r\n    Calendar floored2 = Interval.y.floor(cal2);\r\n    Calendar ceiled1 = Interval.y.floor(cal1);\r\n    if (ceiled1.getTimeInMillis() != cal1.getTimeInMillis()) {\r\n        ceiled1.add(Calendar.DATE, 1);\r\n    }\r\n    int delta = computeJdn(floored2) - computeJdn(ceiled1);\r\n    int rest1 = computeDelta(cal2, floored2);\r\n    int rest2 = computeDelta(ceiled1, cal1);\r\n    if ((rest1 + rest2) / MILLIS_IN_A_DAY >= 1) {\r\n        delta++;\r\n    }\r\n    return inverse ? -delta : delta;\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentCacheManager.externalSegmentDeleted",
	"Comment": "tells the cache that a segment is no longer available in an externalcache.",
	"Method": "void externalSegmentDeleted(SegmentHeader header,MondrianServer server){\r\n    if (MondrianProperties.instance().DisableCaching.get()) {\r\n        return;\r\n    }\r\n    ACTOR.event(handler, new ExternalSegmentDeletedEvent(System.currentTimeMillis(), server.getMonitor(), server.getId(), 0, 0, 0, this, header));\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.ui.widget.StaggeredGridView.setSelectionToTop",
	"Comment": "scroll the list so the first visible position in the grid is the first item in the adapter.",
	"Method": "void setSelectionToTop(){\r\n    removeAllViews();\r\n    resetStateForGridTop();\r\n    populate(false);\r\n}"
}, {
	"Path": "org.mapsforge.core.util.MercatorProjection.scaleFactorToZoomLevel",
	"Comment": "converts a scalefactor to a zoomlevel.note that this will return a double, as the scale factors cover theintermediate zoom levels as well.",
	"Method": "double scaleFactorToZoomLevel(double scaleFactor){\r\n    return Math.log(scaleFactor) / Math.log(2);\r\n}"
}, {
	"Path": "org.mapsforge.map.model.DisplayModel.getMaxTextWidth",
	"Comment": "returns the maximum width of text beyond which the text is broken into lines.",
	"Method": "int getMaxTextWidth(){\r\n    return maxTextWidth;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Dl.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Dl appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.test.TestCalculatedMembers.testNonCanonical",
	"Comment": "tests referring to a calc member by a name other than its canonicalunique name.",
	"Method": "void testNonCanonical(){\r\n    final String expected = \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Store].[USA].[Foo]}\\n\" + \"Row #0: 266,773\\n\";\r\n    assertQueryReturns(\"with member [Store].[USA].[Foo] as\\n\" + \" [Store].[USA] + [Store].[Canada].[BC]\\n\" + \"select [Store].[All Stores].[USA].[Foo] on 0\\n\" + \"from [Sales]\", expected);\r\n    assertQueryReturns(\"with member [Store].[All Stores].[USA].[Foo] as\\n\" + \" [Store].[USA] + [Store].[Canada].[BC]\\n\" + \"select [Store].[USA].[Foo] on 0\\n\" + \"from [Sales]\", expected);\r\n}"
}, {
	"Path": "org.mapsforge.core.util.MercatorProjection.pixelYToLatitude",
	"Comment": "converts a pixel y coordinate at a certain map size to a latitude coordinate.",
	"Method": "double pixelYToLatitude(double pixelY,long mapSize){\r\n    if (pixelY < 0 || pixelY > mapSize) {\r\n        throw new IllegalArgumentException(\"invalid pixelY coordinate \" + mapSize + \": \" + pixelY);\r\n    }\r\n    double y = 0.5 - (pixelY / mapSize);\r\n    return 90 - 360 * Math.atan(Math.exp(-y * (2 * Math.PI))) / Math.PI;\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.widget.LinearListView.getEmptyView",
	"Comment": "when the current adapter is empty, the linearlistview can display a specialview call the empty view. the empty view is used to provide feedback tothe user that no data is available in this linearlistview.",
	"Method": "View getEmptyView(){\r\n    return mEmptyView;\r\n}"
}, {
	"Path": "mondrian.test.PerformanceTest.testVeryLargeExplicitSet",
	"Comment": "tests performance when an mdx query contains a very large explicit set.",
	"Method": "void testVeryLargeExplicitSet(){\r\n    final TestContext testContext = getTestContext();\r\n    final Statistician[] statisticians = { new Statistician(\"testVeryLargeExplicitSet: Execute axis\"), new Statistician(\"testVeryLargeExplicitSet: Execute\"), new Statistician(\"testVeryLargeExplicitSet: Param query\") };\r\n    for (int i = 0; i < 10; i++) {\r\n        checkVeryLargeExplicitSet(statisticians, testContext);\r\n    }\r\n    for (Statistician statistician : statisticians) {\r\n        statistician.printDurations();\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.loader.MondrianFoodMartLoader.writeBatch",
	"Comment": "if we are outputting to jdbc, execute the given set of sql statementsotherwise, output the statements to a file.",
	"Method": "int writeBatch(List<String> sqls,long pauseMillis){\r\n    if (sqls.size() == 0) {\r\n        return sqls.size();\r\n    }\r\n    if (dialect.getDatabaseProduct() == Dialect.DatabaseProduct.INFOBRIGHT) {\r\n        for (String sql : sqls) {\r\n            fileOutput.write(sql);\r\n            fileOutput.write(nl);\r\n        }\r\n    } else if (outputDirectory != null) {\r\n        for (String sql : sqls) {\r\n            fileOutput.write(sql);\r\n            fileOutput.write(\";\" + nl);\r\n        }\r\n    } else {\r\n        final boolean useTxn;\r\n        if (dialect.getDatabaseProduct() == Dialect.DatabaseProduct.NEOVIEW) {\r\n            useTxn = false;\r\n        } else if (pauseMillis > 0) {\r\n            useTxn = false;\r\n            connection.setAutoCommit(true);\r\n        } else {\r\n            useTxn = connection.getMetaData().supportsTransactions();\r\n        }\r\n        if (useTxn) {\r\n            connection.setAutoCommit(false);\r\n        }\r\n        switch(dialect.getDatabaseProduct()) {\r\n            case LUCIDDB:\r\n            case NEOVIEW:\r\n                String VALUES_TOKEN = \"VALUES\";\r\n                StringBuilder sb = new StringBuilder(sqls.get(0));\r\n                for (int i = 1; i < sqls.size(); i++) {\r\n                    sb.append(\",\\n\");\r\n                    int valuesPos = sqls.get(i).indexOf(VALUES_TOKEN);\r\n                    if (valuesPos < 0) {\r\n                        throw new RuntimeException(\"Malformed INSERT:  \" + sqls.get(i));\r\n                    }\r\n                    valuesPos += VALUES_TOKEN.length();\r\n                    sb.append(sqls.get(i).substring(valuesPos));\r\n                }\r\n                sqls.clear();\r\n                sqls.add(sb.toString());\r\n        }\r\n        Statement stmt = connection.createStatement();\r\n        if (sqls.size() == 1) {\r\n            stmt.execute(sqls.get(0));\r\n        } else {\r\n            for (String sql : sqls) {\r\n                stmt.addBatch(sql);\r\n            }\r\n            int[] updateCounts;\r\n            try {\r\n                updateCounts = stmt.executeBatch();\r\n            } catch (SQLException e) {\r\n                for (String sql : sqls) {\r\n                    LOGGER.error(\"Error in SQL batch: \" + sql);\r\n                }\r\n                throw e;\r\n            }\r\n            int updates = 0;\r\n            for (int i = 0; i < updateCounts.length; updates += updateCounts[i], i++) {\r\n                if (updateCounts[i] == 0) {\r\n                    LOGGER.error(\"Error in SQL: \" + sqls.get(i));\r\n                }\r\n            }\r\n            if (updates < sqls.size()) {\r\n                throw new RuntimeException(\"Failed to execute batch: \" + sqls.size() + \" versus \" + updates);\r\n            }\r\n        }\r\n        stmt.close();\r\n        if (useTxn) {\r\n            connection.setAutoCommit(true);\r\n        }\r\n    }\r\n    return sqls.size();\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.DrawerFrameLayout.hasOnFixedItemClickListener",
	"Comment": "gets whether the drawer has a fixed item click listener set to it",
	"Method": "boolean hasOnFixedItemClickListener(){\r\n    return mDrawer.hasOnFixedItemClickListener();\r\n}"
}, {
	"Path": "mondrian.calc.impl.AbstractCalc.getName",
	"Comment": "returns the name of this expression type, used when serializing anexpression to a string.the default implementation tries to extract a name from a functioncall, if any, then prints the last part of the class name.",
	"Method": "String getName(){\r\n    String name = lastSegment(getClass());\r\n    if (isDigits(name) && exp instanceof ResolvedFunCall) {\r\n        ResolvedFunCall funCall = (ResolvedFunCall) exp;\r\n        name = funCall.getFunDef().getName();\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "org.springframework.extensions.jcr.TransactionAwareRepository.getTargetRepository",
	"Comment": "return the target jcr repository that this proxy delegates to.",
	"Method": "Repository getTargetRepository(){\r\n    return this.sessionFactory.getRepository();\r\n}"
}, {
	"Path": "mondrian.olap.ExpCacheDescriptor.getDependentHierarchyOrdinals",
	"Comment": "returns the ordinals of the hierarchies which this expression isdependent upon. when the cache descriptor is used to generate a cachekey, the key will consist of a member from each of these hierarchies.",
	"Method": "int[] getDependentHierarchyOrdinals(){\r\n    return dependentHierarchyOrdinals;\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.displayWarningOnFailedConnection",
	"Comment": "display jdbc connection status warning, if connection is uncsuccessful.",
	"Method": "void displayWarningOnFailedConnection(){\r\n    if (jdbcMetaData != null && jdbcMetaData.getErrMsg() != null) {\r\n        JOptionPane.showMessageDialog(this, getResourceConverter().getFormattedString(\"workbench.open.schema.jdbc.error\", \"Database connection could not be done.\\n{0}\\nAll validations related to database will be ignored.\", jdbcMetaData.getErrMsg()), getResourceConverter().getString(\"workbench.open.schema.jdbc.error.title\", \"Alert\"), JOptionPane.WARNING_MESSAGE);\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.map.android.input.MapZoomControls.setZoomLevelMax",
	"Comment": "sets the maximum zoom level of the map.the maximum possible zoom level of the mapview depends also on other elements. for example, downloading map tilesmay only be possible up to a certain zoom level. setting a higher maximum zoom level has no effect in this case.",
	"Method": "void setZoomLevelMax(byte zoomLevelMax){\r\n    if (zoomLevelMax < this.zoomLevelMin) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    this.zoomLevelMax = zoomLevelMax;\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlImpl.findMeasures",
	"Comment": "returns a list of members of the measures dimension which are mentionedsomewhere in a region specification.",
	"Method": "List<Member> findMeasures(CellRegion region){\r\n    final List<Member> list = new ArrayList<Member>();\r\n    final CellRegionVisitor visitor = new CellRegionVisitorImpl() {\r\n        public void visit(MemberCellRegion region) {\r\n            if (region.dimension.isMeasures()) {\r\n                list.addAll(region.memberList);\r\n            }\r\n        }\r\n        public void visit(MemberRangeCellRegion region) {\r\n            if (region.level.getDimension().isMeasures()) {\r\n                assert false : \"ranges on measures dimension\";\r\n            }\r\n        }\r\n    };\r\n    ((CellRegionImpl) region).accept(visitor);\r\n    return list;\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlImpl.findMeasures",
	"Comment": "returns a list of members of the measures dimension which are mentionedsomewhere in a region specification.",
	"Method": "List<Member> findMeasures(CellRegion region){\r\n    if (region.dimension.isMeasures()) {\r\n        list.addAll(region.memberList);\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlImpl.findMeasures",
	"Comment": "returns a list of members of the measures dimension which are mentionedsomewhere in a region specification.",
	"Method": "List<Member> findMeasures(CellRegion region){\r\n    if (region.level.getDimension().isMeasures()) {\r\n        assert false : \"ranges on measures dimension\";\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCube.getUsages",
	"Comment": "a hierarchy may have one or more hierarchyusages. this method returnsan array holding the one or more usages associated with a hierarchy.the hierarchyusages hierarchyname attribute always equals the nameattribute of the hierarchy.",
	"Method": "HierarchyUsage[] getUsages(Hierarchy hierarchy){\r\n    String name = hierarchy.getName();\r\n    if (!name.equals(hierarchy.getDimension().getName()) && MondrianProperties.instance().SsasCompatibleNaming.get()) {\r\n        name = hierarchy.getDimension().getName() + \".\" + name;\r\n    }\r\n    if (getLogger().isDebugEnabled()) {\r\n        getLogger().debug(\"RolapCube.getUsages: name=\" + name);\r\n    }\r\n    HierarchyUsage hierUsage = null;\r\n    List<HierarchyUsage> list = null;\r\n    for (HierarchyUsage hu : hierarchyUsages) {\r\n        if (hu.getHierarchyName().equals(name)) {\r\n            if (list != null) {\r\n                if (getLogger().isDebugEnabled()) {\r\n                    getLogger().debug(\"RolapCube.getUsages: \" + \"add list HierarchyUsage.name=\" + hu.getName());\r\n                }\r\n                list.add(hu);\r\n            } else if (hierUsage == null) {\r\n                hierUsage = hu;\r\n            } else {\r\n                list = new ArrayList<HierarchyUsage>();\r\n                if (getLogger().isDebugEnabled()) {\r\n                    getLogger().debug(\"RolapCube.getUsages: \" + \"add list hierUsage.name=\" + hierUsage.getName() + \", hu.name=\" + hu.getName());\r\n                }\r\n                list.add(hierUsage);\r\n                list.add(hu);\r\n                hierUsage = null;\r\n            }\r\n        }\r\n    }\r\n    if (hierUsage != null) {\r\n        return new HierarchyUsage[] { hierUsage };\r\n    } else if (list != null) {\r\n        if (getLogger().isDebugEnabled()) {\r\n            getLogger().debug(\"RolapCube.getUsages: return list\");\r\n        }\r\n        return list.toArray(new HierarchyUsage[list.size()]);\r\n    } else {\r\n        return new HierarchyUsage[0];\r\n    }\r\n}"
}, {
	"Path": "mondrian.mdx.ResolvedFunCall.getFunDef",
	"Comment": "returns the definition of the function which is being called.",
	"Method": "FunDef getFunDef(){\r\n    return funDef;\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.model.TDWay.fromWay",
	"Comment": "creates a new tdway from an osmosis way entity using the given noderesolver.",
	"Method": "TDWay fromWay(Way way,NodeResolver resolver,List<String> preferredLanguages){\r\n    if (way == null)\r\n        return null;\r\n    SpecialTagExtractionResult ster = OSMUtils.extractSpecialFields(way, preferredLanguages);\r\n    Map<Short, Object> knownWayTags = OSMUtils.extractKnownWayTags(way);\r\n    if (way.getWayNodes().size() >= 2) {\r\n        boolean validWay = true;\r\n        TDNode[] waynodes = new TDNode[way.getWayNodes().size()];\r\n        int i = 0;\r\n        for (WayNode waynode : way.getWayNodes()) {\r\n            waynodes[i] = resolver.getNode(waynode.getNodeId());\r\n            if (waynodes[i] == null) {\r\n                validWay = false;\r\n                LOGGER.finer(\"unknown way node: \" + waynode.getNodeId() + \" in way \" + way.getId());\r\n            }\r\n            i++;\r\n        }\r\n        if (validWay) {\r\n            byte shape = LINE;\r\n            if (waynodes[0].getId() == waynodes[waynodes.length - 1].getId()) {\r\n                if (waynodes.length >= GeoUtils.MIN_NODES_POLYGON) {\r\n                    if (OSMUtils.isArea(way)) {\r\n                        shape = SIMPLE_POLYGON;\r\n                    }\r\n                } else {\r\n                    LOGGER.finer(\"Found closed polygon with fewer than 4 way nodes. Way-id: \" + way.getId());\r\n                    return null;\r\n                }\r\n            }\r\n            return new TDWay(way.getId(), ster.getLayer(), ster.getName(), ster.getHousenumber(), ster.getRef(), knownWayTags, shape, waynodes);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.sqlite.database.DatabaseUtils.concatenateWhere",
	"Comment": "concatenates two sql where clauses, handling empty or null values.",
	"Method": "String concatenateWhere(String a,String b){\r\n    if (TextUtils.isEmpty(a)) {\r\n        return b;\r\n    }\r\n    if (TextUtils.isEmpty(b)) {\r\n        return a;\r\n    }\r\n    return \"(\" + a + \") AND (\" + b + \")\";\r\n}"
}, {
	"Path": "mondrian.test.TestContext.assertAxisReturns",
	"Comment": "executes a query with a given expression on an axis, and asserts that itreturns the expected string.",
	"Method": "void assertAxisReturns(String expression,String expected){\r\n    Axis axis = executeAxis(expression);\r\n    assertEqualsVerbose(expected, upgradeActual(toString(axis.getPositions())));\r\n}"
}, {
	"Path": "mondrian.olap.Query.setQueryTimeoutMillis",
	"Comment": "sets the timeout in milliseconds of this query.zero means no timeout.",
	"Method": "void setQueryTimeoutMillis(long queryTimeoutMillis){\r\n    statement.setQueryTimeoutMillis(queryTimeoutMillis);\r\n}"
}, {
	"Path": "mondrian.olap.type.DecimalType.getScale",
	"Comment": "returns the number of digits to the right of the decimal point.",
	"Method": "int getScale(){\r\n    return scale;\r\n}"
}, {
	"Path": "org.sqlite.database.DatabaseUtils.appendSelectionArgs",
	"Comment": "appends one set of selection args to another. this is useful when adding a selectionargument to a user provided set.",
	"Method": "String[] appendSelectionArgs(String[] originalValues,String[] newValues){\r\n    if (originalValues == null || originalValues.length == 0) {\r\n        return newValues;\r\n    }\r\n    String[] result = new String[originalValues.length + newValues.length];\r\n    System.arraycopy(originalValues, 0, result, 0, originalValues.length);\r\n    System.arraycopy(newValues, 0, result, originalValues.length, newValues.length);\r\n    return result;\r\n}"
}, {
	"Path": "mondrian.test.TestContext.assertExprDependsOn",
	"Comment": "asserts that an mdx expression depends upon a given list of dimensions.",
	"Method": "void assertExprDependsOn(String expr,String hierList){\r\n    final Connection connection = getConnection();\r\n    final String queryString = \"WITH MEMBER [Measures].[Foo] AS \" + Util.singleQuoteString(expr) + \" SELECT FROM [Sales]\";\r\n    final Query query = connection.parseQuery(queryString);\r\n    query.resolve();\r\n    final Formula formula = query.getFormulas()[0];\r\n    final Exp expression = formula.getExpression();\r\n    checkDependsOn(query, expression, hierList, true);\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.getMinConn",
	"Comment": "returns the minimum number of spare connections in available pool.",
	"Method": "int getMinConn(){\r\n    return this.minConn;\r\n}"
}, {
	"Path": "mondrian.util.Pair.compare",
	"Comment": "compares a pair of comparable values of the same type. null collatesless than everything else, but equal to itself.",
	"Method": "int compare(C c1,C c2){\r\n    if (c1 == null) {\r\n        if (c2 == null) {\r\n            return 0;\r\n        } else {\r\n            return -1;\r\n        }\r\n    } else if (c2 == null) {\r\n        return 1;\r\n    } else {\r\n        return c1.compareTo(c2);\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.map.android.util.MapViewerTemplate.getPersistableId",
	"Comment": "the persistable id is used to store settings information, like the center of the last viewand the zoomlevel. by default the simple name of the class is used. the value is not uservisibile.",
	"Method": "String getPersistableId(){\r\n    return this.getClass().getSimpleName();\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Option.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Option appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Abbr.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Abbr appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.AggGen.insertIntoLost",
	"Comment": "return the sql code to populate a lost dimension table from the facttable.",
	"Method": "String insertIntoLost(){\r\n    StringWriter sw = new StringWriter(512);\r\n    PrintWriter pw = new PrintWriter(sw);\r\n    String prefix = \"    \";\r\n    String factTableName = getFactTableName();\r\n    SqlQuery sqlQuery = getSqlQuery();\r\n    pw.print(\"INSERT INTO \");\r\n    pw.print(makeLostAggregateTableName(getFactTableName()));\r\n    pw.println(\" (\");\r\n    for (JdbcSchema.Table.Column.Usage usage : notLostColumnUsages) {\r\n        JdbcSchema.Table.Column c = usage.getColumn();\r\n        pw.print(prefix);\r\n        pw.print(c.getName());\r\n        pw.println(',');\r\n    }\r\n    for (JdbcSchema.Table.Column.Usage usage : measures) {\r\n        JdbcSchema.Table.Column c = usage.getColumn();\r\n        pw.print(prefix);\r\n        String name = getUsageName(usage);\r\n        pw.print(name);\r\n        pw.println(',');\r\n    }\r\n    pw.print(prefix);\r\n    pw.print(getFactCount());\r\n    pw.println(\")\");\r\n    pw.println(\"SELECT\");\r\n    for (JdbcSchema.Table.Column.Usage usage : notLostColumnUsages) {\r\n        JdbcSchema.Table.Column c = usage.getColumn();\r\n        pw.print(prefix);\r\n        pw.print(sqlQuery.getDialect().quoteIdentifier(factTableName, c.getName()));\r\n        pw.print(\" AS \");\r\n        pw.print(sqlQuery.getDialect().quoteIdentifier(c.getName()));\r\n        pw.println(',');\r\n    }\r\n    for (JdbcSchema.Table.Column.Usage usage : measures) {\r\n        JdbcSchema.Table.Column c = usage.getColumn();\r\n        RolapAggregator agg = usage.getAggregator();\r\n        pw.print(prefix);\r\n        pw.print(agg.getExpression(sqlQuery.getDialect().quoteIdentifier(factTableName, c.getName())));\r\n        pw.print(\" AS \");\r\n        pw.print(sqlQuery.getDialect().quoteIdentifier(c.getName()));\r\n        pw.println(',');\r\n    }\r\n    pw.print(prefix);\r\n    pw.print(\"COUNT(*) AS \");\r\n    pw.println(sqlQuery.getDialect().quoteIdentifier(getFactCount()));\r\n    pw.println(\"FROM \");\r\n    pw.print(prefix);\r\n    pw.print(sqlQuery.getDialect().quoteIdentifier(factTableName));\r\n    pw.print(\" \");\r\n    pw.println(sqlQuery.getDialect().quoteIdentifier(factTableName));\r\n    pw.println(\"GROUP BY \");\r\n    int k = 0;\r\n    for (JdbcSchema.Table.Column.Usage notLostColumnUsage : notLostColumnUsages) {\r\n        if (k++ > 0) {\r\n            pw.println(\",\");\r\n        }\r\n        JdbcSchema.Table.Column.Usage usage = notLostColumnUsage;\r\n        JdbcSchema.Table.Column c = usage.getColumn();\r\n        pw.print(prefix);\r\n        pw.print(sqlQuery.getDialect().quoteIdentifier(factTableName, c.getName()));\r\n    }\r\n    pw.println(';');\r\n    return sw.toString();\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentLoader.cacheSegment",
	"Comment": "called when a segment has been loaded from sql, to put into the segmentindex and the external cache.",
	"Method": "void cacheSegment(RolapStar star,SegmentHeader header,SegmentBody body){\r\n    if (!MondrianProperties.instance().DisableCaching.get()) {\r\n        cacheMgr.compositeCache.put(header, body);\r\n        cacheMgr.loadSucceeded(star, header, body);\r\n    }\r\n}"
}, {
	"Path": "mondrian.util.LockBox.deregister",
	"Comment": "removes an entry from the lock box.it is safe to call this method multiple times.",
	"Method": "boolean deregister(Entry entry){\r\n    return map.remove(entry) != null;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCube.createDummyExp",
	"Comment": "creates an expression that compiles to a given compiled expression.use this for synthetic expressions that do not correspond to anythingin an mdx parse tree, and just need to compile to a particular compiledexpression. the expression has minimal amounts of metadata, for exampletype information, but the function has no name or description.",
	"Method": "Exp createDummyExp(Calc calc){\r\n    return new ResolvedFunCall(new FunDefBase(\"dummy\", null, \"fn\") {\r\n        public Calc compileCall(ResolvedFunCall call, ExpCompiler compiler) {\r\n            return calc;\r\n        }\r\n    }, new Exp[0], calc.getType());\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCube.createDummyExp",
	"Comment": "creates an expression that compiles to a given compiled expression.use this for synthetic expressions that do not correspond to anythingin an mdx parse tree, and just need to compile to a particular compiledexpression. the expression has minimal amounts of metadata, for exampletype information, but the function has no name or description.",
	"Method": "Exp createDummyExp(Calc calc){\r\n    return calc;\r\n}"
}, {
	"Path": "org.mapsforge.map.layer.Layer.onLongPress",
	"Comment": "handles a long press event. a long press event is only triggered if the map was not moved. a return value of trueindicates that the long press event has been handled by this overlay and stops its propagation to other overlays.the default implementation of this method does nothing and returns false.",
	"Method": "boolean onLongPress(LatLong tapLatLong,Point layerXY,Point tapXY){\r\n    return false;\r\n}"
}, {
	"Path": "com.mycollab.core.utils.Emoji.replaceInText",
	"Comment": "converts between emoticons and their corresponding unicode emoji in the\tgiven text",
	"Method": "String replaceInText(String text,String replaceInText,String text,boolean reverse){\r\n    final ReplacementsMap replacements = ReplacementsMap.getInstance();\r\n    String emoticon;\r\n    Integer codepoint;\r\n    for (Map.Entry<String, Integer> entry : replacements.entrySet()) {\r\n        if (entry != null) {\r\n            emoticon = entry.getKey();\r\n            codepoint = entry.getValue();\r\n            if (emoticon != null && codepoint != null) {\r\n                String unicodeChar = getUnicodeChar(codepoint.intValue());\r\n                if (reverse) {\r\n                    text = text.replace(unicodeChar, emoticon);\r\n                } else {\r\n                    text = text.replaceAll(getEmoticonSearchRegex(emoticon), unicodeChar);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return text;\r\n}"
}, {
	"Path": "mondrian.test.TestContext.executeExprRaw",
	"Comment": "executes the expression in the context of the cube indicated bycubename, and returns the result as a cell.",
	"Method": "Cell executeExprRaw(String expression){\r\n    final String queryString = generateExpression(expression);\r\n    Result result = executeQuery(queryString);\r\n    return result.getCell(new int[] { 0 });\r\n}"
}, {
	"Path": "mondrian.spi.SegmentHeader.clone",
	"Comment": "creates a clone of this header by replacing some of theconstrained columns in the process.",
	"Method": "SegmentHeader clone(SegmentColumn[] overrideValues){\r\n    Map<String, SegmentColumn> colsToAdd = new HashMap<String, SegmentColumn>();\r\n    for (SegmentColumn cc : this.constrainedColumns) {\r\n        colsToAdd.put(cc.columnExpression, cc);\r\n    }\r\n    for (SegmentColumn override : overrideValues) {\r\n        colsToAdd.put(override.columnExpression, override);\r\n    }\r\n    return new SegmentHeader(schemaName, schemaChecksum, cubeName, measureName, new ArrayList<SegmentColumn>(colsToAdd.values()), Collections.<String>emptyList(), rolapStarFactTableName, constrainedColsBitKey, Collections.<SegmentColumn>emptyList());\r\n}"
}, {
	"Path": "mondrian.olap.Walker.getChildren",
	"Comment": "override this function to prune the tree, or to allow objects which arenot walkable to have children.",
	"Method": "Object[] getChildren(Object node,Object[] getChildren){\r\n    if (node instanceof Walkable) {\r\n        return ((Walkable) node).getChildren();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testCjNullInEnum",
	"Comment": "set containing only null member should not prevent usage of native.",
	"Method": "void testCjNullInEnum(){\r\n    propSaver.set(MondrianProperties.instance().IgnoreInvalidMembersDuringQuery, true);\r\n    checkNative(20, 0, \"select {[Measures].[Unit Sales]} ON COLUMNS, \" + \"NON EMPTY Crossjoin({[Gender].[All Gender].[emale]}, [Customers].[All Customers].[USA].children) ON ROWS \" + \"from [Sales] \");\r\n}"
}, {
	"Path": "mondrian.xmla.Rowset.makeCondition",
	"Comment": "creates a condition functor using an accessor.the accessor gets a particular property of the element in questionfor the column restrictions to act upon.",
	"Method": "Util.Functor1<Boolean, E> makeCondition(RowsetDefinition.Column column,Util.Functor1<Boolean, E> makeCondition,Util.Functor1<V, ? super E> getter,RowsetDefinition.Column column){\r\n    final Object restriction = restrictions.get(column.name);\r\n    if (restriction == null) {\r\n        return Util.trueFunctor();\r\n    } else if (restriction instanceof XmlaUtil.Wildcard) {\r\n        XmlaUtil.Wildcard wildcard = (XmlaUtil.Wildcard) restriction;\r\n        String regexp = Util.wildcardToRegexp(Collections.singletonList(wildcard.pattern));\r\n        final Matcher matcher = Pattern.compile(regexp).matcher(\"\");\r\n        return new Util.Functor1<Boolean, E>() {\r\n            public Boolean apply(E element) {\r\n                V value = getter.apply(element);\r\n                return matcher.reset(String.valueOf(value)).matches();\r\n            }\r\n        };\r\n    } else if (restriction instanceof List) {\r\n        final List<V> requiredValues = (List) restriction;\r\n        return new Util.Functor1<Boolean, E>() {\r\n            public Boolean apply(E element) {\r\n                if (element == null) {\r\n                    return requiredValues.contains(\"\");\r\n                }\r\n                V value = getter.apply(element);\r\n                return requiredValues.contains(value);\r\n            }\r\n        };\r\n    } else {\r\n        throw Util.newInternal(\"unexpected restriction type: \" + restriction.getClass());\r\n    }\r\n}"
}, {
	"Path": "mondrian.xmla.Rowset.makeCondition",
	"Comment": "creates a condition functor using an accessor.the accessor gets a particular property of the element in questionfor the column restrictions to act upon.",
	"Method": "Util.Functor1<Boolean, E> makeCondition(RowsetDefinition.Column column,Util.Functor1<Boolean, E> makeCondition,Util.Functor1<V, ? super E> getter,RowsetDefinition.Column column){\r\n    V value = getter.apply(element);\r\n    return matcher.reset(String.valueOf(value)).matches();\r\n}"
}, {
	"Path": "mondrian.xmla.Rowset.makeCondition",
	"Comment": "creates a condition functor using an accessor.the accessor gets a particular property of the element in questionfor the column restrictions to act upon.",
	"Method": "Util.Functor1<Boolean, E> makeCondition(RowsetDefinition.Column column,Util.Functor1<Boolean, E> makeCondition,Util.Functor1<V, ? super E> getter,RowsetDefinition.Column column){\r\n    if (element == null) {\r\n        return requiredValues.contains(\"\");\r\n    }\r\n    V value = getter.apply(element);\r\n    return requiredValues.contains(value);\r\n}"
}, {
	"Path": "mondrian.test.CacheHitTest.testSmallSetVCRandom",
	"Comment": "runs a set of small mdx queries that targets a small regionof aggregation cache in random order. all queries referencethe virtual warehouse and sales cube.",
	"Method": "void testSmallSetVCRandom(){\r\n    TestSuite suite = new TestSuite();\r\n    suite.addTest(PartialCacheVCTest.suite());\r\n    suite.addTest(MultiLevelVCTest.suite());\r\n    suite.addTest(MultiDimVCTest.suite());\r\n    suite.addTest(QueryAllVCTest.suite());\r\n    System.out.println(\"== \" + this.getName() + \" ==\");\r\n    runRandomSuite(suite, 200);\r\n    clearCache(\"Warehouse and Sales\");\r\n}"
}, {
	"Path": "mondrian.test.TestContext.executeAxis",
	"Comment": "executes a query with a given expression on an axis, and returns thewhole axis.",
	"Method": "Axis executeAxis(String expression){\r\n    Result result = executeQuery(\"select {\" + expression + \"} on columns from \" + getDefaultCubeName());\r\n    return result.getAxes()[0];\r\n}"
}, {
	"Path": "mondrian.olap.Util.getAnnotation",
	"Comment": "returns an annotation of a particular class on a method. returns thedefault value if the annotation is not present, or in jdk 1.4.",
	"Method": "T getAnnotation(Method method,String annotationClassName,T defaultValue){\r\n    return compatible.getAnnotation(method, annotationClassName, defaultValue);\r\n}"
}, {
	"Path": "mondrian.mdx.MdxVisitorImpl.visitArray",
	"Comment": "visits an array of expressions. returns the same array if none of theexpressions are changed, otherwise a new array.",
	"Method": "Exp[] visitArray(Exp[] args){\r\n    Exp[] newArgs = args;\r\n    for (int i = 0; i < args.length; i++) {\r\n        Exp arg = args[i];\r\n        Exp newArg = (Exp) arg.accept(this);\r\n        if (newArg != arg) {\r\n            if (newArgs == args) {\r\n                newArgs = args.clone();\r\n            }\r\n            newArgs[i] = newArg;\r\n        }\r\n    }\r\n    return newArgs;\r\n}"
}, {
	"Path": "mondrian.spi.impl.FilterDynamicSchemaProcessor.filter",
	"Comment": "reads the contents of a schema as a stream and returns the result asa string.the default implementation returns the contents of the schemaunchanged.",
	"Method": "String filter(String schemaUrl,Util.PropertyList connectInfo,InputStream stream){\r\n    BufferedReader in = new BufferedReader(new InputStreamReader(stream));\r\n    try {\r\n        StringBuilder builder = new StringBuilder();\r\n        char[] buf = new char[2048];\r\n        int readCount;\r\n        while ((readCount = in.read(buf, 0, buf.length)) >= 0) {\r\n            builder.append(buf, 0, readCount);\r\n        }\r\n        return builder.toString();\r\n    } finally {\r\n        in.close();\r\n    }\r\n}"
}, {
	"Path": "mondrian.tui.MockServletContext.removeAttribute",
	"Comment": "removes the attribute with the given name from the servlet context.",
	"Method": "void removeAttribute(String s){\r\n    this.attributes.remove(s);\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.StringHelper.generateRsaPublicKey",
	"Comment": "generates a rsa public key with given modulus and public exponent",
	"Method": "PublicKey generateRsaPublicKey(BigInteger modulus,BigInteger publicExponent){\r\n    try {\r\n        return KeyFactory.getInstance(\"RSA\").generatePublic(new RSAPublicKeySpec(modulus, publicExponent));\r\n    } catch (Exception e) {\r\n        if (AppContext.DEBUG)\r\n            e.printStackTrace();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapEvaluator.getActiveNativeExpansions",
	"Comment": "set of expressions actively being expanded. prevents infinite cycle ofexpansions.",
	"Method": "Set<Exp> getActiveNativeExpansions(){\r\n    return root.activeNativeExpansions;\r\n}"
}, {
	"Path": "mondrian.tui.XmlaSupport.validateXmlaUsingXpath",
	"Comment": "this validates a xmla response using xpaths to extract theschema and data parts. in addition, it does a little surgery onthe doms removing the schema nodes from the xmla root node.",
	"Method": "boolean validateXmlaUsingXpath(byte[] bytes){\r\n    if (!XmlUtil.supportsValidation()) {\r\n        return false;\r\n    }\r\n    bytes = removeUtfBom(bytes);\r\n    Node[] nodes = extractNodesFromXmla(bytes);\r\n    return validateNodes(nodes);\r\n}"
}, {
	"Path": "mondrian.tui.MockServletContext.getNamedDispatcher",
	"Comment": "returns a requestdispatcher object that acts as a wrapper for the namedservlet.",
	"Method": "RequestDispatcher getNamedDispatcher(String s){\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.olap.Query.canRemoveFormula",
	"Comment": "returns whether a formula can safely be removed from the query. it can beremoved if the member or set it defines it not used anywhere else in thequery, including in another formula.",
	"Method": "boolean canRemoveFormula(String uniqueName){\r\n    Formula formula = findFormula(uniqueName);\r\n    if (formula == null) {\r\n        return false;\r\n    }\r\n    OlapElement mdxElement = formula.getElement();\r\n    Walker walker = new Walker(this);\r\n    while (walker.hasMoreElements()) {\r\n        Object queryElement = walker.nextElement();\r\n        if (queryElement instanceof MemberExpr && ((MemberExpr) queryElement).getMember().equals(mdxElement)) {\r\n            return false;\r\n        }\r\n        if (queryElement instanceof NamedSetExpr && ((NamedSetExpr) queryElement).getNamedSet().equals(mdxElement)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.Recognizer.makeLevelColumnUsage",
	"Comment": "make a level column usage. note there is a check in this code. if a given aggregate tablecolumn has already has a level usage, then that usage must all refer tothe same hierarchy usage join table and column name as the one thatcalling this method was to create. if there is an existing level usagefor the column and it matches something else, then it is an error.",
	"Method": "void makeLevelColumnUsage(JdbcSchema.Table.Column aggColumn,Hierarchy hierarchy,HierarchyUsage hierarchyUsage,String factColumnName,String levelColumnName,String symbolicName,boolean isCollapsed,RolapLevel rLevel,JdbcSchema.Table.Column ordinalColumn,JdbcSchema.Table.Column captionColumn,Map<String, JdbcSchema.Table.Column> properties){\r\n    msgRecorder.pushContextName(\"Recognizer.makeLevelColumnUsage\");\r\n    try {\r\n        if (aggColumn.hasUsage(JdbcSchema.UsageType.LEVEL)) {\r\n            for (Iterator<JdbcSchema.Table.Column.Usage> uit = aggColumn.getUsages(JdbcSchema.UsageType.LEVEL); uit.hasNext(); ) {\r\n                JdbcSchema.Table.Column.Usage aggUsage = uit.next();\r\n                MondrianDef.Relation rel = hierarchyUsage.getJoinTable();\r\n                if (!aggUsageMatchesHierarchyUsage(aggUsage, hierarchyUsage, levelColumnName)) {\r\n                    String msg = mres.DoubleMatchForLevel.str(aggTable.getName(), dbFactTable.getName(), aggColumn.getName(), aggUsage.relation.toString(), aggColumn.column.name, rel.toString(), levelColumnName);\r\n                    msgRecorder.reportError(msg);\r\n                    returnValue = false;\r\n                    msgRecorder.throwRTException();\r\n                }\r\n            }\r\n        } else {\r\n            JdbcSchema.Table.Column.Usage aggUsage = aggColumn.newUsage(JdbcSchema.UsageType.LEVEL);\r\n            aggUsage.relation = hierarchyUsage.getJoinTable();\r\n            aggUsage.joinExp = hierarchyUsage.getJoinExp();\r\n            aggUsage.levelColumnName = levelColumnName;\r\n            aggUsage.rightJoinConditionColumnName = levelColumnName;\r\n            aggUsage.collapsed = isCollapsed;\r\n            aggUsage.level = rLevel;\r\n            aggUsage.captionColumn = captionColumn;\r\n            aggUsage.ordinalColumn = ordinalColumn;\r\n            aggUsage.properties = properties;\r\n            makeLevelExtraUsages(aggUsage.captionColumn, aggUsage.ordinalColumn, aggUsage.properties);\r\n            aggUsage.setSymbolicName(symbolicName);\r\n            String tableAlias;\r\n            if (aggUsage.joinExp instanceof MondrianDef.Column) {\r\n                MondrianDef.Column mcolumn = (MondrianDef.Column) aggUsage.joinExp;\r\n                tableAlias = mcolumn.table;\r\n            } else {\r\n                tableAlias = aggUsage.relation.getAlias();\r\n            }\r\n            RolapStar.Table factTable = star.getFactTable();\r\n            RolapStar.Table descTable = factTable.findDescendant(tableAlias);\r\n            if (descTable == null) {\r\n                StringBuilder buf = new StringBuilder(256);\r\n                buf.append(\"descendant table is null for factTable=\");\r\n                buf.append(factTable.getAlias());\r\n                buf.append(\", tableAlias=\");\r\n                buf.append(tableAlias);\r\n                msgRecorder.reportError(buf.toString());\r\n                returnValue = false;\r\n                msgRecorder.throwRTException();\r\n            }\r\n            RolapStar.Column rc = descTable.lookupColumn(factColumnName);\r\n            if (rc == null) {\r\n                rc = lookupInChildren(descTable, factColumnName);\r\n            }\r\n            if (rc == null && hierarchyUsage.getUsagePrefix() != null) {\r\n                rc = descTable.lookupColumn(factColumnName.substring(hierarchyUsage.getUsagePrefix().length()));\r\n            }\r\n            if (rc == null) {\r\n                StringBuilder buf = new StringBuilder(256);\r\n                buf.append(\"Rolap.Column not found (null) for tableAlias=\");\r\n                buf.append(tableAlias);\r\n                buf.append(\", factColumnName=\");\r\n                buf.append(factColumnName);\r\n                buf.append(\", levelColumnName=\");\r\n                buf.append(levelColumnName);\r\n                buf.append(\", symbolicName=\");\r\n                buf.append(symbolicName);\r\n                msgRecorder.reportError(buf.toString());\r\n                returnValue = false;\r\n                msgRecorder.throwRTException();\r\n            } else {\r\n                aggUsage.rColumn = rc;\r\n            }\r\n        }\r\n    } finally {\r\n        msgRecorder.popContextName();\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.RolapMemberBase.getPropertyFromMap",
	"Comment": "returns the value of a property by looking it up in the property map.",
	"Method": "Object getPropertyFromMap(String propertyName,boolean matchCase){\r\n    synchronized (this) {\r\n        if (matchCase) {\r\n            return mapPropertyNameToValue.get(propertyName);\r\n        } else {\r\n            for (String key : mapPropertyNameToValue.keySet()) {\r\n                if (key.equalsIgnoreCase(propertyName)) {\r\n                    return mapPropertyNameToValue.get(key);\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.addSocketToPool",
	"Comment": "adds a socket to a given pool for the given host.\tthis method is not threadsafe, so be careful when using!\tinternal utility method.",
	"Method": "void addSocketToPool(Map<String, Map<SockIO, Long>> pool,String host,SockIO socket){\r\n    if (pool.containsKey(host)) {\r\n        Map<SockIO, Long> sockets = pool.get(host);\r\n        if (sockets != null) {\r\n            sockets.put(socket, new Long(System.currentTimeMillis()));\r\n            return;\r\n        }\r\n    }\r\n    Map<SockIO, Long> sockets = new IdentityHashMap<SockIO, Long>();\r\n    sockets.put(socket, new Long(System.currentTimeMillis()));\r\n    pool.put(host, sockets);\r\n}"
}, {
	"Path": "mondrian.rolap.TestAggregationManager.testColumnCadinalityCache",
	"Comment": "test that once fetched, column cardinality can be shared between different queries using the same connection. test also that expressions with only table alias difference do not share cardinality result.",
	"Method": "void testColumnCadinalityCache(){\r\n    String query1 = \"select \" + \"NonEmptyCrossJoin(\" + \"[Product].[Product Family].Members, \" + \"[Gender].[Gender].Members) on columns \" + \"from [Sales]\";\r\n    String query2 = \"select \" + \"NonEmptyCrossJoin(\" + \"[Store].[Store Country].Members, \" + \"[Product].[Product Family].Members) on columns \" + \"from [Warehouse]\";\r\n    String cardinalitySqlDerby = \"select \" + \"count(distinct \\\"product_class\\\".\\\"product_family\\\") \" + \"from \\\"product_class\\\" as \\\"product_class\\\"\";\r\n    String cardinalitySqlMySql = \"select \" + \"count(distinct `product_class`.`product_family`) as `c0` \" + \"from `product_class` as `product_class`\";\r\n    SqlPattern[] patterns = new SqlPattern[] { new SqlPattern(Dialect.DatabaseProduct.DERBY, cardinalitySqlDerby, cardinalitySqlDerby), new SqlPattern(Dialect.DatabaseProduct.MYSQL, cardinalitySqlMySql, cardinalitySqlMySql) };\r\n    final TestContext context = getTestContext().withFreshConnection();\r\n    try {\r\n        context.executeQuery(query1);\r\n        assertQuerySqlOrNot(context, query2, patterns, true, false, false);\r\n    } finally {\r\n        context.close();\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.TestContext.assertSqlEquals",
	"Comment": "checks that expected sql equals actual sql.performs some normalization on the actual sql to compensate fordifferences between dialects.",
	"Method": "void assertSqlEquals(String expectedSql,String actualSql,int expectedRows){\r\n    assertEqualsVerbose(actualSql, dialectize(actualSql));\r\n    String transformedExpectedSql = removeQuotes(dialectize(expectedSql)).replaceAll(\"\\r\\n\", \"\\n\");\r\n    String transformedActualSql = removeQuotes(actualSql).replaceAll(\"\\r\\n\", \"\\n\");\r\n    Assert.assertEquals(transformedExpectedSql, transformedActualSql);\r\n    checkSqlAgainstDatasource(actualSql, expectedRows);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Code.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Code appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.server.Execution.setContextMap",
	"Comment": "set the copied mdc into the current mdc. this should be calledany time there will be logging in a thread handled by therolapresultshepherd where original mdc needs to be retrieved",
	"Method": "void setContextMap(){\r\n    final Map<String, Object> old = MDC.getContext();\r\n    if (old != null) {\r\n        old.clear();\r\n        old.putAll(mdc);\r\n    }\r\n}"
}, {
	"Path": "org.msgpack.jackson.dataformat.JsonArrayFormat.findFormat",
	"Comment": "defines array format for serialized entities with objectmapper, without actuallyincluding the schema",
	"Method": "JsonFormat.Value findFormat(Annotated ann){\r\n    JsonFormat.Value precedenceFormat = super.findFormat(ann);\r\n    if (precedenceFormat != null) {\r\n        return precedenceFormat;\r\n    }\r\n    return ARRAY_FORMAT;\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.JdbcSchema.resetAllTablesLoaded",
	"Comment": "used for testing allowing one to load tables and their columniterfrom more than one datasource",
	"Method": "void resetAllTablesLoaded(){\r\n    allTablesLoaded = false;\r\n}"
}, {
	"Path": "mondrian.rolap.format.FormatterFactoryTest.testShouldCreateFormatterByClassName",
	"Comment": "given that custom formatter class name is specified.when formatter creating is requested,factory should instantiate an object of specified class.",
	"Method": "void testShouldCreateFormatterByClassName(){\r\n    FormatterCreateContext cellFormatterContext = new FormatterCreateContext.Builder(\"name\").formatterAttr(\"mondrian.rolap.format.CellFormatterTestImpl\").build();\r\n    FormatterCreateContext memberFormatterContext = new FormatterCreateContext.Builder(\"name\").formatterAttr(\"mondrian.rolap.format.MemberFormatterTestImpl\").build();\r\n    FormatterCreateContext propertyFormatterContext = new FormatterCreateContext.Builder(\"name\").formatterAttr(\"mondrian.rolap.format.PropertyFormatterTestImpl\").build();\r\n    CellFormatter cellFormatter = factory.createCellFormatter(cellFormatterContext);\r\n    MemberFormatter memberFormatter = factory.createRolapMemberFormatter(memberFormatterContext);\r\n    PropertyFormatter propertyFormatter = factory.createPropertyFormatter(propertyFormatterContext);\r\n    assertNotNull(cellFormatter);\r\n    assertNotNull(memberFormatter);\r\n    assertNotNull(propertyFormatter);\r\n    assertTrue(cellFormatter instanceof CellFormatterTestImpl);\r\n    assertTrue(memberFormatter instanceof MemberFormatterTestImpl);\r\n    assertTrue(propertyFormatter instanceof PropertyFormatterTestImpl);\r\n}"
}, {
	"Path": "mondrian.util.SlotFuture.fail",
	"Comment": "writes a throwable into the slot, indicating that the task has failed.",
	"Method": "void fail(Throwable throwable){\r\n    stateLock.writeLock().lock();\r\n    try {\r\n        if (done) {\r\n            throw new IllegalArgumentException(\"Future is already done (cancelled=\" + cancelled + \", value=\" + value + \", throwable=\" + this.throwable + \")\");\r\n        }\r\n        this.throwable = throwable;\r\n        this.done = true;\r\n    } finally {\r\n        stateLock.writeLock().unlock();\r\n    }\r\n    dataGate.countDown();\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Style.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Style appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlTest.standardQuery",
	"Comment": "runs a simple query an asserts that the results are as expected.",
	"Method": "void standardQuery(TestContext testContext){\r\n    testContext.assertQueryReturns(\"select {[Time].[Time].Members} on columns,\\n\" + \" {[Product].Children} on rows\\n\" + \"from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Time].[1997]}\\n\" + \"{[Time].[1997].[Q1]}\\n\" + \"{[Time].[1997].[Q1].[1]}\\n\" + \"{[Time].[1997].[Q1].[2]}\\n\" + \"{[Time].[1997].[Q1].[3]}\\n\" + \"{[Time].[1997].[Q2]}\\n\" + \"{[Time].[1997].[Q2].[4]}\\n\" + \"{[Time].[1997].[Q2].[5]}\\n\" + \"{[Time].[1997].[Q2].[6]}\\n\" + \"{[Time].[1997].[Q3]}\\n\" + \"{[Time].[1997].[Q3].[7]}\\n\" + \"{[Time].[1997].[Q3].[8]}\\n\" + \"{[Time].[1997].[Q3].[9]}\\n\" + \"{[Time].[1997].[Q4]}\\n\" + \"{[Time].[1997].[Q4].[10]}\\n\" + \"{[Time].[1997].[Q4].[11]}\\n\" + \"{[Time].[1997].[Q4].[12]}\\n\" + \"{[Time].[1998]}\\n\" + \"{[Time].[1998].[Q1]}\\n\" + \"{[Time].[1998].[Q1].[1]}\\n\" + \"{[Time].[1998].[Q1].[2]}\\n\" + \"{[Time].[1998].[Q1].[3]}\\n\" + \"{[Time].[1998].[Q2]}\\n\" + \"{[Time].[1998].[Q2].[4]}\\n\" + \"{[Time].[1998].[Q2].[5]}\\n\" + \"{[Time].[1998].[Q2].[6]}\\n\" + \"{[Time].[1998].[Q3]}\\n\" + \"{[Time].[1998].[Q3].[7]}\\n\" + \"{[Time].[1998].[Q3].[8]}\\n\" + \"{[Time].[1998].[Q3].[9]}\\n\" + \"{[Time].[1998].[Q4]}\\n\" + \"{[Time].[1998].[Q4].[10]}\\n\" + \"{[Time].[1998].[Q4].[11]}\\n\" + \"{[Time].[1998].[Q4].[12]}\\n\" + \"Axis #2:\\n\" + \"{[Product].[Drink]}\\n\" + \"{[Product].[Food]}\\n\" + \"{[Product].[Non-Consumable]}\\n\" + \"Row #0: 24,597\\n\" + \"Row #0: 5,976\\n\" + \"Row #0: 1,910\\n\" + \"Row #0: 1,951\\n\" + \"Row #0: 2,115\\n\" + \"Row #0: 5,895\\n\" + \"Row #0: 1,948\\n\" + \"Row #0: 2,039\\n\" + \"Row #0: 1,908\\n\" + \"Row #0: 6,065\\n\" + \"Row #0: 2,205\\n\" + \"Row #0: 1,921\\n\" + \"Row #0: 1,939\\n\" + \"Row #0: 6,661\\n\" + \"Row #0: 1,898\\n\" + \"Row #0: 2,344\\n\" + \"Row #0: 2,419\\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #1: 191,940\\n\" + \"Row #1: 47,809\\n\" + \"Row #1: 15,604\\n\" + \"Row #1: 15,142\\n\" + \"Row #1: 17,063\\n\" + \"Row #1: 44,825\\n\" + \"Row #1: 14,393\\n\" + \"Row #1: 15,055\\n\" + \"Row #1: 15,377\\n\" + \"Row #1: 47,440\\n\" + \"Row #1: 17,036\\n\" + \"Row #1: 15,741\\n\" + \"Row #1: 14,663\\n\" + \"Row #1: 51,866\\n\" + \"Row #1: 14,232\\n\" + \"Row #1: 18,278\\n\" + \"Row #1: 19,356\\n\" + \"Row #1: \\n\" + \"Row #1: \\n\" + \"Row #1: \\n\" + \"Row #1: \\n\" + \"Row #1: \\n\" + \"Row #1: \\n\" + \"Row #1: \\n\" + \"Row #1: \\n\" + \"Row #1: \\n\" + \"Row #1: \\n\" + \"Row #1: \\n\" + \"Row #1: \\n\" + \"Row #1: \\n\" + \"Row #1: \\n\" + \"Row #1: \\n\" + \"Row #1: \\n\" + \"Row #1: \\n\" + \"Row #2: 50,236\\n\" + \"Row #2: 12,506\\n\" + \"Row #2: 4,114\\n\" + \"Row #2: 3,864\\n\" + \"Row #2: 4,528\\n\" + \"Row #2: 11,890\\n\" + \"Row #2: 3,838\\n\" + \"Row #2: 3,987\\n\" + \"Row #2: 4,065\\n\" + \"Row #2: 12,343\\n\" + \"Row #2: 4,522\\n\" + \"Row #2: 4,035\\n\" + \"Row #2: 3,786\\n\" + \"Row #2: 13,497\\n\" + \"Row #2: 3,828\\n\" + \"Row #2: 4,648\\n\" + \"Row #2: 5,021\\n\" + \"Row #2: \\n\" + \"Row #2: \\n\" + \"Row #2: \\n\" + \"Row #2: \\n\" + \"Row #2: \\n\" + \"Row #2: \\n\" + \"Row #2: \\n\" + \"Row #2: \\n\" + \"Row #2: \\n\" + \"Row #2: \\n\" + \"Row #2: \\n\" + \"Row #2: \\n\" + \"Row #2: \\n\" + \"Row #2: \\n\" + \"Row #2: \\n\" + \"Row #2: \\n\" + \"Row #2: \\n\");\r\n}"
}, {
	"Path": "mondrian.olap.Util.only",
	"Comment": "returns the sole item in a list.if the list has 0 or more than one element, throws.",
	"Method": "T only(List<T> list){\r\n    if (list.size() != 1) {\r\n        throw new IndexOutOfBoundsException(\"list \" + list + \" has \" + list.size() + \" elements, expected 1\");\r\n    }\r\n    return list.get(0);\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.StringUtils.split",
	"Comment": "split a string at the first occurrence of the delimiter. does not includethe delimiter in the result.",
	"Method": "String[] split(String toSplit,String delimiter){\r\n    if (!hasLength(toSplit) || !hasLength(delimiter)) {\r\n        return null;\r\n    }\r\n    int offset = toSplit.indexOf(delimiter);\r\n    if (offset < 0) {\r\n        return null;\r\n    }\r\n    String beforeDelimiter = toSplit.substring(0, offset);\r\n    String afterDelimiter = toSplit.substring(offset + delimiter.length());\r\n    return new String[] { beforeDelimiter, afterDelimiter };\r\n}"
}, {
	"Path": "mondrian.test.TestContext.getConnection",
	"Comment": "returns the connection to run queries.when invoked on the default testcontext instance, returns a connectionto the foodmart database.",
	"Method": "Connection getConnection(){\r\n    if (connectionRef != null) {\r\n        Connection connection = connectionRef.get();\r\n        if (connection != null) {\r\n            return connection;\r\n        }\r\n    }\r\n    final Connection connection = DriverManager.getConnection(getConnectionProperties(), null, null);\r\n    connectionRef = new SoftReference<Connection>(connection);\r\n    return connection;\r\n}"
}, {
	"Path": "mondrian.olap.Util.uniquify",
	"Comment": "makes a name distinct from other names which have already been usedand shorter than a length limit, adds it to the list, and returns it.",
	"Method": "String uniquify(String name,int maxLength,Collection<String> nameList){\r\n    assert name != null;\r\n    if (name.length() > maxLength) {\r\n        name = name.substring(0, maxLength);\r\n    }\r\n    if (nameList.contains(name)) {\r\n        String aliasBase = name;\r\n        int j = 0;\r\n        while (true) {\r\n            name = aliasBase + j;\r\n            if (name.length() > maxLength) {\r\n                aliasBase = aliasBase.substring(0, aliasBase.length() - 1);\r\n                continue;\r\n            }\r\n            if (!nameList.contains(name)) {\r\n                break;\r\n            }\r\n            j++;\r\n        }\r\n    }\r\n    nameList.add(name);\r\n    return name;\r\n}"
}, {
	"Path": "com.meetup.memcached.MemcachedClient.stats",
	"Comment": "retrieves stats for all servers.\treturns a map keyed on the servername.\tthe value is another map which contains stats\twith stat name as key and value as value.",
	"Method": "Map stats(Map stats,String[] servers,Map stats,String[] servers,String command,String lineStart){\r\n    if (command == null || command.trim().equals(\"\")) {\r\n        log.error(\"++++ invalid / missing command for stats()\");\r\n        return null;\r\n    }\r\n    servers = (servers == null) ? pool.getServers() : servers;\r\n    if (servers == null || servers.length <= 0) {\r\n        log.error(\"++++ no servers to check stats\");\r\n        return null;\r\n    }\r\n    Map<String, Map> statsMaps = new HashMap<String, Map>();\r\n    for (int i = 0; i < servers.length; i++) {\r\n        SockIOPool.SockIO sock = pool.getConnection(servers[i]);\r\n        if (sock == null) {\r\n            log.error(\"++++ unable to get connection to : \" + servers[i]);\r\n            if (errorHandler != null)\r\n                errorHandler.handleErrorOnStats(this, new IOException(\"no socket to server available\"));\r\n            continue;\r\n        }\r\n        try {\r\n            sock.write(command.getBytes());\r\n            sock.flush();\r\n            Map<String, String> stats = new HashMap<String, String>();\r\n            while (true) {\r\n                String line = sock.readLine();\r\n                if (log.isDebugEnabled())\r\n                    log.debug(\"++++ line: \" + line);\r\n                if (line.startsWith(lineStart)) {\r\n                    String[] info = line.split(\" \", 3);\r\n                    String key = info[1];\r\n                    String value = info[2];\r\n                    if (log.isDebugEnabled()) {\r\n                        log.debug(\"++++ key  : \" + key);\r\n                        log.debug(\"++++ value: \" + value);\r\n                    }\r\n                    stats.put(key, value);\r\n                } else if (END.equals(line)) {\r\n                    if (log.isDebugEnabled())\r\n                        log.debug(\"++++ finished reading from cache server\");\r\n                    break;\r\n                } else if (line.startsWith(ERROR) || line.startsWith(CLIENT_ERROR) || line.startsWith(SERVER_ERROR)) {\r\n                    log.error(\"++++ failed to query stats\");\r\n                    log.error(\"++++ server response: \" + line);\r\n                    break;\r\n                }\r\n                statsMaps.put(servers[i], stats);\r\n            }\r\n        } catch (IOException e) {\r\n            if (errorHandler != null)\r\n                errorHandler.handleErrorOnStats(this, e);\r\n            log.error(\"++++ exception thrown while writing bytes to server on stats\");\r\n            log.error(e.getMessage(), e);\r\n            try {\r\n                sock.trueClose();\r\n            } catch (IOException ioe) {\r\n                log.error(\"++++ failed to close socket : \" + sock.toString());\r\n            }\r\n            sock = null;\r\n        }\r\n        if (sock != null) {\r\n            sock.close();\r\n            sock = null;\r\n        }\r\n    }\r\n    return statsMaps;\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletResponse.addIntHeader",
	"Comment": "adds a response header with the given name and integer value.",
	"Method": "void addIntHeader(String name,int value){\r\n    String stringValue = Integer.toString(value);\r\n    addHeader(name, stringValue);\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCube.getFactCountMeasure",
	"Comment": "returns the system measure that counts the number of fact table rows ina given cell.never null, because if there is no count measure explicitly defined,the system creates one.",
	"Method": "RolapMeasure getFactCountMeasure(){\r\n    return factCountMeasure;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapStar.getDataSource",
	"Comment": "returns the datasource used to connect to the underlying dbms.",
	"Method": "DataSource getDataSource(){\r\n    return dataSource;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteGlobal.releaseMemory",
	"Comment": "attempts to release memory by pruning the sqlite page cache and otherinternal data structures.",
	"Method": "int releaseMemory(){\r\n    return nativeReleaseMemory();\r\n}"
}, {
	"Path": "mondrian.test.TestContext.withRole",
	"Comment": "returns a testcontext similar to this one, but using the given role.",
	"Method": "TestContext withRole(String roleName){\r\n    final Util.PropertyList properties = getConnectionProperties().clone();\r\n    properties.put(RolapConnectionProperties.Role.name(), roleName);\r\n    return new DelegatingTestContext(this) {\r\n        public Util.PropertyList getConnectionProperties() {\r\n            return properties;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "mondrian.test.TestContext.withRole",
	"Comment": "returns a testcontext similar to this one, but using the given role.",
	"Method": "TestContext withRole(String roleName){\r\n    return properties;\r\n}"
}, {
	"Path": "mondrian.tui.MockServletContext.getResourceAsStream",
	"Comment": "returns the resource located at the named path as an inputstream object.",
	"Method": "InputStream getResourceAsStream(String s){\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.util.Schedule.nextOccurrence",
	"Comment": "returns the next occurrence of this schedule after a given date. ifafter is null, returns the first occurrence. if there areno further occurrences, returns null.",
	"Method": "Date nextOccurrence(Date after,boolean strict,Calendar nextOccurrence,Calendar earliest,boolean strict,Calendar nextOccurrence,Calendar after,boolean strict,Calendar nextOccurrence,Calendar earliest,boolean strict,Calendar nextOccurrence,Calendar day,boolean strict,Calendar nextOccurrence,Calendar earliest,boolean strict,Calendar nextOccurrence,Calendar earliest,boolean strict,Calendar nextOccurrence,Calendar earliest,boolean strict){\r\n    if (after == null || begin != null && begin.after(after)) {\r\n        after = begin;\r\n        strict = false;\r\n    }\r\n    if (after == null) {\r\n        after = new Date(0);\r\n    }\r\n    Date next = nextOccurrence0(after, strict);\r\n    if (next != null && end != null && !next.before(end)) {\r\n        next = null;\r\n    }\r\n    return next;\r\n}"
}, {
	"Path": "mondrian.gui.SchemaPropertyCellEditor.cancelCellEditing",
	"Comment": "tells the editor to cancel editing and not accept any partiallyedited value.",
	"Method": "void cancelCellEditing(){\r\n    if (activeEditor != null) {\r\n        activeEditor.setVisible(false);\r\n        fireEditingCancelled();\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.SoundManager.getInstance",
	"Comment": "requests the instance of the sound manager and creates it if it does notexist.",
	"Method": "SoundManager getInstance(){\r\n    if (_instance == null)\r\n        _instance = new SoundManager();\r\n    return _instance;\r\n}"
}, {
	"Path": "mondrian.web.taglib.ResultCache.getInstance",
	"Comment": "retrieves a cached query. it is identified by its name and thecurrent session. the servletcontext parameter is necessary becausehttpsession.getservletcontext was not added until j2ee 1.3.",
	"Method": "ResultCache getInstance(HttpSession session,ServletContext servletContext,String name){\r\n    String fqname = ATTR_NAME + name;\r\n    ResultCache resultCache = (ResultCache) session.getAttribute(fqname);\r\n    if (resultCache == null) {\r\n        resultCache = new ResultCache(servletContext);\r\n        session.setAttribute(fqname, resultCache);\r\n    }\r\n    return resultCache;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.H3.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "H3 appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "com.meetup.memcached.NativeHandler.toInt",
	"Comment": "this works by taking each of the bit patterns and converting them to\tints taking into account 2s complement and then adding them..",
	"Method": "int toInt(byte[] b){\r\n    return (((((int) b[3]) & 0xFF) << 32) + ((((int) b[2]) & 0xFF) << 40) + ((((int) b[1]) & 0xFF) << 48) + ((((int) b[0]) & 0xFF) << 56));\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.DefaultRecognizer.getRules",
	"Comment": "get the defaultrules instance associated with this object.",
	"Method": "DefaultRules getRules(){\r\n    return aggDefault;\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.AggTableManager.removeJdbcSchema",
	"Comment": "remove the possibly already loaded snapshot of what is in the database.",
	"Method": "void removeJdbcSchema(){\r\n    DataSource dataSource = schema.getInternalConnection().getDataSource();\r\n    JdbcSchema.removeDB(dataSource);\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.addCustomFunction",
	"Comment": "registers a customfunction callback as a function that can be called fromsqlite database triggers.",
	"Method": "void addCustomFunction(String name,int numArgs,CustomFunction function){\r\n    SQLiteCustomFunction wrapper = new SQLiteCustomFunction(name, numArgs, function);\r\n    synchronized (mLock) {\r\n        throwIfNotOpenLocked();\r\n        mConfigurationLocked.customFunctions.add(wrapper);\r\n        try {\r\n            mConnectionPoolLocked.reconfigure(mConfigurationLocked);\r\n        } catch (RuntimeException ex) {\r\n            mConfigurationLocked.customFunctions.remove(wrapper);\r\n            throw ex;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.core.model.LatLong.fromMicroDegrees",
	"Comment": "constructs a new latlong with the given latitude and longitude values, measured inmicrodegrees.",
	"Method": "LatLong fromMicroDegrees(int latitudeE6,int longitudeE6){\r\n    return new LatLong(LatLongUtils.microdegreesToDegrees(latitudeE6), LatLongUtils.microdegreesToDegrees(longitudeE6));\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.CloseGuard.setEnabled",
	"Comment": "used to enable or disable closeguard. note that closeguard onlywarns if it is enabled for both allocation and finalization.",
	"Method": "void setEnabled(boolean enabled){\r\n    ENABLED = enabled;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapEvaluator.shouldIgnoreUnrelatedDimensions",
	"Comment": "checks if unrelated dimensions to the measure in the current contextshould be ignored.",
	"Method": "boolean shouldIgnoreUnrelatedDimensions(){\r\n    return getCube().shouldIgnoreUnrelatedDimensions(getMeasureCube().getName());\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.setMaintSleep",
	"Comment": "set the sleep time between runs of the pool maintenance thread.\tif set to 0, then the maint thread will not be started.",
	"Method": "void setMaintSleep(long maintSleep){\r\n    this.maintSleep = maintSleep;\r\n}"
}, {
	"Path": "mondrian.olap.ResultBase.getMember",
	"Comment": "returns the current member of a given hierarchy at a given location.",
	"Method": "Member getMember(int[] pos,Hierarchy hierarchy){\r\n    for (int i = -1; i < axes.length; i++) {\r\n        Axis axis = slicerAxis;\r\n        int index = 0;\r\n        if (i >= 0) {\r\n            axis = axes[i];\r\n            index = pos[i];\r\n        }\r\n        List<Position> positions = axis.getPositions();\r\n        Position position = positions.get(index);\r\n        for (Member member : position) {\r\n            if (member.getHierarchy() == hierarchy) {\r\n                return member;\r\n            }\r\n        }\r\n    }\r\n    return hierarchy.getHierarchy().getDefaultMember();\r\n}"
}, {
	"Path": "mondrian.tui.MockServletContext.getContext",
	"Comment": "returns a servletcontext object that corresponds to a specified url onthe server.",
	"Method": "ServletContext getContext(String s){\r\n    return null;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteConnection.close",
	"Comment": "do not call methods on the connection after it is closed.it will probably crash.",
	"Method": "void close(){\r\n    dispose(false);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.checkSchemaFile",
	"Comment": "check if schema file is valid by initiating a mondrian connection.",
	"Method": "void checkSchemaFile(File file){\r\n    try {\r\n        PropertyList list = new PropertyList();\r\n        list.put(\"Provider\", \"mondrian\");\r\n        list.put(\"Jdbc\", jdbcConnectionUrl);\r\n        list.put(\"Catalog\", file.toURI().toURL().toString());\r\n        list.put(\"JdbcDrivers\", jdbcDriverClassName);\r\n        if (jdbcUsername != null && jdbcUsername.length() > 0) {\r\n            list.put(\"JdbcUser\", jdbcUsername);\r\n        }\r\n        if (jdbcPassword != null && jdbcPassword.length() > 0) {\r\n            list.put(\"JdbcPassword\", jdbcPassword);\r\n        }\r\n        DriverManager.getConnection(list, null);\r\n    } catch (Exception ex) {\r\n        LOGGER.error(\"Exception : Schema file \" + file.getAbsolutePath() + \" is invalid.\" + ex.getMessage(), ex);\r\n    } catch (Error err) {\r\n        LOGGER.error(\"Error : Schema file \" + file.getAbsolutePath() + \" is invalid.\" + err.getMessage(), err);\r\n    }\r\n}"
}, {
	"Path": "mondrian.tui.XmlaSupport.validateSchemaXmla",
	"Comment": "check is a byte array containing a xmla response method is valid.schema validation occurs if the xmla response contains both a contentand schmema section. this should not be used when the byte arraycontains both the soap elements and content, but only for the content.",
	"Method": "boolean validateSchemaXmla(byte[] bytes){\r\n    return validateEmbeddedSchema(bytes, XmlUtil.getXmlaXds2xs(\"xmla\"), XmlUtil.getXmlaXds2xd(\"xmla\"));\r\n}"
}, {
	"Path": "mondrian.rolap.SqlTupleReader.getEvaluator",
	"Comment": "obtains the evaluator used to find an aggregate table to supportthe tuple constraint.",
	"Method": "Evaluator getEvaluator(TupleConstraint constraint){\r\n    if (constraint instanceof SqlContextConstraint) {\r\n        return constraint.getEvaluator();\r\n    }\r\n    if (constraint instanceof DescendantsConstraint) {\r\n        DescendantsConstraint descConstraint = (DescendantsConstraint) constraint;\r\n        MemberChildrenConstraint mcc = descConstraint.getMemberChildrenConstraint(null);\r\n        if (mcc instanceof SqlContextConstraint) {\r\n            SqlContextConstraint scc = (SqlContextConstraint) mcc;\r\n            return scc.getEvaluator();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunctionTest.assertAxisCompilesTo",
	"Comment": "compiles a set expression, and asserts that the program looks asexpected.",
	"Method": "void assertAxisCompilesTo(String expr,String expectedCalc){\r\n    final String actualCalc = getTestContext().compileExpression(expr, false);\r\n    final int expDeps = MondrianProperties.instance().TestExpDependencies.get();\r\n    if (expDeps > 0) {\r\n        return;\r\n    }\r\n    TestContext.assertStubbedEqualsVerbose(expectedCalc, actualCalc);\r\n}"
}, {
	"Path": "mondrian.olap.Query.createValidator",
	"Comment": "creates a validator for this query that uses a given function table andfunction validation policy.",
	"Method": "Validator createValidator(Validator createValidator,Map<QueryPart, QueryPart> resolvedIdentifiers,Validator createValidator,FunTable functionTable,boolean alwaysResolveFunDef,Validator createValidator,FunTable functionTable,boolean alwaysResolveFunDef,Map<QueryPart, QueryPart> resolvedIdentifiers){\r\n    return new QueryValidator(functionTable, alwaysResolveFunDef, Query.this, resolvedIdentifiers);\r\n}"
}, {
	"Path": "mondrian.rolap.MemberCacheHelper.findNamedChildrenInCache",
	"Comment": "attempts to find all children requested by the childbynameconstraintin cache.returns null if the complete list is not found.",
	"Method": "List<RolapMember> findNamedChildrenInCache(RolapMember parent,List<String> childNames){\r\n    List<RolapMember> children = checkDefaultAndNamedChildrenCache(parent);\r\n    if (children == null || childNames == null || childNames.size() > children.size()) {\r\n        return null;\r\n    }\r\n    filter(children, new Predicate() {\r\n        public boolean evaluate(Object member) {\r\n            return childNames.contains(((RolapMember) member).getName());\r\n        }\r\n    });\r\n    boolean foundAll = children.size() == childNames.size();\r\n    return !foundAll ? null : children;\r\n}"
}, {
	"Path": "mondrian.rolap.MemberCacheHelper.findNamedChildrenInCache",
	"Comment": "attempts to find all children requested by the childbynameconstraintin cache.returns null if the complete list is not found.",
	"Method": "List<RolapMember> findNamedChildrenInCache(RolapMember parent,List<String> childNames){\r\n    return childNames.contains(((RolapMember) member).getName());\r\n}"
}, {
	"Path": "mondrian.rolap.RolapNativeRegistry.createEvaluator",
	"Comment": "returns the matching nativeevaluator or null if fun can notbe executed in sql for the given context and arguments.",
	"Method": "NativeEvaluator createEvaluator(RolapEvaluator evaluator,FunDef fun,Exp[] args){\r\n    if (!isEnabled()) {\r\n        return null;\r\n    }\r\n    RolapNative rn = null;\r\n    readLock.lock();\r\n    try {\r\n        rn = nativeEvaluatorMap.get(fun.getName().toUpperCase());\r\n    } finally {\r\n        readLock.unlock();\r\n    }\r\n    if (rn == null) {\r\n        return null;\r\n    }\r\n    NativeEvaluator ne = rn.createEvaluator(evaluator, fun, args);\r\n    if (ne != null) {\r\n        if (listener != null) {\r\n            NativeEvent e = new NativeEvent(this, ne);\r\n            listener.foundEvaluator(e);\r\n        }\r\n    }\r\n    return ne;\r\n}"
}, {
	"Path": "org.msgpack.core.MessagePacker.packShort",
	"Comment": "writes an integer value.this method writes an integer using the smallest format from the int format family.",
	"Method": "MessagePacker packShort(short v){\r\n    if (v < -(1 << 5)) {\r\n        if (v < -(1 << 7)) {\r\n            writeByteAndShort(INT16, v);\r\n        } else {\r\n            writeByteAndByte(INT8, (byte) v);\r\n        }\r\n    } else if (v < (1 << 7)) {\r\n        writeByte((byte) v);\r\n    } else {\r\n        if (v < (1 << 8)) {\r\n            writeByteAndByte(UINT8, (byte) v);\r\n        } else {\r\n            writeByteAndShort(UINT16, v);\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.removeSocketFromPool",
	"Comment": "removes a socket from specified pool for host.\tthis method is not threadsafe, so be careful when using!\tinternal utility method.",
	"Method": "void removeSocketFromPool(Map<String, Map<SockIO, Long>> pool,String host,SockIO socket){\r\n    if (pool.containsKey(host)) {\r\n        Map<SockIO, Long> sockets = pool.get(host);\r\n        if (sockets != null)\r\n            sockets.remove(socket);\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCube.getTimeHierarchy",
	"Comment": "returns the time hierarchy for this cube. if there is no time hierarchy,throws.",
	"Method": "RolapHierarchy getTimeHierarchy(String funName){\r\n    for (RolapHierarchy hierarchy : hierarchyList) {\r\n        if (hierarchy.getDimension().getDimensionType() == DimensionType.TimeDimension) {\r\n            return hierarchy;\r\n        }\r\n    }\r\n    throw MondrianResource.instance().NoTimeDimensionInCube.ex(funName);\r\n}"
}, {
	"Path": "mondrian.rolap.RolapSchemaPoolTest.testSchemaFetchMd5JdbcUid",
	"Comment": "test using jdbcconnectionuuid and useschemachecksumfetches the same schema in all scenarios.",
	"Method": "void testSchemaFetchMd5JdbcUid(){\r\n    RolapSchemaPool pool = RolapSchemaPool.instance();\r\n    pool.clear();\r\n    final String uuid = \"UUID-1\";\r\n    String catalogUrl = getFoodmartCatalogUrl().toString();\r\n    Util.PropertyList connectInfo = Util.parseConnectString(TestContext.getDefaultConnectString());\r\n    connectInfo.put(RolapConnectionProperties.JdbcConnectionUuid.name(), uuid);\r\n    connectInfo.put(RolapConnectionProperties.UseContentChecksum.name(), \"true\");\r\n    RolapSchema schema = pool.get(catalogUrl, \"connectionKeyA\", \"joeTheUser\", \"aDataSource\", connectInfo);\r\n    Util.PropertyList connectInfoDyn = connectInfo.clone();\r\n    connectInfoDyn.put(RolapConnectionProperties.DynamicSchemaProcessor.name(), NotReallyDynamicSchemaProcessor.class.getName());\r\n    RolapSchema schemaDyn = pool.get(catalogUrl, \"connectionKeyB\", \"jed\", \"dsName\", connectInfo);\r\n    assertTrue(schema == schemaDyn);\r\n    String catalogContent = Util.readVirtualFileAsString(catalogUrl);\r\n    Util.PropertyList connectInfoCont = connectInfo.clone();\r\n    connectInfoCont.remove(RolapConnectionProperties.Catalog.name());\r\n    connectInfoCont.put(RolapConnectionProperties.CatalogContent.name(), catalogContent);\r\n    RolapSchema schemaCont = pool.get(catalogUrl, \"connectionKeyC\", \"--\", \"--\", connectInfo);\r\n    assertTrue(schema == schemaCont);\r\n    Util.PropertyList connectInfoDS = connectInfo.clone();\r\n    final StringBuilder buf = new StringBuilder();\r\n    DataSource dataSource = RolapConnection.createDataSource(null, connectInfoDS, buf);\r\n    RolapSchema schemaDS = pool.get(catalogUrl, dataSource, connectInfoDS);\r\n    assertTrue(schema == schemaDS);\r\n}"
}, {
	"Path": "mondrian.test.ParameterTest.testParameterMemberFailsBadLevel",
	"Comment": "tests that member parameter fails validation if the level name isinvalid.",
	"Method": "void testParameterMemberFailsBadLevel(){\r\n    assertExprThrows(\"Parameter(\\\"Foo\\\", [Customers].[State], [Customers].[USA].[CA], \\\"\\\")\", \"MDX object '[Customers].[State]' not found in cube 'Sales'\");\r\n    assertExprReturns(\"Parameter(\\\"Foo\\\", [Customers].[State Province], [Customers].[USA].[CA], \\\"\\\")\", \"74,748\");\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.model.TDRelation.fromRelation",
	"Comment": "creates a new tdrelation from an osmosis entity using the given wayresolver.",
	"Method": "TDRelation fromRelation(Relation relation,WayResolver resolver,List<String> preferredLanguages){\r\n    if (relation == null) {\r\n        return null;\r\n    }\r\n    if (relation.getMembers().isEmpty()) {\r\n        return null;\r\n    }\r\n    SpecialTagExtractionResult ster = OSMUtils.extractSpecialFields(relation, preferredLanguages);\r\n    Map<Short, Object> knownWayTags = OSMUtils.extractKnownWayTags(relation);\r\n    if (!knownRelationType(ster.getType())) {\r\n        return null;\r\n    }\r\n    List<RelationMember> members = relation.getMembers();\r\n    List<TDWay> wayMembers = new ArrayList();\r\n    for (RelationMember relationMember : members) {\r\n        if (relationMember.getMemberType() != EntityType.Way) {\r\n            continue;\r\n        }\r\n        TDWay member = resolver.getWay(relationMember.getMemberId());\r\n        if (member == null) {\r\n            LOGGER.finest(\"relation is missing a member, rel-id: \" + relation.getId() + \" member id: \" + relationMember.getMemberId());\r\n            continue;\r\n        }\r\n        wayMembers.add(member);\r\n    }\r\n    if (wayMembers.isEmpty()) {\r\n        LOGGER.finest(\"relation has no valid members: \" + relation.getId());\r\n        return null;\r\n    }\r\n    return new TDRelation(relation.getId(), ster.getLayer(), ster.getName(), ster.getHousenumber(), ster.getRef(), knownWayTags, wayMembers.toArray(new TDWay[wayMembers.size()]));\r\n}"
}, {
	"Path": "mondrian.rolap.RolapStar.lookupSegment",
	"Comment": "looks for an existing aggregation over a given set of columns, in thelocal segment cache, returning null if there is none.must be called from synchronized context.",
	"Method": "Aggregation lookupSegment(AggregationKey aggregationKey){\r\n    return localBars.get().aggregations.get(aggregationKey);\r\n}"
}, {
	"Path": "mondrian.tui.CmdRunner.processSoapXmla",
	"Comment": "this is called to process a file containing xmla as the contentsof soap xml.",
	"Method": "void processSoapXmla(File file,int validateXmlaResponse){\r\n    String catalogURL = CmdRunner.getCatalogURLProperty();\r\n    Map<String, String> catalogNameUrls = new HashMap<String, String>();\r\n    catalogNameUrls.put(CATALOG_NAME, catalogURL);\r\n    long start = System.currentTimeMillis();\r\n    byte[] bytes = null;\r\n    try {\r\n        bytes = XmlaSupport.processSoapXmla(file, getConnectString(), catalogNameUrls, null);\r\n    } finally {\r\n        queryTime = (System.currentTimeMillis() - start);\r\n        totalQueryTime += queryTime;\r\n    }\r\n    String response = new String(bytes);\r\n    out.println(response);\r\n    switch(validateXmlaResponse) {\r\n        case VALIDATE_NONE:\r\n            break;\r\n        case VALIDATE_TRANSFORM:\r\n            XmlaSupport.validateSchemaSoapXmla(bytes);\r\n            out.println(\"XML Data is Valid\");\r\n            break;\r\n        case VALIDATE_XPATH:\r\n            XmlaSupport.validateSoapXmlaUsingXpath(bytes);\r\n            out.println(\"XML Data is Valid\");\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentCacheWorker.put",
	"Comment": "places a segment in the cache. returns true or falseif the operation succeeds.",
	"Method": "void put(SegmentHeader header,SegmentBody body){\r\n    checkThread();\r\n    try {\r\n        final boolean result = cache.put(header, body);\r\n        if (!result) {\r\n            LOGGER.error(MondrianResource.instance().SegmentCacheFailedToSaveSegment.baseMessage);\r\n            throw MondrianResource.instance().SegmentCacheFailedToSaveSegment.ex();\r\n        }\r\n    } catch (Throwable t) {\r\n        LOGGER.error(MondrianResource.instance().SegmentCacheFailedToSaveSegment.baseMessage, t);\r\n        throw MondrianResource.instance().SegmentCacheFailedToSaveSegment.ex(t);\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.model.TDWay.mergeRelationInformation",
	"Comment": "merges tags from a relation with the tags of this way and puts the result into the way tags of this way.",
	"Method": "void mergeRelationInformation(TDRelation relation){\r\n    if (relation.hasTags()) {\r\n        addTags(relation.getTags());\r\n    }\r\n    if (getName() == null && relation.getName() != null) {\r\n        setName(relation.getName());\r\n    }\r\n    if (getRef() == null && relation.getRef() != null) {\r\n        setRef(relation.getRef());\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.map.layer.Layer.setDisplayModel",
	"Comment": "the displaymodel comes from a mapview, so is generally not known when the layer itself is created. maybe a betterway would be to have a mapview as a parameter when creating a layer.",
	"Method": "void setDisplayModel(DisplayModel displayModel){\r\n    this.displayModel = displayModel;\r\n}"
}, {
	"Path": "mondrian.test.TestContext.withProperties",
	"Comment": "creates a testcontext which is like this one but uses the givenconnection properties.",
	"Method": "TestContext withProperties(Util.PropertyList properties){\r\n    return new DelegatingTestContext(this) {\r\n        public Util.PropertyList getConnectionProperties() {\r\n            return properties;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "mondrian.test.TestContext.withProperties",
	"Comment": "creates a testcontext which is like this one but uses the givenconnection properties.",
	"Method": "TestContext withProperties(Util.PropertyList properties){\r\n    return properties;\r\n}"
}, {
	"Path": "mondrian.gui.JdbcTreeModel.getChildCount",
	"Comment": "returns the number of children of parent.returns 0 if the nodeis a leaf or if it has no children.parent must be a nodepreviously obtained from this data source.",
	"Method": "int getChildCount(Object parent){\r\n    if (parent instanceof Node) {\r\n        return ((Node) parent).children.size();\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getAttribute",
	"Comment": "returns the value of the named attribute as an object, or null if no attribute of the given name exists.",
	"Method": "Object getAttribute(String name){\r\n    return this.attributes.get(name);\r\n}"
}, {
	"Path": "org.sqlite.database.DatabaseUtils.cursorStringToInsertHelper",
	"Comment": "reads a string out of a field in a cursor and writes it to an inserthelper.",
	"Method": "void cursorStringToInsertHelper(Cursor cursor,String field,InsertHelper inserter,int index){\r\n    inserter.bind(index, cursor.getString(cursor.getColumnIndexOrThrow(field)));\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCube.validateMemberProps",
	"Comment": "validates an array of member properties, and populates a list of namesand expressions, one for each property.",
	"Method": "void validateMemberProps(MondrianDef.CalculatedMemberProperty[] xmlProperties,List<String> propNames,List<String> propExprs,String memberName){\r\n    if (xmlProperties == null) {\r\n        return;\r\n    }\r\n    for (MondrianDef.CalculatedMemberProperty xmlProperty : xmlProperties) {\r\n        if (xmlProperty.expression == null && xmlProperty.value == null) {\r\n            throw MondrianResource.instance().NeitherExprNorValueForCalcMemberProperty.ex(xmlProperty.name, memberName, getName());\r\n        }\r\n        if (xmlProperty.expression != null && xmlProperty.value != null) {\r\n            throw MondrianResource.instance().ExprAndValueForMemberProperty.ex(xmlProperty.name, memberName, getName());\r\n        }\r\n        propNames.add(xmlProperty.name);\r\n        if (xmlProperty.expression != null) {\r\n            propExprs.add(xmlProperty.expression);\r\n        } else {\r\n            propExprs.add(Util.quoteForMdx(xmlProperty.value));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.util.ObjectFactory.getObject",
	"Comment": "creates an instance with the given classname,parametertypes and parametervalues orthrow a creationexception. there are two differentmechanims available. the first is to uses reflectionto create the instance typing the generated object based uponthe interfaceclass factory instance object.with the second the classname is an class that implementsthe invocationhandler interface and in this casethe java.lang.reflect.proxy class is used togenerate a proxy.",
	"Method": "V getObject(V getObject,Properties props,V getObject,Class[] parameterTypes,Object[] parameterValues,V getObject,Properties props,Class[] parameterTypes,Object[] parameterValues,V getObject,String className,Class[] parameterTypes,Object[] parameterValues,T getObject,Properties props,Class[] parameterTypes,Object[] parameterValues){\r\n    try {\r\n        final Class<?> genericClass = ClassResolver.INSTANCE.forName(className, true);\r\n        if (InvocationHandler.class.isAssignableFrom(genericClass)) {\r\n            final Constructor constructor = genericClass.getConstructor(parameterTypes);\r\n            InvocationHandler handler = (InvocationHandler) constructor.newInstance(parameterValues);\r\n            return (V) Proxy.newProxyInstance(genericClass.getClassLoader(), new Class[] { this.interfaceClass }, handler);\r\n        } else {\r\n            final Class<? extends V> specificClass = genericClass.asSubclass(interfaceClass);\r\n            final Constructor<? extends V> constructor = specificClass.getConstructor(parameterTypes);\r\n            return constructor.newInstance(parameterValues);\r\n        }\r\n    } catch (Exception exc) {\r\n        throw new CreationException(\"Error creating object of type \\\"\" + this.interfaceClass.getName() + \"\\\"\", exc);\r\n    }\r\n}"
}, {
	"Path": "mondrian.olap.Scanner.skipComment",
	"Comment": "eats a delimited comment.the type of delimiters are kept in commentdelim.the currentcomment type is indicated by commenttype.end of file terminates a comment without error.",
	"Method": "void skipComment(String startDelim,String endDelim){\r\n    int depth = 1;\r\n    for (int x = 0; x < startDelim.length(); x++) {\r\n        advance();\r\n    }\r\n    for (; ; ) {\r\n        if (nextChar == -1) {\r\n            return;\r\n        } else if (checkForSymbol(endDelim)) {\r\n            for (int x = 0; x < endDelim.length(); x++) {\r\n                advance();\r\n            }\r\n            if (--depth == 0) {\r\n                return;\r\n            }\r\n        } else if (allowNestedComments && checkForSymbol(startDelim)) {\r\n            for (int x = 0; x < startDelim.length(); x++) {\r\n                advance();\r\n            }\r\n            depth++;\r\n        } else {\r\n            advance();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.MondrianResultPrinter.elapsedTimeAsString",
	"Comment": "returns the formatted string of the elapsed time.duplicated from basetestrunner. fix it.",
	"Method": "String elapsedTimeAsString(long runTime){\r\n    return NumberFormat.getInstance().format((double) runTime / 1000);\r\n}"
}, {
	"Path": "mondrian.test.NamedSetTest.testNamedSetCrossJoin",
	"Comment": "tests a named set defined in a query which consists of tuples.",
	"Method": "void testNamedSetCrossJoin(){\r\n    assertQueryReturns(\"WITH\\n\" + \"    SET [Store Types by Country]\\n\" + \"AS\\n\" + \"    'CROSSJOIN({[Store].[Store Country].MEMBERS},\\n\" + \"               {[Store Type].[Store Type].MEMBERS})'\\n\" + \"SELECT\\n\" + \"    {[Measures].[Units Ordered]} ON COLUMNS,\\n\" + \"    NON EMPTY {[Store Types by Country]} ON ROWS\\n\" + \"FROM\\n\" + \"    [Warehouse]\\n\" + \"WHERE\\n\" + \"    [Time].[1997].[Q2]\", \"Axis #0:\\n\" + \"{[Time].[1997].[Q2]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Units Ordered]}\\n\" + \"Axis #2:\\n\" + \"{[Store].[USA], [Store Type].[Deluxe Supermarket]}\\n\" + \"{[Store].[USA], [Store Type].[Mid-Size Grocery]}\\n\" + \"{[Store].[USA], [Store Type].[Supermarket]}\\n\" + \"Row #0: 16843.0\\n\" + \"Row #1: 2295.0\\n\" + \"Row #2: 34856.0\\n\");\r\n}"
}, {
	"Path": "mondrian.test.FoodMartTestCase.assertQueriesReturnSimilarResults",
	"Comment": "executes query1 and query2 and compares the obtained measure values.",
	"Method": "void assertQueriesReturnSimilarResults(String query1,String query2,TestContext testContext){\r\n    String resultString1 = TestContext.toString(testContext.executeQuery(query1));\r\n    String resultString2 = TestContext.toString(testContext.executeQuery(query2));\r\n    assertEquals(measureValues(resultString1), measureValues(resultString2));\r\n}"
}, {
	"Path": "mondrian.test.CVConcurrentMdxTest.generateQueryArray",
	"Comment": "generates an array of queryandresult objects from the list oftest classes",
	"Method": "QueryAndResult[] generateQueryArray(List<Class> testList){\r\n    List<QueryAndResult> queryList = new ArrayList<QueryAndResult>();\r\n    for (int i = 0; i < testList.size(); i++) {\r\n        Class testClass = testList.get(i);\r\n        Class[] types = new Class[] { String.class };\r\n        try {\r\n            Constructor cons = testClass.getConstructor(types);\r\n            Object[] args = new Object[] { \"\" };\r\n            Test newCon = (Test) cons.newInstance(args);\r\n            DiffRepository diffRepos = ((ClearViewBase) newCon).getDiffRepos();\r\n            List<String> testCaseNames = diffRepos.getTestCaseNames();\r\n            for (int j = 0; j < testCaseNames.size(); j++) {\r\n                String testCaseName = testCaseNames.get(j);\r\n                String query = diffRepos.get(testCaseName, \"mdx\");\r\n                String result = diffRepos.get(testCaseName, \"result\");\r\n                if (diffRepos.get(testCaseName, \"calculatedMembers\") == null) {\r\n                    if (result.startsWith(Util.nl)) {\r\n                        result = result.replaceFirst(Util.nl, \"\");\r\n                    }\r\n                    QueryAndResult queryResult = new QueryAndResult(query, result);\r\n                    queryList.add(queryResult);\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            throw new Error(e.getMessage());\r\n        }\r\n    }\r\n    QueryAndResult[] queryArray = new QueryAndResult[queryList.size()];\r\n    return queryList.toArray(queryArray);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Blockquote.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Blockquote appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.DefaultRecognizer.checkMeasures",
	"Comment": "create measures for an aggregate table.first, iterator through all fact table measure usages.create a matcher for each such usage.iterate through all aggregate table columns.for each column that matches create a measure usage.per fact table measure usage, at most only one aggregate measure shouldbe created.",
	"Method": "int checkMeasures(){\r\n    msgRecorder.pushContextName(\"DefaultRecognizer.checkMeasures\");\r\n    try {\r\n        int measureCountCount = 0;\r\n        for (Iterator<JdbcSchema.Table.Column.Usage> it = dbFactTable.getColumnUsages(JdbcSchema.UsageType.MEASURE); it.hasNext(); ) {\r\n            JdbcSchema.Table.Column.Usage factUsage = it.next();\r\n            Matcher matcher = getMeasureMatcher(factUsage);\r\n            int matchCount = 0;\r\n            for (JdbcSchema.Table.Column aggColumn : aggTable.getColumns()) {\r\n                if (aggColumn.hasUsage(JdbcSchema.UsageType.IGNORE)) {\r\n                    continue;\r\n                }\r\n                if (matcher.matches(aggColumn.getName())) {\r\n                    makeMeasure(factUsage, aggColumn);\r\n                    measureCountCount++;\r\n                    matchCount++;\r\n                }\r\n            }\r\n            if (matchCount > 1) {\r\n                String msg = mres.AggMultipleMatchingMeasure.str(msgRecorder.getContext(), aggTable.getName(), dbFactTable.getName(), matchCount, factUsage.getSymbolicName(), factUsage.getColumn().getName(), factUsage.getAggregator().getName());\r\n                msgRecorder.reportError(msg);\r\n                returnValue = false;\r\n            }\r\n        }\r\n        return measureCountCount;\r\n    } finally {\r\n        msgRecorder.popContextName();\r\n    }\r\n}"
}, {
	"Path": "mondrian.xmla.Rowset.isRestricted",
	"Comment": "returns true if there is a restriction for the given columndefinition.",
	"Method": "boolean isRestricted(RowsetDefinition.Column column){\r\n    return (restrictions.get(column.name) != null);\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCubeMember.getRolapMember",
	"Comment": "returns the underlying member. this is a member of a shared dimension anddoes not belong to a cube.",
	"Method": "RolapMember getRolapMember(){\r\n    return member;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapMemberBaseTest.testShouldReturnMemberNameIfCaptionValueIsNotPresent",
	"Comment": "given rolap member with no caption value, but with name specified.when caption raw value is requested,then member name should be returned.",
	"Method": "void testShouldReturnMemberNameIfCaptionValueIsNotPresent(){\r\n    rolapMemberBase.setProperty(Property.NAME.name, MEMBER_NAME);\r\n    Object captionValue = rolapMemberBase.getCaptionValue();\r\n    assertNotNull(captionValue);\r\n    assertEquals(MEMBER_NAME, captionValue);\r\n}"
}, {
	"Path": "mondrian.gui.JdbcMetaData.getDimensionTables",
	"Comment": "gets all possible cases of dimension tables which are linked to givenfact table by foreign keys.",
	"Method": "List<String> getDimensionTables(String schemaName,String factTable,List<String> getDimensionTables,String sname,String factTable){\r\n    List<String> dimeTables = new ArrayList<String>();\r\n    if (factTable == null) {\r\n        return dimeTables;\r\n    } else {\r\n        return db.getDimensionTables(schemaName, factTable);\r\n    }\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.setWeights",
	"Comment": "sets the list of weights to apply to the server list.\tthis is an int array with each element corresponding to an element\tin the same position in the server string array.",
	"Method": "void setWeights(Integer[] weights){\r\n    this.weights = weights;\r\n}"
}, {
	"Path": "mondrian.olap.Property.lookup",
	"Comment": "looks up a property with a given ordinal.returns null if not found.",
	"Method": "Property lookup(int ordinal,Property lookup,String name,boolean matchCase){\r\n    if (matchCase) {\r\n        Property property = enumeration.getValue(name, false);\r\n        if (property != null) {\r\n            return property;\r\n        }\r\n        return synonyms.get(name);\r\n    } else {\r\n        return mapUpperNameToProperties.get(name.toUpperCase());\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.BasicQueryTest.testSameDimOnTwoAxesFails",
	"Comment": "it is illegal for a query to have the same dimension on more thanone axis.",
	"Method": "void testSameDimOnTwoAxesFails(){\r\n    assertQueryThrows(\"select {[Measures].[Unit Sales]} on columns,\\n\" + \" {[Measures].[Store Sales]} on rows\\n\" + \"from [Sales]\", \"Hierarchy '[Measures]' appears in more than one independent axis\");\r\n    assertQueryThrows(\"select {[Measures].[Unit Sales]} on columns,\\n\" + \" CrossJoin({[Product].members},\" + \"           {[Measures].[Store Sales]}) on rows\\n\" + \"from [Sales]\", \"Hierarchy '[Measures]' appears in more than one independent axis\");\r\n    assertQueryThrows(\"select CrossJoin(\\n\" + \"    {[Product].children},\\n\" + \"    {[Measures].[Unit Sales]}) on columns,\\n\" + \"    {([Product],\\n\" + \"      [Store].CurrentMember)} on rows\\n\" + \"from [Sales]\", \"Hierarchy '[Product]' appears in more than one independent axis\");\r\n    assertQueryThrows(\"select {[Measures].[Unit Sales]} on columns,\\n\" + \" {[Store].Members} on rows\\n\" + \"from [Sales]\\n\" + \"where ([Time].[1997].[Q1], [Measures].[Store Sales])\", \"Hierarchy '[Measures]' appears in more than one independent axis\");\r\n    executeQuery(\"with member [Measures].[West Coast Total] as \" + \" ' Aggregate({[Store].[USA].[CA], [Store].[USA].[OR], [Store].[USA].[WA]}) ' \\n\" + \"select \" + \"   {[Measures].[Store Sales], \\n\" + \"    [Measures].[Unit Sales]} on Columns,\\n\" + \" CrossJoin(\\n\" + \"   {[Product].children},\\n\" + \"   {[Store].children}) on Rows\\n\" + \"from [Sales]\");\r\n}"
}, {
	"Path": "mondrian.test.CacheHitTest.runRandomSuite",
	"Comment": "loops n times, each time run a random test casein the test suite",
	"Method": "void runRandomSuite(TestSuite suite,int n){\r\n    final TestResult tres = new TestResult();\r\n    final MondrianServer server = MondrianServer.forConnection(getTestContext().getConnection());\r\n    for (int i = 0; i < n; i++) {\r\n        int suiteIdx = (int) (Math.random() * suite.testCount());\r\n        TestSuite test = (TestSuite) suite.testAt(suiteIdx);\r\n        int testIdx = (int) (Math.random() * test.testCount());\r\n        test.testAt(testIdx).run(tres);\r\n    }\r\n    report(server.getMonitor().getServer());\r\n}"
}, {
	"Path": "mondrian.rolap.ScenarioImpl.evaluateAtomicCellCount",
	"Comment": "returns the number of atomic cells that contribute to the currentcell.",
	"Method": "double evaluateAtomicCellCount(RolapEvaluator evaluator){\r\n    final int savepoint = evaluator.savepoint();\r\n    try {\r\n        evaluator.setContext(evaluator.getCube().getAtomicCellCountMeasure());\r\n        final Object o = evaluator.evaluateCurrent();\r\n        return ((Number) o).doubleValue();\r\n    } finally {\r\n        evaluator.restore(savepoint);\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.map.reader.MapFile.readMapData",
	"Comment": "reads all map data for the area covered by the given tile at the tile zoom level.",
	"Method": "MapReadResult readMapData(Tile tile,MapReadResult readMapData,Tile upperLeft,Tile lowerRight,MapReadResult readMapData,Tile upperLeft,Tile lowerRight,Selector selector){\r\n    if (upperLeft.tileX > lowerRight.tileX || upperLeft.tileY > lowerRight.tileY) {\r\n        new IllegalArgumentException(\"upperLeft tile must be above and left of lowerRight tile\");\r\n    }\r\n    try {\r\n        QueryParameters queryParameters = new QueryParameters();\r\n        queryParameters.queryZoomLevel = this.mapFileHeader.getQueryZoomLevel(upperLeft.zoomLevel);\r\n        SubFileParameter subFileParameter = this.mapFileHeader.getSubFileParameter(queryParameters.queryZoomLevel);\r\n        if (subFileParameter == null) {\r\n            LOGGER.warning(\"no sub-file for zoom level: \" + queryParameters.queryZoomLevel);\r\n            return null;\r\n        }\r\n        queryParameters.calculateBaseTiles(upperLeft, lowerRight, subFileParameter);\r\n        queryParameters.calculateBlocks(subFileParameter);\r\n        return processBlocks(queryParameters, subFileParameter, Tile.getBoundingBox(upperLeft, lowerRight), selector);\r\n    } catch (IOException e) {\r\n        LOGGER.log(Level.SEVERE, e.getMessage(), e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testEnumLowMaxConstraints",
	"Comment": "verify that native memberlists inputs are subject to sql constriantlimitation. if mondrian.rolap.maxconstraints is set too low, nativeevaluations will be turned off.",
	"Method": "void testEnumLowMaxConstraints(){\r\n    propSaver.set(MondrianProperties.instance().MaxConstraints, 2);\r\n    checkNotNative(12, \"with \" + \"set [All Store Types] as {\" + \"[Store Type].[Deluxe Supermarket], \" + \"[Store Type].[Gourmet Supermarket], \" + \"[Store Type].[Mid-Size Grocery], \" + \"[Store Type].[Small Grocery], \" + \"[Store Type].[Supermarket]} \" + \"set [All Products] as {\" + \"[Product].[Drink], \" + \"[Product].[Food], \" + \"[Product].[Non-Consumable]} \" + \"select \" + \"NonEmptyCrossJoin(\" + \"Filter([All Store Types], ([Measures].[Unit Sales] > 10000)), \" + \"[All Products]) on columns \" + \"from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Store Type].[Deluxe Supermarket], [Product].[Drink]}\\n\" + \"{[Store Type].[Deluxe Supermarket], [Product].[Food]}\\n\" + \"{[Store Type].[Deluxe Supermarket], [Product].[Non-Consumable]}\\n\" + \"{[Store Type].[Gourmet Supermarket], [Product].[Drink]}\\n\" + \"{[Store Type].[Gourmet Supermarket], [Product].[Food]}\\n\" + \"{[Store Type].[Gourmet Supermarket], [Product].[Non-Consumable]}\\n\" + \"{[Store Type].[Mid-Size Grocery], [Product].[Drink]}\\n\" + \"{[Store Type].[Mid-Size Grocery], [Product].[Food]}\\n\" + \"{[Store Type].[Mid-Size Grocery], [Product].[Non-Consumable]}\\n\" + \"{[Store Type].[Supermarket], [Product].[Drink]}\\n\" + \"{[Store Type].[Supermarket], [Product].[Food]}\\n\" + \"{[Store Type].[Supermarket], [Product].[Non-Consumable]}\\n\" + \"Row #0: 6,827\\n\" + \"Row #0: 55,358\\n\" + \"Row #0: 14,652\\n\" + \"Row #0: 1,945\\n\" + \"Row #0: 15,438\\n\" + \"Row #0: 3,950\\n\" + \"Row #0: 1,159\\n\" + \"Row #0: 8,192\\n\" + \"Row #0: 2,140\\n\" + \"Row #0: 14,092\\n\" + \"Row #0: 108,188\\n\" + \"Row #0: 28,275\\n\");\r\n}"
}, {
	"Path": "mondrian.test.NativeSetEvaluationTest.testCJSameDimAsSlicerNamedSet",
	"Comment": "crossjoin that uses same dimension as slicer but is independent from it,evaluated via a named set. no loop should happen here.",
	"Method": "void testCJSameDimAsSlicerNamedSet(){\r\n    String mdx = \"WITH\\n\" + \"SET ST AS 'TopCount([Store Type].[Store Type].CurrentMember, 5)'\\n\" + \"SET TOP_BEV AS 'TopCount([Product].[Drink].Children, 3, [Measures].[Unit Sales])'\\n\" + \"SET TC AS TopCount(NonEmptyCrossJoin([Time].[Year].Members, TOP_BEV), 2, [Measures].[Unit Sales])\\n\" + \"MEMBER [Product].[Top Drinks] as Aggregate(TC, [Measures].[Unit Sales]) \\n\" + \"SET TOP_COUNTRY AS 'TopCount([Customers].[Country].Members, 1, [Measures].[Unit Sales])'\\n\" + \"SELECT NON EMPTY [Measures].[Unit Sales] on 0,\\n\" + \"  NON EMPTY TOP_COUNTRY ON 1 \\n\" + \"FROM [Sales] WHERE [Product].[Top Drinks]\";\r\n    assertQueryReturns(mdx, \"Axis #0:\\n\" + \"{[Product].[Top Drinks]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Customers].[USA]}\\n\" + \"Row #0: 20,411\\n\");\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.DrawerActivity.getToolbarNavigationClickListener",
	"Comment": "returns the fallback listener for navigation icon click events.",
	"Method": "View.OnClickListener getToolbarNavigationClickListener(){\r\n    if (mDrawerToggle != null) {\r\n        return mDrawerToggle.getToolbarNavigationClickListener();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.mapsforge.core.model.LineSegment.pointAlongLineSegment",
	"Comment": "computes a point along the line segment with a given distance to the start point.",
	"Method": "Point pointAlongLineSegment(double distance){\r\n    if (start.x == end.x) {\r\n        if (start.y > end.y) {\r\n            return new Point(end.x, end.y + distance);\r\n        } else {\r\n            return new Point(start.x, start.y + distance);\r\n        }\r\n    } else {\r\n        double slope = (end.y - start.y) / (end.x - start.x);\r\n        double dx = Math.sqrt((distance * distance) / (1 + (slope * slope)));\r\n        if (end.x < start.x) {\r\n            dx *= -1;\r\n        }\r\n        return new Point(start.x + dx, start.y + slope * dx);\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.ExplicitRecognizer.matchForeignKey",
	"Comment": "creates a foreign key usage. first the column name of the fact usage which is a foreign key isused to search for a foreign key definition in theexplicitrules.tabledef.if not found, thats ok, it is just a lostdimension.if found, look for a column in the aggregate table with thatname and make a foreign key usage.",
	"Method": "int matchForeignKey(JdbcSchema.Table.Column.Usage factUsage){\r\n    JdbcSchema.Table.Column factColumn = factUsage.getColumn();\r\n    String aggFK = getTableDef().getAggregateFK(factColumn.getName());\r\n    if (aggFK == null) {\r\n        return 0;\r\n    }\r\n    int matchCount = 0;\r\n    for (JdbcSchema.Table.Column aggColumn : aggTable.getColumns()) {\r\n        if (aggColumn.hasUsage(JdbcSchema.UsageType.IGNORE)) {\r\n            continue;\r\n        }\r\n        if (aggFK.equals(aggColumn.getName())) {\r\n            makeForeignKey(factUsage, aggColumn, aggFK);\r\n            matchCount++;\r\n        }\r\n    }\r\n    return matchCount;\r\n}"
}, {
	"Path": "mondrian.rolap.sql.SqlQuery.addSelectGroupBy",
	"Comment": "adds an expression to the select and group by clauses. uses the alias inthe group by clause, if the dialect requires it.",
	"Method": "String addSelectGroupBy(String expression,SqlStatement.Type type){\r\n    final String alias = addSelect(expression, type);\r\n    addGroupBy(expression, alias);\r\n    return alias;\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.JdbcSchema.isUniqueColumnType",
	"Comment": "determine if the parameter represents a single column type, i.e., thecolumn only has one usage.",
	"Method": "boolean isUniqueColumnType(Set<UsageType> columnType){\r\n    return columnType.size() == 1;\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getRemoteHost",
	"Comment": "returns the fully qualified name of the client that sent the request, orthe ip address of the client if the name cannot be determined.",
	"Method": "String getRemoteHost(){\r\n    return remoteHost;\r\n}"
}, {
	"Path": "mondrian.util.MemoryMonitorFactory.getThreadLocalClassName",
	"Comment": "get the class name of a memorymonitor implementationor null.",
	"Method": "String getThreadLocalClassName(){\r\n    return ClassName.get();\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteConnection.executeForChangedRowCount",
	"Comment": "executes a statement that returns a count of the number of rowsthat were changed.use for update or delete sql statements.",
	"Method": "int executeForChangedRowCount(String sql,Object[] bindArgs,CancellationSignal cancellationSignal){\r\n    if (sql == null) {\r\n        throw new IllegalArgumentException(\"sql must not be null.\");\r\n    }\r\n    int changedRows = 0;\r\n    final int cookie = mRecentOperations.beginOperation(\"executeForChangedRowCount\", sql, bindArgs);\r\n    try {\r\n        final PreparedStatement statement = acquirePreparedStatement(sql);\r\n        try {\r\n            throwIfStatementForbidden(statement);\r\n            bindArguments(statement, bindArgs);\r\n            applyBlockGuardPolicy(statement);\r\n            attachCancellationSignal(cancellationSignal);\r\n            try {\r\n                changedRows = nativeExecuteForChangedRowCount(mConnectionPtr, statement.mStatementPtr);\r\n                return changedRows;\r\n            } finally {\r\n                detachCancellationSignal(cancellationSignal);\r\n            }\r\n        } finally {\r\n            releasePreparedStatement(statement);\r\n        }\r\n    } catch (RuntimeException ex) {\r\n        mRecentOperations.failOperation(cookie, ex);\r\n        throw ex;\r\n    } finally {\r\n        if (mRecentOperations.endOperationDeferLog(cookie)) {\r\n            mRecentOperations.logOperation(cookie, \"changedRows=\" + changedRows);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.util.Format.getFormatToken",
	"Comment": "returns the format token as a string representationwhich corresponds to a given token code.",
	"Method": "String getFormatToken(int code){\r\n    return formatTokenToFormatString.get(code);\r\n}"
}, {
	"Path": "mondrian.olap.Util.areOccurencesEqual",
	"Comment": "returns whether a collection contains precisely one distinct element.returns false if the collection is empty, or if it contains elementsthat are not the same as each other.",
	"Method": "boolean areOccurencesEqual(Collection<T> collection){\r\n    Iterator<T> it = collection.iterator();\r\n    if (!it.hasNext()) {\r\n        return false;\r\n    }\r\n    T first = it.next();\r\n    while (it.hasNext()) {\r\n        T t = it.next();\r\n        if (!t.equals(first)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "mondrian.olap.fun.JavaFunDef.scan",
	"Comment": "scans a java class and returns a list of function definitions, one foreach static method which is suitable to become an mdx function.",
	"Method": "List<FunDef> scan(Class clazz){\r\n    List<FunDef> list = new ArrayList<FunDef>();\r\n    Method[] methods = clazz.getMethods();\r\n    for (Method method : methods) {\r\n        if (Modifier.isStatic(method.getModifiers()) && !method.getName().equals(\"main\")) {\r\n            list.add(generateFunDef(method));\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "mondrian.util.AbstractMemoryMonitor.getLowThreshold",
	"Comment": "returns the current lowest threshold of all registeredlisteners.",
	"Method": "long getLowThreshold(){\r\n    return lowThreshold;\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.AggTableManager.bindToStar",
	"Comment": "this method mines the rolapstar and annotes the jdbcschema.tabledbfacttable by creating jdbcschema.table.column.usage instances. forexample, a measure in the rolapstar becomes a measure usage for thecolumn with the same name and a rolapstar foreign key column becomes aforeign key usage for the column with the same name.",
	"Method": "void bindToStar(JdbcSchema.Table dbFactTable,RolapStar star,MessageRecorder msgRecorder){\r\n    msgRecorder.pushContextName(\"AggTableManager.bindToStar\");\r\n    try {\r\n        dbFactTable.load();\r\n        dbFactTable.setTableUsageType(JdbcSchema.TableUsageType.FACT);\r\n        MondrianDef.RelationOrJoin relation = star.getFactTable().getRelation();\r\n        String schema = null;\r\n        MondrianDef.Hint[] tableHints = null;\r\n        if (relation instanceof MondrianDef.Table) {\r\n            schema = ((MondrianDef.Table) relation).schema;\r\n            tableHints = ((MondrianDef.Table) relation).tableHints;\r\n        }\r\n        String tableName = dbFactTable.getName();\r\n        String alias = null;\r\n        dbFactTable.table = new MondrianDef.Table(schema, tableName, alias, tableHints);\r\n        for (JdbcSchema.Table.Column factColumn : dbFactTable.getColumns()) {\r\n            String cname = factColumn.getName();\r\n            RolapStar.Column[] rcs = star.getFactTable().lookupColumns(cname);\r\n            for (RolapStar.Column rc : rcs) {\r\n                if (rc instanceof RolapStar.Measure) {\r\n                    RolapStar.Measure rm = (RolapStar.Measure) rc;\r\n                    JdbcSchema.Table.Column.Usage usage = factColumn.newUsage(JdbcSchema.UsageType.MEASURE);\r\n                    usage.setSymbolicName(rm.getName());\r\n                    usage.setAggregator(rm.getAggregator());\r\n                    usage.rMeasure = rm;\r\n                }\r\n            }\r\n            RolapStar.Table rTable = star.getFactTable().findTableWithLeftJoinCondition(cname);\r\n            if (rTable != null) {\r\n                JdbcSchema.Table.Column.Usage usage = factColumn.newUsage(JdbcSchema.UsageType.FOREIGN_KEY);\r\n                usage.setSymbolicName(\"FOREIGN_KEY\");\r\n                usage.rTable = rTable;\r\n            } else {\r\n                RolapStar.Column rColumn = star.getFactTable().lookupColumn(cname);\r\n                if ((rColumn != null) && !(rColumn instanceof RolapStar.Measure)) {\r\n                    JdbcSchema.Table.Column.Usage usage = factColumn.newUsage(JdbcSchema.UsageType.FOREIGN_KEY);\r\n                    usage.setSymbolicName(\"FOREIGN_KEY\");\r\n                    usage.rColumn = rColumn;\r\n                }\r\n            }\r\n            if (!factColumn.hasUsage() && getLogger().isDebugEnabled()) {\r\n                getLogger().debug(mres.UnknownFactTableColumn.str(msgRecorder.getContext(), dbFactTable.getName(), factColumn.getName()));\r\n            }\r\n        }\r\n    } finally {\r\n        msgRecorder.popContextName();\r\n    }\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.H1.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "H1 appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "org.sqlite.database.DatabaseUtils.cursorFillWindow",
	"Comment": "fills the specified cursor window by iterating over the contents of the cursor.the window is filled until the cursor is exhausted or the window runs outof space.the original position of the cursor is left unchanged by this operation.",
	"Method": "void cursorFillWindow(Cursor cursor,int position,CursorWindow window){\r\n    if (position < 0 || position >= cursor.getCount()) {\r\n        return;\r\n    }\r\n    final int oldPos = cursor.getPosition();\r\n    final int numColumns = cursor.getColumnCount();\r\n    window.clear();\r\n    window.setStartPosition(position);\r\n    window.setNumColumns(numColumns);\r\n    if (cursor.moveToPosition(position)) {\r\n        rowloop: do {\r\n            if (!window.allocRow()) {\r\n                break;\r\n            }\r\n            for (int i = 0; i < numColumns; i++) {\r\n                final int type = cursor.getType(i);\r\n                final boolean success;\r\n                switch(type) {\r\n                    case Cursor.FIELD_TYPE_NULL:\r\n                        success = window.putNull(position, i);\r\n                        break;\r\n                    case Cursor.FIELD_TYPE_INTEGER:\r\n                        success = window.putLong(cursor.getLong(i), position, i);\r\n                        break;\r\n                    case Cursor.FIELD_TYPE_FLOAT:\r\n                        success = window.putDouble(cursor.getDouble(i), position, i);\r\n                        break;\r\n                    case Cursor.FIELD_TYPE_BLOB:\r\n                        {\r\n                            final byte[] value = cursor.getBlob(i);\r\n                            success = value != null ? window.putBlob(value, position, i) : window.putNull(position, i);\r\n                            break;\r\n                        }\r\n                    default:\r\n                    case Cursor.FIELD_TYPE_STRING:\r\n                        {\r\n                            final String value = cursor.getString(i);\r\n                            success = value != null ? window.putString(value, position, i) : window.putNull(position, i);\r\n                            break;\r\n                        }\r\n                }\r\n                if (!success) {\r\n                    window.freeLastRow();\r\n                    break rowloop;\r\n                }\r\n            }\r\n            position += 1;\r\n        } while (cursor.moveToNext());\r\n    }\r\n    cursor.moveToPosition(oldPos);\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteQueryBuilder.setCursorFactory",
	"Comment": "sets the cursor factory to be used for the query.you can useone factory for all queries on a database but it is normallyeasier to specify the factory when doing this query.",
	"Method": "void setCursorFactory(SQLiteDatabase.CursorFactory factory){\r\n    mFactory = factory;\r\n}"
}, {
	"Path": "mondrian.olap.fun.RangeFunDef.compileMembers",
	"Comment": "returns two membercalc objects, substituting nulls with the hierarchynull member of the other expression.",
	"Method": "MemberCalc[] compileMembers(Exp exp0,Exp exp1,ExpCompiler compiler){\r\n    MemberCalc[] members = new MemberCalc[2];\r\n    if (exp0.getType() instanceof NullType) {\r\n        members[0] = null;\r\n    } else {\r\n        members[0] = compiler.compileMember(exp0);\r\n    }\r\n    if (exp1.getType() instanceof NullType) {\r\n        members[1] = null;\r\n    } else {\r\n        members[1] = compiler.compileMember(exp1);\r\n    }\r\n    if (members[0] == null && members[1] == null) {\r\n        throw MondrianResource.instance().TwoNullsNotSupported.ex();\r\n    } else if (members[0] == null) {\r\n        Member nullMember = ((RolapMember) members[1].evaluate(null)).getHierarchy().getNullMember();\r\n        members[0] = (MemberCalc) ConstantCalc.constantMember(nullMember);\r\n    } else if (members[1] == null) {\r\n        Member nullMember = ((RolapMember) members[0].evaluate(null)).getHierarchy().getNullMember();\r\n        members[1] = (MemberCalc) ConstantCalc.constantMember(nullMember);\r\n    }\r\n    return members;\r\n}"
}, {
	"Path": "mondrian.olap.fun.AbstractAggregateFunDef.ignoreUnrelatedDimensions",
	"Comment": "pushes unrelated dimensions to the top level member from the given listof tuples if the ignoreunrelateddimensions property is set on the basecube usage in the virtual cube.",
	"Method": "TupleList ignoreUnrelatedDimensions(TupleList tuplesForAggregation,RolapCube baseCube){\r\n    Set<Dimension> nonJoiningDimensions = nonJoiningDimensions(baseCube, tuplesForAggregation);\r\n    final Set<List<Member>> processedTuples = new LinkedHashSet<List<Member>>(tuplesForAggregation.size());\r\n    for (List<Member> tuple : tuplesForAggregation) {\r\n        List<Member> tupleCopy = tuple;\r\n        for (int j = 0; j < tuple.size(); j++) {\r\n            final Member member = tuple.get(j);\r\n            if (nonJoiningDimensions.contains(member.getDimension())) {\r\n                if (tupleCopy == tuple) {\r\n                    tupleCopy = new ArrayList<Member>(tuple);\r\n                }\r\n                final Hierarchy hierarchy = member.getDimension().getHierarchy();\r\n                if (hierarchy.hasAll()) {\r\n                    tupleCopy.set(j, hierarchy.getAllMember());\r\n                } else {\r\n                    tupleCopy.set(j, hierarchy.getDefaultMember());\r\n                }\r\n            }\r\n        }\r\n        processedTuples.add(tupleCopy);\r\n    }\r\n    return new DelegatingTupleList(tuplesForAggregation.getArity(), new ArrayList<List<Member>>(processedTuples));\r\n}"
}, {
	"Path": "org.mapsforge.core.model.LatLong.compareTo",
	"Comment": "this method is necessary for inserting latlongs into tree data structures.",
	"Method": "int compareTo(LatLong latLong){\r\n    if (this.latitude > latLong.latitude || this.longitude > latLong.longitude) {\r\n        return 1;\r\n    } else if (this.latitude < latLong.latitude || this.longitude < latLong.longitude) {\r\n        return -1;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunctionTest.testRangeLarge",
	"Comment": "large dimensions use a different member reader, therefore need tobe tested separately.",
	"Method": "void testRangeLarge(){\r\n    assertAxisReturns(\"[Customers].[USA].[CA].[San Francisco] : [Customers].[USA].[WA].[Bellingham]\", \"[Customers].[USA].[CA].[San Francisco]\\n\" + \"[Customers].[USA].[CA].[San Gabriel]\\n\" + \"[Customers].[USA].[CA].[San Jose]\\n\" + \"[Customers].[USA].[CA].[Santa Cruz]\\n\" + \"[Customers].[USA].[CA].[Santa Monica]\\n\" + \"[Customers].[USA].[CA].[Spring Valley]\\n\" + \"[Customers].[USA].[CA].[Torrance]\\n\" + \"[Customers].[USA].[CA].[West Covina]\\n\" + \"[Customers].[USA].[CA].[Woodland Hills]\\n\" + \"[Customers].[USA].[OR].[Albany]\\n\" + \"[Customers].[USA].[OR].[Beaverton]\\n\" + \"[Customers].[USA].[OR].[Corvallis]\\n\" + \"[Customers].[USA].[OR].[Lake Oswego]\\n\" + \"[Customers].[USA].[OR].[Lebanon]\\n\" + \"[Customers].[USA].[OR].[Milwaukie]\\n\" + \"[Customers].[USA].[OR].[Oregon City]\\n\" + \"[Customers].[USA].[OR].[Portland]\\n\" + \"[Customers].[USA].[OR].[Salem]\\n\" + \"[Customers].[USA].[OR].[W. Linn]\\n\" + \"[Customers].[USA].[OR].[Woodburn]\\n\" + \"[Customers].[USA].[WA].[Anacortes]\\n\" + \"[Customers].[USA].[WA].[Ballard]\\n\" + \"[Customers].[USA].[WA].[Bellingham]\");\r\n}"
}, {
	"Path": "mondrian.test.NamedSetTest.testNamedSetRangeInSlicer",
	"Comment": "test case for issue on developers list which involves a named set and arange in the where clause. current mondrian behavior appears to becorrect.",
	"Method": "void testNamedSetRangeInSlicer(){\r\n    String expected = \"Axis #0:\\n\" + \"{[Time].[1997].[Q1].[1]}\\n\" + \"{[Time].[1997].[Q1].[2]}\\n\" + \"{[Time].[1997].[Q1].[3]}\\n\" + \"{[Time].[1997].[Q2].[4]}\\n\" + \"{[Time].[1997].[Q2].[5]}\\n\" + \"{[Time].[1997].[Q2].[6]}\\n\" + \"{[Time].[1997].[Q3].[7]}\\n\" + \"{[Time].[1997].[Q3].[8]}\\n\" + \"{[Time].[1997].[Q3].[9]}\\n\" + \"{[Time].[1997].[Q4].[10]}\\n\" + \"Axis #1:\\n\" + \"{[Customers].[USA].[WA].[Spokane].[Mary Francis Benigar], [Measures].[Unit Sales]}\\n\" + \"{[Customers].[USA].[WA].[Spokane].[James Horvat], [Measures].[Unit Sales]}\\n\" + \"{[Customers].[USA].[WA].[Spokane].[Matt Bellah], [Measures].[Unit Sales]}\\n\" + \"{[Customers].[USA].[WA].[Spokane].[Ida Rodriguez], [Measures].[Unit Sales]}\\n\" + \"{[Customers].[USA].[WA].[Spokane].[Kristin Miller], [Measures].[Unit Sales]}\\n\" + \"Row #0: 422\\n\" + \"Row #0: 369\\n\" + \"Row #0: 363\\n\" + \"Row #0: 344\\n\" + \"Row #0: 323\\n\";\r\n    assertQueryReturns(\"SELECT\\n\" + \"NON EMPTY TopCount([Customers].[Name].Members, 5, [Measures].[Unit Sales]) * [Measures].[Unit Sales] on 0\\n\" + \"FROM [Sales]\\n\" + \"WHERE [Time].[1997].[Q1].[1]:[Time].[1997].[Q4].[10]\", expected);\r\n    assertQueryReturns(\"SELECT\\n\" + \"TopCount([Customers].[Name].Members, 5, [Measures].[Unit Sales]) * [Measures].[Unit Sales] on 0\\n\" + \"FROM [Sales]\\n\" + \"WHERE [Time].[1997].[Q1].[1]:[Time].[1997].[Q4].[10]\", expected);\r\n    assertQueryReturns(\"SELECT\\n\" + \"TopCount(Distinct([Customers].[Name].Members), 5, [Measures].[Unit Sales]) * [Measures].[Unit Sales] on 0\\n\" + \"FROM [Sales]\\n\" + \"WHERE [Time].[1997].[Q1].[1]:[Time].[1997].[Q4].[10]\", expected);\r\n    assertQueryReturns(\"WITH SET [Top Count] AS\\n\" + \"  TopCount([Customers].[Name].Members, 5, [Measures].[Unit Sales])\\n\" + \"SELECT [Top Count] * [Measures].[Unit Sales] on 0\\n\" + \"FROM [Sales]\\n\" + \"WHERE [Time].[1997].[Q1].[1]:[Time].[1997].[Q4].[10]\", expected);\r\n    if (false)\r\n        assertQueryReturns(\"WITH SET [Top Count] AS\\n\" + \"{\\n\" + \"  TopCount(\\n\" + \"    Distinct([Customers].[Name].Members),\\n\" + \"    5,\\n\" + \"    [Measures].[Unit Sales])\\n\" + \"}\\n\" + \"SELECT [Top Count] * [Measures].[Unit Sales] on 0\\n\" + \"FROM [Sales]\\n\" + \"WHERE [Time].[1997].[Q1].[1]:[Time].[1997].[Q4].[10]\", expected);\r\n}"
}, {
	"Path": "mondrian.test.DrillThroughTest.testDrillThroughVirtualCube",
	"Comment": "tests that cells in a virtual cube say they can be drilled through.",
	"Method": "void testDrillThroughVirtualCube(){\r\n    Result result = executeQuery(\"select Crossjoin([Customers].[All Customers].[USA].[OR].Children, {[Measures].[Unit Sales]}) ON COLUMNS, \" + \" [Gender].[All Gender].Children ON ROWS\" + \" from [Warehouse and Sales]\" + \" where [Time].[1997].[Q4].[12]\");\r\n    String sql = result.getCell(new int[] { 0, 0 }).getDrillThroughSQL(false);\r\n    String expectedSql = \"select `time_by_day`.`the_year` as `Year`,\" + \" `time_by_day`.`quarter` as `Quarter`,\" + \" `time_by_day`.month_of_year` as `Month`,\" + \" `customer`.`state_province` as `State Province`,\" + \" `customer`.`city` as `City`,\" + \" `customer`.`gender` as `Gender`,\" + \" `sales_fact_1997`.`unit_sales` as `Unit Sales`\" + \" from `time_by_day` =as= `time_by_day`,\" + \" `sales_fact_1997` =as= `sales_fact_1997`,\" + \" `customer` =as= `customer`\" + \" where `sales_fact_1997`.`time_id` = `time_by_day`.`time_id` and\" + \" `time_by_day`.`the_year` = 1997 and\" + \" `time_by_day`.`quarter` = 'Q4' and\" + \" `time_by_day`.`month_of_year` = 12 and\" + \" `sales_fact_1997`.`customer_id` = `customer`.customer_id` and\" + \" `customer`.`state_province` = 'OR' and\" + \" `customer`.`city` = 'Albany' and\" + \" `customer`.`gender` = 'F'\" + \" order by \" + (TestContext.instance().getDialect().requiresOrderByAlias() ? \"`Year` ASC,\" + \" `Quarter` ASC,\" + \" `Month` ASC,\" + \" `State Province` ASC,\" + \" `City` ASC,\" + \" `Gender` ASC\" : \"`time_by_day`.`the_year` ASC,\" + \" `time_by_day`.`quarter` ASC,\" + \" `time_by_day`.`month_of_year` ASC,\" + \" `customer`.`state_province` ASC,\" + \" `customer`.`city` ASC,\" + \" `customer`.`gender` ASC\");\r\n    getTestContext().assertSqlEquals(expectedSql, sql, 73);\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.Serializer.getVariableByteUnsigned",
	"Comment": "converts an unsigned int to a variable length byte array.the first bit is for continuation info, the other seven bits for data.",
	"Method": "byte[] getVariableByteUnsigned(int value){\r\n    if (value < 0) {\r\n        throw new InvalidParameterException(\"negative value not allowed: \" + value);\r\n    } else if (value < 128) {\r\n        return new byte[] { (byte) value };\r\n    } else if (value < 16384) {\r\n        return new byte[] { (byte) (value | 0x80), (byte) (value >> 7) };\r\n    } else if (value < 2097152) {\r\n        return new byte[] { (byte) (value | 0x80), (byte) ((value >> 7) | 0x80), (byte) (value >> 14) };\r\n    } else if (value < 268435456) {\r\n        return new byte[] { (byte) (value | 0x80), (byte) ((value >> 7) | 0x80), (byte) ((value >> 14) | 0x80), (byte) (value >> 21) };\r\n    } else {\r\n        return new byte[] { (byte) (value | 0x80), (byte) ((value >> 7) | 0x80), (byte) ((value >> 14) | 0x80), (byte) ((value >> 21) | 0x80), (byte) (value >> 28) };\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.core.util.MercatorProjection.tileYToLatitudeWithScaleFactor",
	"Comment": "converts a tile y number at a certain scale to a latitude coordinate.",
	"Method": "double tileYToLatitudeWithScaleFactor(long tileY,double scaleFactor){\r\n    return pixelYToLatitudeWithScaleFactor(tileY * DUMMY_TILE_SIZE, scaleFactor, DUMMY_TILE_SIZE);\r\n}"
}, {
	"Path": "org.mapsforge.map.reader.ReadBuffer.readUTF8EncodedString",
	"Comment": "decodes the given amount of bytes from the read buffer to a string.",
	"Method": "String readUTF8EncodedString(String readUTF8EncodedString,int stringLength){\r\n    if (stringLength > 0 && this.bufferPosition + stringLength <= this.bufferData.length) {\r\n        this.bufferPosition += stringLength;\r\n        try {\r\n            return new String(this.bufferData, this.bufferPosition - stringLength, stringLength, CHARSET_UTF8);\r\n        } catch (UnsupportedEncodingException e) {\r\n            throw new IllegalStateException(e);\r\n        }\r\n    }\r\n    LOGGER.warning(\"invalid string length: \" + stringLength);\r\n    return null;\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.getMaxConn",
	"Comment": "returns the maximum number of spare connections allowed in available pool.",
	"Method": "int getMaxConn(){\r\n    return this.maxConn;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.getDbStats",
	"Comment": "collect statistics about all open databases in the current process.used by bug report.",
	"Method": "ArrayList<DbStats> getDbStats(){\r\n    ArrayList<DbStats> dbStatsList = new ArrayList<DbStats>();\r\n    for (SQLiteDatabase db : getActiveDatabases()) {\r\n        db.collectDbStats(dbStatsList);\r\n    }\r\n    return dbStatsList;\r\n}"
}, {
	"Path": "mondrian.olap.Util.readFully",
	"Comment": "reads an input stream until it returns eof and returns the contents as anarray of bytes.",
	"Method": "String readFully(Reader rdr,int bufferSize,byte[] readFully,InputStream in,int bufferSize){\r\n    if (bufferSize <= 0) {\r\n        throw new IllegalArgumentException(\"Buffer size must be greater than 0\");\r\n    }\r\n    final byte[] buffer = new byte[bufferSize];\r\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream(bufferSize);\r\n    int len;\r\n    while ((len = in.read(buffer)) != -1) {\r\n        baos.write(buffer, 0, len);\r\n    }\r\n    return baos.toByteArray();\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.CloseGuard.warnIfOpen",
	"Comment": "if closeguard is enabled, logs a warning if the caller did notproperly cleanup by calling an explicit close methodbefore finalization. if closeguard is disabled, no action isperformed.",
	"Method": "void warnIfOpen(){\r\n    if (allocationSite == null || !ENABLED) {\r\n        return;\r\n    }\r\n    String message = (\"A resource was acquired at attached stack trace but never released. \" + \"See java.io.Closeable for information on avoiding resource leaks.\");\r\n    REPORTER.report(message, allocationSite);\r\n}"
}, {
	"Path": "mondrian.test.loader.MondrianFoodMartLoader.load",
	"Comment": "load output from the input, optionally creating tables,populating tables and creating indexes",
	"Method": "void load(){\r\n    if (!StringUtils.isBlank(jdbcDrivers)) {\r\n        RolapUtil.loadDrivers(jdbcDrivers);\r\n    }\r\n    if (userName == null) {\r\n        connection = DriverManager.getConnection(jdbcURL);\r\n    } else {\r\n        connection = DriverManager.getConnection(jdbcURL, userName, password);\r\n    }\r\n    if (jdbcInput) {\r\n        if (inputUserName == null) {\r\n            inputConnection = DriverManager.getConnection(inputJdbcURL);\r\n        } else {\r\n            inputConnection = DriverManager.getConnection(inputJdbcURL, inputUserName, inputPassword);\r\n        }\r\n    }\r\n    final DatabaseMetaData metaData = connection.getMetaData();\r\n    String productName = metaData.getDatabaseProductName();\r\n    String version = metaData.getDatabaseProductVersion();\r\n    LOGGER.info(\"Output connection is \" + productName + \", version: \" + version);\r\n    dialect = DialectManager.createDialect(null, connection);\r\n    LOGGER.info(\"Mondrian Dialect is \" + dialect + \", detected database product: \" + dialect.getDatabaseProduct());\r\n    if (dialect.getDatabaseProduct() == Dialect.DatabaseProduct.INFOBRIGHT && indexes) {\r\n        System.out.println(\"Infobright engine detected: ignoring indexes\");\r\n        indexes = false;\r\n    }\r\n    if (outputBatchSize == -1) {\r\n        if (dialect.getDatabaseProduct() == Dialect.DatabaseProduct.LUCIDDB) {\r\n            outputBatchSize = 1000;\r\n        } else {\r\n            outputBatchSize = 50;\r\n        }\r\n    }\r\n    if (dialect.getDatabaseProduct() == Dialect.DatabaseProduct.LUCIDDB) {\r\n        generateUniqueConstraints = true;\r\n    }\r\n    try {\r\n        final Condition<String> tableFilter;\r\n        if (include != null || exclude != null) {\r\n            tableFilter = new Condition<String>() {\r\n                public boolean test(String tableName) {\r\n                    if (include != null) {\r\n                        if (!include.matcher(tableName).matches()) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    if (exclude != null) {\r\n                        if (!exclude.matcher(tableName).matches()) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                    return true;\r\n                }\r\n            };\r\n        } else {\r\n            tableFilter = new Condition<String>() {\r\n                public boolean test(String s) {\r\n                    return true;\r\n                }\r\n            };\r\n        }\r\n        if (generateUniqueConstraints) {\r\n            createIndexes(false, false, tableFilter);\r\n        }\r\n        createTables(tableFilter);\r\n        if (data) {\r\n            if (!populationQueries) {\r\n                if (jdbcInput) {\r\n                    loadDataFromJdbcInput(tableFilter, pauseMillis, outputBatchSize);\r\n                } else {\r\n                    loadDataFromFile(tableFilter, pauseMillis, outputBatchSize);\r\n                }\r\n            }\r\n            if (indexes) {\r\n                createIndexes(true, false, tableFilter);\r\n            }\r\n            loadFromSqlInserts();\r\n        } else {\r\n            if (indexes) {\r\n                createIndexes(true, false, tableFilter);\r\n            }\r\n        }\r\n        if (indexes && aggregates) {\r\n            createIndexes(false, true, tableFilter);\r\n        }\r\n        if (analyze) {\r\n            analyzeTables();\r\n        }\r\n    } finally {\r\n        if (connection != null) {\r\n            connection.close();\r\n            connection = null;\r\n        }\r\n        if (inputConnection != null) {\r\n            inputConnection.close();\r\n            inputConnection = null;\r\n        }\r\n        if (fileOutput != null) {\r\n            fileOutput.close();\r\n            fileOutput = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.loader.MondrianFoodMartLoader.load",
	"Comment": "load output from the input, optionally creating tables,populating tables and creating indexes",
	"Method": "void load(){\r\n    if (include != null) {\r\n        if (!include.matcher(tableName).matches()) {\r\n            return false;\r\n        }\r\n    }\r\n    if (exclude != null) {\r\n        if (!exclude.matcher(tableName).matches()) {\r\n            return true;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "mondrian.test.loader.MondrianFoodMartLoader.load",
	"Comment": "load output from the input, optionally creating tables,populating tables and creating indexes",
	"Method": "void load(){\r\n    return true;\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletResponse.sendRedirect",
	"Comment": "sends a temporary redirect response to the client using the specifiedredirect location url.",
	"Method": "void sendRedirect(String location){\r\n    setHeader(\"Location\", location);\r\n    wasRedirectSent = true;\r\n}"
}, {
	"Path": "mondrian.test.PropertiesTest.testMandatoryMemberProperties",
	"Comment": "tests existence and values of mandatory member properties.",
	"Method": "void testMandatoryMemberProperties(){\r\n    Cube salesCube = getConnection().getSchema().lookupCube(\"Sales\", true);\r\n    SchemaReader scr = salesCube.getSchemaReader(null).withLocus();\r\n    Member member = scr.getMemberByUniqueName(Id.Segment.toList(\"Customers\", \"All Customers\", \"USA\", \"CA\"), true);\r\n    final boolean caseSensitive = MondrianProperties.instance().CaseSensitive.get();\r\n    String stringPropValue;\r\n    Integer intPropValue;\r\n    stringPropValue = (String) member.getPropertyValue(\"SCHEMA_NAME\");\r\n    assertEquals(getConnection().getSchema().getName(), stringPropValue);\r\n    stringPropValue = (String) member.getPropertyValue(\"DIMENSION_UNIQUE_NAME\");\r\n    assertEquals(member.getDimension().getUniqueName(), stringPropValue);\r\n    stringPropValue = (String) member.getPropertyValue(\"dimension_unique_name\", caseSensitive);\r\n    if (caseSensitive) {\r\n        assertNull(stringPropValue);\r\n    } else {\r\n        assertEquals(member.getDimension().getUniqueName(), stringPropValue);\r\n    }\r\n    stringPropValue = (String) member.getPropertyValue(\"DIMENSION_UNIQUE_NAME_XXXX\");\r\n    assertNull(stringPropValue);\r\n    stringPropValue = (String) member.getPropertyValue(\" DIMENSION_UNIQUE_NAME\");\r\n    assertNull(stringPropValue);\r\n    stringPropValue = (String) member.getPropertyValue(\"DIMENSION_UNIQUE_NAME  \");\r\n    assertNull(stringPropValue);\r\n    stringPropValue = (String) member.getPropertyValue(\"HIERARCHY_UNIQUE_NAME\");\r\n    assertEquals(member.getHierarchy().getUniqueName(), stringPropValue);\r\n    stringPropValue = (String) member.getPropertyValue(\"LEVEL_UNIQUE_NAME\");\r\n    assertEquals(member.getLevel().getUniqueName(), stringPropValue);\r\n    intPropValue = (Integer) member.getPropertyValue(\"LEVEL_NUMBER\");\r\n    assertEquals(Integer.valueOf(member.getLevel().getDepth()), intPropValue);\r\n    stringPropValue = (String) member.getPropertyValue(\"MEMBER_UNIQUE_NAME\");\r\n    assertEquals(member.getUniqueName(), stringPropValue);\r\n    stringPropValue = (String) member.getPropertyValue(\"MEMBER_NAME\");\r\n    assertEquals(member.getName(), stringPropValue);\r\n    intPropValue = (Integer) member.getPropertyValue(\"MEMBER_TYPE\");\r\n    assertEquals(Integer.valueOf(member.getMemberType().ordinal()), intPropValue);\r\n    stringPropValue = (String) member.getPropertyValue(\"MEMBER_GUID\");\r\n    assertNull(stringPropValue);\r\n    stringPropValue = (String) member.getPropertyValue(\"MEMBER_CAPTION\");\r\n    assertEquals(member.getCaption(), stringPropValue);\r\n    stringPropValue = (String) member.getPropertyValue(\"CAPTION\");\r\n    assertEquals(member.getCaption(), stringPropValue);\r\n    stringPropValue = (String) member.getPropertyValue(\"caption\", caseSensitive);\r\n    if (caseSensitive) {\r\n        assertNull(stringPropValue);\r\n    } else {\r\n        assertEquals(member.getCaption(), stringPropValue);\r\n    }\r\n    intPropValue = (Integer) member.getPropertyValue(\"MEMBER_ORDINAL\");\r\n    assertEquals(Integer.valueOf(member.getOrdinal()), intPropValue);\r\n    if (false) {\r\n        intPropValue = (Integer) member.getPropertyValue(\"CHILDREN_CARDINALITY\");\r\n        assertEquals(Integer.valueOf(scr.getMemberChildren(member).size()), intPropValue);\r\n    }\r\n    intPropValue = (Integer) member.getPropertyValue(\"PARENT_LEVEL\");\r\n    assertEquals(Integer.valueOf(member.getParentMember().getLevel().getDepth()), intPropValue);\r\n    stringPropValue = (String) member.getPropertyValue(\"PARENT_UNIQUE_NAME\");\r\n    assertEquals(member.getParentUniqueName(), stringPropValue);\r\n    intPropValue = (Integer) member.getPropertyValue(\"PARENT_COUNT\");\r\n    assertEquals(Integer.valueOf(1), intPropValue);\r\n    stringPropValue = (String) member.getPropertyValue(\"DESCRIPTION\");\r\n    assertEquals(member.getDescription(), stringPropValue);\r\n    stringPropValue = (String) member.getPropertyValue(\"desCription\", caseSensitive);\r\n    if (caseSensitive) {\r\n        assertNull(stringPropValue);\r\n    } else {\r\n        assertEquals(member.getDescription(), stringPropValue);\r\n    }\r\n}"
}, {
	"Path": "mondrian.xmla.impl.AuthenticatingXmlaRequestCallback.throwAuthenticationException",
	"Comment": "helper method to create and throw an authentication exception.",
	"Method": "void throwAuthenticationException(String reason){\r\n    throw new XmlaException(XmlaConstants.CLIENT_FAULT_FC, XmlaConstants.CHH_AUTHORIZATION_CODE, XmlaConstants.CHH_AUTHORIZATION_FAULT_FS, new Exception(\"There was a problem with the credentials: \" + reason));\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Body.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Body appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.olap.Walker.getAncestorOrdinal",
	"Comment": "get the ordinal within its parent node of the idepththancestor.",
	"Method": "int getAncestorOrdinal(int iDepth){\r\n    Frame f = getAncestorFrame(iDepth);\r\n    return f == null ? -1 : f.parent == null ? 0 : arrayFind(f.parent.children, f.node);\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentArrayQuerySpec.isValid",
	"Comment": "returns whether this query specification is valid, or throws if invalidand fail is true.",
	"Method": "boolean isValid(boolean fail){\r\n    assert segments.size() > 0;\r\n    for (Segment segment : segments) {\r\n        int n = segment.predicates.length;\r\n        if (n != segment0.predicates.length) {\r\n            assert !fail;\r\n            return false;\r\n        }\r\n        for (int j = 0; j < segment.predicates.length; j++) {\r\n            if (segment.predicates[j] != segment0.predicates[j]) {\r\n                assert !fail;\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.selfMaint",
	"Comment": "runs self maintenance on all internal pools.\tthis is typically called by the maintenance thread to manage pool size.",
	"Method": "void selfMaint(){\r\n    if (log.isDebugEnabled())\r\n        log.debug(\"++++ Starting self maintenance....\");\r\n    Map<String, Integer> needSockets = new HashMap<String, Integer>();\r\n    synchronized (this) {\r\n        for (Iterator<String> i = availPool.keySet().iterator(); i.hasNext(); ) {\r\n            String host = i.next();\r\n            Map<SockIO, Long> sockets = availPool.get(host);\r\n            if (log.isDebugEnabled())\r\n                log.debug(\"++++ Size of avail pool for host (\" + host + \") = \" + sockets.size());\r\n            if (sockets.size() < minConn) {\r\n                int need = minConn - sockets.size();\r\n                needSockets.put(host, need);\r\n            }\r\n        }\r\n    }\r\n    Map<String, Set<SockIO>> newSockets = new HashMap<String, Set<SockIO>>();\r\n    for (String host : needSockets.keySet()) {\r\n        Integer need = needSockets.get(host);\r\n        if (log.isDebugEnabled())\r\n            log.debug(\"++++ Need to create \" + need + \" new sockets for pool for host: \" + host);\r\n        Set<SockIO> newSock = new HashSet<SockIO>(need);\r\n        for (int j = 0; j < need; j++) {\r\n            SockIO socket = createSocket(host);\r\n            if (socket == null)\r\n                break;\r\n            newSock.add(socket);\r\n        }\r\n        newSockets.put(host, newSock);\r\n    }\r\n    synchronized (this) {\r\n        for (String host : newSockets.keySet()) {\r\n            Set<SockIO> sockets = newSockets.get(host);\r\n            for (SockIO socket : sockets) addSocketToPool(availPool, host, socket);\r\n        }\r\n        for (Iterator<String> i = availPool.keySet().iterator(); i.hasNext(); ) {\r\n            String host = i.next();\r\n            Map<SockIO, Long> sockets = availPool.get(host);\r\n            if (log.isDebugEnabled())\r\n                log.debug(\"++++ Size of avail pool for host (\" + host + \") = \" + sockets.size());\r\n            if (sockets.size() > maxConn) {\r\n                int diff = sockets.size() - maxConn;\r\n                int needToClose = (diff <= poolMultiplier) ? diff : (diff) / poolMultiplier;\r\n                if (log.isDebugEnabled())\r\n                    log.debug(\"++++ need to remove \" + needToClose + \" spare sockets for pool for host: \" + host);\r\n                for (Iterator<SockIO> j = sockets.keySet().iterator(); j.hasNext(); ) {\r\n                    if (needToClose <= 0)\r\n                        break;\r\n                    SockIO socket = j.next();\r\n                    long expire = sockets.get(socket).longValue();\r\n                    if ((expire + maxIdle) < System.currentTimeMillis()) {\r\n                        if (log.isDebugEnabled())\r\n                            log.debug(\"+++ removing stale entry from pool as it is past its idle timeout and pool is over max spare\");\r\n                        deadPool.put(socket, ZERO);\r\n                        j.remove();\r\n                        needToClose--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (Iterator<String> i = busyPool.keySet().iterator(); i.hasNext(); ) {\r\n            String host = i.next();\r\n            Map<SockIO, Long> sockets = busyPool.get(host);\r\n            if (log.isDebugEnabled())\r\n                log.debug(\"++++ Size of busy pool for host (\" + host + \")  = \" + sockets.size());\r\n            for (Iterator<SockIO> j = sockets.keySet().iterator(); j.hasNext(); ) {\r\n                SockIO socket = j.next();\r\n                long hungTime = sockets.get(socket).longValue();\r\n                if ((hungTime + maxBusyTime) < System.currentTimeMillis()) {\r\n                    log.error(\"+++ removing potentially hung connection from busy pool ... socket in pool for \" + (System.currentTimeMillis() - hungTime) + \"ms\");\r\n                    deadPool.put(socket, ZERO);\r\n                    j.remove();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Set<SockIO> toClose;\r\n    synchronized (deadPool) {\r\n        toClose = deadPool.keySet();\r\n        deadPool = new IdentityHashMap<SockIO, Integer>();\r\n    }\r\n    for (SockIO socket : toClose) {\r\n        try {\r\n            socket.trueClose(false);\r\n        } catch (Exception ex) {\r\n            log.error(\"++++ failed to close SockIO obj from deadPool\");\r\n            log.error(ex.getMessage(), ex);\r\n        }\r\n        socket = null;\r\n    }\r\n    if (log.isDebugEnabled())\r\n        log.debug(\"+++ ending self maintenance.\");\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getInputStream",
	"Comment": "retrieves the body of the request as binary data using aservletinputstream.",
	"Method": "ServletInputStream getInputStream(){\r\n    return new MockServletInputStream(bodyContent.getBytes());\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Meta.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Meta appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.FilterTest.testNotInFilterExcludeNullMember",
	"Comment": "test that if null member is explicitly excluded, then the native filtersql should filter out null members.",
	"Method": "void testNotInFilterExcludeNullMember(){\r\n    propSaver.set(MondrianProperties.instance().ExpandNonNative, false);\r\n    propSaver.set(MondrianProperties.instance().EnableNativeFilter, true);\r\n    boolean requestFreshConnection = true;\r\n    String query = \"With \" + \"Set [*NATIVE_CJ_SET] as 'NonEmptyCrossJoin([*BASE_MEMBERS_Customers],[*BASE_MEMBERS_SQFT])' \" + \"Set [*BASE_MEMBERS_Customers] as 'Filter([Customers].[Country].Members, [Customers].CurrentMember In {[Customers].[All Customers].[USA]})' \" + \"Set [*BASE_MEMBERS_SQFT] as 'Filter([Store Size in SQFT].[Store Sqft].Members, \" + \"[Store Size in SQFT].currentMember not in {[Store Size in SQFT].[All Store Size in SQFTs].[#null], [Store Size in SQFT].[All Store Size in SQFTs].[39696]})' \" + \"Set [*CJ_ROW_AXIS] as 'Generate([*NATIVE_CJ_SET], {([Customers].currentMember,[Store Size in SQFT].currentMember)})' \" + \"Set [*ORDERED_CJ_ROW_AXIS] as 'Order([*CJ_ROW_AXIS], [Store Size in SQFT].currentmember.OrderKey, BASC)' \" + \"Select \" + \"{[Measures].[Customer Count]} on columns, \" + \"Non Empty [*ORDERED_CJ_ROW_AXIS] on rows \" + \"From [Sales]\";\r\n    String result = \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Customer Count]}\\n\" + \"Axis #2:\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[20319]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[21215]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[22478]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[23598]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[23688]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[27694]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[28206]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[30268]}\\n\" + \"{[Customers].[USA], [Store Size in SQFT].[33858]}\\n\" + \"Row #0: 563\\n\" + \"Row #1: 906\\n\" + \"Row #2: 296\\n\" + \"Row #3: 1,147\\n\" + \"Row #4: 1,059\\n\" + \"Row #5: 474\\n\" + \"Row #6: 190\\n\" + \"Row #7: 84\\n\" + \"Row #8: 278\\n\";\r\n    checkNative(0, 9, query, result, requestFreshConnection);\r\n}"
}, {
	"Path": "org.springframework.extensions.jcr.util.CachingMapDecorator.put",
	"Comment": "put an object into the cache, possibly wrapping it with a weakreference.",
	"Method": "V put(K key,V value){\r\n    Object newValue = value;\r\n    if (value == null) {\r\n        newValue = NULL_VALUE;\r\n    } else if (useWeakValue(key, value)) {\r\n        newValue = new WeakReference<Object>(newValue);\r\n    }\r\n    return unwrapReturnValue(this.targetMap.put(key, newValue));\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.createSocket",
	"Comment": "creates a new sockio obj for the given server.\tif server fails to connect, then return null and do not try\tagain until a duration has passed.this duration will grow\tby doubling after each failed attempt to connect.",
	"Method": "SockIO createSocket(String host){\r\n    SockIO socket = null;\r\n    hostDeadLock.lock();\r\n    try {\r\n        if (failover && failback && hostDead.containsKey(host) && hostDeadDur.containsKey(host)) {\r\n            Date store = hostDead.get(host);\r\n            long expire = hostDeadDur.get(host).longValue();\r\n            if ((store.getTime() + expire) > System.currentTimeMillis())\r\n                return null;\r\n        }\r\n    } finally {\r\n        hostDeadLock.unlock();\r\n    }\r\n    try {\r\n        socket = new SockIO(this, host, this.socketTO, this.socketConnectTO, this.nagle);\r\n        if (!socket.isConnected()) {\r\n            log.error(\"++++ failed to get SockIO obj for: \" + host + \" -- new socket is not connected\");\r\n            deadPool.put(socket, ZERO);\r\n            socket = null;\r\n        }\r\n    } catch (Exception ex) {\r\n        log.error(\"++++ failed to get SockIO obj for: \" + host);\r\n        log.error(ex.getMessage(), ex);\r\n        socket = null;\r\n    }\r\n    hostDeadLock.lock();\r\n    try {\r\n        if (socket == null) {\r\n            Date now = new Date();\r\n            hostDead.put(host, now);\r\n            long expire = (hostDeadDur.containsKey(host)) ? (((Long) hostDeadDur.get(host)).longValue() * 2) : 1000;\r\n            if (expire > MAX_RETRY_DELAY)\r\n                expire = MAX_RETRY_DELAY;\r\n            hostDeadDur.put(host, new Long(expire));\r\n            if (log.isDebugEnabled())\r\n                log.debug(\"++++ ignoring dead host: \" + host + \" for \" + expire + \" ms\");\r\n            clearHostFromPool(availPool, host);\r\n        } else {\r\n            if (log.isDebugEnabled())\r\n                log.debug(\"++++ created socket (\" + socket.toString() + \") for host: \" + host);\r\n            if (hostDead.containsKey(host) || hostDeadDur.containsKey(host)) {\r\n                hostDead.remove(host);\r\n                hostDeadDur.remove(host);\r\n            }\r\n        }\r\n    } finally {\r\n        hostDeadLock.unlock();\r\n    }\r\n    return socket;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.S.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "S appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "org.mapsforge.map.reader.ReadBuffer.readFromFile",
	"Comment": "reads the given amount of bytes from the file into the read buffer and resets the internal buffer position. ifthe capacity of the read buffer is too small, a larger one is created automatically.",
	"Method": "boolean readFromFile(int length,boolean readFromFile,long offset,int length){\r\n    if (this.bufferData == null || this.bufferData.length < length) {\r\n        if (length > Parameters.MAXIMUM_BUFFER_SIZE) {\r\n            LOGGER.warning(\"invalid read length: \" + length);\r\n            return false;\r\n        }\r\n        this.bufferData = new byte[length];\r\n        this.bufferWrapper = ByteBuffer.wrap(this.bufferData, 0, length);\r\n    }\r\n    this.bufferPosition = 0;\r\n    this.bufferWrapper.clear();\r\n    synchronized (this.inputChannel) {\r\n        this.inputChannel.position(offset);\r\n        return this.inputChannel.read(this.bufferWrapper) == length;\r\n    }\r\n}"
}, {
	"Path": "mondrian.olap.QueryPart.unparse",
	"Comment": "writes a string representation of this parse treenode to the given writer.",
	"Method": "void unparse(PrintWriter pw){\r\n    pw.print(toString());\r\n}"
}, {
	"Path": "org.jfaster.mango.parser.ParseException.add_escapes",
	"Comment": "used to convert raw characters to their escaped versionwhen these raw version cannot be used as part of an asciistring literal.",
	"Method": "String add_escapes(String str){\r\n    StringBuffer retval = new StringBuffer();\r\n    char ch;\r\n    for (int i = 0; i < str.length(); i++) {\r\n        switch(str.charAt(i)) {\r\n            case 0:\r\n                continue;\r\n            case '\\b':\r\n                retval.append(\"\\\\b\");\r\n                continue;\r\n            case '\\t':\r\n                retval.append(\"\\\\t\");\r\n                continue;\r\n            case '\\n':\r\n                retval.append(\"\\\\n\");\r\n                continue;\r\n            case '\\f':\r\n                retval.append(\"\\\\f\");\r\n                continue;\r\n            case '\\r':\r\n                retval.append(\"\\\\r\");\r\n                continue;\r\n            case '\\\"':\r\n                retval.append(\"\\\\\\\"\");\r\n                continue;\r\n            case '\\'':\r\n                retval.append(\"\\\\\\'\");\r\n                continue;\r\n            case '\\\\':\r\n                retval.append(\"\\\\\\\\\");\r\n                continue;\r\n            default:\r\n                if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\r\n                    String s = \"0000\" + Integer.toString(ch, 16);\r\n                    retval.append(\"\\\%u\" + s.substring(s.length() - 4, s.length()));\r\n                } else {\r\n                    retval.append(ch);\r\n                }\r\n                continue;\r\n        }\r\n    }\r\n    return retval.toString();\r\n}"
}, {
	"Path": "mondrian.rolap.BitKeyTest.testSizeTypes",
	"Comment": "test that the implementation object returned is expected type.",
	"Method": "void testSizeTypes(){\r\n    int size = 0;\r\n    BitKey bitKey = BitKey.Factory.makeBitKey(size);\r\n    assertTrue(\"BitKey size \" + size + \" not BitKey.Small\", (bitKey.getClass() == BitKey.Small.class));\r\n    size = 63;\r\n    bitKey = BitKey.Factory.makeBitKey(size);\r\n    assertTrue(\"BitKey size \" + size + \" not BitKey.Small\", (bitKey.getClass() == BitKey.Small.class));\r\n    size = 64;\r\n    bitKey = BitKey.Factory.makeBitKey(size);\r\n    assertTrue(\"BitKey size \" + size + \" not BitKey.Mid128\", (bitKey.getClass() == BitKey.Mid128.class));\r\n    size = 65;\r\n    bitKey = BitKey.Factory.makeBitKey(size);\r\n    assertTrue(\"BitKey size \" + size + \" not BitKey.Mid128\", (bitKey.getClass() == BitKey.Mid128.class));\r\n    size = 127;\r\n    bitKey = BitKey.Factory.makeBitKey(size);\r\n    assertTrue(\"BitKey size \" + size + \" not BitKey.Mid128\", (bitKey.getClass() == BitKey.Mid128.class));\r\n    size = 128;\r\n    bitKey = BitKey.Factory.makeBitKey(size);\r\n    assertTrue(\"BitKey size \" + size + \" not BitKey.Big\", (bitKey.getClass() == BitKey.Big.class));\r\n    size = 129;\r\n    bitKey = BitKey.Factory.makeBitKey(size);\r\n    assertTrue(\"BitKey size \" + size + \" not BitKey.Big\", (bitKey.getClass() == BitKey.Big.class));\r\n    size = 1280;\r\n    bitKey = BitKey.Factory.makeBitKey(size);\r\n    assertTrue(\"BitKey size \" + size + \" not BitKey.Big\", (bitKey.getClass() == BitKey.Big.class));\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Label.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Label appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.test.UdfTest.testUdfNeitherScriptNorClassname",
	"Comment": "unit test that ensures that a udf has either a script or a classname.",
	"Method": "void testUdfNeitherScriptNorClassname(){\r\n    TestContext tc = udfTestContext(\"<UserDefinedFunction name='StringMult'/>\\n\");\r\n    tc.assertQueryThrows(\"select from [Sales]\", \"Must specify either className attribute or Script element\");\r\n}"
}, {
	"Path": "mondrian.olap.MondrianPropertiesBase.loadIfStale",
	"Comment": "reads properties from a source.if the source does not exist, or has not changed since we last read it,does nothing.",
	"Method": "void loadIfStale(PropertySource source){\r\n    if (source.isStale()) {\r\n        if (LOGGER.isDebugEnabled()) {\r\n            LOGGER.debug(\"Mondrian: loading \" + source.getDescription());\r\n        }\r\n        load(source);\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.model.TDNode.fromNode",
	"Comment": "constructs a new tdnode from a given osmosis node entity. checks the validity of the entity.",
	"Method": "TDNode fromNode(Node node,List<String> preferredLanguages){\r\n    SpecialTagExtractionResult ster = OSMUtils.extractSpecialFields(node, preferredLanguages);\r\n    Map<Short, Object> knownWayTags = OSMUtils.extractKnownPOITags(node);\r\n    return new TDNode(node.getId(), LatLongUtils.degreesToMicrodegrees(node.getLatitude()), LatLongUtils.degreesToMicrodegrees(node.getLongitude()), ster.getElevation(), ster.getLayer(), ster.getHousenumber(), ster.getName(), knownWayTags);\r\n}"
}, {
	"Path": "mondrian.test.UdfTest.udfTestContext",
	"Comment": "shorthand for containing a test context that consists of the standardfoodmart schema plus a udf.",
	"Method": "TestContext udfTestContext(String xmlUdf){\r\n    return TestContext.instance().create(null, null, null, null, xmlUdf, null);\r\n}"
}, {
	"Path": "mondrian.test.CompoundSlicerTest.testSimulatedCompoundSlicer",
	"Comment": "query that simulates a compound slicer by creating a calculated memberthat aggregates over a set and places it in the where clause.",
	"Method": "void testSimulatedCompoundSlicer(){\r\n    assertQueryReturns(\"with\\n\" + \"  member [Measures].[Price per Unit] as\\n\" + \"    [Measures].[Store Sales] / [Measures].[Unit Sales]\\n\" + \"  set [Top Products] as\\n\" + \"    TopCount(\\n\" + \"      [Product].[Brand Name].Members,\\n\" + \"      3,\\n\" + \"      ([Measures].[Unit Sales], [Time].[1997].[Q3]))\\n\" + \"  member [Product].[Top] as\\n\" + \"    Aggregate([Top Products])\\n\" + \"select {\\n\" + \"  [Measures].[Unit Sales],\\n\" + \"  [Measures].[Price per Unit]} on 0,\\n\" + \" [Gender].Children * [Marital Status].Children on 1\\n\" + \"from [Sales]\\n\" + \"where ([Product].[Top], [Time].[1997].[Q3])\", \"Axis #0:\\n\" + \"{[Product].[Top], [Time].[1997].[Q3]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"{[Measures].[Price per Unit]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[F], [Marital Status].[M]}\\n\" + \"{[Gender].[F], [Marital Status].[S]}\\n\" + \"{[Gender].[M], [Marital Status].[M]}\\n\" + \"{[Gender].[M], [Marital Status].[S]}\\n\" + \"Row #0: 779\\n\" + \"Row #0: 2.40\\n\" + \"Row #1: 811\\n\" + \"Row #1: 2.24\\n\" + \"Row #2: 829\\n\" + \"Row #2: 2.23\\n\" + \"Row #3: 886\\n\" + \"Row #3: 2.25\\n\");\r\n    assertQueryReturns(\"with\\n\" + \"  member [Measures].[Price per Unit] as\\n\" + \"    [Measures].[Store Sales] / [Measures].[Unit Sales]\\n\" + \"  set [Top Products] as\\n\" + \"    TopCount(\\n\" + \"      [Product].[Brand Name].Members,\\n\" + \"      3,\\n\" + \"      ([Measures].[Unit Sales], [Time].[1997].[Q3]))\\n\" + \"select {\\n\" + \"  [Measures].[Unit Sales],\\n\" + \"  [Measures].[Price per Unit]} on 0,\\n\" + \" [Gender].Children * [Marital Status].Children on 1\\n\" + \"from [Sales]\\n\" + \"where [Top Products] * [Time].[1997].[Q3]\", \"Axis #0:\\n\" + \"{[Product].[Food].[Produce].[Vegetables].[Fresh Vegetables].[Hermanos], [Time].[1997].[Q3]}\\n\" + \"{[Product].[Food].[Produce].[Vegetables].[Fresh Vegetables].[Tell Tale], [Time].[1997].[Q3]}\\n\" + \"{[Product].[Food].[Produce].[Vegetables].[Fresh Vegetables].[Ebony], [Time].[1997].[Q3]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"{[Measures].[Price per Unit]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[F], [Marital Status].[M]}\\n\" + \"{[Gender].[F], [Marital Status].[S]}\\n\" + \"{[Gender].[M], [Marital Status].[M]}\\n\" + \"{[Gender].[M], [Marital Status].[S]}\\n\" + \"Row #0: 779\\n\" + \"Row #0: 2.40\\n\" + \"Row #1: 811\\n\" + \"Row #1: 2.24\\n\" + \"Row #2: 829\\n\" + \"Row #2: 2.23\\n\" + \"Row #3: 886\\n\" + \"Row #3: 2.25\\n\");\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Big.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Big appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.structure.DrawerItem.setTextSecondary",
	"Comment": "sets a secondary text with a given text mode to the drawer item",
	"Method": "DrawerItem setTextSecondary(String textSecondary,int textMode,DrawerItem setTextSecondary,String textSecondary){\r\n    setTextSecondary(textSecondary, TWO_LINE);\r\n    return this;\r\n}"
}, {
	"Path": "mondrian.test.BasicQueryTest.testNonEmptyCrossJoin",
	"Comment": "tests a query with a crossjoin so large that we run out of memory unlesswe can push down evaluation to sql.",
	"Method": "void testNonEmptyCrossJoin(){\r\n    if (!props.EnableNativeCrossJoin.get()) {\r\n        return;\r\n    }\r\n    TestContext.instance().flushSchemaCache();\r\n    Result result = executeQuery(\"select {[Measures].[Store Sales]} on columns,\\n\" + \"  NON EMPTY Crossjoin(\\n\" + \"    [Customers].[Name].Members,\\n\" + \"    [Product].[Product Name].Members\\n\" + \" ) ON rows\\n\" + \"from [Sales]\\n\" + \"where (\\n\" + \"  [Store].[All Stores].[USA].[CA].[San Francisco].[Store 14],\\n\" + \"  [Time].[1997].[Q1].[1]\\n\" + \")\\n\");\r\n    Axis a = result.getAxes()[1];\r\n    assertEquals(67, a.getPositions().size());\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.structure.DrawerItem.setRoundedImage",
	"Comment": "sets a rounded image with a given image mode to the drawer item",
	"Method": "DrawerItem setRoundedImage(BitmapDrawable image,int imageMode,DrawerItem setRoundedImage,BitmapDrawable image,DrawerItem setRoundedImage,Context context,Bitmap image,int imageMode,DrawerItem setRoundedImage,Context context,Bitmap image){\r\n    return setImage(new RoundedAvatarDrawable(new BitmapDrawable(context.getResources(), image).getBitmap()), AVATAR);\r\n}"
}, {
	"Path": "mondrian.rolap.VirtualCubeTest.testNativeSetCaching",
	"Comment": "checks that native set caching considers base cubes in the cache key.native sets referencing different base cubes do not share the cachedresult.",
	"Method": "void testNativeSetCaching(){\r\n    final Dialect dialect = getTestContext().getDialect();\r\n    if (dialect.getDatabaseProduct() != Dialect.DatabaseProduct.DERBY) {\r\n        return;\r\n    }\r\n    if (!MondrianProperties.instance().EnableNativeCrossJoin.get() && !MondrianProperties.instance().EnableNativeNonEmpty.get()) {\r\n        return;\r\n    }\r\n    String query1 = \"With \" + \"Set [*NATIVE_CJ_SET] as 'NonEmptyCrossJoin([Product].[Product Family].Members, [Store].[Store Country].Members)' \" + \"Select \" + \"{[Store Sales]} on columns, \" + \"Non Empty Generate([*NATIVE_CJ_SET], {([Product].CurrentMember,[Store].CurrentMember)}) on rows \" + \"From [Warehouse and Sales]\";\r\n    String query2 = \"With \" + \"Set [*NATIVE_CJ_SET] as 'NonEmptyCrossJoin([Product].[Product Family].Members, [Store].[Store Country].Members)' \" + \"Select \" + \"{[Warehouse Sales]} on columns, \" + \"Non Empty Generate([*NATIVE_CJ_SET], {([Product].CurrentMember,[Store].CurrentMember)}) on rows \" + \"From [Warehouse and Sales]\";\r\n    String derbyNecjSql1, derbyNecjSql2;\r\n    if (MondrianProperties.instance().EnableNativeCrossJoin.get()) {\r\n        derbyNecjSql1 = \"select \" + \"\\\"product_class\\\".\\\"product_family\\\", \" + \"\\\"store\\\".\\\"store_country\\\" \" + \"from \" + \"\\\"product\\\" as \\\"product\\\", \" + \"\\\"product_class\\\" as \\\"product_class\\\", \" + \"\\\"sales_fact_1997\\\" as \\\"sales_fact_1997\\\", \" + \"\\\"store\\\" as \\\"store\\\" \" + \"where \" + \"\\\"product\\\".\\\"product_class_id\\\" = \\\"product_class\\\".\\\"product_class_id\\\" \" + \"and \\\"sales_fact_1997\\\".\\\"product_id\\\" = \\\"product\\\".\\\"product_id\\\" \" + \"and \\\"sales_fact_1997\\\".\\\"store_id\\\" = \\\"store\\\".\\\"store_id\\\" \" + \"group by \\\"product_class\\\".\\\"product_family\\\", \\\"store\\\".\\\"store_country\\\" \" + \"order by 1 ASC, 2 ASC\";\r\n        derbyNecjSql2 = \"select \" + \"\\\"product_class\\\".\\\"product_family\\\", \" + \"\\\"store\\\".\\\"store_country\\\" \" + \"from \" + \"\\\"product\\\" as \\\"product\\\", \" + \"\\\"product_class\\\" as \\\"product_class\\\", \" + \"\\\"inventory_fact_1997\\\" as \\\"inventory_fact_1997\\\", \" + \"\\\"store\\\" as \\\"store\\\" \" + \"where \" + \"\\\"product\\\".\\\"product_class_id\\\" = \\\"product_class\\\".\\\"product_class_id\\\" \" + \"and \\\"inventory_fact_1997\\\".\\\"product_id\\\" = \\\"product\\\".\\\"product_id\\\" \" + \"and \\\"inventory_fact_1997\\\".\\\"store_id\\\" = \\\"store\\\".\\\"store_id\\\" \" + \"group by \\\"product_class\\\".\\\"product_family\\\", \\\"store\\\".\\\"store_country\\\" \" + \"order by 1 ASC, 2 ASC\";\r\n    } else {\r\n        derbyNecjSql1 = \"select \" + \"\\\"store\\\".\\\"store_country\\\" \" + \"from \" + \"\\\"store\\\" as \\\"store\\\", \" + \"\\\"sales_fact_1997\\\" as \\\"sales_fact_1997\\\" \" + \"where \" + \"\\\"sales_fact_1997\\\".\\\"store_id\\\" = \\\"store\\\".\\\"store_id\\\" \" + \"group by \\\"store\\\".\\\"store_country\\\" \" + \"order by 1 ASC\";\r\n        derbyNecjSql2 = \"select \" + \"\\\"store\\\".\\\"store_country\\\" \" + \"from \" + \"\\\"store\\\" as \\\"store\\\", \" + \"\\\"inventory_fact_1997\\\" as \\\"inventory_fact_1997\\\" \" + \"where \" + \"\\\"inventory_fact_1997\\\".\\\"store_id\\\" = \\\"store\\\".\\\"store_id\\\" \" + \"group by \\\"store\\\".\\\"store_country\\\" \" + \"order by 1 ASC\";\r\n    }\r\n    SqlPattern[] patterns1 = { new SqlPattern(Dialect.DatabaseProduct.DERBY, derbyNecjSql1, derbyNecjSql1) };\r\n    SqlPattern[] patterns2 = { new SqlPattern(Dialect.DatabaseProduct.DERBY, derbyNecjSql2, derbyNecjSql2) };\r\n    assertQuerySql(query1, patterns1, true);\r\n    assertQuerySql(query2, patterns2, false);\r\n}"
}, {
	"Path": "mondrian.util.NotificationMemoryMonitor.notifyNewLowThreshold",
	"Comment": "notify the java5 memory management system that there is a newlow threshold.",
	"Method": "void notifyNewLowThreshold(long newLowThreshold){\r\n    if (newLowThreshold == Long.MAX_VALUE) {\r\n        TENURED_POOL.setUsageThreshold(0);\r\n    } else {\r\n        TENURED_POOL.setUsageThreshold(newLowThreshold);\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.RolapStar.prepareToLoadAggregates",
	"Comment": "place holder in case in the future we wish to be able toreload aggregates. in that case, if aggregates had already been loaded,i.e., this star has some aggstars, then those aggstars are cleared.",
	"Method": "void prepareToLoadAggregates(){\r\n    aggStars.clear();\r\n}"
}, {
	"Path": "mondrian.test.SchemaTest.testNonAliasedDimensionUsage",
	"Comment": "this test displays an informative error message if someone usesan unaliased name instead of an aliased name",
	"Method": "void testNonAliasedDimensionUsage(){\r\n    final TestContext testContext = TestContext.instance().create(null, \"<Cube name=\\\"Sales Two Dimensions\\\">\\n\" + \"  <Table name=\\\"sales_fact_1997\\\"/>\\n\" + \"  <DimensionUsage name=\\\"Time2\\\" source=\\\"Time\\\" foreignKey=\\\"time_id\\\"/>\\n\" + \"  <DimensionUsage name=\\\"Store\\\" source=\\\"Store\\\" foreignKey=\\\"store_id\\\"/>\\n\" + \"  <Measure name=\\\"Unit Sales\\\" column=\\\"unit_sales\\\" aggregator=\\\"sum\\\" \" + \"   formatString=\\\"Standard\\\"/>\\n\" + \"  <Measure name=\\\"Store Cost\\\" column=\\\"store_cost\\\" aggregator=\\\"sum\\\"\" + \"   formatString=\\\"#,###.00\\\"/>\\n\" + \"<\/Cube>\", null, null, null, null);\r\n    final String query = \"select\\n\" + \" {[Time].[1997]} on columns \\n\" + \"From [Sales Two Dimensions]\";\r\n    if (!MondrianProperties.instance().SsasCompatibleNaming.get()) {\r\n        testContext.assertQueryThrows(query, \"In cube \\\"Sales Two Dimensions\\\" use of unaliased Dimension name \\\"[Time]\\\" rather than the alias name \\\"Time2\\\"\");\r\n    } else {\r\n        testContext.assertQueryReturns(query, \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Time2].[Time].[1997]}\\n\" + \"Row #0: 266,773\\n\");\r\n    }\r\n}"
}, {
	"Path": "mondrian.util.Base64.decodeToObject",
	"Comment": "attempts to decode base64 data and deserialize a javaobject within. returns null if there was an error.",
	"Method": "Object decodeToObject(String encodedObject){\r\n    byte[] objBytes = decode(encodedObject);\r\n    java.io.ByteArrayInputStream bais = null;\r\n    java.io.ObjectInputStream ois = null;\r\n    Object obj = null;\r\n    try {\r\n        bais = new java.io.ByteArrayInputStream(objBytes);\r\n        ois = new java.io.ObjectInputStream(bais);\r\n        obj = ois.readObject();\r\n    } catch (java.io.IOException e) {\r\n        e.printStackTrace();\r\n        obj = null;\r\n    } catch (java.lang.ClassNotFoundException e) {\r\n        e.printStackTrace();\r\n        obj = null;\r\n    } finally {\r\n        try {\r\n            bais.close();\r\n        } catch (Exception e) {\r\n        }\r\n        try {\r\n            ois.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "org.msgpack.core.MessagePacker.packLong",
	"Comment": "writes an integer value.this method writes an integer using the smallest format from the int format family.",
	"Method": "MessagePacker packLong(long v){\r\n    if (v < -(1L << 5)) {\r\n        if (v < -(1L << 15)) {\r\n            if (v < -(1L << 31)) {\r\n                writeByteAndLong(INT64, v);\r\n            } else {\r\n                writeByteAndInt(INT32, (int) v);\r\n            }\r\n        } else {\r\n            if (v < -(1 << 7)) {\r\n                writeByteAndShort(INT16, (short) v);\r\n            } else {\r\n                writeByteAndByte(INT8, (byte) v);\r\n            }\r\n        }\r\n    } else if (v < (1 << 7)) {\r\n        writeByte((byte) v);\r\n    } else {\r\n        if (v < (1L << 16)) {\r\n            if (v < (1 << 8)) {\r\n                writeByteAndByte(UINT8, (byte) v);\r\n            } else {\r\n                writeByteAndShort(UINT16, (short) v);\r\n            }\r\n        } else {\r\n            if (v < (1L << 32)) {\r\n                writeByteAndInt(UINT32, (int) v);\r\n            } else {\r\n                writeByteAndLong(UINT64, v);\r\n            }\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "mondrian.tui.MockServletContext.getRequestDispatcher",
	"Comment": "returns a requestdispatcher object that acts as a wrapper for the resource located at the given path.",
	"Method": "RequestDispatcher getRequestDispatcher(String s){\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AggregationManager.loadAggregation",
	"Comment": "called by fastbatchingcellreader.load where therolapstar creates an aggregation if needed.",
	"Method": "void loadAggregation(SegmentCacheManager cacheMgr,int cellRequestCount,List<RolapStar.Measure> measures,RolapStar.Column[] columns,AggregationKey aggregationKey,StarColumnPredicate[] predicates,GroupingSetsCollector groupingSetsCollector,List<Future<Map<Segment, SegmentWithData>>> segmentFutures){\r\n    RolapStar star = measures.get(0).getStar();\r\n    Aggregation aggregation = star.lookupOrCreateAggregation(aggregationKey);\r\n    predicates = aggregation.optimizePredicates(columns, predicates);\r\n    aggregation.load(cacheMgr, cellRequestCount, columns, measures, predicates, groupingSetsCollector, segmentFutures);\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.widget.IcsLinearLayout.setMeasureWithLargestChildEnabled",
	"Comment": "when set to true, all children with a weight will be considered havingthe minimum size of the largest child. if false, all children aremeasured normally.disabled by default.",
	"Method": "void setMeasureWithLargestChildEnabled(boolean enabled){\r\n    mUseLargestChild = enabled;\r\n}"
}, {
	"Path": "net.engio.mbassy.common.ReflectionUtils.getAnnotation",
	"Comment": "searches for an annotation of the given type on the class.supports meta annotations.",
	"Method": "A getAnnotation(AnnotatedElement from,Class<A> annotationType,Set<AnnotatedElement> visited,A getAnnotation,AnnotatedElement from,Class<A> annotationType){\r\n    return getAnnotation(from, annotationType, new HashSet<AnnotatedElement>());\r\n}"
}, {
	"Path": "mondrian.rolap.MemberCacheHelper.flushCache",
	"Comment": "must sync here because we want the three maps to be modified together.",
	"Method": "void flushCache(){\r\n    mapMemberToChildren.clear();\r\n    mapKeyToMember.clear();\r\n    mapLevelToMembers.clear();\r\n    mapParentToNamedChildren.clear();\r\n    for (Level level : rolapHierarchy.getLevels()) {\r\n        ((RolapLevel) level).setApproxRowCount(Integer.MIN_VALUE);\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testDimensionMembers",
	"Comment": "tests that .members exploits the same optimization as.members.",
	"Method": "void testDimensionMembers(){\r\n    TestCase c = new TestCase(34, 34, \"select \\n\" + \"{[Measures].[Unit Sales]} ON columns,\\n\" + \"NON EMPTY [Customers].Members ON rows\\n\" + \"from [Sales]\\n\" + \"where ([Store].[All Stores].[USA].[CA].[San Francisco].[Store 14], [Time].[1997].[Q1].[1])\");\r\n    c.run();\r\n}"
}, {
	"Path": "mondrian.util.FormatTest.testCurrency",
	"Comment": "tests the international currency symbol parsingin format strings according to different locales.",
	"Method": "void testCurrency(){\r\n    checkFormat(localeDe, 123456, \"Currency\", \"123.456,00 ��\");\r\n    checkFormat(localeDe, 123456, \"###,###.00\" + Format.intlCurrencySymbol, \"123.456,00��\");\r\n    checkFormat(localeFra, 123456, \"###,###.00\" + Format.intlCurrencySymbol, \"123.456,00FF\");\r\n    checkFormat(localeFra, 123456, \"Currency\", \"123.456,00FF\");\r\n    checkFormat(Format.createLocale(Locale.JAPANESE), 123456, \"Currency\", \"$ 123,456.00\");\r\n    checkFormat(null, new BigDecimal(\"1.2\"), \"\" + Format.intlCurrencySymbol + \"#\", \"$1\");\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.getDimensionDefaultHierarchy",
	"Comment": "returns the default hierarchy of a dimension, or null if there is nodefault.",
	"Method": "Hierarchy getDimensionDefaultHierarchy(Dimension dimension){\r\n    final Hierarchy[] hierarchies = dimension.getHierarchies();\r\n    if (hierarchies.length == 1) {\r\n        return hierarchies[0];\r\n    }\r\n    if (MondrianProperties.instance().SsasCompatibleNaming.get()) {\r\n        return null;\r\n    }\r\n    for (Hierarchy hierarchy : hierarchies) {\r\n        if (hierarchy.getName() == null || hierarchy.getUniqueName().equals(dimension.getUniqueName())) {\r\n            return hierarchy;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCubeLevel.getStarKeyColumn",
	"Comment": "this is the rolapstar.column that is related to this rolapcubelevel",
	"Method": "RolapStar.Column getStarKeyColumn(){\r\n    return starKeyColumn;\r\n}"
}, {
	"Path": "org.mapsforge.map.layer.queue.JobQueue.get",
	"Comment": "returns the most important entry from this queue. the method blocks while this queue is emptyor while there are already a certain number of jobs assigned.",
	"Method": "T get(T get,int maxAssigned){\r\n    while (this.queueItems.isEmpty() || this.assignedJobs.size() >= maxAssigned) {\r\n        this.wait(200);\r\n        if (this.isInterrupted) {\r\n            this.isInterrupted = false;\r\n            return null;\r\n        }\r\n    }\r\n    if (this.scheduleNeeded) {\r\n        this.scheduleNeeded = false;\r\n        schedule(displayModel.getTileSize());\r\n    }\r\n    T job = this.queueItems.remove(0).object;\r\n    this.assignedJobs.add(job);\r\n    return job;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteConnection.executeForLastInsertedRowId",
	"Comment": "executes a statement that returns the row id of the last row insertedby the statement.use for insert sql statements.",
	"Method": "long executeForLastInsertedRowId(String sql,Object[] bindArgs,CancellationSignal cancellationSignal){\r\n    if (sql == null) {\r\n        throw new IllegalArgumentException(\"sql must not be null.\");\r\n    }\r\n    final int cookie = mRecentOperations.beginOperation(\"executeForLastInsertedRowId\", sql, bindArgs);\r\n    try {\r\n        final PreparedStatement statement = acquirePreparedStatement(sql);\r\n        try {\r\n            throwIfStatementForbidden(statement);\r\n            bindArguments(statement, bindArgs);\r\n            applyBlockGuardPolicy(statement);\r\n            attachCancellationSignal(cancellationSignal);\r\n            try {\r\n                return nativeExecuteForLastInsertedRowId(mConnectionPtr, statement.mStatementPtr);\r\n            } finally {\r\n                detachCancellationSignal(cancellationSignal);\r\n            }\r\n        } finally {\r\n            releasePreparedStatement(statement);\r\n        }\r\n    } catch (RuntimeException ex) {\r\n        mRecentOperations.failOperation(cookie, ex);\r\n        throw ex;\r\n    } finally {\r\n        mRecentOperations.endOperation(cookie);\r\n    }\r\n}"
}, {
	"Path": "org.msgpack.core.MessageUnpacker.readPayloadAsReference",
	"Comment": "reads payload bytes of binary, extension, or raw string types as a reference to internal buffer.this consumes specified amount of bytes and returns its reference or copy. this method tries toreturn reference as much as possible because it is faster. however, it may copy data to a newlyallocated buffer if reference is not applicable.",
	"Method": "MessageBuffer readPayloadAsReference(int length){\r\n    int bufferRemaining = buffer.size() - position;\r\n    if (bufferRemaining >= length) {\r\n        MessageBuffer slice = buffer.slice(position, length);\r\n        position += length;\r\n        return slice;\r\n    }\r\n    MessageBuffer dst = MessageBuffer.allocate(length);\r\n    readPayload(dst, 0, length);\r\n    return dst;\r\n}"
}, {
	"Path": "org.mapsforge.map.rendertheme.rule.RenderTheme.scaleTextSize",
	"Comment": "scales the text size of this rendertheme by the given factor for a given zoom level.",
	"Method": "void scaleTextSize(float scaleFactor,byte zoomLevel){\r\n    if (!textScales.containsKey(zoomLevel) || scaleFactor != textScales.get(zoomLevel)) {\r\n        for (int i = 0, n = this.rulesList.size(); i < n; ++i) {\r\n            Rule rule = this.rulesList.get(i);\r\n            if (rule.zoomMin <= zoomLevel && rule.zoomMax >= zoomLevel) {\r\n                rule.scaleTextSize(scaleFactor * this.baseTextSize, zoomLevel);\r\n            }\r\n        }\r\n        textScales.put(zoomLevel, scaleFactor);\r\n    }\r\n}"
}, {
	"Path": "mondrian.calc.impl.AbstractCalc.collectArguments",
	"Comment": "collects any other arguments to this calc.the default implementation returns name, class, type, resultstyle.a subclass must call super, but may add other arguments.",
	"Method": "void collectArguments(Map<String, Object> arguments){\r\n    arguments.put(\"name\", getName());\r\n    arguments.put(\"class\", getClass());\r\n    arguments.put(\"type\", getType());\r\n    arguments.put(\"resultStyle\", getResultStyle());\r\n}"
}, {
	"Path": "mondrian.rolap.SqlTupleReader.getLevelIndices",
	"Comment": "gets an array of the indexes of tuple attributes as theyappear in the target ordering.",
	"Method": "int[] getLevelIndices(TupleList tupleList,List<TargetBase> targets){\r\n    assert !tupleList.isEmpty();\r\n    assert targets.size() == tupleList.get(0).size();\r\n    int[] indices = new int[targets.size()];\r\n    List<Member> tuple = tupleList.get(0);\r\n    int i = 0;\r\n    for (TargetBase target : targets) {\r\n        indices[i++] = getIndexOfLevel(target.getLevel(), tuple);\r\n    }\r\n    return indices;\r\n}"
}, {
	"Path": "mondrian.util.ObjectPool.iterator",
	"Comment": "returns an iterator of this objectpool. the order ofthe objects returned by the iterator can not becounted on to be in the same order as they were insertedinto the objectpool.theiterator returned does notsupport the removal of objectpool members.",
	"Method": "Iterator<T> iterator(){\r\n    return new Itr();\r\n}"
}, {
	"Path": "mondrian.test.SchemaTest.testCaptionDescriptionAndAnnotation",
	"Comment": "test for descriptions, captions and annotations of various schemaelements.",
	"Method": "void testCaptionDescriptionAndAnnotation(){\r\n    final String schemaName = \"Description schema\";\r\n    final String salesCubeName = \"DescSales\";\r\n    final String virtualCubeName = \"DescWarehouseAndSales\";\r\n    final String warehouseCubeName = \"Warehouse\";\r\n    final TestContext testContext = TestContext.instance().withSchema(\"<Schema name=\\\"\" + schemaName + \"\\\"\\n\" + \" description=\\\"Schema to test descriptions and captions\\\">\\n\" + \"  <Annotations>\\n\" + \"    <Annotation name=\\\"a\\\">Schema<\/Annotation>\\n\" + \"    <Annotation name=\\\"b\\\">Xyz<\/Annotation>\\n\" + \"  <\/Annotations>\\n\" + \"  <Dimension name=\\\"Time\\\" type=\\\"TimeDimension\\\"\\n\" + \"      caption=\\\"Time shared caption\\\"\\n\" + \"      description=\\\"Time shared description\\\">\\n\" + \"    <Annotations><Annotation name=\\\"a\\\">Time shared<\/Annotation><\/Annotations>\\n\" + \"    <Hierarchy hasAll=\\\"false\\\" primaryKey=\\\"time_id\\\"\\n\" + \"        caption=\\\"Time shared hierarchy caption\\\"\\n\" + \"        description=\\\"Time shared hierarchy description\\\">\\n\" + \"      <Table name=\\\"time_by_day\\\"/>\\n\" + \"      <Level name=\\\"Year\\\" column=\\\"the_year\\\" type=\\\"Numeric\\\" uniqueMembers=\\\"true\\\"\\n\" + \"          levelType=\\\"TimeYears\\\"/>\\n\" + \"      <Level name=\\\"Quarter\\\" column=\\\"quarter\\\" uniqueMembers=\\\"false\\\"\\n\" + \"          levelType=\\\"TimeQuarters\\\"/>\\n\" + \"      <Level name=\\\"Month\\\" column=\\\"month_of_year\\\" uniqueMembers=\\\"false\\\" type=\\\"Numeric\\\"\\n\" + \"          levelType=\\\"TimeMonths\\\"/>\\n\" + \"    <\/Hierarchy>\\n\" + \"  <\/Dimension>\\n\" + \"  <Dimension name=\\\"Warehouse\\\">\\n\" + \"    <Hierarchy hasAll=\\\"true\\\" primaryKey=\\\"warehouse_id\\\">\\n\" + \"      <Table name=\\\"warehouse\\\"/>\\n\" + \"      <Level name=\\\"Country\\\" column=\\\"warehouse_country\\\" uniqueMembers=\\\"true\\\"/>\\n\" + \"      <Level name=\\\"State Province\\\" column=\\\"warehouse_state_province\\\"\\n\" + \"          uniqueMembers=\\\"true\\\"/>\\n\" + \"      <Level name=\\\"City\\\" column=\\\"warehouse_city\\\" uniqueMembers=\\\"false\\\"/>\\n\" + \"      <Level name=\\\"Warehouse Name\\\" column=\\\"warehouse_name\\\" uniqueMembers=\\\"true\\\"/>\\n\" + \"    <\/Hierarchy>\\n\" + \"  <\/Dimension>\\n\" + \"  <Cube name=\\\"\" + salesCubeName + \"\\\"\\n\" + \"    description=\\\"Cube description\\\">\\n\" + \"  <Annotations><Annotation name=\\\"a\\\">Cube<\/Annotation><\/Annotations>\\n\" + \"  <Table name=\\\"sales_fact_1997\\\"/>\\n\" + \"  <Dimension name=\\\"Store\\\" foreignKey=\\\"store_id\\\"\\n\" + \"      caption=\\\"Dimension caption\\\"\\n\" + \"      description=\\\"Dimension description\\\">\\n\" + \"    <Annotations><Annotation name=\\\"a\\\">Dimension<\/Annotation><\/Annotations>\\n\" + \"    <Hierarchy hasAll=\\\"true\\\" primaryKeyTable=\\\"store\\\" primaryKey=\\\"store_id\\\"\\n\" + \"        caption=\\\"Hierarchy caption\\\"\\n\" + \"        description=\\\"Hierarchy description\\\">\\n\" + \"      <Annotations><Annotation name=\\\"a\\\">Hierarchy<\/Annotation><\/Annotations>\\n\" + \"      <Join leftKey=\\\"region_id\\\" rightKey=\\\"region_id\\\">\\n\" + \"        <Table name=\\\"store\\\"/>\\n\" + \"        <Join leftKey=\\\"sales_district_id\\\" rightKey=\\\"promotion_id\\\">\\n\" + \"          <Table name=\\\"region\\\"/>\\n\" + \"          <Table name=\\\"promotion\\\"/>\\n\" + \"        <\/Join>\\n\" + \"      <\/Join>\\n\" + \"      <Level name=\\\"Store Country\\\" table=\\\"store\\\" column=\\\"store_country\\\"\\n\" + \"          description=\\\"Level description\\\"\" + \"          caption=\\\"Level caption\\\">\\n\" + \"        <Annotations><Annotation name=\\\"a\\\">Level<\/Annotation><\/Annotations>\\n\" + \"      <\/Level>\\n\" + \"      <Level name=\\\"Store Region\\\" table=\\\"region\\\" column=\\\"sales_region\\\" />\\n\" + \"      <Level name=\\\"Store Name\\\" table=\\\"store\\\" column=\\\"store_name\\\" />\\n\" + \"    <\/Hierarchy>\\n\" + \"  <\/Dimension>\\n\" + \"  <DimensionUsage name=\\\"Time1\\\"\\n\" + \"    caption=\\\"Time usage caption\\\"\\n\" + \"    description=\\\"Time usage description\\\"\\n\" + \"    source=\\\"Time\\\" foreignKey=\\\"time_id\\\">\\n\" + \"    <Annotations><Annotation name=\\\"a\\\">Time usage<\/Annotation><\/Annotations>\\n\" + \"  <\/DimensionUsage>\\n\" + \"  <DimensionUsage name=\\\"Time2\\\"\\n\" + \"    source=\\\"Time\\\" foreignKey=\\\"time_id\\\"/>\\n\" + \"<Measure name=\\\"Unit Sales\\\" column=\\\"unit_sales\\\"\\n\" + \"    aggregator=\\\"sum\\\" formatString=\\\"Standard\\\"\\n\" + \"    caption=\\\"Measure caption\\\"\\n\" + \"    description=\\\"Measure description\\\">\\n\" + \"  <Annotations><Annotation name=\\\"a\\\">Measure<\/Annotation><\/Annotations>\\n\" + \"<\/Measure>\\n\" + \"<CalculatedMember name=\\\"Foo\\\" dimension=\\\"Measures\\\" \\n\" + \"    caption=\\\"Calc member caption\\\"\\n\" + \"    description=\\\"Calc member description\\\">\\n\" + \"    <Annotations><Annotation name=\\\"a\\\">Calc member<\/Annotation><\/Annotations>\\n\" + \"    <Formula>[Measures].[Unit Sales] + 1<\/Formula>\\n\" + \"    <CalculatedMemberProperty name=\\\"FORMAT_STRING\\\" value=\\\"$#,##0.00\\\"/>\\n\" + \"  <\/CalculatedMember>\\n\" + \"  <NamedSet name=\\\"Top Periods\\\"\\n\" + \"      caption=\\\"Named set caption\\\"\\n\" + \"      description=\\\"Named set description\\\">\\n\" + \"    <Annotations><Annotation name=\\\"a\\\">Named set<\/Annotation><\/Annotations>\\n\" + \"    <Formula>TopCount([Time1].MEMBERS, 5, [Measures].[Foo])<\/Formula>\\n\" + \"  <\/NamedSet>\\n\" + \"<\/Cube>\\n\" + \"<Cube name=\\\"\" + warehouseCubeName + \"\\\">\\n\" + \"  <Table name=\\\"inventory_fact_1997\\\"/>\\n\" + \"\\n\" + \"  <DimensionUsage name=\\\"Time\\\" source=\\\"Time\\\" foreignKey=\\\"time_id\\\"/>\\n\" + \"  <DimensionUsage name=\\\"Warehouse\\\" source=\\\"Warehouse\\\" foreignKey=\\\"warehouse_id\\\"/>\\n\" + \"\\n\" + \"  <Measure name=\\\"Units Shipped\\\" column=\\\"units_shipped\\\" aggregator=\\\"sum\\\" formatString=\\\"#.0\\\"/>\\n\" + \"<\/Cube>\\n\" + \"<VirtualCube name=\\\"\" + virtualCubeName + \"\\\"\\n\" + \"    caption=\\\"Virtual cube caption\\\"\\n\" + \"    description=\\\"Virtual cube description\\\">\\n\" + \"  <Annotations><Annotation name=\\\"a\\\">Virtual cube<\/Annotation><\/Annotations>\\n\" + \"  <VirtualCubeDimension name=\\\"Time\\\"/>\\n\" + \"  <VirtualCubeDimension cubeName=\\\"\" + warehouseCubeName + \"\\\" name=\\\"Warehouse\\\"/>\\n\" + \"  <VirtualCubeMeasure cubeName=\\\"\" + salesCubeName + \"\\\" name=\\\"[Measures].[Unit Sales]\\\">\\n\" + \"    <Annotations><Annotation name=\\\"a\\\">Virtual cube measure<\/Annotation><\/Annotations>\\n\" + \"  <\/VirtualCubeMeasure>\\n\" + \"  <VirtualCubeMeasure cubeName=\\\"\" + warehouseCubeName + \"\\\" name=\\\"[Measures].[Units Shipped]\\\"/>\\n\" + \"  <CalculatedMember name=\\\"Profit Per Unit Shipped\\\" dimension=\\\"Measures\\\">\\n\" + \"    <Formula>1 / [Measures].[Units Shipped]<\/Formula>\\n\" + \"  <\/CalculatedMember>\\n\" + \"<\/VirtualCube>\" + \"<\/Schema>\");\r\n    final Result result = testContext.executeQuery(\"select from [\" + salesCubeName + \"]\");\r\n    final Cube cube = result.getQuery().getCube();\r\n    assertEquals(\"Cube description\", cube.getDescription());\r\n    checkAnnotations(cube.getAnnotationMap(), \"a\", \"Cube\");\r\n    final Schema schema = cube.getSchema();\r\n    checkAnnotations(schema.getAnnotationMap(), \"a\", \"Schema\", \"b\", \"Xyz\");\r\n    final Dimension dimension = cube.getDimensions()[1];\r\n    assertEquals(\"Dimension description\", dimension.getDescription());\r\n    assertEquals(\"Dimension caption\", dimension.getCaption());\r\n    checkAnnotations(dimension.getAnnotationMap(), \"a\", \"Dimension\");\r\n    final Hierarchy hierarchy = dimension.getHierarchies()[0];\r\n    assertEquals(\"Hierarchy description\", hierarchy.getDescription());\r\n    assertEquals(\"Hierarchy caption\", hierarchy.getCaption());\r\n    checkAnnotations(hierarchy.getAnnotationMap(), \"a\", \"Hierarchy\");\r\n    final mondrian.olap.Level level = hierarchy.getLevels()[1];\r\n    assertEquals(\"Level description\", level.getDescription());\r\n    assertEquals(\"Level caption\", level.getCaption());\r\n    checkAnnotations(level.getAnnotationMap(), \"a\", \"Level\");\r\n    final List<Member> memberList = cube.getSchemaReader(null).withLocus().getLevelMembers(level, false);\r\n    final Member member = memberList.get(0);\r\n    assertEquals(\"Canada\", member.getName());\r\n    assertEquals(\"Canada\", member.getCaption());\r\n    assertNull(member.getDescription());\r\n    checkAnnotations(member.getAnnotationMap());\r\n    final Member allMember = member.getParentMember();\r\n    assertEquals(\"All Stores\", allMember.getName());\r\n    assertEquals(\"All Stores\", allMember.getCaption());\r\n    assertNull(allMember.getDescription());\r\n    final mondrian.olap.Level allLevel = hierarchy.getLevels()[0];\r\n    assertEquals(\"(All)\", allLevel.getName());\r\n    assertNull(allLevel.getDescription());\r\n    assertEquals(allLevel.getName(), allLevel.getCaption());\r\n    checkAnnotations(allLevel.getAnnotationMap());\r\n    final Dimension timeDimension = cube.getDimensions()[2];\r\n    assertEquals(\"Time1\", timeDimension.getName());\r\n    assertEquals(\"Time usage description\", timeDimension.getDescription());\r\n    assertEquals(\"Time usage caption\", timeDimension.getCaption());\r\n    checkAnnotations(timeDimension.getAnnotationMap(), \"a\", \"Time usage\");\r\n    final Hierarchy timeHierarchy = timeDimension.getHierarchies()[0];\r\n    final boolean ssasCompatibleNaming = MondrianProperties.instance().SsasCompatibleNaming.get();\r\n    if (ssasCompatibleNaming) {\r\n        assertEquals(\"Time\", timeHierarchy.getName());\r\n        assertEquals(\"Time1\", timeHierarchy.getDimension().getName());\r\n    } else {\r\n        assertEquals(\"Time1\", timeHierarchy.getName());\r\n    }\r\n    assertEquals(\"Time usage caption.Time shared hierarchy description\", timeHierarchy.getDescription());\r\n    assertEquals(\"Time usage caption.Time shared hierarchy caption\", timeHierarchy.getCaption());\r\n    checkAnnotations(timeHierarchy.getAnnotationMap());\r\n    final Dimension time2Dimension = cube.getDimensions()[3];\r\n    assertEquals(\"Time2\", time2Dimension.getName());\r\n    assertEquals(\"Time shared description\", time2Dimension.getDescription());\r\n    assertEquals(\"Time shared caption\", time2Dimension.getCaption());\r\n    checkAnnotations(time2Dimension.getAnnotationMap(), \"a\", \"Time shared\");\r\n    final Hierarchy time2Hierarchy = time2Dimension.getHierarchies()[0];\r\n    if (ssasCompatibleNaming) {\r\n        assertEquals(\"Time\", time2Hierarchy.getName());\r\n        assertEquals(\"Time2\", time2Hierarchy.getDimension().getName());\r\n    } else {\r\n        assertEquals(\"Time2\", time2Hierarchy.getName());\r\n    }\r\n    assertEquals(\"Time2.Time shared hierarchy description\", time2Hierarchy.getDescription());\r\n    assertEquals(\"Time2.Time shared hierarchy caption\", time2Hierarchy.getCaption());\r\n    checkAnnotations(time2Hierarchy.getAnnotationMap());\r\n    final Dimension measuresDimension = cube.getDimensions()[0];\r\n    final Hierarchy measuresHierarchy = measuresDimension.getHierarchies()[0];\r\n    final mondrian.olap.Level measuresLevel = measuresHierarchy.getLevels()[0];\r\n    final SchemaReader schemaReader = cube.getSchemaReader(null);\r\n    final List<Member> measures = schemaReader.getLevelMembers(measuresLevel, true);\r\n    final Member measure = measures.get(0);\r\n    assertEquals(\"Unit Sales\", measure.getName());\r\n    assertEquals(\"Measure caption\", measure.getCaption());\r\n    assertEquals(\"Measure description\", measure.getDescription());\r\n    assertEquals(measure.getDescription(), measure.getPropertyValue(Property.DESCRIPTION.name));\r\n    assertEquals(measure.getCaption(), measure.getPropertyValue(Property.CAPTION.name));\r\n    assertEquals(measure.getCaption(), measure.getPropertyValue(Property.MEMBER_CAPTION.name));\r\n    checkAnnotations(measure.getAnnotationMap(), \"a\", \"Measure\");\r\n    final Member factCountMeasure = measures.get(1);\r\n    assertEquals(\"Fact Count\", factCountMeasure.getName());\r\n    assertEquals(false, factCountMeasure.getPropertyValue(Property.VISIBLE.name));\r\n    checkAnnotations(factCountMeasure.getAnnotationMap(), \"Internal Use\", \"For internal use\");\r\n    final Member calcMeasure = measures.get(2);\r\n    assertEquals(\"Foo\", calcMeasure.getName());\r\n    assertEquals(\"Calc member caption\", calcMeasure.getCaption());\r\n    assertEquals(\"Calc member description\", calcMeasure.getDescription());\r\n    assertEquals(calcMeasure.getDescription(), calcMeasure.getPropertyValue(Property.DESCRIPTION.name));\r\n    assertEquals(calcMeasure.getCaption(), calcMeasure.getPropertyValue(Property.CAPTION.name));\r\n    assertEquals(calcMeasure.getCaption(), calcMeasure.getPropertyValue(Property.MEMBER_CAPTION.name));\r\n    checkAnnotations(calcMeasure.getAnnotationMap(), \"a\", \"Calc member\");\r\n    final NamedSet namedSet = cube.getNamedSets()[0];\r\n    assertEquals(\"Top Periods\", namedSet.getName());\r\n    assertEquals(\"Named set caption\", namedSet.getCaption());\r\n    assertEquals(\"Named set description\", namedSet.getDescription());\r\n    checkAnnotations(namedSet.getAnnotationMap(), \"a\", \"Named set\");\r\n    final Result result2 = testContext.executeQuery(\"select from [\" + virtualCubeName + \"]\");\r\n    final Cube cube2 = result2.getQuery().getCube();\r\n    assertEquals(\"Virtual cube description\", cube2.getDescription());\r\n    checkAnnotations(cube2.getAnnotationMap(), \"a\", \"Virtual cube\");\r\n    final SchemaReader schemaReader2 = cube2.getSchemaReader(null);\r\n    final Dimension measuresDimension2 = cube2.getDimensions()[0];\r\n    final Hierarchy measuresHierarchy2 = measuresDimension2.getHierarchies()[0];\r\n    final mondrian.olap.Level measuresLevel2 = measuresHierarchy2.getLevels()[0];\r\n    final List<Member> measures2 = schemaReader2.getLevelMembers(measuresLevel2, true);\r\n    final Member measure2 = measures2.get(0);\r\n    assertEquals(\"Unit Sales\", measure2.getName());\r\n    assertEquals(\"Measure caption\", measure2.getCaption());\r\n    assertEquals(\"Measure description\", measure2.getDescription());\r\n    assertEquals(measure2.getDescription(), measure2.getPropertyValue(Property.DESCRIPTION.name));\r\n    assertEquals(measure2.getCaption(), measure2.getPropertyValue(Property.CAPTION.name));\r\n    assertEquals(measure2.getCaption(), measure2.getPropertyValue(Property.MEMBER_CAPTION.name));\r\n    checkAnnotations(measure2.getAnnotationMap(), \"a\", \"Virtual cube measure\");\r\n}"
}, {
	"Path": "mondrian.spi.DialectManager.createDialect",
	"Comment": "creates a dialect from a jdbc connection, optionally specifyingthe name of the dialect class.if the dialect cannot handle this connection, throws. never returnsnull.",
	"Method": "Dialect createDialect(DataSource dataSource,Connection connection,Dialect createDialect,DataSource dataSource,Connection connection,String dialectClassName,Dialect createDialect,DataSource dataSource,Connection connection,String dialectClassName,Dialect createDialect,DataSource dataSource,Connection connection,Dialect createDialect,DataSource dataSource,Connection connection,Dialect createDialect,DataSource dataSource,Connection connection){\r\n    return IMPL.createDialect(dataSource, connection, dialectClassName);\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunDefBase.validateArg",
	"Comment": "validates an argument to a call to this function.the default implementation of this method adds an implicitconversion to the correct type. derived classes may override.",
	"Method": "Exp validateArg(Validator validator,Exp[] args,int i,int category){\r\n    return args[i];\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testExpandDifferentLevels",
	"Comment": "verify that native evaluation is not enabled if expanded member list willcontain members from different levels, even if expandnonnative is set.",
	"Method": "void testExpandDifferentLevels(){\r\n    propSaver.set(MondrianProperties.instance().ExpandNonNative, true);\r\n    checkNotNative(278, \"select NonEmptyCrossJoin(\" + \"    Descendants([Customers].[All Customers].[USA].[WA].[Yakima]), \" + \"    [Product].Children) on columns \" + \"from [Sales]\", null);\r\n}"
}, {
	"Path": "org.msgpack.core.MessageUnpacker.unexpected",
	"Comment": "create an exception for the case when an unexpected byte value is read",
	"Method": "MessagePackException unexpected(String expected,byte b){\r\n    MessageFormat format = MessageFormat.valueOf(b);\r\n    if (format == MessageFormat.NEVER_USED) {\r\n        return new MessageNeverUsedFormatException(String.format(\"Expected %s, but encountered 0xC1 \\\"NEVER_USED\\\" byte\", expected));\r\n    } else {\r\n        String name = format.getValueType().name();\r\n        String typeName = name.substring(0, 1) + name.substring(1).toLowerCase();\r\n        return new MessageTypeException(String.format(\"Expected %s, but got %s (x)\", expected, typeName, b));\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.Ssas2005CompatibilityTest.testRootMembers",
	"Comment": "ssas can resolve root members of a hierarchy even if not qualifiedby hierarchy, and even if the dimension has more than one hierarchy.",
	"Method": "void testRootMembers(){\r\n    final String timeByWeek = TestContext.hierarchyName(\"Time\", \"Time By Week\");\r\n    assertExprReturns(\"[Time].[1997].Level.UniqueName\", timeByWeek + \".[Year2]\");\r\n    if (!MondrianProperties.instance().SsasCompatibleNaming.get()) {\r\n        return;\r\n    }\r\n    assertQueryReturns(\"with member [Time].[Time2].[Foo] as\\n\" + \"[Time].[Time2].[1997] + [Time].[Time2].[1997].[Q3]\\n\" + \"select [Time].[Foo] on 0\\n\" + \"from [Warehouse and Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Time].[Time2].[Foo]}\\n\" + \"Row #0: 332,621\\n\");\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletResponse.getOutputStream",
	"Comment": "returns a servletoutputstream suitable for writing binary data in theresponse.",
	"Method": "ServletOutputStream getOutputStream(){\r\n    return outputStream;\r\n}"
}, {
	"Path": "com.meetup.memcached.MemcachedClient.flushAll",
	"Comment": "invalidates the entire cache.\twill return true only if succeeds in clearing all servers.\tif pass in null, then will try to flush all servers.",
	"Method": "boolean flushAll(boolean flushAll,String[] servers){\r\n    if (pool == null) {\r\n        log.error(\"++++ unable to get SockIOPool instance\");\r\n        return false;\r\n    }\r\n    servers = (servers == null) ? pool.getServers() : servers;\r\n    if (servers == null || servers.length <= 0) {\r\n        log.error(\"++++ no servers to flush\");\r\n        return false;\r\n    }\r\n    boolean success = true;\r\n    for (int i = 0; i < servers.length; i++) {\r\n        SockIOPool.SockIO sock = pool.getConnection(servers[i]);\r\n        if (sock == null) {\r\n            log.error(\"++++ unable to get connection to : \" + servers[i]);\r\n            success = false;\r\n            if (errorHandler != null)\r\n                errorHandler.handleErrorOnFlush(this, new IOException(\"no socket to server available\"));\r\n            continue;\r\n        }\r\n        String command = \"flush_all\\r\\n\";\r\n        try {\r\n            sock.write(command.getBytes());\r\n            sock.flush();\r\n            String line = sock.readLine();\r\n            success = (OK.equals(line)) ? success && true : false;\r\n        } catch (IOException e) {\r\n            if (errorHandler != null)\r\n                errorHandler.handleErrorOnFlush(this, e);\r\n            log.error(\"++++ exception thrown while writing bytes to server on flushAll\");\r\n            log.error(e.getMessage(), e);\r\n            try {\r\n                sock.trueClose();\r\n            } catch (IOException ioe) {\r\n                log.error(\"++++ failed to close socket : \" + sock.toString());\r\n            }\r\n            success = false;\r\n            sock = null;\r\n        }\r\n        if (sock != null) {\r\n            sock.close();\r\n            sock = null;\r\n        }\r\n    }\r\n    return success;\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.model.OSMTag.fromOSMTag",
	"Comment": "convenience method that constructs a new osmtag with a new id from another osmtag.",
	"Method": "OSMTag fromOSMTag(OSMTag otherTag,short newID){\r\n    return new OSMTag(newID, otherTag.getKey(), otherTag.getValue(), otherTag.getZoomAppear(), otherTag.isRenderable(), otherTag.isForcePolygonLine(), otherTag.isLabelPosition());\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteQueryBuilder.query",
	"Comment": "perform a query by combining all current settings and theinformation passed into this method.",
	"Method": "Cursor query(SQLiteDatabase db,String[] projectionIn,String selection,String[] selectionArgs,String groupBy,String having,String sortOrder,Cursor query,SQLiteDatabase db,String[] projectionIn,String selection,String[] selectionArgs,String groupBy,String having,String sortOrder,String limit,Cursor query,SQLiteDatabase db,String[] projectionIn,String selection,String[] selectionArgs,String groupBy,String having,String sortOrder,String limit,CancellationSignal cancellationSignal){\r\n    if (mTables == null) {\r\n        return null;\r\n    }\r\n    if (mStrict && selection != null && selection.length() > 0) {\r\n        String sqlForValidation = buildQuery(projectionIn, \"(\" + selection + \")\", groupBy, having, sortOrder, limit);\r\n        db.validateSql(sqlForValidation, cancellationSignal);\r\n    }\r\n    String sql = buildQuery(projectionIn, selection, groupBy, having, sortOrder, limit);\r\n    if (Log.isLoggable(TAG, Log.DEBUG)) {\r\n        Log.d(TAG, \"Performing query: \" + sql);\r\n    }\r\n    return // will throw if query is invalid\r\n    db.rawQueryWithFactory(// will throw if query is invalid\r\n    mFactory, // will throw if query is invalid\r\n    sql, // will throw if query is invalid\r\n    selectionArgs, SQLiteDatabase.findEditTable(mTables), cancellationSignal);\r\n}"
}, {
	"Path": "mondrian.spi.SegmentHeader.getDescription",
	"Comment": "returns a human readable description of thissegment header.",
	"Method": "String getDescription(){\r\n    if (this.description == null) {\r\n        StringBuilder descriptionSB = new StringBuilder();\r\n        descriptionSB.append(\"*Segment Header\\n\");\r\n        descriptionSB.append(\"Schema:[\");\r\n        descriptionSB.append(this.schemaName);\r\n        descriptionSB.append(\"]\\nChecksum:[\");\r\n        descriptionSB.append(this.schemaChecksum);\r\n        descriptionSB.append(\"]\\nCube:[\");\r\n        descriptionSB.append(this.cubeName);\r\n        descriptionSB.append(\"]\\nMeasure:[\");\r\n        descriptionSB.append(this.measureName);\r\n        descriptionSB.append(\"]\\n\");\r\n        descriptionSB.append(\"Axes:[\");\r\n        for (SegmentColumn c : getSortedColumns()) {\r\n            descriptionSB.append(\"\\n    {\");\r\n            descriptionSB.append(c.columnExpression);\r\n            descriptionSB.append(\"=(\");\r\n            if (c.values == null) {\r\n                descriptionSB.append(\"* \");\r\n            } else {\r\n                for (Object value : c.values) {\r\n                    descriptionSB.append(\"'\");\r\n                    descriptionSB.append(value);\r\n                    descriptionSB.append(\"',\");\r\n                }\r\n            }\r\n            descriptionSB.deleteCharAt(descriptionSB.length() - 1);\r\n            descriptionSB.append(\")}\");\r\n        }\r\n        descriptionSB.append(\"]\\n\");\r\n        descriptionSB.append(\"Excluded Regions:[\");\r\n        for (SegmentColumn c : getSortedRegions()) {\r\n            descriptionSB.append(\"\\n    {\");\r\n            descriptionSB.append(c.columnExpression);\r\n            descriptionSB.append(\"=(\");\r\n            if (c.values == null) {\r\n                descriptionSB.append(\"* \");\r\n            } else {\r\n                for (Object value : c.values) {\r\n                    descriptionSB.append(\"'\");\r\n                    descriptionSB.append(value);\r\n                    descriptionSB.append(\"',\");\r\n                }\r\n            }\r\n            descriptionSB.deleteCharAt(descriptionSB.length() - 1);\r\n            descriptionSB.append(\")}\");\r\n        }\r\n        descriptionSB.append(\"]\\n\");\r\n        descriptionSB.append(\"Compound Predicates:[\");\r\n        for (String c : compoundPredicates) {\r\n            descriptionSB.append(\"\\n\\t{\");\r\n            descriptionSB.append(c);\r\n        }\r\n        descriptionSB.append(\"]\\n\").append(\"ID:[\").append(getUniqueID()).append(\"]\\n\");\r\n        this.description = descriptionSB.toString();\r\n    }\r\n    return description;\r\n}"
}, {
	"Path": "org.sqlite.database.DatabaseUtils.stringForQuery",
	"Comment": "utility method to run the query on the db and return the value in thefirst column of the first row.",
	"Method": "String stringForQuery(SQLiteDatabase db,String query,String[] selectionArgs,String stringForQuery,SQLiteStatement prog,String[] selectionArgs){\r\n    prog.bindAllArgsAsStrings(selectionArgs);\r\n    return prog.simpleQueryForString();\r\n}"
}, {
	"Path": "mondrian.util.ConcatenableListTest.testBasicIteration",
	"Comment": "tests that basic iteration over multiple backing lists works properly,whether or not there are intervening empty lists.",
	"Method": "void testBasicIteration(){\r\n    List<String> testList = new ConcatenableList<String>();\r\n    testList.addAll(Arrays.asList(VALUE_1));\r\n    testList.addAll(new ArrayList<String>());\r\n    testList.addAll(new ArrayList<String>());\r\n    testList.addAll(Arrays.asList(VALUE_2, VALUE_3));\r\n    testList.addAll(Arrays.asList(VALUE_4));\r\n    testList.addAll(new ArrayList<String>());\r\n    testList.addAll(new ArrayList<String>());\r\n    testList.addAll(new ArrayList<String>());\r\n    testList.addAll(Arrays.asList(VALUE_5, VALUE_6));\r\n    Iterator<String> iterator = testList.iterator();\r\n    assertTrue(\"iterator.hasNext() should be true\", iterator.hasNext());\r\n    assertEquals(\"first value should be A\", VALUE_1, iterator.next());\r\n    assertTrue(\"iterator.hasNext() should be true\", iterator.hasNext());\r\n    assertEquals(\"first value should be B\", VALUE_2, iterator.next());\r\n    assertTrue(\"iterator.hasNext() should be true\", iterator.hasNext());\r\n    assertEquals(\"first value should be C\", VALUE_3, iterator.next());\r\n    assertTrue(\"iterator.hasNext() should be true\", iterator.hasNext());\r\n    assertEquals(\"first value should be D\", VALUE_4, iterator.next());\r\n    assertTrue(\"iterator.hasNext() should be true\", iterator.hasNext());\r\n    assertEquals(\"first value should be E\", VALUE_5, iterator.next());\r\n    assertTrue(\"iterator.hasNext() should be true\", iterator.hasNext());\r\n    assertEquals(\"first value should be F\", VALUE_6, iterator.next());\r\n    assertFalse(\"iterator.hasNext() should be false, since there are no more values\", iterator.hasNext());\r\n}"
}, {
	"Path": "mondrian.test.CacheHitTest.testBigSetRandom",
	"Comment": "runs a set of bigger mdx queries that requires more memoryand targets a bigger region of cache in random order.queries reference to sales cube as well aswarehouse and sales cube.",
	"Method": "void testBigSetRandom(){\r\n    TestSuite suite = new TestSuite();\r\n    suite.addTest(MemHungryTest.suite());\r\n    suite.addTest(PartialCacheTest.suite());\r\n    suite.addTest(MultiLevelTest.suite());\r\n    suite.addTest(MultiDimTest.suite());\r\n    suite.addTest(QueryAllTest.suite());\r\n    suite.addTest(PartialCacheVCTest.suite());\r\n    suite.addTest(MultiLevelVCTest.suite());\r\n    suite.addTest(MultiDimVCTest.suite());\r\n    suite.addTest(QueryAllVCTest.suite());\r\n    suite.addTest(CVBasicTest.suite());\r\n    suite.addTest(GrandTotalTest.suite());\r\n    suite.addTest(MetricFilterTest.suite());\r\n    suite.addTest(MiscTest.suite());\r\n    suite.addTest(PredicateFilterTest.suite());\r\n    suite.addTest(SubTotalTest.suite());\r\n    suite.addTest(SummaryMetricPercentTest.suite());\r\n    suite.addTest(SummaryTest.suite());\r\n    suite.addTest(TopBottomTest.suite());\r\n    System.out.println(\"== \" + this.getName() + \" ==\");\r\n    runRandomSuite(suite, 200);\r\n    clearCache(\"Sales\");\r\n    clearCache(\"Warehouse and Sales\");\r\n}"
}, {
	"Path": "mondrian.rolap.RolapStar.reOrderAggStarList",
	"Comment": "reorder the list of aggregate stars. this should be called if thealgorithm used to order the aggstars has been changed.",
	"Method": "void reOrderAggStarList(){\r\n    List<AggStar> oldList = new ArrayList<AggStar>(aggStars);\r\n    aggStars.clear();\r\n    for (AggStar aggStar : oldList) {\r\n        addAggStar(aggStar);\r\n    }\r\n}"
}, {
	"Path": "mondrian.olap.QueryAxis.getSet",
	"Comment": "returns the expression which is used to compute the value of this axis.",
	"Method": "Exp getSet(){\r\n    return exp;\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testExpandAllNonNativeInputs",
	"Comment": "verifies that crossjoins with two non native inputs can be nativelyevaluated.",
	"Method": "void testExpandAllNonNativeInputs(){\r\n    propSaver.set(MondrianProperties.instance().ExpandNonNative, true);\r\n    propSaver.set(MondrianProperties.instance().EnableNativeCrossJoin, true);\r\n    boolean requestFreshConnection = true;\r\n    checkNative(0, 2, \"select \" + \"NonEmptyCrossJoin([Gender].Children, [Store].Children) on columns \" + \"from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Gender].[F], [Store].[USA]}\\n\" + \"{[Gender].[M], [Store].[USA]}\\n\" + \"Row #0: 131,558\\n\" + \"Row #0: 135,215\\n\", requestFreshConnection);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Em.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Em appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "org.mapsforge.map.datastore.MapDataStore.readLabels",
	"Comment": "reads only labels for tile. labels are pois as well as ways that carry a name tag.it is permissible for the mapdatastore to return more data.this default implementation returns all map data, which is inefficient, but works.",
	"Method": "MapReadResult readLabels(Tile tile,MapReadResult readLabels,Tile upperLeft,Tile lowerRight){\r\n    if (upperLeft.tileX > lowerRight.tileX || upperLeft.tileY > lowerRight.tileY) {\r\n        new IllegalArgumentException(\"upperLeft tile must be above and left of lowerRight tile\");\r\n    }\r\n    MapReadResult result = new MapReadResult();\r\n    for (int x = upperLeft.tileX; x <= lowerRight.tileX; x++) {\r\n        for (int y = upperLeft.tileY; y <= lowerRight.tileY; y++) {\r\n            Tile current = new Tile(x, y, upperLeft.zoomLevel, upperLeft.tileSize);\r\n            result.add(readLabels(current), false);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "mondrian.olap.fun.AbstractAggregateFunDef.processUnrelatedDimensions",
	"Comment": "pushes unrelated dimensions to the top level member from the given listof tuples if the ignoreunrelateddimensions property is set on the basecube usage in the virtual cube.if ignoremeasurefornonjoiningdimension is set to true andignoreunrelateddimensions on cubeusage is set to false then if a nonjoining dimension exists in the aggregation list then return an emptylist else return the original list.",
	"Method": "TupleList processUnrelatedDimensions(TupleList tuplesForAggregation,Evaluator evaluator){\r\n    if (tuplesForAggregation.size() == 0) {\r\n        return tuplesForAggregation;\r\n    }\r\n    RolapMember measure = getRolapMeasureForUnrelatedDimCheck(evaluator, tuplesForAggregation);\r\n    if (measure.isCalculated()) {\r\n        return tuplesForAggregation;\r\n    }\r\n    RolapCube virtualCube = (RolapCube) evaluator.getCube();\r\n    if (virtualCube.isVirtual()) {\r\n        RolapCube baseCube = ((RolapStoredMeasure) measure).getCube();\r\n        if (baseCube == null) {\r\n            return tuplesForAggregation;\r\n        }\r\n        if (virtualCube.shouldIgnoreUnrelatedDimensions(baseCube.getName())) {\r\n            return ignoreUnrelatedDimensions(tuplesForAggregation, baseCube);\r\n        } else if (MondrianProperties.instance().IgnoreMeasureForNonJoiningDimension.get()) {\r\n            return ignoreMeasureForNonJoiningDimension(tuplesForAggregation, baseCube);\r\n        }\r\n    }\r\n    return tuplesForAggregation;\r\n}"
}, {
	"Path": "mondrian.test.BasicQueryTest.testLogicalAnd",
	"Comment": "a logical and, by contrast, can be supported by using two differenttechniques. if the members used to construct the logical and reside ondifferent dimensions, all that is required is a where clause that usesa tuple representing all involved members. the following mdx query uses awhere clause that effectively restricts the query to retrieve unitsales for drink products in the usa, shown by quarter and year for 1997.",
	"Method": "void testLogicalAnd(){\r\n    assertQueryReturns(\"SELECT {Measures.[Unit Sales]} ON COLUMNS,\\n\" + \"  DESCENDANTS([Time].[1997], [Quarter], SELF_AND_BEFORE) ON ROWS\\n\" + \"FROM Sales\\n\" + \"WHERE ([Product].[Drink], [Store].USA)\", \"Axis #0:\\n\" + \"{[Product].[Drink], [Store].[USA]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Time].[1997]}\\n\" + \"{[Time].[1997].[Q1]}\\n\" + \"{[Time].[1997].[Q2]}\\n\" + \"{[Time].[1997].[Q3]}\\n\" + \"{[Time].[1997].[Q4]}\\n\" + \"Row #0: 24,597\\n\" + \"Row #1: 5,976\\n\" + \"Row #2: 5,895\\n\" + \"Row #3: 6,065\\n\" + \"Row #4: 6,661\\n\");\r\n}"
}, {
	"Path": "org.mapsforge.map.android.view.MapView.destroyAll",
	"Comment": "clear all map view elements.i.e. layers, tile cache, label store, map view, resources, etc.",
	"Method": "void destroyAll(){\r\n    for (Layer layer : this.layerManager.getLayers()) {\r\n        this.layerManager.getLayers().remove(layer);\r\n        layer.onDestroy();\r\n        if (layer instanceof TileLayer) {\r\n            ((TileLayer<?>) layer).getTileCache().destroy();\r\n        }\r\n        if (layer instanceof TileRendererLayer) {\r\n            LabelStore labelStore = ((TileRendererLayer) layer).getLabelStore();\r\n            if (labelStore != null) {\r\n                labelStore.clear();\r\n            }\r\n        }\r\n    }\r\n    destroy();\r\n}"
}, {
	"Path": "mondrian.olap.Query.lookupMemberFromCache",
	"Comment": "looks up a member whose unique name is memberuniquenamefrom cache. if the member is not in cache, returns null.",
	"Method": "Member lookupMemberFromCache(String memberUniqueName){\r\n    for (Member member : getDefinedMembers()) {\r\n        if (Util.equalName(member.getUniqueName(), memberUniqueName) || Util.equalName(getUniqueNameWithoutAll(member), memberUniqueName)) {\r\n            return member;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.ExplicitRecognizer.makeMeasure",
	"Comment": "make a measure. this makes a measure usage using the aggregator found inthe rolapstar.measure associated with the explicitrules.tabledef.measure.",
	"Method": "void makeMeasure(ExplicitRules.TableDef.Measure measure,RolapAggregator factAgg,JdbcSchema.Table.Column aggColumn){\r\n    RolapStar.Measure rm = measure.getRolapStarMeasure();\r\n    JdbcSchema.Table.Column.Usage aggUsage = aggColumn.newUsage(JdbcSchema.UsageType.MEASURE);\r\n    aggUsage.setSymbolicName(measure.getSymbolicName());\r\n    ExplicitRules.TableDef.RollupType explicitRollupType = measure.getExplicitRollupType();\r\n    RolapAggregator ra = null;\r\n    if (explicitRollupType != null) {\r\n        String factCountExpr = getFactCountExpr(aggUsage);\r\n        ra = explicitRollupType.getAggregator(factCountExpr);\r\n    } else {\r\n        ra = (factAgg == null) ? convertAggregator(aggUsage, rm.getAggregator()) : convertAggregator(aggUsage, factAgg, rm.getAggregator());\r\n    }\r\n    aggUsage.setAggregator(ra);\r\n    aggUsage.rMeasure = rm;\r\n}"
}, {
	"Path": "mondrian.olap.Util.lookupProperty",
	"Comment": "finds a member property called propertyname at, or above,level.",
	"Method": "Property lookupProperty(Level level,String propertyName){\r\n    do {\r\n        Property[] properties = level.getProperties();\r\n        for (Property property : properties) {\r\n            if (property.getName().equals(propertyName)) {\r\n                return property;\r\n            }\r\n        }\r\n        level = level.getParentLevel();\r\n    } while (level != null);\r\n    boolean caseSensitive = MondrianProperties.instance().CaseSensitive.get();\r\n    final Property property = Property.lookup(propertyName, caseSensitive);\r\n    if (property != null && property.isMemberProperty() && property.isStandard()) {\r\n        return property;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteQueryBuilder.buildUnionQuery",
	"Comment": "given a set of subqueries, all of which are select statements,construct a query that returns the union of what thosesubqueries return.",
	"Method": "String buildUnionQuery(String[] subQueries,String sortOrder,String limit){\r\n    StringBuilder query = new StringBuilder(128);\r\n    int subQueryCount = subQueries.length;\r\n    String unionOperator = mDistinct ? \" UNION \" : \" UNION ALL \";\r\n    for (int i = 0; i < subQueryCount; i++) {\r\n        if (i > 0) {\r\n            query.append(unionOperator);\r\n        }\r\n        query.append(subQueries[i]);\r\n    }\r\n    appendClause(query, \" ORDER BY \", sortOrder);\r\n    appendClause(query, \" LIMIT \", limit);\r\n    return query.toString();\r\n}"
}, {
	"Path": "mondrian.rolap.ResultLoader.resetCurrMembers",
	"Comment": "sets the current member for those targets that retrieve their columnvalues from native sql.",
	"Method": "void resetCurrMembers(List<RolapMember> partialRow){\r\n    int nativeTarget = 0;\r\n    for (TargetBase target : targets) {\r\n        if (target.getSrcMembers() == null) {\r\n            if (partialRow != null) {\r\n                target.setCurrMember(partialRow.get(nativeTarget++));\r\n            } else {\r\n                target.removeCurrMember();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.olap4j.MondrianOlap4jDatabaseMetaData.wildcard",
	"Comment": "wraps a string in an object that indicates that it is to be treated asa wildcard pattern, not a literal match.",
	"Method": "XmlaUtil.Wildcard wildcard(String pattern){\r\n    return pattern == null ? null : new XmlaUtil.Wildcard(pattern);\r\n}"
}, {
	"Path": "mondrian.rolap.RolapAggregationManager.makeRequest",
	"Comment": "creates a request to evaluate the cell identified by the contextspecified in evaluator.if any of the members from the context is the null member, returnsnull, since there is no cell. if the measure is calculated, returnsnull.",
	"Method": "CellRequest makeRequest(Member[] members,CellRequest makeRequest,RolapEvaluator evaluator){\r\n    final CellRequest request = makeCellRequest(evaluator.getNonAllMembers(), false, false, null, evaluator, null, Collections.<OlapElement>emptyList());\r\n    if (request == null) {\r\n        return null;\r\n    }\r\n    if (CollectionUtils.isEmpty(evaluator.getAggregationLists())) {\r\n        return request;\r\n    }\r\n    if (!applyCompoundPredicates(evaluator, request)) {\r\n        return null;\r\n    }\r\n    return request;\r\n}"
}, {
	"Path": "org.mapsforge.core.util.MercatorProjection.tileXToLongitude",
	"Comment": "converts a tile x number at a certain zoom level to a longitude coordinate.",
	"Method": "double tileXToLongitude(long tileX,byte zoomLevel){\r\n    return pixelXToLongitude(tileX * DUMMY_TILE_SIZE, getMapSize(zoomLevel, DUMMY_TILE_SIZE));\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getHeaderNames",
	"Comment": "returns an enumeration of all the header names this request contains.",
	"Method": "Enumeration getHeaderNames(){\r\n    return Collections.enumeration(headers.keySet());\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentBuilder.toHeader",
	"Comment": "creates a segmentheader object describing the suppliedsegment object.",
	"Method": "SegmentHeader toHeader(Segment segment){\r\n    final List<SegmentColumn> cc = SegmentBuilder.toConstrainedColumns(segment.predicates);\r\n    final List<String> cp = new ArrayList<String>();\r\n    StringBuilder buf = new StringBuilder();\r\n    for (StarPredicate compoundPredicate : segment.compoundPredicateList) {\r\n        buf.setLength(0);\r\n        SqlQuery query = new SqlQuery(segment.star.getSqlQueryDialect());\r\n        compoundPredicate.toSql(query, buf);\r\n        cp.add(buf.toString());\r\n    }\r\n    final RolapSchema schema = segment.star.getSchema();\r\n    return new SegmentHeader(schema.getName(), schema.getChecksum(), segment.measure.getCubeName(), segment.measure.getName(), cc, cp, segment.star.getFactTable().getAlias(), segment.constrainedColumnsBitKey, Collections.<SegmentColumn>emptyList());\r\n}"
}, {
	"Path": "mondrian.test.FoodMartTestCase.assertQueryThrows",
	"Comment": "runs a query, and asserts that it throws an exception which containsthe given pattern.",
	"Method": "void assertQueryThrows(String queryString,String pattern){\r\n    getTestContext().assertQueryThrows(queryString, pattern);\r\n}"
}, {
	"Path": "com.mycollab.vaadin.ui.GenericBeanForm.setFormBuffered",
	"Comment": "disable form validation bean. this is used to switch views of forms and keep the previous values of beanwithout validation. you should be careful to use this method",
	"Method": "void setFormBuffered(boolean isBuffered){\r\n    if (fieldFactory != null) {\r\n        fieldFactory.setBuffered(isBuffered);\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.SqlTupleReader.addTargets",
	"Comment": "recursively forms the cross product of a row retrieved through sqlwith each of the targets that contains an enumerated set of members.",
	"Method": "void addTargets(int currEnumTargetIdx,int currTargetIdx,int nEnumTargets,int[] srcMemberIdxes,SqlStatement stmt,String message){\r\n    TargetBase currTarget = targets.get(currTargetIdx);\r\n    for (int i = 0; i < currTarget.srcMembers.size(); i++) {\r\n        srcMemberIdxes[currEnumTargetIdx] = i;\r\n        if (currEnumTargetIdx < nEnumTargets - 1) {\r\n            int nextTargetIdx = currTargetIdx + 1;\r\n            for (; nextTargetIdx < targets.size(); nextTargetIdx++) {\r\n                if (targets.get(nextTargetIdx).srcMembers != null) {\r\n                    break;\r\n                }\r\n            }\r\n            addTargets(currEnumTargetIdx + 1, nextTargetIdx, nEnumTargets, srcMemberIdxes, stmt, message);\r\n        } else {\r\n            int column = 0;\r\n            int enumTargetIdx = 0;\r\n            for (TargetBase target : targets) {\r\n                if (target.srcMembers == null) {\r\n                    try {\r\n                        column = target.addRow(stmt, column);\r\n                    } catch (Throwable e) {\r\n                        throw Util.newError(e, message);\r\n                    }\r\n                } else {\r\n                    RolapMember member = target.srcMembers.get(srcMemberIdxes[enumTargetIdx++]);\r\n                    target.getList().add(member);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.meetup.memcached.MemcachedClient.setCompressThreshold",
	"Comment": "sets the required length for data to be considered for compression.\tif the length of the data to be stored is not equal or larger than this value, it will\tnot be compressed.\tthis defaults to 15 kb.",
	"Method": "void setCompressThreshold(long compressThreshold){\r\n    this.compressThreshold = compressThreshold;\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlTest.testPartialFlush",
	"Comment": "creates a partial cell region, runs a query, then flushes the cache.",
	"Method": "void testPartialFlush(){\r\n    if (MondrianProperties.instance().DisableCaching.get()) {\r\n        return;\r\n    }\r\n    final TestContext testContext = getTestContext();\r\n    flushCache(testContext);\r\n    StringWriter sw = new StringWriter();\r\n    PrintWriter pw = new PrintWriter(sw);\r\n    final CacheControl cacheControl = testContext.getConnection().getCacheControl(pw);\r\n    final CacheControl.CellRegion region = createCellRegion1997_Q1_UnitSales(testContext, cacheControl);\r\n    standardQuery(testContext);\r\n    cacheControl.flush(region);\r\n    pw.flush();\r\n    assertCacheStateEquals(\"output\", \"${output}\", sw.toString());\r\n    sw.getBuffer().setLength(0);\r\n    cacheControl.flush(region);\r\n    pw.flush();\r\n    assertCacheStateEquals(\"output2\", \"${output2}\", sw.toString());\r\n    final CacheControl.CellRegion region2 = createCellRegion1997(testContext, cacheControl);\r\n    sw.getBuffer().setLength(0);\r\n    cacheControl.flush(region2);\r\n    pw.flush();\r\n    assertCacheStateEquals(\"output3\", \"${output3}\", sw.toString());\r\n    final CacheControl.CellRegion region3 = createCellRegionFemaleFoodDrink(testContext, cacheControl);\r\n    sw.getBuffer().setLength(0);\r\n    cacheControl.flush(region3);\r\n    pw.flush();\r\n    assertCacheStateEquals(\"output4\", \"${output4}\", sw.toString());\r\n    standardQuery(testContext);\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentCacheManager.loadFailed",
	"Comment": "informs cache manager that a segment load failed.called when a sql statement receives an error while loading asegment.",
	"Method": "void loadFailed(RolapStar star,SegmentHeader header,Throwable throwable){\r\n    final Locus locus = Locus.peek();\r\n    ACTOR.event(handler, new SegmentLoadFailedEvent(System.currentTimeMillis(), locus.getServer().getMonitor(), locus.getServer().getId(), locus.execution.getMondrianStatement().getMondrianConnection().getId(), locus.execution.getMondrianStatement().getId(), locus.execution.getId(), star, header, throwable));\r\n}"
}, {
	"Path": "mondrian.test.TestContext.withSchemaProcessor",
	"Comment": "returns a connection to the foodmart databasewith a dynamic schema processor and disables use of rolapschema pool.",
	"Method": "TestContext withSchemaProcessor(Class<? extends DynamicSchemaProcessor> dynProcClass){\r\n    final Util.PropertyList properties = getConnectionProperties().clone();\r\n    properties.put(RolapConnectionProperties.DynamicSchemaProcessor.name(), dynProcClass.getName());\r\n    properties.put(RolapConnectionProperties.UseSchemaPool.name(), \"false\");\r\n    return withProperties(properties);\r\n}"
}, {
	"Path": "mondrian.rolap.sql.SqlQuery.addSelect",
	"Comment": "adds an expression to the select clause, with a specified type andcolumn alias.",
	"Method": "String addSelect(String expression,SqlStatement.Type type,String addSelect,String expression,SqlStatement.Type type,String alias){\r\n    buf.setLength(0);\r\n    buf.append(expression);\r\n    if (alias != null) {\r\n        buf.append(\" as \");\r\n        dialect.quoteIdentifier(alias, buf);\r\n    }\r\n    select.add(buf.toString());\r\n    addType(type);\r\n    columnAliases.put(expression, alias);\r\n    return alias;\r\n}"
}, {
	"Path": "org.springframework.extensions.jcr.SessionFactoryUtils.doGetSession",
	"Comment": "get a jcr session for the given repository. is aware of and will return any existing correspondingsession bound to the current thread, for example when using jcrtransactionmanager. same asgetsession but throws the original repository.",
	"Method": "Session doGetSession(SessionFactory sessionFactory,boolean allowCreate){\r\n    Assert.notNull(sessionFactory, \"No sessionFactory specified\");\r\n    SessionHolder sessionHolder = (SessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);\r\n    if (sessionHolder != null && sessionHolder.getSession() != null)\r\n        return sessionHolder.getSession();\r\n    if (!allowCreate && !TransactionSynchronizationManager.isSynchronizationActive()) {\r\n        throw new IllegalStateException(\"No session bound to thread, \" + \"and configuration does not allow creation of non-transactional one here\");\r\n    }\r\n    LOG.debug(\"Opening JCR Session\");\r\n    Session session = sessionFactory.getSession();\r\n    if (TransactionSynchronizationManager.isSynchronizationActive()) {\r\n        LOG.debug(\"Registering transaction synchronization for JCR session\");\r\n        sessionHolder = sessionFactory.getSessionHolder(session);\r\n        sessionHolder.setSynchronizedWithTransaction(true);\r\n        TransactionSynchronizationManager.registerSynchronization(new JcrSessionSynchronization(sessionHolder, sessionFactory));\r\n        TransactionSynchronizationManager.bindResource(sessionFactory, sessionHolder);\r\n    }\r\n    return session;\r\n}"
}, {
	"Path": "com.haibao.store.myapplication.view.GoogleCircleProgressView.setColorSchemeColors",
	"Comment": "set the colors used in the progress animation. the firstcolor will also be the color of the bar that grows in response to a userswipe gesture.",
	"Method": "void setColorSchemeColors(int colors){\r\n    mColors = colors;\r\n    if (mProgressDrawable != null) {\r\n        mProgressDrawable.setColorSchemeColors(colors);\r\n    }\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.findPointFor",
	"Comment": "gets the first available key equal or above the given one, if none found,\treturns the first k in the bucket",
	"Method": "Long findPointFor(Long hv){\r\n    SortedMap<Long, String> tmap = this.consistentBuckets.tailMap(hv);\r\n    return (tmap.isEmpty()) ? this.consistentBuckets.firstKey() : tmap.firstKey();\r\n}"
}, {
	"Path": "mondrian.olap.Util.deprecated",
	"Comment": "insert a call to this method if you want to flag a piece ofundesirable code.",
	"Method": "T deprecated(T reason,T deprecated,T reason,boolean fail){\r\n    if (fail) {\r\n        throw new UnsupportedOperationException(reason.toString());\r\n    } else {\r\n        return reason;\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.map.model.DisplayModel.setDefaultUserScaleFactor",
	"Comment": "set the default scale factor for all newly created displaymodels, so can be used to apply user settings from adevice.",
	"Method": "void setDefaultUserScaleFactor(float scaleFactor){\r\n    defaultUserScaleFactor = scaleFactor;\r\n}"
}, {
	"Path": "mondrian.util.PropertyUtil.main",
	"Comment": "generates mondrianproperties.java from mondrianproperties.xml.",
	"Method": "void main(String[] args){\r\n    try {\r\n        new PropertyUtil().generate(args);\r\n    } catch (Throwable e) {\r\n        System.out.println(\"Error while generating properties files.\");\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.core.util.MercatorProjection.pixelXToLongitudeWithScaleFactor",
	"Comment": "converts a pixel x coordinate at a certain scale to a longitude coordinate.",
	"Method": "double pixelXToLongitudeWithScaleFactor(double pixelX,double scaleFactor,int tileSize){\r\n    long mapSize = getMapSizeWithScaleFactor(scaleFactor, tileSize);\r\n    if (pixelX < 0 || pixelX > mapSize) {\r\n        throw new IllegalArgumentException(\"invalid pixelX coordinate at scale \" + scaleFactor + \": \" + pixelX);\r\n    }\r\n    return 360 * ((pixelX / mapSize) - 0.5);\r\n}"
}, {
	"Path": "mondrian.server.MondrianServerImpl.registerMBean",
	"Comment": "registers the monitorimpl associated with this serveras an mbean accessible via jmx.",
	"Method": "void registerMBean(){\r\n    MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\r\n    try {\r\n        ObjectName mxbeanName = new ObjectName(\"mondrian.server:type=Server-\" + id);\r\n        mbs.registerMBean(getMonitor(), mxbeanName);\r\n    } catch (MalformedObjectNameException e) {\r\n        LOGGER.warn(\"Failed to register JMX MBean\", e);\r\n    } catch (NotCompliantMBeanException e) {\r\n        LOGGER.warn(\"Failed to register JMX MBean\", e);\r\n    } catch (InstanceAlreadyExistsException e) {\r\n        LOGGER.warn(\"Failed to register JMX MBean\", e);\r\n    } catch (MBeanRegistrationException e) {\r\n        LOGGER.warn(\"Failed to register JMX MBean\", e);\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.SqlConstraintUtils.addContextConstraint",
	"Comment": "for every restricting member in the current context, generatesa where condition and a join to the fact table.",
	"Method": "void addContextConstraint(SqlQuery sqlQuery,AggStar aggStar,Evaluator evaluator,RolapCube baseCube,boolean restrictMemberTypes){\r\n    if (baseCube == null && evaluator instanceof RolapEvaluator) {\r\n        baseCube = ((RolapEvaluator) evaluator).getCube();\r\n    }\r\n    RolapEvaluator rEvaluator = (RolapEvaluator) evaluator;\r\n    TupleList slicerTuples = rEvaluator.getOptimizedSlicerTuples(baseCube);\r\n    boolean disjointSlicerTuples = false;\r\n    if (slicerTuples != null && slicerTuples.size() > 0 && (SqlConstraintUtils.isDisjointTuple(slicerTuples) || rEvaluator.isMultiLevelSlicerTuple())) {\r\n        disjointSlicerTuples = true;\r\n    }\r\n    TupleConstraintStruct expandedSet = makeContextConstraintSet(rEvaluator, restrictMemberTypes, disjointSlicerTuples);\r\n    final CellRequest request = RolapAggregationManager.makeRequest(expandedSet.getMembersArray());\r\n    if (request == null) {\r\n        if (restrictMemberTypes) {\r\n            throw Util.newInternal(\"CellRequest is null - why?\");\r\n        }\r\n        return;\r\n    }\r\n    List<TupleList> slicerTupleList = expandedSet.getDisjoinedTupleLists();\r\n    if (disjointSlicerTuples) {\r\n        slicerTupleList.add(slicerTuples);\r\n    }\r\n    if (slicerTupleList.size() > 0) {\r\n        LOG.warn(\"Using tuple-based native slicer.\");\r\n        for (TupleList tuple : slicerTupleList) {\r\n            addContextConstraintTuples(sqlQuery, aggStar, rEvaluator, baseCube, restrictMemberTypes, request, tuple);\r\n        }\r\n        return;\r\n    }\r\n    RolapStar.Column[] columns = request.getConstrainedColumns();\r\n    Object[] values = request.getSingleValues();\r\n    Map<MondrianDef.Expression, Set<RolapMember>> mapOfSlicerMembers = null;\r\n    HashMap<MondrianDef.Expression, Boolean> done = new HashMap<MondrianDef.Expression, Boolean>();\r\n    for (int i = 0; i < columns.length; i++) {\r\n        final RolapStar.Column column = columns[i];\r\n        final String value = String.valueOf(values[i]);\r\n        String expr = getColumnExpr(sqlQuery, aggStar, column);\r\n        if ((RolapUtil.mdxNullLiteral().equalsIgnoreCase(value)) || (value.equalsIgnoreCase(RolapUtil.sqlNullValue.toString()))) {\r\n            sqlQuery.addWhere(expr, \" is \", RolapUtil.sqlNullLiteral);\r\n        } else {\r\n            if (column.getDatatype().isNumeric()) {\r\n                Double.valueOf(value);\r\n            }\r\n            if (mapOfSlicerMembers == null) {\r\n                mapOfSlicerMembers = getSlicerMemberMap(evaluator);\r\n            }\r\n            final MondrianDef.Expression keyForSlicerMap = column.getExpression();\r\n            if (mapOfSlicerMembers.containsKey(keyForSlicerMap)) {\r\n                if (!done.containsKey(keyForSlicerMap)) {\r\n                    Set<RolapMember> slicerMembersSet = mapOfSlicerMembers.get(keyForSlicerMap);\r\n                    List<RolapMember> slicerMembers = getNonAllMembers(slicerMembersSet);\r\n                    if (slicerMembers.size() > 0) {\r\n                        final int levelIndex = slicerMembers.get(0).getHierarchy().getLevels().length - 1;\r\n                        RolapLevel levelForWhere = (RolapLevel) slicerMembers.get(0).getHierarchy().getLevels()[levelIndex];\r\n                        final String where = generateSingleValueInExpr(sqlQuery, baseCube, aggStar, slicerMembers, levelForWhere, restrictMemberTypes, false, false);\r\n                        if (!where.equals(\"\")) {\r\n                            sqlQuery.addWhere(where);\r\n                        }\r\n                    } else {\r\n                        addSimpleColumnConstraint(sqlQuery, column, expr, value);\r\n                    }\r\n                    done.put(keyForSlicerMap, Boolean.TRUE);\r\n                }\r\n            } else {\r\n                addSimpleColumnConstraint(sqlQuery, column, expr, value);\r\n            }\r\n        }\r\n    }\r\n    addRoleAccessConstraints(sqlQuery, aggStar, restrictMemberTypes, baseCube, evaluator);\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getParameter",
	"Comment": "returns the value of a request parameter as a string, or null if theparameter does not exist.",
	"Method": "String getParameter(String name){\r\n    String[] values = getParameterValues(name);\r\n    return (null != values && 0 < values.length) ? values[0] : null;\r\n}"
}, {
	"Path": "mondrian.gui.JdbcMetaData.inJdbcSchemas",
	"Comment": "check to see if the schemaname is in the list of allowed jdbc schemas",
	"Method": "boolean inJdbcSchemas(String schemaName){\r\n    if (jdbcSchema == null || jdbcSchema.trim().length() == 0) {\r\n        return true;\r\n    }\r\n    String[] schemas = jdbcSchema.split(\"[,;]\");\r\n    for (String schema : schemas) {\r\n        if (schema.trim().equalsIgnoreCase(schemaName)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.haibao.store.myapplication.view.GoogleCircleProgressView.setColorSchemeResources",
	"Comment": "set the color resources used in the progress animation from color resources.the first color will also be the color of the bar that grows in responseto a user swipe gesture.",
	"Method": "void setColorSchemeResources(int colorResIds){\r\n    final Resources res = getResources();\r\n    int[] colorRes = new int[colorResIds.length];\r\n    for (int i = 0; i < colorResIds.length; i++) {\r\n        colorRes[i] = res.getColor(colorResIds[i]);\r\n    }\r\n    setColorSchemeColors(colorRes);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Table.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Table appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.FastBatchingCellReaderTest.testNonSuperSet",
	"Comment": "test that can batch for batch with non superset of constraintcolumn bit key and all values for additional condition.",
	"Method": "void testNonSuperSet(){\r\n    final BatchLoader fbcr = createFbcr(null, salesCube);\r\n    BatchLoader.Batch aggregationBatch = createBatch(fbcr, new String[] { tableTime, tableProductClass, tableProductClass }, new String[] { fieldYear, fieldProductFamily, fieldProductDepartment }, new String[][] { fieldValuesYear, fieldValuesProductFamily, fieldValueProductDepartment }, cubeNameSales, measureUnitSales);\r\n    BatchLoader.Batch detailedBatch = createBatch(fbcr, new String[] { tableProductClass, tableProductClass, tableCustomer }, new String[] { fieldProductFamily, fieldProductDepartment, fieldGender }, new String[][] { fieldValuesProductFamily, fieldValueProductDepartment, fieldValuesGender }, cubeNameSales, measureUnitSales);\r\n    assertFalse(detailedBatch.canBatch(aggregationBatch));\r\n    assertFalse(aggregationBatch.canBatch(detailedBatch));\r\n}"
}, {
	"Path": "org.mapsforge.map.android.util.MapViewerTemplate.createControls",
	"Comment": "hook to create controls, such as scale bars.you can add more controls.",
	"Method": "void createControls(){\r\n    initializePosition(mapView.getModel().mapViewPosition);\r\n}"
}, {
	"Path": "mondrian.rolap.BatchTestCase.assertNoQuerySql",
	"Comment": "checks that a given mdx query does not result in a particular sqlstatement being generated.",
	"Method": "void assertNoQuerySql(String mdxQuery,SqlPattern[] patterns){\r\n    assertQuerySqlOrNot(getTestContext(), mdxQuery, patterns, true, false, true);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Frameset.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Frameset appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentAxis.wouldContain",
	"Comment": "returns whether this axis contains a given key, or would contain itif it existed.for example, if this axis is unconstrained, then this methodreturns true for any value.",
	"Method": "boolean wouldContain(Object key){\r\n    return predicateAlwaysTrue || (predicateValues != null ? predicateValues.contains(key) : predicate.evaluate(key));\r\n}"
}, {
	"Path": "mondrian.test.ParameterTest.testAssignStringParameter",
	"Comment": "positive and negative tests assigning values to a parameter of typestring.",
	"Method": "void testAssignStringParameter(){\r\n    final String para = \"Parameter(\\\"x\\\", STRING, 'xxx')\";\r\n    assertAssignParameter(para, false, \"8\", null);\r\n    assertAssignParameter(para, false, \"8.24\", null);\r\n    assertAssignParameter(para, false, 8, null);\r\n    assertAssignParameter(para, false, -8.56, null);\r\n    assertAssignParameter(para, false, new BigDecimal(\"12.345\"), null);\r\n    assertAssignParameter(para, false, new BigInteger(\"12345\"), null);\r\n    assertAssignParameter(para, false, new Date(), null);\r\n    assertAssignParameter(para, false, new Timestamp(new Date().getTime()), null);\r\n    assertAssignParameter(para, false, new Time(new Date().getTime()), null);\r\n    assertAssignParameter(para, false, null, null);\r\n}"
}, {
	"Path": "com.haibao.store.myapplication.view.swipetoloadlayout.SwipeToLoadLayout.canChildScrollDown",
	"Comment": "whether it is possible for the child view of this layout toscroll down. override this if the child view is a custom view.",
	"Method": "boolean canChildScrollDown(){\r\n    if (android.os.Build.VERSION.SDK_INT < 14) {\r\n        if (mTargetView instanceof AbsListView) {\r\n            final AbsListView absListView = (AbsListView) mTargetView;\r\n            return absListView.getChildCount() > 0 && (absListView.getLastVisiblePosition() < absListView.getChildCount() - 1 || absListView.getChildAt(absListView.getChildCount() - 1).getBottom() > absListView.getPaddingBottom());\r\n        } else {\r\n            return ViewCompat.canScrollVertically(mTargetView, 1) || mTargetView.getScrollY() < 0;\r\n        }\r\n    } else {\r\n        return ViewCompat.canScrollVertically(mTargetView, 1);\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.TestContext.createSubstitutingCube",
	"Comment": "creates a testcontext, adding hierarchy and calculated member definitionsto a cube definition.",
	"Method": "TestContext createSubstitutingCube(String cubeName,String dimensionDefs,TestContext createSubstitutingCube,String cubeName,String dimensionDefs,String memberDefs,TestContext createSubstitutingCube,String cubeName,String dimensionDefs,String measureDefs,String memberDefs,String namedSetDefs,TestContext createSubstitutingCube,String cubeName,String dimensionDefs,String measureDefs,String memberDefs,String namedSetDefs,String defaultMeasure){\r\n    final String schema = substituteSchema(getRawFoodMartSchema(), cubeName, dimensionDefs, measureDefs, memberDefs, namedSetDefs, defaultMeasure);\r\n    return withSchema(schema);\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getReader",
	"Comment": "retrieves the body of the request as character data using abufferedreader.",
	"Method": "BufferedReader getReader(){\r\n    return (bodyContent == null) ? null : new BufferedReader(new StringReader(bodyContent));\r\n}"
}, {
	"Path": "mondrian.rolap.TestAggregationManager.testCountDistinctWithConstraintAggMiss",
	"Comment": "test that using compound member constrant disables using aggregatetable",
	"Method": "void testCountDistinctWithConstraintAggMiss(){\r\n    if (!(MondrianProperties.instance().UseAggregates.get() && MondrianProperties.instance().ReadAggregates.get())) {\r\n        return;\r\n    }\r\n    List<String[]> compoundMembers = new ArrayList<String[]>();\r\n    compoundMembers.add(new String[] { \"1997\", \"Q1\", \"1\" });\r\n    CellRequest request = createRequest(\"Sales\", \"[Measures].[Customer Count]\", new String[] { \"product_class\", \"product_class\", \"product_class\" }, new String[] { \"product_family\", \"product_department\", \"product_category\" }, new String[] { \"Food\", \"Deli\", \"Meat\" }, makeConstraintYearQuarterMonth(compoundMembers));\r\n    SqlPattern[] patterns = { new SqlPattern(ACCESS_MYSQL, \"select \" + \"`product_class`.`product_family` as `c0`, \" + \"`product_class`.`product_department` as `c1`, \" + \"`product_class`.`product_category` as `c2`, \" + \"count(distinct `sales_fact_1997`.`customer_id`) as `m0` \" + \"from \" + \"`product_class` as `product_class`, `product` as `product`, \" + \"`sales_fact_1997` as `sales_fact_1997`, `time_by_day` as `time_by_day` \" + \"where \" + \"`sales_fact_1997`.`product_id` = `product`.`product_id` and \" + \"`product`.`product_class_id` = `product_class`.`product_class_id` and \" + \"`product_class`.`product_family` = 'Food' and \" + \"`product_class`.`product_department` = 'Deli' and \" + \"`product_class`.`product_category` = 'Meat' and \" + \"`sales_fact_1997`.`time_id` = `time_by_day`.`time_id` and \" + \"(`time_by_day`.`the_year` = 1997 and `time_by_day`.`quarter` = 'Q1' and \" + \"`time_by_day`.`month_of_year` = 1) \" + \"group by \" + \"`product_class`.`product_family`, `product_class`.`product_department`, \" + \"`product_class`.`product_category`\", 58) };\r\n    assertRequestSql(new CellRequest[] { request }, patterns);\r\n}"
}, {
	"Path": "org.msgpack.core.MessagePacker.packDouble",
	"Comment": "writes a float value.this method writes a float value using float format family.",
	"Method": "MessagePacker packDouble(double v){\r\n    writeByteAndDouble(FLOAT64, v);\r\n    return this;\r\n}"
}, {
	"Path": "org.mapsforge.core.util.MercatorProjection.calculateGroundResolution",
	"Comment": "calculates the distance on the ground that is represented by a single pixel on the map.",
	"Method": "double calculateGroundResolution(double latitude,long mapSize){\r\n    return Math.cos(latitude * (Math.PI / 180)) * EARTH_CIRCUMFERENCE / mapSize;\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.isSecure",
	"Comment": "returns a boolean indicating whether this request was made using a secure channel, such as https.",
	"Method": "boolean isSecure(){\r\n    String scheme = getScheme();\r\n    return (scheme == null) ? false : scheme.equals(\"https\");\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Kbd.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Kbd appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.quickaction.QuickAction.setOnDismissListener",
	"Comment": "set listener for window dismissed. this listener will only be fired ifthe quicakction dialog is dismissed by clicking outside the dialog orclicking on sticky item.",
	"Method": "void setOnDismissListener(QuickAction.OnDismissListener listener){\r\n    setOnDismissListener(this);\r\n    mDismissListener = listener;\r\n}"
}, {
	"Path": "org.springframework.extensions.jcr.JcrAccessor.afterPropertiesSet",
	"Comment": "eagerly initialize the session holder provider, creating a default one if one is not set.",
	"Method": "void afterPropertiesSet(){\r\n    if (getSessionFactory() == null) {\r\n        throw new IllegalArgumentException(\"sessionFactory is required\");\r\n    }\r\n}"
}, {
	"Path": "mondrian.olap.Util.replace",
	"Comment": "replaces all occurrences of a string in a buffer with another.",
	"Method": "String replace(String s,String find,String replace,StringBuilder replace,StringBuilder buf,int start,String find,String replace){\r\n    int findLength = find.length();\r\n    if (findLength == 0) {\r\n        for (int j = buf.length(); j >= 0; --j) {\r\n            buf.insert(j, replace);\r\n        }\r\n        return buf;\r\n    }\r\n    int k = buf.length();\r\n    while (k > 0) {\r\n        int i = buf.lastIndexOf(find, k);\r\n        if (i < start) {\r\n            break;\r\n        }\r\n        buf.replace(i, i + find.length(), replace);\r\n        k = i - findLength;\r\n    }\r\n    return buf;\r\n}"
}, {
	"Path": "mondrian.spi.impl.NuoDbDialect.generateInline",
	"Comment": "in order to generate a sql statement to represent an inline datasetnuodb requires that you use from dual.",
	"Method": "String generateInline(List<String> columnNames,List<String> columnTypes,List<String[]> valueList){\r\n    return generateInlineGeneric(columnNames, columnTypes, valueList, \" FROM DUAL\", false);\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.startMaintThread",
	"Comment": "starts the maintenance thread.\tthis thread will manage the size of the active pool\tas well as move any closed, but not checked in sockets\tback to the available pool.",
	"Method": "void startMaintThread(){\r\n    if (maintThread != null) {\r\n        if (maintThread.isRunning()) {\r\n            log.error(\"main thread already running\");\r\n        } else {\r\n            maintThread.start();\r\n        }\r\n    } else {\r\n        maintThread = new MaintThread(this);\r\n        maintThread.setInterval(this.maintSleep);\r\n        maintThread.start();\r\n    }\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.hierarchizeMemberList",
	"Comment": "sorts a list of members into hierarchical order. the members must belongto the same dimension.",
	"Method": "void hierarchizeMemberList(List<Member> memberList,boolean post){\r\n    if (memberList.size() <= 1) {\r\n        return;\r\n    }\r\n    Dimension dimension = memberList.get(0).getDimension();\r\n    if (dimension.isHighCardinality()) {\r\n        LOGGER.warn(MondrianResource.instance().HighCardinalityInDimension.str(dimension.getUniqueName()));\r\n        return;\r\n    }\r\n    Comparator<Member> comparator = new HierarchizeComparator(post);\r\n    Collections.sort(memberList, comparator);\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.ExplicitRules.excludeTable",
	"Comment": "returns whether the given is tablename explicitly excluded fromconsideration as a candidate aggregate table.",
	"Method": "boolean excludeTable(String tableName,List<Group> aggGroups,boolean excludeTable,String tableName){\r\n    for (Group group : aggGroups) {\r\n        if (group.excludeTable(tableName)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.mapsforge.map.rendertheme.rule.RenderTheme.destroy",
	"Comment": "must be called when this rendertheme gets destroyed to clean up and free resources.",
	"Method": "void destroy(){\r\n    this.poiMatchingCache.clear();\r\n    this.wayMatchingCache.clear();\r\n    for (Rule r : this.rulesList) {\r\n        r.destroy();\r\n    }\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.I.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "I appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.spi.SegmentHeader.getConstrainedColumn",
	"Comment": "returns the constrained column object, if any, correspondingto a column name and a table name.",
	"Method": "SegmentColumn getConstrainedColumn(String columnExpression){\r\n    for (SegmentColumn c : constrainedColumns) {\r\n        if (c.columnExpression.equals(columnExpression)) {\r\n            return c;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.tui.XmlaSupport.validateNodes",
	"Comment": "validate nodes with throws an error if validation was attempted butfailed, returns true if validation was successful and false ifvalidation was not tried.",
	"Method": "boolean validateNodes(Node[] nodes){\r\n    if (!XmlUtil.supportsValidation()) {\r\n        return false;\r\n    }\r\n    if (nodes.length == 0) {\r\n        return false;\r\n    } else if (nodes.length == 1) {\r\n        return false;\r\n    } else if (nodes.length > 2) {\r\n        return false;\r\n    }\r\n    Node schemaNode = nodes[0];\r\n    Node rowNode = nodes[1];\r\n    Node rootNode = rowNode.getParentNode();\r\n    rootNode.removeChild(schemaNode);\r\n    Document schemaDoc = XmlUtil.newDocument(schemaNode, true);\r\n    Document dataDoc = XmlUtil.newDocument(rootNode, true);\r\n    String xmlns = XmlUtil.getNamespaceAttributeValue(dataDoc);\r\n    String schemaLocationPropertyValue = xmlns + ' ' + \"xmlschema\";\r\n    org.xml.sax.EntityResolver resolver = new XmlUtil.Resolver(schemaDoc);\r\n    XmlUtil.validate(dataDoc, schemaLocationPropertyValue, resolver);\r\n    return true;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.B.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "B appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.olap.fun.OpeningClosingPeriodFunDef.getDescendant",
	"Comment": "returns the first or last descendant of the member at the target level.this method is the implementation of both openingperiod andclosingperiod.",
	"Method": "Member getDescendant(SchemaReader schemaReader,Member member,Level targetLevel,boolean returnFirstDescendant){\r\n    List<Member> children;\r\n    final int targetLevelDepth = targetLevel.getDepth();\r\n    assertPrecondition(member.getLevel().getDepth() < targetLevelDepth, \"member.getLevel().getDepth() < targetLevel.getDepth()\");\r\n    for (; ; ) {\r\n        children = schemaReader.getMemberChildren(member);\r\n        if (children.size() == 0) {\r\n            return targetLevel.getHierarchy().getNullMember();\r\n        }\r\n        final int index = returnFirstDescendant ? 0 : (children.size() - 1);\r\n        member = children.get(index);\r\n        if (member.getLevel().getDepth() == targetLevelDepth) {\r\n            if (member.isHidden()) {\r\n                return member.getHierarchy().getNullMember();\r\n            } else {\r\n                return member;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.loader.MondrianFoodMartLoader.loadFromSqlInserts",
	"Comment": "after data has been loaded from a file or via jdbc, creates any deriveddata.",
	"Method": "void loadFromSqlInserts(){\r\n    InputStream is = getClass().getResourceAsStream(\"insert.sql\");\r\n    if (is == null) {\r\n        is = new FileInputStream(new File(\"src/test/resources/mondrian/test/loader/insert.sql\"));\r\n    }\r\n    if (is == null) {\r\n        throw new Exception(\"Cannot find insert.sql in class path\");\r\n    }\r\n    try {\r\n        final InputStreamReader reader = new InputStreamReader(is);\r\n        final BufferedReader bufferedReader = new BufferedReader(reader);\r\n        String line;\r\n        int lineNumber = 0;\r\n        Util.discard(lineNumber);\r\n        StringBuilder buf = new StringBuilder();\r\n        String fromQuoteChar = null;\r\n        String toQuoteChar = dialect.getQuoteIdentifierString();\r\n        while ((line = bufferedReader.readLine()) != null) {\r\n            ++lineNumber;\r\n            line = line.trim();\r\n            if (line.startsWith(\"#\") || line.length() == 0) {\r\n                continue;\r\n            }\r\n            if (fromQuoteChar == null) {\r\n                if (line.indexOf('`') >= 0) {\r\n                    fromQuoteChar = \"`\";\r\n                } else if (line.indexOf('\"') >= 0) {\r\n                    fromQuoteChar = \"\\\"\";\r\n                }\r\n            }\r\n            if (fromQuoteChar != null && !fromQuoteChar.equals(toQuoteChar)) {\r\n                line = line.replaceAll(fromQuoteChar, toQuoteChar);\r\n            }\r\n            if (line.charAt(line.length() - 1) == ';') {\r\n                buf.append(\" \").append(line.substring(0, line.length() - 1));\r\n                buf = updateSQLLineForSchema(buf);\r\n                executeDDL(buf.toString());\r\n                buf.setLength(0);\r\n            } else {\r\n                buf.append(\" \").append(line.substring(0, line.length()));\r\n            }\r\n        }\r\n        if (buf.length() > 0) {\r\n            executeDDL(buf.toString());\r\n        }\r\n    } finally {\r\n        if (is != null) {\r\n            is.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.olap.IdBatchResolver.batchResolveChildren",
	"Comment": "find the children of id parent in the identifiers set and resolvesall supported children together, adding them to the resolvedidentifiersmap.",
	"Method": "void batchResolveChildren(Id parent,Member parentMember,SortedSet<Id> identifiers,Map<QueryPart, QueryPart> resolvedIdentifiers){\r\n    final List<Id> children = findChildIds(parent, identifiers);\r\n    final List<Id.NameSegment> childNameSegments = collectChildrenNameSegments(parentMember, children);\r\n    if (childNameSegments.size() > 0) {\r\n        List<Member> childMembers = lookupChildrenByNames(parentMember, childNameSegments);\r\n        addChildrenToResolvedMap(resolvedIdentifiers, children, childMembers);\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.map.android.util.AndroidUtil.getMinimumCacheSize",
	"Comment": "compute the minimum cache size for a view, using the size of the map view.for the view size we use the frame buffer calculated dimension.",
	"Method": "int getMinimumCacheSize(Context c,int tileSize,double overdrawFactor,float screenRatio,int getMinimumCacheSize,int tileSize,double overdrawFactor,int width,int height){\r\n    Dimension dimension = FrameBufferController.calculateFrameBufferDimension(new Dimension(width, height), overdrawFactor);\r\n    return Math.max(4, (2 + (dimension.height / tileSize)) * (2 + (dimension.width / tileSize)));\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AbstractQuerySpec.isPartOfSelect",
	"Comment": "allows subclasses to specify if a given column mustbe returned as part of the result set, in the select clause.",
	"Method": "boolean isPartOfSelect(RolapStar.Column col,boolean isPartOfSelect,RolapStar.Measure measure){\r\n    return true;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteOpenHelper.getDatabaseName",
	"Comment": "return the name of the sqlite database being opened, as given tothe constructor.",
	"Method": "String getDatabaseName(){\r\n    return mName;\r\n}"
}, {
	"Path": "mondrian.rolap.VirtualCubeTest.testOrdinalColumn",
	"Comment": "test a virtual cube where one of the dimensions contains anordinalcolumn property",
	"Method": "void testOrdinalColumn(){\r\n    TestContext testContext = TestContext.instance().create(null, null, \"<VirtualCube name=\\\"Sales vs HR\\\">\\n\" + \"<VirtualCubeDimension name=\\\"Store\\\"/>\\n\" + \"<VirtualCubeDimension cubeName=\\\"HR\\\" name=\\\"Position\\\"/>\\n\" + \"<VirtualCubeMeasure cubeName=\\\"HR\\\" name=\\\"[Measures].[Org Salary]\\\"/>\\n\" + \"<\/VirtualCube>\", null, null, null);\r\n    testContext.assertQueryReturns(\"select {[Measures].[Org Salary]} on columns, \" + \"non empty \" + \"crossjoin([Store].[Store Country].members, [Position].[Store Management].children) \" + \"on rows from [Sales vs HR]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Org Salary]}\\n\" + \"Axis #2:\\n\" + \"{[Store].[Canada], [Position].[Store Management].[Store Manager]}\\n\" + \"{[Store].[Canada], [Position].[Store Management].[Store Assistant Manager]}\\n\" + \"{[Store].[Canada], [Position].[Store Management].[Store Shift Supervisor]}\\n\" + \"{[Store].[Mexico], [Position].[Store Management].[Store Manager]}\\n\" + \"{[Store].[Mexico], [Position].[Store Management].[Store Assistant Manager]}\\n\" + \"{[Store].[Mexico], [Position].[Store Management].[Store Shift Supervisor]}\\n\" + \"{[Store].[USA], [Position].[Store Management].[Store Manager]}\\n\" + \"{[Store].[USA], [Position].[Store Management].[Store Assistant Manager]}\\n\" + \"{[Store].[USA], [Position].[Store Management].[Store Shift Supervisor]}\\n\" + \"Row #0: $462.86\\n\" + \"Row #1: $394.29\\n\" + \"Row #2: $565.71\\n\" + \"Row #3: $13,254.55\\n\" + \"Row #4: $11,443.64\\n\" + \"Row #5: $17,705.46\\n\" + \"Row #6: $4,069.80\\n\" + \"Row #7: $3,417.72\\n\" + \"Row #8: $5,145.96\\n\");\r\n}"
}, {
	"Path": "mondrian.rolap.FilterTest.testNotInMultiLevelMemberConstraintMixedNullNonNullParent",
	"Comment": "test that null members are included when the filter explicitly excludescertain members that contain nulls.the members span multiple levels.",
	"Method": "void testNotInMultiLevelMemberConstraintMixedNullNonNullParent(){\r\n    if (!isDefaultNullMemberRepresentation()) {\r\n        return;\r\n    }\r\n    if (MondrianProperties.instance().FilterChildlessSnowflakeMembers.get()) {\r\n        return;\r\n    }\r\n    String dimension = \"<Dimension name=\\\"Warehouse2\\\">\\n\" + \"  <Hierarchy hasAll=\\\"true\\\" primaryKey=\\\"warehouse_id\\\">\\n\" + \"    <Table name=\\\"warehouse\\\"/>\\n\" + \"    <Level name=\\\"fax\\\" column=\\\"warehouse_fax\\\" uniqueMembers=\\\"true\\\"/>\\n\" + \"    <Level name=\\\"address1\\\" column=\\\"wa_address1\\\" uniqueMembers=\\\"false\\\"/>\\n\" + \"    <Level name=\\\"name\\\" column=\\\"warehouse_name\\\" uniqueMembers=\\\"false\\\"/>\\n\" + \"  <\/Hierarchy>\\n\" + \"<\/Dimension>\\n\";\r\n    String cube = \"<Cube name=\\\"Warehouse2\\\">\\n\" + \"  <Table name=\\\"inventory_fact_1997\\\"/>\\n\" + \"  <DimensionUsage name=\\\"Product\\\" source=\\\"Product\\\" foreignKey=\\\"product_id\\\"/>\\n\" + \"  <DimensionUsage name=\\\"Warehouse2\\\" source=\\\"Warehouse2\\\" foreignKey=\\\"warehouse_id\\\"/>\\n\" + \"  <Measure name=\\\"Warehouse Cost\\\" column=\\\"warehouse_cost\\\" aggregator=\\\"sum\\\"/>\\n\" + \"  <Measure name=\\\"Warehouse Sales\\\" column=\\\"warehouse_sales\\\" aggregator=\\\"sum\\\"/>\\n\" + \"<\/Cube>\";\r\n    String query = \"with\\n\" + \"set [Filtered Warehouse Set] as 'Filter([Warehouse2].[name].Members, [Warehouse2].CurrentMember Not In\" + \"{[Warehouse2].[#null].[234 West Covina Pkwy].[Freeman And Co],\" + \" [Warehouse2].[971-555-6213].[3377 Coachman Place].[Jones International]})' \" + \"set [NECJ] as NonEmptyCrossJoin([Filtered Warehouse Set], {[Product].[Product Family].Food}) \" + \"select [NECJ] on 0 from [Warehouse2]\";\r\n    String necjSqlDerby = \"select \\\"warehouse\\\".\\\"warehouse_fax\\\", \\\"warehouse\\\".\\\"wa_address1\\\", \" + \"\\\"warehouse\\\".\\\"warehouse_name\\\", \\\"product_class\\\".\\\"product_family\\\" \" + \"from \\\"warehouse\\\" as \\\"warehouse\\\", \\\"inventory_fact_1997\\\" as \" + \"\\\"inventory_fact_1997\\\", \\\"product\\\" as \\\"product\\\", \\\"product_class\\\" as \" + \"\\\"product_class\\\" where \\\"inventory_fact_1997\\\".\\\"warehouse_id\\\" = \" + \"\\\"warehouse\\\".\\\"warehouse_id\\\" and \\\"product\\\".\\\"product_class_id\\\" = \" + \"\\\"product_class\\\".\\\"product_class_id\\\" and \" + \"\\\"inventory_fact_1997\\\".\\\"product_id\\\" = \\\"product\\\".\\\"product_id\\\" and \" + \"(\\\"product_class\\\".\\\"product_family\\\" = 'Food') and \" + \"(not ((\\\"warehouse\\\".\\\"wa_address1\\\" = '234 West Covina Pkwy' and \" + \"\\\"warehouse\\\".\\\"warehouse_fax\\\" is null and \" + \"\\\"warehouse\\\".\\\"warehouse_name\\\" = 'Freeman And Co') or \" + \"(\\\"warehouse\\\".\\\"wa_address1\\\" = '3377 Coachman Place' and \" + \"\\\"warehouse\\\".\\\"warehouse_fax\\\" = '971-555-6213' and \" + \"\\\"warehouse\\\".\\\"warehouse_name\\\" = 'Jones International')) or \" + \"((\\\"warehouse\\\".\\\"warehouse_name\\\" is null or \" + \"\\\"warehouse\\\".\\\"wa_address1\\\" is null or \\\"warehouse\\\".\\\"warehouse_fax\\\" \" + \"is null) and not((\\\"warehouse\\\".\\\"wa_address1\\\" = \" + \"'234 West Covina Pkwy' and \\\"warehouse\\\".\\\"warehouse_fax\\\" is null \" + \"and \\\"warehouse\\\".\\\"warehouse_name\\\" = 'Freeman And Co') or \" + \"(\\\"warehouse\\\".\\\"wa_address1\\\" = '3377 Coachman Place' and \" + \"\\\"warehouse\\\".\\\"warehouse_fax\\\" = '971-555-6213' and \" + \"\\\"warehouse\\\".\\\"warehouse_name\\\" = 'Jones International')))) \" + \"group by \\\"warehouse\\\".\\\"warehouse_fax\\\", \\\"warehouse\\\".\\\"wa_address1\\\", \" + \"\\\"warehouse\\\".\\\"warehouse_name\\\", \\\"product_class\\\".\\\"product_family\\\" \" + \"order by \\\"warehouse\\\".\\\"warehouse_fax\\\" ASC, \" + \"\\\"warehouse\\\".\\\"wa_address1\\\" ASC, \\\"warehouse\\\".\\\"warehouse_name\\\" ASC, \" + \"\\\"product_class\\\".\\\"product_family\\\" ASC\";\r\n    String necjSqlMySql = \"select `warehouse`.`warehouse_fax` as `c0`, `warehouse`.`wa_address1` as `c1`, \" + \"`warehouse`.`warehouse_name` as `c2`, `product_class`.`product_family` as `c3` \" + \"from `warehouse` as `warehouse`, `inventory_fact_1997` as `inventory_fact_1997`, \" + \"`product` as `product`, `product_class` as `product_class` where \" + \"`inventory_fact_1997`.`warehouse_id` = `warehouse`.`warehouse_id` \" + \"and `product`.`product_class_id` = `product_class`.`product_class_id` \" + \"and `inventory_fact_1997`.`product_id` = `product`.`product_id` \" + \"and (`product_class`.`product_family` = 'Food') and \" + \"(not ((`warehouse`.`warehouse_name`, `warehouse`.`wa_address1`, `warehouse`.`warehouse_fax`) \" + \"in (('Jones International', '3377 Coachman Place', '971-555-6213')) \" + \"or (`warehouse`.`warehouse_fax` is null and (`warehouse`.`warehouse_name`, `warehouse`.`wa_address1`) \" + \"in (('Freeman And Co', '234 West Covina Pkwy')))) or \" + \"((`warehouse`.`warehouse_name` is null or `warehouse`.`wa_address1` is null \" + \"or `warehouse`.`warehouse_fax` is null) and not((`warehouse`.`warehouse_fax` is null \" + \"and (`warehouse`.`warehouse_name`, `warehouse`.`wa_address1`) in \" + \"(('Freeman And Co', '234 West Covina Pkwy')))))) \" + \"group by `warehouse`.`warehouse_fax`, `warehouse`.`wa_address1`, \" + \"`warehouse`.`warehouse_name`, `product_class`.`product_family` \" + \"order by ISNULL(`warehouse`.`warehouse_fax`), `warehouse`.`warehouse_fax` ASC, \" + \"ISNULL(`warehouse`.`wa_address1`), `warehouse`.`wa_address1` ASC, \" + \"ISNULL(`warehouse`.`warehouse_name`), `warehouse`.`warehouse_name` ASC, \" + \"ISNULL(`product_class`.`product_family`), `product_class`.`product_family` ASC\";\r\n    SqlPattern[] patterns = { new SqlPattern(Dialect.DatabaseProduct.DERBY, necjSqlDerby, necjSqlDerby), new SqlPattern(Dialect.DatabaseProduct.MYSQL, necjSqlMySql, necjSqlMySql) };\r\n    TestContext testContext = TestContext.instance().create(dimension, cube, null, null, null, null);\r\n    assertQuerySql(testContext, query, patterns);\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.DefaultRecognizer.getFactCountMatcher",
	"Comment": "get the matcher to be used to match the column which is the fact countcolumn.",
	"Method": "Recognizer.Matcher getFactCountMatcher(){\r\n    return getRules().getFactCountMatcher();\r\n}"
}, {
	"Path": "mondrian.rolap.RolapHierarchy.lookupRelationSubset",
	"Comment": "returns the smallest subset of relation which containsthe table targettable, or null if the targettable is notone of the joining table in relation.",
	"Method": "MondrianDef.RelationOrJoin lookupRelationSubset(MondrianDef.RelationOrJoin relation,RolapStar.Table targetTable){\r\n    if (relation instanceof MondrianDef.Table) {\r\n        MondrianDef.Table table = (MondrianDef.Table) relation;\r\n        if (table.name.equals(targetTable.getTableName())) {\r\n            return relation;\r\n        } else {\r\n            return null;\r\n        }\r\n    } else if (relation instanceof MondrianDef.Join) {\r\n        MondrianDef.Join join = (MondrianDef.Join) relation;\r\n        MondrianDef.RelationOrJoin rightRelation = lookupRelationSubset(join.right, targetTable);\r\n        if (rightRelation == null) {\r\n            return lookupRelationSubset(join.left, targetTable);\r\n        } else {\r\n            return join;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteProgram.clearBindings",
	"Comment": "clears all existing bindings. unset bindings are treated as null.",
	"Method": "void clearBindings(){\r\n    if (mBindArgs != null) {\r\n        Arrays.fill(mBindArgs, null);\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.MondrianTestRunner.getLoader",
	"Comment": "always use the standardtestsuiteloader. overridden frombasetestrunner.",
	"Method": "TestSuiteLoader getLoader(){\r\n    return new StandardTestSuiteLoader();\r\n}"
}, {
	"Path": "org.mapsforge.core.util.MercatorProjection.calculateGroundResolutionWithScaleFactor",
	"Comment": "calculates the distance on the ground that is represented by a single pixel on the map.",
	"Method": "double calculateGroundResolutionWithScaleFactor(double latitude,double scaleFactor,int tileSize){\r\n    long mapSize = getMapSizeWithScaleFactor(scaleFactor, tileSize);\r\n    return Math.cos(latitude * (Math.PI / 180)) * EARTH_CIRCUMFERENCE / mapSize;\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentCacheManager.shutdown",
	"Comment": "shuts down this cache manager and all active threads and indexes.",
	"Method": "void shutdown(){\r\n    execute(new ShutdownCommand());\r\n    cacheExecutor.shutdown();\r\n    sqlExecutor.shutdown();\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCube.getBaseCubes",
	"Comment": "returns the list of base cubes associated with this cubeif this one is a virtual cube,otherwise return just this cube",
	"Method": "List<RolapCube> getBaseCubes(){\r\n    if (baseCubes == null) {\r\n        baseCubes = findBaseCubes(this);\r\n    }\r\n    return baseCubes;\r\n}"
}, {
	"Path": "com.meetup.memcached.MemcachedClient.incr",
	"Comment": "increment the value at the specified key by the specified increment, and then return it.",
	"Method": "long incr(String key,long incr,String key,long inc,long incr,String key,long inc,Integer hashCode){\r\n    return incrdecr(\"incr\", key, inc, hashCode);\r\n}"
}, {
	"Path": "mondrian.util.MemoryMonitorTest.causeGC",
	"Comment": "get the difference between the maximum memory and the used memoryand divide that by 1000. this is the size of allocation chunks.keep allocating chunks until an outofmemoryerror iscreated.",
	"Method": "boolean causeGC(MemoryMonitor mm){\r\n    final int nosOfChunks = 1000;\r\n    long maxMemory = mm.getMaxMemory();\r\n    long usedMemory = mm.getUsedMemory();\r\n    long delta = (maxMemory - usedMemory) / nosOfChunks;\r\n    if (delta == 0) {\r\n        delta = 1024;\r\n    } else if (delta > Integer.MAX_VALUE) {\r\n        delta = Integer.MAX_VALUE;\r\n    }\r\n    final int size = 2 * nosOfChunks;\r\n    Object[] byteArrayHolder = new Object[size];\r\n    for (int i = 0; i < size; i++) {\r\n        try {\r\n            byteArrayHolder[i] = new java.lang.ref.SoftReference(new byte[(int) delta]);\r\n        } catch (java.lang.OutOfMemoryError ex) {\r\n            return true;\r\n        }\r\n    }\r\n    for (int i = 0; i < size; i++) {\r\n        java.lang.ref.SoftReference ref = (java.lang.ref.SoftReference) byteArrayHolder[i];\r\n        if (ref.get() == null) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "mondrian.gui.PropertyTableModel.getRowCount",
	"Comment": "returns the number of rows in the model. ajtable uses this method to determine how many rows itshould display.this method should be quick, as itis called frequently during rendering.",
	"Method": "int getRowCount(){\r\n    return propertyNames.length;\r\n}"
}, {
	"Path": "mondrian.test.CompoundSlicerTest.testTopCountWithAggregatedMemberEnumSet",
	"Comment": "test case for the support of native top count with aggregated measuresusing enumerated members.",
	"Method": "void testTopCountWithAggregatedMemberEnumSet(){\r\n    assertQueryReturns(\"with\\n\" + \"member Time.x as Aggregate({[Time].[1997].[Q1] , [Time].[1997].[Q2]}, [Measures].[Store Sales])\\n\" + \"member Measures.x1 as ([Time].[1997].[Q1], [Measures].[Store Sales])\\n\" + \"member Measures.x2 as ([Time].[1997].[Q2], [Measures].[Store Sales])\\n\" + \" set products as TopCount(Product.[Product Name].Members, 2, Measures.[Store Sales])\\n\" + \" SELECT NON EMPTY products ON 1,\\n\" + \"NON EMPTY {[Measures].[Store Sales], Measures.x1, Measures.x2} ON 0\\n\" + \"FROM [Sales] where Time.x\", \"Axis #0:\\n\" + \"{[Time].[x]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Store Sales]}\\n\" + \"{[Measures].[x1]}\\n\" + \"{[Measures].[x2]}\\n\" + \"Axis #2:\\n\" + \"{[Product].[Food].[Eggs].[Eggs].[Eggs].[Urban].[Urban Small Eggs]}\\n\" + \"{[Product].[Food].[Snack Foods].[Snack Foods].[Dried Fruit].[Fort West].[Fort West Raspberry Fruit Roll]}\\n\" + \"Row #0: 497.42\\n\" + \"Row #0: 235.62\\n\" + \"Row #0: 261.80\\n\" + \"Row #1: 462.84\\n\" + \"Row #1: 226.20\\n\" + \"Row #1: 236.64\\n\");\r\n}"
}, {
	"Path": "mondrian.rolap.SqlTupleReader.initializeIdentityMap",
	"Comment": "creates a map of the expressions from a rolaplevelto themselves.this is the starting assumption ofwhat the target expression is.",
	"Method": "Map<MondrianDef.Expression, MondrianDef.Expression> initializeIdentityMap(RolapLevel level){\r\n    Map<MondrianDef.Expression, MondrianDef.Expression> map = new HashMap<MondrianDef.Expression, MondrianDef.Expression>();\r\n    map.put(level.getKeyExp(), level.getKeyExp());\r\n    map.put(level.getOrdinalExp(), level.getOrdinalExp());\r\n    map.put(level.getCaptionExp(), level.getCaptionExp());\r\n    for (RolapProperty prop : level.getProperties()) {\r\n        if (!map.containsKey(prop.getExp())) {\r\n            map.put(prop.getExp(), prop.getExp());\r\n        }\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.MapFileWriter.writeFile",
	"Comment": "writes the map file according to the given configuration using the given data processor.",
	"Method": "void writeFile(MapWriterConfiguration configuration,TileBasedDataProcessor dataProcessor){\r\n    EXECUTOR_SERVICE = Executors.newFixedThreadPool(configuration.getThreads());\r\n    RandomAccessFile randomAccessFile = new RandomAccessFile(configuration.getOutputFile(), \"rw\");\r\n    int amountOfZoomIntervals = dataProcessor.getZoomIntervalConfiguration().getNumberOfZoomIntervals();\r\n    ByteBuffer containerHeaderBuffer = ByteBuffer.allocate(HEADER_BUFFER_SIZE);\r\n    int totalHeaderSize = writeHeaderBuffer(configuration, dataProcessor, containerHeaderBuffer);\r\n    containerHeaderBuffer.reset();\r\n    final LoadingCache<TDWay, Geometry> jtsGeometryCache = CacheBuilder.newBuilder().maximumSize(JTS_GEOMETRY_CACHE_SIZE).concurrencyLevel(Runtime.getRuntime().availableProcessors() * 2).build(new JTSGeometryCacheLoader(dataProcessor));\r\n    long currentFileSize = totalHeaderSize;\r\n    for (int i = 0; i < amountOfZoomIntervals; i++) {\r\n        long subfileSize = writeSubfile(currentFileSize, i, dataProcessor, jtsGeometryCache, randomAccessFile, configuration);\r\n        writeSubfileMetaDataToContainerHeader(dataProcessor.getZoomIntervalConfiguration(), i, currentFileSize, subfileSize, containerHeaderBuffer);\r\n        currentFileSize += subfileSize;\r\n    }\r\n    randomAccessFile.seek(0);\r\n    randomAccessFile.write(containerHeaderBuffer.array(), 0, totalHeaderSize);\r\n    long fileSize = randomAccessFile.length();\r\n    randomAccessFile.seek(OFFSET_FILE_SIZE);\r\n    randomAccessFile.writeLong(fileSize);\r\n    randomAccessFile.close();\r\n    CacheStats stats = jtsGeometryCache.stats();\r\n    LOGGER.fine(\"Tag values stats:\\n\" + OSMUtils.logValueTypeCount());\r\n    LOGGER.info(\"JTS Geometry cache hit rate: \" + stats.hitRate());\r\n    LOGGER.info(\"JTS Geometry total load time: \" + stats.totalLoadTime() / 1000);\r\n    LOGGER.info(\"Finished writing file.\");\r\n}"
}, {
	"Path": "mondrian.test.SteelWheelsTestCase.createContext",
	"Comment": "creates a testcontext which contains the given schema text.",
	"Method": "TestContext createContext(TestContext context,String schema){\r\n    final Util.PropertyList properties = context.getConnectionProperties().clone();\r\n    final String jdbc = properties.get(RolapConnectionProperties.Jdbc.name());\r\n    properties.put(RolapConnectionProperties.Jdbc.name(), Util.replace(jdbc, \"/foodmart\", \"/steelwheels\"));\r\n    if (schema != null) {\r\n        properties.put(RolapConnectionProperties.CatalogContent.name(), schema);\r\n        properties.remove(RolapConnectionProperties.Catalog.name());\r\n    } else {\r\n        final String catalog = properties.get(RolapConnectionProperties.Catalog.name());\r\n        properties.put(RolapConnectionProperties.Catalog.name(), Util.replace(catalog, \"FoodMart.xml\", \"SteelWheels.xml\"));\r\n    }\r\n    return context.withProperties(properties);\r\n}"
}, {
	"Path": "mondrian.test.FoodMartTestCase.verifySameNativeAndNot",
	"Comment": "checks whether query produces the same results with the native. propsenabled as it does with the props disabled",
	"Method": "void verifySameNativeAndNot(String query,String message,TestContext context){\r\n    propSaver.set(propSaver.properties.EnableNativeCrossJoin, true);\r\n    propSaver.set(propSaver.properties.EnableNativeFilter, true);\r\n    propSaver.set(propSaver.properties.EnableNativeNonEmpty, true);\r\n    propSaver.set(propSaver.properties.EnableNativeTopCount, true);\r\n    Result resultNative = context.executeQuery(query);\r\n    propSaver.set(propSaver.properties.EnableNativeCrossJoin, false);\r\n    propSaver.set(propSaver.properties.EnableNativeFilter, false);\r\n    propSaver.set(propSaver.properties.EnableNativeNonEmpty, false);\r\n    propSaver.set(propSaver.properties.EnableNativeTopCount, false);\r\n    Result resultNonNative = context.executeQuery(query);\r\n    assertEquals(message, TestContext.toString(resultNative), TestContext.toString(resultNonNative));\r\n    propSaver.reset();\r\n}"
}, {
	"Path": "mondrian.spi.impl.MySqlDialect.isInfobright",
	"Comment": "detects whether this database is infobright.infobright uses the mysql driver and appears to be a mysql instance.the only difference is the presence of the brighthouse engine.",
	"Method": "boolean isInfobright(DatabaseMetaData databaseMetaData){\r\n    Statement statement = null;\r\n    try {\r\n        String productVersion = databaseMetaData.getDatabaseProductVersion();\r\n        if (productVersion.compareTo(\"5.1\") >= 0) {\r\n            statement = databaseMetaData.getConnection().createStatement();\r\n            final ResultSet resultSet = statement.executeQuery(\"select * from INFORMATION_SCHEMA.engines \" + \"where ENGINE in ( 'BRIGHTHOUSE', 'INFOBRIGHT' )\");\r\n            if (resultSet.next()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    } catch (SQLException e) {\r\n        throw Util.newInternal(e, \"while running query to detect Brighthouse engine\");\r\n    } finally {\r\n        if (statement != null) {\r\n            try {\r\n                statement.close();\r\n            } catch (SQLException e) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.AggGen.createCollapsed",
	"Comment": "return a string containing the sql code to create a collapsed dimensiontable.",
	"Method": "String createCollapsed(){\r\n    StringWriter sw = new StringWriter(512);\r\n    PrintWriter pw = new PrintWriter(sw);\r\n    String prefix = \"    \";\r\n    pw.print(\"CREATE TABLE \");\r\n    pw.print(makeCollapsedAggregateTableName(getFactTableName()));\r\n    pw.println(\" (\");\r\n    for (List<JdbcSchema.Table.Column.Usage> list : collapsedColumnUsages.values()) {\r\n        for (JdbcSchema.Table.Column.Usage usage : list) {\r\n            addColumnCreate(pw, prefix, usage);\r\n        }\r\n    }\r\n    for (JdbcSchema.Table.Column.Usage usage : measures) {\r\n        addColumnCreate(pw, prefix, usage);\r\n    }\r\n    pw.print(prefix);\r\n    pw.print(getFactCount());\r\n    pw.println(\" INTEGER NOT NULL\");\r\n    pw.println(\");\");\r\n    return sw.toString();\r\n}"
}, {
	"Path": "mondrian.test.CompoundSlicerTest.testEmptySetSlicerViaExpressionReturnsNull",
	"Comment": "tests that if the slicer is calculated using an expression and containszero members, all cells are null.",
	"Method": "void testEmptySetSlicerViaExpressionReturnsNull(){\r\n    assertQueryReturns(\"select [Measures].[Unit Sales] on 0,\\n\" + \"[Product].Children on 1\\n\" + \"from [Sales]\\n\" + \"where filter([Gender].members * [Marital Status].members, 1 = 0)\", \"Axis #0:\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Product].[Drink]}\\n\" + \"{[Product].[Food]}\\n\" + \"{[Product].[Non-Consumable]}\\n\" + \"Row #0: \\n\" + \"Row #1: \\n\" + \"Row #2: \\n\");\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.rawQueryWithFactory",
	"Comment": "runs the provided sql and returns a cursor over the result set.",
	"Method": "Cursor rawQueryWithFactory(CursorFactory cursorFactory,String sql,String[] selectionArgs,String editTable,Cursor rawQueryWithFactory,CursorFactory cursorFactory,String sql,String[] selectionArgs,String editTable,CancellationSignal cancellationSignal){\r\n    acquireReference();\r\n    try {\r\n        SQLiteCursorDriver driver = new SQLiteDirectCursorDriver(this, sql, editTable, cancellationSignal);\r\n        return driver.query(cursorFactory != null ? cursorFactory : mCursorFactory, selectionArgs);\r\n    } finally {\r\n        releaseReference();\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.StringUtils.commaDelimitedListToSet",
	"Comment": "convenience method to convert a csv string list to a set. note that thiswill suppress duplicates.",
	"Method": "Set<String> commaDelimitedListToSet(String str){\r\n    Set<String> set = new TreeSet<String>();\r\n    String[] tokens = commaDelimitedListToStringArray(str);\r\n    for (String token : tokens) {\r\n        set.add(token);\r\n    }\r\n    return set;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.getLabel",
	"Comment": "gets a label to use when describing the database in log messages.",
	"Method": "String getLabel(){\r\n    synchronized (mLock) {\r\n        return mConfigurationLocked.label;\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AggregationManager.getCacheControl",
	"Comment": "returns an api with which to explicitly manage the contents of the cache.",
	"Method": "CacheControl getCacheControl(RolapConnection connection,PrintWriter pw){\r\n    return new CacheControlImpl(connection) {\r\n        protected void flushNonUnion(final CellRegion region) {\r\n            final SegmentCacheManager.FlushResult result = cacheMgr.execute(new SegmentCacheManager.FlushCommand(Locus.peek(), cacheMgr, region, this));\r\n            final List<Future<Boolean>> futures = new ArrayList<Future<Boolean>>();\r\n            for (Callable<Boolean> task : result.tasks) {\r\n                futures.add(cacheMgr.cacheExecutor.submit(task));\r\n            }\r\n            for (Future<Boolean> future : futures) {\r\n                Util.discard(Util.safeGet(future, \"Flush cache\"));\r\n            }\r\n        }\r\n        public void flush(final CellRegion region) {\r\n            if (pw != null) {\r\n                pw.println(\"Cache state before flush:\");\r\n                printCacheState(pw, region);\r\n                pw.println();\r\n            }\r\n            super.flush(region);\r\n            if (pw != null) {\r\n                pw.println(\"Cache state after flush:\");\r\n                printCacheState(pw, region);\r\n                pw.println();\r\n            }\r\n        }\r\n        public void trace(final String message) {\r\n            if (pw != null) {\r\n                pw.println(message);\r\n            }\r\n        }\r\n        public boolean isTraceEnabled() {\r\n            return pw != null;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AggregationManager.getCacheControl",
	"Comment": "returns an api with which to explicitly manage the contents of the cache.",
	"Method": "CacheControl getCacheControl(RolapConnection connection,PrintWriter pw){\r\n    final SegmentCacheManager.FlushResult result = cacheMgr.execute(new SegmentCacheManager.FlushCommand(Locus.peek(), cacheMgr, region, this));\r\n    final List<Future<Boolean>> futures = new ArrayList<Future<Boolean>>();\r\n    for (Callable<Boolean> task : result.tasks) {\r\n        futures.add(cacheMgr.cacheExecutor.submit(task));\r\n    }\r\n    for (Future<Boolean> future : futures) {\r\n        Util.discard(Util.safeGet(future, \"Flush cache\"));\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AggregationManager.getCacheControl",
	"Comment": "returns an api with which to explicitly manage the contents of the cache.",
	"Method": "CacheControl getCacheControl(RolapConnection connection,PrintWriter pw){\r\n    if (pw != null) {\r\n        pw.println(\"Cache state before flush:\");\r\n        printCacheState(pw, region);\r\n        pw.println();\r\n    }\r\n    super.flush(region);\r\n    if (pw != null) {\r\n        pw.println(\"Cache state after flush:\");\r\n        printCacheState(pw, region);\r\n        pw.println();\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AggregationManager.getCacheControl",
	"Comment": "returns an api with which to explicitly manage the contents of the cache.",
	"Method": "CacheControl getCacheControl(RolapConnection connection,PrintWriter pw){\r\n    if (pw != null) {\r\n        pw.println(message);\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AggregationManager.getCacheControl",
	"Comment": "returns an api with which to explicitly manage the contents of the cache.",
	"Method": "CacheControl getCacheControl(RolapConnection connection,PrintWriter pw){\r\n    return pw != null;\r\n}"
}, {
	"Path": "mondrian.test.BasicQueryTest._testTopmost",
	"Comment": "how do i get the topmost members of a level broken out by an ancestorlevel?this type of mdx query is common when only the facts for the lowestlevel of a dimension within a cube are needed, but information aboutother levels within the same dimension may also be required to satisfy aspecific business scenario.for example, a report that shows the unit sales for the store withthe highest unit sales from each country is needed for marketingpurposes. the following table provides an example of this report, runagainst the sales cube in the foodmart 2000 sample database.this looks simple enough, but the country name column providesunexpected difficulty. the values for the store country column are takenfrom the store country level of the store dimension, so the storecountry column is constructed as a calculated member as part of the mdxquery, using the mdx ancestor and name functions to return the countrynames for each store.a combination of the mdx generate, topcount, and descendantsfunctions are used to create a set containing the top stores in unitsales for each country.",
	"Method": "void _testTopmost(){\r\n    assertQueryReturns(\"WITH MEMBER Measures.[Country Name] AS \\n\" + \"  'Ancestor(Store.CurrentMember, [Store Country]).Name'\\n\" + \"SELECT {Measures.[Country Name], Measures.[Unit Sales]} ON COLUMNS,\\n\" + \"  GENERATE([Store Country].MEMBERS, \\n\" + \"    TOPCOUNT(DESCENDANTS([Store].CURRENTMEMBER, [Store].[Store Name]),\\n\" + \"      1, [Measures].[Unit Sales])) ON ROWS\\n\" + \"FROM Sales\", \"\");\r\n}"
}, {
	"Path": "mondrian.rolap.VirtualCubeTest.testCalculatedMeasureAcrossCubes",
	"Comment": "tests a calc measure which combines a measures from the sales cube with ameasures from the warehouse cube.",
	"Method": "void testCalculatedMeasureAcrossCubes(){\r\n    assertQueryReturns(\"with member [Measures].[Shipped per Ordered] as ' [Measures].[Units Shipped] / [Measures].[Unit Sales] ', format_string='#.00%'\\n\" + \" member [Measures].[Profit per Unit Shipped] as ' [Measures].[Profit] / [Measures].[Units Shipped] '\\n\" + \"select\\n\" + \" {[Measures].[Unit Sales], \\n\" + \"  [Measures].[Units Shipped],\\n\" + \"  [Measures].[Shipped per Ordered],\\n\" + \"  [Measures].[Profit per Unit Shipped]} on 0,\\n\" + \" NON EMPTY Crossjoin([Product].Children, [Time].[1997].Children) on 1\\n\" + \"from [Warehouse and Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"{[Measures].[Units Shipped]}\\n\" + \"{[Measures].[Shipped per Ordered]}\\n\" + \"{[Measures].[Profit per Unit Shipped]}\\n\" + \"Axis #2:\\n\" + \"{[Product].[Drink], [Time].[1997].[Q1]}\\n\" + \"{[Product].[Drink], [Time].[1997].[Q2]}\\n\" + \"{[Product].[Drink], [Time].[1997].[Q3]}\\n\" + \"{[Product].[Drink], [Time].[1997].[Q4]}\\n\" + \"{[Product].[Food], [Time].[1997].[Q1]}\\n\" + \"{[Product].[Food], [Time].[1997].[Q2]}\\n\" + \"{[Product].[Food], [Time].[1997].[Q3]}\\n\" + \"{[Product].[Food], [Time].[1997].[Q4]}\\n\" + \"{[Product].[Non-Consumable], [Time].[1997].[Q1]}\\n\" + \"{[Product].[Non-Consumable], [Time].[1997].[Q2]}\\n\" + \"{[Product].[Non-Consumable], [Time].[1997].[Q3]}\\n\" + \"{[Product].[Non-Consumable], [Time].[1997].[Q4]}\\n\" + \"Row #0: 5,976\\n\" + \"Row #0: 4637.0\\n\" + \"Row #0: 77.59%\\n\" + \"Row #0: $1.50\\n\" + \"Row #1: 5,895\\n\" + \"Row #1: 4501.0\\n\" + \"Row #1: 76.35%\\n\" + \"Row #1: $1.60\\n\" + \"Row #2: 6,065\\n\" + \"Row #2: 6258.0\\n\" + \"Row #2: 103.18%\\n\" + \"Row #2: $1.15\\n\" + \"Row #3: 6,661\\n\" + \"Row #3: 5802.0\\n\" + \"Row #3: 87.10%\\n\" + \"Row #3: $1.38\\n\" + \"Row #4: 47,809\\n\" + \"Row #4: 37153.0\\n\" + \"Row #4: 77.71%\\n\" + \"Row #4: $1.64\\n\" + \"Row #5: 44,825\\n\" + \"Row #5: 35459.0\\n\" + \"Row #5: 79.11%\\n\" + \"Row #5: $1.62\\n\" + \"Row #6: 47,440\\n\" + \"Row #6: 41545.0\\n\" + \"Row #6: 87.57%\\n\" + \"Row #6: $1.47\\n\" + \"Row #7: 51,866\\n\" + \"Row #7: 34706.0\\n\" + \"Row #7: 66.91%\\n\" + \"Row #7: $1.91\\n\" + \"Row #8: 12,506\\n\" + \"Row #8: 9161.0\\n\" + \"Row #8: 73.25%\\n\" + \"Row #8: $1.76\\n\" + \"Row #9: 11,890\\n\" + \"Row #9: 9227.0\\n\" + \"Row #9: 77.60%\\n\" + \"Row #9: $1.65\\n\" + \"Row #10: 12,343\\n\" + \"Row #10: 9986.0\\n\" + \"Row #10: 80.90%\\n\" + \"Row #10: $1.59\\n\" + \"Row #11: 13,497\\n\" + \"Row #11: 9291.0\\n\" + \"Row #11: 68.84%\\n\" + \"Row #11: $1.86\\n\");\r\n}"
}, {
	"Path": "mondrian.test.loader.DBLoader.decimalFormat",
	"Comment": "generate an appropriate number format string for doubles etcto be used to include a number in an sql insert statement.",
	"Method": "String decimalFormat(String lengthStr,String placesStr,String decimalFormat,int length,int places){\r\n    StringBuilder buf = new StringBuilder();\r\n    for (int i = 0; i < length; i++) {\r\n        if ((length - i) == places) {\r\n            buf.append('.');\r\n        }\r\n        if ((length - i) <= (places + 1)) {\r\n            buf.append(\"0\");\r\n        } else {\r\n            buf.append(\"#\");\r\n        }\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "mondrian.rolap.DataSourceChangeListenerTest.testDataSourceChangeListenerPlugin",
	"Comment": "tests whether the data source plugin is able to tell mondrianto read the hierarchy and aggregates again.",
	"Method": "void testDataSourceChangeListenerPlugin(){\r\n    final MondrianProperties properties = MondrianProperties.instance();\r\n    if (properties.TestExpDependencies.get() > 0) {\r\n        return;\r\n    }\r\n    final TestContext testContext = getTestContext();\r\n    final mondrian.olap.CacheControl cacheControl = testContext.getConnection().getCacheControl(null);\r\n    final Connection connection = testContext.getConnection();\r\n    final mondrian.olap.Cube salesCube = connection.getSchema().lookupCube(\"Sales\", true);\r\n    final mondrian.olap.CacheControl.CellRegion measuresRegion = cacheControl.createMeasuresRegion(salesCube);\r\n    cacheControl.flush(measuresRegion);\r\n    propSaver.set(properties.DisableCaching, false);\r\n    cacheControl.flushSchemaCache();\r\n    SmartMemberReader smr = getSmartMemberReader(\"Store\");\r\n    MemberCacheHelper smrch = (MemberCacheHelper) smr.getMemberCache();\r\n    MemberCacheHelper rcsmrch = ((RolapCubeHierarchy.RolapCubeHierarchyMemberReader) smr).getRolapCubeMemberCacheHelper();\r\n    SmartMemberReader ssmr = getSharedSmartMemberReader(\"Store\");\r\n    MemberCacheHelper ssmrch = (MemberCacheHelper) ssmr.getMemberCache();\r\n    clearAndHardenCache(ssmrch);\r\n    clearAndHardenCache(rcsmrch);\r\n    clearAndHardenCache(smrch);\r\n    SqlLogger sqlLogger = new SqlLogger();\r\n    RolapUtil.setHook(sqlLogger);\r\n    try {\r\n        String s1, s2, s3, s4, s5, s6;\r\n        Result r1 = executeQuery(\"select {[Store].[All Stores].[USA].[CA].[San Francisco]} on columns from [Sales]\");\r\n        Util.discard(r1);\r\n        s1 = sqlLogger.getSqlQueries().toString();\r\n        sqlLogger.clear();\r\n        assertFalse(\"[]\".equals(s1));\r\n        Result r2 = executeQuery(\"select {[Store].[All Stores].[USA].[CA].[San Francisco]} on columns from [Sales]\");\r\n        Util.discard(r2);\r\n        s2 = sqlLogger.getSqlQueries().toString();\r\n        sqlLogger.clear();\r\n        assertEquals(\"[]\", s2);\r\n        smrch.changeListener = new DataSourceChangeListenerImpl();\r\n        ssmrch.changeListener = new DataSourceChangeListenerImpl();\r\n        rcsmrch.changeListener = new DataSourceChangeListenerImpl();\r\n        Result r3 = executeQuery(\"select {[Store].[All Stores].[USA].[CA].[San Francisco]} on columns from [Sales]\");\r\n        Util.discard(r3);\r\n        s3 = sqlLogger.getSqlQueries().toString();\r\n        sqlLogger.clear();\r\n        assertEquals(\"[]\", s3);\r\n        clearAndHardenCache(smrch);\r\n        clearAndHardenCache(ssmrch);\r\n        clearAndHardenCache(rcsmrch);\r\n        Result r4 = executeQuery(\"select {[Store].[All Stores].[USA].[CA].[San Francisco]} \" + \"on columns from [Sales]\");\r\n        Util.discard(r4);\r\n        s4 = sqlLogger.getSqlQueries().toString();\r\n        sqlLogger.clear();\r\n        assertFalse(\"[]\".equals(s4));\r\n        smrch.changeListener = new DataSourceChangeListenerImpl2();\r\n        ssmrch.changeListener = new DataSourceChangeListenerImpl2();\r\n        rcsmrch.changeListener = new DataSourceChangeListenerImpl2();\r\n        Result r5 = executeQuery(\"select {[Store].[All Stores].[USA].[CA].[San Francisco]} \" + \"on columns from [Sales]\");\r\n        Util.discard(r5);\r\n        s5 = sqlLogger.getSqlQueries().toString();\r\n        sqlLogger.clear();\r\n        assertEquals(s4, s5);\r\n        smrch.changeListener = new DataSourceChangeListenerImpl3();\r\n        ssmrch.changeListener = new DataSourceChangeListenerImpl3();\r\n        rcsmrch.changeListener = new DataSourceChangeListenerImpl3();\r\n        RolapStar star = getStar(\"Sales\");\r\n        star.setChangeListener(smrch.changeListener);\r\n        Result r6 = executeQuery(\"select {[Store].[All Stores].[USA].[CA].[San Francisco]} \" + \"on columns from [Sales]\");\r\n        Util.discard(r6);\r\n        s6 = sqlLogger.getSqlQueries().toString();\r\n        sqlLogger.clear();\r\n        assertEquals(s1, s6);\r\n    } finally {\r\n        smrch.changeListener = null;\r\n        ssmrch.changeListener = null;\r\n        rcsmrch.changeListener = null;\r\n        RolapStar star = getStar(\"Sales\");\r\n        star.setChangeListener(null);\r\n        RolapUtil.setHook(null);\r\n    }\r\n}"
}, {
	"Path": "cc.mallet.util.search.SearchNode.getNextNodes",
	"Comment": "get an iterator over the new search nodes reachablefrom this node by state transitions.",
	"Method": "NextNodeIterator getNextNodes(){\r\n    return new NextNodeIterator();\r\n}"
}, {
	"Path": "com.meetup.memcached.MemcachedClient.setClassLoader",
	"Comment": "sets an optional classloader to be used for\tserialization.",
	"Method": "void setClassLoader(ClassLoader classLoader){\r\n    this.classLoader = classLoader;\r\n}"
}, {
	"Path": "mondrian.olap.Formula.getIntegerMemberProperty",
	"Comment": "returns the integer value of a given constant.if the property is not set, or itsvalue is not an integer, or its value is not a constant,returns null.",
	"Method": "Number getIntegerMemberProperty(String name){\r\n    Exp exp = getMemberProperty(name);\r\n    if (exp != null && exp.getType() instanceof NumericType) {\r\n        return quickEval(exp);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.util.JTSUtils.toJTSGeometry",
	"Comment": "internal conversion method to convert our internal data structure for ways to geometry objects in jts. it willcare about ways and polygons and will create the right jts objects.",
	"Method": "Geometry toJTSGeometry(TDWay way){\r\n    return toJtsGeometry(way, null);\r\n}"
}, {
	"Path": "mondrian.test.DialectTest.checkForceNullCollation",
	"Comment": "checks that the dialect can generate a valid query to sort in a givendirection, with null values appearing last.",
	"Method": "void checkForceNullCollation(boolean ascending,boolean nullsLast){\r\n    Dialect dialect = getDialect();\r\n    String query = \"select \" + dialect.quoteIdentifier(\"store_manager\") + \" from \" + dialectizeTableName(dialect.quoteIdentifier(\"store\")) + \" order by \" + dialect.generateOrderItem(dialect.quoteIdentifier(\"store_manager\"), true, ascending, nullsLast);\r\n    if (ascending) {\r\n        if (nullsLast) {\r\n            assertFirstLast(query, \"Brown\", null);\r\n        } else {\r\n            assertFirstLast(query, null, \"Williams\");\r\n        }\r\n    } else {\r\n        switch(dialect.getDatabaseProduct()) {\r\n            case GREENPLUM:\r\n                return;\r\n            case HIVE:\r\n                return;\r\n            case NEOVIEW:\r\n                return;\r\n        }\r\n        if (nullsLast) {\r\n            assertFirstLast(query, \"Williams\", null);\r\n        } else {\r\n            assertFirstLast(query, null, \"Brown\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentWithData.getCellCount",
	"Comment": "returns the number of cells in this segment, deducting cells inexcluded regions.this method may return a value which is slightly too low, oroccasionally even negative. this occurs when a segment has more than oneexcluded region, and those regions overlap. cells which are in bothregions will be counted twice.",
	"Method": "int getCellCount(){\r\n    int cellCount = 1;\r\n    for (SegmentAxis axis : axes) {\r\n        cellCount *= axis.getKeys().length;\r\n    }\r\n    for (ExcludedRegion excludedRegion : excludedRegions) {\r\n        cellCount -= excludedRegion.getCellCount();\r\n    }\r\n    return cellCount;\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlTest.testPartialFlushRange",
	"Comment": "creates a partial cell region over a range, runs a query, then flushesthe cache.",
	"Method": "void testPartialFlushRange(){\r\n    if (MondrianProperties.instance().DisableCaching.get()) {\r\n        return;\r\n    }\r\n    final TestContext testContext = getTestContext();\r\n    flushCache(testContext);\r\n    StringWriter sw = new StringWriter();\r\n    PrintWriter pw = new PrintWriter(sw);\r\n    final CacheControl cacheControl = testContext.getConnection().getCacheControl(pw);\r\n    final CacheControl.CellRegion region = createCellRegionAprilOnwards(testContext, cacheControl);\r\n    standardQuery(testContext);\r\n    cacheControl.flush(region);\r\n    pw.flush();\r\n    assertCacheStateEquals(\"output\", \"${output}\", sw.toString());\r\n    sw.getBuffer().setLength(0);\r\n    cacheControl.flush(region);\r\n    pw.flush();\r\n    assertCacheStateEquals(\"output2\", \"${output2}\", sw.toString());\r\n    standardQuery(testContext);\r\n    sw.getBuffer().setLength(0);\r\n    cacheControl.printCacheState(pw, region);\r\n    pw.flush();\r\n    assertCacheStateEquals(\"output3\", \"${output3}\", sw.toString());\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletResponse.setIntHeader",
	"Comment": "sets a response header with the given name and integer value.",
	"Method": "void setIntHeader(String name,int value){\r\n    String stringValue = Integer.toString(value);\r\n    addHeader(name, stringValue);\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.yieldIfContended",
	"Comment": "temporarily end the transaction to let other threads run. the transaction is assumed to besuccessful so far. do not call settransactionsuccessful before calling this. when thisreturns a new transaction will have been created but not marked as successful.",
	"Method": "boolean yieldIfContended(){\r\n    return yieldIfContendedHelper(false, -1);\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.StringUtils.trimTrailingCharacter",
	"Comment": "trim all occurences of the supplied trailing character from the givenstring.",
	"Method": "String trimTrailingCharacter(String str,char trailingCharacter){\r\n    if (!hasLength(str)) {\r\n        return str;\r\n    }\r\n    StringBuilder sb = new StringBuilder(str);\r\n    while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {\r\n        sb.deleteCharAt(sb.length() - 1);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "mondrian.rolap.RolapEvaluator.getFormatString",
	"Comment": "returns the format string for this cell. this is computed by evaluatingthe format expression in the current context, and therefore differentcells may have different format strings.",
	"Method": "String getFormatString(){\r\n    final Exp formatExp = (Exp) getProperty(Property.FORMAT_EXP_PARSED.name, null);\r\n    if (formatExp == null) {\r\n        return \"Standard\";\r\n    }\r\n    final Calc formatCalc = root.getCompiled(formatExp, true, null);\r\n    final Object o = formatCalc.evaluate(this);\r\n    if (o == null) {\r\n        return \"Standard\";\r\n    }\r\n    return o.toString();\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Small.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Small appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.CloseGuard.close",
	"Comment": "marks this closeguard instance as closed to avoid warnings onfinalization.",
	"Method": "void close(){\r\n    allocationSite = null;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteStatement.executeInsert",
	"Comment": "execute this sql statement and return the id of the row inserted due to this call.the sql statement should be an insert for this to be a useful call.",
	"Method": "long executeInsert(){\r\n    acquireReference();\r\n    try {\r\n        return getSession().executeForLastInsertedRowId(getSql(), getBindArgs(), getConnectionFlags(), null);\r\n    } catch (SQLiteDatabaseCorruptException ex) {\r\n        onCorruption();\r\n        throw ex;\r\n    } finally {\r\n        releaseReference();\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.sql.SqlQueryTest.makeTestSqlQuery",
	"Comment": "builds a sqlquery with flags set according to params.uses a mockito spy to construct a dialect which will give the desiredboolean value for reqorderbyalias.",
	"Method": "SqlQuery makeTestSqlQuery(String expr,String alias,boolean ascending,boolean nullable,boolean collateNullsLast,boolean reqOrderByAlias){\r\n    JdbcDialectImpl dialect = spy(new JdbcDialectImpl());\r\n    when(dialect.requiresOrderByAlias()).thenReturn(reqOrderByAlias);\r\n    SqlQuery query = new SqlQuery(dialect, true);\r\n    query.addOrderBy(expr, alias, ascending, true, nullable, collateNullsLast);\r\n    return query;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Div.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Div appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testExpandAllMembersInAllInputs",
	"Comment": "verify that the presence of all member in all the inputs disables nativeevaluation, even when expandnonnative is true.",
	"Method": "void testExpandAllMembersInAllInputs(){\r\n    propSaver.set(MondrianProperties.instance().ExpandNonNative, true);\r\n    propSaver.set(MondrianProperties.instance().EnableNativeCrossJoin, true);\r\n    checkNotNative(1, \"select NON EMPTY {[Time].[1997]} ON COLUMNS,\\n\" + \"       NON EMPTY Crossjoin(Hierarchize(Union({[Store].[All Stores]},\\n\" + \"           [Store].[USA].[CA].[San Francisco].[Store 14].Children)), {[Product].[All Products]}) \\n\" + \"           ON ROWS\\n\" + \"    from [Sales]\\n\" + \"    where [Measures].[Unit Sales]\", \"Axis #0:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #1:\\n\" + \"{[Time].[1997]}\\n\" + \"Axis #2:\\n\" + \"{[Store].[All Stores], [Product].[All Products]}\\n\" + \"Row #0: 266,773\\n\");\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Dt.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Dt appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.util.CombiningGenerator.of",
	"Comment": "creates a combininggenerator, inferring the type from the argument.",
	"Method": "CombiningGenerator<T> of(Collection<T> elements){\r\n    return new CombiningGenerator<T>(elements);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.H6.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "H6 appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.agg.Segment.print",
	"Comment": "prints the state of this segment, including constraintsand values. blocks the current thread until the segment is loaded.",
	"Method": "void print(PrintWriter pw){\r\n    final StringBuilder buf = new StringBuilder();\r\n    describe(buf, true);\r\n    pw.print(buf.toString());\r\n    pw.println();\r\n}"
}, {
	"Path": "mondrian.olap.Query.setBaseCubes",
	"Comment": "saves away the base cubes related to the virtual cubereferenced in this query",
	"Method": "void setBaseCubes(List<RolapCube> baseCubes){\r\n    this.baseCubes = baseCubes;\r\n}"
}, {
	"Path": "mondrian.test.AccessControlTest.testRollupBottomLevel",
	"Comment": "tests that members below bottom level are regarded as visible.",
	"Method": "void testRollupBottomLevel(){\r\n    rollupPolicyBottom(Role.RollupPolicy.FULL, \"74,748\", \"36,759\", \"266,773\");\r\n    rollupPolicyBottom(Role.RollupPolicy.PARTIAL, \"72,739\", \"35,775\", \"264,764\");\r\n    rollupPolicyBottom(Role.RollupPolicy.HIDDEN, \"\", \"\", \"\");\r\n}"
}, {
	"Path": "mondrian.web.taglib.ResultCache.setDirty",
	"Comment": "set to dirty after you have modified the query to force a recalcuation",
	"Method": "void setDirty(){\r\n    result = null;\r\n    document = null;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteClosable.releaseReferenceFromContainer",
	"Comment": "releases a reference to the object that was owned by the container of the object,closing the object if the last reference was released.",
	"Method": "void releaseReferenceFromContainer(){\r\n    boolean refCountIsZero = false;\r\n    synchronized (this) {\r\n        refCountIsZero = --mReferenceCount == 0;\r\n    }\r\n    if (refCountIsZero) {\r\n        onAllReferencesReleasedFromContainer();\r\n    }\r\n}"
}, {
	"Path": "mondrian.spi.SegmentColumn.merge",
	"Comment": "merges this column with anotherresulting in another whose values are super set of both.",
	"Method": "SegmentColumn merge(SegmentColumn col){\r\n    assert col != null;\r\n    assert col.columnExpression.equals(this.columnExpression);\r\n    if (this.values == null || col.values == null) {\r\n        return new SegmentColumn(columnExpression, valueCount, null);\r\n    }\r\n    return new SegmentColumn(columnExpression, valueCount, ((ArraySortedSet) this.values).merge((ArraySortedSet) col.values));\r\n}"
}, {
	"Path": "mondrian.util.ObjectPool.clear",
	"Comment": "removes all objects from the pool but keeps the current size ofthe internal storage.",
	"Method": "void clear(){\r\n    values = (T[]) new Object[values.length];\r\n    this.distinct = 0;\r\n    this.freeEntries = values.length;\r\n    trimToSize();\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.WayPolygonizer.mergePolygons",
	"Comment": "tries to merge ways to closed polygons. the ordering of waynodes is preserved during the merge process.",
	"Method": "void mergePolygons(TDWay[] ways){\r\n    this.polygons = new ArrayList();\r\n    this.dangling = new ArrayList();\r\n    this.illegal = new ArrayList();\r\n    Deque<TDWay> ungroupedWays = new ArrayDeque();\r\n    for (TDWay tdWay : ways) {\r\n        tdWay.setReversedInRelation(false);\r\n        if (isClosedPolygon(tdWay)) {\r\n            if (tdWay.getWayNodes().length < MIN_NODES_POLYGON) {\r\n                this.illegal.add(tdWay);\r\n            } else {\r\n                Deque<TDWay> cluster = new ArrayDeque();\r\n                cluster.add(tdWay);\r\n                this.polygons.add(cluster);\r\n            }\r\n        } else {\r\n            ungroupedWays.add(tdWay);\r\n        }\r\n    }\r\n    if (ungroupedWays.isEmpty()) {\r\n        return;\r\n    }\r\n    if (ungroupedWays.size() == 1) {\r\n        this.dangling.add(ungroupedWays.getFirst());\r\n        return;\r\n    }\r\n    boolean startNewPolygon = true;\r\n    while (true) {\r\n        boolean merge = false;\r\n        if (startNewPolygon) {\r\n            Deque<TDWay> cluster = new ArrayDeque();\r\n            cluster.add(ungroupedWays.removeFirst());\r\n            this.polygons.add(cluster);\r\n            startNewPolygon = false;\r\n        }\r\n        Iterator<TDWay> it = ungroupedWays.iterator();\r\n        while (it.hasNext()) {\r\n            TDWay current = it.next();\r\n            Deque<TDWay> currentPolygonSegments = this.polygons.get(this.polygons.size() - 1);\r\n            TDWay c1Start = currentPolygonSegments.getFirst();\r\n            TDWay c1End = currentPolygonSegments.getLast();\r\n            long startFirst = c1Start.isReversedInRelation() ? c1Start.getWayNodes()[c1Start.getWayNodes().length - 1].getId() : c1Start.getWayNodes()[0].getId();\r\n            long endLast = c1End.isReversedInRelation() ? c1End.getWayNodes()[0].getId() : c1End.getWayNodes()[c1End.getWayNodes().length - 1].getId();\r\n            long currentFirst = current.getWayNodes()[0].getId();\r\n            long currentLast = current.getWayNodes()[current.getWayNodes().length - 1].getId();\r\n            if (startFirst == currentLast) {\r\n                merge = true;\r\n                it.remove();\r\n                currentPolygonSegments.offerFirst(current);\r\n            } else if (startFirst == currentFirst) {\r\n                current.setReversedInRelation(true);\r\n                merge = true;\r\n                it.remove();\r\n                currentPolygonSegments.offerFirst(current);\r\n            } else if (endLast == currentFirst) {\r\n                merge = true;\r\n                it.remove();\r\n                currentPolygonSegments.offerLast(current);\r\n            } else if (endLast == currentLast) {\r\n                current.setReversedInRelation(true);\r\n                merge = true;\r\n                it.remove();\r\n                currentPolygonSegments.offerLast(current);\r\n            }\r\n        }\r\n        Deque<TDWay> currentCluster = this.polygons.get(this.polygons.size() - 1);\r\n        boolean closed = isClosedPolygon(currentCluster);\r\n        if (!closed) {\r\n            if (ungroupedWays.isEmpty() || !merge) {\r\n                this.dangling.addAll(this.polygons.get(this.polygons.size() - 1));\r\n                this.dangling.addAll(ungroupedWays);\r\n                this.polygons.remove(this.polygons.size() - 1);\r\n                return;\r\n            }\r\n        } else {\r\n            if (ungroupedWays.isEmpty()) {\r\n                return;\r\n            }\r\n            startNewPolygon = true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.AggGen.insertIntoCollapsed",
	"Comment": "return the sql code to populate a collapsed dimension table fromthe fact table.",
	"Method": "String insertIntoCollapsed(){\r\n    StringWriter sw = new StringWriter(512);\r\n    PrintWriter pw = new PrintWriter(sw);\r\n    String prefix = \"    \";\r\n    String factTableName = getFactTableName();\r\n    SqlQuery sqlQuery = getSqlQuery();\r\n    pw.print(\"INSERT INTO \");\r\n    pw.print(makeCollapsedAggregateTableName(getFactTableName()));\r\n    pw.println(\" (\");\r\n    for (List<JdbcSchema.Table.Column.Usage> list : collapsedColumnUsages.values()) {\r\n        for (JdbcSchema.Table.Column.Usage usage : list) {\r\n            JdbcSchema.Table.Column c = usage.getColumn();\r\n            pw.print(prefix);\r\n            if (usage.usagePrefix != null) {\r\n                pw.print(usage.usagePrefix);\r\n            }\r\n            pw.print(c.getName());\r\n            pw.println(',');\r\n        }\r\n    }\r\n    for (JdbcSchema.Table.Column.Usage usage : measures) {\r\n        JdbcSchema.Table.Column c = usage.getColumn();\r\n        pw.print(prefix);\r\n        String name = getUsageName(usage);\r\n        pw.print(name);\r\n        pw.println(',');\r\n    }\r\n    pw.print(prefix);\r\n    pw.print(getFactCount());\r\n    pw.println(\")\");\r\n    pw.println(\"SELECT\");\r\n    for (List<JdbcSchema.Table.Column.Usage> list : collapsedColumnUsages.values()) {\r\n        for (JdbcSchema.Table.Column.Usage usage : list) {\r\n            JdbcSchema.Table.Column c = usage.getColumn();\r\n            JdbcSchema.Table t = c.getTable();\r\n            pw.print(prefix);\r\n            pw.print(sqlQuery.getDialect().quoteIdentifier(t.getName(), c.getName()));\r\n            pw.print(\" AS \");\r\n            String n = (usage.usagePrefix == null) ? c.getName() : usage.usagePrefix + c.getName();\r\n            pw.print(sqlQuery.getDialect().quoteIdentifier(n));\r\n            pw.println(',');\r\n        }\r\n    }\r\n    for (JdbcSchema.Table.Column.Usage usage : measures) {\r\n        JdbcSchema.Table.Column c = usage.getColumn();\r\n        JdbcSchema.Table t = c.getTable();\r\n        RolapAggregator agg = usage.getAggregator();\r\n        pw.print(prefix);\r\n        pw.print(agg.getExpression(sqlQuery.getDialect().quoteIdentifier(t.getName(), c.getName())));\r\n        pw.print(\" AS \");\r\n        pw.print(sqlQuery.getDialect().quoteIdentifier(c.getName()));\r\n        pw.println(',');\r\n    }\r\n    pw.print(prefix);\r\n    pw.print(\"COUNT(*) AS \");\r\n    pw.println(sqlQuery.getDialect().quoteIdentifier(getFactCount()));\r\n    pw.println(\"FROM \");\r\n    pw.print(prefix);\r\n    pw.print(sqlQuery.getDialect().quoteIdentifier(factTableName));\r\n    pw.print(\" \");\r\n    pw.print(sqlQuery.getDialect().quoteIdentifier(factTableName));\r\n    pw.println(',');\r\n    int k = 0;\r\n    for (RolapStar.Table rt : collapsedColumnUsages.keySet()) {\r\n        if (k++ > 0) {\r\n            pw.println(',');\r\n        }\r\n        pw.print(prefix);\r\n        pw.print(sqlQuery.getDialect().quoteIdentifier(rt.getAlias()));\r\n        pw.print(\" AS \");\r\n        pw.print(sqlQuery.getDialect().quoteIdentifier(rt.getAlias()));\r\n        if (rt.getParentTable() != null) {\r\n            while (rt.getParentTable().getParentTable() != null) {\r\n                rt = rt.getParentTable();\r\n                pw.println(',');\r\n                pw.print(prefix);\r\n                pw.print(sqlQuery.getDialect().quoteIdentifier(rt.getAlias()));\r\n                pw.print(\" AS \");\r\n                pw.print(sqlQuery.getDialect().quoteIdentifier(rt.getAlias()));\r\n            }\r\n        }\r\n    }\r\n    pw.println();\r\n    pw.println(\"WHERE \");\r\n    k = 0;\r\n    for (RolapStar.Table rt : collapsedColumnUsages.keySet()) {\r\n        if (k++ > 0) {\r\n            pw.println(\" and\");\r\n        }\r\n        RolapStar.Condition cond = rt.getJoinCondition();\r\n        if (cond == null) {\r\n            continue;\r\n        }\r\n        pw.print(prefix);\r\n        pw.print(cond.toString(sqlQuery));\r\n        if (rt.getParentTable() != null) {\r\n            while (rt.getParentTable().getParentTable() != null) {\r\n                rt = rt.getParentTable();\r\n                cond = rt.getJoinCondition();\r\n                pw.println(\" and\");\r\n                pw.print(prefix);\r\n                pw.print(cond.toString(sqlQuery));\r\n            }\r\n        }\r\n    }\r\n    pw.println();\r\n    pw.println(\"GROUP BY \");\r\n    k = 0;\r\n    for (List<JdbcSchema.Table.Column.Usage> list : collapsedColumnUsages.values()) {\r\n        for (JdbcSchema.Table.Column.Usage usage : list) {\r\n            if (k++ > 0) {\r\n                pw.println(\",\");\r\n            }\r\n            JdbcSchema.Table.Column c = usage.getColumn();\r\n            JdbcSchema.Table t = c.getTable();\r\n            String n = (usage.usagePrefix == null) ? c.getName() : usage.usagePrefix + c.getName();\r\n            pw.print(prefix);\r\n            pw.print(sqlQuery.getDialect().quoteIdentifier(t.getName(), n));\r\n        }\r\n    }\r\n    pw.println(';');\r\n    return sw.toString();\r\n}"
}, {
	"Path": "mondrian.gui.validate.ValidationUtils.invalid",
	"Comment": "validate a schema model and returns the first error message if it isinvalid.",
	"Method": "String invalid(Messages messages,JdbcValidator jdbcValidator,TreeModel treeModel,TreeModelPath tpath,Object value,MondrianGuiDef.Cube cube,MondrianGuiDef.Dimension parentDimension,MondrianGuiDef.Hierarchy parentHierarchy,MondrianGuiDef.Level parentLevel,boolean isSchemaRequired){\r\n    String nameMustBeSet = messages.getString(\"schemaTreeCellRenderer.nameMustBeSet.alert\", \"Name must be set\");\r\n    if (!tpath.isEmpty()) {\r\n        int pathcount = tpath.getPathCount();\r\n        for (int i = 0; i < pathcount && (cube == null || parentDimension == null || parentHierarchy == null || parentLevel == null); i++) {\r\n            final Object p = tpath.getPathComponent(i);\r\n            if (p instanceof MondrianGuiDef.Cube && cube == null) {\r\n                cube = (MondrianGuiDef.Cube) p;\r\n            }\r\n            if (p instanceof MondrianGuiDef.Dimension && parentDimension == null) {\r\n                parentDimension = (MondrianGuiDef.Dimension) p;\r\n            }\r\n            if (p instanceof MondrianGuiDef.Hierarchy && parentHierarchy == null) {\r\n                parentHierarchy = (MondrianGuiDef.Hierarchy) p;\r\n            }\r\n            if (p instanceof MondrianGuiDef.Level && parentLevel == null) {\r\n                parentLevel = (MondrianGuiDef.Level) p;\r\n            }\r\n        }\r\n    }\r\n    if (value instanceof MondrianGuiDef.Schema) {\r\n        if (isEmpty(((MondrianGuiDef.Schema) value).name)) {\r\n            return nameMustBeSet;\r\n        }\r\n    } else if (value instanceof MondrianGuiDef.VirtualCube) {\r\n        MondrianGuiDef.VirtualCube virtCube = (MondrianGuiDef.VirtualCube) value;\r\n        if (isEmpty(virtCube.name)) {\r\n            return nameMustBeSet;\r\n        }\r\n        if (isEmpty(virtCube.dimensions)) {\r\n            return messages.getString(\"schemaTreeCellRenderer.cubeMustHaveDimensions.alert\", \"Cube must contain dimensions\");\r\n        }\r\n        if (isEmpty(virtCube.measures)) {\r\n            return messages.getString(\"schemaTreeCellRenderer.cubeMustHaveMeasures.alert\", \"Cube must contain measures\");\r\n        }\r\n    } else if (value instanceof MondrianGuiDef.VirtualCubeDimension) {\r\n        if (isEmpty(((MondrianGuiDef.VirtualCubeDimension) value).name)) {\r\n            return nameMustBeSet;\r\n        }\r\n    } else if (value instanceof MondrianGuiDef.VirtualCubeMeasure) {\r\n        if (isEmpty(((MondrianGuiDef.VirtualCubeMeasure) value).name)) {\r\n            return nameMustBeSet;\r\n        }\r\n    } else if (value instanceof MondrianGuiDef.Cube) {\r\n        MondrianGuiDef.Cube cubeVal = (MondrianGuiDef.Cube) value;\r\n        if (isEmpty(cubeVal.name)) {\r\n            return nameMustBeSet;\r\n        }\r\n        if (cubeVal.fact == null || ((cubeVal.fact instanceof MondrianGuiDef.Table) && isEmpty(((MondrianGuiDef.Table) cubeVal.fact).name)) || ((cubeVal.fact instanceof MondrianGuiDef.View) && isEmpty(((MondrianGuiDef.View) cubeVal.fact).alias))) {\r\n            return messages.getString(\"schemaTreeCellRenderer.factNameMustBeSet.alert\", \"Fact name must be set\");\r\n        }\r\n        if (isEmpty(cubeVal.dimensions)) {\r\n            return messages.getString(\"schemaTreeCellRenderer.cubeMustHaveDimensions.alert\", \"Cube must contain dimensions\");\r\n        }\r\n        if (isEmpty(cubeVal.measures)) {\r\n            return messages.getString(\"schemaTreeCellRenderer.cubeMustHaveMeasures.alert\", \"Cube must contain measures\");\r\n        }\r\n        if (jdbcValidator.isInitialized()) {\r\n            if (((MondrianGuiDef.Cube) value).fact instanceof MondrianGuiDef.Table) {\r\n                final MondrianGuiDef.Table table = (MondrianGuiDef.Table) cubeVal.fact;\r\n                String schemaName = table.schema;\r\n                String factTable = table.name;\r\n                if (!jdbcValidator.isTableExists(schemaName, factTable)) {\r\n                    return messages.getFormattedString(\"schemaTreeCellRenderer.factTableDoesNotExist.alert\", \"Fact table {0} does not exist in database {1}\", factTable, ((schemaName == null || schemaName.equals(\"\")) ? \".\" : \"schema \" + schemaName));\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        if (value instanceof MondrianGuiDef.CubeDimension) {\r\n            if (isEmpty(((MondrianGuiDef.CubeDimension) value).name)) {\r\n                return nameMustBeSet;\r\n            }\r\n            if (value instanceof MondrianGuiDef.DimensionUsage) {\r\n                if (isEmpty(((MondrianGuiDef.DimensionUsage) value).source)) {\r\n                    return messages.getString(\"schemaTreeCellRenderer.sourceMustBeSet.alert\", \"Source must be set\");\r\n                }\r\n                MondrianGuiDef.Schema s = (MondrianGuiDef.Schema) treeModel.getRoot();\r\n                MondrianGuiDef.Dimension[] ds = s.dimensions;\r\n                String sourcename = ((MondrianGuiDef.DimensionUsage) value).source;\r\n                boolean notfound = true;\r\n                for (int j = 0; j < ds.length; j++) {\r\n                    if (ds[j].name.equalsIgnoreCase(sourcename)) {\r\n                        notfound = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (notfound) {\r\n                    return messages.getFormattedString(\"schemaTreeCellRenderer.sourceInSharedDimensionDoesNotExist.alert\", \"Source {0} does not exist as Shared Dimension of Schema\", sourcename);\r\n                }\r\n            }\r\n            if (value instanceof MondrianGuiDef.Dimension && cube != null) {\r\n                if (!isEmpty(((MondrianGuiDef.Dimension) value).foreignKey)) {\r\n                    if (jdbcValidator.isInitialized()) {\r\n                        if (cube.fact instanceof MondrianGuiDef.Table) {\r\n                            final MondrianGuiDef.Table factTable = (MondrianGuiDef.Table) cube.fact;\r\n                            String foreignKey = ((MondrianGuiDef.Dimension) value).foreignKey;\r\n                            if (!jdbcValidator.isColExists(factTable.schema, factTable.name, foreignKey)) {\r\n                                return messages.getFormattedString(\"schemaTreeCellRenderer.foreignKeyDoesNotExist.alert\", \"foreignKey {0} does not exist in fact table\", foreignKey);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (value instanceof MondrianGuiDef.Level) {\r\n            MondrianGuiDef.Level level = (MondrianGuiDef.Level) value;\r\n            if (!isEmpty(level.levelType)) {\r\n                if (parentDimension != null) {\r\n                    if ((isEmpty(parentDimension.type) || parentDimension.type.equals(\"StandardDimension\")) && !isEmpty(level.levelType) && (!level.levelType.equals(MondrianGuiDef.Level._levelType_values[0]))) {\r\n                        return messages.getFormattedString(\"schemaTreeCellRenderer.levelUsedOnlyInTimeDimension.alert\", \"levelType {0} can only be used with a TimeDimension\", level.levelType);\r\n                    } else if (!isEmpty(parentDimension.type) && (parentDimension.type.equals(\"TimeDimension\")) && !isEmpty(level.levelType) && (level.levelType.equals(MondrianGuiDef.Level._levelType_values[0]))) {\r\n                        return messages.getFormattedString(\"schemaTreeCellRenderer.levelUsedOnlyInStandardDimension.alert\", \"levelType {0} can only be used with a StandardDimension\", level.levelType);\r\n                    }\r\n                }\r\n            }\r\n            if (isEmpty(level.name)) {\r\n                return messages.getString(\"schemaTreeCellRenderer.nameMustBeSet.alert\", \"Level name must be set\");\r\n            }\r\n            String column = level.column;\r\n            if (isEmpty(column)) {\r\n                if (level.properties == null || level.properties.length == 0) {\r\n                    return messages.getString(\"schemaTreeCellRenderer.columnMustBeSet.alert\", \"Column must be set\");\r\n                }\r\n            } else {\r\n                String theMessage = null;\r\n                try {\r\n                    for (int i = 0; i < DEF_LEVEL.length; i++) {\r\n                        Field theField = level.getClass().getDeclaredField(DEF_LEVEL[i]);\r\n                        column = (String) theField.get(level);\r\n                        theMessage = validateColumn(column, DEF_LEVEL[i], messages, level, jdbcValidator, cube, parentHierarchy);\r\n                        if (theMessage != null) {\r\n                            break;\r\n                        }\r\n                    }\r\n                } catch (Exception ex) {\r\n                    LOGGER.error(\"ValidationUtils\", ex);\r\n                }\r\n                return theMessage;\r\n            }\r\n        } else if (value instanceof MondrianGuiDef.Property) {\r\n            MondrianGuiDef.Property p = (MondrianGuiDef.Property) value;\r\n            String column = p.column;\r\n            if (isEmpty(column)) {\r\n                return messages.getString(\"schemaTreeCellRenderer.columnMustBeSet.alert\", \"Column must be set\");\r\n            }\r\n            if (jdbcValidator.isInitialized()) {\r\n                String table = null;\r\n                if (parentLevel != null) {\r\n                    table = parentLevel.table;\r\n                }\r\n                if (isEmpty(table)) {\r\n                    if (parentHierarchy != null) {\r\n                        if (parentHierarchy.relation == null && cube != null) {\r\n                            final MondrianGuiDef.Table factTable = (MondrianGuiDef.Table) cube.fact;\r\n                            if (!jdbcValidator.isColExists(factTable.schema, factTable.name, column)) {\r\n                                return messages.getFormattedString(\"schemaTreeCellRenderer.degenDimensionColumnDoesNotExist.alert\", \"Degenerate dimension validation check - Column {0} does not exist in fact table\", column);\r\n                            }\r\n                        } else if (parentHierarchy.relation instanceof MondrianGuiDef.Table) {\r\n                            final MondrianGuiDef.Table parentTable = (MondrianGuiDef.Table) parentHierarchy.relation;\r\n                            if (!jdbcValidator.isColExists(parentTable.schema, parentTable.name, column)) {\r\n                                return messages.getFormattedString(\"schemaTreeCellRenderer.columnInDimensionDoesNotExist.alert\", \"Column {0} does not exist in Dimension table\", parentTable.name);\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (!jdbcValidator.isColExists(null, table, column)) {\r\n                        return messages.getFormattedString(\"schemaTreeCellRenderer.columnInDimensionDoesNotExist.alert\", \"Column {0} does not exist in Level table {1}\", column, table);\r\n                    }\r\n                }\r\n            }\r\n        } else if (value instanceof MondrianGuiDef.Measure) {\r\n            final MondrianGuiDef.Measure measure = (MondrianGuiDef.Measure) value;\r\n            if (isEmpty(measure.name)) {\r\n                return nameMustBeSet;\r\n            }\r\n            if (isEmpty(measure.aggregator)) {\r\n                return messages.getString(\"schemaTreeCellRenderer.aggregatorMustBeSet.alert\", \"Aggregator must be set\");\r\n            }\r\n            if (measure.measureExp != null) {\r\n            } else if (isEmpty(measure.column)) {\r\n                return messages.getString(\"schemaTreeCellRenderer.columnMustBeSet.alert\", \"Column must be set\");\r\n            } else if (cube != null && cube.fact != null) {\r\n                if (cube.fact instanceof MondrianGuiDef.Table) {\r\n                    final MondrianGuiDef.Table factTable = (MondrianGuiDef.Table) cube.fact;\r\n                    if (jdbcValidator.isInitialized()) {\r\n                        String column = measure.column;\r\n                        if (jdbcValidator.isColExists(factTable.schema, factTable.name, column)) {\r\n                            int colType = jdbcValidator.getColumnDataType(factTable.schema, factTable.name, measure.column);\r\n                            int agIndex = -1;\r\n                            if (\"sum\".equals(measure.aggregator) || \"avg\".equals(measure.aggregator)) {\r\n                                agIndex = 0;\r\n                            }\r\n                            if (!(agIndex == -1 || (colType >= 2 && colType <= 8) || colType == -5 || colType == -6)) {\r\n                                return messages.getFormattedString(\"schemaTreeCellRenderer.aggregatorNotValidForColumn.alert\", \"Aggregator {0} is not valid for the data type of the column {1}\", measure.aggregator, measure.column);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else if (value instanceof MondrianGuiDef.Hierarchy) {\r\n            final MondrianGuiDef.Hierarchy hierarchy = (MondrianGuiDef.Hierarchy) value;\r\n            if (hierarchy.relation instanceof MondrianGuiDef.Join) {\r\n                if (isEmpty(hierarchy.primaryKeyTable)) {\r\n                    if (isEmpty(hierarchy.primaryKey)) {\r\n                        return messages.getString(\"schemaTreeCellRenderer.primaryKeyTableAndPrimaryKeyMustBeSet.alert\", \"PrimaryKeyTable and PrimaryKey must be set for Join\");\r\n                    } else {\r\n                        return messages.getString(\"schemaTreeCellRenderer.primaryKeyTableMustBeSet.alert\", \"PrimaryKeyTable must be set for Join\");\r\n                    }\r\n                }\r\n                if (isEmpty(hierarchy.primaryKey)) {\r\n                    return messages.getString(\"schemaTreeCellRenderer.primaryKeyMustBeSet.alert\", \"PrimaryKey must be set for Join\");\r\n                }\r\n            }\r\n            MondrianGuiDef.Level[] levels = hierarchy.levels;\r\n            if (levels == null || levels.length == 0) {\r\n                return messages.getString(\"schemaTreeCellRenderer.atLeastOneLevelForHierarchy.alert\", \"At least one Level must be set for Hierarchy\");\r\n            }\r\n            String schema = null;\r\n            String pkTable = null;\r\n            if (hierarchy.relation instanceof MondrianGuiDef.Join) {\r\n                String[] schemaAndTable = SchemaExplorer.getTableNameForAlias(hierarchy.relation, hierarchy.primaryKeyTable);\r\n                schema = schemaAndTable[0];\r\n                pkTable = schemaAndTable[1];\r\n            } else if (hierarchy.relation instanceof MondrianGuiDef.Table) {\r\n                final MondrianGuiDef.Table table = (MondrianGuiDef.Table) hierarchy.relation;\r\n                pkTable = table.name;\r\n                schema = table.schema;\r\n            }\r\n            if (pkTable != null && !jdbcValidator.isColExists(schema, pkTable, hierarchy.primaryKey)) {\r\n                return messages.getFormattedString(\"schemaTreeCellRenderer.columnInTableDoesNotExist.alert\", \"Column {0} defined in field {1} does not exist in table {2}\", isEmpty(hierarchy.primaryKey.trim()) ? \"' '\" : hierarchy.primaryKey, \"primaryKey\", pkTable);\r\n            }\r\n            if (hierarchy.relation instanceof MondrianGuiDef.Table) {\r\n                if (!isEmpty(hierarchy.primaryKeyTable)) {\r\n                    return messages.getString(\"schemaTreeCellRenderer.fieldMustBeEmpty\", \"Table field must be empty\");\r\n                }\r\n            }\r\n            String primaryKeyTable = hierarchy.primaryKeyTable;\r\n            if (!isEmpty(primaryKeyTable) && (hierarchy.relation instanceof MondrianGuiDef.Join)) {\r\n                TreeSet<String> joinTables = new TreeSet<String>();\r\n                SchemaExplorer.getTableNamesForJoin(hierarchy.relation, joinTables);\r\n                if (!joinTables.contains(primaryKeyTable)) {\r\n                    return messages.getString(\"schemaTreeCellRenderer.wrongTableValue\", \"Table value does not correspond to any join\");\r\n                }\r\n            }\r\n            if (!isEmpty(primaryKeyTable) && (hierarchy.relation instanceof MondrianGuiDef.Table)) {\r\n                MondrianGuiDef.Table theTable = (MondrianGuiDef.Table) hierarchy.relation;\r\n                String compareTo = (theTable.alias != null && theTable.alias.trim().length() > 0) ? theTable.alias : theTable.name;\r\n                if (!primaryKeyTable.equals(compareTo)) {\r\n                    return messages.getString(\"schemaTreeCellRenderer.tableDoesNotMatch\", \"Table value does not correspond to Hierarchy Relation\");\r\n                }\r\n            }\r\n        } else if (value instanceof MondrianGuiDef.NamedSet) {\r\n            final MondrianGuiDef.NamedSet namedSet = (MondrianGuiDef.NamedSet) value;\r\n            if (isEmpty(namedSet.name)) {\r\n                return nameMustBeSet;\r\n            }\r\n            if (isEmpty(namedSet.formula) && namedSet.formulaElement == null) {\r\n                return messages.getString(\"schemaTreeCellRenderer.formulaMustBeSet.alert\", \"Formula must be set\");\r\n            }\r\n        } else if (value instanceof MondrianGuiDef.Formula) {\r\n            final MondrianGuiDef.Formula formula = (MondrianGuiDef.Formula) value;\r\n            if (isEmpty(formula.cdata)) {\r\n                return messages.getString(\"schemaTreeCellRenderer.formulaMustBeSet.alert\", \"Formula must be set\");\r\n            }\r\n        } else if (value instanceof MondrianGuiDef.UserDefinedFunction) {\r\n            final MondrianGuiDef.UserDefinedFunction udf = (MondrianGuiDef.UserDefinedFunction) value;\r\n            if (isEmpty(udf.name)) {\r\n                return nameMustBeSet;\r\n            }\r\n            if (isEmpty(udf.className) && udf.script == null) {\r\n                return messages.getString(\"Either a Class Name or a Script are required\", \"Class name must be set\");\r\n            }\r\n        } else if (value instanceof MondrianGuiDef.MemberFormatter) {\r\n            final MondrianGuiDef.MemberFormatter f = (MondrianGuiDef.MemberFormatter) value;\r\n            if (isEmpty(f.className) && f.script == null) {\r\n                return messages.getString(\"schemaTreeCellRenderer.classNameOrScriptRequired.alert\", \"Either a Class Name or a Script are required\");\r\n            }\r\n        } else if (value instanceof MondrianGuiDef.CellFormatter) {\r\n            final MondrianGuiDef.CellFormatter f = (MondrianGuiDef.CellFormatter) value;\r\n            if (isEmpty(f.className) && f.script == null) {\r\n                return messages.getString(\"schemaTreeCellRenderer.classNameOrScriptRequired.alert\", \"Either a Class Name or a Script are required\");\r\n            }\r\n        } else if (value instanceof MondrianGuiDef.PropertyFormatter) {\r\n            final MondrianGuiDef.PropertyFormatter f = (MondrianGuiDef.PropertyFormatter) value;\r\n            if (isEmpty(f.className) && f.script == null) {\r\n                return messages.getString(\"schemaTreeCellRenderer.classNameOrScriptRequired.alert\", \"Either a Class Name or a Script are required\");\r\n            }\r\n        } else if (value instanceof MondrianGuiDef.CalculatedMember) {\r\n            final MondrianGuiDef.CalculatedMember calculatedMember = (MondrianGuiDef.CalculatedMember) value;\r\n            if (isEmpty(calculatedMember.name)) {\r\n                return nameMustBeSet;\r\n            }\r\n            if (isEmpty(calculatedMember.dimension)) {\r\n                return messages.getString(\"schemaTreeCellRenderer.dimensionMustBeSet.alert\", \"Dimension must be set\");\r\n            }\r\n            if (isEmpty(calculatedMember.formula) && calculatedMember.formulaElement == null) {\r\n                return messages.getString(\"schemaTreeCellRenderer.formulaMustBeSet.alert\", \"Formula must be set\");\r\n            }\r\n        } else if (value instanceof MondrianGuiDef.Join) {\r\n            final MondrianGuiDef.Join join = (MondrianGuiDef.Join) value;\r\n            if (isEmpty(join.leftKey)) {\r\n                return messages.getString(\"schemaTreeCellRenderer.leftKeyMustBeSet.alert\", \"Left key must be set\");\r\n            }\r\n            if (isEmpty(join.rightKey)) {\r\n                return messages.getString(\"schemaTreeCellRenderer.rightKeyMustBeSet.alert\", \"Right key must be set\");\r\n            }\r\n        } else if (value instanceof MondrianGuiDef.Table) {\r\n            final MondrianGuiDef.Table table = (MondrianGuiDef.Table) value;\r\n            String tableName = table.name;\r\n            if (!jdbcValidator.isTableExists(null, tableName)) {\r\n                return messages.getFormattedString(\"schemaTreeCellRenderer.tableDoesNotExist.alert\", \"Table {0} does not exist in database\", tableName);\r\n            }\r\n            String theSchema = table.schema;\r\n            if (!isEmpty(theSchema) && !jdbcValidator.isSchemaExists(theSchema)) {\r\n                return messages.getFormattedString(\"schemaTreeCellRenderer.schemaDoesNotExist.alert\", \"Schema {0} does not exist\", theSchema);\r\n            }\r\n            if (isEmpty(theSchema) && isSchemaRequired) {\r\n                return messages.getString(\"schemaTreeCellRenderer.schemaMustBeSet.alert\", \"Schema must be set\");\r\n            }\r\n        }\r\n    }\r\n    int childCnt = treeModel.getChildCount(value);\r\n    for (int i = 0; i < childCnt; i++) {\r\n        Object child = treeModel.getChild(value, i);\r\n        String childErrMsg;\r\n        if (child instanceof MondrianGuiDef.Cube) {\r\n            childErrMsg = invalid(messages, jdbcValidator, treeModel, tpath, child, (MondrianGuiDef.Cube) child, parentDimension, parentHierarchy, parentLevel, isSchemaRequired);\r\n        } else if (child instanceof MondrianGuiDef.Dimension) {\r\n            childErrMsg = invalid(messages, jdbcValidator, treeModel, tpath, child, cube, (MondrianGuiDef.Dimension) child, parentHierarchy, parentLevel, isSchemaRequired);\r\n        } else if (child instanceof MondrianGuiDef.Hierarchy) {\r\n            if (value instanceof MondrianGuiDef.Dimension && cube != null && ((MondrianGuiDef.Hierarchy) child).relation != null) {\r\n                if (isEmpty(((MondrianGuiDef.Dimension) value).foreignKey)) {\r\n                    return messages.getString(\"schemaTreeCellRenderer.foreignKeyMustBeSet.alert\", \"Foreign key must be set\");\r\n                }\r\n            }\r\n            childErrMsg = invalid(messages, jdbcValidator, treeModel, tpath, child, cube, parentDimension, (MondrianGuiDef.Hierarchy) child, parentLevel, isSchemaRequired);\r\n        } else if (child instanceof MondrianGuiDef.Level) {\r\n            childErrMsg = invalid(messages, jdbcValidator, treeModel, tpath, child, cube, parentDimension, parentHierarchy, (MondrianGuiDef.Level) child, isSchemaRequired);\r\n        } else {\r\n            childErrMsg = invalid(messages, jdbcValidator, treeModel, tpath, child, cube, parentDimension, parentHierarchy, parentLevel, isSchemaRequired);\r\n        }\r\n        if (childErrMsg != null) {\r\n            String childClassName = child.getClass().getName();\r\n            String[] simpleName = childClassName.split(\"[$.]\", 0);\r\n            String childName;\r\n            try {\r\n                Field f = child.getClass().getField(\"name\");\r\n                childName = (String) f.get(child);\r\n                if (childName == null) {\r\n                    childName = \"\";\r\n                }\r\n                childErrMsg = messages.getFormattedString(\"schemaTreeCellRenderer.childErrorMessageWithName.alert\", \"{0} {1} is invalid\", simpleName[simpleName.length - 1], childName);\r\n            } catch (Exception ex) {\r\n                childErrMsg = messages.getFormattedString(\"schemaTreeCellRenderer.childErrorExceptionMessage.alert\", \"{0} is invalid\", simpleName[simpleName.length - 1]);\r\n            }\r\n            return childErrMsg;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.test.TestCalculatedMembers.checkForExponentialPerformance",
	"Comment": "runs a query with an calculated member whose expression is a givencomplexity.",
	"Method": "void checkForExponentialPerformance(int n,boolean print){\r\n    StringBuilder buf = new StringBuilder();\r\n    for (int i = 0; i < n; ++i) {\r\n        buf.append(\"+ [Measures].[Sales Count] - [Measures].[Sales Count]\\n\");\r\n    }\r\n    final long t0 = System.currentTimeMillis();\r\n    final String mdx = \"with member [Measures].[M0] as\\n\" + \"    [Measures].[Unit Sales]\\n\" + \"   + [Measures].[Store Cost]\\n\" + \"   + [Measures].[Store Sales]\\n\" + \"   + [Measures].[Customer Count]\\n\" + buf + \"  set [#DataSet#] as NonEmptyCrossjoin(\\n\" + \"    {[Product].[Food]},\\n\" + \"    {Descendants([Store].[USA], 1)})\\n\" + \"select {[Measures].[M0]} on columns,\\n\" + \" NON EMPTY Hierarchize({[#DataSet#]}) on rows\\n\" + \"FROM [Sales]\";\r\n    assertQueryReturns(mdx, \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[M0]}\\n\" + \"Axis #2:\\n\" + \"{[Product].[Food], [Store].[USA].[CA]}\\n\" + \"{[Product].[Food], [Store].[USA].[OR]}\\n\" + \"{[Product].[Food], [Store].[USA].[WA]}\\n\" + \"Row #0: 217,506\\n\" + \"Row #1: 193,104\\n\" + \"Row #2: 359,162\\n\");\r\n    final Result result = executeQuery(mdx);\r\n    assertTrue(result.getCell(new int[] { 0, 0 }).canDrillThrough());\r\n    final long t1 = System.currentTimeMillis();\r\n    if (print) {\r\n        System.out.println(\"For n=\" + n + \", took \" + (t1 - t0) + \" millis\");\r\n    }\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunctionTest.testNullValue",
	"Comment": "tests use of null literal to generate a null cell value.testcase is from bug 1440344.",
	"Method": "void testNullValue(){\r\n    assertQueryReturns(\"with member [Measures].[X] as 'IIF([Measures].[Store Sales]>10000,[Measures].[Store Sales],Null)'\\n\" + \"select\\n\" + \"{[Measures].[X]} on columns,\\n\" + \"{[Product].[Product Department].members} on rows\\n\" + \"from Sales\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[X]}\\n\" + \"Axis #2:\\n\" + \"{[Product].[Drink].[Alcoholic Beverages]}\\n\" + \"{[Product].[Drink].[Beverages]}\\n\" + \"{[Product].[Drink].[Dairy]}\\n\" + \"{[Product].[Food].[Baked Goods]}\\n\" + \"{[Product].[Food].[Baking Goods]}\\n\" + \"{[Product].[Food].[Breakfast Foods]}\\n\" + \"{[Product].[Food].[Canned Foods]}\\n\" + \"{[Product].[Food].[Canned Products]}\\n\" + \"{[Product].[Food].[Dairy]}\\n\" + \"{[Product].[Food].[Deli]}\\n\" + \"{[Product].[Food].[Eggs]}\\n\" + \"{[Product].[Food].[Frozen Foods]}\\n\" + \"{[Product].[Food].[Meat]}\\n\" + \"{[Product].[Food].[Produce]}\\n\" + \"{[Product].[Food].[Seafood]}\\n\" + \"{[Product].[Food].[Snack Foods]}\\n\" + \"{[Product].[Food].[Snacks]}\\n\" + \"{[Product].[Food].[Starchy Foods]}\\n\" + \"{[Product].[Non-Consumable].[Carousel]}\\n\" + \"{[Product].[Non-Consumable].[Checkout]}\\n\" + \"{[Product].[Non-Consumable].[Health and Hygiene]}\\n\" + \"{[Product].[Non-Consumable].[Household]}\\n\" + \"{[Product].[Non-Consumable].[Periodicals]}\\n\" + \"Row #0: 14,029.08\\n\" + \"Row #1: 27,748.53\\n\" + \"Row #2: \\n\" + \"Row #3: 16,455.43\\n\" + \"Row #4: 38,670.41\\n\" + \"Row #5: \\n\" + \"Row #6: 39,774.34\\n\" + \"Row #7: \\n\" + \"Row #8: 30,508.85\\n\" + \"Row #9: 25,318.93\\n\" + \"Row #10: \\n\" + \"Row #11: 55,207.50\\n\" + \"Row #12: \\n\" + \"Row #13: 82,248.42\\n\" + \"Row #14: \\n\" + \"Row #15: 67,609.82\\n\" + \"Row #16: 14,550.05\\n\" + \"Row #17: 11,756.07\\n\" + \"Row #18: \\n\" + \"Row #19: \\n\" + \"Row #20: 32,571.86\\n\" + \"Row #21: 60,469.89\\n\" + \"Row #22: \\n\");\r\n}"
}, {
	"Path": "mondrian.tui.XmlUtil.getXercesVersionNumbers",
	"Comment": "gets the xerces version numbers as a three part array of ints wherethe first element is the major release number, the second is theminor release number, and the third is the patch number.",
	"Method": "int[] getXercesVersionNumbers(){\r\n    if (versionNumbers == null) {\r\n        int[] verNums = new int[3];\r\n        String verNumStr = getXercesVersionNumberString();\r\n        int index = verNumStr.indexOf('.');\r\n        verNums[0] = Integer.parseInt(verNumStr.substring(0, index));\r\n        verNumStr = verNumStr.substring(index + 1);\r\n        index = verNumStr.indexOf('.');\r\n        verNums[1] = Integer.parseInt(verNumStr.substring(0, index));\r\n        verNumStr = verNumStr.substring(index + 1);\r\n        verNums[2] = Integer.parseInt(verNumStr);\r\n        versionNumbers = verNums;\r\n    }\r\n    return versionNumbers;\r\n}"
}, {
	"Path": "mondrian.test.BasicQueryTest.testBigQuery",
	"Comment": "requires the use of a sparse segment, because the product dimensionhas 6 atttributes, the product of whose cardinalities is ~8m. if weuse a dense segment, we run out of memory trying to allocate a hugearray.",
	"Method": "void testBigQuery(){\r\n    Result result = executeQuery(\"SELECT {[Measures].[Unit Sales]} on columns,\\n\" + \" {[Product].members} on rows\\n\" + \"from Sales\");\r\n    final int rowCount = result.getAxes()[1].getPositions().size();\r\n    assertEquals(MondrianProperties.instance().FilterChildlessSnowflakeMembers.get() ? 2256 : 2266, rowCount);\r\n    assertEquals(\"152\", result.getCell(new int[] { 0, rowCount - 1 }).getFormattedValue());\r\n}"
}, {
	"Path": "mondrian.test.NativeSetEvaluationTest.testOverridingCompoundFilter",
	"Comment": "this test demonstrates complex interaction between member calcsand a compound slicer",
	"Method": "void testOverridingCompoundFilter(){\r\n    String mdx = \"WITH MEMBER [Gender].[All Gender].[NoSlicer] AS '([Product].[All Products], [Time].[1997])', solve_order=1000\\n \" + \"MEMBER [Measures].[TotalVal] AS 'Aggregate(Filter({[Store].[Store City].members},[Measures].[Unit Sales] < 2300)), solve_order=900'\\n\" + \"SELECT {[Measures].[TotalVal], [Measures].[Unit Sales]} on 0, {[Gender].[All Gender], [Gender].[All Gender].[NoSlicer]} on 1 from [Sales]\\n\" + \"WHERE {([Product].[Non-Consumable], [Time].[1997].[Q1]),([Product].[Drink], [Time].[1997].[Q2])}\";\r\n    TestContext context = getTestContext().withFreshConnection();\r\n    context.assertQueryReturns(mdx, \"Axis #0:\\n\" + \"{[Product].[Non-Consumable], [Time].[1997].[Q1]}\\n\" + \"{[Product].[Drink], [Time].[1997].[Q2]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[TotalVal]}\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[All Gender]}\\n\" + \"{[Gender].[All Gender].[NoSlicer]}\\n\" + \"Row #0: 12,730\\n\" + \"Row #0: 18,401\\n\" + \"Row #1: 6,557\\n\" + \"Row #1: 266,773\\n\");\r\n    mdx = \"WITH MEMBER [Gender].[All Gender].[SomeSlicer] AS '([Product].[All Products])', solve_order=1000\\n \" + \"MEMBER [Measures].[TotalVal] AS 'Aggregate(Filter({[Store].[Store City].members},[Measures].[Unit Sales] < 2700)), solve_order=900'\\n\" + \"SELECT {[Measures].[TotalVal], [Measures].[Unit Sales]} on 0, {[Gender].[All Gender], [Gender].[All Gender].[SomeSlicer]} on 1 from [Sales]\\n\" + \"WHERE {([Product].[Non-Consumable], [Time].[1997].[Q1]),([Product].[Drink], [Time].[1997].[Q2])}\";\r\n    context.assertQueryReturns(mdx, \"Axis #0:\\n\" + \"{[Product].[Non-Consumable], [Time].[1997].[Q1]}\\n\" + \"{[Product].[Drink], [Time].[1997].[Q2]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[TotalVal]}\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[All Gender]}\\n\" + \"{[Gender].[All Gender].[SomeSlicer]}\\n\" + \"Row #0: 15,056\\n\" + \"Row #0: 18,401\\n\" + \"Row #1: 3,045\\n\" + \"Row #1: 128,901\\n\");\r\n}"
}, {
	"Path": "org.mapsforge.map.awt.view.MapView.destroyAll",
	"Comment": "clear all map view elements.i.e. layers, tile cache, label store, map view, resources, etc.",
	"Method": "void destroyAll(){\r\n    for (Layer layer : this.layerManager.getLayers()) {\r\n        this.layerManager.getLayers().remove(layer);\r\n        layer.onDestroy();\r\n        if (layer instanceof TileLayer) {\r\n            ((TileLayer<?>) layer).getTileCache().destroy();\r\n        }\r\n        if (layer instanceof TileRendererLayer) {\r\n            LabelStore labelStore = ((TileRendererLayer) layer).getLabelStore();\r\n            if (labelStore != null) {\r\n                labelStore.clear();\r\n            }\r\n        }\r\n    }\r\n    destroy();\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AggregationKey.getConstrainedColumnsBitKey",
	"Comment": "returns the bitkey of columns that constrain this aggregation.",
	"Method": "BitKey getConstrainedColumnsBitKey(){\r\n    return constrainedColumnsBitKey;\r\n}"
}, {
	"Path": "mondrian.olap.type.DecimalType.getPrecision",
	"Comment": "returns the maximum number of decimal digits which a value ofthis type can have.",
	"Method": "int getPrecision(){\r\n    return precision;\r\n}"
}, {
	"Path": "mondrian.test.comp.ResultComparator.findSlicerAxisMember",
	"Comment": "returns which member of a given dimension appears in the sliceraxis.if the dimension occurs on one of the other axes, the answer is null.if the dimension occurs in the slicer axis, the answer is that member.otherwise it is the default member of the dimension.",
	"Method": "Member findSlicerAxisMember(Result result,Dimension dimension){\r\n    final Axis slicerAxis = result.getSlicerAxis();\r\n    if (slicerAxis != null && slicerAxis.getPositions().size() == 1) {\r\n        final List<Member> members = slicerAxis.getPositions().get(0);\r\n        for (Member member : members) {\r\n            if (member.getDimension() == dimension) {\r\n                return member;\r\n            }\r\n        }\r\n    }\r\n    final Axis[] axes = result.getAxes();\r\n    for (Axis axis : axes) {\r\n        if (axis.getPositions().size() > 0) {\r\n            final List<Member> members = axis.getPositions().get(0);\r\n            for (Member member : members) {\r\n                if (member.getDimension() == dimension) {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return dimension.getHierarchies()[0].getDefaultMember();\r\n}"
}, {
	"Path": "mondrian.mdx.ParameterExpr.equals",
	"Comment": "returns whether this parameter is equal to another, based upon name,type and value",
	"Method": "boolean equals(Object other){\r\n    if (!(other instanceof ParameterExpr)) {\r\n        return false;\r\n    }\r\n    ParameterExpr that = (ParameterExpr) other;\r\n    return this.parameter == that.parameter;\r\n}"
}, {
	"Path": "org.mapsforge.map.layer.renderer.DatabaseRenderer.createBackgroundBitmap",
	"Comment": "draws a bitmap just with outside colour, used for bitmaps outside of map area.",
	"Method": "TileBitmap createBackgroundBitmap(RenderContext renderContext){\r\n    TileBitmap bitmap = this.graphicFactory.createTileBitmap(renderContext.rendererJob.tile.tileSize, renderContext.rendererJob.hasAlpha);\r\n    renderContext.canvasRasterer.setCanvasBitmap(bitmap);\r\n    if (!renderContext.rendererJob.hasAlpha) {\r\n        renderContext.canvasRasterer.fill(renderContext.renderTheme.getMapBackgroundOutside());\r\n    }\r\n    return bitmap;\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.setFailback",
	"Comment": "sets the failback flag for the pool.\tif this is true and we have marked a host as dead,\twill try to bring it back.if it is false, we will never\ttry to resurrect a dead host.",
	"Method": "void setFailback(boolean failback){\r\n    this.failback = failback;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.P.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "P appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.olap.type.TypeUtil.canConvert",
	"Comment": "returns whether we can convert an argument of a given category to agiven parameter category.",
	"Method": "boolean canConvert(int ordinal,Type fromType,int to,List<Resolver.Conversion> conversions){\r\n    final int from = typeToCategory(fromType);\r\n    if (from == to) {\r\n        return true;\r\n    }\r\n    RuntimeException e = null;\r\n    switch(from) {\r\n        case Category.Array:\r\n            return false;\r\n        case Category.Dimension:\r\n            switch(to) {\r\n                case Category.Member:\r\n                case Category.Tuple:\r\n                case Category.Hierarchy:\r\n                    conversions.add(new ConversionImpl(from, to, ordinal, 2, e));\r\n                    return true;\r\n                case Category.Level:\r\n                    conversions.add(new ConversionImpl(from, to, ordinal, 3, null));\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        case Category.Hierarchy:\r\n            switch(to) {\r\n                case Category.Dimension:\r\n                case Category.Member:\r\n                case Category.Tuple:\r\n                    conversions.add(new ConversionImpl(from, to, ordinal, 1, null));\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        case Category.Level:\r\n            switch(to) {\r\n                case Category.Dimension:\r\n                    conversions.add(new ConversionImpl(from, to, ordinal, 2, null));\r\n                    return true;\r\n                case Category.Hierarchy:\r\n                    conversions.add(new ConversionImpl(from, to, ordinal, 1, null));\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        case Category.Logical:\r\n            switch(to) {\r\n                case Category.Value:\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        case Category.Member:\r\n            switch(to) {\r\n                case Category.Dimension:\r\n                case Category.Hierarchy:\r\n                case Category.Level:\r\n                case Category.Tuple:\r\n                    conversions.add(new ConversionImpl(from, to, ordinal, 1, null));\r\n                    return true;\r\n                case Category.Set:\r\n                    conversions.add(new ConversionImpl(from, to, ordinal, 2, null));\r\n                    return true;\r\n                case Category.Numeric:\r\n                    conversions.add(new ConversionImpl(from, to, ordinal, 3, null));\r\n                    return true;\r\n                case Category.Value:\r\n                case Category.String:\r\n                    conversions.add(new ConversionImpl(from, to, ordinal, 4, null));\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        case Category.Numeric | Category.Constant:\r\n            switch(to) {\r\n                case Category.Value:\r\n                case Category.Numeric:\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        case Category.Numeric:\r\n            switch(to) {\r\n                case Category.Logical:\r\n                    conversions.add(new ConversionImpl(from, to, ordinal, 2, null));\r\n                    return true;\r\n                case Category.Value:\r\n                case Category.Integer:\r\n                case (Category.Integer | Category.Constant):\r\n                case (Category.Numeric | Category.Constant):\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        case Category.Integer:\r\n            switch(to) {\r\n                case Category.Value:\r\n                case (Category.Integer | Category.Constant):\r\n                case Category.Numeric:\r\n                case (Category.Numeric | Category.Constant):\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        case Category.Set:\r\n            return false;\r\n        case Category.String | Category.Constant:\r\n            switch(to) {\r\n                case Category.Value:\r\n                case Category.String:\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        case Category.String:\r\n            switch(to) {\r\n                case Category.Value:\r\n                case (Category.String | Category.Constant):\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        case Category.DateTime | Category.Constant:\r\n            switch(to) {\r\n                case Category.Value:\r\n                case Category.DateTime:\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        case Category.DateTime:\r\n            switch(to) {\r\n                case Category.Value:\r\n                case (Category.DateTime | Category.Constant):\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        case Category.Tuple:\r\n            switch(to) {\r\n                case Category.Set:\r\n                    conversions.add(new ConversionImpl(from, to, ordinal, 2, null));\r\n                    return true;\r\n                case Category.Numeric:\r\n                    conversions.add(new ConversionImpl(from, to, ordinal, 3, null));\r\n                    return true;\r\n                case Category.String:\r\n                case Category.Value:\r\n                    conversions.add(new ConversionImpl(from, to, ordinal, 4, null));\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        case Category.Value:\r\n            switch(to) {\r\n                case Category.String:\r\n                case Category.Numeric:\r\n                case Category.Logical:\r\n                    conversions.add(new ConversionImpl(from, to, ordinal, 2, null));\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        case Category.Symbol:\r\n            return false;\r\n        case Category.Null:\r\n            if (Category.isScalar(to)) {\r\n                return true;\r\n            } else if (to == Category.Member) {\r\n                conversions.add(new ConversionImpl(from, to, ordinal, 2, null));\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        case Category.Empty:\r\n            return false;\r\n        default:\r\n            throw Util.newInternal(\"unknown category \" + from + \" for type \" + fromType);\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.FoodMartTestCase.assertAxisThrows",
	"Comment": "runs a query with a given expression on an axis, and asserts that itthrows an error which matches a particular pattern. the expressionis evaulated against the sales cube.",
	"Method": "void assertAxisThrows(String expression,String pattern){\r\n    getTestContext().assertAxisThrows(expression, pattern);\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.StringUtils.trimWhitespace",
	"Comment": "trim leading and trailing whitespace from the given string.",
	"Method": "String trimWhitespace(String str){\r\n    if (!hasLength(str)) {\r\n        return str;\r\n    }\r\n    StringBuilder sb = new StringBuilder(str);\r\n    while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {\r\n        sb.deleteCharAt(0);\r\n    }\r\n    while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {\r\n        sb.deleteCharAt(sb.length() - 1);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "mondrian.test.loader.MondrianFoodMartLoader.inQuote",
	"Comment": "returns whether we are inside a quoted string after reading a string.",
	"Method": "boolean inQuote(String str,boolean nowInQuote){\r\n    if (str.indexOf('\\'') == -1) {\r\n        return nowInQuote;\r\n    }\r\n    int lastPos = 0;\r\n    while (lastPos <= str.length() && str.indexOf('\\'', lastPos) != -1) {\r\n        int pos = str.indexOf('\\'', lastPos);\r\n        nowInQuote = !nowInQuote;\r\n        lastPos = pos + 1;\r\n    }\r\n    return nowInQuote;\r\n}"
}, {
	"Path": "mondrian.rolap.SqlConstraintUtils.constrainLevel",
	"Comment": "generates a sql expression constraining a level by some value",
	"Method": "String constrainLevel(RolapLevel level,SqlQuery query,RolapCube baseCube,AggStar aggStar,String columnValue,boolean caseSensitive,String constrainLevel,RolapLevel level,SqlQuery query,RolapCube baseCube,AggStar aggStar,String[] columnValue,boolean caseSensitive){\r\n    RolapStar.Column column = null;\r\n    if (level instanceof RolapCubeLevel) {\r\n        column = ((RolapCubeLevel) level).getBaseStarKeyColumn(baseCube);\r\n    }\r\n    String columnString;\r\n    Dialect.Datatype datatype;\r\n    if (column != null) {\r\n        if (column.getNameColumn() == null) {\r\n            datatype = level.getDatatype();\r\n        } else {\r\n            column = column.getNameColumn();\r\n            datatype = Dialect.Datatype.String;\r\n        }\r\n        if (aggStar != null) {\r\n            int bitPos = column.getBitPosition();\r\n            AggStar.Table.Column aggColumn = aggStar.lookupColumn(bitPos);\r\n            if (aggColumn == null) {\r\n                LOG.warn(mres.AggTableNoConstraintGenerated.str(aggStar.getFactTable().getName()));\r\n                return \"\";\r\n            }\r\n            columnString = aggColumn.generateExprString(query);\r\n        } else {\r\n            columnString = column.generateExprString(query);\r\n        }\r\n    } else {\r\n        assert (aggStar == null);\r\n        MondrianDef.Expression exp = level.getNameExp();\r\n        if (exp == null) {\r\n            exp = level.getKeyExp();\r\n            datatype = level.getDatatype();\r\n        } else {\r\n            datatype = Dialect.Datatype.String;\r\n        }\r\n        columnString = exp.getExpression(query);\r\n    }\r\n    String constraint;\r\n    constraint = getColumnValueConstraint(query, columnValue, caseSensitive, columnString, datatype);\r\n    return constraint;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Tt.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Tt appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Base.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Base appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getCharacterEncoding",
	"Comment": "returns the name of the character encoding used in the body of thisrequest.",
	"Method": "String getCharacterEncoding(){\r\n    return charEncoding;\r\n}"
}, {
	"Path": "net.engio.mbassy.subscription.Subscription.handlesMessageType",
	"Comment": "check whether this subscription manages a specific message type.",
	"Method": "boolean handlesMessageType(Class<?> messageType){\r\n    return context.getHandler().handlesMessage(messageType);\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.model.ZoomIntervalConfiguration.newInstance",
	"Comment": "create a new zoomintervalconfiguration from the given byte array. checks for validity.",
	"Method": "ZoomIntervalConfiguration newInstance(byte[] intervals){\r\n    return new ZoomIntervalConfiguration(intervals);\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.util.GeoUtils.deltaLat",
	"Comment": "computes the amount of latitude degrees for a given distance in pixel at a given zoom level.",
	"Method": "double deltaLat(double deltaPixel,double lat,byte zoom,int tileSize){\r\n    long mapSize = MercatorProjection.getMapSize(zoom, tileSize);\r\n    double pixelY = MercatorProjection.latitudeToPixelY(lat, mapSize);\r\n    double lat2 = MercatorProjection.pixelYToLatitude(pixelY + deltaPixel, mapSize);\r\n    return Math.abs(lat2 - lat);\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.SoundManager.loadSounds",
	"Comment": "loads the various sound assets currently hardcoded but could easily bechanged to be flexible.",
	"Method": "void loadSounds(){\r\n    mSoundPoolMap.put(1, mSoundPool.load(mContext, R.raw.pop, 1));\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.AggGen.createLost",
	"Comment": "return a string containing the sql code to create a lost dimensiontable.",
	"Method": "String createLost(){\r\n    StringWriter sw = new StringWriter(512);\r\n    PrintWriter pw = new PrintWriter(sw);\r\n    String prefix = \"    \";\r\n    pw.print(\"CREATE TABLE \");\r\n    pw.print(makeLostAggregateTableName(getFactTableName()));\r\n    pw.println(\" (\");\r\n    for (JdbcSchema.Table.Column.Usage usage : notLostColumnUsages) {\r\n        addColumnCreate(pw, prefix, usage);\r\n    }\r\n    for (JdbcSchema.Table.Column.Usage usage : measures) {\r\n        addColumnCreate(pw, prefix, usage);\r\n    }\r\n    pw.print(prefix);\r\n    pw.print(getFactCount());\r\n    pw.println(\" INTEGER NOT NULL\");\r\n    pw.println(\");\");\r\n    return sw.toString();\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunctionTest._testLinRegAll",
	"Comment": "tests all of the linear regression functions, as suggested bya microsoft knowledgebase article.",
	"Method": "void _testLinRegAll(){\r\n    assertQueryReturns(\"WITH MEMBER \\n\" + \"[Measures].[Intercept] AS \\n\" + \"  'LinRegIntercept([Time].CurrentMember.Lag(10) : [Time].CurrentMember, [Measures].[Unit Sales], [Measures].[Store Sales])' \\n\" + \"MEMBER [Measures].[Regression Slope] AS\\n\" + \"  'LinRegSlope([Time].CurrentMember.Lag(9) : [Time].CurrentMember,[Measures].[Unit Sales],[Measures].[Store Sales]) '\\n\" + \"MEMBER [Measures].[Predict] AS\\n\" + \"  'LinRegPoint([Measures].[Unit Sales],[Time].CurrentMember.Lag(9) : [Time].CurrentMember,[Measures].[Unit Sales],[Measures].[Store Sales])',\\n\" + \"  FORMAT_STRING = 'Standard' \\n\" + \"MEMBER [Measures].[Predict Formula] AS\\n\" + \"  '([Measures].[Regression Slope] * [Measures].[Unit Sales]) + [Measures].[Intercept]',\\n\" + \"  FORMAT_STRING='Standard'\\n\" + \"MEMBER [Measures].[Good Fit] AS\\n\" + \"  'LinRegR2([Time].CurrentMember.Lag(9) : [Time].CurrentMember, [Measures].[Unit Sales],[Measures].[Store Sales])',\\n\" + \"  FORMAT_STRING='#,#.00'\\n\" + \"MEMBER [Measures].[Variance] AS\\n\" + \"  'LinRegVariance([Time].CurrentMember.Lag(9) : [Time].CurrentMember,[Measures].[Unit Sales],[Measures].[Store Sales])'\\n\" + \"SELECT \\n\" + \"  {[Measures].[Store Sales], \\n\" + \"   [Measures].[Intercept], \\n\" + \"   [Measures].[Regression Slope], \\n\" + \"   [Measures].[Predict], \\n\" + \"   [Measures].[Predict Formula], \\n\" + \"   [Measures].[Good Fit], \\n\" + \"   [Measures].[Variance] } ON COLUMNS, \\n\" + \"  Descendants([Time].[1997], [Time].[Month]) ON ROWS\\n\" + \"FROM Sales\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Store Sales]}\\n\" + \"{[Measures].[Intercept]}\\n\" + \"{[Measures].[Regression Slope]}\\n\" + \"{[Measures].[Predict]}\\n\" + \"{[Measures].[Predict Formula]}\\n\" + \"{[Measures].[Good Fit]}\\n\" + \"{[Measures].[Variance]}\\n\" + \"Axis #2:\\n\" + \"{[Time].[1997].[Q1].[1]}\\n\" + \"{[Time].[1997].[Q1].[2]}\\n\" + \"{[Time].[1997].[Q1].[3]}\\n\" + \"{[Time].[1997].[Q2].[4]}\\n\" + \"{[Time].[1997].[Q2].[5]}\\n\" + \"{[Time].[1997].[Q2].[6]}\\n\" + \"{[Time].[1997].[Q3].[7]}\\n\" + \"{[Time].[1997].[Q3].[8]}\\n\" + \"{[Time].[1997].[Q3].[9]}\\n\" + \"{[Time].[1997].[Q4].[10]}\\n\" + \"{[Time].[1997].[Q4].[11]}\\n\" + \"{[Time].[1997].[Q4].[12]}\\n\" + \"Row #0: 45,539.69\\n\" + \"Row #0: 68711.40\\n\" + \"Row #0: -1.033\\n\" + \"Row #0: 46,350.26\\n\" + \"Row #0: 46.350.26\\n\" + \"Row #0: -1.#INF\\n\" + \"Row #0: 5.17E-08\\n\" + \"...\\n\" + \"Row #11: 15343.67\\n\");\r\n}"
}, {
	"Path": "mondrian.tui.MockServletContext.getMinorVersion",
	"Comment": "returns the minor version of the servlet api that this servlet containersupports.",
	"Method": "int getMinorVersion(){\r\n    return this.minorVersion;\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.AggStar.lookupMeasure",
	"Comment": "get the measure at the given bit position or return null.note that there is no check that the bit position is within the range ofthe array of columns.nor is there a check that the column type at that position is a measure.",
	"Method": "AggStar.FactTable.Measure lookupMeasure(int bitPos){\r\n    AggStar.Table.Column column = lookupColumn(bitPos);\r\n    return (column instanceof AggStar.FactTable.Measure) ? (AggStar.FactTable.Measure) column : null;\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.DrawerFrameLayout.hasOnProfileSwitchListener",
	"Comment": "gets whether the drawer has a profile switch listener set to it",
	"Method": "boolean hasOnProfileSwitchListener(){\r\n    return mDrawer.hasOnProfileSwitchListener();\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testExpandOneNonNativeInput",
	"Comment": "verifies that crossjoins with one non native inputs can be nativelyevaluated.",
	"Method": "void testExpandOneNonNativeInput(){\r\n    propSaver.set(MondrianProperties.instance().ExpandNonNative, true);\r\n    propSaver.set(MondrianProperties.instance().EnableNativeCrossJoin, true);\r\n    boolean requestFreshConnection = true;\r\n    checkNative(0, 1, \"With \" + \"Set [*Filtered_Set] as Filter([Product].[Product Name].Members, [Product].CurrentMember IS [Product].[Product Name].[Fast Raisins]) \" + \"Set [*NECJ_Set] as NonEmptyCrossJoin([Store].[Store Country].Members, [*Filtered_Set]) \" + \"select [*NECJ_Set] on columns \" + \"From [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Store].[USA], [Product].[Food].[Snack Foods].[Snack Foods].[Dried Fruit].[Fast].[Fast Raisins]}\\n\" + \"Row #0: 152\\n\", requestFreshConnection);\r\n}"
}, {
	"Path": "mondrian.rolap.SmartMemberReader.readMemberChildren",
	"Comment": "reads the children of member into cache, and also intoresult.",
	"Method": "void readMemberChildren(List<RolapMember> members,List<RolapMember> result,MemberChildrenConstraint constraint){\r\n    if (false) {\r\n        Util.assertPrecondition(isSorted(members), \"isSorted(members)\");\r\n    }\r\n    List<RolapMember> children = new ConcatenableList<RolapMember>();\r\n    source.getMemberChildren(members, children, constraint);\r\n    Map<RolapMember, List<RolapMember>> tempMap = new HashMap<RolapMember, List<RolapMember>>();\r\n    for (RolapMember member1 : members) {\r\n        tempMap.put(member1, Collections.EMPTY_LIST);\r\n    }\r\n    for (final RolapMember child : children) {\r\n        assert child != null : \"child\";\r\n        assert tempMap != null : \"tempMap\";\r\n        final RolapMember parentMember = child.getParentMember();\r\n        List<RolapMember> list = tempMap.get(parentMember);\r\n        if (list == null) {\r\n            continue;\r\n        } else if (list == Collections.EMPTY_LIST) {\r\n            list = new ArrayList<RolapMember>();\r\n            tempMap.put(parentMember, list);\r\n        }\r\n        ((List) list).add(child);\r\n        ((List) result).add(child);\r\n    }\r\n    synchronized (cacheHelper) {\r\n        for (Map.Entry<RolapMember, List<RolapMember>> entry : tempMap.entrySet()) {\r\n            final RolapMember member = entry.getKey();\r\n            if (cacheHelper.getChildrenFromCache(member, constraint) == null) {\r\n                final List<RolapMember> list = entry.getValue();\r\n                cacheHelper.putChildren(member, constraint, list);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.RolapEvaluator.getExpResultCacheKey",
	"Comment": "creates a key which uniquely identifes an expression and itscontext. the context includes members of dimensions which theexpression is dependent upon.",
	"Method": "Object getExpResultCacheKey(ExpCacheDescriptor descriptor){\r\n    final List<Object> key;\r\n    if (nonEmpty) {\r\n        key = new ArrayList<Object>(currentMembers.length + 1);\r\n        key.add(descriptor.getExp());\r\n        for (RolapMember currentMember : currentMembers) {\r\n            key.add(currentMember);\r\n        }\r\n    } else {\r\n        final int[] hierarchyOrdinals = descriptor.getDependentHierarchyOrdinals();\r\n        key = new ArrayList<Object>(hierarchyOrdinals.length + 1);\r\n        key.add(descriptor.getExp());\r\n        for (final int hierarchyOrdinal : hierarchyOrdinals) {\r\n            final Member member = currentMembers[hierarchyOrdinal];\r\n            assert member != null;\r\n            key.add(member);\r\n        }\r\n    }\r\n    return key;\r\n}"
}, {
	"Path": "mondrian.gui.SchemaTreeModel.getChildList",
	"Comment": "returns an immutable list of child elements of a given element.",
	"Method": "List<Object> getChildList(Object parent){\r\n    if (parent instanceof MondrianGuiDef.Cube) {\r\n        MondrianGuiDef.Cube c = (MondrianGuiDef.Cube) parent;\r\n        return new CompositeList<Object>(ifList(c.fact), Arrays.asList(c.dimensions), Arrays.asList(c.measures), Arrays.asList(c.calculatedMembers), Arrays.asList(c.namedSets), ifList(c.annotations));\r\n    } else if (parent instanceof MondrianGuiDef.Dimension) {\r\n        MondrianGuiDef.Dimension d = (MondrianGuiDef.Dimension) parent;\r\n        return new CompositeList<Object>(Arrays.asList((Object[]) d.hierarchies), ifList(d.annotations));\r\n    } else if (parent instanceof MondrianGuiDef.UserDefinedFunction) {\r\n        MondrianGuiDef.UserDefinedFunction udf = (MondrianGuiDef.UserDefinedFunction) parent;\r\n        return new CompositeList<Object>(ifList(udf.script));\r\n    } else if (parent instanceof MondrianGuiDef.ExpressionView) {\r\n        MondrianGuiDef.ExpressionView ev = (MondrianGuiDef.ExpressionView) parent;\r\n        return Arrays.asList((Object[]) ev.expressions);\r\n    } else if (parent instanceof MondrianGuiDef.Hierarchy) {\r\n        MondrianGuiDef.Hierarchy h = (MondrianGuiDef.Hierarchy) parent;\r\n        return new CompositeList<Object>(Arrays.asList(h.levels), Arrays.asList(h.memberReaderParameters), ifList(h.relation), ifList(h.annotations));\r\n    } else if (parent instanceof MondrianGuiDef.Join) {\r\n        MondrianGuiDef.Join j = (MondrianGuiDef.Join) parent;\r\n        return Arrays.<Object>asList(j.left, j.right);\r\n    } else if (parent instanceof MondrianGuiDef.Level) {\r\n        MondrianGuiDef.Level level = (MondrianGuiDef.Level) parent;\r\n        return new CompositeList<Object>(Arrays.asList(level.properties), ifList(level.keyExp), ifList(level.nameExp), ifList(level.ordinalExp), ifList(level.captionExp), ifList(level.parentExp), ifList(level.closure), ifList(level.memberFormatter), ifList(level.annotations));\r\n    } else if (parent instanceof MondrianGuiDef.CellFormatter) {\r\n        MondrianGuiDef.CellFormatter f = (MondrianGuiDef.CellFormatter) parent;\r\n        return new CompositeList<Object>(ifList(f.script));\r\n    } else if (parent instanceof MondrianGuiDef.MemberFormatter) {\r\n        MondrianGuiDef.MemberFormatter f = (MondrianGuiDef.MemberFormatter) parent;\r\n        return new CompositeList<Object>(ifList(f.script));\r\n    } else if (parent instanceof MondrianGuiDef.PropertyFormatter) {\r\n        MondrianGuiDef.PropertyFormatter f = (MondrianGuiDef.PropertyFormatter) parent;\r\n        return new CompositeList<Object>(ifList(f.script));\r\n    } else if (parent instanceof MondrianGuiDef.Property) {\r\n        MondrianGuiDef.Property property = (MondrianGuiDef.Property) parent;\r\n        return new CompositeList<Object>(ifList(property.propertyFormatter));\r\n    } else if (parent instanceof MondrianGuiDef.CalculatedMember) {\r\n        MondrianGuiDef.CalculatedMember c = (MondrianGuiDef.CalculatedMember) parent;\r\n        return new CompositeList<Object>(ifList(c.formulaElement), arrayList(c.memberProperties), ifList(c.annotations), ifList(c.cellFormatter));\r\n    } else if (parent instanceof MondrianGuiDef.Measure) {\r\n        MondrianGuiDef.Measure m = (MondrianGuiDef.Measure) parent;\r\n        return new CompositeList<Object>(ifList(m.measureExp), arrayList(m.memberProperties), ifList(m.annotations), ifList(m.cellFormatter));\r\n    } else if (parent instanceof MondrianGuiDef.NamedSet) {\r\n        MondrianGuiDef.NamedSet m = (MondrianGuiDef.NamedSet) parent;\r\n        return new CompositeList<Object>(ifList((Object) m.formulaElement), ifList(m.annotations));\r\n    } else if (parent instanceof MondrianGuiDef.Schema) {\r\n        MondrianGuiDef.Schema s = (MondrianGuiDef.Schema) parent;\r\n        return new CompositeList<Object>(Arrays.asList(s.cubes), Arrays.asList(s.dimensions), Arrays.asList(s.namedSets), Arrays.asList(s.namedSets), Arrays.asList(s.userDefinedFunctions), Arrays.asList(s.virtualCubes), Arrays.asList(s.roles), Arrays.asList(s.parameters), ifList(s.annotations));\r\n    } else if (parent instanceof MondrianGuiDef.Table) {\r\n        MondrianGuiDef.Table t = (MondrianGuiDef.Table) parent;\r\n        return new CompositeList<Object>(arrayList(t.aggTables), arrayList(t.aggExcludes));\r\n    } else if (parent instanceof MondrianGuiDef.AggTable) {\r\n        MondrianGuiDef.AggTable t = (MondrianGuiDef.AggTable) parent;\r\n        return new CompositeList<Object>(ifList(t.factcount), Arrays.asList(t.measuresfactcount), Arrays.asList(t.ignoreColumns), Arrays.asList(t.foreignKeys), Arrays.asList(t.measures), Arrays.asList(t.levels), (t instanceof MondrianGuiDef.AggPattern) ? Arrays.asList(((MondrianGuiDef.AggPattern) t).excludes) : Collections.emptyList());\r\n    } else if (parent instanceof MondrianGuiDef.AggLevel) {\r\n        MondrianGuiDef.AggLevel t = (MondrianGuiDef.AggLevel) parent;\r\n        if (t.properties == null) {\r\n            t.properties = new MondrianGuiDef.AggLevelProperty[0];\r\n        }\r\n        return new CompositeList<Object>(Arrays.asList(t.properties));\r\n    } else if (parent instanceof MondrianGuiDef.View) {\r\n        MondrianGuiDef.View v = (MondrianGuiDef.View) parent;\r\n        return Arrays.asList((Object[]) v.selects);\r\n    } else if (parent instanceof MondrianGuiDef.VirtualCube) {\r\n        MondrianGuiDef.VirtualCube c = (MondrianGuiDef.VirtualCube) parent;\r\n        return new CompositeList<Object>(Arrays.asList(c.dimensions), Arrays.asList(c.measures), Arrays.asList(c.calculatedMembers), ifList(c.annotations));\r\n    } else if (parent instanceof MondrianGuiDef.VirtualCubeDimension) {\r\n        MondrianGuiDef.VirtualCubeDimension d = (MondrianGuiDef.VirtualCubeDimension) parent;\r\n        return ifList((Object) d.annotations);\r\n    } else if (parent instanceof MondrianGuiDef.VirtualCubeMeasure) {\r\n        MondrianGuiDef.VirtualCubeMeasure m = (MondrianGuiDef.VirtualCubeMeasure) parent;\r\n        return ifList((Object) m.annotations);\r\n    } else if (parent instanceof MondrianGuiDef.Role) {\r\n        MondrianGuiDef.Role c = (MondrianGuiDef.Role) parent;\r\n        return new CompositeList<Object>(Arrays.asList((Object[]) c.schemaGrants), ifList((Object) c.annotations));\r\n    } else if (parent instanceof MondrianGuiDef.SchemaGrant) {\r\n        MondrianGuiDef.SchemaGrant c = (MondrianGuiDef.SchemaGrant) parent;\r\n        return Arrays.asList((Object[]) c.cubeGrants);\r\n    } else if (parent instanceof MondrianGuiDef.CubeGrant) {\r\n        MondrianGuiDef.CubeGrant c = (MondrianGuiDef.CubeGrant) parent;\r\n        return new CompositeList<Object>(Arrays.asList(c.dimensionGrants), Arrays.asList(c.hierarchyGrants));\r\n    } else if (parent instanceof MondrianGuiDef.HierarchyGrant) {\r\n        MondrianGuiDef.HierarchyGrant c = (MondrianGuiDef.HierarchyGrant) parent;\r\n        return Arrays.asList((Object[]) c.memberGrants);\r\n    } else if (parent instanceof MondrianGuiDef.Closure) {\r\n        MondrianGuiDef.Closure c = (MondrianGuiDef.Closure) parent;\r\n        return ifList((Object) c.table);\r\n    } else if (parent instanceof MondrianGuiDef.Annotations) {\r\n        MondrianGuiDef.Annotations annotations = (MondrianGuiDef.Annotations) parent;\r\n        return Arrays.asList((Object[]) annotations.array);\r\n    } else {\r\n        return Collections.emptyList();\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.map.layer.renderer.TileRendererLayer.getLabelStore",
	"Comment": "labels can be stored in a labelstore for rendering on a separate layer.",
	"Method": "LabelStore getLabelStore(){\r\n    return tileBasedLabelStore;\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentBuilder.toSegment",
	"Comment": "creates a segment from a segmentheader. the star,constrainedcolsbitkey, constrainedcolumns and measure arguments are ahelping hand, because we know what we were looking for.",
	"Method": "Segment toSegment(SegmentHeader header,RolapStar star,BitKey constrainedColumnsBitKey,RolapStar.Column[] constrainedColumns,RolapStar.Measure measure,List<StarPredicate> compoundPredicates){\r\n    final List<StarColumnPredicate> predicateList = new ArrayList<StarColumnPredicate>();\r\n    for (int i = 0; i < constrainedColumns.length; i++) {\r\n        RolapStar.Column constrainedColumn = constrainedColumns[i];\r\n        final SortedSet<Comparable> values = header.getConstrainedColumns().get(i).values;\r\n        StarColumnPredicate predicate;\r\n        if (values == null) {\r\n            predicate = new LiteralStarPredicate(constrainedColumn, true);\r\n        } else if (values.size() == 1) {\r\n            predicate = new ValueColumnPredicate(constrainedColumn, values.first());\r\n        } else {\r\n            final List<StarColumnPredicate> valuePredicateList = new ArrayList<StarColumnPredicate>();\r\n            for (Object value : values) {\r\n                valuePredicateList.add(new ValueColumnPredicate(constrainedColumn, value));\r\n            }\r\n            predicate = new ListColumnPredicate(constrainedColumn, valuePredicateList);\r\n        }\r\n        predicateList.add(predicate);\r\n    }\r\n    return new Segment(star, constrainedColumnsBitKey, constrainedColumns, measure, predicateList.toArray(new StarColumnPredicate[predicateList.size()]), new ExcludedRegionList(header), compoundPredicates);\r\n}"
}, {
	"Path": "org.mapsforge.core.model.LatLong.distance",
	"Comment": "calculate the euclidean distance from this latlong to another.",
	"Method": "double distance(LatLong other){\r\n    return LatLongUtils.distance(this, other);\r\n}"
}, {
	"Path": "org.jfaster.mango.parser.JJTParserState.nodeArity",
	"Comment": "returns the number of children on the stack in the current node scope.",
	"Method": "int nodeArity(){\r\n    return sp - mk;\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletResponse.reset",
	"Comment": "clears any data that exists in the buffer as well as the status code andheaders.",
	"Method": "void reset(){\r\n    headers.clear();\r\n    resetBuffer();\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.AggStar.isFullyCollapsed",
	"Comment": "returns true if every level column in the aggstaris collapsed.",
	"Method": "boolean isFullyCollapsed(){\r\n    BitSet bitSet = this.getLevelBitKey().toBitSet();\r\n    for (int i = bitSet.nextSetBit(0); i >= 0; i = bitSet.nextSetBit(i + 1)) {\r\n        if (this.lookupLevel(i) == null || !(this.lookupLevel(i)).isCollapsed()) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.replace",
	"Comment": "convenience method for replacing a row in the database.inserts a new row if a row does not already exist.",
	"Method": "long replace(String table,String nullColumnHack,ContentValues initialValues){\r\n    try {\r\n        return insertWithOnConflict(table, nullColumnHack, initialValues, CONFLICT_REPLACE);\r\n    } catch (SQLException e) {\r\n        Log.e(TAG, \"Error inserting \" + initialValues, e);\r\n        return -1;\r\n    }\r\n}"
}, {
	"Path": "org.msgpack.core.MessagePacker.close",
	"Comment": "closes underlying output.this method flushes internal buffer before closing.",
	"Method": "void close(){\r\n    try {\r\n        flush();\r\n    } finally {\r\n        out.close();\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.samples.android.ClusterMapActivity.onOptionsItemSelected",
	"Comment": "onoptionsitemselected handlersince clustering need mapview to be created and visible,this sample do clustering here.",
	"Method": "boolean onOptionsItemSelected(MenuItem item){\r\n    super.onOptionsItemSelected(item);\r\n    switch(item.getItemId()) {\r\n        case 1234:\r\n            if (clusterer != null) {\r\n                break;\r\n            }\r\n            clusterer = new ClusterManager(mapView, getMarkerBitmap(), getZoomLevelMax(), false);\r\n            Toast toast = Toast.makeText(this, \"\", Toast.LENGTH_LONG);\r\n            ClusterManager.setToast(toast);\r\n            this.mapView.getModel().frameBufferModel.addObserver(clusterer);\r\n            for (int i = 0; i < geoItems.length; i++) {\r\n                clusterer.addItem(geoItems[i]);\r\n            }\r\n            clusterer.redraw();\r\n            displayItems.setEnabled(false);\r\n            displayMoreItems.setEnabled(true);\r\n            hideItems.setEnabled(true);\r\n            break;\r\n        case 5678:\r\n            setProgressBarIndeterminateVisibility(true);\r\n            Handler myHandler = new Handler() {\r\n                @Override\r\n                public void handleMessage(Message msg) {\r\n                    switch(msg.what) {\r\n                        case 0:\r\n                            addMarker();\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                }\r\n            };\r\n            new ManyDummyContent(myHandler);\r\n            item.setEnabled(false);\r\n            break;\r\n        case 9012:\r\n            if (clusterer != null) {\r\n                clusterer.destroyGeoClusterer();\r\n                this.mapView.getModel().frameBufferModel.removeObserver(clusterer);\r\n                clusterer = null;\r\n            }\r\n            displayItems.setEnabled(true);\r\n            displayMoreItems.setEnabled(false);\r\n            hideItems.setEnabled(false);\r\n            break;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.mapsforge.samples.android.ClusterMapActivity.onOptionsItemSelected",
	"Comment": "onoptionsitemselected handlersince clustering need mapview to be created and visible,this sample do clustering here.",
	"Method": "boolean onOptionsItemSelected(MenuItem item){\r\n    switch(msg.what) {\r\n        case 0:\r\n            addMarker();\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.RolapHierarchy.isRagged",
	"Comment": "a hierarchy is ragged if it contains one or more levels with hiddenmembers.",
	"Method": "boolean isRagged(){\r\n    for (Level level : levels) {\r\n        if (((RolapLevel) level).getHideMemberCondition() != RolapLevel.HideMemberCondition.Never) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "mondrian.test.TestContext.upgradeActual",
	"Comment": "massages the actual result of executing a query to handle differences inunique names betweeen old and new behavior.even though the new naming is not enabled by default, reference logsshould be in terms of the new naming.",
	"Method": "String upgradeActual(String actual){\r\n    if (!MondrianProperties.instance().SsasCompatibleNaming.get()) {\r\n        actual = Util.replace(actual, \"[Time.Weekly]\", \"[Time].[Weekly]\");\r\n        actual = Util.replace(actual, \"[All Time.Weeklys]\", \"[All Weeklys]\");\r\n        actual = Util.replace(actual, \"<HIERARCHY_NAME>Time.Weekly<\/HIERARCHY_NAME>\", \"<HIERARCHY_NAME>Weekly<\/HIERARCHY_NAME>\");\r\n        actual = Util.replace(actual, \"[Store.MyHierarchy]\", \"[Store].[MyHierarchy]\");\r\n        actual = Util.replace(actual, \"[All Store.MyHierarchys]\", \"[All MyHierarchys]\");\r\n        actual = Util.replace(actual, \"[Store2].[All Store2s]\", \"[Store2].[Store].[All Stores]\");\r\n        actual = Util.replace(actual, \"[Store Type 2.Store Type 2].[All Store Type 2.Store Type 2s]\", \"[Store Type 2].[All Store Type 2s]\");\r\n        actual = Util.replace(actual, \"[TIME.CALENDAR]\", \"[TIME].[CALENDAR]\");\r\n        actual = Util.replace(actual, \"<Store>true<\/Store>\", \"<Store>1<\/Store>\");\r\n        actual = Util.replace(actual, \"<Employees>80000.0000<\/Employees>\", \"<Employees>80000<\/Employees>\");\r\n    }\r\n    return actual;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Bdo.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Bdo appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.SqlTupleReader.generateSelectForLevels",
	"Comment": "generates the sql string corresponding to the levels referenced.",
	"Method": "Pair<String, List<SqlStatement.Type>> generateSelectForLevels(DataSource dataSource,RolapCube baseCube,WhichSelect whichSelect,List<TargetBase> targetGroup){\r\n    String s = \"while generating query to retrieve members of level(s) \" + targets;\r\n    SqlQuery sqlQuery = SqlQuery.newQuery(dataSource, s);\r\n    sqlQuery.setAllowHints(allowHints);\r\n    Evaluator evaluator = getEvaluator(constraint);\r\n    AggStar aggStar = chooseAggStar(constraint, evaluator, baseCube);\r\n    for (TargetBase target : targetGroup) {\r\n        if (target.getSrcMembers() == null) {\r\n            addLevelMemberSql(sqlQuery, target.getLevel(), baseCube, whichSelect, aggStar);\r\n        }\r\n    }\r\n    constraint.addConstraint(sqlQuery, baseCube, aggStar);\r\n    return sqlQuery.toSqlAndTypes();\r\n}"
}, {
	"Path": "com.meetup.memcached.MemcachedClient.loadMulti",
	"Comment": "this method loads the data from cache into a map.\tpass a sockio object which is ready to receive data and a hashmap\tto store the results.",
	"Method": "void loadMulti(LineInputStream input,Map<String, Object> hm,boolean asString){\r\n    while (true) {\r\n        String line = input.readLine();\r\n        if (log.isDebugEnabled())\r\n            log.debug(\"++++ line: \" + line);\r\n        if (line.startsWith(VALUE)) {\r\n            String[] info = line.split(\" \");\r\n            String key = info[1];\r\n            int flag = Integer.parseInt(info[2]);\r\n            int length = Integer.parseInt(info[3]);\r\n            if (log.isDebugEnabled()) {\r\n                log.debug(\"++++ key: \" + key);\r\n                log.debug(\"++++ flags: \" + flag);\r\n                log.debug(\"++++ length: \" + length);\r\n            }\r\n            byte[] buf = new byte[length];\r\n            input.read(buf);\r\n            input.clearEOL();\r\n            Object o;\r\n            if ((flag & F_COMPRESSED) == F_COMPRESSED) {\r\n                try {\r\n                    GZIPInputStream gzi = new GZIPInputStream(new ByteArrayInputStream(buf));\r\n                    ByteArrayOutputStream bos = new ByteArrayOutputStream(buf.length);\r\n                    int count;\r\n                    byte[] tmp = new byte[2048];\r\n                    while ((count = gzi.read(tmp)) != -1) {\r\n                        bos.write(tmp, 0, count);\r\n                    }\r\n                    buf = bos.toByteArray();\r\n                    gzi.close();\r\n                } catch (IOException e) {\r\n                    if (errorHandler != null)\r\n                        errorHandler.handleErrorOnGet(this, e, key);\r\n                    log.error(\"++++ IOException thrown while trying to uncompress input stream for key: \" + key + \" -- \" + e.getMessage());\r\n                    throw new NestedIOException(\"++++ IOException thrown while trying to uncompress input stream for key: \" + key, e);\r\n                }\r\n            }\r\n            if ((flag & F_SERIALIZED) != F_SERIALIZED) {\r\n                if (primitiveAsString || asString) {\r\n                    if (log.isInfoEnabled())\r\n                        log.info(\"++++ retrieving object and stuffing into a string.\");\r\n                    o = new String(buf, defaultEncoding);\r\n                } else {\r\n                    try {\r\n                        o = NativeHandler.decode(buf, flag);\r\n                    } catch (Exception e) {\r\n                        if (errorHandler != null)\r\n                            errorHandler.handleErrorOnGet(this, e, key);\r\n                        log.error(\"++++ Exception thrown while trying to deserialize for key: \" + key + \" -- \" + e.getMessage());\r\n                        throw new NestedIOException(e);\r\n                    }\r\n                }\r\n            } else {\r\n                ContextObjectInputStream ois = new ContextObjectInputStream(new ByteArrayInputStream(buf), classLoader);\r\n                try {\r\n                    o = ois.readObject();\r\n                    if (log.isInfoEnabled())\r\n                        log.info(\"++++ deserializing \" + o.getClass());\r\n                } catch (InvalidClassException e) {\r\n                    if (errorHandler != null)\r\n                        errorHandler.handleErrorOnGet(this, e, key);\r\n                    o = null;\r\n                    log.error(\"++++ InvalidClassException thrown while trying to deserialize for key: \" + key + \" -- \" + e.getMessage());\r\n                } catch (ClassNotFoundException e) {\r\n                    if (errorHandler != null)\r\n                        errorHandler.handleErrorOnGet(this, e, key);\r\n                    o = null;\r\n                    log.error(\"++++ ClassNotFoundException thrown while trying to deserialize for key: \" + key + \" -- \" + e.getMessage());\r\n                }\r\n            }\r\n            if (o != null)\r\n                hm.put(key, o);\r\n        } else if (END.equals(line)) {\r\n            if (log.isDebugEnabled())\r\n                log.debug(\"++++ finished reading from cache server\");\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.format.DefaultFormatterTest.testNumberFormatting",
	"Comment": "given that the value to format is a number.when the formatted value is requested, then the output should not containany unwanted decimal digits due to floating point representation,as well as scientific notations.",
	"Method": "void testNumberFormatting(){\r\n    for (Map.Entry<Object, String> entry : VALUES.entrySet()) {\r\n        String formatted = formatter.format(entry.getKey());\r\n        assertEquals(\"Value type: \" + entry.getKey().getClass().toString(), entry.getValue(), formatted);\r\n    }\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Address.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Address appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.test.UdfTest.testMemberUdfDoesNotEvaluateToScalar",
	"Comment": "tests a function that takes a member as argument. want to make sure thatmondrian leaves it as a member, does not try to evaluate it to a scalarvalue.",
	"Method": "void testMemberUdfDoesNotEvaluateToScalar(){\r\n    TestContext tc = udfTestContext(\"<UserDefinedFunction name=\\\"MemberName\\\" className=\\\"\" + MemberNameFunction.class.getName() + \"\\\"/>\\n\");\r\n    tc.assertExprReturns(\"MemberName([Gender].[F])\", \"F\");\r\n}"
}, {
	"Path": "org.mapsforge.map.rendertheme.rule.RenderTheme.matchClosedWay",
	"Comment": "matches a closed way with the given parameters against this rendertheme.",
	"Method": "void matchClosedWay(RenderCallback renderCallback,RenderContext renderContext,PolylineContainer way){\r\n    matchWay(renderCallback, renderContext, Closed.YES, way);\r\n}"
}, {
	"Path": "org.mapsforge.map.android.util.MapViewerTemplate.purgeTileCaches",
	"Comment": "hook to purge tile caches.by default we purge every tile cache that has been added to the tilecaches list.",
	"Method": "void purgeTileCaches(){\r\n    for (TileCache tileCache : tileCaches) {\r\n        tileCache.purge();\r\n    }\r\n    tileCaches.clear();\r\n}"
}, {
	"Path": "mondrian.test.ParentChildHierarchyTest.testParentChildDescendantsLeavesBottom",
	"Comment": "script that uses the leaves flag to return the bottom 10 dimensionmembers, from here.",
	"Method": "void testParentChildDescendantsLeavesBottom(){\r\n    assertQueryReturns(\"WITH SET [NonEmptyEmployees] AS 'FILTER(DESCENDANTS([Employees].[All Employees], 10, LEAVES),\\n\" + \"  NOT ISEMPTY([Measures].[Employee Salary]))'\\n\" + \"SELECT { [Measures].[Employee Salary], [Measures].[Number of Employees] } ON COLUMNS,\\n\" + \"  BOTTOMCOUNT([NonEmptyEmployees], 10, [Measures].[Employee Salary]) ON ROWS\\n\" + \"FROM HR\\n\" + \"WHERE ([Pay Type].[Hourly])\", \"Axis #0:\\n\" + \"{[Pay Type].[Hourly]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Employee Salary]}\\n\" + \"{[Measures].[Number of Employees]}\\n\" + \"Axis #2:\\n\" + \"{[Employees].[Sheri Nowmer].[Derrick Whelply].[Laurie Borges].[Eric Long].[Adam Reynolds].[William Hapke].[Marie Richmeier]}\\n\" + \"{[Employees].[Sheri Nowmer].[Derrick Whelply].[Pedro Castillo].[Jose Bernard].[Mary Hunt].[Bonnie Bruno].[Ellen Gray]}\\n\" + \"{[Employees].[Sheri Nowmer].[Derrick Whelply].[Laurie Borges].[Paula Nickell].[Kristine Cleary].[Carla Zubaty].[Hattie Haemon]}\\n\" + \"{[Employees].[Sheri Nowmer].[Derrick Whelply].[Pedro Castillo].[Lois Wood].[Dell Gras].[Christopher Solano].[Sarah Amole]}\\n\" + \"{[Employees].[Sheri Nowmer].[Derrick Whelply].[Pedro Castillo].[Charles Macaluso].[Barbara Wallin].[Kenneth Turner].[Shirley Head]}\\n\" + \"{[Employees].[Sheri Nowmer].[Derrick Whelply].[Pedro Castillo].[Lois Wood].[Dell Gras].[Christopher Solano].[Mary Hall]}\\n\" + \"{[Employees].[Sheri Nowmer].[Derrick Whelply].[Pedro Castillo].[Lin Conley].[Paul Tays].[Pat Chin].[Yasmina Brown]}\\n\" + \"{[Employees].[Sheri Nowmer].[Derrick Whelply].[Laurie Borges].[Eric Long].[Adam Reynolds].[Joshua Huff].[Teanna Cobb]}\\n\" + \"{[Employees].[Sheri Nowmer].[Derrick Whelply].[Pedro Castillo].[Lois Wood].[Dell Gras].[Kristine Aldred].[Kenton Forham]}\\n\" + \"{[Employees].[Sheri Nowmer].[Derrick Whelply].[Laurie Borges].[Mary Solimena].[Matthew Hunter].[Eddie Holmes].[Donald Thompson]}\\n\" + \"Row #0: $39.44\\n\" + \"Row #0: 1\\n\" + \"Row #1: $39.52\\n\" + \"Row #1: 1\\n\" + \"Row #2: $39.52\\n\" + \"Row #2: 1\\n\" + \"Row #3: $39.60\\n\" + \"Row #3: 1\\n\" + \"Row #4: $39.62\\n\" + \"Row #4: 1\\n\" + \"Row #5: $39.62\\n\" + \"Row #5: 1\\n\" + \"Row #6: $39.66\\n\" + \"Row #6: 1\\n\" + \"Row #7: $39.67\\n\" + \"Row #7: 1\\n\" + \"Row #8: $39.75\\n\" + \"Row #8: 1\\n\" + \"Row #9: $39.75\\n\" + \"Row #9: 1\\n\");\r\n}"
}, {
	"Path": "org.mapsforge.map.reader.ReadBuffer.readUnsignedInt",
	"Comment": "converts a variable amount of bytes from the read buffer to an unsigned int.the first bit is for continuation info, the other seven bits are for data.",
	"Method": "int readUnsignedInt(){\r\n    int variableByteDecode = 0;\r\n    byte variableByteShift = 0;\r\n    while ((this.bufferData[this.bufferPosition] & 0x80) != 0) {\r\n        variableByteDecode |= (this.bufferData[this.bufferPosition++] & 0x7f) << variableByteShift;\r\n        variableByteShift += 7;\r\n    }\r\n    return variableByteDecode | (this.bufferData[this.bufferPosition++] << variableByteShift);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Li.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Li appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "com.meetup.memcached.MemcachedClient.init",
	"Comment": "initializes client object to defaults.\tthis enables compression and sets compression threshhold to 15 kb.",
	"Method": "void init(){\r\n    this.sanitizeKeys = true;\r\n    this.primitiveAsString = false;\r\n    this.compressEnable = true;\r\n    this.compressThreshold = COMPRESS_THRESH;\r\n    this.defaultEncoding = \"UTF-8\";\r\n    this.poolName = (this.poolName == null) ? \"default\" : this.poolName;\r\n    this.pool = SockIOPool.getInstance(poolName);\r\n}"
}, {
	"Path": "mondrian.tui.MockServletContext.setAttribute",
	"Comment": "binds an object to a given attribute name in this servlet context.",
	"Method": "void setAttribute(String s,Object obj){\r\n    if (this.attributes == Collections.EMPTY_MAP) {\r\n        this.attributes = new HashMap<String, Object>();\r\n    }\r\n    this.attributes.put(s, obj);\r\n}"
}, {
	"Path": "org.mapsforge.poi.storage.DoubleLinkedPoiCategory.getGraphVizString",
	"Comment": "generates a graphviz source representation as a tree having the current node as its root.",
	"Method": "String getGraphVizString(DoubleLinkedPoiCategory rootNode){\r\n    StringBuilder sb = new StringBuilder();\r\n    Stack<PoiCategory> stack = new Stack();\r\n    stack.push(rootNode);\r\n    DoubleLinkedPoiCategory currentNode;\r\n    sb.append(\"// dot test.dot -Tpng > test.png\\r\\n\");\r\n    sb.append(\"digraph Categories {\\r\\n\");\r\n    sb.append(\"  graph [\\r\\nrankdir = \\\"LR\\\"\\r\\n]\\r\\n\\r\\nnode [\\r\\nshape = \\\"plaintext\\\"\\r\\n]\");\r\n    while (!stack.isEmpty()) {\r\n        currentNode = (DoubleLinkedPoiCategory) stack.pop();\r\n        for (PoiCategory childNode : currentNode.childCategories) {\r\n            stack.push(childNode);\r\n            sb.append(\"\\t\\\"\").append(currentNode.getTitle()).append(\" (\").append(currentNode.getID()).append(\")\").append(\"\\\" -> \\\"\").append(childNode.getTitle()).append(\" (\").append(childNode.getID()).append(\")\").append(\"\\\"\\r\\n\");\r\n        }\r\n    }\r\n    sb.append(\"}\\r\\n\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "mondrian.test.ParameterTest.testConnectionPropsWhichShouldBeNull",
	"Comment": "tests that certain connection properties which should be null, are.",
	"Method": "void testConnectionPropsWhichShouldBeNull(){\r\n    assertExprReturns(\"ParamRef(\\\"JdbcPassword\\\")\", \"\");\r\n    assertExprReturns(\"ParamRef(\\\"CatalogContent\\\")\", \"\");\r\n}"
}, {
	"Path": "mondrian.xmla.XmlaHandler.getConnection",
	"Comment": "returns a new olapconnection opened with the credentials specified in thexmla request or an existing connection if one can be found associatedwith the request session id.",
	"Method": "OlapConnection getConnection(XmlaRequest request,Map<String, String> propMap,OlapConnection getConnection,String catalog,String schema,String role,OlapConnection getConnection,String catalog,String schema,String role,Properties props,OlapConnection getConnection,String catalog,String schema,String roleName,Properties props){\r\n    try {\r\n        return connectionFactory.getConnection(catalog, schema, role, props);\r\n    } catch (SecurityException e) {\r\n        throw new XmlaException(CLIENT_FAULT_FC, HSB_ACCESS_DENIED_CODE, HSB_ACCESS_DENIED_FAULT_FS, e);\r\n    } catch (SQLException e) {\r\n        throw new XmlaException(CLIENT_FAULT_FC, HSB_CONNECTION_DATA_SOURCE_CODE, HSB_CONNECTION_DATA_SOURCE_FAULT_FS, e);\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.RolapEvaluator.exists",
	"Comment": "returns whether a member of the hierarchy with a given ordinal has beenpreserved on the stack since the last savepoint.",
	"Method": "boolean exists(int ordinal){\r\n    for (int i = commandCount - 1; ; ) {\r\n        final Command command = (Command) commands[i];\r\n        switch(command) {\r\n            case SAVEPOINT:\r\n                return false;\r\n            case SET_CONTEXT:\r\n                final Integer memberOrdinal = (Integer) commands[i - 1];\r\n                if (ordinal == memberOrdinal) {\r\n                    return true;\r\n                }\r\n                break;\r\n        }\r\n        i -= command.width;\r\n    }\r\n}"
}, {
	"Path": "mondrian.olap.EnumeratedValues.getNames",
	"Comment": "returns the names in this enumeration, in declaration order.",
	"Method": "String[] getNames(){\r\n    return valuesByName.keySet().toArray(emptyStringArray);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Comment.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Comment appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.dumpAll",
	"Comment": "dump detailed information about all open databases in the current process.used by bug report.",
	"Method": "void dumpAll(Printer printer,boolean verbose){\r\n    for (SQLiteDatabase db : getActiveDatabases()) {\r\n        db.dump(printer, verbose);\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.poi.storage.PoiCategoryManagerTest.init",
	"Comment": "creates a simple category tree and adds it to a mock category manager.",
	"Method": "void init(){\r\n    this.root = new DoubleLinkedPoiCategory(\"root\", null);\r\n    this.restaurants = new DoubleLinkedPoiCategory(\"restaurants\", this.root);\r\n    this.shops = new DoubleLinkedPoiCategory(\"shops\", this.root);\r\n    this.fastFood = new DoubleLinkedPoiCategory(\"fastFood\", this.restaurants);\r\n    this.bars = new DoubleLinkedPoiCategory(\"bars\", this.restaurants);\r\n    this.electronics = new DoubleLinkedPoiCategory(\"electronics\", this.shops);\r\n    this.clothes = new DoubleLinkedPoiCategory(\"clothes\", this.shops);\r\n    DoubleLinkedPoiCategory.calculateCategoryIDs((DoubleLinkedPoiCategory) this.root, 0);\r\n    this.cm = new MockPoiCategoryManager(this.root);\r\n}"
}, {
	"Path": "mondrian.calc.impl.ConstantCalc.constantHierarchy",
	"Comment": "creates an expression which evaluates to a given hierarchy.",
	"Method": "Calc constantHierarchy(Hierarchy hierarchy){\r\n    return new ConstantCalc(HierarchyType.forHierarchy(hierarchy), hierarchy);\r\n}"
}, {
	"Path": "mondrian.tui.CmdRunner.getConnection",
	"Comment": "gets a mondrian connection, creating a new one if fresh is true.",
	"Method": "Connection getConnection(Connection getConnection,boolean fresh){\r\n    if (this.connectString == null) {\r\n        makeConnectString();\r\n    }\r\n    if (this.connection == null) {\r\n        this.connection = DriverManager.getConnection(this.connectString, null);\r\n    }\r\n    return this.connection;\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getUserPrincipal",
	"Comment": "returns a java.security.principal object containing the name of the current authenticated user.",
	"Method": "Principal getUserPrincipal(){\r\n    return principal;\r\n}"
}, {
	"Path": "org.mapsforge.core.util.LatLongUtils.sphericalDistance",
	"Comment": "calculate the spherical distance between two latlongs in meters using the haversineformula.this calculation is done using the assumption, that the earth is a sphere, it is notthough. if you need a higher precision and can afford a longer execution time you mightwant to use vincentydistance.",
	"Method": "double sphericalDistance(LatLong latLong1,LatLong latLong2){\r\n    double dLat = Math.toRadians(latLong2.latitude - latLong1.latitude);\r\n    double dLon = Math.toRadians(latLong2.longitude - latLong1.longitude);\r\n    double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(Math.toRadians(latLong1.latitude)) * Math.cos(Math.toRadians(latLong2.latitude)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\r\n    double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    return c * LatLongUtils.EQUATORIAL_RADIUS;\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testExpandTupleInputs1",
	"Comment": "verify that native evaluation is turned off for tuple inputs, even ifexpandnonnative is set.",
	"Method": "void testExpandTupleInputs1(){\r\n    propSaver.set(MondrianProperties.instance().ExpandNonNative, true);\r\n    checkNotNative(1, \"with \" + \"set [Tuple Set] as {([Store Type].[All Store Types].[HeadQuarters], [Product].[All Products].[Drink]), ([Store Type].[All Store Types].[Supermarket], [Product].[All Products].[Food])} \" + \"set [Filtered Tuple Set] as Filter([Tuple Set], 1=1) \" + \"set [NECJ] as NonEmptyCrossJoin([Store].Children, [Filtered Tuple Set]) \" + \"select [NECJ] on columns from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Store].[USA], [Store Type].[Supermarket], [Product].[Food]}\\n\" + \"Row #0: 108,188\\n\");\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentCacheManager.remove",
	"Comment": "removes a segment from segment index.call is asynchronous. it comes back immediately.does not remove it from the external cache.",
	"Method": "void remove(RolapStar star,SegmentHeader header,boolean remove,SegmentHeader header){\r\n    final Locus locus = Locus.peek();\r\n    ACTOR.event(handler, new SegmentRemoveEvent(System.currentTimeMillis(), locus.getServer().getMonitor(), locus.getServer().getId(), locus.execution.getMondrianStatement().getMondrianConnection().getId(), locus.execution.getMondrianStatement().getId(), locus.execution.getId(), this, star, header));\r\n}"
}, {
	"Path": "mondrian.tui.MockServletContext.getRealPath",
	"Comment": "returns a string containing the real path for a given virtual path.",
	"Method": "String getRealPath(String path){\r\n    return path;\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testExpandTupleInputs2",
	"Comment": "verify that native evaluation is turned off for tuple inputs, even ifexpandnonnative is set.",
	"Method": "void testExpandTupleInputs2(){\r\n    propSaver.set(MondrianProperties.instance().ExpandNonNative, true);\r\n    checkNotNative(1, \"with \" + \"set [Tuple Set] as {([Store Type].[All Store Types].[HeadQuarters], [Product].[All Products].[Drink]), ([Store Type].[All Store Types].[Supermarket], [Product].[All Products].[Food])} \" + \"set [Filtered Tuple Set] as Filter([Tuple Set], 1=1) \" + \"set [NECJ] as NonEmptyCrossJoin([Filtered Tuple Set], [Store].Children) \" + \"select [NECJ] on columns from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Store Type].[Supermarket], [Product].[Food], [Store].[USA]}\\n\" + \"Row #0: 108,188\\n\");\r\n}"
}, {
	"Path": "mondrian.rolap.RolapResult.removeUnaryMembersFromTupleList",
	"Comment": "this function removes single instance members from the compound slicer,enabling more regular slicer behavior for those members. for instance,calculated members can override the context of these members correctly.",
	"Method": "TupleList removeUnaryMembersFromTupleList(TupleList tupleList,RolapEvaluator evaluator){\r\n    List<Member> first = null;\r\n    boolean[] unary = null;\r\n    for (List<Member> tuple : tupleList) {\r\n        if (first == null) {\r\n            first = tuple;\r\n            unary = new boolean[tuple.size()];\r\n            for (int i = 0; i < unary.length; i++) {\r\n                unary[i] = true;\r\n            }\r\n        } else {\r\n            for (int i = 0; i < tuple.size(); i++) {\r\n                if (unary[i] && !tuple.get(i).equals(first.get(i))) {\r\n                    unary[i] = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    int toRemove = 0;\r\n    for (int i = 0; i < unary.length; i++) {\r\n        if (unary[i]) {\r\n            evaluator.setContext(first.get(i));\r\n            toRemove++;\r\n        }\r\n    }\r\n    if (toRemove > 0) {\r\n        TupleList newList = new ListTupleList(tupleList.getArity() - toRemove, new ArrayList<Member>());\r\n        for (List<Member> tuple : tupleList) {\r\n            List<Member> ntuple = new ArrayList<Member>();\r\n            for (int i = 0; i < tuple.size(); i++) {\r\n                if (!unary[i]) {\r\n                    ntuple.add(tuple.get(i));\r\n                }\r\n            }\r\n            newList.add(ntuple);\r\n        }\r\n        tupleList = newList;\r\n    }\r\n    return tupleList;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Strike.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Strike appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getContentType",
	"Comment": "returns the mime type of the body of the request, or null if the type isnot known.",
	"Method": "String getContentType(){\r\n    return getHeader(\"Content-Type\");\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.setPageSize",
	"Comment": "sets the database page size. the page size must be a power of two. thismethod does not work if any data has been written to the database file,and must be called right after the database has been created.",
	"Method": "void setPageSize(long numBytes){\r\n    execSQL(\"PRAGMA page_size = \" + numBytes);\r\n}"
}, {
	"Path": "org.sqlite.database.DatabaseUtils.cursorRowToContentValues",
	"Comment": "read the entire contents of a cursor row and store them in a contentvalues.",
	"Method": "void cursorRowToContentValues(Cursor cursor,ContentValues values){\r\n    String[] columns = cursor.getColumnNames();\r\n    int length = columns.length;\r\n    for (int i = 0; i < length; i++) {\r\n        if (cursor.getType(i) == Cursor.FIELD_TYPE_BLOB) {\r\n            values.put(columns[i], cursor.getBlob(i));\r\n        } else {\r\n            values.put(columns[i], cursor.getString(i));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteSession.hasConnection",
	"Comment": "returns true if the session has an active database connection.",
	"Method": "boolean hasConnection(){\r\n    return mConnection != null;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Object.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Object appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteConnection.collectDbStatsUnsafe",
	"Comment": "collects statistics about database connection memory usage, in the case where thecaller might not actually own the connection.",
	"Method": "void collectDbStatsUnsafe(ArrayList<DbStats> dbStatsList){\r\n    dbStatsList.add(getMainDbStatsUnsafe(0, 0, 0));\r\n}"
}, {
	"Path": "mondrian.test.TestContext.assertQueryThrows",
	"Comment": "executes a query, and asserts that it throws an exception which containsthe given pattern.",
	"Method": "void assertQueryThrows(String queryString,String pattern){\r\n    Throwable throwable;\r\n    try {\r\n        Result result = executeQuery(queryString);\r\n        Util.discard(result);\r\n        throwable = null;\r\n    } catch (Throwable e) {\r\n        throwable = e;\r\n    }\r\n    checkThrowable(throwable, pattern);\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.evaluateTuples",
	"Comment": "for each tuple in a list, evaluates an expression and creates a mapfrom tuples to values.",
	"Method": "Map<List<Member>, Object> evaluateTuples(Evaluator evaluator,Calc exp,TupleList tuples){\r\n    final int savepoint = evaluator.savepoint();\r\n    try {\r\n        assert exp.getType() instanceof ScalarType;\r\n        final Map<List<Member>, Object> mapMemberToValue = new HashMap<List<Member>, Object>();\r\n        for (int i = 0, count = tuples.size(); i < count; i++) {\r\n            List<Member> tuple = tuples.get(i);\r\n            evaluator.setContext(tuple);\r\n            Object result = exp.evaluate(evaluator);\r\n            if (result == null) {\r\n                result = Util.nullValue;\r\n            }\r\n            mapMemberToValue.put(tuple, result);\r\n        }\r\n        return mapMemberToValue;\r\n    } finally {\r\n        evaluator.restore(savepoint);\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.loader.DBLoader.columnValue",
	"Comment": "convert the columns value to a string based upon its column type.",
	"Method": "String columnValue(Column column,Object value){\r\n    Type type = column.getType();\r\n    String typeName = type.getName();\r\n    if (value == null) {\r\n        return \"NULL\";\r\n    } else if ((value instanceof String) && (((String) value).length() == 0)) {\r\n        return \"NULL\";\r\n    }\r\n    if (type == Type.Integer) {\r\n        if (value instanceof String) {\r\n            return (String) value;\r\n        } else if (value instanceof Double) {\r\n            Double result = (Double) value;\r\n            return integerFormatter.format(result.doubleValue());\r\n        } else if (value instanceof Integer) {\r\n            Integer result = (Integer) value;\r\n            return result.toString();\r\n        }\r\n    } else if (type == Type.Smallint) {\r\n        if (value instanceof String) {\r\n            return (String) value;\r\n        } else if (value instanceof Boolean) {\r\n            return (Boolean) value ? \"1\" : \"0\";\r\n        } else if (value instanceof Integer) {\r\n            Integer result = (Integer) value;\r\n            return result.toString();\r\n        }\r\n    } else if (type == Type.Bigint) {\r\n        if (value instanceof String) {\r\n            return (String) value;\r\n        } else if (value instanceof Double) {\r\n            Double result = (Double) value;\r\n            return integerFormatter.format(result.doubleValue());\r\n        } else if (value instanceof Long) {\r\n            Long result = (Long) value;\r\n            return result.toString();\r\n        }\r\n    } else if ((type == Type.Varchar30) || (type == Type.Varchar255) || (type == Type.Varchar60) || typeName.startsWith(\"VARCHAR(\")) {\r\n        if (value instanceof String) {\r\n            return embedQuotes((String) value);\r\n        }\r\n    } else if (type == Type.Timestamp) {\r\n        if (value instanceof String) {\r\n            Timestamp ts = Timestamp.valueOf((String) value);\r\n            switch(dialect.getDatabaseProduct()) {\r\n                case ORACLE:\r\n                case LUCIDDB:\r\n                    return \"TIMESTAMP '\" + ts + \"'\";\r\n                default:\r\n                    return \"'\" + ts + \"'\";\r\n            }\r\n        } else if (value instanceof Timestamp) {\r\n            Timestamp ts = (Timestamp) value;\r\n            switch(dialect.getDatabaseProduct()) {\r\n                case ORACLE:\r\n                case LUCIDDB:\r\n                    return \"TIMESTAMP '\" + ts + \"'\";\r\n                default:\r\n                    return \"'\" + ts + \"'\";\r\n            }\r\n        }\r\n    } else if (type == Type.Date) {\r\n        if (value instanceof String) {\r\n            Date dt = Date.valueOf((String) value);\r\n            switch(dialect.getDatabaseProduct()) {\r\n                case ORACLE:\r\n                case LUCIDDB:\r\n                    return \"DATE '\" + dateFormatter.format(dt) + \"'\";\r\n                default:\r\n                    return \"'\" + dateFormatter.format(dt) + \"'\";\r\n            }\r\n        } else if (value instanceof Date) {\r\n            Date dt = (Date) value;\r\n            switch(dialect.getDatabaseProduct()) {\r\n                case ORACLE:\r\n                case LUCIDDB:\r\n                    return \"DATE '\" + dateFormatter.format(dt) + \"'\";\r\n                default:\r\n                    return \"'\" + dateFormatter.format(dt) + \"'\";\r\n            }\r\n        }\r\n    } else if (type == Type.Real) {\r\n        if (value instanceof String) {\r\n            return (String) value;\r\n        } else if (value instanceof Float) {\r\n            Float result = (Float) value;\r\n            return result.toString();\r\n        }\r\n    } else if ((type == Type.Decimal) || typeName.startsWith(\"DECIMAL(\")) {\r\n        if (value instanceof String) {\r\n            return (String) value;\r\n        } else {\r\n            Matcher matcher = decimalDataTypeRegex.matcher(typeName);\r\n            if (!matcher.matches()) {\r\n                throw new RuntimeException(\"Bad DECIMAL column type for \" + typeName);\r\n            }\r\n            DecimalFormat formatter = new DecimalFormat(decimalFormat(matcher.group(1), matcher.group(2)));\r\n            if (value instanceof Double) {\r\n                Double result = (Double) value;\r\n                return formatter.format(result.doubleValue());\r\n            } else if (value instanceof BigDecimal) {\r\n                BigDecimal result = (BigDecimal) value;\r\n                return formatter.format(result);\r\n            }\r\n        }\r\n    } else if (type == Type.Boolean) {\r\n        if (value instanceof String) {\r\n            String trimmedValue = ((String) value).trim();\r\n            switch(dialect.getDatabaseProduct()) {\r\n                case MARIADB:\r\n                case MYSQL:\r\n                case ORACLE:\r\n                case DB2:\r\n                case DB2_AS400:\r\n                case DB2_OLD_AS400:\r\n                case FIREBIRD:\r\n                case MSSQL:\r\n                case DERBY:\r\n                case INGRES:\r\n                    if (trimmedValue.equals(\"true\")) {\r\n                        return \"1\";\r\n                    } else if (trimmedValue.equals(\"false\")) {\r\n                        return \"0\";\r\n                    } else if (trimmedValue.equals(\"1\")) {\r\n                        return \"1\";\r\n                    } else if (trimmedValue.equals(\"0\")) {\r\n                        return \"0\";\r\n                    }\r\n                default:\r\n                    if (trimmedValue.equals(\"1\")) {\r\n                        return \"true\";\r\n                    } else if (trimmedValue.equals(\"0\")) {\r\n                        return \"false\";\r\n                    }\r\n            }\r\n        } else if (value instanceof Boolean) {\r\n            Boolean result = (Boolean) value;\r\n            return result.toString();\r\n        }\r\n    }\r\n    throw new RuntimeException(\"Unknown column type: \" + typeName + \" for column: \" + column.getName());\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.setMaxConn",
	"Comment": "sets the maximum number of spare connections allowed in our available pool.",
	"Method": "void setMaxConn(int maxConn){\r\n    this.maxConn = maxConn;\r\n}"
}, {
	"Path": "org.mapsforge.poi.storage.PoiCategoryRangeQueryGenerator.getSQLWhereClauseString",
	"Comment": "gets the where clause for the sql query that looks up poi entries.",
	"Method": "String getSQLWhereClauseString(PoiCategoryFilter filter,int version){\r\n    Collection<PoiCategory> superCategories = filter.getAcceptedSuperCategories();\r\n    if (superCategories.isEmpty()) {\r\n        return \"\";\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\" AND (\");\r\n    for (Iterator<PoiCategory> superCatIter = superCategories.iterator(); superCatIter.hasNext(); ) {\r\n        PoiCategory superCat = superCatIter.next();\r\n        Collection<PoiCategory> categories = superCat.deepChildren();\r\n        categories.add(superCat);\r\n        if (version < 2) {\r\n            sb.append(DbConstants.FIND_IN_BOX_CLAUSE_WHERE_CATEGORY_IN_V1);\r\n        } else {\r\n            sb.append(DbConstants.FIND_IN_BOX_CLAUSE_WHERE_CATEGORY_IN);\r\n        }\r\n        for (Iterator<PoiCategory> catIter = categories.iterator(); catIter.hasNext(); ) {\r\n            PoiCategory cat = catIter.next();\r\n            sb.append(cat.getID());\r\n            if (catIter.hasNext()) {\r\n                sb.append(\", \");\r\n            }\r\n        }\r\n        sb.append(\")\");\r\n        if (superCatIter.hasNext()) {\r\n            sb.append(\" OR \");\r\n        }\r\n    }\r\n    sb.append(\")\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "mondrian.rolap.RolapNativeSql.saveStoredMeasure",
	"Comment": "we remember one of the measures so we can generatethe constraints from rolapaggregationmanager. alsomake sure all measures live in the same star.",
	"Method": "boolean saveStoredMeasure(RolapStoredMeasure m){\r\n    if (aggStar != null && !storedMeasureIsPresentOnAggStar(m)) {\r\n        return false;\r\n    }\r\n    if (storedMeasure != null) {\r\n        RolapStar star1 = getStar(storedMeasure);\r\n        RolapStar star2 = getStar(m);\r\n        if (star1 != star2) {\r\n            return false;\r\n        }\r\n    }\r\n    this.storedMeasure = m;\r\n    return true;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Dir.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Dir appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.test.AccessControlTest.testRollupPolicyNegative",
	"Comment": "tests that a bad value for the rolluppolicy attribute gives theappropriate error.",
	"Method": "void testRollupPolicyNegative(){\r\n    final TestContext testContext = TestContext.instance().create(null, null, null, null, null, \"<Role name=\\\"Role1\\\">\\n\" + \"  <SchemaGrant access=\\\"none\\\">\\n\" + \"    <CubeGrant cube=\\\"Sales\\\" access=\\\"all\\\">\\n\" + \"      <HierarchyGrant hierarchy=\\\"[Customers]\\\" access=\\\"custom\\\" rollupPolicy=\\\"bad\\\" bottomLevel=\\\"[Customers].[City]\\\">\\n\" + \"        <MemberGrant member=\\\"[Customers].[USA]\\\" access=\\\"all\\\"/>\\n\" + \"        <MemberGrant member=\\\"[Customers].[USA].[CA].[Los Angeles]\\\" access=\\\"none\\\"/>\\n\" + \"      <\/HierarchyGrant>\\n\" + \"    <\/CubeGrant>\\n\" + \"  <\/SchemaGrant>\\n\" + \"<\/Role>\").withRole(\"Role1\");\r\n    testContext.assertQueryThrows(\"select from [Sales]\", \"Illegal rollupPolicy value 'bad'\");\r\n}"
}, {
	"Path": "mondrian.gui.JdbcMetaData.getAllDbColumns",
	"Comment": "returns all columns of given table in schema.column string is formatted.",
	"Method": "List<DbColumn> getAllDbColumns(String schemaName,String tableName,List<DbColumn> getAllDbColumns,String sname,String tableName){\r\n    List<DbColumn> allcols = new ArrayList<DbColumn>();\r\n    if (tableName == null) {\r\n        List<String> allTables = getAllTables(schemaName);\r\n        for (int i = 0; i < allTables.size(); i++) {\r\n            String tab = allTables.get(i);\r\n            List<DbColumn> cols;\r\n            if (tab.indexOf(LEVEL_SEPARATOR) == -1) {\r\n                cols = getAllDbColumns(schemaName, tab);\r\n            } else {\r\n                String[] names = tab.split(LEVEL_SEPARATOR);\r\n                cols = getAllDbColumns(names[0], names[1]);\r\n            }\r\n            allcols.addAll(cols);\r\n        }\r\n        return allcols;\r\n    } else {\r\n        if (!db.hasColumns(schemaName, tableName)) {\r\n            setColumns(schemaName, tableName);\r\n        }\r\n        return db.getAllDbColumns(schemaName, tableName);\r\n    }\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Cite.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Cite appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.DrawerActivity.hasOnProfileClickListener",
	"Comment": "gets whether the drawer has a profile click listener set to it",
	"Method": "boolean hasOnProfileClickListener(){\r\n    return mDrawer.hasOnProfileClickListener();\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.AggTableManager.finalCleanUp",
	"Comment": "this should only be called if the aggtablemanager is no longer goingto be used. in fact, it should only be called indirectly by itsassociated rolapschema object.",
	"Method": "void finalCleanUp(){\r\n    removeJdbcSchema();\r\n    if (getLogger().isDebugEnabled()) {\r\n        getLogger().debug(\"AggTableManager.finalCleanUp: schema=\" + schema.getName());\r\n    }\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.DrawerView.hasOnItemClickListener",
	"Comment": "gets whether the drawer view has an item click listener set to it",
	"Method": "boolean hasOnItemClickListener(){\r\n    return mOnItemClickListener != null;\r\n}"
}, {
	"Path": "mondrian.rolap.SqlConstraintUtils.constrainMultiLevelMembers",
	"Comment": "adds to the where clause of a query expression matching a specifiedlist of members",
	"Method": "String constrainMultiLevelMembers(SqlQuery sqlQuery,RolapCube baseCube,AggStar aggStar,List<RolapMember> members,RolapLevel fromLevel,boolean restrictMemberTypes,boolean exclude){\r\n    Map<RolapMember, List<RolapMember>> parentChildrenMap = new LinkedHashMap<RolapMember, List<RolapMember>>();\r\n    StringBuilder condition = new StringBuilder();\r\n    StringBuilder condition1 = new StringBuilder();\r\n    if (exclude) {\r\n        condition.append(\"not (\");\r\n    }\r\n    if (sqlQuery.getDialect().supportsMultiValueInExpr()) {\r\n        condition1.append(generateMultiValueInExpr(sqlQuery, baseCube, aggStar, members, fromLevel, restrictMemberTypes, parentChildrenMap));\r\n        if (parentChildrenMap.isEmpty()) {\r\n            condition.append(condition1.toString());\r\n            if (exclude) {\r\n                condition.append(\")\");\r\n                condition.append(\" or \");\r\n                condition.append(generateMultiValueIsNullExprs(sqlQuery, baseCube, members.get(0), fromLevel, aggStar));\r\n            }\r\n            return condition.toString();\r\n        }\r\n    } else {\r\n        for (RolapMember m : members) {\r\n            if (m.isCalculated()) {\r\n                if (restrictMemberTypes) {\r\n                    throw Util.newInternal(\"addMemberConstraint: cannot \" + \"restrict SQL to calculated member :\" + m);\r\n                }\r\n                continue;\r\n            }\r\n            RolapMember p = m.getParentMember();\r\n            List<RolapMember> childrenList = parentChildrenMap.get(p);\r\n            if (childrenList == null) {\r\n                childrenList = new ArrayList<RolapMember>();\r\n                parentChildrenMap.put(p, childrenList);\r\n            }\r\n            childrenList.add(m);\r\n        }\r\n    }\r\n    boolean firstParent = true;\r\n    StringBuilder condition2 = new StringBuilder();\r\n    if (condition1.length() > 0) {\r\n        firstParent = false;\r\n        condition.append(condition1.toString());\r\n        condition.append(\" or \");\r\n    }\r\n    RolapLevel memberLevel = members.get(0).getLevel();\r\n    for (RolapMember p : parentChildrenMap.keySet()) {\r\n        assert p != null;\r\n        if (condition2.toString().length() > 0) {\r\n            condition2.append(\" or \");\r\n        }\r\n        condition2.append(\"(\");\r\n        int levelCount = 0;\r\n        for (RolapMember gp = p; gp != null; gp = gp.getParentMember()) {\r\n            if (gp.isAll()) {\r\n                continue;\r\n            }\r\n            RolapLevel level = gp.getLevel();\r\n            if (firstParent) {\r\n                RolapHierarchy hierarchy = level.getHierarchy();\r\n                RolapStar.Column column = null;\r\n                if (level instanceof RolapCubeLevel) {\r\n                    column = ((RolapCubeLevel) level).getBaseStarKeyColumn(baseCube);\r\n                }\r\n                if (column != null) {\r\n                    if (aggStar != null) {\r\n                        int bitPos = column.getBitPosition();\r\n                        AggStar.Table.Column aggColumn = aggStar.lookupColumn(bitPos);\r\n                        AggStar.Table table = aggColumn.getTable();\r\n                        table.addToFrom(sqlQuery, false, true);\r\n                    } else {\r\n                        RolapStar.Table targetTable = column.getTable();\r\n                        hierarchy.addToFrom(sqlQuery, targetTable);\r\n                    }\r\n                } else {\r\n                    assert (aggStar == null);\r\n                    hierarchy.addToFrom(sqlQuery, level.getKeyExp());\r\n                }\r\n            }\r\n            if (levelCount > 0) {\r\n                condition2.append(\" and \");\r\n            }\r\n            ++levelCount;\r\n            condition2.append(constrainLevel(level, sqlQuery, baseCube, aggStar, getColumnValue(level.nameExp != null ? gp.getName() : gp.getKey(), sqlQuery.getDialect(), level.getDatatype()), false));\r\n            if (gp.getLevel() == fromLevel) {\r\n                break;\r\n            }\r\n        }\r\n        firstParent = false;\r\n        List<RolapMember> children = parentChildrenMap.get(p);\r\n        if (!children.isEmpty()) {\r\n            Map<RolapMember, List<RolapMember>> tmpParentChildrenMap = new HashMap<RolapMember, List<RolapMember>>();\r\n            if (levelCount > 0) {\r\n                condition2.append(\" and \");\r\n            }\r\n            RolapLevel childrenLevel = (RolapLevel) (p.getLevel().getChildLevel());\r\n            if (sqlQuery.getDialect().supportsMultiValueInExpr() && childrenLevel != memberLevel) {\r\n                condition2.append(generateMultiValueInExpr(sqlQuery, baseCube, aggStar, children, childrenLevel, restrictMemberTypes, tmpParentChildrenMap));\r\n                assert tmpParentChildrenMap.isEmpty();\r\n            } else {\r\n                assert childrenLevel == memberLevel;\r\n                condition2.append(generateSingleValueInExpr(sqlQuery, baseCube, aggStar, children, childrenLevel, restrictMemberTypes, false, true));\r\n            }\r\n        }\r\n        condition2.append(\")\");\r\n    }\r\n    condition.append(condition2.toString());\r\n    if (exclude) {\r\n        condition.append(\") or (\");\r\n        condition.append(generateMultiValueIsNullExprs(sqlQuery, baseCube, members.get(0), fromLevel, aggStar));\r\n        condition.append(\" and not(\");\r\n        condition.append(condition2.toString());\r\n        condition.append(\"))\");\r\n    }\r\n    return condition.toString();\r\n}"
}, {
	"Path": "mondrian.util.Composite.of",
	"Comment": "creates a composite list, inferring the element type from the arguments.",
	"Method": "List<T> of(List<? extends T> lists,Iterable<T> of,Iterable<? extends T> iterables,Iterator<T> of,Iterator<? extends T> iterators){\r\n    final Iterator[] iterators1 = (Iterator[]) iterators;\r\n    return new CompositeIterator<T>(iterators1);\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testCalculatedDefaultMeasureOnVirtualCubeNoThrowException",
	"Comment": "before the fix this test would throw an indexoutofbounds exceptionin sqlconstraintutils.removedefaultmembers.the method assumed that thefirst member in the list would exist and be a measure.but, when thedefault measure is calculated, it would have already been removed fromthe list by removecalculatedmembers, and thus the assumption was wrong.",
	"Method": "void testCalculatedDefaultMeasureOnVirtualCubeNoThrowException(){\r\n    propSaver.set(MondrianProperties.instance().EnableNativeNonEmpty, true);\r\n    final TestContext context = TestContext.instance().withSchema(\"<Schema name=\\\"FoodMart\\\">\" + \"  <Dimension name=\\\"Store\\\">\" + \"    <Hierarchy hasAll=\\\"true\\\" primaryKey=\\\"store_id\\\">\" + \"      <Table name=\\\"store\\\" />\" + \"      <Level name=\\\"Store Country\\\" column=\\\"store_country\\\" uniqueMembers=\\\"true\\\" />\" + \"      <Level name=\\\"Store State\\\" column=\\\"store_state\\\" uniqueMembers=\\\"true\\\" />\" + \"      <Level name=\\\"Store City\\\" column=\\\"store_city\\\" uniqueMembers=\\\"false\\\" />\" + \"      <Level name=\\\"Store Name\\\" column=\\\"store_name\\\" uniqueMembers=\\\"true\\\">\" + \"        <Property name=\\\"Store Type\\\" column=\\\"store_type\\\" />\" + \"        <Property name=\\\"Store Manager\\\" column=\\\"store_manager\\\" />\" + \"        <Property name=\\\"Store Sqft\\\" column=\\\"store_sqft\\\" type=\\\"Numeric\\\" />\" + \"        <Property name=\\\"Grocery Sqft\\\" column=\\\"grocery_sqft\\\" type=\\\"Numeric\\\" />\" + \"        <Property name=\\\"Frozen Sqft\\\" column=\\\"frozen_sqft\\\" type=\\\"Numeric\\\" />\" + \"        <Property name=\\\"Meat Sqft\\\" column=\\\"meat_sqft\\\" type=\\\"Numeric\\\" />\" + \"        <Property name=\\\"Has coffee bar\\\" column=\\\"coffee_bar\\\" type=\\\"Boolean\\\" />\" + \"        <Property name=\\\"Street address\\\" column=\\\"store_street_address\\\" type=\\\"String\\\" />\" + \"      <\/Level>\" + \"    <\/Hierarchy>\" + \"  <\/Dimension>\" + \"  <Cube name=\\\"Sales\\\" defaultMeasure=\\\"Unit Sales\\\">\" + \"    <Table name=\\\"sales_fact_1997\\\" />\" + \"    <DimensionUsage name=\\\"Store\\\" source=\\\"Store\\\" foreignKey=\\\"store_id\\\" />\" + \"    <Measure name=\\\"Unit Sales\\\" column=\\\"unit_sales\\\" aggregator=\\\"sum\\\" formatString=\\\"Standard\\\" />\" + \"    <CalculatedMember name=\\\"dummyMeasure\\\" dimension=\\\"Measures\\\">\" + \"      <Formula>1<\/Formula>\" + \"    <\/CalculatedMember>\" + \"  <\/Cube>\" + \"  <VirtualCube defaultMeasure=\\\"dummyMeasure\\\" name=\\\"virtual\\\">\" + \"    <VirtualCubeDimension name=\\\"Store\\\" />\" + \"    <VirtualCubeMeasure cubeName=\\\"Sales\\\" name=\\\"[Measures].[Unit Sales]\\\" />\" + \"    <VirtualCubeMeasure name=\\\"[Measures].[dummyMeasure]\\\" cubeName=\\\"Sales\\\" />\" + \"  <\/VirtualCube>\" + \"<\/Schema>\");\r\n    context.assertQueryReturns(\"select \" + \" [Measures].[Unit Sales] on COLUMNS, \" + \" NON EMPTY {[Store].[Store State].Members} ON ROWS \" + \" from [virtual] \", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Store].[USA].[CA]}\\n\" + \"{[Store].[USA].[OR]}\\n\" + \"{[Store].[USA].[WA]}\\n\" + \"Row #0: 74,748\\n\" + \"Row #1: 67,659\\n\" + \"Row #2: 124,366\\n\");\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Tbody.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Tbody appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.HierarchyUsage.findJoinTable",
	"Comment": "chooses the table with which to join a hierarchy to the fact table.",
	"Method": "MondrianDef.Relation findJoinTable(RolapHierarchy hierarchy,String tableName){\r\n    final MondrianDef.Relation table;\r\n    if (tableName == null) {\r\n        table = hierarchy.getUniqueTable();\r\n        if (table == null) {\r\n            throw MondrianResource.instance().MustSpecifyPrimaryKeyTableForHierarchy.ex(hierarchy.getUniqueName());\r\n        }\r\n    } else {\r\n        table = hierarchy.getRelation().find(tableName);\r\n        if (table == null) {\r\n            throw Util.newError(\"no table '\" + tableName + \"' found in hierarchy \" + hierarchy.getUniqueName());\r\n        }\r\n    }\r\n    return table;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Span.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Span appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "org.jfaster.mango.stat.atomic.LongAdder.reset",
	"Comment": "resets variables maintaining the sum to zero.this method maybe a useful alternative to creating a new adder, but is onlyeffective if there are no concurrent updates.because thismethod is intrinsically racy, it should only be used when it isknown that no threads are concurrently updating.",
	"Method": "void reset(){\r\n    internalReset(0L);\r\n}"
}, {
	"Path": "mondrian.calc.impl.AbstractCalc.butDepends",
	"Comment": "returns true if any of the calcs depend on dimension,else false if any of the calcs return dimension,else true.",
	"Method": "boolean butDepends(Calc[] calcs,Hierarchy hierarchy){\r\n    boolean result = true;\r\n    for (Calc calc : calcs) {\r\n        if (calc != null) {\r\n            if (calc.dependsOn(hierarchy)) {\r\n                return true;\r\n            }\r\n            if (calc.getType().usesHierarchy(hierarchy, true)) {\r\n                result = false;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "mondrian.rolap.sql.SqlQuery.addFrom",
	"Comment": "adds a relation to a query, adding appropriate join conditions, unlessit is already present.returns whether the relation was added to the query.",
	"Method": "void addFrom(SqlQuery sqlQuery,String alias,boolean failIfExists,boolean addFrom,MondrianDef.RelationOrJoin relation,String alias,boolean failIfExists){\r\n    registerRootRelation(relation);\r\n    if (relation instanceof MondrianDef.Relation) {\r\n        MondrianDef.Relation relation1 = (MondrianDef.Relation) relation;\r\n        if (relations.add(relation1) && !MondrianProperties.instance().FilterChildlessSnowflakeMembers.get()) {\r\n            MondrianDef.RelationOrJoin root = mapRelationToRoot.get(relation1);\r\n            List<MondrianDef.Relation> relationsCopy = new ArrayList<MondrianDef.Relation>(relations);\r\n            for (MondrianDef.Relation relation2 : relationsCopy) {\r\n                if (relation2 != relation1 && mapRelationToRoot.get(relation2) == root) {\r\n                    addJoinBetween(root, relation1, relation2);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (relation instanceof MondrianDef.View) {\r\n        final MondrianDef.View view = (MondrianDef.View) relation;\r\n        final String viewAlias = (alias == null) ? view.getAlias() : alias;\r\n        final String sqlString = view.getCodeSet().chooseQuery(dialect);\r\n        return addFromQuery(sqlString, viewAlias, false);\r\n    } else if (relation instanceof MondrianDef.InlineTable) {\r\n        final MondrianDef.Relation relation1 = RolapUtil.convertInlineTableToRelation((MondrianDef.InlineTable) relation, dialect);\r\n        return addFrom(relation1, alias, failIfExists);\r\n    } else if (relation instanceof MondrianDef.Table) {\r\n        final MondrianDef.Table table = (MondrianDef.Table) relation;\r\n        final String tableAlias = (alias == null) ? table.getAlias() : alias;\r\n        return addFromTable(table.schema, table.name, tableAlias, table.getFilter(), table.getHintMap(), failIfExists);\r\n    } else if (relation instanceof MondrianDef.Join) {\r\n        final MondrianDef.Join join = (MondrianDef.Join) relation;\r\n        return addJoin(join.left, join.getLeftAlias(), join.leftKey, join.right, join.getRightAlias(), join.rightKey, failIfExists);\r\n    } else {\r\n        throw Util.newInternal(\"bad relation type \" + relation);\r\n    }\r\n}"
}, {
	"Path": "com.oath.micro.server.events.LabelledEvents.start",
	"Comment": "marks the start of a query identified by the provided correlationid, with additional query type and data parameters",
	"Method": "void start(T query,long correlationId,EventBus bus,String labels,AddLabelledQuery<T> start,T query,long correlationId,String label,AddLabelledQuery<T> start,T query,long correlationId,String label,Object additionalData){\r\n    return new AddLabelledQuery(RequestData.builder().query(query).correlationId(correlationId).type(label).additionalData(additionalData).build());\r\n}"
}, {
	"Path": "mondrian.test.FoodMartTestCase.assertExprThrows",
	"Comment": "runs an expression, and asserts that it gives an error which containsa particular pattern. the error might occur during parsing, or mightbe contained within the cell value.",
	"Method": "void assertExprThrows(String expression,String pattern){\r\n    getTestContext().assertExprThrows(expression, pattern);\r\n}"
}, {
	"Path": "mondrian.test.loader.MondrianFoodMartLoader.embedQuotes",
	"Comment": "generate an appropriate string to use in an sql insert statement fora varchar colummn, taking into account null strings and strings withembedded quotes.",
	"Method": "String embedQuotes(String original){\r\n    if (original == null) {\r\n        return \"NULL\";\r\n    }\r\n    StringBuilder buf = new StringBuilder();\r\n    buf.append(\"'\");\r\n    for (int i = 0; i < original.length(); i++) {\r\n        char ch = original.charAt(i);\r\n        buf.append(ch);\r\n        if (ch == '\\'') {\r\n            buf.append('\\'');\r\n        }\r\n    }\r\n    buf.append(\"'\");\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.mapsforge.map.android.graphics.AndroidPaint.setBitmapShaderShift",
	"Comment": "shifts the bitmap pattern so that it will always start at a multiple ofitself for any tile the pattern is used. this ensures that regardless ofsize of the pattern it tiles correctly.",
	"Method": "void setBitmapShaderShift(Point origin){\r\n    Shader shader = this.paint.getShader();\r\n    if (shader != null) {\r\n        int relativeDx = ((int) -origin.x) % this.shaderWidth;\r\n        int relativeDy = ((int) -origin.y) % this.shaderHeight;\r\n        Matrix localMatrix = new Matrix();\r\n        localMatrix.setTranslate(relativeDx, relativeDy);\r\n        shader.setLocalMatrix(localMatrix);\r\n    }\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteSession.executeForChangedRowCount",
	"Comment": "executes a statement that returns a count of the number of rowsthat were changed.use for update or delete sql statements.",
	"Method": "int executeForChangedRowCount(String sql,Object[] bindArgs,int connectionFlags,CancellationSignal cancellationSignal){\r\n    if (sql == null) {\r\n        throw new IllegalArgumentException(\"sql must not be null.\");\r\n    }\r\n    if (executeSpecial(sql, bindArgs, connectionFlags, cancellationSignal)) {\r\n        return 0;\r\n    }\r\n    acquireConnection(sql, connectionFlags, cancellationSignal);\r\n    try {\r\n        return // might throw\r\n        mConnection.executeForChangedRowCount(// might throw\r\n        sql, bindArgs, cancellationSignal);\r\n    } finally {\r\n        releaseConnection();\r\n    }\r\n}"
}, {
	"Path": "mondrian.server.MondrianServerRegistry.serverForId",
	"Comment": "looks up a server with a given id. if the id is null, returns thestatic server.",
	"Method": "MondrianServer serverForId(String instanceId){\r\n    if (instanceId != null) {\r\n        final LockBox.Entry entry = lockBox.get(instanceId);\r\n        if (entry == null) {\r\n            throw Util.newError(\"No server instance has id '\" + instanceId + \"'\");\r\n        }\r\n        return (MondrianServer) entry.getValue();\r\n    } else {\r\n        return staticServer;\r\n    }\r\n}"
}, {
	"Path": "mondrian.xmla.impl.MondrianXmlaServlet.makeContentFinder",
	"Comment": "creates a callback for reading the repository. derived classes mayoverride.",
	"Method": "RepositoryContentFinder makeContentFinder(String dataSources){\r\n    return new UrlRepositoryContentFinder(dataSources);\r\n}"
}, {
	"Path": "mondrian.gui.SchemaPropertyCellEditor.isCellEditable",
	"Comment": "asks the editor if it can start editing using anevent.anevent is in the invoking component coordinate system.the editor can not assume the component returned bygetcelleditorcomponent is installed.this methodis intended for the use of client to avoid the cost of setting upand installing the editor component if editing is not possible.if editing can be started this method returns true.",
	"Method": "boolean isCellEditable(EventObject anEvent){\r\n    return true;\r\n}"
}, {
	"Path": "mondrian.gui.JTreeUpdater.update",
	"Comment": "call this method whenever you update the tree and needs it reloaded",
	"Method": "void update(){\r\n    synchronized (this.tree) {\r\n        this.tree.removeTreeExpansionListener(this);\r\n        this.tree.removeTreeSelectionListener(this);\r\n        ((DefaultTreeModel) this.tree.getModel()).reload();\r\n        for (TreePath treePath : expandedTreePaths) {\r\n            this.tree.expandPath(treePath);\r\n        }\r\n        this.tree.getSelectionModel().setSelectionPaths(selectedTreePaths);\r\n        this.tree.addTreeExpansionListener(this);\r\n        this.tree.addTreeSelectionListener(this);\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.samples.android.cluster.ClusterManager.createCluster",
	"Comment": "create cluster object. override this method, if you want to use customgeocluster class.",
	"Method": "Cluster<T> createCluster(T item){\r\n    return new Cluster<T>(this, item);\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.BaseTileBasedDataProcessor.handleImplicitWayRelations",
	"Comment": "calculate ids of ways whose polygon inherits part elements.",
	"Method": "void handleImplicitWayRelations(){\r\n    if (!this.tagValues) {\r\n        return;\r\n    }\r\n    for (Map.Entry<TileCoordinate, TLongHashSet> tilePartElementEntry : this.tilesToPartElements.entrySet()) {\r\n        TLongHashSet tileRootElementSet = this.tilesToRootElements.get(tilePartElementEntry.getKey());\r\n        if (tileRootElementSet == null || tileRootElementSet.isEmpty() || tilePartElementEntry.getValue().isEmpty()) {\r\n            continue;\r\n        }\r\n        List<TDWay> pElems = new ArrayList();\r\n        TLongIterator tilePartElementIterator = tilePartElementEntry.getValue().iterator();\r\n        while (tilePartElementIterator.hasNext()) {\r\n            TDWay pElem = getWay(tilePartElementIterator.next());\r\n            pElems.add(pElem);\r\n        }\r\n        TLongIterator tileRootElementIterator = tileRootElementSet.iterator();\r\n        while (tileRootElementIterator.hasNext()) {\r\n            TDWay rElem = getWay(tileRootElementIterator.next());\r\n            BoundingBox rBox = GeoUtils.mapWayToBoundingBox(rElem);\r\n            if (rBox == null) {\r\n                continue;\r\n            }\r\n            Polygon rPolygon = null;\r\n            for (int i = pElems.size() - 1; i >= 0; i--) {\r\n                TDWay pElem = pElems.get(i);\r\n                if (pElem.getWayNodes().length < 3) {\r\n                    continue;\r\n                }\r\n                if (!rBox.contains(LatLongUtils.microdegreesToDegrees(pElem.getWayNodes()[0].getLatitude()), LatLongUtils.microdegreesToDegrees(pElem.getWayNodes()[0].getLongitude()))) {\r\n                    continue;\r\n                }\r\n                Polygon pPolygon = GeoUtils.mapWayToPolygon(pElem);\r\n                if (pPolygon == null) {\r\n                    continue;\r\n                }\r\n                if (rPolygon == null) {\r\n                    rPolygon = GeoUtils.mapWayToPolygon(rElem);\r\n                    if (rPolygon == null) {\r\n                        continue;\r\n                    }\r\n                }\r\n                if (rPolygon.covers(pPolygon.getInteriorPoint())) {\r\n                    if (!this.partRootRelations.containsKey(rElem.getId())) {\r\n                        this.partRootRelations.put(rElem.getId(), null);\r\n                    }\r\n                    this.partRootRelations.put(pElem.getId(), rElem.getId());\r\n                    pElems.remove(pElem);\r\n                    tilePartElementEntry.getValue().remove(pElem.getId());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    LOGGER.info(\"calculated \" + nfCounts.format(partRootRelations.size()) + \" implicit relations\");\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.setWorkbenchProperty",
	"Comment": "set a workbench property.note that this does not save the property,a call to storeworkbenchproperties is required.",
	"Method": "void setWorkbenchProperty(String key,String value){\r\n    workbenchProperties.setProperty(key, value);\r\n}"
}, {
	"Path": "mondrian.rolap.RolapResult.evaluateExp",
	"Comment": "evaluates an expression. intended for evaluating named sets.does not modify the contents of the evaluator.",
	"Method": "Object evaluateExp(Calc calc,RolapEvaluator slicerEvaluator,Evaluator contextEvaluator){\r\n    int attempt = 0;\r\n    RolapEvaluator evaluator = slicerEvaluator.push();\r\n    if (contextEvaluator != null && contextEvaluator.isEvalAxes()) {\r\n        evaluator.setEvalAxes(true);\r\n    }\r\n    final int savepoint = evaluator.savepoint();\r\n    boolean dirty = batchingReader.isDirty();\r\n    try {\r\n        while (true) {\r\n            evaluator.restore(savepoint);\r\n            evaluator.setCellReader(batchingReader);\r\n            Object preliminaryValue = calc.evaluate(evaluator);\r\n            if (preliminaryValue instanceof TupleIterable) {\r\n                TupleIterable iterable = (TupleIterable) preliminaryValue;\r\n                final TupleCursor cursor = iterable.tupleCursor();\r\n                while (cursor.forward()) {\r\n                }\r\n            }\r\n            if (!phase()) {\r\n                break;\r\n            } else {\r\n                evaluator.clearExpResultCache(false);\r\n            }\r\n            if (attempt++ > maxEvalDepth) {\r\n                throw Util.newInternal(\"Failed to load all aggregations after \" + maxEvalDepth + \"passes; there's probably a cycle\");\r\n            }\r\n        }\r\n        if (dirty) {\r\n            batchingReader.setDirty(true);\r\n        }\r\n        evaluator.restore(savepoint);\r\n        evaluator.setCellReader(aggregatingReader);\r\n        final Object o = calc.evaluate(evaluator);\r\n        return o;\r\n    } finally {\r\n        evaluator.restore(savepoint);\r\n    }\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getQueryString",
	"Comment": "returns the query string that is contained in the request url after thepath.",
	"Method": "String getQueryString(){\r\n    return queryString;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.releaseMemory",
	"Comment": "attempts to release memory that sqlite holds but does not require tooperate properly. typically this memory will come from the page cache.",
	"Method": "int releaseMemory(){\r\n    return SQLiteGlobal.releaseMemory();\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.origCompatHashingAlg",
	"Comment": "internal private hashing method.\tthis is the original hashing algorithm from other clients.\tfound to be slow and have poor distribution.",
	"Method": "long origCompatHashingAlg(String key){\r\n    long hash = 0;\r\n    char[] cArr = key.toCharArray();\r\n    for (int i = 0; i < cArr.length; ++i) {\r\n        hash = (hash * 33) + cArr[i];\r\n    }\r\n    return hash;\r\n}"
}, {
	"Path": "mondrian.spi.SegmentHeader.constrain",
	"Comment": "applies a set of exclusions to this segment header and returnsa new segment header representing the original one to which aregion has been excluded.",
	"Method": "SegmentHeader constrain(SegmentColumn[] region){\r\n    final Map<String, SegmentColumn> newRegions = new HashMap<String, SegmentColumn>();\r\n    for (SegmentColumn excludedRegion : excludedRegions) {\r\n        newRegions.put(excludedRegion.columnExpression, excludedRegion);\r\n    }\r\n    for (SegmentColumn col : region) {\r\n        if (getConstrainedColumn(col.columnExpression) == null) {\r\n            continue;\r\n        }\r\n        if (newRegions.containsKey(col.columnExpression)) {\r\n            newRegions.put(col.columnExpression, newRegions.get(col.columnExpression).merge(col));\r\n        } else {\r\n            newRegions.put(col.columnExpression, col);\r\n        }\r\n    }\r\n    assert newRegions.size() > 0;\r\n    return new SegmentHeader(schemaName, schemaChecksum, cubeName, measureName, constrainedColumns, compoundPredicates, rolapStarFactTableName, constrainedColsBitKey, new ArrayList<SegmentColumn>(newRegions.values()));\r\n}"
}, {
	"Path": "mondrian.gui.SchemaExplorer.setTableCellFocus",
	"Comment": "several methods are called, e.g. editcellat,to get the focus set in thevalue column of the specified row.the attribute column has theparameter name and should not receive focus.",
	"Method": "void setTableCellFocus(int row){\r\n    propertyTable.editCellAt(row, 1);\r\n    TableCellEditor editor = propertyTable.getCellEditor(row, 1);\r\n    Component comp = editor.getTableCellEditorComponent(propertyTable, propertyTable.getValueAt(row, 1), true, row, 1);\r\n}"
}, {
	"Path": "mondrian.olap.RoleImpl.checkDimensionAccessByCubeInheritance",
	"Comment": "this method is used to check if the access rights over a dimensionthat might be inherited from the parent cube.it only checks for inherited access, and it presumes that thereare no dimension grants currently given to the dimension passed as anargument.",
	"Method": "Access checkDimensionAccessByCubeInheritance(Dimension dimension){\r\n    assert dimensionGrants.containsKey(dimension) == false || dimension.isMeasures();\r\n    for (Map.Entry<Cube, Access> cubeGrant : cubeGrants.entrySet()) {\r\n        final Access access = toAccess(cubeGrant.getValue());\r\n        if (access == Access.NONE || access == Access.CUSTOM) {\r\n            continue;\r\n        }\r\n        final Dimension[] dimensions = cubeGrant.getKey().getDimensions();\r\n        for (Dimension dimension1 : dimensions) {\r\n            if (dimension == dimension1) {\r\n                return cubeGrant.getValue();\r\n            }\r\n            if (dimension instanceof RolapCubeDimension && dimension.equals(dimension1) && !((RolapCubeDimension) dimension1).getCube().equals(cubeGrant.getKey())) {\r\n                continue;\r\n            }\r\n            if (cubeGrant.getKey() instanceof RolapCube && ((RolapCube) cubeGrant.getKey()).isVirtual() && dimension.equals(dimension1)) {\r\n                return cubeGrant.getValue();\r\n            }\r\n        }\r\n    }\r\n    return Access.NONE;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCube.findBaseCubeHierarchy",
	"Comment": "locates the base cube hierarchy for a particular virtual hierarchy.if not found, return null. this may be converted to a map lookupor cached in some way in the future to increase performancewith cubes that have large numbers of hierarchies",
	"Method": "RolapHierarchy findBaseCubeHierarchy(RolapHierarchy hierarchy){\r\n    for (int i = 0; i < getDimensions().length; i++) {\r\n        Dimension dimension = getDimensions()[i];\r\n        if (dimension.getName().equals(hierarchy.getDimension().getName())) {\r\n            for (int j = 0; j < dimension.getHierarchies().length; j++) {\r\n                Hierarchy hier = dimension.getHierarchies()[j];\r\n                if (hier.getName().equals(hierarchy.getName())) {\r\n                    return (RolapHierarchy) hier;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.mapsforge.samples.android.group.ChildMarker.init",
	"Comment": "set group marker parameter. to know index and calculate position on spiral.",
	"Method": "void init(int index,Bitmap bitmap,int horizontalOffset,int verticalOffset){\r\n    this.index = index;\r\n    this.groupBitmapHalfHeight = bitmap.getHeight() / 2;\r\n    this.groupBitmapHalfWidth = bitmap.getWidth() / 2;\r\n    this.groupHOffset = horizontalOffset;\r\n    this.groupVOffset = verticalOffset;\r\n}"
}, {
	"Path": "org.jfaster.mango.stat.atomic.Striped64.getUnsafe",
	"Comment": "returns a sun.misc.unsafe.suitable for use in a 3rd party package.replace with a simple call to unsafe.getunsafe when integratinginto a jdk.",
	"Method": "sun.misc.Unsafe getUnsafe(){\r\n    try {\r\n        return sun.misc.Unsafe.getUnsafe();\r\n    } catch (SecurityException tryReflectionInstead) {\r\n    }\r\n    try {\r\n        return java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {\r\n            public sun.misc.Unsafe run() throws Exception {\r\n                Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\r\n                for (java.lang.reflect.Field f : k.getDeclaredFields()) {\r\n                    f.setAccessible(true);\r\n                    Object x = f.get(null);\r\n                    if (k.isInstance(x))\r\n                        return k.cast(x);\r\n                }\r\n                throw new NoSuchFieldError(\"the Unsafe\");\r\n            }\r\n        });\r\n    } catch (java.security.PrivilegedActionException e) {\r\n        throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\r\n    }\r\n}"
}, {
	"Path": "org.jfaster.mango.stat.atomic.Striped64.getUnsafe",
	"Comment": "returns a sun.misc.unsafe.suitable for use in a 3rd party package.replace with a simple call to unsafe.getunsafe when integratinginto a jdk.",
	"Method": "sun.misc.Unsafe getUnsafe(){\r\n    Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\r\n    for (java.lang.reflect.Field f : k.getDeclaredFields()) {\r\n        f.setAccessible(true);\r\n        Object x = f.get(null);\r\n        if (k.isInstance(x))\r\n            return k.cast(x);\r\n    }\r\n    throw new NoSuchFieldError(\"the Unsafe\");\r\n}"
}, {
	"Path": "mondrian.test.DialectTest.checkRegex",
	"Comment": "translates a regular expression into sql and executes the query.returns whether the dialect was able to translate the regex.",
	"Method": "boolean checkRegex(String regex){\r\n    Dialect dialect = getDialect();\r\n    final String sqlRegex = dialect.generateRegularExpression(dialect.quoteIdentifier(\"customer\", \"fname\"), regex);\r\n    if (sqlRegex != null) {\r\n        String sql = \"select * from \" + dialectizeTableName(dialect.quoteIdentifier(\"customer\")) + \" where \" + sqlRegex;\r\n        final ResultSet resultSet = getConnection().createStatement().executeQuery(sql);\r\n        assertFalse(resultSet.next());\r\n        resultSet.close();\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "mondrian.xmla.XmlaBaseTestCase.filter",
	"Comment": "filters the content of a test resource. the default implementationreturns the content unchanged, but a derived class might override thismethod to change the content.",
	"Method": "String filter(String testCaseName,String filename,String content){\r\n    Util.discard(testCaseName);\r\n    Util.discard(filename);\r\n    return content;\r\n}"
}, {
	"Path": "org.mapsforge.poi.storage.PoiCategoryRangeQueryGeneratorTest.selectTwoFromBalancedHierarchy",
	"Comment": "select all categories by adding the root category to a whitelist filter.",
	"Method": "void selectTwoFromBalancedHierarchy(){\r\n    PoiCategoryFilter filter = new WhitelistPoiCategoryFilter();\r\n    filter.addCategory(this.balancedCm.getPoiCategoryByTitle(\"l1_1\"));\r\n    filter.addCategory(this.balancedCm.getPoiCategoryByTitle(\"l1_2\"));\r\n    String query = PoiCategoryRangeQueryGenerator.getSQLSelectString(filter, 0, POI_VERSION);\r\n    System.out.println(\"Query: \" + query);\r\n}"
}, {
	"Path": "mondrian.test.Ssas2005CompatibilityTest.testYtd",
	"Comment": "tests that time functions such as ytd behave correctly when there aremultiple time hierarchies.",
	"Method": "void testYtd(){\r\n    if (!MondrianProperties.instance().SsasCompatibleNaming.get()) {\r\n        return;\r\n    }\r\n    assertQueryReturns(\"select Generate(\\n\" + \"  {[Time].[Time2].[1997].[Q3]},\\n\" + \"  {Ytd()}) on 0,\\n\" + \" [Products].Children on 1\\n\" + \"from [Warehouse and Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"Axis #2:\\n\" + \"{[Product].[Products].[Drink]}\\n\" + \"{[Product].[Products].[Food]}\\n\" + \"{[Product].[Products].[Non-Consumable]}\\n\");\r\n}"
}, {
	"Path": "mondrian.olap.ValidatorImpl.requiresExpression",
	"Comment": "returns whether the kth argument to a function callhas to be an expression.",
	"Method": "boolean requiresExpression(boolean requiresExpression,int n,boolean requiresExpression,UnresolvedFunCall funCall,int k){\r\n    List<Resolver> resolvers = funTable.getResolvers(funCall.getFunName(), funCall.getSyntax());\r\n    for (Resolver resolver2 : resolvers) {\r\n        if (!resolver2.requiresExpression(k)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapAggregator.getRollup",
	"Comment": "returns the aggregator used to roll up. by default, aggregators roll upthemselves.",
	"Method": "Aggregator getRollup(){\r\n    return this;\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunctionTest.testNullRange",
	"Comment": "tests that a null passed in returns an empty set in range function",
	"Method": "void testNullRange(){\r\n    assertAxisReturns(\"[Time].[1997].[Q1].[2] : NULL\", \"\");\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunctionTest.testRankHuge",
	"Comment": "tests a rank function which is so large that we need to use cachingin order to execute it efficiently.",
	"Method": "void testRankHuge(){\r\n    if (!MondrianProperties.instance().EnableExpCache.get()) {\r\n        return;\r\n    }\r\n    checkRankHuge(\"WITH \\n\" + \"  MEMBER [Measures].[Rank among products] \\n\" + \"    AS ' Rank([Product].CurrentMember, \" + \"            Order([Product].members, \" + \"            [Measures].[Unit Sales], BDESC)) '\\n\" + \"SELECT CrossJoin(\\n\" + \"  [Gender].members,\\n\" + \"  {[Measures].[Unit Sales],\\n\" + \"   [Measures].[Rank among products]}) ON COLUMNS,\\n\" + \"  {[Product].members} ON ROWS\\n\" + \"FROM [Sales]\", false);\r\n}"
}, {
	"Path": "org.mapsforge.samples.android.SimplestMapViewer.getLayoutId",
	"Comment": "this mapviewer uses the standard xml layout in the samples app.",
	"Method": "int getLayoutId(){\r\n    return R.layout.mapviewer;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.inTransaction",
	"Comment": "returns true if the current thread has a transaction pending.",
	"Method": "boolean inTransaction(){\r\n    acquireReference();\r\n    try {\r\n        return getThreadSession().hasTransaction();\r\n    } finally {\r\n        releaseReference();\r\n    }\r\n}"
}, {
	"Path": "mondrian.gui.JdbcMetaData.initConnection",
	"Comment": "creates a database connection and initializes the meta data details",
	"Method": "String initConnection(){\r\n    LOGGER.debug(\"JdbcMetaData: initConnection\");\r\n    try {\r\n        if (jdbcDriverClassName == null || jdbcDriverClassName.trim().length() == 0 || jdbcConnectionUrl == null || jdbcConnectionUrl.trim().length() == 0) {\r\n            errMsg = getResourceConverter().getFormattedString(\"jdbcMetaData.blank.exception\", \"Driver={0}\\nConnection URL={1}\\nUse Preferences to set Database Connection parameters first and then open a Schema\", jdbcDriverClassName, jdbcConnectionUrl);\r\n            return errMsg;\r\n        }\r\n        Class.forName(jdbcDriverClassName);\r\n        if (jdbcUsername != null && jdbcUsername.length() > 0) {\r\n            conn = DriverManager.getConnection(jdbcConnectionUrl, jdbcUsername, jdbcPassword);\r\n        } else {\r\n            conn = DriverManager.getConnection(jdbcConnectionUrl);\r\n        }\r\n        LOGGER.debug(\"JDBC connection OPEN\");\r\n        md = conn.getMetaData();\r\n        db.productName = md.getDatabaseProductName();\r\n        db.productVersion = md.getDatabaseProductVersion();\r\n        db.catalogName = conn.getCatalog();\r\n        LOGGER.debug(\"Catalog name = \" + db.catalogName);\r\n        LOGGER.debug(\"Database Product Name: \" + db.productName);\r\n        LOGGER.debug(\"Database Product Version: \" + db.productVersion);\r\n        LOGGER.debug(\"JdbcMetaData: initConnection - no error\");\r\n        return null;\r\n    } catch (Exception e) {\r\n        errMsg = e.getClass().getSimpleName() + \" : \" + e.getLocalizedMessage();\r\n        LOGGER.error(\"Database connection exception : \" + errMsg, e);\r\n        return errMsg;\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.UdfTest.calcMemberTestContext",
	"Comment": "shorthand for containing a test context that consists of the standardfoodmart sales cube plus one calculated member.",
	"Method": "TestContext calcMemberTestContext(String xmlCalcMember){\r\n    return TestContext.instance().createSubstitutingCube(\"Sales\", null, null, xmlCalcMember, null);\r\n}"
}, {
	"Path": "mondrian.util.ConcatenableList.consolidate",
	"Comment": "performs a load of all elements into memory, removing sequentialaccess advantages.",
	"Method": "void consolidate(){\r\n    if (this.plainList == null) {\r\n        this.plainList = new ArrayList<T>();\r\n        for (final List<T> list : lists) {\r\n            for (final T t : list) {\r\n                this.plainList.add(t);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testExpandWithOneEmptyInput",
	"Comment": "verify that native evaluation is on when expendnonnative is set, even ifthe input list is empty.",
	"Method": "void testExpandWithOneEmptyInput(){\r\n    propSaver.set(MondrianProperties.instance().ExpandNonNative, true);\r\n    boolean requestFreshConnection = true;\r\n    checkNative(0, 0, \"With \" + \"Set [*NATIVE_CJ_SET] as 'NonEmptyCrossJoin([*BASE_MEMBERS_Gender],[*BASE_MEMBERS_Product])' \" + \"Set [*BASE_MEMBERS_Measures] as '{[Measures].[*FORMATTED_MEASURE_0]}' \" + \"Set [*BASE_MEMBERS_Gender] as 'Filter([Gender].[Gender].Members,[Gender].CurrentMember.Name Matches (\\\"abc\\\"))' \" + \"Set [*NATIVE_MEMBERS_Gender] as 'Generate([*NATIVE_CJ_SET], {[Gender].CurrentMember})' \" + \"Set [*BASE_MEMBERS_Product] as '[Product].[Product Name].Members' \" + \"Set [*NATIVE_MEMBERS_Product] as 'Generate([*NATIVE_CJ_SET], {[Product].CurrentMember})' \" + \"Member [Measures].[*FORMATTED_MEASURE_0] as '[Measures].[Unit Sales]', FORMAT_STRING = '#,##0', SOLVE_ORDER=400 \" + \"Select \" + \"[*BASE_MEMBERS_Measures] on columns, \" + \"Non Empty Generate([*NATIVE_CJ_SET], {([Gender].CurrentMember,[Product].CurrentMember)}) on rows \" + \"From [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[*FORMATTED_MEASURE_0]}\\n\" + \"Axis #2:\\n\", requestFreshConnection);\r\n}"
}, {
	"Path": "mondrian.util.NotificationMemoryMonitor.getMaxMemory",
	"Comment": "get the maximum possible memory usage for this jvm instance.",
	"Method": "long getMaxMemory(){\r\n    return TENURED_POOL.getUsage().getMax();\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.ImageHelper.storePicture",
	"Comment": "store a picture that has just been saved to disk in the mediastore.",
	"Method": "Uri storePicture(Context ctx,File imageFile,String imageName){\r\n    ContentResolver cr = ctx.getContentResolver();\r\n    imageName = imageName.substring(imageName.lastIndexOf('/') + 1);\r\n    ContentValues values = new ContentValues(7);\r\n    values.put(MediaColumns.TITLE, imageName);\r\n    values.put(MediaColumns.DISPLAY_NAME, imageName);\r\n    values.put(ImageColumns.DESCRIPTION, \"\");\r\n    values.put(ImageColumns.DATE_TAKEN, System.currentTimeMillis());\r\n    values.put(MediaColumns.MIME_TYPE, \"image/jpeg\");\r\n    values.put(ImageColumns.ORIENTATION, 0);\r\n    File parentFile = imageFile.getParentFile();\r\n    String path = parentFile.toString().toLowerCase();\r\n    String name = parentFile.getName().toLowerCase();\r\n    values.put(Images.ImageColumns.BUCKET_ID, path.hashCode());\r\n    values.put(Images.ImageColumns.BUCKET_DISPLAY_NAME, name);\r\n    values.put(\"_data\", imageFile.toString());\r\n    Uri uri = cr.insert(Images.Media.EXTERNAL_CONTENT_URI, values);\r\n    return uri;\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlTest.testNormalize",
	"Comment": "tests the algorithm which converts a cache region specification intonormal form.",
	"Method": "void testNormalize(){\r\n    final CacheControl cacheControl = new CacheControlImpl((RolapConnection) getTestContext().getConnection());\r\n    final CacheControl.CellRegion region = cacheControl.createUnionRegion(cacheControl.createCrossjoinRegion(memberRegion(\"[Marital Status].[S]\"), cacheControl.createUnionRegion(cacheControl.createCrossjoinRegion(memberRegion(\"[Gender].[F]\"), memberRegion(\"[Time].[1997].[Q1]\")), cacheControl.createCrossjoinRegion(memberRegion(\"[Gender].[M]\"), memberRegion(\"[Time].[1997].[Q2]\")))), cacheControl.createCrossjoinRegion(cacheControl.createCrossjoinRegion(memberRegion(\"[Marital Status].[S]\"), memberRegion(\"[Gender].[F]\")), memberRegion(\"[Time].[1997].[Q1]\")));\r\n    assertEquals(\"Union(\" + \"Crossjoin(\" + \"Member([Marital Status].[S]), \" + \"Union(\" + \"Crossjoin(\" + \"Member([Gender].[F]), \" + \"Member([Time].[1997].[Q1])), \" + \"Crossjoin(Member([Gender].[M]), \" + \"Member([Time].[1997].[Q2])))), \" + \"Crossjoin(\" + \"Member([Marital Status].[S]), \" + \"Member([Gender].[F]), \" + \"Member([Time].[1997].[Q1])))\", region.toString());\r\n    final CacheControl.CellRegion normalizedRegion = ((CacheControlImpl) cacheControl).normalize((CacheControlImpl.CellRegionImpl) region);\r\n    assertEquals(\"Union(\" + \"Crossjoin(Member([Marital Status].[S]), Member([Gender].[F]), Member([Time].[1997].[Q1])), \" + \"Crossjoin(Member([Marital Status].[S]), Member([Gender].[M]), Member([Time].[1997].[Q2])), \" + \"Crossjoin(Member([Marital Status].[S]), Member([Gender].[F]), Member([Time].[1997].[Q1])))\", normalizedRegion.toString());\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunctionTest.testTwoNullRange",
	"Comment": "tests that an exception is thrown if both parameters in a range functionare null.",
	"Method": "void testTwoNullRange(){\r\n    assertAxisThrows(\"NULL : NULL\", \"Mondrian Error:Failed to parse query 'select {NULL : NULL} on columns from Sales'\");\r\n}"
}, {
	"Path": "org.mapsforge.core.model.Tile.getBoundaryAbsolute",
	"Comment": "extend of the area defined by the two tiles in absolute coordinates.",
	"Method": "Rectangle getBoundaryAbsolute(Tile upperLeft,Tile lowerRight,Rectangle getBoundaryAbsolute){\r\n    return new Rectangle(getOrigin().x, getOrigin().y, getOrigin().x + tileSize, getOrigin().y + tileSize);\r\n}"
}, {
	"Path": "mondrian.olap.IdBatchResolver.getOlapElementNames",
	"Comment": "returns a collection of strings corresponding to the nameor uniquename of each olapelement in olapelements, based on theflag uniquename.",
	"Method": "Collection<String> getOlapElementNames(OlapElement[] olapElements,boolean uniqueName){\r\n    return CollectionUtils.collect(Arrays.asList(olapElements), new Transformer() {\r\n        public Object transform(Object o) {\r\n            return uniqueName ? ((OlapElement) o).getUniqueName() : ((OlapElement) o).getName();\r\n        }\r\n    });\r\n}"
}, {
	"Path": "mondrian.olap.IdBatchResolver.getOlapElementNames",
	"Comment": "returns a collection of strings corresponding to the nameor uniquename of each olapelement in olapelements, based on theflag uniquename.",
	"Method": "Collection<String> getOlapElementNames(OlapElement[] olapElements,boolean uniqueName){\r\n    return uniqueName ? ((OlapElement) o).getUniqueName() : ((OlapElement) o).getName();\r\n}"
}, {
	"Path": "com.mycollab.vaadin.UserUIContext.updateLastModuleVisit",
	"Comment": "update last module visit then the next sign in, mycollab will lead userto last visit module",
	"Method": "void updateLastModuleVisit(String moduleName){\r\n    try {\r\n        UserAccountMapper userAccountMapper = AppContextUtil.getSpringBean(UserAccountMapper.class);\r\n        UserAccount userAccount = new UserAccount();\r\n        userAccount.setLastmodulevisit(moduleName);\r\n        UserAccountExample ex = new UserAccountExample();\r\n        ex.createCriteria().andAccountidEqualTo(AppUI.getAccountId()).andUsernameEqualTo(UserUIContext.getUsername());\r\n        userAccountMapper.updateByExampleSelective(userAccount, ex);\r\n    } catch (Exception e) {\r\n        LOG.error(\"There is error when try to update user preference for last module visit\", e);\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.core.model.Tile.getBoundingBox",
	"Comment": "return the boundingbox of a rectangle of tiles defined by upper left and lower right tile.",
	"Method": "BoundingBox getBoundingBox(Tile upperLeft,Tile lowerRight,BoundingBox getBoundingBox){\r\n    if (this.boundingBox == null) {\r\n        double minLatitude = Math.max(MercatorProjection.LATITUDE_MIN, MercatorProjection.tileYToLatitude(tileY + 1, zoomLevel));\r\n        double minLongitude = Math.max(-180, MercatorProjection.tileXToLongitude(this.tileX, zoomLevel));\r\n        double maxLatitude = Math.min(MercatorProjection.LATITUDE_MAX, MercatorProjection.tileYToLatitude(this.tileY, zoomLevel));\r\n        double maxLongitude = Math.min(180, MercatorProjection.tileXToLongitude(tileX + 1, zoomLevel));\r\n        if (maxLongitude == -180) {\r\n            maxLongitude = 180;\r\n        }\r\n        this.boundingBox = new BoundingBox(minLatitude, minLongitude, maxLatitude, maxLongitude);\r\n    }\r\n    return this.boundingBox;\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.model.TileCoordinate.translateToZoomLevel",
	"Comment": "computes which tile on a lower zoom level covers this given tile or which tiles on a higher zoom level togethercover this tile.",
	"Method": "List<TileCoordinate> translateToZoomLevel(byte zoomlevelNew){\r\n    List<TileCoordinate> tiles = null;\r\n    int zoomlevelDistance = zoomlevelNew - this.zoomlevel;\r\n    int factor = (int) Math.pow(2, Math.abs(zoomlevelDistance));\r\n    if (zoomlevelDistance > 0) {\r\n        tiles = new ArrayList((int) Math.pow(4, Math.abs(zoomlevelDistance)));\r\n        int tileUpperLeftX = this.x * factor;\r\n        int tileUpperLeftY = this.y * factor;\r\n        for (int i = 0; i < factor; i++) {\r\n            for (int j = 0; j < factor; j++) {\r\n                tiles.add(new TileCoordinate(tileUpperLeftX + j, tileUpperLeftY + i, zoomlevelNew));\r\n            }\r\n        }\r\n    } else {\r\n        tiles = new ArrayList(1);\r\n        tiles.add(new TileCoordinate(this.x / factor, this.y / factor, zoomlevelNew));\r\n    }\r\n    return tiles;\r\n}"
}, {
	"Path": "mondrian.test.BasicQueryTest.testSummingProperties",
	"Comment": "tests various ways to sum the properties of the descendants of a member,inspired by forum postsummingproperties.",
	"Method": "void testSummingProperties(){\r\n    final String expected = \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Store].[USA]}\\n\" + \"{[Store].[USA].[CA]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[F]}\\n\" + \"{[Gender].[M]}\\n\" + \"Row #0: 131,558\\n\" + \"Row #0: 36,759\\n\" + \"Row #1: 135,215\\n\" + \"Row #1: 37,989\\n\";\r\n    assertQueryReturns(\"with member [Measures].[Sum Sqft] as '\" + \"sum(\" + \"  Descendants([Store].CurrentMember, [Store].Levels(5)),\" + \"  [Store].CurrentMember.Properties(\\\"Store Sqft\\\")) '\\n\" + \"select {[Store].[USA], [Store].[USA].[CA]} on 0,\\n\" + \" [Gender].Children on 1\\n\" + \"from [Sales]\", expected);\r\n    assertQueryReturns(\"with member [Measures].[Sum Sqft] as '\" + \"sum(\" + \"  Descendants([Store].CurrentMember, [Store].Levels(\\\"Store Name\\\")),\" + \"  [Store].CurrentMember.Properties(\\\"Store Sqft\\\")) '\\n\" + \"select {[Store].[USA], [Store].[USA].[CA]} on 0,\\n\" + \" [Gender].Children on 1\\n\" + \"from [Sales]\", expected);\r\n    assertQueryReturns(\"with member [Measures].[Sum Sqft] as '\" + \"sum(\" + \"  Descendants([Store].CurrentMember, [Store].[Store Name]),\" + \"  [Store].CurrentMember.Properties(\\\"Store Sqft\\\")) '\\n\" + \"select {[Store].[USA], [Store].[USA].[CA]} on 0,\\n\" + \" [Gender].Children on 1\\n\" + \"from [Sales]\", expected);\r\n    assertQueryReturns(\"with member [Measures].[Sum Sqft] as '\" + \"sum(\" + \"  Descendants([Store].CurrentMember, , LEAVES),\" + \"  [Store].CurrentMember.Properties(\\\"Store Sqft\\\")) '\\n\" + \"select {[Store].[USA], [Store].[USA].[CA]} on 0,\\n\" + \" [Gender].Children on 1\\n\" + \"from [Sales]\", expected);\r\n}"
}, {
	"Path": "mondrian.test.NativeSetEvaluationTest.testSlicerTuplesFullCrossJoin",
	"Comment": "same as before but without combinations missing in the crossjoin",
	"Method": "void testSlicerTuplesFullCrossJoin(){\r\n    if (!MondrianProperties.instance().EnableNativeCrossJoin.get() && !Bug.BugMondrian2452Fixed) {\r\n        return;\r\n    }\r\n    final String mdx = \"with\\n\" + \"set TSET as NonEmptyCrossJoin({[Time].[1997].[Q1], [Time].[1997].[Q2]}, {[Store Type].[Supermarket], [Store Type].[Deluxe Supermarket], [Store Type].[Gourmet Supermarket]})\\n\" + \" set products as TopCount(Product.[Product Name].Members, 2, Measures.[Store Sales])\\n\" + \" SELECT NON EMPTY products ON 1,\\n\" + \"NON EMPTY {[Measures].[Store Sales]} ON 0\\n\" + \" FROM [Sales]\\n\" + \"where TSET\";\r\n    String result = \"Axis #0:\\n\" + \"{[Time].[1997].[Q1], [Store Type].[Deluxe Supermarket]}\\n\" + \"{[Time].[1997].[Q1], [Store Type].[Gourmet Supermarket]}\\n\" + \"{[Time].[1997].[Q1], [Store Type].[Supermarket]}\\n\" + \"{[Time].[1997].[Q2], [Store Type].[Deluxe Supermarket]}\\n\" + \"{[Time].[1997].[Q2], [Store Type].[Gourmet Supermarket]}\\n\" + \"{[Time].[1997].[Q2], [Store Type].[Supermarket]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Store Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Product].[Food].[Eggs].[Eggs].[Eggs].[Urban].[Urban Small Eggs]}\\n\" + \"{[Product].[Food].[Produce].[Vegetables].[Fresh Vegetables].[Hermanos].[Hermanos Green Pepper]}\\n\" + \"Row #0: 460.02\\n\" + \"Row #1: 420.74\\n\";\r\n    assertQueryReturns(mdx, result);\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getMethod",
	"Comment": "returns the name of the http method with which this request was made, forexample, get, post, or put.",
	"Method": "String getMethod(){\r\n    return this.method;\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AggregationOnDistinctCountMeasuresTest.testDistinctCountInNonGroupingSetsQuery",
	"Comment": "test distinct count agg happens in non gs query for subset of memberswith mixed measures.",
	"Method": "void testDistinctCountInNonGroupingSetsQuery(){\r\n    propSaver.set(props.EnableGroupingSets, true);\r\n    String mdxQueryWithFewMembers = \"WITH \" + \"MEMBER [Store].[COG_OQP_USR_Aggregate(Store)] AS \" + \"'AGGREGATE({[Store].[All Stores].[USA].[CA], [Store].[All Stores].[USA].[OR]})', SOLVE_ORDER = 8\" + \"SELECT {[Measures].[Customer Count],[Measures].[Unit Sales]} ON AXIS(0), \" + \"{[Store].[All Stores].[USA].[CA], [Store].[All Stores].[USA].[OR], [Store].[COG_OQP_USR_Aggregate(Store)]} \" + \"ON AXIS(1) \" + \"FROM [Sales]\";\r\n    String desiredResult = \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Customer Count]}\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Store].[USA].[CA]}\\n\" + \"{[Store].[USA].[OR]}\\n\" + \"{[Store].[COG_OQP_USR_Aggregate(Store)]}\\n\" + \"Row #0: 2,716\\n\" + \"Row #0: 74,748\\n\" + \"Row #1: 1,037\\n\" + \"Row #1: 67,659\\n\" + \"Row #2: 3,753\\n\" + \"Row #2: 142,407\\n\";\r\n    String oraTeraSqlForDetail = \"select \\\"store\\\".\\\"store_state\\\" as \\\"c0\\\", \" + \"\\\"time_by_day\\\".\\\"the_year\\\" as \\\"c1\\\", \" + \"sum(\\\"sales_fact_1997\\\".\\\"unit_sales\\\") as \\\"m0\\\", \" + \"count(distinct \\\"sales_fact_1997\\\".\\\"customer_id\\\") as \\\"m1\\\" \" + \"from \\\"store\\\" =as= \\\"store\\\", \\\"sales_fact_1997\\\" =as= \\\"sales_fact_1997\\\", \" + \"\\\"time_by_day\\\" =as= \\\"time_by_day\\\" \" + \"where \\\"sales_fact_1997\\\".\\\"store_id\\\" = \\\"store\\\".\\\"store_id\\\" \" + \"and \\\"store\\\".\\\"store_state\\\" in ('CA', 'OR') \" + \"and \\\"sales_fact_1997\\\".\\\"time_id\\\" = \\\"time_by_day\\\".\\\"time_id\\\" \" + \"and \\\"time_by_day\\\".\\\"the_year\\\" = 1997 \" + \"group by \\\"store\\\".\\\"store_state\\\", \\\"time_by_day\\\".\\\"the_year\\\"\";\r\n    String oraTeraSqlForDistinctCountAgg = \"select \\\"time_by_day\\\".\\\"the_year\\\" as \\\"c0\\\", \" + \"count(distinct \\\"sales_fact_1997\\\".\\\"customer_id\\\") as \\\"m0\\\" \" + \"from \\\"time_by_day\\\" =as= \\\"time_by_day\\\", \" + \"\\\"sales_fact_1997\\\" =as= \\\"sales_fact_1997\\\", \\\"store\\\" =as= \\\"store\\\" \" + \"where \\\"sales_fact_1997\\\".\\\"time_id\\\" = \\\"time_by_day\\\".\\\"time_id\\\" \" + \"and \\\"time_by_day\\\".\\\"the_year\\\" = 1997 \" + \"and \\\"sales_fact_1997\\\".\\\"store_id\\\" = \\\"store\\\".\\\"store_id\\\" \" + \"and \\\"store\\\".\\\"store_state\\\" in ('CA', 'OR') \" + \"group by \\\"time_by_day\\\".\\\"the_year\\\"\";\r\n    SqlPattern[] patterns = { new SqlPattern(Dialect.DatabaseProduct.ORACLE, oraTeraSqlForDetail, oraTeraSqlForDetail), new SqlPattern(Dialect.DatabaseProduct.TERADATA, oraTeraSqlForDetail, oraTeraSqlForDetail), new SqlPattern(Dialect.DatabaseProduct.ORACLE, oraTeraSqlForDistinctCountAgg, oraTeraSqlForDistinctCountAgg), new SqlPattern(Dialect.DatabaseProduct.TERADATA, oraTeraSqlForDistinctCountAgg, oraTeraSqlForDistinctCountAgg) };\r\n    assertQueryReturns(mdxQueryWithFewMembers, desiredResult);\r\n    assertQuerySql(mdxQueryWithFewMembers, patterns);\r\n}"
}, {
	"Path": "mondrian.test.Main.isRunOnce",
	"Comment": "checks to see if the tests are running one user, one iteration.some tests are not thread safe so have to be skipped if this is not true.",
	"Method": "boolean isRunOnce(){\r\n    final MondrianProperties properties = MondrianProperties.instance();\r\n    return !properties.Warmup.get() && properties.VUsers.get() == 1 && properties.Iterations.get() == 1;\r\n}"
}, {
	"Path": "org.mapsforge.map.util.PausableThread.awaitPausing",
	"Comment": "causes the current thread to wait until this thread is pausing.",
	"Method": "void awaitPausing(){\r\n    synchronized (this) {\r\n        while (!isInterrupted() && !isPausing()) {\r\n            try {\r\n                wait(100);\r\n            } catch (InterruptedException e) {\r\n                Thread.currentThread().interrupt();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.gui.SchemaTreeModel.getRoot",
	"Comment": "returns the root of the tree.returns nullonly if the tree has no nodes.",
	"Method": "Object getRoot(){\r\n    return schema;\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.model.ZoomIntervalConfiguration.fromString",
	"Comment": "create a new zoomintervalconfiguration from the given string representation. checks for validity.",
	"Method": "ZoomIntervalConfiguration fromString(String confString){\r\n    String[] splitted = confString.split(\",\");\r\n    if (splitted.length % 3 != 0) {\r\n        throw new IllegalArgumentException(\"invalid zoom interval configuration, amount of comma-separated values must be a multiple of 3\");\r\n    }\r\n    byte[][] intervals = new byte[splitted.length / 3][3];\r\n    for (int i = 0; i < intervals.length; i++) {\r\n        intervals[i][0] = Byte.parseByte(splitted[i * 3]);\r\n        intervals[i][1] = Byte.parseByte(splitted[i * 3 + 1]);\r\n        intervals[i][2] = Byte.parseByte(splitted[i * 3 + 2]);\r\n    }\r\n    return ZoomIntervalConfiguration.newInstance(intervals);\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentWithData.wouldContain",
	"Comment": "returns whether the given set of key values will be in this segmentwhen it finishes loading.",
	"Method": "boolean wouldContain(Object[] keys){\r\n    Util.assertTrue(keys.length == axes.length);\r\n    for (int i = 0; i < keys.length; i++) {\r\n        Object key = keys[i];\r\n        if (!axes[i].wouldContain(key)) {\r\n            return false;\r\n        }\r\n    }\r\n    return !isExcluded(keys);\r\n}"
}, {
	"Path": "mondrian.rolap.SqlStatement.getDialect",
	"Comment": "retrieves dialect from schema or attempts to create itin case it is null",
	"Method": "Dialect getDialect(RolapSchema schema){\r\n    Dialect dialect = null;\r\n    if (schema != null && schema.getDialect() != null) {\r\n        dialect = schema.getDialect();\r\n    } else {\r\n        dialect = createDialect();\r\n    }\r\n    return dialect;\r\n}"
}, {
	"Path": "mondrian.util.ObjectPool.add",
	"Comment": "adds an object to the objectpool if it is notalready in the pool or returns the object that is already in thepool that matches the object being added.",
	"Method": "T add(T key){\r\n    int i = indexOfInsertion(key);\r\n    if (i < 0) {\r\n        i = -i - 1;\r\n        return this.values[i];\r\n    }\r\n    if (this.distinct > this.highWaterMark) {\r\n        int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);\r\n        rehash(newCapacity);\r\n        return add(key);\r\n    }\r\n    T v = this.values[i];\r\n    this.values[i] = key;\r\n    if (v == null) {\r\n        this.freeEntries--;\r\n    }\r\n    this.distinct++;\r\n    if (this.freeEntries < 1) {\r\n        int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);\r\n        rehash(newCapacity);\r\n    }\r\n    return key;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Title.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Title appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.structure.DrawerProfile.hasOnProfileClickListener",
	"Comment": "gets whether the drawer profile has a click listener set to it",
	"Method": "boolean hasOnProfileClickListener(){\r\n    return mOnClickListener != null;\r\n}"
}, {
	"Path": "net.engio.mbassy.bus.AbstractPubSubSupportTest.testHandlePublicationError_no_handlers_present_construct_with_config_async",
	"Comment": "test configuration that does not provide a publication error handler.this should print a warning message and fallback to stdout handler",
	"Method": "void testHandlePublicationError_no_handlers_present_construct_with_config_async(){\r\n    PrintStream old = null;\r\n    try {\r\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n        PrintStream ps = new PrintStream(baos);\r\n        old = System.out;\r\n        System.setOut(ps);\r\n        MBassador<String> bus = new MBassador<String>(configuration);\r\n        Assert.assertTrue(baos.toString().contains(AbstractPubSubSupport.ERROR_HANDLER_MSG));\r\n    } finally {\r\n        System.out.flush();\r\n        if (old != null) {\r\n            System.setOut(old);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.gui.SchemaTreeModel.arrayList",
	"Comment": "returns a list with a given set of elements, or an empty list if thearray is null.",
	"Method": "List<T> arrayList(T e){\r\n    return e == null || e.length == 0 ? Collections.<T>emptyList() : e.length == 1 ? Collections.singletonList(e[0]) : Arrays.asList(e);\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCacheRegion.getPredicate",
	"Comment": "returns the predicate associated with thecolumnordinalth column.",
	"Method": "StarColumnPredicate getPredicate(int columnOrdinal,StarColumnPredicate getPredicate,String columnName){\r\n    return columnPredicatesByName.get(columnName);\r\n}"
}, {
	"Path": "mondrian.calc.impl.AbstractCalc.anyDepends",
	"Comment": "returns true if one of the calcs depends on the given dimension.",
	"Method": "boolean anyDepends(Calc[] calcs,Hierarchy hierarchy){\r\n    for (Calc calc : calcs) {\r\n        if (calc != null && calc.dependsOn(hierarchy)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.msgpack.core.MessagePacker.packInt",
	"Comment": "writes an integer value.this method writes an integer using the smallest format from the int format family.",
	"Method": "MessagePacker packInt(int r){\r\n    if (r < -(1 << 5)) {\r\n        if (r < -(1 << 15)) {\r\n            writeByteAndInt(INT32, r);\r\n        } else if (r < -(1 << 7)) {\r\n            writeByteAndShort(INT16, (short) r);\r\n        } else {\r\n            writeByteAndByte(INT8, (byte) r);\r\n        }\r\n    } else if (r < (1 << 7)) {\r\n        writeByte((byte) r);\r\n    } else {\r\n        if (r < (1 << 8)) {\r\n            writeByteAndByte(UINT8, (byte) r);\r\n        } else if (r < (1 << 16)) {\r\n            writeByteAndShort(UINT16, (short) r);\r\n        } else {\r\n            writeByteAndInt(UINT32, r);\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.oath.micro.server.s3.data.S3Utils.getAllSummaries",
	"Comment": "method returns list of all s3objectsummary objects, subject toreq parameters. multiple s3 calls will be performed if there aremore than 1000 elements there",
	"Method": "List<S3ObjectSummary> getAllSummaries(ListObjectsRequest req){\r\n    List<S3ObjectSummary> result = new ArrayList();\r\n    String marker = null;\r\n    ListObjectsRequest req2 = (ListObjectsRequest) req.clone();\r\n    ObjectListing listing;\r\n    do {\r\n        listing = client.listObjects(req2.withMarker(marker));\r\n        marker = listing.getNextMarker();\r\n        result.addAll(listing.getObjectSummaries());\r\n    } while (listing.isTruncated());\r\n    return result;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapMemberBaseTest.testShouldUseMemberFormatterForCaption",
	"Comment": "given rolap member.when caption is requested,then member formatter should be usedto return the formatted caption value.",
	"Method": "void testShouldUseMemberFormatterForCaption(){\r\n    MemberFormatter memberFormatter = mock(MemberFormatter.class);\r\n    when(level.getMemberFormatter()).thenReturn(memberFormatter);\r\n    when(memberFormatter.formatMember(rolapMemberBase)).thenReturn(FORMATTED_CAPTION);\r\n    String caption = rolapMemberBase.getCaption();\r\n    assertEquals(FORMATTED_CAPTION, caption);\r\n}"
}, {
	"Path": "mondrian.olap.Id.append",
	"Comment": "returns a new identifier consisting of this one with another segmentappended. does not modify this identifier.",
	"Method": "Id append(Segment segment){\r\n    List<Segment> newSegments = new ArrayList<Segment>(segments);\r\n    newSegments.add(segment);\r\n    return new Id(newSegments);\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentCacheWorker.initCache",
	"Comment": "instantiates a cache. returns null if there is no external cache defined.",
	"Method": "List<SegmentCache> initCache(){\r\n    final List<SegmentCache> caches = new ArrayList<SegmentCache>();\r\n    final String cacheName = MondrianProperties.instance().SegmentCache.get();\r\n    if (cacheName != null) {\r\n        caches.add(instantiateCache(cacheName));\r\n    }\r\n    final List<Class<SegmentCache>> implementors = ServiceDiscovery.forClass(SegmentCache.class).getImplementor();\r\n    if (implementors.size() > 0) {\r\n        SegmentCache cache = instantiateCache(implementors.get(0).getName());\r\n        if (cache != null) {\r\n            caches.add(cache);\r\n        }\r\n    }\r\n    caches.addAll(SegmentCache.SegmentCacheInjector.getCaches());\r\n    return caches;\r\n}"
}, {
	"Path": "mondrian.tui.MockServletConfig.getServletContext",
	"Comment": "returns a reference to the servletcontext in which the servlet isexecuting.",
	"Method": "ServletContext getServletContext(){\r\n    return servletContext;\r\n}"
}, {
	"Path": "mondrian.xmla.XmlaUtil.rootThrowable",
	"Comment": "finds root mondrianexception in exception chain if exists,otherwise the input throwable.",
	"Method": "Throwable rootThrowable(Throwable throwable){\r\n    Throwable rootThrowable = throwable.getCause();\r\n    if (rootThrowable != null && rootThrowable instanceof MondrianException) {\r\n        return rootThrowable(rootThrowable);\r\n    }\r\n    return throwable;\r\n}"
}, {
	"Path": "mondrian.olap.Query.setVirtualCubeNonNativeCrossJoin",
	"Comment": "indicates that the query cannot use native cross joins to processthis virtual cube",
	"Method": "void setVirtualCubeNonNativeCrossJoin(){\r\n    nativeCrossJoinVirtualCube = false;\r\n}"
}, {
	"Path": "mondrian.gui.PropertyTableModel.getColumnCount",
	"Comment": "returns the number of columns in the model. ajtable uses this method to determine how many columns itshould create and display by default.",
	"Method": "int getColumnCount(){\r\n    return 2;\r\n}"
}, {
	"Path": "org.mapsforge.map.model.DisplayModel.getTileSize",
	"Comment": "width and height of a map tile in pixel after system and user scaling is applied.",
	"Method": "int getTileSize(){\r\n    return tileSize;\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlImpl.normalize",
	"Comment": "normalizes a cellregion into a union of crossjoins of member regions.",
	"Method": "UnionCellRegion normalize(CellRegionImpl region){\r\n    List<CellRegionImpl> nonUnionList = new LinkedList<CellRegionImpl>();\r\n    flattenUnion(region, nonUnionList);\r\n    for (int i = 0; i < nonUnionList.size(); i++) {\r\n        while (true) {\r\n            CellRegionImpl nonUnionRegion = nonUnionList.get(i);\r\n            UnionCellRegion firstUnion = findFirstUnion(nonUnionRegion);\r\n            if (firstUnion == null) {\r\n                break;\r\n            }\r\n            List<CellRegionImpl> list = new ArrayList<CellRegionImpl>();\r\n            for (CellRegionImpl unionComponent : firstUnion.regions) {\r\n                CellRegionImpl cj = copyReplacing(nonUnionRegion, firstUnion, unionComponent);\r\n                list.add(cj);\r\n            }\r\n            nonUnionList.remove(i);\r\n            nonUnionList.addAll(i, list);\r\n        }\r\n    }\r\n    return new UnionCellRegion(nonUnionList);\r\n}"
}, {
	"Path": "mondrian.test.NativeSetEvaluationTest.testTopCountWithAggregatedMemberAggStar",
	"Comment": "now that some native evaluation is supporting aggregated members, weneed to push that logic down to the aggstar selection",
	"Method": "void testTopCountWithAggregatedMemberAggStar(){\r\n    propSaver.set(propSaver.properties.UseAggregates, true);\r\n    propSaver.set(propSaver.properties.ReadAggregates, true);\r\n    propSaver.set(propSaver.properties.GenerateFormattedSql, true);\r\n    final String mdx = \"with member [Time.Weekly].x as Aggregate([Time.Weekly].[1997].Children) \" + \"set products as \" + \"'TopCount([Product].[Product Department].Members, 2, \" + \"[Measures].[Store Sales])' \" + \"select NON EMPTY {[Measures].[Store Sales]} ON COLUMNS, \" + \"NON EMPTY [products] ON ROWS \" + \" from [Sales] where [Time.Weekly].[x]\";\r\n    final String mysql = \"select\\n\" + \"    `product_class`.`product_family` as `c0`,\\n\" + \"    `product_class`.`product_department` as `c1`,\\n\" + \"    sum(`agg_pl_01_sales_fact_1997`.`store_sales_sum`) as `c2`\\n\" + \"from\\n\" + \"    `product` as `product`,\\n\" + \"    `product_class` as `product_class`,\\n\" + \"    `agg_pl_01_sales_fact_1997` as `agg_pl_01_sales_fact_1997`,\\n\" + \"    `time_by_day` as `time_by_day`\\n\" + \"where\\n\" + \"    `product`.`product_class_id` = `product_class`.`product_class_id`\\n\" + \"and\\n\" + \"    `agg_pl_01_sales_fact_1997`.`product_id` = `product`.`product_id`\\n\" + \"and\\n\" + \"    `agg_pl_01_sales_fact_1997`.`time_id` = `time_by_day`.`time_id`\\n\" + \"and\\n\" + \"    `time_by_day`.`the_year` = 1997\\n\" + \"and\\n\" + \"    `time_by_day`.`week_of_year` in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52)\\n\" + \"group by\\n\" + \"    `product_class`.`product_family`,\\n\" + \"    `product_class`.`product_department`\\n\" + \"order by\\n\" + (TestContext.instance().getDialect().requiresOrderByAlias() ? \"    `c2` DESC,\\n\" + \"    ISNULL(`c0`) ASC, `c0` ASC,\\n\" + \"    ISNULL(`c1`) ASC, `c1` ASC\" : \"    sum(`agg_pl_01_sales_fact_1997`.`store_sales_sum`) DESC,\\n\" + \"    ISNULL(`product_class`.`product_family`) ASC, `product_class`.`product_family` ASC,\\n\" + \"    ISNULL(`product_class`.`product_department`) ASC, `product_class`.`product_department` ASC\");\r\n    SqlPattern mysqlPattern = new SqlPattern(DatabaseProduct.MYSQL, mysql, mysql);\r\n    if (MondrianProperties.instance().EnableNativeTopCount.get()) {\r\n        assertQuerySql(mdx, new SqlPattern[] { mysqlPattern });\r\n    }\r\n    assertQueryReturns(mdx, \"Axis #0:\\n\" + \"{[Time].[Weekly].[x]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Store Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Product].[Food].[Produce]}\\n\" + \"{[Product].[Food].[Snack Foods]}\\n\" + \"Row #0: 82,248.42\\n\" + \"Row #1: 67,609.82\\n\");\r\n}"
}, {
	"Path": "mondrian.test.DynamicSchemaProcessorTest.testFoodmartDsp",
	"Comment": "tests to make sure that our base dynamicschemaprocessor works, andmondrian is able to parse and connect to foodmart with it",
	"Method": "void testFoodmartDsp(){\r\n    final Connection monConnection = TestContext.instance().withSchemaProcessor(BaseDsp.class).getConnection();\r\n    assertEquals(monConnection.getSchema().getName(), \"REPLACEME\");\r\n}"
}, {
	"Path": "org.mapsforge.map.android.util.MapViewerTemplate.getScreenRatio",
	"Comment": "returns the relative size of a map view in relation to the screen size of the device. thisis used for cache size calculations.by default this returns 1.0, for a full size map view.",
	"Method": "float getScreenRatio(){\r\n    return 1.0f;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapMemberBaseTest.testShouldReturnMemberKeyIfNoCaptionValueAndNoNamePresent",
	"Comment": "given rolap member with neither caption value nor name specified.when caption raw value is requested,then member key should be returned.",
	"Method": "void testShouldReturnMemberKeyIfNoCaptionValueAndNoNamePresent(){\r\n    Object captionValue = rolapMemberBase.getCaptionValue();\r\n    assertNotNull(captionValue);\r\n    assertEquals(memberKey, captionValue);\r\n}"
}, {
	"Path": "mondrian.olap.Util.readVirtualFile",
	"Comment": "gets content via apache vfs. file must exist and have content",
	"Method": "InputStream readVirtualFile(String url){\r\n    FileSystemManager fsManager = VFS.getManager();\r\n    if (fsManager == null) {\r\n        throw newError(\"Cannot get virtual file system manager\");\r\n    }\r\n    if (url.startsWith(\"file://localhost\")) {\r\n        url = url.substring(\"file://localhost\".length());\r\n    }\r\n    if (url.startsWith(\"file:\")) {\r\n        url = url.substring(\"file:\".length());\r\n    }\r\n    if (url.startsWith(\"http\")) {\r\n        try {\r\n            return new URL(url).openStream();\r\n        } catch (IOException e) {\r\n            throw newError(\"Could not read URL: \" + url);\r\n        }\r\n    }\r\n    File userDir = new File(\"\").getAbsoluteFile();\r\n    FileObject file = fsManager.resolveFile(userDir, url);\r\n    FileContent fileContent = null;\r\n    try {\r\n        file.refresh();\r\n        if (file instanceof HttpFileObject && !file.getName().getURI().equals(url)) {\r\n            fsManager.getFilesCache().removeFile(file.getFileSystem(), file.getName());\r\n            file = fsManager.resolveFile(userDir, url);\r\n        }\r\n        if (!file.isReadable()) {\r\n            throw newError(\"Virtual file is not readable: \" + url);\r\n        }\r\n        fileContent = file.getContent();\r\n    } finally {\r\n        file.close();\r\n    }\r\n    if (fileContent == null) {\r\n        throw newError(\"Cannot get virtual file content: \" + url);\r\n    }\r\n    return fileContent.getInputStream();\r\n}"
}, {
	"Path": "org.mapsforge.map.android.util.MapViewerTemplate.getMapFile",
	"Comment": "combines map file directory and map file to a map file.this method usually will not need to be changed.",
	"Method": "MapDataStore getMapFile(){\r\n    return new MapFile(new File(getMapFileDirectory(), this.getMapFileName()));\r\n}"
}, {
	"Path": "mondrian.rolap.DataSourceChangeListenerTest.checkCacheFlushing",
	"Comment": "tests several threads, each of which is creating connections andperiodically flushing the schema cache.",
	"Method": "void checkCacheFlushing(int workerCount,int cycleCount){\r\n    final Random random = new Random(123456);\r\n    Worker[] workers = new Worker[workerCount];\r\n    Thread[] threads = new Thread[workerCount];\r\n    final String[] queries = { \"with member [Store Type].[All Types] as 'Aggregate({[Store Type].[All Store Types].[Deluxe Supermarket],  \" + \"[Store Type].[All Store Types].[Gourmet Supermarket],  \" + \"[Store Type].[All Store Types].[HeadQuarters],  \" + \"[Store Type].[All Store Types].[Mid-Size Grocery],  \" + \"[Store Type].[All Store Types].[Small Grocery],  \" + \"[Store Type].[All Store Types].[Supermarket]})'  \" + \"select NON EMPTY {[Time].[1997]} ON COLUMNS,   \" + \"NON EMPTY [Store].[All Stores].[USA].[CA].Children ON ROWS   \" + \"from [Sales] \" + \"where ([Store Type].[All Types], [Measures].[Unit Sales], [Customers].[All Customers].[USA], [Product].[All Products].[Drink])  \", \"with member [Measures].[Shipped per Ordered] as ' [Measures].[Units Shipped] / [Measures].[Unit Sales] ', format_string='#.00%'\\n\" + \" member [Measures].[Profit per Unit Shipped] as ' [Measures].[Profit] / [Measures].[Units Shipped] '\\n\" + \"select\\n\" + \" {[Measures].[Unit Sales], \\n\" + \"  [Measures].[Units Shipped],\\n\" + \"  [Measures].[Shipped per Ordered],\\n\" + \"  [Measures].[Profit per Unit Shipped]} on 0,\\n\" + \" NON EMPTY Crossjoin([Product].Children, [Time].[1997].Children) on 1\\n\" + \"from [Warehouse and Sales]\", \"select {[Measures].[Profit Per Unit Shipped]} ON COLUMNS, \" + \"{[Store].[All Stores].[USA].[CA], [Store].[All Stores].[USA].[OR], [Store].[All Stores].[USA].[WA]} ON ROWS \" + \"from [Warehouse and Sales Format Expression Cube No Cache] \" + \"where [Time].[1997]\", \"select {[Store].[All Stores].[USA].[CA].[San Francisco]} on columns from [Sales]\" };\r\n    final String[] results = { \"Axis #0:\\n\" + \"{[Store Type].[All Types], [Measures].[Unit Sales], [Customers].[USA], [Product].[Drink]}\\n\" + \"Axis #1:\\n\" + \"{[Time].[1997]}\\n\" + \"Axis #2:\\n\" + \"{[Store].[USA].[CA].[Beverly Hills]}\\n\" + \"{[Store].[USA].[CA].[Los Angeles]}\\n\" + \"{[Store].[USA].[CA].[San Diego]}\\n\" + \"{[Store].[USA].[CA].[San Francisco]}\\n\" + \"Row #0: 1,945\\n\" + \"Row #1: 2,422\\n\" + \"Row #2: 2,560\\n\" + \"Row #3: 175\\n\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"{[Measures].[Units Shipped]}\\n\" + \"{[Measures].[Shipped per Ordered]}\\n\" + \"{[Measures].[Profit per Unit Shipped]}\\n\" + \"Axis #2:\\n\" + \"{[Product].[Drink], [Time].[1997].[Q1]}\\n\" + \"{[Product].[Drink], [Time].[1997].[Q2]}\\n\" + \"{[Product].[Drink], [Time].[1997].[Q3]}\\n\" + \"{[Product].[Drink], [Time].[1997].[Q4]}\\n\" + \"{[Product].[Food], [Time].[1997].[Q1]}\\n\" + \"{[Product].[Food], [Time].[1997].[Q2]}\\n\" + \"{[Product].[Food], [Time].[1997].[Q3]}\\n\" + \"{[Product].[Food], [Time].[1997].[Q4]}\\n\" + \"{[Product].[Non-Consumable], [Time].[1997].[Q1]}\\n\" + \"{[Product].[Non-Consumable], [Time].[1997].[Q2]}\\n\" + \"{[Product].[Non-Consumable], [Time].[1997].[Q3]}\\n\" + \"{[Product].[Non-Consumable], [Time].[1997].[Q4]}\\n\" + \"Row #0: 5,976\\n\" + \"Row #0: 4637.0\\n\" + \"Row #0: 77.59%\\n\" + \"Row #0: $1.50\\n\" + \"Row #1: 5,895\\n\" + \"Row #1: 4501.0\\n\" + \"Row #1: 76.35%\\n\" + \"Row #1: $1.60\\n\" + \"Row #2: 6,065\\n\" + \"Row #2: 6258.0\\n\" + \"Row #2: 103.18%\\n\" + \"Row #2: $1.15\\n\" + \"Row #3: 6,661\\n\" + \"Row #3: 5802.0\\n\" + \"Row #3: 87.10%\\n\" + \"Row #3: $1.38\\n\" + \"Row #4: 47,809\\n\" + \"Row #4: 37153.0\\n\" + \"Row #4: 77.71%\\n\" + \"Row #4: $1.64\\n\" + \"Row #5: 44,825\\n\" + \"Row #5: 35459.0\\n\" + \"Row #5: 79.11%\\n\" + \"Row #5: $1.62\\n\" + \"Row #6: 47,440\\n\" + \"Row #6: 41545.0\\n\" + \"Row #6: 87.57%\\n\" + \"Row #6: $1.47\\n\" + \"Row #7: 51,866\\n\" + \"Row #7: 34706.0\\n\" + \"Row #7: 66.91%\\n\" + \"Row #7: $1.91\\n\" + \"Row #8: 12,506\\n\" + \"Row #8: 9161.0\\n\" + \"Row #8: 73.25%\\n\" + \"Row #8: $1.76\\n\" + \"Row #9: 11,890\\n\" + \"Row #9: 9227.0\\n\" + \"Row #9: 77.60%\\n\" + \"Row #9: $1.65\\n\" + \"Row #10: 12,343\\n\" + \"Row #10: 9986.0\\n\" + \"Row #10: 80.90%\\n\" + \"Row #10: $1.59\\n\" + \"Row #11: 13,497\\n\" + \"Row #11: 9291.0\\n\" + \"Row #11: 68.84%\\n\" + \"Row #11: $1.86\\n\", \"Axis #0:\\n\" + \"{[Time].[1997]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Profit Per Unit Shipped]}\\n\" + \"Axis #2:\\n\" + \"{[Store].[USA].[CA]}\\n\" + \"{[Store].[USA].[OR]}\\n\" + \"{[Store].[USA].[WA]}\\n\" + \"Row #0: |1.6|style=red\\n\" + \"Row #1: |2.1|style=green\\n\" + \"Row #2: |1.5|style=red\\n\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Store].[USA].[CA].[San Francisco]}\\n\" + \"Row #0: 2,117\\n\" };\r\n    final TestContext testContext = TestContext.instance().create(null, null, \"<Cube name=\\\"Warehouse No Cache\\\" cache=\\\"false\\\">\\n\" + \"  <Table name=\\\"inventory_fact_1997\\\"/>\\n\" + \"\\n\" + \"  <DimensionUsage name=\\\"Time\\\" source=\\\"Time\\\" foreignKey=\\\"time_id\\\"/>\\n\" + \"  <DimensionUsage name=\\\"Store\\\" source=\\\"Store\\\" foreignKey=\\\"store_id\\\"/>\\n\" + \"  <Measure name=\\\"Units Shipped\\\" column=\\\"units_shipped\\\" aggregator=\\\"sum\\\" formatString=\\\"#.0\\\"/>\\n\" + \"<\/Cube>\\n\" + \"<VirtualCube name=\\\"Warehouse and Sales Format Expression Cube No Cache\\\">\\n\" + \"  <VirtualCubeDimension name=\\\"Store\\\"/>\\n\" + \"  <VirtualCubeDimension name=\\\"Time\\\"/>\\n\" + \"  <VirtualCubeMeasure cubeName=\\\"Sales\\\" name=\\\"[Measures].[Store Cost]\\\"/>\\n\" + \"  <VirtualCubeMeasure cubeName=\\\"Sales\\\" name=\\\"[Measures].[Store Sales]\\\"/>\\n\" + \"  <VirtualCubeMeasure cubeName=\\\"Warehouse No Cache\\\" name=\\\"[Measures].[Units Shipped]\\\"/>\\n\" + \"  <CalculatedMember name=\\\"Profit\\\" dimension=\\\"Measures\\\">\\n\" + \"    <Formula>[Measures].[Store Sales] - [Measures].[Store Cost]<\/Formula>\\n\" + \"  <\/CalculatedMember>\\n\" + \"  <CalculatedMember name=\\\"Profit Per Unit Shipped\\\" dimension=\\\"Measures\\\">\\n\" + \"    <Formula>[Measures].[Profit] / [Measures].[Units Shipped]<\/Formula>\\n\" + \"    <CalculatedMemberProperty name=\\\"FORMAT_STRING\\\" expression=\\\"IIf(([Measures].[Profit Per Unit Shipped] > 2.0), '|0.#|style=green', '|0.#|style=red')\\\"/>\\n\" + \"  <\/CalculatedMember>\\n\" + \"<\/VirtualCube>\", null, null, null);\r\n    SmartMemberReader smrStore = getSmartMemberReader(testContext.getConnection(), \"Store\");\r\n    MemberCacheHelper smrStoreCacheHelper = (MemberCacheHelper) smrStore.getMemberCache();\r\n    SmartMemberReader smrProduct = getSmartMemberReader(testContext.getConnection(), \"Product\");\r\n    MemberCacheHelper smrProductCacheHelper = (MemberCacheHelper) smrProduct.getMemberCache();\r\n    smrStoreCacheHelper.changeListener = new DataSourceChangeListenerImpl4(500, 50);\r\n    smrProductCacheHelper.changeListener = smrStoreCacheHelper.changeListener;\r\n    RolapStar star = getStar(testContext.getConnection(), \"Sales\");\r\n    star.setChangeListener(smrStoreCacheHelper.changeListener);\r\n    star = getStar(testContext.getConnection(), \"Warehouse No Cache\");\r\n    star.setChangeListener(smrStoreCacheHelper.changeListener);\r\n    for (int i = 0; i < workerCount; i++) {\r\n        workers[i] = new Worker() {\r\n            public void runSafe() {\r\n                for (int i = 0; i < cycleCount; ++i) {\r\n                    cycle();\r\n                    try {\r\n                        Thread.sleep(random.nextInt(100));\r\n                    } catch (InterruptedException e) {\r\n                        throw Util.newInternal(e, \"interrupted\");\r\n                    }\r\n                }\r\n            }\r\n            private void cycle() {\r\n                int idx = random.nextInt(4);\r\n                String query = queries[idx];\r\n                String result = results[idx];\r\n                testContext.assertQueryReturns(query, result);\r\n            }\r\n        };\r\n        threads[i] = new Thread(workers[i]);\r\n    }\r\n    for (int i = 0; i < workerCount; i++) {\r\n        threads[i].start();\r\n    }\r\n    for (int i = 0; i < workerCount; i++) {\r\n        try {\r\n            threads[i].join();\r\n        } catch (InterruptedException e) {\r\n            throw Util.newInternal(e, \"while joining thread #\" + i);\r\n        }\r\n    }\r\n    List<String> messages = new ArrayList<String>();\r\n    for (Worker worker : workers) {\r\n        for (Throwable throwable : worker.failures) {\r\n            messages.add(TestContext.getStackTrace(throwable));\r\n        }\r\n    }\r\n    if (!messages.isEmpty()) {\r\n        fail(messages.size() + \" threads failed\\n\" + messages);\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.DataSourceChangeListenerTest.checkCacheFlushing",
	"Comment": "tests several threads, each of which is creating connections andperiodically flushing the schema cache.",
	"Method": "void checkCacheFlushing(int workerCount,int cycleCount){\r\n    for (int i = 0; i < cycleCount; ++i) {\r\n        cycle();\r\n        try {\r\n            Thread.sleep(random.nextInt(100));\r\n        } catch (InterruptedException e) {\r\n            throw Util.newInternal(e, \"interrupted\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.DataSourceChangeListenerTest.checkCacheFlushing",
	"Comment": "tests several threads, each of which is creating connections andperiodically flushing the schema cache.",
	"Method": "void checkCacheFlushing(int workerCount,int cycleCount){\r\n    int idx = random.nextInt(4);\r\n    String query = queries[idx];\r\n    String result = results[idx];\r\n    testContext.assertQueryReturns(query, result);\r\n}"
}, {
	"Path": "mondrian.util.Bug.avoidMemoryOverflow",
	"Comment": "returns whether to avoid a test because the memory monitor may cause itto fail.some tests fail if memory monitor is switched on, and access andderby tend to use a lot of memory because they are embedded.",
	"Method": "boolean avoidMemoryOverflow(Dialect dialect){\r\n    return dialect.getDatabaseProduct() == Dialect.DatabaseProduct.ACCESS && MondrianProperties.instance().MemoryMonitor.get();\r\n}"
}, {
	"Path": "org.mapsforge.map.layer.cache.InMemoryTileCache.setCapacity",
	"Comment": "sets the new size of this cache. if this cache already contains more items than the new capacity allows, itemsare discarded based on the cache policy.",
	"Method": "void setCapacity(int capacity){\r\n    BitmapLRUCache lruCacheNew = new BitmapLRUCache(capacity);\r\n    lruCacheNew.putAll(this.lruCache);\r\n    this.lruCache = lruCacheNew;\r\n}"
}, {
	"Path": "mondrian.olap.Util.getMatchingCause",
	"Comment": "if one of the causes of an exception is of a particular class, returnsthat cause. otherwise returns null.",
	"Method": "T getMatchingCause(Throwable e,Class<T> clazz){\r\n    for (; ; ) {\r\n        if (clazz.isInstance(e)) {\r\n            return clazz.cast(e);\r\n        }\r\n        final Throwable cause = e.getCause();\r\n        if (cause == null || cause == e) {\r\n            return null;\r\n        }\r\n        e = cause;\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.core.util.MercatorProjection.getPixelRelativeToTile",
	"Comment": "calculates the absolute pixel position for a tile and tile size relative to origin",
	"Method": "Point getPixelRelativeToTile(LatLong latLong,Tile tile){\r\n    return getPixelRelative(latLong, tile.mapSize, tile.getOrigin());\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.widget.LinearListView.setOnItemClickListener",
	"Comment": "register a callback to be invoked when an item in this linearlistview hasbeen clicked.",
	"Method": "void setOnItemClickListener(OnItemClickListener listener){\r\n    mOnItemClickListener = listener;\r\n}"
}, {
	"Path": "com.meetup.memcached.MemcachedClient.decr",
	"Comment": "decrement the value at the specified key by the specified increment, and then return it.",
	"Method": "long decr(String key,long decr,String key,long inc,long decr,String key,long inc,Integer hashCode){\r\n    return incrdecr(\"decr\", key, inc, hashCode);\r\n}"
}, {
	"Path": "net.engio.mbassy.subscription.Subscription.belongsTo",
	"Comment": "check whether this subscription manages a message handler of the given listener class.",
	"Method": "boolean belongsTo(Class listener){\r\n    return context.getHandler().isFromListener(listener);\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.JdbcSchema.convertColumnTypeToName",
	"Comment": "maps from column type enum to column type name or list of names if theparameter represents more than on usage.",
	"Method": "String convertColumnTypeToName(Set<UsageType> columnType){\r\n    if (columnType.size() == 1) {\r\n        return columnType.iterator().next().name();\r\n    }\r\n    StringBuilder buf = new StringBuilder();\r\n    int k = 0;\r\n    for (UsageType usage : columnType) {\r\n        if (k++ > 0) {\r\n            buf.append('|');\r\n        }\r\n        buf.append(usage.name());\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.mapsforge.core.graphics.GraphicUtils.imageSize",
	"Comment": "given the original image size, as well as width, height, percent parameters,can compute the final image size.",
	"Method": "float[] imageSize(float picWidth,float picHeight,float scaleFactor,int width,int height,int percent){\r\n    float bitmapWidth = picWidth * scaleFactor;\r\n    float bitmapHeight = picHeight * scaleFactor;\r\n    float aspectRatio = picWidth / picHeight;\r\n    if (width != 0 && height != 0) {\r\n        bitmapWidth = width;\r\n        bitmapHeight = height;\r\n    } else if (width == 0 && height != 0) {\r\n        bitmapWidth = height * aspectRatio;\r\n        bitmapHeight = height;\r\n    } else if (width != 0 && height == 0) {\r\n        bitmapHeight = width / aspectRatio;\r\n        bitmapWidth = width;\r\n    }\r\n    if (percent != 100) {\r\n        bitmapWidth *= percent / 100f;\r\n        bitmapHeight *= percent / 100f;\r\n    }\r\n    return new float[] { bitmapWidth, bitmapHeight };\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.DrawerView.hasOnProfileSwitchListener",
	"Comment": "gets whether the drawer has a profile switch listener set to it",
	"Method": "boolean hasOnProfileSwitchListener(){\r\n    return onProfileSwitchListener != null;\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getContextPath",
	"Comment": "returns the portion of the request uri that indicates the context of therequest.",
	"Method": "String getContextPath(){\r\n    return contextPath;\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.getCorrespondingMember",
	"Comment": "returns the corresponding member from tuple, or the default memberfor the hierarchy if member is not explicitly contained in the tuple.",
	"Method": "Member getCorrespondingMember(Member member,List<Member> tuple,List<Hierarchy> tupleHierarchies,Evaluator eval){\r\n    assert tuple.size() == tupleHierarchies.size();\r\n    int dimPos = tupleHierarchies.indexOf(member.getHierarchy());\r\n    if (dimPos >= 0) {\r\n        return tuple.get(dimPos);\r\n    } else if (eval != null) {\r\n        return eval.getContext(member.getHierarchy());\r\n    } else {\r\n        return member.getHierarchy().getDefaultMember();\r\n    }\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getRemoteUser",
	"Comment": "returns the login of the user making this request, if the user has beenauthenticated, or null if the user has not been authenticated.",
	"Method": "String getRemoteUser(){\r\n    return remoteUser;\r\n}"
}, {
	"Path": "mondrian.olap.MemberBase.getOrderKey",
	"Comment": "returns the order key of this member among its siblings.the default implementation returns null.",
	"Method": "Comparable getOrderKey(){\r\n    return null;\r\n}"
}, {
	"Path": "org.sqlite.database.DatabaseUtils.longForQuery",
	"Comment": "utility method to run the query on the db and return the value in thefirst column of the first row.",
	"Method": "long longForQuery(SQLiteDatabase db,String query,String[] selectionArgs,long longForQuery,SQLiteStatement prog,String[] selectionArgs){\r\n    prog.bindAllArgsAsStrings(selectionArgs);\r\n    return prog.simpleQueryForLong();\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.BestLocationListener.updateLastKnownLocation",
	"Comment": "updates the current location with the last known location withoutregistering any location listeners.",
	"Method": "void updateLastKnownLocation(LocationManager locationManager){\r\n    List<String> providers = locationManager.getProviders(true);\r\n    for (int i = 0, providersCount = providers.size(); i < providersCount; i++) {\r\n        String providerName = providers.get(i);\r\n        if (locationManager.isProviderEnabled(providerName)) {\r\n            updateLocation(locationManager.getLastKnownLocation(providerName));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.RolapResultShepherd.shepherdExecution",
	"Comment": "executes and shepherds the execution of an execution instance.the shepherd will wrap the execution instance into a future objectwhich can be monitored for exceptions. if any are encountered,two things will happen. first, the user thread will be returned andthe resulting exception will bubble up. second, the execution threadwill attempt to do a graceful stop of all running sql statements andrelease all other resources gracefully in the background.",
	"Method": "Result shepherdExecution(Execution execution,Callable<Result> callable){\r\n    FutureTask<Result> task = new FutureTask<Result>(callable);\r\n    final Pair<FutureTask<Result>, Execution> pair = new Pair<FutureTask<Result>, Execution>(task, execution);\r\n    tasks.add(pair);\r\n    try {\r\n        executor.execute(task);\r\n        return task.get();\r\n    } catch (Throwable e) {\r\n        execution.cancelSqlStatements();\r\n        if (e instanceof InterruptedException) {\r\n            Thread.currentThread().interrupt();\r\n        }\r\n        Throwable node = e;\r\n        if (e instanceof ExecutionException) {\r\n            ExecutionException executionException = (ExecutionException) e;\r\n            node = executionException.getCause();\r\n        }\r\n        execution.checkCancelOrTimeout();\r\n        final ResourceLimitExceededException t = Util.getMatchingCause(node, ResourceLimitExceededException.class);\r\n        if (t != null) {\r\n            throw t;\r\n        }\r\n        final MondrianException m = Util.getMatchingCause(node, MondrianException.class);\r\n        if (m != null) {\r\n            throw m;\r\n        }\r\n        if (node instanceof RuntimeException) {\r\n            throw (RuntimeException) node;\r\n        } else if (node instanceof Error) {\r\n            throw (Error) node;\r\n        } else {\r\n            throw new MondrianException(node);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.FastBatchingCellReaderTest.testAggregateDistinctCount5",
	"Comment": "fix a problem when genergating predicates for distinct count aggregateloading and using the aggregate function in the slicer.",
	"Method": "void testAggregateDistinctCount5(){\r\n    propSaver.set(propSaver.properties.MaxConstraints, 2);\r\n    String query = \"With \" + \"Set [Products] as \" + \" '{[Product].[Drink], \" + \"   [Product].[Food], \" + \"   [Product].[Non-Consumable]}' \" + \"Member [Product].[Selected Products] as \" + \" 'Aggregate([Products])', SOLVE_ORDER=2 \" + \"Select \" + \" {[Store].[Store State].Members} on rows, \" + \" {[Measures].[Customer Count]} on columns \" + \"From [Sales] \" + \"Where ([Product].[Selected Products])\";\r\n    String derbySql = \"select \\\"store\\\".\\\"store_state\\\" as \\\"c0\\\", \" + \"\\\"time_by_day\\\".\\\"the_year\\\" as \\\"c1\\\", \" + \"count(distinct \\\"sales_fact_1997\\\".\\\"customer_id\\\") as \\\"m0\\\" \" + \"from \\\"store\\\" as \\\"store\\\", \\\"sales_fact_1997\\\" as \\\"sales_fact_1997\\\", \" + \"\\\"time_by_day\\\" as \\\"time_by_day\\\" \" + \"where \\\"sales_fact_1997\\\".\\\"store_id\\\" = \\\"store\\\".\\\"store_id\\\" \" + \"and \\\"sales_fact_1997\\\".\\\"time_id\\\" = \\\"time_by_day\\\".\\\"time_id\\\" \" + \"and \\\"time_by_day\\\".\\\"the_year\\\" = 1997 \" + \"group by \\\"store\\\".\\\"store_state\\\", \\\"time_by_day\\\".\\\"the_year\\\"\";\r\n    String mysqlSql = \"select `store`.`store_state` as `c0`, `time_by_day`.`the_year` as `c1`, \" + \"count(distinct `sales_fact_1997`.`customer_id`) as `m0` \" + \"from `store` as `store`, `sales_fact_1997` as `sales_fact_1997`, \" + \"`time_by_day` as `time_by_day` \" + \"where `sales_fact_1997`.`store_id` = `store`.`store_id` \" + \"and `sales_fact_1997`.`time_id` = `time_by_day`.`time_id` \" + \"and `time_by_day`.`the_year` = 1997 \" + \"group by `store`.`store_state`, `time_by_day`.`the_year`\";\r\n    SqlPattern[] patterns = { new SqlPattern(Dialect.DatabaseProduct.DERBY, derbySql, derbySql), new SqlPattern(Dialect.DatabaseProduct.MYSQL, mysqlSql, mysqlSql) };\r\n    assertQuerySql(query, patterns);\r\n}"
}, {
	"Path": "mondrian.rolap.FastBatchingCellReaderTest.testAggregateDistinctCount6",
	"Comment": "test for multiple members on different levels within the same hierarchy.",
	"Method": "void testAggregateDistinctCount6(){\r\n    final String mdxQuery = \"WITH \" + \" MEMBER [Store].[Select Region] AS \" + \" 'AGGREGATE({[Store].[USA].[CA], [Store].[Mexico], [Store].[Canada], [Store].[USA].[OR]})', solve_order=1\\n\" + \" MEMBER [Time].[Time].[Select Time Period] AS \" + \" 'AGGREGATE({[Time].[1997].[Q1], [Time].[1997].[Q3].[7], [Time].[1997].[Q4], [Time].[1997]})', solve_order=1\\n\" + \"SELECT {[Measures].[Customer Count], [Measures].[Unit Sales]} ON COLUMNS,\\n\" + \"      Union({[Store].[Select Region]} * {[Time].[Select Time Period]},\" + \"      Union({[Store].[Select Region]} * {[Time].[1997].[Q1]},\" + \"      Union({[Store].[Select Region]} * {[Time].[1997].[Q3].[7]},\" + \"      Union({[Store].[Select Region]} * {[Time].[1997].[Q4]},\" + \"            {[Store].[Select Region]} * {[Time].[1997]})))) \" + \"ON ROWS\\n\" + \"FROM Sales\";\r\n    String result = \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Customer Count]}\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Store].[Select Region], [Time].[Select Time Period]}\\n\" + \"{[Store].[Select Region], [Time].[1997].[Q1]}\\n\" + \"{[Store].[Select Region], [Time].[1997].[Q3].[7]}\\n\" + \"{[Store].[Select Region], [Time].[1997].[Q4]}\\n\" + \"{[Store].[Select Region], [Time].[1997]}\\n\" + \"Row #0: 3,753\\n\" + \"Row #0: 229,496\\n\" + \"Row #1: 1,877\\n\" + \"Row #1: 36,177\\n\" + \"Row #2: 845\\n\" + \"Row #2: 13,123\\n\" + \"Row #3: 2,073\\n\" + \"Row #3: 37,789\\n\" + \"Row #4: 3,753\\n\" + \"Row #4: 142,407\\n\";\r\n    assertQueryReturns(mdxQuery, result);\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testAllMembersNECJ2",
	"Comment": "verify that the native evaluation is possible if one input does notcontain the all member.",
	"Method": "void testAllMembersNECJ2(){\r\n    propSaver.set(MondrianProperties.instance().EnableNativeCrossJoin, true);\r\n    boolean requestFreshConnection = true;\r\n    checkNative(0, 3, \"select \" + \"NonEmptyCrossJoin([Product].[All Products].Children, {[Store].[All Stores]}) on columns \" + \"from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Product].[Drink], [Store].[All Stores]}\\n\" + \"{[Product].[Food], [Store].[All Stores]}\\n\" + \"{[Product].[Non-Consumable], [Store].[All Stores]}\\n\" + \"Row #0: 24,597\\n\" + \"Row #0: 191,940\\n\" + \"Row #0: 50,236\\n\", requestFreshConnection);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Ol.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Ol appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AbstractQuerySpec.getPredicateList",
	"Comment": "returns a list of predicates not associated with a particular column.",
	"Method": "List<StarPredicate> getPredicateList(){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "mondrian.rolap.sql.CrossJoinArgFactory.checkCrossJoinArg",
	"Comment": "scans for memberchildren, levelmembers, memberdescendants, crossjoin.",
	"Method": "List<CrossJoinArg[]> checkCrossJoinArg(RolapEvaluator evaluator,Exp exp,List<CrossJoinArg[]> checkCrossJoinArg,RolapEvaluator evaluator,Exp exp,boolean returnAny){\r\n    if (exp instanceof NamedSetExpr) {\r\n        NamedSet namedSet = ((NamedSetExpr) exp).getNamedSet();\r\n        exp = namedSet.getExp();\r\n    }\r\n    if (!(exp instanceof ResolvedFunCall)) {\r\n        return null;\r\n    }\r\n    final ResolvedFunCall funCall = (ResolvedFunCall) exp;\r\n    FunDef fun = funCall.getFunDef();\r\n    Exp[] args = funCall.getArgs();\r\n    final Role role = evaluator.getSchemaReader().getRole();\r\n    CrossJoinArg[] cjArgs;\r\n    cjArgs = checkMemberChildren(role, fun, args);\r\n    if (cjArgs != null) {\r\n        return Collections.singletonList(cjArgs);\r\n    }\r\n    cjArgs = checkLevelMembers(role, fun, args);\r\n    if (cjArgs != null) {\r\n        return Collections.singletonList(cjArgs);\r\n    }\r\n    cjArgs = checkDescendants(role, fun, args);\r\n    if (cjArgs != null) {\r\n        return Collections.singletonList(cjArgs);\r\n    }\r\n    final boolean exclude = false;\r\n    cjArgs = checkEnumeration(evaluator, fun, args, exclude);\r\n    if (cjArgs != null) {\r\n        return Collections.singletonList(cjArgs);\r\n    }\r\n    if (returnAny) {\r\n        cjArgs = checkConstrainedMeasures(evaluator, fun, args);\r\n        if (cjArgs != null) {\r\n            return Collections.singletonList(cjArgs);\r\n        }\r\n    }\r\n    List<CrossJoinArg[]> allArgs = checkDimensionFilter(evaluator, fun, args);\r\n    if (allArgs != null) {\r\n        return allArgs;\r\n    }\r\n    if (\"{}\".equalsIgnoreCase(fun.getName()) && args.length == 1) {\r\n        return checkCrossJoinArg(evaluator, args[0], returnAny);\r\n    }\r\n    if (\"NativizeSet\".equalsIgnoreCase(fun.getName()) && args.length == 1) {\r\n        return checkCrossJoinArg(evaluator, args[0], returnAny);\r\n    }\r\n    return checkCrossJoin(evaluator, fun, args, returnAny);\r\n}"
}, {
	"Path": "org.mapsforge.core.model.LatLong.sphericalDistance",
	"Comment": "calculate the spherical distance from this latlong to another.use vincentydistance for more accuracy but less performance.",
	"Method": "double sphericalDistance(LatLong other){\r\n    return LatLongUtils.sphericalDistance(this, other);\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.DrawerActivity.hasOnItemClickListener",
	"Comment": "gets whether the drawer view has an item click listener set to it",
	"Method": "boolean hasOnItemClickListener(){\r\n    return mOnItemClickListener != null;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.replaceOrThrow",
	"Comment": "convenience method for replacing a row in the database.inserts a new row if a row does not already exist.",
	"Method": "long replaceOrThrow(String table,String nullColumnHack,ContentValues initialValues){\r\n    return insertWithOnConflict(table, nullColumnHack, initialValues, CONFLICT_REPLACE);\r\n}"
}, {
	"Path": "mondrian.test.SchemaTest.testSnowflakeHierarchyValidationNotNeeded2",
	"Comment": "test hierarchy with slightly different join path to fact table thanfirst hierarchy. tables from first and second hierarchy should containthe same join aliases to the fact table.",
	"Method": "void testSnowflakeHierarchyValidationNotNeeded2(){\r\n    final TestContext testContext = TestContext.instance().create(null, \"<Cube name=\\\"AliasedDimensionsTesting\\\" defaultMeasure=\\\"Supply Time\\\">\\n\" + \"  <Table name=\\\"sales_fact_1997\\\">\\n\" + \"    <AggExclude pattern=\\\"agg_lc_06_sales_fact_1997\\\"/>\\n\" + \"  <\/Table>\" + \"  <Dimension name=\\\"Store\\\" foreignKey=\\\"store_id\\\">\\n\" + \"    <Hierarchy hasAll=\\\"true\\\" primaryKeyTable=\\\"store\\\" primaryKey=\\\"store_id\\\">\\n\" + \"      <Join leftKey=\\\"region_id\\\" rightKey=\\\"region_id\\\">\\n\" + \"        <Table name=\\\"store\\\"/>\\n\" + \"        <Join leftKey=\\\"sales_district_id\\\" rightKey=\\\"promotion_id\\\">\\n\" + \"          <Table name=\\\"region\\\"/>\\n\" + \"          <Table name=\\\"promotion\\\"/>\\n\" + \"        <\/Join>\\n\" + \"      <\/Join>\\n\" + \"      <Level name=\\\"Store Country\\\" table=\\\"store\\\" column=\\\"store_country\\\"/>\\n\" + \"      <Level name=\\\"Store Region\\\" table=\\\"region\\\" column=\\\"sales_region\\\" />\\n\" + \"      <Level name=\\\"Store Name\\\" table=\\\"store\\\" column=\\\"store_name\\\" />\\n\" + \"    <\/Hierarchy>\\n\" + \"    <Hierarchy name=\\\"MyHierarchy\\\" hasAll=\\\"true\\\" primaryKeyTable=\\\"store\\\" primaryKey=\\\"store_id\\\">\\n\" + \"      <Join leftKey=\\\"region_id\\\" rightKey=\\\"region_id\\\">\\n\" + \"        <Table name=\\\"store\\\"/>\\n\" + \"        <Table name=\\\"region\\\"/>\\n\" + \"      <\/Join>\\n\" + \"      <Level name=\\\"Store Country\\\" table=\\\"store\\\" column=\\\"store_country\\\"/>\\n\" + \"      <Level name=\\\"Store Region\\\" table=\\\"region\\\" column=\\\"sales_region\\\" />\\n\" + \"      <Level name=\\\"Store Name\\\" table=\\\"store\\\" column=\\\"store_name\\\" />\\n\" + \"    <\/Hierarchy>\\n\" + \"  <\/Dimension>\\n\" + \"  <Dimension name=\\\"Customers\\\" foreignKey=\\\"customer_id\\\">\\n\" + \"    <Hierarchy hasAll=\\\"true\\\" allMemberName=\\\"All Customers\\\" primaryKeyTable=\\\"customer\\\" primaryKey=\\\"customer_id\\\">\\n\" + \"    <Join leftKey=\\\"customer_region_id\\\" rightKey=\\\"region_id\\\">\\n\" + \"      <Table name=\\\"customer\\\"/>\\n\" + \"      <Table name=\\\"region\\\"/>\\n\" + \"    <\/Join>\\n\" + \"    <Level name=\\\"Country\\\" table=\\\"customer\\\" column=\\\"country\\\" uniqueMembers=\\\"true\\\"/>\\n\" + \"    <Level name=\\\"Region\\\" table=\\\"region\\\" column=\\\"sales_region\\\" uniqueMembers=\\\"true\\\"/>\\n\" + \"    <Level name=\\\"City\\\" table=\\\"customer\\\" column=\\\"city\\\" uniqueMembers=\\\"false\\\"/>\\n\" + \"    <Level name=\\\"Name\\\" table=\\\"customer\\\" column=\\\"customer_id\\\" type=\\\"Numeric\\\" uniqueMembers=\\\"true\\\"/>\\n\" + \"  <\/Hierarchy>\\n\" + \"<\/Dimension>\\n\" + \"<Measure name=\\\"Unit Sales\\\" column=\\\"unit_sales\\\" aggregator=\\\"sum\\\" formatString=\\\"Standard\\\"/>\\n\" + \"<\/Cube>\", null, null, null, null);\r\n    testContext.assertQueryReturns(\"select  {[Store.MyHierarchy].[USA].[South West]} on rows,\" + \"{[Customers].[USA].[South West]} on columns\" + \" from \" + \"AliasedDimensionsTesting\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Customers].[USA].[South West]}\\n\" + \"Axis #2:\\n\" + \"{[Store].[MyHierarchy].[USA].[South West]}\\n\" + \"Row #0: 72,631\\n\");\r\n}"
}, {
	"Path": "mondrian.rolap.RolapCube.topToBottom",
	"Comment": "transforms so that all joins have a table as their left child and eithera table of child join on the right.",
	"Method": "void topToBottom(MondrianDef.RelationOrJoin relation){\r\n    if (relation instanceof MondrianDef.Table) {\r\n    } else if (relation instanceof MondrianDef.Join) {\r\n        MondrianDef.Join join = (MondrianDef.Join) relation;\r\n        while (join.left instanceof MondrianDef.Join) {\r\n            MondrianDef.Join jleft = (MondrianDef.Join) join.left;\r\n            join.right = new MondrianDef.Join(join.leftAlias, join.leftKey, jleft.right, join.rightAlias, join.rightKey, join.right);\r\n            join.left = jleft.left;\r\n            join.rightAlias = jleft.rightAlias;\r\n            join.rightKey = jleft.rightKey;\r\n            join.leftAlias = jleft.leftAlias;\r\n            join.leftKey = jleft.leftKey;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.DrawerFrameLayout.hasOnProfileClickListener",
	"Comment": "gets whether the drawer has a profile click listener set to it",
	"Method": "boolean hasOnProfileClickListener(){\r\n    return mDrawer.hasOnProfileClickListener();\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Sup.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Sup appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.gui.SchemaTreeModel.getChildCount",
	"Comment": "returns the number of children of parent.returns 0 if the nodeis a leaf or if it has no children.parent must be a nodepreviously obtained from this data source.",
	"Method": "int getChildCount(Object parent){\r\n    return getChildList(parent).size();\r\n}"
}, {
	"Path": "org.springframework.extensions.jcr.TransactionAwareRepository.setTargetFactory",
	"Comment": "set the target jcr repository that this proxy should delegate to wrapped in a jcrsessionfactory objectalong with the credentials and workspace.",
	"Method": "void setTargetFactory(JcrSessionFactory target){\r\n    this.sessionFactory = target;\r\n    this.proxy = (Repository) Proxy.newProxyInstance(Repository.class.getClassLoader(), new Class[] { Repository.class }, new TransactionAwareRepositoryInvocationHandler());\r\n}"
}, {
	"Path": "mondrian.test.ParameterTest.testAssignMemberParameter",
	"Comment": "positive and negative tests assigning values to a parameter whose type isa member.",
	"Method": "void testAssignMemberParameter(){\r\n    final String para = \"Parameter(\\\"x\\\", [Customers], [Customers].[USA])\";\r\n    assertAssignParameter(para, false, \"8\", \"MDX object '8' not found in cube 'Sales'\");\r\n    assertAssignParameter(para, false, \"8.24\", \"MDX object '8.24' not found in cube 'Sales'\");\r\n    assertAssignParameter(para, false, 8, \"Invalid value '8' for parameter 'x',\" + \" type MemberType<hierarchy=[Customers]>\");\r\n    assertAssignParameter(para, false, -8.56, \"Invalid value '-8.56' for parameter 'x',\" + \" type MemberType<hierarchy=[Customers]>\");\r\n    assertAssignParameter(para, false, new BigDecimal(\"12.345\"), \"Invalid value '12.345' for parameter 'x',\" + \" type MemberType<hierarchy=[Customers]>\");\r\n    assertAssignParameter(para, false, new Date(), \"' for parameter 'x', type MemberType<hierarchy=[Customers]>\");\r\n    assertAssignParameter(para, false, new Timestamp(new Date().getTime()), \"' for parameter 'x', type MemberType<hierarchy=[Customers]>\");\r\n    assertAssignParameter(para, false, new Time(new Date().getTime()), \"' for parameter 'x', type MemberType<hierarchy=[Customers]>\");\r\n    assertAssignParameter(para, false, \"[Customers].[Mexico]\", null);\r\n    assertAssignParameter(para, false, \"[Customers].[All Customers].[Canada].[BC]\", null);\r\n    assertAssignParameter(para, false, \"[Customers].[Canada].[Bear Province]\", \"MDX object '[Customers].[Canada].[Bear Province]' not found in \" + \"cube 'Sales'\");\r\n    assertAssignParameter(para, false, null, null);\r\n    SchemaReader sr = TestContext.instance().getConnection().parseQuery(\"select from [Sales]\").getSchemaReader(true).withLocus();\r\n    assertAssignParameter(para, false, sr.getMemberByUniqueName(Id.Segment.toList(\"Time\", \"1997\", \"Q2\", \"5\"), true), \"Invalid value '[Time].[1997].[Q2].[5]' for parameter 'x', \" + \"type MemberType<hierarchy=[Customers]>\");\r\n    assertAssignParameter(para, false, sr.getMemberByUniqueName(Id.Segment.toList(\"Customers\", \"All Customers\"), true), null);\r\n    assertAssignParameter(\"Parameter(\\\"x\\\", [Customers].[State Province], [Customers].[USA].[CA])\", false, sr.getMemberByUniqueName(Id.Segment.toList(\"Customers\", \"USA\"), true), \"Invalid value '[Customers].[USA]' for parameter \" + \"'x', type MemberType<level=[Customers].[State Province]>\");\r\n    assertAssignParameter(\"Parameter(\\\"x\\\", [Customers].[State Province], [Customers].[USA].[CA])\", false, \"[Customers].[USA]\", \"Invalid value '[Customers].[USA]' for parameter \" + \"'x', type MemberType<level=[Customers].[State Province]>\");\r\n    assertAssignParameter(\"Parameter(\\\"x\\\", [Customers].[State Province], [Customers].[USA].[CA])\", false, sr.getMemberByUniqueName(Id.Segment.toList(\"Customers\", \"USA\", \"OR\"), true), null);\r\n}"
}, {
	"Path": "mondrian.rolap.sql.CrossJoinArgFactory.checkFilterPredicate",
	"Comment": "checks whether the filter predicate can be turned into native sql.see comment for checkdimensionfilter for the types of predicatessuported.",
	"Method": "CrossJoinArg[] checkFilterPredicate(RolapEvaluator evaluator,ResolvedFunCall predicateCall,boolean exclude){\r\n    CrossJoinArg[] predicateCJArgs = null;\r\n    if (predicateCall.getFunName().equals(\"()\")) {\r\n        Exp actualPredicateCall = predicateCall.getArg(0);\r\n        if (actualPredicateCall instanceof ResolvedFunCall) {\r\n            return checkFilterPredicate(evaluator, (ResolvedFunCall) actualPredicateCall, exclude);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    if (predicateCall.getFunName().equals(\"NOT\") && predicateCall.getArg(0) instanceof ResolvedFunCall) {\r\n        predicateCall = (ResolvedFunCall) predicateCall.getArg(0);\r\n        exclude = !exclude;\r\n        return checkFilterPredicate(evaluator, predicateCall, exclude);\r\n    }\r\n    if (predicateCall.getFunName().equals(\"AND\")) {\r\n        Exp andArg0 = predicateCall.getArg(0);\r\n        Exp andArg1 = predicateCall.getArg(1);\r\n        if (andArg0 instanceof ResolvedFunCall && andArg1 instanceof ResolvedFunCall) {\r\n            CrossJoinArg[] andCJArgs0;\r\n            CrossJoinArg[] andCJArgs1;\r\n            andCJArgs0 = checkFilterPredicate(evaluator, (ResolvedFunCall) andArg0, exclude);\r\n            if (andCJArgs0 != null) {\r\n                andCJArgs1 = checkFilterPredicate(evaluator, (ResolvedFunCall) andArg1, exclude);\r\n                if (andCJArgs1 != null) {\r\n                    predicateCJArgs = Util.appendArrays(andCJArgs0, andCJArgs1);\r\n                }\r\n            }\r\n        }\r\n        return predicateCJArgs;\r\n    }\r\n    predicateCJArgs = checkFilterPredicateInIs(evaluator, predicateCall, exclude);\r\n    return predicateCJArgs;\r\n}"
}, {
	"Path": "mondrian.test.BasicQueryTest.testFormatInheritanceUseFirstValid",
	"Comment": "tests format inheritance with complex expression to assert that theformat of the first member that has a valid format is used.",
	"Method": "void testFormatInheritanceUseFirstValid(){\r\n    assertQueryReturns(\"with member measures.foo as '13+31*measures.[Unit Sales]/\" + \"iif(measures.profit>0,measures.profit,measures.[Customer Count])'\" + \" select {[Store].[All Stores].[USA].[CA].children} on 0 \" + \"from sales where measures.foo\", \"Axis #0:\\n\" + \"{[Measures].[foo]}\\n\" + \"Axis #1:\\n\" + \"{[Store].[USA].[CA].[Alameda]}\\n\" + \"{[Store].[USA].[CA].[Beverly Hills]}\\n\" + \"{[Store].[USA].[CA].[Los Angeles]}\\n\" + \"{[Store].[USA].[CA].[San Diego]}\\n\" + \"{[Store].[USA].[CA].[San Francisco]}\\n\" + \"Row #0: 13\\n\" + \"Row #0: 37\\n\" + \"Row #0: 37\\n\" + \"Row #0: 37\\n\" + \"Row #0: 38\\n\");\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testAllMembersNECJ1",
	"Comment": "verify that the presence of all member in all the inputs disables nativeevaluation.",
	"Method": "void testAllMembersNECJ1(){\r\n    propSaver.set(MondrianProperties.instance().EnableNativeCrossJoin, true);\r\n    checkNotNative(1, \"select \" + \"NonEmptyCrossJoin({[Store].[All Stores]}, {[Product].[All Products]}) on columns \" + \"from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Store].[All Stores], [Product].[All Products]}\\n\" + \"Row #0: 266,773\\n\");\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.JdbcSchema.makeDB",
	"Comment": "creates or retrieves an instance of the jdbcschema for the givendatasource.",
	"Method": "JdbcSchema makeDB(DataSource dataSource,JdbcSchema makeDB,DataSource dataSource,JdbcSchema makeDB,DataSource dataSource){\r\n    makeFactory();\r\n    JdbcSchema db = null;\r\n    SoftReference<JdbcSchema> ref = dbMap.get(dataSource);\r\n    if (ref != null) {\r\n        db = ref.get();\r\n    }\r\n    if (db == null) {\r\n        db = factory.makeDB(dataSource);\r\n        dbMap.put(dataSource, new SoftReference<JdbcSchema>(db));\r\n    }\r\n    sweepDB();\r\n    return db;\r\n}"
}, {
	"Path": "mondrian.olap.Query.allAxes",
	"Comment": "returns a collection of all axes, including the slicer as the firstelement, if there is a slicer.",
	"Method": "Collection<QueryAxis> allAxes(){\r\n    if (slicerAxis == null) {\r\n        return Arrays.asList(axes);\r\n    } else {\r\n        return new CompositeCollection(new Collection[] { Collections.singletonList(slicerAxis), Arrays.asList(axes) });\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.core.util.MercatorProjection.pixelYToLatitudeWithScaleFactor",
	"Comment": "converts a pixel y coordinate at a certain scale to a latitude coordinate.",
	"Method": "double pixelYToLatitudeWithScaleFactor(double pixelY,double scaleFactor,int tileSize){\r\n    long mapSize = getMapSizeWithScaleFactor(scaleFactor, tileSize);\r\n    if (pixelY < 0 || pixelY > mapSize) {\r\n        throw new IllegalArgumentException(\"invalid pixelY coordinate at scale \" + scaleFactor + \": \" + pixelY);\r\n    }\r\n    double y = 0.5 - (pixelY / mapSize);\r\n    return 90 - 360 * Math.atan(Math.exp(-y * (2 * Math.PI))) / Math.PI;\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlTest.testNegative",
	"Comment": "a number of negative tests, trying to do invalid things with cacheflushing and getting errors.",
	"Method": "void testNegative(){\r\n    final TestContext testContext = getTestContext();\r\n    final Connection connection = testContext.getConnection();\r\n    final Cube salesCube = connection.getSchema().lookupCube(\"Sales\", true);\r\n    final SchemaReader schemaReader = salesCube.getSchemaReader(null);\r\n    final CacheControl cacheControl = testContext.getCacheControl();\r\n    final Member memberQ1 = schemaReader.withLocus().getMemberByUniqueName(Id.Segment.toList(\"Time\", \"1997\", \"Q1\"), true);\r\n    final Member memberBeer = schemaReader.withLocus().getMemberByUniqueName(Id.Segment.toList(\"Product\", \"Drink\", \"Alcoholic Beverages\", \"Beer and Wine\"), true);\r\n    final Member memberDairy = schemaReader.withLocus().getMemberByUniqueName(Id.Segment.toList(\"Product\", \"Drink\", \"Dairy\"), true);\r\n    final CacheControl.CellRegion regionTimeQ1 = cacheControl.createMemberRegion(memberQ1, false);\r\n    final CacheControl.CellRegion regionProductBeer = cacheControl.createMemberRegion(memberBeer, false);\r\n    final CacheControl.CellRegion regionProductDairy = cacheControl.createMemberRegion(memberDairy, true);\r\n    try {\r\n        final CacheControl.CellRegion cellRegion = cacheControl.createUnionRegion(regionTimeQ1, regionProductBeer);\r\n        fail(\"expected exception, got \" + cellRegion);\r\n    } catch (RuntimeException e) {\r\n        assertContains(\"Cannot union cell regions of different dimensionalities. \" + \"(Dimensionalities are '[[Time]]', '[[Product]]'.)\", e.getMessage());\r\n    }\r\n    final CacheControl.CellRegion regionTimeXProduct = cacheControl.createCrossjoinRegion(regionTimeQ1, regionProductBeer);\r\n    assertNotNull(regionTimeXProduct);\r\n    assertEquals(2, regionTimeXProduct.getDimensionality().size());\r\n    assertEquals(\"Crossjoin(Member([Time].[1997].[Q1]), \" + \"Member([Product].[Drink].[Alcoholic Beverages].\" + \"[Beer and Wine]))\", regionTimeXProduct.toString());\r\n    try {\r\n        final CacheControl.CellRegion cellRegion = cacheControl.createUnionRegion(regionTimeXProduct, regionTimeQ1);\r\n        fail(\"expected exception, got \" + cellRegion);\r\n    } catch (RuntimeException e) {\r\n        assertContains(\"Cannot union cell regions of different dimensionalities. \" + \"(Dimensionalities are '[[Time], [Product]]', '[[Time]]'.)\", e.getMessage());\r\n    }\r\n    try {\r\n        final CacheControl.CellRegion cellRegion = cacheControl.createUnionRegion(regionTimeXProduct, regionProductBeer);\r\n        fail(\"expected exception, got \" + cellRegion);\r\n    } catch (RuntimeException e) {\r\n        assertContains(\"Cannot union cell regions of different dimensionalities. \" + \"(Dimensionalities are '[[Time], [Product]]', \" + \"'[[Product]]'.)\", e.getMessage());\r\n    }\r\n    try {\r\n        final CacheControl.CellRegion cellRegion = cacheControl.createUnionRegion(regionTimeQ1, regionTimeXProduct);\r\n        fail(\"expected exception, got \" + cellRegion);\r\n    } catch (RuntimeException e) {\r\n        assertContains(\"Cannot union cell regions of different dimensionalities. \" + \"(Dimensionalities are '[[Time]]', '[[Time], [Product]]'.)\", e.getMessage());\r\n    }\r\n    final CacheControl.CellRegion regionTimeUnionTime = cacheControl.createUnionRegion(regionTimeQ1, regionTimeQ1);\r\n    assertNotNull(regionTimeUnionTime);\r\n    assertEquals(1, regionTimeUnionTime.getDimensionality().size());\r\n    final CacheControl.CellRegion regionTimeXProductUnionTimeXProduct = cacheControl.createUnionRegion(regionTimeXProduct, regionTimeXProduct);\r\n    assertNotNull(regionTimeXProductUnionTimeXProduct);\r\n    assertEquals(2, regionTimeXProductUnionTimeXProduct.getDimensionality().size());\r\n    try {\r\n        final CacheControl.CellRegion cellRegion = cacheControl.createCrossjoinRegion(regionProductBeer, regionProductDairy);\r\n        fail(\"expected exception, got \" + cellRegion);\r\n    } catch (RuntimeException e) {\r\n        assertContains(\"Cannot crossjoin cell regions which have dimensions in common.\" + \" (Dimensionalities are '[[Product]]', '[[Product]]'.)\", e.getMessage());\r\n    }\r\n    try {\r\n        final CacheControl.CellRegion cellRegion = cacheControl.createCrossjoinRegion(regionProductBeer, regionTimeXProduct);\r\n        fail(\"expected exception, got \" + cellRegion);\r\n    } catch (RuntimeException e) {\r\n        assertContains(\"Cannot crossjoin cell regions which have dimensions in common.\" + \" (Dimensionalities are \" + \"'[[Product]]', '[[Time], [Product]]'.)\", e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.SchemaTest.testAggTableSupportOfSharedDims",
	"Comment": "this test triggers an exception out of the aggregate table manager",
	"Method": "void testAggTableSupportOfSharedDims(){\r\n    if (Bug.BugMondrian361Fixed) {\r\n        final TestContext testContext = TestContext.instance().create(null, \"<Cube name=\\\"Sales Two Dimensions\\\">\\n\" + \"  <Table name=\\\"sales_fact_1997\\\"/>\\n\" + \"  <DimensionUsage name=\\\"Time\\\" source=\\\"Time\\\" foreignKey=\\\"time_id\\\"/>\\n\" + \"  <DimensionUsage name=\\\"Time2\\\" source=\\\"Time\\\" foreignKey=\\\"product_id\\\"/>\\n\" + \"  <DimensionUsage name=\\\"Store\\\" source=\\\"Store\\\" foreignKey=\\\"store_id\\\"/>\\n\" + \"  <Measure name=\\\"Unit Sales\\\" column=\\\"unit_sales\\\" aggregator=\\\"sum\\\" \" + \"   formatString=\\\"Standard\\\"/>\\n\" + \"  <Measure name=\\\"Store Cost\\\" column=\\\"store_cost\\\" aggregator=\\\"sum\\\"\" + \"   formatString=\\\"#,###.00\\\"/>\\n\" + \"<\/Cube>\", null, null, null, null);\r\n        testContext.assertQueryReturns(\"select\\n\" + \" {[Time2].[1997]} on columns,\\n\" + \" {[Time].[1997].[Q3]} on rows\\n\" + \"From [Sales Two Dimensions]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Time2].[1997]}\\n\" + \"Axis #2:\\n\" + \"{[Time].[1997].[Q3]}\\n\" + \"Row #0: 16,266\\n\");\r\n        MondrianProperties props = MondrianProperties.instance();\r\n        propSaver.set(props.DisableCaching, true);\r\n        propSaver.set(props.UseAggregates, true);\r\n        propSaver.set(props.ReadAggregates, false);\r\n        propSaver.set(props.ReadAggregates, true);\r\n    }\r\n}"
}, {
	"Path": "com.mycollab.core.utils.ClassUtils.instanceOf",
	"Comment": "check whether object o is one of instance in class listclasses",
	"Method": "boolean instanceOf(Object o,Class<?> classes){\r\n    for (Class<?> cls : classes) {\r\n        if (cls.isInstance(o)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.ExplicitRecognizer.getTableDef",
	"Comment": "get the explicitrules.tabledef associated with this instance.",
	"Method": "ExplicitRules.TableDef getTableDef(){\r\n    return tableDef;\r\n}"
}, {
	"Path": "mondrian.rolap.SqlConstraintUtils.getColumnExpr",
	"Comment": "get the column expression from the aggstar if provided or the regulartable if not, and ensure table is in from",
	"Method": "String getColumnExpr(SqlQuery sqlQuery,AggStar aggStar,RolapStar.Column column){\r\n    final String expr;\r\n    if (aggStar != null) {\r\n        int bitPos = column.getBitPosition();\r\n        AggStar.Table.Column aggColumn = aggStar.lookupColumn(bitPos);\r\n        AggStar.Table table = aggColumn.getTable();\r\n        table.addToFrom(sqlQuery, false, true);\r\n        expr = aggColumn.generateExprString(sqlQuery);\r\n    } else {\r\n        RolapStar.Table table = column.getTable();\r\n        table.addToFrom(sqlQuery, false, true);\r\n        expr = column.generateExprString(sqlQuery);\r\n    }\r\n    return expr;\r\n}"
}, {
	"Path": "mondrian.olap.EnumeratedValues.getMutableClone",
	"Comment": "creates a mutable enumeration from an existing enumeration, which mayalready be immutable.",
	"Method": "EnumeratedValues getMutableClone(){\r\n    return clone();\r\n}"
}, {
	"Path": "mondrian.olap.ParameterImpl.equals",
	"Comment": "returns whether this parameter is equal to another, based upon name,type and value",
	"Method": "boolean equals(Object other){\r\n    if (!(other instanceof ParameterImpl)) {\r\n        return false;\r\n    }\r\n    ParameterImpl that = (ParameterImpl) other;\r\n    return that.getName().equals(this.getName()) && that.defaultExp.equals(this.defaultExp);\r\n}"
}, {
	"Path": "mondrian.test.loader.DBLoader.writeBatch",
	"Comment": "if we are outputting to jdbc, execute the given set of sql statementsotherwise, output the statements to a file.",
	"Method": "int writeBatch(String[] batch,int batchSize){\r\n    if (this.fileWriter != null) {\r\n        for (int i = 0; i < batchSize; i++) {\r\n            this.fileWriter.write(batch[i]);\r\n            this.fileWriter.write(';');\r\n            this.fileWriter.write(nl);\r\n        }\r\n    } else {\r\n        if (connection.getMetaData().supportsTransactions()) {\r\n            connection.setAutoCommit(false);\r\n        }\r\n        Statement stmt = connection.createStatement();\r\n        if (batchSize == 1) {\r\n            stmt.execute(batch[0]);\r\n        } else {\r\n            for (int i = 0; i < batchSize; i++) {\r\n                stmt.addBatch(batch[i]);\r\n            }\r\n            int[] updateCounts;\r\n            try {\r\n                updateCounts = stmt.executeBatch();\r\n            } catch (SQLException e) {\r\n                for (int i = 0; i < batchSize; i++) {\r\n                    LOGGER.error(\"Error in SQL batch: \" + batch[i]);\r\n                }\r\n                throw e;\r\n            }\r\n            int updates = 0;\r\n            for (int i = 0; i < updateCounts.length; updates += updateCounts[i], i++) {\r\n                if (updateCounts[i] == 0) {\r\n                    LOGGER.error(\"Error in SQL: \" + batch[i]);\r\n                }\r\n            }\r\n            if (updates < batchSize) {\r\n                throw new RuntimeException(\"Failed to execute batch: \" + batchSize + \" versus \" + updates);\r\n            }\r\n        }\r\n        if (connection.getMetaData().supportsTransactions()) {\r\n            connection.commit();\r\n        }\r\n        stmt.close();\r\n        if (connection.getMetaData().supportsTransactions()) {\r\n            connection.setAutoCommit(true);\r\n        }\r\n    }\r\n    return batchSize;\r\n}"
}, {
	"Path": "mondrian.spi.SegmentHeader.getSortedColumns",
	"Comment": "this function returns a sorted view of the constrained columnsof this segment. we cannot sort them at construction becausechanging their order would make it not correspond to its segmentdataset.use this method with caution, not in tight loops.",
	"Method": "List<SegmentColumn> getSortedColumns(){\r\n    List<SegmentColumn> sortedColumns = new ArrayList(constrainedColumns);\r\n    Collections.sort(sortedColumns, new Comparator<SegmentColumn>() {\r\n        public int compare(SegmentColumn o1, SegmentColumn o2) {\r\n            return o1.columnExpression.compareTo(o2.columnExpression);\r\n        }\r\n    });\r\n    return sortedColumns;\r\n}"
}, {
	"Path": "mondrian.spi.SegmentHeader.getSortedColumns",
	"Comment": "this function returns a sorted view of the constrained columnsof this segment. we cannot sort them at construction becausechanging their order would make it not correspond to its segmentdataset.use this method with caution, not in tight loops.",
	"Method": "List<SegmentColumn> getSortedColumns(){\r\n    return o1.columnExpression.compareTo(o2.columnExpression);\r\n}"
}, {
	"Path": "mondrian.olap.Util.makeBigDecimalFromDouble",
	"Comment": "make a bigdecimal from a double. on jdk 1.5 or later, the bigdecimalprecision reflects the precision of the double while with jdk 1.4this is not the case.",
	"Method": "BigDecimal makeBigDecimalFromDouble(double d){\r\n    return compatible.makeBigDecimalFromDouble(d);\r\n}"
}, {
	"Path": "mondrian.rolap.RolapSchemaPool.putSchema",
	"Comment": "adds schema to the pool.attention! this method is not doing any synchronizationinternally and relies on the assumption that it is invokedinside a critical section",
	"Method": "void putSchema(RolapSchema schema,ByteString md5Bytes,String pinTimeout){\r\n    final ExpiringReference<RolapSchema> reference = new ExpiringReference<RolapSchema>(schema, pinTimeout);\r\n    if (md5Bytes != null) {\r\n        mapMd5ToSchema.put(md5Bytes, reference);\r\n    }\r\n    mapKeyToSchema.put(schema.key, reference);\r\n    if (LOGGER.isDebugEnabled()) {\r\n        LOGGER.debug(\"put: schema=\" + schema + \", key=\" + schema.key + \", checksum=\" + md5Bytes + \", map-size=\" + mapKeyToSchema.size() + \", md5-map-size=\" + mapMd5ToSchema.size());\r\n    }\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteQueryBuilder.buildUnionSubQuery",
	"Comment": "construct a select statement suitable for use in a group ofselect statements that will be joined through union operatorsin buildunionquery.",
	"Method": "String buildUnionSubQuery(String typeDiscriminatorColumn,String[] unionColumns,Set<String> columnsPresentInTable,int computedColumnsOffset,String typeDiscriminatorValue,String selection,String groupBy,String having,String buildUnionSubQuery,String typeDiscriminatorColumn,String[] unionColumns,Set<String> columnsPresentInTable,int computedColumnsOffset,String typeDiscriminatorValue,String selection,String[] selectionArgs,String groupBy,String having){\r\n    return buildUnionSubQuery(typeDiscriminatorColumn, unionColumns, columnsPresentInTable, computedColumnsOffset, typeDiscriminatorValue, selection, groupBy, having);\r\n}"
}, {
	"Path": "org.mapsforge.samples.android.cluster.ClusterManager.setToast",
	"Comment": "you might like to set the toast from external, in order to make sure that only a single toastis showing up.",
	"Method": "void setToast(Toast toast){\r\n    ClusterManager.toast = toast;\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.Patterns.digitsAndPlusOnly",
	"Comment": "convenience method to return only the digits and plus signs in thematching string.",
	"Method": "String digitsAndPlusOnly(Matcher matcher){\r\n    StringBuilder buffer = new StringBuilder();\r\n    String matchingRegion = matcher.group();\r\n    for (int i = 0, size = matchingRegion.length(); i < size; i++) {\r\n        char character = matchingRegion.charAt(i);\r\n        if (character == '+' || Character.isDigit(character)) {\r\n            buffer.append(character);\r\n        }\r\n    }\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "mondrian.olap.OlapElementBase.getCaption",
	"Comment": "returns the display name of this catalog element.if no caption is defined, the name is returned.",
	"Method": "String getCaption(){\r\n    if (caption != null) {\r\n        return caption;\r\n    } else {\r\n        return getName();\r\n    }\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletResponse.encodeRedirectURL",
	"Comment": "encodes the specified url for use in the sendredirect method or, ifencoding is not needed, returns the url unchanged.",
	"Method": "String encodeRedirectURL(String url){\r\n    return encode(url);\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.newEvalException",
	"Comment": "creates an exception which indicates that an error has occurred whileexecuting a given function.",
	"Method": "RuntimeException newEvalException(FunDef funDef,String message,RuntimeException newEvalException,Throwable throwable,RuntimeException newEvalException,String message,Throwable throwable){\r\n    return new MondrianEvaluationException(message + \": \" + Util.getErrorMessage(throwable));\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Ul.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Ul appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.FastBatchingCellReader.preloadColumnCardinality",
	"Comment": "iterates through cell requests and makes sure .getcardinality hasbeen called on all constrained columns.this is aworkaroundto an issue in which cardinality queries can be fired on the actorthread, potentially causing a deadlock when interleaved withother threads that depend both on db connections and actor responses.",
	"Method": "void preloadColumnCardinality(List<CellRequest> cellRequests){\r\n    List<BitKey> loaded = new ArrayList<BitKey>();\r\n    for (CellRequest req : cellRequests) {\r\n        if (!loaded.contains(req.getConstrainedColumnsBitKey())) {\r\n            for (RolapStar.Column col : req.getConstrainedColumns()) {\r\n                col.getCardinality();\r\n            }\r\n            loaded.add(req.getConstrainedColumnsBitKey());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Acronym.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Acronym appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.test.ParameterTest.testAssignNumericParameter",
	"Comment": "positive and negative tests assigning values to a parameter of typenumeric.",
	"Method": "void testAssignNumericParameter(){\r\n    final String para = \"Parameter(\\\"x\\\", NUMERIC, 1)\";\r\n    assertAssignParameter(para, false, \"8\", null);\r\n    assertAssignParameter(para, false, \"8.24\", null);\r\n    assertAssignParameter(para, false, 8, null);\r\n    assertAssignParameter(para, false, -8.56, null);\r\n    assertAssignParameter(para, false, new BigDecimal(\"12.345\"), null);\r\n    assertAssignParameter(para, false, new BigInteger(\"12345\"), null);\r\n    assertAssignParameter(para, false, new Date(), \"' for parameter 'x', type NUMERIC\");\r\n    assertAssignParameter(para, false, new Timestamp(new Date().getTime()), \"' for parameter 'x', type NUMERIC\");\r\n    assertAssignParameter(para, false, new Time(new Date().getTime()), \"' for parameter 'x', type NUMERIC\");\r\n    assertAssignParameter(para, false, null, null);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Samp.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Samp appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testResultIsModifyableCopy",
	"Comment": "checks that crossjoin returns a modifiable copy from cachebecause its modified during sort",
	"Method": "void testResultIsModifyableCopy(){\r\n    checkNative(3, 3, \"select {[Measures].[Store Sales]} on columns,\" + \"  NON EMPTY Order(\" + \"        CrossJoin([Customers].[All Customers].[USA].children, [Promotions].[Promotion Name].Members), \" + \"        [Measures].[Store Sales]) ON ROWS\" + \" from [Sales] where (\" + \"  [Store].[All Stores].[USA].[CA].[San Francisco].[Store 14],\" + \"  [Time].[1997].[Q1].[1])\");\r\n}"
}, {
	"Path": "mondrian.rolap.SqlContextConstraint.findVirtualCubeBaseCubes",
	"Comment": "locates base cubes related to the measures referenced in the query.",
	"Method": "boolean findVirtualCubeBaseCubes(Query query,Set<RolapCube> baseCubes,List<RolapCube> baseCubeList){\r\n    Set<Member> measureMembers = query.getMeasuresMembers();\r\n    if (measureMembers.isEmpty()) {\r\n        Cube cube = query.getCube();\r\n        Dimension dimension = cube.getDimensions()[0];\r\n        query.addMeasuresMembers(dimension.getHierarchy().getDefaultMember());\r\n    }\r\n    for (Member member : query.getMeasuresMembers()) {\r\n        if (member instanceof RolapStoredMeasure) {\r\n            addMeasure((RolapStoredMeasure) member, baseCubes, baseCubeList);\r\n        } else if (member instanceof RolapCalculatedMember) {\r\n            findMeasures(member.getExpression(), baseCubes, baseCubeList);\r\n        }\r\n    }\r\n    if (baseCubes.isEmpty()) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.StringUtils.containsWhitespace",
	"Comment": "check whether the given string contains any whitespace characters.",
	"Method": "boolean containsWhitespace(CharSequence str,boolean containsWhitespace,String str){\r\n    return containsWhitespace((CharSequence) str);\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.AggStar.lookupColumn",
	"Comment": "get the column at the bit position.note that there is no check that the bit position is within the range ofthe array of columns.",
	"Method": "AggStar.Table.Column lookupColumn(int bitPos){\r\n    if (columns[bitPos] != null) {\r\n        return columns[bitPos];\r\n    }\r\n    return levelColumnsToJoin.get(bitPos);\r\n}"
}, {
	"Path": "mondrian.test.loader.DBLoader.embedQuotes",
	"Comment": "generate an appropriate string to use in an sql insert statement for avarchar colummn, taking into account null strings and strings withembedded quotes",
	"Method": "String embedQuotes(String original){\r\n    if (original == null) {\r\n        return \"NULL\";\r\n    }\r\n    StringBuilder buf = new StringBuilder();\r\n    buf.append(\"'\");\r\n    for (int i = 0; i < original.length(); i++) {\r\n        char ch = original.charAt(i);\r\n        buf.append(ch);\r\n        if (ch == '\\'') {\r\n            buf.append('\\'');\r\n        }\r\n    }\r\n    buf.append(\"'\");\r\n    return buf.toString();\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getDateHeader",
	"Comment": "returns the value of the specified request header as a long value thatrepresents a date object.",
	"Method": "long getDateHeader(String name){\r\n    String header = getHeader(name);\r\n    if (header == null) {\r\n        return -1;\r\n    }\r\n    try {\r\n        Date dateValue = new SimpleDateFormat(DATE_FORMAT_HEADER, Locale.US).parse(header);\r\n        return dateValue.getTime();\r\n    } catch (ParseException exc) {\r\n        throw new IllegalArgumentException(exc.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteQueryBuilder.buildQuery",
	"Comment": "construct a select statement suitable for use in a group ofselect statements that will be joined through union operatorsin buildunionquery.",
	"Method": "String buildQuery(String[] projectionIn,String selection,String groupBy,String having,String sortOrder,String limit,String buildQuery,String[] projectionIn,String selection,String[] selectionArgs,String groupBy,String having,String sortOrder,String limit){\r\n    return buildQuery(projectionIn, selection, groupBy, having, sortOrder, limit);\r\n}"
}, {
	"Path": "mondrian.rolap.VirtualCubeTest.testRolapCubeLevelInVirtualCube",
	"Comment": "test that rolapcubelevel is used correctly in the context of virtualcube.",
	"Method": "void testRolapCubeLevelInVirtualCube(){\r\n    String query1 = \"With \" + \"Set [*NATIVE_CJ_SET] as 'NonEmptyCrossJoin([*BASE_MEMBERS_Warehouse],[*BASE_MEMBERS_Time])' \" + \"Set [*NATIVE_MEMBERS_Warehouse] as 'Generate([*NATIVE_CJ_SET], {[Warehouse].CurrentMember})' \" + \"Set [*BASE_MEMBERS_Warehouse] as '[Warehouse].[Country].Members' \" + \"Set [*NATIVE_MEMBERS_Time] as 'Generate([*NATIVE_CJ_SET], {[Time].[Time].CurrentMember})' \" + \"Set [*BASE_MEMBERS_Time] as '[Time].[Month].Members' \" + \"Set [*BASE_MEMBERS_Measures] as '{[Measures].[*FORMATTED_MEASURE_0]}' Member [Measures].[*FORMATTED_MEASURE_0] as '[Measures].[Warehouse Sales]', FORMAT_STRING = '#,##0', SOLVE_ORDER=400 \" + \"Select [*BASE_MEMBERS_Measures] on columns, Non Empty Generate([*NATIVE_CJ_SET], {([Warehouse].currentMember,[Time].[Time].currentMember)}) on rows From [Warehouse and Sales] \";\r\n    String query2 = \"With \" + \"Set [*NATIVE_CJ_SET] as 'NonEmptyCrossJoin([*BASE_MEMBERS_Warehouse],[*BASE_MEMBERS_Time])' \" + \"Set [*NATIVE_MEMBERS_Warehouse] as 'Generate([*NATIVE_CJ_SET], {[Warehouse].CurrentMember})' \" + \"Set [*BASE_MEMBERS_Warehouse] as '[Warehouse].[Country].Members' \" + \"Set [*NATIVE_MEMBERS_Time] as 'Generate([*NATIVE_CJ_SET], {[Time].[Time].CurrentMember})' \" + \"Set [*BASE_MEMBERS_Time] as 'Filter([Time].[Month].Members,[Time].[Time].CurrentMember Not In {[Time].[1997].[Q1].[2]})' \" + \"Set [*BASE_MEMBERS_Measures] as '{[Measures].[*FORMATTED_MEASURE_0]}' Member [Measures].[*FORMATTED_MEASURE_0] as '[Measures].[Warehouse Sales]', FORMAT_STRING = '#,##0', SOLVE_ORDER=400 \" + \"Select [*BASE_MEMBERS_Measures] on columns, Non Empty Generate([*NATIVE_CJ_SET], {([Warehouse].currentMember,[Time].[Time].currentMember)}) on rows From [Warehouse and Sales]\";\r\n    executeQuery(query1);\r\n    String result = \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[*FORMATTED_MEASURE_0]}\\n\" + \"Axis #2:\\n\" + \"{[Warehouse].[USA], [Time].[1997].[Q1].[1]}\\n\" + \"{[Warehouse].[USA], [Time].[1997].[Q1].[3]}\\n\" + \"{[Warehouse].[USA], [Time].[1997].[Q2].[4]}\\n\" + \"{[Warehouse].[USA], [Time].[1997].[Q2].[5]}\\n\" + \"{[Warehouse].[USA], [Time].[1997].[Q2].[6]}\\n\" + \"{[Warehouse].[USA], [Time].[1997].[Q3].[7]}\\n\" + \"{[Warehouse].[USA], [Time].[1997].[Q3].[8]}\\n\" + \"{[Warehouse].[USA], [Time].[1997].[Q3].[9]}\\n\" + \"{[Warehouse].[USA], [Time].[1997].[Q4].[10]}\\n\" + \"{[Warehouse].[USA], [Time].[1997].[Q4].[11]}\\n\" + \"{[Warehouse].[USA], [Time].[1997].[Q4].[12]}\\n\" + \"Row #0: 21,762\\n\" + \"Row #1: 13,775\\n\" + \"Row #2: 15,938\\n\" + \"Row #3: 15,649\\n\" + \"Row #4: 14,629\\n\" + \"Row #5: 18,626\\n\" + \"Row #6: 15,833\\n\" + \"Row #7: 21,393\\n\" + \"Row #8: 17,100\\n\" + \"Row #9: 15,356\\n\" + \"Row #10: 13,948\\n\";\r\n    assertQueryReturns(query2, result);\r\n}"
}, {
	"Path": "mondrian.test.loader.MondrianFoodMartLoader.createInsertStatement",
	"Comment": "creates a sql insert statement in the dialect of the output rdbms.",
	"Method": "String createInsertStatement(ResultSet rs,String name,Column[] columns){\r\n    StringBuilder buf = new StringBuilder();\r\n    buf.append(\"INSERT INTO \").append(quoteId(schema, name)).append(\" (\");\r\n    for (int i = 0; i < columns.length; i++) {\r\n        Column column = columns[i];\r\n        if (i > 0) {\r\n            buf.append(\",\");\r\n        }\r\n        buf.append(quoteId(column.name));\r\n    }\r\n    buf.append(\") VALUES(\");\r\n    for (int i = 0; i < columns.length; i++) {\r\n        Column column = columns[i];\r\n        if (i > 0) {\r\n            buf.append(\",\");\r\n        }\r\n        buf.append(columnValue(rs, column));\r\n    }\r\n    buf.append(\")\");\r\n    return buf.toString();\r\n}"
}, {
	"Path": "mondrian.olap.Util.getErrorMessage",
	"Comment": "constructs the message associated with an arbitrary java error, makingup one based on the stack trace if there is none.",
	"Method": "String getErrorMessage(Throwable err,String getErrorMessage,Throwable err,boolean prependClassName){\r\n    String errMsg = err.getMessage();\r\n    if ((errMsg == null) || (err instanceof RuntimeException)) {\r\n        StringWriter sw = new StringWriter();\r\n        PrintWriter pw = new PrintWriter(sw);\r\n        err.printStackTrace(pw);\r\n        return sw.toString();\r\n    } else {\r\n        return (prependClassName) ? err.getClass().getName() + \": \" + errMsg : errMsg;\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AggregationManager.generateSql",
	"Comment": "generates the query to retrieve the cells for a list of segments.called by segment.load.",
	"Method": "Pair<String, List<SqlStatement.Type>> generateSql(GroupingSetsList groupingSetsList,List<StarPredicate> compoundPredicateList){\r\n    final RolapStar star = groupingSetsList.getStar();\r\n    BitKey levelBitKey = groupingSetsList.getDefaultLevelBitKey();\r\n    BitKey measureBitKey = groupingSetsList.getDefaultMeasureBitKey();\r\n    boolean hasCompoundPredicates = false;\r\n    if (compoundPredicateList != null && compoundPredicateList.size() > 0) {\r\n        hasCompoundPredicates = true;\r\n    }\r\n    if (MondrianProperties.instance().UseAggregates.get() && !hasCompoundPredicates) {\r\n        final boolean[] rollup = { false };\r\n        AggStar aggStar = findAgg(star, levelBitKey, measureBitKey, rollup);\r\n        if (aggStar != null) {\r\n            if (LOGGER.isDebugEnabled()) {\r\n                StringBuilder buf = new StringBuilder(256);\r\n                buf.append(\"MATCH: \");\r\n                buf.append(star.getFactTable().getAlias());\r\n                buf.append(Util.nl);\r\n                buf.append(\"   foreign=\");\r\n                buf.append(levelBitKey);\r\n                buf.append(Util.nl);\r\n                buf.append(\"   measure=\");\r\n                buf.append(measureBitKey);\r\n                buf.append(Util.nl);\r\n                buf.append(\"   aggstar=\");\r\n                buf.append(aggStar.getBitKey());\r\n                buf.append(Util.nl);\r\n                buf.append(\"AggStar=\");\r\n                buf.append(aggStar.getFactTable().getName());\r\n                buf.append(Util.nl);\r\n                for (AggStar.Table.Column column : aggStar.getFactTable().getColumns()) {\r\n                    buf.append(\"   \");\r\n                    buf.append(column);\r\n                    buf.append(Util.nl);\r\n                }\r\n                LOGGER.debug(buf.toString());\r\n            }\r\n            AggQuerySpec aggQuerySpec = new AggQuerySpec(aggStar, rollup[0], groupingSetsList);\r\n            Pair<String, List<Type>> sql = aggQuerySpec.generateSqlQuery();\r\n            if (LOGGER.isDebugEnabled()) {\r\n                LOGGER.debug(\"generateSqlQuery: sql=\" + sql.left);\r\n            }\r\n            return sql;\r\n        }\r\n    }\r\n    if (LOGGER.isDebugEnabled()) {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"NO MATCH : \");\r\n        sb.append(star.getFactTable().getAlias());\r\n        sb.append(Util.nl);\r\n        sb.append(\"Foreign columns bit key=\");\r\n        sb.append(levelBitKey);\r\n        sb.append(Util.nl);\r\n        sb.append(\"Measure bit key=        \");\r\n        sb.append(measureBitKey);\r\n        sb.append(Util.nl);\r\n        sb.append(\"Agg Stars=[\");\r\n        sb.append(Util.nl);\r\n        for (AggStar aggStar : star.getAggStars()) {\r\n            sb.append(aggStar.toString());\r\n        }\r\n        sb.append(Util.nl);\r\n        sb.append(\"]\");\r\n        LOGGER.debug(sb.toString());\r\n    }\r\n    SegmentArrayQuerySpec spec = new SegmentArrayQuerySpec(groupingSetsList, compoundPredicateList);\r\n    Pair<String, List<SqlStatement.Type>> pair = spec.generateSqlQuery();\r\n    if (LOGGER.isDebugEnabled()) {\r\n        LOGGER.debug(\"generateSqlQuery: sql=\" + pair.left);\r\n    }\r\n    return pair;\r\n}"
}, {
	"Path": "com.oath.micro.server.s3.data.S3Utils.emptyInputStream",
	"Comment": "provide empty inputstream.this implementation can be convenient if you need to place some emptyvalue to s3 bucket.",
	"Method": "InputStream emptyInputStream(){\r\n    return emptyInputStream;\r\n}"
}, {
	"Path": "mondrian.test.UdfTest.testCellFormatterOnCalcMemberScript",
	"Comment": "unit test for a cell formatter defined against a calculated member,using a script.",
	"Method": "void testCellFormatterOnCalcMemberScript(){\r\n    TestContext tc = calcMemberTestContext(\"<CalculatedMember\\n\" + \"  name='Unit Sales Foo Bar'\\n\" + \"      dimension='Measures'>\\n\" + \"  <Formula>[Measures].[Unit Sales]<\/Formula>\\n\" + \"  <CellFormatter>\\n\" + \"    <Script>\\n\" + \"      return \\\"foo\\\" + value + \\\"bar\\\";\\n\" + \"    <\/Script>\\n\" + \"  <\/CellFormatter>\\n\" + \"<\/CalculatedMember>\");\r\n    tc.assertQueryReturns(\"select {[Measures].[Unit Sales],\\n\" + \"      [Measures].[Unit Sales Foo Bar]} on 0\\n\" + \"from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"{[Measures].[Unit Sales Foo Bar]}\\n\" + \"Row #0: 266,773\\n\" + \"Row #0: foo266773bar\\n\");\r\n}"
}, {
	"Path": "mondrian.rolap.SqlTupleReader.countMembers",
	"Comment": "returns the number of members that have been read from all targets.",
	"Method": "int countMembers(){\r\n    int n = 0;\r\n    for (TargetBase target : targets) {\r\n        if (target.getList() != null) {\r\n            n += target.getList().size();\r\n        }\r\n    }\r\n    return n;\r\n}"
}, {
	"Path": "mondrian.test.UdfTest.testUdfBothScriptAndClassname",
	"Comment": "unit test that ensures that a udf does not have both a scriptand a classname.",
	"Method": "void testUdfBothScriptAndClassname(){\r\n    TestContext tc = udfTestContext(\"<UserDefinedFunction name='StringMult' className='foo'>\\n\" + \" <Script>bar<\/Script>\\n\" + \"<\/UserDefinedFunction>\");\r\n    tc.assertQueryThrows(\"select from [Sales]\", \"Must not specify both className attribute and Script element\");\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.ui.widget.StaggeredGridView.setOnItemClickListener",
	"Comment": "register a callback to be invoked when an item in this adapterview hasbeen clicked.",
	"Method": "void setOnItemClickListener(OnItemClickListener listener){\r\n    mOnItemClickListener = listener;\r\n}"
}, {
	"Path": "mondrian.rolap.FilterTest.testNotInMultiLevelMemberConstraintNonNullParent",
	"Comment": "test that null members are included when the filter excludes membersthat contain multiple levels, but none being null.",
	"Method": "void testNotInMultiLevelMemberConstraintNonNullParent(){\r\n    if (MondrianProperties.instance().ReadAggregates.get()) {\r\n        return;\r\n    }\r\n    String query = \"With \" + \"Set [*NATIVE_CJ_SET] as 'NonEmptyCrossJoin([*BASE_MEMBERS_Customers],[*BASE_MEMBERS_Quarters])' \" + \"Set [*BASE_MEMBERS_Customers] as 'Filter([Customers].[Country].Members, [Customers].CurrentMember In {[Customers].[All Customers].[USA]})' \" + \"Set [*BASE_MEMBERS_Quarters] as 'Filter([Time].[Quarter].Members, \" + \"[Time].currentMember not in {[Time].[1997].[Q1], [Time].[1998].[Q3]})' \" + \"Set [*CJ_ROW_AXIS] as 'Generate([*NATIVE_CJ_SET], {([Customers].currentMember,[Time].currentMember)})' \" + \"Set [*ORDERED_CJ_ROW_AXIS] as 'Order([*CJ_ROW_AXIS], [Time].currentmember.OrderKey, BASC)' \" + \"Select \" + \"{[Measures].[Customer Count]} on columns, \" + \"Non Empty [*ORDERED_CJ_ROW_AXIS] on rows \" + \"From [Sales]\";\r\n    String necjSqlDerby = \"select \\\"customer\\\".\\\"country\\\", \\\"time_by_day\\\".\\\"the_year\\\", \" + \"\\\"time_by_day\\\".\\\"quarter\\\" from \\\"customer\\\" as \\\"customer\\\", \" + \"\\\"sales_fact_1997\\\" as \\\"sales_fact_1997\\\", \\\"time_by_day\\\" as \" + \"\\\"time_by_day\\\" where \\\"sales_fact_1997\\\".\\\"customer_id\\\" = \" + \"\\\"customer\\\".\\\"customer_id\\\" and \\\"sales_fact_1997\\\".\\\"time_id\\\" = \" + \"\\\"time_by_day\\\".\\\"time_id\\\" and (\\\"customer\\\".\\\"country\\\" = 'USA') and \" + \"(not ((\\\"time_by_day\\\".\\\"the_year\\\" = 1997 and \\\"time_by_day\\\".\\\"quarter\\\" \" + \"= 'Q1') or (\\\"time_by_day\\\".\\\"the_year\\\" = 1998 and \" + \"\\\"time_by_day\\\".\\\"quarter\\\" = 'Q3')) or ((\\\"time_by_day\\\".\\\"quarter\\\" is \" + \"null or \\\"time_by_day\\\".\\\"the_year\\\" is null) and \" + \"not((\\\"time_by_day\\\".\\\"the_year\\\" = 1997 and \\\"time_by_day\\\".\\\"quarter\\\" \" + \"= 'Q1') or (\\\"time_by_day\\\".\\\"the_year\\\" = 1998 and \" + \"\\\"time_by_day\\\".\\\"quarter\\\" = 'Q3')))) group by \\\"customer\\\".\\\"country\\\", \" + \"\\\"time_by_day\\\".\\\"the_year\\\", \\\"time_by_day\\\".\\\"quarter\\\" \" + \"order by CASE WHEN \\\"customer\\\".\\\"country\\\" IS NULL THEN 1 ELSE 0 END, \\\"customer\\\".\\\"country\\\" ASC, CASE WHEN \\\"time_by_day\\\".\\\"the_year\\\" IS NULL THEN 1 ELSE 0 END, \\\"time_by_day\\\".\\\"the_year\\\" ASC, CASE WHEN \\\"time_by_day\\\".\\\"quarter\\\" IS NULL THEN 1 ELSE 0 END, \\\"time_by_day\\\".\\\"quarter\\\" ASC\";\r\n    String necjSqlMySql = \"select `customer`.`country` as `c0`, `time_by_day`.`the_year` as `c1`, \" + \"`time_by_day`.`quarter` as `c2` from `customer` as `customer`, \" + \"`sales_fact_1997` as `sales_fact_1997`, `time_by_day` as `time_by_day` \" + \"where `sales_fact_1997`.`customer_id` = `customer`.`customer_id` \" + \"and `sales_fact_1997`.`time_id` = `time_by_day`.`time_id` and \" + \"(`customer`.`country` = 'USA') and \" + \"(not ((`time_by_day`.`quarter`, `time_by_day`.`the_year`) in \" + \"(('Q1', 1997), ('Q3', 1998))) or (`time_by_day`.`quarter` is null or \" + \"`time_by_day`.`the_year` is null)) \" + \"group by `customer`.`country`, `time_by_day`.`the_year`, `time_by_day`.`quarter` \" + (TestContext.instance().getDialect().requiresOrderByAlias() ? \"order by ISNULL(`c0`) ASC, \" + \"`c0` ASC, ISNULL(`c1`) ASC, \" + \"`c1` ASC, ISNULL(`c2`) ASC, \" + \"`c2` ASC\" : \"order by ISNULL(`customer`.`country`) ASC, \" + \"`customer`.`country` ASC, ISNULL(`time_by_day`.`the_year`) ASC, \" + \"`time_by_day`.`the_year` ASC, ISNULL(`time_by_day`.`quarter`) ASC, \" + \"`time_by_day`.`quarter` ASC\");\r\n    SqlPattern[] patterns = { new SqlPattern(Dialect.DatabaseProduct.DERBY, necjSqlDerby, necjSqlDerby), new SqlPattern(Dialect.DatabaseProduct.MYSQL, necjSqlMySql, necjSqlMySql) };\r\n    assertQuerySql(query, patterns);\r\n}"
}, {
	"Path": "org.sqlite.database.DatabaseUtils.blobFileDescriptorForQuery",
	"Comment": "utility method to run the query on the db and return the blob value in thefirst column of the first row.",
	"Method": "ParcelFileDescriptor blobFileDescriptorForQuery(SQLiteDatabase db,String query,String[] selectionArgs,ParcelFileDescriptor blobFileDescriptorForQuery,SQLiteStatement prog,String[] selectionArgs){\r\n    prog.bindAllArgsAsStrings(selectionArgs);\r\n    return prog.simpleQueryForBlobFileDescriptor();\r\n}"
}, {
	"Path": "mondrian.spi.SegmentHeader.getSortedRegions",
	"Comment": "this function returns a sorted view of the excluded regionsof this segment. we cannot sort them at construction becausechanging their order would make it not correspond to its segmentdataset.use this method with caution, not in tight loops.",
	"Method": "List<SegmentColumn> getSortedRegions(){\r\n    List<SegmentColumn> sortedRegions = new ArrayList(excludedRegions);\r\n    Collections.sort(sortedRegions, new Comparator<SegmentColumn>() {\r\n        public int compare(SegmentColumn o1, SegmentColumn o2) {\r\n            return o1.columnExpression.compareTo(o2.columnExpression);\r\n        }\r\n    });\r\n    return sortedRegions;\r\n}"
}, {
	"Path": "mondrian.spi.SegmentHeader.getSortedRegions",
	"Comment": "this function returns a sorted view of the excluded regionsof this segment. we cannot sort them at construction becausechanging their order would make it not correspond to its segmentdataset.use this method with caution, not in tight loops.",
	"Method": "List<SegmentColumn> getSortedRegions(){\r\n    return o1.columnExpression.compareTo(o2.columnExpression);\r\n}"
}, {
	"Path": "mondrian.rolap.SqlMemberSourceTest.getCityLevelMock",
	"Comment": "below there are mocked levels in store hierarchy of store dimension according to the default test foodmart schema",
	"Method": "RolapLevel getCityLevelMock(){\r\n    mondrian.olap.MondrianDef.Level level = new MondrianDef.Level(wrapStrSources(getStoreCity()));\r\n    RolapLevel rlLevel = new RolapLevel(storeHierarchyMock, 0, level);\r\n    RolapLevel rlLevelSpy = spy(rlLevel);\r\n    return rlLevelSpy;\r\n}"
}, {
	"Path": "mondrian.test.CompatibilityTest.testNullCollation",
	"Comment": "tests that null values sort last on all platforms. on some platforms,such as mysql, nulls naturally come before other values, so we have togenerate a modified order by clause.",
	"Method": "void testNullCollation(){\r\n    if (!getTestContext().getDialect().supportsGroupByExpressions()) {\r\n        return;\r\n    }\r\n    final String cubeName = \"Store_NullsCollation\";\r\n    final TestContext testContext = TestContext.instance().create(null, \"<Cube name=\\\"\" + cubeName + \"\\\">\\n\" + \"  <Table name=\\\"store\\\"/>\\n\" + \"  <Dimension name=\\\"Store\\\" foreignKey=\\\"store_id\\\">\\n\" + \"    <Hierarchy hasAll=\\\"true\\\" primaryKey=\\\"store_id\\\">\\n\" + \"      <Level name=\\\"Store Name\\\" column=\\\"store_name\\\"  uniqueMembers=\\\"true\\\">\\n\" + \"       <OrdinalExpression>\\n\" + \"        <SQL dialect=\\\"access\\\">\\n\" + \"           Iif(store_name = 'HQ', null, store_name)\\n\" + \"       <\/SQL>\\n\" + \"        <SQL dialect=\\\"oracle\\\">\\n\" + \"           case \\\"store_name\\\" when 'HQ' then null else \\\"store_name\\\" end\\n\" + \"       <\/SQL>\\n\" + \"        <SQL dialect=\\\"hsqldb\\\">\\n\" + \"           case \\\"store_name\\\" when 'HQ' then null else \\\"store_name\\\" end\\n\" + \"       <\/SQL>\\n\" + \"        <SQL dialect=\\\"db2\\\">\\n\" + \"           case \\\"store\\\".\\\"store_name\\\" when 'HQ' then null else \\\"store\\\".\\\"store_name\\\" end\\n\" + \"       <\/SQL>\\n\" + \"        <SQL dialect=\\\"luciddb\\\">\\n\" + \"           case \\\"store_name\\\" when 'HQ' then null else \\\"store_name\\\" end\\n\" + \"       <\/SQL>\\n\" + \"        <SQL dialect=\\\"netezza\\\">\\n\" + \"           case \\\"store_name\\\" when 'HQ' then null else \\\"store_name\\\" end\\n\" + \"       <\/SQL>\\n\" + \"        <SQL dialect=\\\"generic\\\">\\n\" + \"           case store_name when 'HQ' then null else store_name end\\n\" + \"       <\/SQL>\\n\" + \"       <\/OrdinalExpression>\\n\" + \"        <Property name=\\\"Store Sqft\\\" column=\\\"store_sqft\\\" type=\\\"Numeric\\\"/>\\n\" + \"      <\/Level>\\n\" + \"    <\/Hierarchy>\\n\" + \"  <\/Dimension>\\n\" + \"  <Measure name=\\\"Store Sqft\\\" column=\\\"store_sqft\\\" aggregator=\\\"sum\\\"\\n\" + \"      formatString=\\\"#,###\\\"/>\\n\" + \"<\/Cube>\", null, null, null, null);\r\n    testContext.assertQueryReturns(\"select { [Measures].[Store Sqft] } on columns,\\n\" + \" NON EMPTY topcount(\\n\" + \"    {[Store].[Store Name].members},\\n\" + \"    5,\\n\" + \"    [measures].[store sqft]) on rows\\n\" + \"from [\" + cubeName + \"] \", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Store Sqft]}\\n\" + \"Axis #2:\\n\" + \"{[Store].[Store 3]}\\n\" + \"{[Store].[Store 18]}\\n\" + \"{[Store].[Store 9]}\\n\" + \"{[Store].[Store 10]}\\n\" + \"{[Store].[Store 20]}\\n\" + \"Row #0: 39,696\\n\" + \"Row #1: 38,382\\n\" + \"Row #2: 36,509\\n\" + \"Row #3: 34,791\\n\" + \"Row #4: 34,452\\n\");\r\n}"
}, {
	"Path": "cc.mallet.util.VectorStats.stddev",
	"Comment": "square root of unbiased variance of instances having the given mean",
	"Method": "SparseVector stddev(InstanceList instances,SparseVector mean,boolean unbiased,SparseVector stddev,InstanceList instances,SparseVector stddev,InstanceList instances,boolean unbiased,SparseVector stddev,InstanceList instances,SparseVector mean){\r\n    return stddev(instances, mean, true);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.H5.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "H5 appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.olap.fun.AbstractAggregateFunDef.evaluateCurrentList",
	"Comment": "evaluates the list of members or tuples used in computing the aggregate.if the measure for aggregation has to ignore unrelated dimensionsthis method will push unrelated dimension members to top level member.this behaviour is driven by the ignoreunrelateddimensions propertyon a base cube usage specified in the virtual cube.keeps track of thenumber of iterations that will be required to iterate over the membersor tuples needed to compute the aggregate within the current context.in doing so, also determines if the cross product of all iterationsacross all parent evaluation contexts will exceed the limit set in theproperties file.",
	"Method": "TupleList evaluateCurrentList(ListCalc listCalc,Evaluator evaluator){\r\n    final int savepoint = evaluator.savepoint();\r\n    TupleList tuples;\r\n    try {\r\n        evaluator.setNonEmpty(false);\r\n        tuples = listCalc.evaluateList(evaluator);\r\n    } finally {\r\n        evaluator.restore(savepoint);\r\n    }\r\n    int currLen = tuples.size();\r\n    TupleList dims;\r\n    try {\r\n        dims = processUnrelatedDimensions(tuples, evaluator);\r\n    } finally {\r\n        evaluator.restore(savepoint);\r\n    }\r\n    crossProd(evaluator, currLen);\r\n    return dims;\r\n}"
}, {
	"Path": "mondrian.server.Execution.unregisterSegmentRequests",
	"Comment": "calls into the segmentcachemanager and unregisters all theregistrations made for this execution on segments formthe index.",
	"Method": "void unregisterSegmentRequests(){\r\n    final Locus locus = new Locus(this, \"Execution.unregisterSegmentRequests\", \"cleaning up segment registrations\");\r\n    final SegmentCacheManager mgr = locus.getServer().getAggregationManager().cacheMgr;\r\n    mgr.execute(new SegmentCacheManager.Command<Void>() {\r\n        public Void call() throws Exception {\r\n            mgr.getIndexRegistry().cancelExecutionSegments(Execution.this);\r\n            return null;\r\n        }\r\n        public Locus getLocus() {\r\n            return locus;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "mondrian.server.Execution.unregisterSegmentRequests",
	"Comment": "calls into the segmentcachemanager and unregisters all theregistrations made for this execution on segments formthe index.",
	"Method": "void unregisterSegmentRequests(){\r\n    mgr.getIndexRegistry().cancelExecutionSegments(Execution.this);\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.server.Execution.unregisterSegmentRequests",
	"Comment": "calls into the segmentcachemanager and unregisters all theregistrations made for this execution on segments formthe index.",
	"Method": "void unregisterSegmentRequests(){\r\n    return locus;\r\n}"
}, {
	"Path": "mondrian.rolap.format.FormatterFactoryTest.testShouldCreateFormatterByScript",
	"Comment": "given that custom formatter script is specified.when formatter creating is requested,factory should instantiate an object of script based implementation.",
	"Method": "void testShouldCreateFormatterByScript(){\r\n    FormatterCreateContext context = new FormatterCreateContext.Builder(\"name\").script(\"return null;\", \"JavaScript\").build();\r\n    CellFormatter cellFormatter = factory.createCellFormatter(context);\r\n    MemberFormatter memberFormatter = factory.createRolapMemberFormatter(context);\r\n    PropertyFormatter propertyFormatter = factory.createPropertyFormatter(context);\r\n    assertNotNull(cellFormatter);\r\n    assertNotNull(memberFormatter);\r\n    assertNotNull(propertyFormatter);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.getDbMeta",
	"Comment": "convenience method for retrieving the dbmeta instance that handlesrequired kettle initialization.",
	"Method": "DatabaseMeta getDbMeta(String xml){\r\n    try {\r\n        if (!KettleClientEnvironment.isInitialized()) {\r\n            System.setProperty(\"KETTLE_PLUGIN_BASE_FOLDERS\", KETTLE_PLUGIN_BASE_FOLDERS);\r\n            KettleClientEnvironment.init();\r\n        }\r\n        if (dbMeta != null) {\r\n            return dbMeta;\r\n        }\r\n        if (xml == null) {\r\n            dbMeta = new DatabaseMeta();\r\n        } else {\r\n            dbMeta = new DatabaseMeta(xml);\r\n        }\r\n    } catch (KettleException e) {\r\n        throw new RuntimeException(getResourceConverter().getFormattedString(\"workbench.new.Kettle.exception\", \"Kettle failed to initialize.\"), e);\r\n    }\r\n    return dbMeta;\r\n}"
}, {
	"Path": "org.mapsforge.core.util.LatLongUtils.latitudeDistance",
	"Comment": "calculates the amount of degrees of latitude for a given distance in meters.",
	"Method": "double latitudeDistance(int meters){\r\n    return (meters * 360) / (2 * Math.PI * EQUATORIAL_RADIUS);\r\n}"
}, {
	"Path": "org.fusesource.mqtt.client.CallbackConnection.createTransport",
	"Comment": "creates and start a transport to the mqtt server.passes it to the onconnectonce the transport is connected.",
	"Method": "void createTransport(Callback<Transport> onConnect){\r\n    mqtt.tracer.debug(\"Connecting\");\r\n    String scheme = mqtt.host.getScheme();\r\n    final Transport transport;\r\n    if (\"tcp\".equals(scheme)) {\r\n        transport = new TcpTransport();\r\n    } else if (SslTransport.protocol(scheme) != null) {\r\n        SslTransport ssl = new SslTransport();\r\n        if (mqtt.sslContext == null) {\r\n            mqtt.sslContext = SSLContext.getDefault();\r\n        }\r\n        ssl.setSSLContext(mqtt.sslContext);\r\n        transport = ssl;\r\n    } else {\r\n        throw new Exception(\"Unsupported URI scheme '\" + scheme + \"'\");\r\n    }\r\n    if (mqtt.blockingExecutor == null) {\r\n        mqtt.blockingExecutor = MQTT.getBlockingThreadPool();\r\n    }\r\n    transport.setBlockingExecutor(mqtt.blockingExecutor);\r\n    transport.setDispatchQueue(queue);\r\n    transport.setProtocolCodec(new MQTTProtocolCodec());\r\n    if (transport instanceof TcpTransport) {\r\n        TcpTransport tcp = (TcpTransport) transport;\r\n        tcp.setMaxReadRate(mqtt.maxReadRate);\r\n        tcp.setMaxWriteRate(mqtt.maxWriteRate);\r\n        tcp.setReceiveBufferSize(mqtt.receiveBufferSize);\r\n        tcp.setSendBufferSize(mqtt.sendBufferSize);\r\n        tcp.setTrafficClass(mqtt.trafficClass);\r\n        tcp.setUseLocalHost(mqtt.useLocalHost);\r\n        tcp.connecting(mqtt.host, mqtt.localAddress);\r\n    }\r\n    transport.setTransportListener(new DefaultTransportListener() {\r\n        @Override\r\n        public void onTransportConnected() {\r\n            mqtt.tracer.debug(\"Transport connected\");\r\n            if (disconnected) {\r\n                onFailure(createDisconnectedError());\r\n            } else {\r\n                onConnect.onSuccess(transport);\r\n            }\r\n        }\r\n        @Override\r\n        public void onTransportFailure(final IOException error) {\r\n            mqtt.tracer.debug(\"Transport failure: %s\", error);\r\n            onFailure(error);\r\n        }\r\n        private void onFailure(final Throwable error) {\r\n            if (!transport.isClosed()) {\r\n                transport.stop(new Task() {\r\n                    @Override\r\n                    public void run() {\r\n                        onConnect.onFailure(error);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n    transport.start(NOOP);\r\n}"
}, {
	"Path": "org.fusesource.mqtt.client.CallbackConnection.createTransport",
	"Comment": "creates and start a transport to the mqtt server.passes it to the onconnectonce the transport is connected.",
	"Method": "void createTransport(Callback<Transport> onConnect){\r\n    mqtt.tracer.debug(\"Transport connected\");\r\n    if (disconnected) {\r\n        onFailure(createDisconnectedError());\r\n    } else {\r\n        onConnect.onSuccess(transport);\r\n    }\r\n}"
}, {
	"Path": "org.fusesource.mqtt.client.CallbackConnection.createTransport",
	"Comment": "creates and start a transport to the mqtt server.passes it to the onconnectonce the transport is connected.",
	"Method": "void createTransport(Callback<Transport> onConnect){\r\n    mqtt.tracer.debug(\"Transport failure: %s\", error);\r\n    onFailure(error);\r\n}"
}, {
	"Path": "org.fusesource.mqtt.client.CallbackConnection.createTransport",
	"Comment": "creates and start a transport to the mqtt server.passes it to the onconnectonce the transport is connected.",
	"Method": "void createTransport(Callback<Transport> onConnect){\r\n    if (!transport.isClosed()) {\r\n        transport.stop(new Task() {\r\n            @Override\r\n            public void run() {\r\n                onConnect.onFailure(error);\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "org.fusesource.mqtt.client.CallbackConnection.createTransport",
	"Comment": "creates and start a transport to the mqtt server.passes it to the onconnectonce the transport is connected.",
	"Method": "void createTransport(Callback<Transport> onConnect){\r\n    onConnect.onFailure(error);\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlImpl.flattenUnion",
	"Comment": "flatten a region into a list of regions none of which are unions.",
	"Method": "void flattenUnion(CellRegionImpl region,List<CellRegionImpl> list){\r\n    if (region instanceof UnionCellRegion) {\r\n        UnionCellRegion union = (UnionCellRegion) region;\r\n        for (CellRegionImpl region1 : union.regions) {\r\n            flattenUnion(region1, list);\r\n        }\r\n    } else {\r\n        list.add(region);\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.map.layer.hills.HillsRenderConfig.indexOnThread",
	"Comment": "call after initialization, after a set of changes to the settable properties or after forcereindex to initiate background indexing",
	"Method": "HillsRenderConfig indexOnThread(){\r\n    ShadeTileSource cache = tileSource;\r\n    if (cache != null)\r\n        cache.applyConfiguration(true);\r\n    return this;\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testExpandCalcMembersInAllInputs",
	"Comment": "verifies that the presence of calculated member in all the inputsdisables native evaluation, even when expandnonnative is true.",
	"Method": "void testExpandCalcMembersInAllInputs(){\r\n    propSaver.set(MondrianProperties.instance().ExpandNonNative, true);\r\n    propSaver.set(MondrianProperties.instance().EnableNativeCrossJoin, true);\r\n    checkNotNative(1, \"With \" + \"Member [Product].[*CTX_MEMBER_SEL~SUM] as 'Sum({[Product].[Product Family].Members})' \" + \"Member [Gender].[*CTX_MEMBER_SEL~SUM] as 'Sum({[Gender].[All Gender]})' \" + \"Select \" + \"NonEmptyCrossJoin({[Gender].[*CTX_MEMBER_SEL~SUM]},{[Product].[*CTX_MEMBER_SEL~SUM]}) \" + \"on columns \" + \"From [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Gender].[*CTX_MEMBER_SEL~SUM], [Product].[*CTX_MEMBER_SEL~SUM]}\\n\" + \"Row #0: 266,773\\n\");\r\n}"
}, {
	"Path": "mondrian.test.MonitorTest.testMe",
	"Comment": "exercises as many fields of the monitoring stats classes as possible.so that we can check that they are being populated.",
	"Method": "void testMe(){\r\n    String queryString = \"WITH MEMBER [Measures].[Foo] AS\\n\" + \" [Measures].[Unit Sales]\" + \" + case when [Measures].[Unit Sales] > 0\\n\" + \"   then CInt( ([Measures].[Foo], [Time].PrevMember) )\\n\" + \"   end\\n\" + \"SELECT [Measures].[Foo] on 0\\n\" + \"from [Sales]\\n\" + \"where [Time].[1997].[Q3].[9]\";\r\n    final OlapStatement statement1 = getTestContext().getOlap4jConnection().createStatement();\r\n    CellSet cellSet = statement1.executeOlapQuery(queryString);\r\n    StringWriter stringWriter = new StringWriter();\r\n    new RectangularCellSetFormatter(true).format(cellSet, new PrintWriter(stringWriter));\r\n    statement1.close();\r\n    println(stringWriter);\r\n    final MondrianServer mondrianServer = MondrianServer.forConnection(getConnection());\r\n    final Monitor monitor = mondrianServer.getMonitor();\r\n    final ServerInfo server = monitor.getServer();\r\n    println(\"# stmts open: \" + server.getStatementCurrentlyOpenCount());\r\n    println(\"# connections open: \" + server.getConnectionCurrentlyOpenCount());\r\n    println(\"# rows fetched: \" + server.sqlStatementRowFetchCount);\r\n    println(\"# sql stmts open: \" + server.getSqlStatementCurrentlyOpenCount());\r\n    final List<ConnectionInfo> connections = monitor.getConnections();\r\n    ConnectionInfo lastConnection = connections.get(connections.size() - 1);\r\n    println(\"# cell cache requests, misses, hits; \" + \"by server, connection, mdx statement: \" + server.cellCacheRequestCount + \", \" + server.getCellCacheMissCount() + \", \" + server.cellCacheHitCount + \"; \" + lastConnection.cellCacheRequestCount + \", \" + (lastConnection.cellCacheRequestCount - lastConnection.cellCacheHitCount) + \", \" + lastConnection.cellCacheHitCount);\r\n    println(\"number of mdx statements currently open: \" + server.getStatementCurrentlyOpenCount());\r\n    println(\"number of mdx statements currently executing: \" + server.getStatementCurrentlyExecutingCount());\r\n    println(\"jvm memory: \" + server.jvmHeapBytesUsed + \", max: \" + server.jvmHeapBytesMax + \", committed: \" + server.jvmHeapBytesCommitted);\r\n    println(\"number of segments: \" + server.segmentCount + \", ever created: \" + server.segmentCreateCount + \", number of cells: \" + server.cellCount + \", number of cell coordinates: \" + server.cellCoordinateCount + \", average cell dimensionality: \" + ((float) server.cellCoordinateCount / (float) server.cellCount));\r\n    println(\"Connection: \" + lastConnection);\r\n    println(\"Server: \" + server);\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletResponse.isCommitted",
	"Comment": "returns a boolean indicating if the response has been committed.",
	"Method": "boolean isCommitted(){\r\n    return isCommited;\r\n}"
}, {
	"Path": "org.mapsforge.samples.android.SimplestMapViewer.createLayers",
	"Comment": "creates a simple tile renderer layer with the androidutil helper.",
	"Method": "void createLayers(){\r\n    TileRendererLayer tileRendererLayer = AndroidUtil.createTileRendererLayer(this.tileCaches.get(0), this.mapView.getModel().mapViewPosition, getMapFile(), getRenderTheme(), false, true, false);\r\n    this.mapView.getLayerManager().getLayers().add(tileRendererLayer);\r\n}"
}, {
	"Path": "mondrian.olap.IdBatchResolver.supportedIdentifier",
	"Comment": "checks various conditions to determine whetherthe given identifier is likely to be resolvable at this point.",
	"Method": "boolean supportedIdentifier(Id id){\r\n    Id.Segment seg = getLastSegment(id);\r\n    if (!(seg instanceof Id.NameSegment)) {\r\n        return false;\r\n    }\r\n    return (isPossibleMemberRef(id)) && !segmentIsCalcMember(id.getSegments()) && !id.getSegments().get(0).matches(\"Measures\");\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteDatabase.setMaximumSize",
	"Comment": "sets the maximum size the database will grow to. the maximum size cannotbe set below the current size.",
	"Method": "long setMaximumSize(long numBytes){\r\n    long pageSize = getPageSize();\r\n    long numPages = numBytes / pageSize;\r\n    if ((numBytes % pageSize) != 0) {\r\n        numPages++;\r\n    }\r\n    long newPageCount = DatabaseUtils.longForQuery(this, \"PRAGMA max_page_count = \" + numPages, null);\r\n    return newPageCount * pageSize;\r\n}"
}, {
	"Path": "mondrian.rolap.agg.CellRequest.isUnsatisfiable",
	"Comment": "returns whether this cell request is impossible to satisfy.this occurs when the same column has two or more inconsistentconstraints.",
	"Method": "boolean isUnsatisfiable(){\r\n    return unsatisfiable;\r\n}"
}, {
	"Path": "mondrian.test.ParallelTest.checkSchemaFlush",
	"Comment": "tests several threads, each of which is creating connections andperiodically flushing the schema cache.",
	"Method": "void checkSchemaFlush(int count,int cycleCount,int flushInverseFrequency){\r\n    final Random random = new Random(123456);\r\n    Worker[] workers = new Worker[count];\r\n    Thread[] threads = new Thread[count];\r\n    for (int i = 0; i < count; i++) {\r\n        workers[i] = new Worker() {\r\n            public void runSafe() {\r\n                for (int i = 0; i < cycleCount; ++i) {\r\n                    cycle();\r\n                    try {\r\n                        Thread.sleep(random.nextInt(100));\r\n                    } catch (InterruptedException e) {\r\n                        throw Util.newInternal(e, \"interrupted\");\r\n                    }\r\n                }\r\n            }\r\n            private void cycle() {\r\n                Connection connection = getConnection();\r\n                Query query = connection.parseQuery(\"select {[Measures].[Unit Sales]} on columns,\" + \" {[Product].Members} on rows \" + \"from [Sales]\");\r\n                Result result = connection.execute(query);\r\n                String s = result.toString();\r\n                assertNotNull(s);\r\n                if (random.nextInt(flushInverseFrequency) == 0) {\r\n                    final CacheControl cacheControl = connection.getCacheControl(null);\r\n                    cacheControl.flushSchemaCache();\r\n                }\r\n            }\r\n        };\r\n        threads[i] = new Thread(workers[i]);\r\n    }\r\n    for (int i = 0; i < count; i++) {\r\n        threads[i].start();\r\n    }\r\n    for (int i = 0; i < count; i++) {\r\n        try {\r\n            threads[i].join();\r\n        } catch (InterruptedException e) {\r\n            throw Util.newInternal(e, \"while joining thread #\" + i);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.ParallelTest.checkSchemaFlush",
	"Comment": "tests several threads, each of which is creating connections andperiodically flushing the schema cache.",
	"Method": "void checkSchemaFlush(int count,int cycleCount,int flushInverseFrequency){\r\n    for (int i = 0; i < cycleCount; ++i) {\r\n        cycle();\r\n        try {\r\n            Thread.sleep(random.nextInt(100));\r\n        } catch (InterruptedException e) {\r\n            throw Util.newInternal(e, \"interrupted\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.ParallelTest.checkSchemaFlush",
	"Comment": "tests several threads, each of which is creating connections andperiodically flushing the schema cache.",
	"Method": "void checkSchemaFlush(int count,int cycleCount,int flushInverseFrequency){\r\n    Connection connection = getConnection();\r\n    Query query = connection.parseQuery(\"select {[Measures].[Unit Sales]} on columns,\" + \" {[Product].Members} on rows \" + \"from [Sales]\");\r\n    Result result = connection.execute(query);\r\n    String s = result.toString();\r\n    assertNotNull(s);\r\n    if (random.nextInt(flushInverseFrequency) == 0) {\r\n        final CacheControl cacheControl = connection.getCacheControl(null);\r\n        cacheControl.flushSchemaCache();\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.map.android.util.MapViewerTemplate.getDefaultInitialPosition",
	"Comment": "gets the default initial position of a map view if nothing is set in the map file. thisoperation is used as a fallback only. override this if you are not sure if your map filewill always have an initial position.",
	"Method": "MapPosition getDefaultInitialPosition(){\r\n    return new MapPosition(new LatLong(0, 0), getZoomLevelDefault());\r\n}"
}, {
	"Path": "mondrian.rolap.SqlMemberSource.levelContainsMultipleColumns",
	"Comment": "determine if a level contains more than a single column for itsdata, such as an ordinal column or property column",
	"Method": "boolean levelContainsMultipleColumns(RolapLevel level){\r\n    if (level.isAll()) {\r\n        return false;\r\n    }\r\n    MondrianDef.Expression keyExp = level.getKeyExp();\r\n    MondrianDef.Expression ordinalExp = level.getOrdinalExp();\r\n    MondrianDef.Expression captionExp = level.getCaptionExp();\r\n    if (!keyExp.equals(ordinalExp)) {\r\n        return true;\r\n    }\r\n    if (captionExp != null && !keyExp.equals(captionExp)) {\r\n        return true;\r\n    }\r\n    RolapProperty[] properties = level.getProperties();\r\n    for (RolapProperty property : properties) {\r\n        if (!property.getExp().equals(keyExp)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "mondrian.olap.DriverManager.getConnection",
	"Comment": "creates a connection to a mondrian olap engineusing a list of connection properties,a catalog locator,and a jdbc data source.",
	"Method": "Connection getConnection(String connectString,CatalogLocator locator,Connection getConnection,Util.PropertyList properties,CatalogLocator locator,Connection getConnection,Util.PropertyList properties,CatalogLocator locator,DataSource dataSource){\r\n    String provider = properties.get(\"PROVIDER\", \"mondrian\");\r\n    if (!provider.equalsIgnoreCase(\"mondrian\")) {\r\n        throw Util.newError(\"Provider not recognized: \" + provider);\r\n    }\r\n    final String instance = properties.get(RolapConnectionProperties.Instance.name());\r\n    MondrianServer server = MondrianServer.forId(instance);\r\n    if (server == null) {\r\n        throw Util.newError(\"Unknown server instance: \" + instance);\r\n    }\r\n    if (locator == null) {\r\n        locator = server.getCatalogLocator();\r\n    }\r\n    if (locator != null) {\r\n        String catalog = properties.get(RolapConnectionProperties.Catalog.name());\r\n        properties.put(RolapConnectionProperties.Catalog.name(), locator.locate(catalog));\r\n    }\r\n    final RolapConnection connection = new RolapConnection(server, properties, dataSource);\r\n    server.addConnection(connection);\r\n    return connection;\r\n}"
}, {
	"Path": "mondrian.olap.Query.cancel",
	"Comment": "issues a cancel request on this query object.once the threadrunning the query detects the cancel request, the query execution willthrow an exception. see basicquerytest.testcancel for anexample of usage of this method.",
	"Method": "void cancel(){\r\n    try {\r\n        statement.cancel();\r\n    } catch (SQLException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "mondrian.olap.Formula.getIdentifier",
	"Comment": "returns the identifier of the set or member which is declared by thisformula.",
	"Method": "Id getIdentifier(){\r\n    return id;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapHierarchy.relationSubsetInverse",
	"Comment": "returns the smallest subset of relation which containsthe relation alias, or null if these is no relation withsuch an alias, in inverse join order, used for agg tables.",
	"Method": "MondrianDef.RelationOrJoin relationSubsetInverse(MondrianDef.RelationOrJoin relation,String alias){\r\n    if (relation instanceof MondrianDef.Relation) {\r\n        MondrianDef.Relation table = (MondrianDef.Relation) relation;\r\n        return table.getAlias().equals(alias) ? relation : null;\r\n    } else if (relation instanceof MondrianDef.Join) {\r\n        MondrianDef.Join join = (MondrianDef.Join) relation;\r\n        MondrianDef.RelationOrJoin leftRelation = relationSubsetInverse(join.left, alias);\r\n        return (leftRelation == null) ? relationSubsetInverse(join.right, alias) : join;\r\n    } else {\r\n        throw Util.newInternal(\"bad relation type \" + relation);\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.FoodMartTestCase.assertSize",
	"Comment": "runs a query, and asserts that the result has a given number of columnsand rows.",
	"Method": "void assertSize(String queryString,int columnCount,int rowCount){\r\n    Result result = executeQuery(queryString);\r\n    Axis[] axes = result.getAxes();\r\n    Assert.assertTrue(axes.length == 2);\r\n    Assert.assertTrue(axes[0].getPositions().size() == columnCount);\r\n    Assert.assertTrue(axes[1].getPositions().size() == rowCount);\r\n}"
}, {
	"Path": "mondrian.mdx.ParameterExpr.uniqueName",
	"Comment": "returns the unique name of the level, hierarchy, or dimension of thistype, whichever is most specific.",
	"Method": "String uniqueName(Type type){\r\n    if (type.getLevel() != null) {\r\n        return type.getLevel().getUniqueName();\r\n    } else if (type.getHierarchy() != null) {\r\n        return type.getHierarchy().getUniqueName();\r\n    } else {\r\n        return type.getDimension().getUniqueName();\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.CompoundSlicerTest.testTopCountWithAggregatedMemberEnumCMSet",
	"Comment": "test case for the support of native top count with aggregated measuresusing enumerated members in a calculated member.",
	"Method": "void testTopCountWithAggregatedMemberEnumCMSet(){\r\n    assertQueryReturns(\"with set TO_AGGREGATE as '{[Time].[1997].[Q1] , [Time].[1997].[Q2]}'\\n\" + \"member Time.x as Aggregate(TO_AGGREGATE, [Measures].[Store Sales])\\n\" + \"member Measures.x1 as ([Time].[1997].[Q1], [Measures].[Store Sales])\\n\" + \"member Measures.x2 as ([Time].[1997].[Q2], [Measures].[Store Sales])\\n\" + \" set products as TopCount(Product.[Product Name].Members, 2, Measures.[Store Sales])\\n\" + \" SELECT NON EMPTY products ON 1,\\n\" + \"NON EMPTY {[Measures].[Store Sales], Measures.x1, Measures.x2} ON 0\\n\" + \" FROM [Sales] where Time.x\", \"Axis #0:\\n\" + \"{[Time].[x]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Store Sales]}\\n\" + \"{[Measures].[x1]}\\n\" + \"{[Measures].[x2]}\\n\" + \"Axis #2:\\n\" + \"{[Product].[Food].[Eggs].[Eggs].[Eggs].[Urban].[Urban Small Eggs]}\\n\" + \"{[Product].[Food].[Snack Foods].[Snack Foods].[Dried Fruit].[Fort West].[Fort West Raspberry Fruit Roll]}\\n\" + \"Row #0: 497.42\\n\" + \"Row #0: 235.62\\n\" + \"Row #0: 261.80\\n\" + \"Row #1: 462.84\\n\" + \"Row #1: 226.20\\n\" + \"Row #1: 236.64\\n\");\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.MapFileWriter.release",
	"Comment": "cleans up thread pool. must only be called at the end of processing.",
	"Method": "void release(){\r\n    EXECUTOR_SERVICE.shutdown();\r\n}"
}, {
	"Path": "mondrian.test.loader.MondrianFoodMartLoader.loadTable",
	"Comment": "read the given table from the input rdbms and output to destinationrdbms or file",
	"Method": "int loadTable(String name,Column[] columns,long pauseMillis,int batchSize){\r\n    int rowsAdded = 0;\r\n    StringBuilder buf = new StringBuilder();\r\n    buf.append(\"select \");\r\n    for (int i = 0; i < columns.length; i++) {\r\n        Column column = columns[i];\r\n        if (i > 0) {\r\n            buf.append(\",\");\r\n        }\r\n        buf.append(quoteId(dialect, column.name));\r\n    }\r\n    buf.append(\" from \").append(quoteId(dialect, inputSchema, name));\r\n    String ddl = buf.toString();\r\n    Statement statement = null;\r\n    ResultSet rs = null;\r\n    try {\r\n        statement = inputConnection.createStatement();\r\n        LOGGER.debug(\"Input table SQL: \" + ddl);\r\n        rs = statement.executeQuery(ddl);\r\n        List<String> batch = new ArrayList<String>(batchSize);\r\n        boolean displayedInsert = false;\r\n        while (rs.next()) {\r\n            String insertStatement = createInsertStatement(rs, name, columns);\r\n            if (!displayedInsert && LOGGER.isDebugEnabled()) {\r\n                LOGGER.debug(\"Example Insert statement: \" + insertStatement);\r\n                displayedInsert = true;\r\n            }\r\n            batch.add(insertStatement);\r\n            if (batch.size() >= batchSize) {\r\n                final int rowCount = writeBatch(batch, pauseMillis);\r\n                rowsAdded += rowCount;\r\n                batch.clear();\r\n                if (pauseMillis > 0) {\r\n                    final long t = System.currentTimeMillis();\r\n                    if (t - lastUpdate > 10000) {\r\n                        lastUpdate = t;\r\n                        LOGGER.debug(name + \": wrote row #\" + rowsAdded + \".\");\r\n                    }\r\n                    Thread.sleep(pauseMillis);\r\n                }\r\n            }\r\n        }\r\n        if (batch.size() > 0) {\r\n            rowsAdded += writeBatch(batch, pauseMillis);\r\n        }\r\n    } finally {\r\n        if (rs != null) {\r\n            try {\r\n                rs.close();\r\n            } catch (SQLException e) {\r\n            }\r\n        }\r\n        if (statement != null) {\r\n            try {\r\n                statement.close();\r\n            } catch (SQLException e) {\r\n            }\r\n        }\r\n    }\r\n    return rowsAdded;\r\n}"
}, {
	"Path": "mondrian.olap.Util.addDatabaseTime",
	"Comment": "adds to the cumulative amount of time spent accessing the database.",
	"Method": "void addDatabaseTime(long millis){\r\n    databaseMillis += millis;\r\n}"
}, {
	"Path": "org.mapsforge.map.android.util.MapViewerTemplate.hasZoomControls",
	"Comment": "configuration method to set if a map view activity will have zoom controls.",
	"Method": "boolean hasZoomControls(){\r\n    return true;\r\n}"
}, {
	"Path": "mondrian.olap.Util.lookup",
	"Comment": "looks up an enumeration by name, returning a given default value if nullor not valid.",
	"Method": "OlapElement lookup(Query q,List<Id.Segment> nameParts,Exp lookup,Query q,List<Id.Segment> nameParts,boolean allowProp,Exp lookup,Query q,SchemaReader schemaReader,List<Id.Segment> segments,boolean allowProp,E lookup,Class<E> clazz,String name,E lookup,Class<E> clazz,String name,E defaultValue){\r\n    if (name == null) {\r\n        return defaultValue;\r\n    }\r\n    try {\r\n        return Enum.valueOf(clazz, name);\r\n    } catch (IllegalArgumentException e) {\r\n        return defaultValue;\r\n    }\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.stablePartialSort",
	"Comment": "stable partial sort of a list. returns the desired head of the list.",
	"Method": "List<T> stablePartialSort(List<T> list,Comparator<T> comp,int limit,List<T> stablePartialSort,List<T> list,Comparator<T> comp,int limit,int algorithm){\r\n    assert limit <= list.size();\r\n    assert list.size() > 0;\r\n    for (; ; ) {\r\n        switch(algorithm) {\r\n            case 0:\r\n                float ratio = (float) limit / (float) list.size();\r\n                if (ratio <= .05) {\r\n                    algorithm = 4;\r\n                } else if (ratio <= .35) {\r\n                    algorithm = 2;\r\n                } else {\r\n                    algorithm = 1;\r\n                }\r\n                break;\r\n            case 1:\r\n                return stablePartialSortArray(list, comp, limit);\r\n            case 2:\r\n                return stablePartialSortMarc(list, comp, limit);\r\n            case 3:\r\n                return stablePartialSortPedro(list, comp, limit);\r\n            case 4:\r\n                return stablePartialSortJulian(list, comp, limit);\r\n            default:\r\n                throw new RuntimeException();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.map.reader.MapFile.restrictToZoomRange",
	"Comment": "restricts returns of data to zoom level range specified. this can be used to restrictthe use of this map data base when used in multimapdatabase settings.",
	"Method": "void restrictToZoomRange(byte minZoom,byte maxZoom){\r\n    this.zoomLevelMax = maxZoom;\r\n    this.zoomLevelMin = minZoom;\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.Base64.decodeToObject",
	"Comment": "attempts to decode base64 data and deserialize a java object within.returns null if there was an error. if loader is notnull, it will be the class loader used when deserializing.",
	"Method": "Object decodeToObject(String encodedObject,Object decodeToObject,String encodedObject,int options,ClassLoader loader){\r\n    byte[] objBytes = decode(encodedObject, options);\r\n    java.io.ByteArrayInputStream bais = null;\r\n    java.io.ObjectInputStream ois = null;\r\n    Object obj = null;\r\n    try {\r\n        bais = new java.io.ByteArrayInputStream(objBytes);\r\n        if (loader == null) {\r\n            ois = new java.io.ObjectInputStream(bais);\r\n        } else {\r\n            ois = new java.io.ObjectInputStream(bais) {\r\n                @Override\r\n                public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException, ClassNotFoundException {\r\n                    Class<?> c = Class.forName(streamClass.getName(), false, loader);\r\n                    if (c == null) {\r\n                        return super.resolveClass(streamClass);\r\n                    } else {\r\n                        return c;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        obj = ois.readObject();\r\n    } catch (java.io.IOException e) {\r\n        throw e;\r\n    } catch (java.lang.ClassNotFoundException e) {\r\n        throw e;\r\n    } finally {\r\n        try {\r\n            bais.close();\r\n        } catch (Exception e) {\r\n        }\r\n        try {\r\n            ois.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.Base64.decodeToObject",
	"Comment": "attempts to decode base64 data and deserialize a java object within.returns null if there was an error. if loader is notnull, it will be the class loader used when deserializing.",
	"Method": "Object decodeToObject(String encodedObject,Object decodeToObject,String encodedObject,int options,ClassLoader loader){\r\n    Class<?> c = Class.forName(streamClass.getName(), false, loader);\r\n    if (c == null) {\r\n        return super.resolveClass(streamClass);\r\n    } else {\r\n        return c;\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.agg.SegmentCacheWorker.get",
	"Comment": "returns a segment body corresponding to a header.if no cache is configured or there is an error whilequerying the cache, null is returned none the less.",
	"Method": "SegmentBody get(SegmentHeader header){\r\n    checkThread();\r\n    try {\r\n        return cache.get(header);\r\n    } catch (Throwable t) {\r\n        LOGGER.error(MondrianResource.instance().SegmentCacheFailedToLoadSegment.baseMessage, t);\r\n        throw MondrianResource.instance().SegmentCacheFailedToLoadSegment.ex(t);\r\n    }\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.A.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "A appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "org.mapsforge.map.layer.renderer.RendererJob.setRetrieveLabelsOnly",
	"Comment": "indicates that for this job only the labels should be generated.",
	"Method": "void setRetrieveLabelsOnly(){\r\n    this.labelsOnly = true;\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.getSock",
	"Comment": "returns appropriate sockio object given\tstring cache key and optional hashcode.\ttrys to get sockio from pool.fails over\tto additional pools in event of server failure.",
	"Method": "SockIO getSock(String key,SockIO getSock,String key,Integer hashCode){\r\n    if (log.isDebugEnabled())\r\n        log.debug(\"cache socket pick \" + key + \" \" + hashCode);\r\n    if (!this.initialized) {\r\n        log.error(\"attempting to get SockIO from uninitialized pool!\");\r\n        return null;\r\n    }\r\n    if ((this.hashingAlg == CONSISTENT_HASH && consistentBuckets.size() == 0) || (buckets != null && buckets.size() == 0))\r\n        return null;\r\n    if ((this.hashingAlg == CONSISTENT_HASH && consistentBuckets.size() == 1) || (buckets != null && buckets.size() == 1)) {\r\n        SockIO sock = (this.hashingAlg == CONSISTENT_HASH) ? getConnection(consistentBuckets.get(consistentBuckets.firstKey())) : getConnection(buckets.get(0));\r\n        if (sock != null && sock.isConnected()) {\r\n            if (aliveCheck) {\r\n                if (!sock.isAlive()) {\r\n                    sock.close();\r\n                    try {\r\n                        sock.trueClose();\r\n                    } catch (IOException ioe) {\r\n                        log.error(\"failed to close dead socket\");\r\n                    }\r\n                    sock = null;\r\n                }\r\n            }\r\n        } else {\r\n            if (sock != null) {\r\n                deadPool.put(sock, ZERO);\r\n                sock = null;\r\n            }\r\n        }\r\n        return sock;\r\n    }\r\n    Set<String> tryServers = new HashSet<String>(Arrays.asList(servers));\r\n    long bucket = getBucket(key, hashCode);\r\n    String server = (this.hashingAlg == CONSISTENT_HASH) ? consistentBuckets.get(bucket) : buckets.get((int) bucket);\r\n    while (!tryServers.isEmpty()) {\r\n        SockIO sock = getConnection(server);\r\n        if (log.isDebugEnabled())\r\n            log.debug(\"cache choose \" + server + \" for \" + key);\r\n        if (sock != null && sock.isConnected()) {\r\n            if (aliveCheck) {\r\n                if (sock.isAlive()) {\r\n                    return sock;\r\n                } else {\r\n                    sock.close();\r\n                    try {\r\n                        sock.trueClose();\r\n                    } catch (IOException ioe) {\r\n                        log.error(\"failed to close dead socket\");\r\n                    }\r\n                    sock = null;\r\n                }\r\n            } else {\r\n                return sock;\r\n            }\r\n        } else {\r\n            if (sock != null) {\r\n                deadPool.put(sock, ZERO);\r\n                sock = null;\r\n            }\r\n        }\r\n        if (!failover)\r\n            return null;\r\n        tryServers.remove(server);\r\n        if (tryServers.isEmpty())\r\n            break;\r\n        int rehashTries = 0;\r\n        while (!tryServers.contains(server)) {\r\n            String newKey = String.format(\"%s%s\", rehashTries, key);\r\n            if (log.isDebugEnabled())\r\n                log.debug(\"rehashing with: \" + newKey);\r\n            bucket = getBucket(newKey, null);\r\n            server = (this.hashingAlg == CONSISTENT_HASH) ? consistentBuckets.get(bucket) : buckets.get((int) bucket);\r\n            rehashTries++;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteConnection.isPreparedStatementInCache",
	"Comment": "returns true if the prepared statement cache contains the specified sql.",
	"Method": "boolean isPreparedStatementInCache(String sql){\r\n    return mPreparedStatementCache.get(sql) != null;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapSetEvaluator.ensureList",
	"Comment": "evaluates and saves the value of this named set, if it has not beenevaluated already.",
	"Method": "void ensureList(){\r\n    if (list != null) {\r\n        if (list == DUMMY_LIST) {\r\n            throw rrer.result.slicerEvaluator.newEvalException(null, \"Illegal attempt to reference value of a set '\" + getExpression() + \"' while evaluating itself\");\r\n        }\r\n        return;\r\n    }\r\n    if (RolapResult.LOGGER.isDebugEnabled()) {\r\n        RolapResult.LOGGER.debug(\"Set \" + exp + \": starting evaluation\");\r\n    }\r\n    list = DUMMY_LIST;\r\n    try {\r\n        final Calc calc = rrer.getCompiled(exp, false, ResultStyle.ITERABLE);\r\n        TupleIterable iterable = (TupleIterable) rrer.result.evaluateExp(calc, rrer.result.slicerEvaluator, null);\r\n        final TupleList rawList;\r\n        if (iterable instanceof TupleList) {\r\n            rawList = (TupleList) iterable;\r\n        } else {\r\n            rawList = TupleCollections.createList(iterable.getArity());\r\n            TupleCursor cursor = iterable.tupleCursor();\r\n            while (cursor.forward()) {\r\n                rawList.addCurrent(cursor);\r\n            }\r\n        }\r\n        if (RolapResult.LOGGER.isDebugEnabled()) {\r\n            RolapResult.LOGGER.debug(generateDebugMessage(calc, rawList));\r\n        }\r\n        this.list = rawList.withPositionCallback(this);\r\n    } finally {\r\n        if (this.list == DUMMY_LIST) {\r\n            this.list = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.FastBatchingCellReaderTest.testSuperSetDifferentValues",
	"Comment": "tests that can batch for batch with super set of constraintcolumn bit key and different values for overlapping columns.",
	"Method": "void testSuperSetDifferentValues(){\r\n    final BatchLoader fbcr = createFbcr(null, salesCube);\r\n    BatchLoader.Batch aggregationBatch = createBatch(fbcr, new String[] { tableTime, tableProductClass, tableProductClass }, new String[] { fieldYear, fieldProductFamily, fieldProductDepartment }, new String[][] { new String[] { \"1997\" }, fieldValuesProductFamily, fieldValueProductDepartment }, cubeNameSales, measureUnitSales);\r\n    BatchLoader.Batch detailedBatch = createBatch(fbcr, new String[] { tableTime, tableProductClass, tableProductClass, tableCustomer }, new String[] { fieldYear, fieldProductFamily, fieldProductDepartment, fieldGender }, new String[][] { new String[] { \"1998\" }, fieldValuesProductFamily, fieldValueProductDepartment, fieldValuesGender }, cubeNameSales, measureUnitSales);\r\n    assertFalse(detailedBatch.canBatch(aggregationBatch));\r\n    assertFalse(aggregationBatch.canBatch(detailedBatch));\r\n}"
}, {
	"Path": "mondrian.test.CacheHitTest.testSmallSetRandom",
	"Comment": "runs a set of small mdx queries that targets a small regionof aggregation cache in random order. all queries referencethe relational sales cube.",
	"Method": "void testSmallSetRandom(){\r\n    TestSuite suite = new TestSuite();\r\n    suite.addTest(PartialCacheTest.suite());\r\n    suite.addTest(MultiLevelTest.suite());\r\n    suite.addTest(MultiDimTest.suite());\r\n    suite.addTest(QueryAllTest.suite());\r\n    System.out.println(\"== \" + this.getName() + \" ==\");\r\n    runRandomSuite(suite, 200);\r\n    clearCache(\"Sales\");\r\n}"
}, {
	"Path": "org.mapsforge.map.reader.MapFile.readPoiData",
	"Comment": "reads poi data for an area defined by the tile in the upper left and the tile inthe lower right corner.this implementation takes the data storage of a mapfile into account for greater efficiency.",
	"Method": "MapReadResult readPoiData(Tile tile,MapReadResult readPoiData,Tile upperLeft,Tile lowerRight){\r\n    return readMapData(upperLeft, lowerRight, Selector.POIS);\r\n}"
}, {
	"Path": "mondrian.rolap.agg.CellRequest.getMappedCellValues",
	"Comment": "builds a map of column names to values, as specifiedby this cell request object.",
	"Method": "Map<String, Comparable> getMappedCellValues(){\r\n    final Map<String, Comparable> map = new HashMap<String, Comparable>();\r\n    final RolapStar.Column[] columns = this.getConstrainedColumns();\r\n    final Object[] values = this.getSingleValues();\r\n    for (int i = 0; i < columns.length; i++) {\r\n        RolapStar.Column column = columns[i];\r\n        final Object o = values[i];\r\n        map.put(column.getExpression().getGenericExpression(), (Comparable) o);\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "mondrian.rolap.aggmatcher.AggGen.isReady",
	"Comment": "return true if this instance is ready to generate the sql. if false,then something went wrong as it was trying to understand the columns.",
	"Method": "boolean isReady(){\r\n    return isReady;\r\n}"
}, {
	"Path": "mondrian.test.SchemaTest.testTwoAliasesDimensionsShareTableSameForeignKeys",
	"Comment": "tests two dimensions using same table with same foreign key.both using a table alias.",
	"Method": "void testTwoAliasesDimensionsShareTableSameForeignKeys(){\r\n    final TestContext testContext = TestContext.instance().create(null, \"<Cube name=\\\"AliasedDimensionsTesting\\\" defaultMeasure=\\\"Supply Time\\\">\\n\" + \"  <Table name=\\\"inventory_fact_1997\\\"/>\\n\" + \"  <Dimension name=\\\"StoreA\\\" foreignKey=\\\"store_id\\\">\" + \"    <Hierarchy hasAll=\\\"true\\\" primaryKey=\\\"store_id\\\">\" + \"      <Table name=\\\"store\\\" alias=\\\"storea\\\"/>\" + \"      <Level name=\\\"Store Country\\\" column=\\\"store_country\\\" uniqueMembers=\\\"true\\\"/>\" + \"      <Level name=\\\"Store Name\\\" column=\\\"store_name\\\" uniqueMembers=\\\"true\\\"/>\" + \"    <\/Hierarchy>\" + \"  <\/Dimension>\" + \"  <Dimension name=\\\"StoreB\\\" foreignKey=\\\"store_id\\\">\" + \"    <Hierarchy hasAll=\\\"true\\\" primaryKey=\\\"store_id\\\">\" + \"      <Table name=\\\"store\\\"  alias=\\\"storeb\\\"/>\" + \"      <Level name=\\\"Store Country\\\" column=\\\"store_country\\\" uniqueMembers=\\\"true\\\"/>\" + \"      <Level name=\\\"Store Name\\\" column=\\\"store_name\\\" uniqueMembers=\\\"true\\\"/>\" + \"    <\/Hierarchy>\" + \"  <\/Dimension>\" + \"  <Measure name=\\\"Store Invoice\\\" column=\\\"store_invoice\\\" \" + \"aggregator=\\\"sum\\\"/>\\n\" + \"  <Measure name=\\\"Supply Time\\\" column=\\\"supply_time\\\" \" + \"aggregator=\\\"sum\\\"/>\\n\" + \"  <Measure name=\\\"Warehouse Cost\\\" column=\\\"warehouse_cost\\\" \" + \"aggregator=\\\"sum\\\"/>\\n\" + \"<\/Cube>\", null, null, null, null);\r\n    testContext.assertQueryReturns(\"select {[StoreA].[USA]} on rows,\" + \"{[StoreB].[USA]} on columns\" + \" from \" + \"AliasedDimensionsTesting\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[StoreB].[USA]}\\n\" + \"Axis #2:\\n\" + \"{[StoreA].[USA]}\\n\" + \"Row #0: 10,425\\n\");\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlImpl.flattenCrossjoin",
	"Comment": "flattens a region into a list of regions none of which are unions.",
	"Method": "void flattenCrossjoin(CellRegionImpl region,List<CellRegionImpl> list){\r\n    if (region instanceof CrossjoinCellRegion) {\r\n        CrossjoinCellRegion crossjoin = (CrossjoinCellRegion) region;\r\n        for (CellRegionImpl component : crossjoin.components) {\r\n            flattenCrossjoin(component, list);\r\n        }\r\n    } else {\r\n        list.add(region);\r\n    }\r\n}"
}, {
	"Path": "mondrian.util.Triple.compare",
	"Comment": "compares a pair of comparable values of the same type. null collatesless than everything else, but equal to itself.",
	"Method": "int compare(C c1,C c2){\r\n    if (c1 == null) {\r\n        if (c2 == null) {\r\n            return 0;\r\n        } else {\r\n            return -1;\r\n        }\r\n    } else if (c2 == null) {\r\n        return 1;\r\n    } else {\r\n        return c1.compareTo(c2);\r\n    }\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Fieldset.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Fieldset appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.RolapEvaluator.checkRecursion",
	"Comment": "makes sure that there is no evaluator with identical context on thestack.",
	"Method": "void checkRecursion(RolapEvaluator eval,int c){\r\n    RolapMember[] members = eval.currentMembers.clone();\r\n    Member expanding = eval.expandingMember;\r\n    while (true) {\r\n        if (c < 0) {\r\n            eval = eval.parent;\r\n            if (eval == null) {\r\n                return;\r\n            }\r\n            c = eval.commandCount - 1;\r\n        } else {\r\n            Command command = (Command) eval.commands[c];\r\n            switch(command) {\r\n                case SET_CONTEXT:\r\n                    int memberOrdinal = (Integer) eval.commands[c - 1];\r\n                    RolapMember member = (RolapMember) eval.commands[c - 2];\r\n                    members[memberOrdinal] = member;\r\n                    break;\r\n                case SET_EXPANDING:\r\n                    expanding = (RolapMember) eval.commands[c - 2];\r\n                    if (Arrays.equals(members, eval.currentMembers) && expanding == eval.expandingMember) {\r\n                        throw FunUtil.newEvalException(null, \"Infinite loop while evaluating calculated member '\" + eval.expandingMember + \"'; context stack is \" + eval.getContextString());\r\n                    }\r\n            }\r\n            c -= command.width;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testNativeTopCount",
	"Comment": "checks that topcount is executed natively unless disabled.",
	"Method": "void testNativeTopCount(){\r\n    switch(getTestContext().getDialect().getDatabaseProduct()) {\r\n        case INFOBRIGHT:\r\n            return;\r\n    }\r\n    String query = \"select {[Measures].[Store Sales]} on columns,\" + \"  NON EMPTY TopCount(\" + \"        CrossJoin([Customers].[All Customers].[USA].children, [Promotions].[Promotion Name].Members), \" + \"        3, (3 * [Measures].[Store Sales]) - 100) ON ROWS\" + \" from [Sales] where (\" + \"  [Store].[All Stores].[USA].[CA].[San Francisco].[Store 14],\" + \"  [Time].[1997].[Q1].[1])\";\r\n    propSaver.set(MondrianProperties.instance().EnableNativeTopCount, true);\r\n    boolean requestFreshConnection = true;\r\n    checkNative(3, 3, query, null, requestFreshConnection);\r\n}"
}, {
	"Path": "mondrian.rolap.SqlConstraintUtils.getColumnString",
	"Comment": "returns the column expression for the level, assuringappropriate tables are added to the from clause ofsqlquery if required.determines the correct table and field based on the cubeand whether an aggstar is present.",
	"Method": "String getColumnString(SqlQuery sqlQuery,AggStar aggStar,RolapLevel level,RolapCube baseCube){\r\n    String columnString;\r\n    RolapStar.Column column = null;\r\n    if (level instanceof RolapCubeLevel) {\r\n        column = ((RolapCubeLevel) level).getBaseStarKeyColumn(baseCube);\r\n    }\r\n    RolapHierarchy hierarchy = level.getHierarchy();\r\n    if (column != null) {\r\n        if (aggStar != null) {\r\n            int bitPos = column.getBitPosition();\r\n            AggStar.Table.Column aggColumn = aggStar.lookupColumn(bitPos);\r\n            AggStar.Table table = aggColumn.getTable();\r\n            table.addToFrom(sqlQuery, false, true);\r\n            columnString = aggColumn.generateExprString(sqlQuery);\r\n        } else {\r\n            RolapStar.Table targetTable = column.getTable();\r\n            hierarchy.addToFrom(sqlQuery, targetTable);\r\n            columnString = column.generateExprString(sqlQuery);\r\n        }\r\n    } else {\r\n        assert (aggStar == null);\r\n        hierarchy.addToFrom(sqlQuery, level.getKeyExp());\r\n        MondrianDef.Expression nameExp = level.getNameExp();\r\n        if (nameExp == null) {\r\n            nameExp = level.getKeyExp();\r\n        }\r\n        columnString = nameExp.getExpression(sqlQuery);\r\n    }\r\n    return columnString;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapResult.setPlaceholderSlicerAxis",
	"Comment": "sets sliceraxis to a dummy placeholder rolapaxis containinga single item tuplelist with the null member of hierarchy.this is used with compound slicer evaluation to avoid the slicertuple list from interacting with the aggregate calc which rolls upthe set.this member will contain the aggregatecalc which rollsup the set on the slicer.",
	"Method": "Member setPlaceholderSlicerAxis(RolapMember member,Calc calc,boolean setAxis){\r\n    ValueFormatter formatter;\r\n    if (member.getDimension().isMeasures()) {\r\n        formatter = ((RolapMeasure) member).getFormatter();\r\n    } else {\r\n        formatter = null;\r\n    }\r\n    CompoundSlicerRolapMember placeholderMember = new CompoundSlicerRolapMember((RolapMember) member.getHierarchy().getNullMember(), calc, formatter);\r\n    placeholderMember.setProperty(Property.FORMAT_STRING.getName(), member.getPropertyValue(Property.FORMAT_STRING.getName()));\r\n    placeholderMember.setProperty(Property.FORMAT_EXP_PARSED.getName(), member.getPropertyValue(Property.FORMAT_EXP_PARSED.getName()));\r\n    if (setAxis) {\r\n        TupleList dummyList = TupleCollections.createList(1);\r\n        dummyList.addTuple(placeholderMember);\r\n        this.slicerAxis = new RolapAxis(dummyList);\r\n    }\r\n    return placeholderMember;\r\n}"
}, {
	"Path": "mondrian.rolap.ResultLoader.handle",
	"Comment": "handles an error, and returns an exception that the caller should thenthrow.",
	"Method": "RuntimeException handle(Exception e){\r\n    if (stmt != null) {\r\n        return stmt.handle(e);\r\n    } else {\r\n        return Util.newError(e, message);\r\n    }\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.widget.IcsLinearLayout.isMeasureWithLargestChildEnabled",
	"Comment": "when true, all children with a weight will be considered havingthe minimum size of the largest child. if false, all children aremeasured normally.",
	"Method": "boolean isMeasureWithLargestChildEnabled(){\r\n    return mUseLargestChild;\r\n}"
}, {
	"Path": "mondrian.test.ConcurrentValidatingQueryRunner.run",
	"Comment": "runs a number of queries until time expires. for each iteration,if cache is to be flushed, do it before running the query.",
	"Method": "void run(){\r\n    mStartTime = System.currentTimeMillis();\r\n    threadName = Thread.currentThread().getName();\r\n    try {\r\n        int queryIndex = -1;\r\n        while (System.currentTimeMillis() - mStartTime < mRunTime) {\r\n            try {\r\n                if (mRandomQueries) {\r\n                    queryIndex = (int) (Math.random() * mdxQueries.length);\r\n                } else {\r\n                    queryIndex = mRunCount % mdxQueries.length;\r\n                }\r\n                mRunCount++;\r\n                synchronized (lock) {\r\n                    if (mRandomCacheFlush && (Math.random() < mRandomFlushFrequency)) {\r\n                        flushRandomRegionOfCache();\r\n                    }\r\n                    if (mRandomCacheFlush && (Math.random() < mRandomFlushFrequency)) {\r\n                        flushSchema();\r\n                    }\r\n                }\r\n                synchronized (lock) {\r\n                    concurrentMdxTest.assertQueryReturns(mdxQueries[queryIndex].query, mdxQueries[queryIndex].result);\r\n                    mSuccessCount++;\r\n                }\r\n            } catch (Exception e) {\r\n                mExceptions.add(new Exception(\"Exception occurred in iteration \" + mRunCount + \" of thread \" + Thread.currentThread().getName(), e));\r\n            }\r\n        }\r\n        mStopTime = System.currentTimeMillis();\r\n    } catch (Exception e) {\r\n        mExceptions.add(e);\r\n    } catch (Error e) {\r\n        mExceptions.add(e);\r\n    }\r\n}"
}, {
	"Path": "org.msgpack.core.MessagePacker.packBoolean",
	"Comment": "writes a boolean value.this method writes a true byte or a false byte.",
	"Method": "MessagePacker packBoolean(boolean b){\r\n    writeByte(b ? TRUE : FALSE);\r\n    return this;\r\n}"
}, {
	"Path": "org.mapsforge.map.reader.IndexCache.getIndexEntry",
	"Comment": "returns the index entry of a block in the given map file. if the required index entry is not cached, it will beread from the map file index and put in the cache.",
	"Method": "long getIndexEntry(SubFileParameter subFileParameter,long blockNumber){\r\n    if (blockNumber >= subFileParameter.numberOfBlocks) {\r\n        throw new IOException(\"invalid block number: \" + blockNumber);\r\n    }\r\n    long indexBlockNumber = blockNumber / INDEX_ENTRIES_PER_BLOCK;\r\n    IndexCacheEntryKey indexCacheEntryKey = new IndexCacheEntryKey(subFileParameter, indexBlockNumber);\r\n    byte[] indexBlock = this.map.get(indexCacheEntryKey);\r\n    if (indexBlock == null) {\r\n        long indexBlockPosition = subFileParameter.indexStartAddress + indexBlockNumber * SIZE_OF_INDEX_BLOCK;\r\n        int remainingIndexSize = (int) (subFileParameter.indexEndAddress - indexBlockPosition);\r\n        int indexBlockSize = Math.min(SIZE_OF_INDEX_BLOCK, remainingIndexSize);\r\n        indexBlock = new byte[indexBlockSize];\r\n        ByteBuffer indexBlockWrapper = ByteBuffer.wrap(indexBlock, 0, indexBlockSize);\r\n        synchronized (this.fileChannel) {\r\n            this.fileChannel.position(indexBlockPosition);\r\n            if (this.fileChannel.read(indexBlockWrapper) != indexBlockSize) {\r\n                throw new IOException(\"could not read index block with size: \" + indexBlockSize);\r\n            }\r\n        }\r\n        this.map.put(indexCacheEntryKey, indexBlock);\r\n    }\r\n    long indexEntryInBlock = blockNumber % INDEX_ENTRIES_PER_BLOCK;\r\n    int addressInIndexBlock = (int) (indexEntryInBlock * SubFileParameter.BYTES_PER_INDEX_ENTRY);\r\n    return Deserializer.getFiveBytesLong(indexBlock, addressInIndexBlock);\r\n}"
}, {
	"Path": "mondrian.util.BlockingHashMap.get",
	"Comment": "retrieves the response from the map matching the given key,blocking until it is received.",
	"Method": "V get(K k){\r\n    map.putIfAbsent(k, new SlotFuture<V>());\r\n    V v = Util.safeGet(map.get(k), \"Waiting to retrieve a value from BlockingHashMap.\");\r\n    map.remove(k);\r\n    return v;\r\n}"
}, {
	"Path": "org.mapsforge.samples.android.cluster.ClusterMarker.setMarkerBitmap",
	"Comment": "change icon bitmaps according to the state and content size.",
	"Method": "void setMarkerBitmap(){\r\n    for (markerType = 0; markerType < cluster.getClusterManager().markerIconBmps.size(); markerType++) {\r\n        if (cluster.getItems().size() <= cluster.getClusterManager().markerIconBmps.get(markerType).getItemMax()) {\r\n            return;\r\n        }\r\n    }\r\n    markerType--;\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunctionTest.testComplexQuery",
	"Comment": "executes a query that has a complex parse tree. goal is to findalgorithmic complexity bugs in the validator which would make the queryrun extremely slowly.",
	"Method": "void testComplexQuery(){\r\n    final String expected = \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[All Gender]}\\n\" + \"{[Gender].[F]}\\n\" + \"{[Gender].[M]}\\n\" + \"Row #0: 266,773\\n\" + \"Row #1: 131,558\\n\" + \"Row #2: 135,215\\n\";\r\n    assertQueryReturns(\"select\\n\" + \"   [Measures].[Unit Sales] on 0,\\n\" + \"   Distinct({\\n\" + \"     [Gender],\\n\" + \"     Tail(\\n\" + \"       Head({\\n\" + \"         [Gender],\\n\" + \"         [Gender].[F],\\n\" + \"         [Gender].[M]},\\n\" + \"         2),\\n\" + \"       1),\\n\" + \"     Tail(\\n\" + \"       Head({\\n\" + \"         [Gender],\\n\" + \"         [Gender].[F],\\n\" + \"         [Gender].[M]},\\n\" + \"         2),\\n\" + \"       1),\\n\" + \"     [Gender].[M]}) on 1\\n\" + \"from [Sales]\", expected);\r\n    StringBuilder buf = new StringBuilder();\r\n    buf.append(\"select\\n\" + \"   [Measures].[Unit Sales] on 0,\\n\");\r\n    generateComplex(buf, \"   \", 0, 7, 3);\r\n    buf.append(\" on 1\\n\" + \"from [Sales]\");\r\n    if (false) {\r\n        System.out.println(buf.toString().length() + \": \" + buf.toString());\r\n    }\r\n    assertQueryReturns(buf.toString(), expected);\r\n}"
}, {
	"Path": "mondrian.test.CompoundSlicerTest.testCompoundSlicer",
	"Comment": "test case for a basic query with more than one member of the samehierarchy in the where clause.",
	"Method": "void testCompoundSlicer(){\r\n    assertQueryReturns(\"select [Measures].[Unit Sales] on 0,\\n\" + \"[Gender].Members on 1\\n\" + \"from [Sales]\\n\" + \"where {[Product].[Drink]}\", \"Axis #0:\\n\" + \"{[Product].[Drink]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[All Gender]}\\n\" + \"{[Gender].[F]}\\n\" + \"{[Gender].[M]}\\n\" + \"Row #0: 24,597\\n\" + \"Row #1: 12,202\\n\" + \"Row #2: 12,395\\n\");\r\n    assertQueryReturns(\"select [Measures].[Unit Sales] on 0,\\n\" + \"[Gender].Members on 1\\n\" + \"from [Sales]\\n\" + \"where {[Product].[Food]}\", \"Axis #0:\\n\" + \"{[Product].[Food]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[All Gender]}\\n\" + \"{[Gender].[F]}\\n\" + \"{[Gender].[M]}\\n\" + \"Row #0: 191,940\\n\" + \"Row #1: 94,814\\n\" + \"Row #2: 97,126\\n\");\r\n    assertQueryReturns(\"select [Measures].[Unit Sales] on 0,\\n\" + \"[Gender].Members on 1\\n\" + \"from [Sales]\\n\" + \"where {[Product].[Drink], [Product].[Food]}\", \"Axis #0:\\n\" + \"{[Product].[Drink]}\\n\" + \"{[Product].[Food]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[All Gender]}\\n\" + \"{[Gender].[F]}\\n\" + \"{[Gender].[M]}\\n\" + \"Row #0: 216,537\\n\" + \"Row #1: 107,016\\n\" + \"Row #2: 109,521\\n\");\r\n    assertQueryReturns(\"select [Measures].[Unit Sales] on 0,\\n\" + \"[Gender].Members on 1\\n\" + \"from [Sales]\\n\" + \"where {[Product].[Drink], [Product].[Food], [Product].[Drink]}\", Bug.BugMondrian555Fixed ? \"Axis #0:\\n\" + \"{[Product].[Drink]}\\n\" + \"{[Product].[Food]}\\n\" + \"{[Product].[Drink]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[All Gender]}\\n\" + \"{[Gender].[F]}\\n\" + \"{[Gender].[M]}\\n\" + \"Row #0: 241,134, 241,134, 241,134\\n\" + \"Row #1: 119,218, 119,218, 119,218\\n\" + \"Row #2: 121,916, 121,916, 121,916\\n\" : \"Axis #0:\\n\" + \"{[Product].[Drink]}\\n\" + \"{[Product].[Food]}\\n\" + \"{[Product].[Drink]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[All Gender]}\\n\" + \"{[Gender].[F]}\\n\" + \"{[Gender].[M]}\\n\" + \"Row #0: 241,134\\n\" + \"Row #1: 119,218\\n\" + \"Row #2: 121,916\\n\");\r\n    assertQueryReturns(\"select [Measures].[Unit Sales] on 0,\\n\" + \"[Gender].Members on 1\\n\" + \"from [Sales]\\n\" + \"where {[Product].[All Products].Parent, [Product].[Food], [Product].[Drink]}\", \"Axis #0:\\n\" + \"{[Product].[Food]}\\n\" + \"{[Product].[Drink]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[All Gender]}\\n\" + \"{[Gender].[F]}\\n\" + \"{[Gender].[M]}\\n\" + \"Row #0: 216,537\\n\" + \"Row #1: 107,016\\n\" + \"Row #2: 109,521\\n\");\r\n    assertQueryReturns(\"select [Measures].[Unit Sales] on 0,\\n\" + \"[Gender].Members on 1\\n\" + \"from [Sales]\\n\" + \"where {\\n\" + \"  [Product].[Drink],\\n\" + \"  [Product].[Food].[Dairy]}\", \"Axis #0:\\n\" + \"{[Product].[Drink]}\\n\" + \"{[Product].[Food].[Dairy]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[All Gender]}\\n\" + \"{[Gender].[F]}\\n\" + \"{[Gender].[M]}\\n\" + \"Row #0: 37,482\\n\" + \"Row #1: 18,715\\n\" + \"Row #2: 18,767\\n\");\r\n    assertQueryReturns(\"select [Measures].[Unit Sales] on 0,\\n\" + \"[Gender].Members on 1\\n\" + \"from [Sales]\\n\" + \"where {\\n\" + \"  [Product].[Drink],\\n\" + \"  [Product].[Food].[Dairy],\\n\" + \"  [Product].[Drink].[Alcoholic Beverages].[Beer and Wine].[Beer]}\", Bug.BugMondrian555Fixed ? \"Axis #0:\\n\" + \"{[Product].[Drink]}\\n\" + \"{[Product].[Food].[Dairy]}\\n\" + \"{[Product].[Drink].[Alcoholic Beverages].[Beer and Wine].[Beer]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[All Gender]}\\n\" + \"{[Gender].[F]}\\n\" + \"{[Gender].[M]}\\n\" + \"Row #0: 37,482\\n\" + \"Row #1: 18,715\\n\" + \"Row #2: 18.767\\n\" : \"Axis #0:\\n\" + \"{[Product].[Drink]}\\n\" + \"{[Product].[Food].[Dairy]}\\n\" + \"{[Product].[Drink].[Alcoholic Beverages].[Beer and Wine].[Beer]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[All Gender]}\\n\" + \"{[Gender].[F]}\\n\" + \"{[Gender].[M]}\\n\" + \"Row #0: 39,165\\n\" + \"Row #1: 19,532\\n\" + \"Row #2: 19,633\\n\");\r\n    assertQueryReturns(\"with member [Product].[Foo] as\\n\" + \"  Aggregate({\\n\" + \"    [Product].[Drink],\\n\" + \"    [Product].[Food].[Dairy],\\n\" + \"    [Product].[Drink].[Alcoholic Beverages].[Beer and Wine].[Beer]})\\n\" + \"select [Measures].[Unit Sales] on 0,\\n\" + \"[Gender].Members on 1\\n\" + \"from [Sales]\\n\" + \"where [Product].[Foo]\\n\", \"Axis #0:\\n\" + \"{[Product].[Foo]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[All Gender]}\\n\" + \"{[Gender].[F]}\\n\" + \"{[Gender].[M]}\\n\" + \"Row #0: 39,165\\n\" + \"Row #1: 19,532\\n\" + \"Row #2: 19,633\\n\");\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Dfn.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Dfn appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.ui.widget.StaggeredGridView.getFirstPosition",
	"Comment": "return the first adapter position with a view currently attached asa child view of this grid.",
	"Method": "int getFirstPosition(){\r\n    return mFirstPosition;\r\n}"
}, {
	"Path": "mondrian.gui.JdbcTreeModel.removeTreeModelListener",
	"Comment": "removes a listener previously added withaddtreemodellistener.",
	"Method": "void removeTreeModelListener(TreeModelListener l){\r\n    treeModelListeners.remove(l);\r\n}"
}, {
	"Path": "mondrian.test.SteelWheelsTestCase.getTestContext",
	"Comment": "returns the test context. override this method if you wish to use adifferent source for your steelwheels connection.",
	"Method": "TestContext getTestContext(){\r\n    return createContext(TestContext.instance(), null).withCube(\"SteelWheelsSales\");\r\n}"
}, {
	"Path": "mondrian.rolap.SqlConstraintUtils.getLevelColumn",
	"Comment": "gets the column, using aggstar if available, and ensures the table is inthe query.",
	"Method": "RolapStar.Column getLevelColumn(RolapLevel level,RolapCube baseCube,AggStar aggStar,SqlQuery sqlQuery){\r\n    final RolapStar.Column column = ((RolapCubeLevel) level).getBaseStarKeyColumn(baseCube);\r\n    if (aggStar != null) {\r\n        int bitPos = column.getBitPosition();\r\n        final AggStar.Table.Column aggColumn = aggStar.lookupColumn(bitPos);\r\n        AggStar.Table table = aggColumn.getTable();\r\n        table.addToFrom(sqlQuery, false, true);\r\n        return new Column(aggColumn.getDatatype()) {\r\n            public String generateExprString(SqlQuery query) {\r\n                return aggColumn.generateExprString(query);\r\n            }\r\n            public int getBitPosition() {\r\n                return aggColumn.getBitPosition();\r\n            }\r\n            public Table getTable() {\r\n                return column.getTable();\r\n            }\r\n            public RolapStar getStar() {\r\n                return column.getStar();\r\n            }\r\n        };\r\n    } else {\r\n        column.getTable().addToFrom(sqlQuery, false, true);\r\n        return column;\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.SqlConstraintUtils.getLevelColumn",
	"Comment": "gets the column, using aggstar if available, and ensures the table is inthe query.",
	"Method": "RolapStar.Column getLevelColumn(RolapLevel level,RolapCube baseCube,AggStar aggStar,SqlQuery sqlQuery){\r\n    return aggColumn.generateExprString(query);\r\n}"
}, {
	"Path": "mondrian.rolap.SqlConstraintUtils.getLevelColumn",
	"Comment": "gets the column, using aggstar if available, and ensures the table is inthe query.",
	"Method": "RolapStar.Column getLevelColumn(RolapLevel level,RolapCube baseCube,AggStar aggStar,SqlQuery sqlQuery){\r\n    return aggColumn.getBitPosition();\r\n}"
}, {
	"Path": "mondrian.rolap.SqlConstraintUtils.getLevelColumn",
	"Comment": "gets the column, using aggstar if available, and ensures the table is inthe query.",
	"Method": "RolapStar.Column getLevelColumn(RolapLevel level,RolapCube baseCube,AggStar aggStar,SqlQuery sqlQuery){\r\n    return column.getTable();\r\n}"
}, {
	"Path": "mondrian.rolap.SqlConstraintUtils.getLevelColumn",
	"Comment": "gets the column, using aggstar if available, and ensures the table is inthe query.",
	"Method": "RolapStar.Column getLevelColumn(RolapLevel level,RolapCube baseCube,AggStar aggStar,SqlQuery sqlQuery){\r\n    return column.getStar();\r\n}"
}, {
	"Path": "mondrian.test.CacheTest.testNQueriesWaitingForSameSegmentRepeat",
	"Comment": "tests that if n queries are executed at the same time, only one segmentrequest will be sent. the query that arrives second should see that thereis a pending segment in the aggregation manager, and should wait forthat.if the test fails, look at segmentcreateviasqlcount. if it hasincreased by more than one between before and after, the clients have notmanaged to share work. if it has not increased, the cache was probablynot flushed correctly.",
	"Method": "void testNQueriesWaitingForSameSegmentRepeat(){\r\n    final int parallel = 10;\r\n    final ThreadPoolExecutor executor = new ThreadPoolExecutor(2, parallel, 1, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(parallel * 2));\r\n    final int repeatCount = 20;\r\n    for (int i = 0; i < repeatCount; i++) {\r\n        checkNQueriesWaitingForSameSegment(executor, parallel, \"iteration #\" + i + \" of \" + repeatCount);\r\n    }\r\n    executor.shutdown();\r\n}"
}, {
	"Path": "mondrian.rolap.agg.Aggregation.optimizePredicates",
	"Comment": "drops predicates, where the list of values is close to the values whichwould be returned anyway.",
	"Method": "StarColumnPredicate[] optimizePredicates(RolapStar.Column[] columns,StarColumnPredicate[] predicates){\r\n    RolapStar star = getStar();\r\n    Util.assertTrue(predicates.length == columns.length);\r\n    StarColumnPredicate[] newPredicates = predicates.clone();\r\n    double[] bloats = new double[columns.length];\r\n    List<Member> potentialParents = new ArrayList<Member>();\r\n    for (final StarColumnPredicate predicate : predicates) {\r\n        Member m;\r\n        if (predicate instanceof MemberColumnPredicate) {\r\n            m = ((MemberColumnPredicate) predicate).getMember();\r\n            potentialParents.add(m);\r\n        }\r\n    }\r\n    for (int i = 0; i < newPredicates.length; i++) {\r\n        if (!(newPredicates[i] instanceof ListColumnPredicate)) {\r\n            bloats[i] = 0.0;\r\n            continue;\r\n        }\r\n        final ListColumnPredicate newPredicate = (ListColumnPredicate) newPredicates[i];\r\n        final List<StarColumnPredicate> predicateList = newPredicate.getPredicates();\r\n        final int valueCount = predicateList.size();\r\n        if (valueCount < 2) {\r\n            bloats[i] = 0.0;\r\n            continue;\r\n        }\r\n        if (valueCount > maxConstraints) {\r\n            bloats[i] = 1.0;\r\n            continue;\r\n        }\r\n        double constraintLength = (double) valueCount;\r\n        Member parent = null;\r\n        Level level = null;\r\n        for (int j = 0; j < valueCount; j++) {\r\n            Object value = predicateList.get(j);\r\n            if (value instanceof MemberColumnPredicate) {\r\n                MemberColumnPredicate memberColumnPredicate = (MemberColumnPredicate) value;\r\n                Member m = memberColumnPredicate.getMember();\r\n                if (j == 0) {\r\n                    parent = m.getParentMember();\r\n                    level = m.getLevel();\r\n                } else {\r\n                    if (parent != null && !parent.equals(m.getParentMember())) {\r\n                        parent = null;\r\n                    }\r\n                    if (level != null && !level.equals(m.getLevel())) {\r\n                        level = null;\r\n                    }\r\n                }\r\n            } else {\r\n                parent = null;\r\n                level = null;\r\n                bloats[i] = constraintLength / columns[i].getCardinality();\r\n                break;\r\n            }\r\n        }\r\n        boolean done = false;\r\n        if (parent != null) {\r\n            if (parent.isAll() || potentialParents.contains(parent)) {\r\n                SchemaReader scr = star.getSchema().getSchemaReader();\r\n                int childCount = scr.getChildrenCountFromCache(parent);\r\n                if (childCount == -1) {\r\n                    if (!parent.isAll()) {\r\n                        bloats[i] = 0.0;\r\n                        done = true;\r\n                    }\r\n                } else {\r\n                    bloats[i] = constraintLength / childCount;\r\n                    done = true;\r\n                }\r\n            }\r\n        }\r\n        if (!done && level != null) {\r\n            SchemaReader scr = star.getSchema().getSchemaReader();\r\n            int memberCount = scr.getLevelCardinality(level, true, false);\r\n            if (memberCount > 0) {\r\n                bloats[i] = constraintLength / memberCount;\r\n                done = true;\r\n            }\r\n        }\r\n        if (!done) {\r\n            bloats[i] = constraintLength / columns[i].getCardinality();\r\n        }\r\n    }\r\n    ConstraintComparator comparator = new ConstraintComparator(bloats);\r\n    Integer[] indexes = new Integer[columns.length];\r\n    for (int i = 0; i < columns.length; i++) {\r\n        indexes[i] = i;\r\n    }\r\n    Arrays.sort(indexes, comparator);\r\n    double abloat = 1.0;\r\n    final double aBloatLimit = .5;\r\n    for (Integer j : indexes) {\r\n        abloat = abloat * bloats[j];\r\n        if (abloat <= aBloatLimit) {\r\n            break;\r\n        }\r\n        if (MondrianProperties.instance().OptimizePredicates.get() || bloats[j] == 1) {\r\n            newPredicates[j] = new LiteralStarPredicate(columns[j], true);\r\n        }\r\n    }\r\n    for (int i = 0; i < newPredicates.length; i++) {\r\n        newPredicates[i] = StarPredicates.optimize(newPredicates[i]);\r\n    }\r\n    return newPredicates;\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.StringUtils.substringMatch",
	"Comment": "test whether the given string matches the given substring at the givenindex.",
	"Method": "boolean substringMatch(CharSequence str,int index,CharSequence substring){\r\n    for (int j = 0; j < substring.length(); j++) {\r\n        int i = index + j;\r\n        if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "mondrian.test.CacheHitTest.testSmallSetVCSequential",
	"Comment": "runs a set of small mdx queries that targets a small regionof aggregation cache sequentially. all queries referencethe virtual warehouse and sales cube.",
	"Method": "void testSmallSetVCSequential(){\r\n    TestSuite suite = new TestSuite();\r\n    suite.addTest(PartialCacheVCTest.suite());\r\n    suite.addTest(MultiLevelVCTest.suite());\r\n    suite.addTest(MultiDimVCTest.suite());\r\n    suite.addTest(QueryAllVCTest.suite());\r\n    System.out.println(\"== \" + this.getName() + \" ==\");\r\n    runTestSuiteInOrder(suite, 50);\r\n    clearCache(\"Warehouse and Sales\");\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testCmNativeTopCount",
	"Comment": "checks that topcount is executed natively with calculated member.",
	"Method": "void testCmNativeTopCount(){\r\n    switch(getTestContext().getDialect().getDatabaseProduct()) {\r\n        case INFOBRIGHT:\r\n            return;\r\n    }\r\n    String query = \"with member [Measures].[Store Profit Rate] as '([Measures].[Store Sales]-[Measures].[Store Cost])/[Measures].[Store Cost]', format = '#.00%' \" + \"select {[Measures].[Store Sales]} on columns,\" + \"  NON EMPTY TopCount(\" + \"        [Customers].[All Customers].[USA].children, \" + \"        3, [Measures].[Store Profit Rate] / 2) ON ROWS\" + \" from [Sales]\";\r\n    propSaver.set(MondrianProperties.instance().EnableNativeTopCount, true);\r\n    boolean requestFreshConnection = true;\r\n    checkNative(3, 3, query, null, requestFreshConnection);\r\n}"
}, {
	"Path": "mondrian.util.UtilCompatibleJdk15.makeBigDecimalFromDouble",
	"Comment": "this generates a bigdecimal with a precision reflectingthe precision of the input double.",
	"Method": "BigDecimal makeBigDecimalFromDouble(double d){\r\n    return new BigDecimal(d, MathContext.DECIMAL64);\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getPathTranslated",
	"Comment": "returns any extra path information after the servlet name but before thequery string, and translates it to a real path.",
	"Method": "String getPathTranslated(){\r\n    return pathTranslated;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Html.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Html appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.olap.Util.needToImplement",
	"Comment": "returns an exception which indicates that a particular piece offunctionality should work, but a developer has not implemented it yet.",
	"Method": "RuntimeException needToImplement(Object o){\r\n    throw new UnsupportedOperationException(\"need to implement \" + o);\r\n}"
}, {
	"Path": "mondrian.test.TestContext.assertExprThrows",
	"Comment": "executes an expression, and asserts that it gives an error which containsa particular pattern. the error might occur during parsing, or mightbe contained within the cell value.",
	"Method": "void assertExprThrows(String expression,String pattern){\r\n    Throwable throwable = null;\r\n    try {\r\n        String cubeName = getDefaultCubeName();\r\n        if (cubeName.indexOf(' ') >= 0) {\r\n            cubeName = Util.quoteMdxIdentifier(cubeName);\r\n        }\r\n        expression = Util.replace(expression, \"'\", \"''\");\r\n        Result result = executeQuery(\"with member [Measures].[Foo] as '\" + expression + \"' select {[Measures].[Foo]} on columns from \" + cubeName);\r\n        Cell cell = result.getCell(new int[] { 0 });\r\n        if (cell.isError()) {\r\n            throwable = (Throwable) cell.getValue();\r\n        }\r\n    } catch (Throwable e) {\r\n        throwable = e;\r\n    }\r\n    checkThrowable(throwable, pattern);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.resetWorkbench",
	"Comment": "updates the jdbcmetadata for each schemaexplorer contained in each schemaframe currently opened based on the jdbc preferences entered.",
	"Method": "void resetWorkbench(){\r\n    getNewJdbcMetadata();\r\n    Iterator<JInternalFrame> theSchemaFrames = schemaWindowMap.keySet().iterator();\r\n    while (theSchemaFrames.hasNext()) {\r\n        JInternalFrame theSchemaFrame = theSchemaFrames.next();\r\n        SchemaExplorer theSchemaExplorer = (SchemaExplorer) theSchemaFrame.getContentPane().getComponent(0);\r\n        File theFile = theSchemaExplorer.getSchemaFile();\r\n        checkSchemaFile(theFile);\r\n        theSchemaExplorer.resetMetaData(jdbcMetaData);\r\n        theSchemaExplorer.getTreeUpdater().update();\r\n        theSchemaFrame.updateUI();\r\n    }\r\n    displayWarningOnFailedConnection();\r\n    for (JInternalFrame jdbcFrame : jdbcWindows) {\r\n        JdbcExplorer explorer = (JdbcExplorer) jdbcFrame.getContentPane().getComponent(0);\r\n        explorer.resetMetaData(jdbcMetaData);\r\n        jdbcFrame.setTitle(getResourceConverter().getFormattedString(\"workbench.new.JDBCExplorer.title\", \"JDBC Explorer - {0} {1}\", jdbcMetaData.getDatabaseProductName(), jdbcMetaData.getJdbcConnectionUrl()));\r\n        explorer.getTreeUpdater().update();\r\n        explorer.updateUI();\r\n    }\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.closePool",
	"Comment": "closes all sockets in the passed in pool.\tinternal utility method.",
	"Method": "void closePool(Map<String, Map<SockIO, Long>> pool){\r\n    for (Iterator<String> i = pool.keySet().iterator(); i.hasNext(); ) {\r\n        String host = i.next();\r\n        Map<SockIO, Long> sockets = pool.get(host);\r\n        for (Iterator<SockIO> j = sockets.keySet().iterator(); j.hasNext(); ) {\r\n            SockIO socket = j.next();\r\n            try {\r\n                socket.trueClose();\r\n            } catch (IOException ioe) {\r\n                log.error(\"++++ failed to trueClose socket: \" + socket.toString() + \" for host: \" + host);\r\n            }\r\n            j.remove();\r\n            socket = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getSession",
	"Comment": "returns the current session associated with this request, or if the request does not have a session, creates one.",
	"Method": "HttpSession getSession(boolean create,HttpSession getSession){\r\n    sessionCreated = true;\r\n    return session;\r\n}"
}, {
	"Path": "mondrian.util.CompositeList.of",
	"Comment": "creates a composite list, inferring the element type from the arguments.",
	"Method": "CompositeList<T> of(List<? extends T> lists){\r\n    return new CompositeList<T>(lists);\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunctionTest.testNamedSetCurrentOrdinalWithOrder",
	"Comment": "tests namedset.currentordinal combined with the order function.",
	"Method": "void testNamedSetCurrentOrdinalWithOrder(){\r\n    if (Util.Retrowoven) {\r\n        return;\r\n    }\r\n    assertQueryReturns(\"with set [Time Regular] as [Time].[Time].Members\\n\" + \" set [Time Reversed] as\" + \" Order([Time Regular], [Time Regular].CurrentOrdinal, BDESC)\\n\" + \"select [Time Reversed] on 0\\n\" + \"from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Time].[1998].[Q4].[12]}\\n\" + \"{[Time].[1998].[Q4].[11]}\\n\" + \"{[Time].[1998].[Q4].[10]}\\n\" + \"{[Time].[1998].[Q4]}\\n\" + \"{[Time].[1998].[Q3].[9]}\\n\" + \"{[Time].[1998].[Q3].[8]}\\n\" + \"{[Time].[1998].[Q3].[7]}\\n\" + \"{[Time].[1998].[Q3]}\\n\" + \"{[Time].[1998].[Q2].[6]}\\n\" + \"{[Time].[1998].[Q2].[5]}\\n\" + \"{[Time].[1998].[Q2].[4]}\\n\" + \"{[Time].[1998].[Q2]}\\n\" + \"{[Time].[1998].[Q1].[3]}\\n\" + \"{[Time].[1998].[Q1].[2]}\\n\" + \"{[Time].[1998].[Q1].[1]}\\n\" + \"{[Time].[1998].[Q1]}\\n\" + \"{[Time].[1998]}\\n\" + \"{[Time].[1997].[Q4].[12]}\\n\" + \"{[Time].[1997].[Q4].[11]}\\n\" + \"{[Time].[1997].[Q4].[10]}\\n\" + \"{[Time].[1997].[Q4]}\\n\" + \"{[Time].[1997].[Q3].[9]}\\n\" + \"{[Time].[1997].[Q3].[8]}\\n\" + \"{[Time].[1997].[Q3].[7]}\\n\" + \"{[Time].[1997].[Q3]}\\n\" + \"{[Time].[1997].[Q2].[6]}\\n\" + \"{[Time].[1997].[Q2].[5]}\\n\" + \"{[Time].[1997].[Q2].[4]}\\n\" + \"{[Time].[1997].[Q2]}\\n\" + \"{[Time].[1997].[Q1].[3]}\\n\" + \"{[Time].[1997].[Q1].[2]}\\n\" + \"{[Time].[1997].[Q1].[1]}\\n\" + \"{[Time].[1997].[Q1]}\\n\" + \"{[Time].[1997]}\\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: 26,796\\n\" + \"Row #0: 25,270\\n\" + \"Row #0: 19,958\\n\" + \"Row #0: 72,024\\n\" + \"Row #0: 20,388\\n\" + \"Row #0: 21,697\\n\" + \"Row #0: 23,763\\n\" + \"Row #0: 65,848\\n\" + \"Row #0: 21,350\\n\" + \"Row #0: 21,081\\n\" + \"Row #0: 20,179\\n\" + \"Row #0: 62,610\\n\" + \"Row #0: 23,706\\n\" + \"Row #0: 20,957\\n\" + \"Row #0: 21,628\\n\" + \"Row #0: 66,291\\n\" + \"Row #0: 266,773\\n\");\r\n}"
}, {
	"Path": "mondrian.olap.type.TypeUtil.stripSetType",
	"Comment": "given a set type, returns the element type. or its element type, if itis a set type. and so on.",
	"Method": "Type stripSetType(Type type){\r\n    while (type instanceof SetType) {\r\n        type = ((SetType) type).getElementType();\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "org.mapsforge.samples.android.NoXMLLayout.getMapView",
	"Comment": "in this class we instantiate the mapview directly using this class,without using an xml layout file.",
	"Method": "MapView getMapView(){\r\n    MapView mv = new MapView(this);\r\n    setContentView(mv);\r\n    return mv;\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.md5HashingAlg",
	"Comment": "internal private hashing method.\tmd5 based hash algorithm for use in the consistent\thashing approach.",
	"Method": "long md5HashingAlg(String key){\r\n    MessageDigest md5 = MD5.get();\r\n    md5.reset();\r\n    md5.update(key.getBytes());\r\n    byte[] bKey = md5.digest();\r\n    long res = ((long) (bKey[3] & 0xFF) << 24) | ((long) (bKey[2] & 0xFF) << 16) | ((long) (bKey[1] & 0xFF) << 8) | (long) (bKey[0] & 0xFF);\r\n    return res;\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.getConnection",
	"Comment": "returns a sockio object from the pool for the passed in host.\tmeant to be called from a more intelligent method\twhich handles choosing appropriate server\tand failover.",
	"Method": "SockIO getConnection(String host){\r\n    if (!this.initialized) {\r\n        log.error(\"attempting to get SockIO from uninitialized pool!\");\r\n        return null;\r\n    }\r\n    if (host == null)\r\n        return null;\r\n    synchronized (this) {\r\n        if (availPool != null && !availPool.isEmpty()) {\r\n            Map<SockIO, Long> aSockets = availPool.get(host);\r\n            if (aSockets != null && !aSockets.isEmpty()) {\r\n                for (Iterator<SockIO> i = aSockets.keySet().iterator(); i.hasNext(); ) {\r\n                    SockIO socket = i.next();\r\n                    if (socket.isConnected()) {\r\n                        if (log.isDebugEnabled())\r\n                            log.debug(\"++++ moving socket for host (\" + host + \") to busy pool ... socket: \" + socket);\r\n                        i.remove();\r\n                        addSocketToPool(busyPool, host, socket);\r\n                        return socket;\r\n                    } else {\r\n                        deadPool.put(socket, ZERO);\r\n                        i.remove();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    SockIO socket = createSocket(host);\r\n    if (socket != null) {\r\n        synchronized (this) {\r\n            addSocketToPool(busyPool, host, socket);\r\n        }\r\n    }\r\n    return socket;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapResult.getCellOrdinal",
	"Comment": "converts a set of cell coordinates to a cell ordinal.this method can be expensive, because the ordinal is computed from thelength of the axes, and therefore the axes need to be instantiated.",
	"Method": "int getCellOrdinal(int[] pos){\r\n    if (modulos == null) {\r\n        makeModulos();\r\n    }\r\n    return modulos.getCellOrdinal(pos);\r\n}"
}, {
	"Path": "mondrian.olap.Query.close",
	"Comment": "closes this query.releases any resources held. writes statistics to log if profilingis enabled.this method is idempotent.",
	"Method": "void close(){\r\n    if (ownStatement) {\r\n        statement.close();\r\n    }\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Del.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Del appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.RolapEvaluator.setSlicerContext",
	"Comment": "adds a slicer member to the evaluator context, and remember it as partof the slicer. the slicer members are passed onto derived evaluatorsso that functions using those evaluators can choose to ignore theslicer members. one such function is crossjoin emptiness check.",
	"Method": "void setSlicerContext(Member member){\r\n    setContext(member);\r\n    slicerMembers.add(member);\r\n}"
}, {
	"Path": "mondrian.rolap.sql.SqlQuery.addFromQuery",
	"Comment": "adds a subquery to the from clause of this query with a given alias.if the query already exists it either, depending onfailifexists, throws an exception or does not add the queryand returns false.",
	"Method": "boolean addFromQuery(String query,String alias,boolean failIfExists){\r\n    assert alias != null;\r\n    assert alias.length() > 0;\r\n    if (fromAliases.contains(alias)) {\r\n        if (failIfExists) {\r\n            throw Util.newInternal(\"query already contains alias '\" + alias + \"'\");\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    buf.setLength(0);\r\n    buf.append('(');\r\n    buf.append(query);\r\n    buf.append(')');\r\n    if (dialect.allowsAs()) {\r\n        buf.append(\" as \");\r\n    } else {\r\n        buf.append(' ');\r\n    }\r\n    dialect.quoteIdentifier(alias, buf);\r\n    fromAliases.add(alias);\r\n    from.add(buf.toString());\r\n    return true;\r\n}"
}, {
	"Path": "org.mapsforge.samples.android.cluster.Cluster.redraw",
	"Comment": "add the clustermarker to the layers if is within viewport, otherwise remove.",
	"Method": "void redraw(){\r\n    Layers mapOverlays = clusterManager.getMapView().getLayerManager().getLayers();\r\n    if (clusterMarker != null && !clusterManager.getCurBounds().contains(center) && mapOverlays.contains(clusterMarker)) {\r\n        mapOverlays.remove(clusterMarker);\r\n        return;\r\n    }\r\n    if (clusterMarker != null && mapOverlays.size() > 0 && !mapOverlays.contains(clusterMarker) && !clusterManager.isClustering) {\r\n        mapOverlays.add(1, clusterMarker);\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.BasicQueryTest.testMemberOnAxis",
	"Comment": "if an axis expression is a member, implicitly convert it to a set.",
	"Method": "void testMemberOnAxis(){\r\n    assertQueryReturns(\"select [Measures].[Sales Count] on 0, non empty [Store].[Store State].members on 1 from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Sales Count]}\\n\" + \"Axis #2:\\n\" + \"{[Store].[USA].[CA]}\\n\" + \"{[Store].[USA].[OR]}\\n\" + \"{[Store].[USA].[WA]}\\n\" + \"Row #0: 24,442\\n\" + \"Row #1: 21,611\\n\" + \"Row #2: 40,784\\n\");\r\n}"
}, {
	"Path": "mondrian.test.TestContext.assertSimpleQuery",
	"Comment": "executes a very simple query.this forces the schema to be loaded and performs a basic sanity check.if this is a negative schema test, causes schema validation errors to bethrown.",
	"Method": "void assertSimpleQuery(){\r\n    assertQueryReturns(\"select from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"266,773\");\r\n}"
}, {
	"Path": "org.sqlite.database.DatabaseUtils.appendValueToSql",
	"Comment": "appends an object to an sql string with the proper escaping, etc.",
	"Method": "void appendValueToSql(StringBuilder sql,Object value){\r\n    if (value == null) {\r\n        sql.append(\"NULL\");\r\n    } else if (value instanceof Boolean) {\r\n        Boolean bool = (Boolean) value;\r\n        if (bool) {\r\n            sql.append('1');\r\n        } else {\r\n            sql.append('0');\r\n        }\r\n    } else {\r\n        appendEscapedSQLString(sql, value.toString());\r\n    }\r\n}"
}, {
	"Path": "cc.mallet.util.Timing.totalElapsedTime",
	"Comment": "returns the number of milliseconds since this object was created.ignores previous calls to tick, unlikeelapsedtime and tick.",
	"Method": "long totalElapsedTime(){\r\n    return System.currentTimeMillis() - objCreationTime;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteClosable.releaseReference",
	"Comment": "releases a reference to the object, closing the object if the last referencewas released.",
	"Method": "void releaseReference(){\r\n    boolean refCountIsZero = false;\r\n    synchronized (this) {\r\n        refCountIsZero = --mReferenceCount == 0;\r\n    }\r\n    if (refCountIsZero) {\r\n        onAllReferencesReleased();\r\n    }\r\n}"
}, {
	"Path": "mondrian.tui.CmdRunner.getOlapConnection",
	"Comment": "gets an olap4j connection, creating a new one if fresh is true.",
	"Method": "OlapConnection getOlapConnection(){\r\n    if (this.connectString == null) {\r\n        makeConnectString();\r\n    }\r\n    final String olapConnectString = \"jdbc:mondrian:\" + connectString;\r\n    final java.sql.Connection jdbcConnection = java.sql.DriverManager.getConnection(olapConnectString);\r\n    return ((OlapWrapper) jdbcConnection).unwrap(OlapConnection.class);\r\n}"
}, {
	"Path": "mondrian.rolap.NonEmptyTest.testExpandNonNativeResourceLimitFailure",
	"Comment": "check that the expandnonnative does not create joins with input listscontaining large number of members.",
	"Method": "void testExpandNonNativeResourceLimitFailure(){\r\n    propSaver.set(MondrianProperties.instance().ExpandNonNative, true);\r\n    propSaver.set(MondrianProperties.instance().EnableNativeCrossJoin, true);\r\n    propSaver.set(MondrianProperties.instance().ResultLimit, 2);\r\n    try {\r\n        executeQuery(\"select \" + \"NonEmptyCrossJoin({[Gender].Children, [Gender].[F]}, {[Store].Children, [Store].[Mexico]}) on columns \" + \"from [Sales]\");\r\n        fail(\"Expected error did not occur\");\r\n    } catch (Throwable e) {\r\n        String expectedErrorMsg = \"Mondrian Error:Size of CrossJoin result (3) exceeded limit (2)\";\r\n        assertEquals(expectedErrorMsg, e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.FilterTest.testNotInMultiLevelMemberConstraintSingleNullParent",
	"Comment": "test that null members are included when the filter explicitly excludesa single member that has a null.the members span multiple levels.",
	"Method": "void testNotInMultiLevelMemberConstraintSingleNullParent(){\r\n    if (!isDefaultNullMemberRepresentation()) {\r\n        return;\r\n    }\r\n    if (MondrianProperties.instance().FilterChildlessSnowflakeMembers.get()) {\r\n        return;\r\n    }\r\n    String dimension = \"<Dimension name=\\\"Warehouse2\\\">\\n\" + \"  <Hierarchy hasAll=\\\"true\\\" primaryKey=\\\"warehouse_id\\\">\\n\" + \"    <Table name=\\\"warehouse\\\"/>\\n\" + \"    <Level name=\\\"fax\\\" column=\\\"warehouse_fax\\\" uniqueMembers=\\\"true\\\"/>\\n\" + \"    <Level name=\\\"address1\\\" column=\\\"wa_address1\\\" uniqueMembers=\\\"false\\\"/>\\n\" + \"    <Level name=\\\"name\\\" column=\\\"warehouse_name\\\" uniqueMembers=\\\"false\\\"/>\\n\" + \"  <\/Hierarchy>\\n\" + \"<\/Dimension>\\n\";\r\n    String cube = \"<Cube name=\\\"Warehouse2\\\">\\n\" + \"  <Table name=\\\"inventory_fact_1997\\\"/>\\n\" + \"  <DimensionUsage name=\\\"Product\\\" source=\\\"Product\\\" foreignKey=\\\"product_id\\\"/>\\n\" + \"  <DimensionUsage name=\\\"Warehouse2\\\" source=\\\"Warehouse2\\\" foreignKey=\\\"warehouse_id\\\"/>\\n\" + \"  <Measure name=\\\"Warehouse Cost\\\" column=\\\"warehouse_cost\\\" aggregator=\\\"sum\\\"/>\\n\" + \"  <Measure name=\\\"Warehouse Sales\\\" column=\\\"warehouse_sales\\\" aggregator=\\\"sum\\\"/>\\n\" + \"<\/Cube>\";\r\n    String query = \"with\\n\" + \"set [Filtered Warehouse Set] as 'Filter([Warehouse2].[name].Members, [Warehouse2].CurrentMember Not In\" + \"{[Warehouse2].[#null].[234 West Covina Pkwy].[Freeman And Co]})' \" + \"set [NECJ] as NonEmptyCrossJoin([Filtered Warehouse Set], {[Product].[Product Family].Food}) \" + \"select [NECJ] on 0 from [Warehouse2]\";\r\n    String necjSqlDerby = \"select \\\"warehouse\\\".\\\"warehouse_fax\\\", \\\"warehouse\\\".\\\"wa_address1\\\", \" + \"\\\"warehouse\\\".\\\"warehouse_name\\\", \\\"product_class\\\".\\\"product_family\\\" \" + \"from \\\"warehouse\\\" as \\\"warehouse\\\", \\\"inventory_fact_1997\\\" as \" + \"\\\"inventory_fact_1997\\\", \\\"product\\\" as \\\"product\\\", \\\"product_class\\\" \" + \"as \\\"product_class\\\" where \\\"inventory_fact_1997\\\".\\\"warehouse_id\\\" = \" + \"\\\"warehouse\\\".\\\"warehouse_id\\\" and \\\"product\\\".\\\"product_class_id\\\" = \" + \"\\\"product_class\\\".\\\"product_class_id\\\" and \" + \"\\\"inventory_fact_1997\\\".\\\"product_id\\\" = \\\"product\\\".\\\"product_id\\\" and \" + \"(\\\"product_class\\\".\\\"product_family\\\" = 'Food') and ((not \" + \"(\\\"warehouse\\\".\\\"warehouse_name\\\" = 'Freeman And Co') or \" + \"(\\\"warehouse\\\".\\\"warehouse_name\\\" is null)) or (not \" + \"(\\\"warehouse\\\".\\\"wa_address1\\\" = '234 West Covina Pkwy') or \" + \"(\\\"warehouse\\\".\\\"wa_address1\\\" is null)) or not \" + \"(\\\"warehouse\\\".\\\"warehouse_fax\\\" is null)) group by \" + \"\\\"warehouse\\\".\\\"warehouse_fax\\\", \\\"warehouse\\\".\\\"wa_address1\\\", \" + \"\\\"warehouse\\\".\\\"warehouse_name\\\", \\\"product_class\\\".\\\"product_family\\\" \" + \"order by \\\"warehouse\\\".\\\"warehouse_fax\\\" ASC, \" + \"\\\"warehouse\\\".\\\"wa_address1\\\" ASC, \\\"warehouse\\\".\\\"warehouse_name\\\" ASC, \" + \"\\\"product_class\\\".\\\"product_family\\\" ASC\";\r\n    String necjSqlMySql = \"select `warehouse`.`warehouse_fax` as `c0`, \" + \"`warehouse`.`wa_address1` as `c1`, `warehouse`.`warehouse_name` \" + \"as `c2`, `product_class`.`product_family` as `c3` from \" + \"`warehouse` as `warehouse`, `inventory_fact_1997` as \" + \"`inventory_fact_1997`, `product` as `product`, `product_class` \" + \"as `product_class` where `inventory_fact_1997`.`warehouse_id` = \" + \"`warehouse`.`warehouse_id` and `product`.`product_class_id` = \" + \"`product_class`.`product_class_id` and \" + \"`inventory_fact_1997`.`product_id` = `product`.`product_id` and \" + \"(`product_class`.`product_family` = 'Food') and \" + \"((not (`warehouse`.`warehouse_name` = 'Freeman And Co') or \" + \"(`warehouse`.`warehouse_name` is null)) or (not \" + \"(`warehouse`.`wa_address1` = '234 West Covina Pkwy') or \" + \"(`warehouse`.`wa_address1` is null)) or not \" + \"(`warehouse`.`warehouse_fax` is null)) group by \" + \"`warehouse`.`warehouse_fax`, `warehouse`.`wa_address1`, \" + \"`warehouse`.`warehouse_name`, `product_class`.`product_family` \" + \"order by ISNULL(`warehouse`.`warehouse_fax`), \" + \"`warehouse`.`warehouse_fax` ASC, \" + \"ISNULL(`warehouse`.`wa_address1`), `warehouse`.`wa_address1` ASC, \" + \"ISNULL(`warehouse`.`warehouse_name`), \" + \"`warehouse`.`warehouse_name` ASC, \" + \"ISNULL(`product_class`.`product_family`), \" + \"`product_class`.`product_family` ASC\";\r\n    SqlPattern[] patterns = { new SqlPattern(Dialect.DatabaseProduct.DERBY, necjSqlDerby, necjSqlDerby), new SqlPattern(Dialect.DatabaseProduct.MYSQL, necjSqlMySql, necjSqlMySql) };\r\n    TestContext testContext = TestContext.instance().create(dimension, cube, null, null, null, null);\r\n    assertQuerySql(testContext, query, patterns);\r\n}"
}, {
	"Path": "mondrian.rolap.RolapResult.getCellMembers",
	"Comment": "called only by rolapcell. use this when creating an evaluatoris not required.",
	"Method": "RolapMember[] getCellMembers(int[] pos){\r\n    RolapMember[] members = (RolapMember[]) evaluator.getMembers().clone();\r\n    for (int i = 0; i < pos.length; i++) {\r\n        Position position = axes[i].getPositions().get(pos[i]);\r\n        for (Member member : position) {\r\n            RolapMember m = (RolapMember) member;\r\n            int ordinal = m.getHierarchy().getOrdinalInCube();\r\n            members[ordinal] = m;\r\n        }\r\n    }\r\n    return members;\r\n}"
}, {
	"Path": "mondrian.test.TestContext.assertParameterizedExprReturns",
	"Comment": "asserts that an expression, with a given set of parameter bindings,returns a given result.",
	"Method": "void assertParameterizedExprReturns(String expr,String expected,Object paramValues){\r\n    Connection connection = getConnection();\r\n    String queryString = generateExpression(expr);\r\n    Query query = connection.parseQuery(queryString);\r\n    assert paramValues.length % 2 == 0;\r\n    for (int i = 0; i < paramValues.length; ) {\r\n        final String paramName = (String) paramValues[i++];\r\n        final Object value = paramValues[i++];\r\n        query.setParameter(paramName, value);\r\n    }\r\n    final Result result = connection.execute(query);\r\n    final Cell cell = result.getCell(new int[] { 0 });\r\n    if (expected == null) {\r\n        expected = \"\";\r\n    }\r\n    assertEqualsVerbose(expected, cell.getFormattedValue());\r\n}"
}, {
	"Path": "org.jfaster.mango.util.logging.InternalLoggerFactory.getInstance",
	"Comment": "creates a new logger instance with the name of the specified class.",
	"Method": "InternalLogger getInstance(Class<?> clazz,InternalLogger getInstance,String name){\r\n    return getDefaultFactory().newInstance(name);\r\n}"
}, {
	"Path": "mondrian.server.DynamicContentFinder.reloadDataSources",
	"Comment": "checks for updates to datasources content, flushes obsolete catalogs.",
	"Method": "void reloadDataSources(){\r\n    try {\r\n        String dataSourcesConfigString = getContent();\r\n        if (!hasDataSourcesContentChanged(dataSourcesConfigString)) {\r\n            return;\r\n        }\r\n        DataSourcesConfig.DataSources newDataSources = XmlaSupport.parseDataSources(dataSourcesConfigString, LOGGER);\r\n        if (newDataSources == null) {\r\n            return;\r\n        }\r\n        flushObsoleteCatalogs(newDataSources);\r\n        this.dataSources = newDataSources;\r\n        this.lastDataSourcesConfigString = dataSourcesConfigString;\r\n    } catch (Exception e) {\r\n        throw Util.newError(e, \"Failed to parse data sources config '\" + url + \"'\");\r\n    }\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.H2.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "H2 appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.spi.DialectManager.createFactoryForDialect",
	"Comment": "creates a factory that calls a public constructor of a dialect class.",
	"Method": "DialectFactory createFactoryForDialect(Class<? extends Dialect> dialectClass){\r\n    for (Field field : dialectClass.getFields()) {\r\n        if (Modifier.isPublic(field.getModifiers()) && Modifier.isStatic(field.getModifiers()) && field.getName().equals(\"FACTORY\") && DialectFactory.class.isAssignableFrom(field.getType())) {\r\n            try {\r\n                final DialectFactory factory = (DialectFactory) field.get(null);\r\n                if (factory != null) {\r\n                    return factory;\r\n                }\r\n            } catch (IllegalAccessException e) {\r\n                throw Util.newError(e, \"Error while accessing field \" + field);\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        final Constructor<? extends Dialect> constructor = dialectClass.getConstructor(Connection.class);\r\n        if (Modifier.isPublic(constructor.getModifiers())) {\r\n            return new ConstructorDialectFactory(constructor);\r\n        }\r\n    } catch (NoSuchMethodException e) {\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.heinrichreimersoftware.materialdrawer.DrawerActivity.hasOnProfileSwitchListener",
	"Comment": "gets whether the drawer has a profile switch listener set to it",
	"Method": "boolean hasOnProfileSwitchListener(){\r\n    return mDrawer.hasOnProfileSwitchListener();\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.DeltaEncoder.encode",
	"Comment": "encodes a list of waydatablock objects with the given encoding scheme.",
	"Method": "List<WayDataBlock> encode(List<WayDataBlock> blocks,Encoding encoding){\r\n    if (blocks == null) {\r\n        return null;\r\n    }\r\n    if (encoding == Encoding.NONE) {\r\n        return blocks;\r\n    }\r\n    List<WayDataBlock> results = new ArrayList();\r\n    for (WayDataBlock wayDataBlock : blocks) {\r\n        List<Integer> outer = mEncode(wayDataBlock.getOuterWay(), encoding);\r\n        List<List<Integer>> inner = null;\r\n        if (wayDataBlock.getInnerWays() != null) {\r\n            inner = new ArrayList();\r\n            for (List<Integer> list : wayDataBlock.getInnerWays()) {\r\n                inner.add(mEncode(list, encoding));\r\n            }\r\n        }\r\n        results.add(new WayDataBlock(outer, inner, encoding));\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "com.meetup.memcached.SockIOPool.setFailover",
	"Comment": "sets the failover flag for the pool.\tif this flag is set to true, and a socket fails to connect,\tthe pool will attempt to return a socket from another server\tif one exists.if set to false, then getting a socket\twill return null if it fails to connect to the requested server.",
	"Method": "void setFailover(boolean failover){\r\n    this.failover = failover;\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlTest.flushCache",
	"Comment": "flushes the entire contents of the cache. utility method used to ensurethat cache control tests are starting with a blank page.",
	"Method": "void flushCache(TestContext testContext){\r\n    final CacheControl cacheControl = testContext.getCacheControl();\r\n    CacheControl.CellRegion measuresRegion = null;\r\n    for (Cube cube : testContext.getConnection().getSchema().getCubes()) {\r\n        measuresRegion = cacheControl.createMeasuresRegion(cube);\r\n        cacheControl.flush(measuresRegion);\r\n    }\r\n    StringWriter sw = new StringWriter();\r\n    PrintWriter pw = new PrintWriter(sw);\r\n    cacheControl.printCacheState(pw, measuresRegion);\r\n    pw.flush();\r\n    assertEquals(\"\", sw.toString());\r\n}"
}, {
	"Path": "mondrian.test.TestCalculatedMembers.testSimulatedCompoundSlicer",
	"Comment": "query that simulates a compound slicer by creating a calculated memberthat aggregates over a set and places it in the where clause.",
	"Method": "void testSimulatedCompoundSlicer(){\r\n    assertQueryReturns(\"with\\n\" + \"  member [Measures].[Price per Unit] as\\n\" + \"    [Measures].[Store Sales] / [Measures].[Unit Sales]\\n\" + \"  set [Top Products] as\\n\" + \"    TopCount(\\n\" + \"      [Product].[Brand Name].Members,\\n\" + \"      3,\\n\" + \"      ([Measures].[Unit Sales], [Time].[1997].[Q3]))\\n\" + \"  member [Product].[Top] as\\n\" + \"    Aggregate([Top Products])\\n\" + \"select {\\n\" + \"  [Measures].[Unit Sales],\\n\" + \"  [Measures].[Price per Unit]} on 0,\\n\" + \" [Gender].Children * [Marital Status].Children on 1\\n\" + \"from [Sales]\\n\" + \"where ([Product].[Top], [Time].[1997].[Q3])\", \"Axis #0:\\n\" + \"{[Product].[Top], [Time].[1997].[Q3]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"{[Measures].[Price per Unit]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[F], [Marital Status].[M]}\\n\" + \"{[Gender].[F], [Marital Status].[S]}\\n\" + \"{[Gender].[M], [Marital Status].[M]}\\n\" + \"{[Gender].[M], [Marital Status].[S]}\\n\" + \"Row #0: 779\\n\" + \"Row #0: 2.40\\n\" + \"Row #1: 811\\n\" + \"Row #1: 2.24\\n\" + \"Row #2: 829\\n\" + \"Row #2: 2.23\\n\" + \"Row #3: 886\\n\" + \"Row #3: 2.25\\n\");\r\n    assertQueryReturns(\"with\\n\" + \"  member [Measures].[Price per Unit] as\\n\" + \"    [Measures].[Store Sales] / [Measures].[Unit Sales]\\n\" + \"  set [Top Products] as\\n\" + \"    TopCount(\\n\" + \"      [Product].[Brand Name].Members,\\n\" + \"      3,\\n\" + \"      ([Measures].[Unit Sales], [Time].[1997].[Q3]))\\n\" + \"select {\\n\" + \"  [Measures].[Unit Sales],\\n\" + \"  [Measures].[Price per Unit]} on 0,\\n\" + \" [Gender].Children * [Marital Status].Children on 1\\n\" + \"from [Sales]\\n\" + \"where [Top Products] * [Time].[1997].[Q3]\", \"Axis #0:\\n\" + \"{[Product].[Food].[Produce].[Vegetables].[Fresh Vegetables].[Hermanos], [Time].[1997].[Q3]}\\n\" + \"{[Product].[Food].[Produce].[Vegetables].[Fresh Vegetables].[Tell Tale], [Time].[1997].[Q3]}\\n\" + \"{[Product].[Food].[Produce].[Vegetables].[Fresh Vegetables].[Ebony], [Time].[1997].[Q3]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Unit Sales]}\\n\" + \"{[Measures].[Price per Unit]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[F], [Marital Status].[M]}\\n\" + \"{[Gender].[F], [Marital Status].[S]}\\n\" + \"{[Gender].[M], [Marital Status].[M]}\\n\" + \"{[Gender].[M], [Marital Status].[S]}\\n\" + \"Row #0: 779\\n\" + \"Row #0: 2.40\\n\" + \"Row #1: 811\\n\" + \"Row #1: 2.24\\n\" + \"Row #2: 829\\n\" + \"Row #2: 2.23\\n\" + \"Row #3: 886\\n\" + \"Row #3: 2.25\\n\");\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletResponse.getWriter",
	"Comment": "returns a printwriter object that can send character text to the client.",
	"Method": "PrintWriter getWriter(){\r\n    if (writer == null) {\r\n        writer = new PrintWriter(new OutputStreamWriter(outputStream, charEncoding), true);\r\n    }\r\n    return writer;\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Strong.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Strong appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunctionTest.testNamedSetCurrentOrdinalWithGenerate",
	"Comment": "tests namedset.currentordinal combined with the generate function.",
	"Method": "void testNamedSetCurrentOrdinalWithGenerate(){\r\n    if (Util.Retrowoven) {\r\n        return;\r\n    }\r\n    assertQueryReturns(\" with set [Time Regular] as [Time].[Time].Members\\n\" + \"set [Every Other Time] as\\n\" + \"  Generate(\\n\" + \"    [Time Regular],\\n\" + \"    {[Time].[Time].Members.Item(\\n\" + \"      [Time Regular].CurrentOrdinal * 2)})\\n\" + \"select [Every Other Time] on 0\\n\" + \"from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Time].[1997]}\\n\" + \"{[Time].[1997].[Q1].[1]}\\n\" + \"{[Time].[1997].[Q1].[3]}\\n\" + \"{[Time].[1997].[Q2].[4]}\\n\" + \"{[Time].[1997].[Q2].[6]}\\n\" + \"{[Time].[1997].[Q3].[7]}\\n\" + \"{[Time].[1997].[Q3].[9]}\\n\" + \"{[Time].[1997].[Q4].[10]}\\n\" + \"{[Time].[1997].[Q4].[12]}\\n\" + \"{[Time].[1998].[Q1]}\\n\" + \"{[Time].[1998].[Q1].[2]}\\n\" + \"{[Time].[1998].[Q2]}\\n\" + \"{[Time].[1998].[Q2].[5]}\\n\" + \"{[Time].[1998].[Q3]}\\n\" + \"{[Time].[1998].[Q3].[8]}\\n\" + \"{[Time].[1998].[Q4]}\\n\" + \"{[Time].[1998].[Q4].[11]}\\n\" + \"Row #0: 266,773\\n\" + \"Row #0: 21,628\\n\" + \"Row #0: 23,706\\n\" + \"Row #0: 20,179\\n\" + \"Row #0: 21,350\\n\" + \"Row #0: 23,763\\n\" + \"Row #0: 20,388\\n\" + \"Row #0: 19,958\\n\" + \"Row #0: 26,796\\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\" + \"Row #0: \\n\");\r\n}"
}, {
	"Path": "mondrian.calc.CalcWriter.enableProfiling",
	"Comment": "whether to print out attributes relating to how a statement was actuallyexecuted. if false, client should only send attributes relating to theplan.",
	"Method": "boolean enableProfiling(){\r\n    return profiling;\r\n}"
}, {
	"Path": "mondrian.gui.I18n.getString",
	"Comment": "retreive a resource string using the given locale. use the default ifthere is nothing for the given locale.",
	"Method": "String getString(String stringId,String getString,String stringId,String defaultValue,String getString,String stringId,Locale currentLocale,String getString,String stringId,Locale currentLocale,String defaultValue){\r\n    try {\r\n        if (languageBundle == null) {\r\n            throw new Exception(\"No language bundle\");\r\n        }\r\n        return languageBundle.getString(stringId);\r\n    } catch (MissingResourceException ex) {\r\n        LOGGER.error(\"Can't find the translation for key = \" + stringId + \": using default (\" + defaultValue + \")\", ex);\r\n    } catch (Exception ex) {\r\n        LOGGER.error(\"Exception loading stringID = \" + stringId, ex);\r\n    }\r\n    return defaultValue;\r\n}"
}, {
	"Path": "mondrian.test.Ssas2005CompatibilityTest.testCanHaveMemberWithSameNameAsLevel",
	"Comment": "tests the ambiguity between a level and a member of the same name,both in ssas compatible mode and in regular mode.",
	"Method": "void testCanHaveMemberWithSameNameAsLevel(){\r\n    TestContext testContext = TestContext.instance().createSubstitutingCube(\"Sales\", \"<Dimension name=\\\"SameName\\\" foreignKey=\\\"customer_id\\\">\\n\" + \" <Hierarchy hasAll=\\\"true\\\" primaryKey=\\\"id\\\">\\n\" + \" <InlineTable alias=\\\"sn\\\">\\n\" + \" <ColumnDefs>\\n\" + \" <ColumnDef name=\\\"id\\\" type=\\\"Numeric\\\" />\\n\" + \" <ColumnDef name=\\\"desc\\\" type=\\\"String\\\" />\\n\" + \" <\/ColumnDefs>\\n\" + \" <Rows>\\n\" + \" <Row>\\n\" + \" <Value column=\\\"id\\\">1<\/Value>\\n\" + \" <Value column=\\\"desc\\\">SameName<\/Value>\\n\" + \" <\/Row>\\n\" + \" <\/Rows>\\n\" + \" <\/InlineTable>\\n\" + \" <Level name=\\\"SameName\\\" column=\\\"desc\\\" uniqueMembers=\\\"true\\\" />\\n\" + \" <\/Hierarchy>\\n\" + \"<\/Dimension>\");\r\n    org.olap4j.metadata.Member member = testContext.getOlap4jConnection().getOlapSchema().getCubes().get(\"Sales\").getDimensions().get(\"SameName\").getHierarchies().get(\"SameName\").getLevels().get(\"SameName\").getMembers().get(0);\r\n    assertEquals(\"[SameName].[SameName].[SameName]\", member.getUniqueName());\r\n    testContext.assertQueryThrows(\"select {\" + (MondrianProperties.instance().SsasCompatibleNaming.get() ? \"[SameName].[SameName].[SameName]\" : \"[SameName].[SameName]\") + \"} on 0 from Sales\", \"Mondrian Error:No function matches signature '{<Level>}'\");\r\n    if (MondrianProperties.instance().SsasCompatibleNaming.get()) {\r\n        testContext.assertQueryReturns(\"select {[SameName].[SameName].[SameName].[SameName]} on 0 from Sales\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[SameName].[SameName].[SameName]}\\n\" + \"Row #0: \\n\");\r\n    } else {\r\n        testContext.assertQueryReturns(\"select {[SameName].[SameName].[SameName]} on 0 from Sales\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[SameName].[SameName].[SameName]}\\n\" + \"Row #0: \\n\");\r\n    }\r\n}"
}, {
	"Path": "com.mcxiaoke.minicat.util.StringUtils.trimLeadingCharacter",
	"Comment": "trim all occurences of the supplied leading character from the givenstring.",
	"Method": "String trimLeadingCharacter(String str,char leadingCharacter){\r\n    if (!hasLength(str)) {\r\n        return str;\r\n    }\r\n    StringBuilder sb = new StringBuilder(str);\r\n    while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {\r\n        sb.deleteCharAt(0);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlImpl.validateSameLevel",
	"Comment": "validates that all members of a member set are the same level.",
	"Method": "void validateSameLevel(MemberSetPlus memberSet){\r\n    memberSet.accept(new MemberSetVisitor() {\r\n        final Set<RolapLevel> levelSet = new HashSet<RolapLevel>();\r\n        private void visitMember(RolapMember member, boolean descendants) {\r\n            final String message = \"all members in set must belong to same level\";\r\n            if (levelSet.add(member.getLevel()) && levelSet.size() > 1) {\r\n                throw new IllegalArgumentException(message);\r\n            }\r\n            if (descendants && member.getLevel().getChildLevel() != null) {\r\n                throw new IllegalArgumentException(message);\r\n            }\r\n        }\r\n        public void visit(SimpleMemberSet simpleMemberSet) {\r\n            for (RolapMember member : simpleMemberSet.members) {\r\n                visitMember(member, simpleMemberSet.descendants);\r\n            }\r\n        }\r\n        public void visit(UnionMemberSet unionMemberSet) {\r\n            for (MemberSetPlus item : unionMemberSet.items) {\r\n                item.accept(this);\r\n            }\r\n        }\r\n        public void visit(RangeMemberSet rangeMemberSet) {\r\n            visitMember(rangeMemberSet.lowerMember, rangeMemberSet.descendants);\r\n            visitMember(rangeMemberSet.upperMember, rangeMemberSet.descendants);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlImpl.validateSameLevel",
	"Comment": "validates that all members of a member set are the same level.",
	"Method": "void validateSameLevel(MemberSetPlus memberSet){\r\n    final String message = \"all members in set must belong to same level\";\r\n    if (levelSet.add(member.getLevel()) && levelSet.size() > 1) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n    if (descendants && member.getLevel().getChildLevel() != null) {\r\n        throw new IllegalArgumentException(message);\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlImpl.validateSameLevel",
	"Comment": "validates that all members of a member set are the same level.",
	"Method": "void validateSameLevel(MemberSetPlus memberSet){\r\n    for (RolapMember member : simpleMemberSet.members) {\r\n        visitMember(member, simpleMemberSet.descendants);\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlImpl.validateSameLevel",
	"Comment": "validates that all members of a member set are the same level.",
	"Method": "void validateSameLevel(MemberSetPlus memberSet){\r\n    for (MemberSetPlus item : unionMemberSet.items) {\r\n        item.accept(this);\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.CacheControlImpl.validateSameLevel",
	"Comment": "validates that all members of a member set are the same level.",
	"Method": "void validateSameLevel(MemberSetPlus memberSet){\r\n    visitMember(rangeMemberSet.lowerMember, rangeMemberSet.descendants);\r\n    visitMember(rangeMemberSet.upperMember, rangeMemberSet.descendants);\r\n}"
}, {
	"Path": "mondrian.test.AccessControlTest.testGrantHierarchy9",
	"Comment": "tests that we only aggregate over sf, la, even when called fromfunctions.",
	"Method": "void testGrantHierarchy9(){\r\n    final TestContext tc = new RestrictedTestContext();\r\n    tc.assertQueryReturns(\"with member [Measures].[California Unit Sales] as \" + \" 'Aggregate({[Store].[USA].[CA].children}, [Measures].[Unit Sales])'\\n\" + \"select {[Measures].[California Unit Sales]} on columns,\\n\" + \" {[Gender].children} on rows\\n\" + \"from Sales\\n\" + \"where ([Marital Status].[S])\", \"Axis #0:\\n\" + \"{[Marital Status].[S]}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[California Unit Sales]}\\n\" + \"Axis #2:\\n\" + \"{[Gender].[F]}\\n\" + \"{[Gender].[M]}\\n\" + \"Row #0: 6,636\\n\" + \"Row #1: 7,329\\n\");\r\n}"
}, {
	"Path": "mondrian.tui.MockServletConfig.getInitParameter",
	"Comment": "returns a string containing the value of the named initializationparameter, or null if the parameter does not exist.",
	"Method": "String getInitParameter(String key){\r\n    return initParams.get(key);\r\n}"
}, {
	"Path": "org.springframework.extensions.jcr.JcrAccessor.convertJcrAccessException",
	"Comment": "convert the given runtimeexception to an appropriate exception from theorg.springframework.dao hierarchy.may be overridden in subclasses.",
	"Method": "DataAccessException convertJcrAccessException(RepositoryException ex,DataAccessException convertJcrAccessException,IOException ex,RuntimeException convertJcrAccessException,RuntimeException ex){\r\n    return ex;\r\n}"
}, {
	"Path": "com.meetup.memcached.MemcachedClient.delete",
	"Comment": "deletes an object from cache given cache key and expiration date.",
	"Method": "boolean delete(String key,boolean delete,String key,Date expiry,boolean delete,String key,Integer hashCode,Date expiry){\r\n    if (key == null) {\r\n        log.error(\"null value for key passed to delete()\");\r\n        return false;\r\n    }\r\n    try {\r\n        key = sanitizeKey(key);\r\n    } catch (UnsupportedEncodingException e) {\r\n        if (errorHandler != null)\r\n            errorHandler.handleErrorOnDelete(this, e, key);\r\n        log.error(\"failed to sanitize your key!\", e);\r\n        return false;\r\n    }\r\n    SockIOPool.SockIO sock = pool.getSock(key, hashCode);\r\n    if (sock == null) {\r\n        if (errorHandler != null)\r\n            errorHandler.handleErrorOnDelete(this, new IOException(\"no socket to server available\"), key);\r\n        return false;\r\n    }\r\n    StringBuilder command = new StringBuilder(\"delete \").append(key);\r\n    if (expiry != null)\r\n        command.append(\" \" + expiry.getTime() / 1000);\r\n    command.append(\"\\r\\n\");\r\n    try {\r\n        sock.write(command.toString().getBytes());\r\n        sock.flush();\r\n        String line = sock.readLine();\r\n        if (DELETED.equals(line)) {\r\n            if (log.isInfoEnabled())\r\n                log.info(\"++++ deletion of key: \" + key + \" from cache was a success\");\r\n            sock.close();\r\n            sock = null;\r\n            return true;\r\n        } else if (NOTFOUND.equals(line)) {\r\n            if (log.isInfoEnabled())\r\n                log.info(\"++++ deletion of key: \" + key + \" from cache failed as the key was not found\");\r\n        } else {\r\n            log.error(\"++++ error deleting key: \" + key);\r\n            log.error(\"++++ server response: \" + line);\r\n        }\r\n    } catch (IOException e) {\r\n        if (errorHandler != null)\r\n            errorHandler.handleErrorOnDelete(this, e, key);\r\n        log.error(\"++++ exception thrown while writing bytes to server on delete\");\r\n        log.error(e.getMessage(), e);\r\n        try {\r\n            sock.trueClose();\r\n        } catch (IOException ioe) {\r\n            log.error(\"++++ failed to close socket : \" + sock.toString());\r\n        }\r\n        sock = null;\r\n    }\r\n    if (sock != null) {\r\n        sock.close();\r\n        sock = null;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "mondrian.test.ParameterTest.testSystemPropsGet",
	"Comment": "tests accessing system properties as parameters in a statement.",
	"Method": "void testSystemPropsGet(){\r\n    final List<Property> propertyList = MondrianProperties.instance().getPropertyList();\r\n    for (Property property : propertyList) {\r\n        assertExprReturns(\"ParamRef(\" + Util.singleQuoteString(property.getPath()) + \")\", property.stringValue());\r\n    }\r\n}"
}, {
	"Path": "mondrian.test.ConcurrentValidatingQueryRunner.runTest",
	"Comment": "creates and runs concurrent threads of tests with random cache flush.",
	"Method": "List<Throwable> runTest(int numThreads,int runTimeInSeconds,boolean randomQueries,boolean printReport,FoodMartTestCase.QueryAndResult[] queriesAndResults,List<Throwable> runTest,int numThreads,int runTimeInSeconds,boolean randomQueries,boolean randomCacheFlush,boolean printReport,FoodMartTestCase.QueryAndResult[] queriesAndResults){\r\n    ConcurrentValidatingQueryRunner[] runners = new ConcurrentValidatingQueryRunner[numThreads];\r\n    List<Throwable> allExceptions = new ArrayList<Throwable>();\r\n    for (int idx = 0; idx < runners.length; idx++) {\r\n        runners[idx] = new ConcurrentValidatingQueryRunner(runTimeInSeconds, randomQueries, randomCacheFlush, queriesAndResults);\r\n    }\r\n    for (int idx = 0; idx < runners.length; idx++) {\r\n        runners[idx].start();\r\n    }\r\n    for (int idx = 0; idx < runners.length; idx++) {\r\n        try {\r\n            runners[idx].join();\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    for (int idx = 0; idx < runners.length; idx++) {\r\n        allExceptions.addAll(runners[idx].mExceptions);\r\n        if (printReport) {\r\n            runners[idx].report(System.out);\r\n        }\r\n    }\r\n    return allExceptions;\r\n}"
}, {
	"Path": "mondrian.olap.fun.IsNullFunDef.nonAllWithNullKey",
	"Comment": "dimension members with a null value are treated as the null member.",
	"Method": "boolean nonAllWithNullKey(RolapMember member){\r\n    return !member.isAll() && member.getKey() == RolapUtil.sqlNullValue;\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    desktopPane = new javax.swing.JDesktopPane();\r\n    jToolBar1 = new javax.swing.JToolBar();\r\n    jToolBar2 = new javax.swing.JToolBar();\r\n    toolbarNewPopupMenu = new JPopupMenu();\r\n    toolbarNewButton = new javax.swing.JButton();\r\n    toolbarOpenButton = new javax.swing.JButton();\r\n    toolbarSaveButton = new javax.swing.JButton();\r\n    toolbarSaveAsButton = new javax.swing.JButton();\r\n    jPanel1 = new javax.swing.JPanel();\r\n    jPanel2 = new javax.swing.JPanel();\r\n    toolbarPreferencesButton = new javax.swing.JButton();\r\n    requireSchemaCheckboxMenuItem = new javax.swing.JCheckBoxMenuItem();\r\n    menuBar = new javax.swing.JMenuBar();\r\n    fileMenu = new javax.swing.JMenu();\r\n    newMenu = new javax.swing.JMenu();\r\n    newSchemaMenuItem = new javax.swing.JMenuItem();\r\n    newQueryMenuItem = new javax.swing.JMenuItem();\r\n    newJDBCExplorerMenuItem = new javax.swing.JMenuItem();\r\n    newSchemaMenuItem2 = new javax.swing.JMenuItem();\r\n    newQueryMenuItem2 = new javax.swing.JMenuItem();\r\n    newJDBCExplorerMenuItem2 = new javax.swing.JMenuItem();\r\n    openMenuItem = new javax.swing.JMenuItem();\r\n    preferencesMenuItem = new javax.swing.JMenuItem();\r\n    lastUsed1MenuItem = new javax.swing.JMenuItem();\r\n    lastUsed2MenuItem = new javax.swing.JMenuItem();\r\n    lastUsed3MenuItem = new javax.swing.JMenuItem();\r\n    lastUsed4MenuItem = new javax.swing.JMenuItem();\r\n    saveMenuItem = new javax.swing.JMenuItem();\r\n    saveAsMenuItem = new javax.swing.JMenuItem();\r\n    jSeparator1 = new javax.swing.JSeparator();\r\n    jSeparator2 = new javax.swing.JSeparator();\r\n    jSeparator3 = new javax.swing.JSeparator();\r\n    exitMenuItem = new javax.swing.JMenuItem();\r\n    windowMenu = new javax.swing.JMenu();\r\n    helpMenu = new javax.swing.JMenu();\r\n    editMenu = new javax.swing.JMenu();\r\n    cutMenuItem = new javax.swing.JMenuItem(new DefaultEditorKit.CutAction());\r\n    copyMenuItem = new javax.swing.JMenuItem(new DefaultEditorKit.CopyAction());\r\n    pasteMenuItem = new javax.swing.JMenuItem(new DefaultEditorKit.PasteAction());\r\n    deleteMenuItem = new javax.swing.JMenuItem(new AbstractAction(getResourceConverter().getString(\"workbench.menu.delete\", \"Delete\")) {\r\n        private static final long serialVersionUID = 1L;\r\n        public void actionPerformed(ActionEvent e) {\r\n            JInternalFrame jf = desktopPane.getSelectedFrame();\r\n            if (jf != null && jf.getContentPane().getComponent(0) instanceof SchemaExplorer) {\r\n                SchemaExplorer se = (SchemaExplorer) jf.getContentPane().getComponent(0);\r\n                TreePath tpath = se.tree.getSelectionPath();\r\n                se.delete(tpath);\r\n            }\r\n        }\r\n    });\r\n    aboutMenuItem = new javax.swing.JMenuItem();\r\n    toolsMenu = new javax.swing.JMenu();\r\n    viewMenu = new javax.swing.JMenu();\r\n    viewXmlMenuItem = new javax.swing.JCheckBoxMenuItem();\r\n    setTitle(getResourceConverter().getString(\"workbench.panel.title\", \"Schema Workbench\"));\r\n    setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);\r\n    addWindowListener(new WindowAdapter() {\r\n        public void windowClosing(WindowEvent evt) {\r\n            storeWorkbenchProperties();\r\n            storeDatabaseMeta();\r\n            closeAllSchemaFrames(true);\r\n        }\r\n    });\r\n    getContentPane().add(desktopPane, java.awt.BorderLayout.CENTER);\r\n    newSchemaMenuItem2.setText(getResourceConverter().getString(\"workbench.menu.newSchema\", \"Schema\"));\r\n    newSchemaMenuItem2.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            newSchemaMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    newQueryMenuItem2.setText(getResourceConverter().getString(\"workbench.menu.newQuery\", \"MDX Query\"));\r\n    newQueryMenuItem2.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            newQueryMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    newJDBCExplorerMenuItem2.setText(getResourceConverter().getString(\"workbench.menu.newJDBC\", \"JDBC Explorer\"));\r\n    newJDBCExplorerMenuItem2.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            newJDBCExplorerMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    toolbarNewPopupMenu.add(newSchemaMenuItem2);\r\n    toolbarNewPopupMenu.add(newQueryMenuItem2);\r\n    toolbarNewPopupMenu.add(newJDBCExplorerMenuItem2);\r\n    jPanel2.setLayout(new java.awt.BorderLayout());\r\n    jPanel2.setBorder(javax.swing.BorderFactory.createEtchedBorder());\r\n    jPanel2.setMaximumSize(new java.awt.Dimension(50, 28));\r\n    toolbarNewButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(getResourceConverter().getGUIReference(\"new\"))));\r\n    toolbarNewButton.setToolTipText(getResourceConverter().getString(\"workbench.toolbar.new\", \"New\"));\r\n    toolbarNewButton.setBorderPainted(false);\r\n    toolbarNewButton.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            toolbarNewPopupMenu.show(jPanel2, 0, jPanel2.getSize().height);\r\n        }\r\n    });\r\n    jToolBar2.setFloatable(false);\r\n    jToolBar2.add(toolbarNewButton);\r\n    jPanel2.add(jToolBar2, java.awt.BorderLayout.CENTER);\r\n    toolbarNewArrowButton = new BasicArrowButton(SwingConstants.SOUTH);\r\n    toolbarNewArrowButton.setToolTipText(getResourceConverter().getString(\"workbench.toolbar.newArrow\", \"New\"));\r\n    toolbarNewArrowButton.setBorderPainted(false);\r\n    toolbarNewArrowButton.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            toolbarNewPopupMenu.show(jPanel2, 0, jPanel2.getSize().height);\r\n        }\r\n    });\r\n    jPanel2.add(toolbarNewArrowButton, java.awt.BorderLayout.EAST);\r\n    jToolBar1.add(jPanel2, 0);\r\n    toolbarOpenButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(getResourceConverter().getGUIReference(\"open\"))));\r\n    toolbarOpenButton.setToolTipText(getResourceConverter().getString(\"workbench.toolbar.open\", \"Open\"));\r\n    toolbarOpenButton.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            openMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    jToolBar1.add(toolbarOpenButton);\r\n    toolbarSaveButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(getResourceConverter().getGUIReference(\"save\"))));\r\n    toolbarSaveButton.setToolTipText(getResourceConverter().getString(\"workbench.toolbar.save\", \"Save\"));\r\n    toolbarSaveButton.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            saveMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    jToolBar1.add(toolbarSaveButton);\r\n    toolbarSaveAsButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(getResourceConverter().getGUIReference(\"saveAs\"))));\r\n    toolbarSaveAsButton.setToolTipText(getResourceConverter().getString(\"workbench.toolbar.saveAs\", \"Save As\"));\r\n    toolbarSaveAsButton.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            saveAsMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    jToolBar1.add(toolbarSaveAsButton);\r\n    jPanel1.setMaximumSize(new java.awt.Dimension(8, 8));\r\n    jToolBar1.add(jPanel1);\r\n    toolbarPreferencesButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(getResourceConverter().getGUIReference(\"preferences\"))));\r\n    toolbarPreferencesButton.setToolTipText(getResourceConverter().getString(\"workbench.toolbar.connection\", \"Connection\"));\r\n    toolbarPreferencesButton.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            connectionButtonActionPerformed(evt);\r\n        }\r\n    });\r\n    jToolBar1.add(toolbarPreferencesButton);\r\n    getContentPane().add(jToolBar1, java.awt.BorderLayout.NORTH);\r\n    fileMenu.setText(getResourceConverter().getString(\"workbench.menu.file\", \"File\"));\r\n    fileMenu.setMnemonic(KeyEvent.VK_F);\r\n    newMenu.setText(getResourceConverter().getString(\"workbench.menu.new\", \"New\"));\r\n    newSchemaMenuItem.setText(getResourceConverter().getString(\"workbench.menu.newSchema\", \"Schema\"));\r\n    newSchemaMenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            newSchemaMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    newMenu.add(newSchemaMenuItem);\r\n    newQueryMenuItem.setText(getResourceConverter().getString(\"workbench.menu.newQuery\", \"MDX Query\"));\r\n    newQueryMenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            newQueryMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    newMenu.add(newQueryMenuItem);\r\n    newJDBCExplorerMenuItem.setText(getResourceConverter().getString(\"workbench.menu.newJDBC\", \"JDBC Explorer\"));\r\n    newJDBCExplorerMenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            newJDBCExplorerMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    newMenu.add(newJDBCExplorerMenuItem);\r\n    fileMenu.add(newMenu);\r\n    openMenuItem.setText(getResourceConverter().getString(\"workbench.menu.open\", \"Open\"));\r\n    openMenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            openMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    fileMenu.add(openMenuItem);\r\n    saveMenuItem.setText(getResourceConverter().getString(\"workbench.menu.save\", \"Save\"));\r\n    saveMenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            saveMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    fileMenu.add(saveMenuItem);\r\n    saveAsMenuItem.setText(getResourceConverter().getString(\"workbench.menu.saveAsDot\", \"Save As ...\"));\r\n    saveAsMenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            saveAsMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    fileMenu.add(saveAsMenuItem);\r\n    fileMenu.add(jSeparator2);\r\n    lastUsed1MenuItem.setText(getWorkbenchProperty(\"lastUsed1\"));\r\n    lastUsed1MenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            lastUsed1MenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    fileMenu.add(lastUsed1MenuItem);\r\n    lastUsed2MenuItem.setText(getWorkbenchProperty(\"lastUsed2\"));\r\n    lastUsed2MenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            lastUsed2MenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    fileMenu.add(lastUsed2MenuItem);\r\n    lastUsed3MenuItem.setText(getWorkbenchProperty(\"lastUsed3\"));\r\n    lastUsed3MenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            lastUsed3MenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    fileMenu.add(lastUsed3MenuItem);\r\n    lastUsed4MenuItem.setText(getWorkbenchProperty(\"lastUsed4\"));\r\n    lastUsed4MenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            lastUsed4MenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    fileMenu.add(lastUsed4MenuItem);\r\n    updateLastUsedMenu();\r\n    fileMenu.add(jSeparator1);\r\n    exitMenuItem.setText(getResourceConverter().getString(\"workbench.menu.exit\", \"Exit\"));\r\n    exitMenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            exitMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    fileMenu.add(exitMenuItem);\r\n    menuBar.add(fileMenu);\r\n    editMenu.setText(getResourceConverter().getString(\"workbench.menu.edit\", \"Edit\"));\r\n    editMenu.setMnemonic(KeyEvent.VK_E);\r\n    cutMenuItem.setText(getResourceConverter().getString(\"workbench.menu.cut\", \"Cut\"));\r\n    editMenu.add(cutMenuItem);\r\n    copyMenuItem.setText(getResourceConverter().getString(\"workbench.menu.copy\", \"Copy\"));\r\n    editMenu.add(copyMenuItem);\r\n    pasteMenuItem.setText(getResourceConverter().getString(\"workbench.menu.paste\", \"Paste\"));\r\n    editMenu.add(pasteMenuItem);\r\n    editMenu.add(deleteMenuItem);\r\n    menuBar.add(editMenu);\r\n    viewMenu.setText(getResourceConverter().getString(\"workbench.menu.view\", \"View\"));\r\n    viewMenu.setMnemonic(KeyEvent.VK_V);\r\n    viewXmlMenuItem.setText(getResourceConverter().getString(\"workbench.menu.viewXML\", \"View XML\"));\r\n    viewXmlMenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            viewXMLMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    viewMenu.add(viewXmlMenuItem);\r\n    menuBar.add(viewMenu);\r\n    toolsMenu.setText(getResourceConverter().getString(\"workbench.menu.options\", \"Options\"));\r\n    toolsMenu.setMnemonic(KeyEvent.VK_O);\r\n    preferencesMenuItem.setText(getResourceConverter().getString(\"workbench.menu.connection\", \"Connection\"));\r\n    preferencesMenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            connectionButtonActionPerformed(evt);\r\n        }\r\n    });\r\n    toolsMenu.add(preferencesMenuItem);\r\n    requireSchemaCheckboxMenuItem.setText(getResourceConverter().getString(\"workbench.menu.requireSchema\", \"Require Schema\"));\r\n    requireSchemaCheckboxMenuItem.setSelected(requireSchema);\r\n    requireSchemaCheckboxMenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            requireSchemaActionPerformed(e);\r\n        }\r\n    });\r\n    toolsMenu.add(requireSchemaCheckboxMenuItem);\r\n    menuBar.add(toolsMenu);\r\n    windowMenu.setText(getResourceConverter().getString(\"workbench.menu.windows\", \"Windows\"));\r\n    windowMenu.setMnemonic(KeyEvent.VK_W);\r\n    cascadeMenuItem = new javax.swing.JMenuItem();\r\n    cascadeMenuItem.setText(getResourceConverter().getString(\"workbench.menu.cascadeWindows\", \"Cascade Windows\"));\r\n    cascadeMenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            cascadeMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    tileMenuItem = new javax.swing.JMenuItem();\r\n    tileMenuItem.setText(getResourceConverter().getString(\"workbench.menu.tileWindows\", \"Tile Windows\"));\r\n    tileMenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            tileMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    closeAllMenuItem = new javax.swing.JMenuItem();\r\n    closeAllMenuItem.setText(getResourceConverter().getString(\"workbench.menu.closeAll\", \"Close All\"));\r\n    closeAllMenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            closeAllMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    minimizeMenuItem = new javax.swing.JMenuItem();\r\n    minimizeMenuItem.setText(getResourceConverter().getString(\"workbench.menu.minimizeAll\", \"Minimize All\"));\r\n    minimizeMenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            minimizeMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    maximizeMenuItem = new javax.swing.JMenuItem();\r\n    maximizeMenuItem.setText(getResourceConverter().getString(\"workbench.menu.maximizeAll\", \"Maximize All\"));\r\n    maximizeMenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            maximizeMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    menuBar.add(windowMenu);\r\n    aboutMenuItem.setText(getResourceConverter().getString(\"workbench.menu.about\", \"About\"));\r\n    aboutMenuItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            aboutMenuItemActionPerformed(evt);\r\n        }\r\n    });\r\n    helpMenu.add(aboutMenuItem);\r\n    helpMenu.setText(getResourceConverter().getString(\"workbench.menu.help\", \"Help\"));\r\n    helpMenu.setMnemonic(KeyEvent.VK_H);\r\n    menuBar.add(helpMenu);\r\n    setJMenuBar(menuBar);\r\n    pack();\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    JInternalFrame jf = desktopPane.getSelectedFrame();\r\n    if (jf != null && jf.getContentPane().getComponent(0) instanceof SchemaExplorer) {\r\n        SchemaExplorer se = (SchemaExplorer) jf.getContentPane().getComponent(0);\r\n        TreePath tpath = se.tree.getSelectionPath();\r\n        se.delete(tpath);\r\n    }\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    storeWorkbenchProperties();\r\n    storeDatabaseMeta();\r\n    closeAllSchemaFrames(true);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    newSchemaMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    newQueryMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    newJDBCExplorerMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    toolbarNewPopupMenu.show(jPanel2, 0, jPanel2.getSize().height);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    toolbarNewPopupMenu.show(jPanel2, 0, jPanel2.getSize().height);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    openMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    saveMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    saveAsMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    connectionButtonActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    newSchemaMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    newQueryMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    newJDBCExplorerMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    openMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    saveMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    saveAsMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    lastUsed1MenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    lastUsed2MenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    lastUsed3MenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    lastUsed4MenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    exitMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    viewXMLMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    connectionButtonActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    requireSchemaActionPerformed(e);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    cascadeMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    tileMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    closeAllMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    minimizeMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    maximizeMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.gui.Workbench.initComponents",
	"Comment": "this method is called from within the constructor toinitialize the form.",
	"Method": "void initComponents(){\r\n    aboutMenuItemActionPerformed(evt);\r\n}"
}, {
	"Path": "mondrian.util.MemoryMonitorTest._testQuery",
	"Comment": "run this by itself and it works across 2 orders of magnitude.run it with other tests and its hard to pick the rightvalues for the percentage and how much to allocate for itto always work.",
	"Method": "void _testQuery(){\r\n    if (!enabled) {\r\n        return;\r\n    }\r\n    class Listener implements MemoryMonitor.Listener {\r\n        boolean wasNotified = false;\r\n        Listener() {\r\n        }\r\n        public void memoryUsageNotification(long used, long max) {\r\n            wasNotified = true;\r\n        }\r\n    }\r\n    Listener listener = new Listener();\r\n    final String queryString = \"select \\n\" + \"{ \\n\" + \"[Measures].[Store Sales], \\n\" + \"[Measures].[Sales Count], \\n\" + \"[Measures].[Customer Count] \\n\" + \"} \\n\" + \"ON COLUMNS, \\n\" + \"Crossjoin(\\n\" + \"  Descendants([Store].[All Stores]), \\n\" + \"  Descendants([Product].[All Products]) \\n\" + \") \\n\" + \"ON ROWS \\n\" + \"from [Sales]\";\r\n    List<Result> list = new ArrayList<Result>();\r\n    MemoryMonitor mm = null;\r\n    try {\r\n        MemoryMonitorFactory.setThreadLocalClassName(TestMM.class.getName());\r\n        mm = MemoryMonitorFactory.getMemoryMonitor();\r\n        boolean b = causeGC(mm);\r\n        long neededMemory = 5000000;\r\n        long maxMemory = mm.getMaxMemory();\r\n        long usedMemory = mm.getUsedMemory();\r\n        long tenPercentMaxMemory = maxMemory / 10;\r\n        long level = maxMemory - tenPercentMaxMemory;\r\n        long buf;\r\n        if (level > usedMemory) {\r\n            buf = level - usedMemory - neededMemory;\r\n            if (buf <= 0) {\r\n                buf = level - usedMemory;\r\n            }\r\n            THRESHOLD_PERCENTAGE = 90;\r\n        } else {\r\n            buf = 0;\r\n            double dp = (100.0 * (maxMemory - usedMemory)) / maxMemory;\r\n            THRESHOLD_PERCENTAGE = 100 - (int) Math.ceil(dp);\r\n        }\r\n        byte[] bytes = new byte[(int) ((buf > 0) ? buf : 0)];\r\n        mm.addListener(listener);\r\n        if (listener.wasNotified) {\r\n            return;\r\n        }\r\n        Connection conn = getConnection();\r\n        final int MAX = 100;\r\n        for (int i = 0; i < MAX; i++) {\r\n            Query query = conn.parseQuery(queryString);\r\n            query.setResultStyle(ResultStyle.MUTABLE_LIST);\r\n            Result result = conn.execute(query);\r\n            list.add(result);\r\n            if (listener.wasNotified) {\r\n                break;\r\n            }\r\n        }\r\n        fail(\"Memory Notification Exception did not occur\");\r\n    } catch (MemoryLimitExceededException ex) {\r\n        if (!listener.wasNotified) {\r\n            fail(\"Listener callback not called\");\r\n        }\r\n    } finally {\r\n        if (mm != null) {\r\n            mm.removeListener(listener);\r\n        }\r\n        for (Result result : list) {\r\n            result.close();\r\n        }\r\n        MemoryMonitorFactory.clearThreadLocalClassName();\r\n    }\r\n}"
}, {
	"Path": "mondrian.util.MemoryMonitorTest._testQuery",
	"Comment": "run this by itself and it works across 2 orders of magnitude.run it with other tests and its hard to pick the rightvalues for the percentage and how much to allocate for itto always work.",
	"Method": "void _testQuery(){\r\n    wasNotified = true;\r\n}"
}, {
	"Path": "org.mapsforge.map.rendertheme.rule.RenderTheme.matchLinearWay",
	"Comment": "matches a linear way with the given parameters against this rendertheme.",
	"Method": "void matchLinearWay(RenderCallback renderCallback,RenderContext renderContext,PolylineContainer way){\r\n    matchWay(renderCallback, renderContext, Closed.NO, way);\r\n}"
}, {
	"Path": "mondrian.rolap.FastBatchingCellReaderTest.testCanBatchForSuperSet",
	"Comment": "tests that can batch for batch with super set of contraintcolumn bit key and all values for additional condition.",
	"Method": "void testCanBatchForSuperSet(){\r\n    final BatchLoader fbcr = createFbcr(null, salesCube);\r\n    BatchLoader.Batch aggregationBatch = createBatch(fbcr, new String[] { tableTime, tableProductClass, tableProductClass }, new String[] { fieldYear, fieldProductFamily, fieldProductDepartment }, new String[][] { fieldValuesYear, fieldValuesProductFamily, fieldValueProductDepartment }, cubeNameSales, measureUnitSales);\r\n    BatchLoader.Batch detailedBatch = createBatch(fbcr, new String[] { tableTime, tableProductClass, tableProductClass, tableCustomer }, new String[] { fieldYear, fieldProductFamily, fieldProductDepartment, fieldGender }, new String[][] { fieldValuesYear, fieldValuesProductFamily, fieldValueProductDepartment, fieldValuesGender }, cubeNameSales, measureUnitSales);\r\n    assertTrue(detailedBatch.canBatch(aggregationBatch));\r\n    assertFalse(aggregationBatch.canBatch(detailedBatch));\r\n}"
}, {
	"Path": "mondrian.test.UdfTest.measureTestContext",
	"Comment": "shorthand for containing a test context that consists of the standardfoodmart sales cube plus one measure.",
	"Method": "TestContext measureTestContext(String xmlMeasure){\r\n    return TestContext.instance().createSubstitutingCube(\"Sales\", null, xmlMeasure, null, null);\r\n}"
}, {
	"Path": "mondrian.olap.Property.isMemberProperty",
	"Comment": "returns whether this property is a standard member property.",
	"Method": "boolean isMemberProperty(){\r\n    return member;\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.getParameterNames",
	"Comment": "returns an enumeration of string objects containing the names of theparameters contained in this request.",
	"Method": "Enumeration getParameterNames(){\r\n    return Collections.enumeration(parameters.keySet());\r\n}"
}, {
	"Path": "mondrian.rolap.RolapConnection.getId",
	"Comment": "returns the identifier of this connection. unique within the lifetime ofthis jvm.",
	"Method": "int getId(){\r\n    return id;\r\n}"
}, {
	"Path": "mondrian.test.CacheHitTest.runTestSuiteInOrder",
	"Comment": "loops numite times, each time run all child testsuite in the suite",
	"Method": "void runTestSuiteInOrder(TestSuite suite,int numIter){\r\n    final TestResult tres = new TestResult();\r\n    final MondrianServer server = MondrianServer.forConnection(getTestContext().getConnection());\r\n    for (int i = 0; i < numIter; i++) {\r\n        TestSuite test = (TestSuite) suite.testAt(i % suite.testCount());\r\n        for (int j = 0; j < test.testCount(); j++) {\r\n            test.testAt(j).run(tres);\r\n        }\r\n    }\r\n    report(server.getMonitor().getServer());\r\n}"
}, {
	"Path": "mondrian.test.ScenarioTest.testUnsupportedAllocationPolicyFails",
	"Comment": "tests that allocation policies that are not supported give an error.",
	"Method": "void testUnsupportedAllocationPolicyFails(){\r\n    final TestContext testContext = TestContext.instance().withScenario();\r\n    final OlapConnection connection = testContext.getOlap4jConnection();\r\n    final PreparedOlapStatement pstmt = connection.prepareOlapStatement(\"select {[Measures].[Unit Sales]} on 0,\\n\" + \"{[Product].Children} on 1\\n\" + \"from [Sales]\");\r\n    final CellSet cellSet = pstmt.executeQuery();\r\n    final Cell cell = cellSet.getCell(Arrays.asList(0, 1));\r\n    for (AllocationPolicy policy : AllocationPolicy.values()) {\r\n        switch(policy) {\r\n            case EQUAL_ALLOCATION:\r\n            case EQUAL_INCREMENT:\r\n                continue;\r\n        }\r\n        try {\r\n            cell.setValue(123, policy);\r\n            fail(\"expected error\");\r\n        } catch (RuntimeException e) {\r\n            TestContext.checkThrowable(e, \"Allocation policy \" + policy + \" is not supported\");\r\n        }\r\n    }\r\n    try {\r\n        cell.setValue(123, null);\r\n        fail(\"expected error\");\r\n    } catch (RuntimeException e) {\r\n        TestContext.checkThrowable(e, \"Allocation policy must not be null\");\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.SqlTupleReader.resetCurrMembers",
	"Comment": "sets the current member for those targets that retrieve their columnvalues from native sql",
	"Method": "void resetCurrMembers(List<RolapMember> partialRow){\r\n    int nativeTarget = 0;\r\n    for (TargetBase target : targets) {\r\n        if (target.srcMembers == null) {\r\n            if (partialRow != null) {\r\n                target.setCurrMember(partialRow.get(nativeTarget++));\r\n            } else {\r\n                target.setCurrMember(null);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "mondrian.olap.CubeAccess.addGrantCubeSlicer",
	"Comment": "addsrestricted hierarchy or limited member based on bmember",
	"Method": "void addGrantCubeSlicer(String sHierarchy,String sMember,boolean bMember){\r\n    if (bMember) {\r\n        boolean fail = false;\r\n        List<Id.Segment> sMembers = Util.parseIdentifier(sMember);\r\n        SchemaReader schemaReader = mdxCube.getSchemaReader(null);\r\n        Member member = schemaReader.getMemberByUniqueName(sMembers, fail);\r\n        if (member == null) {\r\n            throw MondrianResource.instance().MdxCubeSlicerMemberError.ex(sMember, sHierarchy, mdxCube.getUniqueName());\r\n        }\r\n        if (getLimitedMemberForHierarchy(member.getHierarchy()) == null) {\r\n            memberList.add(member);\r\n        }\r\n    } else {\r\n        boolean fail = false;\r\n        Hierarchy hierarchy = mdxCube.lookupHierarchy(new Id.NameSegment(sHierarchy), fail);\r\n        if (hierarchy == null) {\r\n            throw MondrianResource.instance().MdxCubeSlicerHierarchyError.ex(sHierarchy, mdxCube.getUniqueName());\r\n        }\r\n        hierarchyList.add(hierarchy);\r\n    }\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Caption.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Caption appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.rolap.agg.CellRequest.getNumValues",
	"Comment": "return the number of column constraints associated with this cellrequest.",
	"Method": "int getNumValues(){\r\n    check();\r\n    return numColumns;\r\n}"
}, {
	"Path": "org.mapsforge.map.writer.util.GeoUtils.simplifyGeometry",
	"Comment": "simplifies a geometry using the douglas peucker algorithm.",
	"Method": "Geometry simplifyGeometry(TDWay way,Geometry geometry,byte zoomlevel,int tileSize,double simplificationFactor){\r\n    Geometry ret = null;\r\n    Envelope bbox = geometry.getEnvelopeInternal();\r\n    double latMax = Math.max(Math.abs(bbox.getMaxY()), Math.abs(bbox.getMinY()));\r\n    double deltaLat = deltaLat(simplificationFactor, latMax, zoomlevel, tileSize);\r\n    try {\r\n        ret = TopologyPreservingSimplifier.simplify(geometry, deltaLat);\r\n    } catch (TopologyException e) {\r\n        LOGGER.log(Level.FINE, \"JTS cannot simplify way due to an error, not simplifying way with id: \" + way.getId(), e);\r\n        way.setInvalid(true);\r\n        return geometry;\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.mapsforge.core.util.LatLongUtils.longitudeDistance",
	"Comment": "calculates the amount of degrees of longitude for a given distance in meters.",
	"Method": "double longitudeDistance(int meters,double latitude){\r\n    return (meters * 360) / (2 * Math.PI * EQUATORIAL_RADIUS * Math.cos(Math.toRadians(latitude)));\r\n}"
}, {
	"Path": "org.mapsforge.map.layer.Layer.getPosition",
	"Comment": "gets the geographic position of this layer element, if it exists.the default implementation of this method returns null.",
	"Method": "LatLong getPosition(){\r\n    return null;\r\n}"
}, {
	"Path": "mondrian.rolap.MemberCacheControlTest.findMember",
	"Comment": "finds a member by its name and the name of its containing cube.",
	"Method": "RolapMember findMember(TestContext tc,String cubeName,String names){\r\n    Cube cube = tc.getConnection().getSchema().lookupCube(cubeName, true);\r\n    SchemaReader scr = cube.getSchemaReader(null).withLocus();\r\n    return (RolapMember) scr.getMemberByUniqueName(Id.Segment.toList(names), true);\r\n}"
}, {
	"Path": "mondrian.olap.QueryPart.explain",
	"Comment": "returns the plan that mondrian intends to use to execute this query.",
	"Method": "void explain(PrintWriter pw){\r\n    throw new UnsupportedOperationException(\"explain not implemented for \" + this + \" (\" + getClass() + \")\");\r\n}"
}, {
	"Path": "mondrian.olap.type.TypeUtil.toMemberType",
	"Comment": "converts a type to a member type.if it is a set, strips the set.if it is a member type, returns the type unchanged.if it is a dimension, hierarchy or level type, converts it toa member type.if it is a tuple, number, string, or boolean, returns null.",
	"Method": "MemberType toMemberType(Type type){\r\n    type = stripSetType(type);\r\n    if (type instanceof MemberType) {\r\n        return (MemberType) type;\r\n    } else if (type instanceof DimensionType || type instanceof HierarchyType || type instanceof LevelType) {\r\n        return MemberType.forType(type);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.mapsforge.samples.android.cluster.Cluster.clear",
	"Comment": "clears cluster object and removes the cluster from the layers collection.",
	"Method": "void clear(){\r\n    if (clusterMarker != null) {\r\n        Layers mapOverlays = clusterManager.getMapView().getLayerManager().getLayers();\r\n        if (mapOverlays.contains(clusterMarker)) {\r\n            mapOverlays.remove(clusterMarker);\r\n        }\r\n        clusterManager = null;\r\n        clusterMarker = null;\r\n    }\r\n    synchronized (items) {\r\n        items.clear();\r\n    }\r\n}"
}, {
	"Path": "mondrian.rolap.SqlMemberSource.addAsOldestSibling",
	"Comment": "adds member just before the first element inlist which has the same parent.",
	"Method": "void addAsOldestSibling(List<RolapMember> list,RolapMember member){\r\n    int i = list.size();\r\n    while (--i >= 0) {\r\n        RolapMember sibling = list.get(i);\r\n        if (sibling.getParentMember() != member.getParentMember()) {\r\n            break;\r\n        }\r\n    }\r\n    list.add(i + 1, member);\r\n}"
}, {
	"Path": "com.hp.gagawa.java.elements.Noframes.appendText",
	"Comment": "convenience method which appends a text node to this element",
	"Method": "Noframes appendText(String text){\r\n    return appendChild(new Text(text));\r\n}"
}, {
	"Path": "mondrian.test.SchemaTest.testAllMemberMultipleDimensionUsages",
	"Comment": "test to verify naming of all member withdimension usage name is different then source name",
	"Method": "void testAllMemberMultipleDimensionUsages(){\r\n    final TestContext testContext = TestContext.instance().create(null, \"<Cube name=\\\"Sales Two Sales Dimensions\\\">\\n\" + \"  <Table name=\\\"sales_fact_1997\\\"/>\\n\" + \"  <DimensionUsage name=\\\"Store\\\" caption=\\\"First Store\\\" source=\\\"Store\\\" foreignKey=\\\"store_id\\\"/>\\n\" + \"  <DimensionUsage name=\\\"Store2\\\" caption=\\\"Second Store\\\" source=\\\"Store\\\" foreignKey=\\\"product_id\\\"/>\\n\" + \"  <Measure name=\\\"Unit Sales\\\" column=\\\"unit_sales\\\" aggregator=\\\"sum\\\" \" + \"   formatString=\\\"Standard\\\"/>\\n\" + \"  <Measure name=\\\"Store Cost\\\" column=\\\"store_cost\\\" aggregator=\\\"sum\\\"\" + \"   formatString=\\\"#,###.00\\\"/>\\n\" + \"<\/Cube>\", null, null, null, null);\r\n    final String store2AllMember = MondrianProperties.instance().SsasCompatibleNaming.get() ? \"[Store2].[All Stores]\" : \"[Store2].[All Store2s]\";\r\n    testContext.assertQueryReturns(\"select\\n\" + \" {[Store].[Store].[All Stores]} on columns,\\n\" + \" {\" + store2AllMember + \"} on rows\\n\" + \"From [Sales Two Sales Dimensions]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Store].[All Stores]}\\n\" + \"Axis #2:\\n\" + \"{[Store2].[Store].[All Stores]}\\n\" + \"Row #0: 266,773\\n\");\r\n    final Result result = testContext.executeQuery(\"select ([Store].[All Stores], \" + store2AllMember + \") on 0\\n\" + \"from [Sales Two Sales Dimensions]\");\r\n    final Axis axis = result.getAxes()[0];\r\n    final Position position = axis.getPositions().get(0);\r\n    assertEquals(\"First Store\", position.get(0).getDimension().getCaption());\r\n    assertEquals(\"Second Store\", position.get(1).getDimension().getCaption());\r\n}"
}, {
	"Path": "org.mapsforge.map.model.DisplayModel.setTileSizeMultiple",
	"Comment": "clamps the tile size to a multiple of the supplied value.the default value of tilesizemultiple will be overwritten with this call.the default value should be good enough for most applications and settingthis value should rarely be required.applications that allow external renderthemes might negatively impacttheir layout as area fills may depend on the default value being used.",
	"Method": "void setTileSizeMultiple(int multiple){\r\n    this.tileSizeMultiple = multiple;\r\n    setTileSize();\r\n}"
}, {
	"Path": "mondrian.rolap.FilterTest.testNotInMultiLevelMemberConstraintNonNullSameParent",
	"Comment": "test that null members are included when the filter excludes membersthat contain multiple levels, but none being null.the members havethe same parent.",
	"Method": "void testNotInMultiLevelMemberConstraintNonNullSameParent(){\r\n    if (MondrianProperties.instance().ReadAggregates.get()) {\r\n        return;\r\n    }\r\n    String query = \"With \" + \"Set [*NATIVE_CJ_SET] as 'NonEmptyCrossJoin([*BASE_MEMBERS_Customers],[*BASE_MEMBERS_Quarters])' \" + \"Set [*BASE_MEMBERS_Customers] as 'Filter([Customers].[Country].Members, [Customers].CurrentMember In {[Customers].[All Customers].[USA]})' \" + \"Set [*BASE_MEMBERS_Quarters] as 'Filter([Time].[Quarter].Members, \" + \"[Time].currentMember not in {[Time].[1997].[Q1], [Time].[1997].[Q3]})' \" + \"Set [*CJ_ROW_AXIS] as 'Generate([*NATIVE_CJ_SET], {([Customers].currentMember,[Time].currentMember)})' \" + \"Set [*ORDERED_CJ_ROW_AXIS] as 'Order([*CJ_ROW_AXIS], [Time].currentmember.OrderKey, BASC)' \" + \"Select \" + \"{[Measures].[Customer Count]} on columns, \" + \"Non Empty [*ORDERED_CJ_ROW_AXIS] on rows \" + \"From [Sales]\";\r\n    String necjSqlDerby = \"select \\\"customer\\\".\\\"country\\\", \\\"time_by_day\\\".\\\"the_year\\\", \" + \"\\\"time_by_day\\\".\\\"quarter\\\" from \\\"customer\\\" as \\\"customer\\\", \" + \"\\\"sales_fact_1997\\\" as \\\"sales_fact_1997\\\", \\\"time_by_day\\\" as \" + \"\\\"time_by_day\\\" where \\\"sales_fact_1997\\\".\\\"customer_id\\\" = \" + \"\\\"customer\\\".\\\"customer_id\\\" and \\\"sales_fact_1997\\\".\\\"time_id\\\" = \" + \"\\\"time_by_day\\\".\\\"time_id\\\" and (\\\"customer\\\".\\\"country\\\" = 'USA') and \" + \"((not (\\\"time_by_day\\\".\\\"quarter\\\" in ('Q1', 'Q3')) or \" + \"(\\\"time_by_day\\\".\\\"quarter\\\" is null)) or (not \" + \"(\\\"time_by_day\\\".\\\"the_year\\\" = 1997) or (\\\"time_by_day\\\".\\\"the_year\\\" is \" + \"null))) group by \\\"customer\\\".\\\"country\\\", \\\"time_by_day\\\".\\\"the_year\\\", \" + \"\\\"time_by_day\\\".\\\"quarter\\\" \" + \"order by CASE WHEN \\\"customer\\\".\\\"country\\\" IS NULL THEN 1 ELSE 0 END, \\\"customer\\\".\\\"country\\\" ASC, CASE WHEN \\\"time_by_day\\\".\\\"the_year\\\" IS NULL THEN 1 ELSE 0 END, \\\"time_by_day\\\".\\\"the_year\\\" ASC, CASE WHEN \\\"time_by_day\\\".\\\"quarter\\\" IS NULL THEN 1 ELSE 0 END, \\\"time_by_day\\\".\\\"quarter\\\" ASC\";\r\n    String necjSqlMySql = \"select `customer`.`country` as `c0`, `time_by_day`.`the_year` as \" + \"`c1`, `time_by_day`.`quarter` as `c2` from `customer` as \" + \"`customer`, `sales_fact_1997` as `sales_fact_1997`, `time_by_day` \" + \"as `time_by_day` where `sales_fact_1997`.`customer_id` = \" + \"`customer`.`customer_id` and `sales_fact_1997`.`time_id` = \" + \"`time_by_day`.`time_id` and (`customer`.`country` = 'USA') and \" + \"((not (`time_by_day`.`quarter` in ('Q1', 'Q3')) or \" + \"(`time_by_day`.`quarter` is null)) or (not \" + \"(`time_by_day`.`the_year` = 1997) or (`time_by_day`.`the_year` \" + \"is null))) group by `customer`.`country`, `time_by_day`.`the_year`, `time_by_day`.`quarter` \" + (TestContext.instance().getDialect().requiresOrderByAlias() ? \"order by ISNULL(`c0`) ASC, \" + \"`c0` ASC, ISNULL(`c1`) ASC, \" + \"`c1` ASC, ISNULL(`c2`) ASC, \" + \"`c2` ASC\" : \"order by ISNULL(`customer`.`country`) ASC, \" + \"`customer`.`country` ASC, ISNULL(`time_by_day`.`the_year`) ASC, \" + \"`time_by_day`.`the_year` ASC, ISNULL(`time_by_day`.`quarter`) ASC, \" + \"`time_by_day`.`quarter` ASC\");\r\n    SqlPattern[] patterns = { new SqlPattern(Dialect.DatabaseProduct.DERBY, necjSqlDerby, necjSqlDerby), new SqlPattern(Dialect.DatabaseProduct.MYSQL, necjSqlMySql, necjSqlMySql) };\r\n    assertQuerySql(query, patterns);\r\n}"
}, {
	"Path": "org.mapsforge.map.rendertheme.rule.RenderTheme.matchNode",
	"Comment": "matches a node with the given parameters against this rendertheme.",
	"Method": "void matchNode(RenderCallback renderCallback,RenderContext renderContext,PointOfInterest poi){\r\n    MatchingCacheKey matchingCacheKey = new MatchingCacheKey(poi.tags, renderContext.rendererJob.tile.zoomLevel, Closed.NO);\r\n    List<RenderInstruction> matchingList = this.poiMatchingCache.get(matchingCacheKey);\r\n    if (matchingList != null) {\r\n        for (int i = 0, n = matchingList.size(); i < n; ++i) {\r\n            matchingList.get(i).renderNode(renderCallback, renderContext, poi);\r\n        }\r\n        return;\r\n    }\r\n    matchingList = new ArrayList<RenderInstruction>();\r\n    for (int i = 0, n = this.rulesList.size(); i < n; ++i) {\r\n        this.rulesList.get(i).matchNode(renderCallback, renderContext, matchingList, poi);\r\n    }\r\n    this.poiMatchingCache.put(matchingCacheKey, matchingList);\r\n}"
}, {
	"Path": "mondrian.tui.MockHttpServletRequest.isRequestedSessionIdFromURL",
	"Comment": "checks whether the requested session id came in as part of the request url.",
	"Method": "boolean isRequestedSessionIdFromURL(){\r\n    return !requestedSessionIdIsFromCookie;\r\n}"
}, {
	"Path": "com.mpatric.mp3agic.ID3v1Genres.matchGenreDescription",
	"Comment": "match provided description against genres, ignoring case.",
	"Method": "int matchGenreDescription(String description){\r\n    if (description != null && description.length() > 0) {\r\n        for (int i = 0; i < ID3v1Genres.GENRES.length; i++) {\r\n            if (ID3v1Genres.GENRES[i].equalsIgnoreCase(description)) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.sqlite.database.sqlite.SQLiteConnection.describeCurrentOperationUnsafe",
	"Comment": "describes the currently executing operation, in the case where thecaller might not actually own the connection.this function is written so that it may be called by a thread that does notown the connection.we need to be very careful because the connection state isnot synchronized.at worst, the method may return stale or slightly wrong data, howeverit should not crash.this is ok as it is only used for diagnostic purposes.",
	"Method": "String describeCurrentOperationUnsafe(){\r\n    return mRecentOperations.describeCurrentOperation();\r\n}"
}, {
	"Path": "mondrian.rolap.RolapMemberBaseTest.testShouldReturnCaptionValueIfPresent",
	"Comment": "given rolap member with caption value specified.when caption raw value is requested,then the caption value should be returned.",
	"Method": "void testShouldReturnCaptionValueIfPresent(){\r\n    rolapMemberBase.setCaptionValue(Integer.MIN_VALUE);\r\n    Object captionValue = rolapMemberBase.getCaptionValue();\r\n    assertNotNull(captionValue);\r\n    assertEquals(Integer.MIN_VALUE, captionValue);\r\n}"
}, {
	"Path": "mondrian.test.BasicQueryTest.testFormatStringAppliedToStringValue",
	"Comment": "test format string values. previously, a bug meant that string valueswere printed as is, never passed through the format string.",
	"Method": "void testFormatStringAppliedToStringValue(){\r\n    assertQueryReturns(\"with member [Measures].[Test] as '23', FORMAT_STRING = '|<|arrow=\\\"up\\\"'\\n\" + \"select [Measures].[Test] on 0\\n\" + \"from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Test]}\\n\" + \"Row #0: |23|arrow=up\\n\");\r\n    assertQueryReturns(\"with member [Measures].[Test] as '\\\"23\\\"', FORMAT_STRING = '|<|arrow=\\\"up\\\"'\\n\" + \"select [Measures].[Test] on 0\\n\" + \"from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Test]}\\n\" + \"Row #0: |23|arrow=up\\n\");\r\n    assertQueryReturns(\"with member [Measures].[Test] as '\\\"Foo \\\" || \\\"Bar\\\"', FORMAT_STRING = '|<|arrow=\\\"up\\\"'\\n\" + \"select [Measures].[Test] on 0\\n\" + \"from [Sales]\", \"Axis #0:\\n\" + \"{}\\n\" + \"Axis #1:\\n\" + \"{[Measures].[Test]}\\n\" + \"Row #0: |foo bar|arrow=up\\n\");\r\n}"
}, {
	"Path": "mondrian.test.UdfTest.testScriptUdfInvalid",
	"Comment": "unit test that we get a nice error if a script udf contains an error.",
	"Method": "void testScriptUdfInvalid(){\r\n    TestContext tc = udfTestContext(\"<UserDefinedFunction name='Factorial'>\\n\" + \"  <Script language='JavaScript'><![CDATA[\\n\" + \"    function getParameterTypes() {\\n\" + \"      return new Array(\\n\" + \"        new mondrian.olap.type.NumericType());\\n\" + \"    }\\n\" + \"    function getReturnType(parameterTypes) {\\n\" + \"      return new mondrian.olap.type.NumericType();\\n\" + \"    }\\n\" + \"    function execute(evaluator, arguments) {\\n\" + \"      var n = arguments[0].evaluateScalar(evaluator);\\n\" + \"      return factorial(n);\\n\" + \"    }\\n\" + \"    function factorial(n) {\\n\" + \"      return n <= 1 ? 1 : n * factorial_xx(n - 1);\\n\" + \"    }\\n\" + \"  ]]>\\n\" + \"  <\/Script>\\n\" + \"<\/UserDefinedFunction>\\n\");\r\n    final Cell cell = tc.executeExprRaw(\"Factorial(4 + 2)\");\r\n    getTestContext().assertMatchesVerbose(Pattern.compile(\"(?s).*ReferenceError: \\\"factorial_xx\\\" is not defined..*\"), cell.getValue().toString());\r\n}"
}, {
	"Path": "mondrian.util.Schedule.createWeekly",
	"Comment": "creates a calendar which fires on particular days each week.",
	"Method": "Schedule createWeekly(Date begin,Date end,TimeZone tz,Time timeOfDay,int period,int daysOfWeekBitmap){\r\n    DateSchedule dateSchedule = new WeeklyDateSchedule(begin == null ? null : ScheduleUtil.createCalendar(begin), period, daysOfWeekBitmap);\r\n    return new Schedule(dateSchedule, new OnceTimeSchedule(ScheduleUtil.createTimeCalendar(timeOfDay)), tz, begin, end);\r\n}"
}, {
	"Path": "mondrian.test.DynamicSchemaProcessorTest.testDSPBasics",
	"Comment": "tests to make sure that our base dynamicschemaprocessor works, with noreplacement. does not test mondrian is able to connect with the schemadefinition.",
	"Method": "void testDSPBasics(){\r\n    DynamicSchemaProcessor dsp = new BaseDsp();\r\n    Util.PropertyList dummy = new Util.PropertyList();\r\n    String processedSchema = \"\";\r\n    try {\r\n        processedSchema = dsp.processSchema(\"\", dummy);\r\n    } catch (Exception e) {\r\n        assertEquals(0, 1);\r\n    }\r\n    Assert.assertEquals(TEMPLATE_SCHEMA, processedSchema);\r\n}"
}, {
	"Path": "mondrian.olap.type.TypeUtil.toMemberOrTupleType",
	"Comment": "converts a type to a member or tuple type.if it cannot, returns null.",
	"Method": "Type toMemberOrTupleType(Type type){\r\n    type = stripSetType(type);\r\n    if (type instanceof TupleType) {\r\n        return type;\r\n    } else {\r\n        return toMemberType(type);\r\n    }\r\n}"
}]