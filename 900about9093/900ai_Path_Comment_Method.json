[{
	"Path": "org.openhab.binding.powermax.internal.state.PowermaxPanelSettings.helpItems",
	"Comment": "log help information relative to items and sitemap entries to be created",
	"Method": "void helpItems(){\r\n    int zoneCnt = panelType.getWireless() + panelType.getWired();\r\n    String items = \"Help for defining items:\\n\" + \"\\nGroup GPowermax \\\"Alarm\\\"\" + \"\\nString Powermax_partition_status \\\"Partition status [%s]\\\" (GPowermax) {powermax=\\\"partition_status\\\"}\" + \"\\nSwitch Powermax_partition_ready \\\"Partition ready\\\" (GPowermax) {powermax=\\\"partition_ready\\\", autoupdate=\\\"false\\\"}\" + \"\\nSwitch Powermax_partition_bypass \\\"Partition bypass\\\" (GPowermax) {powermax=\\\"partition_bypass\\\", autoupdate=\\\"false\\\"}\" + \"\\nSwitch Powermax_partition_alarm \\\"Partition alarm\\\" (GPowermax) {powermax=\\\"partition_alarm\\\", autoupdate=\\\"false\\\"}\" + \"\\nSwitch Powermax_panel_trouble \\\"Panel trouble\\\" (GPowermax) {powermax=\\\"panel_trouble\\\", autoupdate=\\\"false\\\"}\" + \"\\nSwitch Powermax_panel_alert_in_mem \\\"Panel alert in memory\\\" (GPowermax) {powermax=\\\"panel_alert_in_memory\\\", autoupdate=\\\"false\\\"}\" + \"\\nSwitch Powermax_partition_armed \\\"Partition armed\\\" (GPowermax) {powermax=\\\"partition_armed\\\", autoupdate=\\\"false\\\"}\" + \"\\nString Powermax_partition_arm_mode \\\"Partition arm mode [%s]\\\" (GPowermax) {powermax=\\\"partition_arm_mode\\\", autoupdate=\\\"false\\\"}\";\r\n    String sitemap = \"Help for defining sitemap:\\n\" + \"\\nText label=\\\"Security\\\" icon=\\\"lock\\\" {\" + \"\\nSwitch item=Powermax_partition_armed mappings=[OFF=\\\"Disarmed\\\", ON=\\\"Armed\\\"]\" + \"\\nSwitch item=Powermax_partition_arm_mode mappings=[Disarmed=\\\"Disarmed\\\", Stay=\\\"Armed home\\\", Armed=\\\"Armed away\\\"] valuecolor=[==\\\"Armed\\\"=\\\"green\\\",==\\\"Stay\\\"=\\\"orange\\\"]\" + \"\\nSwitch item=Powermax_command mappings=[get_event_log=\\\"Event log\\\", download_setup=\\\"Get setup\\\", log_setup=\\\"Log setup\\\", help_items=\\\"Help items\\\"]\";\r\n    for (int i = 1; i <= zoneCnt; i++) {\r\n        if (zoneSettings[i - 1] != null) {\r\n            items += String.format(\"\\nSwitch Powermax_zone%d_status \\\"Zone %d status\\\" (GPowermax) {powermax=\\\"zone_status:%d\\\", autoupdate=\\\"false\\\"}\" + \"\\nContact Powermax_zone%d_status2 \\\"Zone %d status [%%s]\\\" (GPowermax) {powermax=\\\"zone_status:%d\\\"}\" + \"\\nDateTime Powermax_zone%d_last_trip \\\"Zone %d last trip [%%1$tH:%%1$tM]\\\" (GPowermax) {powermax=\\\"zone_last_trip:%d\\\"}\" + \"\\nSwitch Powermax_zone%d_bypassed \\\"Zone %d bypassed\\\" (GPowermax) {powermax=\\\"zone_bypassed:%d\\\", autoupdate=\\\"false\\\"}\" + \"\\nSwitch Powermax_zone%d_armed \\\"Zone %d armed\\\" (GPowermax) {powermax=\\\"zone_armed:%d\\\", autoupdate=\\\"false\\\"}\" + \"\\nSwitch Powermax_zone%d_low_battery \\\"Zone %d low battery\\\" (GPowermax) {powermax=\\\"zone_low_battery:%d\\\", autoupdate=\\\"false\\\"}\", i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i);\r\n        }\r\n    }\r\n    items += \"\\nString Powermax_command \\\"Command\\\" (GPowermax) {powermax=\\\"command\\\", autoupdate=\\\"false\\\"}\" + \"\\nString Powermax_event_log_1 \\\"Event log 1 [%s]\\\" (GPowermax) {powermax=\\\"event_log:1\\\"}\" + \"\\nString Powermax_event_log_2 \\\"Event log 2 [%s]\\\" (GPowermax) {powermax=\\\"event_log:2\\\"}\" + \"\\nString Powermax_event_log_3 \\\"Event log 3 [%s]\\\" (GPowermax) {powermax=\\\"event_log:3\\\"}\" + \"\\nString Powermax_event_log_4 \\\"Event log 4 [%s]\\\" (GPowermax) {powermax=\\\"event_log:4\\\"}\" + \"\\nString Powermax_event_log_5 \\\"Event log 5 [%s]\\\" (GPowermax) {powermax=\\\"event_log:5\\\"}\" + \"\\nString Powermax_panel_mode \\\"Panel mode [%s]\\\" (GPowermax) {powermax=\\\"panel_mode\\\"}\" + \"\\nString Powermax_panel_type \\\"Panel type [%s]\\\" (GPowermax) {powermax=\\\"panel_type\\\"}\" + \"\\nString Powermax_panel_eeprom \\\"EPROM [%s]\\\" (GPowermax) {powermax=\\\"panel_eprom\\\"}\" + \"\\nString Powermax_panel_software \\\"Software version [%s]\\\" (GPowermax) {powermax=\\\"panel_software\\\"}\" + \"\\nString Powermax_panel_serial \\\"Serial [%s]\\\" (GPowermax) {powermax=\\\"panel_serial\\\"}\";\r\n    if (x10Settings[0] != null && x10Settings[0].isEnabled()) {\r\n        items += \"\\nSwitch Powermax_PGM_status \\\"PGM status\\\" (GPowermax) {powermax=\\\"PGM_status\\\", autoupdate=\\\"false\\\"}\";\r\n    }\r\n    for (int i = 1; i < NB_PGM_X10_DEVICES; i++) {\r\n        if (x10Settings[i] != null && x10Settings[i].isEnabled()) {\r\n            items += String.format(\"\\nSwitch Powermax_X10_%d_status \\\"X10 %d status\\\" (GPowermax) {powermax=\\\"X10_status:%d\\\", autoupdate=\\\"false\\\"}\" + \"\\nString Powermax_X10_%d_status2 \\\"X10 %d status [%%s]\\\" (GPowermax) {powermax=\\\"X10_status:%d\\\", autoupdate=\\\"false\\\"}\", i, i, i, i, i, i);\r\n            sitemap += String.format(\"\\nSwitch item=Powermax_X10_%d_status2 mappings=[OFF=\\\"Off\\\", ON=\\\"On\\\", DIM=\\\"Dim\\\", BRIGHT=\\\"Bright\\\"]\", i);\r\n        }\r\n    }\r\n    sitemap += \"\\nGroup item=GPowermax label=\\\"Alarm\\\"\" + \"\\n}\";\r\n    logger.info(\"Powermax alarm binding:\\n{}\\n\\n{}\\n\", items, sitemap);\r\n}"
}, {
	"Path": "geometry.geom2d.intersection.LineLineIntersector.getIntersection",
	"Comment": "this method returns an intersection point only if there is only one.",
	"Method": "Intersection getIntersection(){\r\n    if (intersection == null)\r\n        computeIntersectionPoint();\r\n    return intersection;\r\n}"
}, {
	"Path": "org.openhab.binding.knx.internal.dpt.KNXCoreTypeMapper.formatDateTime",
	"Comment": "formats the given internal datetype to a knx readable stringaccording to the target datapoint type dpt.",
	"Method": "String formatDateTime(String value,String dpt,String formatDateTime,DateTimeType dateType,String dpt){\r\n    if (DPTXlatorDate.DPT_DATE.getID().equals(dpt)) {\r\n        return dateType.format(\"%tF\");\r\n    } else if (DPTXlatorTime.DPT_TIMEOFDAY.getID().equals(dpt)) {\r\n        return dateType.format(Locale.US, \"%1$ta, %1$tT\");\r\n    } else if (DPTXlatorDateTime.DPT_DATE_TIME.getID().equals(dpt)) {\r\n        return dateType.format(Locale.US, \"%tF %1$tT\");\r\n    } else {\r\n        throw new IllegalArgumentException(\"Could not format date to datapoint type '\" + dpt + \"'\");\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxServer.start",
	"Comment": "initiate communication with the miniserver.starts thread that handles communication.",
	"Method": "void start(){\r\n    logger.debug(\"[{}] Server start\", debugId);\r\n    threadLock.lock();\r\n    try {\r\n        if (monitorThread == null) {\r\n            monitorThread = new LxServerThread(this);\r\n            monitorThread.start();\r\n        }\r\n    } finally {\r\n        threadLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.satel.internal.protocol.SatelMessage.fromBytes",
	"Comment": "deserializes new message instance from specified byte buffer.",
	"Method": "SatelMessage fromBytes(byte[] buffer){\r\n    if (buffer.length < 3) {\r\n        LOGGER.error(\"Invalid message length: {}\", buffer.length);\r\n        return null;\r\n    }\r\n    int receivedCrc = 0xffff & ((buffer[buffer.length - 2] << 8) | (buffer[buffer.length - 1] & 0xff));\r\n    int expectedCrc = calculateChecksum(buffer, buffer.length - 2);\r\n    if (receivedCrc != expectedCrc) {\r\n        LOGGER.error(\"Invalid message checksum: received = {}, expected = {}\", receivedCrc, expectedCrc);\r\n        return null;\r\n    }\r\n    SatelMessage message = new SatelMessage(buffer[0], new byte[buffer.length - 3]);\r\n    if (message.payload.length > 0) {\r\n        System.arraycopy(buffer, 1, message.payload, 0, buffer.length - 3);\r\n    }\r\n    return message;\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.AbstractRioHandlerCallback.fireStateUpdated",
	"Comment": "fires a stateupdate message to all listeners for the channelid and state",
	"Method": "void fireStateUpdated(String channelId,State state){\r\n    if (StringUtils.isEmpty(channelId)) {\r\n        throw new IllegalArgumentException(\"channelId cannot be null or empty)\");\r\n    }\r\n    if (state == null) {\r\n        throw new IllegalArgumentException(\"state cannot be null\");\r\n    }\r\n    for (ListenerState listenerState : listeners) {\r\n        if (listenerState.channelId.equals(channelId)) {\r\n            listenerState.listener.stateUpdate(channelId, state);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.smartmeter.connectors.ConnectorBase.emitValues",
	"Comment": "emitting of values shall happen here. if there is a event based emitting, this can be overriden.",
	"Method": "void emitValues(byte @Nullable[] initMessage,FlowableEmitter<@Nullable T> emitter){\r\n    if (!emitter.isCancelled()) {\r\n        emitter.onNext(readNext(initMessage));\r\n        emitter.onComplete();\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.dhcp.DHCPPacketListenerServer.close",
	"Comment": "closes the socket and waits for the receive thread to finish.does nothing if the receive thread is not running.",
	"Method": "void close(){\r\n    if (isAlive()) {\r\n        willbeclosed = true;\r\n        if (dsocket != null) {\r\n            dsocket.close();\r\n        }\r\n        try {\r\n            join(1000);\r\n        } catch (InterruptedException e) {\r\n        }\r\n        interrupt();\r\n        dsocket = null;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxWsClient.setClientState",
	"Comment": "sets a new websocket client state.the caller must take care of thread synchronization.",
	"Method": "void setClientState(LxWsClient.ClientState state){\r\n    logger.debug(\"[{}] changing client state to: {}\", debugId, state);\r\n    this.state = state;\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassReader.readLabel",
	"Comment": "returns the label corresponding to the given offset. the defaultimplementation of this method creates a label for the given offset if ithas not been already created.",
	"Method": "Label readLabel(int offset,Label[] labels){\r\n    if (labels[offset] == null) {\r\n        labels[offset] = new Label();\r\n    }\r\n    return labels[offset];\r\n}"
}, {
	"Path": "org.mitre.openid.connect.view.UserInfoView.extractUserInfoClaimsIntoSet",
	"Comment": "pull the claims that have been targeted into a set for processing.\treturns an empty set if the input is null.",
	"Method": "Set<String> extractUserInfoClaimsIntoSet(JsonObject claims){\r\n    Set<String> target = new HashSet();\r\n    if (claims != null) {\r\n        JsonObject userinfoAuthorized = claims.getAsJsonObject(\"userinfo\");\r\n        if (userinfoAuthorized != null) {\r\n            for (Entry<String, JsonElement> entry : userinfoAuthorized.entrySet()) {\r\n                target.add(entry.getKey());\r\n            }\r\n        }\r\n    }\r\n    return target;\r\n}"
}, {
	"Path": "org.openhab.io.neeo.internal.servletservices.NeeoBrainService.notifyState",
	"Comment": "helper function to send some state for an itemname to the brain",
	"Method": "void notifyState(String itemName,State state){\r\n    NeeoUtil.requireNotEmpty(itemName, \"itemName cannot be empty\");\r\n    Objects.requireNonNull(state, \"state cannot be null\");\r\n    logger.trace(\"notifyState: {} --- {}\", itemName, state);\r\n    for (final Entry<NeeoDevice, NeeoDeviceChannel> boundEntry : context.getDefinitions().getBound(api.getDeviceKeys(), itemName)) {\r\n        final NeeoDevice device = boundEntry.getKey();\r\n        final NeeoDeviceChannel channel = boundEntry.getValue();\r\n        final NeeoThingUID uid = new NeeoThingUID(device.getUid());\r\n        logger.trace(\"notifyState (device): {} --- {} \", uid, channel);\r\n        for (String deviceKey : api.getDeviceKeys().get(uid)) {\r\n            logger.trace(\"notifyState (key): {} --- {}\", uid, deviceKey);\r\n            if (state instanceof OnOffType) {\r\n                Boolean recipeState = null;\r\n                final String label = channel.getLabel();\r\n                if (StringUtils.equalsIgnoreCase(NeeoButtonGroup.POWERONOFF.getText(), label)) {\r\n                    recipeState = state == OnOffType.ON;\r\n                } else if (state == OnOffType.ON && StringUtils.equalsIgnoreCase(ButtonInfo.POWERON.getLabel(), label)) {\r\n                    recipeState = true;\r\n                } else if (state == OnOffType.OFF && StringUtils.equalsIgnoreCase(ButtonInfo.POWEROFF.getLabel(), label)) {\r\n                    recipeState = false;\r\n                }\r\n                if (recipeState != null) {\r\n                    logger.trace(\"notifyState (executeRecipe): {} --- {} --- {}\", uid, deviceKey, recipeState);\r\n                    final boolean turnOn = recipeState;\r\n                    scheduler.submit(() -> {\r\n                        try {\r\n                            api.executeRecipe(deviceKey, turnOn);\r\n                        } catch (IOException e) {\r\n                            logger.debug(\"Exception occurred while handling executing a recipe: {}\", e.getMessage(), e);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            sendNotification(channel, deviceKey, state);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.protocol.xml.SystemControlXML.applyModelVariations",
	"Comment": "apply command changes to ensure compatibility with all supported models",
	"Method": "void applyModelVariations(){\r\n    if (descriptorXML == null) {\r\n        logger.trace(\"Device descriptor not available\");\r\n        return;\r\n    }\r\n    logger.trace(\"Compatibility detection\");\r\n    partyModeSupported = descriptorXML.hasFeature(d -> MODELS_WITH_PARTY_SUPPORT.contains(d.getUnitName()) || d.system.hasCommandEnding(\"System,Party_Mode,Mode\"), () -> logger.info(\"The {} channel is not supported on your model\", CHANNEL_PARTY_MODE));\r\n    partyModeMuteSupported = descriptorXML.hasFeature(d -> MODELS_WITH_PARTY_SUPPORT.contains(d.getUnitName()) || d.system.hasCommandEnding(\"System,Party_Mode,Volume,Mute\"), () -> logger.info(\"The {} channel is not supported on your model\", CHANNEL_PARTY_MODE_MUTE));\r\n    partyModeVolumeSupported = descriptorXML.hasFeature(d -> MODELS_WITH_PARTY_SUPPORT.contains(d.getUnitName()) || d.system.hasCommandEnding(\"System,Party_Mode,Volume,Lvl\"), () -> logger.info(\"The {} channel is not supported on your model\", CHANNEL_PARTY_MODE_VOLUME));\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.TestDefaultUserInfoService.getByUsernameAndClientId_pairwiseClients",
	"Comment": "clients with pairwise subs should be grouped by the sector uri",
	"Method": "void getByUsernameAndClientId_pairwiseClients(){\r\n    Mockito.when(clientDetailsEntityService.loadClientByClientId(pairwiseClientId1)).thenReturn(pairwiseClient1);\r\n    Mockito.when(clientDetailsEntityService.loadClientByClientId(pairwiseClientId2)).thenReturn(pairwiseClient2);\r\n    Mockito.when(clientDetailsEntityService.loadClientByClientId(pairwiseClientId3)).thenReturn(pairwiseClient3);\r\n    Mockito.when(clientDetailsEntityService.loadClientByClientId(pairwiseClientId4)).thenReturn(pairwiseClient4);\r\n    Mockito.when(userInfoRepository.getByUsername(regularUsername)).thenAnswer(new Answer<UserInfo>() {\r\n        @Override\r\n        public UserInfo answer(InvocationOnMock invocation) throws Throwable {\r\n            UserInfo userInfo = new DefaultUserInfo();\r\n            userInfo.setPreferredUsername(regularUsername);\r\n            userInfo.setSub(regularSub);\r\n            return userInfo;\r\n        }\r\n    });\r\n    Mockito.when(pairwiseIdentiferService.getIdentifier(userInfoRegular, pairwiseClient1)).thenReturn(pairwiseSub12);\r\n    Mockito.when(pairwiseIdentiferService.getIdentifier(userInfoRegular, pairwiseClient2)).thenReturn(pairwiseSub12);\r\n    Mockito.when(pairwiseIdentiferService.getIdentifier(userInfoRegular, pairwiseClient3)).thenReturn(pairwiseSub3);\r\n    Mockito.when(pairwiseIdentiferService.getIdentifier(userInfoRegular, pairwiseClient4)).thenReturn(pairwiseSub4);\r\n    UserInfo user1 = service.getByUsernameAndClientId(regularUsername, pairwiseClientId1);\r\n    UserInfo user2 = service.getByUsernameAndClientId(regularUsername, pairwiseClientId2);\r\n    UserInfo user3 = service.getByUsernameAndClientId(regularUsername, pairwiseClientId3);\r\n    UserInfo user4 = service.getByUsernameAndClientId(regularUsername, pairwiseClientId4);\r\n    assertEquals(pairwiseSub12, user1.getSub());\r\n    assertEquals(pairwiseSub12, user2.getSub());\r\n    assertEquals(pairwiseSub3, user3.getSub());\r\n    assertEquals(pairwiseSub4, user4.getSub());\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.TestDefaultUserInfoService.getByUsernameAndClientId_pairwiseClients",
	"Comment": "clients with pairwise subs should be grouped by the sector uri",
	"Method": "void getByUsernameAndClientId_pairwiseClients(){\r\n    UserInfo userInfo = new DefaultUserInfo();\r\n    userInfo.setPreferredUsername(regularUsername);\r\n    userInfo.setSub(regularSub);\r\n    return userInfo;\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassWriter.newLong",
	"Comment": "adds a long to the constant pool of the class being build. does nothingif the constant pool already contains a similar item.",
	"Method": "Item newLong(long value){\r\n    key.set(value);\r\n    Item result = get(key);\r\n    if (result == null) {\r\n        pool.putByte(LONG).putLong(value);\r\n        result = new Item(index, key);\r\n        index += 2;\r\n        put(result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Unit.fromArray",
	"Comment": "create tuple from array. array has to have exactly one element.",
	"Method": "Unit<X> fromArray(X[] array){\r\n    if (array == null) {\r\n        throw new IllegalArgumentException(\"Array cannot be null\");\r\n    }\r\n    if (array.length != 1) {\r\n        throw new IllegalArgumentException(\"Array must have exactly 1 element in order to create a Unit. Size is \" + array.length);\r\n    }\r\n    return new Unit<X>(array[0]);\r\n}"
}, {
	"Path": "org.openmuc.jrxtx.SerialPortBuilder.newBuilder",
	"Comment": "constructs a new serialportbuilder with the default values.",
	"Method": "SerialPortBuilder newBuilder(String portName){\r\n    return new SerialPortBuilder(portName);\r\n}"
}, {
	"Path": "org.openhab.binding.pentair.internal.handler.PentairBaseBridgeHandler.writePacket",
	"Comment": "method to write a package on the pentair bus. will add preamble and checksum to bytes written",
	"Method": "void writePacket(PentairPacket p){\r\n    try {\r\n        byte[] preamble = { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0x00, (byte) 0xFF };\r\n        byte[] buf = new byte[5 + p.getLength() + 8];\r\n        p.setSource(id);\r\n        System.arraycopy(preamble, 0, buf, 0, 5);\r\n        System.arraycopy(p.buf, 0, buf, 5, p.getLength() + 6);\r\n        int checksum = p.calcChecksum();\r\n        buf[p.getLength() + 11] = (byte) ((checksum >> 8) & 0xFF);\r\n        buf[p.getLength() + 12] = (byte) (checksum & 0xFF);\r\n        logger.debug(\"Writing packet: {}\", PentairPacket.bytesToHex(buf));\r\n        writer.write(buf, 0, 5 + p.getLength() + 8);\r\n        writer.flush();\r\n    } catch (IOException e) {\r\n        logger.trace(\"I/O error while writing stream: {}\", e);\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.feican.internal.Commands.program",
	"Comment": "returns the command to set a preset program. program codes on the device start with 0x80 and up. binding mapsthis with values starting with 1.",
	"Method": "byte[] program(int program){\r\n    byte[] command = PROGRAM_COMMAND.clone();\r\n    command[3] = (byte) (-129 + program);\r\n    return command;\r\n}"
}, {
	"Path": "org.openhab.binding.netatmo.internal.handler.MeasurableChannels.removeChannel",
	"Comment": "if this channel value is provided as a measure, then deleteit in the getmeasure parameter list",
	"Method": "void removeChannel(ChannelUID channelUID){\r\n    String channel = channelUID.getId();\r\n    measuredChannels.remove(channel);\r\n}"
}, {
	"Path": "org.openhab.voice.kaldi.internal.RecognitionEventListenerKaldi.onRecognitionEvent",
	"Comment": "target of recognitionevent events that are forwarded to the contained sttlistener",
	"Method": "void onRecognitionEvent(RecognitionEvent recognitionEvent){\r\n    int status = recognitionEvent.getStatus();\r\n    switch(status) {\r\n        case RecognitionEvent.STATUS_SUCCESS:\r\n            RecognitionEvent.Result result = recognitionEvent.getResult();\r\n            if (result.isFinal()) {\r\n                sttListener.sttEventReceived(getSTTEvent(recognitionEvent));\r\n            }\r\n            break;\r\n        case RecognitionEvent.STATUS_NO_SPEECH:\r\n            sttListener.sttEventReceived(new SpeechRecognitionErrorEvent(\"No speech\"));\r\n            break;\r\n        case RecognitionEvent.STATUS_ABORTED:\r\n            sttListener.sttEventReceived(new SpeechRecognitionErrorEvent(\"Aborted\"));\r\n            break;\r\n        case RecognitionEvent.STATUS_AUDIO_CAPTURE:\r\n            sttListener.sttEventReceived(new SpeechRecognitionErrorEvent(\"Error with audio capture\"));\r\n            break;\r\n        case RecognitionEvent.STATUS_NETWORK:\r\n            sttListener.sttEventReceived(new SpeechRecognitionErrorEvent(\"Network error\"));\r\n            break;\r\n        case RecognitionEvent.STATUS_NOT_ALLOWED:\r\n            sttListener.sttEventReceived(new SpeechRecognitionErrorEvent(\"Not allowed\"));\r\n            break;\r\n        case RecognitionEvent.STATUS_SERVICE_NOT_ALLOWED:\r\n            sttListener.sttEventReceived(new SpeechRecognitionErrorEvent(\"Service not allowed\"));\r\n            break;\r\n        case RecognitionEvent.STATUS_BAD_GRAMMAR:\r\n            sttListener.sttEventReceived(new SpeechRecognitionErrorEvent(\"Grammar invalid\"));\r\n            break;\r\n        case RecognitionEvent.STATUS_LANGUAGE_NOT_SUPPORTED:\r\n            sttListener.sttEventReceived(new SpeechRecognitionErrorEvent(\"Language not supported\"));\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.TestDefaultBlacklistedSiteService.isBlacklisted_no",
	"Comment": "tests for finding a site that is not blacklisted in the repository.",
	"Method": "void isBlacklisted_no(){\r\n    Mockito.when(mockRepository.getAll()).thenReturn(blackListedSitesSet);\r\n    assertFalse(service.isBlacklisted(uri3));\r\n    Mockito.verify(mockRepository).getAll();\r\n}"
}, {
	"Path": "org.openhab.binding.opensprinkler.internal.handler.OpenSprinklerPiHandler.onUpdate",
	"Comment": "creates a new polling job to sync state with the opensprinkler device.",
	"Method": "void onUpdate(){\r\n    if (pollingJob == null || pollingJob.isCancelled()) {\r\n        int refresh;\r\n        try {\r\n            refresh = getConfig().as(OpenSprinklerPiConfig.class).refresh;\r\n        } catch (Exception exp) {\r\n            refresh = this.refreshInterval;\r\n        }\r\n        pollingJob = scheduler.scheduleWithFixedDelay(refreshService, DEFAULT_WAIT_BEFORE_INITIAL_REFRESH, refresh, TimeUnit.SECONDS);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.tplinksmarthome.internal.TPLinkSmartHomeDiscoveryService.closeDiscoverSocket",
	"Comment": "closes the discovery socket and cleans the value. no need for synchronization as this method is called from asynchronized context.",
	"Method": "void closeDiscoverSocket(){\r\n    if (discoverSocket != null) {\r\n        discoverSocket.close();\r\n        discoverSocket = null;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.kodi.internal.protocol.KodiConnection.getFavorites",
	"Comment": "retrieves a list of favorites from the kodi instance. the result is cached.",
	"Method": "List<KodiFavorite> getFavorites(){\r\n    String method = \"Favourites.GetFavourites\";\r\n    String hash = hostname + '#' + method;\r\n    JsonElement response = REQUEST_CACHE.putIfAbsentAndGet(hash, () -> {\r\n        final String[] properties = { \"path\", \"window\", \"windowparameter\" };\r\n        JsonObject params = new JsonObject();\r\n        params.add(\"properties\", getJsonArray(properties));\r\n        return socket.callMethod(method, params);\r\n    });\r\n    List<KodiFavorite> favorites = new ArrayList();\r\n    if (response instanceof JsonObject) {\r\n        JsonObject result = response.getAsJsonObject();\r\n        if (result.has(\"favourites\")) {\r\n            JsonElement favourites = result.get(\"favourites\");\r\n            if (favourites instanceof JsonArray) {\r\n                for (JsonElement element : favourites.getAsJsonArray()) {\r\n                    JsonObject object = (JsonObject) element;\r\n                    KodiFavorite favorite = new KodiFavorite(object.get(\"title\").getAsString());\r\n                    favorite.setFavoriteType(object.get(\"type\").getAsString());\r\n                    if (object.has(\"path\")) {\r\n                        favorite.setPath(object.get(\"path\").getAsString());\r\n                    }\r\n                    if (object.has(\"window\")) {\r\n                        favorite.setWindow(object.get(\"window\").getAsString());\r\n                        favorite.setWindowParameter(object.get(\"windowparameter\").getAsString());\r\n                    }\r\n                    favorites.add(favorite);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return favorites;\r\n}"
}, {
	"Path": "nginx.clojure.asm.Frame.execute",
	"Comment": "simulates the action of the given instruction on the output stack frame.",
	"Method": "void execute(int opcode,int arg,ClassWriter cw,Item item){\r\n    int t1, t2, t3, t4;\r\n    switch(opcode) {\r\n        case Opcodes.NOP:\r\n        case Opcodes.INEG:\r\n        case Opcodes.LNEG:\r\n        case Opcodes.FNEG:\r\n        case Opcodes.DNEG:\r\n        case Opcodes.I2B:\r\n        case Opcodes.I2C:\r\n        case Opcodes.I2S:\r\n        case Opcodes.GOTO:\r\n        case Opcodes.RETURN:\r\n            break;\r\n        case Opcodes.ACONST_NULL:\r\n            push(NULL);\r\n            break;\r\n        case Opcodes.ICONST_M1:\r\n        case Opcodes.ICONST_0:\r\n        case Opcodes.ICONST_1:\r\n        case Opcodes.ICONST_2:\r\n        case Opcodes.ICONST_3:\r\n        case Opcodes.ICONST_4:\r\n        case Opcodes.ICONST_5:\r\n        case Opcodes.BIPUSH:\r\n        case Opcodes.SIPUSH:\r\n        case Opcodes.ILOAD:\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.LCONST_0:\r\n        case Opcodes.LCONST_1:\r\n        case Opcodes.LLOAD:\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.FCONST_0:\r\n        case Opcodes.FCONST_1:\r\n        case Opcodes.FCONST_2:\r\n        case Opcodes.FLOAD:\r\n            push(FLOAT);\r\n            break;\r\n        case Opcodes.DCONST_0:\r\n        case Opcodes.DCONST_1:\r\n        case Opcodes.DLOAD:\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.LDC:\r\n            switch(item.type) {\r\n                case ClassWriter.INT:\r\n                    push(INTEGER);\r\n                    break;\r\n                case ClassWriter.LONG:\r\n                    push(LONG);\r\n                    push(TOP);\r\n                    break;\r\n                case ClassWriter.FLOAT:\r\n                    push(FLOAT);\r\n                    break;\r\n                case ClassWriter.DOUBLE:\r\n                    push(DOUBLE);\r\n                    push(TOP);\r\n                    break;\r\n                case ClassWriter.CLASS:\r\n                    push(OBJECT | cw.addType(\"java/lang/Class\"));\r\n                    break;\r\n                case ClassWriter.STR:\r\n                    push(OBJECT | cw.addType(\"java/lang/String\"));\r\n                    break;\r\n                case ClassWriter.MTYPE:\r\n                    push(OBJECT | cw.addType(\"java/lang/invoke/MethodType\"));\r\n                    break;\r\n                default:\r\n                    push(OBJECT | cw.addType(\"java/lang/invoke/MethodHandle\"));\r\n            }\r\n            break;\r\n        case Opcodes.ALOAD:\r\n            push(get(arg));\r\n            break;\r\n        case Opcodes.IALOAD:\r\n        case Opcodes.BALOAD:\r\n        case Opcodes.CALOAD:\r\n        case Opcodes.SALOAD:\r\n            pop(2);\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.LALOAD:\r\n        case Opcodes.D2L:\r\n            pop(2);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.FALOAD:\r\n            pop(2);\r\n            push(FLOAT);\r\n            break;\r\n        case Opcodes.DALOAD:\r\n        case Opcodes.L2D:\r\n            pop(2);\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.AALOAD:\r\n            pop(1);\r\n            t1 = pop();\r\n            push(ELEMENT_OF + t1);\r\n            break;\r\n        case Opcodes.ISTORE:\r\n        case Opcodes.FSTORE:\r\n        case Opcodes.ASTORE:\r\n            t1 = pop();\r\n            set(arg, t1);\r\n            if (arg > 0) {\r\n                t2 = get(arg - 1);\r\n                if (t2 == LONG || t2 == DOUBLE) {\r\n                    set(arg - 1, TOP);\r\n                } else if ((t2 & KIND) != BASE) {\r\n                    set(arg - 1, t2 | TOP_IF_LONG_OR_DOUBLE);\r\n                }\r\n            }\r\n            break;\r\n        case Opcodes.LSTORE:\r\n        case Opcodes.DSTORE:\r\n            pop(1);\r\n            t1 = pop();\r\n            set(arg, t1);\r\n            set(arg + 1, TOP);\r\n            if (arg > 0) {\r\n                t2 = get(arg - 1);\r\n                if (t2 == LONG || t2 == DOUBLE) {\r\n                    set(arg - 1, TOP);\r\n                } else if ((t2 & KIND) != BASE) {\r\n                    set(arg - 1, t2 | TOP_IF_LONG_OR_DOUBLE);\r\n                }\r\n            }\r\n            break;\r\n        case Opcodes.IASTORE:\r\n        case Opcodes.BASTORE:\r\n        case Opcodes.CASTORE:\r\n        case Opcodes.SASTORE:\r\n        case Opcodes.FASTORE:\r\n        case Opcodes.AASTORE:\r\n            pop(3);\r\n            break;\r\n        case Opcodes.LASTORE:\r\n        case Opcodes.DASTORE:\r\n            pop(4);\r\n            break;\r\n        case Opcodes.POP:\r\n        case Opcodes.IFEQ:\r\n        case Opcodes.IFNE:\r\n        case Opcodes.IFLT:\r\n        case Opcodes.IFGE:\r\n        case Opcodes.IFGT:\r\n        case Opcodes.IFLE:\r\n        case Opcodes.IRETURN:\r\n        case Opcodes.FRETURN:\r\n        case Opcodes.ARETURN:\r\n        case Opcodes.TABLESWITCH:\r\n        case Opcodes.LOOKUPSWITCH:\r\n        case Opcodes.ATHROW:\r\n        case Opcodes.MONITORENTER:\r\n        case Opcodes.MONITOREXIT:\r\n        case Opcodes.IFNULL:\r\n        case Opcodes.IFNONNULL:\r\n            pop(1);\r\n            break;\r\n        case Opcodes.POP2:\r\n        case Opcodes.IF_ICMPEQ:\r\n        case Opcodes.IF_ICMPNE:\r\n        case Opcodes.IF_ICMPLT:\r\n        case Opcodes.IF_ICMPGE:\r\n        case Opcodes.IF_ICMPGT:\r\n        case Opcodes.IF_ICMPLE:\r\n        case Opcodes.IF_ACMPEQ:\r\n        case Opcodes.IF_ACMPNE:\r\n        case Opcodes.LRETURN:\r\n        case Opcodes.DRETURN:\r\n            pop(2);\r\n            break;\r\n        case Opcodes.DUP:\r\n            t1 = pop();\r\n            push(t1);\r\n            push(t1);\r\n            break;\r\n        case Opcodes.DUP_X1:\r\n            t1 = pop();\r\n            t2 = pop();\r\n            push(t1);\r\n            push(t2);\r\n            push(t1);\r\n            break;\r\n        case Opcodes.DUP_X2:\r\n            t1 = pop();\r\n            t2 = pop();\r\n            t3 = pop();\r\n            push(t1);\r\n            push(t3);\r\n            push(t2);\r\n            push(t1);\r\n            break;\r\n        case Opcodes.DUP2:\r\n            t1 = pop();\r\n            t2 = pop();\r\n            push(t2);\r\n            push(t1);\r\n            push(t2);\r\n            push(t1);\r\n            break;\r\n        case Opcodes.DUP2_X1:\r\n            t1 = pop();\r\n            t2 = pop();\r\n            t3 = pop();\r\n            push(t2);\r\n            push(t1);\r\n            push(t3);\r\n            push(t2);\r\n            push(t1);\r\n            break;\r\n        case Opcodes.DUP2_X2:\r\n            t1 = pop();\r\n            t2 = pop();\r\n            t3 = pop();\r\n            t4 = pop();\r\n            push(t2);\r\n            push(t1);\r\n            push(t4);\r\n            push(t3);\r\n            push(t2);\r\n            push(t1);\r\n            break;\r\n        case Opcodes.SWAP:\r\n            t1 = pop();\r\n            t2 = pop();\r\n            push(t1);\r\n            push(t2);\r\n            break;\r\n        case Opcodes.IADD:\r\n        case Opcodes.ISUB:\r\n        case Opcodes.IMUL:\r\n        case Opcodes.IDIV:\r\n        case Opcodes.IREM:\r\n        case Opcodes.IAND:\r\n        case Opcodes.IOR:\r\n        case Opcodes.IXOR:\r\n        case Opcodes.ISHL:\r\n        case Opcodes.ISHR:\r\n        case Opcodes.IUSHR:\r\n        case Opcodes.L2I:\r\n        case Opcodes.D2I:\r\n        case Opcodes.FCMPL:\r\n        case Opcodes.FCMPG:\r\n            pop(2);\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.LADD:\r\n        case Opcodes.LSUB:\r\n        case Opcodes.LMUL:\r\n        case Opcodes.LDIV:\r\n        case Opcodes.LREM:\r\n        case Opcodes.LAND:\r\n        case Opcodes.LOR:\r\n        case Opcodes.LXOR:\r\n            pop(4);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.FADD:\r\n        case Opcodes.FSUB:\r\n        case Opcodes.FMUL:\r\n        case Opcodes.FDIV:\r\n        case Opcodes.FREM:\r\n        case Opcodes.L2F:\r\n        case Opcodes.D2F:\r\n            pop(2);\r\n            push(FLOAT);\r\n            break;\r\n        case Opcodes.DADD:\r\n        case Opcodes.DSUB:\r\n        case Opcodes.DMUL:\r\n        case Opcodes.DDIV:\r\n        case Opcodes.DREM:\r\n            pop(4);\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.LSHL:\r\n        case Opcodes.LSHR:\r\n        case Opcodes.LUSHR:\r\n            pop(3);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.IINC:\r\n            set(arg, INTEGER);\r\n            break;\r\n        case Opcodes.I2L:\r\n        case Opcodes.F2L:\r\n            pop(1);\r\n            push(LONG);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.I2F:\r\n            pop(1);\r\n            push(FLOAT);\r\n            break;\r\n        case Opcodes.I2D:\r\n        case Opcodes.F2D:\r\n            pop(1);\r\n            push(DOUBLE);\r\n            push(TOP);\r\n            break;\r\n        case Opcodes.F2I:\r\n        case Opcodes.ARRAYLENGTH:\r\n        case Opcodes.INSTANCEOF:\r\n            pop(1);\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.LCMP:\r\n        case Opcodes.DCMPL:\r\n        case Opcodes.DCMPG:\r\n            pop(4);\r\n            push(INTEGER);\r\n            break;\r\n        case Opcodes.JSR:\r\n        case Opcodes.RET:\r\n            throw new RuntimeException(\"JSR/RET are not supported with computeFrames option\");\r\n        case Opcodes.GETSTATIC:\r\n            push(cw, item.strVal3);\r\n            break;\r\n        case Opcodes.PUTSTATIC:\r\n            pop(item.strVal3);\r\n            break;\r\n        case Opcodes.GETFIELD:\r\n            pop(1);\r\n            push(cw, item.strVal3);\r\n            break;\r\n        case Opcodes.PUTFIELD:\r\n            pop(item.strVal3);\r\n            pop();\r\n            break;\r\n        case Opcodes.INVOKEVIRTUAL:\r\n        case Opcodes.INVOKESPECIAL:\r\n        case Opcodes.INVOKESTATIC:\r\n        case Opcodes.INVOKEINTERFACE:\r\n            pop(item.strVal3);\r\n            if (opcode != Opcodes.INVOKESTATIC) {\r\n                t1 = pop();\r\n                if (opcode == Opcodes.INVOKESPECIAL && item.strVal2.charAt(0) == '<') {\r\n                    init(t1);\r\n                }\r\n            }\r\n            push(cw, item.strVal3);\r\n            break;\r\n        case Opcodes.INVOKEDYNAMIC:\r\n            pop(item.strVal2);\r\n            push(cw, item.strVal2);\r\n            break;\r\n        case Opcodes.NEW:\r\n            push(UNINITIALIZED | cw.addUninitializedType(item.strVal1, arg));\r\n            break;\r\n        case Opcodes.NEWARRAY:\r\n            pop();\r\n            switch(arg) {\r\n                case Opcodes.T_BOOLEAN:\r\n                    push(ARRAY_OF | BOOLEAN);\r\n                    break;\r\n                case Opcodes.T_CHAR:\r\n                    push(ARRAY_OF | CHAR);\r\n                    break;\r\n                case Opcodes.T_BYTE:\r\n                    push(ARRAY_OF | BYTE);\r\n                    break;\r\n                case Opcodes.T_SHORT:\r\n                    push(ARRAY_OF | SHORT);\r\n                    break;\r\n                case Opcodes.T_INT:\r\n                    push(ARRAY_OF | INTEGER);\r\n                    break;\r\n                case Opcodes.T_FLOAT:\r\n                    push(ARRAY_OF | FLOAT);\r\n                    break;\r\n                case Opcodes.T_DOUBLE:\r\n                    push(ARRAY_OF | DOUBLE);\r\n                    break;\r\n                default:\r\n                    push(ARRAY_OF | LONG);\r\n                    break;\r\n            }\r\n            break;\r\n        case Opcodes.ANEWARRAY:\r\n            String s = item.strVal1;\r\n            pop();\r\n            if (s.charAt(0) == '[') {\r\n                push(cw, '[' + s);\r\n            } else {\r\n                push(ARRAY_OF | OBJECT | cw.addType(s));\r\n            }\r\n            break;\r\n        case Opcodes.CHECKCAST:\r\n            s = item.strVal1;\r\n            pop();\r\n            if (s.charAt(0) == '[') {\r\n                push(cw, s);\r\n            } else {\r\n                push(OBJECT | cw.addType(s));\r\n            }\r\n            break;\r\n        default:\r\n            pop(arg);\r\n            push(cw, item.strVal1);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.feed.internal.handler.FeedHandler.checkConfiguration",
	"Comment": "this method checks if the provided configuration is valid.when invalid parameter is found, default value is assigned.",
	"Method": "void checkConfiguration(){\r\n    logger.debug(\"Start reading Feed Thing configuration.\");\r\n    Configuration configuration = getConfig();\r\n    urlString = (String) configuration.get(URL);\r\n    try {\r\n        refreshTime = (BigDecimal) configuration.get(REFRESH_TIME);\r\n        if (refreshTime.intValue() <= 0) {\r\n            throw new IllegalArgumentException(\"Refresh time must be positive number!\");\r\n        }\r\n    } catch (Exception e) {\r\n        logger.warn(\"Refresh time [{}] is not valid. Falling back to default value: {}. {}\", refreshTime, DEFAULT_REFRESH_TIME, e.getMessage());\r\n        refreshTime = DEFAULT_REFRESH_TIME;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.innogysmarthome.internal.handler.InnogyBridgeHandler.handleNewMessageReceivedEvent",
	"Comment": "handles the event that occurs, when a new message was received. currently only handles low battery messages.",
	"Method": "void handleNewMessageReceivedEvent(Event event){\r\n    if (deviceStructMan == null) {\r\n        scheduleReinitialize();\r\n    }\r\n    List<Message> messageList = event.getDataListAsMessage();\r\n    for (Message m : messageList) {\r\n        if (Message.TYPE_DEVICE_LOW_BATTERY.equals(m.getType())) {\r\n            for (Link dl : m.getDeviceLinkList()) {\r\n                deviceStructMan.refreshDevice(dl.getId());\r\n                Device device = deviceStructMan.getDeviceById(dl.getId());\r\n                if (device != null) {\r\n                    for (DeviceStatusListener deviceStatusListener : deviceStatusListeners) {\r\n                        deviceStatusListener.onDeviceStateChanged(device);\r\n                    }\r\n                } else {\r\n                    logger.debug(\"Unknown/unsupported device {}.\", event.getLinkId());\r\n                }\r\n            }\r\n        } else {\r\n            logger.debug(\"Message received event not yet implemented for Messagetype {}.\", m.getType());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.Frame.init",
	"Comment": "replaces the given type with the appropriate type if it is one of thetypes on which a constructor is invoked in the basic block.",
	"Method": "void init(int var,int init,ClassWriter cw,int t){\r\n    int s;\r\n    if (t == UNINITIALIZED_THIS) {\r\n        s = OBJECT | cw.addType(cw.thisName);\r\n    } else if ((t & (DIM | BASE_KIND)) == UNINITIALIZED) {\r\n        String type = cw.typeTable[t & BASE_VALUE].strVal1;\r\n        s = OBJECT | cw.addType(type);\r\n    } else {\r\n        return t;\r\n    }\r\n    for (int j = 0; j < initializationCount; ++j) {\r\n        int u = initializations[j];\r\n        int dim = u & DIM;\r\n        int kind = u & KIND;\r\n        if (kind == LOCAL) {\r\n            u = dim + inputLocals[u & VALUE];\r\n        } else if (kind == STACK) {\r\n            u = dim + inputStack[inputStack.length - (u & VALUE)];\r\n        }\r\n        if (t == u) {\r\n            return s;\r\n        }\r\n    }\r\n    return t;\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.TelegramReaderUtil.readTelegram",
	"Comment": "reads a telegram given the file relative to this package and returns the objects.",
	"Method": "P1Telegram readTelegram(String telegramName,TelegramState expectedTelegramState){\r\n    AtomicReference<P1Telegram> p1Telegram = new AtomicReference(null);\r\n    byte[] telegram = readRawTelegram(telegramName);\r\n    P1TelegramParser parser = new P1TelegramParser(p1Telegram::set);\r\n    parser.parseData(telegram, 0, telegram.length);\r\n    assertEquals(\"Expected TelegramState should be as expected\", expectedTelegramState, p1Telegram.get().getTelegramState());\r\n    return p1Telegram.get();\r\n}"
}, {
	"Path": "org.openhab.binding.satel.internal.command.ReadEventDescCommand.isLongDescription",
	"Comment": "returns type of requested description, either long or short.",
	"Method": "boolean isLongDescription(){\r\n    return (getRequest().getPayload()[0] & 0x80) != 0;\r\n}"
}, {
	"Path": "nginx.clojure.net.NginxClojureAsynChannel.setTimeout",
	"Comment": "if timeout is negative, it will be ignored. if timeout is 0, this means no timeout.",
	"Method": "void setTimeout(long connectTimeout,long readTimeout,long writeTimeout){\r\n    as.setTimeout(connectTimeout, readTimeout, writeTimeout);\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxControlLightController.onStateChange",
	"Comment": "get scene names from new state value received from the miniserver",
	"Method": "void onStateChange(LxControlState state){\r\n    String scenesText = state.getTextValue();\r\n    if (scenesText != null) {\r\n        sceneNames.clear();\r\n        String[] scenes = scenesText.split(\",\");\r\n        for (String line : scenes) {\r\n            line = line.replaceAll(\"\\\"\", \"\");\r\n            String[] params = line.split(\"=\");\r\n            if (params.length == 2) {\r\n                sceneNames.put(params[0], params[1]);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.minecraft.internal.handler.MinecraftServerHandler.sendMessage",
	"Comment": "send message to server.does nothing if no connection is established.",
	"Method": "boolean sendMessage(OHMessage message){\r\n    if (connection != null) {\r\n        connection.sendMessage(message);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Decade.fromIterable",
	"Comment": "create tuple from iterable. iterable has to have exactly ten elements.",
	"Method": "Decade<X, X, X, X, X, X, X, X, X, X> fromIterable(Iterable<X> iterable,Decade<X, X, X, X, X, X, X, X, X, X> fromIterable,Iterable<X> iterable,int index,Decade<X, X, X, X, X, X, X, X, X, X> fromIterable,Iterable<X> iterable,int index,boolean exactSize){\r\n    if (iterable == null) {\r\n        throw new IllegalArgumentException(\"Iterable cannot be null\");\r\n    }\r\n    boolean tooFewElements = false;\r\n    X element0 = null;\r\n    X element1 = null;\r\n    X element2 = null;\r\n    X element3 = null;\r\n    X element4 = null;\r\n    X element5 = null;\r\n    X element6 = null;\r\n    X element7 = null;\r\n    X element8 = null;\r\n    X element9 = null;\r\n    final Iterator<X> iter = iterable.iterator();\r\n    int i = 0;\r\n    while (i < index) {\r\n        if (iter.hasNext()) {\r\n            iter.next();\r\n        } else {\r\n            tooFewElements = true;\r\n        }\r\n        i++;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element0 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element1 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element2 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element3 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element4 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element5 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element6 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element7 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element8 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element9 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (tooFewElements && exactSize) {\r\n        throw new IllegalArgumentException(\"Not enough elements for creating a Decade (10 needed)\");\r\n    }\r\n    if (iter.hasNext() && exactSize) {\r\n        throw new IllegalArgumentException(\"Iterable must have exactly 10 available elements in order to create a Decade.\");\r\n    }\r\n    return new Decade<X, X, X, X, X, X, X, X, X, X>(element0, element1, element2, element3, element4, element5, element6, element7, element8, element9);\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.NetworkHandlerFactory.activate",
	"Comment": "the activate component call is used to access the bindings configuration",
	"Method": "void activate(ComponentContext componentContext,Map<String, Object> config){\r\n    super.activate(componentContext);\r\n    modified(config);\r\n}"
}, {
	"Path": "org.openhab.binding.feican.internal.Commands.programSpeed",
	"Comment": "returns the command to set program speed to a value between 0 and 100.",
	"Method": "byte[] programSpeed(PercentType percentage){\r\n    byte[] command = PROGRAM_SPEED_COMMAND.clone();\r\n    command[3] = percentage.byteValue();\r\n    return command;\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Decade.fromCollection",
	"Comment": "create tuple from collection. collection has to have exactly ten elements.",
	"Method": "Decade<X, X, X, X, X, X, X, X, X, X> fromCollection(Collection<X> collection){\r\n    return fromIterable(collection);\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.arrayLength",
	"Comment": "generates the instruction to compute the length of an array.",
	"Method": "void arrayLength(){\r\n    mv.visitInsn(Opcodes.ARRAYLENGTH);\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Quartet.fromArray",
	"Comment": "create tuple from array. array has to have exactly four elements.",
	"Method": "Quartet<X, X, X, X> fromArray(X[] array){\r\n    if (array == null) {\r\n        throw new IllegalArgumentException(\"Array cannot be null\");\r\n    }\r\n    if (array.length != 4) {\r\n        throw new IllegalArgumentException(\"Array must have exactly 4 elements in order to create a Quartet. Size is \" + array.length);\r\n    }\r\n    return new Quartet<X, X, X, X>(array[0], array[1], array[2], array[3]);\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.loadArg",
	"Comment": "generates the instruction to load the given method argument on the stack.",
	"Method": "void loadArg(int arg){\r\n    loadInsn(argumentTypes[arg], getArgIndex(arg));\r\n}"
}, {
	"Path": "org.openhab.binding.gardena.internal.handler.GardenaAccountHandler.scheduleReinitialize",
	"Comment": "schedules a reinitialization, if gardea smart home account is not reachable at startup.",
	"Method": "void scheduleReinitialize(){\r\n    scheduler.schedule(() -> {\r\n        initializeGardena();\r\n    }, REINITIALIZE_DELAY_SECONDS, TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "nginx.clojure.asm.util.CheckClassAdapter.checkFormalTypeParameters",
	"Comment": "checks the formal type parameters of a class or method signature.",
	"Method": "int checkFormalTypeParameters(String signature,int pos){\r\n    pos = checkChar('<', signature, pos);\r\n    pos = checkFormalTypeParameter(signature, pos);\r\n    while (getChar(signature, pos) != '>') {\r\n        pos = checkFormalTypeParameter(signature, pos);\r\n    }\r\n    return pos + 1;\r\n}"
}, {
	"Path": "org.openhab.ui.cometvisu.internal.servlet.CometVisuServlet.accepts",
	"Comment": "returns true if the given accept header accepts the given value.",
	"Method": "boolean accepts(String acceptHeader,String toAccept){\r\n    String[] acceptValues = acceptHeader.split(\"\\\\s*(,|;)\\\\s*\");\r\n    Arrays.sort(acceptValues);\r\n    return Arrays.binarySearch(acceptValues, toAccept) > -1 || Arrays.binarySearch(acceptValues, toAccept.replaceAll(\"/.*$\", \"/*\")) > -1 || Arrays.binarySearch(acceptValues, \"*/*\") > -1;\r\n}"
}, {
	"Path": "org.openhab.binding.powermax.internal.message.PowermaxCommManager.sendMessage",
	"Comment": "send a message or delay the sending if time frame for receiving response is not ended",
	"Method": "boolean sendMessage(PowermaxSendType msgType,boolean sendMessage,PowermaxBaseMessage msg,boolean immediate,int waitTime,boolean sendMessage,byte[] data){\r\n    boolean done = false;\r\n    if (isConnected()) {\r\n        data[data.length - 2] = computeCRC(data, data.length);\r\n        connector.sendMessage(data);\r\n        done = connector.isConnected();\r\n    } else {\r\n        logger.debug(\"sendMessage(): aborted (not connected)\");\r\n    }\r\n    return done;\r\n}"
}, {
	"Path": "org.openhab.binding.denonmarantz.internal.connector.telnet.DenonMarantzTelnetConnector.cleanupDisplayInfo",
	"Comment": "display info could contain some garbled text, attempt to clean it up.",
	"Method": "String cleanupDisplayInfo(String titleValue){\r\n    byte[] firstByteRemoved = Arrays.copyOfRange(titleValue.getBytes(), 1, titleValue.getBytes().length);\r\n    return new String(firstByteRemoved).replaceAll(\"[-]\", \"\");\r\n}"
}, {
	"Path": "nginx.clojure.asm.Type.getConstructorDescriptor",
	"Comment": "returns the descriptor corresponding to the given constructor.",
	"Method": "String getConstructorDescriptor(Constructor<?> c){\r\n    Class<?>[] parameters = c.getParameterTypes();\r\n    StringBuffer buf = new StringBuffer();\r\n    buf.append('(');\r\n    for (int i = 0; i < parameters.length; ++i) {\r\n        getDescriptor(buf, parameters[i]);\r\n    }\r\n    return buf.append(\")V\").toString();\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.handler.DSMRBridgeHandler.meterValueReceived",
	"Comment": "method to forward the last received messages to the bound meters and to the meterlisteners.",
	"Method": "void meterValueReceived(P1Telegram telegram){\r\n    updateStatus(ThingStatus.ONLINE);\r\n    getThing().getThings().forEach(child -> {\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(\"Update child:{} with {} objects\", child.getThingTypeUID().getId(), telegram.getCosemObjects().size());\r\n        }\r\n        DSMRMeterHandler dsmrMeterHandler = (DSMRMeterHandler) child.getHandler();\r\n        if (dsmrMeterHandler instanceof DSMRMeterHandler) {\r\n            dsmrMeterHandler.telegramReceived(telegram);\r\n        }\r\n    });\r\n    meterListeners.forEach(m -> m.telegramReceived(telegram));\r\n}"
}, {
	"Path": "view.jme.MyParticleEmitter.killAllParticles",
	"Comment": "instantly kills all active particles, after this method is called, allparticles will be dead and no longer visible.",
	"Method": "void killAllParticles(){\r\n    for (int i = 0; i < particles.length; ++i) {\r\n        if (particles[i].life > 0) {\r\n            this.freeParticle(i);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.client.OIDCAuthenticationFilter.createNonce",
	"Comment": "create a cryptographically random nonce and store it in the session",
	"Method": "String createNonce(HttpSession session){\r\n    String nonce = new BigInteger(50, new SecureRandom()).toString(16);\r\n    session.setAttribute(NONCE_SESSION_VARIABLE, nonce);\r\n    return nonce;\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.handler.NikoHomeControlBridgeHandler.setNhcDiscovery",
	"Comment": "set discovery service handler to be able to start discovery after bridge initialization.",
	"Method": "void setNhcDiscovery(NikoHomeControlDiscoveryService nhcDiscovery){\r\n    this.nhcDiscovery = nhcDiscovery;\r\n}"
}, {
	"Path": "org.openhab.binding.tplinksmarthome.internal.device.DeviceTestBase.assertInput",
	"Comment": "asserts the value passed to outputstream.write, which is the call that would be made to the actual device. thischecks if the value sent to the device is what is expected to be sent to the device.",
	"Method": "void assertInput(String filename){\r\n    AtomicInteger index = new AtomicInteger();\r\n    doAnswer(i -> {\r\n        String json = ModelTestUtil.readJson(filename[index.get()]);\r\n        byte[] input = (byte[]) i.getArguments()[0];\r\n        assertEquals(filename[index.get()], json, CryptUtil.decryptWithLength(new ByteArrayInputStream(input)));\r\n        index.incrementAndGet();\r\n        return null;\r\n    }).when(outputStream).write(any());\r\n}"
}, {
	"Path": "org.openhab.binding.cm11a.internal.X10Interface.scheduleHWUpdate",
	"Comment": "add specified device into the queue for hardware updates.if device is already queued, it will be removed from queue and moved to the end.",
	"Method": "void scheduleHWUpdate(Cm11aAbstractHandler device){\r\n    deviceUpdateQueue.remove(device);\r\n    if (!deviceUpdateQueue.offer(device)) {\r\n        logger.warn(\"X10 function call queue full.  Too many outstanding commands.  This command will be discarded\");\r\n    }\r\n    logger.debug(\"Added item to cm11a queue for: {}\", device.getThing().getLabel());\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.PresenceDetectionValue.addReachableTcpService",
	"Comment": "add a reachable tcp port to this presence detection result value object.thread safe.",
	"Method": "void addReachableTcpService(int tcpPort){\r\n    synchronized (tcpServiceReachable) {\r\n        tcpServiceReachable.add(tcpPort);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.handler.DSMRMeterHandler.updateState",
	"Comment": "updates the state of all channels from the last received cosem values from the meter. the lastreceivedvalues arecleared after processing here so when it does contain values the next time this method is called and it containsvalues those are new values.",
	"Method": "void updateState(){\r\n    logger.trace(\"Update state for device: {}\", getThing().getThingTypeUID().getId());\r\n    if (!lastReceivedValues.isEmpty()) {\r\n        for (CosemObject cosemObject : lastReceivedValues) {\r\n            String channel = cosemObject.getType().name().toLowerCase();\r\n            for (Entry<String, ? extends State> entry : cosemObject.getCosemValues().entrySet()) {\r\n                if (!entry.getKey().isEmpty()) {\r\n                    channel += \"_\" + entry.getKey();\r\n                }\r\n                State newState = entry.getValue();\r\n                logger.debug(\"Updating state for channel {} to value {}\", channel, newState);\r\n                updateState(channel, newState);\r\n            }\r\n        }\r\n        if (getThing().getStatus() != ThingStatus.ONLINE) {\r\n            updateStatus(ThingStatus.ONLINE);\r\n        }\r\n        lastReceivedValues = Collections.emptyList();\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.system.RioSystemProtocol.handleFailureNotification",
	"Comment": "handles any error notifications returned by the russound system",
	"Method": "void handleFailureNotification(Matcher m,String resp){\r\n    logger.debug(\"Error notification: {}\", resp);\r\n}"
}, {
	"Path": "nginx.clojure.asm.Type.getOpcode",
	"Comment": "returns a jvm instruction opcode adapted to this java type. this methodmust not be used for method types.",
	"Method": "int getOpcode(int opcode){\r\n    if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {\r\n        return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);\r\n    } else {\r\n        return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.DSMRHandlerFactory.registerDiscoveryService",
	"Comment": "registers a meter discovery service for the bridge handler.",
	"Method": "void registerDiscoveryService(DSMRBridgeHandler bridgeHandler){\r\n    DSMRMeterDiscoveryService discoveryService = new DSMRMeterDiscoveryService(bridgeHandler);\r\n    discoveryService.setLocaleProvider(localeProvider);\r\n    discoveryService.setTranslationProvider(i18nProvider);\r\n    this.discoveryServiceRegs.put(bridgeHandler.getThing().getUID(), bundleContext.registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable()));\r\n}"
}, {
	"Path": "org.openhab.binding.pioneeravr.protocol.utils.VolumeConverter.convertFromIpControlVolumeToPercent",
	"Comment": "return the percentage of the max volume levelfrom the value received in the ipcontrol response.",
	"Method": "double convertFromIpControlVolumeToPercent(String ipControlVolume,int zone){\r\n    validateZone(zone - 1);\r\n    double ipControlVolumeInt = Double.parseDouble(ipControlVolume);\r\n    return ((ipControlVolumeInt - 1d) * 100d) / MAX_IP_CONTROL_VOLUME[zone - 1];\r\n}"
}, {
	"Path": "org.openhab.binding.feican.internal.Commands.switchOnOff",
	"Comment": "returns the command to switch a device on or off depending on the given parameter.",
	"Method": "byte[] switchOnOff(OnOffType onOff){\r\n    if (onOff == OnOffType.ON) {\r\n        return ON_COMMAND;\r\n    } else {\r\n        return OFF_COMMAND;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.opensprinkler.internal.api.OpenSprinklerApiFactory.getHttpApi",
	"Comment": "factory method used to determine what version of the api is in use at theopensprinkler api and return the proper class for control of the device.",
	"Method": "OpenSprinklerApi getHttpApi(String hostname,int port,String password){\r\n    String returnContent;\r\n    int version = -1;\r\n    try {\r\n        returnContent = Http.sendHttpGet(HTTP_REQUEST_URL_PREFIX + hostname + \":\" + port + \"/\" + CMD_OPTIONS_INFO, null);\r\n    } catch (Exception exp) {\r\n        throw new CommunicationApiException(\"There was a problem in the HTTP communication with the OpenSprinkler API: \" + exp.getMessage());\r\n    }\r\n    try {\r\n        version = Parse.jsonInt(returnContent, JSON_OPTION_FIRMWARE_VERSION);\r\n    } catch (Exception exp) {\r\n        version = -1;\r\n    }\r\n    if (version >= 210 && version < 213) {\r\n        return new OpenSprinklerHttpApiV210(hostname, port, password);\r\n    } else if (version >= 213) {\r\n        return new OpenSprinklerHttpApiV213(hostname, port, password);\r\n    } else {\r\n        try {\r\n            returnContent = Http.sendHttpGet(HTTP_REQUEST_URL_PREFIX + hostname + \":\" + port + \"/sn0\", null);\r\n        } catch (Exception exp) {\r\n            throw new CommunicationApiException(\"There was a problem in the HTTP communication with the OpenSprinkler API: \" + exp.getMessage());\r\n        }\r\n        if (returnContent == null || (!returnContent.equals(\"0\") && !returnContent.equals(\"1\"))) {\r\n            throw new CommunicationApiException(\"There was a problem in the HTTP communication with the OpenSprinkler API, Unexpected API response: \" + returnContent);\r\n        }\r\n        return new OpenSprinklerHttpApiV100(hostname, port, password);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.feican.internal.Commands.colorTemperature",
	"Comment": "returns the command to set the color temperature to a value between 0 and 100.",
	"Method": "byte[] colorTemperature(PercentType percentage){\r\n    byte[] command = COLOR_TEMPERATURE_COMMAND.clone();\r\n    command[4] = percentage.byteValue();\r\n    command[5] = (byte) (100 - percentage.intValue());\r\n    return command;\r\n}"
}, {
	"Path": "nginx.clojure.asm.Type.getArgumentsAndReturnSizes",
	"Comment": "returns the size of the arguments and of the return value of methods ofthis type. this method should only be used for method types.",
	"Method": "int getArgumentsAndReturnSizes(String desc,int getArgumentsAndReturnSizes){\r\n    return getArgumentsAndReturnSizes(getDescriptor());\r\n}"
}, {
	"Path": "nginx.clojure.asm.Label.visitSubroutine",
	"Comment": "finds the basic blocks that belong to a given subroutine, and marks theseblocks as belonging to this subroutine. this method follows the controlflow graph to find all the blocks that are reachable from the currentblock without following any jsr target.",
	"Method": "void visitSubroutine(Label JSR,long id,int nbSubroutines){\r\n    Label stack = this;\r\n    while (stack != null) {\r\n        Label l = stack;\r\n        stack = l.next;\r\n        l.next = null;\r\n        if (JSR != null) {\r\n            if ((l.status & VISITED2) != 0) {\r\n                continue;\r\n            }\r\n            l.status |= VISITED2;\r\n            if ((l.status & RET) != 0) {\r\n                if (!l.inSameSubroutine(JSR)) {\r\n                    Edge e = new Edge();\r\n                    e.info = l.inputStackTop;\r\n                    e.successor = JSR.successors.successor;\r\n                    e.next = l.successors;\r\n                    l.successors = e;\r\n                }\r\n            }\r\n        } else {\r\n            if (l.inSubroutine(id)) {\r\n                continue;\r\n            }\r\n            l.addToSubroutine(id, nbSubroutines);\r\n        }\r\n        Edge e = l.successors;\r\n        while (e != null) {\r\n            if ((l.status & Label.JSR) == 0 || e != l.successors.next) {\r\n                if (e.successor.next == null) {\r\n                    e.successor.next = stack;\r\n                    stack = e.successor;\r\n                }\r\n            }\r\n            e = e.next;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.MITREidDataService_1_1.readSystemScopes",
	"Comment": "read the list of system scopes from the reader and insert them into the\tscope repository.",
	"Method": "void readSystemScopes(JsonReader reader){\r\n    reader.beginArray();\r\n    while (reader.hasNext()) {\r\n        SystemScope scope = new SystemScope();\r\n        reader.beginObject();\r\n        while (reader.hasNext()) {\r\n            switch(reader.peek()) {\r\n                case END_OBJECT:\r\n                    continue;\r\n                case NAME:\r\n                    String name = reader.nextName();\r\n                    if (reader.peek() == JsonToken.NULL) {\r\n                        reader.skipValue();\r\n                    } else if (name.equals(\"value\")) {\r\n                        scope.setValue(reader.nextString());\r\n                    } else if (name.equals(\"description\")) {\r\n                        scope.setDescription(reader.nextString());\r\n                    } else if (name.equals(\"allowDynReg\")) {\r\n                        scope.setRestricted(!reader.nextBoolean());\r\n                    } else if (name.equals(\"defaultScope\")) {\r\n                        scope.setDefaultScope(reader.nextBoolean());\r\n                    } else if (name.equals(\"structured\")) {\r\n                        logger.warn(\"Found a structured scope, ignoring structure\");\r\n                    } else if (name.equals(\"structuredParameter\")) {\r\n                        logger.warn(\"Found a structured scope, ignoring structure\");\r\n                    } else if (name.equals(\"icon\")) {\r\n                        scope.setIcon(reader.nextString());\r\n                    } else {\r\n                        logger.debug(\"found unexpected entry\");\r\n                        reader.skipValue();\r\n                    }\r\n                    break;\r\n                default:\r\n                    logger.debug(\"Found unexpected entry\");\r\n                    reader.skipValue();\r\n                    continue;\r\n            }\r\n        }\r\n        reader.endObject();\r\n        sysScopeRepository.save(scope);\r\n    }\r\n    reader.endArray();\r\n    logger.info(\"Done reading system scopes\");\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxControlJalousie.onStateChange",
	"Comment": "monitor jalousie position against desired target position and stop it if target position is reached.",
	"Method": "void onStateChange(LxControlState state){\r\n    if (STATE_POSITION.equals(state.getName()) && targetPosition != null && targetPosition > 0 && targetPosition < 1) {\r\n        Double currentPosition = state.getValue();\r\n        Double upValue = getStateValue(STATE_UP);\r\n        Double downValue = getStateValue(STATE_DOWN);\r\n        if (currentPosition != null && upValue != null && downValue != null) {\r\n            if (((upValue == 1) && (currentPosition <= targetPosition)) || ((downValue == 1) && (currentPosition >= targetPosition))) {\r\n                targetPosition = null;\r\n                try {\r\n                    stop();\r\n                } catch (IOException e) {\r\n                    logger.debug(\"Error stopping jalousie when meeting target position.\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.minecraft.internal.server.ServerConnection.create",
	"Comment": "directly connect to server.reconnects when connection is lost",
	"Method": "Observable<ServerConnection> create(ThingUID thingUID,String host,int port){\r\n    final String serverUrl = String.format(\"ws://%s:%d/stream\", host, port);\r\n    return Observable.<ServerConnection>create(new OnSubscribe<ServerConnection>() {\r\n        private final Logger logger = LoggerFactory.getLogger(ServerConnection.class);\r\n        @Override\r\n        public void call(final Subscriber<? super ServerConnection> subscriber) {\r\n            logger.info(\"Start connecting to Minecraft server at: {}\", serverUrl);\r\n            if (!subscriber.isUnsubscribed()) {\r\n                ServerConnection serverConnection = new ServerConnection(thingUID, host, port);\r\n                MinecraftSocketHandler socketHandler = new MinecraftSocketHandler() {\r\n                    @Override\r\n                    public void onError(WebSocketException e) {\r\n                        subscriber.onError(e);\r\n                    }\r\n                    @Override\r\n                    public void onClose() {\r\n                        logger.info(\"Connection to Minecraft server stopped\");\r\n                        subscriber.onCompleted();\r\n                    }\r\n                };\r\n                URI destUri = null;\r\n                try {\r\n                    destUri = new URI(serverUrl);\r\n                } catch (URISyntaxException e) {\r\n                    subscriber.onError(e);\r\n                }\r\n                final WebSocket websocket = new WebSocket(destUri);\r\n                websocket.setEventHandler(socketHandler);\r\n                websocket.connect();\r\n                serverConnection.setSocketHandler(socketHandler);\r\n                serverConnection.setWebSocket(websocket);\r\n                subscriber.onNext(serverConnection);\r\n                subscriber.add(Subscriptions.create(new Action0() {\r\n                    @Override\r\n                    public void call() {\r\n                        subscriber.unsubscribe();\r\n                        websocket.close();\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.openhab.binding.minecraft.internal.server.ServerConnection.create",
	"Comment": "directly connect to server.reconnects when connection is lost",
	"Method": "Observable<ServerConnection> create(ThingUID thingUID,String host,int port){\r\n    logger.info(\"Start connecting to Minecraft server at: {}\", serverUrl);\r\n    if (!subscriber.isUnsubscribed()) {\r\n        ServerConnection serverConnection = new ServerConnection(thingUID, host, port);\r\n        MinecraftSocketHandler socketHandler = new MinecraftSocketHandler() {\r\n            @Override\r\n            public void onError(WebSocketException e) {\r\n                subscriber.onError(e);\r\n            }\r\n            @Override\r\n            public void onClose() {\r\n                logger.info(\"Connection to Minecraft server stopped\");\r\n                subscriber.onCompleted();\r\n            }\r\n        };\r\n        URI destUri = null;\r\n        try {\r\n            destUri = new URI(serverUrl);\r\n        } catch (URISyntaxException e) {\r\n            subscriber.onError(e);\r\n        }\r\n        final WebSocket websocket = new WebSocket(destUri);\r\n        websocket.setEventHandler(socketHandler);\r\n        websocket.connect();\r\n        serverConnection.setSocketHandler(socketHandler);\r\n        serverConnection.setWebSocket(websocket);\r\n        subscriber.onNext(serverConnection);\r\n        subscriber.add(Subscriptions.create(new Action0() {\r\n            @Override\r\n            public void call() {\r\n                subscriber.unsubscribe();\r\n                websocket.close();\r\n            }\r\n        }));\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.minecraft.internal.server.ServerConnection.create",
	"Comment": "directly connect to server.reconnects when connection is lost",
	"Method": "Observable<ServerConnection> create(ThingUID thingUID,String host,int port){\r\n    subscriber.onError(e);\r\n}"
}, {
	"Path": "org.openhab.binding.minecraft.internal.server.ServerConnection.create",
	"Comment": "directly connect to server.reconnects when connection is lost",
	"Method": "Observable<ServerConnection> create(ThingUID thingUID,String host,int port){\r\n    logger.info(\"Connection to Minecraft server stopped\");\r\n    subscriber.onCompleted();\r\n}"
}, {
	"Path": "org.openhab.binding.minecraft.internal.server.ServerConnection.create",
	"Comment": "directly connect to server.reconnects when connection is lost",
	"Method": "Observable<ServerConnection> create(ThingUID thingUID,String host,int port){\r\n    subscriber.unsubscribe();\r\n    websocket.close();\r\n}"
}, {
	"Path": "nginx.clojure.NginxClojureRT.postResponseEvent",
	"Comment": "when called in the main thread it will be handled directly otherwise it will post a event by pipe let \tmain threadget a chance to handle this response.",
	"Method": "void postResponseEvent(NginxRequest req,NginxResponse resp){\r\n    if (Thread.currentThread() == NGINX_MAIN_THREAD) {\r\n        int phase = req.phase();\r\n        int rc = handleResponse(req, resp);\r\n        if (phase == -1 || phase == NGX_HTTP_HEADER_FILTER_PHASE) {\r\n            ngx_http_finalize_request(req.nativeRequest(), rc);\r\n        } else if (rc != MiniConstants.NGX_DONE) {\r\n            ngx_http_clojure_mem_continue_current_phase(req.nativeRequest(), rc);\r\n        }\r\n    } else {\r\n        long r = req.nativeRequest();\r\n        WorkerResponseContext ctx = new WorkerResponseContext(resp, req);\r\n        savePostEventData(r, ctx);\r\n        ngx_http_clojure_mem_post_event(r, null, 0);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.kodi.internal.handler.KodiHandler.waitForPlaylistState",
	"Comment": "wait for the playlist state so that we know when the notification has started or finished playing",
	"Method": "boolean waitForPlaylistState(KodiPlaylistState playlistState){\r\n    int timeoutMaxCount = 20, timeoutCount = 0;\r\n    logger.trace(\"Waiting up to {} ms for playlist state '{}' to be set ...\", timeoutMaxCount * 100, playlistState);\r\n    while (!playlistState.equals(connection.getPlaylistState()) && timeoutCount < timeoutMaxCount) {\r\n        try {\r\n            Thread.sleep(100);\r\n        } catch (InterruptedException e) {\r\n            break;\r\n        }\r\n        timeoutCount++;\r\n    }\r\n    return checkForTimeout(timeoutCount, timeoutMaxCount, \"playlist state to '\" + playlistState.toString() + \"' be set\");\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.JSRInlinerAdapter.visitJumpInsn",
	"Comment": "detects a jsr instruction and sets a flag to indicate we will need to doinlining.",
	"Method": "void visitJumpInsn(int opcode,Label lbl){\r\n    super.visitJumpInsn(opcode, lbl);\r\n    LabelNode ln = ((JumpInsnNode) instructions.getLast()).label;\r\n    if (opcode == JSR && !subroutineHeads.containsKey(ln)) {\r\n        subroutineHeads.put(ln, new BitSet());\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.cast",
	"Comment": "generates the instructions to cast a numerical value from one type toanother.",
	"Method": "void cast(Type from,Type to){\r\n    if (from != to) {\r\n        if (from == Type.DOUBLE_TYPE) {\r\n            if (to == Type.FLOAT_TYPE) {\r\n                mv.visitInsn(Opcodes.D2F);\r\n            } else if (to == Type.LONG_TYPE) {\r\n                mv.visitInsn(Opcodes.D2L);\r\n            } else {\r\n                mv.visitInsn(Opcodes.D2I);\r\n                cast(Type.INT_TYPE, to);\r\n            }\r\n        } else if (from == Type.FLOAT_TYPE) {\r\n            if (to == Type.DOUBLE_TYPE) {\r\n                mv.visitInsn(Opcodes.F2D);\r\n            } else if (to == Type.LONG_TYPE) {\r\n                mv.visitInsn(Opcodes.F2L);\r\n            } else {\r\n                mv.visitInsn(Opcodes.F2I);\r\n                cast(Type.INT_TYPE, to);\r\n            }\r\n        } else if (from == Type.LONG_TYPE) {\r\n            if (to == Type.DOUBLE_TYPE) {\r\n                mv.visitInsn(Opcodes.L2D);\r\n            } else if (to == Type.FLOAT_TYPE) {\r\n                mv.visitInsn(Opcodes.L2F);\r\n            } else {\r\n                mv.visitInsn(Opcodes.L2I);\r\n                cast(Type.INT_TYPE, to);\r\n            }\r\n        } else {\r\n            if (to == Type.BYTE_TYPE) {\r\n                mv.visitInsn(Opcodes.I2B);\r\n            } else if (to == Type.CHAR_TYPE) {\r\n                mv.visitInsn(Opcodes.I2C);\r\n            } else if (to == Type.DOUBLE_TYPE) {\r\n                mv.visitInsn(Opcodes.I2D);\r\n            } else if (to == Type.FLOAT_TYPE) {\r\n                mv.visitInsn(Opcodes.I2F);\r\n            } else if (to == Type.LONG_TYPE) {\r\n                mv.visitInsn(Opcodes.I2L);\r\n            } else if (to == Type.SHORT_TYPE) {\r\n                mv.visitInsn(Opcodes.I2S);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.io.openhabcloud.internal.CloudService.sendLogNotification",
	"Comment": "sends an advanced notification to log. log notifications are not pushed to userdevices but are shown to all account users in notifications log",
	"Method": "void sendLogNotification(String message,String icon,String severity){\r\n    logger.debug(\"Sending log message '{}'\", message);\r\n    cloudClient.sendLogNotification(message, icon, severity);\r\n}"
}, {
	"Path": "geometry.collections.Ring.getPrevious",
	"Comment": "sans quoi ce genre de methode renverrai une out of bound exception",
	"Method": "Object getPrevious(int index,Object getPrevious,Object o){\r\n    Object debug = get(indexOf(o));\r\n    if (debug != o)\r\n        for (int i = 0; i < size(); i++) if (get(i) == o)\r\n            return getPrevious(i);\r\n    return getPrevious(indexOf(o));\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.handler.NikoHomeControlActionHandler.handleStateUpdate",
	"Comment": "method to update state of channel, called from niko home control action.",
	"Method": "void handleStateUpdate(NhcAction nhcAction){\r\n    Configuration config = this.getConfig();\r\n    Integer actionId = ((Number) config.get(CONFIG_ACTION_ID)).intValue();\r\n    int actionType = nhcAction.getType();\r\n    int actionState = nhcAction.getState();\r\n    if (this.filterEvent) {\r\n        this.filterEvent = false;\r\n        logger.debug(\"Niko Home Control: filtered event {} for {}\", actionState, actionId);\r\n        updateStatus(ThingStatus.ONLINE);\r\n        return;\r\n    }\r\n    switch(actionType) {\r\n        case 0:\r\n        case 1:\r\n            updateState(CHANNEL_SWITCH, (actionState == 0) ? OnOffType.OFF : OnOffType.ON);\r\n            updateStatus(ThingStatus.ONLINE);\r\n            break;\r\n        case 2:\r\n            updateState(CHANNEL_BRIGHTNESS, new PercentType(actionState));\r\n            updateStatus(ThingStatus.ONLINE);\r\n            break;\r\n        case 4:\r\n        case 5:\r\n            cancelRollershutterStop();\r\n            int state = 100 - actionState;\r\n            int prevState = 100 - this.prevActionState;\r\n            if (((state == 0) || (state == 100)) && (state != prevState)) {\r\n                long duration = rollershutterMoveTime(nhcAction, prevState, state);\r\n                setRollershutterMovingTrue(nhcAction, duration);\r\n            } else {\r\n                setRollershutterMovingFalse();\r\n            }\r\n            if (this.waitForEvent) {\r\n                logger.debug(\"Niko Home Control: received requested rollershutter {} position event {}\", actionId, actionState);\r\n                executeRollershutterTask();\r\n            } else {\r\n                updateState(CHANNEL_ROLLERSHUTTER, new PercentType(state));\r\n                updateStatus(ThingStatus.ONLINE);\r\n            }\r\n            break;\r\n        default:\r\n            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Niko Home Control: unknown action type \" + actionType);\r\n    }\r\n    this.prevActionState = actionState;\r\n}"
}, {
	"Path": "org.openhab.binding.powermax.internal.handler.PowermaxBridgeHandler.checkKeepAlive",
	"Comment": "check that we receive a keep alive message during the last minute",
	"Method": "void checkKeepAlive(){\r\n    long now = System.currentTimeMillis();\r\n    if (Boolean.TRUE.equals(currentState.isPowerlinkMode()) && (currentState.getLastKeepAlive() != null) && ((now - currentState.getLastKeepAlive()) > ONE_MINUTE)) {\r\n        commManager.sendRestoreMessage();\r\n        currentState.setLastKeepAlive(now);\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.storeInsn",
	"Comment": "generates the instruction to store the top stack value in a localvariable.",
	"Method": "void storeInsn(Type type,int index){\r\n    mv.visitVarInsn(type.getOpcode(Opcodes.ISTORE), index);\r\n}"
}, {
	"Path": "nginx.clojure.asm.util.CheckMethodAdapter.getLabelStatusField",
	"Comment": "returns the field object corresponding to the label.status field.",
	"Method": "Field getLabelStatusField(){\r\n    if (labelStatusField == null) {\r\n        labelStatusField = getLabelField(\"a\");\r\n        if (labelStatusField == null) {\r\n            labelStatusField = getLabelField(\"status\");\r\n        }\r\n    }\r\n    return labelStatusField;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.client.service.impl.TestSignedAuthRequestUrlBuilder.buildAuthRequestUrl",
	"Comment": "this test takes the uri from the result of building a signed request\tand checks that the jws object parsed from the request uri matches up\twith the expected claim values.",
	"Method": "void buildAuthRequestUrl(){\r\n    String requestUri = urlBuilder.buildAuthRequestUrl(serverConfig, clientConfig, redirectUri, nonce, state, options, null);\r\n    UriComponentsBuilder builder = null;\r\n    try {\r\n        builder = UriComponentsBuilder.fromUri(new URI(requestUri));\r\n    } catch (URISyntaxException e1) {\r\n        fail(\"URISyntaxException was thrown.\");\r\n    }\r\n    UriComponents components = builder.build();\r\n    String jwtString = components.getQueryParams().get(\"request\").get(0);\r\n    JWTClaimsSet claims = null;\r\n    try {\r\n        SignedJWT jwt = SignedJWT.parse(jwtString);\r\n        claims = jwt.getJWTClaimsSet();\r\n    } catch (ParseException e) {\r\n        fail(\"ParseException was thrown.\");\r\n    }\r\n    assertEquals(responseType, claims.getClaim(\"response_type\"));\r\n    assertEquals(clientConfig.getClientId(), claims.getClaim(\"client_id\"));\r\n    List<String> scopeList = Arrays.asList(((String) claims.getClaim(\"scope\")).split(\" \"));\r\n    assertTrue(scopeList.containsAll(clientConfig.getScope()));\r\n    assertEquals(redirectUri, claims.getClaim(\"redirect_uri\"));\r\n    assertEquals(nonce, claims.getClaim(\"nonce\"));\r\n    assertEquals(state, claims.getClaim(\"state\"));\r\n    for (String claim : options.keySet()) {\r\n        assertEquals(options.get(claim), claims.getClaim(claim));\r\n    }\r\n}"
}, {
	"Path": "org.openhab.voice.googletts.internal.GoogleTTSService.updateConfig",
	"Comment": "called by the framework when the configuration was updated.",
	"Method": "void updateConfig(Map<String, Object> newConfig){\r\n    logger.debug(\"Updating configuration\");\r\n    if (newConfig != null) {\r\n        String param = newConfig.containsKey(PARAM_SERVICE_ACCOUNT_KEY) ? newConfig.get(PARAM_SERVICE_ACCOUNT_KEY).toString() : null;\r\n        config.setServiceAccountKey(param);\r\n        if (param == null) {\r\n            logger.error(\"Missing service account key configuration to access Google Cloud TTS API.\");\r\n        }\r\n        param = newConfig.containsKey(PARAM_PITCH) ? newConfig.get(PARAM_PITCH).toString() : null;\r\n        if (param != null) {\r\n            config.setPitch(Double.parseDouble(param));\r\n        }\r\n        param = newConfig.containsKey(PARAM_SPEAKING_RATE) ? newConfig.get(PARAM_SPEAKING_RATE).toString() : null;\r\n        if (param != null) {\r\n            config.setSpeakingRate(Double.parseDouble(param));\r\n        }\r\n        param = newConfig.containsKey(PARAM_VOLUME_GAIN_DB) ? newConfig.get(PARAM_VOLUME_GAIN_DB).toString() : null;\r\n        if (param != null) {\r\n            config.setVolumeGainDb(Double.parseDouble(param));\r\n        }\r\n        param = newConfig.containsKey(PARAM_PURGE_CACHE) ? newConfig.get(PARAM_PURGE_CACHE).toString() : null;\r\n        if (param != null) {\r\n            config.setPurgeCache(Boolean.parseBoolean(param));\r\n        }\r\n        logger.trace(\"New configuration: {}\", config.toString());\r\n        if (config.getServiceAccountKey() != null) {\r\n            apiImpl.setConfig(config);\r\n            if (apiImpl.isInitialized()) {\r\n                allVoices = initVoices();\r\n                audioFormats = initAudioFormats();\r\n            }\r\n        }\r\n    } else {\r\n        logger.error(\"Missing Google Cloud TTS configuration.\");\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.client.keypublisher.ClientKeyPublisher.publishClientJwk",
	"Comment": "return a view to publish all keys in jwk format. only used if jwkpublishurl is set.",
	"Method": "ModelAndView publishClientJwk(){\r\n    Map<String, JWK> keys = signingAndValidationService.getAllPublicKeys();\r\n    return new ModelAndView(jwkViewName, \"keys\", keys);\r\n}"
}, {
	"Path": "org.openhab.io.neeo.internal.models.NeeoDeviceChannel.isPowerState",
	"Comment": "helper method to determine if the channel is a powerstate channel or not",
	"Method": "boolean isPowerState(){\r\n    return NeeoCapabilityType.SENSOR_POWER.equals(type);\r\n}"
}, {
	"Path": "org.openhab.binding.harmonyhub.internal.handler.HarmonyDeviceHandler.updateButtonPressChannel",
	"Comment": "updates the buttonpress channel with the available buttons as option states.",
	"Method": "void updateButtonPressChannel(HarmonyConfig harmonyConfig){\r\n    ChannelTypeUID channelTypeUID = new ChannelTypeUID(getThing().getUID().getAsString() + \":\" + CHANNEL_BUTTON_PRESS);\r\n    if (harmonyConfig == null) {\r\n        logger.debug(\"Cannot update {} when HarmonyConfig is null\", channelTypeUID);\r\n        return;\r\n    }\r\n    logger.debug(\"Updating {}\", channelTypeUID);\r\n    List<StateOption> states = getButtonStateOptions(harmonyConfig);\r\n    ChannelType channelType = ChannelTypeBuilder.state(channelTypeUID, \"Send Button Press\", \"String\").withDescription(\"Send a button press to device \" + getThing().getLabel()).withStateDescription(new StateDescription(null, null, null, null, false, states)).build();\r\n    factory.addChannelType(channelType);\r\n    Channel channel = ChannelBuilder.create(new ChannelUID(getThing().getUID(), CHANNEL_BUTTON_PRESS), \"String\").withType(channelTypeUID).build();\r\n    List<Channel> newChannels = new ArrayList();\r\n    for (Channel c : getThing().getChannels()) {\r\n        if (!c.getUID().equals(channel.getUID())) {\r\n            newChannels.add(c);\r\n        }\r\n    }\r\n    newChannels.add(channel);\r\n    ThingBuilder thingBuilder = editThing();\r\n    thingBuilder.withChannels(newChannels);\r\n    updateThing(thingBuilder.build());\r\n}"
}, {
	"Path": "org.openhab.binding.gardena.internal.util.UidUtils.getGardenaDeviceId",
	"Comment": "returns the device id of the gardena device from the given thing.",
	"Method": "String getGardenaDeviceId(Thing thing){\r\n    String deviceId = thing.getConfiguration().as(GardenaDeviceConfig.class).deviceId;\r\n    if (deviceId != null) {\r\n        return deviceId;\r\n    }\r\n    return thing.getUID().getId();\r\n}"
}, {
	"Path": "org.openmuc.jrxtx.SerialPortBuilder.build",
	"Comment": "combine all of the options that have been set and return a new serialport object.",
	"Method": "SerialPort build(){\r\n    return JRxTxPort.openSerialPort(portName, baudRate, parity, dataBits, stopBits, flowControl);\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.putField",
	"Comment": "generates the instruction to store the top stack value in a non staticfield.",
	"Method": "void putField(Type owner,String name,Type type){\r\n    fieldInsn(Opcodes.PUTFIELD, owner, name, type);\r\n}"
}, {
	"Path": "org.openhab.binding.deconz.internal.handler.DeconzBridgeHandler.parseAPIKeyResponse",
	"Comment": "parses the response message to the api key generation rest api.",
	"Method": "void parseAPIKeyResponse(AsyncHttpClient.Result r){\r\n    if (r.getResponseCode() == 403) {\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, \"Allow authentification for 3rd party apps. Trying again in \" + String.valueOf(POLL_FREQUENCY_SEC) + \" seconds\");\r\n        scheduledFuture = scheduler.schedule(() -> requestApiKey(), POLL_FREQUENCY_SEC, TimeUnit.SECONDS);\r\n    } else if (r.getResponseCode() == 200) {\r\n        ApiKeyMessage[] response = gson.fromJson(r.getBody(), ApiKeyMessage[].class);\r\n        if (response.length == 0) {\r\n            throw new IllegalStateException(\"Authorisation request response is empty\");\r\n        }\r\n        config.apikey = response[0].success.username;\r\n        Configuration configuration = editConfiguration();\r\n        configuration.put(BindingConstants.CONFIG_APIKEY, config.apikey);\r\n        updateConfiguration(configuration);\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING, \"Waiting for configuration\");\r\n        requestFullState();\r\n    } else {\r\n        throw new IllegalStateException(\"Unknown status code for authorisation request\");\r\n    }\r\n}"
}, {
	"Path": "org.openhab.ui.cometvisu.internal.backend.ReadResource.unregisterItem",
	"Comment": "listens to state changes of the given item, if it is part of therequested items",
	"Method": "void unregisterItem(Item item){\r\n    if (item == null || items.containsKey(item) || !itemNames.contains(item.getName())) {\r\n        return;\r\n    }\r\n    if (item instanceof GenericItem) {\r\n        ((GenericItem) item).removeStateChangeListener(stateEventListener);\r\n        items.remove(item);\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.net.NginxClojureAsynChannel.setReadTimeout",
	"Comment": "if timeout is negative, it will be ignored. if timeout is 0, this means no timeout.",
	"Method": "void setReadTimeout(long timeout){\r\n    check();\r\n    as.setTimeout(-1, timeout, -1);\r\n}"
}, {
	"Path": "org.openhab.binding.avmfritz.internal.hardware.FritzAhaWebInterface.createResponse",
	"Comment": "creates the proper response to a given challenge based on the password stored",
	"Method": "String createResponse(String challenge){\r\n    String handshake = challenge.concat(\"-\").concat(config.getPassword());\r\n    MessageDigest md5;\r\n    try {\r\n        md5 = MessageDigest.getInstance(\"MD5\");\r\n    } catch (NoSuchAlgorithmException e) {\r\n        logger.error(\"This version of Java does not support MD5 hashing\");\r\n        return \"\";\r\n    }\r\n    byte[] handshakeHash;\r\n    try {\r\n        handshakeHash = md5.digest(handshake.getBytes(\"UTF-16LE\"));\r\n    } catch (UnsupportedEncodingException e) {\r\n        logger.error(\"This version of Java does not understand UTF-16LE encoding\");\r\n        return \"\";\r\n    }\r\n    String response = challenge.concat(\"-\");\r\n    for (byte handshakeByte : handshakeHash) {\r\n        response = response.concat(String.format(\"x\", handshakeByte));\r\n    }\r\n    return response;\r\n}"
}, {
	"Path": "org.openhab.binding.dlinksmarthome.internal.DLinkHNAPCommunication.buildRequestAction",
	"Comment": "this is the first soap message used in the login process and is used to retrievethe cookie, challenge and public key used for authentication.",
	"Method": "void buildRequestAction(){\r\n    requestAction.getSOAPHeader().detachNode();\r\n    final SOAPBody soapBody = requestAction.getSOAPBody();\r\n    final SOAPElement soapBodyElem = soapBody.addChildElement(LOGIN, \"\", HNAP_XMLNS);\r\n    soapBodyElem.addChildElement(ACTION).addTextNode(\"request\");\r\n    soapBodyElem.addChildElement(USERNAME).addTextNode(ADMIN);\r\n    soapBodyElem.addChildElement(LOGINPASSWORD);\r\n    soapBodyElem.addChildElement(CAPTCHA);\r\n    final MimeHeaders headers = requestAction.getMimeHeaders();\r\n    headers.addHeader(SOAPACTION, LOGIN_ACTION);\r\n    requestAction.saveChanges();\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxWsClient.connect",
	"Comment": "connect the websocket.attempts to connect to the websocket on a remote miniserver.",
	"Method": "boolean connect(){\r\n    logger.trace(\"[{}] connect() websocket\", debugId);\r\n    stateMachineLock.lock();\r\n    try {\r\n        if (state != ClientState.IDLE) {\r\n            close(\"Attempt to connect a websocket in non-idle state: \" + state);\r\n            return false;\r\n        }\r\n        socket = new LxWebSocket();\r\n        wsClient = new WebSocketClient();\r\n        String message = socket.httpGet(CMD_CFG_API);\r\n        if (message != null) {\r\n            LxJsonSubResponse response = socket.getSubResponse(message);\r\n            if (response != null && response.code == 200 && response.value != null) {\r\n                try {\r\n                    LxJsonCfgApi cfgApi = gson.fromJson(response.value.getAsString(), LxJsonCfgApi.class);\r\n                    swVersion = cfgApi.version;\r\n                    macAddress = cfgApi.snr;\r\n                } catch (JsonSyntaxException | NumberFormatException e) {\r\n                    logger.debug(\"[{}] Error parsing API config response: {}, {}\", debugId, response, e.getMessage());\r\n                }\r\n            } else {\r\n                logger.debug(\"[{}] Http get null or error in reponse for API config request.\", debugId);\r\n            }\r\n        } else {\r\n            logger.debug(\"[{}] Http get failed for API config request.\", debugId);\r\n        }\r\n        try {\r\n            wsClient.start();\r\n            URI target = new URI(\"ws://\" + host.getHostAddress() + \":\" + port + SOCKET_URL);\r\n            ClientUpgradeRequest request = new ClientUpgradeRequest();\r\n            request.setSubProtocols(\"remotecontrol\");\r\n            startResponseTimeout();\r\n            wsClient.connect(socket, target, request);\r\n            setClientState(ClientState.CONNECTING);\r\n            logger.debug(\"[{}] Connecting to server : {} \", debugId, target);\r\n            return true;\r\n        } catch (Exception e) {\r\n            setClientState(ClientState.IDLE);\r\n            close(\"Connection to websocket failed : \" + e.getMessage());\r\n            return false;\r\n        }\r\n    } finally {\r\n        stateMachineLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxWsSecurity.cancel",
	"Comment": "cancel authentication procedure and any pending activities.it is supposed to be overridden by implementing classes.",
	"Method": "void cancel(){\r\n    cancel = true;\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.protocol.NhcAction.getCloseTime",
	"Comment": "get closetime of action.closetime is the time in seconds to fully close a rollershutter.",
	"Method": "Integer getCloseTime(){\r\n    return this.closeTime;\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.RioSystemFavoritesProtocol.handleSystemFavoriteNotification",
	"Comment": "handles any system notifications returned by the russound system",
	"Method": "void handleSystemFavoriteNotification(Matcher m,String resp){\r\n    if (m == null) {\r\n        throw new IllegalArgumentException(\"m (matcher) cannot be null\");\r\n    }\r\n    if (m.groupCount() == 3) {\r\n        try {\r\n            final int favoriteId = Integer.parseInt(m.group(1));\r\n            if (favoriteId >= 1 && favoriteId <= 32) {\r\n                final RioFavorite fav = systemFavorites[favoriteId - 1];\r\n                final String key = m.group(2).toLowerCase();\r\n                final String value = m.group(3);\r\n                switch(key) {\r\n                    case FAV_NAME:\r\n                        fav.setName(value);\r\n                        fireUpdate();\r\n                        break;\r\n                    case FAV_VALID:\r\n                        fav.setValid(!\"false\".equalsIgnoreCase(value));\r\n                        fireUpdate();\r\n                        break;\r\n                    default:\r\n                        logger.warn(\"Unknown system favorite notification: '{}'\", resp);\r\n                        break;\r\n                }\r\n            } else {\r\n                logger.warn(\"Invalid System Favorite Notification (favorite < 1 or > 32): '{}')\", resp);\r\n            }\r\n        } catch (NumberFormatException e) {\r\n            logger.warn(\"Invalid System Favorite Notification (favorite not a parsable integer): '{}')\", resp);\r\n        }\r\n    } else {\r\n        logger.warn(\"Invalid System Notification response: '{}'\", resp);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.dlinksmarthome.internal.DLinkHNAPCommunication.hash",
	"Comment": "used to hash the authentication data such as the login password and the authentication headerfor the detection message.",
	"Method": "String hash(String data,String key){\r\n    final Mac mac = Mac.getInstance(\"HMACMD5\");\r\n    final SecretKeySpec sKey = new SecretKeySpec(key.getBytes(), \"ASCII\");\r\n    mac.init(sKey);\r\n    final byte[] bytes = mac.doFinal(data.getBytes());\r\n    final StringBuilder hashBuf = new StringBuilder();\r\n    for (int i = 0; i < bytes.length; i++) {\r\n        final String hex = Integer.toHexString(0xFF & bytes[i]).toUpperCase();\r\n        if (hex.length() == 1) {\r\n            hashBuf.append('0');\r\n        }\r\n        hashBuf.append(hex);\r\n    }\r\n    return hashBuf.toString();\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.discovery.DSMRMeterDiscoveryService.validateConfiguredMeters",
	"Comment": "validates if the meters configured by the user match with what is detected in the telegram. some meters are asubset of other meters and therefore an invalid configured meter does work, but not all available data isavailable to the user.",
	"Method": "void validateConfiguredMeters(List<Thing> things,Set<DSMRMeterType> configuredMeterTypes){\r\n    final Set<DSMRMeterType> configuredMeters = things.stream().map(Thing::getHandler).filter(DSMRMeterHandler.class::isInstance).map(DSMRMeterHandler.class::cast).map(DSMRMeterHandler::getMeterDescriptor).filter(Objects::nonNull).map(h -> h.getMeterType()).collect(Collectors.toSet());\r\n    final List<DSMRMeterType> invalidConfigured = configuredMeters.stream().filter(dm -> !configuredMeterTypes.contains(dm)).collect(Collectors.toList());\r\n    final List<DSMRMeterType> unconfiguredMeters = configuredMeterTypes.stream().filter(dm -> !configuredMeters.contains(dm)).collect(Collectors.toList());\r\n    if (!invalidConfigured.isEmpty()) {\r\n        reportConfigurationValidationResults(invalidConfigured, unconfiguredMeters);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxServer.addOrUpdateCategory",
	"Comment": "add a new category or update and return existing one with same uuid",
	"Method": "LxCategory addOrUpdateCategory(LxUuid id,String name,String type){\r\n    if (categories == null) {\r\n        return null;\r\n    }\r\n    LxCategory c = findCategory(id);\r\n    if (c != null) {\r\n        c.setName(name);\r\n        c.setType(type);\r\n        return c;\r\n    }\r\n    LxCategory nc = new LxCategory(id, name, type);\r\n    categories.put(id, nc);\r\n    return nc;\r\n}"
}, {
	"Path": "org.openhab.binding.opensprinkler.internal.discovery.OpenSprinklerDiscoveryJob.hasOpenSprinklerDevice",
	"Comment": "determines if an opensprinkler device is available at a given ip address.",
	"Method": "boolean hasOpenSprinklerDevice(String ip){\r\n    try {\r\n        InetAddress address = InetAddress.getByName(ip);\r\n        if (canEstablishConnection(address, DEFAULT_API_PORT)) {\r\n            OpenSprinklerApi openSprinkler = OpenSprinklerApiFactory.getHttpApi(ip, DEFAULT_API_PORT, DEFAULT_ADMIN_PASSWORD);\r\n            return (openSprinkler != null);\r\n        } else {\r\n            logger.trace(\"No OpenSprinkler device found at IP address ({})\", ip);\r\n            return false;\r\n        }\r\n    } catch (Exception exp) {\r\n        logger.debug(\"No OpenSprinkler device found at IP address ({}) because of error: {}\", ip, exp.getMessage());\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.opensprinkler.internal.handler.OpenSprinklerHTTPHandler.onUpdate",
	"Comment": "creates a new polling job to sync state with the opensprinkler device.",
	"Method": "void onUpdate(){\r\n    if (pollingJob == null || pollingJob.isCancelled()) {\r\n        int refresh;\r\n        try {\r\n            refresh = getConfig().as(OpenSprinklerConfig.class).refresh;\r\n        } catch (Exception exp) {\r\n            refresh = this.refreshInterval;\r\n        }\r\n        pollingJob = scheduler.scheduleWithFixedDelay(refreshService, DEFAULT_WAIT_BEFORE_INITIAL_REFRESH, refresh, TimeUnit.SECONDS);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.max.internal.handler.MaxDevicesHandler.sendCCommand",
	"Comment": "trigger update by sending c command.this command is delayed as it takes time to have the updates back from the thermostat",
	"Method": "void sendCCommand(){\r\n    scheduler.schedule(() -> {\r\n        CCommand cmd = new CCommand(rfAddress);\r\n        bridgeHandler.queueCommand(new SendCommand(maxDeviceSerial, cmd, \"Refresh Thermostat Properties\"));\r\n        configSet = false;\r\n    }, COMMUNICATION_DELAY_TIME, TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.utils.NetworkUtils.servicePing",
	"Comment": "try to establish a tcp connection to the given port. returns false if a timeout occurredor the connection was denied.",
	"Method": "boolean servicePing(String host,int port,int timeout){\r\n    SocketAddress socketAddress = new InetSocketAddress(host, port);\r\n    try (Socket socket = new Socket()) {\r\n        socket.connect(socketAddress, timeout);\r\n        return true;\r\n    } catch (ConnectException | SocketTimeoutException | NoRouteToHostException ignored) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.sleepiq.internal.SleepIQHandlerFactory.unregisterBedDiscoveryService",
	"Comment": "unregister the given cloud handler from participating in discovery of new beds.",
	"Method": "void unregisterBedDiscoveryService(SleepIQCloudHandler cloudHandler){\r\n    ThingUID thingUID = cloudHandler.getThing().getUID();\r\n    ServiceRegistration<?> serviceReg = discoveryServiceReg.remove(thingUID);\r\n    if (serviceReg != null) {\r\n        logger.debug(\"Unregistering bed discovery service\");\r\n        serviceReg.unregister();\r\n    }\r\n}"
}, {
	"Path": "view.jme.MyParticleEmitter.emitAllParticles",
	"Comment": "instantly emits all the particles possible to be emitted. any particleswhich are currently inactive will be spawned immediately.",
	"Method": "void emitAllParticles(){\r\n    this.getWorldTransform();\r\n    TempVars vars = TempVars.get();\r\n    BoundingBox bbox = (BoundingBox) this.getMesh().getBound();\r\n    Vector3f min = vars.vect1;\r\n    Vector3f max = vars.vect2;\r\n    bbox.getMin(min);\r\n    bbox.getMax(max);\r\n    if (!Vector3f.isValidVector(min)) {\r\n        min.set(Vector3f.POSITIVE_INFINITY);\r\n    }\r\n    if (!Vector3f.isValidVector(max)) {\r\n        max.set(Vector3f.NEGATIVE_INFINITY);\r\n    }\r\n    while (emitParticle(min, max) != null) ;\r\n    bbox.setMinMax(min, max);\r\n    this.setBoundRefresh();\r\n    vars.release();\r\n}"
}, {
	"Path": "org.openhab.io.neeo.internal.models.NeeoDevice.supportTiming",
	"Comment": "helper method to determine if the device supports timing or not",
	"Method": "boolean supportTiming(NeeoDevice device){\r\n    Objects.requireNonNull(device, \"device must not be null\");\r\n    return !NeeoDeviceType.EXCLUDE.equals(device.type) && !NeeoDeviceType.ACCESSOIRE.equals(device.type) && !NeeoDeviceType.LIGHT.equals(device.type);\r\n}"
}, {
	"Path": "nginx.clojure.asm.Handle.getTag",
	"Comment": "returns the kind of field or method designated by this handle.",
	"Method": "int getTag(){\r\n    return tag;\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.discovery.ZoneDiscoveryService.destroy",
	"Comment": "unregisters this service from the osgi service registry.this object cannot be used aynmore after calling this method.",
	"Method": "void destroy(){\r\n    if (reg != null) {\r\n        reg.unregister();\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.protocol.NikoHomeControlCommunication.getSystemInfo",
	"Comment": "return the object with system info as read from the niko home control controller.",
	"Method": "NhcSystemInfo getSystemInfo(){\r\n    return this.systemInfo;\r\n}"
}, {
	"Path": "org.openhab.binding.lutron.internal.hw.HwDiscoveryService.declareUnknownDimmer",
	"Comment": "called by the bridge when it receives a status update for a dimmer that is not registered.",
	"Method": "void declareUnknownDimmer(String address){\r\n    if (address == null) {\r\n        logger.info(\"Discovered HomeWorks dimmer with no address\");\r\n        return;\r\n    }\r\n    String addressUid = address.replaceAll(\"[\\\\[\\\\]]\", \"\").replaceAll(\":\", \"-\");\r\n    ThingUID bridgeUID = this.handler.getThing().getUID();\r\n    ThingUID uid = new ThingUID(HwConstants.THING_TYPE_HWDIMMER, bridgeUID, addressUid);\r\n    Map<String, Object> props = new HashMap();\r\n    props.put(\"address\", address);\r\n    DiscoveryResult result = DiscoveryResultBuilder.create(uid).withBridge(bridgeUID).withProperties(props).withRepresentationProperty(\"address\").build();\r\n    thingDiscovered(result);\r\n    logger.debug(\"Discovered {}\", uid);\r\n}"
}, {
	"Path": "nginx.clojure.asm.tree.LocalVariableNode.accept",
	"Comment": "makes the given visitor visit this local variable declaration.",
	"Method": "void accept(MethodVisitor mv){\r\n    mv.visitLocalVariable(name, desc, signature, start.getLabel(), end.getLabel(), index);\r\n}"
}, {
	"Path": "org.openhab.binding.innogysmarthome.internal.client.InnogyClient.dispose",
	"Comment": "disposes the client including disconnecting a maybe remaining session.",
	"Method": "void dispose(){\r\n    try {\r\n        uninitializeSession();\r\n        if (httpTransport != null) {\r\n            httpTransport.shutdown();\r\n            httpTransport = null;\r\n        }\r\n        jsonFactory = null;\r\n        requestFactory = null;\r\n        credentialBuilder = null;\r\n    } catch (IOException | ApiException e) {\r\n        logger.debug(\"Error disposing resources: {}\", e.getMessage());\r\n        logger.trace(\"Trace:\", e);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.nest.internal.rest.NestStreamingRestClient.reopenEventSource",
	"Comment": "closes the existing eventsource and opens a new eventsource as workaround when the eventsource fails to reconnectitself.",
	"Method": "void reopenEventSource(){\r\n    try {\r\n        logger.debug(\"Reopening EventSource\");\r\n        closeEventSource(10, TimeUnit.SECONDS);\r\n        logger.debug(\"Opening new EventSource\");\r\n        EventSource localEventSource = createEventSource();\r\n        localEventSource.open();\r\n        eventSource = localEventSource;\r\n    } catch (FailedResolvingNestUrlException e) {\r\n        logger.debug(\"Failed to resolve Nest redirect URL while opening new EventSource\");\r\n    }\r\n}"
}, {
	"Path": "org.openhab.voice.voicerss.internal.cloudapi.VoiceRSSCloudImpl.getTextToSpeech",
	"Comment": "this method will return an input stream to an audio stream for the givenparameters.it will do that using a plain url connection to avoid any externaldependencies.",
	"Method": "InputStream getTextToSpeech(String apiKey,String text,String locale,String audioFormat){\r\n    String url = createURL(apiKey, text, locale, audioFormat);\r\n    logger.debug(\"Call {}\", url);\r\n    URLConnection connection = new URL(url).openConnection();\r\n    int status = ((HttpURLConnection) connection).getResponseCode();\r\n    if (HttpURLConnection.HTTP_OK != status) {\r\n        logger.error(\"Call {} returned HTTP {}\", url, status);\r\n        throw new IOException(\"Could not read from service: HTTP code \" + status);\r\n    }\r\n    if (logger.isTraceEnabled()) {\r\n        for (Entry<String, List<String>> header : connection.getHeaderFields().entrySet()) {\r\n            logger.trace(\"Response.header: {}={}\", header.getKey(), header.getValue());\r\n        }\r\n    }\r\n    String contentType = connection.getHeaderField(\"Content-Type\");\r\n    InputStream is = connection.getInputStream();\r\n    if (contentType.contains(\"text/plain\")) {\r\n        byte[] bytes = new byte[256];\r\n        is.read(bytes, 0, 256);\r\n        try {\r\n            is.close();\r\n        } catch (IOException ex) {\r\n            logger.debug(\"Failed to close inputstream\", ex);\r\n        }\r\n        throw new IOException(\"Could not read audio content, service return an error: \" + new String(bytes, \"UTF-8\"));\r\n    } else {\r\n        return is;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.gardena.internal.util.DateUtils.parseToCalendar",
	"Comment": "converts a string to a calendar, trying different date formats used by gardena.",
	"Method": "Calendar parseToCalendar(String text){\r\n    Date parsedDate = parseToDate(text);\r\n    if (parsedDate != null) {\r\n        Calendar cal = Calendar.getInstance();\r\n        cal.setTime(parsedDate);\r\n        return cal;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "nginx.clojure.asm.tree.analysis.Frame.getStackSize",
	"Comment": "returns the number of values in the operand stack of this frame. long anddouble values are treated as single values.",
	"Method": "int getStackSize(){\r\n    return top;\r\n}"
}, {
	"Path": "nginx.clojure.net.NginxClojureAsynSocket.setConnectTimeout",
	"Comment": "if timeout is negative, it will be ignored. if timeout is 0, this means no timeout.",
	"Method": "void setConnectTimeout(long timeout){\r\n    checkNotClosed();\r\n    setTimeout(s, timeout, -1, -1);\r\n}"
}, {
	"Path": "org.openhab.binding.tplinksmarthome.internal.handler.SmartHomeHandler.updateIpAddress",
	"Comment": "checks if the current configured ip addres is still the same as by which the device is registered on the network.if there is a different ip address for this device it will update the configuration with this ip and start usingthis ip address.",
	"Method": "void updateIpAddress(){\r\n    if (configuration.deviceId == null) {\r\n        return;\r\n    }\r\n    String lastKnownIpAddress = ipAddressService.getLastKnownIpAddress(configuration.deviceId);\r\n    if (lastKnownIpAddress != null && !lastKnownIpAddress.equals(configuration.ipAddress)) {\r\n        Configuration editConfig = editConfiguration();\r\n        editConfig.put(CONFIG_IP, lastKnownIpAddress);\r\n        updateConfiguration(editConfig);\r\n        configuration.ipAddress = lastKnownIpAddress;\r\n        connection.setIpAddress(lastKnownIpAddress);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.io.openhabcloud.internal.CloudClient.sendBroadcastNotification",
	"Comment": "this method sends broadcast notification to the openhab cloud",
	"Method": "void sendBroadcastNotification(String message,String icon,String severity){\r\n    if (isConnected()) {\r\n        JSONObject notificationMessage = new JSONObject();\r\n        try {\r\n            notificationMessage.put(\"message\", message);\r\n            notificationMessage.put(\"icon\", icon);\r\n            notificationMessage.put(\"severity\", severity);\r\n            socket.emit(\"broadcastnotification\", notificationMessage);\r\n        } catch (JSONException e) {\r\n            logger.error(\"{}\", e.getMessage());\r\n        }\r\n    } else {\r\n        logger.debug(\"No connection, notification is not sent\");\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.FieldVisitor.visitEnd",
	"Comment": "visits the end of the field. this method, which is the last one to becalled, is used to inform the visitor that all the annotations andattributes of the field have been visited.",
	"Method": "void visitEnd(){\r\n    if (fv != null) {\r\n        fv.visitEnd();\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.knx.internal.channel.GroupAddressConfiguration.isRead",
	"Comment": "denotes whether the group address is marked to be actively read from.",
	"Method": "boolean isRead(){\r\n    return read;\r\n}"
}, {
	"Path": "geometry.geom2d.algorithm.OffsetOperator.getNextValidSegment",
	"Comment": "ben ici, tant que je ne sais pas comparer les objets par leur reference, je doit fonctionner avec les index",
	"Method": "Segment2D getNextValidSegment(int start){\r\n    Segment2D prev = segments.get(start);\r\n    int index = start;\r\n    Segment2D res = null;\r\n    do {\r\n        index++;\r\n        if (index == segments.size()) {\r\n            index = 0;\r\n        }\r\n        res = segments.get(index);\r\n    } while (res == null && index != start);\r\n    return res;\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassReader.getMaxStringLength",
	"Comment": "returns the maximum length of the strings contained in the constant poolof the class.",
	"Method": "int getMaxStringLength(){\r\n    return maxStringLength;\r\n}"
}, {
	"Path": "org.openhab.binding.opensprinkler.internal.api.OpenSprinklerApiFactory.getGpioApi",
	"Comment": "factory method returns an opensprnkler pi gpio class for control.",
	"Method": "OpenSprinklerApi getGpioApi(int numberOfStations){\r\n    return new OpenSprinklerGpioApi(numberOfStations);\r\n}"
}, {
	"Path": "nginx.clojure.asm.Label.inSameSubroutine",
	"Comment": "returns true if this basic block and the given one belong to a commonsubroutine.",
	"Method": "boolean inSameSubroutine(Label block){\r\n    if ((status & VISITED) == 0 || (block.status & VISITED) == 0) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < srcAndRefPositions.length; ++i) {\r\n        if ((srcAndRefPositions[i] & block.srcAndRefPositions[i]) != 0) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.openhab.binding.solaredge.internal.AtomicReferenceTrait.updateJobReference",
	"Comment": "updates a job reference with a new job. the old job will be cancelled if there is one.",
	"Method": "void updateJobReference(AtomicReference<@Nullable Future<?>> jobReference,Future<?> newJob){\r\n    cancelJob(jobReference.getAndSet(newJob));\r\n}"
}, {
	"Path": "view.jme.MyParticleEmitter.isRandomAngle",
	"Comment": "returns true if every particle spawnedshould have a random facing angle.",
	"Method": "boolean isRandomAngle(){\r\n    return randomAngle;\r\n}"
}, {
	"Path": "org.openhab.binding.satel.internal.command.ReadEventDescCommand.getKind",
	"Comment": "returns kind of description, either short or long, depending on the request.",
	"Method": "int getKind(){\r\n    if (isLongDescription()) {\r\n        return response.getPayload()[2] & 0xff;\r\n    } else {\r\n        return ((response.getPayload()[3] & 0xff) << 8) + (response.getPayload()[4] & 0xff);\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.signature.SignatureWriter.toString",
	"Comment": "returns the signature that was built by this signature writer.",
	"Method": "String toString(){\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.source.RioSourceProtocol.handleSourceNotification",
	"Comment": "handles any source notifications returned by the russound system",
	"Method": "void handleSourceNotification(Matcher m,String resp){\r\n    if (m == null) {\r\n        throw new IllegalArgumentException(\"m (matcher) cannot be null\");\r\n    }\r\n    if (m.groupCount() == 3) {\r\n        try {\r\n            final int notifySource = Integer.parseInt(m.group(1));\r\n            if (notifySource != source) {\r\n                return;\r\n            }\r\n            final String key = m.group(2).toLowerCase();\r\n            final String value = m.group(3);\r\n            switch(key) {\r\n                case SRC_NAME:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCENAME, new StringType(value));\r\n                    break;\r\n                case SRC_TYPE:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCETYPE, new StringType(value));\r\n                    break;\r\n                case SRC_IPADDRESS:\r\n                    setProperty(RioConstants.PROPERTY_SOURCEIPADDRESS, value);\r\n                    break;\r\n                case SRC_COMPOSERNAME:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCECOMPOSERNAME, new StringType(value));\r\n                    break;\r\n                case SRC_CHANNEL:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCECHANNEL, new StringType(value));\r\n                    break;\r\n                case SRC_CHANNELNAME:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCECHANNELNAME, new StringType(value));\r\n                    break;\r\n                case SRC_GENRE:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCEGENRE, new StringType(value));\r\n                    break;\r\n                case SRC_ARTISTNAME:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCEARTISTNAME, new StringType(value));\r\n                    break;\r\n                case SRC_ALBUMNAME:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCEALBUMNAME, new StringType(value));\r\n                    break;\r\n                case SRC_COVERARTURL:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCECOVERARTURL, new StringType(value));\r\n                    break;\r\n                case SRC_PLAYLISTNAME:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCEPLAYLISTNAME, new StringType(value));\r\n                    break;\r\n                case SRC_SONGNAME:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCESONGNAME, new StringType(value));\r\n                    break;\r\n                case SRC_MODE:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCEMODE, new StringType(value));\r\n                    break;\r\n                case SRC_SHUFFLEMODE:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCESHUFFLEMODE, new StringType(value));\r\n                    break;\r\n                case SRC_REPEATMODE:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCEREPEATMODE, new StringType(value));\r\n                    break;\r\n                case SRC_RATING:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCERATING, new StringType(value));\r\n                    break;\r\n                case SRC_PROGRAMSERVICENAME:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCEPROGRAMSERVICENAME, new StringType(value));\r\n                    break;\r\n                case SRC_RADIOTEXT:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCERADIOTEXT, new StringType(value));\r\n                    break;\r\n                case SRC_RADIOTEXT2:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCERADIOTEXT2, new StringType(value));\r\n                    break;\r\n                case SRC_RADIOTEXT3:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCERADIOTEXT3, new StringType(value));\r\n                    break;\r\n                case SRC_RADIOTEXT4:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCERADIOTEXT4, new StringType(value));\r\n                    break;\r\n                case SRC_VOLUME:\r\n                    stateChanged(RioConstants.CHANNEL_SOURCEVOLUME, new StringType(value));\r\n                    break;\r\n                case SRC_MMSCREEN:\r\n                    handleMMChange(RioConstants.CHANNEL_SOURCEMMSCREEN, value);\r\n                    break;\r\n                case SRC_MMTITLE:\r\n                    handleMMChange(RioConstants.CHANNEL_SOURCEMMTITLE, value);\r\n                    break;\r\n                case SRC_MMATTR:\r\n                    handleMMChange(RioConstants.CHANNEL_SOURCEMMATTR, value);\r\n                    break;\r\n                case SRC_MMBTNOK:\r\n                    handleMMChange(RioConstants.CHANNEL_SOURCEMMBUTTONOKTEXT, value);\r\n                    break;\r\n                case SRC_MMBTNBACK:\r\n                    handleMMChange(RioConstants.CHANNEL_SOURCEMMBUTTONBACKTEXT, value);\r\n                    break;\r\n                case SRC_MMHELP:\r\n                    handleMMChange(RioConstants.CHANNEL_SOURCEMMHELPTEXT, value);\r\n                    break;\r\n                case SRC_MMTEXTFIELD:\r\n                    handleMMChange(RioConstants.CHANNEL_SOURCEMMTEXTFIELD, value);\r\n                    break;\r\n                case SRC_MMINFOBLOCK:\r\n                    handleMMChange(RioConstants.CHANNEL_SOURCEMMINFOTEXT, value);\r\n                    break;\r\n                default:\r\n                    logger.warn(\"Unknown source notification: '{}'\", resp);\r\n                    break;\r\n            }\r\n        } catch (NumberFormatException e) {\r\n            logger.warn(\"Invalid Source Notification (source not a parsable integer): '{}')\", resp);\r\n        }\r\n    } else {\r\n        logger.warn(\"Invalid Source Notification response: '{}'\", resp);\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.iinc",
	"Comment": "generates the instruction to increment the given local variable.",
	"Method": "void iinc(int local,int amount){\r\n    mv.visitIincInsn(local, amount);\r\n}"
}, {
	"Path": "org.openhab.binding.onewiregpio.internal.handler.OneWireGPIOHandler.checkConfiguration",
	"Comment": "this method checks if the provided configuration is valid.when invalid parameter is found, default value is assigned.",
	"Method": "boolean checkConfiguration(){\r\n    Configuration configuration = getConfig();\r\n    gpioBusFile = (String) configuration.get(GPIO_BUS_FILE);\r\n    if (StringUtils.isEmpty(gpioBusFile)) {\r\n        logger.debug(\"GPIO_BUS_FILE not set. Please check configuration, and set proper path to w1_slave file.\");\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"The path to the w1_slave sensor data file is missing.\");\r\n        return false;\r\n    }\r\n    refreshTime = ((Number) configuration.get(REFRESH_TIME)).intValue();\r\n    if (refreshTime.intValue() <= 0) {\r\n        logger.warn(\"Refresh time [{}] is not valid. Falling back to default value: {}.\", refreshTime, DEFAULT_REFRESH_TIME);\r\n        refreshTime = DEFAULT_REFRESH_TIME;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "nginx.clojure.asm.tree.InsnList.contains",
	"Comment": "returns true if the given instruction belongs to this list. thismethod always scans the instructions of this list until it finds thegiven instruction or reaches the end of the list.",
	"Method": "boolean contains(AbstractInsnNode insn){\r\n    AbstractInsnNode i = first;\r\n    while (i != null && i != insn) {\r\n        i = i.next;\r\n    }\r\n    return i != null;\r\n}"
}, {
	"Path": "org.openhab.binding.gardena.internal.GardenaSmartImpl.executeRequest",
	"Comment": "communicates with gardena smart home and parses the result.",
	"Method": "T executeRequest(HttpMethod method,String url,Object contentObject,Class<T> result){\r\n    try {\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(\"{} request:  {}\", method, url);\r\n            if (contentObject != null) {\r\n                logger.trace(\"{} data   :  {}\", method, gson.toJson(contentObject));\r\n            }\r\n        }\r\n        Request request = httpClient.newRequest(url).method(method).timeout(config.getConnectionTimeout(), TimeUnit.SECONDS).idleTimeout(config.getConnectionTimeout(), TimeUnit.SECONDS).header(HttpHeader.CONTENT_TYPE, \"application/json\").header(HttpHeader.ACCEPT, \"application/json\").header(HttpHeader.ACCEPT_ENCODING, \"gzip\");\r\n        if (contentObject != null) {\r\n            StringContentProvider content = new StringContentProvider(gson.toJson(contentObject));\r\n            request.content(content);\r\n        }\r\n        if (!result.equals(SessionWrapper.class)) {\r\n            verifySession();\r\n            request.header(\"X-Session\", session.getToken());\r\n        }\r\n        ContentResponse contentResponse = request.send();\r\n        int status = contentResponse.getStatus();\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(\"Status  : {}\", status);\r\n            logger.trace(\"Response: {}\", contentResponse.getContentAsString());\r\n        }\r\n        if (status == 500) {\r\n            throw new GardenaException(gson.fromJson(contentResponse.getContentAsString(), Errors.class).toString());\r\n        } else if (status != 200 && status != 204) {\r\n            throw new GardenaException(String.format(\"Error %s %s\", status, contentResponse.getReason()));\r\n        }\r\n        if (result == NoResult.class) {\r\n            return null;\r\n        }\r\n        return gson.fromJson(contentResponse.getContentAsString(), result);\r\n    } catch (ExecutionException ex) {\r\n        Throwable cause = ex.getCause();\r\n        if (cause instanceof HttpResponseException) {\r\n            HttpResponseException responseException = (HttpResponseException) ex.getCause();\r\n            int status = responseException.getResponse().getStatus();\r\n            if (status == 401) {\r\n                throw new GardenaUnauthorizedException(ex.getCause());\r\n            }\r\n        }\r\n        throw new GardenaException(ex.getMessage(), ex);\r\n    } catch (Exception ex) {\r\n        throw new GardenaException(ex.getMessage(), ex);\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.config.ConfigurationPropertiesBean.getLanguageNamespacesString",
	"Comment": "get the list of namespaces as a json string, for injection into the javascript ui",
	"Method": "String getLanguageNamespacesString(){\r\n    return new Gson().toJson(getLanguageNamespaces());\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.discovery.DSMRMeterDiscoveryService.reportUnregisteredMeters",
	"Comment": "called when a meter equipment identifier is found that has an empty value. this",
	"Method": "void reportUnregisteredMeters(){\r\n    logger.info(\"An unregistered meter has been found. Probably a new meter. Retry discovery once the meter is registered with the energy provider.\");\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.SerialVersionUIDAdder.hasSVUID",
	"Comment": "returns true if the class already has a svuid field. the result of thismethod is only valid when visitend is or has been called.",
	"Method": "boolean hasSVUID(){\r\n    return hasSVUID;\r\n}"
}, {
	"Path": "org.openhab.binding.satel.internal.event.IntegraStateEvent.hasDataForState",
	"Comment": "checks whether data in the event is valid for given type of state.",
	"Method": "boolean hasDataForState(StateType stateType){\r\n    return stateType.getRefreshCommand() == this.command;\r\n}"
}, {
	"Path": "nginx.clojure.net.NginxClojureAsynSocket.setReadTimeout",
	"Comment": "if timeout is negative, it will be ignored. if timeout is 0, this means no timeout.",
	"Method": "void setReadTimeout(long timeout){\r\n    checkNotClosed();\r\n    setTimeout(s, -1, timeout, -1);\r\n}"
}, {
	"Path": "com.github.shyiko.mysql.binlog.event.deserialization.json.JsonStringFormatter.appendString",
	"Comment": "append a string by escaping any characters that must be escaped.",
	"Method": "void appendString(String original){\r\n    for (int i = 0, len = original.length(); i < len; ++i) {\r\n        char c = original.charAt(i);\r\n        int ch = c;\r\n        if (ch < 0 || ch >= ESCAPES.length || ESCAPES[ch] == 0) {\r\n            sb.append(c);\r\n            continue;\r\n        }\r\n        int escape = ESCAPES[ch];\r\n        if (escape > 0) {\r\n            sb.append('\\\\');\r\n            sb.append((char) escape);\r\n        } else {\r\n            unicodeEscape(ch);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.urtsi.internal.mapping.UrtsiChannelMapping.getMappedChannel",
	"Comment": "returns the mapped channel which is used to communicate with the urtsi ii device. returns null if the givenchannel is not valid.",
	"Method": "String getMappedChannel(String configuredChannel){\r\n    int channel = Integer.parseInt(configuredChannel, 16);\r\n    if (channel == 0) {\r\n        channel = 16;\r\n    }\r\n    if (channel < 1 || channel > 16) {\r\n        return null;\r\n    }\r\n    return String.format(\"d\", channel);\r\n}"
}, {
	"Path": "org.openhab.binding.lutron.internal.grxprg.GrafikEyeHandler.setFade",
	"Comment": "helper method to set the fade level. will store the fade and update its state.",
	"Method": "void setFade(int fade){\r\n    if (fade < 0 || fade > 3600) {\r\n        throw new IllegalArgumentException(\"fade must be between 1-3600\");\r\n    }\r\n    _fade = fade;\r\n    updateState(PrgConstants.CHANNEL_ZONEFADE, new DecimalType(_fade));\r\n}"
}, {
	"Path": "org.openhab.binding.pioneeravr.internal.protocol.RequestResponseFactory.getIpControlCommand",
	"Comment": "return a parameterizedcommand of the type given in parameter. theparameter of the command is set with the given paramter value.",
	"Method": "SimpleCommand getIpControlCommand(SimpleCommandType command,int zone,ParameterizedCommand getIpControlCommand,ParameterizedCommandType command,int zone,ParameterizedCommand getIpControlCommand,ParameterizedCommandType command,String parameter,int zone){\r\n    ParameterizedCommand result = getIpControlCommand(command, zone);\r\n    result.setParameter(parameter);\r\n    return result;\r\n}"
}, {
	"Path": "org.openhab.binding.knx.internal.handler.DeviceThingHandler.onGroupWrite",
	"Comment": "knxio, here value changes are set, coming from knx or openhab.",
	"Method": "void onGroupWrite(AbstractKNXClient client,IndividualAddress source,GroupAddress destination,byte[] asdu){\r\n    logger.debug(\"onGroupWrite Thing '{}' received a GroupValueWrite telegram from '{}' for destination '{}'\", getThing().getUID(), source, destination);\r\n    for (Channel channel : getThing().getChannels()) {\r\n        withKNXType(channel, (selector, configuration) -> {\r\n            InboundSpec listenSpec = selector.getListenSpec(configuration, destination);\r\n            if (listenSpec != null) {\r\n                logger.trace(\"onGroupWrite Thing '{}' processes a GroupValueWrite telegram for destination '{}' for channel '{}'\", getThing().getUID(), destination, channel.getUID());\r\n                if (isControl(channel.getUID())) {\r\n                    logger.trace(\"onGroupWrite isControl\");\r\n                    Type type = typeHelper.toType(new CommandDP(destination, getThing().getUID().toString(), 0, listenSpec.getDPT()), asdu);\r\n                    if (type != null) {\r\n                        OutboundSpec commandSpec = selector.getCommandSpec(configuration, typeHelper, type);\r\n                        if (commandSpec != null) {\r\n                            GroupAddress mainGa = getKNXChannelMainGA(channel);\r\n                            if (getRespondingSpecValue(mainGa) != commandSpec.getType()) {\r\n                                if (destination.equals(mainGa)) {\r\n                                    logger.trace(\"onGroupWrite mainGA groupAddressesWriteExposeOnce: '{}'\", destination);\r\n                                    groupAddressesWriteBlockedOnce.add(destination);\r\n                                }\r\n                                processDataReceived(destination, asdu, listenSpec, channel.getUID());\r\n                            }\r\n                            rememberRespondingSpec(commandSpec, true);\r\n                        }\r\n                    }\r\n                } else {\r\n                    processDataReceived(destination, asdu, listenSpec, channel.getUID());\r\n                }\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxServer.addOrUpdateControl",
	"Comment": "add a new control and its states or update and return existing one with same uuid",
	"Method": "void addOrUpdateControl(LxJsonApp3.LxJsonControl json){\r\n    if (json == null || json.uuidAction == null || json.name == null || json.type == null) {\r\n        return;\r\n    }\r\n    LxUuid categoryId = null;\r\n    if (json.cat != null) {\r\n        categoryId = new LxUuid(json.cat);\r\n    }\r\n    LxUuid roomId = null;\r\n    if (json.room != null) {\r\n        roomId = new LxUuid(json.room);\r\n    }\r\n    LxContainer room = findRoom(roomId);\r\n    LxCategory category = findCategory(categoryId);\r\n    LxUuid id = new LxUuid(json.uuidAction);\r\n    LxControl control = findControl(id);\r\n    if (control != null) {\r\n        control.update(json, room, category);\r\n    } else {\r\n        control = LxControlFactory.createControl(socketClient, id, json, room, category);\r\n    }\r\n    if (control != null) {\r\n        updateControls(control);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.harmonyhub.internal.handler.HarmonyHubHandler.updateCurrentActivityChannel",
	"Comment": "updates the current activity channel with the available activities as option states.",
	"Method": "void updateCurrentActivityChannel(HarmonyConfig config){\r\n    ChannelTypeUID channelTypeUID = new ChannelTypeUID(getThing().getUID() + \":\" + CHANNEL_CURRENT_ACTIVITY);\r\n    if (config == null) {\r\n        logger.debug(\"Cannot update {} when HarmonyConfig is null\", channelTypeUID);\r\n        return;\r\n    }\r\n    logger.debug(\"Updating {}\", channelTypeUID);\r\n    List<Activity> activities = config.getActivities();\r\n    Collections.sort(activities, ACTIVITY_COMPERATOR);\r\n    List<StateOption> states = new LinkedList();\r\n    for (Activity activity : activities) {\r\n        states.add(new StateOption(activity.getLabel(), activity.getLabel()));\r\n    }\r\n    ChannelType channelType = ChannelTypeBuilder.state(channelTypeUID, \"Current Activity\", \"String\").withDescription(\"Current activity for \" + getThing().getLabel()).withStateDescription(new StateDescription(null, null, null, \"%s\", false, states)).build();\r\n    factory.addChannelType(channelType);\r\n    Channel channel = ChannelBuilder.create(new ChannelUID(getThing().getUID(), CHANNEL_CURRENT_ACTIVITY), \"String\").withType(channelTypeUID).build();\r\n    List<Channel> newChannels = new ArrayList();\r\n    for (Channel c : getThing().getChannels()) {\r\n        if (!c.getUID().equals(channel.getUID())) {\r\n            newChannels.add(c);\r\n        }\r\n    }\r\n    newChannels.add(channel);\r\n    BridgeBuilder thingBuilder = editThing();\r\n    thingBuilder.withChannels(newChannels);\r\n    updateThing(thingBuilder.build());\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.zone.RioZoneProtocol.handleZoneNotification",
	"Comment": "handles any zone notifications returned by the russound system",
	"Method": "void handleZoneNotification(Matcher m,String resp){\r\n    if (m == null) {\r\n        throw new IllegalArgumentException(\"m (matcher) cannot be null\");\r\n    }\r\n    if (m.groupCount() == 4) {\r\n        try {\r\n            final int notifyController = Integer.parseInt(m.group(1));\r\n            if (notifyController != controller) {\r\n                return;\r\n            }\r\n            final int notifyZone = Integer.parseInt(m.group(2));\r\n            if (notifyZone != zone) {\r\n                return;\r\n            }\r\n            final String key = m.group(3).toLowerCase();\r\n            final String value = m.group(4);\r\n            switch(key) {\r\n                case ZONE_NAME:\r\n                    stateChanged(RioConstants.CHANNEL_ZONENAME, new StringType(value));\r\n                    break;\r\n                case ZONE_SOURCE:\r\n                    try {\r\n                        final int nbr = Integer.parseInt(value);\r\n                        stateChanged(RioConstants.CHANNEL_ZONESOURCE, new DecimalType(nbr));\r\n                        if (nbr != sourceId.getAndSet(nbr)) {\r\n                            sourceId.set(nbr);\r\n                            presetsUpdated(nbr, presetsProtocol.getJson(nbr));\r\n                        }\r\n                    } catch (NumberFormatException e) {\r\n                        logger.warn(\"Invalid zone notification (source not parsable): '{}')\", resp);\r\n                    }\r\n                    break;\r\n                case ZONE_BASS:\r\n                    try {\r\n                        final int nbr = Integer.parseInt(value);\r\n                        stateChanged(RioConstants.CHANNEL_ZONEBASS, new DecimalType(nbr));\r\n                    } catch (NumberFormatException e) {\r\n                        logger.warn(\"Invalid zone notification (bass not parsable): '{}')\", resp);\r\n                    }\r\n                    break;\r\n                case ZONE_TREBLE:\r\n                    try {\r\n                        final int nbr = Integer.parseInt(value);\r\n                        stateChanged(RioConstants.CHANNEL_ZONETREBLE, new DecimalType(nbr));\r\n                    } catch (NumberFormatException e) {\r\n                        logger.warn(\"Invalid zone notification (treble not parsable): '{}')\", resp);\r\n                    }\r\n                    break;\r\n                case ZONE_BALANCE:\r\n                    try {\r\n                        final int nbr = Integer.parseInt(value);\r\n                        stateChanged(RioConstants.CHANNEL_ZONEBALANCE, new DecimalType(nbr));\r\n                    } catch (NumberFormatException e) {\r\n                        logger.warn(\"Invalid zone notification (balance not parsable): '{}')\", resp);\r\n                    }\r\n                    break;\r\n                case ZONE_LOUDNESS:\r\n                    stateChanged(RioConstants.CHANNEL_ZONELOUDNESS, \"ON\".equals(value) ? OnOffType.ON : OnOffType.OFF);\r\n                    break;\r\n                case ZONE_TURNONVOLUME:\r\n                    try {\r\n                        final int nbr = Integer.parseInt(value);\r\n                        stateChanged(RioConstants.CHANNEL_ZONETURNONVOLUME, new PercentType(nbr * 2));\r\n                    } catch (NumberFormatException e) {\r\n                        logger.warn(\"Invalid zone notification (turnonvolume not parsable): '{}')\", resp);\r\n                    }\r\n                    break;\r\n                case ZONE_DONOTDISTURB:\r\n                    stateChanged(RioConstants.CHANNEL_ZONEDONOTDISTURB, new StringType(value));\r\n                    break;\r\n                case ZONE_PARTYMODE:\r\n                    stateChanged(RioConstants.CHANNEL_ZONEPARTYMODE, new StringType(value));\r\n                    break;\r\n                case ZONE_STATUS:\r\n                    stateChanged(RioConstants.CHANNEL_ZONESTATUS, \"ON\".equals(value) ? OnOffType.ON : OnOffType.OFF);\r\n                    break;\r\n                case ZONE_MUTE:\r\n                    stateChanged(RioConstants.CHANNEL_ZONEMUTE, \"ON\".equals(value) ? OnOffType.ON : OnOffType.OFF);\r\n                    break;\r\n                case ZONE_SHAREDSOURCE:\r\n                    stateChanged(RioConstants.CHANNEL_ZONESHAREDSOURCE, \"ON\".equals(value) ? OnOffType.ON : OnOffType.OFF);\r\n                    break;\r\n                case ZONE_LASTERROR:\r\n                    stateChanged(RioConstants.CHANNEL_ZONELASTERROR, new StringType(value));\r\n                    break;\r\n                case ZONE_PAGE:\r\n                    stateChanged(RioConstants.CHANNEL_ZONEPAGE, \"ON\".equals(value) ? OnOffType.ON : OnOffType.OFF);\r\n                    break;\r\n                case ZONE_SLEEPTIMEREMAINING:\r\n                    try {\r\n                        final int nbr = Integer.parseInt(value);\r\n                        stateChanged(RioConstants.CHANNEL_ZONESLEEPTIMEREMAINING, new DecimalType(nbr));\r\n                    } catch (NumberFormatException e) {\r\n                        logger.warn(\"Invalid zone notification (sleeptimeremaining not parsable): '{}')\", resp);\r\n                    }\r\n                    break;\r\n                case ZONE_ENABLED:\r\n                    stateChanged(RioConstants.CHANNEL_ZONEENABLED, \"ON\".equals(value) ? OnOffType.ON : OnOffType.OFF);\r\n                    break;\r\n                case ZONE_VOLUME:\r\n                    try {\r\n                        final int nbr = Integer.parseInt(value);\r\n                        stateChanged(RioConstants.CHANNEL_ZONEVOLUME, new PercentType(nbr * 2));\r\n                    } catch (NumberFormatException e) {\r\n                        logger.warn(\"Invalid zone notification (volume not parsable): '{}')\", resp);\r\n                    }\r\n                    break;\r\n                default:\r\n                    logger.warn(\"Unknown zone notification: '{}'\", resp);\r\n                    break;\r\n            }\r\n        } catch (NumberFormatException e) {\r\n            logger.warn(\"Invalid Zone Notification (controller/zone not a parsable integer): '{}')\", resp);\r\n        }\r\n    } else {\r\n        logger.warn(\"Invalid Zone Notification response: '{}'\", resp);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.tplinksmarthome.internal.CryptUtil.encryptWithLength",
	"Comment": "encrypts the string into a byte array with the first for bytes specifying the length of the given string. thelength is not encrypted.",
	"Method": "byte[] encryptWithLength(String string){\r\n    ByteBuffer bb = ByteBuffer.allocate(4 + string.length());\r\n    bb.putInt(string.length());\r\n    bb.put(encrypt(string));\r\n    return bb.array();\r\n}"
}, {
	"Path": "nginx.clojure.asm.ByteVector.putLong",
	"Comment": "puts a long into this byte vector. the byte vector is automaticallyenlarged if necessary.",
	"Method": "ByteVector putLong(long l){\r\n    int length = this.length;\r\n    if (length + 8 > data.length) {\r\n        enlarge(8);\r\n    }\r\n    byte[] data = this.data;\r\n    int i = (int) (l >>> 32);\r\n    data[length++] = (byte) (i >>> 24);\r\n    data[length++] = (byte) (i >>> 16);\r\n    data[length++] = (byte) (i >>> 8);\r\n    data[length++] = (byte) i;\r\n    i = (int) l;\r\n    data[length++] = (byte) (i >>> 24);\r\n    data[length++] = (byte) (i >>> 16);\r\n    data[length++] = (byte) (i >>> 8);\r\n    data[length++] = (byte) i;\r\n    this.length = length;\r\n    return this;\r\n}"
}, {
	"Path": "com.github.shyiko.mysql.binlog.BinaryLogClient.registerEventListener",
	"Comment": "register event listener. note that multiple event listeners will be called in order theywhere registered.",
	"Method": "void registerEventListener(EventListener eventListener){\r\n    eventListeners.add(eventListener);\r\n}"
}, {
	"Path": "org.openhab.binding.pioneeravr.internal.protocol.RequestResponseFactory.getIpControlResponse",
	"Comment": "return a ipcontrolresponse object based on the given response data.",
	"Method": "Response getIpControlResponse(String responseData){\r\n    return new Response(responseData);\r\n}"
}, {
	"Path": "org.openhab.io.neeo.NeeoService.brainDiscovered",
	"Comment": "called when a brain is discovered. this method will start a new servlet for the brains hostname.",
	"Method": "void brainDiscovered(NeeoSystemInfo sysInfo,InetAddress ipAddress){\r\n    Objects.requireNonNull(sysInfo, \"sysInfo cannot be null\");\r\n    Objects.requireNonNull(ipAddress, \"ipAddress cannot be null\");\r\n    final ServiceContext localContext = context;\r\n    if (localContext != null) {\r\n        final String servletUrl = NeeoUtil.getServletUrl(sysInfo.getHostname());\r\n        if (getServletByUrl(servletUrl) == null) {\r\n            logger.debug(\"Brain discovered: {} at {} and starting servlet at {}\", sysInfo.getHostname(), ipAddress, servletUrl);\r\n            try {\r\n                final NeeoBrainServlet newServlet = NeeoBrainServlet.create(localContext, servletUrl, sysInfo.getHostname(), ipAddress);\r\n                servlets.add(newServlet);\r\n                localContext.getHttpService().registerServlet(servletUrl, newServlet, new Hashtable<String, String>(), localContext.getHttpService().createDefaultHttpContext());\r\n                logger.debug(\"Started NEEO Listener at {}\", servletUrl);\r\n            } catch (NamespaceException | ServletException | IOException e) {\r\n                logger.error(\"Error during servlet startup\", e);\r\n            }\r\n        } else {\r\n            logger.debug(\"Brain servlet with URL of {} already exists - ignored\", servletUrl);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.max.internal.handler.SendCommand.getKey",
	"Comment": "get the key based on the serial and channelthis is can be used to find duplicated commands in the queue",
	"Method": "String getKey(String serialNumber,ChannelUID channelUID,String getKey,String serialNumber,CubeCommand cubeCommand,String getKey){\r\n    return key;\r\n}"
}, {
	"Path": "org.openhab.binding.modbus.internal.config.ModbusPollerConfiguration.getCacheMillis",
	"Comment": "gets time to cache data.this is used for reusing cached data with explicit refresh calls.",
	"Method": "long getCacheMillis(){\r\n    return cacheMillis;\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.zone.RioZoneProtocol.presetsUpdated",
	"Comment": "callback method when presets are updated. simply issues a state change for the zone presets channel using thejsonstring as the value",
	"Method": "void presetsUpdated(int sourceIdUpdated,String jsonString){\r\n    if (sourceIdUpdated != sourceId.get()) {\r\n        return;\r\n    }\r\n    stateChanged(RioConstants.CHANNEL_ZONEPRESETS, new StringType(jsonString));\r\n}"
}, {
	"Path": "org.openhab.binding.minecraft.internal.handler.MinecraftServerHandler.connectToServer",
	"Comment": "directly connect to server.reconnects when connection is lost",
	"Method": "void connectToServer(){\r\n    String host = config.getHostname();\r\n    int port = config.getPort();\r\n    serverConnectionRX = ServerConnection.create(getThing().getUID(), host, port).doOnNext(item -> updateOnlineState(true)).doOnError(e -> updateOnlineState(false)).retryWhen(new RetryWithDelay(1, TimeUnit.MINUTES)).repeat().replay(1).refCount();\r\n    Subscription serverUpdateSubscription = serverConnectionRX.flatMap(connection -> connection.getSocketHandler().getServerRx()).subscribe(serverData -> updateServerState(serverData));\r\n    Subscription serverConnectionSubscription = serverConnectionRX.subscribe(connection -> {\r\n        this.connection = connection;\r\n    });\r\n    subscription.add(serverUpdateSubscription);\r\n    subscription.add(serverConnectionSubscription);\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.handler.NikoHomeControlBridgeHandler.triggerNotice",
	"Comment": "send a trigger from a notice received from niko home control.",
	"Method": "void triggerNotice(String alarmText){\r\n    triggerChannel(CHANNEL_NOTICE, alarmText);\r\n    updateStatus(ThingStatus.ONLINE);\r\n}"
}, {
	"Path": "org.openhab.binding.squeezebox.internal.SqueezeBoxHandlerFactory.registerSqueezeBoxPlayerDiscoveryService",
	"Comment": "adds squeezeboxserverhandlers to the discovery service to find squeezeboxplayers",
	"Method": "void registerSqueezeBoxPlayerDiscoveryService(SqueezeBoxServerHandler squeezeBoxServerHandler){\r\n    logger.trace(\"registering player discovery service\");\r\n    SqueezeBoxPlayerDiscoveryParticipant discoveryService = new SqueezeBoxPlayerDiscoveryParticipant(squeezeBoxServerHandler);\r\n    squeezeBoxServerHandler.registerSqueezeBoxPlayerListener(discoveryService);\r\n    discoveryServiceRegs.put(squeezeBoxServerHandler.getThing().getUID(), bundleContext.registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<String, Object>()));\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.protocol.xml.XMLProtocolService.getInputs",
	"Comment": "sends a request to retrieve the input values available for the zone.",
	"Method": "Collection<InputDto> getInputs(AbstractConnection con,Zone zone){\r\n    Node inputSelItem = getZoneResponse(con, zone, ZONE_INPUT_QUERY, ZONE_INPUT_PATH);\r\n    List<InputDto> inputs = new LinkedList();\r\n    XMLUtils.getChildElements(inputSelItem).forEach(item -> {\r\n        String param = item.getElementsByTagName(\"Param\").item(0).getTextContent();\r\n        boolean writable = item.getElementsByTagName(\"RW\").item(0).getTextContent().contains(\"W\");\r\n        inputs.add(new InputDto(param, writable));\r\n    });\r\n    if (LOGGER.isTraceEnabled()) {\r\n        LOGGER.trace(\"Zone {} - inputs: {}\", zone, inputs.stream().map(InputDto::toString).collect(joining(\", \")));\r\n    }\r\n    return inputs;\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.SerialVersionUIDAdder.writeItems",
	"Comment": "sorts the items in the collection and writes it to the data output stream",
	"Method": "void writeItems(Collection<Item> itemCollection,DataOutput dos,boolean dotted){\r\n    int size = itemCollection.size();\r\n    Item[] items = itemCollection.toArray(new Item[size]);\r\n    Arrays.sort(items);\r\n    for (int i = 0; i < size; i++) {\r\n        dos.writeUTF(items[i].name);\r\n        dos.writeInt(items[i].access);\r\n        dos.writeUTF(dotted ? items[i].desc.replace('/', '.') : items[i].desc);\r\n    }\r\n}"
}, {
	"Path": "view.jme.MyParticleEmitter.setRandomAngle",
	"Comment": "set to true if every particle spawnedshould have a random facing angle.",
	"Method": "void setRandomAngle(boolean randomAngle){\r\n    this.randomAngle = randomAngle;\r\n}"
}, {
	"Path": "org.openhab.binding.powermax.internal.message.PowermaxBaseMessage.getMessageHandler",
	"Comment": "instantiate a class for handling a received message the class depends on the message.",
	"Method": "PowermaxBaseMessage getMessageHandler(byte[] message){\r\n    PowermaxBaseMessage msgHandler;\r\n    try {\r\n        PowermaxReceiveType msgType = PowermaxReceiveType.fromCode(message[1]);\r\n        switch(msgType) {\r\n            case ACK:\r\n                msgHandler = new PowermaxAckMessage(message);\r\n                break;\r\n            case TIMEOUT:\r\n                msgHandler = new PowermaxTimeoutMessage(message);\r\n                break;\r\n            case DENIED:\r\n                msgHandler = new PowermaxDeniedMessage(message);\r\n                break;\r\n            case DOWNLOAD_RETRY:\r\n                msgHandler = new PowermaxDownloadRetryMessage(message);\r\n                break;\r\n            case SETTINGS:\r\n            case SETTINGS_ITEM:\r\n                msgHandler = new PowermaxSettingsMessage(message);\r\n                break;\r\n            case INFO:\r\n                msgHandler = new PowermaxInfoMessage(message);\r\n                break;\r\n            case EVENT_LOG:\r\n                msgHandler = new PowermaxEventLogMessage(message);\r\n                break;\r\n            case ZONESNAME:\r\n                msgHandler = new PowermaxZonesNameMessage(message);\r\n                break;\r\n            case STATUS:\r\n                msgHandler = new PowermaxStatusMessage(message);\r\n                break;\r\n            case ZONESTYPE:\r\n                msgHandler = new PowermaxZonesTypeMessage(message);\r\n                break;\r\n            case PANEL:\r\n                msgHandler = new PowermaxPanelMessage(message);\r\n                break;\r\n            case POWERLINK:\r\n                msgHandler = new PowermaxPowerlinkMessage(message);\r\n                break;\r\n            case POWERMASTER:\r\n                msgHandler = new PowermaxPowerMasterMessage(message);\r\n                break;\r\n            default:\r\n                msgHandler = new PowermaxBaseMessage(message);\r\n                break;\r\n        }\r\n    } catch (IllegalArgumentException e) {\r\n        msgHandler = new PowermaxBaseMessage(message);\r\n    }\r\n    return msgHandler;\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.ModbusBitUtilities.extractStringFromRegisters",
	"Comment": "read data from registers and convert the result to stringtypestrings should start the the first byte of a register, but couldhave an odd number of characters.raw byte array values are converted using the charset parameterand a maximum of length bytes are read. however reading stops at the firstnul byte encountered.",
	"Method": "StringType extractStringFromRegisters(ModbusRegisterArray registers,int index,int length,Charset charset){\r\n    if (index * 2 + length > registers.size() * 2) {\r\n        throw new IllegalArgumentException(String.format(\"Index=%d with length=%d is out-of-bounds given registers of size %d\", index, length, registers.size()));\r\n    }\r\n    if (index < 0) {\r\n        throw new IllegalArgumentException(\"Negative index values are not supported\");\r\n    }\r\n    if (length < 0) {\r\n        throw new IllegalArgumentException(\"Negative string length is not supported\");\r\n    }\r\n    byte[] buff = new byte[length];\r\n    int src = index;\r\n    int dest;\r\n    for (dest = 0; dest < length; dest++) {\r\n        byte chr;\r\n        if (dest % 2 == 0) {\r\n            chr = (byte) ((registers.getRegister(src).getValue() >> 8));\r\n        } else {\r\n            chr = (byte) (registers.getRegister(src).getValue() & 0xff);\r\n            src++;\r\n        }\r\n        if (chr == 0) {\r\n            break;\r\n        }\r\n        buff[dest] = chr;\r\n    }\r\n    return new StringType(new String(buff, 0, dest, charset));\r\n}"
}, {
	"Path": "nginx.clojure.net.NginxClojureAsynChannel.setWriteTimeout",
	"Comment": "if timeout is negative, it will be ignored. if timeout is 0, this means no timeout.",
	"Method": "void setWriteTimeout(long timeout){\r\n    check();\r\n    as.setTimeout(-1, -1, timeout);\r\n}"
}, {
	"Path": "org.openhab.binding.lgwebos.handler.LGWebOSHandler.onDeviceAdded",
	"Comment": "just to make sure, this device is registered, if it was powered off during initialization",
	"Method": "void onDeviceAdded(DiscoveryManager manager,ConnectableDevice device){\r\n    if (device.getId().equals(deviceId)) {\r\n        device.removeListener(this);\r\n        device.addListener(this);\r\n        updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, \"Device Ready\");\r\n        device.connect();\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.config.JsonMessageSource.getValue",
	"Comment": "get a value from the set of maps, taking the first match in order",
	"Method": "String getValue(String code,List<JsonObject> langs,String getValue,String code,JsonObject lang){\r\n    if (lang == null) {\r\n        return null;\r\n    }\r\n    JsonElement e = lang;\r\n    Iterable<String> parts = Splitter.on('.').split(code);\r\n    Iterator<String> it = parts.iterator();\r\n    String value = null;\r\n    while (it.hasNext()) {\r\n        String p = it.next();\r\n        if (e.isJsonObject()) {\r\n            JsonObject o = e.getAsJsonObject();\r\n            if (o.has(p)) {\r\n                e = o.get(p);\r\n                if (!it.hasNext()) {\r\n                    if (e.isJsonPrimitive()) {\r\n                        value = e.getAsString();\r\n                    }\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.protocol.xml.InputWithNavigationControlXML.selectCurrentItem",
	"Comment": "select current item. not for all zones or functions available.",
	"Method": "void selectCurrentItem(){\r\n    navigateCursor(\"Select\");\r\n}"
}, {
	"Path": "org.openhab.binding.powermax.internal.state.PowermaxPanelSettings.process",
	"Comment": "process and store all the panel settings from the raw buffers",
	"Method": "boolean process(boolean PowerlinkMode,PowermaxPanelType defaultPanelType,Long timeSet){\r\n    logger.debug(\"Process settings Powerlink {}\", PowerlinkMode);\r\n    boolean result = true;\r\n    boolean result2;\r\n    byte[] data;\r\n    panelType = defaultPanelType;\r\n    if (PowerlinkMode) {\r\n        data = readSettings(PowermaxSendType.DL_SERIAL, 7, 7);\r\n        if (data != null) {\r\n            try {\r\n                panelType = PowermaxPanelType.fromCode(data[0]);\r\n            } catch (IllegalArgumentException e) {\r\n                logger.debug(\"Powermax alarm binding: unknwon panel type for code {}\", data[0] & 0x000000FF);\r\n                panelType = defaultPanelType;\r\n            }\r\n        } else {\r\n            logger.debug(\"Cannot get panel type\");\r\n            result = false;\r\n        }\r\n    }\r\n    int zoneCnt = panelType.getWireless() + panelType.getWired();\r\n    int customCnt = panelType.getCustomZones();\r\n    int userCnt = panelType.getUserCodes();\r\n    int partitionCnt = panelType.getPartitions();\r\n    int sirenCnt = panelType.getSirens();\r\n    int keypad1wCnt = panelType.getKeypads1w();\r\n    int keypad2wCnt = panelType.getKeypads2w();\r\n    phoneNumbers = new String[4];\r\n    bellTime = 4;\r\n    silentPanic = false;\r\n    quickArm = false;\r\n    bypassEnabled = false;\r\n    partitionsEnabled = false;\r\n    pinCodes = new String[userCnt];\r\n    panelEprom = null;\r\n    panelSoftware = null;\r\n    panelSerial = null;\r\n    zoneSettings = new PowermaxZoneSettings[zoneCnt];\r\n    x10Settings = new PowermaxX10Settings[NB_PGM_X10_DEVICES];\r\n    keypad1wEnrolled = new boolean[keypad1wCnt];\r\n    keypad2wEnrolled = new boolean[keypad2wCnt];\r\n    sirensEnrolled = new boolean[sirenCnt];\r\n    if (PowerlinkMode) {\r\n        data = readSettings(PowermaxSendType.DL_TIME, 0, 5);\r\n        if (data != null) {\r\n            GregorianCalendar cal = new GregorianCalendar();\r\n            cal.set(Calendar.MILLISECOND, 0);\r\n            cal.set(Calendar.SECOND, data[0] & 0x000000FF);\r\n            cal.set(Calendar.MINUTE, data[1] & 0x000000FF);\r\n            cal.set(Calendar.HOUR_OF_DAY, data[2] & 0x000000FF);\r\n            cal.set(Calendar.DAY_OF_MONTH, data[3] & 0x000000FF);\r\n            cal.set(Calendar.MONTH, (data[4] & 0x000000FF) - 1);\r\n            cal.set(Calendar.YEAR, (data[5] & 0x000000FF) + 2000);\r\n            long timeRead = cal.getTimeInMillis();\r\n            logger.debug(\"Powermax alarm binding: time {}\", String.format(\"d/d/d d:d:d\", cal.get(Calendar.DAY_OF_MONTH), cal.get(Calendar.MONTH) + 1, cal.get(Calendar.YEAR), cal.get(Calendar.HOUR_OF_DAY), cal.get(Calendar.MINUTE), cal.get(Calendar.SECOND)));\r\n            if (timeSet != null) {\r\n                long delta = (timeRead - timeSet) / 1000;\r\n                if (delta <= 5) {\r\n                    logger.debug(\"Powermax alarm binding: time sync OK (delta {} s)\", delta);\r\n                } else {\r\n                    logger.info(\"Powermax alarm binding: time sync failed ! (delta {} s)\", delta);\r\n                }\r\n            }\r\n        } else {\r\n            logger.debug(\"Cannot get time and date settings\");\r\n            result = false;\r\n        }\r\n        result2 = true;\r\n        for (int i = 0; i < (26 + customCnt); i++) {\r\n            String str = readSettingsAsString(PowermaxSendType.DL_ZONESTR, i * 16, (i + 1) * 16 - 1);\r\n            if (str != null) {\r\n                try {\r\n                    PowermaxZoneName zoneName = PowermaxZoneName.fromId(i);\r\n                    zoneName.setName(str);\r\n                } catch (IllegalArgumentException e) {\r\n                    logger.debug(\"Zone id out of bounds {}\", i);\r\n                }\r\n            } else {\r\n                result2 = false;\r\n            }\r\n        }\r\n        if (!result2) {\r\n            logger.debug(\"Cannot get all zone names\");\r\n            result = false;\r\n        }\r\n        result2 = true;\r\n        for (int i = 0; i < phoneNumbers.length; i++) {\r\n            data = readSettings(PowermaxSendType.DL_PHONENRS, 8 * i, 8 * i + 7);\r\n            if (data != null) {\r\n                for (int j = 0; j < 8; j++) {\r\n                    if ((data[j] & 0x000000FF) != 0x000000FF) {\r\n                        if (j == 0) {\r\n                            phoneNumbers[i] = \"\";\r\n                        }\r\n                        if (phoneNumbers[i] != null) {\r\n                            phoneNumbers[i] += String.format(\"X\", data[j] & 0x000000FF);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                result2 = false;\r\n            }\r\n        }\r\n        if (!result2) {\r\n            logger.debug(\"Cannot get all communication settings\");\r\n            result = false;\r\n        }\r\n        data = readSettings(PowermaxSendType.DL_COMMDEF, 0, 0x1B);\r\n        if (data != null) {\r\n            bellTime = data[3] & 0x000000FF;\r\n            silentPanic = (data[0x19] & 0x00000010) == 0x00000010;\r\n            quickArm = (data[0x1A] & 0x00000008) == 0x00000008;\r\n            bypassEnabled = (data[0x1B] & 0x000000C0) != 0;\r\n        } else {\r\n            logger.debug(\"Cannot get alarm settings\");\r\n            result = false;\r\n        }\r\n        data = readSettings(panelType.isPowerMaster() ? PowermaxSendType.DL_MR_PINCODES : PowermaxSendType.DL_PINCODES, 0, 2 * userCnt - 1);\r\n        if (data != null) {\r\n            for (int i = 0; i < userCnt; i++) {\r\n                pinCodes[i] = String.format(\"XX\", data[i * 2] & 0x000000FF, data[i * 2 + 1] & 0x000000FF);\r\n            }\r\n        } else {\r\n            logger.debug(\"Cannot get PIN codes\");\r\n            result = false;\r\n        }\r\n        panelEprom = readSettingsAsString(PowermaxSendType.DL_PANELFW, 0, 15);\r\n        if (panelEprom == null) {\r\n            logger.debug(\"Cannot get EEPROM version\");\r\n            result = false;\r\n        }\r\n        panelSoftware = readSettingsAsString(PowermaxSendType.DL_PANELFW, 16, 31);\r\n        if (panelSoftware == null) {\r\n            logger.debug(\"Cannot get software version\");\r\n            result = false;\r\n        }\r\n        panelSerial = \"\";\r\n        data = readSettings(PowermaxSendType.DL_SERIAL, 0, 5);\r\n        if (data != null) {\r\n            for (int i = 0; i <= 5; i++) {\r\n                if ((data[i] & 0x000000FF) != 0x000000FF) {\r\n                    panelSerial += String.format(\"X\", data[i] & 0x000000FF);\r\n                } else {\r\n                    panelSerial += \".\";\r\n                }\r\n            }\r\n        } else {\r\n            logger.debug(\"Cannot get serial ID\");\r\n            result = false;\r\n        }\r\n        byte[] partitions = readSettings(PowermaxSendType.DL_PARTITIONS, 0, 0x10 + zoneCnt);\r\n        if (partitions != null) {\r\n            partitionsEnabled = (partitions[0] & 0x000000FF) == 1;\r\n        } else {\r\n            logger.debug(\"Cannot get partitions information\");\r\n            result = false;\r\n        }\r\n        if (!partitionsEnabled) {\r\n            partitionCnt = 1;\r\n        }\r\n        data = readSettings(PowermaxSendType.DL_ZONES, 0, zoneCnt * 4 - 1);\r\n        byte[] zoneNr = null;\r\n        byte[] dataMr = null;\r\n        if (panelType.isPowerMaster()) {\r\n            zoneNr = readSettings(PowermaxSendType.DL_MR_ZONENAMES, 0, zoneCnt - 1);\r\n            dataMr = readSettings(PowermaxSendType.DL_MR_ZONES, 0, zoneCnt * 10 - 2);\r\n        } else {\r\n            zoneNr = readSettings(PowermaxSendType.DL_ZONENAMES, 0, zoneCnt - 1);\r\n        }\r\n        if ((data != null) && (zoneNr != null)) {\r\n            byte[] zero3 = new byte[] { 0, 0, 0 };\r\n            byte[] zero5 = new byte[] { 0, 0, 0, 0, 0 };\r\n            for (int i = 0; i < zoneCnt; i++) {\r\n                String zoneName;\r\n                try {\r\n                    PowermaxZoneName zone = PowermaxZoneName.fromId(zoneNr[i] & 0x0000001F);\r\n                    zoneName = zone.getName();\r\n                } catch (IllegalArgumentException e) {\r\n                    logger.debug(\"Zone id out of bounds {}\", zoneNr[i] & 0x0000001F);\r\n                    zoneName = null;\r\n                }\r\n                boolean zoneEnrolled;\r\n                byte zoneInfo;\r\n                byte sensorTypeCode;\r\n                String sensorTypeStr;\r\n                if (panelType.isPowerMaster()) {\r\n                    zoneEnrolled = !Arrays.equals(Arrays.copyOfRange(dataMr, i * 10 + 4, i * 10 + 9), zero5);\r\n                    zoneInfo = data[i];\r\n                    sensorTypeCode = dataMr[i * 10 + 5];\r\n                    try {\r\n                        PowermasterSensorType sensorType = PowermasterSensorType.fromCode(sensorTypeCode);\r\n                        sensorTypeStr = sensorType.getLabel();\r\n                    } catch (IllegalArgumentException e) {\r\n                        sensorTypeStr = null;\r\n                    }\r\n                } else {\r\n                    zoneEnrolled = !Arrays.equals(Arrays.copyOfRange(data, i * 4, i * 4 + 3), zero3);\r\n                    zoneInfo = data[i * 4 + 3];\r\n                    sensorTypeCode = data[i * 4 + 2];\r\n                    try {\r\n                        PowermaxSensorType sensorType = PowermaxSensorType.fromCode((byte) (sensorTypeCode & 0x0000000F));\r\n                        sensorTypeStr = sensorType.getLabel();\r\n                    } catch (IllegalArgumentException e) {\r\n                        sensorTypeStr = null;\r\n                    }\r\n                }\r\n                if (zoneEnrolled) {\r\n                    byte zoneType = (byte) (zoneInfo & 0x0000000F);\r\n                    byte zoneChime = (byte) ((zoneInfo >> 4) & 0x00000003);\r\n                    boolean[] part = new boolean[partitionCnt];\r\n                    if (partitionCnt > 1) {\r\n                        for (int j = 0; j < partitionCnt; j++) {\r\n                            part[j] = (partitions != null) ? ((partitions[0x11 + i] & (1 << j)) != 0) : true;\r\n                        }\r\n                    } else {\r\n                        part[0] = true;\r\n                    }\r\n                    zoneSettings[i] = new PowermaxZoneSettings(zoneName, zoneType, zoneChime, sensorTypeStr, part);\r\n                }\r\n            }\r\n        } else {\r\n            logger.debug(\"Cannot get zone settings\");\r\n            result = false;\r\n        }\r\n        data = readSettings(PowermaxSendType.DL_PGMX10, 0, 148);\r\n        zoneNr = readSettings(PowermaxSendType.DL_X10NAMES, 0, NB_PGM_X10_DEVICES - 2);\r\n        if ((data != null) && (zoneNr != null)) {\r\n            for (int i = 0; i < NB_PGM_X10_DEVICES; i++) {\r\n                boolean enabled = false;\r\n                String zoneName = null;\r\n                for (int j = 0; j <= 8; j++) {\r\n                    if (data[5 + i + j * 0x10] != 0) {\r\n                        enabled = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (i > 0) {\r\n                    try {\r\n                        PowermaxZoneName zone = PowermaxZoneName.fromId(zoneNr[i - 1] & 0x0000001F);\r\n                        zoneName = zone.getName();\r\n                    } catch (IllegalArgumentException e) {\r\n                        logger.debug(\"Zone id out of bounds {}\", zoneNr[i - 1] & 0x0000001F);\r\n                        zoneName = null;\r\n                    }\r\n                }\r\n                x10Settings[i] = new PowermaxX10Settings(zoneName, enabled);\r\n            }\r\n        } else {\r\n            logger.debug(\"Cannot get PGM / X10 settings\");\r\n            result = false;\r\n        }\r\n        if (panelType.isPowerMaster()) {\r\n            data = readSettings(PowermaxSendType.DL_MR_KEYPADS, 0, keypad2wCnt * 10 - 1);\r\n            if (data != null) {\r\n                byte[] zero5 = new byte[] { 0, 0, 0, 0, 0 };\r\n                for (int i = 0; i < keypad2wCnt; i++) {\r\n                    keypad2wEnrolled[i] = !Arrays.equals(Arrays.copyOfRange(data, i * 10 + 4, i * 10 + 9), zero5);\r\n                }\r\n            } else {\r\n                logger.debug(\"Cannot get 2 way keypad settings\");\r\n                result = false;\r\n            }\r\n            data = readSettings(PowermaxSendType.DL_MR_SIRENS, 0, sirenCnt * 10 - 1);\r\n            if (data != null) {\r\n                byte[] zero5 = new byte[] { 0, 0, 0, 0, 0 };\r\n                for (int i = 0; i < sirenCnt; i++) {\r\n                    sirensEnrolled[i] = !Arrays.equals(Arrays.copyOfRange(data, i * 10 + 4, i * 10 + 9), zero5);\r\n                }\r\n            } else {\r\n                logger.debug(\"Cannot get siren settings\");\r\n                result = false;\r\n            }\r\n        } else {\r\n            data = readSettings(PowermaxSendType.DL_1WKEYPAD, 0, keypad1wCnt * 4 - 1);\r\n            if (data != null) {\r\n                byte[] zero2 = new byte[] { 0, 0 };\r\n                for (int i = 0; i < keypad1wCnt; i++) {\r\n                    keypad1wEnrolled[i] = !Arrays.equals(Arrays.copyOfRange(data, i * 4, i * 4 + 2), zero2);\r\n                }\r\n            } else {\r\n                logger.debug(\"Cannot get 1 way keypad settings\");\r\n                result = false;\r\n            }\r\n            data = readSettings(PowermaxSendType.DL_2WKEYPAD, 0, keypad2wCnt * 4 - 1);\r\n            if (data != null) {\r\n                byte[] zero3 = new byte[] { 0, 0, 0 };\r\n                for (int i = 0; i < keypad2wCnt; i++) {\r\n                    keypad2wEnrolled[i] = !Arrays.equals(Arrays.copyOfRange(data, i * 4, i * 4 + 3), zero3);\r\n                }\r\n            } else {\r\n                logger.debug(\"Cannot get 2 way keypad settings\");\r\n                result = false;\r\n            }\r\n            data = readSettings(PowermaxSendType.DL_SIRENS, 0, sirenCnt * 4 - 1);\r\n            if (data != null) {\r\n                byte[] zero3 = new byte[] { 0, 0, 0 };\r\n                for (int i = 0; i < sirenCnt; i++) {\r\n                    sirensEnrolled[i] = !Arrays.equals(Arrays.copyOfRange(data, i * 4, i * 4 + 3), zero3);\r\n                }\r\n            } else {\r\n                logger.debug(\"Cannot get siren settings\");\r\n                result = false;\r\n            }\r\n        }\r\n    } else {\r\n        if (!partitionsEnabled) {\r\n            partitionCnt = 1;\r\n        }\r\n        boolean[] part = new boolean[partitionCnt];\r\n        for (int j = 0; j < partitionCnt; j++) {\r\n            part[j] = true;\r\n        }\r\n        for (int i = 0; i < zoneCnt; i++) {\r\n            zoneSettings[i] = new PowermaxZoneSettings(null, (byte) 0xFF, (byte) 0xFF, null, part);\r\n        }\r\n        for (int i = 0; i < NB_PGM_X10_DEVICES; i++) {\r\n            x10Settings[i] = new PowermaxX10Settings(null, true);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.openhab.binding.gpstracker.internal.provider.AbstractCallbackServlet.processMessage",
	"Comment": "process the message received by the servlet. if the tracker is unknown the discovery service is notifiedso that the next search will pop up the new tracker as result.",
	"Method": "List<? extends LocationMessage> processMessage(LocationMessage message){\r\n    String trackerId = message.getTrackerId();\r\n    if (trackerId != null) {\r\n        TrackerHandler recorder = getHandlerById(trackerId);\r\n        if (recorder != null) {\r\n            if (message instanceof TransitionMessage) {\r\n                TransitionMessage tm = (TransitionMessage) message;\r\n                recorder.doTransition(tm);\r\n            } else {\r\n                recorder.updateLocation(message);\r\n            }\r\n            return recorder.getNotifications();\r\n        } else {\r\n            logger.debug(\"There is no handler for tracker {}. Check the inbox for the new tracker.\", trackerId);\r\n        }\r\n    } else {\r\n        logger.debug(\"Message without tracker id. Dropping message. {}\", messageUtil.toJson(message));\r\n    }\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "org.openhab.binding.opensprinkler.internal.handler.OpenSprinklerHandler.handleStationCommand",
	"Comment": "handles control of an opensprnkler station based on commandedreceived by a channel call.",
	"Method": "void handleStationCommand(int stationId,Command command){\r\n    try {\r\n        if (command == OnOffType.ON) {\r\n            openSprinklerDevice.openStation(stationId);\r\n        } else if (command == OnOffType.OFF) {\r\n            openSprinklerDevice.closeStation(stationId);\r\n        } else {\r\n            logger.error(\"Received invalid command type for OpenSprinkler station ({}).\", command);\r\n        }\r\n    } catch (Exception exp) {\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Could not control the station channel \" + (stationId + 1) + \" for the OpenSprinkler.\");\r\n        logger.debug(\"Could not control the station channel {} for the OpenSprinkler device. Exception received: {}\", (stationId + 1), exp.toString());\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.kodi.internal.protocol.KodiClientSocket.open",
	"Comment": "attempts to create a connection to the kodi host and begin listening for updates over the async http web socket",
	"Method": "void open(){\r\n    if (isConnected()) {\r\n        logger.warn(\"connect: connection is already open\");\r\n    }\r\n    KodiWebSocketListener socket = new KodiWebSocketListener();\r\n    ClientUpgradeRequest request = new ClientUpgradeRequest();\r\n    client.connect(socket, uri, request);\r\n}"
}, {
	"Path": "geometry.geom3d.PolygonExtruder.setHorizontalNormal",
	"Comment": "this method is to give horizontal smooth lightning to extruded faces.\tmust be called before extrusion.",
	"Method": "void setHorizontalNormal(double topNormalAngle,double bottomNormalAngle){\r\n    this.topNormalAngle = topNormalAngle;\r\n    this.bottomNormalAngle = bottomNormalAngle;\r\n    horizontalNormalSet = true;\r\n}"
}, {
	"Path": "org.openhab.binding.atlona.internal.pro3.AtlonaPro3PortocolHandler.refreshPortStatus",
	"Comment": "refreshes the input port setting on the specified output port.",
	"Method": "void refreshPortStatus(int portNbr){\r\n    if (portNbr <= 0) {\r\n        throw new IllegalArgumentException(\"portNbr must be greater than 0\");\r\n    }\r\n    sendCommand(String.format(CMD_PORT_STATUS_FORMAT, portNbr));\r\n}"
}, {
	"Path": "org.openhab.binding.minecraft.internal.server.ServerConnection.setSocketHandler",
	"Comment": "add the handler used to handle messages state updates web socket.",
	"Method": "void setSocketHandler(MinecraftSocketHandler handler){\r\n    socketHandler = handler;\r\n}"
}, {
	"Path": "org.openhab.binding.cm11a.internal.X10Interface.processRequestFromIFace",
	"Comment": "processes a request made from the interface to the pc. only handles requests initiated by the interface,not those that form part of a conversation triggered by the pc.",
	"Method": "void processRequestFromIFace(int readint){\r\n    switch(readint) {\r\n        case CLOCK_SET_REQ:\r\n            setClock();\r\n            break;\r\n        case DATA_READY_REQ:\r\n            receiveCommandData();\r\n            break;\r\n        case INPUT_FILTER_FAIL_REQ:\r\n            serialOutput.write(DATA_READY_HEAD);\r\n            logger.warn(\"X10 Interface has indicated that the filter and/or surge protection in the device has failed.\");\r\n            break;\r\n        default:\r\n            logger.warn(\"Unexpected data received from X10 interface: {}\", Integer.toHexString(readint));\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.deconz.internal.handler.DeconzBridgeHandler.requestFullState",
	"Comment": "perform a request to the rest api for retrieving the full bridge state with all sensors and switchesand configuration.",
	"Method": "void requestFullState(){\r\n    if (config.apikey == null) {\r\n        return;\r\n    }\r\n    String url = BindingConstants.url(config.host, config.apikey, null, null);\r\n    http.get(url, config.timeout).thenApply(this::parseBridgeFullStateResponse).exceptionally(e -> {\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n        if (!(e instanceof SocketTimeoutException)) {\r\n            logger.warn(\"Get full state failed\", e);\r\n        }\r\n        return null;\r\n    }).whenComplete((value, error) -> {\r\n        if (thingDiscoveryService != null) {\r\n            thingDiscoveryService.stateRequestFinished(value != null ? value.sensors : null);\r\n        }\r\n    }).thenAccept(fullState -> {\r\n        if (fullState == null) {\r\n            requestApiKey();\r\n            return;\r\n        }\r\n        if (fullState.config.name.isEmpty()) {\r\n            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"You are connected to a HUE bridge, not a deCONZ software!\");\r\n            return;\r\n        }\r\n        if (fullState.config.websocketport == 0) {\r\n            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"deCONZ software too old. No websocket support!\");\r\n            return;\r\n        }\r\n        Map<String, String> editProperties = editProperties();\r\n        editProperties.put(\"apiversion\", fullState.config.apiversion);\r\n        editProperties.put(\"swversion\", fullState.config.swversion);\r\n        editProperties.put(\"fwversion\", fullState.config.fwversion);\r\n        editProperties.put(\"uuid\", fullState.config.uuid);\r\n        editProperties.put(\"zigbeechannel\", String.valueOf(fullState.config.zigbeechannel));\r\n        editProperties.put(\"ipaddress\", fullState.config.ipaddress);\r\n        ignoreConfigurationUpdate = true;\r\n        updateProperties(editProperties);\r\n        ignoreConfigurationUpdate = false;\r\n        websocketport = fullState.config.websocketport;\r\n        startWebsocket();\r\n    }).exceptionally(e -> {\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\r\n        logger.warn(\"Full state parsing failed\", e);\r\n        return null;\r\n    });\r\n}"
}, {
	"Path": "nginx.clojure.asm.Type.getType",
	"Comment": "returns the java type corresponding to the given type descriptor. formethod descriptors, buf is supposed to contain nothing more than thedescriptor itself.",
	"Method": "Type getType(String typeDescriptor,Type getType,Class<?> c,Type getType,Constructor<?> c,Type getType,Method m,Type getType,char[] buf,int off){\r\n    int len;\r\n    switch(buf[off]) {\r\n        case 'V':\r\n            return VOID_TYPE;\r\n        case 'Z':\r\n            return BOOLEAN_TYPE;\r\n        case 'C':\r\n            return CHAR_TYPE;\r\n        case 'B':\r\n            return BYTE_TYPE;\r\n        case 'S':\r\n            return SHORT_TYPE;\r\n        case 'I':\r\n            return INT_TYPE;\r\n        case 'F':\r\n            return FLOAT_TYPE;\r\n        case 'J':\r\n            return LONG_TYPE;\r\n        case 'D':\r\n            return DOUBLE_TYPE;\r\n        case '[':\r\n            len = 1;\r\n            while (buf[off + len] == '[') {\r\n                ++len;\r\n            }\r\n            if (buf[off + len] == 'L') {\r\n                ++len;\r\n                while (buf[off + len] != ';') {\r\n                    ++len;\r\n                }\r\n            }\r\n            return new Type(ARRAY, buf, off, len + 1);\r\n        case 'L':\r\n            len = 1;\r\n            while (buf[off + len] != ';') {\r\n                ++len;\r\n            }\r\n            return new Type(OBJECT, buf, off + 1, len - 1);\r\n        default:\r\n            return new Type(METHOD, buf, off, buf.length - off);\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.ByteVector.putShort",
	"Comment": "puts a short into this byte vector. the byte vector is automaticallyenlarged if necessary.",
	"Method": "ByteVector putShort(int s){\r\n    int length = this.length;\r\n    if (length + 2 > data.length) {\r\n        enlarge(2);\r\n    }\r\n    byte[] data = this.data;\r\n    data[length++] = (byte) (s >>> 8);\r\n    data[length++] = (byte) s;\r\n    this.length = length;\r\n    return this;\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.device.DSMRSerialAutoDevice.stopDiscover",
	"Comment": "stops the discovery of port speed process and sets the state with which it should be stopped.",
	"Method": "void stopDiscover(DeviceState state){\r\n    telegramListener.setDsmrEventListener(parentListener);\r\n    logger.debug(\"Stop discovery of port settings.\");\r\n    if (halfTimeTimer != null) {\r\n        halfTimeTimer.cancel(true);\r\n        halfTimeTimer = null;\r\n    }\r\n    if (endTimeTimer != null) {\r\n        endTimeTimer.cancel(true);\r\n        endTimeTimer = null;\r\n    }\r\n    this.state = state;\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.handler.DSMRMeterHandler.initialize",
	"Comment": "initializes a dsmr meterthis method will load the corresponding configuration",
	"Method": "void initialize(){\r\n    logger.debug(\"Initialize MeterHandler for Thing {}\", getThing().getUID());\r\n    DSMRMeterType meterType;\r\n    try {\r\n        meterType = DSMRMeterType.valueOf(getThing().getThingTypeUID().getId().toUpperCase());\r\n    } catch (IllegalArgumentException iae) {\r\n        logger.warn(\"{} could not be initialized due to an invalid meterType {}. Delete this Thing if the problem persists.\", getThing(), getThing().getThingTypeUID().getId().toUpperCase());\r\n        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_ERROR, \"@text/error.configuration.invalidmetertype\");\r\n        return;\r\n    }\r\n    DSMRMeterConfiguration meterConfig = getConfigAs(DSMRMeterConfiguration.class);\r\n    DSMRMeterDescriptor meterDescriptor = new DSMRMeterDescriptor(meterType, meterConfig.channel);\r\n    meter = new DSMRMeter(meterDescriptor);\r\n    meterWatchdog = scheduler.scheduleWithFixedDelay(this::updateState, meterConfig.refresh, meterConfig.refresh, TimeUnit.SECONDS);\r\n    updateStatus(ThingStatus.UNKNOWN);\r\n}"
}, {
	"Path": "org.openhab.binding.powermax.internal.message.PowermaxBaseMessage.decodeMessage",
	"Comment": "extract information from the buffer of bytes and set class attributes",
	"Method": "void decodeMessage(byte[] data){\r\n    rawData = data;\r\n    code = rawData[1] & 0x000000FF;\r\n    try {\r\n        receiveType = PowermaxReceiveType.fromCode((byte) code);\r\n    } catch (IllegalArgumentException e) {\r\n        receiveType = null;\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.view.UserInfoView.toJsonFromRequestObj",
	"Comment": "build a json response according to the request object received.\tclaims requested in requestobj.userinfo.claims are added to any\tclaims corresponding to requested scopes, if any.",
	"Method": "JsonObject toJsonFromRequestObj(UserInfo ui,Set<String> scope,JsonObject authorizedClaims,JsonObject requestedClaims){\r\n    JsonObject obj = ui.toJson();\r\n    Set<String> allowedByScope = translator.getClaimsForScopeSet(scope);\r\n    Set<String> authorizedByClaims = extractUserInfoClaimsIntoSet(authorizedClaims);\r\n    Set<String> requestedByClaims = extractUserInfoClaimsIntoSet(requestedClaims);\r\n    JsonObject result = new JsonObject();\r\n    for (Entry<String, JsonElement> entry : obj.entrySet()) {\r\n        if (allowedByScope.contains(entry.getKey()) || authorizedByClaims.contains(entry.getKey())) {\r\n            if (requestedByClaims.isEmpty() || requestedByClaims.contains(entry.getKey())) {\r\n                result.add(entry.getKey(), entry.getValue());\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.storeArg",
	"Comment": "generates the instruction to store the top stack value in the givenmethod argument.",
	"Method": "void storeArg(int arg){\r\n    storeInsn(argumentTypes[arg], getArgIndex(arg));\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Triplet.fromCollection",
	"Comment": "create tuple from collection. collection has to have exactly three elements.",
	"Method": "Triplet<X, X, X> fromCollection(Collection<X> collection){\r\n    return fromIterable(collection);\r\n}"
}, {
	"Path": "org.openhab.binding.dlinksmarthome.internal.motionsensor.DLinkMotionSensorCommunication.unexpectedResult",
	"Comment": "output unexpected responses to the debug log and sets the firmware error.",
	"Method": "void unexpectedResult(String message,Document soapResponse){\r\n    logUnexpectedResult(message, soapResponse);\r\n    status = DeviceStatus.UNSUPPORTED_FIRMWARE;\r\n}"
}, {
	"Path": "org.openhab.binding.onebusaway.internal.handler.StopHandler.unregisterRouteDataListener",
	"Comment": "unregisters the listener so it no longer receives updates about arrival and departure times for its route.",
	"Method": "boolean unregisterRouteDataListener(RouteDataListener listener){\r\n    return routeDataListeners.remove(listener);\r\n}"
}, {
	"Path": "nginx.clojure.asm.util.CheckMethodAdapter.checkDesc",
	"Comment": "checks that a the given substring is a valid type descriptor.",
	"Method": "void checkDesc(String desc,boolean canBeVoid,int checkDesc,String desc,int start,boolean canBeVoid){\r\n    if (desc == null || start >= desc.length()) {\r\n        throw new IllegalArgumentException(\"Invalid type descriptor (must not be null or empty)\");\r\n    }\r\n    int index;\r\n    switch(desc.charAt(start)) {\r\n        case 'V':\r\n            if (canBeVoid) {\r\n                return start + 1;\r\n            } else {\r\n                throw new IllegalArgumentException(\"Invalid descriptor: \" + desc);\r\n            }\r\n        case 'Z':\r\n        case 'C':\r\n        case 'B':\r\n        case 'S':\r\n        case 'I':\r\n        case 'F':\r\n        case 'J':\r\n        case 'D':\r\n            return start + 1;\r\n        case '[':\r\n            index = start + 1;\r\n            while (index < desc.length() && desc.charAt(index) == '[') {\r\n                ++index;\r\n            }\r\n            if (index < desc.length()) {\r\n                return checkDesc(desc, index, false);\r\n            } else {\r\n                throw new IllegalArgumentException(\"Invalid descriptor: \" + desc);\r\n            }\r\n        case 'L':\r\n            index = desc.indexOf(';', start);\r\n            if (index == -1 || index - start < 2) {\r\n                throw new IllegalArgumentException(\"Invalid descriptor: \" + desc);\r\n            }\r\n            try {\r\n                checkInternalName(desc, start + 1, index, null);\r\n            } catch (IllegalArgumentException _) {\r\n                throw new IllegalArgumentException(\"Invalid descriptor: \" + desc);\r\n            }\r\n            return index + 1;\r\n        default:\r\n            throw new IllegalArgumentException(\"Invalid descriptor: \" + desc);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.discovery.RioSystemDiscovery.addResult",
	"Comment": "helper method to add our ip address and system type as a discovery result.",
	"Method": "void addResult(String ipAddress,String type){\r\n    if (StringUtils.isEmpty(ipAddress)) {\r\n        throw new IllegalArgumentException(\"ipAddress cannot be null or empty\");\r\n    }\r\n    if (StringUtils.isEmpty(type)) {\r\n        throw new IllegalArgumentException(\"type cannot be null or empty\");\r\n    }\r\n    final Map<String, Object> properties = new HashMap(3);\r\n    properties.put(RioSystemConfig.IP_ADDRESS, ipAddress);\r\n    properties.put(RioSystemConfig.PING, 30);\r\n    properties.put(RioSystemConfig.RETRY_POLLING, 10);\r\n    properties.put(RioSystemConfig.SCAN_DEVICE, true);\r\n    final String id = ipAddress.replace(\".\", \"\");\r\n    final ThingUID uid = new ThingUID(RioConstants.BRIDGE_TYPE_RIO, id);\r\n    if (uid != null) {\r\n        final DiscoveryResult result = DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(\"Russound \" + type).build();\r\n        thingDiscovered(result);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.opensprinkler.internal.util.Http.sendHttpGet",
	"Comment": "given a url and a set parameters, send a http get request to the url location created by the url and parameters.",
	"Method": "String sendHttpGet(String url,String urlParameters){\r\n    URL location = null;\r\n    if (urlParameters != null) {\r\n        location = new URL(url + \"?\" + urlParameters);\r\n    } else {\r\n        location = new URL(url);\r\n    }\r\n    HttpURLConnection connection = (HttpURLConnection) location.openConnection();\r\n    connection.setRequestMethod(HTTP_GET);\r\n    connection.setRequestProperty(\"User-Agent\", USER_AGENT);\r\n    int responseCode = connection.getResponseCode();\r\n    if (responseCode != HTTP_OK_CODE) {\r\n        throw new Exception(\"Error sending HTTP GET request to \" + url + \". Got response code: \" + responseCode);\r\n    }\r\n    BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\r\n    String inputLine;\r\n    StringBuilder response = new StringBuilder();\r\n    while ((inputLine = in.readLine()) != null) {\r\n        response.append(inputLine);\r\n    }\r\n    in.close();\r\n    return response.toString();\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.LoxoneDynamicStateDescriptionProvider.setDescription",
	"Comment": "set a state description for a channel. this description will be used when preparing the channel state bythe framework for presentation. a previous description, if existed, will be replaced.",
	"Method": "void setDescription(ChannelUID channelUID,StateDescription description){\r\n    logger.debug(\"Adding state description for channel {}\", channelUID);\r\n    descriptions.put(channelUID, description);\r\n}"
}, {
	"Path": "org.mitre.openid.connect.web.ProtectedResourceRegistrationEndpoint.registerNewProtectedResource",
	"Comment": "create a new client, issue a client id, and create a registration access token.",
	"Method": "String registerNewProtectedResource(String jsonString,Model m){\r\n    ClientDetailsEntity newClient = null;\r\n    try {\r\n        newClient = ClientDetailsEntityJsonProcessor.parse(jsonString);\r\n    } catch (JsonSyntaxException e) {\r\n        logger.error(\"registerNewProtectedResource failed; submitted JSON is malformed\");\r\n        m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);\r\n        return HttpCodeView.VIEWNAME;\r\n    }\r\n    if (newClient != null) {\r\n        newClient.setClientId(null);\r\n        newClient.setClientSecret(null);\r\n        try {\r\n            newClient = validateScopes(newClient);\r\n            newClient = validateAuth(newClient);\r\n        } catch (ValidationException ve) {\r\n            m.addAttribute(JsonErrorView.ERROR, ve.getError());\r\n            m.addAttribute(JsonErrorView.ERROR_MESSAGE, ve.getErrorDescription());\r\n            m.addAttribute(HttpCodeView.CODE, ve.getStatus());\r\n            return JsonErrorView.VIEWNAME;\r\n        }\r\n        newClient.setGrantTypes(new HashSet<String>());\r\n        newClient.setResponseTypes(new HashSet<String>());\r\n        newClient.setRedirectUris(new HashSet<String>());\r\n        newClient.setAccessTokenValiditySeconds(0);\r\n        newClient.setIdTokenValiditySeconds(0);\r\n        newClient.setRefreshTokenValiditySeconds(0);\r\n        newClient.setDefaultACRvalues(new HashSet<String>());\r\n        newClient.setDefaultMaxAge(null);\r\n        newClient.setIdTokenEncryptedResponseAlg(null);\r\n        newClient.setIdTokenEncryptedResponseEnc(null);\r\n        newClient.setIdTokenSignedResponseAlg(null);\r\n        newClient.setInitiateLoginUri(null);\r\n        newClient.setPostLogoutRedirectUris(null);\r\n        newClient.setRequestObjectSigningAlg(null);\r\n        newClient.setRequireAuthTime(null);\r\n        newClient.setReuseRefreshToken(false);\r\n        newClient.setSectorIdentifierUri(null);\r\n        newClient.setSubjectType(null);\r\n        newClient.setUserInfoEncryptedResponseAlg(null);\r\n        newClient.setUserInfoEncryptedResponseEnc(null);\r\n        newClient.setUserInfoSignedResponseAlg(null);\r\n        newClient.setDynamicallyRegistered(true);\r\n        newClient.setAllowIntrospection(true);\r\n        try {\r\n            ClientDetailsEntity savedClient = clientService.saveNewClient(newClient);\r\n            OAuth2AccessTokenEntity token = connectTokenService.createResourceAccessToken(savedClient);\r\n            tokenService.saveAccessToken(token);\r\n            RegisteredClient registered = new RegisteredClient(savedClient, token.getValue(), config.getIssuer() + \"resource/\" + UriUtils.encodePathSegment(savedClient.getClientId(), \"UTF-8\"));\r\n            m.addAttribute(\"client\", registered);\r\n            // http 201\r\n            m.addAttribute(HttpCodeView.CODE, HttpStatus.CREATED);\r\n            return ClientInformationResponseView.VIEWNAME;\r\n        } catch (UnsupportedEncodingException e) {\r\n            logger.error(\"Unsupported encoding\", e);\r\n            m.addAttribute(HttpCodeView.CODE, HttpStatus.INTERNAL_SERVER_ERROR);\r\n            return HttpCodeView.VIEWNAME;\r\n        } catch (IllegalArgumentException e) {\r\n            logger.error(\"Couldn't save client\", e);\r\n            m.addAttribute(JsonErrorView.ERROR, \"invalid_client_metadata\");\r\n            m.addAttribute(JsonErrorView.ERROR_MESSAGE, \"Unable to save client due to invalid or inconsistent metadata.\");\r\n            m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);\r\n            return JsonErrorView.VIEWNAME;\r\n        }\r\n    } else {\r\n        logger.error(\"registerNewClient failed; submitted JSON is malformed\");\r\n        m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);\r\n        return HttpCodeView.VIEWNAME;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.innogysmarthome.internal.handler.InnogyBridgeHandler.handleControllerConnectivityChangedEvent",
	"Comment": "handles the event that occurs, when the connectivity of the bridge has changed.",
	"Method": "void handleControllerConnectivityChangedEvent(Event event){\r\n    Boolean connected = event.getIsConnected();\r\n    if (connected != null) {\r\n        logger.debug(\"SmartHome Controller connectivity changed to {}.\", connected ? \"online\" : \"offline\");\r\n        if (connected) {\r\n            deviceStructMan = new DeviceStructureManager(client);\r\n            deviceStructMan.start();\r\n            updateStatus(ThingStatus.ONLINE);\r\n        } else {\r\n            updateStatus(ThingStatus.OFFLINE);\r\n            deviceStructMan = null;\r\n        }\r\n    } else {\r\n        logger.warn(\"isConnected property missing in event! (returned null)\");\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.plclogo.internal.config.PLCDigitalConfiguration.setBlockKind",
	"Comment": "set siemens logo! blocks kind.can be i, q, m, ni or nq for digital blocks andai, am, aq, nai or naq for analog",
	"Method": "void setBlockKind(String kind){\r\n    this.kind = kind.trim();\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxServer.updateControls",
	"Comment": "updates server structures with a new or updated control and its states and subcontrols",
	"Method": "void updateControls(LxControl control){\r\n    for (LxControlState state : control.getStates().values()) {\r\n        state.getUuid().setUpdate(true);\r\n        Map<LxUuid, LxControlState> perUuid = states.get(state.getUuid());\r\n        if (perUuid == null) {\r\n            perUuid = new HashMap();\r\n            states.put(state.getUuid(), perUuid);\r\n        }\r\n        perUuid.put(control.uuid, state);\r\n    }\r\n    controls.put(control.uuid, control);\r\n    control.uuid.setUpdate(true);\r\n    for (LxControl subControl : control.getSubControls().values()) {\r\n        updateControls(subControl);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.gardena.internal.util.DateUtils.parseToDate",
	"Comment": "converts a string to a date, trying different date formats used by gardena.",
	"Method": "Date parseToDate(String text){\r\n    if (StringUtils.isNotBlank(text)) {\r\n        Date parsedDate = null;\r\n        for (String dateFormat : DATE_FORMATS) {\r\n            try {\r\n                parsedDate = new SimpleDateFormat(dateFormat).parse(text);\r\n                ZonedDateTime gmt = ZonedDateTime.ofInstant(parsedDate.toInstant(), ZoneOffset.UTC);\r\n                LocalDateTime here = gmt.withZoneSameInstant(ZoneId.systemDefault()).toLocalDateTime();\r\n                parsedDate = Date.from(here.toInstant(ZoneOffset.UTC));\r\n                break;\r\n            } catch (ParseException ex) {\r\n            }\r\n        }\r\n        if (parsedDate == null) {\r\n            LOGGER.error(\"Can't parse date {}\", text);\r\n        }\r\n        return parsedDate;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.PresenceDetection.isIOSdevice",
	"Comment": "return true if the device presence detection is performed for an ios devicelike iphone or ipads. an additional port knock is performed before a ping.",
	"Method": "boolean isIOSdevice(){\r\n    return iosDevice;\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxControlInfoOnlyDigital.getFormattedValue",
	"Comment": "obtain current value of the virtual state, expressed in a format configured on the miniserver",
	"Method": "String getFormattedValue(){\r\n    Double value = getStateValue(STATE_ACTIVE);\r\n    if (value != null) {\r\n        if (value == 0) {\r\n            return textOff;\r\n        } else if (value == 1) {\r\n            return textOn;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.RioPresetsProtocol.handlerSourceTypeNotification",
	"Comment": "handles any preset notifications returned by the russound system",
	"Method": "void handlerSourceTypeNotification(Matcher m,String resp){\r\n    if (m == null) {\r\n        throw new IllegalArgumentException(\"m (matcher) cannot be null\");\r\n    }\r\n    if (m.groupCount() == 2) {\r\n        try {\r\n            final int sourceId = Integer.parseInt(m.group(1));\r\n            if (sourceId >= 1 && sourceId <= 8) {\r\n                final String sourceType = m.group(2);\r\n                final Matcher matcher = IS_TUNER.matcher(sourceType);\r\n                final boolean srcIsTuner = matcher.matches();\r\n                if (srcIsTuner != isTuner[sourceId - 1]) {\r\n                    isTuner[sourceId - 1] = srcIsTuner;\r\n                    if (srcIsTuner) {\r\n                        lastUpdateTime[sourceId - 1] = 0;\r\n                        refreshPresets(sourceId);\r\n                    } else {\r\n                        for (int p = 0; p < 36; p++) {\r\n                            presets[sourceId - 1][p].setValid(false);\r\n                            presets[sourceId - 1][p].setName(null);\r\n                        }\r\n                    }\r\n                    fireUpdate(sourceId);\r\n                }\r\n            } else {\r\n                logger.debug(\"Source is not between 1 and 8, Response: {}\", resp);\r\n            }\r\n        } catch (NumberFormatException e) {\r\n            logger.warn(\"Invalid Preset Notification (source/bank/preset not a parsable integer): '{}')\", resp);\r\n        }\r\n    } else {\r\n        logger.warn(\"Invalid Preset Notification: '{}')\", resp);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.silvercrestwifisocket.internal.handler.SilvercrestWifiSocketHandler.saveConfigurationsUsingCurrentStates",
	"Comment": "save the current runtime configuration of the handler in configuration mechanism.",
	"Method": "void saveConfigurationsUsingCurrentStates(){\r\n    Map<String, Object> map = new HashMap();\r\n    map.put(SilvercrestWifiSocketBindingConstants.MAC_ADDRESS_ARG, this.macAddress);\r\n    map.put(SilvercrestWifiSocketBindingConstants.HOST_ADDRESS_ARG, this.hostAddress);\r\n    map.put(SilvercrestWifiSocketBindingConstants.VENDOR_ARG, this.vendor.toString());\r\n    map.put(SilvercrestWifiSocketBindingConstants.UPDATE_INTERVAL_ARG, this.updateInterval);\r\n    Configuration newConfiguration = new Configuration(map);\r\n    super.updateConfiguration(newConfiguration);\r\n}"
}, {
	"Path": "org.openhab.binding.pioneeravr.internal.handler.AbstractAvrHandler.handleCommand",
	"Comment": "send a command to the avr based on the openhab command received.",
	"Method": "void handleCommand(ChannelUID channelUID,Command command){\r\n    try {\r\n        boolean commandSent = false;\r\n        boolean unknownCommand = false;\r\n        if (channelUID.getId().contains(PioneerAvrBindingConstants.POWER_CHANNEL)) {\r\n            commandSent = connection.sendPowerCommand(command, getZoneFromChannelUID(channelUID.getId()));\r\n        } else if (channelUID.getId().contains(PioneerAvrBindingConstants.VOLUME_DIMMER_CHANNEL) || channelUID.getId().contains(PioneerAvrBindingConstants.VOLUME_DB_CHANNEL)) {\r\n            commandSent = connection.sendVolumeCommand(command, getZoneFromChannelUID(channelUID.getId()));\r\n        } else if (channelUID.getId().contains(PioneerAvrBindingConstants.SET_INPUT_SOURCE_CHANNEL)) {\r\n            commandSent = connection.sendInputSourceCommand(command, getZoneFromChannelUID(channelUID.getId()));\r\n        } else if (channelUID.getId().contains(PioneerAvrBindingConstants.MUTE_CHANNEL)) {\r\n            commandSent = connection.sendMuteCommand(command, getZoneFromChannelUID(channelUID.getId()));\r\n        } else {\r\n            unknownCommand = true;\r\n        }\r\n        if (!commandSent && !unknownCommand) {\r\n            onDisconnection();\r\n        }\r\n    } catch (CommandTypeNotSupportedException e) {\r\n        logger.warn(\"Unsupported command type received for channel {}.\", channelUID.getId());\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.MITREidDataService_1_2.readSystemScopes",
	"Comment": "read the list of system scopes from the reader and insert them into the\tscope repository.",
	"Method": "void readSystemScopes(JsonReader reader){\r\n    reader.beginArray();\r\n    while (reader.hasNext()) {\r\n        SystemScope scope = new SystemScope();\r\n        reader.beginObject();\r\n        while (reader.hasNext()) {\r\n            switch(reader.peek()) {\r\n                case END_OBJECT:\r\n                    continue;\r\n                case NAME:\r\n                    String name = reader.nextName();\r\n                    if (reader.peek() == JsonToken.NULL) {\r\n                        reader.skipValue();\r\n                    } else if (name.equals(VALUE)) {\r\n                        scope.setValue(reader.nextString());\r\n                    } else if (name.equals(DESCRIPTION)) {\r\n                        scope.setDescription(reader.nextString());\r\n                    } else if (name.equals(RESTRICTED)) {\r\n                        scope.setRestricted(reader.nextBoolean());\r\n                    } else if (name.equals(DEFAULT_SCOPE)) {\r\n                        scope.setDefaultScope(reader.nextBoolean());\r\n                    } else if (name.equals(ICON)) {\r\n                        scope.setIcon(reader.nextString());\r\n                    } else if (name.equals(STRUCTURED)) {\r\n                        logger.warn(\"Found a structured scope, ignoring structure\");\r\n                    } else if (name.equals(STRUCTURED_PARAMETER)) {\r\n                        logger.warn(\"Found a structured scope, ignoring structure\");\r\n                    } else {\r\n                        logger.debug(\"found unexpected entry\");\r\n                        reader.skipValue();\r\n                    }\r\n                    break;\r\n                default:\r\n                    logger.debug(\"Found unexpected entry\");\r\n                    reader.skipValue();\r\n                    continue;\r\n            }\r\n        }\r\n        reader.endObject();\r\n        sysScopeRepository.save(scope);\r\n    }\r\n    reader.endArray();\r\n    logger.info(\"Done reading system scopes\");\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxWsClient.startResponseTimeout",
	"Comment": "start a timer to wait for a miniserver response to an action sent from the binding.when timer expires, connection is removed and server error is reported. further connection attempt can be madelater by the upper layer.if a previous timer is running, it will be stopped before a new timer is started.the caller must take care of thread synchronization.",
	"Method": "void startResponseTimeout(){\r\n    stopResponseTimeout();\r\n    timeout = SCHEDULER.schedule(this::responseTimeout, connectTimeout, TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "nginx.clojure.asm.Frame.get",
	"Comment": "returns the output frame local variable type at the given index.",
	"Method": "int get(int local){\r\n    if (outputLocals == null || local >= outputLocals.length) {\r\n        return LOCAL | local;\r\n    } else {\r\n        int type = outputLocals[local];\r\n        if (type == 0) {\r\n            type = outputLocals[local] = LOCAL | local;\r\n        }\r\n        return type;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.onkyo.internal.OnkyoConnection.connectSocket",
	"Comment": "connects to the receiver by opening a socket connection through theip and port.",
	"Method": "boolean connectSocket(){\r\n    if (eiscpSocket == null || !connected || !eiscpSocket.isConnected()) {\r\n        try {\r\n            eiscpSocket = new Socket();\r\n            if (connectionSupervisor == null) {\r\n                connectionSupervisor = new ConnectionSupervisor(CONNECTION_TEST_INTERVAL);\r\n            }\r\n            eiscpSocket.connect(new InetSocketAddress(ip, port), CONNECTION_TIMEOUT);\r\n            logger.debug(\"Connected to {}:{}\", ip, port);\r\n            outStream = new DataOutputStream(eiscpSocket.getOutputStream());\r\n            inStream = new DataInputStream(eiscpSocket.getInputStream());\r\n            eiscpSocket.setSoTimeout(SOCKET_TIMEOUT);\r\n            outStream.flush();\r\n            connected = true;\r\n            if (dataListener == null) {\r\n                dataListener = new DataListener();\r\n                dataListener.start();\r\n            }\r\n        } catch (UnknownHostException unknownHost) {\r\n            logger.debug(\"You are trying to connect to an unknown host: {}\", unknownHost.getMessage());\r\n            sendConnectionErrorEvent(unknownHost.getMessage());\r\n        } catch (IOException ioException) {\r\n            logger.debug(\"Can't connect: {}\", ioException.getMessage());\r\n            sendConnectionErrorEvent(ioException.getMessage());\r\n        }\r\n    }\r\n    return connected;\r\n}"
}, {
	"Path": "org.openhab.binding.minecraft.internal.discovery.MinecraftDiscoveryService.stopDiscovery",
	"Comment": "teardown subscribers and stop searching for players and signs.",
	"Method": "void stopDiscovery(){\r\n    if (subscription != null && !subscription.isUnsubscribed()) {\r\n        subscription.unsubscribe();\r\n    }\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Pair.fromCollection",
	"Comment": "create tuple from collection. collection has to have exactly two elements.",
	"Method": "Pair<X, X> fromCollection(Collection<X> collection){\r\n    return fromIterable(collection);\r\n}"
}, {
	"Path": "org.openhab.binding.plclogo.internal.config.PLCLogoBridgeConfiguration.setRefreshRate",
	"Comment": "set refresh rate of siemens logo! device blocks in milliseconds.",
	"Method": "void setRefreshRate(Integer rate){\r\n    this.refresh = rate;\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.handler.NikoHomeControlActionHandler.rollershutterPositionStop",
	"Comment": "method used to stop rollershutter when moving. this will then result in an exact position to be received, so nextpercentage movements could be done accurately.",
	"Method": "void rollershutterPositionStop(NhcAction nhcAction){\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"rollershutterPositionStop: rollershutter {} executing\", this.getConfig().get(CONFIG_ACTION_ID));\r\n    }\r\n    cancelRollershutterStop();\r\n    this.rollershutterTask = null;\r\n    this.filterEvent = false;\r\n    this.waitForEvent = true;\r\n    nhcAction.execute(NHCSTOP);\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.protocol.NhcAction.setState",
	"Comment": "sets state of action.state is a value between 0 and 100 for a dimmer or rollershutter.rollershutter state is 0 for fully closed and 100 for fully open.state is 0 or 100 for a switch.if a thing handler is registered for the action, send a state update through the handler.this method should only be called from inside this package.",
	"Method": "void setState(int state){\r\n    this.state = state;\r\n    NikoHomeControlActionHandler handler = thingHandler;\r\n    if (handler != null) {\r\n        logger.debug(\"Niko Home Control: update channel state for {} with {}\", id, state);\r\n        handler.handleStateUpdate(this);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.max.internal.handler.MaxCubeBridgeHandler.sendDeviceDelete",
	"Comment": "delete a devices from the cube and updates the room information",
	"Method": "void sendDeviceDelete(String maxDeviceSerial){\r\n    Device device = getDevice(maxDeviceSerial);\r\n    if (device != null) {\r\n        SendCommand sendCommand = new SendCommand(maxDeviceSerial, new TCommand(device.getRFAddress(), true), \"Delete device \" + maxDeviceSerial + \" from Cube!\");\r\n        queueCommand(sendCommand);\r\n        devices.remove(device);\r\n        sendDeviceAndRoomNameUpdate(\"Remove name entry for \" + maxDeviceSerial);\r\n        sendCommand = new SendCommand(maxDeviceSerial, new QCommand(), \"Reload Data\");\r\n        queueCommand(sendCommand);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.avmfritz.internal.hardware.FritzAhaWebInterface.getURL",
	"Comment": "constructs an url from the stored information, a specified path and a specified argument string",
	"Method": "String getURL(String path,String getURL,String path,String args){\r\n    return getURL(path + \"?\" + args);\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ClientDetailsEntityService.checkSectorIdentifierUri",
	"Comment": "load the sector identifier uri if it exists and check the redirect uris against it",
	"Method": "void checkSectorIdentifierUri(ClientDetailsEntity client){\r\n    if (!Strings.isNullOrEmpty(client.getSectorIdentifierUri())) {\r\n        try {\r\n            List<String> redirects = sectorRedirects.get(client.getSectorIdentifierUri());\r\n            if (client.getRegisteredRedirectUri() != null) {\r\n                for (String uri : client.getRegisteredRedirectUri()) {\r\n                    if (!redirects.contains(uri)) {\r\n                        throw new IllegalArgumentException(\"Requested Redirect URI \" + uri + \" is not listed at sector identifier \" + redirects);\r\n                    }\r\n                }\r\n            }\r\n        } catch (UncheckedExecutionException | ExecutionException e) {\r\n            throw new IllegalArgumentException(\"Unable to load sector identifier URI \" + client.getSectorIdentifierUri() + \": \" + e.getMessage());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.gpstracker.internal.provider.AbstractCallbackServlet.getHandlerById",
	"Comment": "find handler for tracker. if the handler does not exist it is registered with discovery service.",
	"Method": "TrackerHandler getHandlerById(String trackerId){\r\n    if (trackerId != null) {\r\n        TrackerHandler handler = trackerRegistry.getTrackerHandler(trackerId);\r\n        if (handler == null) {\r\n            discoveryService.addTracker(trackerId);\r\n        } else {\r\n            return handler;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openhab.io.neeo.NeeoService.activate",
	"Comment": "activates this service. the activation will start up the brain discovery service and register the dashboard tile",
	"Method": "void activate(ComponentContext componentContext){\r\n    Objects.requireNonNull(componentContext, \"componentContext cannot be null\");\r\n    logger.debug(\"Neeo Service activated\");\r\n    final ServiceContext localContext = new ServiceContext(componentContext, validate(httpService, \"httpService\"), validate(itemRegistry, \"itemRegistry\"), validate(bindingInfoRegistry, \"bindingInfoRegistry\"), validate(thingRegistry, \"thingRegistry\"), validate(thingTypeRegistry, \"thingTypeRegistry\"), validate(itemChannelLinkRegistry, \"itemChannelLinkRegistry\"), validate(channelTypeRegistry, \"channelTypeRegistry\"), validate(mdnsClient, \"mdnsClient\"), validate(eventPublisher, \"eventPublisher\"), validate(networkAddressService, \"networkAddressService\"));\r\n    context = localContext;\r\n    discovery = new MdnsBrainDiscovery(context);\r\n    discovery.addListener(discoveryListener);\r\n    try {\r\n        final String servletUrl = NeeoConstants.WEBAPP_PREFIX + NeeoConstants.WEBAPP_DASHBOARD_PREFIX;\r\n        dashboardServlet = new NeeoDashboardServlet(this, servletUrl, localContext);\r\n        localContext.getHttpService().registerServlet(servletUrl, dashboardServlet, new Hashtable(), localContext.getHttpService().createDefaultHttpContext());\r\n        localContext.getHttpService().registerResources(NeeoConstants.WEBAPP_PREFIX, \"web\", localContext.getHttpService().createDefaultHttpContext());\r\n        logger.debug(\"Started NEEO Dashboard tile at {}\", NeeoConstants.WEBAPP_PREFIX);\r\n    } catch (ServletException | NamespaceException e) {\r\n        logger.debug(\"Exception starting status servlet: {}\", e.getMessage(), e);\r\n    }\r\n    BrainDiscovery localDiscovery = discovery;\r\n    if (localDiscovery != null) {\r\n        localDiscovery.startDiscovery();\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.TestDefaultApprovedSiteService.prepare",
	"Comment": "initialize the service and repository mock. initialize a client and\tseveral approvedsite objects for use in unit tests.",
	"Method": "void prepare(){\r\n    client = new ClientDetailsEntity();\r\n    client.setClientId(clientId);\r\n    site1 = new ApprovedSite();\r\n    site1.setId(1L);\r\n    site1.setUserId(\"user1\");\r\n    site1.setClientId(\"other\");\r\n    site2 = new ApprovedSite();\r\n    site2.setId(2L);\r\n    site2.setUserId(\"user1\");\r\n    site2.setClientId(clientId);\r\n    site3 = new ApprovedSite();\r\n    site3.setId(3L);\r\n    site3.setUserId(\"user2\");\r\n    site3.setClientId(clientId);\r\n    Mockito.reset(repository, statsService);\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Quintet.fromCollection",
	"Comment": "create tuple from collection. collection has to have exactly five elements.",
	"Method": "Quintet<X, X, X, X, X> fromCollection(Collection<X> collection){\r\n    return fromIterable(collection);\r\n}"
}, {
	"Path": "org.openhab.binding.globalcache.handler.GlobalCacheHandler.convertHexToGC",
	"Comment": "convert a hex code ir string to a global cache formatted ir string",
	"Method": "String convertHexToGC(String hexCode){\r\n    final int freqConversionFactor = 4145146;\r\n    final int repeat = 1;\r\n    int frequency;\r\n    int sequence1Length;\r\n    int offset;\r\n    String[] hexCodeArray = hexCode.trim().split(\" \");\r\n    if (hexCodeArray.length < 5) {\r\n        throw new HexCodeConversionException(\"Hex code is too short\");\r\n    }\r\n    if (!hexCodeArray[0].equals(\"0000\")) {\r\n        throw new HexCodeConversionException(\"Illegal hex code element 0, should be 0000\");\r\n    }\r\n    try {\r\n        frequency = Math.round(freqConversionFactor / Integer.parseInt(hexCodeArray[1], 16));\r\n    } catch (Exception e) {\r\n        throw new HexCodeConversionException(\"Unable to convert frequency from element 1\");\r\n    }\r\n    try {\r\n        sequence1Length = Integer.parseInt(hexCodeArray[2], 16);\r\n        offset = (sequence1Length * 2) + 1;\r\n    } catch (Exception e) {\r\n        throw new HexCodeConversionException(\"Unable to convert offset from element 2\");\r\n    }\r\n    StringBuilder gcCode = new StringBuilder();\r\n    gcCode.append(frequency);\r\n    gcCode.append(\",\");\r\n    gcCode.append(repeat);\r\n    gcCode.append(\",\");\r\n    gcCode.append(offset);\r\n    try {\r\n        for (int i = 4; i < hexCodeArray.length; i++) {\r\n            gcCode.append(\",\");\r\n            gcCode.append(Integer.parseInt(hexCodeArray[i], 16));\r\n        }\r\n    } catch (Exception e) {\r\n        throw new HexCodeConversionException(\"Unable to convert remaining hex code string\");\r\n    }\r\n    return gcCode.toString();\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Septet.fromCollection",
	"Comment": "create tuple from collection. collection has to have exactly seven elements.",
	"Method": "Septet<X, X, X, X, X, X, X> fromCollection(Collection<X> collection){\r\n    return fromIterable(collection);\r\n}"
}, {
	"Path": "org.openhab.binding.nibeuplink.internal.AtomicReferenceTrait.cancelJob",
	"Comment": "this should usually not called directly. use updatejobreference or canceljobreference instead",
	"Method": "void cancelJob(Future<?> job){\r\n    if (job != null) {\r\n        job.cancel(true);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.toberemoved.cache.ExpiringCacheAsync.getExpiredValue",
	"Comment": "return the raw value, no matter if it is alreadyexpired or still valid.",
	"Method": "V getExpiredValue(){\r\n    return value;\r\n}"
}, {
	"Path": "nginx.clojure.asm.Attribute.getSize",
	"Comment": "returns the size of all the attributes in this attribute list.",
	"Method": "int getSize(ClassWriter cw,byte[] code,int len,int maxStack,int maxLocals){\r\n    Attribute attr = this;\r\n    int size = 0;\r\n    while (attr != null) {\r\n        cw.newUTF8(attr.type);\r\n        size += attr.write(cw, code, len, maxStack, maxLocals).length + 6;\r\n        attr = attr.next;\r\n    }\r\n    return size;\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.unbox",
	"Comment": "generates the instructions to unbox the top stack value. this value isreplaced by its unboxed equivalent on top of the stack.",
	"Method": "void unbox(Type type){\r\n    Type t = NUMBER_TYPE;\r\n    Method sig = null;\r\n    switch(type.getSort()) {\r\n        case Type.VOID:\r\n            return;\r\n        case Type.CHAR:\r\n            t = CHARACTER_TYPE;\r\n            sig = CHAR_VALUE;\r\n            break;\r\n        case Type.BOOLEAN:\r\n            t = BOOLEAN_TYPE;\r\n            sig = BOOLEAN_VALUE;\r\n            break;\r\n        case Type.DOUBLE:\r\n            sig = DOUBLE_VALUE;\r\n            break;\r\n        case Type.FLOAT:\r\n            sig = FLOAT_VALUE;\r\n            break;\r\n        case Type.LONG:\r\n            sig = LONG_VALUE;\r\n            break;\r\n        case Type.INT:\r\n        case Type.SHORT:\r\n        case Type.BYTE:\r\n            sig = INT_VALUE;\r\n    }\r\n    if (sig == null) {\r\n        checkCast(type);\r\n    } else {\r\n        checkCast(t);\r\n        invokeVirtual(t, sig);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.tplinksmarthome.internal.handler.SmartHomeHandler.createConnection",
	"Comment": "creates new connection. methods makes mocking of the connection in tests possible.",
	"Method": "Connection createConnection(TPLinkSmartHomeConfiguration config){\r\n    return new Connection(config.ipAddress);\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxWsClient.stopResponseTimeout",
	"Comment": "stops scheduled timeout waiting for a miniserver responsethe caller must take care of thread synchronization.",
	"Method": "void stopResponseTimeout(){\r\n    logger.trace(\"[{}] stopping response timeout in state {}\", debugId, state);\r\n    if (timeout != null) {\r\n        timeout.cancel(true);\r\n        timeout = null;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.cm11a.internal.X10Interface.receiveCommandData",
	"Comment": "process data that the x10 interface is waiting to send to the pc",
	"Method": "void receiveCommandData(){\r\n    logger.debug(\"Receiving X10 data from interface\");\r\n    serialOutput.write(DATA_READY_HEAD);\r\n    int length = 0;\r\n    do {\r\n        length = serialInput.read();\r\n    } while (length == DATA_READY_REQ || length > 8);\r\n    int mask = serialInput.read();\r\n    length--;\r\n    logger.debug(\"Receiving [{}] bytes,  Addr/Func mask: {}\", length, Integer.toBinaryString(mask));\r\n    if (length > 0) {\r\n        int[] data = new int[length];\r\n        for (int i = 0; i < length; i++) {\r\n            int recvByte = serialInputStr.read();\r\n            data[i] = recvByte;\r\n            logger.debug(\"          Received X10 data [{}]: {}\", i, Integer.toHexString(recvByte));\r\n        }\r\n        processCommandData(mask, data);\r\n    } else {\r\n        logger.warn(\"cm11a buffer was overrun. Any pending commands will be ignorred until the buffer clears.\");\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.lutron.internal.grxprg.PrgProtocolHandler.refreshScene",
	"Comment": "queries the interface for the current scene status on all control units",
	"Method": "void refreshScene(){\r\n    sendCommand(CMD_SCENESTATUS);\r\n}"
}, {
	"Path": "org.openhab.binding.gpstracker.internal.discovery.TrackerDiscoveryService.addTracker",
	"Comment": "called when the source tracker is not registered as a thing. these undiscovered trackers will be registered bythe discovery service.",
	"Method": "void addTracker(String trackerId){\r\n    trackersToDiscover.add(trackerId);\r\n    if (isBackgroundDiscoveryEnabled()) {\r\n        createDiscoveryResult(trackerId);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.protocol.NhcAction.getState",
	"Comment": "get state of action.state is a value between 0 and 100 for a dimmer or rollershutter.rollershutter state is 0 for fully closed and 100 for fully open.state is 0 or 100 for a switch.",
	"Method": "Integer getState(){\r\n    return this.state;\r\n}"
}, {
	"Path": "org.openhab.binding.nibeuplink.internal.model.CustomChannel.setCode",
	"Comment": "used to set the channelcode obtained from configuration file",
	"Method": "void setCode(Integer channelCode){\r\n    if (getChannelGroup().equals(ChannelGroup.CUSTOM)) {\r\n        this.channelCode = channelCode.toString();\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.net.NginxClojureAsynSocket.setWriteTimeout",
	"Comment": "if timeout is negative, it will be ignored. if timeout is 0, this means no timeout.",
	"Method": "void setWriteTimeout(long timeout){\r\n    checkNotClosed();\r\n    setTimeout(s, -1, -1, timeout);\r\n}"
}, {
	"Path": "org.openhab.binding.atlona.internal.pro3.AtlonaPro3PortocolHandler.setPortSwitch",
	"Comment": "sets the input port number to the specified output port number.",
	"Method": "void setPortSwitch(int inPortNbr,int outPortNbr){\r\n    if (inPortNbr <= 0) {\r\n        throw new IllegalArgumentException(\"inPortNbr must be greater than 0\");\r\n    }\r\n    if (outPortNbr <= 0) {\r\n        throw new IllegalArgumentException(\"outPortNbr must be greater than 0\");\r\n    }\r\n    sendCommand(String.format(CMD_PORT_SWITCH_FORMAT, inPortNbr, outPortNbr));\r\n}"
}, {
	"Path": "org.openhab.binding.powermax.internal.handler.PowermaxBridgeHandler.closeConnection",
	"Comment": "close tcp or serial connection to the powermax alarm panel and remove the event listener",
	"Method": "void closeConnection(){\r\n    if (commManager != null) {\r\n        commManager.close();\r\n        commManager.removeEventListener(this);\r\n    }\r\n    logger.debug(\"closeConnection(): disconnected\");\r\n}"
}, {
	"Path": "nginx.clojure.asm.Handle.getName",
	"Comment": "returns the name of the field or method designated by this handle.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "org.openhab.binding.allplay.internal.handler.AllPlayHandler.discoverSpeaker",
	"Comment": "tries to discover the speaker which is associated with this thing.",
	"Method": "void discoverSpeaker(){\r\n    try {\r\n        logger.debug(\"Starting discovery for speaker {}\", getDeviceId());\r\n        allPlay.discoverSpeaker(getDeviceId());\r\n    } catch (DiscoveryException e) {\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Unable to discover speaker: \" + e.getMessage());\r\n        logger.error(\"Unable to discover speaker {}\", getDeviceId(), e);\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.ClientDetailsEntityJsonProcessor.parse",
	"Comment": "create an unbound clientdetailsentity from the given json string.",
	"Method": "ClientDetailsEntity parse(String jsonString,ClientDetailsEntity parse,JsonElement jsonEl){\r\n    if (jsonEl.isJsonObject()) {\r\n        JsonObject o = jsonEl.getAsJsonObject();\r\n        ClientDetailsEntity c = new ClientDetailsEntity();\r\n        c.setClientId(getAsString(o, CLIENT_ID));\r\n        c.setClientSecret(getAsString(o, CLIENT_SECRET));\r\n        c.setRedirectUris(getAsStringSet(o, REDIRECT_URIS));\r\n        c.setClientName(getAsString(o, CLIENT_NAME));\r\n        c.setClientUri(getAsString(o, CLIENT_URI));\r\n        c.setLogoUri(getAsString(o, LOGO_URI));\r\n        c.setContacts(getAsStringSet(o, CONTACTS));\r\n        c.setTosUri(getAsString(o, TOS_URI));\r\n        String authMethod = getAsString(o, TOKEN_ENDPOINT_AUTH_METHOD);\r\n        if (authMethod != null) {\r\n            c.setTokenEndpointAuthMethod(AuthMethod.getByValue(authMethod));\r\n        }\r\n        String scope = getAsString(o, SCOPE);\r\n        if (scope != null) {\r\n            c.setScope(Sets.newHashSet(Splitter.on(SCOPE_SEPARATOR).split(scope)));\r\n        }\r\n        c.setGrantTypes(getAsStringSet(o, GRANT_TYPES));\r\n        c.setResponseTypes(getAsStringSet(o, RESPONSE_TYPES));\r\n        c.setPolicyUri(getAsString(o, POLICY_URI));\r\n        c.setJwksUri(getAsString(o, JWKS_URI));\r\n        JsonElement jwksEl = o.get(JWKS);\r\n        if (jwksEl != null && jwksEl.isJsonObject()) {\r\n            try {\r\n                JWKSet jwks = JWKSet.parse(jwksEl.toString());\r\n                c.setJwks(jwks);\r\n            } catch (ParseException e) {\r\n                logger.error(\"Unable to parse JWK Set for client\", e);\r\n                return null;\r\n            }\r\n        }\r\n        String appType = getAsString(o, APPLICATION_TYPE);\r\n        if (appType != null) {\r\n            c.setApplicationType(AppType.getByValue(appType));\r\n        }\r\n        c.setSectorIdentifierUri(getAsString(o, SECTOR_IDENTIFIER_URI));\r\n        String subjectType = getAsString(o, SUBJECT_TYPE);\r\n        if (subjectType != null) {\r\n            c.setSubjectType(SubjectType.getByValue(subjectType));\r\n        }\r\n        c.setRequestObjectSigningAlg(getAsJwsAlgorithm(o, REQUEST_OBJECT_SIGNING_ALG));\r\n        c.setUserInfoSignedResponseAlg(getAsJwsAlgorithm(o, USERINFO_SIGNED_RESPONSE_ALG));\r\n        c.setUserInfoEncryptedResponseAlg(getAsJweAlgorithm(o, USERINFO_ENCRYPTED_RESPONSE_ALG));\r\n        c.setUserInfoEncryptedResponseEnc(getAsJweEncryptionMethod(o, USERINFO_ENCRYPTED_RESPONSE_ENC));\r\n        c.setIdTokenSignedResponseAlg(getAsJwsAlgorithm(o, ID_TOKEN_SIGNED_RESPONSE_ALG));\r\n        c.setIdTokenEncryptedResponseAlg(getAsJweAlgorithm(o, ID_TOKEN_ENCRYPTED_RESPONSE_ALG));\r\n        c.setIdTokenEncryptedResponseEnc(getAsJweEncryptionMethod(o, ID_TOKEN_ENCRYPTED_RESPONSE_ENC));\r\n        c.setTokenEndpointAuthSigningAlg(getAsJwsAlgorithm(o, TOKEN_ENDPOINT_AUTH_SIGNING_ALG));\r\n        if (o.has(DEFAULT_MAX_AGE)) {\r\n            if (o.get(DEFAULT_MAX_AGE).isJsonPrimitive()) {\r\n                c.setDefaultMaxAge(o.get(DEFAULT_MAX_AGE).getAsInt());\r\n            }\r\n        }\r\n        if (o.has(REQUIRE_AUTH_TIME)) {\r\n            if (o.get(REQUIRE_AUTH_TIME).isJsonPrimitive()) {\r\n                c.setRequireAuthTime(o.get(REQUIRE_AUTH_TIME).getAsBoolean());\r\n            }\r\n        }\r\n        c.setDefaultACRvalues(getAsStringSet(o, DEFAULT_ACR_VALUES));\r\n        c.setInitiateLoginUri(getAsString(o, INITIATE_LOGIN_URI));\r\n        c.setPostLogoutRedirectUris(getAsStringSet(o, POST_LOGOUT_REDIRECT_URIS));\r\n        c.setRequestUris(getAsStringSet(o, REQUEST_URIS));\r\n        c.setClaimsRedirectUris(getAsStringSet(o, CLAIMS_REDIRECT_URIS));\r\n        c.setCodeChallengeMethod(getAsPkceAlgorithm(o, CODE_CHALLENGE_METHOD));\r\n        c.setSoftwareId(getAsString(o, SOFTWARE_ID));\r\n        c.setSoftwareVersion(getAsString(o, SOFTWARE_VERSION));\r\n        String softwareStatement = getAsString(o, SOFTWARE_STATEMENT);\r\n        if (!Strings.isNullOrEmpty(softwareStatement)) {\r\n            try {\r\n                JWT softwareStatementJwt = JWTParser.parse(softwareStatement);\r\n                c.setSoftwareStatement(softwareStatementJwt);\r\n            } catch (ParseException e) {\r\n                logger.warn(\"Error parsing software statement\", e);\r\n                return null;\r\n            }\r\n        }\r\n        return c;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.avmfritz.internal.hardware.FritzAhaWebInterface.authenticate",
	"Comment": "this method authenticates with the fritz!os web interface and updates the session id accordingly",
	"Method": "String authenticate(){\r\n    if (config.getPassword() == null) {\r\n        handler.setStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Please configure password first\");\r\n        return null;\r\n    }\r\n    String loginXml = syncGet(getURL(WEBSERVICE_PATH, addSID(\"\")));\r\n    if (loginXml == null) {\r\n        handler.setStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"FRITZ!Box does not respond\");\r\n        return null;\r\n    }\r\n    Matcher sidmatch = SID_PATTERN.matcher(loginXml);\r\n    if (!sidmatch.find()) {\r\n        handler.setStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"FRITZ!Box does not respond with SID\");\r\n        return null;\r\n    }\r\n    sid = sidmatch.group(1);\r\n    Matcher accmatch = ACCESS_PATTERN.matcher(loginXml);\r\n    if (accmatch.find()) {\r\n        if (\"2\".equals(accmatch.group(1))) {\r\n            handler.setStatusInfo(ThingStatus.ONLINE, ThingStatusDetail.NONE, \"Resuming FRITZ!Box connection with SID \" + sid);\r\n            return sid;\r\n        }\r\n    }\r\n    Matcher challengematch = CHALLENGE_PATTERN.matcher(loginXml);\r\n    if (!challengematch.find()) {\r\n        handler.setStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"FRITZ!Box does not respond with challenge for authentication\");\r\n        return null;\r\n    }\r\n    String challenge = challengematch.group(1);\r\n    String response = createResponse(challenge);\r\n    loginXml = syncGet(getURL(WEBSERVICE_PATH, (config.getUser() != null && !\"\".equals(config.getUser()) ? (\"username=\" + config.getUser() + \"&\") : \"\") + \"response=\" + response));\r\n    if (loginXml == null) {\r\n        handler.setStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"FRITZ!Box does not respond\");\r\n        return null;\r\n    }\r\n    sidmatch = SID_PATTERN.matcher(loginXml);\r\n    if (!sidmatch.find()) {\r\n        handler.setStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"FRITZ!Box does not respond with SID\");\r\n        return null;\r\n    }\r\n    sid = sidmatch.group(1);\r\n    accmatch = ACCESS_PATTERN.matcher(loginXml);\r\n    if (accmatch.find()) {\r\n        if (\"2\".equals(accmatch.group(1))) {\r\n            handler.setStatusInfo(ThingStatus.ONLINE, ThingStatusDetail.NONE, \"Established FRITZ!Box connection with SID \" + sid);\r\n            return sid;\r\n        }\r\n    }\r\n    handler.setStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"User \" + config.getUser() + \" has no access to FRITZ!Box home automation functions\");\r\n    return null;\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.Remapper.mapInvokeDynamicMethodName",
	"Comment": "map invokedynamic method name to the new name. subclasses can override.",
	"Method": "String mapInvokeDynamicMethodName(String name,String desc){\r\n    return name;\r\n}"
}, {
	"Path": "nginx.clojure.asm.signature.SignatureVisitor.visitInterfaceBound",
	"Comment": "visits an interface bound of the last visited formal type parameter.",
	"Method": "SignatureVisitor visitInterfaceBound(){\r\n    return this;\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxUuid.getUpdate",
	"Comment": "see if the object corresponding to uuid has been recently updated.",
	"Method": "boolean getUpdate(){\r\n    return updated;\r\n}"
}, {
	"Path": "org.openhab.io.neeo.internal.NeeoApi.setConnected",
	"Comment": "helper method to set the connected status and fire off change listener",
	"Method": "void setConnected(boolean connected){\r\n    final boolean oldValue = this.connected.getAndSet(connected);\r\n    if (oldValue != connected) {\r\n        propertySupport.firePropertyChange(CONNECTED, oldValue, connected);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.milight.internal.discovery.MilightBridgeDiscovery.startDiscoveryService",
	"Comment": "send a discover message and resends the message until either a valid responseis received or the resend counter reaches the maximum attempts.",
	"Method": "void startDiscoveryService(){\r\n    if (resendTimer != null) {\r\n        return;\r\n    }\r\n    willbeclosed = false;\r\n    try {\r\n        datagramSocket = new DatagramSocket(null);\r\n        datagramSocket.setBroadcast(true);\r\n        datagramSocket.setReuseAddress(true);\r\n        datagramSocket.bind(new InetSocketAddress(receivePort));\r\n    } catch (SocketException e) {\r\n        logger.error(\"Opening a socket for the milight discovery service failed. {}\", e.getLocalizedMessage());\r\n        return;\r\n    }\r\n    resendCounter = 0;\r\n    resendTimer = scheduler.scheduleWithFixedDelay(new SendDiscoverRunnable(), 0, resendTimeoutInMillis, TimeUnit.MILLISECONDS);\r\n    scheduler.execute(this);\r\n}"
}, {
	"Path": "nginx.clojure.asm.util.CheckMethodAdapter.checkLabel",
	"Comment": "checks that the given label is not null. this method can also check thatthe label has been visited.",
	"Method": "void checkLabel(Label label,boolean checkVisited,String msg){\r\n    if (label == null) {\r\n        throw new IllegalArgumentException(\"Invalid \" + msg + \" (must not be null)\");\r\n    }\r\n    if (checkVisited && labels.get(label) == null) {\r\n        throw new IllegalArgumentException(\"Invalid \" + msg + \" (must be visited first)\");\r\n    }\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ProviderTokenService.clearExpiredTokens",
	"Comment": "clears out expired tokens and any abandoned authentication objects",
	"Method": "void clearExpiredTokens(){\r\n    logger.debug(\"Cleaning out all expired tokens\");\r\n    new AbstractPageOperationTemplate<OAuth2AccessTokenEntity>(\"clearExpiredAccessTokens\") {\r\n        @Override\r\n        public Collection<OAuth2AccessTokenEntity> fetchPage() {\r\n            return tokenRepository.getAllExpiredAccessTokens(new DefaultPageCriteria());\r\n        }\r\n        @Override\r\n        public void doOperation(OAuth2AccessTokenEntity item) {\r\n            revokeAccessToken(item);\r\n        }\r\n    }.execute();\r\n    new AbstractPageOperationTemplate<OAuth2RefreshTokenEntity>(\"clearExpiredRefreshTokens\") {\r\n        @Override\r\n        public Collection<OAuth2RefreshTokenEntity> fetchPage() {\r\n            return tokenRepository.getAllExpiredRefreshTokens(new DefaultPageCriteria());\r\n        }\r\n        @Override\r\n        public void doOperation(OAuth2RefreshTokenEntity item) {\r\n            revokeRefreshToken(item);\r\n        }\r\n    }.execute();\r\n    new AbstractPageOperationTemplate<AuthenticationHolderEntity>(\"clearExpiredAuthenticationHolders\") {\r\n        @Override\r\n        public Collection<AuthenticationHolderEntity> fetchPage() {\r\n            return authenticationHolderRepository.getOrphanedAuthenticationHolders(new DefaultPageCriteria());\r\n        }\r\n        @Override\r\n        public void doOperation(AuthenticationHolderEntity item) {\r\n            authenticationHolderRepository.remove(item);\r\n        }\r\n    }.execute();\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ProviderTokenService.clearExpiredTokens",
	"Comment": "clears out expired tokens and any abandoned authentication objects",
	"Method": "void clearExpiredTokens(){\r\n    return tokenRepository.getAllExpiredAccessTokens(new DefaultPageCriteria());\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ProviderTokenService.clearExpiredTokens",
	"Comment": "clears out expired tokens and any abandoned authentication objects",
	"Method": "void clearExpiredTokens(){\r\n    revokeAccessToken(item);\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ProviderTokenService.clearExpiredTokens",
	"Comment": "clears out expired tokens and any abandoned authentication objects",
	"Method": "void clearExpiredTokens(){\r\n    return tokenRepository.getAllExpiredRefreshTokens(new DefaultPageCriteria());\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ProviderTokenService.clearExpiredTokens",
	"Comment": "clears out expired tokens and any abandoned authentication objects",
	"Method": "void clearExpiredTokens(){\r\n    revokeRefreshToken(item);\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ProviderTokenService.clearExpiredTokens",
	"Comment": "clears out expired tokens and any abandoned authentication objects",
	"Method": "void clearExpiredTokens(){\r\n    return authenticationHolderRepository.getOrphanedAuthenticationHolders(new DefaultPageCriteria());\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ProviderTokenService.clearExpiredTokens",
	"Comment": "clears out expired tokens and any abandoned authentication objects",
	"Method": "void clearExpiredTokens(){\r\n    authenticationHolderRepository.remove(item);\r\n}"
}, {
	"Path": "nginx.clojure.asm.tree.AbstractInsnNode.getNext",
	"Comment": "returns the next instruction in the list to which this instructionbelongs, if any.",
	"Method": "AbstractInsnNode getNext(){\r\n    return next;\r\n}"
}, {
	"Path": "org.openhab.binding.milight.internal.protocol.MilightV6SessionManager.sendPreRegistration",
	"Comment": "subsequently send this command for establishing the session. this is not well documented unfortunately.",
	"Method": "void sendPreRegistration(DatagramSocket datagramSocket){\r\n    final InetAddress address = lastKnownIP;\r\n    if (address == null) {\r\n        return;\r\n    }\r\n    byte[] t = { 0x30, 0, 0, 0, 3, sid[0], sid[1], 1, 0 };\r\n    datagramSocket.send(new DatagramPacket(t, t.length, address, port));\r\n}"
}, {
	"Path": "org.openhab.binding.tplinksmarthome.internal.TPLinkSmartHomeDiscoveryServiceTest.testScan",
	"Comment": "test if startscan method finds a device with expected properties.",
	"Method": "void testScan(){\r\n    discoveryService.startScan();\r\n    ArgumentCaptor<DiscoveryResult> discoveryResultCaptor = ArgumentCaptor.forClass(DiscoveryResult.class);\r\n    verify(discoveryListener).thingDiscovered(any(), discoveryResultCaptor.capture());\r\n    DiscoveryResult discoveryResult = discoveryResultCaptor.getValue();\r\n    assertEquals(\"Check if correct binding id found\", TPLinkSmartHomeBindingConstants.BINDING_ID, discoveryResult.getBindingId());\r\n    assertEquals(\"Check if expected number of properties found\", propertiesSize, discoveryResult.getProperties().size());\r\n}"
}, {
	"Path": "org.openhab.binding.powermax.internal.state.PowermaxState.keepOnlyDifferencesWith",
	"Comment": "keep only data that are different from another state and reset all others data to undefined",
	"Method": "void keepOnlyDifferencesWith(PowermaxState otherState){\r\n    for (int i = 1; i <= zones.length; i++) {\r\n        if ((isSensorTripped(i) != null) && isSensorTripped(i).equals(otherState.isSensorTripped(i))) {\r\n            setSensorTripped(i, null);\r\n        }\r\n        if ((getSensorLastTripped(i) != null) && getSensorLastTripped(i).equals(otherState.getSensorLastTripped(i))) {\r\n            setSensorLastTripped(i, null);\r\n        }\r\n        if ((isSensorLowBattery(i) != null) && isSensorLowBattery(i).equals(otherState.isSensorLowBattery(i))) {\r\n            setSensorLowBattery(i, null);\r\n        }\r\n        if ((isSensorBypassed(i) != null) && isSensorBypassed(i).equals(otherState.isSensorBypassed(i))) {\r\n            setSensorBypassed(i, null);\r\n        }\r\n        if ((isSensorArmed(i) != null) && isSensorArmed(i).equals(otherState.isSensorArmed(i))) {\r\n            setSensorArmed(i, null);\r\n        }\r\n    }\r\n    for (int i = 0; i < pgmX10DevicesStatus.length; i++) {\r\n        if ((getPGMX10DeviceStatus(i) != null) && getPGMX10DeviceStatus(i).equals(otherState.getPGMX10DeviceStatus(i))) {\r\n            setPGMX10DeviceStatus(i, null);\r\n        }\r\n    }\r\n    if ((ready != null) && ready.equals(otherState.isReady())) {\r\n        ready = null;\r\n    }\r\n    if ((bypass != null) && bypass.equals(otherState.isBypass())) {\r\n        bypass = null;\r\n    }\r\n    if ((alarmActive != null) && alarmActive.equals(otherState.isAlarmActive())) {\r\n        alarmActive = null;\r\n    }\r\n    if ((trouble != null) && trouble.equals(otherState.isTrouble())) {\r\n        trouble = null;\r\n    }\r\n    if ((alertInMemory != null) && alertInMemory.equals(otherState.isAlertInMemory())) {\r\n        alertInMemory = null;\r\n    }\r\n    if ((statusStr != null) && statusStr.equals(otherState.getStatusStr())) {\r\n        statusStr = null;\r\n    }\r\n    if ((armMode != null) && armMode.equals(otherState.getArmMode())) {\r\n        armMode = null;\r\n    }\r\n    if ((lastKeepAlive != null) && lastKeepAlive.equals(otherState.getLastKeepAlive())) {\r\n        lastKeepAlive = null;\r\n    }\r\n    if ((panelStatus != null) && panelStatus.equals(otherState.getPanelStatus())) {\r\n        panelStatus = null;\r\n    }\r\n    if ((alarmType != null) && alarmType.equals(otherState.getAlarmType())) {\r\n        alarmType = null;\r\n    }\r\n    if ((troubleType != null) && troubleType.equals(otherState.getTroubleType())) {\r\n        troubleType = null;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.PresenceDetection.setUseArpPing",
	"Comment": "enables or disables arp pings. will be automatically disabled if the destinationis not an ipv4 address. if the feature test for the native arping utility fails,it will be disabled as well.",
	"Method": "void setUseArpPing(boolean enable,String arpPingUtilPath){\r\n    this.arpPingUtilPath = arpPingUtilPath;\r\n    if (!enable || StringUtils.isBlank(arpPingUtilPath)) {\r\n        arpPingMethod = null;\r\n        return;\r\n    } else if (destination == null || !(destination instanceof Inet4Address)) {\r\n        arpPingMethod = null;\r\n        return;\r\n    }\r\n    arpPingMethod = networkUtils.determineNativeARPpingMethod(arpPingUtilPath);\r\n}"
}, {
	"Path": "org.openhab.binding.cm11a.internal.X10Interface.connect",
	"Comment": "establishes a serial connection to the hardware, if one is not already established.",
	"Method": "boolean connect(){\r\n    if (!connected) {\r\n        if (serialPort != null) {\r\n            logger.trace(\"Closing stale serialPort object before reconnecting\");\r\n            serialPort.close();\r\n        }\r\n        logger.debug(\"Connecting to X10 hardware on serial port: {}\", portId.getName());\r\n        try {\r\n            serialPort = portId.open(\"Openhab CM11A Binding\", IO_PORT_OPEN_TIMEOUT);\r\n            serialPort.setSerialPortParams(4800, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\r\n            serialPort.setFlowControlMode(SerialPort.FLOWCONTROL_NONE);\r\n            serialPort.disableReceiveTimeout();\r\n            serialPort.enableReceiveThreshold(1);\r\n            serialOutputStr = serialPort.getOutputStream();\r\n            serialOutput = new DataOutputStream(serialOutputStr);\r\n            serialInputStr = serialPort.getInputStream();\r\n            serialInput = new DataInputStream(serialInputStr);\r\n            serialPort.addEventListener(this);\r\n            connected = true;\r\n            serialPort.notifyOnDataAvailable(true);\r\n            serialPort.notifyOnRingIndicator(true);\r\n            serialPort.enableReceiveTimeout(SERIAL_TIMEOUT_MSEC);\r\n            if (!serialPort.isReceiveTimeoutEnabled()) {\r\n                logger.info(\"Serial receive timeout not supported by this driver.\");\r\n            }\r\n            bridgeHandler.changeBridgeStatusToUp();\r\n        } catch (PortInUseException e) {\r\n            String message = String.format(\"Serial port %s is in use by another application (%s)\", portId.getName(), e.currentOwner);\r\n            logger.warn(\"{}\", message);\r\n            bridgeHandler.changeBridgeStatusToDown(message);\r\n        } catch (UnsupportedCommOperationException e) {\r\n            logger.warn(\"Serial port {} doesn't support the required baud/parity/stopbits or Timeout\", portId.getName());\r\n        } catch (IOException e) {\r\n            logger.warn(\"IO Problem with serial port {} . {}\", portId.getName(), e.getMessage());\r\n        } catch (TooManyListenersException e) {\r\n            logger.warn(\"TooManyListeners error when trying to connect to serial port.  Interface is unlikely to work, raise a bug report.\", e);\r\n            bridgeHandler.changeBridgeStatusToDown(\"ToManyListenersException\");\r\n        }\r\n    } else {\r\n        logger.trace(\"Already connected to hardware, skipping reconnection.\");\r\n    }\r\n    return connected;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.config.ConfigurationPropertiesBean.checkConfigConsistency",
	"Comment": "endpoints protected by tls must have https scheme in the uri.",
	"Method": "void checkConfigConsistency(){\r\n    if (!StringUtils.startsWithIgnoreCase(issuer, \"https\")) {\r\n        if (this.forceHttps) {\r\n            logger.error(\"Configured issuer url is not using https scheme. Server will be shut down!\");\r\n            throw new BeanCreationException(\"Issuer is not using https scheme as required: \" + issuer);\r\n        } else {\r\n            logger.warn(\"\\n\\n**\\n** WARNING: Configured issuer url is not using https scheme.\\n**\\n\\n\");\r\n        }\r\n    }\r\n    if (languageNamespaces == null || languageNamespaces.isEmpty()) {\r\n        logger.error(\"No configured language namespaces! Text rendering will fail!\");\r\n    }\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.internal.ModbusLibraryWrapper.createTransactionForEndpoint",
	"Comment": "create a fresh transaction for the given endpoint and connectionthe retries of the transaction will be disabled.",
	"Method": "ModbusTransaction createTransactionForEndpoint(ModbusSlaveEndpoint endpoint,Optional<ModbusSlaveConnection> connection){\r\n    ModbusTransaction transaction = endpoint.accept(new ModbusSlaveEndpointVisitor<ModbusTransaction>() {\r\n        @Override\r\n        @NonNull\r\n        public ModbusTransaction visit(ModbusTCPSlaveEndpoint modbusIPSlavePoolingKey) {\r\n            ModbusTCPTransaction transaction = new ModbusTCPTransaction();\r\n            transaction.setReconnecting(false);\r\n            return transaction;\r\n        }\r\n        @Override\r\n        @NonNull\r\n        public ModbusTransaction visit(ModbusSerialSlaveEndpoint modbusSerialSlavePoolingKey) {\r\n            return new ModbusSerialTransaction();\r\n        }\r\n        @Override\r\n        @NonNull\r\n        public ModbusTransaction visit(ModbusUDPSlaveEndpoint modbusUDPSlavePoolingKey) {\r\n            return new ModbusUDPTransaction();\r\n        }\r\n    });\r\n    transaction.setRetries(0);\r\n    transaction.setRetryDelayMillis(0);\r\n    if (transaction instanceof ModbusSerialTransaction) {\r\n        ((ModbusSerialTransaction) transaction).setSerialConnection((SerialConnection) connection.get());\r\n    } else if (transaction instanceof ModbusUDPTransaction) {\r\n        ((ModbusUDPTransaction) transaction).setTerminal(((UDPMasterConnection) connection.get()).getTerminal());\r\n    } else if (transaction instanceof ModbusTCPTransaction) {\r\n        ((ModbusTCPTransaction) transaction).setConnection((TCPMasterConnection) connection.get());\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n    return transaction;\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.internal.ModbusLibraryWrapper.createTransactionForEndpoint",
	"Comment": "create a fresh transaction for the given endpoint and connectionthe retries of the transaction will be disabled.",
	"Method": "ModbusTransaction createTransactionForEndpoint(ModbusSlaveEndpoint endpoint,Optional<ModbusSlaveConnection> connection){\r\n    ModbusTCPTransaction transaction = new ModbusTCPTransaction();\r\n    transaction.setReconnecting(false);\r\n    return transaction;\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.internal.ModbusLibraryWrapper.createTransactionForEndpoint",
	"Comment": "create a fresh transaction for the given endpoint and connectionthe retries of the transaction will be disabled.",
	"Method": "ModbusTransaction createTransactionForEndpoint(ModbusSlaveEndpoint endpoint,Optional<ModbusSlaveConnection> connection){\r\n    return new ModbusSerialTransaction();\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.internal.ModbusLibraryWrapper.createTransactionForEndpoint",
	"Comment": "create a fresh transaction for the given endpoint and connectionthe retries of the transaction will be disabled.",
	"Method": "ModbusTransaction createTransactionForEndpoint(ModbusSlaveEndpoint endpoint,Optional<ModbusSlaveConnection> connection){\r\n    return new ModbusUDPTransaction();\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.TelegramReaderUtil.readRawTelegram",
	"Comment": "reads the raw bytes of the telegram given the file relative to this package and returns the objects.",
	"Method": "byte[] readRawTelegram(String telegramName){\r\n    try (InputStream is = TelegramReaderUtil.class.getResourceAsStream(telegramName + TELEGRAM_EXT)) {\r\n        return IOUtils.toByteArray(is);\r\n    } catch (IOException e) {\r\n        throw new AssertionError(\"IOException reading telegram data: \", e);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.feican.internal.FeicanDiscoveryService.stringToMac",
	"Comment": "converts a byte representation of a mac address to a real mac address.",
	"Method": "String stringToMac(byte[] data,int length){\r\n    return new String(data, 0, length - 1, StandardCharsets.UTF_8).replaceAll(\"(..)(?!$)\", \"$1:\");\r\n}"
}, {
	"Path": "org.mitre.openid.connect.client.keypublisher.ClientKeyPublisher.postProcessBeanFactory",
	"Comment": "if the jwkpublishurl field is set on this bean, set up a listener on that url to publish keys.",
	"Method": "void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory){\r\n    if (!Strings.isNullOrEmpty(getJwkPublishUrl())) {\r\n        BeanDefinitionBuilder clientKeyMapping = BeanDefinitionBuilder.rootBeanDefinition(ClientKeyPublisherMapping.class);\r\n        BeanDefinitionBuilder viewResolver = BeanDefinitionBuilder.rootBeanDefinition(JwkViewResolver.class);\r\n        if (!Strings.isNullOrEmpty(getJwkPublishUrl())) {\r\n            clientKeyMapping.addPropertyValue(\"jwkPublishUrl\", getJwkPublishUrl());\r\n            jwkViewName = JWKSetView.VIEWNAME + \"-\" + UUID.randomUUID().toString();\r\n            viewResolver.addPropertyValue(\"jwkViewName\", jwkViewName);\r\n            BeanDefinitionBuilder jwkView = BeanDefinitionBuilder.rootBeanDefinition(JWKSetView.class);\r\n            registry.registerBeanDefinition(JWKSetView.VIEWNAME, jwkView.getBeanDefinition());\r\n            viewResolver.addPropertyReference(\"jwk\", JWKSetView.VIEWNAME);\r\n        }\r\n        registry.registerBeanDefinition(\"clientKeyMapping\", clientKeyMapping.getBeanDefinition());\r\n        registry.registerBeanDefinition(\"jwkViewResolver\", viewResolver.getBeanDefinition());\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.device.p1telegram.P1TelegramParser.storeCurrentCosemObject",
	"Comment": "store the current cosemobject in the list of received cosem objects",
	"Method": "void storeCurrentCosemObject(){\r\n    String obisIdString = obisId.toString();\r\n    if (!obisIdString.isEmpty()) {\r\n        CosemObject cosemObject = factory.getCosemObject(obisIdString, cosemObjectValuesString.toString());\r\n        if (cosemObject != null) {\r\n            logger.trace(\"Adding {} to list of Cosem Objects\", cosemObject);\r\n            cosemObjects.add(cosemObject);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.tree.InsnList.resetLabels",
	"Comment": "reset all labels in the instruction list. this method should be calledbefore reusing same instructions list between severalclasswriters.",
	"Method": "void resetLabels(){\r\n    AbstractInsnNode insn = first;\r\n    while (insn != null) {\r\n        if (insn instanceof LabelNode) {\r\n            ((LabelNode) insn).resetLabel();\r\n        }\r\n        insn = insn.next;\r\n    }\r\n}"
}, {
	"Path": "org.apache.coyote.http11.NginxChannel.write",
	"Comment": "writes a sequence of bytes to this channel from the given buffer.",
	"Method": "int write(ByteBuffer src){\r\n    checkInterruptStatus();\r\n    return (int) sc.write(src);\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.protocol.xml.XMLProtocolService.getResponse",
	"Comment": "send the command and retrieve the node at the specified element path.",
	"Method": "Node getResponse(AbstractConnection con,String cmd,String path){\r\n    String response = con.sendReceive(cmd);\r\n    Document doc = XMLUtils.xml(response);\r\n    if (doc.getFirstChild() == null) {\r\n        throw new ReceivedMessageParseException(\"The command '\" + cmd + \"' failed: \" + response);\r\n    }\r\n    Node content = XMLUtils.getNode(doc.getFirstChild(), path);\r\n    return content;\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassReader.readCode",
	"Comment": "reads the bytecode of a method and makes the given visitor visit it.",
	"Method": "void readCode(MethodVisitor mv,Context context,int u){\r\n    byte[] b = this.b;\r\n    char[] c = context.buffer;\r\n    int maxStack = readUnsignedShort(u);\r\n    int maxLocals = readUnsignedShort(u + 2);\r\n    int codeLength = readInt(u + 4);\r\n    u += 8;\r\n    int codeStart = u;\r\n    int codeEnd = u + codeLength;\r\n    Label[] labels = new Label[codeLength + 2];\r\n    readLabel(codeLength + 1, labels);\r\n    while (u < codeEnd) {\r\n        int offset = u - codeStart;\r\n        int opcode = b[u] & 0xFF;\r\n        switch(ClassWriter.TYPE[opcode]) {\r\n            case ClassWriter.NOARG_INSN:\r\n            case ClassWriter.IMPLVAR_INSN:\r\n                u += 1;\r\n                break;\r\n            case ClassWriter.LABEL_INSN:\r\n                readLabel(offset + readShort(u + 1), labels);\r\n                u += 3;\r\n                break;\r\n            case ClassWriter.LABELW_INSN:\r\n                readLabel(offset + readInt(u + 1), labels);\r\n                u += 5;\r\n                break;\r\n            case ClassWriter.WIDE_INSN:\r\n                opcode = b[u + 1] & 0xFF;\r\n                if (opcode == Opcodes.IINC) {\r\n                    u += 6;\r\n                } else {\r\n                    u += 4;\r\n                }\r\n                break;\r\n            case ClassWriter.TABL_INSN:\r\n                u = u + 4 - (offset & 3);\r\n                readLabel(offset + readInt(u), labels);\r\n                for (int i = readInt(u + 8) - readInt(u + 4) + 1; i > 0; --i) {\r\n                    readLabel(offset + readInt(u + 12), labels);\r\n                    u += 4;\r\n                }\r\n                u += 12;\r\n                break;\r\n            case ClassWriter.LOOK_INSN:\r\n                u = u + 4 - (offset & 3);\r\n                readLabel(offset + readInt(u), labels);\r\n                for (int i = readInt(u + 4); i > 0; --i) {\r\n                    readLabel(offset + readInt(u + 12), labels);\r\n                    u += 8;\r\n                }\r\n                u += 8;\r\n                break;\r\n            case ClassWriter.VAR_INSN:\r\n            case ClassWriter.SBYTE_INSN:\r\n            case ClassWriter.LDC_INSN:\r\n                u += 2;\r\n                break;\r\n            case ClassWriter.SHORT_INSN:\r\n            case ClassWriter.LDCW_INSN:\r\n            case ClassWriter.FIELDORMETH_INSN:\r\n            case ClassWriter.TYPE_INSN:\r\n            case ClassWriter.IINC_INSN:\r\n                u += 3;\r\n                break;\r\n            case ClassWriter.ITFMETH_INSN:\r\n            case ClassWriter.INDYMETH_INSN:\r\n                u += 5;\r\n                break;\r\n            default:\r\n                u += 4;\r\n                break;\r\n        }\r\n    }\r\n    for (int i = readUnsignedShort(u); i > 0; --i) {\r\n        Label start = readLabel(readUnsignedShort(u + 2), labels);\r\n        Label end = readLabel(readUnsignedShort(u + 4), labels);\r\n        Label handler = readLabel(readUnsignedShort(u + 6), labels);\r\n        String type = readUTF8(items[readUnsignedShort(u + 8)], c);\r\n        mv.visitTryCatchBlock(start, end, handler, type);\r\n        u += 8;\r\n    }\r\n    u += 2;\r\n    int varTable = 0;\r\n    int varTypeTable = 0;\r\n    boolean zip = true;\r\n    boolean unzip = (context.flags & EXPAND_FRAMES) != 0;\r\n    int stackMap = 0;\r\n    int stackMapSize = 0;\r\n    int frameCount = 0;\r\n    Context frame = null;\r\n    Attribute attributes = null;\r\n    for (int i = readUnsignedShort(u); i > 0; --i) {\r\n        String attrName = readUTF8(u + 2, c);\r\n        if (\"LocalVariableTable\".equals(attrName)) {\r\n            if ((context.flags & SKIP_DEBUG) == 0) {\r\n                varTable = u + 8;\r\n                for (int j = readUnsignedShort(u + 8), v = u; j > 0; --j) {\r\n                    int label = readUnsignedShort(v + 10);\r\n                    if (labels[label] == null) {\r\n                        readLabel(label, labels).status |= Label.DEBUG;\r\n                    }\r\n                    label += readUnsignedShort(v + 12);\r\n                    if (labels[label] == null) {\r\n                        readLabel(label, labels).status |= Label.DEBUG;\r\n                    }\r\n                    v += 10;\r\n                }\r\n            }\r\n        } else if (\"LocalVariableTypeTable\".equals(attrName)) {\r\n            varTypeTable = u + 8;\r\n        } else if (\"LineNumberTable\".equals(attrName)) {\r\n            if ((context.flags & SKIP_DEBUG) == 0) {\r\n                for (int j = readUnsignedShort(u + 8), v = u; j > 0; --j) {\r\n                    int label = readUnsignedShort(v + 10);\r\n                    if (labels[label] == null) {\r\n                        readLabel(label, labels).status |= Label.DEBUG;\r\n                    }\r\n                    labels[label].line = readUnsignedShort(v + 12);\r\n                    v += 4;\r\n                }\r\n            }\r\n        } else if (FRAMES && \"StackMapTable\".equals(attrName)) {\r\n            if ((context.flags & SKIP_FRAMES) == 0) {\r\n                stackMap = u + 10;\r\n                stackMapSize = readInt(u + 4);\r\n                frameCount = readUnsignedShort(u + 8);\r\n            }\r\n        } else if (FRAMES && \"StackMap\".equals(attrName)) {\r\n            if ((context.flags & SKIP_FRAMES) == 0) {\r\n                zip = false;\r\n                stackMap = u + 10;\r\n                stackMapSize = readInt(u + 4);\r\n                frameCount = readUnsignedShort(u + 8);\r\n            }\r\n        } else {\r\n            for (int j = 0; j < context.attrs.length; ++j) {\r\n                if (context.attrs[j].type.equals(attrName)) {\r\n                    Attribute attr = context.attrs[j].read(this, u + 8, readInt(u + 4), c, codeStart - 8, labels);\r\n                    if (attr != null) {\r\n                        attr.next = attributes;\r\n                        attributes = attr;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        u += 6 + readInt(u + 4);\r\n    }\r\n    u += 2;\r\n    if (FRAMES && stackMap != 0) {\r\n        frame = context;\r\n        frame.offset = -1;\r\n        frame.mode = 0;\r\n        frame.localCount = 0;\r\n        frame.localDiff = 0;\r\n        frame.stackCount = 0;\r\n        frame.local = new Object[maxLocals];\r\n        frame.stack = new Object[maxStack];\r\n        if (unzip) {\r\n            getImplicitFrame(context);\r\n        }\r\n        for (int i = stackMap; i < stackMap + stackMapSize - 2; ++i) {\r\n            if (b[i] == 8) {\r\n                int v = readUnsignedShort(i + 1);\r\n                if (v >= 0 && v < codeLength) {\r\n                    if ((b[codeStart + v] & 0xFF) == Opcodes.NEW) {\r\n                        readLabel(v, labels);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    u = codeStart;\r\n    while (u < codeEnd) {\r\n        int offset = u - codeStart;\r\n        Label l = labels[offset];\r\n        if (l != null) {\r\n            mv.visitLabel(l);\r\n            if ((context.flags & SKIP_DEBUG) == 0 && l.line > 0) {\r\n                mv.visitLineNumber(l.line, l);\r\n            }\r\n        }\r\n        while (FRAMES && frame != null && (frame.offset == offset || frame.offset == -1)) {\r\n            if (frame.offset != -1) {\r\n                if (!zip || unzip) {\r\n                    mv.visitFrame(Opcodes.F_NEW, frame.localCount, frame.local, frame.stackCount, frame.stack);\r\n                } else {\r\n                    mv.visitFrame(frame.mode, frame.localDiff, frame.local, frame.stackCount, frame.stack);\r\n                }\r\n            }\r\n            if (frameCount > 0) {\r\n                stackMap = readFrame(stackMap, zip, unzip, labels, frame);\r\n                --frameCount;\r\n            } else {\r\n                frame = null;\r\n            }\r\n        }\r\n        int opcode = b[u] & 0xFF;\r\n        switch(ClassWriter.TYPE[opcode]) {\r\n            case ClassWriter.NOARG_INSN:\r\n                mv.visitInsn(opcode);\r\n                u += 1;\r\n                break;\r\n            case ClassWriter.IMPLVAR_INSN:\r\n                if (opcode > Opcodes.ISTORE) {\r\n                    opcode -= 59;\r\n                    mv.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);\r\n                } else {\r\n                    opcode -= 26;\r\n                    mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 0x3);\r\n                }\r\n                u += 1;\r\n                break;\r\n            case ClassWriter.LABEL_INSN:\r\n                mv.visitJumpInsn(opcode, labels[offset + readShort(u + 1)]);\r\n                u += 3;\r\n                break;\r\n            case ClassWriter.LABELW_INSN:\r\n                mv.visitJumpInsn(opcode - 33, labels[offset + readInt(u + 1)]);\r\n                u += 5;\r\n                break;\r\n            case ClassWriter.WIDE_INSN:\r\n                opcode = b[u + 1] & 0xFF;\r\n                if (opcode == Opcodes.IINC) {\r\n                    mv.visitIincInsn(readUnsignedShort(u + 2), readShort(u + 4));\r\n                    u += 6;\r\n                } else {\r\n                    mv.visitVarInsn(opcode, readUnsignedShort(u + 2));\r\n                    u += 4;\r\n                }\r\n                break;\r\n            case ClassWriter.TABL_INSN:\r\n                {\r\n                    u = u + 4 - (offset & 3);\r\n                    int label = offset + readInt(u);\r\n                    int min = readInt(u + 4);\r\n                    int max = readInt(u + 8);\r\n                    Label[] table = new Label[max - min + 1];\r\n                    u += 12;\r\n                    for (int i = 0; i < table.length; ++i) {\r\n                        table[i] = labels[offset + readInt(u)];\r\n                        u += 4;\r\n                    }\r\n                    mv.visitTableSwitchInsn(min, max, labels[label], table);\r\n                    break;\r\n                }\r\n            case ClassWriter.LOOK_INSN:\r\n                {\r\n                    u = u + 4 - (offset & 3);\r\n                    int label = offset + readInt(u);\r\n                    int len = readInt(u + 4);\r\n                    int[] keys = new int[len];\r\n                    Label[] values = new Label[len];\r\n                    u += 8;\r\n                    for (int i = 0; i < len; ++i) {\r\n                        keys[i] = readInt(u);\r\n                        values[i] = labels[offset + readInt(u + 4)];\r\n                        u += 8;\r\n                    }\r\n                    mv.visitLookupSwitchInsn(labels[label], keys, values);\r\n                    break;\r\n                }\r\n            case ClassWriter.VAR_INSN:\r\n                mv.visitVarInsn(opcode, b[u + 1] & 0xFF);\r\n                u += 2;\r\n                break;\r\n            case ClassWriter.SBYTE_INSN:\r\n                mv.visitIntInsn(opcode, b[u + 1]);\r\n                u += 2;\r\n                break;\r\n            case ClassWriter.SHORT_INSN:\r\n                mv.visitIntInsn(opcode, readShort(u + 1));\r\n                u += 3;\r\n                break;\r\n            case ClassWriter.LDC_INSN:\r\n                mv.visitLdcInsn(readConst(b[u + 1] & 0xFF, c));\r\n                u += 2;\r\n                break;\r\n            case ClassWriter.LDCW_INSN:\r\n                mv.visitLdcInsn(readConst(readUnsignedShort(u + 1), c));\r\n                u += 3;\r\n                break;\r\n            case ClassWriter.FIELDORMETH_INSN:\r\n            case ClassWriter.ITFMETH_INSN:\r\n                {\r\n                    int cpIndex = items[readUnsignedShort(u + 1)];\r\n                    String iowner = readClass(cpIndex, c);\r\n                    cpIndex = items[readUnsignedShort(cpIndex + 2)];\r\n                    String iname = readUTF8(cpIndex, c);\r\n                    String idesc = readUTF8(cpIndex + 2, c);\r\n                    if (opcode < Opcodes.INVOKEVIRTUAL) {\r\n                        mv.visitFieldInsn(opcode, iowner, iname, idesc);\r\n                    } else {\r\n                        mv.visitMethodInsn(opcode, iowner, iname, idesc);\r\n                    }\r\n                    if (opcode == Opcodes.INVOKEINTERFACE) {\r\n                        u += 5;\r\n                    } else {\r\n                        u += 3;\r\n                    }\r\n                    break;\r\n                }\r\n            case ClassWriter.INDYMETH_INSN:\r\n                {\r\n                    int cpIndex = items[readUnsignedShort(u + 1)];\r\n                    int bsmIndex = context.bootstrapMethods[readUnsignedShort(cpIndex)];\r\n                    Handle bsm = (Handle) readConst(readUnsignedShort(bsmIndex), c);\r\n                    int bsmArgCount = readUnsignedShort(bsmIndex + 2);\r\n                    Object[] bsmArgs = new Object[bsmArgCount];\r\n                    bsmIndex += 4;\r\n                    for (int i = 0; i < bsmArgCount; i++) {\r\n                        bsmArgs[i] = readConst(readUnsignedShort(bsmIndex), c);\r\n                        bsmIndex += 2;\r\n                    }\r\n                    cpIndex = items[readUnsignedShort(cpIndex + 2)];\r\n                    String iname = readUTF8(cpIndex, c);\r\n                    String idesc = readUTF8(cpIndex + 2, c);\r\n                    mv.visitInvokeDynamicInsn(iname, idesc, bsm, bsmArgs);\r\n                    u += 5;\r\n                    break;\r\n                }\r\n            case ClassWriter.TYPE_INSN:\r\n                mv.visitTypeInsn(opcode, readClass(u + 1, c));\r\n                u += 3;\r\n                break;\r\n            case ClassWriter.IINC_INSN:\r\n                mv.visitIincInsn(b[u + 1] & 0xFF, b[u + 2]);\r\n                u += 3;\r\n                break;\r\n            default:\r\n                mv.visitMultiANewArrayInsn(readClass(u + 1, c), b[u + 3] & 0xFF);\r\n                u += 4;\r\n                break;\r\n        }\r\n    }\r\n    if (labels[codeLength] != null) {\r\n        mv.visitLabel(labels[codeLength]);\r\n    }\r\n    if ((context.flags & SKIP_DEBUG) == 0 && varTable != 0) {\r\n        int[] typeTable = null;\r\n        if (varTypeTable != 0) {\r\n            u = varTypeTable + 2;\r\n            typeTable = new int[readUnsignedShort(varTypeTable) * 3];\r\n            for (int i = typeTable.length; i > 0; ) {\r\n                typeTable[--i] = u + 6;\r\n                typeTable[--i] = readUnsignedShort(u + 8);\r\n                typeTable[--i] = readUnsignedShort(u);\r\n                u += 10;\r\n            }\r\n        }\r\n        u = varTable + 2;\r\n        for (int i = readUnsignedShort(varTable); i > 0; --i) {\r\n            int start = readUnsignedShort(u);\r\n            int length = readUnsignedShort(u + 2);\r\n            int index = readUnsignedShort(u + 8);\r\n            String vsignature = null;\r\n            if (typeTable != null) {\r\n                for (int j = 0; j < typeTable.length; j += 3) {\r\n                    if (typeTable[j] == start && typeTable[j + 1] == index) {\r\n                        vsignature = readUTF8(typeTable[j + 2], c);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            mv.visitLocalVariable(readUTF8(u + 4, c), readUTF8(u + 6, c), vsignature, labels[start], labels[start + length], index);\r\n            u += 10;\r\n        }\r\n    }\r\n    while (attributes != null) {\r\n        Attribute attr = attributes.next;\r\n        attributes.next = null;\r\n        mv.visitAttribute(attributes);\r\n        attributes = attr;\r\n    }\r\n    mv.visitMaxs(maxStack, maxLocals);\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.zone.RioZoneProtocol.handleZoneFavoriteNotification",
	"Comment": "handles any system notifications returned by the russound system",
	"Method": "void handleZoneFavoriteNotification(Matcher m,String resp){\r\n    if (m == null) {\r\n        throw new IllegalArgumentException(\"m (matcher) cannot be null\");\r\n    }\r\n    if (m.groupCount() == 5) {\r\n        try {\r\n            final int notifyController = Integer.parseInt(m.group(1));\r\n            if (notifyController != controller) {\r\n                return;\r\n            }\r\n            final int notifyZone = Integer.parseInt(m.group(2));\r\n            if (notifyZone != zone) {\r\n                return;\r\n            }\r\n            final int favoriteId = Integer.parseInt(m.group(3));\r\n            if (favoriteId >= 1 && favoriteId <= 2) {\r\n                final RioFavorite fav = zoneFavorites[favoriteId - 1];\r\n                final String key = m.group(4);\r\n                final String value = m.group(5);\r\n                switch(key) {\r\n                    case FAV_NAME:\r\n                        fav.setName(value);\r\n                        updateZoneFavoritesChannel();\r\n                        break;\r\n                    case FAV_VALID:\r\n                        fav.setValid(!\"false\".equalsIgnoreCase(value));\r\n                        updateZoneFavoritesChannel();\r\n                        break;\r\n                    default:\r\n                        logger.warn(\"Unknown zone favorite notification: '{}'\", resp);\r\n                        break;\r\n                }\r\n            } else {\r\n                logger.warn(\"Invalid Zone Favorite Notification (favorite < 1 or > 2): '{}')\", resp);\r\n            }\r\n        } catch (NumberFormatException e) {\r\n            logger.warn(\"Invalid Zone Favorite Notification (favorite not a parsable integer): '{}')\", resp);\r\n        }\r\n    } else {\r\n        logger.warn(\"Invalid Zone Notification response: '{}'\", resp);\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.ifNull",
	"Comment": "generates the instruction to jump to the given label if the top stackvalue is null.",
	"Method": "void ifNull(Label label){\r\n    mv.visitJumpInsn(Opcodes.IFNULL, label);\r\n}"
}, {
	"Path": "org.openhab.binding.solaredge.internal.model.LiveDataResponseMeterless.assignValue",
	"Comment": "converts the value to quantitytype. if no value provided undeftype.undef will be used",
	"Method": "void assignValue(Map<Channel, State> targetMap,Channel channel,Double value,Unit<T> unit){\r\n    State result = UnDefType.UNDEF;\r\n    if (value != null && unit != null) {\r\n        result = new QuantityType<T>(value, unit);\r\n    } else {\r\n        logger.debug(\"Channel {}: no value/unit provided\", channel);\r\n    }\r\n    targetMap.put(channel, result);\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.handler.LoxoneMiniserverHandler.addChannelTags",
	"Comment": "add tags that can be used by homekit transport and alexa openhab skill",
	"Method": "void addChannelTags(Set<String> tags,LxControl control){\r\n    if (control instanceof LxControlSwitch) {\r\n        LxCategory category = control.getCategory();\r\n        if (category != null && category.getType() == LxCategory.CategoryType.LIGHTS) {\r\n            tags.add(\"Lighting\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.github.shyiko.mysql.binlog.BinaryLogClient.registerLifecycleListener",
	"Comment": "register lifecycle listener. note that multiple lifecycle listeners will be called in order theywhere registered.",
	"Method": "void registerLifecycleListener(LifecycleListener lifecycleListener){\r\n    lifecycleListeners.add(lifecycleListener);\r\n}"
}, {
	"Path": "org.openhab.binding.dlinksmarthome.internal.DLinkHNAPCommunication.unexpectedResult",
	"Comment": "output unexpected responses to the debug log and sets the firmware error.",
	"Method": "void unexpectedResult(String message,Document soapResponse){\r\n    logUnexpectedResult(message, soapResponse);\r\n    status = HNAPStatus.UNSUPPORTED_FIRMWARE;\r\n}"
}, {
	"Path": "org.openhab.binding.lutron.internal.grxprg.GrafikEyeConfig.validate",
	"Comment": "validates the configuration. ensures the control unit. fade and shadeerror are valid.",
	"Method": "String validate(){\r\n    if (controlUnit < 1 || controlUnit > 8) {\r\n        return \"controlUnit must be between 1-8\";\r\n    }\r\n    if (fade < 0 || fade > 3600) {\r\n        return \"fade must be between 0-3600\";\r\n    }\r\n    if (shadeError != null) {\r\n        return shadeError;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.coyote.http11.NginxChannel.flush",
	"Comment": "returns true if the network buffer has been flushed out and is empty.",
	"Method": "boolean flush(boolean block,Selector s,long timeout){\r\n    return true;\r\n}"
}, {
	"Path": "org.openhab.binding.opensprinkler.internal.util.Http.sendHttpPost",
	"Comment": "given a url and a set parameters, send a http post request to the url location created by the url and parameters.",
	"Method": "String sendHttpPost(String url,String urlParameters){\r\n    URL location = new URL(url);\r\n    HttpURLConnection connection = (HttpsURLConnection) location.openConnection();\r\n    connection.setRequestMethod(HTTP_POST);\r\n    connection.setRequestProperty(\"User-Agent\", USER_AGENT);\r\n    connection.setDoOutput(true);\r\n    DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\r\n    wr.writeBytes(urlParameters);\r\n    wr.flush();\r\n    wr.close();\r\n    int responseCode = connection.getResponseCode();\r\n    if (responseCode != HTTP_OK_CODE) {\r\n        throw new Exception(\"Error sending HTTP POST request to \" + url + \". Got responce code: \" + responseCode);\r\n    }\r\n    BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\r\n    String inputLine;\r\n    StringBuilder response = new StringBuilder();\r\n    while ((inputLine = in.readLine()) != null) {\r\n        response.append(inputLine);\r\n    }\r\n    in.close();\r\n    return response.toString();\r\n}"
}, {
	"Path": "org.openhab.binding.amazondashbutton.internal.discovery.AmazonDashButtonDiscoveryService.isAmazonVendor",
	"Comment": "returns true if the passed macaddress is an amazon mac address.",
	"Method": "boolean isAmazonVendor(String macAddress){\r\n    String vendorPrefix = macAddress.substring(0, 8).toUpperCase();\r\n    return VENDOR_PREFIXES.contains(vendorPrefix);\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxControlLightControllerV2.getMaxMoodId",
	"Comment": "get maximum value a mood id can have for the current list of moods.",
	"Method": "Integer getMaxMoodId(){\r\n    return maxMoodId;\r\n}"
}, {
	"Path": "org.openhab.binding.solaredge.internal.model.AggregateDataResponsePublicApi.assignValue",
	"Comment": "converts the meter value to quantitytype. if multiple meter value are provided a sum will be calculated. if nounit can be determined undeftype.undef will be used",
	"Method": "void assignValue(Map<Channel, State> targetMap,Channel channel,MeterTelemetry values){\r\n    double sum = 0.0;\r\n    State result = UnDefType.UNDEF;\r\n    for (MeterTelemetry value : values) {\r\n        if (value.value != null) {\r\n            sum += value.value;\r\n        }\r\n    }\r\n    if (energyDetails != null && energyDetails.unit != null) {\r\n        Unit<Energy> unit = determineEnergyUnit(energyDetails.unit);\r\n        if (unit != null) {\r\n            result = new QuantityType<Energy>(sum, unit);\r\n        } else {\r\n            logger.debug(\"Channel {}: Could not determine unit: '{}'\", channel.getFQName(), energyDetails.unit);\r\n        }\r\n    } else {\r\n        logger.debug(\"Channel {}: Value has no unit.\", channel.getFQName());\r\n    }\r\n    targetMap.put(channel, result);\r\n}"
}, {
	"Path": "org.openhab.binding.atlona.internal.pro3.AtlonaPro3PortocolHandler.handleVolumeResponse",
	"Comment": "handles the volume response. the first two group should be the audio port number and the level",
	"Method": "void handleVolumeResponse(Matcher m,String resp){\r\n    if (m == null) {\r\n        throw new IllegalArgumentException(\"m (matcher) cannot be null\");\r\n    }\r\n    if (m.groupCount() == 2) {\r\n        try {\r\n            int portNbr = Integer.parseInt(m.group(1));\r\n            double level = Double.parseDouble(m.group(2));\r\n            callback.stateChanged(AtlonaPro3Utilities.createChannelID(AtlonaPro3Constants.GROUP_VOLUME, portNbr, AtlonaPro3Constants.CHANNEL_VOLUME), new DecimalType(level));\r\n        } catch (NumberFormatException e) {\r\n            logger.warn(\"Invalid volume response (can't parse number): '{}'\", resp);\r\n        }\r\n    } else {\r\n        logger.warn(\"Invalid volume response: '{}'\", resp);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.smartmeter.internal.sml.SmlMeterReader.populateValueCache",
	"Comment": "decodes native sml informations from the device and stores them locally until the next read request.",
	"Method": "void populateValueCache(SmlFile smlFile){\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Read out following SML file: {}\", System.lineSeparator());\r\n        SmlFileDebugOutput.printFile(smlFile, (msg) -> logger.trace(msg));\r\n    }\r\n    List<SmlMessage> smlMessages = smlFile.getMessages();\r\n    if (smlMessages != null) {\r\n        int messageCount = smlMessages.size();\r\n        if (messageCount <= 0) {\r\n            logger.warn(\"{}: no valid SML messages list retrieved.\", this.toString());\r\n        }\r\n        for (int i = 0; i < messageCount; i++) {\r\n            SmlMessage smlMessage = smlMessages.get(i);\r\n            int tag = smlMessage.getMessageBody().getTag().id();\r\n            if (tag != EMessageBody.GET_LIST_RESPONSE.id()) {\r\n                continue;\r\n            }\r\n            SmlGetListRes listResponse = (SmlGetListRes) smlMessage.getMessageBody().getChoice();\r\n            SmlList smlValueList = listResponse.getValList();\r\n            SmlListEntry[] smlListEntries = smlValueList.getValListEntry();\r\n            for (SmlListEntry entry : smlListEntries) {\r\n                SmlValueExtractor valueExtractor = new SmlValueExtractor(entry);\r\n                String obis = valueExtractor.getObisCode();\r\n                MeterValue<?> smlValue = getMeterValue(obis);\r\n                if (smlValue == null) {\r\n                    smlValue = valueExtractor.getSmlValue();\r\n                }\r\n                SmlStatus status = entry.getStatus();\r\n                if (status != null) {\r\n                    String statusValue = readStatus(status, obis);\r\n                    if (statusValue != null) {\r\n                        smlValue.setStatus(statusValue);\r\n                    }\r\n                }\r\n                addObisCache(smlValue);\r\n            }\r\n        }\r\n    } else {\r\n        logger.warn(\"{}: no valid SML messages list retrieved.\", this.toString());\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.util.CheckClassAdapter.checkFormalTypeParameter",
	"Comment": "checks a formal type parameter of a class or method signature.",
	"Method": "int checkFormalTypeParameter(String signature,int pos){\r\n    pos = checkIdentifier(signature, pos);\r\n    pos = checkChar(':', signature, pos);\r\n    if (\"L[T\".indexOf(getChar(signature, pos)) != -1) {\r\n        pos = checkFieldTypeSignature(signature, pos);\r\n    }\r\n    while (getChar(signature, pos) == ':') {\r\n        pos = checkFieldTypeSignature(signature, pos + 1);\r\n    }\r\n    return pos;\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.device.p1telegram.CRC16.calculate",
	"Comment": "calculate a crc16 based on the specified data and the initial crcvalue",
	"Method": "int calculate(byte[] data,int initialCrcValue){\r\n    int crc = initialCrcValue;\r\n    for (int p = 0; p < data.length; p++) {\r\n        crc = (crc >> 8) ^ (crcTable[(crc & 0xFF) ^ (data[p] & 0xFF)] & 0xFFFF);\r\n    }\r\n    return crc;\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.utils.NetworkUtils.nativePing",
	"Comment": "use the native ping utility of the operating system to detect device presence.",
	"Method": "boolean nativePing(IpPingMethodEnum method,String hostname,int timeoutInMS){\r\n    Process proc;\r\n    switch(method) {\r\n        case IPUTILS_LINUX_PING:\r\n            proc = new ProcessBuilder(\"ping\", \"-w\", String.valueOf(timeoutInMS / 1000), \"-c\", \"1\", hostname).start();\r\n            break;\r\n        case MAC_OS_PING:\r\n            proc = new ProcessBuilder(\"ping\", \"-t\", String.valueOf(timeoutInMS / 1000), \"-c\", \"1\", hostname).start();\r\n            break;\r\n        case WINDOWS_PING:\r\n            proc = new ProcessBuilder(\"ping\", \"-w\", String.valueOf(timeoutInMS), \"-n\", \"1\", hostname).start();\r\n            break;\r\n        case JAVA_PING:\r\n        default:\r\n            return false;\r\n    }\r\n    if (method != IpPingMethodEnum.WINDOWS_PING) {\r\n        return proc.waitFor() == 0;\r\n    }\r\n    int result = proc.waitFor();\r\n    if (result != 0) {\r\n        return false;\r\n    }\r\n    try (BufferedReader r = new BufferedReader(new InputStreamReader(proc.getInputStream()))) {\r\n        String line = r.readLine();\r\n        if (line == null) {\r\n            throw new IOException(\"Received no output from ping process.\");\r\n        }\r\n        do {\r\n            if (line.contains(\"host unreachable\") || line.contains(\"timed out\") || line.contains(\"could not find host\")) {\r\n                return false;\r\n            }\r\n            line = r.readLine();\r\n        } while (line != null);\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.mitre.jose.keystore.JWKSetKeyStore.getKeys",
	"Comment": "get the list of keys in this keystore. this is a passthrough to the underlying jwk set",
	"Method": "List<JWK> getKeys(){\r\n    if (jwkSet == null) {\r\n        initializeJwkSet();\r\n    }\r\n    return jwkSet.getKeys();\r\n}"
}, {
	"Path": "nginx.clojure.asm.MethodVisitor.visitEnd",
	"Comment": "visits the end of the method. this method, which is the last one to becalled, is used to inform the visitor that all the annotations andattributes of the method have been visited.",
	"Method": "void visitEnd(){\r\n    if (mv != null) {\r\n        mv.visitEnd();\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.max.internal.handler.MaxCubeBridgeHandler.getCommand",
	"Comment": "processes device command and sends it to the max! cube lan gateway.",
	"Method": "CubeCommand getCommand(SendCommand sendCommand){\r\n    String serialNumber = sendCommand.getDeviceSerial();\r\n    ChannelUID channelUID = sendCommand.getChannelUID();\r\n    Command command = sendCommand.getCommand();\r\n    HeatingThermostat device = (HeatingThermostat) getDevice(serialNumber, devices);\r\n    if (device == null) {\r\n        logger.debug(\"Cannot send command to device with serial number '{}', device not listed.\", serialNumber);\r\n        return null;\r\n    }\r\n    if (channelUID.getId().equals(CHANNEL_SETTEMP)) {\r\n        if (command instanceof QuantityType || command instanceof OnOffType) {\r\n            double setTemp = DEFAULT_OFF_TEMPERATURE;\r\n            if (command instanceof QuantityType) {\r\n                setTemp = ((QuantityType<Temperature>) command).toUnit(CELSIUS).toBigDecimal().setScale(1, RoundingMode.HALF_UP).doubleValue();\r\n            } else if (command instanceof OnOffType) {\r\n                setTemp = OnOffType.ON.equals(command) ? DEFAULT_ON_TEMPERATURE : DEFAULT_OFF_TEMPERATURE;\r\n            }\r\n            return new SCommand(device.getRFAddress(), device.getRoomId(), device.getMode(), setTemp);\r\n        }\r\n    } else if (channelUID.getId().equals(CHANNEL_MODE)) {\r\n        if (command instanceof StringType) {\r\n            String commandContent = command.toString().trim().toUpperCase();\r\n            double setTemp = device.getTemperatureSetpoint();\r\n            if (commandContent.contentEquals(ThermostatModeType.AUTOMATIC.toString())) {\r\n                return new SCommand(device.getRFAddress(), device.getRoomId(), ThermostatModeType.AUTOMATIC, 0D);\r\n            } else if (commandContent.contentEquals(ThermostatModeType.BOOST.toString())) {\r\n                return new SCommand(device.getRFAddress(), device.getRoomId(), ThermostatModeType.BOOST, setTemp);\r\n            } else if (commandContent.contentEquals(ThermostatModeType.MANUAL.toString())) {\r\n                logger.debug(\"updates to MANUAL mode with temperature '{}'\", setTemp);\r\n                return new SCommand(device.getRFAddress(), device.getRoomId(), ThermostatModeType.MANUAL, setTemp);\r\n            } else {\r\n                logger.debug(\"Only updates to AUTOMATIC & BOOST & MANUAL supported, received value: '{}'\", commandContent);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.TestDefaultOAuth2ClientDetailsEntityService.saveNewClient_noOfflineAccess",
	"Comment": "makes sure client does not have offline access if not allowed to have refresh tokens.",
	"Method": "void saveNewClient_noOfflineAccess(){\r\n    ClientDetailsEntity client = new ClientDetailsEntity();\r\n    client = service.saveNewClient(client);\r\n    Mockito.verify(scopeService, Mockito.atLeastOnce()).removeReservedScopes(Matchers.anySet());\r\n    assertThat(client.getScope().contains(SystemScopeService.OFFLINE_ACCESS), is(equalTo(false)));\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassWriter.newInteger",
	"Comment": "adds an integer to the constant pool of the class being build. doesnothing if the constant pool already contains a similar item.",
	"Method": "Item newInteger(int value){\r\n    key.set(value);\r\n    Item result = get(key);\r\n    if (result == null) {\r\n        pool.putByte(INT).putInt(value);\r\n        result = new Item(index++, key);\r\n        put(result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.openhab.binding.silvercrestwifisocket.internal.handler.SilvercrestWifiSocketHandler.lookupForSocketHostAddress",
	"Comment": "lookup for socket host address, by sending one broadcast discovery message. eventually the socket will respond tothe message. when the mediator receives the message, it will set the host address in this handler, for futurecommunications.",
	"Method": "void lookupForSocketHostAddress(){\r\n    SilvercrestWifiSocketRequest requestPacket = new SilvercrestWifiSocketRequest(this.macAddress, SilvercrestWifiSocketRequestType.DISCOVERY, this.vendor);\r\n    for (InetAddress broadcastAddressFound : NetworkUtils.getAllBroadcastAddresses()) {\r\n        logger.debug(\"Will query for device with mac address {} in network with broadcast address {}\", this.macAddress, broadcastAddressFound);\r\n        this.sendRequestPacket(requestPacket, broadcastAddressFound);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.max.internal.handler.MaxDevicesHandler.setForceRefresh",
	"Comment": "set the forcerefresh flag to ensure update when next data is coming",
	"Method": "void setForceRefresh(){\r\n    forceRefresh = true;\r\n}"
}, {
	"Path": "org.openhab.ui.cometvisu.internal.servlet.CometVisuServlet.copy",
	"Comment": "copy the given byte range of the given input to the given output.",
	"Method": "void copy(RandomAccessFile input,OutputStream output,long start,long length){\r\n    byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];\r\n    int read;\r\n    if (input.length() == length) {\r\n        while ((read = input.read(buffer)) > 0) {\r\n            output.write(buffer, 0, read);\r\n        }\r\n    } else {\r\n        input.seek(start);\r\n        long toRead = length;\r\n        while ((read = input.read(buffer)) > 0) {\r\n            if ((toRead -= read) > 0) {\r\n                output.write(buffer, 0, read);\r\n            } else {\r\n                output.write(buffer, 0, (int) toRead + read);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.nibeuplink.internal.AtomicReferenceTrait.updateJobReference",
	"Comment": "updates a job reference with a new job. the old job will be cancelled if there is one.",
	"Method": "void updateJobReference(AtomicReference<@Nullable Future<?>> jobReference,Future<?> newJob){\r\n    cancelJob(jobReference.getAndSet(newJob));\r\n}"
}, {
	"Path": "org.openhab.binding.denonmarantz.internal.connector.telnet.DenonMarantzTelnetConnector.connect",
	"Comment": "set up the connection to the receiver. either using telnet or by polling the http api.",
	"Method": "void connect(){\r\n    telnetClient = new DenonMarantzTelnetClient(config, this);\r\n    telnetRunnable = scheduler.submit(telnetClient);\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.JSRInlinerAdapter.visitEnd",
	"Comment": "if any jsrs were seen, triggers the inlining process. otherwise, forwardsthe byte codes untouched.",
	"Method": "void visitEnd(){\r\n    if (!subroutineHeads.isEmpty()) {\r\n        markSubroutines();\r\n        if (LOGGING) {\r\n            log(mainSubroutine.toString());\r\n            Iterator<BitSet> it = subroutineHeads.values().iterator();\r\n            while (it.hasNext()) {\r\n                BitSet sub = it.next();\r\n                log(sub.toString());\r\n            }\r\n        }\r\n        emitCode();\r\n    }\r\n    if (mv != null) {\r\n        accept(mv);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxServer.addOrUpdateRoom",
	"Comment": "add a room to the server, if a room with same uuid already does not exist, otherwise update it with new name.",
	"Method": "LxContainer addOrUpdateRoom(LxUuid id,String name){\r\n    if (rooms == null) {\r\n        return null;\r\n    }\r\n    LxContainer r = findRoom(id);\r\n    if (r != null) {\r\n        r.setName(name);\r\n        return r;\r\n    }\r\n    LxContainer nr = new LxContainer(id, name);\r\n    rooms.put(id, nr);\r\n    return nr;\r\n}"
}, {
	"Path": "org.openhab.binding.powermax.internal.message.PowermaxCommManager.requestEventLog",
	"Comment": "send a message to the powermax alarm panel to get all the event logs",
	"Method": "boolean requestEventLog(String pinCode){\r\n    logger.debug(\"requestEventLog()\");\r\n    boolean done = false;\r\n    if ((pinCode == null) || (pinCode.length() != 4)) {\r\n        logger.debug(\"Powermax alarm binding: requested event log rejected due to invalid PIN code\");\r\n    } else {\r\n        try {\r\n            byte[] dynPart = new byte[3];\r\n            dynPart[0] = (byte) Integer.parseInt(pinCode.substring(0, 2), 16);\r\n            dynPart[1] = (byte) Integer.parseInt(pinCode.substring(2, 4), 16);\r\n            done = sendMessage(new PowermaxBaseMessage(PowermaxSendType.EVENTLOG, dynPart), false, 0);\r\n        } catch (NumberFormatException e) {\r\n            logger.debug(\"Powermax alarm binding: requested event log rejected due to invalid PIN code\");\r\n        }\r\n    }\r\n    return done;\r\n}"
}, {
	"Path": "org.openhab.binding.milight.internal.protocol.MilightV6SessionManager.close",
	"Comment": "you have to call that if you are done with this object. cleans up the receive thread.",
	"Method": "void close(){\r\n    if (willbeclosed) {\r\n        return;\r\n    }\r\n    willbeclosed = true;\r\n    final DatagramSocket socket = datagramSocket;\r\n    if (socket != null) {\r\n        socket.close();\r\n    }\r\n    sessionThread.interrupt();\r\n    try {\r\n        sessionThread.join();\r\n    } catch (InterruptedException e) {\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.protocol.NhcThermostat.startOverrule",
	"Comment": "start a new overrule, this method is used to be able to calculate the remaining overrule time",
	"Method": "void startOverrule(){\r\n    this.overruleStart = LocalDateTime.now();\r\n}"
}, {
	"Path": "org.openhab.binding.plugwise.internal.PlugwiseMessageProcessor.parseAndQueue",
	"Comment": "parse a buffer into a message and put it in the appropriate queue for further processing",
	"Method": "void parseAndQueue(ByteBuffer readBuffer){\r\n    String response = new String(readBuffer.array(), 0, readBuffer.limit());\r\n    response = StringUtils.chomp(response);\r\n    Matcher matcher = RESPONSE_PATTERN.matcher(response);\r\n    if (matcher.matches()) {\r\n        String protocolHeader = matcher.group(1);\r\n        String messageTypeHex = matcher.group(2);\r\n        String sequence = matcher.group(3);\r\n        String payload = matcher.group(4);\r\n        String crc = matcher.group(5);\r\n        if (protocolHeader.equals(PROTOCOL_HEADER)) {\r\n            String calculatedCRC = Message.getCRC(messageTypeHex + sequence + payload);\r\n            if (calculatedCRC.equals(crc)) {\r\n                MessageType messageType = MessageType.forValue(Integer.parseInt(messageTypeHex, 16));\r\n                int sequenceNumber = Integer.parseInt(sequence, 16);\r\n                if (messageType == null) {\r\n                    logger.debug(\"Received unrecognized message: messageTypeHex=0x{}, sequence={}, payload={}\", messageTypeHex, sequenceNumber, payload);\r\n                    return;\r\n                }\r\n                logger.debug(\"Received message: messageType={}, sequenceNumber={}, payload={}\", messageType, sequenceNumber, payload);\r\n                try {\r\n                    Message message = messageFactory.createMessage(messageType, sequenceNumber, payload);\r\n                    if (message instanceof AcknowledgementMessage && !((AcknowledgementMessage) message).isExtended()) {\r\n                        logger.debug(\"Adding to acknowledgedQueue: {}\", message);\r\n                        context.getAcknowledgedQueue().put((AcknowledgementMessage) message);\r\n                    } else {\r\n                        logger.debug(\"Adding to receivedQueue: {}\", message);\r\n                        context.getReceivedQueue().put(message);\r\n                    }\r\n                } catch (IllegalArgumentException e) {\r\n                    logger.warn(\"Failed to create message\", e);\r\n                } catch (InterruptedException e) {\r\n                    Thread.interrupted();\r\n                }\r\n            } else {\r\n                logger.warn(\"Plugwise protocol CRC error: {} does not match {} in message\", calculatedCRC, crc);\r\n            }\r\n        } else {\r\n            logger.debug(\"Plugwise protocol header error: {} in message {}\", protocolHeader, response);\r\n        }\r\n    } else if (!response.contains(\"APSRequestNodeInfo\") && !response.contains(\"APSSetSleepBehaviour\") && !response.startsWith(\"# \")) {\r\n        logger.warn(\"Plugwise protocol message error: {}\", response);\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.Method.getArgumentTypes",
	"Comment": "returns the argument types of the method described by this object.",
	"Method": "Type[] getArgumentTypes(){\r\n    return Type.getArgumentTypes(desc);\r\n}"
}, {
	"Path": "org.openhab.binding.milight.internal.handler.AbstractLedHandler.configUpdated",
	"Comment": "called by the bridge if a configuration update happened after initialisation has been done",
	"Method": "void configUpdated(AbstractBridgeHandler h,InetAddress address){\r\n    this.port = h.port;\r\n    this.address = address;\r\n    this.socket = h.socket;\r\n    this.delayTimeMS = h.config.delayTime;\r\n    this.repeatTimes = h.config.repeat;\r\n}"
}, {
	"Path": "nginx.clojure.asm.Frame.merge",
	"Comment": "merges the type at the given index in the given type array with the giventype. returns true if the type array has been modified by thisoperation.",
	"Method": "boolean merge(ClassWriter cw,Frame frame,int edge,boolean merge,ClassWriter cw,int t,int[] types,int index){\r\n    int u = types[index];\r\n    if (u == t) {\r\n        return false;\r\n    }\r\n    if ((t & ~DIM) == NULL) {\r\n        if (u == NULL) {\r\n            return false;\r\n        }\r\n        t = NULL;\r\n    }\r\n    if (u == 0) {\r\n        types[index] = t;\r\n        return true;\r\n    }\r\n    int v;\r\n    if ((u & BASE_KIND) == OBJECT || (u & DIM) != 0) {\r\n        if (t == NULL) {\r\n            return false;\r\n        } else if ((t & (DIM | BASE_KIND)) == (u & (DIM | BASE_KIND))) {\r\n            if ((u & BASE_KIND) == OBJECT) {\r\n                v = (t & DIM) | OBJECT | cw.getMergedType(t & BASE_VALUE, u & BASE_VALUE);\r\n            } else {\r\n                v = OBJECT | cw.addType(\"java/lang/Object\");\r\n            }\r\n        } else if ((t & BASE_KIND) == OBJECT || (t & DIM) != 0) {\r\n            v = OBJECT | cw.addType(\"java/lang/Object\");\r\n        } else {\r\n            v = TOP;\r\n        }\r\n    } else if (u == NULL) {\r\n        v = (t & BASE_KIND) == OBJECT || (t & DIM) != 0 ? t : TOP;\r\n    } else {\r\n        v = TOP;\r\n    }\r\n    if (u != v) {\r\n        types[index] = v;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.openhab.binding.satel.internal.protocol.SatelModule.sendCommand",
	"Comment": "enqueues specified command in send queue if not already enqueued.",
	"Method": "boolean sendCommand(SatelCommand cmd,boolean sendCommand,SatelCommand cmd,boolean force){\r\n    try {\r\n        if (force || !this.sendQueue.contains(cmd)) {\r\n            this.sendQueue.put(cmd);\r\n            cmd.setState(State.ENQUEUED);\r\n            logger.trace(\"Command enqueued: {}\", cmd);\r\n        } else {\r\n            logger.debug(\"Command already in the queue: {}\", cmd);\r\n        }\r\n        return true;\r\n    } catch (InterruptedException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.checkCast",
	"Comment": "generates the instruction to check that the top stack value is of thegiven type.",
	"Method": "void checkCast(Type type){\r\n    if (!type.equals(OBJECT_TYPE)) {\r\n        typeInsn(Opcodes.CHECKCAST, type);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.neeo.internal.NeeoDeviceProtocol.setMacroStatus",
	"Comment": "sets the macro status. if the status is true, the macro will be triggered. if false, nothing occurs",
	"Method": "void setMacroStatus(String macroKey,boolean start){\r\n    NeeoUtil.requireNotEmpty(macroKey, \"macroKey cannot be empty\");\r\n    final NeeoBrainApi api = callback.getApi();\r\n    if (api == null) {\r\n        logger.debug(\"API is null [likely bridge is offline]\");\r\n    } else {\r\n        try {\r\n            if (start) {\r\n                api.triggerMacro(roomKey, deviceKey, macroKey);\r\n                callback.scheduleTask(() -> {\r\n                    callback.stateChanged(UidUtils.createChannelId(NeeoConstants.DEVICE_GROUP_MACROS_ID, NeeoConstants.DEVICE_CHANNEL_STATUS, macroKey), OnOffType.OFF);\r\n                }, 500);\r\n            }\r\n        } catch (IOException e) {\r\n            logger.warn(\"Exception occurred during execution of a macro (may need to update the brain firmware): {}\", e.getMessage(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.silvercrestwifisocket.internal.discovery.SilvercrestWifiSocketDiscoveryService.discoveredWifiSocket",
	"Comment": "method called by mediator, when receive one packet from one unknown wifi socket.",
	"Method": "void discoveredWifiSocket(String macAddress,String hostAddress){\r\n    Map<String, Object> properties = new HashMap(2);\r\n    properties.put(SilvercrestWifiSocketBindingConstants.MAC_ADDRESS_ARG, macAddress);\r\n    properties.put(SilvercrestWifiSocketBindingConstants.HOST_ADDRESS_ARG, hostAddress);\r\n    ThingUID newThingId = new ThingUID(SilvercrestWifiSocketBindingConstants.THING_TYPE_WIFI_SOCKET, macAddress);\r\n    DiscoveryResult discoveryResult = DiscoveryResultBuilder.create(newThingId).withProperties(properties).withLabel(\"Silvercrest Wifi Socket\").withRepresentationProperty(macAddress).build();\r\n    logger.debug(\"Discovered new thing with mac address '{}' and host address '{}'\", macAddress, hostAddress);\r\n    this.thingDiscovered(discoveryResult);\r\n}"
}, {
	"Path": "org.openhab.binding.solaredge.internal.AtomicReferenceTrait.cancelJob",
	"Comment": "this should usually not called directly. use updatejobreference or canceljobreference instead",
	"Method": "void cancelJob(Future<?> job){\r\n    if (job != null) {\r\n        job.cancel(true);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.handler.NikoHomeControlActionHandler.scheduleRollershutterStop",
	"Comment": "method used to schedule a rollershutter stop when moving. this allows stopping the rollershutter at a percentposition.",
	"Method": "void scheduleRollershutterStop(NhcAction nhcAction,int currentValue,int newValue){\r\n    this.filterEvent = true;\r\n    long duration = rollershutterMoveTime(nhcAction, currentValue, newValue);\r\n    setRollershutterMovingTrue(nhcAction, duration);\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"scheduleRollershutterStop: schedule rollershutter {} stop in {}ms\", this.getConfig().get(CONFIG_ACTION_ID), duration);\r\n    }\r\n    this.rollershutterStopTask = scheduler.schedule(() -> {\r\n        logger.trace(\"scheduleRollershutterStop: run rollershutter {} stop\", this.getConfig().get(CONFIG_ACTION_ID));\r\n        nhcAction.execute(NHCSTOP);\r\n    }, duration, TimeUnit.MILLISECONDS);\r\n}"
}, {
	"Path": "org.openhab.binding.lutron.internal.grxprg.GrafikEyeHandler.stateChanged",
	"Comment": "helper method to expose the ability to change state outside of the class",
	"Method": "void stateChanged(String channelId,State state){\r\n    updateState(channelId, state);\r\n}"
}, {
	"Path": "org.openhab.binding.max.internal.Utils.toHex",
	"Comment": "returns the hexadecimal number of a number of integer values.",
	"Method": "String toHex(int values,String toHex,boolean[] bits){\r\n    int retVal = 0;\r\n    for (int i = 0; i < bits.length; ++i) {\r\n        retVal |= (bits[i] ? 1 : 0) << i;\r\n    }\r\n    return toHex(retVal);\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.handler.YamahaZoneThingHandler.isCorrectlyInitialized",
	"Comment": "return true if the zone is set, and zonecontrol and zoneavailableinputs objects have been created.",
	"Method": "boolean isCorrectlyInitialized(){\r\n    return zoneConfig != null && zoneConfig.getZone() != null && zoneAvailableInputs != null && zoneControl != null;\r\n}"
}, {
	"Path": "org.openhab.binding.silvercrestwifisocket.internal.handler.SilvercrestWifiSocketHandler.initGetStatusAndKeepAliveThread",
	"Comment": "starts one thread that querys the state of the socket, after the defined refresh interval.",
	"Method": "void initGetStatusAndKeepAliveThread(){\r\n    if (this.keepAliveJob != null) {\r\n        this.keepAliveJob.cancel(true);\r\n    }\r\n    Runnable runnable = () -> {\r\n        logger.debug(\"Begin of Socket keep alive thread routine. Current configuration update interval: {} seconds.\", SilvercrestWifiSocketHandler.this.updateInterval);\r\n        long now = System.currentTimeMillis();\r\n        long timePassedFromLastUpdateInSeconds = (now - SilvercrestWifiSocketHandler.this.latestUpdate) / 1000;\r\n        logger.trace(\"Latest Update: {} Now: {} Delta: {} seconds\", SilvercrestWifiSocketHandler.this.latestUpdate, now, timePassedFromLastUpdateInSeconds);\r\n        logger.debug(\"It has been passed {} seconds since the last update on socket with mac address {}.\", timePassedFromLastUpdateInSeconds, SilvercrestWifiSocketHandler.this.macAddress);\r\n        boolean mustUpdateHostAddress = timePassedFromLastUpdateInSeconds > (SilvercrestWifiSocketHandler.this.updateInterval * 2);\r\n        if (mustUpdateHostAddress) {\r\n            logger.debug(\"No updates have been received for a long time, search the mac address {} in network...\", SilvercrestWifiSocketHandler.this.getMacAddress());\r\n            SilvercrestWifiSocketHandler.this.lookupForSocketHostAddress();\r\n        }\r\n        boolean considerThingOffline = (SilvercrestWifiSocketHandler.this.latestUpdate < 0) || (timePassedFromLastUpdateInSeconds > (SilvercrestWifiSocketHandler.this.updateInterval * 4));\r\n        if (considerThingOffline) {\r\n            logger.debug(\"No updates have been received for a long long time will put the thing with mac address {} OFFLINE.\", SilvercrestWifiSocketHandler.this.getMacAddress());\r\n            SilvercrestWifiSocketHandler.this.updateStatus(ThingStatus.OFFLINE);\r\n        }\r\n        SilvercrestWifiSocketHandler.this.sendCommand(SilvercrestWifiSocketRequestType.GPIO_STATUS);\r\n    };\r\n    this.keepAliveJob = this.scheduler.scheduleWithFixedDelay(runnable, 1, SilvercrestWifiSocketHandler.this.updateInterval, TimeUnit.SECONDS);\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.box",
	"Comment": "generates the instructions to box the top stack value. this value isreplaced by its boxed equivalent on top of the stack.",
	"Method": "void box(Type type){\r\n    if (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) {\r\n        return;\r\n    }\r\n    if (type == Type.VOID_TYPE) {\r\n        push((String) null);\r\n    } else {\r\n        Type boxed = getBoxedType(type);\r\n        newInstance(boxed);\r\n        if (type.getSize() == 2) {\r\n            dupX2();\r\n            dupX2();\r\n            pop();\r\n        } else {\r\n            dupX1();\r\n            swap();\r\n        }\r\n        invokeConstructor(boxed, new Method(\"<init>\", Type.VOID_TYPE, new Type[] { type }));\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.discovery.DSMRBridgeDiscoveryService.handleTelegramReceived",
	"Comment": "handle if telegrams are received.if there are cosem objects received a new bridge will we discovered",
	"Method": "void handleTelegramReceived(P1Telegram telegram){\r\n    List<CosemObject> cosemObjects = telegram.getCosemObjects();\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"[{}] Received {} cosemObjects\", currentScannedPortName, cosemObjects.size());\r\n    }\r\n    if (!cosemObjects.isEmpty()) {\r\n        bridgeDiscovered(telegram);\r\n        stopSerialPortScan();\r\n    }\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Octet.fromArray",
	"Comment": "create tuple from array. array has to have exactly eight elements.",
	"Method": "Octet<X, X, X, X, X, X, X, X> fromArray(X[] array){\r\n    if (array == null) {\r\n        throw new IllegalArgumentException(\"Array cannot be null\");\r\n    }\r\n    if (array.length != 8) {\r\n        throw new IllegalArgumentException(\"Array must have exactly 8 elements in order to create an Octet. Size is \" + array.length);\r\n    }\r\n    return new Octet<X, X, X, X, X, X, X, X>(array[0], array[1], array[2], array[3], array[4], array[5], array[6], array[7]);\r\n}"
}, {
	"Path": "com.mycollab.vaadin.web.ui.chart.JFreeChartWrapper.getGraphHeight",
	"Comment": "gets the pixel height into which the graph is rendered. unless explicitlyset, the value is derived from the components size, except when thecomponent has relative size.",
	"Method": "int getGraphHeight(){\r\n    if (graphHeightInPixels > 0) {\r\n        return graphHeightInPixels;\r\n    }\r\n    int height;\r\n    float w = getHeight();\r\n    if (w < 0) {\r\n        return DEFAULT_HEIGHT;\r\n    }\r\n    switch(getWidthUnits()) {\r\n        case CM:\r\n            height = (int) (w * 96 / 2.54);\r\n            break;\r\n        case INCH:\r\n            height = (int) (w * 96);\r\n            break;\r\n        case PERCENTAGE:\r\n            height = DEFAULT_HEIGHT;\r\n            break;\r\n        default:\r\n            height = (int) w;\r\n            break;\r\n    }\r\n    return height;\r\n}"
}, {
	"Path": "nginx.clojure.asm.signature.SignatureReader.parseType",
	"Comment": "parses a field type signature and makes the given visitor visit it.",
	"Method": "int parseType(String signature,int pos,SignatureVisitor v){\r\n    char c;\r\n    int start, end;\r\n    boolean visited, inner;\r\n    String name;\r\n    switch(c = signature.charAt(pos++)) {\r\n        case 'Z':\r\n        case 'C':\r\n        case 'B':\r\n        case 'S':\r\n        case 'I':\r\n        case 'F':\r\n        case 'J':\r\n        case 'D':\r\n        case 'V':\r\n            v.visitBaseType(c);\r\n            return pos;\r\n        case '[':\r\n            return parseType(signature, pos, v.visitArrayType());\r\n        case 'T':\r\n            end = signature.indexOf(';', pos);\r\n            v.visitTypeVariable(signature.substring(pos, end));\r\n            return end + 1;\r\n        default:\r\n            start = pos;\r\n            visited = false;\r\n            inner = false;\r\n            for (; ; ) {\r\n                switch(c = signature.charAt(pos++)) {\r\n                    case '.':\r\n                    case ';':\r\n                        if (!visited) {\r\n                            name = signature.substring(start, pos - 1);\r\n                            if (inner) {\r\n                                v.visitInnerClassType(name);\r\n                            } else {\r\n                                v.visitClassType(name);\r\n                            }\r\n                        }\r\n                        if (c == ';') {\r\n                            v.visitEnd();\r\n                            return pos;\r\n                        }\r\n                        start = pos;\r\n                        visited = false;\r\n                        inner = true;\r\n                        break;\r\n                    case '<':\r\n                        name = signature.substring(start, pos - 1);\r\n                        if (inner) {\r\n                            v.visitInnerClassType(name);\r\n                        } else {\r\n                            v.visitClassType(name);\r\n                        }\r\n                        visited = true;\r\n                        top: for (; ; ) {\r\n                            switch(c = signature.charAt(pos)) {\r\n                                case '>':\r\n                                    break top;\r\n                                case '*':\r\n                                    ++pos;\r\n                                    v.visitTypeArgument();\r\n                                    break;\r\n                                case '+':\r\n                                case '-':\r\n                                    pos = parseType(signature, pos + 1, v.visitTypeArgument(c));\r\n                                    break;\r\n                                default:\r\n                                    pos = parseType(signature, pos, v.visitTypeArgument('='));\r\n                                    break;\r\n                            }\r\n                        }\r\n                }\r\n            }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.internal.ModbusLibraryWrapper.createRequest",
	"Comment": "convert the general request to modbus library request object",
	"Method": "ModbusRequest createRequest(ModbusWriteRequestBlueprint message,ModbusRequest createRequest,ModbusReadRequestBlueprint message){\r\n    ModbusRequest request;\r\n    if (message.getFunctionCode() == ModbusReadFunctionCode.READ_COILS) {\r\n        request = new ReadCoilsRequest(message.getReference(), message.getDataLength());\r\n    } else if (message.getFunctionCode() == ModbusReadFunctionCode.READ_INPUT_DISCRETES) {\r\n        request = new ReadInputDiscretesRequest(message.getReference(), message.getDataLength());\r\n    } else if (message.getFunctionCode() == ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS) {\r\n        request = new ReadMultipleRegistersRequest(message.getReference(), message.getDataLength());\r\n    } else if (message.getFunctionCode() == ModbusReadFunctionCode.READ_INPUT_REGISTERS) {\r\n        request = new ReadInputRegistersRequest(message.getReference(), message.getDataLength());\r\n    } else {\r\n        throw new IllegalArgumentException(String.format(\"Unexpected function code %s\", message.getFunctionCode()));\r\n    }\r\n    request.setUnitID(message.getUnitID());\r\n    request.setProtocolID(message.getProtocolID());\r\n    return request;\r\n}"
}, {
	"Path": "geometry.geom2d.Line2D.getBoundedRepresentation",
	"Comment": "returns a finite representation in space\tused only for intersections",
	"Method": "Line2D getBoundedRepresentation(){\r\n    Point2D bound0 = p0.getTranslation(getAngle(), -1000000);\r\n    Point2D bound1 = p1.getTranslation(getAngle(), 1000000);\r\n    return new Line2D(bound0, bound1);\r\n}"
}, {
	"Path": "org.openhab.binding.powermax.internal.message.PowermaxBaseMessage.handleMessage",
	"Comment": "work to be done when receiving a message from the visonic alarm system",
	"Method": "PowermaxState handleMessage(PowermaxCommManager commManager){\r\n    if (isAckRequired() && commManager != null) {\r\n        commManager.sendAck(this, (byte) 0x02);\r\n    }\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"{}message handled by class {}: {}\", (receiveType == null) ? \"Unsupported \" : \"\", this.getClass().getSimpleName(), this);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openhab.binding.smartmeter.internal.MeterDevice.clearValueCache",
	"Comment": "deletes all cached values.the method will always be called before new values are populated.",
	"Method": "void clearValueCache(){\r\n    valueCache.clear();\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.ifCmp",
	"Comment": "generates the instructions to jump to a label based on the comparison ofthe top two stack values.",
	"Method": "void ifCmp(Type type,int mode,Label label){\r\n    switch(type.getSort()) {\r\n        case Type.LONG:\r\n            mv.visitInsn(Opcodes.LCMP);\r\n            break;\r\n        case Type.DOUBLE:\r\n            mv.visitInsn(mode == GE || mode == GT ? Opcodes.DCMPL : Opcodes.DCMPG);\r\n            break;\r\n        case Type.FLOAT:\r\n            mv.visitInsn(mode == GE || mode == GT ? Opcodes.FCMPL : Opcodes.FCMPG);\r\n            break;\r\n        case Type.ARRAY:\r\n        case Type.OBJECT:\r\n            switch(mode) {\r\n                case EQ:\r\n                    mv.visitJumpInsn(Opcodes.IF_ACMPEQ, label);\r\n                    return;\r\n                case NE:\r\n                    mv.visitJumpInsn(Opcodes.IF_ACMPNE, label);\r\n                    return;\r\n            }\r\n            throw new IllegalArgumentException(\"Bad comparison for type \" + type);\r\n        default:\r\n            int intOp = -1;\r\n            switch(mode) {\r\n                case EQ:\r\n                    intOp = Opcodes.IF_ICMPEQ;\r\n                    break;\r\n                case NE:\r\n                    intOp = Opcodes.IF_ICMPNE;\r\n                    break;\r\n                case GE:\r\n                    intOp = Opcodes.IF_ICMPGE;\r\n                    break;\r\n                case LT:\r\n                    intOp = Opcodes.IF_ICMPLT;\r\n                    break;\r\n                case LE:\r\n                    intOp = Opcodes.IF_ICMPLE;\r\n                    break;\r\n                case GT:\r\n                    intOp = Opcodes.IF_ICMPGT;\r\n                    break;\r\n            }\r\n            mv.visitJumpInsn(intOp, label);\r\n            return;\r\n    }\r\n    mv.visitJumpInsn(mode, label);\r\n}"
}, {
	"Path": "nginx.clojure.asm.ByteVector.putInt",
	"Comment": "puts an int into this byte vector. the byte vector is automaticallyenlarged if necessary.",
	"Method": "ByteVector putInt(int i){\r\n    int length = this.length;\r\n    if (length + 4 > data.length) {\r\n        enlarge(4);\r\n    }\r\n    byte[] data = this.data;\r\n    data[length++] = (byte) (i >>> 24);\r\n    data[length++] = (byte) (i >>> 16);\r\n    data[length++] = (byte) (i >>> 8);\r\n    data[length++] = (byte) i;\r\n    this.length = length;\r\n    return this;\r\n}"
}, {
	"Path": "nginx.clojure.asm.MethodVisitor.visitFieldInsn",
	"Comment": "visits a field instruction. a field instruction is an instruction thatloads or stores the value of a field of an object.",
	"Method": "void visitFieldInsn(int opcode,String owner,String name,String desc){\r\n    if (mv != null) {\r\n        mv.visitFieldInsn(opcode, owner, name, desc);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.atlona.internal.pro3.AtlonaPro3PortocolHandler.handleMatrixResetResponse",
	"Comment": "handles the matrix reset response. the matrix will go offline immediately on a reset.",
	"Method": "void handleMatrixResetResponse(String resp){\r\n    if (RSP_MATRIX_RESET.equals(resp)) {\r\n        callback.statusChanged(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"System is rebooting due to matrix reset\");\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.util.CheckMethodAdapter.checkOpcode",
	"Comment": "checks that the type of the given opcode is equal to the given type.",
	"Method": "void checkOpcode(int opcode,int type){\r\n    if (opcode < 0 || opcode > 199 || TYPE[opcode] != type) {\r\n        throw new IllegalArgumentException(\"Invalid opcode: \" + opcode);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.synopanalyzer.internal.handler.SynopAnalyzerHandler.getWindStrength",
	"Comment": "returns the wind strength depending upon the unit of the message.",
	"Method": "QuantityType<Speed> getWindStrength(Synop synop){\r\n    return new QuantityType(synop.getWindSpeed(), MPS.equalsIgnoreCase(synop.getWindUnit()) ? WIND_SPEED_UNIT_MS : WIND_SPEED_UNIT_KNOT);\r\n}"
}, {
	"Path": "org.openhab.binding.squeezebox.internal.handler.SqueezeBoxNotificationListener.absoluteVolumeChangeEvent",
	"Comment": "monitor for when the volume is updated to a specific target value",
	"Method": "void absoluteVolumeChangeEvent(String mac,int volume){\r\n    if (!this.playerMAC.equals(mac)) {\r\n        return;\r\n    }\r\n    this.volume.set(volume);\r\n    logger.trace(\"Volume is {} for player {}\", volume, mac);\r\n}"
}, {
	"Path": "org.openhab.binding.silvercrestwifisocket.internal.handler.SilvercrestWifiSocketMediatorImpl.getHandlerRegistredByMac",
	"Comment": "utilitary method to get the registered thing handler in mediator by the mac address.",
	"Method": "SilvercrestWifiSocketHandler getHandlerRegistredByMac(String macAddress){\r\n    SilvercrestWifiSocketHandler searchedHandler = null;\r\n    for (SilvercrestWifiSocketHandler handler : this.handlersRegistredByThing.values()) {\r\n        if (macAddress.equals(handler.getMacAddress())) {\r\n            searchedHandler = handler;\r\n            break;\r\n        }\r\n    }\r\n    return searchedHandler;\r\n}"
}, {
	"Path": "org.openhab.binding.tplinksmarthome.internal.Commands.getRealtimeBulbAndSysinfo",
	"Comment": "returns the json to get the energy and sys info data from the bulb.",
	"Method": "String getRealtimeBulbAndSysinfo(){\r\n    return GET_REALTIME_BULB_AND_SYSINFO;\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.zone.RioZoneProtocol.systemFavoritesUpdated",
	"Comment": "callback method when system favorites are updated. simply issues a state change for the zone system favoriteschannel using the jsonstring as the value",
	"Method": "void systemFavoritesUpdated(String jsonString){\r\n    stateChanged(RioConstants.CHANNEL_ZONESYSFAVORITES, new StringType(jsonString));\r\n}"
}, {
	"Path": "org.openhab.binding.nest.internal.handler.NestBridgeHandler.addUpdateRequest",
	"Comment": "adds the update request into the queue for doing something with, send immediately if the queue is empty.",
	"Method": "void addUpdateRequest(NestUpdateRequest request){\r\n    nestUpdateRequests.add(request);\r\n    scheduleTransmitJobForPendingRequests();\r\n}"
}, {
	"Path": "org.openhab.ui.cometvisu.internal.util.SseUtil.enableBlockingSse",
	"Comment": "marks the current thread as processing a blocking sse request.",
	"Method": "void enableBlockingSse(){\r\n    blockingSseEnabled.set(true);\r\n}"
}, {
	"Path": "org.openmuc.jrxtx.SerialPortBuilder.setBaudRate",
	"Comment": "set the baud rate for the serial port. values such as 9600 or 115200.",
	"Method": "SerialPortBuilder setBaudRate(int baudRate){\r\n    this.baudRate = baudRate;\r\n    return this;\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.RioSystemFavoritesProtocol.getJson",
	"Comment": "returns the json representation of all the system favorites and their state.",
	"Method": "String getJson(){\r\n    final List<RioFavorite> favs = new ArrayList();\r\n    for (final RioFavorite fav : systemFavorites) {\r\n        if (fav.isValid()) {\r\n            favs.add(fav);\r\n        }\r\n    }\r\n    return gson.toJson(favs);\r\n}"
}, {
	"Path": "org.openhab.binding.samsungtv.internal.handler.SamsungTvHandler.checkAndCreateServices",
	"Comment": "one samsung tv contains several upnp devices. samsung tv is discovered bymedia renderer upnp device. this polling job tries to find another upnpdevices related to same samsung tv and create handler for those.",
	"Method": "void checkAndCreateServices(){\r\n    logger.debug(\"Check and create missing UPnP services\");\r\n    for (Device device : upnpService.getRegistry().getDevices()) {\r\n        createService((RemoteDevice) device);\r\n    }\r\n    if (upnpService != null) {\r\n        upnpService.getRegistry().addListener(this);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.pioneeravr.internal.handler.AbstractAvrHandler.onPowerOff",
	"Comment": "called when a power off state update is received from the avr.",
	"Method": "void onPowerOff(int zone){\r\n    updateState(getChannelUID(PioneerAvrBindingConstants.MUTE_CHANNEL, zone), UnDefType.UNDEF);\r\n    updateState(getChannelUID(PioneerAvrBindingConstants.VOLUME_DB_CHANNEL, zone), UnDefType.UNDEF);\r\n    updateState(getChannelUID(PioneerAvrBindingConstants.VOLUME_DIMMER_CHANNEL, zone), UnDefType.UNDEF);\r\n    updateState(getChannelUID(PioneerAvrBindingConstants.SET_INPUT_SOURCE_CHANNEL, zone), UnDefType.UNDEF);\r\n}"
}, {
	"Path": "org.openhab.binding.avmfritz.internal.hardware.callbacks.FritzAhaReauthCallback.isFinalAttempt",
	"Comment": "returns whether there will be another retry on an invalid response",
	"Method": "boolean isFinalAttempt(){\r\n    return retries <= 0;\r\n}"
}, {
	"Path": "org.openhab.binding.cm11a.internal.X10Interface.validateAddress",
	"Comment": "validates that the given string is a valid x10 address. returns true if this is the case.",
	"Method": "boolean validateAddress(String address){\r\n    return (!(address.length() < 2 || address.length() > 3 || !HOUSE_CODES.containsKey(new Character(address.charAt(0))) || !DEVICE_CODES.containsKey(Integer.parseInt(address.substring(1)))));\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassReader.readParameterAnnotations",
	"Comment": "reads parameter annotations and makes the given visitor visit them.",
	"Method": "void readParameterAnnotations(int v,String desc,char[] buf,boolean visible,MethodVisitor mv){\r\n    int i;\r\n    int n = b[v++] & 0xFF;\r\n    int synthetics = Type.getArgumentTypes(desc).length - n;\r\n    AnnotationVisitor av;\r\n    for (i = 0; i < synthetics; ++i) {\r\n        av = mv.visitParameterAnnotation(i, \"Ljava/lang/Synthetic;\", false);\r\n        if (av != null) {\r\n            av.visitEnd();\r\n        }\r\n    }\r\n    for (; i < n + synthetics; ++i) {\r\n        int j = readUnsignedShort(v);\r\n        v += 2;\r\n        for (; j > 0; --j) {\r\n            av = mv.visitParameterAnnotation(i, readUTF8(v, buf), visible);\r\n            v = readAnnotationValues(v + 2, buf, true, av);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.Method.getDescriptor",
	"Comment": "returns the descriptor of the method described by this object.",
	"Method": "String getDescriptor(){\r\n    return desc;\r\n}"
}, {
	"Path": "model.battlefield.map.cliff.Ramp.getSlopeRate",
	"Comment": "get the slope rate at the given tile coords. at the top of the ramp, slope is 0, and 1 at the bottom.",
	"Method": "double getSlopeRate(Tile t){\r\n    Point2D p = t.getCoord();\r\n    if (t.ramp != this) {\r\n        return 0;\r\n    }\r\n    if (angle == 0) {\r\n        if (p.x > maxX) {\r\n            return 1;\r\n        } else if (p.x < minX) {\r\n            return 0;\r\n        } else {\r\n            return (double) (p.x - minX) / (maxX - minX + 1);\r\n        }\r\n    } else if (angle == AngleUtil.FLAT) {\r\n        if (p.x > maxX) {\r\n            return 0;\r\n        } else if (p.x < minX) {\r\n            return 1;\r\n        } else {\r\n            return (double) (maxX - p.x + 1) / (maxX - minX + 1);\r\n        }\r\n    } else if (angle == AngleUtil.RIGHT) {\r\n        if (p.y > maxY) {\r\n            return 1;\r\n        } else if (p.y < minY) {\r\n            return 0;\r\n        } else {\r\n            return (double) (p.y - minY) / (maxY - minY + 1);\r\n        }\r\n    } else if (angle == -AngleUtil.RIGHT) {\r\n        if (p.y > maxY) {\r\n            return 0;\r\n        } else if (p.y < minY) {\r\n            return 1;\r\n        } else {\r\n            return (double) (maxY - p.y + 1) / (maxY - minY + 1);\r\n        }\r\n    }\r\n    throw new RuntimeException();\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Triplet.fromArray",
	"Comment": "create tuple from array. array has to have exactly three elements.",
	"Method": "Triplet<X, X, X> fromArray(X[] array){\r\n    if (array == null) {\r\n        throw new IllegalArgumentException(\"Array cannot be null\");\r\n    }\r\n    if (array.length != 3) {\r\n        throw new IllegalArgumentException(\"Array must have exactly 3 elements in order to create a Triplet. Size is \" + array.length);\r\n    }\r\n    return new Triplet<X, X, X>(array[0], array[1], array[2]);\r\n}"
}, {
	"Path": "org.openhab.binding.tplinksmarthome.internal.CryptUtil.decryptWithLength",
	"Comment": "decrypt the byte data in the input stream. in the first 4 bytes the length of the data in the byte array iscoded.",
	"Method": "String decryptWithLength(InputStream inputStream){\r\n    try (DataInputStream is = new DataInputStream(inputStream)) {\r\n        return decrypt(is, is.readInt());\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.Label.put",
	"Comment": "puts a reference to this label in the bytecode of a method. if theposition of the label is known, the offset is computed and writtendirectly. otherwise, a null offset is written and a new forward referenceis declared for this label.",
	"Method": "void put(MethodWriter owner,ByteVector out,int source,boolean wideOffset){\r\n    if ((status & RESOLVED) == 0) {\r\n        if (wideOffset) {\r\n            addReference(-1 - source, out.length);\r\n            out.putInt(-1);\r\n        } else {\r\n            addReference(source, out.length);\r\n            out.putShort(-1);\r\n        }\r\n    } else {\r\n        if (wideOffset) {\r\n            out.putInt(position - source);\r\n        } else {\r\n            out.putShort(position - source);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.feican.internal.Commands.brightness",
	"Comment": "returns the command to set the brightness on a bulb running in color, color temperature or program.",
	"Method": "byte[] brightness(PercentType percentage){\r\n    byte[] command = BRIGHTNESS_COMMAND.clone();\r\n    command[3] = percentage.byteValue();\r\n    return command;\r\n}"
}, {
	"Path": "org.openhab.binding.solaredge.internal.model.AggregateDataResponsePublicApi.assignPercentage",
	"Comment": "calculates percentage and assigns it to the corresponding channel and puts it into the targetmap",
	"Method": "void assignPercentage(Map<Channel, State> targetMap,Channel channel,State dividendAsState,State divisorAsState){\r\n    double percent = -1;\r\n    State result = UnDefType.UNDEF;\r\n    if (dividendAsState != null && divisorAsState != null) {\r\n        DecimalType dividendAsDecimalType = dividendAsState.as(DecimalType.class);\r\n        DecimalType divisorAsDecimalType = divisorAsState.as(DecimalType.class);\r\n        if (dividendAsDecimalType != null && divisorAsDecimalType != null) {\r\n            double dividend = dividendAsDecimalType.doubleValue();\r\n            double divisor = divisorAsDecimalType.doubleValue();\r\n            if (dividend >= 0.0 && divisor > 0.0) {\r\n                percent = dividend / divisor * 100;\r\n            }\r\n        }\r\n    }\r\n    if (percent >= 0.0) {\r\n        result = new QuantityType<Dimensionless>(percent, SmartHomeUnits.PERCENT);\r\n    } else {\r\n        logger.debug(\"Channel {}: Could not calculate percent.\", channel.getFQName());\r\n    }\r\n    targetMap.put(channel, result);\r\n}"
}, {
	"Path": "nginx.clojure.asm.tree.analysis.Analyzer.getFrames",
	"Comment": "returns the symbolic stack frame for each instruction of the lastrecently analyzed method.",
	"Method": "Frame<V>[] getFrames(){\r\n    return frames;\r\n}"
}, {
	"Path": "org.openhab.binding.globalcache.internal.command.AbstractCommand.sendCommand",
	"Comment": "place a request message onto the request queue, then wait on the response queue for theresponse message. the commandhandler private class in globalcachehandler.javais responsible for the actual device interaction.",
	"Method": "boolean sendCommand(){\r\n    LinkedBlockingQueue<ResponseMessage> responseQueue = new LinkedBlockingQueue<ResponseMessage>(RESPONSE_QUEUE_MAX_DEPTH);\r\n    RequestMessage requestMsg = new RequestMessage(commandName, commandType, deviceCommand, responseQueue);\r\n    try {\r\n        requestQueue.put(requestMsg);\r\n        logger.trace(\"Put request on queue (depth={}), sent command '{}'\", requestQueue.size(), deviceCommand);\r\n        ResponseMessage responseMsg = responseQueue.poll(RESPONSE_QUEUE_TIMEOUT, TimeUnit.MILLISECONDS);\r\n        if (responseMsg == null) {\r\n            createGenericError(\"Timed out waiting on response queue for message\");\r\n            return false;\r\n        }\r\n        deviceReply = responseMsg.getDeviceReply();\r\n        logger.trace(\"Got response message off response queue, received reply '{}'\", deviceReply);\r\n        if (isErrorReply(deviceReply)) {\r\n            return false;\r\n        }\r\n    } catch (InterruptedException e) {\r\n        createGenericError(\"Poll of response queue was interrupted\");\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.MITREidDataService_1_3.readSystemScopes",
	"Comment": "read the list of system scopes from the reader and insert them into the\tscope repository.",
	"Method": "void readSystemScopes(JsonReader reader){\r\n    reader.beginArray();\r\n    while (reader.hasNext()) {\r\n        SystemScope scope = new SystemScope();\r\n        reader.beginObject();\r\n        while (reader.hasNext()) {\r\n            switch(reader.peek()) {\r\n                case END_OBJECT:\r\n                    continue;\r\n                case NAME:\r\n                    String name = reader.nextName();\r\n                    if (reader.peek() == JsonToken.NULL) {\r\n                        reader.skipValue();\r\n                    } else if (name.equals(VALUE)) {\r\n                        scope.setValue(reader.nextString());\r\n                    } else if (name.equals(DESCRIPTION)) {\r\n                        scope.setDescription(reader.nextString());\r\n                    } else if (name.equals(RESTRICTED)) {\r\n                        scope.setRestricted(reader.nextBoolean());\r\n                    } else if (name.equals(DEFAULT_SCOPE)) {\r\n                        scope.setDefaultScope(reader.nextBoolean());\r\n                    } else if (name.equals(ICON)) {\r\n                        scope.setIcon(reader.nextString());\r\n                    } else {\r\n                        logger.debug(\"found unexpected entry\");\r\n                        reader.skipValue();\r\n                    }\r\n                    break;\r\n                default:\r\n                    logger.debug(\"Found unexpected entry\");\r\n                    reader.skipValue();\r\n                    continue;\r\n            }\r\n        }\r\n        reader.endObject();\r\n        sysScopeRepository.save(scope);\r\n    }\r\n    reader.endArray();\r\n    logger.info(\"Done reading system scopes\");\r\n}"
}, {
	"Path": "org.openhab.binding.meteostick.internal.handler.MeteostickBridgeHandler.disconnect",
	"Comment": "disconnects from the serial interface and stops send and receive threads.",
	"Method": "void disconnect(){\r\n    if (receiveThread != null) {\r\n        receiveThread.interrupt();\r\n        try {\r\n            receiveThread.join();\r\n        } catch (InterruptedException e) {\r\n        }\r\n        receiveThread = null;\r\n    }\r\n    if (this.serialPort != null) {\r\n        this.serialPort.close();\r\n        this.serialPort = null;\r\n    }\r\n    logger.info(\"Disconnected from serial port\");\r\n}"
}, {
	"Path": "org.openhab.binding.milight.internal.protocol.MilightV6SessionManager.getNextSequenceNo",
	"Comment": "for non confirmed sequence numbers older that 2 seconds and report them.",
	"Method": "int getNextSequenceNo(){\r\n    int currentSequenceNo = this.sequenceNo;\r\n    usedSequenceNo.put(currentSequenceNo, Instant.now());\r\n    ++sequenceNo;\r\n    return currentSequenceNo;\r\n}"
}, {
	"Path": "org.mitre.data.AbstractPageOperationTemplateTest.execute_nonzerotime",
	"Comment": "this is a valid test however it is vulnerable to a race condition\tas such it is being ignored.",
	"Method": "void execute_nonzerotime(){\r\n    Long timeMillis = 200L;\r\n    CountingPageOperation op = new CountingPageOperation(Integer.MAX_VALUE, timeMillis);\r\n    op.execute();\r\n    assertFalse(\"last fetch time \" + op.getTimeToLastFetch() + \"\" + \" and previous fetch time  \" + op.getTimeToPreviousFetch() + \" exceed max time\" + timeMillis, op.getTimeToLastFetch() > timeMillis && op.getTimeToPreviousFetch() > timeMillis);\r\n}"
}, {
	"Path": "org.openhab.binding.satel.internal.command.ReadDeviceInfoCommand.getName",
	"Comment": "returns name of the device decoded using given encoding. encodingdepends on firmware language and must be specified in the bindingconfiguration.",
	"Method": "String getName(String encoding){\r\n    return new String(response.getPayload(), 3, 16, encoding).trim();\r\n}"
}, {
	"Path": "org.openhab.binding.tplinksmarthome.internal.PropertiesCollectorTest.testRangeExtenderProperties",
	"Comment": "tests if properties for a range extender device are correctly parsed.",
	"Method": "void testRangeExtenderProperties(){\r\n    assertProperties(\"rangeextender_get_sysinfo_response\", TPLinkSmartHomeThingType.RE270K, 11);\r\n}"
}, {
	"Path": "org.mitre.openid.connect.token.TofuUserApprovalHandler.setAuthTime",
	"Comment": "get the auth time out of the current session and add it to the\tauth request in the extensions map.",
	"Method": "void setAuthTime(AuthorizationRequest authorizationRequest){\r\n    ServletRequestAttributes attr = (ServletRequestAttributes) RequestContextHolder.currentRequestAttributes();\r\n    if (attr != null) {\r\n        HttpSession session = attr.getRequest().getSession();\r\n        if (session != null) {\r\n            Date authTime = (Date) session.getAttribute(AuthenticationTimeStamper.AUTH_TIMESTAMP);\r\n            if (authTime != null) {\r\n                String authTimeString = Long.toString(authTime.getTime());\r\n                authorizationRequest.getExtensions().put(AuthenticationTimeStamper.AUTH_TIMESTAMP, authTimeString);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.ModbusRegister.appendHexString",
	"Comment": "appends the register value as hex string to the given stringbuffer",
	"Method": "StringBuffer appendHexString(StringBuffer buffer){\r\n    byte[] bytes = getBytes();\r\n    for (int i = 0; i < 2; i++) {\r\n        byte b = bytes[i];\r\n        String byteHex = Long.toHexString(b & 0xff);\r\n        if ((b & 0xff) < 0x10) {\r\n            buffer.append('0');\r\n        }\r\n        buffer.append(byteHex);\r\n        if (i == 0) {\r\n            buffer.append(' ');\r\n        }\r\n    }\r\n    return buffer;\r\n}"
}, {
	"Path": "nginx.clojure.asm.Type.getElementType",
	"Comment": "returns the type of the elements of this array type. this method shouldonly be used for an array type.",
	"Method": "Type getElementType(){\r\n    return getType(buf, off + getDimensions());\r\n}"
}, {
	"Path": "org.openhab.binding.squeezebox.internal.handler.SqueezeBoxServerHandler.removePlayerCache",
	"Comment": "removed a player from our known list of players, will populate again ifplayer is seen",
	"Method": "void removePlayerCache(String mac){\r\n    players.remove(mac);\r\n}"
}, {
	"Path": "org.openhab.binding.atlona.internal.pro3.AtlonaPro3PortocolHandler.handleUnMirrorResponse",
	"Comment": "handles the unmirror response. the first group should contain the hdmi port number",
	"Method": "void handleUnMirrorResponse(Matcher m,String resp){\r\n    if (m == null) {\r\n        throw new IllegalArgumentException(\"m (matcher) cannot be null\");\r\n    }\r\n    if (m.groupCount() == 1) {\r\n        try {\r\n            int hdmiPortNbr = Integer.parseInt(m.group(1));\r\n            callback.stateChanged(AtlonaPro3Utilities.createChannelID(AtlonaPro3Constants.GROUP_MIRROR, hdmiPortNbr, AtlonaPro3Constants.CHANNEL_PORTMIRROR), new DecimalType(0));\r\n        } catch (NumberFormatException e) {\r\n            logger.warn(\"Invalid unmirror response (can't parse number): '{}'\", resp);\r\n        }\r\n    } else {\r\n        logger.warn(\"Invalid unmirror response: '{}'\", resp);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxControlMood.getId",
	"Comment": "get an id of this mood. id indentifies the mood within a light controller.it is equal to the mood id received from the miniserver.",
	"Method": "Integer getId(){\r\n    return moodId;\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2ClientDetailsEntityService.ensureRefreshTokenConsistency",
	"Comment": "make sure the client has the appropriate scope and grant type.",
	"Method": "void ensureRefreshTokenConsistency(ClientDetailsEntity client){\r\n    if (client.getAuthorizedGrantTypes().contains(\"refresh_token\") || client.getScope().contains(SystemScopeService.OFFLINE_ACCESS)) {\r\n        client.getScope().add(SystemScopeService.OFFLINE_ACCESS);\r\n        client.getAuthorizedGrantTypes().add(\"refresh_token\");\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.TestDefaultUserInfoService.prepare",
	"Comment": "initialize the service and the mocked repository.\tinitialize 2 users, one of them an admin, for use in unit tests.",
	"Method": "void prepare(){\r\n    userInfoAdmin = new DefaultUserInfo();\r\n    userInfoAdmin.setPreferredUsername(adminUsername);\r\n    userInfoAdmin.setSub(adminSub);\r\n    userInfoRegular = new DefaultUserInfo();\r\n    userInfoRegular.setPreferredUsername(regularUsername);\r\n    userInfoRegular.setSub(regularSub);\r\n    publicClient1 = new ClientDetailsEntity();\r\n    publicClient1.setClientId(publicClientId1);\r\n    publicClient2 = new ClientDetailsEntity();\r\n    publicClient2.setClientId(publicClientId2);\r\n    publicClient2.setSubjectType(SubjectType.PUBLIC);\r\n    pairwiseClient1 = new ClientDetailsEntity();\r\n    pairwiseClient1.setClientId(pairwiseClientId1);\r\n    pairwiseClient1.setSubjectType(SubjectType.PAIRWISE);\r\n    pairwiseClient1.setSectorIdentifierUri(sectorIdentifier1);\r\n    pairwiseClient2 = new ClientDetailsEntity();\r\n    pairwiseClient2.setClientId(pairwiseClientId2);\r\n    pairwiseClient2.setSubjectType(SubjectType.PAIRWISE);\r\n    pairwiseClient2.setSectorIdentifierUri(sectorIdentifier2);\r\n    pairwiseClient3 = new ClientDetailsEntity();\r\n    pairwiseClient3.setClientId(pairwiseClientId3);\r\n    pairwiseClient3.setSubjectType(SubjectType.PAIRWISE);\r\n    pairwiseClient3.setSectorIdentifierUri(sectorIdentifier3);\r\n    pairwiseClient4 = new ClientDetailsEntity();\r\n    pairwiseClient4.setClientId(pairwiseClientId4);\r\n    pairwiseClient4.setSubjectType(SubjectType.PAIRWISE);\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.config.YamahaUtils.tryParseEnum",
	"Comment": "tries to parse a string into enum, if unsuccessful returns null.",
	"Method": "T tryParseEnum(Class<T> c,String string){\r\n    if (string != null) {\r\n        try {\r\n            return Enum.valueOf(c, string);\r\n        } catch (IllegalArgumentException ex) {\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.ifICmp",
	"Comment": "generates the instructions to jump to a label based on the comparison ofthe top two integer stack values.",
	"Method": "void ifICmp(int mode,Label label){\r\n    ifCmp(Type.INT_TYPE, mode, label);\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxWsSecurity.decryptControl",
	"Comment": "check if control is encrypted and decrypt it using current decryption algorithm.if control is not encrypted or decryption is not available or not ready, the control should be returned in itsoriginal form.",
	"Method": "String decryptControl(String control){\r\n    return control;\r\n}"
}, {
	"Path": "nginx.clojure.asm.ByteVector.put11",
	"Comment": "puts two bytes into this byte vector. the byte vector is automaticallyenlarged if necessary.",
	"Method": "ByteVector put11(int b1,int b2){\r\n    int length = this.length;\r\n    if (length + 2 > data.length) {\r\n        enlarge(2);\r\n    }\r\n    byte[] data = this.data;\r\n    data[length++] = (byte) b1;\r\n    data[length++] = (byte) b2;\r\n    this.length = length;\r\n    return this;\r\n}"
}, {
	"Path": "nginx.clojure.asm.ByteVector.put12",
	"Comment": "puts a byte and a short into this byte vector. the byte vector isautomatically enlarged if necessary.",
	"Method": "ByteVector put12(int b,int s){\r\n    int length = this.length;\r\n    if (length + 3 > data.length) {\r\n        enlarge(3);\r\n    }\r\n    byte[] data = this.data;\r\n    data[length++] = (byte) b;\r\n    data[length++] = (byte) (s >>> 8);\r\n    data[length++] = (byte) s;\r\n    this.length = length;\r\n    return this;\r\n}"
}, {
	"Path": "org.openhab.binding.nibeuplink.internal.model.AbstractChannels.getChannels",
	"Comment": "returns an unmodifiable set containing all available channels.",
	"Method": "Set<Channel> getChannels(){\r\n    return Collections.unmodifiableSet(channels);\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.test.ModbusSlaveEndpointTestCase.testEqualsSameSerial3",
	"Comment": "even though different echo parameter & baud rate, the endpoints are considered the same due to same port",
	"Method": "void testEqualsSameSerial3(){\r\n    ModbusSerialSlaveEndpoint e1 = new ModbusSerialSlaveEndpoint(\"port1\", 9600, SerialPort.FLOWCONTROL_NONE, SerialPort.FLOWCONTROL_NONE, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE, Modbus.DEFAULT_SERIAL_ENCODING, true, 500);\r\n    ModbusSerialSlaveEndpoint e2 = new ModbusSerialSlaveEndpoint(\"port1\", 9600, SerialPort.FLOWCONTROL_NONE, SerialPort.FLOWCONTROL_NONE, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE, Modbus.DEFAULT_SERIAL_ENCODING, false, 500);\r\n    Assert.assertEquals(e1, e2);\r\n    Assert.assertEquals(e1.hashCode(), e2.hashCode());\r\n}"
}, {
	"Path": "org.openhab.binding.atlona.internal.pro3.AtlonaPro3PortocolHandler.handlePanelLockResponse",
	"Comment": "handles the panel lock response. the response is only on or off.",
	"Method": "void handlePanelLockResponse(String resp){\r\n    callback.stateChanged(AtlonaPro3Utilities.createChannelID(AtlonaPro3Constants.GROUP_PRIMARY, AtlonaPro3Constants.CHANNEL_PANELLOCK), RSP_LOCK.equals(resp) ? OnOffType.ON : OnOffType.OFF);\r\n}"
}, {
	"Path": "org.openhab.binding.silvercrestwifisocket.internal.handler.SilvercrestWifiSocketHandler.sendCommand",
	"Comment": "sends one command to the wifi socket. if the host address is not set, it will trigger the lookup of thehost address and discard the command queried.",
	"Method": "void sendCommand(SilvercrestWifiSocketRequestType type){\r\n    logger.debug(\"Send command for mac addr: {} with type: {} with hostaddress: {}\", this.getMacAddress(), type.name(), this.hostAddress);\r\n    if (this.hostAddress == null) {\r\n        logger.debug(\"Send command cannot proceed until one Host Address is set for mac address: {} Will invoke one mac address lookup!\", this.macAddress);\r\n        this.lookupForSocketHostAddress();\r\n    } else {\r\n        InetAddress address;\r\n        try {\r\n            address = InetAddress.getByName(this.hostAddress);\r\n            this.sendRequestPacket(new SilvercrestWifiSocketRequest(this.macAddress, type, this.vendor), address);\r\n        } catch (UnknownHostException e) {\r\n            logger.debug(\"Host Address not found: {}. Will lookup Mac address.\");\r\n            this.hostAddress = null;\r\n            this.lookupForSocketHostAddress();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "geometry.geom3d.Triangle3D.getZProjection",
	"Comment": "elevate the given point on z axis, for it to be on the triangle plane",
	"Method": "Point3D getZProjection(Point3D p){\r\n    Point3D A = b.getSubtraction(a);\r\n    Point3D B = c.getSubtraction(a);\r\n    Point3D P = p.getSubtraction(a);\r\n    double subZ = a.z;\r\n    double a = A.x;\r\n    double d = A.y;\r\n    double g = A.z;\r\n    double b = B.x;\r\n    double e = B.y;\r\n    double h = B.z;\r\n    double c = P.x;\r\n    double f = P.y;\r\n    double z = (b * f * g + c * d * h - c * e * g - a * f * h) / (b * d - a * e);\r\n    return p.getAddition(0, 0, z + subZ);\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassReader.readAnnotationValue",
	"Comment": "reads a value of an annotation and makes the given visitor visit it.",
	"Method": "int readAnnotationValue(int v,char[] buf,String name,AnnotationVisitor av){\r\n    int i;\r\n    if (av == null) {\r\n        switch(b[v] & 0xFF) {\r\n            case 'e':\r\n                return v + 5;\r\n            case '@':\r\n                return readAnnotationValues(v + 3, buf, true, null);\r\n            case '[':\r\n                return readAnnotationValues(v + 1, buf, false, null);\r\n            default:\r\n                return v + 3;\r\n        }\r\n    }\r\n    switch(b[v++] & 0xFF) {\r\n        case 'I':\r\n        case 'J':\r\n        case 'F':\r\n        case 'D':\r\n            av.visit(name, readConst(readUnsignedShort(v), buf));\r\n            v += 2;\r\n            break;\r\n        case 'B':\r\n            av.visit(name, new Byte((byte) readInt(items[readUnsignedShort(v)])));\r\n            v += 2;\r\n            break;\r\n        case 'Z':\r\n            av.visit(name, readInt(items[readUnsignedShort(v)]) == 0 ? Boolean.FALSE : Boolean.TRUE);\r\n            v += 2;\r\n            break;\r\n        case 'S':\r\n            av.visit(name, new Short((short) readInt(items[readUnsignedShort(v)])));\r\n            v += 2;\r\n            break;\r\n        case 'C':\r\n            av.visit(name, new Character((char) readInt(items[readUnsignedShort(v)])));\r\n            v += 2;\r\n            break;\r\n        case 's':\r\n            av.visit(name, readUTF8(v, buf));\r\n            v += 2;\r\n            break;\r\n        case 'e':\r\n            av.visitEnum(name, readUTF8(v, buf), readUTF8(v + 2, buf));\r\n            v += 4;\r\n            break;\r\n        case 'c':\r\n            av.visit(name, Type.getType(readUTF8(v, buf)));\r\n            v += 2;\r\n            break;\r\n        case '@':\r\n            v = readAnnotationValues(v + 2, buf, true, av.visitAnnotation(name, readUTF8(v, buf)));\r\n            break;\r\n        case '[':\r\n            int size = readUnsignedShort(v);\r\n            v += 2;\r\n            if (size == 0) {\r\n                return readAnnotationValues(v - 2, buf, false, av.visitArray(name));\r\n            }\r\n            switch(this.b[v++] & 0xFF) {\r\n                case 'B':\r\n                    byte[] bv = new byte[size];\r\n                    for (i = 0; i < size; i++) {\r\n                        bv[i] = (byte) readInt(items[readUnsignedShort(v)]);\r\n                        v += 3;\r\n                    }\r\n                    av.visit(name, bv);\r\n                    --v;\r\n                    break;\r\n                case 'Z':\r\n                    boolean[] zv = new boolean[size];\r\n                    for (i = 0; i < size; i++) {\r\n                        zv[i] = readInt(items[readUnsignedShort(v)]) != 0;\r\n                        v += 3;\r\n                    }\r\n                    av.visit(name, zv);\r\n                    --v;\r\n                    break;\r\n                case 'S':\r\n                    short[] sv = new short[size];\r\n                    for (i = 0; i < size; i++) {\r\n                        sv[i] = (short) readInt(items[readUnsignedShort(v)]);\r\n                        v += 3;\r\n                    }\r\n                    av.visit(name, sv);\r\n                    --v;\r\n                    break;\r\n                case 'C':\r\n                    char[] cv = new char[size];\r\n                    for (i = 0; i < size; i++) {\r\n                        cv[i] = (char) readInt(items[readUnsignedShort(v)]);\r\n                        v += 3;\r\n                    }\r\n                    av.visit(name, cv);\r\n                    --v;\r\n                    break;\r\n                case 'I':\r\n                    int[] iv = new int[size];\r\n                    for (i = 0; i < size; i++) {\r\n                        iv[i] = readInt(items[readUnsignedShort(v)]);\r\n                        v += 3;\r\n                    }\r\n                    av.visit(name, iv);\r\n                    --v;\r\n                    break;\r\n                case 'J':\r\n                    long[] lv = new long[size];\r\n                    for (i = 0; i < size; i++) {\r\n                        lv[i] = readLong(items[readUnsignedShort(v)]);\r\n                        v += 3;\r\n                    }\r\n                    av.visit(name, lv);\r\n                    --v;\r\n                    break;\r\n                case 'F':\r\n                    float[] fv = new float[size];\r\n                    for (i = 0; i < size; i++) {\r\n                        fv[i] = Float.intBitsToFloat(readInt(items[readUnsignedShort(v)]));\r\n                        v += 3;\r\n                    }\r\n                    av.visit(name, fv);\r\n                    --v;\r\n                    break;\r\n                case 'D':\r\n                    double[] dv = new double[size];\r\n                    for (i = 0; i < size; i++) {\r\n                        dv[i] = Double.longBitsToDouble(readLong(items[readUnsignedShort(v)]));\r\n                        v += 3;\r\n                    }\r\n                    av.visit(name, dv);\r\n                    --v;\r\n                    break;\r\n                default:\r\n                    v = readAnnotationValues(v - 3, buf, false, av.visitArray(name));\r\n            }\r\n    }\r\n    return v;\r\n}"
}, {
	"Path": "nginx.clojure.wave.MethodDatabase.checkClass",
	"Comment": "overwrite this function if coroutines is used in a transformation chain.this method must create a new checkinstrumentationvisitor and visit thespecified class with it.",
	"Method": "void checkClass(File f,CheckInstrumentationVisitor checkClass,String className,CheckInstrumentationVisitor checkClass,ClassReader r){\r\n    try {\r\n        CheckInstrumentationVisitor civ = new CheckInstrumentationVisitor();\r\n        r.accept(civ, ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES | ClassReader.SKIP_CODE);\r\n        return civ;\r\n    } catch (UnableToInstrumentException ex) {\r\n        throw ex;\r\n    } catch (Exception ex) {\r\n        error(r.getClassName(), ex);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxControlLightController.getSceneNames",
	"Comment": "return an array with names of all scenes, where index is scene number",
	"Method": "Map<String, String> getSceneNames(){\r\n    return sceneNames;\r\n}"
}, {
	"Path": "geometry.geom2d.Segment2D.hasCommonEnd",
	"Comment": "returns true if two points occupy the same coordinate space.",
	"Method": "boolean hasCommonEnd(Line2D other){\r\n    return p0.equals(other.p0) || p0.equals(other.p1) || p1.equals(other.p0) || p1.equals(other.p1);\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Septet.fromArray",
	"Comment": "create tuple from array. array has to have exactly seven elements.",
	"Method": "Septet<X, X, X, X, X, X, X> fromArray(X[] array){\r\n    if (array == null) {\r\n        throw new IllegalArgumentException(\"Array cannot be null\");\r\n    }\r\n    if (array.length != 7) {\r\n        throw new IllegalArgumentException(\"Array must have exactly 7 elements in order to create a Septet. Size is \" + array.length);\r\n    }\r\n    return new Septet<X, X, X, X, X, X, X>(array[0], array[1], array[2], array[3], array[4], array[5], array[6]);\r\n}"
}, {
	"Path": "org.openhab.binding.freebox.internal.handler.FreeboxHandler.authorize",
	"Comment": "handles connection to the freebox, including validation of the apptokenif none is provided in configuration",
	"Method": "boolean authorize(boolean useHttps,String fqdn,String apiBaseUrl,String apiVersion){\r\n    FreeboxServerConfiguration configuration = getConfigAs(FreeboxServerConfiguration.class);\r\n    Bundle bundle = FrameworkUtil.getBundle(getClass());\r\n    fbClient = new FreeboxOsClient(bundle.getSymbolicName(), useHttps, fqdn, apiBaseUrl, apiVersion);\r\n    LoginManager loginManager = fbClient.getLoginManager();\r\n    TrackAuthorizeStatus authorizeStatus = TrackAuthorizeStatus.UNKNOWN;\r\n    try {\r\n        if (StringUtils.isEmpty(configuration.appToken)) {\r\n            // Freebox\r\n            Authorize authorize = // Freebox\r\n            loginManager.newAuthorize(bundle.getHeaders().get(\"Bundle-Name\"), String.format(\"%d.%d\", bundle.getVersion().getMajor(), bundle.getVersion().getMinor()), bundle.getHeaders().get(\"Bundle-Vendor\"));\r\n            configuration.appToken = authorize.getAppToken();\r\n            logger.info(\"####################################################################\");\r\n            logger.info(\"# Please accept activation request directly on your freebox        #\");\r\n            logger.info(\"# Once done, record Apptoken in the Freebox Item configuration     #\");\r\n            logger.info(\"# {} #\", configuration.appToken);\r\n            logger.info(\"####################################################################\");\r\n            do {\r\n                Thread.sleep(2000);\r\n                authorizeStatus = loginManager.trackAuthorize();\r\n            } while (authorizeStatus == TrackAuthorizeStatus.PENDING);\r\n        } else {\r\n            authorizeStatus = TrackAuthorizeStatus.GRANTED;\r\n        }\r\n        if (authorizeStatus != TrackAuthorizeStatus.GRANTED) {\r\n            return false;\r\n        }\r\n        logger.debug(\"Apptoken valide : [{}]\", configuration.appToken);\r\n        loginManager.setAppToken(configuration.appToken);\r\n        loginManager.openSession();\r\n        return true;\r\n    } catch (Exception e) {\r\n        logger.debug(\"Thing {}: error while opening a session\", getThing().getUID(), e);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.sleepiq.internal.handler.SleepIQCloudHandler.getBeds",
	"Comment": "get a list of all beds registered to the cloud service account.",
	"Method": "List<Bed> getBeds(){\r\n    return cloud.getBeds();\r\n}"
}, {
	"Path": "org.openhab.binding.pioneeravr.internal.handler.AbstractAvrHandler.checkStatus",
	"Comment": "check the status of the avr. return true if the avr is online, else return false.",
	"Method": "void checkStatus(){\r\n    if (!connection.sendPowerQuery(1)) {\r\n        updateStatus(ThingStatus.OFFLINE);\r\n    } else {\r\n        updateStatus(ThingStatus.ONLINE);\r\n        connection.sendPowerQuery(2);\r\n        connection.sendPowerQuery(3);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.io.neeo.internal.NeeoApi.getLog",
	"Comment": "helper method to get the log file from the brain, convert the ansi escaped result to html and return it",
	"Method": "String getLog(){\r\n    final String logUrl = NeeoConstants.PROTOCOL + (brainIpAddress.startsWith(\"/\") ? brainIpAddress.substring(1) : brainIpAddress) + \":\" + NeeoConstants.DEFAULT_BRAIN_PORT + NeeoConstants.GETLOG;\r\n    final HttpRequest rqst = request.get();\r\n    final HttpResponse res = rqst.sendGetCommand(logUrl);\r\n    if (res.getHttpCode() != HttpStatus.OK_200) {\r\n        throw res.createException();\r\n    }\r\n    final StringBuilder bld = new StringBuilder(1000);\r\n    bld.append(\"<pre><div><span>\");\r\n    final char[] resp = res.getContent().toCharArray();\r\n    for (int x = 0; x < resp.length; x++) {\r\n        final char ch = resp[x];\r\n        final char nx = x + 1 == resp.length ? '-' : resp[x + 1];\r\n        if ((ch == '\\n' || ch == '\\r')) {\r\n            if (x + 1 < resp.length) {\r\n                bld.append(\"<\/span><\/div><div><span>\");\r\n            }\r\n        } else if (ch == 27 && nx == '[') {\r\n            bld.append(\"<\/span>\");\r\n            x++;\r\n            String codes = \"\";\r\n            while (x + 1 < resp.length && resp[++x] != 'm') {\r\n                codes += resp[x];\r\n            }\r\n            String style = \"\";\r\n            for (String code : codes.split(\";\")) {\r\n                try {\r\n                    int cint = Integer.parseInt(code);\r\n                    if (cint == 0) {\r\n                        style = \"\";\r\n                    } else if (cint == 1) {\r\n                        style += \"font-weight:bold;\";\r\n                    } else if (cint == 4) {\r\n                        style += \"font-style:italic;\";\r\n                    } else if (cint >= 30 && cint <= 37) {\r\n                        style += \"color:\" + ANSICOLORS[cint - 30];\r\n                    } else if (cint >= 40 && cint <= 47) {\r\n                        style += \"background-color:\" + ANSICOLORS[cint - 40];\r\n                    }\r\n                } catch (NumberFormatException e) {\r\n                }\r\n            }\r\n            bld.append(\"<span style='\" + style + \"'>\");\r\n        } else {\r\n            bld.append(ch);\r\n        }\r\n        if (x + 1 == resp.length) {\r\n            bld.append(\"<\/span><\/div><\/pre>\");\r\n        }\r\n    }\r\n    return bld.toString();\r\n}"
}, {
	"Path": "org.openhab.binding.dlinksmarthome.internal.motionsensor.DLinkMotionSensorCommunication.login",
	"Comment": "sends the two login messages and sets the authentication header for the actionmessage.",
	"Method": "void login(SOAPMessage action,int timeout){\r\n    loginSuccess = false;\r\n    login(timeout);\r\n    setAuthenticationHeaders(action);\r\n    switch(getHNAPStatus()) {\r\n        case LOGGED_IN:\r\n            loginSuccess = true;\r\n            break;\r\n        case COMMUNICATION_ERROR:\r\n            status = DeviceStatus.COMMUNICATION_ERROR;\r\n            break;\r\n        case INVALID_PIN:\r\n            status = DeviceStatus.INVALID_PIN;\r\n            break;\r\n        case INTERNAL_ERROR:\r\n            status = DeviceStatus.INTERNAL_ERROR;\r\n            break;\r\n        case UNSUPPORTED_FIRMWARE:\r\n            status = DeviceStatus.UNSUPPORTED_FIRMWARE;\r\n            break;\r\n        case INITIALISED:\r\n        default:\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.onebusaway.internal.handler.RouteHandler.publishChannel",
	"Comment": "publishes the channel with data and possibly schedules work to update it again when the next event has passed.",
	"Method": "void publishChannel(ChannelUID channelUID,Calendar now,long lastUpdateTime,List<ArrivalAndDeparture> arrivalAndDepartures){\r\n    if (channelUID.getId().equals(CHANNEL_ID_UPDATE)) {\r\n        updateState(channelUID, new DateTimeType((new Calendar.Builder()).setInstant(lastUpdateTime).build()));\r\n        return;\r\n    }\r\n    ChannelConfig channelConfig = getThing().getChannel(channelUID.getId()).getConfiguration().as(ChannelConfig.class);\r\n    long offsetMs = TimeUnit.SECONDS.toMillis(channelConfig.getOffset());\r\n    for (int i = 0; i < arrivalAndDepartures.size(); i++) {\r\n        ArrivalAndDeparture data = arrivalAndDepartures.get(i);\r\n        Calendar time;\r\n        switch(channelUID.getId()) {\r\n            case CHANNEL_ID_ARRIVAL:\r\n                time = (new Calendar.Builder()).setInstant((data.predicted ? data.predictedArrivalTime : data.scheduledArrivalTime) - offsetMs).build();\r\n                break;\r\n            case CHANNEL_ID_DEPARTURE:\r\n                time = (new Calendar.Builder()).setInstant((data.predicted ? data.predictedDepartureTime : data.scheduledDepartureTime) - offsetMs).build();\r\n                break;\r\n            default:\r\n                logger.warn(\"No code to handle publishing to {}\", channelUID.getId());\r\n                return;\r\n        }\r\n        if (time.before(now)) {\r\n            logger.debug(\"Not notifying {} because it is in the past.\", channelUID.getId());\r\n            continue;\r\n        }\r\n        updateState(channelUID, new DateTimeType(time));\r\n        if (channelUID.getId().equals(CHANNEL_ID_ARRIVAL)) {\r\n            updatePropertiesFromArrivalAndDeparture(data);\r\n        }\r\n        List<ArrivalAndDeparture> remaining = arrivalAndDepartures.subList(i + 1, arrivalAndDepartures.size());\r\n        if (remaining.isEmpty()) {\r\n            return;\r\n        }\r\n        scheduledFutures.add(scheduler.schedule(() -> {\r\n            publishChannel(channelUID, Calendar.getInstance(), lastUpdateTime, remaining);\r\n        }, time.getTimeInMillis() - now.getTimeInMillis(), TimeUnit.MILLISECONDS));\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.internal.pooling.ModbusSlaveConnectionFactoryImpl.setEndpointPoolConfiguration",
	"Comment": "configure general connection settings with a given endpoint",
	"Method": "void setEndpointPoolConfiguration(ModbusSlaveEndpoint endpoint,EndpointPoolConfiguration config){\r\n    if (config == null) {\r\n        endpointPoolConfigs.remove(endpoint);\r\n    } else {\r\n        endpointPoolConfigs.put(endpoint, config);\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassVisitor.visitOuterClass",
	"Comment": "visits the enclosing class of the class. this method must be called onlyif the class has an enclosing class.",
	"Method": "void visitOuterClass(String owner,String name,String desc){\r\n    if (cv != null) {\r\n        cv.visitOuterClass(owner, name, desc);\r\n    }\r\n}"
}, {
	"Path": "geometry.geom2d.Polygon.getHeight",
	"Comment": "the height of a polygon is the height of the minimum bounding box aligned with its first edge.",
	"Method": "double getHeight(){\r\n    return getFirstEdgeAlignedBoundingBox().height;\r\n}"
}, {
	"Path": "nginx.clojure.asm.ByteVector.putByte",
	"Comment": "puts a byte into this byte vector. the byte vector is automaticallyenlarged if necessary.",
	"Method": "ByteVector putByte(int b){\r\n    int length = this.length;\r\n    if (length + 1 > data.length) {\r\n        enlarge(1);\r\n    }\r\n    data[length++] = (byte) b;\r\n    this.length = length;\r\n    return this;\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.discovery.DSMRMeterDiscoveryService.reportUnrecognizedCosemObjects",
	"Comment": "called when unrecognized cosem objects where found. this can be a bug or a new meter not yet supported.",
	"Method": "void reportUnrecognizedCosemObjects(Map<CosemObjectType, CosemObject> unidentifiedCosemObjects){\r\n    unidentifiedCosemObjects.forEach((k, v) -> logger.debug(\"Unrecognized cosem object '{}' found in the data: {}\", k, v));\r\n}"
}, {
	"Path": "nginx.clojure.asm.tree.InsnList.accept",
	"Comment": "makes the given visitor visit all of the instructions in this list.",
	"Method": "void accept(MethodVisitor mv){\r\n    AbstractInsnNode insn = first;\r\n    while (insn != null) {\r\n        insn.accept(mv);\r\n        insn = insn.next;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.tplinksmarthome.internal.CryptUtilTest.testCrypt",
	"Comment": "test round trip of encrypt and decrypt that should return the same value.",
	"Method": "void testCrypt(){\r\n    assertEquals(\"Crypting should result in same string\", TEST_STRING, CryptUtil.decrypt(CryptUtil.encrypt(TEST_STRING), TEST_STRING.length()));\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.TestDefaultOAuth2ProviderTokenService.createAccessToken_noRefresh",
	"Comment": "tests the creation of access tokens for clients that are not allowed to have refresh tokens.",
	"Method": "void createAccessToken_noRefresh(){\r\n    when(client.isAllowRefresh()).thenReturn(false);\r\n    OAuth2AccessTokenEntity token = service.createAccessToken(authentication);\r\n    verify(clientDetailsService).loadClientByClientId(anyString());\r\n    verify(authenticationHolderRepository).save(any(AuthenticationHolderEntity.class));\r\n    verify(tokenEnhancer).enhance(any(OAuth2AccessTokenEntity.class), Matchers.eq(authentication));\r\n    verify(tokenRepository).saveAccessToken(any(OAuth2AccessTokenEntity.class));\r\n    verify(scopeService, atLeastOnce()).removeReservedScopes(anySet());\r\n    verify(tokenRepository, Mockito.never()).saveRefreshToken(any(OAuth2RefreshTokenEntity.class));\r\n    assertThat(token.getRefreshToken(), is(nullValue()));\r\n}"
}, {
	"Path": "geometry.collections.Chain.getPrevious",
	"Comment": "sans quoi ce genre de methode renverrai une out of bound exception",
	"Method": "Object getPrevious(int index,Object getPrevious,Object o){\r\n    Object debug = get(indexOf(o));\r\n    if (debug != o)\r\n        for (int i = 0; i < size(); i++) if (get(i) == o)\r\n            return getPrevious(i);\r\n    return getPrevious(indexOf(o));\r\n}"
}, {
	"Path": "org.openhab.binding.neeo.internal.handler.NeeoBrainHandler.initialize",
	"Comment": "simply cancels any existing initialization tasks and schedules a new task",
	"Method": "void initialize(){\r\n    NeeoUtil.cancel(initializationTask.getAndSet(scheduler.submit(() -> {\r\n        initializeTask();\r\n    })));\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.controller.RioControllerProtocol.handleControllerNotification",
	"Comment": "handles any controller notifications returned by the russound system",
	"Method": "void handleControllerNotification(Matcher m,String resp){\r\n    if (m == null) {\r\n        throw new IllegalArgumentException(\"m (matcher) cannot be null\");\r\n    }\r\n    if (m.groupCount() == 3) {\r\n        try {\r\n            final int notifyController = Integer.parseInt(m.group(1));\r\n            if (notifyController != controller) {\r\n                return;\r\n            }\r\n            final String key = m.group(2).toLowerCase();\r\n            final String value = m.group(3);\r\n            switch(key) {\r\n                case CTL_TYPE:\r\n                    setProperty(RioConstants.PROPERTY_CTLTYPE, value);\r\n                    break;\r\n                case CTL_IPADDRESS:\r\n                    setProperty(RioConstants.PROPERTY_CTLIPADDRESS, value);\r\n                    break;\r\n                case CTL_MACADDRESS:\r\n                    setProperty(RioConstants.PROPERTY_CTLMACADDRESS, value);\r\n                    break;\r\n                default:\r\n                    logger.debug(\"Unknown controller notification: '{}'\", resp);\r\n                    break;\r\n            }\r\n        } catch (NumberFormatException e) {\r\n            logger.debug(\"Invalid Controller Notification (controller not a parsable integer): '{}')\", resp);\r\n        }\r\n    } else {\r\n        logger.debug(\"Invalid Controller Notification response: '{}'\", resp);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.ui.cometvisu.internal.servlet.CometVisuApp.modified",
	"Comment": "called by the scr when the configuration of a binding has been changedthrough the configadmin service.",
	"Method": "void modified(Map<String, Object> configProps){\r\n    logger.info(\"updated({})\", configProps);\r\n    if (configProps == null) {\r\n        return;\r\n    }\r\n    if (configProps.containsKey(Config.COMETVISU_WEBFOLDER_PROPERTY) || configProps.containsKey(Config.COMETVISU_WEBAPP_ALIAS_PROPERTY)) {\r\n        unregisterServlet();\r\n    }\r\n    readConfiguration(configProps);\r\n    if (configProps.containsKey(Config.COMETVISU_WEBFOLDER_PROPERTY) || configProps.containsKey(Config.COMETVISU_WEBAPP_ALIAS_PROPERTY)) {\r\n        registerServlet();\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.assertion.JWTBearerAuthenticationProvider.authenticate",
	"Comment": "try to validate the client credentials by parsing and validating the jwt.",
	"Method": "Authentication authenticate(Authentication authentication){\r\n    JWTBearerAssertionAuthenticationToken jwtAuth = (JWTBearerAssertionAuthenticationToken) authentication;\r\n    try {\r\n        ClientDetailsEntity client = clientService.loadClientByClientId(jwtAuth.getName());\r\n        JWT jwt = jwtAuth.getJwt();\r\n        JWTClaimsSet jwtClaims = jwt.getJWTClaimsSet();\r\n        if (!(jwt instanceof SignedJWT)) {\r\n            throw new AuthenticationServiceException(\"Unsupported JWT type: \" + jwt.getClass().getName());\r\n        }\r\n        SignedJWT jws = (SignedJWT) jwt;\r\n        JWSAlgorithm alg = jws.getHeader().getAlgorithm();\r\n        if (client.getTokenEndpointAuthSigningAlg() != null && !client.getTokenEndpointAuthSigningAlg().equals(alg)) {\r\n            throw new AuthenticationServiceException(\"Client's registered token endpoint signing algorithm (\" + client.getTokenEndpointAuthSigningAlg() + \") does not match token's actual algorithm (\" + alg.getName() + \")\");\r\n        }\r\n        if (client.getTokenEndpointAuthMethod() == null || client.getTokenEndpointAuthMethod().equals(AuthMethod.NONE) || client.getTokenEndpointAuthMethod().equals(AuthMethod.SECRET_BASIC) || client.getTokenEndpointAuthMethod().equals(AuthMethod.SECRET_POST)) {\r\n            throw new AuthenticationServiceException(\"Client does not support this authentication method.\");\r\n        } else if ((client.getTokenEndpointAuthMethod().equals(AuthMethod.PRIVATE_KEY) && (alg.equals(JWSAlgorithm.RS256) || alg.equals(JWSAlgorithm.RS384) || alg.equals(JWSAlgorithm.RS512) || alg.equals(JWSAlgorithm.ES256) || alg.equals(JWSAlgorithm.ES384) || alg.equals(JWSAlgorithm.ES512) || alg.equals(JWSAlgorithm.PS256) || alg.equals(JWSAlgorithm.PS384) || alg.equals(JWSAlgorithm.PS512))) || (client.getTokenEndpointAuthMethod().equals(AuthMethod.SECRET_JWT) && (alg.equals(JWSAlgorithm.HS256) || alg.equals(JWSAlgorithm.HS384) || alg.equals(JWSAlgorithm.HS512)))) {\r\n            if (config.isHeartMode() && !client.getTokenEndpointAuthMethod().equals(AuthMethod.PRIVATE_KEY)) {\r\n                throw new AuthenticationServiceException(\"[HEART mode] Invalid authentication method\");\r\n            }\r\n            JWTSigningAndValidationService validator = validators.getValidator(client, alg);\r\n            if (validator == null) {\r\n                throw new AuthenticationServiceException(\"Unable to create signature validator for client \" + client + \" and algorithm \" + alg);\r\n            }\r\n            if (!validator.validateSignature(jws)) {\r\n                throw new AuthenticationServiceException(\"Signature did not validate for presented JWT authentication.\");\r\n            }\r\n        } else {\r\n            throw new AuthenticationServiceException(\"Unable to create signature validator for method \" + client.getTokenEndpointAuthMethod() + \" and algorithm \" + alg);\r\n        }\r\n        if (jwtClaims.getIssuer() == null) {\r\n            throw new AuthenticationServiceException(\"Assertion Token Issuer is null\");\r\n        } else if (!jwtClaims.getIssuer().equals(client.getClientId())) {\r\n            throw new AuthenticationServiceException(\"Issuers do not match, expected \" + client.getClientId() + \" got \" + jwtClaims.getIssuer());\r\n        }\r\n        if (jwtClaims.getExpirationTime() == null) {\r\n            throw new AuthenticationServiceException(\"Assertion Token does not have required expiration claim\");\r\n        } else {\r\n            Date now = new Date(System.currentTimeMillis() - (timeSkewAllowance * 1000));\r\n            if (now.after(jwtClaims.getExpirationTime())) {\r\n                throw new AuthenticationServiceException(\"Assertion Token is expired: \" + jwtClaims.getExpirationTime());\r\n            }\r\n        }\r\n        if (jwtClaims.getNotBeforeTime() != null) {\r\n            Date now = new Date(System.currentTimeMillis() + (timeSkewAllowance * 1000));\r\n            if (now.before(jwtClaims.getNotBeforeTime())) {\r\n                throw new AuthenticationServiceException(\"Assertion Token not valid untill: \" + jwtClaims.getNotBeforeTime());\r\n            }\r\n        }\r\n        if (jwtClaims.getIssueTime() != null) {\r\n            Date now = new Date(System.currentTimeMillis() + (timeSkewAllowance * 1000));\r\n            if (now.before(jwtClaims.getIssueTime())) {\r\n                throw new AuthenticationServiceException(\"Assertion Token was issued in the future: \" + jwtClaims.getIssueTime());\r\n            }\r\n        }\r\n        if (jwtClaims.getAudience() == null) {\r\n            throw new AuthenticationServiceException(\"Assertion token audience is null\");\r\n        } else if (!(jwtClaims.getAudience().contains(config.getIssuer()) || jwtClaims.getAudience().contains(config.getIssuer() + \"token\"))) {\r\n            throw new AuthenticationServiceException(\"Audience does not match, expected \" + config.getIssuer() + \" or \" + (config.getIssuer() + \"token\") + \" got \" + jwtClaims.getAudience());\r\n        }\r\n        Set<GrantedAuthority> authorities = new HashSet(client.getAuthorities());\r\n        authorities.add(ROLE_CLIENT);\r\n        return new JWTBearerAssertionAuthenticationToken(jwt, authorities);\r\n    } catch (InvalidClientException e) {\r\n        throw new UsernameNotFoundException(\"Could not find client: \" + jwtAuth.getName());\r\n    } catch (ParseException e) {\r\n        logger.error(\"Failure during authentication, error was: \", e);\r\n        throw new AuthenticationServiceException(\"Invalid JWT format\");\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.MethodVisitor.visitVarInsn",
	"Comment": "visits a local variable instruction. a local variable instruction is aninstruction that loads or stores the value of a local variable.",
	"Method": "void visitVarInsn(int opcode,int var){\r\n    if (mv != null) {\r\n        mv.visitVarInsn(opcode, var);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.silvercrestwifisocket.internal.handler.SilvercrestWifiSocketMediatorImpl.initMediatorWifiSocketUpdateReceiverRunnable",
	"Comment": "inits the mediator wifisocketupdatereceiverrunnable thread. this thread is responsible to receive allpackets from wifi socket devices, and redirect the messages to mediator.",
	"Method": "void initMediatorWifiSocketUpdateReceiverRunnable(){\r\n    if ((this.receiver == null) || ((this.receiverThread != null) && (this.receiverThread.isInterrupted() || !this.receiverThread.isAlive()))) {\r\n        try {\r\n            this.receiver = new SilvercrestWifiSocketUpdateReceiverRunnable(this, SilvercrestWifiSocketBindingConstants.WIFI_SOCKET_DEFAULT_UDP_PORT);\r\n            this.receiverThread = new Thread(this.receiver);\r\n            this.receiverThread.start();\r\n            logger.debug(\"Invoked the start of receiver thread.\");\r\n        } catch (SocketException e) {\r\n            logger.debug(\"Cannot start the socket with default port...\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.denonmarantz.internal.connector.http.DenonMarantzHttpConnector.connect",
	"Comment": "set up the connection to the receiver by starting to poll the http api.",
	"Method": "void connect(){\r\n    refreshState();\r\n    startPolling();\r\n}"
}, {
	"Path": "org.openhab.io.neeo.internal.servletservices.BrainDashboardService.handleGet",
	"Comment": "handles the get by looking at all brain servlets and getting the status of each",
	"Method": "void handleGet(HttpServletRequest req,String[] paths,HttpServletResponse resp){\r\n    Objects.requireNonNull(req, \"req cannot be null\");\r\n    Objects.requireNonNull(paths, \"paths cannot be null\");\r\n    Objects.requireNonNull(resp, \"resp cannot be null\");\r\n    try {\r\n        if (StringUtils.equalsIgnoreCase(paths[0], \"brainstatus\")) {\r\n            final List<BrainStatus> status = new ArrayList();\r\n            for (NeeoBrainServlet servlet : service.getServlets()) {\r\n                status.add(servlet.getBrainStatus());\r\n            }\r\n            NeeoUtil.write(resp, gson.toJson(status));\r\n        } else if (StringUtils.equalsIgnoreCase(paths[0], \"blinkled\")) {\r\n            final String brainId = req.getParameter(\"brainid\");\r\n            final NeeoBrainServlet servlet = service.getServlet(brainId);\r\n            if (servlet == null) {\r\n                NeeoUtil.write(resp, gson.toJson(new ReturnStatus(\"Unknown BraidID: \" + brainId)));\r\n            } else {\r\n                try {\r\n                    servlet.getBrainApi().blinkLed();\r\n                    NeeoUtil.write(resp, gson.toJson(new ReturnStatus(true)));\r\n                } catch (IOException e) {\r\n                    NeeoUtil.write(resp, gson.toJson(new ReturnStatus(\"Exception occurred blinking LED: \" + e.getMessage())));\r\n                }\r\n            }\r\n        } else if (StringUtils.equalsIgnoreCase(paths[0], \"getlog\")) {\r\n            final String brainId = req.getParameter(\"brainid\");\r\n            final NeeoBrainServlet servlet = service.getServlet(brainId);\r\n            if (servlet == null) {\r\n                NeeoUtil.write(resp, gson.toJson(new ReturnStatus(\"Unknown BraidID: \" + brainId)));\r\n            } else {\r\n                try {\r\n                    final String log = servlet.getBrainApi().getLog();\r\n                    NeeoUtil.write(resp, gson.toJson(new ReturnStatus(true, log)));\r\n                } catch (IOException e) {\r\n                    NeeoUtil.write(resp, gson.toJson(new ReturnStatus(\"Exception occurred getting log: \" + e.getMessage())));\r\n                }\r\n            }\r\n        } else {\r\n            logger.debug(\"Unknown get path: {}\", StringUtils.join(paths, ','));\r\n        }\r\n    } catch (JsonParseException | IllegalArgumentException | NullPointerException e) {\r\n        logger.debug(\"Exception handling get: {}\", e.getMessage(), e);\r\n        NeeoUtil.write(resp, gson.toJson(new ReturnStatus(e.getMessage())));\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.dscalarm.internal.DSCAlarmMessage.processDSCAlarmMessage",
	"Comment": "processes the incoming dsc alarm message and extracts the information.",
	"Method": "void processDSCAlarmMessage(){\r\n    DSCAlarmCode dscAlarmCode;\r\n    if (message.length() > 3) {\r\n        try {\r\n            if (message.length() >= 8 && message.charAt(2) == ':' && message.charAt(5) == ':') {\r\n                timeStamp = message.substring(0, 8);\r\n                message = message.substring(9, message.length() - 2);\r\n            } else {\r\n                message = message.substring(0, message.length() - 2);\r\n            }\r\n            codeReceived = message.substring(0, 3);\r\n            if (message.length() >= 4) {\r\n                data = message.substring(3);\r\n            }\r\n        } catch (Exception e) {\r\n            logger.error(\"processDSCAlarmMessage(): Error processing message: ({}) \", message, e);\r\n            return;\r\n        }\r\n        dscAlarmCode = DSCAlarmCode.getDSCAlarmCodeValue(codeReceived);\r\n        if (dscAlarmCode != null) {\r\n            name = dscAlarmCode.getName();\r\n            description = dscAlarmCode.getDescription();\r\n            MessageParameters messageParms = DSCALARM_MESSAGE_PARAMETERS.get(dscAlarmCode);\r\n            if (messageParms != null) {\r\n                boolean hasPartition = messageParms.hasPartition();\r\n                boolean hasZone = messageParms.hasZone();\r\n                if (hasPartition) {\r\n                    partition = message.substring(3, 4);\r\n                }\r\n                if (hasZone) {\r\n                    if (hasPartition) {\r\n                        zone = message.substring(4);\r\n                    } else {\r\n                        zone = message.substring(3);\r\n                    }\r\n                }\r\n                messageType = messageParms.getType();\r\n            }\r\n            switch(dscAlarmCode) {\r\n                case SystemError:\r\n                    int systemErrorCode = 0;\r\n                    systemErrorCode = Integer.parseInt(data);\r\n                    switch(systemErrorCode) {\r\n                        case 1:\r\n                            error = \"Receive Buffer Overrun\";\r\n                            break;\r\n                        case 2:\r\n                            error = \"Receive Buffer Overflow\";\r\n                            break;\r\n                        case 3:\r\n                            error = \"Transmit Buffer Overflow\";\r\n                            break;\r\n                        case 10:\r\n                            error = \"Keybus Transmit Buffer Overrun\";\r\n                            break;\r\n                        case 11:\r\n                            error = \"Keybus Transmit Time Timeout\";\r\n                            break;\r\n                        case 12:\r\n                            error = \"Keybus Transmit Mode Timeout\";\r\n                            break;\r\n                        case 13:\r\n                            error = \"Keybus Transmit Keystring Timeout\";\r\n                            break;\r\n                        case 14:\r\n                            error = \"Keybus Interface Not Functioning\";\r\n                            break;\r\n                        case 15:\r\n                            error = \"Keybus Busy - Attempting to Disarm or Arm with user code\";\r\n                            break;\r\n                        case 16:\r\n                            error = \"Keybus Busy �? Lockout\";\r\n                            break;\r\n                        case 17:\r\n                            error = \"Keybus Busy �? Installers Mode\";\r\n                            break;\r\n                        case 18:\r\n                            error = \"Keybus Busy - General Busy\";\r\n                            break;\r\n                        case 20:\r\n                            error = \"API Command Syntax Error\";\r\n                            break;\r\n                        case 21:\r\n                            error = \"API Command Partition Error - Requested Partition is out of bounds\";\r\n                            break;\r\n                        case 22:\r\n                            error = \"API Command Not Supported\";\r\n                            break;\r\n                        case 23:\r\n                            error = \"API System Not Armed - Sent in response to a disarm command\";\r\n                            break;\r\n                        case 24:\r\n                            error = \"API System Not Ready to Arm - System is either not-secure, in exit-delay, or already armed\";\r\n                            break;\r\n                        case 25:\r\n                            error = \"API Command Invalid Length\";\r\n                            break;\r\n                        case 26:\r\n                            error = \"API User Code not Required\";\r\n                            break;\r\n                        case 27:\r\n                            error = \"API Invalid Characters in Command - No alpha characters are allowed except for checksum\";\r\n                            break;\r\n                        case 28:\r\n                            error = \"API Virtual Keypad is Disabled\";\r\n                            break;\r\n                        case 29:\r\n                            error = \"API Not Valid Parameter\";\r\n                            break;\r\n                        case 30:\r\n                            error = \"API Keypad Does Not Come Out of Blank Mode\";\r\n                            break;\r\n                        case 31:\r\n                            error = \"API IT-100 is Already in Thermostat Menu\";\r\n                            break;\r\n                        case 32:\r\n                            error = \"API IT-100 is NOT in Thermostat Menu\";\r\n                            break;\r\n                        case 33:\r\n                            error = \"API No Response From Thermostat or Escort Module\";\r\n                            break;\r\n                        case 0:\r\n                        default:\r\n                            error = \"No Error\";\r\n                            break;\r\n                    }\r\n                    break;\r\n                case PartitionArmed:\r\n                    mode = message.substring(4);\r\n                    if (mode.equals(\"0\")) {\r\n                        name += \" (Away)\";\r\n                    } else if (mode.equals(\"1\")) {\r\n                        name += \" (Stay)\";\r\n                    } else if (mode.equals(\"2\")) {\r\n                        name += \" (ZEA)\";\r\n                    } else if (mode.equals(\"3\")) {\r\n                        name += \" (ZES)\";\r\n                    }\r\n                    messageType = DSCAlarmMessageType.PARTITION_EVENT;\r\n                    break;\r\n                case UserClosing:\r\n                    user = message.substring(4);\r\n                    name = name.concat(\": \" + user);\r\n                    description = codeReceived + \": Partition \" + String.valueOf(partition) + \" has been armed by user \" + user + \".\";\r\n                    messageType = DSCAlarmMessageType.PARTITION_EVENT;\r\n                    break;\r\n                case UserOpening:\r\n                    user = message.substring(4);\r\n                    name = name.concat(\": \" + user);\r\n                    description = codeReceived + \": Partition \" + String.valueOf(partition) + \" has been disarmed by user \" + user + \".\";\r\n                    messageType = DSCAlarmMessageType.PARTITION_EVENT;\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            logger.debug(\"parseAPIMessage(): Message Received ({}) - Code: {}, Name: {}, Description: {}, Data: {}\\r\\n\", message, codeReceived, name, description, data);\r\n        }\r\n    } else {\r\n        codeReceived = \"-1\";\r\n        data = \"\";\r\n        dscAlarmCode = DSCAlarmCode.getDSCAlarmCodeValue(codeReceived);\r\n        name = dscAlarmCode.getName();\r\n        description = dscAlarmCode.getDescription();\r\n        logger.debug(\"parseAPIMessage(): Invalid Message Received\");\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassReader.readAnnotationValues",
	"Comment": "reads the values of an annotation and makes the given visitor visit them.",
	"Method": "int readAnnotationValues(int v,char[] buf,boolean named,AnnotationVisitor av){\r\n    int i = readUnsignedShort(v);\r\n    v += 2;\r\n    if (named) {\r\n        for (; i > 0; --i) {\r\n            v = readAnnotationValue(v + 2, buf, readUTF8(v, buf), av);\r\n        }\r\n    } else {\r\n        for (; i > 0; --i) {\r\n            v = readAnnotationValue(v, buf, null, av);\r\n        }\r\n    }\r\n    if (av != null) {\r\n        av.visitEnd();\r\n    }\r\n    return v;\r\n}"
}, {
	"Path": "org.openhab.binding.max.internal.message.MessageProcessor.getMessageType",
	"Comment": "processes the raw tcp data read from the max protocol, returning thecorresponding messagetype.",
	"Method": "MessageType getMessageType(String line){\r\n    for (MessageType msgType : MessageType.values()) {\r\n        if (line.startsWith(msgType.name() + SEPARATOR)) {\r\n            return msgType;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openhab.io.neeo.internal.ServiceContext.isExposeAllThings",
	"Comment": "helper method to determine if all things should be exposed by default",
	"Method": "boolean isExposeAllThings(){\r\n    final Object cfgExposeAll = getComponentContext().getProperties().get(NeeoConstants.CFG_EXPOSE_ALL);\r\n    return cfgExposeAll == null ? false : Boolean.parseBoolean(cfgExposeAll.toString());\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.MurmurHash.hash64",
	"Comment": "generates 64 bit hash from byte array with default seed value.",
	"Method": "long hash64(byte[] data,int length,int seed,long hash64,byte[] data,int length,long hash64,String text,long hash64,String text,int from,int length){\r\n    return hash64(text.substring(from, from + length));\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Triplet.fromIterable",
	"Comment": "create tuple from iterable. iterable has to have exactly three elements.",
	"Method": "Triplet<X, X, X> fromIterable(Iterable<X> iterable,Triplet<X, X, X> fromIterable,Iterable<X> iterable,int index,Triplet<X, X, X> fromIterable,Iterable<X> iterable,int index,boolean exactSize){\r\n    if (iterable == null) {\r\n        throw new IllegalArgumentException(\"Iterable cannot be null\");\r\n    }\r\n    boolean tooFewElements = false;\r\n    X element0 = null;\r\n    X element1 = null;\r\n    X element2 = null;\r\n    final Iterator<X> iter = iterable.iterator();\r\n    int i = 0;\r\n    while (i < index) {\r\n        if (iter.hasNext()) {\r\n            iter.next();\r\n        } else {\r\n            tooFewElements = true;\r\n        }\r\n        i++;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element0 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element1 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element2 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (tooFewElements && exactSize) {\r\n        throw new IllegalArgumentException(\"Not enough elements for creating a Triplet (3 needed)\");\r\n    }\r\n    if (iter.hasNext() && exactSize) {\r\n        throw new IllegalArgumentException(\"Iterable must have exactly 3 available elements in order to create a Triplet.\");\r\n    }\r\n    return new Triplet<X, X, X>(element0, element1, element2);\r\n}"
}, {
	"Path": "nginx.clojure.asm.Type.getClassName",
	"Comment": "returns the binary name of the class corresponding to this type. thismethod must not be used on method types.",
	"Method": "String getClassName(){\r\n    switch(sort) {\r\n        case VOID:\r\n            return \"void\";\r\n        case BOOLEAN:\r\n            return \"boolean\";\r\n        case CHAR:\r\n            return \"char\";\r\n        case BYTE:\r\n            return \"byte\";\r\n        case SHORT:\r\n            return \"short\";\r\n        case INT:\r\n            return \"int\";\r\n        case FLOAT:\r\n            return \"float\";\r\n        case LONG:\r\n            return \"long\";\r\n        case DOUBLE:\r\n            return \"double\";\r\n        case ARRAY:\r\n            StringBuffer b = new StringBuffer(getElementType().getClassName());\r\n            for (int i = getDimensions(); i > 0; --i) {\r\n                b.append(\"[]\");\r\n            }\r\n            return b.toString();\r\n        case OBJECT:\r\n            return new String(buf, off, len).replace('/', '.');\r\n        default:\r\n            return null;\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassWriter.newMethodItem",
	"Comment": "adds a method reference to the constant pool of the class being build.does nothing if the constant pool already contains a similar item.",
	"Method": "Item newMethodItem(String owner,String name,String desc,boolean itf){\r\n    int type = itf ? IMETH : METH;\r\n    key3.set(type, owner, name, desc);\r\n    Item result = get(key3);\r\n    if (result == null) {\r\n        put122(type, newClass(owner), newNameType(name, desc));\r\n        result = new Item(index++, key3);\r\n        put(result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.openhab.binding.dlinksmarthome.internal.DLinkHNAPCommunication.sendReceive",
	"Comment": "send the soap message using jetty http client. jetty is used in preference tohttpurlconnection which can result in the hnap interface becoming unresponsive.",
	"Method": "Document sendReceive(SOAPMessage action,int timeout){\r\n    Document result;\r\n    final Request request = httpClient.POST(uri);\r\n    request.timeout(timeout, TimeUnit.MILLISECONDS);\r\n    final Iterator<?> it = action.getMimeHeaders().getAllHeaders();\r\n    while (it.hasNext()) {\r\n        final MimeHeader header = (MimeHeader) it.next();\r\n        request.header(header.getName(), header.getValue());\r\n    }\r\n    try (final ByteArrayOutputStream os = new ByteArrayOutputStream()) {\r\n        action.writeTo(os);\r\n        request.content(new BytesContentProvider(os.toByteArray()));\r\n        final ContentResponse response = request.send();\r\n        try (final ByteArrayInputStream is = new ByteArrayInputStream(response.getContent())) {\r\n            result = parser.parse(is);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.handler.NikoHomeControlThermostatHandler.handleStateUpdate",
	"Comment": "method to update state of all channels, called from niko home control thermostat.",
	"Method": "void handleStateUpdate(NhcThermostat nhcThermostat){\r\n    updateState(CHANNEL_MEASURED, new QuantityType<Temperature>(nhcThermostat.getMeasured() / 10.0, CELSIUS));\r\n    long overruletime = nhcThermostat.getRemainingOverruletime();\r\n    updateState(CHANNEL_OVERRULETIME, new DecimalType(overruletime));\r\n    scheduleRefreshOverruletime(nhcThermostat);\r\n    if (overruletime == 0) {\r\n        updateState(CHANNEL_SETPOINT, new QuantityType<Temperature>(nhcThermostat.getSetpoint() / 10.0, CELSIUS));\r\n    } else {\r\n        updateState(CHANNEL_SETPOINT, new QuantityType<Temperature>(nhcThermostat.getOverrule() / 10.0, CELSIUS));\r\n    }\r\n    updateState(CHANNEL_MODE, new DecimalType(nhcThermostat.getMode()));\r\n    updateStatus(ThingStatus.ONLINE);\r\n}"
}, {
	"Path": "com.github.shyiko.mysql.binlog.event.deserialization.AbstractRowsEventDataDeserializerTest.timestamp",
	"Comment": "checkstyle, please ignore parameternumber for the next line",
	"Method": "long timestamp(int year,int month,int dayOfMonth,int hourOfDay,int minute,int second,int millis){\r\n    Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\r\n    c.set(Calendar.YEAR, year);\r\n    c.set(Calendar.MONTH, month - 1);\r\n    c.set(Calendar.DAY_OF_MONTH, dayOfMonth);\r\n    c.set(Calendar.HOUR_OF_DAY, hourOfDay);\r\n    c.set(Calendar.MINUTE, minute);\r\n    c.set(Calendar.SECOND, second);\r\n    c.set(Calendar.MILLISECOND, millis);\r\n    return c.getTimeInMillis();\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.PresenceDetectionValue.getSuccessfulDetectionTypes",
	"Comment": "return a string of comma separated successful presence detection types.",
	"Method": "String getSuccessfulDetectionTypes(){\r\n    return reachableByType.stream().map(v -> v.name()).collect(Collectors.joining(\", \"));\r\n}"
}, {
	"Path": "org.openhab.binding.nibeuplink.internal.connector.UplinkWebInterface.start",
	"Comment": "starts the periodic request executor job which handles all web requests",
	"Method": "void start(){\r\n    this.config = uplinkHandler.getConfiguration();\r\n    updateJobReference(requestExecutorJobReference, scheduler.scheduleWithFixedDelay(requestExecutor, WEB_REQUEST_INITIAL_DELAY, WEB_REQUEST_INTERVAL, TimeUnit.MILLISECONDS));\r\n}"
}, {
	"Path": "nginx.clojure.asm.Label.getFirst",
	"Comment": "returns the first label of the series to which this label belongs. for anisolated label or for the first label in a series of successive labels,this method returns the label itself. for other labels it returns thefirst label of the series.",
	"Method": "Label getFirst(){\r\n    return !ClassReader.FRAMES || frame == null ? this : frame.owner;\r\n}"
}, {
	"Path": "org.openhab.binding.silvercrestwifisocket.internal.SilvercrestWifiSocketHandlerFactory.unsetMediator",
	"Comment": "used by osgi to unsets the mediator from the handler factory.",
	"Method": "void unsetMediator(SilvercrestWifiSocketMediator mitsubishiMediator){\r\n    logger.debug(\"Mediator has been unsetted from discovery service.\");\r\n    this.mediator = null;\r\n}"
}, {
	"Path": "nginx.clojure.Coroutine.resume",
	"Comment": "runs the coroutine until it is finished or suspended. this method must onlybe called when the coroutine is in the states new or suspended. it is notmulti threading safe.",
	"Method": "void resume(){\r\n    if (state != State.NEW && state != State.SUSPENDED) {\r\n        throw new IllegalStateException(\"Not new or suspended\");\r\n    }\r\n    resumeCounter++;\r\n    State result = State.FINISHED;\r\n    Thread thread = Thread.currentThread();\r\n    Object oldLocals = HackUtils.getThreadLocals(thread);\r\n    Object oldInheritableLocals = HackUtils.getInheritableThreadLocals(thread);\r\n    try {\r\n        HackUtils.setThreadLocals(thread, this.locals);\r\n        HackUtils.setInheritablehreadLocals(thread, this.inheritableLocals);\r\n        state = State.RUNNING;\r\n        try {\r\n            proto.run();\r\n        } catch (SuspendExecution ex) {\r\n            assert ex == SuspendExecution.instance;\r\n            result = State.SUSPENDED;\r\n            stack.resumeStack();\r\n        }\r\n    } finally {\r\n        if (result == State.FINISHED) {\r\n            stack.release();\r\n            inheritableLocals = null;\r\n            locals = null;\r\n            resumeCounter = 0;\r\n            if (proto instanceof FinishAwaredRunnable) {\r\n                ((FinishAwaredRunnable) proto).onFinished(this);\r\n                ;\r\n            }\r\n        }\r\n        HackUtils.setThreadLocals(thread, oldLocals);\r\n        HackUtils.setInheritablehreadLocals(thread, oldInheritableLocals);\r\n        state = result;\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassReader.readFrameType",
	"Comment": "reads a stack map frame type and stores it at the given index in thegiven array.",
	"Method": "int readFrameType(Object[] frame,int index,int v,char[] buf,Label[] labels){\r\n    int type = b[v++] & 0xFF;\r\n    switch(type) {\r\n        case 0:\r\n            frame[index] = Opcodes.TOP;\r\n            break;\r\n        case 1:\r\n            frame[index] = Opcodes.INTEGER;\r\n            break;\r\n        case 2:\r\n            frame[index] = Opcodes.FLOAT;\r\n            break;\r\n        case 3:\r\n            frame[index] = Opcodes.DOUBLE;\r\n            break;\r\n        case 4:\r\n            frame[index] = Opcodes.LONG;\r\n            break;\r\n        case 5:\r\n            frame[index] = Opcodes.NULL;\r\n            break;\r\n        case 6:\r\n            frame[index] = Opcodes.UNINITIALIZED_THIS;\r\n            break;\r\n        case 7:\r\n            frame[index] = readClass(v, buf);\r\n            v += 2;\r\n            break;\r\n        default:\r\n            frame[index] = readLabel(readUnsignedShort(v), labels);\r\n            v += 2;\r\n    }\r\n    return v;\r\n}"
}, {
	"Path": "org.openhab.binding.max.internal.command.SConfigCommand.getCommandString",
	"Comment": "returns the base64 encoded command string to be sent via the max! cube.",
	"Method": "String getCommandString(){\r\n    final StringBuilder commandConfigString = new StringBuilder();\r\n    for (byte b : commandBytes) {\r\n        commandConfigString.append(String.format(\"X\", b));\r\n    }\r\n    String commandString = baseString + rfAddress;\r\n    if (configCommandType == ConfigCommandType.SetRoom || configCommandType == ConfigCommandType.RemoveRoom) {\r\n        commandString = commandString + commandConfigString + Utils.toHex(roomId);\r\n    } else {\r\n        commandString = commandString + Utils.toHex(roomId) + commandConfigString;\r\n    }\r\n    String encodedString = Base64.encodeBase64String(Utils.hexStringToByteArray(commandString));\r\n    return \"s:\" + encodedString;\r\n}"
}, {
	"Path": "org.openhab.binding.deconz.internal.discovery.ThingDiscoveryService.stateRequestFinished",
	"Comment": "call this method when a full bridge state request has been performed and either the sensorsare known or a failure happened.",
	"Method": "void stateRequestFinished(Map<String, SensorMessage> sensors){\r\n    stopScan();\r\n    removeOlderResults(getTimestampOfLastScan());\r\n    if (sensors != null) {\r\n        sensors.forEach(this::addDevice);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.sleepiq.internal.SleepIQHandlerFactory.registerBedDiscoveryService",
	"Comment": "register the given cloud handler to participate in discovery of new beds.",
	"Method": "void registerBedDiscoveryService(SleepIQCloudHandler cloudHandler){\r\n    logger.debug(\"Registering bed discovery service\");\r\n    SleepIQBedDiscoveryService discoveryService = new SleepIQBedDiscoveryService(cloudHandler);\r\n    discoveryServiceReg.put(cloudHandler.getThing().getUID(), bundleContext.registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable()));\r\n}"
}, {
	"Path": "org.openhab.io.neeo.internal.servletservices.ThingDashboardService.appendLine",
	"Comment": "helper method to append a line of text ot the string builder with a line separator",
	"Method": "void appendLine(StringBuilder sb,String text){\r\n    Objects.requireNonNull(sb, \"sb cannot be null\");\r\n    Objects.requireNonNull(text, \"text cannot be null\");\r\n    sb.append(text);\r\n    sb.append(System.lineSeparator());\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassWriter.getCommonSuperClass",
	"Comment": "returns the common super type of the two given types. the defaultimplementation of this method loads the two given classes and usesthe java.lang.class methods to find the common super class. it can beoverridden to compute this common super type in other ways, in particularwithout actually loading any class, or to take into account the classthat is currently being generated by this classwriter, which can ofcourse not be loaded since it is under construction.",
	"Method": "String getCommonSuperClass(String type1,String type2){\r\n    Class<?> c, d;\r\n    ClassLoader classLoader = getClass().getClassLoader();\r\n    try {\r\n        c = Class.forName(type1.replace('/', '.'), false, classLoader);\r\n        d = Class.forName(type2.replace('/', '.'), false, classLoader);\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e.toString());\r\n    }\r\n    if (c.isAssignableFrom(d)) {\r\n        return type1;\r\n    }\r\n    if (d.isAssignableFrom(c)) {\r\n        return type2;\r\n    }\r\n    if (c.isInterface() || d.isInterface()) {\r\n        return \"java/lang/Object\";\r\n    } else {\r\n        do {\r\n            c = c.getSuperclass();\r\n        } while (!c.isAssignableFrom(d));\r\n        return c.getName().replace('.', '/');\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.net.NginxClojureAsynChannel.setConnectTimeout",
	"Comment": "if timeout is negative, it will be ignored. if timeout is 0, this means no timeout.",
	"Method": "void setConnectTimeout(long timeout){\r\n    check();\r\n    as.setTimeout(timeout, -1, -1);\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.handler.YamahaZoneThingHandler.initialize",
	"Comment": "calls createcommunicationobject if the host name is configured correctly.",
	"Method": "void initialize(){\r\n    zoneConfig = getConfigAs(YamahaZoneConfig.class);\r\n    logger.trace(\"Initialize {} with zone '{}'\", getThing().getLabel(), zoneConfig.getZoneValue());\r\n    if (zoneConfig.getZone() == null) {\r\n        String msg = String.format(\"Zone not set or invalid zone name used: '%s'. It needs to be on of: '%s'\", zoneConfig.getZoneValue(), Arrays.toString(Zone.values()));\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\r\n        logger.warn(msg);\r\n        return;\r\n    }\r\n    channelsTypeProviderPreset = new ChannelsTypeProviderPreset(thing.getUID());\r\n    channelsTypeProviderAvailableInputs = new ChannelsTypeProviderAvailableInputs(thing.getUID());\r\n    if (bundleContext != null) {\r\n        servicePreset = bundleContext.registerService(ChannelTypeProvider.class.getName(), channelsTypeProviderPreset, new Hashtable());\r\n        serviceAvailableInputs = bundleContext.registerService(ChannelTypeProvider.class.getName(), channelsTypeProviderAvailableInputs, new Hashtable());\r\n    }\r\n    YamahaBridgeHandler bridgeHandler = getBridgeHandler();\r\n    if (bridgeHandler != null) {\r\n        bridgeStatusChanged(bridgeHandler.getThing().getStatusInfo());\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.putStatic",
	"Comment": "generates the instruction to store the top stack value in a static field.",
	"Method": "void putStatic(Type owner,String name,Type type){\r\n    fieldInsn(Opcodes.PUTSTATIC, owner, name, type);\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxControl.addStateListener",
	"Comment": "adds a listener for a particular state, if the state exists for the control.",
	"Method": "LxControlState addStateListener(String stateName,LxControlStateListener listener){\r\n    LxControlState state = getState(stateName);\r\n    if (state != null) {\r\n        state.addListener(listener);\r\n    } else {\r\n        logger.debug(\"Attempt to add listener for not existing state {}\", stateName);\r\n    }\r\n    return state;\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxControlInfoOnlyAnalog.getFormattedValue",
	"Comment": "obtain current value of an analog virtual state, expressed in a format configured on the miniserver",
	"Method": "String getFormattedValue(){\r\n    Double value = getStateValue(STATE_VALUE);\r\n    if (value != null) {\r\n        return String.format(format, value);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openhab.binding.pioneeravr.internal.handler.AbstractAvrHandler.onPowerOn",
	"Comment": "called when a power on state update is received from the avr for the given zone.",
	"Method": "void onPowerOn(int zone){\r\n    connection.sendVolumeQuery(zone);\r\n    connection.sendMuteQuery(zone);\r\n    connection.sendSourceInputQuery(zone);\r\n}"
}, {
	"Path": "org.openhab.binding.sleepiq.internal.handler.SleepIQCloudHandler.unregisterBedStatusListener",
	"Comment": "unregister the given listener from further bed status updates.",
	"Method": "boolean unregisterBedStatusListener(BedStatusListener listener){\r\n    boolean result = bedStatusListeners.remove(listener);\r\n    if (result) {\r\n        updateListenerManagement();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.model.PendingOIDCAuthenticationToken.getPrincipal",
	"Comment": "get the principal of this object, an immutable map of the subject and issuer.",
	"Method": "Object getPrincipal(){\r\n    return principal;\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxControlLightControllerV2.onStateChange",
	"Comment": "get configured and active moods from a new state value received from the miniserver",
	"Method": "void onStateChange(LxControlState state){\r\n    String stateName = state.getName();\r\n    String text = state.getTextValue();\r\n    logger.debug(\"Received state {} update to {}\", stateName, text);\r\n    try {\r\n        if (STATE_MOODS_LIST.equals(stateName)) {\r\n            LxJsonMood[] array = socketClient.getGson().fromJson(text, LxJsonMood[].class);\r\n            moodList.clear();\r\n            minMoodId = null;\r\n            maxMoodId = null;\r\n            LxJsonControl json = new LxJsonApp3().new LxJsonControl();\r\n            for (LxJsonMood mood : array) {\r\n                if (mood.id != null && mood.name != null) {\r\n                    logger.debug(\"Adding mood {} (name={}, isUsed={}, t5={}, static={}\", mood.id, mood.name, mood.isUsed, mood.isT5Controlled, mood.isStatic);\r\n                    json.name = mood.name;\r\n                    LxUuid moodUuid = new LxUuid(getUuid().toString() + \"-M\" + mood.id);\r\n                    LxControlMood control = new LxControlMood(socketClient, moodUuid, json, getRoom(), getCategory(), mood.id, mood.isStatic, this);\r\n                    moodList.put(moodUuid, control);\r\n                    if (minMoodId == null || minMoodId > mood.id) {\r\n                        minMoodId = mood.id;\r\n                    }\r\n                    if (maxMoodId == null || maxMoodId < mood.id) {\r\n                        maxMoodId = mood.id;\r\n                    }\r\n                }\r\n            }\r\n        } else if (STATE_ACTIVE_MOODS_LIST.equals(stateName)) {\r\n            Integer[] array = socketClient.getGson().fromJson(text, Integer[].class);\r\n            activeMoods = Arrays.asList(array);\r\n        }\r\n    } catch (JsonSyntaxException e) {\r\n        logger.debug(\"Error parsing state {}: {}\", stateName, e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.modbus.internal.AtomicStampedKeyValue.clone",
	"Comment": "synchronized implementation of clone with exception swallowing",
	"Method": "Object clone(){\r\n    try {\r\n        return super.clone();\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.pioneeravr.protocol.utils.VolumeConverter.convertFromIpControlVolumeToDb",
	"Comment": "return the double value of the volume from the value received in the ipcontrol response.",
	"Method": "double convertFromIpControlVolumeToDb(String ipControlVolume,int zone){\r\n    validateZone(zone - 1);\r\n    double ipControlVolumeInt = Double.parseDouble(ipControlVolume);\r\n    return ((ipControlVolumeInt - 1d) / 2d) - MIN_DB_VOLUME[zone - 1];\r\n}"
}, {
	"Path": "org.openhab.binding.tplinksmarthome.internal.PropertiesCollectorTest.testSwitchProperties",
	"Comment": "tests if properties for a switch device are correctly parsed.",
	"Method": "void testSwitchProperties(){\r\n    assertProperties(\"plug_get_sysinfo_response\", TPLinkSmartHomeThingType.HS100, 12);\r\n}"
}, {
	"Path": "nginx.clojure.asm.Type.getObjectType",
	"Comment": "returns the java type corresponding to the given internal name.",
	"Method": "Type getObjectType(String internalName){\r\n    char[] buf = internalName.toCharArray();\r\n    return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\r\n}"
}, {
	"Path": "org.openhab.ui.cometvisu.internal.servlet.CometVisuServlet.matches",
	"Comment": "returns true if the given match header matches the given value.",
	"Method": "boolean matches(String matchHeader,String toMatch){\r\n    String[] matchValues = matchHeader.split(\"\\\\s*,\\\\s*\");\r\n    Arrays.sort(matchValues);\r\n    return Arrays.binarySearch(matchValues, toMatch) > -1 || Arrays.binarySearch(matchValues, \"*\") > -1;\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.TestDefaultOAuth2ProviderTokenService.refreshAccessToken_expiration",
	"Comment": "checks to see that the expiration date of refreshed tokens is being set accurately to within some delta for time skew.",
	"Method": "void refreshAccessToken_expiration(){\r\n    Integer accessTokenValiditySeconds = 3600;\r\n    when(client.getAccessTokenValiditySeconds()).thenReturn(accessTokenValiditySeconds);\r\n    long start = System.currentTimeMillis();\r\n    OAuth2AccessTokenEntity token = service.refreshAccessToken(refreshTokenValue, tokenRequest);\r\n    long end = System.currentTimeMillis();\r\n    Date lowerBoundAccessTokens = new Date(start + (accessTokenValiditySeconds * 1000L) - DELTA);\r\n    Date upperBoundAccessTokens = new Date(end + (accessTokenValiditySeconds * 1000L) + DELTA);\r\n    verify(scopeService, atLeastOnce()).removeReservedScopes(anySet());\r\n    assertTrue(token.getExpiration().after(lowerBoundAccessTokens) && token.getExpiration().before(upperBoundAccessTokens));\r\n}"
}, {
	"Path": "nginx.clojure.asm.Label.inSubroutine",
	"Comment": "returns true is this basic block belongs to the given subroutine.",
	"Method": "boolean inSubroutine(long id){\r\n    if ((status & Label.VISITED) != 0) {\r\n        return (srcAndRefPositions[(int) (id >>> 32)] & (int) id) != 0;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "nginx.clojure.asm.tree.InsnList.get",
	"Comment": "returns the instruction whose index is given. this method builds a cacheof the instructions in this list to avoid scanning the whole list eachtime it is called. once the cache is built, this method run in constanttime. this cache is invalidated by all the methods that modify the list.",
	"Method": "AbstractInsnNode get(int index){\r\n    if (index < 0 || index >= size) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    if (cache == null) {\r\n        cache = toArray();\r\n    }\r\n    return cache[index];\r\n}"
}, {
	"Path": "org.openhab.binding.milight.internal.protocol.QueuedSend.queue",
	"Comment": "add data to the send queue.you have to create your own queueitem. this allows to you create a chain of commands. a chain will alwaysexecuted in order and without interrupting the sequence with another command. a chain will be removed completelyif another command with the same category is added except if the chain has been started to be processed.",
	"Method": "void queue(QueueItem item){\r\n    if (item.uniqueCommandId != NO_CATEGORY) {\r\n        removeFromQueue(item.uniqueCommandId);\r\n    }\r\n    queue.offer(item);\r\n}"
}, {
	"Path": "org.openhab.binding.modbus.internal.ModbusPollerThingHandlerTest.setUp",
	"Comment": "before each test, setup tcp endpoint thing, configure mocked item registry",
	"Method": "void setUp(){\r\n    Mockito.when(thingRegistry.get(ArgumentMatchers.any())).then(invocation -> {\r\n        ThingUID uid = (ThingUID) invocation.getArgument(0);\r\n        for (Thing thing : things) {\r\n            if (thing.getUID().equals(uid)) {\r\n                return thing;\r\n            }\r\n        }\r\n        throw new IllegalArgumentException(\"UID is unknown: \" + uid.getAsString());\r\n    });\r\n    Configuration tcpConfig = new Configuration();\r\n    tcpConfig.put(\"host\", \"thisishost\");\r\n    tcpConfig.put(\"port\", 44);\r\n    tcpConfig.put(\"id\", 9);\r\n    endpoint = createTcpThingBuilder(\"tcpendpoint\").withConfiguration(tcpConfig).build();\r\n    hookStatusUpdates(endpoint);\r\n    tcpThingHandler = new ModbusTcpThingHandler(endpoint, () -> modbusManager);\r\n    tcpThingHandler.setCallback(thingCallback);\r\n    endpoint.setHandler(tcpThingHandler);\r\n    registerThingToMockRegistry(endpoint);\r\n    tcpThingHandler.initialize();\r\n    assertThat(endpoint.getStatus(), is(equalTo(ThingStatus.ONLINE)));\r\n    reset(modbusManager);\r\n}"
}, {
	"Path": "nginx.clojure.asm.MethodVisitor.visitAnnotationDefault",
	"Comment": "visits the default value of this annotation interface method.",
	"Method": "AnnotationVisitor visitAnnotationDefault(){\r\n    if (mv != null) {\r\n        return mv.visitAnnotationDefault();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openhab.io.openhabcloud.internal.CloudService.sendNotification",
	"Comment": "this method sends notification message to mobile app through the openhab cloud service",
	"Method": "void sendNotification(String userId,String message,String icon,String severity){\r\n    logger.debug(\"Sending message '{}' to user id {}\", message, userId);\r\n    cloudClient.sendNotification(userId, message, icon, severity);\r\n}"
}, {
	"Path": "org.openhab.binding.milight.internal.handler.MilightV3WhiteHandler.setBrightness",
	"Comment": "this just emulates an absolute brightness command with the relative commands.",
	"Method": "void setBrightness(int value,MilightThingState state){\r\n    if (value <= 0) {\r\n        setPower(false, state);\r\n        return;\r\n    } else if (value >= 100) {\r\n        setFull(config.zone, state);\r\n        return;\r\n    }\r\n    final int newLevel = (int) Math.ceil((value * BRIGHTNESS_LEVELS) / 100.0);\r\n    int oldLevel;\r\n    final byte[] cFull = { COMMAND_FULL[config.zone], 0x00, 0x55 };\r\n    QueueItem item = createRepeatable(cFull);\r\n    boolean skipFirst = false;\r\n    if (state.brightness == 0) {\r\n        oldLevel = BRIGHTNESS_LEVELS;\r\n    } else {\r\n        oldLevel = (int) Math.ceil((state.brightness * BRIGHTNESS_LEVELS) / 100.0);\r\n        skipFirst = true;\r\n    }\r\n    if (newLevel == oldLevel) {\r\n        return;\r\n    }\r\n    final int repeatCount = Math.abs(newLevel - oldLevel);\r\n    logger.debug(\"milight: dim from '{}' with command '{}' via '{}' steps.\", String.valueOf(state.brightness), String.valueOf(value), repeatCount);\r\n    int op = newLevel > oldLevel ? +1 : -1;\r\n    final byte[] cOn = { COMMAND_ON[config.zone], 0x00, 0x55 };\r\n    for (int i = 0; i < repeatCount; i++) {\r\n        final byte[] cBr = { (byte) (op < 0 ? 0x34 : 0x3C), 0x00, 0x55 };\r\n        item = item.addRepeatable(cOn).addNonRepeatable(cBr);\r\n    }\r\n    final QueueItem nextItem = item.next;\r\n    if (nextItem != null && skipFirst) {\r\n        sendQueue.queue(nextItem);\r\n    } else {\r\n        sendQueue.queue(item);\r\n    }\r\n    state.brightness = value;\r\n}"
}, {
	"Path": "org.openhab.binding.sleepiq.internal.handler.SleepIQCloudHandler.updateProperties",
	"Comment": "update the given properties with attributes of the given bed. if no properties are given, a new map will becreated.",
	"Method": "Map<String, String> updateProperties(Bed bed,Map<String, String> properties){\r\n    if (bed != null) {\r\n        properties.put(Thing.PROPERTY_MODEL_ID, bed.getModel());\r\n        properties.put(SleepIQBindingConstants.PROPERTY_BASE, bed.getBase());\r\n        if (bed.isKidsBed() != null) {\r\n            properties.put(SleepIQBindingConstants.PROPERTY_KIDS_BED, bed.isKidsBed().toString());\r\n        }\r\n        properties.put(SleepIQBindingConstants.PROPERTY_MAC_ADDRESS, bed.getMacAddress());\r\n        properties.put(SleepIQBindingConstants.PROPERTY_NAME, bed.getName());\r\n        if (bed.getPurchaseDate() != null) {\r\n            properties.put(SleepIQBindingConstants.PROPERTY_PURCHASE_DATE, bed.getPurchaseDate().toString());\r\n        }\r\n        properties.put(SleepIQBindingConstants.PROPERTY_SIZE, bed.getSize());\r\n        properties.put(SleepIQBindingConstants.PROPERTY_SKU, bed.getSku());\r\n    }\r\n    return properties;\r\n}"
}, {
	"Path": "nginx.clojure.asm.Type.getDimensions",
	"Comment": "returns the number of dimensions of this array type. this method shouldonly be used for an array type.",
	"Method": "int getDimensions(){\r\n    int i = 1;\r\n    while (buf[off + i] == '[') {\r\n        ++i;\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Sextet.fromIterable",
	"Comment": "create tuple from iterable. iterable has to have exactly six elements.",
	"Method": "Sextet<X, X, X, X, X, X> fromIterable(Iterable<X> iterable,Sextet<X, X, X, X, X, X> fromIterable,Iterable<X> iterable,int index,Sextet<X, X, X, X, X, X> fromIterable,Iterable<X> iterable,int index,boolean exactSize){\r\n    if (iterable == null) {\r\n        throw new IllegalArgumentException(\"Iterable cannot be null\");\r\n    }\r\n    boolean tooFewElements = false;\r\n    X element0 = null;\r\n    X element1 = null;\r\n    X element2 = null;\r\n    X element3 = null;\r\n    X element4 = null;\r\n    X element5 = null;\r\n    final Iterator<X> iter = iterable.iterator();\r\n    int i = 0;\r\n    while (i < index) {\r\n        if (iter.hasNext()) {\r\n            iter.next();\r\n        } else {\r\n            tooFewElements = true;\r\n        }\r\n        i++;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element0 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element1 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element2 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element3 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element4 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element5 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (tooFewElements && exactSize) {\r\n        throw new IllegalArgumentException(\"Not enough elements for creating a Sextet (6 needed)\");\r\n    }\r\n    if (iter.hasNext() && exactSize) {\r\n        throw new IllegalArgumentException(\"Iterable must have exactly 6 available elements in order to create a Sextet.\");\r\n    }\r\n    return new Sextet<X, X, X, X, X, X>(element0, element1, element2, element3, element4, element5);\r\n}"
}, {
	"Path": "org.openhab.binding.minecraft.internal.server.ServerConnection.getSocketHandler",
	"Comment": "get the object used to handle state changes and messages from web socket.",
	"Method": "MinecraftSocketHandler getSocketHandler(){\r\n    return socketHandler;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.web.AuthenticationTimeStamper.onAuthenticationSuccess",
	"Comment": "set the timestamp on the session to mark when the authentication happened,\tuseful for calculating authentication age. this gets stored in the sesion\tand can get pulled out by other components.",
	"Method": "void onAuthenticationSuccess(HttpServletRequest request,HttpServletResponse response,Authentication authentication){\r\n    Date authTimestamp = new Date();\r\n    HttpSession session = request.getSession();\r\n    session.setAttribute(AUTH_TIMESTAMP, authTimestamp);\r\n    if (session.getAttribute(AuthorizationRequestFilter.PROMPT_REQUESTED) != null) {\r\n        session.setAttribute(AuthorizationRequestFilter.PROMPTED, Boolean.TRUE);\r\n        session.removeAttribute(AuthorizationRequestFilter.PROMPT_REQUESTED);\r\n    }\r\n    logger.info(\"Successful Authentication of \" + authentication.getName() + \" at \" + authTimestamp.toString());\r\n    super.onAuthenticationSuccess(request, response, authentication);\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Quintet.fromArray",
	"Comment": "create tuple from array. array has to have exactly five elements.",
	"Method": "Quintet<X, X, X, X, X> fromArray(X[] array){\r\n    if (array == null) {\r\n        throw new IllegalArgumentException(\"Array cannot be null\");\r\n    }\r\n    if (array.length != 5) {\r\n        throw new IllegalArgumentException(\"Array must have exactly 5 elements in order to create a Quintet. Size is \" + array.length);\r\n    }\r\n    return new Quintet<X, X, X, X, X>(array[0], array[1], array[2], array[3], array[4]);\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.device.cosem.OBISIdentifier.equalsWildCard",
	"Comment": "checks whether this obis identifer and the other identifer equals taking the wildcards into account",
	"Method": "boolean equalsWildCard(OBISIdentifier o){\r\n    boolean result = true;\r\n    result &= groupA == o.groupA;\r\n    if (groupB != null && o.groupB != null) {\r\n        result &= (groupB.equals(o.groupB));\r\n    }\r\n    result &= groupC == o.groupC;\r\n    result &= groupD == o.groupD;\r\n    result &= groupE == o.groupE;\r\n    if (groupF != null && o.groupF != null) {\r\n        result &= (groupF.equals(o.groupF));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.math",
	"Comment": "generates the instruction to do the specified mathematical or logicaloperation.",
	"Method": "void math(int op,Type type){\r\n    mv.visitInsn(type.getOpcode(op));\r\n}"
}, {
	"Path": "org.openhab.binding.max.internal.handler.MaxDevicesHandler.deviceDelete",
	"Comment": "sends the t command to the cube to disassociate the device from the max! cube.",
	"Method": "void deviceDelete(){\r\n    MaxCubeBridgeHandler maxCubeBridge = getMaxCubeBridgeHandler();\r\n    if (maxCubeBridge != null) {\r\n        maxCubeBridge.sendDeviceDelete(maxDeviceSerial);\r\n        dispose();\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.zone.RioZoneProtocol.updateZoneFavoritesChannel",
	"Comment": "will update the zone favorites channel with only valid favorites",
	"Method": "void updateZoneFavoritesChannel(){\r\n    final List<RioFavorite> favs = new ArrayList();\r\n    for (final RioFavorite fav : zoneFavorites) {\r\n        if (fav.isValid()) {\r\n            favs.add(fav);\r\n        }\r\n    }\r\n    final String favJson = gson.toJson(favs);\r\n    stateChanged(RioConstants.CHANNEL_ZONEFAVORITES, new StringType(favJson));\r\n}"
}, {
	"Path": "org.openhab.binding.gpstracker.internal.handler.TrackerHandler.mapDistanceChannels",
	"Comment": "create a map of all configured distance channels to handle channel updates easily.",
	"Method": "void mapDistanceChannels(){\r\n    distanceChannelMap = thing.getChannels().stream().filter(c -> CHANNEL_TYPE_DISTANCE.equals(c.getChannelTypeUID())).collect(Collectors.toMap(c -> ConfigHelper.getRegionName(c.getConfiguration()), Function.identity()));\r\n    regions.addAll(distanceChannelMap.keySet());\r\n}"
}, {
	"Path": "nginx.clojure.asm.tree.AbstractInsnNode.getPrevious",
	"Comment": "returns the previous instruction in the list to which this instructionbelongs, if any.",
	"Method": "AbstractInsnNode getPrevious(){\r\n    return prev;\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.protocol.xml.InputWithPlayControlXML.applyModelVariations",
	"Comment": "apply command changes to ensure compatibility with all supported models",
	"Method": "void applyModelVariations(){\r\n    if (inputFeatureDescriptor != null) {\r\n        if (inputFeatureDescriptor.hasCommandEnding(\"Play_Control,Play\")) {\r\n            playCmd = new CommandTemplate(\"<Play_Control><Play>%s<\/Play><\/Play_Control>\", \"Play_Info/Status\");\r\n            logger.debug(\"Input {} - adjusting command to: {}\", inputElement, playCmd);\r\n        }\r\n        if (inputFeatureDescriptor.hasCommandEnding(\"Play_Control,Skip\")) {\r\n            skipForwardValue = \"Fwd\";\r\n            skipBackwardValue = \"Rev\";\r\n            skipCmd = new CommandTemplate(\"<Play_Control><Skip>%s<\/Skip><\/Play_Control>\");\r\n            logger.debug(\"Input {} - adjusting command to: {}\", inputElement, skipCmd);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.ui.cometvisu.internal.util.ClientInstaller.isNewer",
	"Comment": "compare two semver version strings and return true if releaseversion is newer then currentversion",
	"Method": "boolean isNewer(String releaseVersion,String currentVersion){\r\n    logger.debug(\"checking if {} is newer than {}\", releaseVersion, currentVersion);\r\n    Matcher release = semverPattern.matcher(releaseVersion);\r\n    Matcher current = semverPattern.matcher(currentVersion);\r\n    if (!release.matches()) {\r\n        throw new NumberFormatException(\"release version format error \" + releaseVersion);\r\n    }\r\n    if (!current.matches()) {\r\n        throw new NumberFormatException(\"current version format error \" + currentVersion);\r\n    }\r\n    for (int i = 1; i <= 3; i++) {\r\n        if (Integer.parseInt(release.group(i)) > Integer.parseInt(current.group(i))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.github.shyiko.mysql.binlog.event.deserialization.AbstractRowsEventDataDeserializer.asUnixTime",
	"Comment": "checkstyle, please ignore parameternumber for the next line",
	"Method": "Long asUnixTime(int year,int month,int day,int hour,int minute,int second,int millis){\r\n    if (year == 0 || month == 0 || day == 0) {\r\n        return invalidDateAndTimeRepresentation;\r\n    }\r\n    return UnixTime.from(year, month, day, hour, minute, second, millis);\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassWriter.newString",
	"Comment": "adds a string to the constant pool of the class being build. does nothingif the constant pool already contains a similar item.",
	"Method": "Item newString(String value){\r\n    key2.set(STR, value, null, null);\r\n    Item result = get(key2);\r\n    if (result == null) {\r\n        pool.put12(STR, newUTF8(value));\r\n        result = new Item(index++, key2);\r\n        put(result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.TestDefaultOAuth2ProviderTokenService.createAccessToken_expiration",
	"Comment": "checks to see that the expiration date of new tokens is being set accurately to within some delta for time skew.",
	"Method": "void createAccessToken_expiration(){\r\n    Integer accessTokenValiditySeconds = 3600;\r\n    Integer refreshTokenValiditySeconds = 600;\r\n    when(client.getAccessTokenValiditySeconds()).thenReturn(accessTokenValiditySeconds);\r\n    when(client.getRefreshTokenValiditySeconds()).thenReturn(refreshTokenValiditySeconds);\r\n    long start = System.currentTimeMillis();\r\n    OAuth2AccessTokenEntity token = service.createAccessToken(authentication);\r\n    long end = System.currentTimeMillis();\r\n    Date lowerBoundAccessTokens = new Date(start + (accessTokenValiditySeconds * 1000L) - DELTA);\r\n    Date upperBoundAccessTokens = new Date(end + (accessTokenValiditySeconds * 1000L) + DELTA);\r\n    Date lowerBoundRefreshTokens = new Date(start + (refreshTokenValiditySeconds * 1000L) - DELTA);\r\n    Date upperBoundRefreshTokens = new Date(end + (refreshTokenValiditySeconds * 1000L) + DELTA);\r\n    verify(scopeService, atLeastOnce()).removeReservedScopes(anySet());\r\n    assertTrue(token.getExpiration().after(lowerBoundAccessTokens) && token.getExpiration().before(upperBoundAccessTokens));\r\n    assertTrue(token.getRefreshToken().getExpiration().after(lowerBoundRefreshTokens) && token.getRefreshToken().getExpiration().before(upperBoundRefreshTokens));\r\n}"
}, {
	"Path": "org.openhab.binding.neeo.internal.handler.NeeoDeviceHandler.addProperty",
	"Comment": "helper method to add a property to the properties map if the value is not null",
	"Method": "void addProperty(Map<String, String> properties,String key,String value){\r\n    Objects.requireNonNull(properties, \"properties cannot be null\");\r\n    NeeoUtil.requireNotEmpty(key, \"key cannot be empty\");\r\n    if (value != null && StringUtils.isNotEmpty(value)) {\r\n        properties.put(key, value);\r\n    }\r\n}"
}, {
	"Path": "geometry.geom2d.Line2D.intersectAtSinglePoint",
	"Comment": "check if an intersection point between this line and an other one exists.",
	"Method": "boolean intersectAtSinglePoint(Line2D other){\r\n    LineLineIntersector intersector = new LineLineIntersector(this, other);\r\n    return intersector.hasUniqueIntersection();\r\n}"
}, {
	"Path": "nginx.clojure.asm.Label.resolve",
	"Comment": "resolves all forward references to this label. this method must be calledwhen this label is added to the bytecode of the method, i.e. when itsposition becomes known. this method fills in the blanks that where leftin the bytecode by each forward reference previously added to this label.",
	"Method": "boolean resolve(MethodWriter owner,int position,byte[] data){\r\n    boolean needUpdate = false;\r\n    this.status |= RESOLVED;\r\n    this.position = position;\r\n    int i = 0;\r\n    while (i < referenceCount) {\r\n        int source = srcAndRefPositions[i++];\r\n        int reference = srcAndRefPositions[i++];\r\n        int offset;\r\n        if (source >= 0) {\r\n            offset = position - source;\r\n            if (offset < Short.MIN_VALUE || offset > Short.MAX_VALUE) {\r\n                int opcode = data[reference - 1] & 0xFF;\r\n                if (opcode <= Opcodes.JSR) {\r\n                    data[reference - 1] = (byte) (opcode + 49);\r\n                } else {\r\n                    data[reference - 1] = (byte) (opcode + 20);\r\n                }\r\n                needUpdate = true;\r\n            }\r\n            data[reference++] = (byte) (offset >>> 8);\r\n            data[reference] = (byte) offset;\r\n        } else {\r\n            offset = position + source + 1;\r\n            data[reference++] = (byte) (offset >>> 24);\r\n            data[reference++] = (byte) (offset >>> 16);\r\n            data[reference++] = (byte) (offset >>> 8);\r\n            data[reference] = (byte) offset;\r\n        }\r\n    }\r\n    return needUpdate;\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Quartet.fromCollection",
	"Comment": "create tuple from collection. collection has to have exactly four elements.",
	"Method": "Quartet<X, X, X, X> fromCollection(Collection<X> collection){\r\n    return fromIterable(collection);\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Quartet.fromIterable",
	"Comment": "create tuple from iterable. iterable has to have exactly four elements.",
	"Method": "Quartet<X, X, X, X> fromIterable(Iterable<X> iterable,Quartet<X, X, X, X> fromIterable,Iterable<X> iterable,int index,Quartet<X, X, X, X> fromIterable,Iterable<X> iterable,int index,boolean exactSize){\r\n    if (iterable == null) {\r\n        throw new IllegalArgumentException(\"Iterable cannot be null\");\r\n    }\r\n    boolean tooFewElements = false;\r\n    X element0 = null;\r\n    X element1 = null;\r\n    X element2 = null;\r\n    X element3 = null;\r\n    final Iterator<X> iter = iterable.iterator();\r\n    int i = 0;\r\n    while (i < index) {\r\n        if (iter.hasNext()) {\r\n            iter.next();\r\n        } else {\r\n            tooFewElements = true;\r\n        }\r\n        i++;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element0 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element1 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element2 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element3 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (tooFewElements && exactSize) {\r\n        throw new IllegalArgumentException(\"Not enough elements for creating a Quartet (4 needed)\");\r\n    }\r\n    if (iter.hasNext() && exactSize) {\r\n        throw new IllegalArgumentException(\"Iterable must have exactly 4 available elements in order to create a Quartet.\");\r\n    }\r\n    return new Quartet<X, X, X, X>(element0, element1, element2, element3);\r\n}"
}, {
	"Path": "org.openhab.binding.powermax.internal.state.PowermaxState.getShortArmMode",
	"Comment": "get the short description associated to the current arming mode",
	"Method": "String getShortArmMode(String getShortArmMode,String armMode){\r\n    String result = null;\r\n    if (armMode != null) {\r\n        try {\r\n            PowermaxArmMode mode = PowermaxArmMode.fromName(armMode);\r\n            result = mode.getShortName();\r\n        } catch (IllegalArgumentException e) {\r\n            result = armMode;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.openhab.binding.gpstracker.internal.handler.TrackerHandler.updateChannelsWithLocation",
	"Comment": "update state channels from location message. this includes basic channel updates and recalculations of all distances.",
	"Method": "void updateChannelsWithLocation(LocationMessage message){\r\n    updateBaseChannels(message, CHANNEL_BATTERY_LEVEL, CHANNEL_LAST_LOCATION, CHANNEL_LAST_REPORT, CHANNEL_GPS_ACCURACY);\r\n    String trackerId = message.getTrackerId();\r\n    logger.debug(\"Updating distance channels tracker {}\", trackerId);\r\n    distanceChannelMap.values().forEach(c -> updateDistanceChannelFromMessage(message, c));\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.Method.getReturnType",
	"Comment": "returns the return type of the method described by this object.",
	"Method": "Type getReturnType(){\r\n    return Type.getReturnType(desc);\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.device.p1telegram.CRC16.processByte",
	"Comment": "processed a single byte and updates the internal crc16 value",
	"Method": "void processByte(byte b){\r\n    crcValue = (crcValue >> 8) ^ (crcTable[(crcValue & 0xFF) ^ (b & 0xFF)] & 0xFFFF);\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.monitorEnter",
	"Comment": "generates the instruction to get the monitor of the top stack value.",
	"Method": "void monitorEnter(){\r\n    mv.visitInsn(Opcodes.MONITORENTER);\r\n}"
}, {
	"Path": "nginx.clojure.asm.ByteVector.putByteArray",
	"Comment": "puts an array of bytes into this byte vector. the byte vector isautomatically enlarged if necessary.",
	"Method": "ByteVector putByteArray(byte[] b,int off,int len){\r\n    if (length + len > data.length) {\r\n        enlarge(len);\r\n    }\r\n    if (b != null) {\r\n        System.arraycopy(b, off, data, length, len);\r\n    }\r\n    length += len;\r\n    return this;\r\n}"
}, {
	"Path": "org.openhab.io.neeo.internal.models.NeeoDeviceTiming.constrainTime",
	"Comment": "utility function to ensure the passed delay is withing bounds",
	"Method": "int constrainTime(int delay){\r\n    if (delay < MIN_DELAY) {\r\n        return MIN_DELAY;\r\n    }\r\n    if (delay > MAX_DELAY) {\r\n        return MAX_DELAY;\r\n    }\r\n    return delay;\r\n}"
}, {
	"Path": "org.mitre.util.jpa.JpaUtil.getResultPage",
	"Comment": "get a page of results from the specified typedquery\tby using the given pagecriteria to limit the query\tresults. the pagecriteria will override any size or\toffset already specified on the query.",
	"Method": "List<T> getResultPage(TypedQuery<T> query,PageCriteria pageCriteria){\r\n    query.setMaxResults(pageCriteria.getPageSize());\r\n    query.setFirstResult(pageCriteria.getPageNumber() * pageCriteria.getPageSize());\r\n    return query.getResultList();\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.getStatic",
	"Comment": "generates the instruction to push the value of a static field on thestack.",
	"Method": "void getStatic(Type owner,String name,Type type){\r\n    fieldInsn(Opcodes.GETSTATIC, owner, name, type);\r\n}"
}, {
	"Path": "org.openhab.binding.onebusaway.internal.handler.StopHandler.registerRouteDataListener",
	"Comment": "registers the listener to receive updates about arrival and departure times for its route.",
	"Method": "boolean registerRouteDataListener(RouteDataListener listener){\r\n    if (listener == null) {\r\n        throw new IllegalArgumentException(\"It makes no sense to register a null listener!\");\r\n    }\r\n    boolean added = routeDataListeners.add(listener);\r\n    if (added) {\r\n        String routeId = listener.getRouteId();\r\n        List<ObaStopArrivalResponse.ArrivalAndDeparture> copiedRouteData;\r\n        synchronized (routeData) {\r\n            copiedRouteData = Lists.newArrayList(routeData.get(routeId));\r\n        }\r\n        Collections.sort(copiedRouteData);\r\n        listener.onNewRouteData(routeDataLastUpdateMs, copiedRouteData);\r\n    }\r\n    return added;\r\n}"
}, {
	"Path": "org.openhab.io.hueemulation.internal.RESTApi.remaining",
	"Comment": "cuts of the first part of a path and returns the remaining one.",
	"Method": "Path remaining(Path path){\r\n    if (path.getNameCount() > 1) {\r\n        return path.subpath(1, path.getNameCount());\r\n    } else {\r\n        return Paths.get(\"/\");\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.feed.internal.handler.FeedHandler.getLatestEntry",
	"Comment": "returns the most recent entry or null, if no entries are found.",
	"Method": "SyndEntry getLatestEntry(SyndFeed feed){\r\n    List<SyndEntry> allEntries = feed.getEntries();\r\n    SyndEntry lastEntry = null;\r\n    if (allEntries.size() >= 1) {\r\n        lastEntry = allEntries.get(0);\r\n    } else {\r\n        logger.debug(\"No entries found\");\r\n    }\r\n    return lastEntry;\r\n}"
}, {
	"Path": "org.openhab.binding.phc.internal.handler.PHCBridgeHandler.handleIncomingCommand",
	"Comment": "send the incoming command to the appropriate handler and channel.",
	"Method": "void handleIncomingCommand(byte moduleAddress,int channel,byte[] cmd){\r\n    ThingUID uid = PHCHelper.getThingUIDreverse(PHCBindingConstants.THING_TYPE_EM, moduleAddress);\r\n    Thing thing = getThingByUID(uid);\r\n    String channelId = \"em#\" + StringUtils.leftPad(Integer.toString(channel), 2, '0');\r\n    if (thing != null) {\r\n        OnOffType state = OnOffType.OFF;\r\n        if ((cmd[0] & 0x0F) == 2) {\r\n            state = OnOffType.ON;\r\n        }\r\n        logger.debug(\"{}, {}\", thing.getUID(), state);\r\n        ((PHCHandler) thing.getHandler()).handleIncoming(channelId, state);\r\n    } else {\r\n        logger.info(\"No Thing with UID {} available.\", uid.getAsString());\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.monitorExit",
	"Comment": "generates the instruction to release the monitor of the top stack value.",
	"Method": "void monitorExit(){\r\n    mv.visitInsn(Opcodes.MONITOREXIT);\r\n}"
}, {
	"Path": "org.openhab.binding.powermax.internal.handler.PowermaxBridgeHandler.updateMotionSensorState",
	"Comment": "set the state of items linked to motion sensors to off when the last trip is olderthan the value defined by the variable motionoffdelay",
	"Method": "void updateMotionSensorState(){\r\n    long now = System.currentTimeMillis();\r\n    if (currentState != null) {\r\n        boolean update = false;\r\n        PowermaxState updateState = commManager.createNewState();\r\n        PowermaxPanelSettings panelSettings = getPanelSettings();\r\n        for (int i = 1; i <= panelSettings.getNbZones(); i++) {\r\n            if (panelSettings.getZoneSettings(i) != null && panelSettings.getZoneSettings(i).isMotionSensor() && currentState.isLastTripBeforeTime(i, now - motionOffDelay)) {\r\n                update = true;\r\n                updateState.setSensorTripped(i, false);\r\n            }\r\n        }\r\n        if (update) {\r\n            updateChannelsFromAlarmState(TRIPPED, updateState);\r\n            currentState.merge(updateState);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.TestDefaultUserInfoService.loadByUsername_nullUser",
	"Comment": "if a user is not found, the loadbyusername method should throw an exception.",
	"Method": "void loadByUsername_nullUser(){\r\n    Mockito.when(userInfoRepository.getByUsername(adminUsername)).thenReturn(null);\r\n    UserInfo user = service.getByUsername(adminUsername);\r\n    assertNull(user);\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.ModbusRegisterArray.appendHexString",
	"Comment": "appends the register data as hex string to the given stringbuffer",
	"Method": "StringBuffer appendHexString(StringBuffer buffer){\r\n    IntStream.range(0, size()).forEachOrdered(index -> {\r\n        getRegister(index).appendHexString(buffer);\r\n        if (index < size() - 1) {\r\n            buffer.append(' ');\r\n        }\r\n    });\r\n    return buffer;\r\n}"
}, {
	"Path": "org.openhab.binding.dlinksmarthome.internal.DLinkHNAPCommunication.setAuthenticationData",
	"Comment": "sets the password for the second login message based on the data received from thefirst login message. also sets the private key used to generate the authentication header.",
	"Method": "void setAuthenticationData(String challenge,String cookie,String publicKey){\r\n    final MimeHeaders loginHeaders = loginAction.getMimeHeaders();\r\n    loginHeaders.setHeader(COOKIE, \"uid=\" + cookie);\r\n    privateKey = hash(challenge, publicKey + pin);\r\n    final String password = hash(challenge, privateKey);\r\n    loginAction.getSOAPBody().getElementsByTagName(LOGINPASSWORD).item(0).setTextContent(password);\r\n    loginAction.saveChanges();\r\n}"
}, {
	"Path": "org.openhab.binding.solaredge.internal.model.AbstractAggregateDataResponsePrivateApi.assignValue",
	"Comment": "converts the value to quantitytype. if no unit can be determined undeftype.undef will be used",
	"Method": "void assignValue(Map<Channel, State> targetMap,Channel channel,Value value){\r\n    State result = UnDefType.UNDEF;\r\n    if (value != null && value.value != null && value.unit != null) {\r\n        Unit<Energy> unit = determineEnergyUnit(value.unit);\r\n        if (unit != null) {\r\n            result = new QuantityType<Energy>(value.value, unit);\r\n        } else {\r\n            logger.debug(\"Channel {}: Could not determine unit: '{}'\", channel.getFQName(), value.unit);\r\n        }\r\n    } else {\r\n        logger.debug(\"Channel {}: no value provided or value has no unit.\", channel.getFQName());\r\n    }\r\n    targetMap.put(channel, result);\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.TestDefaultOAuth2ProviderTokenService.createAccessToken_nullAuth",
	"Comment": "tests exception handling for null authentication or null authorization.",
	"Method": "void createAccessToken_nullAuth(){\r\n    when(authentication.getOAuth2Request()).thenReturn(null);\r\n    try {\r\n        service.createAccessToken(null);\r\n        fail(\"Authentication parameter is null. Excpected a AuthenticationCredentialsNotFoundException.\");\r\n    } catch (AuthenticationCredentialsNotFoundException e) {\r\n        assertThat(e, is(notNullValue()));\r\n    }\r\n    try {\r\n        service.createAccessToken(authentication);\r\n        fail(\"AuthorizationRequest is null. Excpected a AuthenticationCredentialsNotFoundException.\");\r\n    } catch (AuthenticationCredentialsNotFoundException e) {\r\n        assertThat(e, is(notNullValue()));\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.Label.addToSubroutine",
	"Comment": "marks this basic block as belonging to the given subroutine.",
	"Method": "void addToSubroutine(long id,int nbSubroutines){\r\n    if ((status & VISITED) == 0) {\r\n        status |= VISITED;\r\n        srcAndRefPositions = new int[(nbSubroutines - 1) / 32 + 1];\r\n    }\r\n    srcAndRefPositions[(int) (id >>> 32)] |= (int) id;\r\n}"
}, {
	"Path": "org.openhab.binding.harmonyhub.internal.HarmonyHubHandlerFactory.registerHarmonyDeviceDiscoveryService",
	"Comment": "adds harmonyhubhandler to the discovery service to find harmony devices",
	"Method": "void registerHarmonyDeviceDiscoveryService(HarmonyHubHandler harmonyHubHandler){\r\n    HarmonyDeviceDiscoveryService discoveryService = new HarmonyDeviceDiscoveryService(harmonyHubHandler);\r\n    this.discoveryServiceRegs.put(harmonyHubHandler.getThing().getUID(), bundleContext.registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable()));\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.MurmurHash.hash32",
	"Comment": "generates 32 bit hash from byte array with default seed value.",
	"Method": "int hash32(byte[] data,int length,int seed,int hash32,byte[] data,int length,int hash32,String text,int hash32,String text,int from,int length){\r\n    return hash32(text.substring(from, from + length));\r\n}"
}, {
	"Path": "org.openhab.binding.powermax.internal.message.PowermaxCommManager.sendSetTime",
	"Comment": "send a message to set the alarm time and date using the system time and date",
	"Method": "boolean sendSetTime(){\r\n    logger.debug(\"sendSetTime()\");\r\n    boolean done = false;\r\n    if (autoSyncTime) {\r\n        GregorianCalendar cal = new GregorianCalendar();\r\n        if (cal.get(Calendar.YEAR) >= 2000) {\r\n            logger.debug(\"sendSetTime(): sync time {}\", String.format(\"d/d/d d:d:d\", cal.get(Calendar.DAY_OF_MONTH), cal.get(Calendar.MONTH) + 1, cal.get(Calendar.YEAR), cal.get(Calendar.HOUR_OF_DAY), cal.get(Calendar.MINUTE), cal.get(Calendar.SECOND)));\r\n            byte[] dynPart = new byte[6];\r\n            dynPart[0] = (byte) cal.get(Calendar.SECOND);\r\n            dynPart[1] = (byte) cal.get(Calendar.MINUTE);\r\n            dynPart[2] = (byte) cal.get(Calendar.HOUR_OF_DAY);\r\n            dynPart[3] = (byte) cal.get(Calendar.DAY_OF_MONTH);\r\n            dynPart[4] = (byte) (cal.get(Calendar.MONTH) + 1);\r\n            dynPart[5] = (byte) (cal.get(Calendar.YEAR) - 2000);\r\n            done = sendMessage(new PowermaxBaseMessage(PowermaxSendType.SETTIME, dynPart), false, 0);\r\n            cal.set(Calendar.MILLISECOND, 0);\r\n            syncTimeCheck = cal.getTimeInMillis();\r\n        } else {\r\n            logger.info(\"Powermax alarm binding: time not synchronized; please correct the date/time of your openHAB server\");\r\n            syncTimeCheck = null;\r\n        }\r\n    } else {\r\n        syncTimeCheck = null;\r\n    }\r\n    return done;\r\n}"
}, {
	"Path": "nginx.clojure.AppEventListenerManager.buildPostedEvent",
	"Comment": "this method is used by clojure to build posted event easier.",
	"Method": "PostedEvent buildPostedEvent(Object otag,Object data,PostedEvent buildPostedEvent,int tag,Object data){\r\n    PostedEvent e = pooledEvents.poll();\r\n    if (e == null) {\r\n        e = new PostedEvent();\r\n    }\r\n    e.accept(tag, data);\r\n    return e;\r\n}"
}, {
	"Path": "org.openhab.binding.squeezebox.internal.discovery.SqueezeBoxPlayerDiscoveryParticipant.cancelRequestPlayerJob",
	"Comment": "allows request player job to be canceled when server handler is removed",
	"Method": "void cancelRequestPlayerJob(){\r\n    logger.debug(\"canceling RequestPlayerJob\");\r\n    if (requestPlayerJob != null) {\r\n        requestPlayerJob.cancel(true);\r\n        requestPlayerJob = null;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.max.internal.handler.MaxDevicesHandler.refreshActualsRestore",
	"Comment": "send the commands to restore the original settings for mode & temperatureto end the automatic update cycle",
	"Method": "void refreshActualsRestore(){\r\n    try {\r\n        refreshingActuals = false;\r\n        if (originalMode == ThermostatModeType.AUTOMATIC || originalMode == ThermostatModeType.MANUAL) {\r\n            logger.debug(\"Finished Actuals Refresh: Restoring Temp {}\", originalSetTemp);\r\n            handleCommand(new ChannelUID(getThing().getUID(), CHANNEL_SETTEMP), new QuantityType(originalSetTemp, CELSIUS));\r\n        }\r\n        if (refreshActualsJob != null && !refreshActualsJob.isCancelled()) {\r\n            refreshActualsJob.cancel(true);\r\n            refreshActualsJob = null;\r\n        }\r\n    } catch (Exception e) {\r\n        logger.debug(\"Exception occurred during Actuals Refresh : {}\", e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.sleepiq.internal.handler.SleepIQCloudHandler.createCloudConnection",
	"Comment": "create a new sleepiq cloud service connection. if a connection already exists, it will be lost.",
	"Method": "void createCloudConnection(){\r\n    logger.debug(\"Reading SleepIQ cloud binding configuration\");\r\n    SleepIQCloudConfiguration bindingConfig = getConfigAs(SleepIQCloudConfiguration.class);\r\n    logger.debug(\"Creating SleepIQ client\");\r\n    Configuration cloudConfig = new Configuration().withUsername(bindingConfig.username).withPassword(bindingConfig.password).withLogging(logger.isDebugEnabled());\r\n    cloud = SleepIQ.create(cloudConfig);\r\n    logger.debug(\"Authenticating at the SleepIQ cloud service\");\r\n    cloud.login();\r\n    logger.info(\"Successfully authenticated at the SleepIQ cloud service\");\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxUuid.setUpdate",
	"Comment": "indicate the object corresponding to uuid has recently been updated.",
	"Method": "void setUpdate(boolean updated){\r\n    this.updated = updated;\r\n}"
}, {
	"Path": "org.openhab.binding.tplinksmarthome.internal.Commands.getRealtimeAndSysinfo",
	"Comment": "returns the json to get the energy and sys info data from the device.",
	"Method": "String getRealtimeAndSysinfo(){\r\n    return GET_REALTIME_AND_SYSINFO;\r\n}"
}, {
	"Path": "com.mycollab.vaadin.web.ui.chart.JFreeChartWrapper.getGraphWidth",
	"Comment": "gets the pixel width into which the graph is rendered. unless explicitlyset, the value is derived from the components size, except when thecomponent has relative size.",
	"Method": "int getGraphWidth(){\r\n    if (graphWidthInPixels > 0) {\r\n        return graphWidthInPixels;\r\n    }\r\n    int width;\r\n    float w = getWidth();\r\n    if (w < 0) {\r\n        return DEFAULT_WIDTH;\r\n    }\r\n    switch(getWidthUnits()) {\r\n        case CM:\r\n            width = (int) (w * 96 / 2.54);\r\n            break;\r\n        case INCH:\r\n            width = (int) (w * 96);\r\n            break;\r\n        case PERCENTAGE:\r\n            width = DEFAULT_WIDTH;\r\n            break;\r\n        default:\r\n            width = (int) w;\r\n            break;\r\n    }\r\n    return width;\r\n}"
}, {
	"Path": "org.openhab.binding.milight.internal.protocol.MilightV6SessionManager.sendSearchForBroadcast",
	"Comment": "send a search for bridgeid packet on all network interfaces.this is used for the initial way to determine the ip of the bridge as wellas if the ip of a bridge has changed and the session got invalid because of that.a response will assign us session bytes.",
	"Method": "void sendSearchForBroadcast(DatagramSocket datagramSocket){\r\n    byte[] t = new byte[] { (byte) 0x10, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x0A, (byte) 0x02, clientSID1, clientSID2, (byte) 0x01, bridgeMAC[0], bridgeMAC[1], bridgeMAC[2], bridgeMAC[3], bridgeMAC[4], bridgeMAC[5] };\r\n    if (lastKnownIP != null) {\r\n        try {\r\n            datagramSocket.send(new DatagramPacket(t, t.length, lastKnownIP, port));\r\n        } catch (IOException e) {\r\n            logger.warn(\"Could not send discover packet! {}\", e.getLocalizedMessage());\r\n        }\r\n        return;\r\n    }\r\n    Enumeration<NetworkInterface> enumNetworkInterfaces;\r\n    try {\r\n        enumNetworkInterfaces = NetworkInterface.getNetworkInterfaces();\r\n    } catch (SocketException socketException) {\r\n        logger.warn(\"Could not enumerate network interfaces for sending the discover packet!\", socketException);\r\n        return;\r\n    }\r\n    DatagramPacket packet = new DatagramPacket(t, t.length, lastKnownIP, port);\r\n    while (enumNetworkInterfaces.hasMoreElements()) {\r\n        NetworkInterface networkInterface = enumNetworkInterfaces.nextElement();\r\n        Iterator<InterfaceAddress> it = networkInterface.getInterfaceAddresses().iterator();\r\n        while (it.hasNext()) {\r\n            InterfaceAddress address = it.next();\r\n            if (address == null) {\r\n                continue;\r\n            }\r\n            InetAddress broadcast = address.getBroadcast();\r\n            if (broadcast != null && !address.getAddress().isLoopbackAddress()) {\r\n                packet.setAddress(broadcast);\r\n                try {\r\n                    datagramSocket.send(packet);\r\n                } catch (IOException e) {\r\n                    logger.warn(\"Could not send discovery packet! {}\", e.getLocalizedMessage());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.MethodVisitor.visitJumpInsn",
	"Comment": "visits a jump instruction. a jump instruction is an instruction that mayjump to another instruction.",
	"Method": "void visitJumpInsn(int opcode,Label label){\r\n    if (mv != null) {\r\n        mv.visitJumpInsn(opcode, label);\r\n    }\r\n}"
}, {
	"Path": "view.jme.MyParticleEmitter.isSelectRandomImage",
	"Comment": "returns true if every particle spawned should get a randomimage.",
	"Method": "boolean isSelectRandomImage(){\r\n    return selectRandomImage;\r\n}"
}, {
	"Path": "org.openhab.binding.kodi.internal.handler.KodiHandler.waitForState",
	"Comment": "wait for the player state so that we know when the notification has started or finished playing",
	"Method": "boolean waitForState(KodiState state){\r\n    int timeoutMaxCount = getConfigAs(KodiConfig.class).getNotificationTimeout().intValue(), timeoutCount = 0;\r\n    logger.trace(\"Waiting up to {} ms for state '{}' to be set ...\", timeoutMaxCount * 100, state);\r\n    while (!state.equals(connection.getState()) && timeoutCount < timeoutMaxCount) {\r\n        try {\r\n            Thread.sleep(100);\r\n        } catch (InterruptedException e) {\r\n            break;\r\n        }\r\n        timeoutCount++;\r\n    }\r\n    return checkForTimeout(timeoutCount, timeoutMaxCount, \"state to '\" + state.toString() + \"' be set\");\r\n}"
}, {
	"Path": "view.jme.MyParticleEmitter.setNumParticles2",
	"Comment": "set the maximum amount of particles thatcan exist at the same time with this emitter.calling this method many times is not recommended.",
	"Method": "void setNumParticles2(int numParticles){\r\n    particles = new Particle[numParticles];\r\n    for (int i = 0; i < numParticles; i++) {\r\n        particles[i] = new Particle();\r\n    }\r\n    particleMesh.initParticleData(this, particles.length);\r\n    particleMesh.setImagesXY(this.imagesX, this.imagesY);\r\n    firstUnUsed = 0;\r\n    lastUsed = -1;\r\n}"
}, {
	"Path": "org.mitre.util.JsonUtils.getAsArray",
	"Comment": "translate a set of strings to a json array, empty array returned as null",
	"Method": "JsonElement getAsArray(Set<String> value,JsonElement getAsArray,Set<String> value,boolean preserveEmpty){\r\n    if (!preserveEmpty && value != null && value.isEmpty()) {\r\n        return JsonNull.INSTANCE;\r\n    } else {\r\n        return gson.toJsonTree(value, new TypeToken<Set<String>>() {\r\n        }.getType());\r\n    }\r\n}"
}, {
	"Path": "app.StaticCamera.registerWithInput",
	"Comment": "registers the flybycamera to receive input events from the provideddispatcher.",
	"Method": "void registerWithInput(InputManager inputManager){\r\n    this.inputManager = inputManager;\r\n    String[] mappings = new String[] { // \"FLYCAM_ZoomOut\",\r\n    \"FLYCAM_Left\", // \"FLYCAM_ZoomOut\",\r\n    \"FLYCAM_Right\", // \"FLYCAM_ZoomOut\",\r\n    \"FLYCAM_Up\", \"FLYCAM_Down\", \"FLYCAM_RotateDrag\" };\r\n    inputManager.addMapping(\"FLYCAM_Left\", new MouseAxisTrigger(MouseInput.AXIS_X, true), new KeyTrigger(KeyInput.KEY_LEFT));\r\n    inputManager.addMapping(\"FLYCAM_Right\", new MouseAxisTrigger(MouseInput.AXIS_X, false), new KeyTrigger(KeyInput.KEY_RIGHT));\r\n    inputManager.addMapping(\"FLYCAM_Up\", new MouseAxisTrigger(MouseInput.AXIS_Y, false), new KeyTrigger(KeyInput.KEY_UP));\r\n    inputManager.addMapping(\"FLYCAM_Down\", new MouseAxisTrigger(MouseInput.AXIS_Y, true), new KeyTrigger(KeyInput.KEY_DOWN));\r\n    inputManager.addMapping(\"FLYCAM_RotateDrag\", new MouseButtonTrigger(MouseInput.BUTTON_LEFT));\r\n    inputManager.addListener(this, mappings);\r\n    inputManager.setCursorVisible(dragToRotate);\r\n    Joystick[] joysticks = inputManager.getJoysticks();\r\n    if (joysticks != null && joysticks.length > 0) {\r\n        Joystick joystick = joysticks[0];\r\n        joystick.assignAxis(\"FLYCAM_Right\", \"FLYCAM_Left\", joystick.getXAxisIndex());\r\n        joystick.assignAxis(\"FLYCAM_Down\", \"FLYCAM_Up\", joystick.getYAxisIndex());\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.innogysmarthome.internal.client.entity.event.Event.getLinkId",
	"Comment": "returns the id of the link or null, if there is no link or the link does not have an id.",
	"Method": "String getLinkId(){\r\n    String linkType = getLinkType();\r\n    if (linkType != null && !linkType.equals(Link.LINK_TYPE_UNKNOWN) && !linkType.equals(Link.LINK_TYPE_SHC)) {\r\n        String linkValue = getLink().getValue();\r\n        if (linkValue != null) {\r\n            return linkValue.replace(linkType, \"\");\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openhab.binding.opensprinkler.internal.discovery.OpenSprinklerDiscoveryService.submitDiscoveryResults",
	"Comment": "create a new thing with an ip address given. uses default port and password.",
	"Method": "void submitDiscoveryResults(String ip){\r\n    ThingUID uid = new ThingUID(OPENSPRINKLER_THING, ip.replace('.', '_'));\r\n    HashMap<String, Object> properties = new HashMap();\r\n    properties.put(\"hostname\", ip);\r\n    properties.put(\"port\", DEFAULT_API_PORT);\r\n    properties.put(\"password\", DEFAULT_ADMIN_PASSWORD);\r\n    properties.put(\"refresh\", DEFAULT_REFRESH_RATE);\r\n    thingDiscovered(DiscoveryResultBuilder.create(uid).withProperties(properties).withLabel(\"OpenSprinkler\").build());\r\n}"
}, {
	"Path": "org.openhab.binding.irtrans.internal.IrCommand.matches",
	"Comment": "matches two ircommands commands match if they have the same remote andthe same command",
	"Method": "boolean matches(IrCommand anotherCommand){\r\n    return (matchRemote(anotherCommand) && matchCommand(anotherCommand));\r\n}"
}, {
	"Path": "org.openhab.binding.gardena.internal.handler.GardenaThingHandler.updateStatus",
	"Comment": "updates the thing status based on the gardena device status.",
	"Method": "void updateStatus(Device device){\r\n    String connectionStatus = \"\";\r\n    try {\r\n        connectionStatus = device.getAbility(ABILITY_RADIO).getProperty(PROPERTY_CONNECTION_STATUS).getValueAsString();\r\n    } catch (GardenaException ex) {\r\n    }\r\n    boolean isUnreach = PROPERTY_CONNECTION_STATUS_UNREACH_VALUE.equals(connectionStatus);\r\n    ThingStatus oldStatus = thing.getStatus();\r\n    ThingStatus newStatus = ThingStatus.ONLINE;\r\n    ThingStatusDetail newDetail = ThingStatusDetail.NONE;\r\n    if (isUnreach) {\r\n        newStatus = ThingStatus.OFFLINE;\r\n        newDetail = ThingStatusDetail.COMMUNICATION_ERROR;\r\n    } else if (!device.isConfigurationSynchronized()) {\r\n        newStatus = thing.getStatus();\r\n        newDetail = ThingStatusDetail.CONFIGURATION_PENDING;\r\n    }\r\n    if (oldStatus != newStatus || thing.getStatusInfo().getStatusDetail() != newDetail) {\r\n        updateStatus(newStatus, newDetail);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.neeo.internal.handler.NeeoBrainHandler.initializeTask",
	"Comment": "initializes the bridge by connecting to the configuration ip address and parsing the results. properties will beset and the thing will go online.",
	"Method": "void initializeTask(){\r\n    final Lock writerLock = stateLock.writeLock();\r\n    writerLock.lock();\r\n    try {\r\n        NeeoUtil.checkInterrupt();\r\n        final NeeoBrainConfig config = getBrainConfig();\r\n        final String ipAddress = config.getIpAddress();\r\n        if (ipAddress == null || StringUtils.isEmpty(ipAddress)) {\r\n            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Brain IP Address must be specified\");\r\n            return;\r\n        }\r\n        final NeeoBrainApi api = new NeeoBrainApi(ipAddress);\r\n        final NeeoBrain brain = api.getBrain();\r\n        final String brainId = getNeeoBrainId();\r\n        NeeoUtil.checkInterrupt();\r\n        neeoBrainApi = api;\r\n        final Map<String, String> properties = new HashMap();\r\n        addProperty(properties, \"Name\", brain.getName());\r\n        addProperty(properties, \"Version\", brain.getVersion());\r\n        addProperty(properties, \"Label\", brain.getLabel());\r\n        addProperty(properties, \"Is Configured\", String.valueOf(brain.isConfigured()));\r\n        addProperty(properties, \"Key\", brain.getKey());\r\n        addProperty(properties, \"AirKey\", brain.getAirkey());\r\n        addProperty(properties, \"Last Change\", String.valueOf(brain.getLastChange()));\r\n        updateProperties(properties);\r\n        if (config.isEnableForwardActions()) {\r\n            NeeoUtil.checkInterrupt();\r\n            forwardActionServlet = new NeeoForwardActionsServlet(scheduler, new NeeoForwardActionsServlet.Callback() {\r\n                @Override\r\n                public void post(String json) {\r\n                    triggerChannel(NeeoConstants.CHANNEL_BRAIN_FOWARDACTIONS, json);\r\n                    final NeeoAction action = gson.fromJson(json, NeeoAction.class);\r\n                    for (final Thing child : getThing().getThings()) {\r\n                        final ThingHandler th = child.getHandler();\r\n                        if (th instanceof NeeoRoomHandler) {\r\n                            ((NeeoRoomHandler) th).processAction(action);\r\n                        }\r\n                    }\r\n                }\r\n            }, config.getForwardChain());\r\n            NeeoUtil.checkInterrupt();\r\n            try {\r\n                servletPath = NeeoConstants.WEBAPP_FORWARDACTIONS.replace(\"{brainid}\", brainId);\r\n                httpService.registerServlet(servletPath, forwardActionServlet, new Hashtable(), httpService.createDefaultHttpContext());\r\n                final URL callbackURL = createCallbackUrl(brainId, config);\r\n                if (callbackURL == null) {\r\n                    logger.debug(\"Unable to create a callback URL because there is no primary address specified (please set the primary address in the configuration)\");\r\n                } else {\r\n                    final URL url = new URL(callbackURL, servletPath);\r\n                    api.registerForwardActions(url);\r\n                }\r\n            } catch (NamespaceException | ServletException e) {\r\n                logger.debug(\"Error registering forward actions to {}: {}\", servletPath, e.getMessage(), e);\r\n            }\r\n        }\r\n        NeeoUtil.checkInterrupt();\r\n        updateStatus(ThingStatus.ONLINE);\r\n        NeeoUtil.checkInterrupt();\r\n        if (config.getCheckStatusInterval() > 0) {\r\n            NeeoUtil.cancel(checkStatus.getAndSet(scheduler.scheduleWithFixedDelay(() -> {\r\n                try {\r\n                    NeeoUtil.checkInterrupt();\r\n                    checkStatus(ipAddress);\r\n                } catch (InterruptedException e) {\r\n                }\r\n            }, config.getCheckStatusInterval(), config.getCheckStatusInterval(), TimeUnit.SECONDS)));\r\n        }\r\n    } catch (IOException e) {\r\n        logger.debug(\"Exception occurred connecting to brain: {}\", e.getMessage(), e);\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Exception occurred connecting to brain: \" + e.getMessage());\r\n    } catch (InterruptedException e) {\r\n        logger.debug(\"Initializtion was interrupted\", e);\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.HANDLER_INITIALIZING_ERROR, \"Initialization was interrupted\");\r\n    } finally {\r\n        writerLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.neeo.internal.handler.NeeoBrainHandler.initializeTask",
	"Comment": "initializes the bridge by connecting to the configuration ip address and parsing the results. properties will beset and the thing will go online.",
	"Method": "void initializeTask(){\r\n    triggerChannel(NeeoConstants.CHANNEL_BRAIN_FOWARDACTIONS, json);\r\n    final NeeoAction action = gson.fromJson(json, NeeoAction.class);\r\n    for (final Thing child : getThing().getThings()) {\r\n        final ThingHandler th = child.getHandler();\r\n        if (th instanceof NeeoRoomHandler) {\r\n            ((NeeoRoomHandler) th).processAction(action);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.protocol.NikoHomeControlCommunication.readMessage",
	"Comment": "method that interprets all feedback from niko home control and calls appropriate handling methods.",
	"Method": "void readMessage(String nhcMessage){\r\n    logger.debug(\"Niko Home Control: received json {} on thread {}\", nhcMessage, Thread.currentThread().getId());\r\n    try {\r\n        NhcMessageBase nhcMessageGson = this.gsonIn.fromJson(nhcMessage, NhcMessageBase.class);\r\n        String cmd = nhcMessageGson.getCmd();\r\n        String event = nhcMessageGson.getEvent();\r\n        if (\"systeminfo\".equals(cmd)) {\r\n            cmdSystemInfo(((NhcMessageMap) nhcMessageGson).getData());\r\n        } else if (\"startevents\".equals(cmd)) {\r\n            cmdStartEvents(((NhcMessageMap) nhcMessageGson).getData());\r\n        } else if (\"listlocations\".equals(cmd)) {\r\n            cmdListLocations(((NhcMessageListMap) nhcMessageGson).getData());\r\n        } else if (\"listactions\".equals(cmd)) {\r\n            cmdListActions(((NhcMessageListMap) nhcMessageGson).getData());\r\n        } else if ((\"listthermostat\").equals(cmd)) {\r\n            cmdListThermostat(((NhcMessageListMap) nhcMessageGson).getData());\r\n        } else if (\"executeactions\".equals(cmd)) {\r\n            cmdExecuteActions(((NhcMessageMap) nhcMessageGson).getData());\r\n        } else if (\"executethermostat\".equals(cmd)) {\r\n            cmdExecuteThermostat(((NhcMessageMap) nhcMessageGson).getData());\r\n        } else if (\"listactions\".equals(event)) {\r\n            eventListActions(((NhcMessageListMap) nhcMessageGson).getData());\r\n        } else if (\"listthermostat\".equals(event)) {\r\n            eventListThermostat(((NhcMessageListMap) nhcMessageGson).getData());\r\n        } else if (\"getalarms\".equals(event)) {\r\n            eventGetAlarms(((NhcMessageMap) nhcMessageGson).getData());\r\n        } else {\r\n            logger.debug(\"Niko Home Control: not acted on json {}\", nhcMessage);\r\n        }\r\n    } catch (JsonParseException e) {\r\n        logger.debug(\"Niko Home Control: not acted on unsupported json {}\", nhcMessage);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.lametrictime.internal.LaMetricTimeHandlerFactory.unregisterAppDiscoveryService",
	"Comment": "unregister the given device handler from participating in discovery of new apps.",
	"Method": "void unregisterAppDiscoveryService(LaMetricTimeHandler deviceHandler){\r\n    ThingUID thingUID = deviceHandler.getThing().getUID();\r\n    ServiceRegistration<?> serviceReg = discoveryServiceReg.remove(thingUID);\r\n    if (serviceReg != null) {\r\n        logger.debug(\"Unregistering app discovery service\");\r\n        serviceReg.unregister();\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassWriter.newConstItem",
	"Comment": "adds a number or string constant to the constant pool of the class beingbuild. does nothing if the constant pool already contains a similar item.",
	"Method": "Item newConstItem(Object cst){\r\n    if (cst instanceof Integer) {\r\n        int val = ((Integer) cst).intValue();\r\n        return newInteger(val);\r\n    } else if (cst instanceof Byte) {\r\n        int val = ((Byte) cst).intValue();\r\n        return newInteger(val);\r\n    } else if (cst instanceof Character) {\r\n        int val = ((Character) cst).charValue();\r\n        return newInteger(val);\r\n    } else if (cst instanceof Short) {\r\n        int val = ((Short) cst).intValue();\r\n        return newInteger(val);\r\n    } else if (cst instanceof Boolean) {\r\n        int val = ((Boolean) cst).booleanValue() ? 1 : 0;\r\n        return newInteger(val);\r\n    } else if (cst instanceof Float) {\r\n        float val = ((Float) cst).floatValue();\r\n        return newFloat(val);\r\n    } else if (cst instanceof Long) {\r\n        long val = ((Long) cst).longValue();\r\n        return newLong(val);\r\n    } else if (cst instanceof Double) {\r\n        double val = ((Double) cst).doubleValue();\r\n        return newDouble(val);\r\n    } else if (cst instanceof String) {\r\n        return newString((String) cst);\r\n    } else if (cst instanceof Type) {\r\n        Type t = (Type) cst;\r\n        int s = t.getSort();\r\n        if (s == Type.OBJECT) {\r\n            return newClassItem(t.getInternalName());\r\n        } else if (s == Type.METHOD) {\r\n            return newMethodTypeItem(t.getDescriptor());\r\n        } else {\r\n            return newClassItem(t.getDescriptor());\r\n        }\r\n    } else if (cst instanceof Handle) {\r\n        Handle h = (Handle) cst;\r\n        return newHandleItem(h.tag, h.owner, h.name, h.desc);\r\n    } else {\r\n        throw new IllegalArgumentException(\"value \" + cst);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.innogysmarthome.internal.client.entity.capability.Capability.hasState",
	"Comment": "returns, if the capability has a state. not all capabilities have a state.",
	"Method": "boolean hasState(){\r\n    return capabilityState != null;\r\n}"
}, {
	"Path": "org.openhab.binding.neeo.internal.handler.NeeoDeviceHandler.refreshChannel",
	"Comment": "refresh the specified channel section, key and id using the specified protocol",
	"Method": "void refreshChannel(NeeoDeviceProtocol protocol,String groupId,String channelId,String channelKey){\r\n    Objects.requireNonNull(protocol, \"protocol cannot be null\");\r\n    NeeoUtil.requireNotEmpty(groupId, \"groupId must not be empty\");\r\n    NeeoUtil.requireNotEmpty(channelId, \"channelId must not be empty\");\r\n    NeeoUtil.requireNotEmpty(channelKey, \"channelKey must not be empty\");\r\n    switch(groupId) {\r\n        case NeeoConstants.DEVICE_GROUP_MACROS_ID:\r\n            switch(channelId) {\r\n                case NeeoConstants.DEVICE_CHANNEL_STATUS:\r\n                    protocol.refreshMacroStatus(channelKey);\r\n                    break;\r\n            }\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassWriter.toByteArray",
	"Comment": "returns the bytecode of the class that was build with this class writer.",
	"Method": "byte[] toByteArray(){\r\n    if (index > 0xFFFF) {\r\n        throw new RuntimeException(\"Class file too large!\");\r\n    }\r\n    int size = 24 + 2 * interfaceCount;\r\n    int nbFields = 0;\r\n    FieldWriter fb = firstField;\r\n    while (fb != null) {\r\n        ++nbFields;\r\n        size += fb.getSize();\r\n        fb = (FieldWriter) fb.fv;\r\n    }\r\n    int nbMethods = 0;\r\n    MethodWriter mb = firstMethod;\r\n    while (mb != null) {\r\n        ++nbMethods;\r\n        size += mb.getSize();\r\n        mb = (MethodWriter) mb.mv;\r\n    }\r\n    int attributeCount = 0;\r\n    if (bootstrapMethods != null) {\r\n        ++attributeCount;\r\n        size += 8 + bootstrapMethods.length;\r\n        newUTF8(\"BootstrapMethods\");\r\n    }\r\n    if (ClassReader.SIGNATURES && signature != 0) {\r\n        ++attributeCount;\r\n        size += 8;\r\n        newUTF8(\"Signature\");\r\n    }\r\n    if (sourceFile != 0) {\r\n        ++attributeCount;\r\n        size += 8;\r\n        newUTF8(\"SourceFile\");\r\n    }\r\n    if (sourceDebug != null) {\r\n        ++attributeCount;\r\n        size += sourceDebug.length + 4;\r\n        newUTF8(\"SourceDebugExtension\");\r\n    }\r\n    if (enclosingMethodOwner != 0) {\r\n        ++attributeCount;\r\n        size += 10;\r\n        newUTF8(\"EnclosingMethod\");\r\n    }\r\n    if ((access & Opcodes.ACC_DEPRECATED) != 0) {\r\n        ++attributeCount;\r\n        size += 6;\r\n        newUTF8(\"Deprecated\");\r\n    }\r\n    if ((access & Opcodes.ACC_SYNTHETIC) != 0) {\r\n        if ((version & 0xFFFF) < Opcodes.V1_5 || (access & ACC_SYNTHETIC_ATTRIBUTE) != 0) {\r\n            ++attributeCount;\r\n            size += 6;\r\n            newUTF8(\"Synthetic\");\r\n        }\r\n    }\r\n    if (innerClasses != null) {\r\n        ++attributeCount;\r\n        size += 8 + innerClasses.length;\r\n        newUTF8(\"InnerClasses\");\r\n    }\r\n    if (ClassReader.ANNOTATIONS && anns != null) {\r\n        ++attributeCount;\r\n        size += 8 + anns.getSize();\r\n        newUTF8(\"RuntimeVisibleAnnotations\");\r\n    }\r\n    if (ClassReader.ANNOTATIONS && ianns != null) {\r\n        ++attributeCount;\r\n        size += 8 + ianns.getSize();\r\n        newUTF8(\"RuntimeInvisibleAnnotations\");\r\n    }\r\n    if (attrs != null) {\r\n        attributeCount += attrs.getCount();\r\n        size += attrs.getSize(this, null, 0, -1, -1);\r\n    }\r\n    size += pool.length;\r\n    ByteVector out = new ByteVector(size);\r\n    out.putInt(0xCAFEBABE).putInt(version);\r\n    out.putShort(index).putByteArray(pool.data, 0, pool.length);\r\n    int mask = Opcodes.ACC_DEPRECATED | ACC_SYNTHETIC_ATTRIBUTE | ((access & ACC_SYNTHETIC_ATTRIBUTE) / TO_ACC_SYNTHETIC);\r\n    out.putShort(access & ~mask).putShort(name).putShort(superName);\r\n    out.putShort(interfaceCount);\r\n    for (int i = 0; i < interfaceCount; ++i) {\r\n        out.putShort(interfaces[i]);\r\n    }\r\n    out.putShort(nbFields);\r\n    fb = firstField;\r\n    while (fb != null) {\r\n        fb.put(out);\r\n        fb = (FieldWriter) fb.fv;\r\n    }\r\n    out.putShort(nbMethods);\r\n    mb = firstMethod;\r\n    while (mb != null) {\r\n        mb.put(out);\r\n        mb = (MethodWriter) mb.mv;\r\n    }\r\n    out.putShort(attributeCount);\r\n    if (bootstrapMethods != null) {\r\n        out.putShort(newUTF8(\"BootstrapMethods\"));\r\n        out.putInt(bootstrapMethods.length + 2).putShort(bootstrapMethodsCount);\r\n        out.putByteArray(bootstrapMethods.data, 0, bootstrapMethods.length);\r\n    }\r\n    if (ClassReader.SIGNATURES && signature != 0) {\r\n        out.putShort(newUTF8(\"Signature\")).putInt(2).putShort(signature);\r\n    }\r\n    if (sourceFile != 0) {\r\n        out.putShort(newUTF8(\"SourceFile\")).putInt(2).putShort(sourceFile);\r\n    }\r\n    if (sourceDebug != null) {\r\n        int len = sourceDebug.length - 2;\r\n        out.putShort(newUTF8(\"SourceDebugExtension\")).putInt(len);\r\n        out.putByteArray(sourceDebug.data, 2, len);\r\n    }\r\n    if (enclosingMethodOwner != 0) {\r\n        out.putShort(newUTF8(\"EnclosingMethod\")).putInt(4);\r\n        out.putShort(enclosingMethodOwner).putShort(enclosingMethod);\r\n    }\r\n    if ((access & Opcodes.ACC_DEPRECATED) != 0) {\r\n        out.putShort(newUTF8(\"Deprecated\")).putInt(0);\r\n    }\r\n    if ((access & Opcodes.ACC_SYNTHETIC) != 0) {\r\n        if ((version & 0xFFFF) < Opcodes.V1_5 || (access & ACC_SYNTHETIC_ATTRIBUTE) != 0) {\r\n            out.putShort(newUTF8(\"Synthetic\")).putInt(0);\r\n        }\r\n    }\r\n    if (innerClasses != null) {\r\n        out.putShort(newUTF8(\"InnerClasses\"));\r\n        out.putInt(innerClasses.length + 2).putShort(innerClassesCount);\r\n        out.putByteArray(innerClasses.data, 0, innerClasses.length);\r\n    }\r\n    if (ClassReader.ANNOTATIONS && anns != null) {\r\n        out.putShort(newUTF8(\"RuntimeVisibleAnnotations\"));\r\n        anns.put(out);\r\n    }\r\n    if (ClassReader.ANNOTATIONS && ianns != null) {\r\n        out.putShort(newUTF8(\"RuntimeInvisibleAnnotations\"));\r\n        ianns.put(out);\r\n    }\r\n    if (attrs != null) {\r\n        attrs.put(this, null, 0, -1, -1, out);\r\n    }\r\n    if (invalidFrames) {\r\n        anns = null;\r\n        ianns = null;\r\n        attrs = null;\r\n        innerClassesCount = 0;\r\n        innerClasses = null;\r\n        bootstrapMethodsCount = 0;\r\n        bootstrapMethods = null;\r\n        firstField = null;\r\n        lastField = null;\r\n        firstMethod = null;\r\n        lastMethod = null;\r\n        computeMaxs = false;\r\n        computeFrames = true;\r\n        invalidFrames = false;\r\n        new ClassReader(out.data).accept(this, ClassReader.SKIP_FRAMES);\r\n        return toByteArray();\r\n    }\r\n    return out.data;\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.protocol.NikoHomeControlCommunication.getThermostats",
	"Comment": "return all thermostats in the niko home control controller.",
	"Method": "Map<Integer, NhcThermostat> getThermostats(){\r\n    return this.thermostats;\r\n}"
}, {
	"Path": "org.mitre.oauth2.model.OAuth2AccessTokenEntity.setIdToken",
	"Comment": "add the id token to the additionalinformation map for a token response.",
	"Method": "void setIdToken(JWT idToken){\r\n    if (idToken != null) {\r\n        additionalInformation.put(ID_TOKEN_FIELD_NAME, idToken.serialize());\r\n    }\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.test.SmokeTest.testRegularReadEvery150msWithCoil",
	"Comment": "testing regular polling of coilsamount of requests is timed, and average poll period is checked",
	"Method": "void testRegularReadEvery150msWithCoil(){\r\n    generateData();\r\n    ModbusSlaveEndpoint endpoint = getEndpoint();\r\n    AtomicInteger unexpectedCount = new AtomicInteger();\r\n    CountDownLatch callbackCalled = new CountDownLatch(5);\r\n    AtomicInteger dataReceived = new AtomicInteger();\r\n    BasicPollTaskImpl task = new BasicPollTaskImpl(endpoint, new BasicModbusReadRequestBlueprint(SLAVE_UNIT_ID, ModbusReadFunctionCode.READ_COILS, 1, 15, 1), new ModbusReadCallback() {\r\n        @Override\r\n        public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\r\n            unexpectedCount.incrementAndGet();\r\n            callbackCalled.countDown();\r\n        }\r\n        @Override\r\n        public void onError(ModbusReadRequestBlueprint request, Exception error) {\r\n            unexpectedCount.incrementAndGet();\r\n            callbackCalled.countDown();\r\n        }\r\n        @Override\r\n        public void onBits(ModbusReadRequestBlueprint request, BitArray bits) {\r\n            dataReceived.incrementAndGet();\r\n            try {\r\n                assertThat(bits.size(), is(equalTo(15)));\r\n                testCoilValues(bits, 1);\r\n            } catch (AssertionError e) {\r\n                unexpectedCount.incrementAndGet();\r\n            }\r\n            callbackCalled.countDown();\r\n        }\r\n    });\r\n    long start = System.currentTimeMillis();\r\n    modbusManager.registerRegularPoll(task, 150, 0);\r\n    callbackCalled.await(5, TimeUnit.SECONDS);\r\n    long end = System.currentTimeMillis();\r\n    assertPollDetails(unexpectedCount, dataReceived, start, end, 145, 500);\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.test.SmokeTest.testRegularReadEvery150msWithCoil",
	"Comment": "testing regular polling of coilsamount of requests is timed, and average poll period is checked",
	"Method": "void testRegularReadEvery150msWithCoil(){\r\n    unexpectedCount.incrementAndGet();\r\n    callbackCalled.countDown();\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.test.SmokeTest.testRegularReadEvery150msWithCoil",
	"Comment": "testing regular polling of coilsamount of requests is timed, and average poll period is checked",
	"Method": "void testRegularReadEvery150msWithCoil(){\r\n    unexpectedCount.incrementAndGet();\r\n    callbackCalled.countDown();\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.test.SmokeTest.testRegularReadEvery150msWithCoil",
	"Comment": "testing regular polling of coilsamount of requests is timed, and average poll period is checked",
	"Method": "void testRegularReadEvery150msWithCoil(){\r\n    dataReceived.incrementAndGet();\r\n    try {\r\n        assertThat(bits.size(), is(equalTo(15)));\r\n        testCoilValues(bits, 1);\r\n    } catch (AssertionError e) {\r\n        unexpectedCount.incrementAndGet();\r\n    }\r\n    callbackCalled.countDown();\r\n}"
}, {
	"Path": "org.openhab.binding.meteostick.internal.handler.MeteostickBridgeHandler.connectPort",
	"Comment": "connects to the comm port and starts send and receive threads.",
	"Method": "boolean connectPort(String serialPortName){\r\n    logger.info(\"MeteoStick Connecting to serial port {}\", serialPortName);\r\n    boolean success = false;\r\n    try {\r\n        CommPortIdentifier portIdentifier = CommPortIdentifier.getPortIdentifier(serialPortName);\r\n        CommPort commPort = portIdentifier.open(\"org.openhab.binding.meteostick\", 2000);\r\n        serialPort = (SerialPort) commPort;\r\n        serialPort.setSerialPortParams(115200, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\r\n        serialPort.enableReceiveThreshold(1);\r\n        serialPort.enableReceiveTimeout(RECEIVE_TIMEOUT);\r\n        receiveThread = new ReceiveThread();\r\n        receiveThread.start();\r\n        serialPort.addEventListener(this.receiveThread);\r\n        serialPort.notifyOnDataAvailable(true);\r\n        logger.info(\"Serial port is initialized\");\r\n        success = true;\r\n    } catch (NoSuchPortException e) {\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Serial Error: Port \" + serialPortName + \" does not exist\");\r\n    } catch (PortInUseException e) {\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Serial Error: Port \" + serialPortName + \" in use\");\r\n    } catch (UnsupportedCommOperationException e) {\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Serial Error: Unsupported comm operation on port \" + serialPortName);\r\n    } catch (TooManyListenersException e) {\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Serial Error: Too many listeners on port \" + serialPortName);\r\n    }\r\n    return success;\r\n}"
}, {
	"Path": "org.openhab.binding.satel.internal.command.ReadEventCommand.getEventCode",
	"Comment": "returns event code the describes the event. it can be used to retrieve description text for this event.",
	"Method": "int getEventCode(){\r\n    return ((response.getPayload()[4] & 0x03) << 8) + (response.getPayload()[5] & 0xff);\r\n}"
}, {
	"Path": "org.openhab.binding.lgwebos.internal.BaseChannelHandler.getSubscription",
	"Comment": "creates a subscription instance for this device if subscription is supported.",
	"Method": "Optional<ServiceSubscription<T>> getSubscription(ConnectableDevice device,String channelId,LGWebOSHandler handler){\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxWsStateUpdateEvent.getSize",
	"Comment": "get size of binary representation of state update event in bytes, as received from loxone miniserverused to traverse a binary buffer with more than one state update events",
	"Method": "int getSize(){\r\n    return size;\r\n}"
}, {
	"Path": "org.openhab.voice.voicerss.internal.cloudapi.VoiceRSSCloudImpl.createURL",
	"Comment": "this method will create the url for the cloud service. the text will beuri encoded as it is part of the url.it is in package scope to be accessed by tests.",
	"Method": "String createURL(String apiKey,String text,String locale,String audioFormat){\r\n    String encodedMsg;\r\n    try {\r\n        encodedMsg = URLEncoder.encode(text, \"UTF-8\");\r\n    } catch (UnsupportedEncodingException ex) {\r\n        logger.error(\"UnsupportedEncodingException for UTF-8 MUST NEVER HAPPEN! Check your JVM configuration!\", ex);\r\n        encodedMsg = text;\r\n    }\r\n    return \"http://api.voicerss.org/?key=\" + apiKey + \"&hl=\" + locale + \"&c=\" + audioFormat + \"&f=44khz_16bit_mono&src=\" + encodedMsg;\r\n}"
}, {
	"Path": "org.openhab.binding.max.internal.message.MessageProcessor.reset",
	"Comment": "resets the current status and processed lines. should be used afterprocessing a message",
	"Method": "void reset(){\r\n    this.currentMessage = null;\r\n    receivedLines.clear();\r\n    currentMessageType = null;\r\n    numberOfRequiredLines = null;\r\n}"
}, {
	"Path": "com.github.shyiko.mysql.binlog.BinaryLogClientIntegrationTest.generateTime",
	"Comment": "checkstyle, please ignore parameternumber for the next line",
	"Method": "long generateTime(int year,int month,int day,int hour,int minute,int second,int millisecond){\r\n    Calendar instance = Calendar.getInstance();\r\n    instance.set(Calendar.YEAR, year);\r\n    instance.set(Calendar.MONTH, month - 1);\r\n    instance.set(Calendar.DAY_OF_MONTH, day);\r\n    instance.set(Calendar.HOUR_OF_DAY, hour);\r\n    instance.set(Calendar.MINUTE, minute);\r\n    instance.set(Calendar.SECOND, second);\r\n    instance.set(Calendar.MILLISECOND, millisecond);\r\n    return instance.getTimeInMillis();\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.handler.NikoHomeControlBridgeHandler.updateProperties",
	"Comment": "update bridge properties with properties returned from niko home control controller, so they can be made visiblein paperui.",
	"Method": "void updateProperties(){\r\n    Map<String, String> properties = new HashMap();\r\n    properties.put(\"softwareVersion\", this.nhcComm.getSystemInfo().getSwVersion());\r\n    properties.put(\"apiVersion\", this.nhcComm.getSystemInfo().getApi());\r\n    properties.put(\"language\", this.nhcComm.getSystemInfo().getLanguage());\r\n    properties.put(\"currency\", this.nhcComm.getSystemInfo().getCurrency());\r\n    properties.put(\"units\", this.nhcComm.getSystemInfo().getUnits());\r\n    properties.put(\"tzOffset\", this.nhcComm.getSystemInfo().getTz());\r\n    properties.put(\"dstOffset\", this.nhcComm.getSystemInfo().getDst());\r\n    properties.put(\"configDate\", this.nhcComm.getSystemInfo().getLastConfig());\r\n    properties.put(\"energyEraseDate\", this.nhcComm.getSystemInfo().getLastEnergyErase());\r\n    properties.put(\"connectionStartDate\", this.nhcComm.getSystemInfo().getTime());\r\n    thing.setProperties(properties);\r\n}"
}, {
	"Path": "org.openhab.binding.pioneeravr.internal.handler.AbstractAvrHandler.getZoneFromChannelUID",
	"Comment": "return the zone from the given channeluid.return 0 if the zone cannot be extracted from the channeluid.",
	"Method": "int getZoneFromChannelUID(String channelUID){\r\n    int zone = 0;\r\n    Matcher matcher = PioneerAvrBindingConstants.GROUP_CHANNEL_ZONE_PATTERN.matcher(channelUID);\r\n    if (matcher.find()) {\r\n        zone = Integer.valueOf(matcher.group(1));\r\n    }\r\n    return zone;\r\n}"
}, {
	"Path": "org.openhab.voice.marytts.internal.MaryTTSService.getAudioFormat",
	"Comment": "obtains an audioformat from a javax.sound.sampled.audioformat",
	"Method": "AudioFormat getAudioFormat(javax.sound.sampled.AudioFormat audioFormat){\r\n    String container = AudioFormat.CONTAINER_WAVE;\r\n    String codec = audioFormat.getEncoding().toString();\r\n    Boolean bigEndian = audioFormat.isBigEndian();\r\n    int frameSize = audioFormat.getFrameSize();\r\n    int bitsPerFrame = frameSize * 8;\r\n    Integer bitDepth = NOT_SPECIFIED == frameSize ? null : bitsPerFrame;\r\n    float frameRate = audioFormat.getFrameRate();\r\n    Integer bitRate = NOT_SPECIFIED == frameRate ? null : (int) frameRate * bitsPerFrame;\r\n    float sampleRate = audioFormat.getSampleRate();\r\n    Long frequency = NOT_SPECIFIED == sampleRate ? null : (long) sampleRate;\r\n    return new AudioFormat(container, codec, bigEndian, bitDepth, bitRate, frequency);\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2AuthorizationCodeService.createAuthorizationCode",
	"Comment": "generate a random authorization code and create an authorizationcodeentity,\twhich will be stored in the repository.",
	"Method": "String createAuthorizationCode(OAuth2Authentication authentication){\r\n    String code = generator.generate();\r\n    AuthenticationHolderEntity authHolder = new AuthenticationHolderEntity();\r\n    authHolder.setAuthentication(authentication);\r\n    authHolder = authenticationHolderRepository.save(authHolder);\r\n    Date expiration = new Date(System.currentTimeMillis() + (getAuthCodeExpirationSeconds() * 1000L));\r\n    AuthorizationCodeEntity entity = new AuthorizationCodeEntity(code, authHolder, expiration);\r\n    repository.save(entity);\r\n    return code;\r\n}"
}, {
	"Path": "org.mitre.jwt.signer.service.impl.SymmetricKeyJWTValidatorCacheService.getSymmetricValidtor",
	"Comment": "create a symmetric signing and validation service for the given client",
	"Method": "JWTSigningAndValidationService getSymmetricValidtor(ClientDetailsEntity client){\r\n    if (client == null) {\r\n        logger.error(\"Couldn't create symmetric validator for null client\");\r\n        return null;\r\n    }\r\n    if (Strings.isNullOrEmpty(client.getClientSecret())) {\r\n        logger.error(\"Couldn't create symmetric validator for client \" + client.getClientId() + \" without a client secret\");\r\n        return null;\r\n    }\r\n    try {\r\n        return validators.get(client.getClientSecret());\r\n    } catch (UncheckedExecutionException ue) {\r\n        logger.error(\"Problem loading client validator\", ue);\r\n        return null;\r\n    } catch (ExecutionException e) {\r\n        logger.error(\"Problem loading client validator\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.PresenceDetection.updateReachableValue",
	"Comment": "if the cached presencedetectionvalue has not expired yet, the cached versionis returned otherwise a new reachable presencedetectionvalue is created witha latency of 0.it is safe to call this method from multiple threads. the returned presencedetectionvaluemight be still be altered in other threads though.",
	"Method": "PresenceDetectionValue updateReachableValue(PresenceDetectionType type,double latency){\r\n    lastSeenInMS = System.currentTimeMillis();\r\n    PresenceDetectionValue v;\r\n    if (cache.isExpired()) {\r\n        v = new PresenceDetectionValue(destination.getHostAddress(), 0);\r\n    } else {\r\n        v = cache.getExpiredValue();\r\n    }\r\n    v.updateLatency(latency);\r\n    v.addType(type);\r\n    cache.setValue(v);\r\n    return v;\r\n}"
}, {
	"Path": "org.openhab.binding.opensprinkler.internal.discovery.OpenSprinklerDiscoveryService.getIpAddressScanList",
	"Comment": "provide a string list of all the ip addresses associated with the network interfaces onthis machine.",
	"Method": "List<String> getIpAddressScanList(){\r\n    List<String> results = new ArrayList();\r\n    InetAddress localHost = InetAddress.getLocalHost();\r\n    NetworkInterface networkInterface = NetworkInterface.getByInetAddress(localHost);\r\n    for (InterfaceAddress address : networkInterface.getInterfaceAddresses()) {\r\n        InetAddress ipAddress = address.getAddress();\r\n        String cidrSubnet = ipAddress.getHostAddress() + \"/\" + DISCOVERY_SUBNET_MASK;\r\n        if (ipAddress instanceof Inet4Address) {\r\n            logger.debug(\"Found interface IPv4 address to scan: {}\", cidrSubnet);\r\n            SubnetUtils utils = new SubnetUtils(cidrSubnet);\r\n            results.addAll(Arrays.asList(utils.getInfo().getAllAddresses()));\r\n        } else if (ipAddress instanceof Inet6Address) {\r\n            logger.debug(\"Found interface IPv6 address to scan: {}\", cidrSubnet);\r\n        } else {\r\n            logger.debug(\"Found interface unknown IP type address to scan: {}\", cidrSubnet);\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.openhab.binding.gpstracker.internal.message.MessageUtil.fromJson",
	"Comment": "parses json message into an object with type determined by message pattern.",
	"Method": "LocationMessage fromJson(String json){\r\n    for (String pattern : PATTERNS) {\r\n        Class<? extends LocationMessage> c = MESSAGE_TYPES.get(pattern);\r\n        if (json.matches(pattern)) {\r\n            return gson.fromJson(json, c);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openhab.ui.cometvisu.internal.util.SseUtil.shouldAsyncBlock",
	"Comment": "returns true if the current thread is processing an sse request thatshould block.",
	"Method": "boolean shouldAsyncBlock(){\r\n    return blockingSseEnabled.get().booleanValue();\r\n}"
}, {
	"Path": "org.openhab.binding.max.internal.command.UdpCubeCommand.setIpAddress",
	"Comment": "set the ip address to send the command to. the command will be send to the address and broadcasted over allactive interfaces",
	"Method": "void setIpAddress(String ipAddress){\r\n    this.ipAddress = ipAddress;\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.discovery.NetworkDiscoveryService.startScan",
	"Comment": "starts the discoverythread for each ip on each interface on the network",
	"Method": "void startScan(){\r\n    if (executorService != null) {\r\n        return;\r\n    }\r\n    removeOlderResults(getTimestampOfLastScan(), null);\r\n    logger.trace(\"Starting Network Device Discovery\");\r\n    final Set<String> networkIPs = networkUtils.getNetworkIPs(MAXIMUM_IPS_PER_INTERFACE);\r\n    executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors() * 2);\r\n    scannedIPcount = 0;\r\n    for (String ip : networkIPs) {\r\n        final PresenceDetection s = new PresenceDetection(this, 2000);\r\n        try {\r\n            s.setHostname(ip);\r\n        } catch (UnknownHostException unknownHostException) {\r\n            logger.trace(\"Skip IP that cannot be converted to a InetAddress\", unknownHostException);\r\n            continue;\r\n        }\r\n        s.setIOSDevice(true);\r\n        s.setUseDhcpSniffing(false);\r\n        s.setTimeout(PING_TIMEOUT_IN_MS);\r\n        s.setUseIcmpPing(true);\r\n        s.setUseArpPing(true, configuration.arpPingToolPath);\r\n        s.setServicePorts(tcp_service_ports);\r\n        executorService.execute(() -> {\r\n            Thread.currentThread().setName(\"Discovery thread \" + ip);\r\n            s.performPresenceDetection(true);\r\n            synchronized (scannedIPcount) {\r\n                scannedIPcount += 1;\r\n                if (scannedIPcount == networkIPs.size()) {\r\n                    logger.trace(\"Scan of {} IPs successful\", scannedIPcount);\r\n                    stopScan();\r\n                }\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.pioneeravr.internal.protocol.StreamAvrConnection.sendCommand",
	"Comment": "sends to command to the receiver. it does not wait for a reply.",
	"Method": "boolean sendCommand(AvrCommand ipControlCommand){\r\n    boolean isSent = false;\r\n    if (connect()) {\r\n        String command = ipControlCommand.getCommand();\r\n        try {\r\n            if (logger.isTraceEnabled()) {\r\n                logger.trace(\"Sending {} bytes: {}\", command.length(), HexUtils.bytesToHex(command.getBytes()));\r\n            }\r\n            outputStream.writeBytes(command);\r\n            outputStream.flush();\r\n            isSent = true;\r\n        } catch (IOException ioException) {\r\n            logger.error(\"Error occurred when sending command\", ioException);\r\n            close();\r\n        }\r\n        logger.debug(\"Command sent to AVR @{}: {}\", getConnectionName(), command);\r\n    }\r\n    return isSent;\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.protocol.xml.XMLUtils.getNodeOrFail",
	"Comment": "retrieves the child node according to the xpath expression.",
	"Method": "Node getNodeOrFail(Node root,String nodePath){\r\n    Node node = getNode(root, nodePath);\r\n    if (node == null) {\r\n        throw new ReceivedMessageParseException(nodePath + \" child in parent node missing!\");\r\n    }\r\n    return node;\r\n}"
}, {
	"Path": "geometry.geom2d.Line2D.intersect",
	"Comment": "check if an intersection point between this line and an other one exists.",
	"Method": "boolean intersect(Line2D other,boolean intersect,Circle2D circle){\r\n    LineCircleIntersector it = new LineCircleIntersector(this, circle);\r\n    return it.intersection.exist();\r\n}"
}, {
	"Path": "org.openhab.ui.cometvisu.internal.backend.ReadResource.registerItem",
	"Comment": "listens to state changes of the given item, if it is part of therequested items",
	"Method": "void registerItem(Item item){\r\n    if (item == null || items.containsKey(item) || !itemNames.contains(item.getName())) {\r\n        return;\r\n    }\r\n    if (item instanceof GenericItem) {\r\n        ((GenericItem) item).addStateChangeListener(stateEventListener);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.atlona.internal.pro3.AtlonaPro3PortocolHandler.login",
	"Comment": "attempts to log into the switch when prompted by the switch. please see code comments on the exact protocol forthis.",
	"Method": "String login(){\r\n    logger.debug(\"Logging into atlona switch\");\r\n    modelType = null;\r\n    version = null;\r\n    NoDispatchingCallback callback = new NoDispatchingCallback();\r\n    session.addListener(callback);\r\n    String response;\r\n    try {\r\n        response = callback.getResponse();\r\n        if (!response.equals(\"\")) {\r\n            logger.info(\"Altona protocol violation - didn't start with an inital empty response: '{}'\", response);\r\n        }\r\n    } catch (Exception e) {\r\n    }\r\n    session.sendCommand(NOTVALID_USER_OR_CMD);\r\n    response = callback.getResponse();\r\n    if (response.startsWith(RSP_FAILED)) {\r\n        logger.debug(\"Altona didn't require a login\");\r\n        postLogin();\r\n        return null;\r\n    }\r\n    response = callback.getResponse();\r\n    if (!response.equals(\"\")) {\r\n        logger.info(\"Altona protocol violation - didn't start with an inital empty response: '{}'\", response);\r\n    }\r\n    response = callback.getResponse();\r\n    if (response.equals(RSP_LOGIN)) {\r\n        if (config.getUserName() == null || config.getUserName().trim().length() == 0) {\r\n            return \"Atlona PRO3 has enabled Telnet/IP Login but no username was provided in the configuration.\";\r\n        }\r\n        session.sendCommand(config.getUserName());\r\n    } else {\r\n        return \"Altona protocol violation - wasn't initially a command failure or login prompt: \" + response;\r\n    }\r\n    response = callback.getResponse();\r\n    if (response.equals(\"\")) {\r\n        response = callback.getResponse();\r\n    }\r\n    if (!response.equals(RSP_PASSWORD)) {\r\n        if (response.equals(RSP_LOGIN)) {\r\n            return \"Username \" + config.getUserName() + \" is not a valid user on the atlona\";\r\n        }\r\n        return \"Altona protocol violation - invalid response to a login: \" + response;\r\n    }\r\n    if (config.getPassword() == null || config.getPassword().trim().length() == 0) {\r\n        return \"Atlona PRO3 has enabled Telnet/IP Login but no password was provided in the configuration.\";\r\n    }\r\n    session.sendCommand(config.getPassword());\r\n    response = callback.getResponse();\r\n    if (!response.equals(\"\")) {\r\n        logger.info(\"Altona protocol violation - not an empty response after password: '{}'\", response);\r\n    }\r\n    session.sendCommand(NOTVALID_USER_OR_CMD);\r\n    response = callback.getResponse();\r\n    if (response.startsWith(RSP_FAILED)) {\r\n        postLogin();\r\n        return null;\r\n    }\r\n    return \"Password was invalid - please check your atlona setup\";\r\n}"
}, {
	"Path": "org.openhab.binding.nest.test.NestTestHandlerFactory.removeHandler",
	"Comment": "removes the handler for the specific thing. this also handles disabling the discoveryservice when the bridge is removed.",
	"Method": "void removeHandler(ThingHandler thingHandler){\r\n    if (thingHandler instanceof NestBridgeHandler) {\r\n        ServiceRegistration<?> reg = discoveryService.get(thingHandler.getThing().getUID());\r\n        if (reg != null) {\r\n            NestDiscoveryService service = (NestDiscoveryService) bundleContext.getService(reg.getReference());\r\n            service.deactivate();\r\n            reg.unregister();\r\n            discoveryService.remove(thingHandler.getThing().getUID());\r\n        }\r\n    }\r\n    super.removeHandler(thingHandler);\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.KeyValue.fromArray",
	"Comment": "create tuple from array. array has to have exactly two elements.",
	"Method": "KeyValue<X, X> fromArray(X[] array){\r\n    if (array == null) {\r\n        throw new IllegalArgumentException(\"Array cannot be null\");\r\n    }\r\n    if (array.length != 2) {\r\n        throw new IllegalArgumentException(\"Array must have exactly 2 elements in order to create a KeyValue. Size is \" + array.length);\r\n    }\r\n    return new KeyValue<X, X>(array[0], array[1]);\r\n}"
}, {
	"Path": "org.openhab.binding.nest.internal.NestHandlerFactory.createHandler",
	"Comment": "creates a handler for the specific thing. this also creates the discovery servicewhen the bridge is created.",
	"Method": "ThingHandler createHandler(Thing thing){\r\n    ThingTypeUID thingTypeUID = thing.getThingTypeUID();\r\n    if (THING_TYPE_THERMOSTAT.equals(thingTypeUID)) {\r\n        return new NestThermostatHandler(thing);\r\n    }\r\n    if (THING_TYPE_CAMERA.equals(thingTypeUID)) {\r\n        return new NestCameraHandler(thing);\r\n    }\r\n    if (THING_TYPE_STRUCTURE.equals(thingTypeUID)) {\r\n        return new NestStructureHandler(thing);\r\n    }\r\n    if (THING_TYPE_SMOKE_DETECTOR.equals(thingTypeUID)) {\r\n        return new NestSmokeDetectorHandler(thing);\r\n    }\r\n    if (THING_TYPE_BRIDGE.equals(thingTypeUID)) {\r\n        NestBridgeHandler handler = new NestBridgeHandler((Bridge) thing);\r\n        NestDiscoveryService service = new NestDiscoveryService(handler);\r\n        service.activate();\r\n        discoveryService.put(handler.getThing().getUID(), bundleContext.registerService(DiscoveryService.class.getName(), service, new Hashtable()));\r\n        return handler;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openhab.binding.gardena.internal.GardenaSmartImpl.verifySession",
	"Comment": "verifies the gardena smart home session and reconnects if necessary.",
	"Method": "void verifySession(){\r\n    if (session == null || session.getCreated() + (config.getSessionTimeout() * 60000) <= System.currentTimeMillis()) {\r\n        logger.trace(\"(Re)logging in to Gardena Smart Home\");\r\n        session = executeRequest(HttpMethod.POST, URL_LOGIN, new GardenaConfigWrapper(config), SessionWrapper.class).getSession();\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.system.RioSystemProtocol.handleSystemNotification",
	"Comment": "handles any system notifications returned by the russound system",
	"Method": "void handleSystemNotification(Matcher m,String resp){\r\n    if (m == null) {\r\n        throw new IllegalArgumentException(\"m (matcher) cannot be null\");\r\n    }\r\n    if (m.groupCount() == 2) {\r\n        final String key = m.group(1).toLowerCase();\r\n        final String value = m.group(2);\r\n        switch(key) {\r\n            case SYS_LANG:\r\n                stateChanged(RioConstants.CHANNEL_SYSLANG, new StringType(value));\r\n                break;\r\n            case SYS_STATUS:\r\n                stateChanged(RioConstants.CHANNEL_SYSSTATUS, \"ON\".equals(value) ? OnOffType.ON : OnOffType.OFF);\r\n                break;\r\n            default:\r\n                logger.warn(\"Unknown system notification: '{}'\", resp);\r\n                break;\r\n        }\r\n    } else {\r\n        logger.warn(\"Invalid System Notification response: '{}'\", resp);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.ModbusBitUtilities.commandToRegisters",
	"Comment": "convert command to array of registers using a specific value type",
	"Method": "ModbusRegisterArray commandToRegisters(Command command,ModbusConstants.ValueType type){\r\n    DecimalType numericCommand;\r\n    if (command instanceof OnOffType || command instanceof OpenClosedType) {\r\n        numericCommand = translateCommand2Boolean(command).get() ? new DecimalType(BigDecimal.ONE) : DecimalType.ZERO;\r\n    } else if (command instanceof DecimalType) {\r\n        numericCommand = (DecimalType) command;\r\n    } else {\r\n        throw new NotImplementedException(String.format(\"Command '%s' of class '%s' cannot be converted to registers. Please use OnOffType, OpenClosedType, or DecimalType commands.\", command, command.getClass().getName()));\r\n    }\r\n    if (type.getBits() != 16 && type.getBits() != 32) {\r\n        throw new IllegalArgumentException(String.format(\"Illegal type=%s (bits=%d). Only 16bit and 32bit types are supported\", type, type.getBits()));\r\n    }\r\n    switch(type) {\r\n        case INT16:\r\n        case UINT16:\r\n            {\r\n                short shortValue = numericCommand.shortValue();\r\n                byte b1 = (byte) (shortValue >> 8);\r\n                byte b2 = (byte) shortValue;\r\n                ModbusRegister register = new BasicModbusRegister(b1, b2);\r\n                return new BasicModbusRegisterArray(new ModbusRegister[] { register });\r\n            }\r\n        case INT32:\r\n        case UINT32:\r\n            {\r\n                int intValue = numericCommand.intValue();\r\n                byte b1 = (byte) (intValue >> 24);\r\n                byte b2 = (byte) (intValue >> 16);\r\n                byte b3 = (byte) (intValue >> 8);\r\n                byte b4 = (byte) intValue;\r\n                ModbusRegister register = new BasicModbusRegister(b1, b2);\r\n                ModbusRegister register2 = new BasicModbusRegister(b3, b4);\r\n                return new BasicModbusRegisterArray(new ModbusRegister[] { register, register2 });\r\n            }\r\n        case INT32_SWAP:\r\n        case UINT32_SWAP:\r\n            {\r\n                int intValue = numericCommand.intValue();\r\n                byte b1 = (byte) (intValue >> 24);\r\n                byte b2 = (byte) (intValue >> 16);\r\n                byte b3 = (byte) (intValue >> 8);\r\n                byte b4 = (byte) intValue;\r\n                ModbusRegister register = new BasicModbusRegister(b3, b4);\r\n                ModbusRegister register2 = new BasicModbusRegister(b1, b2);\r\n                return new BasicModbusRegisterArray(new ModbusRegister[] { register, register2 });\r\n            }\r\n        case FLOAT32:\r\n            {\r\n                float floatValue = numericCommand.floatValue();\r\n                int intBits = Float.floatToIntBits(floatValue);\r\n                byte b1 = (byte) (intBits >> 24);\r\n                byte b2 = (byte) (intBits >> 16);\r\n                byte b3 = (byte) (intBits >> 8);\r\n                byte b4 = (byte) intBits;\r\n                ModbusRegister register = new BasicModbusRegister(b1, b2);\r\n                ModbusRegister register2 = new BasicModbusRegister(b3, b4);\r\n                return new BasicModbusRegisterArray(new ModbusRegister[] { register, register2 });\r\n            }\r\n        case FLOAT32_SWAP:\r\n            {\r\n                float floatValue = numericCommand.floatValue();\r\n                int intBits = Float.floatToIntBits(floatValue);\r\n                byte b1 = (byte) (intBits >> 24);\r\n                byte b2 = (byte) (intBits >> 16);\r\n                byte b3 = (byte) (intBits >> 8);\r\n                byte b4 = (byte) intBits;\r\n                ModbusRegister register = new BasicModbusRegister(b3, b4);\r\n                ModbusRegister register2 = new BasicModbusRegister(b1, b2);\r\n                return new BasicModbusRegisterArray(new ModbusRegister[] { register, register2 });\r\n            }\r\n        default:\r\n            throw new NotImplementedException(String.format(\"Illegal type=%s. Missing implementation for this type\", type));\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.Label.addReference",
	"Comment": "adds a forward reference to this label. this method must be called onlyfor a true forward reference, i.e. only if this label is not resolvedyet. for backward references, the offset of the reference can be, andmust be, computed and stored directly.",
	"Method": "void addReference(int sourcePosition,int referencePosition){\r\n    if (srcAndRefPositions == null) {\r\n        srcAndRefPositions = new int[6];\r\n    }\r\n    if (referenceCount >= srcAndRefPositions.length) {\r\n        int[] a = new int[srcAndRefPositions.length + 6];\r\n        System.arraycopy(srcAndRefPositions, 0, a, 0, srcAndRefPositions.length);\r\n        srcAndRefPositions = a;\r\n    }\r\n    srcAndRefPositions[referenceCount++] = sourcePosition;\r\n    srcAndRefPositions[referenceCount++] = referencePosition;\r\n}"
}, {
	"Path": "org.openhab.binding.tplinksmarthome.internal.Connection.sendCommand",
	"Comment": "sends the command, which is a json string, encrypted to the device and decrypts the json result and returns it",
	"Method": "String sendCommand(String command){\r\n    logger.trace(\"Executing command: {}\", command);\r\n    try (Socket socket = createSocket();\r\n        final OutputStream outputStream = socket.getOutputStream()) {\r\n        outputStream.write(CryptUtil.encryptWithLength(command));\r\n        String response = readReturnValue(socket);\r\n        logger.trace(\"Command response: {}\", response);\r\n        return response;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.utils.NetworkUtils.getNetworkIPs",
	"Comment": "takes the interfaceips and fetches every ip which can be assigned on their network",
	"Method": "Set<String> getNetworkIPs(int maximumPerInterface,Set<String> getNetworkIPs,Set<String> interfaceIPs,int maximumPerInterface){\r\n    LinkedHashSet<String> networkIPs = new LinkedHashSet();\r\n    for (String string : interfaceIPs) {\r\n        try {\r\n            SubnetUtils utils = new SubnetUtils(string);\r\n            String[] addresses = utils.getInfo().getAllAddresses();\r\n            int len = addresses.length;\r\n            if (maximumPerInterface != 0 && maximumPerInterface < len) {\r\n                len = maximumPerInterface;\r\n            }\r\n            for (int i = 0; i < len; i++) {\r\n                networkIPs.add(addresses[i]);\r\n            }\r\n        } catch (Exception ex) {\r\n        }\r\n    }\r\n    return networkIPs;\r\n}"
}, {
	"Path": "org.openhab.binding.logreader.internal.searchengine.SearchEngine.isMatching",
	"Comment": "check if data is matching to one of the provided search patterns.",
	"Method": "boolean isMatching(String data,boolean isMatching,List<Pattern> patterns,String data){\r\n    if (patterns != null) {\r\n        for (Pattern pattern : patterns) {\r\n            Matcher matcher = pattern.matcher(data);\r\n            if (matcher.find()) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassWriter.newFloat",
	"Comment": "adds a float to the constant pool of the class being build. does nothingif the constant pool already contains a similar item.",
	"Method": "Item newFloat(float value){\r\n    key.set(value);\r\n    Item result = get(key);\r\n    if (result == null) {\r\n        pool.putByte(FLOAT).putInt(key.intVal);\r\n        result = new Item(index++, key);\r\n        put(result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.openhab.binding.innogysmarthome.internal.handler.InnogyDeviceHandler.invertValueIfConfigured",
	"Comment": "returns the inverted value. currently only rollershutter channels are supported.",
	"Method": "int invertValueIfConfigured(String channelId,int value){\r\n    if (!CHANNEL_ROLLERSHUTTER.equals(channelId)) {\r\n        logger.debug(\"Channel {} cannot be inverted.\", channelId);\r\n        return value;\r\n    }\r\n    Channel channel = getThing().getChannel(channelId);\r\n    if (channel == null) {\r\n        logger.debug(\"Channel {} was null! Value not inverted.\", channelId);\r\n        return value;\r\n    }\r\n    return 100 - value;\r\n}"
}, {
	"Path": "nginx.clojure.asm.MethodVisitor.visitMaxs",
	"Comment": "visits the maximum stack size and the maximum number of local variablesof the method.",
	"Method": "void visitMaxs(int maxStack,int maxLocals){\r\n    if (mv != null) {\r\n        mv.visitMaxs(maxStack, maxLocals);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.solaredge.internal.AtomicReferenceTrait.cancelJobReference",
	"Comment": "updates a job reference to null and cancels any existing job which might be assigned to the reference.",
	"Method": "void cancelJobReference(AtomicReference<@Nullable Future<?>> jobReference){\r\n    cancelJob(jobReference.getAndSet(null));\r\n}"
}, {
	"Path": "org.mitre.openid.connect.web.UserInfoEndpoint.getInfo",
	"Comment": "get information about the user as specified in the accesstoken included in this request",
	"Method": "String getInfo(String claimsRequestJsonString,String acceptHeader,OAuth2Authentication auth,Model model){\r\n    if (auth == null) {\r\n        logger.error(\"getInfo failed; no principal. Requester is not authorized.\");\r\n        model.addAttribute(HttpCodeView.CODE, HttpStatus.FORBIDDEN);\r\n        return HttpCodeView.VIEWNAME;\r\n    }\r\n    String username = auth.getName();\r\n    UserInfo userInfo = userInfoService.getByUsernameAndClientId(username, auth.getOAuth2Request().getClientId());\r\n    if (userInfo == null) {\r\n        logger.error(\"getInfo failed; user not found: \" + username);\r\n        model.addAttribute(HttpCodeView.CODE, HttpStatus.NOT_FOUND);\r\n        return HttpCodeView.VIEWNAME;\r\n    }\r\n    model.addAttribute(UserInfoView.SCOPE, auth.getOAuth2Request().getScope());\r\n    model.addAttribute(UserInfoView.AUTHORIZED_CLAIMS, auth.getOAuth2Request().getExtensions().get(\"claims\"));\r\n    if (!Strings.isNullOrEmpty(claimsRequestJsonString)) {\r\n        model.addAttribute(UserInfoView.REQUESTED_CLAIMS, claimsRequestJsonString);\r\n    }\r\n    model.addAttribute(UserInfoView.USER_INFO, userInfo);\r\n    ClientDetailsEntity client = clientService.loadClientByClientId(auth.getOAuth2Request().getClientId());\r\n    model.addAttribute(UserInfoJWTView.CLIENT, client);\r\n    List<MediaType> mediaTypes = MediaType.parseMediaTypes(acceptHeader);\r\n    MediaType.sortBySpecificityAndQuality(mediaTypes);\r\n    if (client.getUserInfoSignedResponseAlg() != null || client.getUserInfoEncryptedResponseAlg() != null || client.getUserInfoEncryptedResponseEnc() != null) {\r\n        for (MediaType m : mediaTypes) {\r\n            if (!m.isWildcardType() && m.isCompatibleWith(UserInfoJWTView.JOSE_MEDIA_TYPE)) {\r\n                return UserInfoJWTView.VIEWNAME;\r\n            } else if (!m.isWildcardType() && m.isCompatibleWith(MediaType.APPLICATION_JSON)) {\r\n                return UserInfoView.VIEWNAME;\r\n            }\r\n        }\r\n        return UserInfoJWTView.VIEWNAME;\r\n    } else {\r\n        for (MediaType m : mediaTypes) {\r\n            if (!m.isWildcardType() && m.isCompatibleWith(MediaType.APPLICATION_JSON)) {\r\n                return UserInfoView.VIEWNAME;\r\n            } else if (!m.isWildcardType() && m.isCompatibleWith(UserInfoJWTView.JOSE_MEDIA_TYPE)) {\r\n                return UserInfoJWTView.VIEWNAME;\r\n            }\r\n        }\r\n        return UserInfoView.VIEWNAME;\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.ifZCmp",
	"Comment": "generates the instructions to jump to a label based on the comparison ofthe top integer stack value with zero.",
	"Method": "void ifZCmp(int mode,Label label){\r\n    mv.visitJumpInsn(mode, label);\r\n}"
}, {
	"Path": "org.openhab.binding.nibeuplink.internal.connector.UplinkWebInterface.preCheck",
	"Comment": "performs some pre cheks on configuration before attempting to login",
	"Method": "boolean preCheck(){\r\n    String preCheckStatusMessage = \"\";\r\n    String localPassword = config.getPassword();\r\n    String localUser = config.getUser();\r\n    String localNibeId = config.getNibeId();\r\n    if (localPassword == null || localPassword.isEmpty()) {\r\n        preCheckStatusMessage = \"please configure password first\";\r\n    } else if (localUser == null || localUser.isEmpty()) {\r\n        preCheckStatusMessage = \"please configure user first\";\r\n    } else if (localNibeId == null || localNibeId.isEmpty()) {\r\n        preCheckStatusMessage = \"please configure nibeId first\";\r\n    } else if (localNibeId.length() > NIBE_ID_THRESHOLD) {\r\n        preCheckStatusMessage = \"your NibeId is too long. Please refer to the documentation on how to set this value.\";\r\n    } else {\r\n        return true;\r\n    }\r\n    this.uplinkHandler.setStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, preCheckStatusMessage);\r\n    return false;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.assertion.JWTBearerClientAssertionTokenEndpointFilter.attemptAuthentication",
	"Comment": "pull the assertion out of the request and send it up to the auth manager for processing.",
	"Method": "Authentication attemptAuthentication(HttpServletRequest request,HttpServletResponse response){\r\n    String assertionType = request.getParameter(\"client_assertion_type\");\r\n    String assertion = request.getParameter(\"client_assertion\");\r\n    try {\r\n        JWT jwt = JWTParser.parse(assertion);\r\n        String clientId = jwt.getJWTClaimsSet().getSubject();\r\n        Authentication authRequest = new JWTBearerAssertionAuthenticationToken(jwt);\r\n        return this.getAuthenticationManager().authenticate(authRequest);\r\n    } catch (ParseException e) {\r\n        throw new BadCredentialsException(\"Invalid JWT credential: \" + assertion);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.gardena.internal.config.GardenaConfig.isValid",
	"Comment": "validate the config, if at least email and password is specified.",
	"Method": "boolean isValid(){\r\n    return StringUtils.isNotBlank(email) && StringUtils.isNotBlank(password);\r\n}"
}, {
	"Path": "org.openhab.binding.gardena.internal.handler.GardenaThingHandler.getGardenaSmart",
	"Comment": "returns the gardena smart home implementation if the bridge is available.",
	"Method": "GardenaSmart getGardenaSmart(){\r\n    if (getBridge() == null || getBridge().getHandler() == null || ((GardenaAccountHandler) getBridge().getHandler()).getGardenaSmart() == null) {\r\n        if (thing.getStatus() != ThingStatus.INITIALIZING) {\r\n            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.HANDLER_MISSING_ERROR);\r\n        }\r\n        throw new AccountHandlerNotAvailableException(\"Gardena AccountHandler not yet available!\");\r\n    }\r\n    return ((GardenaAccountHandler) getBridge().getHandler()).getGardenaSmart();\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.discovery.DSMRMeterDiscoveryService.reportConfigurationValidationResults",
	"Comment": "called when the validation finds in inconsistency between configured meters.",
	"Method": "void reportConfigurationValidationResults(List<DSMRMeterType> invalidConfigured,List<DSMRMeterType> unconfiguredMeters){\r\n    logger.info(\"Possible incorrect meters configured. These are configured: {}.\" + \"But the following unconfigured meters are found in the data received from the meter: {}\", invalidConfigured.stream().map(m -> m.name()).collect(Collectors.joining(\", \")), unconfiguredMeters.stream().map(m -> m.name()).collect(Collectors.joining(\", \")));\r\n}"
}, {
	"Path": "org.openhab.binding.solaredge.internal.connector.WebInterface.preCheck",
	"Comment": "performs some pre cheks on configuration before attempting to login",
	"Method": "boolean preCheck(){\r\n    String preCheckStatusMessage = \"\";\r\n    String localTokenOrApiKey = config.getTokenOrApiKey();\r\n    String localSolarId = config.getSolarId();\r\n    if (localTokenOrApiKey == null || localTokenOrApiKey.isEmpty()) {\r\n        preCheckStatusMessage = \"please configure token/api_key first\";\r\n    } else if (localSolarId == null || localSolarId.isEmpty()) {\r\n        preCheckStatusMessage = \"please configure solarId first\";\r\n    } else if (config.isUsePrivateApi() && localTokenOrApiKey.length() < TOKEN_THRESHOLD) {\r\n        preCheckStatusMessage = \"you will have to use a 'token' and not an 'api key' when using private API\";\r\n    } else if (!config.isUsePrivateApi() && localTokenOrApiKey.length() > API_KEY_THRESHOLD) {\r\n        preCheckStatusMessage = \"you will have to use an 'api key' and not a 'token' when using public API\";\r\n    } else if (config.isUsePrivateApi() == false && calcRequestsPerDay() > WEB_REQUEST_PUBLIC_API_DAY_LIMIT) {\r\n        preCheckStatusMessage = \"daily request limit (\" + WEB_REQUEST_PUBLIC_API_DAY_LIMIT + \") exceeded: \" + calcRequestsPerDay();\r\n    } else if (config.isUsePrivateApi() && !config.isMeterInstalled()) {\r\n        preCheckStatusMessage = \"a meter must be present in order to use the private API\";\r\n    } else {\r\n        return true;\r\n    }\r\n    this.handler.setStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, preCheckStatusMessage);\r\n    return false;\r\n}"
}, {
	"Path": "org.openhab.binding.globalcache.internal.discovery.MulticastListener.waitForBeacon",
	"Comment": "wait on the multicast socket for an announcement beacon. return false on socket timeout or error.otherwise, parse the beacon for information about the device.",
	"Method": "boolean waitForBeacon(){\r\n    byte[] bytes = new byte[600];\r\n    boolean beaconFound;\r\n    logger.trace(\"Multicast listener waiting for datagram on multicast port\");\r\n    DatagramPacket msgPacket = new DatagramPacket(bytes, bytes.length);\r\n    try {\r\n        socket.receive(msgPacket);\r\n        beaconFound = true;\r\n        logger.trace(\"Multicast listener got datagram of length {} from multicast port: {}\", msgPacket.getLength(), msgPacket.toString());\r\n    } catch (SocketTimeoutException e) {\r\n        beaconFound = false;\r\n    }\r\n    if (beaconFound) {\r\n        parseAnnouncementBeacon(msgPacket);\r\n    }\r\n    return beaconFound;\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.protocol.xml.ZoneControlXML.applyModelVariations",
	"Comment": "apply command changes to ensure compatibility with all supported models",
	"Method": "void applyModelVariations(){\r\n    if (zoneDescriptor == null) {\r\n        logger.trace(\"Zone {} - descriptor not available\", getZone());\r\n        return;\r\n    }\r\n    logger.trace(\"Zone {} - compatibility detection\", getZone());\r\n    sceneSelSupported = zoneDescriptor.hasCommandEnding(\"Scene,Scene_Sel\", () -> logger.info(\"Zone {} - the {} channel is not supported on your model\", getZone(), CHANNEL_SCENE));\r\n    dialogueLevelSupported = zoneDescriptor.hasAnyCommandEnding(\"Sound_Video,Dialogue_Adjust,Dialogue_Lvl\", \"Sound_Video,Dialogue_Adjust,Dialogue_Lift\");\r\n    if (zoneDescriptor.hasCommandEnding(\"Sound_Video,Dialogue_Adjust,Dialogue_Lift\")) {\r\n        dialogueLevel = dialogueLevel.replace(\"Dialogue_Lvl\", \"Dialogue_Lift\");\r\n        logger.debug(\"Zone {} - adjusting command to: {}\", getZone(), dialogueLevel);\r\n    }\r\n    if (!dialogueLevelSupported) {\r\n        logger.info(\"Zone {} - the {} channel is not supported on your model\", getZone(), CHANNEL_DIALOGUE_LEVEL);\r\n    }\r\n    if (zoneDescriptor.hasCommandEnding(\"Vol,Lvl\")) {\r\n        volume = volume.replace(\"Volume\", \"Vol\");\r\n        logger.debug(\"Zone {} - adjusting command to: {}\", getZone(), volume);\r\n    }\r\n    if (zoneDescriptor.hasCommandEnding(\"Vol,Mute\")) {\r\n        mute = mute.replace(\"Volume\", \"Vol\");\r\n        logger.debug(\"Zone {} - adjusting command to: {}\", getZone(), mute);\r\n    }\r\n    try {\r\n        Node basicStatusNode = getZoneResponse(comReference.get(), getZone(), ZONE_BASIC_STATUS_CMD, ZONE_BASIC_STATUS_PATH);\r\n        String surroundProgram = getNodeContentOrEmpty(basicStatusNode, \"Surr/Pgm_Sel/Pgm\");\r\n        if (StringUtils.isNotEmpty(surroundProgram)) {\r\n            surroundSelProgram = new CommandTemplate(\"<Surr><Pgm_Sel><Straight>Off<\/Straight><Pgm>%s<\/Pgm><\/Pgm_Sel><\/Surr>\", \"Surr/Pgm_Sel/Pgm\");\r\n            logger.debug(\"Zone {} - adjusting command to: {}\", getZone(), surroundSelProgram);\r\n            surroundSelStraight = new CommandTemplate(\"<Surr><Pgm_Sel><Straight>On<\/Straight><\/Pgm_Sel><\/Surr>\", \"Surr/Pgm_Sel/Straight\");\r\n            logger.debug(\"Zone {} - adjusting command to: {}\", getZone(), surroundSelStraight);\r\n        }\r\n    } catch (ReceivedMessageParseException | IOException e) {\r\n        logger.warn(\"Could not perform feature detection for RX-V3900\", e);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.smartmeter.internal.MeterDevice.getPrintMeterInfo",
	"Comment": "gets if the object information has to be logged to osgi console.",
	"Method": "Boolean getPrintMeterInfo(){\r\n    return this.printMeterInfo;\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.PresenceDetection.getValue",
	"Comment": "return asynchronously the value of the presence detection as a presencedetectionvalue.",
	"Method": "void getValue(Consumer<PresenceDetectionValue> callback){\r\n    cache.getValue(callback);\r\n}"
}, {
	"Path": "org.openhab.binding.smartmeter.internal.MeterDevice.setPrintMeterInfo",
	"Comment": "sets if the object information has to be logged to osgi console.",
	"Method": "void setPrintMeterInfo(Boolean printMeterInfo){\r\n    this.printMeterInfo = printMeterInfo;\r\n}"
}, {
	"Path": "org.openhab.ui.cometvisu.internal.backend.ReadResource.broadcastEvent",
	"Comment": "broadcasts an event described by the given parameters to all currentlylistening clients.",
	"Method": "void broadcastEvent(Object eventObject){\r\n    executorService.execute(() -> {\r\n        broadcaster.broadcast(SseUtil.buildEvent(eventObject));\r\n    });\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.TestDefaultOAuth2ProviderTokenService.createAccessToken_yesRefresh",
	"Comment": "tests the creation of access tokens for clients that are allowed to have refresh tokens.",
	"Method": "void createAccessToken_yesRefresh(){\r\n    OAuth2Request clientAuth = new OAuth2Request(null, clientId, null, true, newHashSet(SystemScopeService.OFFLINE_ACCESS), null, null, null, null);\r\n    when(authentication.getOAuth2Request()).thenReturn(clientAuth);\r\n    when(client.isAllowRefresh()).thenReturn(true);\r\n    OAuth2AccessTokenEntity token = service.createAccessToken(authentication);\r\n    verify(tokenRepository, atLeastOnce()).saveRefreshToken(any(OAuth2RefreshTokenEntity.class));\r\n    verify(scopeService, atLeastOnce()).removeReservedScopes(anySet());\r\n    assertThat(token.getRefreshToken(), is(notNullValue()));\r\n}"
}, {
	"Path": "nginx.clojure.asm.MethodVisitor.visitTypeInsn",
	"Comment": "visits a type instruction. a type instruction is an instruction thattakes the internal name of a class as parameter.",
	"Method": "void visitTypeInsn(int opcode,String type){\r\n    if (mv != null) {\r\n        mv.visitTypeInsn(opcode, type);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.lutron.internal.grxprg.GrafikEyeHandler.cancelPolling",
	"Comment": "helper method to cancel our polling if we are currently polling",
	"Method": "void cancelPolling(){\r\n    if (_polling != null) {\r\n        _polling.cancel(true);\r\n        _polling = null;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.sleepiq.internal.handler.SleepIQCloudHandler.updateListenerManagement",
	"Comment": "start or stop a background polling job to look for bed status updates based on whether or not there are anylisteners to notify.",
	"Method": "void updateListenerManagement(){\r\n    if (!bedStatusListeners.isEmpty() && (pollingJob == null || pollingJob.isCancelled())) {\r\n        int pollingInterval = getPollingInterval();\r\n        pollingJob = scheduler.scheduleWithFixedDelay(this::refreshBedStatus, pollingInterval, pollingInterval, TimeUnit.SECONDS);\r\n    } else if (bedStatusListeners.isEmpty() && pollingJob != null && !pollingJob.isCancelled()) {\r\n        pollingJob.cancel(true);\r\n        pollingJob = null;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.handler.NikoHomeControlThermostatHandler.scheduleRefreshOverruletime",
	"Comment": "method to update state of overruletime channel every minute with remaining time.",
	"Method": "void scheduleRefreshOverruletime(NhcThermostat nhcThermostat){\r\n    cancelRefreshTimer();\r\n    if (nhcThermostat.getRemainingOverruletime() <= 0) {\r\n        return;\r\n    }\r\n    this.refreshTimer = scheduler.scheduleWithFixedDelay(() -> {\r\n        long remainingTime = nhcThermostat.getRemainingOverruletime();\r\n        updateState(CHANNEL_OVERRULETIME, new DecimalType(remainingTime));\r\n        if (remainingTime <= 0) {\r\n            cancelRefreshTimer();\r\n        }\r\n    }, 1, 1, TimeUnit.MINUTES);\r\n}"
}, {
	"Path": "org.openhab.binding.satel.internal.command.ReadEventCommand.getNextIndex",
	"Comment": "return index of previous event in the log. can be used to iterate over tha event log.",
	"Method": "int getNextIndex(){\r\n    return (response.getPayload()[8] << 16) + ((response.getPayload()[9] & 0xff) << 8) + (response.getPayload()[10] & 0xff);\r\n}"
}, {
	"Path": "org.openhab.binding.squeezebox.internal.handler.SqueezeBoxNotificationPlayer.setVolume",
	"Comment": "sends a volume set command if target volume is not equal to the current volume.",
	"Method": "void setVolume(int requestedVolume){\r\n    if (playerState.getVolume() == requestedVolume) {\r\n        return;\r\n    }\r\n    SqueezeBoxNotificationListener listener = new SqueezeBoxNotificationListener(mac);\r\n    listener.resetVolumeUpdated();\r\n    squeezeBoxServerHandler.registerSqueezeBoxPlayerListener(listener);\r\n    squeezeBoxServerHandler.setVolume(mac, requestedVolume);\r\n    logger.trace(\"Waiting up to {} s for volume to be updated...\", VOLUME_COMMAND_TIMEOUT);\r\n    try {\r\n        int timeoutCount = 0;\r\n        while (!listener.isVolumeUpdated(requestedVolume)) {\r\n            Thread.sleep(100);\r\n            if (timeoutCount++ > VOLUME_COMMAND_TIMEOUT * 10) {\r\n                throw new SqueezeBoxTimeoutException(\"Unable to update volume.\");\r\n            }\r\n        }\r\n    } finally {\r\n        squeezeBoxServerHandler.unregisterSqueezeBoxPlayerListener(listener);\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.MethodVisitor.visitLabel",
	"Comment": "visits a label. a label designates the instruction that will be visitedjust after it.",
	"Method": "void visitLabel(Label label){\r\n    if (mv != null) {\r\n        mv.visitLabel(label);\r\n    }\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Octet.fromIterable",
	"Comment": "create tuple from iterable. iterable has to have exactly eight elements.",
	"Method": "Octet<X, X, X, X, X, X, X, X> fromIterable(Iterable<X> iterable,Octet<X, X, X, X, X, X, X, X> fromIterable,Iterable<X> iterable,int index,Octet<X, X, X, X, X, X, X, X> fromIterable,Iterable<X> iterable,int index,boolean exactSize){\r\n    if (iterable == null) {\r\n        throw new IllegalArgumentException(\"Iterable cannot be null\");\r\n    }\r\n    boolean tooFewElements = false;\r\n    X element0 = null;\r\n    X element1 = null;\r\n    X element2 = null;\r\n    X element3 = null;\r\n    X element4 = null;\r\n    X element5 = null;\r\n    X element6 = null;\r\n    X element7 = null;\r\n    final Iterator<X> iter = iterable.iterator();\r\n    int i = 0;\r\n    while (i < index) {\r\n        if (iter.hasNext()) {\r\n            iter.next();\r\n        } else {\r\n            tooFewElements = true;\r\n        }\r\n        i++;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element0 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element1 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element2 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element3 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element4 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element5 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element6 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element7 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (tooFewElements && exactSize) {\r\n        throw new IllegalArgumentException(\"Not enough elements for creating an Octet (8 needed)\");\r\n    }\r\n    if (iter.hasNext() && exactSize) {\r\n        throw new IllegalArgumentException(\"Iterable must have exactly 8 available elements in order to create an Octet.\");\r\n    }\r\n    return new Octet<X, X, X, X, X, X, X, X>(element0, element1, element2, element3, element4, element5, element6, element7);\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.handler.NikoHomeControlBridgeHandler.triggerAlarm",
	"Comment": "send a trigger from an alarm received from niko home control.",
	"Method": "void triggerAlarm(String alarmText){\r\n    triggerChannel(CHANNEL_ALARM, alarmText);\r\n    updateStatus(ThingStatus.ONLINE);\r\n}"
}, {
	"Path": "org.openhab.binding.netatmo.internal.WeatherUtils.getHumidex",
	"Comment": "compute the humidex index given temperature and hygrometry",
	"Method": "double getHumidex(double temperature,double hygro){\r\n    double result = 6.112 * Math.pow(10, 7.5 * temperature / (237.7 + temperature)) * hygro / 100;\r\n    result = temperature + 0.555555556 * (result - 10);\r\n    return result;\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassWriter.newNameTypeItem",
	"Comment": "adds a name and type to the constant pool of the class being build. doesnothing if the constant pool already contains a similar item.",
	"Method": "Item newNameTypeItem(String name,String desc){\r\n    key2.set(NAME_TYPE, name, desc, null);\r\n    Item result = get(key2);\r\n    if (result == null) {\r\n        put122(NAME_TYPE, newUTF8(name), newUTF8(desc));\r\n        result = new Item(index++, key2);\r\n        put(result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.protocol.NhcAction.getOpenTime",
	"Comment": "get opentime of action.opentime is the time in seconds to fully open a rollershutter.",
	"Method": "Integer getOpenTime(){\r\n    return this.openTime;\r\n}"
}, {
	"Path": "nginx.clojure.asm.Type.getMethodDescriptor",
	"Comment": "returns the descriptor corresponding to the given argument and returntypes.",
	"Method": "String getMethodDescriptor(Type returnType,Type argumentTypes,String getMethodDescriptor,Method m){\r\n    Class<?>[] parameters = m.getParameterTypes();\r\n    StringBuffer buf = new StringBuffer();\r\n    buf.append('(');\r\n    for (int i = 0; i < parameters.length; ++i) {\r\n        getDescriptor(buf, parameters[i]);\r\n    }\r\n    buf.append(')');\r\n    getDescriptor(buf, m.getReturnType());\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.openhab.binding.neeo.internal.handler.NeeoRoomHandler.refreshChannel",
	"Comment": "refresh the specified channel section, key and id using the specified protocol",
	"Method": "void refreshChannel(NeeoRoomProtocol protocol,String groupId,String channelKey,String channelId){\r\n    Objects.requireNonNull(protocol, \"protocol cannot be null\");\r\n    NeeoUtil.requireNotEmpty(groupId, \"groupId must not be empty\");\r\n    NeeoUtil.requireNotEmpty(channelId, \"channelId must not be empty\");\r\n    switch(groupId) {\r\n        case NeeoConstants.ROOM_GROUP_RECIPE_ID:\r\n            NeeoUtil.requireNotEmpty(channelKey, \"channelKey must not be empty\");\r\n            switch(channelId) {\r\n                case NeeoConstants.ROOM_CHANNEL_NAME:\r\n                    protocol.refreshRecipeName(channelKey);\r\n                    break;\r\n                case NeeoConstants.ROOM_CHANNEL_TYPE:\r\n                    protocol.refreshRecipeType(channelKey);\r\n                    break;\r\n                case NeeoConstants.ROOM_CHANNEL_ENABLED:\r\n                    protocol.refreshRecipeEnabled(channelKey);\r\n                    break;\r\n                case NeeoConstants.ROOM_CHANNEL_STATUS:\r\n                    protocol.refreshRecipeStatus(channelKey);\r\n                    break;\r\n            }\r\n            break;\r\n        case NeeoConstants.ROOM_GROUP_SCENARIO_ID:\r\n            NeeoUtil.requireNotEmpty(channelKey, \"channelKey must not be empty\");\r\n            switch(channelId) {\r\n                case NeeoConstants.ROOM_CHANNEL_NAME:\r\n                    protocol.refreshScenarioName(channelKey);\r\n                    break;\r\n                case NeeoConstants.ROOM_CHANNEL_CONFIGURED:\r\n                    protocol.refreshScenarioConfigured(channelKey);\r\n                    break;\r\n                case NeeoConstants.ROOM_CHANNEL_STATUS:\r\n                    protocol.refreshScenarioStatus(channelKey);\r\n                    break;\r\n            }\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.mitre.oauth2.introspectingfilter.IntrospectingTokenService.isCacheTokens",
	"Comment": "is the service caching tokens, or is it hitting the introspection end point every time",
	"Method": "boolean isCacheTokens(){\r\n    return cacheTokens;\r\n}"
}, {
	"Path": "nginx.clojure.NginxClojureRT.evalSimpleExp",
	"Comment": "do not use this method for frequent invoking because it is slow and not optimized.",
	"Method": "String evalSimpleExp(String v,Map<String, String> vars){\r\n    int p = v.indexOf(\"#{\");\r\n    if (p > -1) {\r\n        int s = 0;\r\n        StringBuilder sb = new StringBuilder();\r\n        while (p > -1) {\r\n            if (p != s) {\r\n                sb.append(v.substring(s, p));\r\n            }\r\n            s = v.indexOf('}', p);\r\n            if (s < 0) {\r\n                sb.append(v.substring(p));\r\n                break;\r\n            }\r\n            String ek = v.substring(p + 2, s);\r\n            String ev = vars.get(ek);\r\n            if (ev == null) {\r\n                ev = vars.get(\"system.\" + ek);\r\n                if (ev == null) {\r\n                    ev = System.getProperty(ek);\r\n                }\r\n            }\r\n            sb.append(ev);\r\n            s++;\r\n            p = v.indexOf(\"#{\", s);\r\n        }\r\n        if (p < 0 && s != v.length()) {\r\n            sb.append(v.substring(s));\r\n        }\r\n        return sb.toString();\r\n    }\r\n    return v;\r\n}"
}, {
	"Path": "org.openhab.binding.feican.internal.handler.FeicanHandler.handlePercentage",
	"Comment": "handle percenttype commands. action depends on what channel send the command. for brightness related channelsafter the brightness command an extra onoff command is send to update the onoff state conform the brightnessstate.",
	"Method": "void handlePercentage(ChannelUID channelUID,PercentType command){\r\n    String id = channelUID.getId();\r\n    switch(id) {\r\n        case CHANNEL_COLOR:\r\n            handleBrightness(command);\r\n            handleOnOff(command);\r\n            break;\r\n        case CHANNEL_COLOR_TEMPERATURE:\r\n            handleColorTemperature(command);\r\n            handleOnOff(OnOffType.ON);\r\n            break;\r\n        case CHANNEL_PROGRAM_SPEED:\r\n            handleProgramSpeed(command);\r\n            handleOnOff(OnOffType.ON);\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxWsSecurity.setError",
	"Comment": "set error code and return false. it is used to report detailed error information from inside the algorithms.",
	"Method": "boolean setError(LxOfflineReason reason,String details){\r\n    if (reason != null) {\r\n        this.reason = reason;\r\n    }\r\n    if (details != null) {\r\n        this.details = details;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.openhab.binding.satel.internal.command.ReadEventCommand.isEventPresent",
	"Comment": "checks whether event record is present in the response data.",
	"Method": "boolean isEventPresent(){\r\n    return (response.getPayload()[0] & 0x10) != 0;\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.TestDefaultOAuth2ClientDetailsEntityService.saveNewClient_yesOfflineAccess",
	"Comment": "makes sure client has offline access granted scope if allowed refresh tokens.",
	"Method": "void saveNewClient_yesOfflineAccess(){\r\n    ClientDetailsEntity client = new ClientDetailsEntity();\r\n    Set<String> grantTypes = new HashSet();\r\n    grantTypes.add(\"refresh_token\");\r\n    client.setGrantTypes(grantTypes);\r\n    client = service.saveNewClient(client);\r\n    assertThat(client.getScope().contains(SystemScopeService.OFFLINE_ACCESS), is(equalTo(true)));\r\n}"
}, {
	"Path": "org.openhab.io.neeo.internal.servletservices.NeeoBrainService.resendState",
	"Comment": "helper function to send the current state of all bound channels",
	"Method": "void resendState(){\r\n    for (final Entry<NeeoDevice, NeeoDeviceChannel> boundEntry : context.getDefinitions().getBound(api.getDeviceKeys())) {\r\n        final NeeoDevice device = boundEntry.getKey();\r\n        final NeeoDeviceChannel channel = boundEntry.getValue();\r\n        try {\r\n            final State state = context.getItemRegistry().getItem(channel.getItemName()).getState();\r\n            for (String deviceKey : api.getDeviceKeys().get(device.getUid())) {\r\n                sendNotification(channel, deviceKey, state);\r\n            }\r\n        } catch (ItemNotFoundException e) {\r\n            logger.debug(\"Item not found {}\", channel.getItemName());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.neeo.internal.handler.NeeoBrainHandler.addProperty",
	"Comment": "helper method to add a property to the properties map if the value is not null",
	"Method": "void addProperty(Map<String, String> properties,String key,String value){\r\n    Objects.requireNonNull(properties, \"properties cannot be null\");\r\n    NeeoUtil.requireNotEmpty(key, \"key cannot be empty\");\r\n    if (value != null && StringUtils.isNotEmpty(value)) {\r\n        properties.put(key, value);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.deconz.internal.handler.DeconzBridgeHandler.parseBridgeFullStateResponse",
	"Comment": "parses the response message to the rest api for retrieving the full bridge state with all sensors and switchesand configuration.",
	"Method": "BridgeFullState parseBridgeFullStateResponse(AsyncHttpClient.Result r){\r\n    if (r.getResponseCode() == 403) {\r\n        return null;\r\n    } else if (r.getResponseCode() == 200) {\r\n        return gson.fromJson(r.getBody(), BridgeFullState.class);\r\n    } else {\r\n        throw new IllegalStateException(\"Unknown status code for full state request\");\r\n    }\r\n}"
}, {
	"Path": "model.battlefield.map.MapTraversor.meetObstacle",
	"Comment": "fast voxel traversal algorithm for ray tracing john amanatides andrew woo",
	"Method": "boolean meetObstacle(Map map,Point2D p1,Point2D p2){\r\n    double dirX = p2.x - p1.x;\r\n    double dirY = p2.y - p1.y;\r\n    double length = Math.sqrt(dirX * dirX + dirY * dirY);\r\n    dirX /= length;\r\n    dirY /= length;\r\n    double tDeltaX = 1 / Math.abs(dirX);\r\n    double tDeltaY = 1 / Math.abs(dirY);\r\n    int x = (int) Math.floor(p1.x);\r\n    int y = (int) Math.floor(p1.y);\r\n    int endX = (int) Math.floor(p2.x);\r\n    int endY = (int) Math.floor(p2.y);\r\n    int stepX = (int) Math.signum(dirX);\r\n    int stepY = (int) Math.signum(dirY);\r\n    double tMaxX, tMaxY;\r\n    if (dirX < 0) {\r\n        tMaxX = (x - p1.x) / dirX;\r\n    } else {\r\n        tMaxX = (x + 1 - p1.x) / dirX;\r\n    }\r\n    if (dirY < 0) {\r\n        tMaxY = (y - p1.y) / dirY;\r\n    } else {\r\n        tMaxY = (y + 1 - p1.y) / dirY;\r\n    }\r\n    if (map.get(x, y).isBlocked()) {\r\n        return true;\r\n    }\r\n    boolean reachedX = false, reachedY = false;\r\n    while (!reachedX || !reachedY) {\r\n        if (tMaxX < tMaxY) {\r\n            tMaxX += tDeltaX;\r\n            x += stepX;\r\n        } else {\r\n            tMaxY += tDeltaY;\r\n            y += stepY;\r\n        }\r\n        if (map.get(x, y).isBlocked()) {\r\n            return true;\r\n        }\r\n        if (stepX > 0) {\r\n            if (x >= endX) {\r\n                reachedX = true;\r\n            }\r\n        } else if (x <= endX) {\r\n            reachedX = true;\r\n        }\r\n        if (stepY > 0) {\r\n            if (y >= endY) {\r\n                reachedY = true;\r\n            }\r\n        } else if (y <= endY) {\r\n            reachedY = true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "geometry.geom2d.Polygon.getSplits",
	"Comment": "split the polygon in two, by the given line. returns a list of polygons. the first is the one who contains the\tgiven point.",
	"Method": "ArrayList<Polygon> getSplits(Line2D splitLine,ArrayList<Polygon> getSplits,Point2D pointOnLeftSide,Line2D splitLine){\r\n    PointRing left = new PointRing();\r\n    PointRing right = new PointRing();\r\n    PointRing actual = left;\r\n    if (!points.contains(pointOnLeftSide))\r\n        throw new RuntimeException(\"The specified point can't be found in this polygon.\");\r\n    Point2D p = pointOnLeftSide;\r\n    Point2D start = null;\r\n    for (int i = 0; i < size(); i++) {\r\n        actual.add(p);\r\n        Point2D next = points.getNext(p);\r\n        Segment2D edge = new Segment2D(p, next);\r\n        if (edge.isCollinear(splitLine))\r\n            throw new RuntimeException(\"Trying to split a polygon with a line collinear to one of its edges : \" + splitLine);\r\n        if (edge.intersect(splitLine)) {\r\n            Point2D intersection = edge.getAnyIntersection(splitLine);\r\n            if (!intersection.equals(edge.getEnd())) {\r\n                if (!intersection.equals(edge.getStart()))\r\n                    actual.add(intersection);\r\n                if (actual == left) {\r\n                    start = p;\r\n                    actual = right;\r\n                } else\r\n                    actual = left;\r\n                actual.add(intersection);\r\n            }\r\n        }\r\n        p = next;\r\n    }\r\n    if (actual == right)\r\n        throw new RuntimeException(\"The polygon have been splitted on an impair number of points, which is not allowed.\");\r\n    left.shiftTo(start);\r\n    ArrayList<Polygon> res = new ArrayList<Polygon>();\r\n    res.add(new Polygon(left));\r\n    res.add(new Polygon(right));\r\n    return res;\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.RioPresetsProtocol.handlePresetNotification",
	"Comment": "handles any system notifications returned by the russound system",
	"Method": "void handlePresetNotification(Matcher m,String resp){\r\n    if (m == null) {\r\n        throw new IllegalArgumentException(\"m (matcher) cannot be null\");\r\n    }\r\n    if (m.groupCount() == 5) {\r\n        try {\r\n            final int source = Integer.parseInt(m.group(1));\r\n            if (source >= 1 && source <= 8) {\r\n                final int bank = Integer.parseInt(m.group(2));\r\n                if (bank >= 1 && bank <= 6) {\r\n                    final int preset = Integer.parseInt(m.group(3));\r\n                    if (preset >= 1 && preset <= 6) {\r\n                        final String key = m.group(4).toLowerCase();\r\n                        final String value = m.group(5);\r\n                        final RioPreset rioPreset = presets[source - 1][(bank - 1) * 6 + preset - 1];\r\n                        switch(key) {\r\n                            case PRESET_NAME:\r\n                                rioPreset.setName(value);\r\n                                fireUpdate(source);\r\n                                break;\r\n                            case PRESET_VALID:\r\n                                rioPreset.setValid(!\"false\".equalsIgnoreCase(value));\r\n                                fireUpdate(source);\r\n                                break;\r\n                            default:\r\n                                logger.warn(\"Unknown preset notification: '{}'\", resp);\r\n                                break;\r\n                        }\r\n                    } else {\r\n                        logger.debug(\"Preset ID must be between 1 and 6: {}\", resp);\r\n                    }\r\n                } else {\r\n                    logger.debug(\"Bank ID must be between 1 and 6: {}\", resp);\r\n                }\r\n            } else {\r\n                logger.debug(\"Source ID must be between 1 and 8: {}\", resp);\r\n            }\r\n        } catch (NumberFormatException e) {\r\n            logger.warn(\"Invalid Preset Notification (source/bank/preset not a parsable integer): '{}')\", resp);\r\n        }\r\n    } else {\r\n        logger.warn(\"Invalid Preset Notification: '{}')\", resp);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.miio.handler.MiIoBasicHandler.checkChannelStructure",
	"Comment": "checks if the channel structure has been build already based on the model data. if not build it.",
	"Method": "void checkChannelStructure(){\r\n    if (!hasChannelStructure) {\r\n        if (configuration.model == null || configuration.model.isEmpty()) {\r\n            logger.debug(\"Model needs to be determined\");\r\n        } else {\r\n            hasChannelStructure = buildChannelStructure(configuration.model);\r\n        }\r\n    }\r\n    if (hasChannelStructure) {\r\n        refreshList = new ArrayList<MiIoBasicChannel>();\r\n        for (MiIoBasicChannel miChannel : miioDevice.getDevice().getChannels()) {\r\n            if (miChannel.getRefresh()) {\r\n                refreshList.add(miChannel);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.atlona.internal.pro3.AtlonaPro3PortocolHandler.setPortMirror",
	"Comment": "sets the hdmi port number to mirror the specified output port number.",
	"Method": "void setPortMirror(int hdmiPortNbr,int outPortNbr){\r\n    if (hdmiPortNbr <= 0) {\r\n        throw new IllegalArgumentException(\"hdmiPortNbr must be greater than 0\");\r\n    }\r\n    if (outPortNbr <= 0) {\r\n        throw new IllegalArgumentException(\"outPortNbr must be greater than 0\");\r\n    }\r\n    if (capabilities.getHdmiPorts().contains(hdmiPortNbr)) {\r\n        sendCommand(String.format(CMD_PORT_MIRROR_FORMAT, hdmiPortNbr, outPortNbr));\r\n    } else {\r\n        logger.info(\"Trying to set port mirroring on a non-hdmi port: {}\", hdmiPortNbr);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.kodi.internal.model.KodiDuration.toMillis",
	"Comment": "converts this kodiduration to the total length in milliseconds.",
	"Method": "long toMillis(){\r\n    return Duration.ofHours(hours).plusMinutes(minutes).plusSeconds(seconds).plusMillis(milliseconds).toMillis();\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxWsSecurity.checkResponse",
	"Comment": "check a response received from the miniserver for errors, interpret it and store the results in class fields.",
	"Method": "boolean checkResponse(LxJsonSubResponse response){\r\n    if (response == null || cancel) {\r\n        reason = LxOfflineReason.COMMUNICATION_ERROR;\r\n        return false;\r\n    }\r\n    reason = LxOfflineReason.getReason(response.code);\r\n    return (reason == LxOfflineReason.NONE);\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.handler.YamahaBridgeHandler.updateAllZoneInformation",
	"Comment": "periodically and initially called. this must run in another thread, because all update calls are blocking.",
	"Method": "void updateAllZoneInformation(){\r\n    if (disposed) {\r\n        logger.trace(\"updateAllZoneInformation will be skipped because the bridge is disposed\");\r\n        return;\r\n    }\r\n    logger.trace(\"updateAllZoneInformation\");\r\n    try {\r\n        systemControlState.power = true;\r\n        systemControl.update();\r\n        updateStatus(ThingStatus.ONLINE);\r\n        Bridge bridge = (Bridge) thing;\r\n        for (Thing thing : bridge.getThings()) {\r\n            YamahaZoneThingHandler handler = (YamahaZoneThingHandler) thing.getHandler();\r\n            if (handler != null) {\r\n                if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.BRIDGE_OFFLINE) {\r\n                    handler.bridgeStatusChanged(ThingStatusInfoBuilder.create(bridge.getStatus()).build());\r\n                } else if (handler.isCorrectlyInitialized()) {\r\n                    handler.updateZoneInformation();\r\n                }\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\r\n        systemControlState.invalidate();\r\n        return;\r\n    } catch (ReceivedMessageParseException e) {\r\n        updateProperty(PROPERTY_MENU_ERROR, e.getMessage());\r\n        logger.debug(\"Parse error!\", e);\r\n    } finally {\r\n        loadingDone.countDown();\r\n    }\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.internal.pooling.ModbusSlaveConnectionFactoryImpl.getEndpointPoolConfiguration",
	"Comment": "get general configuration settings applied to a given endpointnote that default configuration settings are returned in case the endpoint has not been configured.",
	"Method": "EndpointPoolConfiguration getEndpointPoolConfiguration(ModbusSlaveEndpoint endpoint){\r\n    @Nullable\r\n    EndpointPoolConfiguration config = endpointPoolConfigs.computeIfAbsent(endpoint, defaultPoolConfigurationFactory);\r\n    return config;\r\n}"
}, {
	"Path": "geometry.geom2d.Polygon.getWidth",
	"Comment": "the width of a polygon is the width of the minimum bounding box aligned with its first edge.",
	"Method": "double getWidth(){\r\n    return getFirstEdgeAlignedBoundingBox().width;\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.zone.RioZoneProtocol.setZoneRating",
	"Comment": "assign a rating to the current song if the source supports a rating",
	"Method": "void setZoneRating(boolean like){\r\n    sendCommand(\"EVENT C[\" + controller + \"].Z[\" + zone + \"]!MMRate \" + (like ? \"hi\" : \"low\"));\r\n}"
}, {
	"Path": "org.openhab.binding.pioneeravr.internal.handler.AbstractAvrHandler.getChannelUID",
	"Comment": "build the channeluid from the channel name and the zone number.",
	"Method": "String getChannelUID(String channelName,int zone){\r\n    return String.format(PioneerAvrBindingConstants.GROUP_CHANNEL_PATTERN, zone, channelName);\r\n}"
}, {
	"Path": "org.openhab.binding.lutron.internal.grxprg.PrgProtocolHandler.refreshZoneIntensity",
	"Comment": "refreshes the current zone intensities for the control unit",
	"Method": "void refreshZoneIntensity(int controlUnit){\r\n    validateControlUnit(controlUnit);\r\n    sendCommand(CMD_ZONEINTENSITYSTATUS + \" \" + controlUnit);\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.not",
	"Comment": "generates the instructions to compute the bitwise negation of the topstack value.",
	"Method": "void not(){\r\n    mv.visitInsn(Opcodes.ICONST_1);\r\n    mv.visitInsn(Opcodes.IXOR);\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.getField",
	"Comment": "generates the instruction to push the value of a non static field on thestack.",
	"Method": "void getField(Type owner,String name,Type type){\r\n    fieldInsn(Opcodes.GETFIELD, owner, name, type);\r\n}"
}, {
	"Path": "org.openhab.ui.cometvisu.internal.backend.ReadResource.getStates",
	"Comment": "subscribes the connecting client to the stream of events filtered by thegiven eventfilter.",
	"Method": "Object getStates(List<String> itemNames,long index,long time){\r\n    final EventOutput eventOutput = new EventOutput();\r\n    this.itemNames = itemNames;\r\n    broadcaster.add(eventOutput);\r\n    items = new HashMap<Item, Map<String, Class<? extends State>>>();\r\n    if (this.itemRegistry != null) {\r\n        List<StateBean> states = new ArrayList<StateBean>();\r\n        for (String cvItemName : itemNames) {\r\n            try {\r\n                String[] parts = cvItemName.split(\":\");\r\n                String ohItemName = cvItemName;\r\n                Class<? extends State> stateClass = null;\r\n                if (parts.length == 2) {\r\n                    String classPrefix = parts[0].toLowerCase();\r\n                    if (Config.itemTypeMapper.containsKey(classPrefix)) {\r\n                        stateClass = Config.itemTypeMapper.get(classPrefix);\r\n                        classPrefix += \":\";\r\n                    } else {\r\n                        logger.debug(\"no type found for '{}'\", classPrefix);\r\n                        classPrefix = \"\";\r\n                    }\r\n                    ohItemName = parts[1];\r\n                }\r\n                Item item = this.itemRegistry.getItem(ohItemName);\r\n                if (!items.containsKey(item)) {\r\n                    items.put(item, new HashMap<String, Class<? extends State>>());\r\n                }\r\n                items.get(item).put(cvItemName, stateClass);\r\n                StateBean itemState = new StateBean();\r\n                itemState.name = cvItemName;\r\n                if (stateClass != null) {\r\n                    itemState.state = item.getStateAs(stateClass).toString();\r\n                    logger.trace(\"get state of '{}' as '{}' == '{}'\", item, stateClass, itemState.state);\r\n                } else {\r\n                    itemState.state = item.getState().toString();\r\n                }\r\n                states.add(itemState);\r\n            } catch (ItemNotFoundException e) {\r\n                logger.error(\"{}\", e.getLocalizedMessage());\r\n            }\r\n        }\r\n        logger.debug(\"initially broadcasting {}/{} item states\", states.size(), itemNames.size());\r\n        broadcaster.broadcast(SseUtil.buildEvent(states));\r\n    }\r\n    registerItems();\r\n    return eventOutput;\r\n}"
}, {
	"Path": "org.mitre.oauth2.model.OAuth2RefreshTokenEntity.getAuthenticationHolder",
	"Comment": "the authentication in place when the original access token was\tcreated",
	"Method": "AuthenticationHolderEntity getAuthenticationHolder(){\r\n    return authenticationHolder;\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.system.RioSystemProtocol.ping",
	"Comment": "pings the server with out ping command to keep the connection alive",
	"Method": "void ping(){\r\n    sendCommand(CMD_PING);\r\n}"
}, {
	"Path": "org.openhab.binding.dscalarm.internal.handler.PanelThingHandler.restorePartitionsInAlarm",
	"Comment": "restores all partitions that are in alarm after special panel alarm conditions have been restored.",
	"Method": "void restorePartitionsInAlarm(DSCAlarmCode dscAlarmCode){\r\n    logger.debug(\"restorePartitionsInAlarm(): DSC Alarm Code: {}!\", dscAlarmCode.toString());\r\n    ChannelUID channelUID = null;\r\n    if (dscAlarmCode == DSCAlarmCode.FireKeyRestored || dscAlarmCode == DSCAlarmCode.AuxiliaryKeyRestored || dscAlarmCode == DSCAlarmCode.PanicKeyRestored || dscAlarmCode == DSCAlarmCode.AuxiliaryInputAlarmRestored) {\r\n        List<Thing> things = dscAlarmBridgeHandler.getThing().getThings();\r\n        for (Thing thg : things) {\r\n            if (thg.getThingTypeUID().equals(PARTITION_THING_TYPE)) {\r\n                DSCAlarmBaseThingHandler handler = (DSCAlarmBaseThingHandler) thg.getHandler();\r\n                if (handler != null) {\r\n                    channelUID = new ChannelUID(thg.getUID(), PARTITION_IN_ALARM);\r\n                    handler.updateChannel(channelUID, 0, \"\");\r\n                    logger.debug(\"restorePartitionsInAlarm(): Partition In Alarm Restored: {}!\", thg.getUID());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.lutron.internal.grxprg.GrafikEyeConfig.isShadeZone",
	"Comment": "helper method to determine if the zone is a shade zone or not. if zone number is invalid, false will be returned.",
	"Method": "boolean isShadeZone(int zone){\r\n    if (zone >= 1 && zone <= shades.length) {\r\n        return shades[zone - 1];\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.openhab.binding.gpstracker.internal.GPSTrackerHandlerFactory.supportsThingType",
	"Comment": "called by the framework to find out if thing type is supported by the handler factory.",
	"Method": "boolean supportsThingType(ThingTypeUID thingTypeUID){\r\n    return GPSTrackerBindingConstants.SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\r\n}"
}, {
	"Path": "nginx.clojure.asm.signature.SignatureVisitor.visitClassBound",
	"Comment": "visits the class bound of the last visited formal type parameter.",
	"Method": "SignatureVisitor visitClassBound(){\r\n    return this;\r\n}"
}, {
	"Path": "org.openhab.io.openhabcloud.internal.CloudService.sendBroadcastNotification",
	"Comment": "sends a broadcast notification. broadcast notifications are pushed to allmobile devices of all users of the account",
	"Method": "void sendBroadcastNotification(String message,String icon,String severity){\r\n    logger.debug(\"Sending broadcast message '{}' to all users\", message);\r\n    cloudClient.sendBroadcastNotification(message, icon, severity);\r\n}"
}, {
	"Path": "org.openhab.binding.nest.internal.handler.NestStructureHandler.handleCommand",
	"Comment": "handles updating the details on this structure by sending the request all the wayto nest.",
	"Method": "void handleCommand(ChannelUID channelUID,Command command){\r\n    if (REFRESH.equals(command)) {\r\n        Structure lastUpdate = getLastUpdate();\r\n        if (lastUpdate != null) {\r\n            updateState(channelUID, getChannelState(channelUID, lastUpdate));\r\n        }\r\n    } else if (CHANNEL_AWAY.equals(channelUID.getId())) {\r\n        if (command instanceof StringType) {\r\n            StringType cmd = (StringType) command;\r\n            addUpdateRequest(NEST_STRUCTURE_UPDATE_PATH, \"away\", HomeAwayState.valueOf(cmd.toString()));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.satel.internal.event.IntegraStateEvent.statesSet",
	"Comment": "returns number of state bits that are active for given state.",
	"Method": "int statesSet(StateType stateType){\r\n    return getStateBits(stateType).cardinality();\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxControlLightControllerV2.getMinMoodId",
	"Comment": "get minimum value a mood id can have for the current list of moods.",
	"Method": "Integer getMinMoodId(){\r\n    return minMoodId;\r\n}"
}, {
	"Path": "org.openhab.binding.innogysmarthome.internal.client.entity.state.StatePropertyList.getConfigVersion",
	"Comment": "returns the config version of the smarthome setup.the config version changes everytime, the configuration on the controller is changed and saved.",
	"Method": "Integer getConfigVersion(){\r\n    return getPropertyValueAsInteger(STATE_NAME_CONFIGVERSION);\r\n}"
}, {
	"Path": "nginx.clojure.asm.signature.SignatureVisitor.visitTypeArgument",
	"Comment": "visits a type argument of the last visited class or inner class type.",
	"Method": "void visitTypeArgument(SignatureVisitor visitTypeArgument,char wildcard){\r\n    return this;\r\n}"
}, {
	"Path": "geometry.geom2d.algorithm.OffsetOperator.computeSegments",
	"Comment": "this method computes the edges of the remainder polygon, by intersecting the offset lines.\tthe borders will be the difference between the remainder and the original polygon.",
	"Method": "void computeSegments(){\r\n    int correspondence = 0;\r\n    for (Line2D line : lines) {\r\n        Point2D start;\r\n        Point2D end;\r\n        if (line.isCollinear(lines.getPrevious(line))) {\r\n            start = line.getStart();\r\n        } else {\r\n            if (!line.intersectAtSinglePoint(lines.getPrevious(line))) {\r\n                logger.warning(\"les lignes n'ont pas d'intersection ??\" + line + lines.getPrevious(line));\r\n            }\r\n            start = line.getUniqueIntersection(lines.getPrevious(line));\r\n        }\r\n        if (line.isCollinear(lines.getNext(line))) {\r\n            end = line.getEnd();\r\n        } else {\r\n            if (!line.intersectAtSinglePoint(lines.getNext(line))) {\r\n                logger.warning(\"les lignes n'ont pas d'intersection ??\" + line + lines.getNext(line));\r\n            }\r\n            end = line.getUniqueIntersection(lines.getNext(line));\r\n        }\r\n        if (!start.equals(end) && AngleUtil.areSimilar(end.getSubtraction(start).getAngle(), line.getAngle())) {\r\n            segments.add(new Segment2D(start, end));\r\n        } else {\r\n            segments.add(null);\r\n            correspondence--;\r\n            if (correspondence < 0) {\r\n                correspondence = p.points.size() - 1;\r\n            }\r\n        }\r\n        correspondences.add(new Integer(correspondence));\r\n        correspondence++;\r\n    }\r\n    Segment2D lastValid = segments.getFirst();\r\n    if (lastValid == null) {\r\n        lastValid = getNextValidSegment(0);\r\n    }\r\n    if (lastValid == null) {\r\n        throw new RuntimeException(\"There is no valid edge.\");\r\n    }\r\n    int start = segments.indexOf(lastValid);\r\n    int index = start;\r\n    do {\r\n        Segment2D nextValid = getNextValidSegment(index);\r\n        if (nextValid != segments.getNext(lastValid)) {\r\n            Point2D intersection = new Line2D(lastValid).getUniqueIntersection(new Line2D(nextValid));\r\n            int lastValidIndex = segments.indexOf(lastValid);\r\n            int nextValidIndex = segments.indexOf(nextValid);\r\n            segments.set(lastValidIndex, new Segment2D(lastValid.getStart(), intersection));\r\n            segments.set(nextValidIndex, new Segment2D(intersection, nextValid.getEnd()));\r\n            nextValid = segments.get(nextValidIndex);\r\n        }\r\n        index = segments.indexOf(nextValid);\r\n        lastValid = segments.get(segments.indexOf(nextValid));\r\n    } while (index != start);\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.instanceOf",
	"Comment": "generates the instruction to test if the top stack value is of the giventype.",
	"Method": "void instanceOf(Type type){\r\n    typeInsn(Opcodes.INSTANCEOF, type);\r\n}"
}, {
	"Path": "nginx.clojure.asm.MethodVisitor.visitMethodInsn",
	"Comment": "visits a method instruction. a method instruction is an instruction thatinvokes a method.",
	"Method": "void visitMethodInsn(int opcode,String owner,String name,String desc){\r\n    if (mv != null) {\r\n        mv.visitMethodInsn(opcode, owner, name, desc);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.modbus.internal.ModbusPollerThingHandlerTest.testRefreshWithPreviousData2",
	"Comment": "testing again caching, such that most recently received data is propagated to children",
	"Method": "void testRefreshWithPreviousData2(){\r\n    Configuration pollerConfig = new Configuration();\r\n    pollerConfig.put(\"refresh\", 0L);\r\n    pollerConfig.put(\"start\", 5);\r\n    pollerConfig.put(\"length\", 13);\r\n    pollerConfig.put(\"type\", \"coil\");\r\n    pollerConfig.put(\"cacheMillis\", 10000L);\r\n    poller = createPollerThingBuilder(\"poller\").withConfiguration(pollerConfig).withBridge(endpoint.getUID()).build();\r\n    registerThingToMockRegistry(poller);\r\n    hookStatusUpdates(poller);\r\n    ModbusPollerThingHandlerImpl thingHandler = new ModbusPollerThingHandlerImpl(poller, () -> modbusManager);\r\n    thingHandler.setCallback(thingCallback);\r\n    poller.setHandler(thingHandler);\r\n    hookItemRegistry(thingHandler);\r\n    thingHandler.initialize();\r\n    ModbusDataThingHandler child1 = Mockito.mock(ModbusDataThingHandler.class);\r\n    thingHandler.childHandlerInitialized(child1, Mockito.mock(Thing.class));\r\n    assertThat(poller.getStatus(), is(equalTo(ThingStatus.ONLINE)));\r\n    verify(modbusManager, never()).submitOneTimePoll(any());\r\n    ModbusReadCallback pollerReadCallback = getPollerCallback(thingHandler);\r\n    ModbusReadRequestBlueprint request = Mockito.mock(ModbusReadRequestBlueprint.class);\r\n    ModbusReadRequestBlueprint request2 = Mockito.mock(ModbusReadRequestBlueprint.class);\r\n    ModbusRegisterArray registers = Mockito.mock(ModbusRegisterArray.class);\r\n    Exception error = Mockito.mock(Exception.class);\r\n    pollerReadCallback.onRegisters(request, registers);\r\n    verify(child1).onRegisters(request, registers);\r\n    verifyNoMoreInteractions(child1);\r\n    reset(child1);\r\n    Thread.sleep(5L);\r\n    pollerReadCallback.onError(request2, error);\r\n    verify(child1).onError(request2, error);\r\n    verifyNoMoreInteractions(child1);\r\n    reset(child1);\r\n    thingHandler.refresh();\r\n    verify(modbusManager, never()).submitOneTimePoll(any());\r\n    verify(child1).onError(request2, error);\r\n    verifyNoMoreInteractions(child1);\r\n}"
}, {
	"Path": "nginx.clojure.asm.ByteVector.putUTF8",
	"Comment": "puts an utf8 string into this byte vector. the byte vector isautomatically enlarged if necessary.",
	"Method": "ByteVector putUTF8(String s){\r\n    int charLength = s.length();\r\n    if (charLength > 65535) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    int len = length;\r\n    if (len + 2 + charLength > data.length) {\r\n        enlarge(2 + charLength);\r\n    }\r\n    byte[] data = this.data;\r\n    data[len++] = (byte) (charLength >>> 8);\r\n    data[len++] = (byte) charLength;\r\n    for (int i = 0; i < charLength; ++i) {\r\n        char c = s.charAt(i);\r\n        if (c >= '\\001' && c <= '\\177') {\r\n            data[len++] = (byte) c;\r\n        } else {\r\n            int byteLength = i;\r\n            for (int j = i; j < charLength; ++j) {\r\n                c = s.charAt(j);\r\n                if (c >= '\\001' && c <= '\\177') {\r\n                    byteLength++;\r\n                } else if (c > '?') {\r\n                    byteLength += 3;\r\n                } else {\r\n                    byteLength += 2;\r\n                }\r\n            }\r\n            if (byteLength > 65535) {\r\n                throw new IllegalArgumentException();\r\n            }\r\n            data[length] = (byte) (byteLength >>> 8);\r\n            data[length + 1] = (byte) byteLength;\r\n            if (length + 2 + byteLength > data.length) {\r\n                length = len;\r\n                enlarge(2 + byteLength);\r\n                data = this.data;\r\n            }\r\n            for (int j = i; j < charLength; ++j) {\r\n                c = s.charAt(j);\r\n                if (c >= '\\001' && c <= '\\177') {\r\n                    data[len++] = (byte) c;\r\n                } else if (c > '?') {\r\n                    data[len++] = (byte) (0xE0 | c >> 12 & 0xF);\r\n                    data[len++] = (byte) (0x80 | c >> 6 & 0x3F);\r\n                    data[len++] = (byte) (0x80 | c & 0x3F);\r\n                } else {\r\n                    data[len++] = (byte) (0xC0 | c >> 6 & 0x1F);\r\n                    data[len++] = (byte) (0x80 | c & 0x3F);\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    length = len;\r\n    return this;\r\n}"
}, {
	"Path": "org.openhab.binding.lametrictime.internal.LaMetricTimeHandlerFactory.registerAppDiscoveryService",
	"Comment": "register the given device handler to participate in discovery of new apps.",
	"Method": "void registerAppDiscoveryService(LaMetricTimeHandler deviceHandler){\r\n    logger.debug(\"Registering app discovery service\");\r\n    LaMetricTimeAppDiscoveryService discoveryService = new LaMetricTimeAppDiscoveryService(deviceHandler);\r\n    discoveryServiceReg.put(deviceHandler.getThing().getUID(), bundleContext.registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<String, Object>()));\r\n}"
}, {
	"Path": "org.openhab.binding.satel.internal.protocol.SatelModule.getIntegraVersion",
	"Comment": "returns firmware revision of integra connected to the module.",
	"Method": "String getIntegraVersion(){\r\n    return this.integraVersion;\r\n}"
}, {
	"Path": "org.mitre.oauth2.web.AuthenticationUtilities.ensureOAuthScope",
	"Comment": "makes sure the authentication contains the given scope, throws an exception otherwise",
	"Method": "void ensureOAuthScope(Authentication auth,String scope){\r\n    if (auth instanceof OAuth2Authentication) {\r\n        OAuth2Authentication oAuth2Authentication = (OAuth2Authentication) auth;\r\n        if (oAuth2Authentication.getOAuth2Request().getScope() == null || !oAuth2Authentication.getOAuth2Request().getScope().contains(scope)) {\r\n            throw new InsufficientScopeException(\"Insufficient scope\", ImmutableSet.of(scope));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.cm11a.internal.X10Interface.updateHardware",
	"Comment": "perform hardware update. keep trying until it is successful",
	"Method": "void updateHardware(Cm11aAbstractHandler nextModule){\r\n    boolean success = false;\r\n    while (!success) {\r\n        try {\r\n            if (connect()) {\r\n                nextModule.updateHardware(this);\r\n                success = true;\r\n            } else {\r\n                Thread.sleep(IO_RECONNECT_INTERVAL);\r\n            }\r\n        } catch (IOException e) {\r\n            connected = false;\r\n            String message = \"IO Exception when updating module hardware.  Will retry shortly\";\r\n            logger.warn(message, e);\r\n            bridgeHandler.changeBridgeStatusToDown(message);\r\n            Thread.sleep(IO_RECONNECT_INTERVAL);\r\n        } catch (InvalidAddressException e) {\r\n            logger.warn(\"Attempted to send an X10 Function call with invalid address.  Ignoring this.\");\r\n            success = true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.Handle.getDesc",
	"Comment": "returns the descriptor of the field or method designated by this handle.",
	"Method": "String getDesc(){\r\n    return desc;\r\n}"
}, {
	"Path": "org.mitre.jwt.encryption.service.impl.DefaultJWTEncryptionAndDecryptionService.buildEncryptersAndDecrypters",
	"Comment": "builds all the encrypters and decrypters for this service based on the key map.",
	"Method": "void buildEncryptersAndDecrypters(){\r\n    for (Map.Entry<String, JWK> jwkEntry : keys.entrySet()) {\r\n        String id = jwkEntry.getKey();\r\n        JWK jwk = jwkEntry.getValue();\r\n        if (jwk instanceof RSAKey) {\r\n            RSAEncrypter encrypter = new RSAEncrypter((RSAKey) jwk);\r\n            encrypter.getJCAContext().setProvider(BouncyCastleProviderSingleton.getInstance());\r\n            encrypters.put(id, encrypter);\r\n            if (jwk.isPrivate()) {\r\n                RSADecrypter decrypter = new RSADecrypter((RSAKey) jwk);\r\n                decrypter.getJCAContext().setProvider(BouncyCastleProviderSingleton.getInstance());\r\n                decrypters.put(id, decrypter);\r\n            } else {\r\n                logger.warn(\"No private key for key #\" + jwk.getKeyID());\r\n            }\r\n        } else if (jwk instanceof ECKey) {\r\n            ECDHEncrypter encrypter = new ECDHEncrypter((ECKey) jwk);\r\n            encrypter.getJCAContext().setProvider(BouncyCastleProviderSingleton.getInstance());\r\n            encrypters.put(id, encrypter);\r\n            if (jwk.isPrivate()) {\r\n                ECDHDecrypter decrypter = new ECDHDecrypter((ECKey) jwk);\r\n                decrypter.getJCAContext().setProvider(BouncyCastleProviderSingleton.getInstance());\r\n                decrypters.put(id, decrypter);\r\n            } else {\r\n                logger.warn(\"No private key for key # \" + jwk.getKeyID());\r\n            }\r\n        } else if (jwk instanceof OctetSequenceKey) {\r\n            DirectEncrypter encrypter = new DirectEncrypter((OctetSequenceKey) jwk);\r\n            encrypter.getJCAContext().setProvider(BouncyCastleProviderSingleton.getInstance());\r\n            DirectDecrypter decrypter = new DirectDecrypter((OctetSequenceKey) jwk);\r\n            decrypter.getJCAContext().setProvider(BouncyCastleProviderSingleton.getInstance());\r\n            encrypters.put(id, encrypter);\r\n            decrypters.put(id, decrypter);\r\n        } else {\r\n            logger.warn(\"Unknown key type: \" + jwk);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.ui.cometvisu.internal.util.ClientInstaller.isDownloadAvailableButBlocked",
	"Comment": "checks if the cometvisu client is missing, but the automatic download is blocked by configuration.",
	"Method": "boolean isDownloadAvailableButBlocked(){\r\n    return downloadAvailableButBlocked;\r\n}"
}, {
	"Path": "org.openhab.binding.tplinksmarthome.internal.handler.SmartHomeHandler.updateChannelState",
	"Comment": "updates the state from the device data for the channel given the data..",
	"Method": "void updateChannelState(ChannelUID channelUID,DeviceState deviceState){\r\n    String channelId = channelUID.getId();\r\n    final State state;\r\n    if (deviceState == null) {\r\n        state = UnDefType.UNDEF;\r\n    } else if (CHANNEL_RSSI.equals(channelId)) {\r\n        state = new DecimalType(deviceState.getSysinfo().getRssi());\r\n    } else {\r\n        state = smartHomeDevice.updateChannel(channelId, deviceState);\r\n    }\r\n    updateState(channelUID, state);\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.PresenceDetection.setIOSDevice",
	"Comment": "set to true if the device presence detection should be performed for an ios devicelike iphone or ipads. an additional port knock is performed before a ping.",
	"Method": "void setIOSDevice(boolean value){\r\n    iosDevice = value;\r\n}"
}, {
	"Path": "org.mitre.openid.connect.model.OIDCAuthenticationToken.getPrincipal",
	"Comment": "get the principal of this object, an immutable map of the subject and issuer.",
	"Method": "Object getPrincipal(){\r\n    return principal;\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.PresenceDetection.waitForPresenceDetection",
	"Comment": "waits for the presence detection threads to finish. returns immediatelyif no presence detection is performed right now.",
	"Method": "void waitForPresenceDetection(){\r\n    if (executorService == null) {\r\n        return;\r\n    }\r\n    try {\r\n        executorService.awaitTermination(timeoutInMS + 100, TimeUnit.MILLISECONDS);\r\n        submitFinalResult();\r\n    } catch (InterruptedException e) {\r\n        Thread.currentThread().interrupt();\r\n        executorService.shutdownNow();\r\n        executorService = null;\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.Type.getReturnType",
	"Comment": "returns the return type of methods of this type. this method should onlybe used for method types.",
	"Method": "Type getReturnType(String methodDescriptor,Type getReturnType,Method method,Type getReturnType){\r\n    return getReturnType(getDescriptor());\r\n}"
}, {
	"Path": "org.openhab.binding.lutron.internal.grxprg.PrgProtocolHandler.convertScene",
	"Comment": "validates the scene and converts it to the corresponding hex value",
	"Method": "char convertScene(int scene){\r\n    if (scene < 0 || scene > VALID_SCENES.length()) {\r\n        throw new IllegalArgumentException(\"Invalid scene (must be between 0 and \" + VALID_SCENES.length() + \"): \" + scene);\r\n    }\r\n    return VALID_SCENES.charAt(scene);\r\n}"
}, {
	"Path": "nginx.clojure.asm.Type.getSize",
	"Comment": "returns the size of values of this type. this method must not be used formethod types.",
	"Method": "int getSize(){\r\n    return buf == null ? (off & 0xFF) : 1;\r\n}"
}, {
	"Path": "org.openhab.binding.pioneeravr.protocol.utils.DisplayInformationConverter.convertMessageFromIpControl",
	"Comment": "convert an ipcontrol information message payload to a readable string.",
	"Method": "String convertMessageFromIpControl(String responsePayload){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 2; i < responsePayload.length() - 1; i += 2) {\r\n        String hexAsciiValue = responsePayload.substring(i, i + 2);\r\n        try {\r\n            sb.append((char) Integer.parseInt(hexAsciiValue, 16));\r\n        } catch (Exception e) {\r\n            throw new AvrConnectionException(\"Failed to parse the reponsePayload as an IpControl information message.\", e);\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.openhab.binding.squeezebox.internal.handler.SqueezeBoxPlayerHandler.setNotificationSoundVolume",
	"Comment": "used by the audiosink to set the volume level that should be used to play the notification",
	"Method": "void setNotificationSoundVolume(PercentType newNotificationSoundVolume){\r\n    if (newNotificationSoundVolume != null) {\r\n        notificationSoundVolume = Integer.valueOf(newNotificationSoundVolume.intValue());\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.client.model.IssuerServiceResponse.shouldRedirect",
	"Comment": "if the redirect url has been set, then we should send a redirect using it instead of processing things.",
	"Method": "boolean shouldRedirect(){\r\n    return this.redirectUrl != null;\r\n}"
}, {
	"Path": "nginx.clojure.asm.Handler.remove",
	"Comment": "removes the range between start and end from the given exceptionhandlers.",
	"Method": "Handler remove(Handler h,Label start,Label end){\r\n    if (h == null) {\r\n        return null;\r\n    } else {\r\n        h.next = remove(h.next, start, end);\r\n    }\r\n    int hstart = h.start.position;\r\n    int hend = h.end.position;\r\n    int s = start.position;\r\n    int e = end == null ? Integer.MAX_VALUE : end.position;\r\n    if (s < hend && e > hstart) {\r\n        if (s <= hstart) {\r\n            if (e >= hend) {\r\n                h = h.next;\r\n            } else {\r\n                h.start = end;\r\n            }\r\n        } else if (e >= hend) {\r\n            h.end = start;\r\n        } else {\r\n            Handler g = new Handler();\r\n            g.start = end;\r\n            g.end = h.end;\r\n            g.handler = h.handler;\r\n            g.desc = h.desc;\r\n            g.type = h.type;\r\n            g.next = h.next;\r\n            h.end = start;\r\n            h.next = g;\r\n        }\r\n    }\r\n    return h;\r\n}"
}, {
	"Path": "nginx.clojure.asm.Type.getArgumentTypes",
	"Comment": "returns the argument types of methods of this type. this method shouldonly be used for method types.",
	"Method": "Type[] getArgumentTypes(String methodDescriptor,Type[] getArgumentTypes,Method method,Type[] getArgumentTypes){\r\n    return getArgumentTypes(getDescriptor());\r\n}"
}, {
	"Path": "org.mitre.openid.connect.web.DynamicClientRegistrationEndpoint.registerNewClient",
	"Comment": "create a new client, issue a client id, and create a registration access token.",
	"Method": "String registerNewClient(String jsonString,Model m){\r\n    ClientDetailsEntity newClient = null;\r\n    try {\r\n        newClient = ClientDetailsEntityJsonProcessor.parse(jsonString);\r\n    } catch (JsonSyntaxException e) {\r\n        logger.error(\"registerNewClient failed; submitted JSON is malformed\");\r\n        m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);\r\n        return HttpCodeView.VIEWNAME;\r\n    }\r\n    if (newClient != null) {\r\n        newClient.setClientId(null);\r\n        newClient.setClientSecret(null);\r\n        try {\r\n            newClient = validateSoftwareStatement(newClient);\r\n            newClient = validateScopes(newClient);\r\n            newClient = validateResponseTypes(newClient);\r\n            newClient = validateGrantTypes(newClient);\r\n            newClient = validateRedirectUris(newClient);\r\n            newClient = validateAuth(newClient);\r\n        } catch (ValidationException ve) {\r\n            m.addAttribute(JsonErrorView.ERROR, ve.getError());\r\n            m.addAttribute(JsonErrorView.ERROR_MESSAGE, ve.getErrorDescription());\r\n            m.addAttribute(HttpCodeView.CODE, ve.getStatus());\r\n            return JsonErrorView.VIEWNAME;\r\n        }\r\n        if (newClient.getTokenEndpointAuthMethod() == null) {\r\n            newClient.setTokenEndpointAuthMethod(AuthMethod.SECRET_BASIC);\r\n        }\r\n        if (newClient.getTokenEndpointAuthMethod() == AuthMethod.SECRET_BASIC || newClient.getTokenEndpointAuthMethod() == AuthMethod.SECRET_JWT || newClient.getTokenEndpointAuthMethod() == AuthMethod.SECRET_POST) {\r\n            newClient = clientService.generateClientSecret(newClient);\r\n        }\r\n        if (config.isHeartMode()) {\r\n            if (newClient.getGrantTypes().contains(\"authorization_code\")) {\r\n                newClient.setAccessTokenValiditySeconds((int) TimeUnit.HOURS.toSeconds(1));\r\n                newClient.setIdTokenValiditySeconds((int) TimeUnit.MINUTES.toSeconds(5));\r\n                newClient.setRefreshTokenValiditySeconds((int) TimeUnit.HOURS.toSeconds(24));\r\n            } else if (newClient.getGrantTypes().contains(\"implicit\")) {\r\n                newClient.setAccessTokenValiditySeconds((int) TimeUnit.MINUTES.toSeconds(15));\r\n                newClient.setIdTokenValiditySeconds((int) TimeUnit.MINUTES.toSeconds(5));\r\n                newClient.setRefreshTokenValiditySeconds(0);\r\n            } else if (newClient.getGrantTypes().contains(\"client_credentials\")) {\r\n                newClient.setAccessTokenValiditySeconds((int) TimeUnit.HOURS.toSeconds(6));\r\n                // no id tokens\r\n                newClient.setIdTokenValiditySeconds(0);\r\n                newClient.setRefreshTokenValiditySeconds(0);\r\n            }\r\n        } else {\r\n            newClient.setAccessTokenValiditySeconds((int) TimeUnit.HOURS.toSeconds(1));\r\n            newClient.setIdTokenValiditySeconds((int) TimeUnit.MINUTES.toSeconds(10));\r\n            newClient.setRefreshTokenValiditySeconds(null);\r\n        }\r\n        newClient.setDynamicallyRegistered(true);\r\n        newClient.setAllowIntrospection(false);\r\n        try {\r\n            ClientDetailsEntity savedClient = clientService.saveNewClient(newClient);\r\n            OAuth2AccessTokenEntity token = connectTokenService.createRegistrationAccessToken(savedClient);\r\n            token = tokenService.saveAccessToken(token);\r\n            RegisteredClient registered = new RegisteredClient(savedClient, token.getValue(), config.getIssuer() + \"register/\" + UriUtils.encodePathSegment(savedClient.getClientId(), \"UTF-8\"));\r\n            m.addAttribute(\"client\", registered);\r\n            // http 201\r\n            m.addAttribute(HttpCodeView.CODE, HttpStatus.CREATED);\r\n            return ClientInformationResponseView.VIEWNAME;\r\n        } catch (UnsupportedEncodingException e) {\r\n            logger.error(\"Unsupported encoding\", e);\r\n            m.addAttribute(HttpCodeView.CODE, HttpStatus.INTERNAL_SERVER_ERROR);\r\n            return HttpCodeView.VIEWNAME;\r\n        } catch (IllegalArgumentException e) {\r\n            logger.error(\"Couldn't save client\", e);\r\n            m.addAttribute(JsonErrorView.ERROR, \"invalid_client_metadata\");\r\n            m.addAttribute(JsonErrorView.ERROR_MESSAGE, \"Unable to save client due to invalid or inconsistent metadata.\");\r\n            m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);\r\n            return JsonErrorView.VIEWNAME;\r\n        }\r\n    } else {\r\n        logger.error(\"registerNewClient failed; submitted JSON is malformed\");\r\n        m.addAttribute(HttpCodeView.CODE, HttpStatus.BAD_REQUEST);\r\n        return HttpCodeView.VIEWNAME;\r\n    }\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Pair.fromArray",
	"Comment": "create tuple from array. array has to have exactly two elements.",
	"Method": "Pair<X, X> fromArray(X[] array){\r\n    if (array == null) {\r\n        throw new IllegalArgumentException(\"Array cannot be null\");\r\n    }\r\n    if (array.length != 2) {\r\n        throw new IllegalArgumentException(\"Array must have exactly 2 elements in order to create a Pair. Size is \" + array.length);\r\n    }\r\n    return new Pair<X, X>(array[0], array[1]);\r\n}"
}, {
	"Path": "org.openhab.binding.modbus.internal.AtomicStampedKeyValue.compare",
	"Comment": "compare two atomicstampedkeyvalue objects based on stampsnulls are ordered first",
	"Method": "int compare(AtomicStampedKeyValue x,AtomicStampedKeyValue y){\r\n    if (x == null) {\r\n        return -1;\r\n    } else if (y == null) {\r\n        return 1;\r\n    } else {\r\n        return Long.compare(x.stamp, y.stamp);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.pentair.internal.handler.PentairBaseBridgeHandler.findThing",
	"Comment": "helper function to find a thing assigned to this bridge with a specific pentair bus id.",
	"Method": "Thing findThing(int id){\r\n    List<Thing> things = getThing().getThings();\r\n    for (Thing t : things) {\r\n        PentairBaseThingHandler handler = (PentairBaseThingHandler) t.getHandler();\r\n        if (handler != null && handler.getPentairID() == id) {\r\n            return t;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openhab.io.neeo.internal.models.NeeoDevice.isExposed",
	"Comment": "determines if the given itemname has been exposed to the neeo brain or not",
	"Method": "boolean isExposed(String itemName){\r\n    NeeoUtil.requireNotEmpty(itemName, \"itemName cannot be empty\");\r\n    logger.trace(\"isExposed: {}\", itemName);\r\n    for (NeeoDeviceChannel channel : channels) {\r\n        final boolean notExcluded = channel.getType() != NeeoCapabilityType.EXCLUDE;\r\n        final boolean notEmpty = StringUtils.isNotEmpty(channel.getType().toString());\r\n        final boolean isItemMatch = StringUtils.equalsIgnoreCase(itemName, channel.getItemName());\r\n        logger.trace(\"isExposed(channel): {} --- notExcluded({}) -- notEmpty({}) -- isItemMatch({}) -- {}\", itemName, notExcluded, notEmpty, isItemMatch, channel);\r\n        if (notExcluded && notEmpty && isItemMatch) {\r\n            return true;\r\n        }\r\n    }\r\n    logger.trace(\"isExposed (FALSE): {}\", itemName);\r\n    return false;\r\n}"
}, {
	"Path": "org.openhab.binding.opensprinkler.internal.util.Parse.jsonIntAtArrayIndex",
	"Comment": "parses an int from a json array given its key name in the json string.",
	"Method": "int jsonIntAtArrayIndex(String jsonData,String keyName,int index){\r\n    JsonElement jelement = jsonParser.parse(jsonData);\r\n    JsonObject jobject = jelement.getAsJsonObject();\r\n    JsonArray jarray = jobject.get(keyName).getAsJsonArray();\r\n    return jarray.get(index).getAsInt();\r\n}"
}, {
	"Path": "org.openhab.binding.max.internal.message.MessageProcessor.pull",
	"Comment": "pulls the message from the stack when there is one available. this needsto be done before next line can be added into message processor. whenmessage is pulled, the message processor is reseted and ready to processnext line.",
	"Method": "Message pull(){\r\n    final Message result = this.currentMessage;\r\n    if (this.currentMessage == null) {\r\n        throw new NoMessageAvailableException();\r\n    }\r\n    reset();\r\n    return result;\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.device.DSMRDeviceRunnable.releaseSemaphore",
	"Comment": "wrapper around semaphore to only release when no permits available.",
	"Method": "void releaseSemaphore(){\r\n    synchronized (semaphore) {\r\n        if (semaphore.availablePermits() == 0) {\r\n            semaphore.release();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.milight.internal.protocol.QueuedSend.removeFromQueue",
	"Comment": "mark all commands in the queue invalid that have the same unique id as the given one. this does not synchronisewith the sender thread. if an element has been started to being processed, this method has no more effect on thatelement. command chains are always executed in a row. even if the head of the command queue has been markedas invalid, if the processing has been started, the chain will be processed completely.",
	"Method": "void removeFromQueue(int uniqueCommandId){\r\n    Iterator<QueueItem> iterator = queue.iterator();\r\n    while (iterator.hasNext()) {\r\n        try {\r\n            QueueItem item = iterator.next();\r\n            if (item.uniqueCommandId == uniqueCommandId) {\r\n                item.makeInvalid();\r\n            }\r\n        } catch (IllegalStateException e) {\r\n        } catch (NoSuchElementException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.toberemoved.cache.ExpiringCacheAsync.getCurrentNanoTime",
	"Comment": "returns an arbitrary time reference in nanoseconds.this is used for the cache to determine if a value has expired.",
	"Method": "long getCurrentNanoTime(){\r\n    return System.nanoTime();\r\n}"
}, {
	"Path": "org.openhab.io.hueemulation.internal.LightItems.setFilterTags",
	"Comment": "set filter tags. empty sets are allowed, items will not be filtered then.",
	"Method": "void setFilterTags(Set<String> switchFilter,Set<String> colorFilter,Set<String> whiteFilter){\r\n    this.switchFilter = switchFilter;\r\n    this.colorFilter = colorFilter;\r\n    this.whiteFilter = whiteFilter;\r\n}"
}, {
	"Path": "nginx.clojure.asm.Handle.getOwner",
	"Comment": "returns the internal name of the class that owns the field or methoddesignated by this handle.",
	"Method": "String getOwner(){\r\n    return owner;\r\n}"
}, {
	"Path": "nginx.clojure.Coroutine.yield",
	"Comment": "suspend the currently running coroutine on the calling thread.",
	"Method": "void yield(){\r\n    throw new Error(\"Calling function not instrumented\");\r\n}"
}, {
	"Path": "nginx.clojure.asm.MethodWriter.noSuccessor",
	"Comment": "ends the current basic block. this method must be used in the case wherethe current basic block does not have any successor.",
	"Method": "void noSuccessor(){\r\n    if (compute == FRAMES) {\r\n        Label l = new Label();\r\n        l.frame = new Frame();\r\n        l.frame.owner = l;\r\n        l.resolve(this, code.length, code.data);\r\n        previousBlock.successor = l;\r\n        previousBlock = l;\r\n    } else {\r\n        currentBlock.outputStackMax = maxStackSize;\r\n    }\r\n    currentBlock = null;\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.device.p1telegram.P1TelegramParser.handleUnexpectedCharacter",
	"Comment": "handles an unexpected character. the character will be logged and the current telegram is marked corrupted",
	"Method": "void handleUnexpectedCharacter(char c){\r\n    logger.debug(\"Unexpected character '{}' in state: {}. This P1 telegram is marked as failed\", c, state);\r\n    telegramState = TelegramState.DATA_CORRUPTION;\r\n}"
}, {
	"Path": "org.openhab.binding.max.internal.command.SCommand.getCommandString",
	"Comment": "returns the base64 encoded command string to be sent via the max!protocol.",
	"Method": "String getCommandString(){\r\n    final String baseString;\r\n    if (roomId == 0) {\r\n        baseString = BASE_STRING_S;\r\n    } else {\r\n        baseString = BASE_STRING_G;\r\n    }\r\n    final String commandString = baseString + rfAddress + Utils.toHex(roomId) + Utils.toHex(bits);\r\n    final String encodedString = Base64.encodeBase64String(Utils.hexStringToByteArray(commandString));\r\n    return \"s:\" + encodedString;\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.ifNonNull",
	"Comment": "generates the instruction to jump to the given label if the top stackvalue is not null.",
	"Method": "void ifNonNull(Label label){\r\n    mv.visitJumpInsn(Opcodes.IFNONNULL, label);\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.handler.YamahaBridgeHandler.initialize",
	"Comment": "calls createcommunicationobject if the host name is configured correctly.",
	"Method": "void initialize(){\r\n    zoneDiscoveryService = new ZoneDiscoveryService(bundleContext);\r\n    bridgeConfig = getConfigAs(YamahaBridgeConfig.class);\r\n    logger.trace(\"Initialize of {} with host '{}' and port {}\", getThing().getLabel(), bridgeConfig.getHost(), bridgeConfig.getPort());\r\n    Optional<String> host = bridgeConfig.getHostWithPort();\r\n    if (!host.isPresent()) {\r\n        String msg = \"Host or port not set. Double check your thing settings.\";\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, msg);\r\n        logger.warn(msg);\r\n        return;\r\n    }\r\n    protocolFactory.createConnection(host.get(), this);\r\n    inputConverter = protocolFactory.InputConverter(connection, bridgeConfig.getInputMapping());\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.loadArgArray",
	"Comment": "generates the instructions to load all the method arguments on the stack,as a single object array.",
	"Method": "void loadArgArray(){\r\n    push(argumentTypes.length);\r\n    newArray(OBJECT_TYPE);\r\n    for (int i = 0; i < argumentTypes.length; i++) {\r\n        dup();\r\n        push(i);\r\n        loadArg(i);\r\n        box(argumentTypes[i]);\r\n        arrayStore(OBJECT_TYPE);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.satel.internal.command.ReadEventDescCommand.getText",
	"Comment": "returns text of the description decoded using given encoding.encoding depends on firmware language and must be specified in the binding configuration.",
	"Method": "String getText(String encoding){\r\n    int length = isLongDescription() ? 46 : 16;\r\n    return new String(response.getPayload(), 5, length, encoding).trim();\r\n}"
}, {
	"Path": "org.openhab.binding.atlona.internal.pro3.AtlonaPro3Utilities.createChannelID",
	"Comment": "helper method to create a channel id from a group, port number and channel id",
	"Method": "String createChannelID(String group,String channelId,String createChannelID,String group,int portNbr,String channelId){\r\n    return group + portNbr + \"#\" + channelId;\r\n}"
}, {
	"Path": "org.openhab.binding.max.internal.device.HeatingThermostat.getValvePosition",
	"Comment": "returns the current valve position of this thermostat in percent.",
	"Method": "int getValvePosition(){\r\n    return this.valvePosition;\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.PresenceDetectionValue.setDetectionIsFinished",
	"Comment": "mark the result value as final. no modifications should occur after this call.",
	"Method": "void setDetectionIsFinished(boolean detectionIsFinished){\r\n    this.detectionIsFinished = detectionIsFinished;\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxServer.isChanged",
	"Comment": "checks if current miniserver configuration differs from provided parameters.",
	"Method": "boolean isChanged(InetAddress host,int port,String user,String password){\r\n    return (!(this.port == port && this.host.toString().equals(host.toString()) && this.user.equals(user) && this.password.equals(password)));\r\n}"
}, {
	"Path": "org.openhab.binding.loxone.internal.core.LxControlInfoOnlyAnalog.getValue",
	"Comment": "obtain current value of an analog virtual state, expressed as a number",
	"Method": "Double getValue(){\r\n    return getStateValue(STATE_VALUE);\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.JSRInlinerAdapter.emitCode",
	"Comment": "creates the new instructions, inlining each instantiation of eachsubroutine until the code is fully elaborated.",
	"Method": "void emitCode(){\r\n    LinkedList<Instantiation> worklist = new LinkedList<Instantiation>();\r\n    worklist.add(new Instantiation(null, mainSubroutine));\r\n    InsnList newInstructions = new InsnList();\r\n    List<TryCatchBlockNode> newTryCatchBlocks = new ArrayList<TryCatchBlockNode>();\r\n    List<LocalVariableNode> newLocalVariables = new ArrayList<LocalVariableNode>();\r\n    while (!worklist.isEmpty()) {\r\n        Instantiation inst = worklist.removeFirst();\r\n        emitSubroutine(inst, worklist, newInstructions, newTryCatchBlocks, newLocalVariables);\r\n    }\r\n    instructions = newInstructions;\r\n    tryCatchBlocks = newTryCatchBlocks;\r\n    localVariables = newLocalVariables;\r\n}"
}, {
	"Path": "org.mitre.jwt.signer.service.impl.DefaultJWTSigningAndValidationService.buildSignersAndVerifiers",
	"Comment": "build all of the signers and verifiers for this based on the key map.",
	"Method": "void buildSignersAndVerifiers(){\r\n    for (Map.Entry<String, JWK> jwkEntry : keys.entrySet()) {\r\n        String id = jwkEntry.getKey();\r\n        JWK jwk = jwkEntry.getValue();\r\n        try {\r\n            if (jwk instanceof RSAKey) {\r\n                if (jwk.isPrivate()) {\r\n                    RSASSASigner signer = new RSASSASigner((RSAKey) jwk);\r\n                    signers.put(id, signer);\r\n                }\r\n                RSASSAVerifier verifier = new RSASSAVerifier((RSAKey) jwk);\r\n                verifiers.put(id, verifier);\r\n            } else if (jwk instanceof ECKey) {\r\n                if (jwk.isPrivate()) {\r\n                    ECDSASigner signer = new ECDSASigner((ECKey) jwk);\r\n                    signers.put(id, signer);\r\n                }\r\n                ECDSAVerifier verifier = new ECDSAVerifier((ECKey) jwk);\r\n                verifiers.put(id, verifier);\r\n            } else if (jwk instanceof OctetSequenceKey) {\r\n                if (jwk.isPrivate()) {\r\n                    MACSigner signer = new MACSigner((OctetSequenceKey) jwk);\r\n                    signers.put(id, signer);\r\n                }\r\n                MACVerifier verifier = new MACVerifier((OctetSequenceKey) jwk);\r\n                verifiers.put(id, verifier);\r\n            } else {\r\n                logger.warn(\"Unknown key type: \" + jwk);\r\n            }\r\n        } catch (JOSEException e) {\r\n            logger.warn(\"Exception loading signer/verifier\", e);\r\n        }\r\n    }\r\n    if (defaultSignerKeyId == null && keys.size() == 1) {\r\n        setDefaultSignerKeyId(keys.keySet().iterator().next());\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.PresenceDetectionValue.getHostAddress",
	"Comment": "return the host address of the presence detection result object.",
	"Method": "String getHostAddress(){\r\n    return hostAddress;\r\n}"
}, {
	"Path": "org.apache.coyote.http11.NginxChannel.checkInterruptStatus",
	"Comment": "this method should be used to check the interrupt status beforeattempting a write.if a thread has been interrupted and the interrupt has not been clearedthen an attempt to write to the socket will fail. when this happens thesocket is removed from the poller without the socket being selected. thisresults in a connection limit leak for nio as the endpoint expects thesocket to be selected even in error conditions.",
	"Method": "void checkInterruptStatus(){\r\n    if (Thread.interrupted()) {\r\n        throw new IOException(sm.getString(\"channel.nio.interrupted\"));\r\n    }\r\n}"
}, {
	"Path": "org.mitre.oauth2.model.OAuth2AccessTokenEntity.getAdditionalInformation",
	"Comment": "get all additional information to be sent to the serializer as part of the token response.\tthis map is not persisted to the database.",
	"Method": "Map<String, Object> getAdditionalInformation(){\r\n    return additionalInformation;\r\n}"
}, {
	"Path": "nginx.clojure.asm.util.CheckMethodAdapter.checkNonDebugLabel",
	"Comment": "checks that the given label is not a label used only for debug purposes.",
	"Method": "void checkNonDebugLabel(Label label){\r\n    Field f = getLabelStatusField();\r\n    int status = 0;\r\n    try {\r\n        status = f == null ? 0 : ((Integer) f.get(label)).intValue();\r\n    } catch (IllegalAccessException e) {\r\n        throw new Error(\"Internal error\");\r\n    }\r\n    if ((status & 0x01) != 0) {\r\n        throw new IllegalArgumentException(\"Labels used for debug info cannot be reused for control flow\");\r\n    }\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.internal.pooling.ModbusSlaveConnectionFactoryImpl.disconnectOnReturn",
	"Comment": "disconnect returning connections which have been connected before certain time",
	"Method": "void disconnectOnReturn(ModbusSlaveEndpoint endpoint,long disconnectBeforeConnectedMillis){\r\n    disconnectIfConnectedBefore.put(endpoint, disconnectBeforeConnectedMillis);\r\n}"
}, {
	"Path": "org.openhab.binding.pioneeravr.protocol.utils.VolumeConverter.convertFromDbToIpControlVolume",
	"Comment": "return the string parameter to send to the avr based on the given volume.",
	"Method": "String convertFromDbToIpControlVolume(double volumeDb,int zone){\r\n    validateZone(zone - 1);\r\n    double ipControlVolume = ((MIN_DB_VOLUME[zone - 1] + volumeDb) * 2d) + 1d;\r\n    return formatIpControlVolume(ipControlVolume, zone);\r\n}"
}, {
	"Path": "org.openhab.binding.smartmeter.internal.conformity.negate.NegateHandler.isNegateSet",
	"Comment": "gets whether the bit at position negateposition is set or not.",
	"Method": "boolean isNegateSet(String value,int negatePosition){\r\n    long longValue = Long.parseLong(value);\r\n    return (longValue & (1L << negatePosition)) != 0;\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.PresenceDetectionValue.getReachableTCPports",
	"Comment": "return the reachable tcp ports of the presence detection value.thread safe.",
	"Method": "List<Integer> getReachableTCPports(){\r\n    synchronized (tcpServiceReachable) {\r\n        List<Integer> copy = new ArrayList();\r\n        copy.addAll(tcpServiceReachable);\r\n        return copy;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.powermax.internal.message.PowermaxCommManager.processPanelSettings",
	"Comment": "process and store all the panel settings from the raw buffers",
	"Method": "boolean processPanelSettings(boolean powerlinkMode){\r\n    return panelSettings.process(powerlinkMode, panelType, powerlinkMode ? syncTimeCheck : null);\r\n}"
}, {
	"Path": "nginx.clojure.asm.util.CheckClassAdapter.checkState",
	"Comment": "checks that the visit method has been called and that visitend has notbeen called.",
	"Method": "void checkState(){\r\n    if (!start) {\r\n        throw new IllegalStateException(\"Cannot visit member before visit has been called.\");\r\n    }\r\n    if (end) {\r\n        throw new IllegalStateException(\"Cannot visit member after visitEnd has been called.\");\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.russound.internal.rio.source.RioSourceProtocol.handleBankNotification",
	"Comment": "handles any bank notifications returned by the russound system",
	"Method": "void handleBankNotification(Matcher m,String resp){\r\n    if (m == null) {\r\n        throw new IllegalArgumentException(\"m (matcher) cannot be null\");\r\n    }\r\n    if (m.groupCount() == 4) {\r\n        try {\r\n            final int bank = Integer.parseInt(m.group(2));\r\n            if (bank >= 1 && bank <= 6) {\r\n                final int notifySource = Integer.parseInt(m.group(1));\r\n                if (notifySource != source) {\r\n                    return;\r\n                }\r\n                final String key = m.group(3).toLowerCase();\r\n                final String value = m.group(4);\r\n                switch(key) {\r\n                    case BANK_NAME:\r\n                        banks[bank - 1].setName(value);\r\n                        updateBanksChannel();\r\n                        break;\r\n                    default:\r\n                        logger.warn(\"Unknown bank name notification: '{}'\", resp);\r\n                        break;\r\n                }\r\n            } else {\r\n                logger.debug(\"Bank ID must be between 1 and 6: {}\", resp);\r\n            }\r\n        } catch (NumberFormatException e) {\r\n            logger.warn(\"Invalid Bank Name Notification (bank/source not a parsable integer): '{}')\", resp);\r\n        }\r\n    } else {\r\n        logger.warn(\"Invalid Bank Notification: '{}')\", resp);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.nest.internal.NestHandlerFactory.removeHandler",
	"Comment": "removes the handler for the specific thing. this also handles disabling the discoveryservice when the bridge is removed.",
	"Method": "void removeHandler(ThingHandler thingHandler){\r\n    if (thingHandler instanceof NestBridgeHandler) {\r\n        ServiceRegistration<?> reg = discoveryService.get(thingHandler.getThing().getUID());\r\n        if (reg != null) {\r\n            NestDiscoveryService service = (NestDiscoveryService) bundleContext.getService(reg.getReference());\r\n            service.deactivate();\r\n            reg.unregister();\r\n            discoveryService.remove(thingHandler.getThing().getUID());\r\n        }\r\n    }\r\n    super.removeHandler(thingHandler);\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.handler.DSMRMeterHandler.telegramReceived",
	"Comment": "callback for received meter values. when this method is called but the telegram has no values for this meter thismeter is set to offline because something is wrong, possible the meter has been removed.",
	"Method": "void telegramReceived(P1Telegram telegram){\r\n    lastReceivedValues = Collections.emptyList();\r\n    DSMRMeter localMeter = meter;\r\n    if (localMeter == null) {\r\n        return;\r\n    }\r\n    List<CosemObject> filteredValues = localMeter.filterMeterValues(telegram.getCosemObjects());\r\n    if (filteredValues.isEmpty()) {\r\n        if (getThing().getStatus() == ThingStatus.ONLINE) {\r\n            setDeviceOffline(ThingStatusDetail.COMMUNICATION_ERROR, \"@text/error.thing.nodata\");\r\n        }\r\n    } else {\r\n        if (logger.isTraceEnabled()) {\r\n            logger.trace(\"Received {} objects for {}\", filteredValues.size(), getThing().getThingTypeUID().getId());\r\n        }\r\n        lastReceivedValues = filteredValues;\r\n        if (getThing().getStatus() != ThingStatus.ONLINE) {\r\n            updateState();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.phc.internal.handler.PHCBridgeHandler.serialEvent",
	"Comment": "puts the available data on serial port into a buffer and transfer it to the processing method.",
	"Method": "void serialEvent(SerialPortEvent event){\r\n    if (event.getEventType() != SerialPortEvent.DATA_AVAILABLE) {\r\n        return;\r\n    }\r\n    byte[] buffer;\r\n    try {\r\n        if (serialIn.available() <= 0) {\r\n            return;\r\n        }\r\n        Thread.sleep(5);\r\n        buffer = new byte[serialIn.available()];\r\n        serialIn.read(buffer);\r\n        if (messageFragment != null) {\r\n            processInputStream(ArrayUtils.addAll(messageFragment, buffer));\r\n        } else {\r\n            processInputStream(buffer);\r\n        }\r\n    } catch (IOException e) {\r\n    } catch (InterruptedException e) {\r\n        Thread.currentThread().interrupt();\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.gardena.internal.config.GardenaConfig.setRefresh",
	"Comment": "returns the refresh interval to fetch new data from gardena smart home.",
	"Method": "void setRefresh(Integer refresh){\r\n    this.refresh = refresh;\r\n}"
}, {
	"Path": "org.openhab.binding.gardena.internal.config.GardenaConfig.getRefresh",
	"Comment": "returns the refresh interval to fetch new data from gardena smart home.",
	"Method": "Integer getRefresh(){\r\n    return refresh;\r\n}"
}, {
	"Path": "org.openhab.binding.plclogo.internal.config.PLCLogoBridgeConfiguration.getRefreshRate",
	"Comment": "get configured refresh rate of siemens logo! device blocks in milliseconds.",
	"Method": "Integer getRefreshRate(){\r\n    return refresh;\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.device.DSMRSerialAutoDevice.endTimeScheduledCall",
	"Comment": "stops the discovery process as triggered by the end timer. it will only act if the discovery process was stillrunning.",
	"Method": "void endTimeScheduledCall(){\r\n    if (state == DeviceState.DISCOVER_SETTINGS) {\r\n        stopDiscover(DeviceState.ERROR);\r\n        parentListener.handleErrorEvent(DSMRConnectorErrorEvent.DONT_EXISTS);\r\n    }\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Octet.fromCollection",
	"Comment": "create tuple from collection. collection has to have exactly eight elements.",
	"Method": "Octet<X, X, X, X, X, X, X, X> fromCollection(Collection<X> collection){\r\n    return fromIterable(collection);\r\n}"
}, {
	"Path": "org.openhab.io.neeo.internal.NeeoUtil.getUniqueLabel",
	"Comment": "returns the unique label name given a set of labels. the unique label will be added to the set of labels.",
	"Method": "String getUniqueLabel(Set<String> labels,String itemLabel){\r\n    Objects.requireNonNull(labels, \"labels cannot be null\");\r\n    String label = StringUtils.isEmpty(itemLabel) ? \"NA\" : itemLabel;\r\n    int idx = 0;\r\n    if (labels.contains(label)) {\r\n        do {\r\n            idx++;\r\n        } while (labels.contains(label + \".\" + idx));\r\n        label = label + \".\" + idx;\r\n    }\r\n    labels.add(label);\r\n    return label;\r\n}"
}, {
	"Path": "nginx.clojure.asm.tree.analysis.SimpleVerifier.setClassLoader",
	"Comment": "set the classloader which will be used to load referencedclasses. this is useful if you are verifying multiple interdependentclasses.",
	"Method": "void setClassLoader(ClassLoader loader){\r\n    this.loader = loader;\r\n}"
}, {
	"Path": "org.openhab.binding.opensprinkler.internal.util.Parse.jsonStringAtArrayIndex",
	"Comment": "parses a string from a json array given its key name in the json string.",
	"Method": "String jsonStringAtArrayIndex(String jsonData,String keyName,int index){\r\n    JsonElement jelement = jsonParser.parse(jsonData);\r\n    JsonObject jobject = jelement.getAsJsonObject();\r\n    JsonArray jarray = jobject.get(keyName).getAsJsonArray();\r\n    return jarray.get(index).getAsString();\r\n}"
}, {
	"Path": "org.openhab.io.neeo.internal.ServiceContext.isExposeNeeoBinding",
	"Comment": "helper method to determine if things from the neeo binding should be exposed",
	"Method": "boolean isExposeNeeoBinding(){\r\n    final Object cfgExpose = getComponentContext().getProperties().get(NeeoConstants.CFG_EXPOSENEEOBINDING);\r\n    return cfgExpose == null ? true : Boolean.parseBoolean(cfgExpose.toString());\r\n}"
}, {
	"Path": "nginx.clojure.asm.Frame.set",
	"Comment": "sets the output frame local variable type at the given index.",
	"Method": "void set(int local,int type){\r\n    if (outputLocals == null) {\r\n        outputLocals = new int[10];\r\n    }\r\n    int n = outputLocals.length;\r\n    if (local >= n) {\r\n        int[] t = new int[Math.max(local + 1, 2 * n)];\r\n        System.arraycopy(outputLocals, 0, t, 0, n);\r\n        outputLocals = t;\r\n    }\r\n    outputLocals[local] = type;\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Pair.fromIterable",
	"Comment": "create tuple from iterable. iterable has to have exactly two elements.",
	"Method": "Pair<X, X> fromIterable(Iterable<X> iterable,Pair<X, X> fromIterable,Iterable<X> iterable,int index,Pair<X, X> fromIterable,Iterable<X> iterable,int index,boolean exactSize){\r\n    if (iterable == null) {\r\n        throw new IllegalArgumentException(\"Iterable cannot be null\");\r\n    }\r\n    boolean tooFewElements = false;\r\n    X element0 = null;\r\n    X element1 = null;\r\n    final Iterator<X> iter = iterable.iterator();\r\n    int i = 0;\r\n    while (i < index) {\r\n        if (iter.hasNext()) {\r\n            iter.next();\r\n        } else {\r\n            tooFewElements = true;\r\n        }\r\n        i++;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element0 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element1 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (tooFewElements && exactSize) {\r\n        throw new IllegalArgumentException(\"Not enough elements for creating a Pair (2 needed)\");\r\n    }\r\n    if (iter.hasNext() && exactSize) {\r\n        throw new IllegalArgumentException(\"Iterable must have exactly 2 available elements in order to create a Pair.\");\r\n    }\r\n    return new Pair<X, X>(element0, element1);\r\n}"
}, {
	"Path": "org.openhab.binding.evohome.handler.BaseEvohomeHandler.checkConfig",
	"Comment": "checks the configuration for validity, result is reflected in the status of the thing",
	"Method": "void checkConfig(){\r\n    if (configuration == null) {\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Configuration is missing or corrupted\");\r\n    } else if (StringUtils.isEmpty(configuration.id)) {\r\n        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Id not configured\");\r\n    }\r\n}"
}, {
	"Path": "org.openhab.io.hueemulation.internal.ConfigManagement.checkPairingTimeout",
	"Comment": "starts a pairing timeout thread if datastore.config.linkbutton is set to true.stops any already setup timer.",
	"Method": "void checkPairingTimeout(){\r\n    stopPairingTimeoutThread();\r\n    if (dataStore.config.linkbutton) {\r\n        logger.info(\"Hue Emulation pairing enabled for {}s at {}\", dataStore.config.networkopenduration, RESTApi.PATH);\r\n        Thread thread = new Thread(() -> {\r\n            try {\r\n                Thread.sleep(dataStore.config.networkopenduration * 1000);\r\n                org.osgi.service.cm.Configuration configuration = configAdmin.getConfiguration(\"org.openhab.hueemulation\");\r\n                Dictionary<String, Object> dictionary = configuration.getProperties();\r\n                dictionary.put(HueEmulationConfig.CONFIG_PAIRING_ENABLED, false);\r\n                dictionary.put(HueEmulationConfig.CONFIG_CREATE_NEW_USER_ON_THE_FLY, false);\r\n                configuration.update(dictionary);\r\n            } catch (IOException | InterruptedException ignore) {\r\n            }\r\n        });\r\n        pairingTimeoutThread = thread;\r\n        thread.start();\r\n    } else {\r\n        logger.info(\"Hue Emulation pairing disabled. Service available under {}\", RESTApi.PATH);\r\n    }\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Septet.fromIterable",
	"Comment": "create tuple from iterable. iterable has to have exactly seven elements.",
	"Method": "Septet<X, X, X, X, X, X, X> fromIterable(Iterable<X> iterable,Septet<X, X, X, X, X, X, X> fromIterable,Iterable<X> iterable,int index,Septet<X, X, X, X, X, X, X> fromIterable,Iterable<X> iterable,int index,boolean exactSize){\r\n    if (iterable == null) {\r\n        throw new IllegalArgumentException(\"Iterable cannot be null\");\r\n    }\r\n    boolean tooFewElements = false;\r\n    X element0 = null;\r\n    X element1 = null;\r\n    X element2 = null;\r\n    X element3 = null;\r\n    X element4 = null;\r\n    X element5 = null;\r\n    X element6 = null;\r\n    final Iterator<X> iter = iterable.iterator();\r\n    int i = 0;\r\n    while (i < index) {\r\n        if (iter.hasNext()) {\r\n            iter.next();\r\n        } else {\r\n            tooFewElements = true;\r\n        }\r\n        i++;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element0 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element1 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element2 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element3 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element4 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element5 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element6 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (tooFewElements && exactSize) {\r\n        throw new IllegalArgumentException(\"Not enough elements for creating a Septet (7 needed)\");\r\n    }\r\n    if (iter.hasNext() && exactSize) {\r\n        throw new IllegalArgumentException(\"Iterable must have exactly 7 available elements in order to create a Septet.\");\r\n    }\r\n    return new Septet<X, X, X, X, X, X, X>(element0, element1, element2, element3, element4, element5, element6);\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Sextet.fromCollection",
	"Comment": "create tuple from collection. collection has to have exactly six elements.",
	"Method": "Sextet<X, X, X, X, X, X> fromCollection(Collection<X> collection){\r\n    return fromIterable(collection);\r\n}"
}, {
	"Path": "org.mitre.oauth2.model.ClientDetailsEntity.getIdTokenValiditySeconds",
	"Comment": "number of seconds id token is valid for. must be a positive integer, can not be null.",
	"Method": "Integer getIdTokenValiditySeconds(){\r\n    return idTokenValiditySeconds;\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Ennead.fromIterable",
	"Comment": "create tuple from iterable. iterable has to have exactly nine elements.",
	"Method": "Ennead<X, X, X, X, X, X, X, X, X> fromIterable(Iterable<X> iterable,Ennead<X, X, X, X, X, X, X, X, X> fromIterable,Iterable<X> iterable,int index,Ennead<X, X, X, X, X, X, X, X, X> fromIterable,Iterable<X> iterable,int index,boolean exactSize){\r\n    if (iterable == null) {\r\n        throw new IllegalArgumentException(\"Iterable cannot be null\");\r\n    }\r\n    boolean tooFewElements = false;\r\n    X element0 = null;\r\n    X element1 = null;\r\n    X element2 = null;\r\n    X element3 = null;\r\n    X element4 = null;\r\n    X element5 = null;\r\n    X element6 = null;\r\n    X element7 = null;\r\n    X element8 = null;\r\n    final Iterator<X> iter = iterable.iterator();\r\n    int i = 0;\r\n    while (i < index) {\r\n        if (iter.hasNext()) {\r\n            iter.next();\r\n        } else {\r\n            tooFewElements = true;\r\n        }\r\n        i++;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element0 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element1 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element2 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element3 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element4 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element5 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element6 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element7 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element8 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (tooFewElements && exactSize) {\r\n        throw new IllegalArgumentException(\"Not enough elements for creating an Ennead (9 needed)\");\r\n    }\r\n    if (iter.hasNext() && exactSize) {\r\n        throw new IllegalArgumentException(\"Iterable must have exactly 9 available elements in order to create an Ennead.\");\r\n    }\r\n    return new Ennead<X, X, X, X, X, X, X, X, X>(element0, element1, element2, element3, element4, element5, element6, element7, element8);\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.SerialVersionUIDAdder.visitField",
	"Comment": "gets class field information for step 4 of the algorithm. also determinesif the class already has a svuid.",
	"Method": "FieldVisitor visitField(int access,String name,String desc,String signature,Object value){\r\n    if (computeSVUID) {\r\n        if (\"serialVersionUID\".equals(name)) {\r\n            computeSVUID = false;\r\n            hasSVUID = true;\r\n        }\r\n        if ((access & Opcodes.ACC_PRIVATE) == 0 || (access & (Opcodes.ACC_STATIC | Opcodes.ACC_TRANSIENT)) == 0) {\r\n            int mods = access & (Opcodes.ACC_PUBLIC | Opcodes.ACC_PRIVATE | Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC | Opcodes.ACC_FINAL | Opcodes.ACC_VOLATILE | Opcodes.ACC_TRANSIENT);\r\n            svuidFields.add(new Item(name, mods, desc));\r\n        }\r\n    }\r\n    return super.visitField(access, name, desc, signature, value);\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Unit.fromIterable",
	"Comment": "create tuple from iterable. iterable has to have exactly one element.",
	"Method": "Unit<X> fromIterable(Iterable<X> iterable,Unit<X> fromIterable,Iterable<X> iterable,int index,Unit<X> fromIterable,Iterable<X> iterable,int index,boolean exactSize){\r\n    if (iterable == null) {\r\n        throw new IllegalArgumentException(\"Iterable cannot be null\");\r\n    }\r\n    boolean tooFewElements = false;\r\n    X element0 = null;\r\n    final Iterator<X> iter = iterable.iterator();\r\n    int i = 0;\r\n    while (i < index) {\r\n        if (iter.hasNext()) {\r\n            iter.next();\r\n        } else {\r\n            tooFewElements = true;\r\n        }\r\n        i++;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element0 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (tooFewElements && exactSize) {\r\n        throw new IllegalArgumentException(\"Not enough elements for creating a Unit (1 needed)\");\r\n    }\r\n    if (iter.hasNext() && exactSize) {\r\n        throw new IllegalArgumentException(\"Iterable must have exactly 1 available element in order to create a Unit.\");\r\n    }\r\n    return new Unit<X>(element0);\r\n}"
}, {
	"Path": "nginx.clojure.asm.tree.analysis.Frame.getLocals",
	"Comment": "returns the maximum number of local variables of this frame.",
	"Method": "int getLocals(){\r\n    return locals;\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassWriter.newDouble",
	"Comment": "adds a double to the constant pool of the class being build. does nothingif the constant pool already contains a similar item.",
	"Method": "Item newDouble(double value){\r\n    key.set(value);\r\n    Item result = get(key);\r\n    if (result == null) {\r\n        pool.putByte(DOUBLE).putLong(key.longVal);\r\n        result = new Item(index, key);\r\n        index += 2;\r\n        put(result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "nginx.clojure.asm.Attribute.getCount",
	"Comment": "returns the length of the attribute list that begins with this attribute.",
	"Method": "int getCount(){\r\n    int count = 0;\r\n    Attribute attr = this;\r\n    while (attr != null) {\r\n        count += 1;\r\n        attr = attr.next;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "org.mitre.oauth2.model.ClientDetailsEntity.isScoped",
	"Comment": "if the scope list is not null or empty, then this client has been scoped.",
	"Method": "boolean isScoped(){\r\n    return getScope() != null && !getScope().isEmpty();\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.DefaultOAuth2AuthorizationCodeService.consumeAuthorizationCode",
	"Comment": "consume a given authorization code.\tmatch the provided string to an authorizationcodeentity. if one is found, return\tthe authentication associated with the code. if one is not found, throw an\tinvalidgrantexception.",
	"Method": "OAuth2Authentication consumeAuthorizationCode(String code){\r\n    AuthorizationCodeEntity result = repository.getByCode(code);\r\n    if (result == null) {\r\n        throw new InvalidGrantException(\"JpaAuthorizationCodeRepository: no authorization code found for value \" + code);\r\n    }\r\n    OAuth2Authentication auth = result.getAuthenticationHolder().getAuthentication();\r\n    repository.remove(result);\r\n    return auth;\r\n}"
}, {
	"Path": "org.openhab.binding.gardena.internal.discovery.GardenaDeviceDiscoveryService.loadDevices",
	"Comment": "starts a thread which loads all gardena devices registered in the account",
	"Method": "void loadDevices(){\r\n    if (scanFuture == null) {\r\n        scanFuture = scheduler.submit(() -> {\r\n            try {\r\n                GardenaSmart gardena = accountHandler.getGardenaSmart();\r\n                gardena.loadAllDevices();\r\n                for (Location location : gardena.getLocations()) {\r\n                    for (String deviceId : location.getDeviceIds()) {\r\n                        deviceDiscovered(gardena.getDevice(deviceId));\r\n                    }\r\n                }\r\n                for (Thing thing : accountHandler.getThing().getThings()) {\r\n                    try {\r\n                        gardena.getDevice(UidUtils.getGardenaDeviceId(thing));\r\n                    } catch (GardenaException ex) {\r\n                        thingRemoved(thing.getUID());\r\n                    }\r\n                }\r\n                logger.debug(\"Finished Gardena device discovery scan on gateway '{}'\", accountHandler.getGardenaSmart().getId());\r\n            } catch (GardenaException ex) {\r\n                logger.error(\"{}\", ex.getMessage(), ex);\r\n            } finally {\r\n                scanFuture = null;\r\n                removeOlderResults(getTimestampOfLastScan());\r\n            }\r\n        });\r\n    } else {\r\n        logger.debug(\"Gardena device discovery scan in progress\");\r\n    }\r\n}"
}, {
	"Path": "org.openhab.voice.kaldi.internal.RecognitionEventListenerKaldi.getSTTEvent",
	"Comment": "utility method to create a sttevent from a successful, final recognitionevent",
	"Method": "STTEvent getSTTEvent(RecognitionEvent recognitionEvent){\r\n    RecognitionEvent.Result result = recognitionEvent.getResult();\r\n    List<RecognitionEvent.Hypothesis> hypotheses = result.getHypotheses();\r\n    float confidence = -1.0f;\r\n    String transcript = new String();\r\n    for (RecognitionEvent.Hypothesis hypothesis : hypotheses) {\r\n        if (confidence < hypothesis.getConfidence()) {\r\n            confidence = hypothesis.getConfidence();\r\n            transcript = hypothesis.getTranscript();\r\n        }\r\n    }\r\n    return new SpeechRecognitionEvent(transcript, confidence);\r\n}"
}, {
	"Path": "org.openhab.voice.kaldi.internal.STTServiceKaldiRunnable.run",
	"Comment": "this method sends audiosource data in the wsduplexrecognitionsession",
	"Method": "void run(){\r\n    try {\r\n        this.recognitionSession.connect();\r\n        AudioFormat audioFormat = this.audioStream.getFormat();\r\n        int bitRate = audioFormat.getBitRate().intValue();\r\n        int byteRate = (bitRate / 8);\r\n        int chunkRate = 4;\r\n        byte[] buffer = new byte[byteRate / chunkRate];\r\n        sttListener.sttEventReceived(new RecognitionStartEvent());\r\n        boolean sentLastChunk = false;\r\n        while (!this.isAborting && !this.isClosed) {\r\n            long millisWithinChunkSecond = System.currentTimeMillis() % (1000 / chunkRate);\r\n            int size = audioStream.read(buffer);\r\n            if (size < 0) {\r\n                sentLastChunk = true;\r\n                byte[] buffer2 = new byte[0];\r\n                this.recognitionSession.sendChunk(buffer2, true);\r\n                break;\r\n            }\r\n            if (size == (byteRate / chunkRate)) {\r\n                this.recognitionSession.sendChunk(buffer, false);\r\n            } else {\r\n                sentLastChunk = true;\r\n                byte[] buffer2 = Arrays.copyOf(buffer, size);\r\n                this.recognitionSession.sendChunk(buffer2, true);\r\n                break;\r\n            }\r\n            Thread.sleep(1000 / chunkRate - millisWithinChunkSecond);\r\n        }\r\n        if (this.isAborting && !this.isClosed && !sentLastChunk) {\r\n            byte[] buffer2 = new byte[0];\r\n            this.recognitionSession.sendChunk(buffer2, true);\r\n        }\r\n    } catch (IOException e) {\r\n        sttListener.sttEventReceived(new SpeechRecognitionErrorEvent(\"Unable to send audio data to the server\"));\r\n    } catch (InterruptedException e) {\r\n        sttListener.sttEventReceived(new SpeechRecognitionErrorEvent(\"Unable to send data to the server at the proper rate\"));\r\n    } catch (RuntimeException e) {\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.protocol.xml.DeviceDescriptorXML.hasFeature",
	"Comment": "checks if the condition is met, on false result calls the runnable.",
	"Method": "boolean hasFeature(Predicate<DeviceDescriptorXML> predicate,Runnable falseAction){\r\n    boolean result = predicate.test(this);\r\n    if (!result) {\r\n        falseAction.run();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.loadInsn",
	"Comment": "generates the instruction to push a local variable on the stack.",
	"Method": "void loadInsn(Type type,int index){\r\n    mv.visitVarInsn(type.getOpcode(Opcodes.ILOAD), index);\r\n}"
}, {
	"Path": "org.openhab.binding.tplinksmarthome.internal.CryptUtilTest.testCryptWithLength",
	"Comment": "test round trip of encrypt and decrypt with length that should return the same value.",
	"Method": "void testCryptWithLength(){\r\n    try (final ByteArrayInputStream is = new ByteArrayInputStream(CryptUtil.encryptWithLength(TEST_STRING))) {\r\n        assertEquals(\"Crypting should result in same string\", TEST_STRING, CryptUtil.decryptWithLength(is));\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassVisitor.visitEnd",
	"Comment": "visits the end of the class. this method, which is the last one to becalled, is used to inform the visitor that all the fields and methods ofthe class have been visited.",
	"Method": "void visitEnd(){\r\n    if (cv != null) {\r\n        cv.visitEnd();\r\n    }\r\n}"
}, {
	"Path": "geometry.math.AngleUtil.getTurn",
	"Comment": "returns the orientation of the angle formed by the two edges.\tnote that the result is approximated to 0.001.",
	"Method": "int getTurn(Point2D p0,Point2D p1,Point2D q){\r\n    double turn = p1.getSubtraction(p0).getDeterminant(q.getSubtraction(p1));\r\n    if (turn > PrecisionUtil.APPROX) {\r\n        return COUNTERCLOCKWISE;\r\n    } else if (turn < -PrecisionUtil.APPROX) {\r\n        return CLOCKWISE;\r\n    } else {\r\n        return NONE;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.powermax.internal.message.PowermaxCommManager.sendZoneBypass",
	"Comment": "send a message to the powermax alarm panel to bypass a zone or to not bypass a zone",
	"Method": "boolean sendZoneBypass(boolean bypass,byte zone,String pinCode){\r\n    logger.debug(\"sendZoneBypass(): bypass = {}, zone = {}\", bypass ? \"true\" : \"false\", zone);\r\n    boolean done = false;\r\n    if ((pinCode == null) || (pinCode.length() != 4)) {\r\n        logger.debug(\"Powermax alarm binding: zone bypass rejected due to invalid PIN code\");\r\n    } else if ((zone < 1) || (zone > panelSettings.getNbZones())) {\r\n        logger.debug(\"Powermax alarm binding: invalid zone number: {}\", zone);\r\n    } else {\r\n        try {\r\n            int val = (1 << (zone - 1));\r\n            byte[] dynPart = new byte[10];\r\n            dynPart[0] = (byte) Integer.parseInt(pinCode.substring(0, 2), 16);\r\n            dynPart[1] = (byte) Integer.parseInt(pinCode.substring(2, 4), 16);\r\n            int i;\r\n            for (i = 2; i < 10; i++) {\r\n                dynPart[i] = 0;\r\n            }\r\n            i = bypass ? 2 : 6;\r\n            dynPart[i++] = (byte) (val & 0x000000FF);\r\n            dynPart[i++] = (byte) ((val >> 8) & 0x000000FF);\r\n            dynPart[i++] = (byte) ((val >> 16) & 0x000000FF);\r\n            dynPart[i++] = (byte) ((val >> 24) & 0x000000FF);\r\n            done = sendMessage(new PowermaxBaseMessage(PowermaxSendType.BYPASS, dynPart), false, 0);\r\n            if (done) {\r\n                done = sendMessage(new PowermaxBaseMessage(PowermaxSendType.BYPASSTAT), false, 0);\r\n            }\r\n        } catch (NumberFormatException e) {\r\n            logger.debug(\"Powermax alarm binding: zone bypass rejected due to invalid PIN code\");\r\n        }\r\n    }\r\n    return done;\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.test.SmokeTest.testRegularReadEvery150msWithHolding",
	"Comment": "testing regular polling of holding registersamount of requests is timed, and average poll period is checked",
	"Method": "void testRegularReadEvery150msWithHolding(){\r\n    generateData();\r\n    ModbusSlaveEndpoint endpoint = getEndpoint();\r\n    AtomicInteger unexpectedCount = new AtomicInteger();\r\n    CountDownLatch callbackCalled = new CountDownLatch(5);\r\n    AtomicInteger dataReceived = new AtomicInteger();\r\n    BasicPollTaskImpl task = new BasicPollTaskImpl(endpoint, new BasicModbusReadRequestBlueprint(SLAVE_UNIT_ID, ModbusReadFunctionCode.READ_MULTIPLE_REGISTERS, 1, 15, 1), new ModbusReadCallback() {\r\n        @Override\r\n        public void onRegisters(ModbusReadRequestBlueprint request, ModbusRegisterArray registers) {\r\n            dataReceived.incrementAndGet();\r\n            try {\r\n                assertThat(registers.size(), is(equalTo(15)));\r\n                testHoldingValues(registers, 1);\r\n            } catch (AssertionError e) {\r\n                unexpectedCount.incrementAndGet();\r\n            }\r\n            callbackCalled.countDown();\r\n        }\r\n        @Override\r\n        public void onError(ModbusReadRequestBlueprint request, Exception error) {\r\n            unexpectedCount.incrementAndGet();\r\n            callbackCalled.countDown();\r\n        }\r\n        @Override\r\n        public void onBits(ModbusReadRequestBlueprint request, BitArray bits) {\r\n            unexpectedCount.incrementAndGet();\r\n            callbackCalled.countDown();\r\n        }\r\n    });\r\n    long start = System.currentTimeMillis();\r\n    modbusManager.registerRegularPoll(task, 150, 0);\r\n    callbackCalled.await(5, TimeUnit.SECONDS);\r\n    long end = System.currentTimeMillis();\r\n    assertPollDetails(unexpectedCount, dataReceived, start, end, 145, 500);\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.test.SmokeTest.testRegularReadEvery150msWithHolding",
	"Comment": "testing regular polling of holding registersamount of requests is timed, and average poll period is checked",
	"Method": "void testRegularReadEvery150msWithHolding(){\r\n    dataReceived.incrementAndGet();\r\n    try {\r\n        assertThat(registers.size(), is(equalTo(15)));\r\n        testHoldingValues(registers, 1);\r\n    } catch (AssertionError e) {\r\n        unexpectedCount.incrementAndGet();\r\n    }\r\n    callbackCalled.countDown();\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.test.SmokeTest.testRegularReadEvery150msWithHolding",
	"Comment": "testing regular polling of holding registersamount of requests is timed, and average poll period is checked",
	"Method": "void testRegularReadEvery150msWithHolding(){\r\n    unexpectedCount.incrementAndGet();\r\n    callbackCalled.countDown();\r\n}"
}, {
	"Path": "org.openhab.io.transport.modbus.test.SmokeTest.testRegularReadEvery150msWithHolding",
	"Comment": "testing regular polling of holding registersamount of requests is timed, and average poll period is checked",
	"Method": "void testRegularReadEvery150msWithHolding(){\r\n    unexpectedCount.incrementAndGet();\r\n    callbackCalled.countDown();\r\n}"
}, {
	"Path": "org.openhab.binding.modbus.internal.Transformation.transformState",
	"Comment": "transform state to another state using this transformation",
	"Method": "State transformState(BundleContext context,List<Class<? extends State>> types,State state){\r\n    final String stateAsString = state.toString();\r\n    final String transformed = transform(context, stateAsString);\r\n    return TypeParser.parseState(types, transformed);\r\n}"
}, {
	"Path": "nginx.clojure.Coroutine.getActiveCoroutine",
	"Comment": "returns the active coroutine on this thread or null if no coroutine is running.",
	"Method": "Coroutine getActiveCoroutine(){\r\n    Stack s = Stack.getStack();\r\n    if (s != null) {\r\n        return s.co;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.openhab.binding.gpstracker.internal.GPSTrackerHandlerFactory.activate",
	"Comment": "activate the binding. it starts the tracker discovery service and the http callback endpoint.",
	"Method": "void activate(ComponentContext componentContext){\r\n    super.activate(componentContext);\r\n    logger.debug(\"Initializing callback servlets\");\r\n    try {\r\n        otHTTPEndpoint = new OwnTracksCallbackServlet(discoveryService, this);\r\n        this.httpService.registerServlet(otHTTPEndpoint.getPath(), otHTTPEndpoint, null, this.httpService.createDefaultHttpContext());\r\n        logger.debug(\"Started GPSTracker Callback servlet on {}\", otHTTPEndpoint.getPath());\r\n        glHTTPEndpoint = new GPSLoggerCallbackServlet(discoveryService, this);\r\n        this.httpService.registerServlet(glHTTPEndpoint.getPath(), glHTTPEndpoint, null, this.httpService.createDefaultHttpContext());\r\n        logger.debug(\"Started GPSTracker Callback servlet on {}\", glHTTPEndpoint.getPath());\r\n    } catch (NamespaceException | ServletException e) {\r\n        logger.error(\"Could not start GPSTracker Callback servlet: {}\", e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.commons.GeneratorAdapter.returnValue",
	"Comment": "generates the instruction to return the top stack value to the caller.",
	"Method": "void returnValue(){\r\n    mv.visitInsn(returnType.getOpcode(Opcodes.IRETURN));\r\n}"
}, {
	"Path": "org.mitre.oauth2.introspectingfilter.IntrospectingTokenService.parseToken",
	"Comment": "validate a token string against the introspection endpoint,\tthen parse it and store it in the local cache if caching is enabled.",
	"Method": "TokenCacheObject parseToken(String accessToken){\r\n    String introspectionUrl;\r\n    RegisteredClient client;\r\n    try {\r\n        introspectionUrl = introspectionConfigurationService.getIntrospectionUrl(accessToken);\r\n        client = introspectionConfigurationService.getClientConfiguration(accessToken);\r\n    } catch (IllegalArgumentException e) {\r\n        logger.error(\"Unable to load introspection URL or client configuration\", e);\r\n        return null;\r\n    }\r\n    String validatedToken = null;\r\n    RestTemplate restTemplate;\r\n    MultiValueMap<String, String> form = new LinkedMultiValueMap();\r\n    final String clientId = client.getClientId();\r\n    final String clientSecret = client.getClientSecret();\r\n    if (SECRET_BASIC.equals(client.getTokenEndpointAuthMethod())) {\r\n        restTemplate = new RestTemplate(factory) {\r\n            @Override\r\n            protected ClientHttpRequest createRequest(URI url, HttpMethod method) throws IOException {\r\n                ClientHttpRequest httpRequest = super.createRequest(url, method);\r\n                httpRequest.getHeaders().add(\"Authorization\", String.format(\"Basic %s\", Base64.encode(String.format(\"%s:%s\", clientId, clientSecret))));\r\n                return httpRequest;\r\n            }\r\n        };\r\n    } else {\r\n        restTemplate = new RestTemplate(factory);\r\n        form.add(\"client_id\", clientId);\r\n        form.add(\"client_secret\", clientSecret);\r\n    }\r\n    form.add(\"token\", accessToken);\r\n    try {\r\n        validatedToken = restTemplate.postForObject(introspectionUrl, form, String.class);\r\n    } catch (RestClientException rce) {\r\n        logger.error(\"validateToken\", rce);\r\n        return null;\r\n    }\r\n    if (validatedToken != null) {\r\n        JsonElement jsonRoot = new JsonParser().parse(validatedToken);\r\n        if (!jsonRoot.isJsonObject()) {\r\n            return null;\r\n        }\r\n        JsonObject tokenResponse = jsonRoot.getAsJsonObject();\r\n        if (tokenResponse.get(\"error\") != null) {\r\n            logger.error(\"Got an error back: \" + tokenResponse.get(\"error\") + \", \" + tokenResponse.get(\"error_description\"));\r\n            return null;\r\n        }\r\n        if (!tokenResponse.get(\"active\").getAsBoolean()) {\r\n            logger.info(\"Server returned non-active token\");\r\n            return null;\r\n        }\r\n        OAuth2Authentication auth = new OAuth2Authentication(createStoredRequest(tokenResponse), createUserAuthentication(tokenResponse));\r\n        OAuth2AccessToken token = createAccessToken(tokenResponse, accessToken);\r\n        if (token.getExpiration() == null || token.getExpiration().after(new Date())) {\r\n            TokenCacheObject tco = new TokenCacheObject(token, auth);\r\n            if (cacheTokens && (cacheNonExpiringTokens || token.getExpiration() != null)) {\r\n                authCache.put(accessToken, tco);\r\n            }\r\n            return tco;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.mitre.oauth2.introspectingfilter.IntrospectingTokenService.parseToken",
	"Comment": "validate a token string against the introspection endpoint,\tthen parse it and store it in the local cache if caching is enabled.",
	"Method": "TokenCacheObject parseToken(String accessToken){\r\n    ClientHttpRequest httpRequest = super.createRequest(url, method);\r\n    httpRequest.getHeaders().add(\"Authorization\", String.format(\"Basic %s\", Base64.encode(String.format(\"%s:%s\", clientId, clientSecret))));\r\n    return httpRequest;\r\n}"
}, {
	"Path": "org.openhab.binding.cm11a.internal.X10Interface.processCommandData",
	"Comment": "process raw data received from the interface and convert into human readable data",
	"Method": "void processCommandData(int mask,int[] data){\r\n    int localMask = mask;\r\n    X10ReceivedData.X10COMMAND command = X10ReceivedData.X10COMMAND.UNDEF;\r\n    List<String> addresses = new ArrayList();\r\n    int dims = 0;\r\n    List<X10ReceivedData> rcvData = new ArrayList();\r\n    for (int i = 0; i < data.length; i++) {\r\n        int d = data[i];\r\n        int dataType = localMask & 0x01;\r\n        if (dataType == 0) {\r\n            int houseIndex = (d >> 4) & 0x0f;\r\n            int unitIndex = d & 0x0f;\r\n            addresses.add(Character.toString(X10ReceivedData.HOUSE_CODE[houseIndex]) + Integer.toString(X10ReceivedData.UNIT_CODE[unitIndex]));\r\n        } else {\r\n            command = X10ReceivedData.COMMAND_MAP.get(d & 0x0f);\r\n            if (command == null) {\r\n                command = X10ReceivedData.X10COMMAND.UNDEF;\r\n            } else if (command == X10ReceivedData.X10COMMAND.BRIGHT || command == X10ReceivedData.X10COMMAND.DIM) {\r\n                if (i < data.length) {\r\n                    dims = data[++i];\r\n                    dims = (dims * CM11A_DIM_INCREMENTS) / 210;\r\n                    dims = dims > 0 ? dims : 1;\r\n                }\r\n                if (lastAddresses == null) {\r\n                    logger.info(\"cm11a received a dim command but there is no prior commands that included an address.\");\r\n                    continue;\r\n                }\r\n                addresses = lastAddresses;\r\n            } else if (command == X10ReceivedData.X10COMMAND.ALL_LIGHTS_OFF || command == X10ReceivedData.X10COMMAND.ALL_LIGHTS_ON || command == X10ReceivedData.X10COMMAND.ALL_UNITS_OFF) {\r\n                logger.warn(\"cm11a received the command: {}. This command is ignored by this binding.\", command);\r\n                continue;\r\n            } else {\r\n                if (addresses.isEmpty()) {\r\n                    if (lastAddresses == null) {\r\n                        logger.info(\"cm11a received a command but the transmission didn't include an address.\");\r\n                        continue;\r\n                    } else {\r\n                        addresses = lastAddresses;\r\n                        logger.info(\"cm11a received a command without any addresses. Addresses from a prior reception are available and will be used.\");\r\n                    }\r\n                }\r\n            }\r\n            X10ReceivedData rd = new X10ReceivedData(addresses.toArray(new String[0]), command, dims);\r\n            rcvData.add(rd);\r\n            logger.debug(\"cm11a: Added received data to queue: {}\", rd.toString());\r\n            command = X10ReceivedData.X10COMMAND.UNDEF;\r\n            lastAddresses = addresses;\r\n            addresses = new ArrayList();\r\n            dims = 0;\r\n        }\r\n        localMask = localMask >> 1;\r\n    }\r\n    for (X10ReceivedData rd : rcvData) {\r\n        logger.debug(\"cm11a: Converted received data to human form: {}\", rd.toString());\r\n        notifyReceiveListeners(rd);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.protocol.NikoHomeControlDiscover.setNhcBridgeId",
	"Comment": "retrieves a unique id from the returned datagram packet received after sending the udp discovery message.",
	"Method": "void setNhcBridgeId(DatagramPacket packet){\r\n    byte[] packetData = packet.getData();\r\n    int packetLength = packet.getLength();\r\n    packetLength = packetLength > 6 ? 6 : packetLength;\r\n    StringBuilder sb = new StringBuilder(packetLength);\r\n    for (int i = 0; i < packetLength; i++) {\r\n        sb.append(String.format(\"x\", packetData[i]));\r\n    }\r\n    this.nhcBridgeId = sb.toString();\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.protocol.NhcAction.getType",
	"Comment": "get type of action identified.action type is 0 or 1 for a switch, 2 for a dimmer, 3 or 4 for a rollershutter.",
	"Method": "Integer getType(){\r\n    return this.type;\r\n}"
}, {
	"Path": "org.openhab.binding.gardena.internal.GardenaSmartImpl.loadDevices",
	"Comment": "loads all devices for the location, adds virtual properties for commands.",
	"Method": "Devices loadDevices(Location location){\r\n    Devices devices = executeRequest(HttpMethod.GET, URL_DEVICES + location.getId(), null, Devices.class);\r\n    for (Device device : devices.getDevices()) {\r\n        device.setLocation(location);\r\n        for (Ability ability : device.getAbilities()) {\r\n            ability.setDevice(device);\r\n            for (Property property : ability.getProperties()) {\r\n                property.setAbility(ability);\r\n                if (device.getCategory().equals(DEVICE_CATEGORY_PUMP)) {\r\n                    if (property.getName().equals(PROPERTY_MANUAL_WATERING_TIMER)) {\r\n                        Integer duration = getIntegerValue(property.getValueAsString());\r\n                        if (duration == null) {\r\n                            duration = 0;\r\n                        }\r\n                        property.setValue(new PropertyValue(String.valueOf(duration / 60)));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (Setting setting : device.getSettings()) {\r\n            setting.setDevice(device);\r\n        }\r\n        if (DEVICE_CATEGORY_MOWER.equals(device.getCategory())) {\r\n            Ability mower = device.getAbility(ABILITY_MOWER);\r\n            mower.addProperty(new Property(GardenaSmartCommandName.PARK_UNTIL_NEXT_TIMER, \"false\"));\r\n            mower.addProperty(new Property(GardenaSmartCommandName.PARK_UNTIL_FURTHER_NOTICE, \"false\"));\r\n            mower.addProperty(new Property(GardenaSmartCommandName.START_RESUME_SCHEDULE, \"false\"));\r\n            mower.addProperty(new Property(GardenaSmartCommandName.START_OVERRIDE_TIMER, \"false\"));\r\n            mower.addProperty(new Property(GardenaSmartCommandName.DURATION_PROPERTY, mowerDuration));\r\n        }\r\n    }\r\n    return devices;\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.LabelValue.fromArray",
	"Comment": "create tuple from array. array has to have exactly two elements.",
	"Method": "LabelValue<X, X> fromArray(X[] array){\r\n    if (array == null) {\r\n        throw new IllegalArgumentException(\"Array cannot be null\");\r\n    }\r\n    if (array.length != 2) {\r\n        throw new IllegalArgumentException(\"Array must have exactly 2 elements in order to create a LabelValue. Size is \" + array.length);\r\n    }\r\n    return new LabelValue<X, X>(array[0], array[1]);\r\n}"
}, {
	"Path": "org.mitre.openid.connect.service.impl.TestDefaultStatsService.prepare",
	"Comment": "prepares a collection of approvedsite mocks to be returned from the approvedsiteservice\tand a collection of clientdetailentity mocks to be returned from the clientservice.",
	"Method": "void prepare(){\r\n    Mockito.reset(approvedSiteService);\r\n    Mockito.when(ap1.getUserId()).thenReturn(userId1);\r\n    Mockito.when(ap1.getClientId()).thenReturn(clientId1);\r\n    Mockito.when(ap2.getUserId()).thenReturn(userId1);\r\n    Mockito.when(ap2.getClientId()).thenReturn(clientId1);\r\n    Mockito.when(ap3.getUserId()).thenReturn(userId2);\r\n    Mockito.when(ap3.getClientId()).thenReturn(clientId2);\r\n    Mockito.when(ap4.getUserId()).thenReturn(userId2);\r\n    Mockito.when(ap4.getClientId()).thenReturn(clientId3);\r\n    Mockito.when(ap5.getUserId()).thenReturn(userId2);\r\n    Mockito.when(ap5.getClientId()).thenReturn(clientId1);\r\n    Mockito.when(ap6.getUserId()).thenReturn(userId1);\r\n    Mockito.when(ap6.getClientId()).thenReturn(clientId4);\r\n    Mockito.when(approvedSiteService.getAll()).thenReturn(Sets.newHashSet(ap1, ap2, ap3, ap4));\r\n    Mockito.when(client1.getId()).thenReturn(1L);\r\n    Mockito.when(client2.getId()).thenReturn(2L);\r\n    Mockito.when(client3.getId()).thenReturn(3L);\r\n    Mockito.when(client4.getId()).thenReturn(4L);\r\n    Mockito.when(approvedSiteService.getByClientId(clientId1)).thenReturn(Sets.newHashSet(ap1, ap2));\r\n    Mockito.when(approvedSiteService.getByClientId(clientId2)).thenReturn(Sets.newHashSet(ap3));\r\n    Mockito.when(approvedSiteService.getByClientId(clientId3)).thenReturn(Sets.newHashSet(ap4));\r\n    Mockito.when(approvedSiteService.getByClientId(clientId4)).thenReturn(Sets.newHashSet());\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.discovery.NikoHomeControlBridgeDiscoveryService.discoverBridge",
	"Comment": "discovers devices connected to a niko home control controller",
	"Method": "void discoverBridge(){\r\n    try {\r\n        String broadcastAddr = networkAddressService.getConfiguredBroadcastAddress();\r\n        if (broadcastAddr == null) {\r\n            logger.warn(\"Niko Home Control: discovery not possible, no broadcast address found\");\r\n            return;\r\n        }\r\n        logger.debug(\"Niko Home Control: discovery broadcast on {}\", broadcastAddr);\r\n        NikoHomeControlDiscover nhcDiscover = new NikoHomeControlDiscover(broadcastAddr);\r\n        addBridge(nhcDiscover.getAddr(), nhcDiscover.getNhcBridgeId());\r\n    } catch (IOException e) {\r\n        logger.debug(\"Niko Home Control: no bridge found.\");\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.protocol.xml.InputWithPlayControlXML.sendCommand",
	"Comment": "sends a playback command to the avr. after command is invoked, the state is also being refreshed.",
	"Method": "void sendCommand(String command){\r\n    comReference.get().send(wrInput(command));\r\n    update();\r\n}"
}, {
	"Path": "org.openhab.binding.feican.internal.FeicanDiscoveryService.closeDiscoverSocket",
	"Comment": "closes the discovery socket and cleans the value. no need for synchronization as this method is called from asynchronized context.",
	"Method": "void closeDiscoverSocket(){\r\n    if (discoverSocket != null) {\r\n        discoverSocket.close();\r\n        discoverSocket = null;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.network.internal.utils.NetworkUtils.determinePingMethod",
	"Comment": "return the working method for the native system ping. if no native pingworks javaping is returned.",
	"Method": "IpPingMethodEnum determinePingMethod(){\r\n    IpPingMethodEnum method;\r\n    if (SystemUtils.IS_OS_WINDOWS) {\r\n        method = IpPingMethodEnum.WINDOWS_PING;\r\n    } else if (SystemUtils.IS_OS_MAC) {\r\n        method = IpPingMethodEnum.MAC_OS_PING;\r\n    } else if (SystemUtils.IS_OS_UNIX) {\r\n        method = IpPingMethodEnum.IPUTILS_LINUX_PING;\r\n    } else {\r\n        return IpPingMethodEnum.JAVA_PING;\r\n    }\r\n    try {\r\n        if (nativePing(method, \"127.0.0.1\", 1000)) {\r\n            return method;\r\n        }\r\n    } catch (IOException ignored) {\r\n    } catch (InterruptedException e) {\r\n        Thread.currentThread().interrupt();\r\n    }\r\n    return IpPingMethodEnum.JAVA_PING;\r\n}"
}, {
	"Path": "nginx.clojure.asm.Type.getMethodType",
	"Comment": "returns the java method type corresponding to the given argument andreturn types.",
	"Method": "Type getMethodType(String methodDescriptor,Type getMethodType,Type returnType,Type argumentTypes){\r\n    return getType(getMethodDescriptor(returnType, argumentTypes));\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Ennead.fromCollection",
	"Comment": "create tuple from collection. collection has to have exactly nine elements.",
	"Method": "Ennead<X, X, X, X, X, X, X, X, X> fromCollection(Collection<X> collection){\r\n    return fromIterable(collection);\r\n}"
}, {
	"Path": "org.openhab.binding.powermax.internal.state.PowermaxState.isArmed",
	"Comment": "get whether or not the current arming mode is considered as armed",
	"Method": "Boolean isArmed(Boolean isArmed,String armMode){\r\n    Boolean result = null;\r\n    if (armMode != null) {\r\n        try {\r\n            PowermaxArmMode mode = PowermaxArmMode.fromName(armMode);\r\n            result = mode.isArmed();\r\n        } catch (IllegalArgumentException e) {\r\n            result = Boolean.FALSE;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.openhab.binding.rfxcom.handler.RFXComHandler.isLowBattery",
	"Comment": "check if battery level is below low battery threshold level.",
	"Method": "State isLowBattery(State batteryLevel){\r\n    int level = ((DecimalType) batteryLevel).intValue();\r\n    if (level <= LOW_BATTERY_LEVEL) {\r\n        return OnOffType.ON;\r\n    } else {\r\n        return OnOffType.OFF;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.gardena.internal.util.UidUtils.generateThingUID",
	"Comment": "generates the thinguid for the given device in the given account.",
	"Method": "ThingUID generateThingUID(Device device,Bridge account){\r\n    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.getCategory());\r\n    return new ThingUID(thingTypeUID, account.getUID(), device.getId());\r\n}"
}, {
	"Path": "org.openhab.binding.max.internal.handler.MaxCubeBridgeHandler.sendCubeCommand",
	"Comment": "connects to the max! cube lan gateway and send a command to cubeand process the message",
	"Method": "boolean sendCubeCommand(CubeCommand command){\r\n    try {\r\n        if (socket == null || socket.isClosed()) {\r\n            this.socketConnect();\r\n        } else if (maxRequestsPerConnection > 0 && requestCount >= maxRequestsPerConnection) {\r\n            logger.debug(\"maxRequestsPerConnection reached, reconnecting.\");\r\n            socket.close();\r\n            this.socketConnect();\r\n        }\r\n        if (requestCount == 0) {\r\n            logger.debug(\"Connect to MAX! Cube\");\r\n            readLines(\"L:\");\r\n        }\r\n        if (!(requestCount == 0 && command instanceof LCommand)) {\r\n            logger.debug(\"Sending request #{} to MAX! Cube\", this.requestCount);\r\n            if (writer == null) {\r\n                logger.warn(\"Can't write to MAX! Cube\");\r\n                this.socketConnect();\r\n            }\r\n            writer.write(command.getCommandString());\r\n            logger.trace(\"Write string to Max! Cube {}: {}\", ipAddress, command.getCommandString());\r\n            writer.flush();\r\n            if (command.getReturnStrings() != null) {\r\n                readLines(command.getReturnStrings());\r\n            } else {\r\n                socketClose();\r\n            }\r\n        }\r\n        requestCount++;\r\n        return true;\r\n    } catch (ConnectException e) {\r\n        logger.debug(\"Connection timed out on {} port {}\", ipAddress, port);\r\n        socketClose();\r\n        return false;\r\n    } catch (UnknownHostException e) {\r\n        logger.debug(\"Host error occurred during execution: {}\", e.getMessage());\r\n        socketClose();\r\n        return false;\r\n    } catch (IOException e) {\r\n        logger.debug(\"IO error occurred during execution: {}\", e.getMessage());\r\n        socketClose();\r\n        return false;\r\n    } catch (Exception e) {\r\n        logger.debug(\"Exception occurred during execution\", e);\r\n        socketClose();\r\n        return false;\r\n    } finally {\r\n        if (!exclusive) {\r\n            socketClose();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.discovery.DSMRBridgeDiscoveryService.startScan",
	"Comment": "starts a new discovery scan.all available serial ports are scanned for p1 telegrams.",
	"Method": "void startScan(){\r\n    logger.debug(\"Started DSMR discovery scan\");\r\n    scanning = true;\r\n    Stream<SerialPortIdentifier> portEnum = serialPortManager.getIdentifiers();\r\n    portEnum.forEach(portIdentifier -> {\r\n        if (scanning) {\r\n            currentScannedPortName = portIdentifier.getName();\r\n            if (portIdentifier.isCurrentlyOwned()) {\r\n                logger.trace(\"Possible port to check:{}, owned:{} by:{}\", currentScannedPortName, portIdentifier.isCurrentlyOwned(), portIdentifier.getCurrentOwner());\r\n                if (DSMRBindingConstants.DSMR_PORT_NAME.equals(portIdentifier.getCurrentOwner())) {\r\n                    logger.debug(\"The port {} is owned by this binding. If no DSMR meters will be found it \" + \"might indicate the port is locked by an older instance of this binding. \" + \"Restart the system to unlock the port.\", currentScannedPortName);\r\n                }\r\n            } else {\r\n                logger.debug(\"Start discovery on serial port: {}\", currentScannedPortName);\r\n                DSMRSerialAutoDevice device = new DSMRSerialAutoDevice(serialPortManager, portIdentifier.getName(), this, scheduler, BAUDRATE_SWITCH_TIMEOUT_SECONDS);\r\n                device.setLenientMode(true);\r\n                currentScannedDevice = new DSMRDeviceRunnable(device, this);\r\n                currentScannedDevice.run();\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "nginx.clojure.asm.Frame.initInputFrame",
	"Comment": "initializes the input frame of the first basic block from the methoddescriptor.",
	"Method": "void initInputFrame(ClassWriter cw,int access,Type[] args,int maxLocals){\r\n    inputLocals = new int[maxLocals];\r\n    inputStack = new int[0];\r\n    int i = 0;\r\n    if ((access & Opcodes.ACC_STATIC) == 0) {\r\n        if ((access & MethodWriter.ACC_CONSTRUCTOR) == 0) {\r\n            inputLocals[i++] = OBJECT | cw.addType(cw.thisName);\r\n        } else {\r\n            inputLocals[i++] = UNINITIALIZED_THIS;\r\n        }\r\n    }\r\n    for (int j = 0; j < args.length; ++j) {\r\n        int t = type(cw, args[j].getDescriptor());\r\n        inputLocals[i++] = t;\r\n        if (t == LONG || t == DOUBLE) {\r\n            inputLocals[i++] = TOP;\r\n        }\r\n    }\r\n    while (i < maxLocals) {\r\n        inputLocals[i++] = TOP;\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.dsmr.internal.device.cosem.CosemObjectFactory.getCosemObjectInternal",
	"Comment": "constructs a cosemobject from the given type, obisidentifier and the values",
	"Method": "CosemObject getCosemObjectInternal(CosemObjectType cosemObjectType,OBISIdentifier obisIdentifier,String cosemStringValues){\r\n    CosemObject obj = new CosemObject(cosemObjectType, obisIdentifier);\r\n    try {\r\n        logger.trace(\"Parse values for Cosem Object type: {}\", cosemObjectType);\r\n        obj.parseCosemValues(cosemStringValues);\r\n        return obj;\r\n    } catch (ParseException pe) {\r\n        logger.debug(\"Failed to construct Cosem Object for type {}, values: {}\", cosemObjectType, cosemStringValues, pe);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "nginx.clojure.asm.Attribute.put",
	"Comment": "writes all the attributes of this attribute list in the given bytevector.",
	"Method": "void put(ClassWriter cw,byte[] code,int len,int maxStack,int maxLocals,ByteVector out){\r\n    Attribute attr = this;\r\n    while (attr != null) {\r\n        ByteVector b = attr.write(cw, code, len, maxStack, maxLocals);\r\n        out.putShort(cw.newUTF8(attr.type)).putInt(b.length);\r\n        out.putByteArray(b.data, 0, b.length);\r\n        attr = attr.next;\r\n    }\r\n}"
}, {
	"Path": "org.mitre.openid.connect.client.OIDCAuthenticationFilter.getStoredSessionString",
	"Comment": "get the named stored session variable as a string. return null if not found or not a string.",
	"Method": "String getStoredSessionString(HttpSession session,String key){\r\n    Object o = session.getAttribute(key);\r\n    if (o != null && o instanceof String) {\r\n        return o.toString();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.asm.util.CheckClassAdapter.checkAccess",
	"Comment": "checks that the given access flags do not contain invalid flags. thismethod also checks that mutually incompatible flags are not setsimultaneously.",
	"Method": "void checkAccess(int access,int possibleAccess){\r\n    if ((access & ~possibleAccess) != 0) {\r\n        throw new IllegalArgumentException(\"Invalid access flags: \" + access);\r\n    }\r\n    int pub = (access & Opcodes.ACC_PUBLIC) == 0 ? 0 : 1;\r\n    int pri = (access & Opcodes.ACC_PRIVATE) == 0 ? 0 : 1;\r\n    int pro = (access & Opcodes.ACC_PROTECTED) == 0 ? 0 : 1;\r\n    if (pub + pri + pro > 1) {\r\n        throw new IllegalArgumentException(\"public private and protected are mutually exclusive: \" + access);\r\n    }\r\n    int fin = (access & Opcodes.ACC_FINAL) == 0 ? 0 : 1;\r\n    int abs = (access & Opcodes.ACC_ABSTRACT) == 0 ? 0 : 1;\r\n    if (fin + abs > 1) {\r\n        throw new IllegalArgumentException(\"final and abstract are mutually exclusive: \" + access);\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.pioneeravr.protocol.utils.VolumeConverter.convertFromPercentToIpControlVolume",
	"Comment": "return the string parameter to send to the avr based on the given persentage of the max volume level.",
	"Method": "String convertFromPercentToIpControlVolume(double volumePercent,int zone){\r\n    validateZone(zone - 1);\r\n    double ipControlVolume = 1 + (volumePercent * MAX_IP_CONTROL_VOLUME[zone - 1] / 100);\r\n    return formatIpControlVolume(ipControlVolume, zone);\r\n}"
}, {
	"Path": "org.openhab.binding.gpstracker.internal.handler.TrackerHandler.createBasicDistanceChannel",
	"Comment": "create distance channel for measuring the distance between the tracker and the szstem.",
	"Method": "void createBasicDistanceChannel(){\r\n    @Nullable\r\n    ThingHandlerCallback callback = getCallback();\r\n    if (callback != null) {\r\n        ChannelUID systemDistanceChannelUID = new ChannelUID(thing.getUID(), CHANNEL_DISTANCE_SYSTEM_ID);\r\n        Channel systemDistance = thing.getChannel(CHANNEL_DISTANCE_SYSTEM_ID);\r\n        ChannelBuilder channelBuilder = null;\r\n        if (systemDistance != null) {\r\n            if (!systemDistance.getConfiguration().get(CONFIG_REGION_CENTER_LOCATION).equals(sysLocation.toFullString())) {\r\n                logger.trace(\"Existing distance channel for system. Changing system location config parameter: {}\", sysLocation.toFullString());\r\n                channelBuilder = callback.editChannel(thing, systemDistanceChannelUID);\r\n                Configuration configToUpdate = systemDistance.getConfiguration();\r\n                configToUpdate.put(CONFIG_REGION_CENTER_LOCATION, sysLocation.toFullString());\r\n                channelBuilder.withConfiguration(configToUpdate);\r\n            } else {\r\n                logger.trace(\"Existing distance channel for system. No change.\");\r\n            }\r\n        } else {\r\n            logger.trace(\"Creating missing distance channel for system.\");\r\n            Configuration config = new Configuration();\r\n            config.put(ConfigHelper.CONFIG_REGION_NAME, CHANNEL_DISTANCE_SYSTEM_NAME);\r\n            config.put(CONFIG_REGION_CENTER_LOCATION, sysLocation.toFullString());\r\n            config.put(ConfigHelper.CONFIG_REGION_RADIUS, CHANNEL_DISTANCE_SYSTEM_RADIUS);\r\n            channelBuilder = callback.createChannelBuilder(systemDistanceChannelUID, CHANNEL_TYPE_DISTANCE).withLabel(\"System Distance\").withConfiguration(config);\r\n        }\r\n        if (channelBuilder != null) {\r\n            List<Channel> channels = new ArrayList(thing.getChannels());\r\n            if (systemDistance != null) {\r\n                channels.remove(systemDistance);\r\n            }\r\n            channels.add(channelBuilder.build());\r\n            ThingBuilder thingBuilder = editThing();\r\n            thingBuilder.withChannels(channels);\r\n            updateThing(thingBuilder.build());\r\n            logger.debug(\"Distance channel created for system: {}\", systemDistanceChannelUID);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.protocol.xml.XMLConnection.sendReceive",
	"Comment": "post the given xml message and return the response as string.",
	"Method": "String sendReceive(String message){\r\n    return postMessage(XML_GET, message, XML_END, c -> consumeResponse(c));\r\n}"
}, {
	"Path": "org.nlpcn.commons.lang.util.tuples.Quintet.fromIterable",
	"Comment": "create tuple from iterable. iterable has to have exactly five elements.",
	"Method": "Quintet<X, X, X, X, X> fromIterable(Iterable<X> iterable,Quintet<X, X, X, X, X> fromIterable,Iterable<X> iterable,int index,Quintet<X, X, X, X, X> fromIterable,Iterable<X> iterable,int index,boolean exactSize){\r\n    if (iterable == null) {\r\n        throw new IllegalArgumentException(\"Iterable cannot be null\");\r\n    }\r\n    boolean tooFewElements = false;\r\n    X element0 = null;\r\n    X element1 = null;\r\n    X element2 = null;\r\n    X element3 = null;\r\n    X element4 = null;\r\n    final Iterator<X> iter = iterable.iterator();\r\n    int i = 0;\r\n    while (i < index) {\r\n        if (iter.hasNext()) {\r\n            iter.next();\r\n        } else {\r\n            tooFewElements = true;\r\n        }\r\n        i++;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element0 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element1 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element2 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element3 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (iter.hasNext()) {\r\n        element4 = iter.next();\r\n    } else {\r\n        tooFewElements = true;\r\n    }\r\n    if (tooFewElements && exactSize) {\r\n        throw new IllegalArgumentException(\"Not enough elements for creating a Quintet (5 needed)\");\r\n    }\r\n    if (iter.hasNext() && exactSize) {\r\n        throw new IllegalArgumentException(\"Iterable must have exactly 5 available elements in order to create a Quintet.\");\r\n    }\r\n    return new Quintet<X, X, X, X, X>(element0, element1, element2, element3, element4);\r\n}"
}, {
	"Path": "org.openhab.binding.cm11a.internal.X10Interface.sendData",
	"Comment": "sends data to the hardware and handles the checksuming and retry process.when applicable, method blocks until the data has actually been sent over the powerlines using x10",
	"Method": "void sendData(int[] data){\r\n    int calcChecksum = 0;\r\n    int checksumResponse = -1;\r\n    for (int i = 0; i < data.length; i++) {\r\n        calcChecksum = (calcChecksum + (0x000000FF & (data[i]))) & 0x000000FF;\r\n        logger.trace(\"Checksum calc: int {} = {}\", i, Integer.toHexString(data[i]));\r\n    }\r\n    if (connect()) {\r\n        synchronized (serialPort) {\r\n            long startTime = System.currentTimeMillis();\r\n            serialPort.notifyOnDataAvailable(false);\r\n            try {\r\n                int retryCount = 0;\r\n                while (checksumResponse != calcChecksum) {\r\n                    retryCount++;\r\n                    for (int i = 0; i < data.length; i++) {\r\n                        serialOutput.write(data[i]);\r\n                        serialOutput.flush();\r\n                    }\r\n                    long sendTime = System.currentTimeMillis();\r\n                    logger.trace(\"Sent the following data out the serial port in {} msec, {}\", (sendTime - startTime), Arrays.toString(data));\r\n                    checksumResponse = serialInput.readUnsignedByte();\r\n                    logger.trace(\"Attempted to send data, try number: {} Checksum expected: {} received: {}\", retryCount, Integer.toHexString(calcChecksum), Integer.toHexString(checksumResponse));\r\n                    long ckSumTime = System.currentTimeMillis();\r\n                    logger.trace(\"Received serial port check sum in {} msec\", (ckSumTime - sendTime));\r\n                    if (checksumResponse != calcChecksum) {\r\n                        processRequestFromIFace(checksumResponse);\r\n                        if (retryCount > IO_MAX_SEND_RETRY_COUNT) {\r\n                            logger.warn(\"Failed to send data to X10 hardware due to too many checksum failures\");\r\n                            serialPort.notifyOnDataAvailable(true);\r\n                            throw new IOException(\"Max retries exceeded\");\r\n                        }\r\n                    }\r\n                }\r\n                logger.trace(\"Data transmission to interface was successful, sending ACK.  X10 transmission over powerline will now commence.\");\r\n                long ackTime = System.currentTimeMillis();\r\n                serialOutput.write(CHECKSUM_ACK);\r\n                serialOutput.flush();\r\n                int response = serialInput.readUnsignedByte();\r\n                if (response == IF_READY) {\r\n                    long cmpltdTime = System.currentTimeMillis();\r\n                    logger.trace(\"Serial port X10 ACK completed in {} msec, TOTAL X10 TRANSMISSION TIME in {} ms\", (cmpltdTime - ackTime), (cmpltdTime - startTime));\r\n                } else {\r\n                    logger.warn(\"Expected IF_READY ({}) response from hardware but received: {} instead\", Integer.toHexString(IF_READY & 0x00000FF), Integer.toHexString(response & 0x00000FF));\r\n                }\r\n            } catch (EOFException ex) {\r\n                logger.warn(\"Received EOF exception while sending X10 command after {} ms. Make sure the cm11a is connected to the serial port\", (System.currentTimeMillis() - startTime));\r\n            }\r\n            serialPort.notifyOnDataAvailable(true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.cm11a.internal.X10Interface.addReceivedDataListener",
	"Comment": "called by classes that want to be notified when data has been received from the cm11a",
	"Method": "void addReceivedDataListener(ReceivedDataListener listener){\r\n    receiveListeners.add(listener);\r\n}"
}, {
	"Path": "org.openhab.binding.opensprinkler.internal.api.OpenSprinklerHttpApiV100.getRequestRequiredOptions",
	"Comment": "returns the required url parameters required for every api call.",
	"Method": "String getRequestRequiredOptions(){\r\n    return CMD_PASSWORD + this.password;\r\n}"
}, {
	"Path": "org.openhab.binding.nest.internal.handler.NestThermostatHandler.handleCommand",
	"Comment": "handle the command to do things to the thermostat, this will change thevalue of a channel by sending the request to nest.",
	"Method": "void handleCommand(ChannelUID channelUID,Command command){\r\n    if (REFRESH.equals(command)) {\r\n        Thermostat lastUpdate = getLastUpdate();\r\n        if (lastUpdate != null) {\r\n            updateState(channelUID, getChannelState(channelUID, lastUpdate));\r\n        }\r\n    } else if (CHANNEL_FAN_TIMER_ACTIVE.equals(channelUID.getId())) {\r\n        if (command instanceof OnOffType) {\r\n            addUpdateRequest(\"fan_timer_active\", command == OnOffType.ON);\r\n        }\r\n    } else if (CHANNEL_FAN_TIMER_DURATION.equals(channelUID.getId())) {\r\n        if (command instanceof QuantityType) {\r\n            QuantityType<Time> minuteQuantity = ((QuantityType<Time>) command).toUnit(SmartHomeUnits.MINUTE);\r\n            if (minuteQuantity != null) {\r\n                addUpdateRequest(\"fan_timer_duration\", minuteQuantity.intValue());\r\n            }\r\n        }\r\n    } else if (CHANNEL_MAX_SET_POINT.equals(channelUID.getId())) {\r\n        if (command instanceof QuantityType) {\r\n            addTemperatureUpdateRequest(\"target_temperature_high_c\", \"target_temperature_high_f\", (QuantityType<Temperature>) command);\r\n        }\r\n    } else if (CHANNEL_MIN_SET_POINT.equals(channelUID.getId())) {\r\n        if (command instanceof QuantityType) {\r\n            addTemperatureUpdateRequest(\"target_temperature_low_c\", \"target_temperature_low_f\", (QuantityType<Temperature>) command);\r\n        }\r\n    } else if (CHANNEL_MODE.equals(channelUID.getId())) {\r\n        if (command instanceof StringType) {\r\n            addUpdateRequest(\"hvac_mode\", Mode.valueOf(((StringType) command).toString()));\r\n        }\r\n    } else if (CHANNEL_SET_POINT.equals(channelUID.getId())) {\r\n        if (command instanceof QuantityType) {\r\n            addTemperatureUpdateRequest(\"target_temperature_c\", \"target_temperature_f\", (QuantityType<Temperature>) command);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.openhab.binding.nikohomecontrol.internal.protocol.NikoHomeControlCommunication.sendMessage",
	"Comment": "called by other methods to send json cmd to niko home control.",
	"Method": "void sendMessage(Object nhcMessage){\r\n    PrintWriter writer = this.nhcOut;\r\n    String json = gsonOut.toJson(nhcMessage);\r\n    logger.debug(\"Niko Home Control: send json {} from thread {}\", json, Thread.currentThread().getId());\r\n    if (writer != null) {\r\n        writer.println(json);\r\n    }\r\n    if ((writer == null) || (writer.checkError())) {\r\n        logger.warn(\"Niko Home Control: error sending message, trying to restart communication\");\r\n        restartCommunication();\r\n        logger.debug(\"Niko Home Control: resend json {} from thread {}\", json, Thread.currentThread().getId());\r\n        writer = this.nhcOut;\r\n        if (writer != null) {\r\n            writer.println(json);\r\n        }\r\n        if ((writer == null) || (writer.checkError())) {\r\n            logger.warn(\"Niko Home Control: error resending message\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "nginx.clojure.Coroutine.run",
	"Comment": "runs the coroutine until it is finished or suspended. this method must onlybe called when the coroutine is in the states new or suspended. it is notmulti threading safe.",
	"Method": "void run(){\r\n    resume();\r\n}"
}, {
	"Path": "org.openhab.binding.smartmeter.connectors.ConnectorBase.applyRetryHandling",
	"Comment": "whether to apply a retry handling whenever the read out failed.",
	"Method": "boolean applyRetryHandling(){\r\n    return false;\r\n}"
}, {
	"Path": "org.openhab.binding.gpstracker.internal.GPSTrackerHandlerFactory.deactivate",
	"Comment": "deactivate the binding. it stops the http callback endpoint and stops the tracker discovery service.",
	"Method": "void deactivate(ComponentContext componentContext){\r\n    logger.debug(\"Deactivating GPSTracker Binding\");\r\n    this.httpService.unregister(otHTTPEndpoint.getPath());\r\n    logger.debug(\"GPSTracker callback servlet stopped on {}\", otHTTPEndpoint.getPath());\r\n    this.httpService.unregister(glHTTPEndpoint.getPath());\r\n    logger.debug(\"GPSTracker callback servlet stopped on {}\", glHTTPEndpoint.getPath());\r\n    super.deactivate(componentContext);\r\n}"
}, {
	"Path": "nginx.clojure.asm.ClassWriter.newFieldItem",
	"Comment": "adds a field reference to the constant pool of the class being build.does nothing if the constant pool already contains a similar item.",
	"Method": "Item newFieldItem(String owner,String name,String desc){\r\n    key3.set(FIELD, owner, name, desc);\r\n    Item result = get(key3);\r\n    if (result == null) {\r\n        put122(FIELD, newClass(owner), newNameType(name, desc));\r\n        result = new Item(index++, key3);\r\n        put(result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.openhab.binding.dlinksmarthome.internal.motionsensor.DLinkMotionSensorCommunication.buildDetectionAction",
	"Comment": "this is the soap message used to retrieve the last detection time. this message willonly receive a successful response after the login process has been completed and theauthentication data has been set.",
	"Method": "void buildDetectionAction(){\r\n    detectionAction.getSOAPHeader().detachNode();\r\n    final SOAPBody soapBody = detectionAction.getSOAPBody();\r\n    final SOAPElement soapBodyElem = soapBody.addChildElement(\"GetLatestDetection\", \"\", HNAP_XMLNS);\r\n    soapBodyElem.addChildElement(\"ModuleID\").addTextNode(\"1\");\r\n    final MimeHeaders headers = detectionAction.getMimeHeaders();\r\n    headers.addHeader(SOAPACTION, DETECTION_ACTION);\r\n}"
}, {
	"Path": "org.openhab.binding.tplinksmarthome.internal.CryptUtil.decrypt",
	"Comment": "decrypt the byte data in the input stream with the length as given.",
	"Method": "String decrypt(byte[] data,int length,String decrypt,InputStream inputStream,int length){\r\n    StringBuilder sb = new StringBuilder();\r\n    int in;\r\n    int key = KEY;\r\n    while (sb.length() < length && (in = inputStream.read()) != -1) {\r\n        int nextKey = in;\r\n        sb.append((char) (in ^ key));\r\n        key = nextKey;\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.openhab.binding.opensprinkler.internal.api.OpenSprinklerGpioApi.pushStationState",
	"Comment": "communicate with the gpio of the opensprinkler pi device topush and update local station state to the device.",
	"Method": "void pushStationState(){\r\n    srClkOutputPin.low();\r\n    srLatOutputPin.low();\r\n    for (int i = 1; i <= numberOfStations; i++) {\r\n        srClkOutputPin.low();\r\n        srDatOutputPin.setState(stationState[numberOfStations - i]);\r\n        srClkOutputPin.high();\r\n    }\r\n    srLatOutputPin.high();\r\n}"
}, {
	"Path": "org.openhab.ui.cometvisu.internal.servlet.CometVisuApp.activate",
	"Comment": "called by the scr to activate the component with its configuration readfrom cas",
	"Method": "void activate(Map<String, Object> configProps){\r\n    readConfiguration(configProps);\r\n    registerServlet();\r\n    logger.info(\"Started CometVisu UI at {} serving {}\", Config.COMETVISU_WEBAPP_ALIAS, Config.COMETVISU_WEBFOLDER);\r\n}"
}, {
	"Path": "org.mitre.oauth2.service.impl.TestDefaultOAuth2ProviderTokenService.refreshAccessToken_requestingMixedScope",
	"Comment": "tests the case where only some of the valid scope values are being requested along with\tother extra unauthorized scope values.",
	"Method": "void refreshAccessToken_requestingMixedScope(){\r\n    Set<String> mixedScope = newHashSet(\"openid\", \"profile\", \"address\", \"phone\");\r\n    tokenRequest.setScope(mixedScope);\r\n    service.refreshAccessToken(refreshTokenValue, tokenRequest);\r\n}"
}, {
	"Path": "org.openhab.binding.powermax.internal.message.PowermaxCommManager.sendPGMX10",
	"Comment": "send a message to the powermax alarm panel to change pgm or x10 zone state",
	"Method": "boolean sendPGMX10(Command action,Byte device){\r\n    logger.debug(\"sendPGMX10(): action = {}, device = {}\", action, device);\r\n    boolean done = false;\r\n    Map<String, Byte> codes = new HashMap();\r\n    codes.put(\"OFF\", (byte) 0x00);\r\n    codes.put(\"ON\", (byte) 0x01);\r\n    codes.put(\"DIM\", (byte) 0x0A);\r\n    codes.put(\"BRIGHT\", (byte) 0x0B);\r\n    Byte code = codes.get(action.toString());\r\n    if (code == null) {\r\n        logger.debug(\"Powermax alarm binding: invalid PGM/X10 command: {}\", action);\r\n    } else if ((device != null) && ((device < 1) || (device >= panelSettings.getNbPGMX10Devices()))) {\r\n        logger.debug(\"Powermax alarm binding: invalid X10 device id: {}\", device);\r\n    } else {\r\n        int val = (device == null) ? 1 : (1 << device);\r\n        byte[] dynPart = new byte[3];\r\n        dynPart[0] = code;\r\n        dynPart[1] = (byte) (val & 0x000000FF);\r\n        dynPart[2] = (byte) (val >> 8);\r\n        done = sendMessage(new PowermaxBaseMessage(PowermaxSendType.X10PGM, dynPart), false, 0);\r\n    }\r\n    return done;\r\n}"
}, {
	"Path": "org.openhab.io.hueemulation.internal.Utils.getMAC",
	"Comment": "try to get the ethernet interface mac for the network interface that belongs to the given ip address.returns a default mac on any failure.",
	"Method": "String getMAC(InetAddress address){\r\n    NetworkInterface networkInterface;\r\n    final byte[] mac;\r\n    try {\r\n        networkInterface = NetworkInterface.getByInetAddress(address);\r\n        mac = networkInterface.getHardwareAddress();\r\n        if (mac == null) {\r\n            return \"00:00:88:00:bb:ee\";\r\n        }\r\n    } catch (SocketException e) {\r\n        return \"00:00:88:00:bb:ee\";\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 0; i < mac.length; i++) {\r\n        sb.append(String.format(\"X%s\", mac[i], (i < mac.length - 1) ? \":\" : \"\"));\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.openhab.binding.yamahareceiver.internal.protocol.xml.InputWithPresetControlXML.applyModelVariations",
	"Comment": "apply command changes to ensure compatibility with all supported models",
	"Method": "void applyModelVariations(){\r\n    if (deviceDescriptor == null) {\r\n        logger.trace(\"Descriptor not available\");\r\n        return;\r\n    }\r\n}"
}]