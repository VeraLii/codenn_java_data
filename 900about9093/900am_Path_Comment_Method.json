[{
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetSelectedCompressionMethod",
	"Comment": "test of getselectedcompressionmethod method, of class defaultchooser.",
	"Method": "void testGetSelectedCompressionMethod(){\r\n    context.setSelectedCompressionMethod(null);\r\n    config.setDefaultSelectedCompressionMethod(CompressionMethod.DEFLATE);\r\n    assertEquals(CompressionMethod.DEFLATE, config.getDefaultSelectedCompressionMethod());\r\n    assertEquals(CompressionMethod.DEFLATE, chooser.getSelectedCompressionMethod());\r\n    context.setSelectedCompressionMethod(CompressionMethod.LZS);\r\n    assertEquals(CompressionMethod.LZS, chooser.getSelectedCompressionMethod());\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.protocol.RobotRules.setContentLengthFetched",
	"Comment": "returns the number of bytes fetched per request when not cached",
	"Method": "void setContentLengthFetched(int[] bytesFetched){\r\n    this.bytesFetched = bytesFetched;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.EncryptedExtensionsMessageTest.testToString",
	"Comment": "test of tostring method, of class encryptedextensionsmessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"EncryptedExtensionMessage:\");\r\n    sb.append(\"\\n  Extensions: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ApplicationMessageHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class applicationmessagehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new ApplicationMessage()) instanceof ApplicationMessagePreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.SessionTicketTLSExtensionParserTest.generateData",
	"Comment": "gets the test vectors of the sessiontickettlsextensionhandlertest class.",
	"Method": "Collection<Object[]> generateData(){\r\n    return Arrays.asList(new Object[][] { { ExtensionType.SESSION_TICKET, 0, new byte[0], ArrayConverter.hexStringToByteArray(\"00230000\"), 0 } });\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetClientSupportedCiphersuites",
	"Comment": "test of getclientsupportedciphersuites method, of class defaultchooser.",
	"Method": "void testGetClientSupportedCiphersuites(){\r\n    LinkedList<CipherSuite> clientSupportedCiphersuites = new LinkedList();\r\n    LinkedList<CipherSuite> clientSupportedCiphersuites2 = new LinkedList();\r\n    clientSupportedCiphersuites.add(CipherSuite.TLS_FALLBACK_SCSV);\r\n    clientSupportedCiphersuites.add(CipherSuite.TLS_AES_128_GCM_SHA256);\r\n    clientSupportedCiphersuites.add(CipherSuite.TLS_DHE_DSS_EXPORT1024_WITH_RC4_56_SHA);\r\n    clientSupportedCiphersuites.add(CipherSuite.SSL_FORTEZZA_KEA_WITH_NULL_SHA);\r\n    clientSupportedCiphersuites.add(CipherSuite.TLS_DHE_PSK_WITH_AES_128_CBC_SHA256);\r\n    clientSupportedCiphersuites.add(CipherSuite.TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384);\r\n    config.setDefaultClientSupportedCiphersuites(clientSupportedCiphersuites);\r\n    assertEquals(clientSupportedCiphersuites, config.getDefaultClientSupportedCiphersuites());\r\n    assertEquals(clientSupportedCiphersuites, chooser.getClientSupportedCiphersuites());\r\n    context.setClientSupportedCiphersuites(clientSupportedCiphersuites2);\r\n    assertEquals(clientSupportedCiphersuites2, chooser.getClientSupportedCiphersuites());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.KeyShareExtensionParser.parseKeyShareListBytes",
	"Comment": "reads the next bytes as the keysharelistbytes of the extension and writesthem in the message",
	"Method": "void parseKeyShareListBytes(KeyShareExtensionMessage msg){\r\n    msg.setKeyShareListBytes(parseByteArrayField(msg.getKeyShareListLength().getValue()));\r\n    LOGGER.debug(\"KeyShareListBytes: \" + ArrayConverter.bytesToHexString(msg.getKeyShareListBytes().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.DeactivateEncryptionActionTest.testReset",
	"Comment": "test of reset method, of class deactivateencryptionaction.",
	"Method": "void testReset(){\r\n    assertFalse(action.isExecuted());\r\n    action.execute(state);\r\n    assertTrue(action.isExecuted());\r\n    action.reset();\r\n    assertFalse(action.isExecuted());\r\n    action.execute(state);\r\n    assertTrue(action.isExecuted());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellodepthperception.HelloDepthPerceptionActivity.setupTangoConfig",
	"Comment": "sets up the tango configuration object. make sure mtango object is initialized beforemaking this call.",
	"Method": "TangoConfig setupTangoConfig(Tango tango){\r\n    TangoConfig config = tango.getConfig(TangoConfig.CONFIG_TYPE_DEFAULT);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_DEPTH, true);\r\n    config.putInt(TangoConfig.KEY_INT_DEPTH_MODE, TangoConfig.TANGO_DEPTH_MODE_POINT_CLOUD);\r\n    return config;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetClientCertificateTypes",
	"Comment": "test of getclientcertificatetypes method, of class defaultchooser.",
	"Method": "void testGetClientCertificateTypes(){\r\n    List<ClientCertificateType> typeList = new LinkedList();\r\n    typeList.add(ClientCertificateType.DSS_EPHEMERAL_DH_RESERVED);\r\n    typeList.add(ClientCertificateType.DSS_FIXED_DH);\r\n    typeList.add(ClientCertificateType.DSS_SIGN);\r\n    typeList.add(ClientCertificateType.FORTEZZA_DMS_RESERVED);\r\n    typeList.add(ClientCertificateType.RSA_EPHEMERAL_DH_RESERVED);\r\n    typeList.add(ClientCertificateType.RSA_FIXED_DH);\r\n    typeList.add(ClientCertificateType.RSA_SIGN);\r\n    config.setClientCertificateTypes(typeList);\r\n    assertTrue(config.getClientCertificateTypes().size() == 7);\r\n    assertTrue(chooser.getClientCertificateTypes().size() == 7);\r\n    context.setClientCertificateTypes(new LinkedList<ClientCertificateType>());\r\n    assertTrue(chooser.getClientCertificateTypes().isEmpty());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.state.TlsContext.addProposedExtension",
	"Comment": "mark the given tls extension type as client proposed extension.",
	"Method": "void addProposedExtension(ExtensionType ext){\r\n    proposedExtensionSet.add(ext);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ClientHelloParser.parseCompressions",
	"Comment": "reads the next bytes as the compression and writes them in the message",
	"Method": "void parseCompressions(ClientHelloMessage message){\r\n    message.setCompressions(parseByteArrayField(message.getCompressionLength().getValue()));\r\n    LOGGER.debug(\"Compressions: \" + ArrayConverter.bytesToHexString(message.getCompressions().getValue()));\r\n}"
}, {
	"Path": "org.springframework.statemachine.test.StateMachineTestPlanBuilder.defaultAwaitTime",
	"Comment": "sets default await time. this is in seconds how long a latch\twill be waited for listening various callbacks.",
	"Method": "StateMachineTestPlanBuilder<S, E> defaultAwaitTime(int seconds){\r\n    if (seconds < 0) {\r\n        throw new IllegalArgumentException(\"Default await time cannot be negative, was \" + seconds);\r\n    }\r\n    this.defaultAwaitTime = seconds;\r\n    return this;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.EcPointFormatExtensionHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class ecpointformatextensionhandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new ECPointFormatExtensionMessage()) instanceof ECPointFormatExtensionPreparator);\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.identity.AWSCognitoDeveloperAuthenticationSample.validateLoginRequest",
	"Comment": "verify if the login request is valid. username and uid are authenticated.the timestamp is checked to see it falls within the valid timestampwindow. the signature is computed and matched against the givensignature. also its checked to see if the uid belongs to the username.this function is useful in identity mode",
	"Method": "void validateLoginRequest(String username,String uid,String signature,String timestamp){\r\n    if (!isTimestampValid(timestamp)) {\r\n        throw new UnauthorizedException(\"Invalid timestamp: \" + timestamp);\r\n    }\r\n    log.info(String.format(\"Timestamp [ %s ] is valid\", timestamp));\r\n    log.info(\"Validate signature: \" + signature);\r\n    UserInfo user = ensureKnownUser(username);\r\n    if (!validateSignature(timestamp, user.getHashedPassword(), signature)) {\r\n        throw new UnauthorizedException(\"Invalid signature: \" + signature);\r\n    }\r\n    log.info(\"Signature matched!!!\");\r\n    DeviceInfo device = regenerateKey(uid, user.getUsername());\r\n    log.info(\"Device found/registered successfully!!!\");\r\n    if (!deviceBelongsToUser(user.getUsername(), device.getUsername())) {\r\n        throw new UnauthorizedException(String.format(\"User [ %s ] doesn't match the device's owner [ %s ]\", user.getUsername(), device.getUsername()));\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.CopyClientRandomActionTest.testExecute",
	"Comment": "test of execute method, of class changeclientrandomaction.",
	"Method": "void testExecute(){\r\n    action.execute(state);\r\n    assertArrayEquals(tlsContextServer1.getClientRandom(), tlsContextServer2.getClientRandom());\r\n    assertArrayEquals(tlsContextServer2.getClientRandom(), new byte[] { 1, 2 });\r\n    assertTrue(action.isExecuted());\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.util.GeomBuilder.multiLineString",
	"Comment": "creates a multilinestring from all linestrings on the geometry stack and places the result back on the geometry stack.",
	"Method": "GeomBuilder multiLineString(){\r\n    gstack.push(factory.createMultiLineString(gpopAll(LineString.class)));\r\n    return this;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.setDisplayRotation",
	"Comment": "set the color camera background texture rotation and save the camera to display rotation.",
	"Method": "void setDisplayRotation(){\r\n    Display display = getWindowManager().getDefaultDisplay();\r\n    mDisplayRotation = display.getRotation();\r\n    mSurfaceView.queueEvent(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            if (mIsConnected) {\r\n                mRenderer.updateColorCameraTextureUvGlThread(mDisplayRotation);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.setDisplayRotation",
	"Comment": "set the color camera background texture rotation and save the camera to display rotation.",
	"Method": "void setDisplayRotation(){\r\n    if (mIsConnected) {\r\n        mRenderer.updateColorCameraTextureUvGlThread(mDisplayRotation);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.executor.SendMessageHelper.sendData",
	"Comment": "sends all messagebytes in the messagebytecollector with the specifiedtransporthandler",
	"Method": "void sendData(MessageBytesCollector collector,TlsContext context){\r\n    context.getTransportHandler().sendData(collector.getRecordBytes());\r\n    collector.flushRecordBytes();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.DHClientKeyExchangePreparatorTest.testPrepare",
	"Comment": "test of preparehandshakemessagecontents method, of classdhclientkeyexchangepreparator.",
	"Method": "void testPrepare(){\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS12);\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_DH_RSA_WITH_AES_128_CBC_SHA256);\r\n    context.setClientRandom(ArrayConverter.hexStringToByteArray(RANDOM));\r\n    context.setServerRandom(ArrayConverter.hexStringToByteArray(RANDOM));\r\n    context.setServerDhModulus(new BigInteger(DH_M, 16));\r\n    context.setServerDhGenerator(new BigInteger(DH_G, 16));\r\n    context.setServerDhPublicKey(SERVER_PUBLIC_KEY);\r\n    preparator.prepareHandshakeMessageContents();\r\n    assertArrayEquals(PREMASTERSECRET, message.getComputations().getPremasterSecret().getValue());\r\n    assertNotNull(message.getPublicKeyLength().getValue());\r\n    assertNotNull(message.getPublicKey());\r\n    assertNotNull(message.getComputations().getClientServerRandom());\r\n    assertArrayEquals(ArrayConverter.concatenate(ArrayConverter.hexStringToByteArray(RANDOM), ArrayConverter.hexStringToByteArray(RANDOM)), message.getComputations().getClientServerRandom().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.CertificateMessageHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class certificatemessagehandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new CertificateMessage()) instanceof CertificateMessageSerializer);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.helloareadescription.HelloAreaDescriptionActivity.saveAdf",
	"Comment": "save the current area description file.performs saving on a background thread and displays a progress dialog.",
	"Method": "void saveAdf(String adfName){\r\n    mSaveAdfTask = new SaveAdfTask(this, this, mTango, adfName);\r\n    mSaveAdfTask.execute();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.record.cipher.RecordBlockCipherTest.testEncryptTls12",
	"Comment": "test of encrypt method, of class recordblockcipher, for tls12.",
	"Method": "void testEncryptTls12(){\r\n    RandomHelper.setRandom(new BadRandom(new Random(0), null));\r\n    context.setConnection(new OutboundConnection());\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA256);\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS12);\r\n    context.setClientRandom(ArrayConverter.hexStringToByteArray(\"04324f7660b420bb3851d9d47acb933dbe70399bf6c92da33af01d4fb770e98c\"));\r\n    context.setServerRandom(ArrayConverter.hexStringToByteArray(\"60e4c0b6e3c608e9009b9ea6f3b363b2ffba6c68aae03e238906e1d39fc28ff2\"));\r\n    context.setMasterSecret(ArrayConverter.hexStringToByteArray(\"E2C53BF814820DBBDEE155136C3D1266366E15DF235C8409CEBA95F66B7F3471D093308CA889162888B1B2AF59C12E66\"));\r\n    byte[] iv = ArrayConverter.hexStringToByteArray(\"60B420BB3851D9D47ACB933DBE70399B\");\r\n    byte[] data = ArrayConverter.hexStringToByteArray(\"1400000C085BE7DCDCC455020E3B578A9812C4AAD8FDCA97E7B389632B6DD1F3D61A3878413B995C942EA842CE8B2E4B0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F\");\r\n    cipher = new RecordBlockCipher(context, KeySetGenerator.generateKeySet(context));\r\n    EncryptionResult encryptionResult = cipher.encrypt(new EncryptionRequest(data, iv, null));\r\n    byte[] correctCiphertext = ArrayConverter.hexStringToByteArray(\"60B420BB3851D9D47ACB933DBE70399BB7556D6BBB782F6B13EF212326DEE109ED896514DD83AB9DDB7C9B8ACB79E738E0A928C05217E90DC98D6F3E326C2751A0B12C06E2C3D852E72075098F3387E1\");\r\n    assertArrayEquals(correctCiphertext, encryptionResult.getCompleteEncryptedCipherText());\r\n    assertArrayEquals(iv, encryptionResult.getInitialisationVector());\r\n    data = ArrayConverter.hexStringToByteArray(\"54657374EDE63C0E2BDAB2875D35FFC30ED4C327F7B54CCB0707070707070707\");\r\n    correctCiphertext = ArrayConverter.hexStringToByteArray(\"60B420BB3851D9D47ACB933DBE70399BE55651CF88774ED9990F91F4BD25C30881331F16DC8FBD609F0E7714CD4678EF\");\r\n    encryptionResult = cipher.encrypt(new EncryptionRequest(data, iv, null));\r\n    assertArrayEquals(correctCiphertext, encryptionResult.getCompleteEncryptedCipherText());\r\n    assertArrayEquals(iv, encryptionResult.getInitialisationVector());\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPI1Test.testTessBaseAPIGetBoolVariable",
	"Comment": "test of tessbaseapigetboolvariable method, of class tessapi1.",
	"Method": "void testTessBaseAPIGetBoolVariable(){\r\n    logger.info(\"TessBaseAPIGetBoolVariable\");\r\n    String name = \"tessedit_create_hocr\";\r\n    TessAPI1.TessBaseAPISetVariable(handle, name, \"1\");\r\n    IntBuffer value = IntBuffer.allocate(1);\r\n    int result = -1;\r\n    if (TessAPI1.TessBaseAPIGetBoolVariable(handle, \"tessedit_create_hocr\", value) == TRUE) {\r\n        result = value.get(0);\r\n    }\r\n    int expResult = 1;\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.record.cipher.RecordBlockCipherTest.testEncryptTls10",
	"Comment": "test of encrypt method, of class recordblockcipher, for tls10.",
	"Method": "void testEncryptTls10(){\r\n    context.setConnection(new OutboundConnection());\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA);\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS10);\r\n    context.setClientRandom(ArrayConverter.hexStringToByteArray(\"03c08c3460b420bb3851d9d47acb933dbe70399bf6c92da33af01d4fb770e98c\"));\r\n    context.setServerRandom(ArrayConverter.hexStringToByteArray(\"78f0c84e04d3c23cad94aad61ccae23ce79bcd9d2d6953f8ccbe0e528c63a238\"));\r\n    context.setMasterSecret(ArrayConverter.hexStringToByteArray(\"F81015161244782B3541E6020140556E4FFEA98C57FCF6CEC172CD8B577DC73CCDE4B724E07DB8687DDF327CD8A68891\"));\r\n    byte[] data = ArrayConverter.hexStringToByteArray(\"1400000CCE92FBEC9131F48A63FED31F71573F726479AA9108FB86A4FA16BC1D5CB5753003030303\");\r\n    cipher = new RecordBlockCipher(context, KeySetGenerator.generateKeySet(context));\r\n    byte[] ciphertext = cipher.encrypt(new EncryptionRequest(data, cipher.getEncryptionIV(), null)).getCompleteEncryptedCipherText();\r\n    byte[] correctCiphertext = ArrayConverter.hexStringToByteArray(\"C34B06D54CDE2A5AF25EE0AE1896F6F149720FA9EC205C6629B2C7F52A7F3A72931E351D4AD26E23\");\r\n    assertArrayEquals(correctCiphertext, ciphertext);\r\n    data = ArrayConverter.hexStringToByteArray(\"54657374EDE63C0E2BDAB2875D35FFC30ED4C327F7B54CCB0707070707070707\");\r\n    ciphertext = cipher.encrypt(new EncryptionRequest(data, cipher.getEncryptionIV(), null)).getCompleteEncryptedCipherText();\r\n    correctCiphertext = ArrayConverter.hexStringToByteArray(\"7829006A6B93FA6348E1074E58CCEFA9EBBEA3202ABA82F9A2B7BC26D187AF08\");\r\n    assertArrayEquals(correctCiphertext, ciphertext);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.UnknownSerializerTest.testSerializeProtocolMessageContent",
	"Comment": "test of serializeprotocolmessagecontent method, of classunknownserializer.",
	"Method": "void testSerializeProtocolMessageContent(){\r\n    msg.setCompleteResultingMessage(new byte[] { 1, 2, 3 });\r\n    assertArrayEquals(new byte[] { 1, 2, 3 }, serializer.serialize());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n    ArrayList<TangoCoordinateFramePair> framePairs = new ArrayList<TangoCoordinateFramePair>();\r\n    mTango.connectListener(framePairs, new OnTangoUpdateListener() {\r\n        @Override\r\n        public void onPoseAvailable(TangoPoseData pose) {\r\n        }\r\n        @Override\r\n        public void onFrameAvailable(int cameraId) {\r\n            if (cameraId == TangoCameraIntrinsics.TANGO_CAMERA_COLOR) {\r\n                mIsFrameAvailableTangoThread.set(true);\r\n                mSurfaceView.requestRender();\r\n            }\r\n        }\r\n        @Override\r\n        public void onXyzIjAvailable(TangoXyzIjData xyzIj) {\r\n        }\r\n        @Override\r\n        public void onPointCloudAvailable(TangoPointCloudData pointCloud) {\r\n            mPointCloudManager.updatePointCloud(pointCloud);\r\n        }\r\n        @Override\r\n        public void onTangoEvent(TangoEvent event) {\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n    if (cameraId == TangoCameraIntrinsics.TANGO_CAMERA_COLOR) {\r\n        mIsFrameAvailableTangoThread.set(true);\r\n        mSurfaceView.requestRender();\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n    mPointCloudManager.updatePointCloud(pointCloud);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.WorkflowInputDelegateTest.testGetWorkflowInput",
	"Comment": "test of getworkflowinput method, of class workflowinputdelegate.",
	"Method": "void testGetWorkflowInput(){\r\n    args = new String[2];\r\n    args[0] = \"-workflow_input\";\r\n    args[1] = tempFile.getAbsolutePath();\r\n    assertFalse(tempFile.getAbsolutePath().equals(delegate.getWorkflowInput()));\r\n    jcommander.parse(args);\r\n    assertTrue(tempFile.getAbsolutePath().equals(delegate.getWorkflowInput()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.EcPointFormatExtensionHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class ecpointformatextensionhandler.",
	"Method": "void testAdjustTLSContext(){\r\n    ECPointFormatExtensionMessage msg = new ECPointFormatExtensionMessage();\r\n    msg.setPointFormats(new byte[] { 0, 1 });\r\n    handler.adjustTLSContext(msg);\r\n    assertTrue(context.getClientPointFormatsList().size() == 2);\r\n    assertTrue(context.getClientPointFormatsList().contains(ECPointFormat.UNCOMPRESSED));\r\n    assertTrue(context.getClientPointFormatsList().contains(ECPointFormat.ANSIX962_COMPRESSED_PRIME));\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellomotiontracking.HelloMotionTrackingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to new pose data.",
	"Method": "void startupTango(){\r\n    final ArrayList<TangoCoordinateFramePair> framePairs = new ArrayList<TangoCoordinateFramePair>();\r\n    framePairs.add(new TangoCoordinateFramePair(TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_DEVICE));\r\n    mTango.connectListener(framePairs, new OnTangoUpdateListener() {\r\n        @Override\r\n        public void onPoseAvailable(final TangoPoseData pose) {\r\n            logPose(pose);\r\n        }\r\n        @Override\r\n        public void onXyzIjAvailable(TangoXyzIjData xyzIj) {\r\n        }\r\n        @Override\r\n        public void onPointCloudAvailable(TangoPointCloudData pointCloud) {\r\n        }\r\n        @Override\r\n        public void onTangoEvent(final TangoEvent event) {\r\n        }\r\n        @Override\r\n        public void onFrameAvailable(int cameraId) {\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellomotiontracking.HelloMotionTrackingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to new pose data.",
	"Method": "void startupTango(){\r\n    logPose(pose);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellomotiontracking.HelloMotionTrackingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to new pose data.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellomotiontracking.HelloMotionTrackingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to new pose data.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellomotiontracking.HelloMotionTrackingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to new pose data.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellomotiontracking.HelloMotionTrackingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to new pose data.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ServerHelloDoneHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class serverhellodonehandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof ServerHelloDoneParser);\r\n}"
}, {
	"Path": "org.takes.http.FtBasicTest.server",
	"Comment": "mocked serversocket so that socket will throw socketexception.",
	"Method": "ServerSocket server(){\r\n    final ServerSocket server = Mockito.mock(ServerSocket.class);\r\n    final Socket socket = Mockito.mock(Socket.class, new Answer<Socket>() {\r\n        @Override\r\n        public Socket answer(final InvocationOnMock invocation) throws Throwable {\r\n            throw new SocketException(\"Broken pipe\");\r\n        }\r\n    });\r\n    Mockito.when(server.accept()).thenReturn(socket);\r\n    return server;\r\n}"
}, {
	"Path": "org.takes.http.FtBasicTest.server",
	"Comment": "mocked serversocket so that socket will throw socketexception.",
	"Method": "ServerSocket server(){\r\n    throw new SocketException(\"Broken pipe\");\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.projectionMatrixFromCameraIntrinsics",
	"Comment": "use tango camera intrinsics to calculate the projection matrix for the rajawali scene.",
	"Method": "float[] projectionMatrixFromCameraIntrinsics(TangoCameraIntrinsics intrinsics){\r\n    float near = 0.1f;\r\n    float far = 100;\r\n    double cx = intrinsics.cx;\r\n    double cy = intrinsics.cy;\r\n    double width = intrinsics.width;\r\n    double height = intrinsics.height;\r\n    double fx = intrinsics.fx;\r\n    double fy = intrinsics.fy;\r\n    double xscale = near / fx;\r\n    double yscale = near / fy;\r\n    double xoffset = (cx - (width / 2.0)) * xscale;\r\n    double yoffset = -(cy - (height / 2.0)) * yscale;\r\n    float[] m = new float[16];\r\n    Matrix.frustumM(m, 0, (float) (xscale * -width / 2.0 - xoffset), (float) (xscale * width / 2.0 - xoffset), (float) (yscale * -height / 2.0 - yoffset), (float) (yscale * height / 2.0 - yoffset), near, far);\r\n    return m;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.constants.AlgorithmResolverTest.testGetCipherType",
	"Comment": "test of getciphertype method, of class algorithmresolver.",
	"Method": "void testGetCipherType(){\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_NULL_WITH_NULL_NULL) == CipherType.STREAM);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_IDEA_CBC_SHA) == CipherType.BLOCK);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5) == CipherType.BLOCK);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_RC4_128_SHA) == CipherType.STREAM);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA) == CipherType.BLOCK);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA) == CipherType.BLOCK);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA) == CipherType.BLOCK);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_AES_128_CCM) == CipherType.AEAD);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_AES_256_CCM) == CipherType.AEAD);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256) == CipherType.AEAD);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_DH_anon_WITH_AES_256_GCM_SHA384) == CipherType.AEAD);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256) == CipherType.BLOCK);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256) == CipherType.AEAD);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384) == CipherType.BLOCK);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384) == CipherType.AEAD);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_SEED_CBC_SHA) == CipherType.BLOCK);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA) == CipherType.BLOCK);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_DES_CBC_SHA) == CipherType.BLOCK);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA) == CipherType.BLOCK);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_ARIA_128_CBC_SHA256) == CipherType.BLOCK);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_ARIA_128_GCM_SHA256) == CipherType.AEAD);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_DH_anon_WITH_ARIA_256_CBC_SHA384) == CipherType.BLOCK);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_ARIA_256_GCM_SHA384) == CipherType.AEAD);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_GOSTR341094_WITH_28147_CNT_IMIT) == CipherType.STREAM);\r\n    assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256) == CipherType.STREAM);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.DHClientKeyExchangeParser.parseSerializedPublicKey",
	"Comment": "reads the next bytes as the serializedpublickey and writes them in themessage",
	"Method": "void parseSerializedPublicKey(T message){\r\n    message.setPublicKey(parseByteArrayField(message.getPublicKeyLength().getValue()));\r\n    LOGGER.debug(\"SerializedPublicKey: \" + ArrayConverter.bytesToHexString(message.getPublicKey().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetTransportHandler",
	"Comment": "test of gettransporthandler method, of class defaultchooser.",
	"Method": "void testGetTransportHandler(){\r\n    TransportHandler transportHandler = new ClientTcpTransportHandler(0, \"abc\", 0);\r\n    context.setTransportHandler(transportHandler);\r\n    assertEquals(transportHandler, chooser.getTransportHandler());\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.wrapsIndexOutOfBoundsExceptionFromGet",
	"Comment": "verboselist should wraps outofboundsexception thrown by get method.",
	"Method": "void wrapsIndexOutOfBoundsExceptionFromGet(){\r\n    final int index = 5;\r\n    final Exception cause = new IndexOutOfBoundsException();\r\n    Mockito.doThrow(cause).when(this.origin).get(index);\r\n    this.thrown.expect(IndexOutOfBoundsException.class);\r\n    this.thrown.expectMessage(VerboseListTest.MSG);\r\n    this.thrown.expectCause(Matchers.is(cause));\r\n    this.list.get(index);\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.distance.CartesianDistCalc.distanceToLineSegment",
	"Comment": "todo add to generic distancecalculator and develop geo versions.",
	"Method": "double distanceToLineSegment(Point point,double vX,double vY,double wX,double wY){\r\n    double d = distanceSquared(vX, vY, wX, wY);\r\n    double toX;\r\n    double toY;\r\n    if (d <= 0) {\r\n        toX = vX;\r\n        toY = vY;\r\n    } else {\r\n        double t = ((point.getX() - vX) * (wX - vX) + (point.getY() - vY) * (wY - vY)) / d;\r\n        if (t < 0) {\r\n            toX = vX;\r\n            toY = vY;\r\n        } else if (t > 1) {\r\n            toX = wX;\r\n            toY = wY;\r\n        } else {\r\n            toX = vX + t * (wX - vX);\r\n            toY = vY + t * (wY - vY);\r\n        }\r\n    }\r\n    return distance(point, toX, toY);\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.util.GeomBuilder.polygon",
	"Comment": "creates a polygon from all linearrings on the geometry stack and places the result back on the geometry stack.",
	"Method": "GeomBuilder polygon(){\r\n    if (gstack.isEmpty() || !(gstack.peek() instanceof LinearRing)) {\r\n        ring();\r\n    }\r\n    LinearRing[] rings = gpopAll(LinearRing.class);\r\n    LinearRing outer = rings[0];\r\n    LinearRing[] inner = null;\r\n    if (rings.length > 1) {\r\n        inner = Arrays.copyOfRange(rings, 1, rings.length);\r\n    }\r\n    gstack.push(factory.createPolygon(outer, inner));\r\n    return this;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.UnknownHandshakeSerializerTest.testSerializeHandshakeMessageContent",
	"Comment": "test of serializehandshakemessagecontent method, of classunknownhandshakeserializer.",
	"Method": "void testSerializeHandshakeMessageContent(){\r\n    UnknownHandshakeMessage msg = new UnknownHandshakeMessage();\r\n    msg.setCompleteResultingMessage(expectedPart);\r\n    msg.setType(type.getValue());\r\n    msg.setLength(length);\r\n    msg.setData(data);\r\n    UnknownHandshakeSerializer serializer = new UnknownHandshakeSerializer(msg, ProtocolVersion.TLS12);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.doFitPlane",
	"Comment": "use the tango support library with point cloud data to calculate the planeof the world feature pointed at the location the camera is looking.it returns the transform of the fitted plane in a double array.",
	"Method": "float[] doFitPlane(float u,float v,double rgbTimestamp){\r\n    TangoPointCloudData pointCloud = mPointCloudManager.getLatestPointCloud();\r\n    if (pointCloud == null) {\r\n        return null;\r\n    }\r\n    TangoPoseData depthToColorPose = TangoSupport.getPoseAtTime(rgbTimestamp, TangoPoseData.COORDINATE_FRAME_CAMERA_DEPTH, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_TANGO, TangoSupport.ENGINE_TANGO, TangoSupport.ROTATION_IGNORED);\r\n    if (depthToColorPose.statusCode != TangoPoseData.POSE_VALID) {\r\n        Log.d(TAG, \"Could not get a valid pose from depth camera\" + \"to color camera at time \" + rgbTimestamp);\r\n        return null;\r\n    }\r\n    IntersectionPointPlaneModelPair intersectionPointPlaneModelPair = TangoSupport.fitPlaneModelNearPoint(pointCloud, new double[] { 0.0, 0.0, 0.0 }, new double[] { 0.0, 0.0, 0.0, 1.0 }, u, v, mDisplayRotation, depthToColorPose.translation, depthToColorPose.rotation);\r\n    mPlanePlacedTimestamp = mRgbTimestampGlThread;\r\n    return convertPlaneModelToMatrix(intersectionPointPlaneModelPair);\r\n}"
}, {
	"Path": "com.diffplug.spotless.FormatterStep.filterByFile",
	"Comment": "returns a new formatterstep which will only apply its changes\tto files which pass the given filter.\tthe provided filter must be serializable.",
	"Method": "FormatterStep filterByFile(SerializableFileFilter filter){\r\n    return new FilterByFileFormatterStep(this, filter);\r\n}"
}, {
	"Path": "studio.carbonylgroup.textfieldboxes.TextFieldBoxes.setCounterError",
	"Comment": "set highlight color and counter label text color to error color",
	"Method": "void setCounterError(){\r\n    this.onError = true;\r\n    setHighlightColor(this.errorColor);\r\n    this.counterLabel.setTextColor(this.errorColor);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.record.cipher.RecordNullCipherTest.testCalculatePadding",
	"Comment": "test of calculatepadding method, of class recordnullcipher.",
	"Method": "void testCalculatePadding(){\r\n    assertArrayEquals(record.calculatePadding(10), new byte[0]);\r\n}"
}, {
	"Path": "com.example.android.trivialdrivesample.util.IabHelper.getResponseCodeFromBundle",
	"Comment": "workaround to bug where sometimes response codes come as long instead of integer",
	"Method": "int getResponseCodeFromBundle(Bundle b){\r\n    Object o = b.get(RESPONSE_CODE);\r\n    if (o == null) {\r\n        logDebug(\"Bundle with null response code, assuming OK (known issue)\");\r\n        return BILLING_RESPONSE_RESULT_OK;\r\n    } else if (o instanceof Integer)\r\n        return ((Integer) o).intValue();\r\n    else if (o instanceof Long)\r\n        return (int) ((Long) o).longValue();\r\n    else {\r\n        logError(\"Unexpected type for bundle response code.\");\r\n        logError(o.getClass().getName());\r\n        throw new RuntimeException(\"Unexpected type for bundle response code: \" + o.getClass().getName());\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.crypto.ECCUtilsBCWrapper.readECParametersWithPublicKey",
	"Comment": "reads ecc domain parameters from an inputstream, all named formats andpoint formats are allowed. then, it also reads the public key provided inthe input stream.",
	"Method": "ECPublicKeyParameters readECParametersWithPublicKey(InputStream input){\r\n    ECDomainParameters domainParameters = readECParameters(input);\r\n    int length = input.read();\r\n    byte[] point = new byte[length];\r\n    input.read(point);\r\n    short[] pointFormats = convertPointFormats(ECPointFormat.values());\r\n    return TlsECCUtils.deserializeECPublicKey(pointFormats, domainParameters, point);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.CertificateRequestParser.parseSignatureHashAlgorithms",
	"Comment": "reads the next bytes as the signaturehashalgorithms and writes them inthe message",
	"Method": "void parseSignatureHashAlgorithms(CertificateRequestMessage message){\r\n    message.setSignatureHashAlgorithms(parseByteArrayField(message.getSignatureHashAlgorithmsLength().getValue()));\r\n    LOGGER.debug(\"SignatureHashAlgorithms: \" + ArrayConverter.bytesToHexString(message.getSignatureHashAlgorithms().getValue()));\r\n}"
}, {
	"Path": "com.reacttwitter.MainActivity.getUseDeveloperSupport",
	"Comment": "returns whether dev mode should be enabled.this enables e.g. the dev menu.",
	"Method": "boolean getUseDeveloperSupport(){\r\n    return BuildConfig.DEBUG;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.ProtocolVersionDelegateTest.testGetProtocolVersion",
	"Comment": "test of getprotocolversion method, of class protocolversiondelegate.",
	"Method": "void testGetProtocolVersion(){\r\n    args = new String[2];\r\n    args[0] = \"-version\";\r\n    args[1] = \"TLS12\";\r\n    delegate.setProtocolVersion(null);\r\n    assertFalse(delegate.getProtocolVersion() == ProtocolVersion.TLS12);\r\n    jcommander.parse(args);\r\n    assertTrue(delegate.getProtocolVersion() == ProtocolVersion.TLS12);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.SignedCertificateTimestampExtensionHandler.adjustTLSExtensionContext",
	"Comment": "parses the content of a signedcertificatetimestampextensionmessage to theactual chooser",
	"Method": "void adjustTLSExtensionContext(SignedCertificateTimestampExtensionMessage message){\r\n    if (message.getExtensionLength().getValue() > 65535) {\r\n        LOGGER.warn(\"The SingedCertificateTimestamp length shouldn't exceed 2 bytes as defined in RFC 6962. \" + \"Length was \" + message.getExtensionLength().getValue());\r\n    }\r\n    context.setSignedCertificateTimestamp(message.getSignedTimestamp().getValue());\r\n    LOGGER.debug(\"The context SignedCertificateTimestamp was set to \" + ArrayConverter.bytesToHexString(message.getSignedTimestamp()));\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.eclipse.wtp.sse.CleanupStep.format",
	"Comment": "calls the cleanup and formatting task of the processor and returns the formatted string.",
	"Method": "String format(String raw){\r\n    return processor.cleanupContent(raw);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.HeartbeatMessageHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class heartbeatmessagehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new HeartbeatMessage()) instanceof HeartbeatMessagePreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.UnknownHandshakeMessageTest.testToString",
	"Comment": "test of tostring method, of class unknownhandshakemessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"UnknownHandshakeMessage:\");\r\n    sb.append(\"\\n  Data: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.extension.PaddingExtensionPreparator.prepareExtensionContent",
	"Comment": "prepares the padding extension padding bytes based on the length set inthe context.",
	"Method": "void prepareExtensionContent(){\r\n    message.setPaddingBytes(chooser.getConfig().getDefaultPaddingExtensionBytes());\r\n    LOGGER.debug(\"Prepared PaddingExtension with \" + ArrayConverter.bytesToHexString(chooser.getConfig().getDefaultPaddingExtensionBytes()) + \" padding bytes.\");\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.PskDhClientKeyExchangeSerializerTest.testSerializeHandshakeMessageContent",
	"Comment": "test of serializehandshakemessagecontent method, of classpskdhclientkeyexchangeserializer.",
	"Method": "void testSerializeHandshakeMessageContent(){\r\n    PskDhClientKeyExchangeMessage msg = new PskDhClientKeyExchangeMessage();\r\n    msg.setCompleteResultingMessage(expectedPart);\r\n    msg.setIdentity(serializedPskIdentity);\r\n    msg.setIdentityLength(serializedPskIdentityLength);\r\n    msg.setPublicKey(ArrayConverter.hexStringToByteArray(\"32d08c13c3c7ef291e4bc7854eed91ddef2737260c09573aa8def5ce79e964a5598797470501ee6ff8be72cd8c3bbaf46ab55b77851029db3cfb38a12040a15bc8512dba290d9cae345ecf24f347e1c80c65b230e265e13c8a571e0842539536d062a6141de09017d27ac2d64c0d29cbaa19d5e55c3c6c5035c87788ac776177\"));\r\n    msg.setPublicKeyLength(128);\r\n    msg.setType(type.getValue());\r\n    msg.setLength(length);\r\n    PskDhClientKeyExchangeSerializer serializer = new PskDhClientKeyExchangeSerializer(msg, version);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellodepthperception.HelloDepthPerceptionActivity.logPointCloud",
	"Comment": "log the point count and the average depth of the given pointcloud datain the logcat as information.",
	"Method": "void logPointCloud(TangoPointCloudData pointCloudData){\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    stringBuilder.append(\"Point count: \" + pointCloudData.numPoints);\r\n    stringBuilder.append(\". Average depth (m): \" + calculateAveragedDepth(pointCloudData.points, pointCloudData.numPoints));\r\n    Log.i(TAG, stringBuilder.toString());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SrpServerKeyExchangeParser.parseSignatureLength",
	"Comment": "reads the next bytes as the signaturelength and writes them in themessage",
	"Method": "void parseSignatureLength(SrpServerKeyExchangeMessage msg){\r\n    msg.setSignatureLength(parseIntField(HandshakeByteLength.SIGNATURE_LENGTH));\r\n    LOGGER.debug(\"SignatureLength: \" + msg.getSignatureLength().getValue());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellomotiontracking.HelloMotionTrackingActivity.setupTangoConfig",
	"Comment": "sets up the tango configuration object. make sure mtango object is initialized beforemaking this call.",
	"Method": "TangoConfig setupTangoConfig(Tango tango){\r\n    TangoConfig config = tango.getConfig(TangoConfig.CONFIG_TYPE_DEFAULT);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_MOTIONTRACKING, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_AUTORECOVERY, true);\r\n    return config;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ECDHClientKeyExchangeHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class ecdhclientkeyexchangehandler.",
	"Method": "void testAdjustTLSContext(){\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS12);\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256);\r\n    context.setClientRandom(new byte[] {});\r\n    context.setServerRandom(new byte[] {});\r\n    context.getConfig().setDefaultSelectedNamedGroup(NamedGroup.SECP192R1);\r\n    context.setSelectedGroup(NamedGroup.SECP192R1);\r\n    context.setServerEcPublicKey(new CustomECPoint(new BigInteger(\"1336698681267683560144780033483217462176613397209956026562\"), new BigInteger(\"4390496211885670837594012513791855863576256216444143941964\")));\r\n    context.getConfig().setDefaultClientEcPrivateKey(new BigInteger(\"3\"));\r\n    context.getConfig().setDefaultServerEcPrivateKey(new BigInteger(\"3\"));\r\n    context.setRecordLayer(new TlsRecordLayer(context));\r\n    ECDHClientKeyExchangeMessage message = new ECDHClientKeyExchangeMessage(context.getConfig());\r\n    ECDHClientKeyExchangePreparator prep = new ECDHClientKeyExchangePreparator(context.getChooser(), message);\r\n    prep.prepare();\r\n    handler.adjustTLSContext(message);\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"273CF78A3DB2E37EE97935DEF45E3C82F126807C31A498E9\"), context.getPreMasterSecret());\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"5686D5F789AEDC43162480112E94C7C60F1292B1C5D688AE58F237BD054594775B94AC5F0B18A01B808ADBBE78BCC8C7\"), context.getMasterSecret());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.attacks.pkcs1.Pkcs1VectorGeneratorTest.testGeneratePlainPkcs1Vectors",
	"Comment": "test of generateplainpkcs1vectors method, of class pkcs1vectorgenerator.",
	"Method": "void testGeneratePlainPkcs1Vectors(){\r\n    List<Pkcs1Vector> vectors = Pkcs1VectorGenerator.generatePlainPkcs1Vectors(2048, BleichenbacherCommandConfig.Type.FAST, ProtocolVersion.TLS12);\r\n    Assert.assertNotNull(vectors);\r\n    Assert.assertEquals(\"11 PKCS#1 vectors should be generated\", 12, vectors.size());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.extension.ServerNamePairPreparatorTest.testPrepare",
	"Comment": "test of prepare method, of class servernamepairpreparator.",
	"Method": "void testPrepare(){\r\n    preparator.prepare();\r\n    assertArrayEquals(serverName, pair.getServerName().getValue());\r\n    assertEquals(serverNameType, (long) pair.getServerNameType().getValue());\r\n    assertEquals(serverNameLength, (long) pair.getServerNameLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.WorkflowTraceNormalizerTestBadInput.loadTestVector",
	"Comment": "loads a test vector from file. have a look at the test vectors to see therequired format.",
	"Method": "void loadTestVector(File testVectorPath){\r\n    String testData;\r\n    try {\r\n        testData = inputStreamToString(new FileInputStream(testVectorPath));\r\n    } catch (IOException ex) {\r\n        LOGGER.error(\"Could not load test file \" + testVectorPath + \": \" + ex);\r\n        return;\r\n    }\r\n    String[] testDataSplit = testData.split(\"(?m)#.*$\");\r\n    configXml = testDataSplit[1].trim();\r\n    traceInputXml = testDataSplit[2].trim();\r\n    try {\r\n        config = Config.createConfig(new ByteArrayInputStream(configXml.getBytes(StandardCharsets.UTF_8.name())));\r\n    } catch (UnsupportedEncodingException ex) {\r\n        LOGGER.error(\"Could not load config from test file \" + testVectorPath + \": \" + ex);\r\n        return;\r\n    }\r\n    try {\r\n        trace = WorkflowTraceSerializer.read(new ByteArrayInputStream(traceInputXml.getBytes(StandardCharsets.UTF_8.name())));\r\n    } catch (JAXBException | IOException | XMLStreamException | DataBindingException ex) {\r\n        LOGGER.error(\"Could not load workflow trace from test file \" + testVectorPath + \": \" + ex);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ECDHEServerKeyExchangeParser.parseSerializedPublicKey",
	"Comment": "reads the next bytes as the serializedpublickey and writes them in themessage",
	"Method": "void parseSerializedPublicKey(ECDHEServerKeyExchangeMessage msg){\r\n    msg.setPublicKey(parseByteArrayField(msg.getPublicKeyLength().getValue()));\r\n    LOGGER.debug(\"SerializedPublicKey: \" + ArrayConverter.bytesToHexString(msg.getPublicKey().getValue()));\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.util.Configurable.configure",
	"Comment": "used by classes urlfilters and parsefilters classes to load theconfiguration of filters from json",
	"Method": "void configure(Map stormConf,JsonNode filterParams,List<T> configure,Map stormConf,JsonNode filtersConf,Class<T> filterClass,String callingClass){\r\n    List<T> filterLists = new ArrayList();\r\n    filtersConf = filtersConf.get(callingClass);\r\n    if (filtersConf == null) {\r\n        LOG.info(\"No field {} in JSON config. Skipping\", callingClass);\r\n        return filterLists;\r\n    }\r\n    Iterator<JsonNode> filterIter = filtersConf.elements();\r\n    while (filterIter.hasNext()) {\r\n        JsonNode afilterConf = filterIter.next();\r\n        String filterName = \"<unnamed>\";\r\n        JsonNode nameNode = afilterConf.get(\"name\");\r\n        if (nameNode != null) {\r\n            filterName = nameNode.textValue();\r\n        }\r\n        JsonNode classNode = afilterConf.get(\"class\");\r\n        if (classNode == null) {\r\n            LOG.error(\"Filter {} doesn't specified a 'class' attribute\", filterName);\r\n            continue;\r\n        }\r\n        String className = classNode.textValue().trim();\r\n        filterName += '[' + className + ']';\r\n        try {\r\n            Class<?> filterImplClass = Class.forName(className);\r\n            boolean subClassOK = filterClass.isAssignableFrom(filterImplClass);\r\n            if (!subClassOK) {\r\n                LOG.error(\"Filter {} does not extend {}\", filterName, filterClass.getName());\r\n                continue;\r\n            }\r\n            T filterInstance = (T) filterImplClass.newInstance();\r\n            JsonNode paramNode = afilterConf.get(\"params\");\r\n            if (paramNode != null) {\r\n                filterInstance.configure(stormConf, paramNode);\r\n            } else {\r\n                filterInstance.configure(stormConf, NullNode.getInstance());\r\n            }\r\n            filterLists.add(filterInstance);\r\n            LOG.info(\"Setup {}\", filterName);\r\n        } catch (Exception e) {\r\n            LOG.error(\"Can't setup {}: {}\", filterName, e);\r\n            throw new RuntimeException(\"Can't setup \" + filterName, e);\r\n        }\r\n    }\r\n    return filterLists;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetClientSupportedSignatureAndHashAlgorithms",
	"Comment": "test of getclientsupportedsignatureandhashalgorithms method, of classdefaultchooser.",
	"Method": "void testGetClientSupportedSignatureAndHashAlgorithms(){\r\n    List<SignatureAndHashAlgorithm> algoList = new LinkedList();\r\n    algoList.add(SignatureAndHashAlgorithm.DSA_MD5);\r\n    config.setDefaultClientSupportedSignatureAndHashAlgorithms(algoList);\r\n    assertTrue(config.getDefaultClientSupportedSignatureAndHashAlgorithms().size() == 1);\r\n    assertTrue(chooser.getClientSupportedSignatureAndHashAlgorithms().size() == 1);\r\n    context.setClientSupportedSignatureAndHashAlgorithms(new LinkedList<SignatureAndHashAlgorithm>());\r\n    assertTrue(chooser.getClientSupportedSignatureAndHashAlgorithms().isEmpty());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n    ArrayList<TangoCoordinateFramePair> framePairs = new ArrayList<TangoCoordinateFramePair>();\r\n    mTango.connectListener(framePairs, new OnTangoUpdateListener() {\r\n        @Override\r\n        public void onPoseAvailable(TangoPoseData pose) {\r\n        }\r\n        @Override\r\n        public void onFrameAvailable(int cameraId) {\r\n            if (cameraId == TangoCameraIntrinsics.TANGO_CAMERA_COLOR) {\r\n                mIsFrameAvailableTangoThread.set(true);\r\n                mSurfaceView.requestRender();\r\n            }\r\n        }\r\n        @Override\r\n        public void onXyzIjAvailable(TangoXyzIjData xyzIj) {\r\n        }\r\n        @Override\r\n        public void onPointCloudAvailable(TangoPointCloudData pointCloud) {\r\n            mPointCloudManager.updatePointCloud(pointCloud);\r\n        }\r\n        @Override\r\n        public void onTangoEvent(TangoEvent event) {\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n    if (cameraId == TangoCameraIntrinsics.TANGO_CAMERA_COLOR) {\r\n        mIsFrameAvailableTangoThread.set(true);\r\n        mSurfaceView.requestRender();\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n    mPointCloudManager.updatePointCloud(pointCloud);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.attacks.ec.ICEPointReader.readPoints",
	"Comment": "reads points for the attack on elliptic curves from a file specific forthis named curve",
	"Method": "List<ICEPoint> readPoints(String namedCurve){\r\n    String namedCurveLow = namedCurve.toLowerCase();\r\n    String fileName = \"points_\" + namedCurveLow + \".txt\";\r\n    BufferedReader br = new BufferedReader(new InputStreamReader(ICEPointReader.class.getClassLoader().getResourceAsStream(fileName)));\r\n    String line;\r\n    List<ICEPoint> points = new LinkedList();\r\n    try {\r\n        while ((line = br.readLine()) != null) {\r\n            if (line.length() != 0 && !line.startsWith(\"#\")) {\r\n                String[] nums = line.split(\"\\\\s+,\\\\s+\");\r\n                int order = Integer.parseInt(nums[0]);\r\n                BigInteger x = new BigInteger(nums[1], 16);\r\n                BigInteger y = new BigInteger(nums[2], 16);\r\n                points.add(new ICEPoint(order, x, y));\r\n            }\r\n        }\r\n        Collections.sort(points, new ICEPointCopmparator());\r\n        if (LOGGER.isDebugEnabled()) {\r\n            LOGGER.debug(\"Using the following curves and points\");\r\n            for (ICEPoint p : points) {\r\n                LOGGER.debug(p.getOrder() + \" , \" + p.getX().toString(16) + \" , \" + p.getY().toString(16));\r\n            }\r\n        }\r\n        return points;\r\n    } catch (IOException | NumberFormatException ex) {\r\n        throw new ConfigurationException(ex.getLocalizedMessage(), ex);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.KeyShareEntryParser.parseKeyShare",
	"Comment": "reads the next bytes as the keyshare of the extension and writes them inthe message",
	"Method": "void parseKeyShare(KeyShareEntry pair){\r\n    pair.setPublicKey(parseByteArrayField(pair.getPublicKeyLength().getValue()));\r\n    LOGGER.debug(\"KeyShare: \" + ArrayConverter.bytesToHexString(pair.getPublicKey().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.CertificateVerifyParser.parseSignature",
	"Comment": "reads the next bytes as the signature and writes them in the message",
	"Method": "void parseSignature(CertificateVerifyMessage msg){\r\n    msg.setSignature(parseByteArrayField(msg.getSignatureLength().getValue()));\r\n    LOGGER.debug(\"Signatur: \" + ArrayConverter.bytesToHexString(msg.getSignature().getValue()));\r\n}"
}, {
	"Path": "com.projecttango.examples.java.greenscreen.GreenScreenActivity.setupTangoConfig",
	"Comment": "sets up the tango configuration object. make sure mtango object is initialized beforemaking this call.",
	"Method": "TangoConfig setupTangoConfig(Tango tango){\r\n    TangoConfig config = tango.getConfig(TangoConfig.CONFIG_TYPE_DEFAULT);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_COLORCAMERA, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_DEPTH, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_LOWLATENCYIMUINTEGRATION, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_DRIFT_CORRECTION, true);\r\n    config.putInt(TangoConfig.KEY_INT_DEPTH_MODE, TangoConfig.TANGO_DEPTH_MODE_POINT_CLOUD);\r\n    return config;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetMaxFragmentLength",
	"Comment": "test of getmaxfragmentlength method, of class defaultchooser.",
	"Method": "void testGetMaxFragmentLength(){\r\n    config.setDefaultMaxFragmentLength(MaxFragmentLength.TWO_9);\r\n    assertEquals(MaxFragmentLength.TWO_9, config.getMaxFragmentLength());\r\n    assertEquals(MaxFragmentLength.TWO_9, chooser.getMaxFragmentLength());\r\n    context.setMaxFragmentLength(MaxFragmentLength.TWO_11);\r\n    assertEquals(MaxFragmentLength.TWO_11, chooser.getMaxFragmentLength());\r\n}"
}, {
	"Path": "org.springframework.data.neo4j.extensions.CustomGraphRepositoryTests.shouldExposeCommonMethodOnExtendedRepository",
	"Comment": "asserts that the correct proxied object is created by spring and that we can integrate with it.",
	"Method": "void shouldExposeCommonMethodOnExtendedRepository(){\r\n    assertTrue(repository.sharedCustomMethod());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.openglar.OpenGlAugmentedRealityActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n    ArrayList<TangoCoordinateFramePair> framePairs = new ArrayList<TangoCoordinateFramePair>();\r\n    mTango.connectListener(framePairs, new OnTangoUpdateListener() {\r\n        @Override\r\n        public void onPoseAvailable(TangoPoseData pose) {\r\n        }\r\n        @Override\r\n        public void onXyzIjAvailable(TangoXyzIjData xyzIj) {\r\n        }\r\n        @Override\r\n        public void onPointCloudAvailable(TangoPointCloudData pointCloud) {\r\n        }\r\n        @Override\r\n        public void onTangoEvent(TangoEvent event) {\r\n        }\r\n        @Override\r\n        public void onFrameAvailable(int cameraId) {\r\n            if (cameraId == TangoCameraIntrinsics.TANGO_CAMERA_COLOR) {\r\n                if (mSurfaceView.getRenderMode() != GLSurfaceView.RENDERMODE_WHEN_DIRTY) {\r\n                    mSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\r\n                }\r\n                mIsFrameAvailableTangoThread.set(true);\r\n                mSurfaceView.requestRender();\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.openglar.OpenGlAugmentedRealityActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.openglar.OpenGlAugmentedRealityActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.openglar.OpenGlAugmentedRealityActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.openglar.OpenGlAugmentedRealityActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.openglar.OpenGlAugmentedRealityActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n    if (cameraId == TangoCameraIntrinsics.TANGO_CAMERA_COLOR) {\r\n        if (mSurfaceView.getRenderMode() != GLSurfaceView.RENDERMODE_WHEN_DIRTY) {\r\n            mSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\r\n        }\r\n        mIsFrameAvailableTangoThread.set(true);\r\n        mSurfaceView.requestRender();\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.SignatureAndHashAlgorithmsExtensionHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of classsignatureandhashalgorithmsextensionhandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new SignatureAndHashAlgorithmsExtensionMessage()) instanceof SignatureAndHashAlgorithmsExtensionPreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.CopyClientRandomActionTest.testGetAllAliases",
	"Comment": "test of getallaliases method, of class changeclientrandomaction.",
	"Method": "void testGetAllAliases(){\r\n    String[] aliases = action.getAllAliases().toArray(new String[2]);\r\n    assertEquals(aliases.length, 2);\r\n    assertTrue(aliases[0].equals(\"server1\") || aliases[0].equals(\"server2\"));\r\n    assertTrue(aliases[1].equals(\"server1\") || aliases[1].equals(\"server2\"));\r\n    assertNotEquals(aliases[0], aliases[1]);\r\n}"
}, {
	"Path": "com.android.vending.billing.util.Inventory.hasDetails",
	"Comment": "return whether or not details about the given product are available.",
	"Method": "boolean hasDetails(String sku){\r\n    return mSkuMap.containsKey(sku);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testIsUseExtendedMasterSecret",
	"Comment": "test of isextendedmastersecretextension method, of class defaultchooser.",
	"Method": "void testIsUseExtendedMasterSecret(){\r\n    assertEquals(false, chooser.isUseExtendedMasterSecret());\r\n    context.setUseExtendedMasterSecret(true);\r\n    assertEquals(true, chooser.isUseExtendedMasterSecret());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ServerHelloDoneHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class serverhellodonehandler.",
	"Method": "void testAdjustTLSContext(){\r\n    ServerHelloDoneMessage message = new ServerHelloDoneMessage();\r\n    handler.adjustTLSContext(message);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.NewSessionTicketPreparatorTest.testPrepare",
	"Comment": "test of prepareprotocolmessagecontents method, of classnewsessionticketpreparator.",
	"Method": "void testPrepare(){\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS12);\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256);\r\n    context.setSelectedCompressionMethod(CompressionMethod.NULL);\r\n    context.setMasterSecret(// SessionTicketMS+SessionTicketMS+SessionTicketMS+\r\n    ArrayConverter.hexStringToByteArray(\"53657373696f6e5469636b65744d532b53657373696f6e5469636b65744d532b53657373696f6e5469636b65744d532b\"));\r\n    context.setClientAuthentication(false);\r\n    TimeHelper.setProvider(new FixedTimeProvider(152113433000l));\r\n    context.getConfig().setSessionTicketLifetimeHint(3600);\r\n    RandomHelper.setRandom(new BadFixedRandom((byte) 0x55));\r\n    preparator.prepare();\r\n    assertArrayEquals(message.getTicket().getEncryptedState().getValue(), ArrayConverter.hexStringToByteArray(\"23403433756E7E6C0777047BECA5B4A1FC987804A39B420BE56DA996D6F9C233CC6C97FC2F5A3EE3A193A2ACE6F320E6AA3E98B66B4A3C51AA4056D7EF5898F8\"));\r\n    byte[] decrypted = StaticTicketCrypto.decrypt(CipherAlgorithm.AES_128_CBC, message.getTicket().getEncryptedState().getValue(), context.getChooser().getConfig().getSessionTicketKeyAES(), message.getTicket().getIV().getValue());\r\n    assertArrayEquals(decrypted, ArrayConverter.hexStringToByteArray(\"0303009c0053657373696f6e5469636b65744d532b53657373696f6e5469636b65744d532b53657373696f6e5469636b65744d532b0009111119\"));\r\n    assertTrue(message.getTicketLifetimeHint().getValue() == 3600);\r\n    assertTrue(message.getTicketLength().getValue() == 128);\r\n    assertArrayEquals(message.getTicket().getIV().getValue(), ArrayConverter.hexStringToByteArray(\"55555555555555555555555555555555\"));\r\n    assertArrayEquals(message.getTicket().getKeyName().getValue(), ArrayConverter.hexStringToByteArray(\"544c532d41747461636b6572204b6579\"));\r\n    assertArrayEquals(message.getTicket().getMAC().getValue(), ArrayConverter.hexStringToByteArray(\"C12AC5FD8690B8E61F647F86630271F16C9A6281663014C2873EE4934A6C9C3B\"));\r\n    byte[] macinput = ArrayConverter.concatenate(message.getTicket().getKeyName().getValue(), message.getTicket().getIV().getValue());\r\n    macinput = ArrayConverter.concatenate(macinput, ArrayConverter.intToBytes(message.getTicket().getEncryptedState().getValue().length, HandshakeByteLength.ENCRYPTED_STATE_LENGTH));\r\n    macinput = ArrayConverter.concatenate(macinput, message.getTicket().getEncryptedState().getValue());\r\n    assertTrue(StaticTicketCrypto.verifyHMAC(MacAlgorithm.HMAC_SHA256, message.getTicket().getMAC().getValue(), macinput, context.getChooser().getConfig().getSessionTicketKeyHMAC()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ECDHEServerKeyExchangeParser.parseSignatureAndHashAlgorithm",
	"Comment": "reads the next bytes as the signatureandhashalgorithm and writes them inthe message",
	"Method": "void parseSignatureAndHashAlgorithm(ECDHEServerKeyExchangeMessage msg){\r\n    msg.setSignatureAndHashAlgorithm(parseByteArrayField(HandshakeByteLength.SIGNATURE_HASH_ALGORITHM));\r\n    LOGGER.debug(\"SignatureAndHashAlgorithm: \" + ArrayConverter.bytesToHexString(msg.getSignatureAndHashAlgorithm().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.EllipticCurveDelegateTest.testApplyDelegate",
	"Comment": "test of applydelegate method, of class namedgroupsdelegate.",
	"Method": "void testApplyDelegate(){\r\n    args = new String[4];\r\n    args[0] = \"-named_group\";\r\n    args[1] = \"SECP192R1,SECP256R1\";\r\n    args[2] = \"-point_formats\";\r\n    args[3] = \"ANSIX962_COMPRESSED_PRIME,UNCOMPRESSED\";\r\n    Config config = Config.createConfig();\r\n    config.setDefaultSelectedNamedGroup(NamedGroup.NONE);\r\n    config.setDefaultClientSupportedPointFormats(new ECPointFormat[0]);\r\n    config.setDefaultServerSupportedPointFormats(new ECPointFormat[0]);\r\n    jcommander.parse(args);\r\n    delegate.applyDelegate(config);\r\n    assertTrue(\"SECP192R1 should get parsed correctly\", config.getDefaultClientNamedGroups().contains(NamedGroup.SECP192R1));\r\n    assertTrue(\"SECP256R1 should get parsed correctly\", config.getDefaultClientNamedGroups().contains(NamedGroup.SECP192R1));\r\n    assertTrue(\"UNCOMPRESSED should get parsed correctly\", config.getDefaultClientSupportedPointFormats().contains(ECPointFormat.UNCOMPRESSED));\r\n    assertTrue(\"ANSIX962_COMPRESSED_PRIME should get parsed correctly\", config.getDefaultClientSupportedPointFormats().contains(ECPointFormat.ANSIX962_COMPRESSED_PRIME));\r\n    assertTrue(\"UNCOMPRESSED should get parsed correctly\", config.getDefaultServerSupportedPointFormats().contains(ECPointFormat.UNCOMPRESSED));\r\n    assertTrue(\"ANSIX962_COMPRESSED_PRIME should get parsed correctly\", config.getDefaultServerSupportedPointFormats().contains(ECPointFormat.ANSIX962_COMPRESSED_PRIME));\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.io.ParseUtils.parsePointDouble",
	"Comment": "given a string containing dimension values encoded in it, separated by commas, return a double array of length dimensioncontaining the values.",
	"Method": "double[] parsePointDouble(double[] out,String externalVal,int dimension){\r\n    if (out == null || out.length != dimension)\r\n        out = new double[dimension];\r\n    int idx = externalVal.indexOf(',');\r\n    int end = idx;\r\n    int start = 0;\r\n    int i = 0;\r\n    if (idx == -1 && dimension == 1 && externalVal.length() > 0) {\r\n        out[0] = Double.parseDouble(externalVal.trim());\r\n        i = 1;\r\n    } else if (idx > 0) {\r\n        for (; i < dimension; i++) {\r\n            while (start < end && externalVal.charAt(start) == ' ') start++;\r\n            while (end > start && externalVal.charAt(end - 1) == ' ') end--;\r\n            if (start == end) {\r\n                break;\r\n            }\r\n            out[i] = Double.parseDouble(externalVal.substring(start, end));\r\n            start = idx + 1;\r\n            end = externalVal.indexOf(',', start);\r\n            idx = end;\r\n            if (end == -1) {\r\n                end = externalVal.length();\r\n            }\r\n        }\r\n    }\r\n    if (i != dimension) {\r\n        throw new InvalidShapeException(\"incompatible dimension (\" + dimension + \") and values (\" + externalVal + \").  Only \" + i + \" values specified\");\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellovideo.HelloVideoActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n    ArrayList<TangoCoordinateFramePair> framePairs = new ArrayList<TangoCoordinateFramePair>();\r\n    mTango.connectListener(framePairs, new OnTangoUpdateListener() {\r\n        @Override\r\n        public void onPoseAvailable(final TangoPoseData pose) {\r\n        }\r\n        @Override\r\n        public void onXyzIjAvailable(TangoXyzIjData xyzIj) {\r\n        }\r\n        @Override\r\n        public void onPointCloudAvailable(final TangoPointCloudData pointCloudData) {\r\n        }\r\n        @Override\r\n        public void onTangoEvent(final TangoEvent event) {\r\n        }\r\n        @Override\r\n        public void onFrameAvailable(int cameraId) {\r\n            Log.d(TAG, \"onFrameAvailable\");\r\n            if (cameraId == TangoCameraIntrinsics.TANGO_CAMERA_COLOR) {\r\n                if (mSurfaceView.getRenderMode() != GLSurfaceView.RENDERMODE_WHEN_DIRTY) {\r\n                    mSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\r\n                }\r\n                mIsFrameAvailableTangoThread.set(true);\r\n                mSurfaceView.requestRender();\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellovideo.HelloVideoActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellovideo.HelloVideoActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellovideo.HelloVideoActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellovideo.HelloVideoActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellovideo.HelloVideoActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n    Log.d(TAG, \"onFrameAvailable\");\r\n    if (cameraId == TangoCameraIntrinsics.TANGO_CAMERA_COLOR) {\r\n        if (mSurfaceView.getRenderMode() != GLSurfaceView.RENDERMODE_WHEN_DIRTY) {\r\n            mSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\r\n        }\r\n        mIsFrameAvailableTangoThread.set(true);\r\n        mSurfaceView.requestRender();\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.PskServerKeyExchangeMessageTest.testToString",
	"Comment": "test of tostring method, of class pskserverkeyexchangemessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"PskServerKeyExchangeMessage:\");\r\n    sb.append(\"\\n  IdentityHintLength: \").append(\"null\");\r\n    sb.append(\"\\n  IdentityHint: \").append(\"null\");\r\n    Assert.assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.DHEServerKeyExchangeParser.parseSignatureAndHashAlgorithm",
	"Comment": "reads the next bytes as the signatureandhashalgorithm and writes them inthe message",
	"Method": "void parseSignatureAndHashAlgorithm(DHEServerKeyExchangeMessage msg){\r\n    msg.setSignatureAndHashAlgorithm(parseByteArrayField(HandshakeByteLength.SIGNATURE_HASH_ALGORITHM));\r\n    LOGGER.debug(\"SignatureAndHashAlgorithm: \" + ArrayConverter.bytesToHexString(msg.getSignatureAndHashAlgorithm().getValue()));\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPI1Test.testTessBaseAPIGetLoadedLanguagesAsVector",
	"Comment": "test of tessbaseapigetloadedlanguagesasvector method, of class tessapi1.",
	"Method": "void testTessBaseAPIGetLoadedLanguagesAsVector(){\r\n    logger.info(\"TessBaseAPIGetLoadedLanguagesAsVector\");\r\n    TessAPI1.TessBaseAPIInit3(handle, datapath, language);\r\n    String[] expResult = { \"eng\" };\r\n    String[] result = TessAPI1.TessBaseAPIGetLoadedLanguagesAsVector(handle).getPointer().getStringArray(0);\r\n    assertArrayEquals(expResult, result);\r\n}"
}, {
	"Path": "org.takes.rq.multipart.RqMtFakeTest.closesAllParts",
	"Comment": "rqmtfake can close all parts once the request body has beenclosed.",
	"Method": "void closesAllParts(){\r\n    final String body = \"RqMtFakeTest.closesAllParts\";\r\n    final RqMultipart request = new RqMtFake(new RqFake(), new RqWithHeaders(new RqFake(\"\", \"\", body), RqMtFakeTest.contentLengthHeader((long) body.getBytes().length), RqMtFakeTest.contentDispositionHeader(\"form-data; name=\\\"name\\\"\")), new RqWithHeaders(new RqFake(\"\", \"\", body), RqMtFakeTest.contentLengthHeader(0L), RqMtFakeTest.contentDispositionHeader(\"form-data; name=\\\"content\\\"; filename=\\\"a.bin\\\"\")));\r\n    final String exmessage = \"An IOException was expected since the Stream is closed\";\r\n    final String name = \"name\";\r\n    final String closed = \"Closed\";\r\n    final String content = \"content\";\r\n    final RqMtBase multi = new RqMtBase(request);\r\n    multi.part(name).iterator().next().body().read();\r\n    multi.part(content).iterator().next().body().read();\r\n    multi.body().close();\r\n    MatcherAssert.assertThat(multi.part(name).iterator().next(), Matchers.notNullValue());\r\n    try {\r\n        multi.part(name).iterator().next().body().read();\r\n        Assert.fail(exmessage);\r\n    } catch (final IOException ex) {\r\n        MatcherAssert.assertThat(ex.getMessage(), Matchers.containsString(closed));\r\n    }\r\n    MatcherAssert.assertThat(multi.part(content).iterator().next(), Matchers.notNullValue());\r\n    try {\r\n        multi.part(content).iterator().next().body().read();\r\n        Assert.fail(exmessage);\r\n    } catch (final IOException ex) {\r\n        MatcherAssert.assertThat(ex.getMessage(), Matchers.containsString(closed));\r\n    }\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.delegatesContainsAll",
	"Comment": "verboselist should delegate containsall method to decorated list.",
	"Method": "void delegatesContainsAll(){\r\n    final List<Object> collection = Collections.emptyList();\r\n    this.list.containsAll(collection);\r\n    Mockito.verify(this.origin).containsAll(collection);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetClientSNIEntryList",
	"Comment": "test of getclientsnientrylist method, of class defaultchooser.",
	"Method": "void testGetClientSNIEntryList(){\r\n    List<SNIEntry> listSNI = new LinkedList();\r\n    listSNI.add(new SNIEntry(\"Test\", NameType.HOST_NAME));\r\n    config.setDefaultClientSNIEntryList(listSNI);\r\n    assertTrue(config.getDefaultClientSNIEntryList().size() == 1);\r\n    assertTrue(chooser.getClientSNIEntryList().size() == 1);\r\n    context.setClientSNIEntryList(new LinkedList<SNIEntry>());\r\n    assertTrue(context.getClientSNIEntryList().isEmpty());\r\n}"
}, {
	"Path": "org.springframework.cloud.consul.binder.ConsulBinderTests.getConsumerMessagePayload",
	"Comment": "return the most recent payload message a consumer received.",
	"Method": "String getConsumerMessagePayload(int port){\r\n    try {\r\n        return restTemplate.getForObject(String.format(\"http://localhost:%d/message-payload\", port), String.class);\r\n    } catch (ResourceAccessException e) {\r\n        logger.debug(\"getConsumerMessagePayload\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.PskDheServerKeyExchangeSerializerTest.testSerializeHandshakeMessageContent",
	"Comment": "test of serializehandshakemessagecontent method, of classpskdheserverkeyexchangeserializer.",
	"Method": "void testSerializeHandshakeMessageContent(){\r\n    PskDheServerKeyExchangeMessage msg = new PskDheServerKeyExchangeMessage();\r\n    msg.setCompleteResultingMessage(expectedPart);\r\n    msg.setType(type.getValue());\r\n    msg.setLength(length);\r\n    msg.setIdentityHint(PskIdentityHint);\r\n    msg.setIdentityHintLength(PskIdentityHintLength);\r\n    msg.setModulusLength(128);\r\n    msg.setModulus(ArrayConverter.hexStringToByteArray(\"b10b8f96a080e01dde92de5eae5d54ec52c99fbcfb06a3c69a6a9dca52d23b616073e28675a23d189838ef1e2ee652c013ecb4aea906112324975c3cd49b83bfaccbdd7d90c4bd7098488e9c219a73724effd6fae5644738faa31a4ff55bccc0a151af5f0dc8b4bd45bf37df365c1a65e68cfda76d4da708df1fb2bc2e4a4371\"));\r\n    msg.setGeneratorLength(128);\r\n    msg.setGenerator(ArrayConverter.hexStringToByteArray(\"a4d1cbd5c3fd34126765a442efb99905f8104dd258ac507fd6406cff14266d31266fea1e5c41564b777e690f5504f213160217b4b01b886a5e91547f9e2749f4d7fbd7d3b9a92ee1909d0d2263f80a76a6a24c087a091f531dbf0a0169b6a28ad662a4d18e73afa32d779d5918d08bc8858f4dcef97c2a24855e6eeb22b3b2e5\"));\r\n    msg.setPublicKey(ArrayConverter.hexStringToByteArray(\"70dd13c4bca8c96983bdf065ce9517eb44114a4cf4cdbc55b3bfdabde8510faa38142139409378b90e3ceba61167056fc8b0ee088132183e48b986ed468eeaaf435c9dea3a5d9c01b63a3aae176971a2e1142674675dedca8a8e91093cd42246b4fa37893d7e66534a59461935274955e5dc623c9897a6c4a8501f37427e079d\"));\r\n    msg.setPublicKeyLength(128);\r\n    PskDheServerKeyExchangeSerializer serializer = new PskDheServerKeyExchangeSerializer(msg, version);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.https.HttpsRequestParserTest.testParseMessageContentFailed",
	"Comment": "test of parsemessagecontent method, of class httpsrequestparser with aninvalid request.",
	"Method": "void testParseMessageContentFailed(){\r\n    HttpsRequestParser parser = new HttpsRequestParser(0, ArrayConverter.hexStringToByteArray(\"AAAAAAAAAAAAAAAAAAAAAAAA\"), ProtocolVersion.TLS12);\r\n    parser.parse();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.EllipticCurveDelegateTest.testSetNamedCurves",
	"Comment": "test of setnamedcurves method, of class namedgroupsdelegate.",
	"Method": "void testSetNamedCurves(){\r\n    LinkedList<NamedGroup> supportedNamedCurves = new LinkedList();\r\n    supportedNamedCurves.add(NamedGroup.BRAINPOOLP384R1);\r\n    delegate.setNamedGroups(supportedNamedCurves);\r\n    assertTrue(\"NamedCurves setter is not working correctly\", delegate.getNamedGroups().equals(supportedNamedCurves));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.RSAClientKeyExchangeHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class rsaclientkeyexchangehandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof RSAClientKeyExchangeParser);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.extension.SessionTicketTLSExtensionSerializerTest.testSerializeExtensionContent",
	"Comment": "tests the serializeextensioncontent method of thesessiontickettlsextensionserializer class",
	"Method": "void testSerializeExtensionContent(){\r\n    message = new SessionTicketTLSExtensionMessage();\r\n    message.setExtensionType(extensionType.getValue());\r\n    message.setExtensionLength(extensionLength);\r\n    message.setTicket(sessionTicket);\r\n    SessionTicketTLSExtensionSerializer serializer = new SessionTicketTLSExtensionSerializer(message);\r\n    assertArrayEquals(expectedBytes, serializer.serialize());\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.util.GeomBuilder.collection",
	"Comment": "creates a geometrycollection from all geometries on the geometry stack and places the result back on the geometry stack.",
	"Method": "GeomBuilder collection(){\r\n    gstack.push(factory.createGeometryCollection(gpopAll(Geometry.class)));\r\n    return this;\r\n}"
}, {
	"Path": "com.android.vending.billing.util.Inventory.hasPurchase",
	"Comment": "returns whether or not there exists a purchase of the given product.",
	"Method": "boolean hasPurchase(String sku){\r\n    return mPurchaseMap.containsKey(sku);\r\n}"
}, {
	"Path": "technology.tabula.RectangleSpatialIndex.getBounds",
	"Comment": "minimum bounding box of all the rectangles contained on this rectanglespatialindex",
	"Method": "Rectangle getBounds(){\r\n    return Rectangle.boundingBoxOf(rectangles);\r\n}"
}, {
	"Path": "org.takes.facets.auth.codecs.CcStrictTest.canDecodeAnonymousIdentity",
	"Comment": "ccstrict can decode anonymous identity without exception.",
	"Method": "void canDecodeAnonymousIdentity(){\r\n    final Codec codec = Mockito.mock(Codec.class);\r\n    Mockito.when(codec.decode(Mockito.<byte[]>any())).thenReturn(Identity.ANONYMOUS);\r\n    MatcherAssert.assertThat(new CcStrict(codec).decode(new byte[0]), CoreMatchers.equalTo(Identity.ANONYMOUS));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.EllipticCurvesExtensionHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class ellipticcurvesextensionhandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[] { 1, 2 }, 0) instanceof EllipticCurvesExtensionParser);\r\n}"
}, {
	"Path": "android.support.v4.content.LocalBroadcastManager.registerReceiver",
	"Comment": "register a receive for any local broadcasts that match the given intentfilter.",
	"Method": "void registerReceiver(BroadcastReceiver receiver,IntentFilter filter){\r\n    synchronized (mReceivers) {\r\n        ReceiverRecord entry = new ReceiverRecord(filter, receiver);\r\n        ArrayList<IntentFilter> filters = mReceivers.get(receiver);\r\n        if (filters == null) {\r\n            filters = new ArrayList<IntentFilter>(1);\r\n            mReceivers.put(receiver, filters);\r\n        }\r\n        filters.add(filter);\r\n        for (int i = 0; i < filter.countActions(); i++) {\r\n            String action = filter.getAction(i);\r\n            ArrayList<ReceiverRecord> entries = mActions.get(action);\r\n            if (entries == null) {\r\n                entries = new ArrayList<ReceiverRecord>(1);\r\n                mActions.put(action, entries);\r\n            }\r\n            entries.add(entry);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.MaxFragmentLengthExtensionHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class maxfragmentlengthextensionhandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new MaxFragmentLengthExtensionMessage()) instanceof MaxFragmentLengthExtensionSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.TransportHandlerDelegateTest.testSetTransportHandlerType",
	"Comment": "test of settransporthandlertype method, of classtransporthandlerdelegate.",
	"Method": "void testSetTransportHandlerType(){\r\n    assertFalse(delegate.getTransportHandlerType() == TransportHandlerType.UDP);\r\n    delegate.setTransportHandlerType(TransportHandlerType.UDP);\r\n    assertTrue(delegate.getTransportHandlerType() == TransportHandlerType.UDP);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.PskDhClientKeyExchangeMessageTest.testToString",
	"Comment": "test of tostring method, of class pskdhclientkeyexchangemessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"PskDhClientKeyExchangeMessage:\");\r\n    sb.append(\"\\n  PSKIdentity Length: \").append(\"null\");\r\n    sb.append(\"\\n  PSKIdentity: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.SSL2ClientHelloMessageTest.testToString",
	"Comment": "test of tostring method, of class ssl2clienthellomessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"SSL2ClientHelloMessage:\");\r\n    sb.append(\"\\n  Protocol Version: \").append(\"null\");\r\n    sb.append(\"\\n  Type: \").append(\"null\");\r\n    sb.append(\"\\n  Supported CipherSuites: \").append(\"null\");\r\n    sb.append(\"\\n  Challange: \").append(\"null\");\r\n    sb.append(\"\\n  SessionID: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.UnknownPreparatorTest.testPrepare",
	"Comment": "test of prepareprotocolmessagecontents method, of classunknownpreparator.",
	"Method": "void testPrepare(){\r\n    message.setDataConfig(new byte[] { 6, 6, 6 });\r\n    preparator.prepare();\r\n    assertArrayEquals(new byte[] { 6, 6, 6 }, message.getCompleteResultingMessage().getValue());\r\n}"
}, {
	"Path": "com.diffplug.spotless.TestProvisioner.createLazyWithRepositories",
	"Comment": "creates a provisioner for the given repositories.\tthe first time a project is created, there are ~7 seconds of configuration\twhich will go away for all subsequent runs.\tevery call to resolve will take about 1 second, even when all artifacts are resolved.",
	"Method": "Supplier<Provisioner> createLazyWithRepositories(Consumer<RepositoryHandler> repoConfig){\r\n    return Suppliers.memoize(() -> {\r\n        Project project = ProjectBuilder.builder().build();\r\n        repoConfig.accept(project.getRepositories());\r\n        return (withTransitives, mavenCoords) -> {\r\n            Dependency[] deps = mavenCoords.stream().map(project.getDependencies()::create).toArray(Dependency[]::new);\r\n            Configuration config = project.getConfigurations().detachedConfiguration(deps);\r\n            config.setTransitive(withTransitives);\r\n            config.setDescription(mavenCoords.toString());\r\n            try {\r\n                return config.resolve();\r\n            } catch (ResolveException e) {\r\n                throw new ResolveException(config.getDescription(), e);\r\n            }\r\n        };\r\n    });\r\n}"
}, {
	"Path": "studio.carbonylgroup.textfieldboxes.TextFieldBoxes.updateBottomViewVisibility",
	"Comment": "check if the helper label and counter are both empty.if true, make the bottom view visible.otherwise, make it gone.",
	"Method": "void updateBottomViewVisibility(){\r\n    if (this.helperLabel.getText().toString().isEmpty() && this.counterLabel.getText().toString().isEmpty())\r\n        this.bottomPart.setVisibility(View.GONE);\r\n    else\r\n        this.bottomPart.setVisibility(View.VISIBLE);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetServerEcPrivateKey",
	"Comment": "test of getserverecprivatekey method, of class defaultchooser.",
	"Method": "void testGetServerEcPrivateKey(){\r\n    context.setServerEcPrivateKey(null);\r\n    config.setDefaultServerEcPrivateKey(BigInteger.ONE);\r\n    assertEquals(BigInteger.ONE, config.getDefaultServerEcPrivateKey());\r\n    assertEquals(BigInteger.ONE, chooser.getServerEcPrivateKey());\r\n    context.setServerEcPrivateKey(BigInteger.TEN);\r\n    assertEquals(BigInteger.TEN, chooser.getServerEcPrivateKey());\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPITest.testTessBaseAPIAnalyseLayout",
	"Comment": "test of tessbaseapianalyselayout method, of class tessapi.",
	"Method": "void testTessBaseAPIAnalyseLayout(){\r\n    logger.info(\"TessBaseAPIAnalyseLayout\");\r\n    File image = new File(testResourcesDataPath, \"eurotext.png\");\r\n    int expResult = 12;\r\n    Leptonica leptInstance = Leptonica.INSTANCE;\r\n    Pix pix = leptInstance.pixRead(image.getPath());\r\n    api.TessBaseAPIInit3(handle, datapath, language);\r\n    api.TessBaseAPISetImage2(handle, pix);\r\n    int pageIteratorLevel = TessPageIteratorLevel.RIL_TEXTLINE;\r\n    logger.info(\"PageIteratorLevel: \" + Utils.getConstantName(pageIteratorLevel, TessPageIteratorLevel.class));\r\n    int i = 0;\r\n    TessPageIterator pi = api.TessBaseAPIAnalyseLayout(handle);\r\n    do {\r\n        IntBuffer leftB = IntBuffer.allocate(1);\r\n        IntBuffer topB = IntBuffer.allocate(1);\r\n        IntBuffer rightB = IntBuffer.allocate(1);\r\n        IntBuffer bottomB = IntBuffer.allocate(1);\r\n        api.TessPageIteratorBoundingBox(pi, pageIteratorLevel, leftB, topB, rightB, bottomB);\r\n        int left = leftB.get();\r\n        int top = topB.get();\r\n        int right = rightB.get();\r\n        int bottom = bottomB.get();\r\n        logger.info(String.format(\"Box[%d]: x=%d, y=%d, w=%d, h=%d\", i++, left, top, right - left, bottom - top));\r\n    } while (api.TessPageIteratorNext(pi, pageIteratorLevel) == TRUE);\r\n    api.TessPageIteratorDelete(pi);\r\n    PointerByReference pRef = new PointerByReference();\r\n    pRef.setValue(pix.getPointer());\r\n    leptInstance.pixDestroy(pRef);\r\n    assertEquals(expResult, i);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SrpServerKeyExchangeParser.parseModulusLength",
	"Comment": "reads the next bytes as the nlength and writes them in the message",
	"Method": "void parseModulusLength(SrpServerKeyExchangeMessage msg){\r\n    msg.setModulusLength(parseIntField(HandshakeByteLength.SRP_MODULUS_LENGTH));\r\n    LOGGER.debug(\"Modulus Length: \" + msg.getModulusLength().getValue());\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.wrapsIndexOutOfBoundsExceptionFromRemove",
	"Comment": "verboselist should wraps outofboundsexception thrown by remove method.",
	"Method": "void wrapsIndexOutOfBoundsExceptionFromRemove(){\r\n    final int index = 5;\r\n    final Exception cause = new IndexOutOfBoundsException();\r\n    Mockito.doThrow(cause).when(this.origin).remove(index);\r\n    this.thrown.expect(IndexOutOfBoundsException.class);\r\n    this.thrown.expectMessage(VerboseListTest.MSG);\r\n    this.thrown.expectCause(Matchers.is(cause));\r\n    this.list.remove(index);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ApplicationMessageHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class applicationmessagehandler.",
	"Method": "void testAdjustTLSContext(){\r\n    ApplicationMessage message = new ApplicationMessage();\r\n    message.setData(new byte[] { 0, 1, 2, 3, 4, 5, 6 });\r\n    handler.adjustTLSContext(message);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.updateLine",
	"Comment": "update the oldest line endpoint to the value passed into this function.this will also flag the line for update on the next render pass.",
	"Method": "void updateLine(MeasuredPoint newPoint){\r\n    if (mPointSwitch) {\r\n        mPointSwitch = !mPointSwitch;\r\n        mMeasuredPoints[0] = newPoint;\r\n        return;\r\n    }\r\n    mPointSwitch = !mPointSwitch;\r\n    mMeasuredPoints[1] = newPoint;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.factory.WorkflowConfigurationFactoryTest.testCreateHandshakeWorkflow",
	"Comment": "test of createhandshakeworkflow method, of classworkflowconfigurationfactory.",
	"Method": "void testCreateHandshakeWorkflow(){\r\n    WorkflowTrace handshakeWorkflow;\r\n    MessageAction lastAction;\r\n    MessageAction messageAction4;\r\n    ReceiveAction receiveAction;\r\n    config.setHighestProtocolVersion(ProtocolVersion.TLS13);\r\n    config.setClientAuthentication(false);\r\n    workflowConfigurationFactory = new WorkflowConfigurationFactory(config);\r\n    handshakeWorkflow = workflowConfigurationFactory.createWorkflowTrace(WorkflowTraceType.HANDSHAKE, RunningModeType.CLIENT);\r\n    Assert.assertThat(handshakeWorkflow.getMessageActions().size(), Matchers.greaterThanOrEqualTo(3));\r\n    Assert.assertNotNull(handshakeWorkflow.getLastMessageAction());\r\n    lastAction = handshakeWorkflow.getLastMessageAction();\r\n    Assert.assertEquals(FinishedMessage.class, lastAction.getMessages().get(lastAction.getMessages().size() - 1).getClass());\r\n    config.setClientAuthentication(true);\r\n    workflowConfigurationFactory = new WorkflowConfigurationFactory(config);\r\n    handshakeWorkflow = workflowConfigurationFactory.createWorkflowTrace(WorkflowTraceType.HANDSHAKE, RunningModeType.CLIENT);\r\n    lastAction = handshakeWorkflow.getLastMessageAction();\r\n    Assert.assertEquals(CertificateMessage.class, lastAction.getMessages().get(0).getClass());\r\n    Assert.assertEquals(CertificateVerifyMessage.class, lastAction.getMessages().get(1).getClass());\r\n    Assert.assertEquals(FinishedMessage.class, lastAction.getMessages().get(2).getClass());\r\n    config.setHighestProtocolVersion(ProtocolVersion.DTLS10);\r\n    config.setClientAuthentication(true);\r\n    workflowConfigurationFactory = new WorkflowConfigurationFactory(config);\r\n    handshakeWorkflow = workflowConfigurationFactory.createWorkflowTrace(WorkflowTraceType.HANDSHAKE, RunningModeType.CLIENT);\r\n    Assert.assertThat(handshakeWorkflow.getMessageActions().size(), Matchers.greaterThanOrEqualTo(6));\r\n    messageAction4 = handshakeWorkflow.getMessageActions().get(4);\r\n    Assert.assertEquals(CertificateMessage.class, messageAction4.getMessages().get(0).getClass());\r\n    Assert.assertEquals(CertificateVerifyMessage.class, messageAction4.getMessages().get(messageAction4.getMessages().size() - 3).getClass());\r\n    Assert.assertEquals(ChangeCipherSpecMessage.class, messageAction4.getMessages().get(messageAction4.getMessages().size() - 2).getClass());\r\n    Assert.assertEquals(FinishedMessage.class, messageAction4.getMessages().get(messageAction4.getMessages().size() - 1).getClass());\r\n    receiveAction = (ReceiveAction) handshakeWorkflow.getLastMessageAction();\r\n    Assert.assertEquals(ChangeCipherSpecMessage.class, receiveAction.getExpectedMessages().get(0).getClass());\r\n    Assert.assertEquals(FinishedMessage.class, receiveAction.getExpectedMessages().get(1).getClass());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskClientKeyExchangeHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class pskclientkeyexchangehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new PskClientKeyExchangeMessage()) instanceof PskClientKeyExchangePreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetClientSupportedCompressions",
	"Comment": "test of getclientsupportedcompressions method, of class defaultchooser.",
	"Method": "void testGetClientSupportedCompressions(){\r\n    LinkedList<CompressionMethod> clientSupportedCompressionMethods = new LinkedList();\r\n    LinkedList<CompressionMethod> clientSupportedCompressionMethods2 = new LinkedList();\r\n    clientSupportedCompressionMethods.add(CompressionMethod.LZS);\r\n    clientSupportedCompressionMethods.add(CompressionMethod.NULL);\r\n    clientSupportedCompressionMethods.add(CompressionMethod.DEFLATE);\r\n    config.setDefaultClientSupportedCompressionMethods(clientSupportedCompressionMethods);\r\n    assertEquals(clientSupportedCompressionMethods, config.getDefaultClientSupportedCompressionMethods());\r\n    assertEquals(clientSupportedCompressionMethods, chooser.getClientSupportedCompressions());\r\n    context.setClientSupportedCompressions(clientSupportedCompressionMethods2);\r\n    assertEquals(clientSupportedCompressionMethods2, chooser.getClientSupportedCompressions());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.SrpServerKeyExchangeMessageTest.testToString",
	"Comment": "test of tostring method, of class srpserverkeyexchangemessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"SrpServerKeyExchangeMessage:\");\r\n    sb.append(\"\\n  Modulus p: \").append(\"null\");\r\n    sb.append(\"\\n  Generator g: \").append(\"null\");\r\n    sb.append(\"\\n  Public Key: \").append(\"null\");\r\n    sb.append(\"\\n  Signature and Hash Algorithm: \").append(\"null\");\r\n    sb.append(\"\\n  Signature: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.EllipticCurveDelegateTest.testSetPointFormats",
	"Comment": "test of setpointformats method, of class namedgroupsdelegate.",
	"Method": "void testSetPointFormats(){\r\n    LinkedList<ECPointFormat> supportedPointFormats = new LinkedList();\r\n    supportedPointFormats.add(ECPointFormat.UNCOMPRESSED);\r\n    delegate.setPointFormats(supportedPointFormats);\r\n    assertTrue(\"PointFormats setter is not working correctly\", delegate.getPointFormats().equals(supportedPointFormats));\r\n}"
}, {
	"Path": "com.diffplug.gradle.spotless.SpotlessTask.formatViolationsFor",
	"Comment": "returns an exception which indicates problem files nicely.",
	"Method": "GradleException formatViolationsFor(Formatter formatter,List<File> problemFiles){\r\n    return new GradleException(DiffMessageFormatter.builder().runToFix(\"Run 'gradlew spotlessApply' to fix these violations.\").isPaddedCell(paddedCell).formatter(formatter).problemFiles(problemFiles).getMessage());\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPI1Test.testTessBaseAPIGetUTF8Text_Pix",
	"Comment": "test of tessbaseapigetutf8text method, of class tessapi1.",
	"Method": "void testTessBaseAPIGetUTF8Text_Pix(){\r\n    logger.info(\"TessBaseAPIGetUTF8Text_Pix\");\r\n    String expResult = expOCRResult;\r\n    File tiff = new File(this.testResourcesDataPath, \"eurotext.tif\");\r\n    Pix pix = Leptonica1.pixRead(tiff.getPath());\r\n    TessAPI1.TessBaseAPIInit3(handle, datapath, language);\r\n    TessAPI1.TessBaseAPISetImage2(handle, pix);\r\n    Pointer utf8Text = TessAPI1.TessBaseAPIGetUTF8Text(handle);\r\n    String result = utf8Text.getString(0);\r\n    TessAPI1.TessDeleteText(utf8Text);\r\n    logger.info(result);\r\n    PointerByReference pRef = new PointerByReference();\r\n    pRef.setValue(pix.getPointer());\r\n    Leptonica1.pixDestroy(pRef);\r\n    assertTrue(result.startsWith(expResult));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.HelloVerifyRequestHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class helloverifyrequesthandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof HelloVerifyRequestParser);\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.sql.StatusUpdaterBolt.ack",
	"Comment": "do not ack the tuple straight away! wait to get the confirmation that itworked.",
	"Method": "void ack(Tuple t,String url){\r\n    List<Tuple> list = waitingAck.get(url);\r\n    if (list == null) {\r\n        super.ack(t, url);\r\n        return;\r\n    }\r\n    list.add(t);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.occlusion.OcclusionActivity.projectionMatrixFromCameraIntrinsics",
	"Comment": "use tango camera intrinsics to calculate the projection matrix for the opengl scene.",
	"Method": "float[] projectionMatrixFromCameraIntrinsics(TangoCameraIntrinsics intrinsics){\r\n    float cx = (float) intrinsics.cx;\r\n    float cy = (float) intrinsics.cy;\r\n    float width = (float) intrinsics.width;\r\n    float height = (float) intrinsics.height;\r\n    float fx = (float) intrinsics.fx;\r\n    float fy = (float) intrinsics.fy;\r\n    float near = 0.1f;\r\n    float far = 100;\r\n    float xScale = near / fx;\r\n    float yScale = near / fy;\r\n    float xOffset = (cx - (width / 2.0f)) * xScale;\r\n    float yOffset = -(cy - (height / 2.0f)) * yScale;\r\n    float[] m = new float[16];\r\n    Matrix.frustumM(m, 0, xScale * (float) -width / 2.0f - xOffset, xScale * (float) width / 2.0f - xOffset, yScale * (float) -height / 2.0f - yOffset, yScale * (float) height / 2.0f - yOffset, near, far);\r\n    return m;\r\n}"
}, {
	"Path": "com.diffplug.spotless.maven.ArtifactResolver.resolve",
	"Comment": "given a set of maven coordinates, returns a set of jars which include all\tof the specified coordinates and optionally their transitive dependencies.",
	"Method": "Set<File> resolve(String mavenCoordinate,Set<File> resolve,boolean withTransitives,Collection<String> mavenCoordinates){\r\n    List<Dependency> dependencies = mavenCoordinates.stream().map(coordinateString -> new DefaultArtifact(coordinateString)).map(artifact -> new Dependency(artifact, null)).collect(toList());\r\n    CollectRequest collectRequest = new CollectRequest(dependencies, null, repositories);\r\n    DependencyRequest dependencyRequest;\r\n    if (withTransitives) {\r\n        dependencyRequest = new DependencyRequest(collectRequest, ACCEPT_ALL);\r\n    } else {\r\n        dependencyRequest = new DependencyRequest(collectRequest, FILTER_TRANSITIVES);\r\n    }\r\n    DependencyResult dependencyResult = resolveDependencies(dependencyRequest);\r\n    return dependencyResult.getArtifactResults().stream().peek(this::logResolved).map(ArtifactResult::getArtifact).map(Artifact::getFile).collect(toSet());\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.identity.UserAuthentication.authenticateUserSignature",
	"Comment": "authenticates the given username, signature combination. a signature isgenerated and matched against the given signature. if they match thenreturns true.",
	"Method": "boolean authenticateUserSignature(String username,String timestamp,String signature){\r\n    UserInfo user = getUserInfo(username);\r\n    if (user == null) {\r\n        return false;\r\n    }\r\n    String computedSignature = Utilities.sign(timestamp, user.getHashedPassword());\r\n    return Utilities.slowStringComparison(signature, computedSignature);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.HelloRetryRequestMessageTest.testToString",
	"Comment": "test of tostring method, of class helloretryrequestmessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"HelloRetryRequestMessage:\");\r\n    sb.append(\"\\n  Protocol Version: \").append(\"null\");\r\n    sb.append(\"\\n  Selected Cipher Suite: \").append(\"null\");\r\n    sb.append(\"\\n  Extensions: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "org.springframework.data.neo4j.web.support.OpenSessionInViewInterceptor.getSessionFactory",
	"Comment": "return the neo4j ogm sessionfactory that should be used to create sessions.",
	"Method": "SessionFactory getSessionFactory(){\r\n    return this.sessionFactory;\r\n}"
}, {
	"Path": "org.springframework.data.neo4j.web.support.OpenSessionInViewInterceptor.setSessionFactory",
	"Comment": "set the neo4j ogm sessionfactory that should be used to create sessions.",
	"Method": "void setSessionFactory(SessionFactory sessionFactory){\r\n    this.sessionFactory = sessionFactory;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetDistinguishedNames",
	"Comment": "test of getdistinguishednames method, of class defaultchooser.",
	"Method": "void testGetDistinguishedNames(){\r\n    byte[] namelist = { (byte) 0, (byte) 1 };\r\n    config.setDistinguishedNames(namelist);\r\n    assertTrue(config.getDistinguishedNames().length == 2);\r\n    assertTrue(chooser.getDistinguishedNames().length == 2);\r\n    byte[] namelist2 = { (byte) 0, (byte) 1, (byte) 3 };\r\n    context.setDistinguishedNames(namelist2);\r\n    assertTrue(chooser.getDistinguishedNames().length == 3);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskClientKeyExchangeHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class pskclientkeyexchangehandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof PskClientKeyExchangeParser);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetCertificateRequestContext",
	"Comment": "test of getcertificaterequestcontext method, of class defaultchooser.",
	"Method": "void testGetCertificateRequestContext(){\r\n    context.setCertificateRequestContext(null);\r\n    byte[] requestContext = ArrayConverter.hexStringToByteArray(\"122131123987891238098123\");\r\n    byte[] requestContext2 = ArrayConverter.hexStringToByteArray(\"1221311239878912380981281294\");\r\n    config.setDefaultCertificateRequestContext(requestContext);\r\n    assertArrayEquals(requestContext, config.getDefaultCertificateRequestContext());\r\n    assertArrayEquals(requestContext, chooser.getCertificateRequestContext());\r\n    context.setCertificateRequestContext(requestContext2);\r\n    assertArrayEquals(requestContext2, chooser.getCertificateRequestContext());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorplanView.updatePanAndZoomMatrix",
	"Comment": "updates the pan and zoom matrix with the most recent drag and scale information.",
	"Method": "void updatePanAndZoomMatrix(){\r\n    float dragX;\r\n    float dragY;\r\n    float scaleFactor;\r\n    synchronized (this) {\r\n        dragX = mDragX;\r\n        dragY = mDragY;\r\n        scaleFactor = mScaleFactor;\r\n    }\r\n    mPanAndZoomMatrix.setTranslate(dragX, dragY);\r\n    mPanAndZoomMatrix.postScale(scaleFactor, scaleFactor);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.CertificateVerifyHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class certificateverifyhandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new CertificateVerifyMessage()) instanceof CertificateVerifySerializer);\r\n}"
}, {
	"Path": "org.springframework.statemachine.config.common.annotation.AbstractAnnotationBuilder.getObject",
	"Comment": "gets the object that was built. if it has not been built yet an exception\tis thrown.",
	"Method": "O getObject(){\r\n    if (!building.get()) {\r\n        throw new IllegalStateException(\"This object has not been built\");\r\n    }\r\n    return object;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ServerHelloParser.parseProtocolVersion",
	"Comment": "reads the next bytes as the protocolversion and writes them in themessage",
	"Method": "void parseProtocolVersion(SSL2ServerHelloMessage message){\r\n    message.setProtocolVersion(parseByteArrayField(SSL2ByteLength.VERSION));\r\n    LOGGER.debug(\"ProtocolVersion: \" + ArrayConverter.bytesToHexString(message.getProtocolVersion().getValue()));\r\n}"
}, {
	"Path": "com.diffplug.spotless.TestProvisioner.mavenLocal",
	"Comment": "creates a provisioner for the local maven repo for development purpose.",
	"Method": "Provisioner mavenLocal(){\r\n    return mavenLocal.get();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SrpServerKeyExchangeParser.parseSignature",
	"Comment": "reads the next bytes as the signature and writes them in the message",
	"Method": "void parseSignature(SrpServerKeyExchangeMessage msg){\r\n    msg.setSignature(parseByteArrayField(msg.getSignatureLength().getValue()));\r\n    LOGGER.debug(\"Signature: \" + ArrayConverter.bytesToHexString(msg.getSignature().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ECDHClientKeyExchangeParser.parseSerializedPublicKeyLength",
	"Comment": "reads the next bytes as the serializedpublickeylength and writes them inthe message",
	"Method": "void parseSerializedPublicKeyLength(ECDHClientKeyExchangeMessage msg){\r\n    msg.setPublicKeyLength(parseIntField(HandshakeByteLength.ECDH_PARAM_LENGTH));\r\n    LOGGER.debug(\"SerializedPublicKeyLength: \" + msg.getPublicKeyLength().getValue());\r\n}"
}, {
	"Path": "com.diffplug.gradle.spotless.SelfTest.createProject",
	"Comment": "creates a project which has had the spotlessextension setup.",
	"Method": "Project createProject(Consumer<SpotlessExtension> test){\r\n    Project project = ProjectBuilder.builder().withProjectDir(new File(\"\").getAbsoluteFile()).build();\r\n    SpotlessPlugin plugin = project.getPlugins().apply(SpotlessPlugin.class);\r\n    test.accept(plugin.getExtension());\r\n    plugin.createTasks(project);\r\n    return project;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetSelectedCipherSuite",
	"Comment": "test of getselectedciphersuite method, of class defaultchooser.",
	"Method": "void testGetSelectedCipherSuite(){\r\n    context.setSelectedCipherSuite(null);\r\n    config.setDefaultSelectedCipherSuite(CipherSuite.TLS_AES_128_CCM_SHA256);\r\n    assertEquals(CipherSuite.TLS_AES_128_CCM_SHA256, config.getDefaultSelectedCipherSuite());\r\n    assertEquals(CipherSuite.TLS_AES_128_CCM_SHA256, chooser.getSelectedCipherSuite());\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA);\r\n    assertEquals(CipherSuite.TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA, chooser.getSelectedCipherSuite());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.HeartbeatMessageHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class heartbeatmessagehandler.",
	"Method": "void testAdjustTLSContext(){\r\n    HeartbeatMessage message = new HeartbeatMessage();\r\n    handler.adjustTLSContext(message);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.EllipticCurvesExtensionParser.parseSupportedGroups",
	"Comment": "reads the next bytes as the supportedcurves of the extension and writesthem in the message",
	"Method": "void parseSupportedGroups(EllipticCurvesExtensionMessage msg){\r\n    msg.setSupportedGroups(parseByteArrayField(msg.getSupportedGroupsLength().getValue()));\r\n    LOGGER.debug(\"SupportedGroups: \" + ArrayConverter.bytesToHexString(msg.getSupportedGroups().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.https.HttpsResponseParserTest.testParseMessageContentSuccess",
	"Comment": "test of parsemessagecontent method, of class httpsresponseparser with avalid response.",
	"Method": "void testParseMessageContentSuccess(){\r\n    String message = \"HTTP/1.1 200 OK\\r\\nDate: Mon, 27 Jul 2009 12:28:53 GMT\\r\\nServer: Apache/2.2.14 (Win32)\\r\\n\" + \"Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT\\r\\nContent-Length: 88\\r\\nContent-Type: text/html\\r\\nConnection: Closed\\r\\n\\r\\ntest\";\r\n    HttpsResponseParser parser = new HttpsResponseParser(0, message.getBytes(Charset.forName(\"UTF-8\")), ProtocolVersion.TLS12);\r\n    HttpsResponseMessage parsedMessage = parser.parse();\r\n    assertEquals(parsedMessage.getResponseStatusCode().getValue(), \"200 OK\");\r\n    assertEquals(parsedMessage.getResponseProtocol().getValue(), \"HTTP/1.1\");\r\n    assertEquals(parsedMessage.getResponseContent().getValue(), \"test\");\r\n    assertEquals(parsedMessage.getHeader().get(0).getHeaderName().getValue(), \"Date\");\r\n    assertEquals(parsedMessage.getHeader().get(0).getHeaderValue().getValue(), \"Mon, 27 Jul 2009 12:28:53 GMT\");\r\n    assertEquals(parsedMessage.getHeader().get(1).getHeaderName().getValue(), \"Server\");\r\n    assertEquals(parsedMessage.getHeader().get(1).getHeaderValue().getValue(), \"Apache/2.2.14 (Win32)\");\r\n    assertEquals(parsedMessage.getHeader().get(2).getHeaderName().getValue(), \"Last-Modified\");\r\n    assertEquals(parsedMessage.getHeader().get(2).getHeaderValue().getValue(), \"Wed, 22 Jul 2009 19:15:56 GMT\");\r\n    assertEquals(parsedMessage.getHeader().get(3).getHeaderName().getValue(), \"Content-Length\");\r\n    assertEquals(parsedMessage.getHeader().get(3).getHeaderValue().getValue(), \"88\");\r\n    assertEquals(parsedMessage.getHeader().get(4).getHeaderName().getValue(), \"Content-Type\");\r\n    assertEquals(parsedMessage.getHeader().get(4).getHeaderValue().getValue(), \"text/html\");\r\n    assertEquals(parsedMessage.getHeader().get(5).getHeaderName().getValue(), \"Connection\");\r\n    assertEquals(parsedMessage.getHeader().get(5).getHeaderValue().getValue(), \"Closed\");\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.CertificateVerifySerializerTest.testSerializeHandshakeMessageContent",
	"Comment": "test of serializehandshakemessagecontent method, of classcertificateverifyserializer.",
	"Method": "void testSerializeHandshakeMessageContent(){\r\n    CertificateVerifyMessage message = new CertificateVerifyMessage();\r\n    message.setLength(length);\r\n    message.setType(type.getValue());\r\n    message.setSignature(signature);\r\n    message.setSignatureLength(signatureLength);\r\n    message.setSignatureHashAlgorithm(sigHashAlgo);\r\n    CertificateVerifySerializer serializer = new CertificateVerifySerializer(message, ProtocolVersion.TLS12);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ServerHelloDoneHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class serverhellodonehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new ServerHelloDoneMessage()) instanceof ServerHelloDonePreparator);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void connectRenderer(){\r\n    mRenderer.getCurrentScene().registerFrameCallback(new ASceneFrameCallback() {\r\n        @Override\r\n        public void onPreFrame(long sceneTime, double deltaTime) {\r\n            try {\r\n                synchronized (ModelCorrespondenceActivity.this) {\r\n                    if (!mIsConnected) {\r\n                        return;\r\n                    }\r\n                    if (!mRenderer.isSceneCameraConfigured()) {\r\n                        TangoCameraIntrinsics intrinsics = TangoSupport.getCameraIntrinsicsBasedOnDisplayRotation(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mDisplayRotation);\r\n                        mRenderer.setProjectionMatrix(projectionMatrixFromCameraIntrinsics(intrinsics));\r\n                    }\r\n                    if (mConnectedTextureIdGlThread != mRenderer.getTextureId()) {\r\n                        mTango.connectTextureId(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mRenderer.getTextureId());\r\n                        mConnectedTextureIdGlThread = mRenderer.getTextureId();\r\n                        Log.d(TAG, \"connected to texture id: \" + mRenderer.getTextureId());\r\n                    }\r\n                    if (mIsFrameAvailableTangoThread.compareAndSet(true, false)) {\r\n                        mRgbTimestampGlThread = mTango.updateTexture(TangoCameraIntrinsics.TANGO_CAMERA_COLOR);\r\n                    }\r\n                    if (mRgbTimestampGlThread > mCameraPoseTimestamp) {\r\n                        TangoPoseData lastFramePose = TangoSupport.getPoseAtTime(mRgbTimestampGlThread, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                        if (lastFramePose.statusCode == TangoPoseData.POSE_VALID) {\r\n                            mRenderer.updateRenderCameraPose(lastFramePose);\r\n                            mCameraPoseTimestamp = lastFramePose.timestamp;\r\n                            if (!mCorrespondenceDone) {\r\n                                TangoSupport.MatrixTransformData transform = TangoSupport.getMatrixTransformAtTime(mCameraPoseTimestamp, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                                if (transform.statusCode == TangoPoseData.POSE_VALID) {\r\n                                    float[] rgbTHouse = calculateModelTransformFixedToCam(mDisplayRotation);\r\n                                    float[] openGlTHouse = new float[16];\r\n                                    Matrix.multiplyMM(openGlTHouse, 0, transform.matrix, 0, rgbTHouse, 0);\r\n                                    mOpenGlTHouse = openGlTHouse;\r\n                                    mModelUpdated = true;\r\n                                } else {\r\n                                    Log.w(TAG, \"Can't get camera transform at time: \" + mCameraPoseTimestamp);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            Log.w(TAG, \"Can't get device pose at time: \" + mRgbTimestampGlThread);\r\n                        }\r\n                    }\r\n                    if (mModelUpdated) {\r\n                        mRenderer.updateModelRendering(mHouseModel, mOpenGlTHouse, mDestPointList);\r\n                        mModelUpdated = false;\r\n                    }\r\n                }\r\n            } catch (TangoErrorException e) {\r\n                Log.e(TAG, \"Tango API call error within the OpenGL render thread\", e);\r\n            } catch (Throwable t) {\r\n                Log.e(TAG, \"Exception on the OpenGL thread\", t);\r\n            }\r\n        }\r\n        @Override\r\n        public void onPreDraw(long sceneTime, double deltaTime) {\r\n        }\r\n        @Override\r\n        public void onPostFrame(long sceneTime, double deltaTime) {\r\n        }\r\n        @Override\r\n        public boolean callPreFrame() {\r\n            return true;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void connectRenderer(){\r\n    try {\r\n        synchronized (ModelCorrespondenceActivity.this) {\r\n            if (!mIsConnected) {\r\n                return;\r\n            }\r\n            if (!mRenderer.isSceneCameraConfigured()) {\r\n                TangoCameraIntrinsics intrinsics = TangoSupport.getCameraIntrinsicsBasedOnDisplayRotation(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mDisplayRotation);\r\n                mRenderer.setProjectionMatrix(projectionMatrixFromCameraIntrinsics(intrinsics));\r\n            }\r\n            if (mConnectedTextureIdGlThread != mRenderer.getTextureId()) {\r\n                mTango.connectTextureId(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mRenderer.getTextureId());\r\n                mConnectedTextureIdGlThread = mRenderer.getTextureId();\r\n                Log.d(TAG, \"connected to texture id: \" + mRenderer.getTextureId());\r\n            }\r\n            if (mIsFrameAvailableTangoThread.compareAndSet(true, false)) {\r\n                mRgbTimestampGlThread = mTango.updateTexture(TangoCameraIntrinsics.TANGO_CAMERA_COLOR);\r\n            }\r\n            if (mRgbTimestampGlThread > mCameraPoseTimestamp) {\r\n                TangoPoseData lastFramePose = TangoSupport.getPoseAtTime(mRgbTimestampGlThread, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                if (lastFramePose.statusCode == TangoPoseData.POSE_VALID) {\r\n                    mRenderer.updateRenderCameraPose(lastFramePose);\r\n                    mCameraPoseTimestamp = lastFramePose.timestamp;\r\n                    if (!mCorrespondenceDone) {\r\n                        TangoSupport.MatrixTransformData transform = TangoSupport.getMatrixTransformAtTime(mCameraPoseTimestamp, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                        if (transform.statusCode == TangoPoseData.POSE_VALID) {\r\n                            float[] rgbTHouse = calculateModelTransformFixedToCam(mDisplayRotation);\r\n                            float[] openGlTHouse = new float[16];\r\n                            Matrix.multiplyMM(openGlTHouse, 0, transform.matrix, 0, rgbTHouse, 0);\r\n                            mOpenGlTHouse = openGlTHouse;\r\n                            mModelUpdated = true;\r\n                        } else {\r\n                            Log.w(TAG, \"Can't get camera transform at time: \" + mCameraPoseTimestamp);\r\n                        }\r\n                    }\r\n                } else {\r\n                    Log.w(TAG, \"Can't get device pose at time: \" + mRgbTimestampGlThread);\r\n                }\r\n            }\r\n            if (mModelUpdated) {\r\n                mRenderer.updateModelRendering(mHouseModel, mOpenGlTHouse, mDestPointList);\r\n                mModelUpdated = false;\r\n            }\r\n        }\r\n    } catch (TangoErrorException e) {\r\n        Log.e(TAG, \"Tango API call error within the OpenGL render thread\", e);\r\n    } catch (Throwable t) {\r\n        Log.e(TAG, \"Exception on the OpenGL thread\", t);\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void connectRenderer(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void connectRenderer(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void connectRenderer(){\r\n    return true;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.HeartbeatExtensionHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class heartbeatextensionhandler.",
	"Method": "void testAdjustTLSContext(){\r\n    HeartbeatExtensionMessage msg = new HeartbeatExtensionMessage();\r\n    msg.setHeartbeatMode(new byte[] { 1 });\r\n    handler.adjustTLSContext(msg);\r\n    assertTrue(context.getHeartbeatMode() == HeartbeatMode.PEER_ALLOWED_TO_SEND);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.factory.WorkflowConfigurationFactory.createHelloWorkflow",
	"Comment": "create a hello workflow for the default connection end defined in config.",
	"Method": "WorkflowTrace createHelloWorkflow(WorkflowTrace createHelloWorkflow,AliasedConnection connection){\r\n    WorkflowTrace workflowTrace = new WorkflowTrace();\r\n    if (config.getStarttlsType() != StarttlsType.NONE) {\r\n        addStartTlsActions(connection, config.getStarttlsType(), workflowTrace);\r\n    }\r\n    List<ProtocolMessage> messages = new LinkedList();\r\n    ClientHelloMessage clientHello = null;\r\n    if (config.getHighestProtocolVersion() == ProtocolVersion.DTLS10 || config.getHighestProtocolVersion() == ProtocolVersion.DTLS12) {\r\n        clientHello = new ClientHelloMessage(config);\r\n        clientHello.setIncludeInDigest(false);\r\n    } else {\r\n        clientHello = new ClientHelloMessage(config);\r\n    }\r\n    messages.add(clientHello);\r\n    workflowTrace.addTlsAction(MessageActionFactory.createAction(connection, ConnectionEndType.CLIENT, messages));\r\n    if (config.getHighestProtocolVersion() == ProtocolVersion.DTLS10 || config.getHighestProtocolVersion() == ProtocolVersion.DTLS12) {\r\n        HelloVerifyRequestMessage helloVerifyRequestMessage = new HelloVerifyRequestMessage(config);\r\n        helloVerifyRequestMessage.setIncludeInDigest(false);\r\n        messages = new LinkedList();\r\n        messages.add(helloVerifyRequestMessage);\r\n        workflowTrace.addTlsAction(MessageActionFactory.createAction(connection, ConnectionEndType.SERVER, messages));\r\n        clientHello = new ClientHelloMessage(config);\r\n        messages = new LinkedList();\r\n        messages.add(clientHello);\r\n        workflowTrace.addTlsAction(MessageActionFactory.createAction(connection, ConnectionEndType.CLIENT, messages));\r\n    }\r\n    messages = new LinkedList();\r\n    messages.add(new ServerHelloMessage(config));\r\n    if (config.getHighestProtocolVersion().isTLS13()) {\r\n        if (config.getTls13BackwardsCompatibilityMode() == Boolean.TRUE) {\r\n            messages.add(new ChangeCipherSpecMessage());\r\n        }\r\n        messages.add(new EncryptedExtensionsMessage(config));\r\n        if (config.isClientAuthentication()) {\r\n            CertificateRequestMessage certRequest = new CertificateRequestMessage(config);\r\n            messages.add(certRequest);\r\n        }\r\n        if (connection.getLocalConnectionEndType() == ConnectionEndType.CLIENT) {\r\n            messages.add(new CertificateMessage());\r\n        } else {\r\n            messages.add(new CertificateMessage(config));\r\n        }\r\n        messages.add(new CertificateVerifyMessage(config));\r\n        messages.add(new FinishedMessage(config));\r\n    } else {\r\n        CipherSuite selectedCipherSuite = config.getDefaultSelectedCipherSuite();\r\n        if (!selectedCipherSuite.isSrpSha() && !selectedCipherSuite.isPskOrDhPsk() && !selectedCipherSuite.isAnon()) {\r\n            if (connection.getLocalConnectionEndType() == ConnectionEndType.CLIENT) {\r\n                messages.add(new CertificateMessage());\r\n            } else {\r\n                messages.add(new CertificateMessage(config));\r\n            }\r\n        }\r\n        if (selectedCipherSuite.isEphemeral() || selectedCipherSuite.isSrp()) {\r\n            addServerKeyExchangeMessage(messages);\r\n        }\r\n        if (config.isClientAuthentication()) {\r\n            CertificateRequestMessage certRequest = new CertificateRequestMessage(config);\r\n            messages.add(certRequest);\r\n        }\r\n        messages.add(new ServerHelloDoneMessage(config));\r\n    }\r\n    workflowTrace.addTlsAction(MessageActionFactory.createAction(connection, ConnectionEndType.SERVER, messages));\r\n    return workflowTrace;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    final AlertDialog dialog = new AlertDialog.Builder(this).setMessage(\"Java Model Correspondence Example requires camera permission\").setPositiveButton(\"Ok\", new DialogInterface.OnClickListener() {\r\n        @Override\r\n        public void onClick(DialogInterface dialogInterface, int i) {\r\n            ActivityCompat.requestPermissions(ModelCorrespondenceActivity.this, new String[] { CAMERA_PERMISSION }, CAMERA_PERMISSION_CODE);\r\n        }\r\n    }).create();\r\n    dialog.show();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    ActivityCompat.requestPermissions(ModelCorrespondenceActivity.this, new String[] { CAMERA_PERMISSION }, CAMERA_PERMISSION_CODE);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.DynamicWorkflowDelegateTest.testIsDynamicWorkflow",
	"Comment": "test of isdynamicworkflow method, of class dynamicworkflowdelegate.",
	"Method": "void testIsDynamicWorkflow(){\r\n    args = new String[1];\r\n    args[0] = \"-dynamic_workflow\";\r\n    assertTrue(delegate.isDynamicWorkflow() == null);\r\n    jcommander.parse(args);\r\n    assertTrue(delegate.isDynamicWorkflow());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.HelloRequestHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class hellorequesthandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new HelloRequestMessage()) instanceof HelloRequestSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskServerKeyExchangeHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class pskserverkeyexchangehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new PskServerKeyExchangeMessage()) instanceof PskServerKeyExchangePreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.MessageActionFactoryTest.testCreateAsciiAction",
	"Comment": "test of createasciiaction method, of class messageactionfactory.",
	"Method": "void testCreateAsciiAction(){\r\n    MessageAction action = MessageActionFactory.createAsciiAction(clientConnection, ConnectionEndType.CLIENT, \"\");\r\n    assertEquals(action.getClass(), SendAsciiAction.class);\r\n    action = MessageActionFactory.createAsciiAction(clientConnection, ConnectionEndType.SERVER, \"\");\r\n    assertEquals(action.getClass(), ReceiveAsciiAction.class);\r\n    action = MessageActionFactory.createAsciiAction(serverConnection, ConnectionEndType.CLIENT, \"\");\r\n    assertEquals(action.getClass(), ReceiveAsciiAction.class);\r\n    action = MessageActionFactory.createAsciiAction(serverConnection, ConnectionEndType.SERVER, \"\");\r\n    assertEquals(action.getClass(), SendAsciiAction.class);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.RSAClientKeyExchangeHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class rsaclientkeyexchangehandler.",
	"Method": "void testAdjustTLSContext(){\r\n    RSAClientKeyExchangeMessage message = new RSAClientKeyExchangeMessage();\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA);\r\n    message.prepareComputations();\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS12);\r\n    context.setRecordLayer(new TlsRecordLayer(context));\r\n    message.getComputations().setPremasterSecret(ArrayConverter.hexStringToByteArray(\"0303d3fad5b20109834717bac4e7762e217add183d0c4852ab054f65ba6e93b1ed83ca5c5fa614cd3b810f4766c66feb\"));\r\n    message.getComputations().setClientServerRandom(ArrayConverter.hexStringToByteArray(\"a449532975d478abeefcfafa7522b9312bdbd0bb294fe460c4d52bab13a425b7594d0e9508874a67db6d9b8e91db4f38600e88f006bbe58f2b41deb6811c74cc\"));\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA);\r\n    handler.adjustTLSContext(message);\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"0303d3fad5b20109834717bac4e7762e217add183d0c4852ab054f65ba6e93b1ed83ca5c5fa614cd3b810f4766c66feb\"), context.getPreMasterSecret());\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"FA1D499E795E936751AD43355C26857728E78ABE1C4BCAFA6EF3C90F6D9B9E49DF1ADE262F127EB2A23BB73E142EE122\"), context.getMasterSecret());\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.identity.AWSCognitoDeveloperAuthenticationSample.regenerateKey",
	"Comment": "this method regenerates the key each time. it lookups up device detailsof a registered device. also registers device if it is not alreadyregistered.",
	"Method": "DeviceInfo regenerateKey(String uid,String username){\r\n    log.info(\"Generating encryption key\");\r\n    String encryptionKey = generateRandomString();\r\n    if (deviceAuthenticator.registerDevice(uid, encryptionKey, username)) {\r\n        return deviceAuthenticator.getDeviceInfo(uid);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ServerHelloParser.parseSessionID",
	"Comment": "reads the next bytes as the sessionid and writes them in the message",
	"Method": "void parseSessionID(SSL2ServerHelloMessage message){\r\n    message.setSessionID(parseByteArrayField(message.getSessionIdLength().getValue()));\r\n    LOGGER.debug(\"SessionID: \" + ArrayConverter.bytesToHexString(message.getSessionId().getValue()));\r\n}"
}, {
	"Path": "com.diffplug.gradle.spotless.FormatExtension.relativize",
	"Comment": "returns the relative path between root and dest,\tor null if dest is not a child of root.",
	"Method": "String relativize(File root,File dest){\r\n    String rootPath = root.getAbsolutePath();\r\n    String destPath = dest.getAbsolutePath();\r\n    if (!destPath.startsWith(rootPath)) {\r\n        return null;\r\n    } else {\r\n        return destPath.substring(rootPath.length());\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.ECPointFormatExtensionParserTest.testParseExtensionMessageContent",
	"Comment": "test of parseextensionmessagecontent method, of classecpointformatextensionparser.",
	"Method": "void testParseExtensionMessageContent(){\r\n    ECPointFormatExtensionParser parser = new ECPointFormatExtensionParser(start, extension);\r\n    ECPointFormatExtensionMessage msg = parser.parse();\r\n    assertArrayEquals(msg.getExtensionBytes().getValue(), completeExtension);\r\n    assertArrayEquals(type.getValue(), msg.getExtensionType().getValue());\r\n    assertTrue(extensionLength == msg.getExtensionLength().getValue());\r\n    assertArrayEquals(msg.getPointFormats().getValue(), pointFormats);\r\n    assertTrue(pointFormatLength == msg.getPointFormatsLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.SupportedVersionsExtensionParser.parseSupportedVersion",
	"Comment": "reads the next bytes as the supportedversion of the extension and writesthem in the message",
	"Method": "void parseSupportedVersion(SupportedVersionsExtensionMessage msg){\r\n    msg.setSupportedVersions(parseByteArrayField(msg.getSupportedVersionsLength().getValue()));\r\n    LOGGER.debug(\"SupportedVersions: \" + ArrayConverter.bytesToHexString(msg.getSupportedVersions().getValue()));\r\n}"
}, {
	"Path": "org.takes.facets.fork.TkMethodsTest.returnsMethodIsNotAllowedForUnsupportedMethods",
	"Comment": "tkmethods can return 405 status when acting on unknown method.",
	"Method": "void returnsMethodIsNotAllowedForUnsupportedMethods(){\r\n    new FtRemote(new TkMethods(new TkEmpty(), RqMethod.PUT)).exec(url -> new JdkRequest(url).method(RqMethod.POST).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_BAD_METHOD));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeProtocolVersionActionTest.testExecute",
	"Comment": "test of execute method, of class changecompressionaction.",
	"Method": "void testExecute(){\r\n    tlsContext.setSelectedProtocolVersion(ProtocolVersion.TLS12);\r\n    action.execute(state);\r\n    assertEquals(action.getOldValue(), ProtocolVersion.TLS12);\r\n    assertEquals(action.getNewValue(), ProtocolVersion.SSL2);\r\n    assertEquals(tlsContext.getSelectedProtocolVersion(), ProtocolVersion.SSL2);\r\n    assertTrue(action.isExecuted());\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPI1Test.testTessBaseAPISetVariable",
	"Comment": "test of tessbaseapisetvariable method, of class tessapi1.",
	"Method": "void testTessBaseAPISetVariable(){\r\n    logger.info(\"TessBaseAPISetVariable\");\r\n    String name = \"tessedit_create_hocr\";\r\n    String value = \"1\";\r\n    int expResult = 1;\r\n    int result = TessAPI1.TessBaseAPISetVariable(handle, name, value);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskDhClientKeyExchangeHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class pskdhclientkeyexchangehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new PskDhClientKeyExchangeMessage()) instanceof PskDhClientKeyExchangePreparator);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.setDisplayRotation",
	"Comment": "set the color camera background texture rotation and save the camera to display rotation.",
	"Method": "void setDisplayRotation(){\r\n    Display display = getWindowManager().getDefaultDisplay();\r\n    mDisplayRotation = display.getRotation();\r\n    mSurfaceView.queueEvent(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            if (mIsConnected) {\r\n                mRenderer.updateColorCameraTextureUvGlThread(mDisplayRotation);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.setDisplayRotation",
	"Comment": "set the color camera background texture rotation and save the camera to display rotation.",
	"Method": "void setDisplayRotation(){\r\n    if (mIsConnected) {\r\n        mRenderer.updateColorCameraTextureUvGlThread(mDisplayRotation);\r\n    }\r\n}"
}, {
	"Path": "org.takes.tk.TkRetry.strings",
	"Comment": "transforms a list of exceptions and returns a list of messages.",
	"Method": "List<String> strings(List<IOException> failures){\r\n    final List<String> result = new ArrayList(failures.size());\r\n    final Iterable<String> transform = new Transform(failures, new TransformAction<IOException, String>() {\r\n        @Override\r\n        public String transform(final IOException element) {\r\n            final Opt<String> message = new Opt.Single(element.getMessage());\r\n            String result = \"\";\r\n            if (message.has()) {\r\n                result = message.get();\r\n            }\r\n            return result;\r\n        }\r\n    });\r\n    final Iterator<String> messages = transform.iterator();\r\n    while (messages.hasNext()) {\r\n        result.add(messages.next());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.takes.tk.TkRetry.strings",
	"Comment": "transforms a list of exceptions and returns a list of messages.",
	"Method": "List<String> strings(List<IOException> failures){\r\n    final Opt<String> message = new Opt.Single(element.getMessage());\r\n    String result = \"\";\r\n    if (message.has()) {\r\n        result = message.get();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ECDHEServerKeyExchangeParser.parseSignature",
	"Comment": "reads the next bytes as the signature and writes them in the message",
	"Method": "void parseSignature(ECDHEServerKeyExchangeMessage msg){\r\n    msg.setSignature(parseByteArrayField(msg.getSignatureLength().getValue()));\r\n    LOGGER.debug(\"Signature: \" + ArrayConverter.bytesToHexString(msg.getSignature().getValue()));\r\n}"
}, {
	"Path": "org.takes.rs.RsPrintTest.flushHeadEvenWhenExceptionHappens",
	"Comment": "rsprint can flush head contents even when exception happens.",
	"Method": "void flushHeadEvenWhenExceptionHappens(){\r\n    final IOException exception = new IOException(\"Error\");\r\n    final FailWriter writer = new FailWriter(exception);\r\n    try {\r\n        new RsPrint(new RsText(\"World!\")).printHead(writer);\r\n    } catch (final IOException ex) {\r\n        if (!ex.equals(exception)) {\r\n            throw ex;\r\n        }\r\n    }\r\n    MatcherAssert.assertThat(writer.haveFlushed(), Matchers.is(true));\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.util.Geom.prepare",
	"Comment": "creates a prepared geometry.prepared geometries make operations like intersection must faster.",
	"Method": "PreparedGeometry prepare(Geometry g){\r\n    return PreparedGeometryFactory.prepare(g);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetDhServerPublicKey",
	"Comment": "test of getdhserverpublickey method, of class defaultchooser.",
	"Method": "void testGetDhServerPublicKey(){\r\n    context.setServerDhPublicKey(null);\r\n    config.setDefaultServerDhPublicKey(BigInteger.ONE);\r\n    assertEquals(BigInteger.ONE, config.getDefaultServerDhPublicKey());\r\n    assertEquals(BigInteger.ONE, chooser.getDhServerPublicKey());\r\n    context.setServerDhPublicKey(BigInteger.TEN);\r\n    assertEquals(BigInteger.TEN, chooser.getDhServerPublicKey());\r\n}"
}, {
	"Path": "org.takes.facets.fallback.TkFallbackTest.fallsBackWithProperMessage",
	"Comment": "tkfallback can throw an ioexception when no fallback is available.",
	"Method": "void fallsBackWithProperMessage(){\r\n    try {\r\n        new TkFallback(new TkFailure(), new FbChain()).act(new RqFake());\r\n        MatcherAssert.assertThat(\"Must throw exception\", false);\r\n    } catch (final IOException exception) {\r\n        MatcherAssert.assertThat(exception.getMessage(), Matchers.containsString(\"fallback \"));\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.hasCameraPermission",
	"Comment": "check to see if we have the necessary permissions for this app.",
	"Method": "boolean hasCameraPermission(){\r\n    return ContextCompat.checkSelfPermission(this, CAMERA_PERMISSION) == PackageManager.PERMISSION_GRANTED;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.FinishedPreparatorTest.testPrepareTLS13",
	"Comment": "test of preparehandshakemessagecontents method for tls 1.3, of classfinishedpreparator.",
	"Method": "void testPrepareTLS13(){\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_AES_128_GCM_SHA256);\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS13);\r\n    context.setConnection(new OutboundConnection());\r\n    context.setClientHandshakeTrafficSecret(ArrayConverter.hexStringToByteArray(\"2E9C9DD264A15D3C1EEC604A7C862934486764F94E35C0BA7E0B9494EAC06E82\"));\r\n    context.getDigest().setRawBytes(ArrayConverter.hexStringToByteArray(\"01010101010101010101010101010101\"));\r\n    preparator.prepare();\r\n    assertArrayEquals(message.getVerifyData().getValue(), ArrayConverter.hexStringToByteArray(\"B4AB5C21316FD38E3605D62C9022062DA84D83214EBC7BCD4BE6B3DB1971AFCA\"));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.SignedCertificateTimestampExtensionHandler.getSerializer",
	"Comment": "returns a new signedcertificatetimestampextensionserializer",
	"Method": "SignedCertificateTimestampExtensionSerializer getSerializer(SignedCertificateTimestampExtensionMessage message){\r\n    return new SignedCertificateTimestampExtensionSerializer(message);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.SignatureAndHashAlgorithmsExtensionHandlerTest.testGetParser",
	"Comment": "test of getparser method, of classsignatureandhashalgorithmsextensionhandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[] { 0, 2 }, 0) instanceof SignatureAndHashAlgorithmsExtensionParser);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.factory.WorkflowConfigurationFactory.createHandshakeWorkflow",
	"Comment": "create a handshake workflow for the default connection end defined inconfig.",
	"Method": "WorkflowTrace createHandshakeWorkflow(WorkflowTrace createHandshakeWorkflow,AliasedConnection connection){\r\n    WorkflowTrace workflowTrace = this.createHelloWorkflow(connection);\r\n    List<ProtocolMessage> messages = new LinkedList();\r\n    if (config.getHighestProtocolVersion().isTLS13()) {\r\n        if (config.isClientAuthentication()) {\r\n            messages.add(new CertificateMessage(config));\r\n            messages.add(new CertificateVerifyMessage(config));\r\n        }\r\n    } else {\r\n        if (config.isClientAuthentication()) {\r\n            messages.add(new CertificateMessage(config));\r\n            addClientKeyExchangeMessage(messages);\r\n            messages.add(new CertificateVerifyMessage(config));\r\n        } else {\r\n            addClientKeyExchangeMessage(messages);\r\n        }\r\n        messages.add(new ChangeCipherSpecMessage(config));\r\n    }\r\n    messages.add(new FinishedMessage(config));\r\n    workflowTrace.addTlsAction(MessageActionFactory.createAction(connection, ConnectionEndType.CLIENT, messages));\r\n    if (!config.getHighestProtocolVersion().isTLS13()) {\r\n        messages = new LinkedList();\r\n        messages.add(new ChangeCipherSpecMessage(config));\r\n        messages.add(new FinishedMessage(config));\r\n        workflowTrace.addTlsAction(MessageActionFactory.createAction(connection, ConnectionEndType.SERVER, messages));\r\n    }\r\n    return workflowTrace;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeCompressionActionTest.testExecute",
	"Comment": "test of execute method, of class changecompressionaction.",
	"Method": "void testExecute(){\r\n    tlsContext.setSelectedCompressionMethod(CompressionMethod.NULL);\r\n    action.execute(state);\r\n    assertEquals(action.getOldValue(), CompressionMethod.NULL);\r\n    assertEquals(action.getNewValue(), CompressionMethod.LZS);\r\n    assertEquals(tlsContext.getSelectedCompressionMethod(), CompressionMethod.LZS);\r\n    assertTrue(action.isExecuted());\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.elasticsearch.persistence.StatusUpdaterBolt.ack",
	"Comment": "do not ack the tuple straight away! wait to get the confirmation that itworked",
	"Method": "void ack(Tuple t,String url){\r\n    synchronized (waitAck) {\r\n        String sha256hex = org.apache.commons.codec.digest.DigestUtils.sha256Hex(url);\r\n        List<Tuple> tt = waitAck.getIfPresent(sha256hex);\r\n        if (tt == null) {\r\n            Metadata metadata = (Metadata) t.getValueByField(\"metadata\");\r\n            if (metadata.getFirstValue(\"es.status.skipped.sending\") != null) {\r\n                LOG.debug(\"Indexing skipped for {} with ID {} but key removed since\", url, sha256hex);\r\n                super.ack(t, url);\r\n                return;\r\n            }\r\n            tt = new LinkedList();\r\n        }\r\n        tt.add(t);\r\n        waitAck.put(sha256hex, tt);\r\n        LOG.debug(\"Added to waitAck {} with ID {} total {}\", url, sha256hex, tt.size());\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2HandshakeMessageParser.parseType",
	"Comment": "reads the next bytes as the type and writes them in the message",
	"Method": "void parseType(T msg){\r\n    msg.setType(parseByteField(SSL2ByteLength.MESSAGE_TYPE));\r\n    LOGGER.debug(\"Type: \" + msg.getType().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.CertificateRequestHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class certificaterequesthandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new CertificateRequestMessage()) instanceof CertificateRequestSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.ServerHelloPreparatorTest.testPrepare",
	"Comment": "test of preparehandshakemessagecontents method, of classserverhellopreparator.",
	"Method": "void testPrepare(){\r\n    TimeHelper.setProvider(new FixedTimeProvider(12345l));\r\n    List<CipherSuite> suiteList = new LinkedList();\r\n    context.getConfig().setHighestProtocolVersion(ProtocolVersion.TLS12);\r\n    suiteList.add(CipherSuite.TLS_DHE_DSS_WITH_AES_256_CBC_SHA256);\r\n    suiteList.add(CipherSuite.RFC_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256);\r\n    suiteList.add(CipherSuite.TLS_DHE_PSK_WITH_AES_128_GCM_SHA256);\r\n    context.setClientSupportedCiphersuites(suiteList);\r\n    List<CipherSuite> ourSuiteList = new LinkedList();\r\n    ourSuiteList.add(CipherSuite.RFC_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256);\r\n    List<CompressionMethod> ourCompressionList = new LinkedList();\r\n    ourCompressionList.add(CompressionMethod.LZS);\r\n    context.getConfig().setDefaultClientSupportedCiphersuites(ourSuiteList);\r\n    context.getConfig().setDefaultServerSupportedCompressionMethods(ourCompressionList);\r\n    context.setHighestClientProtocolVersion(ProtocolVersion.TLS11);\r\n    List<CompressionMethod> compressionList = new LinkedList();\r\n    compressionList.add(CompressionMethod.NULL);\r\n    compressionList.add(CompressionMethod.LZS);\r\n    context.setClientSupportedCompressions(compressionList);\r\n    context.getConfig().setDefaultServerSessionId(new byte[] { 0, 1, 2, 3, 4, 5 });\r\n    preparator.prepare();\r\n    assertArrayEquals(ProtocolVersion.TLS11.getValue(), message.getProtocolVersion().getValue());\r\n    assertArrayEquals(ArrayConverter.longToUint32Bytes(12345l), message.getUnixTime().getValue());\r\n    LOGGER.info(ArrayConverter.bytesToHexString(message.getRandom().getValue()));\r\n    assertArrayEquals(ArrayConverter.concatenate(ArrayConverter.longToUint32Bytes(12345l), ArrayConverter.hexStringToByteArray(\"60B420BB3851D9D47ACB933DBE70399BF6C92DA33AF01D4FB770E98C\")), message.getRandom().getValue());\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"000102030405\"), message.getSessionId().getValue());\r\n    assertTrue(6 == message.getSessionIdLength().getValue());\r\n    assertTrue(message.getExtensionBytes().getValue().length == 0);\r\n    assertTrue(0 == message.getExtensionsLength().getValue());\r\n}"
}, {
	"Path": "com.novoda.spikes.arcore.google.rendering.PointCloudRenderer.update",
	"Comment": "updates the opengl buffer contents to the provided point. repeated calls with the same pointcloud will be ignored.",
	"Method": "void update(PointCloud cloud){\r\n    if (lastPointCloud == cloud) {\r\n        return;\r\n    }\r\n    ShaderUtil.checkGLError(TAG, \"before update\");\r\n    GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, vbo);\r\n    lastPointCloud = cloud;\r\n    numPoints = lastPointCloud.getPoints().remaining() / FLOATS_PER_POINT;\r\n    if (numPoints * BYTES_PER_POINT > vboSize) {\r\n        while (numPoints * BYTES_PER_POINT > vboSize) {\r\n            vboSize *= 2;\r\n        }\r\n        GLES20.glBufferData(GLES20.GL_ARRAY_BUFFER, vboSize, null, GLES20.GL_DYNAMIC_DRAW);\r\n    }\r\n    GLES20.glBufferSubData(GLES20.GL_ARRAY_BUFFER, 0, numPoints * BYTES_PER_POINT, lastPointCloud.getPoints());\r\n    GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0);\r\n    ShaderUtil.checkGLError(TAG, \"after update\");\r\n}"
}, {
	"Path": "org.takes.rs.RsPrettyXml.prepareDocType",
	"Comment": "parses body to get doctype and configure transformerwith proper method, public id and system id.",
	"Method": "void prepareDocType(InputStream body,Transformer transformer){\r\n    try {\r\n        final String html = \"html\";\r\n        final DocumentType doctype = RsPrettyXml.getDocType(body);\r\n        if (null != doctype) {\r\n            if (null == doctype.getSystemId() && null == doctype.getPublicId() && html.equalsIgnoreCase(doctype.getName())) {\r\n                transformer.setOutputProperty(OutputKeys.METHOD, html);\r\n                transformer.setOutputProperty(OutputKeys.VERSION, \"5.0\");\r\n                return;\r\n            }\r\n            if (null != doctype.getSystemId()) {\r\n                transformer.setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctype.getSystemId());\r\n            }\r\n            if (null != doctype.getPublicId()) {\r\n                transformer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctype.getPublicId());\r\n            }\r\n        }\r\n    } finally {\r\n        body.reset();\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.extension.SessionTicketTLSExtensionPreparator.prepareExtensionContent",
	"Comment": "parses the content of a sessiontickettlsextensionmessage of thetlscontext",
	"Method": "void prepareExtensionContent(){\r\n    message.setTicket(chooser.getConfig().getTlsSessionTicket());\r\n    LOGGER.debug(\"Prepared the SessionTicketTLSExtension with Ticket \" + ArrayConverter.bytesToHexString(message.getTicket().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.CertificateVerifyMessageTest.testToString",
	"Comment": "test of tostring method, of class certificateverifymessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"CertificateVerifyMessage:\").append(\"\\n  SignatureAndHashAlgorithm: \").append(\"null\").append(\"\\n  Signature Length: \").append(\"null\").append(\"\\n  Signature: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "org.takes.facets.auth.social.PsGoogleTest.createErrorJson",
	"Comment": "construct a error response with google json syntax for errors.",
	"Method": "RsJson createErrorJson(){\r\n    final String message = \"message\";\r\n    return new RsJson(Json.createObjectBuilder().add(\"error\", Json.createObjectBuilder().add(\"errors\", Json.createArrayBuilder().add(Json.createObjectBuilder().add(\"domain\", \"usageLimits\").add(\"reason\", \"accessNotConfigured\").add(\"extendedHelp\", \"https://developers.google.com\"))).add(PsGoogleTest.CODE, HttpURLConnection.HTTP_BAD_REQUEST).add(message, \"Access Not Configured.\")).build());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.UnknownHandshakeHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class unknownhandshakehandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new UnknownHandshakeMessage()) instanceof UnknownHandshakeSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeClientRandomActionTest.testExecute",
	"Comment": "test of execute method, of class changeclientrandomaction.",
	"Method": "void testExecute(){\r\n    tlsContext.setClientRandom(new byte[] { 3 });\r\n    action.execute(state);\r\n    assertArrayEquals(action.getOldValue(), new byte[] { 3 });\r\n    assertArrayEquals(action.getNewValue(), new byte[] { 0, 1 });\r\n    assertArrayEquals(tlsContext.getClientRandom(), new byte[] { 0, 1 });\r\n    assertTrue(action.isExecuted());\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.shape.jts.JtsGeometry.narrowCollectionIfPossible",
	"Comment": "attempts to retype a geometry collection under the following circumstances, returningnull if the collection can not be retyped. single object collections are collapsed down to the object. homogenous collections are recast as the appropriate subclass.",
	"Method": "Geometry narrowCollectionIfPossible(GeometryCollection gc){\r\n    List<Geometry> geoms = new ArrayList();\r\n    for (int i = 0; i < gc.getNumGeometries(); i++) {\r\n        geoms.add(gc.getGeometryN(i));\r\n    }\r\n    Geometry result = gc.getFactory().buildGeometry(geoms);\r\n    return !result.getClass().equals(GeometryCollection.class) ? result : null;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.extension.SessionTicketTLSExtensionSerializer.serializeExtensionContent",
	"Comment": "serializes the content of a sessiontickettlsextensionmessage",
	"Method": "byte[] serializeExtensionContent(){\r\n    appendBytes(message.getTicket().getValue());\r\n    LOGGER.debug(\"Serialized PaddingExtension with SessionTicket of length \" + message.getTicket().getValue().length);\r\n    return getAlreadySerialized();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskEcDhClientKeyExchangeHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class pskecdhclientkeyexchangehandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof PskEcDhClientKeyExchangeParser);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.CertificateMessagePreparatorTest.testPrepare",
	"Comment": "test of preparehandshakemessagecontents method, of classcertificatemessagepreparator.",
	"Method": "void testPrepare(){\r\n    for (ProtocolVersion version : PROTOCOLS) {\r\n        context.setSelectedProtocolVersion(version);\r\n        final CertificateMessage message = new CertificateMessage(context.getConfig());\r\n        Certificate cert = Certificate.parse(new ByteArrayInputStream(ArrayConverter.hexStringToByteArray(\"0003970003943082039030820278A003020102020900A650C00794049FCD300D06092A864886F70D01010B0500305C310B30090603550406130241553113301106035504080C0A536F6D652D53746174653121301F060355040A0C18496E7465726E6574205769646769747320507479204C74643115301306035504030C0C544C532D41747461636B65723020170D3137303731333132353331385A180F32313137303631393132353331385A305C310B30090603550406130241553113301106035504080C0A536F6D652D53746174653121301F060355040A0C18496E7465726E6574205769646769747320507479204C74643115301306035504030C0C544C532D41747461636B657230820122300D06092A864886F70D01010105000382010F003082010A0282010100C8820D6C3CE84C8430F6835ABFC7D7A912E1664F44578751F376501A8C68476C3072D919C5D39BD0DBE080E71DB83BD4AB2F2F9BDE3DFFB0080F510A5F6929C196551F2B3C369BE051054C877573195558FD282035934DC86EDAB8D4B1B7F555E5B2FEE7275384A756EF86CB86793B5D1333F0973203CB96966766E655CD2CCCAE1940E4494B8E9FB5279593B75AFD0B378243E51A88F6EB88DEF522A8CD5C6C082286A04269A2879760FCBA45005D7F2672DD228809D47274F0FE0EA5531C2BD95366C05BF69EDC0F3C3189866EDCA0C57ADCCA93250AE78D9EACA0393A95FF9952FC47FB7679DD3803E6A7A6FA771861E3D99E4B551A4084668B111B7EEF7D0203010001A3533051301D0603551D0E04160414E7A92FE5543AEE2FF7592F800AC6E66541E3268B301F0603551D23041830168014E7A92FE5543AEE2FF7592F800AC6E66541E3268B300F0603551D130101FF040530030101FF300D06092A864886F70D01010B050003820101000D5C11E28CF19D1BC17E4FF543695168570AA7DB85B3ECB85405392A0EDAFE4F097EE4685B7285E3D9B869D23257161CA65E20B5E6A585D33DA5CD653AF81243318132C9F64A476EC08BA80486B3E439F765635A7EA8A969B3ABD8650036D74C5FC4A04589E9AC8DC3BE2708743A6CFE3B451E3740F735F156D6DC7FFC8A2C852CD4E397B942461C2FCA884C7AFB7EBEF7918D6AAEF1F0D257E959754C4665779FA0E3253EF2BEDBBD5BE5DA600A0A68E51D2D1C125C4E198669A6BC715E8F3884E9C3EFF39D40838ADA4B1F38313F6286AA395DC6DEA9DAF49396CF12EC47EFA7A0D3882F8B84D9AEEFFB252C6B81A566609605FBFD3F0D17E5B12401492A1A\")));\r\n        final CertificateMessagePreparator preparator = new CertificateMessagePreparator(context.getChooser(), message);\r\n        context.getConfig().setDefaultExplicitCertificateKeyPair(new CertificateKeyPair(cert, new CustomRSAPrivateKey(context.getConfig().getDefaultClientRSAModulus(), context.getConfig().getDefaultClientRSAPrivateKey())));\r\n        context.getConfig().setAutoSelectCertificate(false);\r\n        preparator.prepare();\r\n        LOGGER.debug(\"Certificate in msg after preparation: \" + ArrayConverter.bytesToHexString(message.getCertificatesListBytes(), false, false));\r\n        assertArrayEquals(message.getCertificatesListBytes().getValue(), ArrayConverter.hexStringToByteArray(\"0003943082039030820278A003020102020900A650C00794049FCD300D06092A864886F70D01010B0500305C310B30090603550406130241553113301106035504080C0A536F6D652D53746174653121301F060355040A0C18496E7465726E6574205769646769747320507479204C74643115301306035504030C0C544C532D41747461636B65723020170D3137303731333132353331385A180F32313137303631393132353331385A305C310B30090603550406130241553113301106035504080C0A536F6D652D53746174653121301F060355040A0C18496E7465726E6574205769646769747320507479204C74643115301306035504030C0C544C532D41747461636B657230820122300D06092A864886F70D01010105000382010F003082010A0282010100C8820D6C3CE84C8430F6835ABFC7D7A912E1664F44578751F376501A8C68476C3072D919C5D39BD0DBE080E71DB83BD4AB2F2F9BDE3DFFB0080F510A5F6929C196551F2B3C369BE051054C877573195558FD282035934DC86EDAB8D4B1B7F555E5B2FEE7275384A756EF86CB86793B5D1333F0973203CB96966766E655CD2CCCAE1940E4494B8E9FB5279593B75AFD0B378243E51A88F6EB88DEF522A8CD5C6C082286A04269A2879760FCBA45005D7F2672DD228809D47274F0FE0EA5531C2BD95366C05BF69EDC0F3C3189866EDCA0C57ADCCA93250AE78D9EACA0393A95FF9952FC47FB7679DD3803E6A7A6FA771861E3D99E4B551A4084668B111B7EEF7D0203010001A3533051301D0603551D0E04160414E7A92FE5543AEE2FF7592F800AC6E66541E3268B301F0603551D23041830168014E7A92FE5543AEE2FF7592F800AC6E66541E3268B300F0603551D130101FF040530030101FF300D06092A864886F70D01010B050003820101000D5C11E28CF19D1BC17E4FF543695168570AA7DB85B3ECB85405392A0EDAFE4F097EE4685B7285E3D9B869D23257161CA65E20B5E6A585D33DA5CD653AF81243318132C9F64A476EC08BA80486B3E439F765635A7EA8A969B3ABD8650036D74C5FC4A04589E9AC8DC3BE2708743A6CFE3B451E3740F735F156D6DC7FFC8A2C852CD4E397B942461C2FCA884C7AFB7EBEF7918D6AAEF1F0D257E959754C4665779FA0E3253EF2BEDBBD5BE5DA600A0A68E51D2D1C125C4E198669A6BC715E8F3884E9C3EFF39D40838ADA4B1F38313F6286AA395DC6DEA9DAF49396CF12EC47EFA7A0D3882F8B84D9AEEFFB252C6B81A566609605FBFD3F0D17E5B12401492A1A\"));\r\n        assertTrue(message.getCertificatesListLength().getValue() == 0x000397);\r\n        assertTrue(message.getType().getValue() == HandshakeMessageType.CERTIFICATE.getValue());\r\n        assertTrue(message.getLength().getValue() == 0x00039A);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeServerRandomActionTest.testGetNewValue",
	"Comment": "test of getnewvalue method, of class changeclientrandomaction.",
	"Method": "void testGetNewValue(){\r\n    assertArrayEquals(action.getNewValue(), new byte[] { 0, 1 });\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.ServerNameIndicationExtensionParser.parseServerNameList",
	"Comment": "reads the next bytes as the servernamelist of the extension and writesthem in the message",
	"Method": "void parseServerNameList(ServerNameIndicationExtensionMessage msg){\r\n    msg.setServerNameList(pairList);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.occlusion.OcclusionActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camera and callbacks.",
	"Method": "void connectRenderer(){\r\n    mSurfaceView.setEGLContextClientVersion(2);\r\n    mRenderer = new OcclusionRenderer(OcclusionActivity.this, new OcclusionRenderer.RenderCallback() {\r\n        @Override\r\n        public void preRender() {\r\n            try {\r\n                synchronized (OcclusionActivity.this) {\r\n                    if (!mIsConnected) {\r\n                        return;\r\n                    }\r\n                    if (!mRenderer.isProjectionMatrixConfigured()) {\r\n                        TangoCameraIntrinsics intrinsics = TangoSupport.getCameraIntrinsicsBasedOnDisplayRotation(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mDisplayRotation);\r\n                        mRenderer.setProjectionMatrix(projectionMatrixFromCameraIntrinsics(intrinsics), 0.1f, 100f);\r\n                    }\r\n                    if (mConnectedTextureIdGlThread != mRenderer.getTextureId()) {\r\n                        mTango.connectTextureId(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mRenderer.getTextureId());\r\n                        mConnectedTextureIdGlThread = mRenderer.getTextureId();\r\n                        Log.d(TAG, \"connected to texture id: \" + mRenderer.getTextureId());\r\n                    }\r\n                    if (mIsFrameAvailableTangoThread.compareAndSet(true, false)) {\r\n                        mRgbTimestampGlThread = mTango.updateTexture(TangoCameraIntrinsics.TANGO_CAMERA_COLOR);\r\n                        TangoSupport.MatrixTransformData ssTrgb = TangoSupport.getMatrixTransformAtTime(mRgbTimestampGlThread, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                        if (ssTrgb.statusCode == TangoPoseData.POSE_VALID) {\r\n                            mRenderer.updateViewMatrix(ssTrgb.matrix);\r\n                        } else {\r\n                            Log.w(TAG, \"Can't get last camera pose\");\r\n                        }\r\n                    }\r\n                }\r\n                updateMeshMap();\r\n            } catch (TangoErrorException e) {\r\n                Log.e(TAG, \"Tango API call error within the OpenGL render thread\", e);\r\n            } catch (TangoInvalidException e) {\r\n                Log.e(TAG, \"Tango API call error within the OpenGL render thread\", e);\r\n            }\r\n        }\r\n    });\r\n    mSurfaceView.setRenderer(mRenderer);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.occlusion.OcclusionActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camera and callbacks.",
	"Method": "void connectRenderer(){\r\n    try {\r\n        synchronized (OcclusionActivity.this) {\r\n            if (!mIsConnected) {\r\n                return;\r\n            }\r\n            if (!mRenderer.isProjectionMatrixConfigured()) {\r\n                TangoCameraIntrinsics intrinsics = TangoSupport.getCameraIntrinsicsBasedOnDisplayRotation(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mDisplayRotation);\r\n                mRenderer.setProjectionMatrix(projectionMatrixFromCameraIntrinsics(intrinsics), 0.1f, 100f);\r\n            }\r\n            if (mConnectedTextureIdGlThread != mRenderer.getTextureId()) {\r\n                mTango.connectTextureId(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mRenderer.getTextureId());\r\n                mConnectedTextureIdGlThread = mRenderer.getTextureId();\r\n                Log.d(TAG, \"connected to texture id: \" + mRenderer.getTextureId());\r\n            }\r\n            if (mIsFrameAvailableTangoThread.compareAndSet(true, false)) {\r\n                mRgbTimestampGlThread = mTango.updateTexture(TangoCameraIntrinsics.TANGO_CAMERA_COLOR);\r\n                TangoSupport.MatrixTransformData ssTrgb = TangoSupport.getMatrixTransformAtTime(mRgbTimestampGlThread, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                if (ssTrgb.statusCode == TangoPoseData.POSE_VALID) {\r\n                    mRenderer.updateViewMatrix(ssTrgb.matrix);\r\n                } else {\r\n                    Log.w(TAG, \"Can't get last camera pose\");\r\n                }\r\n            }\r\n        }\r\n        updateMeshMap();\r\n    } catch (TangoErrorException e) {\r\n        Log.e(TAG, \"Tango API call error within the OpenGL render thread\", e);\r\n    } catch (TangoInvalidException e) {\r\n        Log.e(TAG, \"Tango API call error within the OpenGL render thread\", e);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ECDHEServerKeyExchangeHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class ecdheserverkeyexchangehandler.",
	"Method": "void testAdjustTLSContext(){\r\n    ECDHEServerKeyExchangeMessage message = new ECDHEServerKeyExchangeMessage();\r\n    message.setCurveType(EllipticCurveType.NAMED_CURVE.getValue());\r\n    message.setNamedGroup(NamedGroup.SECP256R1.getValue());\r\n    message.setPublicKey(ArrayConverter.hexStringToByteArray(\"04f660a88e9dae015684be56c25610f9c62cf120cb075eea60c560e5e6dd5d10ef6e391d7213a298985470dc2268949317ce24940d474a0c8386ab13b312ffc104\"));\r\n    message.setPublicKeyLength(65);\r\n    message.prepareComputations();\r\n    message.getComputations().setPremasterSecret(new byte[] { 0, 1, 2, 3 });\r\n    message.getComputations().setPrivateKey(new BigInteger(\"12345\"));\r\n    handler.adjustTLSContext(message);\r\n    assertNull(context.getPreMasterSecret());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.CertificateRequestPreparatorTest.testPrepare",
	"Comment": "test of preparehandshakemessagecontents method, of classcertificaterequestpreparator.",
	"Method": "void testPrepare(){\r\n    context.getConfig().setDistinguishedNames(new byte[] { 0, 1, 2 });\r\n    List<ClientCertificateType> list = new LinkedList();\r\n    list.add(ClientCertificateType.DSS_EPHEMERAL_DH_RESERVED);\r\n    list.add(ClientCertificateType.RSA_EPHEMERAL_DH_RESERVED);\r\n    context.getConfig().setClientCertificateTypes(list);\r\n    List<SignatureAndHashAlgorithm> algoList = new LinkedList();\r\n    algoList.add(SignatureAndHashAlgorithm.ANONYMOUS_SHA1);\r\n    algoList.add(SignatureAndHashAlgorithm.ECDSA_SHA512);\r\n    context.getConfig().setDefaultServerSupportedSignatureAndHashAlgorithms(algoList);\r\n    preparator.prepare();\r\n    assertArrayEquals(new byte[] { 0, 1, 2 }, message.getDistinguishedNames().getValue());\r\n    assertTrue(3 == message.getDistinguishedNamesLength().getValue());\r\n    assertArrayEquals(new byte[] { 6, 5 }, message.getClientCertificateTypes().getValue());\r\n    assertArrayEquals(new byte[] { 2, 0, 6, 3 }, message.getSignatureHashAlgorithms().getValue());\r\n    assertTrue(4 == message.getSignatureHashAlgorithmsLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.EllipticCurvesExtensionHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class ellipticcurvesextensionhandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new EllipticCurvesExtensionMessage()) instanceof EllipticCurvesExtensionPreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.ExtensionHandler.adjustTLSContext",
	"Comment": "adjusts the tls context according to the received or sendingprotocolmessage",
	"Method": "void adjustTLSContext(Message message){\r\n    markExtensionInContext(message);\r\n    adjustTLSExtensionContext(message);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.StarttlsDelegateTest.testGetStarttlsType",
	"Comment": "test of getstarttlstype method, of class starttlsdelegate.",
	"Method": "void testGetStarttlsType(){\r\n    args = new String[2];\r\n    args[0] = \"-starttls\";\r\n    args[1] = \"POP3\";\r\n    delegate.setStarttlsType(null);\r\n    assertFalse(delegate.getStarttlsType() == StarttlsType.NONE);\r\n    jcommander.parse(args);\r\n    assertTrue(delegate.getStarttlsType() == StarttlsType.POP3);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.RSAClientKeyExchangeHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class rsaclientkeyexchangehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new RSAClientKeyExchangeMessage()) instanceof RSAClientKeyExchangePreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.CertificateRequestParser.hasDistinguishedNamesLength",
	"Comment": "checks if the distinguishednameslength has a value greater than zero",
	"Method": "boolean hasDistinguishedNamesLength(CertificateRequestMessage msg){\r\n    return msg.getDistinguishedNamesLength().getValue() != 0;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.HeartbeatMessageHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class heartbeatmessagehandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof HeartbeatMessageParser);\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.distance.DistanceUtils.distVincentyRAD",
	"Comment": "calculates the great circle distance using the vincenty formula, simplified for a spherical model. this formulais accurate for any pair of points. the equationwas taken from wikipedia.the arguments are in radians, and the result is in radians.",
	"Method": "double distVincentyRAD(double lat1,double lon1,double lat2,double lon2){\r\n    if (lat1 == lat2 && lon1 == lon2)\r\n        return 0.0;\r\n    double cosLat1 = Math.cos(lat1);\r\n    double cosLat2 = Math.cos(lat2);\r\n    double sinLat1 = Math.sin(lat1);\r\n    double sinLat2 = Math.sin(lat2);\r\n    double dLon = lon2 - lon1;\r\n    double cosDLon = Math.cos(dLon);\r\n    double sinDLon = Math.sin(dLon);\r\n    double a = cosLat2 * sinDLon;\r\n    double b = cosLat1 * sinLat2 - sinLat1 * cosLat2 * cosDLon;\r\n    double c = sinLat1 * sinLat2 + cosLat1 * cosLat2 * cosDLon;\r\n    return Math.atan2(Math.sqrt(a * a + b * b), c);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeCipherSuiteActionTest.testGetOldValue",
	"Comment": "test of getoldvalue method, of class changeciphersuiteaction.",
	"Method": "void testGetOldValue(){\r\n    action.execute(state);\r\n    assertEquals(action.getOldValue(), CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.TransportHandlerDelegateTest.testGetTransportHandlerType",
	"Comment": "test of gettransporthandlertype method, of classtransporthandlerdelegate.",
	"Method": "void testGetTransportHandlerType(){\r\n    args = new String[2];\r\n    args[0] = \"-transport_handler_type\";\r\n    args[1] = \"UDP\";\r\n    assertFalse(delegate.getTransportHandlerType() == TransportHandlerType.UDP);\r\n    jcommander.parse(args);\r\n    assertTrue(delegate.getTransportHandlerType() == TransportHandlerType.UDP);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.ModifiableVariableHolder.getAllModifiableVariableHolders",
	"Comment": "returns a list of all the modifiable variable holders in the object,including this instance",
	"Method": "List<ModifiableVariableHolder> getAllModifiableVariableHolders(){\r\n    List<ModifiableVariableHolder> holders = new LinkedList();\r\n    holders.add(this);\r\n    return holders;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.DeactivateEncryptionActionTest.testExecute",
	"Comment": "test of execute method, of class deactivateencryptionaction.",
	"Method": "void testExecute(){\r\n    action.execute(state);\r\n    assertTrue(action.isExecuted());\r\n}"
}, {
	"Path": "com.projecttango.rajawali.renderables.Trajectory.init",
	"Comment": "since only vertex and index buffers are used, we only initialize them using setdata call.",
	"Method": "void init(boolean createVBOs){\r\n    float[] vertices = new float[MAX_NUMBER_OF_VERTICES * 3];\r\n    int[] indices = new int[MAX_NUMBER_OF_VERTICES];\r\n    for (int i = 0; i < indices.length; ++i) {\r\n        indices[i] = i;\r\n    }\r\n    setData(vertices, GLES20.GL_STATIC_DRAW, null, GLES20.GL_STATIC_DRAW, null, GLES20.GL_STATIC_DRAW, null, GLES20.GL_STATIC_DRAW, indices, GLES20.GL_STATIC_DRAW, createVBOs);\r\n}"
}, {
	"Path": "studio.carbonylgroup.textfieldboxes.TextFieldBoxes.removeEndIcon",
	"Comment": "remove the end icon by setting the visibility of the end image view to view.gone",
	"Method": "void removeEndIcon(){\r\n    this.endIconResourceId = 0;\r\n    this.endIconImageButton.setImageDrawable(null);\r\n    this.endIconImageButton.setVisibility(View.GONE);\r\n    updateClearAndEndIconLayout();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.constants.AlgorithmResolverTest.testGetDigestAlgorithm",
	"Comment": "test of getdigestalgorithm method, of class algorithmresolver.",
	"Method": "void testGetDigestAlgorithm(){\r\n    for (CipherSuite suite : CipherSuite.values()) {\r\n        if (suite.name().contains(\"GOST\")) {\r\n            continue;\r\n        }\r\n        assertTrue(AlgorithmResolver.getDigestAlgorithm(ProtocolVersion.TLS10, suite) == DigestAlgorithm.LEGACY);\r\n        assertTrue(AlgorithmResolver.getDigestAlgorithm(ProtocolVersion.TLS11, suite) == DigestAlgorithm.LEGACY);\r\n        assertTrue(AlgorithmResolver.getDigestAlgorithm(ProtocolVersion.DTLS10, suite) == DigestAlgorithm.LEGACY);\r\n    }\r\n    assertTrue(AlgorithmResolver.getDigestAlgorithm(ProtocolVersion.TLS12, CipherSuite.TLS_DHE_DSS_WITH_AES_256_GCM_SHA384) == DigestAlgorithm.SHA384);\r\n    assertTrue(AlgorithmResolver.getDigestAlgorithm(ProtocolVersion.DTLS12, CipherSuite.TLS_DHE_DSS_WITH_AES_256_GCM_SHA384) == DigestAlgorithm.SHA384);\r\n    assertTrue(AlgorithmResolver.getDigestAlgorithm(ProtocolVersion.TLS12, CipherSuite.TLS_CECPQ1_ECDSA_WITH_CHACHA20_POLY1305_SHA256) == DigestAlgorithm.SHA256);\r\n    assertTrue(AlgorithmResolver.getDigestAlgorithm(ProtocolVersion.DTLS12, CipherSuite.TLS_CECPQ1_ECDSA_WITH_CHACHA20_POLY1305_SHA256) == DigestAlgorithm.SHA256);\r\n    assertTrue(AlgorithmResolver.getDigestAlgorithm(ProtocolVersion.TLS12, CipherSuite.SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA) == DigestAlgorithm.SHA256);\r\n    assertTrue(AlgorithmResolver.getDigestAlgorithm(ProtocolVersion.DTLS12, CipherSuite.TLS_DHE_PSK_WITH_AES_256_CCM) == DigestAlgorithm.SHA256);\r\n    assertTrue(AlgorithmResolver.getDigestAlgorithm(ProtocolVersion.TLS12, CipherSuite.TLS_DH_anon_EXPORT_WITH_RC4_40_MD5) == DigestAlgorithm.SHA256);\r\n    assertTrue(AlgorithmResolver.getDigestAlgorithm(ProtocolVersion.TLS12, CipherSuite.TLS_GOSTR341094_WITH_28147_CNT_IMIT) == DigestAlgorithm.GOSTR3411);\r\n    assertTrue(AlgorithmResolver.getDigestAlgorithm(ProtocolVersion.TLS12, CipherSuite.TLS_GOSTR341112_256_WITH_28147_CNT_IMIT) == DigestAlgorithm.GOSTR34112012_256);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.SupportedVersionsExtensionHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class supportedversionsextensionhandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new SupportedVersionsExtensionMessage()) instanceof SupportedVersionsExtensionSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.extension.KeySharePairSerializerTest.testSerializeBytes",
	"Comment": "test of serializebytes method, of class keyshareentryserializer.",
	"Method": "void testSerializeBytes(){\r\n    entry = new KeyShareEntry();\r\n    entry.setPublicKeyLength(32);\r\n    entry.setGroup(ArrayConverter.hexStringToByteArray(\"001D\"));\r\n    entry.setPublicKey(ArrayConverter.hexStringToByteArray(\"2a981db6cdd02a06c1763102c9e741365ac4e6f72b3176a6bd6a3523d3ec0f4c\"));\r\n    serializer = new KeyShareEntrySerializer(entry);\r\n    byte[] result = serializer.serialize();\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"001D00202a981db6cdd02a06c1763102c9e741365ac4e6f72b3176a6bd6a3523d3ec0f4c\"), result);\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.eclipse.base.SpotlessEclipseServiceConfig.ignoreContentType",
	"Comment": "eclipse provides means to lookup the file content type, e.g. by file name extensions.\tthis possibility is not required by most spotless formatters.",
	"Method": "void ignoreContentType(){\r\n    add(IContentTypeManager.class, new NoContentTypeSpecificHandling());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.hasCameraPermission",
	"Comment": "check to see if we have the necessary permissions for this app.",
	"Method": "boolean hasCameraPermission(){\r\n    return ContextCompat.checkSelfPermission(this, CAMERA_PERMISSION) == PackageManager.PERMISSION_GRANTED;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.occlusion.OcclusionActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    final AlertDialog dialog = new AlertDialog.Builder(this).setMessage(\"Java Occlusion Example requires camera permission\").setPositiveButton(\"Ok\", new DialogInterface.OnClickListener() {\r\n        @Override\r\n        public void onClick(DialogInterface dialogInterface, int i) {\r\n            ActivityCompat.requestPermissions(OcclusionActivity.this, new String[] { CAMERA_PERMISSION }, CAMERA_PERMISSION_CODE);\r\n        }\r\n    }).create();\r\n    dialog.show();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.occlusion.OcclusionActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    ActivityCompat.requestPermissions(OcclusionActivity.this, new String[] { CAMERA_PERMISSION }, CAMERA_PERMISSION_CODE);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.HelloRequestParser.parseHandshakeMessageContent",
	"Comment": "reads the next bytes as the handshakemessagecontent and writes them inthe message",
	"Method": "void parseHandshakeMessageContent(HelloRequestMessage msg){\r\n    LOGGER.debug(\"Parsing HelloRequestMessage\");\r\n    if (msg.getLength().getValue() != 0) {\r\n        LOGGER.warn(\"Parsed HelloRequest with non-zero length! Not parsing payload.\");\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ServerHelloParser.parseCertificateLength",
	"Comment": "reads the next bytes as the certificatelength and writes them in themessage",
	"Method": "void parseCertificateLength(SSL2ServerHelloMessage message){\r\n    message.setCertificateLength(parseIntField(SSL2ByteLength.CERTIFICATE_LENGTH));\r\n    LOGGER.debug(\"CertificateLength: \" + message.getCertificateLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.MaxFragmentLengthDelegateTest.testApplyDelegate",
	"Comment": "test of applydelegate method, of class maxfragmentlengthdelegate.",
	"Method": "void testApplyDelegate(){\r\n    Config config = Config.createConfig();\r\n    args = new String[2];\r\n    args[0] = \"-max_fragment_length\";\r\n    args[1] = \"4\";\r\n    assertFalse(config.getMaxFragmentLength() == MaxFragmentLength.TWO_12);\r\n    assertFalse(config.isAddMaxFragmentLengthExtension());\r\n    jcommander.parse(args);\r\n    delegate.applyDelegate(config);\r\n    assertTrue(config.isAddMaxFragmentLengthExtension());\r\n    assertTrue(config.getMaxFragmentLength() == MaxFragmentLength.TWO_12);\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.distance.DistanceUtils.distSquaredCartesian",
	"Comment": "the square of the cartesian distance.not really a distance, but useful if all that matters iscomparing the result to another one.",
	"Method": "double distSquaredCartesian(double[] vec1,double[] vec2){\r\n    double result = 0;\r\n    for (int i = 0; i < vec1.length; i++) {\r\n        double v = vec1[i] - vec2[i];\r\n        result += v * v;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.takes.rs.RsPrettyXml.getDocType",
	"Comment": "parses the input stream and returns documenttype built without loadingany external dtd schemas.",
	"Method": "DocumentType getDocType(InputStream body){\r\n    final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\r\n    try {\r\n        factory.setFeature(RsPrettyXml.LOAD_EXTERNAL_DTD, false);\r\n        final DocumentBuilder builder = factory.newDocumentBuilder();\r\n        return builder.parse(body).getDoctype();\r\n    } catch (final ParserConfigurationException | SAXException ex) {\r\n        throw new IOException(ex);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.HeartbeatMessageSerializerTest.testSerializeProtocolMessageContent",
	"Comment": "test of serializeprotocolmessagecontent method, of classheartbeatmessageserializer.",
	"Method": "void testSerializeProtocolMessageContent(){\r\n    HeartbeatMessage msg = new HeartbeatMessage();\r\n    msg.setCompleteResultingMessage(expectedPart);\r\n    msg.setHeartbeatMessageType(heartBeatType);\r\n    msg.setPayloadLength(payloadLength);\r\n    msg.setPayload(payload);\r\n    msg.setPadding(padding);\r\n    HeartbeatMessageSerializer serializer = new HeartbeatMessageSerializer(msg, ProtocolVersion.TLS12);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderActivity.hasCameraPermission",
	"Comment": "check to see of we have the necessary permissions for this app.",
	"Method": "boolean hasCameraPermission(){\r\n    return ContextCompat.checkSelfPermission(this, CAMERA_PERMISSION) == PackageManager.PERMISSION_GRANTED;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetHighestClientProtocolVersion",
	"Comment": "test of gethighestclientprotocolversion method, of class defaultchooser.",
	"Method": "void testGetHighestClientProtocolVersion(){\r\n    context.setHighestClientProtocolVersion(null);\r\n    config.setDefaultHighestClientProtocolVersion(ProtocolVersion.TLS10);\r\n    assertEquals(ProtocolVersion.TLS10, config.getDefaultHighestClientProtocolVersion());\r\n    assertEquals(ProtocolVersion.TLS10, chooser.getHighestClientProtocolVersion());\r\n    context.setHighestClientProtocolVersion(ProtocolVersion.TLS11);\r\n    assertEquals(ProtocolVersion.TLS11, chooser.getHighestClientProtocolVersion());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.attacks.ec.ICEAttacker.bruteForceWithAdditionalOracleEquations",
	"Comment": "creates recursively all possible combinations of equations and tries tocompute the server private key with crt.",
	"Method": "void bruteForceWithAdditionalOracleEquations(int[] usedOracleEquations,BigInteger[] congs,BigInteger[] modulis,int pointer){\r\n    if (result == null) {\r\n        int[] eq = Arrays.copyOf(usedOracleEquations, usedOracleEquations.length);\r\n        int maxValue = (pointer == usedOracleEquations.length - 1) ? (congs.length) : (usedOracleEquations[pointer + 1]);\r\n        int minValue = usedOracleEquations[pointer];\r\n        for (int i = minValue; i < maxValue; i++) {\r\n            eq[pointer] = i;\r\n            if (pointer > 0) {\r\n                bruteForceWithAdditionalOracleEquations(eq, congs, modulis, (pointer - 1));\r\n            } else {\r\n                LOGGER.debug(\"Trying the following combination: {}\", Arrays.toString(eq));\r\n                BigInteger sqrtResult = computeCRTFromCombination(usedOracleEquations, congs, modulis);\r\n                BigInteger r = MathHelper.bigIntSqRootFloor(sqrtResult);\r\n                LOGGER.info(\"Guessing the following result: {}\", r);\r\n                if (oracle.isFinalSolutionCorrect(r)) {\r\n                    result = r;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.factory.WorkflowConfigurationFactoryTest.workflowTracesEqual",
	"Comment": "checks if the left and right workflowtrace contain the same amount andcombination of messageactions and their respective messages. the messagesare matched by their class.",
	"Method": "boolean workflowTracesEqual(WorkflowTrace left,WorkflowTrace right){\r\n    if (left.getMessageActions().size() != right.getMessageActions().size() || left.getReceivingActions().size() != right.getReceivingActions().size() || left.getSendingActions().size() != right.getSendingActions().size()) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < left.getMessageActions().size(); i++) {\r\n        final MessageAction leftMessageAction = left.getMessageActions().get(i);\r\n        final MessageAction rightMessageAction = right.getMessageActions().get(i);\r\n        if (left.getMessageActions().size() != right.getMessageActions().size() || !left.getMessageActions().get(i).getClass().equals(right.getMessageActions().get(i).getClass())) {\r\n            return false;\r\n        }\r\n        for (int j = 0; j < leftMessageAction.getMessages().size(); j++) {\r\n            if (!leftMessageAction.getMessages().get(j).getClass().equals(rightMessageAction.getMessages().get(j).getClass())) {\r\n                return false;\r\n            }\r\n        }\r\n        if (leftMessageAction instanceof ReceivingAction) {\r\n            if (!(rightMessageAction instanceof ReceivingAction)) {\r\n                return false;\r\n            }\r\n            final ReceiveAction leftReceiveAction = (ReceiveAction) leftMessageAction;\r\n            final ReceiveAction rightReceiveAction = (ReceiveAction) rightMessageAction;\r\n            if (leftReceiveAction.getExpectedMessages().size() != rightReceiveAction.getExpectedMessages().size()) {\r\n                return false;\r\n            }\r\n            for (int j = 0; j < leftReceiveAction.getMessages().size(); j++) {\r\n                if (!leftReceiveAction.getExpectedMessages().get(j).getClass().equals(rightReceiveAction.getExpectedMessages().get(j).getClass())) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.https.HttpsRequestParserTest.testParseMessageContentSuccess",
	"Comment": "test of parsemessagecontent method, of class httpsrequestparser with anvalid request.",
	"Method": "void testParseMessageContentSuccess(){\r\n    String message = \"GET /index.html HTTP/1.1\\r\\nUser-Agent: Test\\r\\nHost: www.rub.de\\r\\n\\r\\n\";\r\n    HttpsRequestParser parser = new HttpsRequestParser(0, message.getBytes(Charset.forName(\"UTF-8\")), ProtocolVersion.TLS12);\r\n    HttpsRequestMessage parsedMessage = parser.parse();\r\n    assertEquals(parsedMessage.getRequestType().getValue(), \"GET\");\r\n    assertEquals(parsedMessage.getRequestPath().getValue(), \"/index.html\");\r\n    assertEquals(parsedMessage.getRequestProtocol().getValue(), \"HTTP/1.1\");\r\n    assertEquals(parsedMessage.getHeader().get(0).getHeaderName().getValue(), \"User-Agent\");\r\n    assertEquals(parsedMessage.getHeader().get(0).getHeaderValue().getValue(), \"Test\");\r\n    assertEquals(parsedMessage.getHeader().get(1).getHeaderName().getValue(), \"Host\");\r\n    assertEquals(parsedMessage.getHeader().get(1).getHeaderValue().getValue(), \"www.rub.de\");\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.unittest.helper.DefaultNormalizeFilter.getNormalizedAndFilteredCopy",
	"Comment": "return a normalized and filtered copy of the given workflow trace.this method does not modify the input trace.",
	"Method": "WorkflowTrace getNormalizedAndFilteredCopy(WorkflowTrace trace,Config config){\r\n    WorkflowTrace filteredTrace = WorkflowTrace.copy(trace);\r\n    normalizeAndFilter(filteredTrace, config);\r\n    return filteredTrace;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeCompressionActionTest.testGetOldValue",
	"Comment": "test of getoldvalue method, of class changecompressionaction.",
	"Method": "void testGetOldValue(){\r\n    tlsContext.setSelectedCompressionMethod(CompressionMethod.NULL);\r\n    action.execute(state);\r\n    assertEquals(action.getOldValue(), CompressionMethod.NULL);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetClientHandshakeTrafficSecret",
	"Comment": "test of getclienthandshaketrafficsecret method, of class defaultchooser.",
	"Method": "void testGetClientHandshakeTrafficSecret(){\r\n    context.setClientHandshakeTrafficSecret(null);\r\n    byte[] secret = ArrayConverter.hexStringToByteArray(\"122131123987891238098123\");\r\n    byte[] secret2 = ArrayConverter.hexStringToByteArray(\"1221311239878912380981281294\");\r\n    config.setDefaultClientHandshakeTrafficSecret(secret);\r\n    assertArrayEquals(secret, config.getDefaultClientHandshakeTrafficSecret());\r\n    assertArrayEquals(secret, chooser.getClientHandshakeTrafficSecret());\r\n    context.setClientHandshakeTrafficSecret(secret2);\r\n    assertArrayEquals(secret2, chooser.getClientHandshakeTrafficSecret());\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.util.ImageHelper.getSubImage",
	"Comment": "a replacement for the standard bufferedimage.getsubimagemethod.",
	"Method": "BufferedImage getSubImage(BufferedImage image,int x,int y,int width,int height){\r\n    int type = (image.getTransparency() == Transparency.OPAQUE) ? BufferedImage.TYPE_INT_RGB : BufferedImage.TYPE_INT_ARGB;\r\n    BufferedImage tmp = new BufferedImage(width, height, type);\r\n    Graphics2D g2 = tmp.createGraphics();\r\n    g2.drawImage(image.getSubimage(x, y, width, height), 0, 0, null);\r\n    g2.dispose();\r\n    return tmp;\r\n}"
}, {
	"Path": "org.takes.rq.TempInputStreamTest.deletesTempFile",
	"Comment": "tempinputstream can delete the underlying temporary file.",
	"Method": "void deletesTempFile(){\r\n    final File file = File.createTempFile(\"tempfile\", \".tmp\");\r\n    final BufferedWriter out = new BufferedWriter(new FileWriter(file));\r\n    try {\r\n        out.write(\"Temp file deletion test\");\r\n    } finally {\r\n        out.close();\r\n    }\r\n    final InputStream body = new TempInputStream(new FileInputStream(file), file);\r\n    try {\r\n        MatcherAssert.assertThat(\"File is not created!\", file.exists(), Matchers.is(true));\r\n    } finally {\r\n        body.close();\r\n    }\r\n    MatcherAssert.assertThat(\"File exists after stream closure\", file.exists(), Matchers.is(false));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ClientHelloParserTest.generateData",
	"Comment": "constructing a ssl2 clienthellomessage, captured from www.aspray24.com",
	"Method": "Collection<Object[]> generateData(){\r\n    return Arrays.asList(new Object[][] { { ArrayConverter.hexStringToByteArray(\"802b0100020012000000100100800700c0030080060040020080040080bc4c7de14f6fc8bff4428f159fb24f2b\"), ProtocolVersion.SSL2, 43, HandshakeMessageType.CLIENT_HELLO, ProtocolVersion.SSL2.getValue(), 18, 0, 16, ArrayConverter.hexStringToByteArray(\"0100800700c0030080060040020080040080\"), new byte[0], ArrayConverter.hexStringToByteArray(\"bc4c7de14f6fc8bff4428f159fb24f2b\") } });\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.constants.AlgorithmResolverTest.testGetKeyExchangeAlgorithm",
	"Comment": "test of getkeyexchangealgorithm method, of class algorithmresolver.",
	"Method": "void testGetKeyExchangeAlgorithm(){\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.RFC_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256) == KeyExchangeAlgorithm.DHE_RSA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.SSL_FORTEZZA_KEA_WITH_NULL_SHA) == KeyExchangeAlgorithm.FORTEZZA_KEA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_CECPQ1_ECDSA_WITH_AES_256_GCM_SHA384) == KeyExchangeAlgorithm.CECPQ1_ECDSA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA) == KeyExchangeAlgorithm.DHE_DSS);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA) == KeyExchangeAlgorithm.DHE_DSS);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA) == KeyExchangeAlgorithm.DHE_PSK);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA256) == KeyExchangeAlgorithm.DHE_RSA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA) == KeyExchangeAlgorithm.DHE_RSA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_DH_DSS_WITH_AES_256_CBC_SHA) == KeyExchangeAlgorithm.DH_DSS);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA) == KeyExchangeAlgorithm.DH_RSA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA) == KeyExchangeAlgorithm.DH_ANON);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8) == KeyExchangeAlgorithm.ECDHE_ECDSA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384) == KeyExchangeAlgorithm.ECDHE_PSK);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256) == KeyExchangeAlgorithm.ECDHE_RSA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA) == KeyExchangeAlgorithm.ECDH_ECDSA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA) == KeyExchangeAlgorithm.ECDH_RSA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_ECDH_anon_WITH_AES_128_CBC_SHA) == KeyExchangeAlgorithm.ECDH_ANON);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_GOSTR341001_WITH_28147_CNT_IMIT) == KeyExchangeAlgorithm.VKO_GOST01);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5) == KeyExchangeAlgorithm.KRB5);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_KRB5_WITH_DES_CBC_SHA) == KeyExchangeAlgorithm.KRB5);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_NULL_WITH_NULL_NULL) == KeyExchangeAlgorithm.NULL);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_PSK_DHE_WITH_AES_128_CCM_8) == KeyExchangeAlgorithm.DHE_PSK);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_PSK_WITH_AES_128_CCM) == KeyExchangeAlgorithm.PSK);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_RSA_EXPORT1024_WITH_RC4_56_MD5) == KeyExchangeAlgorithm.RSA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_RSA_PSK_WITH_AES_256_CBC_SHA) == KeyExchangeAlgorithm.PSK_RSA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256) == KeyExchangeAlgorithm.RSA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA) == KeyExchangeAlgorithm.SRP_SHA_DSS);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA) == KeyExchangeAlgorithm.SRP_SHA_RSA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA) == KeyExchangeAlgorithm.SRP_SHA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.UNOFFICIAL_TLS_ECMQV_ECNRA_WITH_DES_CBC_SHA) == KeyExchangeAlgorithm.ECMQV_ECNRA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.UNOFFICIAL_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA) == KeyExchangeAlgorithm.ECDH_ECDSA);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.UNOFFICIAL_TLS_ECDH_anon_EXPORT_WITH_RC4_40_SHA) == KeyExchangeAlgorithm.ECDH_ANON);\r\n    assertTrue(AlgorithmResolver.getKeyExchangeAlgorithm(CipherSuite.TLS_AES_128_GCM_SHA256) == null);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskEcDhClientKeyExchangeHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of classpskecdhclientkeyexchangehandler.",
	"Method": "void testAdjustTLSContext(){\r\n    PskEcDhClientKeyExchangeMessage message = new PskEcDhClientKeyExchangeMessage();\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA);\r\n    message.prepareComputations();\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS12);\r\n    context.setRecordLayer(new TlsRecordLayer(context));\r\n    message.getComputations().setPremasterSecret(ArrayConverter.hexStringToByteArray(\"0303d3fad5b20109834717bac4e7762e217add183d0c4852ab054f65ba6e93b1ed83ca5c5fa614cd3b810f4766c66feb\"));\r\n    message.getComputations().setClientServerRandom(ArrayConverter.hexStringToByteArray(\"a449532975d478abeefcfafa7522b9312bdbd0bb294fe460c4d52bab13a425b7594d0e9508874a67db6d9b8e91db4f38600e88f006bbe58f2b41deb6811c74cc\"));\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA);\r\n    handler.adjustTLSContext(message);\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"0303d3fad5b20109834717bac4e7762e217add183d0c4852ab054f65ba6e93b1ed83ca5c5fa614cd3b810f4766c66feb\"), context.getPreMasterSecret());\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"FA1D499E795E936751AD43355C26857728E78ABE1C4BCAFA6EF3C90F6D9B9E49DF1ADE262F127EB2A23BB73E142EE122\"), context.getMasterSecret());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ServerHelloHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class serverhellohandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new ServerHelloMessage()) instanceof ServerHelloPreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetDhGenerator",
	"Comment": "test of getserverdhgenerator method, of class defaultchooser.",
	"Method": "void testGetDhGenerator(){\r\n    context.setServerDhGenerator(null);\r\n    config.setDefaultServerDhGenerator(BigInteger.ONE);\r\n    assertEquals(BigInteger.ONE, config.getDefaultServerDhGenerator());\r\n    assertEquals(BigInteger.ONE, chooser.getServerDhGenerator());\r\n    context.setServerDhGenerator(BigInteger.TEN);\r\n    assertEquals(BigInteger.TEN, chooser.getServerDhGenerator());\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.wrapsIndexOutOfBoundsExceptionFromSet",
	"Comment": "verboselist should wraps outofboundsexception thrown by set method.",
	"Method": "void wrapsIndexOutOfBoundsExceptionFromSet(){\r\n    final int index = 5;\r\n    final Object obj = new Object();\r\n    final Exception cause = new IndexOutOfBoundsException();\r\n    Mockito.doThrow(cause).when(this.origin).set(index, obj);\r\n    this.thrown.expect(IndexOutOfBoundsException.class);\r\n    this.thrown.expectMessage(VerboseListTest.MSG);\r\n    this.thrown.expectCause(Matchers.is(cause));\r\n    this.list.set(index, obj);\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.context.SpatialContext.makeCollection",
	"Comment": "construct a shapecollection, analogous to an ogc geometrycollection.",
	"Method": "ShapeCollection<S> makeCollection(List<S> coll){\r\n    return shapeFactory.multiShape(coll);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ClientHelloParser.parseCipherSuites",
	"Comment": "reads the next bytes as the cyphersuites and writes them in the message",
	"Method": "void parseCipherSuites(ClientHelloMessage msg){\r\n    msg.setCipherSuites(parseByteArrayField(msg.getCipherSuiteLength().getValue()));\r\n    LOGGER.debug(\"CipherSuites: \" + ArrayConverter.bytesToHexString(msg.getCipherSuites().getValue()));\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.indexing.AbstractIndexerBolt.fieldNameForURL",
	"Comment": "returns the field name to use for the url or null if the url must not beindexed",
	"Method": "String fieldNameForURL(){\r\n    return fieldNameForURL;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.WorkflowOutputDelegateTest.testApplyDelegate",
	"Comment": "test of applydelegate method, of class workflowoutputdelegate.",
	"Method": "void testApplyDelegate(){\r\n    Config config = Config.createConfig();\r\n    args = new String[2];\r\n    args[0] = \"-workflow_output\";\r\n    args[1] = \"path\";\r\n    jcommander.parse(args);\r\n    assertFalse(\"path\".equals(config.getWorkflowOutput()));\r\n    delegate.applyDelegate(config);\r\n    assertTrue(\"path\".equals(config.getWorkflowOutput()));\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.io.ParseUtils.parsePoint",
	"Comment": "given a string containing dimension values encoded in it, separated by commas, return a string array of length dimensioncontaining the values.",
	"Method": "String[] parsePoint(String[] out,String externalVal,int dimension){\r\n    if (out == null || out.length != dimension)\r\n        out = new String[dimension];\r\n    int idx = externalVal.indexOf(',');\r\n    int end = idx;\r\n    int start = 0;\r\n    int i = 0;\r\n    if (idx == -1 && dimension == 1 && externalVal.length() > 0) {\r\n        out[0] = externalVal.trim();\r\n        i = 1;\r\n    } else if (idx > 0) {\r\n        for (; i < dimension; i++) {\r\n            while (start < end && externalVal.charAt(start) == ' ') start++;\r\n            while (end > start && externalVal.charAt(end - 1) == ' ') end--;\r\n            if (start == end) {\r\n                break;\r\n            }\r\n            out[i] = externalVal.substring(start, end);\r\n            start = idx + 1;\r\n            end = externalVal.indexOf(',', start);\r\n            idx = end;\r\n            if (end == -1) {\r\n                end = externalVal.length();\r\n            }\r\n        }\r\n    }\r\n    if (i != dimension) {\r\n        throw new InvalidShapeException(\"incompatible dimension (\" + dimension + \") and values (\" + externalVal + \").  Only \" + i + \" values specified\");\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "org.takes.rq.RqMethodTest.failsOnExtraSpaces",
	"Comment": "rqmethod can fail when http method line has any extra spacesbetween the elements.",
	"Method": "void failsOnExtraSpaces(){\r\n    new RqMethod.Base(new RqSimple(Arrays.asList(\"GET /     HTTP/1.1\"), null)).method();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.greenscreen.GreenScreenActivity.projectionMatrixFromCameraIntrinsics",
	"Comment": "use tango camera intrinsics to calculate the projection matrix for the opengl scene.",
	"Method": "float[] projectionMatrixFromCameraIntrinsics(TangoCameraIntrinsics intrinsics){\r\n    float near = 0.1f;\r\n    float far = 100;\r\n    float xScale = near / (float) intrinsics.fx;\r\n    float yScale = near / (float) intrinsics.fy;\r\n    float xOffset = (float) (intrinsics.cx - (intrinsics.width / 2.0)) * xScale;\r\n    float yOffset = (float) -(intrinsics.cy - (intrinsics.height / 2.0)) * yScale;\r\n    float[] m = new float[16];\r\n    Matrix.frustumM(m, 0, xScale * (float) -intrinsics.width / 2.0f - xOffset, xScale * (float) intrinsics.width / 2.0f - xOffset, yScale * (float) -intrinsics.height / 2.0f - yOffset, yScale * (float) intrinsics.height / 2.0f - yOffset, near, far);\r\n    return m;\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.eclipse.wtp.sse.SpotlessPreferences.configurePluginPreferences",
	"Comment": "configures the eclipse properties for a plugin and returns its previous values.",
	"Method": "Properties configurePluginPreferences(Plugin plugin,Properties newValues){\r\n    IEclipsePreferences globalPreferences = DefaultScope.INSTANCE.getNode(plugin.getBundle().getSymbolicName());\r\n    Properties oldValues = new Properties();\r\n    newValues.forEach((key, value) -> {\r\n        String oldValue = globalPreferences.get((String) key, null);\r\n        if (null != oldValue) {\r\n            oldValues.put(key, oldValue);\r\n        }\r\n        globalPreferences.put((String) key, (String) value);\r\n    });\r\n    return oldValues;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.ServerNameIndicationExtensionHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class servernameindicationextensionhandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[] { 0, 2, 3 }, 0) instanceof ServerNameIndicationExtensionParser);\r\n}"
}, {
	"Path": "com.diffplug.spotless.java.ImportSorterImpl.filterMatchingImports",
	"Comment": "returns not matching items and initializes internal state",
	"Method": "void filterMatchingImports(List<String> imports){\r\n    for (String anImport : imports) {\r\n        String orderItem = getBestMatchingImportOrderItem(anImport);\r\n        if (orderItem != null) {\r\n            if (!matchingImports.containsKey(orderItem)) {\r\n                matchingImports.put(orderItem, new ArrayList());\r\n            }\r\n            matchingImports.get(orderItem).add(anImport);\r\n        } else {\r\n            notMatching.add(anImport);\r\n        }\r\n    }\r\n    notMatching.addAll(allImportOrderItems);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.greenscreen.GreenScreenRenderer.setProjectionMatrix",
	"Comment": "set the projection matrix matching the tango rgb camera in order to be able to doaugmented reality.",
	"Method": "void setProjectionMatrix(float[] matrixFloats){\r\n    mProjectionMatrix = matrixFloats;\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.warc.WARCRecordFormat.generateWARCInfo",
	"Comment": "generates a warc info entry which can be stored at the beginning of eachwarc file.",
	"Method": "byte[] generateWARCInfo(Map<String, String> fields){\r\n    StringBuffer buffer = new StringBuffer();\r\n    buffer.append(WARC_VERSION);\r\n    buffer.append(CRLF);\r\n    buffer.append(\"WARC-Type: warcinfo\").append(CRLF);\r\n    String mainID = UUID.randomUUID().toString();\r\n    String date = fields.get(\"WARC-Date\");\r\n    buffer.append(\"WARC-Date: \").append(date).append(CRLF);\r\n    String filename = fields.get(\"WARC-Filename\");\r\n    buffer.append(\"WARC-Filename: \").append(filename).append(CRLF);\r\n    buffer.append(\"WARC-Record-ID\").append(\": \").append(\"<urn:uuid:\").append(mainID).append(\">\").append(CRLF);\r\n    buffer.append(\"Content-Type\").append(\": \").append(\"application/warc-fields\").append(CRLF);\r\n    StringBuilder fieldsBuffer = new StringBuilder();\r\n    Iterator<Entry<String, String>> iter = fields.entrySet().iterator();\r\n    while (iter.hasNext()) {\r\n        Entry<String, String> entry = iter.next();\r\n        String key = entry.getKey();\r\n        if (key.startsWith(\"WARC-\"))\r\n            continue;\r\n        fieldsBuffer.append(key).append(\": \").append(entry.getValue()).append(CRLF);\r\n    }\r\n    buffer.append(\"Content-Length\").append(\": \").append(fieldsBuffer.toString().getBytes(StandardCharsets.UTF_8).length).append(CRLF);\r\n    buffer.append(CRLF);\r\n    buffer.append(fieldsBuffer.toString());\r\n    buffer.append(CRLF);\r\n    buffer.append(CRLF);\r\n    return buffer.toString().getBytes(StandardCharsets.UTF_8);\r\n}"
}, {
	"Path": "org.togglz.core.activation.ParameterBuilder.matching",
	"Comment": "sets a regular expression that must match for parameter values to be considered as valid.",
	"Method": "ParameterBuilder matching(String regex){\r\n    Validate.notNull(regex, \"regex is required\");\r\n    this.pattern = Pattern.compile(regex);\r\n    return this;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.extension.ServerNamePairSerializierTest.testSerializeBytes",
	"Comment": "test of serializebytes method, of class servernamepairserializier.",
	"Method": "void testSerializeBytes(){\r\n    pair = new ServerNamePair();\r\n    pair.setServerNameLength(123);\r\n    pair.setServerNameType((byte) 3);\r\n    pair.setServerName(new byte[] { 1, 2, 3, 4 });\r\n    serializer = new ServerNamePairSerializier(pair);\r\n    byte[] result = serializer.serialize();\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"03007B01020304\"), result);\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.persistence.AbstractStatusUpdaterBolt.ack",
	"Comment": "must be overridden for implementations where the actual writing can bedelayed e.g. put in a buffer",
	"Method": "void ack(Tuple t,String url){\r\n    if (useCache) {\r\n        cache.put(url, \"\");\r\n    }\r\n    _collector.ack(t);\r\n}"
}, {
	"Path": "org.takes.rq.form.RqFormFakeTest.throwsExceptionWhenNotCorrectlyCreated",
	"Comment": "rqformfake throws an illegalargumentexception when invoked withwrong number of parameters.",
	"Method": "void throwsExceptionWhenNotCorrectlyCreated(){\r\n    new RqFormFake(new RqFake(), \"param\");\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.crypto.ec.ECComputer.add",
	"Comment": "provides point addition, checks for infinity in case checkinfinity is set",
	"Method": "Point add(Point p,Point q,Point add,Point p,Point q,boolean checkInfinity){\r\n    if (checkInfinity) {\r\n        if (p == null || p.isInfinity()) {\r\n            return q;\r\n        }\r\n        if (q == null || q.isInfinity()) {\r\n            return p;\r\n        }\r\n        if (p.getX().equals(q.getX())) {\r\n            if (p.getY().equals(q.getY())) {\r\n                return dbl(p, true);\r\n            } else {\r\n                return new Point(true);\r\n            }\r\n        }\r\n    }\r\n    return add(p, q);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetClientSessionId",
	"Comment": "test of getclientsessionid method, of class defaultchooser.",
	"Method": "void testGetClientSessionId(){\r\n    byte[] sessionID = new byte[0];\r\n    config.setDefaultClientSessionId(sessionID);\r\n    assertArrayEquals(sessionID, config.getDefaultClientSessionId());\r\n    assertArrayEquals(sessionID, chooser.getClientSessionId());\r\n    context.setClientSessionId(sessionID);\r\n    assertArrayEquals(sessionID, chooser.getClientSessionId());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskEcDhClientKeyExchangeHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class pskecdhclientkeyexchangehandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new PskEcDhClientKeyExchangeMessage()) instanceof PskEcDhClientKeyExchangeSerializer);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.motiontracking.MotionTrackingActivity.setupRenderer",
	"Comment": "connects the rajawali surface view and its renderer. this is ideally called only once inoncreate.",
	"Method": "void setupRenderer(){\r\n    mSurfaceView.setEGLContextClientVersion(2);\r\n    mRenderer.getCurrentScene().registerFrameCallback(new ASceneFrameCallback() {\r\n        @Override\r\n        public void onPreFrame(long sceneTime, double deltaTime) {\r\n            if (!mIsTangoPoseReady.get()) {\r\n                return;\r\n            }\r\n            synchronized (MotionTrackingActivity.this) {\r\n                try {\r\n                    TangoPoseData pose = TangoSupport.getPoseAtTime(0.0, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_DEVICE, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                    if (pose.statusCode == TangoPoseData.POSE_VALID) {\r\n                        mRenderer.updateRenderCameraPose(pose);\r\n                    }\r\n                } catch (TangoErrorException e) {\r\n                    Log.e(TAG, \"TangoSupport.getPoseAtTime error\", e);\r\n                }\r\n            }\r\n        }\r\n        @Override\r\n        public void onPreDraw(long sceneTime, double deltaTime) {\r\n        }\r\n        @Override\r\n        public void onPostFrame(long sceneTime, double deltaTime) {\r\n        }\r\n        @Override\r\n        public boolean callPreFrame() {\r\n            return true;\r\n        }\r\n    });\r\n    mSurfaceView.setSurfaceRenderer(mRenderer);\r\n    mSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.motiontracking.MotionTrackingActivity.setupRenderer",
	"Comment": "connects the rajawali surface view and its renderer. this is ideally called only once inoncreate.",
	"Method": "void setupRenderer(){\r\n    if (!mIsTangoPoseReady.get()) {\r\n        return;\r\n    }\r\n    synchronized (MotionTrackingActivity.this) {\r\n        try {\r\n            TangoPoseData pose = TangoSupport.getPoseAtTime(0.0, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_DEVICE, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n            if (pose.statusCode == TangoPoseData.POSE_VALID) {\r\n                mRenderer.updateRenderCameraPose(pose);\r\n            }\r\n        } catch (TangoErrorException e) {\r\n            Log.e(TAG, \"TangoSupport.getPoseAtTime error\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.motiontracking.MotionTrackingActivity.setupRenderer",
	"Comment": "connects the rajawali surface view and its renderer. this is ideally called only once inoncreate.",
	"Method": "void setupRenderer(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.motiontracking.MotionTrackingActivity.setupRenderer",
	"Comment": "connects the rajawali surface view and its renderer. this is ideally called only once inoncreate.",
	"Method": "void setupRenderer(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.motiontracking.MotionTrackingActivity.setupRenderer",
	"Comment": "connects the rajawali surface view and its renderer. this is ideally called only once inoncreate.",
	"Method": "void setupRenderer(){\r\n    return true;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ClientHelloParser.parseCipherSuiteLength",
	"Comment": "reads the next bytes as the cyphersuitelength and writes them in themessage",
	"Method": "void parseCipherSuiteLength(ClientHelloMessage msg){\r\n    msg.setCipherSuiteLength(parseIntField(HandshakeByteLength.CIPHER_SUITES_LENGTH));\r\n    LOGGER.debug(\"CipherSuiteLength: \" + msg.getCipherSuiteLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.UnknownExtensionHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class unknownextensionhandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new UnknownExtensionMessage()) instanceof UnknownExtensionSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.socket.TlsAttackerSocket.receiveString",
	"Comment": "receives bytes and decrypts applicationmessage contents in converts themto strings",
	"Method": "String receiveString(){\r\n    return new String(receiveBytes(), Charset.defaultCharset());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.ECDHEServerKeyExchangeMessageTest.testToString",
	"Comment": "test of tostring method, of class ecdheserverkeyexchangemessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"ECDHEServerKeyExchangeMessage:\");\r\n    sb.append(\"\\n  Curve Type: \").append(\"null\");\r\n    sb.append(\"\\n  Named Curve: \").append(\"null\");\r\n    sb.append(\"\\n  Public Key: \").append(\"null\");\r\n    sb.append(\"\\n  Signature and Hash Algorithm: \").append(\"null\");\r\n    sb.append(\"\\n  Signature: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.KeyShareEntryParser.parseKeyShareLength",
	"Comment": "reads the next bytes as the keysharelength of the extension and writesthem in the message",
	"Method": "void parseKeyShareLength(KeyShareEntry pair){\r\n    pair.setPublicKeyLength(parseIntField(ExtensionByteLength.KEY_SHARE_LENGTH));\r\n    LOGGER.debug(\"KeyShareLength: \" + pair.getPublicKeyLength().getValue());\r\n}"
}, {
	"Path": "org.takes.facets.auth.PsAllTest.indexMustBeSmallEnough",
	"Comment": "fails if index is greater or equal to the number of passes to enter.",
	"Method": "void indexMustBeSmallEnough(){\r\n    MatcherAssert.assertThat(new PsAll(Arrays.asList(new PsFake(true), new PsFake(false)), 2).enter(new RqFake()).has(), Matchers.is(false));\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPITest.testTessBaseAPIGetComponentImages",
	"Comment": "test of tessbaseapigetcomponentimages method, of class tessapi.",
	"Method": "void testTessBaseAPIGetComponentImages(){\r\n    logger.info(\"TessBaseAPIGetComponentImages\");\r\n    File image = new File(this.testResourcesDataPath, \"eurotext.png\");\r\n    int expResult = 12;\r\n    Leptonica leptInstance = Leptonica.INSTANCE;\r\n    Pix pix = leptInstance.pixRead(image.getPath());\r\n    api.TessBaseAPIInit3(handle, datapath, language);\r\n    api.TessBaseAPISetImage2(handle, pix);\r\n    PointerByReference pixa = null;\r\n    PointerByReference blockids = null;\r\n    Boxa boxes = api.TessBaseAPIGetComponentImages(handle, TessPageIteratorLevel.RIL_TEXTLINE, TRUE, pixa, blockids);\r\n    int boxCount = leptInstance.boxaGetCount(boxes);\r\n    for (int i = 0; i < boxCount; i++) {\r\n        Box box = leptInstance.boxaGetBox(boxes, i, L_CLONE);\r\n        if (box == null) {\r\n            continue;\r\n        }\r\n        api.TessBaseAPISetRectangle(handle, box.x, box.y, box.w, box.h);\r\n        Pointer utf8Text = api.TessBaseAPIGetUTF8Text(handle);\r\n        String ocrResult = utf8Text.getString(0);\r\n        api.TessDeleteText(utf8Text);\r\n        int conf = api.TessBaseAPIMeanTextConf(handle);\r\n        System.out.print(String.format(\"Box[%d]: x=%d, y=%d, w=%d, h=%d, confidence: %d, text: %s\", i, box.x, box.y, box.w, box.h, conf, ocrResult));\r\n        LeptUtils.dispose(box);\r\n    }\r\n    LeptUtils.dispose(pix);\r\n    LeptUtils.dispose(boxes);\r\n    assertEquals(expResult, boxCount);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.EllipticCurvesExtensionHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class ellipticcurvesextensionhandler.",
	"Method": "void testAdjustTLSContext(){\r\n    EllipticCurvesExtensionMessage msg = new EllipticCurvesExtensionMessage();\r\n    msg.setSupportedGroups(new byte[] { 0, 1, 0, 2 });\r\n    handler.adjustTLSContext(msg);\r\n    assertTrue(context.getClientNamedGroupsList().size() == 2);\r\n    assertTrue(context.getClientNamedGroupsList().get(0) == NamedGroup.SECT163K1);\r\n    assertTrue(context.getClientNamedGroupsList().get(1) == NamedGroup.SECT163R1);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.executor.ReceiveMessageHelper.receiveMessages",
	"Comment": "receives messages, and tries to receive the messages specified inmessages",
	"Method": "MessageActionResult receiveMessages(TlsContext context,MessageActionResult receiveMessages,List<ProtocolMessage> expectedMessages,TlsContext context){\r\n    context.setTalkingConnectionEndType(context.getChooser().getMyConnectionPeer());\r\n    List<AbstractRecord> realRecords = new LinkedList();\r\n    List<ProtocolMessage> messages = new LinkedList();\r\n    try {\r\n        byte[] receivedBytes;\r\n        boolean shouldContinue = true;\r\n        do {\r\n            receivedBytes = receiveByteArray(context);\r\n            MessageActionResult tempMessageActionResult = handleReceivedBytes(receivedBytes, context);\r\n            messages.addAll(tempMessageActionResult.getMessageList());\r\n            realRecords.addAll(tempMessageActionResult.getRecordList());\r\n            if (context.getConfig().isQuickReceive() && !expectedMessages.isEmpty()) {\r\n                shouldContinue = shouldContinue(expectedMessages, messages, context);\r\n            }\r\n        } while (receivedBytes.length != 0 && shouldContinue);\r\n    } catch (IOException ex) {\r\n        LOGGER.warn(\"Received \" + ex.getLocalizedMessage() + \" while recieving for Messages.\");\r\n        LOGGER.debug(ex);\r\n        context.setReceivedTransportHandlerException(true);\r\n    }\r\n    return new MessageActionResult(realRecords, messages);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.helloareadescription.AdfUuidListViewActivity.updateTangoSpaceAdfList",
	"Comment": "updates the list of adfdata corresponding to the tango space.",
	"Method": "void updateTangoSpaceAdfList(){\r\n    ArrayList<String> fullUuidList;\r\n    TangoAreaDescriptionMetaData metadata = new TangoAreaDescriptionMetaData();\r\n    try {\r\n        fullUuidList = mTango.listAreaDescriptions();\r\n        mTangoSpaceAdfDataList.clear();\r\n        for (String uuid : fullUuidList) {\r\n            String name;\r\n            try {\r\n                metadata = mTango.loadAreaDescriptionMetaData(uuid);\r\n            } catch (TangoErrorException e) {\r\n                Toast.makeText(this, R.string.tango_error, Toast.LENGTH_SHORT).show();\r\n            }\r\n            name = new String(metadata.get(TangoAreaDescriptionMetaData.KEY_NAME));\r\n            mTangoSpaceAdfDataList.add(new AdfData(uuid, name));\r\n        }\r\n    } catch (TangoErrorException e) {\r\n        Toast.makeText(this, R.string.tango_error, Toast.LENGTH_SHORT).show();\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.transport.nonblocking.ServerTCPNonBlockingTransportHandlerTest.testInitialize",
	"Comment": "test of initialize method, of class servertcpnonblockingtransporthandler.",
	"Method": "void testInitialize(){\r\n    try {\r\n        handler.initialize();\r\n        assertFalse(handler.isInitialized());\r\n        handler.recheck();\r\n        assertFalse(handler.isInitialized());\r\n        new Socket().connect(new InetSocketAddress(\"localhost\", handler.getPort()));\r\n        handler.recheck(1000);\r\n        assertTrue(handler.isInitialized());\r\n    } catch (IOException ex) {\r\n        fail(\"Encountered Exception\");\r\n    } finally {\r\n        try {\r\n            handler.closeConnection();\r\n        } catch (IOException ex) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.data.neo4j.transaction.SharedSessionCreator.createSharedSession",
	"Comment": "create a transactional session proxy for the given sessionfactory.",
	"Method": "Session createSharedSession(SessionFactory sessionFactory){\r\n    return (Session) Proxy.newProxyInstance(SharedSessionCreator.class.getClassLoader(), new Class<?>[] { Session.class, MetaDataProvider.class }, new SharedSessionInvocationHandler(sessionFactory));\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPITest.testTessBaseAPIGetInitLanguagesAsString",
	"Comment": "test of tessbaseapigetinitlanguagesasstring method, of class tessapi.",
	"Method": "void testTessBaseAPIGetInitLanguagesAsString(){\r\n    logger.info(\"TessBaseAPIGetInitLanguagesAsString\");\r\n    String expResult = \"\";\r\n    String result = api.TessBaseAPIGetInitLanguagesAsString(handle);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.SSL2ServerHelloMessageTest.testToString",
	"Comment": "test of tostring method, of class ssl2serverhellomessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"SSL2ServerHelloMessage:\");\r\n    sb.append(\"\\n  Protocol Version: \").append(\"null\");\r\n    sb.append(\"\\n  Type: \").append(\"null\");\r\n    sb.append(\"\\n  Supported CipherSuites: \").append(\"null\");\r\n    sb.append(\"\\n  SessionIdHit: \").append(\"null\");\r\n    sb.append(\"\\n  Certificate: \").append(\"null\");\r\n    sb.append(\"\\n  SessionID: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPI1Test.testTessBaseAPIGetComponentImages",
	"Comment": "test of tessbaseapigetcomponentimages method, of class tessapi1.",
	"Method": "void testTessBaseAPIGetComponentImages(){\r\n    logger.info(\"TessBaseAPIGetComponentImages\");\r\n    File image = new File(this.testResourcesDataPath, \"eurotext.png\");\r\n    int expResult = 12;\r\n    Pix pix = Leptonica1.pixRead(image.getPath());\r\n    TessAPI1.TessBaseAPIInit3(handle, datapath, language);\r\n    TessAPI1.TessBaseAPISetImage2(handle, pix);\r\n    PointerByReference pixa = null;\r\n    PointerByReference blockids = null;\r\n    Boxa boxes = TessAPI1.TessBaseAPIGetComponentImages(handle, TessPageIteratorLevel.RIL_TEXTLINE, TRUE, pixa, blockids);\r\n    int boxCount = Leptonica1.boxaGetCount(boxes);\r\n    for (int i = 0; i < boxCount; i++) {\r\n        Box box = Leptonica1.boxaGetBox(boxes, i, L_CLONE);\r\n        if (box == null) {\r\n            continue;\r\n        }\r\n        TessAPI1.TessBaseAPISetRectangle(handle, box.x, box.y, box.w, box.h);\r\n        Pointer utf8Text = TessAPI1.TessBaseAPIGetUTF8Text(handle);\r\n        String ocrResult = utf8Text.getString(0);\r\n        TessAPI1.TessDeleteText(utf8Text);\r\n        int conf = TessAPI1.TessBaseAPIMeanTextConf(handle);\r\n        System.out.print(String.format(\"Box[%d]: x=%d, y=%d, w=%d, h=%d, confidence: %d, text: %s\", i, box.x, box.y, box.w, box.h, conf, ocrResult));\r\n        LeptUtils.dispose(box);\r\n    }\r\n    LeptUtils.dispose(pix);\r\n    LeptUtils.dispose(boxes);\r\n    assertEquals(expResult, boxCount);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.cert.CertificatePairParser.parseExtensionsLength",
	"Comment": "reads the next bytes as the extensionslength of the certificatepair andwrites them in the message",
	"Method": "void parseExtensionsLength(CertificatePair pair){\r\n    pair.setExtensionsLength(parseIntField(HandshakeByteLength.EXTENSION_LENGTH));\r\n    LOGGER.debug(\"ExtensionsLength: \" + pair.getCertificateLength().getValue());\r\n}"
}, {
	"Path": "org.springframework.data.neo4j.examples.restaurants.RestaurantTests.shouldFindRestaurantsNear_nameParameterFirst",
	"Comment": "this test, as the below one does, asserts that the parameter index for each query part is set correctly. most query\tparts are associated with one parameter, while certain kinds, such as near, require more.",
	"Method": "void shouldFindRestaurantsNear_nameParameterFirst(){\r\n    Restaurant restaurant = new Restaurant(\"San Francisco International Airport (SFO)\", new Point(37.61649, -122.38681), 94128);\r\n    restaurantRepository.save(restaurant);\r\n    List<Restaurant> results = restaurantRepository.findByNameAndLocationNear(\"San Francisco International Airport (SFO)\", new Distance(150, Metrics.KILOMETERS), new Point(37.6, -122.3));\r\n    assertNotNull(results);\r\n    assertEquals(1, results.size());\r\n    Restaurant found = results.get(0);\r\n    assertNotNull(found.getLocation());\r\n    assertEquals(37.61649, found.getLocation().getX(), 0);\r\n    assertEquals(-122.38681, found.getLocation().getY(), 0);\r\n}"
}, {
	"Path": "org.springframework.statemachine.listener.AbstractCompositeListener.setListeners",
	"Comment": "sets the list of listeners. this clears\tall existing listeners.",
	"Method": "void setListeners(List<? extends T> listeners){\r\n    this.listeners.setItems(listeners);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetServerSupportedSignatureAndHashAlgorithms",
	"Comment": "test of getserversupportedsignatureandhashalgorithms method, of classdefaultchooser.",
	"Method": "void testGetServerSupportedSignatureAndHashAlgorithms(){\r\n    LinkedList<SignatureAndHashAlgorithm> serverSupportedSignatureAndHashAlgorithms = new LinkedList();\r\n    LinkedList<SignatureAndHashAlgorithm> serverSupportedSignatureAndHashAlgorithms2 = new LinkedList();\r\n    serverSupportedSignatureAndHashAlgorithms.add(SignatureAndHashAlgorithm.DSA_MD5);\r\n    serverSupportedSignatureAndHashAlgorithms.add(SignatureAndHashAlgorithm.DSA_SHA1);\r\n    serverSupportedSignatureAndHashAlgorithms.add(SignatureAndHashAlgorithm.DSA_SHA256);\r\n    serverSupportedSignatureAndHashAlgorithms.add(SignatureAndHashAlgorithm.DSA_SHA384);\r\n    config.setDefaultServerSupportedSignatureAndHashAlgorithms(serverSupportedSignatureAndHashAlgorithms);\r\n    assertEquals(serverSupportedSignatureAndHashAlgorithms, config.getDefaultServerSupportedSignatureAndHashAlgorithms());\r\n    assertEquals(serverSupportedSignatureAndHashAlgorithms, chooser.getServerSupportedSignatureAndHashAlgorithms());\r\n    context.setServerSupportedSignatureAndHashAlgorithms(serverSupportedSignatureAndHashAlgorithms2);\r\n    assertEquals(serverSupportedSignatureAndHashAlgorithms2, chooser.getServerSupportedSignatureAndHashAlgorithms());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.record.cipher.RecordNullCipherTest.testGetPaddingLength",
	"Comment": "test of getpaddinglength method, of class recordnullcipher.",
	"Method": "void testGetPaddingLength(){\r\n    assertEquals(record.calculatePaddingLength(0), 0);\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.util.ImageIOHelper.createTiffFiles",
	"Comment": "creates a list of tiff image files from a list of iioimageobjects.",
	"Method": "List<File> createTiffFiles(File imageFile,int index,List<File> createTiffFiles,File imageFile,int index,boolean preserve,List<File> createTiffFiles,List<IIOImage> imageList,int index,List<File> createTiffFiles,List<IIOImage> imageList,int index,int dpiX,int dpiY){\r\n    List<File> tiffFiles = new ArrayList<File>();\r\n    TIFFImageWriteParam tiffWriteParam = new TIFFImageWriteParam(Locale.US);\r\n    tiffWriteParam.setCompressionMode(ImageWriteParam.MODE_DISABLED);\r\n    Iterator<ImageWriter> writers = ImageIO.getImageWritersByFormatName(TIFF_FORMAT);\r\n    if (!writers.hasNext()) {\r\n        throw new RuntimeException(JAI_IMAGE_WRITER_MESSAGE);\r\n    }\r\n    ImageWriter writer = writers.next();\r\n    IIOMetadata streamMetadata = writer.getDefaultStreamMetadata(tiffWriteParam);\r\n    for (IIOImage oimage : (index == -1 ? imageList : imageList.subList(index, index + 1))) {\r\n        if (dpiX != 0 && dpiY != 0) {\r\n            ImageTypeSpecifier imageType = ImageTypeSpecifier.createFromRenderedImage(oimage.getRenderedImage());\r\n            ImageWriteParam param = writer.getDefaultWriteParam();\r\n            IIOMetadata imageMetadata = writer.getDefaultImageMetadata(imageType, param);\r\n            imageMetadata = setDPIViaAPI(imageMetadata, dpiX, dpiY);\r\n            oimage.setMetadata(imageMetadata);\r\n        }\r\n        File tiffFile = File.createTempFile(OUTPUT_FILE_NAME, TIFF_EXT);\r\n        try (ImageOutputStream ios = ImageIO.createImageOutputStream(tiffFile)) {\r\n            writer.setOutput(ios);\r\n            writer.write(streamMetadata, oimage, tiffWriteParam);\r\n            tiffFiles.add(tiffFile);\r\n        }\r\n    }\r\n    writer.dispose();\r\n    return tiffFiles;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.augmentedreality.AugmentedRealityActivity.projectionMatrixFromCameraIntrinsics",
	"Comment": "use tango camera intrinsics to calculate the projection matrix for the rajawali scene.",
	"Method": "float[] projectionMatrixFromCameraIntrinsics(TangoCameraIntrinsics intrinsics){\r\n    float cx = (float) intrinsics.cx;\r\n    float cy = (float) intrinsics.cy;\r\n    float width = (float) intrinsics.width;\r\n    float height = (float) intrinsics.height;\r\n    float fx = (float) intrinsics.fx;\r\n    float fy = (float) intrinsics.fy;\r\n    float near = 0.1f;\r\n    float far = 100;\r\n    float xScale = near / fx;\r\n    float yScale = near / fy;\r\n    float xOffset = (cx - (width / 2.0f)) * xScale;\r\n    float yOffset = -(cy - (height / 2.0f)) * yScale;\r\n    float[] m = new float[16];\r\n    Matrix.frustumM(m, 0, xScale * (float) -width / 2.0f - xOffset, xScale * (float) width / 2.0f - xOffset, yScale * (float) -height / 2.0f - yOffset, yScale * (float) height / 2.0f - yOffset, near, far);\r\n    return m;\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.parse.ParseFilters.fromConf",
	"Comment": "loads and configure the parsefilters based on the storm config if thereis one otherwise returns an emptyparsefilter.",
	"Method": "ParseFilters fromConf(Map stormConf){\r\n    String parseconfigfile = ConfUtils.getString(stormConf, \"parsefilters.config.file\");\r\n    if (StringUtils.isNotBlank(parseconfigfile)) {\r\n        try {\r\n            return new ParseFilters(stormConf, parseconfigfile);\r\n        } catch (IOException e) {\r\n            String message = \"Exception caught while loading the ParseFilters from \" + parseconfigfile;\r\n            LOG.error(message);\r\n            throw new RuntimeException(message, e);\r\n        }\r\n    }\r\n    return ParseFilters.emptyParseFilter;\r\n}"
}, {
	"Path": "com.diffplug.spotless.Provisioner.provisionWithTransitives",
	"Comment": "given a set of maven coordinates, returns a set of jars which include all\tof the specified coordinates and optionally their transitive dependencies.",
	"Method": "Set<File> provisionWithTransitives(boolean withTransitives,String mavenCoordinates,Set<File> provisionWithTransitives,boolean withTransitives,Collection<String> mavenCoordinates){\r\n    return provisionWithTransitives(withTransitives, Arrays.asList(mavenCoordinates));\r\n}"
}, {
	"Path": "org.takes.http.BkParallelTest.requestsAreParallel",
	"Comment": "bkparallel runs requests in parallel, hence evenwhen handling of a request blocks, other requestsshould be handled.",
	"Method": "void requestsAreParallel(){\r\n    final ServerSocket socket = new ServerSocket(0);\r\n    final String uri = String.format(\"http://localhost:%d\", socket.getLocalPort());\r\n    final int count = 3;\r\n    final CountDownLatch started = new CountDownLatch(count);\r\n    final CountDownLatch completed = new CountDownLatch(count);\r\n    final Take take = new Take() {\r\n        @Override\r\n        public Response act(final Request req) {\r\n            started.countDown();\r\n            try {\r\n                started.await();\r\n            } catch (final InterruptedException ex) {\r\n                throw new IllegalStateException(ex);\r\n            }\r\n            completed.countDown();\r\n            return new TkEmpty().act(req);\r\n        }\r\n    };\r\n    final Exit exit = new Exit() {\r\n        @Override\r\n        public boolean ready() {\r\n            return completed.getCount() == 0;\r\n        }\r\n    };\r\n    new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                new FtBasic(new BkParallel(new BkBasic(take), count), socket).start(exit);\r\n            } catch (final IOException ex) {\r\n                throw new IllegalStateException(ex);\r\n            }\r\n        }\r\n    }).start();\r\n    for (int idx = 0; idx < count; ++idx) {\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    new JdkRequest(uri).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\r\n                } catch (final IOException ex) {\r\n                    throw new IllegalStateException(ex);\r\n                }\r\n            }\r\n        }).start();\r\n    }\r\n    completed.await(1L, TimeUnit.MINUTES);\r\n    MatcherAssert.assertThat(started.getCount(), Matchers.equalTo(0L));\r\n    MatcherAssert.assertThat(completed.getCount(), Matchers.equalTo(0L));\r\n}"
}, {
	"Path": "org.takes.http.BkParallelTest.requestsAreParallel",
	"Comment": "bkparallel runs requests in parallel, hence evenwhen handling of a request blocks, other requestsshould be handled.",
	"Method": "void requestsAreParallel(){\r\n    started.countDown();\r\n    try {\r\n        started.await();\r\n    } catch (final InterruptedException ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n    completed.countDown();\r\n    return new TkEmpty().act(req);\r\n}"
}, {
	"Path": "org.takes.http.BkParallelTest.requestsAreParallel",
	"Comment": "bkparallel runs requests in parallel, hence evenwhen handling of a request blocks, other requestsshould be handled.",
	"Method": "void requestsAreParallel(){\r\n    return completed.getCount() == 0;\r\n}"
}, {
	"Path": "org.takes.http.BkParallelTest.requestsAreParallel",
	"Comment": "bkparallel runs requests in parallel, hence evenwhen handling of a request blocks, other requestsshould be handled.",
	"Method": "void requestsAreParallel(){\r\n    try {\r\n        new FtBasic(new BkParallel(new BkBasic(take), count), socket).start(exit);\r\n    } catch (final IOException ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.takes.http.BkParallelTest.requestsAreParallel",
	"Comment": "bkparallel runs requests in parallel, hence evenwhen handling of a request blocks, other requestsshould be handled.",
	"Method": "void requestsAreParallel(){\r\n    try {\r\n        new JdkRequest(uri).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK);\r\n    } catch (final IOException ex) {\r\n        throw new IllegalStateException(ex);\r\n    }\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.util.CharsetIdentification.getCharsetFromText",
	"Comment": "use a third party library as last resort to guess the charset from thebytes.",
	"Method": "String getCharsetFromText(byte[] content,String declaredCharset,int maxLengthCharsetDetection){\r\n    String charset = null;\r\n    CharsetDetector charsetDetector = new CharsetDetector();\r\n    charsetDetector.enableInputFilter(true);\r\n    if (declaredCharset != null)\r\n        charsetDetector.setDeclaredEncoding(declaredCharset);\r\n    byte[] subContent = content;\r\n    if (maxLengthCharsetDetection != -1 && content.length > maxLengthCharsetDetection) {\r\n        subContent = Arrays.copyOfRange(content, 0, maxLengthCharsetDetection);\r\n    }\r\n    charsetDetector.setText(subContent);\r\n    try {\r\n        CharsetMatch charsetMatch = charsetDetector.detect();\r\n        charset = validateCharset(charsetMatch.getName());\r\n    } catch (Exception e) {\r\n        charset = null;\r\n    }\r\n    return charset;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.TangoMesher.resetSceneReconstruction",
	"Comment": "synchronize access to mtango3dreconstruction. this runs in ui thread.",
	"Method": "void resetSceneReconstruction(){\r\n    mTango3dReconstruction.clear();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorPlanReconstructionActivity.setupTangoConfig",
	"Comment": "sets up the tango configuration object. make sure mtango object is initialized beforemaking this call.",
	"Method": "TangoConfig setupTangoConfig(Tango tango){\r\n    TangoConfig config = tango.getConfig(TangoConfig.CONFIG_TYPE_DEFAULT);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_DEPTH, true);\r\n    config.putInt(TangoConfig.KEY_INT_DEPTH_MODE, TangoConfig.TANGO_DEPTH_MODE_POINT_CLOUD);\r\n    return config;\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.wtp.EclipseWtpFormatterStepTest.multipleConfigurations",
	"Comment": "check that configuration change is supported by all wtp formatters.\tsome of the formatters only support static workspace configuration.\thence separated class loaders are required for different configurations.",
	"Method": "void multipleConfigurations(){\r\n    FormatterStep tabFormatter = createStepForDefaultVersion(config -> {\r\n        config.setProperty(\"indentationChar\", \"tab\");\r\n        config.setProperty(\"indentationSize\", \"1\");\r\n    });\r\n    FormatterStep spaceFormatter = createStepForDefaultVersion(config -> {\r\n        config.setProperty(\"indentationChar\", \"space\");\r\n        config.setProperty(\"indentationSize\", \"5\");\r\n    });\r\n    assertThat(formatWith(tabFormatter)).as(\"Tab formatting output unexpected\").isEqualTo(wtp.expectation);\r\n    assertThat(formatWith(spaceFormatter)).as(\"Space formatting output unexpected\").isEqualTo(wtp.expectation.replace(\"\\t\", \"     \"));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.attacks.padding.LongRecordGenerator.getAllBitFlipModifications",
	"Comment": "returns a list of modifications which flip each bit up to byte length xindiviually",
	"Method": "List<ByteArrayXorModification> getAllBitFlipModifications(int targetLength){\r\n    byte[] bitflipArray = getBitflipArray();\r\n    List<ByteArrayXorModification> modificationList = new LinkedList();\r\n    for (int i = 0; i < targetLength; i++) {\r\n        for (int j = 0; j < 8; j++) {\r\n            modificationList.add(new ByteArrayXorModification(new byte[] { bitflipArray[j] }, i));\r\n        }\r\n    }\r\n    return modificationList;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.HeartbeatExtensionParserTest.testParseExtensionMessageContent",
	"Comment": "test of parseextensionmessagecontent method, of classheartbeatextensionparser.",
	"Method": "void testParseExtensionMessageContent(){\r\n    HeartbeatExtensionParser parser = new HeartbeatExtensionParser(start, extension);\r\n    HeartbeatExtensionMessage msg = parser.parse();\r\n    assertArrayEquals(msg.getExtensionBytes().getValue(), completeExtension);\r\n    assertArrayEquals(type.getValue(), msg.getExtensionType().getValue());\r\n    assertTrue(extensionLength == msg.getExtensionLength().getValue());\r\n    assertArrayEquals(heartbeatMode, msg.getHeartbeatMode().getValue());\r\n}"
}, {
	"Path": "org.takes.tk.TkRetryTest.retriesOnExceptionTillSuccess",
	"Comment": "tkretry can retry when initial take fails with ioexception,till get successful result.",
	"Method": "void retriesOnExceptionTillSuccess(){\r\n    final int count = Tv.THREE;\r\n    final int delay = Tv.THOUSAND;\r\n    final String data = \"data\";\r\n    final Take take = Mockito.mock(Take.class);\r\n    Mockito.when(take.act(Mockito.any(Request.class))).thenThrow(new IOException()).thenReturn(new RsText(data));\r\n    final long start = System.nanoTime();\r\n    final RsPrint response = new RsPrint(new TkRetry(count, delay, take).act(new RqFake(RqMethod.GET)));\r\n    final long spent = System.nanoTime() - start;\r\n    MatcherAssert.assertThat(new Long(delay - Tv.HUNDRED) * Tv.MILLION, Matchers.lessThanOrEqualTo(spent));\r\n    MatcherAssert.assertThat(response.print(), Matchers.containsString(data));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ClientHelloHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class clienthellohandler.",
	"Method": "void testAdjustTLSContext(){\r\n    ClientHelloMessage message = new ClientHelloMessage();\r\n    message.setUnixTime(new byte[] { 0, 1, 2 });\r\n    message.setRandom(new byte[] { 0, 1, 2, 3, 4, 5 });\r\n    message.setCompressions(new byte[] { 0, 1 });\r\n    message.setCipherSuites(new byte[] { 0x00, 0x01, 0x00, 0x02 });\r\n    message.setSessionId(new byte[] { 6, 6, 6 });\r\n    message.setProtocolVersion(ProtocolVersion.TLS12.getValue());\r\n    handler.adjustTLSContext(message);\r\n    assertArrayEquals(context.getClientRandom(), new byte[] { 0, 1, 2, 3, 4, 5 });\r\n    assertTrue(context.getClientSupportedCompressions().contains(CompressionMethod.DEFLATE));\r\n    assertTrue(context.getClientSupportedCompressions().contains(CompressionMethod.NULL));\r\n    assertTrue(context.getClientSupportedCompressions().size() == 2);\r\n    assertArrayEquals(context.getClientSessionId(), new byte[] { 6, 6, 6 });\r\n    assertTrue(context.getClientSupportedCiphersuites().size() == 2);\r\n    assertTrue(context.getClientSupportedCiphersuites().contains(CipherSuite.TLS_RSA_WITH_NULL_SHA));\r\n    assertTrue(context.getClientSupportedCiphersuites().contains(CipherSuite.TLS_RSA_WITH_NULL_MD5));\r\n    assertNull(context.getDtlsCookie());\r\n    assertArrayEquals(context.getHighestClientProtocolVersion().getValue(), ProtocolVersion.TLS12.getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangePreMasterSecretActionTest.testExecute",
	"Comment": "test of execute method, of class changeclientrandomaction.",
	"Method": "void testExecute(){\r\n    tlsContext.setPreMasterSecret(new byte[] { 3 });\r\n    action.execute(state);\r\n    assertArrayEquals(action.getOldValue(), new byte[] { 3 });\r\n    assertArrayEquals(action.getNewValue(), new byte[] { 0, 1 });\r\n    assertArrayEquals(tlsContext.getPreMasterSecret(), new byte[] { 0, 1 });\r\n    assertTrue(action.isExecuted());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.transport.stream.StreamTransportHandlerTest.testCloseConnection",
	"Comment": "test of closeconnection method, of class streamtransporthandler.",
	"Method": "void testCloseConnection(){\r\n    handler.closeConnection();\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.util.CookieConverter.getCookies",
	"Comment": "get a list of cookies based on the cookies string taken from responseheader and the target url.",
	"Method": "List<Cookie> getCookies(String[] cookiesStrings,URL targetURL){\r\n    ArrayList<Cookie> list = new ArrayList<Cookie>();\r\n    for (String cs : cookiesStrings) {\r\n        String name = null;\r\n        String value = null;\r\n        String expires = null;\r\n        String domain = null;\r\n        String path = null;\r\n        boolean secure = false;\r\n        String[] tokens = cs.split(\";\");\r\n        int equals = tokens[0].indexOf(\"=\");\r\n        name = tokens[0].substring(0, equals);\r\n        value = tokens[0].substring(equals + 1);\r\n        for (int i = 1; i < tokens.length; i++) {\r\n            String ti = tokens[i].trim();\r\n            if (ti.equalsIgnoreCase(\"secure\"))\r\n                secure = true;\r\n            if (ti.toLowerCase().startsWith(\"path=\")) {\r\n                path = ti.substring(5);\r\n            }\r\n            if (ti.toLowerCase().startsWith(\"domain=\")) {\r\n                domain = ti.substring(7);\r\n            }\r\n            if (ti.toLowerCase().startsWith(\"expires=\")) {\r\n                expires = ti.substring(8);\r\n            }\r\n        }\r\n        BasicClientCookie cookie = new BasicClientCookie(name, value);\r\n        if (domain != null) {\r\n            cookie.setDomain(domain);\r\n            if (!checkDomainMatchToUrl(domain, targetURL.getHost()))\r\n                continue;\r\n        }\r\n        if (path != null) {\r\n            cookie.setPath(path);\r\n            if (!path.equals(\"\") && !path.equals(\"/\") && !targetURL.getPath().startsWith(path))\r\n                continue;\r\n        }\r\n        if (secure) {\r\n            cookie.setSecure(secure);\r\n            if (!targetURL.getProtocol().equalsIgnoreCase(\"https\"))\r\n                continue;\r\n        }\r\n        if (expires != null) {\r\n            try {\r\n                Date expirationDate = DATE_FORMAT.parse(expires);\r\n                cookie.setExpiryDate(expirationDate);\r\n                if (cookie.isExpired(new Date()))\r\n                    continue;\r\n                cookie.setExpiryDate(expirationDate);\r\n            } catch (ParseException e) {\r\n            }\r\n        }\r\n        list.add(cookie);\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.DHEServerKeyExchangeParser.parseSerializedPublicKeyLength",
	"Comment": "reads the next bytes as the serializedpublickeylength and writes them inthe message",
	"Method": "void parseSerializedPublicKeyLength(DHEServerKeyExchangeMessage msg){\r\n    msg.setPublicKeyLength(parseIntField(HandshakeByteLength.DH_PUBLICKEY_LENGTH));\r\n    LOGGER.debug(\"SerializedPublicKeyLength: \" + msg.getPublicKeyLength().getValue());\r\n}"
}, {
	"Path": "org.springframework.statemachine.config.common.annotation.configurers.DefaultResourceConfigurer.configureResources",
	"Comment": "configure resources. if this implementation is extended,\tcustom configure handling can be handled here.",
	"Method": "boolean configureResources(B builder,Set<Resource> resources){\r\n    return false;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.SignedCertificateTimestampExtensionParser.parseExtensionMessageContent",
	"Comment": "parses the content of the singedcertificatetimestampextension",
	"Method": "void parseExtensionMessageContent(SignedCertificateTimestampExtensionMessage msg){\r\n    if (msg.getExtensionLength().getValue() > 65535) {\r\n        LOGGER.warn(\"The SingedCertificateTimestamp ticket length shouldn't exceed 2 bytes as defined in RFC 6962. \" + \"Length was \" + msg.getExtensionLength().getValue());\r\n    }\r\n    msg.setSignedTimestamp(parseByteArrayField(msg.getExtensionLength().getValue()));\r\n    LOGGER.debug(\"The signed certificate timestamp extension parser parsed the value \" + bytesToHexString(msg.getSignedTimestamp()));\r\n}"
}, {
	"Path": "com.diffplug.spotless.FormatterTest.equality",
	"Comment": "formatter normally needs to be closed, but no resources will be leaked in this special case",
	"Method": "void equality(){\r\n    new SerializableEqualityTester() {\r\n        private LineEnding.Policy lineEndingsPolicy = LineEnding.UNIX.createPolicy();\r\n        private Charset encoding = StandardCharsets.UTF_8;\r\n        private Path rootDir = Paths.get(StandardSystemProperty.USER_DIR.value());\r\n        private List<FormatterStep> steps = new ArrayList();\r\n        private FormatExceptionPolicy exceptionPolicy = FormatExceptionPolicy.failOnlyOnError();\r\n        @Override\r\n        protected void setupTest(API api) throws Exception {\r\n            api.areDifferentThan();\r\n            lineEndingsPolicy = LineEnding.WINDOWS.createPolicy();\r\n            api.areDifferentThan();\r\n            encoding = StandardCharsets.UTF_16;\r\n            api.areDifferentThan();\r\n            rootDir = rootDir.getParent();\r\n            api.areDifferentThan();\r\n            steps.add(EndWithNewlineStep.create());\r\n            api.areDifferentThan();\r\n            {\r\n                FormatExceptionPolicyStrict standard = new FormatExceptionPolicyStrict();\r\n                standard.excludePath(\"path\");\r\n                exceptionPolicy = standard;\r\n                api.areDifferentThan();\r\n            }\r\n            {\r\n                FormatExceptionPolicyStrict standard = new FormatExceptionPolicyStrict();\r\n                standard.excludeStep(\"step\");\r\n                exceptionPolicy = standard;\r\n                api.areDifferentThan();\r\n            }\r\n        }\r\n        @Override\r\n        protected Formatter create() {\r\n            return Formatter.builder().lineEndingsPolicy(lineEndingsPolicy).encoding(encoding).rootDir(rootDir).steps(steps).exceptionPolicy(exceptionPolicy).build();\r\n        }\r\n    }.testEquals();\r\n}"
}, {
	"Path": "com.diffplug.spotless.FormatterTest.equality",
	"Comment": "formatter normally needs to be closed, but no resources will be leaked in this special case",
	"Method": "void equality(){\r\n    api.areDifferentThan();\r\n    lineEndingsPolicy = LineEnding.WINDOWS.createPolicy();\r\n    api.areDifferentThan();\r\n    encoding = StandardCharsets.UTF_16;\r\n    api.areDifferentThan();\r\n    rootDir = rootDir.getParent();\r\n    api.areDifferentThan();\r\n    steps.add(EndWithNewlineStep.create());\r\n    api.areDifferentThan();\r\n    {\r\n        FormatExceptionPolicyStrict standard = new FormatExceptionPolicyStrict();\r\n        standard.excludePath(\"path\");\r\n        exceptionPolicy = standard;\r\n        api.areDifferentThan();\r\n    }\r\n    {\r\n        FormatExceptionPolicyStrict standard = new FormatExceptionPolicyStrict();\r\n        standard.excludeStep(\"step\");\r\n        exceptionPolicy = standard;\r\n        api.areDifferentThan();\r\n    }\r\n}"
}, {
	"Path": "com.diffplug.spotless.FormatterTest.equality",
	"Comment": "formatter normally needs to be closed, but no resources will be leaked in this special case",
	"Method": "void equality(){\r\n    return Formatter.builder().lineEndingsPolicy(lineEndingsPolicy).encoding(encoding).rootDir(rootDir).steps(steps).exceptionPolicy(exceptionPolicy).build();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.RSAClientKeyExchangeHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class rsaclientkeyexchangehandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new RSAClientKeyExchangeMessage()) instanceof RSAClientKeyExchangeSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.SessionTicketTlsExtensionHandlerTest.testAdjustTLSContext",
	"Comment": "tests the adjusttlscontext of the sessiontickettlsextensionhandler class",
	"Method": "void testAdjustTLSContext(){\r\n    SessionTicketTLSExtensionMessage message = new SessionTicketTLSExtensionMessage();\r\n    message.setTicket(SESSION_TICKET);\r\n    message.setExtensionLength(EXTENSION_LENGTH);\r\n    handler.adjustTLSContext(message);\r\n    assertArrayEquals(SESSION_TICKET, context.getSessionTicketTLS());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.filter.DefaultFilter.postFilter",
	"Comment": "restore workflow trace values that were explicitly set by the user.currently restores only workflow trace connections set by the user.",
	"Method": "void postFilter(WorkflowTrace trace,WorkflowTrace reference){\r\n    trace.setConnections(reference.getConnections());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.HelloVerifyRequestHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class helloverifyrequesthandler.",
	"Method": "void testAdjustTLSContext(){\r\n    HelloVerifyRequestMessage message = new HelloVerifyRequestMessage();\r\n    message.setCookie(new byte[] { 0, 1, 2, 3 });\r\n    handler.adjustTLSContext(message);\r\n    assertArrayEquals(new byte[] { 0, 1, 2, 3 }, context.getDtlsCookie());\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.delegatesRetainAll",
	"Comment": "verboselist should delegate retainall method to decorated list.",
	"Method": "void delegatesRetainAll(){\r\n    final List<Object> collection = Collections.emptyList();\r\n    this.list.retainAll(collection);\r\n    Mockito.verify(this.origin).retainAll(collection);\r\n}"
}, {
	"Path": "org.takes.rs.RsWithTypeTest.addsCharsetToContentType",
	"Comment": "rswithtype can add the charset to the content type when it is explicitlyspecified.",
	"Method": "void addsCharsetToContentType(){\r\n    MatcherAssert.assertThat(new RsPrint(new RsWithType(new RsEmpty(), RsWithTypeTest.TYPE_TEXT, StandardCharsets.ISO_8859_1)).print(), Matchers.equalTo(Joiner.on(RsWithTypeTest.CRLF).join(RsWithTypeTest.HTTP_OK, String.format(RsWithTypeTest.TYPE_WITH_CHARSET, RsWithTypeTest.TYPE_TEXT, StandardCharsets.ISO_8859_1), \"\", \"\")));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.SignedCertificateTimestampExtensionHandler.getParser",
	"Comment": "returns a new signedcertificatetimestampextensionparser",
	"Method": "SignedCertificateTimestampExtensionParser getParser(byte[] message,int pointer){\r\n    return new SignedCertificateTimestampExtensionParser(pointer, message);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.HeartbeatMessageParser.parsePayloadLength",
	"Comment": "reads the next bytes as the payloadlength and writes them in the message",
	"Method": "void parsePayloadLength(HeartbeatMessage msg){\r\n    msg.setPayloadLength(parseIntField(HeartbeatByteLength.PAYLOAD_LENGTH));\r\n    LOGGER.debug(\"PayloadLength: \" + msg.getPayloadLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.attacks.pkcs1.oracles.TestPkcs1Oracle.checkXMLENC",
	"Comment": "presents an xml encryption oracle. this oracle checks, if the wrapped keyhas a correct size. it must be either 16, 24, or 32 bytes long.",
	"Method": "boolean checkXMLENC(byte[] msg){\r\n    if (!checkSecond(msg)) {\r\n        return false;\r\n    }\r\n    return hasCorrectKeySize(16, msg) || hasCorrectKeySize(24, msg) || hasCorrectKeySize(32, msg);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeMasterSecretActionTest.testExecute",
	"Comment": "test of execute method, of class changeclientrandomaction.",
	"Method": "void testExecute(){\r\n    tlsContext.setMasterSecret(new byte[] { 3 });\r\n    action.execute(state);\r\n    assertArrayEquals(action.getOldValue(), new byte[] { 3 });\r\n    assertArrayEquals(action.getNewValue(), new byte[] { 0, 1 });\r\n    assertArrayEquals(tlsContext.getMasterSecret(), new byte[] { 0, 1 });\r\n    assertTrue(action.isExecuted());\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.delegatesSubList",
	"Comment": "verboselist should delegate sublist method to decorated list.",
	"Method": "void delegatesSubList(){\r\n    final int from = 3;\r\n    final int toidx = 5;\r\n    this.list.subList(from, toidx);\r\n    Mockito.verify(this.origin).subList(from, toidx);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetTokenBindingKeyParameters",
	"Comment": "test of gettokenbindingkeyparameters method, of class defaultchooser.",
	"Method": "void testGetTokenBindingKeyParameters(){\r\n    List<TokenBindingKeyParameters> paramList = new LinkedList();\r\n    List<TokenBindingKeyParameters> paramList2 = new LinkedList();\r\n    paramList.add(TokenBindingKeyParameters.ECDSAP256);\r\n    paramList.add(TokenBindingKeyParameters.RSA2048_PKCS1_5);\r\n    paramList.add(TokenBindingKeyParameters.RSA2048_PSS);\r\n    config.setDefaultTokenBindingKeyParameters(paramList);\r\n    assertEquals(paramList, config.getDefaultTokenBindingKeyParameters());\r\n    assertEquals(paramList, chooser.getTokenBindingKeyParameters());\r\n    context.setTokenBindingKeyParameters(paramList2);\r\n    assertEquals(paramList2, chooser.getTokenBindingKeyParameters());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskDheServerKeyExchangeHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class pskdheserverkeyexchangehandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new PskDheServerKeyExchangeMessage()) instanceof PskDheServerKeyExchangeSerializer);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorPlanReconstructionActivity.onPreDrawing",
	"Comment": "method called each time right before the floorplan is drawn. it allows use of the tangoservice to get the device position and orientation.",
	"Method": "void onPreDrawing(){\r\n    try {\r\n        synchronized (FloorPlanReconstructionActivity.this) {\r\n            if (!mIsConnected) {\r\n                return;\r\n            }\r\n            TangoPoseData devicePose = TangoSupport.getPoseAtTime(0.0, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_DEVICE, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n            if (devicePose.statusCode == TangoPoseData.POSE_VALID) {\r\n                float[] devicePosition = devicePose.getTranslationAsFloats();\r\n                float[] deviceOrientation = devicePose.getRotationAsFloats();\r\n                float yawRadians = yRotationFromQuaternion(deviceOrientation[0], deviceOrientation[1], deviceOrientation[2], deviceOrientation[3]);\r\n                mFloorplanView.updateCameraMatrix(devicePosition[0], devicePosition[2], yawRadians);\r\n            } else {\r\n                Log.w(TAG, \"Can't get last device pose\");\r\n            }\r\n        }\r\n    } catch (TangoErrorException e) {\r\n        Log.e(TAG, \"Tango error while querying device pose.\", e);\r\n    } catch (TangoInvalidException e) {\r\n        Log.e(TAG, \"Tango exception while querying device pose.\", e);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.HelloVerifyRequestHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class helloverifyrequesthandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new HelloVerifyRequestMessage()) instanceof HelloVerifyRequestPreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.record.crypto.RecordDecryptorTest.testDecrypt",
	"Comment": "test of the decrypt method for tls 1.3, of class recorddecryptor.",
	"Method": "void testDecrypt(){\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS13_DRAFT21);\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_AES_128_GCM_SHA256);\r\n    context.setClientHandshakeTrafficSecret(ArrayConverter.hexStringToByteArray(\"4B63051EABCD514D7CB6D1899F472B9F56856B01BDBC5B733FBB47269E7EBDC2\"));\r\n    context.setServerHandshakeTrafficSecret(ArrayConverter.hexStringToByteArray(\"ACC9DB33EE0968FAE7E06DAA34D642B146092CE7F9C9CF47670C66A0A6CE1C8C\"));\r\n    context.setConnection(new OutboundConnection());\r\n    record.setProtocolMessageBytes(ArrayConverter.hexStringToByteArray(\"1BB3293A919E0D66F145AE830488E8D89BE5EC16688229\"));\r\n    record.setLength(record.getProtocolMessageBytes().getValue().length);\r\n    context.setActiveClientKeySetType(Tls13KeySetType.HANDSHAKE_TRAFFIC_SECRETS);\r\n    recordCipher = new RecordAEADCipher(context, KeySetGenerator.generateKeySet(context));\r\n    decryptor = new RecordDecryptor(recordCipher, context);\r\n    decryptor.decrypt(record);\r\n    assertTrue(record.getCleanProtocolMessageBytes().getValue().length == 6);\r\n    assertArrayEquals(record.getCleanProtocolMessageBytes().getValue(), ArrayConverter.hexStringToByteArray(\"080000020000\"));\r\n}"
}, {
	"Path": "org.takes.facets.auth.PsAllTest.testSuccessfullIdx",
	"Comment": "psall with multiple passes that all can be entered returns theidentity specified by an index.",
	"Method": "void testSuccessfullIdx(){\r\n    final Pass resulting = new PsFixed(new Identity.Simple(\"urn:foo:test\"));\r\n    final RqFake request = new RqFake();\r\n    MatcherAssert.assertThat(new PsAll(Arrays.asList(new PsFake(true), new PsFake(true), new PsFake(true), resulting), Tv.THREE).enter(request).get().urn(), Matchers.equalTo(resulting.enter(request).get().urn()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.util.BasicTlsClientServerTest.testSimpleProxy",
	"Comment": "run a tls handshake between basictlsclient and basictlsserver.",
	"Method": "void testSimpleProxy(){\r\n    try {\r\n        TimeHelper.setProvider(new FixedTimeProvider(0));\r\n        KeyPair k = KeyStoreGenerator.createRSAKeyPair(1024, random);\r\n        KeyStore ks = KeyStoreGenerator.createKeyStore(k, random);\r\n        BasicTlsServer tlsServer = new BasicTlsServer(ks, KeyStoreGenerator.PASSWORD, \"TLS\", SERVER_PORT);\r\n        LOGGER.info(\"Starting test server\");\r\n        new Thread(tlsServer).start();\r\n        while (!tlsServer.isInitialized()) ;\r\n        LOGGER.info(\"Starting test client\");\r\n        BasicTlsClient client = new BasicTlsClient(\"localhost\", tlsServer.getPort(), ProtocolVersion.TLS12, CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA);\r\n        client.setRetryConnect(false);\r\n        Thread clientThread = new Thread(client);\r\n        clientThread.start();\r\n        TimeUnit.SECONDS.sleep(1);\r\n        LOGGER.info(\"Killing client\");\r\n        clientThread.interrupt();\r\n        LOGGER.info(\"Done.\");\r\n        LOGGER.info(\"Killing server...\");\r\n        tlsServer.shutdown();\r\n        LOGGER.info(\"Done.\");\r\n    } catch (NoSuchAlgorithmException | CertificateException | IOException | InvalidKeyException | KeyStoreException | NoSuchProviderException | SignatureException | UnrecoverableKeyException | KeyManagementException | InterruptedException ex) {\r\n        fail();\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderRenderer.updateMVPMatrix",
	"Comment": "composes the model, view and projection matrices into a single mvp matrix.",
	"Method": "void updateMVPMatrix(){\r\n    float[] modelViewMatrix = new float[16];\r\n    Matrix.setIdentityM(modelViewMatrix, 0);\r\n    Matrix.multiplyMM(modelViewMatrix, 0, mViewMatrix, 0, mModelMatrix, 0);\r\n    Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, modelViewMatrix, 0);\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.context.SpatialContextFactory.checkDefaultFormats",
	"Comment": "if no formats were defined in the config, this will make sure geojson and wkt are registered",
	"Method": "void checkDefaultFormats(){\r\n    if (readers.isEmpty()) {\r\n        addReaderIfNoggitExists(GeoJSONReader.class);\r\n        readers.add(WKTReader.class);\r\n        readers.add(PolyshapeReader.class);\r\n        readers.add(LegacyShapeReader.class);\r\n    }\r\n    if (writers.isEmpty()) {\r\n        writers.add(GeoJSONWriter.class);\r\n        writers.add(WKTWriter.class);\r\n        writers.add(PolyshapeWriter.class);\r\n        writers.add(LegacyShapeWriter.class);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeServerRandomActionTest.testSetNewValue",
	"Comment": "test of setnewvalue method, of class changeclientrandomaction.",
	"Method": "void testSetNewValue(){\r\n    assertArrayEquals(action.getNewValue(), new byte[] { 0, 1 });\r\n    action.setNewValue(new byte[] { 0 });\r\n    assertArrayEquals(action.getNewValue(), new byte[] { 0 });\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.HelloVerifyRequestPreparatorTest.testPrepare",
	"Comment": "test of preparehandshakemessagecontents method, of classhelloverifyrequestpreparator.",
	"Method": "void testPrepare(){\r\n    context.getConfig().setDefaultDTLSCookieLength(10);\r\n    context.getConfig().setHighestProtocolVersion(ProtocolVersion.DTLS12);\r\n    preparator.prepare();\r\n    LOGGER.info(ArrayConverter.bytesToHexString(message.getCookie().getValue(), false));\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"60B420BB3851D9D47ACB\"), message.getCookie().getValue());\r\n    assertTrue(10 == message.getCookieLength().getValue());\r\n    assertArrayEquals(ProtocolVersion.DTLS12.getValue(), message.getProtocolVersion().getValue());\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.util.CharsetIdentification.getCharsetFromMeta",
	"Comment": "attempt to find a meta tag in the html that hints at the character setused to write the document.",
	"Method": "String getCharsetFromMeta(byte buffer,int maxlength){\r\n    int len = buffer.length;\r\n    if (maxlength > 0 && maxlength < len) {\r\n        len = maxlength;\r\n    }\r\n    String html = new String(buffer, 0, len, DEFAULT_CHARSET);\r\n    Document doc = Parser.htmlParser().parseInput(html, \"dummy\");\r\n    Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\r\n    String foundCharset = null;\r\n    for (Element meta : metaElements) {\r\n        if (meta.hasAttr(\"http-equiv\"))\r\n            foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\r\n        if (foundCharset == null && meta.hasAttr(\"charset\"))\r\n            foundCharset = meta.attr(\"charset\");\r\n        if (foundCharset != null)\r\n            return foundCharset;\r\n    }\r\n    return foundCharset;\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.shape.RectIntersectionTestHelper.isRandomShapeRectangular",
	"Comment": "override to return true if generaterandomshape is essentially a rectangle.",
	"Method": "boolean isRandomShapeRectangular(){\r\n    return false;\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.identity.AWSCognitoDeveloperAuthenticationSample.getCognitoToken",
	"Comment": "generate tokens for given uid. the tokens are encrypted using the keycorresponding to uid. encrypted tokens are then wrapped in json objectbefore returning it. useful in anonymous and identity modes",
	"Method": "String getCognitoToken(String uid,Map<String, String> logins,String identityId){\r\n    DeviceInfo device = ensureKnownDevice(uid);\r\n    UserInfo user = ensureKnownUser(device.getUsername());\r\n    if (!user.getUsername().equals(logins.get(Configuration.DEVELOPER_PROVIDER_NAME))) {\r\n        throw new UnauthorizedException(\"User mismatch for device and logins map\");\r\n    }\r\n    log.info(\"Creating temporary credentials\");\r\n    GetOpenIdTokenForDeveloperIdentityResult result = byoiManagement.getTokenFromCognito(user.getUsername(), logins, identityId);\r\n    log.info(\"Generating session tokens for UID : \" + uid);\r\n    return Utilities.prepareCognitoJsonResponseForTokens(result, device.getKey());\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPITest.testTessBaseAPIPrintVariablesToFile",
	"Comment": "test of tessbaseapiprintvariables method, of class tessapi.",
	"Method": "void testTessBaseAPIPrintVariablesToFile(){\r\n    logger.info(\"TessBaseAPIPrintVariablesToFile\");\r\n    String var = \"tessedit_char_whitelist\";\r\n    String value = \"0123456789\";\r\n    api.TessBaseAPISetVariable(handle, var, value);\r\n    String filename = \"printvar.txt\";\r\n    api.TessBaseAPIPrintVariablesToFile(handle, filename);\r\n    File file = new File(filename);\r\n    BufferedReader input = new BufferedReader(new FileReader(file));\r\n    StringBuilder strB = new StringBuilder();\r\n    String line;\r\n    String EOL = System.getProperty(\"line.separator\");\r\n    while ((line = input.readLine()) != null) {\r\n        strB.append(line).append(EOL);\r\n    }\r\n    input.close();\r\n    file.delete();\r\n    assertTrue(strB.toString().contains(var + \"\\t\" + value));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.CopyServerRandomActionTest.testGetAllAliases",
	"Comment": "test of getallaliases method, of class changeserverrandomaction.",
	"Method": "void testGetAllAliases(){\r\n    String[] aliases = action.getAllAliases().toArray(new String[2]);\r\n    assertEquals(aliases.length, 2);\r\n    assertTrue(aliases[0].equals(\"server1\") || aliases[0].equals(\"server2\"));\r\n    assertTrue(aliases[1].equals(\"server1\") || aliases[1].equals(\"server2\"));\r\n    assertNotEquals(aliases[0], aliases[1]);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.KeyShareExtensionParserTest.testParseExtensionMessageContent",
	"Comment": "test of parseextensionmessagecontent method, of classkeyshareextensionparser.",
	"Method": "void testParseExtensionMessageContent(){\r\n    KeyShareExtensionParser parser = new KeyShareExtensionParser(start, extension);\r\n    KeyShareExtensionMessage msg = parser.parse();\r\n    assertArrayEquals(msg.getExtensionBytes().getValue(), completeExtension);\r\n    assertArrayEquals(type.getValue(), msg.getExtensionType().getValue());\r\n    assertTrue(extensionLength == msg.getExtensionLength().getValue());\r\n    assertArrayEquals(msg.getKeyShareListBytes().getValue(), ksListBytes);\r\n    assertTrue(ksListLength == msg.getKeyShareListLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.factory.WorkflowConfigurationFactory.createFalseStartWorkflow",
	"Comment": "create a handshake workflow for the default connection end defined inconfig.",
	"Method": "WorkflowTrace createFalseStartWorkflow(WorkflowTrace createFalseStartWorkflow,AliasedConnection connection){\r\n    if (config.getHighestProtocolVersion().isTLS13()) {\r\n        throw new ConfigurationException(\"The false start workflow is not implemented for TLS 1.3\");\r\n    }\r\n    WorkflowTrace workflowTrace = this.createHandshakeWorkflow(connection);\r\n    MessageAction appData = MessageActionFactory.createAction(connection, ConnectionEndType.CLIENT, new ApplicationMessage(config));\r\n    TlsAction lastClientAction;\r\n    if (connection.getLocalConnectionEndType() == ConnectionEndType.CLIENT) {\r\n        lastClientAction = (TlsAction) workflowTrace.getLastSendingAction();\r\n    } else {\r\n        lastClientAction = (TlsAction) workflowTrace.getLastReceivingAction();\r\n    }\r\n    int i = workflowTrace.getTlsActions().indexOf(lastClientAction);\r\n    workflowTrace.addTlsAction(i + 1, appData);\r\n    return workflowTrace;\r\n}"
}, {
	"Path": "org.takes.misc.VerboseIteratorTest.nextValueThrowsExceptionOnEmptyList",
	"Comment": "verboseiterator next value throws exception on an empty list.",
	"Method": "void nextValueThrowsExceptionOnEmptyList(){\r\n    new VerboseIterable<String>(Collections.<String>emptyList(), \"Expected Error Message\").iterator().next();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.DHEServerKeyExchangeParser.parseSerializedPublicKey",
	"Comment": "reads the next bytes as the serializedpublickey and writes them in themessage",
	"Method": "void parseSerializedPublicKey(DHEServerKeyExchangeMessage msg){\r\n    msg.setPublicKey(parseByteArrayField(msg.getPublicKeyLength().getValue()));\r\n    LOGGER.debug(\"SerializedPublicKey: \" + ArrayConverter.bytesToHexString(msg.getPublicKey().getValue()));\r\n}"
}, {
	"Path": "com.example.android.trivialdrivesample.util.Security.verify",
	"Comment": "verifies that the signature from the server matches the computedsignature on the data.returns true if the data is correctly signed.",
	"Method": "boolean verify(PublicKey publicKey,String signedData,String signature){\r\n    Signature sig;\r\n    try {\r\n        sig = Signature.getInstance(SIGNATURE_ALGORITHM);\r\n        sig.initVerify(publicKey);\r\n        sig.update(signedData.getBytes());\r\n        if (!sig.verify(Base64.decode(signature))) {\r\n            Log.e(TAG, \"Signature verification failed.\");\r\n            return false;\r\n        }\r\n        return true;\r\n    } catch (NoSuchAlgorithmException e) {\r\n        Log.e(TAG, \"NoSuchAlgorithmException.\");\r\n    } catch (InvalidKeyException e) {\r\n        Log.e(TAG, \"Invalid key specification.\");\r\n    } catch (SignatureException e) {\r\n        Log.e(TAG, \"Signature exception.\");\r\n    } catch (Base64DecoderException e) {\r\n        Log.e(TAG, \"Base64 decoding failed.\");\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.projecttango.rajawali.ScenePoseCalculator.calculateProjectionMatrix",
	"Comment": "use tango camera intrinsics to calculate the projection matrix for the rajawali scene.",
	"Method": "Matrix4 calculateProjectionMatrix(int width,int height,double fx,double fy,double cx,double cy){\r\n    double near = 0.1;\r\n    double far = 100;\r\n    double xScale = near / fx;\r\n    double yScale = near / fy;\r\n    double xOffset = (cx - (width / 2.0)) * xScale;\r\n    double yOffset = -(cy - (height / 2.0)) * yScale;\r\n    double[] m = new double[16];\r\n    Matrix.frustumM(m, 0, xScale * -width / 2.0 - xOffset, xScale * width / 2.0 - xOffset, yScale * -height / 2.0 - yOffset, yScale * height / 2.0 - yOffset, near, far);\r\n    return new Matrix4(m);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeClientRandomActionTest.testSetNewValue",
	"Comment": "test of setnewvalue method, of class changeclientrandomaction.",
	"Method": "void testSetNewValue(){\r\n    assertArrayEquals(action.getNewValue(), new byte[] { 0, 1 });\r\n    action.setNewValue(new byte[] { 0 });\r\n    assertArrayEquals(action.getNewValue(), new byte[] { 0 });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.occlusion.meshing.TangoMesher.setDepthCameraCalibration",
	"Comment": "synchronize access to mtango3dreconstruction. this runs in ui thread.",
	"Method": "void setDepthCameraCalibration(TangoCameraIntrinsics calibration){\r\n    mTango3dReconstruction.setDepthCameraCalibration(calibration);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.RSAClientKeyExchangeParser.parseSerializedPublicKeyLength",
	"Comment": "reads the next bytes as the serializedpublickeylength and writes them inthe message",
	"Method": "void parseSerializedPublicKeyLength(T msg){\r\n    if (getVersion().isSSL()) {\r\n        msg.setPublicKeyLength(getBytesLeft());\r\n    } else {\r\n        msg.setPublicKeyLength(parseIntField(HandshakeByteLength.ENCRYPTED_PREMASTER_SECRET_LENGTH));\r\n    }\r\n    LOGGER.debug(\"SerializedPublicKeyLength: \" + msg.getPublicKeyLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetServerSessionId",
	"Comment": "test of getserversessionid method, of class defaultchooser.",
	"Method": "void testGetServerSessionId(){\r\n    byte[] sessionID = new byte[0];\r\n    config.setDefaultServerSessionId(sessionID);\r\n    assertArrayEquals(sessionID, config.getDefaultServerSessionId());\r\n    assertArrayEquals(sessionID, chooser.getServerSessionId());\r\n    context.setServerSessionId(sessionID);\r\n    assertArrayEquals(sessionID, chooser.getServerSessionId());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.DHClientKeyExchangeParser.parseSerializedPublicKeyLength",
	"Comment": "reads the next bytes as the serializedpublickeylength and writes them inthe message",
	"Method": "void parseSerializedPublicKeyLength(T message){\r\n    message.setPublicKeyLength(parseIntField(HandshakeByteLength.DH_PUBLICKEY_LENGTH));\r\n    LOGGER.debug(\"SerializedPublicKeyLength: \" + message.getPublicKeyLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.MessageActionFactoryTest.testCreateActionOne",
	"Comment": "test of createaction method, of class messageactionfactory.",
	"Method": "void testCreateActionOne(){\r\n    MessageAction action = MessageActionFactory.createAction(clientConnection, ConnectionEndType.CLIENT, new AlertMessage(config));\r\n    assertEquals(action.getClass(), SendAction.class);\r\n    action = MessageActionFactory.createAction(clientConnection, ConnectionEndType.SERVER, new AlertMessage(config));\r\n    assertEquals(action.getClass(), ReceiveAction.class);\r\n    action = MessageActionFactory.createAction(serverConnection, ConnectionEndType.CLIENT, new AlertMessage(config));\r\n    assertEquals(action.getClass(), ReceiveAction.class);\r\n    action = MessageActionFactory.createAction(serverConnection, ConnectionEndType.SERVER, new AlertMessage(config));\r\n    assertEquals(action.getClass(), SendAction.class);\r\n    assertTrue(action.messages.size() == 1);\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.wrapsIndexOutOfBoundsExceptionFromSubList",
	"Comment": "verboselist should wraps outofboundsexception thrown by sublist method.",
	"Method": "void wrapsIndexOutOfBoundsExceptionFromSubList(){\r\n    final int from = 2;\r\n    final int toidx = 5;\r\n    final Exception cause = new IndexOutOfBoundsException();\r\n    Mockito.doThrow(cause).when(this.origin).subList(from, toidx);\r\n    this.thrown.expect(IndexOutOfBoundsException.class);\r\n    this.thrown.expectMessage(VerboseListTest.MSG);\r\n    this.thrown.expectCause(Matchers.is(cause));\r\n    this.list.subList(from, toidx);\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.Metadata.getFirstValue",
	"Comment": "returns the first non empty value found for the keys or null if nonefound.",
	"Method": "String getFirstValue(String key,String getFirstValue,Metadata md,String keys){\r\n    for (String key : keys) {\r\n        String val = md.getFirstValue(key);\r\n        if (StringUtils.isBlank(val))\r\n            continue;\r\n        return val;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceRenderer.updateModelRendering",
	"Comment": "render the data model.render the next correspondence source point to be added as a green sphere. render thecorrespondence destination points as red spheres. render the 3d model in the position andorientation given by the found correspondence transform.",
	"Method": "void updateModelRendering(HouseModel houseModel,float[] openGlTHouse,List<float[]> destPoints){\r\n    if (destPoints.size() > mDestPointsObjectList.size()) {\r\n        for (int i = mDestPointsObjectList.size(); i < destPoints.size(); i++) {\r\n            Object3D destPointObject3D = makePoint(destPoints.get(i), Color.RED);\r\n            getCurrentScene().addChild(destPointObject3D);\r\n            mDestPointsObjectList.add(destPointObject3D);\r\n        }\r\n    } else if (destPoints.size() < mDestPointsObjectList.size()) {\r\n        for (int i = destPoints.size(); i < mDestPointsObjectList.size(); i++) {\r\n            Object3D destPointObject3D = mDestPointsObjectList.get(i);\r\n            getCurrentScene().removeChild(destPointObject3D);\r\n            mDestPointsObjectList.remove(i);\r\n        }\r\n    }\r\n    int nextPointNumber = destPoints.size();\r\n    List<float[]> houseModelPoints = houseModel.getOpenGlModelPpoints(openGlTHouse);\r\n    if (nextPointNumber < houseModelPoints.size()) {\r\n        if (mNextPointObject3D == null) {\r\n            mNextPointObject3D = makePoint(new float[] { 0, 0, 0 }, Color.GREEN);\r\n            getCurrentScene().addChild(mNextPointObject3D);\r\n        }\r\n        float[] position = houseModelPoints.get(nextPointNumber);\r\n        mNextPointObject3D.setPosition(position[0], position[1], position[2]);\r\n    } else {\r\n        getCurrentScene().removeChild(mNextPointObject3D);\r\n        mNextPointObject3D = null;\r\n    }\r\n    if (mHouseObject3D != null) {\r\n        Matrix4 transform = new Matrix4(openGlTHouse);\r\n        double scale = transform.getScaling().x;\r\n        mHouseObject3D.setScale(scale);\r\n        Vector3 translation = transform.getTranslation();\r\n        Matrix4 invScale = Matrix4.createScaleMatrix(1 / scale, 1 / scale, 1 / scale);\r\n        transform.multiply(invScale);\r\n        Quaternion orientation = new Quaternion().fromMatrix(transform);\r\n        orientation.normalize();\r\n        mHouseObject3D.setPosition(translation);\r\n        mHouseObject3D.setOrientation(orientation);\r\n    }\r\n}"
}, {
	"Path": "org.takes.http.BkBasicTest.returnsProperResponseCodeOnInvalidUrl",
	"Comment": "bkbasic can return http status 404 when accessing invalid url.",
	"Method": "void returnsProperResponseCodeOnInvalidUrl(){\r\n    new FtRemote(new TkFork(new FkRegex(\"/path/a\", new TkText(\"a\")), new FkRegex(\"/path/b\", new TkText(\"b\")))).exec(new FtRemote.Script() {\r\n        @Override\r\n        public void exec(final URI home) throws IOException {\r\n            new JdkRequest(String.format(\"%s/path/c\", home)).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NOT_FOUND);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.takes.http.BkBasicTest.returnsProperResponseCodeOnInvalidUrl",
	"Comment": "bkbasic can return http status 404 when accessing invalid url.",
	"Method": "void returnsProperResponseCodeOnInvalidUrl(){\r\n    new JdkRequest(String.format(\"%s/path/c\", home)).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_NOT_FOUND);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.tokenbinding.TokenBindingMessageSerializerTest.testSerializeProtocolMessageContent",
	"Comment": "test of serializeprotocolmessagecontent method, of classtokenbindingmessageserializer.",
	"Method": "void testSerializeProtocolMessageContent(){\r\n    serializer.serialize();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.CiphersuiteDelegateTest.testGetCipherSuites",
	"Comment": "test of getciphersuites method, of class ciphersuitedelegate.",
	"Method": "void testGetCipherSuites(){\r\n    args = new String[2];\r\n    args[0] = \"-cipher\";\r\n    args[1] = \"TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA\";\r\n    jcommander.parse(args);\r\n    assertTrue(\"TLS_RSA_WITH_AES_128_CBC_SHA should get parsed correctly\", delegate.getCipherSuites().contains(CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA));\r\n    assertTrue(\"TLS_RSA_WITH_AES_256_CBC_SHA should get parsed correctly\", delegate.getCipherSuites().contains(CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.SignatureAndHashAlgorithmDelegateTest.testApplyDelegate",
	"Comment": "test of applydelegate method, of class signatureandhashalgorithmdelegate.",
	"Method": "void testApplyDelegate(){\r\n    Config config = Config.createConfig();\r\n    args = new String[2];\r\n    args[0] = \"-signature_hash_algo\";\r\n    args[1] = \"RSA_SHA512,DSA_SHA512\";\r\n    delegate.setSignatureAndHashAlgorithms(null);\r\n    jcommander.parse(args);\r\n    config.setAddSignatureAndHashAlgorithmsExtension(false);\r\n    assertFalse(config.isAddSignatureAndHashAlgrorithmsExtension());\r\n    delegate.applyDelegate(config);\r\n    assertTrue(config.isAddSignatureAndHashAlgrorithmsExtension());\r\n    assertTrue(config.getSupportedSignatureAndHashAlgorithms().contains(SignatureAndHashAlgorithm.RSA_SHA512));\r\n    assertTrue(config.getSupportedSignatureAndHashAlgorithms().contains(SignatureAndHashAlgorithm.DSA_SHA512));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangePreMasterSecretActionTest.testGetOldValue",
	"Comment": "test of getoldvalue method, of class changeclientrandomaction.",
	"Method": "void testGetOldValue(){\r\n    tlsContext.setPreMasterSecret(new byte[] { 3 });\r\n    action.execute(state);\r\n    assertArrayEquals(action.getOldValue(), new byte[] { 3 });\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.AlertPreparatorTest.testPrepare",
	"Comment": "test of prepareprotocolmessagecontents method, of class alertpreparator.",
	"Method": "void testPrepare(){\r\n    message.setConfig(AlertLevel.FATAL, AlertDescription.DECRYPT_ERROR);\r\n    preparator.prepare();\r\n    assertTrue(message.getLevel().getValue() == AlertLevel.FATAL.getValue());\r\n    assertTrue(message.getDescription().getValue() == AlertDescription.DECRYPT_ERROR.getValue());\r\n}"
}, {
	"Path": "com.diffplug.spotless.Formatter.compute",
	"Comment": "returns the result of calling all of the formattersteps.\tthe input must have unix line endings, and the output\tis guaranteed to also have unix line endings.",
	"Method": "String compute(String unix,File file){\r\n    Objects.requireNonNull(unix, \"unix\");\r\n    Objects.requireNonNull(file, \"file\");\r\n    for (FormatterStep step : steps) {\r\n        try {\r\n            String formatted = step.format(unix, file);\r\n            if (formatted == null) {\r\n            } else {\r\n                unix = LineEnding.toUnix(formatted);\r\n            }\r\n        } catch (Throwable e) {\r\n            String relativePath = rootDir.relativize(file.toPath()).toString();\r\n            exceptionPolicy.handleError(e, step, relativePath);\r\n        }\r\n    }\r\n    return unix;\r\n}"
}, {
	"Path": "com.diffplug.spotless.TestProvisioner.caching",
	"Comment": "creates a provisioner which will cache the result of previous calls.",
	"Method": "Provisioner caching(String name,Supplier<Provisioner> input){\r\n    File spotlessDir = new File(StandardSystemProperty.USER_DIR.value()).getParentFile();\r\n    File testlib = new File(spotlessDir, \"testlib\");\r\n    File cacheFile = new File(testlib, \"build/tmp/testprovisioner.\" + name + \".cache\");\r\n    Map<ImmutableSet<String>, ImmutableSet<File>> cached;\r\n    if (cacheFile.exists()) {\r\n        try (ObjectInputStream inputStream = new ObjectInputStream(Files.asByteSource(cacheFile).openBufferedStream())) {\r\n            cached = (Map<ImmutableSet<String>, ImmutableSet<File>>) inputStream.readObject();\r\n        } catch (IOException | ClassNotFoundException e) {\r\n            throw Errors.asRuntime(e);\r\n        }\r\n    } else {\r\n        cached = new HashMap();\r\n    }\r\n    return (withTransitives, mavenCoords) -> {\r\n        Box<Boolean> wasChanged = Box.of(false);\r\n        ImmutableSet<File> result = cached.computeIfAbsent(ImmutableSet.copyOf(mavenCoords), coords -> {\r\n            wasChanged.set(true);\r\n            return ImmutableSet.copyOf(input.get().provisionWithTransitives(withTransitives, coords));\r\n        });\r\n        if (wasChanged.get()) {\r\n            try (ObjectOutputStream outputStream = new ObjectOutputStream(Files.asByteSink(cacheFile).openBufferedStream())) {\r\n                outputStream.writeObject(cached);\r\n            } catch (IOException e) {\r\n                throw Errors.asRuntime(e);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}"
}, {
	"Path": "com.diffplug.spotless.Formatter.applyToAndReturnResultIfDirty",
	"Comment": "applies formatting to the given file.\treturns null if the file was already clean, or the\tformatted result with unix newlines if it was not.",
	"Method": "String applyToAndReturnResultIfDirty(File file){\r\n    Objects.requireNonNull(file);\r\n    byte[] rawBytes = Files.readAllBytes(file.toPath());\r\n    String raw = new String(rawBytes, encoding);\r\n    String rawUnix = LineEnding.toUnix(raw);\r\n    String formattedUnix = compute(rawUnix, file);\r\n    String formatted = computeLineEndings(formattedUnix, file);\r\n    byte[] formattedBytes = formatted.getBytes(encoding);\r\n    if (!Arrays.equals(rawBytes, formattedBytes)) {\r\n        Files.write(file.toPath(), formattedBytes, StandardOpenOption.TRUNCATE_EXISTING);\r\n        return formattedUnix;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.java.EclipseFormatterStep.create",
	"Comment": "creates a formatter step for the given version and settings files.",
	"Method": "FormatterStep create(File settingsFile,Provisioner provisioner,FormatterStep create,Iterable<File> settingsFiles,Provisioner provisioner,FormatterStep create,String version,File settingsFile,Provisioner provisioner,FormatterStep create,String version,Iterable<File> settingsFiles,Provisioner provisioner){\r\n    Objects.requireNonNull(version, \"version\");\r\n    Objects.requireNonNull(settingsFiles, \"settingsFiles\");\r\n    Objects.requireNonNull(provisioner, \"provisioner\");\r\n    EclipseBasedStepBuilder builder = EclipseJdtFormatterStep.createBuilder(provisioner);\r\n    builder.setPreferences(settingsFiles);\r\n    builder.setVersion(DEFAULT_VERSION);\r\n    return builder.build();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.util.ServerCertificateKeyTest.testGetServerCertificateKey",
	"Comment": "test of getservercertificatekey method, of class servercertificatekey.",
	"Method": "void testGetServerCertificateKey(){\r\n    assertEquals(ServerCertificateKey.DH, ServerCertificateKey.getServerCertificateKey(CipherSuite.TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA));\r\n    assertEquals(ServerCertificateKey.RSA, ServerCertificateKey.getServerCertificateKey(CipherSuite.TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA));\r\n    assertEquals(ServerCertificateKey.RSA, ServerCertificateKey.getServerCertificateKey(CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA));\r\n    assertEquals(ServerCertificateKey.EC, ServerCertificateKey.getServerCertificateKey(CipherSuite.TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA));\r\n    assertEquals(ServerCertificateKey.NONE, ServerCertificateKey.getServerCertificateKey(CipherSuite.TLS_ECDH_anon_WITH_RC4_128_SHA));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.DHEServerKeyExchangeHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class dheserverkeyexchangehandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof DHEServerKeyExchangeParser);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeCompressionActionTest.testSetNewValue",
	"Comment": "test of setnewvalue method, of class changecompressionaction.",
	"Method": "void testSetNewValue(){\r\n    assertEquals(action.getNewValue(), CompressionMethod.LZS);\r\n    action.setNewValue(CompressionMethod.DEFLATE);\r\n    assertEquals(action.getNewValue(), CompressionMethod.DEFLATE);\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.context.SpatialContextFactory.newSpatialContext",
	"Comment": "subclasses should simply construct the instance from the initialized configuration.",
	"Method": "SpatialContext newSpatialContext(){\r\n    return new SpatialContext(this);\r\n}"
}, {
	"Path": "org.takes.rs.xe.XeMemoryTest.buildsHtmlResponse",
	"Comment": "xemillis can build html response with default xsl template.",
	"Method": "void buildsHtmlResponse(){\r\n    MatcherAssert.assertThat(IOUtils.toString(new RsXslt(new RsXembly(new XeStylesheet(\"/org/takes/rs/xe/test_memory.xsl\"), new XeAppend(\"page\", new XeMemory()))).body(), StandardCharsets.UTF_8), XhtmlMatchers.hasXPaths(\"/xhtml:html/xhtml:span\"));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ApplicationMessageHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class applicationmessagehandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new ApplicationMessage()) instanceof ApplicationMessageSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeProtocolVersionActionTest.testSetNewValue",
	"Comment": "test of setnewvalue method, of class changecompressionaction.",
	"Method": "void testSetNewValue(){\r\n    assertEquals(action.getNewValue(), ProtocolVersion.SSL2);\r\n    action.setNewValue(ProtocolVersion.TLS11);\r\n    assertEquals(action.getNewValue(), ProtocolVersion.TLS11);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.ExtensionParser.parseExtensionLength",
	"Comment": "reads the next bytes as the length of the extension and writes them inthe message",
	"Method": "void parseExtensionLength(ExtensionMessage msg){\r\n    msg.setExtensionLength(parseIntField(ExtensionByteLength.EXTENSIONS_LENGTH));\r\n    LOGGER.debug(\"ExtensionLength: \" + msg.getExtensionLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.https.HttpsResponseParserTest.testParseMessageContentFailed",
	"Comment": "test of parsemessagecontent method, of class httpsresponseparser with aninvalid response.",
	"Method": "void testParseMessageContentFailed(){\r\n    HttpsResponseParser parser = new HttpsResponseParser(0, ArrayConverter.hexStringToByteArray(\"AAAAAAAAAAAAAAAAAAAAAAAA\"), ProtocolVersion.TLS12);\r\n    parser.parse();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskClientKeyExchangeHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class pskclientkeyexchangehandler.",
	"Method": "void testAdjustTLSContext(){\r\n    PskClientKeyExchangeMessage message = new PskClientKeyExchangeMessage();\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_PSK_WITH_AES_128_CBC_SHA);\r\n    message.prepareComputations();\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS12);\r\n    context.setRecordLayer(new TlsRecordLayer(context));\r\n    message.getComputations().setPremasterSecret(ArrayConverter.hexStringToByteArray(\"0303d3fad5b20109834717bac4e7762e217add183d0c4852ab054f65ba6e93b1ed83ca5c5fa614cd3b810f4766c66feb\"));\r\n    message.getComputations().setClientServerRandom(ArrayConverter.hexStringToByteArray(\"a449532975d478abeefcfafa7522b9312bdbd0bb294fe460c4d52bab13a425b7594d0e9508874a67db6d9b8e91db4f38600e88f006bbe58f2b41deb6811c74cc\"));\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_PSK_WITH_AES_128_CBC_SHA);\r\n    handler.adjustTLSContext(message);\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"0303d3fad5b20109834717bac4e7762e217add183d0c4852ab054f65ba6e93b1ed83ca5c5fa614cd3b810f4766c66feb\"), context.getPreMasterSecret());\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"FA1D499E795E936751AD43355C26857728E78ABE1C4BCAFA6EF3C90F6D9B9E49DF1ADE262F127EB2A23BB73E142EE122\"), context.getMasterSecret());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ChangeCipherSpecHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class changecipherspechandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof ChangeCipherSpecParser);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeCipherSuiteActionTest.testExecute",
	"Comment": "test of execute method, of class changeciphersuiteaction.",
	"Method": "void testExecute(){\r\n    action.execute(state);\r\n    assertEquals(tlsContext.getSelectedCipherSuite(), action.getNewValue());\r\n    assertTrue(action.isExecuted());\r\n}"
}, {
	"Path": "org.togglz.core.repository.composite.CompositeStateRepository.setSetterSelection",
	"Comment": "sets the selector for which state repositories to call to set a feature state.if not set the defaultis the last repository in this composite.",
	"Method": "void setSetterSelection(RepositorySelector setterSelection){\r\n    this.setterSelection = setterSelection;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.occlusion.meshing.TangoMesher.release",
	"Comment": "synchronize access to mtango3dreconstruction. this runs in ui thread.",
	"Method": "void release(){\r\n    mIsReconstructionActive = false;\r\n    mTango3dReconstruction.release();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.CompressionDelegateTest.testGetCompressionMethods",
	"Comment": "test of getcompressionmethods method, of class compressiondelegate.",
	"Method": "void testGetCompressionMethods(){\r\n    args = new String[2];\r\n    args[0] = \"-compression\";\r\n    args[1] = \"NULL,DEFLATE\";\r\n    jcommander.parse(args);\r\n    assertTrue(\"NULL should get parsed correctly\", delegate.getCompressionMethods().contains(CompressionMethod.NULL));\r\n    assertTrue(\"DEFLATE should get parsed correctly\", delegate.getCompressionMethods().contains(CompressionMethod.DEFLATE));\r\n}"
}, {
	"Path": "com.diffplug.spotless.TestProvisioner.snapshots",
	"Comment": "creates a provisioner for the sonatype snapshots maven repo for development purpose.",
	"Method": "Provisioner snapshots(){\r\n    return snapshots.get();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.PskDhClientKeyExchangeParser.parsePskIdentityLength",
	"Comment": "reads the next bytes as the pskidentitylength and writes them in themessage",
	"Method": "void parsePskIdentityLength(PskDhClientKeyExchangeMessage msg){\r\n    msg.setIdentityLength(parseIntField(HandshakeByteLength.PSK_IDENTITY_LENGTH));\r\n    LOGGER.debug(\"PSK-IdentityLength: \" + msg.getIdentityLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.extension.ServerNameIndicationExtensionPreparatorTest.testPrepareExtensionContentWithOnePair",
	"Comment": "test of prepareextensioncontent method, of classservernameindicationextensionpreparator.",
	"Method": "void testPrepareExtensionContentWithOnePair(){\r\n    List<ServerNamePair> pairList = new LinkedList();\r\n    ServerNamePair pair = new ServerNamePair();\r\n    pair.setServerNameConfig(new byte[] { 0x01, 0x02 });\r\n    pair.setServerNameTypeConfig((byte) 1);\r\n    pair.setServerNameLength(2);\r\n    pairList.add(pair);\r\n    message.setServerNameList(pairList);\r\n    ServerNameIndicationExtensionPreparator serverprep = new ServerNameIndicationExtensionPreparator(chooser, message, serializer);\r\n    serverprep.prepareExtensionContent();\r\n    assertArrayEquals(new byte[] { 0x01, 0x00, 0x02, 0x01, 0x02 }, serverprep.getObject().getServerNameListBytes().getValue());\r\n    assertEquals(5, (long) serverprep.getObject().getServerNameListLength().getOriginalValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetLastRecordVersion",
	"Comment": "test of getlastrecordversion method, of class defaultchooser.",
	"Method": "void testGetLastRecordVersion(){\r\n    config.setDefaultLastRecordProtocolVersion(ProtocolVersion.TLS13_DRAFT20);\r\n    assertEquals(ProtocolVersion.TLS13_DRAFT20, config.getDefaultLastRecordProtocolVersion());\r\n    assertEquals(ProtocolVersion.TLS13_DRAFT20, chooser.getLastRecordVersion());\r\n    context.setLastRecordVersion(ProtocolVersion.SSL2);\r\n    assertEquals(ProtocolVersion.SSL2, context.getLastRecordVersion());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.setupTangoConfig",
	"Comment": "sets up the tango configuration object. make sure mtango object is initialized beforemaking this call.",
	"Method": "TangoConfig setupTangoConfig(Tango tango){\r\n    TangoConfig config = tango.getConfig(TangoConfig.CONFIG_TYPE_DEFAULT);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_LOWLATENCYIMUINTEGRATION, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_COLORCAMERA, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_DEPTH, true);\r\n    config.putInt(TangoConfig.KEY_INT_DEPTH_MODE, TangoConfig.TANGO_DEPTH_MODE_POINT_CLOUD);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_DRIFT_CORRECTION, true);\r\n    return config;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.occlusion.OcclusionRenderer.updateVPMatrix",
	"Comment": "composes the view and projection matrices into a single vp matrix.",
	"Method": "void updateVPMatrix(){\r\n    Matrix.setIdentityM(mVPMatrix, 0);\r\n    Matrix.multiplyMM(mVPMatrix, 0, mProjectionMatrix, 0, mViewMatrix, 0);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetDhClientPrivateKey",
	"Comment": "test of getdhclientprivatekey method, of class defaultchooser.",
	"Method": "void testGetDhClientPrivateKey(){\r\n    context.setClientDhPrivateKey(null);\r\n    config.setDefaultClientDhPrivateKey(BigInteger.ONE);\r\n    assertEquals(BigInteger.ONE, config.getDefaultClientDhPrivateKey());\r\n    assertEquals(BigInteger.ONE, chooser.getDhClientPrivateKey());\r\n    context.setClientDhPrivateKey(BigInteger.TEN);\r\n    assertEquals(BigInteger.TEN, chooser.getDhClientPrivateKey());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.KeyShareExtensionHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class keyshareextensionhandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new KeyShareExtensionMessage(ExtensionType.KEY_SHARE)) instanceof KeyShareExtensionSerializer);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.startRotationAnimation",
	"Comment": "animate rotation value to show the next point of the model to make the correspondence.",
	"Method": "void startRotationAnimation(float start,float end){\r\n    if (mZRotationAnimator != null) {\r\n        mZRotationAnimator.cancel();\r\n    }\r\n    mZRotationAnimator = ValueAnimator.ofFloat(start, end);\r\n    mZRotationAnimator.setDuration(1500);\r\n    mZRotationAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\r\n        public void onAnimationUpdate(ValueAnimator animation) {\r\n            Float value = (Float) animation.getAnimatedValue();\r\n            mModelZRotation = value;\r\n        }\r\n    });\r\n    mZRotationAnimator.start();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.startRotationAnimation",
	"Comment": "animate rotation value to show the next point of the model to make the correspondence.",
	"Method": "void startRotationAnimation(float start,float end){\r\n    Float value = (Float) animation.getAnimatedValue();\r\n    mModelZRotation = value;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeCompressionActionTest.testGetNewValue",
	"Comment": "test of getnewvalue method, of class changecompressionaction.",
	"Method": "void testGetNewValue(){\r\n    assertEquals(action.getNewValue(), CompressionMethod.LZS);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ProtocolMessageHandler.parseMessage",
	"Comment": "parses a bytearray from a position into a messageobject and returns theparsed messageobjet and parser position in a parser result. the currentchooser is adjusted as",
	"Method": "ParserResult parseMessage(byte[] message,int pointer){\r\n    Parser<Message> parser = getParser(message, pointer);\r\n    Message parsedMessage = parser.parse();\r\n    try {\r\n        prepareAfterParse(parsedMessage);\r\n        if (parsedMessage instanceof HandshakeMessage) {\r\n            if (((HandshakeMessage) parsedMessage).getIncludeInDigest()) {\r\n                tlsContext.getDigest().append(parsedMessage.getCompleteResultingMessage().getValue());\r\n            }\r\n        }\r\n        adjustTLSContext(parsedMessage);\r\n    } catch (AdjustmentException | UnsupportedOperationException E) {\r\n        LOGGER.warn(\"Could not adjust TLSContext\");\r\n        LOGGER.debug(E);\r\n    }\r\n    return new ParserResult(parsedMessage, parser.getPointer());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.occlusion.OcclusionActivity.crossProduct",
	"Comment": "cross product between two vectors following the right hand rule.",
	"Method": "float[] crossProduct(float[] v1,float[] v2){\r\n    float[] result = new float[3];\r\n    result[0] = v1[1] * v2[2] - v2[1] * v1[2];\r\n    result[1] = v1[2] * v2[0] - v2[2] * v1[0];\r\n    result[2] = v1[0] * v2[1] - v2[0] * v1[1];\r\n    return result;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.DHEServerKeyExchangeParser.parsepLength",
	"Comment": "reads the next bytes as the plength and writes them in the message",
	"Method": "void parsepLength(DHEServerKeyExchangeMessage msg){\r\n    msg.setModulusLength(parseIntField(HandshakeByteLength.DH_MODULUS_LENGTH));\r\n    LOGGER.debug(\"pLength: \" + msg.getModulusLength().getValue());\r\n}"
}, {
	"Path": "org.takes.rs.RsVelocityTest.useTemplateFolder",
	"Comment": "rsvelocity should use template folder to load macros in different files.",
	"Method": "void useTemplateFolder(){\r\n    MatcherAssert.assertThat(IOUtils.toString(new RsVelocity(RsVelocityTest.class.getResource(\"/vtl\").getPath(), RsVelocityTest.class.getResourceAsStream(\"/vtl/simple.vm\"), new HashMap<CharSequence, Object>()).body(), StandardCharsets.UTF_8), Matchers.equalTo(\"Hello World!\\n\"));\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n    ArrayList<TangoCoordinateFramePair> framePairs = new ArrayList<TangoCoordinateFramePair>();\r\n    mTango.connectListener(framePairs, new OnTangoUpdateListener() {\r\n        @Override\r\n        public void onPoseAvailable(TangoPoseData pose) {\r\n        }\r\n        @Override\r\n        public void onXyzIjAvailable(TangoXyzIjData xyzIj) {\r\n        }\r\n        @Override\r\n        public void onPointCloudAvailable(TangoPointCloudData pointCloud) {\r\n        }\r\n        @Override\r\n        public void onTangoEvent(TangoEvent event) {\r\n        }\r\n        @Override\r\n        public void onFrameAvailable(int cameraId) {\r\n            if (cameraId == TangoCameraIntrinsics.TANGO_CAMERA_COLOR) {\r\n                if (mSurfaceView.getRenderMode() != GLSurfaceView.RENDERMODE_WHEN_DIRTY) {\r\n                    mSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\r\n                }\r\n                mIsFrameAvailableTangoThread.set(true);\r\n                mSurfaceView.requestRender();\r\n            }\r\n        }\r\n    });\r\n    mTango.experimentalConnectOnFrameListener(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, new Tango.OnFrameAvailableListener() {\r\n        @Override\r\n        public void onFrameAvailable(TangoImageBuffer tangoImageBuffer, int i) {\r\n            mCurrentImageBuffer = copyImageBuffer(tangoImageBuffer);\r\n            detectMarkers();\r\n        }\r\n        TangoImageBuffer copyImageBuffer(TangoImageBuffer imageBuffer) {\r\n            ByteBuffer clone = ByteBuffer.allocateDirect(imageBuffer.data.capacity());\r\n            imageBuffer.data.rewind();\r\n            clone.put(imageBuffer.data);\r\n            imageBuffer.data.rewind();\r\n            clone.flip();\r\n            return new TangoImageBuffer(imageBuffer.width, imageBuffer.height, imageBuffer.stride, imageBuffer.frameNumber, imageBuffer.timestamp, imageBuffer.format, clone, imageBuffer.exposureDurationNs);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n    if (cameraId == TangoCameraIntrinsics.TANGO_CAMERA_COLOR) {\r\n        if (mSurfaceView.getRenderMode() != GLSurfaceView.RENDERMODE_WHEN_DIRTY) {\r\n            mSurfaceView.setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\r\n        }\r\n        mIsFrameAvailableTangoThread.set(true);\r\n        mSurfaceView.requestRender();\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n    mCurrentImageBuffer = copyImageBuffer(tangoImageBuffer);\r\n    detectMarkers();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera.",
	"Method": "void startupTango(){\r\n    ByteBuffer clone = ByteBuffer.allocateDirect(imageBuffer.data.capacity());\r\n    imageBuffer.data.rewind();\r\n    clone.put(imageBuffer.data);\r\n    imageBuffer.data.rewind();\r\n    clone.flip();\r\n    return new TangoImageBuffer(imageBuffer.width, imageBuffer.height, imageBuffer.stride, imageBuffer.frameNumber, imageBuffer.timestamp, imageBuffer.format, clone, imageBuffer.exposureDurationNs);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    final AlertDialog dialog = new AlertDialog.Builder(this).setMessage(\"Java Point to point Example requires camera permission\").setPositiveButton(\"Ok\", new DialogInterface.OnClickListener() {\r\n        @Override\r\n        public void onClick(DialogInterface dialogInterface, int i) {\r\n            ActivityCompat.requestPermissions(PointToPointActivity.this, new String[] { CAMERA_PERMISSION }, CAMERA_PERMISSION_CODE);\r\n        }\r\n    }).create();\r\n    dialog.show();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    ActivityCompat.requestPermissions(PointToPointActivity.this, new String[] { CAMERA_PERMISSION }, CAMERA_PERMISSION_CODE);\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.eclipse.base.osgi.BundleSet.get",
	"Comment": "get bundle by its id or null if collection does not contain the corresponding bundle.",
	"Method": "Bundle get(String symbolicName,Bundle get,long id){\r\n    return id2bundle.get(id);\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.util.LoadLibs.copyJarResourceToPath",
	"Comment": "copies resources from the jar file of the current thread and extract itto the destination path.",
	"Method": "void copyJarResourceToPath(JarURLConnection jarConnection,File destPath){\r\n    try (JarFile jarFile = jarConnection.getJarFile()) {\r\n        String jarConnectionEntryName = jarConnection.getEntryName();\r\n        if (!jarConnectionEntryName.endsWith(\"/\")) {\r\n            jarConnectionEntryName += \"/\";\r\n        }\r\n        for (Enumeration<JarEntry> e = jarFile.entries(); e.hasMoreElements(); ) {\r\n            JarEntry jarEntry = e.nextElement();\r\n            String jarEntryName = jarEntry.getName();\r\n            if (jarEntryName.startsWith(jarConnectionEntryName)) {\r\n                String filename = jarEntryName.substring(jarConnectionEntryName.length());\r\n                File targetFile = new File(destPath, filename);\r\n                if (jarEntry.isDirectory()) {\r\n                    targetFile.mkdirs();\r\n                } else {\r\n                    if (!targetFile.exists() || targetFile.length() != jarEntry.getSize()) {\r\n                        try (InputStream is = jarFile.getInputStream(jarEntry);\r\n                            OutputStream out = FileUtils.openOutputStream(targetFile)) {\r\n                            IOUtils.copy(is, out);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        logger.warn(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.distance.DistanceUtils.calcBoxByDistFromPtDEG",
	"Comment": "calculates the bounding box of a circle, as specified by its center pointand distance.reuse is an optional argument to store theresults to avoid object creation.",
	"Method": "Rectangle calcBoxByDistFromPtDEG(double lat,double lon,double distDEG,SpatialContext ctx,Rectangle reuse){\r\n    double minX;\r\n    double maxX;\r\n    double minY;\r\n    double maxY;\r\n    if (distDEG == 0) {\r\n        minX = lon;\r\n        maxX = lon;\r\n        minY = lat;\r\n        maxY = lat;\r\n    } else if (distDEG >= 180) {\r\n        minX = -180;\r\n        maxX = 180;\r\n        minY = -90;\r\n        maxY = 90;\r\n    } else {\r\n        maxY = lat + distDEG;\r\n        minY = lat - distDEG;\r\n        if (maxY >= 90 || minY <= -90) {\r\n            minX = -180;\r\n            maxX = 180;\r\n            if (maxY <= 90 && minY >= -90) {\r\n                minX = normLonDEG(lon - 90);\r\n                maxX = normLonDEG(lon + 90);\r\n            }\r\n            if (maxY > 90)\r\n                maxY = 90;\r\n            if (minY < -90)\r\n                minY = -90;\r\n        } else {\r\n            double lon_delta_deg = calcBoxByDistFromPt_deltaLonDEG(lat, lon, distDEG);\r\n            minX = normLonDEG(lon - lon_delta_deg);\r\n            maxX = normLonDEG(lon + lon_delta_deg);\r\n        }\r\n    }\r\n    if (reuse == null) {\r\n        return ctx.makeRectangle(minX, maxX, minY, maxY);\r\n    } else {\r\n        reuse.reset(minX, maxX, minY, maxY);\r\n        return reuse;\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.CertificateMessageSerializerTest.testSerializeHandshakeMessageContent",
	"Comment": "test of serializehandshakemessagecontent method, of classcertificatemessageserializer.",
	"Method": "void testSerializeHandshakeMessageContent(){\r\n    CertificateMessage message = new CertificateMessage();\r\n    message.setCertificatesListLength(certificatesLength);\r\n    message.setCertificatesListBytes(certificateBytes);\r\n    message.setLength(length);\r\n    message.setType(type.getValue());\r\n    CertificateMessageSerializer serializer = new CertificateMessageSerializer(message, version);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskRsaClientKeyExchangeHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class pskrsaclientkeyexchangehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new PskRsaClientKeyExchangeMessage()) instanceof PskRsaClientKeyExchangePreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.WorkflowTraceTest.testGetReceiveActions",
	"Comment": "test of getreceiveactions method, of class workflowtrace.",
	"Method": "void testGetReceiveActions(){\r\n    trace.addTlsAction(new SendAction());\r\n    trace.addTlsAction(new ReceiveAction());\r\n    trace.addTlsAction(new ChangeClientRandomAction());\r\n    assertTrue(trace.getReceivingActions().size() == 1);\r\n    assertEquals(trace.getReceivingActions().get(0), new ReceiveAction());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    final AlertDialog dialog = new AlertDialog.Builder(this).setMessage(\"Java Plane Fitting Example requires camera permission\").setPositiveButton(\"Ok\", new DialogInterface.OnClickListener() {\r\n        @Override\r\n        public void onClick(DialogInterface dialogInterface, int i) {\r\n            ActivityCompat.requestPermissions(PlaneFittingActivity.this, new String[] { CAMERA_PERMISSION }, CAMERA_PERMISSION_CODE);\r\n        }\r\n    }).create();\r\n    dialog.show();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    ActivityCompat.requestPermissions(PlaneFittingActivity.this, new String[] { CAMERA_PERMISSION }, CAMERA_PERMISSION_CODE);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.motiontracking.MotionTrackingActivity.setupTangoConfig",
	"Comment": "sets up the tango configuration object. make sure mtango object is initialized beforemaking this call.",
	"Method": "TangoConfig setupTangoConfig(Tango tango){\r\n    TangoConfig config = tango.getConfig(TangoConfig.CONFIG_TYPE_DEFAULT);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_MOTIONTRACKING, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_AUTORECOVERY, true);\r\n    return config;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.HeartbeatMessageHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class heartbeatmessagehandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new HeartbeatMessage()) instanceof HeartbeatMessageSerializer);\r\n}"
}, {
	"Path": "com.diffplug.gradle.spotless.SpotlessExtension.kotlinGradle",
	"Comment": "configures the special gradle kotlin dsl specific extension.",
	"Method": "void kotlinGradle(Action<KotlinGradleExtension> closure){\r\n    requireNonNull(closure);\r\n    configure(KotlinGradleExtension.NAME, KotlinGradleExtension.class, closure);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.ProtocolVersionDelegateTest.testApplyDelegate",
	"Comment": "test of applydelegate method, of class protocolversiondelegate.",
	"Method": "void testApplyDelegate(){\r\n    Config config = Config.createConfig();\r\n    config.setHighestProtocolVersion(ProtocolVersion.SSL2);\r\n    config.getDefaultClientConnection().setTransportHandlerType(TransportHandlerType.EAP_TLS);\r\n    config.getDefaultServerConnection().setTransportHandlerType(TransportHandlerType.EAP_TLS);\r\n    args = new String[2];\r\n    args[0] = \"-version\";\r\n    args[1] = \"TLS12\";\r\n    assertThat(config.getHighestProtocolVersion(), equalTo(ProtocolVersion.SSL2));\r\n    assertThat(config.getDefaultClientConnection().getTransportHandlerType(), equalTo(TransportHandlerType.EAP_TLS));\r\n    assertThat(config.getDefaultServerConnection().getTransportHandlerType(), equalTo(TransportHandlerType.EAP_TLS));\r\n    jcommander.parse(args);\r\n    delegate.applyDelegate(config);\r\n    assertThat(config.getHighestProtocolVersion(), equalTo(ProtocolVersion.TLS12));\r\n    assertThat(config.getDefaultClientConnection().getTransportHandlerType(), equalTo(TransportHandlerType.TCP));\r\n    assertThat(config.getDefaultServerConnection().getTransportHandlerType(), equalTo(TransportHandlerType.TCP));\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.eclipse.base.SpotlessEclipseServiceConfig.hideEnvironment",
	"Comment": "spotless formatters should not be configured by environment variables, and\tthey shall be os independent.",
	"Method": "void hideEnvironment(){\r\n    add(EnvironmentInfo.class, new HiddenEnvironment());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.SupplementalDataMessageTest.testToString",
	"Comment": "test of tostring method, of class supplementaldatamessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"SupplementalDataMessage:\");\r\n    sb.append(\"\\n  Supplemental Data Length: \").append(\"null\");\r\n    sb.append(\"\\n  SupplementalDataEntries:\\n\").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "org.takes.rs.RsPrettyXmlTest.formatsHtml5ForLegacyBrowsersDoctypeBody",
	"Comment": "rsprettyxml can format html5 markup with doctype forlegacy browser support.",
	"Method": "void formatsHtml5ForLegacyBrowsersDoctypeBody(){\r\n    MatcherAssert.assertThat(new RsPrint(new RsPrettyXml(new RsWithBody(Joiner.on(\"\").appendTo(new StringBuilder(\"<!DOCTYPE html \"), \"SYSTEM \\\"about:legacy-compat\\\">\", \"<html><head><\/head><body><\/body><\/html>\").toString()))).printBody(), Matchers.is(Joiner.on(\"\").appendTo(new StringBuilder(\"<!DOCTYPE html\\n\"), \"  SYSTEM \\\"about:legacy-compat\\\">\\n\", \"<html>\\n\", \"   <head>\\n\", \"      <meta http-equiv=\\\"Content-Type\\\"\", \" content=\\\"text/html; charset=UTF-8\\\">\\n\", \"   <\/head>\\n\", \"   <body><\/body>\\n\", \"<\/html>\").toString()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ClientHelloParser.parseCipherSuiteLength",
	"Comment": "reads the next bytes as the ciphersuitelength and writes them in themessage",
	"Method": "void parseCipherSuiteLength(SSL2ClientHelloMessage msg){\r\n    msg.setCipherSuiteLength(parseIntField(SSL2ByteLength.CIPHERSUITE_LENGTH));\r\n    LOGGER.debug(\"CipherSuiteLength: \" + msg.getCipherSuiteLength().getValue());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.setupTangoConfig",
	"Comment": "sets up the tango configuration object. make sure mtango object is initialized beforemaking this call.",
	"Method": "TangoConfig setupTangoConfig(Tango tango){\r\n    TangoConfig config = tango.getConfig(TangoConfig.CONFIG_TYPE_DEFAULT);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_LOWLATENCYIMUINTEGRATION, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_COLORCAMERA, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_DEPTH, true);\r\n    config.putInt(TangoConfig.KEY_INT_DEPTH_MODE, TangoConfig.TANGO_DEPTH_MODE_POINT_CLOUD);\r\n    return config;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ECDHEServerKeyExchangeHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class ecdheserverkeyexchangehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new ECDHEServerKeyExchangeMessage()) instanceof ECDHEServerKeyExchangePreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.PskClientKeyExchangeParser.parsePskIdentity",
	"Comment": "reads the next bytes as the pskidentity and writes them in the message",
	"Method": "void parsePskIdentity(PskClientKeyExchangeMessage msg){\r\n    msg.setIdentity(parseByteArrayField(msg.getIdentityLength().getValue()));\r\n    LOGGER.debug(\"PskIdentity: \" + ArrayConverter.bytesToHexString(msg.getIdentity().getValue()));\r\n}"
}, {
	"Path": "org.takes.http.FtBasicTest.consumesTwiceInputStreamWithRsHtml",
	"Comment": "ftbasic can consume twice the input stream in case of a rshtml.",
	"Method": "void consumesTwiceInputStreamWithRsHtml(){\r\n    final String result = \"Hello RsHTML!\";\r\n    new FtRemote(new TkFork(new FkRegex(FtBasicTest.ROOT_PATH, new RsHtml(new ByteArrayInputStream(new Utf8String(result).bytes()))))).exec(new FtRemote.Script() {\r\n        @Override\r\n        public void exec(final URI home) throws IOException {\r\n            new JdkRequest(home).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertBody(Matchers.equalTo(result));\r\n            new JdkRequest(home).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertBody(Matchers.equalTo(result));\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.takes.http.FtBasicTest.consumesTwiceInputStreamWithRsHtml",
	"Comment": "ftbasic can consume twice the input stream in case of a rshtml.",
	"Method": "void consumesTwiceInputStreamWithRsHtml(){\r\n    new JdkRequest(home).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertBody(Matchers.equalTo(result));\r\n    new JdkRequest(home).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertBody(Matchers.equalTo(result));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.DHEServerKeyExchangeParserTest.testParse",
	"Comment": "test of parse method, of class dheserverkeyexchangeparser.",
	"Method": "void testParse(){\r\n    DHEServerKeyExchangeParser<DHEServerKeyExchangeMessage> parser = new DHEServerKeyExchangeParser(0, message, version);\r\n    DHEServerKeyExchangeMessage msg = parser.parse();\r\n    assertArrayEquals(message, msg.getCompleteResultingMessage().getValue());\r\n    assertTrue(msg.getLength().getValue() == length);\r\n    assertTrue(msg.getType().getValue() == type.getValue());\r\n    assertTrue(serializedKeyLength == msg.getPublicKeyLength().getValue());\r\n    assertArrayEquals(serializedKey, msg.getPublicKey().getValue());\r\n    byte[] tempSignatureAndHashAlgo = null;\r\n    if (msg.getSignatureAndHashAlgorithm() != null && msg.getSignatureAndHashAlgorithm().getValue() != null) {\r\n        tempSignatureAndHashAlgo = msg.getSignatureAndHashAlgorithm().getValue();\r\n    }\r\n    assertArrayEquals(signatureAndHashAlgo, tempSignatureAndHashAlgo);\r\n    assertTrue(sigLength == msg.getSignatureLength().getValue());\r\n    assertArrayEquals(signature, msg.getSignature().getValue());\r\n}"
}, {
	"Path": "com.projecttango.rajawali.renderables.Trajectory.addSegmentTo",
	"Comment": "update the geometry of the trajectory once new vertex is available.",
	"Method": "void addSegmentTo(Vector3 vertex){\r\n    mVertexBuffer.position(mTrajectoryCount * 3);\r\n    mVertexBuffer.put((float) vertex.x);\r\n    mVertexBuffer.put((float) vertex.y);\r\n    mVertexBuffer.put((float) vertex.z);\r\n    mTrajectoryCount++;\r\n    mLastPoint = vertex.clone();\r\n    mGeometry.setNumIndices(mTrajectoryCount);\r\n    mGeometry.getVertices().position(0);\r\n    mGeometry.changeBufferData(mGeometry.getVertexBufferInfo(), mVertexBuffer, 0, mTrajectoryCount * 3);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.HeartbeatDelegateTest.testGetHeartbeatMode",
	"Comment": "test of getheartbeatmode method, of class heartbeatdelegate.",
	"Method": "void testGetHeartbeatMode(){\r\n    args = new String[2];\r\n    args[0] = \"-heartbeat_mode\";\r\n    args[1] = \"PEER_ALLOWED_TO_SEND\";\r\n    delegate.setHeartbeatMode(null);\r\n    jcommander.parse(args);\r\n    assertTrue(delegate.getHeartbeatMode() == HeartbeatMode.PEER_ALLOWED_TO_SEND);\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.filtering.regex.RegexURLNormalizer.filter",
	"Comment": "this function does the replacements by iterating through all the regexpatterns. it accepts a string url as input and returns the alteredstring. if the normalized url is an empty string, the function willreturn null.",
	"Method": "String filter(URL sourceUrl,Metadata sourceMetadata,String urlString){\r\n    Iterator<Rule> i = rules.iterator();\r\n    while (i.hasNext()) {\r\n        Rule r = i.next();\r\n        Matcher matcher = r.pattern.matcher(urlString);\r\n        urlString = matcher.replaceAll(r.substitution);\r\n    }\r\n    if (urlString.equals(\"\")) {\r\n        urlString = null;\r\n    }\r\n    return urlString;\r\n}"
}, {
	"Path": "org.takes.rq.RqWithDefaultHeader.build",
	"Comment": "builds the request with the default header if it is not already present.",
	"Method": "Request build(Request req,String hdr,String val){\r\n    final Request request;\r\n    if (new RqHeaders.Base(req).header(hdr).iterator().hasNext()) {\r\n        request = req;\r\n    } else {\r\n        request = new RqWithHeader(req, hdr, val);\r\n    }\r\n    return request;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.CertificateDelegateTest.testSetKeystore",
	"Comment": "test of setkeystore method, of class certificatedelegate.",
	"Method": "void testSetKeystore(){\r\n    delegate.setKeystore(\"testKey\");\r\n    assertTrue(\"Keystore setter is not working correctly\", delegate.getKeystore().equals(\"testKey\"));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ClientHelloParser.parseCipherSuites",
	"Comment": "reads the next bytes as the ciphersuites and writes them in the message",
	"Method": "void parseCipherSuites(SSL2ClientHelloMessage msg){\r\n    msg.setCipherSuites(parseByteArrayField(msg.getCipherSuiteLength().getValue()));\r\n    LOGGER.debug(\"ChipherSuites: \" + ArrayConverter.bytesToHexString(msg.getCipherSuites().getValue()));\r\n}"
}, {
	"Path": "org.springframework.statemachine.support.ExpressionUtils.createStandardEvaluationContext",
	"Comment": "used to create a context with no beanfactory, usually in tests.",
	"Method": "StandardEvaluationContext createStandardEvaluationContext(ConversionService conversionService,BeanFactory beanFactory,StandardEvaluationContext createStandardEvaluationContext,StandardEvaluationContext createStandardEvaluationContext,BeanFactory beanFactory){\r\n    if (beanFactory == null) {\r\n        logger.warn(\"Creating EvaluationContext with no beanFactory\", new RuntimeException(\"No beanfactory\"));\r\n    }\r\n    return doCreateContext(beanFactory);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ServerHelloParser.parseCertificate",
	"Comment": "reads the next bytes as the certificate and writes them in the message",
	"Method": "void parseCertificate(SSL2ServerHelloMessage message){\r\n    message.setCertificate(parseByteArrayField(message.getCertificateLength().getValue()));\r\n    LOGGER.debug(\"Certificate: \" + ArrayConverter.bytesToHexString(message.getCertificate().getValue()));\r\n}"
}, {
	"Path": "com.android.vending.billing.util.IabHelper.getResponseCodeFromBundle",
	"Comment": "workaround to bug where sometimes response codes come as long instead of integer",
	"Method": "int getResponseCodeFromBundle(Bundle b){\r\n    Object o = b.get(RESPONSE_CODE);\r\n    if (o == null) {\r\n        logDebug(\"Bundle with null response code, assuming OK (known issue)\");\r\n        return BILLING_RESPONSE_RESULT_OK;\r\n    } else if (o instanceof Integer)\r\n        return ((Integer) o).intValue();\r\n    else if (o instanceof Long)\r\n        return (int) ((Long) o).longValue();\r\n    else {\r\n        logError(\"Unexpected type for bundle response code.\");\r\n        logError(o.getClass().getName());\r\n        throw new RuntimeException(\"Unexpected type for bundle response code: \" + o.getClass().getName());\r\n    }\r\n}"
}, {
	"Path": "com.diffplug.spotless.FileSignature.signAsList",
	"Comment": "creates file signature whereas order of the files remains unchanged.",
	"Method": "FileSignature signAsList(File files,FileSignature signAsList,Iterable<File> files){\r\n    return new FileSignature(toNullHostileList(files));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.DHEServerKeyExchangeHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class dheserverkeyexchangehandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new DHEServerKeyExchangeMessage()) instanceof DHEServerKeyExchangeSerializer);\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.ConfigurableTopology.submit",
	"Comment": "submits the topology with the name taken from the configuration",
	"Method": "int submit(Config conf,TopologyBuilder builder,int submit,String name,Config conf,TopologyBuilder builder){\r\n    Config.registerSerialization(conf, Metadata.class);\r\n    if (isLocal) {\r\n        LocalCluster cluster = new LocalCluster();\r\n        cluster.submitTopology(name, conf, builder.createTopology());\r\n        if (ttl != -1) {\r\n            Utils.sleep(ttl * 1000);\r\n            cluster.shutdown();\r\n        }\r\n    } else {\r\n        try {\r\n            StormSubmitter.submitTopology(name, conf, builder.createTopology());\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            return -1;\r\n        }\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.DHClientKeyExchangeHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class dhclientkeyexchangehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new DHClientKeyExchangeMessage()) instanceof DHClientKeyExchangePreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskEcDheServerKeyExchangeHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class pskecdheserverkeyexchangehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new PskEcDheServerKeyExchangeMessage()) instanceof PskEcDheServerKeyExchangePreparator);\r\n}"
}, {
	"Path": "org.springframework.data.neo4j.mapping.Neo4jPersistentProperty.usePropertyAccess",
	"Comment": "overridden to force field access as opposed to getter method access for simplicity.",
	"Method": "boolean usePropertyAccess(){\r\n    logger.debug(\"[property].usePropertyAccess() returns false\");\r\n    return false;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.HandshakeMessageParser.parseExtensionBytes",
	"Comment": "reads the next bytes as the extensionbytes and writes them in the messageand adds parsed extensions to the message",
	"Method": "void parseExtensionBytes(T message){\r\n    byte[] extensionBytes = parseByteArrayField(message.getExtensionsLength().getValue());\r\n    message.setExtensionBytes(extensionBytes);\r\n    LOGGER.debug(\"ExtensionBytes:\" + ArrayConverter.bytesToHexString(extensionBytes, false));\r\n    List<ExtensionMessage> extensionMessages = new LinkedList();\r\n    int pointer = 0;\r\n    while (pointer < extensionBytes.length) {\r\n        ExtensionParser parser = ExtensionParserFactory.getExtensionParser(extensionBytes, pointer, message.getHandshakeMessageType());\r\n        extensionMessages.add(parser.parse());\r\n        if (pointer == parser.getPointer()) {\r\n            throw new ParserException(\"Ran into infinite Loop while parsing Extensions\");\r\n        }\r\n        pointer = parser.getPointer();\r\n    }\r\n    message.setExtensions(extensionMessages);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.HandshakeMessageParser.parseType",
	"Comment": "reads the next bytes as a handshakemessagetype and writes them in themessage",
	"Method": "void parseType(HandshakeMessage message){\r\n    message.setType(parseByteField(HandshakeByteLength.MESSAGE_TYPE));\r\n    if (message.getType().getValue() != expectedType.getValue() && expectedType != HandshakeMessageType.UNKNOWN) {\r\n        LOGGER.warn(\"Parsed wrong message type. Parsed:\" + message.getType().getValue() + \" but expected:\" + expectedType.getValue());\r\n    }\r\n    LOGGER.debug(\"Type:\" + message.getType().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskClientKeyExchangeHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class pskclientkeyexchangehandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new PskClientKeyExchangeMessage()) instanceof PskClientKeyExchangeSerializer);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n    ArrayList<TangoCoordinateFramePair> framePairs = new ArrayList<TangoCoordinateFramePair>();\r\n    mTango.connectListener(framePairs, new OnTangoUpdateListener() {\r\n        @Override\r\n        public void onPoseAvailable(TangoPoseData pose) {\r\n        }\r\n        @Override\r\n        public void onFrameAvailable(int cameraId) {\r\n            if (cameraId == TangoCameraIntrinsics.TANGO_CAMERA_COLOR) {\r\n                mIsFrameAvailableTangoThread.set(true);\r\n                mSurfaceView.requestRender();\r\n            }\r\n        }\r\n        @Override\r\n        public void onXyzIjAvailable(TangoXyzIjData xyzIj) {\r\n        }\r\n        @Override\r\n        public void onPointCloudAvailable(TangoPointCloudData pointCloud) {\r\n            mPointCloudManager.updatePointCloud(pointCloud);\r\n        }\r\n        @Override\r\n        public void onTangoEvent(TangoEvent event) {\r\n        }\r\n    });\r\n    mTango.experimentalConnectOnFrameListener(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, new Tango.OnFrameAvailableListener() {\r\n        @Override\r\n        public void onFrameAvailable(TangoImageBuffer tangoImageBuffer, int i) {\r\n            mCurrentImageBuffer = copyImageBuffer(tangoImageBuffer);\r\n        }\r\n        TangoImageBuffer copyImageBuffer(TangoImageBuffer imageBuffer) {\r\n            ByteBuffer clone = ByteBuffer.allocateDirect(imageBuffer.data.capacity());\r\n            imageBuffer.data.rewind();\r\n            clone.put(imageBuffer.data);\r\n            imageBuffer.data.rewind();\r\n            clone.flip();\r\n            return new TangoImageBuffer(imageBuffer.width, imageBuffer.height, imageBuffer.stride, imageBuffer.frameNumber, imageBuffer.timestamp, imageBuffer.format, clone, imageBuffer.exposureDurationNs);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n    if (cameraId == TangoCameraIntrinsics.TANGO_CAMERA_COLOR) {\r\n        mIsFrameAvailableTangoThread.set(true);\r\n        mSurfaceView.requestRender();\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n    mPointCloudManager.updatePointCloud(pointCloud);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n    mCurrentImageBuffer = copyImageBuffer(tangoImageBuffer);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the rgb camera and point cloud.",
	"Method": "void startupTango(){\r\n    ByteBuffer clone = ByteBuffer.allocateDirect(imageBuffer.data.capacity());\r\n    imageBuffer.data.rewind();\r\n    clone.put(imageBuffer.data);\r\n    imageBuffer.data.rewind();\r\n    clone.flip();\r\n    return new TangoImageBuffer(imageBuffer.width, imageBuffer.height, imageBuffer.stride, imageBuffer.frameNumber, imageBuffer.timestamp, imageBuffer.format, clone, imageBuffer.exposureDurationNs);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.CertificateMessageParser.parseRequestContextBytes",
	"Comment": "reads the next bytes as the requestcontextbytes and writes them in themessage",
	"Method": "void parseRequestContextBytes(CertificateMessage msg){\r\n    msg.setRequestContext(parseByteArrayField(msg.getRequestContextLength().getValue()));\r\n    LOGGER.debug(\"RequestContextBytes: \" + ArrayConverter.bytesToHexString(msg.getRequestContext()));\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camera and callbacks.",
	"Method": "void connectRenderer(){\r\n    mSurfaceView.setEGLContextClientVersion(2);\r\n    mRenderer = new MeshBuilderRenderer(new MeshBuilderRenderer.RenderCallback() {\r\n        @Override\r\n        public void preRender() {\r\n            try {\r\n                synchronized (MeshBuilderActivity.this) {\r\n                    if (!mIsConnected) {\r\n                        return;\r\n                    }\r\n                    TangoSupport.MatrixTransformData ssTdev = TangoSupport.getMatrixTransformAtTime(0.0, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_DEVICE, TangoSupport.ENGINE_TANGO, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                    if (ssTdev.statusCode == TangoPoseData.POSE_VALID) {\r\n                        mRenderer.updateViewMatrix(ssTdev.matrix);\r\n                    } else {\r\n                        Log.w(TAG, \"Can't get last camera pose\");\r\n                    }\r\n                }\r\n                updateMeshMap();\r\n            } catch (TangoErrorException e) {\r\n                Log.w(TAG, \"Tango API call error within the OpenGL thread\", e);\r\n            } catch (TangoInvalidException e) {\r\n                Log.w(TAG, \"Tango API call error within the OpenGL thread\", e);\r\n            }\r\n        }\r\n    });\r\n    mSurfaceView.setRenderer(mRenderer);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camera and callbacks.",
	"Method": "void connectRenderer(){\r\n    try {\r\n        synchronized (MeshBuilderActivity.this) {\r\n            if (!mIsConnected) {\r\n                return;\r\n            }\r\n            TangoSupport.MatrixTransformData ssTdev = TangoSupport.getMatrixTransformAtTime(0.0, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_DEVICE, TangoSupport.ENGINE_TANGO, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n            if (ssTdev.statusCode == TangoPoseData.POSE_VALID) {\r\n                mRenderer.updateViewMatrix(ssTdev.matrix);\r\n            } else {\r\n                Log.w(TAG, \"Can't get last camera pose\");\r\n            }\r\n        }\r\n        updateMeshMap();\r\n    } catch (TangoErrorException e) {\r\n        Log.w(TAG, \"Tango API call error within the OpenGL thread\", e);\r\n    } catch (TangoInvalidException e) {\r\n        Log.w(TAG, \"Tango API call error within the OpenGL thread\", e);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.HelloMessageParser.parseProtocolVersion",
	"Comment": "reads the next bytes as a protocolversion and writes them in the message",
	"Method": "void parseProtocolVersion(HelloMessage message){\r\n    message.setProtocolVersion(parseByteArrayField(HandshakeByteLength.VERSION));\r\n    LOGGER.debug(\"ProtocolVersion:\" + ArrayConverter.bytesToHexString(message.getProtocolVersion().getValue()));\r\n}"
}, {
	"Path": "com.novoda.spikes.arcore.google.rendering.ObjectRenderer.createOnGlThread",
	"Comment": "creates and initializes opengl resources needed for rendering the model.",
	"Method": "void createOnGlThread(Context context,String objAssetName,String diffuseTextureAssetName){\r\n    final int vertexShader = ShaderUtil.loadGLShader(TAG, context, GLES20.GL_VERTEX_SHADER, VERTEX_SHADER_NAME);\r\n    final int fragmentShader = ShaderUtil.loadGLShader(TAG, context, GLES20.GL_FRAGMENT_SHADER, FRAGMENT_SHADER_NAME);\r\n    program = GLES20.glCreateProgram();\r\n    GLES20.glAttachShader(program, vertexShader);\r\n    GLES20.glAttachShader(program, fragmentShader);\r\n    GLES20.glLinkProgram(program);\r\n    GLES20.glUseProgram(program);\r\n    ShaderUtil.checkGLError(TAG, \"Program creation\");\r\n    modelViewUniform = GLES20.glGetUniformLocation(program, \"u_ModelView\");\r\n    modelViewProjectionUniform = GLES20.glGetUniformLocation(program, \"u_ModelViewProjection\");\r\n    positionAttribute = GLES20.glGetAttribLocation(program, \"a_Position\");\r\n    normalAttribute = GLES20.glGetAttribLocation(program, \"a_Normal\");\r\n    texCoordAttribute = GLES20.glGetAttribLocation(program, \"a_TexCoord\");\r\n    textureUniform = GLES20.glGetUniformLocation(program, \"u_Texture\");\r\n    lightingParametersUniform = GLES20.glGetUniformLocation(program, \"u_LightingParameters\");\r\n    materialParametersUniform = GLES20.glGetUniformLocation(program, \"u_MaterialParameters\");\r\n    colorCorrectionParameterUniform = GLES20.glGetUniformLocation(program, \"u_ColorCorrectionParameters\");\r\n    ShaderUtil.checkGLError(TAG, \"Program parameters\");\r\n    Bitmap textureBitmap = BitmapFactory.decodeStream(context.getAssets().open(diffuseTextureAssetName));\r\n    GLES20.glActiveTexture(GLES20.GL_TEXTURE0);\r\n    GLES20.glGenTextures(textures.length, textures, 0);\r\n    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textures[0]);\r\n    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR_MIPMAP_LINEAR);\r\n    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);\r\n    GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, textureBitmap, 0);\r\n    GLES20.glGenerateMipmap(GLES20.GL_TEXTURE_2D);\r\n    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);\r\n    textureBitmap.recycle();\r\n    ShaderUtil.checkGLError(TAG, \"Texture loading\");\r\n    InputStream objInputStream = context.getAssets().open(objAssetName);\r\n    Obj obj = ObjReader.read(objInputStream);\r\n    obj = ObjUtils.convertToRenderable(obj);\r\n    IntBuffer wideIndices = ObjData.getFaceVertexIndices(obj, 3);\r\n    FloatBuffer vertices = ObjData.getVertices(obj);\r\n    FloatBuffer texCoords = ObjData.getTexCoords(obj, 2);\r\n    FloatBuffer normals = ObjData.getNormals(obj);\r\n    ShortBuffer indices = ByteBuffer.allocateDirect(2 * wideIndices.limit()).order(ByteOrder.nativeOrder()).asShortBuffer();\r\n    while (wideIndices.hasRemaining()) {\r\n        indices.put((short) wideIndices.get());\r\n    }\r\n    indices.rewind();\r\n    int[] buffers = new int[2];\r\n    GLES20.glGenBuffers(2, buffers, 0);\r\n    vertexBufferId = buffers[0];\r\n    indexBufferId = buffers[1];\r\n    verticesBaseAddress = 0;\r\n    texCoordsBaseAddress = verticesBaseAddress + 4 * vertices.limit();\r\n    normalsBaseAddress = texCoordsBaseAddress + 4 * texCoords.limit();\r\n    final int totalBytes = normalsBaseAddress + 4 * normals.limit();\r\n    GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, vertexBufferId);\r\n    GLES20.glBufferData(GLES20.GL_ARRAY_BUFFER, totalBytes, null, GLES20.GL_STATIC_DRAW);\r\n    GLES20.glBufferSubData(GLES20.GL_ARRAY_BUFFER, verticesBaseAddress, 4 * vertices.limit(), vertices);\r\n    GLES20.glBufferSubData(GLES20.GL_ARRAY_BUFFER, texCoordsBaseAddress, 4 * texCoords.limit(), texCoords);\r\n    GLES20.glBufferSubData(GLES20.GL_ARRAY_BUFFER, normalsBaseAddress, 4 * normals.limit(), normals);\r\n    GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0);\r\n    GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER, indexBufferId);\r\n    indexCount = indices.limit();\r\n    GLES20.glBufferData(GLES20.GL_ELEMENT_ARRAY_BUFFER, 2 * indexCount, indices, GLES20.GL_STATIC_DRAW);\r\n    GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER, 0);\r\n    ShaderUtil.checkGLError(TAG, \"OBJ buffer load\");\r\n    Matrix.setIdentityM(modelMatrix, 0);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskDhClientKeyExchangeHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class pskdhclientkeyexchangehandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof PskDhClientKeyExchangeParser);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeMasterSecretActionTest.testGetOldValue",
	"Comment": "test of getoldvalue method, of class changeclientrandomaction.",
	"Method": "void testGetOldValue(){\r\n    tlsContext.setMasterSecret(new byte[] { 3 });\r\n    action.normalize();\r\n    action.execute(state);\r\n    assertArrayEquals(action.getOldValue(), new byte[] { 3 });\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.SignatureAndHashAlgorithmDelegateTest.testGetSignatureAndHashAlgorithms",
	"Comment": "test of getsignatureandhashalgorithms method, of classsignatureandhashalgorithmdelegate.",
	"Method": "void testGetSignatureAndHashAlgorithms(){\r\n    args = new String[2];\r\n    args[0] = \"-signature_hash_algo\";\r\n    args[1] = \"RSA_SHA512,DSA_SHA512\";\r\n    delegate.setSignatureAndHashAlgorithms(null);\r\n    jcommander.parse(args);\r\n    assertTrue(delegate.getSignatureAndHashAlgorithms().contains(SignatureAndHashAlgorithm.RSA_SHA512));\r\n    assertTrue(delegate.getSignatureAndHashAlgorithms().contains(SignatureAndHashAlgorithm.DSA_SHA512));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.constants.AlgorithmResolverTest.testGetMacAlgorithm",
	"Comment": "test of getmacalgorithm method, of class algorithmresolver.",
	"Method": "void testGetMacAlgorithm(){\r\n    assertEquals(AlgorithmResolver.getMacAlgorithm(ProtocolVersion.TLS12, CipherSuite.TLS_GOSTR341094_WITH_28147_CNT_IMIT), MacAlgorithm.IMIT_GOST28147);\r\n    assertEquals(AlgorithmResolver.getMacAlgorithm(ProtocolVersion.TLS12, CipherSuite.TLS_GOSTR341001_WITH_NULL_GOSTR3411), MacAlgorithm.HMAC_GOSTR3411);\r\n    assertEquals(AlgorithmResolver.getMacAlgorithm(ProtocolVersion.TLS12, CipherSuite.TLS_GOSTR341112_256_WITH_NULL_GOSTR3411), MacAlgorithm.HMAC_GOSTR3411_2012_256);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.PskEcDhClientKeyExchangeMessageTest.testToString",
	"Comment": "test of tostring method, of class pskecdhclientkeyexchangemessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"PskEcDhClientKeyExchangeMessage:\");\r\n    sb.append(\"\\n  PSKIdentity Length: \").append(\"null\");\r\n    sb.append(\"\\n  PSKIdentity: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ServerHelloParser.parseCipherSuites",
	"Comment": "reads the next bytes as the ciphersuites and writes them in the message",
	"Method": "void parseCipherSuites(SSL2ServerHelloMessage message){\r\n    message.setCipherSuites(parseByteArrayField(message.getCipherSuitesLength().getValue()));\r\n    LOGGER.debug(\"CipherSuites: \" + ArrayConverter.bytesToHexString(message.getCipherSuites().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.crypto.ec_.EllipticCurve.mult",
	"Comment": "returns kp on this curve. if k or p is null, the result will be null. ifthe point is not on the curve and the calculations would require dividingby 0, the result will be the point at infinity.",
	"Method": "Point mult(BigInteger k,Point p){\r\n    if (k == null || p == null) {\r\n        return null;\r\n    } else {\r\n        if (k.compareTo(BigInteger.ZERO) < 0) {\r\n            k = k.negate();\r\n            p = this.inverse(p);\r\n        }\r\n        Point q = new Point();\r\n        for (int i = k.bitLength(); i > 0; i--) {\r\n            q = this.add(q, q);\r\n            if (k.testBit(i - 1)) {\r\n                q = this.add(q, p);\r\n            }\r\n        }\r\n        return q;\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.ServerNameIndicationExtensionParserTest.testParseExtensionMessageContent",
	"Comment": "test of parseextensionmessagecontent method, of classservernameindicationextensionparser.",
	"Method": "void testParseExtensionMessageContent(){\r\n    ServerNameIndicationExtensionParser parser = new ServerNameIndicationExtensionParser(start, extension);\r\n    ServerNameIndicationExtensionMessage msg = parser.parse();\r\n    assertArrayEquals(msg.getExtensionBytes().getValue(), completeExtension);\r\n    assertArrayEquals(type.getValue(), msg.getExtensionType().getValue());\r\n    assertEquals(extensionLength, msg.getExtensionLength().getValue().intValue());\r\n    assertArrayEquals(msg.getServerNameListBytes().getValue(), sniListBytes);\r\n    assertEquals(sniListLength, msg.getServerNameListLength().getValue().intValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.EllipticCurvesExtensionParserTest.testParseExtensionMessageContent",
	"Comment": "test of parseextensionmessagecontent method, of classellipticcurvesextensionparser.",
	"Method": "void testParseExtensionMessageContent(){\r\n    EllipticCurvesExtensionParser parser = new EllipticCurvesExtensionParser(start, extension);\r\n    EllipticCurvesExtensionMessage msg = parser.parse();\r\n    assertArrayEquals(msg.getExtensionBytes().getValue(), completeExtension);\r\n    assertArrayEquals(type.getValue(), msg.getExtensionType().getValue());\r\n    assertTrue(extensionLength == msg.getExtensionLength().getValue());\r\n    assertArrayEquals(msg.getSupportedGroups().getValue(), curves);\r\n    assertTrue(curvesLength == msg.getSupportedGroupsLength().getValue());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.helloareadescription.HelloAreaDescriptionActivity.setTangoConfig",
	"Comment": "sets up the tango configuration object. make sure mtango object is initialized beforemaking this call.",
	"Method": "TangoConfig setTangoConfig(Tango tango,boolean isLearningMode,boolean isLoadAdf){\r\n    TangoConfig config = tango.getConfig(TangoConfig.CONFIG_TYPE_DEFAULT);\r\n    if (isLearningMode) {\r\n        config.putBoolean(TangoConfig.KEY_BOOLEAN_LEARNINGMODE, true);\r\n    }\r\n    if (isLoadAdf) {\r\n        ArrayList<String> fullUuidList;\r\n        fullUuidList = tango.listAreaDescriptions();\r\n        if (fullUuidList.size() > 0) {\r\n            config.putString(TangoConfig.KEY_STRING_AREADESCRIPTION, fullUuidList.get(fullUuidList.size() - 1));\r\n        }\r\n    }\r\n    return config;\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.identity.AWSCognitoDeveloperAuthenticationSample.validateTokenRequest",
	"Comment": "verify if the token request is valid. uid is authenticated. the timestampis checked to see it falls within the valid timestamp window. thesignature is computed and matched against the given signature. useful inanonymous and identity modes",
	"Method": "void validateTokenRequest(String uid,String signature,String timestamp,String stringToSign){\r\n    if (!isTimestampValid(timestamp)) {\r\n        throw new UnauthorizedException(\"Invalid timestamp: \" + timestamp);\r\n    }\r\n    log.info(String.format(\"Timestamp [ %s ] is valid\", timestamp));\r\n    DeviceInfo device = ensureKnownDevice(uid);\r\n    if (!validateSignature(stringToSign, device.getKey(), signature)) {\r\n        log.info(\"String to sign: \" + stringToSign);\r\n        throw new UnauthorizedException(\"Invalid signature: \" + signature);\r\n    }\r\n    log.info(\"Signature matched!!!\");\r\n}"
}, {
	"Path": "technology.tabula.Page.getTextBounds",
	"Comment": "returns the minimum bounding box that contains all the textelements on this page",
	"Method": "Rectangle getTextBounds(){\r\n    List<TextElement> texts = this.getText();\r\n    if (!texts.isEmpty()) {\r\n        return Utils.bounds(texts);\r\n    } else {\r\n        return new Rectangle();\r\n    }\r\n}"
}, {
	"Path": "org.sonar.java.ast.visitors.SyntaxHighlighterVisitorTest.test_restricted_keywords_within_module",
	"Comment": "java 9 modules introduces restricted keywords only used in their context",
	"Method": "void test_restricted_keywords_within_module(){\r\n    this.eol = \"\\n\";\r\n    File file = generateTestFile(\"src/test/files/highlighter/ModuleExample.java\");\r\n    scan(file);\r\n    String componentKey = \":\" + file.getName();\r\n    assertThatHasBeenHighlighted(componentKey, 1, 1, 3, 4, TypeOfText.COMMENT);\r\n    assertThatHasBeenHighlighted(componentKey, 4, 1, 4, 7, TypeOfText.KEYWORD);\r\n    assertThatHasBeenHighlighted(componentKey, 6, 1, 8, 4, TypeOfText.STRUCTURED_COMMENT);\r\n    assertThatHasBeenHighlighted(componentKey, 9, 1, 9, 6, TypeOfText.ANNOTATION);\r\n    assertThatHasBeenHighlighted(componentKey, 10, 1, 10, 5, TypeOfText.KEYWORD);\r\n    assertThatHasBeenHighlighted(componentKey, 10, 6, 10, 12, TypeOfText.KEYWORD);\r\n    assertThatHasBeenHighlighted(componentKey, 11, 3, 11, 11, TypeOfText.KEYWORD);\r\n    assertThatHasNotBeenHighlighted(componentKey, 11, 12, 11, 22);\r\n    assertThatHasBeenHighlighted(componentKey, 12, 3, 12, 11, TypeOfText.KEYWORD);\r\n    assertThatHasBeenHighlighted(componentKey, 12, 12, 12, 18, TypeOfText.KEYWORD);\r\n    assertThatHasNotBeenHighlighted(componentKey, 12, 19, 12, 29);\r\n    assertThatHasBeenHighlighted(componentKey, 13, 3, 13, 11, TypeOfText.KEYWORD);\r\n    assertThatHasBeenHighlighted(componentKey, 13, 12, 13, 18, TypeOfText.KEYWORD);\r\n    assertThatHasBeenHighlighted(componentKey, 13, 19, 13, 29, TypeOfText.KEYWORD);\r\n    assertThatHasBeenHighlighted(componentKey, 14, 3, 14, 10, TypeOfText.KEYWORD);\r\n    assertThatHasBeenHighlighted(componentKey, 14, 19, 14, 21, TypeOfText.KEYWORD);\r\n    assertThatHasBeenHighlighted(componentKey, 15, 3, 15, 8, TypeOfText.KEYWORD);\r\n    assertThatHasBeenHighlighted(componentKey, 15, 17, 15, 19, TypeOfText.KEYWORD);\r\n    assertThatHasBeenHighlighted(componentKey, 16, 3, 16, 7, TypeOfText.KEYWORD);\r\n    assertThatHasBeenHighlighted(componentKey, 17, 3, 17, 11, TypeOfText.KEYWORD);\r\n    assertThatHasBeenHighlighted(componentKey, 17, 26, 17, 30, TypeOfText.KEYWORD);\r\n    assertThatHasBeenHighlighted(componentKey, 18, 3, 18, 60, TypeOfText.COMMENT);\r\n    assertThatHasBeenHighlighted(componentKey, 19, 3, 19, 10, TypeOfText.KEYWORD);\r\n    assertThatHasNotBeenHighlighted(componentKey, 19, 28, 19, 34);\r\n    assertThatHasBeenHighlighted(componentKey, 20, 3, 20, 11, TypeOfText.KEYWORD);\r\n    assertThatHasBeenHighlighted(componentKey, 20, 34, 20, 38, TypeOfText.KEYWORD);\r\n    assertThatHasNotBeenHighlighted(componentKey, 20, 45, 20, 49);\r\n    assertThatHasNotBeenHighlighted(componentKey, 20, 50, 20, 52);\r\n    assertThatHasNotBeenHighlighted(componentKey, 20, 53, 20, 60);\r\n    assertThatHasNotBeenHighlighted(componentKey, 20, 61, 20, 67);\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.util.ConfUtils.loadListFromConf",
	"Comment": "return one or more strings regardless of whether they are represented asa single string or a list in the config.",
	"Method": "List<String> loadListFromConf(String paramKey,Map stormConf){\r\n    Object obj = stormConf.get(paramKey);\r\n    List<String> list = new LinkedList();\r\n    if (obj == null)\r\n        return list;\r\n    if (obj instanceof PersistentVector) {\r\n        list.addAll((PersistentVector) obj);\r\n    } else {\r\n        list.add(obj.toString());\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.HostnameExtensionDelegateTest.testApplyDelegate",
	"Comment": "test of applydelegate method, of class hostnameextensiondelegate.",
	"Method": "void testApplyDelegate(){\r\n    args = new String[2];\r\n    args[0] = \"-server_name\";\r\n    args[1] = \"its_me\";\r\n    jcommander.parse(args);\r\n    Config config = Config.createConfig();\r\n    config.setSniHostname(null);\r\n    config.setAddServerNameIndicationExtension(false);\r\n    assertFalse(config.isAddServerNameIndicationExtension());\r\n    delegate.applyDelegate(config);\r\n    assertTrue(config.getSniHostname().equals(\"its_me\"));\r\n    assertTrue(config.isAddServerNameIndicationExtension());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.extension.SupportedVersionsExtensionPreparatorTest.testPrepare",
	"Comment": "test of prepare method, of class supportedversionsextensionpreparator.",
	"Method": "void testPrepare(){\r\n    LinkedList<ProtocolVersion> supportedVersions = new LinkedList();\r\n    supportedVersions.add(ProtocolVersion.TLS13);\r\n    supportedVersions.add(ProtocolVersion.TLS12);\r\n    context.getConfig().setSupportedVersions(supportedVersions);\r\n    preparator.prepare();\r\n    assertArrayEquals(message.getSupportedVersions().getValue(), ArrayConverter.concatenate(ProtocolVersion.TLS13.getValue(), ProtocolVersion.TLS12.getValue()));\r\n    assertTrue(message.getSupportedVersionsLength().getValue() == 4);\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.GitAttributesLineEndings.findAttributeInRules",
	"Comment": "parses an attribute value from a list of rules, returning null if there is no match for the given key.",
	"Method": "String findAttributeInRules(String subpath,boolean isFolder,String key,List<AttributesRule> rules){\r\n    String value = null;\r\n    for (AttributesRule rule : rules) {\r\n        if (rule.isMatch(subpath, isFolder)) {\r\n            for (Attribute attribute : rule.getAttributes()) {\r\n                if (attribute.getKey().equals(key)) {\r\n                    value = attribute.getValue();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.CertificateRequestMessageTest.testToString",
	"Comment": "test of tostring method, of class certificaterequestmessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"CertificateRequestMessage:\");\r\n    sb.append(\"\\n  Certificate Types Count: \").append(\"null\");\r\n    sb.append(\"\\n  Certificate Types: \").append(\"null\");\r\n    sb.append(\"\\n  Signature Hash Algorithms Length: \").append(\"null\");\r\n    sb.append(\"\\n  Signature Hash Algorithms: \").append(\"null\");\r\n    sb.append(\"\\n  Distinguished Names Length: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.crypto.ECCUtilsBCWrapper.serializeECPoint",
	"Comment": "serializes an ec point and returns its encoded version, consisting of onebyte encoding information and ec coordinates",
	"Method": "byte[] serializeECPoint(ECPointFormat[] ecPointFormats,ECPoint point){\r\n    short[] pf = convertPointFormats(ecPointFormats);\r\n    return TlsECCUtils.serializeECPoint(pf, point);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.DHEServerKeyExchangeParser.parseSignatureLength",
	"Comment": "reads the next bytes as the signaturelength and writes them in themessage",
	"Method": "void parseSignatureLength(DHEServerKeyExchangeMessage msg){\r\n    msg.setSignatureLength(parseIntField(HandshakeByteLength.SIGNATURE_LENGTH));\r\n    LOGGER.debug(\"SignatureLength: \" + msg.getSignatureLength().getValue());\r\n}"
}, {
	"Path": "org.springframework.data.neo4j.conversion.MetaDataDrivenConversionService.nestedTypeOrType",
	"Comment": "if the type can be resolved to a collection that has generics, we extract the collection type, otherwise we return\tthe resolved type.",
	"Method": "Class<?> nestedTypeOrType(ResolvableType type){\r\n    return Optional.ofNullable(type.asCollection()).filter(ResolvableType::hasGenerics).map(r -> r.getGeneric(0)).orElse(type).resolve(Object.class);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.crypto.MessageDigestCollectorTest.testSetRawBytes",
	"Comment": "test of setrawbytes method, of class messagedigestcollector.",
	"Method": "void testSetRawBytes(){\r\n    digest.setRawBytes(testarray);\r\n    assertArrayEquals(testarray, digest.getRawBytes());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.EllipticCurveDelegateTest.testGetPointFormats",
	"Comment": "test of getpointformats method, of class namedgroupsdelegate.",
	"Method": "void testGetPointFormats(){\r\n    args = new String[2];\r\n    args[0] = \"-point_formats\";\r\n    args[1] = \"ANSIX962_COMPRESSED_PRIME,UNCOMPRESSED\";\r\n    jcommander.parse(args);\r\n    assertTrue(\"UNCOMPRESSED should get parsed correctly\", delegate.getPointFormats().contains(ECPointFormat.UNCOMPRESSED));\r\n    assertTrue(\"ANSIX962_COMPRESSED_PRIME should get parsed correctly\", delegate.getPointFormats().contains(ECPointFormat.ANSIX962_COMPRESSED_PRIME));\r\n}"
}, {
	"Path": "org.takes.misc.VerboseIteratorTest.returnFalseInHasNextValueOnEmptyList",
	"Comment": "verboseiterator returns false in has next value on empty list.",
	"Method": "void returnFalseInHasNextValueOnEmptyList(){\r\n    MatcherAssert.assertThat(new VerboseIterable<String>(Collections.<String>emptyList(), \"Non used Error Message\").iterator().hasNext(), Matchers.equalTo(false));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.UnknownHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class unknownhandler.",
	"Method": "void testAdjustTLSContext(){\r\n    UnknownMessage message = new UnknownMessage();\r\n    handler.adjustTLSContext(message);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.factory.WorkflowConfigurationFactory.createFullWorkflow",
	"Comment": "creates an extended tls workflow including an application data andheartbeat messages",
	"Method": "WorkflowTrace createFullWorkflow(){\r\n    AliasedConnection connection = getConnection();\r\n    WorkflowTrace workflowTrace = this.createHandshakeWorkflow(connection);\r\n    List<ProtocolMessage> messages = new LinkedList();\r\n    if (config.isServerSendsApplicationData()) {\r\n        messages.add(new ApplicationMessage(config));\r\n        workflowTrace.addTlsAction(MessageActionFactory.createAction(connection, ConnectionEndType.SERVER, messages));\r\n        messages = new LinkedList();\r\n    }\r\n    messages.add(new ApplicationMessage(config));\r\n    if (config.isAddHeartbeatExtension()) {\r\n        messages.add(new HeartbeatMessage(config));\r\n        workflowTrace.addTlsAction(MessageActionFactory.createAction(connection, ConnectionEndType.CLIENT, messages));\r\n        messages = new LinkedList();\r\n        messages.add(new HeartbeatMessage(config));\r\n        workflowTrace.addTlsAction(MessageActionFactory.createAction(connection, ConnectionEndType.SERVER, messages));\r\n    } else {\r\n        workflowTrace.addTlsAction(MessageActionFactory.createAction(connection, ConnectionEndType.CLIENT, messages));\r\n    }\r\n    return workflowTrace;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.DHEServerKeyExchangeMessageTest.testToString",
	"Comment": "test of tostring method, of class dheserverkeyexchangemessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"DHEServerKeyExchangeMessage:\");\r\n    sb.append(\"\\n  Modulus p: \").append(\"null\");\r\n    sb.append(\"\\n  Generator g: \").append(\"null\");\r\n    sb.append(\"\\n  Public Key: \").append(\"null\");\r\n    sb.append(\"\\n  Signature and Hash Algorithm: \").append(\"null\");\r\n    sb.append(\"\\n  Signature: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "com.diffplug.spotless.FileSignature.files",
	"Comment": "returns all of the files in this signature, throwing an exception if there are more or less than 1 file.",
	"Method": "Collection<File> files(){\r\n    return Collections.unmodifiableList(files);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.KeyShareEntryParser.parseKeyShareGroup",
	"Comment": "reads the next bytes as the keysharetype of the extension and writes themin the message",
	"Method": "void parseKeyShareGroup(KeyShareEntry pair){\r\n    pair.setGroup(parseByteArrayField(ExtensionByteLength.KEY_SHARE_GROUP));\r\n    LOGGER.debug(\"KeyShareGroup: \" + ArrayConverter.bytesToHexString(pair.getGroup().getValue()));\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.util.GeomBuilder.buffer",
	"Comment": "buffers the geometry at the top of the geometry stack, and places the result back on the geometry stack.",
	"Method": "GeomBuilder buffer(double amt){\r\n    gstack.push(gpop(Geometry.class).buffer(amt));\r\n    return this;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.transport.nonblocking.ServerTCPNonBlockingTransportHandlerTest.testRecheck",
	"Comment": "test of recheck method, of class servertcpnonblockingtransporthandler.",
	"Method": "void testRecheck(){\r\n    handler.recheck();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.crypto.ECCUtilsBCWrapper.readECParameters",
	"Comment": "reads ecc domain parameters from an inputstream, all named formats andpoint formats are allowed",
	"Method": "ECDomainParameters readECParameters(NamedGroup[] namedGroups,ECPointFormat[] pointFormats,InputStream input,ECDomainParameters readECParameters,NamedGroup namedGroup,ECPointFormat pointFormat,InputStream input,ECDomainParameters readECParameters,InputStream input){\r\n    NamedGroup[] namedCurves = NamedGroup.values();\r\n    ECPointFormat[] poinFormats = ECPointFormat.values();\r\n    return readECParameters(namedCurves, poinFormats, input);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.projectionMatrixFromCameraIntrinsics",
	"Comment": "use tango camera intrinsics to calculate the projection matrix for the rajawali scene.",
	"Method": "float[] projectionMatrixFromCameraIntrinsics(TangoCameraIntrinsics intrinsics){\r\n    float cx = (float) intrinsics.cx;\r\n    float cy = (float) intrinsics.cy;\r\n    float width = (float) intrinsics.width;\r\n    float height = (float) intrinsics.height;\r\n    float fx = (float) intrinsics.fx;\r\n    float fy = (float) intrinsics.fy;\r\n    float near = 0.1f;\r\n    float far = 100;\r\n    float xScale = near / fx;\r\n    float yScale = near / fy;\r\n    float xOffset = (cx - (width / 2.0f)) * xScale;\r\n    float yOffset = -(cy - (height / 2.0f)) * yScale;\r\n    float[] m = new float[16];\r\n    Matrix.frustumM(m, 0, xScale * (float) -width / 2.0f - xOffset, xScale * (float) width / 2.0f - xOffset, yScale * (float) -height / 2.0f - yOffset, yScale * (float) height / 2.0f - yOffset, near, far);\r\n    return m;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ChangeCipherSpecParser.parseCcsProtocolType",
	"Comment": "reads the next bytes as the ccsprotocoltype and writes them in themessage",
	"Method": "void parseCcsProtocolType(ChangeCipherSpecMessage msg){\r\n    msg.setCcsProtocolType(parseByteField(ChangeCipherSpecByteLength.TYPE_LENGTH));\r\n    LOGGER.debug(\"CcsProtocolType: \" + msg.getCcsProtocolType().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.ChangeCipherSpecMessageTest.testToString",
	"Comment": "test of tostring method, of class changecipherspecmessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"ChangeCipherSpecMessage:\");\r\n    sb.append(\"\\n  CCS ProtocolType: \").append(\"null\");\r\n    assertEquals(sb.toString(), message.toString());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.PskClientKeyExchangePreparatorTest.testPrepare",
	"Comment": "test of preparehandshakemessagecontents method, of classpskclientkeyexchangepreparator.",
	"Method": "void testPrepare(){\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS12);\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_PSK_WITH_AES_128_CBC_SHA);\r\n    context.setClientRandom(ArrayConverter.hexStringToByteArray(RANDOM));\r\n    context.setServerRandom(ArrayConverter.hexStringToByteArray(RANDOM));\r\n    preparator.prepareHandshakeMessageContents();\r\n    assertArrayEquals(PREMASTERSECRET, message.getComputations().getPremasterSecret().getValue());\r\n    assertNotNull(message.getComputations().getClientServerRandom());\r\n    assertArrayEquals(ArrayConverter.concatenate(ArrayConverter.hexStringToByteArray(RANDOM), ArrayConverter.hexStringToByteArray(RANDOM)), message.getComputations().getClientServerRandom().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.CertificateRequestHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class certificaterequesthandler.",
	"Method": "void testAdjustTLSContext(){\r\n    CertificateRequestMessage message = new CertificateRequestMessage();\r\n    message.setClientCertificateTypes(new byte[] { 1, 2, 3, 4, 5, 6 });\r\n    message.setDistinguishedNames(new byte[] { 0, 1, 2, 3 });\r\n    message.setSignatureHashAlgorithms(new byte[] { 03, 01, 01, 03 });\r\n    handler.adjustTLSContext(message);\r\n    assertArrayEquals(context.getDistinguishedNames(), ArrayConverter.hexStringToByteArray(\"00010203\"));\r\n    assertTrue(context.getClientCertificateTypes().size() == 6);\r\n    assertTrue(context.getClientCertificateTypes().contains(ClientCertificateType.DSS_EPHEMERAL_DH_RESERVED));\r\n    assertTrue(context.getClientCertificateTypes().contains(ClientCertificateType.DSS_FIXED_DH));\r\n    assertTrue(context.getClientCertificateTypes().contains(ClientCertificateType.DSS_SIGN));\r\n    assertTrue(context.getClientCertificateTypes().contains(ClientCertificateType.RSA_EPHEMERAL_DH_RESERVED));\r\n    assertTrue(context.getClientCertificateTypes().contains(ClientCertificateType.RSA_FIXED_DH));\r\n    assertTrue(context.getClientCertificateTypes().contains(ClientCertificateType.RSA_SIGN));\r\n    assertTrue(context.getServerSupportedSignatureAndHashAlgorithms().size() == 2);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.AlertParser.parseLevel",
	"Comment": "reads the next bytes as the level and writes them in the message",
	"Method": "void parseLevel(AlertMessage msg){\r\n    msg.setLevel(parseByteField(AlertByteLength.LEVEL_LENGTH));\r\n    LOGGER.debug(\"Level: \" + msg.getLevel().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ECDHEServerKeyExchangeHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class ecdheserverkeyexchangehandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new ECDHEServerKeyExchangeMessage()) instanceof ECDHEServerKeyExchangeSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.ModifiableVariableHolder.getRandomModifiableVariableField",
	"Comment": "returns a random field representing a modifiable variable from this class",
	"Method": "Field getRandomModifiableVariableField(Random random){\r\n    List<Field> fields = getAllModifiableVariableFields();\r\n    int randomField = random.nextInt(fields.size());\r\n    return fields.get(randomField);\r\n}"
}, {
	"Path": "org.springframework.statemachine.config.common.annotation.configurers.DefaultPropertiesConfigurer.configureProperties",
	"Comment": "configure properties. if this implementation is extended,\tcustom configure handling can be handled here.",
	"Method": "boolean configureProperties(B builder,Properties properties){\r\n    return false;\r\n}"
}, {
	"Path": "org.takes.rq.multipart.RqMtFakeTest.returnsEmptyIteratorOnInvalidPartRequest",
	"Comment": "rqmtfake can return empty iterator on invalid part request.",
	"Method": "void returnsEmptyIteratorOnInvalidPartRequest(){\r\n    final String body = \"443 N Wolfe Rd, Sunnyvale, CA 94085\";\r\n    final RqMultipart multi = new RqMtFake(new RqFake(), new RqWithHeaders(new RqFake(\"\", \"\", body), RqMtFakeTest.contentLengthHeader((long) body.getBytes().length), RqMtFakeTest.contentDispositionHeader(\"form-data; name=\\\"t5\\\"\")), new RqWithHeaders(new RqFake(\"\", \"\", \"\"), RqMtFakeTest.contentLengthHeader(0L), RqMtFakeTest.contentDispositionHeader(String.format(RqMtFakeTest.FORM_DATA, \"a.zip\"))));\r\n    MatcherAssert.assertThat(multi.part(\"fake\").iterator().hasNext(), Matchers.is(false));\r\n    multi.body().close();\r\n}"
}, {
	"Path": "org.takes.rs.RsPrintTest.flushBodyEvenWhenExceptionHappens",
	"Comment": "rsprint can flush body contents even when exception happens.",
	"Method": "void flushBodyEvenWhenExceptionHappens(){\r\n    final IOException exception = new IOException(\"Failure\");\r\n    final FailOutputStream output = new FailOutputStream(exception);\r\n    try {\r\n        new RsPrint(new RsText(\"Hello\")).printBody(output);\r\n    } catch (final IOException ex) {\r\n        if (!ex.equals(exception)) {\r\n            throw ex;\r\n        }\r\n    }\r\n    MatcherAssert.assertThat(output.haveFlushed(), Matchers.is(true));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.ApplicationMessagePreparatorTest.testPrepare",
	"Comment": "test of prepareprotocolmessagecontents method, of classapplicationmessagepreparator.",
	"Method": "void testPrepare(){\r\n    context.getConfig().setDefaultApplicationMessageData(\"1234\");\r\n    preparator.prepare();\r\n    assertArrayEquals(message.getData().getValue(), \"1234\".getBytes());\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.delegatesLastIndexOf",
	"Comment": "verboselist should delegate lastindexof method to decorated list.",
	"Method": "void delegatesLastIndexOf(){\r\n    final Object obj = new Object();\r\n    this.list.lastIndexOf(obj);\r\n    Mockito.verify(this.origin).lastIndexOf(obj);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointcloud.PointCloudActivity.setupTangoConfig",
	"Comment": "sets up the tango configuration object. make sure mtango object is initialized beforemaking this call.",
	"Method": "TangoConfig setupTangoConfig(Tango tango){\r\n    TangoConfig config = tango.getConfig(TangoConfig.CONFIG_TYPE_DEFAULT);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_DEPTH, true);\r\n    config.putInt(TangoConfig.KEY_INT_DEPTH_MODE, TangoConfig.TANGO_DEPTH_MODE_POINT_CLOUD);\r\n    return config;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.transport.tcp.ServerTcpTransportHandlerTest.testInitialize",
	"Comment": "test of initialize method, of class servertcptransporthandler.",
	"Method": "void testInitialize(){\r\n    SocketOpenerCallable callable = new SocketOpenerCallable(\"localhost\", handler.getPort());\r\n    Thread t = new Thread(new FutureTask(callable));\r\n    t.start();\r\n    handler.initialize();\r\n    assertTrue(handler.isInitialized());\r\n}"
}, {
	"Path": "org.springframework.statemachine.config.common.annotation.AbstractConfiguredAnnotationBuilder.getSharedObject",
	"Comment": "gets a shared object. note that object hierarchies are not considered.",
	"Method": "C getSharedObject(Class<C> sharedType){\r\n    return (C) this.sharedObjects.get(sharedType);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ChangeCipherSpecHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class changecipherspechandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new ChangeCipherSpecMessage()) instanceof ChangeCipherSpecSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.ServerNameIndicationExtensionHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of classservernameindicationextensionhandler.",
	"Method": "void testAdjustTLSContext(){\r\n    ServerNameIndicationExtensionMessage msg = new ServerNameIndicationExtensionMessage();\r\n    List<ServerNamePair> pairList = new LinkedList();\r\n    ServerNamePair pair = new ServerNamePair();\r\n    pair.setServerName(\"localhost\".getBytes());\r\n    pair.setServerNameType(NameType.HOST_NAME.getValue());\r\n    pairList.add(pair);\r\n    msg.setServerNameList(pairList);\r\n    handler.adjustTLSContext(msg);\r\n    assertTrue(context.getClientSNIEntryList().size() == 1);\r\n    SNIEntry entry = context.getClientSNIEntryList().get(0);\r\n    assertEquals(\"localhost\", entry.getName());\r\n    assertTrue(entry.getType() == NameType.HOST_NAME);\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.util.MetadataTransfer.filter",
	"Comment": "determine which metadata should be persisted for a given documentincluding those which are not necessarily transferred to the outlinks",
	"Method": "Metadata filter(Metadata metadata){\r\n    Metadata filtered_md = _filter(metadata, mdToTransfer);\r\n    filtered_md.putAll(_filter(metadata, mdToPersistOnly));\r\n    return filtered_md;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ECDHEServerKeyExchangeParser.parseNamedGroup",
	"Comment": "reads the next bytes as the curve and writes them in the message",
	"Method": "void parseNamedGroup(ECDHEServerKeyExchangeMessage msg){\r\n    msg.setNamedGroup(parseByteArrayField(NamedGroup.LENGTH));\r\n    LOGGER.debug(\"NamedGroup: \" + ArrayConverter.bytesToHexString(msg.getNamedGroup().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.DHClientKeyExchangeParserTest.testParse",
	"Comment": "test of parse method, of class dhclientkeyexchangeparser.",
	"Method": "void testParse(){\r\n    DHClientKeyExchangeParser<DHClientKeyExchangeMessage> parser = new DHClientKeyExchangeParser(0, message, version);\r\n    DHClientKeyExchangeMessage msg = parser.parse();\r\n    assertArrayEquals(message, msg.getCompleteResultingMessage().getValue());\r\n    assertTrue(msg.getLength().getValue() == length);\r\n    assertTrue(msg.getType().getValue() == type.getValue());\r\n    assertTrue(serializedKeyLength == msg.getPublicKeyLength().getValue());\r\n    assertArrayEquals(serializedKey, msg.getPublicKey().getValue());\r\n}"
}, {
	"Path": "com.diffplug.spotless.StepHarness.test",
	"Comment": "asserts that the given element is transformed as expected, and that the result is idempotent.",
	"Method": "StepHarness test(String before,String after){\r\n    String actual = formatter.apply(before);\r\n    Assert.assertEquals(\"Step application failed\", after, actual);\r\n    return testUnaffected(after);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellovideo.HelloVideoActivity.setupTangoConfig",
	"Comment": "sets up the tango configuration object. make sure mtango object is initialized beforemaking this call.",
	"Method": "TangoConfig setupTangoConfig(Tango tango){\r\n    TangoConfig config = tango.getConfig(TangoConfig.CONFIG_TYPE_DEFAULT);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_COLORCAMERA, true);\r\n    return config;\r\n}"
}, {
	"Path": "org.takes.tk.TkRedirectTest.createsRedirectResponseWithUrlAndStatus",
	"Comment": "tkredirect can create a response with http status code and url string.",
	"Method": "void createsRedirectResponseWithUrlAndStatus(){\r\n    final String url = \"/\";\r\n    MatcherAssert.assertThat(new RsPrint(new TkRedirect(url, HttpURLConnection.HTTP_MOVED_TEMP).act(new RqFake())).print(), Matchers.equalTo(Joiner.on(TkRedirectTest.NEWLINE).join(\"HTTP/1.1 302 Moved Temporarily\", String.format(TkRedirectTest.LOCATION, url), \"\", \"\")));\r\n}"
}, {
	"Path": "org.togglz.core.repository.jdbc.SchemaUpdater.columnExists",
	"Comment": "returns true if the given column exists in the features table.",
	"Method": "boolean columnExists(String column){\r\n    return isSuccessful(\"SELECT \" + column + \" FROM %TABLE%\");\r\n}"
}, {
	"Path": "com.example.android.trivialdrivesample.util.Base64.decode",
	"Comment": "decodes base64 content using the supplied decodabet and returnsthe decoded byte array.",
	"Method": "byte[] decode(String s,byte[] decode,byte[] source,byte[] decode,byte[] source,int off,int len,byte[] decode,byte[] source,int off,int len,byte[] decodabet){\r\n    int len34 = len * 3 / 4;\r\n    byte[] outBuff = new byte[2 + len34];\r\n    int outBuffPosn = 0;\r\n    byte[] b4 = new byte[4];\r\n    int b4Posn = 0;\r\n    int i = 0;\r\n    byte sbiCrop = 0;\r\n    byte sbiDecode = 0;\r\n    for (i = 0; i < len; i++) {\r\n        sbiCrop = (byte) (source[i + off] & 0x7f);\r\n        sbiDecode = decodabet[sbiCrop];\r\n        if (sbiDecode >= WHITE_SPACE_ENC) {\r\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\r\n                if (sbiCrop == EQUALS_SIGN) {\r\n                    int bytesLeft = len - i;\r\n                    byte lastByte = (byte) (source[len - 1 + off] & 0x7f);\r\n                    if (b4Posn == 0 || b4Posn == 1) {\r\n                        throw new Base64DecoderException(\"invalid padding byte '=' at byte offset \" + i);\r\n                    } else if ((b4Posn == 3 && bytesLeft > 2) || (b4Posn == 4 && bytesLeft > 1)) {\r\n                        throw new Base64DecoderException(\"padding byte '=' falsely signals end of encoded value \" + \"at offset \" + i);\r\n                    } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {\r\n                        throw new Base64DecoderException(\"encoded value has invalid trailing byte\");\r\n                    }\r\n                    break;\r\n                }\r\n                b4[b4Posn++] = sbiCrop;\r\n                if (b4Posn == 4) {\r\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);\r\n                    b4Posn = 0;\r\n                }\r\n            }\r\n        } else {\r\n            throw new Base64DecoderException(\"Bad Base64 input character at \" + i + \": \" + source[i + off] + \"(decimal)\");\r\n        }\r\n    }\r\n    if (b4Posn != 0) {\r\n        if (b4Posn == 1) {\r\n            throw new Base64DecoderException(\"single trailing character at offset \" + (len - 1));\r\n        }\r\n        b4[b4Posn++] = EQUALS_SIGN;\r\n        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);\r\n    }\r\n    byte[] out = new byte[outBuffPosn];\r\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\r\n    return out;\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.elasticsearch.bolt.IndexerBolt.getIndexName",
	"Comment": "must be overridden for implementing custom index names based on somemetadata information by default, indexname coming from config is used",
	"Method": "String getIndexName(Metadata m){\r\n    return indexName;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.util.KeyStoreGeneratorTest.testCreateECKeyPair",
	"Comment": "test of createeckeypair method, of class keystoregenerator.",
	"Method": "void testCreateECKeyPair(){\r\n    KeyPair k = KeyStoreGenerator.createECKeyPair(256, random);\r\n    assertNotNull(k);\r\n    assertEquals(\"EC\", k.getPublic().getAlgorithm());\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.eclipse.base.osgi.ServiceCollection.createFilter",
	"Comment": "creates filter object suitable to lookup service by its interface name.",
	"Method": "Filter createFilter(String filterDescr){\r\n    Optional<String> serviceClassName = className2Service.keySet().stream().filter(serviceClazzName -> filterDescr.contains(serviceClazzName)).findFirst();\r\n    return new ClassNameBasedFilter(serviceClassName);\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.context.jts.JtsSpatialContext.getShapeFactory",
	"Comment": "todo i expect to delete this eventually once the other deprecated methods in this class disappear",
	"Method": "JtsShapeFactory getShapeFactory(){\r\n    return (JtsShapeFactory) super.getShapeFactory();\r\n}"
}, {
	"Path": "com.projecttango.rajawali.ScenePoseCalculator.toOpenGlCameraPose",
	"Comment": "given the device pose in start of service frame, calculate the correspondingposition and orientation for a opengl scene camera in the rajawali world.",
	"Method": "Pose toOpenGlCameraPose(TangoPoseData devicePose,DeviceExtrinsics extrinsics){\r\n    Matrix4 startServiceTdevice = tangoPoseToMatrix(devicePose);\r\n    Matrix4 openglTDevice = OPENGL_T_TANGO_WORLD.clone().multiply(startServiceTdevice);\r\n    Matrix4 openglWorldTOpenglCamera = openglTDevice.multiply(extrinsics.getDeviceTColorCamera()).multiply(COLOR_CAMERA_T_OPENGL_CAMERA);\r\n    return matrixToPose(openglWorldTOpenglCamera);\r\n}"
}, {
	"Path": "com.novoda.enews.MainSlack.main",
	"Comment": "first param is the slack api keysecond param is a boolean if you want to use mock data",
	"Method": "void main(String[] args){\r\n    if (args.length == 0) {\r\n        throw new IllegalStateException(\"You need to pass a Slack token as the first arg. See https://api.slack.com/web\");\r\n    }\r\n    boolean runLocally = Boolean.parseBoolean(args[1]);\r\n    if (runLocally) {\r\n        System.out.println(\"Running using local mock data\");\r\n    }\r\n    String slackToken = args[0];\r\n    Scraper scraper = new Scraper.Factory().newInstance(slackToken, runLocally);\r\n    LocalDateTime start = LocalDateTime.now();\r\n    LocalDateTime end = LocalDateTime.now().minusDays(6);\r\n    List<ChannelHistory.Message> messages = scraper.scrape(start, end).collect(Collectors.toList());\r\n    messages.forEach(System.out::println);\r\n    System.out.println(\"Total was: \" + messages.size());\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.Tesseract1.createDocumentsWithResults",
	"Comment": "creates documents with ocr results for given renderers at specified pageiterator level.",
	"Method": "List<OCRResult> createDocumentsWithResults(String[] filenames,String[] outputbases,List<ITesseract.RenderedFormat> formats,int pageIteratorLevel){\r\n    if (filenames.length != outputbases.length) {\r\n        throw new RuntimeException(\"The two arrays must match in length.\");\r\n    }\r\n    init();\r\n    setTessVariables();\r\n    List<OCRResult> results = new ArrayList<OCRResult>();\r\n    try {\r\n        for (int i = 0; i < filenames.length; i++) {\r\n            File inputFile = new File(filenames[i]);\r\n            File imageFile = null;\r\n            try {\r\n                imageFile = ImageIOHelper.getImageFile(inputFile);\r\n                TessResultRenderer renderer = createRenderers(outputbases[i], formats);\r\n                int meanTextConfidence = createDocuments(imageFile.getPath(), renderer);\r\n                List<Word> words = meanTextConfidence > 0 ? getRecognizedWords(pageIteratorLevel) : new ArrayList<Word>();\r\n                results.add(new OCRResult(meanTextConfidence, words));\r\n                TessDeleteResultRenderer(renderer);\r\n            } catch (Exception e) {\r\n                logger.warn(e.getMessage(), e);\r\n            } finally {\r\n                if (imageFile != null && imageFile.exists() && imageFile != inputFile && imageFile.getName().startsWith(\"multipage\") && imageFile.getName().endsWith(ImageIOHelper.TIFF_EXT)) {\r\n                    imageFile.delete();\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        dispose();\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SrpClientKeyExchangeParser.parsePublicKey",
	"Comment": "reads the next bytes as the publickey and writes them in the message",
	"Method": "void parsePublicKey(SrpClientKeyExchangeMessage message){\r\n    message.setPublicKey(parseByteArrayField(message.getPublicKeyLength().getValue()));\r\n    LOGGER.debug(\"PublicKey: \" + ArrayConverter.bytesToHexString(message.getPublicKey().getValue()));\r\n}"
}, {
	"Path": "technology.tabula.extractors.SpreadsheetExtractionAlgorithm.extract",
	"Comment": "extract a list of table from page using rulings as separators",
	"Method": "List<Table> extract(Page page,List<Table> extract,Page page,List<Ruling> rulings){\r\n    List<Ruling> horizontalR = new ArrayList(), verticalR = new ArrayList();\r\n    for (Ruling r : rulings) {\r\n        if (r.horizontal()) {\r\n            horizontalR.add(r);\r\n        } else if (r.vertical()) {\r\n            verticalR.add(r);\r\n        }\r\n    }\r\n    horizontalR = Ruling.collapseOrientedRulings(horizontalR);\r\n    verticalR = Ruling.collapseOrientedRulings(verticalR);\r\n    List<Cell> cells = findCells(horizontalR, verticalR);\r\n    List<Rectangle> spreadsheetAreas = findSpreadsheetsFromCells(cells);\r\n    List<Table> spreadsheets = new ArrayList();\r\n    for (Rectangle area : spreadsheetAreas) {\r\n        List<Cell> overlappingCells = new ArrayList();\r\n        for (Cell c : cells) {\r\n            if (c.intersects(area)) {\r\n                c.setTextElements(TextElement.mergeWords(page.getText(c)));\r\n                overlappingCells.add(c);\r\n            }\r\n        }\r\n        List<Ruling> horizontalOverlappingRulings = new ArrayList();\r\n        for (Ruling hr : horizontalR) {\r\n            if (area.intersectsLine(hr)) {\r\n                horizontalOverlappingRulings.add(hr);\r\n            }\r\n        }\r\n        List<Ruling> verticalOverlappingRulings = new ArrayList();\r\n        for (Ruling vr : verticalR) {\r\n            if (area.intersectsLine(vr)) {\r\n                verticalOverlappingRulings.add(vr);\r\n            }\r\n        }\r\n        TableWithRulingLines t = new TableWithRulingLines(area, overlappingCells, horizontalOverlappingRulings, verticalOverlappingRulings, this);\r\n        spreadsheets.add(t);\r\n    }\r\n    Utils.sort(spreadsheets, Rectangle.ILL_DEFINED_ORDER);\r\n    return spreadsheets;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.CertificateVerifyParser.parseSignatureHashAlgorithm",
	"Comment": "reads the next bytes as the signaturehashalgorithm and writes them in themessage",
	"Method": "void parseSignatureHashAlgorithm(CertificateVerifyMessage msg){\r\n    msg.setSignatureHashAlgorithm(parseByteArrayField(HandshakeByteLength.SIGNATURE_HASH_ALGORITHM));\r\n    LOGGER.debug(\"SignatureHashAlgorithm: \" + ArrayConverter.bytesToHexString(msg.getSignatureHashAlgorithm().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2HandshakeMessageParser.parseMessageLength",
	"Comment": "reads the next bytes as the messagelength and writes them in the message",
	"Method": "void parseMessageLength(T message){\r\n    byte[] length;\r\n    int mask;\r\n    if ((peek() & (byte) 0x80) != 0) {\r\n        length = parseByteArrayField(SSL2ByteLength.LENGTH);\r\n        mask = 0x3f;\r\n    } else {\r\n        length = parseByteArrayField(SSL2ByteLength.LONG_LENGTH);\r\n        mask = 0x7f;\r\n    }\r\n    int intLength = ((length[0] & mask) << 8) | (length[1] & 0xFF);\r\n    message.setMessageLength(intLength);\r\n    LOGGER.debug(\"MessageLength: \" + message.getMessageLength().getValue());\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.identity.UserAuthentication.createIdentityTable",
	"Comment": "used to create the identity table. this function only needs to be calledonce.",
	"Method": "void createIdentityTable(){\r\n    ProvisionedThroughput provisionedThroughput = new ProvisionedThroughput().withReadCapacityUnits(10L).withWriteCapacityUnits(5L);\r\n    ArrayList<AttributeDefinition> attributeDefinitions = new ArrayList<AttributeDefinition>();\r\n    attributeDefinitions.add(new AttributeDefinition().withAttributeName(ATTRIBUTE_USERNAME).withAttributeType(\"S\"));\r\n    ArrayList<KeySchemaElement> tableKeySchema = new ArrayList<KeySchemaElement>();\r\n    tableKeySchema.add(new KeySchemaElement().withAttributeName(ATTRIBUTE_USERNAME).withKeyType(KeyType.HASH));\r\n    CreateTableRequest createTableRequest = new CreateTableRequest().withTableName(USER_TABLE).withProvisionedThroughput(provisionedThroughput).withAttributeDefinitions(attributeDefinitions).withKeySchema(tableKeySchema);\r\n    try {\r\n        ddb.createTable(createTableRequest);\r\n    } catch (AmazonClientException e) {\r\n        throw new DataAccessException(\"Failed to create table: \" + USER_TABLE, e);\r\n    }\r\n}"
}, {
	"Path": "com.android.vending.billing.util.Inventory.getPurchase",
	"Comment": "returns purchase information for a given product, or null if there is no purchase.",
	"Method": "Purchase getPurchase(String sku){\r\n    return mPurchaseMap.get(sku);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.record.cipher.RecordBlockCipherTest.testDecrypt10",
	"Comment": "test of decrypt method, of class recordblockcipher, for tls10.",
	"Method": "void testDecrypt10(){\r\n    context.setConnection(new OutboundConnection());\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA);\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS10);\r\n    context.setClientRandom(ArrayConverter.hexStringToByteArray(\"03c08c3460b420bb3851d9d47acb933dbe70399bf6c92da33af01d4fb770e98c\"));\r\n    context.setServerRandom(ArrayConverter.hexStringToByteArray(\"78f0c84e04d3c23cad94aad61ccae23ce79bcd9d2d6953f8ccbe0e528c63a238\"));\r\n    context.setMasterSecret(ArrayConverter.hexStringToByteArray(\"F81015161244782B3541E6020140556E4FFEA98C57FCF6CEC172CD8B577DC73CCDE4B724E07DB8687DDF327CD8A68891\"));\r\n    byte[] data = ArrayConverter.hexStringToByteArray(\"BCD644DF7E82BF0097E1B0C16CDD53199733EE70629FA82DAC7B0B4F6100B602ACBA3B8EA6A7741B\");\r\n    cipher = new RecordBlockCipher(context, KeySetGenerator.generateKeySet(context));\r\n    byte[] plaintext = cipher.decrypt(new DecryptionRequest(null, data)).getDecryptedCipherText();\r\n    byte[] correctPlaintext = ArrayConverter.hexStringToByteArray(\"1400000CC84350158844FE559EC327B77F44B9791ECB11453B7FC40ED27C35DDDC7C250603030303\");\r\n    assertArrayEquals(plaintext, correctPlaintext);\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPITest.testTessBaseAPIGetAvailableLanguagesAsVector",
	"Comment": "test of tessbaseapigetavailablelanguagesasvector method, of classtessapi.",
	"Method": "void testTessBaseAPIGetAvailableLanguagesAsVector(){\r\n    logger.info(\"TessBaseAPIGetAvailableLanguagesAsVector\");\r\n    api.TessBaseAPIInit3(handle, datapath, language);\r\n    String[] expResult = { \"eng\" };\r\n    String[] result = api.TessBaseAPIGetAvailableLanguagesAsVector(handle).getPointer().getStringArray(0);\r\n    assertTrue(Arrays.asList(result).containsAll(Arrays.asList(expResult)));\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.identity.AWSCognitoDeveloperAuthenticationSample.registerUser",
	"Comment": "allows users to register with awscognitodeveloperauthenticationsample. this functionis useful in identity mode",
	"Method": "boolean registerUser(String username,String password,String endpoint){\r\n    return userAuthenticator.registerUser(username, password, endpoint);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.EllipticCurvesExtensionHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class ellipticcurvesextensionhandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new EllipticCurvesExtensionMessage()) instanceof EllipticCurvesExtensionSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.record.cipher.RecordBlockCipherTest.testDecrypt12",
	"Comment": "test of decrypt method, of class recordblockcipher, for tls12.",
	"Method": "void testDecrypt12(){\r\n    RandomHelper.setRandom(new BadRandom(new Random(0), null));\r\n    context.setConnection(new OutboundConnection());\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA256);\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS12);\r\n    context.setClientRandom(ArrayConverter.hexStringToByteArray(\"03c08c3460b420bb3851d9d47acb933dbe70399bf6c92da33af01d4fb770e98c\"));\r\n    context.setServerRandom(ArrayConverter.hexStringToByteArray(\"78f0c84e04d3c23cad94aad61ccae23ce79bcd9d2d6953f8ccbe0e528c63a238\"));\r\n    context.setMasterSecret(ArrayConverter.hexStringToByteArray(\"F81015161244782B3541E6020140556E4FFEA98C57FCF6CEC172CD8B577DC73CCDE4B724E07DB8687DDF327CD8A68891\"));\r\n    byte[] data = ArrayConverter.hexStringToByteArray(\"45DCB1853201C59037AFF4DFE3F442B7CDB4DB1348894AE76E251F4491A6F5F859B2DE12879C6D86D4BDC83CAB854E33EF5CC51B25942E64EC6730AB1DDB5806E900B7B0C32D9BFF59C0F01334C0F673\");\r\n    cipher = new RecordBlockCipher(context, KeySetGenerator.generateKeySet(context));\r\n    byte[] plaintext = cipher.decrypt(new DecryptionRequest(null, data)).getDecryptedCipherText();\r\n    byte[] correctPlaintext = ArrayConverter.hexStringToByteArray(\"7F1F9E3AA2EAD435ED42143C54D81FEDAC85A400AF369CABFA1B77EBB3647B534FB8447306D14FE610F897EBE455A43ED47140370DB20BF3181067641D20E425\");\r\n    assertArrayEquals(plaintext, correctPlaintext);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.ServerNameIndicationExtensionHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of classservernameindicationextensionhandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new ServerNameIndicationExtensionMessage()) instanceof ServerNameIndicationExtensionPreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.https.HttpsResponseSerializerTest.testSerializeProtocolMessageContent",
	"Comment": "test of serializeprotocolmessagecontent method, of classhttpsresponseserializer.",
	"Method": "void testSerializeProtocolMessageContent(){\r\n    HttpsResponseParser parser = new HttpsResponseParser(0, msg, version);\r\n    HttpsResponseMessage parsedMsg = parser.parse();\r\n    HttpsResponseSerializer serializer = new HttpsResponseSerializer(parsedMsg, version);\r\n    assertArrayEquals(expPart, serializer.serialize());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.factory.WorkflowConfigurationFactoryTest.testCreateHelloWorkflow",
	"Comment": "test of createhelloworkflow method, of classworkflowconfigurationfactory.",
	"Method": "void testCreateHelloWorkflow(){\r\n    WorkflowTrace helloWorkflow;\r\n    MessageAction firstAction;\r\n    MessageAction messageAction1;\r\n    MessageAction messageAction2;\r\n    ReceiveAction lastAction;\r\n    ClientHelloMessage clientHelloMessage;\r\n    WorkflowConfigurationFactory factory = new WorkflowConfigurationFactory(config);\r\n    helloWorkflow = factory.createWorkflowTrace(WorkflowTraceType.HELLO, RunningModeType.CLIENT);\r\n    Assert.assertThat(helloWorkflow.getMessageActions().size(), Matchers.greaterThanOrEqualTo(2));\r\n    firstAction = helloWorkflow.getMessageActions().get(0);\r\n    Assert.assertEquals(ReceiveAction.class, helloWorkflow.getLastMessageAction().getClass());\r\n    lastAction = (ReceiveAction) helloWorkflow.getLastMessageAction();\r\n    Assert.assertEquals(1, firstAction.getMessages().size());\r\n    Assert.assertThat(lastAction.getExpectedMessages().size(), Matchers.greaterThanOrEqualTo(1));\r\n    Assert.assertEquals(firstAction.getMessages().get(0).getClass(), de.rub.nds.tlsattacker.core.protocol.message.ClientHelloMessage.class);\r\n    Assert.assertEquals(lastAction.getExpectedMessages().get(0).getClass(), de.rub.nds.tlsattacker.core.protocol.message.ServerHelloMessage.class);\r\n    config.setHighestProtocolVersion(ProtocolVersion.DTLS10);\r\n    config.setClientAuthentication(false);\r\n    workflowConfigurationFactory = new WorkflowConfigurationFactory(config);\r\n    helloWorkflow = workflowConfigurationFactory.createWorkflowTrace(WorkflowTraceType.HELLO, RunningModeType.CLIENT);\r\n    firstAction = helloWorkflow.getMessageActions().get(0);\r\n    clientHelloMessage = (ClientHelloMessage) firstAction.getMessages().get(0);\r\n    Assert.assertFalse(clientHelloMessage.getIncludeInDigest());\r\n    Assert.assertThat(helloWorkflow.getMessageActions().size(), Matchers.greaterThanOrEqualTo(4));\r\n    Assert.assertNotNull(helloWorkflow.getMessageActions().get(1));\r\n    Assert.assertNotNull(helloWorkflow.getMessageActions().get(2));\r\n    messageAction1 = helloWorkflow.getMessageActions().get(1);\r\n    messageAction2 = helloWorkflow.getMessageActions().get(2);\r\n    Assert.assertEquals(ReceiveAction.class, messageAction1.getClass());\r\n    Assert.assertEquals(HelloVerifyRequestMessage.class, ((ReceiveAction) messageAction1).getExpectedMessages().get(0).getClass());\r\n    Assert.assertEquals(ClientHelloMessage.class, messageAction2.getMessages().get(0).getClass());\r\n    lastAction = (ReceiveAction) helloWorkflow.getLastMessageAction();\r\n    Assert.assertEquals(lastAction.getExpectedMessages().get(1).getClass(), de.rub.nds.tlsattacker.core.protocol.message.CertificateMessage.class);\r\n    config.setHighestProtocolVersion(ProtocolVersion.DTLS10);\r\n    config.setClientAuthentication(true);\r\n    config.setDefaultSelectedCipherSuite(CipherSuite.TLS_DHE_DSS_WITH_AES_256_GCM_SHA384);\r\n    workflowConfigurationFactory = new WorkflowConfigurationFactory(config);\r\n    helloWorkflow = workflowConfigurationFactory.createWorkflowTrace(WorkflowTraceType.HELLO, RunningModeType.CLIENT);\r\n    lastAction = (ReceiveAction) helloWorkflow.getLastMessageAction();\r\n    Assert.assertNotNull(lastAction.getExpectedMessages().get(2));\r\n    Assert.assertEquals(lastAction.getExpectedMessages().get(3).getClass(), de.rub.nds.tlsattacker.core.protocol.message.CertificateRequestMessage.class);\r\n}"
}, {
	"Path": "org.sonar.plugins.java.JavaPlugin.isAnalysisWarningsSupported",
	"Comment": "drop this and related when the minimum supported version of sonarjava reaches 7.4.",
	"Method": "boolean isAnalysisWarningsSupported(SonarRuntime runtime){\r\n    return runtime.getApiVersion().isGreaterThanOrEqual(ANALYSIS_WARNINGS_MIN_SUPPORTED_SQ_VERSION) && runtime.getProduct() != SonarProduct.SONARLINT;\r\n}"
}, {
	"Path": "com.novoda.spikes.arcore.poly.copied.PolyObjectRenderer.createOnGlThread",
	"Comment": "creates and initializes opengl resources needed for rendering the model.",
	"Method": "void createOnGlThread(Context context,byte[] objBytes,byte[] textureBytes){\r\n    Bitmap textureBitmap = BitmapFactory.decodeByteArray(textureBytes, 0, textureBytes.length);\r\n    GLES20.glActiveTexture(GLES20.GL_TEXTURE0);\r\n    GLES20.glGenTextures(mTextures.length, mTextures, 0);\r\n    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mTextures[0]);\r\n    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR_MIPMAP_LINEAR);\r\n    GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);\r\n    GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, textureBitmap, 0);\r\n    GLES20.glGenerateMipmap(GLES20.GL_TEXTURE_2D);\r\n    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);\r\n    textureBitmap.recycle();\r\n    ShaderUtil.checkGLError(TAG, \"Texture loading\");\r\n    ByteArrayInputStream objInputStream = new ByteArrayInputStream(objBytes);\r\n    Obj obj = ObjReader.read(objInputStream);\r\n    obj = ObjUtils.convertToRenderable(obj);\r\n    String infoString = ObjUtils.createInfoString(obj);\r\n    IntBuffer wideIndices = ObjData.getFaceVertexIndices(obj, 3);\r\n    FloatBuffer vertices = ObjData.getVertices(obj);\r\n    FloatBuffer texCoords = ObjData.getTexCoords(obj, 2);\r\n    FloatBuffer normals = ObjData.getNormals(obj);\r\n    int verticesAll = 0;\r\n    while (vertices.hasRemaining()) {\r\n        float x = vertices.get();\r\n        float y = vertices.get();\r\n        float z = vertices.get();\r\n        encapsulateInBounds(x, y, z);\r\n        verticesAll++;\r\n    }\r\n    vertices.rewind();\r\n    ShortBuffer indices = ByteBuffer.allocateDirect(2 * wideIndices.limit()).order(ByteOrder.nativeOrder()).asShortBuffer();\r\n    while (wideIndices.hasRemaining()) {\r\n        indices.put((short) wideIndices.get());\r\n    }\r\n    indices.rewind();\r\n    int[] buffers = new int[2];\r\n    GLES20.glGenBuffers(2, buffers, 0);\r\n    mVertexBufferId = buffers[0];\r\n    mIndexBufferId = buffers[1];\r\n    mVerticesBaseAddress = 0;\r\n    mTexCoordsBaseAddress = mVerticesBaseAddress + 4 * vertices.limit();\r\n    mNormalsBaseAddress = mTexCoordsBaseAddress + 4 * texCoords.limit();\r\n    final int totalBytes = mNormalsBaseAddress + 4 * normals.limit();\r\n    GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, mVertexBufferId);\r\n    GLES20.glBufferData(GLES20.GL_ARRAY_BUFFER, totalBytes, null, GLES20.GL_STATIC_DRAW);\r\n    GLES20.glBufferSubData(GLES20.GL_ARRAY_BUFFER, mVerticesBaseAddress, 4 * vertices.limit(), vertices);\r\n    GLES20.glBufferSubData(GLES20.GL_ARRAY_BUFFER, mTexCoordsBaseAddress, 4 * texCoords.limit(), texCoords);\r\n    GLES20.glBufferSubData(GLES20.GL_ARRAY_BUFFER, mNormalsBaseAddress, 4 * normals.limit(), normals);\r\n    GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0);\r\n    GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER, mIndexBufferId);\r\n    mIndexCount = indices.limit();\r\n    GLES20.glBufferData(GLES20.GL_ELEMENT_ARRAY_BUFFER, 2 * mIndexCount, indices, GLES20.GL_STATIC_DRAW);\r\n    GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER, 0);\r\n    ShaderUtil.checkGLError(TAG, \"OBJ buffer load\");\r\n    final int vertexShader = ShaderUtil.loadGLShader(TAG, context, GLES20.GL_VERTEX_SHADER, VERTEX_SHADER_NAME);\r\n    final int fragmentShader = ShaderUtil.loadGLShader(TAG, context, GLES20.GL_FRAGMENT_SHADER, FRAGMENT_SHADER_NAME);\r\n    mProgram = GLES20.glCreateProgram();\r\n    GLES20.glAttachShader(mProgram, vertexShader);\r\n    GLES20.glAttachShader(mProgram, fragmentShader);\r\n    GLES20.glLinkProgram(mProgram);\r\n    GLES20.glUseProgram(mProgram);\r\n    ShaderUtil.checkGLError(TAG, \"Program creation\");\r\n    mModelViewUniform = GLES20.glGetUniformLocation(mProgram, \"u_ModelView\");\r\n    mModelViewProjectionUniform = GLES20.glGetUniformLocation(mProgram, \"u_ModelViewProjection\");\r\n    mPositionAttribute = GLES20.glGetAttribLocation(mProgram, \"a_Position\");\r\n    mNormalAttribute = GLES20.glGetAttribLocation(mProgram, \"a_Normal\");\r\n    mTexCoordAttribute = GLES20.glGetAttribLocation(mProgram, \"a_TexCoord\");\r\n    mTextureUniform = GLES20.glGetUniformLocation(mProgram, \"u_Texture\");\r\n    mLightingParametersUniform = GLES20.glGetUniformLocation(mProgram, \"u_LightingParameters\");\r\n    mMaterialParametersUniform = GLES20.glGetUniformLocation(mProgram, \"u_MaterialParameters\");\r\n    colorCorrectionParameterUniform = GLES20.glGetUniformLocation(mProgram, \"u_ColorCorrectionParameters\");\r\n    ShaderUtil.checkGLError(TAG, \"Program parameters\");\r\n    Matrix.setIdentityM(mModelMatrix, 0);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.AlertParser.parseDescription",
	"Comment": "reads the next bytes as a description and writes them in the message",
	"Method": "void parseDescription(AlertMessage msg){\r\n    msg.setDescription(parseByteField(AlertByteLength.DESCRIPTION_LENGTH));\r\n    LOGGER.debug(\"Description: \" + msg.getDescription().getValue());\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.util.RobotsTags.normaliseToMetadata",
	"Comment": "adds a normalised representation of the directives in the metadata",
	"Method": "void normaliseToMetadata(Metadata metadata){\r\n    metadata.setValue(ROBOTS_NO_INDEX, Boolean.toString(noIndex));\r\n    metadata.setValue(ROBOTS_NO_CACHE, Boolean.toString(noCache));\r\n    metadata.setValue(ROBOTS_NO_FOLLOW, Boolean.toString(noFollow));\r\n}"
}, {
	"Path": "com.projecttango.rajawali.ScenePoseCalculator.matrixToPose",
	"Comment": "helper method to extract a pose object from a transformation matrix taking into accountrajawali conventions.",
	"Method": "Pose matrixToPose(Matrix4 m){\r\n    Vector3 p = m.getTranslation();\r\n    Quaternion q = new Quaternion();\r\n    q.fromMatrix(m);\r\n    q.conjugate();\r\n    return new Pose(p, q);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetSelectedCurve",
	"Comment": "test of getselectednamedgroup method, of class defaultchooser.",
	"Method": "void testGetSelectedCurve(){\r\n    context.setSelectedGroup(null);\r\n    config.setDefaultSelectedNamedGroup(NamedGroup.FFDHE2048);\r\n    assertEquals(NamedGroup.FFDHE2048, config.getDefaultSelectedNamedGroup());\r\n    assertEquals(NamedGroup.FFDHE2048, chooser.getSelectedNamedGroup());\r\n    context.setSelectedGroup(NamedGroup.SECT163R1);\r\n    assertEquals(NamedGroup.SECT163R1, chooser.getSelectedNamedGroup());\r\n}"
}, {
	"Path": "com.android.vending.billing.util.IabHelper.getResponseCodeFromIntent",
	"Comment": "workaround to bug where sometimes response codes come as long instead of integer",
	"Method": "int getResponseCodeFromIntent(Intent i){\r\n    Object o = i.getExtras().get(RESPONSE_CODE);\r\n    if (o == null) {\r\n        logError(\"Intent with no response code, assuming OK (known issue)\");\r\n        return BILLING_RESPONSE_RESULT_OK;\r\n    } else if (o instanceof Integer)\r\n        return ((Integer) o).intValue();\r\n    else if (o instanceof Long)\r\n        return (int) ((Long) o).longValue();\r\n    else {\r\n        logError(\"Unexpected type for intent response code.\");\r\n        logError(o.getClass().getName());\r\n        throw new RuntimeException(\"Unexpected type for intent response code: \" + o.getClass().getName());\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.KeyShareExtensionHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class keyshareextensionhandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[] { 0, 2, 3 }, 0) instanceof KeyShareExtensionParser);\r\n}"
}, {
	"Path": "org.takes.rq.multipart.RqMtBase.make",
	"Comment": "make a request. scans the origin request until the boundary reached. caches thecontent into a temporary file and returns it as a new request.",
	"Method": "Request make(byte[] boundary,ReadableByteChannel body){\r\n    final File file = File.createTempFile(RqMultipart.class.getName(), \".tmp\");\r\n    try (WritableByteChannel channel = Files.newByteChannel(file.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {\r\n        channel.write(ByteBuffer.wrap(this.head().iterator().next().getBytes(RqMtBase.ENCODING)));\r\n        channel.write(ByteBuffer.wrap(RqMtBase.CRLF.getBytes(RqMtBase.ENCODING)));\r\n        this.copy(channel, boundary, body);\r\n    }\r\n    return new RqTemp(file);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.KeyShareExtensionParser.parseKeyShareListLength",
	"Comment": "reads the next bytes as the keysahrelistlength of the extension andwrites them in the message",
	"Method": "void parseKeyShareListLength(KeyShareExtensionMessage msg){\r\n    msg.setKeyShareListLength(parseIntField(ExtensionByteLength.KEY_SHARE_LIST_LENGTH));\r\n    LOGGER.debug(\"KeyShareListLength: \" + msg.getKeyShareListLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskEcDheServerKeyExchangeHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class pskecdheserverkeyexchangehandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof PskEcDheServerKeyExchangeParser);\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.util.URLUtil.fixPureQueryTargets",
	"Comment": "handle the case in rfc3986 section 5.4.1 example 7, and similar.",
	"Method": "URL fixPureQueryTargets(URL base,String target){\r\n    if (!target.startsWith(\"?\"))\r\n        return new URL(base, target);\r\n    String basePath = base.getPath();\r\n    String baseRightMost = \"\";\r\n    int baseRightMostIdx = basePath.lastIndexOf(\"/\");\r\n    if (baseRightMostIdx != -1) {\r\n        baseRightMost = basePath.substring(baseRightMostIdx + 1);\r\n    }\r\n    if (target.startsWith(\"?\"))\r\n        target = baseRightMost + target;\r\n    return new URL(base, target);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetServerHandshakeTrafficSecret",
	"Comment": "test of getserverhandshaketrafficsecret method, of class defaultchooser.",
	"Method": "void testGetServerHandshakeTrafficSecret(){\r\n    context.setServerHandshakeTrafficSecret(null);\r\n    byte[] secret = ArrayConverter.hexStringToByteArray(\"122131123987891238098123\");\r\n    byte[] secret2 = ArrayConverter.hexStringToByteArray(\"1221311239878912380981281294\");\r\n    config.setDefaultServerHandshakeTrafficSecret(secret);\r\n    assertArrayEquals(secret, config.getDefaultServerHandshakeTrafficSecret());\r\n    assertArrayEquals(secret, chooser.getServerHandshakeTrafficSecret());\r\n    context.setServerHandshakeTrafficSecret(secret2);\r\n    assertArrayEquals(secret2, chooser.getServerHandshakeTrafficSecret());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetDhServerPrivateKey",
	"Comment": "test of getdhserverprivatekey method, of class defaultchooser.",
	"Method": "void testGetDhServerPrivateKey(){\r\n    context.setServerDhPrivateKey(null);\r\n    config.setDefaultServerDhPrivateKey(BigInteger.ONE);\r\n    assertEquals(BigInteger.ONE, config.getDefaultServerDhPrivateKey());\r\n    assertEquals(BigInteger.ONE, chooser.getDhServerPrivateKey());\r\n    context.setServerDhPrivateKey(BigInteger.TEN);\r\n    assertEquals(BigInteger.TEN, chooser.getDhServerPrivateKey());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.EllipticCurveDelegateTest.testGetNamedCurves",
	"Comment": "test of getnamedcurves method, of class namedgroupsdelegate.",
	"Method": "void testGetNamedCurves(){\r\n    args = new String[2];\r\n    args[0] = \"-named_group\";\r\n    args[1] = \"SECP192R1,SECP256R1\";\r\n    jcommander.parse(args);\r\n    assertTrue(\"SECP192R1 should get parsed correctly\", delegate.getNamedGroups().contains(NamedGroup.SECP192R1));\r\n    assertTrue(\"SECP256R1 should get parsed correctly\", delegate.getNamedGroups().contains(NamedGroup.SECP256R1));\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.identity.UserAuthentication.storeUser",
	"Comment": "store the username, password combination in the identity table. theusername will represent the item name and the item will contain aattributes password and userid.",
	"Method": "void storeUser(String username,String password,String uri){\r\n    if (null == username || null == password) {\r\n        return;\r\n    }\r\n    String hashedSaltedPassword = Utilities.getSaltedPassword(username, uri, password);\r\n    Map<String, AttributeValue> item = new HashMap<String, AttributeValue>();\r\n    item.put(ATTRIBUTE_USERNAME, new AttributeValue().withS(username));\r\n    item.put(ATTRIBUTE_HASH_SALTED_PASSWORD, new AttributeValue().withS(hashedSaltedPassword));\r\n    item.put(ATTRIBUTE_ENABLED, new AttributeValue().withS(\"true\"));\r\n    PutItemRequest putItemRequest = new PutItemRequest().withTableName(USER_TABLE).withItem(item);\r\n    try {\r\n        ddb.putItem(putItemRequest);\r\n    } catch (AmazonClientException e) {\r\n        throw new DataAccessException(\"Failed to store user: \" + username, e);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.attacks.actions.EarlyCcsAction.execute",
	"Comment": "sends a clientkeyexchange message depending on the currently selectedciphersuite. depening on the target version cryptographic material isadjusted.",
	"Method": "void execute(State state){\r\n    WorkflowConfigurationFactory factory = new WorkflowConfigurationFactory(state.getConfig());\r\n    ClientKeyExchangeMessage message = factory.createClientKeyExchangeMessage(AlgorithmResolver.getKeyExchangeAlgorithm(state.getTlsContext().getChooser().getSelectedCipherSuite()));\r\n    ModifiableBoolean modifiableBoolean = new ModifiableBoolean();\r\n    modifiableBoolean.setModification(new BooleanExplicitValueModification(false));\r\n    if (!targetOpenssl1_0_0) {\r\n        message.setIncludeInDigest(modifiableBoolean);\r\n    }\r\n    message.setAdjustContext(modifiableBoolean);\r\n    ClientKeyExchangeHandler handler = (ClientKeyExchangeHandler) message.getHandler(state.getTlsContext());\r\n    byte[] protocolMessageBytes = handler.prepareMessage(message);\r\n    if (targetOpenssl1_0_0) {\r\n        handler.adjustPremasterSecret(message);\r\n        handler.adjustMasterSecret(message);\r\n    }\r\n    handler.adjustTlsContextAfterSerialize(message);\r\n    List<AbstractRecord> recordList = new LinkedList();\r\n    recordList.add(new Record());\r\n    byte[] prepareRecords = state.getTlsContext().getRecordLayer().prepareRecords(protocolMessageBytes, ProtocolMessageType.HANDSHAKE, recordList);\r\n    state.getTlsContext().getTransportHandler().sendData(prepareRecords);\r\n    setExecuted(true);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ClientHelloParser.parseChallenge",
	"Comment": "reads the next bytes as the challenge and writes them in the message",
	"Method": "void parseChallenge(SSL2ClientHelloMessage msg){\r\n    msg.setChallenge(parseByteArrayField(msg.getChallengeLength().getValue()));\r\n    LOGGER.debug(\"Challenge: \" + ArrayConverter.bytesToHexString(msg.getChallenge().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.ChangeCipherSpecPreparatorTest.testPrepare",
	"Comment": "test of prepareprotocolmessagecontents method, of classchangecipherspecpreparator.",
	"Method": "void testPrepare(){\r\n    preparator.prepare();\r\n    assertTrue(message.getCcsProtocolType().getValue() == 1);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.attacks.pkcs1.oracles.TestPkcs1Oracle.checkThird",
	"Comment": "returns true if and only if the message contains the 0x00 byte on thecorrect position in the plaintext.",
	"Method": "boolean checkThird(byte[] msg){\r\n    boolean result = false;\r\n    if (hasCorrectKeySize(48, msg)) {\r\n        result = true;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ECDHClientKeyExchangeParserTest.testParse",
	"Comment": "test of parse method, of class ecdhclientkeyexchangeparser.",
	"Method": "void testParse(){\r\n    ECDHClientKeyExchangeParser<ECDHClientKeyExchangeMessage> parser = new ECDHClientKeyExchangeParser(0, message, version);\r\n    ECDHClientKeyExchangeMessage msg = parser.parse();\r\n    assertArrayEquals(message, msg.getCompleteResultingMessage().getValue());\r\n    assertTrue(msg.getLength().getValue() == length);\r\n    assertTrue(msg.getType().getValue() == type.getValue());\r\n    assertTrue(serializedKeyLength == msg.getPublicKeyLength().getValue());\r\n    assertArrayEquals(serializedKey, msg.getPublicKey().getValue());\r\n}"
}, {
	"Path": "org.takes.facets.ret.TkReturnTest.redirectsAndRemovesCookie",
	"Comment": "tkreturn can redirect to return locationand remove a return cookie.",
	"Method": "void redirectsAndRemovesCookie(){\r\n    final Take take = new TkReturn(new TkEmpty());\r\n    final String destination = \"/return/to\";\r\n    MatcherAssert.assertThat(take.act(new RqWithHeader(new RqFake(), String.format(\"Cookie: RsReturn=%s;\", URLEncoder.encode(destination, Charset.defaultCharset().name())))).head(), Matchers.contains(\"HTTP/1.1 303 See Other\", String.format(\"Location: %s\", destination), \"Set-Cookie: RsReturn=;\"));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.KeyShareExtensionParser.parseKeyShareList",
	"Comment": "reads the next bytes as the keysharelist of the extension and writes themin the message",
	"Method": "void parseKeyShareList(KeyShareExtensionMessage msg){\r\n    msg.setKeyShareList(entryList);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.attacks.bruteforce.GuessProviderFactory.createGuessProvider",
	"Comment": "creates guessprovider objects based on a guessprovidertype. someguessprovider require an inputsource to create their guesses. if theguessprovider does not use an inputstream, the inputstream is ignored",
	"Method": "GuessProvider createGuessProvider(GuessProviderType type,InputStream guessSource){\r\n    switch(type) {\r\n        case INCREMENTING:\r\n            return new IncrementingGuessProvider();\r\n        case WORDLIST:\r\n            return new WordListGuessProvider(guessSource);\r\n        default:\r\n            throw new UnsupportedOperationException(\"Guess provider \\\"\" + type + \"\\\" is not supported\");\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.Parser.parseByteField",
	"Comment": "parses a number of bytes from the array and returns them as a byte.throws a parserexception if the number of bytes cannot be parsed. movesthe pointer accordingly.",
	"Method": "byte parseByteField(int length){\r\n    if (length == 0) {\r\n        throw new ParserException(\"Cannot parse byte of size 0\");\r\n    }\r\n    if (length > 1) {\r\n        LOGGER.warn(\"Parsing byte[] field into a byte of size >1\");\r\n    }\r\n    return (byte) ArrayConverter.bytesToInt(parseByteArrayField(length));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.HelloRequestSerializerTest.testSerializeHandshakeMessageContent",
	"Comment": "test of serializehandshakemessagecontent method, of classhellorequestserializer.",
	"Method": "void testSerializeHandshakeMessageContent(){\r\n    HelloRequestMessage msg = new HelloRequestMessage();\r\n    msg.setCompleteResultingMessage(expectedPart);\r\n    msg.setLength(length);\r\n    msg.setType(type.getValue());\r\n    HelloRequestSerializer serializer = new HelloRequestSerializer(msg, ProtocolVersion.TLS12);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.SendAsciiActionTest.testExecuteWorkflowExecutionException",
	"Comment": "test of workflowexecutionexception of execute method, of classsendasciiaction.",
	"Method": "void testExecuteWorkflowExecutionException(){\r\n    action.execute(state);\r\n    action.execute(state);\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPITest.testTessBaseAPIGetBoolVariable",
	"Comment": "test of tessbaseapigetboolvariable method, of class tessapi.",
	"Method": "void testTessBaseAPIGetBoolVariable(){\r\n    logger.info(\"TessBaseAPIGetBoolVariable\");\r\n    String name = \"tessedit_create_hocr\";\r\n    api.TessBaseAPISetVariable(handle, name, \"1\");\r\n    IntBuffer value = IntBuffer.allocate(1);\r\n    int result = -1;\r\n    if (api.TessBaseAPIGetBoolVariable(handle, \"tessedit_create_hocr\", value) == TRUE) {\r\n        result = value.get(0);\r\n    }\r\n    int expResult = 1;\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.socket.TlsAttackerSocketTest.testReceiveString",
	"Comment": "test of receivestring method, of class tlsattackersocket.",
	"Method": "void testReceiveString(){\r\n    transportHandler.setFetchableByte(ArrayConverter.concatenate(new byte[] { 0x17, 0x03, 0x03, 0x00, 0x04 }, \"test\".getBytes(Charset.forName(\"ASCII\"))));\r\n    String receivedString = socket.receiveString();\r\n    assertEquals(\"test\", receivedString);\r\n}"
}, {
	"Path": "com.novoda.spikes.arcore.google.rendering.PlaneRenderer.drawPlanes",
	"Comment": "draws the collection of tracked planes, with closer planes hiding more distant ones.",
	"Method": "void drawPlanes(Collection<Plane> allPlanes,Pose cameraPose,float[] cameraPerspective){\r\n    List<SortablePlane> sortedPlanes = new ArrayList();\r\n    float[] normal = new float[3];\r\n    float cameraX = cameraPose.tx();\r\n    float cameraY = cameraPose.ty();\r\n    float cameraZ = cameraPose.tz();\r\n    for (Plane plane : allPlanes) {\r\n        if (plane.getTrackingState() != TrackingState.TRACKING || plane.getSubsumedBy() != null) {\r\n            continue;\r\n        }\r\n        Pose center = plane.getCenterPose();\r\n        center.getTransformedAxis(1, 1.0f, normal, 0);\r\n        float distance = (cameraX - center.tx()) * normal[0] + (cameraY - center.ty()) * normal[1] + (cameraZ - center.tz()) * normal[2];\r\n        if (distance < 0) {\r\n            continue;\r\n        }\r\n        sortedPlanes.add(new SortablePlane(distance, plane));\r\n    }\r\n    Collections.sort(sortedPlanes, new Comparator<SortablePlane>() {\r\n        @Override\r\n        public int compare(SortablePlane a, SortablePlane b) {\r\n            return Float.compare(a.distance, b.distance);\r\n        }\r\n    });\r\n    float[] cameraView = new float[16];\r\n    cameraPose.inverse().toMatrix(cameraView, 0);\r\n    GLES20.glClearColor(1, 1, 1, 1);\r\n    GLES20.glColorMask(false, false, false, true);\r\n    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);\r\n    GLES20.glColorMask(true, true, true, true);\r\n    GLES20.glDepthMask(false);\r\n    GLES20.glEnable(GLES20.GL_BLEND);\r\n    // RGB (src, dest)\r\n    GLES20.glBlendFuncSeparate(GLES20.GL_DST_ALPHA, // ALPHA (src, dest)\r\n    GLES20.GL_ONE, GLES20.GL_ZERO, GLES20.GL_ONE_MINUS_SRC_ALPHA);\r\n    GLES20.glUseProgram(planeProgram);\r\n    GLES20.glActiveTexture(GLES20.GL_TEXTURE0);\r\n    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textures[0]);\r\n    GLES20.glUniform1i(textureUniform, 0);\r\n    GLES20.glUniform4fv(gridControlUniform, 1, GRID_CONTROL, 0);\r\n    GLES20.glEnableVertexAttribArray(planeXZPositionAlphaAttribute);\r\n    ShaderUtil.checkGLError(TAG, \"Setting up to draw planes\");\r\n    for (SortablePlane sortedPlane : sortedPlanes) {\r\n        Plane plane = sortedPlane.plane;\r\n        float[] planeMatrix = new float[16];\r\n        plane.getCenterPose().toMatrix(planeMatrix, 0);\r\n        updatePlaneParameters(planeMatrix, plane.getExtentX(), plane.getExtentZ(), plane.getPolygon());\r\n        Integer planeIndex = planeIndexMap.get(plane);\r\n        if (planeIndex == null) {\r\n            planeIndex = planeIndexMap.size();\r\n            planeIndexMap.put(plane, planeIndex);\r\n        }\r\n        int colorIndex = planeIndex % PLANE_COLORS_RGBA.length;\r\n        colorRgbaToFloat(planeColor, PLANE_COLORS_RGBA[colorIndex]);\r\n        GLES20.glUniform4fv(lineColorUniform, 1, planeColor, 0);\r\n        GLES20.glUniform4fv(dotColorUniform, 1, planeColor, 0);\r\n        float angleRadians = planeIndex * 0.144f;\r\n        float uScale = DOTS_PER_METER;\r\n        float vScale = DOTS_PER_METER * EQUILATERAL_TRIANGLE_SCALE;\r\n        planeAngleUvMatrix[0] = +(float) Math.cos(angleRadians) * uScale;\r\n        planeAngleUvMatrix[1] = -(float) Math.sin(angleRadians) * vScale;\r\n        planeAngleUvMatrix[2] = +(float) Math.sin(angleRadians) * uScale;\r\n        planeAngleUvMatrix[3] = +(float) Math.cos(angleRadians) * vScale;\r\n        GLES20.glUniformMatrix2fv(planeUvMatrixUniform, 1, false, planeAngleUvMatrix, 0);\r\n        draw(cameraView, cameraPerspective);\r\n    }\r\n    GLES20.glDisableVertexAttribArray(planeXZPositionAlphaAttribute);\r\n    GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);\r\n    GLES20.glDisable(GLES20.GL_BLEND);\r\n    GLES20.glDepthMask(true);\r\n    ShaderUtil.checkGLError(TAG, \"Cleaning up after drawing planes\");\r\n}"
}, {
	"Path": "com.novoda.spikes.arcore.google.rendering.PlaneRenderer.drawPlanes",
	"Comment": "draws the collection of tracked planes, with closer planes hiding more distant ones.",
	"Method": "void drawPlanes(Collection<Plane> allPlanes,Pose cameraPose,float[] cameraPerspective){\r\n    return Float.compare(a.distance, b.distance);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.WorkflowTypeDelegateTest.testGetWorkflowTraceType",
	"Comment": "test of getworkflowtracetype method, of class workflowtypedelegate.",
	"Method": "void testGetWorkflowTraceType(){\r\n    args = new String[2];\r\n    args[0] = \"-workflow_trace_type\";\r\n    args[1] = \"HANDSHAKE\";\r\n    assertFalse(WorkflowTraceType.HANDSHAKE.equals(delegate.getWorkflowTraceType()));\r\n    jcommander.parse(args);\r\n    assertTrue(delegate.getWorkflowTraceType().equals(WorkflowTraceType.HANDSHAKE));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.WorkflowTypeDelegateTest.testApplyDelegate",
	"Comment": "test of applydelegate method, of class workflowtypedelegate.",
	"Method": "void testApplyDelegate(){\r\n    Config config = Config.createConfig();\r\n    args = new String[2];\r\n    args[0] = \"-workflow_trace_type\";\r\n    args[1] = \"FULL\";\r\n    jcommander.parse(args);\r\n    assertFalse(WorkflowTraceType.FULL.equals(config.getWorkflowTraceType()));\r\n    delegate.applyDelegate(config);\r\n    assertTrue(WorkflowTraceType.FULL.equals(config.getWorkflowTraceType()));\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderActivity.setupTangoConfig",
	"Comment": "sets up the tango configuration object. make sure mtango object is initialized beforemaking this call.",
	"Method": "TangoConfig setupTangoConfig(Tango tango){\r\n    TangoConfig config = tango.getConfig(TangoConfig.CONFIG_TYPE_DEFAULT);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_LOWLATENCYIMUINTEGRATION, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_SMOOTH_POSE, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_DEPTH, true);\r\n    config.putInt(TangoConfig.KEY_INT_DEPTH_MODE, TangoConfig.TANGO_DEPTH_MODE_POINT_CLOUD);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_COLORCAMERA, true);\r\n    return config;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskDheServerKeyExchangeHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class pskdheserverkeyexchangehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new PskDheServerKeyExchangeMessage()) instanceof PskDheServerKeyExchangePreparator);\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPITest.testTessBaseAPIGetLoadedLanguagesAsVector",
	"Comment": "test of tessbaseapigetloadedlanguagesasvector method, of class tessapi.",
	"Method": "void testTessBaseAPIGetLoadedLanguagesAsVector(){\r\n    logger.info(\"TessBaseAPIGetLoadedLanguagesAsVector\");\r\n    api.TessBaseAPIInit3(handle, datapath, language);\r\n    String[] expResult = { \"eng\" };\r\n    String[] result = api.TessBaseAPIGetLoadedLanguagesAsVector(handle).getPointer().getStringArray(0);\r\n    assertArrayEquals(expResult, result);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.SignatureAndHashAlgorithmsExtensionHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of classsignatureandhashalgorithmsextensionhandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new SignatureAndHashAlgorithmsExtensionMessage()) instanceof SignatureAndHashAlgorithmsExtensionSerializer);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingRenderer.updateObjectPose",
	"Comment": "save the updated plane fit pose to update the ar object on the next render pass.this is synchronized against concurrent access in the render loop above.",
	"Method": "void updateObjectPose(float[] openglTDepthArr,float[] mDepthTPlaneArr){\r\n    Matrix4 openglTDepth = new Matrix4(openglTDepthArr);\r\n    Matrix4 openglTPlane = openglTDepth.multiply(new Matrix4(mDepthTPlaneArr));\r\n    mObjectTransform = openglTPlane.multiply(DEPTH_T_OPENGL);\r\n    ;\r\n    mObjectPoseUpdated = true;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskDheServerKeyExchangeHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class pskdheserverkeyexchangehandler.",
	"Method": "void testAdjustTLSContext(){\r\n    PskDheServerKeyExchangeMessage message = new PskDheServerKeyExchangeMessage();\r\n    message.setModulus(BigInteger.TEN.toByteArray());\r\n    message.setGenerator(BigInteger.ONE.toByteArray());\r\n    message.setPublicKey(new byte[] { 0, 1, 2, 3 });\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_DHE_PSK_WITH_AES_128_CBC_SHA);\r\n    message.prepareComputations();\r\n    message.getComputations().setPrivateKey(BigInteger.ZERO);\r\n    handler.adjustTLSContext(message);\r\n    assertNull(context.getPreMasterSecret());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.transport.tcp.ClientTcpTransportHandlerTest.testCloseConnection",
	"Comment": "test of closeconnection method, of class clienttcptransporthandler.",
	"Method": "void testCloseConnection(){\r\n    handler = new ClientTcpTransportHandler(100, \"localhost\", 0);\r\n    handler.closeConnection();\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.SampleLogger.getLogger",
	"Comment": "get the logger for awscognitodeveloperauthenticationsample",
	"Method": "Logger getLogger(){\r\n    if (null != logger) {\r\n        return logger;\r\n    }\r\n    logger = Logger.getLogger(\"AWSCognitoDeveloperAuthenticationSampleLogger\");\r\n    logger.setLevel(Level.ALL);\r\n    return logger;\r\n}"
}, {
	"Path": "org.springframework.data.neo4j.examples.restaurants.RestaurantTests.shouldFindRestaurantsNear_locationFirst",
	"Comment": "this test, as the above one does, asserts that the parameter index for each query part is set correctly. most query\tparts are associated with one parameter, while certain kinds, such as near, require more.",
	"Method": "void shouldFindRestaurantsNear_locationFirst(){\r\n    Restaurant restaurant = new Restaurant(\"San Francisco International Airport (SFO)\", new Point(37.61649, -122.38681), 94128);\r\n    restaurantRepository.save(restaurant);\r\n    List<Restaurant> results = restaurantRepository.findByLocationNearAndName(new Distance(150, Metrics.KILOMETERS), new Point(37.6, -122.3), \"San Francisco International Airport (SFO)\");\r\n    assertNotNull(results);\r\n    assertEquals(1, results.size());\r\n    Restaurant found = results.get(0);\r\n    assertNotNull(found.getLocation());\r\n    assertEquals(37.61649, found.getLocation().getX(), 0);\r\n    assertEquals(-122.38681, found.getLocation().getY(), 0);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.KeyShareExtensionHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class keyshareextensionhandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new KeyShareExtensionMessage(ExtensionType.KEY_SHARE)) instanceof KeyShareExtensionPreparator);\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.Tesseract.getRecognizedWords",
	"Comment": "gets result words at specified page iterator level from recognized pages.",
	"Method": "List<Word> getRecognizedWords(int pageIteratorLevel){\r\n    List<Word> words = new ArrayList<Word>();\r\n    try {\r\n        TessResultIterator ri = api.TessBaseAPIGetIterator(handle);\r\n        TessPageIterator pi = api.TessResultIteratorGetPageIterator(ri);\r\n        api.TessPageIteratorBegin(pi);\r\n        do {\r\n            Pointer ptr = api.TessResultIteratorGetUTF8Text(ri, pageIteratorLevel);\r\n            String text = ptr.getString(0);\r\n            api.TessDeleteText(ptr);\r\n            float confidence = api.TessResultIteratorConfidence(ri, pageIteratorLevel);\r\n            IntBuffer leftB = IntBuffer.allocate(1);\r\n            IntBuffer topB = IntBuffer.allocate(1);\r\n            IntBuffer rightB = IntBuffer.allocate(1);\r\n            IntBuffer bottomB = IntBuffer.allocate(1);\r\n            api.TessPageIteratorBoundingBox(pi, pageIteratorLevel, leftB, topB, rightB, bottomB);\r\n            int left = leftB.get();\r\n            int top = topB.get();\r\n            int right = rightB.get();\r\n            int bottom = bottomB.get();\r\n            Word word = new Word(text, confidence, new Rectangle(left, top, right - left, bottom - top));\r\n            words.add(word);\r\n        } while (api.TessPageIteratorNext(pi, pageIteratorLevel) == TRUE);\r\n    } catch (Exception e) {\r\n        logger.warn(e.getMessage(), e);\r\n    }\r\n    return words;\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.indexing.AbstractIndexerBolt.trimText",
	"Comment": "returns a trimmed string or the original one if it is below the thresholdset in the configuration.",
	"Method": "String trimText(String text){\r\n    if (maxLengthText == -1)\r\n        return text;\r\n    if (text == null)\r\n        return text;\r\n    if (text.length() <= maxLengthText)\r\n        return text;\r\n    return text.substring(0, maxLengthText);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.extension.KeyShareExtensionPreparatorTest.testPrepare",
	"Comment": "test of prepare method, of class keyshareextensionpreparator.",
	"Method": "void testPrepare(){\r\n    List<KeyShareEntry> keyShareList = new LinkedList();\r\n    KeyShareEntry entry = new KeyShareEntry(NamedGroup.ECDH_X25519, new BigInteger(\"03BD8BCA70C19F657E897E366DBE21A466E4924AF6082DBDF573827BCDDE5DEF\", 16));\r\n    keyShareList.add(entry);\r\n    message.setKeyShareList(keyShareList);\r\n    preparator.prepare();\r\n    assertArrayEquals(message.getKeyShareListBytes().getValue(), ArrayConverter.hexStringToByteArray(\"001D00202a981db6cdd02a06c1763102c9e741365ac4e6f72b3176a6bd6a3523d3ec0f4c\"));\r\n    assertTrue(message.getKeyShareListLength().getValue() == 36);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.RSAClientKeyExchangeParser.parseSerializedPublicKey",
	"Comment": "reads the next bytes as the serializedpublickey and writes them in themessage",
	"Method": "void parseSerializedPublicKey(T msg){\r\n    msg.setPublicKey(parseByteArrayField(msg.getPublicKeyLength().getValue()));\r\n    LOGGER.debug(\"SerializedPublicKey: \" + ArrayConverter.bytesToHexString(msg.getPublicKey().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.FinishedSerializerTest.testSerializeHandshakeMessageContent",
	"Comment": "test of serializehandshakemessagecontent method, of classfinishedserializer.",
	"Method": "void testSerializeHandshakeMessageContent(){\r\n    FinishedMessage msg = new FinishedMessage();\r\n    msg.setLength(length);\r\n    msg.setType(type.getValue());\r\n    msg.setVerifyData(verifyData);\r\n    msg.setCompleteResultingMessage(expectedPart);\r\n    FinishedSerializer serializer = new FinishedSerializer(msg, version);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetClientSupportedNamedCurves",
	"Comment": "test of getclientsupportednamedgroups method, of class defaultchooser.",
	"Method": "void testGetClientSupportedNamedCurves(){\r\n    List<NamedGroup> curveList = new LinkedList();\r\n    curveList.add(NamedGroup.BRAINPOOLP256R1);\r\n    curveList.add(NamedGroup.ECDH_X448);\r\n    curveList.add(NamedGroup.SECP160K1);\r\n    config.setDefaultClientNamedGroups(curveList);\r\n    assertTrue(config.getDefaultClientNamedGroups().size() == 3);\r\n    assertTrue(chooser.getClientSupportedNamedGroups().size() == 3);\r\n    context.setClientNamedGroupsList(new LinkedList<NamedGroup>());\r\n    assertTrue(chooser.getClientSupportedNamedGroups().isEmpty());\r\n}"
}, {
	"Path": "org.sonar.java.se.JavaCheckVerifier.verifyIssueOnFile",
	"Comment": "verifies that the provided file will only raise an issue on the file, with the given message, when analyzed using the given check.",
	"Method": "void verifyIssueOnFile(String filename,String message,JavaFileScanner check){\r\n    JavaCheckVerifier javaCheckVerifier = new JavaCheckVerifier(new Expectations(false, message, null));\r\n    javaCheckVerifier.scanFile(filename, new JavaFileScanner[] { check });\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.PaddingExtensionHandler.adjustTLSExtensionContext",
	"Comment": "adjusts the tls context based on the lenght of the padding extension.",
	"Method": "void adjustTLSExtensionContext(PaddingExtensionMessage message){\r\n    if (message.getPaddingBytes().getValue().length > 65535) {\r\n        LOGGER.warn(\"The Padding Extension length value exceeds the two bytes defined in RFC 7685.\");\r\n    }\r\n    context.setPaddingExtensionBytes(message.getPaddingBytes().getValue());\r\n    LOGGER.debug(\"The context PaddingExtension bytes were set to \" + ArrayConverter.bytesToHexString(context.getPaddingExtensionBytes()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.HelloMessageParser.parseRandom",
	"Comment": "reads the next bytes as a the random and writes them in the message",
	"Method": "void parseRandom(HelloMessage message){\r\n    message.setRandom(parseByteArrayField(HandshakeByteLength.RANDOM));\r\n    LOGGER.debug(\"Random:\" + ArrayConverter.bytesToHexString(message.getRandom().getValue()));\r\n    message.setUnixTime(Arrays.copyOf(message.getRandom().getValue(), HandshakeByteLength.UNIX_TIME));\r\n    LOGGER.debug(\"UnixTime:\" + ArrayConverter.bytesToHexString(message.getUnixTime().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.CertificateRequestHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class certificaterequesthandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new CertificateRequestMessage()) instanceof CertificateRequestPreparator);\r\n}"
}, {
	"Path": "org.takes.misc.Href.createBare",
	"Comment": "remove query and fragment parts from the provided uri andreturn the resulting uri.",
	"Method": "URI createBare(URI link){\r\n    final URI uri;\r\n    if (link.getRawQuery() == null && link.getRawFragment() == null) {\r\n        uri = link;\r\n    } else {\r\n        final String href = link.toString();\r\n        final int idx;\r\n        if (link.getRawQuery() == null) {\r\n            idx = href.indexOf('#');\r\n        } else {\r\n            idx = href.indexOf('?');\r\n        }\r\n        uri = URI.create(href.substring(0, idx));\r\n    }\r\n    return uri;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.HelloVerifyRequestMessageTest.testToString",
	"Comment": "test of tostring method, of class helloverifyrequestmessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"HelloVerifyRequestMessage:\");\r\n    sb.append(\"\\n  ProtocolVersion: \").append(\"null\");\r\n    sb.append(\"\\n  Cookie Length: \").append(\"null\");\r\n    sb.append(\"\\n  Cookie: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ECDHEServerKeyExchangeHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class ecdheserverkeyexchangehandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof ECDHEServerKeyExchangeParser);\r\n}"
}, {
	"Path": "org.takes.facets.auth.PsBasicTest.header",
	"Comment": "generate the string used on the request that store information aboutauthentication.",
	"Method": "String header(String user,String pass){\r\n    final String auth = String.format(\"%s:%s\", user, pass);\r\n    final String encoded = DatatypeConverter.printBase64Binary(auth.getBytes());\r\n    return String.format(PsBasicTest.AUTH_BASIC, encoded);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorplanView.updateCameraMatrix",
	"Comment": "updates the current rotation and translation to be used for the map. this is called with thecurrent device position and orientation.",
	"Method": "void updateCameraMatrix(float translationX,float translationY,float yawRadians){\r\n    mFixedCameraMatrix.setTranslate(-translationX * SCALE, -translationY * SCALE);\r\n    mFixedCameraMatrix.preRotate((float) Math.toDegrees(yawRadians), translationX * SCALE, translationY * SCALE);\r\n    mFixedCameraMatrix.invert(mFixedCameraInverse);\r\n}"
}, {
	"Path": "org.togglz.benchmark.TogglzOverheadBenchmark.toggleEnabledState",
	"Comment": "toggle the state between iterations to keep the compiler honest",
	"Method": "void toggleEnabledState(){\r\n    enabled = !enabled;\r\n    manager.setFeatureState(new FeatureState(OverheadFeature.FEATURE, enabled));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.util.KeyStoreGeneratorTest.testCreateRSAKeyPair",
	"Comment": "test of creatersakeypair method, of class keystoregenerator.",
	"Method": "void testCreateRSAKeyPair(){\r\n    KeyPair k = KeyStoreGenerator.createRSAKeyPair(1024, random);\r\n    assertNotNull(k);\r\n    assertEquals(\"RSA\", k.getPublic().getAlgorithm());\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.util.URLPartitioner.getPartition",
	"Comment": "returns the host, domain, ip of a url so that it can be partitioned forpoliteness, depending on the value of the configpartition.url.mode.",
	"Method": "String getPartition(String url,Metadata metadata){\r\n    String partitionKey = null;\r\n    String host = \"\";\r\n    if (mode.equalsIgnoreCase(Constants.PARTITION_MODE_IP)) {\r\n        String ip_provided = metadata.getFirstValue(\"ip\");\r\n        if (StringUtils.isNotBlank(ip_provided)) {\r\n            partitionKey = ip_provided;\r\n        }\r\n    }\r\n    if (partitionKey == null) {\r\n        URL u;\r\n        try {\r\n            u = new URL(url);\r\n            host = u.getHost();\r\n        } catch (MalformedURLException e1) {\r\n            LOG.warn(\"Invalid URL: {}\", url);\r\n            return null;\r\n        }\r\n    }\r\n    if (mode.equalsIgnoreCase(Constants.PARTITION_MODE_HOST))\r\n        partitionKey = host;\r\n    else if (mode.equalsIgnoreCase(Constants.PARTITION_MODE_DOMAIN)) {\r\n        partitionKey = PaidLevelDomain.getPLD(host);\r\n    }\r\n    if (mode.equalsIgnoreCase(Constants.PARTITION_MODE_IP) && partitionKey == null) {\r\n        try {\r\n            long start = System.currentTimeMillis();\r\n            final InetAddress addr = InetAddress.getByName(host);\r\n            partitionKey = addr.getHostAddress();\r\n            long end = System.currentTimeMillis();\r\n            LOG.debug(\"Resolved IP {} in {} msec for : {}\", partitionKey, end - start, url);\r\n        } catch (final Exception e) {\r\n            LOG.warn(\"Unable to resolve IP for: {}\", host);\r\n            return null;\r\n        }\r\n    }\r\n    LOG.debug(\"Partition Key for: {} > {}\", url, partitionKey);\r\n    return partitionKey;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.HostnameExtensionDelegateTest.testGetSniHostname",
	"Comment": "test of getsnihostname method, of class hostnameextensiondelegate.",
	"Method": "void testGetSniHostname(){\r\n    args = new String[2];\r\n    args[0] = \"-server_name\";\r\n    args[1] = \"its_me\";\r\n    assertFalse(\"its_me\".equals(delegate.getSniHostname()));\r\n    jcommander.parse(args);\r\n    assertTrue(\"its_me\".equals(delegate.getSniHostname()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeMasterSecretActionTest.testGetNewValue",
	"Comment": "test of getnewvalue method, of class changeclientrandomaction.",
	"Method": "void testGetNewValue(){\r\n    assertArrayEquals(action.getNewValue(), new byte[] { 0, 1 });\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.crypto.ec_.Point.isAtInfinity",
	"Comment": "returns true if the point is the point at infinity. returns false if thepoint is an affine point.",
	"Method": "boolean isAtInfinity(){\r\n    return this.infinity;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.greenscreen.GreenScreenActivity.hasPermissions",
	"Comment": "check to see if we have camera and write external storage permissions for this app.",
	"Method": "boolean hasPermissions(){\r\n    return ContextCompat.checkSelfPermission(this, CAMERA_PERMISSION) == PackageManager.PERMISSION_GRANTED && ContextCompat.checkSelfPermission(this, WRITE_PERMISSION) == PackageManager.PERMISSION_GRANTED;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellomotiontracking.HelloMotionTrackingActivity.logPose",
	"Comment": "log the position and orientation of the given pose in the logcat as information.",
	"Method": "void logPose(TangoPoseData pose){\r\n    StringBuilder stringBuilder = new StringBuilder();\r\n    float[] translation = pose.getTranslationAsFloats();\r\n    stringBuilder.append(\"Position: \" + translation[0] + \", \" + translation[1] + \", \" + translation[2]);\r\n    float[] orientation = pose.getRotationAsFloats();\r\n    stringBuilder.append(\". Orientation: \" + orientation[0] + \", \" + orientation[1] + \", \" + orientation[2] + \", \" + orientation[3]);\r\n    Log.i(TAG, stringBuilder.toString());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.SupportedVersionsExtensionHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class supportedversionsextensionhandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new SupportedVersionsExtensionMessage()) instanceof SupportedVersionsExtensionPreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.DHEServerKeyExchangePreparatorTest.testPrepare",
	"Comment": "test of preparehandshakemessagecontents method, of classdheserverkeyexchangepreparator.",
	"Method": "void testPrepare(){\r\n    context.getConfig().setDefaultServerDhGenerator(new BigInteger(ArrayConverter.hexStringToByteArray(\"a51883e9ac0539859df3d25c716437008bb4bd8ec4786eb4bc643299daef5e3e5af5863a6ac40a597b83a27583f6a658d408825105b16d31b6ed088fc623f648fd6d95e9cefcb0745763cddf564c87bcf4ba7928e74fd6a3080481f588d535e4c026b58a21e1e5ec412ff241b436043e29173f1dc6cb943c09742de989547288\")));\r\n    context.getConfig().setDefaultServerDhModulus(new BigInteger(1, ArrayConverter.hexStringToByteArray(\"da3a8085d372437805de95b88b675122f575df976610c6a844de99f1df82a06848bf7a42f18895c97402e81118e01a00d0855d51922f434c022350861d58ddf60d65bc6941fc6064b147071a4c30426d82fc90d888f94990267c64beef8c304a4b2b26fb93724d6a9472fa16bc50c5b9b8b59afb62cfe9ea3ba042c73a6ade35\")));\r\n    context.setClientRandom(ArrayConverter.hexStringToByteArray(\"AABBCCDD\"));\r\n    context.setServerRandom(ArrayConverter.hexStringToByteArray(\"AABBCCDD\"));\r\n    List<SignatureAndHashAlgorithm> SigAndHashList = new LinkedList();\r\n    SigAndHashList.add(SignatureAndHashAlgorithm.RSA_SHA1);\r\n    SigAndHashList.add(SignatureAndHashAlgorithm.DSA_MD5);\r\n    context.getConfig().setSupportedSignatureAndHashAlgorithms(SigAndHashList);\r\n    preparator.prepareHandshakeMessageContents();\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"a51883e9ac0539859df3d25c716437008bb4bd8ec4786eb4bc643299daef5e3e5af5863a6ac40a597b83a27583f6a658d408825105b16d31b6ed088fc623f648fd6d95e9cefcb0745763cddf564c87bcf4ba7928e74fd6a3080481f588d535e4c026b58a21e1e5ec412ff241b436043e29173f1dc6cb943c09742de989547288\"), message.getGenerator().getValue());\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"da3a8085d372437805de95b88b675122f575df976610c6a844de99f1df82a06848bf7a42f18895c97402e81118e01a00d0855d51922f434c022350861d58ddf60d65bc6941fc6064b147071a4c30426d82fc90d888f94990267c64beef8c304a4b2b26fb93724d6a9472fa16bc50c5b9b8b59afb62cfe9ea3ba042c73a6ade35\"), message.getModulus().getValue());\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"AABBCCDDAABBCCDD\"), message.getComputations().getClientServerRandom().getValue());\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"0201\"), message.getSignatureAndHashAlgorithm().getValue());\r\n    assertNotNull(message.getSignature().getValue());\r\n    assertNotNull(message.getSignatureLength().getValue());\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.Tesseract.createDocumentsWithResults",
	"Comment": "creates documents with ocr results for given renderers at specified pageiterator level.",
	"Method": "List<OCRResult> createDocumentsWithResults(String[] filenames,String[] outputbases,List<ITesseract.RenderedFormat> formats,int pageIteratorLevel){\r\n    if (filenames.length != outputbases.length) {\r\n        throw new RuntimeException(\"The two arrays must match in length.\");\r\n    }\r\n    init();\r\n    setTessVariables();\r\n    List<OCRResult> results = new ArrayList<OCRResult>();\r\n    try {\r\n        for (int i = 0; i < filenames.length; i++) {\r\n            File inputFile = new File(filenames[i]);\r\n            File imageFile = null;\r\n            try {\r\n                imageFile = ImageIOHelper.getImageFile(inputFile);\r\n                TessResultRenderer renderer = createRenderers(outputbases[i], formats);\r\n                int meanTextConfidence = createDocuments(imageFile.getPath(), renderer);\r\n                List<Word> words = meanTextConfidence > 0 ? getRecognizedWords(pageIteratorLevel) : new ArrayList<Word>();\r\n                results.add(new OCRResult(meanTextConfidence, words));\r\n                api.TessDeleteResultRenderer(renderer);\r\n            } catch (Exception e) {\r\n                logger.warn(e.getMessage(), e);\r\n            } finally {\r\n                if (imageFile != null && imageFile.exists() && imageFile != inputFile && imageFile.getName().startsWith(\"multipage\") && imageFile.getName().endsWith(ImageIOHelper.TIFF_EXT)) {\r\n                    imageFile.delete();\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        dispose();\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ChangeCipherSpecHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class changecipherspechandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new ChangeCipherSpecMessage()) instanceof ChangeCipherSpecPreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.PskDhClientKeyExchangeParserTest.testParse",
	"Comment": "test of parse method, of class pskdhclientkeyexchangeparser.",
	"Method": "void testParse(){\r\n    PskDhClientKeyExchangeParser parser = new PskDhClientKeyExchangeParser(0, message, version);\r\n    PskDhClientKeyExchangeMessage msg = parser.parse();\r\n    assertArrayEquals(message, msg.getCompleteResultingMessage().getValue());\r\n    assertTrue(msg.getLength().getValue() == length);\r\n    assertTrue(msg.getType().getValue() == type.getValue());\r\n    assertTrue(serializedPskIdentityLength == msg.getIdentityLength().getValue());\r\n    assertArrayEquals(serializedPskIdentity, msg.getIdentity().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.MaxFragmentLengthDelegateTest.testSetMaxFragmentLength",
	"Comment": "test of setmaxfragmentlength method, of class maxfragmentlengthdelegate.",
	"Method": "void testSetMaxFragmentLength(){\r\n    assertFalse(Objects.equals(delegate.getMaxFragmentLength(), 4));\r\n    delegate.setMaxFragmentLength(4);\r\n    assertTrue(Objects.equals(delegate.getMaxFragmentLength(), 4));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.UnknownExtensionHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class unknownextensionhandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new UnknownExtensionMessage()) instanceof UnknownExtensionPreparator);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointcloud.PointCloudActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud and tango events and pose.",
	"Method": "void startupTango(){\r\n    ArrayList<TangoCoordinateFramePair> framePairs = new ArrayList<TangoCoordinateFramePair>();\r\n    framePairs.add(new TangoCoordinateFramePair(TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_DEVICE));\r\n    mTango.connectListener(framePairs, new Tango.TangoUpdateCallback() {\r\n        @Override\r\n        public void onPoseAvailable(TangoPoseData pose) {\r\n            if (mTangoUx != null) {\r\n                mTangoUx.updatePoseStatus(pose.statusCode);\r\n            }\r\n        }\r\n        @Override\r\n        public void onPointCloudAvailable(TangoPointCloudData pointCloud) {\r\n            if (mTangoUx != null) {\r\n                mTangoUx.updatePointCloud(pointCloud);\r\n            }\r\n            mPointCloudManager.updatePointCloud(pointCloud);\r\n            final double currentTimeStamp = pointCloud.timestamp;\r\n            final double pointCloudFrameDelta = (currentTimeStamp - mPointCloudPreviousTimeStamp) * SECS_TO_MILLISECS;\r\n            mPointCloudPreviousTimeStamp = currentTimeStamp;\r\n            final double averageDepth = getAveragedDepth(pointCloud.points, pointCloud.numPoints);\r\n            mPointCloudTimeToNextUpdate -= pointCloudFrameDelta;\r\n            if (mPointCloudTimeToNextUpdate < 0.0) {\r\n                mPointCloudTimeToNextUpdate = UPDATE_INTERVAL_MS;\r\n                final String pointCountString = Integer.toString(pointCloud.numPoints);\r\n                runOnUiThread(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        mPointCountTextView.setText(pointCountString);\r\n                        mAverageZTextView.setText(FORMAT_THREE_DECIMAL.format(averageDepth));\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        @Override\r\n        public void onTangoEvent(TangoEvent event) {\r\n            if (mTangoUx != null) {\r\n                mTangoUx.updateTangoEvent(event);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointcloud.PointCloudActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud and tango events and pose.",
	"Method": "void startupTango(){\r\n    if (mTangoUx != null) {\r\n        mTangoUx.updatePoseStatus(pose.statusCode);\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointcloud.PointCloudActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud and tango events and pose.",
	"Method": "void startupTango(){\r\n    if (mTangoUx != null) {\r\n        mTangoUx.updatePointCloud(pointCloud);\r\n    }\r\n    mPointCloudManager.updatePointCloud(pointCloud);\r\n    final double currentTimeStamp = pointCloud.timestamp;\r\n    final double pointCloudFrameDelta = (currentTimeStamp - mPointCloudPreviousTimeStamp) * SECS_TO_MILLISECS;\r\n    mPointCloudPreviousTimeStamp = currentTimeStamp;\r\n    final double averageDepth = getAveragedDepth(pointCloud.points, pointCloud.numPoints);\r\n    mPointCloudTimeToNextUpdate -= pointCloudFrameDelta;\r\n    if (mPointCloudTimeToNextUpdate < 0.0) {\r\n        mPointCloudTimeToNextUpdate = UPDATE_INTERVAL_MS;\r\n        final String pointCountString = Integer.toString(pointCloud.numPoints);\r\n        runOnUiThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                mPointCountTextView.setText(pointCountString);\r\n                mAverageZTextView.setText(FORMAT_THREE_DECIMAL.format(averageDepth));\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointcloud.PointCloudActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud and tango events and pose.",
	"Method": "void startupTango(){\r\n    mPointCountTextView.setText(pointCountString);\r\n    mAverageZTextView.setText(FORMAT_THREE_DECIMAL.format(averageDepth));\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointcloud.PointCloudActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud and tango events and pose.",
	"Method": "void startupTango(){\r\n    if (mTangoUx != null) {\r\n        mTangoUx.updateTangoEvent(event);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.SessionResumptionDelegateTest.testSetSessionID",
	"Comment": "test of setsessionid method, of class sessionresumptiondelegate.",
	"Method": "void testSetSessionID(){\r\n    byte[] expected = { (byte) 0x00, (byte) 0x11, (byte) 0x22, (byte) 0x33, (byte) 0x44, (byte) 0x55, (byte) 0x66, (byte) 0x77, (byte) 0x88, (byte) 0x99, (byte) 0xAA, (byte) 0xBB, (byte) 0xCC, (byte) 0xDD, (byte) 0xEE, (byte) 0xFF };\r\n    delegate.setSessionId(expected);\r\n    assertArrayEquals(delegate.getSessionId(), expected);\r\n}"
}, {
	"Path": "org.togglz.core.activation.ParameterBuilder.largeText",
	"Comment": "specifies that the parameter typically has large texts as a value",
	"Method": "ParameterBuilder largeText(){\r\n    this.largeText = true;\r\n    return this;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.StarttlsDelegateTest.testSetStarttlsType",
	"Comment": "test of setstarttlstype method, of class starttlsdelegate.",
	"Method": "void testSetStarttlsType(){\r\n    assertTrue(delegate.getStarttlsType() == StarttlsType.NONE);\r\n    delegate.setStarttlsType(StarttlsType.POP3);\r\n    assertTrue(delegate.getStarttlsType() == StarttlsType.POP3);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.MessageActionFactoryTest.testCreateActionMultiple",
	"Comment": "test of createaction method, of class messageactionfactory.",
	"Method": "void testCreateActionMultiple(){\r\n    List<ProtocolMessage> messages = new LinkedList();\r\n    messages.add(new ChangeCipherSpecMessage());\r\n    messages.add(new AlertMessage(config));\r\n    MessageAction action = MessageActionFactory.createAction(clientConnection, ConnectionEndType.CLIENT, messages);\r\n    assertEquals(action.getClass(), SendAction.class);\r\n    action = MessageActionFactory.createAction(clientConnection, ConnectionEndType.SERVER, messages);\r\n    assertEquals(action.getClass(), ReceiveAction.class);\r\n    action = MessageActionFactory.createAction(serverConnection, ConnectionEndType.CLIENT, messages);\r\n    assertEquals(action.getClass(), ReceiveAction.class);\r\n    action = MessageActionFactory.createAction(serverConnection, ConnectionEndType.SERVER, messages);\r\n    assertEquals(action.getClass(), SendAction.class);\r\n    assertTrue(action.messages.size() == 2);\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.util.URLUtil.getHost",
	"Comment": "returns the lowercased hostname for the url or null if the url is notwell formed.",
	"Method": "String getHost(String url){\r\n    try {\r\n        return new URL(url).getHost().toLowerCase(Locale.ROOT);\r\n    } catch (MalformedURLException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.delegatesToArray",
	"Comment": "verboselist should delegate toarray method to decorated list.",
	"Method": "void delegatesToArray(){\r\n    this.list.toArray();\r\n    Mockito.verify(this.origin).toArray();\r\n    final Object[] array = new Object[1];\r\n    this.list.toArray(array);\r\n    Mockito.verify(this.origin).toArray(array);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.PskDhClientKeyExchangeParser.parsePskIdentity",
	"Comment": "reads the next bytes as the pskidentity and writes them in the message",
	"Method": "void parsePskIdentity(PskDhClientKeyExchangeMessage msg){\r\n    msg.setIdentity(parseByteArrayField(msg.getIdentityLength().getValue()));\r\n    LOGGER.debug(\"SerializedPSK-Identity: \" + ArrayConverter.bytesToHexString(msg.getIdentity().getValue()));\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.io.LegacyShapeWriter.makeNumberFormat",
	"Comment": "a convenience method to create a suitable numberformat for writing numbers.",
	"Method": "NumberFormat makeNumberFormat(int fractionDigits){\r\n    NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);\r\n    nf.setGroupingUsed(false);\r\n    nf.setMaximumFractionDigits(fractionDigits);\r\n    nf.setMinimumFractionDigits(0);\r\n    return nf;\r\n}"
}, {
	"Path": "com.android.vending.billing.util.IabHelper.startSetup",
	"Comment": "starts the setup process. this will start up the setup process asynchronously.you will be notified through the listener when the setup process is complete.this method is safe to call from a ui thread.",
	"Method": "void startSetup(OnIabSetupFinishedListener listener){\r\n    checkNotDisposed();\r\n    if (mSetupDone)\r\n        throw new IllegalStateException(\"IAB helper is already set up.\");\r\n    logDebug(\"Starting in-app billing setup.\");\r\n    mServiceConn = new ServiceConnection() {\r\n        @Override\r\n        public void onServiceDisconnected(ComponentName name) {\r\n            logDebug(\"Billing service disconnected.\");\r\n            mService = null;\r\n        }\r\n        @Override\r\n        public void onServiceConnected(ComponentName name, IBinder service) {\r\n            if (mDisposed)\r\n                return;\r\n            logDebug(\"Billing service connected.\");\r\n            mService = IInAppBillingService.Stub.asInterface(service);\r\n            String packageName = mContext.getPackageName();\r\n            try {\r\n                logDebug(\"Checking for in-app billing 3 support.\");\r\n                int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);\r\n                if (response != BILLING_RESPONSE_RESULT_OK) {\r\n                    if (listener != null)\r\n                        listener.onIabSetupFinished(new IabResult(response, \"Error checking for billing v3 support.\"));\r\n                    mSubscriptionsSupported = false;\r\n                    return;\r\n                }\r\n                logDebug(\"In-app billing version 3 supported for \" + packageName);\r\n                response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);\r\n                if (response == BILLING_RESPONSE_RESULT_OK) {\r\n                    logDebug(\"Subscriptions AVAILABLE.\");\r\n                    mSubscriptionsSupported = true;\r\n                } else {\r\n                    logDebug(\"Subscriptions NOT AVAILABLE. Response: \" + response);\r\n                }\r\n                mSetupDone = true;\r\n            } catch (RemoteException e) {\r\n                if (listener != null) {\r\n                    listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION, \"RemoteException while setting up in-app billing.\"));\r\n                }\r\n                e.printStackTrace();\r\n                return;\r\n            }\r\n            if (listener != null) {\r\n                listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, \"Setup successful.\"));\r\n            }\r\n        }\r\n    };\r\n    Intent serviceIntent = new Intent(\"com.android.vending.billing.InAppBillingService.BIND\");\r\n    serviceIntent.setPackage(\"com.android.vending\");\r\n    if (!mContext.getPackageManager().queryIntentServices(serviceIntent, 0).isEmpty()) {\r\n        mContext.bindService(serviceIntent, mServiceConn, Context.BIND_AUTO_CREATE);\r\n    } else {\r\n        if (listener != null) {\r\n            listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE, \"Billing service unavailable on device.\"));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.android.vending.billing.util.IabHelper.startSetup",
	"Comment": "starts the setup process. this will start up the setup process asynchronously.you will be notified through the listener when the setup process is complete.this method is safe to call from a ui thread.",
	"Method": "void startSetup(OnIabSetupFinishedListener listener){\r\n    logDebug(\"Billing service disconnected.\");\r\n    mService = null;\r\n}"
}, {
	"Path": "com.android.vending.billing.util.IabHelper.startSetup",
	"Comment": "starts the setup process. this will start up the setup process asynchronously.you will be notified through the listener when the setup process is complete.this method is safe to call from a ui thread.",
	"Method": "void startSetup(OnIabSetupFinishedListener listener){\r\n    if (mDisposed)\r\n        return;\r\n    logDebug(\"Billing service connected.\");\r\n    mService = IInAppBillingService.Stub.asInterface(service);\r\n    String packageName = mContext.getPackageName();\r\n    try {\r\n        logDebug(\"Checking for in-app billing 3 support.\");\r\n        int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);\r\n        if (response != BILLING_RESPONSE_RESULT_OK) {\r\n            if (listener != null)\r\n                listener.onIabSetupFinished(new IabResult(response, \"Error checking for billing v3 support.\"));\r\n            mSubscriptionsSupported = false;\r\n            return;\r\n        }\r\n        logDebug(\"In-app billing version 3 supported for \" + packageName);\r\n        response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);\r\n        if (response == BILLING_RESPONSE_RESULT_OK) {\r\n            logDebug(\"Subscriptions AVAILABLE.\");\r\n            mSubscriptionsSupported = true;\r\n        } else {\r\n            logDebug(\"Subscriptions NOT AVAILABLE. Response: \" + response);\r\n        }\r\n        mSetupDone = true;\r\n    } catch (RemoteException e) {\r\n        if (listener != null) {\r\n            listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION, \"RemoteException while setting up in-app billing.\"));\r\n        }\r\n        e.printStackTrace();\r\n        return;\r\n    }\r\n    if (listener != null) {\r\n        listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, \"Setup successful.\"));\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorPlanReconstructionActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    final AlertDialog dialog = new AlertDialog.Builder(this).setMessage(\"Java Floorplan Reconstruction Example requires camera permission\").setPositiveButton(\"Ok\", new DialogInterface.OnClickListener() {\r\n        @Override\r\n        public void onClick(DialogInterface dialogInterface, int i) {\r\n            ActivityCompat.requestPermissions(FloorPlanReconstructionActivity.this, new String[] { CAMERA_PERMISSION }, CAMERA_PERMISSION_CODE);\r\n        }\r\n    }).create();\r\n    dialog.show();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorPlanReconstructionActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    ActivityCompat.requestPermissions(FloorPlanReconstructionActivity.this, new String[] { CAMERA_PERMISSION }, CAMERA_PERMISSION_CODE);\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.Tesseract1.getRecognizedWords",
	"Comment": "gets result words at specified page iterator level from recognized pages.",
	"Method": "List<Word> getRecognizedWords(int pageIteratorLevel){\r\n    List<Word> words = new ArrayList();\r\n    try {\r\n        TessResultIterator ri = TessBaseAPIGetIterator(handle);\r\n        TessPageIterator pi = TessResultIteratorGetPageIterator(ri);\r\n        TessPageIteratorBegin(pi);\r\n        do {\r\n            Pointer ptr = TessResultIteratorGetUTF8Text(ri, pageIteratorLevel);\r\n            String text = ptr.getString(0);\r\n            TessAPI1.TessDeleteText(ptr);\r\n            float confidence = TessResultIteratorConfidence(ri, pageIteratorLevel);\r\n            IntBuffer leftB = IntBuffer.allocate(1);\r\n            IntBuffer topB = IntBuffer.allocate(1);\r\n            IntBuffer rightB = IntBuffer.allocate(1);\r\n            IntBuffer bottomB = IntBuffer.allocate(1);\r\n            TessPageIteratorBoundingBox(pi, pageIteratorLevel, leftB, topB, rightB, bottomB);\r\n            int left = leftB.get();\r\n            int top = topB.get();\r\n            int right = rightB.get();\r\n            int bottom = bottomB.get();\r\n            Word word = new Word(text, confidence, new Rectangle(left, top, right - left, bottom - top));\r\n            words.add(word);\r\n        } while (TessPageIteratorNext(pi, pageIteratorLevel) == TRUE);\r\n    } catch (Exception e) {\r\n        logger.warn(e.getMessage(), e);\r\n    }\r\n    return words;\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.util.Geom.multi",
	"Comment": "converts a geometry object into the associated geometry collection. forexample polygon to multipolygon. if the input is already a collection it is returned as is.",
	"Method": "GeometryCollection multi(Geometry g){\r\n    switch(Geom.Type.from(g)) {\r\n        case POINT:\r\n            return factory.createMultiPoint(new Point[] { (Point) g });\r\n        case LINESTRING:\r\n            return factory.createMultiLineString(new LineString[] { (LineString) g });\r\n        case POLYGON:\r\n            return factory.createMultiPolygon(new Polygon[] { (Polygon) g });\r\n        default:\r\n            return (GeometryCollection) g;\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ServerHelloParser.parseCertificateType",
	"Comment": "reads the next bytes as the certificatetype and writes them in themessage",
	"Method": "void parseCertificateType(SSL2ServerHelloMessage message){\r\n    message.setCertificateType(parseByteField(SSL2ByteLength.CERTIFICATE_TYPE));\r\n    LOGGER.debug(\"CertificateType: \" + message.getCertificateType().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetDhClientPublicKey",
	"Comment": "test of getdhclientpublickey method, of class defaultchooser.",
	"Method": "void testGetDhClientPublicKey(){\r\n    context.setClientDhPublicKey(null);\r\n    config.setDefaultClientDhPublicKey(BigInteger.ONE);\r\n    assertEquals(BigInteger.ONE, config.getDefaultClientDhPublicKey());\r\n    assertEquals(BigInteger.ONE, chooser.getDhClientPublicKey());\r\n    context.setClientDhPublicKey(BigInteger.TEN);\r\n    assertEquals(BigInteger.TEN, chooser.getDhClientPublicKey());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.motiontracking.MotionTrackingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to pose data.",
	"Method": "void startupTango(){\r\n    ArrayList<TangoCoordinateFramePair> framePairs = new ArrayList<TangoCoordinateFramePair>();\r\n    framePairs.add(new TangoCoordinateFramePair(TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_DEVICE));\r\n    mTango.connectListener(framePairs, new Tango.OnTangoUpdateListener() {\r\n        @Override\r\n        public void onPoseAvailable(final TangoPoseData pose) {\r\n            mIsTangoPoseReady.compareAndSet(false, true);\r\n        }\r\n        @Override\r\n        public void onXyzIjAvailable(TangoXyzIjData xyzIj) {\r\n        }\r\n        @Override\r\n        public void onPointCloudAvailable(final TangoPointCloudData pointCloudData) {\r\n        }\r\n        @Override\r\n        public void onTangoEvent(final TangoEvent event) {\r\n        }\r\n        @Override\r\n        public void onFrameAvailable(int cameraId) {\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.motiontracking.MotionTrackingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to pose data.",
	"Method": "void startupTango(){\r\n    mIsTangoPoseReady.compareAndSet(false, true);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.motiontracking.MotionTrackingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to pose data.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.motiontracking.MotionTrackingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to pose data.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.motiontracking.MotionTrackingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to pose data.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.motiontracking.MotionTrackingActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to pose data.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.diffplug.spotless.generic.LicenseHeaderStep.createFromHeader",
	"Comment": "creates a formatterstep which forces the start of each file to match a license header.",
	"Method": "FormatterStep createFromHeader(String licenseHeader,String delimiter,FormatterStep createFromHeader,String licenseHeader,String delimiter,String yearSeparator){\r\n    Objects.requireNonNull(licenseHeader, \"licenseHeader\");\r\n    Objects.requireNonNull(delimiter, \"delimiter\");\r\n    Objects.requireNonNull(yearSeparator, \"yearSeparator\");\r\n    return FormatterStep.create(LicenseHeaderStep.NAME, new LicenseHeaderStep(licenseHeader, delimiter, yearSeparator), step -> step::format);\r\n}"
}, {
	"Path": "com.diffplug.spotless.PaddedCellBulk.applyAnyChanged",
	"Comment": "performs the typical spotlessapply, but with paddedcell handling of misbehaving formattersteps.",
	"Method": "boolean applyAnyChanged(Formatter formatter,File file){\r\n    Objects.requireNonNull(formatter, \"formatter\");\r\n    Objects.requireNonNull(file, \"file\");\r\n    byte[] rawBytes = Files.readAllBytes(file.toPath());\r\n    String raw = new String(rawBytes, formatter.getEncoding());\r\n    String rawUnix = LineEnding.toUnix(raw);\r\n    String formattedUnix = formatter.compute(rawUnix, file);\r\n    String formatted = formatter.computeLineEndings(formattedUnix, file);\r\n    byte[] formattedBytes = formatted.getBytes(formatter.getEncoding());\r\n    if (Arrays.equals(rawBytes, formattedBytes)) {\r\n        return false;\r\n    }\r\n    PaddedCell cell = PaddedCell.check(formatter, file, rawUnix);\r\n    if (!cell.isResolvable()) {\r\n        return false;\r\n    }\r\n    String canonicalUnix = cell.canonical();\r\n    String canonical = formatter.computeLineEndings(canonicalUnix, file);\r\n    byte[] canonicalBytes = canonical.getBytes(formatter.getEncoding());\r\n    if (!Arrays.equals(rawBytes, canonicalBytes)) {\r\n        Files.write(file.toPath(), canonicalBytes, StandardOpenOption.TRUNCATE_EXISTING);\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.calculateModelTransformFixedToCam",
	"Comment": "calculate the transform needed to place the model in the upper left corner of the camera,and rotate it to show the next point to make the correspondence.",
	"Method": "float[] calculateModelTransformFixedToCam(int mDisplayRotation){\r\n    float[] rgbTHouse = new float[16];\r\n    Matrix.setIdentityM(rgbTHouse, 0);\r\n    if (mDisplayRotation == Surface.ROTATION_0 || mDisplayRotation == Surface.ROTATION_180) {\r\n        Matrix.translateM(rgbTHouse, 0, 0f, 1.2f, -4);\r\n    } else {\r\n        Matrix.translateM(rgbTHouse, 0, -1.5f, 0.3f, -4);\r\n    }\r\n    Matrix.rotateM(rgbTHouse, 0, 180, 0, 0, 1);\r\n    Matrix.rotateM(rgbTHouse, 0, 70, 1, 0, 0);\r\n    Matrix.rotateM(rgbTHouse, 0, -mModelZRotation, 0, 0, 1);\r\n    Matrix.scaleM(rgbTHouse, 0, 0.03f, 0.03f, 0.03f);\r\n    return rgbTHouse;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.HeartbeatDelegateTest.testApplyDelegate",
	"Comment": "test of applydelegate method, of class heartbeatdelegate.",
	"Method": "void testApplyDelegate(){\r\n    Config config = Config.createConfig();\r\n    config.setHeartbeatMode(null);\r\n    args = new String[2];\r\n    args[0] = \"-heartbeat_mode\";\r\n    args[1] = \"PEER_ALLOWED_TO_SEND\";\r\n    jcommander.parse(args);\r\n    assertFalse(config.isAddHeartbeatExtension());\r\n    delegate.applyDelegate(config);\r\n    assertTrue(config.getHeartbeatMode() == HeartbeatMode.PEER_ALLOWED_TO_SEND);\r\n    assertTrue(config.isAddHeartbeatExtension());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.SignatureAndHashAlgorithmsExtensionHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of classsignatureandhashalgorithmsextensionhandler.",
	"Method": "void testAdjustTLSContext(){\r\n    SignatureAndHashAlgorithmsExtensionMessage msg = new SignatureAndHashAlgorithmsExtensionMessage();\r\n    msg.setSignatureAndHashAlgorithms(new byte[] { 0, 0 });\r\n    handler.adjustTLSContext(msg);\r\n    assertTrue(context.getClientSupportedSignatureAndHashAlgorithms().size() == 1);\r\n    assertTrue(context.getClientSupportedSignatureAndHashAlgorithms().get(0).getHashAlgorithm() == HashAlgorithm.NONE);\r\n    assertTrue(context.getClientSupportedSignatureAndHashAlgorithms().get(0).getSignatureAlgorithm() == SignatureAlgorithm.ANONYMOUS);\r\n}"
}, {
	"Path": "com.diffplug.spotless.java.ImportSorterImpl.mergeNotMatchingItems",
	"Comment": "not matching means it does not match any order item, so it will be appended before or after order items",
	"Method": "void mergeNotMatchingItems(boolean staticItems){\r\n    Collections.sort(notMatching);\r\n    int firstIndexOfOrderItem = getFirstIndexOfOrderItem(notMatching, staticItems);\r\n    int indexOfOrderItem = 0;\r\n    for (String notMatchingItem : notMatching) {\r\n        if (!matchesStatic(staticItems, notMatchingItem)) {\r\n            continue;\r\n        }\r\n        boolean isOrderItem = isOrderItem(notMatchingItem, staticItems);\r\n        if (isOrderItem) {\r\n            indexOfOrderItem = template.indexOf(notMatchingItem);\r\n        } else {\r\n            if (indexOfOrderItem == 0 && firstIndexOfOrderItem != 0) {\r\n                template.add(firstIndexOfOrderItem, notMatchingItem);\r\n                firstIndexOfOrderItem++;\r\n            } else if (firstIndexOfOrderItem == 0) {\r\n                if (template.size() > 0 && (template.get(template.size() - 1).startsWith(\"static\"))) {\r\n                    template.add(ImportSorter.N);\r\n                }\r\n                template.add(notMatchingItem);\r\n            } else {\r\n                template.add(indexOfOrderItem + 1, notMatchingItem);\r\n                indexOfOrderItem++;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.state.ContextContainer.replaceTlsContext",
	"Comment": "replace existing tlscontext with new tlscontext.the tlscontext can only be replaced if the connection of both the new andthe old tlscontext equal.",
	"Method": "void replaceTlsContext(TlsContext newTlsContext){\r\n    String alias = newTlsContext.getConnection().getAlias();\r\n    if (!containsAlias(alias)) {\r\n        throw new ConfigurationException(\"No TlsContext to replace for alias \" + alias);\r\n    }\r\n    TlsContext replaceMe = tlsContexts.get(alias);\r\n    if (!replaceMe.getConnection().equals(newTlsContext.getConnection())) {\r\n        throw new ContextHandlingException(\"Cannot replace TlsContext because the new TlsContext\" + \" defines another connection.\");\r\n    }\r\n    removeTlsContext(alias);\r\n    addTlsContext(newTlsContext);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.socket.InboundConnectionTest.testSerializeNonDefaultFields",
	"Comment": "verify that the serverconnectionend includes manually set values inserialization output.",
	"Method": "void testSerializeNonDefaultFields(){\r\n    TestXmlRoot expected = new TestXmlRoot();\r\n    expected.setAlias(\"TestMe\");\r\n    expected.setPort(4444);\r\n    m.marshal(expected, writer);\r\n    String xmlString = writer.toString();\r\n    LOGGER.debug(xmlString);\r\n    StringBuilder sb = new StringBuilder(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\\n\");\r\n    sb.append(\"<testXmlRoot>\\n\");\r\n    sb.append(\"    <alias>TestMe<\/alias>\\n\");\r\n    sb.append(\"    <port>4444<\/port>\\n\");\r\n    sb.append(\"<\/testXmlRoot>\\n\");\r\n    assertEquals(sb.toString(), xmlString);\r\n    Unmarshaller um = context.createUnmarshaller();\r\n    TestXmlRoot actual = (TestXmlRoot) um.unmarshal(new StringReader(xmlString));\r\n    assertEquals(expected, actual);\r\n    assertNotSame(expected, actual);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.HelloVerifyRequestSerializerTest.testSerializeHandshakeMessageContent",
	"Comment": "test of serializehandshakemessagecontent method, of classhelloverifyrequestserializer.",
	"Method": "void testSerializeHandshakeMessageContent(){\r\n    HelloVerifyRequestMessage msg = new HelloVerifyRequestMessage();\r\n    msg.setCompleteResultingMessage(message);\r\n    msg.setType(type.getValue());\r\n    msg.setType(type.getValue());\r\n    msg.setProtocolVersion(protocolVersion);\r\n    msg.setCookieLength(cookieLength);\r\n    msg.setCookie(cookie);\r\n    msg.setLength(length);\r\n    msg.setMessageSeq(messageSeq);\r\n    msg.setFragmentOffset(fragmentOffset);\r\n    msg.setFragmentLength(fragmentLength);\r\n    HelloVerifyRequestSerializer serializer = new HelloVerifyRequestSerializer(msg, ProtocolVersion.DTLS10);\r\n    assertArrayEquals(message, serializer.serialize());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.transport.tcp.timing.TimingClientTcpTransportHandlerTest.testCloseConnection",
	"Comment": "test of closeconnection method, of class timingclienttcptransporthandler.",
	"Method": "void testCloseConnection(){\r\n    handler = new TimingClientTcpTransportHandler(100, \"localhost\", 0);\r\n    handler.closeConnection();\r\n}"
}, {
	"Path": "com.diffplug.spotless.Formatter.computeLineEndings",
	"Comment": "applies the appropriate line endings to the given unix content.",
	"Method": "String computeLineEndings(String unix,File file){\r\n    Objects.requireNonNull(unix, \"unix\");\r\n    Objects.requireNonNull(file, \"file\");\r\n    String ending = lineEndingsPolicy.getEndingFor(file);\r\n    if (!ending.equals(LineEnding.UNIX.str())) {\r\n        return unix.replace(LineEnding.UNIX.str(), ending);\r\n    } else {\r\n        return unix;\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.greenscreen.GreenScreenActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    final AlertDialog dialog = new AlertDialog.Builder(this).setMessage(\"Java Green Screen Example requires camera and write external \" + \"storage permissions\").setPositiveButton(\"Ok\", new DialogInterface.OnClickListener() {\r\n        @Override\r\n        public void onClick(DialogInterface dialogInterface, int i) {\r\n            ActivityCompat.requestPermissions(GreenScreenActivity.this, new String[] { CAMERA_PERMISSION, WRITE_PERMISSION }, MULTIPLE_PERMISSION_CODE);\r\n        }\r\n    }).create();\r\n    dialog.show();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.greenscreen.GreenScreenActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    ActivityCompat.requestPermissions(GreenScreenActivity.this, new String[] { CAMERA_PERMISSION, WRITE_PERMISSION }, MULTIPLE_PERMISSION_CODE);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.DHClientKeyExchangeHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class dhclientkeyexchangehandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof DHClientKeyExchangeParser);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.ECDHClientKeyExchangePreparatorTest.testPrepare",
	"Comment": "test of preparehandshakemessagecontents method, of classecdhclientkeyexchangepreparator.",
	"Method": "void testPrepare(){\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS12);\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256);\r\n    context.setClientRandom(ArrayConverter.hexStringToByteArray(RANDOM));\r\n    context.setServerRandom(ArrayConverter.hexStringToByteArray(RANDOM));\r\n    context.getConfig().setDefaultSelectedNamedGroup(NamedGroup.SECP192R1);\r\n    context.setSelectedGroup(NamedGroup.SECP192R1);\r\n    context.setServerEcPublicKey(new CustomECPoint(new BigInteger(\"1336698681267683560144780033483217462176613397209956026562\"), new BigInteger(\"4390496211885670837594012513791855863576256216444143941964\")));\r\n    context.getConfig().setDefaultClientEcPrivateKey(new BigInteger(\"3\"));\r\n    preparator.prepare();\r\n    assertNotNull(message.getComputations().getComputedPublicKeyX());\r\n    assertNotNull(message.getComputations().getComputedPublicKeyY());\r\n    assertArrayEquals(PREMASTER_SECRET, message.getComputations().getPremasterSecret().getValue());\r\n    assertNotNull(message.getPublicKeyLength().getValue());\r\n    assertNotNull(message.getPublicKey());\r\n    assertNotNull(message.getComputations().getClientServerRandom());\r\n    assertArrayEquals(ArrayConverter.concatenate(ArrayConverter.hexStringToByteArray(RANDOM), ArrayConverter.hexStringToByteArray(RANDOM)), message.getComputations().getClientServerRandom().getValue());\r\n}"
}, {
	"Path": "org.takes.facets.hamcrest.HmHeaderTest.testsMultipleHeadersAvailable",
	"Comment": "hmrqheader can test whether multiple headers are available.",
	"Method": "void testsMultipleHeadersAvailable(){\r\n    MatcherAssert.assertThat(new RqWithHeaders(new RqFake(), \"header3: value31\", \"header3: value32\"), new HmHeader(\"header3\", Matchers.hasItems(\"value31\", \"value32\")));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ReceiveAsciiActionTest.testExecuteWorkflowExecutionException",
	"Comment": "test of workflowexecutionexception of execute method, of classreceiveasciiaction.",
	"Method": "void testExecuteWorkflowExecutionException(){\r\n    action.execute(state);\r\n    action.execute(state);\r\n}"
}, {
	"Path": "com.diffplug.spotless.PaddedCellBulk.apply",
	"Comment": "performs the typical spotlessapply, but with paddedcell handling of misbehaving formattersteps.",
	"Method": "void apply(Formatter formatter,File file){\r\n    applyAnyChanged(formatter, file);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.SignedCertificateTimestampExtensionHandler.getPreparator",
	"Comment": "returns a new signedcertificatetimestampextensionpreparator",
	"Method": "SignedCertificateTimestampExtensionPreparator getPreparator(SignedCertificateTimestampExtensionMessage message){\r\n    return new SignedCertificateTimestampExtensionPreparator(context.getChooser(), message, getSerializer(message));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.FinishedHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class finishedhandler.",
	"Method": "void testAdjustTLSContext(){\r\n    FinishedMessage message = new FinishedMessage();\r\n    message.setVerifyData(new byte[] { 0, 1, 2, 3, 4 });\r\n    handler.adjustTLSContext(message);\r\n    assertArrayEquals(new byte[] { 0, 1, 2, 3, 4 }, context.getLastClientVerifyData());\r\n    assertArrayEquals(null, context.getLastServerVerifyData());\r\n    assertEquals(Tls13KeySetType.NONE, context.getActiveServerKeySetType());\r\n    assertEquals(Tls13KeySetType.NONE, context.getActiveClientKeySetType());\r\n    assertArrayEquals(null, context.getClientApplicationTrafficSecret());\r\n    assertArrayEquals(null, context.getServerApplicationTrafficSecret());\r\n    assertArrayEquals(null, context.getMasterSecret());\r\n}"
}, {
	"Path": "com.projecttango.rajawali.ScenePoseCalculator.toOpenGLPoseWithScreenRotation",
	"Comment": "given a pose in start of service or area description frame and a screen rotaion, calculatethe corresponding position and orientation for a 3d object in the rajawali world.",
	"Method": "Pose toOpenGLPoseWithScreenRotation(TangoPoseData tangoPose,int rotationIndex){\r\n    Matrix4 startServiceTDevice = tangoPoseToMatrix(tangoPose);\r\n    Matrix4 openglWorldTDevice = OPENGL_T_TANGO_WORLD.clone().multiply(startServiceTDevice);\r\n    switch(rotationIndex) {\r\n        case 0:\r\n            openglWorldTDevice.multiply(ROTATION_0_T_DEFAULT);\r\n            break;\r\n        case 1:\r\n            openglWorldTDevice.multiply(ROTATION_90_T_DEFAULT);\r\n            break;\r\n        case 2:\r\n            openglWorldTDevice.multiply(ROTATION_180_T_DEFAULT);\r\n            break;\r\n        case 3:\r\n            openglWorldTDevice.multiply(ROTATION_270_T_DEFAULT);\r\n            break;\r\n        default:\r\n            openglWorldTDevice.multiply(ROTATION_0_T_DEFAULT);\r\n            break;\r\n    }\r\n    return matrixToPose(openglWorldTDevice);\r\n}"
}, {
	"Path": "com.diffplug.spotless.StepHarness.testResourceUnaffected",
	"Comment": "asserts that the given elements in the resources directory are transformed as expected.",
	"Method": "StepHarness testResourceUnaffected(String resourceIdempotent){\r\n    String idempotentElement = ResourceHarness.getTestResource(resourceIdempotent);\r\n    return testUnaffected(idempotentElement);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ClientHelloParser.parseSessionID",
	"Comment": "reads the next bytes as the sessionid and writes them in the message",
	"Method": "void parseSessionID(SSL2ClientHelloMessage msg){\r\n    msg.setSessionID(parseByteArrayField(msg.getSessionIdLength().getValue()));\r\n    LOGGER.debug(\"SessionID: \" + ArrayConverter.bytesToHexString(msg.getSessionId().getValue()));\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.Utilities.slowStringComparison",
	"Comment": "this method is low performance string comparison function. the purpose ofthis method is to prevent timing attack.",
	"Method": "boolean slowStringComparison(String givenSignature,String computedSignature){\r\n    if (null == givenSignature || null == computedSignature || givenSignature.length() != computedSignature.length())\r\n        return false;\r\n    int n = computedSignature.length();\r\n    boolean signaturesMatch = true;\r\n    for (int i = 0; i < n; i++) {\r\n        signaturesMatch &= (computedSignature.charAt(i) == givenSignature.charAt(i));\r\n    }\r\n    return signaturesMatch;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SrpServerKeyExchangeParser.parseGeneratorLength",
	"Comment": "reads the next bytes as the glength and writes them in the message",
	"Method": "void parseGeneratorLength(SrpServerKeyExchangeMessage msg){\r\n    msg.setGeneratorLength(parseIntField(HandshakeByteLength.SRP_GENERATOR_LENGTH));\r\n    LOGGER.debug(\"gLength: \" + msg.getGeneratorLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.extension.KeySharePairPreparatorTest.testPrepare",
	"Comment": "test of prepare method, of class keyshareentrypreparator.",
	"Method": "void testPrepare(){\r\n    preparator.prepare();\r\n    assertArrayEquals(entry.getPublicKey().getValue(), ArrayConverter.hexStringToByteArray(\"2a981db6cdd02a06c1763102c9e741365ac4e6f72b3176a6bd6a3523d3ec0f4c\"));\r\n    assertTrue(entry.getPublicKeyLength().getValue() == 32);\r\n    assertArrayEquals(entry.getGroup().getValue(), ArrayConverter.hexStringToByteArray(\"001D\"));\r\n}"
}, {
	"Path": "studio.carbonylgroup.textfieldboxes.TextFieldBoxes.setError",
	"Comment": "set highlight color and helperlabel label text color to errorcolorset helperlabel label text to error message",
	"Method": "void setError(String errorText,boolean giveFocus){\r\n    if (this.enabled) {\r\n        this.onError = true;\r\n        activate(true);\r\n        setHighlightColor(this.errorColor);\r\n        this.helperLabel.setTextColor(this.errorColor);\r\n        if (errorText != null) {\r\n            this.helperLabel.setText(errorText);\r\n            updateBottomViewVisibility();\r\n        }\r\n        if (giveFocus)\r\n            setHasFocus(true);\r\n        makeCursorBlink();\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.constants.AlgorithmResolverTest.testGetPRFAlgorithm",
	"Comment": "test of getprfalgorithm method, of class algorithmresolver.",
	"Method": "void testGetPRFAlgorithm(){\r\n    for (CipherSuite suite : CipherSuite.values()) {\r\n        if (suite.name().contains(\"GOST\")) {\r\n            continue;\r\n        }\r\n        assertTrue(AlgorithmResolver.getPRFAlgorithm(ProtocolVersion.TLS10, suite) == PRFAlgorithm.TLS_PRF_LEGACY);\r\n        assertTrue(AlgorithmResolver.getPRFAlgorithm(ProtocolVersion.TLS11, suite) == PRFAlgorithm.TLS_PRF_LEGACY);\r\n        assertTrue(AlgorithmResolver.getPRFAlgorithm(ProtocolVersion.DTLS10, suite) == PRFAlgorithm.TLS_PRF_LEGACY);\r\n    }\r\n    assertTrue(AlgorithmResolver.getPRFAlgorithm(ProtocolVersion.TLS12, CipherSuite.TLS_DHE_DSS_WITH_AES_256_GCM_SHA384) == PRFAlgorithm.TLS_PRF_SHA384);\r\n    assertTrue(AlgorithmResolver.getPRFAlgorithm(ProtocolVersion.DTLS12, CipherSuite.TLS_DHE_DSS_WITH_AES_256_GCM_SHA384) == PRFAlgorithm.TLS_PRF_SHA384);\r\n    assertTrue(AlgorithmResolver.getPRFAlgorithm(ProtocolVersion.TLS12, CipherSuite.TLS_CECPQ1_ECDSA_WITH_CHACHA20_POLY1305_SHA256) == PRFAlgorithm.TLS_PRF_SHA256);\r\n    assertTrue(AlgorithmResolver.getPRFAlgorithm(ProtocolVersion.DTLS12, CipherSuite.TLS_CECPQ1_ECDSA_WITH_CHACHA20_POLY1305_SHA256) == PRFAlgorithm.TLS_PRF_SHA256);\r\n    assertTrue(AlgorithmResolver.getPRFAlgorithm(ProtocolVersion.TLS12, CipherSuite.SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA) == PRFAlgorithm.TLS_PRF_SHA256);\r\n    assertTrue(AlgorithmResolver.getPRFAlgorithm(ProtocolVersion.DTLS12, CipherSuite.TLS_DHE_PSK_WITH_AES_256_CCM) == PRFAlgorithm.TLS_PRF_SHA256);\r\n    assertTrue(AlgorithmResolver.getPRFAlgorithm(ProtocolVersion.TLS12, CipherSuite.TLS_DH_anon_EXPORT_WITH_RC4_40_MD5) == PRFAlgorithm.TLS_PRF_SHA256);\r\n    assertTrue(AlgorithmResolver.getPRFAlgorithm(ProtocolVersion.TLS12, CipherSuite.TLS_GOSTR341001_WITH_28147_CNT_IMIT) == PRFAlgorithm.TLS_PRF_GOSTR3411);\r\n    assertTrue(AlgorithmResolver.getPRFAlgorithm(ProtocolVersion.TLS12, CipherSuite.TLS_GOSTR341112_256_WITH_28147_CNT_IMIT) == PRFAlgorithm.TLS_PRF_GOSTR3411_2012_256);\r\n}"
}, {
	"Path": "com.novoda.inkyphat.ImageScaler.fitXY",
	"Comment": "scale in width and height independently, so that sourcebitmap matches dst exactly.this may change the aspect ratio of the sourcebitmap.",
	"Method": "Bitmap fitXY(Bitmap sourceBitmap,int maxWidth,int maxHeight){\r\n    int bitmapWidth = sourceBitmap.getWidth();\r\n    int bitmapHeight = sourceBitmap.getHeight();\r\n    if (bitmapWidth > maxWidth || bitmapHeight > maxHeight) {\r\n        return scaleBitmap(sourceBitmap, maxWidth, maxHeight);\r\n    } else {\r\n        return sourceBitmap.copy(Bitmap.Config.ARGB_8888, true);\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud.",
	"Method": "void startupTango(){\r\n    checkTangoVersion();\r\n    mTangoMesher = new TangoMesher(new TangoMesher.OnTangoMeshesAvailableListener() {\r\n        @Override\r\n        public void onMeshesAvailable(TangoMesh[] tangoMeshes) {\r\n            mMeshVector = tangoMeshes;\r\n        }\r\n    });\r\n    mIntrinsics = mTango.getCameraIntrinsics(TangoCameraIntrinsics.TANGO_CAMERA_COLOR);\r\n    mTangoMesher.setColorCameraCalibration(mIntrinsics);\r\n    mTangoMesher.setDepthCameraCalibration(mTango.getCameraIntrinsics(TangoCameraIntrinsics.TANGO_CAMERA_DEPTH));\r\n    mTangoMesher.startSceneReconstruction();\r\n    List<TangoCoordinateFramePair> framePairs = new ArrayList<TangoCoordinateFramePair>();\r\n    mTango.connectListener(framePairs, new Tango.OnTangoUpdateListener() {\r\n        @Override\r\n        public void onPoseAvailable(TangoPoseData tangoPoseData) {\r\n        }\r\n        @Override\r\n        public void onXyzIjAvailable(TangoXyzIjData tangoXyzIjData) {\r\n        }\r\n        @Override\r\n        public void onFrameAvailable(int i) {\r\n        }\r\n        @Override\r\n        public void onTangoEvent(TangoEvent tangoEvent) {\r\n        }\r\n        @Override\r\n        public void onPointCloudAvailable(TangoPointCloudData tangoPointCloudData) {\r\n            mTangoMesher.onPointCloudAvailable(tangoPointCloudData);\r\n        }\r\n    });\r\n    mTango.experimentalConnectOnFrameListener(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, new Tango.OnFrameAvailableListener() {\r\n        @Override\r\n        public void onFrameAvailable(TangoImageBuffer tangoImageBuffer, int i) {\r\n            mTangoMesher.onFrameAvailable(tangoImageBuffer, i);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud.",
	"Method": "void startupTango(){\r\n    mMeshVector = tangoMeshes;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud.",
	"Method": "void startupTango(){\r\n    mTangoMesher.onPointCloudAvailable(tangoPointCloudData);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud.",
	"Method": "void startupTango(){\r\n    mTangoMesher.onFrameAvailable(tangoImageBuffer, i);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.util.ModifiableVariableAnalyzerTest.testGetAllModifiableVariableFields",
	"Comment": "test of getallmodifiablevariablefields method, of classmodifiablevariableanalyzer.",
	"Method": "void testGetAllModifiableVariableFields(){\r\n    ClientHelloMessage chm = new ClientHelloMessage(Config.createConfig());\r\n    String[] fieldNames = { \"compressionLength\", \"cipherSuiteLength\", \"cipherSuites\", \"compressions\", \"protocolVersion\", \"unixTime\", \"random\", \"sessionIdLength\", \"sessionId\", \"type\", \"completeResultingMessage\" };\r\n    List<Field> fields = ModifiableVariableAnalyzer.getAllModifiableVariableFields(chm);\r\n    for (String fn : fieldNames) {\r\n        assertTrue(containsFieldName(fn, fields));\r\n    }\r\n    assertFalse(containsFieldName(\"somename\", fields));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetSignedCertificateTimestamp",
	"Comment": "test of getsignedcertificatetimestamp method, of class defaultchooser.",
	"Method": "void testGetSignedCertificateTimestamp(){\r\n    context.setSignedCertificateTimestamp(null);\r\n    byte[] timestamp = ArrayConverter.hexStringToByteArray(\"122131123987891238098123\");\r\n    byte[] timestamp2 = ArrayConverter.hexStringToByteArray(\"1221311239878912380981281294\");\r\n    config.setDefaultSignedCertificateTimestamp(timestamp);\r\n    assertArrayEquals(timestamp, config.getDefaultSignedCertificateTimestamp());\r\n    assertArrayEquals(timestamp, chooser.getSignedCertificateTimestamp());\r\n    context.setSignedCertificateTimestamp(timestamp2);\r\n    assertArrayEquals(timestamp2, chooser.getSignedCertificateTimestamp());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.CompressionDelegateTest.testSetCompressionMethods",
	"Comment": "test of setcompressionmethods method, of class compressiondelegate.",
	"Method": "void testSetCompressionMethods(){\r\n    LinkedList<CompressionMethod> supportedCompressions = new LinkedList();\r\n    supportedCompressions.add(CompressionMethod.LZS);\r\n    delegate.setCompressionMethods(supportedCompressions);\r\n    assertTrue(\"CompressionMethods setter is not working correctly\", delegate.getCompressionMethods().equals(supportedCompressions));\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.indexing.AbstractIndexerBolt.valueForURL",
	"Comment": "returns the value to be used as the url for indexing purposes, if presentthe canonical value is used instead",
	"Method": "String valueForURL(Tuple tuple){\r\n    String url = tuple.getStringByField(\"url\");\r\n    Metadata metadata = (Metadata) tuple.getValueByField(\"metadata\");\r\n    if (StringUtils.isBlank(canonicalMetadataParamName)) {\r\n        return url;\r\n    }\r\n    String canonicalValue = metadata.getFirstValue(canonicalMetadataName);\r\n    if (StringUtils.isBlank(canonicalValue)) {\r\n        return url;\r\n    }\r\n    try {\r\n        URL sURL = new URL(url);\r\n        URL canonical = URLUtil.resolveURL(sURL, canonicalValue);\r\n        if (sURL.getHost().equals(canonical.getHost())) {\r\n            return canonical.toExternalForm();\r\n        } else {\r\n            LOG.info(\"Canonical URL references a different host, ignoring in {} \", url);\r\n        }\r\n    } catch (MalformedURLException e) {\r\n        LOG.error(\"Malformed canonical URL {} was found in {} \", canonicalValue, url);\r\n    }\r\n    return url;\r\n}"
}, {
	"Path": "org.springframework.statemachine.processor.StateMachineAnnotationPostProcessor.getBeanClass",
	"Comment": "gets the bean class. will check if bean is a proxy and\tfind a class from there as target class, otherwise\twe just get bean class.",
	"Method": "Class<?> getBeanClass(Object bean){\r\n    Class<?> targetClass = AopUtils.getTargetClass(bean);\r\n    return (targetClass != null) ? targetClass : bean.getClass();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.attacks.ec.oracles.RealDirectMessageECOracle.executeValidWorkflowAndExtractCheckValues",
	"Comment": "executes a valid workflow with valid points etc. and saves the values forfurther validation purposes.",
	"Method": "void executeValidWorkflowAndExtractCheckValues(){\r\n    State state = new State(config);\r\n    WorkflowExecutor workflowExecutor = WorkflowExecutorFactory.createWorkflowExecutor(config.getWorkflowExecutorType(), state);\r\n    WorkflowTrace trace = state.getWorkflowTrace();\r\n    workflowExecutor.executeWorkflow();\r\n    ECDHClientKeyExchangeMessage message = (ECDHClientKeyExchangeMessage) WorkflowTraceUtil.getFirstSendMessage(HandshakeMessageType.CLIENT_KEY_EXCHANGE, trace);\r\n    BigInteger x = message.getComputations().getComputedPublicKeyX().getValue();\r\n    BigInteger y = message.getComputations().getComputedPublicKeyY().getValue();\r\n    checkPoint = new Point(x, y);\r\n    checkPMS = message.getComputations().getPremasterSecret().getValue();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetClientEcPublicKey",
	"Comment": "test of getclientecpublickey method, of class defaultchooser.",
	"Method": "void testGetClientEcPublicKey(){\r\n    context.setClientEcPublicKey(null);\r\n    config.setDefaultClientEcPublicKey(new CustomECPoint(BigInteger.ONE, BigInteger.TEN));\r\n    assertEquals(new CustomECPoint(BigInteger.ONE, BigInteger.TEN), config.getDefaultClientEcPublicKey());\r\n    assertEquals(new CustomECPoint(BigInteger.ONE, BigInteger.TEN), chooser.getClientEcPublicKey());\r\n    context.setClientEcPublicKey(new CustomECPoint(BigInteger.ZERO, BigInteger.TEN));\r\n    assertEquals(new CustomECPoint(BigInteger.ZERO, BigInteger.TEN), chooser.getClientEcPublicKey());\r\n}"
}, {
	"Path": "com.diffplug.spotless.PaddedCellBulk.check",
	"Comment": "performs a full check using paddedcell logic on the given files with the given formatter.\tif any are found which do not conform to the paddedcell, a description of the error will\tbe written to the diagnose dir.",
	"Method": "List<File> check(File rootDir,File diagnoseDir,Formatter formatter,List<File> problemFiles){\r\n    Objects.requireNonNull(rootDir, \"rootDir\");\r\n    Objects.requireNonNull(diagnoseDir, \"diagnoseDir\");\r\n    Objects.requireNonNull(formatter, \"formatter\");\r\n    Objects.requireNonNull(problemFiles, \"problemFiles\");\r\n    FakeStep paddedCellStep = new FakeStep();\r\n    try (Formatter paddedFormatter = Formatter.builder().lineEndingsPolicy(formatter.getLineEndingsPolicy()).encoding(formatter.getEncoding()).rootDir(formatter.getRootDir()).steps(Collections.singletonList(paddedCellStep)).exceptionPolicy(formatter.getExceptionPolicy()).build()) {\r\n        Path rootPath = rootDir.toPath();\r\n        Path diagnosePath = diagnoseDir.toPath();\r\n        cleanDir(diagnosePath);\r\n        List<File> stillFailing = new ArrayList();\r\n        for (File problemFile : problemFiles) {\r\n            logger.fine(\"Running padded cell check on \" + problemFile);\r\n            PaddedCell padded = PaddedCell.check(formatter, problemFile);\r\n            if (!padded.misbehaved()) {\r\n                logger.fine(\"    well-behaved.\");\r\n            } else {\r\n                Path relative = rootPath.relativize(problemFile.toPath());\r\n                Path diagnoseFile = diagnosePath.resolve(relative);\r\n                for (int i = 0; i < padded.steps().size(); ++i) {\r\n                    Path path = Paths.get(diagnoseFile + \".\" + padded.type().name().toLowerCase(Locale.ROOT) + i);\r\n                    Files.createDirectories(path.getParent());\r\n                    String version = padded.steps().get(i);\r\n                    Files.write(path, version.getBytes(formatter.getEncoding()));\r\n                }\r\n                logger.finer(\"    \" + relative + \" \" + padded.userMessage());\r\n                if (!padded.isResolvable()) {\r\n                } else {\r\n                    paddedCellStep.set(problemFile, padded.canonical());\r\n                    if (!paddedFormatter.isClean(problemFile)) {\r\n                        stillFailing.add(problemFile);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return stillFailing;\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.CiphersuiteDelegateTest.testSetCipherSuites",
	"Comment": "test of setciphersuites method, of class ciphersuitedelegate.",
	"Method": "void testSetCipherSuites(){\r\n    LinkedList<CipherSuite> supportedCipherSuites = new LinkedList();\r\n    supportedCipherSuites.add(CipherSuite.TLS_FALLBACK_SCSV);\r\n    delegate.setCipherSuites(supportedCipherSuites);\r\n    assertTrue(\"CipherSuites setter is not working correctly\", delegate.getCipherSuites().equals(supportedCipherSuites));\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.tika.DOMBuilder.getRootNode",
	"Comment": "get the root node of the dom being created. this is either a document ora documentfragment.",
	"Method": "Node getRootNode(){\r\n    return (null != m_docFrag) ? (Node) m_docFrag : (Node) m_doc;\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.indexing.AbstractIndexerBolt.fieldNameForText",
	"Comment": "returns the field name to use for the text or null if the text must notbe indexed",
	"Method": "String fieldNameForText(){\r\n    return fieldNameForText;\r\n}"
}, {
	"Path": "org.takes.facets.hamcrest.HmHeaderTest.testsHeaderNameAndValueAvailable",
	"Comment": "hmrqheader can test whether header name and value are available.",
	"Method": "void testsHeaderNameAndValueAvailable(){\r\n    MatcherAssert.assertThat(new RqWithHeader(new RqFake(), \"header1: value1\"), new HmHeader(\"header1\", \"value1\"));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.CertificateVerifyHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class certificateverifyhandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof CertificateVerifyParser);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ServerHelloParser.parseSelectedCiphersuite",
	"Comment": "reads the next bytes as a ciphersuite and writes them in the message",
	"Method": "void parseSelectedCiphersuite(ServerHelloMessage msg){\r\n    msg.setSelectedCipherSuite(parseByteArrayField(HandshakeByteLength.CIPHER_SUITE));\r\n}"
}, {
	"Path": "org.takes.rq.RqLive.checkLineFeed",
	"Comment": "checks whether or not the next byte to read is a line feed.please note that this method assumes that the previous byte readwas a carriage return.",
	"Method": "void checkLineFeed(InputStream input,ByteArrayOutputStream baos,Integer position){\r\n    if (input.read() != '\\n') {\r\n        throw new HttpException(HttpURLConnection.HTTP_BAD_REQUEST, String.format(\"there is no LF after CR in header, line #%d: \\\"%s\\\"\", position, new Utf8String(baos.toByteArray()).string()));\r\n    }\r\n}"
}, {
	"Path": "com.diffplug.spotless.FileSignature.signAsSet",
	"Comment": "creates file signature insensitive to the order of the files.",
	"Method": "FileSignature signAsSet(File files,FileSignature signAsSet,Iterable<File> files){\r\n    return new FileSignature(toSortedSet(files));\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.util.ImageIOHelperTest.testGetImageFileFormat",
	"Comment": "test of getimagefileformat method, of class imageiohelper.",
	"Method": "void testGetImageFileFormat(){\r\n    logger.info(\"getImageFileFormat\");\r\n    File imageFile = new File(TEST_RESOURCES_DATA_PATH, \"eurotext.png\");\r\n    String expResult = \"png\";\r\n    String result = ImageIOHelper.getImageFileFormat(imageFile);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.cert.CertificatePairParser.parseCertificateLength",
	"Comment": "reads the next bytes as the certificatelength of the certificatepair andwrites them in the message",
	"Method": "void parseCertificateLength(CertificatePair pair){\r\n    pair.setCertificateLength(parseIntField(HandshakeByteLength.CERTIFICATE_LENGTH));\r\n    LOGGER.debug(\"CertificateLength: \" + pair.getCertificateLength().getValue());\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.eclipse.base.osgi.ServiceCollection.getReferences",
	"Comment": "get reference matching interface class name or all references",
	"Method": "ServiceReference<?>[] getReferences(String interfaceClassName){\r\n    if (null == interfaceClassName) {\r\n        Collection<ServiceReference<?>> allServices = className2Service.values();\r\n        return allServices.toArray(new ServiceReference<?>[allServices.size()]);\r\n    }\r\n    ServiceReference<?> singleService = className2Service.get(interfaceClassName);\r\n    return (null == singleService) ? null : new ServiceReference<?>[] { singleService };\r\n}"
}, {
	"Path": "com.diffplug.spotless.StepHarness.testResource",
	"Comment": "asserts that the given elements inthe resources directory are transformed as expected.",
	"Method": "StepHarness testResource(String resourceBefore,String resourceAfter){\r\n    String before = ResourceHarness.getTestResource(resourceBefore);\r\n    String after = ResourceHarness.getTestResource(resourceAfter);\r\n    return test(before, after);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.CertificateMessageParser.parseCertificatesListLength",
	"Comment": "reads the next bytes as the certificatelength and writes them in themessage",
	"Method": "void parseCertificatesListLength(CertificateMessage msg){\r\n    msg.setCertificatesListLength(parseIntField(HandshakeByteLength.CERTIFICATES_LENGTH));\r\n    LOGGER.debug(\"CertificatesListLength: \" + msg.getCertificatesListLength());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void connectRenderer(){\r\n    mRenderer.getCurrentScene().registerFrameCallback(new ASceneFrameCallback() {\r\n        @Override\r\n        public void onPreFrame(long sceneTime, double deltaTime) {\r\n            try {\r\n                synchronized (PointToPointActivity.this) {\r\n                    if (!mIsConnected) {\r\n                        return;\r\n                    }\r\n                    if (!mRenderer.isSceneCameraConfigured()) {\r\n                        TangoCameraIntrinsics intrinsics = TangoSupport.getCameraIntrinsicsBasedOnDisplayRotation(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mDisplayRotation);\r\n                        mRenderer.setProjectionMatrix(projectionMatrixFromCameraIntrinsics(intrinsics));\r\n                    }\r\n                    if (mConnectedTextureIdGlThread != mRenderer.getTextureId()) {\r\n                        mTango.connectTextureId(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mRenderer.getTextureId());\r\n                        mConnectedTextureIdGlThread = mRenderer.getTextureId();\r\n                        Log.d(TAG, \"connected to texture id: \" + mRenderer.getTextureId());\r\n                    }\r\n                    if (mIsFrameAvailableTangoThread.compareAndSet(true, false)) {\r\n                        mRgbTimestampGlThread = mTango.updateTexture(TangoCameraIntrinsics.TANGO_CAMERA_COLOR);\r\n                    }\r\n                    if (mRgbTimestampGlThread > mCameraPoseTimestamp) {\r\n                        TangoPoseData lastFramePose = TangoSupport.getPoseAtTime(mRgbTimestampGlThread, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                        if (lastFramePose.statusCode == TangoPoseData.POSE_VALID) {\r\n                            mRenderer.updateRenderCameraPose(lastFramePose);\r\n                            mCameraPoseTimestamp = lastFramePose.timestamp;\r\n                        } else {\r\n                            Log.w(TAG, \"Can't get device pose at time: \" + mRgbTimestampGlThread);\r\n                        }\r\n                        if (mMeasuredPoints[0] != null && mMeasuredPoints[1] != null) {\r\n                            TangoSupport.MatrixTransformData openglTDepthArr0 = TangoSupport.getMatrixTransformAtTime(mMeasuredPoints[0].mTimestamp, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_DEPTH, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_TANGO, TangoSupport.ROTATION_IGNORED);\r\n                            TangoSupport.MatrixTransformData openglTDepthArr1 = TangoSupport.getMatrixTransformAtTime(mMeasuredPoints[1].mTimestamp, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_DEPTH, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_TANGO, TangoSupport.ROTATION_IGNORED);\r\n                            if (openglTDepthArr0.statusCode == TangoPoseData.POSE_VALID && openglTDepthArr1.statusCode == TangoPoseData.POSE_VALID) {\r\n                                mMeasurePoitnsInOpenGLSpace.clear();\r\n                                float[] p0 = TangoTransformHelper.transformPoint(openglTDepthArr0.matrix, mMeasuredPoints[0].mDepthTPoint);\r\n                                float[] p1 = TangoTransformHelper.transformPoint(openglTDepthArr1.matrix, mMeasuredPoints[1].mDepthTPoint);\r\n                                mMeasurePoitnsInOpenGLSpace.push(new Vector3(p0[0], p0[1], p0[2]));\r\n                                mMeasurePoitnsInOpenGLSpace.push(new Vector3(p1[0], p1[1], p1[2]));\r\n                                mMeasuredDistance = (float) Math.sqrt(Math.pow(p0[0] - p1[0], 2) + Math.pow(p0[1] - p1[1], 2) + Math.pow(p0[2] - p1[2], 2));\r\n                            }\r\n                        }\r\n                        mRenderer.setLine(mMeasurePoitnsInOpenGLSpace);\r\n                    }\r\n                }\r\n            } catch (TangoErrorException e) {\r\n                Log.e(TAG, \"Tango API call error within the OpenGL render thread\", e);\r\n            } catch (Throwable t) {\r\n                Log.e(TAG, \"Exception on the OpenGL thread\", t);\r\n            }\r\n        }\r\n        @Override\r\n        public void onPreDraw(long sceneTime, double deltaTime) {\r\n        }\r\n        @Override\r\n        public void onPostFrame(long sceneTime, double deltaTime) {\r\n        }\r\n        @Override\r\n        public boolean callPreFrame() {\r\n            return true;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void connectRenderer(){\r\n    try {\r\n        synchronized (PointToPointActivity.this) {\r\n            if (!mIsConnected) {\r\n                return;\r\n            }\r\n            if (!mRenderer.isSceneCameraConfigured()) {\r\n                TangoCameraIntrinsics intrinsics = TangoSupport.getCameraIntrinsicsBasedOnDisplayRotation(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mDisplayRotation);\r\n                mRenderer.setProjectionMatrix(projectionMatrixFromCameraIntrinsics(intrinsics));\r\n            }\r\n            if (mConnectedTextureIdGlThread != mRenderer.getTextureId()) {\r\n                mTango.connectTextureId(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mRenderer.getTextureId());\r\n                mConnectedTextureIdGlThread = mRenderer.getTextureId();\r\n                Log.d(TAG, \"connected to texture id: \" + mRenderer.getTextureId());\r\n            }\r\n            if (mIsFrameAvailableTangoThread.compareAndSet(true, false)) {\r\n                mRgbTimestampGlThread = mTango.updateTexture(TangoCameraIntrinsics.TANGO_CAMERA_COLOR);\r\n            }\r\n            if (mRgbTimestampGlThread > mCameraPoseTimestamp) {\r\n                TangoPoseData lastFramePose = TangoSupport.getPoseAtTime(mRgbTimestampGlThread, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                if (lastFramePose.statusCode == TangoPoseData.POSE_VALID) {\r\n                    mRenderer.updateRenderCameraPose(lastFramePose);\r\n                    mCameraPoseTimestamp = lastFramePose.timestamp;\r\n                } else {\r\n                    Log.w(TAG, \"Can't get device pose at time: \" + mRgbTimestampGlThread);\r\n                }\r\n                if (mMeasuredPoints[0] != null && mMeasuredPoints[1] != null) {\r\n                    TangoSupport.MatrixTransformData openglTDepthArr0 = TangoSupport.getMatrixTransformAtTime(mMeasuredPoints[0].mTimestamp, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_DEPTH, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_TANGO, TangoSupport.ROTATION_IGNORED);\r\n                    TangoSupport.MatrixTransformData openglTDepthArr1 = TangoSupport.getMatrixTransformAtTime(mMeasuredPoints[1].mTimestamp, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_DEPTH, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_TANGO, TangoSupport.ROTATION_IGNORED);\r\n                    if (openglTDepthArr0.statusCode == TangoPoseData.POSE_VALID && openglTDepthArr1.statusCode == TangoPoseData.POSE_VALID) {\r\n                        mMeasurePoitnsInOpenGLSpace.clear();\r\n                        float[] p0 = TangoTransformHelper.transformPoint(openglTDepthArr0.matrix, mMeasuredPoints[0].mDepthTPoint);\r\n                        float[] p1 = TangoTransformHelper.transformPoint(openglTDepthArr1.matrix, mMeasuredPoints[1].mDepthTPoint);\r\n                        mMeasurePoitnsInOpenGLSpace.push(new Vector3(p0[0], p0[1], p0[2]));\r\n                        mMeasurePoitnsInOpenGLSpace.push(new Vector3(p1[0], p1[1], p1[2]));\r\n                        mMeasuredDistance = (float) Math.sqrt(Math.pow(p0[0] - p1[0], 2) + Math.pow(p0[1] - p1[1], 2) + Math.pow(p0[2] - p1[2], 2));\r\n                    }\r\n                }\r\n                mRenderer.setLine(mMeasurePoitnsInOpenGLSpace);\r\n            }\r\n        }\r\n    } catch (TangoErrorException e) {\r\n        Log.e(TAG, \"Tango API call error within the OpenGL render thread\", e);\r\n    } catch (Throwable t) {\r\n        Log.e(TAG, \"Exception on the OpenGL thread\", t);\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void connectRenderer(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void connectRenderer(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void connectRenderer(){\r\n    return true;\r\n}"
}, {
	"Path": "studio.carbonylgroup.textfieldboxes.TextFieldBoxes.deactivate",
	"Comment": "lower the labeltext labeltext label when there is no text at losing focus",
	"Method": "void deactivate(){\r\n    if (this.editText.getText().toString().isEmpty()) {\r\n        if (this.alwaysShowHint && !this.editText.getHint().toString().isEmpty()) {\r\n            this.editTextLayout.setAlpha(1f);\r\n            this.floatingLabel.setScaleX(0.75f);\r\n            this.floatingLabel.setScaleY(0.75f);\r\n            this.floatingLabel.setTranslationY(-labelTopMargin + getContext().getResources().getDimensionPixelOffset(R.dimen.label_active_margin_top));\r\n        } else {\r\n            this.editTextLayout.setAlpha(0);\r\n            ViewCompat.animate(floatingLabel).alpha(1).scaleX(1).scaleY(1).translationY(0).setDuration(ANIMATION_DURATION);\r\n        }\r\n        if (this.editText.hasFocus()) {\r\n            inputMethodManager.hideSoftInputFromWindow(editText.getWindowToken(), 0);\r\n            this.editText.clearFocus();\r\n        }\r\n    }\r\n    this.activated = false;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.HeartbeatMessageParser.parsePadding",
	"Comment": "reads the next bytes as the padding and writes them in the message",
	"Method": "void parsePadding(HeartbeatMessage msg){\r\n    msg.setPadding(parseByteArrayField(getBytesLeft()));\r\n    LOGGER.debug(\"Padding: \" + ArrayConverter.bytesToHexString(msg.getPadding().getValue()));\r\n}"
}, {
	"Path": "org.takes.facets.fork.FkChainTest.gracefullyHandlesNoForkMatching",
	"Comment": "fkchain can gracefully work when no fork matches the request.",
	"Method": "void gracefullyHandlesNoForkMatching(){\r\n    MatcherAssert.assertThat(new FkChain(new FkRegex(\"/doyoumatch?\", \"Hello. It's me.\"), new FkRegex(\"/plzmatch!\", \"I am your father\")).route(new RqFake(\"POST\", \"/idontmatch\")).has(), Matchers.equalTo(false));\r\n}"
}, {
	"Path": "com.projecttango.examples.java.occlusion.meshing.TangoMesher.setColorCameraCalibration",
	"Comment": "synchronize access to mtango3dreconstruction. this runs in ui thread.",
	"Method": "void setColorCameraCalibration(TangoCameraIntrinsics calibration){\r\n    mTango3dReconstruction.setColorCameraCalibration(calibration);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.augmentedreality.AugmentedRealityActivity.setupTangoConfig",
	"Comment": "sets up the tango configuration object. make sure mtango object is initialized beforemaking this call.",
	"Method": "TangoConfig setupTangoConfig(Tango tango){\r\n    TangoConfig config = tango.getConfig(TangoConfig.CONFIG_TYPE_DEFAULT);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_COLORCAMERA, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_LOWLATENCYIMUINTEGRATION, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_DRIFT_CORRECTION, true);\r\n    return config;\r\n}"
}, {
	"Path": "com.diffplug.spotless.StepHarness.testUnaffected",
	"Comment": "asserts that the given element is idempotent w.r.t the step under test.",
	"Method": "StepHarness testUnaffected(String idempotentElement){\r\n    String actual = formatter.apply(idempotentElement);\r\n    Assert.assertEquals(\"Step is not idempotent\", idempotentElement, actual);\r\n    return this;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ECDHEServerKeyExchangeParserTest.testParse",
	"Comment": "test of parse method, of class ecdheserverkeyexchangeparser.",
	"Method": "void testParse(){\r\n    ECDHEServerKeyExchangeParser<ECDHEServerKeyExchangeMessage> parser = new ECDHEServerKeyExchangeParser(0, message, version);\r\n    ECDHEServerKeyExchangeMessage msg = parser.parse();\r\n    assertArrayEquals(message, msg.getCompleteResultingMessage().getValue());\r\n    assertTrue(length == msg.getLength().getValue());\r\n    assertTrue(type.getValue() == msg.getType().getValue());\r\n    assertTrue(curveType == msg.getGroupType().getValue());\r\n    assertArrayEquals(namedCurve, msg.getNamedGroup().getValue());\r\n    assertTrue(pubKeyLength == msg.getPublicKeyLength().getValue());\r\n    assertArrayEquals(pubKey, msg.getPublicKey().getValue());\r\n    byte[] tempSignatureAndHashAlgo = null;\r\n    if (msg.getSignatureAndHashAlgorithm() != null && msg.getSignatureAndHashAlgorithm().getValue() != null) {\r\n        tempSignatureAndHashAlgo = msg.getSignatureAndHashAlgorithm().getValue();\r\n    }\r\n    assertArrayEquals(signatureAndHashAlgo, tempSignatureAndHashAlgo);\r\n    assertTrue(sigLength == msg.getSignatureLength().getValue());\r\n    assertArrayEquals(signature, msg.getSignature().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.ECDHEServerKeyExchangeSerializerTest.testSerializeHandshakeMessageContent",
	"Comment": "test of serializehandshakemessagecontent method, of classecdheserverkeyexchangeserializer.",
	"Method": "void testSerializeHandshakeMessageContent(){\r\n    ECDHEServerKeyExchangeMessage msg = new ECDHEServerKeyExchangeMessage();\r\n    msg.setCompleteResultingMessage(expectedPart);\r\n    msg.setCurveType(curveType);\r\n    msg.setLength(length);\r\n    msg.setType(type.getValue());\r\n    msg.setNamedGroup(namedGroup);\r\n    msg.setPublicKey(pubKey);\r\n    msg.setPublicKeyLength(pubKeyLength);\r\n    if (signatureAndHashAlgo != null) {\r\n        msg.setSignatureAndHashAlgorithm(signatureAndHashAlgo);\r\n    }\r\n    msg.setPublicKey(pubKey);\r\n    msg.setPublicKeyLength(pubKeyLength);\r\n    msg.setSignatureLength(sigLength);\r\n    msg.setSignature(signature);\r\n    ECDHEServerKeyExchangeSerializer serializer = new ECDHEServerKeyExchangeSerializer(msg, version);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ServerHelloParser.parseSelectedComressionMethod",
	"Comment": "reads the next bytes as a compressionmethod and writes them in themessage",
	"Method": "void parseSelectedComressionMethod(ServerHelloMessage msg){\r\n    msg.setSelectedCompressionMethod(parseByteField(HandshakeByteLength.COMPRESSION));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.EcPointFormatExtensionHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class ecpointformatextensionhandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[] { 123 }, 0) instanceof ECPointFormatExtensionParser);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskDhClientKeyExchangeHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class pskdhclientkeyexchangehandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new PskDhClientKeyExchangeMessage()) instanceof PskDhClientKeyExchangeSerializer);\r\n}"
}, {
	"Path": "org.takes.facets.hamcrest.HmHeaderTest.testsValueNotAvailable",
	"Comment": "hmrqheader can test whether header name is availableand value is not available.",
	"Method": "void testsValueNotAvailable(){\r\n    MatcherAssert.assertThat(new RqWithHeader(new RqFake(), \"header2: value2\"), Matchers.not(new HmHeader(\"header2\", \"value21\")));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.HelloMessageParser.parseSessionIDLength",
	"Comment": "reads the next bytes as the sessionid length and writes them in themessage",
	"Method": "void parseSessionIDLength(HelloMessage message){\r\n    message.setSessionIdLength(parseIntField(HandshakeByteLength.SESSION_ID_LENGTH));\r\n    LOGGER.debug(\"SessionIDLength:\" + message.getSessionIdLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.MaxFragmentLengthDelegateTest.testGetMaxFragmentLength",
	"Comment": "test of getmaxfragmentlength method, of class maxfragmentlengthdelegate.",
	"Method": "void testGetMaxFragmentLength(){\r\n    args = new String[2];\r\n    args[0] = \"-max_fragment_length\";\r\n    args[1] = \"4\";\r\n    assertTrue(delegate.getMaxFragmentLength() == null);\r\n    jcommander.parse(args);\r\n    assertTrue(delegate.getMaxFragmentLength() == 4);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.CertificateVerifyHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class certificateverifyhandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new CertificateVerifyMessage()) instanceof CertificateVerifyPreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskEcDheServerKeyExchangeHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class pskecdheserverkeyexchangehandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new PskEcDheServerKeyExchangeMessage()) instanceof PskEcDheServerKeyExchangeSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ServerHelloDoneHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class serverhellodonehandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new ServerHelloDoneMessage()) instanceof ServerHelloDoneSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ECDHClientKeyExchangeParser.parseSerializedPublicKey",
	"Comment": "reads the next bytes as the serializedpublickey and writes them in themessage",
	"Method": "void parseSerializedPublicKey(ECDHClientKeyExchangeMessage msg){\r\n    msg.setPublicKey(parseByteArrayField(msg.getPublicKeyLength().getValue()));\r\n    LOGGER.debug(\"SerializedPublicKey: \" + ArrayConverter.bytesToHexString(msg.getPublicKey().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeCipherSuiteActionTest.testSetNewValue",
	"Comment": "test of setnewvalue method, of class changeciphersuiteaction.",
	"Method": "void testSetNewValue(){\r\n    assertEquals(action.getNewValue(), CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA256);\r\n    action.setNewValue(CipherSuite.TLS_FALLBACK_SCSV);\r\n    assertEquals(action.getNewValue(), CipherSuite.TLS_FALLBACK_SCSV);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.WorkflowTraceNormalizerTestGoodInput.loadTestVector",
	"Comment": "loads a test vector from file. have a look at the test vectors to see therequired format.",
	"Method": "void loadTestVector(File testVectorPath){\r\n    String testData;\r\n    try {\r\n        testData = inputStreamToString(new FileInputStream(testVectorPath));\r\n    } catch (IOException ex) {\r\n        LOGGER.error(\"Could not load test file \" + testVectorPath + \": \" + ex);\r\n        return;\r\n    }\r\n    String[] testDataSplit = testData.split(\"(?m)#.*$\");\r\n    configXml = testDataSplit[1].trim();\r\n    traceInputXml = testDataSplit[2].trim();\r\n    if (testDataSplit.length > 3) {\r\n        expectedNormalizedXml = testDataSplit[3].trim();\r\n        expectedFilteredXml = testDataSplit[4].trim();\r\n    }\r\n    try {\r\n        config = Config.createConfig(new ByteArrayInputStream(configXml.getBytes(StandardCharsets.UTF_8.name())));\r\n    } catch (UnsupportedEncodingException ex) {\r\n        LOGGER.error(\"Could not load config from test file \" + testVectorPath + \": \" + ex);\r\n        return;\r\n    }\r\n    try {\r\n        trace = WorkflowTraceSerializer.read(new ByteArrayInputStream(traceInputXml.getBytes(StandardCharsets.UTF_8.name())));\r\n    } catch (JAXBException | IOException | XMLStreamException | DataBindingException ex) {\r\n        LOGGER.error(\"Could not load workflow trace from test file \" + testVectorPath + \": \" + ex);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetClientSupportedPointFormats",
	"Comment": "test of getclientsupportedpointformats method, of class defaultchooser.",
	"Method": "void testGetClientSupportedPointFormats(){\r\n    List<ECPointFormat> formatList = new LinkedList();\r\n    formatList.add(ECPointFormat.UNCOMPRESSED);\r\n    formatList.add(ECPointFormat.UNCOMPRESSED);\r\n    formatList.add(ECPointFormat.UNCOMPRESSED);\r\n    formatList.add(ECPointFormat.UNCOMPRESSED);\r\n    formatList.add(ECPointFormat.UNCOMPRESSED);\r\n    formatList.add(ECPointFormat.UNCOMPRESSED);\r\n    formatList.add(ECPointFormat.UNCOMPRESSED);\r\n    formatList.add(ECPointFormat.UNCOMPRESSED);\r\n    config.setDefaultClientSupportedPointFormats(formatList);\r\n    assertTrue(config.getDefaultClientSupportedPointFormats().size() == 8);\r\n    assertTrue(chooser.getClientSupportedPointFormats().size() == 8);\r\n    context.setClientPointFormatsList(new LinkedList<ECPointFormat>());\r\n    assertTrue(chooser.getClientSupportedPointFormats().isEmpty());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.CiphersuiteDelegateTest.testApplyDelegate",
	"Comment": "test of applydelegate method, of class ciphersuitedelegate.",
	"Method": "void testApplyDelegate(){\r\n    args = new String[2];\r\n    args[0] = \"-cipher\";\r\n    args[1] = \"TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA\";\r\n    jcommander.parse(args);\r\n    assertTrue(\"TLS_RSA_WITH_AES_128_CBC_SHA should get parsed correctly\", delegate.getCipherSuites().contains(CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA));\r\n    assertTrue(\"TLS_RSA_WITH_AES_256_CBC_SHA should get parsed correctly\", delegate.getCipherSuites().contains(CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA));\r\n    Config config = Config.createConfig();\r\n    config.setDefaultSelectedCipherSuite(CipherSuite.TLS_AES_128_GCM_SHA256);\r\n    config.setDefaultClientSupportedCiphersuites(new CipherSuite[0]);\r\n    delegate.applyDelegate(config);\r\n    assertTrue(\"TLS_RSA_WITH_AES_128_CBC_SHA should get parsed correctly\", config.getDefaultClientSupportedCiphersuites().contains(CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA));\r\n    assertTrue(\"TLS_RSA_WITH_AES_256_CBC_SHA should get parsed correctly\", config.getDefaultClientSupportedCiphersuites().contains(CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA));\r\n    assertEquals(CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA, config.getDefaultSelectedCipherSuite());\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.eclipse.wtp.EclipseXmlFormatterStepImpl.format",
	"Comment": "formatting xml string resolving uris according its base location",
	"Method": "String format(String raw,String baseLocation){\r\n    IStructuredDocument document = new BasicStructuredDocument(new XMLSourceParser());\r\n    document.setPreferredLineDelimiter(LINE_DELIMITER);\r\n    IDocumentPartitioner partitioner = new StructuredTextPartitionerForXML();\r\n    document.setDocumentPartitioner(new StructuredTextPartitionerForXML());\r\n    partitioner.connect(document);\r\n    document.set(raw);\r\n    DOMModelImpl xmlDOM = new DOMModelImpl();\r\n    xmlDOM.setBaseLocation(baseLocation);\r\n    xmlDOM.getFactoryRegistry().addFactory(xmlAdapterFactory);\r\n    xmlDOM.setStructuredDocument(document);\r\n    ModelQuery modelQuery = ModelQueryUtil.getModelQuery(xmlDOM);\r\n    modelQuery.getCMDocumentManager().setPropertyEnabled(CMDocumentManager.PROPERTY_USE_CACHED_RESOLVED_URI, true);\r\n    TextEdit formatterChanges = formatter.format(xmlDOM, 0, document.getLength(), preferences);\r\n    formatterChanges.apply(document);\r\n    return document.get();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.openglar.OpenGlAugmentedRealityActivity.setDisplayRotation",
	"Comment": "set the color camera background texture rotation and save the camera to display rotation.",
	"Method": "void setDisplayRotation(){\r\n    Display display = getWindowManager().getDefaultDisplay();\r\n    mDisplayRotation = display.getRotation();\r\n    mSurfaceView.queueEvent(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            if (mIsConnected) {\r\n                mRenderer.updateColorCameraTextureUv(mDisplayRotation);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.openglar.OpenGlAugmentedRealityActivity.setDisplayRotation",
	"Comment": "set the color camera background texture rotation and save the camera to display rotation.",
	"Method": "void setDisplayRotation(){\r\n    if (mIsConnected) {\r\n        mRenderer.updateColorCameraTextureUv(mDisplayRotation);\r\n    }\r\n}"
}, {
	"Path": "com.novoda.spikes.arcore.google.rendering.TextureReader.create",
	"Comment": "creates the texture reader. this function needs to be called from the opengl rendering thread.",
	"Method": "void create(Context context,int format,int width,int height,Boolean keepAspectRatio){\r\n    if (format != TextureReaderImage.IMAGE_FORMAT_RGBA && format != TextureReaderImage.IMAGE_FORMAT_I8) {\r\n        throw new RuntimeException(\"Image format not supported.\");\r\n    }\r\n    this.keepAspectRatio = keepAspectRatio;\r\n    imageFormat = format;\r\n    imageWidth = width;\r\n    imageHeight = height;\r\n    frontIndex = -1;\r\n    backIndex = -1;\r\n    if (imageFormat == TextureReaderImage.IMAGE_FORMAT_RGBA) {\r\n        pixelBufferSize = imageWidth * imageHeight * 4;\r\n    } else if (imageFormat == TextureReaderImage.IMAGE_FORMAT_I8) {\r\n        pixelBufferSize = imageWidth * imageHeight;\r\n    }\r\n    pbo = new int[bufferCount];\r\n    frameBuffer = new int[bufferCount];\r\n    texture = new int[bufferCount];\r\n    bufferUsed = new Boolean[bufferCount];\r\n    GLES30.glGenBuffers(bufferCount, pbo, 0);\r\n    GLES20.glGenFramebuffers(bufferCount, frameBuffer, 0);\r\n    GLES20.glGenTextures(bufferCount, texture, 0);\r\n    for (int i = 0; i < bufferCount; i++) {\r\n        bufferUsed[i] = false;\r\n        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, frameBuffer[i]);\r\n        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texture[i]);\r\n        GLES30.glTexImage2D(GLES30.GL_TEXTURE_2D, 0, imageFormat == TextureReaderImage.IMAGE_FORMAT_I8 ? GLES30.GL_R8 : GLES30.GL_RGBA, imageWidth, imageHeight, 0, imageFormat == TextureReaderImage.IMAGE_FORMAT_I8 ? GLES30.GL_RED : GLES30.GL_RGBA, GLES30.GL_UNSIGNED_BYTE, null);\r\n        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);\r\n        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);\r\n        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);\r\n        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);\r\n        GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0, GLES20.GL_TEXTURE_2D, texture[i], 0);\r\n        int status = GLES20.glCheckFramebufferStatus(GLES20.GL_FRAMEBUFFER);\r\n        if (status != GLES20.GL_FRAMEBUFFER_COMPLETE) {\r\n            throw new RuntimeException(this + \": Failed to set up render buffer with status \" + status + \" and error \" + GLES20.glGetError());\r\n        }\r\n        GLES30.glBindBuffer(GLES30.GL_PIXEL_PACK_BUFFER, pbo[i]);\r\n        GLES30.glBufferData(GLES30.GL_PIXEL_PACK_BUFFER, pixelBufferSize, null, GLES30.GL_DYNAMIC_READ);\r\n        GLES30.glBindBuffer(GLES30.GL_PIXEL_PACK_BUFFER, 0);\r\n    }\r\n    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);\r\n    int numVertices = 4;\r\n    if (numVertices != QUAD_COORDS.length / COORDS_PER_VERTEX) {\r\n        throw new RuntimeException(\"Unexpected number of vertices in BackgroundRenderer.\");\r\n    }\r\n    ByteBuffer bbVertices = ByteBuffer.allocateDirect(QUAD_COORDS.length * FLOAT_SIZE);\r\n    bbVertices.order(ByteOrder.nativeOrder());\r\n    quadVertices = bbVertices.asFloatBuffer();\r\n    quadVertices.put(QUAD_COORDS);\r\n    quadVertices.position(0);\r\n    ByteBuffer bbTexCoords = ByteBuffer.allocateDirect(numVertices * TEXCOORDS_PER_VERTEX * FLOAT_SIZE);\r\n    bbTexCoords.order(ByteOrder.nativeOrder());\r\n    quadTexCoord = bbTexCoords.asFloatBuffer();\r\n    quadTexCoord.put(QUAD_TEXCOORDS);\r\n    quadTexCoord.position(0);\r\n    int vertexShader = ShaderUtil.loadGLShader(TAG, context, GLES20.GL_VERTEX_SHADER, \"shaders/gpu_download.vert\");\r\n    int fragmentShader = ShaderUtil.loadGLShader(TAG, context, GLES20.GL_FRAGMENT_SHADER, imageFormat == TextureReaderImage.IMAGE_FORMAT_I8 ? \"shaders/gpu_download_i8.frag\" : \"shaders/gpu_download_rgba.frag\");\r\n    quadProgram = GLES20.glCreateProgram();\r\n    GLES20.glAttachShader(quadProgram, vertexShader);\r\n    GLES20.glAttachShader(quadProgram, fragmentShader);\r\n    GLES20.glLinkProgram(quadProgram);\r\n    GLES20.glUseProgram(quadProgram);\r\n    quadPositionAttrib = GLES20.glGetAttribLocation(quadProgram, \"a_Position\");\r\n    quadTexCoordAttrib = GLES20.glGetAttribLocation(quadProgram, \"a_TexCoord\");\r\n    int texLoc = GLES20.glGetUniformLocation(quadProgram, \"sTexture\");\r\n    GLES20.glUniform1i(texLoc, 0);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.HelloMessageParser.parseSessionID",
	"Comment": "reads the next bytes as the sessionid and writes them in the message",
	"Method": "void parseSessionID(HelloMessage message){\r\n    message.setSessionId(parseByteArrayField(message.getSessionIdLength().getOriginalValue()));\r\n    LOGGER.debug(\"SessionID:\" + ArrayConverter.bytesToHexString(message.getSessionId().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.CertificateVerifyHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class certificateverifyhandler.",
	"Method": "void testAdjustTLSContext(){\r\n    CertificateVerifyMessage message = new CertificateVerifyMessage();\r\n    handler.adjustTLSContext(message);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.greenscreen.GreenScreenActivity.onRequestPermissionsResult",
	"Comment": "result for requesting camera and write external storage permissions.",
	"Method": "void onRequestPermissionsResult(int requestCode,String[] permissions,int[] grantResults){\r\n    if (hasPermissions()) {\r\n        bindTangoService();\r\n    } else {\r\n        Toast.makeText(this, \"Java Green Screen Example requires camera and write \" + \"external storage permissions\", Toast.LENGTH_LONG).show();\r\n    }\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.util.GeomBuilder.lineString",
	"Comment": "creates a linestring from all points on the coordinate stack, and places the resulton the geometry stack.",
	"Method": "GeomBuilder lineString(){\r\n    gstack.push(factory.createLineString(cpopAll()));\r\n    return this;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.openglar.OpenGlAugmentedRealityActivity.setupTangoConfig",
	"Comment": "sets up the tango configuration object. make sure mtango object is initialized beforemaking this call.",
	"Method": "TangoConfig setupTangoConfig(Tango tango){\r\n    TangoConfig config = tango.getConfig(TangoConfig.CONFIG_TYPE_DEFAULT);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_COLORCAMERA, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_LOWLATENCYIMUINTEGRATION, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_DRIFT_CORRECTION, true);\r\n    return config;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.state.ContextContainer.getTlsContext",
	"Comment": "get the only defined tls context.convenience method, useful when working with a single context only.",
	"Method": "TlsContext getTlsContext(TlsContext getTlsContext,String alias){\r\n    TlsContext ctx = tlsContexts.get(alias);\r\n    if (ctx == null) {\r\n        throw new ConfigurationException(\"No context defined with alias '\" + alias + \"'.\");\r\n    }\r\n    return ctx;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetTalkingConnectionEnd",
	"Comment": "test of gettalkingconnectionend method, of class defaultchooser.",
	"Method": "void testGetTalkingConnectionEnd(){\r\n    context.setTalkingConnectionEndType(ConnectionEndType.CLIENT);\r\n    assertEquals(ConnectionEndType.CLIENT, chooser.getTalkingConnectionEnd());\r\n    context.setTalkingConnectionEndType(ConnectionEndType.SERVER);\r\n    assertEquals(ConnectionEndType.SERVER, chooser.getTalkingConnectionEnd());\r\n    context.setTalkingConnectionEndType(null);\r\n    assertEquals(null, chooser.getTalkingConnectionEnd());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.state.State.replaceTlsContext",
	"Comment": "replace existing tlscontext with new tlscontext. this can only be done ifexistingtlscontext.connection equals newtlscontext.connection.",
	"Method": "void replaceTlsContext(TlsContext newTlsContext){\r\n    contextContainer.replaceTlsContext(newTlsContext);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.CertificateMessageHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class certificatemessagehandler.",
	"Method": "void testAdjustTLSContext(){\r\n    for (ProtocolVersion version : new ProtocolVersion[] { ProtocolVersion.TLS12 }) {\r\n        context.setTalkingConnectionEndType(ConnectionEndType.CLIENT);\r\n        context.setSelectedProtocolVersion(version);\r\n        CertificateMessage message = new CertificateMessage();\r\n        message.setCertificatesListBytes(ArrayConverter.hexStringToByteArray(\"00023a30820236308201dba0030201020209008812dc4bf7943e2b300a06082a8648ce3d0403023077310b3009060355040613024445310c300a06035504080c034e5257310f300d06035504070c06426f6368756d312f302d060355040a0c263c7363726970743e616c6572742827544c532d41747461636b657227293c2f7363726970743e3118301606035504030c0f746c732d61747461636b65722e6465301e170d3137303232323132353032385a170d3138303232323132353032385a3077310b3009060355040613024445310c300a06035504080c034e5257310f300d06035504070c06426f6368756d312f302d060355040a0c263c7363726970743e616c6572742827544c532d41747461636b657227293c2f7363726970743e3118301606035504030c0f746c732d61747461636b65722e64653059301306072a8648ce3d020106082a8648ce3d03010703420004fbca33b6018a6b244aea13a5332b505daa865026a565f7c7dc3aed6d8b8193248abb4000cf4a1c2c29d94ce1072454ea0a990cd97c863b931f266cc3addad922a350304e301d0603551d0e041604141e9b408ab6236764f8a1d26ed696f009d7b18904301f0603551d230418301680141e9b408ab6236764f8a1d26ed696f009d7b18904300c0603551d13040530030101ff300a06082a8648ce3d0403020349003046022100c9c06d798bbdf6809a3c9523bb979a64a0565fb1759182d6f6bcf6849cd70c7d022100b8e695c1915f71a348600ca90d48dfead7ea5c97b116b05c270af595c94bfa8d\"));\r\n        message.setCertificatesListLength(573);\r\n        handler.adjustTLSContext(message);\r\n        assertNotNull(context.getClientCertificate());\r\n        assertNull(context.getServerCertificate());\r\n        context = new TlsContext();\r\n        context.setTalkingConnectionEndType(ConnectionEndType.SERVER);\r\n        context.setSelectedProtocolVersion(version);\r\n        handler = new CertificateMessageHandler(context);\r\n        handler.adjustTLSContext(message);\r\n        assertNull(context.getClientCertificate());\r\n        assertNotNull(context.getServerCertificate());\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ServerHelloHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class serverhellohandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new ServerHelloMessage()) instanceof ServerHelloSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.factory.WorkflowConfigurationFactoryTest.testCreateFullWorkflow",
	"Comment": "test of createfullworkflow method, of class workflowconfigurationfactory.",
	"Method": "void testCreateFullWorkflow(){\r\n    MessageAction messageAction3;\r\n    MessageAction messageAction4;\r\n    MessageAction messageAction5;\r\n    config.setHighestProtocolVersion(ProtocolVersion.TLS13);\r\n    config.setClientAuthentication(true);\r\n    config.setServerSendsApplicationData(false);\r\n    config.setAddHeartbeatExtension(false);\r\n    workflowConfigurationFactory = new WorkflowConfigurationFactory(config);\r\n    WorkflowTrace fullWorkflow = workflowConfigurationFactory.createWorkflowTrace(WorkflowTraceType.FULL, RunningModeType.CLIENT);\r\n    Assert.assertThat(fullWorkflow.getMessageActions().size(), Matchers.greaterThanOrEqualTo(4));\r\n    messageAction3 = fullWorkflow.getMessageActions().get(3);\r\n    Assert.assertEquals(ApplicationMessage.class, messageAction3.getMessages().get(0).getClass());\r\n    config.setServerSendsApplicationData(true);\r\n    config.setAddHeartbeatExtension(true);\r\n    workflowConfigurationFactory = new WorkflowConfigurationFactory(config);\r\n    fullWorkflow = workflowConfigurationFactory.createWorkflowTrace(WorkflowTraceType.FULL, RunningModeType.CLIENT);\r\n    Assert.assertThat(fullWorkflow.getMessageActions().size(), Matchers.greaterThanOrEqualTo(6));\r\n    messageAction3 = fullWorkflow.getMessageActions().get(3);\r\n    messageAction4 = fullWorkflow.getMessageActions().get(4);\r\n    messageAction5 = fullWorkflow.getMessageActions().get(5);\r\n    Assert.assertEquals(ReceiveAction.class, messageAction3.getClass());\r\n    Assert.assertEquals(ApplicationMessage.class, ((ReceiveAction) messageAction3).getExpectedMessages().get(0).getClass());\r\n    Assert.assertEquals(ApplicationMessage.class, messageAction4.getMessages().get(0).getClass());\r\n    Assert.assertEquals(HeartbeatMessage.class, messageAction4.getMessages().get(1).getClass());\r\n    Assert.assertEquals(ReceiveAction.class, messageAction5.getClass());\r\n    Assert.assertEquals(HeartbeatMessage.class, ((ReceiveAction) messageAction5).getExpectedMessages().get(0).getClass());\r\n}"
}, {
	"Path": "org.springframework.statemachine.state.AbstractState.scheduleStateActions",
	"Comment": "schedule state actions and store futures into list to\tbe cancelled.",
	"Method": "void scheduleStateActions(StateContext<S, E> context){\r\n    AtomicInteger completionCount = null;\r\n    if (isSimple()) {\r\n        completionCount = new AtomicInteger(stateActions.size());\r\n    }\r\n    for (Action<S, E> action : stateActions) {\r\n        ScheduledFuture<?> future = scheduleAction(action, context, completionCount);\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Scheduling state do action \" + action + \" with future \" + future);\r\n        }\r\n        if (future != null) {\r\n            scheduledActions.add(new ScheduledAction(future, resolveDoActionTimeout(context)));\r\n        }\r\n    }\r\n    if (isSimple() && stateActions.size() == 0) {\r\n        notifyStateOnComplete(context);\r\n    }\r\n}"
}, {
	"Path": "com.diffplug.spotless.MoreIterables.toNullHostileList",
	"Comment": "returns a shallow copy of input elements, throwing on null elements.",
	"Method": "List<T> toNullHostileList(Iterable<T> input){\r\n    requireElementsNonNull(input);\r\n    List<T> shallowCopy = (input instanceof Collection) ? new ArrayList(((Collection<?>) input).size()) : new ArrayList();\r\n    input.forEach(shallowCopy::add);\r\n    return shallowCopy;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ServerHelloParser.parseSessionIdHit",
	"Comment": "reads the next bytes as the sessionidhit and writes them in the message",
	"Method": "void parseSessionIdHit(SSL2ServerHelloMessage message){\r\n    message.setSessionIdHit(parseByteField(SSL2ByteLength.SESSION_ID_HIT));\r\n    LOGGER.debug(\"SessionIdHit: \" + message.getSessionIdHit().getValue());\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.protocol.HttpRobotRulesParser.getCacheKey",
	"Comment": "compose unique key to store and access robot rules in cache for given url",
	"Method": "String getCacheKey(URL url){\r\n    String protocol = url.getProtocol().toLowerCase(Locale.ROOT);\r\n    String host = url.getHost().toLowerCase(Locale.ROOT);\r\n    int port = url.getPort();\r\n    if (port == -1) {\r\n        port = url.getDefaultPort();\r\n    }\r\n    return protocol + \":\" + host + \":\" + port;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.hasCameraPermission",
	"Comment": "check to see that we have the necessary permissions for this app.",
	"Method": "boolean hasCameraPermission(){\r\n    return ContextCompat.checkSelfPermission(this, CAMERA_PERMISSION) == PackageManager.PERMISSION_GRANTED;\r\n}"
}, {
	"Path": "org.springframework.statemachine.config.AbstractStateMachineFactory.setContextEventsEnabled",
	"Comment": "instructs this factory to enable application context events.",
	"Method": "void setContextEventsEnabled(Boolean contextEvents){\r\n    this.contextEvents = contextEvents;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.transport.stream.StreamTransportHandlerTest.testGetInputStream",
	"Comment": "test of getinputstream method, of class streamtransporthandler.",
	"Method": "void testGetInputStream(){\r\n    assertNotNull(handler.getInputStream());\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPI1Test.testTessBaseAPIGetHOCRText",
	"Comment": "test of tessbaseapigethocrtext method, of class tessapi1.",
	"Method": "void testTessBaseAPIGetHOCRText(){\r\n    logger.info(\"TessBaseAPIGetHOCRText\");\r\n    File tiff = new File(this.testResourcesDataPath, \"eurotext.tif\");\r\n    BufferedImage image = ImageIO.read(new FileInputStream(tiff));\r\n    ByteBuffer buf = ImageIOHelper.convertImageData(image);\r\n    int bpp = image.getColorModel().getPixelSize();\r\n    int bytespp = bpp / 8;\r\n    int bytespl = (int) Math.ceil(image.getWidth() * bpp / 8.0);\r\n    TessAPI1.TessBaseAPISetPageSegMode(handle, TessPageSegMode.PSM_AUTO);\r\n    TessAPI1.TessBaseAPIInit3(handle, datapath, language);\r\n    TessAPI1.TessBaseAPISetImage(handle, buf, image.getWidth(), image.getHeight(), bytespp, bytespl);\r\n    int page_number = 0;\r\n    Pointer utf8Text = TessAPI1.TessBaseAPIGetHOCRText(handle, page_number);\r\n    String result = utf8Text.getString(0);\r\n    TessAPI1.TessDeleteText(utf8Text);\r\n    assertTrue(result.contains(\"<div class='ocr_page'\"));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.CertificateRequestParser.parseClientCertificateTypes",
	"Comment": "reads the next bytes as the clientcertificatetypes and writes them in themessage",
	"Method": "void parseClientCertificateTypes(CertificateRequestMessage msg){\r\n    msg.setClientCertificateTypes(parseByteArrayField(msg.getClientCertificateTypesCount().getValue()));\r\n    LOGGER.debug(\"ClientCertificateTypes: \" + Arrays.toString(msg.getClientCertificateTypes().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.PskServerKeyExchangeParser.parsePskIdentityHint",
	"Comment": "reads the next bytes as the pskidentityhint and writes them in themessage",
	"Method": "void parsePskIdentityHint(PskServerKeyExchangeMessage msg){\r\n    msg.setIdentityHint(parseByteArrayField(msg.getIdentityHintLength().getValue()));\r\n    LOGGER.debug(\"SerializedPSK-Identity: \" + ArrayConverter.bytesToHexString(msg.getIdentityHint().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.UnknownHandshakeHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class unknownhandshakehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new UnknownHandshakeMessage()) instanceof UnknownHandshakePreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.util.KeyStoreGeneratorTest.testCreateKeyStore",
	"Comment": "test of createkeystore method, of class keystoregenerator.",
	"Method": "void testCreateKeyStore(){\r\n    KeyPair k = KeyStoreGenerator.createRSAKeyPair(1024, random);\r\n    KeyStore ks = KeyStoreGenerator.createKeyStore(k, random);\r\n    assertNotNull(ks);\r\n    k = KeyStoreGenerator.createECKeyPair(256, random);\r\n    ks = KeyStoreGenerator.createKeyStore(k, random);\r\n    assertNotNull(ks);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.attacks.pkcs1.oracles.TestPkcs1Oracle.hasCorrectKeySize",
	"Comment": "checks, if 0x00 is defined on a good position and if before this 0x00byte is no other 0x00",
	"Method": "boolean hasCorrectKeySize(int keySize,byte[] msg){\r\n    boolean result = false;\r\n    if (msg[msg.length - keySize - 1] == 0x00) {\r\n        if (!containsByte((byte) 0x00, msg, 10, msg.length - keySize - 1)) {\r\n            result = true;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.HandshakeMessageParser.parseExtensionLength",
	"Comment": "reads the next bytes as the extensionlength and writes them in themessage",
	"Method": "void parseExtensionLength(T message){\r\n    message.setExtensionsLength(parseIntField(HandshakeByteLength.EXTENSION_LENGTH));\r\n    LOGGER.debug(\"ExtensionLength:\" + message.getExtensionsLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ECDHClientKeyExchangeHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class ecdhclientkeyexchangehandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof ECDHClientKeyExchangeParser);\r\n}"
}, {
	"Path": "org.takes.facets.auth.PsBasicDefaultTest.supportsUsersWithSpacesInTheirNames",
	"Comment": "psbasic.default can be entered by a user with a space in his name.",
	"Method": "void supportsUsersWithSpacesInTheirNames(){\r\n    MatcherAssert.assertThat(new PsBasic.Default(new String[] { \"abraham+lincoln qwer urn:foo:z\" }).enter(\"abraham lincoln\", \"qwer\").has(), Matchers.is(true));\r\n}"
}, {
	"Path": "org.togglz.core.repository.FeatureState.copyOf",
	"Comment": "returns a copy of a featurestate, or null if the featurestate isnull.",
	"Method": "FeatureState copyOf(FeatureState featureState){\r\n    return featureState == null ? null : featureState.copy();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.TangoMesher.setDepthCameraCalibration",
	"Comment": "synchronize access to mtango3dreconstruction. this runs in ui thread.",
	"Method": "void setDepthCameraCalibration(TangoCameraIntrinsics calibration){\r\n    mTango3dReconstruction.setDepthCameraCalibration(calibration);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.HelloVerifyRequestHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class helloverifyrequesthandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new HelloVerifyRequestMessage()) instanceof HelloVerifyRequestSerializer);\r\n}"
}, {
	"Path": "org.springframework.data.neo4j.examples.restaurants.RestaurantTests.shouldFindByNameNotLike",
	"Comment": "all findbypropertylike does currently is to require an exact match, ignoring case.",
	"Method": "void shouldFindByNameNotLike(){\r\n    Restaurant restaurant = new Restaurant(\"San Francisco International Airport (SFO)\", 68.0);\r\n    restaurantRepository.save(restaurant);\r\n    Restaurant kuroda = new Restaurant(\"Kuroda\", 72.4);\r\n    restaurantRepository.save(kuroda);\r\n    List<Restaurant> results = restaurantRepository.findByNameNotLike(\"kuroda\");\r\n    assertNotNull(results);\r\n    assertEquals(1, results.size());\r\n    assertEquals(\"San Francisco International Airport (SFO)\", results.get(0).getName());\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.delegatesRemoveAll",
	"Comment": "verboselist should delegate removeall method to decorated list.",
	"Method": "void delegatesRemoveAll(){\r\n    final List<Object> collection = Collections.emptyList();\r\n    this.list.removeAll(collection);\r\n    Mockito.verify(this.origin).removeAll(collection);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.SupportedVersionsExtensionHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of classsupportedversionsextensionhandler.",
	"Method": "void testAdjustTLSContext(){\r\n    SupportedVersionsExtensionMessage msg = new SupportedVersionsExtensionMessage();\r\n    msg.setSupportedVersions(ArrayConverter.concatenate(ProtocolVersion.TLS12.getValue(), ProtocolVersion.TLS13.getValue()));\r\n    handler.adjustTLSContext(msg);\r\n    assertTrue(context.getClientSupportedProtocolVersions().size() == 2);\r\n    assertEquals(context.getHighestClientProtocolVersion().getValue(), ProtocolVersion.TLS13.getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ApplicationMessageHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class applicationmessagehandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof ApplicationMessageParser);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.ApplicationMessageSerializerTest.testSerializeProtocolMessageContent",
	"Comment": "test of serializeprotocolmessagecontent method, of classapplicationmessageserializer.",
	"Method": "void testSerializeProtocolMessageContent(){\r\n    ApplicationMessage message = new ApplicationMessage();\r\n    message.setData(data);\r\n    message.setCompleteResultingMessage(expectedPart);\r\n    ApplicationMessageSerializer serializer = new ApplicationMessageSerializer(message, ProtocolVersion.TLS12);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetServerSupportedPointFormats",
	"Comment": "test of getserversupportedpointformats method, of class defaultchooser.",
	"Method": "void testGetServerSupportedPointFormats(){\r\n    List<ECPointFormat> formatList = new LinkedList();\r\n    formatList.add(ECPointFormat.UNCOMPRESSED);\r\n    formatList.add(ECPointFormat.UNCOMPRESSED);\r\n    formatList.add(ECPointFormat.UNCOMPRESSED);\r\n    formatList.add(ECPointFormat.UNCOMPRESSED);\r\n    formatList.add(ECPointFormat.UNCOMPRESSED);\r\n    formatList.add(ECPointFormat.UNCOMPRESSED);\r\n    formatList.add(ECPointFormat.UNCOMPRESSED);\r\n    formatList.add(ECPointFormat.UNCOMPRESSED);\r\n    config.setDefaultServerSupportedPointFormats(formatList);\r\n    assertTrue(config.getDefaultServerSupportedPointFormats().size() == 8);\r\n    assertTrue(chooser.getServerSupportedPointFormats().size() == 8);\r\n    context.setServerPointFormatsList(new LinkedList<ECPointFormat>());\r\n    assertTrue(chooser.getServerSupportedPointFormats().isEmpty());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.util.CertificateUtils.parsePublicKey",
	"Comment": "parses the leaf certificate publickey from the certificatestructure",
	"Method": "PublicKey parsePublicKey(Certificate cert){\r\n    try {\r\n        X509Certificate x509Cert = X509Certificate.getInstance(cert.getCertificateAt(0).getEncoded());\r\n        PublicKey key = x509Cert.getPublicKey();\r\n        if (key instanceof RSAPublicKey || key instanceof ECPublicKey || key instanceof DSAPublicKey) {\r\n            return key;\r\n        } else {\r\n            ASN1InputStream stream = new ASN1InputStream(cert.getCertificateAt(0).getSubjectPublicKeyInfo().toASN1Primitive().getEncoded());\r\n            DLSequence sequence = (DLSequence) stream.readObject();\r\n            DLSequence objectAt = (DLSequence) sequence.getObjectAt(0).toASN1Primitive();\r\n            DLSequence dhparams = (DLSequence) objectAt.getObjectAt(1);\r\n            ASN1Integer asnModulus = (ASN1Integer) dhparams.getObjectAt(0);\r\n            ASN1Integer asnGenerator = (ASN1Integer) dhparams.getObjectAt(1);\r\n            BigInteger publicKey = new BigInteger(1, x509Cert.getPublicKey().getEncoded());\r\n            return new CustomDhPublicKey(asnModulus.getPositiveValue(), asnGenerator.getPositiveValue(), publicKey);\r\n        }\r\n    } catch (IOException | CertificateException | IllegalArgumentException | ClassCastException ex) {\r\n        LOGGER.warn(\"Could not extract public key from Certificate!\");\r\n        LOGGER.debug(ex);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.cert.CertificatePairParser.parseCertificate",
	"Comment": "reads the next bytes as the certificate of the certificatepair and writesthem in the message",
	"Method": "void parseCertificate(CertificatePair pair){\r\n    pair.setCertificate(parseByteArrayField(pair.getCertificateLength().getValue()));\r\n    LOGGER.debug(\"Certificate: \" + ArrayConverter.bytesToHexString(pair.getCertificate().getValue()));\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.TangoFloorplanner.resetFloorplan",
	"Comment": "synchronize access to mtango3dreconstruction. this runs in ui thread.",
	"Method": "void resetFloorplan(){\r\n    mTango3dReconstruction.clear();\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.elasticsearch.persistence.StatusUpdaterBolt.getIndexName",
	"Comment": "must be overridden for implementing custom index names based on somemetadata information by default, indexname coming from config is used",
	"Method": "String getIndexName(Metadata m){\r\n    return indexName;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetClientRSAPublicKey",
	"Comment": "test of getclientrsapublickey method, of class defaultchooser.",
	"Method": "void testGetClientRSAPublicKey(){\r\n    context.setClientRSAPublicKey(null);\r\n    config.setDefaultClientRSAPublicKey(BigInteger.ONE);\r\n    assertEquals(BigInteger.ONE, config.getDefaultClientRSAPublicKey());\r\n    assertEquals(BigInteger.ONE, chooser.getClientRSAPublicKey());\r\n    context.setClientRSAPublicKey(BigInteger.TEN);\r\n    assertEquals(BigInteger.TEN, chooser.getClientRSAPublicKey());\r\n}"
}, {
	"Path": "org.togglz.core.activation.ParameterBuilder.description",
	"Comment": "sets an optional description for the parameter displayed in the admin console.",
	"Method": "ParameterBuilder description(String description){\r\n    this.description = description;\r\n    return this;\r\n}"
}, {
	"Path": "com.diffplug.spotless.generic.EndWithNewlineStep.create",
	"Comment": "creates a formatterstep which forces lines to end with a newline.",
	"Method": "FormatterStep create(){\r\n    return FormatterStep.create(\"endWithNewline\", EndWithNewlineStep.class, unused -> EndWithNewlineStep::format);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.occlusion.OcclusionActivity.hasCameraPermission",
	"Comment": "check to see if we have the necessary permissions for this app.",
	"Method": "boolean hasCameraPermission(){\r\n    return ContextCompat.checkSelfPermission(this, CAMERA_PERMISSION) == PackageManager.PERMISSION_GRANTED;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeClientRandomActionTest.testGetNewValue",
	"Comment": "test of getnewvalue method, of class changeclientrandomaction.",
	"Method": "void testGetNewValue(){\r\n    assertArrayEquals(action.getNewValue(), new byte[] { 0, 1 });\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ClientHelloHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class clienthellohandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new ClientHelloMessage()) instanceof ClientHelloPreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.ChangeCipherSpecSerializerTest.testSerializeProtocolMessageContent",
	"Comment": "test of serializeprotocolmessagecontent method, of classchangecipherspecserializer.",
	"Method": "void testSerializeProtocolMessageContent(){\r\n    ChangeCipherSpecMessage msg = new ChangeCipherSpecMessage();\r\n    msg.setCcsProtocolType(ccsType);\r\n    msg.setCompleteResultingMessage(expectedPart);\r\n    ChangeCipherSpecSerializer serializer = new ChangeCipherSpecSerializer(msg, version);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetHeartbeatMode",
	"Comment": "test of getheartbeatmode method, of class defaultchooser.",
	"Method": "void testGetHeartbeatMode(){\r\n    config.setHeartbeatMode(HeartbeatMode.PEER_ALLOWED_TO_SEND);\r\n    assertEquals(HeartbeatMode.PEER_ALLOWED_TO_SEND, config.getHeartbeatMode());\r\n    assertEquals(HeartbeatMode.PEER_ALLOWED_TO_SEND, chooser.getHeartbeatMode());\r\n    context.setHeartbeatMode(HeartbeatMode.PEER_NOT_ALLOWED_TO_SEND);\r\n    assertEquals(HeartbeatMode.PEER_NOT_ALLOWED_TO_SEND, chooser.getHeartbeatMode());\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.tika.XMLCharacterRecognizer.isWhiteSpace",
	"Comment": "returns whether the specified ch conforms to the xml 1.0definition of whitespace. refer tothe definition ofs for details.",
	"Method": "boolean isWhiteSpace(char ch,boolean isWhiteSpace,char ch,int start,int length,boolean isWhiteSpace,StringBuffer buf,boolean isWhiteSpace,String s){\r\n    if (null != s) {\r\n        int n = s.length();\r\n        for (int i = 0; i < n; i++) {\r\n            if (!isWhiteSpace(s.charAt(i)))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.ExtensionParser.parseExtensionType",
	"Comment": "reads the next bytes as the type of the extension and writes it in themessage",
	"Method": "void parseExtensionType(ExtensionMessage msg){\r\n    msg.setExtensionType(parseByteArrayField(ExtensionByteLength.TYPE));\r\n    LOGGER.debug(\"ExtensionType: \" + ArrayConverter.bytesToHexString(msg.getExtensionType().getValue()));\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.wrapsIndexOutOfBoundsExceptionFromListIterator",
	"Comment": "verboselist should wraps outofboundsexception thrown by listiteratormethod.",
	"Method": "void wrapsIndexOutOfBoundsExceptionFromListIterator(){\r\n    final int index = 5;\r\n    final Exception cause = new IndexOutOfBoundsException();\r\n    Mockito.doThrow(cause).when(this.origin).listIterator(index);\r\n    this.thrown.expect(IndexOutOfBoundsException.class);\r\n    this.thrown.expectMessage(VerboseListTest.MSG);\r\n    this.thrown.expectCause(Matchers.is(cause));\r\n    this.list.listIterator(index);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.HeartbeatExtensionHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class heartbeatextensionhandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[] { 0, 1, 2 }, 0) instanceof HeartbeatExtensionParser);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.doPointMeasurement",
	"Comment": "use the tangosupport library with point cloud data to calculate the point in opengl framepointed at the location the crosshair is aiming.",
	"Method": "float[] doPointMeasurement(float u,float v,double rgbTimestamp){\r\n    TangoPointCloudData pointCloud = mPointCloudManager.getLatestPointCloud();\r\n    if (pointCloud == null) {\r\n        return null;\r\n    }\r\n    TangoPoseData openglTdepthPose = TangoSupport.getPoseAtTime(pointCloud.timestamp, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_DEPTH, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_TANGO, TangoSupport.ROTATION_IGNORED);\r\n    if (openglTdepthPose.statusCode != TangoPoseData.POSE_VALID) {\r\n        Log.w(TAG, \"Could not get openglTdepth pose at time \" + pointCloud.timestamp);\r\n        return null;\r\n    }\r\n    TangoPoseData openglTcolorPose = TangoSupport.getPoseAtTime(rgbTimestamp, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_TANGO, TangoSupport.ROTATION_IGNORED);\r\n    if (openglTcolorPose.statusCode != TangoPoseData.POSE_VALID) {\r\n        Log.w(TAG, \"Could not get openglTcolor pose at time \" + rgbTimestamp);\r\n        return null;\r\n    }\r\n    float[] openglPoint = TangoDepthInterpolation.getDepthAtPointNearestNeighbor(pointCloud, openglTdepthPose.translation, openglTdepthPose.rotation, u, v, mDisplayRotation, openglTcolorPose.translation, openglTcolorPose.rotation);\r\n    if (openglPoint == null) {\r\n        return null;\r\n    }\r\n    return openglPoint;\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.identity.DeviceAuthentication.storeDevice",
	"Comment": "store the uid, key, username combination in the identity table. the uidwill represent the item name and the item will contain attributes key andusername.",
	"Method": "void storeDevice(String uid,String key,String username){\r\n    Map<String, AttributeValue> item = new HashMap<String, AttributeValue>();\r\n    item.put(ATTRIBUTE_UID, new AttributeValue().withS(uid));\r\n    item.put(ATTRIBUTE_KEY, new AttributeValue().withS(key));\r\n    item.put(ATTRIBUTE_USERNAME, new AttributeValue().withS(username));\r\n    PutItemRequest putItemRequest = new PutItemRequest().withTableName(DEVICE_TABLE).withItem(item);\r\n    try {\r\n        ddb.putItem(putItemRequest);\r\n    } catch (AmazonClientException e) {\r\n        throw new DataAccessException(String.format(\"Failed to store device uid: %s; key: %s; username: %s\", uid, key, username), e);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.socket.OutboundConnectionTest.testSerializeNonDefaultFields",
	"Comment": "verify that the serverconnectionend includes manually set values inserialization output.",
	"Method": "void testSerializeNonDefaultFields(){\r\n    TestXmlRoot expected = new TestXmlRoot();\r\n    expected.setAlias(\"TestMe\");\r\n    expected.setPort(4444);\r\n    m.marshal(expected, writer);\r\n    String xmlString = writer.toString();\r\n    LOGGER.debug(xmlString);\r\n    StringBuilder sb = new StringBuilder(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\\n\");\r\n    sb.append(\"<testXmlRoot>\\n\");\r\n    sb.append(\"    <alias>TestMe<\/alias>\\n\");\r\n    sb.append(\"    <port>4444<\/port>\\n\");\r\n    sb.append(\"<\/testXmlRoot>\\n\");\r\n    assertEquals(sb.toString(), xmlString);\r\n    Unmarshaller um = context.createUnmarshaller();\r\n    TestXmlRoot actual = (TestXmlRoot) um.unmarshal(new StringReader(xmlString));\r\n    assertEquals(expected, actual);\r\n    assertNotSame(expected, actual);\r\n}"
}, {
	"Path": "org.takes.tk.TkCorsTest.handleConnectionsWithCorrectDomainOnOrigin",
	"Comment": "tkcors can handle connections with correct domain on origin.",
	"Method": "void handleConnectionsWithCorrectDomainOnOrigin(){\r\n    MatcherAssert.assertThat(\"Invalid HTTP status for a request with correct domain.\", new TkCors(new TkFixed(new RsText()), \"http://teamed.io\", \"http://example.com\").act(new RqWithHeaders(new RqFake(), \"Origin: http://teamed.io\")), new HmRsStatus(HttpURLConnection.HTTP_OK));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.SessionTicketTlsExtensionHandlerTest.testGetSerializer",
	"Comment": "tests the getserializer of the sessiontickettlsextensionhandler class",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new SessionTicketTLSExtensionMessage()) instanceof SessionTicketTLSExtensionSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ProtocolMessageHandler.prepareMessage",
	"Comment": "prepare message for sending. this method invokes before and after methodhooks.",
	"Method": "byte[] prepareMessage(Message message,byte[] prepareMessage,Message message,boolean withPrepare){\r\n    if (withPrepare) {\r\n        Preparator preparator = getPreparator(message);\r\n        preparator.prepare();\r\n        preparator.afterPrepare();\r\n        Serializer serializer = getSerializer(message);\r\n        byte[] completeMessage = serializer.serialize();\r\n        message.setCompleteResultingMessage(completeMessage);\r\n        if (message instanceof HandshakeMessage) {\r\n            if (((HandshakeMessage) message).getIncludeInDigest()) {\r\n                tlsContext.getDigest().append(message.getCompleteResultingMessage().getValue());\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        if (message.getAdjustContext()) {\r\n            adjustTLSContext(message);\r\n        } else {\r\n            LOGGER.debug(\"Not adjusting TLSContext for \" + message.toCompactString());\r\n        }\r\n    } catch (AdjustmentException E) {\r\n        LOGGER.warn(\"Could not adjust TLSContext\");\r\n        LOGGER.debug(E);\r\n    }\r\n    return message.getCompleteResultingMessage().getValue();\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPI1Test.testTessBaseAPIDetectOrientationScript",
	"Comment": "test of tessbaseapidetectorientationscript method, of class tessapi1.",
	"Method": "void testTessBaseAPIDetectOrientationScript(){\r\n    logger.info(\"TessBaseAPIDetectOrientationScript\");\r\n    File image = new File(testResourcesDataPath, \"eurotext.png\");\r\n    int expResult = TRUE;\r\n    Pix pix = Leptonica1.pixRead(image.getPath());\r\n    TessAPI1.TessBaseAPIInit3(handle, datapath, language);\r\n    TessAPI1.TessBaseAPISetImage2(handle, pix);\r\n    IntBuffer orient_degB = IntBuffer.allocate(1);\r\n    FloatBuffer orient_confB = FloatBuffer.allocate(1);\r\n    PointerByReference script_nameB = new PointerByReference();\r\n    FloatBuffer script_confB = FloatBuffer.allocate(1);\r\n    int result = TessAPI1.TessBaseAPIDetectOrientationScript(handle, orient_degB, orient_confB, script_nameB, script_confB);\r\n    if (result == TRUE) {\r\n        int orient_deg = orient_degB.get();\r\n        float orient_conf = orient_confB.get();\r\n        String script_name = script_nameB.getValue().getString(0);\r\n        float script_conf = script_confB.get();\r\n        logger.info(String.format(\"OrientationScript: orient_deg=%d, orient_conf=%f, script_name=%s, script_conf=%f\", orient_deg, orient_conf, script_name, script_conf));\r\n    }\r\n    PointerByReference pRef = new PointerByReference();\r\n    pRef.setValue(pix.getPointer());\r\n    Leptonica1.pixDestroy(pRef);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.delegatesSize",
	"Comment": "verboselist should delegate size method to decorated list.",
	"Method": "void delegatesSize(){\r\n    this.list.size();\r\n    Mockito.verify(this.origin).size();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.ServerNameIndicationExtensionHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of classservernameindicationextensionhandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new ServerNameIndicationExtensionMessage()) instanceof ServerNameIndicationExtensionSerializer);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.occlusion.OcclusionRenderer.setProjectionMatrix",
	"Comment": "set the projection matrix matching the tango rgb camera in order to be able to doaugmented reality.",
	"Method": "void setProjectionMatrix(float[] matrixFloats,float nearPlane,float farPlane){\r\n    mProjectionMatrix = matrixFloats;\r\n    mOpenGlSphere.configureCamera(nearPlane, farPlane);\r\n    mProjectionMatrixConfigured = true;\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.delegatesRemove",
	"Comment": "verboselist should delegate remove method to decorated list.",
	"Method": "void delegatesRemove(){\r\n    final int index = 5;\r\n    final Object obj = new Object();\r\n    this.list.remove(obj);\r\n    Mockito.verify(this.origin).remove(obj);\r\n    this.list.remove(index);\r\n    Mockito.verify(this.origin).remove(index);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.setDisplayRotation",
	"Comment": "set the color camera background texture rotation and save the display rotation.",
	"Method": "void setDisplayRotation(){\r\n    Display display = getWindowManager().getDefaultDisplay();\r\n    mDisplayRotation = display.getRotation();\r\n    mSurfaceView.queueEvent(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            if (mIsConnected) {\r\n                mRenderer.updateColorCameraTextureUvGlThread(mDisplayRotation);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.setDisplayRotation",
	"Comment": "set the color camera background texture rotation and save the display rotation.",
	"Method": "void setDisplayRotation(){\r\n    if (mIsConnected) {\r\n        mRenderer.updateColorCameraTextureUvGlThread(mDisplayRotation);\r\n    }\r\n}"
}, {
	"Path": "com.example.android.trivialdrivesample.util.IabHelper.startSetup",
	"Comment": "starts the setup process. this will start up the setup process asynchronously.you will be notified through the listener when the setup process is complete.this method is safe to call from a ui thread.",
	"Method": "void startSetup(OnIabSetupFinishedListener listener){\r\n    checkNotDisposed();\r\n    if (mSetupDone)\r\n        throw new IllegalStateException(\"IAB helper is already set up.\");\r\n    logDebug(\"Starting in-app billing setup.\");\r\n    mServiceConn = new ServiceConnection() {\r\n        @Override\r\n        public void onServiceDisconnected(ComponentName name) {\r\n            logDebug(\"Billing service disconnected.\");\r\n            mService = null;\r\n        }\r\n        @Override\r\n        public void onServiceConnected(ComponentName name, IBinder service) {\r\n            if (mDisposed)\r\n                return;\r\n            logDebug(\"Billing service connected.\");\r\n            mService = IInAppBillingService.Stub.asInterface(service);\r\n            String packageName = mContext.getPackageName();\r\n            try {\r\n                logDebug(\"Checking for in-app billing 3 support.\");\r\n                int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);\r\n                if (response != BILLING_RESPONSE_RESULT_OK) {\r\n                    if (listener != null)\r\n                        listener.onIabSetupFinished(new IabResult(response, \"Error checking for billing v3 support.\"));\r\n                    mSubscriptionsSupported = false;\r\n                    return;\r\n                }\r\n                logDebug(\"In-app billing version 3 supported for \" + packageName);\r\n                response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);\r\n                if (response == BILLING_RESPONSE_RESULT_OK) {\r\n                    logDebug(\"Subscriptions AVAILABLE.\");\r\n                    mSubscriptionsSupported = true;\r\n                } else {\r\n                    logDebug(\"Subscriptions NOT AVAILABLE. Response: \" + response);\r\n                }\r\n                mSetupDone = true;\r\n            } catch (RemoteException e) {\r\n                if (listener != null) {\r\n                    listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION, \"RemoteException while setting up in-app billing.\"));\r\n                }\r\n                e.printStackTrace();\r\n                return;\r\n            }\r\n            if (listener != null) {\r\n                listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, \"Setup successful.\"));\r\n            }\r\n        }\r\n    };\r\n    Intent serviceIntent = new Intent(\"com.android.vending.billing.InAppBillingService.BIND\");\r\n    serviceIntent.setPackage(\"com.android.vending\");\r\n    if (!mContext.getPackageManager().queryIntentServices(serviceIntent, 0).isEmpty()) {\r\n        mContext.bindService(serviceIntent, mServiceConn, Context.BIND_AUTO_CREATE);\r\n    } else {\r\n        if (listener != null) {\r\n            listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE, \"Billing service unavailable on device.\"));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.example.android.trivialdrivesample.util.IabHelper.startSetup",
	"Comment": "starts the setup process. this will start up the setup process asynchronously.you will be notified through the listener when the setup process is complete.this method is safe to call from a ui thread.",
	"Method": "void startSetup(OnIabSetupFinishedListener listener){\r\n    logDebug(\"Billing service disconnected.\");\r\n    mService = null;\r\n}"
}, {
	"Path": "com.example.android.trivialdrivesample.util.IabHelper.startSetup",
	"Comment": "starts the setup process. this will start up the setup process asynchronously.you will be notified through the listener when the setup process is complete.this method is safe to call from a ui thread.",
	"Method": "void startSetup(OnIabSetupFinishedListener listener){\r\n    if (mDisposed)\r\n        return;\r\n    logDebug(\"Billing service connected.\");\r\n    mService = IInAppBillingService.Stub.asInterface(service);\r\n    String packageName = mContext.getPackageName();\r\n    try {\r\n        logDebug(\"Checking for in-app billing 3 support.\");\r\n        int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);\r\n        if (response != BILLING_RESPONSE_RESULT_OK) {\r\n            if (listener != null)\r\n                listener.onIabSetupFinished(new IabResult(response, \"Error checking for billing v3 support.\"));\r\n            mSubscriptionsSupported = false;\r\n            return;\r\n        }\r\n        logDebug(\"In-app billing version 3 supported for \" + packageName);\r\n        response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);\r\n        if (response == BILLING_RESPONSE_RESULT_OK) {\r\n            logDebug(\"Subscriptions AVAILABLE.\");\r\n            mSubscriptionsSupported = true;\r\n        } else {\r\n            logDebug(\"Subscriptions NOT AVAILABLE. Response: \" + response);\r\n        }\r\n        mSetupDone = true;\r\n    } catch (RemoteException e) {\r\n        if (listener != null) {\r\n            listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION, \"RemoteException while setting up in-app billing.\"));\r\n        }\r\n        e.printStackTrace();\r\n        return;\r\n    }\r\n    if (listener != null) {\r\n        listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, \"Setup successful.\"));\r\n    }\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.identity.AWSCognitoDeveloperAuthenticationSample.getKey",
	"Comment": "generate key for device uid. the key is encrypted by hash of saltedpassword of the user. encrypted key is then wrapped in json object beforereturning it. this function is useful in identity mode",
	"Method": "String getKey(String username,String uid){\r\n    DeviceInfo device = ensureKnownDevice(uid);\r\n    UserInfo user = ensureKnownUser(username);\r\n    log.info(\"Responding with encrypted key for UID : \" + uid);\r\n    return Utilities.prepareJsonResponseForKey(device.getKey(), user.getHashedPassword());\r\n}"
}, {
	"Path": "com.reacttwitter.MainActivity.getPackages",
	"Comment": "a list of packages used by the app. if the app uses additional viewsor modules besides the default ones, add more packages here.",
	"Method": "List<ReactPackage> getPackages(){\r\n    pushNotificationPackage = new ReactNativePushNotificationPackage(this);\r\n    return Arrays.asList(new MainReactPackage(), new NativeWidgetsPackage(), oauthIntentPackage, pushNotificationPackage);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.PskClientKeyExchangeMessageTest.testToString",
	"Comment": "test of tostring method, of class pskclientkeyexchangemessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"PskClientKeyExchangeMessage:\");\r\n    sb.append(\"\\n  PSKIdentity Length: \").append(\"null\");\r\n    sb.append(\"\\n  PSKIdentity: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.openglar.OpenGlAugmentedRealityRenderer.setProjectionMatrix",
	"Comment": "set the projection matrix matching the tango rgb camera in order to be able to doaugmented reality.",
	"Method": "void setProjectionMatrix(float[] matrixFloats){\r\n    mEarthSphere.setProjectionMatrix(matrixFloats);\r\n    mMoonSphere.setProjectionMatrix(matrixFloats);\r\n    mProjectionMatrixConfigured = true;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.transport.tcp.ClientTcpTransportHandlerTest.testInitialize",
	"Comment": "test of initialize method, of class clienttcptransporthandler.",
	"Method": "void testInitialize(){\r\n    ServerSocketChannel serverSocketChannel = null;\r\n    try {\r\n        serverSocketChannel = ServerSocketChannel.open();\r\n        serverSocketChannel.socket().bind(new InetSocketAddress(0));\r\n        serverSocketChannel.configureBlocking(false);\r\n        handler = new ClientTcpTransportHandler(100, \"localhost\", serverSocketChannel.socket().getLocalPort());\r\n        handler.initialize();\r\n        SocketChannel acceptChannel = serverSocketChannel.accept();\r\n        assertNotNull(acceptChannel);\r\n        assertTrue(handler.isInitialized());\r\n    } finally {\r\n        if (serverSocketChannel != null) {\r\n            try {\r\n                serverSocketChannel.close();\r\n            } catch (IOException ex) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ECDHEServerKeyExchangeParser.parseSerializedPublicKeyLength",
	"Comment": "reads the next bytes as the serializedpublickeylength and writes them inthe message",
	"Method": "void parseSerializedPublicKeyLength(ECDHEServerKeyExchangeMessage msg){\r\n    msg.setPublicKeyLength(parseIntField(HandshakeByteLength.ECDHE_PARAM_LENGTH));\r\n    LOGGER.debug(\"SerializedPublicKeyLength: \" + msg.getPublicKeyLength().getValue());\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.util.Geom.first",
	"Comment": "returns the first polygon in a multi polygon, or null if the multi polygon is empty.",
	"Method": "Point first(MultiPoint mp,LineString first,MultiLineString ml,Polygon first,MultiPolygon mp){\r\n    return mp.getNumGeometries() > 0 ? (Polygon) mp.getGeometryN(0) : null;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderRenderer.updateViewMatrix",
	"Comment": "update the view matrix matching the pose of the tango rgb camera.",
	"Method": "void updateViewMatrix(float[] ssTcamera){\r\n    float[] viewMatrix = new float[16];\r\n    Matrix.invertM(viewMatrix, 0, ssTcamera, 0);\r\n    mViewMatrix = viewMatrix;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.TangoMesher.release",
	"Comment": "synchronize access to mtango3dreconstruction. this runs in ui thread.",
	"Method": "void release(){\r\n    mIsReconstructionActive = false;\r\n    mTango3dReconstruction.release();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.MaxFragmentLengthExtensionHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class maxfragmentlengthextensionhandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new MaxFragmentLengthExtensionMessage()) instanceof MaxFragmentLengthExtensionPreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.CertificateMessageParser.parseCertificateList",
	"Comment": "reads the bytes from the certificatelistbytes and writes them in thecertificatelist",
	"Method": "void parseCertificateList(CertificateMessage msg){\r\n    int position = 0;\r\n    List<CertificatePair> pairList = new LinkedList();\r\n    while (position < msg.getCertificatesListLength().getValue()) {\r\n        CertificatePairParser parser = new CertificatePairParser(position, msg.getCertificatesListBytes().getValue());\r\n        pairList.add(parser.parse());\r\n        if (position == parser.getPointer()) {\r\n            throw new ParserException(\"Ran into infinite Loop while parsing CertificatePairs\");\r\n        }\r\n        position = parser.getPointer();\r\n    }\r\n    msg.setCertificatesList(pairList);\r\n    List<CertificateEntry> entryList = new LinkedList();\r\n    for (CertificatePair pair : msg.getCertificatesList()) {\r\n        List<ExtensionMessage> extensionMessages = new LinkedList();\r\n        int pointer = 0;\r\n        while (pointer < pair.getExtensionsLength().getValue()) {\r\n            ExtensionParser parser = ExtensionParserFactory.getExtensionParser(pair.getExtensions().getValue(), pointer, msg.getHandshakeMessageType());\r\n            extensionMessages.add(parser.parse());\r\n            if (pointer == parser.getPointer()) {\r\n                throw new ParserException(\"Ran into infinite Loop while parsing CertificateExtensions\");\r\n            }\r\n            pointer = parser.getPointer();\r\n        }\r\n        entryList.add(new CertificateEntry(pair.getCertificate().getValue(), extensionMessages));\r\n    }\r\n    msg.setCertificatesListAsEntry(entryList);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.PskEcDhClientKeyExchangeParser.parsePskIdentityLength",
	"Comment": "reads the next bytes as the pskidentitylength and writes them in themessage",
	"Method": "void parsePskIdentityLength(PskEcDhClientKeyExchangeMessage msg){\r\n    msg.setIdentityLength(parseIntField(HandshakeByteLength.PSK_IDENTITY_LENGTH));\r\n    LOGGER.debug(\"PSK-IdentityLength: \" + msg.getIdentityLength().getValue());\r\n}"
}, {
	"Path": "studio.carbonylgroup.textfieldboxes.TextFieldBoxes.setHighlightColor",
	"Comment": "set the color of the labeltext label, edittext cursor, icon signifier and the underline",
	"Method": "void setHighlightColor(int colorRes){\r\n    this.floatingLabel.setTextColor(colorRes);\r\n    setCursorDrawableColor(this.editText, colorRes);\r\n    if (getIsResponsiveIconColor()) {\r\n        this.iconImageButton.setColorFilter(colorRes);\r\n        if (colorRes == secondaryColor)\r\n            this.iconImageButton.setAlpha(0.54f);\r\n        else\r\n            this.iconImageButton.setAlpha(1f);\r\n    }\r\n    if (colorRes == DEFAULT_DISABLED_TEXT_COLOR)\r\n        this.iconImageButton.setAlpha(0.35f);\r\n    this.bottomLine.setBackgroundColor(colorRes);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.CompressionDelegateTest.testApplyDelegate",
	"Comment": "test of applydelegate method, of class compressiondelegate.",
	"Method": "void testApplyDelegate(){\r\n    args = new String[2];\r\n    args[0] = \"-compression\";\r\n    args[1] = \"NULL,DEFLATE\";\r\n    jcommander.parse(args);\r\n    Config config = Config.createConfig();\r\n    config.setDefaultClientSupportedCompressionMethods(new CompressionMethod[0]);\r\n    config.setDefaultServerSupportedCompressionMethods(new CompressionMethod[0]);\r\n    delegate.applyDelegate(config);\r\n    assertTrue(\"NULL should get parsed correctly\", config.getDefaultClientSupportedCompressionMethods().contains(CompressionMethod.NULL));\r\n    assertTrue(\"DEFLATE should get parsed correctly\", config.getDefaultClientSupportedCompressionMethods().contains(CompressionMethod.DEFLATE));\r\n    assertTrue(\"NULL should get parsed correctly\", config.getDefaultServerSupportedCompressionMethods().contains(CompressionMethod.NULL));\r\n    assertTrue(\"DEFLATE should get parsed correctly\", config.getDefaultServerSupportedCompressionMethods().contains(CompressionMethod.DEFLATE));\r\n}"
}, {
	"Path": "org.springframework.cloud.consul.config.ConsulPropertySource.parsePropertiesWithNonKeyValueFormat",
	"Comment": "parses the properties using the format which is not a key value style i.e., either\tjava properties style or yaml style",
	"Method": "void parsePropertiesWithNonKeyValueFormat(List<GetValue> values,ConsulConfigProperties.Format format){\r\n    if (values == null) {\r\n        return;\r\n    }\r\n    for (GetValue getValue : values) {\r\n        String key = getValue.getKey().replace(context, \"\");\r\n        if (configProperties.getDataKey().equals(key)) {\r\n            parseValue(getValue, format);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ECDHClientKeyExchangeHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class ecdhclientkeyexchangehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new ECDHClientKeyExchangeMessage()) instanceof ECDHClientKeyExchangePreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.Parser.parseIntField",
	"Comment": "parses a number of bytes from the array and returns them as a int. throwsa parserexception if the number of bytes cannot be parsed. moves thepointer accordingly.",
	"Method": "int parseIntField(int length){\r\n    if (length == 0) {\r\n        throw new ParserException(\"Cannot parse int of size 0\");\r\n    }\r\n    return ArrayConverter.bytesToInt(parseByteArrayField(length));\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.setDisplayRotation",
	"Comment": "set the color camera background texture rotation and save the display rotation.",
	"Method": "void setDisplayRotation(){\r\n    Display display = getWindowManager().getDefaultDisplay();\r\n    mDisplayRotation = display.getRotation();\r\n    mSurfaceView.queueEvent(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            if (mIsConnected) {\r\n                mRenderer.updateColorCameraTextureUvGlThread(mDisplayRotation);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.setDisplayRotation",
	"Comment": "set the color camera background texture rotation and save the display rotation.",
	"Method": "void setDisplayRotation(){\r\n    if (mIsConnected) {\r\n        mRenderer.updateColorCameraTextureUvGlThread(mDisplayRotation);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.PskEcDhClientKeyExchangeParser.parsePskIdentity",
	"Comment": "reads the next bytes as the pskidentity and writes them in the message",
	"Method": "void parsePskIdentity(PskEcDhClientKeyExchangeMessage msg){\r\n    msg.setIdentity(parseByteArrayField(msg.getIdentityLength().getValue()));\r\n    LOGGER.debug(\"SerializedPSK-Identity: \" + ArrayConverter.bytesToHexString(msg.getIdentity().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ProtocolMessageParser.parseCompleteResultingMessage",
	"Comment": "reads the next bytes as the completeresultingmessage and writes them inthe message",
	"Method": "void parseCompleteResultingMessage(ProtocolMessage msg){\r\n    msg.setCompleteResultingMessage(getAlreadyParsed());\r\n    LOGGER.debug(\"CompleteResultMessage: \" + ArrayConverter.bytesToHexString(msg.getCompleteResultingMessage().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskEcDheServerKeyExchangeHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of classpskecdheserverkeyexchangehandler.",
	"Method": "void testAdjustTLSContext(){\r\n    PskEcDheServerKeyExchangeMessage message = new PskEcDheServerKeyExchangeMessage();\r\n    message.setCurveType(EllipticCurveType.NAMED_CURVE.getValue());\r\n    message.setNamedGroup(NamedGroup.SECP256R1.getValue());\r\n    message.setPublicKey(ArrayConverter.hexStringToByteArray(\"04f660a88e9dae015684be56c25610f9c62cf120cb075eea60c560e5e6dd5d10ef6e391d7213a298985470dc2268949317ce24940d474a0c8386ab13b312ffc104\"));\r\n    message.setPublicKeyLength(65);\r\n    message.prepareComputations();\r\n    message.getComputations().setPremasterSecret(new byte[] { 0, 1, 2, 3 });\r\n    message.getComputations().setPrivateKey(new BigInteger(\"12345\"));\r\n    handler.adjustTLSContext(message);\r\n    assertNull(context.getPreMasterSecret());\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPI1Test.testTessBaseAPIGetAvailableLanguagesAsVector",
	"Comment": "test of tessbaseapigetavailablelanguagesasvector method, of classtessapi1.",
	"Method": "void testTessBaseAPIGetAvailableLanguagesAsVector(){\r\n    logger.info(\"TessBaseAPIGetAvailableLanguagesAsVector\");\r\n    TessAPI1.TessBaseAPIInit3(handle, datapath, language);\r\n    String[] expResult = { \"eng\" };\r\n    String[] result = TessAPI1.TessBaseAPIGetAvailableLanguagesAsVector(handle).getPointer().getStringArray(0);\r\n    assertTrue(Arrays.asList(result).containsAll(Arrays.asList(expResult)));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.HelloRequestHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class hellorequesthandler.",
	"Method": "void testAdjustTLSContext(){\r\n    HelloRequestMessage message = new HelloRequestMessage();\r\n    handler.adjustTLSContext(message);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.transport.stream.StreamTransportHandlerTest.testGetOutputStream",
	"Comment": "test of getoutputstream method, of class streamtransporthandler.",
	"Method": "void testGetOutputStream(){\r\n    assertNotNull(handler.getOutputStream());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.PskDheServerKeyExchangeParserTest.testParse",
	"Comment": "test of parse method, of class pskdheserverkeyexchangeparser.",
	"Method": "void testParse(){\r\n    PskDheServerKeyExchangeParser parser = new PskDheServerKeyExchangeParser(0, message, version);\r\n    PskDheServerKeyExchangeMessage msg = parser.parse();\r\n    assertArrayEquals(message, msg.getCompleteResultingMessage().getValue());\r\n    assertTrue(msg.getLength().getValue() == length);\r\n    assertTrue(msg.getType().getValue() == type.getValue());\r\n    assertTrue(PskIdentityHintLength == msg.getIdentityHintLength().getValue());\r\n    assertArrayEquals(PskIdentityHint, msg.getIdentityHint().getValue());\r\n}"
}, {
	"Path": "org.takes.rs.RsPrettyXmlTest.formatsHtml4DoctypeBody",
	"Comment": "rsprettyxml can format html4 markup with doctype with publicand system id.",
	"Method": "void formatsHtml4DoctypeBody(){\r\n    final String pid = \"PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \";\r\n    final String xhtml = \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" \".concat(\"lang=\\\"en\\\">\");\r\n    MatcherAssert.assertThat(new RsPrint(new RsPrettyXml(new RsWithBody(Joiner.on(\"\").appendTo(new StringBuilder(\"<!DOCTYPE HTML \"), pid, \"\\\"http://www.w3.org/TR/html4/loose.dtd\\\">\", xhtml, \"<head><a>foo<\/a><\/head>\", \"<body>this is body<\/body><\/html>\")))).printBody(), Matchers.is(Joiner.on(\"\").appendTo(new StringBuilder(\"<!DOCTYPE html\\n  \"), pid, \"\\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\", xhtml, \"\\n   <head>\\n      \", \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; \", \"charset=UTF-8\\\" /><a>foo<\/a><\/head>\\n   \", \"<body>this is body<\/body>\\n<\/html>\").toString()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.SignatureAndHashAlgorithmsExtensionParser.parseSignatureAndHashAlgorithmsLength",
	"Comment": "reads the next bytes as the signatureandhandshakealgorithmslength of theextension and writes them in the message",
	"Method": "void parseSignatureAndHashAlgorithmsLength(SignatureAndHashAlgorithmsExtensionMessage msg){\r\n    msg.setSignatureAndHashAlgorithmsLength(parseIntField(ExtensionByteLength.SIGNATURE_AND_HASH_ALGORITHMS));\r\n    LOGGER.debug(\"SignatureAndHashAlgorithmsLength: \" + msg.getSignatureAndHashAlgorithmsLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.ServerNamePairParser.parseServerName",
	"Comment": "reads the next bytes as the servername of the extension and writes themin the message",
	"Method": "void parseServerName(ServerNamePair pair){\r\n    pair.setServerName(parseByteArrayField(pair.getServerNameLength().getValue()));\r\n    LOGGER.debug(\"ServerName: \" + ArrayConverter.bytesToHexString(pair.getServerName().getValue()));\r\n}"
}, {
	"Path": "com.diffplug.spotless.markdown.FreshMarkStep.create",
	"Comment": "creates a formatter step for the given version and settings file.",
	"Method": "FormatterStep create(Supplier<Map<String, ?>> properties,Provisioner provisioner,FormatterStep create,String version,Supplier<Map<String, ?>> properties,Provisioner provisioner){\r\n    Objects.requireNonNull(version, \"version\");\r\n    Objects.requireNonNull(properties, \"properties\");\r\n    Objects.requireNonNull(provisioner, \"provisioner\");\r\n    return FormatterStep.createLazy(NAME, () -> new State(JarState.from(MAVEN_COORDINATE + version, provisioner), properties.get()), State::createFormat);\r\n}"
}, {
	"Path": "org.takes.rs.xe.XeMillisTest.buildsHtmlResponse",
	"Comment": "xemillis can build html response with default xsl template.",
	"Method": "void buildsHtmlResponse(){\r\n    MatcherAssert.assertThat(IOUtils.toString(new RsXslt(new RsXembly(new XeStylesheet(\"/org/takes/rs/xe/test_millis.xsl\"), new XeAppend(\"page\", new XeMillis(false), new XeMillis(true)))).body(), StandardCharsets.UTF_8), XhtmlMatchers.hasXPaths(\"/xhtml:html/xhtml:span\"));\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.util.Geom.array",
	"Comment": "returns the geometries of a geometry collection as an array.",
	"Method": "T[] array(GeometryCollection gc,T[] array){\r\n    for (int i = 0; i < gc.getNumGeometries(); i++) {\r\n        array[i] = (T) gc.getGeometryN(i);\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.EllipticCurvesExtensionParser.parseSupportedGroupsLength",
	"Comment": "reads the next bytes as the supportedcurveslength of the extension andwrites them in the message",
	"Method": "void parseSupportedGroupsLength(EllipticCurvesExtensionMessage msg){\r\n    msg.setSupportedGroupsLength(parseIntField(ExtensionByteLength.SUPPORTED_GROUPS));\r\n    LOGGER.debug(\"SupportedGroupsLength: \" + msg.getSupportedGroupsLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.CertificateRequestParser.parseDistinguishedNamesLength",
	"Comment": "reads the next bytes as the distinguishednameslength and writes them inthe message",
	"Method": "void parseDistinguishedNamesLength(CertificateRequestMessage msg){\r\n    msg.setDistinguishedNamesLength(parseIntField(HandshakeByteLength.DISTINGUISHED_NAMES_LENGTH));\r\n    LOGGER.debug(\"DistinguishedNamesLength: \" + msg.getDistinguishedNamesLength().getValue());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceRenderer.makePoint",
	"Comment": "render the new correspondence destination point measurements as red spheres.",
	"Method": "Object3D makePoint(float[] openGLPpoint,int color){\r\n    Object3D object3D = new Sphere(SPHERE_RADIUS, 10, 10);\r\n    object3D.setMaterial(mSphereMaterial);\r\n    object3D.setColor(color);\r\n    object3D.setPosition(openGLPpoint[0], openGLPpoint[1], openGLPpoint[2]);\r\n    return object3D;\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.identity.AWSCognitoDeveloperAuthenticationSample.isTimestampValid",
	"Comment": "checks to see if the request has valid timestamp. if given timestampfalls in 30 mins window from current server timestamp",
	"Method": "boolean isTimestampValid(String timestamp){\r\n    long timestampLong = 0L;\r\n    final long window = 15 * 60 * 1000L;\r\n    if (null == timestamp) {\r\n        return false;\r\n    }\r\n    timestampLong = DateUtils.parseISO8601Date(timestamp).getTime();\r\n    Long now = new Date().getTime();\r\n    long before15Mins = new Date(now - window).getTime();\r\n    long after15Mins = new Date(now + window).getTime();\r\n    return (timestampLong >= before15Mins && timestampLong <= after15Mins);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.openglar.OpenGlAugmentedRealityActivity.projectionMatrixFromCameraIntrinsics",
	"Comment": "use tango camera intrinsics to calculate the projection matrix for the opengl scene.",
	"Method": "float[] projectionMatrixFromCameraIntrinsics(TangoCameraIntrinsics intrinsics){\r\n    float cx = (float) intrinsics.cx;\r\n    float cy = (float) intrinsics.cy;\r\n    float width = (float) intrinsics.width;\r\n    float height = (float) intrinsics.height;\r\n    float fx = (float) intrinsics.fx;\r\n    float fy = (float) intrinsics.fy;\r\n    float near = 0.1f;\r\n    float far = 100;\r\n    float xScale = near / fx;\r\n    float yScale = near / fy;\r\n    float xOffset = (cx - (width / 2.0f)) * xScale;\r\n    float yOffset = -(cy - (height / 2.0f)) * yScale;\r\n    float[] m = new float[16];\r\n    Matrix.frustumM(m, 0, xScale * (float) -width / 2.0f - xOffset, xScale * (float) width / 2.0f - xOffset, yScale * (float) -height / 2.0f - yOffset, yScale * (float) height / 2.0f - yOffset, near, far);\r\n    return m;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.HeartbeatMessageParser.parseHeartbeatMessageType",
	"Comment": "reads the next bytes as the hearbeatmessagetype and writes them in themessage",
	"Method": "void parseHeartbeatMessageType(HeartbeatMessage msg){\r\n    msg.setHeartbeatMessageType(parseByteField(HeartbeatByteLength.TYPE));\r\n    LOGGER.debug(\"HeartbeatMessageType: \" + msg.getHeartbeatMessageType().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ClientHelloHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class clienthellohandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new ClientHelloMessage()) instanceof ClientHelloSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.state.TlsContext.addNegotiatedExtension",
	"Comment": "mark the given tls extension type as server negotiated extension.",
	"Method": "void addNegotiatedExtension(ExtensionType ext){\r\n    negotiatedExtensionSet.add(ext);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellodepthperception.HelloDepthPerceptionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to new point cloud data.",
	"Method": "void startupTango(){\r\n    final ArrayList<TangoCoordinateFramePair> framePairs = new ArrayList<TangoCoordinateFramePair>();\r\n    framePairs.add(new TangoCoordinateFramePair(TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_DEVICE));\r\n    mTango.connectListener(framePairs, new OnTangoUpdateListener() {\r\n        @Override\r\n        public void onPoseAvailable(final TangoPoseData pose) {\r\n        }\r\n        @Override\r\n        public void onXyzIjAvailable(TangoXyzIjData xyzIj) {\r\n        }\r\n        @Override\r\n        public void onPointCloudAvailable(final TangoPointCloudData pointCloudData) {\r\n            logPointCloud(pointCloudData);\r\n        }\r\n        @Override\r\n        public void onTangoEvent(final TangoEvent event) {\r\n        }\r\n        @Override\r\n        public void onFrameAvailable(int cameraId) {\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellodepthperception.HelloDepthPerceptionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to new point cloud data.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellodepthperception.HelloDepthPerceptionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to new point cloud data.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellodepthperception.HelloDepthPerceptionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to new point cloud data.",
	"Method": "void startupTango(){\r\n    logPointCloud(pointCloudData);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellodepthperception.HelloDepthPerceptionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to new point cloud data.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellodepthperception.HelloDepthPerceptionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to new point cloud data.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "org.togglz.core.repository.jdbc.SchemaUpdater.isSuccessful",
	"Comment": "returns true if the supplied statement returned without any error",
	"Method": "boolean isSuccessful(String sql){\r\n    Statement statement = connection.createStatement();\r\n    try {\r\n        statement.execute(substitute(sql));\r\n    } catch (SQLException e) {\r\n        return false;\r\n    } finally {\r\n        DbUtils.closeQuietly(statement);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.data.neo4j.transactions.service.BusinessService.throwsException",
	"Comment": "transactional only from service wrapper, throws checked exception",
	"Method": "void throwsException(){\r\n    insert();\r\n    throw new Exception(\"Deliberately throwing exception\");\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.DHClientKeyExchangeHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class dhclientkeyexchangehandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new DHClientKeyExchangeMessage()) instanceof DHClientKeyExchangeSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.WorkflowTraceTest.testGetMessageActions",
	"Comment": "test of getmessageactions method, of class workflowtrace.",
	"Method": "void testGetMessageActions(){\r\n    trace.addTlsAction(new SendAction());\r\n    trace.addTlsAction(new ReceiveAction());\r\n    trace.addTlsAction(new ChangeClientRandomAction());\r\n    assertTrue(trace.getMessageActions().size() == 2);\r\n    assertEquals(trace.getMessageActions().get(0), new SendAction());\r\n    assertEquals(trace.getMessageActions().get(1), new ReceiveAction());\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.eclipse.wtp.EclipseJsFormatterStepImpl.formatComments",
	"Comment": "comment formats like it would be accomplished by the jdts ui, without setting up the ui.",
	"Method": "String formatComments(String raw){\r\n    Document doc = new Document(raw);\r\n    IDocumentPartitioner commentPartitioner = new FastPartitioner(new FastJavaPartitionScanner(), COMMENT_TYPES);\r\n    doc.setDocumentPartitioner(IJavaScriptPartitions.JAVA_PARTITIONING, commentPartitioner);\r\n    commentPartitioner.connect(doc);\r\n    CommentFormattingStrategy commentFormatter = new CommentFormattingStrategy();\r\n    IFormattingContext context = new CommentFormattingContext();\r\n    context.setProperty(FormattingContextProperties.CONTEXT_PREFERENCES, options);\r\n    context.setProperty(FormattingContextProperties.CONTEXT_DOCUMENT, Boolean.TRUE);\r\n    context.setProperty(FormattingContextProperties.CONTEXT_MEDIUM, doc);\r\n    try {\r\n        ITypedRegion[] regions = TextUtilities.computePartitioning(doc, IJavaScriptPartitions.JAVA_PARTITIONING, 0, doc.getLength(), false);\r\n        MultiTextEdit resultEdit = new MultiTextEdit();\r\n        Arrays.asList(regions).stream().filter(reg -> commentTypesToBeFormatted.contains(reg.getType())).forEach(region -> {\r\n            TypedPosition typedPosition = new TypedPosition(region.getOffset(), region.getLength(), region.getType());\r\n            context.setProperty(FormattingContextProperties.CONTEXT_PARTITION, typedPosition);\r\n            commentFormatter.formatterStarts(context);\r\n            TextEdit edit = commentFormatter.calculateTextEdit();\r\n            commentFormatter.formatterStops();\r\n            if (null != edit && edit.hasChildren()) {\r\n                resultEdit.addChild(edit);\r\n            }\r\n        });\r\n        resultEdit.apply(doc);\r\n        return doc.get();\r\n    } catch (BadLocationException e) {\r\n        return raw;\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.Parser.parseBigIntField",
	"Comment": "parses a number of bytes from the array and returns them as a positivebiginteger. throws a parserexception if the number of bytes cannot beparsed. moves the pointer accordingly.",
	"Method": "BigInteger parseBigIntField(int length){\r\n    if (length == 0) {\r\n        throw new ParserException(\"Cannot parse BigInt of size 0\");\r\n    }\r\n    return new BigInteger(1, parseByteArrayField(length));\r\n}"
}, {
	"Path": "org.springframework.data.neo4j.examples.restaurants.RestaurantTests.shouldFindByNameLike",
	"Comment": "all findbypropertylike does currently is to require an exact match, ignoring case.",
	"Method": "void shouldFindByNameLike(){\r\n    Restaurant restaurant = new Restaurant(\"San Francisco International Airport (SFO)\", 68.0);\r\n    restaurantRepository.save(restaurant);\r\n    Restaurant kuroda = new Restaurant(\"Kuroda\", 72.4);\r\n    restaurantRepository.save(kuroda);\r\n    List<Restaurant> results = restaurantRepository.findByNameLike(\"*san francisco international*\");\r\n    assertNotNull(results);\r\n    assertEquals(1, results.size());\r\n    assertEquals(\"San Francisco International Airport (SFO)\", results.get(0).getName());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.DHEServerKeyExchangeSerializerTest.testSerializeHandshakeMessageContent",
	"Comment": "test of serializehandshakemessagecontent method, of classdheserverkeyexchangeserializer.",
	"Method": "void testSerializeHandshakeMessageContent(){\r\n    DHEServerKeyExchangeMessage msg = new DHEServerKeyExchangeMessage();\r\n    msg.setCompleteResultingMessage(expectedPart);\r\n    msg.setType(type.getValue());\r\n    msg.setLength(length);\r\n    msg.setModulusLength(pLength);\r\n    msg.setModulus(p);\r\n    msg.setGeneratorLength(gLength);\r\n    msg.setGenerator(g);\r\n    msg.setPublicKey(serializedKey);\r\n    msg.setPublicKeyLength(serializedKeyLength);\r\n    msg.setSignature(signature);\r\n    if (signatureAndHashAlgo != null) {\r\n        msg.setSignatureAndHashAlgorithm(signatureAndHashAlgo);\r\n    }\r\n    msg.setSignatureLength(sigLength);\r\n    DHEServerKeyExchangeSerializer serializer = new DHEServerKeyExchangeSerializer(msg, version);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.PskRsaClientKeyExchangeParser.parsePskIdentity",
	"Comment": "reads the next bytes as the pskidentity and writes them in the message",
	"Method": "void parsePskIdentity(PskRsaClientKeyExchangeMessage msg){\r\n    msg.setIdentity(parseByteArrayField(msg.getIdentityLength().getValue()));\r\n    LOGGER.debug(\"PSK-Identity: \" + ArrayConverter.bytesToHexString(msg.getIdentity().getValue()));\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPI1Test.testTessBaseAPIGetUTF8Text",
	"Comment": "test of tessbaseapigetutf8text method, of class tessapi1.",
	"Method": "void testTessBaseAPIGetUTF8Text(){\r\n    logger.info(\"TessBaseAPIGetUTF8Text\");\r\n    String expResult = expOCRResult;\r\n    File tiff = new File(this.testResourcesDataPath, \"eurotext.tif\");\r\n    BufferedImage image = ImageIO.read(new FileInputStream(tiff));\r\n    ByteBuffer buf = ImageIOHelper.convertImageData(image);\r\n    int bpp = image.getColorModel().getPixelSize();\r\n    int bytespp = bpp / 8;\r\n    int bytespl = (int) Math.ceil(image.getWidth() * bpp / 8.0);\r\n    TessAPI1.TessBaseAPIInit3(handle, datapath, language);\r\n    TessAPI1.TessBaseAPISetPageSegMode(handle, TessPageSegMode.PSM_AUTO);\r\n    TessAPI1.TessBaseAPISetImage(handle, buf, image.getWidth(), image.getHeight(), bytespp, bytespl);\r\n    TessAPI1.TessBaseAPISetRectangle(handle, 0, 0, 1024, 800);\r\n    Pointer utf8Text = TessAPI1.TessBaseAPIGetUTF8Text(handle);\r\n    String result = utf8Text.getString(0);\r\n    TessAPI1.TessDeleteText(utf8Text);\r\n    logger.info(result);\r\n    assertTrue(result.startsWith(expResult));\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.delegatesListIterator",
	"Comment": "verboselist should delegate listiterator method to decorated list.",
	"Method": "void delegatesListIterator(){\r\n    this.list.listIterator();\r\n    Mockito.verify(this.origin).listIterator();\r\n    final int index = 5;\r\n    this.list.listIterator(index);\r\n    Mockito.verify(this.origin).listIterator(index);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SrpClientKeyExchangeParser.parsePublicKeyLength",
	"Comment": "reads the next bytes as the publickeylength and writes them in themessage",
	"Method": "void parsePublicKeyLength(SrpClientKeyExchangeMessage message){\r\n    message.setPublicKeyLength(parseIntField(HandshakeByteLength.SRP_PUBLICKEY_LENGTH));\r\n    LOGGER.debug(\"PublicKeyLength: \" + message.getPublicKeyLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangePreMasterSecretActionTest.testGetNewValue",
	"Comment": "test of getnewvalue method, of class changeclientrandomaction.",
	"Method": "void testGetNewValue(){\r\n    assertArrayEquals(action.getNewValue(), new byte[] { 0, 1 });\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.DHEServerKeyExchangeHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class dheserverkeyexchangehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new DHEServerKeyExchangeMessage()) instanceof DHEServerKeyExchangePreparator);\r\n}"
}, {
	"Path": "org.springframework.statemachine.boot.actuate.InMemoryStateMachineTraceRepository.setReverse",
	"Comment": "flag to say that the repository lists traces in reverse order.",
	"Method": "void setReverse(boolean reverse){\r\n    synchronized (this.traces) {\r\n        this.reverse = reverse;\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.RSAClientKeyExchangePreparatorTest.testPrepare",
	"Comment": "test of preparehandshakemessagecontents method, of classrsaclientkeyexchangepreparator.",
	"Method": "void testPrepare(){\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA256);\r\n    context.setHighestClientProtocolVersion(ProtocolVersion.TLS12);\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS12);\r\n    context.setClientRandom(ArrayConverter.hexStringToByteArray(\"AABBCCDDEEFF\"));\r\n    context.setServerRandom(ArrayConverter.hexStringToByteArray(\"AABBCCDDEEFF\"));\r\n    preparator.prepareHandshakeMessageContents();\r\n    assertArrayEquals(ArrayConverter.concatenate(ArrayConverter.hexStringToByteArray(\"AABBCCDDEEFF\"), ArrayConverter.hexStringToByteArray(\"AABBCCDDEEFF\")), message.getComputations().getClientServerRandom().getValue());\r\n    assertNotNull(message.getComputations().getPremasterSecret().getValue());\r\n    assertEquals(HandshakeByteLength.PREMASTER_SECRET, message.getComputations().getPremasterSecret().getValue().length);\r\n    assertEquals(ProtocolVersion.TLS12.getMajor(), message.getComputations().getPremasterSecret().getValue()[0]);\r\n    assertEquals(ProtocolVersion.TLS12.getMinor(), message.getComputations().getPremasterSecret().getValue()[1]);\r\n    assertNotNull(message.getComputations().getPlainPaddedPremasterSecret().getValue());\r\n    assertEquals((byte) 0x00, message.getComputations().getPlainPaddedPremasterSecret().getValue()[0]);\r\n    assertEquals((byte) 0x02, message.getComputations().getPlainPaddedPremasterSecret().getValue()[1]);\r\n    assertEquals((byte) 0x00, message.getComputations().getPlainPaddedPremasterSecret().getValue()[message.getComputations().getPadding().getValue().length + 2]);\r\n    assertNotNull(message.getPublicKeyLength().getValue());\r\n    assertNotNull(message.getPublicKey());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.DHEServerKeyExchangeParser.parsegLength",
	"Comment": "reads the next bytes as the glength and writes them in the message",
	"Method": "void parsegLength(DHEServerKeyExchangeMessage msg){\r\n    msg.setGeneratorLength(parseIntField(HandshakeByteLength.DH_GENERATOR_LENGTH));\r\n    LOGGER.debug(\"gLength: \" + msg.getGeneratorLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.ECDHClientKeyExchangeSerializerTest.testSerializeHandshakeMessageContent",
	"Comment": "test of serializehandshakemessagecontent method, of classecdhclientkeyexchangeserializer.",
	"Method": "void testSerializeHandshakeMessageContent(){\r\n    ECDHClientKeyExchangeMessage msg = new ECDHClientKeyExchangeMessage();\r\n    msg.setLength(length);\r\n    msg.setType(type.getValue());\r\n    msg.setPublicKey(serializedKey);\r\n    msg.setPublicKeyLength(serializedKeyLength);\r\n    msg.setCompleteResultingMessage(expectedPart);\r\n    ECDHClientKeyExchangeSerializer serializer = new ECDHClientKeyExchangeSerializer(msg, version);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeServerRandomActionTest.testGetOldValue",
	"Comment": "test of getoldvalue method, of class changeclientrandomaction.",
	"Method": "void testGetOldValue(){\r\n    tlsContext.setServerRandom(new byte[] { 3 });\r\n    action.execute(state);\r\n    assertArrayEquals(action.getOldValue(), new byte[] { 3 });\r\n}"
}, {
	"Path": "com.diffplug.spotless.generic.IndentStep.create",
	"Comment": "creates a step which will indent with the given type of whitespace, converting between tabs and spaces at the given ratio.",
	"Method": "FormatterStep create(Type type,int numSpacesPerTab){\r\n    Objects.requireNonNull(type, \"type\");\r\n    return FormatterStep.create(\"indentWith\" + type.tabSpace(\"Tabs\", \"Spaces\"), new State(type, numSpacesPerTab), State::toFormatter);\r\n}"
}, {
	"Path": "org.takes.http.FtBasicTest.consumesTwiceInputStreamWithRsText",
	"Comment": "ftbasic can consume twice the input stream in case of a rstext.",
	"Method": "void consumesTwiceInputStreamWithRsText(){\r\n    final String result = \"Hello RsText!\";\r\n    new FtRemote(new TkFork(new FkRegex(FtBasicTest.ROOT_PATH, new RsText(new ByteArrayInputStream(new Utf8String(result).bytes()))))).exec(new FtRemote.Script() {\r\n        @Override\r\n        public void exec(final URI home) throws IOException {\r\n            new JdkRequest(home).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertBody(Matchers.equalTo(result));\r\n            new JdkRequest(home).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertBody(Matchers.equalTo(result));\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.takes.http.FtBasicTest.consumesTwiceInputStreamWithRsText",
	"Comment": "ftbasic can consume twice the input stream in case of a rstext.",
	"Method": "void consumesTwiceInputStreamWithRsText(){\r\n    new JdkRequest(home).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertBody(Matchers.equalTo(result));\r\n    new JdkRequest(home).fetch().as(RestResponse.class).assertStatus(HttpURLConnection.HTTP_OK).assertBody(Matchers.equalTo(result));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskRsaClientKeyExchangeHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class pskrsaclientkeyexchangehandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new PskRsaClientKeyExchangeMessage()) instanceof PskRsaClientKeyExchangeSerializer);\r\n}"
}, {
	"Path": "org.togglz.archaius.repository.DefaultReadOnlyArchaiusPropertySource.getEditor",
	"Comment": "always throws an unsupportedoperationexception as changes to the state are handled by archaiusand not by togglz.",
	"Method": "Editor getEditor(){\r\n    throw new UnsupportedOperationException(\"Updates through Togglz are not supported\");\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.CertificateDelegateTest.testGetPassword",
	"Comment": "test of getpassword method, of class certificatedelegate.",
	"Method": "void testGetPassword(){\r\n    args = new String[2];\r\n    args[0] = \"-password\";\r\n    args[1] = \"testpassword\";\r\n    jcommander.parse(args);\r\n    assertTrue(\"Password parameter gets not parsed correctly\", delegate.getPassword().equals(args[1]));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.factory.WorkflowConfigurationFactoryTest.testCreateWorkflowTrace",
	"Comment": "test of createworkflowtrace method, of classworkflowconfigurationfactory.",
	"Method": "void testCreateWorkflowTrace(){\r\n    RunningModeType mode = RunningModeType.CLIENT;\r\n    final WorkflowTrace hello0 = workflowConfigurationFactory.createWorkflowTrace(WorkflowTraceType.HELLO, mode);\r\n    final WorkflowTrace hello1 = workflowConfigurationFactory.createWorkflowTrace(WorkflowTraceType.HELLO, mode);\r\n    Assert.assertTrue(workflowTracesEqual(hello0, hello1));\r\n    final List<WorkflowTrace> list = new ArrayList(WorkflowTraceType.values().length);\r\n    for (WorkflowTraceType workflowTraceType : WorkflowTraceType.values()) {\r\n        if (workflowTraceType == WorkflowTraceType.SIMPLE_MITM_PROXY) {\r\n            mode = RunningModeType.MITM;\r\n        } else {\r\n            mode = RunningModeType.CLIENT;\r\n        }\r\n        WorkflowTrace newTrace = workflowConfigurationFactory.createWorkflowTrace(workflowTraceType, mode);\r\n        Assert.assertNotNull(newTrace.getMessageActions());\r\n        Assert.assertFalse(newTrace.getMessageActions().isEmpty());\r\n        for (MessageAction action : newTrace.getMessageActions()) {\r\n            if (action instanceof ReceiveAction) {\r\n                Assert.assertNotNull(((ReceiveAction) action).getExpectedMessages());\r\n                Assert.assertFalse(((ReceiveAction) action).getExpectedMessages().isEmpty());\r\n            } else {\r\n                Assert.assertNotNull(action.getMessages());\r\n                Assert.assertFalse(action.getMessages().isEmpty());\r\n            }\r\n        }\r\n        for (WorkflowTrace trace : list) {\r\n            if (workflowTracesEqual(trace, newTrace)) {\r\n                Assert.fail(MessageFormat.format(\"The WorkflowConfigurationFactory is expected to produce different WorkflowTraces \" + \"for each WorkflowTraceType but there is a duplicate pair: {0} {1}\", trace, newTrace));\r\n            }\r\n        }\r\n        list.add(newTrace);\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.openglar.OpenGlAugmentedRealityActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    final AlertDialog dialog = new AlertDialog.Builder(this).setMessage(\"Java OpenGL Augmented Reality Example requires camera permission\").setPositiveButton(\"Ok\", new DialogInterface.OnClickListener() {\r\n        @Override\r\n        public void onClick(DialogInterface dialogInterface, int i) {\r\n            ActivityCompat.requestPermissions(OpenGlAugmentedRealityActivity.this, new String[] { CAMERA_PERMISSION }, CAMERA_PERMISSION_CODE);\r\n        }\r\n    }).create();\r\n    dialog.show();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.openglar.OpenGlAugmentedRealityActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    ActivityCompat.requestPermissions(OpenGlAugmentedRealityActivity.this, new String[] { CAMERA_PERMISSION }, CAMERA_PERMISSION_CODE);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointcloud.PointCloudActivity.setupRenderer",
	"Comment": "sets rajawali surface view and its renderer. this is ideally called only once in oncreate.",
	"Method": "void setupRenderer(){\r\n    mSurfaceView.setEGLContextClientVersion(2);\r\n    mRenderer.getCurrentScene().registerFrameCallback(new ASceneFrameCallback() {\r\n        @Override\r\n        public void onPreFrame(long sceneTime, double deltaTime) {\r\n            synchronized (PointCloudActivity.this) {\r\n                if (!mIsConnected) {\r\n                    return;\r\n                }\r\n                TangoPointCloudData pointCloud = mPointCloudManager.getLatestPointCloud();\r\n                if (pointCloud != null) {\r\n                    TangoSupport.MatrixTransformData transform = TangoSupport.getMatrixTransformAtTime(pointCloud.timestamp, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_DEPTH, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_TANGO, TangoSupport.ROTATION_IGNORED);\r\n                    if (transform.statusCode == TangoPoseData.POSE_VALID) {\r\n                        mRenderer.updatePointCloud(pointCloud, transform.matrix);\r\n                    }\r\n                }\r\n                try {\r\n                    TangoPoseData lastFramePose = TangoSupport.getPoseAtTime(0, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_DEVICE, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                    if (lastFramePose.statusCode == TangoPoseData.POSE_VALID) {\r\n                        mRenderer.updateCameraPose(lastFramePose);\r\n                    }\r\n                } catch (TangoErrorException e) {\r\n                    Log.e(TAG, \"Could not get valid transform\");\r\n                }\r\n            }\r\n        }\r\n        @Override\r\n        public boolean callPreFrame() {\r\n            return true;\r\n        }\r\n        @Override\r\n        public void onPreDraw(long sceneTime, double deltaTime) {\r\n        }\r\n        @Override\r\n        public void onPostFrame(long sceneTime, double deltaTime) {\r\n        }\r\n    });\r\n    mSurfaceView.setSurfaceRenderer(mRenderer);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointcloud.PointCloudActivity.setupRenderer",
	"Comment": "sets rajawali surface view and its renderer. this is ideally called only once in oncreate.",
	"Method": "void setupRenderer(){\r\n    synchronized (PointCloudActivity.this) {\r\n        if (!mIsConnected) {\r\n            return;\r\n        }\r\n        TangoPointCloudData pointCloud = mPointCloudManager.getLatestPointCloud();\r\n        if (pointCloud != null) {\r\n            TangoSupport.MatrixTransformData transform = TangoSupport.getMatrixTransformAtTime(pointCloud.timestamp, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_DEPTH, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_TANGO, TangoSupport.ROTATION_IGNORED);\r\n            if (transform.statusCode == TangoPoseData.POSE_VALID) {\r\n                mRenderer.updatePointCloud(pointCloud, transform.matrix);\r\n            }\r\n        }\r\n        try {\r\n            TangoPoseData lastFramePose = TangoSupport.getPoseAtTime(0, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_DEVICE, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n            if (lastFramePose.statusCode == TangoPoseData.POSE_VALID) {\r\n                mRenderer.updateCameraPose(lastFramePose);\r\n            }\r\n        } catch (TangoErrorException e) {\r\n            Log.e(TAG, \"Could not get valid transform\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointcloud.PointCloudActivity.setupRenderer",
	"Comment": "sets rajawali surface view and its renderer. this is ideally called only once in oncreate.",
	"Method": "void setupRenderer(){\r\n    return true;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointcloud.PointCloudActivity.setupRenderer",
	"Comment": "sets rajawali surface view and its renderer. this is ideally called only once in oncreate.",
	"Method": "void setupRenderer(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointcloud.PointCloudActivity.setupRenderer",
	"Comment": "sets rajawali surface view and its renderer. this is ideally called only once in oncreate.",
	"Method": "void setupRenderer(){\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.CertificateRequestParser.parseClientCertificateTypesCount",
	"Comment": "reads the next bytes as the clientcertificatecount and writes them in themessage",
	"Method": "void parseClientCertificateTypesCount(CertificateRequestMessage msg){\r\n    msg.setClientCertificateTypesCount(parseIntField(HandshakeByteLength.CERTIFICATES_TYPES_COUNT));\r\n    LOGGER.debug(\"ClientCertificateTypesCount: \" + msg.getClientCertificateTypesCount().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ServerHelloParser.parseCipherSuitesLength",
	"Comment": "reads the next bytes as the ciphersuiteslength and writes them in themessage",
	"Method": "void parseCipherSuitesLength(SSL2ServerHelloMessage message){\r\n    message.setCipherSuitesLength(parseIntField(SSL2ByteLength.CIPHERSUITE_LENGTH));\r\n    LOGGER.debug(\"CipherSuitesLength: \" + message.getCipherSuitesLength().getValue());\r\n}"
}, {
	"Path": "org.takes.rq.RqMethodTest.failsOnSeparatorsInExtensionMethod",
	"Comment": "rqmethod can fail when http extension method name contains separatorcharacters.",
	"Method": "void failsOnSeparatorsInExtensionMethod(){\r\n    new RqMethod.Base(new RqFake(\"CUSTO{M)\")).method();\r\n}"
}, {
	"Path": "com.diffplug.gradle.spotless.GradleIntegrationTest.getContents",
	"Comment": "dumps the complete file contents of the folder to the console.",
	"Method": "String getContents(String getContents,Predicate<String> subpathsToInclude){\r\n    TreeDef<File> treeDef = TreeDef.forFile(Errors.rethrow());\r\n    List<File> files = TreeStream.depthFirst(treeDef, rootFolder()).filter(File::isFile).collect(Collectors.toList());\r\n    ListIterator<File> iterator = files.listIterator(files.size());\r\n    int rootLength = rootFolder().getAbsolutePath().length() + 1;\r\n    return StringPrinter.buildString(printer -> Errors.rethrow().run(() -> {\r\n        while (iterator.hasPrevious()) {\r\n            File file = iterator.previous();\r\n            String subPath = file.getAbsolutePath().substring(rootLength);\r\n            if (subpathsToInclude.test(subPath)) {\r\n                printer.println(\"### \" + subPath + \" ###\");\r\n                printer.println(read(subPath));\r\n            }\r\n        }\r\n    }));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskDheServerKeyExchangeHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class pskdheserverkeyexchangehandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof PskDheServerKeyExchangeParser);\r\n}"
}, {
	"Path": "org.springframework.statemachine.support.StateMachineInterceptorList.set",
	"Comment": "sets the interceptors, clears any existing interceptors.",
	"Method": "boolean set(List<StateMachineInterceptor<S, E>> interceptors){\r\n    synchronized (this.interceptors) {\r\n        this.interceptors.clear();\r\n        return this.interceptors.addAll(interceptors);\r\n    }\r\n}"
}, {
	"Path": "com.diffplug.gradle.spotless.SelfTest.runTasksManually",
	"Comment": "runs a full task manually, so you can step through all the logic.",
	"Method": "void runTasksManually(Type type){\r\n    Project project = createProject(extension -> {\r\n        extension.java(java -> {\r\n            java.target(\"**/*.java\");\r\n            java.licenseHeaderFile(\"spotless.license.java\");\r\n            java.importOrderFile(\"spotless.importorder\");\r\n            java.eclipse().configFile(\"spotless.eclipseformat.xml\");\r\n            java.trimTrailingWhitespace();\r\n            java.customLazy(\"Lambda fix\", () -> raw -> {\r\n                if (!raw.contains(\"public class SelfTest \")) {\r\n                    return raw.replace(\"} )\", \"})\").replace(\"} ,\", \"},\");\r\n                } else {\r\n                    return raw;\r\n                }\r\n            });\r\n        });\r\n        extension.format(\"misc\", misc -> {\r\n            misc.target(\"**/*.gradle\", \"**/*.md\", \"**/*.gitignore\");\r\n            misc.indentWithTabs();\r\n            misc.trimTrailingWhitespace();\r\n            misc.endWithNewline();\r\n        });\r\n    });\r\n    type.runAllTasks(project);\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPI1Test.testTessBaseAPIPrintVariablesToFile",
	"Comment": "test of tessbaseapiprintvariables method, of class tessapi1.",
	"Method": "void testTessBaseAPIPrintVariablesToFile(){\r\n    logger.info(\"TessBaseAPIPrintVariablesToFile\");\r\n    String var = \"tessedit_char_whitelist\";\r\n    String value = \"0123456789\";\r\n    TessAPI1.TessBaseAPISetVariable(handle, var, value);\r\n    String filename = \"printvar.txt\";\r\n    TessAPI1.TessBaseAPIPrintVariablesToFile(handle, filename);\r\n    File file = new File(filename);\r\n    BufferedReader input = new BufferedReader(new FileReader(file));\r\n    StringBuilder strB = new StringBuilder();\r\n    String line;\r\n    String EOL = System.getProperty(\"line.separator\");\r\n    while ((line = input.readLine()) != null) {\r\n        strB.append(line).append(EOL);\r\n    }\r\n    input.close();\r\n    file.delete();\r\n    assertTrue(strB.toString().contains(var + \"\\t\" + value));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.transport.nonblocking.ServerTCPNonBlockingTransportHandlerTest.testCloseConnectionNotInitialised",
	"Comment": "test of closeconnection method, of classservertcpnonblockingtransporthandler.",
	"Method": "void testCloseConnectionNotInitialised(){\r\n    handler.closeConnection();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SrpServerKeyExchangeParser.parseSignatureAndHashAlgorithm",
	"Comment": "reads the next bytes as the signatureandhashalgorithm and writes them inthe message",
	"Method": "void parseSignatureAndHashAlgorithm(SrpServerKeyExchangeMessage msg){\r\n    msg.setSignatureAndHashAlgorithm(parseByteArrayField(HandshakeByteLength.SIGNATURE_HASH_ALGORITHM));\r\n    LOGGER.debug(\"SignatureAndHashAlgorithm: \" + ArrayConverter.bytesToHexString(msg.getSignatureAndHashAlgorithm().getValue()));\r\n}"
}, {
	"Path": "com.projecttango.examples.java.occlusion.meshing.TangoMesher.resetSceneReconstruction",
	"Comment": "synchronize access to mtango3dreconstruction. this runs in ui thread.",
	"Method": "void resetSceneReconstruction(){\r\n    mTango3dReconstruction.clear();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.ClientHelloSerializerTest.testSerializeHandshakeMessageContent",
	"Comment": "test of serializehandshakemessagecontent method, of classclienthelloserializer.",
	"Method": "void testSerializeHandshakeMessageContent(){\r\n    ClientHelloMessage clientMessage = new ClientHelloMessage();\r\n    clientMessage.setLength(length);\r\n    clientMessage.setType(type.getValue());\r\n    clientMessage.setCipherSuiteLength(cipherSuitesLength);\r\n    clientMessage.setCipherSuites(cipherSuites);\r\n    clientMessage.setCompressionLength(compressionsLength);\r\n    clientMessage.setCompressions(compressions);\r\n    if (cookie != null) {\r\n        clientMessage.setCookie(cookie);\r\n    }\r\n    if (cookieLength != null) {\r\n        clientMessage.setCookieLength(cookieLength);\r\n    }\r\n    if (extensionBytes != null) {\r\n        clientMessage.setExtensionBytes(extensionBytes);\r\n    }\r\n    clientMessage.setExtensionsLength(extensionLength);\r\n    clientMessage.setSessionId(sessionID);\r\n    clientMessage.setSessionIdLength(sessionIdLength);\r\n    clientMessage.setCompleteResultingMessage(expectedPart);\r\n    clientMessage.setUnixTime(unixtime);\r\n    clientMessage.setRandom(random);\r\n    clientMessage.setProtocolVersion(protocolVersion);\r\n    ClientHelloSerializer serializer = new ClientHelloSerializer(clientMessage, version);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.util.GeomBuilder.ring",
	"Comment": "creates a linearring from all points on the coordinate stack, and places the resulton the geometry stack.if the first and last coordinate on the point stack are not equal an additional point will be added.",
	"Method": "GeomBuilder ring(){\r\n    Coordinate[] coords = cpopAll();\r\n    if (coords.length > 1 && !coords[0].equals(coords[coords.length - 1])) {\r\n        Coordinate[] tmp = new Coordinate[coords.length + 1];\r\n        System.arraycopy(coords, 0, tmp, 0, coords.length);\r\n        tmp[tmp.length - 1] = new Coordinate(tmp[0]);\r\n        coords = tmp;\r\n    }\r\n    gstack.push(factory.createLinearRing(coords));\r\n    return this;\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.identity.DeviceAuthentication.createDeviceTable",
	"Comment": "used to create the device table. this function only needs to be calledonce.",
	"Method": "void createDeviceTable(){\r\n    ProvisionedThroughput provisionedThroughput = new ProvisionedThroughput().withReadCapacityUnits(10L).withWriteCapacityUnits(5L);\r\n    ArrayList<AttributeDefinition> attributeDefinitions = new ArrayList<AttributeDefinition>();\r\n    attributeDefinitions.add(new AttributeDefinition().withAttributeName(ATTRIBUTE_UID).withAttributeType(\"S\"));\r\n    ArrayList<KeySchemaElement> tableKeySchema = new ArrayList<KeySchemaElement>();\r\n    tableKeySchema.add(new KeySchemaElement().withAttributeName(ATTRIBUTE_UID).withKeyType(KeyType.HASH));\r\n    CreateTableRequest createTableRequest = new CreateTableRequest().withTableName(DEVICE_TABLE).withProvisionedThroughput(provisionedThroughput).withAttributeDefinitions(attributeDefinitions).withKeySchema(tableKeySchema);\r\n    try {\r\n        ddb.createTable(createTableRequest);\r\n    } catch (AmazonClientException e) {\r\n        throw new DataAccessException(\"Failed to create table: \" + DEVICE_TABLE, e);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.HeartbeatExtensionHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class heartbeatextensionhandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new HeartbeatExtensionMessage()) instanceof HeartbeatExtensionPreparator);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.detectMarkers",
	"Comment": "detect markers from the current image buffer. the function executes thedetection algorithm in a thread, and avoids reentry by using a lock.",
	"Method": "void detectMarkers(){\r\n    if (mIsMarkerDetectionThreadRunning.compareAndSet(false, true)) {\r\n        mMarkerDetectionHandler.post(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    TangoPoseData worldTcamera = TangoSupport.getPoseAtTime(mCurrentImageBuffer.timestamp, TangoPoseData.COORDINATE_FRAME_AREA_DESCRIPTION, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_TANGO, TangoSupport.ROTATION_IGNORED);\r\n                    TangoMarkers.DetectParam param = new TangoMarkers.DetectParam();\r\n                    param.type = TangoMarkers.MARKER_ARTAG;\r\n                    param.markerSize = MARKER_SIZE;\r\n                    mMarkerList = TangoMarkers.detectMarkers(mCurrentImageBuffer, TangoCameraIntrinsics.TANGO_CAMERA_COLOR, worldTcamera.translation, worldTcamera.rotation, param);\r\n                } catch (TangoException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                mIsMarkerDetectionThreadRunning.set(false);\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.detectMarkers",
	"Comment": "detect markers from the current image buffer. the function executes thedetection algorithm in a thread, and avoids reentry by using a lock.",
	"Method": "void detectMarkers(){\r\n    try {\r\n        TangoPoseData worldTcamera = TangoSupport.getPoseAtTime(mCurrentImageBuffer.timestamp, TangoPoseData.COORDINATE_FRAME_AREA_DESCRIPTION, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_TANGO, TangoSupport.ROTATION_IGNORED);\r\n        TangoMarkers.DetectParam param = new TangoMarkers.DetectParam();\r\n        param.type = TangoMarkers.MARKER_ARTAG;\r\n        param.markerSize = MARKER_SIZE;\r\n        mMarkerList = TangoMarkers.detectMarkers(mCurrentImageBuffer, TangoCameraIntrinsics.TANGO_CAMERA_COLOR, worldTcamera.translation, worldTcamera.rotation, param);\r\n    } catch (TangoException e) {\r\n        e.printStackTrace();\r\n    }\r\n    mIsMarkerDetectionThreadRunning.set(false);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.UnknownHandshakeParser.parseData",
	"Comment": "reads the next bytes as the data and writes them in the message",
	"Method": "void parseData(UnknownHandshakeMessage msg){\r\n    msg.setData(parseByteArrayField(msg.getLength().getValue()));\r\n    LOGGER.debug(\"Data: \" + ArrayConverter.bytesToHexString(msg.getData().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.FindReceivedProtocolMessageActionTest.testExecute",
	"Comment": "test of execute method, of class findreceivedprotocolmessageaction.",
	"Method": "void testExecute(){\r\n    Config config = Config.createConfig();\r\n    config.getDefaultClientConnection().setPort(SERVER_PORT);\r\n    WorkflowConfigurationFactory factory = new WorkflowConfigurationFactory(config);\r\n    WorkflowTrace trace = factory.createWorkflowTrace(WorkflowTraceType.HELLO, RunningModeType.CLIENT);\r\n    FindReceivedProtocolMessageAction action_find_handshake = new FindReceivedProtocolMessageAction(ProtocolMessageType.HANDSHAKE);\r\n    FindReceivedProtocolMessageAction action_find_app_data = new FindReceivedProtocolMessageAction(ProtocolMessageType.APPLICATION_DATA);\r\n    trace.addTlsAction(action_find_handshake);\r\n    trace.addTlsAction(action_find_app_data);\r\n    State state = new State(config, trace);\r\n    try {\r\n        TimeHelper.setProvider(new FixedTimeProvider(0));\r\n        KeyPair k = KeyStoreGenerator.createRSAKeyPair(1024, random);\r\n        KeyStore ks = KeyStoreGenerator.createKeyStore(k, random);\r\n        BasicTlsServer tlsServer = new BasicTlsServer(ks, KeyStoreGenerator.PASSWORD, \"TLS\", SERVER_PORT);\r\n        LOGGER.info(\"Starting test server\");\r\n        new Thread(tlsServer).start();\r\n        while (!tlsServer.isInitialized()) ;\r\n        WorkflowExecutor executor = new DefaultWorkflowExecutor(state);\r\n        executor.executeWorkflow();\r\n        LOGGER.info(\"Killing server...\");\r\n        tlsServer.shutdown();\r\n        LOGGER.info(\"Done.\");\r\n    } catch (NoSuchAlgorithmException | CertificateException | IOException | InvalidKeyException | KeyStoreException | NoSuchProviderException | SignatureException | UnrecoverableKeyException | KeyManagementException ex) {\r\n        fail();\r\n    }\r\n    assertTrue(action_find_handshake.isFound());\r\n    assertFalse(action_find_app_data.isFound());\r\n}"
}, {
	"Path": "com.projecttango.rajawali.ScenePoseCalculator.toOpenGLPose",
	"Comment": "given a pose in start of service or area description frame, calculate the correspondingposition and orientation for a 3d object in the rajawali world.",
	"Method": "Pose toOpenGLPose(TangoPoseData tangoPose){\r\n    Matrix4 startServiceTDevice = tangoPoseToMatrix(tangoPose);\r\n    Matrix4 openglWorldTDevice = OPENGL_T_TANGO_WORLD.clone().multiply(startServiceTDevice);\r\n    return matrixToPose(openglWorldTDevice);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SrpServerKeyExchangeParser.parseSerializedPublicKey",
	"Comment": "reads the next bytes as the serializedpublickey and writes them in themessage",
	"Method": "void parseSerializedPublicKey(SrpServerKeyExchangeMessage msg){\r\n    msg.setPublicKey(parseByteArrayField(msg.getPublicKeyLength().getValue()));\r\n    LOGGER.debug(\"SerializedPublicKey: \" + ArrayConverter.bytesToHexString(msg.getPublicKey().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.SessionTicketTlsExtensionHandlerTest.testGetParser",
	"Comment": "tests the getparser of the sessiontickettlsextensionhandler class",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[0], 0) instanceof SessionTicketTLSExtensionParser);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.CopyServerRandomActionTest.testEquals",
	"Comment": "test of equals method, of class changeserverrandomaction.",
	"Method": "void testEquals(){\r\n    assertEquals(action, action);\r\n    assertNotEquals(action, new CopyClientRandomAction(\"server1\", \"null\"));\r\n    assertNotEquals(action, new CopyClientRandomAction(\"null\", \"server2\"));\r\n    assertNotEquals(action, new CopyClientRandomAction(\"null\", \"null\"));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.SignatureAndHashAlgorithmDelegateTest.testSetSignatureAndHashAlgorithms",
	"Comment": "test of setsignatureandhashalgorithms method, of classsignatureandhashalgorithmdelegate.",
	"Method": "void testSetSignatureAndHashAlgorithms(){\r\n    List<SignatureAndHashAlgorithm> signatureAndHashAlgoList = new LinkedList();\r\n    signatureAndHashAlgoList.add(SignatureAndHashAlgorithm.ANONYMOUS_SHA1);\r\n    delegate.setSignatureAndHashAlgorithms(signatureAndHashAlgoList);\r\n    assertTrue(delegate.getSignatureAndHashAlgorithms().contains(SignatureAndHashAlgorithm.ANONYMOUS_SHA1));\r\n}"
}, {
	"Path": "com.projecttango.examples.java.helloareadescription.AdfUuidListViewActivity.getAppSpaceAdfFolder",
	"Comment": "returns maps storage location in the app package folder. creates a folder called maps, if itdoes not exist.",
	"Method": "String getAppSpaceAdfFolder(){\r\n    String mapsFolder = Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + \"Maps\";\r\n    File file = new File(mapsFolder);\r\n    if (!file.exists()) {\r\n        file.mkdirs();\r\n    }\r\n    return mapsFolder;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ApplicationMessageParser.parseData",
	"Comment": "reads the next bytes as the data and writes them in the message",
	"Method": "void parseData(ApplicationMessage msg){\r\n    msg.setData(parseByteArrayField(getBytesLeft()));\r\n    LOGGER.debug(\"Data: \" + ArrayConverter.bytesToHexString(msg.getData().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetSessionTicketTLS",
	"Comment": "test of getsessiontickettls method, of class defaultchooser.",
	"Method": "void testGetSessionTicketTLS(){\r\n    context.setSessionTicketTLS(null);\r\n    byte[] sessionTicketTLS = ArrayConverter.hexStringToByteArray(\"122131123987891238098123\");\r\n    byte[] sessionTicketTLS2 = ArrayConverter.hexStringToByteArray(\"1221311239878912380981281294\");\r\n    config.setTlsSessionTicket(sessionTicketTLS);\r\n    assertArrayEquals(sessionTicketTLS, config.getTlsSessionTicket());\r\n    assertArrayEquals(sessionTicketTLS, chooser.getSessionTicketTLS());\r\n    context.setSessionTicketTLS(sessionTicketTLS2);\r\n    assertArrayEquals(sessionTicketTLS2, chooser.getSessionTicketTLS());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.setupRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void setupRenderer(){\r\n    mRenderer.getCurrentScene().registerFrameCallback(new ASceneFrameCallback() {\r\n        @Override\r\n        public void onPreFrame(long sceneTime, double deltaTime) {\r\n            try {\r\n                synchronized (MarkerDetectionActivity.this) {\r\n                    if (!mIsConnected) {\r\n                        return;\r\n                    }\r\n                    if (!mRenderer.isSceneCameraConfigured()) {\r\n                        TangoCameraIntrinsics intrinsics = TangoSupport.getCameraIntrinsicsBasedOnDisplayRotation(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mDisplayRotation);\r\n                        mRenderer.setProjectionMatrix(projectionMatrixFromCameraIntrinsics(intrinsics));\r\n                    }\r\n                    if (mConnectedTextureIdGlThread != mRenderer.getTextureId()) {\r\n                        mTango.connectTextureId(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mRenderer.getTextureId());\r\n                        mConnectedTextureIdGlThread = mRenderer.getTextureId();\r\n                        Log.d(TAG, \"connected to texture id: \" + mRenderer.getTextureId());\r\n                    }\r\n                    if (mIsFrameAvailableTangoThread.compareAndSet(true, false)) {\r\n                        mRgbTimestampGlThread = mTango.updateTexture(TangoCameraIntrinsics.TANGO_CAMERA_COLOR);\r\n                    }\r\n                    if (mRgbTimestampGlThread > mCameraPoseTimestamp) {\r\n                        TangoPoseData lastFramePose = TangoSupport.getPoseAtTime(mRgbTimestampGlThread, TangoPoseData.COORDINATE_FRAME_AREA_DESCRIPTION, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                        if (lastFramePose.statusCode == TangoPoseData.POSE_VALID) {\r\n                            mRenderer.updateRenderCameraPose(lastFramePose);\r\n                            mCameraPoseTimestamp = lastFramePose.timestamp;\r\n                            mRenderer.updateMarkers(mMarkerList);\r\n                        } else {\r\n                            Log.w(TAG, \"Can't get device pose at time: \" + mRgbTimestampGlThread);\r\n                        }\r\n                    }\r\n                }\r\n            } catch (TangoErrorException e) {\r\n                Log.e(TAG, \"Tango API call error within the OpenGL render thread\", e);\r\n            } catch (Throwable t) {\r\n                Log.e(TAG, \"Exception on the OpenGL thread\", t);\r\n            }\r\n        }\r\n        @Override\r\n        public void onPreDraw(long sceneTime, double deltaTime) {\r\n        }\r\n        @Override\r\n        public void onPostFrame(long sceneTime, double deltaTime) {\r\n        }\r\n        @Override\r\n        public boolean callPreFrame() {\r\n            return true;\r\n        }\r\n    });\r\n    mSurfaceView.setSurfaceRenderer(mRenderer);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.setupRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void setupRenderer(){\r\n    try {\r\n        synchronized (MarkerDetectionActivity.this) {\r\n            if (!mIsConnected) {\r\n                return;\r\n            }\r\n            if (!mRenderer.isSceneCameraConfigured()) {\r\n                TangoCameraIntrinsics intrinsics = TangoSupport.getCameraIntrinsicsBasedOnDisplayRotation(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mDisplayRotation);\r\n                mRenderer.setProjectionMatrix(projectionMatrixFromCameraIntrinsics(intrinsics));\r\n            }\r\n            if (mConnectedTextureIdGlThread != mRenderer.getTextureId()) {\r\n                mTango.connectTextureId(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mRenderer.getTextureId());\r\n                mConnectedTextureIdGlThread = mRenderer.getTextureId();\r\n                Log.d(TAG, \"connected to texture id: \" + mRenderer.getTextureId());\r\n            }\r\n            if (mIsFrameAvailableTangoThread.compareAndSet(true, false)) {\r\n                mRgbTimestampGlThread = mTango.updateTexture(TangoCameraIntrinsics.TANGO_CAMERA_COLOR);\r\n            }\r\n            if (mRgbTimestampGlThread > mCameraPoseTimestamp) {\r\n                TangoPoseData lastFramePose = TangoSupport.getPoseAtTime(mRgbTimestampGlThread, TangoPoseData.COORDINATE_FRAME_AREA_DESCRIPTION, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                if (lastFramePose.statusCode == TangoPoseData.POSE_VALID) {\r\n                    mRenderer.updateRenderCameraPose(lastFramePose);\r\n                    mCameraPoseTimestamp = lastFramePose.timestamp;\r\n                    mRenderer.updateMarkers(mMarkerList);\r\n                } else {\r\n                    Log.w(TAG, \"Can't get device pose at time: \" + mRgbTimestampGlThread);\r\n                }\r\n            }\r\n        }\r\n    } catch (TangoErrorException e) {\r\n        Log.e(TAG, \"Tango API call error within the OpenGL render thread\", e);\r\n    } catch (Throwable t) {\r\n        Log.e(TAG, \"Exception on the OpenGL thread\", t);\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.setupRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void setupRenderer(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.setupRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void setupRenderer(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.setupRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void setupRenderer(){\r\n    return true;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.WorkflowTraceTest.testGetLastMessageAction",
	"Comment": "test of getlastmessageaction method, of class workflowtrace.",
	"Method": "void testGetLastMessageAction(){\r\n    trace.addTlsAction(new SendAction());\r\n    trace.addTlsAction(new ReceiveAction());\r\n    trace.addTlsAction(new ReceiveAction());\r\n    trace.addTlsAction(new SendAction());\r\n    trace.addTlsAction(new SendAction());\r\n    trace.addTlsAction(new ReceiveAction());\r\n    trace.addTlsAction(new SendAction());\r\n    trace.addTlsAction(new ChangeCipherSuiteAction());\r\n    assertEquals(new SendAction(), trace.getLastMessageAction());\r\n    trace.addTlsAction(new ReceiveAction());\r\n    assertEquals(new ReceiveAction(), trace.getLastMessageAction());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.CopyClientRandomActionTest.testEquals",
	"Comment": "test of equals method, of class changeclientrandomaction.",
	"Method": "void testEquals(){\r\n    assertEquals(action, action);\r\n    assertNotEquals(action, new CopyClientRandomAction(\"server1\", \"null\"));\r\n    assertNotEquals(action, new CopyClientRandomAction(\"null\", \"server2\"));\r\n    assertNotEquals(action, new CopyClientRandomAction(\"null\", \"null\"));\r\n}"
}, {
	"Path": "org.springframework.statemachine.support.AbstractExpressionEvaluator.getEvaluationContext",
	"Comment": "emits a warn log if the beanfactory field is null, unless the argument is false.",
	"Method": "StandardEvaluationContext getEvaluationContext(StandardEvaluationContext getEvaluationContext,boolean beanFactoryRequired){\r\n    if (this.evaluationContext == null) {\r\n        if (this.beanFactory == null && !beanFactoryRequired) {\r\n            this.evaluationContext = ExpressionUtils.createStandardEvaluationContext();\r\n        } else {\r\n            this.evaluationContext = ExpressionUtils.createStandardEvaluationContext(this.beanFactory);\r\n        }\r\n        if (this.typeConverter != null) {\r\n            this.evaluationContext.setTypeConverter(this.typeConverter);\r\n        }\r\n    }\r\n    return this.evaluationContext;\r\n}"
}, {
	"Path": "org.sonar.java.se.JavaCheckVerifier.verifyNoIssue",
	"Comment": "verifies that the provided file will not raise any issue when analyzed with the given check.",
	"Method": "void verifyNoIssue(String filename,JavaFileScanner check){\r\n    JavaCheckVerifier javaCheckVerifier = new JavaCheckVerifier(new Expectations(true, null, null));\r\n    javaCheckVerifier.scanFile(filename, new JavaFileScanner[] { check });\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.UnknownParser.parseCompleteMessage",
	"Comment": "since we dont know what this is, we cannot make assumptions about lengthfields or the such, so we assume that all data we received in the arrayis part of this unknown message",
	"Method": "void parseCompleteMessage(UnknownMessage msg){\r\n    parseByteArrayField(getBytesLeft());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.state.TlsContext.isExtensionProposed",
	"Comment": "check if the given tls extension type was proposed by the client.",
	"Method": "boolean isExtensionProposed(ExtensionType ext){\r\n    return proposedExtensionSet.contains(ext);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.ClientAuthenticationDelegateTest.testApplyDelegate",
	"Comment": "test of applydelegate method, of class clientauthenticationdelegate.",
	"Method": "void testApplyDelegate(){\r\n    Config config = Config.createConfig();\r\n    config.setClientAuthentication(false);\r\n    args = new String[1];\r\n    args[0] = \"-client_authentication\";\r\n    jcommander.parse(args);\r\n    delegate.applyDelegate(config);\r\n    assertTrue(config.isClientAuthentication());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.CertificateDelegateTest.testGetKeystore",
	"Comment": "test of getkeystore method, of class certificatedelegate.",
	"Method": "void testGetKeystore(){\r\n    args = new String[2];\r\n    args[0] = \"-keystore\";\r\n    args[1] = \"testkeystore\";\r\n    jcommander.parse(args);\r\n    assertTrue(\"Keystore parameter gets not parsed correctly\", delegate.getKeystore().equals(args[1]));\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.delegatesAddAll",
	"Comment": "verboselist should delegate addall method to decorated list.",
	"Method": "void delegatesAddAll(){\r\n    final List<Object> collection = Collections.emptyList();\r\n    this.list.addAll(collection);\r\n    Mockito.verify(this.origin).addAll(collection);\r\n    final int index = 5;\r\n    this.list.addAll(index, collection);\r\n    Mockito.verify(this.origin).addAll(index, collection);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.CertificateRequestParser.parseDistinguishedNames",
	"Comment": "reads the next bytes as the distinguishednames and writes them in themessage",
	"Method": "void parseDistinguishedNames(CertificateRequestMessage msg){\r\n    msg.setDistinguishedNames(parseByteArrayField(msg.getDistinguishedNamesLength().getValue()));\r\n    LOGGER.debug(\"DistinguishedNames: \" + ArrayConverter.bytesToHexString(msg.getDistinguishedNames().getValue()));\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    final AlertDialog dialog = new AlertDialog.Builder(this).setMessage(\"Java Mesh Builder Example requires camera permission\").setPositiveButton(\"Ok\", new DialogInterface.OnClickListener() {\r\n        @Override\r\n        public void onClick(DialogInterface dialogInterface, int i) {\r\n            ActivityCompat.requestPermissions(MeshBuilderActivity.this, new String[] { CAMERA_PERMISSION }, CAMERA_PERMISSION_CODE);\r\n        }\r\n    }).create();\r\n    dialog.show();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    ActivityCompat.requestPermissions(MeshBuilderActivity.this, new String[] { CAMERA_PERMISSION }, CAMERA_PERMISSION_CODE);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.CertificateDelegateTest.testApplyDelegate",
	"Comment": "test of applydelegate method, of class certificatedelegate.",
	"Method": "void testApplyDelegate(){\r\n    KeyStore store = KeyStoreGenerator.createKeyStore(KeyStoreGenerator.createRSAKeyPair(1024, random), random);\r\n    File keyStoreFile = folder.newFile(\"key.store\");\r\n    store.store(new FileOutputStream(keyStoreFile), \"password\".toCharArray());\r\n    args = new String[6];\r\n    args[0] = \"-keystore\";\r\n    args[1] = keyStoreFile.getAbsolutePath();\r\n    args[2] = \"-password\";\r\n    args[3] = \"password\";\r\n    args[4] = \"-alias\";\r\n    args[5] = \"alias\";\r\n    jcommander.parse(args);\r\n    assertTrue(\"Keystore parameter gets not parsed correctly\", delegate.getKeystore().equals(args[1]));\r\n    assertTrue(\"Password parameter gets not parsed correctly\", delegate.getPassword().equals(args[3]));\r\n    assertTrue(\"Alias parameter gets not parsed correctly\", delegate.getAlias().equals(args[5]));\r\n    Config config = Config.createConfig();\r\n    config.setDefaultExplicitCertificateKeyPair(null);\r\n    delegate.applyDelegate(config);\r\n    assertNotNull(\"Ceritifcate could not be loaded\", config.getDefaultExplicitCertificateKeyPair());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    final AlertDialog dialog = new AlertDialog.Builder(this).setMessage(\"Java Marker Detection Example requires camera permission\").setPositiveButton(\"Ok\", new DialogInterface.OnClickListener() {\r\n        @Override\r\n        public void onClick(DialogInterface dialogInterface, int i) {\r\n            ActivityCompat.requestPermissions(MarkerDetectionActivity.this, new String[] { CAMERA_PERMISSION }, CAMERA_PERMISSION_CODE);\r\n        }\r\n    }).create();\r\n    dialog.show();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.showRequestPermissionRationale",
	"Comment": "if the user has declined the permission before, we have to explain that the app needs thispermission.",
	"Method": "void showRequestPermissionRationale(){\r\n    ActivityCompat.requestPermissions(MarkerDetectionActivity.this, new String[] { CAMERA_PERMISSION }, CAMERA_PERMISSION_CODE);\r\n}"
}, {
	"Path": "org.springframework.statemachine.state.AbstractState.scheduleAction",
	"Comment": "schedule action and return future which can be used to cancel it.",
	"Method": "ScheduledFuture<?> scheduleAction(Action<S, E> action,StateContext<S, E> context,AtomicInteger completionCount){\r\n    TaskScheduler taskScheduler = getTaskScheduler();\r\n    if (taskScheduler == null) {\r\n        log.error(\"Unable to schedule action as taskSchedule is not set, action=[\" + action + \"]\");\r\n        return null;\r\n    }\r\n    ScheduledFuture<?> future = taskScheduler.schedule(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            executeAction(action, context);\r\n            if (completionCount != null && completionCount.decrementAndGet() <= 0) {\r\n                notifyStateOnComplete(context);\r\n            }\r\n        }\r\n    }, new Date());\r\n    return future;\r\n}"
}, {
	"Path": "org.springframework.statemachine.state.AbstractState.scheduleAction",
	"Comment": "schedule action and return future which can be used to cancel it.",
	"Method": "ScheduledFuture<?> scheduleAction(Action<S, E> action,StateContext<S, E> context,AtomicInteger completionCount){\r\n    executeAction(action, context);\r\n    if (completionCount != null && completionCount.decrementAndGet() <= 0) {\r\n        notifyStateOnComplete(context);\r\n    }\r\n}"
}, {
	"Path": "com.example.android.trivialdrivesample.util.Inventory.hasPurchase",
	"Comment": "returns whether or not there exists a purchase of the given product.",
	"Method": "boolean hasPurchase(String sku){\r\n    return mPurchaseMap.containsKey(sku);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.transport.tcp.ServerTcpTransportHandlerTest.testCloseConnection",
	"Comment": "test of closeconnection method, of class servertcptransporthandler.",
	"Method": "void testCloseConnection(){\r\n    handler.closeConnection();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.markerdetection.MarkerDetectionActivity.setupTangoConfig",
	"Comment": "sets up the tango configuration object. make sure mtango object is initialized beforemaking this call.",
	"Method": "TangoConfig setupTangoConfig(Tango tango){\r\n    TangoConfig config = tango.getConfig(TangoConfig.CONFIG_TYPE_DEFAULT);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_COLORCAMERA, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_LOWLATENCYIMUINTEGRATION, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_DRIFT_CORRECTION, true);\r\n    return config;\r\n}"
}, {
	"Path": "com.android.vending.billing.util.Base64.decode",
	"Comment": "decodes base64 content using the supplied decodabet and returnsthe decoded byte array.",
	"Method": "byte[] decode(String s,byte[] decode,byte[] source,byte[] decode,byte[] source,int off,int len,byte[] decode,byte[] source,int off,int len,byte[] decodabet){\r\n    int len34 = len * 3 / 4;\r\n    byte[] outBuff = new byte[2 + len34];\r\n    int outBuffPosn = 0;\r\n    byte[] b4 = new byte[4];\r\n    int b4Posn = 0;\r\n    int i = 0;\r\n    byte sbiCrop = 0;\r\n    byte sbiDecode = 0;\r\n    for (i = 0; i < len; i++) {\r\n        sbiCrop = (byte) (source[i + off] & 0x7f);\r\n        sbiDecode = decodabet[sbiCrop];\r\n        if (sbiDecode >= WHITE_SPACE_ENC) {\r\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\r\n                if (sbiCrop == EQUALS_SIGN) {\r\n                    int bytesLeft = len - i;\r\n                    byte lastByte = (byte) (source[len - 1 + off] & 0x7f);\r\n                    if (b4Posn == 0 || b4Posn == 1) {\r\n                        throw new Base64DecoderException(\"invalid padding byte '=' at byte offset \" + i);\r\n                    } else if ((b4Posn == 3 && bytesLeft > 2) || (b4Posn == 4 && bytesLeft > 1)) {\r\n                        throw new Base64DecoderException(\"padding byte '=' falsely signals end of encoded value \" + \"at offset \" + i);\r\n                    } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {\r\n                        throw new Base64DecoderException(\"encoded value has invalid trailing byte\");\r\n                    }\r\n                    break;\r\n                }\r\n                b4[b4Posn++] = sbiCrop;\r\n                if (b4Posn == 4) {\r\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);\r\n                    b4Posn = 0;\r\n                }\r\n            }\r\n        } else {\r\n            throw new Base64DecoderException(\"Bad Base64 input character at \" + i + \": \" + source[i + off] + \"(decimal)\");\r\n        }\r\n    }\r\n    if (b4Posn != 0) {\r\n        if (b4Posn == 1) {\r\n            throw new Base64DecoderException(\"single trailing character at offset \" + (len - 1));\r\n        }\r\n        b4[b4Posn++] = EQUALS_SIGN;\r\n        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);\r\n    }\r\n    byte[] out = new byte[outBuffPosn];\r\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\r\n    return out;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeClientRandomActionTest.testGetOldValue",
	"Comment": "test of getoldvalue method, of class changeclientrandomaction.",
	"Method": "void testGetOldValue(){\r\n    tlsContext.setClientRandom(new byte[] { 3 });\r\n    action.execute(state);\r\n    assertArrayEquals(action.getOldValue(), new byte[] { 3 });\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.ServerNamePairParser.parseServerNameLength",
	"Comment": "reads the next bytes as the servernamelength of the extension and writesthem in the message",
	"Method": "void parseServerNameLength(ServerNamePair pair){\r\n    pair.setServerNameLength(parseIntField(ExtensionByteLength.SERVER_NAME));\r\n    LOGGER.debug(\"ServerNameLength: \" + pair.getServerNameLength().getValue());\r\n}"
}, {
	"Path": "org.togglz.core.activation.ParameterBuilder.label",
	"Comment": "a custom human readable label for the parameter. if no custom label is set, the builder will use the name of theparameter as a label.",
	"Method": "ParameterBuilder label(String name){\r\n    Validate.notNull(name, \"name is required\");\r\n    this.label = name;\r\n    return this;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.mitm.main.TlsMitmTest.checkSimpleMitmProxyWorkflow",
	"Comment": "todo this test currently just executes the workflow. for validation,write the trace to xml and compare it with a reference trace.",
	"Method": "void checkSimpleMitmProxyWorkflow(){\r\n    try {\r\n        TimeHelper.setProvider(new FixedTimeProvider(0));\r\n        KeyPair k = KeyStoreGenerator.createRSAKeyPair(1024, random);\r\n        KeyStore ks = KeyStoreGenerator.createKeyStore(k, random);\r\n        BasicTlsServer serverThread = new BasicTlsServer(ks, KeyStoreGenerator.PASSWORD, \"TLS\", SERVER_PORT);\r\n        CipherSuite cipherSuite = CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA;\r\n        LOGGER.info(\"Starting test server\");\r\n        serverThread.start();\r\n        while (!serverThread.isInitialized()) ;\r\n        String[] mitmParams = new String[6];\r\n        mitmParams[0] = \"-connect\";\r\n        mitmParams[1] = \"localhost:\" + serverThread.getPort();\r\n        mitmParams[2] = \"-accept\";\r\n        mitmParams[3] = Integer.toString(MITM_PORT);\r\n        mitmParams[4] = \"-cipher\";\r\n        mitmParams[5] = cipherSuite.name();\r\n        LOGGER.info(\"Starting mitm\");\r\n        TlsMitm mitm = new TlsMitm(mitmParams);\r\n        Thread mitmThread = new Thread(mitm);\r\n        mitmThread.start();\r\n        LOGGER.info(\"Starting test client\");\r\n        BasicTlsClient clientThread = new BasicTlsClient(\"localhost\", MITM_PORT, ProtocolVersion.TLS12, cipherSuite);\r\n        clientThread.setRetryConnect(true);\r\n        clientThread.start();\r\n        mitmThread.join();\r\n        LOGGER.info(\"Killing client\");\r\n        clientThread.interrupt();\r\n        LOGGER.info(\"Done.\");\r\n        LOGGER.info(\"Killing mitm\");\r\n        mitmThread.interrupt();\r\n        LOGGER.info(\"Done.\");\r\n        LOGGER.info(\"Killing server...\");\r\n        serverThread.shutdown();\r\n        LOGGER.info(\"Done.\");\r\n    } catch (NoSuchAlgorithmException | CertificateException | IOException | InvalidKeyException | KeyStoreException | NoSuchProviderException | SignatureException | UnrecoverableKeyException | KeyManagementException | InterruptedException | OperatorCreationException ex) {\r\n        LOGGER.warn(ex);\r\n        fail();\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.UnknownExtensionHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class unknownextensionhandler.",
	"Method": "void testAdjustTLSContext(){\r\n    UnknownExtensionMessage msg = new UnknownExtensionMessage();\r\n    handler.adjustTLSContext(msg);\r\n}"
}, {
	"Path": "studio.carbonylgroup.textfieldboxes.TextFieldBoxes.setIsResponsiveIconColor",
	"Comment": "set whether the icon signifier will change its color when gaining or losing focusas the label and the bottomline do.",
	"Method": "void setIsResponsiveIconColor(boolean isResponsiveIconColor){\r\n    this.isResponsiveIconColor = isResponsiveIconColor;\r\n    if (this.isResponsiveIconColor) {\r\n        if (this.hasFocus) {\r\n            this.iconImageButton.setColorFilter(primaryColor);\r\n            this.iconImageButton.setAlpha(1f);\r\n        } else {\r\n            this.iconImageButton.setColorFilter(secondaryColor);\r\n            this.iconImageButton.setAlpha(0.54f);\r\n        }\r\n    } else {\r\n        this.iconImageButton.setColorFilter(primaryColor);\r\n        this.iconImageButton.setAlpha(1f);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.constants.ProtocolVersionTest.testGethighestProtocolVersion",
	"Comment": "test of gethighestprotocolversion method, of class protocolversion.",
	"Method": "void testGethighestProtocolVersion(){\r\n    List<ProtocolVersion> versions = new LinkedList();\r\n    versions.add(ProtocolVersion.TLS10);\r\n    versions.add(ProtocolVersion.TLS11);\r\n    versions.add(ProtocolVersion.TLS12);\r\n    versions.add(ProtocolVersion.TLS13);\r\n    ProtocolVersion highestProtocolVersion = ProtocolVersion.getHighestProtocolVersion(versions);\r\n    assertArrayEquals(ProtocolVersion.TLS13.getValue(), highestProtocolVersion.getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.WorkflowInputDelegateTest.testSetWorkflowInput",
	"Comment": "test of setworkflowinput method, of class workflowinputdelegate.",
	"Method": "void testSetWorkflowInput(){\r\n    assertFalse(tempFile.getAbsolutePath().equals(delegate.getWorkflowInput()));\r\n    delegate.setWorkflowInput(tempFile.getAbsolutePath());\r\n    assertTrue(tempFile.getAbsolutePath().equals(delegate.getWorkflowInput()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.extension.KeyShareExtensionSerializerTest.testSerializeExtensionContent",
	"Comment": "test of serializeextensioncontent method, of classkeyshareextensionserializertest.",
	"Method": "void testSerializeExtensionContent(){\r\n    KeyShareExtensionMessage msg = new KeyShareExtensionMessage(ExtensionType.KEY_SHARE);\r\n    msg.setExtensionType(type.getValue());\r\n    msg.setExtensionLength(extensionLength);\r\n    msg.setKeyShareListBytes(keyShareList);\r\n    msg.setKeyShareListLength(keyShareListLength);\r\n    KeyShareExtensionSerializer serializer = new KeyShareExtensionSerializer(msg, ConnectionEndType.CLIENT);\r\n    assertArrayEquals(completeExtension, serializer.serialize());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.TangoMesher.setColorCameraCalibration",
	"Comment": "synchronize access to mtango3dreconstruction. this runs in ui thread.",
	"Method": "void setColorCameraCalibration(TangoCameraIntrinsics calibration){\r\n    mTango3dReconstruction.setColorCameraCalibration(calibration);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ClientHelloParser.parseChallengeLength",
	"Comment": "reads the next bytes as the challengelength and writes them in themessage",
	"Method": "void parseChallengeLength(SSL2ClientHelloMessage msg){\r\n    msg.setChallengeLength(parseIntField(SSL2ByteLength.CHALLENGE_LENGTH));\r\n    LOGGER.debug(\"ChallengeLength: \" + msg.getChallengeLength().getValue());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.TangoFloorplanner.release",
	"Comment": "synchronize access to mtango3dreconstruction. this runs in ui thread.",
	"Method": "void release(){\r\n    mIsFloorplanningActive = false;\r\n    mTango3dReconstruction.release();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ECDHEServerKeyExchangeParser.parseSignatureLength",
	"Comment": "reads the next bytes as the signaturelength and writes them in themessage",
	"Method": "void parseSignatureLength(ECDHEServerKeyExchangeMessage msg){\r\n    msg.setSignatureLength(parseIntField(HandshakeByteLength.SIGNATURE_LENGTH));\r\n    LOGGER.debug(\"SignatureLength: \" + msg.getSignatureLength().getValue());\r\n}"
}, {
	"Path": "org.springframework.cloud.consul.binder.ConsulBinderTests.launchConsumers",
	"Comment": "launch one or more consumers based on the number of consumer groups.\tblocks execution until the consumers are bound.",
	"Method": "Set<AppId> launchConsumers(String[] groups){\r\n    Set<AppId> consumers = new HashSet();\r\n    Map<String, String> appProperties = new HashMap();\r\n    int consumerCount = groups == null ? 1 : groups.length;\r\n    for (int i = 0; i < consumerCount; i++) {\r\n        int consumerPort = SocketUtils.findAvailableTcpPort();\r\n        appProperties.put(\"server.port\", String.valueOf(consumerPort));\r\n        List<String> args = new ArrayList();\r\n        args.add(String.format(\"--server.port=%d\", consumerPort));\r\n        args.add(\"--management.context-path=/\");\r\n        args.add(\"--management.security.enabled=false\");\r\n        args.add(\"--endpoints.shutdown.enabled=true\");\r\n        args.add(\"--debug\");\r\n        if (groups != null) {\r\n            args.add(String.format(\"--group=%s\", groups[i]));\r\n        }\r\n        consumers.add(new AppId(launchApplication(TestConsumer.class, appProperties, args), consumerPort));\r\n    }\r\n    for (AppId app : consumers) {\r\n        waitForConsumer(app.port);\r\n    }\r\n    return consumers;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.HeartbeatMessagePreparatorTest.testPrepare",
	"Comment": "test of prepareprotocolmessagecontents method, of classheartbeatmessagepreparator.",
	"Method": "void testPrepare(){\r\n    context.getConfig().setHeartbeatPayloadLength(11);\r\n    context.getConfig().setHeartbeatPaddingLength(11);\r\n    context.setRandom(new FixedSecureRandom(ArrayConverter.hexStringToByteArray(\"F6C92DA33AF01D4FB770AA60B420BB3851D9D47ACB93\")));\r\n    preparator.prepare();\r\n    assertTrue(HeartbeatMessageType.HEARTBEAT_REQUEST.getValue() == message.getHeartbeatMessageType().getValue());\r\n    LOGGER.info(\"padding: \" + ArrayConverter.bytesToHexString(message.getPadding().getValue()));\r\n    LOGGER.info(\"payload: \" + ArrayConverter.bytesToHexString(message.getPayload().getValue()));\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"60B420BB3851D9D47ACB93\"), message.getPadding().getValue());\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"F6C92DA33AF01D4FB770AA\"), message.getPayload().getValue());\r\n    assertTrue(11 == message.getPayloadLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.DHEServerKeyExchangeParser.parseSignature",
	"Comment": "reads the next bytes as the signature and writes them in the message",
	"Method": "void parseSignature(DHEServerKeyExchangeMessage msg){\r\n    msg.setSignature(parseByteArrayField(msg.getSignatureLength().getValue()));\r\n    LOGGER.debug(\"Signature: \" + ArrayConverter.bytesToHexString(msg.getSignature().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.PskEcDheServerKeyExchangeParser.parsePskIdentityHint",
	"Comment": "reads the next bytes as the pskidentityhint and writes them in themessage",
	"Method": "void parsePskIdentityHint(PskEcDheServerKeyExchangeMessage msg){\r\n    msg.setIdentityHint(parseByteArrayField(msg.getIdentityHintLength().getValue()));\r\n    LOGGER.debug(\"SerializedPSK-Identity: \" + ArrayConverter.bytesToHexString(msg.getIdentityHint().getValue()));\r\n}"
}, {
	"Path": "com.example.android.trivialdrivesample.util.Inventory.getPurchase",
	"Comment": "returns purchase information for a given product, or null if there is no purchase.",
	"Method": "Purchase getPurchase(String sku){\r\n    return mPurchaseMap.get(sku);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskDhClientKeyExchangeHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class pskdhclientkeyexchangehandler.",
	"Method": "void testAdjustTLSContext(){\r\n    PskDhClientKeyExchangeMessage message = new PskDhClientKeyExchangeMessage();\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_DHE_PSK_WITH_AES_128_CBC_SHA);\r\n    message.prepareComputations();\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS12);\r\n    context.setRecordLayer(new TlsRecordLayer(context));\r\n    message.getComputations().setPremasterSecret(ArrayConverter.hexStringToByteArray(\"0303d3fad5b20109834717bac4e7762e217add183d0c4852ab054f65ba6e93b1ed83ca5c5fa614cd3b810f4766c66feb\"));\r\n    message.getComputations().setClientServerRandom(ArrayConverter.hexStringToByteArray(\"a449532975d478abeefcfafa7522b9312bdbd0bb294fe460c4d52bab13a425b7594d0e9508874a67db6d9b8e91db4f38600e88f006bbe58f2b41deb6811c74cc\"));\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_DHE_PSK_WITH_AES_128_CBC_SHA);\r\n    handler.adjustTLSContext(message);\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"0303d3fad5b20109834717bac4e7762e217add183d0c4852ab054f65ba6e93b1ed83ca5c5fa614cd3b810f4766c66feb\"), context.getPreMasterSecret());\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"FA1D499E795E936751AD43355C26857728E78ABE1C4BCAFA6EF3C90F6D9B9E49DF1ADE262F127EB2A23BB73E142EE122\"), context.getMasterSecret());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.augmentedreality.AugmentedRealityActivity.setupRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void setupRenderer(){\r\n    mRenderer.getCurrentScene().registerFrameCallback(new ASceneFrameCallback() {\r\n        @Override\r\n        public void onPreFrame(long sceneTime, double deltaTime) {\r\n            try {\r\n                synchronized (AugmentedRealityActivity.this) {\r\n                    if (!mIsConnected) {\r\n                        return;\r\n                    }\r\n                    if (!mRenderer.isSceneCameraConfigured()) {\r\n                        TangoCameraIntrinsics intrinsics = TangoSupport.getCameraIntrinsicsBasedOnDisplayRotation(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mDisplayRotation);\r\n                        mRenderer.setProjectionMatrix(projectionMatrixFromCameraIntrinsics(intrinsics));\r\n                    }\r\n                    if (mConnectedTextureIdGlThread != mRenderer.getTextureId()) {\r\n                        mTango.connectTextureId(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mRenderer.getTextureId());\r\n                        mConnectedTextureIdGlThread = mRenderer.getTextureId();\r\n                        Log.d(TAG, \"connected to texture id: \" + mRenderer.getTextureId());\r\n                    }\r\n                    if (mIsFrameAvailableTangoThread.compareAndSet(true, false)) {\r\n                        mRgbTimestampGlThread = mTango.updateTexture(TangoCameraIntrinsics.TANGO_CAMERA_COLOR);\r\n                    }\r\n                    if (mRgbTimestampGlThread > mCameraPoseTimestamp) {\r\n                        TangoPoseData lastFramePose = TangoSupport.getPoseAtTime(mRgbTimestampGlThread, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                        if (lastFramePose.statusCode == TangoPoseData.POSE_VALID) {\r\n                            mRenderer.updateRenderCameraPose(lastFramePose);\r\n                            mCameraPoseTimestamp = lastFramePose.timestamp;\r\n                        } else {\r\n                            Log.w(TAG, \"Can't get device pose at time: \" + mRgbTimestampGlThread);\r\n                        }\r\n                    }\r\n                }\r\n            } catch (TangoErrorException e) {\r\n                Log.e(TAG, \"Tango API call error within the OpenGL render thread\", e);\r\n            } catch (Throwable t) {\r\n                Log.e(TAG, \"Exception on the OpenGL thread\", t);\r\n            }\r\n        }\r\n        @Override\r\n        public void onPreDraw(long sceneTime, double deltaTime) {\r\n        }\r\n        @Override\r\n        public void onPostFrame(long sceneTime, double deltaTime) {\r\n        }\r\n        @Override\r\n        public boolean callPreFrame() {\r\n            return true;\r\n        }\r\n    });\r\n    mSurfaceView.setSurfaceRenderer(mRenderer);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.augmentedreality.AugmentedRealityActivity.setupRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void setupRenderer(){\r\n    try {\r\n        synchronized (AugmentedRealityActivity.this) {\r\n            if (!mIsConnected) {\r\n                return;\r\n            }\r\n            if (!mRenderer.isSceneCameraConfigured()) {\r\n                TangoCameraIntrinsics intrinsics = TangoSupport.getCameraIntrinsicsBasedOnDisplayRotation(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mDisplayRotation);\r\n                mRenderer.setProjectionMatrix(projectionMatrixFromCameraIntrinsics(intrinsics));\r\n            }\r\n            if (mConnectedTextureIdGlThread != mRenderer.getTextureId()) {\r\n                mTango.connectTextureId(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mRenderer.getTextureId());\r\n                mConnectedTextureIdGlThread = mRenderer.getTextureId();\r\n                Log.d(TAG, \"connected to texture id: \" + mRenderer.getTextureId());\r\n            }\r\n            if (mIsFrameAvailableTangoThread.compareAndSet(true, false)) {\r\n                mRgbTimestampGlThread = mTango.updateTexture(TangoCameraIntrinsics.TANGO_CAMERA_COLOR);\r\n            }\r\n            if (mRgbTimestampGlThread > mCameraPoseTimestamp) {\r\n                TangoPoseData lastFramePose = TangoSupport.getPoseAtTime(mRgbTimestampGlThread, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                if (lastFramePose.statusCode == TangoPoseData.POSE_VALID) {\r\n                    mRenderer.updateRenderCameraPose(lastFramePose);\r\n                    mCameraPoseTimestamp = lastFramePose.timestamp;\r\n                } else {\r\n                    Log.w(TAG, \"Can't get device pose at time: \" + mRgbTimestampGlThread);\r\n                }\r\n            }\r\n        }\r\n    } catch (TangoErrorException e) {\r\n        Log.e(TAG, \"Tango API call error within the OpenGL render thread\", e);\r\n    } catch (Throwable t) {\r\n        Log.e(TAG, \"Exception on the OpenGL thread\", t);\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.augmentedreality.AugmentedRealityActivity.setupRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void setupRenderer(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.augmentedreality.AugmentedRealityActivity.setupRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void setupRenderer(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.augmentedreality.AugmentedRealityActivity.setupRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void setupRenderer(){\r\n    return true;\r\n}"
}, {
	"Path": "com.projecttango.rajawali.ScenePoseCalculator.planeFitToTangoWorldPose",
	"Comment": "given a point and a normal in depth camera frame and the device pose in start of serviceframe at the time the point and normal were acquired, calculate a pose object whichrepresents the position and orientation of the fitted plane with its y vector pointingup in the gravity vector, represented in the tango start of service frame.",
	"Method": "TangoPoseData planeFitToTangoWorldPose(double[] point,double[] normal,TangoPoseData tangoPose,DeviceExtrinsics extrinsics){\r\n    Matrix4 startServiceTdevice = tangoPoseToMatrix(tangoPose);\r\n    Vector3 depthUp = TANGO_WORLD_UP.clone();\r\n    startServiceTdevice.clone().multiply(extrinsics.getDeviceTDepthCamera()).inverse().rotateVector(depthUp);\r\n    Matrix4 depthTplane = matrixFromPointNormalUp(point, normal, depthUp);\r\n    Matrix4 tangoWorldTplane = startServiceTdevice.multiply(extrinsics.getDeviceTDepthCamera()).multiply(depthTplane);\r\n    return matrixToTangoPose(tangoWorldTplane);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.FinishedPreparatorTest.testPrepare",
	"Comment": "test of preparehandshakemessagecontents method, of classfinishedpreparator.",
	"Method": "void testPrepare(){\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA);\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS12);\r\n    context.setMasterSecret(ArrayConverter.hexStringToByteArray(\"AABBCCDDEEFF\"));\r\n    context.setPrfAlgorithm(PRFAlgorithm.TLS_PRF_SHA256);\r\n    preparator.prepare();\r\n    LOGGER.info(ArrayConverter.bytesToHexString(message.getVerifyData().getValue(), false));\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"232A2CCB976E313AAA8E0F7A\"), message.getVerifyData().getValue());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.openglar.OpenGlAugmentedRealityRenderer.updateViewMatrix",
	"Comment": "update the view matrix matching the pose of the tango rgb camera.",
	"Method": "void updateViewMatrix(float[] ssTcamera){\r\n    float[] viewMatrix = new float[16];\r\n    Matrix.invertM(viewMatrix, 0, ssTcamera, 0);\r\n    mEarthSphere.setViewMatrix(viewMatrix);\r\n    mMoonSphere.setViewMatrix(viewMatrix);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.occlusion.OcclusionActivity.doFitPlane",
	"Comment": "use the tango support library with point cloud data to calculate the planeof the world feature pointed at the location the camera is looking.it returns the transform of the fitted plane in a double array.",
	"Method": "float[] doFitPlane(float u,float v,double rgbTimestamp){\r\n    TangoPointCloudData pointCloud = mPointCloudManager.getLatestPointCloud();\r\n    if (pointCloud == null) {\r\n        return null;\r\n    }\r\n    TangoPoseData openglTdepthPose = TangoSupport.getPoseAtTime(pointCloud.timestamp, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_DEPTH, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_TANGO, TangoSupport.ROTATION_IGNORED);\r\n    if (openglTdepthPose.statusCode != TangoPoseData.POSE_VALID) {\r\n        Log.w(TAG, \"Cant get openglTdepth pose at time \" + pointCloud.timestamp);\r\n        return null;\r\n    }\r\n    TangoPoseData openglTcolorPose = TangoSupport.getPoseAtTime(rgbTimestamp, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_TANGO, TangoSupport.ROTATION_IGNORED);\r\n    if (openglTcolorPose.statusCode != TangoPoseData.POSE_VALID) {\r\n        Log.w(TAG, \"Cannot get openglTcolor pose at time \" + rgbTimestamp);\r\n        return null;\r\n    }\r\n    TangoSupport.IntersectionPointPlaneModelPair pointPlaneModel = TangoSupport.fitPlaneModelNearPoint(pointCloud, openglTdepthPose.translation, openglTdepthPose.rotation, u, v, mDisplayRotation, openglTcolorPose.translation, openglTcolorPose.rotation);\r\n    float[] openglUp = new float[] { 0, 1, 0, 0 };\r\n    float[] openglTplane = matrixFromPointNormalUp(pointPlaneModel.intersectionPoint, pointPlaneModel.planeModel, openglUp);\r\n    return openglTplane;\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.delegatesIndexOf",
	"Comment": "verboselist should delegate indexof method to decorated list.",
	"Method": "void delegatesIndexOf(){\r\n    final Object obj = new Object();\r\n    this.list.indexOf(obj);\r\n    Mockito.verify(this.origin).indexOf(obj);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.extension.SessionTicketTLSExtensionSerializerTest.generateData",
	"Comment": "gets the test vectors of the sessiontickettlsextensionhandlertest class.",
	"Method": "Collection<Object[]> generateData(){\r\n    return SessionTicketTLSExtensionParserTest.generateData();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.UnknownExtensionHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class unknownextensionhandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[] { 0, 1, 2, 3, 4 }, 0) instanceof UnknownExtensionParser);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ServerHelloHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class serverhellohandler.",
	"Method": "void testAdjustTLSContext(){\r\n    ServerHelloMessage message = new ServerHelloMessage();\r\n    message.setUnixTime(new byte[] { 0, 1, 2 });\r\n    message.setRandom(new byte[] { 0, 1, 2, 3, 4, 5 });\r\n    message.setSelectedCompressionMethod(CompressionMethod.DEFLATE.getValue());\r\n    message.setSelectedCipherSuite(CipherSuite.TLS_CECPQ1_ECDSA_WITH_AES_256_GCM_SHA384.getByteValue());\r\n    message.setSessionId(new byte[] { 6, 6, 6 });\r\n    message.setProtocolVersion(ProtocolVersion.TLS12.getValue());\r\n    handler.adjustTLSContext(message);\r\n    assertArrayEquals(context.getServerRandom(), new byte[] { 0, 1, 2, 3, 4, 5 });\r\n    assertTrue(context.getSelectedCompressionMethod() == CompressionMethod.DEFLATE);\r\n    assertArrayEquals(context.getServerSessionId(), new byte[] { 6, 6, 6 });\r\n    assertArrayEquals(context.getSelectedCipherSuite().getByteValue(), CipherSuite.TLS_CECPQ1_ECDSA_WITH_AES_256_GCM_SHA384.getByteValue());\r\n    assertArrayEquals(context.getSelectedProtocolVersion().getValue(), ProtocolVersion.TLS12.getValue());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.greenscreen.GreenScreenActivity.setDisplayRotation",
	"Comment": "set the color camera background texture rotation and save the camera to display rotation.",
	"Method": "void setDisplayRotation(){\r\n    Display display = getWindowManager().getDefaultDisplay();\r\n    mDisplayRotation = display.getRotation();\r\n    mSurfaceView.queueEvent(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            if (mIsConnected) {\r\n                mRenderer.updateColorCameraTextureUv(mDisplayRotation);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.greenscreen.GreenScreenActivity.setDisplayRotation",
	"Comment": "set the color camera background texture rotation and save the camera to display rotation.",
	"Method": "void setDisplayRotation(){\r\n    if (mIsConnected) {\r\n        mRenderer.updateColorCameraTextureUv(mDisplayRotation);\r\n    }\r\n}"
}, {
	"Path": "com.diffplug.gradle.spotless.SpotlessExtension.removeFormat",
	"Comment": "makes it possible to remove a format which was created earlier.",
	"Method": "void removeFormat(String name){\r\n    requireNonNull(name);\r\n    FormatExtension toRemove = formats.remove(name);\r\n    if (toRemove == null) {\r\n        project.getLogger().warn(\"Called removeFormat('\" + name + \"') but there was no such format.\");\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ClientHelloParser.parseCompressionLength",
	"Comment": "reads the next bytes as the compressionlength and writes them in themessage",
	"Method": "void parseCompressionLength(ClientHelloMessage message){\r\n    message.setCompressionLength(parseIntField(HandshakeByteLength.COMPRESSION_LENGTH));\r\n    LOGGER.debug(\"CompressionLength: \" + message.getCompressionLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.ECDHEServerKeyExchangeParser.parseCurveType",
	"Comment": "reads the next bytes as the curvetype and writes them in the message",
	"Method": "void parseCurveType(ECDHEServerKeyExchangeMessage msg){\r\n    msg.setCurveType(parseByteField(HandshakeByteLength.ELLIPTIC_CURVE));\r\n    LOGGER.debug(\"CurveType: \" + msg.getGroupType().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.SupportedVersionsExtensionParser.parseSupportedVersionLength",
	"Comment": "reads the next bytes as the supportedversionlength of the extension andwrites them in the message",
	"Method": "void parseSupportedVersionLength(SupportedVersionsExtensionMessage msg){\r\n    msg.setSupportedVersionsLength(parseIntField(ExtensionByteLength.SUPPORTED_PROTOCOL_VERSIONS_LENGTH));\r\n    LOGGER.debug(\"SupportedVersionsLength: \" + msg.getSupportedVersionsLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.PskDheServerKeyExchangeMessageTest.testToString",
	"Comment": "test of tostring method, of class pskdheserverkeyexchangemessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"PskDheServerKeyExchangeMessage:\");\r\n    sb.append(\"\\n  Modulus p: \").append(\"null\");\r\n    sb.append(\"\\n  Generator g: \").append(\"null\");\r\n    sb.append(\"\\n  Public Key: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "com.novoda.spikes.arcore.google.rendering.PointCloudRenderer.draw",
	"Comment": "renders the point cloud. arcore point cloud is given in world space.",
	"Method": "void draw(float[] cameraView,float[] cameraPerspective){\r\n    float[] modelViewProjection = new float[16];\r\n    Matrix.multiplyMM(modelViewProjection, 0, cameraPerspective, 0, cameraView, 0);\r\n    ShaderUtil.checkGLError(TAG, \"Before draw\");\r\n    GLES20.glUseProgram(programName);\r\n    GLES20.glEnableVertexAttribArray(positionAttribute);\r\n    GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, vbo);\r\n    GLES20.glVertexAttribPointer(positionAttribute, 4, GLES20.GL_FLOAT, false, BYTES_PER_POINT, 0);\r\n    GLES20.glUniform4f(colorUniform, 31.0f / 255.0f, 188.0f / 255.0f, 210.0f / 255.0f, 1.0f);\r\n    GLES20.glUniformMatrix4fv(modelViewProjectionUniform, 1, false, modelViewProjection, 0);\r\n    GLES20.glUniform1f(pointSizeUniform, 5.0f);\r\n    GLES20.glDrawArrays(GLES20.GL_POINTS, 0, numPoints);\r\n    GLES20.glDisableVertexAttribArray(positionAttribute);\r\n    GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0);\r\n    ShaderUtil.checkGLError(TAG, \"Draw\");\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetSelectedProtocolVersion",
	"Comment": "test of getselectedprotocolversion method, of class defaultchooser.",
	"Method": "void testGetSelectedProtocolVersion(){\r\n    context.setSelectedProtocolVersion(null);\r\n    config.setDefaultSelectedProtocolVersion(ProtocolVersion.TLS13_DRAFT20);\r\n    assertEquals(ProtocolVersion.TLS13_DRAFT20, config.getDefaultSelectedProtocolVersion());\r\n    assertEquals(ProtocolVersion.TLS13_DRAFT20, chooser.getSelectedProtocolVersion());\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS12);\r\n    assertEquals(ProtocolVersion.TLS12, chooser.getSelectedProtocolVersion());\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.wrapsIndexOutOfBoundsExceptionFromAddAll",
	"Comment": "verboselist should wraps outofboundsexception thrown by addall method.",
	"Method": "void wrapsIndexOutOfBoundsExceptionFromAddAll(){\r\n    final int index = 5;\r\n    final List<Object> collection = Collections.emptyList();\r\n    final Exception cause = new IndexOutOfBoundsException();\r\n    Mockito.doThrow(cause).when(this.origin).addAll(index, collection);\r\n    this.thrown.expect(IndexOutOfBoundsException.class);\r\n    this.thrown.expectMessage(VerboseListTest.MSG);\r\n    this.thrown.expectCause(Matchers.is(cause));\r\n    this.list.addAll(index, collection);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.HandshakeMessageParser.parseLength",
	"Comment": "reads the next bytes as the messagelength and writes them in the message",
	"Method": "void parseLength(HandshakeMessage message){\r\n    message.setLength(parseIntField(HandshakeByteLength.MESSAGE_LENGTH_FIELD));\r\n    LOGGER.debug(\"Length:\" + message.getLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.socket.TlsAttackerSocketTest.testReceiveRawBytes",
	"Comment": "test of recieverawbytes method, of class tlsattackersocket.",
	"Method": "void testReceiveRawBytes(){\r\n    transportHandler.setFetchableByte(new byte[] { 1, 2, 3 });\r\n    byte[] received = socket.receiveRawBytes();\r\n    assertArrayEquals(new byte[] { 1, 2, 3 }, received);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.HRRKeyShareExtensionParserTest.testParseExtensionMessageContent",
	"Comment": "test of parseextensionmessagecontent method, of classhrrkeyshareextensionparser.",
	"Method": "void testParseExtensionMessageContent(){\r\n    HRRKeyShareExtensionParser parser = new HRRKeyShareExtensionParser(start, extension);\r\n    HRRKeyShareExtensionMessage msg = parser.parse();\r\n    assertArrayEquals(msg.getExtensionBytes().getValue(), completeExtension);\r\n    assertArrayEquals(type.getValue(), msg.getExtensionType().getValue());\r\n    assertTrue(extensionLength == msg.getExtensionLength().getValue());\r\n    assertArrayEquals(msg.getSelectedGroup().getValue(), selectedGroup);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.tokenbinding.TokenbindingMessagePreparatorTest.testPrepareProtocolMessageContents",
	"Comment": "test of prepareprotocolmessagecontents method, of classtokenbindingmessagepreparator.",
	"Method": "void testPrepareProtocolMessageContents(){\r\n    preparator.prepare();\r\n    Serializer serializer = new TokenBindingMessageSerializer(message, ProtocolVersion.TLS12);\r\n    byte[] serialize = serializer.serialize();\r\n    TokenBindingMessageParser selfParser = new TokenBindingMessageParser(0, serialize, ProtocolVersion.TLS12);\r\n    TokenBindingMessage selfParsed = selfParser.parse();\r\n    assertNotNull(selfParsed);\r\n    String base64 = \"AIkAAgBBQM9eQES_uxoyRn0DDoYLcWqvm6Oo3p0lI1s3fRjdIj6dw8wLDf0RWkxuyNAmgAQkUWxm8_JfwS8MziBYVuJ5ECcAQHF_HGcPiSv_X60y5Ql-AxoqaWzwqXvpStEBgY_IX8kT_qAHsb5h38ZuQoWOaZVgqlF1sa70B4GVXxmi2JkdJYcAAA\";\r\n    byte[] decode = Base64.getUrlDecoder().decode(base64);\r\n    TokenBindingMessageParser parser = new TokenBindingMessageParser(0, decode, ProtocolVersion.TLS12);\r\n    TokenBindingMessage parsedMessage = parser.parse();\r\n    byte[] xBytes = new byte[32];\r\n    System.arraycopy(parsedMessage.getPoint().getValue(), 0, xBytes, 0, 32);\r\n    LOGGER.debug(\"X:\" + ArrayConverter.bytesToHexString(xBytes));\r\n    byte[] yBytes = new byte[32];\r\n    System.arraycopy(parsedMessage.getPoint().getValue(), 32, yBytes, 0, 32);\r\n    LOGGER.debug(\"Y:\" + ArrayConverter.bytesToHexString(yBytes));\r\n    BigInteger intX = new BigInteger(xBytes);\r\n    LOGGER.debug(\"intx: \" + intX);\r\n    ASN1Integer x = new ASN1Integer(xBytes);\r\n    LOGGER.debug(\"xasn1:\" + x.getPositiveValue());\r\n    ASN1Integer y = new ASN1Integer(yBytes);\r\n    ECDomainParameters generateEcParameters = generateEcParameters();\r\n    ECPublicKeyParameters ecPublicKeyParameters = new ECPublicKeyParameters(generateEcParameters.getCurve().createPoint(x.getPositiveValue(), y.getPositiveValue()), generateEcParameters);\r\n    LOGGER.debug(\"RAW X:\" + ecPublicKeyParameters.getQ().getRawXCoord().toBigInteger());\r\n    LOGGER.debug(\"RAW Y:\" + ecPublicKeyParameters.getQ().getRawYCoord().toBigInteger());\r\n    LOGGER.debug(\"Valid: \" + ecPublicKeyParameters.getQ().isValid());\r\n    ECDSASigner signer = new ECDSASigner();\r\n    signer.init(false, ecPublicKeyParameters);\r\n    byte[] signedContent = // Correct\r\n    ArrayConverter.hexStringToByteArray(\"0002A5F86D4EA32D7B305774F6EA56DB444F4D70D777ABF77B810561935F3A96B9C2\");\r\n    byte[] rBytes = new byte[32];\r\n    System.arraycopy(parsedMessage.getSignature().getValue(), 0, rBytes, 0, 32);\r\n    byte[] sBytes = new byte[32];\r\n    System.arraycopy(parsedMessage.getSignature().getValue(), 32, sBytes, 0, 32);\r\n    LOGGER.debug(\"r:\" + ArrayConverter.bytesToHexString(rBytes));\r\n    LOGGER.debug(\"s:\" + ArrayConverter.bytesToHexString(sBytes));\r\n    LOGGER.debug(\"r:\" + new ASN1Integer(rBytes).getPositiveValue());\r\n    LOGGER.debug(\"s:\" + new ASN1Integer(sBytes).getPositiveValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.SignedCertificateTimestampExtensionParser.createExtensionMessage",
	"Comment": "creates a new signedcertificatetimestampextensionmessage",
	"Method": "SignedCertificateTimestampExtensionMessage createExtensionMessage(){\r\n    return new SignedCertificateTimestampExtensionMessage();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.ProtocolVersionDelegateTest.testSetProtocolVersion",
	"Comment": "test of setprotocolversion method, of class protocolversiondelegate.",
	"Method": "void testSetProtocolVersion(){\r\n    delegate.setProtocolVersion(null);\r\n    assertFalse(delegate.getProtocolVersion() == ProtocolVersion.TLS12);\r\n    delegate.setProtocolVersion(ProtocolVersion.TLS12);\r\n    assertTrue(delegate.getProtocolVersion() == ProtocolVersion.TLS12);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.PskEcDheServerKeyExchangeMessageTest.testToString",
	"Comment": "test of tostring method, of class pskecdheserverkeyexchangemessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"PskEcDheServerKeyExchangeMessage:\");\r\n    sb.append(\"\\n  Curve Type: \").append(\"null\");\r\n    sb.append(\"\\n  Named Group: \").append(\"null\");\r\n    sb.append(\"\\n  Public Key: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.AlertSerializerTest.testSerializeProtocolMessageContent",
	"Comment": "test of serializeprotocolmessagecontent method, of class alertserializer.",
	"Method": "void testSerializeProtocolMessageContent(){\r\n    AlertMessage message = new AlertMessage();\r\n    message.setLevel(level);\r\n    message.setDescription(description);\r\n    message.setCompleteResultingMessage(expectedPart);\r\n    AlertSerializer serializer = new AlertSerializer(message, ProtocolVersion.TLS12);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderActivity.checkTangoVersion",
	"Comment": "check the minimum tango core version needed by the java 3d reconstruction library.",
	"Method": "void checkTangoVersion(){\r\n    try {\r\n        PackageInfo packageInfo = getPackageManager().getPackageInfo(TANGO_PACKAGE_NAME, 0);\r\n        int version = Integer.parseInt(Integer.toString(packageInfo.versionCode).substring(2));\r\n        if (version < MIN_TANGO_VERSION) {\r\n            throw new TangoOutOfDateException();\r\n        }\r\n    } catch (PackageManager.NameNotFoundException e) {\r\n        Log.d(TAG, \"Tango package could not be found\");\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.setupTangoConfig",
	"Comment": "sets up the tango configuration object. make sure mtango object is initialized beforemaking this call.",
	"Method": "TangoConfig setupTangoConfig(Tango tango){\r\n    TangoConfig config = tango.getConfig(TangoConfig.CONFIG_TYPE_DEFAULT);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_LOWLATENCYIMUINTEGRATION, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_COLORCAMERA, true);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_DEPTH, true);\r\n    config.putInt(TangoConfig.KEY_INT_DEPTH_MODE, TangoConfig.TANGO_DEPTH_MODE_POINT_CLOUD);\r\n    config.putBoolean(TangoConfig.KEY_BOOLEAN_DRIFT_CORRECTION, true);\r\n    return config;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.crypto.ec.Curve25519.mul",
	"Comment": "multiply two numbers. the output is in reduced form, the inputs need notbe.",
	"Method": "long10 mul(long10 xy,long10 x,long10 y){\r\n    long x_0 = x._0, x_1 = x._1, x_2 = x._2, x_3 = x._3, x_4 = x._4, x_5 = x._5, x_6 = x._6, x_7 = x._7, x_8 = x._8, x_9 = x._9;\r\n    long y_0 = y._0, y_1 = y._1, y_2 = y._2, y_3 = y._3, y_4 = y._4, y_5 = y._5, y_6 = y._6, y_7 = y._7, y_8 = y._8, y_9 = y._9;\r\n    long t;\r\n    t = (x_0 * y_8) + (x_2 * y_6) + (x_4 * y_4) + (x_6 * y_2) + (x_8 * y_0) + 2 * ((x_1 * y_7) + (x_3 * y_5) + (x_5 * y_3) + (x_7 * y_1)) + 38 * (x_9 * y_9);\r\n    xy._8 = (t & ((1 << 26) - 1));\r\n    t = (t >> 26) + (x_0 * y_9) + (x_1 * y_8) + (x_2 * y_7) + (x_3 * y_6) + (x_4 * y_5) + (x_5 * y_4) + (x_6 * y_3) + (x_7 * y_2) + (x_8 * y_1) + (x_9 * y_0);\r\n    xy._9 = (t & ((1 << 25) - 1));\r\n    t = (x_0 * y_0) + 19 * ((t >> 25) + (x_2 * y_8) + (x_4 * y_6) + (x_6 * y_4) + (x_8 * y_2)) + 38 * ((x_1 * y_9) + (x_3 * y_7) + (x_5 * y_5) + (x_7 * y_3) + (x_9 * y_1));\r\n    xy._0 = (t & ((1 << 26) - 1));\r\n    t = (t >> 26) + (x_0 * y_1) + (x_1 * y_0) + 19 * ((x_2 * y_9) + (x_3 * y_8) + (x_4 * y_7) + (x_5 * y_6) + (x_6 * y_5) + (x_7 * y_4) + (x_8 * y_3) + (x_9 * y_2));\r\n    xy._1 = (t & ((1 << 25) - 1));\r\n    t = (t >> 25) + (x_0 * y_2) + (x_2 * y_0) + 19 * ((x_4 * y_8) + (x_6 * y_6) + (x_8 * y_4)) + 2 * (x_1 * y_1) + 38 * ((x_3 * y_9) + (x_5 * y_7) + (x_7 * y_5) + (x_9 * y_3));\r\n    xy._2 = (t & ((1 << 26) - 1));\r\n    t = (t >> 26) + (x_0 * y_3) + (x_1 * y_2) + (x_2 * y_1) + (x_3 * y_0) + 19 * ((x_4 * y_9) + (x_5 * y_8) + (x_6 * y_7) + (x_7 * y_6) + (x_8 * y_5) + (x_9 * y_4));\r\n    xy._3 = (t & ((1 << 25) - 1));\r\n    t = (t >> 25) + (x_0 * y_4) + (x_2 * y_2) + (x_4 * y_0) + 19 * ((x_6 * y_8) + (x_8 * y_6)) + 2 * ((x_1 * y_3) + (x_3 * y_1)) + 38 * ((x_5 * y_9) + (x_7 * y_7) + (x_9 * y_5));\r\n    xy._4 = (t & ((1 << 26) - 1));\r\n    t = (t >> 26) + (x_0 * y_5) + (x_1 * y_4) + (x_2 * y_3) + (x_3 * y_2) + (x_4 * y_1) + (x_5 * y_0) + 19 * ((x_6 * y_9) + (x_7 * y_8) + (x_8 * y_7) + (x_9 * y_6));\r\n    xy._5 = (t & ((1 << 25) - 1));\r\n    t = (t >> 25) + (x_0 * y_6) + (x_2 * y_4) + (x_4 * y_2) + (x_6 * y_0) + 19 * (x_8 * y_8) + 2 * ((x_1 * y_5) + (x_3 * y_3) + (x_5 * y_1)) + 38 * ((x_7 * y_9) + (x_9 * y_7));\r\n    xy._6 = (t & ((1 << 26) - 1));\r\n    t = (t >> 26) + (x_0 * y_7) + (x_1 * y_6) + (x_2 * y_5) + (x_3 * y_4) + (x_4 * y_3) + (x_5 * y_2) + (x_6 * y_1) + (x_7 * y_0) + 19 * ((x_8 * y_9) + (x_9 * y_8));\r\n    xy._7 = (t & ((1 << 25) - 1));\r\n    t = (t >> 25) + xy._8;\r\n    xy._8 = (t & ((1 << 26) - 1));\r\n    xy._9 += (t >> 26);\r\n    return xy;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.attacks.bruteforce.WordListGuessProvider.getGuess",
	"Comment": "returns the next word from the inputstream. if no more words are in thein inputstream null is returned.",
	"Method": "byte[] getGuess(){\r\n    try {\r\n        String line = bufferedReader.readLine();\r\n        if (line == null) {\r\n            return null;\r\n        }\r\n        return ArrayConverter.hexStringToByteArray(line);\r\n    } catch (IOException ex) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "android.support.v4.content.LocalBroadcastManager.unregisterReceiver",
	"Comment": "unregister a previously registered broadcastreceiver.allfilters that have been registered for this broadcastreceiver will beremoved.",
	"Method": "void unregisterReceiver(BroadcastReceiver receiver){\r\n    synchronized (mReceivers) {\r\n        ArrayList<IntentFilter> filters = mReceivers.remove(receiver);\r\n        if (filters == null) {\r\n            return;\r\n        }\r\n        for (int i = 0; i < filters.size(); i++) {\r\n            IntentFilter filter = filters.get(i);\r\n            for (int j = 0; j < filter.countActions(); j++) {\r\n                String action = filter.getAction(j);\r\n                ArrayList<ReceiverRecord> receivers = mActions.get(action);\r\n                if (receivers != null) {\r\n                    for (int k = 0; k < receivers.size(); k++) {\r\n                        if (receivers.get(k).receiver == receiver) {\r\n                            receivers.remove(k);\r\n                            k--;\r\n                        }\r\n                    }\r\n                    if (receivers.size() <= 0) {\r\n                        mActions.remove(action);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetSelectedSigHashAlgorithm",
	"Comment": "test of getselectedsighashalgorithm method, of class defaultchooser.",
	"Method": "void testGetSelectedSigHashAlgorithm(){\r\n    config.setDefaultSelectedSignatureAndHashAlgorithm(SignatureAndHashAlgorithm.RSA_PSS_PSS_SHA256);\r\n    assertEquals(config.getDefaultSelectedSignatureAndHashAlgorithm(), SignatureAndHashAlgorithm.RSA_PSS_PSS_SHA256);\r\n    assertEquals(chooser.getSelectedSigHashAlgorithm(), SignatureAndHashAlgorithm.RSA_PSS_PSS_SHA256);\r\n    context.setSelectedSignatureAndHashAlgorithm(SignatureAndHashAlgorithm.DSA_SHA1);\r\n    assertEquals(chooser.getSelectedSigHashAlgorithm(), SignatureAndHashAlgorithm.DSA_SHA1);\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.identity.UserAuthentication.registerUser",
	"Comment": "attempts to register the username, password combination. checks ifusername not already exist. returns true if successful, false otherwise.",
	"Method": "boolean registerUser(String username,String password,String uri){\r\n    if (checkUsernameExists(username)) {\r\n        return false;\r\n    }\r\n    storeUser(username, password, uri);\r\n    return true;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.HelloRequestPreparatorTest.testPrepare",
	"Comment": "test of preparehandshakemessagecontents method, of classhellorequestpreparator.",
	"Method": "void testPrepare(){\r\n    preparator.prepare();\r\n}"
}, {
	"Path": "com.diffplug.spotless.JarState.from",
	"Comment": "provisions the given maven coordinates and their transitive dependencies.",
	"Method": "JarState from(String mavenCoordinate,Provisioner provisioner,JarState from,Collection<String> mavenCoordinates,Provisioner provisioner){\r\n    return provisionWithTransitives(true, mavenCoordinates, provisioner);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.crypto.PseudoRandomFunction.compute",
	"Comment": "computes prf output of the provided size using the given mac algorithm",
	"Method": "byte[] compute(PRFAlgorithm prfAlgorithm,byte[] secret,String label,byte[] seed,int size){\r\n    switch(prfAlgorithm) {\r\n        case TLS_PRF_SHA256:\r\n        case TLS_PRF_SHA384:\r\n        case TLS_PRF_GOSTR3411:\r\n        case TLS_PRF_GOSTR3411_2012_256:\r\n            return computeTls12(secret, label, seed, size, prfAlgorithm.getMacAlgorithm().getJavaName());\r\n        case TLS_PRF_LEGACY:\r\n            return TlsUtils.PRF_legacy(secret, label, seed, size);\r\n        default:\r\n            throw new UnsupportedOperationException(\"PRF computation for different\" + \" protocol versions is not supported yet\");\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.HRRKeyShareExtensionParser.parseSelectedGroup",
	"Comment": "reads the next bytes as the selectedgroup of the extension and writesthem in the message",
	"Method": "void parseSelectedGroup(HRRKeyShareExtensionMessage msg){\r\n    msg.setSelectedGroup(parseByteArrayField(ExtensionByteLength.KEY_SHARE_GROUP));\r\n    LOGGER.debug(\"SelectedGroup: \" + ArrayConverter.bytesToHexString(msg.getSelectedGroup().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.tokenbinding.TokenBindingMessageParserTest.testParseMessageContent",
	"Comment": "test of parsemessagecontent method, of class tokenbindingmessageparser.",
	"Method": "void testParseMessageContent(){\r\n    parser = new TokenBindingMessageParser(0, toParse, version);\r\n    TokenBindingMessage message = parser.parse();\r\n    Assert.assertArrayEquals(new byte[0], message.getExtensionBytes().getValue());\r\n    assertTrue(message.getExtensionLength().getValue() == 0);\r\n    assertTrue(message.getSignatureLength().getValue() == 0x40);\r\n    assertTrue(message.getPointLength().getValue() == 0x40);\r\n    assertTrue(message.getKeyParameter().getValue() == 0x02);\r\n    TokenBindingMessageSerializer serializer = new TokenBindingMessageSerializer(message, version);\r\n    byte[] serialized = serializer.serialize();\r\n    Assert.assertArrayEquals(toParse, serialized);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetPreMasterSecret",
	"Comment": "test of getpremastersecret method, of class defaultchooser.",
	"Method": "void testGetPreMasterSecret(){\r\n    byte[] preMasterSecret = ArrayConverter.hexStringToByteArray(\"ab18712378669892893619236899692136\");\r\n    config.setDefaultPreMasterSecret(preMasterSecret);\r\n    assertArrayEquals(preMasterSecret, config.getDefaultPreMasterSecret());\r\n    assertArrayEquals(preMasterSecret, chooser.getPreMasterSecret());\r\n    context.setPreMasterSecret(preMasterSecret);\r\n    assertArrayEquals(preMasterSecret, chooser.getPreMasterSecret());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.SessionResumptionDelegateTest.testGetSessionID",
	"Comment": "test of getsessionid method, of class sessionresumptiondelegate.",
	"Method": "void testGetSessionID(){\r\n    args = new String[2];\r\n    args[0] = \"-session_id\";\r\n    args[1] = \"00112233445566778899AABBCCDDEEFF\";\r\n    delegate.setSessionId(null);\r\n    jcommander.parse(args);\r\n    byte[] expected = { (byte) 0x00, (byte) 0x11, (byte) 0x22, (byte) 0x33, (byte) 0x44, (byte) 0x55, (byte) 0x66, (byte) 0x77, (byte) 0x88, (byte) 0x99, (byte) 0xAA, (byte) 0xBB, (byte) 0xCC, (byte) 0xDD, (byte) 0xEE, (byte) 0xFF };\r\n    assertArrayEquals(delegate.getSessionId(), expected);\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.util.GeomBuilder.multiPoint",
	"Comment": "creates a multipoint from all coordinates on the coordinate stack, plaching the resultback on the geometry stack. if the coordinate stack is empty this method will consume all point geometries on the geometry stack.",
	"Method": "GeomBuilder multiPoint(){\r\n    if (!cstack.isEmpty()) {\r\n        gstack.push(factory.createMultiPoint(cpopAll()));\r\n    } else {\r\n        gstack.push(factory.createMultiPoint(gpopAll(Point.class)));\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.takes.facets.auth.PsBasicTest.handleMultipleHeadersWithValidCredential",
	"Comment": "psbasic can handle multiple headers with valid credential.",
	"Method": "void handleMultipleHeadersWithValidCredential(){\r\n    final String user = \"bill\";\r\n    final Opt<Identity> identity = new PsBasic(\"RealmC\", new PsBasic.Fake(true)).enter(new RqWithHeaders(new RqFake(RqMethod.GET, String.format(\"?multiple_code=%s\", RandomStringUtils.randomAlphanumeric(Tv.TEN))), PsBasicTest.header(user, \"changeit\"), \"Referer: http://teamed.io/\", \"Connection:keep-alive\", \"Content-Encoding:gzip\", \"X-Check-Cacheable:YES\", \"X-Powered-By:Java/1.7\"));\r\n    MatcherAssert.assertThat(identity.has(), Matchers.is(true));\r\n    MatcherAssert.assertThat(identity.get().urn(), CoreMatchers.equalTo(PsBasicTest.urn(user)));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.crypto.MessageDigestCollectorTest.testGetRawBytes",
	"Comment": "test of getrawbytes method, of class messagedigestcollector.",
	"Method": "void testGetRawBytes(){\r\n    assertNotNull(digest.getRawBytes());\r\n}"
}, {
	"Path": "org.springframework.data.neo4j.web.support.OpenSessionInViewFilter.createSession",
	"Comment": "create a neo4j ogm session to be bound to a request.\tcan be overridden in subclasses.",
	"Method": "Session createSession(SessionFactory sessionFactory){\r\n    return sessionFactory.openSession();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.HostnameExtensionDelegateTest.testSetSniHostname",
	"Comment": "test of setsnihostname method, of class hostnameextensiondelegate.",
	"Method": "void testSetSniHostname(){\r\n    assertFalse(\"123456\".equals(delegate.getSniHostname()));\r\n    delegate.setSniHostname(\"123456\");\r\n    assertTrue(\"123456\".equals(delegate.getSniHostname()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ClientHelloParser.parseProtocolVersion",
	"Comment": "reads the next bytes as the protocolversion and writes them in themessage",
	"Method": "void parseProtocolVersion(SSL2ClientHelloMessage msg){\r\n    msg.setProtocolVersion(parseByteArrayField(SSL2ByteLength.VERSION));\r\n    LOGGER.debug(\"ProtocolVersion: \" + ArrayConverter.bytesToHexString(msg.getProtocolVersion().getValue()));\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.util.Geom.singlify",
	"Comment": "recursively unwraps a geometry collection containing single object.",
	"Method": "Geometry singlify(Geometry geom){\r\n    while (geom instanceof GeometryCollection && geom.getNumGeometries() == 1) {\r\n        geom = geom.getGeometryN(0);\r\n    }\r\n    return geom;\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.eclipse.base.osgi.ResourceAccessor.getEntry",
	"Comment": "get resource url for relative path, or null if the path is not present",
	"Method": "URL getEntry(String path){\r\n    BundleEntry entry = bundleFile.getEntry(getFatJarPath(path));\r\n    if (null == entry) {\r\n        entry = bundleFile.getEntry(path);\r\n    }\r\n    return null == entry ? null : entry.getLocalURL();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.CertificateVerifyParser.parseSignatureLength",
	"Comment": "reads the next bytes as the signaturelength and writes them in themessage",
	"Method": "void parseSignatureLength(CertificateVerifyMessage msg){\r\n    msg.setSignatureLength(parseIntField(HandshakeByteLength.SIGNATURE_LENGTH));\r\n    LOGGER.debug(\"SignatureLength: \" + msg.getSignatureLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.DHClientKeyExchangeHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class dhclientkeyexchangehandler.",
	"Method": "void testAdjustTLSContext(){\r\n    DHClientKeyExchangeMessage message = new DHClientKeyExchangeMessage();\r\n    message.prepareComputations();\r\n    message.getComputations().setPremasterSecret(ArrayConverter.hexStringToByteArray(\"17631f03fb5f59e65ef9b581bb6494e7304e2eaffb07ff7356cf62db1c44f4e4c15614909a3f2980c1908da2200924a23bc037963c204048cc77b1bcab5e6c9ef2c32928bcbdc0b664535885d46a9d4af4104eba4d7428c5741cf1c74bbd54d8e7ea16eaa126218286639a740fc39173e8989aea7f4b4440e1cad321315911fc4a8135d1217ebada1c70cb4ce99ff11dc8c8ca4ffc3c48a9f3f2143588a8fec147a6c3da4d36df18cf075eb7de187d83c7e3b7fd27124741a4b8809bed4f43ed9a434ce59c6a33277be96d8ef27b8e6a59d70bf6a04a86f04dfc37ab69ad90da53dfc1ea27f60a32ee7608b2197943bf8673dbe68003277bfd40b40d18b1a3bf\"));\r\n    message.getComputations().setClientServerRandom(ArrayConverter.hexStringToByteArray(\"c8c9c788adbd9dc72b5dd0635f9e2576e09c87b67e045c026ffa3281069601fd594c07e445947b545a746fcbc094e12427e0286be2199300925a81be02bf5467\"));\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_DHE_RSA_WITH_AES_256_CBC_SHA);\r\n    context.setSelectedProtocolVersion(ProtocolVersion.TLS10);\r\n    context.setRecordLayer(new TlsRecordLayer(context));\r\n    handler.adjustTLSContext(message);\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"17631f03fb5f59e65ef9b581bb6494e7304e2eaffb07ff7356cf62db1c44f4e4c15614909a3f2980c1908da2200924a23bc037963c204048cc77b1bcab5e6c9ef2c32928bcbdc0b664535885d46a9d4af4104eba4d7428c5741cf1c74bbd54d8e7ea16eaa126218286639a740fc39173e8989aea7f4b4440e1cad321315911fc4a8135d1217ebada1c70cb4ce99ff11dc8c8ca4ffc3c48a9f3f2143588a8fec147a6c3da4d36df18cf075eb7de187d83c7e3b7fd27124741a4b8809bed4f43ed9a434ce59c6a33277be96d8ef27b8e6a59d70bf6a04a86f04dfc37ab69ad90da53dfc1ea27f60a32ee7608b2197943bf8673dbe68003277bfd40b40d18b1a3bf\"), context.getPreMasterSecret());\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"4a0a7f6a0598acb36684359e1a19d848ab03b3ba1167430471166d94dcf8315d1c4290c9d9e40c50ae834df7b4f4bdef\"), context.getMasterSecret());\r\n}"
}, {
	"Path": "com.projecttango.rajawali.ScenePoseCalculator.getPointInEngineFrame",
	"Comment": "converts a point, represented as a vector3 from its initial reference frame tothe opengl world refrence frame. this allows various points to be depicted inthe opengl rendering.",
	"Method": "Vector3 getPointInEngineFrame(Vector3 inPoint,TangoPoseData deviceTPointFramePose,TangoPoseData startServiceTDevicePose){\r\n    Matrix4 startServiceTDeviceMatrix = tangoPoseToMatrix(startServiceTDevicePose);\r\n    Matrix4 deviceTPointFrameMatrix = tangoPoseToMatrix(deviceTPointFramePose);\r\n    Matrix4 startServiceTDepthMatrix = startServiceTDeviceMatrix.multiply(deviceTPointFrameMatrix);\r\n    Matrix4 inPointMatrix = new Matrix4();\r\n    inPointMatrix.setToTranslation(inPoint);\r\n    Matrix4 startServicePointMatrix = startServiceTDepthMatrix.multiply(inPointMatrix);\r\n    Matrix4 openGlWorldPointMatrix = OPENGL_T_TANGO_WORLD.clone().multiply(startServicePointMatrix);\r\n    return matrixToPose(openGlWorldPointMatrix).getPosition();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetTokenBindingVersion",
	"Comment": "test of gettokenbindingversion method, of class defaultchooser.",
	"Method": "void testGetTokenBindingVersion(){\r\n    context.setTokenBindingVersion(null);\r\n    config.setDefaultTokenBindingVersion(TokenBindingVersion.DRAFT_13);\r\n    assertEquals(TokenBindingVersion.DRAFT_13, config.getDefaultTokenBindingVersion());\r\n    assertEquals(TokenBindingVersion.DRAFT_13, chooser.getTokenBindingVersion());\r\n    context.setTokenBindingVersion(TokenBindingVersion.DRAFT_1);\r\n    assertEquals(TokenBindingVersion.DRAFT_1, chooser.getTokenBindingVersion());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.modelcorrespondence.ModelCorrespondenceActivity.findCorrespondence",
	"Comment": "calculate the correspondence transform between the given points in the data model and thechosen points in world frame. update the pose of the data model and render it in ar.uses the tangosupport library to find the correspondence similarity transform.",
	"Method": "void findCorrespondence(){\r\n    List<float[]> srcVectors = mHouseModel.getOpenGlModelPpoints(mOpenGlTHouse);\r\n    double[][] src = new double[4][3];\r\n    for (int i = 0; i < mHouseModel.getNumberOfPoints(); i++) {\r\n        float[] v = srcVectors.get(i);\r\n        src[i][0] = v[0];\r\n        src[i][1] = v[1];\r\n        src[i][2] = v[2];\r\n    }\r\n    double[][] dest = new double[4][3];\r\n    for (int i = 0; i < mHouseModel.getNumberOfPoints(); i++) {\r\n        float[] v = mDestPointList.get(i);\r\n        dest[i][0] = v[0];\r\n        dest[i][1] = v[1];\r\n        dest[i][2] = v[2];\r\n    }\r\n    double[] output = TangoTransformHelper.findCorrespondenceSimilarityTransform(src, dest);\r\n    transformModel(toFloatArray(output));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.factory.HandlerFactory.getExtensionHandler",
	"Comment": "returns the correct extension handler for a specified extensiontype in ahandshakemessage",
	"Method": "ExtensionHandler getExtensionHandler(TlsContext context,ExtensionType type,HandshakeMessageType handshakeMessageType){\r\n    try {\r\n        switch(type) {\r\n            case ALPN:\r\n                return new AlpnExtensionHandler(context);\r\n            case CACHED_INFO:\r\n                return new CachedInfoExtensionHandler(context);\r\n            case CERT_TYPE:\r\n                return new CertificateTypeExtensionHandler(context);\r\n            case CLIENT_AUTHZ:\r\n                return new ClientAuthzExtensionHandler(context);\r\n            case CLIENT_CERTIFICATE_TYPE:\r\n                return new ClientCertificateTypeExtensionHandler(context);\r\n            case CLIENT_CERTIFICATE_URL:\r\n                return new ClientCertificateUrlExtensionHandler(context);\r\n            case EARLY_DATA:\r\n                return new EarlyDataExtensionHandler(context);\r\n            case EC_POINT_FORMATS:\r\n                return new EcPointFormatExtensionHandler(context);\r\n            case ELLIPTIC_CURVES:\r\n                return new EllipticCurvesExtensionHandler(context);\r\n            case ENCRYPT_THEN_MAC:\r\n                return new EncryptThenMacExtensionHandler(context);\r\n            case EXTENDED_MASTER_SECRET:\r\n                return new ExtendedMasterSecretExtensionHandler(context);\r\n            case HEARTBEAT:\r\n                return new HeartbeatExtensionHandler(context);\r\n            case KEY_SHARE_OLD:\r\n            case KEY_SHARE:\r\n                if (handshakeMessageType == HandshakeMessageType.HELLO_RETRY_REQUEST) {\r\n                    return new HrrKeyShareExtensionHandler(context);\r\n                }\r\n                return new KeyShareExtensionHandler(context);\r\n            case MAX_FRAGMENT_LENGTH:\r\n                return new MaxFragmentLengthExtensionHandler(context);\r\n            case PADDING:\r\n                return new PaddingExtensionHandler(context);\r\n            case PRE_SHARED_KEY:\r\n                return new PreSharedKeyExtensionHandler(context);\r\n            case PSK_KEY_EXCHANGE_MODES:\r\n                return new PSKKeyExchangeModesExtensionHandler(context);\r\n            case RENEGOTIATION_INFO:\r\n                return new RenegotiationInfoExtensionHandler(context);\r\n            case SERVER_AUTHZ:\r\n                return new ServerAuthzExtensionHandler(context);\r\n            case SERVER_CERTIFICATE_TYPE:\r\n                return new ServerCertificateTypeExtensionHandler(context);\r\n            case SERVER_NAME_INDICATION:\r\n                return new ServerNameIndicationExtensionHandler(context);\r\n            case SESSION_TICKET:\r\n                return new SessionTicketTlsExtensionHandler(context);\r\n            case SIGNATURE_AND_HASH_ALGORITHMS:\r\n                return new SignatureAndHashAlgorithmsExtensionHandler(context);\r\n            case SIGNED_CERTIFICATE_TIMESTAMP:\r\n                return new SignedCertificateTimestampExtensionHandler(context);\r\n            case SRP:\r\n                return new SrpExtensionHandler(context);\r\n            case STATUS_REQUEST:\r\n                return new CertificateStatusRequestExtensionHandler(context);\r\n            case STATUS_REQUEST_V2:\r\n                return new CertificateStatusRequestV2ExtensionHandler(context);\r\n            case SUPPORTED_VERSIONS:\r\n                return new SupportedVersionsExtensionHandler(context);\r\n            case TOKEN_BINDING:\r\n                return new TokenBindingExtensionHandler(context);\r\n            case TRUNCATED_HMAC:\r\n                return new TruncatedHmacExtensionHandler(context);\r\n            case TRUSTED_CA_KEYS:\r\n                return new TrustedCaIndicationExtensionHandler(context);\r\n            case UNKNOWN:\r\n                return new UnknownExtensionHandler(context);\r\n            case USER_MAPPING:\r\n                return new UserMappingExtensionHandler(context);\r\n            case USE_SRTP:\r\n                return new SrtpExtensionHandler(context);\r\n            default:\r\n                throw new UnsupportedOperationException(type.name() + \" Extension are not supported yet\");\r\n        }\r\n    } catch (UnsupportedOperationException E) {\r\n        LOGGER.debug(\"Could not retrieve correct Handler, returning UnknownExtensionHandler\", E);\r\n    }\r\n    return new UnknownExtensionHandler(context);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.PskRsaClientKeyExchangeMessageTest.testToString",
	"Comment": "test of tostring method, of class pskrsaclientkeyexchangemessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"PskRsaClientKeyExchangeMessage:\");\r\n    sb.append(\"\\n  PSKIdentityLength: \").append(\"null\");\r\n    sb.append(\"\\n  PSKIdentity: \").append(\"null\");\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorPlanReconstructionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud.",
	"Method": "void startupTango(){\r\n    mTangoFloorplanner = new TangoFloorplanner(new TangoFloorplanner.OnFloorplanAvailableListener() {\r\n        @Override\r\n        public void onFloorplanAvailable(List<TangoPolygon> polygons, List<TangoFloorplanLevel> levels) {\r\n            mFloorplanView.setFloorplan(polygons);\r\n            updateFloorAndCeiling(levels);\r\n            calculateAndUpdateArea(polygons);\r\n        }\r\n    });\r\n    mTangoFloorplanner.setDepthCameraCalibration(mTango.getCameraIntrinsics(TangoCameraIntrinsics.TANGO_CAMERA_DEPTH));\r\n    mTangoFloorplanner.startFloorplanning();\r\n    List<TangoCoordinateFramePair> framePairs = new ArrayList<TangoCoordinateFramePair>();\r\n    mTango.connectListener(framePairs, new Tango.OnTangoUpdateListener() {\r\n        @Override\r\n        public void onPoseAvailable(TangoPoseData tangoPoseData) {\r\n        }\r\n        @Override\r\n        public void onXyzIjAvailable(TangoXyzIjData tangoXyzIjData) {\r\n        }\r\n        @Override\r\n        public void onFrameAvailable(int i) {\r\n        }\r\n        @Override\r\n        public void onTangoEvent(TangoEvent tangoEvent) {\r\n        }\r\n        @Override\r\n        public void onPointCloudAvailable(TangoPointCloudData tangoPointCloudData) {\r\n            mTangoFloorplanner.onPointCloudAvailable(tangoPointCloudData);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorPlanReconstructionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud.",
	"Method": "void startupTango(){\r\n    mFloorplanView.setFloorplan(polygons);\r\n    updateFloorAndCeiling(levels);\r\n    calculateAndUpdateArea(polygons);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorPlanReconstructionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorPlanReconstructionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorPlanReconstructionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorPlanReconstructionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorPlanReconstructionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.listen to updates from the point cloud.",
	"Method": "void startupTango(){\r\n    mTangoFloorplanner.onPointCloudAvailable(tangoPointCloudData);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.projectionMatrixFromCameraIntrinsics",
	"Comment": "use tango camera intrinsics to calculate the projection matrix for the rajawali scene.",
	"Method": "float[] projectionMatrixFromCameraIntrinsics(TangoCameraIntrinsics intrinsics){\r\n    float near = 0.1f;\r\n    float far = 100;\r\n    double cx = intrinsics.cx;\r\n    double cy = intrinsics.cy;\r\n    double width = intrinsics.width;\r\n    double height = intrinsics.height;\r\n    double fx = intrinsics.fx;\r\n    double fy = intrinsics.fy;\r\n    double xscale = near / fx;\r\n    double yscale = near / fy;\r\n    double xoffset = (cx - (width / 2.0)) * xscale;\r\n    double yoffset = -(cy - (height / 2.0)) * yscale;\r\n    float[] m = new float[16];\r\n    Matrix.frustumM(m, 0, (float) (xscale * -width / 2.0 - xoffset), (float) (xscale * width / 2.0 - xoffset), (float) (yscale * -height / 2.0 - yoffset), (float) (yscale * height / 2.0 - yoffset), near, far);\r\n    return m;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.ServerNameIndicationExtensionParser.parseServerNameListLength",
	"Comment": "reads the next bytes as the servernamelistlength of the extension andwrites them in the message",
	"Method": "void parseServerNameListLength(ServerNameIndicationExtensionMessage msg){\r\n    msg.setServerNameListLength(parseIntField(ExtensionByteLength.SERVER_NAME_LIST));\r\n    LOGGER.debug(\"ServerNameListLength: \" + msg.getServerNameListLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.message.NewSessionTicketMessageTest.testToString",
	"Comment": "test of tostring method, of class newsessionticketmessage.",
	"Method": "void testToString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"NewSessionTicketMessage:\");\r\n    sb.append(\"\\n  TicketLifeTimeHint: \").append(\"null\");\r\n    sb.append(\"\\n  TicketLength: \").append(\"null\");\r\n    sb.append(\"\\n  Ticket: \").append(new SessionTicket().toString());\r\n    assertEquals(message.toString(), sb.toString());\r\n}"
}, {
	"Path": "org.springframework.data.neo4j.integration.conversion.ConversionServiceTests.shouldConvertFieldsUsingAnAvailableSupertypeConverterIfExactTypesDoNotMatch",
	"Comment": "if target graph type is set to integer but we have a converter for a number then it should still save to the graph.",
	"Method": "void shouldConvertFieldsUsingAnAvailableSupertypeConverterIfExactTypesDoNotMatch(){\r\n    this.conversionService.addConverterFactory(new SpringMonetaryAmountToNumberConverterFactory());\r\n    PensionPlan pension = new PensionPlan(new MonetaryAmount(20_000, 00), \"Ashes Assets LLP\");\r\n    this.pensionRepository.save(pension);\r\n    Result result = getGraphDatabaseService().execute(\"MATCH (p:PensionPlan) RETURN p.fundValue AS fv\");\r\n    assertTrue(\"Nothing was saved\", result.hasNext());\r\n    assertEquals(\"The amount wasn't converted and persisted correctly\", \"2000000\", String.valueOf(result.next().get(\"fv\")));\r\n    result.close();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.greenscreen.GreenScreenRenderer.takeScreenshot",
	"Comment": "this method sets a flag for saving the view in the next frame to a screenshot.",
	"Method": "void takeScreenshot(){\r\n    mTakeScreenshot = true;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.extension.SignedCertificateTimestampExtensionPreparator.prepareExtensionContent",
	"Comment": "parses a signedcertificatetimestampextensionmessage of a tlscontext.",
	"Method": "void prepareExtensionContent(){\r\n    message.setSignedTimestamp(chooser.getConfig().getDefaultSignedCertificateTimestamp());\r\n    LOGGER.debug(\"Prepared the SignedCertificateTimestapExtension with timestamp length \" + message.getSignedTimestamp().getValue().length);\r\n}"
}, {
	"Path": "com.diffplug.spotless.PaddedCellBulk.cleanDir",
	"Comment": "does whatever it takes to turn this path into an empty folder.",
	"Method": "void cleanDir(Path folder){\r\n    if (Files.exists(folder)) {\r\n        if (Files.isDirectory(folder)) {\r\n            Files.walkFileTree(folder, FOLDER_CLEANING_VISITOR);\r\n        } else {\r\n            Files.delete(folder);\r\n        }\r\n    }\r\n    Files.createDirectories(folder);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.CertificateRequestParser.parseSignatureHashAlgorithmsLength",
	"Comment": "reads the next bytes as the signaturehashalgorithmslength and writes themin the message",
	"Method": "void parseSignatureHashAlgorithmsLength(CertificateRequestMessage msg){\r\n    msg.setSignatureHashAlgorithmsLength(parseIntField(HandshakeByteLength.SIGNATURE_HASH_ALGORITHMS_LENGTH));\r\n    LOGGER.debug(\"SignatureHashAlgorithmsLength: \" + msg.getSignatureHashAlgorithmsLength().getValue());\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.protocol.selenium.NavigationFilters.fromConf",
	"Comment": "loads and configure the navigationfilters based on the storm config ifthere is one otherwise returns an emptynavigationfilters.",
	"Method": "NavigationFilters fromConf(Map stormConf){\r\n    String configfile = ConfUtils.getString(stormConf, \"navigationfilters.config.file\");\r\n    if (StringUtils.isNotBlank(configfile)) {\r\n        try {\r\n            return new NavigationFilters(stormConf, configfile);\r\n        } catch (IOException e) {\r\n            String message = \"Exception caught while loading the NavigationFilters from \" + configfile;\r\n            LOG.error(message);\r\n            throw new RuntimeException(message, e);\r\n        }\r\n    }\r\n    return NavigationFilters.emptyNavigationFilters;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.extension.HRRKeyShareExtensionPreparatorTest.testPrepare",
	"Comment": "test of prepare method, of class hrrkeyshareextensionpreparator.",
	"Method": "void testPrepare(){\r\n    preparator.prepare();\r\n    assertArrayEquals(message.getSelectedGroup().getValue(), context.getConfig().getDefaultSelectedNamedGroup().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ReceiveAsciiActionTest.testExecutdAsPlanned",
	"Comment": "test of executedasplanned method, of class receiveasciiaction.",
	"Method": "void testExecutdAsPlanned(){\r\n    assertFalse(action.executedAsPlanned());\r\n}"
}, {
	"Path": "com.example.android.trivialdrivesample.util.IabHelper.getResponseCodeFromIntent",
	"Comment": "workaround to bug where sometimes response codes come as long instead of integer",
	"Method": "int getResponseCodeFromIntent(Intent i){\r\n    Object o = i.getExtras().get(RESPONSE_CODE);\r\n    if (o == null) {\r\n        logError(\"Intent with no response code, assuming OK (known issue)\");\r\n        return BILLING_RESPONSE_RESULT_OK;\r\n    } else if (o instanceof Integer)\r\n        return ((Integer) o).intValue();\r\n    else if (o instanceof Long)\r\n        return (int) ((Long) o).longValue();\r\n    else {\r\n        logError(\"Unexpected type for intent response code.\");\r\n        logError(o.getClass().getName());\r\n        throw new RuntimeException(\"Unexpected type for intent response code: \" + o.getClass().getName());\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellovideo.HelloVideoRenderer.createCameraVbos",
	"Comment": "creates and populates vertex buffer objects for rendering the camera.",
	"Method": "void createCameraVbos(){\r\n    mVbos = new int[3];\r\n    GLES20.glGenBuffers(3, mVbos, 0);\r\n    GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, mVbos[0]);\r\n    // 4 2D vertex of floats.\r\n    GLES20.glBufferData(// 4 2D vertex of floats.\r\n    GLES20.GL_ARRAY_BUFFER, // 4 2D vertex of floats.\r\n    mVertex.capacity() * Float.SIZE / 8, mVertex, GLES20.GL_STATIC_DRAW);\r\n    GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, mVbos[1]);\r\n    // 4 2D texture coords of floats.\r\n    GLES20.glBufferData(// 4 2D texture coords of floats.\r\n    GLES20.GL_ARRAY_BUFFER, // 4 2D texture coords of floats.\r\n    mTexCoord.capacity() * Float.SIZE / 8, mTexCoord, GLES20.GL_STATIC_DRAW);\r\n    GLES20.glBindBuffer(GLES20.GL_ELEMENT_ARRAY_BUFFER, mVbos[2]);\r\n    // 4 short indices.\r\n    GLES20.glBufferData(// 4 short indices.\r\n    GLES20.GL_ELEMENT_ARRAY_BUFFER, // 4 short indices.\r\n    mIndices.capacity() * Short.SIZE / 8, mIndices, GLES20.GL_STATIC_DRAW);\r\n    GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.DHEServerKeyExchangeHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class dheserverkeyexchangehandler.",
	"Method": "void testAdjustTLSContext(){\r\n    DHEServerKeyExchangeMessage message = new DHEServerKeyExchangeMessage();\r\n    message.setModulus(BigInteger.TEN.toByteArray());\r\n    message.setGenerator(BigInteger.ONE.toByteArray());\r\n    message.setPublicKey(new byte[] { 0, 1, 2, 3 });\r\n    context.setSelectedCipherSuite(CipherSuite.TLS_DHE_RSA_WITH_AES_128_CBC_SHA);\r\n    message.prepareComputations();\r\n    message.getComputations().setPrivateKey(BigInteger.ZERO);\r\n    handler.adjustTLSContext(message);\r\n}"
}, {
	"Path": "org.takes.facets.fork.TkMethodsTest.throwsExceptionOnActinOnUnproperMethod",
	"Comment": "tkmethods can throw httpexcection when acting on unproper method.",
	"Method": "void throwsExceptionOnActinOnUnproperMethod(){\r\n    new TkMethods(Mockito.mock(Take.class), RqMethod.POST).act(new RqFake(RqMethod.GET));\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPITest.testTessBaseAPIDetectOrientationScript",
	"Comment": "test of tessbaseapidetectorientationscript method, of class tessapi.",
	"Method": "void testTessBaseAPIDetectOrientationScript(){\r\n    logger.info(\"TessBaseAPIDetectOrientationScript\");\r\n    File image = new File(testResourcesDataPath, \"eurotext.png\");\r\n    int expResult = TRUE;\r\n    Leptonica leptInstance = Leptonica.INSTANCE;\r\n    Pix pix = leptInstance.pixRead(image.getPath());\r\n    api.TessBaseAPIInit3(handle, datapath, language);\r\n    api.TessBaseAPISetImage2(handle, pix);\r\n    IntBuffer orient_degB = IntBuffer.allocate(1);\r\n    FloatBuffer orient_confB = FloatBuffer.allocate(1);\r\n    PointerByReference script_nameB = new PointerByReference();\r\n    FloatBuffer script_confB = FloatBuffer.allocate(1);\r\n    int result = api.TessBaseAPIDetectOrientationScript(handle, orient_degB, orient_confB, script_nameB, script_confB);\r\n    if (result == TRUE) {\r\n        int orient_deg = orient_degB.get();\r\n        float orient_conf = orient_confB.get();\r\n        String script_name = script_nameB.getValue().getString(0);\r\n        float script_conf = script_confB.get();\r\n        logger.info(String.format(\"OrientationScript: orient_deg=%d, orient_conf=%f, script_name=%s, script_conf=%f\", orient_deg, orient_conf, script_name, script_conf));\r\n    }\r\n    PointerByReference pRef = new PointerByReference();\r\n    pRef.setValue(pix.getPointer());\r\n    leptInstance.pixDestroy(pRef);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.identity.UserAuthentication.authenticateUser",
	"Comment": "authenticates the given username, password combination. hash of passwordis matched against the hash value stored for password field",
	"Method": "boolean authenticateUser(String username,String password,String uri){\r\n    if (null == username || null == password) {\r\n        return false;\r\n    }\r\n    UserInfo user = getUserInfo(username);\r\n    if (user == null) {\r\n        return false;\r\n    }\r\n    String hashedSaltedPassword = Utilities.getSaltedPassword(username, uri, password);\r\n    return hashedSaltedPassword.equals(user.getHashedPassword());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.util.CipherSuiteFilter.filterCipherSuites",
	"Comment": "ciphersuite filtering based on the key exchange method and on theephemeral property. this method is useful for establishing new workflows.",
	"Method": "void filterCipherSuites(List<CipherSuite> cipherSuites){\r\n    KeyExchangeAlgorithm algorithm = AlgorithmResolver.getKeyExchangeAlgorithm(cipherSuites.get(0));\r\n    boolean ephemeral = cipherSuites.get(0).isEphemeral();\r\n    for (int i = cipherSuites.size() - 1; i > 0; i--) {\r\n        CipherSuite cs = cipherSuites.get(i);\r\n        if (AlgorithmResolver.getKeyExchangeAlgorithm(cs) != algorithm || cs.isEphemeral() != ephemeral) {\r\n            cipherSuites.remove(i);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.PskRsaClientKeyExchangeParser.parsePskIdentityLength",
	"Comment": "reads the next bytes as the pskidentitylength and writes them in themessage",
	"Method": "void parsePskIdentityLength(PskRsaClientKeyExchangeMessage msg){\r\n    msg.setIdentityLength(parseIntField(HandshakeByteLength.PSK_IDENTITY_LENGTH));\r\n    LOGGER.debug(\"PSK-IdentityLength: \" + msg.getIdentityLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.WorkflowOutputDelegateTest.testGetWorkflowOutput",
	"Comment": "test of getworkflowoutput method, of class workflowoutputdelegate.",
	"Method": "void testGetWorkflowOutput(){\r\n    args = new String[2];\r\n    args[0] = \"-workflow_output\";\r\n    args[1] = \"path\";\r\n    assertFalse(\"path\".equals(delegate.getWorkflowOutput()));\r\n    jcommander.parse(args);\r\n    assertTrue(\"path\".equals(delegate.getWorkflowOutput()));\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.util.URLUtil.getPage",
	"Comment": "returns the page for the url. the page consists of the protocol, host,and path, but does not include the query string. the host is lowercasedbut the path is not.",
	"Method": "String getPage(String url){\r\n    try {\r\n        url = url.toLowerCase(Locale.ROOT);\r\n        String queryStr = new URL(url).getQuery();\r\n        return (queryStr != null) ? url.replace(\"?\" + queryStr, \"\") : url;\r\n    } catch (MalformedURLException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.statemachine.security.SecurityRule.commaDelimitedListToSecurityAttributes",
	"Comment": "convert attributes from comma separated string to collection",
	"Method": "Collection<String> commaDelimitedListToSecurityAttributes(String attributes){\r\n    Collection<String> attrs = new HashSet<String>();\r\n    for (String attribute : attributes.split(\",\")) {\r\n        attribute = attribute.trim();\r\n        if (!\"\".equals(attribute)) {\r\n            attrs.add(attribute);\r\n        }\r\n    }\r\n    return attrs;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.SessionTicketTlsExtensionHandlerTest.testGetPreparator",
	"Comment": "tests the getpreparator of the sessiontickettlsextensionhandler class",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new SessionTicketTLSExtensionMessage()) instanceof SessionTicketTLSExtensionPreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.FinishedParser.parseVerifyData",
	"Comment": "reads the next bytes as the verifydata and writes them in the message",
	"Method": "void parseVerifyData(FinishedMessage msg){\r\n    msg.setVerifyData(parseByteArrayField(msg.getLength().getValue()));\r\n    LOGGER.debug(\"VerifiyData: \" + ArrayConverter.bytesToHexString(msg.getVerifyData().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeCipherSuiteActionTest.testGetNewValue",
	"Comment": "test of getnewvalue method, of class changeciphersuiteaction.",
	"Method": "void testGetNewValue(){\r\n    assertEquals(action.getNewValue(), CipherSuite.TLS_DHE_DSS_WITH_AES_128_CBC_SHA256);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetClientEcPrivateKey",
	"Comment": "test of getclientecprivatekey method, of class defaultchooser.",
	"Method": "void testGetClientEcPrivateKey(){\r\n    context.setClientEcPrivateKey(null);\r\n    config.setDefaultClientEcPrivateKey(BigInteger.ONE);\r\n    assertEquals(BigInteger.ONE, config.getDefaultClientEcPrivateKey());\r\n    assertEquals(BigInteger.ONE, chooser.getClientEcPrivateKey());\r\n    context.setClientEcPrivateKey(BigInteger.TEN);\r\n    assertEquals(BigInteger.TEN, chooser.getClientEcPrivateKey());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.UnknownHandshakePreparatorTest.testPrepare",
	"Comment": "test of preparehandshakemessagecontents method, of classunknownhandshakepreparator.",
	"Method": "void testPrepare(){\r\n    message.setDataConfig(new byte[] { 6, 6, 6 });\r\n    preparator.prepare();\r\n    assertArrayEquals(new byte[] { 6, 6, 6 }, message.getData().getValue());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorPlanReconstructionActivity.calculateAndUpdateArea",
	"Comment": "calculate the total explored space area and update the text field with that information.",
	"Method": "void calculateAndUpdateArea(List<TangoPolygon> polygons){\r\n    double area = 0;\r\n    for (TangoPolygon polygon : polygons) {\r\n        if (polygon.layer == TangoPolygon.TANGO_3DR_LAYER_SPACE) {\r\n            if (area == 0 || (polygon.area > mMinAreaSpace || polygon.area < 0)) {\r\n                area += polygon.area;\r\n            }\r\n        }\r\n    }\r\n    final String areaText = String.format(\"%.2f\", area);\r\n    runOnUiThread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            mAreaText.setText(areaText);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorPlanReconstructionActivity.calculateAndUpdateArea",
	"Comment": "calculate the total explored space area and update the text field with that information.",
	"Method": "void calculateAndUpdateArea(List<TangoPolygon> polygons){\r\n    mAreaText.setText(areaText);\r\n}"
}, {
	"Path": "com.projecttango.rajawali.ScenePoseCalculator.tangoPoseToMatrix",
	"Comment": "converts from tangoposedata to a matrix4 for transformations.",
	"Method": "Matrix4 tangoPoseToMatrix(TangoPoseData tangoPose){\r\n    Vector3 v = new Vector3(tangoPose.translation[0], tangoPose.translation[1], tangoPose.translation[2]);\r\n    Quaternion q = new Quaternion(tangoPose.rotation[3], tangoPose.rotation[0], tangoPose.rotation[1], tangoPose.rotation[2]);\r\n    q.conjugate();\r\n    Matrix4 m = new Matrix4();\r\n    m.setAll(v, new Vector3(1, 1, 1), q);\r\n    return m;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.WorkflowOutputDelegateTest.testSetWorkflowOutput",
	"Comment": "test of setworkflowoutput method, of class workflowoutputdelegate.",
	"Method": "void testSetWorkflowOutput(){\r\n    assertFalse(\"path\".equals(delegate.getWorkflowOutput()));\r\n    delegate.setWorkflowOutput(\"path\");\r\n    assertTrue(\"path\".equals(delegate.getWorkflowOutput()));\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.util.MetadataTransfer.getMetaForOutlink",
	"Comment": "determine which metadata should be transfered to an outlink. addsadditional metadata like the url path.",
	"Method": "Metadata getMetaForOutlink(String targetURL,String sourceURL,Metadata parentMD){\r\n    Metadata md = _filter(parentMD, mdToTransfer);\r\n    if (trackPath) {\r\n        md.addValue(urlPathKeyName, sourceURL);\r\n    }\r\n    if (trackDepth) {\r\n        String existingDepth = md.getFirstValue(depthKeyName);\r\n        int depth;\r\n        try {\r\n            depth = Integer.parseInt(existingDepth);\r\n        } catch (Exception e) {\r\n            depth = 0;\r\n        }\r\n        md.setValue(depthKeyName, Integer.toString(++depth));\r\n    }\r\n    return md;\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.elasticsearch.metrics.MetricsConsumer.getIndexName",
	"Comment": "returns the name of the index that metrics will be written too.",
	"Method": "String getIndexName(){\r\n    return indexName;\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.groovy.GrEclipseFormatterStep.create",
	"Comment": "creates a formatter step for the given version and settings file.",
	"Method": "FormatterStep create(Iterable<File> settingsFiles,Provisioner provisioner,FormatterStep create,String version,Iterable<File> settingsFiles,Provisioner provisioner){\r\n    EclipseBasedStepBuilder builder = createBuilder(provisioner);\r\n    builder.setVersion(version);\r\n    builder.setPreferences(settingsFiles);\r\n    return builder.build();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.extension.HRRKeyShareExtensionSerializerTest.testSerializeExtensionContent",
	"Comment": "test of serializeextensioncontent method, of classhrrkeyshareextensionserializer.",
	"Method": "void testSerializeExtensionContent(){\r\n    HRRKeyShareExtensionMessage msg = new HRRKeyShareExtensionMessage();\r\n    msg.setExtensionType(type.getValue());\r\n    msg.setExtensionLength(extensionLength);\r\n    msg.setSelectedGroup(selectedGroup);\r\n    HRRKeyShareExtensionSerializer serializer = new HRRKeyShareExtensionSerializer(msg);\r\n    assertArrayEquals(completeExtension, serializer.serialize());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.DefaultWorkflowExecutorTest.testExecuteImplicitWorkflowWithDefaultContexts",
	"Comment": "fallback to workflowconfigurationfactory with default context shouldwork.",
	"Method": "void testExecuteImplicitWorkflowWithDefaultContexts(){\r\n    Config config = Config.createConfig();\r\n    config.setWorkflowTraceType(WorkflowTraceType.HELLO);\r\n    State state = new State(config);\r\n    WorkflowExecutor workflowExecutor = new DefaultWorkflowExecutor(state);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.TransportHandlerDelegateTest.testApplyDelegate",
	"Comment": "test of applydelegate method, of class transporthandlerdelegate.",
	"Method": "void testApplyDelegate(){\r\n    Config config = Config.createConfig();\r\n    config.getDefaultClientConnection().setTransportHandlerType(TransportHandlerType.TCP);\r\n    config.getDefaultServerConnection().setTransportHandlerType(TransportHandlerType.TCP);\r\n    args = new String[2];\r\n    args[0] = \"-transport_handler_type\";\r\n    args[1] = \"UDP\";\r\n    jcommander.parse(args);\r\n    delegate.applyDelegate(config);\r\n    assertThat(config.getDefaultClientConnection().getTransportHandlerType(), equalTo(TransportHandlerType.UDP));\r\n    assertThat(config.getDefaultServerConnection().getTransportHandlerType(), equalTo(TransportHandlerType.UDP));\r\n}"
}, {
	"Path": "com.amazonaws.cognito.sync.demo.client.cognito.ServerCognitoIdentityProvider.refresh",
	"Comment": "2.when the app user is not using the developer authentication, just callthe refresh method of the awsabstractcognitodeveloperidentityproviderclass which actually calls getid and getopenidtoken api of amazoncognito.",
	"Method": "String refresh(){\r\n    setToken(null);\r\n    ensureLoginData();\r\n    return updateCognitoToken().getToken();\r\n}"
}, {
	"Path": "org.takes.facets.auth.PsBasicTest.handleConnectionWithValidCredentialDefaultEntry",
	"Comment": "psbasic can handle connection with valid credential when entry isa instance of default.",
	"Method": "void handleConnectionWithValidCredentialDefaultEntry(){\r\n    final String user = \"johny\";\r\n    final String password = \"password2\";\r\n    final Opt<Identity> identity = new PsBasic(\"RealmAA\", new PsBasic.Default(\"mike my password1 urn:basic:michael\", String.format(\"%s %s urn:basic:%s\", user, password, user))).enter(new RqWithHeaders(new RqFake(RqMethod.GET, String.format(PsBasicTest.VALID_CODE, RandomStringUtils.randomAlphanumeric(Tv.TEN))), PsBasicTest.header(user, password)));\r\n    MatcherAssert.assertThat(identity.has(), Matchers.is(true));\r\n    MatcherAssert.assertThat(identity.get().urn(), CoreMatchers.equalTo(PsBasicTest.urn(user)));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.client.main.TlsClientTest.testExecuteWorkflows",
	"Comment": "test of executeworkflow method, of class workflowexecutor.",
	"Method": "void testExecuteWorkflows(PublicKeyAlgorithm algorithm,int port){\r\n    ClientCommandConfig clientCommandConfig = new ClientCommandConfig(new GeneralDelegate());\r\n    TimeoutDelegate timeoutDelegate = (TimeoutDelegate) clientCommandConfig.getDelegate(TimeoutDelegate.class);\r\n    timeoutDelegate.setTimeout(TIMEOUT);\r\n    ClientDelegate clientDelegate = (ClientDelegate) clientCommandConfig.getDelegate(ClientDelegate.class);\r\n    clientDelegate.setHost(\"localhost:\" + port);\r\n    Config config = clientCommandConfig.createConfig();\r\n    config.setEnforceSettings(false);\r\n    List<String> serverList = Arrays.asList(tlsServer.getCipherSuites());\r\n    config.setHighestProtocolVersion(ProtocolVersion.SSL3);\r\n    testProtocolCompatibility(serverList, config, algorithm);\r\n    config.setHighestProtocolVersion(ProtocolVersion.TLS10);\r\n    testProtocolCompatibility(serverList, config, algorithm);\r\n    config.setHighestProtocolVersion(ProtocolVersion.TLS11);\r\n    testProtocolCompatibility(serverList, config, algorithm);\r\n    config.setHighestProtocolVersion(ProtocolVersion.TLS12);\r\n    testProtocolCompatibility(serverList, config, algorithm);\r\n    if (algorithm == PublicKeyAlgorithm.RSA) {\r\n        boolean result = testCustomWorkflow(port);\r\n        collector.checkThat(\"Custom failed.\", result, is(true));\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.pointtopoint.PointToPointActivity.getDepthAtTouchPosition",
	"Comment": "use the tango support library with point cloud data to calculate the depthof the point closest to where the user touches the screen. it returns avector3 in opengl world space.",
	"Method": "MeasuredPoint getDepthAtTouchPosition(float u,float v){\r\n    TangoPointCloudData pointCloud = mPointCloudManager.getLatestPointCloud();\r\n    if (pointCloud == null) {\r\n        return null;\r\n    }\r\n    double rgbTimestamp;\r\n    TangoImageBuffer imageBuffer = mCurrentImageBuffer;\r\n    if (mBilateralBox.isChecked()) {\r\n        rgbTimestamp = imageBuffer.timestamp;\r\n    } else {\r\n        rgbTimestamp = mRgbTimestampGlThread;\r\n    }\r\n    TangoPoseData depthlTcolorPose = TangoSupport.getPoseAtTime(rgbTimestamp, TangoPoseData.COORDINATE_FRAME_CAMERA_DEPTH, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_TANGO, TangoSupport.ENGINE_TANGO, TangoSupport.ROTATION_IGNORED);\r\n    if (depthlTcolorPose.statusCode != TangoPoseData.POSE_VALID) {\r\n        Log.w(TAG, \"Could not get color camera transform at time \" + rgbTimestamp);\r\n        return null;\r\n    }\r\n    float[] depthPoint;\r\n    if (mBilateralBox.isChecked()) {\r\n        depthPoint = TangoDepthInterpolation.getDepthAtPointBilateral(pointCloud, new double[] { 0.0, 0.0, 0.0 }, new double[] { 0.0, 0.0, 0.0, 1.0 }, imageBuffer, u, v, mDisplayRotation, depthlTcolorPose.translation, depthlTcolorPose.rotation);\r\n    } else {\r\n        depthPoint = TangoDepthInterpolation.getDepthAtPointNearestNeighbor(pointCloud, new double[] { 0.0, 0.0, 0.0 }, new double[] { 0.0, 0.0, 0.0, 1.0 }, u, v, mDisplayRotation, depthlTcolorPose.translation, depthlTcolorPose.rotation);\r\n    }\r\n    if (depthPoint == null) {\r\n        return null;\r\n    }\r\n    return new MeasuredPoint(rgbTimestamp, depthPoint);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.MaxFragmentLengthExtensionHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of classmaxfragmentlengthextensionhandler.",
	"Method": "void testAdjustTLSContext(){\r\n    MaxFragmentLengthExtensionMessage msg = new MaxFragmentLengthExtensionMessage();\r\n    msg.setMaxFragmentLength(new byte[] { 1 });\r\n    handler.adjustTLSContext(msg);\r\n    assertTrue(context.getMaxFragmentLength() == MaxFragmentLength.TWO_9);\r\n}"
}, {
	"Path": "org.takes.http.BkTimeable.check",
	"Comment": "checking threads storage and interrupt long running threads.",
	"Method": "void check(){\r\n    for (final Map.Entry<Thread, Long> entry : this.threads.entrySet()) {\r\n        final long time = System.currentTimeMillis();\r\n        if (time - entry.getValue() > this.latency) {\r\n            final Thread thread = entry.getKey();\r\n            if (thread.isAlive()) {\r\n                thread.interrupt();\r\n            }\r\n            this.threads.remove(thread);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.MaxFragmentLengthExtensionParserTest.testParseExtensionMessageContent",
	"Comment": "test of parseextensionmessagecontent method, of classmaxfragmentlengthextensionparser.",
	"Method": "void testParseExtensionMessageContent(){\r\n    MaxFragmentLengthExtensionParser parser = new MaxFragmentLengthExtensionParser(start, extension);\r\n    MaxFragmentLengthExtensionMessage msg = parser.parse();\r\n    assertArrayEquals(msg.getExtensionBytes().getValue(), completeExtension);\r\n    assertArrayEquals(type.getValue(), msg.getExtensionType().getValue());\r\n    assertTrue(extensionLength == msg.getExtensionLength().getValue());\r\n    assertTrue(maxFragmentLength == msg.getMaxFragmentLength().getValue());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.occlusion.OcclusionActivity.setDisplayRotation",
	"Comment": "set the color camera background texture rotation and save the camera to display rotation.",
	"Method": "void setDisplayRotation(){\r\n    Display display = getWindowManager().getDefaultDisplay();\r\n    mDisplayRotation = display.getRotation();\r\n    mSurfaceView.queueEvent(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            if (mIsConnected) {\r\n                mRenderer.updateColorCameraTextureUv(mDisplayRotation);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.occlusion.OcclusionActivity.setDisplayRotation",
	"Comment": "set the color camera background texture rotation and save the camera to display rotation.",
	"Method": "void setDisplayRotation(){\r\n    if (mIsConnected) {\r\n        mRenderer.updateColorCameraTextureUv(mDisplayRotation);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.factory.WorkflowConfigurationFactoryTest.testAddStartTlsAction",
	"Comment": "test of addstarttlsaction method, of class workflowconfigurationfactory.",
	"Method": "void testAddStartTlsAction(){\r\n    config.setStarttlsType(StarttlsType.FTP);\r\n    workflowConfigurationFactory = new WorkflowConfigurationFactory(config);\r\n    WorkflowTrace workflowTrace = workflowConfigurationFactory.createWorkflowTrace(WorkflowTraceType.HELLO, RunningModeType.CLIENT);\r\n    Assert.assertEquals(ReceiveAsciiAction.class, workflowTrace.getMessageActions().get(0).getClass());\r\n    Assert.assertEquals(SendAsciiAction.class, workflowTrace.getMessageActions().get(1).getClass());\r\n    Assert.assertEquals(ReceiveAsciiAction.class, workflowTrace.getMessageActions().get(2).getClass());\r\n    config.setStarttlsType(StarttlsType.IMAP);\r\n    workflowConfigurationFactory = new WorkflowConfigurationFactory(config);\r\n    workflowTrace = workflowConfigurationFactory.createWorkflowTrace(WorkflowTraceType.HELLO, RunningModeType.CLIENT);\r\n    Assert.assertEquals(ReceiveAsciiAction.class, workflowTrace.getMessageActions().get(0).getClass());\r\n    Assert.assertEquals(SendAsciiAction.class, workflowTrace.getMessageActions().get(1).getClass());\r\n    Assert.assertEquals(ReceiveAsciiAction.class, workflowTrace.getMessageActions().get(2).getClass());\r\n    Assert.assertEquals(SendAsciiAction.class, workflowTrace.getMessageActions().get(3).getClass());\r\n    Assert.assertEquals(ReceiveAsciiAction.class, workflowTrace.getMessageActions().get(4).getClass());\r\n    config.setStarttlsType(StarttlsType.POP3);\r\n    workflowConfigurationFactory = new WorkflowConfigurationFactory(config);\r\n    workflowTrace = workflowConfigurationFactory.createWorkflowTrace(WorkflowTraceType.HELLO, RunningModeType.CLIENT);\r\n    Assert.assertEquals(ReceiveAsciiAction.class, workflowTrace.getMessageActions().get(0).getClass());\r\n    Assert.assertEquals(SendAsciiAction.class, workflowTrace.getMessageActions().get(1).getClass());\r\n    Assert.assertEquals(ReceiveAsciiAction.class, workflowTrace.getMessageActions().get(2).getClass());\r\n    config.setStarttlsType(StarttlsType.SMTP);\r\n    workflowConfigurationFactory = new WorkflowConfigurationFactory(config);\r\n    workflowTrace = workflowConfigurationFactory.createWorkflowTrace(WorkflowTraceType.HELLO, RunningModeType.CLIENT);\r\n    Assert.assertEquals(ReceiveAsciiAction.class, workflowTrace.getMessageActions().get(0).getClass());\r\n    Assert.assertEquals(SendAsciiAction.class, workflowTrace.getMessageActions().get(1).getClass());\r\n    Assert.assertEquals(ReceiveAsciiAction.class, workflowTrace.getMessageActions().get(2).getClass());\r\n    Assert.assertEquals(ReceiveAsciiAction.class, workflowTrace.getMessageActions().get(3).getClass());\r\n    Assert.assertEquals(ReceiveAsciiAction.class, workflowTrace.getMessageActions().get(4).getClass());\r\n    Assert.assertEquals(ReceiveAsciiAction.class, workflowTrace.getMessageActions().get(5).getClass());\r\n    Assert.assertEquals(SendAsciiAction.class, workflowTrace.getMessageActions().get(6).getClass());\r\n    Assert.assertEquals(ReceiveAsciiAction.class, workflowTrace.getMessageActions().get(7).getClass());\r\n}"
}, {
	"Path": "com.projecttango.examples.java.helloareadescription.HelloAreaDescriptionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.",
	"Method": "void startupTango(){\r\n    ArrayList<TangoCoordinateFramePair> framePairs = new ArrayList<TangoCoordinateFramePair>();\r\n    framePairs.add(new TangoCoordinateFramePair(TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_DEVICE));\r\n    framePairs.add(new TangoCoordinateFramePair(TangoPoseData.COORDINATE_FRAME_AREA_DESCRIPTION, TangoPoseData.COORDINATE_FRAME_DEVICE));\r\n    framePairs.add(new TangoCoordinateFramePair(TangoPoseData.COORDINATE_FRAME_AREA_DESCRIPTION, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE));\r\n    mTango.connectListener(framePairs, new OnTangoUpdateListener() {\r\n        @Override\r\n        public void onPoseAvailable(TangoPoseData pose) {\r\n            synchronized (mSharedLock) {\r\n                if (pose.baseFrame == TangoPoseData.COORDINATE_FRAME_AREA_DESCRIPTION && pose.targetFrame == TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE) {\r\n                    if (pose.statusCode == TangoPoseData.POSE_VALID) {\r\n                        mIsRelocalized = true;\r\n                    } else {\r\n                        mIsRelocalized = false;\r\n                    }\r\n                }\r\n            }\r\n            final double deltaTime = (pose.timestamp - mPreviousPoseTimeStamp) * SECS_TO_MILLISECS;\r\n            mPreviousPoseTimeStamp = pose.timestamp;\r\n            mTimeToNextUpdate -= deltaTime;\r\n            if (mTimeToNextUpdate < 0.0) {\r\n                mTimeToNextUpdate = UPDATE_INTERVAL_MS;\r\n                runOnUiThread(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        synchronized (mSharedLock) {\r\n                            mSaveAdfButton.setEnabled(mIsRelocalized);\r\n                            mRelocalizationTextView.setText(mIsRelocalized ? getString(R.string.localized) : getString(R.string.not_localized));\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        @Override\r\n        public void onXyzIjAvailable(TangoXyzIjData xyzIj) {\r\n        }\r\n        @Override\r\n        public void onPointCloudAvailable(TangoPointCloudData xyzij) {\r\n        }\r\n        @Override\r\n        public void onTangoEvent(final TangoEvent event) {\r\n        }\r\n        @Override\r\n        public void onFrameAvailable(int cameraId) {\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.helloareadescription.HelloAreaDescriptionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.",
	"Method": "void startupTango(){\r\n    synchronized (mSharedLock) {\r\n        if (pose.baseFrame == TangoPoseData.COORDINATE_FRAME_AREA_DESCRIPTION && pose.targetFrame == TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE) {\r\n            if (pose.statusCode == TangoPoseData.POSE_VALID) {\r\n                mIsRelocalized = true;\r\n            } else {\r\n                mIsRelocalized = false;\r\n            }\r\n        }\r\n    }\r\n    final double deltaTime = (pose.timestamp - mPreviousPoseTimeStamp) * SECS_TO_MILLISECS;\r\n    mPreviousPoseTimeStamp = pose.timestamp;\r\n    mTimeToNextUpdate -= deltaTime;\r\n    if (mTimeToNextUpdate < 0.0) {\r\n        mTimeToNextUpdate = UPDATE_INTERVAL_MS;\r\n        runOnUiThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                synchronized (mSharedLock) {\r\n                    mSaveAdfButton.setEnabled(mIsRelocalized);\r\n                    mRelocalizationTextView.setText(mIsRelocalized ? getString(R.string.localized) : getString(R.string.not_localized));\r\n                }\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.helloareadescription.HelloAreaDescriptionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.",
	"Method": "void startupTango(){\r\n    synchronized (mSharedLock) {\r\n        mSaveAdfButton.setEnabled(mIsRelocalized);\r\n        mRelocalizationTextView.setText(mIsRelocalized ? getString(R.string.localized) : getString(R.string.not_localized));\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.helloareadescription.HelloAreaDescriptionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.helloareadescription.HelloAreaDescriptionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.helloareadescription.HelloAreaDescriptionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.helloareadescription.HelloAreaDescriptionActivity.startupTango",
	"Comment": "set up the callback listeners for the tango service and obtain other parameters requiredafter tango connection.",
	"Method": "void startupTango(){\r\n}"
}, {
	"Path": "com.novoda.spikes.arcore.google.rendering.ShaderUtil.loadGLShader",
	"Comment": "converts a raw text file, saved as a resource, into an opengl es shader.",
	"Method": "int loadGLShader(String tag,Context context,int type,String filename){\r\n    String code = readRawTextFileFromAssets(context, filename);\r\n    int shader = GLES20.glCreateShader(type);\r\n    GLES20.glShaderSource(shader, code);\r\n    GLES20.glCompileShader(shader);\r\n    final int[] compileStatus = new int[1];\r\n    GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compileStatus, 0);\r\n    if (compileStatus[0] == 0) {\r\n        Log.e(tag, \"Error compiling shader: \" + GLES20.glGetShaderInfoLog(shader));\r\n        GLES20.glDeleteShader(shader);\r\n        shader = 0;\r\n    }\r\n    if (shader == 0) {\r\n        throw new RuntimeException(\"Error creating shader.\");\r\n    }\r\n    return shader;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.DHClientKeyExchangeSerializerTest.testSerializeHandshakeMessageContent",
	"Comment": "test of serializehandshakemessagecontent method, of classdhclientkeyexchangeserializer.",
	"Method": "void testSerializeHandshakeMessageContent(){\r\n    DHClientKeyExchangeMessage msg = new DHClientKeyExchangeMessage();\r\n    msg.setCompleteResultingMessage(expectedPart);\r\n    msg.setPublicKey(serializedKey);\r\n    msg.setPublicKeyLength(serializedKeyLength);\r\n    msg.setType(type.getValue());\r\n    msg.setLength(length);\r\n    DHClientKeyExchangeSerializer serializer = new DHClientKeyExchangeSerializer(msg, version);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.preparator.ClientHelloPreparatorTest.testPrepareNoCookie",
	"Comment": "test of preparehandshakemessagecontents method, of classclienthellopreparator.",
	"Method": "void testPrepareNoCookie(){\r\n    TimeHelper.setProvider(new FixedTimeProvider(12345678l));\r\n    List<CipherSuite> cipherSuiteList = new LinkedList();\r\n    cipherSuiteList.add(CipherSuite.TLS_DHE_RSA_WITH_SEED_CBC_SHA);\r\n    cipherSuiteList.add(CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256);\r\n    List<CompressionMethod> methodList = new LinkedList();\r\n    methodList.add(CompressionMethod.DEFLATE);\r\n    methodList.add(CompressionMethod.NULL);\r\n    context.getConfig().setDefaultClientSupportedCiphersuites(cipherSuiteList);\r\n    context.getConfig().setDefaultClientSupportedCompressionMethods(methodList);\r\n    context.getConfig().setHighestProtocolVersion(ProtocolVersion.TLS11);\r\n    context.getConfig().setDefaultClientSessionId(new byte[] { 0, 1, 2, 3 });\r\n    preparator.prepare();\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"009AC02B\"), message.getCipherSuites().getValue());\r\n    assertTrue(4 == message.getCipherSuiteLength().getValue());\r\n    assertArrayEquals(ArrayConverter.hexStringToByteArray(\"0100\"), message.getCompressions().getValue());\r\n    assertTrue(2 == message.getCompressionLength().getValue());\r\n    assertNull(message.getCookie());\r\n    assertNull(message.getCookieLength());\r\n    assertArrayEquals(message.getProtocolVersion().getValue(), ProtocolVersion.TLS11.getValue());\r\n    assertArrayEquals(message.getSessionId().getValue(), new byte[] { 0, 1, 2, 3 });\r\n    assertTrue(4 == message.getSessionIdLength().getValue());\r\n    assertArrayEquals(ArrayConverter.longToUint32Bytes(12345678l), message.getUnixTime().getValue());\r\n    assertTrue(message.getExtensionsLength().getValue() == 0);\r\n    assertTrue(message.getExtensionBytes().getValue().length == 0);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.transport.stream.StreamTransportHandlerTest.testInitialize",
	"Comment": "test of initialize method, of class streamtransporthandler.",
	"Method": "void testInitialize(){\r\n    assertFalse(handler.isInitialized());\r\n    handler.initialize();\r\n    assertTrue(handler.isInitialized());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.SessionTicketTLSExtensionParser.parseExtensionMessageContent",
	"Comment": "parses the content of the given byte array to asessiontickettlsextensionmessage",
	"Method": "void parseExtensionMessageContent(SessionTicketTLSExtensionMessage msg){\r\n    if (msg.getExtensionLength().getValue() > 65535) {\r\n        LOGGER.warn(\"The SessionTLS ticket length shouldn't exceed 2 bytes as defined in RFC 4507. \" + \"Length was \" + msg.getExtensionLength().getValue());\r\n    }\r\n    msg.setTicket(parseByteArrayField(msg.getExtensionLength().getValue()));\r\n    LOGGER.debug(\"The session ticket TLS parser parsed the value \" + bytesToHexString(msg.getTicket()));\r\n}"
}, {
	"Path": "com.diffplug.spotless.JarState.withoutTransitives",
	"Comment": "provisions the given maven coordinates without their transitive dependencies.",
	"Method": "JarState withoutTransitives(Collection<String> mavenCoordinates,Provisioner provisioner){\r\n    return provisionWithTransitives(false, mavenCoordinates, provisioner);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.DynamicWorkflowDelegateTest.testApplyDelegate",
	"Comment": "test of applydelegate method, of class dynamicworkflowdelegate.",
	"Method": "void testApplyDelegate(){\r\n    Config config = Config.createConfig();\r\n    config.setDynamicWorkflow(false);\r\n    args = new String[1];\r\n    args[0] = \"-dynamic_workflow\";\r\n    jcommander.parse(args);\r\n    delegate.applyDelegate(config);\r\n    assertTrue(config.isDynamicWorkflow());\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.util.RefreshTag.extractRefreshURL",
	"Comment": "returns a normalised value of the content attribute for the refresh tag",
	"Method": "String extractRefreshURL(String value,String extractRefreshURL,DocumentFragment doc){\r\n    String value;\r\n    try {\r\n        value = (String) expression.evaluate(doc, XPathConstants.STRING);\r\n    } catch (XPathExpressionException e) {\r\n        return null;\r\n    }\r\n    return extractRefreshURL(value);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.ClientAuthenticationDelegateTest.testSetClientAuthentication",
	"Comment": "test of setclientauthentication method, of classclientauthenticationdelegate.",
	"Method": "void testSetClientAuthentication(){\r\n    assertTrue(delegate.isClientAuthentication() == null);\r\n    delegate.setClientAuthentication(true);\r\n    assertTrue(delegate.isClientAuthentication());\r\n}"
}, {
	"Path": "com.amazonaws.cognito.devauthsample.identity.DeviceAuthentication.registerDevice",
	"Comment": "attempts to register the uid, key and username combination. returns trueif successful, false otherwise.",
	"Method": "boolean registerDevice(String uid,String key,String username){\r\n    DeviceInfo device = getDeviceInfo(uid);\r\n    if (device != null && !username.equals(device.getUsername())) {\r\n        return false;\r\n    }\r\n    storeDevice(uid, key, username);\r\n    return true;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetDhModulus",
	"Comment": "test of getserverdhmodulus method, of class defaultchooser.",
	"Method": "void testGetDhModulus(){\r\n    context.setServerDhModulus(null);\r\n    config.setDefaultServerDhModulus(BigInteger.ONE);\r\n    assertEquals(BigInteger.ONE, config.getDefaultServerDhModulus());\r\n    assertEquals(BigInteger.ONE, chooser.getServerDhModulus());\r\n    context.setServerDhModulus(BigInteger.TEN);\r\n    assertEquals(BigInteger.TEN, chooser.getServerDhModulus());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.serializer.CertificateRequestSerializerTest.testSerializeHandshakeMessageContent",
	"Comment": "test of serializehandshakemessagecontent method, of classcertificaterequestserializer.",
	"Method": "void testSerializeHandshakeMessageContent(){\r\n    CertificateRequestMessage message = new CertificateRequestMessage();\r\n    message.setLength(length);\r\n    message.setType(type.getValue());\r\n    message.setClientCertificateTypesCount(certTypesCount);\r\n    message.setClientCertificateTypes(certTypes);\r\n    message.setSignatureHashAlgorithmsLength(sigHashAlgsLength);\r\n    message.setSignatureHashAlgorithms(sigHashAlgs);\r\n    message.setDistinguishedNamesLength(distinguishedNamesLength);\r\n    message.setDistinguishedNames(disitinguishedNames);\r\n    CertificateRequestSerializer serializer = new CertificateRequestSerializer(message, version);\r\n    assertArrayEquals(expectedPart, serializer.serialize());\r\n}"
}, {
	"Path": "org.locationtech.spatial4j.util.GeomBuilder.multiPolygon",
	"Comment": "creates a multipolygon from all polygons on the geometry stack and places the result back on the geometry stack.",
	"Method": "GeomBuilder multiPolygon(){\r\n    gstack.push(factory.createMultiPolygon(gpopAll(Polygon.class)));\r\n    return this;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.meshbuilder.MeshBuilderActivity.updateMeshMap",
	"Comment": "updates the rendered mesh map if a new mesh vector is available.this is run in the opengl thread.",
	"Method": "void updateMeshMap(){\r\n    if (mClearMeshes) {\r\n        mRenderer.clearMeshes();\r\n        mClearMeshes = false;\r\n    }\r\n    if (mMeshVector != null) {\r\n        for (TangoMesh tangoMesh : mMeshVector) {\r\n            if (tangoMesh != null && tangoMesh.numFaces > 0) {\r\n                mRenderer.updateMesh(tangoMesh);\r\n            }\r\n        }\r\n        mMeshVector = null;\r\n    }\r\n}"
}, {
	"Path": "org.sonar.java.ast.parser.grammar.expressions.ExpressionTest.error",
	"Comment": "our grammar accepts such constructions, whereas should not.",
	"Method": "void error(){\r\n    assertThat(JavaLexer.EXPRESSION).matches(\"a = b + 1 = c + 2\");\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void connectRenderer(){\r\n    mRenderer.getCurrentScene().registerFrameCallback(new ASceneFrameCallback() {\r\n        @Override\r\n        public void onPreFrame(long sceneTime, double deltaTime) {\r\n            try {\r\n                synchronized (PlaneFittingActivity.this) {\r\n                    if (!mIsConnected) {\r\n                        return;\r\n                    }\r\n                    if (!mRenderer.isSceneCameraConfigured()) {\r\n                        TangoCameraIntrinsics intrinsics = TangoSupport.getCameraIntrinsicsBasedOnDisplayRotation(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mDisplayRotation);\r\n                        mRenderer.setProjectionMatrix(projectionMatrixFromCameraIntrinsics(intrinsics));\r\n                    }\r\n                    if (mConnectedTextureIdGlThread != mRenderer.getTextureId()) {\r\n                        mTango.connectTextureId(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mRenderer.getTextureId());\r\n                        mConnectedTextureIdGlThread = mRenderer.getTextureId();\r\n                        Log.d(TAG, \"connected to texture id: \" + mRenderer.getTextureId());\r\n                    }\r\n                    if (mIsFrameAvailableTangoThread.compareAndSet(true, false)) {\r\n                        mRgbTimestampGlThread = mTango.updateTexture(TangoCameraIntrinsics.TANGO_CAMERA_COLOR);\r\n                    }\r\n                    if (mRgbTimestampGlThread > mCameraPoseTimestamp) {\r\n                        TangoPoseData lastFramePose = TangoSupport.getPoseAtTime(mRgbTimestampGlThread, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                        if (lastFramePose.statusCode == TangoPoseData.POSE_VALID) {\r\n                            mRenderer.updateRenderCameraPose(lastFramePose);\r\n                            mCameraPoseTimestamp = lastFramePose.timestamp;\r\n                        } else {\r\n                            Log.w(TAG, \"Can't get device pose at time: \" + mRgbTimestampGlThread);\r\n                        }\r\n                        if (mDepthTPlane != null) {\r\n                            TangoSupport.MatrixTransformData openglTDepthArr = TangoSupport.getMatrixTransformAtTime(mPlanePlacedTimestamp, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_DEPTH, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_TANGO, TangoSupport.ROTATION_IGNORED);\r\n                            if (openglTDepthArr.statusCode == TangoPoseData.POSE_VALID) {\r\n                                mRenderer.updateObjectPose(openglTDepthArr.matrix, mDepthTPlane);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } catch (TangoErrorException e) {\r\n                Log.e(TAG, \"Tango API call error within the OpenGL render thread\", e);\r\n            } catch (Throwable t) {\r\n                Log.e(TAG, \"Exception on the OpenGL thread\", t);\r\n            }\r\n        }\r\n        @Override\r\n        public void onPreDraw(long sceneTime, double deltaTime) {\r\n        }\r\n        @Override\r\n        public void onPostFrame(long sceneTime, double deltaTime) {\r\n        }\r\n        @Override\r\n        public boolean callPreFrame() {\r\n            return true;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void connectRenderer(){\r\n    try {\r\n        synchronized (PlaneFittingActivity.this) {\r\n            if (!mIsConnected) {\r\n                return;\r\n            }\r\n            if (!mRenderer.isSceneCameraConfigured()) {\r\n                TangoCameraIntrinsics intrinsics = TangoSupport.getCameraIntrinsicsBasedOnDisplayRotation(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mDisplayRotation);\r\n                mRenderer.setProjectionMatrix(projectionMatrixFromCameraIntrinsics(intrinsics));\r\n            }\r\n            if (mConnectedTextureIdGlThread != mRenderer.getTextureId()) {\r\n                mTango.connectTextureId(TangoCameraIntrinsics.TANGO_CAMERA_COLOR, mRenderer.getTextureId());\r\n                mConnectedTextureIdGlThread = mRenderer.getTextureId();\r\n                Log.d(TAG, \"connected to texture id: \" + mRenderer.getTextureId());\r\n            }\r\n            if (mIsFrameAvailableTangoThread.compareAndSet(true, false)) {\r\n                mRgbTimestampGlThread = mTango.updateTexture(TangoCameraIntrinsics.TANGO_CAMERA_COLOR);\r\n            }\r\n            if (mRgbTimestampGlThread > mCameraPoseTimestamp) {\r\n                TangoPoseData lastFramePose = TangoSupport.getPoseAtTime(mRgbTimestampGlThread, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_COLOR, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n                if (lastFramePose.statusCode == TangoPoseData.POSE_VALID) {\r\n                    mRenderer.updateRenderCameraPose(lastFramePose);\r\n                    mCameraPoseTimestamp = lastFramePose.timestamp;\r\n                } else {\r\n                    Log.w(TAG, \"Can't get device pose at time: \" + mRgbTimestampGlThread);\r\n                }\r\n                if (mDepthTPlane != null) {\r\n                    TangoSupport.MatrixTransformData openglTDepthArr = TangoSupport.getMatrixTransformAtTime(mPlanePlacedTimestamp, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_CAMERA_DEPTH, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_TANGO, TangoSupport.ROTATION_IGNORED);\r\n                    if (openglTDepthArr.statusCode == TangoPoseData.POSE_VALID) {\r\n                        mRenderer.updateObjectPose(openglTDepthArr.matrix, mDepthTPlane);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch (TangoErrorException e) {\r\n        Log.e(TAG, \"Tango API call error within the OpenGL render thread\", e);\r\n    } catch (Throwable t) {\r\n        Log.e(TAG, \"Exception on the OpenGL thread\", t);\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void connectRenderer(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void connectRenderer(){\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.connectRenderer",
	"Comment": "connects the view and renderer to the color camara and callbacks.",
	"Method": "void connectRenderer(){\r\n    return true;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.attacks.bruteforce.IncrementingGuessProviderTest.testGetGuess",
	"Comment": "test of getguess method, of class incrementingguessprovider.",
	"Method": "void testGetGuess(){\r\n    IncrementingGuessProvider provider = new IncrementingGuessProvider();\r\n    for (int i = 0; i < 2048; i++) {\r\n        provider.getGuess();\r\n    }\r\n}"
}, {
	"Path": "org.takes.tk.TkRetryTest.retriesOnExceptionTillCount",
	"Comment": "tkretry can retry when initial take fails oncewith ioexception, till retry count is reached.",
	"Method": "void retriesOnExceptionTillCount(){\r\n    final int count = Tv.THREE;\r\n    final int delay = Tv.THOUSAND;\r\n    final Take take = Mockito.mock(Take.class);\r\n    Mockito.when(take.act(Mockito.any(Request.class))).thenThrow(new IOException());\r\n    final long start = System.nanoTime();\r\n    try {\r\n        new TkRetry(count, delay, take).act(new RqFake(RqMethod.GET));\r\n    } catch (final IOException exception) {\r\n        final long spent = System.nanoTime() - start;\r\n        MatcherAssert.assertThat(new Long(count * delay - Tv.HUNDRED) * Tv.MILLION, Matchers.lessThanOrEqualTo(spent));\r\n        throw exception;\r\n    }\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.spout.FileSpout.setScheme",
	"Comment": "specify a scheme for parsing the lines into urls and metadata.stringtabscheme is used by default. the scheme must generate a string forthe url and a metadata object. if a status field is needed, the schememust generate it.",
	"Method": "void setScheme(Scheme scheme){\r\n    _scheme = scheme;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.UnknownHandshakeHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class unknownhandshakehandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof UnknownHandshakeParser);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.HandshakeMessageParser.hasExtensionLengthField",
	"Comment": "checks if the message has an extensionlength field, by checking if thevalue specified in the length field is big enough to allow it.",
	"Method": "boolean hasExtensionLengthField(T message){\r\n    return message.getLength().getValue() + HandshakeByteLength.MESSAGE_TYPE + HandshakeByteLength.MESSAGE_LENGTH_FIELD > getPointer() - getStartPoint();\r\n}"
}, {
	"Path": "org.springframework.data.neo4j.integration.constructors.PersistenceConstructorsTests.shouldHandleRelationshipInCtor",
	"Comment": "they are populated in a second step, after object instantiation",
	"Method": "void shouldHandleRelationshipInCtor(){\r\n    PersonWithManyToOneRel person = new PersonWithManyToOneRel(\"foo\", new Group(\"ADMIN\"));\r\n    manyToOneRepository.save(person);\r\n    session.clear();\r\n    List<PersonWithManyToOneRel> persons = IterableUtils.toList(manyToOneRepository.findAll());\r\n    assertEquals(1, persons.size());\r\n    assertEquals(\"foo\", persons.get(0).getName());\r\n    assertEquals(\"ADMIN\", persons.get(0).getGroup().getName());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.MaxFragmentLengthExtensionHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class maxfragmentlengthextensionhandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[] { 0, 1, 2, 3 }, 0) instanceof MaxFragmentLengthExtensionParser);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ECDHClientKeyExchangeHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class ecdhclientkeyexchangehandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new ECDHClientKeyExchangeMessage()) instanceof ECDHClientKeyExchangeSerializer);\r\n}"
}, {
	"Path": "com.diffplug.gradle.spotless.FormatExtension.setupTask",
	"Comment": "sets up a format task according to the values in this extension.",
	"Method": "void setupTask(SpotlessTask task){\r\n    task.setPaddedCell(paddedCell);\r\n    task.setEncoding(getEncoding().name());\r\n    task.setExceptionPolicy(exceptionPolicy);\r\n    task.setTarget(target);\r\n    task.setSteps(steps);\r\n    task.setLineEndingsPolicy(getLineEndings().createPolicy(getProject().getProjectDir(), () -> task.target));\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.eclipse.base.osgi.ServiceCollection.getService",
	"Comment": "return service for reference if it belongs to the system bundle.",
	"Method": "S getService(ServiceReference<S> reference,S getService){\r\n    if (systemBundle == reference.getBundle()) {\r\n        return ((FrameworkServiceReference<S>) reference).getService();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.MaxFragmentLengthExtensionParser.parseMaxFragmentLength",
	"Comment": "reads the next bytes as the maxfragmentlength of the extension and writesthem in the message",
	"Method": "void parseMaxFragmentLength(MaxFragmentLengthExtensionMessage msg){\r\n    msg.setMaxFragmentLength(parseByteArrayField(ExtensionByteLength.MAX_FRAGMENT));\r\n    LOGGER.debug(\"MaxFragmentLength: \" + ArrayConverter.bytesToHexString(msg.getMaxFragmentLength().getValue()));\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellovideo.HelloVideoActivity.setDisplayRotation",
	"Comment": "set the color camera background texture rotation and save the camera to display rotation.",
	"Method": "void setDisplayRotation(){\r\n    Display display = getWindowManager().getDefaultDisplay();\r\n    mDisplayRotation = display.getRotation();\r\n    mSurfaceView.queueEvent(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            if (mIsConnected) {\r\n                mRenderer.updateColorCameraTextureUv(mDisplayRotation);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.projecttango.examples.java.hellovideo.HelloVideoActivity.setDisplayRotation",
	"Comment": "set the color camera background texture rotation and save the camera to display rotation.",
	"Method": "void setDisplayRotation(){\r\n    if (mIsConnected) {\r\n        mRenderer.updateColorCameraTextureUv(mDisplayRotation);\r\n    }\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.elasticsearch.bolt.DeletionBolt.getIndexName",
	"Comment": "must be overridden for implementing custom index names based on somemetadata information by default, indexname coming from config is used",
	"Method": "String getIndexName(Metadata m){\r\n    return indexName;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.attacks.pkcs1.oracles.TestPkcs1Oracle.checkSecond",
	"Comment": "returns true if and only if the message contains no 0x00 byte in thefirst 8 bytes of the decrypted text",
	"Method": "boolean checkSecond(byte[] msg){\r\n    boolean result = true;\r\n    for (int i = 1; i < 9; i++) {\r\n        if (msg[i] == 0x00) {\r\n            result = false;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.ECPointFormatExtensionParser.parsePointFormat",
	"Comment": "reads the next bytes as the pointformat of the extension and writes themin the message",
	"Method": "void parsePointFormat(ECPointFormatExtensionMessage msg){\r\n    msg.setPointFormats(parseByteArrayField(msg.getPointFormatsLength().getValue()));\r\n    LOGGER.debug(\"PointFormats: \" + ArrayConverter.bytesToHexString(msg.getPointFormats().getValue()));\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.eclipse.base.osgi.ResourceAccessor.getEntries",
	"Comment": "enumeration of strings that indicate the paths found or null if the path does not exist.",
	"Method": "Enumeration<String> getEntries(String path){\r\n    Enumeration<String> entries = bundleFile.getEntryPaths(getFatJarPath(path));\r\n    if (null == entries) {\r\n        entries = bundleFile.getEntryPaths(path);\r\n    }\r\n    return entries;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.CopyServerRandomActionTest.testExecute",
	"Comment": "test of execute method, of class changeserverrandomaction.",
	"Method": "void testExecute(){\r\n    action.execute(state);\r\n    assertArrayEquals(tlsContextServer1.getServerRandom(), tlsContextServer2.getServerRandom());\r\n    assertArrayEquals(tlsContextServer2.getServerRandom(), new byte[] { 1, 2 });\r\n    assertTrue(action.isExecuted());\r\n}"
}, {
	"Path": "org.takes.tk.TkCorsTest.handleConnectionsWithoutOriginInTheRequest",
	"Comment": "tkcors can handle connections without origin in the request.",
	"Method": "void handleConnectionsWithoutOriginInTheRequest(){\r\n    MatcherAssert.assertThat(\"It was expected to receive a 403 error.\", new TkCors(new TkFixed(new RsText()), \"http://www.netbout.io\", \"http://www.example.com\").act(new RqFake()), new HmRsStatus(HttpURLConnection.HTTP_FORBIDDEN));\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.filtering.URLFilters.fromConf",
	"Comment": "loads and configure the urlfilters based on the storm config if there isone otherwise returns an empty urlfilter.",
	"Method": "URLFilters fromConf(Map stormConf){\r\n    String configFile = ConfUtils.getString(stormConf, \"urlfilters.config.file\");\r\n    if (StringUtils.isNotBlank(configFile)) {\r\n        try {\r\n            return new URLFilters(stormConf, configFile);\r\n        } catch (IOException e) {\r\n            String message = \"Exception caught while loading the URLFilters from \" + configFile;\r\n            LOG.error(message);\r\n            throw new RuntimeException(message, e);\r\n        }\r\n    }\r\n    return URLFilters.emptyURLFilters;\r\n}"
}, {
	"Path": "org.takes.facets.hamcrest.HmHeaderTest.testsHeaderValueNotAvailable",
	"Comment": "hmrqheader can test whether a header value is not available.",
	"Method": "void testsHeaderValueNotAvailable(){\r\n    MatcherAssert.assertThat(new RqFake(Arrays.asList(\"GET /f?a=3\", \"Host: www.example.com\", \"Accept: text/json\"), \"\"), Matchers.not(new HmHeader(\"host\", \"fake.org\")));\r\n}"
}, {
	"Path": "com.projecttango.rajawali.ScenePoseCalculator.toDepthCameraOpenGlPose",
	"Comment": "given the device pose in start of service frame, calculate the position and orientation ofthe depth sensor in opengl coordinate frame.",
	"Method": "Pose toDepthCameraOpenGlPose(TangoPoseData devicePose,DeviceExtrinsics extrinsics){\r\n    Matrix4 startServiceTdevice = tangoPoseToMatrix(devicePose);\r\n    Matrix4 openglTDevice = OPENGL_T_TANGO_WORLD.clone().multiply(startServiceTdevice);\r\n    Matrix4 openglWorldTOpenglCamera = openglTDevice.multiply(extrinsics.getDeviceTDepthCamera());\r\n    return matrixToPose(openglWorldTOpenglCamera);\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPI1Test.testTessBaseAPIAnalyseLayout",
	"Comment": "test of tessbaseapianalyselayout method, of class tessapi1.",
	"Method": "void testTessBaseAPIAnalyseLayout(){\r\n    logger.info(\"TessBaseAPIAnalyseLayout\");\r\n    File image = new File(testResourcesDataPath, \"eurotext.png\");\r\n    int expResult = 12;\r\n    Pix pix = Leptonica1.pixRead(image.getPath());\r\n    TessAPI1.TessBaseAPIInit3(handle, datapath, language);\r\n    TessAPI1.TessBaseAPISetImage2(handle, pix);\r\n    int pageIteratorLevel = TessPageIteratorLevel.RIL_TEXTLINE;\r\n    logger.info(\"PageIteratorLevel: \" + Utils.getConstantName(pageIteratorLevel, TessPageIteratorLevel.class));\r\n    int i = 0;\r\n    TessPageIterator pi = TessAPI1.TessBaseAPIAnalyseLayout(handle);\r\n    do {\r\n        IntBuffer leftB = IntBuffer.allocate(1);\r\n        IntBuffer topB = IntBuffer.allocate(1);\r\n        IntBuffer rightB = IntBuffer.allocate(1);\r\n        IntBuffer bottomB = IntBuffer.allocate(1);\r\n        TessAPI1.TessPageIteratorBoundingBox(pi, pageIteratorLevel, leftB, topB, rightB, bottomB);\r\n        int left = leftB.get();\r\n        int top = topB.get();\r\n        int right = rightB.get();\r\n        int bottom = bottomB.get();\r\n        logger.info(String.format(\"Box[%d]: x=%d, y=%d, w=%d, h=%d\", i++, left, top, right - left, bottom - top));\r\n    } while (TessAPI1.TessPageIteratorNext(pi, pageIteratorLevel) == TRUE);\r\n    TessAPI1.TessPageIteratorDelete(pi);\r\n    PointerByReference pRef = new PointerByReference();\r\n    pRef.setValue(pix.getPointer());\r\n    Leptonica1.pixDestroy(pRef);\r\n    assertEquals(expResult, i);\r\n}"
}, {
	"Path": "com.projecttango.examples.java.planefitting.PlaneFittingActivity.projectionMatrixFromCameraIntrinsics",
	"Comment": "use tango camera intrinsics to calculate the projection matrix for the rajawali scene.",
	"Method": "float[] projectionMatrixFromCameraIntrinsics(TangoCameraIntrinsics intrinsics){\r\n    float near = 0.1f;\r\n    float far = 100;\r\n    double cx = intrinsics.cx;\r\n    double cy = intrinsics.cy;\r\n    double width = intrinsics.width;\r\n    double height = intrinsics.height;\r\n    double fx = intrinsics.fx;\r\n    double fy = intrinsics.fy;\r\n    double xscale = near / fx;\r\n    double yscale = near / fy;\r\n    double xoffset = (cx - (width / 2.0)) * xscale;\r\n    double yoffset = -(cy - (height / 2.0)) * yscale;\r\n    float[] m = new float[16];\r\n    Matrix.frustumM(m, 0, (float) (xscale * -width / 2.0 - xoffset), (float) (xscale * width / 2.0 - xoffset), (float) (yscale * -height / 2.0 - yoffset), (float) (yscale * height / 2.0 - yoffset), near, far);\r\n    return m;\r\n}"
}, {
	"Path": "org.springframework.data.neo4j.transaction.Neo4jTransactionManager.setSessionFactory",
	"Comment": "set the sessionfactory that this instance should manage transactions for.\tby default, a default sessionfactory will be retrieved by finding a single unique bean of type sessionfactory in\tthe containing beanfactory.",
	"Method": "void setSessionFactory(SessionFactory sessionFactory){\r\n    this.sessionFactory = sessionFactory;\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorPlanReconstructionActivity.hasCameraPermission",
	"Comment": "check to see if we have the necessary permissions for this app.",
	"Method": "boolean hasCameraPermission(){\r\n    return ContextCompat.checkSelfPermission(this, CAMERA_PERMISSION) == PackageManager.PERMISSION_GRANTED;\r\n}"
}, {
	"Path": "net.sourceforge.tess4j.TessAPI1Test.testTessBaseAPIGetInitLanguagesAsString",
	"Comment": "test of tessbaseapigetinitlanguagesasstring method, of class tessapi1.",
	"Method": "void testTessBaseAPIGetInitLanguagesAsString(){\r\n    logger.info(\"TessBaseAPIGetInitLanguagesAsString\");\r\n    String expResult = \"\";\r\n    String result = TessAPI1.TessBaseAPIGetInitLanguagesAsString(handle);\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "org.springframework.data.neo4j.transaction.Neo4jTransactionManager.getSessionFactory",
	"Comment": "return the sessionfactory that this instance should manage transactions for.",
	"Method": "SessionFactory getSessionFactory(){\r\n    return this.sessionFactory;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.SupportedVersionsExtensionHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class supportedversionsextensionhandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[] { 0, 2 }, 0) instanceof SupportedVersionsExtensionParser);\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.wrapsIndexOutOfBoundsExceptionFromAdd",
	"Comment": "verboselist should wraps outofboundsexception thrown by add method.",
	"Method": "void wrapsIndexOutOfBoundsExceptionFromAdd(){\r\n    final int index = 5;\r\n    final Object obj = new Object();\r\n    final Exception cause = new IndexOutOfBoundsException();\r\n    Mockito.doThrow(cause).when(this.origin).add(index, obj);\r\n    this.thrown.expect(IndexOutOfBoundsException.class);\r\n    this.thrown.expectMessage(VerboseListTest.MSG);\r\n    this.thrown.expectCause(Matchers.is(cause));\r\n    this.list.add(index, obj);\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.delegatesContains",
	"Comment": "verboselist should delegate contains method to decorated list.",
	"Method": "void delegatesContains(){\r\n    final Object obj = new Object();\r\n    this.list.contains(obj);\r\n    Mockito.verify(this.origin).contains(obj);\r\n}"
}, {
	"Path": "org.takes.misc.VerboseListTest.delegatesClear",
	"Comment": "verboselist should delegate clear method to decorated list.",
	"Method": "void delegatesClear(){\r\n    this.list.clear();\r\n    Mockito.verify(this.origin).clear();\r\n}"
}, {
	"Path": "com.projecttango.examples.java.openglar.OpenGlAugmentedRealityActivity.hasCameraPermission",
	"Comment": "check to see that we have the necessary permissions for this app.",
	"Method": "boolean hasCameraPermission(){\r\n    return ContextCompat.checkSelfPermission(this, CAMERA_PERMISSION) == PackageManager.PERMISSION_GRANTED;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeMasterSecretActionTest.testSetNewValue",
	"Comment": "test of setnewvalue method, of class changeclientrandomaction.",
	"Method": "void testSetNewValue(){\r\n    assertArrayEquals(action.getNewValue(), new byte[] { 0, 1 });\r\n    action.setNewValue(new byte[] { 0 });\r\n    assertArrayEquals(action.getNewValue(), new byte[] { 0 });\r\n}"
}, {
	"Path": "org.springframework.statemachine.support.StateMachineUtils.isTransientPseudoState",
	"Comment": "checks if state is a transient pseudo state, meaning it is a pseudostate\tand its kind indicates that machine will never stay on this state after\trun to completion has finished.",
	"Method": "boolean isTransientPseudoState(State<S, E> state){\r\n    if (state == null) {\r\n        return false;\r\n    }\r\n    PseudoState<S, E> pseudoState = state.getPseudoState();\r\n    if (pseudoState == null) {\r\n        return false;\r\n    }\r\n    PseudoStateKind kind = pseudoState.getKind();\r\n    if (kind == PseudoStateKind.CHOICE || kind == PseudoStateKind.JUNCTION || kind == PseudoStateKind.ENTRY || kind == PseudoStateKind.EXIT || kind == PseudoStateKind.HISTORY_DEEP || kind == PseudoStateKind.HISTORY_SHALLOW || kind == PseudoStateKind.FORK || kind == PseudoStateKind.JOIN) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorPlanReconstructionActivity.updateFloorAndCeiling",
	"Comment": "given the floorplan levels, calculate the ceiling height and the current distance from thedevice to the floor.",
	"Method": "void updateFloorAndCeiling(List<TangoFloorplanLevel> levels){\r\n    if (levels.size() > 0) {\r\n        TangoFloorplanLevel level = levels.get(0);\r\n        float ceilingHeight = level.maxZ - level.minZ;\r\n        final String ceilingHeightText = String.format(\"%.2f\", ceilingHeight);\r\n        TangoPoseData devicePose;\r\n        synchronized (FloorPlanReconstructionActivity.this) {\r\n            if (!mIsConnected) {\r\n                return;\r\n            }\r\n            devicePose = TangoSupport.getPoseAtTime(0.0, TangoPoseData.COORDINATE_FRAME_START_OF_SERVICE, TangoPoseData.COORDINATE_FRAME_DEVICE, TangoSupport.ENGINE_OPENGL, TangoSupport.ENGINE_OPENGL, mDisplayRotation);\r\n        }\r\n        float devToFloorDistance = devicePose.getTranslationAsFloats()[1] - level.minZ;\r\n        final String distanceText = String.format(\"%.2f\", devToFloorDistance);\r\n        runOnUiThread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                mHeightText.setText(ceilingHeightText);\r\n                mDistanceText.setText(distanceText);\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.projecttango.examples.java.floorplanreconstruction.FloorPlanReconstructionActivity.updateFloorAndCeiling",
	"Comment": "given the floorplan levels, calculate the ceiling height and the current distance from thedevice to the floor.",
	"Method": "void updateFloorAndCeiling(List<TangoFloorplanLevel> levels){\r\n    mHeightText.setText(ceilingHeightText);\r\n    mDistanceText.setText(distanceText);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.PskDheServerKeyExchangeParser.parsePskIdentityHint",
	"Comment": "reads the next bytes as the pskidentityhint and writes them in themessage",
	"Method": "void parsePskIdentityHint(PskDheServerKeyExchangeMessage msg){\r\n    msg.setIdentityHint(parseByteArrayField(msg.getIdentityHintLength().getValue()));\r\n    LOGGER.debug(\"SerializedPSK-Identity: \" + ArrayConverter.bytesToHexString(msg.getIdentityHint().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.ECPointFormatExtensionParser.parsePointFormatsLength",
	"Comment": "reads the next bytes as the pointformatslength of the extension andwrites them in the message",
	"Method": "void parsePointFormatsLength(ECPointFormatExtensionMessage msg){\r\n    msg.setPointFormatsLength(parseIntField(ExtensionByteLength.EC_POINT_FORMATS));\r\n    LOGGER.debug(\"PointFormatsLength: \" + msg.getPointFormatsLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.SessionResumptionDelegateTest.testApplyDelegate",
	"Comment": "test of applydelegate method, of class sessionresumptiondelegate.",
	"Method": "void testApplyDelegate(){\r\n    Config config = Config.createConfig();\r\n    args = new String[2];\r\n    args[0] = \"-session_id\";\r\n    args[1] = \"00112233445566778899AABBCCDDEEFF\";\r\n    delegate.setSessionId(null);\r\n    jcommander.parse(args);\r\n    delegate.applyDelegate(config);\r\n    byte[] expected = { (byte) 0x00, (byte) 0x11, (byte) 0x22, (byte) 0x33, (byte) 0x44, (byte) 0x55, (byte) 0x66, (byte) 0x77, (byte) 0x88, (byte) 0x99, (byte) 0xAA, (byte) 0xBB, (byte) 0xCC, (byte) 0xDD, (byte) 0xEE, (byte) 0xFF };\r\n    assertArrayEquals(config.getDefaultClientSessionId(), expected);\r\n    assertArrayEquals(config.getDefaultServerSessionId(), expected);\r\n}"
}, {
	"Path": "org.springframework.statemachine.support.StateMachineUtils.containsAtleastOne",
	"Comment": "checks if right hand collection has atleast one same item as left hand\tcollection.",
	"Method": "boolean containsAtleastOne(Collection<S> left,Collection<S> right){\r\n    if (left == null || right == null) {\r\n        return false;\r\n    }\r\n    for (S id : left) {\r\n        if (right.contains(id)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.PskClientKeyExchangeParser.parsePskIdentityLength",
	"Comment": "reads the next bytes as the pskidentitylength and writes them in themessage",
	"Method": "void parsePskIdentityLength(PskClientKeyExchangeMessage msg){\r\n    msg.setIdentityLength(parseIntField(HandshakeByteLength.PSK_IDENTITY_LENGTH));\r\n    LOGGER.debug(\"PskIdentityLength: \" + msg.getIdentityLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.RSAClientKeyExchangeParserTest.testParse",
	"Comment": "test of parse method, of class rsaclientkeyexchangeparser.",
	"Method": "void testParse(){\r\n    RSAClientKeyExchangeParser<RSAClientKeyExchangeMessage> parser = new RSAClientKeyExchangeParser(0, message, version);\r\n    RSAClientKeyExchangeMessage msg = parser.parse();\r\n    assertArrayEquals(message, msg.getCompleteResultingMessage().getValue());\r\n    assertEquals(length, msg.getLength().getValue().intValue());\r\n    assertEquals(type.getValue(), msg.getType().getValue().byteValue());\r\n    assertEquals(serializedKeyLength, msg.getPublicKeyLength().getValue().intValue());\r\n    assertArrayEquals(serializedKey, msg.getPublicKey().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.SignatureAndHashAlgorithmsExtensionParser.parseSignatureAndHashAlgorithms",
	"Comment": "reads the next bytes as the signatureandhandshakealgorithms of theextension and writes them in the message",
	"Method": "void parseSignatureAndHashAlgorithms(SignatureAndHashAlgorithmsExtensionMessage msg){\r\n    msg.setSignatureAndHashAlgorithms(parseByteArrayField(msg.getSignatureAndHashAlgorithmsLength().getValue()));\r\n    LOGGER.debug(\"SignatureAndHashAlgorithms: \" + ArrayConverter.bytesToHexString(msg.getSignatureAndHashAlgorithms().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.cert.CertificatePairParser.parseExtensions",
	"Comment": "reads the next bytes as the extensions of the certificatepair and writesthem in the message",
	"Method": "void parseExtensions(CertificatePair pair){\r\n    pair.setExtensions(parseByteArrayField(pair.getExtensionsLength().getValue()));\r\n    LOGGER.debug(\"Extensions: \" + ArrayConverter.bytesToHexString(pair.getCertificate().getValue()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.CertificateMessageHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class certificatemessagehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new CertificateMessage()) instanceof CertificateMessagePreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.transport.tcp.timing.TimingClientTcpTransportHandlerTest.testInitialize",
	"Comment": "test of initialize method, of class timingclienttcptransporthandler.",
	"Method": "void testInitialize(){\r\n    ServerSocketChannel serverSocketChannel = null;\r\n    try {\r\n        serverSocketChannel = ServerSocketChannel.open();\r\n        serverSocketChannel.socket().bind(new InetSocketAddress(0));\r\n        serverSocketChannel.configureBlocking(false);\r\n        handler = new TimingClientTcpTransportHandler(100, \"localhost\", serverSocketChannel.socket().getLocalPort());\r\n        handler.initialize();\r\n        SocketChannel acceptChannel = serverSocketChannel.accept();\r\n        assertNotNull(acceptChannel);\r\n        assertTrue(handler.isInitialized());\r\n    } finally {\r\n        if (serverSocketChannel != null) {\r\n            try {\r\n                serverSocketChannel.close();\r\n            } catch (IOException ex) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.digitalpebble.stormcrawler.parse.ParseFilter.needsDOM",
	"Comment": "specifies whether this filter requires a dom representation of thedocument",
	"Method": "boolean needsDOM(){\r\n    return false;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.extension.HeartbeatExtensionHandlerTest.testGetSerializer",
	"Comment": "test of getserializer method, of class heartbeatextensionhandler.",
	"Method": "void testGetSerializer(){\r\n    assertTrue(handler.getSerializer(new HeartbeatExtensionMessage()) instanceof HeartbeatExtensionSerializer);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.ChangeCipherSpecHandlerTest.testAdjustTLSContext",
	"Comment": "test of adjusttlscontext method, of class changecipherspechandler.",
	"Method": "void testAdjustTLSContext(){\r\n    ChangeCipherSpecMessage message = new ChangeCipherSpecMessage();\r\n    context.setRecordLayer(new TlsRecordLayer(context));\r\n    context.setSelectedCipherSuite(CipherSuite.getImplemented().get(0));\r\n    context.setTalkingConnectionEndType(ConnectionEndType.CLIENT);\r\n    handler.adjustTLSContext(message);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.WorkflowInputDelegateTest.testApplyDelegate",
	"Comment": "test of applydelegate method, of class workflowinputdelegate.",
	"Method": "void testApplyDelegate(){\r\n    Config config = Config.createConfig();\r\n    config.setWorkflowInput(null);\r\n    args = new String[2];\r\n    args[0] = \"-workflow_input\";\r\n    args[1] = tempFile.getAbsolutePath();\r\n    jcommander.parse(args);\r\n    assertFalse(config.getWorkflowInput() != null);\r\n    delegate.applyDelegate(config);\r\n    assertTrue(config.getWorkflowInput() != null);\r\n}"
}, {
	"Path": "org.springframework.cloud.consul.config.ConsulPropertySource.parsePropertiesInKeyValueFormat",
	"Comment": "parses the properties in key value style i.e., values are expected to be either a\tsub key or a constant",
	"Method": "void parsePropertiesInKeyValueFormat(List<GetValue> values){\r\n    if (values == null) {\r\n        return;\r\n    }\r\n    for (GetValue getValue : values) {\r\n        String key = getValue.getKey();\r\n        if (!StringUtils.endsWithIgnoreCase(key, \"/\")) {\r\n            key = key.replace(context, \"\").replace('/', '.');\r\n            String value = getValue.getDecodedValue();\r\n            properties.put(key, value);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.DynamicWorkflowDelegateTest.testSetDynamicWorkflow",
	"Comment": "test of setdynamicworkflow method, of class dynamicworkflowdelegate.",
	"Method": "void testSetDynamicWorkflow(){\r\n    assertTrue(delegate.isDynamicWorkflow() == null);\r\n    delegate.setDynamicWorkflow(true);\r\n    assertTrue(delegate.isDynamicWorkflow());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.config.delegate.ClientAuthenticationDelegateTest.testIsClientAuthentication",
	"Comment": "test of isclientauthentication method, of classclientauthenticationdelegate.",
	"Method": "void testIsClientAuthentication(){\r\n    args = new String[1];\r\n    args[0] = \"-client_authentication\";\r\n    assertTrue(delegate.isClientAuthentication() == null);\r\n    jcommander.parse(args);\r\n    assertTrue(delegate.isClientAuthentication());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.HandshakeMessageParser.hasExtensions",
	"Comment": "checks if the extensionslengthfield has a value greater than zero, eg. ifthere are extensions present.",
	"Method": "boolean hasExtensions(T message){\r\n    return message.getExtensionsLength().getValue() > 0;\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ServerHelloParser.parseSessionIDLength",
	"Comment": "reads the next bytes as the sessionidlength and writes them in themessage",
	"Method": "void parseSessionIDLength(SSL2ServerHelloMessage message){\r\n    message.setSessionIDLength(parseIntField(SSL2ByteLength.SESSIONID_LENGTH));\r\n    LOGGER.debug(\"SessionIDLength: \" + message.getSessionIdLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskEcDhClientKeyExchangeHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class pskecdhclientkeyexchangehandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new PskEcDhClientKeyExchangeMessage()) instanceof PskEcDhClientKeyExchangePreparator);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.HeartbeatMessageParser.parsePayload",
	"Comment": "reads the next bytes as the payload and writes them in the message",
	"Method": "void parsePayload(HeartbeatMessage msg){\r\n    msg.setPayload(parseByteArrayField(msg.getPayloadLength().getValue()));\r\n    LOGGER.debug(\"Payload: \" + ArrayConverter.bytesToHexString(msg.getPayload().getValue()));\r\n}"
}, {
	"Path": "studio.carbonylgroup.textfieldboxes.TextFieldBoxes.removeIconSignifier",
	"Comment": "remove the icon by setting the visibility of the image view to view.gone",
	"Method": "void removeIconSignifier(){\r\n    this.iconSignifierResourceId = 0;\r\n    this.iconImageButton.setVisibility(View.GONE);\r\n}"
}, {
	"Path": "com.reacttwitter.MainActivity.getMainComponentName",
	"Comment": "returns the name of the main component registered from javascript.this is used to schedule rendering of the component.",
	"Method": "String getMainComponentName(){\r\n    return \"ReactTwitter\";\r\n}"
}, {
	"Path": "org.springframework.statemachine.support.StateMachineUtils.isNormalPseudoState",
	"Comment": "checks if state is a normal pseudo state, meaning it is a pseudostate\tand its kind is not initial or end.",
	"Method": "boolean isNormalPseudoState(State<S, E> state){\r\n    if (state == null) {\r\n        return false;\r\n    }\r\n    PseudoState<S, E> pseudoState = state.getPseudoState();\r\n    if (pseudoState == null) {\r\n        return false;\r\n    }\r\n    PseudoStateKind kind = pseudoState.getKind();\r\n    if (kind == PseudoStateKind.INITIAL || kind == PseudoStateKind.END) {\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SSL2ClientHelloParser.parseSessionIDLength",
	"Comment": "reads the next bytes as the sessionidlength and writes them in themessage",
	"Method": "void parseSessionIDLength(SSL2ClientHelloMessage msg){\r\n    msg.setSessionIDLength(parseIntField(SSL2ByteLength.SESSIONID_LENGTH));\r\n    LOGGER.debug(\"SessionIDLength: \" + msg.getSessionIdLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.CertificateMessageParser.parseCertificateListBytes",
	"Comment": "reads the next bytes as the certificatebytes and writes them in themessage",
	"Method": "void parseCertificateListBytes(CertificateMessage msg){\r\n    msg.setCertificatesListBytes(parseByteArrayField(msg.getCertificatesListLength().getValue()));\r\n    LOGGER.debug(\"CertificatesListBytes: \" + ArrayConverter.bytesToHexString(msg.getCertificatesListBytes()));\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.chooser.DefaultChooserTest.testGetServerRSAPublicKey",
	"Comment": "test of getserverrsapublickey method, of class defaultchooser.",
	"Method": "void testGetServerRSAPublicKey(){\r\n    context.setServerRSAPublicKey(null);\r\n    config.setDefaultServerRSAPublicKey(BigInteger.ONE);\r\n    assertEquals(BigInteger.ONE, config.getDefaultServerRSAPublicKey());\r\n    assertEquals(BigInteger.ONE, chooser.getServerRSAPublicKey());\r\n    context.setServerRSAPublicKey(BigInteger.TEN);\r\n    assertEquals(BigInteger.TEN, chooser.getServerRSAPublicKey());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.PskServerKeyExchangeHandlerTest.testGetParser",
	"Comment": "test of getparser method, of class pskserverkeyexchangehandler.",
	"Method": "void testGetParser(){\r\n    assertTrue(handler.getParser(new byte[1], 0) instanceof PskServerKeyExchangeParser);\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.SrpServerKeyExchangeParser.parseSerializedPublicKeyLength",
	"Comment": "reads the next bytes as the serializedpublickeylength and writes them inthe message",
	"Method": "void parseSerializedPublicKeyLength(SrpServerKeyExchangeMessage msg){\r\n    msg.setPublicKeyLength(parseIntField(HandshakeByteLength.SRP_PUBLICKEY_LENGTH));\r\n    LOGGER.debug(\"SerializedPublicKeyLength: \" + msg.getPublicKeyLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.SupportedVersionsExtensionParserTest.testParseExtensionMessageContent",
	"Comment": "test of parseextensionmessagecontent method, of classsupportedversionsextensionparser.",
	"Method": "void testParseExtensionMessageContent(){\r\n    SupportedVersionsExtensionParser parser = new SupportedVersionsExtensionParser(start, extension);\r\n    SupportedVersionsExtensionMessage msg = parser.parse();\r\n    assertArrayEquals(msg.getExtensionBytes().getValue(), completeExtension);\r\n    assertArrayEquals(type.getValue(), msg.getExtensionType().getValue());\r\n    assertTrue(extensionLength == msg.getExtensionLength().getValue());\r\n    assertArrayEquals(msg.getSupportedVersions().getValue(), versionList);\r\n    assertTrue(versionListLength == msg.getSupportedVersionsLength().getValue());\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.handler.HelloRequestHandlerTest.testGetPreparator",
	"Comment": "test of getpreparator method, of class hellorequesthandler.",
	"Method": "void testGetPreparator(){\r\n    assertTrue(handler.getPreparator(new HelloRequestMessage()) instanceof HelloRequestPreparator);\r\n}"
}, {
	"Path": "com.diffplug.spotless.StepHarness.testException",
	"Comment": "asserts that the given elements in the resources directory are transformed as expected.",
	"Method": "StepHarness testException(String resourceBefore,Consumer<AbstractThrowableAssert<?, ? extends Throwable>> exceptionAssertion){\r\n    String before = ResourceHarness.getTestResource(resourceBefore);\r\n    try {\r\n        formatter.apply(before);\r\n        Assert.fail();\r\n    } catch (Throwable t) {\r\n        AbstractThrowableAssert<?, ? extends Throwable> abstractAssert = Assertions.assertThat(t);\r\n        exceptionAssertion.accept(abstractAssert);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.sonar.java.collections.AVLTreeTest.do_not_use_subtraction_for_comparison_of_keys",
	"Comment": "subtraction must not be used for comparison of keys due to possibility of integer overflow,this for example will be the case for sequence below, which was generated using random number generator.",
	"Method": "void do_not_use_subtraction_for_comparison_of_keys(){\r\n    Key[] keys = { new Key(2043979982, \"\"), new Key(-36348207, \"\"), new Key(-1864559204, \"\"), new Key(-2018458363, \"\"), new Key(-152409201, \"\"), new Key(-1786252453, \"\"), new Key(-1853960690, \"\") };\r\n    AVLTree<Object, Object> t = AVLTree.create();\r\n    for (Key key : keys) {\r\n        t = t.add(key);\r\n    }\r\n    for (Key key : keys) {\r\n        assertThat(t.get(key)).as(\"found\").isNotNull();\r\n        assertThat(t.remove(key)).as(\"removed\").isNotSameAs(t);\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeProtocolVersionActionTest.testGetNewValue",
	"Comment": "test of getnewvalue method, of class changecompressionaction.",
	"Method": "void testGetNewValue(){\r\n    assertEquals(action.getNewValue(), ProtocolVersion.SSL2);\r\n}"
}, {
	"Path": "studio.carbonylgroup.textfieldboxes.TextFieldBoxes.updateDimens",
	"Comment": "check if the textfieldbox should use a dense spacing,then change the layout dimens accordingly",
	"Method": "void updateDimens(boolean useDenseSpacing){\r\n    final Resources res = getContext().getResources();\r\n    RelativeLayout.LayoutParams lp = (RelativeLayout.LayoutParams) this.floatingLabel.getLayoutParams();\r\n    lp.topMargin = res.getDimensionPixelOffset(useDenseSpacing ? R.dimen.dense_label_idle_margin_top : R.dimen.label_idle_margin_top);\r\n    this.floatingLabel.setLayoutParams(lp);\r\n    this.inputLayout.setPadding(0, res.getDimensionPixelOffset(useDenseSpacing ? R.dimen.dense_editTextLayout_padding_top : R.dimen.editTextLayout_padding_top), 0, res.getDimensionPixelOffset(R.dimen.editTextLayout_padding_bottom));\r\n    this.endIconImageButton.setMinimumHeight(res.getDimensionPixelOffset(useDenseSpacing ? R.dimen.end_icon_min_height : R.dimen.dense_end_icon_min_height));\r\n    this.endIconImageButton.setMinimumWidth(res.getDimensionPixelOffset(useDenseSpacing ? R.dimen.end_icon_min_width : R.dimen.dense_end_icon_min_width));\r\n    this.clearButton.setMinimumHeight(res.getDimensionPixelOffset(useDenseSpacing ? R.dimen.clear_button_min_height : R.dimen.dense_clear_button_min_height));\r\n    this.clearButton.setMinimumWidth(res.getDimensionPixelOffset(useDenseSpacing ? R.dimen.clear_button_min_width : R.dimen.dense_clear_button_min_width));\r\n    lp = (RelativeLayout.LayoutParams) this.bottomPart.getLayoutParams();\r\n    lp.topMargin = res.getDimensionPixelOffset(useDenseSpacing ? R.dimen.dense_bottom_marginTop : R.dimen.bottom_marginTop);\r\n    this.bottomPart.setLayoutParams(lp);\r\n    this.editText.setTextSize(TypedValue.COMPLEX_UNIT_PX, res.getDimension(useDenseSpacing ? R.dimen.dense_edittext_text_size : R.dimen.edittext_text_size));\r\n    this.labelTopMargin = RelativeLayout.LayoutParams.class.cast(this.floatingLabel.getLayoutParams()).topMargin;\r\n    this.requestLayout();\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.protocol.parser.extension.ServerNameIndicationExtensionParser.parseServerNameListBytes",
	"Comment": "reads the next bytes as the servernamelistbytes of the extension andwrites them in the message",
	"Method": "void parseServerNameListBytes(ServerNameIndicationExtensionMessage msg){\r\n    msg.setServerNameListBytes(parseByteArrayField(msg.getServerNameListLength().getValue()));\r\n    LOGGER.debug(\"ServerNameListBytes: \" + ArrayConverter.bytesToHexString(msg.getServerNameListBytes().getValue()));\r\n}"
}, {
	"Path": "org.takes.rq.multipart.RqMtSmartTest.identifiesBoundary",
	"Comment": "rqmtsmart can identify the boundary even if the last content toread before the pattern is an empty line.",
	"Method": "void identifiesBoundary(){\r\n    final int length = 9000;\r\n    final String part = \"foo-1\";\r\n    final String body = Joiner.on(RqMtSmartTest.CRLF).join(\"----foo\", String.format(RqMtSmartTest.CONTENT, part), \"\", StringUtils.repeat(\"F\", length), \"\", \"----foo--\");\r\n    final Request req = new RqFake(Arrays.asList(\"POST /post?foo=3 HTTP/1.1\", \"Host: www.foo.com\", RqMtSmartTest.contentLengthHeader((long) body.getBytes().length), \"Content-Type: multipart/form-data; boundary=--foo\"), body);\r\n    final RqMtSmart regsmart = new RqMtSmart(new RqMtBase(req));\r\n    try {\r\n        MatcherAssert.assertThat(regsmart.single(part).body().available(), Matchers.equalTo(length));\r\n    } finally {\r\n        req.body().close();\r\n        regsmart.part(part).iterator().next().body().close();\r\n    }\r\n}"
}, {
	"Path": "de.rub.nds.tlsattacker.core.workflow.action.ChangeProtocolVersionActionTest.testGetOldValue",
	"Comment": "test of getoldvalue method, of class changecompressionaction.",
	"Method": "void testGetOldValue(){\r\n    tlsContext.setSelectedProtocolVersion(ProtocolVersion.TLS12);\r\n    action.execute(state);\r\n    assertEquals(action.getOldValue(), ProtocolVersion.TLS12);\r\n}"
}, {
	"Path": "com.diffplug.spotless.extra.eclipse.groovy.GrEclipseFormatterStepImplTest.parserException",
	"Comment": "test the handling antlrparserplugin exceptions by groovylogmanager.manager logging",
	"Method": "void parserException(){\r\n    format(PARSER_EXCEPTION, config -> {\r\n    });\r\n}"
}]